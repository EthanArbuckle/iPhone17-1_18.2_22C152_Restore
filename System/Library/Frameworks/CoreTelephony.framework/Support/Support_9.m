void sub_1004D6B94(void *a1)
{
  std::__shared_weak_count *v2;
  uint64_t vars8;

  *a1 = off_1019D7CB0;
  v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    sub_10004D2C8(v2);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 1));

  NetworkConfigInterface::~NetworkConfigInterface((NetworkConfigInterface *)a1);
}

void sub_1004D6BF8(void *a1)
{
  *a1 = off_1019D7CB0;
  v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    sub_10004D2C8(v2);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 1));
  NetworkConfigInterface::~NetworkConfigInterface((NetworkConfigInterface *)a1);

  operator delete();
}

void sub_1004D6C70(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_1004D6CD8(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_1004D6D14(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_1004D6D4C(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_1004D6D7C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

void *sub_1004D6DC0(void *a1)
{
  v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t sub_1004D6E44(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

void sub_1004D6EDC(uint64_t a1@<X0>, void *a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  uint64_t v3 = (char *)operator new(0x130uLL);
  *((void *)v3 + 1) = 0;
  *(void *)uint64_t v3 = off_1019D7F60;
  v14 = v3 + 24;
  *((void *)v3 + 2) = 0;
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&__p, kCtLoggingSystemName, "paireddev");
  initially_inactive = dispatch_queue_attr_make_initially_inactive(0);
  v5 = dispatch_queue_create_with_target_V2("PairedDeviceService", initially_inactive, 0);
  dispatch_set_qos_class_floor(v5, QOS_CLASS_UTILITY, 0);
  dispatch_activate(v5);
  *((void *)v3 + 4) = 0;
  *((void *)v3 + 5) = 0;
  *((void *)v3 + 6) = v5;
  if (v5)
  {
    dispatch_retain(v5);
    *((void *)v3 + 7) = 0;
    dispatch_release(v5);
  }
  else
  {
    *((void *)v3 + 7) = 0;
  }
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)&v19, &__p);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(v3 + 64), (const ctu::OsLogLogger *)&v19);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)&v19);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&__p);
  *((void *)v3 + 3) = off_1019D7DE8;
  CFNotificationCenterRef DistributedCenter = CFNotificationCenterGetDistributedCenter();
  CFNotificationCenterRef v7 = DistributedCenter;
  v8 = *((void *)v3 + 6);
  if (v8)
  {
    dispatch_retain(v8);
    *((void *)v3 + 9) = v7;
    *((void *)v3 + 10) = v8;
    dispatch_retain(v8);
    *((void *)v3 + 12) = 0;
    *((void *)v3 + 13) = 0;
    *((void *)v3 + 11) = v3 + 96;
    dispatch_release(v8);
  }
  else
  {
    *((void *)v3 + 12) = 0;
    *((void *)v3 + 9) = DistributedCenter;
    *((void *)v3 + 10) = 0;
    *((void *)v3 + 13) = 0;
    *((void *)v3 + 11) = v3 + 96;
  }
  v3[232] = 0;
  *((_OWORD *)v3 + 7) = 0u;
  *((_OWORD *)v3 + 10) = 0u;
  *((void *)v3 + 24) = 0;
  *((void *)v3 + 23) = v3 + 192;
  *((void *)v3 + 25) = 0;
  *((_OWORD *)v3 + 8) = 0u;
  *((_OWORD *)v3 + 9) = 0u;
  *((void *)v3 + 22) = 0;
  *((void *)v3 + 27) = 0;
  *((void *)v3 + 26) = v3 + 216;
  *((void *)v3 + 28) = 0;
  v3[256] = 0;
  uint64_t v9 = *(void *)(a1 + 8);
  *((void *)v3 + 33) = *(void *)a1;
  *((void *)v3 + 34) = v9;
  if (v9) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v9 + 8), 1uLL, memory_order_relaxed);
  }
  sub_100058DB0(&__p, "PairedDeviceService");
  v10 = *((void *)v3 + 6);
  v16 = v10;
  if (v10) {
    dispatch_retain(v10);
  }
  v11 = *((void *)v3 + 7);
  object = v11;
  if (v11) {
    dispatch_retain(v11);
  }
  ctu::RestModule::RestModule();
  if (object) {
    dispatch_release(object);
  }
  if (v16) {
    dispatch_release(v16);
  }
  if (v18 < 0) {
    operator delete(__p.var0);
  }
  *((_WORD *)v3 + 148) = 0;
  *a2 = v14;
  a2[1] = v3;
  v12 = (std::__shared_weak_count *)*((void *)v3 + 5);
  if (v12)
  {
    if (v12->__shared_owners_ != -1) {
      goto LABEL_24;
    }
    atomic_fetch_add_explicit((atomic_ullong *volatile)v3 + 1, 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit((atomic_ullong *volatile)v3 + 2, 1uLL, memory_order_relaxed);
    *((void *)v3 + 4) = v14;
    *((void *)v3 + 5) = v3;
    std::__shared_weak_count::__release_weak(v12);
  }
  else
  {
    atomic_fetch_add_explicit((atomic_ullong *volatile)v3 + 1, 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit((atomic_ullong *volatile)v3 + 2, 1uLL, memory_order_relaxed);
    *((void *)v3 + 4) = v14;
    *((void *)v3 + 5) = v3;
  }
  sub_10004D2C8((std::__shared_weak_count *)v3);
LABEL_24:
  __p.var0 = 0;
  __p.var1.fRef = 0;
  Registry::getServiceManager((uint64_t *)&__p, *(Registry **)a1);
  if (__p.var0)
  {
    atomic_fetch_add_explicit((atomic_ullong *volatile)v3 + 1, 1uLL, memory_order_relaxed);
    operator new();
  }
  if (__p.var1.fRef) {
    sub_10004D2C8((std::__shared_weak_count *)__p.var1.fRef);
  }
}

void sub_1004D728C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, ctu::OsLogLogger *a10, uint64_t a11, uint64_t a12, uint64_t a13, PairedDeviceInterface *a14, dispatch_object_t object, dispatch_object_t a16, void *__p, std::__shared_weak_count *a18, int a19, __int16 a20,char a21,char a22,uint64_t a23)
{
  if (a23) {
    (*(void (**)(uint64_t))(*(void *)a23 + 8))(a23);
  }
  if (a18) {
    sub_10004D2C8(a18);
  }
  sub_10004D2C8(v23);
  _Unwind_Resume(a1);
}

BOOL sub_1004D73F8(uint64_t a1)
{
  return !*(unsigned char *)(a1 + 232) || *(void *)(a1 + 208) != *(void *)(a1 + 216);
}

BOOL sub_1004D7418(uint64_t a1)
{
  uint64_t v5 = a1;
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472;
  v6[2] = sub_1004D9210;
  v6[3] = &unk_10199E4C0;
  v6[4] = a1 + 8;
  v6[5] = &v5;
  CFNotificationCenterRef v7 = objc_retainBlock(v6);
  v2 = *(NSObject **)(a1 + 24);
  if (*(void *)(a1 + 32))
  {
    char v14 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v9 = 3221225472;
    v10 = sub_1004D9274;
    v11 = &unk_10199E470;
    v12 = &v14;
    v13 = &v7;
    dispatch_async_and_wait(v2, &block);
  }
  else
  {
    char v14 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v9 = 3221225472;
    v10 = sub_1004D9238;
    v11 = &unk_10199E470;
    v12 = &v14;
    v13 = &v7;
    dispatch_sync(v2, &block);
  }
  BOOL v3 = v14 != 0;

  return v3;
}

void sub_1004D7570(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t v6 = a1;
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 3221225472;
  v7[2] = sub_1004D92B0;
  v7[3] = &unk_10199E4E0;
  v7[4] = a1 + 8;
  v7[5] = &v6;
  v8 = objc_retainBlock(v7);
  v4 = *(NSObject **)(a1 + 24);
  uint64_t v5 = a2 + 1;
  if (*(void *)(a1 + 32))
  {
    void *v5 = 0;
    a2[2] = 0;
    *a2 = v5;
    block = _NSConcreteStackBlock;
    uint64_t v10 = 3221225472;
    v11 = sub_1004D9368;
    v12 = &unk_10199E470;
    v13 = a2;
    char v14 = &v8;
    dispatch_async_and_wait(v4, &block);
  }
  else
  {
    void *v5 = 0;
    a2[2] = 0;
    *a2 = v5;
    block = _NSConcreteStackBlock;
    uint64_t v10 = 3221225472;
    v11 = sub_1004D92C4;
    v12 = &unk_10199E470;
    v13 = a2;
    char v14 = &v8;
    dispatch_sync(v4, &block);
  }
}

char *sub_1004D76C0@<X0>(uint64_t a1@<X0>, void **a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t result = (char *)sub_100046F68(a1 + 184, a2);
  if ((char *)(a1 + 192) == result)
  {
    char v7 = 0;
    *(unsigned char *)a3 = 0;
  }
  else
  {
    if (result[79] < 0)
    {
      uint64_t result = (char *)sub_10004FC84((unsigned char *)a3, *((void **)result + 7), *((void *)result + 8));
    }
    else
    {
      long long v6 = *(_OWORD *)(result + 56);
      *(void *)(a3 + 16) = *((void *)result + 9);
      *(_OWORD *)a3 = v6;
    }
    char v7 = 1;
  }
  *(unsigned char *)(a3 + 24) = v7;
  return result;
}

BOOL sub_1004D7738(uint64_t a1, uint64_t a2)
{
  v6[0] = a1;
  v6[1] = a2;
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 3221225472;
  v7[2] = sub_1004D940C;
  v7[3] = &unk_10199E4C0;
  v7[4] = a1 + 8;
  v7[5] = v6;
  v8 = objc_retainBlock(v7);
  BOOL v3 = *(NSObject **)(a1 + 24);
  if (*(void *)(a1 + 32))
  {
    char v15 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v10 = 3221225472;
    v11 = sub_1004D9274;
    v12 = &unk_10199E470;
    v13 = &v15;
    char v14 = &v8;
    dispatch_async_and_wait(v3, &block);
  }
  else
  {
    char v15 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v10 = 3221225472;
    v11 = sub_1004D9238;
    v12 = &unk_10199E470;
    v13 = &v15;
    char v14 = &v8;
    dispatch_sync(v3, &block);
  }
  BOOL v4 = v15 != 0;

  return v4;
}

BOOL sub_1004D7894(uint64_t a1)
{
  uint64_t v5 = a1;
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472;
  void v6[2] = sub_1004D9444;
  v6[3] = &unk_10199E4C0;
  v6[4] = a1 + 8;
  v6[5] = &v5;
  char v7 = objc_retainBlock(v6);
  v2 = *(NSObject **)(a1 + 24);
  if (*(void *)(a1 + 32))
  {
    char v14 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v9 = 3221225472;
    uint64_t v10 = sub_1004D9274;
    v11 = &unk_10199E470;
    v12 = &v14;
    v13 = &v7;
    dispatch_async_and_wait(v2, &block);
  }
  else
  {
    char v14 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v9 = 3221225472;
    uint64_t v10 = sub_1004D9238;
    v11 = &unk_10199E470;
    v12 = &v14;
    v13 = &v7;
    dispatch_sync(v2, &block);
  }
  BOOL v3 = v14 != 0;

  return v3;
}

void sub_1004D79EC(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = a1;
  sub_1000F0058((uint64_t)&v5, a2);
  BOOL v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (v3)
  {
    if (std::__shared_weak_count::lock(v3)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_1004D7B24(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_10006A6AC(a1);
}

void sub_1004D7B3C(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = a1;
  sub_1000278EC((uint64_t)&v5, a2);
  BOOL v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (v3)
  {
    if (std::__shared_weak_count::lock(v3)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_1004D7C74(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_10006A6AC(a1);
}

void sub_1004D7C8C(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = a1;
  sub_1000278EC((uint64_t)&v5, a2);
  BOOL v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (v3)
  {
    if (std::__shared_weak_count::lock(v3)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_1004D7DC4(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_10006A6AC(a1);
}

void sub_1004D7DDC(uint64_t a1, dispatch_object_t object)
{
  if (object)
  {
    dispatch_retain(object);
    dispatch_group_enter(object);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_1004D7EDC(uint64_t a1)
{
  if ((*(unsigned int (**)(uint64_t))(*(void *)a1 + 16))(a1))
  {
    if (!*(unsigned char *)(a1 + 232))
    {
LABEL_16:
      if (!*(void *)(a1 + 176))
      {
        sub_1004D8144(a1);
      }
      return;
    }
    for (uint64_t i = *(void *)(a1 + 208); i != *(void *)(a1 + 216); i += 32)
    {
      if (!*(unsigned char *)(i + 25)) {
        goto LABEL_16;
      }
    }
  }
  BOOL v3 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    int v4 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
    uint64_t v5 = "false";
    long long v6 = "true";
    if (!v4) {
      long long v6 = "false";
    }
    if (*(unsigned char *)(a1 + 232))
    {
      uint64_t v7 = *(void *)(a1 + 208);
      uint64_t v8 = *(void *)(a1 + 216);
      if (v7 == v8)
      {
        uint64_t v5 = "true";
      }
      else
      {
        uint64_t v5 = "true";
        while (*(unsigned char *)(v7 + 25))
        {
          v7 += 32;
          if (v7 == v8) {
            goto LABEL_22;
          }
        }
        uint64_t v5 = "false";
      }
    }
LABEL_22:
    int v11 = 136315394;
    v12 = v6;
    __int16 v13 = 2080;
    char v14 = v5;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I No more paired devices, remove remote apps, has paired %s, all are tinker %s", (uint8_t *)&v11, 0x16u);
  }
  *(unsigned char *)(a1 + 272) = 0;
  sub_10005CD2C(a1 + 160, *(char **)(a1 + 168));
  *(void *)(a1 + 160) = a1 + 168;
  *(void *)(a1 + 168) = 0;
  uint64_t v10 = *(void **)(a1 + 192);
  uint64_t v9 = (void *)(a1 + 192);
  *(v9 - 2) = 0;
  sub_10010C0E0((uint64_t)(v9 - 1), v10);
  *(v9 - 1) = v9;
  *uint64_t v9 = 0;
  v9[1] = 0;
  sub_1004D80DC(*(v9 - 13), *(v9 - 12));
}

uint64_t sub_1004D80DC(uint64_t result, uint64_t a2)
{
  if (result != a2)
  {
    uint64_t v3 = result;
    do
    {
      uint64_t v4 = *(void *)(v3 + 24);
      if (!v4) {
        sub_10007B600();
      }
      uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)v4 + 48))(v4);
      v3 += 32;
    }
    while (v3 != a2);
  }
  return result;
}

void sub_1004D8144(uint64_t a1)
{
  v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Remote application database updated", buf, 2u);
  }
  *(unsigned char *)(a1 + 272) = 0;
  if (qword_101B0D118[0] != -1) {
    dispatch_once(qword_101B0D118, &stru_1019D7F30);
  }
  if (byte_101B0D110)
  {
    uint64_t v3 = +[ACXDeviceConnection sharedDeviceConnection];
    uint64_t v4 = +[NRPairedDeviceRegistry sharedInstance];
    uint64_t v5 = [v4 getActivePairedDevice];

    long long v6 = [v5 valueForProperty:NRDevicePropertyCellularEnabled];
    unsigned __int8 v7 = [v6 BOOLValue];

    id v8 = [objc_alloc((Class)NSUUID) initWithUUIDString:@"80E387E5-4BC3-421D-873B-080D09375241"];
    unsigned __int8 v9 = [v5 supportsCapability:v8];

    if (v3)
    {
      if (v5)
      {
        v11[0] = _NSConcreteStackBlock;
        v11[1] = 3221225472;
        v11[2] = sub_1004D83B0;
        v11[3] = &unk_1019D7E68;
        uint64_t v14 = a1;
        id v12 = v3;
        id v13 = v5;
        unsigned __int8 v15 = v7;
        unsigned __int8 v16 = v9;
        [v12 enumerateInstalledApplicationsOnPairedDevice:v13 withBlock:v11];
      }
    }
  }
  else
  {
    uint64_t v10 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#N AC runtime not available.", buf, 2u);
    }
  }
}

void sub_1004D8354(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, void *a14)
{
  _Unwind_Resume(a1);
}

BOOL sub_1004D83B0(uint64_t a1, void *a2, void *a3)
{
  unint64_t v5 = a2;
  unint64_t v6 = a3;
  uint64_t v7 = *(void *)(a1 + 48);
  if (v5 | v6)
  {
    uint64_t v13 = *(void *)(a1 + 48);
    id v14 = (id)v5;
    __int16 v15 = *(_WORD *)(a1 + 56);
    v18[0] = _NSConcreteStackBlock;
    v18[1] = 3221225472;
    v18[2] = sub_1004DB6D8;
    v18[3] = &unk_10199E470;
    v18[4] = v7 + 8;
    v18[5] = &v13;
    id v8 = objc_retainBlock(v18);
    unsigned __int8 v9 = *(NSObject **)(v7 + 24);
    if (*(void *)(v7 + 32)) {
      dispatch_async_and_wait(v9, v8);
    }
    else {
      dispatch_sync(v9, v8);
    }
  }
  else
  {
    uint64_t v10 = *(void **)(a1 + 32);
    uint64_t v11 = *(void *)(a1 + 40);
    v16[0] = _NSConcreteStackBlock;
    v16[1] = 3221225472;
    v16[2] = sub_1004D8510;
    v16[3] = &unk_1019D7E40;
    v16[4] = v7;
    __int16 v17 = *(_WORD *)(a1 + 56);
    [v10 enumerateInstallableSystemAppsOnPairedDevice:v11 withBlock:v16];
  }

  return (v5 | v6) != 0;
}

BOOL sub_1004D8510(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  uint64_t v13 = *(void *)(a1 + 32);
  uint64_t v7 = v13;
  id v8 = v5;
  id v14 = v8;
  id v9 = v6;
  id v15 = v9;
  __int16 v16 = *(_WORD *)(a1 + 40);
  v17[0] = _NSConcreteStackBlock;
  v17[1] = 3221225472;
  v17[2] = sub_1004DB3AC;
  v17[3] = &unk_10199E4C0;
  v17[4] = v13 + 8;
  v17[5] = &v13;
  char v18 = objc_retainBlock(v17);
  uint64_t v10 = *(NSObject **)(v7 + 24);
  if (*(void *)(v7 + 32))
  {
    char v25 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v20 = 3221225472;
    v21 = sub_1004D9274;
    v22 = &unk_10199E470;
    v23 = &v25;
    v24 = &v18;
    dispatch_async_and_wait(v10, &block);
  }
  else
  {
    char v25 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v20 = 3221225472;
    v21 = sub_1004D9238;
    v22 = &unk_10199E470;
    v23 = &v25;
    v24 = &v18;
    dispatch_sync(v10, &block);
  }
  BOOL v11 = v25 != 0;

  return v11;
}

BOOL sub_1004D86CC(int a1, char a2, char a3, uint64_t a4)
{
  if (!a1 || (a2 & 1) != 0 || (a3 & 1) != 0) {
    return 0;
  }
  uint64_t v4 = *(unsigned __int8 *)(a4 + 23);
  int v5 = (char)v4;
  if ((v4 & 0x80u) != 0) {
    uint64_t v4 = *(void *)(a4 + 8);
  }
  if (v4 != 28) {
    return 0;
  }
  id v6 = v5 >= 0 ? (uint64_t *)a4 : *(uint64_t **)a4;
  uint64_t v7 = *v6;
  uint64_t v8 = v6[1];
  uint64_t v9 = v6[2];
  int v10 = *((_DWORD *)v6 + 6);
  BOOL v11 = v7 == 0x6C7070612E6D6F63 && v8 == 0x776472616F622E65;
  BOOL v12 = v11 && v9 == 0x637461772E6B6C61;
  return v12 && v10 == 1886413160;
}

void sub_1004D8768(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 176);
  uint64_t v3 = *(NSObject **)(a1 + 40);
  BOOL v4 = os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT);
  if (v2)
  {
    if (v4)
    {
      sub_1000E8F34(*(std::string **)(a1 + 160), (std::string *)(a1 + 168), ", ", 2uLL, (std::string *)__p);
      int v5 = (SBYTE7(v24[0]) & 0x80u) == 0 ? __p : (void **)__p[0];
      *(_DWORD *)buf = 136446210;
      *(void *)&buf[4] = v5;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Paired device remote apps: %{public}s", buf, 0xCu);
      if (SBYTE7(v24[0]) < 0) {
        operator delete(__p[0]);
      }
    }
    uint64_t v37 = 0;
    long long v35 = 0u;
    long long v36 = 0u;
    long long v33 = 0u;
    long long v34 = 0u;
    long long v31 = 0u;
    long long v32 = 0u;
    long long v29 = 0u;
    long long v30 = 0u;
    long long v27 = 0u;
    long long v28 = 0u;
    *(_OWORD *)char v25 = 0u;
    long long v26 = 0u;
    memset(v24, 0, sizeof(v24));
    *(_OWORD *)OsLogContext __p = 0u;
    sub_10004BD84((uint64_t)__p);
    id v6 = *(void **)(a1 + 184);
    if (v6 != (void *)(a1 + 192))
    {
      do
      {
        buf[0] = 123;
        uint64_t v7 = sub_10004B96C(v24, (uint64_t)buf, 1);
        int v8 = *((char *)v6 + 55);
        if (v8 >= 0) {
          uint64_t v9 = (uint64_t)(v6 + 4);
        }
        else {
          uint64_t v9 = v6[4];
        }
        if (v8 >= 0) {
          uint64_t v10 = *((unsigned __int8 *)v6 + 55);
        }
        else {
          uint64_t v10 = v6[5];
        }
        BOOL v11 = sub_10004B96C(v7, v9, v10);
        BOOL v12 = sub_10004B96C(v11, (uint64_t)", ", 2);
        int v13 = *((char *)v6 + 79);
        if (v13 >= 0) {
          uint64_t v14 = (uint64_t)(v6 + 7);
        }
        else {
          uint64_t v14 = v6[7];
        }
        if (v13 >= 0) {
          uint64_t v15 = *((unsigned __int8 *)v6 + 79);
        }
        else {
          uint64_t v15 = v6[8];
        }
        __int16 v16 = sub_10004B96C(v12, v14, v15);
        sub_10004B96C(v16, (uint64_t)"},\n", 3);
        __int16 v17 = (void *)v6[1];
        if (v17)
        {
          do
          {
            char v18 = v17;
            __int16 v17 = (void *)*v17;
          }
          while (v17);
        }
        else
        {
          do
          {
            char v18 = (void *)v6[2];
            BOOL v19 = *v18 == (void)v6;
            id v6 = v18;
          }
          while (!v19);
        }
        id v6 = v18;
      }
      while (v18 != (void *)(a1 + 192));
    }
    uint64_t v20 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
    {
      sub_10004BC98((uint64_t)v24 + 8, buf);
      v21 = v39 >= 0 ? buf : *(unsigned char **)buf;
      *(_DWORD *)v40 = 136446210;
      v41 = v21;
      _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#I Paired device extension mapping:\n%{public}s", v40, 0xCu);
      if (v39 < 0) {
        operator delete(*(void **)buf);
      }
    }
    *(void **)((char *)__p
    *(void *)&v24[0] = v22;
    if (SHIBYTE(v26) < 0) {
      operator delete(v25[1]);
    }
    std::streambuf::~streambuf();
    std::iostream::~basic_iostream();
    std::ios::~ios();
  }
  else if (v4)
  {
    LOWORD(__p[0]) = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I There are no paired devices remote apps", (uint8_t *)__p, 2u);
  }
}

void sub_1004D8B3C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1004D8B60(uint64_t a1)
{
  sub_1004D8CE4(a1);

  operator delete();
}

void sub_1004D8B98(void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  if (v2)
  {
    BOOL v4 = v1[1];
    int v5 = v2;
    if (v4 != v2)
    {
      do
        BOOL v4 = sub_10001E914(v4 - 4);
      while (v4 != v2);
      int v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void sub_1004D8C1C(void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  if (v2)
  {
    BOOL v4 = v1[1];
    int v5 = v2;
    if (v4 != v2)
    {
      do
        BOOL v4 = sub_10003B34C(v4 - 4);
      while (v4 != v2);
      int v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void sub_1004D8CA0(id a1)
{
  uint64_t v1 = NSClassFromString(@"ACXDeviceConnection");
  byte_101B0D110 = v1 != 0;
}

void sub_1004D8CE4(uint64_t a1)
{
  *(void *)a1 = off_1019D7DE8;
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 264);
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 248);
  if (v3) {
    sub_10004D2C8(v3);
  }
  if (*(unsigned char *)(a1 + 232))
  {
    BOOL v4 = (void **)(a1 + 208);
    sub_1000D82FC(&v4);
  }
  sub_10010C0E0(a1 + 184, *(void **)(a1 + 192));
  sub_10005CD2C(a1 + 160, *(char **)(a1 + 168));
  BOOL v4 = (void **)(a1 + 136);
  sub_1004D8B98(&v4);
  BOOL v4 = (void **)(a1 + 112);
  sub_1004D8B98(&v4);
  BOOL v4 = (void **)(a1 + 88);
  sub_1004D8C1C(&v4);
  sub_100F012E8(a1 + 48);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 40));
  sub_100087E88((void *)(a1 + 8));
  PairedDeviceInterface::~PairedDeviceInterface((PairedDeviceInterface *)a1);
}

void sub_1004D8DC4(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1019D7F60;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1004D8DE4(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1019D7F60;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_1004D8E38(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_1004D8E60(ServiceManager::Service *this)
{
  *(void *)this = off_1019D7FB0;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }

  ServiceManager::Service::~Service(this);
}

void sub_1004D8EBC(ServiceManager::Service *this)
{
  *(void *)this = off_1019D7FB0;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  ServiceManager::Service::~Service(this);

  operator delete();
}

void *sub_1004D8F2C@<X0>(void *a1@<X8>)
{
  return sub_100058DB0(a1, "PairedDeviceService");
}

unsigned char *sub_1004D8F3C@<X0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  uint64_t v2 = operator new(1uLL);
  *a1 = v2;
  unsigned char *v2 = 1;
  uint64_t result = v2 + 1;
  a1[1] = result;
  a1[2] = result;
  return result;
}

void sub_1004D8F7C(uint64_t a1, dispatch_object_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v3 = *a2;
  if (*a2)
  {
    dispatch_retain(*a2);
    dispatch_group_enter(v3);
    sub_1004D7DDC(v2, v3);
  }
  uint64_t v4 = *(void *)(a1 + 8);

  sub_1004D7DDC(v4, 0);
}

uint64_t sub_1004D9000()
{
  return 0;
}

uint64_t sub_1004D9008()
{
  return 1;
}

uint64_t sub_1004D9010()
{
  return 0;
}

void sub_1004D901C(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(*(void *)(a1 + 8) + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_1004D90FC(uint64_t a1, int a2, ServiceStage *this)
{
  uint64_t v3 = *(void *)(a1 + 8);
  ServiceStage::holdOffStage((uint64_t *)&group[1], this);
  uint64_t v4 = *(std::__shared_weak_count **)(v3 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

BOOL sub_1004D9210(uint64_t a1)
{
  uint64_t v1 = **(void **)(a1 + 40);
  return *(unsigned char *)(v1 + 272) && *(void *)(v1 + 176) != 0;
}

uint64_t sub_1004D9238(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 40) + 16))();
  **(unsigned char **)(a1 + 32) = result;
  return result;
}

uint64_t sub_1004D9274(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 40) + 16))();
  **(unsigned char **)(a1 + 32) = result;
  return result;
}

uint64_t *sub_1004D92B0@<X0>(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  return sub_1000C6BDC(a2, **(void **)(a1 + 40) + 160);
}

void sub_1004D92C4(uint64_t a1)
{
  (*(void (**)(char ***__return_ptr))(**(void **)(a1 + 40) + 16))(&v7);
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v3 = v2 + 8;
  sub_10005CD2C(v2, *(char **)(v2 + 8));
  *(void *)uint64_t v2 = v7;
  uint64_t v4 = v8;
  *(void *)(v2 + 8) = v8;
  uint64_t v5 = v9;
  *(void *)(v2 + 16) = v9;
  if (v5)
  {
    id v6 = 0;
    *((void *)v4 + 2) = v3;
    uint64_t v7 = &v8;
    int v8 = 0;
    uint64_t v9 = 0;
  }
  else
  {
    *(void *)uint64_t v2 = v3;
    id v6 = v8;
  }
  sub_10005CD2C((uint64_t)&v7, v6);
}

void sub_1004D9368(uint64_t a1)
{
  (*(void (**)(char ***__return_ptr))(**(void **)(a1 + 40) + 16))(&v7);
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v3 = v2 + 8;
  sub_10005CD2C(v2, *(char **)(v2 + 8));
  *(void *)uint64_t v2 = v7;
  uint64_t v4 = v8;
  *(void *)(v2 + 8) = v8;
  uint64_t v5 = v9;
  *(void *)(v2 + 16) = v9;
  if (v5)
  {
    id v6 = 0;
    *((void *)v4 + 2) = v3;
    uint64_t v7 = &v8;
    int v8 = 0;
    uint64_t v9 = 0;
  }
  else
  {
    *(void *)uint64_t v2 = v3;
    id v6 = v8;
  }
  sub_10005CD2C((uint64_t)&v7, v6);
}

BOOL sub_1004D940C(uint64_t a1)
{
  uint64_t v1 = *(uint64_t **)(a1 + 40);
  uint64_t v2 = *v1;
  return v2 + 168 != (void)sub_100046F68(*v1 + 160, (void **)v1[1]);
}

BOOL sub_1004D9444(uint64_t a1)
{
  uint64_t v1 = **(void **)(a1 + 40);
  if (!*(unsigned char *)(v1 + 232)) {
    return 0;
  }
  uint64_t v2 = *(void *)(v1 + 208);
  uint64_t v3 = *(void *)(v1 + 216);
  if (v2 != v3)
  {
    while (!*(unsigned char *)(v2 + 24) || *(unsigned char *)(v2 + 25) == 0)
    {
      v2 += 32;
      if (v2 == v3)
      {
        uint64_t v2 = v3;
        return v2 != v3;
      }
    }
  }
  return v2 != v3;
}

uint64_t *sub_1004D9498(void **a1)
{
  uint64_t v1 = *a1;
  BOOL v19 = a1;
  uint64_t v20 = v1;
  uint64_t v2 = *v1;
  unint64_t v3 = *(void *)(*v1 + 96);
  unint64_t v4 = *(void *)(*v1 + 104);
  if (v3 >= v4)
  {
    uint64_t v6 = *(void *)(v2 + 88);
    uint64_t v7 = (uint64_t)(v3 - v6) >> 5;
    if ((unint64_t)(v7 + 1) >> 59) {
      sub_10006A748();
    }
    uint64_t v8 = v4 - v6;
    uint64_t v9 = v8 >> 4;
    if (v8 >> 4 <= (unint64_t)(v7 + 1)) {
      uint64_t v9 = v7 + 1;
    }
    if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFE0) {
      unint64_t v10 = 0x7FFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v10 = v9;
    }
    uint64_t v24 = *v1 + 104;
    if (v10)
    {
      if (v10 >> 59) {
        sub_10006A7CC();
      }
      BOOL v11 = (char *)operator new(32 * v10);
    }
    else
    {
      BOOL v11 = 0;
    }
    v21 = v11;
    v22.i64[0] = (uint64_t)&v11[32 * v7];
    v22.i64[1] = v22.i64[0];
    v23 = &v11[32 * v10];
    sub_1000F0058(v22.i64[0], (uint64_t)(v1 + 1));
    uint64_t v12 = v22.i64[0];
    uint64_t v5 = v22.i64[0] + 32;
    uint64_t v14 = *(void *)(v2 + 88);
    unint64_t v13 = *(void *)(v2 + 96);
    if (v13 == v14)
    {
      int64x2_t v15 = vdupq_n_s64(v13);
    }
    else
    {
      do
      {
        v13 -= 32;
        uint64_t v12 = sub_1000DA470(v12 - 32, v13);
      }
      while (v13 != v14);
      int64x2_t v15 = *(int64x2_t *)(v2 + 88);
    }
    *(void *)(v2 + 88) = v12;
    *(void *)(v2 + 96) = v5;
    int64x2_t v22 = v15;
    __int16 v16 = *(char **)(v2 + 104);
    *(void *)(v2 + 104) = v23;
    v23 = v16;
    v21 = (char *)v15.i64[0];
    sub_1004D9678((uint64_t)&v21);
  }
  else
  {
    sub_1000F0058(*(void *)(*v1 + 96), (uint64_t)(v1 + 1));
    uint64_t v5 = v3 + 32;
    *(void *)(v2 + 96) = v5;
  }
  *(void *)(v2 + 96) = v5;
  if (*(unsigned char *)(v2 + 272) && *(void *)(v2 + 176))
  {
    uint64_t v17 = v1[4];
    if (!v17) {
      sub_10007B600();
    }
    (*(void (**)(uint64_t))(*(void *)v17 + 48))(v17);
  }
  sub_10033515C((uint64_t *)&v20);
  return sub_100046B58((uint64_t *)&v19);
}

void sub_1004D9640(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, void);
  va_copy(va2, va1);
  uint64_t v5 = va_arg(va2, void);
  sub_1004D9678((uint64_t)va2);
  sub_10033515C((uint64_t *)va1);
  sub_100046B58((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1004D9678(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 32;
    sub_10003B34C((void *)(i - 32));
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t *sub_1004D96C8(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v3 = a1;
  uint64_t v4 = v1;
  sub_1004D972C((uint64_t *)(*(void *)v1 + 112), v1 + 8);
  sub_1004931DC(&v4);
  return sub_100046B58((uint64_t *)&v3);
}

void sub_1004D9710(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

uint64_t sub_1004D972C(uint64_t *a1, uint64_t a2)
{
  unint64_t v4 = a1[2];
  unint64_t v5 = a1[1];
  if (v5 >= v4)
  {
    uint64_t v8 = (uint64_t)(v5 - *a1) >> 5;
    if ((unint64_t)(v8 + 1) >> 59) {
      sub_10006A748();
    }
    uint64_t v9 = v4 - *a1;
    uint64_t v10 = v9 >> 4;
    if (v9 >> 4 <= (unint64_t)(v8 + 1)) {
      uint64_t v10 = v8 + 1;
    }
    if ((unint64_t)v9 >= 0x7FFFFFFFFFFFFFE0) {
      unint64_t v11 = 0x7FFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v11 = v10;
    }
    v21 = a1 + 2;
    if (v11)
    {
      if (v11 >> 59) {
        sub_10006A7CC();
      }
      uint64_t v12 = (char *)operator new(32 * v11);
    }
    else
    {
      uint64_t v12 = 0;
    }
    char v18 = v12;
    v19.i64[0] = (uint64_t)&v12[32 * v8];
    v19.i64[1] = v19.i64[0];
    uint64_t v20 = &v12[32 * v11];
    sub_1000278EC(v19.i64[0], a2);
    uint64_t v13 = v19.i64[0];
    uint64_t v7 = v19.i64[0] + 32;
    uint64_t v15 = *a1;
    unint64_t v14 = a1[1];
    if (v14 == *a1)
    {
      int64x2_t v16 = vdupq_n_s64(v14);
    }
    else
    {
      do
      {
        v14 -= 32;
        uint64_t v13 = sub_1000279CC(v13 - 32, v14);
      }
      while (v14 != v15);
      int64x2_t v16 = *(int64x2_t *)a1;
    }
    *a1 = v13;
    a1[1] = v7;
    int64x2_t v19 = v16;
    uint64_t v17 = (char *)a1[2];
    a1[2] = (uint64_t)v20;
    uint64_t v20 = v17;
    char v18 = (char *)v16.i64[0];
    uint64_t result = sub_1004D9888((uint64_t)&v18);
  }
  else
  {
    uint64_t result = sub_1000278EC(a1[1], a2);
    uint64_t v7 = v5 + 32;
    a1[1] = v7;
  }
  a1[1] = v7;
  return result;
}

void sub_1004D9868(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1004D9888((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1004D9888(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 32;
    sub_10001E914((void *)(i - 32));
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t *sub_1004D98D8(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v3 = a1;
  uint64_t v4 = v1;
  sub_1004D972C((uint64_t *)(*(void *)v1 + 136), v1 + 8);
  sub_1004931DC(&v4);
  return sub_100046B58((uint64_t *)&v3);
}

void sub_1004D9920(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

uint64_t *sub_1004D993C(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v3 = a1;
  uint64_t v4 = v1;
  ctu::RestModule::disconnect((ctu::RestModule *)(*(void *)v1 + 256));
  sub_100088C88(&v4);
  return sub_100046B58((uint64_t *)&v3);
}

void sub_1004D9984(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

uint64_t *sub_1004D99A0(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v7 = a1;
  uint64_t v8 = v1;
  uint64_t v2 = *(uint64_t **)v1;
  Registry::createRestModuleOneTimeUseConnection(&v10, *(Registry **)(*(void *)v1 + 240));
  ctu::RestModule::connect();
  if (v11) {
    sub_10004D2C8(v11);
  }
  sub_100058DB0(__p, "/cc/props/paired_device");
  uint64_t v3 = operator new(0x28uLL);
  *uint64_t v3 = off_1019D8030;
  v3[1] = v2 + 26;
  v3[2] = v2;
  v3[3] = sub_1004D7EDC;
  v3[4] = 0;
  uint64_t v17 = v3;
  ctu::RestModule::observeProperty();
  sub_10003F600(v16);
  if (v14 < 0) {
    operator delete(__p[0]);
  }
  sub_100058DB0(__p, "/cc/events/dump_state");
  uint64_t v4 = operator new(0x20uLL);
  void *v4 = off_1019D80B0;
  v4[1] = v2;
  v4[2] = sub_1004D8768;
  v4[3] = 0;
  uint64_t v17 = v4;
  ctu::RestModule::observeEvent();
  sub_10003F600(v16);
  if (v14 < 0) {
    operator delete(__p[0]);
  }
  v16[0] = off_1019D8130;
  v16[1] = v2;
  uint64_t v17 = v16;
  sub_100F017C8(v2 + 6, ACXRemoteApplicationDatabaseResyncedDistributedNotification, (uint64_t)v16);
  sub_1001472DC(v16);
  __p[0] = off_1019D81B0;
  __p[1] = v2;
  uint64_t v15 = __p;
  sub_100F017C8(v2 + 6, ACXRemoteApplicationsInstalledDistributedNotification, (uint64_t)__p);
  sub_1001472DC(__p);
  v12[0] = off_1019D8230;
  v12[1] = v2;
  v12[3] = v12;
  sub_100F017C8(v2 + 6, ACXRemoteApplicationsUninstalledDistributedNotification, (uint64_t)v12);
  sub_1001472DC(v12);
  unint64_t v5 = v2[5];
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Remote application database updates registered", buf, 2u);
  }
  sub_100088C88(&v8);
  return sub_100046B58((uint64_t *)&v7);
}

void sub_1004D9C38(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
}

void sub_1004D9CC4()
{
}

__n128 sub_1004D9CD8(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_1019D8030;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_1004D9D2C(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019D8030;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_1004D9D64(void *a1)
{
  rest::read_rest_value();
  uint64_t v2 = (uint64_t (*)(void *))a1[3];
  uint64_t v3 = a1[4];
  uint64_t v4 = (void *)(a1[2] + (v3 >> 1));
  if (v3) {
    uint64_t v2 = *(uint64_t (**)(void *))(*v4 + v2);
  }

  return v2(v4);
}

uint64_t sub_1004D9DE0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1004D9E20()
{
}

void sub_1004D9E30()
{
}

__n128 sub_1004D9E44(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_1019D80B0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_1004D9E98(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019D80B0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_1004D9ED0(void *a1)
{
  uint64_t v1 = (uint64_t (*)(void *))a1[2];
  uint64_t v2 = a1[3];
  uint64_t v3 = (void *)(a1[1] + (v2 >> 1));
  if (v2) {
    return (*(uint64_t (**)(void))(*v3 + v1))();
  }
  else {
    return v1(v3);
  }
}

uint64_t sub_1004D9F18(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1004D9F58()
{
}

void sub_1004D9F68()
{
}

void *sub_1004D9F7C(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_1019D8130;
  result[1] = v3;
  return result;
}

uint64_t sub_1004D9FC4(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019D8130;
  a2[1] = v2;
  return result;
}

void sub_1004D9FF0(uint64_t a1, void **a2)
{
  uint64_t v3 = *a2;
  *a2 = xpc_null_create();
  sub_1004D8144(*(void *)(a1 + 8));
  xpc_release(v3);
}

void sub_1004DA03C(_Unwind_Exception *a1)
{
  xpc_release(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1004DA058(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1004DA098()
{
}

void sub_1004DA0A8()
{
}

void *sub_1004DA0BC(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_1019D81B0;
  result[1] = v3;
  return result;
}

uint64_t sub_1004DA104(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019D81B0;
  a2[1] = v2;
  return result;
}

void sub_1004DA130(uint64_t a1, void **a2)
{
  uint64_t v3 = *a2;
  *a2 = xpc_null_create();
  uint64_t v4 = *(void *)(a1 + 8);
  xpc_object_t v39 = v3;
  if (v3) {
    xpc_retain(v3);
  }
  else {
    xpc_object_t v39 = xpc_null_create();
  }
  xpc_object_t object = 0;
  long long v50 = 0uLL;
  uint64_t v51 = 0;
  ctu::cf::assign();
  *(_OWORD *)OsLogContext __p = 0u;
  *(void *)&long long v43 = 0;
  buf.__r_.__value_.__r.__words[0] = (std::string::size_type)&v39;
  buf.__r_.__value_.__l.__size_ = (std::string::size_type)__p;
  sub_10005107C((uint64_t)&buf, &object);
  if (SBYTE7(v43) < 0) {
    operator delete(__p[0]);
  }
  __p[0] = object;
  if (object) {
    xpc_retain(object);
  }
  else {
    __p[0] = xpc_null_create();
  }
  xpc::bridge((uint64_t *)&v50, (xpc *)__p, v5);
  uint64_t v6 = (void *)v50;
  *(void *)&long long v50 = 0;
  sub_1000577C4((const void **)&v50);
  xpc_release(__p[0]);
  if (!v6)
  {
    long long v29 = *(NSObject **)(v4 + 40);
    if (!os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_52;
    }
    LOWORD(v50) = 0;
    long long v30 = "#N Remote App Installed notification does not contain any bundleIds";
    long long v31 = v29;
    uint32_t v32 = 2;
LABEL_51:
    _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, v30, (uint8_t *)&v50, v32);
    goto LABEL_52;
  }
  if (!*(void *)(v4 + 176))
  {
    long long v33 = *(NSObject **)(v4 + 40);
    if (!os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_52;
    }
    LODWORD(v50) = 138412290;
    *(void *)((char *)&v50 + 4) = v6;
    long long v30 = "#I Remote app db has not been initialized yet.  %@ should be enumerated when the remote app db is updated.";
    long long v31 = v33;
    uint32_t v32 = 12;
    goto LABEL_51;
  }
  long long v34 = v6;
  long long v36 = +[ACXDeviceConnection sharedDeviceConnection];
  xpc_object_t v46 = 0;
  long long v50 = 0uLL;
  uint64_t v51 = 0;
  ctu::cf::assign();
  *(_OWORD *)OsLogContext __p = v50;
  *(void *)&long long v43 = v51;
  uint64_t v7 = (void **)v50;
  if (v51 >= 0) {
    uint64_t v7 = __p;
  }
  buf.__r_.__value_.__r.__words[0] = (std::string::size_type)&v39;
  buf.__r_.__value_.__l.__size_ = (std::string::size_type)v7;
  sub_100048BAC((uint64_t)&buf, &v46);
  if (SBYTE7(v43) < 0) {
    operator delete(__p[0]);
  }
  id v8 = objc_alloc((Class)NSUUID);
  xpc::bridge((uint64_t *)&v50, (xpc *)&v46, v9);
  uint64_t v10 = (void *)v50;
  *(void *)&long long v50 = 0;
  id v37 = [v8 initWithUUIDString:v10];

  sub_1000577C4((const void **)&v50);
  unint64_t v11 = +[NRPairedDeviceRegistry sharedInstance];
  long long v35 = [v11 getActivePairedDevice];

  uint64_t v12 = [v35 valueForProperty:NRDevicePropertyCellularEnabled];
  char v13 = [v12 BOOLValue];

  id v14 = [objc_alloc((Class)NSUUID) initWithUUIDString:@"80E387E5-4BC3-421D-873B-080D09375241"];
  char v15 = [v35 supportsCapability:v14];

  long long v44 = 0u;
  long long v45 = 0u;
  *(_OWORD *)OsLogContext __p = 0u;
  long long v43 = 0u;
  id obj = v6;
  int64x2_t v16 = (char *)[obj countByEnumeratingWithState:__p objects:&v50 count:16];
  if (v16)
  {
    uint64_t v17 = *(void *)v43;
    do
    {
      for (uint64_t i = 0; i != v16; ++i)
      {
        if (*(void *)v43 != v17) {
          objc_enumerationMutation(obj);
        }
        uint64_t v19 = *((void *)__p[1] + i);
        memset(&__str, 0, sizeof(__str));
        memset(&buf, 0, sizeof(buf));
        ctu::cf::assign();
        std::string __str = buf;
        if (sub_1004D86CC(*(unsigned char *)(v4 + 273) != 0, v13, v15, (uint64_t)&__str))
        {
          uint64_t v20 = *(NSObject **)(v4 + 40);
          if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
          {
            LOWORD(buf.__r_.__value_.__l.__data_) = 0;
            _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#N Temporarily ignoring app", (uint8_t *)&buf, 2u);
          }
        }
        else
        {
          sub_1000F29CC((uint64_t **)(v4 + 160), (void **)&__str.__r_.__value_.__l.__data_, (uint64_t)&__str);
          v21 = [v36 applicationOnDeviceWithPairingID:v37 withBundleID:v19 error:0];
          int64x2_t v22 = v21;
          if (v21)
          {
            id v23 = [v21 watchKitAppExtensionBundleID];
            uint64_t v24 = (char *)[v23 UTF8String];

            if (v24)
            {
              sub_100058DB0(&buf, v24);
              p_std::string buf = &buf;
              char v25 = sub_100327F4C((uint64_t **)(v4 + 184), (void **)&buf.__r_.__value_.__l.__data_, (uint64_t)&unk_10144E20E, (_OWORD **)&p_buf);
              std::string::operator=((std::string *)((char *)v25 + 56), &__str);
              if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
                operator delete(buf.__r_.__value_.__l.__data_);
              }
            }
          }
          if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
            sub_10004FC84(&__dst, __str.__r_.__value_.__l.__data_, __str.__r_.__value_.__l.__size_);
          }
          else {
            std::string __dst = __str;
          }
          uint64_t v26 = *(void *)(v4 + 112);
          uint64_t v27 = *(void *)(v4 + 120);
          while (v26 != v27)
          {
            if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
              sub_10004FC84(&buf, __dst.__r_.__value_.__l.__data_, __dst.__r_.__value_.__l.__size_);
            }
            else {
              std::string buf = __dst;
            }
            uint64_t v28 = *(void *)(v26 + 24);
            if (!v28) {
              sub_10007B600();
            }
            (*(void (**)(uint64_t, std::string *))(*(void *)v28 + 48))(v28, &buf);
            if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(buf.__r_.__value_.__l.__data_);
            }
            v26 += 32;
          }
          if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(__dst.__r_.__value_.__l.__data_);
          }
        }
        if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__str.__r_.__value_.__l.__data_);
        }
      }
      int64x2_t v16 = (char *)[obj countByEnumeratingWithState:__p objects:&v50 count:16];
    }
    while (v16);
  }

  xpc_release(v46);
  uint64_t v6 = v34;
LABEL_52:

  xpc_release(object);
  xpc_release(v39);
  xpc_release(v3);
}

void sub_1004DA720(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, xpc_object_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, xpc_object_t a18, uint64_t a19, uint64_t a20,int a21,__int16 a22,char a23,char a24,uint64_t a25,char a26,uint64_t a27,int a28,__int16 a29,char a30,char a31,uint64_t a32,xpc_object_t __p,uint64_t a34,int a35,__int16 a36,char a37,char a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,xpc_object_t object,xpc_object_t a45,uint64_t a46,uint64_t a47,void *a48,uint64_t a49,int a50,__int16 a51,char a52,char a53)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1004DA92C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1004DA96C()
{
}

void sub_1004DA97C()
{
}

void *sub_1004DA990(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_1019D8230;
  result[1] = v3;
  return result;
}

uint64_t sub_1004DA9D8(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019D8230;
  a2[1] = v2;
  return result;
}

void sub_1004DAA04(uint64_t a1, void **a2)
{
  uint64_t v3 = *a2;
  *a2 = xpc_null_create();
  uint64_t v4 = *(void *)(a1 + 8);
  xpc_object_t v42 = v3;
  if (v3) {
    xpc_retain(v3);
  }
  else {
    xpc_object_t v42 = xpc_null_create();
  }
  xpc_object_t object = 0;
  *(void *)v56 = 0;
  uint64_t v57 = 0;
  uint64_t v58 = 0;
  long long v34 = v3;
  ctu::cf::assign();
  *(_OWORD *)OsLogContext __p = 0u;
  *(void *)&long long v50 = 0;
  *(void *)&long long buf = &v42;
  *((void *)&buf + 1) = __p;
  sub_10005107C((uint64_t)&buf, &object);
  if (SBYTE7(v50) < 0) {
    operator delete(__p[0]);
  }
  __p[0] = object;
  if (object) {
    xpc_retain(object);
  }
  else {
    __p[0] = xpc_null_create();
  }
  xpc::bridge((uint64_t *)v56, (xpc *)__p, v5);
  uint64_t v6 = *(void **)v56;
  *(void *)v56 = 0;
  sub_1000577C4((const void **)v56);
  xpc_release(__p[0]);
  if (v6)
  {
    uint64_t v7 = +[NRPairedDeviceRegistry sharedInstance];
    long long v33 = [v7 getActivePairedDevice];

    id v8 = [v33 valueForProperty:NRDevicePropertyCellularEnabled];
    char v9 = [v8 BOOLValue];

    id v10 = [objc_alloc((Class)NSUUID) initWithUUIDString:@"80E387E5-4BC3-421D-873B-080D09375241"];
    id v11 = [v33 supportsCapability:v10];

    long long v51 = 0u;
    long long v52 = 0u;
    *(_OWORD *)OsLogContext __p = 0u;
    long long v50 = 0u;
    id obj = v6;
    uint64_t v12 = (char *)[obj countByEnumeratingWithState:__p objects:v56 count:16];
    if (v12)
    {
      id v37 = (uint64_t **)(v4 + 160);
      v40 = (uint64_t **)(v4 + 184);
      uint64_t v41 = *(void *)v50;
      char v13 = (uint64_t *)(v4 + 192);
      char v36 = v9;
      uint64_t v35 = v4;
      do
      {
        id v14 = 0;
        v38 = v12;
        do
        {
          if (*(void *)v50 != v41) {
            objc_enumerationMutation(obj);
          }
          v47[0] = 0;
          v47[1] = 0;
          uint64_t v48 = 0;
          long long buf = 0uLL;
          uint64_t v55 = 0;
          ctu::cf::assign();
          *(_OWORD *)v47 = buf;
          uint64_t v48 = v55;
          if (sub_1004D86CC(*(unsigned char *)(v4 + 273) != 0, v9, (char)v11, (uint64_t)v47))
          {
            char v15 = *(NSObject **)(v4 + 40);
            if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
            {
              LOWORD(buf) = 0;
              _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#N Temporarily ignoring app", (uint8_t *)&buf, 2u);
            }
          }
          else
          {
            sub_1000E9358(v37, v47);
            id v16 = v11;
            uint64_t v17 = v6;
            char v18 = *v40;
            if (SHIBYTE(v48) < 0)
            {
              sub_10004FC84(__dst, v47[0], (unint64_t)v47[1]);
            }
            else
            {
              *(_OWORD *)std::string __dst = *(_OWORD *)v47;
              uint64_t v46 = v48;
            }
            char v19 = HIBYTE(v46);
            uint64_t v20 = v13;
            if (v18 != v13)
            {
              if (v46 >= 0) {
                v21 = (void *)HIBYTE(v46);
              }
              else {
                v21 = __dst[1];
              }
              if (v46 >= 0) {
                int64x2_t v22 = __dst;
              }
              else {
                int64x2_t v22 = (void **)__dst[0];
              }
              uint64_t v20 = v18;
              do
              {
                uint64_t v23 = *((unsigned __int8 *)v20 + 79);
                if ((v23 & 0x80u) == 0) {
                  uint64_t v24 = (void *)*((unsigned __int8 *)v20 + 79);
                }
                else {
                  uint64_t v24 = (void *)v20[8];
                }
                if (v24 == v21)
                {
                  if ((v23 & 0x80) != 0)
                  {
                    if (!memcmp((const void *)v20[7], v22, v20[8])) {
                      goto LABEL_47;
                    }
                  }
                  else
                  {
                    if (!*((unsigned char *)v20 + 79)) {
                      goto LABEL_47;
                    }
                    uint64_t v25 = 0;
                    while (*((unsigned __int8 *)v20 + v25 + 56) == *((unsigned __int8 *)v22 + v25))
                    {
                      if (v23 == ++v25) {
                        goto LABEL_47;
                      }
                    }
                  }
                }
                uint64_t v26 = (uint64_t *)v20[1];
                if (v26)
                {
                  do
                  {
                    uint64_t v27 = v26;
                    uint64_t v26 = (uint64_t *)*v26;
                  }
                  while (v26);
                }
                else
                {
                  do
                  {
                    uint64_t v27 = (uint64_t *)v20[2];
                    BOOL v28 = *v27 == (void)v20;
                    uint64_t v20 = v27;
                  }
                  while (!v28);
                }
                uint64_t v20 = v27;
              }
              while (v27 != v13);
              uint64_t v20 = v13;
LABEL_47:
              uint64_t v3 = v34;
            }
            if (v19 < 0) {
              operator delete(__dst[0]);
            }
            uint64_t v6 = v17;
            if (v20 != v13)
            {
              sub_10006C514(v40, v20);
              sub_1000FECD4((uint64_t)(v20 + 4));
              operator delete(v20);
            }
            char v9 = v36;
            id v11 = v16;
            if (SHIBYTE(v48) < 0)
            {
              sub_10004FC84(v43, v47[0], (unint64_t)v47[1]);
            }
            else
            {
              *(_OWORD *)long long v43 = *(_OWORD *)v47;
              uint64_t v44 = v48;
            }
            uint64_t v4 = v35;
            uint64_t v29 = *(void *)(v35 + 136);
            uint64_t v30 = *(void *)(v35 + 144);
            while (v29 != v30)
            {
              if (SHIBYTE(v44) < 0)
              {
                sub_10004FC84(&buf, v43[0], (unint64_t)v43[1]);
              }
              else
              {
                long long buf = *(_OWORD *)v43;
                uint64_t v55 = v44;
              }
              uint64_t v31 = *(void *)(v29 + 24);
              if (!v31) {
                sub_10007B600();
              }
              (*(void (**)(uint64_t, long long *))(*(void *)v31 + 48))(v31, &buf);
              if (SHIBYTE(v55) < 0) {
                operator delete((void *)buf);
              }
              v29 += 32;
            }
            uint64_t v12 = v38;
            if (SHIBYTE(v44) < 0) {
              operator delete(v43[0]);
            }
          }
          if (SHIBYTE(v48) < 0) {
            operator delete(v47[0]);
          }
          ++v14;
        }
        while (v14 != v12);
        uint64_t v12 = (char *)[obj countByEnumeratingWithState:__p objects:v56 count:16];
      }
      while (v12);
    }
  }
  else
  {
    uint32_t v32 = *(NSObject **)(v4 + 40);
    if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)v56 = 0;
      _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, "#N Remote App Installed notification does not contain any bundleIds", v56, 2u);
    }
  }

  xpc_release(object);
  xpc_release(v42);
  xpc_release(v3);
}

void sub_1004DAF90(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, uint64_t a17, xpc_object_t a18, void *a19, uint64_t a20,int a21,__int16 a22,char a23,char a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,char a30,uint64_t a31,int a32,__int16 a33,char a34,char a35,uint64_t a36,xpc_object_t __p,uint64_t a38,int a39,__int16 a40,char a41,char a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,xpc_object_t object,void *a50,uint64_t a51,int a52,__int16 a53,char a54,char a55)
{
  xpc_release(object);
  xpc_release(a18);
  xpc_release(v56);
  _Unwind_Resume(a1);
}

uint64_t sub_1004DB0FC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1004DB13C()
{
}

void sub_1004DB148(uint64_t **a1)
{
  id v16 = a1;
  uint64_t v1 = **a1;
  uint64_t v2 = *(NSObject **)(v1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Starting paired device service", buf, 2u);
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(v1 + 240));
  uint64_t v4 = ServiceMap;
  if (v5 < 0)
  {
    uint64_t v6 = (unsigned __int8 *)(v5 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v7 = 5381;
    do
    {
      uint64_t v5 = v7;
      unsigned int v8 = *v6++;
      uint64_t v7 = (33 * v7) ^ v8;
    }
    while (v8);
  }
  std::mutex::lock(ServiceMap);
  *(void *)long long buf = v5;
  char v9 = sub_10004D37C(&v4[1].__m_.__sig, (unint64_t *)buf);
  if (v9)
  {
    uint64_t v11 = v9[3];
    id v10 = (std::__shared_weak_count *)v9[4];
    if (v10)
    {
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v4);
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v10);
      char v12 = 0;
      if (!v11)
      {
LABEL_13:
        if ((v12 & 1) == 0) {
          sub_10004D2C8(v10);
        }
        int v13 = (*(uint64_t (**)(uint64_t))(*(void *)v1 + 16))(v1);
        id v14 = *(NSObject **)(v1 + 40);
        BOOL v15 = os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT);
        if (v13)
        {
          if (v15)
          {
            *(_WORD *)long long buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I There is a paired device on start", buf, 2u);
          }
          sub_1004D8144(v1);
        }
        else if (v15)
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I No paired devices on start", buf, 2u);
        }
        operator delete();
      }
LABEL_12:
      *(unsigned char *)(v1 + 273) = (*(uint64_t (**)(uint64_t))(*(void *)v11 + 72))(v11);
      goto LABEL_13;
    }
  }
  else
  {
    uint64_t v11 = 0;
  }
  std::mutex::unlock(v4);
  id v10 = 0;
  char v12 = 1;
  if (!v11) {
    goto LABEL_13;
  }
  goto LABEL_12;
}

void sub_1004DB368()
{
  if ((v0 & 1) == 0) {
    sub_10004D2C8(v1);
  }
  operator delete();
}

uint64_t sub_1004DB3AC(uint64_t a1)
{
  uint64_t v1 = *(uint64_t **)(a1 + 40);
  uint64_t v3 = *v1;
  uint64_t v2 = (void *)v1[1];
  if (!v2 && !v1[2])
  {
    *(unsigned char *)(v3 + 272) = 1;
    sub_1004D80DC(*(void *)(v3 + 88), *(void *)(v3 + 96));
    return 0;
  }
  id v4 = [v2 bundleIdentifier];
  uint64_t v5 = (char *)[v4 UTF8String];

  if (v5)
  {
    BOOL v6 = *(unsigned char *)(v3 + 273) != 0;
    char v7 = *((unsigned char *)v1 + 24) != 0;
    char v8 = *((unsigned char *)v1 + 25) != 0;
    sub_100058DB0(buf, v5);
    BOOL v9 = sub_1004D86CC(v6, v7, v8, (uint64_t)buf);
    BOOL v10 = v9;
    if (v23 < 0)
    {
      operator delete(*(void **)buf);
      if (v10)
      {
LABEL_6:
        uint64_t v11 = *(NSObject **)(v3 + 40);
        if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long buf = 0;
          char v12 = "#N Temporarily ignoring app";
          int v13 = v11;
          uint32_t v14 = 2;
LABEL_10:
          _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, v12, buf, v14);
          return 1;
        }
        return 1;
      }
    }
    else if (v9)
    {
      goto LABEL_6;
    }
    sub_1004DB600((uint64_t **)(v3 + 160), v5);
    id v17 = [(id)v1[1] watchKitAppExtensionBundleID];
    char v18 = (char *)[v17 UTF8String];

    if (v18)
    {
      sub_100058DB0(buf, v18);
      v21 = buf;
      char v19 = sub_100327F4C((uint64_t **)(v3 + 184), (void **)buf, (uint64_t)&unk_10144E20E, &v21);
      sub_10003ED78((std::string *)((char *)v19 + 56), v5);
      if (v23 < 0) {
        operator delete(*(void **)buf);
      }
    }
    return 1;
  }
  BOOL v15 = *(NSObject **)(v3 + 40);
  if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v16 = v1[1];
    *(_DWORD *)long long buf = 138412290;
    *(void *)&buf[4] = v16;
    char v12 = "#N Missing bundle identifier for system app %@";
    int v13 = v15;
    uint32_t v14 = 12;
    goto LABEL_10;
  }
  return 1;
}

void sub_1004DB5C4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  _Unwind_Resume(a1);
}

void sub_1004DB600(uint64_t **a1, char *a2)
{
  id v4 = a1 + 1;
  v9[1] = 1;
  OsLogContext __p = operator new(0x38uLL);
  v9[0] = v4;
  sub_100058DB0((void *)__p + 4, a2);
  uint64_t v7 = 0;
  uint64_t v5 = (uint64_t **)sub_100046ED4((uint64_t)a1, &v7, (void **)__p + 4);
  if (*v5)
  {
    BOOL v6 = (void **)__p;
    OsLogContext __p = 0;
    if (v6) {
      sub_1000C6EE8((uint64_t)v9, v6);
    }
  }
  else
  {
    sub_100046C38(a1, v7, v5, (uint64_t *)__p);
  }
}

void sub_1004DB6BC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  sub_1000C6EE8(v10, v11);
  _Unwind_Resume(a1);
}

void sub_1004DB6D8(uint64_t a1)
{
  uint64_t v1 = *(uint64_t **)(a1 + 40);
  uint64_t v2 = *v1;
  id v3 = [(id)v1[1] bundleIdentifier];
  id v4 = (char *)[v3 UTF8String];

  if (!v4)
  {
    uint32_t v14 = *(NSObject **)(v2 + 40);
    if (!os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    uint64_t v15 = v1[1];
    *(_DWORD *)long long buf = 138412290;
    *(void *)&buf[4] = v15;
    uint64_t v11 = "#N Missing bundle identifier for app %@";
    char v12 = v14;
    uint32_t v13 = 12;
    goto LABEL_8;
  }
  BOOL v5 = *(unsigned char *)(v2 + 273) != 0;
  char v6 = *((unsigned char *)v1 + 16) != 0;
  char v7 = *((unsigned char *)v1 + 17) != 0;
  sub_100058DB0(buf, v4);
  BOOL v8 = sub_1004D86CC(v5, v6, v7, (uint64_t)buf);
  BOOL v9 = v8;
  if (v21 < 0)
  {
    operator delete(*(void **)buf);
    if (v9) {
      goto LABEL_4;
    }
  }
  else if (v8)
  {
LABEL_4:
    uint64_t v10 = *(NSObject **)(v2 + 40);
    if (!os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    *(_WORD *)long long buf = 0;
    uint64_t v11 = "#N Temporarily ignoring app";
    char v12 = v10;
    uint32_t v13 = 2;
LABEL_8:
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, v11, buf, v13);
    return;
  }
  sub_1004DB600((uint64_t **)(v2 + 160), v4);
  id v16 = [(id)v1[1] watchKitAppExtensionBundleID];
  id v17 = (char *)[v16 UTF8String];

  if (v17)
  {
    sub_100058DB0(buf, v17);
    char v19 = buf;
    char v18 = sub_100327F4C((uint64_t **)(v2 + 184), (void **)buf, (uint64_t)&unk_10144E20E, &v19);
    sub_10003ED78((std::string *)((char *)v18 + 56), v4);
    if (v21 < 0) {
      operator delete(*(void **)buf);
    }
  }
}

void sub_1004DB8C8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1004DB904(uint64_t a1, NSObject **a2, void *a3, char a4)
{
  *(void *)a1 = &off_101A2EE90;
  BOOL v8 = (void *)(a1 + 8);
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v11, kCtLoggingSystemName, "probe.http");
  sub_1004DBA00(v8, a2, &v11);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v11);
  *(void *)a1 = off_1019D82B0;
  *(void *)(a1 + 48) = *a3;
  uint64_t v9 = a3[1];
  *(void *)(a1 + 56) = v9;
  if (v9) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v9 + 8), 1uLL, memory_order_relaxed);
  }
  *(unsigned char *)(a1 + 64) = a4;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  return a1;
}

void sub_1004DB9EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void *sub_1004DBA00(void *a1, NSObject **a2, OsLogContext *a3)
{
  *a1 = 0;
  a1[1] = 0;
  BOOL v5 = *a2;
  a1[2] = *a2;
  if (v5) {
    dispatch_retain(v5);
  }
  a1[3] = 0;
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v7, a3);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 4), (const ctu::OsLogLogger *)v7);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v7);
  return a1;
}

void sub_1004DBA68(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)va);
  sub_100087E88(v2);
  _Unwind_Resume(a1);
}

void *sub_1004DBA8C(void *a1)
{
  *a1 = off_1019D82B0;
  uint64_t v2 = (std::__shared_weak_count *)a1[12];
  if (v2) {
    sub_10004D2C8(v2);
  }
  id v3 = (std::__shared_weak_count *)a1[10];
  if (v3) {
    sub_10004D2C8(v3);
  }
  id v4 = (std::__shared_weak_count *)a1[7];
  if (v4) {
    sub_10004D2C8(v4);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 5));
  sub_100087E88(a1 + 1);
  return a1;
}

void sub_1004DBB08(void *a1)
{
  sub_1004DBA8C(a1);

  operator delete();
}

void sub_1004DBB40(uint64_t a1, uint64_t a2)
{
  (*(void (**)(uint8_t *__return_ptr))(**(void **)(a1 + 48) + 24))(buf);
  long long v4 = *(_OWORD *)buf;
  memset(buf, 0, sizeof(buf));
  BOOL v5 = *(std::__shared_weak_count **)(a1 + 96);
  *(_OWORD *)(a1 + 88) = v4;
  if (v5)
  {
    sub_10004D2C8(v5);
    if (*(void *)&buf[8]) {
      sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
    }
    if (*(void *)(a1 + 88)) {
      goto LABEL_5;
    }
  }
  else if ((void)v4)
  {
LABEL_5:
    char v6 = *(std::__shared_weak_count **)(a1 + 16);
    if (!v6 || (uint64_t v7 = *(void *)(a1 + 8), (v8 = std::__shared_weak_count::lock(v6)) == 0)) {
      sub_100088B9C();
    }
    uint64_t v9 = v8;
    p_shared_weak_owners = &v8->__shared_weak_owners_;
    atomic_fetch_add_explicit(&v8->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v8);
    (*(void (**)(void, void))(**(void **)(a1 + 88) + 8))(*(void *)(a1 + 88), *(void *)(a1 + 24));
    uint64_t v11 = *(void *)(a1 + 88);
    v29[0] = _NSConcreteStackBlock;
    v29[1] = 1174405120;
    v29[2] = sub_1004DC014;
    v29[3] = &unk_1019D82E0;
    v29[5] = a1;
    v29[6] = v7;
    uint64_t v30 = v9;
    atomic_fetch_add_explicit(p_shared_weak_owners, 1uLL, memory_order_relaxed);
    v29[4] = a2;
    (*(void (**)(uint64_t, void *))(*(void *)v11 + 16))(v11, v29);
    int v12 = *(unsigned __int8 *)(a1 + 64);
    uint32_t v13 = *(NSObject **)(a1 + 40);
    BOOL v14 = os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT);
    if (v12)
    {
      if (v14)
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I starting probe", buf, 2u);
      }
      uint64_t v15 = *(void *)(a1 + 88);
      __p[1] = 0;
      uint64_t v28 = 0;
      __p[0] = 0;
      (*(void (**)(uint64_t, void **))(*(void *)v15 + 40))(v15, __p);
      if (SHIBYTE(v28) < 0) {
        operator delete(__p[0]);
      }
    }
    else
    {
      if (v14)
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I wait till we have data", buf, 2u);
      }
      (*(void (**)(uint8_t *__return_ptr))(**(void **)(a1 + 48) + 32))(buf);
      uint64_t v17 = *(void *)buf;
      sub_100058DB0(v24, "probe: timer");
      uint64_t v18 = (*(uint64_t (**)(void))(**(void **)(a1 + 48) + 40))(*(void *)(a1 + 48));
      char v19 = *(NSObject **)(a1 + 24);
      dispatch_object_t object = v19;
      if (v19) {
        dispatch_retain(v19);
      }
      v21[0] = _NSConcreteStackBlock;
      v21[1] = 0x40000000;
      v21[2] = sub_1004DC21C;
      v21[3] = &unk_1019D8310;
      v21[4] = a1;
      aBlock = _Block_copy(v21);
      sub_100118A44(v17, (uint64_t)v24, 1, 1000000 * v18, &object, &aBlock);
      sub_1004DC2E0((void *)(a1 + 72), &v26);
      uint64_t v20 = v26;
      uint64_t v26 = 0;
      if (v20) {
        (*(void (**)(uint64_t))(*(void *)v20 + 8))(v20);
      }
      if (aBlock) {
        _Block_release(aBlock);
      }
      if (object) {
        dispatch_release(object);
      }
      if (v25 < 0) {
        operator delete(v24[0]);
      }
      if (*(void *)&buf[8]) {
        sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
      }
    }
    if (v30) {
      std::__shared_weak_count::__release_weak(v30);
    }
    std::__shared_weak_count::__release_weak(v9);
    return;
  }
  id v16 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#E Unable to allocate request", buf, 2u);
  }
  (*(void (**)(uint64_t, void))(a2 + 16))(a2, 0);
}

void sub_1004DBF44(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *aBlock, dispatch_object_t object, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,std::__shared_weak_count *a36)
{
  if (a22) {
    (*(void (**)(uint64_t))(*(void *)a22 + 8))(a22);
  }
  if (aBlock) {
    _Block_release(aBlock);
  }
  if (object) {
    dispatch_release(object);
  }
  if (a21 < 0) {
    operator delete(__p);
  }
  xpc_object_t v39 = *(std::__shared_weak_count **)(v37 - 56);
  if (v39) {
    sub_10004D2C8(v39);
  }
  if (a36) {
    std::__shared_weak_count::__release_weak(a36);
  }
  std::__shared_weak_count::__release_weak(v36);
  _Unwind_Resume(a1);
}

void sub_1004DC014(void *a1, void *a2)
{
  id v3 = (std::__shared_weak_count *)a1[7];
  if (v3)
  {
    uint64_t v5 = a1[5];
    char v6 = std::__shared_weak_count::lock(v3);
    if (v6)
    {
      uint64_t v7 = v6;
      if (a1[6])
      {
        BOOL v8 = *(NSObject **)(v5 + 40);
        if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
        {
          (*(void (**)(void))(*(void *)*a2 + 16))();
          ctu::Http::asString();
          int v9 = (*(uint64_t (**)(void))(*(void *)*a2 + 24))();
          p_p = &__p;
          if (v12 < 0) {
            p_p = __p;
          }
          *(_DWORD *)long long buf = 136315394;
          BOOL v14 = p_p;
          __int16 v15 = 1024;
          int v16 = v9;
          _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I got probe response, result: %s, respone: %d", buf, 0x12u);
          if (v12 < 0) {
            operator delete(__p);
          }
        }
        if (*a2) {
          (*(uint64_t (**)(void))(*(void *)*a2 + 24))(*a2);
        }
        (*(void (**)(void))(a1[4] + 16))();
      }
      sub_10004D2C8(v7);
    }
  }
}

void sub_1004DC1C0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  sub_10004D2C8(v15);
  _Unwind_Resume(a1);
}

uint64_t sub_1004DC1F0(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 56);
  *(void *)(result + 48) = *(void *)(a2 + 48);
  *(void *)(result + 56) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_1004DC20C(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 56);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_1004DC21C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t v2 = *(NSObject **)(v1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I start request on timer expiry", buf, 2u);
  }
  uint64_t v3 = *(void *)(v1 + 88);
  __p[1] = 0;
  uint64_t v5 = 0;
  __p[0] = 0;
  (*(void (**)(uint64_t, void **))(*(void *)v3 + 40))(v3, __p);
  if (SHIBYTE(v5) < 0) {
    operator delete(__p[0]);
  }
}

void sub_1004DC2C4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *sub_1004DC2E0(void *a1, uint64_t *a2)
{
  sub_1004DC438((uint64_t *)&v6, a2);
  uint64_t v3 = (std::__shared_weak_count *)a1[1];
  long long v4 = v6;
  *(void *)&long long v6 = *a1;
  *((void *)&v6 + 1) = v3;
  *(_OWORD *)a1 = v4;
  if (v3) {
    sub_10004D2C8(v3);
  }
  return a1;
}

void sub_1004DC32C(uint64_t a1, int a2)
{
  *(unsigned char *)(a1 + 64) = a2;
  if (a2 && *(void *)(a1 + 72))
  {
    uint64_t v3 = *(std::__shared_weak_count **)(a1 + 80);
    *(void *)(a1 + 72) = 0;
    *(void *)(a1 + 80) = 0;
    if (v3) {
      sub_10004D2C8(v3);
    }
    long long v4 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I start probe on getting data mode", buf, 2u);
    }
    uint64_t v5 = *(void *)(a1 + 88);
    __p[1] = 0;
    uint64_t v7 = 0;
    __p[0] = 0;
    (*(void (**)(uint64_t, void **))(*(void *)v5 + 40))(v5, __p);
    if (SHIBYTE(v7) < 0) {
      operator delete(__p[0]);
    }
  }
}

void sub_1004DC3F4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1004DC410(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 88) + 48))();
}

uint64_t *sub_1004DC438(uint64_t *result, uint64_t *a2)
{
  uint64_t v2 = *a2;
  *__n128 result = *a2;
  if (v2) {
    operator new();
  }
  result[1] = 0;
  *a2 = 0;
  return result;
}

void sub_1004DC4BC(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_1004DC4F4(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_1004DC524(uint64_t a1, uint64_t a2)
{
    return a1 + 24;
  else {
    return 0;
  }
}

uint64_t sub_1004DC568(void **a1, void *a2, const void *a3, void **a4)
{
  memset(&c, 0, sizeof(c));
  *(void *)md = 0;
  uint64_t v36 = 0;
  CC_MD5_Init(&c);
  CC_MD5_Update(&c, a2, (CC_LONG)a3);
  CC_MD5_Final(md, &c);
  uint64_t v29 = 0;
  long long v27 = 0u;
  long long v28 = 0u;
  long long v25 = 0u;
  long long v26 = 0u;
  long long v23 = 0u;
  long long v24 = 0u;
  long long v21 = 0u;
  long long v22 = 0u;
  long long v20 = 0u;
  long long v18 = 0u;
  long long v19 = 0u;
  *(_OWORD *)OsLogContext __p = 0u;
  memset(v16, 0, sizeof(v16));
  sub_10004DE24((uint64_t)v16);
  buf[0] = 48;
  sub_1004DC904(v16, buf);
  uint64_t v8 = 0;
  *(_DWORD *)((char *)v16 + *(void *)(*(void *)&v16[0] - 24) + 8) = *(_DWORD *)((unsigned char *)v16
                                                                                    + *(void *)(*(void *)&v16[0]
                                                                                                - 24)
                                                                                    + 8) & 0xFFFFFFB5 | 8;
  do
  {
    *(void *)((char *)&v16[1] + *(void *)(*(void *)&v16[0] - 24) + 8) = 2;
    std::ostream::operator<<();
    ++v8;
  }
  while (v8 != 16);
  sub_10004BC98((uint64_t)v16 + 8, buf);
  if (*((char *)a4 + 23) < 0) {
    operator delete(*a4);
  }
  *(_OWORD *)a4 = *(_OWORD *)buf;
  a4[2] = *(void **)&buf[16];
  int v9 = *a1[1];
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v11 = ((uint64_t (*)(void **))(*a1)[5])(a1);
    ctu::hex((uint64_t *)v14, (ctu *)a2, a3, v12);
    if (v15 >= 0) {
      uint32_t v13 = v14;
    }
    else {
      uint32_t v13 = (void **)v14[0];
    }
    if (*((char *)a4 + 23) < 0) {
      a4 = (void **)*a4;
    }
    *(_DWORD *)long long buf = 136315906;
    *(void *)&uint8_t buf[4] = v11;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = ", ";
    *(_WORD *)&buf[22] = 2080;
    uint32_t v32 = v13;
    __int16 v33 = 2080;
    long long v34 = a4;
    _os_log_debug_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEBUG, "#D %s%scomputeDigest, data:0x%s -> %s", buf, 0x2Au);
    if (v15 < 0) {
      operator delete(v14[0]);
    }
  }
  if (SHIBYTE(v18) < 0) {
    operator delete(__p[1]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  std::ios::~ios();
  return 1;
}

void sub_1004DC8D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  sub_1000C937C((uint64_t)va);
  _Unwind_Resume(a1);
}

void *sub_1004DC904(void *a1, char *a2)
{
  uint64_t v3 = (char *)a1 + *(void *)(*a1 - 24);
  int v4 = *a2;
  if (*((_DWORD *)v3 + 36) == -1)
  {
    std::ios_base::getloc((const std::ios_base *)((char *)a1 + *(void *)(*a1 - 24)));
    uint64_t v5 = std::locale::use_facet(&v8, &std::ctype<char>::id);
    int v6 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v5->__vftable[2].~facet_0)(v5, 32);
    std::locale::~locale(&v8);
    *((_DWORD *)v3 + 36) = v6;
  }
  *((_DWORD *)v3 + 36) = v4;
  return a1;
}

void sub_1004DC9B8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::locale a10)
{
}

uint64_t sub_1004DC9CC(void **a1, void *a2, const void *a3, void *a4, const void *a5, unint64_t *a6)
{
  unint64_t v12 = (void *)*a6;
  unint64_t v14 = a6[1] - (void)v12;
  if (v14 > 0xF)
  {
    if (v14 != 16) {
      a6[1] = (unint64_t)v12 + 16;
    }
  }
  else
  {
    sub_10011FDF0(a6, 16 - v14);
    unint64_t v12 = (void *)*a6;
  }
  CCHmac(1u, a2, (size_t)a3, a4, (size_t)a5, v12);
  char v15 = *a1[1];
  if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v17 = ((uint64_t (*)(void **))(*a1)[5])(a1);
    ctu::hex((uint64_t *)v29, (ctu *)a2, a3, v18);
    if (v30 >= 0) {
      long long v20 = v29;
    }
    else {
      long long v20 = (void **)v29[0];
    }
    ctu::hex((uint64_t *)v27, (ctu *)a4, a5, v19);
    int v21 = v28;
    long long v22 = (void **)v27[0];
    ctu::hex();
    long long v23 = v27;
    if (v21 < 0) {
      long long v23 = v22;
    }
    if (v26 >= 0) {
      p_p = &__p;
    }
    else {
      p_p = __p;
    }
    *(_DWORD *)long long buf = 136316162;
    uint64_t v32 = v17;
    __int16 v33 = 2080;
    long long v34 = ", ";
    __int16 v35 = 2080;
    uint64_t v36 = v20;
    __int16 v37 = 2080;
    v38 = v23;
    __int16 v39 = 2080;
    v40 = p_p;
    _os_log_debug_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEBUG, "#D %s%scomputeHmac, key:0x%s, data:0x%s -> %s", buf, 0x34u);
    if (v26 < 0) {
      operator delete(__p);
    }
    if (v28 < 0) {
      operator delete(v27[0]);
    }
    if (v30 < 0) {
      operator delete(v29[0]);
    }
  }
  return 1;
}

void sub_1004DCBE0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, void *a19, uint64_t a20,int a21,__int16 a22,char a23,char a24)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  if (a24 < 0) {
    operator delete(a19);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1004DCC1C(void **a1, void *a2, const void *a3, void **a4)
{
  memset(&c, 0, sizeof(c));
  memset(md, 0, sizeof(md));
  CC_SHA256_Init(&c);
  CC_SHA256_Update(&c, a2, (CC_LONG)a3);
  CC_SHA256_Final((unsigned __int8 *)md, &c);
  uint64_t v29 = 0;
  long long v27 = 0u;
  long long v28 = 0u;
  long long v25 = 0u;
  long long v26 = 0u;
  long long v23 = 0u;
  long long v24 = 0u;
  long long v21 = 0u;
  long long v22 = 0u;
  long long v20 = 0u;
  long long v18 = 0u;
  long long v19 = 0u;
  *(_OWORD *)OsLogContext __p = 0u;
  memset(v16, 0, sizeof(v16));
  sub_10004DE24((uint64_t)v16);
  buf[0] = 48;
  sub_1004DC904(v16, buf);
  uint64_t v8 = 0;
  *(_DWORD *)((char *)v16 + *(void *)(*(void *)&v16[0] - 24) + 8) = *(_DWORD *)((unsigned char *)v16
                                                                                    + *(void *)(*(void *)&v16[0]
                                                                                                - 24)
                                                                                    + 8) & 0xFFFFFFB5 | 8;
  do
  {
    *(void *)((char *)&v16[1] + *(void *)(*(void *)&v16[0] - 24) + 8) = 2;
    std::ostream::operator<<();
    ++v8;
  }
  while (v8 != 32);
  sub_10004BC98((uint64_t)v16 + 8, buf);
  if (*((char *)a4 + 23) < 0) {
    operator delete(*a4);
  }
  *(_OWORD *)a4 = *(_OWORD *)buf;
  a4[2] = *(void **)&buf[16];
  int v9 = *a1[1];
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v11 = ((uint64_t (*)(void **))(*a1)[5])(a1);
    ctu::hex((uint64_t *)v14, (ctu *)a2, a3, v12);
    if (v15 >= 0) {
      uint32_t v13 = v14;
    }
    else {
      uint32_t v13 = (void **)v14[0];
    }
    if (*((char *)a4 + 23) < 0) {
      a4 = (void **)*a4;
    }
    *(_DWORD *)long long buf = 136315906;
    *(void *)&uint8_t buf[4] = v11;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = ", ";
    *(_WORD *)&buf[22] = 2080;
    uint64_t v32 = v13;
    __int16 v33 = 2080;
    long long v34 = a4;
    _os_log_debug_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEBUG, "#D %s%scomputeDigest, data:0x%s -> %s", buf, 0x2Au);
    if (v15 < 0) {
      operator delete(v14[0]);
    }
  }
  if (SHIBYTE(v18) < 0) {
    operator delete(__p[1]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  std::ios::~ios();
  return 1;
}

void sub_1004DCF90(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  sub_1000C937C((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1004DCFBC(void **a1, void *a2, const void *a3, void *a4, const void *a5, unint64_t *a6)
{
  unint64_t v12 = (void *)*a6;
  unint64_t v14 = a6[1] - (void)v12;
  if (v14 > 0x1F)
  {
    if (v14 != 32) {
      a6[1] = (unint64_t)v12 + 32;
    }
  }
  else
  {
    sub_10011FDF0(a6, 32 - v14);
    unint64_t v12 = (void *)*a6;
  }
  CCHmac(2u, a2, (size_t)a3, a4, (size_t)a5, v12);
  char v15 = *a1[1];
  if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v17 = ((uint64_t (*)(void **))(*a1)[5])(a1);
    ctu::hex((uint64_t *)v29, (ctu *)a2, a3, v18);
    if (v30 >= 0) {
      long long v20 = v29;
    }
    else {
      long long v20 = (void **)v29[0];
    }
    ctu::hex((uint64_t *)v27, (ctu *)a4, a5, v19);
    int v21 = v28;
    long long v22 = (void **)v27[0];
    ctu::hex();
    long long v23 = v27;
    if (v21 < 0) {
      long long v23 = v22;
    }
    if (v26 >= 0) {
      p_p = &__p;
    }
    else {
      p_p = __p;
    }
    *(_DWORD *)long long buf = 136316162;
    uint64_t v32 = v17;
    __int16 v33 = 2080;
    long long v34 = ", ";
    __int16 v35 = 2080;
    uint64_t v36 = v20;
    __int16 v37 = 2080;
    v38 = v23;
    __int16 v39 = 2080;
    v40 = p_p;
    _os_log_debug_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEBUG, "#D %s%scomputeHmac, key:0x%s, data:0x%s -> %s", buf, 0x34u);
    if (v26 < 0) {
      operator delete(__p);
    }
    if (v28 < 0) {
      operator delete(v27[0]);
    }
    if (v30 < 0) {
      operator delete(v29[0]);
    }
  }
  return 1;
}

void sub_1004DD1D0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, void *a19, uint64_t a20,int a21,__int16 a22,char a23,char a24)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  if (a24 < 0) {
    operator delete(a19);
  }
  _Unwind_Resume(exception_object);
}

void sub_1004DD20C(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + 32) = 1065353216;
  *(void *)(a1 + 40) = a2;
  operator new();
}

void sub_1004DD2B8(_Unwind_Exception *a1)
{
  sub_1004DD39C(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1004DD2CC(uint64_t a1)
{
  for (uint64_t i = *(void **)(a1 + 16); i; uint64_t i = (void *)*i)
  {
    uint64_t v3 = i[5];
    if (v3) {
      (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
    }
  }

  return sub_1004DD39C(a1);
}

void sub_1004DD340()
{
}

const char *sub_1004DD354()
{
  return "MD5";
}

const char *sub_1004DD360()
{
  return "MD5DigestAlgorithm";
}

void sub_1004DD370()
{
}

const char *sub_1004DD384()
{
  return "SHA256";
}

const char *sub_1004DD390()
{
  return "SHA256DigestAlgorithm";
}

uint64_t sub_1004DD39C(uint64_t a1)
{
  sub_1004DD3D8(a1, *(void ***)(a1 + 16));
  uint64_t v2 = *(void **)a1;
  *(void *)a1 = 0;
  if (v2) {
    operator delete(v2);
  }
  return a1;
}

void sub_1004DD3D8(int a1, void **__p)
{
  if (__p)
  {
    uint64_t v2 = __p;
    do
    {
      uint64_t v3 = (void **)*v2;
      if (*((char *)v2 + 39) < 0) {
        operator delete(v2[2]);
      }
      operator delete(v2);
      uint64_t v2 = v3;
    }
    while (v3);
  }
}

char *sub_1004DD424(uint64_t *a1, unsigned __int8 *a2, uint64_t a3, long long **a4)
{
  uint64_t v7 = a1 + 3;
  unint64_t v8 = sub_100206390((uint64_t)(a1 + 3), (uint64_t)a2);
  unint64_t v9 = v8;
  unint64_t v10 = a1[1];
  if (v10)
  {
    uint8x8_t v11 = (uint8x8_t)vcnt_s8((int8x8_t)v10);
    v11.i16[0] = vaddlv_u8(v11);
    unint64_t v12 = v11.u32[0];
    if (v11.u32[0] > 1uLL)
    {
      unint64_t v13 = v8;
      if (v8 >= v10) {
        unint64_t v13 = v8 % v10;
      }
    }
    else
    {
      unint64_t v13 = (v10 - 1) & v8;
    }
    unint64_t v14 = *(void ***)(*a1 + 8 * v13);
    if (v14)
    {
      char v15 = (char *)*v14;
      if (*v14)
      {
        do
        {
          unint64_t v16 = *((void *)v15 + 1);
          if (v16 == v9)
          {
            if (sub_1000609C0((uint64_t)(a1 + 4), (unsigned __int8 *)v15 + 16, a2)) {
              return v15;
            }
          }
          else
          {
            if (v12 > 1)
            {
              if (v16 >= v10) {
                v16 %= v10;
              }
            }
            else
            {
              v16 &= v10 - 1;
            }
            if (v16 != v13) {
              break;
            }
          }
          char v15 = *(char **)v15;
        }
        while (v15);
      }
    }
  }
  else
  {
    unint64_t v13 = 0;
  }
  uint64_t v17 = *a4;
  char v15 = (char *)operator new(0x30uLL);
  *(void *)char v15 = 0;
  *((void *)v15 + 1) = v9;
  unint64_t v18 = v15 + 16;
  if (*((char *)v17 + 23) < 0)
  {
    sub_10004FC84(v18, *(void **)v17, *((void *)v17 + 1));
  }
  else
  {
    long long v19 = *v17;
    *((void *)v15 + 4) = *((void *)v17 + 2);
    *(_OWORD *)unint64_t v18 = v19;
  }
  *((void *)v15 + 5) = 0;
  float v20 = (float)(unint64_t)(a1[3] + 1);
  float v21 = *((float *)a1 + 8);
  if (!v10 || (float)(v21 * (float)v10) < v20)
  {
    BOOL v22 = 1;
    if (v10 >= 3) {
      BOOL v22 = (v10 & (v10 - 1)) != 0;
    }
    unint64_t v23 = v22 | (2 * v10);
    unint64_t v24 = vcvtps_u32_f32(v20 / v21);
    if (v23 <= v24) {
      int8x8_t prime = (int8x8_t)v24;
    }
    else {
      int8x8_t prime = (int8x8_t)v23;
    }
    if (*(void *)&prime == 1)
    {
      int8x8_t prime = (int8x8_t)2;
    }
    else if ((*(void *)&prime & (*(void *)&prime - 1)) != 0)
    {
      int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
    }
    unint64_t v10 = a1[1];
    if (*(void *)&prime > v10) {
      goto LABEL_33;
    }
    if (*(void *)&prime < v10)
    {
      unint64_t v32 = vcvtps_u32_f32((float)(unint64_t)a1[3] / *((float *)a1 + 8));
      if (v10 < 3 || (uint8x8_t v33 = (uint8x8_t)vcnt_s8((int8x8_t)v10), v33.i16[0] = vaddlv_u8(v33), v33.u32[0] > 1uLL))
      {
        unint64_t v32 = std::__next_prime(v32);
      }
      else
      {
        uint64_t v34 = 1 << -(char)__clz(v32 - 1);
        if (v32 >= 2) {
          unint64_t v32 = v34;
        }
      }
      if (*(void *)&prime <= v32) {
        int8x8_t prime = (int8x8_t)v32;
      }
      if (*(void *)&prime >= v10)
      {
        unint64_t v10 = a1[1];
      }
      else
      {
        if (prime)
        {
LABEL_33:
          if (*(void *)&prime >> 61) {
            sub_10006A7CC();
          }
          char v26 = operator new(8 * *(void *)&prime);
          long long v27 = (void *)*a1;
          *a1 = (uint64_t)v26;
          if (v27) {
            operator delete(v27);
          }
          uint64_t v28 = 0;
          a1[1] = (uint64_t)prime;
          do
            *(void *)(*a1 + 8 * v28++) = 0;
          while (*(void *)&prime != v28);
          uint64_t v29 = (void *)a1[2];
          if (v29)
          {
            unint64_t v30 = v29[1];
            uint8x8_t v31 = (uint8x8_t)vcnt_s8(prime);
            v31.i16[0] = vaddlv_u8(v31);
            if (v31.u32[0] > 1uLL)
            {
              if (v30 >= *(void *)&prime) {
                v30 %= *(void *)&prime;
              }
            }
            else
            {
              v30 &= *(void *)&prime - 1;
            }
            *(void *)(*a1 + 8 * v30) = a1 + 2;
            __int16 v35 = (void *)*v29;
            if (*v29)
            {
              do
              {
                unint64_t v36 = v35[1];
                if (v31.u32[0] > 1uLL)
                {
                  if (v36 >= *(void *)&prime) {
                    v36 %= *(void *)&prime;
                  }
                }
                else
                {
                  v36 &= *(void *)&prime - 1;
                }
                if (v36 != v30)
                {
                  if (!*(void *)(*a1 + 8 * v36))
                  {
                    *(void *)(*a1 + 8 * v36) = v29;
                    goto LABEL_58;
                  }
                  *uint64_t v29 = *v35;
                  *__int16 v35 = **(void **)(*a1 + 8 * v36);
                  **(void **)(*a1 + 8 * v36) = v35;
                  __int16 v35 = v29;
                }
                unint64_t v36 = v30;
LABEL_58:
                uint64_t v29 = v35;
                __int16 v35 = (void *)*v35;
                unint64_t v30 = v36;
              }
              while (v35);
            }
          }
          unint64_t v10 = (unint64_t)prime;
          goto LABEL_62;
        }
        uint64_t v41 = (void *)*a1;
        *a1 = 0;
        if (v41) {
          operator delete(v41);
        }
        unint64_t v10 = 0;
        a1[1] = 0;
      }
    }
LABEL_62:
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v9 >= v10) {
        unint64_t v13 = v9 % v10;
      }
      else {
        unint64_t v13 = v9;
      }
    }
    else
    {
      unint64_t v13 = (v10 - 1) & v9;
    }
  }
  uint64_t v37 = *a1;
  v38 = *(void **)(*a1 + 8 * v13);
  if (v38)
  {
    *(void *)char v15 = *v38;
LABEL_75:
    void *v38 = v15;
    goto LABEL_76;
  }
  *(void *)char v15 = a1[2];
  a1[2] = (uint64_t)v15;
  *(void *)(v37 + 8 * v13) = a1 + 2;
  if (*(void *)v15)
  {
    unint64_t v39 = *(void *)(*(void *)v15 + 8);
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v39 >= v10) {
        v39 %= v10;
      }
    }
    else
    {
      v39 &= v10 - 1;
    }
    v38 = (void *)(*a1 + 8 * v39);
    goto LABEL_75;
  }
LABEL_76:
  ++*v7;
  return v15;
}

void sub_1004DD86C(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_1004DD894(void *a1, void *a2)
{
  int v4 = (ctu::OsLogLogger *)(a1 + 1);
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v7, kCtLoggingSystemName, "wea");
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v8, &v7);
  ctu::OsLogLogger::OsLogLogger(v4, (const ctu::OsLogLogger *)v8);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v8);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v7);
  a1[2] = 0;
  a1[3] = 0;
  *a1 = off_1019D8520;
  a1[4] = *a2;
  uint64_t v5 = a2[1];
  a1[5] = v5;
  if (v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
  }
  a1[6] = 0;
  return a1;
}

void sub_1004DD974(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v4 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)va1);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)va);
  LocationDelegateInterface::~LocationDelegateInterface(v2);
  _Unwind_Resume(a1);
}

void sub_1004DD9A8(uint64_t a1, void *a2)
{
}

id sub_1004DD9B0(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 48);
  if (v2)
  {
    return [v2 isLocationServiceEnabled];
  }
  else
  {
    uint64_t v4 = *(NSObject **)(a1 + 8);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t v5 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "Invalid Location module", v5, 2u);
    }
    return 0;
  }
}

id sub_1004DDA44(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 48);
  if (v2)
  {
    return [v2 isCircularGeofenceSupported];
  }
  else
  {
    uint64_t v3 = *(NSObject **)(a1 + 8);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t v5 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "Invalid Location module", v5, 2u);
    }
    return 0;
  }
}

id sub_1004DDAD8(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 48);
  if (v2)
  {
    return [v2 isPolygonalGeofenceSupported];
  }
  else
  {
    uint64_t v3 = *(NSObject **)(a1 + 8);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t v5 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "Invalid Location module", v5, 2u);
    }
    return 0;
  }
}

void sub_1004DDB6C(uint64_t a1)
{
  uint64_t v1 = *(NSObject **)(a1 + 8);
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v2 = 0;
    _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "#I Starting..", v2, 2u);
  }
}

void sub_1004DDBCC(uint64_t a1)
{
  uint64_t v1 = *(NSObject **)(a1 + 8);
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v2 = 0;
    _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "#I Ending..", v2, 2u);
  }
}

void sub_1004DDC2C(uint64_t a1@<X0>, uint64_t *a2@<X1>, void *a3@<X8>, double a4@<D0>, double a5@<D1>, double a6@<D2>)
{
  if (*(void *)(a1 + 48))
  {
    id v12 = objc_alloc((Class)NSString);
    if (*((char *)a2 + 23) < 0) {
      a2 = (uint64_t *)*a2;
    }
    id v17 = [v12 initWithUTF8String:a2];
    unint64_t v13 = objc_msgSend(*(id *)(a1 + 48), "setupCircularGeoFence:withName:", a4, a5, a6);
    unint64_t v14 = operator new(0x28uLL);
    v14[1] = 0;
    v14[2] = 0;
    void *v14 = off_1019C8EF0;
    id v15 = v13;
    *((_DWORD *)v14 + 6) = 0;
    v14[4] = v15;
    *a3 = v14 + 3;
    a3[1] = v14;
  }
  else
  {
    unint64_t v16 = *(NSObject **)(a1 + 8);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "Invalid Location module", buf, 2u);
    }
    *a3 = 0;
    a3[1] = 0;
  }
}

void sub_1004DDD84(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1004DDDA4(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X2>, void *a4@<X8>)
{
  if (*(void *)(a1 + 48))
  {
    id v8 = objc_alloc((Class)NSString);
    if (*((char *)a3 + 23) < 0) {
      a3 = (uint64_t *)*a3;
    }
    id v9 = [v8 initWithUTF8String:a3];
    unint64_t v10 = *(void **)(a1 + 48);
    unint64_t v16 = 0;
    uint64_t v17 = 0;
    OsLogContext __p = 0;
    sub_1004081A4(&__p, *(const void **)a2, *(void *)(a2 + 8), (uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 4);
    uint8x8_t v11 = [v10 setupPolygonalGeoFence:&__p withName:v9];
    id v12 = operator new(0x28uLL);
    v12[1] = 0;
    v12[2] = 0;
    void *v12 = off_1019C8EF0;
    id v13 = v11;
    *((_DWORD *)v12 + 6) = 0;
    void v12[4] = v13;
    *a4 = v12 + 3;
    a4[1] = v12;

    if (__p)
    {
      unint64_t v16 = __p;
      operator delete(__p);
    }
  }
  else
  {
    unint64_t v14 = *(NSObject **)(a1 + 8);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "Invalid Location module", buf, 2u);
    }
    *a4 = 0;
    a4[1] = 0;
  }
}

void sub_1004DDEE4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

void sub_1004DDF18(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v3 = *(void **)(a1 + 48);
  uint64_t v4 = *(NSObject **)(a1 + 8);
  if (v3)
  {
    if (os_log_type_enabled(*(os_log_t *)(a1 + 8), OS_LOG_TYPE_DEFAULT))
    {
      if (*((char *)a3 + 23) < 0) {
        a3 = (uint64_t *)*a3;
      }
      int v8 = 136315138;
      id v9 = a3;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Attempting to stop geofencing for [%s]", (uint8_t *)&v8, 0xCu);
      uint64_t v3 = *(void **)(a1 + 48);
    }
    [v3 stopGeofence:*(void *)(*(void *)a2 + 8)];
  }
  else if (os_log_type_enabled(*(os_log_t *)(a1 + 8), OS_LOG_TYPE_ERROR))
  {
    LOWORD(v8) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "Invalid Location module", (uint8_t *)&v8, 2u);
  }
}

void sub_1004DE034(uint64_t a1, void **a2)
{
  uint64_t v4 = *(NSObject **)(a1 + 8);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
  {
    unint64_t v16 = a2;
    if (*((char *)a2 + 23) < 0) {
      unint64_t v16 = *a2;
    }
    *(_DWORD *)long long buf = 136446210;
    *(void *)&uint8_t buf[4] = v16;
    _os_log_error_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "geofence setup failure: %{public}s", buf, 0xCu);
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 32));
  uint64_t v6 = ServiceMap;
  if (v7 < 0)
  {
    int v8 = (unsigned __int8 *)(v7 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v9 = 5381;
    do
    {
      uint64_t v7 = v9;
      unsigned int v10 = *v8++;
      uint64_t v9 = (33 * v9) ^ v10;
    }
    while (v10);
  }
  std::mutex::lock(ServiceMap);
  *(void *)long long buf = v7;
  uint8x8_t v11 = sub_10004D37C(&v6[1].__m_.__sig, (unint64_t *)buf);
  if (v11)
  {
    uint64_t v13 = v11[3];
    id v12 = (std::__shared_weak_count *)v11[4];
    if (v12)
    {
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v6);
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v12);
      char v14 = 0;
      if (!v13) {
        goto LABEL_8;
      }
      goto LABEL_13;
    }
  }
  else
  {
    uint64_t v13 = 0;
  }
  std::mutex::unlock(v6);
  id v12 = 0;
  char v14 = 1;
  if (!v13)
  {
LABEL_8:
    id v15 = *(NSObject **)(a1 + 8);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "Failed to get Geofence manager", buf, 2u);
      if (v14) {
        return;
      }
      goto LABEL_18;
    }
LABEL_17:
    if (v14) {
      return;
    }
    goto LABEL_18;
  }
LABEL_13:
  if (*((char *)a2 + 23) < 0)
  {
    sub_10004FC84(__p, *a2, (unint64_t)a2[1]);
  }
  else
  {
    *(_OWORD *)OsLogContext __p = *(_OWORD *)a2;
    unint64_t v18 = a2[2];
  }
  (*(void (**)(uint64_t, void **))(*(void *)v13 + 56))(v13, __p);
  if ((SHIBYTE(v18) & 0x80000000) == 0) {
    goto LABEL_17;
  }
  operator delete(__p[0]);
  if ((v14 & 1) == 0) {
LABEL_18:
  }
    sub_10004D2C8(v12);
}

void sub_1004DE258(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if ((v15 & 1) == 0) {
    sub_10004D2C8(v14);
  }
  _Unwind_Resume(exception_object);
}

void sub_1004DE2A0(uint64_t a1, void **a2)
{
  uint64_t v4 = *(NSObject **)(a1 + 8);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = a2;
    if (*((char *)a2 + 23) < 0) {
      uint64_t v5 = *a2;
    }
    *(_DWORD *)long long buf = 136446210;
    *(void *)&uint8_t buf[4] = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I geofence setup success: %{public}s", buf, 0xCu);
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 32));
  uint64_t v7 = ServiceMap;
  if (v8 < 0)
  {
    uint64_t v9 = (unsigned __int8 *)(v8 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v10 = 5381;
    do
    {
      uint64_t v8 = v10;
      unsigned int v11 = *v9++;
      uint64_t v10 = (33 * v10) ^ v11;
    }
    while (v11);
  }
  std::mutex::lock(ServiceMap);
  *(void *)long long buf = v8;
  id v12 = sub_10004D37C(&v7[1].__m_.__sig, (unint64_t *)buf);
  if (v12)
  {
    uint64_t v14 = v12[3];
    uint64_t v13 = (std::__shared_weak_count *)v12[4];
    if (v13)
    {
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v7);
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v13);
      char v15 = 0;
      if (!v14) {
        goto LABEL_11;
      }
      goto LABEL_16;
    }
  }
  else
  {
    uint64_t v14 = 0;
  }
  std::mutex::unlock(v7);
  uint64_t v13 = 0;
  char v15 = 1;
  if (!v14)
  {
LABEL_11:
    unint64_t v16 = *(NSObject **)(a1 + 8);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "Failed to get Geofence manager", buf, 2u);
      if (v15) {
        return;
      }
      goto LABEL_21;
    }
LABEL_20:
    if (v15) {
      return;
    }
    goto LABEL_21;
  }
LABEL_16:
  if (*((char *)a2 + 23) < 0)
  {
    sub_10004FC84(__p, *a2, (unint64_t)a2[1]);
  }
  else
  {
    *(_OWORD *)OsLogContext __p = *(_OWORD *)a2;
    unint64_t v18 = a2[2];
  }
  (*(void (**)(uint64_t, void **))(*(void *)v14 + 64))(v14, __p);
  if ((SHIBYTE(v18) & 0x80000000) == 0) {
    goto LABEL_20;
  }
  operator delete(__p[0]);
  if (v15) {
    return;
  }
LABEL_21:
  sub_10004D2C8(v13);
}

void sub_1004DE4C0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if ((v15 & 1) == 0) {
    sub_10004D2C8(v14);
  }
  _Unwind_Resume(exception_object);
}

void sub_1004DE508(uint64_t a1, void **a2)
{
  uint64_t v4 = *(NSObject **)(a1 + 8);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = a2;
    if (*((char *)a2 + 23) < 0) {
      uint64_t v5 = *a2;
    }
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I geofence setup failure: %s", buf, 0xCu);
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 32));
  uint64_t v7 = ServiceMap;
  if (v8 < 0)
  {
    uint64_t v9 = (unsigned __int8 *)(v8 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v10 = 5381;
    do
    {
      uint64_t v8 = v10;
      unsigned int v11 = *v9++;
      uint64_t v10 = (33 * v10) ^ v11;
    }
    while (v11);
  }
  std::mutex::lock(ServiceMap);
  *(void *)long long buf = v8;
  id v12 = sub_10004D37C(&v7[1].__m_.__sig, (unint64_t *)buf);
  if (v12)
  {
    uint64_t v14 = v12[3];
    uint64_t v13 = (std::__shared_weak_count *)v12[4];
    if (v13)
    {
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v7);
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v13);
      char v15 = 0;
      if (!v14) {
        goto LABEL_11;
      }
      goto LABEL_16;
    }
  }
  else
  {
    uint64_t v14 = 0;
  }
  std::mutex::unlock(v7);
  uint64_t v13 = 0;
  char v15 = 1;
  if (!v14)
  {
LABEL_11:
    unint64_t v16 = *(NSObject **)(a1 + 8);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "Failed to get Geofence manager", buf, 2u);
      if (v15) {
        return;
      }
      goto LABEL_21;
    }
LABEL_20:
    if (v15) {
      return;
    }
    goto LABEL_21;
  }
LABEL_16:
  if (*((char *)a2 + 23) < 0)
  {
    sub_10004FC84(__p, *a2, (unint64_t)a2[1]);
  }
  else
  {
    *(_OWORD *)OsLogContext __p = *(_OWORD *)a2;
    unint64_t v18 = a2[2];
  }
  (*(void (**)(uint64_t, void **))(*(void *)v14 + 72))(v14, __p);
  if ((SHIBYTE(v18) & 0x80000000) == 0) {
    goto LABEL_20;
  }
  operator delete(__p[0]);
  if (v15) {
    return;
  }
LABEL_21:
  sub_10004D2C8(v13);
}

void sub_1004DE728(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if ((v15 & 1) == 0) {
    sub_10004D2C8(v14);
  }
  _Unwind_Resume(exception_object);
}

void sub_1004DE770(uint64_t a1, void **a2, uint64_t a3)
{
  uint64_t v6 = *(NSObject **)(a1 + 8);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v7 = a2;
    if (*((char *)a2 + 23) < 0) {
      uint64_t v7 = *a2;
    }
    *(_DWORD *)long long buf = 136446210;
    *(void *)&uint8_t buf[4] = v7;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I geofence didDeterminState: %{public}s", buf, 0xCu);
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 32));
  uint64_t v9 = ServiceMap;
  if (v10 < 0)
  {
    unsigned int v11 = (unsigned __int8 *)(v10 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v12 = 5381;
    do
    {
      uint64_t v10 = v12;
      unsigned int v13 = *v11++;
      uint64_t v12 = (33 * v12) ^ v13;
    }
    while (v13);
  }
  std::mutex::lock(ServiceMap);
  *(void *)long long buf = v10;
  uint64_t v14 = sub_10004D37C(&v9[1].__m_.__sig, (unint64_t *)buf);
  if (v14)
  {
    uint64_t v16 = v14[3];
    char v15 = (std::__shared_weak_count *)v14[4];
    if (v15)
    {
      atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v9);
      atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v15);
      char v17 = 0;
      if (!v16) {
        goto LABEL_11;
      }
      goto LABEL_16;
    }
  }
  else
  {
    uint64_t v16 = 0;
  }
  std::mutex::unlock(v9);
  char v15 = 0;
  char v17 = 1;
  if (!v16)
  {
LABEL_11:
    unint64_t v18 = *(NSObject **)(a1 + 8);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "Failed to get Geofence manager", buf, 2u);
      if (v17) {
        return;
      }
      goto LABEL_21;
    }
LABEL_20:
    if (v17) {
      return;
    }
    goto LABEL_21;
  }
LABEL_16:
  if (*((char *)a2 + 23) < 0)
  {
    sub_10004FC84(__p, *a2, (unint64_t)a2[1]);
  }
  else
  {
    *(_OWORD *)OsLogContext __p = *(_OWORD *)a2;
    float v20 = a2[2];
  }
  (*(void (**)(uint64_t, void **, uint64_t))(*(void *)v16 + 96))(v16, __p, a3);
  if ((SHIBYTE(v20) & 0x80000000) == 0) {
    goto LABEL_20;
  }
  operator delete(__p[0]);
  if (v17) {
    return;
  }
LABEL_21:
  sub_10004D2C8(v15);
}

void sub_1004DE998(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if ((v15 & 1) == 0) {
    sub_10004D2C8(v14);
  }
  _Unwind_Resume(exception_object);
}

void sub_1004DE9E0(uint64_t a1, void **a2)
{
  uint64_t v4 = *(NSObject **)(a1 + 8);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = a2;
    if (*((char *)a2 + 23) < 0) {
      uint64_t v5 = *a2;
    }
    *(_DWORD *)long long buf = 136446210;
    *(void *)&uint8_t buf[4] = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I geofence entry: %{public}s", buf, 0xCu);
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 32));
  uint64_t v7 = ServiceMap;
  if (v8 < 0)
  {
    uint64_t v9 = (unsigned __int8 *)(v8 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v10 = 5381;
    do
    {
      uint64_t v8 = v10;
      unsigned int v11 = *v9++;
      uint64_t v10 = (33 * v10) ^ v11;
    }
    while (v11);
  }
  std::mutex::lock(ServiceMap);
  *(void *)long long buf = v8;
  uint64_t v12 = sub_10004D37C(&v7[1].__m_.__sig, (unint64_t *)buf);
  if (v12)
  {
    uint64_t v14 = v12[3];
    unsigned int v13 = (std::__shared_weak_count *)v12[4];
    if (v13)
    {
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v7);
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v13);
      char v15 = 0;
      if (!v14) {
        goto LABEL_11;
      }
      goto LABEL_16;
    }
  }
  else
  {
    uint64_t v14 = 0;
  }
  std::mutex::unlock(v7);
  unsigned int v13 = 0;
  char v15 = 1;
  if (!v14)
  {
LABEL_11:
    uint64_t v16 = *(NSObject **)(a1 + 8);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "Failed to get Geofence manager", buf, 2u);
      if (v15) {
        return;
      }
      goto LABEL_21;
    }
LABEL_20:
    if (v15) {
      return;
    }
    goto LABEL_21;
  }
LABEL_16:
  if (*((char *)a2 + 23) < 0)
  {
    sub_10004FC84(__p, *a2, (unint64_t)a2[1]);
  }
  else
  {
    *(_OWORD *)OsLogContext __p = *(_OWORD *)a2;
    unint64_t v18 = a2[2];
  }
  (*(void (**)(uint64_t, void **))(*(void *)v14 + 80))(v14, __p);
  if ((SHIBYTE(v18) & 0x80000000) == 0) {
    goto LABEL_20;
  }
  operator delete(__p[0]);
  if (v15) {
    return;
  }
LABEL_21:
  sub_10004D2C8(v13);
}

void sub_1004DEC00(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if ((v15 & 1) == 0) {
    sub_10004D2C8(v14);
  }
  _Unwind_Resume(exception_object);
}

void sub_1004DEC48(uint64_t a1, void **a2)
{
  uint64_t v4 = *(NSObject **)(a1 + 8);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = a2;
    if (*((char *)a2 + 23) < 0) {
      uint64_t v5 = *a2;
    }
    *(_DWORD *)long long buf = 136446210;
    *(void *)&uint8_t buf[4] = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I geofence exit: %{public}s", buf, 0xCu);
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 32));
  uint64_t v7 = ServiceMap;
  if (v8 < 0)
  {
    uint64_t v9 = (unsigned __int8 *)(v8 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v10 = 5381;
    do
    {
      uint64_t v8 = v10;
      unsigned int v11 = *v9++;
      uint64_t v10 = (33 * v10) ^ v11;
    }
    while (v11);
  }
  std::mutex::lock(ServiceMap);
  *(void *)long long buf = v8;
  uint64_t v12 = sub_10004D37C(&v7[1].__m_.__sig, (unint64_t *)buf);
  if (v12)
  {
    uint64_t v14 = v12[3];
    unsigned int v13 = (std::__shared_weak_count *)v12[4];
    if (v13)
    {
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v7);
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v13);
      char v15 = 0;
      if (!v14) {
        goto LABEL_11;
      }
      goto LABEL_16;
    }
  }
  else
  {
    uint64_t v14 = 0;
  }
  std::mutex::unlock(v7);
  unsigned int v13 = 0;
  char v15 = 1;
  if (!v14)
  {
LABEL_11:
    uint64_t v16 = *(NSObject **)(a1 + 8);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "Failed to get Geofence manager", buf, 2u);
      if (v15) {
        return;
      }
      goto LABEL_21;
    }
LABEL_20:
    if (v15) {
      return;
    }
    goto LABEL_21;
  }
LABEL_16:
  if (*((char *)a2 + 23) < 0)
  {
    sub_10004FC84(__p, *a2, (unint64_t)a2[1]);
  }
  else
  {
    *(_OWORD *)OsLogContext __p = *(_OWORD *)a2;
    unint64_t v18 = a2[2];
  }
  (*(void (**)(uint64_t, void **))(*(void *)v14 + 88))(v14, __p);
  if ((SHIBYTE(v18) & 0x80000000) == 0) {
    goto LABEL_20;
  }
  operator delete(__p[0]);
  if (v15) {
    return;
  }
LABEL_21:
  sub_10004D2C8(v13);
}

void sub_1004DEE68(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if ((v15 & 1) == 0) {
    sub_10004D2C8(v14);
  }
  _Unwind_Resume(exception_object);
}

void sub_1004DEEB0(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 8);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Location services disabled", buf, 2u);
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 32));
  uint64_t v4 = ServiceMap;
  if ((v5 & 0x8000000000000000) != 0)
  {
    uint64_t v6 = (unsigned __int8 *)(v5 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v7 = 5381;
    do
    {
      unint64_t v5 = v7;
      unsigned int v8 = *v6++;
      uint64_t v7 = (33 * v7) ^ v8;
    }
    while (v8);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v16 = v5;
  uint64_t v9 = sub_10004D37C(&v4[1].__m_.__sig, &v16);
  if (v9)
  {
    uint64_t v11 = v9[3];
    uint64_t v10 = (std::__shared_weak_count *)v9[4];
    if (v10)
    {
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v4);
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v10);
      char v12 = 0;
      if (!v11) {
        goto LABEL_9;
      }
LABEL_13:
      (*(void (**)(uint64_t))(*(void *)v11 + 120))(v11);
      goto LABEL_14;
    }
  }
  else
  {
    uint64_t v11 = 0;
  }
  std::mutex::unlock(v4);
  uint64_t v10 = 0;
  char v12 = 1;
  if (v11) {
    goto LABEL_13;
  }
LABEL_9:
  unsigned int v13 = *(NSObject **)(a1 + 8);
  if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)uint64_t v14 = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "Failed to get Geofence manager", v14, 2u);
  }
LABEL_14:
  if ((v12 & 1) == 0) {
    sub_10004D2C8(v10);
  }
}

void sub_1004DF034(_Unwind_Exception *exception_object)
{
  if ((v2 & 1) == 0) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_1004DF050(uint64_t a1)
{
  char v2 = *(NSObject **)(a1 + 8);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Monitoring failed with error...", buf, 2u);
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 32));
  uint64_t v4 = ServiceMap;
  if ((v5 & 0x8000000000000000) != 0)
  {
    uint64_t v6 = (unsigned __int8 *)(v5 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v7 = 5381;
    do
    {
      unint64_t v5 = v7;
      unsigned int v8 = *v6++;
      uint64_t v7 = (33 * v7) ^ v8;
    }
    while (v8);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v16 = v5;
  uint64_t v9 = sub_10004D37C(&v4[1].__m_.__sig, &v16);
  if (v9)
  {
    uint64_t v11 = v9[3];
    uint64_t v10 = (std::__shared_weak_count *)v9[4];
    if (v10)
    {
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v4);
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v10);
      char v12 = 0;
      if (!v11) {
        goto LABEL_9;
      }
LABEL_13:
      (*(void (**)(uint64_t))(*(void *)v11 + 104))(v11);
      goto LABEL_14;
    }
  }
  else
  {
    uint64_t v11 = 0;
  }
  std::mutex::unlock(v4);
  uint64_t v10 = 0;
  char v12 = 1;
  if (v11) {
    goto LABEL_13;
  }
LABEL_9:
  unsigned int v13 = *(NSObject **)(a1 + 8);
  if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)uint64_t v14 = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "Failed to get Geofence manager", v14, 2u);
  }
LABEL_14:
  if ((v12 & 1) == 0) {
    sub_10004D2C8(v10);
  }
}

void sub_1004DF1D4(_Unwind_Exception *exception_object)
{
  if ((v2 & 1) == 0) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_1004DF1F0(uint64_t a1)
{
  if (*(void *)(a1 + 48))
  {
    uint64_t v1 = *(void **)(a1 + 48);
    [v1 resetMonitoredRegions];
  }
  else
  {
    char v2 = *(NSObject **)(a1 + 8);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t v3 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_ERROR, "Invalid Location module", v3, 2u);
    }
  }
}

id sub_1004DF280@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  id result = *(id *)(a1 + 48);
  if (result) {
    return [result getCurrentLocation];
  }
  *a2 = 0;
  a2[1] = 0;
  return result;
}

void sub_1004DF298(uint64_t a1)
{
  sub_1004DF2D0(a1);

  operator delete();
}

void sub_1004DF2D0(uint64_t a1)
{
  *(void *)a1 = off_1019D8520;

  char v2 = *(std::__shared_weak_count **)(a1 + 40);
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 24);
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 8));

  LocationDelegateInterface::~LocationDelegateInterface((LocationDelegateInterface *)a1);
}

void sub_1004DF348(void *a1@<X1>, void *a2@<X8>)
{
  uint64_t v4 = operator new(0x50uLL);
  sub_1004DF3BC(v4, a1);
  *a2 = v4 + 3;
  a2[1] = v4;

  sub_1000B3BC8((uint64_t)a2, v4 + 5, (uint64_t)(v4 + 3));
}

void sub_1004DF3A8(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_1004DF3BC(void *a1, void *a2)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = off_1019D8640;
  sub_1004DD894(a1 + 3, a2);
  return a1;
}

void sub_1004DF404(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void sub_1004DF418(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1019D8640;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1004DF438(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1019D8640;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_1004DF48C(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 24) + 152))();
}

void sub_1004DF4B4()
{
}

void sub_1004DF52C()
{
}

uint64_t sub_1004DF550(uint64_t a1, void *a2, uint64_t *a3)
{
  unint64_t v5 = (std::__shared_weak_count *)a3[1];
  uint64_t v10 = *a3;
  uint64_t v11 = v5;
  if (v5) {
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  sub_100A2BF08(a1, a2, &v10, "ps.cld");
  uint64_t v6 = (capabilities::ct *)v11;
  if (v11) {
    sub_10004D2C8(v11);
  }
  *(void *)a1 = off_1019D8690;
  *(_OWORD *)(a1 + 1024) = 0u;
  if (capabilities::ct::supportsThumperService(v6))
  {
    uint64_t v7 = *(void *)(a1 + 88);
    if (v7) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v7 + 8), 1uLL, memory_order_relaxed);
    }
    uint64_t v8 = a2[6];
    if (v8) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v8 + 8), 1uLL, memory_order_relaxed);
    }
    sub_10125B7A8();
  }
  return a1;
}

void sub_1004DF678(_Unwind_Exception *a1)
{
  if (v3) {
    sub_10004D2C8(v3);
  }
  if (v2) {
    sub_10004D2C8(v2);
  }
  unint64_t v5 = *(std::__shared_weak_count **)(v1 + 1032);
  if (v5) {
    sub_10004D2C8(v5);
  }
  sub_100A2C4CC(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1004DF6CC(uint64_t a1)
{
  sub_100A2C64C(a1);
  uint64_t result = *(void *)(a1 + 1024);
  if (result)
  {
    uint64_t v3 = *(uint64_t (**)(void))(*(void *)result + 120);
    return v3();
  }
  return result;
}

uint64_t sub_1004DF734(uint64_t a1)
{
  char v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = **(PersonalityInfo ***)(a1 + 80);
    if (v3) {
      uint64_t v4 = (const char *)PersonalityInfo::logPrefix(v3);
    }
    else {
      uint64_t v4 = "-1";
    }
    int v7 = 136315394;
    uint64_t v8 = v4;
    __int16 v9 = 2080;
    uint64_t v10 = " ";
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I %s%sstarting", (uint8_t *)&v7, 0x16u);
  }
  sub_100A2DD80(a1);
  uint64_t v5 = *(void *)(a1 + 1024);
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 128))(v5);
  }
  return (*(uint64_t (**)(uint64_t, void, void))(*(void *)a1 + 344))(a1, 0, 0);
}

void sub_1004DF86C(uint64_t a1, NSObject **a2)
{
  uint64_t v4 = *(void *)(a1 + 1024);
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 136))(v4);
  }
  uint64_t v5 = *a2;
  if (v5)
  {
    dispatch_retain(v5);
    dispatch_group_enter(v5);
  }
  *(unsigned char *)(a1 + 354) = 1;
  ctu::RestModule::disconnect((ctu::RestModule *)(a1 + 64));
  if (v5)
  {
    dispatch_group_leave(v5);
    dispatch_release(v5);
  }
}

void sub_1004DF910(_Unwind_Exception *exception_object)
{
  if (v1)
  {
    dispatch_group_leave(v1);
    dispatch_release(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1004DF930(void **a1, uint64_t a2, uint64_t *a3)
{
  sub_1001BF980(a1 + 10, a3);
  uint64_t v4 = (uint64_t (*)(void **, void, void))(*a1)[43];

  return v4(a1, 0, 0);
}

uint64_t sub_1004DF9A0(void **a1, uint64_t *a2)
{
  sub_1001BF980(a1 + 10, a2);
  uint64_t v3 = (uint64_t (*)(void **, void, void))(*a1)[43];

  return v3(a1, 0, 0);
}

uint64_t sub_1004DFA0C(void **a1, uint64_t *a2)
{
  sub_1001BF980(a1 + 10, a2);
  uint64_t v3 = (uint64_t (*)(void **, void, void))(*a1)[43];

  return v3(a1, 0, 0);
}

uint64_t sub_1004DFA78(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 1024);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 288))();
  }
  return result;
}

const void **sub_1004DFAB0(uint64_t a1)
{
  uint64_t result = *(const void ***)(a1 + 1024);
  if (result) {
    return sub_10126EF14((uint64_t)result);
  }
  return result;
}

uint64_t sub_1004DFAC0(uint64_t a1)
{
  void (***v38)(uint64_t *__return_ptr, void, uint64_t);
  char v39;
  std::mutex *v40;
  std::mutex *v41;
  unsigned __int8 *v42;
  uint64_t v43;
  unsigned int v44;
  void *v45;
  std::__shared_weak_count *v46;
  void (***v47)(uint64_t *__return_ptr, void, uint64_t);
  char v48;
  uint64_t v49;
  std::__shared_weak_count *v50;
  unsigned char buf[12];
  __int16 v52;
  const char *v53;
  void *v54;
  char v55;
  char v56;
  void *__p;
  char v58;
  char v59;

  if (!*(unsigned char *)(a1 + 344)) {
    goto LABEL_20;
  }
  if ((*(char *)(a1 + 191) & 0x80000000) == 0)
  {
    if (*(unsigned char *)(a1 + 191)) {
      goto LABEL_4;
    }
LABEL_20:
    __int16 v9 = *(NSObject **)(a1 + 40);
    BOOL v10 = os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT);
    uint64_t result = 0;
    if (!v10) {
      return result;
    }
    char v12 = **(PersonalityInfo ***)(a1 + 80);
    if (v12) {
      unsigned int v13 = (const char *)PersonalityInfo::logPrefix(v12);
    }
    else {
      unsigned int v13 = "-1";
    }
    *(_DWORD *)long long buf = 136315394;
    *(void *)&uint8_t buf[4] = v13;
    long long v52 = 2080;
    v53 = " ";
    long long v19 = "#I %s%srequest ignored because sip-uri in not in place";
LABEL_55:
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, v19, buf, 0x16u);
    return 0;
  }
  if (!*(void *)(a1 + 176)) {
    goto LABEL_20;
  }
LABEL_4:
  uint64_t v2 = *(unsigned __int8 *)(a1 + 167);
  if ((v2 & 0x80u) == 0) {
    uint64_t v3 = *(unsigned __int8 *)(a1 + 167);
  }
  else {
    uint64_t v3 = *(void *)(a1 + 152);
  }
  uint64_t v4 = *(unsigned __int8 *)(a1 + 143);
  int v5 = (char)v4;
  if ((v4 & 0x80u) != 0) {
    uint64_t v4 = *(void *)(a1 + 128);
  }
  if (v3 != v4)
  {
LABEL_23:
    BOOL v8 = 0;
    uint64_t v14 = (unsigned char *)(a1 + 353);
    goto LABEL_24;
  }
  if (v5 >= 0) {
    uint64_t v6 = (unsigned __int8 *)(a1 + 120);
  }
  else {
    uint64_t v6 = *(unsigned __int8 **)(a1 + 120);
  }
  if ((v2 & 0x80) != 0)
  {
    BOOL v8 = memcmp(*(const void **)(a1 + 144), v6, *(void *)(a1 + 152)) == 0;
  }
  else
  {
    if (*(unsigned char *)(a1 + 167))
    {
      int v7 = (unsigned __int8 *)(a1 + 144);
      while (*v7 == *v6)
      {
        ++v7;
        ++v6;
        if (!--v2) {
          goto LABEL_18;
        }
      }
      goto LABEL_23;
    }
LABEL_18:
    BOOL v8 = 1;
  }
  uint64_t v14 = (unsigned char *)(a1 + 353);
  if (*(unsigned char *)(a1 + 353) && v8)
  {
    float v20 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
    {
      float v21 = **(PersonalityInfo ***)(a1 + 80);
      if (v21) {
        BOOL v22 = (const char *)PersonalityInfo::logPrefix(v21);
      }
      else {
        BOOL v22 = "-1";
      }
      *(_DWORD *)long long buf = 136315394;
      *(void *)&uint8_t buf[4] = v22;
      long long v52 = 2080;
      v53 = " ";
      _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#I %s%sgetPSAS call in progress - skip", buf, 0x16u);
    }
    return 1;
  }
LABEL_24:
  int v15 = *(_DWORD *)(a1 + 408);
  if (v15 && (v15 != 1 || *(void *)(a1 + 416) || !*(_DWORD *)(a1 + 412)))
  {
    __int16 v9 = *(NSObject **)(a1 + 40);
    BOOL v16 = os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT);
    uint64_t result = 0;
    if (!v16) {
      return result;
    }
    char v17 = **(PersonalityInfo ***)(a1 + 80);
    if (v17) {
      unint64_t v18 = (const char *)PersonalityInfo::logPrefix(v17);
    }
    else {
      unint64_t v18 = "-1";
    }
    *(_DWORD *)long long buf = 136315394;
    *(void *)&uint8_t buf[4] = v18;
    long long v52 = 2080;
    v53 = " ";
    long long v19 = "#I %s%sgetPSAS request blocked by throttle control";
    goto LABEL_55;
  }
  if (sub_100A2E718(a1))
  {
    __int16 v9 = *(NSObject **)(a1 + 40);
    BOOL v23 = os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT);
    uint64_t result = 0;
    if (!v23) {
      return result;
    }
    unint64_t v24 = **(PersonalityInfo ***)(a1 + 80);
    if (v24) {
      long long v25 = (const char *)PersonalityInfo::logPrefix(v24);
    }
    else {
      long long v25 = "-1";
    }
    *(_DWORD *)long long buf = 136315394;
    *(void *)&uint8_t buf[4] = v25;
    long long v52 = 2080;
    v53 = " ";
    long long v19 = "#I %s%sservice allowed without entitlement check - getPSAS bypassed";
    goto LABEL_55;
  }
  if (!v8) {
    std::string::operator=((std::string *)(a1 + 144), (const std::string *)(a1 + 120));
  }
  char v26 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
  {
    long long v27 = **(PersonalityInfo ***)(a1 + 80);
    if (v27) {
      uint64_t v28 = (const char *)PersonalityInfo::logPrefix(v27);
    }
    else {
      uint64_t v28 = "-1";
    }
    *(_DWORD *)long long buf = 136315394;
    *(void *)&uint8_t buf[4] = v28;
    long long v52 = 2080;
    v53 = " ";
    _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "#I %s%s================================ Call Update Registered Location ================================", buf, 0x16u);
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 48));
  unint64_t v30 = ServiceMap;
  uint64_t v32 = v31;
  if (v31 < 0)
  {
    uint8x8_t v33 = (unsigned __int8 *)(v31 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v34 = 5381;
    do
    {
      uint64_t v32 = v34;
      unsigned int v35 = *v33++;
      uint64_t v34 = (33 * v34) ^ v35;
    }
    while (v35);
  }
  std::mutex::lock(ServiceMap);
  *(void *)long long buf = v32;
  unint64_t v36 = sub_10004D37C(&v30[1].__m_.__sig, (unint64_t *)buf);
  if (v36)
  {
    v38 = (void (***)(uint64_t *__return_ptr, void, uint64_t))v36[3];
    uint64_t v37 = (std::__shared_weak_count *)v36[4];
    if (v37)
    {
      atomic_fetch_add_explicit(&v37->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v30);
      atomic_fetch_add_explicit(&v37->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v37);
      unint64_t v39 = 0;
      goto LABEL_67;
    }
  }
  else
  {
    v38 = 0;
  }
  std::mutex::unlock(v30);
  uint64_t v37 = 0;
  unint64_t v39 = 1;
LABEL_67:
  (**v38)(&v49, v38, **(void **)(a1 + 80) + 24);
  *(void *)long long buf = off_1019D88E8;
  v54 = buf;
  (*(void (**)(uint64_t, uint64_t, unsigned char *))(*(void *)v49 + 328))(v49, 1, buf);
  sub_100060644(buf);
  if (v50) {
    sub_10004D2C8(v50);
  }
  if ((v39 & 1) == 0) {
    sub_10004D2C8(v37);
  }
  v40 = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 48));
  uint64_t v41 = v40;
  if (v31 < 0)
  {
    xpc_object_t v42 = (unsigned __int8 *)(v31 & 0x7FFFFFFFFFFFFFFFLL);
    long long v43 = 5381;
    do
    {
      uint64_t v31 = v43;
      uint64_t v44 = *v42++;
      long long v43 = (33 * v43) ^ v44;
    }
    while (v44);
  }
  std::mutex::lock(v40);
  *(void *)long long buf = v31;
  long long v45 = sub_10004D37C(&v41[1].__m_.__sig, (unint64_t *)buf);
  if (v45)
  {
    v47 = (void (***)(uint64_t *__return_ptr, void, uint64_t))v45[3];
    uint64_t v46 = (std::__shared_weak_count *)v45[4];
    if (v46)
    {
      atomic_fetch_add_explicit(&v46->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v41);
      atomic_fetch_add_explicit(&v46->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v46);
      uint64_t v48 = 0;
      goto LABEL_79;
    }
  }
  else
  {
    v47 = 0;
  }
  std::mutex::unlock(v41);
  uint64_t v46 = 0;
  uint64_t v48 = 1;
LABEL_79:
  (**v47)(&v49, v47, **(void **)(a1 + 80) + 24);
  uint8_t buf[8] = 0;
  LOBYTE(v52) = 0;
  BYTE2(v53) = 0;
  LOBYTE(v54) = 0;
  v56 = 0;
  LOBYTE(__p) = 0;
  v59 = 0;
  *(_DWORD *)long long buf = 0;
  uint8_t buf[4] = 0;
  (*(void (**)(void))(*(void *)v49 + 352))();
  if (v59 && v58 < 0) {
    operator delete(__p);
  }
  if (v56 && v55 < 0) {
    operator delete(v54);
  }
  if (v50) {
    sub_10004D2C8(v50);
  }
  if ((v48 & 1) == 0) {
    sub_10004D2C8(v46);
  }
  uint64_t result = 1;
  unsigned char *v14 = 1;
  return result;
}

void sub_1004E0170(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, std::__shared_weak_count *a5, ...)
{
  va_start(va, a5);
  sub_10016A3E8((uint64_t)va);
  if (a5) {
    sub_10004D2C8(a5);
  }
  if ((v6 & 1) == 0) {
    sub_10004D2C8(v5);
  }
  _Unwind_Resume(a1);
}

void sub_1004E01D4(uint64_t a1, const std::string *a2)
{
  uint64_t v2 = a2;
  if (*(unsigned char *)(a1 + 344))
  {
    uint64_t v4 = *(unsigned __int8 *)(a1 + 191);
    if ((v4 & 0x80u) == 0) {
      uint64_t v5 = *(unsigned __int8 *)(a1 + 191);
    }
    else {
      uint64_t v5 = *(void *)(a1 + 176);
    }
    std::string::size_type size = HIBYTE(a2->__r_.__value_.__r.__words[2]);
    int v7 = (char)size;
    if ((size & 0x80u) != 0) {
      std::string::size_type size = a2->__r_.__value_.__l.__size_;
    }
    if (v5 == size)
    {
      BOOL v8 = (const void **)(a1 + 168);
      if (v7 < 0) {
        a2 = (const std::string *)a2->__r_.__value_.__r.__words[0];
      }
      if ((v4 & 0x80) != 0)
      {
        if (!memcmp(*v8, a2, *(void *)(a1 + 176))) {
          return;
        }
      }
      else
      {
        if (!*(unsigned char *)(a1 + 191)) {
          return;
        }
        while (*(unsigned __int8 *)v8 == a2->__r_.__value_.__s.__data_[0])
        {
          BOOL v8 = (const void **)((char *)v8 + 1);
          a2 = (const std::string *)((char *)a2 + 1);
          if (!--v4) {
            return;
          }
        }
      }
    }
  }
  uint64_t v9 = a1 + 144;
  uint64_t v33 = 0;
  *(_OWORD *)OsLogContext __p = 0u;
  long long v32 = 0u;
  *(_OWORD *)uint64_t v29 = 0u;
  long long v30 = 0u;
  long long v27 = 0u;
  long long v28 = 0u;
  long long v25 = 0u;
  *(_OWORD *)char v26 = 0u;
  long long v23 = 0u;
  *(_OWORD *)unint64_t v24 = 0u;
  *(_OWORD *)float v21 = 0u;
  *(_OWORD *)BOOL v22 = 0u;
  sub_1001DDF34(a1 + 144, (long long *)v21);
  if ((_BYTE)v33 && SHIBYTE(v32) < 0) {
    operator delete(__p[1]);
  }
  if (LOBYTE(__p[0]) && SHIBYTE(v30) < 0) {
    operator delete(v29[1]);
  }
  if (BYTE8(v27) && SBYTE7(v27) < 0) {
    operator delete(v26[0]);
  }
  if (BYTE8(v25) && SBYTE7(v25) < 0) {
    operator delete(v24[0]);
  }
  if (SHIBYTE(v23) < 0) {
    operator delete(v22[1]);
  }
  if (SHIBYTE(v22[0]) < 0) {
    operator delete(v21[0]);
  }
  std::string::operator=((std::string *)(a1 + 168), v2);
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 48));
  uint64_t v11 = ServiceMap;
  if (v12 < 0)
  {
    unsigned int v13 = (unsigned __int8 *)(v12 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v14 = 5381;
    do
    {
      uint64_t v12 = v14;
      unsigned int v15 = *v13++;
      uint64_t v14 = (33 * v14) ^ v15;
    }
    while (v15);
  }
  std::mutex::lock(ServiceMap);
  v21[0] = (void *)v12;
  BOOL v16 = sub_10004D37C(&v11[1].__m_.__sig, (unint64_t *)v21);
  if (v16)
  {
    uint64_t v18 = v16[3];
    char v17 = (std::__shared_weak_count *)v16[4];
    if (v17)
    {
      atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v11);
      atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v17);
      char v19 = 0;
      goto LABEL_40;
    }
  }
  else
  {
    uint64_t v18 = 0;
  }
  std::mutex::unlock(v11);
  char v17 = 0;
  char v19 = 1;
LABEL_40:
  uint64_t v20 = **(void **)(a1 + 80);
  sub_1003A8E80(v9, v21);
  (*(void (**)(uint64_t, uint64_t, const __CFString *, void *, void, void, uint64_t, void))(*(void *)v18 + 16))(v18, v20 + 24, @"onfile.status", v21[0], kPhoneServicesWalletDomain, 0, 4, 0);
  sub_100057D78((const void **)v21);
  if ((v19 & 1) == 0) {
    sub_10004D2C8(v17);
  }
}

void sub_1004E0464(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9)
{
  sub_100057D78(&a9);
  if ((v10 & 1) == 0) {
    sub_10004D2C8(v9);
  }
  _Unwind_Resume(a1);
}

void sub_1004E04A0(uint64_t a1, uint64_t a2)
{
  void (***v12)(uint64_t *__return_ptr, void, uint64_t);
  char v13;
  uint64_t v14;
  std::__shared_weak_count *v15;
  unint64_t v16;

  sub_100A2BBB0(a1 + 360);
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 48));
  uint64_t v5 = ServiceMap;
  if ((v6 & 0x8000000000000000) != 0)
  {
    int v7 = (unsigned __int8 *)(v6 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v8 = 5381;
    do
    {
      unint64_t v6 = v8;
      unsigned int v9 = *v7++;
      uint64_t v8 = (33 * v8) ^ v9;
    }
    while (v9);
  }
  std::mutex::lock(ServiceMap);
  BOOL v16 = v6;
  char v10 = sub_10004D37C(&v5[1].__m_.__sig, &v16);
  if (v10)
  {
    uint64_t v12 = (void (***)(uint64_t *__return_ptr, void, uint64_t))v10[3];
    uint64_t v11 = (std::__shared_weak_count *)v10[4];
    if (v11)
    {
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v5);
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v11);
      unsigned int v13 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v12 = 0;
  }
  std::mutex::unlock(v5);
  uint64_t v11 = 0;
  unsigned int v13 = 1;
LABEL_9:
  (**v12)(&v14, v12, **(void **)(a1 + 80) + 24);
  (*(void (**)(uint64_t, uint64_t))(*(void *)v14 + 376))(v14, a2);
  if (v15) {
    sub_10004D2C8(v15);
  }
  if ((v13 & 1) == 0) {
    sub_10004D2C8(v11);
  }
}

void sub_1004E0608(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11)
{
  if (a11) {
    sub_10004D2C8(a11);
  }
  if ((v12 & 1) == 0) {
    sub_10004D2C8(v11);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1004E0638(uint64_t a1)
{
  sub_100A31BB8(a1);
  uint64_t result = *(void *)(a1 + 1024);
  if (result)
  {
    uint64_t v3 = *(uint64_t (**)(void))(*(void *)result + 144);
    return v3();
  }
  return result;
}

uint64_t sub_1004E06A0(void *a1, int a2)
{
  if (a2) {
    (*(void (**)(void *))(*a1 + 312))(a1);
  }
  uint64_t result = a1[128];
  if (result)
  {
    uint64_t v4 = *(uint64_t (**)(void))(*(void *)result + 320);
    return v4();
  }
  return result;
}

const void **sub_1004E0760@<X0>(uint64_t a1@<X0>, int a2@<W1>, uint64_t a3@<X8>)
{
  if (a2 == 1 && (uint64_t v3 = *(void *)(a1 + 1024)) != 0)
  {
    uint64_t v4 = *(uint64_t (**)(void))(*(void *)v3 + 192);
    return (const void **)v4();
  }
  else
  {
    *(unsigned char *)a3 = 0;
    *(void *)(a3 + 8) = 0;
    unint64_t v6 = 0;
    return sub_100057D78(&v6);
  }
}

const void **sub_1004E07DC@<X0>(uint64_t a1@<X0>, int a2@<W1>, uint64_t a3@<X8>)
{
  if (a2 == 1 && (uint64_t v4 = *(void *)(a1 + 1024)) != 0)
  {
    uint64_t v7 = 0;
    uint64_t v8 = 0;
    (*(void (**)(uint64_t *__return_ptr))(*(void *)v4 + 200))(&v7);
    *(unsigned char *)a3 = v7;
    sub_100058198((const void **)(a3 + 8), &v8);
    uint64_t v5 = &v8;
  }
  else
  {
    *(unsigned char *)a3 = 0;
    *(void *)(a3 + 8) = 0;
    uint64_t v7 = 0;
    uint64_t v5 = (const void **)&v7;
  }
  return sub_100057D78(v5);
}

uint64_t sub_1004E087C(uint64_t a1, int a2, uint64_t a3, const void **a4)
{
  if (a2 != 1) {
    return 1;
  }
  uint64_t v5 = *(void *)(a1 + 1024);
  sub_100058198(&v8, a4);
  uint64_t v6 = (*(uint64_t (**)(uint64_t, uint64_t, const void **))(*(void *)v5 + 216))(v5, a3, &v8);
  sub_100057D78(&v8);
  return v6;
}

void sub_1004E0904(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100057D78((const void **)va);
  _Unwind_Resume(a1);
}

const void **sub_1004E0918(const void **result, int a2, uint64_t a3, const void **a4)
{
  if (a2 == 1)
  {
    uint64_t v4 = result[128];
    if (v4)
    {
      sub_100058198(&v6, a4);
      (*(void (**)(const void *, uint64_t, const void **))(*(void *)v4 + 208))(v4, a3, &v6);
      return sub_100057D78(&v6);
    }
  }
  return result;
}

void sub_1004E0994(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100057D78((const void **)va);
  _Unwind_Resume(a1);
}

const void **sub_1004E09A8(const void **result, BOOL a2, BOOL a3)
{
  if (!*((unsigned char *)result + 354))
  {
    uint64_t result = (const void **)result[128];
    if (result) {
      return sub_10125E354(result, a2, a3);
    }
  }
  return result;
}

const void **sub_1004E09C0@<X0>(const void **result@<X0>, int a2@<W1>, const void **a3@<X8>)
{
  *a3 = 0;
  if (a2 == 1)
  {
    uint64_t result = (const void **)result[128];
    if (result)
    {
      (*((void (**)(const void **__return_ptr))*result + 19))(&v5);
      if (&v5 != a3)
      {
        uint64_t v4 = *a3;
        *a3 = v5;
        uint64_t v5 = 0;
        uint64_t v6 = v4;
        sub_100057D78(&v6);
      }
      return sub_100057D78(&v5);
    }
  }
  return result;
}

void sub_1004E0A50(_Unwind_Exception *a1)
{
  sub_100057D78(v1);
  _Unwind_Resume(a1);
}

BOOL sub_1004E0A64(uint64_t a1, int a2, int a3, const std::string *a4)
{
  if (a2 != 1) {
    return a2 == 1;
  }
  uint64_t v23 = 0;
  *(_OWORD *)OsLogContext __p = 0u;
  long long v22 = 0u;
  if (a3)
  {
    LODWORD(__p[0]) = 2;
    sub_100093B44((std::string *)&__p[1], a4);
  }
  uint64_t v6 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v7 = **(PersonalityInfo ***)(a1 + 80);
    if (v7) {
      uint64_t v8 = (const char *)PersonalityInfo::logPrefix(v7);
    }
    else {
      uint64_t v8 = "-1";
    }
    uint64_t v9 = asString();
    *(_DWORD *)long long buf = 136315650;
    *(void *)&uint8_t buf[4] = v8;
    __int16 v25 = 2080;
    char v26 = " ";
    __int16 v27 = 2080;
    uint64_t v28 = v9;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I %s%sVoWiFi configuration is: %s", buf, 0x20u);
  }
  std::mutex::lock((std::mutex *)(a1 + 448));
  *(_DWORD *)(a1 + 536) = __p[0];
  *(unsigned char *)(a1 + 540) = 1;
  sub_100179AF8((std::string *)(a1 + 544), (const std::string *)&__p[1]);
  std::mutex::unlock((std::mutex *)(a1 + 448));
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 48));
  uint64_t v11 = ServiceMap;
  if (v12 < 0)
  {
    unsigned int v13 = (unsigned __int8 *)(v12 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v14 = 5381;
    do
    {
      uint64_t v12 = v14;
      unsigned int v15 = *v13++;
      uint64_t v14 = (33 * v14) ^ v15;
    }
    while (v15);
  }
  std::mutex::lock(ServiceMap);
  *(void *)long long buf = v12;
  BOOL v16 = sub_10004D37C(&v11[1].__m_.__sig, (unint64_t *)buf);
  if (!v16)
  {
    uint64_t v18 = 0;
    goto LABEL_16;
  }
  uint64_t v18 = v16[3];
  char v17 = (std::__shared_weak_count *)v16[4];
  if (!v17)
  {
LABEL_16:
    std::mutex::unlock(v11);
    char v17 = 0;
    char v19 = 1;
    goto LABEL_17;
  }
  atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v11);
  atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v17);
  char v19 = 0;
LABEL_17:
  (*(void (**)(uint64_t))(*(void *)v18 + 32))(v18);
  if ((v19 & 1) == 0) {
    sub_10004D2C8(v17);
  }
  if ((_BYTE)v23 && SHIBYTE(v22) < 0) {
    operator delete(__p[1]);
  }
  return a2 == 1;
}

void sub_1004E0CB0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16)
{
  if (a16)
  {
    if (a15 < 0) {
      operator delete(__p);
    }
  }
  _Unwind_Resume(exception_object);
}

void sub_1004E0D14(uint64_t a1@<X0>, uint64_t a2@<X1>, const void *a3@<X2>, ctu::cf **a4@<X8>)
{
  uint64_t v8 = operator new(0x10uLL);
  char v10 = v8 + 2;
  uint64_t v11 = v8 + 2;
  void *v8 = @"IMSConfig";
  v8[1] = a2;
  uint64_t v9 = v8;
  if (!*(void *)(a1 + 1024))
  {
    *a4 = 0;
    goto LABEL_5;
  }
  sub_10126B808(*(void *)(a1 + 1024), (uint64_t *)&v9, a3, a4);
  uint64_t v8 = v9;
  if (v9)
  {
LABEL_5:
    char v10 = v8;
    operator delete(v8);
  }
}

void sub_1004E0DAC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1004E0DC8(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 1024);
  if (v1 && sub_100810848(*(void *)(a1 + 1024)))
  {
    sub_10125AFE8(v1, 0);
  }
}

CFDictionaryRef sub_1004E0E1C(uint64_t a1)
{
  CFDictionaryRef result = *(CFDictionaryRef *)(a1 + 1024);
  if (result) {
    return sub_10126E05C((uint64_t)result, kIWLANSettingsKey);
  }
  return result;
}

uint64_t sub_1004E0E38(uint64_t a1, uint64_t a2)
{
  uint64_t result = *(void *)(a1 + 1024);
  if (result) {
    return sub_10126DF18(result, a2);
  }
  return result;
}

CFDictionaryRef sub_1004E0E48(uint64_t a1)
{
  CFDictionaryRef result = *(CFDictionaryRef *)(a1 + 1024);
  if (result) {
    return sub_10126E05C((uint64_t)result, @"IMSConfig");
  }
  return result;
}

void sub_1004E0E60(uint64_t a1@<X0>, uint64_t *a2@<X1>, const void *a3@<X2>, ctu::cf **a4@<X8>)
{
  uint64_t v4 = *(void *)(a1 + 1024);
  if (v4) {
    sub_10126B808(v4, a2, a3, a4);
  }
  else {
    *a4 = 0;
  }
}

void sub_1004E0E74(uint64_t a1@<X0>, int a2@<W1>, uint64_t a3@<X3>, void *a4@<X8>)
{
  uint64_t v4 = *(void *)(a1 + 1024);
  if (v4)
  {
    uint64_t v5 = *(std::__shared_weak_count **)(a3 + 8);
    uint64_t v6 = v5;
    if (v5) {
      atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    sub_10126E0F8(v4, a2, a4);
    if (v6) {
      sub_10004D2C8(v6);
    }
  }
  else
  {
    *a4 = 0;
    a4[1] = 0;
  }
}

void sub_1004E0ED4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1004E0EEC(uint64_t a1, uint64_t a2)
{
  if (*(void *)(a1 + 1024))
  {
    return sub_100A32B88(a1, a2);
  }
  else
  {
    uint64_t v4 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v5 = **(PersonalityInfo ***)(a1 + 80);
      if (v5) {
        uint64_t v6 = (const char *)PersonalityInfo::logPrefix(v5);
      }
      else {
        uint64_t v6 = "-1";
      }
      int v7 = 136315394;
      uint64_t v8 = v6;
      __int16 v9 = 2080;
      char v10 = " ";
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I %s%sWarning: fThumper is not valid. Default canDialNumber to true", (uint8_t *)&v7, 0x16u);
    }
    return 1;
  }
}

void sub_1004E1000(uint64_t a1@<X0>, unsigned __int8 *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v5 = *(void *)(a1 + 1024);
  if (!v5)
  {
    unsigned int v13 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v14 = **(PersonalityInfo ***)(a1 + 80);
      if (v14) {
        unsigned int v15 = (const char *)PersonalityInfo::logPrefix(v14);
      }
      else {
        unsigned int v15 = "-1";
      }
      *(_DWORD *)long long buf = 136315394;
      *(void *)&uint8_t buf[4] = v15;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = " ";
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I %s%sThumper not present", buf, 0x16u);
    }
    goto LABEL_41;
  }
  long long v40 = 0u;
  long long v41 = 0u;
  long long v38 = 0u;
  long long v39 = 0u;
  long long v36 = 0u;
  long long v37 = 0u;
  long long v34 = 0u;
  long long v35 = 0u;
  long long v33 = 0u;
  memset(buf, 0, sizeof(buf));
  uint64_t v42 = 1;
  memset(__s1, 0, sizeof(__s1));
  long long v44 = 0u;
  uint64_t v45 = 0;
  if ((sub_10126DF18(v5, (uint64_t)buf) & 1) == 0)
  {
    BOOL v16 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      char v17 = **(PersonalityInfo ***)(a1 + 80);
      if (v17) {
        uint64_t v18 = (const char *)PersonalityInfo::logPrefix(v17);
      }
      else {
        uint64_t v18 = "-1";
      }
      int v26 = 136315394;
      __int16 v27 = v18;
      __int16 v28 = 2080;
      uint64_t v29 = " ";
      long long v22 = "#I %s%sIMSInfo not available";
      uint64_t v23 = v16;
      uint32_t v24 = 22;
      goto LABEL_39;
    }
LABEL_40:
    sub_100350940((uint64_t)buf);
LABEL_41:
    *(void *)a3 = 0;
    *(void *)(a3 + 8) = 0;
    *(void *)(a3 + 16) = 0;
    return;
  }
  uint64_t v7 = HIBYTE(__s1[2]);
  if (SHIBYTE(__s1[2]) >= 0) {
    uint64_t v8 = (void *)HIBYTE(__s1[2]);
  }
  else {
    uint64_t v8 = __s1[1];
  }
  __int16 v9 = (void *)a2[23];
  int v10 = (char)v9;
  if ((char)v9 < 0) {
    __int16 v9 = (void *)*((void *)a2 + 1);
  }
  if (v8 != v9)
  {
LABEL_27:
    char v19 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v20 = **(PersonalityInfo ***)(a1 + 80);
      if (v20)
      {
        float v21 = (const char *)PersonalityInfo::logPrefix(v20);
        LOBYTE(v10) = a2[23];
      }
      else
      {
        float v21 = "-1";
      }
      if ((v10 & 0x80u) == 0) {
        __int16 v25 = a2;
      }
      else {
        __int16 v25 = *(unsigned __int8 **)a2;
      }
      int v26 = 136315650;
      __int16 v27 = v21;
      __int16 v28 = 2080;
      uint64_t v29 = " ";
      __int16 v30 = 2080;
      uint64_t v31 = v25;
      long long v22 = "#I %s%sCannot resolve mcc (%s) as it is not home mcc";
      uint64_t v23 = v19;
      uint32_t v24 = 32;
LABEL_39:
      _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, v22, (uint8_t *)&v26, v24);
      goto LABEL_40;
    }
    goto LABEL_40;
  }
  if (v10 >= 0) {
    uint64_t v11 = a2;
  }
  else {
    uint64_t v11 = *(unsigned __int8 **)a2;
  }
  if ((HIBYTE(__s1[2]) & 0x80) != 0)
  {
    if (memcmp(__s1[0], v11, (size_t)__s1[1])) {
      goto LABEL_27;
    }
  }
  else if (HIBYTE(__s1[2]))
  {
    uint64_t v12 = __s1;
    while (*(unsigned __int8 *)v12 == *v11)
    {
      uint64_t v12 = (void **)((char *)v12 + 1);
      ++v11;
      if (!--v7) {
        goto LABEL_30;
      }
    }
    goto LABEL_27;
  }
LABEL_30:
  if (SHIBYTE(__s1[5]) < 0)
  {
    sub_10004FC84((unsigned char *)a3, __s1[3], (unint64_t)__s1[4]);
  }
  else
  {
    *(_OWORD *)a3 = *(_OWORD *)&__s1[3];
    *(void **)(a3 + 16) = __s1[5];
  }
  sub_100350940((uint64_t)buf);
}

void sub_1004E1308(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  sub_100350940((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1004E1324(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = **(PersonalityInfo ***)(a1 + 80);
    if (v3) {
      uint64_t v4 = (const char *)PersonalityInfo::logPrefix(v3);
    }
    else {
      uint64_t v4 = "-1";
    }
    ctu::cf::assign();
    *(_OWORD *)OsLogContext __p = 0u;
    uint64_t v6 = 0;
    int buf = 136315650;
    buf_4 = v4;
    __int16 buf_12 = 2080;
    buf_14 = " ";
    __int16 v11 = 2080;
    uint64_t v12 = __p;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I %s%s%s -- NOT SUPPORTED", (uint8_t *)&buf, 0x20u);
    if (SHIBYTE(v6) < 0) {
      operator delete(__p[0]);
    }
  }
}

void sub_1004E1450(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1004E146C(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = **(PersonalityInfo ***)(a1 + 80);
    if (v3) {
      uint64_t v4 = (const char *)PersonalityInfo::logPrefix(v3);
    }
    else {
      uint64_t v4 = "-1";
    }
    ctu::cf::assign();
    *(_OWORD *)OsLogContext __p = 0u;
    uint64_t v6 = 0;
    int buf = 136315650;
    buf_4 = v4;
    __int16 buf_12 = 2080;
    buf_14 = " ";
    __int16 v11 = 2080;
    uint64_t v12 = __p;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I %s%s%s -- NOT SUPPORTED", (uint8_t *)&buf, 0x20u);
    if (SHIBYTE(v6) < 0) {
      operator delete(__p[0]);
    }
  }
}

void sub_1004E1598(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_1004E15B4(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 1024);
  return v1 && *(unsigned char *)(v1 + 704) != 0;
}

uint64_t sub_1004E15D4(void *a1)
{
  *a1 = off_1019D8690;
  uint64_t v2 = (std::__shared_weak_count *)a1[129];
  if (v2) {
    sub_10004D2C8(v2);
  }

  return sub_100A2C4CC((uint64_t)a1);
}

void sub_1004E1630(void *a1)
{
  *a1 = off_1019D8690;
  uint64_t v2 = (std::__shared_weak_count *)a1[129];
  if (v2) {
    sub_10004D2C8(v2);
  }
  sub_100A2C4CC((uint64_t)a1);

  operator delete();
}

const char *sub_1004E16A0()
{
  return "PSControlCloud";
}

void sub_1004E16AC(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_1004E1778(void *a1)
{
  __cxa_begin_catch(a1);
  dispatch_barrier_async_f(v1[3], v1, (dispatch_function_t)sub_1004E1850);
  __cxa_rethrow();
}

void sub_1004E17A0(_Unwind_Exception *a1)
{
}

void sub_1004E17B8(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_1004E17F0(uint64_t a1)
{
}

uint64_t sub_1004E180C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_1004E1850(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void sub_1004E1880()
{
}

void *sub_1004E1894()
{
  CFDictionaryRef result = operator new(0x10uLL);
  *CFDictionaryRef result = off_1019D88E8;
  return result;
}

void sub_1004E18CC(uint64_t a1, void *a2)
{
  *a2 = off_1019D88E8;
}

uint64_t sub_1004E18F8(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_1019D8948)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_1004E1938()
{
  return &off_1019D8948;
}

void CSISMSCommandDriver::create(uint64_t *a1, char a2, uint64_t a3)
{
  uint64_t v4 = *(std::__shared_weak_count **)(a3 + 8);
  uint64_t v8 = v4;
  if (v4) {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v6 = *a1;
  uint64_t v5 = (std::__shared_weak_count *)a1[1];
  if (v5) {
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  int v10 = 0;
  uint64_t v7 = operator new(0x20uLL);
  *(void *)uint64_t v7 = off_1019D8980;
  unsigned char v7[8] = a2;
  *((void *)v7 + 2) = v6;
  *((void *)v7 + 3) = v5;
  if (v5) {
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  int v10 = v7;
  CSISMSCommandDriver::create();
  sub_1004E1D88(v9);
  if (v5) {
    sub_10004D2C8(v5);
  }
  if (v8) {
    sub_10004D2C8(v8);
  }
}

void sub_1004E1A58(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, std::__shared_weak_count *a4, ...)
{
  va_start(va, a4);
  sub_1004E1D88((uint64_t *)va);
  if (v4) {
    sub_10004D2C8(v4);
  }
  if (a4) {
    sub_10004D2C8(a4);
  }
  _Unwind_Resume(a1);
}

void *sub_1004E1A8C(void *a1)
{
  *a1 = off_1019D8980;
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

void sub_1004E1AD8(void *a1)
{
  *a1 = off_1019D8980;
  uint64_t v1 = (std::__shared_weak_count *)a1[3];
  if (v1) {
    sub_10004D2C8(v1);
  }

  operator delete();
}

unsigned char *sub_1004E1B44(uint64_t a1)
{
  CFDictionaryRef result = operator new(0x20uLL);
  *(void *)CFDictionaryRef result = off_1019D8980;
  result[8] = *(unsigned char *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 24);
  *((void *)result + 2) = *(void *)(a1 + 16);
  *((void *)result + 3) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_1004E1BA8(uint64_t result, uint64_t a2)
{
  *(void *)a2 = off_1019D8980;
  *(unsigned char *)(a2 + 8) = *(unsigned char *)(result + 8);
  uint64_t v2 = *(void *)(result + 24);
  *(void *)(a2 + 16) = *(void *)(result + 16);
  *(void *)(a2 + 24) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_1004E1BE8(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 24);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

void sub_1004E1BF8(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[3];
  if (v2) {
    sub_10004D2C8(v2);
  }

  operator delete(__p);
}

void sub_1004E1C38(uint64_t a1@<X0>, NSObject **a2@<X1>, void *a3@<X8>)
{
  uint64_t v4 = *a2;
  *a2 = 0;
  *a3 = 0;
  a3[1] = 0;
  if (*(unsigned char *)(a1 + 8) == 1)
  {
    if (v4) {
      dispatch_retain(v4);
    }
    CSISMSCommandDriver::createBasebandDriver();
    *(_OWORD *)a3 = v5;
    if (v4) {
      dispatch_release(v4);
    }
  }
  else if (!*(unsigned char *)(a1 + 8))
  {
    if (v4) {
      dispatch_retain(v4);
    }
    ImsSmsCommandDriver::create();
  }
  if (v4) {
    dispatch_release(v4);
  }
}

void sub_1004E1D08(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object)
{
  if (object) {
    dispatch_release(object);
  }
  if (v10) {
    dispatch_release(v10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1004E1D3C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1004E1D7C()
{
}

void *sub_1004E1D88(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *sub_1004E1E0C(void *a1, void *a2, unsigned int a3, uint64_t a4, uint64_t a5, NSObject **a6, char *a7, int a8)
{
  unsigned int v15 = *a6;
  dispatch_object_t object = v15;
  if (v15) {
    dispatch_retain(v15);
  }
  sub_100D81FD0((uint64_t)a1, (uint64_t *)&off_1019D93D0, a2, a3, a4, a5, &object, a7, a8);
  if (object) {
    dispatch_release(object);
  }
  *a1 = off_1019D8A38;
  a1[3] = off_1019D8F38;
  return a1;
}

void sub_1004E1F08(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object)
{
  if (object) {
    dispatch_release(object);
  }
  PersonalitySpecific::~PersonalitySpecific(v10);
  _Unwind_Resume(a1);
}

void sub_1004E1F28(uint64_t a1)
{
  sub_100D84338(a1, (uint64_t *)&off_1019D93D0);

  PersonalitySpecific::~PersonalitySpecific(v1);
}

void sub_1004E1F58(uint64_t a1)
{
  sub_100D84338(a1 - 24, (uint64_t *)&off_1019D93D0);

  PersonalitySpecific::~PersonalitySpecific(v1);
}

void sub_1004E1F8C(uint64_t a1)
{
  sub_100D84338(a1, (uint64_t *)&off_1019D93D0);
  PersonalitySpecific::~PersonalitySpecific(v1);

  operator delete();
}

void sub_1004E1FD0(uint64_t a1)
{
}

uint64_t sub_1004E1FD8(uint64_t a1, int a2)
{
  if (!a2)
  {
    ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 72));
    uint64_t v4 = ServiceMap;
    if ((v5 & 0x8000000000000000) != 0)
    {
      uint64_t v6 = (unsigned __int8 *)(v5 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v7 = 5381;
      do
      {
        unint64_t v5 = v7;
        unsigned int v8 = *v6++;
        uint64_t v7 = (33 * v7) ^ v8;
      }
      while (v8);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v14 = v5;
    __int16 v9 = sub_10004D37C(&v4[1].__m_.__sig, &v14);
    if (v9)
    {
      uint64_t v11 = v9[3];
      int v10 = (std::__shared_weak_count *)v9[4];
      if (v10)
      {
        atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v4);
        atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v10);
        char v12 = 0;
        if (!v11) {
          goto LABEL_11;
        }
        goto LABEL_15;
      }
    }
    else
    {
      uint64_t v11 = 0;
    }
    std::mutex::unlock(v4);
    int v10 = 0;
    char v12 = 1;
    if (!v11)
    {
LABEL_11:
      uint64_t v13 = 0;
      if (v12) {
        return v13;
      }
      goto LABEL_16;
    }
LABEL_15:
    uint64_t v13 = (*(unsigned int (**)(uint64_t))(*(void *)v11 + 1112))(v11) ^ 1;
    if (v12) {
      return v13;
    }
LABEL_16:
    sub_10004D2C8(v10);
    return v13;
  }

  return sub_100D96CAC(a1, a2);
}

void sub_1004E2124(_Unwind_Exception *exception_object)
{
  if ((v2 & 1) == 0) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1004E2140(uint64_t a1)
{
  return *(void *)(a1 + 192);
}

uint64_t sub_1004E2148(uint64_t a1, int a2)
{
  uint64_t v2 = a1 + 224;
  uint64_t v3 = a1 + 208;
  if (!a2) {
    uint64_t v3 = a1 + 216;
  }
  if (a2 != 1) {
    uint64_t v2 = v3;
  }
  return *(void *)v2;
}

uint64_t sub_1004E216C@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(result + 272);
  *a2 = *(void *)(result + 264);
  a2[1] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_1004E2188@<X0>(uint64_t result@<X0>, int a2@<W1>, void *a3@<X8>)
{
  uint64_t v3 = result + 16 * a2;
  uint64_t v5 = *(void *)(v3 + 312);
  uint64_t v4 = *(void *)(v3 + 320);
  *a3 = v5;
  a3[1] = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_1004E21A8@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(result + 272);
  *a2 = *(void *)(result + 264);
  a2[1] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void *sub_1004E21C4@<X0>(void *result@<X0>, void *a2@<X8>)
{
  uint64_t v2 = result[33];
  if (!v2) {
    return sub_100058DB0(a2, "");
  }
  if (*(char *)(v2 + 95) < 0) {
    return sub_10004FC84(a2, *(void **)(v2 + 72), *(void *)(v2 + 80));
  }
  long long v3 = *(_OWORD *)(v2 + 72);
  a2[2] = *(void *)(v2 + 88);
  *(_OWORD *)a2 = v3;
  return result;
}

void *sub_1004E2204@<X0>(void *result@<X0>, void *a2@<X8>)
{
  uint64_t v2 = result[33];
  if (!v2) {
    return sub_100058DB0(a2, "");
  }
  if (*(char *)(v2 + 119) < 0) {
    return sub_10004FC84(a2, *(void **)(v2 + 96), *(void *)(v2 + 104));
  }
  long long v3 = *(_OWORD *)(v2 + 96);
  a2[2] = *(void *)(v2 + 112);
  *(_OWORD *)a2 = v3;
  return result;
}

void *sub_1004E2244@<X0>(void *result@<X0>, void *a2@<X8>)
{
  uint64_t v2 = result[33];
  if (!v2) {
    return sub_100058DB0(a2, "");
  }
  if (*(char *)(v2 + 143) < 0) {
    return sub_10004FC84(a2, *(void **)(v2 + 120), *(void *)(v2 + 128));
  }
  long long v3 = *(_OWORD *)(v2 + 120);
  a2[2] = *(void *)(v2 + 136);
  *(_OWORD *)a2 = v3;
  return result;
}

uint64_t sub_1004E2284(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 264);
  if (v1) {
    return *(unsigned __int16 *)(v1 + 202);
  }
  else {
    return 0;
  }
}

void *sub_1004E229C@<X0>(void *result@<X0>, void *a2@<X8>)
{
  uint64_t v2 = result[33];
  if (!v2 || !*(unsigned char *)(v2 + 272)) {
    return sub_100058DB0(a2, "");
  }
  if (*(char *)(v2 + 271) < 0) {
    return sub_10004FC84(a2, *(void **)(v2 + 248), *(void *)(v2 + 256));
  }
  long long v3 = *(_OWORD *)(v2 + 248);
  a2[2] = *(void *)(v2 + 264);
  *(_OWORD *)a2 = v3;
  return result;
}

uint64_t sub_1004E22E4(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 1168))();
}

uint64_t sub_1004E2310()
{
  return 0;
}

uint64_t sub_1004E2324()
{
  return 0;
}

uint64_t sub_1004E232C(uint64_t a1)
{
  return *(void *)(a1 + 168);
}

uint64_t sub_1004E2334(uint64_t a1, int a2)
{
  uint64_t v2 = 184;
  if (a2 == 1) {
    uint64_t v2 = 200;
  }
  if (!a2) {
    uint64_t v2 = 192;
  }
  return *(void *)(a1 + v2);
}

uint64_t sub_1004E2358(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 - 24) + 1168))();
}

uint64_t sub_1004E2384(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 240);
  if (v1) {
    return *(unsigned __int16 *)(v1 + 202);
  }
  else {
    return 0;
  }
}

uint64_t sub_1004E239C@<X0>(uint64_t result@<X0>, int a2@<W1>, void *a3@<X8>)
{
  uint64_t v3 = result + 16 * a2;
  uint64_t v5 = *(void *)(v3 + 288);
  uint64_t v4 = *(void *)(v3 + 296);
  *a3 = v5;
  a3[1] = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void *sub_1004E23BC@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  return sub_1004E21C4((void *)(a1 - 24), a2);
}

void *sub_1004E23C4@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  return sub_1004E2204((void *)(a1 - 24), a2);
}

void *sub_1004E23CC@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  return sub_1004E2244((void *)(a1 - 24), a2);
}

void *sub_1004E23D4@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  return sub_1004E229C((void *)(a1 - 24), a2);
}

uint64_t sub_1004E23DC@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(result + 248);
  *a2 = *(void *)(result + 240);
  a2[1] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_1004E23F8@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(result + 248);
  *a2 = *(void *)(result + 240);
  a2[1] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_1004E2414()
{
  return 0;
}

const char *sub_1004E241C(int a1)
{
  if ((a1 - 1) > 2) {
    return "lazuli.prov.ctr?";
  }
  else {
    return off_1019DAFA0[a1 - 1];
  }
}

void *sub_1004E2444(uint64_t a1)
{
  sub_100453C90(a1 + 32, *(void **)(a1 + 40));

  return sub_1004E90EC((void *)a1);
}

void *sub_1004E2484(uint64_t a1)
{
  sub_1000346F8(a1 + 32, *(void **)(a1 + 40));

  return sub_1004E9170((void *)a1);
}

void *sub_1004E24C4(uint64_t a1)
{
  sub_10021D564(a1 + 32, *(char **)(a1 + 40));

  return sub_1004E91F4((void *)a1);
}

void *sub_1004E2504(uint64_t a1)
{
  sub_1001F6F58(a1 + 32, *(void **)(a1 + 40));

  return sub_1004E9278((void *)a1);
}

void *sub_1004E2544(uint64_t a1)
{
  sub_1001F701C(a1 + 32, *(void **)(a1 + 40));

  return sub_1004E92FC((void *)a1);
}

void sub_1004E2584(uint64_t a1, void *a2)
{
  if (*(void *)(a1 + 456) == a2[2])
  {
    uint64_t v3 = *(void **)(a1 + 440);
    uint64_t v4 = a1 + 448;
    if (v3 == (void *)(a1 + 448)) {
      return;
    }
    uint64_t v5 = (void *)*a2;
    while (*((_DWORD *)v3 + 8) == *((_DWORD *)v5 + 8)
         && sub_1007ABCE8((unsigned __int8 *)v3 + 40, (unsigned __int8 *)v5 + 40))
    {
      uint64_t v6 = (void *)v3[1];
      uint64_t v7 = v3;
      if (v6)
      {
        do
        {
          uint64_t v3 = v6;
          uint64_t v6 = (void *)*v6;
        }
        while (v6);
      }
      else
      {
        do
        {
          uint64_t v3 = (void *)v7[2];
          BOOL v8 = *v3 == (void)v7;
          uint64_t v7 = v3;
        }
        while (!v8);
      }
      __int16 v9 = (void *)v5[1];
      if (v9)
      {
        do
        {
          int v10 = v9;
          __int16 v9 = (void *)*v9;
        }
        while (v9);
      }
      else
      {
        do
        {
          int v10 = (void *)v5[2];
          BOOL v8 = *v10 == (void)v5;
          uint64_t v5 = v10;
        }
        while (!v8);
      }
      uint64_t v5 = v10;
      if (v3 == (void *)v4) {
        return;
      }
    }
  }
  uint64_t v11 = (void *)*a2;
  v159 = a2 + 1;
  uint64_t v12 = a1;
  if ((void *)*a2 != a2 + 1)
  {
    uint64_t v13 = (uint64_t *)(a1 + 448);
    unint64_t v14 = (uint64_t *)(a1 + 120);
    do
    {
      uint64_t v15 = *v13;
      uint64_t v16 = *((unsigned int *)v11 + 8);
      if (!*v13) {
        goto LABEL_30;
      }
      uint64_t v17 = a1 + 448;
      do
      {
        int v18 = *(_DWORD *)(v15 + 32);
        BOOL v19 = v18 < (int)v16;
        if (v18 >= (int)v16) {
          uint64_t v20 = (uint64_t *)v15;
        }
        else {
          uint64_t v20 = (uint64_t *)(v15 + 8);
        }
        if (!v19) {
          uint64_t v17 = v15;
        }
        uint64_t v15 = *v20;
      }
      while (*v20);
      if ((uint64_t *)v17 == v13 || (int)v16 < *(_DWORD *)(v17 + 32))
      {
LABEL_30:
        (*(void (**)(void, void))(**(void **)(v12 + 48) + 16))(*(void *)(v12 + 48), *((unsigned int *)v11 + 8));
        if (*((char *)v11 + 63) < 0)
        {
          sub_10004FC84(__dst, (void *)v11[5], v11[6]);
        }
        else
        {
          *(_OWORD *)std::string __dst = *(_OWORD *)(v11 + 5);
          *(void *)&__dst[16] = v11[7];
        }
        uint64_t v21 = v12;
        uint64_t v22 = *(void *)(v12 + 128);
        uint64_t v23 = *(uint64_t **)(v21 + 112);
        if (v23 != v14)
        {
          while (1)
          {
            uint64_t v24 = *((unsigned __int8 *)v23 + 55);
            if ((v24 & 0x80u) == 0) {
              uint64_t v25 = *((unsigned __int8 *)v23 + 55);
            }
            else {
              uint64_t v25 = v23[5];
            }
            uint64_t v26 = __dst[23];
            if (__dst[23] < 0) {
              uint64_t v26 = *(void *)&__dst[8];
            }
            if (v25 != v26) {
              goto LABEL_50;
            }
            if (__dst[23] >= 0) {
              __int16 v27 = __dst;
            }
            else {
              __int16 v27 = *(unsigned __int8 **)__dst;
            }
            if ((v24 & 0x80) != 0)
            {
              if (memcmp((const void *)v23[4], v27, v23[5])) {
                goto LABEL_50;
              }
            }
            else if (*((unsigned char *)v23 + 55))
            {
              __int16 v28 = (unsigned __int8 *)(v23 + 4);
              while (*v28 == *v27)
              {
                ++v28;
                ++v27;
                if (!--v24) {
                  goto LABEL_56;
                }
              }
LABEL_50:
              uint64_t v29 = (uint64_t *)v23[1];
              if (v29)
              {
                do
                {
                  __int16 v30 = v29;
                  uint64_t v29 = (uint64_t *)*v29;
                }
                while (v29);
              }
              else
              {
                do
                {
                  __int16 v30 = (uint64_t *)v23[2];
                  BOOL v8 = *v30 == (void)v23;
                  uint64_t v23 = v30;
                }
                while (!v8);
              }
              goto LABEL_57;
            }
LABEL_56:
            __int16 v30 = sub_10006C514((uint64_t **)(a1 + 112), v23);
            sub_1001FEC1C((uint64_t)(v23 + 4));
            operator delete(v23);
LABEL_57:
            uint64_t v23 = v30;
            if (v30 == v14)
            {
              uint64_t v31 = *(void *)(a1 + 128);
              goto LABEL_60;
            }
          }
        }
        uint64_t v31 = v22;
LABEL_60:
        if ((__dst[23] & 0x80000000) != 0) {
          operator delete(*(void **)__dst);
        }
        BOOL v8 = v22 == v31;
        uint64_t v12 = a1;
        if (!v8)
        {
          long long v32 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), v16);
          if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)int buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, "#I Model removed", buf, 2u);
          }
        }
      }
      long long v33 = (void *)v11[1];
      if (v33)
      {
        do
        {
          long long v34 = v33;
          long long v33 = (void *)*v33;
        }
        while (v33);
      }
      else
      {
        do
        {
          long long v34 = (void *)v11[2];
          BOOL v8 = *v34 == (void)v11;
          uint64_t v11 = v34;
        }
        while (!v8);
      }
      uint64_t v11 = v34;
    }
    while (v34 != v159);
  }
  long long v35 = *(void **)(v12 + 440);
  long long v36 = (void *)(v12 + 448);
  if (v35 != (void *)(v12 + 448))
  {
    do
    {
      (*(void (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), *((unsigned int *)v35 + 8));
      long long v37 = (void *)v35[1];
      if (v37)
      {
        do
        {
          long long v38 = v37;
          long long v37 = (void *)*v37;
        }
        while (v37);
      }
      else
      {
        do
        {
          long long v38 = (void *)v35[2];
          BOOL v8 = *v38 == (void)v35;
          long long v35 = v38;
        }
        while (!v8);
      }
      long long v35 = v38;
    }
    while (v38 != v36);
    long long v39 = *(void **)(a1 + 440);
    if (v39 != v36)
    {
      long long v40 = (void *)(a1 + 120);
      v154 = (uint64_t **)(a1 + 160);
      v158 = (void *)(v12 + 448);
      do
      {
        long long v41 = (int *)(v39 + 4);
        uint64_t v42 = (os_log_t *)(*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), *((unsigned int *)v39 + 8));
        long long v43 = v42;
        if (*((char *)v39 + 63) < 0)
        {
          if (v39[6]) {
            goto LABEL_94;
          }
        }
        else if (*((unsigned char *)v39 + 63))
        {
          goto LABEL_94;
        }
        long long v44 = *(void **)(a1 + 112);
        if (v44 != v40)
        {
          int v45 = *v41;
          do
          {
            uint64_t v46 = v44[7];
            if (v46 && *(_DWORD *)(v46 + 96) == v45)
            {
              sub_100256E84(v154, v45, (_DWORD *)v39 + 8);
              uint64_t v67 = *v41;
              *(void *)std::string __dst = 0;
              *(void *)&__dst[8] = 0;
              sub_1004E51B4(a1, v67, (uint64_t)__dst);
            }
            v47 = (void *)v44[1];
            if (v47)
            {
              do
              {
                uint64_t v48 = v47;
                v47 = (void *)*v47;
              }
              while (v47);
            }
            else
            {
              do
              {
                uint64_t v48 = (void *)v44[2];
                BOOL v8 = *v48 == (void)v44;
                long long v44 = v48;
              }
              while (!v8);
            }
            long long v44 = v48;
          }
          while (v48 != v40);
        }
LABEL_94:
        uint64_t v49 = *v159;
        if (*v159)
        {
          uint64_t v50 = *v41;
          long long v51 = v159;
          do
          {
            int v52 = *(_DWORD *)(v49 + 32);
            BOOL v53 = v52 < (int)v50;
            if (v52 >= (int)v50) {
              v54 = (uint64_t *)v49;
            }
            else {
              v54 = (uint64_t *)(v49 + 8);
            }
            if (!v53) {
              long long v51 = (void *)v49;
            }
            uint64_t v49 = *v54;
          }
          while (*v54);
          if (v51 != v159 && (int)v50 >= *((_DWORD *)v51 + 8))
          {
            v157 = (unsigned __int8 **)(v39 + 5);
            uint64_t v57 = (const void **)(v51 + 11);
            uint64_t v58 = (unsigned __int8 **)(v39 + 11);
            char v59 = *((unsigned char *)v51 + 111);
            uint64_t v60 = v51[12];
            if (v59 >= 0) {
              uint64_t v61 = *((unsigned __int8 *)v51 + 111);
            }
            else {
              uint64_t v61 = v51[12];
            }
            uint64_t v62 = *((unsigned __int8 *)v39 + 111);
            int v63 = (char)v62;
            if ((v62 & 0x80u) != 0) {
              uint64_t v62 = v39[12];
            }
            if (v61 != v62) {
              goto LABEL_123;
            }
            if (v63 >= 0) {
              v64 = (unsigned __int8 **)(v39 + 11);
            }
            else {
              v64 = (unsigned __int8 **)*v58;
            }
            if ((*((unsigned char *)v51 + 111) & 0x80) != 0)
            {
              int v68 = memcmp(*v57, v64, v51[12]);
              uint64_t v57 = (const void **)(v51 + 11);
              uint64_t v58 = (unsigned __int8 **)(v39 + 11);
              uint64_t v61 = v60;
              if (v68) {
                goto LABEL_123;
              }
            }
            else if (*((unsigned char *)v51 + 111))
            {
              v65 = (unsigned __int8 *)(v51 + 11);
              uint64_t v66 = *((unsigned __int8 *)v51 + 111);
              while (*v65 == *(unsigned __int8 *)v64)
              {
                ++v65;
                v64 = (unsigned __int8 **)((char *)v64 + 1);
                if (!--v66) {
                  goto LABEL_133;
                }
              }
LABEL_123:
              if (v61)
              {
                v69 = *(void **)(a1 + 112);
                if (v69 != v40)
                {
                  do
                  {
                    uint64_t v70 = v69[7];
                    if (v70 && *(_DWORD *)(v70 + 96) == v50)
                    {
                      v83 = v57;
                      loga = *v43;
                      if (os_log_type_enabled(*v43, OS_LOG_TYPE_DEFAULT))
                      {
                        if (v59 < 0) {
                          v83 = (const void **)*v83;
                        }
                        if (v63 < 0) {
                          uint64_t v58 = (unsigned __int8 **)*v58;
                        }
                        *(_DWORD *)std::string __dst = 136446466;
                        *(void *)&__dst[4] = v83;
                        *(_WORD *)&__dst[12] = 2082;
                        *(void *)&__dst[14] = v58;
                        _os_log_impl((void *)&_mh_execute_header, loga, OS_LOG_TYPE_DEFAULT, "#I Custom provisioning URL: [%{public}s] --> [%{public}s]", __dst, 0x16u);
                        uint64_t v50 = *v41;
                      }
                      *(void *)std::string __dst = 0;
                      *(void *)&__dst[8] = 0;
                      sub_1004E51B4(a1, v50, (uint64_t)__dst);
                    }
                    v71 = (void *)v69[1];
                    if (v71)
                    {
                      do
                      {
                        v72 = v71;
                        v71 = (void *)*v71;
                      }
                      while (v71);
                    }
                    else
                    {
                      do
                      {
                        v72 = (void *)v69[2];
                        BOOL v8 = *v72 == (void)v69;
                        v69 = v72;
                      }
                      while (!v8);
                    }
                    v69 = v72;
                  }
                  while (v72 != v40);
                }
              }
            }
LABEL_133:
            v171 = 0;
            v172 = 0;
            sub_1004E3FF4(&v171, a1, v50, (uint64_t)v157);
            log = v171;
            if (!v171) {
              goto LABEL_321;
            }
            if (*((unsigned char *)v51 + 225) || *((unsigned char *)v51 + 226)) {
              goto LABEL_136;
            }
            uint64_t v84 = 208;
            if (!*((unsigned char *)v51 + 209)) {
              uint64_t v84 = 213;
            }
            if (!*((unsigned char *)v51 + v84)) {
LABEL_136:
            }
              int v73 = 0;
            else {
              int v73 = *((unsigned char *)v51 + 211) != 0;
            }
            if (*((unsigned char *)v39 + 225) || *((unsigned char *)v39 + 226)) {
              goto LABEL_139;
            }
            uint64_t v85 = 208;
            if (!*((unsigned char *)v39 + 209)) {
              uint64_t v85 = 213;
            }
            if (!*((unsigned char *)v39 + v85))
            {
LABEL_139:
              if ((v73 & 1) == 0) {
                goto LABEL_175;
              }
              int v74 = 0;
            }
            else
            {
              int v74 = *((unsigned char *)v39 + 211) != 0;
              if (v73 == v74) {
                goto LABEL_175;
              }
            }
            v75 = *v43;
            if (os_log_type_enabled(*v43, OS_LOG_TYPE_DEFAULT))
            {
              if (v73) {
                v76 = "Enabled";
              }
              else {
                v76 = "Disabled";
              }
              *(_DWORD *)std::string __dst = 136315394;
              *(void *)&__dst[4] = v76;
              if (v74) {
                v77 = "Enabled";
              }
              else {
                v77 = "Disabled";
              }
              *(_WORD *)&__dst[12] = 2080;
              *(void *)&__dst[14] = v77;
              _os_log_impl((void *)&_mh_execute_header, v75, OS_LOG_TYPE_DEFAULT, "#I Feature switch state: %s --> %s", __dst, 0x16u);
            }
            uint64_t v78 = *v41;
            if ((v74 & 1) == 0)
            {
              int v173 = *v41;
              *(void *)int buf = 0;
              uint64_t v176 = 0;
              sub_1004E51B4(a1, v78, (uint64_t)buf);
            }
            if (sub_100256E84(v154, *v41, (_DWORD *)v39 + 8)[5])
            {
              v79 = *v43;
              if (os_log_type_enabled(*v43, OS_LOG_TYPE_DEFAULT))
              {
                *(_WORD *)std::string __dst = 0;
                _os_log_impl((void *)&_mh_execute_header, v79, OS_LOG_TYPE_DEFAULT, "#I Stopping ongoing deprovisioning operations", __dst, 2u);
              }
              LazuliProvisioningModel::stop(log);
              v80 = sub_100256E84(v154, *v41, (_DWORD *)v39 + 8);
              v81 = (std::__shared_weak_count *)v80[6];
              v80[5] = 0;
              v80[6] = 0;
              if (v81) {
                sub_10004D2C8(v81);
              }
            }
            v82 = v172;
            v170[0] = log;
            v170[1] = (LazuliProvisioningModel *)v172;
            if (v172) {
              atomic_fetch_add_explicit(&v172->__shared_owners_, 1uLL, memory_order_relaxed);
            }
            sub_1004E4BE8(a1, v170, (uint64_t)v157);
            if (v82) {
              sub_10004D2C8(v82);
            }
LABEL_175:
            int v86 = *((unsigned __int8 *)v51 + 211);
            int v87 = *((unsigned __int8 *)v39 + 211);
            if (v86 != v87)
            {
              v88 = *v43;
              if (os_log_type_enabled(*v43, OS_LOG_TYPE_DEFAULT))
              {
                if (v86) {
                  v89 = "true";
                }
                else {
                  v89 = "false";
                }
                *(_DWORD *)std::string __dst = 136315394;
                *(void *)&__dst[4] = v89;
                if (v87) {
                  v90 = "true";
                }
                else {
                  v90 = "false";
                }
                *(_WORD *)&__dst[12] = 2080;
                *(void *)&__dst[14] = v90;
                _os_log_impl((void *)&_mh_execute_header, v88, OS_LOG_TYPE_DEFAULT, "#I Bundle support: %s --> %s", __dst, 0x16u);
                int v87 = *((unsigned __int8 *)v39 + 211);
              }
              if (!v87)
              {
                uint64_t v91 = *v41;
                *(void *)std::string __dst = 0;
                *(void *)&__dst[8] = 0;
                sub_1004E51B4(a1, v91, (uint64_t)__dst);
              }
              v92 = v172;
              v169[0] = log;
              v169[1] = (LazuliProvisioningModel *)v172;
              if (v172) {
                atomic_fetch_add_explicit(&v172->__shared_owners_, 1uLL, memory_order_relaxed);
              }
              sub_1004E4BE8(a1, v169, (uint64_t)v157);
              if (v92) {
                sub_10004D2C8(v92);
              }
            }
            uint64_t v93 = *((int *)v51 + 54);
            uint64_t v94 = *((int *)v39 + 54);
            if (v93 != v94)
            {
              v95 = *v43;
              if (os_log_type_enabled(*v43, OS_LOG_TYPE_DEFAULT))
              {
                v96 = "kCellular";
                if (v93 <= 4) {
                  v96 = off_1019DAFB8[v93];
                }
                v97 = "kCellular";
                if (v94 <= 4) {
                  v97 = off_1019DAFB8[v94];
                }
                *(_DWORD *)std::string __dst = 136315394;
                *(void *)&__dst[4] = v96;
                *(_WORD *)&__dst[12] = 2080;
                *(void *)&__dst[14] = v97;
                _os_log_impl((void *)&_mh_execute_header, v95, OS_LOG_TYPE_DEFAULT, "#I Provisioning interface: %s --> %s", __dst, 0x16u);
              }
              if (LazuliProvisioningModel::interfaceChanged(log))
              {
                v98 = *v43;
                if (os_log_type_enabled(*v43, OS_LOG_TYPE_DEFAULT))
                {
                  *(_WORD *)std::string __dst = 0;
                  _os_log_impl((void *)&_mh_execute_header, v98, OS_LOG_TYPE_DEFAULT, "#I Retry timer already running", __dst, 2u);
                }
                goto LABEL_321;
              }
              v99 = v172;
              v168[0] = log;
              v168[1] = (LazuliProvisioningModel *)v172;
              if (v172) {
                atomic_fetch_add_explicit(&v172->__shared_owners_, 1uLL, memory_order_relaxed);
              }
              sub_1004E4BE8(a1, v168, (uint64_t)v157);
              if (v99) {
                sub_10004D2C8(v99);
              }
            }
            uint64_t v100 = *((int *)v51 + 55);
            uint64_t v101 = *((int *)v39 + 55);
            if (v100 != v101)
            {
              v102 = *v43;
              if (os_log_type_enabled(*v43, OS_LOG_TYPE_DEFAULT))
              {
                v103 = "kCellular";
                if (v100 <= 4) {
                  v103 = off_1019DAFB8[v100];
                }
                v104 = "kCellular";
                if (v101 <= 4) {
                  v104 = off_1019DAFB8[v101];
                }
                *(_DWORD *)std::string __dst = 136315394;
                *(void *)&__dst[4] = v103;
                *(_WORD *)&__dst[12] = 2080;
                *(void *)&__dst[14] = v104;
                _os_log_impl((void *)&_mh_execute_header, v102, OS_LOG_TYPE_DEFAULT, "#I Ims registration interface: %s --> %s", __dst, 0x16u);
              }
              v105 = v172;
              v167[0] = log;
              v167[1] = (LazuliProvisioningModel *)v172;
              if (v172) {
                atomic_fetch_add_explicit(&v172->__shared_owners_, 1uLL, memory_order_relaxed);
              }
              sub_1004E4BE8(a1, v167, (uint64_t)v157);
              if (v105) {
                sub_10004D2C8(v105);
              }
            }
            v106 = v51 + 14;
            v107 = (unsigned __int8 **)(v39 + 14);
            char v108 = *((unsigned char *)v51 + 135);
            if (v108 >= 0) {
              uint64_t v109 = *((unsigned __int8 *)v51 + 135);
            }
            else {
              uint64_t v109 = v51[15];
            }
            uint64_t v110 = *((unsigned __int8 *)v39 + 135);
            int v111 = (char)v110;
            if ((v110 & 0x80u) != 0) {
              uint64_t v110 = v39[15];
            }
            if (v109 == v110)
            {
              if (v111 >= 0) {
                v112 = (unsigned __int8 **)(v39 + 14);
              }
              else {
                v112 = (unsigned __int8 **)*v107;
              }
              if ((*((unsigned char *)v51 + 135) & 0x80) == 0)
              {
                if (*((unsigned char *)v51 + 135))
                {
                  v113 = (unsigned __int8 *)(v51 + 14);
                  uint64_t v114 = *((unsigned __int8 *)v51 + 135);
                  while (*v113 == *(unsigned __int8 *)v112)
                  {
                    ++v113;
                    v112 = (unsigned __int8 **)((char *)v112 + 1);
                    if (!--v114) {
                      goto LABEL_242;
                    }
                  }
                  goto LABEL_230;
                }
LABEL_242:
                v117 = v51 + 5;
                char v118 = *((unsigned char *)v51 + 63);
                if (v118 >= 0) {
                  uint64_t v119 = *((unsigned __int8 *)v51 + 63);
                }
                else {
                  uint64_t v119 = v51[6];
                }
                int v120 = *((char *)v39 + 63);
                uint64_t v121 = *((unsigned __int8 *)v39 + 63);
                uint64_t v122 = v39[6];
                if (v120 >= 0) {
                  uint64_t v122 = *((unsigned __int8 *)v39 + 63);
                }
                if (v119 == v122)
                {
                  if (v120 >= 0) {
                    v123 = (unsigned __int8 *)(v39 + 5);
                  }
                  else {
                    v123 = *v157;
                  }
                  if ((*((unsigned char *)v51 + 63) & 0x80) == 0)
                  {
                    if (*((unsigned char *)v51 + 63))
                    {
                      v124 = (unsigned __int8 *)(v51 + 5);
                      uint64_t v125 = *((unsigned __int8 *)v51 + 63);
                      while (*v124 == *v123)
                      {
                        ++v124;
                        ++v123;
                        if (!--v125) {
                          goto LABEL_273;
                        }
                      }
                      goto LABEL_257;
                    }
LABEL_273:
                    int v130 = *((unsigned __int8 *)v51 + 224);
                    int v131 = *((unsigned __int8 *)v39 + 224);
                    if (v130 != v131)
                    {
                      v132 = *v43;
                      if (os_log_type_enabled(*v43, OS_LOG_TYPE_DEFAULT))
                      {
                        if (v130) {
                          v133 = "true";
                        }
                        else {
                          v133 = "false";
                        }
                        *(_DWORD *)std::string __dst = 136315394;
                        *(void *)&__dst[4] = v133;
                        if (v131) {
                          v134 = "true";
                        }
                        else {
                          v134 = "false";
                        }
                        *(_WORD *)&__dst[12] = 2080;
                        *(void *)&__dst[14] = v134;
                        _os_log_impl((void *)&_mh_execute_header, v132, OS_LOG_TYPE_DEFAULT, "#I Did first unlock: %s --> %s", __dst, 0x16u);
                        int v131 = *((unsigned __int8 *)v39 + 224);
                      }
                      if (!v131) {
                        goto LABEL_321;
                      }
                      v135 = v172;
                      v164[0] = log;
                      v164[1] = (LazuliProvisioningModel *)v172;
                      if (v172) {
                        atomic_fetch_add_explicit(&v172->__shared_owners_, 1uLL, memory_order_relaxed);
                      }
                      sub_1004E4BE8(a1, v164, (uint64_t)v157);
                      if (v135) {
                        sub_10004D2C8(v135);
                      }
                    }
                    int v136 = *((unsigned __int8 *)v51 + 225);
                    int v137 = *((unsigned __int8 *)v39 + 225);
                    if (v136 != v137)
                    {
                      v138 = *v43;
                      if (os_log_type_enabled(*v43, OS_LOG_TYPE_DEFAULT))
                      {
                        if (v136) {
                          v139 = "true";
                        }
                        else {
                          v139 = "false";
                        }
                        *(_DWORD *)std::string __dst = 136315394;
                        *(void *)&__dst[4] = v139;
                        if (v137) {
                          v140 = "true";
                        }
                        else {
                          v140 = "false";
                        }
                        *(_WORD *)&__dst[12] = 2080;
                        *(void *)&__dst[14] = v140;
                        _os_log_impl((void *)&_mh_execute_header, v138, OS_LOG_TYPE_DEFAULT, "#I Feature disabled by profile: %s --> %s", __dst, 0x16u);
                      }
                      v141 = v172;
                      v163[0] = log;
                      v163[1] = (LazuliProvisioningModel *)v172;
                      if (v172) {
                        atomic_fetch_add_explicit(&v172->__shared_owners_, 1uLL, memory_order_relaxed);
                      }
                      sub_1004E4BE8(a1, v163, (uint64_t)v157);
                      if (v141) {
                        sub_10004D2C8(v141);
                      }
                    }
                    int v142 = *((unsigned __int8 *)v51 + 226);
                    int v143 = *((unsigned __int8 *)v39 + 226);
                    if (v142 != v143)
                    {
                      v144 = *v43;
                      if (os_log_type_enabled(*v43, OS_LOG_TYPE_DEFAULT))
                      {
                        if (v142) {
                          v145 = "true";
                        }
                        else {
                          v145 = "false";
                        }
                        *(_DWORD *)std::string __dst = 136315394;
                        *(void *)&__dst[4] = v145;
                        if (v143) {
                          v146 = "true";
                        }
                        else {
                          v146 = "false";
                        }
                        *(_WORD *)&__dst[12] = 2080;
                        *(void *)&__dst[14] = v146;
                        _os_log_impl((void *)&_mh_execute_header, v144, OS_LOG_TYPE_DEFAULT, "#I Feature disabled store demo: %s --> %s", __dst, 0x16u);
                      }
                      v147 = v172;
                      v162[0] = log;
                      v162[1] = (LazuliProvisioningModel *)v172;
                      if (v172) {
                        atomic_fetch_add_explicit(&v172->__shared_owners_, 1uLL, memory_order_relaxed);
                      }
                      sub_1004E4BE8(a1, v162, (uint64_t)v157);
                      if (v147) {
                        sub_10004D2C8(v147);
                      }
                    }
                    int v148 = *((unsigned __int8 *)v51 + 210);
                    int v149 = *((unsigned __int8 *)v39 + 210);
                    if (v148 != v149)
                    {
                      v150 = *v43;
                      if (os_log_type_enabled(*v43, OS_LOG_TYPE_DEFAULT))
                      {
                        *(_DWORD *)std::string __dst = 67109376;
                        *(_DWORD *)&__dst[4] = v148;
                        *(_WORD *)&__dst[8] = 1024;
                        *(_DWORD *)&__dst[10] = v149;
                        _os_log_impl((void *)&_mh_execute_header, v150, OS_LOG_TYPE_DEFAULT, "#I SMS online: %{BOOL}d --> %{BOOL}d", __dst, 0xEu);
                        int v149 = *((unsigned __int8 *)v39 + 210);
                      }
                      if (v149)
                      {
                        v151 = v172;
                        v161[0] = log;
                        v161[1] = (LazuliProvisioningModel *)v172;
                        if (v172) {
                          atomic_fetch_add_explicit(&v172->__shared_owners_, 1uLL, memory_order_relaxed);
                        }
                        sub_1004E4BE8(a1, v161, (uint64_t)v157);
                        if (v151) {
                          sub_10004D2C8(v151);
                        }
                      }
                    }
LABEL_321:
                    if (v172) {
                      sub_10004D2C8(v172);
                    }
                    v56 = v158;
                    goto LABEL_324;
                  }
                  v117 = (void *)*v117;
                  if (!memcmp(v117, v123, v51[6])) {
                    goto LABEL_273;
                  }
                  v126 = *v43;
                  if (os_log_type_enabled(*v43, OS_LOG_TYPE_DEFAULT))
                  {
LABEL_262:
                    v127 = (unsigned __int8 *)(v39 + 5);
                    if (v120 < 0) {
                      v127 = *v157;
                    }
                    *(_DWORD *)std::string __dst = 136315394;
                    *(void *)&__dst[4] = v117;
                    *(_WORD *)&__dst[12] = 2080;
                    *(void *)&__dst[14] = v127;
                    _os_log_impl((void *)&_mh_execute_header, v126, OS_LOG_TYPE_DEFAULT, "#I IMSI: %s --> %s", __dst, 0x16u);
                    uint64_t v121 = *((unsigned __int8 *)v39 + 63);
                  }
                }
                else
                {
LABEL_257:
                  v126 = *v43;
                  if (os_log_type_enabled(*v43, OS_LOG_TYPE_DEFAULT))
                  {
                    if (v118 < 0) {
                      v117 = (void *)*v117;
                    }
                    goto LABEL_262;
                  }
                }
                if ((v121 & 0x80) != 0) {
                  uint64_t v121 = v39[6];
                }
                if (!v121)
                {
                  uint64_t v128 = *v41;
                  *(void *)std::string __dst = 0;
                  *(void *)&__dst[8] = 0;
                  sub_1004E51B4(a1, v128, (uint64_t)__dst);
                }
                v129 = v172;
                v165[0] = log;
                v165[1] = (LazuliProvisioningModel *)v172;
                if (v172) {
                  atomic_fetch_add_explicit(&v172->__shared_owners_, 1uLL, memory_order_relaxed);
                }
                sub_1004E4BE8(a1, v165, (uint64_t)v157);
                if (v129) {
                  sub_10004D2C8(v129);
                }
                goto LABEL_273;
              }
              v106 = (void *)*v106;
              if (!memcmp(v106, v112, v51[15])) {
                goto LABEL_242;
              }
              v115 = *v43;
              if (os_log_type_enabled(*v43, OS_LOG_TYPE_DEFAULT))
              {
LABEL_235:
                if (v111 < 0) {
                  v107 = (unsigned __int8 **)*v107;
                }
                *(_DWORD *)std::string __dst = 136315394;
                *(void *)&__dst[4] = v106;
                *(_WORD *)&__dst[12] = 2080;
                *(void *)&__dst[14] = v107;
                _os_log_impl((void *)&_mh_execute_header, v115, OS_LOG_TYPE_DEFAULT, "#I Msisdn: %s --> %s", __dst, 0x16u);
              }
            }
            else
            {
LABEL_230:
              v115 = *v43;
              if (os_log_type_enabled(*v43, OS_LOG_TYPE_DEFAULT))
              {
                if (v108 < 0) {
                  v106 = (void *)*v106;
                }
                goto LABEL_235;
              }
            }
            v116 = v172;
            v166[0] = log;
            v166[1] = (LazuliProvisioningModel *)v172;
            if (v172) {
              atomic_fetch_add_explicit(&v172->__shared_owners_, 1uLL, memory_order_relaxed);
            }
            sub_1004E4BE8(a1, v166, (uint64_t)v157);
            if (v116) {
              sub_10004D2C8(v116);
            }
            goto LABEL_242;
          }
        }
        uint64_t v55 = *v42;
        v56 = v158;
        if (os_log_type_enabled(*v42, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)std::string __dst = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v55, OS_LOG_TYPE_ERROR, "Failed to find provisioning model", __dst, 2u);
        }
LABEL_324:
        v152 = (void *)v39[1];
        if (v152)
        {
          do
          {
            v153 = v152;
            v152 = (void *)*v152;
          }
          while (v152);
        }
        else
        {
          do
          {
            v153 = (void *)v39[2];
            BOOL v8 = *v153 == (void)v39;
            long long v39 = v153;
          }
          while (!v8);
        }
        long long v39 = v153;
      }
      while (v153 != v56);
    }
  }
}

void sub_1004E3E0C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,std::__shared_weak_count *a51)
{
  std::__shared_weak_count::__release_weak(v51);
  std::__shared_weak_count::__release_weak(v51);
  if (a51) {
    sub_10004D2C8(a51);
  }
  _Unwind_Resume(a1);
}

void sub_1004E3F04(uint64_t a1, uint64_t a2)
{
  if (a2 == 3)
  {
    subscriber::makeSimSlotRange();
    uint64_t v3 = v5;
    if (v5 != v6)
    {
      while ((v7(*v3) & 1) == 0)
      {
        if (++v3 == v6)
        {
          uint64_t v3 = v6;
          break;
        }
      }
LABEL_6:
      while (v3 != v6)
      {
        uint64_t v4 = v3 + 1;
        sub_1004E6B6C(a1, *v3);
        uint64_t v3 = v6;
        if (v4 != v6)
        {
          uint64_t v3 = v4;
          while ((v7(*v3) & 1) == 0)
          {
            if (++v3 == v6)
            {
              uint64_t v3 = v6;
              goto LABEL_6;
            }
          }
        }
      }
    }
  }
  else
  {
    sub_1004E6B6C(a1, a2);
  }
}

void sub_1004E3FF4(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  BOOL v8 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(a2 + 48) + 16))(*(void *)(a2 + 48), a3);
  __int16 v9 = (void **)(a2 + 112);
  int v10 = sub_100046F68(a2 + 112, (void **)a4);
  uint64_t v11 = (uint64_t **)v10;
  if ((void **)(a2 + 120) != v10)
  {
    uint64_t v12 = (atomic_ullong *)v10[8];
    *a1 = v10[7];
    a1[1] = v12;
    if (v12) {
      atomic_fetch_add_explicit(v12 + 1, 1uLL, memory_order_relaxed);
    }
    return;
  }
  if ((sub_1004E6618(*(void *)(a2 + 48), a3, a4) & 1) == 0)
  {
    *a1 = 0;
    a1[1] = 0;
    return;
  }
  __p[0] = 0;
  __p[1] = 0;
  v71[0] = 0;
  sub_100562274((Registry **)(a2 + 80), (uint64_t)__p);
  if ((*(uint64_t (**)(void, void **))(**(void **)(a2 + 96) + 88))(*(void *)(a2 + 96), __p)) {
    goto LABEL_6;
  }
  if (SHIBYTE(v71[0]) >= 0) {
    uint64_t v13 = __p;
  }
  else {
    uint64_t v13 = (void **)__p[0];
  }
  int v14 = (*(uint64_t (**)(void, void **, uint64_t, uint64_t))(**(void **)(a2 + 96) + 72))(*(void *)(a2 + 96), v13, 511, 1);
  uint64_t v15 = *(NSObject **)(a2 + 40);
  if (!v14)
  {
    if (os_log_type_enabled(*(os_log_t *)(a2 + 40), OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v21 = __p;
      if (SHIBYTE(v71[0]) < 0) {
        uint64_t v21 = (void **)__p[0];
      }
      *(_DWORD *)int buf = 136446210;
      *(void *)&uint8_t buf[4] = v21;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I Created lazuli directory: %{public}s", buf, 0xCu);
    }
LABEL_6:
    memset(buf, 0, sizeof(buf));
    object[0] = 0;
    if (SHIBYTE(v71[0]) < 0)
    {
      sub_10004FC84(buf, __p[0], (unint64_t)__p[1]);
    }
    else
    {
      *(_OWORD *)int buf = *(_OWORD *)__p;
      object[0] = (dispatch_object_t)v71[0];
    }
    ctu::path_join_impl();
    if (((*(uint64_t (**)(void, uint8_t *))(**(void **)(a2 + 96) + 88))(*(void *)(a2 + 96), buf) & 1) == 0)
    {
      if (SHIBYTE(object[0]) >= 0) {
        uint64_t v17 = buf;
      }
      else {
        uint64_t v17 = *(uint8_t **)buf;
      }
      int v18 = (*(uint64_t (**)(void, uint8_t *, uint64_t, uint64_t))(**(void **)(a2 + 96) + 72))(*(void *)(a2 + 96), v17, 511, 1);
      BOOL v19 = *(NSObject **)(a2 + 40);
      if (v18)
      {
        if (os_log_type_enabled(*(os_log_t *)(a2 + 40), OS_LOG_TYPE_ERROR))
        {
          uint64_t v20 = buf;
          if (SHIBYTE(object[0]) < 0) {
            uint64_t v20 = *(uint8_t **)buf;
          }
          LODWORD(v83) = 136446210;
          *(void *)((char *)&v83 + 4) = v20;
          _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Failed to create provisioning directory: %{public}s", (uint8_t *)&v83, 0xCu);
        }
      }
      else if (os_log_type_enabled(*(os_log_t *)(a2 + 40), OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v22 = buf;
        if (SHIBYTE(object[0]) < 0) {
          uint64_t v22 = *(uint8_t **)buf;
        }
        LODWORD(v83) = 136446210;
        *(void *)((char *)&v83 + 4) = v22;
        _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#I Created lazuli/provisioning directory: %{public}s", (uint8_t *)&v83, 0xCu);
      }
    }
    if (SHIBYTE(object[0]) < 0) {
      operator delete(*(void **)buf);
    }
    goto LABEL_37;
  }
  if (os_log_type_enabled(*(os_log_t *)(a2 + 40), OS_LOG_TYPE_ERROR))
  {
    uint64_t v16 = __p;
    if (SHIBYTE(v71[0]) < 0) {
      uint64_t v16 = (void **)__p[0];
    }
    *(_DWORD *)int buf = 136446210;
    *(void *)&uint8_t buf[4] = v16;
    _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "Failed to create lazuli directory: %{public}s", buf, 0xCu);
  }
LABEL_37:
  if (SHIBYTE(v71[0]) < 0) {
    operator delete(__p[0]);
  }
  sub_100562274((Registry **)(a2 + 80), (uint64_t)__p);
  *(_OWORD *)uint64_t v58 = *(_OWORD *)__p;
  char v59 = v71[0];
  __p[1] = 0;
  v71[0] = 0;
  __p[0] = 0;
  ctu::path_join_impl();
  if (SHIBYTE(v71[0]) < 0) {
    operator delete(__p[0]);
  }
  v56[0] = 0;
  v56[1] = 0;
  uint64_t v57 = 0;
  if (SHIBYTE(v59) < 0)
  {
    sub_10004FC84(v56, v58[0], (unint64_t)v58[1]);
  }
  else
  {
    *(_OWORD *)v56 = *(_OWORD *)v58;
    uint64_t v57 = v59;
  }
  ctu::path_join_impl();
  if (((*(uint64_t (**)(void, void **))(**(void **)(a2 + 96) + 88))(*(void *)(a2 + 96), v56) & 1) == 0)
  {
    if (SHIBYTE(v57) >= 0) {
      uint64_t v31 = v56;
    }
    else {
      uint64_t v31 = (void **)v56[0];
    }
    int v32 = (*(uint64_t (**)(void, void **, uint64_t, uint64_t))(**(void **)(a2 + 96) + 72))(*(void *)(a2 + 96), v31, 511, 1);
    long long v33 = *v8;
    long long v34 = *v8;
    if (v32)
    {
      if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
      {
        LODWORD(__p[0]) = 67109120;
        HIDWORD(__p[0]) = v32;
        _os_log_error_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_ERROR, "Failed to create directory: (error: %d)", (uint8_t *)__p, 8u);
      }
      *a1 = 0;
      a1[1] = 0;
      goto LABEL_135;
    }
    if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
    {
      long long v36 = v56;
      if (SHIBYTE(v57) < 0) {
        long long v36 = (void **)v56[0];
      }
      LODWORD(__p[0]) = 136446210;
      *(void **)((char *)__p + 4) = v36;
      _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "#I Created directory: %{public}s", (uint8_t *)__p, 0xCu);
    }
  }
  uint64_t v82 = 0;
  long long v80 = 0u;
  long long v81 = 0u;
  long long v78 = 0u;
  *(_OWORD *)v79 = 0u;
  *(_OWORD *)v76 = 0u;
  *(_OWORD *)v77 = 0u;
  *(_OWORD *)int v74 = 0u;
  long long v75 = 0u;
  long long v72 = 0u;
  *(_OWORD *)int v73 = 0u;
  *(_OWORD *)OsLogContext __p = 0u;
  *(_OWORD *)v71 = 0u;
  sub_1004E62F8((char *)__p, a2, a3);
  if (!(_BYTE)v82)
  {
    long long v35 = *v8;
    if (os_log_type_enabled(*v8, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)int buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_ERROR, "Missing parameters", buf, 2u);
    }
    *a1 = 0;
    a1[1] = 0;
    goto LABEL_120;
  }
  *(_OWORD *)int buf = 0u;
  *(_OWORD *)dispatch_object_t object = 0u;
  v69 = 0;
  *(_OWORD *)uint64_t v67 = 0u;
  long long v68 = 0u;
  memset(v66, 0, sizeof(v66));
  *(_OWORD *)v64 = 0u;
  long long v65 = 0u;
  *(_OWORD *)int v63 = 0u;
  *(_DWORD *)int buf = a3;
  uint64_t v23 = *(void *)(a2 + 88);
  *(void *)&uint8_t buf[8] = *(void *)(a2 + 80);
  object[0] = (dispatch_object_t)v23;
  if (v23) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v23 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v24 = *(NSObject **)(a2 + 24);
  object[1] = v24;
  if (v24) {
    dispatch_retain(v24);
  }
  uint64_t v25 = *(std::__shared_weak_count **)(a2 + 16);
  if (!v25 || (uint64_t v26 = *(std::__shared_weak_count **)(a2 + 8), (v27 = std::__shared_weak_count::lock(v25)) == 0)) {
    sub_100088B9C();
  }
  __int16 v28 = v27;
  atomic_fetch_add_explicit(&v27->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v27);
  v63[0] = 0;
  v63[1] = 0;
  uint64_t v29 = std::__shared_weak_count::lock(v28);
  __int16 v30 = v29;
  if (v29) {
    atomic_fetch_add_explicit(&v29->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  }
  else {
    uint64_t v26 = 0;
  }
  long long v37 = v63[1];
  v63[0] = v26;
  v63[1] = v30;
  if (v37) {
    std::__shared_weak_count::__release_weak(v37);
  }
  std::__shared_weak_count::__release_weak(v28);
  if (v30) {
    sub_10004D2C8(v30);
  }
  if (SHIBYTE(v57) < 0)
  {
    sub_10004FC84(v64, v56[0], (unint64_t)v56[1]);
  }
  else
  {
    *(_OWORD *)v64 = *(_OWORD *)v56;
    *(void *)&long long v65 = v57;
  }
  if (!(_BYTE)v82) {
    sub_10016C840();
  }
  *((void *)&v65 + 1) = v73;
  LOBYTE(v66[0]) = *(unsigned char *)(a4 + 172);
  if (*(char *)(a4 + 143) < 0)
  {
    sub_10004FC84(&v66[1], *(void **)(a4 + 120), *(void *)(a4 + 128));
  }
  else
  {
    *(_OWORD *)&v66[1] = *(_OWORD *)(a4 + 120);
    v66[3] = *(void **)(a4 + 136);
  }
  if (*(char *)(a4 + 167) < 0)
  {
    sub_10004FC84(v67, *(void **)(a4 + 144), *(void *)(a4 + 152));
  }
  else
  {
    *(_OWORD *)uint64_t v67 = *(_OWORD *)(a4 + 144);
    *(void *)&long long v68 = *(void *)(a4 + 160);
  }
  long long v38 = *(std::__shared_weak_count **)(a2 + 192);
  *((void *)&v68 + 1) = *(void *)(a2 + 184);
  v69 = v38;
  if (v38) {
    atomic_fetch_add_explicit(&v38->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v40 = *(void *)(a2 + 200);
  uint64_t v39 = *(void *)(a2 + 208);
  long long v41 = (std::__shared_weak_count *)operator new(0x110uLL);
  uint64_t v42 = v41;
  v41->__shared_owners_ = 0;
  v41->__shared_weak_owners_ = 0;
  v41->__vftable = (std::__shared_weak_count_vtbl *)off_1019DAF60;
  long long v43 = (LazuliProvisioningModel *)&v41[1];
  *(void *)&long long v83 = v40;
  *((void *)&v83 + 1) = v39;
  if (v39) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v39 + 8), 1uLL, memory_order_relaxed);
  }
  LazuliProvisioningModel::LazuliProvisioningModel((uint64_t)&v41[1], (uint64_t)buf, (uint64_t)&v83);
  if (*((void *)&v83 + 1)) {
    sub_10004D2C8(*((std::__shared_weak_count **)&v83 + 1));
  }
  shared_owners = (std::__shared_weak_count *)v42[1].__shared_owners_;
  if (!shared_owners)
  {
    atomic_fetch_add_explicit(&v42->__shared_owners_, 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit(&v42->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    v42[1].__vftable = (std::__shared_weak_count_vtbl *)&v42[1];
    v42[1].__shared_owners_ = (uint64_t)v42;
    goto LABEL_93;
  }
  if (shared_owners->__shared_owners_ == -1)
  {
    atomic_fetch_add_explicit(&v42->__shared_owners_, 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit(&v42->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    v42[1].__vftable = (std::__shared_weak_count_vtbl *)&v42[1];
    v42[1].__shared_owners_ = (uint64_t)v42;
    std::__shared_weak_count::__release_weak(shared_owners);
LABEL_93:
    sub_10004D2C8(v42);
  }
  LazuliProvisioningModel::prepareFromDisk(v43, 0);
  uint64_t v60 = 0;
  int v45 = (uint64_t **)sub_100046ED4(a2 + 112, &v60, (void **)a4);
  uint64_t v46 = *v45;
  if (!*v45)
  {
    v47 = v45;
    uint64_t v84 = 0;
    uint64_t v46 = operator new(0x48uLL);
    *(void *)&long long v83 = v46;
    *((void *)&v83 + 1) = v11;
    uint64_t v48 = v46 + 4;
    if (*(char *)(a4 + 23) < 0)
    {
      sub_10004FC84(v48, *(void **)a4, *(void *)(a4 + 8));
    }
    else
    {
      *(_OWORD *)uint64_t v48 = *(_OWORD *)a4;
      v46[6] = *(void *)(a4 + 16);
    }
    v46[7] = 0;
    v46[8] = 0;
    LOBYTE(v84) = 1;
    uint64_t v49 = v60;
    *uint64_t v46 = 0;
    v46[1] = 0;
    v46[2] = v49;
    void *v47 = v46;
    uint64_t v50 = (void *)**v9;
    long long v51 = v46;
    if (v50)
    {
      *__int16 v9 = v50;
      long long v51 = *v47;
    }
    sub_100046C90(*v11, v51);
    ++*(void *)(a2 + 128);
    *(void *)&long long v83 = 0;
    sub_1001FEBC4((uint64_t)&v83);
  }
  atomic_fetch_add_explicit(&v42->__shared_owners_, 1uLL, memory_order_relaxed);
  int v52 = (std::__shared_weak_count *)v46[8];
  v46[7] = v43;
  v46[8] = v42;
  if (v52) {
    sub_10004D2C8(v52);
  }
  uint64_t v53 = *sub_100046ED4(a2 + 112, &v83, (void **)a4);
  if (!v53) {
    sub_1000C14F0("map::at:  key not found");
  }
  uint64_t v55 = *(void *)(v53 + 56);
  uint64_t v54 = *(void *)(v53 + 64);
  *a1 = v55;
  a1[1] = v54;
  if (v54) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v54 + 8), 1uLL, memory_order_relaxed);
  }
  sub_10004D2C8(v42);
  if (v69) {
    sub_10004D2C8(v69);
  }
  if (SBYTE7(v68) < 0) {
    operator delete(v67[0]);
  }
  if (SHIBYTE(v66[3]) < 0) {
    operator delete(v66[1]);
  }
  if (SBYTE7(v65) < 0) {
    operator delete(v64[0]);
  }
  if (v63[1]) {
    std::__shared_weak_count::__release_weak(v63[1]);
  }
  if (object[1]) {
    dispatch_release(object[1]);
  }
  if (object[0]) {
    sub_10004D2C8((std::__shared_weak_count *)object[0]);
  }
LABEL_120:
  if ((_BYTE)v82)
  {
    if (SBYTE7(v80) < 0) {
      operator delete(v79[0]);
    }
    if (SHIBYTE(v78) < 0) {
      operator delete(v77[1]);
    }
    if (SHIBYTE(v77[0]) < 0) {
      operator delete(v76[0]);
    }
    if (SHIBYTE(v75) < 0) {
      operator delete(v74[1]);
    }
    if (SHIBYTE(v74[0]) < 0) {
      operator delete(v73[0]);
    }
    if (SHIBYTE(v72) < 0) {
      operator delete(v71[1]);
    }
    if (SHIBYTE(v71[0]) < 0) {
      operator delete(__p[0]);
    }
  }
LABEL_135:
  if (SHIBYTE(v57) < 0) {
    operator delete(v56[0]);
  }
  if (SHIBYTE(v59) < 0) {
    operator delete(v58[0]);
  }
}

void sub_1004E4A8C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,void *a23,uint64_t a24,uint64_t a25,dispatch_object_t object,uint64_t a27,std::__shared_weak_count *a28,void *a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,void *a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  sub_1001FEBC4(v68 - 128);
  sub_10004D2C8(v67);
  sub_1004E9380((uint64_t)&a23);
  if (a67) {
    sub_1001F7180((uint64_t)&a43);
  }
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a21 < 0) {
    operator delete(a16);
  }
  _Unwind_Resume(a1);
}

void sub_1004E4BE8(uint64_t a1, LazuliProvisioningModel **a2, uint64_t a3)
{
  uint64_t v6 = *((unsigned int *)*a2 + 24);
  (*(void (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), v6);
  uint64_t v7 = (NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), v6);
  if ((sub_1004E6618(*(void *)(a1 + 48), v6, a3) & 1) == 0)
  {
    uint64_t v11 = *v7;
    if (!os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_37;
    }
    *(_WORD *)int buf = 0;
    uint64_t v12 = "#I Provisioning not possible";
    goto LABEL_36;
  }
  if (!*(_DWORD *)(a3 + 176))
  {
    uint64_t v11 = *v7;
    if (!os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_37;
    }
    *(_WORD *)int buf = 0;
    uint64_t v12 = "#I Provisioning not possible (both cellular and wifi unavailable)";
    goto LABEL_36;
  }
  if (!*(unsigned char *)(a3 + 172))
  {
    if (v6 == 1) {
      int v13 = 2;
    }
    else {
      int v13 = 1;
    }
    int v14 = *(void **)(a1 + 112);
    if (v14 != (void *)(a1 + 120))
    {
      while (1)
      {
        uint64_t v15 = (LazuliProvisioningModel *)v14[7];
        if (v15)
        {
          if (*((_DWORD *)v15 + 24) == v13) {
            break;
          }
        }
        uint64_t v16 = (void *)v14[1];
        if (v16)
        {
          do
          {
            uint64_t v17 = v16;
            uint64_t v16 = (void *)*v16;
          }
          while (v16);
        }
        else
        {
          do
          {
            uint64_t v17 = (void *)v14[2];
            BOOL v21 = *v17 == (void)v14;
            int v14 = v17;
          }
          while (!v21);
        }
        int v14 = v17;
        if (v17 == (void *)(a1 + 120)) {
          goto LABEL_23;
        }
      }
      if (LazuliProvisioningModel::isAppAttestationOngoing(v15))
      {
        uint64_t v11 = *v7;
        if (!os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_37;
        }
        *(_WORD *)int buf = 0;
        uint64_t v12 = "#I Provisioning not possible (app attestation ongoing for other sub)";
        goto LABEL_36;
      }
      if (*(unsigned char *)(a3 + 172)) {
        goto LABEL_4;
      }
    }
LABEL_23:
    if (sub_1004E6368(a1, v6) || *(_DWORD *)(a3 + 176) != 2) {
      goto LABEL_4;
    }
    uint64_t v11 = *v7;
    if (!os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_37;
    }
    *(_WORD *)int buf = 0;
    uint64_t v12 = "#I First time provisioning not possible on other sub";
LABEL_36:
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, v12, buf, 2u);
    goto LABEL_37;
  }
LABEL_4:
  BOOL v8 = *v7;
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v9 = *(int *)(a3 + 176);
    if (v9 > 4) {
      int v10 = "kCellular";
    }
    else {
      int v10 = off_1019DAFB8[v9];
    }
    *(_DWORD *)int buf = 136315138;
    *(void *)long long v34 = v10;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Provisioning possible over: [%s]", buf, 0xCu);
  }
  if (LazuliProvisioningModel::anyServerNeedsProvisioning(*a2))
  {
    uint64_t v18 = (uint64_t)*a2;
    LOBYTE(__p) = 0;
    char v32 = 0;
    LazuliProvisioningModel::startWebProvisioning(v18, (uint64_t)&__p);
    if (v32)
    {
      if (v31 < 0) {
        operator delete(__p);
      }
    }
  }
LABEL_37:
  BOOL v19 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), v6);
  if (*(unsigned __int8 *)(a3 + 185) | *(unsigned __int8 *)(a3 + 186)) {
    goto LABEL_45;
  }
  uint64_t v20 = (unsigned char *)(a3 + 168);
  if (!*(unsigned char *)(a3 + 169)) {
    uint64_t v20 = (unsigned char *)(a3 + 173);
  }
  BOOL v21 = !*v20 || *(unsigned char *)(a3 + 171) == 0;
  if (v21)
  {
LABEL_45:
    int v22 = 0;
  }
  else
  {
    uint64_t v29 = *(unsigned __int8 *)(a3 + 23);
    if ((v29 & 0x80u) != 0) {
      uint64_t v29 = *(void *)(a3 + 8);
    }
    int v22 = 1;
    if (v29 && *(_DWORD *)(a3 + 180))
    {
      if (LazuliProvisioningModel::isImsReady(*a2)) {
        LazuliProvisioningModel::publishLazuliInformation(*a2);
      }
      return;
    }
  }
  uint64_t v23 = *v19;
  if (os_log_type_enabled(*v19, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v24 = "true";
    if (*(unsigned char *)(a3 + 171)) {
      uint64_t v25 = "true";
    }
    else {
      uint64_t v25 = "false";
    }
    uint64_t v26 = *(unsigned __int8 *)(a3 + 23);
    if ((v26 & 0x80u) != 0) {
      uint64_t v26 = *(void *)(a3 + 8);
    }
    if (!v26) {
      uint64_t v24 = "false";
    }
    uint64_t v27 = *(int *)(a3 + 180);
    if (v27 > 4) {
      __int16 v28 = "kCellular";
    }
    else {
      __int16 v28 = off_1019DAFB8[v27];
    }
    *(_DWORD *)int buf = 67109890;
    *(_DWORD *)long long v34 = v22;
    *(_WORD *)&v34[4] = 2080;
    *(void *)&v34[6] = v25;
    __int16 v35 = 2080;
    long long v36 = v24;
    __int16 v37 = 2080;
    long long v38 = v28;
    _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "#I IMS registration not possible: [feature enabled: %{BOOL}d, support: %s, imsi available: %s, ims interface: %s]", buf, 0x26u);
  }
}

void sub_1004E5040(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15)
{
  if (a15)
  {
    if (a14 < 0) {
      operator delete(__p);
    }
  }
  _Unwind_Resume(exception_object);
}

void sub_1004E506C(uint64_t *a1, uint64_t a2)
{
  int v12 = a2;
  uint64_t v3 = (std::__shared_weak_count *)a1[2];
  if (v3)
  {
    uint64_t v5 = *a1;
    uint64_t v6 = std::__shared_weak_count::lock(v3);
    if (v6)
    {
      uint64_t v7 = v6;
      if (a1[1])
      {
        if (sub_1002C74D0((uint64_t **)(v5 + 136), a2, &v12)[5])
        {
          BOOL v8 = sub_1002C74D0((uint64_t **)(v5 + 136), a2, &v12);
          uint64_t v9 = v8[5];
          v8[5] = 0;
          if (v9)
          {
            dispatch_group_leave(v9);
            dispatch_release(v9);
          }
        }
        int v10 = sub_100256E84((uint64_t **)(v5 + 160), a2, &v12);
        uint64_t v11 = (std::__shared_weak_count *)v10[6];
        v10[5] = 0;
        v10[6] = 0;
        if (v11) {
          sub_10004D2C8(v11);
        }
        sub_1004E3F04(v5, a2);
      }
      sub_10004D2C8(v7);
    }
  }
}

void sub_1004E5164(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1004E5178(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 48);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 8);
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  return a1;
}

void sub_1004E51B4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a3 + 8);
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_1004E52C4(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)int buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Powering on", buf, 2u);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (!v3 || (v4 = *(void *)(a1 + 200), uint64_t v5 = *(void *)(a1 + 8), (v6 = std::__shared_weak_count::lock(v3)) == 0)) {
    sub_100088B9C();
  }
  uint64_t v7 = v5 + 56;
  if (!v5) {
    uint64_t v7 = 0;
  }
  uint64_t v26 = v7;
  uint64_t v27 = v6;
  (*(void (**)(uint64_t, uint64_t *))(*(void *)v4 + 88))(v4, &v26);
  if (v27) {
    sub_10004D2C8(v27);
  }
  uint64_t v8 = a1 + 64;
  if ((ctu::RestModule::isConnected((ctu::RestModule *)(a1 + 64)) & 1) == 0)
  {
    Registry::createRestModuleOneTimeUseConnection(&v24, *(Registry **)(a1 + 80));
    ctu::RestModule::connect();
    if (v25) {
      sub_10004D2C8(v25);
    }
  }
  uint64_t v9 = (uint8_t *)(a1 + 216);
  *(void *)int buf = off_1019DAB90;
  uint64_t v29 = a1 + 64;
  __int16 v30 = buf;
  if (buf != (uint8_t *)(a1 + 216))
  {
    int v10 = *(uint8_t **)(a1 + 240);
    if (v10 == v9)
    {
      uint64_t v32 = a1 + 64;
      uint64_t v33 = 0;
      __int16 v30 = 0;
      OsLogContext __p = off_1019DAB90;
      (*(void (**)(uint64_t, uint8_t *))(*(void *)v9 + 24))(a1 + 216, buf);
      (*(void (**)(void))(**(void **)(a1 + 240) + 32))(*(void *)(a1 + 240));
      *(void *)(a1 + 240) = 0;
      __int16 v30 = buf;
      (*((void (**)(void **, uint64_t))__p + 3))(&__p, a1 + 216);
      (*((void (**)(void **))__p + 4))(&__p);
    }
    else
    {
      *(void *)(a1 + 216) = off_1019DAB90;
      *(void *)(a1 + 224) = v8;
      __int16 v30 = v10;
    }
    *(void *)(a1 + 240) = v9;
  }
  sub_1004E92FC(buf);
  uint64_t v11 = *(void *)(a1 + 240);
  if (v11) {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v11 + 48))(v11, a1 + 248);
  }
  int v12 = (uint8_t *)(a1 + 272);
  *(void *)int buf = off_1019DAC20;
  uint64_t v29 = a1 + 64;
  __int16 v30 = buf;
  if (buf != (uint8_t *)(a1 + 272))
  {
    int v13 = *(uint8_t **)(a1 + 296);
    if (v13 == v12)
    {
      uint64_t v32 = a1 + 64;
      uint64_t v33 = 0;
      __int16 v30 = 0;
      OsLogContext __p = off_1019DAC20;
      (*(void (**)(uint64_t, uint8_t *))(*(void *)v12 + 24))(a1 + 272, buf);
      (*(void (**)(void))(**(void **)(a1 + 296) + 32))(*(void *)(a1 + 296));
      *(void *)(a1 + 296) = 0;
      __int16 v30 = buf;
      (*((void (**)(void **, uint64_t))__p + 3))(&__p, a1 + 272);
      (*((void (**)(void **))__p + 4))(&__p);
    }
    else
    {
      *(void *)(a1 + 272) = off_1019DAC20;
      *(void *)(a1 + 280) = v8;
      __int16 v30 = v13;
    }
    *(void *)(a1 + 296) = v12;
  }
  sub_1004E9278(buf);
  uint64_t v14 = *(void *)(a1 + 296);
  if (v14) {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v14 + 48))(v14, a1 + 304);
  }
  uint64_t v15 = (uint8_t *)(a1 + 328);
  *(void *)int buf = off_1019DACB0;
  uint64_t v29 = a1 + 64;
  __int16 v30 = buf;
  if (buf != (uint8_t *)(a1 + 328))
  {
    uint64_t v16 = *(uint8_t **)(a1 + 352);
    if (v16 == v15)
    {
      uint64_t v32 = a1 + 64;
      uint64_t v33 = 0;
      __int16 v30 = 0;
      OsLogContext __p = off_1019DACB0;
      (*(void (**)(uint64_t, uint8_t *))(*(void *)v15 + 24))(a1 + 328, buf);
      (*(void (**)(void))(**(void **)(a1 + 352) + 32))(*(void *)(a1 + 352));
      *(void *)(a1 + 352) = 0;
      __int16 v30 = buf;
      (*((void (**)(void **, uint64_t))__p + 3))(&__p, a1 + 328);
      (*((void (**)(void **))__p + 4))(&__p);
    }
    else
    {
      *(void *)(a1 + 328) = off_1019DACB0;
      *(void *)(a1 + 336) = v8;
      __int16 v30 = v16;
    }
    *(void *)(a1 + 352) = v15;
  }
  sub_1004E91F4(buf);
  uint64_t v17 = *(void *)(a1 + 352);
  if (v17) {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v17 + 48))(v17, a1 + 360);
  }
  uint64_t v18 = (uint8_t *)(a1 + 384);
  *(void *)int buf = off_1019DAD40;
  uint64_t v29 = a1 + 64;
  __int16 v30 = buf;
  if (buf != (uint8_t *)(a1 + 384))
  {
    BOOL v19 = *(uint8_t **)(a1 + 408);
    if (v19 == v18)
    {
      uint64_t v32 = a1 + 64;
      uint64_t v33 = 0;
      __int16 v30 = 0;
      OsLogContext __p = off_1019DAD40;
      (*(void (**)(uint64_t, uint8_t *))(*(void *)v18 + 24))(a1 + 384, buf);
      (*(void (**)(void))(**(void **)(a1 + 408) + 32))(*(void *)(a1 + 408));
      *(void *)(a1 + 408) = 0;
      __int16 v30 = buf;
      (*((void (**)(void **, uint64_t))__p + 3))(&__p, a1 + 384);
      (*((void (**)(void **))__p + 4))(&__p);
    }
    else
    {
      *(void *)(a1 + 384) = off_1019DAD40;
      *(void *)(a1 + 392) = v8;
      __int16 v30 = v19;
    }
    *(void *)(a1 + 408) = v18;
  }
  sub_1004E9170(buf);
  uint64_t v20 = *(void *)(a1 + 408);
  if (v20) {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v20 + 48))(v20, a1 + 416);
  }
  *(void *)int buf = off_1019DADD0;
  uint64_t v29 = a1 + 64;
  __int16 v30 = buf;
  sub_1004EBBD4(buf, (void *)(a1 + 472));
  sub_1004E90EC(buf);
  uint64_t v21 = *(void *)(a1 + 496);
  if (v21) {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v21 + 48))(v21, a1 + 504);
  }
  sub_100058DB0(&__p, "/cc/props/lazuli_provisioning_initializer");
  int v22 = (uint8_t *)operator new(0x28uLL);
  *(void *)int v22 = off_1019DAE60;
  *((void *)v22 + 1) = a1 + 440;
  *((void *)v22 + 2) = a1;
  *((void *)v22 + 3) = sub_1004E2584;
  *((void *)v22 + 4) = 0;
  __int16 v30 = v22;
  ctu::RestModule::observeProperty();
  sub_10003F600(buf);
  if (SHIBYTE(v33) < 0) {
    operator delete(__p);
  }
  sub_100058DB0(&__p, "/cc/events/lazuli_registration_disabled");
  uint64_t v23 = (uint8_t *)operator new(0x20uLL);
  *(void *)uint64_t v23 = off_1019DAEE0;
  *((void *)v23 + 1) = a1;
  *((void *)v23 + 2) = sub_1004E5BB4;
  *((void *)v23 + 3) = 0;
  __int16 v30 = v23;
  ctu::RestModule::observeEvent();
  sub_10003F600(buf);
  if (SHIBYTE(v33) < 0) {
    operator delete(__p);
  }
}

void sub_1004E5B38(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_1004E5BB4(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (os_log_t *)(*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
  uint64_t v5 = *v4;
  if (os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(__p[0]) = 0;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I IMS registration disabled (potential 403)", (uint8_t *)__p, 2u);
  }
  uint64_t v6 = *(void **)(a1 + 112);
  if (v6 != (void *)(a1 + 120))
  {
    do
    {
      uint64_t v15 = 0;
      *(_OWORD *)OsLogContext __p = 0u;
      *(_OWORD *)uint64_t v14 = 0u;
      if (*((char *)v6 + 55) < 0)
      {
        sub_10004FC84(__p, (void *)v6[4], v6[5]);
      }
      else
      {
        *(_OWORD *)OsLogContext __p = *((_OWORD *)v6 + 2);
        v14[0] = *((LazuliProvisioningModel **)v6 + 6);
      }
      uint64_t v7 = (LazuliProvisioningModel *)v6[7];
      uint64_t v8 = (std::__shared_weak_count *)v6[8];
      v14[1] = v7;
      uint64_t v15 = v8;
      if (v8)
      {
        atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
        uint64_t v7 = v14[1];
      }
      if (*((_DWORD *)v7 + 24) == a2)
      {
        v16[0] = 0;
        v16[1] = 0;
        sub_1004E51B4(a1, a2, (uint64_t)v16);
      }
      if (v15) {
        sub_10004D2C8(v15);
      }
      if (SHIBYTE(v14[0]) < 0) {
        operator delete(__p[0]);
      }
      uint64_t v9 = (void *)v6[1];
      if (v9)
      {
        do
        {
          int v10 = v9;
          uint64_t v9 = (void *)*v9;
        }
        while (v9);
      }
      else
      {
        do
        {
          int v10 = (void *)v6[2];
          BOOL v11 = *v10 == (void)v6;
          uint64_t v6 = v10;
        }
        while (!v11);
      }
      uint64_t v6 = v10;
    }
    while (v10 != (void *)(a1 + 120));
  }
  int v12 = *v4;
  if (os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(__p[0]) = 0;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I Unable to find provisioning model", (uint8_t *)__p, 2u);
  }
}

void sub_1004E5D94(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1004E5DAC(uint64_t a1, uint64_t a2, NSObject **a3)
{
  uint64_t v6 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(buf) = 0;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Shutting down", (uint8_t *)&buf, 2u);
  }
  if (a2 == 3)
  {
    subscriber::makeSimSlotRange();
    uint64_t v7 = (unsigned int *)*((void *)&buf + 1);
    uint64_t v8 = (unsigned int *)buf;
    if ((void)buf == *((void *)&buf + 1)) {
      goto LABEL_26;
    }
    uint64_t v9 = v22;
    while ((v9(*v8) & 1) == 0)
    {
      if (++v8 == v7)
      {
        uint64_t v8 = v7;
        break;
      }
    }
    int v10 = (unsigned int *)*((void *)&buf + 1);
    if (v8 == *((unsigned int **)&buf + 1))
    {
LABEL_26:
      char v11 = 0;
    }
    else
    {
      char v11 = 0;
      do
      {
        uint64_t v12 = *v8;
        int v13 = *a3;
        uint64_t v20 = v13;
        if (v13)
        {
          dispatch_retain(v13);
          dispatch_group_enter(v13);
        }
        BOOL v14 = sub_1004E602C((void **)a1, v12, &v20);
        if (v13)
        {
          dispatch_group_leave(v13);
          dispatch_release(v13);
        }
        uint64_t v15 = v8 + 1;
        uint64_t v8 = v7;
        if (v15 != v7)
        {
          uint64_t v8 = v15;
          while ((v9(*v8) & 1) == 0)
          {
            if (++v8 == v7)
            {
              uint64_t v8 = v7;
              break;
            }
          }
        }
        v11 |= v14;
      }
      while (v8 != v10);
    }
  }
  else
  {
    uint64_t v16 = *a3;
    BOOL v19 = v16;
    if (v16)
    {
      dispatch_retain(v16);
      dispatch_group_enter(v16);
    }
    char v11 = sub_1004E602C((void **)a1, a2, &v19);
    if (v16)
    {
      dispatch_group_leave(v16);
      dispatch_release(v16);
    }
  }
  uint64_t v17 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v18 = "false";
    if (v11) {
      uint64_t v18 = "true";
    }
    LODWORD(buf) = 136315138;
    *(void *)((char *)&buf + 4) = v18;
    _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I Deprovisioning ongoing: %s", (uint8_t *)&buf, 0xCu);
  }
}

void sub_1004E5FEC(_Unwind_Exception *exception_object)
{
  if (v1)
  {
    dispatch_group_leave(v1);
    dispatch_release(v1);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_1004E602C(void **a1, uint64_t a2, NSObject **a3)
{
  int v15 = a2;
  uint64_t v6 = a1 + 20;
  uint64_t v7 = sub_100256E84(a1 + 20, a2, &v15)[5];
  if (v7)
  {
    uint64_t v8 = *(NSObject **)(*(uint64_t (**)(void *, uint64_t))(*a1[6] + 16))(a1[6], a2);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)BOOL v14 = 0;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Deprovisioning ongoing. Shutdown will finish after deprovisioning completes.", v14, 2u);
    }
    uint64_t v9 = sub_100256E84(v6, a2, &v15);
    sub_10040F9CC((uint64_t)v9[5], 1);
    int v10 = *a3;
    if (v10)
    {
      dispatch_retain(v10);
      dispatch_group_enter(v10);
    }
    char v11 = sub_1002C74D0(a1 + 17, a2, &v15);
    uint64_t v12 = v11[5];
    v11[5] = (uint64_t *)v10;
    if (v12)
    {
      dispatch_group_leave(v12);
      dispatch_release(v12);
    }
  }
  return v7 != 0;
}

void sub_1004E6158(_Unwind_Exception *exception_object)
{
  if (v1)
  {
    dispatch_group_leave(v1);
    dispatch_release(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1004E6178(void *a1)
{
  uint64_t v2 = a1[5];
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    v14[0] = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Cleanup", (uint8_t *)v14, 2u);
  }
  DefaultLazuliRegistrationInitializerMap = GetDefaultLazuliRegistrationInitializerMap();
  uint64_t v4 = DefaultLazuliRegistrationInitializerMap;
  if (a1[33] == DefaultLazuliRegistrationInitializerMap[2])
  {
    uint64_t v5 = (void *)a1[31];
    if (v5 == a1 + 32) {
      return ctu::RestModule::disconnect((ctu::RestModule *)(a1 + 8));
    }
    uint64_t v6 = (void *)*DefaultLazuliRegistrationInitializerMap;
    while (*((_DWORD *)v5 + 8) == *((_DWORD *)v6 + 8)
         && sub_1007ACBA8((unsigned __int8 *)v5 + 40, (unsigned __int8 *)v6 + 40))
    {
      uint64_t v7 = (void *)v5[1];
      uint64_t v8 = v5;
      if (v7)
      {
        do
        {
          uint64_t v5 = v7;
          uint64_t v7 = (void *)*v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          uint64_t v5 = (void *)v8[2];
          BOOL v9 = *v5 == (void)v8;
          uint64_t v8 = v5;
        }
        while (!v9);
      }
      int v10 = (void *)v6[1];
      if (v10)
      {
        do
        {
          char v11 = v10;
          int v10 = (void *)*v10;
        }
        while (v10);
      }
      else
      {
        do
        {
          char v11 = (void *)v6[2];
          BOOL v9 = *v11 == (void)v6;
          uint64_t v6 = v11;
        }
        while (!v9);
      }
      uint64_t v6 = v11;
      if (v5 == a1 + 32) {
        return ctu::RestModule::disconnect((ctu::RestModule *)(a1 + 8));
      }
    }
  }
  if (a1 + 31 != v4) {
    sub_1004EC1E4(a1 + 31, (void *)*v4, v4 + 1);
  }
  uint64_t v12 = a1[30];
  if (v12) {
    (*(void (**)(uint64_t, void *))(*(void *)v12 + 48))(v12, a1 + 31);
  }
  return ctu::RestModule::disconnect((ctu::RestModule *)(a1 + 8));
}

char *sub_1004E62F8(char *result, uint64_t a2, int a3)
{
  uint64_t v3 = *(void *)(a2 + 448);
  if (!v3) {
    goto LABEL_11;
  }
  uint64_t v4 = a2 + 448;
  do
  {
    int v5 = *(_DWORD *)(v3 + 32);
    BOOL v6 = v5 < a3;
    if (v5 >= a3) {
      uint64_t v7 = (uint64_t *)v3;
    }
    else {
      uint64_t v7 = (uint64_t *)(v3 + 8);
    }
    if (!v6) {
      uint64_t v4 = v3;
    }
    uint64_t v3 = *v7;
  }
  while (*v7);
  if (v4 != a2 + 448 && *(_DWORD *)(v4 + 32) <= a3)
  {
    CFDictionaryRef result = sub_1001FE050(result, (long long *)(v4 + 40));
    char v8 = 1;
  }
  else
  {
LABEL_11:
    char v8 = 0;
    *CFDictionaryRef result = 0;
  }
  result[192] = v8;
  return result;
}

uint64_t sub_1004E6368(uint64_t a1, int a2)
{
  memset(&v22, 0, sizeof(v22));
  uint64_t v2 = *(void **)(a1 + 440);
  if (v2 == (void *)(a1 + 448)) {
    return 0xFFFFFFFFLL;
  }
  while (*((_DWORD *)v2 + 8) != a2)
  {
    int v5 = (void *)v2[1];
    if (v5)
    {
      do
      {
        BOOL v6 = v5;
        int v5 = (void *)*v5;
      }
      while (v5);
    }
    else
    {
      do
      {
        BOOL v6 = (void *)v2[2];
        BOOL v7 = *v6 == (void)v2;
        uint64_t v2 = v6;
      }
      while (!v7);
    }
    uint64_t v2 = v6;
    if (v6 == (void *)(a1 + 448)) {
      return 0xFFFFFFFFLL;
    }
  }
  if (!*((unsigned char *)v2 + 212)) {
    return 1;
  }
  if (*((char *)v2 + 63) < 0)
  {
    if (!v2[6]) {
      return 0xFFFFFFFFLL;
    }
  }
  else if (!*((unsigned char *)v2 + 63))
  {
    return 0xFFFFFFFFLL;
  }
  std::string::operator=(&v22, (const std::string *)(v2 + 5));
  std::string::size_type size = HIBYTE(v22.__r_.__value_.__r.__words[2]);
  if ((v22.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
    std::string::size_type size = v22.__r_.__value_.__l.__size_;
  }
  if (!size)
  {
    uint64_t v8 = 0xFFFFFFFFLL;
    if ((*((unsigned char *)&v22.__r_.__value_.__s + 23) & 0x80) == 0) {
      return v8;
    }
LABEL_39:
    operator delete(v22.__r_.__value_.__l.__data_);
    return v8;
  }
  long long v20 = 0uLL;
  uint64_t v21 = 0;
  sub_100562274((Registry **)(a1 + 80), (uint64_t)__p);
  long long v20 = *(_OWORD *)__p;
  uint64_t v21 = v16;
  __p[1] = 0;
  *(void *)&long long v16 = 0;
  __p[0] = 0;
  ctu::path_join_impl();
  ctu::path_join_impl();
  if (SBYTE7(v16) < 0) {
    operator delete(__p[0]);
  }
  long long v18 = 0u;
  long long v19 = 0u;
  long long v16 = 0u;
  *(_OWORD *)uint64_t v17 = 0u;
  *(_OWORD *)OsLogContext __p = 0u;
  char v11 = *(std::__shared_weak_count **)(a1 + 88);
  uint64_t v13 = *(void *)(a1 + 80);
  BOOL v14 = v11;
  if (v11) {
    atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  sub_1007E3AFC((uint64_t)__p, a2, (uint64_t)&v13, &v20);
  if (v14) {
    sub_10004D2C8(v14);
  }
  uint64_t v8 = sub_1007E8588((uint64_t)__p);
  if (*((void *)&v19 + 1)) {
    sub_10004D2C8(*((std::__shared_weak_count **)&v19 + 1));
  }
  if (SHIBYTE(v18) < 0) {
    operator delete(v17[1]);
  }
  if (v17[0]) {
    sub_10004D2C8((std::__shared_weak_count *)v17[0]);
  }
  uint64_t v12 = __p[1];
  __p[1] = 0;
  if (v12) {
    (*(void (**)(void *))(*(void *)v12 + 8))(v12);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)__p);
  if (SHIBYTE(v21) < 0) {
    operator delete((void *)v20);
  }
  if ((*((unsigned char *)&v22.__r_.__value_.__s + 23) & 0x80) != 0) {
    goto LABEL_39;
  }
  return v8;
}

void sub_1004E65A0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sub_10020F970((ctu::OsLogLogger *)va);
  if (*(char *)(v3 - 41) < 0) {
    operator delete(*(void **)(v3 - 64));
  }
  if (*(char *)(v3 - 17) < 0) {
    operator delete(*(void **)(v3 - 40));
  }
  _Unwind_Resume(a1);
}

uint64_t sub_1004E6618(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = (os_log_t *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
  int v5 = *(unsigned __int8 *)(a3 + 185);
  int v6 = *(unsigned __int8 *)(a3 + 186);
  if (v5 | v6) {
    goto LABEL_15;
  }
  BOOL v7 = (unsigned char *)(a3 + 168);
  if (!*(unsigned char *)(a3 + 169)) {
    BOOL v7 = (unsigned char *)(a3 + 173);
  }
  if (!*v7)
  {
LABEL_15:
    BOOL v8 = 0;
    BOOL v9 = *(unsigned char *)(a3 + 170) != 0;
  }
  else
  {
    BOOL v8 = *(unsigned char *)(a3 + 171) != 0;
    BOOL v9 = *(unsigned char *)(a3 + 170) != 0;
    if (*(unsigned char *)(a3 + 171) && *(unsigned char *)(a3 + 170))
    {
      uint64_t v10 = *(unsigned __int8 *)(a3 + 23);
      if ((v10 & 0x80u) != 0) {
        uint64_t v10 = *(void *)(a3 + 8);
      }
      if (v10)
      {
        uint64_t v11 = *(unsigned __int8 *)(a3 + 95);
        if ((v11 & 0x80u) != 0) {
          uint64_t v11 = *(void *)(a3 + 80);
        }
        BOOL v9 = 1;
        if (v11)
        {
          BOOL v8 = 1;
          uint64_t v12 = 1;
          if (*(unsigned char *)(a3 + 184)) {
            return v12;
          }
          goto LABEL_16;
        }
      }
      else
      {
        BOOL v9 = 1;
      }
      BOOL v8 = 1;
    }
  }
LABEL_16:
  uint64_t v13 = *v4;
  BOOL v14 = os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT);
  uint64_t v12 = 0;
  if (v14)
  {
    int v15 = "true";
    if (*(unsigned char *)(a3 + 171)) {
      long long v16 = "true";
    }
    else {
      long long v16 = "false";
    }
    if (v9) {
      uint64_t v17 = "true";
    }
    else {
      uint64_t v17 = "false";
    }
    uint64_t v18 = *(unsigned __int8 *)(a3 + 23);
    uint64_t v19 = *(unsigned __int8 *)(a3 + 95);
    uint64_t v20 = *(void *)(a3 + 80);
    if ((v18 & 0x80u) != 0) {
      uint64_t v18 = *(void *)(a3 + 8);
    }
    if (v18) {
      uint64_t v21 = "true";
    }
    else {
      uint64_t v21 = "false";
    }
    int v22 = *(unsigned __int8 *)(a3 + 184);
    v27[0] = 67110914;
    if ((v19 & 0x80u) != 0) {
      uint64_t v19 = v20;
    }
    v27[1] = v8;
    __int16 v28 = 2080;
    if (v19) {
      uint64_t v23 = "true";
    }
    else {
      uint64_t v23 = "false";
    }
    uint64_t v29 = v16;
    if (v22) {
      uint64_t v24 = "true";
    }
    else {
      uint64_t v24 = "false";
    }
    __int16 v30 = 2080;
    if (v5) {
      uint64_t v25 = "true";
    }
    else {
      uint64_t v25 = "false";
    }
    char v31 = v17;
    if (!v6) {
      int v15 = "false";
    }
    __int16 v32 = 2080;
    uint64_t v33 = v21;
    __int16 v34 = 2080;
    __int16 v35 = v23;
    __int16 v36 = 2080;
    __int16 v37 = v24;
    __int16 v38 = 2080;
    uint64_t v39 = v25;
    __int16 v40 = 2080;
    long long v41 = v15;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I Lazuli not possible: [feature enabled: %{BOOL}d, support: %s, sms online: %s, imsi available: %s, msisdn available: %s,  first unlock state: %s, feature disabled by profile: %s, feature disabled store demo: %s]", (uint8_t *)v27, 0x4Eu);
    return 0;
  }
  return v12;
}

void sub_1004E6858(uint64_t a1, int a2)
{
  uint64_t v2 = *(void **)(a1 + 440);
  uint64_t v3 = (void *)(a1 + 448);
  if (v2 != (void *)(a1 + 448))
  {
    do
    {
      uint64_t v6 = *((unsigned int *)v2 + 8);
      if (v6 != a2)
      {
        BOOL v7 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v8 = subscriber::asString();
          uint64_t v9 = subscriber::asString();
          *(_DWORD *)long long buf = 136315394;
          *(void *)&uint8_t buf[4] = v8;
          *(_WORD *)&unsigned char buf[12] = 2080;
          *(void *)&buf[14] = v9;
          _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Checking if attestation is required on %s (attestation completed on: %s)", buf, 0x16u);
          uint64_t v6 = *((unsigned int *)v2 + 8);
        }
        *(void *)long long buf = 0;
        *(void *)&uint8_t buf[8] = 0;
        sub_1004E3FF4(buf, a1, v6, (uint64_t)(v2 + 5));
        uint64_t v10 = *(std::__shared_weak_count **)&buf[8];
        if (*(void *)buf)
        {
          v14[0] = *(LazuliProvisioningModel **)buf;
          v14[1] = *(LazuliProvisioningModel **)&buf[8];
          if (*(void *)&buf[8]) {
            atomic_fetch_add_explicit((atomic_ullong *volatile)(*(void *)&buf[8] + 8), 1uLL, memory_order_relaxed);
          }
          sub_1004E4BE8(a1, v14, (uint64_t)(v2 + 5));
          if (!v10) {
            goto LABEL_12;
          }
          sub_10004D2C8(v10);
LABEL_11:
          sub_10004D2C8(v10);
          goto LABEL_12;
        }
        if (*(void *)&buf[8]) {
          goto LABEL_11;
        }
      }
LABEL_12:
      uint64_t v11 = (void *)v2[1];
      if (v11)
      {
        do
        {
          uint64_t v12 = v11;
          uint64_t v11 = (void *)*v11;
        }
        while (v11);
      }
      else
      {
        do
        {
          uint64_t v12 = (void *)v2[2];
          BOOL v13 = *v12 == (void)v2;
          uint64_t v2 = v12;
        }
        while (!v13);
      }
      uint64_t v2 = v12;
    }
    while (v12 != v3);
  }
}

void sub_1004E6A04(_Unwind_Exception *exception_object)
{
  if (v1)
  {
    sub_10004D2C8(v1);
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1004E6A2C(uint64_t a1, int a2)
{
  uint64_t v2 = *(void **)(a1 + 112);
  if (v2 == (void *)(a1 + 120))
  {
LABEL_9:
    BOOL v7 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      int v9 = 136315138;
      uint64_t v10 = subscriber::asString();
      _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "Failed to find model for: %s", (uint8_t *)&v9, 0xCu);
    }
    return 0;
  }
  else
  {
    while (1)
    {
      uint64_t v3 = (LazuliProvisioningModel *)v2[7];
      if (*((_DWORD *)v3 + 24) == a2) {
        break;
      }
      uint64_t v4 = (void *)v2[1];
      if (v4)
      {
        do
        {
          int v5 = v4;
          uint64_t v4 = (void *)*v4;
        }
        while (v4);
      }
      else
      {
        do
        {
          int v5 = (void *)v2[2];
          BOOL v6 = *v5 == (void)v2;
          uint64_t v2 = v5;
        }
        while (!v6);
      }
      uint64_t v2 = v5;
      if (v5 == (void *)(a1 + 120)) {
        goto LABEL_9;
      }
    }
    return LazuliProvisioningModel::getProvisioningOperationState(v3);
  }
}

void sub_1004E6B6C(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = (uint64_t **)(a1 + 112);
  uint64_t v3 = *(uint64_t **)(a1 + 112);
  uint64_t v4 = (uint64_t *)(a1 + 120);
  if (v3 != (uint64_t *)(a1 + 120))
  {
    uint64_t v7 = *(void *)(a1 + 128);
    do
    {
      if (*(_DWORD *)(v3[7] + 96) == a2)
      {
        uint64_t v8 = sub_10006C514(v2, v3);
        sub_1001FEC1C((uint64_t)(v3 + 4));
        operator delete(v3);
      }
      else
      {
        int v9 = (uint64_t *)v3[1];
        if (v9)
        {
          do
          {
            uint64_t v8 = v9;
            int v9 = (uint64_t *)*v9;
          }
          while (v9);
        }
        else
        {
          do
          {
            uint64_t v8 = (uint64_t *)v3[2];
            BOOL v10 = *v8 == (void)v3;
            uint64_t v3 = v8;
          }
          while (!v10);
        }
      }
      uint64_t v3 = v8;
    }
    while (v8 != v4);
    if (v7 != *(void *)(a1 + 128))
    {
      uint64_t v11 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t v12 = 0;
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I Model removed", v12, 2u);
      }
    }
  }
}

uint64_t *sub_1004E6CAC(uint64_t a1, int a2)
{
  uint64_t v2 = *(void *)(a1 + 448);
  if (v2)
  {
    uint64_t v3 = a1 + 448;
    do
    {
      int v4 = *(_DWORD *)(v2 + 32);
      BOOL v5 = v4 < a2;
      if (v4 >= a2) {
        BOOL v6 = (uint64_t *)v2;
      }
      else {
        BOOL v6 = (uint64_t *)(v2 + 8);
      }
      if (!v5) {
        uint64_t v3 = v2;
      }
      uint64_t v2 = *v6;
    }
    while (*v6);
    if (v3 != a1 + 448 && *(_DWORD *)(v3 + 32) <= a2) {
      return (uint64_t *)(v3 + 40);
    }
  }
  uint64_t v7 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
  {
    int v9 = 136315138;
    uint64_t v10 = subscriber::asString();
    _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "Failed to find provisioning information at: %s", (uint8_t *)&v9, 0xCu);
  }
  return GetDefaultLazuliProvisioningInitializer();
}

void sub_1004E6DA0(uint64_t a1, int a2, const std::string *a3)
{
  BOOL v6 = (os_log_t *)(*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
  uint64_t v7 = *(void **)(a1 + 112);
  __int16 v40 = (void *)(a1 + 120);
  if (v7 == (void *)(a1 + 120))
  {
LABEL_47:
    __int16 v30 = *v6;
    if (os_log_type_enabled(*v6, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_ERROR, "OTP sms ignored.", buf, 2u);
    }
  }
  else
  {
    __int16 v35 = v6;
    int v36 = a2;
    __int16 v37 = a3;
    uint64_t v38 = a1;
    uint64_t v8 = (const std::string *)a3->__r_.__value_.__r.__words[0];
    if ((a3->__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
    {
      uint64_t size = a3->__r_.__value_.__l.__size_;
    }
    else
    {
      uint64_t v8 = a3;
      uint64_t size = HIBYTE(a3->__r_.__value_.__r.__words[2]);
    }
    __s = v8;
    uint64_t v10 = (char *)v8 + size;
    uint64_t v11 = *(void **)(a1 + 112);
    do
    {
      int v12 = *((char *)v11 + 55);
      if (v12 >= 0) {
        BOOL v13 = (char *)(v11 + 4);
      }
      else {
        BOOL v13 = (char *)v11[4];
      }
      if (v12 >= 0) {
        int64_t v14 = *((unsigned __int8 *)v11 + 55);
      }
      else {
        int64_t v14 = v11[5];
      }
      if (v14)
      {
        if (size >= v14)
        {
          int v15 = *v13;
          uint64_t v16 = size;
          uint64_t v17 = (std::string *)__s;
          do
          {
            uint64_t v18 = v16 - v14;
            if (v18 == -1) {
              break;
            }
            uint64_t v19 = (char *)memchr(v17, v15, v18 + 1);
            if (!v19) {
              break;
            }
            uint64_t v20 = v19;
            if (!memcmp(v19, v13, v14))
            {
              if (v20 == v10 || v20 - (char *)__s == -1) {
                break;
              }
              goto LABEL_22;
            }
            uint64_t v17 = (std::string *)(v20 + 1);
            uint64_t v16 = v10 - (v20 + 1);
          }
          while (v16 >= v14);
        }
      }
      else
      {
LABEL_22:
        if (size >= 7)
        {
          uint64_t v21 = size;
          int v22 = (std::string *)__s;
          do
          {
            uint64_t v23 = (char *)memchr(v22, 45, v21 - 6);
            if (!v23) {
              break;
            }
            BOOL v24 = *(_DWORD *)v23 == 1935897133 && *(_DWORD *)(v23 + 3) == 1734763379;
            if (v24)
            {
              if (v23 != v10 && v23 - (char *)__s != -1)
              {
                __int16 v32 = *(NSObject **)(a1 + 40);
                if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
                {
                  *(_WORD *)long long buf = 0;
                  _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, "#I Potential reset config received", buf, 2u);
                  LOBYTE(v12) = *((unsigned char *)v11 + 55);
                }
                int v33 = *(_DWORD *)(v11[7] + 96);
                *(void *)long long buf = a1;
                if ((v12 & 0x80) != 0)
                {
                  sub_10004FC84(__p, (void *)v11[4], v11[5]);
                }
                else
                {
                  *(_OWORD *)OsLogContext __p = *((_OWORD *)v11 + 2);
                  __p[2] = *((void **)v11 + 6);
                }
                int v43 = v33;
                __int16 v34 = *(std::__shared_weak_count **)(a1 + 16);
                if (v34 && std::__shared_weak_count::lock(v34)) {
                  operator new();
                }
                sub_100088B9C();
              }
              break;
            }
            int v22 = (std::string *)(v23 + 1);
            uint64_t v21 = v10 - (char *)v22;
          }
          while (v10 - (char *)v22 >= 7);
        }
      }
      uint64_t v25 = (void *)v11[1];
      if (v25)
      {
        do
        {
          uint64_t v26 = v25;
          uint64_t v25 = (void *)*v25;
        }
        while (v25);
      }
      else
      {
        do
        {
          uint64_t v26 = (void *)v11[2];
          BOOL v24 = *v26 == (void)v11;
          uint64_t v11 = v26;
        }
        while (!v24);
      }
      uint64_t v11 = v26;
    }
    while (v26 != v40);
    BOOL v6 = v35;
    while (1)
    {
      uint64_t v27 = v7[7];
      if (*(_DWORD *)(v27 + 96) == v36) {
        break;
      }
      __int16 v28 = (void *)v7[1];
      if (v28)
      {
        do
        {
          uint64_t v29 = v28;
          __int16 v28 = (void *)*v28;
        }
        while (v28);
      }
      else
      {
        do
        {
          uint64_t v29 = (void *)v7[2];
          BOOL v24 = *v29 == (void)v7;
          uint64_t v7 = v29;
        }
        while (!v24);
      }
      uint64_t v7 = v29;
      if (v29 == v40) {
        goto LABEL_47;
      }
    }
    char v31 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(*(os_log_t *)(v38 + 40), OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "#I Potential OTP received", buf, 2u);
      uint64_t v27 = v7[7];
    }
    LazuliProvisioningModel::handleOtp(v27, v37);
  }
}

void sub_1004E71F4(uint64_t a1, int a2, const std::string *a3)
{
  uint64_t v23 = (os_log_t *)(*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
  BOOL v5 = *(void **)(a1 + 112);
  if (v5 != (void *)(a1 + 120))
  {
    char v6 = HIBYTE(a3->__r_.__value_.__r.__words[2]);
    if (v6 >= 0) {
      unint64_t size = HIBYTE(a3->__r_.__value_.__r.__words[2]);
    }
    else {
      unint64_t size = a3->__r_.__value_.__l.__size_;
    }
    if (v6 >= 0) {
      uint64_t v8 = a3;
    }
    else {
      uint64_t v8 = (const std::string *)a3->__r_.__value_.__r.__words[0];
    }
    int v9 = (char *)v8 + size;
    do
    {
      uint64_t v10 = v5[7];
      if (*(_DWORD *)(v10 + 96) == a2 && (uint64_t)size >= 2)
      {
        unint64_t v12 = size;
        BOOL v13 = (std::string *)v8;
        do
        {
          int64_t v14 = (char *)memchr(v13, 71, v12 - 1);
          if (!v14) {
            break;
          }
          if (*(_WORD *)v14 == 11591)
          {
            if (v14 == v9) {
              break;
            }
            int v15 = (char *)(v14 - (char *)v8);
            if (v14 - (char *)v8 == -1) {
              break;
            }
            std::string::size_type v16 = (std::string::size_type)(v15 + 2);
            if ((unint64_t)(v15 + 2) >= size) {
              break;
            }
            uint64_t v21 = *(NSObject **)(a1 + 40);
            if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
            {
              LOWORD(buf.__r_.__value_.__l.__data_) = 0;
              _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "#I GCODE OTP received", (uint8_t *)&buf, 2u);
              uint64_t v10 = v5[7];
            }
            std::string::basic_string(&buf, a3, v16, 0xFFFFFFFFFFFFFFFFLL, (std::allocator<char> *)&v25);
            LazuliProvisioningModel::handleOtp(v10, &buf);
            if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(buf.__r_.__value_.__l.__data_);
            }
            return;
          }
          BOOL v13 = (std::string *)(v14 + 1);
          unint64_t v12 = v9 - (char *)v13;
        }
        while (v9 - (char *)v13 >= 2);
      }
      uint64_t v17 = (void *)v5[1];
      if (v17)
      {
        do
        {
          uint64_t v18 = v17;
          uint64_t v17 = (void *)*v17;
        }
        while (v17);
      }
      else
      {
        do
        {
          uint64_t v18 = (void *)v5[2];
          BOOL v19 = *v18 == (void)v5;
          BOOL v5 = v18;
        }
        while (!v19);
      }
      BOOL v5 = v18;
    }
    while (v18 != (void *)(a1 + 120));
  }
  uint64_t v20 = *v23;
  if (os_log_type_enabled(*v23, OS_LOG_TYPE_ERROR))
  {
    LOWORD(buf.__r_.__value_.__l.__data_) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, "GCODE OTP ignored.", (uint8_t *)&buf, 2u);
  }
}

void sub_1004E7404(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1004E7420(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a3 + 8);
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  int v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_1004E7530(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_1004E7628(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a3 + 8);
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  int v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_1004E7738(uint64_t a1@<X0>, int a2@<W1>, unsigned char *a3@<X8>)
{
  int v4 = *(void **)(a1 + 112);
  if (v4 == (void *)(a1 + 120))
  {
LABEL_9:
    uint64_t v8 = *(NSObject **)(*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v10 = 0;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Unable to find provisioning model", v10, 2u);
    }
    *a3 = 0;
    a3[8] = 0;
    a3[16] = 0;
    a3[88] = 0;
    a3[96] = 0;
    a3[128] = 0;
    a3[136] = 0;
    a3[352] = 0;
    a3[360] = 0;
    a3[408] = 0;
    a3[416] = 0;
    a3[420] = 0;
    a3[424] = 0;
    a3[429] = 0;
  }
  else
  {
    while (*(_DWORD *)(v4[7] + 96) != a2)
    {
      BOOL v5 = (void *)v4[1];
      if (v5)
      {
        do
        {
          char v6 = v5;
          BOOL v5 = (void *)*v5;
        }
        while (v5);
      }
      else
      {
        do
        {
          char v6 = (void *)v4[2];
          BOOL v7 = *v6 == (void)v4;
          int v4 = v6;
        }
        while (!v7);
      }
      int v4 = v6;
      if (v6 == (void *)(a1 + 120)) {
        goto LABEL_9;
      }
    }
    int v9 = (Registry **)v4[7];
    LazuliProvisioningModel::getServiceCapabilities(v9, (uint64_t)a3);
  }
}

void sub_1004E787C(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 448);
  if (!v3) {
    goto LABEL_11;
  }
  uint64_t v4 = a1 + 448;
  do
  {
    int v5 = *(_DWORD *)(v3 + 32);
    BOOL v6 = v5 < (int)a2;
    if (v5 >= (int)a2) {
      BOOL v7 = (uint64_t *)v3;
    }
    else {
      BOOL v7 = (uint64_t *)(v3 + 8);
    }
    if (!v6) {
      uint64_t v4 = v3;
    }
    uint64_t v3 = *v7;
  }
  while (*v7);
  if (v4 == a1 + 448 || *(_DWORD *)(v4 + 32) > (int)a2)
  {
LABEL_11:
    uint64_t v8 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Server not ready for provisioning", buf, 2u);
    }
    return;
  }
  *(void *)std::string buf = 0;
  int64_t v14 = 0;
  uint64_t v9 = v4 + 40;
  sub_1004E3FF4(buf, a1, a2, v4 + 40);
  uint64_t v10 = *(LazuliProvisioningModel **)buf;
  if (!*(void *)buf)
  {
    uint64_t v11 = (std::__shared_weak_count *)v14;
    if (!v14) {
      return;
    }
    goto LABEL_19;
  }
  LazuliProvisioningModel::refreshXmlCollectionFromDisk(*(LazuliProvisioningModel **)buf);
  uint64_t v11 = (std::__shared_weak_count *)v14;
  v12[0] = v10;
  v12[1] = (LazuliProvisioningModel *)v14;
  if (v14) {
    atomic_fetch_add_explicit(v14 + 1, 1uLL, memory_order_relaxed);
  }
  sub_1004E4BE8(a1, v12, v9);
  if (v11)
  {
    sub_10004D2C8(v11);
LABEL_19:
    sub_10004D2C8(v11);
  }
}

void sub_1004E79A0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  if (v12)
  {
    sub_10004D2C8(v12);
    sub_10004D2C8(v12);
  }
  _Unwind_Resume(exception_object);
}

void sub_1004E79D0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a3 + 8);
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

uint64_t sub_1004E7AE0(uint64_t a1, int a2)
{
  int v79 = a2;
  uint64_t v75 = 1;
  long long v77 = 0u;
  uint64_t v78 = 0;
  uint64_t v76 = a1 + 272;
  uint64_t v3 = a1 + 304;
  sub_1001FE7B4((uint64_t *)&v77, a1 + 304);
  long long v72 = 0;
  int v73 = 0;
  uint64_t v74 = 0;
  sub_1001FE7B4((uint64_t *)&v72, v3);
  DefaultLazuliChatBotInformation = GetDefaultLazuliChatBotInformation();
  int v5 = v73;
  BOOL v6 = (uint64_t *)&v73;
  if (!v73) {
    goto LABEL_12;
  }
  int v7 = v79;
  uint64_t v8 = &v73;
  do
  {
    uint64_t v9 = v5;
    uint64_t v10 = v8;
    int v11 = *((_DWORD *)v5 + 8);
    if (v11 >= v79) {
      uint64_t v8 = (uint64_t **)v5;
    }
    else {
      ++v5;
    }
    int v5 = (uint64_t *)*v5;
  }
  while (v5);
  BOOL v6 = (uint64_t *)&v73;
  if (v8 != &v73 && (v11 >= v79 ? (v12 = v9) : (v12 = v10), BOOL v6 = (uint64_t *)v8, v79 >= v12[8]))
  {
    if (v11 >= v79) {
      uint64_t v18 = (std::string *)(v9 + 5);
    }
    else {
      uint64_t v18 = (std::string *)(v10 + 5);
    }
    std::string::operator=(v18, (const std::string *)DefaultLazuliChatBotInformation);
    if (v11 >= v7) {
      BOOL v19 = (std::string *)(v9 + 8);
    }
    else {
      BOOL v19 = (std::string *)(v10 + 8);
    }
    std::string::operator=(v19, (const std::string *)DefaultLazuliChatBotInformation + 1);
    if (v11 >= v7) {
      uint64_t v20 = (std::string *)(v9 + 11);
    }
    else {
      uint64_t v20 = (std::string *)(v10 + 11);
    }
    std::string::operator=(v20, (const std::string *)DefaultLazuliChatBotInformation + 2);
    uint64_t v21 = (uint64_t *)(v10 + 14);
    uint64_t v22 = DefaultLazuliChatBotInformation[9];
    if (v11 >= v7) {
      uint64_t v21 = v9 + 14;
    }
    *((_WORD *)v21 + 4) = *((_WORD *)DefaultLazuliChatBotInformation + 40);
    uint64_t *v21 = v22;
  }
  else
  {
LABEL_12:
    uint64_t v83 = 0;
    uint64_t v84 = 0;
    BOOL v13 = sub_1000262C0(&v72, v6, &v84, &v83, &v79);
    if (!*v13)
    {
      int v14 = v79;
      uint64_t v82 = 0;
      int v15 = (char *)operator new(0x80uLL);
      std::string::size_type v16 = v15;
      long long v80 = (uint64_t *)v15;
      long long v81 = (uint64_t *)&v73;
      *((_DWORD *)v15 + 8) = v14;
      if (*((char *)DefaultLazuliChatBotInformation + 23) < 0)
      {
        sub_10004FC84(v15 + 40, (void *)*DefaultLazuliChatBotInformation, DefaultLazuliChatBotInformation[1]);
      }
      else
      {
        long long v17 = *(_OWORD *)DefaultLazuliChatBotInformation;
        *((void *)v15 + 7) = DefaultLazuliChatBotInformation[2];
        *(_OWORD *)(v15 + 40) = v17;
      }
      if (*((char *)DefaultLazuliChatBotInformation + 47) < 0)
      {
        sub_10004FC84(v16 + 64, (void *)DefaultLazuliChatBotInformation[3], DefaultLazuliChatBotInformation[4]);
      }
      else
      {
        long long v23 = *(_OWORD *)(DefaultLazuliChatBotInformation + 3);
        *((void *)v16 + 10) = DefaultLazuliChatBotInformation[5];
        *((_OWORD *)v16 + 4) = v23;
      }
      BOOL v24 = v16 + 88;
      if (*((char *)DefaultLazuliChatBotInformation + 71) < 0)
      {
        sub_10004FC84(v24, (void *)DefaultLazuliChatBotInformation[6], DefaultLazuliChatBotInformation[7]);
      }
      else
      {
        long long v25 = *((_OWORD *)DefaultLazuliChatBotInformation + 3);
        *((void *)v16 + 13) = DefaultLazuliChatBotInformation[8];
        *(_OWORD *)BOOL v24 = v25;
      }
      uint64_t v26 = DefaultLazuliChatBotInformation[9];
      *((_WORD *)v16 + 60) = *((_WORD *)DefaultLazuliChatBotInformation + 40);
      *((void *)v16 + 14) = v26;
      LOBYTE(v82) = 1;
      uint64_t v27 = v84;
      __int16 v28 = v80;
      *long long v80 = 0;
      v28[1] = 0;
      v28[2] = (uint64_t)v27;
      uint64_t *v13 = (uint64_t)v28;
      if (*v72)
      {
        long long v72 = (uint64_t **)*v72;
        __int16 v28 = (uint64_t *)*v13;
      }
      sub_100046C90(v73, v28);
      ++v74;
      long long v80 = 0;
      sub_1001FEAB8((uint64_t)&v80, 0);
    }
  }
  sub_1004ED4FC((uint64_t *)&v77, v72, &v73);
  sub_1001F6F58((uint64_t)&v72, v73);
  sub_1004ED380((uint64_t)&v75);
  uint64_t v75 = 1;
  long long v77 = 0u;
  uint64_t v78 = 0;
  uint64_t v76 = a1 + 328;
  sub_1004EE488((uint64_t *)&v77, a1 + 360);
  long long v72 = 0;
  int v73 = 0;
  uint64_t v74 = 0;
  sub_1004EE488((uint64_t *)&v72, a1 + 360);
  DefaultLazuliMessagingInformation = GetDefaultLazuliMessagingInformation();
  __int16 v30 = DefaultLazuliMessagingInformation;
  char v31 = v73;
  __int16 v32 = (uint64_t *)&v73;
  if (!v73) {
    goto LABEL_48;
  }
  int v33 = &v73;
  do
  {
    __int16 v34 = v31;
    __int16 v35 = v33;
    int v36 = *((_DWORD *)v31 + 8);
    if (v36 >= v79) {
      int v33 = (uint64_t **)v31;
    }
    else {
      ++v31;
    }
    char v31 = (uint64_t *)*v31;
  }
  while (v31);
  __int16 v32 = (uint64_t *)&v73;
  if (v33 != &v73 && (v36 >= v79 ? (v37 = v34) : (v37 = v35), __int16 v32 = (uint64_t *)v33, v79 >= v37[8]))
  {
    BOOL v44 = v36 < v79;
    if (v36 >= v79) {
      int v45 = (long long *)(v34 + 5);
    }
    else {
      int v45 = (long long *)(v35 + 5);
    }
    long long v46 = *DefaultLazuliMessagingInformation;
    *(long long *)((char *)v45 + 12) = *(long long *)((char *)DefaultLazuliMessagingInformation + 12);
    *int v45 = v46;
    v47 = (std::string *)(v35 + 9);
    uint64_t v48 = (std::string *)(v34 + 9);
    if (v44) {
      uint64_t v49 = v47;
    }
    else {
      uint64_t v49 = v48;
    }
    std::string::operator=(v49, (const std::string *)(v30 + 2));
  }
  else
  {
LABEL_48:
    uint64_t v83 = 0;
    uint64_t v84 = 0;
    uint64_t v38 = sub_1000262C0(&v72, v32, &v84, &v83, &v79);
    if (!*v38)
    {
      int v39 = v79;
      uint64_t v82 = 0;
      __int16 v40 = (char *)operator new(0x60uLL);
      long long v81 = (uint64_t *)&v73;
      *((_DWORD *)v40 + 8) = v39;
      long long v41 = *(long long *)((char *)v30 + 12);
      *(_OWORD *)(v40 + 40) = *v30;
      *(_OWORD *)(v40 + 52) = v41;
      uint64_t v42 = v40 + 72;
      if (*((char *)v30 + 55) < 0)
      {
        sub_10004FC84(v42, *((void **)v30 + 4), *((void *)v30 + 5));
      }
      else
      {
        long long v43 = v30[2];
        *((void *)v40 + 11) = *((void *)v30 + 6);
        *(_OWORD *)uint64_t v42 = v43;
      }
      uint64_t v50 = v84;
      *(void *)__int16 v40 = 0;
      *((void *)v40 + 1) = 0;
      *((void *)v40 + 2) = v50;
      uint64_t *v38 = (uint64_t)v40;
      if (*v72)
      {
        long long v72 = (uint64_t **)*v72;
        __int16 v40 = (char *)*v38;
      }
      sub_100046C90(v73, (uint64_t *)v40);
      ++v74;
    }
  }
  sub_1004EE56C((uint64_t *)&v77, v72, &v73);
  sub_10021D564((uint64_t)&v72, (char *)v73);
  sub_1004EE318((uint64_t)&v75);
  uint64_t v75 = 1;
  long long v77 = 0u;
  uint64_t v78 = 0;
  uint64_t v76 = a1 + 384;
  uint64_t v51 = a1 + 416;
  sub_1004ECB58((uint64_t *)&v77, v51);
  long long v80 = 0;
  long long v81 = 0;
  uint64_t v82 = 0;
  sub_1004ECB58((uint64_t *)&v80, v51);
  DefaultLazuliDiscoverCapabilitiesInformation = GetDefaultLazuliDiscoverCapabilitiesInformation();
  uint64_t v53 = DefaultLazuliDiscoverCapabilitiesInformation;
  uint64_t v54 = v81;
  uint64_t v55 = (uint64_t *)&v81;
  if (!v81) {
    goto LABEL_73;
  }
  v56 = &v81;
  do
  {
    uint64_t v57 = v54;
    uint64_t v58 = v56;
    int v59 = *((_DWORD *)v54 + 8);
    if (v59 >= v79) {
      v56 = (uint64_t **)v54;
    }
    else {
      ++v54;
    }
    uint64_t v54 = (uint64_t *)*v54;
  }
  while (v54);
  uint64_t v55 = (uint64_t *)&v81;
  if (v56 != &v81 && (v59 >= v79 ? (v60 = v57) : (v60 = v58), uint64_t v55 = (uint64_t *)v56, v79 >= v60[8]))
  {
    uint64_t v66 = v58 + 5;
    uint64_t v67 = v57 + 5;
    if (v59 >= v79) {
      uint64_t v68 = v67;
    }
    else {
      uint64_t v68 = v66;
    }
    long long v69 = *DefaultLazuliDiscoverCapabilitiesInformation;
    long long v70 = DefaultLazuliDiscoverCapabilitiesInformation[1];
    v68[8] = *((_DWORD *)DefaultLazuliDiscoverCapabilitiesInformation + 8);
    *(_OWORD *)uint64_t v68 = v69;
    *((_OWORD *)v68 + 1) = v70;
  }
  else
  {
LABEL_73:
    long long v72 = 0;
    uint64_t v84 = 0;
    uint64_t v61 = sub_1000262C0(&v80, v55, (uint64_t **)&v72, (uint64_t *)&v84, &v79);
    if (!*v61)
    {
      uint64_t v62 = (char *)operator new(0x50uLL);
      *((_DWORD *)v62 + 8) = v79;
      uint64_t v63 = *((void *)v53 + 4);
      long long v64 = v53[1];
      *(_OWORD *)(v62 + 40) = *v53;
      *(_OWORD *)(v62 + 56) = v64;
      *((void *)v62 + 9) = v63;
      long long v65 = v72;
      *(void *)uint64_t v62 = 0;
      *((void *)v62 + 1) = 0;
      *((void *)v62 + 2) = v65;
      *uint64_t v61 = (uint64_t)v62;
      if (*v80)
      {
        long long v80 = (uint64_t *)*v80;
        uint64_t v62 = (char *)*v61;
      }
      sub_100046C90(v81, (uint64_t *)v62);
      ++v82;
    }
  }
  sub_1004ECBB0((uint64_t **)&v77, v80, &v81);
  sub_1000346F8((uint64_t)&v80, v81);
  return sub_1004EC9E0((uint64_t)&v75);
}

void sub_1004E80E8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, char *a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21)
{
  a20 = 0;
  sub_10021D504(v22, v21);
  sub_10021D564((uint64_t)&a10, a11);
  sub_1004EE318((uint64_t)&a13);
  _Unwind_Resume(a1);
}

void sub_1004E81B4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  BOOL v6 = (os_log_t *)(*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
  int v7 = *v6;
  if (os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Subscription removed. Erasing models", buf, 2u);
  }
  uint64_t v8 = sub_100046F68(a1 + 112, (void **)a3);
  if ((void **)(a1 + 120) != v8)
  {
    uint64_t v9 = (uint64_t *)v8;
    LazuliProvisioningModel::stop((LazuliProvisioningModel *)v8[7]);
    sub_10006C514((uint64_t **)(a1 + 112), v9);
    sub_1001FEC1C((uint64_t)(v9 + 4));
    operator delete(v9);
    uint64_t v10 = *v6;
    if (os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT))
    {
      if (*(char *)(a3 + 23) >= 0) {
        int v11 = (void *)a3;
      }
      else {
        int v11 = *(void **)a3;
      }
      *(_DWORD *)std::string buf = 141558275;
      *(void *)&uint8_t buf[4] = 1752392040;
      *(_WORD *)&unsigned char buf[12] = 2085;
      *(void *)&buf[14] = v11;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I Model erased with ID: %{sensitive, mask.hash}s", buf, 0x16u);
    }
  }
  sub_100562274((Registry **)(a1 + 80), (uint64_t)__p);
  *(_OWORD *)std::string buf = *(_OWORD *)__p;
  *(void **)&uint8_t buf[16] = __p[2];
  memset(__p, 0, 24);
  ctu::path_join_impl();
  ctu::path_join_impl();
  if (SHIBYTE(__p[2]) < 0) {
    operator delete(__p[0]);
  }
  if ((*(unsigned int (**)(void, unsigned char *))(**(void **)(a1 + 96) + 88))(*(void *)(a1 + 96), buf))
  {
    unint64_t v12 = (void *)(*(uint64_t (**)(void, unsigned char *))(**(void **)(a1 + 96) + 112))(*(void *)(a1 + 96), buf);
    BOOL v13 = *v6;
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      int v14 = buf;
      if (buf[23] < 0) {
        int v14 = *(unsigned char **)buf;
      }
      LODWORD(__p[0]) = 136446466;
      *(void **)((char *)__p + 4) = v14;
      WORD2(__p[1]) = 2048;
      *(void **)((char *)&__p[1] + 6) = v12;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I Erased folder: [%{public}s] [status: %zu]", (uint8_t *)__p, 0x16u);
    }
  }
  sub_1004E7AE0(a1, a2);
  __p[0] = 0;
  __p[1] = 0;
  sub_1004E51B4(a1, a2, (uint64_t)__p);
}

void sub_1004E84A0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1004E84EC(uint64_t a1, uint64_t a2)
{
  sub_1004E7AE0(a1, a2);
  __p[0] = 0;
  __p[1] = 0;
  sub_1004E51B4(a1, a2, (uint64_t)__p);
}

void sub_1004E85B8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, xpc_object_t a17)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  xpc_release(a17);
  _Unwind_Resume(a1);
}

void sub_1004E85FC(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I === Provisioning controller state ===", buf, 2u);
  }
  uint64_t v3 = *(void **)(a1 + 112);
  if (v3 != (void *)(a1 + 120))
  {
    do
    {
      uint64_t v4 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), *(unsigned int *)(v3[7] + 96));
      if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Dumping Model: ", buf, 2u);
      }
      LazuliProvisioningModel::dump((LazuliProvisioningModel *)v3[7]);
      int v5 = (void *)v3[1];
      if (v5)
      {
        do
        {
          BOOL v6 = v5;
          int v5 = (void *)*v5;
        }
        while (v5);
      }
      else
      {
        do
        {
          BOOL v6 = (void *)v3[2];
          BOOL v7 = *v6 == (void)v3;
          uint64_t v3 = v6;
        }
        while (!v7);
      }
      uint64_t v3 = v6;
    }
    while (v6 != (void *)(a1 + 120));
  }
  uint64_t v8 = *(void **)(a1 + 136);
  if (v8 != (void *)(a1 + 144))
  {
    do
    {
      uint64_t v9 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), *((unsigned int *)v8 + 8));
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
      {
        if (v8[5]) {
          uint64_t v10 = "YES";
        }
        else {
          uint64_t v10 = "NO";
        }
        *(_DWORD *)std::string buf = 136315138;
        uint64_t v20 = v10;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I In shutdown: %s", buf, 0xCu);
      }
      int v11 = (void *)v8[1];
      if (v11)
      {
        do
        {
          unint64_t v12 = v11;
          int v11 = (void *)*v11;
        }
        while (v11);
      }
      else
      {
        do
        {
          unint64_t v12 = (void *)v8[2];
          BOOL v7 = *v12 == (void)v8;
          uint64_t v8 = v12;
        }
        while (!v7);
      }
      uint64_t v8 = v12;
    }
    while (v12 != (void *)(a1 + 144));
  }
  BOOL v13 = *(void **)(a1 + 160);
  if (v13 != (void *)(a1 + 168))
  {
    do
    {
      int v14 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), *((unsigned int *)v13 + 8));
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
      {
        if (v13[5]) {
          int v15 = "YES";
        }
        else {
          int v15 = "NO";
        }
        *(_DWORD *)std::string buf = 136315138;
        uint64_t v20 = v15;
        _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I DeprovisioningTimer running: %s", buf, 0xCu);
      }
      std::string::size_type v16 = (void *)v13[1];
      if (v16)
      {
        do
        {
          long long v17 = v16;
          std::string::size_type v16 = (void *)*v16;
        }
        while (v16);
      }
      else
      {
        do
        {
          long long v17 = (void *)v13[2];
          BOOL v7 = *v17 == (void)v13;
          BOOL v13 = v17;
        }
        while (!v7);
      }
      BOOL v13 = v17;
    }
    while (v17 != (void *)(a1 + 168));
  }
  uint64_t v18 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#I === === ===", buf, 2u);
  }
}

void sub_1004E897C(uint64_t a1, int a2, __int16 a3)
{
  int v6 = a3;
  int v7 = HIBYTE(a3);
  uint64_t v8 = *(NSObject **)(*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v9 = "Enabled";
    if (!v6) {
      uint64_t v9 = "Disabled";
    }
    if (!v7) {
      uint64_t v9 = "Unknown";
    }
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = v9;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Business messaging switch state changed to: %s", buf, 0xCu);
  }
  uint64_t v10 = *(void *)(a1 + 256);
  if (!v10) {
    goto LABEL_17;
  }
  uint64_t v11 = a1 + 256;
  do
  {
    int v12 = *(_DWORD *)(v10 + 32);
    BOOL v13 = v12 < a2;
    if (v12 >= a2) {
      int v14 = (uint64_t *)v10;
    }
    else {
      int v14 = (uint64_t *)(v10 + 8);
    }
    if (!v13) {
      uint64_t v11 = v10;
    }
    uint64_t v10 = *v14;
  }
  while (*v14);
  if (v11 != a1 + 256 && *(_DWORD *)(v11 + 32) <= a2)
  {
    if (v7 && *(unsigned char *)(v11 + 285))
    {
      if (*(unsigned __int8 *)(v11 + 284) == v6) {
        return;
      }
    }
    else if ((v7 != 0) == (*(unsigned char *)(v11 + 285) != 0))
    {
      return;
    }
    *(void *)std::string buf = 1;
    long long v25 = 0u;
    uint64_t v26 = 0;
    *(void *)&uint8_t buf[8] = a1 + 216;
    sub_1001FE2D0((uint64_t *)&v25, a1 + 248);
    std::string::size_type v16 = (uint64_t *)*((void *)&v25 + 1);
    long long v17 = (uint64_t **)&v25 + 1;
    uint64_t v18 = (uint64_t **)&v25 + 1;
    if (*((void *)&v25 + 1))
    {
      do
      {
        while (1)
        {
          uint64_t v18 = (uint64_t **)v16;
          int v19 = *((_DWORD *)v16 + 8);
          if (v19 <= a2) {
            break;
          }
          std::string::size_type v16 = *v18;
          long long v17 = v18;
          if (!*v18) {
            goto LABEL_33;
          }
        }
        if (v19 >= a2)
        {
          uint64_t v22 = (char *)v18;
          goto LABEL_36;
        }
        std::string::size_type v16 = v18[1];
      }
      while (v16);
      long long v17 = v18 + 1;
    }
LABEL_33:
    v23[2] = 1;
    uint64_t v22 = (char *)operator new(0x140uLL);
    v23[1] = (char *)&v25 + 8;
    *((_DWORD *)v22 + 8) = a2;
    *(_OWORD *)(v22 + 280) = 0u;
    *(_OWORD *)(v22 + 56) = 0u;
    *(_OWORD *)(v22 + 72) = 0u;
    *(_OWORD *)(v22 + 88) = 0u;
    *(_OWORD *)(v22 + 104) = 0u;
    *(_OWORD *)(v22 + 120) = 0u;
    *(_OWORD *)(v22 + 136) = 0u;
    *(_OWORD *)(v22 + 152) = 0u;
    *(_OWORD *)(v22 + 168) = 0u;
    *(_OWORD *)(v22 + 184) = 0u;
    *(_OWORD *)(v22 + 200) = 0u;
    *(_OWORD *)(v22 + 216) = 0u;
    *(_OWORD *)(v22 + 232) = 0u;
    *(_OWORD *)(v22 + 248) = 0u;
    *(_OWORD *)(v22 + 264) = 0u;
    *(_OWORD *)(v22 + 40) = 0u;
    v22[289] = 1;
    *(void *)(v22 + 300) = 0;
    *((_DWORD *)v22 + 79) = 0;
    *(void *)(v22 + 292) = 0;
    *(void *)(v22 + 308) = 0;
    *(void *)uint64_t v22 = 0;
    *((void *)v22 + 1) = 0;
    *((void *)v22 + 2) = v18;
    *long long v17 = (uint64_t *)v22;
    uint64_t v20 = (uint64_t *)v22;
    if (*(void *)v25)
    {
      *(void *)&long long v25 = *(void *)v25;
      uint64_t v20 = *v17;
    }
    sub_100046C90(*((uint64_t **)&v25 + 1), v20);
    ++v26;
    v23[0] = 0;
    sub_1001FE75C((uint64_t)v23, 0);
LABEL_36:
    *((_WORD *)v22 + 142) = a3;
    sub_1004EDD20((uint64_t)buf);
  }
  else
  {
LABEL_17:
    int v15 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
    {
      uint64_t v21 = subscriber::asString();
      *(_DWORD *)std::string buf = 136315138;
      *(void *)&uint8_t buf[4] = v21;
      _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "Registration information not found for: %s", buf, 0xCu);
    }
  }
}

void sub_1004E8CA8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  sub_1004EDD20((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1004E8CC4(uint64_t a1, int a2, __int16 a3)
{
}

void sub_1004E8CD0(uint64_t a1@<X0>, int a2@<W1>, uint64_t a3@<X8>)
{
  int v6 = (NSObject **)(*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
  uint64_t v21 = 0;
  long long v19 = 0u;
  long long v20 = 0u;
  long long v17 = 0u;
  *(_OWORD *)OsLogContext __p = 0u;
  *(_OWORD *)int v15 = 0u;
  *(_OWORD *)std::string::size_type v16 = 0u;
  *(_OWORD *)BOOL v13 = 0u;
  long long v14 = 0u;
  long long v11 = 0u;
  *(_OWORD *)int v12 = 0u;
  *(_OWORD *)uint64_t v9 = 0u;
  *(_OWORD *)uint64_t v10 = 0u;
  sub_1004E62F8((char *)v9, a1, a2);
  if ((_BYTE)v21)
  {
    if (SHIBYTE(v16[0]) < 0)
    {
      sub_10004FC84((unsigned char *)a3, v15[0], (unint64_t)v15[1]);
    }
    else
    {
      *(_OWORD *)a3 = *(_OWORD *)v15;
      *(void **)(a3 + 16) = v16[0];
    }
  }
  else
  {
    int v7 = *v6;
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t v8 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "Missing parameters", v8, 2u);
    }
    *(void *)a3 = 0;
    *(void *)(a3 + 8) = 0;
    *(void *)(a3 + 16) = 0;
  }
  if ((_BYTE)v21)
  {
    if (SBYTE7(v19) < 0) {
      operator delete(__p[0]);
    }
    if (SHIBYTE(v17) < 0) {
      operator delete(v16[1]);
    }
    if (SHIBYTE(v16[0]) < 0) {
      operator delete(v15[0]);
    }
    if (SHIBYTE(v14) < 0) {
      operator delete(v13[1]);
    }
    if (SHIBYTE(v13[0]) < 0) {
      operator delete(v12[0]);
    }
    if (SHIBYTE(v11) < 0) {
      operator delete(v10[1]);
    }
    if (SHIBYTE(v10[0]) < 0) {
      operator delete(v9[0]);
    }
  }
}

void sub_1004E8E68(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,char a35)
{
  if (a35) {
    sub_1001F7180((uint64_t)&a11);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1004E8E84(uint64_t a1, int a2, int *a3)
{
  int v24 = a2;
  v21[0] = 1;
  long long v22 = 0u;
  uint64_t v23 = 0;
  v21[1] = a1 + 472;
  sub_1004EEA5C((uint64_t *)&v22, a1 + 504);
  sub_100995F94(a3, (char *)&object);
  uint64_t v5 = *((void *)&v22 + 1);
  int v6 = (uint64_t *)&v22 + 1;
  if (!*((void *)&v22 + 1)) {
    goto LABEL_12;
  }
  int v7 = (uint64_t *)&v22 + 1;
  do
  {
    uint64_t v8 = (uint64_t *)v5;
    uint64_t v9 = v7;
    int v10 = *(_DWORD *)(v5 + 32);
    if (v10 >= a2) {
      int v7 = (uint64_t *)v5;
    }
    else {
      v5 += 8;
    }
    uint64_t v5 = *(void *)v5;
  }
  while (v5);
  int v6 = (uint64_t *)&v22 + 1;
  if (v7 != (uint64_t *)((char *)&v22 + 8) && (v10 >= a2 ? (v11 = v8) : (v11 = v9), int v6 = v7, *((_DWORD *)v11 + 8) <= a2))
  {
    xpc_object_t v15 = object;
    xpc_object_t v16 = xpc_null_create();
    if (v10 >= a2) {
      long long v17 = v8;
    }
    else {
      long long v17 = v9;
    }
    xpc_object_t object = v16;
    uint64_t v18 = (void *)v17[5];
    v17[5] = (uint64_t)v15;
    xpc_release(v18);
  }
  else
  {
LABEL_12:
    uint64_t v27 = 0;
    __int16 v28 = 0;
    int v12 = sub_1000262C0(&v22, v6, &v28, &v27, &v24);
    if (!*v12)
    {
      uint64_t v26 = 0;
      BOOL v13 = operator new(0x30uLL);
      v25[1] = (char *)&v22 + 8;
      v13[8] = v24;
      *((void *)v13 + 5) = object;
      xpc_object_t object = xpc_null_create();
      LOBYTE(v26) = 1;
      long long v14 = v28;
      *(void *)BOOL v13 = 0;
      *((void *)v13 + 1) = 0;
      *((void *)v13 + 2) = v14;
      uint64_t *v12 = (uint64_t)v13;
      if (*(void *)v22)
      {
        *(void *)&long long v22 = *(void *)v22;
        BOOL v13 = (_DWORD *)*v12;
      }
      sub_100046C90(*((uint64_t **)&v22 + 1), (uint64_t *)v13);
      ++v23;
      v25[0] = 0;
      sub_100455C48((uint64_t)v25, 0);
    }
  }
  xpc_release(object);
  return sub_1004EEC44((uint64_t)v21);
}

void sub_1004E9044(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, char a11)
{
}

void sub_1004E9070(uint64_t a1)
{
  sub_1004E9404(a1);

  operator delete();
}

uint64_t sub_1004E90A8(uint64_t a1)
{
  return sub_1004E9404(a1 - 56);
}

void sub_1004E90B0(uint64_t a1)
{
  sub_1004E9404(a1 - 56);

  operator delete();
}

void *sub_1004E90EC(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *sub_1004E9170(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *sub_1004E91F4(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *sub_1004E9278(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *sub_1004E92FC(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t sub_1004E9380(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 144);
  if (v2) {
    sub_10004D2C8(v2);
  }
  if (*(char *)(a1 + 135) < 0) {
    operator delete(*(void **)(a1 + 112));
  }
  if (*(char *)(a1 + 111) < 0) {
    operator delete(*(void **)(a1 + 88));
  }
  if (*(char *)(a1 + 71) < 0) {
    operator delete(*(void **)(a1 + 48));
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 40);
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  uint64_t v4 = *(NSObject **)(a1 + 24);
  if (v4) {
    dispatch_release(v4);
  }
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 16);
  if (v5) {
    sub_10004D2C8(v5);
  }
  return a1;
}

uint64_t sub_1004E9404(uint64_t a1)
{
  *(void *)a1 = off_1019DA898;
  uint64_t v2 = (LazuliFeatureSettingsModelObserverInterface *)(a1 + 56);
  *(void *)(a1 + 56) = off_1019DA978;
  uint64_t v3 = (void *)(a1 + 472);
  sub_100453C90(a1 + 504, *(void **)(a1 + 512));
  sub_1004E90EC(v3);
  sub_1001F7124(a1 + 440, *(void **)(a1 + 448));
  sub_1000346F8(a1 + 416, *(void **)(a1 + 424));
  sub_1004E9170((void *)(a1 + 384));
  sub_10021D564(a1 + 360, *(char **)(a1 + 368));
  sub_1004E91F4((void *)(a1 + 328));
  sub_1001F6F58(a1 + 304, *(void **)(a1 + 312));
  sub_1004E9278((void *)(a1 + 272));
  sub_1001F701C(a1 + 248, *(void **)(a1 + 256));
  sub_1004E92FC((void *)(a1 + 216));
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 208);
  if (v4) {
    sub_10004D2C8(v4);
  }
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 192);
  if (v5) {
    sub_10004D2C8(v5);
  }
  sub_100119D90(*(void **)(a1 + 168));
  sub_1004E95BC(*(void **)(a1 + 144));
  sub_1001FEC70(*(void **)(a1 + 120));
  int v6 = *(std::__shared_weak_count **)(a1 + 104);
  if (v6) {
    sub_10004D2C8(v6);
  }
  int v7 = *(std::__shared_weak_count **)(a1 + 88);
  if (v7) {
    sub_10004D2C8(v7);
  }
  uint64_t v8 = *(std::__shared_weak_count **)(a1 + 72);
  if (v8) {
    sub_10004D2C8(v8);
  }
  LazuliFeatureSettingsModelObserverInterface::~LazuliFeatureSettingsModelObserverInterface(v2);
  LazuliLifetimeInterface::~LazuliLifetimeInterface((LazuliLifetimeInterface *)a1);
  uint64_t v9 = *(void *)(a1 + 48);
  *(void *)(a1 + 48) = 0;
  if (v9) {
    (*(void (**)(uint64_t))(*(void *)v9 + 8))(v9);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 40));
  sub_100087E88((void *)(a1 + 8));
  return a1;
}

void sub_1004E959C()
{
}

uint64_t sub_1004E95B0(uint64_t a1)
{
  return *(void *)(a1 + 8) + 40;
}

void sub_1004E95BC(void *a1)
{
  if (a1)
  {
    sub_1004E95BC(*a1);
    sub_1004E95BC(a1[1]);
    uint64_t v2 = a1[5];
    if (v2)
    {
      dispatch_group_leave(v2);
      uint64_t v3 = a1[5];
      if (v3) {
        dispatch_release(v3);
      }
    }
    operator delete(a1);
  }
}

uint64_t sub_1004E9620(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 24) = 0;
  sub_1001FE7B4((uint64_t *)(a1 + 32), a2);
  return a1;
}

void sub_1004E9650(_Unwind_Exception *a1)
{
  sub_1004E9278(v1);
  _Unwind_Resume(a1);
}

void sub_1004E9664(NSObject **a1@<X1>, Registry **a2@<X2>, void *a3@<X3>, uint64_t *a4@<X4>, void *a5@<X8>)
{
  int v10 = operator new(0x228uLL);
  sub_1004E96F8(v10, a1, a2, a3, a4);
  *a5 = v10 + 3;
  a5[1] = v10;

  sub_1000B3BC8((uint64_t)a5, v10 + 4, (uint64_t)(v10 + 3));
}

void sub_1004E96E4(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_1004E96F8(void *a1, NSObject **a2, Registry **a3, void *a4, uint64_t *a5)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = off_1019DAAC0;
  sub_1004E97F0((uint64_t)(a1 + 3), a2, a3, a4, a5);
  return a1;
}

void sub_1004E9740(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void sub_1004E9754(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1019DAAC0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1004E9774(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1019DAAC0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_1004E97C8(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 24) + 48))();
}

uint64_t sub_1004E97F0(uint64_t a1, NSObject **a2, Registry **a3, void *a4, uint64_t *a5)
{
  uint64_t v8 = (std::__shared_weak_count *)a3[1];
  __int16 v37 = *a3;
  uint64_t v38 = v8;
  if (v8) {
    atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v9 = *a5;
  uint64_t v10 = a5[1];
  *a5 = 0;
  a5[1] = 0;
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v49, kCtLoggingSystemName, "lazuli.prov.ctr");
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  long long v11 = *a2;
  *(void *)(a1 + 24) = *a2;
  if (v11) {
    dispatch_retain(v11);
  }
  *(void *)(a1 + 32) = 0;
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v48, &v49);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 40), (const ctu::OsLogLogger *)v48);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v48);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v49);
  v48[0] = off_101999E18;
  v48[1] = sub_1004E241C;
  v48[3] = v48;
  *(void *)(a1 + 48) = 0;
  if ((capabilities::ct::supportsGemini(v12) & 1) == 0) {
    operator new();
  }
  if (!*(void *)(a1 + 48)) {
    operator new();
  }
  uint64_t v36 = v10;
  sub_10008863C(v48);
  *(void *)a1 = off_1019DA898;
  *(void *)(a1 + 56) = off_1019DA978;
  sub_100058DB0(&__p, "lazuli.prov.ctr");
  BOOL v13 = *a2;
  dispatch_object_t v44 = v13;
  if (v13) {
    dispatch_retain(v13);
  }
  dispatch_object_t object = 0;
  ctu::RestModule::RestModule();
  if (v44) {
    dispatch_release(v44);
  }
  if (v46 < 0) {
    operator delete(__p);
  }
  long long v14 = v37;
  *(void *)(a1 + 80) = v37;
  *(void *)(a1 + 88) = v38;
  if (v38)
  {
    atomic_fetch_add_explicit(&v38->__shared_owners_, 1uLL, memory_order_relaxed);
    long long v14 = *(Registry **)(a1 + 80);
  }
  Registry::getFileSystemInterface((uint64_t *)(a1 + 96), v14);
  *(void *)(a1 + 120) = 0;
  *(void *)(a1 + 128) = 0;
  *(void *)(a1 + 112) = a1 + 120;
  long long v41 = v37;
  uint64_t v42 = v38;
  if (v38) {
    atomic_fetch_add_explicit(&v38->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  *(void *)(a1 + 144) = 0;
  *(void *)(a1 + 152) = 0;
  *(void *)(a1 + 136) = a1 + 144;
  subscriber::makeSimSlotRange();
  var0 = v49.var0;
  fRef = v49.var1.fRef;
  if (v49.var0 != (char *)v49.var1.fRef)
  {
    long long v17 = v50;
    while ((v17(*(unsigned int *)var0) & 1) == 0)
    {
      var0 += 4;
      if (var0 == (char *)fRef)
      {
        var0 = (char *)fRef;
        break;
      }
    }
    uint64_t v18 = v49.var1.fRef;
LABEL_25:
    while (var0 != (char *)v18)
    {
      LODWORD(v39) = 0;
      LODWORD(v39) = *(_DWORD *)var0;
      long long v19 = sub_1002C74D0((uint64_t **)(a1 + 136), (int)v39, &v39);
      long long v20 = v19[5];
      v19[5] = 0;
      if (v20)
      {
        dispatch_group_leave(v20);
        dispatch_release(v20);
      }
      uint64_t v21 = var0 + 4;
      var0 = (char *)fRef;
      if (v21 != (char *)fRef)
      {
        var0 = v21;
        while ((v17(*(unsigned int *)var0) & 1) == 0)
        {
          var0 += 4;
          if (var0 == (char *)fRef)
          {
            var0 = (char *)fRef;
            goto LABEL_25;
          }
        }
      }
    }
  }
  if (v42) {
    sub_10004D2C8(v42);
  }
  int v39 = v37;
  __int16 v40 = v38;
  if (v38) {
    atomic_fetch_add_explicit(&v38->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  *(void *)(a1 + 168) = 0;
  *(void *)(a1 + 176) = 0;
  *(void *)(a1 + 160) = a1 + 168;
  subscriber::makeSimSlotRange();
  long long v22 = v49.var0;
  uint64_t v23 = v49.var1.fRef;
  if (v49.var0 != (char *)v49.var1.fRef)
  {
    int v24 = v50;
    while ((v24(*(unsigned int *)v22) & 1) == 0)
    {
      v22 += 4;
      if (v22 == (char *)v23)
      {
        long long v22 = (char *)v23;
        break;
      }
    }
    long long v25 = v49.var1.fRef;
LABEL_43:
    while (v22 != (char *)v25)
    {
      int v47 = 0;
      int v47 = *(_DWORD *)v22;
      uint64_t v26 = sub_100256E84((uint64_t **)(a1 + 160), v47, &v47);
      uint64_t v27 = (std::__shared_weak_count *)v26[6];
      v26[5] = 0;
      v26[6] = 0;
      if (v27) {
        sub_10004D2C8(v27);
      }
      __int16 v28 = v22 + 4;
      long long v22 = (char *)v23;
      if (v28 != (char *)v23)
      {
        long long v22 = v28;
        while ((v24(*(unsigned int *)v22) & 1) == 0)
        {
          v22 += 4;
          if (v22 == (char *)v23)
          {
            long long v22 = (char *)v23;
            goto LABEL_43;
          }
        }
      }
    }
  }
  if (v40) {
    sub_10004D2C8(v40);
  }
  *(void *)(a1 + 184) = *a4;
  uint64_t v29 = a4[1];
  *(void *)(a1 + 192) = v29;
  if (v29) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v29 + 8), 1uLL, memory_order_relaxed);
  }
  *(void *)(a1 + 200) = v9;
  *(void *)(a1 + 208) = v36;
  DefaultLazuliRegistrationInitializerMap = GetDefaultLazuliRegistrationInitializerMap();
  *(void *)(a1 + 240) = 0;
  sub_1001FE2D0((uint64_t *)(a1 + 248), (uint64_t)DefaultLazuliRegistrationInitializerMap);
  DefaultLazuliChatBotInformationMap = GetDefaultLazuliChatBotInformationMap();
  sub_1004E9620(a1 + 272, (uint64_t)DefaultLazuliChatBotInformationMap);
  DefaultLazuliMessagingInformationMap = GetDefaultLazuliMessagingInformationMap();
  *(void *)(a1 + 352) = 0;
  sub_1004EE488((uint64_t *)(a1 + 360), (uint64_t)DefaultLazuliMessagingInformationMap);
  DefaultLazuliCapabilitiesInformationMap = GetDefaultLazuliCapabilitiesInformationMap();
  *(void *)(a1 + 408) = 0;
  sub_1004ECB58((uint64_t *)(a1 + 416), (uint64_t)DefaultLazuliCapabilitiesInformationMap);
  DefaultLazuliProvisioningInitializerMap = GetDefaultLazuliProvisioningInitializerMap();
  sub_1001FDE4C((uint64_t *)(a1 + 440), (uint64_t)DefaultLazuliProvisioningInitializerMap);
  *(void *)(a1 + 520) = 0;
  *(void *)(a1 + 504) = a1 + 512;
  *(void *)(a1 + 512) = 0;
  *(void *)(a1 + 496) = 0;
  if (!*(void *)(a1 + 96)) {
    __TUAssertTrigger();
  }
  if (!*(void *)(a1 + 184)) {
    __TUAssertTrigger();
  }
  if (v38) {
    sub_10004D2C8(v38);
  }
  return a1;
}

void sub_1004E9D98(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, dispatch_object_t object, dispatch_object_t a20,void *__p,uint64_t a22,int a23,__int16 a24,char a25,char a26,uint64_t a27,char a28)
{
  sub_10008863C((void *)(v28 - 128));
  operator delete();
}

void *sub_1004EA044(void *a1)
{
  *a1 = off_1019DAB10;
  uint64_t v2 = (std::__shared_weak_count *)a1[7];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)a1[2];
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  return a1;
}

void sub_1004EA09C(void *a1)
{
  *a1 = off_1019DAB10;
  uint64_t v2 = (std::__shared_weak_count *)a1[7];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)a1[2];
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }

  operator delete();
}

char *sub_1004EA114(uint64_t a1)
{
  CFDictionaryRef result = (char *)operator new(0x40uLL);
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 16);
  *(void *)CFDictionaryRef result = off_1019DAB10;
  *((void *)result + 1) = v4;
  *((void *)result + 2) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  *((void *)result + 3) = *(void *)(a1 + 24);
  *((_DWORD *)result + 8) = *(_DWORD *)(a1 + 32);
  *(_OWORD *)(result + 40) = *(_OWORD *)(a1 + 40);
  uint64_t v5 = *(void *)(a1 + 56);
  *((void *)result + 7) = v5;
  if (v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_1004EA1A0(uint64_t result, uint64_t a2)
{
  uint64_t v3 = *(void *)(result + 8);
  uint64_t v2 = *(void *)(result + 16);
  *(void *)a2 = off_1019DAB10;
  *(void *)(a2 + 8) = v3;
  *(void *)(a2 + 16) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  uint64_t v4 = *(void *)(result + 24);
  *(_DWORD *)(a2 + 32) = *(_DWORD *)(result + 32);
  *(void *)(a2 + 24) = v4;
  *(_OWORD *)(a2 + 40) = *(_OWORD *)(result + 40);
  uint64_t v5 = *(void *)(result + 56);
  *(void *)(a2 + 56) = v5;
  if (v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_1004EA208(uint64_t a1)
{
}

void sub_1004EA210(void *a1)
{
  sub_1004EA454((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_1004EA24C(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2)
  {
    uint64_t v3 = *(void *)(a1 + 24);
    uint64_t v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      uint64_t v5 = v4;
      if (*(void *)(a1 + 8))
      {
        int v6 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v3 + 48) + 16))(*(void *)(v3 + 48), *(unsigned int *)(a1 + 32));
        if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)std::string buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Forcing deprovisioning operations to end", buf, 2u);
        }
        int v7 = *(void **)(v3 + 112);
        if (v7 != (void *)(v3 + 120))
        {
          do
          {
            uint64_t v8 = (LazuliProvisioningModel *)v7[7];
            if (*((_DWORD *)v8 + 24) == *(_DWORD *)(a1 + 32)) {
              LazuliProvisioningModel::stop(v8);
            }
            uint64_t v9 = (void *)v7[1];
            if (v9)
            {
              do
              {
                uint64_t v10 = v9;
                uint64_t v9 = (void *)*v9;
              }
              while (v9);
            }
            else
            {
              do
              {
                uint64_t v10 = (void *)v7[2];
                BOOL v11 = *v10 == (void)v7;
                int v7 = v10;
              }
              while (!v11);
            }
            int v7 = v10;
          }
          while (v10 != (void *)(v3 + 120));
        }
        int v12 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v3 + 48) + 16))(*(void *)(v3 + 48), *(unsigned int *)(a1 + 32));
        if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)BOOL v13 = 0;
          _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I Shut down complete", v13, 2u);
        }
        sub_1004E506C((uint64_t *)(a1 + 40), *(unsigned int *)(a1 + 32));
      }
      sub_10004D2C8(v5);
    }
  }
}

void sub_1004EA3E8(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1004EA408(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1004EA448()
{
}

void sub_1004EA454(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 48);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 8);
  if (v3)
  {
    std::__shared_weak_count::__release_weak(v3);
  }
}

uint64_t *sub_1004EA4A4(void **a1)
{
  uint64_t v1 = *a1;
  int v6 = a1;
  int v7 = v1;
  uint64_t v2 = (std::__shared_weak_count *)v1[2];
  if (v2)
  {
    uint64_t v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      uint64_t v4 = v3;
      if (v1[1]) {
        sub_1004E506C(v1 + 3, *(unsigned int *)v1);
      }
      sub_10004D2C8(v4);
    }
  }
  sub_1004EA534((uint64_t *)&v7);
  return sub_100046B58((uint64_t *)&v6);
}

void sub_1004EA510(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  sub_10004D2C8(v10);
  sub_1004EA534(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_1004EA534(uint64_t *result)
{
  uint64_t v1 = *result;
  *CFDictionaryRef result = 0;
  if (v1)
  {
    uint64_t v2 = *(std::__shared_weak_count **)(v1 + 40);
    if (v2) {
      std::__shared_weak_count::__release_weak(v2);
    }
    uint64_t v3 = *(std::__shared_weak_count **)(v1 + 16);
    if (v3) {
      std::__shared_weak_count::__release_weak(v3);
    }
    operator delete();
  }
  return result;
}

void sub_1004EA598()
{
}

void *sub_1004EA5AC(uint64_t a1)
{
  CFDictionaryRef result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *CFDictionaryRef result = off_1019DAB90;
  result[1] = v3;
  return result;
}

uint64_t sub_1004EA5F4(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019DAB90;
  a2[1] = v2;
  return result;
}

void sub_1004EA620(uint64_t a1, void *a2)
{
  xpc_object_t v3 = xpc_array_create(0, 0);
  if (v3 || (xpc_object_t v3 = xpc_null_create()) != 0)
  {
    if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_array)
    {
      xpc_retain(v3);
      xpc_object_t v4 = v3;
    }
    else
    {
      xpc_object_t v4 = xpc_null_create();
    }
  }
  else
  {
    xpc_object_t v4 = xpc_null_create();
    xpc_object_t v3 = 0;
  }
  xpc_release(v3);
  int v7 = (void *)*a2;
  uint64_t v5 = a2 + 1;
  int v6 = v7;
  if (v7 != v5)
  {
    do
    {
      xpc_object_t v8 = xpc_dictionary_create(0, 0, 0);
      xpc_object_t v9 = v8;
      if (v8)
      {
        xpc_object_t v26 = v8;
      }
      else
      {
        xpc_object_t v9 = xpc_null_create();
        xpc_object_t v26 = v9;
        if (!v9)
        {
          xpc_object_t v10 = xpc_null_create();
          xpc_object_t v9 = 0;
          goto LABEL_15;
        }
      }
      if (xpc_get_type(v9) != (xpc_type_t)&_xpc_type_dictionary)
      {
        xpc_object_t v10 = xpc_null_create();
LABEL_15:
        xpc_object_t v26 = v10;
        goto LABEL_16;
      }
      xpc_retain(v9);
LABEL_16:
      xpc_release(v9);
      int v11 = *((_DWORD *)v6 + 8);
      uint64_t v12 = subscriber::asString();
      ctu::rest::detail::write_enum_string_value((uint64_t *)&v24, (ctu::rest::detail *)v11, v12, v13);
      OsLogContext __p = &v26;
      long long v20 = "first";
      sub_100035E70((uint64_t)&__p, &v24, &object);
      xpc_release(object);
      xpc_object_t object = 0;
      xpc_release(v24);
      xpc_object_t v24 = 0;
      write_rest_value((uint64_t)(v6 + 5), &v22);
      OsLogContext __p = &v26;
      long long v20 = "second";
      sub_100035E70((uint64_t)&__p, &v22, &v23);
      xpc_release(v23);
      xpc_object_t v23 = 0;
      xpc_release(v22);
      xpc_object_t v22 = 0;
      xpc_object_t v14 = v26;
      if (v26) {
        xpc_retain(v26);
      }
      else {
        xpc_object_t v14 = xpc_null_create();
      }
      xpc_release(v26);
      xpc_array_append_value(v4, v14);
      xpc_release(v14);
      xpc_object_t v15 = (void *)v6[1];
      if (v15)
      {
        do
        {
          xpc_object_t v16 = v15;
          xpc_object_t v15 = (void *)*v15;
        }
        while (v15);
      }
      else
      {
        do
        {
          xpc_object_t v16 = (void *)v6[2];
          BOOL v17 = *v16 == (void)v6;
          int v6 = v16;
        }
        while (!v17);
      }
      int v6 = v16;
    }
    while (v16 != v5);
  }
  if (v4)
  {
    xpc_retain(v4);
    xpc_object_t v18 = v4;
  }
  else
  {
    xpc_object_t v18 = xpc_null_create();
  }
  xpc_release(v4);
  sub_100058DB0(&__p, "/cc/props/lazuli_registration_initializer");
  xpc_object_t v26 = v18;
  if (v18) {
    xpc_retain(v18);
  }
  else {
    xpc_object_t v26 = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(v26);
  xpc_object_t v26 = 0;
  if (v21 < 0) {
    operator delete(__p);
  }
  xpc_release(v18);
}

void sub_1004EA8E8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, xpc_object_t object)
{
  xpc_release(object);
  if (a14 < 0) {
    operator delete(__p);
  }
  xpc_release(v19);
  _Unwind_Resume(a1);
}

uint64_t sub_1004EA9A0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1004EA9E0()
{
}

void sub_1004EA9F0()
{
}

void *sub_1004EAA04(uint64_t a1)
{
  CFDictionaryRef result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *CFDictionaryRef result = off_1019DAC20;
  result[1] = v3;
  return result;
}

uint64_t sub_1004EAA4C(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019DAC20;
  a2[1] = v2;
  return result;
}

void sub_1004EAA78(uint64_t a1, void *a2)
{
  xpc_object_t v3 = xpc_array_create(0, 0);
  if (v3 || (xpc_object_t v3 = xpc_null_create()) != 0)
  {
    if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_array)
    {
      xpc_retain(v3);
      xpc_object_t v4 = v3;
    }
    else
    {
      xpc_object_t v4 = xpc_null_create();
    }
  }
  else
  {
    xpc_object_t v4 = xpc_null_create();
    xpc_object_t v3 = 0;
  }
  xpc_release(v3);
  int v7 = (void *)*a2;
  uint64_t v5 = a2 + 1;
  int v6 = v7;
  if (v7 != v5)
  {
    do
    {
      xpc_object_t v8 = xpc_dictionary_create(0, 0, 0);
      xpc_object_t v9 = v8;
      if (v8)
      {
        xpc_object_t v26 = v8;
      }
      else
      {
        xpc_object_t v9 = xpc_null_create();
        xpc_object_t v26 = v9;
        if (!v9)
        {
          xpc_object_t v10 = xpc_null_create();
          xpc_object_t v9 = 0;
          goto LABEL_15;
        }
      }
      if (xpc_get_type(v9) != (xpc_type_t)&_xpc_type_dictionary)
      {
        xpc_object_t v10 = xpc_null_create();
LABEL_15:
        xpc_object_t v26 = v10;
        goto LABEL_16;
      }
      xpc_retain(v9);
LABEL_16:
      xpc_release(v9);
      int v11 = *((_DWORD *)v6 + 8);
      uint64_t v12 = subscriber::asString();
      ctu::rest::detail::write_enum_string_value((uint64_t *)&v24, (ctu::rest::detail *)v11, v12, v13);
      OsLogContext __p = &v26;
      long long v20 = "first";
      sub_100035E70((uint64_t)&__p, &v24, &object);
      xpc_release(object);
      xpc_object_t object = 0;
      xpc_release(v24);
      xpc_object_t v24 = 0;
      write_rest_value((uint64_t)(v6 + 5), &v22);
      OsLogContext __p = &v26;
      long long v20 = "second";
      sub_100035E70((uint64_t)&__p, &v22, &v23);
      xpc_release(v23);
      xpc_object_t v23 = 0;
      xpc_release(v22);
      xpc_object_t v22 = 0;
      xpc_object_t v14 = v26;
      if (v26) {
        xpc_retain(v26);
      }
      else {
        xpc_object_t v14 = xpc_null_create();
      }
      xpc_release(v26);
      xpc_array_append_value(v4, v14);
      xpc_release(v14);
      xpc_object_t v15 = (void *)v6[1];
      if (v15)
      {
        do
        {
          xpc_object_t v16 = v15;
          xpc_object_t v15 = (void *)*v15;
        }
        while (v15);
      }
      else
      {
        do
        {
          xpc_object_t v16 = (void *)v6[2];
          BOOL v17 = *v16 == (void)v6;
          int v6 = v16;
        }
        while (!v17);
      }
      int v6 = v16;
    }
    while (v16 != v5);
  }
  if (v4)
  {
    xpc_retain(v4);
    xpc_object_t v18 = v4;
  }
  else
  {
    xpc_object_t v18 = xpc_null_create();
  }
  xpc_release(v4);
  sub_100058DB0(&__p, "/cc/props/lazuli_chatbot_information");
  xpc_object_t v26 = v18;
  if (v18) {
    xpc_retain(v18);
  }
  else {
    xpc_object_t v26 = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(v26);
  xpc_object_t v26 = 0;
  if (v21 < 0) {
    operator delete(__p);
  }
  xpc_release(v18);
}

void sub_1004EAD40(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, xpc_object_t object)
{
  xpc_release(object);
  if (a14 < 0) {
    operator delete(__p);
  }
  xpc_release(v19);
  _Unwind_Resume(a1);
}

uint64_t sub_1004EADF8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1004EAE38()
{
}

void sub_1004EAE48()
{
}

void *sub_1004EAE5C(uint64_t a1)
{
  CFDictionaryRef result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *CFDictionaryRef result = off_1019DACB0;
  result[1] = v3;
  return result;
}

uint64_t sub_1004EAEA4(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019DACB0;
  a2[1] = v2;
  return result;
}

void sub_1004EAED0(uint64_t a1, void *a2)
{
  xpc_object_t v3 = xpc_array_create(0, 0);
  if (v3 || (xpc_object_t v3 = xpc_null_create()) != 0)
  {
    if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_array)
    {
      xpc_retain(v3);
      xpc_object_t v4 = v3;
    }
    else
    {
      xpc_object_t v4 = xpc_null_create();
    }
  }
  else
  {
    xpc_object_t v4 = xpc_null_create();
    xpc_object_t v3 = 0;
  }
  xpc_release(v3);
  int v7 = (void *)*a2;
  uint64_t v5 = a2 + 1;
  int v6 = v7;
  if (v7 != v5)
  {
    do
    {
      xpc_object_t v8 = xpc_dictionary_create(0, 0, 0);
      xpc_object_t v9 = v8;
      if (v8)
      {
        xpc_object_t v26 = v8;
      }
      else
      {
        xpc_object_t v9 = xpc_null_create();
        xpc_object_t v26 = v9;
        if (!v9)
        {
          xpc_object_t v10 = xpc_null_create();
          xpc_object_t v9 = 0;
          goto LABEL_15;
        }
      }
      if (xpc_get_type(v9) != (xpc_type_t)&_xpc_type_dictionary)
      {
        xpc_object_t v10 = xpc_null_create();
LABEL_15:
        xpc_object_t v26 = v10;
        goto LABEL_16;
      }
      xpc_retain(v9);
LABEL_16:
      xpc_release(v9);
      int v11 = *((_DWORD *)v6 + 8);
      uint64_t v12 = subscriber::asString();
      ctu::rest::detail::write_enum_string_value((uint64_t *)&v24, (ctu::rest::detail *)v11, v12, v13);
      OsLogContext __p = &v26;
      long long v20 = "first";
      sub_100035E70((uint64_t)&__p, &v24, &object);
      xpc_release(object);
      xpc_object_t object = 0;
      xpc_release(v24);
      xpc_object_t v24 = 0;
      write_rest_value((uint64_t)(v6 + 5), &v22);
      OsLogContext __p = &v26;
      long long v20 = "second";
      sub_100035E70((uint64_t)&__p, &v22, &v23);
      xpc_release(v23);
      xpc_object_t v23 = 0;
      xpc_release(v22);
      xpc_object_t v22 = 0;
      xpc_object_t v14 = v26;
      if (v26) {
        xpc_retain(v26);
      }
      else {
        xpc_object_t v14 = xpc_null_create();
      }
      xpc_release(v26);
      xpc_array_append_value(v4, v14);
      xpc_release(v14);
      xpc_object_t v15 = (void *)v6[1];
      if (v15)
      {
        do
        {
          xpc_object_t v16 = v15;
          xpc_object_t v15 = (void *)*v15;
        }
        while (v15);
      }
      else
      {
        do
        {
          xpc_object_t v16 = (void *)v6[2];
          BOOL v17 = *v16 == (void)v6;
          int v6 = v16;
        }
        while (!v17);
      }
      int v6 = v16;
    }
    while (v16 != v5);
  }
  if (v4)
  {
    xpc_retain(v4);
    xpc_object_t v18 = v4;
  }
  else
  {
    xpc_object_t v18 = xpc_null_create();
  }
  xpc_release(v4);
  sub_100058DB0(&__p, "/cc/props/lazuli_messaging_information");
  xpc_object_t v26 = v18;
  if (v18) {
    xpc_retain(v18);
  }
  else {
    xpc_object_t v26 = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(v26);
  xpc_object_t v26 = 0;
  if (v21 < 0) {
    operator delete(__p);
  }
  xpc_release(v18);
}

void sub_1004EB198(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, xpc_object_t object)
{
  xpc_release(object);
  if (a14 < 0) {
    operator delete(__p);
  }
  xpc_release(v19);
  _Unwind_Resume(a1);
}

uint64_t sub_1004EB250(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1004EB290()
{
}

void sub_1004EB2A0()
{
}

void *sub_1004EB2B4(uint64_t a1)
{
  CFDictionaryRef result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *CFDictionaryRef result = off_1019DAD40;
  result[1] = v3;
  return result;
}

uint64_t sub_1004EB2FC(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019DAD40;
  a2[1] = v2;
  return result;
}

void sub_1004EB328(uint64_t a1, void *a2)
{
  xpc_object_t v3 = xpc_array_create(0, 0);
  if (v3 || (xpc_object_t v3 = xpc_null_create()) != 0)
  {
    if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_array)
    {
      xpc_retain(v3);
      xpc_object_t v4 = v3;
    }
    else
    {
      xpc_object_t v4 = xpc_null_create();
    }
  }
  else
  {
    xpc_object_t v4 = xpc_null_create();
    xpc_object_t v3 = 0;
  }
  xpc_release(v3);
  int v7 = (void *)*a2;
  uint64_t v5 = a2 + 1;
  int v6 = v7;
  if (v7 != v5)
  {
    do
    {
      xpc_object_t v8 = xpc_dictionary_create(0, 0, 0);
      xpc_object_t v9 = v8;
      if (v8)
      {
        xpc_object_t v26 = v8;
      }
      else
      {
        xpc_object_t v9 = xpc_null_create();
        xpc_object_t v26 = v9;
        if (!v9)
        {
          xpc_object_t v10 = xpc_null_create();
          xpc_object_t v9 = 0;
          goto LABEL_15;
        }
      }
      if (xpc_get_type(v9) != (xpc_type_t)&_xpc_type_dictionary)
      {
        xpc_object_t v10 = xpc_null_create();
LABEL_15:
        xpc_object_t v26 = v10;
        goto LABEL_16;
      }
      xpc_retain(v9);
LABEL_16:
      xpc_release(v9);
      int v11 = *((_DWORD *)v6 + 8);
      uint64_t v12 = subscriber::asString();
      ctu::rest::detail::write_enum_string_value((uint64_t *)&v24, (ctu::rest::detail *)v11, v12, v13);
      OsLogContext __p = &v26;
      long long v20 = "first";
      sub_100035E70((uint64_t)&__p, &v24, &object);
      xpc_release(object);
      xpc_object_t object = 0;
      xpc_release(v24);
      xpc_object_t v24 = 0;
      write_rest_value((uint64_t)(v6 + 5), &v22);
      OsLogContext __p = &v26;
      long long v20 = "second";
      sub_100035E70((uint64_t)&__p, &v22, &v23);
      xpc_release(v23);
      xpc_object_t v23 = 0;
      xpc_release(v22);
      xpc_object_t v22 = 0;
      xpc_object_t v14 = v26;
      if (v26) {
        xpc_retain(v26);
      }
      else {
        xpc_object_t v14 = xpc_null_create();
      }
      xpc_release(v26);
      xpc_array_append_value(v4, v14);
      xpc_release(v14);
      xpc_object_t v15 = (void *)v6[1];
      if (v15)
      {
        do
        {
          xpc_object_t v16 = v15;
          xpc_object_t v15 = (void *)*v15;
        }
        while (v15);
      }
      else
      {
        do
        {
          xpc_object_t v16 = (void *)v6[2];
          BOOL v17 = *v16 == (void)v6;
          int v6 = v16;
        }
        while (!v17);
      }
      int v6 = v16;
    }
    while (v16 != v5);
  }
  if (v4)
  {
    xpc_retain(v4);
    xpc_object_t v18 = v4;
  }
  else
  {
    xpc_object_t v18 = xpc_null_create();
  }
  xpc_release(v4);
  sub_100058DB0(&__p, "/cc/props/lazuli_capabilities_information");
  xpc_object_t v26 = v18;
  if (v18) {
    xpc_retain(v18);
  }
  else {
    xpc_object_t v26 = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(v26);
  xpc_object_t v26 = 0;
  if (v21 < 0) {
    operator delete(__p);
  }
  xpc_release(v18);
}

void sub_1004EB5F0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, xpc_object_t object)
{
  xpc_release(object);
  if (a14 < 0) {
    operator delete(__p);
  }
  xpc_release(v19);
  _Unwind_Resume(a1);
}

uint64_t sub_1004EB6A8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1004EB6E8()
{
}

void sub_1004EB6F8()
{
}

void *sub_1004EB70C(uint64_t a1)
{
  CFDictionaryRef result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *CFDictionaryRef result = off_1019DADD0;
  result[1] = v3;
  return result;
}

uint64_t sub_1004EB754(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019DADD0;
  a2[1] = v2;
  return result;
}

void sub_1004EB780(uint64_t a1, void *a2)
{
  xpc_object_t v5 = 0;
  sub_1004EB8B4(a2, &v5);
  sub_100058DB0(&__p, "/cc/props/lazuli_analytics_information");
  xpc_object_t object = v5;
  if (v5) {
    xpc_retain(v5);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(object);
  if (v4 < 0) {
    operator delete(__p);
  }
  xpc_release(v5);
}

void sub_1004EB824(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  xpc_release(object);
  if (a16 < 0) {
    operator delete(__p);
  }
  xpc_release(*(xpc_object_t *)(v16 - 24));
  _Unwind_Resume(a1);
}

uint64_t sub_1004EB868(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1004EB8A8()
{
}

void sub_1004EB8B4(void *a1@<X0>, xpc_object_t *a2@<X8>)
{
  xpc_object_t v4 = xpc_array_create(0, 0);
  if (v4 || (xpc_object_t v4 = xpc_null_create()) != 0)
  {
    if (xpc_get_type(v4) == (xpc_type_t)&_xpc_type_array)
    {
      xpc_retain(v4);
      xpc_object_t v5 = v4;
    }
    else
    {
      xpc_object_t v5 = xpc_null_create();
    }
  }
  else
  {
    xpc_object_t v5 = xpc_null_create();
    xpc_object_t v4 = 0;
  }
  xpc_release(v4);
  xpc_object_t v8 = (int *)*a1;
  int v6 = (int *)(a1 + 1);
  int v7 = v8;
  if (v8 != v6)
  {
    do
    {
      sub_1004EBA20(v7 + 8, &value);
      xpc_array_append_value(v5, value);
      xpc_release(value);
      xpc_object_t v9 = (int *)*((void *)v7 + 1);
      if (v9)
      {
        do
        {
          xpc_object_t v10 = v9;
          xpc_object_t v9 = *(int **)v9;
        }
        while (v9);
      }
      else
      {
        do
        {
          xpc_object_t v10 = (int *)*((void *)v7 + 2);
          BOOL v11 = *(void *)v10 == (void)v7;
          int v7 = v10;
        }
        while (!v11);
      }
      int v7 = v10;
    }
    while (v10 != v6);
  }
  *a2 = v5;
  if (v5) {
    xpc_retain(v5);
  }
  else {
    *a2 = xpc_null_create();
  }
  xpc_release(v5);
}

void sub_1004EB9F4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object)
{
  xpc_release(object);
  xpc_release(v10);
  _Unwind_Resume(a1);
}

void sub_1004EBA20(int *a1@<X0>, xpc_object_t *a2@<X8>)
{
  xpc_object_t v4 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v5 = v4;
  if (v4)
  {
    xpc_object_t v18 = v4;
  }
  else
  {
    xpc_object_t v5 = xpc_null_create();
    xpc_object_t v18 = v5;
    if (!v5)
    {
      xpc_object_t v6 = xpc_null_create();
      xpc_object_t v5 = 0;
      goto LABEL_8;
    }
  }
  if (xpc_get_type(v5) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v5);
    goto LABEL_9;
  }
  xpc_object_t v6 = xpc_null_create();
LABEL_8:
  xpc_object_t v18 = v6;
LABEL_9:
  xpc_release(v5);
  int v7 = *a1;
  uint64_t v8 = subscriber::asString();
  ctu::rest::detail::write_enum_string_value((uint64_t *)&v16, (ctu::rest::detail *)v7, v8, v9);
  xpc_object_t v14 = &v18;
  xpc_object_t v15 = "first";
  sub_100035E70((uint64_t)&v14, &v16, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(v16);
  xpc_object_t v16 = 0;
  xpc_object_t v10 = (void *)*((void *)a1 + 1);
  xpc_object_t v12 = v10;
  if (v10) {
    xpc_retain(v10);
  }
  else {
    xpc_object_t v12 = xpc_null_create();
  }
  xpc_object_t v14 = &v18;
  xpc_object_t v15 = "second";
  sub_100035E70((uint64_t)&v14, &v12, &v13);
  xpc_release(v13);
  xpc_object_t v13 = 0;
  xpc_release(v12);
  xpc_object_t v12 = 0;
  xpc_object_t v11 = v18;
  *a2 = v18;
  if (v11) {
    xpc_retain(v11);
  }
  else {
    *a2 = xpc_null_create();
  }
  xpc_release(v18);
}

void sub_1004EBBBC(_Unwind_Exception *a1)
{
  xpc_release(*(xpc_object_t *)(v1 - 40));
  _Unwind_Resume(a1);
}

void *sub_1004EBBD4(void *result, void *a2)
{
  if (a2 != result)
  {
    uint64_t v3 = result;
    xpc_object_t v4 = (void *)result[3];
    xpc_object_t v5 = (void *)a2[3];
    if (v4 == result)
    {
      if (v5 == a2)
      {
        memset(v6, 0, sizeof(v6));
        (*(void (**)(void *, void *))(*result + 24))(result, v6);
        (*(void (**)(void))(*(void *)v3[3] + 32))(v3[3]);
        v3[3] = 0;
        (*(void (**)(void, void *))(*(void *)a2[3] + 24))(a2[3], v3);
        (*(void (**)(void))(*(void *)a2[3] + 32))(a2[3]);
        a2[3] = 0;
        v3[3] = v3;
        (*(void (**)(void *, void *))(v6[0] + 24))(v6, a2);
        CFDictionaryRef result = (void *)(*(uint64_t (**)(void *))(v6[0] + 32))(v6);
      }
      else
      {
        (*(void (**)(void *, void *))(*result + 24))(result, a2);
        CFDictionaryRef result = (void *)(*(uint64_t (**)(void))(*(void *)v3[3] + 32))(v3[3]);
        v3[3] = a2[3];
      }
      a2[3] = a2;
    }
    else if (v5 == a2)
    {
      (*(void (**)(void *, void *))(*a2 + 24))(a2, result);
      CFDictionaryRef result = (void *)(*(uint64_t (**)(void))(*(void *)a2[3] + 32))(a2[3]);
      a2[3] = v3[3];
      v3[3] = v3;
    }
    else
    {
      result[3] = v5;
      a2[3] = v4;
    }
  }
  return result;
}

void sub_1004EBE3C(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_10006A6AC(a1);
}

void sub_1004EBE4C()
{
}

__n128 sub_1004EBE60(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_1019DAE60;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_1004EBEB4(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019DAE60;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_1004EBEEC(void *a1, xpc_object_t *a2)
{
  uint64_t v3 = (void *)a1[1];
  xpc_object_t v4 = v3 + 1;
  xpc_object_t v5 = (void *)v3[1];
  xpc_object_t v9 = (void **)*v3;
  xpc_object_t v10 = v5;
  if (v3[2])
  {
    v5[2] = &v10;
    *uint64_t v3 = v4;
    void *v4 = 0;
    v3[2] = 0;
  }
  else
  {
    xpc_object_t v9 = &v10;
  }
  sub_1001FFE94((uint64_t)v3, a2);
  xpc_object_t v6 = (void (*)(void *, void ***))a1[3];
  uint64_t v7 = a1[4];
  uint64_t v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    xpc_object_t v6 = *(void (**)(void *, void ***))(*v8 + v6);
  }
  v6(v8, &v9);
  sub_1001F7124((uint64_t)&v9, v10);
}

void sub_1004EBFAC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11)
{
}

uint64_t sub_1004EBFC4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1004EC004()
{
}

void sub_1004EC014()
{
}

__n128 sub_1004EC028(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_1019DAEE0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_1004EC07C(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019DAEE0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_1004EC0B4(void *a1, xpc_object_t *a2)
{
  xpc_type_t type = xpc_get_type(*a2);
  if (type == (xpc_type_t)&_xpc_type_string)
  {
    unsigned int v13 = 0;
    ctu::rest::detail::read_enum_string_value((ctu::rest::detail *)&v13, (int *)a2, v5);
    uint64_t v8 = v13;
  }
  else if (type == (xpc_type_t)&_xpc_type_BOOL {
         || type == (xpc_type_t)&_xpc_type_int64
  }
         || type == (xpc_type_t)&_xpc_type_uint64)
  {
    uint64_t v8 = xpc::dyn_cast_or_default((xpc *)a2, 0, (uint64_t)v5);
  }
  else
  {
    uint64_t v8 = 0;
  }
  xpc_object_t v9 = (uint64_t (*)(void *, uint64_t))a1[2];
  uint64_t v10 = a1[3];
  xpc_object_t v11 = (void *)(a1[1] + (v10 >> 1));
  if (v10) {
    xpc_object_t v9 = *(uint64_t (**)(void *, uint64_t))(*v11 + v9);
  }
  return v9(v11, v8);
}

uint64_t sub_1004EC198(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1004EC1D8()
{
}

void sub_1004EC1E4(uint64_t *a1, void *a2, void *a3)
{
  if (a1[2])
  {
    uint64_t v6 = *a1;
    uint64_t v8 = (uint64_t **)(a1 + 1);
    uint64_t v7 = a1[1];
    *a1 = (uint64_t)(a1 + 1);
    *(void *)(v7 + 16) = 0;
    a1[1] = 0;
    a1[2] = 0;
    if (*(void *)(v6 + 8)) {
      xpc_object_t v9 = *(uint64_t **)(v6 + 8);
    }
    else {
      xpc_object_t v9 = (uint64_t *)v6;
    }
    char v21 = a1;
    xpc_object_t v22 = v9;
    xpc_object_t v23 = v9;
    if (v9)
    {
      xpc_object_t v22 = sub_1000EA590((uint64_t)v9);
      if (a2 != a3)
      {
        uint64_t v10 = a2;
        do
        {
          *((_DWORD *)v9 + 8) = *((_DWORD *)v10 + 8);
          sub_1004EC400((uint64_t)(v9 + 5), (uint64_t)(v10 + 5));
          xpc_object_t v11 = *v8;
          xpc_object_t v12 = (uint64_t **)(a1 + 1);
          unsigned int v13 = (uint64_t **)(a1 + 1);
          if (*v8)
          {
            do
            {
              while (1)
              {
                xpc_object_t v12 = (uint64_t **)v11;
                if (*((_DWORD *)v23 + 8) >= *((_DWORD *)v11 + 8)) {
                  break;
                }
                xpc_object_t v11 = (uint64_t *)*v11;
                unsigned int v13 = v12;
                if (!*v12) {
                  goto LABEL_14;
                }
              }
              xpc_object_t v11 = (uint64_t *)v11[1];
            }
            while (v11);
            unsigned int v13 = v12 + 1;
          }
LABEL_14:
          sub_100046C38((uint64_t **)a1, (uint64_t)v12, v13, v23);
          xpc_object_t v9 = v22;
          xpc_object_t v23 = v22;
          if (v22) {
            xpc_object_t v22 = sub_1000EA590((uint64_t)v22);
          }
          xpc_object_t v14 = (void *)v10[1];
          if (v14)
          {
            do
            {
              a2 = v14;
              xpc_object_t v14 = (void *)*v14;
            }
            while (v14);
          }
          else
          {
            do
            {
              a2 = (void *)v10[2];
              BOOL v15 = *a2 == (void)v10;
              uint64_t v10 = a2;
            }
            while (!v15);
          }
          if (!v9) {
            break;
          }
          uint64_t v10 = a2;
        }
        while (a2 != a3);
      }
    }
    sub_1004EC4E0((uint64_t)&v21);
  }
  if (a2 != a3)
  {
    do
    {
      char v21 = 0;
      xpc_object_t v22 = 0;
      xpc_object_t v23 = 0;
      sub_1001FE458((uint64_t)a1, (uint64_t)(a2 + 4), &v21);
      uint64_t v16 = a1[1];
      BOOL v17 = (uint64_t **)(a1 + 1);
      xpc_object_t v18 = (uint64_t **)(a1 + 1);
      if (v16)
      {
        do
        {
          while (1)
          {
            BOOL v17 = (uint64_t **)v16;
            if (*((_DWORD *)v21 + 8) >= *(_DWORD *)(v16 + 32)) {
              break;
            }
            uint64_t v16 = *(void *)v16;
            xpc_object_t v18 = v17;
            if (!*v17) {
              goto LABEL_31;
            }
          }
          uint64_t v16 = *(void *)(v16 + 8);
        }
        while (v16);
        xpc_object_t v18 = v17 + 1;
      }
LABEL_31:
      sub_100046C38((uint64_t **)a1, (uint64_t)v17, v18, v21);
      char v21 = 0;
      sub_1001FE75C((uint64_t)&v21, 0);
      long long v19 = (void *)a2[1];
      if (v19)
      {
        do
        {
          long long v20 = v19;
          long long v19 = (void *)*v19;
        }
        while (v19);
      }
      else
      {
        do
        {
          long long v20 = (void *)a2[2];
          BOOL v15 = *v20 == (void)a2;
          a2 = v20;
        }
        while (!v15);
      }
      a2 = v20;
    }
    while (v20 != a3);
  }
}

void sub_1004EC3EC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1004EC4E0((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1004EC400(uint64_t a1, uint64_t a2)
{
  std::string::operator=((std::string *)a1, (const std::string *)a2);
  std::string::operator=((std::string *)(a1 + 24), (const std::string *)(a2 + 24));
  std::string::operator=((std::string *)(a1 + 48), (const std::string *)(a2 + 48));
  std::string::operator=((std::string *)(a1 + 72), (const std::string *)(a2 + 72));
  std::string::operator=((std::string *)(a1 + 96), (const std::string *)(a2 + 96));
  if (a1 != a2)
  {
    sub_10005CA3C(a1 + 120, *(std::string **)(a2 + 120), *(long long **)(a2 + 128), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a2 + 128) - *(void *)(a2 + 120)) >> 3));
    sub_10005CA3C(a1 + 144, *(std::string **)(a2 + 144), *(long long **)(a2 + 152), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a2 + 152) - *(void *)(a2 + 144)) >> 3));
  }
  long long v4 = *(_OWORD *)(a2 + 168);
  *(_OWORD *)(a1 + 184) = *(_OWORD *)(a2 + 184);
  *(_OWORD *)(a1 + 168) = v4;
  long long v5 = *(_OWORD *)(a2 + 200);
  long long v6 = *(_OWORD *)(a2 + 216);
  long long v7 = *(_OWORD *)(a2 + 232);
  *(void *)(a1 + 248) = *(void *)(a2 + 248);
  *(_OWORD *)(a1 + 232) = v7;
  *(_OWORD *)(a1 + 216) = v6;
  *(_OWORD *)(a1 + 200) = v5;
  std::string::operator=((std::string *)(a1 + 256), (const std::string *)(a2 + 256));
  return a1;
}

uint64_t sub_1004EC4E0(uint64_t a1)
{
  sub_1001F701C(*(void *)a1, *(void **)(a1 + 16));
  uint64_t v2 = *(void **)(a1 + 8);
  if (v2)
  {
    uint64_t v3 = (void *)v2[2];
    if (v3)
    {
      do
      {
        uint64_t v2 = v3;
        uint64_t v3 = (void *)v3[2];
      }
      while (v3);
      *(void *)(a1 + 8) = v2;
    }
    sub_1001F701C(*(void *)a1, v2);
  }
  return a1;
}

void sub_1004EC538(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1019DAF60;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1004EC558(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1019DAF60;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void *sub_1004EC5AC(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 264);
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 248);
  if (v3) {
    sub_10004D2C8(v3);
  }
  sub_1004EC6A0(a1 + 216, *(void **)(a1 + 224));
  long long v4 = *(std::__shared_weak_count **)(a1 + 208);
  if (v4) {
    sub_10004D2C8(v4);
  }
  long long v5 = *(std::__shared_weak_count **)(a1 + 192);
  if (v5) {
    sub_10004D2C8(v5);
  }
  if (*(char *)(a1 + 175) < 0) {
    operator delete(*(void **)(a1 + 152));
  }
  if (*(char *)(a1 + 151) < 0) {
    operator delete(*(void **)(a1 + 128));
  }
  long long v6 = *(std::__shared_weak_count **)(a1 + 112);
  if (v6) {
    std::__shared_weak_count::__release_weak(v6);
  }
  long long v7 = *(std::__shared_weak_count **)(a1 + 96);
  if (v7) {
    sub_10004D2C8(v7);
  }
  uint64_t v8 = *(std::__shared_weak_count **)(a1 + 80);
  if (v8) {
    sub_10004D2C8(v8);
  }
  uint64_t v9 = *(void *)(a1 + 64);
  *(void *)(a1 + 64) = 0;
  if (v9) {
    (*(void (**)(uint64_t))(*(void *)v9 + 8))(v9);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 56));

  return sub_100087E88((void *)(a1 + 24));
}

void sub_1004EC6A0(uint64_t a1, void *a2)
{
  if (a2)
  {
    sub_1004EC6A0(a1, *a2);
    sub_1004EC6A0(a1, a2[1]);
    sub_1001FEC1C((uint64_t)(a2 + 4));
    operator delete(a2);
  }
}

uint64_t *sub_1004EC6FC(unsigned int **a1)
{
  uint64_t v1 = *a1;
  unsigned int v13 = a1;
  xpc_object_t v14 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v3 = *(NSObject **)(*(void *)v1 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Reset config received...", buf, 2u);
  }
  sub_100562274((Registry **)(v2 + 80), (uint64_t)__p);
  *(_OWORD *)std::string buf = *(_OWORD *)__p;
  uint64_t v16 = __p[2];
  memset(__p, 0, sizeof(__p));
  ctu::path_join_impl();
  ctu::path_join_impl();
  if (SHIBYTE(__p[2]) < 0) {
    operator delete(__p[0]);
  }
  if ((*(unsigned int (**)(void, uint8_t *))(**(void **)(v2 + 96) + 88))(*(void *)(v2 + 96), buf))
  {
    long long v4 = (void *)(*(uint64_t (**)(void, uint8_t *))(**(void **)(v2 + 96) + 112))(*(void *)(v2 + 96), buf);
    long long v5 = *(NSObject **)(v2 + 40);
    if (!os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_15;
    }
    long long v6 = buf;
    if (SHIBYTE(v16) < 0) {
      long long v6 = *(uint8_t **)buf;
    }
    LODWORD(__p[0]) = 136446466;
    *(void **)((char *)__p + 4) = v6;
    WORD2(__p[1]) = 2048;
    *(void **)((char *)&__p[1] + 6) = v4;
    long long v7 = "#I Folder erasure status: %{public}s -> %ld";
    uint64_t v8 = v5;
    uint32_t v9 = 22;
  }
  else
  {
    uint64_t v10 = *(NSObject **)(v2 + 40);
    if (!os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_15;
    }
    xpc_object_t v11 = buf;
    if (SHIBYTE(v16) < 0) {
      xpc_object_t v11 = *(uint8_t **)buf;
    }
    LODWORD(__p[0]) = 136446210;
    *(void **)((char *)__p + 4) = v11;
    long long v7 = "#I Folder not found: %{public}s";
    uint64_t v8 = v10;
    uint32_t v9 = 12;
  }
  _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, v7, (uint8_t *)__p, v9);
LABEL_15:
  sub_1004E3F04(v2, v1[8]);
  (*(void (**)(uint64_t, void))(*(void *)v2 + 160))(v2, v1[8]);
  if (SHIBYTE(v16) < 0) {
    operator delete(*(void **)buf);
  }
  sub_1000E890C((uint64_t *)&v14);
  return sub_100046B58((uint64_t *)&v13);
}

void sub_1004EC984(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  sub_1000E890C(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t sub_1004EC9E0(uint64_t a1)
{
  if (*(unsigned char *)a1)
  {
    uint64_t v2 = *(void **)(a1 + 8);
    if (v2[6] == *(void *)(a1 + 32))
    {
      uint64_t v3 = (void *)v2[4];
      if (v3 == v2 + 5) {
        goto LABEL_24;
      }
      long long v4 = *(void **)(a1 + 16);
      while (*((_DWORD *)v3 + 8) == *((_DWORD *)v4 + 8) && sub_1007AD264((uint64_t)(v3 + 5), (uint64_t)(v4 + 5)))
      {
        long long v5 = (void *)v3[1];
        long long v6 = v3;
        if (v5)
        {
          do
          {
            uint64_t v3 = v5;
            long long v5 = (void *)*v5;
          }
          while (v5);
        }
        else
        {
          do
          {
            uint64_t v3 = (void *)v6[2];
            BOOL v7 = *v3 == (void)v6;
            long long v6 = v3;
          }
          while (!v7);
        }
        uint64_t v8 = (void *)v4[1];
        if (v8)
        {
          do
          {
            uint32_t v9 = v8;
            uint64_t v8 = (void *)*v8;
          }
          while (v8);
        }
        else
        {
          do
          {
            uint32_t v9 = (void *)v4[2];
            BOOL v7 = *v9 == (void)v4;
            long long v4 = v9;
          }
          while (!v7);
        }
        long long v4 = v9;
        if (v3 == v2 + 5) {
          goto LABEL_24;
        }
      }
    }
    uint64_t v10 = v2 + 5;
    sub_1000346F8((uint64_t)(v2 + 4), (void *)v2[5]);
    v2[4] = *(void *)(a1 + 16);
    xpc_object_t v11 = (void *)(a1 + 24);
    uint64_t v12 = *(void *)(a1 + 24);
    v2[5] = v12;
    uint64_t v13 = *(void *)(a1 + 32);
    v2[6] = v13;
    if (v13)
    {
      *(void *)(v12 + 16) = v10;
      *(void *)(a1 + 16) = v11;
      void *v11 = 0;
      *(void *)(a1 + 32) = 0;
    }
    else
    {
      v2[4] = v10;
    }
    uint64_t v14 = v2[3];
    if (v14) {
      (*(void (**)(uint64_t, void *))(*(void *)v14 + 48))(v14, v2 + 4);
    }
  }
LABEL_24:
  sub_1000346F8(a1 + 16, *(void **)(a1 + 24));
  return a1;
}

uint64_t *sub_1004ECB58(uint64_t *a1, uint64_t a2)
{
  a1[2] = 0;
  a1[1] = 0;
  *a1 = (uint64_t)(a1 + 1);
  sub_1001A2454(a1, *(int **)a2, (int *)(a2 + 8));
  return a1;
}

void sub_1004ECB98(_Unwind_Exception *a1)
{
  sub_1000346F8(v1, *(void **)(v1 + 8));
  _Unwind_Resume(a1);
}

uint64_t **sub_1004ECBB0(uint64_t **result, void *a2, void *a3)
{
  long long v5 = result;
  if (result[2])
  {
    long long v6 = *result;
    uint64_t v8 = result + 1;
    BOOL v7 = result[1];
    *__n128 result = (uint64_t *)(result + 1);
    v7[2] = 0;
    result[1] = 0;
    result[2] = 0;
    if (v6[1]) {
      uint64_t v9 = v6[1];
    }
    else {
      uint64_t v9 = (uint64_t)v6;
    }
    __int16 v30 = result;
    char v31 = (void *)v9;
    uint64_t v32 = v9;
    if (v9)
    {
      uint64_t v10 = sub_1000EA590(v9);
      char v31 = v10;
      if (a2 != a3)
      {
        xpc_object_t v11 = a2;
        do
        {
          uint64_t v12 = (uint64_t)v10;
          int v13 = *((_DWORD *)v11 + 8);
          *(_DWORD *)(v9 + 32) = v13;
          long long v14 = *(_OWORD *)(v11 + 5);
          long long v15 = *(_OWORD *)(v11 + 7);
          *(_DWORD *)(v9 + 72) = *((_DWORD *)v11 + 18);
          *(_OWORD *)(v9 + 56) = v15;
          *(_OWORD *)(v9 + 40) = v14;
          uint64_t v16 = *v8;
          BOOL v17 = v5 + 1;
          xpc_object_t v18 = v5 + 1;
          if (*v8)
          {
            do
            {
              while (1)
              {
                BOOL v17 = (uint64_t **)v16;
                if (v13 >= *((_DWORD *)v16 + 8)) {
                  break;
                }
                uint64_t v16 = (uint64_t *)*v16;
                xpc_object_t v18 = v17;
                if (!*v17) {
                  goto LABEL_14;
                }
              }
              uint64_t v16 = (uint64_t *)v16[1];
            }
            while (v16);
            xpc_object_t v18 = v17 + 1;
          }
LABEL_14:
          sub_100046C38(v5, (uint64_t)v17, v18, (uint64_t *)v9);
          if (v12) {
            uint64_t v10 = sub_1000EA590(v12);
          }
          else {
            uint64_t v10 = 0;
          }
          long long v19 = (void *)v11[1];
          if (v19)
          {
            do
            {
              a2 = v19;
              long long v19 = (void *)*v19;
            }
            while (v19);
          }
          else
          {
            do
            {
              a2 = (void *)v11[2];
              BOOL v20 = *a2 == (void)v11;
              xpc_object_t v11 = a2;
            }
            while (!v20);
          }
          if (!v12) {
            break;
          }
          uint64_t v9 = v12;
          xpc_object_t v11 = a2;
        }
        while (a2 != a3);
        char v31 = v10;
        uint64_t v32 = v12;
      }
    }
    __n128 result = (uint64_t **)sub_1001A09B4((uint64_t)&v30);
  }
  if (a2 != a3)
  {
    char v21 = v5 + 1;
    do
    {
      xpc_object_t v22 = operator new(0x50uLL);
      long long v24 = *((_OWORD *)a2 + 3);
      long long v23 = *((_OWORD *)a2 + 4);
      v22[2] = *((_OWORD *)a2 + 2);
      v22[3] = v24;
      v22[4] = v23;
      long long v25 = *v21;
      xpc_object_t v26 = v5 + 1;
      uint64_t v27 = v5 + 1;
      if (*v21)
      {
        do
        {
          while (1)
          {
            xpc_object_t v26 = (uint64_t **)v25;
            if (*((_DWORD *)v22 + 8) >= *((_DWORD *)v25 + 8)) {
              break;
            }
            long long v25 = (uint64_t *)*v25;
            uint64_t v27 = v26;
            if (!*v26) {
              goto LABEL_34;
            }
          }
          long long v25 = (uint64_t *)v25[1];
        }
        while (v25);
        uint64_t v27 = v26 + 1;
      }
LABEL_34:
      __n128 result = (uint64_t **)sub_100046C38(v5, (uint64_t)v26, v27, (uint64_t *)v22);
      uint64_t v28 = (void *)a2[1];
      if (v28)
      {
        do
        {
          uint64_t v29 = v28;
          uint64_t v28 = (void *)*v28;
        }
        while (v28);
      }
      else
      {
        do
        {
          uint64_t v29 = (void *)a2[2];
          BOOL v20 = *v29 == (void)a2;
          a2 = v29;
        }
        while (!v20);
      }
      a2 = v29;
    }
    while (v29 != a3);
  }
  return result;
}

uint64_t *sub_1004ECDC4(uint64_t *a1)
{
  uint64_t v1 = *a1;
  char v46 = a1;
  uint64_t v47 = v1;
  uint64_t v2 = *(void *)(v1 + 8);
  if (*(void *)(v1 + 16))
  {
    uint64_t v51 = 1;
    long long v53 = 0u;
    uint64_t v54 = 0;
    uint64_t v52 = v2 + 384;
    uint64_t v3 = sub_1004ECB58((uint64_t *)&v53, v2 + 416);
    long long v4 = *(long long **)(v1 + 16);
    long long v5 = (uint64_t *)&v53 + 1;
    uint64_t v6 = *((void *)&v53 + 1);
    if (!*((void *)&v53 + 1)) {
      goto LABEL_13;
    }
    int v7 = *(_DWORD *)v1;
    uint64_t v8 = (uint64_t *)&v53 + 1;
    do
    {
      uint64_t v9 = (uint64_t *)v6;
      uint64_t v10 = v8;
      int v11 = *(_DWORD *)(v6 + 32);
      if (v11 >= v7) {
        uint64_t v8 = (uint64_t *)v6;
      }
      else {
        v6 += 8;
      }
      uint64_t v6 = *(void *)v6;
    }
    while (v6);
    if (v8 != (uint64_t *)((char *)&v53 + 8)
      && (v11 >= v7 ? (v12 = v9) : (v12 = v10), long long v5 = v8, v7 >= *((_DWORD *)v12 + 8)))
    {
      uint64_t v38 = v10 + 5;
      int v39 = v9 + 5;
      if (v11 >= v7) {
        __int16 v40 = v39;
      }
      else {
        __int16 v40 = v38;
      }
      long long v41 = *v4;
      long long v42 = v4[1];
      *((_DWORD *)v40 + 8) = *((_DWORD *)v4 + 8);
      *(_OWORD *)__int16 v40 = v41;
      *((_OWORD *)v40 + 1) = v42;
    }
    else
    {
LABEL_13:
      uint64_t v48 = 0;
      uint64_t v55 = 0;
      int v13 = sub_1000262C0(v3, v5, &v48, &v55, (int *)v1);
      if (!*v13)
      {
        long long v14 = (char *)operator new(0x50uLL);
        *((_DWORD *)v14 + 8) = *(_DWORD *)v1;
        long long v15 = *v4;
        long long v16 = v4[1];
        *((void *)v14 + 9) = *((void *)v4 + 4);
        *(_OWORD *)(v14 + 56) = v16;
        *(_OWORD *)(v14 + 40) = v15;
        BOOL v17 = v48;
        *(void *)long long v14 = 0;
        *((void *)v14 + 1) = 0;
        *((void *)v14 + 2) = v17;
        uint64_t *v13 = (uint64_t)v14;
        if (*(void *)v53)
        {
          *(void *)&long long v53 = *(void *)v53;
          long long v14 = (char *)*v13;
        }
        sub_100046C90(*((uint64_t **)&v53 + 1), (uint64_t *)v14);
        ++v54;
      }
    }
LABEL_54:
    sub_1004EC9E0((uint64_t)&v51);
    goto LABEL_55;
  }
  uint64_t v18 = *(void *)(v2 + 424);
  if (v18)
  {
    uint64_t v19 = v2 + 384;
    uint64_t v20 = v2 + 416;
    uint64_t v21 = v2 + 424;
    int v22 = *(_DWORD *)v1;
    uint64_t v23 = v21;
    do
    {
      int v24 = *(_DWORD *)(v18 + 32);
      BOOL v25 = v24 < v22;
      if (v24 >= v22) {
        xpc_object_t v26 = (uint64_t *)v18;
      }
      else {
        xpc_object_t v26 = (uint64_t *)(v18 + 8);
      }
      if (!v25) {
        uint64_t v23 = v18;
      }
      uint64_t v18 = *v26;
    }
    while (*v26);
    if (v23 != v21 && v22 >= *(_DWORD *)(v23 + 32))
    {
      uint64_t v51 = 1;
      long long v53 = 0u;
      uint64_t v54 = 0;
      uint64_t v52 = v19;
      sub_1004ECB58((uint64_t *)&v53, v20);
      uint64_t v48 = 0;
      OsLogContext v49 = 0;
      uint64_t v50 = 0;
      sub_1004ECB58((uint64_t *)&v48, v20);
      if (v49)
      {
        int v27 = *(_DWORD *)v1;
        uint64_t v28 = (uint64_t *)&v49;
        uint64_t v29 = v49;
        do
        {
          __int16 v30 = v29;
          char v31 = v28;
          int v32 = *((_DWORD *)v29 + 8);
          int v33 = v29 + 1;
          if (v32 >= v27) {
            uint64_t v28 = v29;
          }
          else {
            ++v29;
          }
          uint64_t v29 = (uint64_t *)*v29;
        }
        while (v29);
        if (v28 != (uint64_t *)&v49)
        {
          if (v32 < v27) {
            __int16 v30 = v31;
          }
          if (*((_DWORD *)v30 + 8) <= v27)
          {
            __int16 v34 = (uint64_t **)(v31 + 1);
            if (v32 >= v27) {
              __int16 v35 = (uint64_t **)v33;
            }
            else {
              __int16 v35 = v34;
            }
            uint64_t v36 = *v35;
            if (*v35)
            {
              do
              {
                __int16 v37 = v36;
                uint64_t v36 = (uint64_t *)*v36;
              }
              while (v36);
            }
            else
            {
              long long v43 = v28;
              do
              {
                __int16 v37 = (uint64_t *)v43[2];
                BOOL v44 = *v37 == (void)v43;
                long long v43 = v37;
              }
              while (!v44);
            }
            if (v48 == v28) {
              uint64_t v48 = v37;
            }
            --v50;
            sub_10005EE6C(v49, v28);
            operator delete(v28);
          }
        }
      }
      sub_1004ECBB0((uint64_t **)&v53, v48, &v49);
      sub_1000346F8((uint64_t)&v48, v49);
      goto LABEL_54;
    }
  }
LABEL_55:
  sub_1004ED0FC(&v47);
  return sub_100046B58((uint64_t *)&v46);
}

void sub_1004ED0B8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va3, a2);
  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, void);
  va_copy(va2, va1);
  uint64_t v5 = va_arg(va2, void);
  va_copy(va3, va2);
  uint64_t v7 = va_arg(va3, void);
  uint64_t v9 = va_arg(va3, void *);
  uint64_t v10 = va_arg(va3, void);
  sub_1000346F8((uint64_t)va2, v9);
  sub_1004EC9E0((uint64_t)va3);
  sub_1004ED0FC((uint64_t *)va1);
  sub_100046B58((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t *sub_1004ED0FC(uint64_t *result)
{
  uint64_t v1 = *result;
  *__n128 result = 0;
  if (v1)
  {
    uint64_t v2 = *(std::__shared_weak_count **)(v1 + 24);
    if (v2) {
      sub_10004D2C8(v2);
    }
    operator delete();
  }
  return result;
}

void sub_1004ED150(unsigned int **a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = *((void *)*a1 + 1);
  uint64_t v3 = (*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), **a1);
  long long v4 = *(void **)(v2 + 112);
  if (v4 != (void *)(v2 + 120))
  {
    uint64_t v5 = (os_log_t *)v3;
    do
    {
      int v6 = *(_DWORD *)(v4[7] + 96);
      if (v6 == *v1)
      {
        uint64_t v7 = *v5;
        if (os_log_type_enabled(*v5, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v8 = "success";
          if (!*((unsigned char *)v1 + 16)) {
            uint64_t v8 = "failed";
          }
          *(_DWORD *)std::string buf = 136315138;
          BOOL v17 = v8;
          _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Last access response: %s", buf, 0xCu);
          int v6 = *v1;
        }
        uint64_t v9 = sub_100256E84((uint64_t **)(v2 + 160), v6, v1);
        uint64_t v10 = (std::__shared_weak_count *)v9[6];
        v9[5] = 0;
        v9[6] = 0;
        if (v10) {
          sub_10004D2C8(v10);
        }
      }
      int v11 = (void *)v4[1];
      if (v11)
      {
        do
        {
          uint64_t v12 = v11;
          int v11 = (void *)*v11;
        }
        while (v11);
      }
      else
      {
        do
        {
          uint64_t v12 = (void *)v4[2];
          BOOL v13 = *v12 == (void)v4;
          long long v4 = v12;
        }
        while (!v13);
      }
      long long v4 = v12;
    }
    while (v12 != (void *)(v2 + 120));
  }
  sub_1004E3F04(v2, *v1);
  long long v14 = sub_1002C74D0((uint64_t **)(v2 + 136), *v1, v1);
  long long v15 = v14[5];
  v14[5] = 0;
  if (v15)
  {
    dispatch_group_leave(v15);
    dispatch_release(v15);
  }
  operator delete();
}

void sub_1004ED350()
{
}

uint64_t sub_1004ED380(uint64_t a1)
{
  if (*(unsigned char *)a1)
  {
    uint64_t v2 = *(void **)(a1 + 8);
    if (v2[6] == *(void *)(a1 + 32))
    {
      uint64_t v3 = (void *)v2[4];
      if (v3 == v2 + 5) {
        goto LABEL_24;
      }
      long long v4 = *(void **)(a1 + 16);
      while (*((_DWORD *)v3 + 8) == *((_DWORD *)v4 + 8)
           && sub_1007AD098((unsigned __int8 *)v3 + 40, (unsigned __int8 *)v4 + 40))
      {
        uint64_t v5 = (void *)v3[1];
        int v6 = v3;
        if (v5)
        {
          do
          {
            uint64_t v3 = v5;
            uint64_t v5 = (void *)*v5;
          }
          while (v5);
        }
        else
        {
          do
          {
            uint64_t v3 = (void *)v6[2];
            BOOL v7 = *v3 == (void)v6;
            int v6 = v3;
          }
          while (!v7);
        }
        uint64_t v8 = (void *)v4[1];
        if (v8)
        {
          do
          {
            uint64_t v9 = v8;
            uint64_t v8 = (void *)*v8;
          }
          while (v8);
        }
        else
        {
          do
          {
            uint64_t v9 = (void *)v4[2];
            BOOL v7 = *v9 == (void)v4;
            long long v4 = v9;
          }
          while (!v7);
        }
        long long v4 = v9;
        if (v3 == v2 + 5) {
          goto LABEL_24;
        }
      }
    }
    uint64_t v10 = v2 + 5;
    sub_1001F6F58((uint64_t)(v2 + 4), (void *)v2[5]);
    v2[4] = *(void *)(a1 + 16);
    int v11 = (void *)(a1 + 24);
    uint64_t v12 = *(void *)(a1 + 24);
    v2[5] = v12;
    uint64_t v13 = *(void *)(a1 + 32);
    v2[6] = v13;
    if (v13)
    {
      *(void *)(v12 + 16) = v10;
      *(void *)(a1 + 16) = v11;
      void *v11 = 0;
      *(void *)(a1 + 32) = 0;
    }
    else
    {
      v2[4] = v10;
    }
    uint64_t v14 = v2[3];
    if (v14) {
      (*(void (**)(uint64_t, void *))(*(void *)v14 + 48))(v14, v2 + 4);
    }
  }
LABEL_24:
  sub_1001F6F58(a1 + 16, *(void **)(a1 + 24));
  return a1;
}

void sub_1004ED4FC(uint64_t *a1, void *a2, void *a3)
{
  if (a1[2])
  {
    uint64_t v6 = *a1;
    uint64_t v8 = (uint64_t **)(a1 + 1);
    uint64_t v7 = a1[1];
    *a1 = (uint64_t)(a1 + 1);
    *(void *)(v7 + 16) = 0;
    a1[1] = 0;
    a1[2] = 0;
    if (*(void *)(v6 + 8)) {
      uint64_t v9 = *(uint64_t **)(v6 + 8);
    }
    else {
      uint64_t v9 = (uint64_t *)v6;
    }
    int v22 = a1;
    uint64_t v23 = v9;
    int v24 = v9;
    if (v9)
    {
      uint64_t v23 = sub_1000EA590((uint64_t)v9);
      if (a2 != a3)
      {
        uint64_t v10 = a2;
        do
        {
          *((_DWORD *)v9 + 8) = *((_DWORD *)v10 + 8);
          std::string::operator=((std::string *)(v9 + 5), (const std::string *)(v10 + 5));
          std::string::operator=((std::string *)(v9 + 8), (const std::string *)(v10 + 8));
          std::string::operator=((std::string *)(v9 + 11), (const std::string *)(v10 + 11));
          uint64_t v11 = v10[14];
          *((_WORD *)v9 + 60) = *((_WORD *)v10 + 60);
          v9[14] = v11;
          uint64_t v12 = *v8;
          uint64_t v13 = (uint64_t **)(a1 + 1);
          uint64_t v14 = (uint64_t **)(a1 + 1);
          if (*v8)
          {
            do
            {
              while (1)
              {
                uint64_t v13 = (uint64_t **)v12;
                if (*((_DWORD *)v24 + 8) >= *((_DWORD *)v12 + 8)) {
                  break;
                }
                uint64_t v12 = (uint64_t *)*v12;
                uint64_t v14 = v13;
                if (!*v13) {
                  goto LABEL_14;
                }
              }
              uint64_t v12 = (uint64_t *)v12[1];
            }
            while (v12);
            uint64_t v14 = v13 + 1;
          }
LABEL_14:
          sub_100046C38((uint64_t **)a1, (uint64_t)v13, v14, v24);
          uint64_t v9 = v23;
          int v24 = v23;
          if (v23) {
            uint64_t v23 = sub_1000EA590((uint64_t)v23);
          }
          long long v15 = (void *)v10[1];
          if (v15)
          {
            do
            {
              a2 = v15;
              long long v15 = (void *)*v15;
            }
            while (v15);
          }
          else
          {
            do
            {
              a2 = (void *)v10[2];
              BOOL v16 = *a2 == (void)v10;
              uint64_t v10 = a2;
            }
            while (!v16);
          }
          if (!v9) {
            break;
          }
          uint64_t v10 = a2;
        }
        while (a2 != a3);
      }
    }
    sub_1004ED740((uint64_t)&v22);
  }
  if (a2 != a3)
  {
    do
    {
      int v22 = 0;
      uint64_t v23 = 0;
      int v24 = 0;
      sub_1001FE93C((uint64_t)a1, (uint64_t)(a2 + 4), &v22);
      uint64_t v17 = a1[1];
      uint64_t v18 = (uint64_t **)(a1 + 1);
      uint64_t v19 = (uint64_t **)(a1 + 1);
      if (v17)
      {
        do
        {
          while (1)
          {
            uint64_t v18 = (uint64_t **)v17;
            if (*((_DWORD *)v22 + 8) >= *(_DWORD *)(v17 + 32)) {
              break;
            }
            uint64_t v17 = *(void *)v17;
            uint64_t v19 = v18;
            if (!*v18) {
              goto LABEL_31;
            }
          }
          uint64_t v17 = *(void *)(v17 + 8);
        }
        while (v17);
        uint64_t v19 = v18 + 1;
      }
LABEL_31:
      sub_100046C38((uint64_t **)a1, (uint64_t)v18, v19, v22);
      int v22 = 0;
      sub_1001FEAB8((uint64_t)&v22, 0);
      uint64_t v20 = (void *)a2[1];
      if (v20)
      {
        do
        {
          uint64_t v21 = v20;
          uint64_t v20 = (void *)*v20;
        }
        while (v20);
      }
      else
      {
        do
        {
          uint64_t v21 = (void *)a2[2];
          BOOL v16 = *v21 == (void)a2;
          a2 = v21;
        }
        while (!v16);
      }
      a2 = v21;
    }
    while (v21 != a3);
  }
}

void sub_1004ED72C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1004ED740((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1004ED740(uint64_t a1)
{
  sub_1001F6F58(*(void *)a1, *(void **)(a1 + 16));
  uint64_t v2 = *(void **)(a1 + 8);
  if (v2)
  {
    uint64_t v3 = (void *)v2[2];
    if (v3)
    {
      do
      {
        uint64_t v2 = v3;
        uint64_t v3 = (void *)v3[2];
      }
      while (v3);
      *(void *)(a1 + 8) = v2;
    }
    sub_1001F6F58(*(void *)a1, v2);
  }
  return a1;
}

uint64_t *sub_1004ED798(unsigned int **a1)
{
  uint64_t v1 = *a1;
  uint64_t v57 = a1;
  uint64_t v58 = v1;
  uint64_t v2 = *((void *)v1 + 1);
  uint64_t v3 = (os_log_t *)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), *v1);
  long long v4 = v3;
  uint64_t v5 = *(uint64_t **)(v2 + 312);
  if (!v5) {
    goto LABEL_89;
  }
  int v6 = *v1;
  uint64_t v7 = v2 + 312;
  uint64_t v8 = *(void *)(v2 + 312);
  do
  {
    int v9 = *(_DWORD *)(v8 + 32);
    BOOL v10 = v9 < v6;
    if (v9 >= v6) {
      uint64_t v11 = (uint64_t *)v8;
    }
    else {
      uint64_t v11 = (uint64_t *)(v8 + 8);
    }
    if (!v10) {
      uint64_t v7 = v8;
    }
    uint64_t v8 = *v11;
  }
  while (*v11);
  if (v7 != v2 + 312 && v6 >= *(_DWORD *)(v7 + 32))
  {
    uint64_t v28 = (unsigned __int8 *)*((void *)v1 + 2);
    if (!v28)
    {
      __int16 v35 = *v3;
      if (os_log_type_enabled(*v3, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_DEFAULT, "#I Erasing chatbot information...", buf, 2u);
      }
      *(void *)std::string buf = 1;
      long long v60 = 0u;
      uint64_t v61 = 0;
      *(void *)&uint8_t buf[8] = v2 + 272;
      sub_1001FE7B4((uint64_t *)&v60, v2 + 304);
      uint64_t v62 = 0;
      uint64_t v63 = 0;
      uint64_t v64 = 0;
      sub_1001FE7B4((uint64_t *)&v62, v2 + 304);
      if (v63)
      {
        int v36 = *v1;
        __int16 v37 = &v63;
        uint64_t v38 = v63;
        do
        {
          int v39 = v38;
          __int16 v40 = v37;
          int v41 = *((_DWORD *)v38 + 8);
          long long v42 = v38 + 1;
          if (v41 >= v36) {
            __int16 v37 = (uint64_t **)v38;
          }
          else {
            ++v38;
          }
          uint64_t v38 = (uint64_t *)*v38;
        }
        while (v38);
        if (v37 != &v63)
        {
          if (v41 >= v36)
          {
            uint64_t v43 = (uint64_t)(v39 + 4);
          }
          else
          {
            int v39 = (uint64_t *)v40;
            uint64_t v43 = (uint64_t)(v40 + 4);
          }
          if (*((_DWORD *)v39 + 8) <= v36)
          {
            BOOL v44 = (uint64_t *)(v40 + 1);
            if (v41 >= v36) {
              int v45 = v42;
            }
            else {
              int v45 = v44;
            }
            char v46 = (uint64_t *)*v45;
            if (*v45)
            {
              do
              {
                uint64_t v47 = (uint64_t **)v46;
                char v46 = (uint64_t *)*v46;
              }
              while (v46);
            }
            else
            {
              uint64_t v54 = v37;
              do
              {
                uint64_t v47 = (uint64_t **)v54[2];
                BOOL v55 = *v47 == (uint64_t *)v54;
                uint64_t v54 = v47;
              }
              while (!v55);
            }
            if (v62 == (uint64_t *)v37) {
              uint64_t v62 = (uint64_t *)v47;
            }
            --v64;
            sub_10005EE6C(v63, (uint64_t *)v37);
            sub_1001F6FB4(v43);
            operator delete(v37);
          }
        }
      }
      sub_1004ED4FC((uint64_t *)&v60, v62, &v63);
      sub_1001F6F58((uint64_t)&v62, v63);
      goto LABEL_85;
    }
    while (1)
    {
      while (1)
      {
        int v29 = *((_DWORD *)v5 + 8);
        if (v29 <= v6) {
          break;
        }
        uint64_t v5 = (uint64_t *)*v5;
        if (!v5) {
          goto LABEL_34;
        }
      }
      if (v29 >= v6) {
        break;
      }
      uint64_t v5 = (uint64_t *)v5[1];
      if (!v5) {
LABEL_34:
      }
        sub_1000C14F0("map::at:  key not found");
    }
    if (!sub_1007AD098((unsigned __int8 *)v5 + 40, v28))
    {
LABEL_12:
      uint64_t v12 = *v4;
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I Publishing chatbot information...", buf, 2u);
      }
      *(void *)std::string buf = 1;
      long long v60 = 0u;
      uint64_t v61 = 0;
      *(void *)&uint8_t buf[8] = v2 + 272;
      uint64_t v13 = sub_1001FE7B4((uint64_t *)&v60, v2 + 304);
      uint64_t v14 = (const std::string *)*((void *)v1 + 2);
      uint64_t v15 = *((void *)&v60 + 1);
      BOOL v16 = (uint64_t *)&v60 + 1;
      if (!*((void *)&v60 + 1)) {
        goto LABEL_25;
      }
      int v17 = *v1;
      uint64_t v18 = (uint64_t *)&v60 + 1;
      do
      {
        uint64_t v19 = v15;
        uint64_t v20 = v18;
        int v21 = *(_DWORD *)(v15 + 32);
        if (v21 >= v17) {
          uint64_t v18 = (uint64_t *)v15;
        }
        else {
          v15 += 8;
        }
        uint64_t v15 = *(void *)v15;
      }
      while (v15);
      BOOL v16 = (uint64_t *)&v60 + 1;
      if (v18 != (uint64_t *)((char *)&v60 + 8)
        && (v21 >= v17 ? (v22 = (uint64_t *)v19) : (v22 = v20), BOOL v16 = v18, v17 >= *((_DWORD *)v22 + 8)))
      {
        if (v21 >= v17) {
          __int16 v30 = (std::string *)(v19 + 40);
        }
        else {
          __int16 v30 = (std::string *)(v20 + 5);
        }
        std::string::operator=(v30, *((const std::string **)v1 + 2));
        if (v21 >= v17) {
          char v31 = (std::string *)(v19 + 64);
        }
        else {
          char v31 = (std::string *)(v20 + 8);
        }
        std::string::operator=(v31, v14 + 1);
        if (v21 >= v17) {
          int v32 = (std::string *)(v19 + 88);
        }
        else {
          int v32 = (std::string *)(v20 + 11);
        }
        std::string::operator=(v32, v14 + 2);
        int v33 = v20 + 14;
        uint64_t data = (uint64_t)v14[3].__r_.__value_.__l.__data_;
        if (v21 >= v17) {
          int v33 = (uint64_t *)(v19 + 112);
        }
        *((_WORD *)v33 + 4) = v14[3].__r_.__value_.__r.__words[1];
        *int v33 = data;
      }
      else
      {
LABEL_25:
        uint64_t v66 = 0;
        uint64_t v65 = 0;
        uint64_t v23 = sub_1000262C0(v13, v16, &v66, &v65, (int *)v1);
        if (!*v23)
        {
          int v24 = *v1;
          uint64_t v64 = 0;
          BOOL v25 = (char *)operator new(0x80uLL);
          xpc_object_t v26 = v25;
          uint64_t v62 = (uint64_t *)v25;
          uint64_t v63 = (uint64_t *)&v60 + 1;
          *((_DWORD *)v25 + 8) = v24;
          if (SHIBYTE(v14->__r_.__value_.__r.__words[2]) < 0)
          {
            sub_10004FC84(v25 + 40, v14->__r_.__value_.__l.__data_, v14->__r_.__value_.__l.__size_);
          }
          else
          {
            long long v27 = *(_OWORD *)&v14->__r_.__value_.__l.__data_;
            *((void *)v25 + 7) = *((void *)&v14->__r_.__value_.__l + 2);
            *(_OWORD *)(v25 + 40) = v27;
          }
          if (SHIBYTE(v14[1].__r_.__value_.__r.__words[2]) < 0)
          {
            sub_10004FC84(v26 + 64, v14[1].__r_.__value_.__l.__data_, v14[1].__r_.__value_.__l.__size_);
          }
          else
          {
            long long v48 = *(_OWORD *)&v14[1].__r_.__value_.__l.__data_;
            *((void *)v26 + 10) = *((void *)&v14[1].__r_.__value_.__l + 2);
            *((_OWORD *)v26 + 4) = v48;
          }
          OsLogContext v49 = v26 + 88;
          if (SHIBYTE(v14[2].__r_.__value_.__r.__words[2]) < 0)
          {
            sub_10004FC84(v49, v14[2].__r_.__value_.__l.__data_, v14[2].__r_.__value_.__l.__size_);
          }
          else
          {
            long long v50 = *(_OWORD *)&v14[2].__r_.__value_.__l.__data_;
            *((void *)v26 + 13) = *((void *)&v14[2].__r_.__value_.__l + 2);
            *(_OWORD *)OsLogContext v49 = v50;
          }
          std::string::pointer v51 = v14[3].__r_.__value_.__l.__data_;
          *((_WORD *)v26 + 60) = v14[3].__r_.__value_.__r.__words[1];
          *((void *)v26 + 14) = v51;
          LOBYTE(v64) = 1;
          uint64_t v52 = v66;
          long long v53 = v62;
          *uint64_t v62 = 0;
          v53[1] = 0;
          v53[2] = (uint64_t)v52;
          uint64_t *v23 = (uint64_t)v53;
          if (*(void *)v60)
          {
            *(void *)&long long v60 = *(void *)v60;
            long long v53 = (uint64_t *)*v23;
          }
          sub_100046C90(*((uint64_t **)&v60 + 1), v53);
          ++v61;
          uint64_t v62 = 0;
          sub_1001FEAB8((uint64_t)&v62, 0);
        }
      }
LABEL_85:
      sub_1004ED380((uint64_t)buf);
    }
  }
  else
  {
LABEL_89:
    if (*((void *)v1 + 2)) {
      goto LABEL_12;
    }
  }
  sub_1004ED0FC((uint64_t *)&v58);
  return sub_100046B58((uint64_t *)&v57);
}

void sub_1004EDC98(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16)
{
  if (*(char *)(v16 + 87) < 0) {
    operator delete(*v18);
  }
  if (*(char *)(v16 + 63) < 0) {
    operator delete(*v17);
  }
  sub_1001FEAB8((uint64_t)&a16, 0);
  sub_1004ED380((uint64_t)&a11);
  sub_1004ED0FC(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t sub_1004EDD20(uint64_t a1)
{
  if (*(unsigned char *)a1)
  {
    uint64_t v2 = *(void **)(a1 + 8);
    if (v2[6] == *(void *)(a1 + 32))
    {
      uint64_t v3 = (void *)v2[4];
      if (v3 == v2 + 5) {
        goto LABEL_24;
      }
      long long v4 = *(void **)(a1 + 16);
      while (*((_DWORD *)v3 + 8) == *((_DWORD *)v4 + 8)
           && sub_1007ACBA8((unsigned __int8 *)v3 + 40, (unsigned __int8 *)v4 + 40))
      {
        uint64_t v5 = (void *)v3[1];
        int v6 = v3;
        if (v5)
        {
          do
          {
            uint64_t v3 = v5;
            uint64_t v5 = (void *)*v5;
          }
          while (v5);
        }
        else
        {
          do
          {
            uint64_t v3 = (void *)v6[2];
            BOOL v7 = *v3 == (void)v6;
            int v6 = v3;
          }
          while (!v7);
        }
        uint64_t v8 = (void *)v4[1];
        if (v8)
        {
          do
          {
            int v9 = v8;
            uint64_t v8 = (void *)*v8;
          }
          while (v8);
        }
        else
        {
          do
          {
            int v9 = (void *)v4[2];
            BOOL v7 = *v9 == (void)v4;
            long long v4 = v9;
          }
          while (!v7);
        }
        long long v4 = v9;
        if (v3 == v2 + 5) {
          goto LABEL_24;
        }
      }
    }
    BOOL v10 = v2 + 5;
    sub_1001F701C((uint64_t)(v2 + 4), (void *)v2[5]);
    v2[4] = *(void *)(a1 + 16);
    uint64_t v11 = (void *)(a1 + 24);
    uint64_t v12 = *(void *)(a1 + 24);
    v2[5] = v12;
    uint64_t v13 = *(void *)(a1 + 32);
    v2[6] = v13;
    if (v13)
    {
      *(void *)(v12 + 16) = v10;
      *(void *)(a1 + 16) = v11;
      void *v11 = 0;
      *(void *)(a1 + 32) = 0;
    }
    else
    {
      v2[4] = v10;
    }
    uint64_t v14 = v2[3];
    if (v14) {
      (*(void (**)(uint64_t, void *))(*(void *)v14 + 48))(v14, v2 + 4);
    }
  }
LABEL_24:
  sub_1001F701C(a1 + 16, *(void **)(a1 + 24));
  return a1;
}

uint64_t *sub_1004EDE9C(unsigned int **a1)
{
  uint64_t v1 = *a1;
  OsLogContext v49 = a1;
  long long v50 = v1;
  uint64_t v2 = *((void *)v1 + 1);
  uint64_t v3 = (os_log_t *)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), *v1);
  long long v4 = v3;
  uint64_t v5 = *(uint64_t **)(v2 + 256);
  if (!v5) {
    goto LABEL_75;
  }
  int v6 = *v1;
  uint64_t v7 = v2 + 256;
  uint64_t v8 = *(void *)(v2 + 256);
  do
  {
    int v9 = *(_DWORD *)(v8 + 32);
    BOOL v10 = v9 < v6;
    if (v9 >= v6) {
      uint64_t v11 = (uint64_t *)v8;
    }
    else {
      uint64_t v11 = (uint64_t *)(v8 + 8);
    }
    if (!v10) {
      uint64_t v7 = v8;
    }
    uint64_t v8 = *v11;
  }
  while (*v11);
  if (v7 != v2 + 256 && v6 >= *(_DWORD *)(v7 + 32))
  {
    uint64_t v28 = (unsigned __int8 *)*((void *)v1 + 2);
    if (!v28)
    {
      __int16 v34 = *v3;
      if (os_log_type_enabled(*v3, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "#I Erasing registration information...", buf, 2u);
      }
      *(void *)std::string buf = 1;
      long long v52 = 0u;
      uint64_t v53 = 0;
      *(void *)&uint8_t buf[8] = v2 + 216;
      sub_1001FE2D0((uint64_t *)&v52, v2 + 248);
      uint64_t v54 = 0;
      BOOL v55 = 0;
      uint64_t v56 = 0;
      sub_1001FE2D0((uint64_t *)&v54, v2 + 248);
      if (v55)
      {
        int v35 = *v1;
        int v36 = &v55;
        __int16 v37 = v55;
        do
        {
          uint64_t v38 = v37;
          int v39 = v36;
          int v40 = *((_DWORD *)v37 + 8);
          int v41 = (uint64_t **)(v37 + 1);
          if (v40 >= v35) {
            int v36 = (uint64_t **)v37;
          }
          else {
            ++v37;
          }
          __int16 v37 = (uint64_t *)*v37;
        }
        while (v37);
        if (v36 != &v55)
        {
          long long v42 = v40 >= v35 ? v38 : (uint64_t *)v39;
          if (*((_DWORD *)v42 + 8) <= v35)
          {
            if (v40 < v35) {
              int v41 = v39 + 1;
            }
            uint64_t v43 = *v41;
            if (*v41)
            {
              do
              {
                BOOL v44 = (uint64_t **)v43;
                uint64_t v43 = (uint64_t *)*v43;
              }
              while (v43);
            }
            else
            {
              int v45 = v36;
              do
              {
                BOOL v44 = (uint64_t **)v45[2];
                BOOL v46 = *v44 == (uint64_t *)v45;
                int v45 = v44;
              }
              while (!v46);
            }
            if (v54 == (uint64_t *)v36) {
              uint64_t v54 = (uint64_t *)v44;
            }
            --v56;
            sub_10005EE6C(v55, (uint64_t *)v36);
            if (v40 >= v35) {
              uint64_t v47 = (uint64_t)(v38 + 5);
            }
            else {
              uint64_t v47 = (uint64_t)(v39 + 5);
            }
            sub_1001F7078(v47);
            operator delete(v36);
          }
        }
      }
      sub_1004EC1E4((uint64_t *)&v52, v54, &v55);
      sub_1001F701C((uint64_t)&v54, v55);
      goto LABEL_71;
    }
    while (1)
    {
      while (1)
      {
        int v29 = *((_DWORD *)v5 + 8);
        if (v29 <= v6) {
          break;
        }
        uint64_t v5 = (uint64_t *)*v5;
        if (!v5) {
          goto LABEL_36;
        }
      }
      if (v29 >= v6) {
        break;
      }
      uint64_t v5 = (uint64_t *)v5[1];
      if (!v5) {
LABEL_36:
      }
        sub_1000C14F0("map::at:  key not found");
    }
    char v30 = sub_1007ACBA8((unsigned __int8 *)v5 + 40, v28);
    if ((v30 & 1) == 0)
    {
LABEL_12:
      uint64_t v12 = *v4;
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I Publishing registration information...", buf, 2u);
      }
      *(void *)std::string buf = 1;
      long long v52 = 0u;
      uint64_t v53 = 0;
      *(void *)&uint8_t buf[8] = v2 + 216;
      uint64_t v13 = sub_1001FE2D0((uint64_t *)&v52, v2 + 248);
      uint64_t v14 = (long long *)*((void *)v1 + 2);
      uint64_t v15 = *((void *)&v52 + 1);
      uint64_t v16 = (uint64_t *)&v52 + 1;
      if (!*((void *)&v52 + 1)) {
        goto LABEL_25;
      }
      int v17 = *v1;
      uint64_t v18 = (uint64_t *)&v52 + 1;
      do
      {
        uint64_t v19 = (uint64_t *)v15;
        uint64_t v20 = v18;
        int v21 = *(_DWORD *)(v15 + 32);
        if (v21 >= v17) {
          uint64_t v18 = (uint64_t *)v15;
        }
        else {
          v15 += 8;
        }
        uint64_t v15 = *(void *)v15;
      }
      while (v15);
      uint64_t v16 = (uint64_t *)&v52 + 1;
      if (v18 != (uint64_t *)((char *)&v52 + 8)
        && (v21 >= v17 ? (v22 = v19) : (v22 = v20), uint64_t v16 = v18, v17 >= *((_DWORD *)v22 + 8)))
      {
        uint64_t v31 = (uint64_t)(v20 + 5);
        uint64_t v32 = (uint64_t)(v19 + 5);
        if (v21 >= v17) {
          uint64_t v33 = v32;
        }
        else {
          uint64_t v33 = v31;
        }
        sub_1004EC400(v33, *((void *)v1 + 2));
      }
      else
      {
LABEL_25:
        uint64_t v58 = 0;
        uint64_t v57 = 0;
        uint64_t v23 = sub_1000262C0(v13, v16, &v58, &v57, (int *)v1);
        if (!*v23)
        {
          int v24 = *v1;
          uint64_t v56 = 0;
          BOOL v25 = operator new(0x140uLL);
          uint64_t v54 = (uint64_t *)v25;
          BOOL v55 = (uint64_t *)&v52 + 1;
          *((_DWORD *)v25 + 8) = v24;
          sub_1001FE4D4((char *)v25 + 40, v14);
          LOBYTE(v56) = 1;
          xpc_object_t v26 = v58;
          long long v27 = v54;
          uint64_t *v54 = 0;
          v27[1] = 0;
          _DWORD v27[2] = (uint64_t)v26;
          uint64_t *v23 = (uint64_t)v27;
          if (*(void *)v52)
          {
            *(void *)&long long v52 = *(void *)v52;
            long long v27 = (uint64_t *)*v23;
          }
          sub_100046C90(*((uint64_t **)&v52 + 1), v27);
          ++v53;
          uint64_t v54 = 0;
          sub_1001FE75C((uint64_t)&v54, 0);
        }
      }
LABEL_71:
      sub_1004EDD20((uint64_t)buf);
    }
  }
  else
  {
LABEL_75:
    if (*((void *)v1 + 2)) {
      goto LABEL_12;
    }
  }
  sub_1004ED0FC((uint64_t *)&v50);
  return sub_100046B58((uint64_t *)&v49);
}

void sub_1004EE2C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16, void *a17)
{
}

uint64_t sub_1004EE318(uint64_t a1)
{
  if (*(unsigned char *)a1)
  {
    uint64_t v2 = *(void **)(a1 + 8);
    if (v2[6] == *(void *)(a1 + 32))
    {
      uint64_t v3 = (void *)v2[4];
      if (v3 == v2 + 5) {
        goto LABEL_24;
      }
      long long v4 = *(void **)(a1 + 16);
      while (*((_DWORD *)v3 + 8) == *((_DWORD *)v4 + 8)
           && *((unsigned __int8 *)v4 + 40) == *((unsigned __int8 *)v3 + 40))
      {
        uint64_t v5 = (void *)v3[1];
        int v6 = v3;
        if (v5)
        {
          do
          {
            uint64_t v3 = v5;
            uint64_t v5 = (void *)*v5;
          }
          while (v5);
        }
        else
        {
          do
          {
            uint64_t v3 = (void *)v6[2];
            BOOL v7 = *v3 == (void)v6;
            int v6 = v3;
          }
          while (!v7);
        }
        uint64_t v8 = (void *)v4[1];
        if (v8)
        {
          do
          {
            int v9 = v8;
            uint64_t v8 = (void *)*v8;
          }
          while (v8);
        }
        else
        {
          do
          {
            int v9 = (void *)v4[2];
            BOOL v7 = *v9 == (void)v4;
            long long v4 = v9;
          }
          while (!v7);
        }
        long long v4 = v9;
        if (v3 == v2 + 5) {
          goto LABEL_24;
        }
      }
    }
    BOOL v10 = v2 + 5;
    sub_10021D564((uint64_t)(v2 + 4), (char *)v2[5]);
    v2[4] = *(void *)(a1 + 16);
    uint64_t v11 = (void *)(a1 + 24);
    uint64_t v12 = *(void *)(a1 + 24);
    v2[5] = v12;
    uint64_t v13 = *(void *)(a1 + 32);
    v2[6] = v13;
    if (v13)
    {
      *(void *)(v12 + 16) = v10;
      *(void *)(a1 + 16) = v11;
      void *v11 = 0;
      *(void *)(a1 + 32) = 0;
    }
    else
    {
      v2[4] = v10;
    }
    uint64_t v14 = v2[3];
    if (v14) {
      (*(void (**)(uint64_t, void *))(*(void *)v14 + 48))(v14, v2 + 4);
    }
  }
LABEL_24:
  sub_10021D564(a1 + 16, *(char **)(a1 + 24));
  return a1;
}

uint64_t *sub_1004EE488(uint64_t *a1, uint64_t a2)
{
  a1[2] = 0;
  a1[1] = 0;
  *a1 = (uint64_t)(a1 + 1);
  sub_1004EE4E0(a1, *(int **)a2, (int *)(a2 + 8));
  return a1;
}

void sub_1004EE4C8(_Unwind_Exception *a1)
{
  sub_10021D564(v1, *(char **)(v1 + 8));
  _Unwind_Resume(a1);
}

uint64_t *sub_1004EE4E0(uint64_t *result, int *a2, int *a3)
{
  if (a2 != a3)
  {
    long long v4 = a2;
    uint64_t v5 = (uint64_t **)result;
    int v6 = result + 1;
    do
    {
      __n128 result = sub_10021D378(v5, v6, v4 + 8, (uint64_t)(v4 + 8));
      BOOL v7 = (int *)*((void *)v4 + 1);
      if (v7)
      {
        do
        {
          uint64_t v8 = v7;
          BOOL v7 = *(int **)v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          uint64_t v8 = (int *)*((void *)v4 + 2);
          BOOL v9 = *(void *)v8 == (void)v4;
          long long v4 = v8;
        }
        while (!v9);
      }
      long long v4 = v8;
    }
    while (v8 != a3);
  }
  return result;
}

uint64_t *sub_1004EE56C(uint64_t *result, void *a2, void *a3)
{
  uint64_t v5 = (uint64_t)result;
  if (result[2])
  {
    uint64_t v6 = *result;
    uint64_t v8 = (uint64_t **)(result + 1);
    uint64_t v7 = result[1];
    *__n128 result = (uint64_t)(result + 1);
    *(void *)(v7 + 16) = 0;
    result[1] = 0;
    result[2] = 0;
    if (*(void *)(v6 + 8)) {
      BOOL v9 = *(uint64_t **)(v6 + 8);
    }
    else {
      BOOL v9 = (uint64_t *)v6;
    }
    int v22 = result;
    uint64_t v23 = v9;
    int v24 = v9;
    if (v9)
    {
      uint64_t v23 = sub_1000EA590((uint64_t)v9);
      if (a2 != a3)
      {
        BOOL v10 = a2;
        do
        {
          *((_DWORD *)v9 + 8) = *((_DWORD *)v10 + 8);
          long long v11 = *(_OWORD *)(v10 + 5);
          *(_OWORD *)((char *)v9 + 52) = *(_OWORD *)((char *)v10 + 52);
          *(_OWORD *)(v9 + 5) = v11;
          std::string::operator=((std::string *)v9 + 3, (const std::string *)v10 + 3);
          uint64_t v12 = *v8;
          uint64_t v13 = (uint64_t **)(v5 + 8);
          uint64_t v14 = (uint64_t **)(v5 + 8);
          if (*v8)
          {
            do
            {
              while (1)
              {
                uint64_t v13 = (uint64_t **)v12;
                if (*((_DWORD *)v24 + 8) >= *((_DWORD *)v12 + 8)) {
                  break;
                }
                uint64_t v12 = (uint64_t *)*v12;
                uint64_t v14 = v13;
                if (!*v13) {
                  goto LABEL_14;
                }
              }
              uint64_t v12 = (uint64_t *)v12[1];
            }
            while (v12);
            uint64_t v14 = v13 + 1;
          }
LABEL_14:
          sub_100046C38((uint64_t **)v5, (uint64_t)v13, v14, v24);
          BOOL v9 = v23;
          int v24 = v23;
          if (v23) {
            uint64_t v23 = sub_1000EA590((uint64_t)v23);
          }
          uint64_t v15 = (void *)v10[1];
          if (v15)
          {
            do
            {
              a2 = v15;
              uint64_t v15 = (void *)*v15;
            }
            while (v15);
          }
          else
          {
            do
            {
              a2 = (void *)v10[2];
              BOOL v16 = *a2 == (void)v10;
              BOOL v10 = a2;
            }
            while (!v16);
          }
          if (!v9) {
            break;
          }
          BOOL v10 = a2;
        }
        while (a2 != a3);
      }
    }
    __n128 result = (uint64_t *)sub_1004EE788((uint64_t)&v22);
  }
  if (a2 != a3)
  {
    do
    {
      int v22 = 0;
      uint64_t v23 = 0;
      int v24 = 0;
      sub_10021D408(v5, (uint64_t)(a2 + 4), &v22);
      int v17 = *(uint64_t **)(v5 + 8);
      uint64_t v18 = (uint64_t **)(v5 + 8);
      uint64_t v19 = (uint64_t **)(v5 + 8);
      if (v17)
      {
        do
        {
          while (1)
          {
            uint64_t v18 = (uint64_t **)v17;
            if (*((_DWORD *)v22 + 8) >= *((_DWORD *)v17 + 8)) {
              break;
            }
            int v17 = (uint64_t *)*v17;
            uint64_t v19 = v18;
            if (!*v18) {
              goto LABEL_31;
            }
          }
          int v17 = (uint64_t *)v17[1];
        }
        while (v17);
        uint64_t v19 = v18 + 1;
      }
LABEL_31:
      __n128 result = sub_100046C38((uint64_t **)v5, (uint64_t)v18, v19, v22);
      uint64_t v20 = (void *)a2[1];
      if (v20)
      {
        do
        {
          int v21 = v20;
          uint64_t v20 = (void *)*v20;
        }
        while (v20);
      }
      else
      {
        do
        {
          int v21 = (void *)a2[2];
          BOOL v16 = *v21 == (void)a2;
          a2 = v21;
        }
        while (!v16);
      }
      a2 = v21;
    }
    while (v21 != a3);
  }
  return result;
}

void sub_1004EE774(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1004EE788((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1004EE788(uint64_t a1)
{
  sub_10021D564(*(void *)a1, *(char **)(a1 + 16));
  uint64_t v2 = *(void *)(a1 + 8);
  if (v2)
  {
    uint64_t v3 = *(void *)(v2 + 16);
    if (v3)
    {
      do
      {
        uint64_t v2 = v3;
        uint64_t v3 = *(void *)(v3 + 16);
      }
      while (v3);
      *(void *)(a1 + 8) = v2;
    }
    sub_10021D564(*(void *)a1, (char *)v2);
  }
  return a1;
}

uint64_t *sub_1004EE7E0(unsigned int **a1)
{
  uint64_t v1 = *a1;
  BOOL v9 = a1;
  BOOL v10 = v1;
  uint64_t v2 = *((void *)v1 + 1);
  uint64_t v3 = (NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), *v1);
  v14[0] = 1;
  long long v15 = 0u;
  uint64_t v16 = 0;
  v14[1] = v2 + 328;
  v2 += 360;
  sub_1004EE488((uint64_t *)&v15, v2);
  uint64_t v12 = 0;
  v13[0] = 0;
  v13[1] = 0;
  sub_1004EE488((uint64_t *)&v12, v2);
  DefaultLazuliMessagingInformation = (long long *)*((void *)v1 + 2);
  if (!DefaultLazuliMessagingInformation) {
    DefaultLazuliMessagingInformation = GetDefaultLazuliMessagingInformation();
  }
  uint64_t v5 = sub_1004EE994(&v12, *v1, v1);
  long long v6 = *DefaultLazuliMessagingInformation;
  *(_OWORD *)((char *)v5 + 52) = *(long long *)((char *)DefaultLazuliMessagingInformation + 12);
  *(_OWORD *)(v5 + 5) = v6;
  std::string::operator=((std::string *)v5 + 3, (const std::string *)(DefaultLazuliMessagingInformation + 2));
  uint64_t v7 = *v3;
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Publishing messaging information...", buf, 2u);
  }
  sub_1004EE56C((uint64_t *)&v15, v12, v13);
  sub_10021D564((uint64_t)&v12, v13[0]);
  sub_1004EE318((uint64_t)v14);
  sub_1004ED0FC((uint64_t *)&v10);
  return sub_100046B58((uint64_t *)&v9);
}

void sub_1004EE954(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15)
{
}

uint64_t **sub_1004EE994(uint64_t **a1, int a2, _DWORD *a3)
{
  long long v6 = a1 + 1;
  uint64_t v5 = a1[1];
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        uint64_t v7 = (uint64_t **)v5;
        int v8 = *((_DWORD *)v5 + 8);
        if (v8 <= a2) {
          break;
        }
        uint64_t v5 = *v7;
        long long v6 = v7;
        if (!*v7) {
          goto LABEL_9;
        }
      }
      if (v8 >= a2) {
        break;
      }
      uint64_t v5 = v7[1];
      if (!v5)
      {
        long long v6 = v7 + 1;
        goto LABEL_9;
      }
    }
  }
  else
  {
    uint64_t v7 = a1 + 1;
LABEL_9:
    BOOL v9 = (char *)operator new(0x60uLL);
    *((_DWORD *)v9 + 8) = *a3;
    *(_OWORD *)(v9 + 40) = 0u;
    *(_OWORD *)(v9 + 56) = 0u;
    *(_OWORD *)(v9 + 72) = 0u;
    *((void *)v9 + 11) = 0;
    sub_100046C38(a1, (uint64_t)v7, v6, (uint64_t *)v9);
    return (uint64_t **)v9;
  }
  return v7;
}

uint64_t *sub_1004EEA5C(uint64_t *a1, uint64_t a2)
{
  a1[2] = 0;
  a1[1] = 0;
  *a1 = (uint64_t)(a1 + 1);
  sub_1004EEAB4(a1, *(int **)a2, (int *)(a2 + 8));
  return a1;
}

void sub_1004EEA9C(_Unwind_Exception *a1)
{
  sub_100453C90(v1, *(void **)(v1 + 8));
  _Unwind_Resume(a1);
}

uint64_t *sub_1004EEAB4(uint64_t *result, int *a2, int *a3)
{
  if (a2 != a3)
  {
    long long v4 = a2;
    uint64_t v5 = (uint64_t **)result;
    long long v6 = result + 1;
    do
    {
      __n128 result = sub_1004EEB40(v5, v6, v4 + 8, (uint64_t)(v4 + 8));
      uint64_t v7 = (int *)*((void *)v4 + 1);
      if (v7)
      {
        do
        {
          int v8 = v7;
          uint64_t v7 = *(int **)v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          int v8 = (int *)*((void *)v4 + 2);
          BOOL v9 = *(void *)v8 == (void)v4;
          long long v4 = v8;
        }
        while (!v9);
      }
      long long v4 = v8;
    }
    while (v8 != a3);
  }
  return result;
}

uint64_t *sub_1004EEB40(uint64_t **a1, uint64_t *a2, int *a3, uint64_t a4)
{
  uint64_t v11 = 0;
  uint64_t v12 = 0;
  long long v6 = sub_1000262C0(a1, a2, &v12, &v11, a3);
  uint64_t v7 = (uint64_t *)*v6;
  if (!*v6)
  {
    int v8 = (uint64_t **)v6;
    v10[2] = 1;
    uint64_t v7 = (uint64_t *)operator new(0x30uLL);
    v10[1] = a1 + 1;
    sub_1004EEBF8((uint64_t)(v7 + 4), a4);
    sub_100046C38(a1, (uint64_t)v12, v8, v7);
    v10[0] = 0;
    sub_100455C48((uint64_t)v10, 0);
  }
  return v7;
}

uint64_t sub_1004EEBF8(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)a1 = *(_DWORD *)a2;
  uint64_t v3 = *(void **)(a2 + 8);
  *(void *)(a1 + 8) = v3;
  if (v3) {
    xpc_retain(v3);
  }
  else {
    *(void *)(a1 + 8) = xpc_null_create();
  }
  return a1;
}

uint64_t sub_1004EEC44(uint64_t a1)
{
  if (*(unsigned char *)a1)
  {
    uint64_t v2 = *(void **)(a1 + 8);
    if (v2[6] == *(void *)(a1 + 32))
    {
      uint64_t v3 = (void *)v2[4];
      if (v3 == v2 + 5) {
        goto LABEL_21;
      }
      long long v4 = *(void **)(a1 + 16);
      while (*((_DWORD *)v3 + 8) == *((_DWORD *)v4 + 8) && xpc_equal((xpc_object_t)v3[5], (xpc_object_t)v4[5]))
      {
        uint64_t v5 = (void *)v3[1];
        long long v6 = v3;
        if (v5)
        {
          do
          {
            uint64_t v3 = v5;
            uint64_t v5 = (void *)*v5;
          }
          while (v5);
        }
        else
        {
          do
          {
            uint64_t v3 = (void *)v6[2];
            BOOL v7 = *v3 == (void)v6;
            long long v6 = v3;
          }
          while (!v7);
        }
        int v8 = (void *)v4[1];
        if (v8)
        {
          do
          {
            BOOL v9 = v8;
            int v8 = (void *)*v8;
          }
          while (v8);
        }
        else
        {
          do
          {
            BOOL v9 = (void *)v4[2];
            BOOL v7 = *v9 == (void)v4;
            long long v4 = v9;
          }
          while (!v7);
        }
        long long v4 = v9;
        if (v3 == v2 + 5) {
          goto LABEL_21;
        }
      }
    }
    sub_1004EED8C((uint64_t)(v2 + 4), (void *)(a1 + 16));
    uint64_t v10 = v2[3];
    if (v10) {
      (*(void (**)(uint64_t, void *))(*(void *)v10 + 48))(v10, v2 + 4);
    }
  }
LABEL_21:
  sub_100453C90(a1 + 16, *(void **)(a1 + 24));
  return a1;
}

void sub_1004EED8C(uint64_t a1, void *a2)
{
  long long v4 = (void *)(a1 + 8);
  sub_100453C90(a1, *(void **)(a1 + 8));
  *(void *)a1 = *a2;
  uint64_t v5 = a2 + 1;
  uint64_t v6 = a2[1];
  void *v4 = v6;
  uint64_t v7 = a2[2];
  *(void *)(a1 + 16) = v7;
  if (v7)
  {
    *(void *)(v6 + 16) = v4;
    *a2 = v5;
    void *v5 = 0;
    a2[2] = 0;
  }
  else
  {
    *(void *)a1 = v4;
  }
}

void sub_1004EEDF8(void **this)
{
  *this = &off_1019DAFF0;
  if (*((char *)this + 39) < 0) {
    operator delete(this[2]);
  }
  uint64_t v2 = (uint64_t)this[1];
  this[1] = 0;
  if (v2) {
    sub_100206334((uint64_t)(this + 1), v2);
  }

  PB::Base::~Base((PB::Base *)this);
}

void sub_1004EEE70(void **a1)
{
  sub_1004EEDF8(a1);

  operator delete();
}

uint64_t sub_1004EEEA8(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = &off_1019DAFF0;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  std::string::operator=((std::string *)(a1 + 16), (const std::string *)(a2 + 16));
  if (*(void *)(a2 + 8)) {
    operator new();
  }
  *(unsigned char *)(a1 + 40) = *(unsigned char *)(a2 + 40);
  return a1;
}

uint64_t sub_1004EEF80(uint64_t a1, PB::TextFormatter *this, char *a3)
{
  PB::TextFormatter::beginObject(this, a3);
  PB::TextFormatter::format(this, "isAltEmAddressUpdateUrl", *(unsigned char *)(a1 + 40));
  if (*(void *)(a1 + 8)) {
    PB::TextFormatter::format();
  }
  PB::TextFormatter::format();

  return PB::TextFormatter::endObject(this);
}

uint64_t sub_1004EF004(uint64_t a1, PB::Reader *this)
{
  unint64_t v3 = *((void *)this + 1);
  unint64_t v2 = *((void *)this + 2);
  int v4 = *((unsigned __int8 *)this + 24);
  if (v3 < v2 && v4 == 0)
  {
    while (1)
    {
      uint64_t v8 = *(void *)this;
      if (v3 > 0xFFFFFFFFFFFFFFF5 || v3 + 10 > v2) {
        break;
      }
      char v9 = 0;
      unsigned int v10 = 0;
      unint64_t v11 = 0;
      while (1)
      {
        unint64_t v12 = v3 + 1;
        *((void *)this + 1) = v3 + 1;
        char v13 = *(unsigned char *)(v8 + v3);
        v11 |= (unint64_t)(v13 & 0x7F) << v9;
        if ((v13 & 0x80) == 0) {
          break;
        }
        v9 += 7;
        unint64_t v3 = v12;
        BOOL v14 = v10++ > 8;
        if (v14) {
          goto LABEL_20;
        }
      }
LABEL_22:
      unsigned __int8 v19 = v11 & 7;
      if ((v11 & 7) == 4)
      {
        int v4 = 0;
        return v4 == 0;
      }
      unint64_t v20 = v11 >> 3;
      if ((v11 >> 3) == 3)
      {
        if (v12 >= v2)
        {
          BOOL v23 = 0;
          *((unsigned char *)this + 24) = 1;
        }
        else
        {
          int v22 = *(unsigned __int8 *)(v8 + v12);
          *((void *)this + 1) = v12 + 1;
          BOOL v23 = v22 != 0;
        }
        *(unsigned char *)(a1 + 40) = v23;
      }
      else
      {
        if (v20 == 2) {
          operator new();
        }
        if (v20 == 1)
        {
          PB::Reader::read();
        }
        else
        {
LABEL_27:
          uint64_t result = PB::Reader::skip(this, v20, v19, 0);
          if (!result) {
            return result;
          }
        }
      }
      unint64_t v3 = *((void *)this + 1);
      unint64_t v2 = *((void *)this + 2);
      int v4 = *((unsigned __int8 *)this + 24);
      if (v3 >= v2 || *((unsigned char *)this + 24)) {
        return v4 == 0;
      }
    }
    char v15 = 0;
    unsigned int v16 = 0;
    unint64_t v11 = 0;
    if (v3 <= v2) {
      unint64_t v17 = v2;
    }
    else {
      unint64_t v17 = v3;
    }
    while (v17 != v3)
    {
      char v18 = *(unsigned char *)(v8 + v3);
      *((void *)this + 1) = v3 + 1;
      v11 |= (unint64_t)(v18 & 0x7F) << v15;
      if ((v18 & 0x80) == 0)
      {
        unint64_t v12 = v3 + 1;
        goto LABEL_22;
      }
      v15 += 7;
      ++v3;
      BOOL v14 = v16++ > 8;
      if (v14)
      {
LABEL_20:
        unsigned __int8 v19 = 0;
        LODWORD(v20) = 0;
        goto LABEL_27;
      }
    }
    int v4 = 1;
    *((unsigned char *)this + 24) = 1;
  }
  return v4 == 0;
}

uint64_t sub_1004EF21C(uint64_t a1, PB::Writer *a2)
{
  PB::Writer::write();
  if (*(void *)(a1 + 8)) {
    PB::Writer::write();
  }
  char v4 = *(unsigned char *)(a1 + 40);

  return PB::Writer::write(a2, v4, 3u);
}

void sub_1004EF288(Registry **a1)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(*a1);
  unint64_t v2 = ServiceMap;
  if ((v3 & 0x8000000000000000) != 0)
  {
    char v4 = (unsigned __int8 *)(v3 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v5 = 5381;
    do
    {
      unint64_t v3 = v5;
      unsigned int v6 = *v4++;
      uint64_t v5 = (33 * v5) ^ v6;
    }
    while (v6);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v15 = v3;
  uint64_t v7 = sub_10004D37C(&v2[1].__m_.__sig, &v15);
  if (v7)
  {
    uint64_t v9 = v7[3];
    uint64_t v8 = (std::__shared_weak_count *)v7[4];
    if (v8)
    {
      atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v2);
      atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v8);
      char v11 = 0;
      if (!v9) {
        goto LABEL_17;
      }
      goto LABEL_10;
    }
  }
  else
  {
    uint64_t v9 = 0;
  }
  std::mutex::unlock(v2);
  uint64_t v8 = 0;
  char v11 = 1;
  if (!v9) {
    goto LABEL_17;
  }
LABEL_10:
  int v12 = capabilities::ct::defaultVinylSlotID(v10);
  char v13 = (capabilities::ct *)VinylSlotIdFromInt(v12);
  BOOL v14 = (capabilities::ct *)capabilities::ct::supportedVinylSlotCount(v13);
  if ((unint64_t)capabilities::ct::supportedVinylSlotCount(v14) >> 31) {
    __assert_rtn("initMetrics", "VinylAwdMetrics.cpp", 98, "capabilities::ct::supportedVinylSlotCount() <= std::numeric_limits<int>::max()");
  }
  if ((v11 & 1) == 0) {
    atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  sub_10017B514();
  if ((v11 & 1) == 0) {
    atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  sub_10017B514();
  if (v8)
  {
    sub_10004D2C8(v8);
    sub_10004D2C8(v8);
  }
LABEL_17:
  if ((v11 & 1) == 0) {
    sub_10004D2C8(v8);
  }
}

void sub_1004EF49C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, std::__shared_weak_count *a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,std::__shared_weak_count *a22)
{
  if (a15) {
    sub_10004D2C8(a15);
  }
  if (a22) {
    sub_10004D2C8(a22);
  }
  if ((v23 & 1) == 0) {
    sub_10004D2C8(v22);
  }
  _Unwind_Resume(exception_object);
}

void sub_1004EF4E4(wis::MetricFactory *a1, unsigned int a2)
{
  unint64_t v3 = (std::__shared_weak_count *)*((void *)a1 + 5);
  uint64_t v9 = v3;
  if (v3) {
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  SharedMetricFactory = (wis::MetricFactory *)wis::MetricFactory::getSharedMetricFactory(a1);
  uint64_t v5 = (wis::MetricContainer *)wis::MetricFactory::newMetricContainerWithIdentifier(SharedMetricFactory, a2);
  if (v5)
  {
    unsigned int v6 = sub_10001C8F4(8);
    uint64_t v8 = *v6;
    uint64_t v7 = (std::__shared_weak_count *)v6[1];
    if (v7) {
      atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    if (v8) {
      operator new();
    }
    if (v7) {
      sub_10004D2C8(v7);
    }
    wis::MetricContainer::~MetricContainer(v5);
    operator delete();
  }
  if (v9) {
    sub_10004D2C8(v9);
  }
}

void sub_1004EF694(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, std::__shared_weak_count *a7, uint64_t a8, ...)
{
  va_start(va, a8);
  if (v8) {
    sub_10004D2C8(v8);
  }
  sub_100129880((wis::MetricContainer **)va, 0);
  if (a7) {
    sub_10004D2C8(a7);
  }
  _Unwind_Resume(a1);
}

void sub_1004EF72C(uint64_t a1, int *a2)
{
  int v22 = *(_DWORD *)(a1 + 48);
  if (v22 >= 1)
  {
    char v4 = (wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(a2 + 10);
    uint64_t v5 = (wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(a2 + 4);
    unsigned int v6 = 1;
    do
    {
      long long v23 = 0u;
      long long v24 = 0u;
      uint64_t v7 = *(void *)(a1 + 32);
      uint64_t v8 = VinylSlotIdFromInt(v6);
      (*(void (**)(long long *__return_ptr, uint64_t, uint64_t))(*(void *)v7 + 216))(&v23, v7, v8);
      if (BYTE8(v24))
      {
        uint64_t v9 = (const std::string *)*((void *)&v23 + 1);
        if ((void)v23 == *((void *)&v23 + 1)) {
          goto LABEL_28;
        }
        if (v6 > 2)
        {
          BOOL v25 = (void **)&v23;
          sub_1000C57C8(&v25);
          return;
        }
        unsigned int v10 = (const std::string *)(v23 + 120);
        do
        {
          if (v6 == 1)
          {
            int v11 = a2[7];
            uint64_t v12 = a2[6];
            if ((int)v12 >= v11)
            {
              if (v11 == a2[8])
              {
                wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve(v5, v11 + 1);
                int v11 = a2[7];
              }
              a2[7] = v11 + 1;
              sub_1004F1684();
            }
            uint64_t v13 = *((void *)a2 + 2);
            a2[6] = v12 + 1;
          }
          else
          {
            int v14 = a2[13];
            uint64_t v12 = a2[12];
            if ((int)v12 >= v14)
            {
              if (v14 == a2[14])
              {
                wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve(v4, v14 + 1);
                int v14 = a2[13];
              }
              a2[13] = v14 + 1;
              sub_1004F1684();
            }
            uint64_t v13 = *((void *)a2 + 5);
            a2[12] = v12 + 1;
          }
          uint64_t v15 = *(void *)(v13 + 8 * v12);
          int v16 = *(_DWORD *)(v15 + 36);
          *(unsigned char *)(v15 + 12) = v10[-2].__r_.__value_.__s.__data_[17];
          *(_DWORD *)(v15 + 36) = v16 | 6;
          unint64_t v17 = *(std::string **)(v15 + 16);
          if (v17 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString) {
            operator new();
          }
          std::string::operator=(v17, v10);
          *(_DWORD *)(v15 + 36) |= 8u;
          char v18 = *(std::string **)(v15 + 24);
          if (v18 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString) {
            operator new();
          }
          std::string::operator=(v18, v10 - 1);
          if (v10[-2].__r_.__value_.__s.__data_[16]) {
            int v19 = 1;
          }
          else {
            int v19 = 2;
          }
          *(_DWORD *)(v15 + 36) |= 1u;
          *(_DWORD *)(v15 + 8) = v19;
          unint64_t v20 = v10 + 4;
          v10 += 9;
        }
        while (v20 != v9);
        if (BYTE8(v24))
        {
LABEL_28:
          BOOL v25 = (void **)&v23;
          sub_1000C57C8(&v25);
        }
      }
    }
    while (v6++ != v22);
  }
}

void sub_1004EF9CC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, char a14, uint64_t a15, char *a16)
{
  if (a14)
  {
    a16 = &a11;
    sub_1000C57C8((void ***)&a16);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1004EF9F0(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_1004EFA0C(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

uint64_t sub_1004EFA1C(uint64_t a1)
{
  long long v3 = 0u;
  long long v4 = 0u;
  (*(void (**)(long long *__return_ptr))(**(void **)(a1 + 32) + 216))(&v3);
  if (BYTE8(v4))
  {
    for (uint64_t i = v3; ; i += 216)
    {
      if (i == *((void *)&v3 + 1))
      {
        char v6 = 0;
        goto LABEL_9;
      }
      if (*(unsigned char *)(i + 89)) {
        break;
      }
    }
    char v6 = 0;
    sub_1000C5AB4((uint64_t)v7, i);
    char v6 = 1;
    if (!BYTE8(v4)) {
      goto LABEL_10;
    }
LABEL_9:
    uint64_t v5 = (void **)&v3;
    sub_1000C57C8(&v5);
  }
  else
  {
    char v6 = 0;
  }
LABEL_10:
  uint64_t result = sub_1004EFB74();
  if (v6) {
    return sub_1000C584C((uint64_t)v7);
  }
  return result;
}

void sub_1004EFB2C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, uint64_t *a13, char a14)
{
  if (a12)
  {
    a13 = &a9;
    sub_1000C57C8((void ***)&a13);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1004EFB74()
{
  return sub_1004F16E8((wis::MetricFactory *)0x800C9);
}

uint64_t sub_1004EFC04(wis::MetricFactory *a1)
{
  unsigned int v1 = a1;
  SharedMetricFactory = (wis::MetricFactory *)wis::MetricFactory::getSharedMetricFactory(a1);
  uint64_t v3 = wis::MetricFactory::newMetricContainerWithIdentifier(SharedMetricFactory, v1);
  if (v3)
  {
    long long v4 = (wis::MetricContainer *)v3;
    uint64_t v5 = sub_10001C8F4(8);
    uint64_t v7 = *v5;
    char v6 = (std::__shared_weak_count *)v5[1];
    if (v6) {
      atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    if (v7) {
      operator new();
    }
    if (v6) {
      sub_10004D2C8(v6);
    }
    wis::MetricContainer::~MetricContainer(v4);
    operator delete();
  }
  return 0;
}

void sub_1004EFD60(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  sub_100129880((wis::MetricContainer **)va, 0);
  _Unwind_Resume(a1);
}

uint64_t sub_1004EFDE4(uint64_t a1, uint64_t a2)
{
  uint64_t result = VinylSlotIdToInt();
  int v5 = *(_DWORD *)(a2 + 28);
  *(_DWORD *)(a2 + 16) = result;
  char v6 = *(unsigned char *)(a1 + 36);
  *(_DWORD *)(a2 + 28) = v5 | 6;
  *(unsigned char *)(a2 + 20) = v6;
  return result;
}

uint64_t sub_1004EFE28(uint64_t a1, int a2)
{
  switch(a2)
  {
    case 4:
      return result;
    default:
      uint64_t result = sub_1004EFF24((wis::MetricFactory *)0x800CA);
      break;
  }
  return result;
}

uint64_t sub_1004EFF24(wis::MetricFactory *a1)
{
  unsigned int v1 = a1;
  SharedMetricFactory = (wis::MetricFactory *)wis::MetricFactory::getSharedMetricFactory(a1);
  uint64_t v3 = wis::MetricFactory::newMetricContainerWithIdentifier(SharedMetricFactory, v1);
  if (v3)
  {
    long long v4 = (wis::MetricContainer *)v3;
    int v5 = sub_10001C8F4(8);
    uint64_t v7 = *v5;
    char v6 = (std::__shared_weak_count *)v5[1];
    if (v6) {
      atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    if (v7) {
      operator new();
    }
    if (v6) {
      sub_10004D2C8(v6);
    }
    wis::MetricContainer::~MetricContainer(v4);
    operator delete();
  }
  return 0;
}

void sub_1004F0080(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  sub_100129880((wis::MetricContainer **)va, 0);
  _Unwind_Resume(a1);
}

uint64_t sub_1004F0104(uint64_t a1, _DWORD *a2)
{
  int v3 = *(_DWORD *)(a1 + 32);
  int v4 = a2[10];
  a2[10] = v4 | 4;
  a2[5] = v3;
  int v5 = *(_DWORD *)(a1 + 36);
  if (v5)
  {
    a2[10] = v4 | 0xC;
    a2[8] = v5;
  }
  uint64_t result = VinylSlotIdToInt();
  a2[10] |= 2u;
  a2[4] = result;
  return result;
}

uint64_t sub_1004F0164(uint64_t a1, int a2)
{
  switch(a2)
  {
    case 4:
      return result;
    default:
      sub_1004EFF24((wis::MetricFactory *)0x800CB);
      uint64_t result = sub_1004F03CC((wis::MetricFactory *)0x800CD);
      break;
  }
  return result;
}

std::string *sub_1004F02EC(uint64_t a1, uint64_t a2)
{
  int v4 = *(_DWORD *)(a1 + 40);
  *(_DWORD *)(a2 + 40) |= 4u;
  *(_DWORD *)(a2 + 20) = v4;
  uint64_t result = (std::string *)VinylSlotIdToInt();
  int v6 = *(_DWORD *)(a2 + 40);
  *(_DWORD *)(a2 + 40) = v6 | 2;
  *(_DWORD *)(a2 + 16) = result;
  int v7 = *(_DWORD *)(a1 + 48);
  *(_DWORD *)(a2 + 40) = v6 | 0xA;
  *(_DWORD *)(a2 + 32) = v7;
  uint64_t v8 = *(void *)(a1 + 32);
  if (*(char *)(v8 + 23) < 0)
  {
    if (!*(void *)(v8 + 8)) {
      return result;
    }
  }
  else if (!*(unsigned char *)(v8 + 23))
  {
    return result;
  }
  *(_DWORD *)(a2 + 40) = v6 | 0x1A;
  uint64_t v9 = *(std::string **)(a2 + 24);
  if (v9 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString) {
    operator new();
  }

  return std::string::operator=(v9, (const std::string *)v8);
}

uint64_t sub_1004F03CC(wis::MetricFactory *a1)
{
  unsigned int v1 = a1;
  SharedMetricFactory = (wis::MetricFactory *)wis::MetricFactory::getSharedMetricFactory(a1);
  uint64_t v3 = wis::MetricFactory::newMetricContainerWithIdentifier(SharedMetricFactory, v1);
  if (v3)
  {
    int v4 = (wis::MetricContainer *)v3;
    int v5 = sub_10001C8F4(8);
    uint64_t v7 = *v5;
    int v6 = (std::__shared_weak_count *)v5[1];
    if (v6) {
      atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    if (v7) {
      operator new();
    }
    if (v6) {
      sub_10004D2C8(v6);
    }
    wis::MetricContainer::~MetricContainer(v4);
    operator delete();
  }
  return 0;
}

void sub_1004F0528(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  sub_100129880((wis::MetricContainer **)va, 0);
  _Unwind_Resume(a1);
}

uint64_t sub_1004F05AC(uint64_t a1, uint64_t a2)
{
  int v4 = *(_DWORD *)(a1 + 48);
  *(_DWORD *)(a2 + 132) |= 4u;
  *(_DWORD *)(a2 + 20) = v4;
  uint64_t result = VinylSlotIdToInt();
  int v6 = *(_DWORD *)(a2 + 132);
  *(_DWORD *)(a2 + 132) = v6 | 2;
  *(_DWORD *)(a2 + 16) = result;
  int v7 = *(_DWORD *)(a1 + 56);
  *(_DWORD *)(a2 + 132) = v6 | 0xA;
  *(_DWORD *)(a2 + 32) = v7;
  uint64_t v8 = *(void *)(a1 + 32);
  if (*(char *)(v8 + 23) < 0) {
    uint64_t v9 = *(void *)(v8 + 8);
  }
  else {
    uint64_t v9 = *(unsigned __int8 *)(v8 + 23);
  }
  if (v9)
  {
    *(_DWORD *)(a2 + 132) = v6 | 0x1A;
    unsigned int v10 = *(std::string **)(a2 + 24);
    if (v10 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString) {
      operator new();
    }
    uint64_t result = (uint64_t)std::string::operator=(v10, (const std::string *)v8);
  }
  uint64_t v11 = *(void *)(a1 + 40);
  if (*(unsigned char *)(v11 + 16))
  {
    uint64_t v12 = *(void *)(v11 + 24);
    *(_DWORD *)(a2 + 132) |= 0x10000u;
    *(_DWORD *)(a2 + 76) = v12;
  }
  if (*(unsigned char *)(v11 + 32))
  {
    uint64_t v13 = *(void *)(v11 + 40);
    *(_DWORD *)(a2 + 132) |= 0x20000u;
    *(_DWORD *)(a2 + 80) = v13;
  }
  if (*(unsigned char *)(v11 + 48))
  {
    uint64_t v14 = *(void *)(v11 + 56);
    *(_DWORD *)(a2 + 132) |= 0x40000u;
    *(_DWORD *)(a2 + 84) = v14;
  }
  if (*(unsigned char *)(v11 + 64))
  {
    uint64_t v15 = *(void *)(v11 + 72);
    *(_DWORD *)(a2 + 132) |= 0x80000u;
    *(_DWORD *)(a2 + 88) = v15;
  }
  if (*(unsigned char *)(v11 + 80))
  {
    uint64_t v16 = *(void *)(v11 + 88);
    *(_DWORD *)(a2 + 132) |= 0x100000u;
    *(_DWORD *)(a2 + 92) = v16;
  }
  if (*(unsigned char *)(v11 + 96))
  {
    uint64_t v17 = *(void *)(v11 + 104);
    *(_DWORD *)(a2 + 132) |= 0x200000u;
    *(_DWORD *)(a2 + 96) = v17;
  }
  if (*(unsigned char *)(v11 + 112))
  {
    uint64_t v18 = *(void *)(v11 + 120);
    *(_DWORD *)(a2 + 132) |= 0x400000u;
    *(_DWORD *)(a2 + 100) = v18;
  }
  if (*(unsigned char *)(v11 + 128))
  {
    uint64_t v19 = *(void *)(v11 + 136);
    *(_DWORD *)(a2 + 132) |= 0x800000u;
    *(_DWORD *)(a2 + 104) = v19;
  }
  if (*(unsigned char *)(v11 + 144))
  {
    uint64_t v20 = *(void *)(v11 + 152);
    *(_DWORD *)(a2 + 132) |= 0x1000000u;
    *(_DWORD *)(a2 + 108) = v20;
  }
  if (*(unsigned char *)(v11 + 160))
  {
    uint64_t v21 = *(void *)(v11 + 168);
    *(_DWORD *)(a2 + 132) |= 0x2000000u;
    *(_DWORD *)(a2 + 120) = v21;
  }
  if (*(unsigned char *)(v11 + 176))
  {
    *(_DWORD *)(a2 + 132) |= 0x4000000u;
    int v22 = *(std::string **)(a2 + 112);
    if (v22 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString) {
      operator new();
    }
    uint64_t result = (uint64_t)std::string::operator=(v22, (const std::string *)(v11 + 184));
    uint64_t v11 = *(void *)(a1 + 40);
  }
  if (*(unsigned char *)v11)
  {
    uint64_t v23 = *(void *)(v11 + 8);
    *(_DWORD *)(a2 + 132) |= 0x80u;
    *(_DWORD *)(a2 + 40) = v23;
  }
  return result;
}

uint64_t sub_1004F0808(wis::MetricFactory *a1)
{
  unsigned int v1 = a1;
  SharedMetricFactory = (wis::MetricFactory *)wis::MetricFactory::getSharedMetricFactory(a1);
  uint64_t v3 = wis::MetricFactory::newMetricContainerWithIdentifier(SharedMetricFactory, v1);
  if (v3)
  {
    int v4 = (wis::MetricContainer *)v3;
    int v5 = sub_10001C8F4(8);
    uint64_t v7 = *v5;
    int v6 = (std::__shared_weak_count *)v5[1];
    if (v6) {
      atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    if (v7) {
      operator new();
    }
    if (v6) {
      sub_10004D2C8(v6);
    }
    wis::MetricContainer::~MetricContainer(v4);
    operator delete();
  }
  return 0;
}

void sub_1004F0964(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  sub_100129880((wis::MetricContainer **)va, 0);
  _Unwind_Resume(a1);
}

uint64_t sub_1004F09E8(_DWORD *a1, _DWORD *a2)
{
  uint64_t result = VinylSlotIdToInt();
  int v5 = a2[9];
  a2[9] = v5 | 2;
  a2[4] = result;
  int v6 = a1[9];
  a2[9] = v5 | 6;
  a2[5] = v6;
  int v7 = a1[10];
  a2[9] = v5 | 0xE;
  a2[6] = v7;
  int v8 = a1[11];
  a2[9] = v5 | 0x1E;
  a2[7] = v8;
  return result;
}

uint64_t sub_1004F0A54(wis::MetricFactory *a1)
{
  unsigned int v1 = a1;
  SharedMetricFactory = (wis::MetricFactory *)wis::MetricFactory::getSharedMetricFactory(a1);
  uint64_t v3 = wis::MetricFactory::newMetricContainerWithIdentifier(SharedMetricFactory, v1);
  if (v3)
  {
    int v4 = (wis::MetricContainer *)v3;
    int v5 = sub_10001C8F4(8);
    uint64_t v7 = *v5;
    int v6 = (std::__shared_weak_count *)v5[1];
    if (v6) {
      atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    if (v7) {
      operator new();
    }
    if (v6) {
      sub_10004D2C8(v6);
    }
    wis::MetricContainer::~MetricContainer(v4);
    operator delete();
  }
  return 0;
}

void sub_1004F0BB0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  sub_100129880((wis::MetricContainer **)va, 0);
  _Unwind_Resume(a1);
}

uint64_t sub_1004F0C34(uint64_t a1, _DWORD *a2)
{
  uint64_t result = VinylSlotIdToInt();
  int v5 = a2[7];
  a2[7] = v5 | 2;
  a2[4] = result;
  int v6 = *(_DWORD *)(a1 + 36);
  a2[7] = v5 | 6;
  a2[5] = v6;
  return result;
}

uint64_t sub_1004F0C80(wis::MetricFactory *a1)
{
  unsigned int v1 = a1;
  SharedMetricFactory = (wis::MetricFactory *)wis::MetricFactory::getSharedMetricFactory(a1);
  uint64_t v3 = wis::MetricFactory::newMetricContainerWithIdentifier(SharedMetricFactory, v1);
  if (v3)
  {
    int v4 = (wis::MetricContainer *)v3;
    int v5 = sub_10001C8F4(8);
    uint64_t v7 = *v5;
    int v6 = (std::__shared_weak_count *)v5[1];
    if (v6) {
      atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    if (v7) {
      operator new();
    }
    if (v6) {
      sub_10004D2C8(v6);
    }
    wis::MetricContainer::~MetricContainer(v4);
    operator delete();
  }
  return 0;
}

void sub_1004F0DDC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  sub_100129880((wis::MetricContainer **)va, 0);
  _Unwind_Resume(a1);
}

uint64_t sub_1004F0E60(uint64_t a1, uint64_t a2)
{
  uint64_t result = VinylSlotIdToInt();
  int v5 = *(_DWORD *)(a2 + 36);
  *(_DWORD *)(a2 + 36) = v5 | 2;
  *(_DWORD *)(a2 + 16) = result;
  *(_DWORD *)(a2 + 20) = *(_DWORD *)(a1 + 36);
  char v6 = *(unsigned char *)(a1 + 44);
  *(_DWORD *)(a2 + 36) = v5 | 0xE;
  *(unsigned char *)(a2 + 24) = v6;
  int v7 = *(_DWORD *)(a1 + 40);
  if (v7)
  {
    *(_DWORD *)(a2 + 36) = v5 | 0x1E;
    *(_DWORD *)(a2 + 28) = v7;
  }
  return result;
}

void sub_1004F0EC8(Registry **a1, uint64_t *a2)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(*a1);
  int v4 = ServiceMap;
  if (v5 < 0)
  {
    char v6 = (unsigned __int8 *)(v5 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v7 = 5381;
    do
    {
      uint64_t v5 = v7;
      unsigned int v8 = *v6++;
      uint64_t v7 = (33 * v7) ^ v8;
    }
    while (v8);
  }
  std::mutex::lock(ServiceMap);
  p_long long string = (const char *)v5;
  uint64_t v9 = sub_10004D37C(&v4[1].__m_.__sig, (unint64_t *)&p_string);
  if (!v9)
  {
    uint64_t v10 = 0;
LABEL_9:
    std::mutex::unlock(v4);
    uint64_t v11 = 0;
    char v12 = 1;
    if (!v10) {
      goto LABEL_74;
    }
    goto LABEL_10;
  }
  uint64_t v10 = v9[3];
  uint64_t v11 = (std::__shared_weak_count *)v9[4];
  if (!v11) {
    goto LABEL_9;
  }
  atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v4);
  atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v11);
  char v12 = 0;
  if (!v10) {
    goto LABEL_74;
  }
LABEL_10:
  int v29 = v11;
  uint64_t v13 = *a2;
  uint64_t v31 = a2[1];
  char v30 = v12;
  if (*a2 == v31)
  {
    int v15 = 0;
    int v14 = 0;
  }
  else
  {
    int v14 = 0;
    int v15 = 0;
    do
    {
      if (*(unsigned char *)(v13 + 80))
      {
        int v33 = v14;
        p_long long string = 0;
        long long v60 = 0;
        uint64_t v61 = 0;
        sub_1000C5EF0(&p_string, *(void *)(v13 + 56), *(void *)(v13 + 64), 0x84BDA12F684BDA13 * ((uint64_t)(*(void *)(v13 + 64) - *(void *)(v13 + 56)) >> 3));
        uint64_t v17 = p_string;
        uint64_t v16 = v60;
        for (unint64_t i = v60 - p_string; v17 != v16; v17 += 216)
        {
          xpc_object_t v58 = 0;
          xpc_object_t v18 = xpc_dictionary_create(0, 0, 0);
          xpc_object_t v19 = v18;
          if (v18)
          {
            xpc_object_t v58 = v18;
          }
          else
          {
            xpc_object_t v19 = xpc_null_create();
            xpc_object_t v58 = v19;
            if (!v19)
            {
              xpc_object_t v20 = xpc_null_create();
              xpc_object_t v19 = 0;
              goto LABEL_21;
            }
          }
          if (xpc_get_type(v19) != (xpc_type_t)&_xpc_type_dictionary)
          {
            xpc_object_t v20 = xpc_null_create();
LABEL_21:
            xpc_object_t v58 = v20;
            goto LABEL_22;
          }
          xpc_retain(v19);
LABEL_22:
          xpc_release(v19);
          xpc_object_t v56 = xpc_BOOL_create(v17[89]);
          if (!v56) {
            xpc_object_t v56 = xpc_null_create();
          }
          *(void *)&long long string = &v58;
          *((void *)&string + 1) = "isActive";
          sub_100035E70((uint64_t)&string, &v56, &v57);
          xpc_release(v57);
          xpc_object_t v57 = 0;
          xpc_release(v56);
          uint64_t v55 = 0;
          xpc_object_t v56 = 0;
          long long string = 0uLL;
          if (v17[88])
          {
            qmemcpy(&string, "Bootstrap", 9);
            char v21 = 9;
          }
          else
          {
            qmemcpy(&string, "Normal", 6);
            ++v15;
            char v21 = 6;
          }
          HIBYTE(v55) = v21;
          xpc_object_t v52 = xpc_string_create((const char *)&string);
          if (!v52) {
            xpc_object_t v52 = xpc_null_create();
          }
          OsLogContext __p = &v58;
          long long v48 = "profileType";
          sub_100035E70((uint64_t)&__p, &v52, &v53);
          xpc_release(v53);
          xpc_object_t v53 = 0;
          xpc_release(v52);
          xpc_object_t v52 = 0;
          sub_1002055B4((const void **)v17 + 12, (const void **)v17 + 15, &__p);
          if (v49 >= 0) {
            p_p = (const char *)&__p;
          }
          else {
            p_p = (const char *)__p;
          }
          xpc_object_t v50 = xpc_string_create(p_p);
          if (!v50) {
            xpc_object_t v50 = xpc_null_create();
          }
          v46[0] = &v58;
          v46[1] = "carrierName";
          sub_100035E70((uint64_t)v46, &v50, &object);
          xpc_release(object);
          xpc_object_t object = 0;
          xpc_release(v50);
          xpc_object_t v50 = 0;
          if (v49 < 0) {
            operator delete(__p);
          }
          uint64_t v23 = v17 + 64;
          if (v17[87] < 0) {
            uint64_t v23 = *(const char **)v23;
          }
          xpc_object_t v44 = xpc_string_create(v23);
          if (!v44) {
            xpc_object_t v44 = xpc_null_create();
          }
          OsLogContext __p = &v58;
          long long v48 = "serviceProviderName";
          sub_100035E70((uint64_t)&__p, &v44, &v45);
          xpc_release(v45);
          xpc_object_t v45 = 0;
          xpc_release(v44);
          xpc_object_t v44 = 0;
          long long v24 = v17 + 144;
          if (v17[167] < 0) {
            long long v24 = *(const char **)v24;
          }
          xpc_object_t v42 = xpc_string_create(v24);
          if (!v42) {
            xpc_object_t v42 = xpc_null_create();
          }
          OsLogContext __p = &v58;
          long long v48 = "gid1";
          sub_100035E70((uint64_t)&__p, &v42, &v43);
          xpc_release(v43);
          xpc_object_t v43 = 0;
          xpc_release(v42);
          xpc_object_t v42 = 0;
          BOOL v25 = v17 + 168;
          if (v17[191] < 0) {
            BOOL v25 = *(const char **)v25;
          }
          xpc_object_t v40 = xpc_string_create(v25);
          if (!v40) {
            xpc_object_t v40 = xpc_null_create();
          }
          OsLogContext __p = &v58;
          long long v48 = "gid1";
          sub_100035E70((uint64_t)&__p, &v40, &v41);
          xpc_release(v41);
          xpc_object_t v41 = 0;
          xpc_release(v40);
          xpc_object_t v39 = v58;
          xpc_object_t v40 = 0;
          if (v58) {
            xpc_retain(v58);
          }
          else {
            xpc_object_t v39 = xpc_null_create();
          }
          (*(void (**)(uint64_t, const char *, xpc_object_t *))(*(void *)v10 + 16))(v10, "commCenterVinylInfo", &v39);
          xpc_release(v39);
          xpc_object_t v39 = 0;
          if (SHIBYTE(v55) < 0) {
            operator delete((void *)string);
          }
          xpc_release(v58);
        }
        int v14 = v33 + 1749801491 * (i >> 3);
        *(void *)&long long string = &p_string;
        sub_1000C57C8((void ***)&string);
      }
      v13 += 88;
    }
    while (v13 != v31);
  }
  *(void *)&long long string = 0;
  xpc_object_t v26 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v27 = v26;
  if (v26)
  {
    *(void *)&long long string = v26;
  }
  else
  {
    xpc_object_t v27 = xpc_null_create();
    *(void *)&long long string = v27;
    if (!v27)
    {
      xpc_object_t v28 = xpc_null_create();
      xpc_object_t v27 = 0;
      goto LABEL_65;
    }
  }
  if (xpc_get_type(v27) != (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_object_t v28 = xpc_null_create();
LABEL_65:
    *(void *)&long long string = v28;
    goto LABEL_66;
  }
  xpc_retain(v27);
LABEL_66:
  xpc_release(v27);
  xpc_object_t v37 = xpc_int64_create(v14);
  if (!v37) {
    xpc_object_t v37 = xpc_null_create();
  }
  p_long long string = (const char *)&string;
  long long v60 = "installedProfilesCount";
  sub_100035E70((uint64_t)&p_string, &v37, &v38);
  xpc_release(v38);
  xpc_object_t v38 = 0;
  xpc_release(v37);
  xpc_object_t v37 = 0;
  xpc_object_t v35 = xpc_int64_create(v15);
  uint64_t v11 = v29;
  if (!v35) {
    xpc_object_t v35 = xpc_null_create();
  }
  p_long long string = (const char *)&string;
  long long v60 = "nonBootstrapProfilesCount";
  sub_100035E70((uint64_t)&p_string, &v35, &v36);
  xpc_release(v36);
  xpc_object_t v36 = 0;
  xpc_release(v35);
  xpc_object_t v34 = (xpc_object_t)string;
  xpc_object_t v35 = 0;
  if ((void)string) {
    xpc_retain((xpc_object_t)string);
  }
  else {
    xpc_object_t v34 = xpc_null_create();
  }
  (*(void (**)(uint64_t, const char *, xpc_object_t *))(*(void *)v10 + 16))(v10, "commCenterVinylInfo", &v34);
  xpc_release(v34);
  xpc_object_t v34 = 0;
  xpc_release((xpc_object_t)string);
  char v12 = v30;
LABEL_74:
  if ((v12 & 1) == 0) {
    sub_10004D2C8(v11);
  }
}

void sub_1004F1550(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, std::__shared_weak_count *a9, int a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, xpc_object_t object, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, xpc_object_t a20)
{
  xpc_release(object);
  xpc_release(*(xpc_object_t *)(v20 - 160));
  if ((a11 & 1) == 0) {
    sub_10004D2C8(a9);
  }
  _Unwind_Resume(a1);
}

void sub_1004F1684()
{
}

void sub_1004F16C4()
{
}

uint64_t sub_1004F16E8(wis::MetricFactory *a1)
{
  unsigned int v1 = a1;
  SharedMetricFactory = (wis::MetricFactory *)wis::MetricFactory::getSharedMetricFactory(a1);
  uint64_t v3 = wis::MetricFactory::newMetricContainerWithIdentifier(SharedMetricFactory, v1);
  if (v3)
  {
    int v4 = (wis::MetricContainer *)v3;
    uint64_t v5 = sub_10001C8F4(8);
    uint64_t v7 = *v5;
    char v6 = (std::__shared_weak_count *)v5[1];
    if (v6) {
      atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    if (v7) {
      operator new();
    }
    if (v6) {
      sub_10004D2C8(v6);
    }
    wis::MetricContainer::~MetricContainer(v4);
    operator delete();
  }
  return 0;
}

void sub_1004F1844(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  sub_100129880((wis::MetricContainer **)va, 0);
  _Unwind_Resume(a1);
}

uint64_t sub_1004F18C8(uint64_t a1, _DWORD *a2)
{
  uint64_t result = VinylSlotIdToInt();
  int v5 = a2[7];
  a2[7] = v5 | 2;
  a2[4] = result;
  int v6 = *(_DWORD *)(a1 + 36);
  a2[7] = v5 | 6;
  a2[5] = v6;
  return result;
}

void sub_1004F1B7C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, id location)
{
  objc_destroyWeak(v18);

  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1004F1BEC(uint64_t a1, void *a2, void *a3, void *a4)
{
  int v6 = (id *)(a1 + 32);
  id v7 = a4;
  id v8 = a3;
  id v9 = a2;
  id WeakRetained = objc_loadWeakRetained(v6);
  [WeakRetained handleGPSData:v9 heatMapDict:v8 error:v7];
}

void sub_1004F1C80(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1004F2EF4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *a22,void *a23,void *a24)
{
  _Unwind_Resume(a1);
}

void *sub_1004F30E0(void *a1, id *a2, uint64_t a3)
{
  *a1 = off_1019DB260;
  int v6 = [StewieBBTimeFreqTransferAssertion alloc];
  id v7 = sub_100200FB4(a2);
  a1[1] = [(StewieBBTimeFreqTransferAssertion *)v6 initWithQueue:v7 callback:a3];

  return a1;
}

void sub_1004F3168(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1004F3178(uint64_t a1)
{
  return a1;
}

void sub_1004F31A4(uint64_t a1)
{
  operator delete();
}

double sub_1004F31F0@<D0>(id *a1@<X0>, uint64_t a2@<X1>, _OWORD *a3@<X8>)
{
  if (!*a1) {
    __TUAssertTrigger();
  }
  sub_1004F345C(a1, a2, v7);
  double result = v7[0];
  *a3 = *(_OWORD *)v7;
  return result;
}

uint64_t sub_1004F3258(uint64_t a1)
{
  sub_10024D10C(a1 + 40, *(void **)(a1 + 48));
  uint64_t v2 = *(void **)(a1 + 8);
  if (v2)
  {
    *(void *)(a1 + 16) = v2;
    operator delete(v2);
  }
  return a1;
}

uint64_t *sub_1004F3298(uint64_t *result, unsigned int a2, int a3, uint64_t *a4)
{
  int v6 = result;
  id v8 = (uint64_t **)(result + 1);
  uint64_t v7 = result[1];
  if (v7)
  {
    while (1)
    {
      while (1)
      {
        id v9 = (void *)v7;
        unsigned int v10 = *(_DWORD *)(v7 + 32);
        if (v10 <= a2) {
          break;
        }
        uint64_t v7 = *v9;
        id v8 = (uint64_t **)v9;
        if (!*v9) {
          goto LABEL_9;
        }
      }
      if (v10 >= a2) {
        break;
      }
      uint64_t v7 = v9[1];
      if (!v7)
      {
        id v8 = (uint64_t **)(v9 + 1);
        goto LABEL_9;
      }
    }
  }
  else
  {
    id v9 = result + 1;
LABEL_9:
    uint64_t v11 = (uint64_t *)operator new(0x40uLL);
    char v12 = v11;
    *((_DWORD *)v11 + 8) = a3;
    uint64_t v13 = a4 + 1;
    uint64_t v14 = a4[1];
    v11[5] = *a4;
    v11[6] = v14;
    int v15 = (char *)(v11 + 6);
    uint64_t v16 = a4[2];
    v11[7] = v16;
    if (v16)
    {
      *(void *)(v14 + 16) = v15;
      *a4 = (uint64_t)v13;
      void *v13 = 0;
      a4[2] = 0;
    }
    else
    {
      v11[5] = (uint64_t)v15;
    }
    uint64_t *v11 = 0;
    v11[1] = 0;
    v11[2] = (uint64_t)v9;
    std::__shared_weak_count *v8 = v11;
    uint64_t v17 = *(void *)*v6;
    if (v17)
    {
      *int v6 = v17;
      char v12 = *v8;
    }
    double result = sub_100046C90((uint64_t *)v6[1], v12);
    ++v6[2];
  }
  return result;
}

uint64_t sub_1004F3390(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 64))
  {
    sub_10024D10C(a1 + 40, *(void **)(a1 + 48));
    uint64_t v2 = *(void **)(a1 + 8);
    if (v2)
    {
      *(void *)(a1 + 16) = v2;
      operator delete(v2);
    }
  }
  return a1;
}

void *sub_1004F33D8(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *sub_1004F345C@<X0>(id *a1@<X1>, uint64_t a2@<X2>, void *a3@<X8>)
{
  int v6 = operator new(0x28uLL);
  double result = sub_1004F34C0(v6, a1, a2);
  *a3 = v6 + 3;
  a3[1] = v6;
  return result;
}

void sub_1004F34AC(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_1004F34C0(void *a1, id *a2, uint64_t a3)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = off_1019DB2A8;
  sub_1004F30E0(a1 + 3, a2, a3);
  return a1;
}

void sub_1004F3508(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void sub_1004F351C(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1019DB2A8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1004F353C(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1019DB2A8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_1004F3590(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

uint64_t sub_1004F35B8@<X0>(uint64_t *a1@<X1>, dispatch_object_t *a2@<X2>, uint64_t *a3@<X3>, void *a4@<X8>)
{
  id v8 = (char *)operator new(0x20uLL);
  uint64_t result = sub_1004F362C((uint64_t)v8, a1, a2, a3);
  *a4 = v8 + 24;
  a4[1] = v8;
  return result;
}

void sub_1004F3618(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1004F362C(uint64_t a1, uint64_t *a2, dispatch_object_t *a3, uint64_t *a4)
{
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = off_1019DB2F8;
  sub_1004F3708((void **)(a1 + 24), a2, a3, a4);
  return a1;
}

void sub_1004F3674(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void sub_1004F3688(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1019DB2F8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1004F36A8(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1019DB2F8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_1004F36FC(uint64_t a1)
{
}

void **sub_1004F3708(void **a1, uint64_t *a2, dispatch_object_t *a3, uint64_t *a4)
{
  uint64_t v7 = *a2;
  int v6 = (std::__shared_weak_count *)a2[1];
  if (v6) {
    atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  id v8 = *a3;
  if (*a3) {
    dispatch_retain(*a3);
  }
  uint64_t v9 = *a4;
  *a1 = 0;
  unsigned int v10 = [EduModeNotifier alloc];
  uint64_t v15 = v7;
  uint64_t v16 = v6;
  if (v6) {
    atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  dispatch_object_t object = v8;
  if (v8) {
    dispatch_retain(v8);
  }
  uint64_t v11 = [(EduModeNotifier *)v10 initWithRegistry:&v15 andQueue:&object andLogger:v9];
  char v12 = *a1;
  *a1 = v11;

  if (object) {
    dispatch_release(object);
  }
  if (v16) {
    sub_10004D2C8(v16);
  }
  if (v8) {
    dispatch_release(v8);
  }
  if (v6) {
    sub_10004D2C8(v6);
  }
  return a1;
}

void sub_1004F37F8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object, uint64_t a11, std::__shared_weak_count *a12)
{
  if (object) {
    dispatch_release(object);
  }
  if (a12) {
    sub_10004D2C8(a12);
  }

  if (v14) {
    dispatch_release(v14);
  }
  if (v12) {
    sub_10004D2C8(v12);
  }
  _Unwind_Resume(a1);
}

void sub_1004F3844(uint64_t a1)
{
  *(void *)a1 = off_1019DB348;
  if (*(unsigned char *)(a1 + 2064) && *(char *)(a1 + 2063) < 0) {
    operator delete(*(void **)(a1 + 2040));
  }
  sub_1000DA2E4(*(char **)(a1 + 2016));
  sub_10026D080(*(char **)(a1 + 1992));
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 1976);
  if (v2) {
    sub_10004D2C8(v2);
  }
  PersonalitiesTracker::~PersonalitiesTracker((PersonalitiesTracker *)(a1 + 1792));
  sub_100160A84((atomic_uint **)(a1 + 1768));
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 1760);
  if (v3) {
    sub_10004D2C8(v3);
  }
  int v4 = *(std::__shared_weak_count **)(a1 + 1744);
  if (v4) {
    sub_10004D2C8(v4);
  }
  sub_10005CD2C(a1 + 1712, *(char **)(a1 + 1720));
  sub_100136194(a1 + 912);
  sub_100136194(a1 + 112);
  sub_10005CD2C(a1 + 80, *(char **)(a1 + 88));
  sub_1000886C0(a1 + 56, *(char **)(a1 + 64));
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 40));
  sub_100087E88((void *)(a1 + 8));

  SatelliteSystemInterface::~SatelliteSystemInterface((SatelliteSystemInterface *)a1);
}

void sub_1004F393C(uint64_t a1)
{
  sub_1004F3844(a1);

  operator delete();
}

void SatelliteSystemController::create(capabilities::ct *a1@<X0>, void *a2@<X8>)
{
  if (capabilities::ct::supportsStewie(a1))
  {
    if (_os_feature_enabled_impl()) {
      operator new();
    }
    ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)buf, kCtLoggingSystemName, "sat.sys.ctr");
    uint64_t v3 = v5;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_INFO, "Not enabled", buf, 2u);
    }
  }
  *a2 = 0;
  a2[1] = 0;
}

void sub_1004F3DCC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, ctu::OsLogLogger *a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, dispatch_object_t object, dispatch_object_t a19, void *a20,std::__shared_weak_count *a21,int a22,__int16 a23,char a24,char a25)
{
  if (__p) {
    (*(void (**)(void *))(*(void *)__p + 8))(__p);
  }
  if (a21) {
    sub_10004D2C8(a21);
  }
  sub_10004D2C8(v25);
  _Unwind_Resume(a1);
}

void sub_1004F3F8C()
{
}

void sub_1004F3F94(uint64_t a1)
{
  unsigned int v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_1004F4084(uint64_t a1, uint64_t a2, uint64_t a3)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 24));
  if (!*(unsigned char *)(*(void *)a3 + 49))
  {
    int v5 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      asString();
      if (v8 >= 0) {
        p_p = &__p;
      }
      else {
        p_p = __p;
      }
      *(_DWORD *)std::string buf = 136446210;
      unsigned int v10 = p_p;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Handle personality event: %{public}s", buf, 0xCu);
      if (v8 < 0) {
        operator delete(__p);
      }
    }
    dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 24));
    sub_1004F5C9C(a1, 0, 0);
  }
}

void sub_1004F4190(uint64_t a1, int a2)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 24));
  int v4 = a2 == 0;
  if (*(unsigned __int8 *)(a1 + 1961) != v4)
  {
    *(unsigned char *)(a1 + 1961) = v4;
    int v5 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      int v6 = "not ";
      if (!a2) {
        int v6 = "";
      }
      int v7 = 136315138;
      char v8 = v6;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Current operating mode is: %sonline", (uint8_t *)&v7, 0xCu);
    }
    dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 24));
    sub_1004F5C9C(a1, 0, 0);
  }
}

void sub_1004F4288(uint64_t a1)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 24));
  uint64_t v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = asStringBool(*(unsigned char *)(a1 + 1960));
    *(_DWORD *)std::string buf = 136315138;
    uint64_t v41 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I [d] Force allow satellite systems: %s", buf, 0xCu);
    uint64_t v2 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    int v4 = "";
    if (!*(unsigned char *)(a1 + 1961)) {
      int v4 = "not ";
    }
    *(_DWORD *)std::string buf = 136315138;
    uint64_t v41 = (uint64_t)v4;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I [d] Current operating mode is: %sonline", buf, 0xCu);
    uint64_t v2 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    if (*(unsigned char *)(a1 + 1963)) {
      int v5 = (const char *)asString();
    }
    else {
      int v5 = "<none>";
    }
    *(_DWORD *)std::string buf = 136315138;
    uint64_t v41 = (uint64_t)v5;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I [d] Registration over sat plmns status: %s", buf, 0xCu);
    uint64_t v2 = *(NSObject **)(a1 + 40);
  }
  int v6 = *(AutoStartTimer **)(a1 + 1968);
  if (v6 && os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v7 = AutoStartTimer::getDuration(v6) / 1000;
    char isExpired = AutoStartTimer::isExpired(*(AutoStartTimer **)(a1 + 1968));
    uint64_t v9 = asStringBool(isExpired);
    uint64_t StartTime = AutoStartTimer::getStartTime(*(AutoStartTimer **)(a1 + 1968));
    uint64_t ExpiryTime = AutoStartTimer::getExpiryTime(*(AutoStartTimer **)(a1 + 1968));
    *(_DWORD *)std::string buf = 134218754;
    uint64_t v41 = v7;
    __int16 v42 = 2080;
    xpc_object_t v43 = (void *)v9;
    __int16 v44 = 2048;
    uint64_t v45 = StartTime;
    __int16 v46 = 2048;
    uint64_t v47 = ExpiryTime;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I [d] Settling timer is running. Timer duration: %lld seconds, isExpired: %s, startTime: %lld, expiryTime: %lld", buf, 0x2Au);
    uint64_t v2 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v12 = *(void *)(a1 + 2000);
    *(_DWORD *)std::string buf = 134217984;
    uint64_t v41 = v12;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I [d] Cellular Internet configs [count: %zu]", buf, 0xCu);
  }
  uint64_t v13 = *(void **)(a1 + 1984);
  if (v13 != (void *)(a1 + 1992))
  {
    do
    {
      uint64_t v14 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v15 = v13 + 5;
        uint64_t v16 = subscriber::asString();
        if (*((char *)v13 + 63) < 0) {
          uint64_t v15 = (void *)*v15;
        }
        *(_DWORD *)std::string buf = 136315394;
        uint64_t v41 = v16;
        __int16 v42 = 2080;
        xpc_object_t v43 = v15;
        _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I [d] -->Slot: %s, Config: [interface name %s]", buf, 0x16u);
      }
      uint64_t v17 = (void *)v13[1];
      if (v17)
      {
        do
        {
          xpc_object_t v18 = v17;
          uint64_t v17 = (void *)*v17;
        }
        while (v17);
      }
      else
      {
        do
        {
          xpc_object_t v18 = (void *)v13[2];
          BOOL v19 = *v18 == (void)v13;
          uint64_t v13 = v18;
        }
        while (!v19);
      }
      uint64_t v13 = v18;
    }
    while (v18 != (void *)(a1 + 1992));
  }
  uint64_t v20 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v21 = *(void *)(a1 + 2024);
    *(_DWORD *)std::string buf = 134217984;
    uint64_t v41 = v21;
    _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#I [d] IMS Registration State: [count: %zu]", buf, 0xCu);
  }
  int v22 = *(void **)(a1 + 2008);
  if (v22 != (void *)(a1 + 2016))
  {
    do
    {
      uint64_t v23 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
      {
        long long v24 = (const char *)v22[4];
        uint64_t v25 = *((unsigned __int8 *)v22 + 55);
        int v26 = (char)v25;
        if ((v25 & 0x80u) != 0) {
          uint64_t v25 = v22[5];
        }
        if (v26 >= 0) {
          long long v24 = (const char *)(v22 + 4);
        }
        if (v25) {
          xpc_object_t v27 = v24;
        }
        else {
          xpc_object_t v27 = "<invalid>";
        }
        uint64_t v28 = asStringBool(*((unsigned char *)v22 + 56));
        uint64_t v29 = asStringBool(*((unsigned char *)v22 + 57));
        *(_DWORD *)std::string buf = 136315650;
        uint64_t v41 = (uint64_t)v27;
        __int16 v42 = 2080;
        xpc_object_t v43 = (void *)v28;
        __int16 v44 = 2080;
        uint64_t v45 = v29;
        _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "#I [d] -->Personality: %s, Status: [IMS registered for SMS: %s, Is over Internet: %s]", buf, 0x20u);
      }
      char v30 = (void *)v22[1];
      if (v30)
      {
        do
        {
          uint64_t v31 = v30;
          char v30 = (void *)*v30;
        }
        while (v30);
      }
      else
      {
        do
        {
          uint64_t v31 = (void *)v22[2];
          BOOL v19 = *v31 == (void)v22;
          int v22 = v31;
        }
        while (!v19);
      }
      int v22 = v31;
    }
    while (v31 != (void *)(a1 + 2016));
  }
  int v32 = *(unsigned __int8 *)(a1 + 2064);
  int v33 = *(NSObject **)(a1 + 40);
  BOOL v34 = os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT);
  if (v32)
  {
    if (!v34) {
      return;
    }
    uint64_t v35 = subscriber::asString();
    xpc_object_t v36 = (void *)(a1 + 2040);
    if (*(char *)(a1 + 2063) < 0) {
      xpc_object_t v36 = (void *)*v36;
    }
    *(_DWORD *)std::string buf = 136315394;
    uint64_t v41 = v35;
    __int16 v42 = 2082;
    xpc_object_t v43 = v36;
    xpc_object_t v37 = "#I [d] Active setting: [slot: %s, interface: %{public}s]";
    xpc_object_t v38 = v33;
    uint32_t v39 = 22;
  }
  else
  {
    if (!v34) {
      return;
    }
    *(_WORD *)std::string buf = 0;
    xpc_object_t v37 = "#I [d] Active setting: <none>";
    xpc_object_t v38 = v33;
    uint32_t v39 = 2;
  }
  _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_DEFAULT, v37, buf, v39);
}

void sub_1004F47BC(uint64_t a1, int a2)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 24));
  int v4 = *(unsigned __int8 *)(a1 + 48);
  if (v4 != a2)
  {
    int v5 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      int v6 = "yes";
      if (!v4) {
        int v6 = "no";
      }
      int v7 = 136315138;
      char v8 = v6;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Emergency call in progress: %s", (uint8_t *)&v7, 0xCu);
    }
    dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 24));
    sub_1004F5C9C(a1, 0, 0);
  }
}

void sub_1004F48A8(uint64_t a1, int a2)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 24));
  if (*(_DWORD *)(a1 + 52) != a2)
  {
    int v4 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      int v5 = 136315138;
      uint64_t v6 = asString();
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Airplane mode user preference: %s", (uint8_t *)&v5, 0xCu);
    }
    dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 24));
    sub_1004F5C9C(a1, 0, 0);
  }
}

void sub_1004F4984(uint64_t a1, void *a2)
{
  uint64_t v3 = *(void **)(a1 + 56);
  if (*(void *)(a1 + 72) == a2[2])
  {
    uint64_t v4 = a1 + 64;
    if (v3 == (void *)(a1 + 64)) {
      return;
    }
    int v5 = (void *)*a2;
    while (*((_DWORD *)v3 + 8) == *((_DWORD *)v5 + 8) && operator==())
    {
      uint64_t v6 = (void *)v3[1];
      int v7 = v3;
      if (v6)
      {
        do
        {
          uint64_t v3 = v6;
          uint64_t v6 = (void *)*v6;
        }
        while (v6);
      }
      else
      {
        do
        {
          uint64_t v3 = (void *)v7[2];
          BOOL v8 = *v3 == (void)v7;
          int v7 = v3;
        }
        while (!v8);
      }
      uint64_t v9 = (void *)v5[1];
      if (v9)
      {
        do
        {
          unsigned int v10 = v9;
          uint64_t v9 = (void *)*v9;
        }
        while (v9);
      }
      else
      {
        do
        {
          unsigned int v10 = (void *)v5[2];
          BOOL v8 = *v10 == (void)v5;
          int v5 = v10;
        }
        while (!v8);
      }
      int v5 = v10;
      if (v3 == (void *)v4) {
        return;
      }
    }
    uint64_t v3 = *(void **)(a1 + 56);
  }
  uint64_t v47 = 0;
  uint64_t v48 = 0;
  __int16 v46 = &v47;
  if (v3 != (void *)(a1 + 64))
  {
    while (1)
    {
      uint64_t v11 = (void **)(v3 + 5);
      if (*((char *)v3 + 63) < 0)
      {
        unint64_t v12 = v3[6];
        if (v12)
        {
          sub_10004FC84(buf, *v11, v12);
          goto LABEL_25;
        }
      }
      else if (*((unsigned char *)v3 + 63))
      {
        *(_OWORD *)std::string buf = *(_OWORD *)v11;
        *(void *)&uint8_t buf[16] = v3[7];
LABEL_25:
        uint64_t v13 = v47;
        uint64_t v14 = &v47;
        uint64_t v15 = &v47;
        if (v47)
        {
          int v16 = *((_DWORD *)v3 + 8);
          do
          {
            while (1)
            {
              uint64_t v15 = (uint64_t **)v13;
              int v17 = *((_DWORD *)v13 + 8);
              if (v17 <= v16) {
                break;
              }
              uint64_t v13 = *v15;
              uint64_t v14 = v15;
              if (!*v15) {
                goto LABEL_34;
              }
            }
            if (v17 >= v16)
            {
              BOOL v19 = (char *)v15;
              goto LABEL_37;
            }
            uint64_t v13 = v15[1];
          }
          while (v13);
          uint64_t v14 = v15 + 1;
        }
LABEL_34:
        BOOL v19 = (char *)operator new(0x40uLL);
        *((_DWORD *)v19 + 8) = *((_DWORD *)v3 + 8);
        *((void *)v19 + 6) = 0;
        *((void *)v19 + 7) = 0;
        *((void *)v19 + 5) = 0;
        *(void *)BOOL v19 = 0;
        *((void *)v19 + 1) = 0;
        *((void *)v19 + 2) = v15;
        NSObject *v14 = (uint64_t *)v19;
        xpc_object_t v18 = (uint64_t *)v19;
        if (*v46)
        {
          __int16 v46 = (uint64_t **)*v46;
          xpc_object_t v18 = *v14;
        }
        sub_100046C90(v47, v18);
        ++v48;
LABEL_37:
        uint64_t v20 = (void **)(v19 + 40);
        if (v19[63] < 0) {
          operator delete(*v20);
        }
        *(_OWORD *)uint64_t v20 = *(_OWORD *)buf;
        *((void *)v19 + 7) = *(void *)&buf[16];
      }
      uint64_t v21 = (void *)v3[1];
      if (v21)
      {
        do
        {
          int v22 = v21;
          uint64_t v21 = (void *)*v21;
        }
        while (v21);
      }
      else
      {
        do
        {
          int v22 = (void *)v3[2];
          BOOL v8 = *v22 == (void)v3;
          uint64_t v3 = v22;
        }
        while (!v8);
      }
      uint64_t v3 = v22;
      if (v22 == (void *)(a1 + 64))
      {
        uint64_t v23 = v48;
        goto LABEL_48;
      }
    }
  }
  uint64_t v23 = 0;
LABEL_48:
  if (v23 != *(void *)(a1 + 2000)) {
    goto LABEL_79;
  }
  long long v24 = v46;
  if (v46 != &v47)
  {
    uint64_t v25 = *(void **)(a1 + 1984);
    while (*((_DWORD *)v24 + 8) == *((_DWORD *)v25 + 8))
    {
      uint64_t v26 = *((unsigned __int8 *)v24 + 63);
      if ((v26 & 0x80u) == 0) {
        xpc_object_t v27 = (uint64_t *)*((unsigned __int8 *)v24 + 63);
      }
      else {
        xpc_object_t v27 = v24[6];
      }
      uint64_t v28 = (uint64_t *)*((unsigned __int8 *)v25 + 63);
      int v29 = (char)v28;
      if ((char)v28 < 0) {
        uint64_t v28 = (uint64_t *)v25[6];
      }
      if (v27 != v28) {
        break;
      }
      char v30 = (const void **)(v24 + 5);
      if (v29 >= 0) {
        uint64_t v31 = (unsigned __int8 *)(v25 + 5);
      }
      else {
        uint64_t v31 = (unsigned __int8 *)v25[5];
      }
      if ((v26 & 0x80) != 0)
      {
        if (memcmp(*v30, v31, (size_t)v24[6])) {
          break;
        }
      }
      else if (*((unsigned char *)v24 + 63))
      {
        while (*(unsigned __int8 *)v30 == *v31)
        {
          char v30 = (const void **)((char *)v30 + 1);
          ++v31;
          if (!--v26) {
            goto LABEL_67;
          }
        }
        break;
      }
LABEL_67:
      int v32 = v24[1];
      if (v32)
      {
        do
        {
          int v33 = (uint64_t **)v32;
          int v32 = (uint64_t *)*v32;
        }
        while (v32);
      }
      else
      {
        do
        {
          int v33 = (uint64_t **)v24[2];
          BOOL v8 = *v33 == (uint64_t *)v24;
          long long v24 = v33;
        }
        while (!v8);
      }
      BOOL v34 = (void *)v25[1];
      if (v34)
      {
        do
        {
          uint64_t v35 = v34;
          BOOL v34 = (void *)*v34;
        }
        while (v34);
      }
      else
      {
        do
        {
          uint64_t v35 = (void *)v25[2];
          BOOL v8 = *v35 == (void)v25;
          uint64_t v25 = v35;
        }
        while (!v8);
      }
      uint64_t v25 = v35;
      long long v24 = v33;
      if (v33 == &v47) {
        goto LABEL_96;
      }
    }
LABEL_79:
    xpc_object_t v36 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)std::string buf = 134217984;
      *(void *)&uint8_t buf[4] = v23;
      _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_DEFAULT, "#I Cellular Internet configs changed [count: %zu]", buf, 0xCu);
    }
    xpc_object_t v37 = v46;
    if (v46 != &v47)
    {
      do
      {
        xpc_object_t v38 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v39 = subscriber::asString();
          xpc_object_t v40 = v37 + 5;
          if (*((char *)v37 + 63) < 0) {
            xpc_object_t v40 = (void *)*v40;
          }
          *(_DWORD *)std::string buf = 136315394;
          *(void *)&uint8_t buf[4] = v39;
          *(_WORD *)&unsigned char buf[12] = 2080;
          *(void *)&buf[14] = v40;
          _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_DEFAULT, "#I -->Slot: %s, Config: [interface name %s]", buf, 0x16u);
        }
        uint64_t v41 = v37[1];
        if (v41)
        {
          do
          {
            __int16 v42 = (uint64_t **)v41;
            uint64_t v41 = (uint64_t *)*v41;
          }
          while (v41);
        }
        else
        {
          do
          {
            __int16 v42 = (uint64_t **)v37[2];
            BOOL v8 = *v42 == (uint64_t *)v37;
            xpc_object_t v37 = v42;
          }
          while (!v8);
        }
        xpc_object_t v37 = v42;
      }
      while (v42 != &v47);
    }
    uint64_t v43 = a1 + 1992;
    sub_10026D080(*(char **)(a1 + 1992));
    __int16 v44 = v47;
    *(void *)(a1 + 1984) = v46;
    *(void *)(a1 + 1992) = v44;
    uint64_t v45 = v48;
    *(void *)(a1 + 2000) = v48;
    if (v45)
    {
      v44[2] = v43;
      uint64_t v47 = 0;
      uint64_t v48 = 0;
    }
    else
    {
      *(void *)(a1 + 1984) = v43;
    }
    sub_1004F57E8(a1);
  }
LABEL_96:
  sub_10026D080((char *)v47);
}

void sub_1004F4E64(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char *a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
}

void sub_1004F4E98(uint64_t a1, unsigned __int8 **a2)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 24));
  if (*(unsigned __int8 **)(a1 + 96) == a2[2])
  {
    uint64_t v4 = *(unsigned __int8 **)(a1 + 80);
    if (v4 == (unsigned __int8 *)(a1 + 88)) {
      return;
    }
    int v5 = *a2;
    while (sub_10001D294(v4 + 32, v5 + 32) && sub_10047161C((uint64_t)(v4 + 56), (uint64_t)(v5 + 56)))
    {
      uint64_t v6 = (unsigned __int8 *)*((void *)v4 + 1);
      int v7 = v4;
      if (v6)
      {
        do
        {
          uint64_t v4 = v6;
          uint64_t v6 = *(unsigned __int8 **)v6;
        }
        while (v6);
      }
      else
      {
        do
        {
          uint64_t v4 = (unsigned __int8 *)*((void *)v7 + 2);
          BOOL v8 = *(void *)v4 == (void)v7;
          int v7 = v4;
        }
        while (!v8);
      }
      uint64_t v9 = (unsigned __int8 *)*((void *)v5 + 1);
      if (v9)
      {
        do
        {
          unsigned int v10 = v9;
          uint64_t v9 = *(unsigned __int8 **)v9;
        }
        while (v9);
      }
      else
      {
        do
        {
          unsigned int v10 = (unsigned __int8 *)*((void *)v5 + 2);
          BOOL v8 = *(void *)v10 == (void)v5;
          int v5 = v10;
        }
        while (!v8);
      }
      int v5 = v10;
      if (v4 == (unsigned __int8 *)(a1 + 88)) {
        return;
      }
    }
  }
  __int16 v46 = 0;
  uint64_t v47 = 0;
  uint64_t v45 = &v46;
  uint64_t v11 = *(void **)(a1 + 80);
  if (v11 == (void *)(a1 + 88))
  {
    long long v24 = 0;
  }
  else
  {
    do
    {
      if (*((_DWORD *)v11 + 14) == 1) {
        int v12 = (*((unsigned __int8 *)v11 + 60) >> 1) & 1;
      }
      else {
        LOBYTE(v12) = 0;
      }
      char v13 = *((unsigned char *)v11 + 64);
      uint64_t v14 = v46;
      uint64_t v15 = (void **)&v46;
      int v16 = &v46;
      if (!v46) {
        goto LABEL_31;
      }
      uint64_t v15 = (void **)&v46;
      while (1)
      {
        while (1)
        {
          int v16 = (uint64_t **)v14;
          int v17 = v14 + 4;
          if ((sub_100046FE8(v11 + 4, (void **)v14 + 4) & 0x80) == 0) {
            break;
          }
          uint64_t v14 = *v16;
          uint64_t v15 = (void **)v16;
          if (!*v16) {
            goto LABEL_31;
          }
        }
        if ((sub_100046FE8(v17, (void **)v11 + 4) & 0x80) == 0) {
          break;
        }
        uint64_t v15 = (void **)(v16 + 1);
        uint64_t v14 = v16[1];
        if (!v14) {
          goto LABEL_31;
        }
      }
      xpc_object_t v18 = (char *)*v15;
      if (!*v15)
      {
LABEL_31:
        xpc_object_t v18 = (char *)operator new(0x40uLL);
        BOOL v19 = v18 + 32;
        if (*((char *)v11 + 55) < 0)
        {
          sub_10004FC84(v19, (void *)v11[4], v11[5]);
        }
        else
        {
          long long v20 = *((_OWORD *)v11 + 2);
          *((void *)v18 + 6) = v11[6];
          *(_OWORD *)BOOL v19 = v20;
        }
        *((_WORD *)v18 + 28) = 0;
        *(void *)xpc_object_t v18 = 0;
        *((void *)v18 + 1) = 0;
        *((void *)v18 + 2) = v16;
        *uint64_t v15 = v18;
        uint64_t v21 = (uint64_t *)v18;
        if (*v45)
        {
          uint64_t v45 = (uint64_t **)*v45;
          uint64_t v21 = (uint64_t *)*v15;
        }
        sub_100046C90(v46, v21);
        ++v47;
      }
      v18[56] = v12;
      v18[57] = v13;
      int v22 = (void *)v11[1];
      if (v22)
      {
        do
        {
          uint64_t v23 = v22;
          int v22 = (void *)*v22;
        }
        while (v22);
      }
      else
      {
        do
        {
          uint64_t v23 = (void *)v11[2];
          BOOL v8 = *v23 == (void)v11;
          uint64_t v11 = v23;
        }
        while (!v8);
      }
      uint64_t v11 = v23;
    }
    while (v23 != (void *)(a1 + 88));
    long long v24 = v47;
  }
  if (v24 != *(const char **)(a1 + 2024)) {
    goto LABEL_63;
  }
  uint64_t v25 = v45;
  if (v45 != &v46)
  {
    uint64_t v26 = *(unsigned __int8 **)(a1 + 2008);
    while (sub_10001D294((unsigned __int8 *)v25 + 32, v26 + 32)
         && *((unsigned __int8 *)v25 + 56) == v26[56]
         && *((unsigned __int8 *)v25 + 57) == v26[57])
    {
      xpc_object_t v27 = v25[1];
      uint64_t v28 = v25;
      if (v27)
      {
        do
        {
          uint64_t v25 = (uint64_t **)v27;
          xpc_object_t v27 = (uint64_t *)*v27;
        }
        while (v27);
      }
      else
      {
        do
        {
          uint64_t v25 = (uint64_t **)v28[2];
          BOOL v8 = *v25 == (uint64_t *)v28;
          uint64_t v28 = v25;
        }
        while (!v8);
      }
      int v29 = (unsigned __int8 *)*((void *)v26 + 1);
      if (v29)
      {
        do
        {
          char v30 = v29;
          int v29 = *(unsigned __int8 **)v29;
        }
        while (v29);
      }
      else
      {
        do
        {
          char v30 = (unsigned __int8 *)*((void *)v26 + 2);
          BOOL v8 = *(void *)v30 == (void)v26;
          uint64_t v26 = v30;
        }
        while (!v8);
      }
      uint64_t v26 = v30;
      if (v25 == &v46) {
        goto LABEL_85;
      }
    }
LABEL_63:
    uint64_t v31 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)std::string buf = 134217984;
      char v49 = v47;
      _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "#I IMS Registration State changed: [count: %zu]", buf, 0xCu);
    }
    int v32 = v45;
    if (v45 != &v46)
    {
      do
      {
        int v33 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
        {
          BOOL v34 = (const char *)v32[4];
          uint64_t v35 = (uint64_t *)*((unsigned __int8 *)v32 + 55);
          int v36 = (char)v35;
          if ((char)v35 < 0) {
            uint64_t v35 = v32[5];
          }
          if (v36 >= 0) {
            BOOL v34 = (const char *)(v32 + 4);
          }
          if (v35) {
            xpc_object_t v37 = v34;
          }
          else {
            xpc_object_t v37 = "<invalid>";
          }
          uint64_t v38 = asStringBool(*((unsigned char *)v32 + 56));
          uint64_t v39 = asStringBool(*((unsigned char *)v32 + 57));
          *(_DWORD *)std::string buf = 136315650;
          char v49 = v37;
          __int16 v50 = 2080;
          uint64_t v51 = v38;
          __int16 v52 = 2080;
          uint64_t v53 = v39;
          _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "#I -->Personality: %s, Status: [IMS registered for SMS: %s, Is over Internet: %s]", buf, 0x20u);
        }
        xpc_object_t v40 = v32[1];
        if (v40)
        {
          do
          {
            uint64_t v41 = (uint64_t **)v40;
            xpc_object_t v40 = (uint64_t *)*v40;
          }
          while (v40);
        }
        else
        {
          do
          {
            uint64_t v41 = (uint64_t **)v32[2];
            BOOL v8 = *v41 == (uint64_t *)v32;
            int v32 = v41;
          }
          while (!v8);
        }
        int v32 = v41;
      }
      while (v41 != &v46);
    }
    uint64_t v42 = a1 + 2016;
    sub_1000DA2E4(*(char **)(a1 + 2016));
    uint64_t v43 = v46;
    *(void *)(a1 + 2008) = v45;
    *(void *)(a1 + 2016) = v43;
    __int16 v44 = v47;
    *(void *)(a1 + 2024) = v47;
    if (v44)
    {
      v43[2] = v42;
      __int16 v46 = 0;
      uint64_t v47 = 0;
    }
    else
    {
      *(void *)(a1 + 2008) = v42;
    }
    dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 24));
    sub_1004F5C9C(a1, 0, 0);
  }
LABEL_85:
  sub_1000DA2E4((char *)v46);
}

void sub_1004F537C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char *a13)
{
}

void sub_1004F53A8(uint64_t a1, int a2)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 24));
  if (*(_DWORD *)(a1 + 104) != a2)
  {
    uint64_t v4 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      int v5 = 136315138;
      uint64_t v6 = subscriber::asString();
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I PreferredDataSim: %s", (uint8_t *)&v5, 0xCu);
    }
    sub_1004F5C9C(a1, 1, 0);
  }
}

void sub_1004F547C(uint64_t a1, const RegisteredNetworkInfo *a2)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 24));
  OsLogContext __p = 0;
  uint64_t v11 = 0;
  uint64_t v12 = 0;
  RegisteredNetworkInfo::compare((uint64_t *)&__p, (RegisteredNetworkInfo *)(a1 + 912), a2);
  uint64_t v4 = __p;
  int v5 = __p;
  if (__p != v11)
  {
    int v5 = __p;
LABEL_3:
    uint64_t v6 = 0;
    while (*v5 != dword_1014B19B4[v6])
    {
      if (++v6 == 2)
      {
        if (++v5 != v11) {
          goto LABEL_3;
        }
        goto LABEL_12;
      }
    }
  }
  if (v5 != v11)
  {
    int v7 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v8 = asString();
      uint64_t v9 = asStringBool(*(unsigned char *)(a1 + 1708));
      *(_DWORD *)std::string buf = 136315394;
      uint64_t v14 = v8;
      __int16 v15 = 2080;
      uint64_t v16 = v9;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I RegNetInfo2 changed. RegistrationStatus: %s, IsSatelliteSystem: %s", buf, 0x16u);
    }
    dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 24));
    sub_1004F5C9C(a1, 0, 0);
    sub_1004F57E8(a1);
    uint64_t v4 = __p;
  }
LABEL_12:
  if (v4)
  {
    uint64_t v11 = v4;
    operator delete(v4);
  }
}

void sub_1004F55E8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1004F5610(uint64_t a1, uint64_t a2)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 24));
  if ((sub_1004F6074((void *)(a1 + 1712), a2) & 1) == 0)
  {
    uint64_t v4 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      int v5 = *(const char **)(a1 + 1728);
      *(_DWORD *)std::string buf = 134217984;
      int v17 = v5;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Satellite support changed: [count: %zu]", buf, 0xCu);
    }
    uint64_t v6 = *(void **)(a1 + 1712);
    if (v6 != (void *)(a1 + 1720))
    {
      do
      {
        int v7 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v8 = (const char *)v6[4];
          uint64_t v9 = *((unsigned __int8 *)v6 + 55);
          int v10 = (char)v9;
          if ((v9 & 0x80u) != 0) {
            uint64_t v9 = v6[5];
          }
          if (v10 >= 0) {
            uint64_t v8 = (const char *)(v6 + 4);
          }
          if (v9) {
            uint64_t v11 = v8;
          }
          else {
            uint64_t v11 = "<invalid>";
          }
          uint64_t v12 = asStringBool(*((unsigned char *)v6 + 56));
          *(_DWORD *)std::string buf = 136315394;
          int v17 = v11;
          __int16 v18 = 2080;
          uint64_t v19 = v12;
          _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I -->\t[Personality: %s] Satellite support changed to: %s", buf, 0x16u);
        }
        char v13 = (void *)v6[1];
        if (v13)
        {
          do
          {
            uint64_t v14 = v13;
            char v13 = (void *)*v13;
          }
          while (v13);
        }
        else
        {
          do
          {
            uint64_t v14 = (void *)v6[2];
            BOOL v15 = *v14 == (void)v6;
            uint64_t v6 = v14;
          }
          while (!v15);
        }
        uint64_t v6 = v14;
      }
      while (v14 != (void *)(a1 + 1720));
    }
    dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 24));
    sub_1004F5C9C(a1, 0, 0);
  }
}

void sub_1004F57E8(uint64_t a1)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 24));
  uint64_t v35 = 0;
  *(_OWORD *)__s1 = 0u;
  *(_OWORD *)__n = 0u;
  int v2 = *(_DWORD *)(a1 + 104);
  if ((v2 - 1) >= 2)
  {
    if (!*(unsigned char *)(a1 + 2064)) {
      return;
    }
    uint64_t v14 = (unsigned char *)(a1 + 2064);
    char v13 = (unsigned int *)(a1 + 2032);
    goto LABEL_54;
  }
  if (*(unsigned char *)(a1 + 1963)) {
    BOOL v3 = *(unsigned char *)(a1 + 1962) == 0;
  }
  else {
    BOOL v3 = 0;
  }
  if (v3)
  {
    memset(__p, 0, sizeof(__p));
    char v37 = 1;
    sub_1004F6A18((uint64_t)__s1, (uint64_t)__p);
    if (v37 && SHIBYTE(__p[3]) < 0) {
      operator delete(__p[1]);
    }
    int v2 = *(_DWORD *)(a1 + 104);
    LODWORD(__s1[0]) = v2;
  }
  uint64_t v4 = a1 + 1992;
  uint64_t v5 = *(void *)(a1 + 1992);
  if (!v5) {
    goto LABEL_21;
  }
  uint64_t v6 = a1 + 1992;
  do
  {
    int v7 = *(_DWORD *)(v5 + 32);
    BOOL v8 = v7 < v2;
    if (v7 >= v2) {
      uint64_t v9 = (uint64_t *)v5;
    }
    else {
      uint64_t v9 = (uint64_t *)(v5 + 8);
    }
    if (!v8) {
      uint64_t v6 = v5;
    }
    uint64_t v5 = *v9;
  }
  while (*v9);
  if (v6 == v4 || v2 < *(_DWORD *)(v6 + 32)) {
LABEL_21:
  }
    uint64_t v6 = a1 + 1992;
  if (v2 == 2) {
    uint64_t v10 = a1 + 912;
  }
  else {
    uint64_t v10 = a1 + 112;
  }
  int v11 = v35;
  if (*(unsigned char *)(v10 + 796)) {
    BOOL v12 = v6 == v4;
  }
  else {
    BOOL v12 = 1;
  }
  if (!v12)
  {
    if (!(_BYTE)v35)
    {
      memset(__p, 0, sizeof(__p));
      char v37 = 1;
      sub_1004F6A18((uint64_t)__s1, (uint64_t)__p);
      if (v37)
      {
        if (SHIBYTE(__p[3]) < 0) {
          operator delete(__p[1]);
        }
      }
    }
    std::string::operator=((std::string *)&__s1[1], (const std::string *)(v6 + 40));
    int v11 = v35;
  }
  char v13 = (unsigned int *)(a1 + 2032);
  uint64_t v14 = (unsigned char *)(a1 + 2064);
  int v15 = *(unsigned __int8 *)(a1 + 2064);
  if (!v11 || !*(unsigned char *)(a1 + 2064))
  {
    if ((v11 != 0) == (v15 != 0)) {
      goto LABEL_91;
    }
    if (v11) {
      goto LABEL_64;
    }
LABEL_54:
    int v22 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(__p[0]) = 0;
      _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "#I Active setting changed to <none>", (uint8_t *)__p, 2u);
    }
    sub_1004F6574(a1, v13, 0);
    sub_1004F67BC(a1, (uint64_t)v13, 0);
    if (*v14)
    {
      if (*(char *)(a1 + 2063) < 0) {
        operator delete(*(void **)(a1 + 2040));
      }
      unsigned char *v14 = 0;
    }
    goto LABEL_90;
  }
  if (LODWORD(__s1[0]) != *v13) {
    goto LABEL_63;
  }
  uint64_t v16 = HIBYTE(__n[1]);
  if ((__n[1] & 0x8000000000000000) == 0) {
    size_t v17 = HIBYTE(__n[1]);
  }
  else {
    size_t v17 = __n[0];
  }
  uint64_t v18 = *(unsigned __int8 *)(a1 + 2063);
  int v19 = (char)v18;
  if ((v18 & 0x80u) != 0) {
    uint64_t v18 = *(void *)(a1 + 2048);
  }
  if (v17 != v18)
  {
LABEL_63:
    int v15 = 1;
    goto LABEL_64;
  }
  if (v19 >= 0) {
    long long v20 = (unsigned __int8 *)(a1 + 2040);
  }
  else {
    long long v20 = *(unsigned __int8 **)(a1 + 2040);
  }
  if ((__n[1] & 0x8000000000000000) != 0)
  {
    int v32 = memcmp(__s1[1], v20, __n[0]);
    int v15 = 1;
    int v11 = 1;
    if (!v32) {
      goto LABEL_91;
    }
LABEL_64:
    uint64_t v23 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
    {
      long long v24 = (void *)subscriber::asString();
      uint64_t v25 = &__s1[1];
      if ((__n[1] & 0x8000000000000000) != 0) {
        uint64_t v25 = (void **)__s1[1];
      }
      LODWORD(__p[0]) = 136315394;
      *(void **)((char *)__p + 4) = v24;
      WORD2(__p[1]) = 2082;
      *(void **)((char *)&__p[1] + 6) = v25;
      _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "#I Active setting changed to [slot: %s, interface: %{public}s]", (uint8_t *)__p, 0x16u);
      int v15 = *v14;
    }
    if (v15)
    {
      if (LODWORD(__s1[0]) != *v13)
      {
        sub_1004F6574(a1, (unsigned int *)(a1 + 2032), 0);
        sub_1004F6574(a1, (unsigned int *)__s1, 1);
      }
      uint64_t v26 = HIBYTE(__n[1]);
      if ((__n[1] & 0x8000000000000000) == 0) {
        size_t v27 = HIBYTE(__n[1]);
      }
      else {
        size_t v27 = __n[0];
      }
      uint64_t v28 = *(unsigned __int8 *)(a1 + 2063);
      int v29 = (char)v28;
      if ((v28 & 0x80u) != 0) {
        uint64_t v28 = *(void *)(a1 + 2048);
      }
      if (v27 == v28)
      {
        if (v29 >= 0) {
          char v30 = (unsigned __int8 *)(a1 + 2040);
        }
        else {
          char v30 = *(unsigned __int8 **)(a1 + 2040);
        }
        if ((__n[1] & 0x8000000000000000) == 0)
        {
          if (HIBYTE(__n[1]))
          {
            uint64_t v31 = &__s1[1];
            while (*(unsigned __int8 *)v31 == *v30)
            {
              uint64_t v31 = (void **)((char *)v31 + 1);
              ++v30;
              if (!--v26) {
                goto LABEL_89;
              }
            }
            goto LABEL_88;
          }
LABEL_89:
          sub_1004F6A18(a1 + 2032, (uint64_t)__s1);
LABEL_90:
          int v11 = v35;
          goto LABEL_91;
        }
        if (!memcmp(__s1[1], v30, __n[0])) {
          goto LABEL_89;
        }
      }
LABEL_88:
      sub_1004F67BC(a1, a1 + 2032, 0);
      sub_1004F67BC(a1, (uint64_t)__s1, 1);
      goto LABEL_89;
    }
    sub_1004F6574(a1, (unsigned int *)__s1, 1);
    sub_1004F67BC(a1, (uint64_t)__s1, 1);
    goto LABEL_89;
  }
  if (HIBYTE(__n[1]))
  {
    uint64_t v21 = &__s1[1];
    while (*(unsigned __int8 *)v21 == *v20)
    {
      uint64_t v21 = (void **)((char *)v21 + 1);
      ++v20;
      int v11 = 1;
      if (!--v16) {
        goto LABEL_91;
      }
    }
    goto LABEL_63;
  }
  int v11 = 1;
LABEL_91:
  if (v11)
  {
    if (SHIBYTE(__n[1]) < 0) {
      operator delete(__s1[1]);
    }
  }
}

void sub_1004F5C70(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16)
{
  if (a16)
  {
    if (a15 < 0) {
      operator delete(__p);
    }
  }
  _Unwind_Resume(exception_object);
}

void sub_1004F5C9C(uint64_t a1, int a2, int a3)
{
  uint64_t v6 = a1 + 24;
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 24));
  dispatch_assert_queue_V2(*(dispatch_queue_t *)v6);
  int v7 = *(uint64_t ***)(v6 + 1920);
  BOOL v8 = *v7;
  uint64_t v9 = v7[1];
  if (v8 != v9)
  {
    while (*(unsigned char *)(*v8 + 49) || *(_DWORD *)(*v8 + 52) != *(_DWORD *)(v6 + 80))
    {
      v8 += 2;
      if (v8 == v9) {
        goto LABEL_15;
      }
    }
  }
  if (v8 == v9)
  {
LABEL_15:
    LODWORD(v11) = 0;
    int v12 = 1;
  }
  else
  {
    uint64_t v11 = *v8;
    uint64_t v10 = (std::__shared_weak_count *)v8[1];
    if (v10) {
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    if (!v11)
    {
LABEL_13:
      int v12 = 1;
      if (!v10) {
        goto LABEL_16;
      }
      goto LABEL_14;
    }
    if (*(unsigned char *)(v11 + 49)
      || *(unsigned char *)(v11 + 62)
      || !*(unsigned char *)(v11 + 48)
      || (*(_DWORD *)(v11 + 52) - 1) > 1
      || (uint64_t v21 = sub_100046F68(a1 + 1712, (void **)(v11 + 24)), (void **)(a1 + 1720) == v21)
      || !*((unsigned char *)v21 + 56)
      || *(unsigned char *)(a1 + 48)
      || *(_DWORD *)(a1 + 52) == 2
      || !*(unsigned char *)(a1 + 1961))
    {
      LODWORD(v11) = 0;
      goto LABEL_13;
    }
    if (*(unsigned char *)(a1 + 1960))
    {
      LODWORD(v11) = 1;
      goto LABEL_13;
    }
    int v12 = 0;
    LODWORD(v11) = sub_1004F6128(a1, v11) ^ 1;
    if (v10) {
LABEL_14:
    }
      sub_10004D2C8(v10);
  }
LABEL_16:
  int v13 = v11 ^ 1;
  if (a2)
  {
LABEL_17:
    sub_1004F6288(a1, v13);
    return;
  }
  if (*(unsigned char *)(a1 + 1963) && *(unsigned __int8 *)(a1 + 1962) == v13)
  {
    sub_1004F6208(a1);
  }
  else
  {
    if (v11)
    {
      CFStringRef v14 = @"SatelliteSystemTransitionTimeToAllowed";
      int v15 = (Registry **)(a1 + 1736);
      uint64_t v16 = 60;
    }
    else
    {
      CFStringRef v14 = @"SatelliteSystemTransitionTimeToNotAllowed";
      int v15 = (Registry **)(a1 + 1736);
      uint64_t v16 = 900;
    }
    uint64_t v17 = sub_1004F6384(v15, *(unsigned int *)(a1 + 104), (uint64_t)v14, v16);
    if (v12 || a3) {
      goto LABEL_17;
    }
    if (!*(void *)(a1 + 1968))
    {
      uint64_t v18 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(buf) = 134217984;
        *(void *)((char *)&buf + 4) = v17;
        _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#I Scheduling settling timer. Expires in: %lld seconds", (uint8_t *)&buf, 0xCu);
      }
      sub_100058DB0(&__p, "SatelliteSystemSettlingTimer");
      Registry::getTimerService(&v22, *(Registry **)(a1 + 1736));
      *(void *)&long long buf = off_1019DBCE0;
      *((void *)&buf + 1) = a1;
      uint64_t v28 = 1000 * v17;
      p_long long buf = &buf;
      AutoStartTimer::create();
      long long v19 = v26;
      long long v26 = 0uLL;
      long long v20 = *(std::__shared_weak_count **)(a1 + 1976);
      *(_OWORD *)(a1 + 1968) = v19;
      if (v20)
      {
        sub_10004D2C8(v20);
        if (*((void *)&v26 + 1)) {
          sub_10004D2C8(*((std::__shared_weak_count **)&v26 + 1));
        }
      }
      sub_10003B34C(&buf);
      if (v23) {
        sub_10004D2C8(v23);
      }
      if (v25 < 0) {
        operator delete(__p);
      }
    }
  }
}

void sub_1004F6020(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, uint64_t a18, uint64_t a19, char a20)
{
  if (v20) {
    sub_10004D2C8(v20);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1004F6074(void *a1, uint64_t a2)
{
  if (a1[2] == *(void *)(a2 + 16))
  {
    int v2 = (void **)(a1 + 1);
    BOOL v3 = (void **)*a1;
    if ((void *)*a1 == a1 + 1) {
      return 1;
    }
    uint64_t v5 = (void **)(a2 + 8);
    while (1)
    {
      uint64_t v6 = sub_100046F68(a2, v3 + 4);
      if (v5 == v6 || *((unsigned __int8 *)v6 + 56) != *((unsigned __int8 *)v3 + 56)) {
        break;
      }
      int v7 = (void **)v3[1];
      if (v7)
      {
        do
        {
          BOOL v8 = v7;
          int v7 = (void **)*v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          BOOL v8 = (void **)v3[2];
          BOOL v9 = *v8 == v3;
          BOOL v3 = v8;
        }
        while (!v9);
      }
      BOOL v3 = v8;
      if (v8 == v2) {
        return 1;
      }
    }
  }
  return 0;
}

uint64_t sub_1004F6128(uint64_t a1, uint64_t a2)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 24));
  uint64_t v4 = *(void **)(a1 + 2016);
  if (!v4) {
    goto LABEL_14;
  }
  uint64_t v5 = (void *)(a1 + 2016);
  do
  {
    char v6 = sub_100046FE8(v4 + 4, (void **)(a2 + 24));
    if (v6 >= 0) {
      int v7 = v4;
    }
    else {
      int v7 = v4 + 1;
    }
    if (v6 >= 0) {
      uint64_t v5 = v4;
    }
    uint64_t v4 = (void *)*v7;
  }
  while (*v7);
  if (v5 == (void *)(a1 + 2016)
    || (sub_100046FE8((void *)(a2 + 24), (void **)v5 + 4) & 0x80) != 0
    || !*((unsigned char *)v5 + 56))
  {
LABEL_14:
    LODWORD(result) = 0;
  }
  else
  {
    uint64_t result = 1;
    if (*((unsigned char *)v5 + 57)) {
      return result;
    }
  }
  if (*(_DWORD *)(a2 + 52) == 2) {
    uint64_t v9 = a1 + 912;
  }
  else {
    uint64_t v9 = a1 + 112;
  }
  if (*(unsigned char *)(v9 + 796)) {
    return 0;
  }
  if ((*(_DWORD *)(v9 + 8) & 0xFFFFFFFE) == 4) {
    return 1;
  }
  return result;
}

void sub_1004F6208(uint64_t a1)
{
  if (*(void *)(a1 + 1968))
  {
    int v2 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v4 = 0;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Stopped settling timer", v4, 2u);
    }
    BOOL v3 = *(std::__shared_weak_count **)(a1 + 1976);
    *(_OWORD *)(a1 + 1968) = 0u;
    if (v3) {
      sub_10004D2C8(v3);
    }
  }
}

void sub_1004F6288(uint64_t a1, __int16 a2)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 24));
  uint64_t v4 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    if (*(unsigned char *)(a1 + 1963)) {
      uint64_t v5 = (const char *)asString();
    }
    else {
      uint64_t v5 = "<none>";
    }
    int v6 = 136315394;
    int v7 = v5;
    __int16 v8 = 2080;
    uint64_t v9 = asString();
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Registration over sat plmns status: %s => %s", (uint8_t *)&v6, 0x16u);
  }
  *(_WORD *)(a1 + 1962) = a2 | 0x100;
  sub_1004F6208(a1);
  sub_1004F57E8(a1);
}

uint64_t sub_1004F6384(Registry **a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (!a3) {
    __TUAssertTrigger();
  }
  if ((a2 - 1) <= 1)
  {
    uint64_t v23 = 0;
    ServiceMap = (std::mutex *)Registry::getServiceMap(*a1);
    uint64_t v9 = ServiceMap;
    if ((v10 & 0x8000000000000000) != 0)
    {
      uint64_t v11 = (unsigned __int8 *)(v10 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v12 = 5381;
      do
      {
        unint64_t v10 = v12;
        unsigned int v13 = *v11++;
        uint64_t v12 = (33 * v12) ^ v13;
      }
      while (v13);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v24 = v10;
    CFStringRef v14 = sub_10004D37C(&v9[1].__m_.__sig, &v24);
    if (v14)
    {
      uint64_t v16 = v14[3];
      int v15 = (std::__shared_weak_count *)v14[4];
      if (v15)
      {
        atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v9);
        atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v15);
        char v17 = 0;
LABEL_12:
        (*(void (**)(const void **__return_ptr, uint64_t, uint64_t, uint64_t, uint64_t, void, void))(*(void *)v16 + 96))(&v22, v16, a2, 1, a3, 0, 0);
        sub_1000842D0(&v23, &v22);
        sub_1000577C4(&v22);
        if ((v17 & 1) == 0) {
          sub_10004D2C8(v15);
        }
        if (v23) {
          long long v19 = sub_100081E58;
        }
        else {
          long long v19 = 0;
        }
        if (v19 && (LODWORD(v24) = 0, ctu::cf::assign((ctu::cf *)&v24, v23, v18), uint64_t v20 = v24, v24))
        {
          sub_1000570E8((const void **)&v23);
          return v20;
        }
        else
        {
          sub_1000570E8((const void **)&v23);
        }
        return a4;
      }
    }
    else
    {
      uint64_t v16 = 0;
    }
    std::mutex::unlock(v9);
    int v15 = 0;
    char v17 = 1;
    goto LABEL_12;
  }
  return a4;
}

void sub_1004F6538(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sub_1000570E8((const void **)va);
  _Unwind_Resume(a1);
}

void sub_1004F6574(uint64_t a1, unsigned int *a2, int a3)
{
  if (*((unsigned char *)a2 + 32) && *a2 - 1 <= 1)
  {
    ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 1736));
    int v7 = ServiceMap;
    if (v8 < 0)
    {
      uint64_t v9 = (unsigned __int8 *)(v8 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v10 = 5381;
      do
      {
        uint64_t v8 = v10;
        unsigned int v11 = *v9++;
        uint64_t v10 = (33 * v10) ^ v11;
      }
      while (v11);
    }
    std::mutex::lock(ServiceMap);
    *(void *)uint64_t v21 = v8;
    uint64_t v12 = sub_10004D37C(&v7[1].__m_.__sig, (unint64_t *)v21);
    if (v12)
    {
      uint64_t v14 = v12[3];
      unsigned int v13 = (std::__shared_weak_count *)v12[4];
      if (v13)
      {
        atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v7);
        atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v13);
        char v15 = 0;
        if (!v14) {
          goto LABEL_9;
        }
        goto LABEL_13;
      }
    }
    else
    {
      uint64_t v14 = 0;
    }
    std::mutex::unlock(v7);
    unsigned int v13 = 0;
    char v15 = 1;
    if (!v14)
    {
LABEL_9:
      uint64_t v16 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)uint64_t v21 = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "RegistrationInterface not found", v21, 2u);
      }
LABEL_16:
      if ((v15 & 1) == 0) {
        sub_10004D2C8(v13);
      }
      return;
    }
LABEL_13:
    uint64_t v17 = a3 ^ 1u;
    CFNumberRef v18 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v19 = subscriber::asString();
      uint64_t v20 = asString();
      *(_DWORD *)uint64_t v21 = 136315394;
      *(void *)&v21[4] = v19;
      __int16 v22 = 2080;
      uint64_t v23 = v20;
      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#I Setting satellite system config for slot: %s [status: %s]", v21, 0x16u);
    }
    (*(void (**)(uint64_t, void, uint64_t))(*(void *)v14 + 520))(v14, *a2, v17);
    goto LABEL_16;
  }
}

void sub_1004F678C(_Unwind_Exception *exception_object)
{
  if ((v2 & 1) == 0) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_1004F67BC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(unsigned char *)(a2 + 32))
  {
    uint64_t v4 = *(unsigned __int8 *)(a2 + 31);
    if ((v4 & 0x80u) != 0) {
      uint64_t v4 = *(void *)(a2 + 16);
    }
    if (v4)
    {
      ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 1736));
      uint64_t v8 = ServiceMap;
      if (v9 < 0)
      {
        uint64_t v10 = (unsigned __int8 *)(v9 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v11 = 5381;
        do
        {
          uint64_t v9 = v11;
          unsigned int v12 = *v10++;
          uint64_t v11 = (33 * v11) ^ v12;
        }
        while (v12);
      }
      std::mutex::lock(ServiceMap);
      *(void *)uint64_t v20 = v9;
      unsigned int v13 = sub_10004D37C(&v8[1].__m_.__sig, (unint64_t *)v20);
      if (v13)
      {
        uint64_t v15 = v13[3];
        uint64_t v14 = (std::__shared_weak_count *)v13[4];
        if (v14)
        {
          atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v8);
          atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v14);
          char v16 = 0;
          goto LABEL_13;
        }
      }
      else
      {
        uint64_t v15 = 0;
      }
      std::mutex::unlock(v8);
      uint64_t v14 = 0;
      char v16 = 1;
LABEL_13:
      uint64_t v17 = *(NSObject **)(a1 + 40);
      if (v15)
      {
        if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v18 = *(void *)(a2 + 8);
          uint64_t v19 = "not ";
          if (*(char *)(a2 + 31) >= 0) {
            uint64_t v18 = a2 + 8;
          }
          if (a3) {
            uint64_t v19 = "";
          }
          *(_DWORD *)uint64_t v20 = 136446466;
          *(void *)&v20[4] = v18;
          __int16 v21 = 2080;
          __int16 v22 = v19;
          _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I Setting interface: %{public}s as %sultra constrained", v20, 0x16u);
        }
        (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v15 + 24))(v15, a2 + 8, a3);
      }
      else if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)uint64_t v20 = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "NetworkConfigInterface not found", v20, 2u);
        if (v16) {
          return;
        }
LABEL_23:
        sub_10004D2C8(v14);
        return;
      }
      if (v16) {
        return;
      }
      goto LABEL_23;
    }
  }
}

void sub_1004F69EC(_Unwind_Exception *exception_object)
{
  if ((v2 & 1) == 0) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

__n128 sub_1004F6A18(uint64_t a1, uint64_t a2)
{
  if (*(unsigned __int8 *)(a1 + 32) == *(unsigned __int8 *)(a2 + 32))
  {
    if (*(unsigned char *)(a1 + 32))
    {
      *(_DWORD *)a1 = *(_DWORD *)a2;
      uint64_t v4 = (void **)(a1 + 8);
      if (*(char *)(a1 + 31) < 0) {
        operator delete(*v4);
      }
      __n128 result = *(__n128 *)(a2 + 8);
      *(void *)(a1 + 24) = *(void *)(a2 + 24);
      *(__n128 *)uint64_t v4 = result;
      *(unsigned char *)(a2 + 31) = 0;
      *(unsigned char *)(a2 + 8) = 0;
    }
  }
  else if (*(unsigned char *)(a1 + 32))
  {
    if (*(char *)(a1 + 31) < 0) {
      operator delete(*(void **)(a1 + 8));
    }
    *(unsigned char *)(a1 + 32) = 0;
  }
  else
  {
    *(_DWORD *)a1 = *(_DWORD *)a2;
    __n128 result = *(__n128 *)(a2 + 8);
    *(void *)(a1 + 24) = *(void *)(a2 + 24);
    *(__n128 *)(a1 + 8) = result;
    *(void *)(a2 + 16) = 0;
    *(void *)(a2 + 24) = 0;
    *(void *)(a2 + 8) = 0;
    *(unsigned char *)(a1 + 32) = 1;
  }
  return result;
}

void sub_1004F6AD8(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_1004F6B10(uint64_t a1)
{
}

uint64_t sub_1004F6B2C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_1004F6B70(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 16))();
  }
  return result;
}

void sub_1004F6B9C(ServiceManager::Service *this)
{
  *(void *)this = off_1019DB478;
  char v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }

  ServiceManager::Service::~Service(this);
}

void sub_1004F6BF8(ServiceManager::Service *this)
{
  *(void *)this = off_1019DB478;
  char v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  ServiceManager::Service::~Service(this);

  operator delete();
}

void *sub_1004F6C68@<X0>(void *a1@<X8>)
{
  return sub_100058DB0(a1, "SatelliteSystem");
}

unsigned char *sub_1004F6C78@<X0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  char v2 = operator new(1uLL);
  *a1 = v2;
  unsigned char *v2 = 2;
  __n128 result = v2 + 1;
  a1[1] = result;
  a1[2] = result;
  return result;
}

void sub_1004F6CB8(uint64_t a1, dispatch_object_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  BOOL v3 = *a2;
  if (*a2)
  {
    dispatch_retain(*a2);
    dispatch_group_enter(v3);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(v2 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

uint64_t sub_1004F6DB8()
{
  return 0;
}

uint64_t sub_1004F6DC0()
{
  return 1;
}

uint64_t sub_1004F6DC8()
{
  return 0;
}

void sub_1004F6DD4(uint64_t a1)
{
  unsigned int v1 = *(std::__shared_weak_count **)(*(void *)(a1 + 8) + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_1004F6EB4(uint64_t a1, int a2, ServiceStage *this)
{
  uint64_t v3 = *(void *)(a1 + 8);
  ServiceStage::holdOffStage((uint64_t *)&group[1], this);
  uint64_t v4 = *(std::__shared_weak_count **)(v3 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_1004F6FC8(uint64_t **a1)
{
  uint64_t v1 = **a1;
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(v1 + 24));
  uint64_t v2 = *(NSObject **)(v1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(buf) = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Bootstrap", (uint8_t *)&buf, 2u);
  }
  Registry::createRestModuleOneTimeUseConnection(&v7, *(Registry **)(v1 + 1736));
  ctu::RestModule::connect();
  if (v8) {
    sub_10004D2C8(v8);
  }
  uint64_t v3 = operator new(0x20uLL);
  *uint64_t v3 = off_1019DB4F8;
  v3[1] = v1;
  v3[2] = sub_1004F4084;
  v3[3] = 0;
  uint64_t v18 = v3;
  unsigned int v13 = 0;
  v11[3] = 0;
  PersonalitiesTracker::bind();
  sub_100100490(v11);
  sub_10010040C(aBlock);
  sub_100100388(&buf);
  uint64_t v9 = 0;
  aBlock[0] = _NSConcreteStackBlock;
  aBlock[1] = 0x40000000;
  aBlock[2] = sub_1004F7CC4;
  unsigned int v13 = &unk_1019DB568;
  uint64_t v14 = v1 + 8;
  uint64_t v15 = sub_1004F4190;
  uint64_t v16 = 0;
  uint64_t v9 = _Block_copy(aBlock);
  uint64_t v4 = *(std::__shared_weak_count **)(v1 + 16);
  if (v4)
  {
    uint64_t v5 = std::__shared_weak_count::lock(v4);
    if (v5)
    {
      int v6 = v5;
      sub_1004F93C4(v10, &v9, *(dispatch_object_t *)(v1 + 24));
      sub_1004F940C(&buf, v10);
      atomic_fetch_add_explicit(&v6->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_1004F7790(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, char a20,uint64_t a21,uint64_t a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,void *__p,uint64_t a28,int a29,__int16 a30,char a31,char a32)
{
  if (a2)
  {
    sub_100163BC8((uint64_t)&a23);
    if (a22) {
      (*(void (**)(uint64_t))(*(void *)a22 + 8))(a22);
    }
    std::__shared_weak_count::__release_weak(v32);
    sub_1004F7D10(v33 - 112);
    sub_1004FA334((uint64_t)&a20);
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_1004F7908(uint64_t **a1)
{
  uint64_t v3 = a1;
  uint64_t v1 = **a1;
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(v1 + 24));
  uint64_t v2 = *(NSObject **)(v1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Starting", buf, 2u);
  }
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(v1 + 24));
  sub_1004F5C9C(v1, 0, 0);
  operator delete();
}

void sub_1004F79BC()
{
}

uint64_t *sub_1004F79E8(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v4 = a1;
  uint64_t v5 = v1;
  uint64_t v2 = *(void *)v1;
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(*(void *)v1 + 24));
  ctu::RestModule::disconnect((ctu::RestModule *)(v2 + 1752));
  sub_100088C88(&v5);
  return sub_100046B58((uint64_t *)&v4);
}

void sub_1004F7A38(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

void sub_1004F7A54(uint64_t **a1)
{
  uint64_t v4 = a1;
  uint64_t v1 = **a1;
  int v2 = *((unsigned __int8 *)*a1 + 8);
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(v1 + 24));
  if (*(unsigned __int8 *)(v1 + 1960) != v2)
  {
    *(unsigned char *)(v1 + 1960) = v2;
    uint64_t v3 = *(NSObject **)(v1 + 40);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 136315138;
      uint64_t v6 = asStringBool(v2 != 0);
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Force allow satellite systems changed to: %s", buf, 0xCu);
    }
    sub_1004F5C9C(v1, 1, 0);
  }
  operator delete();
}

void sub_1004F7B58()
{
}

void sub_1004F7B88()
{
}

__n128 sub_1004F7B9C(uint64_t a1)
{
  int v2 = (char *)operator new(0x20uLL);
  *(void *)int v2 = off_1019DB4F8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_1004F7BF0(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019DB4F8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_1004F7C28(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = (uint64_t (*)(void *, uint64_t, uint64_t))a1[2];
  uint64_t v5 = a1[3];
  uint64_t v6 = (void *)(a1[1] + (v5 >> 1));
  if (v5) {
    uint64_t v4 = *(uint64_t (**)(void *, uint64_t, uint64_t))(*v6 + v4);
  }
  return v4(v6, a3, a4);
}

uint64_t sub_1004F7C78(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1004F7CB8()
{
}

uint64_t sub_1004F7CC4(void *a1)
{
  uint64_t v1 = (uint64_t (*)(void *))a1[5];
  uint64_t v2 = a1[6];
  uint64_t v3 = (void *)(a1[4] + (v2 >> 1) - 8);
  if (v2) {
    return (*(uint64_t (**)(void))(*v3 + v1))();
  }
  else {
    return v1(v3);
  }
}

uint64_t sub_1004F7D10(uint64_t a1)
{
  sub_1004F9FB0((uint64_t *)(a1 + 24));
  uint64_t v3 = (void **)a1;
  sub_100163C60(&v3);
  return a1;
}

uint64_t sub_1004F7D50(uint64_t *a1)
{
  uint64_t result = *a1;
  if (!result) {
    __assert_rtn("operator*", "shared_ptr.hpp", 780, "px != 0");
  }
  return result;
}

void sub_1004F7D94(uint64_t *a1)
{
  memset(v3, 0, sizeof(v3));
  uint64_t v2 = (pthread_mutex_t *)sub_100060E64(a1 + 3);
  sub_100061F70(v3, v2);
  sub_1004F7E8C(a1, v3);
}

void sub_1004F7E5C(_Unwind_Exception *exception_object, int a2)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_1004F7E8C(uint64_t *a1, void *a2)
{
  uint64_t v2 = 0;
  uint64_t v3 = 0;
  sub_1004F7F84(a1, a2);
}

void sub_1004F7F6C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  sub_10000A740((atomic_uint **)va);
  _Unwind_Resume(a1);
}

void sub_1004F7F84(uint64_t *a1, void *a2)
{
}

void sub_1004F7FF8()
{
}

uint64_t sub_1004F801C(uint64_t *a1)
{
  uint64_t result = *a1;
  if (!result) {
    __assert_rtn("operator->", "shared_ptr.hpp", 786, "px != 0");
  }
  return result;
}

uint64_t sub_1004F8060(uint64_t *a1)
{
  uint64_t result = *a1;
  if (!result) {
    __assert_rtn("operator->", "shared_ptr.hpp", 786, "px != 0");
  }
  return result;
}

uint64_t *sub_1004F80A4(uint64_t *a1, void *a2)
{
  uint64_t v2 = a1[1];
  if (!v2 || atomic_load_explicit((atomic_uint *volatile)(v2 + 8), memory_order_acquire) != 1) {
    operator new();
  }

  return sub_1004F83C0(a1, a2, 1, 2);
}

void sub_1004F81A0()
{
}

void sub_1004F81C4(void *a1, uint64_t a2)
{
  if (a2)
  {
    if (*a1 == a2) {
      __assert_rtn("reset", "shared_ptr.hpp", 734, "p == 0 || p != px");
    }
  }
  sub_1004F8474(&v2, a2);
}

uint64_t sub_1004F8240(uint64_t *a1)
{
  uint64_t result = *a1;
  if (!result) {
    __assert_rtn("operator*", "shared_ptr.hpp", 780, "px != 0");
  }
  return result;
}

uint64_t *sub_1004F8284(uint64_t *a1, void *a2, int a3, uint64_t **a4, int a5)
{
  uint64_t v5 = a1[1];
  if (!v5 || atomic_load_explicit((atomic_uint *volatile)(v5 + 8), memory_order_acquire) != 1) {
    __assert_rtn("nolock_cleanup_connections_from", "signal_template.hpp", 436, "_shared_state.unique()");
  }
  __int16 v22 = *a4;
  uint64_t v10 = (uint64_t *)sub_1004F801C(a1);
  uint64_t result = (uint64_t *)sub_1004F9380(v10);
  if (result != v22)
  {
    unsigned int v12 = a5 - 1;
    unsigned int v13 = 1;
    uint64_t result = v22;
    do
    {
      if (a3)
      {
        uint64_t v14 = sub_1004F8060(result + 2);
        sub_1004F8AA8(v14, a2);
        uint64_t result = v22;
      }
      if (*(unsigned char *)(sub_1004F8060(result + 2) + 24))
      {
        uint64_t v15 = (atomic_uint *)v22[1];
      }
      else
      {
        uint64_t v16 = (uint64_t *)sub_1004F801C(a1);
        uint64_t v17 = sub_1004F9380(v16);
        uint64_t v18 = sub_1004F8060(v22 + 2);
        uint64_t v15 = sub_1001631B0(v17, (void *)(v18 + 64), (void **)&v22);
      }
      __int16 v22 = (uint64_t *)v15;
      uint64_t v19 = (uint64_t *)sub_1004F801C(a1);
      uint64_t v20 = (uint64_t *)sub_1004F9380(v19);
      uint64_t result = v22;
      if (v22 == v20) {
        break;
      }
    }
    while (v12 >= v13++);
  }
  a1[2] = (uint64_t)result;
  return result;
}

uint64_t *sub_1004F83C0(uint64_t *a1, void *a2, int a3, int a4)
{
  uint64_t v4 = a1[1];
  if (!v4 || atomic_load_explicit((atomic_uint *volatile)(v4 + 8), memory_order_acquire) != 1) {
    __assert_rtn("nolock_cleanup_connections", "signal_template.hpp", 461, "_shared_state.unique()");
  }
  uint64_t v9 = (uint64_t *)sub_1004F801C(a1);
  uint64_t v10 = sub_1004F9380(v9);
  uint64_t v11 = (uint64_t *)a1[2];
  if (v11 == (uint64_t *)v10)
  {
    unsigned int v12 = (uint64_t *)sub_1004F801C(a1);
    uint64_t v11 = *(uint64_t **)(sub_1004F9380(v12) + 8);
  }
  uint64_t v14 = v11;
  return sub_1004F8284(a1, a2, a3, &v14, a4);
}

void sub_1004F8474(void *a1, uint64_t a2)
{
  *a1 = a2;
  a1[1] = 0;
  sub_1004F84E0(&v2);
}

void sub_1004F84CC(_Unwind_Exception *a1)
{
  sub_10000A740(v1);
  _Unwind_Resume(a1);
}

void sub_1004F84E0(void *a1)
{
  *a1 = 0;
  operator new();
}

void sub_1004F8550(void *a1)
{
  __cxa_begin_catch(a1);
  sub_10016267C(v1);
  __cxa_rethrow();
}

void sub_1004F8564(_Unwind_Exception *a1)
{
}

void sub_1004F857C()
{
}

uint64_t sub_1004F8590(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 16);
  if (v1)
  {
    sub_10000A740((atomic_uint **)(v1 + 24));
    sub_10000A740((atomic_uint **)(v1 + 8));
    operator delete();
  }
  return result;
}

uint64_t sub_1004F85F4()
{
  return 0;
}

uint64_t sub_1004F85FC()
{
  return 0;
}

uint64_t sub_1004F8604()
{
  return 0;
}

void sub_1004F860C()
{
}

void sub_1004F8688()
{
}

uint64_t sub_1004F86AC(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = sub_1004F8838((uint64_t *)a1, a2);
  sub_1004F88A4((uint64_t)(v4 + 3), a2 + 24);
  *(unsigned char *)(a1 + 56) = *(unsigned char *)(a2 + 56);
  uint64_t v5 = *(void **)(a2 + 24);
  uint64_t v6 = (void *)(a2 + 32);
  if (v5 != (void *)(a2 + 32))
  {
    uint64_t v7 = *(void **)(a1 + 24);
    uint64_t v8 = *(void *)(a1 + 8);
    do
    {
      if (v7 == (void *)(a1 + 32)) {
        __assert_rtn("grouped_list", "slot_groups.hpp", 80, "this_map_it != _group_map.end()");
      }
      void v7[6] = v8;
      uint64_t v9 = a2;
      if (v5 != v6) {
        uint64_t v9 = v5[6];
      }
      uint64_t v10 = (void *)v5[1];
      uint64_t v11 = v10;
      unsigned int v12 = v5;
      if (v10)
      {
        do
        {
          unsigned int v13 = v11;
          uint64_t v11 = (void *)*v11;
        }
        while (v11);
      }
      else
      {
        do
        {
          unsigned int v13 = (void *)v12[2];
          BOOL v14 = *v13 == (void)v12;
          unsigned int v12 = v13;
        }
        while (!v14);
      }
      uint64_t v15 = a2;
      if (v13 != v6) {
        uint64_t v15 = v13[6];
      }
      while (v9 != v15)
      {
        uint64_t v9 = *(void *)(v9 + 8);
        uint64_t v8 = *(void *)(v8 + 8);
      }
      if (v10)
      {
        do
        {
          uint64_t v16 = v10;
          uint64_t v10 = (void *)*v10;
        }
        while (v10);
      }
      else
      {
        do
        {
          uint64_t v16 = (void *)v5[2];
          BOOL v14 = *v16 == (void)v5;
          uint64_t v5 = v16;
        }
        while (!v14);
      }
      uint64_t v17 = (void *)v7[1];
      if (v17)
      {
        do
        {
          uint64_t v18 = v17;
          uint64_t v17 = (void *)*v17;
        }
        while (v17);
      }
      else
      {
        do
        {
          uint64_t v18 = (void *)v7[2];
          BOOL v14 = *v18 == (void)v7;
          uint64_t v7 = v18;
        }
        while (!v14);
      }
      uint64_t v5 = v16;
      uint64_t v7 = v18;
    }
    while (v16 != v6);
  }
  return a1;
}

void sub_1004F8810(_Unwind_Exception *a1)
{
  sub_100162A90(v1);
  _Unwind_Resume(a1);
}

uint64_t *sub_1004F8838(uint64_t *a1, uint64_t a2)
{
  *a1 = (uint64_t)a1;
  a1[1] = (uint64_t)a1;
  a1[2] = 0;
  for (uint64_t i = a2; ; sub_100162A30(a1, (void *)(i + 16)))
  {
    uint64_t i = *(void *)(i + 8);
    if (i == a2) {
      break;
    }
  }
  return a1;
}

void sub_1004F8890(_Unwind_Exception *a1)
{
  sub_100162A90(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1004F88A4(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(unsigned char *)(a1 + 24) = *(unsigned char *)(a2 + 24);
  *(void *)a1 = a1 + 8;
  sub_100162B6C((_OWORD *)a1, *(void **)a2, (void *)(a2 + 8));
  return a1;
}

void sub_1004F88F4(_Unwind_Exception *a1)
{
  sub_1000346F8(v1, *(void **)(v1 + 8));
  _Unwind_Resume(a1);
}

void sub_1004F890C(void *a1, uint64_t a2)
{
  *a1 = a2;
  a1[1] = 0;
  sub_1004F8978(&v2);
}

void sub_1004F8964(_Unwind_Exception *a1)
{
  sub_10000A740(v1);
  _Unwind_Resume(a1);
}

void sub_1004F8978(void *a1)
{
  *a1 = 0;
  operator new();
}

void sub_1004F89E8(void *a1)
{
  __cxa_begin_catch(a1);
  sub_100163050(v1);
  __cxa_rethrow();
}

void sub_1004F89FC(_Unwind_Exception *a1)
{
}

void sub_1004F8A14()
{
}

uint64_t sub_1004F8A28(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 16);
  if (v1)
  {
    sub_1000346F8(v1 + 24, *(void **)(v1 + 32));
    sub_100162A90((atomic_uint **)v1);
    operator delete();
  }
  return result;
}

uint64_t sub_1004F8A90()
{
  return 0;
}

uint64_t sub_1004F8A98()
{
  return 0;
}

uint64_t sub_1004F8AA0()
{
  return 0;
}

uint64_t *sub_1004F8AA8(uint64_t a1, void *a2)
{
  uint64_t v4 = *(void *)(a1 + 32);
  uint64_t result = (uint64_t *)(a1 + 32);
  if (v4)
  {
    uint64_t v6 = (uint64_t *)sub_1004F8B10(result);
    uint64_t result = (uint64_t *)sub_100163358(v6);
    if (result)
    {
      if (*(unsigned char *)(a1 + 24))
      {
        *(unsigned char *)(a1 + 24) = 0;
        return (uint64_t *)sub_100163448((atomic_uint **)a1, a2);
      }
    }
  }
  return result;
}

uint64_t sub_1004F8B10(uint64_t *a1)
{
  uint64_t result = *a1;
  if (!result) {
    __assert_rtn("operator*", "shared_ptr.hpp", 780, "px != 0");
  }
  return result;
}

void sub_1004F8B54(uint64_t a1)
{
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(unsigned char *)(a1 + 24) = 1;
  *(_DWORD *)(a1 + 28) = 1;
  *(void *)a1 = off_1019DB658;
  operator new();
}

void sub_1004F8C68(uint64_t a1, ...)
{
  va_start(va, a1);
  sub_100163C60((void ***)va);
  operator delete();
}

void sub_1004F8CD0(uint64_t a1)
{
  sub_1004F9084(a1);

  operator delete();
}

BOOL sub_1004F8D08(uint64_t a1)
{
  uint64_t v1 = a1;
  long long v5 = 0u;
  memset(v4, 0, sizeof(v4));
  uint64_t v2 = (pthread_mutex_t *)sub_100060E64((uint64_t *)(a1 + 48));
  sub_100061F70(v4, v2);
  sub_1004F90F4((atomic_uint **)v1, v4);
  LODWORD(v1) = *(unsigned __int8 *)(v1 + 24);
  sub_10000A6C8(*((pthread_mutex_t **)&v5 + 1));
  sub_10000A5F8(v4);
  return v1 != 0;
}

void sub_1004F8DB8(_Unwind_Exception *exception_object, int a2)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1004F8DE8(uint64_t a1)
{
  uint64_t v1 = (pthread_mutex_t *)sub_10000A588((uint64_t *)(a1 + 48));

  return sub_10000A704(v1);
}

uint64_t sub_1004F8E14(uint64_t a1)
{
  uint64_t v1 = (pthread_mutex_t *)sub_10000A588((uint64_t *)(a1 + 48));

  return sub_10000A6C8(v1);
}

atomic_uint **sub_1004F8E40@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t v3 = *(void *)(a1 + 32);
  uint64_t v4 = *(void *)(a1 + 40);
  uint64_t v2 = (long long *)(a1 + 32);
  *a2 = v3;
  a2[1] = v4;
  if (v4)
  {
    atomic_fetch_add_explicit((atomic_uint *volatile)(v4 + 8), 1u, memory_order_relaxed);
    long long v5 = *v2;
  }
  else
  {
    *((void *)&v5 + 1) = 0;
  }
  *(void *)uint64_t v2 = 0;
  *((void *)v2 + 1) = 0;
  *((void *)&v7 + 1) = *((void *)&v5 + 1);
  return sub_10000A740((atomic_uint **)&v7 + 1);
}

void sub_1004F8E9C(void *a1, uint64_t a2)
{
  *a1 = a2;
  a1[1] = 0;
  sub_1004F8F08(&v2);
}

void sub_1004F8EF4(_Unwind_Exception *a1)
{
  sub_10000A740(v1);
  _Unwind_Resume(a1);
}

void sub_1004F8F08(void *a1)
{
  *a1 = 0;
  operator new();
}

void sub_1004F8F78(void *a1)
{
  __cxa_begin_catch(a1);
  sub_1004F8FA0(v1);
  __cxa_rethrow();
}

void sub_1004F8F8C(_Unwind_Exception *a1)
{
}

uint64_t sub_1004F8FA0(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = (void **)result;
    sub_1004F9FB0((uint64_t *)(result + 24));
    uint64_t v2 = v1;
    sub_100163C60(&v2);
    operator delete();
  }
  return result;
}

void sub_1004F9000()
{
}

uint64_t sub_1004F9014(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 16);
  if (v1)
  {
    sub_1004F9FB0((uint64_t *)(v1 + 24));
    uint64_t v2 = (void **)v1;
    sub_100163C60(&v2);
    operator delete();
  }
  return result;
}

uint64_t sub_1004F906C()
{
  return 0;
}

uint64_t sub_1004F9074()
{
  return 0;
}

uint64_t sub_1004F907C()
{
  return 0;
}

uint64_t sub_1004F9084(uint64_t a1)
{
  *(void *)a1 = off_1019DB658;
  sub_10000A740((atomic_uint **)(a1 + 56));
  sub_10000A740((atomic_uint **)(a1 + 40));
  *(void *)a1 = off_1019A5688;
  sub_100160AF8((atomic_uint **)(a1 + 16));
  return a1;
}

atomic_uint **sub_1004F90F4(atomic_uint **result, void *a2)
{
  uint64_t v2 = (uint64_t *)(result + 4);
  if (result[4])
  {
    uint64_t v4 = result;
    for (uint64_t i = *(atomic_uint **)sub_1004F8B10((uint64_t *)result + 4); ; i += 6)
    {
      uint64_t result = (atomic_uint **)sub_1004F8B10(v2);
      if (i == result[1]) {
        break;
      }
      memset(v6, 0, sizeof(v6));
      sub_100060B10(i, (uint64_t)v6);
      if (sub_100060A68((uint64_t)i))
      {
        if (*((unsigned char *)v4 + 24))
        {
          *((unsigned char *)v4 + 24) = 0;
          sub_100163448(v4, a2);
        }
        return sub_1000624B4((uint64_t)v6);
      }
      sub_1000624B4((uint64_t)v6);
    }
  }
  return result;
}

void sub_1004F91D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sub_1000624B4((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1004F91F8(void *a1, uint64_t a2)
{
  *a1 = a2;
  a1[1] = 0;
  sub_1004F9264(&v2);
}

void sub_1004F9250(_Unwind_Exception *a1)
{
  sub_10000A740(v1);
  _Unwind_Resume(a1);
}

void sub_1004F9264(void *a1)
{
  *a1 = 0;
  operator new();
}

void sub_1004F92D4(void *a1)
{
  __cxa_begin_catch(a1);
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }
  __cxa_rethrow();
}

void sub_1004F930C(_Unwind_Exception *a1)
{
}

void sub_1004F9324()
{
}

uint64_t sub_1004F9338(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 16);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_1004F9368()
{
  return 0;
}

uint64_t sub_1004F9370()
{
  return 0;
}

uint64_t sub_1004F9378()
{
  return 0;
}

uint64_t sub_1004F9380(uint64_t *a1)
{
  uint64_t result = *a1;
  if (!result) {
    __assert_rtn("operator*", "shared_ptr.hpp", 780, "px != 0");
  }
  return result;
}

dispatch_object_t *sub_1004F93C4(dispatch_object_t *a1, void **a2, dispatch_object_t object)
{
  *a1 = object;
  uint64_t v4 = *a2;
  if (*a2)
  {
    uint64_t v4 = _Block_copy(v4);
    dispatch_object_t object = *a1;
  }
  a1[1] = v4;
  dispatch_retain(object);
  return a1;
}

_OWORD *sub_1004F940C(_OWORD *a1, NSObject **a2)
{
  *a1 = 0u;
  a1[1] = 0u;
  sub_1004F9464((uint64_t)a1, a2);
  return a1;
}

void sub_1004F9444(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void **a10)
{
  sub_1004F9FB0((uint64_t *)(v10 + 24));
  a10 = (void **)v10;
  sub_100163C60(&a10);
  _Unwind_Resume(a1);
}

uint64_t sub_1004F9464(uint64_t a1, NSObject **a2)
{
  sub_1004F9540(v4, a2);
  sub_1004F94BC((uint64_t *)(a1 + 24), v4);
  return sub_1004FA334((uint64_t)v4);
}

void sub_1004F94A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t *sub_1004F94BC(uint64_t *a1, NSObject **a2)
{
  sub_1004F9540(v4, a2);
  sub_1004F9608(v5, v4);
  sub_1004F958C(v5, a1);
  sub_1004F9FB0(v5);
  sub_1004FA334((uint64_t)v4);
  return a1;
}

void sub_1004F951C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
}

NSObject **sub_1004F9540(NSObject **a1, NSObject **a2)
{
  uint64_t v3 = *a2;
  uint64_t v4 = a2[1];
  *a1 = *a2;
  if (v4)
  {
    uint64_t v4 = _Block_copy(v4);
    uint64_t v3 = *a1;
  }
  a1[1] = v4;
  dispatch_retain(v3);
  return a1;
}

uint64_t *sub_1004F958C(uint64_t *result, uint64_t *a2)
{
  if (a2 != result)
  {
    uint64_t v3 = (uint64_t)result;
    memset(v4, 0, sizeof(v4));
    sub_1004F9EF0((uint64_t)v4, result);
    sub_1004F9EF0(v3, a2);
    sub_1004F9EF0((uint64_t)a2, (uint64_t *)v4);
    return sub_1004F9FB0((uint64_t *)v4);
  }
  return result;
}

void sub_1004F95F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void *sub_1004F9608(void *a1, NSObject **a2)
{
  sub_1004F9540(v4, a2);
  sub_1004F9668(a1, v4);
  sub_1004FA334((uint64_t)v4);
  return a1;
}

void sub_1004F9654(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void *sub_1004F9668(void *a1, NSObject **a2)
{
  *a1 = 0;
  sub_1004F9540(v4, a2);
  sub_1004F96C8((uint64_t)a1, v4);
  sub_1004FA334((uint64_t)v4);
  return a1;
}

void sub_1004F96B4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_1004F96C8(uint64_t a1, NSObject **a2)
{
  sub_1004F9540(v6, a2);
  int v3 = sub_1004F9820((uint64_t)off_1019DB760, v6, (NSObject **)(a1 + 8));
  uint64_t result = sub_1004FA334((uint64_t)v6);
  if (v3) {
    long long v5 = off_1019DB760;
  }
  else {
    long long v5 = 0;
  }
  *(void *)a1 = v5;
  return result;
}

void sub_1004F9730(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_1004F9744(uint64_t result, uint64_t a2, unsigned int a3)
{
  if (a3 == 4) {
    goto LABEL_2;
  }
  uint64_t v5 = result;
  if (a3 <= 1)
  {
    uint64_t result = (uint64_t)sub_1004F9540((NSObject **)a2, (NSObject **)result);
    if (a3 != 1) {
      return result;
    }
    uint64_t v6 = v5;
    goto LABEL_10;
  }
  if (a3 != 3)
  {
    if (a3 != 2)
    {
LABEL_2:
      *(_WORD *)(a2 + 8) = 0;
      return result;
    }
    uint64_t v6 = a2;
LABEL_10:
    return sub_1004FA334(v6);
  }
  uint64_t result = *(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL;
  if (result == ((unint64_t)"N3ctu12DispatchSlotIN8dispatch5blockIU13block_pointerFv14Operating_ModeEEEEE" & 0x7FFFFFFFFFFFFFFFLL)
    || (uint64_t result = strcmp((const char *)result, (const char *)((unint64_t)"N3ctu12DispatchSlotIN8dispatch5blockIU13block_pointerFv14Operating_ModeEEEEE" & 0x7FFFFFFFFFFFFFFFLL)), !result))
  {
    *(void *)a2 = v5;
  }
  else
  {
    *(void *)a2 = 0;
  }
  return result;
}

uint64_t sub_1004F9820(uint64_t a1, NSObject **a2, NSObject **a3)
{
  sub_1004F9540(v7, a2);
  uint64_t v5 = sub_1004F9EA8(a1, v7, a3);
  sub_1004FA334((uint64_t)v7);
  return v5;
}

void sub_1004F9874(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1004F9888(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 8);
  if (v1) {
    uint64_t v1 = _Block_copy(v1);
  }
  aBlock = v1;
  sub_1004F9B30(&v3, &aBlock);
  operator new();
}

void sub_1004F99C0(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *aBlock, char a11)
{
}

uint64_t sub_1004F9A14(uint64_t a1)
{
  sub_1004F9A98(*(void **)(a1 + 32));
  uint64_t v2 = *(uint64_t **)(a1 + 32);
  if (v2)
  {
    sub_1004F9FB0(v2);
    operator delete();
  }
  uint64_t result = *(void *)(a1 + 40);
  if (result)
  {
    operator delete();
  }
  return result;
}

uint64_t sub_1004F9A98(void *a1)
{
  if (!*a1)
  {
    std::runtime_error::runtime_error(&v4, "call to empty boost::function");
    v4.__vftable = (std::runtime_error_vtbl *)&off_10199A8C8;
    sub_100098518(&v4);
  }
  uint64_t v1 = *(uint64_t (**)(void *))((*a1 & 0xFFFFFFFFFFFFFFFELL) + 8);
  uint64_t v2 = a1 + 1;

  return v1(v2);
}

void sub_1004F9B1C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, std::runtime_error a9)
{
}

void *sub_1004F9B30(void *a1, void **a2)
{
  uint64_t v3 = *a2;
  if (*a2) {
    uint64_t v3 = _Block_copy(v3);
  }
  aBlock = v3;
  sub_1004F9BAC(a1, &aBlock);
  if (aBlock) {
    _Block_release(aBlock);
  }
  return a1;
}

void sub_1004F9B90(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *aBlock)
{
  if (aBlock) {
    _Block_release(aBlock);
  }
  _Unwind_Resume(exception_object);
}

void *sub_1004F9BAC(void *a1, void **a2)
{
  *a1 = 0;
  uint64_t v3 = *a2;
  if (*a2) {
    uint64_t v3 = _Block_copy(v3);
  }
  aBlock = v3;
  sub_1004F9C28((uint64_t)a1, &aBlock);
  if (aBlock) {
    _Block_release(aBlock);
  }
  return a1;
}

void sub_1004F9C0C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *aBlock)
{
  if (aBlock) {
    _Block_release(aBlock);
  }
  _Unwind_Resume(exception_object);
}

void sub_1004F9C28(uint64_t a1, void **a2)
{
  uint64_t v3 = *a2;
  if (*a2) {
    uint64_t v3 = _Block_copy(v3);
  }
  aBlock = v3;
  int v4 = sub_1004F9CF0((uint64_t)off_1019DB7A0, &aBlock, (void **)(a1 + 8));
  if (aBlock) {
    _Block_release(aBlock);
  }
  if (v4) {
    uint64_t v5 = off_1019DB7A0;
  }
  else {
    uint64_t v5 = 0;
  }
  *(void *)a1 = v5;
}

void sub_1004F9CA4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *aBlock)
{
  if (aBlock) {
    _Block_release(aBlock);
  }
  _Unwind_Resume(exception_object);
}

void sub_1004F9CC0(void **a1, _WORD *a2, unsigned int a3)
{
  if (a3 == 4)
  {
    a2[4] = 0;
  }
  else
  {
    sub_1004F9D74(a1, a2, a3);
  }
}

uint64_t sub_1004F9CE0(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 16))();
}

uint64_t sub_1004F9CF0(uint64_t a1, void **a2, void **a3)
{
  uint64_t v5 = *a2;
  if (*a2) {
    uint64_t v5 = _Block_copy(v5);
  }
  aBlock = v5;
  uint64_t v6 = sub_1004F9E48(a1, (const void **)&aBlock, a3);
  if (aBlock) {
    _Block_release(aBlock);
  }
  return v6;
}

void sub_1004F9D58(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *aBlock)
{
  if (aBlock) {
    _Block_release(aBlock);
  }
  _Unwind_Resume(exception_object);
}

void sub_1004F9D74(void **a1, _WORD *a2, unsigned int a3)
{
  if (a3 > 1)
  {
    if (a3 == 3)
    {
      uint64_t v8 = (const char *)(*(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL);
      if (v8 == (const char *)((unint64_t)"N8dispatch5blockIU13block_pointerFv14Operating_ModeEEE" & 0x7FFFFFFFFFFFFFFFLL)
        || !strcmp(v8, (const char *)((unint64_t)"N8dispatch5blockIU13block_pointerFv14Operating_ModeEEE" & 0x7FFFFFFFFFFFFFFFLL)))
      {
        *(void *)a2 = a1;
      }
      else
      {
        *(void *)a2 = 0;
      }
    }
    else if (a3 == 2)
    {
      long long v7 = *(void **)a2;
      if (*(void *)a2) {
LABEL_6:
      }
        _Block_release(v7);
    }
    else
    {
      a2[4] = 0;
    }
  }
  else
  {
    uint64_t v6 = *a1;
    if (*a1) {
      uint64_t v6 = _Block_copy(v6);
    }
    *(void *)a2 = v6;
    if (a3 == 1)
    {
      long long v7 = *a1;
      if (*a1) {
        goto LABEL_6;
      }
    }
  }
}

uint64_t sub_1004F9E48(uint64_t a1, const void **a2, void **a3)
{
  if (*a2 && (v4 = _Block_copy(*a2), (uint64_t v5 = v4) != 0))
  {
    *a3 = _Block_copy(v4);
    _Block_release(v5);
  }
  else
  {
    *a3 = 0;
  }
  return 1;
}

uint64_t sub_1004F9EA8(uint64_t a1, NSObject **a2, NSObject **a3)
{
  sub_1004F9540(v5, a2);
  sub_1004F9540(a3, v5);
  sub_1004FA334((uint64_t)v5);
  return 1;
}

uint64_t sub_1004F9EF0(uint64_t result, uint64_t *a2)
{
  if (a2 != (uint64_t *)result)
  {
    uint64_t v2 = a2;
    uint64_t v3 = (uint64_t *)result;
    uint64_t v4 = *a2;
    if (*a2)
    {
      *(void *)uint64_t result = v4;
      if (v4)
      {
        long long v7 = *(_OWORD *)(a2 + 1);
        *(void *)(result + 24) = a2[3];
        *(_OWORD *)(result + 8) = v7;
      }
      else
      {
        uint64_t result = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(v4 & 0xFFFFFFFFFFFFFFFELL))(a2 + 1, result + 8, 1);
      }
    }
    else
    {
      uint64_t v5 = *(void *)result;
      if (!*(void *)result) {
        return result;
      }
      if ((v5 & 1) == 0)
      {
        uint64_t v6 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v5 & 0xFFFFFFFFFFFFFFFELL);
        if (v6) {
          uint64_t result = v6(result + 8, result + 8, 2);
        }
      }
      uint64_t v2 = v3;
    }
    uint64_t *v2 = 0;
  }
  return result;
}

void sub_1004F9F8C(void *a1)
{
  __cxa_begin_catch(a1);
  *uint64_t v1 = 0;
  __cxa_rethrow();
}

void sub_1004F9F9C(_Unwind_Exception *a1)
{
}

uint64_t *sub_1004F9FB0(uint64_t *a1)
{
  uint64_t v2 = *a1;
  if (*a1)
  {
    if ((v2 & 1) == 0)
    {
      uint64_t v3 = *(void (**)(uint64_t *, uint64_t *, uint64_t))(v2 & 0xFFFFFFFFFFFFFFFELL);
      if (v3) {
        v3(a1 + 1, a1 + 1, 2);
      }
    }
    *a1 = 0;
  }
  return a1;
}

void *sub_1004FA004(void *a1)
{
  *a1 = off_1019DB7D0;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_1004FA050(void *a1)
{
  *a1 = off_1019DB7D0;
  uint64_t v1 = (std::__shared_weak_count *)a1[2];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

void sub_1004FA0BC(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1) {
    std::__shared_weak_count::lock(v1);
  }
  operator new();
}

void sub_1004FA16C(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_1004FA184(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 16);
  return !v1 || *(void *)(v1 + 8) == -1;
}

void sub_1004FA1A4()
{
}

void *sub_1004FA210(void *a1)
{
  *a1 = off_1019DB820;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

void sub_1004FA25C(void *a1)
{
  *a1 = off_1019DB820;
  uint64_t v1 = (std::__shared_weak_count *)a1[2];
  if (v1) {
    sub_10004D2C8(v1);
  }

  operator delete();
}

void sub_1004FA2C8()
{
}

uint64_t sub_1004FA334(uint64_t a1)
{
  dispatch_release(*(dispatch_object_t *)a1);
  uint64_t v2 = *(const void **)(a1 + 8);
  if (v2) {
    _Block_release(v2);
  }
  return a1;
}

void sub_1004FA374()
{
}

__n128 sub_1004FA388(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_1019DB860;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_1004FA3DC(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019DB860;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_1004FA414(void *a1)
{
  uint64_t v1 = (uint64_t (*)(void *))a1[2];
  uint64_t v2 = a1[3];
  uint64_t v3 = (void *)(a1[1] + (v2 >> 1));
  if (v2) {
    return (*(uint64_t (**)(void))(*v3 + v1))();
  }
  else {
    return v1(v3);
  }
}

uint64_t sub_1004FA45C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1004FA49C()
{
}

void sub_1004FA4AC()
{
}

__n128 sub_1004FA4C0(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_1019DB8E0;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_1004FA514(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019DB8E0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_1004FA54C(void *a1, xpc *this, BOOL a3)
{
  uint64_t v4 = (unsigned char *)a1[1];
  int v5 = *v4;
  unsigned char *v4 = xpc::dyn_cast_or_default(this, 0, a3);
  uint64_t v6 = (uint64_t (*)(void *, BOOL))a1[3];
  uint64_t v7 = a1[4];
  uint64_t v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    uint64_t v6 = *(uint64_t (**)(void *, BOOL))(*v8 + v6);
  }

  return v6(v8, v5 != 0);
}

uint64_t sub_1004FA5E8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1004FA628()
{
}

void sub_1004FA638()
{
}

__n128 sub_1004FA64C(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_1019DB960;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_1004FA6A0(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019DB960;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_1004FA6D8(void *a1, xpc_object_t *a2)
{
  uint64_t v4 = (unsigned int *)a1[1];
  uint64_t v5 = *v4;
  xpc_type_t type = xpc_get_type(*a2);
  if (type == (xpc_type_t)&_xpc_type_string)
  {
    unsigned int v14 = *v4;
    ctu::rest::detail::read_enum_string_value((ctu::rest::detail *)&v14, (int *)a2, v7);
    unsigned int *v4 = v14;
  }
  else if (type == (xpc_type_t)&_xpc_type_BOOL {
         || type == (xpc_type_t)&_xpc_type_int64
  }
         || type == (xpc_type_t)&_xpc_type_uint64)
  {
    unsigned int *v4 = xpc::dyn_cast_or_default((xpc *)a2, 0, (uint64_t)v7);
  }
  uint64_t v10 = (uint64_t (*)(void *, uint64_t))a1[3];
  uint64_t v11 = a1[4];
  unsigned int v12 = (void *)(a1[2] + (v11 >> 1));
  if (v11) {
    uint64_t v10 = *(uint64_t (**)(void *, uint64_t))(*v12 + v10);
  }
  return v10(v12, v5);
}

uint64_t sub_1004FA7D0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1004FA810()
{
}

void sub_1004FA820()
{
}

__n128 sub_1004FA834(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_1019DB9E0;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_1004FA888(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019DB9E0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_1004FA8C0(void *a1, xpc_object_t *a2)
{
  uint64_t v3 = (void *)a1[1];
  uint64_t v4 = v3 + 1;
  uint64_t v5 = v3[1];
  uint64_t v9 = (char **)*v3;
  uint64_t v10 = (char *)v5;
  if (v3[2])
  {
    *(void *)(v5 + 16) = &v10;
    *uint64_t v3 = v4;
    void *v4 = 0;
    v3[2] = 0;
  }
  else
  {
    uint64_t v9 = &v10;
  }
  sub_1004CED98((uint64_t)v3, a2);
  uint64_t v6 = (void (*)(void *, char ***))a1[3];
  uint64_t v7 = a1[4];
  uint64_t v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    uint64_t v6 = *(void (**)(void *, char ***))(*v8 + v6);
  }
  v6(v8, &v9);
  sub_1000886C0((uint64_t)&v9, v10);
}

void sub_1004FA980(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, char *a11)
{
}

uint64_t sub_1004FA998(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1004FA9D8()
{
}

void sub_1004FA9E8()
{
}

__n128 sub_1004FA9FC(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_1019DBA60;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_1004FAA50(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019DBA60;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_1004FAA88(void *a1, xpc_object_t *a2)
{
  uint64_t v3 = (void *)a1[1];
  uint64_t v4 = v3 + 1;
  uint64_t v5 = v3[1];
  uint64_t v9 = (char **)*v3;
  uint64_t v10 = (char *)v5;
  if (v3[2])
  {
    *(void *)(v5 + 16) = &v10;
    *uint64_t v3 = v4;
    void *v4 = 0;
    v3[2] = 0;
  }
  else
  {
    uint64_t v9 = &v10;
  }
  sub_1002430C8((uint64_t)v3, a2);
  uint64_t v6 = (void (*)(void *, char ***))a1[3];
  uint64_t v7 = a1[4];
  uint64_t v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    uint64_t v6 = *(void (**)(void *, char ***))(*v8 + v6);
  }
  v6(v8, &v9);
  sub_10005CD2C((uint64_t)&v9, v10);
}

void sub_1004FAB48(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, char *a11)
{
}

uint64_t sub_1004FAB60(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1004FABA0()
{
}

void sub_1004FABB0()
{
}

__n128 sub_1004FABC4(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_1019DBAE0;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_1004FAC18(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019DBAE0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_1004FAC50(void *a1, xpc_object_t *a2)
{
  uint64_t v4 = (unsigned int *)a1[1];
  uint64_t v5 = *v4;
  xpc_type_t type = xpc_get_type(*a2);
  if (type == (xpc_type_t)&_xpc_type_string)
  {
    unsigned int v14 = *v4;
    ctu::rest::detail::read_enum_string_value((ctu::rest::detail *)&v14, (int *)a2, v7);
    unsigned int *v4 = v14;
  }
  else if (type == (xpc_type_t)&_xpc_type_BOOL {
         || type == (xpc_type_t)&_xpc_type_int64
  }
         || type == (xpc_type_t)&_xpc_type_uint64)
  {
    unsigned int *v4 = xpc::dyn_cast_or_default((xpc *)a2, 0, (uint64_t)v7);
  }
  uint64_t v10 = (uint64_t (*)(void *, uint64_t))a1[3];
  uint64_t v11 = a1[4];
  unsigned int v12 = (void *)(a1[2] + (v11 >> 1));
  if (v11) {
    uint64_t v10 = *(uint64_t (**)(void *, uint64_t))(*v12 + v10);
  }
  return v10(v12, v5);
}

uint64_t sub_1004FAD48(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1004FAD88()
{
}

void sub_1004FAD98()
{
}

__n128 sub_1004FADAC(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_1019DBB60;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_1004FAE00(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019DBB60;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_1004FAE38(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1004FAE78()
{
}

void sub_1004FAE88()
{
}

__n128 sub_1004FAE9C(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_1019DBBE0;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_1004FAEF0(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019DBBE0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_1004FAF28(void *a1, const xpc::object *a2)
{
  uint64_t v4 = (const RegisteredNetworkInfo *)a1[1];
  bzero(v9, 0x320uLL);
  RegisteredNetworkInfo::RegisteredNetworkInfo((RegisteredNetworkInfo *)v9, v4);
  read_rest_value(v4, a2);
  uint64_t v5 = (void (*)(void *, unsigned char *))a1[3];
  uint64_t v6 = a1[4];
  uint64_t v7 = (void *)(a1[2] + (v6 >> 1));
  if (v6) {
    uint64_t v5 = *(void (**)(void *, unsigned char *))(*v7 + v5);
  }
  v5(v7, v9);
  if (v18 && v17 < 0) {
    operator delete(__p);
  }
  sub_10002B2D8((uint64_t)&v15);
  sub_10002B28C((uint64_t)&v14);
  sub_10002B1F4((uint64_t)&v13);
  sub_10002B1A8((uint64_t)&v12);
  sub_10002B1A8((uint64_t)&v11);
  return sub_10002B240((uint64_t)&v10);
}

void sub_1004FB048(_Unwind_Exception *a1)
{
}

uint64_t sub_1004FB0A8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1004FB0E8()
{
}

void sub_1004FB0F8()
{
}

__n128 sub_1004FB10C(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_1019DBC60;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_1004FB160(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019DBC60;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_1004FB198(void *a1, xpc_object_t *a2)
{
  uint64_t v3 = (void *)a1[1];
  uint64_t v4 = v3 + 1;
  uint64_t v5 = v3[1];
  uint64_t v9 = (char **)*v3;
  uint64_t v10 = (char *)v5;
  if (v3[2])
  {
    *(void *)(v5 + 16) = &v10;
    *uint64_t v3 = v4;
    void *v4 = 0;
    v3[2] = 0;
  }
  else
  {
    uint64_t v9 = &v10;
  }
  sub_100A59380((uint64_t)v3, a2, "PersonalityID", "State");
  uint64_t v6 = (void (*)(void *, char ***))a1[3];
  uint64_t v7 = a1[4];
  uint64_t v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    uint64_t v6 = *(void (**)(void *, char ***))(*v8 + v6);
  }
  v6(v8, &v9);
  sub_10005CD2C((uint64_t)&v9, v10);
}

void sub_1004FB268(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, char *a11)
{
}

uint64_t sub_1004FB280(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1004FB2C0()
{
}

void sub_1004FB2D0()
{
}

__n128 sub_1004FB2E4(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_1019DBCE0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_1004FB330(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019DBCE0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_1004FB360(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v3 = *(std::__shared_weak_count **)(v2 + 1976);
  *(_OWORD *)(v2 + 1968) = 0u;
  if (v3) {
    sub_10004D2C8(v3);
  }
  uint64_t v4 = *(NSObject **)(v2 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = *(void *)(a1 + 16) / 1000;
    int v6 = 134217984;
    uint64_t v7 = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Settling timer expired (after %lld seconds)", (uint8_t *)&v6, 0xCu);
  }
  sub_1004F5C9C(v2, 0, 1);
}

uint64_t sub_1004FB44C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1004FB48C()
{
}

uint64_t sub_1004FB498@<X0>(int a1@<W0>, char *const *a2@<X1>, uint64_t a3@<X8>)
{
  *(void *)a3 = 0;
  *(void *)(a3 + 8) = 0;
  *(void *)(a3 + 16) = 0;
  uint64_t result = getopt(a1, a2, "1:M:PphLF:RD:");
  int v7 = result << 24;
  if (result << 24 != -16777216)
  {
    uint64_t v9 = 0;
    char v8 = 0;
    while (1)
    {
      int v10 = v7 >> 24;
      if (v10 <= 75)
      {
        if (v10 != 49)
        {
          if (v10 != 70)
          {
            if (v10 == 63) {
              goto LABEL_22;
            }
            goto LABEL_20;
          }
          uint64_t v11 = optarg;
          if (v9)
          {
            *(void *)(a3 + 16) = optarg;
          }
          else
          {
            *(void *)(a3 + 8) = optarg;
            uint64_t v9 = v11;
          }
        }
      }
      else
      {
        if (v10 > 103)
        {
          if (v10 != 112)
          {
            if (v10 == 104) {
LABEL_22:
            }
              exit(0);
LABEL_20:
            __assert_rtn("sParseCommCenterCommandLineArgs", "CommCenterCommandLineArgs.cpp", 64, "false");
          }
        }
        else
        {
          if (v10 == 76)
          {
            char v8 = 1;
            *(unsigned char *)(a3 + 1) = 1;
            goto LABEL_17;
          }
          if (v10 != 80) {
            goto LABEL_20;
          }
        }
        *(unsigned char *)a3 = 1;
      }
LABEL_17:
      uint64_t result = getopt(a1, a2, "1:M:PphLF:RD:");
      int v7 = result << 24;
      if (result << 24 == -16777216) {
        goto LABEL_18;
      }
    }
  }
  char v8 = 0;
LABEL_18:
  *(unsigned char *)(a3 + 2) = v8 ^ 1;
  return result;
}

void *sub_1004FB5F0(uint64_t a1)
{
  *(void *)a1 = off_1019DBD60;
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 120);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 104);
  if (v3) {
    sub_10004D2C8(v3);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 88);
  if (v4) {
    sub_10004D2C8(v4);
  }
  sub_10012577C((const void **)(a1 + 64));

  return sub_1002B4928((void *)a1);
}

void sub_1004FB670(uint64_t a1)
{
  sub_1004FB5F0(a1);

  operator delete();
}

uint64_t sub_1004FB6A8(uint64_t a1, unsigned __int8 *a2)
{
  if (!*(unsigned char *)(a1 + 77))
  {
    *(unsigned char *)(a1 + 77) = 1;
    uint64_t v5 = *(NSObject **)(a1 + 8);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Setting up environment", buf, 2u);
    }
    int v6 = *a2;
    *(unsigned char *)(a1 + 78) = v6;
    *(unsigned char *)(a1 + 76) = a2[1];
    if (v6)
    {
      int v7 = *(NSObject **)(a1 + 8);
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)char v8 = 0;
        _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Waiting for off grid mode message", v8, 2u);
      }
    }
  }
  return 1;
}

void sub_1004FB780(uint64_t a1)
{
  uint64_t v1 = *(NSObject **)(a1 + 8);
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v2 = 0;
    _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "#I Teardown requested", v2, 2u);
  }
}

uint64_t sub_1004FB7E0(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 77);
}

void sub_1004FB7E8(uint64_t a1, int a2)
{
  if (*(unsigned __int8 *)(a1 + 74) != a2)
  {
    *(unsigned char *)(a1 + 74) = a2;
    if (a2)
    {
      if (*(unsigned char *)(a1 + 73)) {
        *(unsigned char *)(a1 + 73) = 0;
      }
      *(unsigned char *)(a1 + 75) = 0;
      uint64_t v2 = *(NSObject **)(a1 + 8);
      if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t v3 = 0;
        _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Resetting token to: <none>; Marking CarrierPigeonStartMessage not acked. Reason: New start due",
          v3,
          2u);
      }
    }
  }
}

void sub_1004FB86C(uint64_t a1, const void **a2, unsigned __int8 a3)
{
  unsigned __int8 v11 = a3;
  v10[0] = a1;
  v10[1] = (uint64_t)a2;
  dispatch_object_t v10[2] = (uint64_t)&v11;
  if (*(unsigned char *)(a1 + 74))
  {
    uint64_t v3 = "New start is pending...";
  }
  else
  {
    uint64_t v4 = *a2;
    if (v4) {
      uint64_t v5 = sub_100136254;
    }
    else {
      uint64_t v5 = 0;
    }
    if (v5 && ((int v7 = *(const void **)(a1 + 64)) != 0 ? (v8 = sub_100136254) : (v8 = 0), v8 && CFEqual(v7, v4)))
    {
      if (!*(unsigned char *)(a1 + 73) || *(unsigned __int8 *)(a1 + 72) != v11)
      {
        *(_WORD *)(a1 + 72) = v11 | 0x100;
        uint64_t v3 = "New token";
        int v9 = 1;
        goto LABEL_17;
      }
      uint64_t v3 = "Duplicate";
    }
    else
    {
      uint64_t v3 = "LLC ID mismatch";
    }
  }
  int v9 = 0;
LABEL_17:
  sub_1004FB954(v10, v9, (uint64_t)v3);
}

void sub_1004FB954(uint64_t *a1, int a2, uint64_t a3)
{
  uint64_t v6 = *a1;
  int v7 = *(NSObject **)(*a1 + 8);
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    sub_100BC8FAC((CFUUIDRef *)a1[1], v16);
    int v8 = v17;
    int v9 = (void **)v16[0];
    int v10 = *(unsigned __int8 *)a1[2];
    sub_100BC8FAC((CFUUIDRef *)(v6 + 64), __p);
    unsigned __int8 v11 = v16;
    if (v8 < 0) {
      unsigned __int8 v11 = v9;
    }
    uint64_t v12 = "[Ignored]";
    if (a2) {
      uint64_t v12 = "[Token updated]";
    }
    *(_DWORD *)long long buf = 136316162;
    uint64_t v19 = v12;
    __int16 v20 = 2082;
    if (v15 >= 0) {
      uint64_t v13 = __p;
    }
    else {
      uint64_t v13 = (void **)__p[0];
    }
    __int16 v21 = v11;
    __int16 v22 = 1024;
    int v23 = v10;
    __int16 v24 = 2082;
    char v25 = v13;
    __int16 v26 = 2080;
    uint64_t v27 = a3;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I [CarrierPigeonStartMessage][Attempted]%s Message: [LLC ID: %{public}s, token: %hhu], environment: [LLC ID: %{public}s], %s", buf, 0x30u);
    if (v15 < 0) {
      operator delete(__p[0]);
    }
    if (v17 < 0) {
      operator delete(v16[0]);
    }
  }
}

void sub_1004FBAC0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1004FBAE4(uint64_t a1, const void **a2, char a3)
{
  char v15 = a3;
  v14[0] = a1;
  v14[1] = (uint64_t)a2;
  void v14[2] = (uint64_t)&v15;
  if (*(unsigned char *)(a1 + 74))
  {
    uint64_t v3 = "New start is pending...";
LABEL_17:
    int v9 = 0;
    goto LABEL_18;
  }
  uint64_t v4 = *a2;
  if (v4) {
    uint64_t v5 = sub_100136254;
  }
  else {
    uint64_t v5 = 0;
  }
  if (!v5 || ((int v7 = *(const void **)(a1 + 64)) != 0 ? (v8 = sub_100136254) : (v8 = 0), !v8 || !CFEqual(v7, v4)))
  {
    uint64_t v3 = "LLC ID mismatch";
    goto LABEL_17;
  }
  if (!*(unsigned char *)(a1 + 73) || v15 != *(unsigned char *)(a1 + 72))
  {
    uint64_t v3 = "Token Mismatch";
    goto LABEL_17;
  }
  if (*(unsigned char *)(a1 + 75))
  {
    uint64_t v3 = "Nothing changed for this environment";
    goto LABEL_17;
  }
  int v10 = *(void (****)(void, uint64_t))(a1 + 96);
  if (v10)
  {
    unsigned __int8 v11 = *(NSObject **)(a1 + 8);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v13 = 0;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I Successfully published OffGridMode", v13, 2u);
      int v10 = *(void (****)(void, uint64_t))(a1 + 96);
    }
    (**v10)(v10, 1);
    uint64_t v12 = *(std::__shared_weak_count **)(a1 + 104);
    *(void *)(a1 + 96) = 0;
    *(void *)(a1 + 104) = 0;
    if (v12) {
      sub_10004D2C8(v12);
    }
  }
  *(unsigned char *)(a1 + 75) = 1;
  uint64_t v3 = "Updated environment";
  int v9 = 1;
LABEL_18:
  sub_1004FBC6C(v14, v9, (uint64_t)v3);
}

void sub_1004FBC6C(uint64_t *a1, int a2, uint64_t a3)
{
  uint64_t v6 = *a1;
  int v7 = *(NSObject **)(*a1 + 8);
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    if (a2) {
      int v8 = "[Accepted]";
    }
    else {
      int v8 = "[Ignored]";
    }
    int v9 = v18;
    sub_100BC8FAC((CFUUIDRef *)a1[1], v18);
    if (v19 < 0) {
      int v9 = (void **)v18[0];
    }
    int v10 = *(unsigned __int8 *)a1[2];
    sub_100BC8FAC((CFUUIDRef *)(v6 + 64), v16);
    int v11 = v17;
    uint64_t v12 = (void **)v16[0];
    sub_10026CCB8((unsigned __int8 *)(v6 + 72), &__p);
    uint64_t v13 = v16;
    if (v11 < 0) {
      uint64_t v13 = v12;
    }
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      p_p = &__p;
    }
    else {
      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    *(_DWORD *)long long buf = 136316418;
    __int16 v21 = v8;
    __int16 v22 = 2082;
    int v23 = v9;
    __int16 v24 = 1024;
    int v25 = v10;
    __int16 v26 = 2082;
    uint64_t v27 = v13;
    __int16 v28 = 2082;
    int v29 = p_p;
    __int16 v30 = 2080;
    uint64_t v31 = a3;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I [CarrierPigeonStartMessage][Acked]%s Message: [LLC ID: %{public}s, token: %hhu], environment: [LLC ID: %{public}s, token: %{public}s], %s", buf, 0x3Au);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    if (v17 < 0) {
      operator delete(v16[0]);
    }
    if (v19 < 0) {
      operator delete(v18[0]);
    }
  }
}

void sub_1004FBE10(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, void *a19, uint64_t a20,int a21,__int16 a22,char a23,char a24)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  if (a24 < 0) {
    operator delete(a19);
  }
  _Unwind_Resume(exception_object);
}

void sub_1004FBE4C(uint64_t a1, const void **a2)
{
  uint64_t v3 = *a2;
  if (v3) {
    uint64_t v4 = sub_100136254;
  }
  else {
    uint64_t v4 = 0;
  }
  if (v4)
  {
    int v7 = (const void **)(a1 + 64);
    uint64_t v6 = *(const void **)(a1 + 64);
    int v8 = v6 ? sub_100136254 : 0;
    if (!v8 || !CFEqual(v6, v3))
    {
      sub_100224390(v7, a2);
      if (*(unsigned char *)(a1 + 73)) {
        *(unsigned char *)(a1 + 73) = 0;
      }
      *(unsigned char *)(a1 + 75) = 0;
      int v9 = *(NSObject **)(a1 + 8);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
      {
        sub_100BC8FAC((CFUUIDRef *)v7, v15);
        int v10 = v16;
        int v11 = (void **)v15[0];
        sub_10026CCB8((unsigned __int8 *)(a1 + 72), &__p);
        uint64_t v12 = v15;
        if (v10 < 0) {
          uint64_t v12 = v11;
        }
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          p_p = &__p;
        }
        else {
          p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
        }
        *(_DWORD *)long long buf = 136446466;
        char v18 = v12;
        __int16 v19 = 2080;
        __int16 v20 = p_p;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I LLCEnvironmentID changed. Updated environment: [LLC ID: %{public}s, token: %s]", buf, 0x16u);
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__p.__r_.__value_.__l.__data_);
        }
        if (v16 < 0) {
          operator delete(v15[0]);
        }
      }
      sub_1004FB7E8(a1, 1);
    }
  }
}

void sub_1004FBFDC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1004FC000(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  if (*a2 == a2[1]) {
    __TUAssertTrigger();
  }
  if (!*(void *)(a3 + 24)) {
    __TUAssertTrigger();
  }
  *(unsigned char *)(a1 + 78) = 0;
  uint64_t v6 = *(NSObject **)(a1 + 8);
  BOOL v7 = os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT);
  uint64_t v8 = *a2;
  uint64_t v9 = a2[1];
  if (v7)
  {
    *(_DWORD *)long long buf = 134217984;
    uint64_t v15 = v9 - v8;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Got OffGridModeKey of size: %zu", buf, 0xCu);
    uint64_t v8 = *a2;
    uint64_t v9 = a2[1];
  }
  uint64_t v10 = a2[2];
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  sub_100023950((uint64_t)v13, a3);
  int v11 = operator new(0x60uLL);
  v11[1] = 0;
  v11[2] = 0;
  void *v11 = off_1019DBE10;
  sub_100023950((uint64_t)buf, (uint64_t)v13);
  v11[3] = off_1019DBDA0;
  void v11[4] = v8;
  v11[5] = v9;
  v11[6] = v10;
  sub_100023950((uint64_t)(v11 + 7), (uint64_t)buf);
  *((unsigned char *)v11 + 88) = 0;
  sub_100060644(buf);
  uint64_t v12 = *(std::__shared_weak_count **)(a1 + 104);
  *(void *)(a1 + 96) = v11 + 3;
  *(void *)(a1 + 104) = v11;
  if (v12) {
    sub_10004D2C8(v12);
  }
  sub_100060644(v13);
  sub_1004FB7E8(a1, 1);
}

void sub_1004FC1A0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  sub_100060644(&a9);
  if (v9) {
    operator delete(v9);
  }
  _Unwind_Resume(a1);
}

void *sub_1004FC1C0@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t result = *(void **)(a1 + 96);
  if (result)
  {
    uint64_t v4 = (*(uint64_t (**)(void *))(*result + 8))(result);
    a2[1] = 0;
    a2[2] = 0;
    *a2 = 0;
    uint64_t v5 = *(const void **)v4;
    uint64_t v6 = *(void *)(v4 + 8);
    size_t v7 = v6 - *(void *)v4;
    return sub_10005C928(a2, v5, v6, v7);
  }
  else
  {
    *a2 = 0;
    a2[1] = 0;
    a2[2] = 0;
  }
  return result;
}

BOOL sub_1004FC244(uint64_t a1, uint64_t *a2)
{
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 120);
  if (v4)
  {
    uint64_t v5 = std::__shared_weak_count::lock(v4);
    if (v5)
    {
      uint64_t v6 = *(void *)(a1 + 112);
      if (v6)
      {
        BOOL v7 = v6 == *a2;
LABEL_11:
        sub_10004D2C8(v5);
        return v7;
      }
    }
  }
  else
  {
    uint64_t v5 = 0;
  }
  uint64_t v9 = *a2;
  uint64_t v8 = a2[1];
  if (v8) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v8 + 16), 1uLL, memory_order_relaxed);
  }
  uint64_t v10 = *(std::__shared_weak_count **)(a1 + 120);
  *(void *)(a1 + 112) = v9;
  *(void *)(a1 + 120) = v8;
  if (v10) {
    std::__shared_weak_count::__release_weak(v10);
  }
  BOOL v7 = 1;
  if (v5) {
    goto LABEL_11;
  }
  return v7;
}

void sub_1004FC2D8(uint64_t a1)
{
  sub_1002B486C(a1);
  uint64_t v2 = *(NSObject **)(a1 + 8);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = "true";
    if (!*(unsigned char *)(a1 + 77)) {
      uint64_t v3 = "false";
    }
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I [d] DidSetup: %s", buf, 0xCu);
    uint64_t v2 = *(NSObject **)(a1 + 8);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    sub_100BC8FAC((CFUUIDRef *)(a1 + 64), buf);
    int v4 = v23;
    uint64_t v5 = *(unsigned char **)buf;
    sub_10026CCB8((unsigned __int8 *)(a1 + 72), &__p);
    uint64_t v6 = buf;
    if (v4 < 0) {
      uint64_t v6 = v5;
    }
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      p_p = &__p;
    }
    else {
      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    *(_DWORD *)__int16 v24 = 136446466;
    int v25 = v6;
    __int16 v26 = 2080;
    uint64_t v27 = p_p;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I [d] [LLC ID: %{public}s, token: %s]", v24, 0x16u);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    if (v23 < 0) {
      operator delete(*(void **)buf);
    }
    uint64_t v2 = *(NSObject **)(a1 + 8);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v8 = "true";
    if (!*(unsigned char *)(a1 + 74)) {
      uint64_t v8 = "false";
    }
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = v8;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I [d] IsCarrierPigeonStartMessageDue: %s", buf, 0xCu);
    uint64_t v2 = *(NSObject **)(a1 + 8);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v9 = "true";
    if (!*(unsigned char *)(a1 + 75)) {
      uint64_t v9 = "false";
    }
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = v9;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I [d] IsCarrierPigeonStartMessageAcked: %s", buf, 0xCu);
    uint64_t v2 = *(NSObject **)(a1 + 8);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v10 = "true";
    if (!*(unsigned char *)(a1 + 76)) {
      uint64_t v10 = "false";
    }
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = v10;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I [d] AreAllPrimaryContactsReachableViaIML: %s", buf, 0xCu);
    uint64_t v2 = *(NSObject **)(a1 + 8);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    int v11 = "true";
    if (!*(unsigned char *)(a1 + 78)) {
      int v11 = "false";
    }
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = v11;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I [d] WaitingForOffGridModeMessage: %s", buf, 0xCu);
  }
  uint64_t v12 = *(uint64_t ***)(a1 + 80);
  if (v12)
  {
    uint64_t v13 = *v12;
    uint64_t v14 = v12[1];
    if (*v12 != v14)
    {
      do
      {
        uint64_t v15 = *(NSObject **)(a1 + 8);
        if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v16 = *v13;
          *(_DWORD *)long long buf = 134217984;
          *(void *)&uint8_t buf[4] = v16;
          _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I [d] [CachedMyShortHandle] %llu", buf, 0xCu);
        }
        ++v13;
      }
      while (v13 != v14);
    }
  }
  char v17 = *(NSObject **)(a1 + 8);
  if (*(void *)(a1 + 96) && os_log_type_enabled(*(os_log_t *)(a1 + 8), OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I [d] Off the grid mode context exists", buf, 2u);
    char v17 = *(NSObject **)(a1 + 8);
  }
  if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
  {
    char v18 = *(std::__shared_weak_count **)(a1 + 120);
    if (v18)
    {
      __int16 v19 = std::__shared_weak_count::lock(v18);
      if (v19 && *(void *)(a1 + 112))
      {
        __int16 v20 = "true";
        goto LABEL_47;
      }
    }
    else
    {
      __int16 v19 = 0;
    }
    __int16 v20 = "false";
LABEL_47:
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = v20;
    _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I [d] Valid IMLOutgoingEncodeToken exists: %s", buf, 0xCu);
    if (v19) {
      sub_10004D2C8(v19);
    }
  }
}

void sub_1004FC724(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1004FC748(uint64_t a1)
{
  *(void *)a1 = off_1019DBDA0;
  uint64_t v2 = (void *)(a1 + 32);
  if (*(void *)(a1 + 56)) {
    sub_1000607A8(a1 + 32, *(unsigned char *)(a1 + 64));
  }
  sub_100060644(v2);
  uint64_t v3 = *(void **)(a1 + 8);
  if (v3)
  {
    *(void *)(a1 + 16) = v3;
    operator delete(v3);
  }
  return a1;
}

void sub_1004FC7C0(uint64_t a1)
{
  sub_1004FC748(a1);

  operator delete();
}

uint64_t sub_1004FC7F8(uint64_t result, char a2)
{
  *(unsigned char *)(result + 64) = a2;
  return result;
}

uint64_t sub_1004FC800(uint64_t a1)
{
  return a1 + 8;
}

void sub_1004FC808(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1019DBE10;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1004FC828(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1019DBE10;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_1004FC87C(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 24) + 16))();
}

uint64_t sub_1004FC8A4(uint64_t a1, int a2, uint64_t a3, long long *a4, char a5, uint64_t a6, int a7, char a8)
{
  *(void *)a1 = off_1019DBE60;
  if (*((char *)a4 + 23) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 8), *(void **)a4, *((void *)a4 + 1));
  }
  else
  {
    long long v15 = *a4;
    *(void *)(a1 + 24) = *((void *)a4 + 2);
    *(_OWORD *)(a1 + 8) = v15;
  }
  *(void *)(a1 + 40) = 0;
  *(_DWORD *)(a1 + 32) = a2;
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 56) = 0;
  sub_100448664((void *)(a1 + 40), *(const void **)a3, *(void *)(a3 + 8), (uint64_t)(*(void *)(a3 + 8) - *(void *)a3) >> 2);
  *(unsigned char *)(a1 + 64) = a5;
  *(void *)(a1 + 72) = a6;
  *(_DWORD *)(a1 + 80) = a7;
  *(std::chrono::steady_clock::time_point *)(a1 + 88) = std::chrono::steady_clock::now();
  *(_DWORD *)(a1 + 96) = 0;
  *(unsigned char *)(a1 + 100) = a8;
  return a1;
}

void sub_1004FC97C(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 31) < 0) {
    operator delete(*v2);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1004FC998(uint64_t a1)
{
  *(void *)a1 = off_1019DBE60;
  uint64_t v2 = *(void **)(a1 + 40);
  if (v2)
  {
    *(void *)(a1 + 48) = v2;
    operator delete(v2);
  }
  if (*(char *)(a1 + 31) < 0) {
    operator delete(*(void **)(a1 + 8));
  }
  return a1;
}

void sub_1004FC9FC(uint64_t a1)
{
  sub_1004FC998(a1);

  operator delete();
}

BOOL sub_1004FCA34(uint64_t a1)
{
  std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep v2 = *(void *)(a1 + 72);
  return v2 >= 1 && v2 < (std::chrono::steady_clock::now().__d_.__rep_ - *(void *)(a1 + 88)) / 1000000000
      || *(_DWORD *)(a1 + 96) < *(_DWORD *)(a1 + 80);
}

uint64_t sub_1004FCAA8(uint64_t a1, os_log_t oslog)
{
  if (os_log_type_enabled(oslog, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = "ContextBlocker:";
    _os_log_impl((void *)&_mh_execute_header, oslog, OS_LOG_TYPE_INFO, "DATA:: ------- %s -------", buf, 0xCu);
  }
  uint64_t v61 = 0;
  long long v59 = 0u;
  long long v60 = 0u;
  long long v57 = 0u;
  long long v58 = 0u;
  long long v55 = 0u;
  long long v56 = 0u;
  long long v53 = 0u;
  long long v54 = 0u;
  long long v51 = 0u;
  long long v52 = 0u;
  *(_OWORD *)char v49 = 0u;
  long long v50 = 0u;
  long long v47 = 0u;
  long long v48 = 0u;
  *(_OWORD *)long long buf = 0u;
  long long v46 = 0u;
  sub_10004DE24((uint64_t)buf);
  long long __p = 0uLL;
  uint64_t v42 = 0;
  sub_1004FD2F4((uint64_t)&buf[8], &__p);
  if (SHIBYTE(v42) < 0) {
    operator delete((void *)__p);
  }
  int v4 = sub_10004B96C(buf, (uint64_t)"\t", 1);
  uint64_t v5 = sub_10004B96C(v4, (uint64_t)"fApn=", 5);
  int v6 = *(char *)(a1 + 31);
  if (v6 >= 0) {
    uint64_t v7 = a1 + 8;
  }
  else {
    uint64_t v7 = *(void *)(a1 + 8);
  }
  if (v6 >= 0) {
    uint64_t v8 = *(unsigned __int8 *)(a1 + 31);
  }
  else {
    uint64_t v8 = *(void *)(a1 + 16);
  }
  uint64_t v9 = sub_10004B96C(v5, v7, v8);
  uint64_t v10 = sub_10004B96C(v9, (uint64_t)", ", 2);
  sub_10004B96C(v10, (uint64_t)"fTimeoutSecs=", 13);
  int v11 = (void *)std::ostream::operator<<();
  uint64_t v12 = sub_10004B96C(v11, (uint64_t)", ", 2);
  sub_10004B96C(v12, (uint64_t)"fTries=", 7);
  uint64_t v13 = (void *)std::ostream::operator<<();
  uint64_t v14 = sub_10004B96C(v13, (uint64_t)", ", 2);
  sub_10004B96C(v14, (uint64_t)"blocker is ", 11);
  std::chrono::steady_clock::now();
  long long v15 = (void *)std::ostream::operator<<();
  uint64_t v16 = sub_10004B96C(v15, (uint64_t)" seconds old ", 13);
  char v17 = sub_10004B96C(v16, (uint64_t)", ", 2);
  sub_10004B96C(v17, (uint64_t)"fCurrentTry=", 12);
  char v18 = (void *)std::ostream::operator<<();
  std::ios_base::getloc((const std::ios_base *)((char *)v18 + *(void *)(*v18 - 24)));
  __int16 v19 = std::locale::use_facet((const std::locale *)&__p, &std::ctype<char>::id);
  ((void (*)(const std::locale::facet *, uint64_t))v19->__vftable[2].~facet_0)(v19, 10);
  std::locale::~locale((std::locale *)&__p);
  std::ostream::put();
  std::ostream::flush();
  if (os_log_type_enabled(oslog, OS_LOG_TYPE_INFO))
  {
    sub_10004BC98((uint64_t)&buf[8], &__p);
    __int16 v20 = v42 >= 0 ? &__p : (long long *)__p;
    *(_DWORD *)uint64_t v43 = 136446210;
    __int16 v44 = v20;
    _os_log_impl((void *)&_mh_execute_header, oslog, OS_LOG_TYPE_INFO, "DATA:: %{public}s", v43, 0xCu);
    if (SHIBYTE(v42) < 0) {
      operator delete((void *)__p);
    }
  }
  long long __p = 0uLL;
  uint64_t v42 = 0;
  sub_1004FD2F4((uint64_t)&buf[8], &__p);
  if (SHIBYTE(v42) < 0) {
    operator delete((void *)__p);
  }
  __int16 v21 = sub_10004B96C(buf, (uint64_t)"\t", 1);
  __int16 v22 = sub_10004B96C(v21, (uint64_t)"fType=", 6);
  char v23 = (const char *)asString();
  size_t v24 = strlen(v23);
  int v25 = sub_10004B96C(v22, (uint64_t)v23, v24);
  std::ios_base::getloc((const std::ios_base *)((char *)v25 + *(void *)(*v25 - 24)));
  __int16 v26 = std::locale::use_facet((const std::locale *)&__p, &std::ctype<char>::id);
  ((void (*)(const std::locale::facet *, uint64_t))v26->__vftable[2].~facet_0)(v26, 10);
  std::locale::~locale((std::locale *)&__p);
  std::ostream::put();
  std::ostream::flush();
  uint64_t v27 = *(void *)(a1 + 40);
  for (uint64_t i = *(void *)(a1 + 48); v27 != i; v27 += 4)
  {
    int v29 = sub_10004B96C(buf, (uint64_t)"\t\t", 2);
    sub_10004B96C(v29, (uint64_t)"error=", 6);
    __int16 v30 = (void *)std::ostream::operator<<();
    std::ios_base::getloc((const std::ios_base *)((char *)v30 + *(void *)(*v30 - 24)));
    uint64_t v31 = std::locale::use_facet((const std::locale *)&__p, &std::ctype<char>::id);
    ((void (*)(const std::locale::facet *, uint64_t))v31->__vftable[2].~facet_0)(v31, 10);
    std::locale::~locale((std::locale *)&__p);
    std::ostream::put();
    std::ostream::flush();
  }
  if (os_log_type_enabled(oslog, OS_LOG_TYPE_INFO))
  {
    sub_10004BC98((uint64_t)&buf[8], &__p);
    int v32 = v42 >= 0 ? &__p : (long long *)__p;
    *(_DWORD *)uint64_t v43 = 136446210;
    __int16 v44 = v32;
    _os_log_impl((void *)&_mh_execute_header, oslog, OS_LOG_TYPE_INFO, "DATA:: %{public}s", v43, 0xCu);
    if (SHIBYTE(v42) < 0) {
      operator delete((void *)__p);
    }
  }
  long long __p = 0uLL;
  uint64_t v42 = 0;
  sub_1004FD2F4((uint64_t)&buf[8], &__p);
  if (SHIBYTE(v42) < 0) {
    operator delete((void *)__p);
  }
  uint64_t v33 = sub_10004B96C(buf, (uint64_t)"\t", 1);
  *(_DWORD *)((char *)v33 + *(void *)(*v33 - 24) + 8) |= 1u;
  BOOL v34 = sub_10004B96C(v33, (uint64_t)", ", 2);
  sub_10004B96C(v34, (uint64_t)"fAirplaneModeRecovery=", 22);
  uint64_t v35 = (void *)std::ostream::operator<<();
  int v36 = sub_10004B96C(v35, (uint64_t)", ", 2);
  sub_10004B96C(v36, (uint64_t)"fWifiAPChangeRecovery=", 22);
  char v37 = (void *)std::ostream::operator<<();
  std::ios_base::getloc((const std::ios_base *)((char *)v37 + *(void *)(*v37 - 24)));
  uint64_t v38 = std::locale::use_facet((const std::locale *)&__p, &std::ctype<char>::id);
  ((void (*)(const std::locale::facet *, uint64_t))v38->__vftable[2].~facet_0)(v38, 10);
  std::locale::~locale((std::locale *)&__p);
  std::ostream::put();
  std::ostream::flush();
  if (os_log_type_enabled(oslog, OS_LOG_TYPE_INFO))
  {
    sub_10004BC98((uint64_t)&buf[8], &__p);
    uint64_t v39 = v42 >= 0 ? &__p : (long long *)__p;
    *(_DWORD *)uint64_t v43 = 136446210;
    __int16 v44 = v39;
    _os_log_impl((void *)&_mh_execute_header, oslog, OS_LOG_TYPE_INFO, "DATA:: %{public}s", v43, 0xCu);
    if (SHIBYTE(v42) < 0) {
      operator delete((void *)__p);
    }
  }
  if (SHIBYTE(v50) < 0) {
    operator delete(v49[1]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return std::ios::~ios();
}

void sub_1004FD288(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18)
{
}

void sub_1004FD2F4(uint64_t a1, long long *a2)
{
  uint64_t v4 = a1 + 64;
  if (*(char *)(a1 + 87) < 0) {
    operator delete(*(void **)v4);
  }
  long long v5 = *a2;
  *(void *)(v4 + 16) = *((void *)a2 + 2);
  *(_OWORD *)uint64_t v4 = v5;
  *((unsigned char *)a2 + 23) = 0;
  *(unsigned char *)a2 = 0;

  sub_100146140(a1);
}

void sub_1004FD408(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1004FD65C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1004FD770(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1004FD8B0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void *sub_1004FD900(void *a1)
{
  std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep v2 = a1 + 1;
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v8, kCtLoggingSystemName, "un.ctl");
  uint64_t v3 = dispatch_queue_attr_make_initially_inactive(0);
  uint64_t v4 = dispatch_queue_create_with_target_V2("UserNotificationController", v3, 0);
  dispatch_set_qos_class_floor(v4, QOS_CLASS_UTILITY, 0);
  dispatch_activate(v4);
  long long v5 = v4;

  void *v2 = 0;
  v2[1] = 0;
  int v6 = v5;
  a1[3] = v6;
  a1[4] = 0;

  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v9, &v8);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 5), (const ctu::OsLogLogger *)v9);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v9);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v8);
  *a1 = off_1019DBE90;
  a1[6] = [[UserNotificationControllerImpl alloc] initWithLogger:a1 + 5];
  return a1;
}

void sub_1004FDA30(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v5 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)va1);
  sub_1004FDE68(v3);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)va);
  UserNotificationControllerInterface::~UserNotificationControllerInterface(v2);
  _Unwind_Resume(a1);
}

void sub_1004FDA84(id *a1)
{
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 5));
  sub_1004FDE68((uint64_t)(a1 + 1));

  UserNotificationControllerInterface::~UserNotificationControllerInterface((UserNotificationControllerInterface *)a1);
}

void sub_1004FDAD8(id *a1)
{
  sub_1004FDA84(a1);

  operator delete();
}

void sub_1004FDB10(uint64_t a1, long long *a2)
{
  sub_1004FDEC0((char *)&v4, a2);
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (v3)
  {
    if (std::__shared_weak_count::lock(v3)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_1004FDC74(uint64_t a1, uint64_t a2)
{
  if (*(char *)(a2 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)long long __p = *(_OWORD *)a2;
    __p[2] = *(void **)(a2 + 16);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (v3)
  {
    if (std::__shared_weak_count::lock(v3)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_1004FDDE4()
{
}

void sub_1004FDE44()
{
}

uint64_t sub_1004FDE68(uint64_t a1)
{
  std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep v2 = *(void **)(a1 + 24);
  *(void *)(a1 + 24) = 0;

  uint64_t v3 = *(void **)(a1 + 16);
  *(void *)(a1 + 16) = 0;

  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 8);
  if (v4) {
    std::__shared_weak_count::__release_weak(v4);
  }
  return a1;
}

char *sub_1004FDEC0(char *__dst, long long *a2)
{
  if (*((char *)a2 + 23) < 0)
  {
    sub_10004FC84(__dst, *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v4 = *a2;
    *((void *)__dst + 2) = *((void *)a2 + 2);
    *(_OWORD *)std::string __dst = v4;
  }
  if (*((char *)a2 + 47) < 0)
  {
    sub_10004FC84(__dst + 24, *((void **)a2 + 3), *((void *)a2 + 4));
  }
  else
  {
    long long v5 = *(long long *)((char *)a2 + 24);
    *((void *)__dst + 5) = *((void *)a2 + 5);
    *(_OWORD *)(__dst + 24) = v5;
  }
  __dst[48] = *((unsigned char *)a2 + 48);
  sub_100083DA4((const void **)__dst + 7, (const void **)a2 + 7);
  sub_100083DA4((const void **)__dst + 8, (const void **)a2 + 8);
  int v6 = __dst + 72;
  if (*((char *)a2 + 95) < 0)
  {
    sub_10004FC84(v6, *((void **)a2 + 9), *((void *)a2 + 10));
  }
  else
  {
    long long v7 = *(long long *)((char *)a2 + 72);
    *((void *)__dst + 11) = *((void *)a2 + 11);
    *(_OWORD *)int v6 = v7;
  }
  return __dst;
}

void sub_1004FDFA4(_Unwind_Exception *a1)
{
  sub_1000558F4(v4);
  sub_1000558F4(v3);
  if (*(char *)(v1 + 47) < 0) {
    operator delete(*v2);
  }
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(a1);
}

uint64_t *sub_1004FDFE8(uint64_t *a1)
{
  uint64_t v1 = *a1;
  long long v4 = a1;
  uint64_t v5 = v1;
  std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep v2 = *(void **)(*(void *)v1 + 48);
  sub_1004FDEC0((char *)__dst, (long long *)(v1 + 8));
  objc_msgSend(v2, "publishNotificationWithInfo:", __dst, v4, v5);
  if (v12 < 0) {
    operator delete((void *)v11[1]);
  }
  sub_1000558F4(v11);
  sub_1000558F4(&v10);
  if (v9 < 0) {
    operator delete(v8);
  }
  if (v7 < 0) {
    operator delete(__dst[0]);
  }
  sub_1004FE0EC(&v5);
  return sub_100046B58((uint64_t *)&v4);
}

void sub_1004FE084(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,void *__p,uint64_t a27,int a28,__int16 a29,char a30,char a31)
{
  if (a31 < 0) {
    operator delete(__p);
  }
  sub_1000558F4((const void **)&a25);
  sub_1000558F4((const void **)&a24);
  if (a22 < 0) {
    operator delete(a17);
  }
  if (a16 < 0) {
    operator delete(a11);
  }
  sub_1004FE0EC(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_1004FE0EC(uint64_t *result)
{
  uint64_t v1 = *result;
  *uint64_t result = 0;
  if (v1)
  {
    if (*(char *)(v1 + 103) < 0) {
      operator delete(*(void **)(v1 + 80));
    }
    sub_1000558F4((const void **)(v1 + 72));
    sub_1000558F4((const void **)(v1 + 64));
    if (*(char *)(v1 + 55) < 0) {
      operator delete(*(void **)(v1 + 32));
    }
    if (*(char *)(v1 + 31) < 0) {
      operator delete(*(void **)(v1 + 8));
    }
    operator delete();
  }
  return result;
}

uint64_t *sub_1004FE174(void *a1)
{
  objc_msgSend(*(id *)(*(void *)*a1 + 48), "removeNotificationWithIdentifier:", *a1 + 8, a1, *a1);
  sub_1001102C4(&v3);
  return sub_100046B58(&v2);
}

void sub_1004FE1BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

void sub_1004FE1D8(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_1004FE260(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, __int16 a11, char a12, char a13)
{
  __cxa_begin_catch(a1);
  sub_1004FE28C((uint64_t)&a13, v13);
  __cxa_rethrow();
}

void sub_1004FE278(_Unwind_Exception *a1)
{
}

void sub_1004FE28C(uint64_t a1, id *a2)
{
  uint64_t v3 = sub_100200FB4(a2 + 3);
  dispatch_barrier_async_f(v3, a2, (dispatch_function_t)sub_1004FE3D8);
}

void sub_1004FE2F4(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_1004FE32C(uint64_t a1)
{
  uint64_t v1 = *(id **)(a1 + 24);
  uint64_t v2 = sub_100200FB4(v1 + 3);
  dispatch_barrier_async_f(v2, v1, (dispatch_function_t)sub_1004FE3D8);
}

uint64_t sub_1004FE394(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_1004FE3D8(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void sub_1004FE404()
{
}

void sub_1004FE548(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100057D78((const void **)va);
  (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  _Unwind_Resume(a1);
}

uint64_t sub_1004FE5D8(uint64_t a1)
{
  *(void *)a1 = off_1019DBFC8;
  uint64_t v2 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  sub_1000558F4((const void **)(a1 + 8));
  return a1;
}

void sub_1004FE650(uint64_t a1)
{
  *(void *)a1 = off_1019DBFC8;
  uint64_t v2 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  sub_1000558F4((const void **)(a1 + 8));

  operator delete();
}

uint64_t sub_1004FE6E8(ctu::RestResource *a1, ctu::RestResourceContext *a2, const ctu::PathView *a3)
{
  int v6 = (*(uint64_t (**)(void *))(**((void **)a1 + 2) + 16))(*((void **)a1 + 2));
  return v6 | ctu::RestResource::handleMessage(a1, a2, a3);
}

uint64_t sub_1004FE758(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 16) + 32))();
}

uint64_t sub_1004FE780(uint64_t a1, int a2, ctu::PathView *this)
{
  __dst[0] = 0;
  __dst[1] = 0;
  uint64_t v25 = 0;
  long long v4 = (void *)ctu::PathView::current(this);
  if (v4)
  {
    sub_1000D95C8(__dst, v4, v5);
  }
  else
  {
    __dst[0] = 0;
    __dst[1] = 0;
    uint64_t v25 = 0;
  }
  xpc_object_t v23 = 0;
  __p[0] = xpc_string_create("get");
  if (!__p[0]) {
    __p[0] = xpc_null_create();
  }
  v27[0].fObj = (dispatch_object_s *)xpc_string_create("internal");
  if (!v27[0].fObj) {
    v27[0].fObj = (dispatch_object_s *)xpc_null_create();
  }
  if (v25 >= 0) {
    int v6 = __dst;
  }
  else {
    int v6 = (void **)__dst[0];
  }
  object[0] = xpc_string_create((const char *)v6);
  if (!object[0]) {
    object[0] = xpc_null_create();
  }
  v30.fObj = (dispatch_object_s *)xpc_null_create();
  ctu::rest::createRestMessage((uint64_t *)&v23, (ctu::rest *)__p, v27, (const object *)object, &v30, v7);
  xpc_release(v30.fObj);
  xpc_release(object[0]);
  xpc_release(v27[0].fObj);
  xpc_release(__p[0]);
  object[0] = 0;
  object[1] = 0;
  xpc_object_t v22 = 0;
  sub_1004FEC10(object, (uint64_t)&v23);
  uint64_t v8 = *(void *)(a1 + 16);
  ctu::PathView::PathView();
  (*(void (**)(uint64_t, xpc_object_t *, xpc_object_t *))(*(void *)v8 + 16))(v8, object, __p);
  char v9 = (ctu *)v22;
  if (v22) {
    xpc_retain(v22);
  }
  else {
    char v9 = (ctu *)xpc_null_create();
  }
  CFPropertyListRef value = 0;
  if (xpc_get_type(v9) != (xpc_type_t)&_xpc_type_null)
  {
    ctu::xpc_to_cf((uint64_t *)v27, v9, v10);
    CFPropertyListRef v11 = value;
    CFPropertyListRef value = v27[0].fObj;
    __p[0] = (xpc_object_t)v11;
    v27[0].fObj = 0;
    sub_1000577C4((const void **)__p);
    sub_1000577C4((const void **)&v27[0].fObj);
  }
  if (SHIBYTE(v25) < 0)
  {
    sub_10004FC84(v15, __dst[0], (unint64_t)__dst[1]);
  }
  else
  {
    *(_OWORD *)long long v15 = *(_OWORD *)__dst;
    uint64_t v16 = v25;
  }
  if (SHIBYTE(v16) < 0)
  {
    sub_10004FC84(v27, v15[0], (unint64_t)v15[1]);
  }
  else
  {
    *(_OWORD *)&v27[0].fObj = *(_OWORD *)v15;
    uint64_t v28 = v16;
  }
  __int16 v26 = 0;
  if (SHIBYTE(v28) < 0)
  {
    sub_10004FC84(__p, v27[0].fObj, (unint64_t)v27[1].fObj);
  }
  else
  {
    *(_OWORD *)long long __p = *(_OWORD *)&v27[0].fObj;
    uint64_t v20 = v28;
  }
  int v29 = 0;
  if (ctu::cf::convert_copy())
  {
    char v12 = v26;
    __int16 v26 = v29;
    v30.fObj = v12;
    sub_1000558F4((const void **)&v30.fObj);
  }
  if (SHIBYTE(v20) < 0) {
    operator delete(__p[0]);
  }
  CFStringRef v13 = (const __CFString *)v26;
  char v17 = v26;
  __int16 v26 = 0;
  sub_1000558F4((const void **)&v26);
  if (SHIBYTE(v28) < 0) {
    operator delete(v27[0].fObj);
  }
  if (SHIBYTE(v16) < 0) {
    operator delete(v15[0]);
  }
  CFPreferencesSetValue(v13, value, *(CFStringRef *)(a1 + 8), kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
  CFPreferencesSynchronize(*(CFStringRef *)(a1 + 8), kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
  sub_1000558F4((const void **)&v17);
  sub_1000577C4(&value);
  xpc_release(v9);
  xpc_release(v22);
  xpc_object_t v22 = 0;
  ctu::RestResourceContext::~RestResourceContext((ctu::RestResourceContext *)object);
  xpc_release(v23);
  if (SHIBYTE(v25) < 0) {
    operator delete(__dst[0]);
  }
  return 1;
}

void sub_1004FEAE8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, char a16, int a17, const void *a18, xpc_object_t a19, uint64_t a20,int a21,__int16 a22,char a23,char a24,uint64_t a25,xpc_object_t a26,uint64_t a27,uint64_t a28,xpc_object_t object,void *a30,uint64_t a31,int a32,__int16 a33,char a34,char a35)
{
  sub_1000558F4((const void **)(v36 - 104));
  if (*(char *)(v36 - 73) < 0) {
    operator delete(*(void **)(v36 - 96));
  }
  if (a14 < 0) {
    operator delete(__p);
  }
  sub_1000577C4(&a18);
  xpc_release(v35);
  sub_1004FEC5C(&a26);
  xpc_release(object);
  if (a35 < 0) {
    operator delete(a30);
  }
  _Unwind_Resume(a1);
}

void *sub_1004FEC10(void *a1, uint64_t a2)
{
  *a1 = &off_1019DC070;
  a1[1] = a2;
  a1[2] = xpc_null_create();
  return a1;
}

void sub_1004FEC5C(xpc_object_t *a1)
{
  xpc_release(a1[2]);
  a1[2] = 0;

  ctu::RestResourceContext::~RestResourceContext((ctu::RestResourceContext *)a1);
}

void sub_1004FECA0(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
}

uint64_t sub_1004FECA8(uint64_t a1, xpc_object_t *a2)
{
  xpc_object_t v3 = *a2;
  if (*a2) {
    xpc_retain(*a2);
  }
  else {
    xpc_object_t v3 = xpc_null_create();
  }
  long long v4 = *(void **)(a1 + 16);
  *(void *)(a1 + 16) = v3;
  xpc_release(v4);
  return 1;
}

void sub_1004FECFC(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
}

uint64_t sub_1004FED04()
{
  return 1;
}

uint64_t sub_1004FED0C()
{
  return 1;
}

uint64_t sub_1004FED14()
{
  return 0;
}

void sub_1004FED1C(xpc_object_t *a1)
{
  xpc_release(a1[2]);
  a1[2] = 0;
  ctu::RestResourceContext::~RestResourceContext((ctu::RestResourceContext *)a1);

  operator delete();
}

void sub_1004FED74(uint64_t a1, ctu *a2, uint64_t *a3)
{
  uint64_t v4 = *a3;
  v9[1] = 0;
  uint64_t v10 = 0;
  ctu::cf::assign();
  long long v16 = 0u;
  uint64_t v17 = 0;
  v15.fObj = 0;
  ctu::cf_to_xpc((uint64_t *)&v15, a2, v5);
  xpc_object_t v14 = 0;
  v9[0] = xpc_string_create("set");
  if (!v9[0]) {
    v9[0] = xpc_null_create();
  }
  v11[0] = xpc_string_create("internal");
  if (!v11[0]) {
    v11[0] = xpc_null_create();
  }
  if (v17 >= 0) {
    int v6 = (const char *)&v16;
  }
  else {
    int v6 = (const char *)v16;
  }
  xpc_object_t object = xpc_string_create(v6);
  if (!object) {
    xpc_object_t object = xpc_null_create();
  }
  ctu::rest::createRestMessage((uint64_t *)&v14, (ctu::rest *)v9, (const object *)v11, (const object *)&object, &v15, v7);
  xpc_release(object);
  xpc_release(v11[0]);
  xpc_release(v9[0]);
  v11[0] = 0;
  v11[1] = 0;
  xpc_object_t v12 = 0;
  sub_1004FEC10(v11, (uint64_t)&v14);
  uint64_t v8 = *(void *)(v4 + 16);
  ctu::PathView::PathView();
  (*(void (**)(uint64_t, xpc_object_t *, xpc_object_t *))(*(void *)v8 + 16))(v8, v11, v9);
  xpc_release(v12);
  xpc_object_t v12 = 0;
  ctu::RestResourceContext::~RestResourceContext((ctu::RestResourceContext *)v11);
  xpc_release(v14);
  xpc_release(v15.fObj);
  if (SHIBYTE(v17) < 0) {
    operator delete((void *)v16);
  }
}

void sub_1004FEF34(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, xpc_object_t a16, uint64_t a17, xpc_object_t a18, xpc_object_t object, xpc_object_t a20)
{
  xpc_release(object);
  xpc_release(a16);
  xpc_release(a9);
  xpc_release(*(xpc_object_t *)(v20 - 56));
  if (*(char *)(v20 - 25) < 0) {
    operator delete(*(void **)(v20 - 48));
  }
  _Unwind_Resume(a1);
}

BOOL CarrierBundleHandler::removeVerificationKeys(CarrierBundleHandler *this)
{
  char v7 = 0;
  CFTypeRef v6 = CFPreferencesCopyValue(@"VerifyBundles", @"com.apple.commcenter", kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
  sub_1000BE34C(&v7, &v6);
  if (v7) {
    uint64_t v2 = sub_100084B4C;
  }
  else {
    uint64_t v2 = 0;
  }
  if (v2)
  {
    LOBYTE(v6) = 0;
    ctu::cf::assign((ctu::cf *)&v6, v7, v1);
    int v3 = v6;
    CFPreferencesSetValue(@"VerifyBundles", 0, @"com.apple.commcenter", kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
    BOOL v4 = v3 == 0;
    sub_1003F2A04();
  }
  else
  {
    BOOL v4 = 0;
  }
  sub_100062778((const void **)&v7);
  return v4;
}

void sub_1004FF0BC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100062778((const void **)va);
  _Unwind_Resume(a1);
}

void MMSCServer::MMSCServer(MMSCServer *this, char *a2)
{
  *(void *)this = off_101A35FE0;
  BOOL v4 = (MMSCServer *)((char *)this + 8);
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&__p, kCtLoggingSystemName, "msg.mms.svr");
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v7, &__p);
  ctu::OsLogLogger::OsLogLogger(v4, (const ctu::OsLogLogger *)v7);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v7);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&__p);
  *(void *)this = off_1019DC0F0;
  *((_OWORD *)this + 1) = 0u;
  *((void *)this + 26) = 0;
  *((_DWORD *)this + 57) = 0;
  *((unsigned char *)this + 243) = 0;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 6) = 0u;
  *((_OWORD *)this + 7) = 0u;
  *((_OWORD *)this + 8) = 0u;
  *((_OWORD *)this + 9) = 0u;
  *((_OWORD *)this + 10) = 0u;
  *((_OWORD *)this + 11) = 0u;
  *((_OWORD *)this + 12) = 0u;
  *((_WORD *)this + 108) = 80;
  *((_DWORD *)this + 55) = 0;
  if (a2)
  {
    sub_100058DB0(&__p, a2);
    MMSCServer::setBaseUrl((const void **)this, (uint64_t)&__p);
    if (v6 < 0) {
      operator delete(__p.var0);
    }
  }
  *((_DWORD *)this + 56) = 0x200000;
  *((_DWORD *)this + 58) = 3072;
  *((_WORD *)this + 118) = 1;
  *((unsigned char *)this + 238) = 0;
  *((_WORD *)this + 120) = 0;
  *((unsigned char *)this + 242) = 0;
}

void sub_1004FF220(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  sub_1000FE824(v17);
  if (*(char *)(v15 + 207) < 0) {
    operator delete(*(void **)(v15 + 184));
  }
  if (*(char *)(v15 + 183) < 0) {
    operator delete(*(void **)(v15 + 160));
  }
  if (*(char *)(v15 + 159) < 0) {
    operator delete(*(void **)(v15 + 136));
  }
  if (*(char *)(v15 + 135) < 0) {
    operator delete(*(void **)(v15 + 112));
  }
  if (*(char *)(v15 + 111) < 0) {
    operator delete(*(void **)(v15 + 88));
  }
  if (*(char *)(v15 + 87) < 0) {
    operator delete(*(void **)(v15 + 64));
  }
  if (*(char *)(v15 + 63) < 0) {
    operator delete(*(void **)(v15 + 40));
  }
  if (*(char *)(v15 + 39) < 0) {
    operator delete(*v18);
  }
  ctu::OsLogLogger::~OsLogLogger(v16);
  _Unwind_Resume(a1);
}

const void **MMSCServer::setBaseUrl(const void **result, uint64_t a2)
{
  int v3 = result;
  unint64_t v4 = *(unsigned __int8 *)(a2 + 23);
  if (*(char *)(a2 + 23) < 0)
  {
    unint64_t v6 = *(void *)(a2 + 8);
    if (!v6) {
      return result;
    }
    size_t v5 = *(char **)a2;
  }
  else
  {
    if (!*(unsigned char *)(a2 + 23)) {
      return result;
    }
    size_t v5 = (char *)a2;
    unint64_t v6 = *(unsigned __int8 *)(a2 + 23);
  }
  if (v6 >= 7) {
    unint64_t v6 = 7;
  }
  char v7 = &v5[v6];
  uint64_t v8 = v5;
  char v9 = v7;
  do
  {
    if (*v8 == 104)
    {
      uint64_t v10 = &_mh_execute_header.magic + 1;
      while (v10 != 7)
      {
        if (&v8[v10] == v7) {
          goto LABEL_18;
        }
        int v11 = v8[v10];
        int v12 = aHttp[v10++];
        if (v11 != v12) {
          goto LABEL_10;
        }
      }
      char v9 = v8;
    }
LABEL_10:
    ++v8;
  }
  while (v8 != v7);
LABEL_18:
  if (v9 == v7 || v9 != v5)
  {
    if ((v4 & 0x80u) == 0) {
      CFStringRef v13 = (char *)a2;
    }
    else {
      CFStringRef v13 = *(char **)a2;
    }
    if ((v4 & 0x80u) != 0) {
      unint64_t v4 = *(void *)(a2 + 8);
    }
    if (v4 >= 8) {
      unint64_t v4 = 8;
    }
    if (!v4) {
      goto LABEL_44;
    }
    xpc_object_t v14 = &v13[v4];
    uint64_t v15 = v13;
    long long v16 = v14;
    do
    {
      if (*v15 == 104)
      {
        uint64_t v17 = &_mh_execute_header.magic + 1;
        while (v17 != 8)
        {
          if (&v15[v17] == v14) {
            goto LABEL_39;
          }
          int v18 = v15[v17];
          int v19 = aHttps[v17++];
          if (v18 != v19) {
            goto LABEL_31;
          }
        }
        long long v16 = v15;
      }
LABEL_31:
      ++v15;
    }
    while (v15 != v14);
LABEL_39:
    if (v16 == v14 || v16 != v13)
    {
LABEL_44:
      if (*((char *)result + 39) < 0)
      {
        result[3] = (const void *)7;
        __int16 v21 = result[2];
      }
      else
      {
        __int16 v21 = result + 2;
        *((unsigned char *)result + 39) = 7;
      }
      *(_DWORD *)((char *)v21 + 3) = 791624304;
      _DWORD *v21 = 1886680168;
      uint64_t v20 = (char *)v21 + 7;
      goto LABEL_49;
    }
    v5 += 8;
  }
  else
  {
    v5 += 7;
  }
  if (*((char *)result + 39) < 0)
  {
    result[3] = 0;
    uint64_t v20 = result[2];
  }
  else
  {
    uint64_t v20 = result + 2;
    *((unsigned char *)result + 39) = 0;
  }
LABEL_49:
  *uint64_t v20 = 0;
  xpc_object_t v22 = strchr(v5, 58);
  xpc_object_t v23 = (std::string *)(v3 + 5);
  if (v22) {
    sub_10003ECB8(v23, v5, v22 - v5);
  }
  else {
    sub_10003ED78(v23, v5);
  }
  size_t v24 = (const char *)(v3 + 2);
  int v25 = *(char *)(a2 + 23);
  if (v25 >= 0) {
    __int16 v26 = (const std::string::value_type *)a2;
  }
  else {
    __int16 v26 = *(const std::string::value_type **)a2;
  }
  if (v25 >= 0) {
    std::string::size_type v27 = *(unsigned __int8 *)(a2 + 23);
  }
  else {
    std::string::size_type v27 = *(void *)(a2 + 8);
  }
  std::string::append((std::string *)(v3 + 2), v26, v27);
  if (*((char *)v3 + 39) < 0) {
    size_t v24 = *(const char **)v24;
  }
  CFStringRef v30 = CFStringCreateWithCString(kCFAllocatorDefault, v24, 0x600u);
  CFURLRef v28 = CFURLCreateWithString(kCFAllocatorDefault, v30, 0);
  int v29 = v3[26];
  v3[26] = v28;
  uint64_t v31 = v29;
  sub_1000FE824(&v31);
  return sub_1000558F4((const void **)&v30);
}

void sub_1004FF590(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9)
{
}

void MMSCServer::~MMSCServer(MMSCServer *this)
{
  *(void *)this = off_1019DC0F0;
  sub_1000FE824((const void **)this + 26);
  if (*((char *)this + 207) < 0) {
    operator delete(*((void **)this + 23));
  }
  if (*((char *)this + 183) < 0) {
    operator delete(*((void **)this + 20));
  }
  if (*((char *)this + 159) < 0) {
    operator delete(*((void **)this + 17));
  }
  if (*((char *)this + 135) < 0) {
    operator delete(*((void **)this + 14));
  }
  if (*((char *)this + 111) < 0) {
    operator delete(*((void **)this + 11));
  }
  if (*((char *)this + 87) < 0) {
    operator delete(*((void **)this + 8));
  }
  if (*((char *)this + 63) < 0) {
    operator delete(*((void **)this + 5));
  }
  if (*((char *)this + 39) < 0) {
    operator delete(*((void **)this + 2));
  }
  ctu::OsLogLogger::~OsLogLogger((MMSCServer *)((char *)this + 8));
}

{
  uint64_t vars8;

  MMSCServer::~MMSCServer(this);

  operator delete();
}

std::string *MMSCServer::setProxy(std::string *result, uint64_t a2, __int16 a3)
{
  unint64_t v4 = result;
  uint64_t v5 = *(unsigned __int8 *)(a2 + 23);
  if ((v5 & 0x80u) != 0) {
    uint64_t v5 = *(void *)(a2 + 8);
  }
  if (v5)
  {
    uint64_t result = std::string::operator=((std::string *)((char *)result + 112), (const std::string *)a2);
  }
  else if (result[5].__r_.__value_.__s.__data_[15] < 0)
  {
    *(unsigned char *)result[4].__r_.__value_.__r.__words[2] = 0;
    result[5].__r_.__value_.__r.__words[0] = 0;
  }
  else
  {
    result[4].__r_.__value_.__s.__data_[16] = 0;
    result[5].__r_.__value_.__s.__data_[15] = 0;
  }
  LOWORD(v4[9].__r_.__value_.__l.__data_) = a3;
  return result;
}

uint64_t MMSCServer::prepareMessageForSend(uint64_t a1, uint64_t *a2, long long *a3)
{
  int v3 = a3;
  long long v79 = 0uLL;
  long long v80 = 0;
  if (a3) {
    goto LABEL_2;
  }
  if (!sub_100CCA330(*a2, "X-Mms-Transaction-ID"))
  {
    uint64_t v97 = 0;
    long long v95 = 0u;
    long long v96 = 0u;
    long long v93 = 0u;
    long long v94 = 0u;
    long long v91 = 0u;
    long long v92 = 0u;
    long long v89 = 0u;
    long long v90 = 0u;
    long long v87 = 0u;
    long long v88 = 0u;
    long long v85 = 0u;
    long long v86 = 0u;
    long long v83 = 0u;
    long long v84 = 0u;
    memset(v82, 0, sizeof(v82));
    sub_10004DE24((uint64_t)v82);
    time(0);
    int v25 = (void *)std::ostream::operator<<();
    sub_10004B96C(v25, (uint64_t)"-", 1);
    ++*(_DWORD *)(a1 + 220);
    std::ostream::operator<<();
    sub_10004BC98((uint64_t)&v82[1], &v77);
    if (SHIBYTE(v80) < 0) {
      operator delete((void *)v79);
    }
    long long v79 = v77;
    long long v80 = v78;
    if (SHIBYTE(v78) >= 0) {
      int v3 = &v79;
    }
    else {
      int v3 = (long long *)v77;
    }
    if (SHIBYTE(v86) < 0) {
      operator delete(*((void **)&v85 + 1));
    }
    std::streambuf::~streambuf();
    std::ostream::~ostream();
    std::ios::~ios();
    if (v3) {
LABEL_2:
    }
      sub_100CCA11C(*a2, "X-Mms-Transaction-ID", (uint64_t)v3, 0);
  }
  if (*(char *)(a1 + 159) < 0)
  {
    if (!*(void *)(a1 + 144)) {
      goto LABEL_12;
    }
LABEL_8:
    if (!sub_100CCA330(*a2, "X-Mms-MMS-Version"))
    {
      unint64_t v6 = (void *)(a1 + 136);
      if (*(char *)(a1 + 159) < 0) {
        unint64_t v6 = (void *)*v6;
      }
      sub_100CCA11C(*a2, "X-Mms-MMS-Version", (uint64_t)v6, 0);
    }
    goto LABEL_12;
  }
  if (*(unsigned char *)(a1 + 159)) {
    goto LABEL_8;
  }
LABEL_12:
  if (*(int *)(a1 + 228) >= 1)
  {
    uint64_t v7 = sub_100CCA330(*a2, "Subject");
    uint64_t v8 = v7;
    if (v7)
    {
      long long v77 = 0uLL;
      uint64_t v78 = 0;
      if ((*(unsigned int (**)(uint64_t, long long *))(*(void *)v7 + 72))(v7, &v77))
      {
        if (SHIBYTE(v78) >= 0) {
          char v9 = (char *)HIBYTE(v78);
        }
        else {
          char v9 = (char *)*((void *)&v77 + 1);
        }
        unint64_t v10 = *(int *)(a1 + 228);
        if ((unint64_t)v9 > v10)
        {
          long long v70 = v9;
          size_t v11 = (v10 + 1);
          __chkstk_darwin();
          bzero((char *)&v70 - ((v11 + 15) & 0x1FFFFFFF0), v11);
          Mutable = CFStringCreateMutable(0, 0);
          CFStringRef v13 = Mutable;
          if (SHIBYTE(v78) >= 0) {
            xpc_object_t v14 = (const char *)&v77;
          }
          else {
            xpc_object_t v14 = (const char *)v77;
          }
          CFStringAppendCString(Mutable, v14, 0x8000100u);
          v71 = &v70;
          CFIndex Length = CFStringGetLength(v13);
          uint64_t v16 = a1;
          CFIndex v17 = *(int *)(a1 + 228);
          CFIndex v18 = CFStringGetLength(v13);
          if (Length - 1 >= v17) {
            CFIndex v19 = v17;
          }
          else {
            CFIndex v19 = Length - 1;
          }
          v98.length = v18 - v19;
          v98.location = v19;
          CFStringDelete(v13, v98);
          *(void *)&long long v20 = 134217984;
          long long v72 = v20;
          while ((v19 & 0x8000000000000000) == 0)
          {
            int CString = CFStringGetCString(v13, (char *)&v70 - ((v11 + 15) & 0x1FFFFFFF0), v11, 0x8000100u);
            xpc_object_t v22 = *(NSObject **)(v16 + 8);
            BOOL v23 = os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT);
            if (CString)
            {
              if (v23)
              {
                __int16 v26 = (char *)strlen((const char *)&v70 - ((v11 + 15) & 0x1FFFFFFF0));
                LODWORD(v82[0]) = 134218496;
                *(char **)((char *)v82 + 4) = v70;
                WORD2(v82[1]) = 2048;
                *(char **)((char *)&v82[1] + 6) = v26;
                HIWORD(v82[2]) = 2048;
                v82[3] = (char *)v19;
                _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "#I MMS subject truncated from %zu bytes to %zu bytes (%ld characters) due to carrier setting", (uint8_t *)v82, 0x20u);
              }
              (*(void (**)(uint64_t, char *))(*(void *)v8 + 16))(v8, (char *)&v70 - ((v11 + 15) & 0x1FFFFFFF0));
              break;
            }
            if (v23)
            {
              LODWORD(v82[0]) = v72;
              *(char **)((char *)v82 + 4) = (char *)v19;
              _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "#I MMS subject truncation to %ld characters failed (partial code-point); trying again...",
                (uint8_t *)v82,
                0xCu);
            }
            v99.location = --v19;
            v99.length = 1;
            CFStringDelete(v13, v99);
          }
          CFRelease(v13);
          a1 = v16;
        }
      }
      else
      {
        size_t v24 = *(NSObject **)(a1 + 8);
        if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
        {
          LOWORD(v82[0]) = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "Could not access MMS subject for truncation detection", (uint8_t *)v82, 2u);
        }
      }
      if (SHIBYTE(v78) < 0) {
        operator delete((void *)v77);
      }
    }
  }
  if (*(char *)(a1 + 207) < 0)
  {
    if (!*(void *)(a1 + 192)) {
      goto LABEL_167;
    }
  }
  else if (!*(unsigned char *)(a1 + 207))
  {
    goto LABEL_167;
  }
  memset(v82, 0, 24);
  long long v77 = 0uLL;
  uint64_t v78 = 0;
  sub_100CCA430(*a2, "To", v82);
  if (v82[1] == v82[0])
  {
    memset(&v76, 0, sizeof(v76));
    goto LABEL_161;
  }
  unint64_t v27 = 0;
  v71 = (char **)a1;
  *(void *)&long long v72 = a1 + 184;
  if ((unint64_t)((v82[1] - v82[0]) >> 3) <= 1) {
    int64_t v28 = 1;
  }
  else {
    int64_t v28 = (v82[1] - v82[0]) >> 3;
  }
  do
  {
    if (v27 >= (v82[1] - v82[0]) >> 3) {
      sub_10015B728();
    }
    uint64_t v29 = (*(uint64_t (**)(void))(**(void **)&v82[0][8 * v27] + 80))(*(void *)&v82[0][8 * v27]);
    uint64_t v30 = v29;
    uint64_t v31 = *((void *)&v77 + 1);
    if (*((void *)&v77 + 1) >= (unint64_t)v78)
    {
      uint64_t v33 = (uint64_t)(*((void *)&v77 + 1) - v77) >> 3;
      if ((unint64_t)(v33 + 1) >> 61) {
        sub_10006A748();
      }
      unint64_t v34 = (uint64_t)&v78[-v77] >> 2;
      if (v34 <= v33 + 1) {
        unint64_t v34 = v33 + 1;
      }
      if ((unint64_t)&v78[-v77] >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v35 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v35 = v34;
      }
      if (v35) {
        uint64_t v36 = (char *)sub_10004EF74((uint64_t)&v78, v35);
      }
      else {
        uint64_t v36 = 0;
      }
      char v37 = (uint64_t *)&v36[8 * v33];
      *char v37 = v30;
      int v32 = v37 + 1;
      uint64_t v38 = (char *)*((void *)&v77 + 1);
      uint64_t v39 = (char *)v77;
      if (*((void *)&v77 + 1) != (void)v77)
      {
        do
        {
          uint64_t v40 = *((void *)v38 - 1);
          v38 -= 8;
          *--char v37 = v40;
        }
        while (v38 != v39);
        uint64_t v38 = (char *)v77;
      }
      *(void *)&long long v77 = v37;
      *((void *)&v77 + 1) = v32;
      uint64_t v78 = &v36[8 * v35];
      if (v38) {
        operator delete(v38);
      }
    }
    else
    {
      **((void **)&v77 + 1) = v29;
      int v32 = (void *)(v31 + 8);
    }
    *((void *)&v77 + 1) = v32;
    sub_100CCA1F8((void *)*a2, "To");
    ++v27;
  }
  while (v27 != v28);
  unint64_t v41 = 0;
  memset(&v76, 0, sizeof(v76));
  memset(&v75, 0, sizeof(v75));
  do
  {
    if (v41 >= (uint64_t)(*((void *)&v77 + 1) - v77) >> 3) {
      sub_10015B728();
    }
    (*(void (**)(void, std::string *))(**(void **)(v77 + 8 * v41) + 72))(*(void *)(v77 + 8 * v41), &v76);
    memset(&v74, 0, sizeof(v74));
    if (SHIBYTE(v76.__r_.__value_.__r.__words[2]) < 0) {
      sub_10004FC84(&v74, v76.__r_.__value_.__l.__data_, v76.__r_.__value_.__l.__size_);
    }
    else {
      std::string v74 = v76;
    }
    unsigned int v42 = HIBYTE(v74.__r_.__value_.__r.__words[2]);
    if ((v74.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      uint64_t v43 = (std::string *)((char *)&v74 + HIBYTE(v74.__r_.__value_.__r.__words[2]));
    }
    else {
      uint64_t v43 = (std::string *)(v74.__r_.__value_.__r.__words[0] + v74.__r_.__value_.__l.__size_);
    }
    if ((v74.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      __int16 v44 = &v74;
    }
    else {
      __int16 v44 = (std::string *)v74.__r_.__value_.__r.__words[0];
    }
    if (v44 != v43)
    {
      do
      {
        v44->__r_.__value_.__s.__data_[0] = __tolower(v44->__r_.__value_.__s.__data_[0]);
        __int16 v44 = (std::string *)((char *)v44 + 1);
      }
      while (v44 != v43);
      unsigned int v42 = HIBYTE(v74.__r_.__value_.__r.__words[2]);
    }
    if ((v42 & 0x80) != 0)
    {
      size_t size = v74.__r_.__value_.__l.__size_;
      if (!v74.__r_.__value_.__l.__size_) {
        goto LABEL_170;
      }
      long long v46 = (std::string *)v74.__r_.__value_.__r.__words[0];
      if (*v74.__r_.__value_.__l.__data_ != 43) {
        goto LABEL_133;
      }
      if (v74.__r_.__value_.__l.__size_ <= 1) {
LABEL_170:
      }
        sub_1000C14D8();
      if (*(unsigned char *)(v74.__r_.__value_.__r.__words[0] + 1) == 49)
      {
LABEL_133:
        std::string::operator=(&v75, &v76);
        goto LABEL_134;
      }
    }
    else
    {
      if (!v42) {
        goto LABEL_170;
      }
      if (v74.__r_.__value_.__s.__data_[0] != 43) {
        goto LABEL_133;
      }
      if (v42 <= 1) {
        goto LABEL_170;
      }
      if (v74.__r_.__value_.__s.__data_[1] == 49) {
        goto LABEL_133;
      }
      size_t size = v42;
      long long v46 = &v74;
    }
    long long v47 = memchr(v46, 64, size);
    if (v47 && v47 - (unsigned char *)v46 != -1) {
      goto LABEL_133;
    }
    int64_t v48 = v74.__r_.__value_.__l.__size_;
    if ((v42 & 0x80u) != 0)
    {
      char v49 = (std::string *)v74.__r_.__value_.__r.__words[0];
    }
    else
    {
      int64_t v48 = v42;
      char v49 = &v74;
    }
    if (v48 < 10) {
      goto LABEL_133;
    }
    long long v50 = (char *)v49 + v48;
    long long v51 = v49;
    while (1)
    {
      long long v52 = (char *)memchr(v51, 47, v48 - 9);
      if (!v52) {
        goto LABEL_133;
      }
      if (*(void *)v52 == 0x6C703D657079742FLL && *((_WORD *)v52 + 4) == 28269) {
        break;
      }
      long long v51 = (std::string *)(v52 + 1);
      int64_t v48 = v50 - (char *)v51;
      if (v50 - (char *)v51 < 10) {
        goto LABEL_133;
      }
    }
    if (v52 == v50 || v52 - (char *)v49 == -1) {
      goto LABEL_133;
    }
    std::string::basic_string(&v73, &v74, 1uLL, 3uLL, (std::allocator<char> *)&v81);
    if ((v73.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type v54 = HIBYTE(v73.__r_.__value_.__r.__words[2]);
    }
    else {
      std::string::size_type v54 = v73.__r_.__value_.__l.__size_;
    }
    long long v55 = (char *)*((unsigned __int8 *)v71 + 207);
    int v56 = (char)v55;
    if ((char)v55 < 0) {
      long long v55 = v71[24];
    }
    if ((char *)v54 == v55)
    {
      if (v56 >= 0) {
        long long v57 = (unsigned __int8 *)v72;
      }
      else {
        long long v57 = *(unsigned __int8 **)v72;
      }
      if ((*((unsigned char *)&v73.__r_.__value_.__s + 23) & 0x80) != 0)
      {
        uint64_t v64 = (void *)v73.__r_.__value_.__r.__words[0];
        int v65 = memcmp(v73.__r_.__value_.__l.__data_, v57, v73.__r_.__value_.__l.__size_);
        operator delete(v64);
        if (!v65) {
          goto LABEL_155;
        }
      }
      else
      {
        if (!*((unsigned char *)&v73.__r_.__value_.__s + 23)) {
          goto LABEL_155;
        }
        uint64_t v58 = 0;
        do
        {
          int v59 = v73.__r_.__value_.__s.__data_[v58];
          int v60 = v57[v58];
        }
        while (v59 == v60 && HIBYTE(v73.__r_.__value_.__r.__words[2]) - 1 != v58++);
        if (v59 == v60)
        {
LABEL_155:
          std::string::basic_string(&v73, &v76, 1uLL, 0xFFFFFFFFFFFFFFFFLL, (std::allocator<char> *)&v81);
          if (SHIBYTE(v75.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v75.__r_.__value_.__l.__data_);
          }
          std::string v75 = v73;
          goto LABEL_134;
        }
      }
    }
    else if ((*((unsigned char *)&v73.__r_.__value_.__s + 23) & 0x80) != 0)
    {
      operator delete(v73.__r_.__value_.__l.__data_);
    }
    std::string::operator=(&v75, (const std::string *)v72);
    std::string::basic_string(&v73, &v76, 1uLL, 0xFFFFFFFFFFFFFFFFLL, (std::allocator<char> *)&v81);
    if ((v73.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      uint64_t v66 = &v73;
    }
    else {
      uint64_t v66 = (std::string *)v73.__r_.__value_.__r.__words[0];
    }
    if ((v73.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type v67 = HIBYTE(v73.__r_.__value_.__r.__words[2]);
    }
    else {
      std::string::size_type v67 = v73.__r_.__value_.__l.__size_;
    }
    std::string::append(&v75, (const std::string::value_type *)v66, v67);
    if (SHIBYTE(v73.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v73.__r_.__value_.__l.__data_);
    }
LABEL_134:
    if ((v75.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      uint64_t v62 = &v75;
    }
    else {
      uint64_t v62 = (std::string *)v75.__r_.__value_.__r.__words[0];
    }
    sub_100CCA11C(*a2, "To", (uint64_t)v62, 1);
    if (v41 >= (uint64_t)(*((void *)&v77 + 1) - v77) >> 3) {
      sub_10015B728();
    }
    uint64_t v63 = *(void *)(v77 + 8 * v41);
    if (v63) {
      (*(void (**)(uint64_t))(*(void *)v63 + 8))(v63);
    }
    if (SHIBYTE(v74.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v74.__r_.__value_.__l.__data_);
    }
    ++v41;
  }
  while (v41 != v28);
  if (SHIBYTE(v75.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v75.__r_.__value_.__l.__data_);
  }
LABEL_161:
  if (SHIBYTE(v76.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v76.__r_.__value_.__l.__data_);
  }
  if ((void)v77)
  {
    *((void *)&v77 + 1) = v77;
    operator delete((void *)v77);
  }
  if (v82[0])
  {
    v82[1] = v82[0];
    operator delete(v82[0]);
  }
LABEL_167:
  uint64_t v68 = sub_10022C514(*a2);
  if (SHIBYTE(v80) < 0) {
    operator delete((void *)v79);
  }
  return v68;
}

void sub_10050021C(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 87) < 0) {
    operator delete(*(void **)(v1 + 64));
  }
  if (*(char *)(v1 + 119) < 0) {
    operator delete(*(void **)(v1 + 96));
  }
  if (*(char *)(v1 + 151) < 0) {
    operator delete(*(void **)(v1 + 128));
  }
  int v3 = *(void **)(v1 + 152);
  if (v3)
  {
    *(void *)(v1 + 160) = v3;
    operator delete(v3);
  }
  unint64_t v4 = *(void **)(v1 + 208);
  if (v4)
  {
    *(void *)(v1 + 216) = v4;
    operator delete(v4);
  }
  if (*(char *)(v1 + 199) < 0) {
    operator delete(*(void **)(v1 + 176));
  }
  _Unwind_Resume(exception_object);
}

BOOL MMSCServer::getTuncMMSSubject(MMSCServer *this)
{
  return *((_DWORD *)this + 57) > 0;
}

uint64_t MMSCServer::getMaxMMSSubjectLen(MMSCServer *this)
{
  return *((unsigned int *)this + 57);
}

const void **MMSCServer::getBaseUrl@<X0>(const void **this@<X0>, const void **a2@<X8>)
{
  return sub_100119B5C(a2, this + 26);
}

uint64_t MMSCServer::getBaseUrlStr(MMSCServer *this)
{
  return (uint64_t)this + 16;
}

std::string *MMSCServer::setUserAgentProfile(uint64_t a1, const std::string *a2)
{
  return std::string::operator=((std::string *)(a1 + 64), a2);
}

uint64_t MMSCServer::getUserAgentProfile(MMSCServer *this)
{
  return (uint64_t)this + 64;
}

std::string *MMSCServer::setUserAgent(uint64_t a1, const std::string *a2)
{
  return std::string::operator=((std::string *)(a1 + 88), a2);
}

uint64_t MMSCServer::getUserAgent(MMSCServer *this)
{
  return (uint64_t)this + 88;
}

uint64_t MMSCServer::getHost(MMSCServer *this)
{
  return (uint64_t)this + 40;
}

uint64_t MMSCServer::getProxyHost(MMSCServer *this)
{
  return (uint64_t)this + 112;
}

uint64_t MMSCServer::getMMSVersion(MMSCServer *this)
{
  return (uint64_t)this + 136;
}

std::string *MMSCServer::setMMSVersion(uint64_t a1, const std::string *a2)
{
  return std::string::operator=((std::string *)(a1 + 136), a2);
}

uint64_t MMSCServer::getProxyPort(MMSCServer *this)
{
  return *((__int16 *)this + 108);
}

uint64_t MMSCServer::setMaxMessageSize(uint64_t this, int a2)
{
  *(_DWORD *)(this + 224) = a2;
  return this;
}

uint64_t MMSCServer::getMaxMessageSize(MMSCServer *this)
{
  return *((unsigned int *)this + 56);
}

uint64_t MMSCServer::setMaxMessageSizeOverSatellite(uint64_t this, int a2)
{
  *(_DWORD *)(this + 232) = a2;
  return this;
}

uint64_t MMSCServer::getMaxMessageSizeOverSatellite(MMSCServer *this)
{
  return *((unsigned int *)this + 58);
}

uint64_t MMSCServer::getEnableNotifyResp(MMSCServer *this)
{
  return *((unsigned __int8 *)this + 236);
}

uint64_t MMSCServer::setEnableNotifyResp(uint64_t this, char a2)
{
  *(unsigned char *)(this + 236) = a2;
  return this;
}

uint64_t MMSCServer::getEnableAck(MMSCServer *this)
{
  return *((unsigned __int8 *)this + 237);
}

uint64_t MMSCServer::getAllowReports(MMSCServer *this)
{
  return *((unsigned __int8 *)this + 238);
}

uint64_t MMSCServer::setEnableAck(uint64_t this, char a2)
{
  *(unsigned char *)(this + 237) = a2;
  return this;
}

uint64_t MMSCServer::setAllowReports(uint64_t this, char a2)
{
  *(unsigned char *)(this + 238) = a2;
  return this;
}

uint64_t MMSCServer::getEnableRejectMMSIfTooLarge(MMSCServer *this)
{
  return *((unsigned __int8 *)this + 239);
}

uint64_t MMSCServer::setEnableRejectMMSIfTooLarge(uint64_t this, char a2)
{
  *(unsigned char *)(this + 239) = a2;
  return this;
}

uint64_t MMSCServer::getSendRejectNotificationIfTooLarge(MMSCServer *this)
{
  return *((unsigned __int8 *)this + 243);
}

uint64_t MMSCServer::setSendRejectNotificationIfTooLarge(uint64_t this, char a2)
{
  *(unsigned char *)(this + 243) = a2;
  return this;
}

uint64_t MMSCServer::getCanUseTransactionIdWithContentLocation(MMSCServer *this)
{
  return *((unsigned __int8 *)this + 240);
}

uint64_t MMSCServer::setCanUseTransactionIdWithContentLocation(uint64_t this, char a2)
{
  *(unsigned char *)(this + 240) = a2;
  return this;
}

uint64_t MMSCServer::getAllowFetchFromMultipleMMSCs(MMSCServer *this)
{
  return *((unsigned __int8 *)this + 241);
}

uint64_t MMSCServer::setAllowFetchFromMultipleMMSCs(uint64_t this, char a2)
{
  *(unsigned char *)(this + 241) = a2;
  return this;
}

uint64_t MMSCServer::getCarrierRequiredPhoneNumberHeaderName(MMSCServer *this)
{
  return (uint64_t)this + 160;
}

std::string *MMSCServer::setCarrierRequiredPhoneNumberHeaderName(uint64_t a1, const std::string *a2)
{
  return std::string::operator=((std::string *)(a1 + 160), a2);
}

uint64_t MMSCServer::getExplicitInternationalDialingCode(MMSCServer *this)
{
  return (uint64_t)this + 184;
}

std::string *MMSCServer::setExplicitInternationalDialingCode(uint64_t a1, const std::string *a2)
{
  return std::string::operator=((std::string *)(a1 + 184), a2);
}

uint64_t MMSCServer::verbose(MMSCServer *this)
{
  return *((unsigned __int8 *)this + 242);
}

uint64_t MMSCServer::setVerbose(uint64_t this, char a2)
{
  *(unsigned char *)(this + 242) = a2;
  return this;
}

uint64_t MMSCServer::setNumberPrefixRequiresInternationalSymbol(uint64_t this, int a2)
{
  *(_DWORD *)(this + 244) = a2;
  return this;
}

uint64_t MMSCServer::getNumberPrefixRequiresInternationalSymbol(MMSCServer *this)
{
  return *((unsigned int *)this + 61);
}

uint64_t MMSCServer::setMaxMMSSubjectLen(uint64_t this, int a2)
{
  *(_DWORD *)(this + 228) = a2;
  return this;
}

void MMSCServer::dumpState(MMSCServer *this)
{
  uint64_t v2 = *((void *)this + 1);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    int v3 = (char *)this + 16;
    if (*((char *)this + 39) < 0) {
      int v3 = *(const char **)v3;
    }
    int v24 = 136315138;
    int v25 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Base URL: %s", (uint8_t *)&v24, 0xCu);
    uint64_t v2 = *((void *)this + 1);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    unint64_t v4 = (char *)this + 40;
    if (*((char *)this + 63) < 0) {
      unint64_t v4 = *(const char **)v4;
    }
    int v24 = 136315138;
    int v25 = v4;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Host name: %s", (uint8_t *)&v24, 0xCu);
    uint64_t v2 = *((void *)this + 1);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = (char *)this + 64;
    if (*((char *)this + 87) < 0) {
      uint64_t v5 = *(const char **)v5;
    }
    int v24 = 136315138;
    int v25 = v5;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I UA prof: %s", (uint8_t *)&v24, 0xCu);
    uint64_t v2 = *((void *)this + 1);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    unint64_t v6 = (char *)this + 88;
    if (*((char *)this + 111) < 0) {
      unint64_t v6 = *(const char **)v6;
    }
    int v24 = 136315138;
    int v25 = v6;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I User agent: %s", (uint8_t *)&v24, 0xCu);
    uint64_t v2 = *((void *)this + 1);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v7 = (char *)this + 112;
    if (*((char *)this + 135) < 0) {
      uint64_t v7 = *(const char **)v7;
    }
    int v24 = 136315138;
    int v25 = v7;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Proxy host: %s", (uint8_t *)&v24, 0xCu);
    uint64_t v2 = *((void *)this + 1);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v8 = (char *)this + 136;
    if (*((char *)this + 159) < 0) {
      uint64_t v8 = *(const char **)v8;
    }
    int v24 = 136315138;
    int v25 = v8;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Mms version: %s", (uint8_t *)&v24, 0xCu);
    uint64_t v2 = *((void *)this + 1);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    int v9 = *((__int16 *)this + 108);
    int v24 = 67109120;
    LODWORD(v25) = v9;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Proxy port: %d", (uint8_t *)&v24, 8u);
    uint64_t v2 = *((void *)this + 1);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    int v10 = *((_DWORD *)this + 55);
    int v24 = 67109120;
    LODWORD(v25) = v10;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Next transaction id: %u", (uint8_t *)&v24, 8u);
    uint64_t v2 = *((void *)this + 1);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    int v11 = *((_DWORD *)this + 56);
    int v24 = 67109120;
    LODWORD(v25) = v11;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Max mms size: %u", (uint8_t *)&v24, 8u);
    uint64_t v2 = *((void *)this + 1);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    int v12 = *((_DWORD *)this + 57);
    int v24 = 67109120;
    LODWORD(v25) = v12;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Max mms subject len: %u", (uint8_t *)&v24, 8u);
    uint64_t v2 = *((void *)this + 1);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    int v13 = *((unsigned __int8 *)this + 236);
    int v24 = 67109120;
    LODWORD(v25) = v13;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Enable notify response: %u", (uint8_t *)&v24, 8u);
    uint64_t v2 = *((void *)this + 1);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    if (*((unsigned char *)this + 237)) {
      xpc_object_t v14 = "true";
    }
    else {
      xpc_object_t v14 = "false";
    }
    int v24 = 136315138;
    int v25 = v14;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Enable ack: %s", (uint8_t *)&v24, 0xCu);
    uint64_t v2 = *((void *)this + 1);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    if (*((unsigned char *)this + 238)) {
      uint64_t v15 = "true";
    }
    else {
      uint64_t v15 = "false";
    }
    int v24 = 136315138;
    int v25 = v15;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Allow reports: %s", (uint8_t *)&v24, 0xCu);
    uint64_t v2 = *((void *)this + 1);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    if (*((unsigned char *)this + 239)) {
      uint64_t v16 = "true";
    }
    else {
      uint64_t v16 = "false";
    }
    int v24 = 136315138;
    int v25 = v16;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Enable reject mms if too large: %s", (uint8_t *)&v24, 0xCu);
    uint64_t v2 = *((void *)this + 1);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    if (*((unsigned char *)this + 243)) {
      CFIndex v17 = "true";
    }
    else {
      CFIndex v17 = "false";
    }
    int v24 = 136315138;
    int v25 = v17;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Send reject notification if mmms too large: %s", (uint8_t *)&v24, 0xCu);
    uint64_t v2 = *((void *)this + 1);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    if (*((unsigned char *)this + 240)) {
      CFIndex v18 = "true";
    }
    else {
      CFIndex v18 = "false";
    }
    int v24 = 136315138;
    int v25 = v18;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Can use transaction id with content location: %s", (uint8_t *)&v24, 0xCu);
    uint64_t v2 = *((void *)this + 1);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    if (*((unsigned char *)this + 241)) {
      CFIndex v19 = "true";
    }
    else {
      CFIndex v19 = "false";
    }
    int v24 = 136315138;
    int v25 = v19;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Allow fetch from multiple mmscs: %s", (uint8_t *)&v24, 0xCu);
    uint64_t v2 = *((void *)this + 1);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    long long v20 = (char *)this + 160;
    if (*((char *)this + 183) < 0) {
      long long v20 = *(const char **)v20;
    }
    int v24 = 136315138;
    int v25 = v20;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Carrier require phone number header name: %s", (uint8_t *)&v24, 0xCu);
    uint64_t v2 = *((void *)this + 1);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    __int16 v21 = (char *)this + 184;
    if (*((char *)this + 207) < 0) {
      __int16 v21 = *(const char **)v21;
    }
    int v24 = 136315138;
    int v25 = v21;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Explicit Internation dialing code: %s", (uint8_t *)&v24, 0xCu);
    uint64_t v2 = *((void *)this + 1);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    if (*((unsigned char *)this + 242)) {
      xpc_object_t v22 = "true";
    }
    else {
      xpc_object_t v22 = "false";
    }
    int v24 = 136315138;
    int v25 = v22;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Verbose: %s", (uint8_t *)&v24, 0xCu);
    uint64_t v2 = *((void *)this + 1);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    if (*((_DWORD *)this + 61)) {
      BOOL v23 = "true";
    }
    else {
      BOOL v23 = "false";
    }
    int v24 = 136315138;
    int v25 = v23;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Number prefix requires international symbol: %s", (uint8_t *)&v24, 0xCu);
  }
}

double sub_100500B70@<D0>(uint64_t a1@<X0>, _OWORD *a2@<X8>)
{
  sub_1005ADB10((void *)(a1 + 8), v4);
  double result = v4[0];
  *a2 = *(_OWORD *)v4;
  return result;
}

void sub_100500BB0(SubscriptionConfigurationFactoryInterface *this)
{
  *(void *)this = off_1019DC2B8;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }

  SubscriptionConfigurationFactoryInterface::~SubscriptionConfigurationFactoryInterface(this);
}

void sub_100500C0C(SubscriptionConfigurationFactoryInterface *this)
{
  *(void *)this = off_1019DC2B8;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  SubscriptionConfigurationFactoryInterface::~SubscriptionConfigurationFactoryInterface(this);

  operator delete();
}

void sub_100500C7C(uint64_t a1@<X0>, NSObject **a2@<X1>, uint64_t *a3@<X8>)
{
  unint64_t v6 = (std::__shared_weak_count *)operator new(0xA0uLL);
  v6->__shared_owners_ = 0;
  v6->__shared_weak_owners_ = 0;
  v6->__vftable = (std::__shared_weak_count_vtbl *)off_1019DC3E0;
  uint64_t v7 = (uint64_t)&v6[1];
  uint64_t v8 = *a2;
  *a2 = 0;
  dispatch_object_t object = v8;
  sub_100500F50((uint64_t)&v6[1], a1, &object);
  if (object) {
    dispatch_release(object);
  }
  v6[1].__vftable = (std::__shared_weak_count_vtbl *)off_1019DC430;
  shared_weak_owners = (std::__shared_weak_count *)v6[1].__shared_weak_owners_;
  if (!shared_weak_owners)
  {
    atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit(&v6->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    v6[1].__shared_owners_ = v7;
    v6[1].__shared_weak_owners_ = (uint64_t)v6;
    goto LABEL_7;
  }
  if (shared_weak_owners->__shared_owners_ == -1)
  {
    atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit(&v6->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    v6[1].__shared_owners_ = v7;
    v6[1].__shared_weak_owners_ = (uint64_t)v6;
    std::__shared_weak_count::__release_weak(shared_weak_owners);
LABEL_7:
    sub_10004D2C8(v6);
  }
  sub_100500DC4(v7);
  *a3 = v7;
  a3[1] = (uint64_t)v6;
}

void sub_100500D90(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object)
{
  sub_10004D2C8(v10);
  _Unwind_Resume(a1);
}

void sub_100500DC4(uint64_t a1)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 48));
  int v3 = ServiceMap;
  if (v4 < 0)
  {
    uint64_t v5 = (unsigned __int8 *)(v4 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v6 = 5381;
    do
    {
      uint64_t v4 = v6;
      unsigned int v7 = *v5++;
      uint64_t v6 = (33 * v6) ^ v7;
    }
    while (v7);
  }
  std::mutex::lock(ServiceMap);
  *(void *)&long long v15 = v4;
  uint64_t v8 = sub_10004D37C(&v3[1].__m_.__sig, (unint64_t *)&v15);
  if (v8)
  {
    uint64_t v10 = v8[3];
    int v9 = (std::__shared_weak_count *)v8[4];
    if (v9)
    {
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v3);
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v9);
      char v11 = 0;
      if (!v10) {
        goto LABEL_7;
      }
      goto LABEL_11;
    }
  }
  else
  {
    uint64_t v10 = 0;
  }
  std::mutex::unlock(v3);
  int v9 = 0;
  char v11 = 1;
  if (!v10)
  {
LABEL_7:
    int v12 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v15) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "NanoPreferencesSyncFactoryInterface is not set!", (uint8_t *)&v15, 2u);
    }
    goto LABEL_14;
  }
LABEL_11:
  (*(void (**)(long long *__return_ptr, uint64_t))(*(void *)v10 + 16))(&v15, v10);
  long long v13 = v15;
  long long v15 = 0uLL;
  xpc_object_t v14 = *(std::__shared_weak_count **)(a1 + 104);
  *(_OWORD *)(a1 + 96) = v13;
  if (v14)
  {
    sub_10004D2C8(v14);
    if (*((void *)&v15 + 1)) {
      sub_10004D2C8(*((std::__shared_weak_count **)&v15 + 1));
    }
  }
LABEL_14:
  if ((v11 & 1) == 0) {
    sub_10004D2C8(v9);
  }
}

void sub_100500F34(_Unwind_Exception *exception_object)
{
  if ((v2 & 1) == 0) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100500F50(uint64_t a1, uint64_t a2, NSObject **a3)
{
  int v9 = *a3;
  *a3 = 0;
  sub_1011DD9C4((void *)a1, a2, &v9, (uint64_t)"SuppServicesPreferencesSource", "set.supp.prefs");
  if (v9) {
    dispatch_release(v9);
  }
  *(void *)a1 = off_1019DC2F8;
  *(void *)(a1 + 96) = 0;
  *(void *)(a1 + 104) = 0;
  sub_100058DB0(&__p, "SuppServicesPreferencesSource");
  uint64_t v4 = *(NSObject **)(a1 + 24);
  uint64_t v6 = v4;
  if (v4) {
    dispatch_retain(v4);
  }
  ctu::RestModule::RestModule();
  if (v6) {
    dispatch_release(v6);
  }
  if (v8 < 0) {
    operator delete(__p);
  }
  *(_DWORD *)(a1 + 128) = 0;
  return a1;
}

void sub_100501034(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, dispatch_object_t object, dispatch_object_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (object) {
    dispatch_release(object);
  }
  if (a10) {
    dispatch_release(a10);
  }
  if (a16 < 0) {
    operator delete(__p);
  }
  CFIndex v18 = (std::__shared_weak_count *)*((void *)v16 + 13);
  if (v18) {
    sub_10004D2C8(v18);
  }
  sub_1011DDB58(v16);
  _Unwind_Resume(a1);
}

void sub_100501098(uint64_t a1)
{
  char v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Bootstrap", buf, 2u);
  }
  sub_100058DB0(&__p, "/cc/prefs-nb/user_default_voice_slot");
  int v3 = operator new(0x28uLL);
  *int v3 = off_1019DC4F8;
  v3[1] = a1 + 128;
  v3[2] = a1;
  v3[3] = sub_100501214;
  v3[4] = 0;
  int v9 = v3;
  ctu::RestModule::observeProperty();
  sub_10003F600(buf);
  if (v7 < 0) {
    operator delete(__p);
  }
  Registry::createRestModuleOneTimeUseConnection(&v4, *(Registry **)(a1 + 48));
  ctu::RestModule::connect();
  if (v5) {
    sub_10004D2C8(v5);
  }
}

void sub_1005011CC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, char a18)
{
  if (a11) {
    sub_10004D2C8(a11);
  }
  _Unwind_Resume(exception_object);
}

void sub_100501214(uint64_t a1, int *a2)
{
  int v3 = *(_DWORD *)(a1 + 128);
  int v4 = *a2;
  uint64_t v5 = *(NSObject **)(a1 + 40);
  BOOL v6 = os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT);
  if (v4 == v3)
  {
    if (v6)
    {
      LOWORD(v9) = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I No change in User Default Voice Slot", (uint8_t *)&v9, 2u);
    }
  }
  else
  {
    if (v6)
    {
      int v9 = 136315138;
      uint64_t v10 = subscriber::asString();
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I User Default Voice Slot updated to slot %s", (uint8_t *)&v9, 0xCu);
    }
    unsigned int v7 = subscriber::simSlotAsInstance();
    uint64_t v8 = kUserDefaultVoiceSlotKey;
    if (sub_1011DDE2C((void *)(a1 + 64), kUserDefaultVoiceSlotKey, v7)) {
      sub_1005013A0(*(void *)(a1 + 96), v8);
    }
  }
}

uint64_t sub_100501334(uint64_t a1)
{
  char v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)int v4 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Stop", v4, 2u);
  }
  return ctu::RestModule::disconnect((ctu::RestModule *)(a1 + 112));
}

void sub_1005013A0(uint64_t a1, uint64_t a2)
{
  if (a1)
  {
    uint64_t v4 = kCommCenterSharedSettingsBundleId;
    uint64_t v5 = operator new(8uLL);
    OsLogContext __p = v5;
    void *v5 = a2;
    unsigned int v7 = v5 + 1;
    uint64_t v8 = v5 + 1;
    (*(void (**)(uint64_t, uint64_t, void **))(*(void *)a1 + 16))(a1, v4, &__p);
    if (__p)
    {
      unsigned int v7 = __p;
      operator delete(__p);
    }
  }
}

void sub_100501438(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100501454(uint64_t a1, int a2, unsigned __int8 **a3)
{
  uint64_t v5 = sub_1011DDDB8(a1, a2, a3);
  if (v5)
  {
    if ((a2 - 1) > 1) {
      uint64_t v6 = 0;
    }
    else {
      uint64_t v6 = kSuppServicesCLIRStatusKeys[subscriber::simSlotAsInstance()];
    }
    sub_1005013A0(*(void *)(a1 + 96), v6);
  }
  return v5;
}

uint64_t sub_1005014C0(uint64_t a1, int a2, unsigned __int8 **a3)
{
  uint64_t v5 = sub_1011DE280(a1, a2, a3);
  if (v5)
  {
    if ((a2 - 1) > 1) {
      uint64_t v6 = 0;
    }
    else {
      uint64_t v6 = kSuppServicesCLIRNetworkStatusKeys[subscriber::simSlotAsInstance()];
    }
    sub_1005013A0(*(void *)(a1 + 96), v6);
  }
  return v5;
}

uint64_t sub_10050152C(uint64_t a1, int a2, int a3)
{
  uint64_t v5 = sub_1011DE844(a1, a2, a3);
  if (v5)
  {
    if ((a2 - 1) > 1) {
      uint64_t v6 = 0;
    }
    else {
      uint64_t v6 = kSuppServicesCallWaitingStatusKeys[subscriber::simSlotAsInstance()];
    }
    sub_1005013A0(*(void *)(a1 + 96), v6);
  }
  return v5;
}

uint64_t sub_100501598(uint64_t a1, int a2, int a3)
{
  uint64_t v5 = sub_1011DEA88(a1, a2, a3);
  if (v5)
  {
    if ((a2 - 1) > 1) {
      uint64_t v6 = 0;
    }
    else {
      uint64_t v6 = kSuppServicesAutoAnswerStatusKeys[subscriber::simSlotAsInstance()];
    }
    sub_1005013A0(*(void *)(a1 + 96), v6);
  }
  return v5;
}

void sub_100501604(uint64_t a1)
{
  if (*(void *)(a1 + 96))
  {
    char v2 = operator new(0x20uLL);
    int v3 = 0;
    uint64_t v4 = 0;
    _OWORD *v2 = *(_OWORD *)&off_1019DC398;
    v2[1] = *(_OWORD *)&off_1019DC3A8;
    OsLogContext __p = 0;
    uint64_t v30 = 0;
    uint64_t v31 = 0;
    do
    {
      char v5 = 0;
      uint64_t v6 = 0;
      uint64_t v7 = *((void *)v2 + v4);
      do
      {
        char v8 = v5;
        uint64_t v9 = *(void *)(v7 + 8 * v6);
        if (v3 >= v31)
        {
          uint64_t v10 = (v3 - (unsigned char *)__p) >> 3;
          if ((unint64_t)(v10 + 1) >> 61) {
            sub_10006A748();
          }
          unint64_t v11 = (v31 - (unsigned char *)__p) >> 2;
          if (v11 <= v10 + 1) {
            unint64_t v11 = v10 + 1;
          }
          if ((unint64_t)(v31 - (unsigned char *)__p) >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v12 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v12 = v11;
          }
          if (v12) {
            long long v13 = (char *)sub_10004EF74((uint64_t)&v31, v12);
          }
          else {
            long long v13 = 0;
          }
          xpc_object_t v14 = &v13[8 * v10];
          *(void *)xpc_object_t v14 = v9;
          int v3 = v14 + 8;
          uint64_t v16 = (char *)__p;
          long long v15 = v30;
          if (v30 != __p)
          {
            do
            {
              uint64_t v17 = *((void *)v15 - 1);
              v15 -= 8;
              *((void *)v14 - 1) = v17;
              v14 -= 8;
            }
            while (v15 != v16);
            long long v15 = (char *)__p;
          }
          OsLogContext __p = v14;
          uint64_t v30 = v3;
          uint64_t v31 = &v13[8 * v12];
          if (v15) {
            operator delete(v15);
          }
        }
        else
        {
          *(void *)int v3 = v9;
          v3 += 8;
        }
        uint64_t v30 = v3;
        char v5 = 1;
        uint64_t v6 = 1;
      }
      while ((v8 & 1) == 0);
      ++v4;
    }
    while (v4 != 4);
    if (v3 >= v31)
    {
      uint64_t v19 = (v3 - (unsigned char *)__p) >> 3;
      if ((unint64_t)(v19 + 1) >> 61) {
        sub_10006A748();
      }
      unint64_t v20 = (v31 - (unsigned char *)__p) >> 2;
      if (v20 <= v19 + 1) {
        unint64_t v20 = v19 + 1;
      }
      if ((unint64_t)(v31 - (unsigned char *)__p) >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v21 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v21 = v20;
      }
      if (v21) {
        xpc_object_t v22 = (char *)sub_10004EF74((uint64_t)&v31, v21);
      }
      else {
        xpc_object_t v22 = 0;
      }
      BOOL v23 = &v22[8 * v19];
      int v24 = &v22[8 * v21];
      *(void *)BOOL v23 = kUserDefaultVoiceSlotKey;
      CFIndex v18 = v23 + 8;
      __int16 v26 = (char *)__p;
      int v25 = v30;
      if (v30 != __p)
      {
        do
        {
          uint64_t v27 = *((void *)v25 - 1);
          v25 -= 8;
          *((void *)v23 - 1) = v27;
          v23 -= 8;
        }
        while (v25 != v26);
        int v25 = (char *)__p;
      }
      OsLogContext __p = v23;
      uint64_t v30 = v18;
      uint64_t v31 = v24;
      if (v25) {
        operator delete(v25);
      }
    }
    else
    {
      *(void *)int v3 = kUserDefaultVoiceSlotKey;
      CFIndex v18 = v3 + 8;
    }
    uint64_t v30 = v18;
    int64_t v28 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 134217984;
      uint64_t v33 = (v18 - (unsigned char *)__p) >> 3;
      _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "#I Requesting to sync %zu keys", buf, 0xCu);
    }
    (*(void (**)(void, void, void **))(**(void **)(a1 + 96) + 16))(*(void *)(a1 + 96), kCommCenterSharedSettingsBundleId, &__p);
    if (__p)
    {
      uint64_t v30 = (char *)__p;
      operator delete(__p);
    }
    operator delete(v2);
  }
}

void sub_100501900(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  operator delete(v11);
  _Unwind_Resume(a1);
}

SuppServicesPreferencesInterface *sub_10050192C(SuppServicesPreferencesInterface *this)
{
  *(void *)this = off_1019DC2F8;
  char v2 = (std::__shared_weak_count *)*((void *)this + 15);
  if (v2) {
    sub_10004D2C8(v2);
  }
  int v3 = (std::__shared_weak_count *)*((void *)this + 13);
  if (v3) {
    sub_10004D2C8(v3);
  }

  return sub_1011DDB58(this);
}

void sub_100501994(SuppServicesPreferencesInterface *this)
{
  *(void *)this = off_1019DC2F8;
  char v2 = (std::__shared_weak_count *)*((void *)this + 15);
  if (v2) {
    sub_10004D2C8(v2);
  }
  int v3 = (std::__shared_weak_count *)*((void *)this + 13);
  if (v3) {
    sub_10004D2C8(v3);
  }
  sub_1011DDB58(this);

  operator delete();
}

void sub_100501A10(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1019DC3E0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100501A30(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1019DC3E0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100501A84(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

SuppServicesPreferencesInterface *sub_100501AAC(SuppServicesPreferencesInterface *this)
{
  *(void *)this = off_1019DC2F8;
  char v2 = (std::__shared_weak_count *)*((void *)this + 15);
  if (v2) {
    sub_10004D2C8(v2);
  }
  int v3 = (std::__shared_weak_count *)*((void *)this + 13);
  if (v3) {
    sub_10004D2C8(v3);
  }

  return sub_1011DDB58(this);
}

void sub_100501B14(SuppServicesPreferencesInterface *this)
{
  *(void *)this = off_1019DC2F8;
  char v2 = (std::__shared_weak_count *)*((void *)this + 15);
  if (v2) {
    sub_10004D2C8(v2);
  }
  int v3 = (std::__shared_weak_count *)*((void *)this + 13);
  if (v3) {
    sub_10004D2C8(v3);
  }
  sub_1011DDB58(this);

  operator delete();
}

void sub_100501B94()
{
}

__n128 sub_100501BA8(uint64_t a1)
{
  char v2 = (char *)operator new(0x28uLL);
  *(void *)char v2 = off_1019DC4F8;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100501BFC(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019DC4F8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100501C34(void *a1, xpc_object_t *a2)
{
  uint64_t v4 = (int *)a1[1];
  int v13 = *v4;
  xpc_type_t type = xpc_get_type(*a2);
  if (type == (xpc_type_t)&_xpc_type_string)
  {
    int v14 = *v4;
    ctu::rest::detail::read_enum_string_value((ctu::rest::detail *)&v14, (int *)a2, v6);
    int *v4 = v14;
  }
  else if (type == (xpc_type_t)&_xpc_type_BOOL {
         || type == (xpc_type_t)&_xpc_type_int64
  }
         || type == (xpc_type_t)&_xpc_type_uint64)
  {
    int *v4 = xpc::dyn_cast_or_default((xpc *)a2, 0, (uint64_t)v6);
  }
  uint64_t v9 = (uint64_t (*)(void *, int *))a1[3];
  uint64_t v10 = a1[4];
  unint64_t v11 = (void *)(a1[2] + (v10 >> 1));
  if (v10) {
    uint64_t v9 = *(uint64_t (**)(void *, int *))(*v11 + v9);
  }
  return v9(v11, &v13);
}

uint64_t sub_100501D30(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100501D70()
{
}

uint64_t sub_100501D7C(uint64_t a1)
{
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v3, kCtLoggingSystemName, "call.state");
  sub_100501E00((void *)a1, "call::model::CallState", QOS_CLASS_USER_INITIATED, &v3);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v3);
  *(_DWORD *)(a1 + 40) = 0;
  *(unsigned char *)(a1 + 44) = 0;
  return a1;
}

void sub_100501DEC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void *sub_100501E00(void *a1, const char *a2, dispatch_qos_class_t a3, const OsLogContext *a4)
{
  dispatch_object_t object = 0;
  sub_100104718(a1, a2, a3, &object);
  if (object) {
    dispatch_release(object);
  }
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)&v7, a4);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 4), (const ctu::OsLogLogger *)&v7);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)&v7);
  return a1;
}

void sub_100501E68(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object)
{
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)&a9);
  sub_100087E88(v10);
  _Unwind_Resume(a1);
}

void sub_100501EA0(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 8);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

BOOL sub_100501F90(uint64_t a1)
{
  uint64_t v4 = a1;
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  v5[2] = sub_10050255C;
  v5[3] = &unk_1019DC588;
  uint64_t v5[4] = a1;
  v5[5] = &v4;
  uint64_t v6 = v5;
  uint64_t v2 = a1 + 16;
  uint64_t v1 = *(NSObject **)(a1 + 16);
  if (*(void *)(v2 + 8))
  {
    char v13 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v8 = 0x40000000;
    uint64_t v9 = sub_10005AD20;
    uint64_t v10 = &unk_1019DC5C8;
    unint64_t v11 = &v13;
    unint64_t v12 = &v6;
    dispatch_async_and_wait(v1, &block);
  }
  else
  {
    char v13 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v8 = 0x40000000;
    uint64_t v9 = sub_100059FBC;
    uint64_t v10 = &unk_1019DC5A8;
    unint64_t v11 = &v13;
    unint64_t v12 = &v6;
    dispatch_sync(v1, &block);
  }
  return v13 != 0;
}

BOOL sub_1005020BC(uint64_t a1)
{
  uint64_t v4 = a1;
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  v5[2] = sub_100502574;
  v5[3] = &unk_1019DC5E8;
  uint64_t v5[4] = a1;
  v5[5] = &v4;
  uint64_t v6 = v5;
  uint64_t v2 = a1 + 16;
  uint64_t v1 = *(NSObject **)(a1 + 16);
  if (*(void *)(v2 + 8))
  {
    char v13 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v8 = 0x40000000;
    uint64_t v9 = sub_10005AD20;
    uint64_t v10 = &unk_1019DC5C8;
    unint64_t v11 = &v13;
    unint64_t v12 = &v6;
    dispatch_async_and_wait(v1, &block);
  }
  else
  {
    char v13 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v8 = 0x40000000;
    uint64_t v9 = sub_100059FBC;
    uint64_t v10 = &unk_1019DC5A8;
    unint64_t v11 = &v13;
    unint64_t v12 = &v6;
    dispatch_sync(v1, &block);
  }
  return v13 != 0;
}

void sub_1005021E8(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 8);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_1005022D8(uint64_t **a1)
{
  uint64_t v10 = a1;
  uint64_t v1 = **a1;
  int v2 = *((_DWORD *)*a1 + 2);
  long long v13 = 0uLL;
  uint64_t v14 = 0;
  long long __p = 0uLL;
  uint64_t v12 = 0;
  int v3 = *(_DWORD *)(v1 + 40);
  if (v3 == 1)
  {
    uint64_t v4 = (char *)&v13 + 12;
    HIBYTE(v14) = 12;
    qmemcpy(&v13, "kStateActive", 12);
  }
  else
  {
    if (v3)
    {
      __TUAssertTrigger();
LABEL_7:
      if (v2 == 1)
      {
        char v5 = (char *)&__p + 12;
        HIBYTE(v12) = 12;
        qmemcpy(&__p, "kStateActive", 12);
      }
      else
      {
        if (v2)
        {
          __TUAssertTrigger();
LABEL_13:
          uint64_t v6 = *(NSObject **)(v1 + 32);
          if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)long long buf = 136315394;
            uint64_t v16 = &v13;
            __int16 v17 = 2080;
            p_p = &__p;
            _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Changing from %s to %s", buf, 0x16u);
          }
          *(_DWORD *)(v1 + 40) = v2;
          if (v2)
          {
            if (v2 != 1) {
              goto LABEL_20;
            }
            uint64_t v7 = (uint64_t *)&event::call::active;
          }
          else
          {
            uint64_t v7 = (uint64_t *)&event::call::inactive;
          }
          uint64_t v8 = v7 + 1;
          sub_100477910(v7 + 3);
          uint64_t v9 = (uint64_t *)sub_100161CDC(v8);
          sub_10035414C(v9);
LABEL_20:
          if (SHIBYTE(v12) < 0) {
            operator delete((void *)__p);
          }
          if (SHIBYTE(v14) < 0) {
            operator delete((void *)v13);
          }
          operator delete();
        }
        char v5 = (char *)&__p + 14;
        HIBYTE(v12) = 14;
        qmemcpy(&__p, "kStateInactive", 14);
      }
      unsigned char *v5 = 0;
      goto LABEL_13;
    }
    uint64_t v4 = (char *)&v13 + 14;
    HIBYTE(v14) = 14;
    qmemcpy(&v13, "kStateInactive", 14);
  }
  unsigned char *v4 = 0;
  goto LABEL_7;
}

void sub_100502510(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  if (a22 < 0) {
    operator delete(a17);
  }
  operator delete();
}

BOOL sub_10050255C(uint64_t a1)
{
  return *(_DWORD *)(**(void **)(a1 + 40) + 40) == 1;
}

uint64_t sub_100502574(uint64_t a1)
{
  return *(unsigned __int8 *)(**(void **)(a1 + 40) + 44);
}

void sub_100502584(uint64_t a1)
{
  uint64_t v1 = a1;
  *(unsigned char *)(**(void **)a1 + 44) = *(unsigned char *)(*(void *)a1 + 8);
  operator delete();
}

BOOL sub_1005025D0(void *a1, void *a2)
{
  return *a1 == *a2 && a1[1] == a2[1] && *(void *)((char *)a1 + 14) == *(void *)((char *)a2 + 14);
}

uint64_t sub_1005025F4(uint64_t a1, int a2, void *a3, uint64_t *a4, void *a5)
{
  v31[0] = off_1019AF850;
  v31[1] = sub_100502B74;
  v31[3] = v31;
  *(void *)(a1 + 208) = 0;
  if ((capabilities::ct::supportsGemini((capabilities::ct *)a1) & 1) == 0) {
    operator new();
  }
  if (!*(void *)(a1 + 208)) {
    operator new();
  }
  sub_10008863C(v31);
  uint64_t v10 = (std::__shared_weak_count *)a3[1];
  v26[0] = *a3;
  v26[1] = v10;
  if (v10) {
    atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  unint64_t v11 = (std::__shared_weak_count *)a4[1];
  v25[0] = *a4;
  v25[1] = v11;
  if (v11) {
    atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v12 = (std::__shared_weak_count *)a5[1];
  v24[0] = *a5;
  v24[1] = v12;
  if (v12) {
    atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  sub_1005724C8(a1, a2, v26, v25, v24);
  if (v12) {
    sub_10004D2C8(v12);
  }
  if (v11) {
    sub_10004D2C8(v11);
  }
  if (v10) {
    sub_10004D2C8(v10);
  }
  *(void *)a1 = off_1019DC628;
  *(void *)(a1 + 8) = off_1019DC790;
  sub_100058DB0(&__p, "MO MMS");
  uint64_t v27 = 0;
  os_log_t log = 0;
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v27, kCtLoggingSystemName, "mms.send");
  os_log_t v13 = log;
  uint64_t v14 = os_signpost_id_generate(log);
  if ((unint64_t)(v14 - 1) <= 0xFFFFFFFFFFFFFFFDLL)
  {
    long long v15 = log;
    if (os_signpost_enabled(log))
    {
      *(_WORD *)long long buf = 0;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v15, OS_SIGNPOST_INTERVAL_BEGIN, v14, "MobileOriginatedMMS", (const char *)&unk_1017DEDA7, buf, 2u);
    }
  }
  *(void *)long long buf = off_1019DC810;
  uint64_t v33 = buf;
  v29[0] = v14;
  v29[1] = (uint64_t)os_retain(v13);
  sub_1000336E8((uint64_t)&v30, (uint64_t)buf);
  sub_100033A10(buf);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v27);
  Registry::createXpcJetsamAssertion();
  sub_1000339DC(v29);
  if (v23 < 0) {
    operator delete(__p);
  }
  *(void *)(a1 + 240) = 0;
  *(void *)(a1 + 248) = 0;
  *(void *)(a1 + 256) = 0;
  uint64_t v16 = *(std::__shared_weak_count **)(a1 + 184);
  *(void *)(a1 + 176) = 0;
  *(void *)(a1 + 184) = 0;
  if (v16) {
    sub_10004D2C8(v16);
  }
  sub_10022E124(*a4, 128);
  uint64_t v17 = *a5;
  if (*a5)
  {
    CFIndex v18 = (std::__shared_weak_count *)a4[1];
    uint64_t v20 = *a4;
    unint64_t v21 = v18;
    if (v18) {
      atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    (*(void (**)(uint64_t, uint64_t *, void))(*(void *)v17 + 24))(v17, &v20, 0);
    if (v21) {
      sub_10004D2C8(v21);
    }
  }
  *(_DWORD *)(a1 + 44) = 1;
  *(void *)(a1 + 64) = 1;
  *(void *)(a1 + 216) = 0;
  return a1;
}

void sub_100502A10(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,char a24,uint64_t a25,char a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,char a32)
{
  sub_10008863C((void *)(v32 - 128));
  operator delete();
}

const char *sub_100502B74(int a1)
{
  uint64_t v1 = "msg.mms.op.send.?";
  if (a1 == 2) {
    uint64_t v1 = "msg.mms.op.send.2";
  }
  if (a1 == 1) {
    return "msg.mms.op.send.1";
  }
  else {
    return v1;
  }
}

uint64_t sub_100502BA0(uint64_t a1)
{
  *(void *)a1 = off_1019DC628;
  *(void *)(a1 + 8) = off_1019DC790;
  if (*(char *)(a1 + 263) < 0) {
    operator delete(*(void **)(a1 + 240));
  }
  int v2 = *(std::__shared_weak_count **)(a1 + 232);
  if (v2) {
    sub_10004D2C8(v2);
  }
  sub_100572700(a1);
  uint64_t v3 = *(void *)(a1 + 208);
  *(void *)(a1 + 208) = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  return a1;
}

uint64_t sub_100502C58(uint64_t a1)
{
  return sub_100502BA0(a1 - 8);
}

void sub_100502C60(uint64_t a1)
{
  sub_100502BA0(a1);

  operator delete();
}

void sub_100502C98(uint64_t a1)
{
  sub_100502BA0(a1 - 8);

  operator delete();
}

uint64_t sub_100502CD4(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 144);
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 152);
  uint64_t v4 = v2;
  if (v3)
  {
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
    uint64_t v4 = *(void *)(a1 + 144);
  }
  if (v4) {
    BOOL v5 = v2 == 0;
  }
  else {
    BOOL v5 = 1;
  }
  if (!v5)
  {
    uint64_t v6 = sub_10022C514(v2);
    if (!v3) {
      return v6;
    }
    goto LABEL_9;
  }
  uint64_t v6 = 0;
  if (v3) {
LABEL_9:
  }
    sub_10004D2C8(v3);
  return v6;
}

void sub_100502D44(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100502D5C(uint64_t a1, uint64_t a2)
{
  unsigned int v2 = *(_DWORD *)(a1 + 216);
  if (v2)
  {
    signed int v5 = 100 * (int)a2 / v2;
    BOOL v6 = v5 == 100 || v5 < 10;
    if (v6 || v5 - *(_DWORD *)(a1 + 220) >= 10)
    {
      uint64_t v7 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 208) + 16))(*(void *)(a1 + 208), *(unsigned int *)(a1 + 48));
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
      {
        int v8 = *(_DWORD *)(a1 + 216);
        int v9 = *(_DWORD *)(a1 + 36);
        uint64_t v20 = (const char *)__PAIR64__(a2, 67109888);
        __int16 v21 = 1024;
        int v22 = v8;
        __int16 v23 = 1024;
        signed int v24 = v5;
        __int16 v25 = 1024;
        int v26 = v9;
        _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Sent %d of %d (%d%%): MsgId %u", (uint8_t *)&v20, 0x1Au);
      }
      ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 112));
      unint64_t v11 = ServiceMap;
      uint64_t v12 = "27MessageCenterModelInterface";
      if (((unint64_t)"27MessageCenterModelInterface" & 0x8000000000000000) != 0)
      {
        os_log_t v13 = (unsigned __int8 *)((unint64_t)"27MessageCenterModelInterface" & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v14 = 5381;
        do
        {
          uint64_t v12 = (const char *)v14;
          unsigned int v15 = *v13++;
          uint64_t v14 = (33 * v14) ^ v15;
        }
        while (v15);
      }
      std::mutex::lock(ServiceMap);
      uint64_t v20 = v12;
      uint64_t v16 = sub_10004D37C(&v11[1].__m_.__sig, (unint64_t *)&v20);
      if (v16)
      {
        uint64_t v18 = v16[3];
        uint64_t v17 = (std::__shared_weak_count *)v16[4];
        if (v17)
        {
          atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v11);
          atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v17);
          char v19 = 0;
          if (!v18) {
            goto LABEL_19;
          }
          goto LABEL_18;
        }
      }
      else
      {
        uint64_t v18 = 0;
      }
      std::mutex::unlock(v11);
      uint64_t v17 = 0;
      char v19 = 1;
      if (!v18)
      {
LABEL_19:
        if ((v19 & 1) == 0) {
          sub_10004D2C8(v17);
        }
        *(_DWORD *)(a1 + 220) = v5;
        return;
      }
LABEL_18:
      (*(void (**)(uint64_t, void, void, uint64_t, void))(*(void *)v18 + 232))(v18, *(unsigned int *)(a1 + 48), *(unsigned int *)(a1 + 36), a2, *(unsigned int *)(a1 + 216));
      goto LABEL_19;
    }
  }
}

void sub_100502F78(_Unwind_Exception *exception_object)
{
  if ((v1 & 1) == 0) {
    sub_10004D2C8(v2);
  }
  _Unwind_Resume(exception_object);
}

void sub_100502FA8(uint64_t a1, uint64_t a2)
{
}

void sub_100502FB0(uint64_t a1, unsigned int a2, unsigned int a3)
{
  uint64_t v6 = *(unsigned int *)(a1 + 48);
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 112));
  int v8 = ServiceMap;
  if (v9 < 0)
  {
    uint64_t v10 = (unsigned __int8 *)(v9 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v11 = 5381;
    do
    {
      uint64_t v9 = v11;
      unsigned int v12 = *v10++;
      uint64_t v11 = (33 * v11) ^ v12;
    }
    while (v12);
  }
  std::mutex::lock(ServiceMap);
  *(void *)long long buf = v9;
  os_log_t v13 = sub_10004D37C(&v8[1].__m_.__sig, (unint64_t *)buf);
  if (v13)
  {
    uint64_t v15 = v13[3];
    uint64_t v14 = (std::__shared_weak_count *)v13[4];
    if (v14)
    {
      atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v8);
      atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v14);
      char v16 = 0;
      if (!v15) {
        goto LABEL_7;
      }
      goto LABEL_11;
    }
  }
  else
  {
    uint64_t v15 = 0;
  }
  std::mutex::unlock(v8);
  uint64_t v14 = 0;
  char v16 = 1;
  if (!v15)
  {
LABEL_7:
    uint64_t v17 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 208) + 16))(*(void *)(a1 + 208), v6);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "Failed to get analytics interface for MMS Send End.", buf, 2u);
    }
    goto LABEL_35;
  }
LABEL_11:
  xpc_object_t v36 = 0;
  xpc_object_t v18 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v19 = v18;
  if (v18)
  {
    xpc_object_t v36 = v18;
  }
  else
  {
    xpc_object_t v19 = xpc_null_create();
    xpc_object_t v36 = v19;
    if (!v19)
    {
      xpc_object_t v20 = xpc_null_create();
      xpc_object_t v19 = 0;
      goto LABEL_18;
    }
  }
  if (xpc_get_type(v19) != (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_object_t v20 = xpc_null_create();
LABEL_18:
    xpc_object_t v36 = v20;
    goto LABEL_19;
  }
  xpc_retain(v19);
LABEL_19:
  xpc_release(v19);
  unsigned int v21 = subscriber::simSlotAsInstance();
  xpc_object_t object = xpc_int64_create(v21);
  if (!object) {
    xpc_object_t object = xpc_null_create();
  }
  *(void *)long long buf = &v36;
  uint64_t v33 = "subs_id";
  sub_100035E70((uint64_t)buf, &object, &v35);
  xpc_release(v35);
  xpc_object_t v35 = 0;
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_object_t v30 = xpc_int64_create(a3);
  if (!v30) {
    xpc_object_t v30 = xpc_null_create();
  }
  *(void *)long long buf = &v36;
  uint64_t v33 = "dwErrCode";
  sub_100035E70((uint64_t)buf, &v30, &v31);
  xpc_release(v31);
  xpc_object_t v31 = 0;
  xpc_release(v30);
  xpc_object_t v30 = 0;
  xpc_object_t v28 = xpc_int64_create(*(unsigned int *)(a1 + 104));
  if (!v28) {
    xpc_object_t v28 = xpc_null_create();
  }
  *(void *)long long buf = &v36;
  uint64_t v33 = "rat";
  sub_100035E70((uint64_t)buf, &v28, &v29);
  xpc_release(v29);
  xpc_object_t v29 = 0;
  xpc_release(v28);
  xpc_object_t v28 = 0;
  int v22 = (const char *)(a1 + 240);
  if (*(char *)(a1 + 263) < 0) {
    int v22 = *(const char **)v22;
  }
  xpc_object_t v26 = xpc_string_create(v22);
  if (!v26) {
    xpc_object_t v26 = xpc_null_create();
  }
  *(void *)long long buf = &v36;
  uint64_t v33 = "wMmsVersion";
  sub_100035E70((uint64_t)buf, &v26, &v27);
  xpc_release(v27);
  xpc_object_t v27 = 0;
  xpc_release(v26);
  xpc_object_t v26 = 0;
  xpc_object_t v24 = xpc_int64_create(a2);
  if (!v24) {
    xpc_object_t v24 = xpc_null_create();
  }
  *(void *)long long buf = &v36;
  uint64_t v33 = "wResultCode";
  sub_100035E70((uint64_t)buf, &v24, &v25);
  xpc_release(v25);
  xpc_object_t v25 = 0;
  xpc_release(v24);
  xpc_object_t v23 = v36;
  xpc_object_t v24 = 0;
  if (v36) {
    xpc_retain(v36);
  }
  else {
    xpc_object_t v23 = xpc_null_create();
  }
  (*(void (**)(uint64_t, const char *, xpc_object_t *))(*(void *)v15 + 16))(v15, "metricCCMMSSendEnd", &v23);
  xpc_release(v23);
  xpc_object_t v23 = 0;
  xpc_release(v36);
LABEL_35:
  if ((v16 & 1) == 0) {
    sub_10004D2C8(v14);
  }
}

void sub_1005033A8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object)
{
  if ((v11 & 1) == 0) {
    sub_10004D2C8(v10);
  }
  _Unwind_Resume(exception_object);
}

void sub_100503444(uint64_t a1)
{
  *(_DWORD *)(a1 + 220) = 0;
  uint64_t v3 = *(void *)(a1 + 144);
  unsigned int v2 = *(std::__shared_weak_count **)(a1 + 152);
  if (v2) {
    atomic_fetch_add_explicit(&v2->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v4 = *(unsigned int *)(a1 + 48);
  signed int v5 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 208) + 16))(*(void *)(a1 + 208), v4);
  uint64_t v6 = *v5;
  if (os_log_type_enabled(*v5, OS_LOG_TYPE_DEFAULT))
  {
    int v7 = *(_DWORD *)(a1 + 36);
    *(_DWORD *)long long buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v7;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Begin MMSSendOperation::run: MsgId %u", buf, 8u);
  }
  uint64_t v8 = sub_100CCA3B0(v3, "X-Mms-MMS-Version");
  uint64_t v9 = (void **)(a1 + 240);
  if (v8 && (*(unsigned int (**)(uint64_t, uint64_t))(*(void *)v8 + 72))(v8, a1 + 240))
  {
    if (*(char *)(a1 + 263) < 0)
    {
      sub_10004FC84(buf, *(void **)(a1 + 240), *(void *)(a1 + 248));
    }
    else
    {
      *(_OWORD *)long long buf = *(_OWORD *)v9;
      *(void *)&long long v84 = *(void *)(a1 + 256);
    }
  }
  else
  {
    sub_100058DB0(buf, "");
  }
  if (*(char *)(a1 + 263) < 0) {
    operator delete(*v9);
  }
  *(_OWORD *)uint64_t v9 = *(_OWORD *)buf;
  *(void *)(a1 + 256) = v84;
  uint64_t v10 = *(void *)(v3 + 72);
  unint64_t v11 = *(void *)(v3 + 80) - v10;
  if ((v11 & 0x7FFFFFFF8) != 0)
  {
    uint64_t v12 = *(void *)(v10 + 8 * ((v11 >> 3) - 1));
    if (v12)
    {
      uint64_t v13 = sub_100CCA3B0(v12, "Content-Type");
      if (v13)
      {
        uint64_t v14 = *(void *)(v13 + 24);
        if (v14)
        {
          memset(buf, 0, sizeof(buf));
          *(void *)&long long v84 = 0;
          uint64_t v15 = (char *)(*(uint64_t (**)(uint64_t))(*(void *)v14 + 16))(v14);
          sub_100058DB0(buf, v15);
          uint64_t v16 = BYTE7(v84);
          if (SBYTE7(v84) < 0) {
            uint64_t v16 = *(void *)&buf[8];
          }
          if (!v16) {
            goto LABEL_60;
          }
          std::string::append((std::string *)buf, "/", 1uLL);
          uint64_t v17 = (const char *)(*(uint64_t (**)(uint64_t))(*(void *)v14 + 24))(v14);
          size_t v18 = strlen(v17);
          std::string::append((std::string *)buf, v17, v18);
          if ((SBYTE7(v84) & 0x80u) == 0) {
            xpc_object_t v19 = (char *)buf;
          }
          else {
            xpc_object_t v19 = *(char **)buf;
          }
          int v20 = sub_10035EBCC(v19);
          ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 112));
          int v22 = ServiceMap;
          if (v23 < 0)
          {
            xpc_object_t v24 = (unsigned __int8 *)(v23 & 0x7FFFFFFFFFFFFFFFLL);
            uint64_t v25 = 5381;
            do
            {
              uint64_t v23 = v25;
              unsigned int v26 = *v24++;
              uint64_t v25 = (33 * v25) ^ v26;
            }
            while (v26);
          }
          std::mutex::lock(ServiceMap);
          *(void *)long long v86 = v23;
          xpc_object_t v27 = sub_10004D37C(&v22[1].__m_.__sig, (unint64_t *)v86);
          value[0] = v20;
          if (v27)
          {
            uint64_t v29 = v27[3];
            xpc_object_t v28 = (std::__shared_weak_count *)v27[4];
            if (v28)
            {
              atomic_fetch_add_explicit(&v28->__shared_owners_, 1uLL, memory_order_relaxed);
              std::mutex::unlock(v22);
              atomic_fetch_add_explicit(&v28->__shared_owners_, 1uLL, memory_order_relaxed);
              sub_10004D2C8(v28);
              char v30 = 0;
              if (!v29) {
                goto LABEL_28;
              }
              goto LABEL_33;
            }
          }
          else
          {
            uint64_t v29 = 0;
          }
          std::mutex::unlock(v22);
          xpc_object_t v28 = 0;
          char v30 = 1;
          if (!v29)
          {
LABEL_28:
            xpc_object_t v31 = *v5;
            if (os_log_type_enabled(*v5, OS_LOG_TYPE_ERROR))
            {
              *(_WORD *)long long v86 = 0;
              _os_log_error_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_ERROR, "Failed to get analytics interface for MMS Send Start.", v86, 2u);
            }
LABEL_58:
            if ((v30 & 1) == 0) {
              sub_10004D2C8(v28);
            }
LABEL_60:
            if (SBYTE7(v84) < 0) {
              operator delete(*(void **)buf);
            }
            goto LABEL_62;
          }
LABEL_33:
          xpc_object_t v82 = 0;
          xpc_object_t v32 = xpc_dictionary_create(0, 0, 0);
          xpc_object_t v33 = v32;
          if (v32)
          {
            xpc_object_t v82 = v32;
          }
          else
          {
            xpc_object_t v33 = xpc_null_create();
            xpc_object_t v82 = v33;
            if (!v33)
            {
              xpc_object_t v34 = xpc_null_create();
              xpc_object_t v33 = 0;
              goto LABEL_40;
            }
          }
          if (xpc_get_type(v33) == (xpc_type_t)&_xpc_type_dictionary)
          {
            xpc_retain(v33);
LABEL_41:
            xpc_release(v33);
            unsigned int v35 = subscriber::simSlotAsInstance();
            xpc_object_t v80 = xpc_int64_create(v35);
            if (!v80) {
              xpc_object_t v80 = xpc_null_create();
            }
            *(void *)long long v86 = &v82;
            long long v87 = "subs_id";
            sub_100035E70((uint64_t)v86, &v80, &object);
            xpc_release(object);
            xpc_object_t object = 0;
            xpc_release(v80);
            xpc_object_t v80 = 0;
            xpc_object_t v78 = xpc_int64_create(value[0]);
            if (!v78) {
              xpc_object_t v78 = xpc_null_create();
            }
            *(void *)long long v86 = &v82;
            long long v87 = "dwContentType";
            sub_100035E70((uint64_t)v86, &v78, &v79);
            xpc_release(v79);
            xpc_object_t v79 = 0;
            xpc_release(v78);
            xpc_object_t v78 = 0;
            uint64_t v36 = sub_100CCA3B0(v3, "X-Mms-Message-Size");
            if (v36) {
              unsigned int v37 = *(_DWORD *)(v36 + 20);
            }
            else {
              unsigned int v37 = 0;
            }
            xpc_object_t v76 = xpc_int64_create(v37);
            if (!v76) {
              xpc_object_t v76 = xpc_null_create();
            }
            *(void *)long long v86 = &v82;
            long long v87 = "dwSize";
            sub_100035E70((uint64_t)v86, &v76, &v77);
            xpc_release(v77);
            xpc_object_t v77 = 0;
            xpc_release(v76);
            xpc_object_t v76 = 0;
            if (*(char *)(a1 + 263) < 0) {
              uint64_t v9 = (void **)*v9;
            }
            xpc_object_t v74 = xpc_string_create((const char *)v9);
            if (!v74) {
              xpc_object_t v74 = xpc_null_create();
            }
            *(void *)long long v86 = &v82;
            long long v87 = "wMmsVersion";
            sub_100035E70((uint64_t)v86, &v74, &v75);
            xpc_release(v75);
            xpc_object_t v75 = 0;
            xpc_release(v74);
            xpc_object_t v73 = v82;
            xpc_object_t v74 = 0;
            if (v82) {
              xpc_retain(v82);
            }
            else {
              xpc_object_t v73 = xpc_null_create();
            }
            (*(void (**)(uint64_t, const char *, xpc_object_t *))(*(void *)v29 + 16))(v29, "metricCCMMSSendStart", &v73);
            xpc_release(v73);
            xpc_object_t v73 = 0;
            xpc_release(v82);
            goto LABEL_58;
          }
          xpc_object_t v34 = xpc_null_create();
LABEL_40:
          xpc_object_t v82 = v34;
          goto LABEL_41;
        }
      }
    }
  }
LABEL_62:
  *(_DWORD *)&uint8_t buf[4] = 0;
  *(_DWORD *)long long buf = 1;
  uint64_t v85 = 0;
  *(void *)&uint8_t buf[8] = 0;
  long long v84 = 0uLL;
  uint64_t v38 = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 112));
  uint64_t v39 = v38;
  if (v40 < 0)
  {
    unint64_t v41 = (unsigned __int8 *)(v40 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v42 = 5381;
    do
    {
      uint64_t v40 = v42;
      unsigned int v43 = *v41++;
      uint64_t v42 = (33 * v42) ^ v43;
    }
    while (v43);
  }
  std::mutex::lock(v38);
  *(void *)long long v86 = v40;
  __int16 v44 = sub_10004D37C(&v39[1].__m_.__sig, (unint64_t *)v86);
  if (!v44)
  {
    uint64_t v46 = 0;
LABEL_70:
    std::mutex::unlock(v39);
    uint64_t v45 = 0;
    char v47 = 1;
    if (!v46) {
      goto LABEL_72;
    }
    goto LABEL_71;
  }
  uint64_t v46 = v44[3];
  uint64_t v45 = (std::__shared_weak_count *)v44[4];
  if (!v45) {
    goto LABEL_70;
  }
  atomic_fetch_add_explicit(&v45->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v39);
  atomic_fetch_add_explicit(&v45->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v45);
  char v47 = 0;
  if (v46) {
LABEL_71:
  }
    LODWORD(v85) = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v46 + 224))(v46, v4);
LABEL_72:
  if ((v47 & 1) == 0) {
    sub_10004D2C8(v45);
  }
  sub_1005725BC(a1, v4, &v71);
  sub_100572C3C(a1, &v71);
  if (v72) {
    sub_10004D2C8(v72);
  }
  uint64_t v48 = *(void *)(a1 + 176);
  if (!v48)
  {
    uint64_t v58 = *v5;
    if (os_log_type_enabled(v58, OS_LOG_TYPE_ERROR))
    {
      int v63 = *(_DWORD *)(a1 + 36);
      *(_DWORD *)long long v86 = 67109120;
      *(_DWORD *)&v86[4] = v63;
      _os_log_error_impl((void *)&_mh_execute_header, v58, OS_LOG_TYPE_ERROR, "Unable to create connection object, failing MMS Send: MsgId %u", v86, 8u);
    }
    sub_100502FB0(a1, 0xE0u, 0xCu);
    uint64_t v59 = *(void *)(a1 + 128);
    sub_10003E168(&v69, (void *)(a1 + 16));
    (*(void (**)(uint64_t, uint64_t, uint64_t *))(*(void *)v59 + 16))(v59, 1, &v69);
    int v60 = v70;
    if (!v70) {
      goto LABEL_96;
    }
LABEL_95:
    sub_10004D2C8(v60);
    goto LABEL_96;
  }
  (*(void (**)(uint64_t, const char *))(*(void *)v48 + 40))(v48, "application/vnd.wap.mms-message");
  sub_100572E28(a1);
  uint64_t v49 = *(void *)(a1 + 176);
  uint64_t v67 = v3;
  uint64_t v68 = v2;
  if (v2) {
    atomic_fetch_add_explicit(&v2->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  char v50 = (*(uint64_t (**)(uint64_t, uint64_t *, uint8_t *, void))(*(void *)v49 + 32))(v49, &v67, buf, 0);
  if (v68) {
    sub_10004D2C8(v68);
  }
  if ((v50 & 1) == 0)
  {
    long long v51 = *v5;
    if (os_log_type_enabled(*v5, OS_LOG_TYPE_ERROR))
    {
      int v64 = *(_DWORD *)(a1 + 36);
      *(_DWORD *)long long v86 = 67109120;
      *(_DWORD *)&v86[4] = v64;
      _os_log_error_impl((void *)&_mh_execute_header, v51, OS_LOG_TYPE_ERROR, "MMS send: Failed to send message: MsgId %u", v86, 8u);
    }
    long long v52 = *(std::__shared_weak_count **)(a1 + 184);
    *(void *)(a1 + 176) = 0;
    *(void *)(a1 + 184) = 0;
    if (v52) {
      sub_10004D2C8(v52);
    }
    sub_100502FB0(a1, 0xE0u, 0xFu);
  }
  int v53 = HIBYTE(v84);
  if (v84 < 0) {
    int v53 = v84;
  }
  *(_DWORD *)(a1 + 216) = v53;
  uint64_t v54 = *(void *)(a1 + 176);
  long long v55 = *v5;
  BOOL v56 = os_log_type_enabled(v55, OS_LOG_TYPE_DEFAULT);
  if (v54)
  {
    if (v56)
    {
      int v57 = *(_DWORD *)(a1 + 36);
      *(_DWORD *)long long v86 = 67109120;
      *(_DWORD *)&v86[4] = v57;
      _os_log_impl((void *)&_mh_execute_header, v55, OS_LOG_TYPE_DEFAULT, "#I End of MMSSendOperation::run, Message send should be in progress: MsgId %u", v86, 8u);
    }
    goto LABEL_96;
  }
  if (v56)
  {
    int v61 = *(_DWORD *)(a1 + 36);
    *(_DWORD *)long long v86 = 67109120;
    *(_DWORD *)&v86[4] = v61;
    _os_log_impl((void *)&_mh_execute_header, v55, OS_LOG_TYPE_DEFAULT, "#I MMSSend: Connection is null, retry message: MsgId %u", v86, 8u);
  }
  uint64_t v62 = *(void *)(a1 + 128);
  sub_10003E168(&value[1], (void *)(a1 + 16));
  (*(void (**)(uint64_t, uint64_t, _DWORD *))(*(void *)v62 + 16))(v62, 2, &value[1]);
  int v60 = v66;
  if (v66) {
    goto LABEL_95;
  }
LABEL_96:
  if (SHIBYTE(v84) < 0) {
    operator delete(*(void **)&buf[8]);
  }
  if (v2) {
    sub_10004D2C8(v2);
  }
}

void sub_100503E28(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, xpc_object_t object, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,xpc_object_t a28,void *__p,uint64_t a30,int a31,__int16 a32,char a33,char a34,int a35,__int16 a36,char a37,char a38)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_100503F7C(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (os_log_t *)(*(uint64_t (**)(void, void))(**(void **)(a1 + 208) + 16))(*(void *)(a1 + 208), *(unsigned int *)(a1 + 48));
  signed int v5 = *v4;
  if (os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT))
  {
    int v6 = *(_DWORD *)(a1 + 36);
    *(_DWORD *)long long buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v6;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I MMSSendOperation: HTTP Response callback, begin processing response: MsgId %u", buf, 8u);
  }
  int v7 = *(std::__shared_weak_count **)(a2 + 8);
  xpc_object_t v79 = *(int **)a2;
  xpc_object_t v80 = v7;
  if (v7) {
    atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v8 = (os_log_t *)(*(uint64_t (**)(void, void))(**(void **)(a1 + 208) + 16))(*(void *)(a1 + 208), *(unsigned int *)(a1 + 48));
  unsigned __int8 v83 = 1;
  char v81 = 0;
  xpc_object_t v82 = 0;
  sub_100572FB0(a1, (char *)&v83, &v79, &v81);
  uint64_t v9 = *(std::__shared_weak_count **)(a1 + 184);
  *(void *)(a1 + 176) = 0;
  *(void *)(a1 + 184) = 0;
  if (v9) {
    sub_10004D2C8(v9);
  }
  if (!v81)
  {
    if (*((void *)v79 + 1) == -1001 && *(_DWORD *)(a1 + 220) == 100)
    {
      unsigned int v21 = *v8;
      if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
      {
        int v76 = *(_DWORD *)(a1 + 36);
        *(_DWORD *)long long buf = 67109120;
        *(_DWORD *)&uint8_t buf[4] = v76;
        _os_log_error_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "Timeout occurred after sending all of the message data; will not automatically retry, MsgId: %u",
          buf,
          8u);
      }
      sub_100502FB0(a1, 0xE0u, 0xDu);
      uint64_t v22 = *(void *)(a1 + 128);
      sub_10003E168(buf, (void *)(a1 + 16));
      (*(void (**)(uint64_t, uint64_t, uint8_t *))(*(void *)v22 + 16))(v22, 1, buf);
    }
    else
    {
      uint64_t v23 = *v8;
      if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
      {
        int v24 = *(_DWORD *)(a1 + 36);
        *(_DWORD *)long long buf = 67109120;
        *(_DWORD *)&uint8_t buf[4] = v24;
        _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "#I MMSSendOperation Failed to get message from HTTP Response, MsgId: %u", buf, 8u);
      }
      uint64_t v25 = *(void *)(a1 + 128);
      uint64_t v26 = v83;
      sub_10003E168(buf, (void *)(a1 + 16));
      (*(void (**)(uint64_t, uint64_t, uint8_t *))(*(void *)v25 + 16))(v25, v26, buf);
    }
    if (*(void *)&buf[8]) {
      sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
    }
    goto LABEL_75;
  }
  unsigned __int8 v83 = 1;
  uint64_t v10 = sub_100CCA3B0((uint64_t)v81, "X-Mms-Response-Status");
  if (!v10) {
    goto LABEL_70;
  }
  int v11 = *(unsigned __int8 *)(v10 + 17);
  if (v11 == 128)
  {
    uint64_t v12 = *v8;
    if (os_log_type_enabled(*v8, OS_LOG_TYPE_DEFAULT))
    {
      int v13 = *(_DWORD *)(a1 + 36);
      *(_DWORD *)long long buf = 67109120;
      *(_DWORD *)&uint8_t buf[4] = v13;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I MMSSendOperation send succeeded, MsgId: %u", buf, 8u);
      uint64_t v12 = *v8;
    }
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      int v14 = *(_DWORD *)(a1 + 36);
      sub_10022E1C8(v81, 0, 0, buf);
      if (v91 >= 0) {
        uint64_t v15 = buf;
      }
      else {
        uint64_t v15 = *(uint8_t **)buf;
      }
      *(_DWORD *)long long v84 = 67109378;
      *(_DWORD *)&v84[4] = v14;
      *(_WORD *)&v84[8] = 2080;
      *(void *)&v84[10] = v15;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I MsgId %u public response: %s", v84, 0x12u);
      if (SHIBYTE(v91) < 0) {
        operator delete(*(void **)buf);
      }
      uint64_t v12 = *v8;
    }
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      int v16 = *(_DWORD *)(a1 + 36);
      sub_10022E1C8(v81, 1, 0, buf);
      if (v91 >= 0) {
        uint64_t v17 = buf;
      }
      else {
        uint64_t v17 = *(uint8_t **)buf;
      }
      *(_DWORD *)long long v84 = 67109379;
      *(_DWORD *)&v84[4] = v16;
      *(_WORD *)&v84[8] = 2085;
      *(void *)&v84[10] = v17;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I MsgId %u sensitive response: %{sensitive}s", v84, 0x12u);
      if (SHIBYTE(v91) < 0) {
        operator delete(*(void **)buf);
      }
      uint64_t v12 = *v8;
    }
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      int v18 = *(_DWORD *)(a1 + 36);
      sub_10022E4D4((uint64_t)v81, buf);
      xpc_object_t v19 = v91 >= 0 ? buf : *(uint8_t **)buf;
      *(_DWORD *)long long v84 = 67109379;
      *(_DWORD *)&v84[4] = v18;
      *(_WORD *)&v84[8] = 2085;
      *(void *)&v84[10] = v19;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I MsgId %u Body: %{sensitive}s", v84, 0x12u);
      if (SHIBYTE(v91) < 0) {
        operator delete(*(void **)buf);
      }
    }
    uint64_t v20 = 0;
    unsigned __int8 v83 = 0;
    goto LABEL_76;
  }
  if ((v11 & 0xF0) != 0xC0)
  {
    if (v11 == 226 || v11 == 131)
    {
      uint64_t v29 = *(void *)(a1 + 144);
      xpc_object_t v28 = *(std::__shared_weak_count **)(a1 + 152);
      if (v28) {
        atomic_fetch_add_explicit(&v28->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      if (!v29) {
        goto LABEL_68;
      }
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_DWORD *)long long buf = 1;
      uint64_t v92 = 0;
      uint64_t v93 = 0;
      *(void *)&uint8_t buf[8] = 0;
      uint64_t v91 = 0;
      ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 112));
      xpc_object_t v31 = ServiceMap;
      if (v32 < 0)
      {
        xpc_object_t v33 = (unsigned __int8 *)(v32 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v34 = 5381;
        do
        {
          uint64_t v32 = v34;
          unsigned int v35 = *v33++;
          uint64_t v34 = (33 * v34) ^ v35;
        }
        while (v35);
      }
      std::mutex::lock(ServiceMap);
      *(void *)long long v84 = v32;
      uint64_t v36 = sub_10004D37C(&v31[1].__m_.__sig, (unint64_t *)v84);
      if (v36)
      {
        uint64_t v38 = v36[3];
        unsigned int v37 = (std::__shared_weak_count *)v36[4];
        if (v37)
        {
          atomic_fetch_add_explicit(&v37->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v31);
          atomic_fetch_add_explicit(&v37->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v37);
          char v39 = 0;
LABEL_62:
          if (v38) {
            LODWORD(v93) = (*(uint64_t (**)(uint64_t, void))(*(void *)v38 + 224))(v38, *(unsigned int *)(a1 + 48));
          }
          if ((v39 & 1) == 0) {
            sub_10004D2C8(v37);
          }
          sub_10078F678((uint64_t)buf, v29);
          sub_10078F770((uint64_t)buf, "corrupt_message");
          if (SHIBYTE(v92) < 0) {
            operator delete(*(void **)&buf[8]);
          }
LABEL_68:
          if (v28) {
            sub_10004D2C8(v28);
          }
          goto LABEL_70;
        }
      }
      else
      {
        uint64_t v38 = 0;
      }
      std::mutex::unlock(v31);
      unsigned int v37 = 0;
      char v39 = 1;
      goto LABEL_62;
    }
LABEL_70:
    uint64_t v40 = sub_100CCA330((uint64_t)v81, "X-Mms-Response-Status");
    memset(buf, 0, sizeof(buf));
    uint64_t v91 = 0;
    (*(void (**)(uint64_t, uint8_t *))(*(void *)v40 + 72))(v40, buf);
    unint64_t v41 = *v8;
    if (os_log_type_enabled(*v8, OS_LOG_TYPE_ERROR))
    {
      int v65 = *(_DWORD *)(a1 + 36);
      uint64_t v66 = *(uint8_t **)buf;
      if (v91 >= 0) {
        uint64_t v66 = buf;
      }
      *(_DWORD *)long long v84 = 136315394;
      *(void *)&v84[4] = v66;
      *(_WORD *)&v84[12] = 1024;
      *(_DWORD *)&v84[14] = v65;
      _os_log_error_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_ERROR, "MMSSendOperation send failed, response status header: %s, MsgId: %u", v84, 0x12u);
      unint64_t v41 = *v8;
    }
    if (os_log_type_enabled(v41, OS_LOG_TYPE_ERROR))
    {
      int v67 = *(_DWORD *)(a1 + 36);
      sub_10022E1C8(v81, 0, 0, v84);
      if (v85 >= 0) {
        uint64_t v68 = v84;
      }
      else {
        uint64_t v68 = *(unsigned char **)v84;
      }
      *(_DWORD *)long long v86 = 67109378;
      int v87 = v67;
      __int16 v88 = 2080;
      long long v89 = v68;
      _os_log_error_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_ERROR, "MsgId %u public response: %s", v86, 0x12u);
      if (v85 < 0) {
        operator delete(*(void **)v84);
      }
      unint64_t v41 = *v8;
    }
    if (os_log_type_enabled(v41, OS_LOG_TYPE_ERROR))
    {
      int v69 = *(_DWORD *)(a1 + 36);
      sub_10022E1C8(v81, 1, 0, v84);
      long long v70 = v85 >= 0 ? v84 : *(unsigned char **)v84;
      *(_DWORD *)long long v86 = 67109379;
      int v87 = v69;
      __int16 v88 = 2085;
      long long v89 = v70;
      _os_log_error_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_ERROR, "MsgId %u sensitive response: %{sensitive}s", v86, 0x12u);
      if (v85 < 0) {
        operator delete(*(void **)v84);
      }
    }
    unsigned __int8 v83 = 1;
    if (SHIBYTE(v91) < 0) {
      operator delete(*(void **)buf);
    }
LABEL_75:
    uint64_t v20 = v83;
    goto LABEL_76;
  }
  xpc_object_t v27 = *v8;
  if (os_log_type_enabled(*v8, OS_LOG_TYPE_ERROR))
  {
    int v71 = *(_DWORD *)(a1 + 36);
    *(_DWORD *)long long buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v71;
    _os_log_error_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_ERROR, "Transient error sending MMS, will attempt retry if allowed, MsgId: %u", buf, 8u);
    xpc_object_t v27 = *v8;
  }
  if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
  {
    int v72 = *(_DWORD *)(a1 + 36);
    sub_10022E1C8(v81, 0, 0, buf);
    if (v91 >= 0) {
      xpc_object_t v73 = buf;
    }
    else {
      xpc_object_t v73 = *(uint8_t **)buf;
    }
    *(_DWORD *)long long v84 = 67109378;
    *(_DWORD *)&v84[4] = v72;
    *(_WORD *)&v84[8] = 2080;
    *(void *)&v84[10] = v73;
    _os_log_error_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_ERROR, "MsgId %u public response: %s", v84, 0x12u);
    if (SHIBYTE(v91) < 0) {
      operator delete(*(void **)buf);
    }
    xpc_object_t v27 = *v8;
  }
  if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
  {
    int v74 = *(_DWORD *)(a1 + 36);
    sub_10022E1C8(v81, 1, 0, buf);
    xpc_object_t v75 = v91 >= 0 ? buf : *(uint8_t **)buf;
    *(_DWORD *)long long v84 = 67109379;
    *(_DWORD *)&v84[4] = v74;
    *(_WORD *)&v84[8] = 2085;
    *(void *)&v84[10] = v75;
    _os_log_error_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_ERROR, "MsgId %u sensitive response: %{sensitive}s", v84, 0x12u);
    if (SHIBYTE(v91) < 0) {
      operator delete(*(void **)buf);
    }
  }
  uint64_t v20 = 2;
  unsigned __int8 v83 = 2;
LABEL_76:
  if (v82) {
    sub_10004D2C8(v82);
  }
  if (v80) {
    sub_10004D2C8(v80);
  }
  if (v20)
  {
    if (v20 != 1)
    {
      if (v20 != 2) {
        goto LABEL_107;
      }
      if ((*(uint64_t (**)(uint64_t))(*(void *)a1 + 96))(a1))
      {
        uint64_t v20 = 2;
        goto LABEL_107;
      }
      long long v52 = *v4;
      if (os_log_type_enabled(v52, OS_LOG_TYPE_DEFAULT))
      {
        int v54 = *(_DWORD *)(a1 + 36);
        int v53 = *(_DWORD *)(a1 + 40);
        *(_DWORD *)long long buf = 67109376;
        *(_DWORD *)&uint8_t buf[4] = v53;
        *(_WORD *)&uint8_t buf[8] = 1024;
        *(_DWORD *)&buf[10] = v54;
        _os_log_impl((void *)&_mh_execute_header, v52, OS_LOG_TYPE_DEFAULT, "#I Message can no longer be retried due to retry count: %u, Failing send operation: MsgId %u", buf, 0xEu);
      }
      sub_100502FB0(a1, 0xE0u, 3u);
    }
    sub_100502FB0(a1, 0xE0u, 0xFu);
    long long v55 = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 112));
    BOOL v56 = v55;
    int v57 = "27MessageCenterModelInterface";
    if (((unint64_t)"27MessageCenterModelInterface" & 0x8000000000000000) != 0)
    {
      uint64_t v58 = (unsigned __int8 *)((unint64_t)"27MessageCenterModelInterface" & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v59 = 5381;
      do
      {
        int v57 = (const char *)v59;
        unsigned int v60 = *v58++;
        uint64_t v59 = (33 * v59) ^ v60;
      }
      while (v60);
    }
    std::mutex::lock(v55);
    *(void *)long long buf = v57;
    int v61 = sub_10004D37C(&v56[1].__m_.__sig, (unint64_t *)buf);
    if (v61)
    {
      uint64_t v62 = v61[3];
      uint64_t v49 = (std::__shared_weak_count *)v61[4];
      if (v49)
      {
        atomic_fetch_add_explicit(&v49->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v56);
        atomic_fetch_add_explicit(&v49->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v49);
        char v63 = 0;
        if (!v62)
        {
LABEL_105:
          uint64_t v20 = 1;
          if (v63) {
            goto LABEL_107;
          }
          goto LABEL_106;
        }
LABEL_104:
        (*(void (**)(uint64_t, void, uint64_t, void))(*(void *)v62 + 192))(v62, *(unsigned int *)(a1 + 48), 1, *(unsigned int *)(a1 + 36));
        goto LABEL_105;
      }
    }
    else
    {
      uint64_t v62 = 0;
    }
    std::mutex::unlock(v56);
    uint64_t v49 = 0;
    char v63 = 1;
    if (!v62) {
      goto LABEL_105;
    }
    goto LABEL_104;
  }
  sub_100502FB0(a1, 0x80u, 0);
  uint64_t v42 = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 112));
  unsigned int v43 = v42;
  __int16 v44 = "27MessageCenterModelInterface";
  if (((unint64_t)"27MessageCenterModelInterface" & 0x8000000000000000) != 0)
  {
    uint64_t v45 = (unsigned __int8 *)((unint64_t)"27MessageCenterModelInterface" & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v46 = 5381;
    do
    {
      __int16 v44 = (const char *)v46;
      unsigned int v47 = *v45++;
      uint64_t v46 = (33 * v46) ^ v47;
    }
    while (v47);
  }
  std::mutex::lock(v42);
  *(void *)long long buf = v44;
  uint64_t v48 = sub_10004D37C(&v43[1].__m_.__sig, (unint64_t *)buf);
  if (!v48)
  {
    uint64_t v50 = 0;
LABEL_111:
    std::mutex::unlock(v43);
    uint64_t v49 = 0;
    char v51 = 1;
    if (!v50) {
      goto LABEL_113;
    }
    goto LABEL_112;
  }
  uint64_t v50 = v48[3];
  uint64_t v49 = (std::__shared_weak_count *)v48[4];
  if (!v49) {
    goto LABEL_111;
  }
  atomic_fetch_add_explicit(&v49->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v43);
  atomic_fetch_add_explicit(&v49->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v49);
  char v51 = 0;
  if (v50) {
LABEL_112:
  }
    (*(void (**)(uint64_t, void, uint64_t, void))(*(void *)v50 + 240))(v50, *(unsigned int *)(a1 + 48), 1, *(unsigned int *)(a1 + 36));
LABEL_113:
  uint64_t v20 = 0;
  if ((v51 & 1) == 0) {
LABEL_106:
  }
    sub_10004D2C8(v49);
LABEL_107:
  uint64_t v64 = *(void *)(a1 + 128);
  sub_10003E168(&v77, (void *)(a1 + 16));
  (*(void (**)(uint64_t, uint64_t, uint64_t *))(*(void *)v64 + 16))(v64, v20, &v77);
  if (v78) {
    sub_10004D2C8(v78);
  }
}

void sub_100504C54(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, std::__shared_weak_count *a13, uint64_t a14, std::__shared_weak_count *a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,void *a25,void *__p,int a27,__int16 a28,char a29,char a30,int a31,__int16 a32,char a33,char a34)
{
  if ((v35 & 1) == 0) {
    sub_10004D2C8(v36);
  }
  if (a34 < 0) {
    operator delete(__p);
  }
  if (v34) {
    sub_10004D2C8(v34);
  }
  if (a15) {
    sub_10004D2C8(a15);
  }
  if (a13) {
    sub_10004D2C8(a13);
  }
  _Unwind_Resume(exception_object);
}

void sub_100504D50(uint64_t a1)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 112));
  uint64_t v3 = ServiceMap;
  uint64_t v4 = "27MessageCenterModelInterface";
  if (((unint64_t)"27MessageCenterModelInterface" & 0x8000000000000000) != 0)
  {
    signed int v5 = (unsigned __int8 *)((unint64_t)"27MessageCenterModelInterface" & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v6 = 5381;
    do
    {
      uint64_t v4 = (const char *)v6;
      unsigned int v7 = *v5++;
      uint64_t v6 = (33 * v6) ^ v7;
    }
    while (v7);
  }
  std::mutex::lock(ServiceMap);
  uint64_t v12 = v4;
  uint64_t v8 = sub_10004D37C(&v3[1].__m_.__sig, (unint64_t *)&v12);
  if (!v8)
  {
    uint64_t v10 = 0;
LABEL_9:
    std::mutex::unlock(v3);
    uint64_t v9 = 0;
    char v11 = 1;
    if (!v10) {
      goto LABEL_11;
    }
    goto LABEL_10;
  }
  uint64_t v10 = v8[3];
  uint64_t v9 = (std::__shared_weak_count *)v8[4];
  if (!v9) {
    goto LABEL_9;
  }
  atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v3);
  atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v9);
  char v11 = 0;
  if (v10) {
LABEL_10:
  }
    (*(void (**)(uint64_t, void, uint64_t, void))(*(void *)v10 + 192))(v10, *(unsigned int *)(a1 + 48), 1, *(unsigned int *)(a1 + 36));
LABEL_11:
  if ((v11 & 1) == 0) {
    sub_10004D2C8(v9);
  }
}

void sub_100504E68(_Unwind_Exception *exception_object)
{
  if ((v1 & 1) == 0) {
    sub_10004D2C8(v2);
  }
  _Unwind_Resume(exception_object);
}

const char *sub_100504E84()
{
  return "MMSSend";
}

uint64_t sub_100504E90()
{
  return 1;
}

uint64_t sub_100504E98()
{
  return 1;
}

void sub_100504EA4()
{
}

void *sub_100504EB8()
{
  __n128 result = operator new(0x10uLL);
  *__n128 result = off_1019DC810;
  return result;
}

void sub_100504EF0(uint64_t a1, void *a2)
{
  *a2 = off_1019DC810;
}

void sub_100504F18(uint64_t a1, os_log_t *a2, os_signpost_id_t *a3)
{
  os_signpost_id_t v3 = *a3;
  if (*a3 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    uint64_t v4 = *a2;
    if (os_signpost_enabled(*a2))
    {
      *(_WORD *)signed int v5 = 0;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v4, OS_SIGNPOST_INTERVAL_END, v3, "MobileOriginatedMMS", (const char *)&unk_1017DEDA7, v5, 2u);
    }
  }
}

uint64_t sub_100504F90(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100504FD0()
{
}

void sub_100504FE0()
{
}

uint64_t sub_100504FF4(uint64_t a1)
{
  return *(void *)(*(void *)(a1 + 8) + 192);
}

void sub_100505000(uint64_t a1@<X0>, uint64_t a2@<X1>, NSObject **a3@<X2>, _OWORD *a4@<X8>)
{
  uint64_t v6 = (capabilities::ct *)(a1 + 8);
  unsigned int v7 = *a3;
  if (*a3) {
    dispatch_retain(v7);
  }
  uint64_t v8 = *(std::__shared_weak_count **)(a2 + 8);
  if (v8) {
    atomic_fetch_add_explicit(&v8->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  }
  NetworkEmergencyNumbers::create(v6, &v9);
  *a4 = v9;
  long long v9 = 0uLL;
  if (v8) {
    std::__shared_weak_count::__release_weak(v8);
  }
  if (v7) {
    dispatch_release(v7);
  }
}

void sub_10050509C(_Unwind_Exception *exception_object)
{
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  if (v1) {
    dispatch_release(v1);
  }
  _Unwind_Resume(exception_object);
}

const char *sub_1005050C0(unsigned int a1)
{
  if (a1 > 0x10) {
    return "???";
  }
  else {
    return off_1019DCB10[(__int16)a1];
  }
}

const char *sub_1005050E8(int a1)
{
  if ((a1 - 1) > 0x23) {
    return "kIDSServiceErrorNone";
  }
  else {
    return off_1019DCB98[(char)(a1 - 1)];
  }
}

void sub_100505284()
{
}

void sub_100505360(uint64_t a1)
{
  unsigned int v2 = [*(id *)(*(void *)(a1 + 32) + 8) devices];
  os_signpost_id_t v3 = [*(id *)(*(void *)(a1 + 32) + 8) linkedDevicesWithRelationship:2];
  uint64_t v4 = *(void *)(a1 + 32);
  signed int v5 = *(NSObject **)(v4 + 16);
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_100505450;
  block[3] = &unk_1019DC8C8;
  block[4] = v4;
  id v9 = v2;
  id v10 = v3;
  id v6 = v3;
  id v7 = v2;
  dispatch_async(v5, block);
}

void sub_100505440(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id sub_100505450(id *a1)
{
  unsigned int v2 = (unsigned __int8 *)a1[4];
  os_signpost_id_t v3 = **((void **)v2 + 5);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    int v4 = v2[48];
    id v5 = [a1[5] count];
    id v6 = [a1[6] count];
    v8[0] = 67109632;
    v8[1] = v4;
    __int16 v9 = 2048;
    id v10 = v5;
    __int16 v11 = 2048;
    id v12 = v6;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I %d: Initial RegisteredDevices [%lu]; LinkedDevices [%lu]",
      (uint8_t *)v8,
      0x1Cu);
    unsigned int v2 = (unsigned __int8 *)a1[4];
  }
  [v2 _service:*((void *)v2 + 1) devicesChanged:a1[5] isQueried:1];
  return [a1[4] service:*((void *)a1[4] + 1) linkedDevicesChanged:a1[6]];
}

void sub_1005059F8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

void sub_100505AB4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  a9.super_class = (Class)CellularPlanIDSServiceDelegate;
  [(_Unwind_Exception *)&a9 dealloc];
  _Unwind_Resume(a1);
}

void sub_1005060D0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, void *a12, char a13, uint64_t a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,int a39,__int16 a40,char a41,char a42)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

uint64_t sub_10050620C(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  *(void *)(a1 + 8) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }

  return a1;
}

void sub_10050648C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1005065E8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_100506600(uint64_t a1, void *a2, char a3)
{
  id v5 = a2;
  id v6 = v5;
  if (v5
    && ([v5 uniqueIDOverride], id v7 = objc_claimAutoreleasedReturnValue(), v7, v7))
  {
    long long v18 = 0u;
    long long v19 = 0u;
    long long v16 = 0u;
    long long v17 = 0u;
    id v8 = [v6 uniqueIDOverride];
    sub_10003ED78((std::string *)&v16, (char *)[v8 UTF8String]);

    unsigned int v9 = [v6 isNearby];
    if (v9) {
      LOBYTE(v9) = [v6 isConnected];
    }
    BYTE8(v17) = v9;
    BYTE9(v17) = [v6 isActive];
    id v10 = [v6 modelIdentifier];

    if (v10)
    {
      id v11 = [v6 modelIdentifier];
      sub_10003ED78((std::string *)&v18, (char *)[v11 UTF8String]);
    }
    [v6 operatingSystemVersion];
    [v6 operatingSystemVersion];
    [v6 operatingSystemVersion];
    DWORD2(v19) = (v14 << 8) | (v15 << 16) | v13;
    BYTE12(v19) = a3;
    *(_OWORD *)(a1 + 8) = v16;
    *(void *)(a1 + 24) = v17;
    long long v16 = 0uLL;
    *(void *)&long long v17 = 0;
    *(_WORD *)(a1 + 32) = WORD4(v17);
    *(_OWORD *)(a1 + 40) = v18;
    *(void *)(a1 + 56) = v19;
    long long v18 = 0uLL;
    *(void *)&long long v19 = 0;
    int v12 = DWORD2(v19);
    *(unsigned char *)(a1 + 68) = a3;
    *(_DWORD *)(a1 + 64) = v12;
    *(unsigned char *)a1 = 1;
  }
  else
  {
    *(unsigned char *)a1 = 0;
  }
}

void sub_1005067A0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  sub_100087740((uint64_t)va);

  _Unwind_Resume(a1);
}

void sub_100506988(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id sub_1005069D4(uint64_t a1)
{
  uint64_t v2 = +[NSMutableDictionary dictionaryWithCapacity:6];
  [v2 setObject:&__kCFBooleanTrue forKeyedSubscript:IDSSendMessageOptionBypassDuetKey];
  os_signpost_id_t v3 = +[NSNumber numberWithInt:*(unsigned int *)(a1 + 76)];
  [v2 setObject:v3 forKeyedSubscript:IDSSendMessageOptionTimeoutKey];

  int v4 = *(unsigned __int8 *)(a1 + 72);
  if (v4 == 1)
  {
    id v5 = &IDSSendMessageOptionAllowCloudDeliveryKey;
  }
  else
  {
    if (v4 != 2) {
      goto LABEL_6;
    }
    id v5 = &IDSSendMessageOptionRequireBluetoothKey;
  }
  [v2 setObject:&__kCFBooleanTrue forKeyedSubscript:*v5];
LABEL_6:
  if (*(unsigned char *)(a1 + 84)) {
    [v2 setObject:&__kCFBooleanTrue forKeyedSubscript:IDSSendMessageOptionWantsClientAcknowledgementKey];
  }
  uint64_t v6 = IDSSendMessageOptionEnforceRemoteTimeoutsKey;
  [v2 setObject:&__kCFBooleanFalse forKeyedSubscript:IDSSendMessageOptionEnforceRemoteTimeoutsKey];
  if (*(unsigned char *)(a1 + 85)) {
    [v2 setObject:&__kCFBooleanTrue forKeyedSubscript:v6];
  }
  id v7 = (void *)(a1 + 24);
  if ((*(char *)(a1 + 47) & 0x80000000) == 0)
  {
    if (!*(unsigned char *)(a1 + 47)) {
      goto LABEL_16;
    }
LABEL_15:
    id v8 = +[NSString stringWithUTF8String:v7];
    [v2 setObject:v8 forKeyedSubscript:IDSSendMessageOptionPeerResponseIdentifierKey];

    goto LABEL_19;
  }
  if (*(void *)(a1 + 32))
  {
    id v7 = (void *)*v7;
    goto LABEL_15;
  }
LABEL_16:
  unsigned int v9 = *(unsigned __int16 *)(a1 + 48);
  if (v9 <= 0xD && ((1 << v9) & 0x3550) != 0) {
    [v2 setObject:&__kCFBooleanTrue forKeyedSubscript:IDSSendMessageOptionExpectsPeerResponseKey];
  }
LABEL_19:

  return v2;
}

void sub_100506BA0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100506DA8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100507068(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, id location, uint64_t a20,uint64_t a21,uint64_t a22,id a23,void *__p,uint64_t a25,int a26,__int16 a27,char a28,char a29,char a30)
{
}

id *sub_1005070F8(id *location)
{
  if (*((char *)location + 31) < 0) {
    operator delete(location[1]);
  }
  objc_destroyWeak(location);
  return location;
}

void sub_10050739C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,char a24,uint64_t a25,uint64_t a26,void **a27)
{
  a27 = (void **)&a24;
  sub_1002B2AEC(&a27);

  _Unwind_Resume(a1);
}

uint64_t sub_100507410(int64x2_t *a1, long long *a2)
{
  unint64_t v6 = a1[1].u64[0];
  uint64_t i64 = (uint64_t)a1[1].i64;
  unint64_t v5 = v6;
  unint64_t v7 = *(void *)(i64 - 8);
  if (v7 >= v6)
  {
    uint64_t v10 = (uint64_t)(v7 - a1->i64[0]) >> 6;
    if ((unint64_t)(v10 + 1) >> 58) {
      sub_10006A748();
    }
    uint64_t v11 = v5 - a1->i64[0];
    uint64_t v12 = v11 >> 5;
    if (v11 >> 5 <= (unint64_t)(v10 + 1)) {
      uint64_t v12 = v10 + 1;
    }
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFC0) {
      unint64_t v13 = 0x3FFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v13 = v12;
    }
    uint64_t v26 = i64;
    if (v13) {
      int v14 = (char *)sub_1001A14BC(i64, v13);
    }
    else {
      int v14 = 0;
    }
    uint64_t v23 = v14;
    v24.i64[0] = (uint64_t)&v14[64 * v10];
    uint64_t v25 = &v14[64 * v13];
    sub_1003C1CC4((char *)v24.i64[0], a2);
    uint64_t v15 = v24.i64[0];
    uint64_t v9 = v24.i64[0] + 64;
    v24.i64[1] = v24.i64[0] + 64;
    uint64_t v17 = a1->i64[0];
    unint64_t v16 = a1->u64[1];
    if (v16 == a1->i64[0])
    {
      int64x2_t v21 = vdupq_n_s64(v16);
    }
    else
    {
      do
      {
        long long v18 = *(_OWORD *)(v16 - 64);
        *(void *)(v15 - 48) = *(void *)(v16 - 48);
        *(_OWORD *)(v15 - 64) = v18;
        *(void *)(v16 - 56) = 0;
        *(void *)(v16 - 48) = 0;
        *(void *)(v16 - 64) = 0;
        *(_WORD *)(v15 - 40) = *(_WORD *)(v16 - 40);
        long long v19 = *(_OWORD *)(v16 - 32);
        *(void *)(v15 - 16) = *(void *)(v16 - 16);
        *(_OWORD *)(v15 - 32) = v19;
        *(void *)(v16 - 24) = 0;
        *(void *)(v16 - 16) = 0;
        *(void *)(v16 - 32) = 0;
        int v20 = *(_DWORD *)(v16 - 8);
        *(unsigned char *)(v15 - 4) = *(unsigned char *)(v16 - 4);
        *(_DWORD *)(v15 - 8) = v20;
        v15 -= 64;
        v16 -= 64;
      }
      while (v16 != v17);
      int64x2_t v21 = *a1;
      uint64_t v9 = v24.i64[1];
    }
    a1->i64[0] = v15;
    a1->i64[1] = v9;
    int64x2_t v24 = v21;
    uint64_t v22 = (char *)a1[1].i64[0];
    a1[1].i64[0] = (uint64_t)v25;
    uint64_t v25 = v22;
    uint64_t v23 = (char *)v21.i64[0];
    uint64_t result = sub_1002B2A9C((uint64_t)&v23);
  }
  else
  {
    uint64_t result = (uint64_t)sub_1003C1CC4(*(char **)(i64 - 8), a2);
    uint64_t v9 = v7 + 64;
    a1->i64[1] = v7 + 64;
  }
  a1->i64[1] = v9;
  return result;
}

void sub_100507588(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1002B2A9C((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_100507800(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,char a24,uint64_t a25,uint64_t a26,void **a27)
{
  a27 = (void **)&a24;
  sub_1002B2AEC(&a27);

  _Unwind_Resume(a1);
}

void sub_100507AFC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1003C55AC((uint64_t)va);
  if (*(char *)(v7 - 129) < 0) {
    operator delete(*(void **)(v7 - 152));
  }

  _Unwind_Resume(a1);
}

void sub_100507C74(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

void sub_100507D9C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1005084CC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, void *a15, uint64_t a16, void *a17, void *a18, void *a19, void *a20,void *a21,uint64_t a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,char a38)
{
  if (a28 < 0) {
    operator delete(__p);
  }

  sub_10050A070(v40 - 208);
  sub_1003C1D74((uint64_t)&a38);

  _Unwind_Resume(a1);
}

void sub_100508A18(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  sub_10050A070(v30 - 176);
  sub_1003C1D74((uint64_t)&a26);

  _Unwind_Resume(a1);
}

uint64_t sub_100508ABC(uint64_t result)
{
  if ((result - 4) >= 0xC) {
    return 0;
  }
  else {
    return result;
  }
}

void sub_100508F38(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,void *__p,uint64_t a35,int a36,__int16 a37,char a38,char a39,uint64_t a40,uint64_t a41,char a42)
{
  sub_10050A070((uint64_t)&a42);
  sub_1003C1D74(v48 - 192);

  if (a39 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

void sub_100509338(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  sub_10050A070(v30 - 176);
  sub_1003C1D74((uint64_t)&a26);

  _Unwind_Resume(a1);
}

void *sub_1005094AC(void *a1, NSObject **a2, uint64_t a3, uint64_t a4)
{
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v10, kCtLoggingSystemName, "cp.ids");
  a1[1] = 0;
  a1[2] = 0;
  id v8 = *a2;
  a1[3] = *a2;
  if (v8) {
    dispatch_retain(v8);
  }
  a1[4] = 0;
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v11, &v10);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 5), (const ctu::OsLogLogger *)v11);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v11);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v10);
  *a1 = off_1019DC8F8;
  a1[6] = [[CellularPlanIDSServiceDelegate alloc] initWithQueue:*a2 registry:a3 serviceType:a4];
  return a1;
}

void sub_100509594(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v4 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)va1);
  sub_100087E88(v2);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1005095D8(uint64_t a1)
{
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 40));
  sub_100087E88((void *)(a1 + 8));
  return a1;
}

void sub_10050961C(uint64_t a1)
{
  sub_1005095D8(a1);

  operator delete();
}

id sub_100509654(uint64_t a1)
{
  return [*(id *)(a1 + 48) startService];
}

BOOL sub_10050965C(uint64_t a1, uint64_t a2, uint64_t a3, void *a4, void *a5, void *a6)
{
  uint64_t v17 = a2;
  id v16 = a4;
  id v15 = a5;
  v13[5] = a3;
  id v14 = a6;
  v13[0] = &v16;
  v13[1] = &v15;
  v13[2] = &v14;
  v13[3] = a1;
  void v13[4] = &v17;
  v18[0] = _NSConcreteStackBlock;
  v18[1] = 3221225472;
  v18[2] = sub_10050A810;
  v18[3] = &unk_10199E4C0;
  v18[4] = a1 + 8;
  v18[5] = v13;
  long long v19 = objc_retainBlock(v18);
  OsLogContext v10 = *(NSObject **)(a1 + 24);
  if (*(void *)(a1 + 32))
  {
    char v26 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v21 = 3221225472;
    uint64_t v22 = sub_10050A9E4;
    uint64_t v23 = &unk_10199E470;
    int64x2_t v24 = &v26;
    uint64_t v25 = &v19;
    dispatch_async_and_wait(v10, &block);
  }
  else
  {
    char v26 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v21 = 3221225472;
    uint64_t v22 = sub_10050A9A8;
    uint64_t v23 = &unk_10199E470;
    int64x2_t v24 = &v26;
    uint64_t v25 = &v19;
    dispatch_sync(v10, &block);
  }
  BOOL v11 = v26 != 0;

  return v11;
}

void sub_100509820(uint64_t a1, long long *a2, void *a3)
{
  id v5 = a3;
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 3321888768;
  v7[2] = sub_1005099C0;
  double v7[3] = &unk_1019DC940;
  uint64_t v9 = a1;
  if (*((char *)a2 + 23) < 0)
  {
    sub_10004FC84(&v10, *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v10 = *a2;
    uint64_t v11 = *((void *)a2 + 2);
  }
  if (*((char *)a2 + 47) < 0)
  {
    sub_10004FC84(&__p, *((void **)a2 + 3), *((void *)a2 + 4));
  }
  else
  {
    long long __p = *(long long *)((char *)a2 + 24);
    uint64_t v13 = *((void *)a2 + 5);
  }
  __int16 v14 = *((_WORD *)a2 + 24);
  sub_10002FD9C(&v15, (const void **)a2 + 7);
  sub_100119B5C(&v16, (const void **)a2 + 8);
  v17[0] = *((void *)a2 + 9);
  *(void *)((char *)v17 + 6) = *(void *)((char *)a2 + 78);
  id v6 = v5;
  id v8 = v6;
  sub_10050AA20((uint64_t *)(a1 + 8), v7);

  sub_1000FE824(&v16);
  sub_100030068(&v15);
  if (SHIBYTE(v13) < 0) {
    operator delete((void *)__p);
  }
  if (SHIBYTE(v11) < 0) {
    operator delete((void *)v10);
  }
}

void sub_100509998(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

void sub_1005099C0(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  os_signpost_id_t v3 = *(void **)(v2 + 48);
  if (*(char *)(a1 + 71) < 0)
  {
    sub_10004FC84(__dst, *(void **)(a1 + 48), *(void *)(a1 + 56));
  }
  else
  {
    *(_OWORD *)std::string __dst = *(_OWORD *)(a1 + 48);
    uint64_t v10 = *(void *)(a1 + 64);
  }
  if (*(char *)(a1 + 95) < 0)
  {
    sub_10004FC84(&__p, *(void **)(a1 + 72), *(void *)(a1 + 80));
  }
  else
  {
    long long __p = *(_OWORD *)(a1 + 72);
    uint64_t v12 = *(void *)(a1 + 88);
  }
  __int16 v13 = *(_WORD *)(a1 + 96);
  sub_10002FD9C(&v14, (const void **)(a1 + 104));
  sub_100119B5C(&v15, (const void **)(a1 + 112));
  v16[0] = *(void *)(a1 + 120);
  *(void *)((char *)v16 + 6) = *(void *)(a1 + 126);
  unsigned __int8 v4 = [v3 sendMessage:__dst responseHandler:*(void *)(a1 + 32)];
  sub_1000FE824(&v15);
  sub_100030068(&v14);
  if (SHIBYTE(v12) < 0) {
    operator delete((void *)__p);
  }
  if (SHIBYTE(v10) < 0)
  {
    operator delete(__dst[0]);
    if (v4) {
      return;
    }
  }
  else if (v4)
  {
    return;
  }
  id v5 = *(NSObject **)(v2 + 40);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "Failed to send message?", buf, 2u);
  }
  uint64_t v6 = *(void *)(a1 + 32);
  if (v6)
  {
    v7[0] = 0;
    sub_1003C55AC((uint64_t)v7);
    v7[0] = 2;
    unsigned char v7[8] = 11;
    (*(void (**)(uint64_t, unsigned char *))(v6 + 16))(v6, v7);
    sub_1003C55AC((uint64_t)v7);
  }
}

void sub_100509B68(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
}

const void **sub_100509BA4(uint64_t a1, uint64_t a2)
{
  if (*(char *)(a2 + 71) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 48), *(void **)(a2 + 48), *(void *)(a2 + 56));
  }
  else
  {
    long long v4 = *(_OWORD *)(a2 + 48);
    *(void *)(a1 + 64) = *(void *)(a2 + 64);
    *(_OWORD *)(a1 + 48) = v4;
  }
  id v5 = (unsigned char *)(a1 + 72);
  if (*(char *)(a2 + 95) < 0)
  {
    sub_10004FC84(v5, *(void **)(a2 + 72), *(void *)(a2 + 80));
  }
  else
  {
    long long v6 = *(_OWORD *)(a2 + 72);
    *(void *)(a1 + 88) = *(void *)(a2 + 88);
    *(_OWORD *)id v5 = v6;
  }
  *(_WORD *)(a1 + 96) = *(_WORD *)(a2 + 96);
  sub_10002FD9C((const void **)(a1 + 104), (const void **)(a2 + 104));
  uint64_t result = sub_100119B5C((const void **)(a1 + 112), (const void **)(a2 + 112));
  uint64_t v8 = *(void *)(a2 + 120);
  *(void *)(a1 + 126) = *(void *)(a2 + 126);
  *(void *)(a1 + 120) = v8;
  return result;
}

void sub_100509C5C(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 71) < 0) {
    operator delete(*v2);
  }
  _Unwind_Resume(exception_object);
}

void sub_100509C78(uint64_t a1)
{
  sub_1000FE824((const void **)(a1 + 112));
  sub_100030068((const void **)(a1 + 104));
  if (*(char *)(a1 + 95) < 0) {
    operator delete(*(void **)(a1 + 72));
  }
  if (*(char *)(a1 + 71) < 0)
  {
    uint64_t v2 = *(void **)(a1 + 48);
    operator delete(v2);
  }
}

void sub_100509CE0(uint64_t a1, long long *a2)
{
  uint64_t v2 = (uint64_t *)(a1 + 8);
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3321888768;
  v3[2] = sub_100509D98;
  v3[3] = &unk_1019DC970;
  v3[4] = a1;
  if (*((char *)a2 + 23) < 0)
  {
    sub_10004FC84(&__p, *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long __p = *a2;
    uint64_t v5 = *((void *)a2 + 2);
  }
  sub_10050AA20(v2, v3);
  if (SHIBYTE(v5) < 0) {
    operator delete((void *)__p);
  }
}

void sub_100509D98(uint64_t a1)
{
  uint64_t v1 = *(void **)(*(void *)(a1 + 32) + 48);
  if (*(char *)(a1 + 63) < 0)
  {
    sub_10004FC84(__p, *(void **)(a1 + 40), *(void *)(a1 + 48));
  }
  else
  {
    *(_OWORD *)long long __p = *(_OWORD *)(a1 + 40);
    uint64_t v3 = *(void *)(a1 + 56);
  }
  [v1 handledResponse:__p];
  if (SHIBYTE(v3) < 0) {
    operator delete(__p[0]);
  }
}

void sub_100509E0C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100509E28(uint64_t a1, uint64_t a2, int a3)
{
  if (*(char *)(a2 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)long long __p = *(_OWORD *)a2;
    xpc_object_t __p[2] = *(void **)(a2 + 16);
  }
  int v7 = a3;
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 16);
  if (v5)
  {
    if (std::__shared_weak_count::lock(v5)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100509F90(std::string *a1@<X8>)
{
  a1->__r_.__value_.__r.__words[0] = 0;
  a1->__r_.__value_.__l.__size_ = 0;
  a1->__r_.__value_.__r.__words[2] = 0;
  id v2 = (id)IDSCopyLocalDeviceUniqueID();
  if (v2) {
    sub_10003ED78(a1, (char *)[v2 UTF8String]);
  }
}

void sub_10050A004(_Unwind_Exception *a1)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(a1);
}

void sub_10050A024(void **a1)
{
  id v2 = *a1;
}

uint64_t sub_10050A070(uint64_t a1)
{
  if (*(unsigned char *)a1)
  {
    if (*(char *)(a1 + 63) < 0) {
      operator delete(*(void **)(a1 + 40));
    }
    if (*(char *)(a1 + 31) < 0) {
      operator delete(*(void **)(a1 + 8));
    }
    *(unsigned char *)a1 = 0;
  }
  return a1;
}

void sub_10050A0C0(void *a1)
{
  if (a1)
  {
    sub_10050A0C0(*a1);
    sub_10050A0C0(a1[1]);
    sub_10050A114((uint64_t)(a1 + 4));
    operator delete(a1);
  }
}

void sub_10050A114(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  *(void *)(a1 + 32) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }

  if (*(char *)(a1 + 23) < 0)
  {
    uint64_t v3 = *(void **)a1;
    operator delete(v3);
  }
}

void sub_10050A194(uint64_t **a1, void **a2)
{
  uint64_t v3 = (uint64_t *)sub_100046F68((uint64_t)a1, a2);
  if (a1 + 1 != (uint64_t **)v3)
  {
    long long v4 = v3;
    sub_1000F5B04(a1, v3);
    sub_10050A114((uint64_t)(v4 + 4));
    operator delete(v4);
  }
}

uint64_t sub_10050A1FC(uint64_t a1)
{
  *(void *)a1 = off_1019DCA68;
  if (*(char *)(a1 + 39) < 0) {
    operator delete(*(void **)(a1 + 16));
  }
  objc_destroyWeak((id *)(a1 + 8));
  return a1;
}

void sub_10050A254(uint64_t a1)
{
  *(void *)a1 = off_1019DCA68;
  if (*(char *)(a1 + 39) < 0) {
    operator delete(*(void **)(a1 + 16));
  }
  objc_destroyWeak((id *)(a1 + 8));

  operator delete();
}

void *sub_10050A2CC(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t v2 = operator new(0x28uLL);
  void *v2 = off_1019DCA68;
  sub_10050A518((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_10050A320(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_10050A334(uint64_t a1, void *a2)
{
  *a2 = off_1019DCA68;
  return sub_10050A518((uint64_t)(a2 + 1), a1 + 8);
}

void sub_10050A360(uint64_t a1)
{
}

void sub_10050A368(id *a1)
{
  sub_10050A584(a1 + 1);

  operator delete(a1);
}

void sub_10050A3A4(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 8));
  if (WeakRetained)
  {
    WeakRetained;
    if (*(char *)(a1 + 39) < 0)
    {
      sub_10004FC84(__p, *(void **)(a1 + 16), *(void *)(a1 + 24));
    }
    else
    {
      *(_OWORD *)long long __p = *(_OWORD *)(a1 + 16);
      xpc_object_t __p[2] = *(void **)(a1 + 32);
    }
    operator new();
  }
}

void sub_10050A4B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9)
{
  _Unwind_Resume(a1);
}

uint64_t sub_10050A4CC(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_1019DCAC8)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_10050A50C()
{
  return &off_1019DCAC8;
}

uint64_t sub_10050A518(uint64_t a1, uint64_t a2)
{
  objc_copyWeak((id *)a1, (id *)a2);
  long long v4 = (unsigned char *)(a1 + 8);
  if (*(char *)(a2 + 31) < 0)
  {
    sub_10004FC84(v4, *(void **)(a2 + 8), *(void *)(a2 + 16));
  }
  else
  {
    long long v5 = *(_OWORD *)(a2 + 8);
    *(void *)(a1 + 24) = *(void *)(a2 + 24);
    *(_OWORD *)long long v4 = v5;
  }
  return a1;
}

void sub_10050A570(_Unwind_Exception *a1)
{
  objc_destroyWeak(v1);
  _Unwind_Resume(a1);
}

void sub_10050A584(id *location)
{
  if (*((char *)location + 31) < 0) {
    operator delete(location[1]);
  }

  objc_destroyWeak(location);
}

uint64_t *sub_10050A5C8(uint64_t *result)
{
  uint64_t v1 = *result;
  *uint64_t result = 0;
  if (v1)
  {
    if (*(char *)(v1 + 31) < 0) {
      operator delete(*(void **)(v1 + 8));
    }

    operator delete();
  }
  return result;
}

uint64_t *sub_10050A628(uint64_t a1)
{
  uint64_t v10 = a1;
  uint64_t v2 = *(void *)a1;
  uint64_t v3 = **(NSObject ***)(*(void *)a1 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
  {
    uint64_t v9 = (void *)(a1 + 8);
    if (*(char *)(a1 + 31) < 0) {
      uint64_t v9 = (void *)*v9;
    }
    *(_DWORD *)long long buf = 136315138;
    uint64_t v12 = v9;
    _os_log_error_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "SendMessage Message ID Timeout: [%s]", buf, 0xCu);
    uint64_t v2 = *(void *)a1;
  }
  long long v4 = sub_100046F68(v2 + 56, (void **)(a1 + 8));
  if ((void **)(*(void *)a1 + 64) != v4)
  {
    long long v5 = (uint64_t *)v4;
    long long v6 = sub_100046F68(*(void *)a1 + 80, (void **)(a1 + 8));
    uint64_t v7 = v5[7];
    if ((void **)(*(void *)a1 + 88) == v6)
    {
      buf[0] = 0;
      sub_1003C55AC((uint64_t)buf);
      buf[0] = 2;
      BYTE4(v12) = 17;
      (*(void (**)(uint64_t, uint8_t *))(v7 + 16))(v7, buf);
      sub_1003C55AC((uint64_t)buf);
    }
    else
    {
      buf[0] = 0;
      sub_1003C55AC((uint64_t)buf);
      buf[0] = 2;
      BYTE4(v12) = 36;
      (*(void (**)(uint64_t, uint8_t *))(v7 + 16))(v7, buf);
      sub_1003C55AC((uint64_t)buf);
      sub_1000E1C44((uint64_t **)(*(void *)a1 + 80), (uint64_t)v6);
    }
    sub_1000F5B04((uint64_t **)(*(void *)a1 + 56), v5);
    sub_10050A114((uint64_t)(v5 + 4));
    operator delete(v5);
  }
  return sub_10050A5C8(&v10);
}

void sub_10050A7E8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, void);
  sub_1003C55AC((uint64_t)va1);
  sub_10050A5C8((uint64_t *)va);
  _Unwind_Resume(a1);
}

id sub_10050A810(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 40);
  uint64_t v2 = *(void *)(v1 + 24);
  if (!**(void **)v1 || !**(void **)(v1 + 8) || !**(void **)(v1 + 16))
  {
    long long v6 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      uint64_t v10 = **(void **)(v1 + 32);
      int v11 = 136315138;
      uint64_t v12 = v10;
      uint64_t v9 = "Callback missing [%s] do not register";
      goto LABEL_12;
    }
    return 0;
  }
  if (!**(_WORD **)(v1 + 40))
  {
    long long v6 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      uint64_t v8 = **(void **)(v1 + 32);
      int v11 = 136315138;
      uint64_t v12 = v8;
      uint64_t v9 = "No supported message type to register [%s]";
LABEL_12:
      _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, v9, (uint8_t *)&v11, 0xCu);
      return 0;
    }
    return 0;
  }
  uint64_t v3 = *(void **)(v2 + 48);
  long long v4 = +[NSString stringWithUTF8String:**(void **)(v1 + 32)];
  id v5 = [v3 registerWithName:v4 supportedIncomingMessageTypes:**(void **)(v1 + 40) validateDeviceCallback:**(void **)v1 devicesChangedCallback:**(void **)(v1 + 8) incomingMessageCallback:**(void **)(v1 + 16)];

  return v5;
}

void sub_10050A990(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_10050A9A8(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 40) + 16))();
  **(unsigned char **)(a1 + 32) = result;
  return result;
}

uint64_t sub_10050A9E4(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 40) + 16))();
  **(unsigned char **)(a1 + 32) = result;
  return result;
}

void sub_10050AA20(uint64_t *a1, void *a2)
{
  id v3 = a2;
  long long v4 = (std::__shared_weak_count *)a1[1];
  if (!v4 || (uint64_t v5 = *a1, (v6 = std::__shared_weak_count::lock(v4)) == 0)) {
    sub_100088B9C();
  }
  uint64_t v7 = v6;
  uint64_t v8 = a1[2];
  block[0] = _NSConcreteStackBlock;
  block[1] = 3321888768;
  block[2] = sub_10050AB0C;
  block[3] = &unk_1019DCAE0;
  uint64_t v12 = v5;
  __int16 v13 = v6;
  atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
  id v9 = v3;
  id v11 = v9;
  dispatch_async(v8, block);

  if (v13) {
    sub_10004D2C8(v13);
  }
  sub_10004D2C8(v7);
}

uint64_t sub_10050AB0C(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

uint64_t sub_10050AB1C(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_10050AB38(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

uint64_t *sub_10050AB48(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v5 = a1;
  uint64_t v6 = v1;
  uint64_t v2 = *(void **)(*(void *)v1 + 48);
  if (*(char *)(v1 + 31) < 0)
  {
    sub_10004FC84(__p, *(void **)(v1 + 8), *(void *)(v1 + 16));
  }
  else
  {
    long long v3 = *(_OWORD *)(v1 + 8);
    uint64_t v8 = *(void *)(v1 + 24);
    *(_OWORD *)long long __p = v3;
  }
  objc_msgSend(v2, "updateTimeoutForTransaction:timeout:", __p, *(unsigned int *)(v1 + 32), v5, v6);
  if (SHIBYTE(v8) < 0) {
    operator delete(__p[0]);
  }
  sub_1000E890C(&v6);
  return sub_100046B58((uint64_t *)&v5);
}

void sub_10050ABD8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
}

void sub_10050AC0C()
{
}

double sub_10050AC34@<D0>(_OWORD *a1@<X8>)
{
  sub_1005741F0((std::__shared_weak_count **)&v3);
  double result = *(double *)&v3;
  *a1 = v3;
  return result;
}

void sub_10050AC74(LaunchServicesFactoryInterface *a1)
{
  LaunchServicesFactoryInterface::~LaunchServicesFactoryInterface(a1);

  operator delete();
}

void sub_10050ACAC(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1019DCD08;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_10050ACCC(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1019DCD08;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_10050AD20(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

_DWORD *sub_10050AD48(_DWORD *result, int a2)
{
  result[3] = a2;
  if (result[56] == 3) {
    int v2 = 30;
  }
  else {
    int v2 = -1;
  }
  result[58] = v2;
  return result;
}

uint64_t sub_10050AD64(uint64_t a1)
{
  *(void *)a1 = off_1019E5360;
  if (*(char *)(a1 + 207) < 0) {
    operator delete(*(void **)(a1 + 184));
  }
  if (*(char *)(a1 + 183) < 0) {
    operator delete(*(void **)(a1 + 160));
  }
  if (*(char *)(a1 + 159) < 0) {
    operator delete(*(void **)(a1 + 136));
  }
  if (*(char *)(a1 + 135) < 0) {
    operator delete(*(void **)(a1 + 112));
  }
  int v2 = *(std::__shared_weak_count **)(a1 + 96);
  if (v2) {
    sub_10004D2C8(v2);
  }
  if (*(char *)(a1 + 79) < 0) {
    operator delete(*(void **)(a1 + 56));
  }
  return a1;
}

void sub_10050AE00(uint64_t a1)
{
  *(void *)a1 = off_1019E5360;
  if (*(char *)(a1 + 207) < 0) {
    operator delete(*(void **)(a1 + 184));
  }
  if (*(char *)(a1 + 183) < 0) {
    operator delete(*(void **)(a1 + 160));
  }
  if (*(char *)(a1 + 159) < 0) {
    operator delete(*(void **)(a1 + 136));
  }
  if (*(char *)(a1 + 135) < 0) {
    operator delete(*(void **)(a1 + 112));
  }
  int v2 = *(std::__shared_weak_count **)(a1 + 96);
  if (v2) {
    sub_10004D2C8(v2);
  }
  if (*(char *)(a1 + 79) < 0) {
    operator delete(*(void **)(a1 + 56));
  }

  operator delete();
}

const char *sub_10050AEBC()
{
  return "SmsSend";
}

uint64_t sub_10050AEC8()
{
  return 1;
}

void sub_10050B0E0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, id a9)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_10050B140(uint64_t a1)
{
  id v2 = objc_alloc_init((Class)sub_10050B180());
  long long v3 = *(void **)(a1 + 232);
  *(void *)(a1 + 232) = v2;
}

id sub_10050B180()
{
  uint64_t v4 = 0;
  uint64_t v5 = &v4;
  uint64_t v6 = 0x2050000000;
  char v0 = (void *)qword_101B0D128;
  uint64_t v7 = qword_101B0D128;
  if (!qword_101B0D128)
  {
    v3[0] = _NSConcreteStackBlock;
    v3[1] = 3221225472;
    v3[2] = sub_10050CC00;
    v3[3] = &unk_1019DD010;
    v3[4] = &v4;
    sub_10050CC00((uint64_t)v3);
    char v0 = (void *)v5[3];
  }
  id v1 = v0;
  _Block_object_dispose(&v4, 8);

  return v1;
}

void sub_10050B24C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_10050B264(uint64_t a1)
{
  id v2 = *(id *)(a1 + 232);
  long long v3 = *(void **)(a1 + 232);
  *(void *)(a1 + 232) = 0;

  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472;
  void v6[2] = sub_10050B338;
  void v6[3] = &unk_1019DCEC8;
  id v7 = v2;
  id v4 = v2;
  [v4 resetProcessedEvent:5 reply:v6];
  uint64_t v5 = *(const void **)(a1 + 224);
  *(void *)(a1 + 224) = 0;
  uint64_t v8 = v5;
  sub_100030068(&v8);
}

void sub_10050B320(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13)
{
  _Unwind_Resume(a1);
}

void sub_10050B338(uint64_t a1, int a2, void *a3)
{
  id v5 = a3;
  if (v5)
  {
    ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v8, kCtLoggingSystemName, "cp.si.ctr");
    uint64_t v6 = *(id *)&v9[4];
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v8);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      id v7 = "failed";
      if (a2) {
        id v7 = "succeed";
      }
      int v8 = 136315394;
      *(void *)id v9 = v7;
      *(_WORD *)&char v9[8] = 2112;
      *(void *)&v9[10] = v5;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "resetProcessedEvent %s, err:%@", (uint8_t *)&v8, 0x16u);
    }
  }
  [*(id *)(a1 + 32) invalidate];
}

void sub_10050B44C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10050B468(uint64_t a1, char a2, long long *a3, uint64_t a4)
{
  id v5 = (void *)(a4 + 24);
  if (*(void *)(a4 + 24))
  {
    if (*(void *)(a1 + 224)) {
      id v7 = sub_10008324C;
    }
    else {
      id v7 = 0;
    }
    if (v7)
    {
      sub_10024924C(a4, 0);
      return;
    }
    id v9 = (void *)(a1 + 88);
    if (*(void *)(a1 + 88))
    {
      uint64_t v10 = sub_100200FB4((id *)(a1 + 40));
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "secureIntent onging", buf, 2u);
      }

      sub_10024924C(a4, 13);
      return;
    }
    uint64_t v13 = a1 + 64;
    sub_10050D3C8((void *)(a1 + 64));
    uint64_t v14 = *v5;
    if (*v5)
    {
      if (v14 == a4)
      {
        *id v9 = v13;
        (*(void (**)(void, uint64_t))(*(void *)*v5 + 24))(*v5, a1 + 64);
LABEL_22:
        (***(void (****)(uint8_t *__return_ptr))(a1 + 48))(buf);
        ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)buf);
        id v16 = ServiceMap;
        if ((v17 & 0x8000000000000000) != 0)
        {
          long long v18 = (unsigned __int8 *)(v17 & 0x7FFFFFFFFFFFFFFFLL);
          uint64_t v19 = 5381;
          do
          {
            unint64_t v17 = v19;
            unsigned int v20 = *v18++;
            uint64_t v19 = (33 * v19) ^ v20;
          }
          while (v20);
        }
        std::mutex::lock(ServiceMap);
        unint64_t v32 = v17;
        uint64_t v21 = sub_10004D37C(&v16[1].__m_.__sig, &v32);
        if (v21)
        {
          uint64_t v23 = v21[3];
          uint64_t v22 = (std::__shared_weak_count *)v21[4];
          if (v22)
          {
            atomic_fetch_add_explicit(&v22->__shared_owners_, 1uLL, memory_order_relaxed);
            std::mutex::unlock(v16);
            atomic_fetch_add_explicit(&v22->__shared_owners_, 1uLL, memory_order_relaxed);
            sub_10004D2C8(v22);
            char v24 = 0;
LABEL_30:
            if (v31) {
              sub_10004D2C8(v31);
            }
            if (v23)
            {
              char v27 = a2;
              if (*((char *)a3 + 23) < 0)
              {
                sub_10004FC84(&__p, *(void **)a3, *((void *)a3 + 1));
              }
              else
              {
                long long __p = *a3;
                uint64_t v29 = *((void *)a3 + 2);
              }
              uint64_t v34 = 0;
              uint64_t v25 = (char *)operator new(0x30uLL);
              *(void *)uint64_t v25 = off_1019DD0A8;
              *((void *)v25 + 1) = a1;
              v25[16] = v27;
              char v26 = v25 + 24;
              if (SHIBYTE(v29) < 0)
              {
                sub_10004FC84(v26, (void *)__p, *((unint64_t *)&__p + 1));
              }
              else
              {
                *(_OWORD *)char v26 = __p;
                *((void *)v25 + 5) = v29;
              }
              uint64_t v34 = v25;
              (*(void (**)(uint64_t, void *))(*(void *)v23 + 72))(v23, v33);
              sub_10001E914(v33);
              if (SHIBYTE(v29) < 0) {
                operator delete((void *)__p);
              }
            }
            if ((v24 & 1) == 0) {
              sub_10004D2C8(v22);
            }
            return;
          }
        }
        else
        {
          uint64_t v23 = 0;
        }
        std::mutex::unlock(v16);
        uint64_t v22 = 0;
        char v24 = 1;
        goto LABEL_30;
      }
      *id v9 = v14;
    }
    else
    {
      id v5 = (void *)(a1 + 88);
    }
    void *v5 = 0;
    goto LABEL_22;
  }
  int v8 = sub_100200FB4((id *)(a1 + 40));
  if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "invalid secure intent callback", buf, 2u);
  }
}

void sub_10050B830(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21)
{
  operator delete(v21);
  if (a17 < 0) {
    operator delete(__p);
  }
  if ((v23 & 1) == 0) {
    sub_10004D2C8(v22);
  }
  _Unwind_Resume(a1);
}

void *sub_10050B8AC(uint64_t a1)
{
  [*(id *)(a1 + 240) invalidate];
  id v2 = *(void **)(a1 + 240);
  *(void *)(a1 + 240) = 0;

  long long v5 = 0u;
  long long v6 = 0u;
  long long v3 = (void *)(a1 + 64);
  sub_10032CA08((uint64_t)&v5, (uint64_t)v3);
  if (*((void *)&v6 + 1))
  {
    sub_10050D3C8(v3);
    sub_10024924C((uint64_t)&v5, 45);
  }
  return sub_100313668(&v5);
}

void sub_10050B950(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_10050B964(uint64_t a1, uint64_t a2, uint64_t a3)
{
  id v4 = (uint64_t *)(a3 + 24);
  if (!*(void *)(a3 + 24))
  {
    uint64_t v10 = sub_100200FB4((id *)(a1 + 40));
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      LOWORD(keys) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "invalid secureAuth callback", (uint8_t *)&keys, 2u);
    }

    return;
  }
  if (*(void *)(a1 + 224)) {
    long long v5 = sub_10008324C;
  }
  else {
    long long v5 = 0;
  }
  if (v5)
  {
    long long v6 = (uint64_t *)(a1 + 120);
    if (*(void *)(a1 + 120))
    {
      id v7 = sub_100200FB4((id *)(a1 + 40));
      if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
      {
        LOWORD(keys) = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "previous secureAuth ongoing", (uint8_t *)&keys, 2u);
      }

      v53[0] = 0;
      char v55 = 0;
      int v57 = 0;
      uint64_t v58 = 0;
      long long __p = 0;
      sub_10050C5D4(*v4, (uint64_t)v53, 13);
      if (__p)
      {
        int v57 = __p;
        operator delete(__p);
      }
      if (v55)
      {
        int v8 = v54;
        id v9 = v53;
LABEL_22:
        sub_10026CF54((uint64_t)v9, v8);
        return;
      }
      return;
    }
    uint64_t v14 = a1 + 96;
    sub_10050DC8C((void *)(a1 + 96));
    uint64_t v15 = *v4;
    if (*v4)
    {
      if (v15 == a3)
      {
        *long long v6 = v14;
        (*(void (**)(uint64_t, uint64_t))(*(void *)*v4 + 24))(*v4, a1 + 96);
LABEL_30:
        std::string::operator=((std::string *)(a1 + 128), (const std::string *)a2);
        if (a1 + 128 != a2)
        {
          sub_10006E4A8((void *)(a1 + 152), *(char **)(a2 + 24), *(char **)(a2 + 32), *(void *)(a2 + 32) - *(void *)(a2 + 24));
          sub_10006E4A8((void *)(a1 + 176), *(char **)(a2 + 48), *(char **)(a2 + 56), *(void *)(a2 + 56) - *(void *)(a2 + 48));
          sub_10006E4A8((void *)(a1 + 200), *(char **)(a2 + 72), *(char **)(a2 + 80), *(void *)(a2 + 80) - *(void *)(a2 + 72));
        }
        (***(void (****)(void **__return_ptr))(a1 + 48))(&keys);
        ServiceMap = (std::mutex *)Registry::getServiceMap((Registry *)keys);
        unint64_t v17 = ServiceMap;
        if (v18 < 0)
        {
          uint64_t v19 = (unsigned __int8 *)(v18 & 0x7FFFFFFFFFFFFFFFLL);
          uint64_t v20 = 5381;
          do
          {
            uint64_t v18 = v20;
            unsigned int v21 = *v19++;
            uint64_t v20 = (33 * v20) ^ v21;
          }
          while (v21);
        }
        std::mutex::lock(ServiceMap);
        values = (void *)v18;
        uint64_t v22 = sub_10004D37C(&v17[1].__m_.__sig, (unint64_t *)&values);
        if (v22)
        {
          uint64_t v24 = v22[3];
          char v23 = (std::__shared_weak_count *)v22[4];
          if (v23)
          {
            atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
            std::mutex::unlock(v17);
            atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
            sub_10004D2C8(v23);
            char v25 = 0;
            goto LABEL_40;
          }
        }
        else
        {
          uint64_t v24 = 0;
        }
        std::mutex::unlock(v17);
        char v23 = 0;
        char v25 = 1;
LABEL_40:
        if (v96) {
          sub_10004D2C8((std::__shared_weak_count *)v96);
        }
        if (!v24)
        {
          unsigned int v37 = sub_100200FB4((id *)(a1 + 40));
          if (os_log_type_enabled(v37, OS_LOG_TYPE_FAULT))
          {
            LOWORD(keys) = 0;
            _os_log_fault_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_FAULT, "No vinyl controller", (uint8_t *)&keys, 2u);
          }

          LOBYTE(keys) = 0;
          LOBYTE(p_keys) = 0;
          values = 0;
          long long v89 = 0;
          CFBooleanRef v90 = 0;
          sub_10050C988(a1, (uint64_t)&keys, (uint64_t)&values, 1);
          if ((_BYTE)p_keys) {
            sub_10026CF54((uint64_t)&keys, v96);
          }
          goto LABEL_101;
        }
        uint64_t v68 = 0;
        int v69 = 0;
        uint64_t v70 = 0;
        int v65 = 0;
        uint64_t v66 = 0;
        uint64_t v67 = 0;
        uint64_t v26 = *(void *)(a1 + 224);
        if (v26) {
          char v27 = sub_10008324C;
        }
        else {
          char v27 = 0;
        }
        if (!v27 || !v26)
        {
          uint64_t v38 = sub_100200FB4((id *)(a1 + 40));
          if (os_log_type_enabled(v38, OS_LOG_TYPE_ERROR))
          {
            LOWORD(keys) = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_ERROR, "no context available to sign", (uint8_t *)&keys, 2u);
          }

          LOBYTE(v36) = 6;
          goto LABEL_92;
        }
        id v28 = [objc_alloc((Class)sub_10050B180()) initWithExternalizedContext:*(void *)(a1 + 224)];
        objc_storeStrong((id *)(a1 + 232), v28);
        keys = (void *)kSecClass;
        long long v96 = (__CFString *)kSecAttrLabel;
        CFStringRef v97 = kSecUseDataProtectionKeychain;
        CFStringRef p_keys = kSecReturnRef;
        uint64_t v99 = kSecUseSystemKeychain;
        CFStringRef v100 = kSecAttrAccessGroup;
        CFStringRef v101 = kSecUseAuthenticationContext;
        values = (void *)kSecClassKey;
        long long v89 = @"euicc-rk-ucrt";
        CFBooleanRef v90 = kCFBooleanTrue;
        CFBooleanRef v91 = kCFBooleanTrue;
        CFBooleanRef v92 = kCFBooleanTrue;
        CFStringRef v93 = @"com.apple.coretelephony";
        id v94 = v28;
        CFDictionaryRef v29 = CFDictionaryCreate(0, (const void **)&keys, (const void **)&values, 7, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
        CFDictionaryRef v84 = v29;
        if (v29) {
          uint64_t v30 = sub_100080778;
        }
        else {
          uint64_t v30 = 0;
        }
        if (v30)
        {
          CFTypeRef result = 0;
          OSStatus v31 = SecItemCopyMatching(v29, &result);
          if (result)
          {
            if (sub_1003F1B5C(a1 + 128, a1 + 176, a1 + 152, (const void **)(a1 + 200), &v68))
            {
              *(void *)long long buf = 0;
              long long v86 = 0;
              uint64_t v87 = 0;
              xpc_object_t v80 = 0;
              char v81 = 0;
              uint64_t v82 = 0;
              sub_1001E7940(&v80, "SEPSIGNED31SecureIntentControllerInterface", (uint64_t)"31SecureIntentControllerInterface", 9uLL);
              sub_10005C748((uint64_t)buf, v86, (char *)v80, v81, v81 - (unsigned char *)v80);
              sub_10005C748((uint64_t)buf, v86, (char *)v68, v69, v69 - (unsigned char *)v68);
              md = 0;
              xpc_object_t v78 = 0;
              uint64_t v79 = 0;
              sub_10008E4E8(&md, 0x20uLL);
              if (CC_SHA256(*(const void **)buf, (int)v86 - *(_DWORD *)buf, md))
              {
                CFDataRef v76 = 0;
                CFDataRef v32 = CFDataCreate(kCFAllocatorDefault, md, v78 - md);
                CFErrorRef error = 0;
                CFDataRef v76 = v32;
                CFDataRef theData = 0;
                CFDataRef v33 = SecKeyCreateSignature((SecKeyRef)result, kSecKeyAlgorithmECDSASignatureRFC4754, v32, &error);
                CFDataRef theData = v33;
                if (error)
                {
                  uint64_t v34 = sub_100200FB4((id *)(a1 + 40));
                  if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
                  {
                    *(_WORD *)int v71 = 0;
                    _os_log_error_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_ERROR, "signing failed", v71, 2u);
                  }

                  int v35 = 1;
                  int v36 = 4;
                }
                else
                {
                  *(void *)int v71 = 0;
                  int v72 = 0;
                  uint64_t v73 = 0;
                  BytePtr = (char *)CFDataGetBytePtr(v33);
                  CFIndex Length = CFDataGetLength(theData);
                  sub_10006E4A8(v71, BytePtr, &BytePtr[Length], Length);
                  int v45 = sub_1003F18E0((uint64_t)v71, &v65);
                  if (v45) {
                    int v36 = 0;
                  }
                  else {
                    int v36 = 6;
                  }
                  int v35 = v45 ^ 1;
                  if (*(void *)v71)
                  {
                    int v72 = *(void **)v71;
                    operator delete(*(void **)v71);
                  }
                }
                sub_100030068((const void **)&theData);
                sub_100030068((const void **)&v76);
              }
              else
              {
                uint64_t v42 = sub_100200FB4((id *)(a1 + 40));
                if (os_log_type_enabled(v42, OS_LOG_TYPE_ERROR))
                {
                  *(_WORD *)int v71 = 0;
                  _os_log_error_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_ERROR, "sha256 digest failed", v71, 2u);
                }

                int v35 = 1;
                int v36 = 6;
              }
              if (md)
              {
                xpc_object_t v78 = md;
                operator delete(md);
              }
              if (v80)
              {
                char v81 = (char *)v80;
                operator delete(v80);
              }
              if (*(void *)buf)
              {
                long long v86 = *(char **)buf;
                operator delete(*(void **)buf);
              }
            }
            else
            {
              int v35 = 1;
              int v36 = 6;
            }
            goto LABEL_89;
          }
          OSStatus v40 = v31;
          unint64_t v41 = sub_100200FB4((id *)(a1 + 40));
          if (os_log_type_enabled(v41, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)long long buf = 67109120;
            *(_DWORD *)&uint8_t buf[4] = v40;
            _os_log_error_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_ERROR, "No key : euicc-rk-ucrt key ! status: %d", buf, 8u);
          }
        }
        else
        {
          char v39 = sub_100200FB4((id *)(a1 + 40));
          if (os_log_type_enabled(v39, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)long long buf = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_ERROR, "No query for key : euicc-rk-ucrt key !", buf, 2u);
          }
        }
        int v35 = 1;
        int v36 = 4;
LABEL_89:
        sub_100057D78((const void **)&v84);

        if (!v35)
        {
          unsigned int v47 = sub_100200FB4((id *)(a1 + 40));
          if (os_log_type_enabled(v47, OS_LOG_TYPE_DEFAULT))
          {
            LOWORD(keys) = 0;
            _os_log_impl((void *)&_mh_execute_header, v47, OS_LOG_TYPE_DEFAULT, "#I request baseband signing...", (uint8_t *)&keys, 2u);
          }

          uint64_t v48 = *(std::__shared_weak_count **)(a1 + 16);
          if (!v48 || (v49 = *(char **)(a1 + 8), (uint64_t v50 = std::__shared_weak_count::lock(v48)) == 0)) {
            sub_100088B9C();
          }
          char v51 = v50;
          atomic_fetch_add_explicit(&v50->__shared_weak_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v50);
          CFStringRef p_keys = 0;
          long long v52 = (__CFString *)operator new(0x20uLL);
          v52->isa = off_1019DD228;
          v52->info = a1;
          v52->uint64_t data = v49;
          v52->length = (uint64_t)v51;
          CFStringRef p_keys = v52;
          (*(void (**)(uint64_t, void **, void **, void **))(*(void *)v24 + 64))(v24, &v68, &v65, &keys);
          sub_100491448(&keys);
          goto LABEL_97;
        }
        if (v36 == 4)
        {
          keys = off_1019DD1A8;
          CFStringRef p_keys = (CFStringRef)&keys;
          (*(void (**)(uint64_t, void **))(*(void *)v24 + 72))(v24, &keys);
          sub_10001E914(&keys);
          LOBYTE(v36) = 4;
        }
LABEL_92:
        LOBYTE(values) = 0;
        LOBYTE(v91) = 0;
        *(void *)long long buf = 0;
        long long v86 = 0;
        uint64_t v87 = 0;
        sub_10050C988(a1, (uint64_t)&values, (uint64_t)buf, v36);
        if ((_BYTE)v91) {
          sub_10026CF54((uint64_t)&values, v89);
        }
        uint64_t v46 = sub_100200FB4((id *)(a1 + 40));
        if (os_log_type_enabled(v46, OS_LOG_TYPE_ERROR))
        {
          LOWORD(values) = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v46, OS_LOG_TYPE_ERROR, "signing data failed", (uint8_t *)&values, 2u);
        }

LABEL_97:
        if (v65)
        {
          uint64_t v66 = v65;
          operator delete(v65);
        }
        if (v68)
        {
          int v69 = (char *)v68;
          operator delete(v68);
        }
LABEL_101:
        if ((v25 & 1) == 0) {
          sub_10004D2C8(v23);
        }
        return;
      }
      *long long v6 = v15;
    }
    else
    {
      id v4 = (uint64_t *)(a1 + 120);
    }
    uint64_t *v4 = 0;
    goto LABEL_30;
  }
  id v11 = sub_100200FB4((id *)(a1 + 40));
  if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
  {
    LOWORD(keys) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "invalid LAContext", (uint8_t *)&keys, 2u);
  }

  v59[0] = 0;
  char v61 = 0;
  char v63 = 0;
  uint64_t v64 = 0;
  uint64_t v62 = 0;
  sub_10050C5D4(*v4, (uint64_t)v59, 4);
  if (v62)
  {
    char v63 = v62;
    operator delete(v62);
  }
  if (v61)
  {
    int v8 = v60;
    id v9 = v59;
    goto LABEL_22;
  }
}

void sub_10050C424(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *a23,uint64_t a24,uint64_t a25,void *a26,uint64_t a27,uint64_t a28,void *a29,uint64_t a30,uint64_t a31,char a32,uint64_t a33,char a34,void *__p,uint64_t a36,uint64_t a37,void *a38,uint64_t a39)
{
  if (__p) {
    operator delete(__p);
  }
  if (a38) {
    operator delete(a38);
  }
  __int16 v44 = *(void **)(v42 - 224);
  if (v44)
  {
    *(void *)(v42 - 216) = v44;
    operator delete(v44);
  }
  sub_100057D78((const void **)(v42 - 232));

  if (a23) {
    operator delete(a23);
  }
  if (a26) {
    operator delete(a26);
  }
  if ((v41 & 1) == 0) {
    sub_10004D2C8(v39);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_10050C5D4(uint64_t a1, uint64_t a2, char a3)
{
  char v4 = a3;
  if (!a1) {
    sub_10007B600();
  }
  return (*(uint64_t (**)(uint64_t, uint64_t, char *))(*(void *)a1 + 48))(a1, a2, &v4);
}

uint64_t sub_10050C624(uint64_t a1)
{
  id v2 = *(void **)(a1 + 32);
  if (v2)
  {
    *(void *)(a1 + 40) = v2;
    operator delete(v2);
  }
  if (*(unsigned char *)(a1 + 24)) {
    sub_10026CF54(a1, *(void **)(a1 + 8));
  }
  return a1;
}

void *sub_10050C66C(uint64_t a1, const void **a2)
{
  if (*a2) {
    long long v3 = sub_10008324C;
  }
  else {
    long long v3 = 0;
  }
  if (v3)
  {
    sub_1003C5CD0((const void **)(a1 + 224), a2);
    char v4 = 0;
  }
  else
  {
    long long v5 = sub_100200FB4((id *)(a1 + 40));
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v8) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "invalid context", (uint8_t *)&v8, 2u);
    }

    char v4 = 48;
  }
  long long v8 = 0u;
  long long v9 = 0u;
  long long v6 = (void *)(a1 + 64);
  sub_10032CA08((uint64_t)&v8, (uint64_t)v6);
  if (*((void *)&v9 + 1))
  {
    sub_10050D3C8(v6);
    sub_10024924C((uint64_t)&v8, v4);
  }
  return sub_100313668(&v8);
}

void sub_10050C77C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_10050C798(uint64_t a1)
{
  if (*(char *)(a1 + 63) < 0) {
    operator delete(*(void **)(a1 + 40));
  }
  id v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_10050C7D8(uint64_t *a1)
{
  uint64_t v2 = *a1;
  v13[0] = &off_101AE63A0;
  v12[0] = @"FlowTypeKey";
  v12[1] = @"ExternalizedContextKey";
  long long v3 = [*(id *)(v2 + 232) externalizedContext];
  v13[1] = v3;
  char v4 = &__kCFBooleanFalse;
  if (*((unsigned char *)a1 + 8)) {
    char v4 = &__kCFBooleanTrue;
  }
  v13[2] = v4;
  v12[2] = @"LocalConversionOngoing";
  v12[3] = @"PlanDescriptorKey";
  long long v5 = a1 + 2;
  if (*((char *)a1 + 39) < 0) {
    long long v5 = (void *)*v5;
  }
  long long v6 = +[NSString stringWithUTF8String:v5];
  v13[3] = v6;
  id v7 = +[NSDictionary dictionaryWithObjects:v13 forKeys:v12 count:4];

  long long v8 = objc_alloc_init(SecureIntentRemoteAlertObserver);
  long long v9 = *(void **)(v2 + 248);
  *(void *)(v2 + 248) = v8;

  [*(id *)(v2 + 240) invalidate];
  uint64_t v10 = +[RemoteUILaunchHelper launchRemoteUI:@"com.apple.SIMSetupUIService" viewController:@"TSSIMSetupSupportViewController" reason:@"secure intent gesture" userInfo:v7 observer:*(void *)(v2 + 248)];
  id v11 = *(void **)(v2 + 240);
  *(void *)(v2 + 240) = v10;
}

void sub_10050C954(_Unwind_Exception *a1)
{
  long long v3 = v2;

  _Unwind_Resume(a1);
}

void sub_10050C988(uint64_t a1, uint64_t a2, uint64_t a3, char a4)
{
  uint64_t v25 = 0;
  long long v23 = 0u;
  *(_OWORD *)uint64_t v24 = 0u;
  long long v22 = 0u;
  sub_10050CEA4((uint64_t)&v22, a2);
  v24[0] = 0;
  v24[1] = 0;
  uint64_t v25 = 0;
  sub_10005C928(v24, *(const void **)a3, *(void *)(a3 + 8), *(void *)(a3 + 8) - *(void *)a3);
  if (*(void *)(a1 + 120))
  {
    sub_10050CEA4((uint64_t)v16, (uint64_t)&v22);
    long long __p = 0;
    uint64_t v20 = 0;
    uint64_t v21 = 0;
    sub_10005C928(&__p, v24[0], (uint64_t)v24[1], (char *)v24[1] - (char *)v24[0]);
    sub_10050C5D4(*(void *)(a1 + 120), (uint64_t)v16, a4);
    if (__p)
    {
      uint64_t v20 = __p;
      operator delete(__p);
    }
    if (v18) {
      sub_10026CF54((uint64_t)v16, v17);
    }
    sub_10050DC8C((void *)(a1 + 96));
    id v7 = (void **)(a1 + 128);
    if (*(char *)(a1 + 151) < 0) {
      operator delete(*v7);
    }
    long long v9 = (void *)(a1 + 152);
    long long v8 = *(void **)(a1 + 152);
    *id v7 = 0;
    *(void *)(a1 + 136) = 0;
    *(void *)(a1 + 144) = 0;
    if (v8)
    {
      *(void *)(a1 + 160) = v8;
      operator delete(v8);
      *long long v9 = 0;
      *(void *)(a1 + 160) = 0;
      *(void *)(a1 + 168) = 0;
    }
    id v11 = (void *)(a1 + 176);
    uint64_t v10 = *(void **)(a1 + 176);
    *long long v9 = 0;
    *(void *)(a1 + 160) = 0;
    *(void *)(a1 + 168) = 0;
    if (v10)
    {
      *(void *)(a1 + 184) = v10;
      operator delete(v10);
      void *v11 = 0;
      *(void *)(a1 + 184) = 0;
      *(void *)(a1 + 192) = 0;
    }
    uint64_t v13 = (void *)(a1 + 200);
    uint64_t v12 = *(void **)(a1 + 200);
    void *v11 = 0;
    *(void *)(a1 + 184) = 0;
    *(void *)(a1 + 192) = 0;
    if (v12)
    {
      *(void *)(a1 + 208) = v12;
      operator delete(v12);
      void *v13 = 0;
      *(void *)(a1 + 208) = 0;
      *(void *)(a1 + 216) = 0;
    }
    void *v13 = 0;
    *(void *)(a1 + 208) = 0;
    *(void *)(a1 + 216) = 0;
  }
  else
  {
    uint64_t v14 = sub_100200FB4((id *)(a1 + 40));
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t v15 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "missing entitlement response callback", v15, 2u);
    }
  }
  if (v24[0])
  {
    v24[1] = v24[0];
    operator delete(v24[0]);
  }
  if (BYTE8(v23)) {
    sub_10026CF54((uint64_t)&v22, *((void **)&v22 + 1));
  }
}

void sub_10050CB64(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  sub_10050C624((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_10050CBA8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, void *a18, uint64_t a19, char a20)
{
  if (a20) {
    sub_10026CF54((uint64_t)&a17, a18);
  }
  JUMPOUT(0x10050CBA0);
}

void sub_10050CBC8(uint64_t a1)
{
  sub_10050CF08(a1);

  operator delete();
}

Class sub_10050CC00(uint64_t a1)
{
  v7[0] = 0;
  if (!qword_101B0D130)
  {
    v7[1] = _NSConcreteStackBlock;
    v7[2] = (void *)3221225472;
    double v7[3] = sub_10050CE30;
    void v7[4] = &unk_1019A1BF8;
    v7[5] = v7;
    long long v8 = off_1019DD030;
    uint64_t v9 = 0;
    qword_101B0D130 = _sl_dlopen();
  }
  if (!qword_101B0D130)
  {
    long long v3 = +[NSAssertionHandler currentHandler];
    char v4 = +[NSString stringWithUTF8String:"void *LocalAuthenticationLibrary()"];
    objc_msgSend(v3, "handleFailureInFunction:file:lineNumber:description:", v4, @"SecureIntentController.mm", 27, @"%s", v7[0]);

    goto LABEL_10;
  }
  if (v7[0]) {
    free(v7[0]);
  }
  Class result = objc_getClass("LAContext");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  if (!*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24))
  {
    long long v5 = +[NSAssertionHandler currentHandler];
    long long v6 = +[NSString stringWithUTF8String:"Class getLAContextClass()_block_invoke"];
    objc_msgSend(v5, "handleFailureInFunction:file:lineNumber:description:", v6, @"SecureIntentController.mm", 28, @"Unable to find class %s", "LAContext");

LABEL_10:
    __break(1u);
  }
  qword_101B0D128 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void sub_10050CDEC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

uint64_t sub_10050CE30()
{
  uint64_t result = _sl_dlopen();
  qword_101B0D130 = result;
  return result;
}

uint64_t sub_10050CEA4(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)a1 = 0;
  *(unsigned char *)(a1 + 24) = 0;
  if (*(unsigned char *)(a2 + 24))
  {
    sub_10026E7F8((uint64_t *)a1, a2);
    *(unsigned char *)(a1 + 24) = 1;
  }
  return a1;
}

void sub_10050CEE8(_Unwind_Exception *exception_object)
{
  if (*(unsigned char *)(v1 + 24)) {
    sub_10026CF54(v1, *(void **)(v1 + 8));
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10050CF08(uint64_t a1)
{
  *(void *)a1 = off_1019DCE80;

  sub_100030068((const void **)(a1 + 224));
  uint64_t v2 = *(void **)(a1 + 200);
  if (v2)
  {
    *(void *)(a1 + 208) = v2;
    operator delete(v2);
  }
  long long v3 = *(void **)(a1 + 176);
  if (v3)
  {
    *(void *)(a1 + 184) = v3;
    operator delete(v3);
  }
  char v4 = *(void **)(a1 + 152);
  if (v4)
  {
    *(void *)(a1 + 160) = v4;
    operator delete(v4);
  }
  if (*(char *)(a1 + 151) < 0) {
    operator delete(*(void **)(a1 + 128));
  }
  sub_10050D2AC((void *)(a1 + 96));
  sub_100313668((void *)(a1 + 64));
  long long v5 = *(std::__shared_weak_count **)(a1 + 56);
  if (v5) {
    sub_10004D2C8(v5);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 40));
  sub_1004FDE68(a1 + 8);
  return a1;
}

void sub_10050CFD8(uint64_t *a1@<X1>, id *a2@<X2>, void *a3@<X8>)
{
  long long v6 = operator new(0x118uLL);
  sub_10050D054(v6, a1, a2);
  *a3 = v6 + 3;
  a3[1] = v6;

  sub_1000B3BC8((uint64_t)a3, v6 + 4, (uint64_t)(v6 + 3));
}

void sub_10050D040(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_10050D054(void *a1, uint64_t *a2, id *a3)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = off_1019DD058;
  sub_10050D14C((uint64_t)(a1 + 3), a2, a3);
  return a1;
}

void sub_10050D09C(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void sub_10050D0B0(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1019DD058;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_10050D0D0(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1019DD058;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_10050D124(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

uint64_t sub_10050D14C(uint64_t a1, uint64_t *a2, id *a3)
{
  uint64_t v5 = *a2;
  char v4 = (std::__shared_weak_count *)a2[1];
  if (v4) {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  id v6 = *a3;
  *(void *)a1 = off_1019DCF08;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  id v7 = v6;
  *(void *)(a1 + 24) = v7;
  *(void *)(a1 + 32) = 0;
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 40), kCtLoggingSystemName, "cp.si.ctr");
  *(void *)a1 = off_1019DCE80;
  *(void *)(a1 + 48) = v5;
  *(void *)(a1 + 56) = v4;
  if (v4)
  {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
    *(void *)(a1 + 88) = 0;
    *(_OWORD *)(a1 + 120) = 0u;
    *(_OWORD *)(a1 + 136) = 0u;
    *(_OWORD *)(a1 + 152) = 0u;
    *(_OWORD *)(a1 + 168) = 0u;
    *(_OWORD *)(a1 + 184) = 0u;
    *(_OWORD *)(a1 + 200) = 0u;
    *(_OWORD *)(a1 + 216) = 0u;
    *(_OWORD *)(a1 + 232) = 0u;
    *(void *)(a1 + 248) = 0;

    sub_10004D2C8(v4);
  }
  else
  {
    *(void *)(a1 + 88) = 0;
    *(_OWORD *)(a1 + 120) = 0u;
    *(_OWORD *)(a1 + 136) = 0u;
    *(_OWORD *)(a1 + 152) = 0u;
    *(_OWORD *)(a1 + 168) = 0u;
    *(_OWORD *)(a1 + 184) = 0u;
    *(_OWORD *)(a1 + 200) = 0u;
    *(_OWORD *)(a1 + 216) = 0u;
    *(_OWORD *)(a1 + 232) = 0u;
    *(void *)(a1 + 248) = 0;
  }
  return a1;
}

void sub_10050D288(_Unwind_Exception *a1)
{
  sub_1004FDE68(v3);

  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(a1);
}

void *sub_10050D2AC(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void sub_10050D330(uint64_t **a1)
{
  uint64_t v2 = a1;
  uint64_t v1 = **a1;
  uint64_t v3 = 0;
  sub_10050C66C(v1, &v3);
  sub_100030068(&v3);
  operator delete();
}

void sub_10050D394(uint64_t a1, ...)
{
  va_start(va, a1);
  sub_100030068((const void **)va);
  operator delete();
}

void *sub_10050D3C8(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  a1[3] = 0;
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t sub_10050D450(uint64_t a1)
{
  *(void *)a1 = off_1019DD0A8;
  if (*(char *)(a1 + 47) < 0) {
    operator delete(*(void **)(a1 + 24));
  }
  return a1;
}

void sub_10050D4A0(uint64_t a1)
{
  *(void *)a1 = off_1019DD0A8;
  if (*(char *)(a1 + 47) < 0) {
    operator delete(*(void **)(a1 + 24));
  }

  operator delete();
}

char *sub_10050D510(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x30uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *(void *)uint64_t v2 = off_1019DD0A8;
  *((void *)v2 + 1) = v3;
  uint8_t v2[16] = *(unsigned char *)(a1 + 16);
  char v4 = v2 + 24;
  if (*(char *)(a1 + 47) < 0)
  {
    sub_10004FC84(v4, *(void **)(a1 + 24), *(void *)(a1 + 32));
  }
  else
  {
    *(_OWORD *)char v4 = *(_OWORD *)(a1 + 24);
    *((void *)v2 + 5) = *(void *)(a1 + 40);
  }
  return v2;
}

void sub_10050D594(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

char *sub_10050D5A8(char *result, uint64_t a2)
{
  *(void *)a2 = off_1019DD0A8;
  uint64_t v2 = *((void *)result + 1);
  *(unsigned char *)(a2 + 16) = result[16];
  *(void *)(a2 + 8) = v2;
  uint64_t v3 = (unsigned char *)(a2 + 24);
  if (result[47] < 0) {
    return (char *)sub_10004FC84(v3, *((void **)result + 3), *((void *)result + 4));
  }
  long long v4 = *(_OWORD *)(result + 24);
  *(void *)(a2 + 40) = *((void *)result + 5);
  *(_OWORD *)uint64_t v3 = v4;
  return result;
}

void sub_10050D604(uint64_t a1)
{
  if (*(char *)(a1 + 47) < 0) {
    operator delete(*(void **)(a1 + 24));
  }
}

void sub_10050D618(void **__p)
{
  if (*((char *)__p + 47) < 0) {
    operator delete(__p[3]);
  }

  operator delete(__p);
}

void sub_10050D65C(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void **)a2;
  uint64_t v4 = *(void *)(a2 + 8);
  uint64_t v5 = *(unsigned __int8 *)(a2 + 23);
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  uint64_t v6 = *(void *)(a1 + 8);
  id v7 = sub_100200FB4((id *)(v6 + 40));
  long long v8 = v7;
  if ((v5 & 0x80u) == 0) {
    uint64_t v9 = v5;
  }
  else {
    uint64_t v9 = v4;
  }
  if (v9)
  {
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I perform secure intent gesture", buf, 2u);
    }

    int v10 = *(unsigned __int8 *)(a1 + 16);
    id v11 = (_OWORD *)(a1 + 24);
    memset(&v31[1], 0, 32);
    v31[0] = v6;
    LOBYTE(v31[1]) = v10;
    if (*(char *)(a1 + 47) < 0)
    {
      sub_10004FC84(&v31[2], *(void **)(a1 + 24), *(void *)(a1 + 32));
    }
    else
    {
      *(_OWORD *)&v31[2] = *v11;
      void v31[4] = *(void *)(a1 + 40);
    }
    uint64_t v29 = 0;
    uint64_t v30 = 0;
    (***(void (****)(Registry **__return_ptr))(v6 + 48))(&v37);
    Registry::getNotificationSenderFactory((uint64_t *)buf, v37);
    uint64_t v12 = *(void *)buf;
    (***(void (****)(CFTypeRef *__return_ptr))(v6 + 48))(&cf);
    Registry::getTimerService(&v27, (Registry *)cf);
    (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t *, uint64_t))(*(void *)v12 + 160))(&v29, v12, &v27, v6 + 24);
    if (v28) {
      sub_10004D2C8(v28);
    }
    if (v26) {
      sub_10004D2C8(v26);
    }
    if (*(void *)&buf[8]) {
      sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
    }
    if (v38) {
      sub_10004D2C8(v38);
    }
    if (v29)
    {
      CFTypeRef cf = 0;
      uint64_t v13 = [*(id *)(v6 + 232) externalizedContext];
      uint64_t v14 = v13;
      CFTypeRef cf = v13;
      if (v13) {
        CFRetain(v13);
      }

      uint64_t v15 = v29;
      CFTypeRef v24 = cf;
      if (cf) {
        CFRetain(cf);
      }
      *(void *)long long buf = v6;
      id v16 = *(std::__shared_weak_count **)(v6 + 16);
      if (!v16 || (v17 = *(void *)(v6 + 8), (char v18 = std::__shared_weak_count::lock(v16)) == 0)) {
        sub_100088B9C();
      }
      *(void *)&uint8_t buf[8] = v17;
      v33[0] = v18;
      atomic_fetch_add_explicit(&v18->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v18);
      v33[1] = (std::__shared_weak_count *)v31[0];
      char v34 = v31[1];
      if (SHIBYTE(v31[4]) < 0)
      {
        sub_10004FC84(&__p, (void *)v31[2], v31[3]);
      }
      else
      {
        long long __p = *(_OWORD *)&v31[2];
        uint64_t v36 = v31[4];
      }
      char v39 = 0;
      uint64_t v20 = (char *)operator new(0x48uLL);
      *(void *)uint64_t v20 = off_1019DD128;
      *(_OWORD *)(v20 + 8) = *(_OWORD *)buf;
      uint64_t v21 = v33[0];
      *(void *)&uint8_t buf[8] = 0;
      v33[0] = 0;
      long long v22 = v33[1];
      *((void *)v20 + 3) = v21;
      *((void *)v20 + 4) = v22;
      v20[40] = v34;
      long long v23 = v20 + 48;
      if (SHIBYTE(v36) < 0)
      {
        sub_10004FC84(v23, (void *)__p, *((unint64_t *)&__p + 1));
      }
      else
      {
        *(_OWORD *)long long v23 = __p;
        *((void *)v20 + 8) = v36;
      }
      char v39 = v20;
      (*(void (**)(uint64_t, BOOL, _OWORD *, CFTypeRef *, Registry **))(*(void *)v15 + 24))(v15, v10 != 0, v11, &v24, &v37);
      sub_100060644(&v37);
      if (SHIBYTE(v36) < 0) {
        operator delete((void *)__p);
      }
      if (v33[0]) {
        std::__shared_weak_count::__release_weak(v33[0]);
      }
      sub_100030068(&v24);
      sub_100030068(&cf);
    }
    else
    {
      uint64_t v19 = sub_100200FB4((id *)(v6 + 40));
      if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#I launchSecureIntentUI delegate does not exists", buf, 2u);
      }

      sub_10050C7D8(v31);
    }
    if (v30) {
      sub_10004D2C8(v30);
    }
    if ((SHIBYTE(v31[4]) & 0x80000000) == 0)
    {
      if ((v5 & 0x80) == 0) {
        return;
      }
      goto LABEL_49;
    }
    operator delete((void *)v31[2]);
    if ((v5 & 0x80) != 0) {
LABEL_49:
    }
      operator delete(v3);
  }
  else
  {
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "secureIntent token error", buf, 2u);
    }

    *(_OWORD *)long long buf = 0u;
    *(_OWORD *)CFDataRef v33 = 0u;
    sub_10032CA08((uint64_t)buf, v6 + 64);
    if (v33[1])
    {
      sub_10050D3C8((void *)(v6 + 64));
      sub_10024924C((uint64_t)buf, 13);
    }
    sub_100313668(buf);
    if ((v5 & 0x80) != 0) {
      goto LABEL_49;
    }
  }
}

void sub_10050DB14(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, const void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, std::__shared_weak_count *a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23,char a24,uint64_t a25,std::__shared_weak_count *a26)
{
  uint64_t v30 = (std::__shared_weak_count *)v27[3];
  if (v30) {
    std::__shared_weak_count::__release_weak(v30);
  }
  operator delete(v27);
  sub_10050C798((uint64_t)&a24);
  sub_100030068((const void **)&a9);
  sub_100030068(&a10);
  if (a15) {
    sub_10004D2C8(a15);
  }
  if (a23 < 0) {
    operator delete(__p);
  }
  if (v28 < 0) {
    operator delete(v26);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_10050DC40(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10050DC80()
{
}

void *sub_10050DC8C(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  a1[3] = 0;
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t sub_10050DD14(uint64_t a1)
{
  *(void *)a1 = off_1019DD128;
  if (*(char *)(a1 + 71) < 0) {
    operator delete(*(void **)(a1 + 48));
  }
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 24);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_10050DD70(uint64_t a1)
{
  *(void *)a1 = off_1019DD128;
  if (*(char *)(a1 + 71) < 0) {
    operator delete(*(void **)(a1 + 48));
  }
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 24);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete();
}

void *sub_10050DDEC(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t v2 = operator new(0x48uLL);
  void *v2 = off_1019DD128;
  sub_10050DFD8((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_10050DE40(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_10050DE54(uint64_t a1, void *a2)
{
  *a2 = off_1019DD128;
  return sub_10050DFD8((uint64_t)(a2 + 1), a1 + 8);
}

void sub_10050DE80(uint64_t a1)
{
}

void sub_10050DE88(void *a1)
{
  sub_10050E074((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_10050DEC4(void *a1, unsigned __int8 *a2)
{
  uint64_t v3 = (std::__shared_weak_count *)a1[3];
  if (v3)
  {
    int v4 = *a2;
    uint64_t v5 = a1[1];
    uint64_t v6 = std::__shared_weak_count::lock(v3);
    if (v6)
    {
      id v7 = v6;
      if (!v4 && a1[2])
      {
        long long v8 = sub_100200FB4((id *)(v5 + 40));
        if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)uint64_t v9 = 0;
          _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I secure intent not launched with SIMSetupUIService", v9, 2u);
        }

        sub_10050C7D8(a1 + 4);
      }
      sub_10004D2C8(v7);
    }
  }
}

void sub_10050DF74(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_10050DF8C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10050DFCC()
{
}

uint64_t sub_10050DFD8(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = *(_OWORD *)a2;
  uint64_t v3 = *(void *)(a2 + 16);
  *(void *)(a1 + 16) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  uint64_t v4 = *(void *)(a2 + 24);
  *(unsigned char *)(a1 + 32) = *(unsigned char *)(a2 + 32);
  *(void *)(a1 + 24) = v4;
  uint64_t v5 = (unsigned char *)(a1 + 40);
  if (*(char *)(a2 + 63) < 0)
  {
    sub_10004FC84(v5, *(void **)(a2 + 40), *(void *)(a2 + 48));
  }
  else
  {
    long long v6 = *(_OWORD *)(a2 + 40);
    *(void *)(a1 + 56) = *(void *)(a2 + 56);
    *(_OWORD *)uint64_t v5 = v6;
  }
  return a1;
}

void sub_10050E05C(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(std::__shared_weak_count **)(v1 + 16);
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  _Unwind_Resume(exception_object);
}

void sub_10050E074(uint64_t a1)
{
  if (*(char *)(a1 + 63) < 0) {
    operator delete(*(void **)(a1 + 40));
  }
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2)
  {
    std::__shared_weak_count::__release_weak(v2);
  }
}

void sub_10050E0CC()
{
}

void *sub_10050E0E0()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = off_1019DD1A8;
  return result;
}

void sub_10050E118(uint64_t a1, void *a2)
{
  *a2 = off_1019DD1A8;
}

void sub_10050E140(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void **)a2;
  int v3 = *(char *)(a2 + 23);
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  if (v3 < 0) {
    operator delete(v2);
  }
}

uint64_t sub_10050E15C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10050E19C()
{
}

void *sub_10050E1A8(void *a1)
{
  *a1 = off_1019DD228;
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_10050E1F4(void *a1)
{
  *a1 = off_1019DD228;
  uint64_t v1 = (std::__shared_weak_count *)a1[3];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

char *sub_10050E260(uint64_t a1)
{
  uint64_t result = (char *)operator new(0x20uLL);
  *(void *)uint64_t result = off_1019DD228;
  *(_OWORD *)(result + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 24);
  *((void *)result + 3) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_10050E2C4(uint64_t result, uint64_t a2)
{
  *(void *)a2 = off_1019DD228;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(result + 8);
  uint64_t v2 = *(void *)(result + 24);
  *(void *)(a2 + 24) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_10050E304(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 24);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_10050E314(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete(__p);
}

void sub_10050E354(void *a1, uint64_t a2, long long *a3, unsigned __int16 *a4)
{
  LOBYTE(v19) = 0;
  char v22 = 0;
  if (*(unsigned char *)(a2 + 24))
  {
    uint64_t v5 = (void *)(a2 + 8);
    long long v6 = *(void **)(a2 + 8);
    uint64_t v19 = *(void ***)a2;
    uint64_t v20 = v6;
    if (*(void *)(a2 + 16))
    {
      void v6[2] = &v20;
      *(void *)a2 = v5;
      void *v5 = 0;
      *(void *)(a2 + 16) = 0;
    }
    else
    {
      uint64_t v19 = &v20;
    }
    char v22 = 1;
  }
  long long v16 = *a3;
  long long v17 = *a3;
  uint64_t v18 = *((void *)a3 + 2);
  *(void *)a3 = 0;
  *((void *)a3 + 1) = 0;
  *((void *)a3 + 2) = 0;
  id v7 = (std::__shared_weak_count *)a1[3];
  if (v7)
  {
    unsigned int v8 = *a4;
    uint64_t v9 = a1[1];
    int v10 = std::__shared_weak_count::lock(v7);
    if (v10)
    {
      id v11 = v10;
      if (a1[2])
      {
        uint64_t v12 = (id *)(v9 + 40);
        if (v8 >= 0x100)
        {
          uint64_t v13 = sub_100200FB4(v12);
          if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
          {
            uint64_t v15 = asString();
            *(_DWORD *)long long buf = 136315138;
            uint64_t v24 = v15;
            _os_log_error_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "secure intent failed with error : %s", buf, 0xCu);
          }
          char v14 = 1;
        }
        else
        {
          uint64_t v13 = sub_100200FB4(v12);
          if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)long long buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I secure intent transaction success", buf, 2u);
          }
          char v14 = 0;
        }

        sub_10050C988(v9, (uint64_t)&v19, (uint64_t)&v17, v14);
      }
      sub_10004D2C8(v11);
    }
  }
  if ((void)v16) {
    operator delete((void *)v16);
  }
  if (v22) {
    sub_10026CF54((uint64_t)&v19, v20);
  }
}

void sub_10050E530(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, void *a16, uint64_t a17, char a18)
{
  sub_10004D2C8(v18);
  if (a9) {
    operator delete(a9);
  }
  if (a18) {
    sub_10026CF54((uint64_t)&a15, a16);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_10050E584(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10050E5C4()
{
}

void sub_10050E5D0()
{
}

uint64_t sub_10050E5F8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t *a5, uint64_t a6)
{
  v50[0] = off_1019AF850;
  v50[1] = sub_10050ED7C;
  v50[3] = v50;
  *(void *)(a1 + 208) = 0;
  if ((capabilities::ct::supportsGemini((capabilities::ct *)a1) & 1) == 0) {
    operator new();
  }
  if (!*(void *)(a1 + 208)) {
    operator new();
  }
  sub_10008863C(v50);
  uint64_t v12 = *(std::__shared_weak_count **)(a3 + 8);
  v45[0] = *(void *)a3;
  v45[1] = v12;
  if (v12) {
    atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v13 = (std::__shared_weak_count *)a4[1];
  v44[0] = *a4;
  v44[1] = v13;
  if (v13) {
    atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v14 = *a5;
  uint64_t v15 = (std::__shared_weak_count *)a5[1];
  v43[0] = v14;
  v43[1] = v15;
  if (v15) {
    atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  sub_1005724C8(a1, a2, v45, v44, v43);
  if (v15) {
    sub_10004D2C8(v15);
  }
  if (v13) {
    sub_10004D2C8(v13);
  }
  if (v12) {
    sub_10004D2C8(v12);
  }
  *(void *)a1 = off_1019DD2B8;
  *(void *)(a1 + 8) = off_1019DD420;
  *(_OWORD *)(a1 + 240) = 0u;
  *(_OWORD *)(a1 + 256) = 0u;
  *(_OWORD *)(a1 + 272) = 0u;
  std::to_string(&v40, a6);
  long long v16 = std::string::insert(&v40, 0, "MT MMS ", 7uLL);
  long long v17 = *(_OWORD *)&v16->__r_.__value_.__l.__data_;
  std::string::size_type v42 = v16->__r_.__value_.__r.__words[2];
  *(_OWORD *)long long __p = v17;
  v16->__r_.__value_.__l.__size_ = 0;
  v16->__r_.__value_.__r.__words[2] = 0;
  v16->__r_.__value_.__r.__words[0] = 0;
  uint64_t v46 = 0;
  os_log_t log = 0;
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v46, kCtLoggingSystemName, "mms.fetch");
  os_log_t v18 = log;
  uint64_t v19 = os_signpost_id_generate(log);
  if ((unint64_t)(v19 - 1) <= 0xFFFFFFFFFFFFFFFDLL)
  {
    uint64_t v20 = log;
    if (os_signpost_enabled(log))
    {
      LODWORD(buf) = 134217984;
      *(void *)((char *)&buf + 4) = a6;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v20, OS_SIGNPOST_INTERVAL_BEGIN, v19, "MobileTerminatedMMS", "receive_time=%{signpost.description:attribute}ld", (uint8_t *)&buf, 0xCu);
    }
  }
  *(void *)&long long buf = off_1019DD4B8;
  p_long long buf = &buf;
  v48[0] = v19;
  v48[1] = (uint64_t)os_retain(v18);
  sub_1000336E8((uint64_t)&v49, (uint64_t)&buf);
  sub_100033A10(&buf);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v46);
  Registry::createXpcJetsamAssertion();
  sub_1000339DC(v48);
  if (SHIBYTE(v42) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v40.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v40.__r_.__value_.__l.__data_);
  }
  *(void *)(a1 + 216) = 0;
  uint64_t v21 = operator new(0x18uLL);
  *((void *)&buf + 1) = v21 + 3;
  long long v52 = (char *)(v21 + 3);
  *(_OWORD *)uint64_t v21 = *(_OWORD *)off_1019DD448;
  void v21[2] = @"MaxMmsFetchRetries";
  *(void *)&long long buf = v21;
  uint64_t v46 = 0;
  ServiceMap = (std::mutex *)Registry::getServiceMap(v21 + 3, *(Registry **)a3);
  long long v23 = ServiceMap;
  if ((v24 & 0x8000000000000000) != 0)
  {
    uint64_t v25 = (unsigned __int8 *)(v24 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v26 = 5381;
    do
    {
      std::string::size_type v24 = v26;
      unsigned int v27 = *v25++;
      uint64_t v26 = (33 * v26) ^ v27;
    }
    while (v27);
  }
  std::mutex::lock(ServiceMap);
  v40.__r_.__value_.__r.__words[0] = v24;
  char v28 = sub_10004D37C(&v23[1].__m_.__sig, (unint64_t *)&v40);
  if (v28)
  {
    uint64_t v30 = v28[3];
    uint64_t v29 = (std::__shared_weak_count *)v28[4];
    if (v29)
    {
      atomic_fetch_add_explicit(&v29->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v23);
      atomic_fetch_add_explicit(&v29->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v29);
      char v31 = 0;
      goto LABEL_32;
    }
  }
  else
  {
    uint64_t v30 = 0;
  }
  std::mutex::unlock(v23);
  uint64_t v29 = 0;
  char v31 = 1;
LABEL_32:
  (*(void (**)(const void **__return_ptr, uint64_t, uint64_t, uint64_t, long long *, void, void))(*(void *)v30 + 104))(&v39, v30, a2, 1, &buf, 0, 0);
  sub_1000842D0(&v46, &v39);
  sub_1000577C4(&v39);
  if ((v31 & 1) == 0) {
    sub_10004D2C8(v29);
  }
  if (v46) {
    CFDataRef v33 = sub_100081E58;
  }
  else {
    CFDataRef v33 = 0;
  }
  int data = 10;
  if (v33)
  {
    LODWORD(v40.__r_.__value_.__l.__data_) = 10;
    ctu::cf::assign((ctu::cf *)&v40, v46, v32);
    int data = (int)v40.__r_.__value_.__l.__data_;
  }
  *(_DWORD *)(a1 + 44) = data;
  int v35 = *(std::__shared_weak_count **)(a1 + 184);
  *(void *)(a1 + 176) = 0;
  *(void *)(a1 + 184) = 0;
  if (v35) {
    sub_10004D2C8(v35);
  }
  *(void *)(a1 + 224) = a6;
  *(void *)(a1 + 232) = 0;
  if (*a4)
  {
    uint64_t v36 = sub_100CCA330(*a4, "X-Mms-Expiry");
    if (v36)
    {
      uint64_t v37 = *(void *)(a1 + 224);
      if (*(unsigned __int8 *)(v36 + 36) != 128) {
        uint64_t v37 = 0;
      }
      *(void *)(a1 + 232) = *(unsigned int *)(v36 + 32) - v37;
    }
  }
  sub_1000570E8((const void **)&v46);
  if ((void)buf)
  {
    *((void *)&buf + 1) = buf;
    operator delete((void *)buf);
  }
  return a1;
}

void sub_10050EBA4(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29,uint64_t a30,char a31)
{
  sub_10008863C((void *)(v31 - 128));
  operator delete();
}

const char *sub_10050ED7C(int a1)
{
  uint64_t v1 = "msg.mms.op.fetch.?";
  if (a1 == 2) {
    uint64_t v1 = "msg.mms.op.fetch.2";
  }
  if (a1 == 1) {
    return "msg.mms.op.fetch.1";
  }
  else {
    return v1;
  }
}

uint64_t sub_10050EDA8(uint64_t a1)
{
  *(void *)a1 = off_1019DD2B8;
  *(void *)(a1 + 8) = off_1019DD420;
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 296);
  if (v2) {
    sub_10004D2C8(v2);
  }
  if (*(char *)(a1 + 287) < 0) {
    operator delete(*(void **)(a1 + 264));
  }
  if (*(char *)(a1 + 263) < 0) {
    operator delete(*(void **)(a1 + 240));
  }
  sub_100572700(a1);
  uint64_t v3 = *(void *)(a1 + 208);
  *(void *)(a1 + 208) = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  return a1;
}

uint64_t sub_10050EE70(uint64_t a1)
{
  return sub_10050EDA8(a1 - 8);
}

void sub_10050EE78(uint64_t a1)
{
  sub_10050EDA8(a1);

  operator delete();
}

void sub_10050EEB0(uint64_t a1)
{
  sub_10050EDA8(a1 - 8);

  operator delete();
}

BOOL sub_10050EEEC(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 144);
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 152);
  uint64_t v4 = v2;
  if (v3)
  {
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
    uint64_t v4 = *(void *)(a1 + 144);
  }
  if (v4) {
    BOOL v5 = v2 == 0;
  }
  else {
    BOOL v5 = 1;
  }
  if (!v5)
  {
    uint64_t v6 = sub_100CCA3B0(v2, "X-Mms-Content-Location");
    if (v6)
    {
      if (*(char *)(v6 + 47) < 0)
      {
        BOOL v7 = *(void *)(v6 + 24) != 0;
        if (!v3) {
          return v7;
        }
      }
      else
      {
        BOOL v7 = 1;
        if (!v3) {
          return v7;
        }
      }
      goto LABEL_12;
    }
  }
  BOOL v7 = 0;
  if (v3) {
LABEL_12:
  }
    sub_10004D2C8(v3);
  return v7;
}

void sub_10050EF84(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10050EF9C(uint64_t a1, uint64_t a2, char a3)
{
  uint64_t v6 = sub_100573A2C((uint64_t *)a1, a2, a3);
  if (v6 && (a3 & 1) == 0) {
    sub_10078E66C(a2, *(_DWORD *)(a1 + 224));
  }
  return v6;
}

void sub_10050EFEC(uint64_t a1)
{
  uint64_t v2 = (os_log_t *)(*(uint64_t (**)(void, void))(**(void **)(a1 + 208) + 16))(*(void *)(a1 + 208), *(unsigned int *)(a1 + 48));
  time_t v3 = time(0);
  uint64_t v4 = *(void *)(a1 + 232);
  if (v4 && v3 > *(void *)(a1 + 224) + v4)
  {
    BOOL v5 = *v2;
    if (os_log_type_enabled(*v2, OS_LOG_TYPE_ERROR))
    {
      int v44 = *(_DWORD *)(a1 + 36);
      LODWORD(buf.__r_.__value_.__l.__data_) = 67109120;
      HIDWORD(buf.__r_.__value_.__r.__words[0]) = v44;
      _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "MMSFetchOperation expired, MsgId: %u", (uint8_t *)&buf, 8u);
    }
    sub_100058DB0(v95, "");
    sub_10050FF64(a1, 0xE2u, 5u, (const char *)v95);
    if (v96 < 0) {
      operator delete(v95[0]);
    }
LABEL_101:
    uint64_t v43 = *(void *)(a1 + 128);
    sub_10003E168(&v66, (void *)(a1 + 16));
    (*(void (**)(uint64_t, uint64_t, uint64_t *))(*(void *)v43 + 16))(v43, 1, &v66);
    if (v67) {
      sub_10004D2C8(v67);
    }
    return;
  }
  uint64_t v7 = *(void *)(a1 + 144);
  uint64_t v6 = *(std::__shared_weak_count **)(a1 + 152);
  if (v6) {
    atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (v7)
  {
    memset(&v92, 0, sizeof(v92));
    sub_100058DB0(&v92, "");
    uint64_t v8 = sub_100CCA3B0(v7, "X-Mms-MMS-Version");
    if (v8 && (*(unsigned int (**)(uint64_t, std::string *))(*(void *)v8 + 72))(v8, &v92))
    {
      if (SHIBYTE(v92.__r_.__value_.__r.__words[2]) < 0) {
        sub_10004FC84(&buf, v92.__r_.__value_.__l.__data_, v92.__r_.__value_.__l.__size_);
      }
      else {
        std::string buf = v92;
      }
    }
    else
    {
      sub_100058DB0(&buf, "");
    }
    if (SHIBYTE(v92.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v92.__r_.__value_.__l.__data_);
    }
    std::string v92 = buf;
    uint64_t v9 = sub_100CCA3B0(v7, "X-Mms-Content-Location");
    if (!v9 || (int v10 = (char *)(v9 + 24), *(char *)(v9 + 47) < 0) && (int v10 = *(char **)v10) == 0)
    {
      int v35 = *v2;
      if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
      {
        int v46 = *(_DWORD *)(a1 + 36);
        LODWORD(buf.__r_.__value_.__l.__data_) = 136315394;
        *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)"X-Mms-Content-Location";
        WORD2(buf.__r_.__value_.__r.__words[1]) = 1024;
        *(_DWORD *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = v46;
        _os_log_error_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_ERROR, "MMSFetchOperation failed, content location is missing (no value for header '%s'), MsgId: %u", (uint8_t *)&buf, 0x12u);
      }
      uint64_t v36 = *(void *)(a1 + 128);
      uint64_t v37 = *(unsigned int *)(a1 + 48);
      uint64_t v90 = v7;
      CFBooleanRef v91 = v6;
      if (v6) {
        atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      sub_100058DB0(v88, "");
      (*(void (**)(uint64_t, uint64_t, uint64_t *, const char *, void **))(*(void *)v36 + 48))(v36, v37, &v90, "Unrecognized", v88);
      if (v89 < 0) {
        operator delete(v88[0]);
      }
      if (v91) {
        sub_10004D2C8(v91);
      }
      if (SHIBYTE(v92.__r_.__value_.__r.__words[2]) < 0) {
        sub_10004FC84(&__p, v92.__r_.__value_.__l.__data_, v92.__r_.__value_.__l.__size_);
      }
      else {
        std::string __p = v92;
      }
      sub_10050FF64(a1, 0xE5u, 6u, (const char *)&__p);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      goto LABEL_95;
    }
    sub_100058DB0(&buf, v10);
    id v11 = (void **)(a1 + 240);
    if (*(char *)(a1 + 263) < 0) {
      operator delete(*v11);
    }
    *(_OWORD *)id v11 = *(_OWORD *)&buf.__r_.__value_.__l.__data_;
    *(void *)(a1 + 256) = *((void *)&buf.__r_.__value_.__l + 2);
    if (!(*(unsigned int (**)(void))(**(void **)(a1 + 160) + 248))(*(void *)(a1 + 160)))
    {
LABEL_41:
      std::string::size_type v21 = std::string::find((const std::string *)(a1 + 240), 63, 0);
      std::string::basic_string(&buf, (const std::string *)(a1 + 240), 0, v21, (std::allocator<char> *)&v85);
      char v22 = (void **)(a1 + 264);
      if (*(char *)(a1 + 287) < 0) {
        operator delete(*v22);
      }
      *(_OWORD *)char v22 = *(_OWORD *)&buf.__r_.__value_.__l.__data_;
      *(void *)(a1 + 280) = *((void *)&buf.__r_.__value_.__l + 2);
      long long v23 = *v2;
      if (os_log_type_enabled(*v2, OS_LOG_TYPE_DEFAULT))
      {
        if (*(char *)(a1 + 287) < 0) {
          char v22 = (void **)*v22;
        }
        std::string::size_type v24 = (void *)(a1 + 240);
        if (*(char *)(a1 + 263) < 0) {
          std::string::size_type v24 = *v11;
        }
        int v25 = *(_DWORD *)(a1 + 36);
        LODWORD(buf.__r_.__value_.__l.__data_) = 136315650;
        *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v22;
        WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
        *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v24;
        HIWORD(buf.__r_.__value_.__r.__words[2]) = 1024;
        int v98 = v25;
        _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "#I Calculated fMmscUrl for MMSFetchOperation: %s (full path was: %s), MsgId: %u", (uint8_t *)&buf, 0x1Cu);
      }
      uint64_t v85 = 0;
      long long v86 = 0;
      sub_1005725BC(a1, *(unsigned int *)(a1 + 48), &v85);
      if (!v85
        || !*(void *)(a1 + 160)
        || ((uint64_t v26 = (*(uint64_t (**)(void))(*(void *)v85 + 40))(),
             int v27 = *(char *)(v26 + 23),
             char v28 = *(const char **)v26,
             uint64_t v29 = (*(uint64_t (**)(void))(**(void **)(a1 + 160) + 40))(*(void *)(a1 + 160)),
             v27 >= 0)
          ? (uint64_t v30 = (const char *)v26)
          : (uint64_t v30 = v28),
            *(char *)(v29 + 23) >= 0 ? (uint64_t v31 = (const char *)v29) : (uint64_t v31 = *(const char **)v29),
            strcasecmp(v30, v31)))
      {
        CFNumberRef v32 = *v2;
        if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
        {
          int v47 = *(_DWORD *)(a1 + 36);
          LODWORD(buf.__r_.__value_.__l.__data_) = 67109120;
          HIDWORD(buf.__r_.__value_.__r.__words[0]) = v47;
          _os_log_error_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_ERROR, "MMSFetchOperation failed, MMSC has changed since being queued, MsgId: %u", (uint8_t *)&buf, 8u);
        }
        if (SHIBYTE(v92.__r_.__value_.__r.__words[2]) < 0) {
          sub_10004FC84(&__dst, v92.__r_.__value_.__l.__data_, v92.__r_.__value_.__l.__size_);
        }
        else {
          std::string __dst = v92;
        }
        sub_10050FF64(a1, 0x18u, 7u, (const char *)&__dst);
        if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
          goto LABEL_84;
        }
        uint64_t v38 = (void *)__dst.__r_.__value_.__r.__words[0];
LABEL_83:
        operator delete(v38);
LABEL_84:
        int v34 = 1;
LABEL_85:
        if (v86) {
          sub_10004D2C8(v86);
        }
        goto LABEL_96;
      }
      char v39 = *v2;
      if (os_log_type_enabled(*v2, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v40 = sub_100CCA3B0(v7, "X-Mms-Message-Size");
        if (v40) {
          int v41 = *(_DWORD *)(v40 + 20);
        }
        else {
          int v41 = 0;
        }
        int v48 = *(_DWORD *)(a1 + 36);
        LODWORD(buf.__r_.__value_.__l.__data_) = 67109376;
        HIDWORD(buf.__r_.__value_.__r.__words[0]) = v41;
        LOWORD(buf.__r_.__value_.__r.__words[1]) = 1024;
        *(_DWORD *)((char *)&buf.__r_.__value_.__r.__words[1] + 2) = v48;
        _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_DEFAULT, "#I Recieved MMS notification indicates expected mms size: %u, MsgId: %u", (uint8_t *)&buf, 0xEu);
      }
      uint64_t v49 = *(std::__shared_weak_count **)(a1 + 168);
      uint64_t v82 = *(void *)(a1 + 160);
      unsigned __int8 v83 = v49;
      if (v49) {
        atomic_fetch_add_explicit(&v49->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      sub_100572C3C(a1, &v82);
      if (v83) {
        sub_10004D2C8(v83);
      }
      uint64_t v50 = *(void *)(a1 + 176);
      if (!v50)
      {
        int v54 = *v2;
        if (os_log_type_enabled(v54, OS_LOG_TYPE_ERROR))
        {
          int v64 = *(_DWORD *)(a1 + 36);
          LODWORD(buf.__r_.__value_.__l.__data_) = 67109120;
          HIDWORD(buf.__r_.__value_.__r.__words[0]) = v64;
          _os_log_error_impl((void *)&_mh_execute_header, v54, OS_LOG_TYPE_ERROR, "MMSFetchOperation failed, Unable to create connection object, MsgId: %u", (uint8_t *)&buf, 8u);
        }
        if (SHIBYTE(v92.__r_.__value_.__r.__words[2]) < 0) {
          sub_10004FC84(&v81, v92.__r_.__value_.__l.__data_, v92.__r_.__value_.__l.__size_);
        }
        else {
          std::string v81 = v92;
        }
        sub_10050FF64(a1, 0x18u, 0xCu, (const char *)&v81);
        if ((SHIBYTE(v81.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
          goto LABEL_84;
        }
        uint64_t v38 = (void *)v81.__r_.__value_.__r.__words[0];
        goto LABEL_83;
      }
      (*(void (**)(uint64_t, const char *))(*(void *)v50 + 40))(v50, "application/vnd.wap.mms-message");
      sub_100572E28(a1);
      char v51 = (void *)(a1 + 240);
      if (*(char *)(a1 + 263) < 0) {
        char v51 = *v11;
      }
      if (((*(uint64_t (**)(void, void *))(**(void **)(a1 + 176) + 16))(*(void *)(a1 + 176), v51) & 1) == 0)
      {
        char v55 = *(std::__shared_weak_count **)(a1 + 184);
        *(void *)(a1 + 176) = 0;
        *(void *)(a1 + 184) = 0;
        if (v55) {
          sub_10004D2C8(v55);
        }
        BOOL v56 = *v2;
        if (os_log_type_enabled(v56, OS_LOG_TYPE_ERROR))
        {
          if (*(char *)(a1 + 263) < 0) {
            id v11 = (void **)*v11;
          }
          int v65 = *(_DWORD *)(a1 + 36);
          LODWORD(buf.__r_.__value_.__l.__data_) = 136315394;
          *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v11;
          WORD2(buf.__r_.__value_.__r.__words[1]) = 1024;
          *(_DWORD *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = v65;
          _os_log_error_impl((void *)&_mh_execute_header, v56, OS_LOG_TYPE_ERROR, "MMSFetchOperation failed, Unable to retrieve message from url %s, MsgId: %u", (uint8_t *)&buf, 0x12u);
        }
        if (SHIBYTE(v92.__r_.__value_.__r.__words[2]) < 0) {
          sub_10004FC84(&v80, v92.__r_.__value_.__l.__data_, v92.__r_.__value_.__l.__size_);
        }
        else {
          std::string v80 = v92;
        }
        sub_10050FF64(a1, 0x18u, 0xEu, (const char *)&v80);
        if ((SHIBYTE(v80.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
          goto LABEL_84;
        }
        uint64_t v38 = (void *)v80.__r_.__value_.__r.__words[0];
        goto LABEL_83;
      }
      *(_OWORD *)&buf.__r_.__value_.__l.__data_ = 0uLL;
      sub_100117350(*(Registry **)(a1 + 112), &buf);
      if (!buf.__r_.__value_.__r.__words[0])
      {
        int v57 = *v2;
        if (os_log_type_enabled(*v2, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)xpc_object_t v75 = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v57, OS_LOG_TYPE_ERROR, "Failed to get analytics interface for MMS Send End.", v75, 2u);
        }
        goto LABEL_149;
      }
      xpc_object_t v79 = 0;
      xpc_object_t v52 = xpc_dictionary_create(0, 0, 0);
      xpc_object_t v53 = v52;
      if (v52)
      {
        xpc_object_t v79 = v52;
      }
      else
      {
        xpc_object_t v53 = xpc_null_create();
        xpc_object_t v79 = v53;
        if (!v53)
        {
          xpc_object_t v58 = xpc_null_create();
          xpc_object_t v53 = 0;
          goto LABEL_139;
        }
      }
      if (xpc_get_type(v53) == (xpc_type_t)&_xpc_type_dictionary)
      {
        xpc_retain(v53);
LABEL_140:
        xpc_release(v53);
        unsigned int v60 = subscriber::simSlotAsInstance();
        xpc_object_t v77 = xpc_int64_create(v60);
        if (!v77) {
          xpc_object_t v77 = xpc_null_create();
        }
        *(void *)xpc_object_t v75 = &v79;
        CFDataRef v76 = "subs_id";
        sub_100035E70((uint64_t)v75, &v77, &object);
        xpc_release(object);
        xpc_object_t object = 0;
        xpc_release(v77);
        xpc_object_t v77 = 0;
        xpc_object_t v73 = xpc_int64_create(0);
        if (!v73) {
          xpc_object_t v73 = xpc_null_create();
        }
        *(void *)xpc_object_t v75 = &v79;
        CFDataRef v76 = "dwErrCode";
        sub_100035E70((uint64_t)v75, &v73, &v74);
        xpc_release(v74);
        xpc_object_t v74 = 0;
        xpc_release(v73);
        xpc_object_t v73 = 0;
        xpc_object_t v71 = xpc_int64_create(7);
        if (!v71) {
          xpc_object_t v71 = xpc_null_create();
        }
        *(void *)xpc_object_t v75 = &v79;
        CFDataRef v76 = "ucState";
        sub_100035E70((uint64_t)v75, &v71, &v72);
        xpc_release(v72);
        xpc_object_t v72 = 0;
        xpc_release(v71);
        xpc_object_t v71 = 0;
        xpc_object_t v69 = xpc_int64_create(128);
        if (!v69) {
          xpc_object_t v69 = xpc_null_create();
        }
        *(void *)xpc_object_t v75 = &v79;
        CFDataRef v76 = "wResultCode";
        sub_100035E70((uint64_t)v75, &v69, &v70);
        xpc_release(v70);
        xpc_object_t v70 = 0;
        xpc_release(v69);
        xpc_object_t v69 = 0;
        std::string::size_type v61 = buf.__r_.__value_.__r.__words[0];
        sub_100117418(&v68, &v79);
        (*(void (**)(std::string::size_type, const char *, xpc_object_t *))(*(void *)v61 + 16))(v61, "metricCCMMSRetState", &v68);
        xpc_release(v68);
        xpc_object_t v68 = 0;
        xpc_release(v79);
LABEL_149:
        if (buf.__r_.__value_.__l.__size_) {
          sub_10004D2C8((std::__shared_weak_count *)buf.__r_.__value_.__l.__size_);
        }
        uint64_t v62 = *v2;
        int v34 = 0;
        if (os_log_type_enabled(v62, OS_LOG_TYPE_DEFAULT))
        {
          int v63 = *(_DWORD *)(a1 + 36);
          LODWORD(buf.__r_.__value_.__l.__data_) = 67109120;
          HIDWORD(buf.__r_.__value_.__r.__words[0]) = v63;
          _os_log_impl((void *)&_mh_execute_header, v62, OS_LOG_TYPE_DEFAULT, "#I MMSFetchOperation run() succeeded, fetch in progress, MsgId: %u", (uint8_t *)&buf, 8u);
          int v34 = 0;
        }
        goto LABEL_85;
      }
      xpc_object_t v58 = xpc_null_create();
LABEL_139:
      xpc_object_t v79 = v58;
      goto LABEL_140;
    }
    if (*(char *)(a1 + 263) < 0)
    {
      uint64_t v12 = *(void *)(a1 + 248);
      if (v12)
      {
LABEL_25:
        uint64_t v13 = v12 - 1;
        uint64_t v14 = (unsigned char *)(a1 + 240);
        if ((*(unsigned char *)(a1 + 263) & 0x80) != 0) {
          uint64_t v14 = *v11;
        }
        if (v14[v13] == 61)
        {
          uint64_t v15 = *v2;
          if (os_log_type_enabled(*v2, OS_LOG_TYPE_DEFAULT))
          {
            int v16 = *(_DWORD *)(a1 + 36);
            LODWORD(buf.__r_.__value_.__l.__data_) = 67109120;
            HIDWORD(buf.__r_.__value_.__r.__words[0]) = v16;
            _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I Content-Location does not include UID value, manually appending, MsgId: %u", (uint8_t *)&buf, 8u);
          }
          uint64_t v17 = sub_100CCA3B0(v7, "X-Mms-Transaction-ID");
          if (v17)
          {
            os_log_t v18 = (char *)(v17 + 24);
            if ((*(char *)(v17 + 47) & 0x80000000) == 0 || (os_log_t v18 = *(char **)v18) != 0)
            {
              sub_100058DB0(&buf, v18);
              if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                p_std::string buf = &buf;
              }
              else {
                p_std::string buf = (std::string *)buf.__r_.__value_.__r.__words[0];
              }
              if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                std::string::size_type size = HIBYTE(buf.__r_.__value_.__r.__words[2]);
              }
              else {
                std::string::size_type size = buf.__r_.__value_.__l.__size_;
              }
              std::string::append((std::string *)(a1 + 240), (const std::string::value_type *)p_buf, size);
              if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
                operator delete(buf.__r_.__value_.__l.__data_);
              }
              goto LABEL_41;
            }
          }
          std::string::size_type v42 = *v2;
          if (os_log_type_enabled(v42, OS_LOG_TYPE_ERROR))
          {
            int v59 = *(_DWORD *)(a1 + 36);
            LODWORD(buf.__r_.__value_.__l.__data_) = 136315394;
            *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)"X-Mms-Transaction-ID";
            WORD2(buf.__r_.__value_.__r.__words[1]) = 1024;
            *(_DWORD *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = v59;
            _os_log_error_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_ERROR, "MMSFetchOperation failed, No value for transaction ID (no value for header '%s'), cannot assemble complete MMS URL to fetch!, MsgId: %u", (uint8_t *)&buf, 0x12u);
          }
LABEL_95:
          int v34 = 1;
LABEL_96:
          if (SHIBYTE(v92.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v92.__r_.__value_.__l.__data_);
          }
          goto LABEL_98;
        }
        goto LABEL_41;
      }
    }
    else
    {
      uint64_t v12 = *(unsigned __int8 *)(a1 + 263);
      if (*(unsigned char *)(a1 + 263)) {
        goto LABEL_25;
      }
    }
    sub_1000C14D8();
  }
  CFDataRef v33 = *v2;
  if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
  {
    int v45 = *(_DWORD *)(a1 + 36);
    LODWORD(buf.__r_.__value_.__l.__data_) = 67109120;
    HIDWORD(buf.__r_.__value_.__r.__words[0]) = v45;
    _os_log_error_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_ERROR, "MMSFetchOperation failed, message is null, MsgId: %u", (uint8_t *)&buf, 8u);
  }
  sub_100058DB0(v93, "");
  sub_10050FF64(a1, 0xC0u, 2u, (const char *)v93);
  if (v94 < 0) {
    operator delete(v93[0]);
  }
  int v34 = 1;
LABEL_98:
  if (v6) {
    sub_10004D2C8(v6);
  }
  if (v34) {
    goto LABEL_101;
  }
}

void sub_10050FD78(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, xpc_object_t object, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,xpc_object_t a24,void *__p,uint64_t a26,int a27,__int16 a28,char a29,char a30,uint64_t a31,uint64_t a32,uint64_t a33,int a34,__int16 a35,char a36,char a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,int a43,__int16 a44,char a45,char a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,int a52,__int16 a53,char a54,char a55)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_10050FF64(uint64_t a1, unsigned int a2, unsigned int a3, const char *a4)
{
  uint64_t v8 = *(unsigned int *)(a1 + 48);
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 112));
  int v10 = ServiceMap;
  if (v11 < 0)
  {
    uint64_t v12 = (unsigned __int8 *)(v11 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v13 = 5381;
    do
    {
      uint64_t v11 = v13;
      unsigned int v14 = *v12++;
      uint64_t v13 = (33 * v13) ^ v14;
    }
    while (v14);
  }
  std::mutex::lock(ServiceMap);
  *(void *)std::string buf = v11;
  uint64_t v15 = sub_10004D37C(&v10[1].__m_.__sig, (unint64_t *)buf);
  if (v15)
  {
    uint64_t v17 = v15[3];
    int v16 = (std::__shared_weak_count *)v15[4];
    if (v16)
    {
      atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v10);
      atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v16);
      char v18 = 0;
      if (!v17) {
        goto LABEL_7;
      }
      goto LABEL_11;
    }
  }
  else
  {
    uint64_t v17 = 0;
  }
  std::mutex::unlock(v10);
  int v16 = 0;
  char v18 = 1;
  if (!v17)
  {
LABEL_7:
    uint64_t v19 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 208) + 16))(*(void *)(a1 + 208), v8);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Failed to get analytics interface for MMS Send End.", buf, 2u);
    }
    goto LABEL_33;
  }
LABEL_11:
  xpc_object_t v35 = 0;
  xpc_object_t v20 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v21 = v20;
  if (v20)
  {
    xpc_object_t v35 = v20;
  }
  else
  {
    xpc_object_t v21 = xpc_null_create();
    xpc_object_t v35 = v21;
    if (!v21)
    {
      xpc_object_t v22 = xpc_null_create();
      xpc_object_t v21 = 0;
      goto LABEL_18;
    }
  }
  if (xpc_get_type(v21) != (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_object_t v22 = xpc_null_create();
LABEL_18:
    xpc_object_t v35 = v22;
    goto LABEL_19;
  }
  xpc_retain(v21);
LABEL_19:
  xpc_release(v21);
  unsigned int v23 = subscriber::simSlotAsInstance();
  xpc_object_t v33 = xpc_int64_create(v23);
  if (!v33) {
    xpc_object_t v33 = xpc_null_create();
  }
  *(void *)std::string buf = &v35;
  CFNumberRef v32 = "subs_id";
  sub_100035E70((uint64_t)buf, &v33, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(v33);
  xpc_object_t v33 = 0;
  xpc_object_t v29 = xpc_int64_create(a3);
  if (!v29) {
    xpc_object_t v29 = xpc_null_create();
  }
  *(void *)std::string buf = &v35;
  CFNumberRef v32 = "dwErrCode";
  sub_100035E70((uint64_t)buf, &v29, &v30);
  xpc_release(v30);
  xpc_object_t v30 = 0;
  xpc_release(v29);
  xpc_object_t v29 = 0;
  if (a4[23] < 0) {
    a4 = *(const char **)a4;
  }
  xpc_object_t v27 = xpc_string_create(a4);
  if (!v27) {
    xpc_object_t v27 = xpc_null_create();
  }
  *(void *)std::string buf = &v35;
  CFNumberRef v32 = "wMmsVersion";
  sub_100035E70((uint64_t)buf, &v27, &v28);
  xpc_release(v28);
  xpc_object_t v28 = 0;
  xpc_release(v27);
  xpc_object_t v27 = 0;
  xpc_object_t v25 = xpc_int64_create(a2);
  if (!v25) {
    xpc_object_t v25 = xpc_null_create();
  }
  *(void *)std::string buf = &v35;
  CFNumberRef v32 = "wResultCode";
  sub_100035E70((uint64_t)buf, &v25, &v26);
  xpc_release(v26);
  xpc_object_t v26 = 0;
  xpc_release(v25);
  xpc_object_t v24 = v35;
  xpc_object_t v25 = 0;
  if (v35) {
    xpc_retain(v35);
  }
  else {
    xpc_object_t v24 = xpc_null_create();
  }
  (*(void (**)(uint64_t, const char *, xpc_object_t *))(*(void *)v17 + 16))(v17, "metricCCMMSFinishRet", &v24);
  xpc_release(v24);
  xpc_object_t v24 = 0;
  xpc_release(v35);
LABEL_33:
  if ((v18 & 1) == 0) {
    sub_10004D2C8(v16);
  }
}

void sub_10051030C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object)
{
  if ((v11 & 1) == 0) {
    sub_10004D2C8(v10);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_10051039C(uint64_t a1)
{
  time_t v2 = time(0);
  uint64_t v3 = *(void *)(a1 + 232);
  return v3 && v2 > *(void *)(a1 + 224) + v3;
}

void sub_1005103E4(uint64_t a1, int **a2)
{
  unsigned __int8 v155 = 1;
  uint64_t v4 = (os_log_t *)(*(uint64_t (**)(void, void))(**(void **)(a1 + 208) + 16))(*(void *)(a1 + 208), *(unsigned int *)(a1 + 48));
  BOOL v5 = v4;
  if (*a2)
  {
    v151 = 0;
    v152 = 0;
    sub_100572FB0(a1, (char *)&v155, a2, &v151);
    uint64_t v6 = *(std::__shared_weak_count **)(a1 + 184);
    *(void *)(a1 + 176) = 0;
    *(void *)(a1 + 184) = 0;
    if (v6) {
      sub_10004D2C8(v6);
    }
    uint64_t v7 = v151;
    if (v151)
    {
      uint64_t v8 = v152;
      if (v152) {
        atomic_fetch_add_explicit(&v152->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      uint64_t v9 = (os_log_t *)(*(uint64_t (**)(void, void))(**(void **)(a1 + 208) + 16))(*(void *)(a1 + 208), *(unsigned int *)(a1 + 48));
      int v10 = *v9;
      if (os_log_type_enabled(*v9, OS_LOG_TYPE_DEFAULT))
      {
        int v11 = *(_DWORD *)(a1 + 36);
        sub_10022E1C8(v7, 0, 0, __p);
        if (__p[23] >= 0) {
          uint64_t v12 = __p;
        }
        else {
          uint64_t v12 = *(unsigned char **)__p;
        }
        LODWORD(buf.__r_.__value_.__l.__data_) = 67109378;
        HIDWORD(buf.__r_.__value_.__r.__words[0]) = v11;
        LOWORD(buf.__r_.__value_.__r.__words[1]) = 2080;
        *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 2) = (std::string::size_type)v12;
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I MsgId %u public message: %s", (uint8_t *)&buf, 0x12u);
        if ((__p[23] & 0x80000000) != 0) {
          operator delete(*(void **)__p);
        }
        int v10 = *v9;
      }
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
        int v13 = *(_DWORD *)(a1 + 36);
        sub_10022E1C8(v7, 1, 0, __p);
        if (__p[23] >= 0) {
          unsigned int v14 = __p;
        }
        else {
          unsigned int v14 = *(unsigned char **)__p;
        }
        LODWORD(buf.__r_.__value_.__l.__data_) = 67109379;
        HIDWORD(buf.__r_.__value_.__r.__words[0]) = v13;
        LOWORD(buf.__r_.__value_.__r.__words[1]) = 2085;
        *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 2) = (std::string::size_type)v14;
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I MsgId %u sensitive message: %{sensitive}s", (uint8_t *)&buf, 0x12u);
        if ((__p[23] & 0x80000000) != 0) {
          operator delete(*(void **)__p);
        }
        int v10 = *v9;
      }
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
        int v15 = *(_DWORD *)(a1 + 36);
        sub_10022E4D4((uint64_t)v7, __p);
        int v16 = __p[23] >= 0 ? __p : *(unsigned char **)__p;
        LODWORD(buf.__r_.__value_.__l.__data_) = 67109379;
        HIDWORD(buf.__r_.__value_.__r.__words[0]) = v15;
        LOWORD(buf.__r_.__value_.__r.__words[1]) = 2085;
        *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 2) = (std::string::size_type)v16;
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I MsgId %u Body: %{sensitive}s", (uint8_t *)&buf, 0x12u);
        if ((__p[23] & 0x80000000) != 0) {
          operator delete(*(void **)__p);
        }
      }
      uint64_t v17 = (unsigned __int8 *)sub_100CCA330((uint64_t)v7, "X-Mms-Retrieve-Status");
      if (v17)
      {
        int v18 = v17[17];
        if (v18 != 128)
        {
          memset(__p, 0, 24);
          (*(void (**)(unsigned __int8 *, unsigned char *))(*(void *)v17 + 72))(v17, __p);
          uint64_t v19 = *v9;
          if (os_log_type_enabled(*v9, OS_LOG_TYPE_ERROR))
          {
            int v69 = *(_DWORD *)(a1 + 36);
            xpc_object_t v70 = *(unsigned char **)__p;
            if (__p[23] >= 0) {
              xpc_object_t v70 = __p;
            }
            LODWORD(buf.__r_.__value_.__l.__data_) = 67109634;
            HIDWORD(buf.__r_.__value_.__r.__words[0]) = v18;
            LOWORD(buf.__r_.__value_.__r.__words[1]) = 2080;
            *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 2) = (std::string::size_type)v70;
            WORD1(buf.__r_.__value_.__r.__words[2]) = 1024;
            HIDWORD(buf.__r_.__value_.__r.__words[2]) = v69;
            _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "MMSFetchOperation fetch / retrieve failed: Status 0x%.2x (%s), MsgId: %u", (uint8_t *)&buf, 0x18u);
          }
          if ((v18 & 0xF0) == 0xC0) {
            unsigned __int8 v20 = 2;
          }
          else {
            unsigned __int8 v20 = 1;
          }
          if ((__p[23] & 0x80000000) != 0) {
            operator delete(*(void **)__p);
          }
          goto LABEL_213;
        }
      }
      else
      {
        xpc_object_t v30 = *v9;
        if (os_log_type_enabled(*v9, OS_LOG_TYPE_DEFAULT))
        {
          int v31 = *(_DWORD *)(a1 + 36);
          *(_DWORD *)std::string __p = 136315394;
          *(void *)&__p[4] = "X-Mms-Retrieve-Status";
          *(_WORD *)&__p[12] = 1024;
          *(_DWORD *)&__p[14] = v31;
          _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "#I No value for header '%s', assuming status OK, MsgId: %u", __p, 0x12u);
        }
      }
      CFNumberRef v32 = *v9;
      if (os_log_type_enabled(*v9, OS_LOG_TYPE_DEFAULT))
      {
        int v33 = *(_DWORD *)(a1 + 36);
        *(_DWORD *)std::string __p = 67109120;
        *(_DWORD *)&__p[4] = v33;
        _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, "#I MMSFetchOperation: fetch / retrieve status OK. MsgId: %u", __p, 8u);
      }
      uint64_t v161 = 0;
      v162 = 0;
      sub_1005725BC(a1, *(unsigned int *)(a1 + 48), &v161);
      uint64_t v34 = sub_100CCA330((uint64_t)v7, "From");
      int v35 = (*(uint64_t (**)(uint64_t))(*(void *)v161 + 328))(v161);
      if (!v34 || (int v36 = v35, v35 == -1))
      {
LABEL_168:
        uint64_t v84 = sub_100CCA3B0((uint64_t)v7, "X-Mms-Transaction-ID");
        if (v84 && ((*(char *)(v84 + 47) & 0x80000000) == 0 || *(void *)(v84 + 24)))
        {
          if (v8) {
            atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          if (!(*(unsigned int (**)(void))(**(void **)(a1 + 160) + 184))(*(void *)(a1 + 160))) {
            goto LABEL_191;
          }
          uint64_t v85 = sub_100CCA3B0((uint64_t)v7, "X-Mms-Transaction-ID");
          if (v85)
          {
            long long v86 = (void *)(v85 + 24);
            if (*(char *)(v85 + 47) < 0) {
              long long v86 = (void *)*v86;
            }
          }
          else
          {
            long long v86 = 0;
          }
          uint64_t v87 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 208) + 16))(*(void *)(a1 + 208), *(unsigned int *)(a1 + 48));
          if (v86)
          {
            if (os_log_type_enabled(v87, OS_LOG_TYPE_DEFAULT))
            {
              int v88 = *(_DWORD *)(a1 + 36);
              *(_DWORD *)std::string __p = 67109378;
              *(_DWORD *)&__p[4] = v88;
              *(_WORD *)&__p[8] = 2080;
              *(void *)&__p[10] = v86;
              _os_log_impl((void *)&_mh_execute_header, v87, OS_LOG_TYPE_DEFAULT, "#I Queueing Ack for MsgId: %u, transactionId: %s", __p, 0x12u);
            }
            uint64_t v90 = *(void *)(a1 + 120);
            uint64_t v89 = *(void *)(a1 + 128);
            uint64_t v91 = *(unsigned int *)(a1 + 48);
            *(void *)std::string __p = *(void *)(a1 + 112);
            *(void *)&__p[8] = v90;
            if (v90) {
              atomic_fetch_add_explicit((atomic_ullong *volatile)(v90 + 8), 1uLL, memory_order_relaxed);
            }
            std::string::size_type v92 = *(void *)(a1 + 168);
            buf.__r_.__value_.__r.__words[0] = *(void *)(a1 + 160);
            buf.__r_.__value_.__l.__size_ = v92;
            if (v92) {
              atomic_fetch_add_explicit((atomic_ullong *volatile)(v92 + 8), 1uLL, memory_order_relaxed);
            }
            (*(void (**)(uint64_t, uint64_t, unsigned char *, void *, std::string *))(*(void *)v89 + 24))(v89, v91, __p, v86, &buf);
            if (buf.__r_.__value_.__l.__size_) {
              sub_10004D2C8((std::__shared_weak_count *)buf.__r_.__value_.__l.__size_);
            }
            if (*(void *)&__p[8])
            {
              sub_10004D2C8(*(std::__shared_weak_count **)&__p[8]);
              if (!v8) {
                goto LABEL_193;
              }
LABEL_192:
              sub_10004D2C8(v8);
              goto LABEL_193;
            }
LABEL_191:
            if (!v8) {
              goto LABEL_193;
            }
            goto LABEL_192;
          }
          if (!os_log_type_enabled(v87, OS_LOG_TYPE_ERROR)) {
            goto LABEL_191;
          }
          int v122 = *(_DWORD *)(a1 + 36);
          *(_DWORD *)std::string __p = 67109120;
          *(_DWORD *)&__p[4] = v122;
          _os_log_error_impl((void *)&_mh_execute_header, v87, OS_LOG_TYPE_ERROR, "MMS missing transactionId, can't ACK for MsgId: %u", __p, 8u);
          if (v8) {
            goto LABEL_192;
          }
        }
LABEL_193:
        ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 112));
        char v94 = ServiceMap;
        long long v95 = "27MessageCenterModelInterface";
        if (((unint64_t)"27MessageCenterModelInterface" & 0x8000000000000000) != 0)
        {
          char v96 = (unsigned __int8 *)((unint64_t)"27MessageCenterModelInterface" & 0x7FFFFFFFFFFFFFFFLL);
          uint64_t v97 = 5381;
          do
          {
            long long v95 = (const char *)v97;
            unsigned int v98 = *v96++;
            uint64_t v97 = (33 * v97) ^ v98;
          }
          while (v98);
        }
        std::mutex::lock(ServiceMap);
        *(void *)std::string __p = v95;
        uint64_t v99 = sub_10004D37C(&v94[1].__m_.__sig, (unint64_t *)__p);
        if (v99)
        {
          uint64_t v101 = v99[3];
          CFStringRef v100 = (std::__shared_weak_count *)v99[4];
          if (v100)
          {
            atomic_fetch_add_explicit(&v100->__shared_owners_, 1uLL, memory_order_relaxed);
            std::mutex::unlock(v94);
            atomic_fetch_add_explicit(&v100->__shared_owners_, 1uLL, memory_order_relaxed);
            sub_10004D2C8(v100);
            char v102 = 0;
            if (!v101) {
              goto LABEL_208;
            }
            goto LABEL_202;
          }
        }
        else
        {
          uint64_t v101 = 0;
        }
        std::mutex::unlock(v94);
        CFStringRef v100 = 0;
        char v102 = 1;
        if (!v101)
        {
LABEL_208:
          if ((v102 & 1) == 0) {
            sub_10004D2C8(v100);
          }
          if (v162) {
            sub_10004D2C8(v162);
          }
          unsigned __int8 v20 = 0;
LABEL_213:
          unsigned __int8 v155 = v20;
          if (v8) {
            sub_10004D2C8(v8);
          }
          BOOL v106 = sub_100511CDC(a1);
          v107 = *v5;
          if (v106)
          {
            unsigned int v108 = v155;
          }
          else
          {
            if (os_log_type_enabled(*v5, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)std::string __p = 0;
              _os_log_impl((void *)&_mh_execute_header, v107, OS_LOG_TYPE_DEFAULT, "#I Retry not possible", __p, 2u);
              v107 = *v5;
            }
            unsigned int v108 = 1;
            unsigned __int8 v155 = 1;
          }
          if (os_log_type_enabled(v107, OS_LOG_TYPE_DEFAULT))
          {
            if (v108 > 2) {
              uint64_t v109 = "???";
            }
            else {
              uint64_t v109 = off_1019DD568[(char)v108];
            }
            *(_DWORD *)std::string __p = 136315138;
            *(void *)&__p[4] = v109;
            _os_log_impl((void *)&_mh_execute_header, v107, OS_LOG_TYPE_DEFAULT, "#I MMS fetch response: %s", __p, 0xCu);
            unsigned int v108 = v155;
          }
          if (v108 == 2)
          {
            sub_100058DB0(v128, "");
            sub_10050FF64(a1, 0xC0u, 0, v128);
            if ((v129 & 0x80000000) == 0) {
              goto LABEL_260;
            }
            uint64_t v114 = *(void **)v128;
          }
          else
          {
            if (!v108)
            {
              uint64_t v111 = *(void *)(a1 + 144);
              uint64_t v110 = *(std::__shared_weak_count **)(a1 + 152);
              if (v110)
              {
                atomic_fetch_add_explicit(&v110->__shared_owners_, 1uLL, memory_order_relaxed);
                if (!v111) {
                  goto LABEL_259;
                }
                uint64_t v112 = *(void *)(a1 + 128);
                uint64_t v113 = *(unsigned int *)(a1 + 48);
                uint64_t v134 = v111;
                v135 = v110;
                atomic_fetch_add_explicit(&v110->__shared_owners_, 1uLL, memory_order_relaxed);
              }
              else
              {
                if (!v111) {
                  goto LABEL_260;
                }
                uint64_t v112 = *(void *)(a1 + 128);
                uint64_t v113 = *(unsigned int *)(a1 + 48);
                uint64_t v134 = *(void *)(a1 + 144);
                v135 = 0;
              }
              if (*(char *)(a1 + 287) < 0)
              {
                sub_10004FC84(v132, *(void **)(a1 + 264), *(void *)(a1 + 272));
              }
              else
              {
                *(_OWORD *)v132 = *(_OWORD *)(a1 + 264);
                uint64_t v133 = *(void *)(a1 + 280);
              }
              (*(void (**)(uint64_t, uint64_t, uint64_t *, const char *, void **))(*(void *)v112 + 48))(v112, v113, &v134, "Retrieved", v132);
              if (SHIBYTE(v133) < 0) {
                operator delete(v132[0]);
              }
              if (v135) {
                sub_10004D2C8(v135);
              }
              memset(__p, 0, 24);
              sub_100058DB0(__p, "");
              uint64_t v115 = sub_100CCA3B0(v111, "X-Mms-MMS-Version");
              if (v115 && (*(unsigned int (**)(uint64_t, unsigned char *))(*(void *)v115 + 72))(v115, __p))
              {
                if ((__p[23] & 0x80000000) != 0) {
                  sub_10004FC84(&buf, *(void **)__p, *(unint64_t *)&__p[8]);
                }
                else {
                  std::string buf = *(std::string *)__p;
                }
              }
              else
              {
                sub_100058DB0(&buf, "");
              }
              if ((__p[23] & 0x80000000) != 0) {
                operator delete(*(void **)__p);
              }
              *(std::string *)std::string __p = buf;
              if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0)
              {
                sub_10004FC84(v130, *(void **)__p, *(unint64_t *)&__p[8]);
              }
              else
              {
                *(_OWORD *)int v130 = *(_OWORD *)__p;
                uint64_t v131 = *(void *)&__p[16];
              }
              sub_10050FF64(a1, 0x80u, 0, (const char *)v130);
              if (SHIBYTE(v131) < 0) {
                operator delete(v130[0]);
              }
              if ((__p[23] & 0x80000000) != 0) {
                operator delete(*(void **)__p);
              }
              if (!v110)
              {
LABEL_260:
                uint64_t v116 = *(void *)(a1 + 128);
                uint64_t v117 = v155;
                sub_10003E168(&v124, (void *)(a1 + 16));
                (*(void (**)(uint64_t, uint64_t, uint64_t *))(*(void *)v116 + 16))(v116, v117, &v124);
                char v118 = v125;
                if (!v125) {
                  goto LABEL_262;
                }
                goto LABEL_261;
              }
LABEL_259:
              sub_10004D2C8(v110);
              goto LABEL_260;
            }
            sub_100058DB0(v126, "");
            sub_10050FF64(a1, 0x18u, 3u, (const char *)v126);
            if ((v127 & 0x80000000) == 0) {
              goto LABEL_260;
            }
            uint64_t v114 = v126[0];
          }
          operator delete(v114);
          goto LABEL_260;
        }
LABEL_202:
        v103 = *v9;
        if (os_log_type_enabled(v103, OS_LOG_TYPE_DEFAULT))
        {
          int v104 = *(_DWORD *)(a1 + 36);
          *(_DWORD *)std::string __p = 67109120;
          *(_DWORD *)&__p[4] = v104;
          _os_log_impl((void *)&_mh_execute_header, v103, OS_LOG_TYPE_DEFAULT, "#I MMSFetchOperation Succeeded: Telling MCM to Receive from network. MsgId: %u", __p, 8u);
        }
        uint64_t v105 = *(unsigned int *)(a1 + 48);
        *(void *)std::string __p = v7;
        *(void *)&__p[8] = v8;
        if (v8) {
          atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        (*(void (**)(uint64_t, uint64_t, unsigned char *, void))(*(void *)v101 + 248))(v101, v105, __p, *(unsigned int *)(a1 + 36));
        if (*(void *)&__p[8]) {
          sub_10004D2C8(*(std::__shared_weak_count **)&__p[8]);
        }
        goto LABEL_208;
      }
      uint64_t v37 = *v9;
      if (os_log_type_enabled(*v9, OS_LOG_TYPE_DEFAULT))
      {
        int v38 = *(_DWORD *)(a1 + 36);
        *(_DWORD *)std::string __p = 67109120;
        *(_DWORD *)&__p[4] = v38;
        _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEFAULT, "#I MMSFetchOperation: from header & number prefix requires international symbol, MsgId: %u", __p, 8u);
      }
      memset(&buf, 0, sizeof(buf));
      uint64_t v179 = 0;
      long long v177 = 0u;
      long long v178 = 0u;
      long long v175 = 0u;
      long long v176 = 0u;
      long long v173 = 0u;
      long long v174 = 0u;
      long long v171 = 0u;
      long long v172 = 0u;
      long long v169 = 0u;
      long long v170 = 0u;
      *(_OWORD *)v167 = 0u;
      long long v168 = 0u;
      long long v165 = 0u;
      long long v166 = 0u;
      memset(__p, 0, sizeof(__p));
      sub_10004DE24((uint64_t)__p);
      std::ostream::operator<<();
      v158 = 0;
      std::string::size_type v159 = 0;
      uint64_t v160 = 0;
      sub_10004BC98((uint64_t)&__p[8], &v158);
      if (!(*(unsigned int (**)(uint64_t, std::string *))(*(void *)v34 + 72))(v34, &buf)) {
        goto LABEL_162;
      }
      if (v160 >= 0) {
        std::string::size_type v39 = HIBYTE(v160);
      }
      else {
        std::string::size_type v39 = v159;
      }
      std::string::basic_string(&v163, &buf, 0, v39, (std::allocator<char> *)v156);
      char v40 = HIBYTE(v163.__r_.__value_.__r.__words[2]);
      if ((v163.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string::size_type size = HIBYTE(v163.__r_.__value_.__r.__words[2]);
      }
      else {
        std::string::size_type size = v163.__r_.__value_.__l.__size_;
      }
      std::string::size_type v42 = HIBYTE(v160);
      if (v160 < 0) {
        std::string::size_type v42 = v159;
      }
      if (size == v42)
      {
        if (v160 >= 0) {
          uint64_t v43 = (unsigned __int8 *)&v158;
        }
        else {
          uint64_t v43 = (unsigned __int8 *)v158;
        }
        if ((*((unsigned char *)&v163.__r_.__value_.__s + 23) & 0x80) != 0)
        {
          std::string::size_type v61 = (void *)v163.__r_.__value_.__r.__words[0];
          if (memcmp(v163.__r_.__value_.__l.__data_, v43, v163.__r_.__value_.__l.__size_))
          {
            operator delete(v61);
            goto LABEL_162;
          }
        }
        else if (*((unsigned char *)&v163.__r_.__value_.__s + 23))
        {
          int v44 = &v163;
          uint64_t v45 = HIBYTE(v163.__r_.__value_.__r.__words[2]);
          while (v44->__r_.__value_.__s.__data_[0] == *v43)
          {
            int v44 = (std::string *)((char *)v44 + 1);
            ++v43;
            if (!--v45) {
              goto LABEL_102;
            }
          }
          goto LABEL_123;
        }
LABEL_102:
        if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          int64_t v62 = HIBYTE(buf.__r_.__value_.__r.__words[2]);
        }
        else {
          int64_t v62 = buf.__r_.__value_.__l.__size_;
        }
        p_std::string buf = &buf;
        if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
          p_std::string buf = (std::string *)buf.__r_.__value_.__r.__words[0];
        }
        int v64 = (char *)p_buf + v62;
        if (v62 < 1)
        {
          xpc_object_t v71 = (char *)p_buf + v62;
        }
        else
        {
          size_t v65 = v62;
          __s = p_buf;
          uint64_t v66 = p_buf;
          do
          {
            uint64_t v67 = (char *)memchr(v66, 64, v65);
            if (!v67) {
              break;
            }
            if (*v67 == 64)
            {
              if (v67 != v64 && v67 - (char *)__s != -1) {
                goto LABEL_123;
              }
              break;
            }
            uint64_t v66 = (std::string *)(v67 + 1);
            size_t v65 = v64 - (char *)v66;
          }
          while (v64 - (char *)v66 >= 1);
          if (v62 >= 10)
          {
            xpc_object_t v73 = __s;
            do
            {
              xpc_object_t v71 = (char *)memchr(v73, 47, v62 - 9);
              if (!v71) {
                break;
              }
              if (*(void *)v71 == 0x4C503D455059542FLL && *((_WORD *)v71 + 4) == 20045) {
                goto LABEL_135;
              }
              xpc_object_t v73 = (std::string *)(v71 + 1);
              int64_t v62 = v64 - (char *)v73;
            }
            while (v64 - (char *)v73 > 9);
          }
          xpc_object_t v71 = v64;
LABEL_135:
          p_std::string buf = __s;
        }
        int64_t v75 = v71 - (char *)p_buf;
        BOOL v72 = v71 != v64 && v75 != -1;
        if ((v40 & 0x80) == 0)
        {
LABEL_124:
          if (v72) {
            goto LABEL_144;
          }
          goto LABEL_162;
        }
LABEL_143:
        operator delete(v163.__r_.__value_.__l.__data_);
        if (v72)
        {
LABEL_144:
          sub_100058DB0(&v163, "");
          sub_1004FD2F4((uint64_t)&__p[8], (long long *)&v163);
          if (SHIBYTE(v163.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v163.__r_.__value_.__l.__data_);
          }
          xpc_object_t v77 = sub_10004B96C(__p, (uint64_t)"+", 1);
          if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            xpc_object_t v78 = &buf;
          }
          else {
            xpc_object_t v78 = (std::string *)buf.__r_.__value_.__r.__words[0];
          }
          if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            std::string::size_type v79 = HIBYTE(buf.__r_.__value_.__r.__words[2]);
          }
          else {
            std::string::size_type v79 = buf.__r_.__value_.__l.__size_;
          }
          sub_10004B96C(v77, (uint64_t)v78, v79);
          sub_10004BC98((uint64_t)&__p[8], &v163);
          if ((v163.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            std::string v80 = &v163;
          }
          else {
            std::string v80 = (std::string *)v163.__r_.__value_.__r.__words[0];
          }
          sub_100CCA11C((uint64_t)v7, "From", (uint64_t)v80, 0);
          if (SHIBYTE(v163.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v163.__r_.__value_.__l.__data_);
          }
          std::string v81 = *v9;
          if (os_log_type_enabled(*v9, OS_LOG_TYPE_DEFAULT))
          {
            sub_10004BC98((uint64_t)&__p[8], v156);
            int v82 = *(_DWORD *)(a1 + 36);
            unsigned __int8 v83 = (void **)v156[0];
            if (v157 >= 0) {
              unsigned __int8 v83 = v156;
            }
            LODWORD(v163.__r_.__value_.__l.__data_) = 67109634;
            HIDWORD(v163.__r_.__value_.__r.__words[0]) = v36;
            LOWORD(v163.__r_.__value_.__r.__words[1]) = 2080;
            *(std::string::size_type *)((char *)&v163.__r_.__value_.__r.__words[1] + 2) = (std::string::size_type)v83;
            WORD1(v163.__r_.__value_.__r.__words[2]) = 1024;
            HIDWORD(v163.__r_.__value_.__r.__words[2]) = v82;
            _os_log_impl((void *)&_mh_execute_header, v81, OS_LOG_TYPE_DEFAULT, "#I Prepended '+' to address for prefix \"%u\" to form address [%s], MsgId: %u", (uint8_t *)&v163, 0x18u);
            if (v157 < 0) {
              operator delete(v156[0]);
            }
          }
        }
LABEL_162:
        if (SHIBYTE(v160) < 0) {
          operator delete(v158);
        }
        if (SHIBYTE(v168) < 0) {
          operator delete(v167[1]);
        }
        std::streambuf::~streambuf();
        std::ostream::~ostream();
        std::ios::~ios();
        if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(buf.__r_.__value_.__l.__data_);
        }
        goto LABEL_168;
      }
LABEL_123:
      BOOL v72 = 0;
      if ((v40 & 0x80) == 0) {
        goto LABEL_124;
      }
      goto LABEL_143;
    }
    xpc_object_t v25 = *v5;
    if (os_log_type_enabled(*v5, OS_LOG_TYPE_ERROR))
    {
      int v57 = *(_DWORD *)(a1 + 36);
      *(_DWORD *)std::string __p = 67109120;
      *(_DWORD *)&__p[4] = v57;
      _os_log_error_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_ERROR, "Failed to extract message from HTTP response, MsgId: %u", __p, 8u);
    }
    if (v155 == 2
      || (**a2 - 200) >= 0x64
      && ((*a2)[4] != -2
       || !(*(unsigned int (**)(void))(**(void **)(a1 + 160) + 232))(*(void *)(a1 + 160))))
    {
LABEL_284:
      uint64_t v120 = *(void *)(a1 + 128);
      uint64_t v121 = v155;
      sub_10003E168(&v136, (void *)(a1 + 16));
      (*(void (**)(uint64_t, uint64_t, uint64_t *))(*(void *)v120 + 16))(v120, v121, &v136);
      char v118 = v137;
      if (!v137)
      {
LABEL_262:
        xpc_object_t v24 = v152;
        if (!v152) {
          return;
        }
        goto LABEL_263;
      }
LABEL_261:
      sub_10004D2C8(v118);
      goto LABEL_262;
    }
    uint64_t v26 = *(void *)(a1 + 144);
    xpc_object_t v27 = *(std::__shared_weak_count **)(a1 + 152);
    if (v27)
    {
      atomic_fetch_add_explicit(&v27->__shared_owners_, 1uLL, memory_order_relaxed);
      if (!v26) {
        goto LABEL_86;
      }
      uint64_t v28 = *(void *)(a1 + 128);
      uint64_t v29 = *(unsigned int *)(a1 + 48);
      uint64_t v149 = v26;
      v150 = v27;
      atomic_fetch_add_explicit(&v27->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    else
    {
      if (!v26) {
        goto LABEL_86;
      }
      uint64_t v28 = *(void *)(a1 + 128);
      uint64_t v29 = *(unsigned int *)(a1 + 48);
      uint64_t v149 = *(void *)(a1 + 144);
      v150 = 0;
    }
    if (*(char *)(a1 + 287) < 0)
    {
      sub_10004FC84(__dst, *(void **)(a1 + 264), *(void *)(a1 + 272));
    }
    else
    {
      *(_OWORD *)std::string __dst = *(_OWORD *)(a1 + 264);
      uint64_t v148 = *(void *)(a1 + 280);
    }
    (*(void (**)(uint64_t, uint64_t, uint64_t *, const char *, void **))(*(void *)v28 + 48))(v28, v29, &v149, "Unrecognized", __dst);
    if (SHIBYTE(v148) < 0) {
      operator delete(__dst[0]);
    }
    if (v150) {
      sub_10004D2C8(v150);
    }
LABEL_86:
    if ((*a2)[4] != -2)
    {
LABEL_282:
      unsigned __int8 v155 = 1;
      if (v27) {
        sub_10004D2C8(v27);
      }
      goto LABEL_284;
    }
    int v47 = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 112));
    int v48 = v47;
    if (v49 < 0)
    {
      uint64_t v50 = (unsigned __int8 *)(v49 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v51 = 5381;
      do
      {
        uint64_t v49 = v51;
        unsigned int v52 = *v50++;
        uint64_t v51 = (33 * v51) ^ v52;
      }
      while (v52);
    }
    std::mutex::lock(v47);
    *(void *)std::string __p = v49;
    xpc_object_t v53 = sub_10004D37C(&v48[1].__m_.__sig, (unint64_t *)__p);
    if (v53)
    {
      uint64_t v55 = v53[3];
      int v54 = (std::__shared_weak_count *)v53[4];
      if (v54)
      {
        atomic_fetch_add_explicit(&v54->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v48);
        atomic_fetch_add_explicit(&v54->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v54);
        char v56 = 0;
        goto LABEL_95;
      }
    }
    else
    {
      uint64_t v55 = 0;
    }
    std::mutex::unlock(v48);
    int v54 = 0;
    char v56 = 1;
LABEL_95:
    if (!v55)
    {
      unsigned int v60 = *v5;
      if (os_log_type_enabled(v60, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)std::string __p = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v60, OS_LOG_TYPE_ERROR, "Failed to get analytics interface for MMS Send End.", __p, 2u);
      }
      goto LABEL_280;
    }
    buf.__r_.__value_.__r.__words[0] = 0;
    xpc_object_t v58 = xpc_dictionary_create(0, 0, 0);
    xpc_object_t v59 = v58;
    if (v58)
    {
      buf.__r_.__value_.__r.__words[0] = (std::string::size_type)v58;
    }
    else
    {
      xpc_object_t v59 = xpc_null_create();
      buf.__r_.__value_.__r.__words[0] = (std::string::size_type)v59;
      if (!v59)
      {
        xpc_object_t v68 = xpc_null_create();
        xpc_object_t v59 = 0;
        goto LABEL_267;
      }
    }
    if (xpc_get_type(v59) == (xpc_type_t)&_xpc_type_dictionary)
    {
      xpc_retain(v59);
LABEL_268:
      xpc_release(v59);
      unsigned int v119 = subscriber::simSlotAsInstance();
      xpc_object_t v145 = xpc_int64_create(v119);
      if (!v145) {
        xpc_object_t v145 = xpc_null_create();
      }
      *(void *)std::string __p = &buf;
      *(void *)&__p[8] = "subs_id";
      sub_100035E70((uint64_t)__p, &v145, &object);
      xpc_release(object);
      xpc_object_t object = 0;
      xpc_release(v145);
      xpc_object_t v145 = 0;
      xpc_object_t v143 = xpc_int64_create(16);
      if (!v143) {
        xpc_object_t v143 = xpc_null_create();
      }
      *(void *)std::string __p = &buf;
      *(void *)&__p[8] = "dwErrCode";
      sub_100035E70((uint64_t)__p, &v143, &v144);
      xpc_release(v144);
      xpc_object_t v144 = 0;
      xpc_release(v143);
      xpc_object_t v143 = 0;
      xpc_object_t v141 = xpc_int64_create(7);
      if (!v141) {
        xpc_object_t v141 = xpc_null_create();
      }
      *(void *)std::string __p = &buf;
      *(void *)&__p[8] = "ucState";
      sub_100035E70((uint64_t)__p, &v141, &v142);
      xpc_release(v142);
      xpc_object_t v142 = 0;
      xpc_release(v141);
      xpc_object_t v141 = 0;
      xpc_object_t v139 = xpc_int64_create(229);
      if (!v139) {
        xpc_object_t v139 = xpc_null_create();
      }
      *(void *)std::string __p = &buf;
      *(void *)&__p[8] = "wResultCode";
      sub_100035E70((uint64_t)__p, &v139, &v140);
      xpc_release(v140);
      xpc_object_t v140 = 0;
      xpc_release(v139);
      xpc_object_t v138 = (xpc_object_t)buf.__r_.__value_.__r.__words[0];
      xpc_object_t v139 = 0;
      if (buf.__r_.__value_.__r.__words[0]) {
        xpc_retain(buf.__r_.__value_.__l.__data_);
      }
      else {
        xpc_object_t v138 = xpc_null_create();
      }
      (*(void (**)(uint64_t, const char *, xpc_object_t *))(*(void *)v55 + 16))(v55, "metricCCMMSRetState", &v138);
      xpc_release(v138);
      xpc_object_t v138 = 0;
      xpc_release(buf.__r_.__value_.__l.__data_);
LABEL_280:
      if ((v56 & 1) == 0) {
        sub_10004D2C8(v54);
      }
      goto LABEL_282;
    }
    xpc_object_t v68 = xpc_null_create();
LABEL_267:
    buf.__r_.__value_.__r.__words[0] = (std::string::size_type)v68;
    goto LABEL_268;
  }
  xpc_object_t v21 = *v4;
  if (os_log_type_enabled(*v4, OS_LOG_TYPE_ERROR))
  {
    int v46 = *(_DWORD *)(a1 + 36);
    *(_DWORD *)std::string __p = 67109120;
    *(_DWORD *)&__p[4] = v46;
    _os_log_error_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "MMSFetchOperation failed, No http response. MsgId: %u", __p, 8u);
    uint64_t v22 = v155;
  }
  else
  {
    uint64_t v22 = 1;
  }
  uint64_t v23 = *(void *)(a1 + 128);
  sub_10003E168(&v153, (void *)(a1 + 16));
  (*(void (**)(uint64_t, uint64_t, uint64_t *))(*(void *)v23 + 16))(v23, v22, &v153);
  xpc_object_t v24 = v154;
  if (v154) {
LABEL_263:
  }
    sub_10004D2C8(v24);
}

void sub_100511A18(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

BOOL sub_100511CDC(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 40) >= *(_DWORD *)(a1 + 44)) {
    return 0;
  }
  time_t v2 = time(0);
  uint64_t v3 = *(void *)(a1 + 232);
  return !v3 || v2 <= *(void *)(a1 + 224) + v3;
}

const char *sub_100511D38()
{
  return "MMSFetch";
}

uint64_t sub_100511D44()
{
  return 1;
}

uint64_t sub_100511D4C()
{
  return 1;
}

uint64_t sub_100511D54(uint64_t a1)
{
  return *(void *)(a1 + 232);
}

void sub_100511D60()
{
}

void *sub_100511D74()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = off_1019DD4B8;
  return result;
}

void sub_100511DAC(uint64_t a1, void *a2)
{
  *a2 = off_1019DD4B8;
}

void sub_100511DD4(uint64_t a1, os_log_t *a2, os_signpost_id_t *a3)
{
  os_signpost_id_t v3 = *a3;
  if (*a3 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    uint64_t v4 = *a2;
    if (os_signpost_enabled(*a2))
    {
      *(_WORD *)BOOL v5 = 0;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v4, OS_SIGNPOST_INTERVAL_END, v3, "MobileTerminatedMMS", (const char *)&unk_1017DEDA7, v5, 2u);
    }
  }
}

uint64_t sub_100511E4C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100511E8C()
{
}

void sub_100511E9C()
{
}

uint64_t sub_100511EB0(uint64_t a1)
{
  return *(void *)(*(void *)(a1 + 8) + 192);
}

void sub_100511EBC()
{
}

void sub_100511FA4(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  if (v2) {
    operator delete();
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100511FD8(uint64_t a1, void *a2, NSObject **a3, void *a4, uint64_t a5)
{
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v18, kCtLoggingSystemName, "ps.sat");
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  int v10 = *a3;
  *(void *)(a1 + 24) = *a3;
  if (v10) {
    dispatch_retain(v10);
  }
  *(void *)(a1 + 32) = 0;
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v19, &v18);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 40), (const ctu::OsLogLogger *)v19);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v19);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v18);
  *(void *)a1 = off_1019DD590;
  *(void *)(a1 + 48) = *a2;
  uint64_t v11 = a2[1];
  *(void *)(a1 + 56) = v11;
  if (v11) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v11 + 8), 1uLL, memory_order_relaxed);
  }
  *(void *)(a1 + 64) = *a4;
  uint64_t v12 = a4[1];
  *(void *)(a1 + 72) = v12;
  if (v12) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v12 + 8), 1uLL, memory_order_relaxed);
  }
  *(void *)(a1 + 80) = a5;
  sub_100058DB0(&__p, "SatelliteControl");
  int v13 = *(NSObject **)(a1 + 24);
  int v15 = v13;
  if (v13) {
    dispatch_retain(v13);
  }
  ctu::RestModule::RestModule();
  if (v15) {
    dispatch_release(v15);
  }
  if (v17 < 0) {
    operator delete(__p);
  }
  *(unsigned char *)(a1 + 104) = 0;
  *(void *)(a1 + 108) = 0x300000000;
  *(_DWORD *)(a1 + 116) = 0;
  *(unsigned char *)(a1 + 120) = 0;
  *(void *)(a1 + 124) = 0;
  *(void *)(a1 + 140) = 0;
  *(void *)(a1 + 132) = 0;
  *(_DWORD *)(a1 + 148) = 0;
  return a1;
}

void sub_100512174(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, dispatch_object_t object, dispatch_object_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17, uint64_t a18, char a19)
{
  if (object) {
    dispatch_release(object);
  }
  if (a10) {
    dispatch_release(a10);
  }
  if (a16 < 0) {
    operator delete(__p);
  }
  uint64_t v23 = *(std::__shared_weak_count **)(v19 + 72);
  if (v23) {
    sub_10004D2C8(v23);
  }
  xpc_object_t v24 = *(std::__shared_weak_count **)(v19 + 56);
  if (v24) {
    sub_10004D2C8(v24);
  }
  ctu::OsLogLogger::~OsLogLogger(v21);
  sub_100087E88(v20);
  _Unwind_Resume(a1);
}

void *sub_100512200(void *a1)
{
  *a1 = off_1019DD590;
  int v2 = (std::__shared_weak_count *)a1[18];
  if (v2) {
    sub_10004D2C8(v2);
  }
  os_signpost_id_t v3 = (std::__shared_weak_count *)a1[12];
  if (v3) {
    sub_10004D2C8(v3);
  }
  uint64_t v4 = (std::__shared_weak_count *)a1[9];
  if (v4) {
    sub_10004D2C8(v4);
  }
  BOOL v5 = (std::__shared_weak_count *)a1[7];
  if (v5) {
    sub_10004D2C8(v5);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 5));
  sub_100087E88(a1 + 1);
  return a1;
}

void sub_100512288(void *a1)
{
  sub_100512200(a1);

  operator delete();
}

uint64_t sub_1005122C0(uint64_t a1)
{
  return ctu::RestModule::disconnect((ctu::RestModule *)(a1 + 88));
}

BOOL sub_1005122C8(uint64_t a1)
{
  int v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 64));
    *(_DWORD *)std::string buf = 136315394;
    *(void *)&uint8_t buf[4] = v3;
    __int16 v18 = 2080;
    uint64_t v19 = " ";
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I %s%sinitializing", buf, 0x16u);
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 48));
  BOOL v5 = ServiceMap;
  if (v6 < 0)
  {
    uint64_t v7 = (unsigned __int8 *)(v6 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v8 = 5381;
    do
    {
      uint64_t v6 = v8;
      unsigned int v9 = *v7++;
      uint64_t v8 = (33 * v8) ^ v9;
    }
    while (v9);
  }
  std::mutex::lock(ServiceMap);
  *(void *)std::string buf = v6;
  int v10 = sub_10004D37C(&v5[1].__m_.__sig, (unint64_t *)buf);
  if (v10)
  {
    uint64_t v12 = v10[3];
    uint64_t v11 = (std::__shared_weak_count *)v10[4];
    if (v11)
    {
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v5);
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v11);
      goto LABEL_11;
    }
  }
  else
  {
    uint64_t v12 = 0;
  }
  std::mutex::unlock(v5);
  uint64_t v11 = 0;
LABEL_11:
  int v13 = *(std::__shared_weak_count **)(a1 + 144);
  *(void *)(a1 + 136) = v12;
  *(void *)(a1 + 144) = v11;
  if (v13) {
    sub_10004D2C8(v13);
  }
  Registry::createRestModuleOneTimeUseConnection(&v15, *(Registry **)(a1 + 48));
  ctu::RestModule::connect();
  if (v16) {
    sub_10004D2C8(v16);
  }
  sub_1005124A8(a1);
  sub_100512790(a1);
  BOOL result = sub_100512D5C(a1);
  *(unsigned char *)(a1 + 120) = result;
  return result;
}

void sub_100512478(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

const void **sub_1005124A8(uint64_t a1)
{
  *(_DWORD *)(a1 + 124) = 0;
  uint64_t v22 = 0;
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 48));
  uint64_t v3 = ServiceMap;
  if (v4 < 0)
  {
    BOOL v5 = (unsigned __int8 *)(v4 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v6 = 5381;
    do
    {
      uint64_t v4 = v6;
      unsigned int v7 = *v5++;
      uint64_t v6 = (33 * v6) ^ v7;
    }
    while (v7);
  }
  std::mutex::lock(ServiceMap);
  *(void *)std::string buf = v4;
  uint64_t v8 = sub_10004D37C(&v3[1].__m_.__sig, (unint64_t *)buf);
  if (v8)
  {
    uint64_t v10 = v8[3];
    unsigned int v9 = (std::__shared_weak_count *)v8[4];
    if (v9)
    {
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v3);
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v9);
      char v11 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v10 = 0;
  }
  std::mutex::unlock(v3);
  unsigned int v9 = 0;
  char v11 = 1;
LABEL_9:
  (*(void (**)(const void **__return_ptr, uint64_t, uint64_t, const __CFString *, void, void, uint64_t))(*(void *)v10 + 64))(&v21, v10, **(void **)(a1 + 64) + 24, @"SatelliteUserPreference", kPhoneServicesWalletDomain, 0, 1);
  sub_1000842D0(&v22, &v21);
  sub_1000577C4(&v21);
  if ((v11 & 1) == 0) {
    sub_10004D2C8(v9);
  }
  if (v22) {
    int v13 = sub_100081E58;
  }
  else {
    int v13 = 0;
  }
  if (v13)
  {
    *(_DWORD *)std::string buf = 0;
    ctu::cf::assign((ctu::cf *)buf, v22, v12);
    int v14 = *(_DWORD *)buf;
    if (*(int *)buf > 0)
    {
      int v15 = 2;
LABEL_22:
      *(_DWORD *)(a1 + 124) = v15;
      return sub_1000570E8((const void **)&v22);
    }
    int v16 = sub_100512B40(*(unsigned int *)(**(void **)(a1 + 64) + 52), *(void *)(a1 + 136));
    int v17 = -v14;
    if (v16 <= -v14)
    {
      int v15 = 1;
      goto LABEL_22;
    }
    __int16 v18 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v19 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 64));
      *(_DWORD *)std::string buf = 136315906;
      *(void *)&uint8_t buf[4] = v19;
      __int16 v24 = 2080;
      xpc_object_t v25 = " ";
      __int16 v26 = 1024;
      int v27 = v17;
      __int16 v28 = 1024;
      int v29 = v16;
      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#I %s%sSwitch: user preference has ver:%d vs current:%d, force reset to default", buf, 0x22u);
    }
    (*(void (**)(uint64_t))(*(void *)a1 + 96))(a1);
  }
  return sub_1000570E8((const void **)&v22);
}

void sub_10051273C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000570E8((const void **)va);
  _Unwind_Resume(a1);
}

BOOL sub_100512790(uint64_t a1)
{
  *(void *)std::string buf = 0;
  (*(void (**)(const void **__return_ptr))(**(void **)(a1 + 136) + 96))(&v10);
  sub_1000057AC(buf, &v10);
  sub_1000577C4(&v10);
  LOBYTE(v10) = 0;
  ctu::cf::assign((ctu::cf *)&v10, *(BOOL **)buf, v2);
  int v3 = v10;
  sub_100062778((const void **)buf);
  int v4 = *(unsigned __int8 *)(a1 + 104);
  if (v4 != v3)
  {
    BOOL v5 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v6 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 64));
      uint64_t v7 = asStringBool(*(unsigned char *)(a1 + 104));
      uint64_t v8 = asStringBool(v3 != 0);
      *(_DWORD *)std::string buf = 136315906;
      *(void *)&uint8_t buf[4] = v6;
      __int16 v12 = 2080;
      int v13 = " ";
      __int16 v14 = 2080;
      uint64_t v15 = v7;
      __int16 v16 = 2080;
      uint64_t v17 = v8;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I %s%sSupports capability is changing from %s to %s", buf, 0x2Au);
    }
    *(unsigned char *)(a1 + 104) = v3;
  }
  return v4 != v3;
}

void sub_100512934(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sub_100062778((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100512960(uint64_t a1)
{
  CFBooleanRef v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 64));
    int v5 = 136315394;
    uint64_t v6 = v3;
    __int16 v7 = 2080;
    uint64_t v8 = " ";
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I %s%sstarted", (uint8_t *)&v5, 0x16u);
  }
  return (*(uint64_t (**)(uint64_t, void, uint64_t))(*(void *)a1 + 104))(a1, 0, 1);
}

uint64_t sub_100512A4C(uint64_t a1)
{
  CFBooleanRef v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 64));
    int v5 = 136315394;
    uint64_t v6 = v3;
    __int16 v7 = 2080;
    uint64_t v8 = " ";
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I %s%sSwitch: review provisioning on migration", (uint8_t *)&v5, 0x16u);
  }
  sub_1005124A8(a1);
  return (*(uint64_t (**)(uint64_t, void, void))(*(void *)a1 + 104))(a1, 0, 0);
}

unint64_t sub_100512B40(uint64_t a1, uint64_t a2)
{
  CFTypeRef cf = 0;
  (*(void (**)(CFTypeRef *__return_ptr, uint64_t, uint64_t, uint64_t, const __CFString *, void, void))(*(void *)a2 + 96))(&cf, a2, a1, 1, @"ResetSatelliteAfterUpgrade", 0, 0);
  if (cf) {
    CFBooleanRef v2 = sub_100080934;
  }
  else {
    CFBooleanRef v2 = 0;
  }
  if (!v2) {
    goto LABEL_12;
  }
  CFTypeID v3 = CFGetTypeID(cf);
  CFTypeID TypeID = CFNumberGetTypeID();
  unint64_t v5 = (unint64_t)cf;
  if (v3 != TypeID)
  {
    unsigned __int8 v12 = 0;
    if (!cf) {
      goto LABEL_13;
    }
    CFTypeID v8 = CFGetTypeID(cf);
    if (v8 == CFBooleanGetTypeID())
    {
      ctu::cf::assign((ctu::cf *)&v12, (BOOL *)v5, v9);
      unint64_t v5 = v12;
      goto LABEL_13;
    }
    goto LABEL_12;
  }
  unsigned int v13 = 0;
  if (cf)
  {
    CFTypeID v6 = CFGetTypeID(cf);
    if (v6 == CFNumberGetTypeID())
    {
      ctu::cf::assign((ctu::cf *)&v13, (int *)v5, v7);
      unint64_t v5 = v13;
      goto LABEL_13;
    }
LABEL_12:
    unint64_t v5 = 0;
  }
LABEL_13:
  sub_1000577C4(&cf);
  return v5;
}

void sub_100512C60(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9)
{
}

BOOL sub_100512C74(uint64_t a1, uint64_t a2)
{
  CFBooleanRef BOOLean = 0;
  (*(void (**)(const void **__return_ptr, uint64_t, uint64_t, uint64_t, const __CFString *, void, void))(*(void *)a2 + 96))(&v5, a2, a1, 1, @"ShowSatelliteSwitch", 0, 0);
  sub_1000057AC(&BOOLean, &v5);
  sub_1000577C4(&v5);
  if (BOOLean) {
    CFBooleanRef v2 = sub_100084B4C;
  }
  else {
    CFBooleanRef v2 = 0;
  }
  if (v2) {
    BOOL v3 = CFBooleanGetValue(BOOLean) == 1;
  }
  else {
    BOOL v3 = 0;
  }
  sub_100062778((const void **)&BOOLean);
  return v3;
}

void sub_100512D38(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100062778((const void **)va);
  _Unwind_Resume(a1);
}

BOOL sub_100512D5C(uint64_t a1)
{
  BOOL v2 = sub_100512C74(*(unsigned int *)(**(void **)(a1 + 64) + 52), *(void *)(a1 + 136));
  uint64_t v3 = sub_100512F14(*(unsigned int *)(**(void **)(a1 + 64) + 52), *(void *)(a1 + 136), v2);
  if (v2 && (int v4 = *(_DWORD *)(a1 + 124)) != 0)
  {
    unint64_t v5 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v6 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 64));
      uint64_t v7 = *(int *)(a1 + 124);
      if (v7 > 2) {
        CFTypeID v8 = (char *)&unk_10161656E;
      }
      else {
        CFTypeID v8 = off_1019DD7E0[v7];
      }
      int v12 = 136315650;
      uint64_t v13 = v6;
      __int16 v14 = 2080;
      uint64_t v15 = " ";
      __int16 v16 = 2080;
      uint64_t v17 = v8;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I %s%sSwitch: Using manual preference %s", (uint8_t *)&v12, 0x20u);
      int v4 = *(_DWORD *)(a1 + 124);
    }
    return v4 == 2;
  }
  else
  {
    CFBooleanRef v9 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v10 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 64));
      int v12 = 136315650;
      uint64_t v13 = v10;
      __int16 v14 = 2080;
      uint64_t v15 = " ";
      __int16 v16 = 1024;
      LODWORD(v17) = v3;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I %s%sSwitch: Using carrier default %d", (uint8_t *)&v12, 0x1Cu);
    }
  }
  return v3;
}

uint64_t sub_100512F14(uint64_t a1, uint64_t a2, int a3)
{
  (*(void (**)(CFTypeRef *__return_ptr, uint64_t, uint64_t, uint64_t, const __CFString *, const CFBooleanRef, void))(*(void *)a2 + 96))(&cf, a2, a1, 1, @"EnableSatelliteByDefault", kCFBooleanTrue, 0);
  int v4 = (BOOL *)cf;
  uint64_t v5 = a3 ^ 1u;
  char v10 = v5;
  if (cf)
  {
    CFTypeID v6 = CFGetTypeID(cf);
    if (v6 == CFBooleanGetTypeID())
    {
      ctu::cf::assign((ctu::cf *)&v10, v4, v7);
      uint64_t v5 = v10 != 0;
    }
  }
  sub_1000577C4(&cf);
  return v5;
}

void sub_100512FE0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9)
{
}

uint64_t sub_100512FF4(uint64_t a1)
{
  BOOL v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 64));
    *(_DWORD *)uint64_t v15 = 136315394;
    *(void *)&v15[4] = v3;
    __int16 v16 = 2080;
    uint64_t v17 = " ";
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I %s%sSwitch: Reset", v15, 0x16u);
  }
  *(_DWORD *)(a1 + 124) = 0;
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 48));
  uint64_t v5 = ServiceMap;
  if (v6 < 0)
  {
    CFBooleanRef v7 = (unsigned __int8 *)(v6 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v8 = 5381;
    do
    {
      uint64_t v6 = v8;
      unsigned int v9 = *v7++;
      uint64_t v8 = (33 * v8) ^ v9;
    }
    while (v9);
  }
  std::mutex::lock(ServiceMap);
  *(void *)uint64_t v15 = v6;
  char v10 = sub_10004D37C(&v5[1].__m_.__sig, (unint64_t *)v15);
  if (v10)
  {
    uint64_t v12 = v10[3];
    char v11 = (std::__shared_weak_count *)v10[4];
    if (v11)
    {
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v5);
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v11);
      char v13 = 0;
      goto LABEL_11;
    }
  }
  else
  {
    uint64_t v12 = 0;
  }
  std::mutex::unlock(v5);
  char v11 = 0;
  char v13 = 1;
LABEL_11:
  (*(void (**)(uint64_t, uint64_t, const __CFString *, void, void, uint64_t))(*(void *)v12 + 72))(v12, **(void **)(a1 + 64) + 24, @"SatelliteUserPreference", kPhoneServicesWalletDomain, 0, 1);
  if ((v13 & 1) == 0) {
    sub_10004D2C8(v11);
  }
  return (*(uint64_t (**)(uint64_t, void, void))(*(void *)a1 + 104))(a1, 0, 0);
}

void sub_1005131E8(_Unwind_Exception *exception_object)
{
  if ((v1 & 1) == 0) {
    sub_10004D2C8(v2);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_100513218(uint64_t a1)
{
  return *(_DWORD *)(a1 + 128) == 2;
}

unint64_t sub_100513228(uint64_t a1)
{
  return *(unsigned int *)(a1 + 124) | ((unint64_t)*(unsigned __int8 *)(a1 + 120) << 32);
}

uint64_t sub_100513238(uint64_t result)
{
  if (*(unsigned char *)(**(void **)(result + 64) + 48)) {
    phoneservices::submitSwitchAnalytics();
  }
  return result;
}

uint64_t sub_100513274(uint64_t a1)
{
  BOOL v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 64));
    int v5 = 136315394;
    uint64_t v6 = v3;
    __int16 v7 = 2080;
    uint64_t v8 = " ";
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I %s%spersonality config changed", (uint8_t *)&v5, 0x16u);
  }
  sub_1005124A8(a1);
  return (*(uint64_t (**)(uint64_t, void, void))(*(void *)a1 + 104))(a1, 0, 0);
}

uint64_t sub_100513368(uint64_t a1)
{
  BOOL v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 64));
    int v5 = 136315394;
    uint64_t v6 = v3;
    __int16 v7 = 2080;
    uint64_t v8 = " ";
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I %s%spersonal wallet changed", (uint8_t *)&v5, 0x16u);
  }
  sub_1005124A8(a1);
  return (*(uint64_t (**)(uint64_t, void, void))(*(void *)a1 + 104))(a1, 0, 0);
}

uint64_t sub_10051345C(uint64_t a1, int a2, int a3)
{
  if (a2)
  {
    *(_DWORD *)(a1 + 108) = 2;
    if (*(_DWORD *)(a1 + 112) != a3)
    {
      int v5 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v6 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 64));
        if ((a3 - 1) > 5) {
          __int16 v7 = "???";
        }
        else {
          __int16 v7 = off_1019DD7B0[a3 - 1];
        }
        int v11 = 136315650;
        uint64_t v12 = v6;
        __int16 v13 = 2080;
        __int16 v14 = " ";
        __int16 v15 = 2080;
        __int16 v16 = v7;
        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I %s%sentitlement supported and changed to %s", (uint8_t *)&v11, 0x20u);
      }
      *(_DWORD *)(a1 + 112) = a3;
    }
  }
  else
  {
    uint64_t v8 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v9 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 64));
      int v11 = 136315394;
      uint64_t v12 = v9;
      __int16 v13 = 2080;
      __int16 v14 = " ";
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I %s%sentitlement is not supported", (uint8_t *)&v11, 0x16u);
    }
    *(void *)(a1 + 108) = 0x200000001;
  }
  return (*(uint64_t (**)(uint64_t, void, void))(*(void *)a1 + 104))(a1, 0, 0);
}

const void **sub_100513610@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  CFMutableDictionaryRef theDict = 0;
  int v3 = *(_DWORD *)(a1 + 132);
  if ((v3 - 2) < 2)
  {
    Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    if (Mutable)
    {
      CFMutableDictionaryRef v10 = theDict;
      CFMutableDictionaryRef theDict = Mutable;
      CFMutableDictionaryRef v15 = v10;
      sub_10005717C((const void **)&v15);
    }
    CFDictionarySetValue(theDict, kCTCapabilityCanChangeSetting, kCFBooleanTrue);
    char v8 = 1;
    char v6 = 1;
    char v7 = 1;
  }
  else if (v3 == 4)
  {
    int v11 = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    if (v11)
    {
      CFMutableDictionaryRef v12 = theDict;
      CFMutableDictionaryRef theDict = v11;
      CFMutableDictionaryRef v15 = v12;
      sub_10005717C((const void **)&v15);
    }
    CFDictionarySetValue(theDict, kCTCapabilityCanChangeSettingEnableStillProvisioning, kCFBooleanTrue);
    char v7 = 0;
    char v8 = 1;
    char v6 = 1;
  }
  else if (v3 == 5)
  {
    int v4 = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    if (v4)
    {
      CFMutableDictionaryRef v5 = theDict;
      CFMutableDictionaryRef theDict = v4;
      CFMutableDictionaryRef v15 = v5;
      sub_10005717C((const void **)&v15);
    }
    CFDictionarySetValue(theDict, kCTCapabilityCannotChangeSettingNeedToCallCarrier, kCFBooleanTrue);
    char v6 = 0;
    char v7 = 0;
    char v8 = 1;
  }
  else
  {
    char v8 = 0;
    char v6 = 0;
    char v7 = 0;
  }
  *(unsigned char *)a2 = v8;
  *(unsigned char *)(a2 + 1) = v6;
  *(unsigned char *)(a2 + 2) = v7;
  sub_10004EFE4((void *)(a2 + 8), (CFTypeRef *)&theDict);
  return sub_10005717C((const void **)&theDict);
}

void sub_1005137C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9)
{
}

const void **sub_1005137D4@<X0>(_DWORD *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v5 = 0;
  char v6 = 0;
  (*(void (**)(uint64_t *__return_ptr))(*(void *)a1 + 56))(&v5);
  *(unsigned char *)a2 = a1[32] == 2;
  sub_100058198((const void **)(a2 + 8), &v6);
  return sub_100057D78(&v6);
}

void sub_100513864(uint64_t a1, BOOL a2)
{
  int v4 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 64));
    uint64_t v6 = asStringBool(a2);
    uint64_t v7 = *(int *)(a1 + 132);
    if (v7 > 5) {
      char v8 = "???";
    }
    else {
      char v8 = off_1019DD7F8[v7];
    }
    *(_DWORD *)std::string buf = 136315906;
    *(void *)&uint8_t buf[4] = v5;
    __int16 v38 = 2080;
    std::string::size_type v39 = " ";
    __int16 v40 = 2080;
    uint64_t v41 = v6;
    __int16 v42 = 2080;
    uint64_t v43 = v8;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I %s%ssetEnabled(%s): Current 'can set' status: %s", buf, 0x2Au);
  }
  unsigned int v9 = *(_DWORD *)(a1 + 132);
  BOOL v10 = v9 > 5;
  int v11 = (1 << v9) & 0x23;
  if (v10 || v11 == 0)
  {
    if (a2) {
      int v13 = 2;
    }
    else {
      int v13 = 1;
    }
    if (*(_DWORD *)(a1 + 124) == v13)
    {
LABEL_38:
      (*(void (**)(uint64_t, uint64_t, void))(*(void *)a1 + 104))(a1, 1, 0);
      return;
    }
    __int16 v14 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v15 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 64));
      uint64_t v16 = *(int *)(a1 + 124);
      if (v16 > 2) {
        uint64_t v17 = (char *)&unk_10161656E;
      }
      else {
        uint64_t v17 = off_1019DD7E0[v16];
      }
      __int16 v18 = "Disabled";
      *(_DWORD *)std::string buf = 136315906;
      *(void *)&uint8_t buf[4] = v15;
      std::string::size_type v39 = " ";
      __int16 v38 = 2080;
      if (a2) {
        __int16 v18 = "Enabled";
      }
      __int16 v40 = 2080;
      uint64_t v41 = (uint64_t)v17;
      __int16 v42 = 2080;
      uint64_t v43 = v18;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I %s%sSwitch: changed user preference from %s to %s", buf, 0x2Au);
    }
    int v19 = sub_100512B40(*(unsigned int *)(**(void **)(a1 + 64) + 52), *(void *)(a1 + 136));
    if (a2) {
      int v20 = v19 + 1;
    }
    else {
      int v20 = -v19;
    }
    ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 48));
    uint64_t v22 = ServiceMap;
    if (v23 < 0)
    {
      __int16 v24 = (unsigned __int8 *)(v23 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v25 = 5381;
      do
      {
        uint64_t v23 = v25;
        unsigned int v26 = *v24++;
        uint64_t v25 = (33 * v25) ^ v26;
      }
      while (v26);
    }
    std::mutex::lock(ServiceMap);
    *(void *)std::string buf = v23;
    int v27 = sub_10004D37C(&v22[1].__m_.__sig, (unint64_t *)buf);
    if (v27)
    {
      uint64_t v29 = v27[3];
      __int16 v28 = (std::__shared_weak_count *)v27[4];
      if (v28)
      {
        atomic_fetch_add_explicit(&v28->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v22);
        atomic_fetch_add_explicit(&v28->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v28);
        char v30 = 0;
LABEL_33:
        uint64_t v31 = **(void **)(a1 + 64);
        CFNumberRef v36 = 0;
        *(_DWORD *)std::string buf = v20;
        CFNumberRef v32 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, buf);
        if (v32)
        {
          CFNumberRef v33 = v36;
          CFNumberRef v36 = v32;
          *(void *)std::string buf = v33;
          sub_1000570E8((const void **)buf);
        }
        CFNumberRef v34 = v36;
        CFNumberRef v35 = v36;
        CFNumberRef v36 = 0;
        sub_1000570E8((const void **)&v36);
        (*(void (**)(uint64_t, uint64_t, const __CFString *, CFNumberRef, void, void, uint64_t, void, CFNumberRef))(*(void *)v29 + 48))(v29, v31 + 24, @"SatelliteUserPreference", v34, kPhoneServicesWalletDomain, 0, 1, 0, v35);
        sub_1000570E8((const void **)&v35);
        if ((v30 & 1) == 0) {
          sub_10004D2C8(v28);
        }
        *(_DWORD *)(a1 + 124) = v13;
        *(unsigned char *)(a1 + 120) = sub_100512D5C(a1);
        goto LABEL_38;
      }
    }
    else
    {
      uint64_t v29 = 0;
    }
    std::mutex::unlock(v22);
    __int16 v28 = 0;
    char v30 = 1;
    goto LABEL_33;
  }
}

void sub_100513C10(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9)
{
  sub_1000570E8(&a9);
  if ((v10 & 1) == 0) {
    sub_10004D2C8(v9);
  }
  _Unwind_Resume(a1);
}

void sub_100513C58(uint64_t a1, int a2, char a3)
{
  BOOL v6 = sub_100512790(a1);
  int v7 = *(unsigned __int8 *)(a1 + 104);
  int v8 = 1;
  if (*(unsigned char *)(a1 + 104))
  {
    if (*(_DWORD *)(a1 + 112) == 2) {
      int v8 = 2;
    }
    else {
      int v8 = 1;
    }
  }
  int v9 = *(_DWORD *)(a1 + 116);
  if (v9 != v8)
  {
    char v10 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      char v11 = a3;
      uint64_t v12 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 64));
      *(_DWORD *)std::string buf = 136315906;
      *(void *)&uint8_t buf[4] = v12;
      a3 = v11;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = " ";
      __int16 v45 = 2080;
      uint64_t v46 = asString();
      __int16 v47 = 2080;
      uint64_t v48 = asString();
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I %s%sNetwork support is changing from %s to %s", buf, 0x2Au);
      int v7 = *(unsigned __int8 *)(a1 + 104);
    }
    *(_DWORD *)(a1 + 116) = v8;
  }
  if (v7)
  {
    switch(*(_DWORD *)(a1 + 112))
    {
      case 1:
        int v13 = 3;
        break;
      case 2:
        if (!sub_100512C74(*(unsigned int *)(**(void **)(a1 + 64) + 52), *(void *)(a1 + 136)))
        {
          __int16 v14 = *(NSObject **)(a1 + 40);
          if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v15 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 64));
            *(_DWORD *)std::string buf = 136315394;
            *(void *)&uint8_t buf[4] = v15;
            *(_WORD *)&unsigned char buf[12] = 2080;
            *(void *)&buf[14] = " ";
            _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I %s%sEither switch support is not present or it is set to false", buf, 0x16u);
          }
          goto LABEL_19;
        }
        int v13 = 2;
        break;
      case 3:
      case 4:
      case 6:
        int v13 = 5;
        break;
      case 5:
        int v13 = 4;
        break;
      default:
        int v13 = 0;
        break;
    }
  }
  else
  {
LABEL_19:
    int v13 = 1;
  }
  int v16 = *(_DWORD *)(a1 + 132);
  if (v16 != v13)
  {
    uint64_t v17 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v18 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 64));
      uint64_t v19 = *(int *)(a1 + 132);
      if (v19 > 5) {
        int v20 = "???";
      }
      else {
        int v20 = off_1019DD7F8[v19];
      }
      xpc_object_t v21 = off_1019DD7F8[v13];
      *(_DWORD *)std::string buf = 136315906;
      *(void *)&uint8_t buf[4] = v18;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = " ";
      __int16 v45 = 2080;
      uint64_t v46 = (uint64_t)v20;
      __int16 v47 = 2080;
      uint64_t v48 = (uint64_t)v21;
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I %s%sSupports switch is changing from %s to %s", buf, 0x2Au);
    }
    *(_DWORD *)(a1 + 132) = v13;
  }
  int v22 = *(unsigned __int8 *)(a1 + 120);
  int v23 = sub_100512D5C(a1);
  *(unsigned char *)(a1 + 120) = v23;
  BOOL v24 = v22 != v23;
  uint64_t v25 = **(PersonalityInfo ***)(a1 + 64);
  if (*((unsigned char *)v25 + 48))
  {
    int v26 = *(_DWORD *)(a1 + 116);
    if ((v23 & (v26 == 2)) != 0) {
      int v27 = 2;
    }
    else {
      int v27 = 1;
    }
    if (v26) {
      int v28 = v27;
    }
    else {
      int v28 = 0;
    }
  }
  else
  {
    int v28 = 0;
  }
  if (v28 != *(_DWORD *)(a1 + 128))
  {
    int v43 = v9;
    int v29 = a2;
    BOOL v30 = v6;
    char v31 = a3;
    CFNumberRef v32 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v33 = PersonalityInfo::logPrefix(v25);
      uint64_t v34 = asString();
      *(_DWORD *)std::string buf = 136315650;
      *(void *)&uint8_t buf[4] = v33;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = " ";
      __int16 v45 = 2080;
      uint64_t v46 = v34;
      _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, "#I %s%sfeature re-evaluated to %s", buf, 0x20u);
    }
    *(_DWORD *)(a1 + 128) = v28;
    BOOL v24 = 1;
    a3 = v31;
    BOOL v6 = v30;
    a2 = v29;
    int v9 = v43;
  }
  if (v16 != v13) {
    BOOL v24 = 1;
  }
  if (v9 != v8) {
    BOOL v24 = 1;
  }
  BOOL v35 = v24 || v6;
  sub_100A2FD3C(*(void *)(a1 + 80), 5, a2);
  if (v35 || (a3 & 1) != 0 || a2)
  {
    char v36 = *(unsigned char *)(a1 + 104);
    char v37 = *(unsigned char *)(a1 + 120);
    BOOL v38 = *(_DWORD *)(a1 + 116) == 2;
    int v39 = *(_DWORD *)(a1 + 124);
    int v40 = *(_DWORD *)(a1 + 128);
    uint64_t v41 = *(void *)(a1 + 80);
    __int16 v42 = (char *)operator new(0x30uLL);
    *((void *)v42 + 1) = 0;
    *((void *)v42 + 2) = 0;
    *(void *)__int16 v42 = off_1019DD770;
    *(_WORD *)(v42 + 25) = 0;
    v42[27] = 0;
    *((_DWORD *)v42 + 7) = v39;
    v42[32] = v37;
    *(_WORD *)(v42 + 33) = 0;
    v42[35] = 0;
    v42[36] = v38;
    *(_WORD *)(v42 + 37) = 0;
    v42[39] = 0;
    *((_DWORD *)v42 + 10) = v40;
    *(void *)&uint8_t buf[8] = v42;
    v42[24] = v36;
    *(void *)std::string buf = v42 + 24;
    sub_100A321D8(v41, 5, (uint64_t **)buf);
    if (*(void *)&buf[8]) {
      sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
    }
  }
}

void sub_1005140F0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
}

void sub_100514128(uint64_t a1)
{
  BOOL v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 64));
    uint64_t v4 = **(void **)(a1 + 64);
    int v7 = *(const char **)(v4 + 24);
    uint64_t v5 = (const char *)(v4 + 24);
    BOOL v6 = v7;
    uint64_t v8 = *((unsigned __int8 *)v5 + 23);
    int v9 = (char)v8;
    if ((v8 & 0x80u) != 0) {
      uint64_t v8 = *((void *)v5 + 1);
    }
    if (v9 < 0) {
      uint64_t v5 = v6;
    }
    if (!v8) {
      uint64_t v5 = "<invalid>";
    }
    int v32 = 136315650;
    uint64_t v33 = v3;
    __int16 v34 = 2080;
    BOOL v35 = " ";
    __int16 v36 = 2080;
    uint64_t v37 = (uint64_t)v5;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I %s%s=|= dump SatelliteControl '%s'", (uint8_t *)&v32, 0x20u);
    BOOL v2 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v10 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 64));
    uint64_t v11 = asStringBool(*(unsigned char *)(a1 + 104));
    int v32 = 136315650;
    uint64_t v33 = v10;
    __int16 v34 = 2080;
    BOOL v35 = " ";
    __int16 v36 = 2080;
    uint64_t v37 = v11;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I %s%s | Carrier support        : %s", (uint8_t *)&v32, 0x20u);
    BOOL v2 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v12 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 64));
    uint64_t v13 = asString();
    unsigned int v14 = *(_DWORD *)(a1 + 112) - 1;
    if (v14 > 5) {
      uint64_t v15 = "???";
    }
    else {
      uint64_t v15 = off_1019DD7B0[v14];
    }
    int v32 = 136315906;
    uint64_t v33 = v12;
    __int16 v34 = 2080;
    BOOL v35 = " ";
    __int16 v36 = 2080;
    uint64_t v37 = v13;
    __int16 v38 = 2080;
    int v39 = v15;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I %s%s | Entitlement support    : %s state:%s", (uint8_t *)&v32, 0x2Au);
    BOOL v2 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v16 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 64));
    uint64_t v17 = asString();
    int v32 = 136315650;
    uint64_t v33 = v16;
    __int16 v34 = 2080;
    BOOL v35 = " ";
    __int16 v36 = 2080;
    uint64_t v37 = v17;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I %s%s | Account/Network support: %s", (uint8_t *)&v32, 0x20u);
    BOOL v2 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v18 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 64));
    uint64_t v19 = asStringBool(*(unsigned char *)(a1 + 120));
    int v32 = 136315650;
    uint64_t v33 = v18;
    __int16 v34 = 2080;
    BOOL v35 = " ";
    __int16 v36 = 2080;
    uint64_t v37 = v19;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I %s%s | Actual switch state    : %s", (uint8_t *)&v32, 0x20u);
    BOOL v2 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v20 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 64));
    uint64_t v21 = *(int *)(a1 + 124);
    if (v21 > 2) {
      int v22 = (char *)&unk_10161656E;
    }
    else {
      int v22 = off_1019DD7E0[v21];
    }
    int v32 = 136315650;
    uint64_t v33 = v20;
    __int16 v34 = 2080;
    BOOL v35 = " ";
    __int16 v36 = 2080;
    uint64_t v37 = (uint64_t)v22;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I %s%s | User preference        : %s", (uint8_t *)&v32, 0x20u);
    BOOL v2 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v23 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 64));
    uint64_t v24 = *(int *)(a1 + 132);
    if (v24 > 5) {
      uint64_t v25 = "???";
    }
    else {
      uint64_t v25 = off_1019DD7F8[v24];
    }
    int v32 = 136315650;
    uint64_t v33 = v23;
    __int16 v34 = 2080;
    BOOL v35 = " ";
    __int16 v36 = 2080;
    uint64_t v37 = (uint64_t)v25;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I %s%s | CanSet state           : %s", (uint8_t *)&v32, 0x20u);
    BOOL v2 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v26 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 64));
    uint64_t v27 = asString();
    int v32 = 136315650;
    uint64_t v33 = v26;
    __int16 v34 = 2080;
    BOOL v35 = " ";
    __int16 v36 = 2080;
    uint64_t v37 = v27;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I %s%s | Final capability state : %s", (uint8_t *)&v32, 0x20u);
    BOOL v2 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v28 = PersonalityInfo::logPrefix(**(PersonalityInfo ***)(a1 + 64));
    BOOL v29 = sub_100512C74(*(unsigned int *)(**(void **)(a1 + 64) + 52), *(void *)(a1 + 136));
    char v30 = sub_100512F14(*(unsigned int *)(**(void **)(a1 + 64) + 52), *(void *)(a1 + 136), v29);
    uint64_t v31 = asStringBool(v30);
    int v32 = 136315650;
    uint64_t v33 = v28;
    __int16 v34 = 2080;
    BOOL v35 = " ";
    __int16 v36 = 2080;
    uint64_t v37 = v31;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I %s%s | EnableByDefault        : %s", (uint8_t *)&v32, 0x20u);
  }
}

uint64_t sub_100514640()
{
  return 0;
}

void sub_100514648(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_100514714(void *a1)
{
  __cxa_begin_catch(a1);
  dispatch_barrier_async_f(v1[3], v1, (dispatch_function_t)sub_1005147EC);
  __cxa_rethrow();
}

void sub_10051473C(_Unwind_Exception *a1)
{
}

void sub_100514754(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_10051478C(uint64_t a1)
{
}

uint64_t sub_1005147A8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_1005147EC(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void sub_100514818(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1019DD770;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100514838(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1019DD770;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void RegistrationController::setupAwdCallbacks_sync(RegistrationController *this)
{
  sub_10017B514();
  sub_10017B514();
  if (capabilities::ct::supports5G(v1)) {
    sub_10017B514();
  }
}

void sub_1005149C4(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 0x40000000;
  v3[2] = sub_100514AD0;
  v3[3] = &unk_1019DD828;
  v3[4] = v1;
  uint64_t v6 = 0;
  int v7 = 0;
  sub_10003E168(&v6, (void *)(v1 + 8));
  BOOL v2 = *(NSObject **)(v1 + 24);
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  block[2] = sub_100059504;
  block[3] = &unk_1019DD970;
  void block[5] = v6;
  uint64_t v5 = v7;
  if (v7) {
    atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  void block[4] = v3;
  dispatch_async(v2, block);
  if (v5) {
    sub_10004D2C8(v5);
  }
  if (v7) {
    sub_10004D2C8(v7);
  }
}

uint64_t sub_100514AD0()
{
  return sub_100514DA8((wis::MetricFactory *)0x80019);
}

void sub_100514B48(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 0x40000000;
  v3[2] = sub_100514C54;
  v3[3] = &unk_1019DD868;
  v3[4] = v1;
  uint64_t v6 = 0;
  int v7 = 0;
  sub_10003E168(&v6, (void *)(v1 + 8));
  BOOL v2 = *(NSObject **)(v1 + 24);
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  block[2] = sub_100059504;
  block[3] = &unk_1019DD970;
  void block[5] = v6;
  uint64_t v5 = v7;
  if (v7) {
    atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  void block[4] = v3;
  dispatch_async(v2, block);
  if (v5) {
    sub_10004D2C8(v5);
  }
  if (v7) {
    sub_10004D2C8(v7);
  }
}

uint64_t sub_100514C54()
{
  return sub_10051513C((wis::MetricFactory *)0x80067);
}

void sub_100514CCC(uint64_t a1)
{
  uint64_t v1 = (void *)(*(void *)(a1 + 32) + 8);
  v2[0] = 0;
  v2[1] = 0;
  sub_10003E168(v2, v1);
  operator new();
}

uint64_t sub_100514DA8(wis::MetricFactory *a1)
{
  unsigned int v1 = a1;
  SharedMetricFactory = (wis::MetricFactory *)wis::MetricFactory::getSharedMetricFactory(a1);
  uint64_t v3 = wis::MetricFactory::newMetricContainerWithIdentifier(SharedMetricFactory, v1);
  if (v3)
  {
    uint64_t v4 = (wis::MetricContainer *)v3;
    uint64_t v5 = sub_10001C8F4(8);
    uint64_t v7 = *v5;
    uint64_t v6 = (std::__shared_weak_count *)v5[1];
    if (v6) {
      atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    if (v7) {
      operator new();
    }
    if (v6) {
      sub_10004D2C8(v6);
    }
    wis::MetricContainer::~MetricContainer(v4);
    operator delete();
  }
  return 0;
}

void sub_100514F04(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  sub_100129880((wis::MetricContainer **)va, 0);
  _Unwind_Resume(a1);
}

uint64_t sub_100514F88(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 32) + 64;
  LODWORD(__str.__r_.__value_.__l.__data_) = 1;
  uint64_t v4 = *(void *)*sub_1000FD774(v3, (int *)&__str);
  int v5 = (*(uint64_t (**)(void))(v4 + 464))();
  *(_DWORD *)(a2 + 36) |= 1u;
  *(_DWORD *)(a2 + 16) = v5;
  int v10 = 1;
  uint64_t v6 = *(void *)*sub_1000FD774(v3, &v10);
  (*(void (**)(std::string *__return_ptr))(v6 + 456))(&__str);
  *(_DWORD *)(a2 + 36) |= 2u;
  uint64_t v7 = *(std::string **)(a2 + 8);
  if (v7 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString) {
    operator new();
  }
  std::string::operator=(v7, &__str);
  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__str.__r_.__value_.__l.__data_);
  }
  LODWORD(__str.__r_.__value_.__l.__data_) = 1;
  uint64_t v8 = sub_1000FD774(v3, (int *)&__str);
  uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)*v8 + 64))(*v8);
  *(_DWORD *)(a2 + 36) |= 4u;
  *(unsigned char *)(a2 + 20) = result != 0;
  return result;
}

void sub_100515120(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10051513C(wis::MetricFactory *a1)
{
  unsigned int v1 = a1;
  SharedMetricFactory = (wis::MetricFactory *)wis::MetricFactory::getSharedMetricFactory(a1);
  uint64_t v3 = wis::MetricFactory::newMetricContainerWithIdentifier(SharedMetricFactory, v1);
  if (v3)
  {
    uint64_t v4 = (wis::MetricContainer *)v3;
    int v5 = sub_10001C8F4(8);
    uint64_t v7 = *v5;
    uint64_t v6 = (std::__shared_weak_count *)v5[1];
    if (v6) {
      atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    if (v7) {
      operator new();
    }
    if (v6) {
      sub_10004D2C8(v6);
    }
    wis::MetricContainer::~MetricContainer(v4);
    operator delete();
  }
  return 0;
}

void sub_100515298(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  sub_100129880((wis::MetricContainer **)va, 0);
  _Unwind_Resume(a1);
}

const void **sub_10051531C(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 32);
  int v9 = 0;
  (*(void (**)(uint8_t *__return_ptr))(**(void **)(v3 + 248) + 40))(buf);
  sub_1000057AC(&v9, (CFTypeRef *)buf);
  sub_1000577C4((const void **)buf);
  if (v9) {
    uint64_t v4 = sub_100084B4C;
  }
  else {
    uint64_t v4 = 0;
  }
  if (v4) {
    int v5 = *(unsigned char *)(v3 + 376) == 0;
  }
  else {
    int v5 = 2;
  }
  uint64_t v6 = *(NSObject **)(v3 + 40);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v7 = off_1019DD9A0[v5];
    *(_DWORD *)std::string buf = 136315138;
    uint64_t v11 = v7;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Submitting AWD metric for voice roaming with the state being: %s", buf, 0xCu);
  }
  *(_DWORD *)(a2 + 24) |= 2u;
  *(_DWORD *)(a2 + 16) = v5;
  return sub_100062778(&v9);
}

void sub_10051547C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sub_1000577C4((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100515498(wis::MetricFactory *a1)
{
  unsigned int v1 = a1;
  SharedMetricFactory = (wis::MetricFactory *)wis::MetricFactory::getSharedMetricFactory(a1);
  uint64_t v3 = wis::MetricFactory::newMetricContainerWithIdentifier(SharedMetricFactory, v1);
  if (v3)
  {
    uint64_t v4 = (wis::MetricContainer *)v3;
    int v5 = sub_10001C8F4(8);
    uint64_t v7 = *v5;
    uint64_t v6 = (std::__shared_weak_count *)v5[1];
    if (v6) {
      atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    if (v7) {
      operator new();
    }
    if (v6) {
      sub_10004D2C8(v6);
    }
    wis::MetricContainer::~MetricContainer(v4);
    operator delete();
  }
  return 0;
}

void sub_1005155F4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  sub_100129880((wis::MetricContainer **)va, 0);
  _Unwind_Resume(a1);
}

void sub_100515678(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 32);
  int v5 = *(unsigned __int8 *)(a1 + 44);
  *(_DWORD *)(a2 + 44) |= 2u;
  *(_DWORD *)(a2 + 16) = v5;
  int v6 = subscriber::simSlotAsInstance();
  int v7 = *(_DWORD *)(a2 + 44);
  *(_DWORD *)(a2 + 44) = v7 | 4;
  *(_DWORD *)(a2 + 20) = v6;
  uint64_t v8 = *(void *)(v4 + 736);
  if (v8)
  {
    uint64_t v9 = *(unsigned int *)(a1 + 40);
    uint64_t v10 = v4 + 736;
    do
    {
      int v11 = *(_DWORD *)(v8 + 32);
      BOOL v12 = v11 < (int)v9;
      if (v11 >= (int)v9) {
        uint64_t v13 = (uint64_t *)v8;
      }
      else {
        uint64_t v13 = (uint64_t *)(v8 + 8);
      }
      if (!v12) {
        uint64_t v10 = v8;
      }
      uint64_t v8 = *v13;
    }
    while (*v13);
    if (v10 != v4 + 736 && (int)v9 >= *(_DWORD *)(v10 + 32))
    {
      *(_DWORD *)(a2 + 44) = v7 | 0xC;
      unsigned int v14 = *(std::string **)(a2 + 24);
      if (v14 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString) {
        operator new();
      }
      std::string::operator=(v14, (const std::string *)(v10 + 40));
      *(_DWORD *)(a2 + 44) |= 0x10u;
      uint64_t v15 = *(std::string **)(a2 + 32);
      if (v15 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString) {
        operator new();
      }
      std::string::operator=(v15, (const std::string *)(v10 + 64));
      return;
    }
  }
  else
  {
    uint64_t v9 = *(unsigned int *)(a1 + 40);
  }
  uint64_t v16 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v4 + 48) + 16))(*(void *)(v4 + 48), v9);
  if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v17 = 0;
    _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#N Missing home PLMN", v17, 2u);
  }
}

const void **sub_10051583C(const void **result, int *a2)
{
  BOOL v2 = result[4];
  uint64_t v3 = (void *)v2[8];
  if (v3 != v2 + 9)
  {
    uint64_t v26 = (wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(a2 + 4);
    int v5 = (char *)(v2 + 92);
    do
    {
      int v6 = a2[7];
      uint64_t v7 = a2[6];
      if ((int)v7 >= v6)
      {
        if (v6 == a2[8])
        {
          wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve(v26, v6 + 1);
          int v6 = a2[7];
        }
        a2[7] = v6 + 1;
        operator new();
      }
      uint64_t v8 = *((void *)a2 + 2);
      a2[6] = v7 + 1;
      uint64_t v9 = *(void *)(v8 + 8 * v7);
      if (v9)
      {
        CFBooleanRef v28 = 0;
        (*(void (**)(CFBooleanRef *__return_ptr))(*(void *)v2[31] + 80))(&v28);
        if (v28 == kCFBooleanFalse)
        {
          int v11 = *(NSObject **)(*(uint64_t (**)(void, void))(*(void *)v2[6] + 16))(v2[6], *((unsigned int *)v3 + 8));
          if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)std::string buf = 0;
            unsigned int v10 = 2;
            _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I Carrier does not show 5G Standalone switch", buf, 2u);
          }
          else
          {
            unsigned int v10 = 2;
          }
        }
        else
        {
          *(void *)std::string buf = (*(uint64_t (**)(void))(*(void *)v3[5] + 592))(v3[5]);
          unsigned int v10 = (RatSelectionType::getSelection((RatSelectionType *)buf) >> 6) & 1;
        }
        *(_DWORD *)(v9 + 44) |= 2u;
        *(_DWORD *)(v9 + 16) = v10;
        int v12 = subscriber::simSlotAsInstance();
        int v13 = *(_DWORD *)(v9 + 44);
        *(_DWORD *)(v9 + 44) = v13 | 4;
        *(_DWORD *)(v9 + 20) = v12;
        unsigned int v14 = *(char **)v5;
        uint64_t v15 = *((unsigned int *)v3 + 8);
        if (!*(void *)v5) {
          goto LABEL_24;
        }
        uint64_t v16 = (char *)(v2 + 92);
        do
        {
          int v17 = *((_DWORD *)v14 + 8);
          BOOL v18 = v17 < (int)v15;
          if (v17 >= (int)v15) {
            uint64_t v19 = (char **)v14;
          }
          else {
            uint64_t v19 = (char **)(v14 + 8);
          }
          if (!v18) {
            uint64_t v16 = v14;
          }
          unsigned int v14 = *v19;
        }
        while (*v19);
        if (v16 != v5 && (int)v15 >= *((_DWORD *)v16 + 8))
        {
          *(_DWORD *)(v9 + 44) = v13 | 0xC;
          uint64_t v21 = *(std::string **)(v9 + 24);
          if (v21 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString) {
            operator new();
          }
          std::string::operator=(v21, (const std::string *)(v16 + 40));
          *(_DWORD *)(v9 + 44) |= 0x10u;
          int v22 = *(std::string **)(v9 + 32);
          if (v22 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString) {
            operator new();
          }
          std::string::operator=(v22, (const std::string *)(v16 + 64));
        }
        else
        {
LABEL_24:
          uint64_t v20 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(*(void *)v2[6] + 16))(v2[6], v15);
          if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)std::string buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#N Missing home PLMN", buf, 2u);
          }
        }
        uint64_t result = sub_1000577C4((const void **)&v28);
      }
      uint64_t v23 = (void *)v3[1];
      if (v23)
      {
        do
        {
          uint64_t v24 = v23;
          uint64_t v23 = (void *)*v23;
        }
        while (v23);
      }
      else
      {
        do
        {
          uint64_t v24 = (void *)v3[2];
          BOOL v25 = *v24 == (void)v3;
          uint64_t v3 = v24;
        }
        while (!v25);
      }
      uint64_t v3 = v24;
    }
    while (v24 != v2 + 9);
  }
  return result;
}

void sub_100515BE4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  sub_1000577C4((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100515C28(wis::MetricFactory *a1)
{
  unsigned int v1 = a1;
  SharedMetricFactory = (wis::MetricFactory *)wis::MetricFactory::getSharedMetricFactory(a1);
  uint64_t v3 = wis::MetricFactory::newMetricContainerWithIdentifier(SharedMetricFactory, v1);
  if (v3)
  {
    uint64_t v4 = (wis::MetricContainer *)v3;
    int v5 = sub_10001C8F4(8);
    uint64_t v7 = *v5;
    int v6 = (std::__shared_weak_count *)v5[1];
    if (v6) {
      atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    if (v7) {
      operator new();
    }
    if (v6) {
      sub_10004D2C8(v6);
    }
    wis::MetricContainer::~MetricContainer(v4);
    operator delete();
  }
  return 0;
}

void sub_100515D84(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  sub_100129880((wis::MetricContainer **)va, 0);
  _Unwind_Resume(a1);
}

void sub_100515E08(uint64_t a1, int *a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v3 = *(void **)(v2 + 856);
  uint64_t v4 = (void *)(v2 + 864);
  if (v3 != (void *)(v2 + 864))
  {
    BOOL v29 = (wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(a2 + 4);
    int v6 = (uint64_t *)(v2 + 736);
    do
    {
      int v7 = a2[7];
      uint64_t v8 = a2[6];
      if ((int)v8 >= v7)
      {
        if (v7 == a2[8])
        {
          wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve(v29, v7 + 1);
          int v7 = a2[7];
        }
        a2[7] = v7 + 1;
        operator new();
      }
      uint64_t v9 = *((void *)a2 + 2);
      a2[6] = v8 + 1;
      uint64_t v10 = *(void *)(v9 + 8 * v8);
      if (v10)
      {
        int v11 = subscriber::simSlotAsInstance();
        int v12 = *(_DWORD *)(v10 + 60);
        *(_DWORD *)(v10 + 60) = v12 | 2;
        *(_DWORD *)(v10 + 32) = v11;
        uint64_t v13 = *v6;
        uint64_t v14 = *((unsigned int *)v3 + 7);
        if (!*v6) {
          goto LABEL_19;
        }
        uint64_t v15 = v2 + 736;
        do
        {
          int v16 = *(_DWORD *)(v13 + 32);
          BOOL v17 = v16 < (int)v14;
          if (v16 >= (int)v14) {
            BOOL v18 = (uint64_t *)v13;
          }
          else {
            BOOL v18 = (uint64_t *)(v13 + 8);
          }
          if (!v17) {
            uint64_t v15 = v13;
          }
          uint64_t v13 = *v18;
        }
        while (*v18);
        if ((uint64_t *)v15 != v6 && (int)v14 >= *(_DWORD *)(v15 + 32))
        {
          *(_DWORD *)(v10 + 60) = v12 | 6;
          uint64_t v20 = *(std::string **)(v10 + 16);
          if (v20 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString) {
            operator new();
          }
          std::string::operator=(v20, (const std::string *)(v15 + 40));
          *(_DWORD *)(v10 + 60) |= 8u;
          uint64_t v21 = *(std::string **)(v10 + 24);
          if (v21 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString) {
            operator new();
          }
          std::string::operator=(v21, (const std::string *)(v15 + 64));
          uint64_t v4 = (void *)(v2 + 864);
        }
        else
        {
LABEL_19:
          uint64_t v19 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), v14);
          if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)std::string buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#E Missing home PLMN", buf, 2u);
          }
        }
        char v22 = *((unsigned char *)v3 + 32);
        int v23 = *(_DWORD *)(v10 + 60);
        *(_DWORD *)(v10 + 60) = v23 | 0x10;
        *(unsigned char *)(v10 + 36) = v22;
        uint64_t v24 = *((unsigned int *)v3 + 9);
        *(_DWORD *)(v10 + 60) = v23 | 0x70;
        *(unsigned char *)(v10 + 37) = *((unsigned char *)v3 + 40);
        uint64_t v25 = *((unsigned int *)v3 + 11);
        *(_DWORD *)(v10 + 60) = v23 | 0xF0;
        *(void *)(v10 + 40) = v24;
        *(void *)(v10 + 48) = v25;
      }
      uint64_t v26 = (void *)v3[1];
      if (v26)
      {
        do
        {
          uint64_t v27 = v26;
          uint64_t v26 = (void *)*v26;
        }
        while (v26);
      }
      else
      {
        do
        {
          uint64_t v27 = (void *)v3[2];
          BOOL v28 = *v27 == (void)v3;
          uint64_t v3 = v27;
        }
        while (!v28);
      }
      uint64_t v3 = v27;
    }
    while (v27 != v4);
  }
}

void sub_1005160D8()
{
}

void sub_1005160FC(wis::MetricFactory *a1)
{
  int v7 = a1;
  uint64_t v1 = **(void **)a1;
  uint64_t v8 = _NSConcreteStackBlock;
  uint64_t v9 = 0x40000000;
  uint64_t v10 = sub_10051583C;
  int v11 = &unk_1019DD928;
  uint64_t v12 = v1;
  SharedMetricFactory = (wis::MetricFactory *)wis::MetricFactory::getSharedMetricFactory(a1);
  uint64_t v3 = (wis::MetricContainer *)wis::MetricFactory::newMetricContainerWithIdentifier(SharedMetricFactory, 0x8012Cu);
  uint64_t v13 = v3;
  if (v3)
  {
    uint64_t v4 = sub_10001C8F4(8);
    uint64_t v6 = *v4;
    int v5 = (std::__shared_weak_count *)v4[1];
    if (v5) {
      atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    if (v6) {
      operator new();
    }
    if (v5) {
      sub_10004D2C8(v5);
    }
    if (v3)
    {
      wis::MetricContainer::~MetricContainer(v3);
      operator delete();
    }
  }
  operator delete();
}

void sub_1005162B0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  if (v7) {
    sub_10004D2C8(v7);
  }
  sub_100129880((wis::MetricContainer **)va, 0);
  operator delete();
}

void *sub_10051635C(void *a1)
{
  uint64_t v2 = (ctu::OsLogLogger *)(a1 + 1);
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v4, kCtLoggingSystemName, "cu.policy.ne");
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v5, &v4);
  ctu::OsLogLogger::OsLogLogger(v2, (const ctu::OsLogLogger *)v5);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v5);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v4);
  *a1 = off_1019DD9C8;
  a1[2] = 0;
  return a1;
}

void sub_10051640C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v4 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)va1);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)va);
  NetworkPolicyDriverInterface::~NetworkPolicyDriverInterface(v2);
  _Unwind_Resume(a1);
}

void sub_100516440(uint64_t *a1)
{
  *a1 = (uint64_t)off_1019DD9C8;
  uint64_t v2 = (ctu::OsLogLogger *)(a1 + 1);
  uint64_t v3 = a1 + 2;
  sub_1005167CC(a1 + 2, 0);
  sub_1005167CC(v3, 0);
  ctu::OsLogLogger::~OsLogLogger(v2);

  NetworkPolicyDriverInterface::~NetworkPolicyDriverInterface((NetworkPolicyDriverInterface *)a1);
}

uint64_t *sub_1005164C0(uint64_t a1)
{
  return sub_1005167CC((uint64_t *)(a1 + 16), 0);
}

void sub_1005164D0(uint64_t *a1)
{
  sub_100516440(a1);

  operator delete();
}

void sub_100516508(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (void *)(a1 + 16);
  if (!*(void *)(a1 + 16)) {
    sub_100A2887C();
  }
  int v5 = *(NSObject **)(a1 + 8);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    sub_1000E8F34(*(std::string **)a2, (std::string *)(a2 + 8), ", ", 2uLL, &__p);
    uint64_t v6 = (__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
       ? &__p
       : (std::string *)__p.__r_.__value_.__r.__words[0];
    *(_DWORD *)std::string buf = 136446210;
    uint64_t v19 = v6;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Denying network access to %{public}s", buf, 0xCu);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
  }
  uint64_t v9 = *(std::string **)a2;
  int v7 = (std::string *)(a2 + 8);
  uint64_t v8 = v9;
  if (v9 == v7) {
    goto LABEL_26;
  }
  char v10 = 0;
  do
  {
    p_std::string::size_type size = &v8[1].__r_.__value_.__l.__size_;
    if ((*(uint64_t (**)(void, std::string::size_type *))(*(void *)*v4 + 16))(*v4, &v8[1].__r_.__value_.__l.__size_))
    {
      char v10 = 1;
    }
    else
    {
      uint64_t v12 = *(NSObject **)(a1 + 8);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
      {
        if (v8[2].__r_.__value_.__s.__data_[7] < 0) {
          p_std::string::size_type size = (std::string::size_type *)*p_size;
        }
        LODWORD(__p.__r_.__value_.__l.__data_) = 136446210;
        *(std::string::size_type *)((char *)__p.__r_.__value_.__r.__words + 4) = (std::string::size_type)p_size;
        _os_log_error_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "Condition not added for %{public}s", (uint8_t *)&__p, 0xCu);
      }
    }
    std::string::size_type size = (std::string *)v8->__r_.__value_.__l.__size_;
    if (size)
    {
      do
      {
        uint64_t v14 = size;
        std::string::size_type size = (std::string *)size->__r_.__value_.__r.__words[0];
      }
      while (size);
    }
    else
    {
      do
      {
        uint64_t v14 = (std::string *)v8->__r_.__value_.__r.__words[2];
        BOOL v15 = v14->__r_.__value_.__r.__words[0] == (void)v8;
        uint64_t v8 = v14;
      }
      while (!v15);
    }
    uint64_t v8 = v14;
  }
  while (v14 != v7);
  if ((v10 & 1) == 0)
  {
LABEL_26:
    int v16 = *(NSObject **)(a1 + 8);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
    {
      LOWORD(__p.__r_.__value_.__l.__data_) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "No drop policies added", (uint8_t *)&__p, 2u);
    }
  }
  else
  {
    (*(void (**)(void))(*(void *)*v4 + 32))();
  }
}

uint64_t *sub_1005167CC(uint64_t *result, uint64_t a2)
{
  uint64_t v2 = *result;
  *uint64_t result = a2;
  if (v2)
  {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
    (*(void (**)(uint64_t))(*(void *)v2 + 32))(v2);
    uint64_t v3 = *(uint64_t (**)(uint64_t))(*(void *)v2 + 8);
    return (uint64_t *)v3(v2);
  }
  return result;
}

void sub_100516890(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  operator new();
}

const void **sub_10051691C(uint64_t a1, int a2, unsigned int a3)
{
  int v8 = a2;
  uint64_t v7 = sub_100C895B8(a3);
  uint64_t v4 = *(void ***)(a1 + 8);
  v9[0] = off_1019DDB90;
  v9[1] = &v8;
  xpc_object_t v9[2] = &v7;
  void v9[3] = v9;
  sub_100043ED0((uint64_t)v9, *v4);
  sub_100043E48(v9);
  return sub_1000558F4((const void **)&v7);
}

void sub_1005169DC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, const void *);
  uint64_t v5 = va_arg(va1, void);
  sub_100043E48((uint64_t *)va1);
  sub_1000558F4((const void **)va);
  _Unwind_Resume(a1);
}

void *sub_100516A00(uint64_t a1, int a2, char a3)
{
  int v7 = a2;
  char v6 = a3;
  uint64_t v3 = *(void ***)(a1 + 8);
  v8[0] = off_1019DDC10;
  v8[1] = &v7;
  _DWORD v8[2] = &v6;
  v8[3] = v8;
  sub_100043ED0((uint64_t)v8, *v3);
  return sub_100043E48(v8);
}

void sub_100516AAC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100043E48((uint64_t *)va);
  _Unwind_Resume(a1);
}

const void **sub_100516AC8(uint64_t a1, int a2, unsigned int a3)
{
  int v8 = a2;
  uint64_t v7 = sub_100C895B8(a3);
  uint64_t v4 = *(void ***)(a1 + 8);
  v9[0] = off_1019DDC90;
  v9[1] = &v8;
  xpc_object_t v9[2] = &v7;
  void v9[3] = v9;
  sub_100043ED0((uint64_t)v9, *v4);
  sub_100043E48(v9);
  return sub_1000558F4((const void **)&v7);
}

void sub_100516B88(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, const void *);
  uint64_t v5 = va_arg(va1, void);
  sub_100043E48((uint64_t *)va1);
  sub_1000558F4((const void **)va);
  _Unwind_Resume(a1);
}

const void **sub_100516BAC(uint64_t a1, int a2, unsigned int a3)
{
  int v8 = a2;
  uint64_t v7 = sub_100C895B8(a3);
  uint64_t v4 = *(void ***)(a1 + 8);
  v9[0] = off_1019DDD10;
  v9[1] = &v8;
  xpc_object_t v9[2] = &v7;
  void v9[3] = v9;
  sub_100043ED0((uint64_t)v9, *v4);
  sub_100043E48(v9);
  return sub_1000558F4((const void **)&v7);
}

void sub_100516C6C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, const void *);
  uint64_t v5 = va_arg(va1, void);
  sub_100043E48((uint64_t *)va1);
  sub_1000558F4((const void **)va);
  _Unwind_Resume(a1);
}

void *sub_100516C90(uint64_t a1, int a2, char a3)
{
  int v7 = a2;
  char v6 = a3;
  uint64_t v3 = *(void ***)(a1 + 8);
  v8[0] = off_1019DDD90;
  v8[1] = &v7;
  _DWORD v8[2] = &v6;
  v8[3] = v8;
  sub_100043ED0((uint64_t)v8, *v3);
  return sub_100043E48(v8);
}

void sub_100516D3C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100043E48((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *sub_100516D58(uint64_t a1, int a2)
{
  int v5 = a2;
  uint64_t v2 = *(void ***)(a1 + 8);
  v6[0] = off_1019DDE10;
  v6[1] = &v5;
  void v6[3] = v6;
  sub_100043ED0((uint64_t)v6, *v2);
  return sub_100043E48(v6);
}

void sub_100516DFC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100043E48((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *sub_100516E18(uint64_t a1)
{
  uint64_t v1 = *(void ***)(a1 + 8);
  v4[0] = off_1019DDE90;
  double v4[3] = v4;
  sub_100043ED0((uint64_t)v4, *v1);
  return sub_100043E48(v4);
}

void sub_100516EB4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100043E48((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *sub_100516ED0(uint64_t a1, int a2)
{
  int v5 = a2;
  uint64_t v2 = *(void ***)(a1 + 8);
  v6[0] = off_1019DDF10;
  v6[1] = &v5;
  void v6[3] = v6;
  sub_100043ED0((uint64_t)v6, *v2);
  return sub_100043E48(v6);
}

void sub_100516F74(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100043E48((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *sub_100516F90(uint64_t a1, int a2)
{
  int v5 = a2;
  uint64_t v2 = *(void ***)(a1 + 8);
  v6[0] = off_1019DDF90;
  v6[1] = &v5;
  void v6[3] = v6;
  sub_100043ED0((uint64_t)v6, *v2);
  return sub_100043E48(v6);
}

void sub_100517034(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100043E48((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *sub_100517050(uint64_t a1, int a2, __int16 a3)
{
  int v7 = a2;
  __int16 v6 = a3;
  uint64_t v3 = *(void ***)(a1 + 8);
  v8[0] = off_1019DE010;
  v8[1] = &v7;
  _DWORD v8[2] = &v6;
  v8[3] = v8;
  sub_100043ED0((uint64_t)v8, *v3);
  return sub_100043E48(v8);
}

void sub_1005170FC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100043E48((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *sub_100517118(uint64_t a1, int a2, uint64_t a3)
{
  int v6 = a2;
  uint64_t v3 = *(void ***)(a1 + 8);
  v7[0] = off_1019DE090;
  v7[1] = &v6;
  v7[2] = a3;
  double v7[3] = v7;
  sub_100043ED0((uint64_t)v7, *v3);
  return sub_100043E48(v7);
}

void sub_1005171BC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100043E48((uint64_t *)va);
  _Unwind_Resume(a1);
}

void sub_1005171D8(CTXPCSubscriberNotificationInterface *this)
{
  *(void *)this = off_1019DDA88;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }

  CTXPCSubscriberNotificationInterface::~CTXPCSubscriberNotificationInterface(this);
}

void sub_100517234(CTXPCSubscriberNotificationInterface *this)
{
  *(void *)this = off_1019DDA88;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  CTXPCSubscriberNotificationInterface::~CTXPCSubscriberNotificationInterface(this);

  operator delete();
}

void sub_1005172A4(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_10051730C(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100517348(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100517380(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_1005173B0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

void sub_1005173F8()
{
}

__n128 sub_10051740C(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_1019DDB90;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_100517458(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019DDB90;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100517488(uint64_t a1, id *a2)
{
  id v4 = *a2;
  uint64_t v3 = +[CTXPCPlaceholder simSlot:**(unsigned int **)(a1 + 8)];
  [v4 simStatusDidChange:v3 status:**(void **)(a1 + 16)];
}

void sub_100517504(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t sub_100517524(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100517564()
{
}

void sub_100517574()
{
}

__n128 sub_100517588(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_1019DDC10;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_1005175D4(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019DDC10;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100517604(uint64_t a1, id *a2)
{
  id v4 = *a2;
  uint64_t v3 = +[CTXPCPlaceholder simSlot:**(unsigned int **)(a1 + 8)];
  [v4 simLockSaveRequestDidComplete:v3 success:**(unsigned __int8 **)(a1 + 16)];
}

void sub_100517680(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1005176A0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1005176E0()
{
}

void sub_1005176F0()
{
}

__n128 sub_100517704(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_1019DDC90;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_100517750(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019DDC90;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100517780(uint64_t a1, id *a2)
{
  id v4 = *a2;
  uint64_t v3 = +[CTXPCPlaceholder simSlot:**(unsigned int **)(a1 + 8)];
  [v4 simPinEntryErrorDidOccur:v3 status:**(void **)(a1 + 16)];
}

void sub_1005177FC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t sub_10051781C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10051785C()
{
}

void sub_10051786C()
{
}

__n128 sub_100517880(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_1019DDD10;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_1005178CC(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019DDD10;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_1005178FC(uint64_t a1, id *a2)
{
  id v4 = *a2;
  uint64_t v3 = +[CTXPCPlaceholder simSlot:**(unsigned int **)(a1 + 8)];
  [v4 simPukEntryErrorDidOccur:v3 status:**(void **)(a1 + 16)];
}

void sub_100517978(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t sub_100517998(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1005179D8()
{
}

void sub_1005179E8()
{
}

__n128 sub_1005179FC(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_1019DDD90;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_100517A48(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019DDD90;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100517A78(uint64_t a1, id *a2)
{
  id v4 = *a2;
  uint64_t v3 = +[CTXPCPlaceholder simSlot:**(unsigned int **)(a1 + 8)];
  [v4 simPinChangeRequestDidComplete:v3 success:**(unsigned __int8 **)(a1 + 16)];
}

void sub_100517AF4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t sub_100517B14(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100517B54()
{
}

void sub_100517B64()
{
}

void *sub_100517B78(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_1019DDE10;
  result[1] = v3;
  return result;
}

uint64_t sub_100517BC0(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019DDE10;
  a2[1] = v2;
  return result;
}

void sub_100517BEC(uint64_t a1, id *a2)
{
  id v8 = *a2;
  id v3 = objc_alloc((Class)CTServiceDescriptor);
  int v4 = **(_DWORD **)(a1 + 8);
  if (v4 == 1) {
    uint64_t v5 = 1;
  }
  else {
    uint64_t v5 = 2 * (v4 == 2);
  }
  int v6 = +[NSNumber numberWithInteger:v5];
  id v7 = [v3 initWithDomain:1 instance:v6];
  [v8 authTokenChanged:v7];
}

void sub_100517C9C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  uint64_t v12 = v11;

  _Unwind_Resume(a1);
}

uint64_t sub_100517CCC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100517D0C()
{
}

void sub_100517D1C()
{
}

void *sub_100517D30()
{
  __n128 result = operator new(0x10uLL);
  *__n128 result = off_1019DDE90;
  return result;
}

void sub_100517D68(uint64_t a1, void *a2)
{
  *a2 = off_1019DDE90;
}

id sub_100517D90(uint64_t a1, id *a2)
{
  return [*a2 shortLabelsDidChange];
}

uint64_t sub_100517D98(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_100517DD8()
{
}

void sub_100517DE8()
{
}

void *sub_100517DFC(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_1019DDF10;
  result[1] = v3;
  return result;
}

uint64_t sub_100517E44(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019DDF10;
  a2[1] = v2;
  return result;
}

void sub_100517E70(uint64_t a1, id *a2)
{
  id v4 = *a2;
  uint64_t v3 = +[CTXPCPlaceholder simSlot:**(unsigned int **)(a1 + 8)];
  [v4 subscriberCountryCodeDidChange:v3];
}

void sub_100517EE4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t sub_100517F04(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100517F44()
{
}

void sub_100517F54()
{
}

void *sub_100517F68(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_1019DDF90;
  result[1] = v3;
  return result;
}

uint64_t sub_100517FB0(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019DDF90;
  a2[1] = v2;
  return result;
}

void sub_100517FDC(uint64_t a1, id *a2)
{
  id v4 = *a2;
  uint64_t v3 = +[CTXPCPlaceholder simSlot:**(unsigned int **)(a1 + 8)];
  [v4 userDefaultVoiceSlotDidChange:v3];
}

void sub_100518050(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t sub_100518070(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1005180B0()
{
}

void sub_1005180C0()
{
}

__n128 sub_1005180D4(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_1019DE010;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_100518120(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019DE010;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100518150(uint64_t a1, id *a2)
{
  id v5 = *a2;
  uint64_t v3 = +[CTXPCPlaceholder simSlot:**(unsigned int **)(a1 + 8)];
  id v4 = +[NSNumber numberWithUnsignedInteger:**(unsigned __int16 **)(a1 + 16)];
  [v5 prlVersionDidChange:v3 version:v4];
}

void sub_1005181E8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  uint64_t v12 = v11;

  _Unwind_Resume(a1);
}

uint64_t sub_100518218(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100518258()
{
}

void sub_100518268()
{
}

__n128 sub_10051827C(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_1019DE090;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_1005182C8(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019DE090;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_1005182F8(uint64_t a1, id *a2)
{
  id v5 = *a2;
  uint64_t v3 = +[CTXPCPlaceholder simSlot:**(unsigned int **)(a1 + 8)];
  id v4 = sub_1005B0AD4(*(uint64_t ***)(a1 + 16));
  [v5 didDetectSimDeactivation:v3 info:v4];
}

void sub_100518384(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  uint64_t v12 = v11;

  _Unwind_Resume(a1);
}

uint64_t sub_1005183B4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1005183F4()
{
}

void sub_100518400(uint64_t a1@<X0>, NSObject **a2@<X1>, _OWORD *a3@<X8>)
{
  id v4 = *(std::__shared_weak_count **)(a1 + 16);
  uint64_t v7 = *(void *)(a1 + 8);
  id v8 = v4;
  if (v4) {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  id v5 = *a2;
  dispatch_object_t object = v5;
  if (v5) {
    dispatch_retain(v5);
  }
  sub_100C622C4(&v7, &object, &v9);
  *a3 = v9;
  if (object) {
    dispatch_release(object);
  }
  if (v8) {
    sub_10004D2C8(v8);
  }
}

void sub_100518484(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object, uint64_t a11, std::__shared_weak_count *a12)
{
  if (object) {
    dispatch_release(object);
  }
  if (a12) {
    sub_10004D2C8(a12);
  }
  _Unwind_Resume(exception_object);
}

double sub_1005184A8@<D0>(void *a1@<X1>, _OWORD *a2@<X8>)
{
  return sub_100E38F1C(a1, a2);
}

uint64_t sub_1005184B0@<X0>(capabilities::ct *a1@<X0>, void *a2@<X8>)
{
  if (capabilities::ct::supportsDataPlanNotifications(a1)) {
    sub_10015B958();
  }
  uint64_t result = 0;
  *a2 = 0;
  a2[1] = 0;
  return result;
}

void sub_10051854C(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

void sub_100518580(uint64_t *a1@<X1>, uint64_t a2@<X2>, NSObject **a3@<X3>, int a4@<W4>, void *a5@<X8>)
{
  *a5 = 0;
  a5[1] = 0;
  uint64_t v10 = *a1;
  long long v9 = (std::__shared_weak_count *)a1[1];
  int v11 = (std::__shared_weak_count *)operator new(0x40uLL);
  uint64_t v12 = v11;
  v11->__shared_owners_ = 0;
  v11->__shared_weak_owners_ = 0;
  v11->__vftable = (std::__shared_weak_count_vtbl *)off_1019DE1D0;
  uint64_t v13 = (uint64_t)&v11[1];
  __int16 v38 = (void *)v10;
  int v39 = v9;
  if (v9) {
    atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v14 = *(NSObject **)a2;
  BOOL v15 = *(std::__shared_weak_count **)(a2 + 8);
  __int16 v36 = v14;
  uint64_t v37 = v15;
  if (v15) {
    atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  sub_1013F1944(&v11[1].__vftable, (uint64_t *)&v38, &v36);
  if (v15) {
    sub_10004D2C8(v15);
  }
  if (v9) {
    sub_10004D2C8(v9);
  }
  uint64_t v34 = v13;
  BOOL v35 = v12;
  switch(a4)
  {
    case 1:
      BOOL v17 = *a3;
      BOOL v18 = (std::__shared_weak_count *)operator new(0x108uLL);
      v18->__shared_owners_ = 0;
      v18->__shared_weak_owners_ = 0;
      v18->__vftable = (std::__shared_weak_count_vtbl *)off_1019DE220;
      int v16 = &v18[1].__vftable;
      __int16 v36 = v17;
      if (v17) {
        dispatch_retain(v17);
      }
      __int16 v38 = (void *)v13;
      int v39 = v12;
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_1008478D8(v16, &v36, (uint64_t *)&v38);
      sub_10004D2C8(v12);
      if (v17) {
        dispatch_release(v17);
      }
      shared_weak_owners = (std::__shared_weak_count *)v18[1].__shared_weak_owners_;
      if (shared_weak_owners)
      {
        if (shared_weak_owners->__shared_owners_ != -1)
        {
LABEL_53:
          uint64_t v21 = 0;
          *a5 = v16;
          a5[1] = v18;
LABEL_54:
          (*(void (**)(void *))(*v16 + 248))(v16);
          goto LABEL_55;
        }
        atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
        atomic_fetch_add_explicit(&v18->__shared_weak_owners_, 1uLL, memory_order_relaxed);
        v18[1].__shared_owners_ = (uint64_t)v16;
        v18[1].__shared_weak_owners_ = (uint64_t)v18;
        std::__shared_weak_count::__release_weak(shared_weak_owners);
      }
      else
      {
        atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
        atomic_fetch_add_explicit(&v18->__shared_weak_owners_, 1uLL, memory_order_relaxed);
        v18[1].__shared_owners_ = (uint64_t)v16;
        v18[1].__shared_weak_owners_ = (uint64_t)v18;
      }
      sub_10004D2C8(v18);
      goto LABEL_53;
    case 2:
      __int16 v38 = 0;
      int v39 = 0;
      LODWORD(v36) = 2;
      sub_1005190EC((uint64_t *)&v38, *a3, (int *)&v36, &v34);
      int v16 = v38;
      if (v38)
      {
        int v32 = v38 + 30;
        uint64_t v33 = v39;
        if (v39) {
          atomic_fetch_add_explicit(&v39->__shared_owners_, 1uLL, memory_order_relaxed);
        }
      }
      else
      {
        int v32 = 0;
        uint64_t v33 = 0;
      }
      uint64_t v20 = *a3;
      dispatch_object_t object = v20;
      if (v20) {
        dispatch_retain(v20);
      }
      (*(void (**)(NSObject **__return_ptr, uint64_t, void, void **, dispatch_object_t *))(*(void *)v13 + 32))(&v36, v13, 0, &v32, &object);
      char v22 = v36;
      uint64_t v21 = v37;
      __int16 v36 = 0;
      uint64_t v37 = 0;
      if (object) {
        dispatch_release(object);
      }
      if (v33) {
        sub_10004D2C8(v33);
      }
      v30[0] = (uint64_t)v22;
      v30[1] = (uint64_t)v21;
      if (v21) {
        atomic_fetch_add_explicit(&v21->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      sub_1008734FC((uint64_t)v16, v30);
      break;
    case 3:
      __int16 v38 = 0;
      int v39 = 0;
      LODWORD(v36) = 3;
      sub_1005190EC((uint64_t *)&v38, *a3, (int *)&v36, &v34);
      int v16 = v38;
      if (v38)
      {
        BOOL v28 = v38 + 30;
        BOOL v29 = v39;
        if (v39) {
          atomic_fetch_add_explicit(&v39->__shared_owners_, 1uLL, memory_order_relaxed);
        }
      }
      else
      {
        BOOL v28 = 0;
        BOOL v29 = 0;
      }
      int v23 = *a3;
      dispatch_object_t v27 = v23;
      if (v23) {
        dispatch_retain(v23);
      }
      (*(void (**)(NSObject **__return_ptr, uint64_t, uint64_t, void **, dispatch_object_t *))(*(void *)v13 + 32))(&v36, v13, 1, &v28, &v27);
      uint64_t v24 = v36;
      uint64_t v21 = v37;
      __int16 v36 = 0;
      uint64_t v37 = 0;
      if (v27) {
        dispatch_release(v27);
      }
      if (v29) {
        sub_10004D2C8(v29);
      }
      v26[0] = (uint64_t)v24;
      v26[1] = (uint64_t)v21;
      if (v21) {
        atomic_fetch_add_explicit(&v21->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      sub_1008734FC((uint64_t)v16, v26);
      break;
    default:
LABEL_58:
      sub_10004D2C8(v12);
      return;
  }
  if (v21) {
    sub_10004D2C8(v21);
  }
  uint64_t v25 = v39;
  if (v39)
  {
    atomic_fetch_add_explicit(&v39->__shared_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v25);
  }
  *a5 = v16;
  a5[1] = v25;
  if (v16) {
    goto LABEL_54;
  }
LABEL_55:
  if (v21) {
    sub_10004D2C8(v21);
  }
  uint64_t v12 = v35;
  if (v35) {
    goto LABEL_58;
  }
}

void sub_10051896C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, dispatch_object_t object, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, dispatch_object_t a16, uint64_t a17, uint64_t a18, uint64_t a19, std::__shared_weak_count *a20)
{
  if (v21) {
    sub_10004D2C8(v21);
  }
  uint64_t v24 = *(std::__shared_weak_count **)(v22 - 72);
  if (v24) {
    sub_10004D2C8(v24);
  }
  if (v21) {
    sub_10004D2C8(v21);
  }
  if (a20) {
    sub_10004D2C8(a20);
  }
  uint64_t v25 = *(std::__shared_weak_count **)(v20 + 8);
  if (v25) {
    sub_10004D2C8(v25);
  }
  _Unwind_Resume(exception_object);
}

void sub_100518A78(uint64_t a1@<X1>, int a2@<W2>, int a3@<W3>, const void **a4@<X8>)
{
  *a4 = 0;
  long long v9 = *(std::__shared_weak_count **)(a1 + 8);
  BOOL v17 = *(NSDictionary **)a1;
  BOOL v18 = v9;
  if (v9) {
    atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v19 = 0;
  uint64_t v10 = sub_100518CEC((Registry **)&v17, @"CellularDataPlanAccountProxy", a2, a3);
  uint64_t v19 = v10;
  if (v18)
  {
    sub_10004D2C8(v18);
    uint64_t v10 = v19;
  }
  if (v10) {
    int v11 = sub_1000810B8;
  }
  else {
    int v11 = 0;
  }
  if (v11)
  {
    uint64_t v12 = +[NSURL URLWithString:v17];
    uint64_t v13 = v12;
    if (v12)
    {
      uint64_t v14 = [(NSString *)[(NSURL *)v12 scheme] lowercaseString];
      if ([(NSString *)v14 isEqualToString:@"https"])
      {
        v22[0] = kCFStreamPropertyHTTPSProxyHost;
        v23[0] = [(NSURL *)v13 host];
        v22[1] = kCFStreamPropertyHTTPSProxyPort;
        if ([(NSURL *)v13 port]) {
          BOOL v15 = [(NSURL *)v13 port];
        }
        else {
          BOOL v15 = (NSNumber *)&off_101AE63B8;
        }
        v23[1] = v15;
        BOOL v17 = +[NSDictionary dictionaryWithObjects:v23 forKeys:v22 count:2];
        sub_100282490(a4, (CFTypeRef *)&v17);
      }
      else if ([(NSString *)v14 isEqualToString:@"http"])
      {
        v20[0] = kCFStreamPropertyHTTPProxyHost;
        v21[0] = [(NSURL *)v13 host];
        v20[1] = kCFStreamPropertyHTTPProxyPort;
        if ([(NSURL *)v13 port]) {
          int v16 = [(NSURL *)v13 port];
        }
        else {
          int v16 = (NSNumber *)&off_101AE63D0;
        }
        v21[1] = v16;
        BOOL v17 = +[NSDictionary dictionaryWithObjects:v21 forKeys:v20 count:2];
        sub_100282490(a4, (CFTypeRef *)&v17);
      }
    }
  }
  sub_1000558F4(&v19);
}

void sub_100518CA8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sub_1000558F4((const void **)va);
  sub_100057D78(v3);
  _Unwind_Resume(a1);
}

const void *sub_100518CEC(Registry **a1, const void *a2, int a3, int a4)
{
  CFDictionaryRef v6 = (const __CFDictionary *)sub_100916B20(a1, a4);
  CFDictionaryRef v17 = v6;
  if (v6) {
    uint64_t v7 = sub_100080778;
  }
  else {
    uint64_t v7 = 0;
  }
  if (!v7) {
    goto LABEL_19;
  }
  if (a3 != -1)
  {
    CFDictionaryRef v15 = v6;
    CFDictionaryRef theDict = 0;
    if (v6) {
      CFRetain(v6);
    }
    sub_100916790(&v15, a3, (const void **)&theDict);
    sub_100057D78((const void **)&v15);
    if (theDict) {
      id v8 = sub_100080778;
    }
    else {
      id v8 = 0;
    }
    if (v8)
    {
      Value = CFDictionaryGetValue(theDict, a2);
      uint64_t v10 = Value;
      if (Value)
      {
        CFTypeID v11 = CFGetTypeID(Value);
        if (v11 == CFStringGetTypeID())
        {
          sub_100057D78((const void **)&theDict);
LABEL_18:
          CFRetain(v10);
          goto LABEL_20;
        }
      }
    }
    sub_100057D78((const void **)&theDict);
    CFDictionaryRef v6 = v17;
  }
  uint64_t v12 = CFDictionaryGetValue(v6, a2);
  uint64_t v10 = v12;
  if (v12)
  {
    CFTypeID v13 = CFGetTypeID(v12);
    if (v13 == CFStringGetTypeID()) {
      goto LABEL_18;
    }
LABEL_19:
    uint64_t v10 = 0;
  }
LABEL_20:
  sub_100057D78((const void **)&v17);
  return v10;
}

void sub_100518E1C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, const void *);
  uint64_t v5 = va_arg(va1, void);
  sub_100057D78((const void **)va);
  sub_100057D78((const void **)va1);
  _Unwind_Resume(a1);
}

void *sub_100518E4C(void *a1)
{
  *a1 = off_1019DE110;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

void sub_100518E98(void *a1)
{
  *a1 = off_1019DE110;
  uint64_t v1 = (std::__shared_weak_count *)a1[2];
  if (v1) {
    sub_10004D2C8(v1);
  }

  operator delete();
}

void sub_100518F08(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100518F40(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_100518F70(uint64_t a1, uint64_t a2)
{
    return a1 + 24;
  else {
    return 0;
  }
}

void sub_100518FB4(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1019DE1D0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100518FD4(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1019DE1D0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100519028(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_100519050(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1019DE220;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100519070(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1019DE220;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_1005190C4(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_1005190EC(uint64_t *a1, NSObject *a2, int *a3, uint64_t *a4)
{
  id v8 = (std::__shared_weak_count *)operator new(0x140uLL);
  v8->__shared_owners_ = 0;
  v8->__shared_weak_owners_ = 0;
  v8->__vftable = (std::__shared_weak_count_vtbl *)off_1019DE270;
  uint64_t v9 = (uint64_t)&v8[1];
  CFDictionaryRef v15 = a2;
  if (a2) {
    dispatch_retain(a2);
  }
  int v10 = *a3;
  uint64_t v11 = *a4;
  uint64_t v12 = (std::__shared_weak_count *)a4[1];
  v14[0] = v11;
  v14[1] = (uint64_t)v12;
  if (v12) {
    atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  sub_1008733F4(v9, &v15, v10, v14);
  if (v12) {
    sub_10004D2C8(v12);
  }
  if (a2) {
    dispatch_release(a2);
  }
  *a1 = v9;
  a1[1] = (uint64_t)v8;
  shared_weak_owners = (std::__shared_weak_count *)v8[1].__shared_weak_owners_;
  if (shared_weak_owners)
  {
    if (shared_weak_owners->__shared_owners_ != -1) {
      return;
    }
    atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit(&v8->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    v8[1].__shared_owners_ = v9;
    v8[1].__shared_weak_owners_ = (uint64_t)v8;
    std::__shared_weak_count::__release_weak(shared_weak_owners);
  }
  else
  {
    atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit(&v8->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    v8[1].__shared_owners_ = v9;
    v8[1].__shared_weak_owners_ = (uint64_t)v8;
  }

  sub_10004D2C8(v8);
}

void sub_100519230(_Unwind_Exception *a1)
{
  if (v3) {
    sub_10004D2C8(v3);
  }
  if (v2) {
    dispatch_release(v2);
  }
  std::__shared_weak_count::~__shared_weak_count(v1);
  operator delete(v5);
  _Unwind_Resume(a1);
}

void sub_100519260(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1019DE270;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100519280(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1019DE270;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_1005192D4(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_1005192FC()
{
}

void sub_100519364()
{
}

void *sub_100519388(void *a1)
{
  LoggingProfileInterface::LoggingProfileInterface();
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v3, kCtLoggingSystemName, "log.prof");
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v4, &v3);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 3), (const ctu::OsLogLogger *)v4);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v4);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v3);
  a1[4] = 0;
  a1[5] = 0;
  *a1 = off_1019DE2C0;
  return a1;
}

void sub_10051941C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v4 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)va1);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)va);
  LoggingProfileInterface::~LoggingProfileInterface(v2);
  _Unwind_Resume(a1);
}

BOOL *sub_100519450(uint64_t a1)
{
  uint64_t v16 = 0;
  CFDictionaryRef v17 = 0;
  Registry::getMobileHelper(&v16, *(Registry **)(a1 + 8));
  if (!v16)
  {
    uint64_t v4 = 0;
    goto LABEL_19;
  }
  CFTypeRef cf = 0;
  (*(void (**)(CFTypeRef *__return_ptr))(*(void *)v16 + 32))(&cf);
  if (cf) {
    uint64_t v2 = sub_100080934;
  }
  else {
    uint64_t v2 = 0;
  }
  if (!v2) {
    goto LABEL_17;
  }
  CFTypeID v3 = CFGetTypeID(cf);
  if (v3 == CFBooleanGetTypeID())
  {
    uint64_t v4 = (BOOL *)cf;
    LOBYTE(v18) = 0;
    if (cf)
    {
      CFTypeID v5 = CFGetTypeID(cf);
      if (v5 == CFBooleanGetTypeID())
      {
        ctu::cf::assign((ctu::cf *)&v18, v4, v6);
        int v7 = v18;
LABEL_15:
        uint64_t v4 = (BOOL *)(v7 != 0);
        goto LABEL_18;
      }
      goto LABEL_17;
    }
  }
  else
  {
    if (v3 != CFNumberGetTypeID())
    {
      int v10 = *(NSObject **)(a1 + 24);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
      {
        long long v18 = 0uLL;
        uint64_t v19 = 0;
        ctu::cf::assign();
        *(_OWORD *)std::string __p = v18;
        uint64_t v14 = v19;
        uint64_t v12 = __p;
        if (v19 < 0) {
          uint64_t v12 = (void **)v18;
        }
        *(_DWORD *)std::string buf = 134218242;
        CFTypeID v21 = v3;
        __int16 v22 = 2080;
        int v23 = v12;
        _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "Wrong type %lu for key '%s'", buf, 0x16u);
        if (SHIBYTE(v14) < 0) {
          operator delete(__p[0]);
        }
      }
      goto LABEL_17;
    }
    uint64_t v4 = (BOOL *)cf;
    LODWORD(v18) = 0;
    if (cf)
    {
      CFTypeID v8 = CFGetTypeID(cf);
      if (v8 == CFNumberGetTypeID())
      {
        ctu::cf::assign((ctu::cf *)&v18, (int *)v4, v9);
        int v7 = v18;
        goto LABEL_15;
      }
LABEL_17:
      uint64_t v4 = 0;
    }
  }
LABEL_18:
  sub_1000577C4(&cf);
LABEL_19:
  if (v17) {
    sub_10004D2C8(v17);
  }
  return v4;
}

void sub_100519688(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, const void *a13, uint64_t a14, std::__shared_weak_count *a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  sub_1000577C4(&a13);
  if (a15) {
    sub_10004D2C8(a15);
  }
  _Unwind_Resume(a1);
}

void sub_1005196D4(void *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[5];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 3));

  LoggingProfileInterface::~LoggingProfileInterface((LoggingProfileInterface *)a1);
}

void sub_10051971C(void *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[5];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 3));
  LoggingProfileInterface::~LoggingProfileInterface((LoggingProfileInterface *)a1);

  operator delete();
}

void sub_100519778(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_1005197F8(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100519834(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_10051986C(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_10051989C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

void SaveDataModeController::setupAwdMetricCallbacks_sync(SaveDataModeController *this)
{
  sub_10003E168(&v2, (void *)this + 1);
  uint64_t v1 = v3;
  if (v3)
  {
    atomic_fetch_add_explicit(&v3->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v1);
  }
  if (v1) {
    atomic_fetch_add_explicit(&v1->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  }
  sub_10017B514();
  if (v1) {
    atomic_fetch_add_explicit(&v1->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  }
  sub_10017B514();
  if (v1)
  {
    std::__shared_weak_count::__release_weak(v1);
    std::__shared_weak_count::__release_weak(v1);
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_100519A34(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, std::__shared_weak_count *a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,std::__shared_weak_count *a22)
{
  if (a15) {
    std::__shared_weak_count::__release_weak(a15);
  }
  if (a22) {
    std::__shared_weak_count::__release_weak(a22);
  }
  if (v22) {
    std::__shared_weak_count::__release_weak(v22);
  }
  _Unwind_Resume(exception_object);
}

void sub_100519A6C(uint64_t a1)
{
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 1174405120;
  v3[2] = sub_100519BA0;
  v3[3] = &unk_1019DE3D8;
  long long v4 = *(_OWORD *)(a1 + 32);
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  CFTypeID v5 = v1;
  if (v1) {
    atomic_fetch_add_explicit(&v1->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v8 = 0;
  CFNumberRef v9 = 0;
  sub_10003E168(&v8, (void *)(v4 + 8));
  uint64_t v2 = *(NSObject **)(v4 + 24);
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  block[2] = sub_10051A8E8;
  block[3] = &unk_1019DE4A0;
  void block[5] = v8;
  int v7 = v9;
  if (v9) {
    atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  void block[4] = v3;
  dispatch_async(v2, block);
  if (v7) {
    sub_10004D2C8(v7);
  }
  if (v9) {
    sub_10004D2C8(v9);
  }
  if (v5) {
    std::__shared_weak_count::__release_weak(v5);
  }
}

void sub_100519BA0(void *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[6];
  if (v2)
  {
    uint64_t v3 = a1[4];
    long long v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      CFTypeID v5 = v4;
      if (a1[5])
      {
        CFBooleanRef v6 = *(NSObject **)(v3 + 40);
        if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)int v7 = 0;
          _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Call back for Low Data Mode metrics", v7, 2u);
        }
        SaveDataModeController::submitLowDataModeMetrics_sync(v3, 3);
      }
      sub_10004D2C8(v5);
    }
  }
}

void sub_100519C40(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void SaveDataModeController::submitLowDataModeMetrics_sync(uint64_t a1, int a2)
{
  if (a2) {
    operator new();
  }
}

void sub_10051A114(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  if (v2) {
    sub_10004D2C8(v2);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_10051A1DC(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_10051A1F8(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_10051A208(uint64_t a1)
{
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 1174405120;
  v3[2] = sub_10051A33C;
  v3[3] = &unk_1019DE438;
  long long v4 = *(_OWORD *)(a1 + 32);
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  CFTypeID v5 = v1;
  if (v1) {
    atomic_fetch_add_explicit(&v1->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v8 = 0;
  CFNumberRef v9 = 0;
  sub_10003E168(&v8, (void *)(v4 + 8));
  uint64_t v2 = *(NSObject **)(v4 + 24);
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  block[2] = sub_10051A8E8;
  block[3] = &unk_1019DE4A0;
  void block[5] = v8;
  int v7 = v9;
  if (v9) {
    atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  void block[4] = v3;
  dispatch_async(v2, block);
  if (v7) {
    sub_10004D2C8(v7);
  }
  if (v9) {
    sub_10004D2C8(v9);
  }
  if (v5) {
    std::__shared_weak_count::__release_weak(v5);
  }
}

void sub_10051A33C(void *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[6];
  if (v2)
  {
    uint64_t v3 = (capabilities::ct *)a1[4];
    long long v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      CFTypeID v5 = v4;
      if (a1[5])
      {
        CFBooleanRef v6 = *((void *)v3 + 5);
        if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)int v7 = 0;
          _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Call back for Smart Data Mode metrics", v7, 2u);
        }
        SaveDataModeController::submitSmartDataModeMetrics_sync(v3, 3);
      }
      sub_10004D2C8(v5);
    }
  }
}

void sub_10051A3E0(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t SaveDataModeController::submitSmartDataModeMetrics_sync(capabilities::ct *a1, int a2)
{
  uint64_t result = capabilities::ct::supports5G(a1);
  if (a2)
  {
    if (result) {
      operator new();
    }
  }
  return result;
}

void sub_10051A7A8(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  if (v2) {
    sub_10004D2C8(v2);
  }
  _Unwind_Resume(a1);
}

void sub_10051A884()
{
}

void sub_10051A8C4()
{
}

uint64_t sub_10051A8E8(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

uint64_t sub_10051A8F8(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_10051A914(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

void sub_10051AC68(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19)
{
  if ((v23 & 1) == 0) {
    sub_10004D2C8(v21);
  }

  _Unwind_Resume(a1);
}

void sub_10051B1D8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, char a20,uint64_t a21)
{
  if ((v25 & 1) == 0) {
    sub_10004D2C8(v23);
  }
  if (a14 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

void sub_10051B624(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if ((v20 & 1) == 0) {
    sub_10004D2C8(v18);
  }
  if (a16 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

void sub_10051B980(_Unwind_Exception *a1)
{
  if ((v4 & 1) == 0) {
    sub_10004D2C8(v2);
  }

  _Unwind_Resume(a1);
}

void sub_10051C00C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,char a23,uint64_t a24,uint64_t a25,char a26,void *__p,uint64_t a28,int a29,__int16 a30,char a31,char a32,char a33,uint64_t a34,uint64_t a35,char a36)
{
  if ((v39 & 1) == 0) {
    sub_10004D2C8(v36);
  }

  _Unwind_Resume(a1);
}

void sub_10051C688(_Unwind_Exception *a1)
{
  if ((v4 & 1) == 0) {
    sub_10004D2C8(v3);
  }

  _Unwind_Resume(a1);
}

void sub_10051CD84(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,char a23,uint64_t a24,uint64_t a25,char a26,void *__p,uint64_t a28,int a29,__int16 a30,char a31,char a32,char a33,uint64_t a34,uint64_t a35,char a36)
{
  if ((v39 & 1) == 0) {
    sub_10004D2C8(v37);
  }

  _Unwind_Resume(a1);
}

void sub_10051D134(_Unwind_Exception *a1)
{
  if ((v4 & 1) == 0) {
    sub_10004D2C8(v2);
  }

  _Unwind_Resume(a1);
}

void sub_10051D4DC(_Unwind_Exception *a1)
{
  if ((v5 & 1) == 0) {
    sub_10004D2C8(v3);
  }

  _Unwind_Resume(a1);
}

void sub_10051D8B4(_Unwind_Exception *a1)
{
  if ((v5 & 1) == 0) {
    sub_10004D2C8(v3);
  }

  _Unwind_Resume(a1);
}

void sub_10051DBA8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if ((v17 & 1) == 0) {
    sub_10004D2C8(v15);
  }

  _Unwind_Resume(a1);
}

void sub_10051E05C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if ((v18 & 1) == 0) {
    sub_10004D2C8(v17);
  }
  if ((v19 & 1) == 0) {
    sub_10004D2C8(v16);
  }

  _Unwind_Resume(a1);
}

void sub_10051E364(_Unwind_Exception *a1)
{
  if ((v4 & 1) == 0) {
    sub_10004D2C8(v2);
  }

  _Unwind_Resume(a1);
}

void sub_10051E460(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10051E87C(_Unwind_Exception *a1)
{
  if ((v5 & 1) == 0) {
    sub_10004D2C8(v3);
  }

  _Unwind_Resume(a1);
}

void sub_10051EC4C(_Unwind_Exception *a1)
{
  if ((v4 & 1) == 0) {
    sub_10004D2C8(v2);
  }

  _Unwind_Resume(a1);
}

void sub_10051F024(_Unwind_Exception *a1)
{
  if ((v5 & 1) == 0) {
    sub_10004D2C8(v3);
  }

  _Unwind_Resume(a1);
}

void sub_10051F514(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  sub_100525CFC((uint64_t *)va);
  if ((v9 & 1) == 0) {
    sub_10004D2C8(v8);
  }

  _Unwind_Resume(a1);
}

void sub_10051F9C0(_Unwind_Exception *a1)
{
  if ((v3 & 1) == 0) {
    sub_10004D2C8(v2);
  }

  _Unwind_Resume(a1);
}

void sub_10051FDA0(_Unwind_Exception *a1)
{
  if ((v4 & 1) == 0) {
    sub_10004D2C8(v2);
  }

  _Unwind_Resume(a1);
}

void sub_10052016C(_Unwind_Exception *a1)
{
  if ((v4 & 1) == 0) {
    sub_10004D2C8(v2);
  }

  _Unwind_Resume(a1);
}

void sub_100520634(_Unwind_Exception *a1)
{
  if ((v5 & 1) == 0) {
    sub_10004D2C8(v4);
  }
  if ((v6 & 1) == 0) {
    sub_10004D2C8(v3);
  }

  _Unwind_Resume(a1);
}

void sub_100520A1C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    sub_10004D2C8(a12);
  }
  if ((v15 & 1) == 0) {
    sub_10004D2C8(v14);
  }

  _Unwind_Resume(a1);
}

void sub_100520EA8(_Unwind_Exception *a1)
{
  if ((v5 & 1) == 0) {
    sub_10004D2C8(v3);
  }

  _Unwind_Resume(a1);
}

void sub_100521430(_Unwind_Exception *a1)
{
  if ((v6 & 1) == 0) {
    sub_10004D2C8(v4);
  }

  _Unwind_Resume(a1);
}

void sub_10052187C(_Unwind_Exception *a1)
{
  if ((v4 & 1) == 0) {
    sub_10004D2C8(v2);
  }

  _Unwind_Resume(a1);
}

void sub_100521B4C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_100521B9C(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void sub_100521BAC(uint64_t a1)
{
}

void sub_100521F14(_Unwind_Exception *a1)
{
  if ((v3 & 1) == 0) {
    sub_10004D2C8(v2);
  }

  _Unwind_Resume(a1);
}

void sub_1005222F8(_Unwind_Exception *a1)
{
  if ((v3 & 1) == 0) {
    sub_10004D2C8(v2);
  }

  _Unwind_Resume(a1);
}

void sub_100522608(_Unwind_Exception *a1)
{
  if ((v4 & 1) == 0) {
    sub_10004D2C8(v2);
  }

  _Unwind_Resume(a1);
}

void sub_100522980(_Unwind_Exception *a1)
{
  if ((v4 & 1) == 0) {
    sub_10004D2C8(v2);
  }

  _Unwind_Resume(a1);
}

void sub_100522C98(_Unwind_Exception *a1)
{
  if ((v5 & 1) == 0) {
    sub_10004D2C8(v3);
  }

  _Unwind_Resume(a1);
}

uint64_t sub_100522D0C(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 48) && *(unsigned char *)(a1 + 24) && *(char *)(a1 + 23) < 0) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t sub_100522D50(uint64_t *a1, uint64_t a2)
{
  uint64_t v3 = *a1;
  unint64_t v4 = 0xCCCCCCCCCCCCCCCDLL * ((a1[1] - *a1) >> 5);
  unint64_t v5 = v4 + 1;
  if (v4 + 1 > 0x199999999999999) {
    sub_10006A748();
  }
  uint64_t v7 = (uint64_t)(a1 + 2);
  unint64_t v8 = 0xCCCCCCCCCCCCCCCDLL * ((a1[2] - v3) >> 5);
  if (2 * v8 > v5) {
    unint64_t v5 = 2 * v8;
  }
  if (v8 >= 0xCCCCCCCCCCCCCCLL) {
    unint64_t v9 = 0x199999999999999;
  }
  else {
    unint64_t v9 = v5;
  }
  char v17 = a1 + 2;
  if (v9) {
    int v10 = (char *)sub_100522FB0(v7, v9);
  }
  else {
    int v10 = 0;
  }
  CFTypeID v13 = v10;
  uint64_t v14 = &v10[160 * v4];
  uint64_t v16 = &v10[160 * v9];
  sub_100522E58((uint64_t)v14, a2);
  char v15 = v14 + 160;
  sub_100522F38(a1, &v13);
  uint64_t v11 = a1[1];
  sub_1005231F0((uint64_t)&v13);
  return v11;
}

void sub_100522E44(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1005231F0((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100522E58(uint64_t a1, uint64_t a2)
{
  long long v4 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(_OWORD *)(a1 + 16) = v4;
  sub_100522ECC(a1 + 32, a2 + 32);
  sub_100522ECC(a1 + 88, a2 + 88);
  uint64_t v5 = *(void *)(a2 + 144);
  *(void *)(a1 + 150) = *(void *)(a2 + 150);
  *(void *)(a1 + 144) = v5;
  return a1;
}

void sub_100522EB8(_Unwind_Exception *a1)
{
  sub_100522D0C(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100522ECC(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)a1 = 0;
  *(unsigned char *)(a1 + 48) = 0;
  if (*(unsigned char *)(a2 + 48))
  {
    sub_1000593FC(a1, (long long *)a2);
    uint64_t v4 = *(void *)(a2 + 32);
    *(unsigned char *)(a1 + 40) = *(unsigned char *)(a2 + 40);
    *(void *)(a1 + 32) = v4;
    *(unsigned char *)(a1 + 48) = 1;
  }
  return a1;
}

void sub_100522F24(_Unwind_Exception *a1)
{
  sub_100522D0C(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100522F38(uint64_t *a1, void *a2)
{
  uint64_t result = sub_100522FF8((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

void *sub_100522FB0(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x19999999999999ALL) {
    sub_10006A7CC();
  }
  return operator new(160 * a2);
}

uint64_t sub_100522FF8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&long long v15 = a6;
  *((void *)&v15 + 1) = a7;
  long long v14 = v15;
  v12[0] = a1;
  v12[1] = &v14;
  v12[2] = &v15;
  uint64_t v13 = 0;
  if (a3 == a5)
  {
    uint64_t v10 = a6;
  }
  else
  {
    uint64_t v9 = a3;
    do
    {
      v9 -= 160;
      sub_10052309C(v7 - 160, v9);
      uint64_t v7 = *((void *)&v15 + 1) - 160;
      *((void *)&v15 + 1) -= 160;
    }
    while (v9 != a5);
    uint64_t v10 = v15;
  }
  LOBYTE(v13) = 1;
  sub_100523170((uint64_t)v12);
  return v10;
}

uint64_t sub_10052309C(uint64_t result, uint64_t a2)
{
  long long v2 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)uint64_t result = *(_OWORD *)a2;
  *(_OWORD *)(result + 16) = v2;
  *(unsigned char *)(result + 32) = 0;
  *(unsigned char *)(result + 80) = 0;
  if (*(unsigned char *)(a2 + 80))
  {
    *(unsigned char *)(result + 56) = 0;
    if (*(unsigned char *)(a2 + 56))
    {
      long long v3 = *(_OWORD *)(a2 + 32);
      *(void *)(result + 48) = *(void *)(a2 + 48);
      *(_OWORD *)(result + 32) = v3;
      *(void *)(a2 + 40) = 0;
      *(void *)(a2 + 48) = 0;
      *(void *)(a2 + 32) = 0;
      *(unsigned char *)(result + 56) = 1;
    }
    uint64_t v4 = *(void *)(a2 + 64);
    *(unsigned char *)(result + 72) = *(unsigned char *)(a2 + 72);
    *(void *)(result + 64) = v4;
    *(unsigned char *)(result + 80) = 1;
  }
  *(unsigned char *)(result + 88) = 0;
  *(unsigned char *)(result + 136) = 0;
  if (*(unsigned char *)(a2 + 136))
  {
    *(unsigned char *)(result + 112) = 0;
    if (*(unsigned char *)(a2 + 112))
    {
      long long v5 = *(_OWORD *)(a2 + 88);
      *(void *)(result + 104) = *(void *)(a2 + 104);
      *(_OWORD *)(result + 88) = v5;
      *(void *)(a2 + 96) = 0;
      *(void *)(a2 + 104) = 0;
      *(void *)(a2 + 88) = 0;
      *(unsigned char *)(result + 112) = 1;
    }
    uint64_t v6 = *(void *)(a2 + 120);
    *(unsigned char *)(result + 128) = *(unsigned char *)(a2 + 128);
    *(void *)(result + 120) = v6;
    *(unsigned char *)(result + 136) = 1;
  }
  uint64_t v7 = *(void *)(a2 + 144);
  *(void *)(result + 150) = *(void *)(a2 + 150);
  *(void *)(result + 144) = v7;
  return result;
}

uint64_t sub_100523170(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    sub_1005231A8(a1);
  }
  return a1;
}

uint64_t sub_1005231A8(uint64_t result)
{
  uint64_t v1 = *(void *)(*(void *)(result + 16) + 8);
  uint64_t v2 = *(void *)(*(void *)(result + 8) + 8);
  while (v1 != v2)
  {
    sub_100522D0C(v1 + 88);
    uint64_t result = sub_100522D0C(v1 + 32);
    v1 += 160;
  }
  return result;
}

uint64_t sub_1005231F0(uint64_t a1)
{
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t sub_100523228(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(result + 16);
  if (v2 != a2)
  {
    uint64_t v4 = result;
    do
    {
      *(void *)(v4 + 16) = v2 - 160;
      sub_100522D0C(v2 - 72);
      uint64_t result = sub_100522D0C(v2 - 128);
      uint64_t v2 = *(void *)(v4 + 16);
    }
    while (v2 != a2);
  }
  return result;
}

void sub_100523284(void ***a1)
{
  uint64_t v2 = (uint64_t *)*a1;
  if (*v2)
  {
    sub_1005232D8((uint64_t)v2, *v2);
    long long v3 = **a1;
    operator delete(v3);
  }
}

uint64_t sub_1005232D8(uint64_t result, uint64_t a2)
{
  uint64_t v3 = result;
  for (uint64_t i = *(void *)(result + 8); i != a2; i -= 160)
  {
    sub_100522D0C(i - 72);
    uint64_t result = sub_100522D0C(i - 128);
  }
  *(void *)(v3 + 8) = a2;
  return result;
}

uint64_t sub_100523334(uint64_t a1)
{
  return a1;
}

void sub_100523368(uint64_t a1)
{
  operator delete();
}

void *sub_1005233BC(uint64_t a1)
{
  uint64_t v2 = operator new(0x18uLL);
  void *v2 = off_1019DE530;
  v2[1] = *(id *)(a1 + 8);
  void v2[2] = objc_retainBlock(*(id *)(a1 + 16));
  return v2;
}

id sub_100523420(uint64_t a1, void *a2)
{
  *a2 = off_1019DE530;
  a2[1] = *(id *)(a1 + 8);
  id result = objc_retainBlock(*(id *)(a1 + 16));
  a2[2] = result;
  return result;
}

void sub_100523478(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 8);
}

void sub_1005234B4(id *a1)
{
  operator delete(a1);
}

void sub_1005234F8(uint64_t a1, int *a2, uint64_t a3, uint64_t a4, int *a5)
{
  int v6 = *a2;
  *(_OWORD *)std::string __p = *(_OWORD *)a4;
  uint64_t v16 = *(void *)(a4 + 16);
  *(void *)(a4 + 8) = 0;
  *(void *)(a4 + 16) = 0;
  *(void *)a4 = 0;
  uint64_t v7 = *a5;
  uint64_t v8 = *(void **)(a1 + 8);
  if (v8)
  {
    [v8 registry];
  }
  else
  {
    uint64_t v17 = 0;
    char v18 = 0;
  }
  int isValidSimSlot = subscriber::isValidSimSlot();
  if (v18) {
    sub_10004D2C8(v18);
  }
  if (isValidSimSlot)
  {
    uint64_t v10 = sub_1005AF7F8(v6);
    uint64_t v11 = +[CTXPCServiceSubscriptionContext contextWithServiceDescriptor:v10];
  }
  else
  {
    uint64_t v11 = 0;
  }
  if ((SHIBYTE(v16) & 0x80000000) == 0)
  {
    if (HIBYTE(v16))
    {
      uint64_t v12 = __p;
      goto LABEL_14;
    }
LABEL_16:
    uint64_t v13 = 0;
    if (v7) {
      goto LABEL_15;
    }
    goto LABEL_17;
  }
  if (!__p[1]) {
    goto LABEL_16;
  }
  uint64_t v12 = (void **)__p[0];
LABEL_14:
  uint64_t v13 = +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v12, __p[0]);
  if (v7)
  {
LABEL_15:
    id v14 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:v7 userInfo:0];
    goto LABEL_18;
  }
LABEL_17:
  id v14 = 0;
LABEL_18:
  (*(void (**)(void))(*(void *)(a1 + 16) + 16))();

  if (SHIBYTE(v16) < 0) {
    operator delete(__p[0]);
  }
}

void sub_10052367C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_1005236D0(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_1019DE5A0)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_100523710()
{
  return &off_1019DE5A0;
}

void *sub_10052371C(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t sub_1005237A0(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

uint64_t sub_100523838(uint64_t a1)
{
  return a1;
}

void sub_100523864(uint64_t a1)
{
  operator delete();
}

void *sub_1005238B0(uint64_t a1)
{
  uint64_t v2 = operator new(0x10uLL);
  void *v2 = off_1019DE5C0;
  v2[1] = objc_retainBlock(*(id *)(a1 + 8));
  return v2;
}

id sub_100523908(uint64_t a1, void *a2)
{
  *a2 = off_1019DE5C0;
  id result = objc_retainBlock(*(id *)(a1 + 8));
  a2[1] = result;
  return result;
}

void sub_100523950(uint64_t a1)
{
}

void sub_100523958(id *a1)
{
  operator delete(a1);
}

void sub_100523994(uint64_t a1, unsigned char *a2)
{
  if (*a2) {
    id v3 = 0;
  }
  else {
    id v3 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
  }
  id v4 = v3;
  (*(void (**)(void))(*(void *)(a1 + 8) + 16))();
}

void sub_100523A24(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t sub_100523A38(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_1019DE620)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_100523A78()
{
  return &off_1019DE620;
}

uint64_t sub_100523A84(uint64_t a1)
{
  return a1;
}

void sub_100523AB0(uint64_t a1)
{
  operator delete();
}

void *sub_100523AFC(uint64_t a1)
{
  uint64_t v2 = operator new(0x10uLL);
  void *v2 = off_1019DE640;
  v2[1] = objc_retainBlock(*(id *)(a1 + 8));
  return v2;
}

id sub_100523B54(uint64_t a1, void *a2)
{
  *a2 = off_1019DE640;
  id result = objc_retainBlock(*(id *)(a1 + 8));
  a2[1] = result;
  return result;
}

void sub_100523B9C(uint64_t a1)
{
}

void sub_100523BA4(id *a1)
{
  operator delete(a1);
}

void sub_100523BE0(uint64_t a1, unsigned char *a2)
{
  if (*a2) {
    id v3 = 0;
  }
  else {
    id v3 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
  }
  id v4 = v3;
  (*(void (**)(void))(*(void *)(a1 + 8) + 16))();
}

void sub_100523C70(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t sub_100523C84(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_1019DE6A0)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_100523CC4()
{
  return &off_1019DE6A0;
}

uint64_t sub_100523CD0(uint64_t a1)
{
  return a1;
}

void sub_100523CFC(uint64_t a1)
{
  operator delete();
}

void *sub_100523D48(uint64_t a1)
{
  uint64_t v2 = operator new(0x10uLL);
  void *v2 = off_1019DE6C0;
  v2[1] = objc_retainBlock(*(id *)(a1 + 8));
  return v2;
}

id sub_100523DA0(uint64_t a1, void *a2)
{
  *a2 = off_1019DE6C0;
  id result = objc_retainBlock(*(id *)(a1 + 8));
  a2[1] = result;
  return result;
}

void sub_100523DE8(uint64_t a1)
{
}

void sub_100523DF0(id *a1)
{
  operator delete(a1);
}

void sub_100523E2C(uint64_t a1, unsigned int **a2)
{
  id v8 = (id)objc_opt_new();
  id v4 = objc_alloc_init((Class)NSMutableArray);
  long long v5 = *a2;
  int v6 = a2[1];
  while (v5 != v6)
  {
    uint64_t v7 = sub_1005B02EC(v5);
    [v4 addObject:v7];

    v5 += 40;
  }
  [v8 setFilters:v4];
  (*(void (**)(void))(*(void *)(a1 + 8) + 16))();
}

void sub_100523EF8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t sub_100523F28(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_1019DE730)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_100523F68()
{
  return &off_1019DE730;
}

void *sub_100523F74(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t sub_100523FF8(uint64_t a1)
{
  return a1;
}

void sub_100524024(uint64_t a1)
{
  operator delete();
}

void *sub_100524070(uint64_t a1)
{
  uint64_t v2 = operator new(0x10uLL);
  void *v2 = off_1019DE750;
  v2[1] = objc_retainBlock(*(id *)(a1 + 8));
  return v2;
}

id sub_1005240C8(uint64_t a1, void *a2)
{
  *a2 = off_1019DE750;
  id result = objc_retainBlock(*(id *)(a1 + 8));
  a2[1] = result;
  return result;
}

void sub_100524110(uint64_t a1)
{
}

void sub_100524118(id *a1)
{
  operator delete(a1);
}

void sub_100524154(uint64_t a1, unsigned int **a2)
{
  id v8 = (id)objc_opt_new();
  id v4 = objc_alloc_init((Class)NSMutableArray);
  long long v5 = *a2;
  int v6 = a2[1];
  while (v5 != v6)
  {
    uint64_t v7 = sub_1005B02EC(v5);
    [v4 addObject:v7];

    v5 += 40;
  }
  [v8 setFilters:v4];
  (*(void (**)(void))(*(void *)(a1 + 8) + 16))();
}

void sub_100524220(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t sub_100524250(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_1019DE7B0)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_100524290()
{
  return &off_1019DE7B0;
}

uint64_t sub_10052429C(uint64_t a1)
{
  return a1;
}

void sub_1005242C8(uint64_t a1)
{
  operator delete();
}

void *sub_100524314(uint64_t a1)
{
  uint64_t v2 = operator new(0x10uLL);
  void *v2 = off_1019DE7D0;
  v2[1] = objc_retainBlock(*(id *)(a1 + 8));
  return v2;
}

id sub_10052436C(uint64_t a1, void *a2)
{
  *a2 = off_1019DE7D0;
  id result = objc_retainBlock(*(id *)(a1 + 8));
  a2[1] = result;
  return result;
}

void sub_1005243B4(uint64_t a1)
{
}

void sub_1005243BC(id *a1)
{
  operator delete(a1);
}

void sub_1005243F8(uint64_t a1, unsigned char *a2)
{
  if (*a2) {
    id v3 = 0;
  }
  else {
    id v3 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
  }
  id v4 = v3;
  (*(void (**)(void))(*(void *)(a1 + 8) + 16))();
}

void sub_100524488(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t sub_10052449C(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_1019DE830)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_1005244DC()
{
  return &off_1019DE830;
}

uint64_t sub_1005244E8(uint64_t a1)
{
  return a1;
}

void sub_100524514(uint64_t a1)
{
  operator delete();
}

void *sub_100524560(uint64_t a1)
{
  uint64_t v2 = operator new(0x10uLL);
  void *v2 = off_1019DE850;
  v2[1] = objc_retainBlock(*(id *)(a1 + 8));
  return v2;
}

id sub_1005245B8(uint64_t a1, void *a2)
{
  *a2 = off_1019DE850;
  id result = objc_retainBlock(*(id *)(a1 + 8));
  a2[1] = result;
  return result;
}

void sub_100524600(uint64_t a1)
{
}

void sub_100524608(id *a1)
{
  operator delete(a1);
}

void sub_100524644(uint64_t a1, unsigned char *a2)
{
  if (*a2) {
    id v3 = 0;
  }
  else {
    id v3 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
  }
  id v4 = v3;
  (*(void (**)(void))(*(void *)(a1 + 8) + 16))();
}

void sub_1005246D4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1005246E8(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_1019DE8B0)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_100524728()
{
  return &off_1019DE8B0;
}

uint64_t sub_100524734(uint64_t a1)
{
  return a1;
}

void sub_100524760(uint64_t a1)
{
  operator delete();
}

void *sub_1005247AC(uint64_t a1)
{
  uint64_t v2 = operator new(0x10uLL);
  void *v2 = off_1019DE8D0;
  v2[1] = objc_retainBlock(*(id *)(a1 + 8));
  return v2;
}

id sub_100524804(uint64_t a1, void *a2)
{
  *a2 = off_1019DE8D0;
  id result = objc_retainBlock(*(id *)(a1 + 8));
  a2[1] = result;
  return result;
}

void sub_10052484C(uint64_t a1)
{
}

void sub_100524854(id *a1)
{
  operator delete(a1);
}

void sub_100524890(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *a2;
  if (HIDWORD(*a2)) {
    BOOL v4 = v3 == 0;
  }
  else {
    BOOL v4 = 1;
  }
  if (v4) {
    goto LABEL_8;
  }
  if (v3 == 2)
  {
    id v5 = objc_alloc((Class)NSError);
    int v6 = &NSMachErrorDomain;
    goto LABEL_10;
  }
  if (v3 != 1)
  {
LABEL_8:
    id v7 = 0;
    goto LABEL_11;
  }
  id v5 = objc_alloc((Class)NSError);
  int v6 = &NSPOSIXErrorDomain;
LABEL_10:
  id v7 = [v5 initWithDomain:*v6 code:v3 >> 32 userInfo:0];
LABEL_11:
  id v8 = v7;
  (*(void (**)(void))(*(void *)(a1 + 8) + 16))();
}

void sub_100524958(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t sub_10052496C(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_1019DE930)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_1005249AC()
{
  return &off_1019DE930;
}

uint64_t sub_1005249B8(uint64_t a1)
{
  return a1;
}

void sub_1005249E4(uint64_t a1)
{
  operator delete();
}

void *sub_100524A30(uint64_t a1)
{
  uint64_t v2 = operator new(0x10uLL);
  void *v2 = off_1019DE950;
  v2[1] = objc_retainBlock(*(id *)(a1 + 8));
  return v2;
}

id sub_100524A88(uint64_t a1, void *a2)
{
  *a2 = off_1019DE950;
  id result = objc_retainBlock(*(id *)(a1 + 8));
  a2[1] = result;
  return result;
}

void sub_100524AD0(uint64_t a1)
{
}

void sub_100524AD8(id *a1)
{
  operator delete(a1);
}

uint64_t sub_100524B14(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 8) + 16))();
}

uint64_t sub_100524B2C(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_1019DE9B0)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_100524B6C()
{
  return &off_1019DE9B0;
}

uint64_t sub_100524B78(uint64_t a1)
{
  return a1;
}

void sub_100524BA4(uint64_t a1)
{
  operator delete();
}

void *sub_100524BF0(uint64_t a1)
{
  uint64_t v2 = operator new(0x10uLL);
  void *v2 = off_1019DE9D0;
  v2[1] = objc_retainBlock(*(id *)(a1 + 8));
  return v2;
}

id sub_100524C48(uint64_t a1, void *a2)
{
  *a2 = off_1019DE9D0;
  id result = objc_retainBlock(*(id *)(a1 + 8));
  a2[1] = result;
  return result;
}

void sub_100524C90(uint64_t a1)
{
}

void sub_100524C98(id *a1)
{
  operator delete(a1);
}

void sub_100524CD4(uint64_t a1, unint64_t *a2)
{
  unint64_t v3 = *a2;
  id v4 = (id)objc_opt_new();
  [v4 setAvailable:v3 & 1];
  [v4 setCsiError:HIDWORD(v3)];
  (*(void (**)(void))(*(void *)(a1 + 8) + 16))();
}

void sub_100524D50(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t sub_100524D64(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_1019DEA40)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_100524DA4()
{
  return &off_1019DEA40;
}

void *sub_100524DB0(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t sub_100524E34(uint64_t a1)
{
  return a1;
}

void sub_100524E68(uint64_t a1)
{
  operator delete();
}

void *sub_100524EBC(uint64_t a1)
{
  uint64_t v2 = operator new(0x18uLL);
  void *v2 = off_1019DEA60;
  v2[1] = objc_retainBlock(*(id *)(a1 + 8));
  void v2[2] = *(id *)(a1 + 16);
  return v2;
}

id sub_100524F20(uint64_t a1, void *a2)
{
  *a2 = off_1019DEA60;
  a2[1] = objc_retainBlock(*(id *)(a1 + 8));
  id result = *(id *)(a1 + 16);
  a2[2] = result;
  return result;
}

void sub_100524F78(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 8);
}

void sub_100524FB4(id *a1)
{
  operator delete(a1);
}

void sub_100524FF8(uint64_t a1, unsigned __int8 *a2)
{
  id v4 = objc_opt_new();
  if (a2[1])
  {
    id v5 = +[NSNumber numberWithBool:*a2];
    [v4 setCarrierEnabled:v5];
  }
  if (a2[3])
  {
    int v6 = +[NSNumber numberWithBool:a2[2]];
    [v4 setUserAuthenticated:v6];
  }
  if (a2[12])
  {
    id v7 = +[NSNumber numberWithUnsignedInt:*((unsigned int *)a2 + 2)];
    [v4 setMisPdpMaxHosts:v7];
  }
  if (a2[5])
  {
    id v8 = +[NSNumber numberWithBool:a2[4]];
    [v4 setAsserted:v8];
  }
  if (a2[7])
  {
    uint64_t v9 = +[NSNumber numberWithBool:a2[6]];
    [v4 setActivationFailure:v9];
  }
  if (*((_DWORD *)a2 + 48))
  {
    uint64_t v22 = 0;
    char v23 = &v22;
    uint64_t v24 = 0x3032000000;
    char v25 = sub_100521B9C;
    uint64_t v26 = sub_100521BAC;
    id v27 = 0;
    uint64_t v10 = *(void **)(a1 + 16);
    v21[0] = _NSConcreteStackBlock;
    v21[1] = 3221225472;
    void v21[2] = sub_1005253A4;
    v21[3] = &unk_1019DEAD8;
    v21[4] = &v22;
    void v21[5] = a2;
    [v10 getSubscriptionInfo:v21];
    if (v23[5])
    {
      objc_msgSend(v4, "setContext:");
    }
    else
    {
      id v11 = objc_alloc((Class)CTXPCServiceSubscriptionContext);
      int v12 = *((_DWORD *)a2 + 48);
      if (v12 == 1) {
        uint64_t v13 = 1;
      }
      else {
        uint64_t v13 = 2 * (v12 == 2);
      }
      id v14 = [v11 initWithSlot:v13];
      [v4 setContext:v14];
    }
    _Block_object_dispose(&v22, 8);
  }
  if (a2[24])
  {
    long long v15 = objc_opt_new();
    [v4 setConnectionAvailabilityStatus:v15];

    if (!a2[24]
      || (int v16 = a2[16],
          [v4 connectionAvailabilityStatus],
          uint64_t v17 = objc_claimAutoreleasedReturnValue(),
          [v17 setAvailable:v16 != 0],
          v17,
          !a2[24]))
    {
      sub_10016C840();
    }
    uint64_t v18 = *((unsigned int *)a2 + 5);
    char v19 = [v4 connectionAvailabilityStatus];
    [v19 setCsiError:v18];
  }
  if (a2[184])
  {
    char v20 = sub_100020AD0((uint64_t)(a2 + 32));
    [v4 setConnectionStatus:v20];
  }
  (*(void (**)(void))(*(void *)(a1 + 8) + 16))();
}

void sub_1005252EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, id a20)
{
  _Block_object_dispose(&a15, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_100525358(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_1019DEAF8)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_100525398()
{
  return &off_1019DEAF8;
}

void sub_1005253A4(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  if (v5)
  {
    long long v17 = 0u;
    long long v18 = 0u;
    long long v15 = 0u;
    long long v16 = 0u;
    id v7 = objc_msgSend(v5, "subscriptions", 0);
    id v8 = [v7 countByEnumeratingWithState:&v15 objects:v19 count:16];
    if (v8)
    {
      uint64_t v9 = *(void *)v16;
      while (2)
      {
        for (uint64_t i = 0; i != v8; uint64_t i = (char *)i + 1)
        {
          if (*(void *)v16 != v9) {
            objc_enumerationMutation(v7);
          }
          id v11 = *(void **)(*((void *)&v15 + 1) + 8 * i);
          id v12 = [v11 slotID];
          int v13 = *(_DWORD *)(*(void *)(a1 + 40) + 192);
          if (v13 == 1) {
            uint64_t v14 = 1;
          }
          else {
            uint64_t v14 = 2 * (v13 == 2);
          }
          if (v12 == (id)v14)
          {
            objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 32) + 8) + 40), v11);
            goto LABEL_15;
          }
        }
        id v8 = [v7 countByEnumeratingWithState:&v15 objects:v19 count:16];
        if (v8) {
          continue;
        }
        break;
      }
    }
LABEL_15:
  }
}

void sub_100525508(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void *sub_100525538(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t sub_1005255BC(uint64_t a1)
{
  return a1;
}

void sub_1005255E8(uint64_t a1)
{
  operator delete();
}

void *sub_100525634(uint64_t a1)
{
  uint64_t v2 = operator new(0x10uLL);
  void *v2 = off_1019DEB18;
  v2[1] = objc_retainBlock(*(id *)(a1 + 8));
  return v2;
}

id sub_10052568C(uint64_t a1, void *a2)
{
  *a2 = off_1019DEB18;
  id result = objc_retainBlock(*(id *)(a1 + 8));
  a2[1] = result;
  return result;
}

void sub_1005256D4(uint64_t a1)
{
}

void sub_1005256DC(id *a1)
{
  operator delete(a1);
}

void sub_100525718(uint64_t a1, char **a2)
{
  unint64_t v3 = *a2;
  id v4 = a2[1];
  a2[1] = 0;
  a2[2] = 0;
  *a2 = 0;
  id v5 = objc_alloc_init((Class)NSMutableArray);
  if (v3 != v4)
  {
    id v6 = v3;
    do
    {
      [v5 addObject:kCTDataConnectionServiceTypeFromIndex()];
      v6 += 4;
    }
    while (v6 != v4);
  }
  (*(void (**)(void))(*(void *)(a1 + 8) + 16))();

  if (v3)
  {
    operator delete(v3);
  }
}

void sub_1005257D8(_Unwind_Exception *a1)
{
  if (v1) {
    operator delete(v1);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100525800(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_1019DEB88)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_100525840()
{
  return &off_1019DEB88;
}

void *sub_10052584C(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t sub_1005258D0(uint64_t a1)
{
  return a1;
}

void sub_1005258FC(uint64_t a1)
{
  operator delete();
}

void *sub_100525948(uint64_t a1)
{
  uint64_t v2 = operator new(0x10uLL);
  void *v2 = off_1019DEBA8;
  v2[1] = objc_retainBlock(*(id *)(a1 + 8));
  return v2;
}

id sub_1005259A0(uint64_t a1, void *a2)
{
  *a2 = off_1019DEBA8;
  id result = objc_retainBlock(*(id *)(a1 + 8));
  a2[1] = result;
  return result;
}

void sub_1005259E8(id *a1)
{
  operator delete(a1);
}

uint64_t sub_100525A24(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_1019DEC18)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_100525A64()
{
  return &off_1019DEC18;
}

void sub_100525A70(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 144) && *(unsigned char *)(a1 + 136))
  {
    uint64_t v2 = (void **)(a1 + 112);
    sub_100523284(&v2);
  }
  if (*(unsigned char *)(a1 + 80))
  {
    if (*(unsigned char *)(a1 + 72))
    {
      uint64_t v2 = (void **)(a1 + 48);
      sub_100523284(&v2);
    }
  }
}

uint64_t sub_100525AD8(uint64_t a1)
{
  return a1;
}

void sub_100525B04(uint64_t a1)
{
  operator delete();
}

void *sub_100525B50(uint64_t a1)
{
  uint64_t v2 = operator new(0x10uLL);
  void *v2 = off_1019DEC38;
  v2[1] = objc_retainBlock(*(id *)(a1 + 8));
  return v2;
}

id sub_100525BA8(uint64_t a1, void *a2)
{
  *a2 = off_1019DEC38;
  id result = objc_retainBlock(*(id *)(a1 + 8));
  a2[1] = result;
  return result;
}

void sub_100525BF0(uint64_t a1)
{
}

void sub_100525BF8(id *a1)
{
  operator delete(a1);
}

void sub_100525C34(uint64_t a1, uint64_t *a2, void *a3)
{
  uint64_t v3 = *(void *)(a1 + 8);
  sub_1005B069C(a2, a3);
  id v4 = (id)objc_claimAutoreleasedReturnValue();
  (*(void (**)(uint64_t))(v3 + 16))(v3);
}

void sub_100525C9C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t sub_100525CB0(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_1019DECA8)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_100525CF0()
{
  return &off_1019DECA8;
}

void *sub_100525CFC(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t sub_100525D80(uint64_t a1)
{
  return a1;
}

void sub_100525DAC(uint64_t a1)
{
  operator delete();
}

void *sub_100525DF8(uint64_t a1)
{
  uint64_t v2 = operator new(0x10uLL);
  void *v2 = off_1019DECC8;
  v2[1] = objc_retainBlock(*(id *)(a1 + 8));
  return v2;
}

id sub_100525E50(uint64_t a1, void *a2)
{
  *a2 = off_1019DECC8;
  id result = objc_retainBlock(*(id *)(a1 + 8));
  a2[1] = result;
  return result;
}

void sub_100525E98(uint64_t a1)
{
}

void sub_100525EA0(id *a1)
{
  operator delete(a1);
}

void sub_100525EDC(uint64_t a1, void *a2)
{
  v18[0] = 0;
  v18[1] = 0;
  v16[1] = 0;
  long long v17 = (uint64_t *)v18;
  long long v15 = v16;
  v16[0] = 0;
  uint64_t v3 = a2 + 1;
  id v4 = (void *)*a2;
  if ((void *)*a2 != a2 + 1)
  {
    do
    {
      memset(v14, 0, sizeof(v14));
      long long v13 = 0u;
      TrafficDescriptor::TrafficDescriptor((TrafficDescriptor *)&v13, (const TrafficDescriptor *)(v4 + 4));
      __p.n128_u8[0] = 0;
      char v12 = 0;
      sub_100179CB0((uint64_t)v14, &__p);
      if (v12 && SHIBYTE(v11) < 0) {
        operator delete((void *)__p.n128_u64[0]);
      }
      BYTE4(v13) = 0;
      BYTE8(v13) = 0;
      if ((TrafficDescriptor::empty((TrafficDescriptor *)&v13) & 1) == 0)
      {
        __n128 __p = 0uLL;
        uint64_t v11 = 0;
        TrafficDescriptor::toKey((uint64_t *)&__p, (TrafficDescriptor *)&v13);
        if (v16 == (char **)sub_100046F68((uint64_t)&v15, (void **)&__p))
        {
          sub_1003816BC(&v17, (uint64_t)&v13, (const TrafficDescriptor *)&v13);
          sub_100046BAC((uint64_t **)&v15, (void **)&__p, (uint64_t)&__p);
        }
        if (SHIBYTE(v11) < 0) {
          operator delete((void *)__p.n128_u64[0]);
        }
      }
      TrafficDescriptor::~TrafficDescriptor((TrafficDescriptor *)&v13);
      id v5 = (void *)v4[1];
      if (v5)
      {
        do
        {
          id v6 = v5;
          id v5 = (void *)*v5;
        }
        while (v5);
      }
      else
      {
        do
        {
          id v6 = (void *)v4[2];
          BOOL v7 = *v6 == (void)v4;
          id v4 = v6;
        }
        while (!v7);
      }
      id v4 = v6;
    }
    while (v6 != v3);
  }
  id v8 = sub_100069448(&v17);
  uint64_t v9 = objc_opt_new();
  [v9 setTrafficDescriptors:v8];
  (*(void (**)(void))(*(void *)(a1 + 8) + 16))();

  sub_10005CD2C((uint64_t)&v15, v16[0]);
  sub_10005D9E0((uint64_t)&v17, v18[0]);
}

void sub_1005260B8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, char a16)
{
  sub_10005CD2C(v17 - 96, *(char **)(v17 - 88));
  sub_10005D9E0(v17 - 72, *(void **)(v17 - 64));
  _Unwind_Resume(a1);
}

uint64_t sub_100526128(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_1019DED38)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_100526168()
{
  return &off_1019DED38;
}

void *sub_100526174(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t sub_1005261F8(uint64_t a1)
{
  return a1;
}

void sub_100526224(uint64_t a1)
{
  operator delete();
}

void *sub_100526270(uint64_t a1)
{
  uint64_t v2 = operator new(0x10uLL);
  void *v2 = off_1019DED58;
  v2[1] = objc_retainBlock(*(id *)(a1 + 8));
  return v2;
}

id sub_1005262C8(uint64_t a1, void *a2)
{
  *a2 = off_1019DED58;
  id result = objc_retainBlock(*(id *)(a1 + 8));
  a2[1] = result;
  return result;
}

void sub_100526310(id *a1)
{
  operator delete(a1);
}

uint64_t sub_10052634C(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_1019DEDC8)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_10052638C()
{
  return &off_1019DEDC8;
}

uint64_t sub_100526398(uint64_t a1)
{
  return a1;
}

void sub_1005263C4(uint64_t a1)
{
  operator delete();
}

void *sub_100526410(uint64_t a1)
{
  uint64_t v2 = operator new(0x10uLL);
  void *v2 = off_1019DEDE8;
  v2[1] = objc_retainBlock(*(id *)(a1 + 8));
  return v2;
}

id sub_100526468(uint64_t a1, void *a2)
{
  *a2 = off_1019DEDE8;
  id result = objc_retainBlock(*(id *)(a1 + 8));
  a2[1] = result;
  return result;
}

void sub_1005264B0(uint64_t a1)
{
}

void sub_1005264B8(id *a1)
{
  operator delete(a1);
}

uint64_t sub_1005264F4(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  unsigned int v3 = *(_DWORD *)(a2 + 20);
  if (v3 - 1 >= 6) {
    uint64_t v4 = 0;
  }
  else {
    uint64_t v4 = v3;
  }
  return (*(uint64_t (**)(uint64_t, uint64_t, void))(v2 + 16))(v2, v4, 0);
}

uint64_t sub_100526518(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_1019DEE48)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_100526558()
{
  return &off_1019DEE48;
}

uint64_t sub_100526564(uint64_t a1)
{
  return a1;
}

void sub_100526590(uint64_t a1)
{
  operator delete();
}

void *sub_1005265DC(uint64_t a1)
{
  uint64_t v2 = operator new(0x10uLL);
  void *v2 = off_1019DEE68;
  v2[1] = objc_retainBlock(*(id *)(a1 + 8));
  return v2;
}

id sub_100526634(uint64_t a1, void *a2)
{
  *a2 = off_1019DEE68;
  id result = objc_retainBlock(*(id *)(a1 + 8));
  a2[1] = result;
  return result;
}

void sub_10052667C(uint64_t a1)
{
}

void sub_100526684(id *a1)
{
  operator delete(a1);
}

uint64_t sub_1005266C0(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 8) + 16))();
}

uint64_t sub_1005266DC(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_1019DEEC8)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_10052671C()
{
  return &off_1019DEEC8;
}

uint64_t sub_100526728(uint64_t a1)
{
  return a1;
}

void sub_100526754(uint64_t a1)
{
  operator delete();
}

void *sub_1005267A0(uint64_t a1)
{
  uint64_t v2 = operator new(0x10uLL);
  void *v2 = off_1019DEEE8;
  v2[1] = objc_retainBlock(*(id *)(a1 + 8));
  return v2;
}

id sub_1005267F8(uint64_t a1, void *a2)
{
  *a2 = off_1019DEEE8;
  id result = objc_retainBlock(*(id *)(a1 + 8));
  a2[1] = result;
  return result;
}

void sub_100526840(uint64_t a1)
{
}

void sub_100526848(id *a1)
{
  operator delete(a1);
}

void sub_100526884(uint64_t a1, unsigned __int8 *a2, unsigned char *a3)
{
  int v3 = *a2;
  int v4 = *a3;
  uint64_t v5 = *(void *)(a1 + 8);
  if (*a3) {
    id v6 = 0;
  }
  else {
    id v6 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
  }
  id v7 = v6;
  (*(void (**)(uint64_t, BOOL))(v5 + 16))(v5, v3 != 0);
  if (!v4)
  {
  }
}

void sub_100526938(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  if (!v10) {

  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100526950(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_1019DEF48)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_100526990()
{
  return &off_1019DEF48;
}

uint64_t sub_10052699C(uint64_t a1)
{
  return a1;
}

void sub_1005269C8(uint64_t a1)
{
  operator delete();
}

void *sub_100526A14(uint64_t a1)
{
  uint64_t v2 = operator new(0x10uLL);
  void *v2 = off_1019DEF68;
  v2[1] = objc_retainBlock(*(id *)(a1 + 8));
  return v2;
}

id sub_100526A6C(uint64_t a1, void *a2)
{
  *a2 = off_1019DEF68;
  id result = objc_retainBlock(*(id *)(a1 + 8));
  a2[1] = result;
  return result;
}

void sub_100526AB4(uint64_t a1)
{
}

void sub_100526ABC(id *a1)
{
  operator delete(a1);
}

void sub_100526AF8(uint64_t a1, unsigned char *a2)
{
  int v2 = *a2;
  uint64_t v3 = *(void *)(a1 + 8);
  if (*a2) {
    id v4 = 0;
  }
  else {
    id v4 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
  }
  id v5 = v4;
  (*(void (**)(uint64_t))(v3 + 16))(v3);
  if (!v2)
  {
  }
}

void sub_100526BA0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  if (!v10) {

  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100526BB8(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_1019DEFC8)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_100526BF8()
{
  return &off_1019DEFC8;
}

void *sub_100526C04(void *a1, char *a2, char *a3)
{
  *a1 = off_1019DEFE8;
  id v5 = a1 + 4;
  if (!a2) {
    a2 = "";
  }
  sub_100058DB0(a1 + 1, a2);
  if (a3) {
    id v6 = a3;
  }
  else {
    id v6 = "";
  }
  sub_100058DB0(v5, v6);
  return a1;
}

void sub_100526C88(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 31) < 0) {
    operator delete(*v2);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100526CA4(uint64_t a1, char *a2)
{
  return 1;
}

uint64_t sub_100526CC4(uint64_t a1, uint64_t a2)
{
  return sub_100FECA4C(a2, (std::string *)(a1 + 32));
}

uint64_t sub_100526CD4(uint64_t a1, uint64_t a2)
{
  int v2 = (unsigned char *)(a1 + 8);
  if ((*(char *)(a1 + 31) & 0x80000000) == 0)
  {
    if (!*(unsigned char *)(a1 + 31)) {
      return 0;
    }
LABEL_6:
    sub_10078E554(a2, v2);
    return 1;
  }
  if (*(void *)(a1 + 16))
  {
    int v2 = *(unsigned char **)v2;
    goto LABEL_6;
  }
  return 0;
}

uint64_t sub_100526D20(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (unsigned char *)(a1 + 32);
  if (*(char *)(a1 + 55) < 0) {
    uint64_t v3 = *(unsigned char **)v3;
  }
  sub_10078E78C(a2, v3);
  return 1;
}

uint64_t sub_100526D54(uint64_t a1)
{
  uint64_t result = a1 + 8;
  if (*(char *)(a1 + 31) < 0) {
    return *(void *)result;
  }
  return result;
}

uint64_t sub_100526D70(uint64_t a1, std::string *this)
{
  std::string::operator=(this, (const std::string *)(a1 + 32));
  return 1;
}

void sub_100526D98()
{
}

void sub_100526E58()
{
  if (*(char *)(v0 + 31) < 0) {
    operator delete(*v1);
  }
  operator delete();
}

const char *sub_100526E94()
{
  return "simple";
}

uint64_t sub_100526EA0(uint64_t a1)
{
  *(void *)a1 = off_1019DEFE8;
  if (*(char *)(a1 + 55) < 0) {
    operator delete(*(void **)(a1 + 32));
  }
  if (*(char *)(a1 + 31) < 0) {
    operator delete(*(void **)(a1 + 8));
  }
  return a1;
}

void sub_100526F00(uint64_t a1)
{
  *(void *)a1 = off_1019DEFE8;
  if (*(char *)(a1 + 55) < 0) {
    operator delete(*(void **)(a1 + 32));
  }
  if (*(char *)(a1 + 31) < 0) {
    operator delete(*(void **)(a1 + 8));
  }

  operator delete();
}

void sub_100526F80()
{
  uint64_t v0 = operator new(0x28uLL);
  v0[1] = 0;
  v0[2] = 0;
  *uint64_t v0 = off_1019DF070;
  WidgetNanoRegistryDelegate::WidgetNanoRegistryDelegate((WidgetNanoRegistryDelegate *)(v0 + 3));
  long long v4 = 0uLL;
  uint64_t v2 = v1;
  uint64_t v3 = v0;
  atomic_fetch_add_explicit(v0 + 1, 1uLL, memory_order_relaxed);
  sub_10077FDE0();
}

void sub_1005270D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14, uint64_t a15, uint64_t a16)
{
  if (a16) {
    (*(void (**)(uint64_t))(*(void *)a16 + 8))(a16);
  }
  if (a10) {
    sub_10004D2C8(a10);
  }
  if (a14) {
    sub_10004D2C8(a14);
  }
  sub_10004D2C8(v16);
  _Unwind_Resume(a1);
}

void sub_100527170(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1019DF070;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100527190(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1019DF070;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_1005271E4(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 24) + 16))();
}

void sub_10052720C(ServiceManager::Service *this)
{
  *(void *)this = off_1019DF0C0;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }

  ServiceManager::Service::~Service(this);
}

void sub_100527268(ServiceManager::Service *this)
{
  *(void *)this = off_1019DF0C0;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  ServiceManager::Service::~Service(this);

  operator delete();
}

void *sub_1005272D8@<X0>(void *a1@<X8>)
{
  return sub_100058DB0(a1, "TinkerController");
}

unsigned char *sub_1005272E8@<X0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  uint64_t v2 = operator new(1uLL);
  *a1 = v2;
  unsigned char *v2 = 0;
  uint64_t result = v2 + 1;
  a1[1] = result;
  a1[2] = result;
  return result;
}

void sub_100527324(uint64_t a1, NSObject **a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v3 = *a2;
  dispatch_group_t group = v3;
  if (v3)
  {
    dispatch_retain(v3);
    dispatch_group_enter(v3);
  }
  sub_10077FFA4(v2, &group);
}

void sub_10052738C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_group_t group)
{
  if (group)
  {
    dispatch_group_leave(group);
    dispatch_release(group);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1005273B0()
{
  return 0;
}

uint64_t sub_1005273B8()
{
  return 1;
}

uint64_t sub_1005273C0()
{
  return 0;
}

void sub_1005273CC(uint64_t a1)
{
}

void sub_1005273D4(uint64_t a1, int a2, ServiceStage *a3)
{
}

void sub_1005273E4(uint64_t *a1@<X0>, NSObject **a2@<X1>, uint64_t a3@<X8>)
{
  if (capabilities::ct::getRadioModuleType((capabilities::ct *)a1) == 2)
  {
    if (!*a2) {
      __assert_rtn("sCreateDataPlanManager", "DataPlanManagerPrivateInterface.cpp", 71, "\"q is invalid\" && q");
    }
    if (!*a1) {
      __assert_rtn("sCreateDataPlanManager", "DataPlanManagerPrivateInterface.cpp", 72, "\"registry is invalid\" && registry");
    }
    uint64_t v12 = 0;
    long long v13 = 0;
    sub_100527538(a1, &v12);
    id v6 = *a2;
    dispatch_object_t object = v6;
    if (v6) {
      dispatch_retain(v6);
    }
    uint64_t v8 = v12;
    uint64_t v9 = v13;
    if (v13) {
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    DataPlanManagerBootstrap::sCreate((uint64_t)a1, &object, &v8, &v11);
    long long v7 = v11;
    long long v11 = 0uLL;
    if (v9) {
      sub_10004D2C8(v9);
    }
    if (object) {
      dispatch_release(object);
    }
    *(_OWORD *)a3 = v7;
    if (v13) {
      sub_10004D2C8(v13);
    }
  }
  else
  {
    *(void *)a3 = 0;
    *(void *)(a3 + 8) = 0;
  }
}

void sub_100527508(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, std::__shared_weak_count *a13, dispatch_object_t object)
{
  if (a13) {
    sub_10004D2C8(a13);
  }
  if (object) {
    dispatch_release(object);
  }
  long long v16 = *(std::__shared_weak_count **)(v14 - 40);
  if (v16) {
    sub_10004D2C8(v16);
  }
  _Unwind_Resume(exception_object);
}

void *sub_100527538@<X0>(uint64_t *a1@<X1>, void *a2@<X8>)
{
  uint64_t result = operator new(0x30uLL);
  result[1] = 0;
  result[2] = 0;
  *uint64_t result = off_1019DF140;
  uint64_t v6 = *a1;
  uint64_t v5 = a1[1];
  result[3] = off_1019DE110;
  result[4] = v6;
  result[5] = v5;
  if (v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
  }
  *a2 = result + 3;
  a2[1] = result;
  return result;
}

void sub_1005275C0(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1019DF140;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1005275E0(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1019DF140;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100527634(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_10052765C(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  operator new();
}

void sub_10052774C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object, uint64_t a11, uint64_t a12)
{
  uint64_t v14 = *(std::__shared_weak_count **)(v12 + 8);
  if (v14) {
    sub_10004D2C8(v14);
  }
  _Unwind_Resume(exception_object);
}

void *sub_1005277A0(void *a1, long long *a2, uint64_t a3, uint64_t a4, dispatch_object_t *a5, int a6)
{
  long long v7 = *a2;
  *(void *)a2 = 0;
  *((void *)a2 + 1) = 0;
  dispatch_object_t object = *a5;
  *a5 = 0;
  uint64_t v8 = "DATA.Connection.CarrierSpace.X";
  int v9 = *(_DWORD *)(*(void *)a3 + 52);
  if (v9 == 2) {
    uint64_t v8 = "DATA.Connection.CarrierSpace.2";
  }
  int v10 = "CarrierSpace.2";
  if (v9 != 2) {
    int v10 = "CarrierSpace.X";
  }
  long long v15 = v7;
  if (v9 == 1) {
    long long v11 = "DATA.Connection.CarrierSpace.1";
  }
  else {
    long long v11 = v8;
  }
  if (v9 == 1) {
    uint64_t v12 = "CarrierSpace.1";
  }
  else {
    uint64_t v12 = v10;
  }
  sub_10129653C((uint64_t)a1, (uint64_t *)&off_1019DFD58, &v15, a3, a4, &object, v11, (uint64_t)v12, a6);
  if (object) {
    dispatch_release(object);
  }
  if (*((void *)&v15 + 1)) {
    sub_10004D2C8(*((std::__shared_weak_count **)&v15 + 1));
  }
  *a1 = off_1019DF320;
  a1[8] = off_1019DF870;
  a1[9] = off_1019DFB00;
  a1[10] = off_1019DFCF0;
  return a1;
}

void sub_100527908(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object, uint64_t a11, std::__shared_weak_count *a12)
{
  if (object) {
    dispatch_release(object);
  }
  if (a12) {
    sub_10004D2C8(a12);
  }
  PersonalitySpecific::~PersonalitySpecific(v12);
  _Unwind_Resume(a1);
}

void sub_100527934(uint64_t a1)
{
  sub_101296BD8(a1, (uint64_t *)&off_1019DFD58);

  PersonalitySpecific::~PersonalitySpecific(v1);
}

void sub_100527964(uint64_t a1)
{
  sub_101296BD8(a1 - 64, (uint64_t *)&off_1019DFD58);

  PersonalitySpecific::~PersonalitySpecific(v1);
}

void sub_100527998(uint64_t a1)
{
  sub_101296BD8(a1 - 72, (uint64_t *)&off_1019DFD58);

  PersonalitySpecific::~PersonalitySpecific(v1);
}

void sub_1005279CC(uint64_t a1)
{
  sub_101296BD8(a1 - 80, (uint64_t *)&off_1019DFD58);

  PersonalitySpecific::~PersonalitySpecific(v1);
}

void sub_100527A00(uint64_t a1)
{
  sub_101296BD8(a1, (uint64_t *)&off_1019DFD58);
  PersonalitySpecific::~PersonalitySpecific(v1);

  operator delete();
}

void sub_100527A44(uint64_t a1)
{
}

void sub_100527A4C(uint64_t a1)
{
}

void sub_100527A54(uint64_t a1)
{
}

uint64_t sub_100527A5C(Registry **a1)
{
  uint64_t v15 = 0;
  long long v16 = 0;
  ServiceMap = (std::mutex *)Registry::getServiceMap(a1[11]);
  uint64_t v3 = ServiceMap;
  if ((v4 & 0x8000000000000000) != 0)
  {
    uint64_t v5 = (unsigned __int8 *)(v4 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v6 = 5381;
    do
    {
      unint64_t v4 = v6;
      unsigned int v7 = *v5++;
      uint64_t v6 = (33 * v6) ^ v7;
    }
    while (v7);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v17 = v4;
  uint64_t v8 = sub_10004D37C(&v3[1].__m_.__sig, &v17);
  if (v8)
  {
    uint64_t v10 = v8[3];
    int v9 = (std::__shared_weak_count *)v8[4];
    if (v9) {
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
    }
  }
  else
  {
    uint64_t v10 = 0;
    int v9 = 0;
  }
  std::mutex::unlock(v3);
  uint64_t v15 = v10;
  long long v16 = v9;
  if (v9)
  {
    atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v9);
  }
  if (!v10)
  {
    uint64_t v13 = 0x1000000;
    if (!v9) {
      return v13;
    }
    goto LABEL_15;
  }
  uint64_t v11 = PersonalitySpecificImpl::simSlot((PersonalitySpecificImpl *)a1);
  int v12 = sub_100527BA0(v11, (uint64_t)&v15, carrier_space::kCBAllowedWhenRoamingKey, 0);
  int v9 = v16;
  if (v12) {
    uint64_t v13 = 0x10001000000;
  }
  else {
    uint64_t v13 = 0x1000000;
  }
  if (v16) {
LABEL_15:
  }
    sub_10004D2C8(v9);
  return v13;
}

void sub_100527B88(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11)
{
  if (a11) {
    sub_10004D2C8(a11);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100527BA0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  CFTypeRef cf = 0;
  carrier_space::getCarrierSpaceValueForKey();
  sub_1000577C4(&cf);
  return a4;
}

void sub_100527C40(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9)
{
}

uint64_t sub_100527C54(uint64_t a1)
{
  return sub_100527A5C((Registry **)(a1 - 72));
}

uint64_t sub_100527C74()
{
  return 0;
}

void sub_100527C7C(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_100527D48(void *a1)
{
  __cxa_begin_catch(a1);
  dispatch_barrier_async_f(v1[5], v1, (dispatch_function_t)sub_100527E20);
  __cxa_rethrow();
}

void sub_100527D70(_Unwind_Exception *a1)
{
}

void sub_100527D88(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100527DC0(uint64_t a1)
{
}

uint64_t sub_100527DDC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_100527E20(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void sub_100527E78()
{
}

const void **sub_100527E94(uint64_t a1, const void **a2)
{
  sub_100058198(&v3, a2);
  sub_100527F38((wis::MetricFactory *)0x800DE);
  return sub_100057D78(&v3);
}

void sub_100527F24(_Unwind_Exception *a1)
{
  sub_100057D78(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100527F38(wis::MetricFactory *a1)
{
  unsigned int v1 = a1;
  SharedMetricFactory = (wis::MetricFactory *)wis::MetricFactory::getSharedMetricFactory(a1);
  uint64_t v3 = wis::MetricFactory::newMetricContainerWithIdentifier(SharedMetricFactory, v1);
  if (v3)
  {
    unint64_t v4 = (wis::MetricContainer *)v3;
    uint64_t v5 = sub_10001C8F4(8);
    uint64_t v7 = *v5;
    uint64_t v6 = (std::__shared_weak_count *)v5[1];
    if (v6) {
      atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    if (v7) {
      operator new();
    }
    if (v6) {
      sub_10004D2C8(v6);
    }
    wis::MetricContainer::~MetricContainer(v4);
    operator delete();
  }
  return 0;
}

void sub_100528094(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  sub_100129880((wis::MetricContainer **)va, 0);
  _Unwind_Resume(a1);
}

void sub_100528118(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 32);
  uint64_t v5 = *(NSObject **)(v4 + 40);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(buf.__r_.__value_.__l.__data_) = 0;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Submitting metric on desktop update for bundle transfer failure", (uint8_t *)&buf, 2u);
  }
  CFDictionaryRef v6 = *(const __CFDictionary **)(a1 + 40);
  if (v6) {
    uint64_t v7 = sub_100080778;
  }
  else {
    uint64_t v7 = 0;
  }
  if (v7)
  {
    int v8 = *(_DWORD *)(a2 + 28);
    uint64_t v9 = *(int *)(a2 + 24);
    if ((int)v9 >= v8)
    {
      if (v8 == *(_DWORD *)(a2 + 32))
      {
        wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve((wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(a2 + 16), v8 + 1);
        int v8 = *(_DWORD *)(a2 + 28);
      }
      *(_DWORD *)(a2 + 28) = v8 + 1;
      sub_100528594();
    }
    uint64_t v10 = *(void *)(a2 + 16);
    *(_DWORD *)(a2 + 24) = v9 + 1;
    uint64_t v11 = *(void *)(v10 + 8 * v9);
    CFDictionaryGetValue(v6, @"BundleID");
    memset(&buf, 0, sizeof(buf));
    ctu::cf::assign();
    std::string __str = buf;
    uint64_t v12 = *(void *)(v4 + 64);
    CFDictionaryRef v13 = *(const __CFDictionary **)(a1 + 40);
    memset(&v24, 0, sizeof(v24));
    CFDictionaryGetValue(v13, @"BundleURL");
    memset(&buf, 0, sizeof(buf));
    ctu::cf::assign();
    std::string __p = buf;
    (*(void (**)(std::string *__return_ptr, uint64_t, std::string *))(*(void *)v12 + 120))(&v24, v12, &__p);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 40), @"BundleVersion");
    memset(&buf, 0, sizeof(buf));
    ctu::cf::assign();
    std::string __p = buf;
    *(_DWORD *)(v11 + 40) |= 2u;
    uint64_t v14 = *(std::string **)(v11 + 8);
    if (v14 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString) {
      operator new();
    }
    std::string::operator=(v14, &__str);
    *(_DWORD *)(v11 + 40) |= 4u;
    uint64_t v15 = *(std::string **)(v11 + 16);
    if (v15 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString) {
      operator new();
    }
    std::string::operator=(v15, &v24);
    *(_DWORD *)(v11 + 40) |= 8u;
    long long v16 = *(std::string **)(v11 + 24);
    if (v16 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString) {
      operator new();
    }
    std::string::operator=(v16, &__p);
    unint64_t v17 = *(NSObject **)(v4 + 40);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
    {
      p_str = &__str;
      if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        p_str = (std::string *)__str.__r_.__value_.__r.__words[0];
      }
      char v19 = &v24;
      if ((v24.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        char v19 = (std::string *)v24.__r_.__value_.__r.__words[0];
      }
      p_p = &__p;
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      LODWORD(buf.__r_.__value_.__l.__data_) = 136446722;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)p_str;
      WORD2(buf.__r_.__value_.__r.__words[1]) = 2082;
      *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v19;
      HIWORD(buf.__r_.__value_.__r.__words[2]) = 2082;
      id v27 = p_p;
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I Filling metric details on desktop bundle update info %{public}s, %{public}s, %{public}s", (uint8_t *)&buf, 0x20u);
    }
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v24.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v24.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__str.__r_.__value_.__l.__data_);
    }
  }
  int v21 = *(_DWORD *)(a2 + 52);
  *(unsigned char *)(a2 + 46) = 1;
  *(_DWORD *)(a2 + 40) = 6;
  char v22 = *(unsigned char *)(v4 + 112);
  *(_DWORD *)(a2 + 52) = v21 | 0x68;
  *(unsigned char *)(a2 + 47) = v22;
}

void sub_1005284F0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,uint64_t a27,void *__p,uint64_t a29,int a30,__int16 a31,char a32,char a33)
{
  if (a33 < 0) {
    operator delete(__p);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  if (a26 < 0) {
    operator delete(a21);
  }
  _Unwind_Resume(exception_object);
}

void sub_100528594()
{
}

void sub_1005285D4()
{
}

void sub_1005285F8(uint64_t a1)
{
}

void sub_100528600(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 32);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v3 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Submitting scheduled update metric", v3, 2u);
  }
  CFDateGetAbsoluteTime(*(CFDateRef *)(a1 + 40));
  operator new();
}

void sub_100528794(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  if (v2) {
    sub_10004D2C8(v2);
  }
  _Unwind_Resume(a1);
}

void sub_100528834(uint64_t a1@<X0>, void *a2@<X1>, void *a3@<X8>)
{
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 16);
  if (v5)
  {
    uint64_t v7 = std::__shared_weak_count::lock(v5);
    uint64_t v10 = v7;
    if (v7)
    {
      if (*(void *)(a1 + 8))
      {
        long long v8 = 0uLL;
        *a2 = 0;
        sub_10008E8D8(&v8);
      }
      sub_10004D2C8(v7);
    }
  }
  *a3 = 0;
  a3[1] = 0;
}

void sub_100528968(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object, uint64_t a11, std::__shared_weak_count *a12)
{
  if (v13) {
    std::__shared_weak_count::__release_weak(v13);
  }
  if (a12) {
    sub_10004D2C8(a12);
  }
  sub_10004D2C8(v12);
  _Unwind_Resume(a1);
}

void sub_1005289A8()
{
}

void sub_1005289E0(STKFactoryInterface *this)
{
  *(void *)this = off_1019E0C50;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  STKFactoryInterface::~STKFactoryInterface(this);
}

void sub_100528A3C(STKFactoryInterface *this)
{
  *(void *)this = off_1019E0C50;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  STKFactoryInterface::~STKFactoryInterface(this);

  operator delete();
}

uint64_t sub_100528AAC(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_100528ADC(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

void sub_100528B2C(uint64_t a1, long long *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 16);
  if (v5)
  {
    uint64_t v9 = std::__shared_weak_count::lock(v5);
    if (v9)
    {
      uint64_t v10 = v9;
      uint64_t v11 = *(void *)(a1 + 8);
      if (v11)
      {
        long long v12 = *a2;
        *(void *)a2 = 0;
        *((void *)a2 + 1) = 0;
        (*(void (**)(uint64_t, long long *, uint64_t, uint64_t))(*(void *)v11 + 16))(v11, &v12, a3, a4);
        if (*((void *)&v12 + 1)) {
          sub_10004D2C8(*((std::__shared_weak_count **)&v12 + 1));
        }
      }
      sub_10004D2C8(v10);
    }
  }
}

void sub_100528BDC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  sub_10004D2C8(v10);
  _Unwind_Resume(a1);
}

void sub_100528BFC(uint64_t a1, long long *a2, uint64_t a3)
{
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4)
  {
    uint64_t v7 = std::__shared_weak_count::lock(v4);
    if (v7)
    {
      long long v8 = v7;
      uint64_t v9 = *(void *)(a1 + 8);
      if (v9)
      {
        long long v10 = *a2;
        *(void *)a2 = 0;
        *((void *)a2 + 1) = 0;
        (*(void (**)(uint64_t, long long *, uint64_t))(*(void *)v9 + 24))(v9, &v10, a3);
        if (*((void *)&v10 + 1)) {
          sub_10004D2C8(*((std::__shared_weak_count **)&v10 + 1));
        }
      }
      sub_10004D2C8(v8);
    }
  }
}

void sub_100528C9C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  sub_10004D2C8(v10);
  _Unwind_Resume(a1);
}

void sub_100528CBC(uint64_t a1, long long *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 16);
  if (v5)
  {
    uint64_t v9 = std::__shared_weak_count::lock(v5);
    if (v9)
    {
      long long v10 = v9;
      uint64_t v11 = *(void *)(a1 + 8);
      if (v11)
      {
        long long v12 = *a2;
        *(void *)a2 = 0;
        *((void *)a2 + 1) = 0;
        (*(void (**)(uint64_t, long long *, uint64_t, uint64_t))(*(void *)v11 + 32))(v11, &v12, a3, a4);
        if (*((void *)&v12 + 1)) {
          sub_10004D2C8(*((std::__shared_weak_count **)&v12 + 1));
        }
      }
      sub_10004D2C8(v10);
    }
  }
}

void sub_100528D6C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  sub_10004D2C8(v10);
  _Unwind_Resume(a1);
}

void sub_100528D8C(uint64_t a1, long long *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  CFDictionaryRef v6 = *(std::__shared_weak_count **)(a1 + 16);
  if (v6)
  {
    uint64_t v11 = std::__shared_weak_count::lock(v6);
    if (v11)
    {
      long long v12 = v11;
      uint64_t v13 = *(void *)(a1 + 8);
      if (v13)
      {
        long long v16 = *a2;
        *(void *)a2 = 0;
        *((void *)a2 + 1) = 0;
        *(_OWORD *)std::string __p = *(_OWORD *)a5;
        uint64_t v15 = *(void *)(a5 + 16);
        *(void *)(a5 + 8) = 0;
        *(void *)(a5 + 16) = 0;
        *(void *)a5 = 0;
        (*(void (**)(uint64_t, long long *, uint64_t, uint64_t, void **))(*(void *)v13 + 40))(v13, &v16, a3, a4, __p);
        if (SHIBYTE(v15) < 0) {
          operator delete(__p[0]);
        }
        if (*((void *)&v16 + 1)) {
          sub_10004D2C8(*((std::__shared_weak_count **)&v16 + 1));
        }
      }
      sub_10004D2C8(v12);
    }
  }
}

void sub_100528E6C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, std::__shared_weak_count *a17)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a17) {
    sub_10004D2C8(a17);
  }
  sub_10004D2C8(v17);
  _Unwind_Resume(a1);
}

void sub_100528E9C(uint64_t a1, long long *a2, uint64_t a3)
{
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4)
  {
    uint64_t v7 = std::__shared_weak_count::lock(v4);
    if (v7)
    {
      long long v8 = v7;
      uint64_t v9 = *(void *)(a1 + 8);
      if (v9)
      {
        long long v10 = *a2;
        *(void *)a2 = 0;
        *((void *)a2 + 1) = 0;
        (*(void (**)(uint64_t, long long *, uint64_t))(*(void *)v9 + 48))(v9, &v10, a3);
        if (*((void *)&v10 + 1)) {
          sub_10004D2C8(*((std::__shared_weak_count **)&v10 + 1));
        }
      }
      sub_10004D2C8(v8);
    }
  }
}

void sub_100528F3C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  sub_10004D2C8(v10);
  _Unwind_Resume(a1);
}

void sub_100528F5C(uint64_t a1, long long *a2, uint64_t a3)
{
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4)
  {
    uint64_t v7 = std::__shared_weak_count::lock(v4);
    if (v7)
    {
      long long v8 = v7;
      uint64_t v9 = *(void *)(a1 + 8);
      if (v9)
      {
        long long v10 = *a2;
        *(void *)a2 = 0;
        *((void *)a2 + 1) = 0;
        (*(void (**)(uint64_t, long long *, uint64_t))(*(void *)v9 + 56))(v9, &v10, a3);
        if (*((void *)&v10 + 1)) {
          sub_10004D2C8(*((std::__shared_weak_count **)&v10 + 1));
        }
      }
      sub_10004D2C8(v8);
    }
  }
}

void sub_100528FFC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  sub_10004D2C8(v10);
  _Unwind_Resume(a1);
}

void sub_10052901C(uint64_t a1, long long *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 16);
  if (v5)
  {
    uint64_t v9 = std::__shared_weak_count::lock(v5);
    if (v9)
    {
      long long v10 = v9;
      uint64_t v11 = *(void *)(a1 + 8);
      if (v11)
      {
        long long v12 = *a2;
        *(void *)a2 = 0;
        *((void *)a2 + 1) = 0;
        (*(void (**)(uint64_t, long long *, uint64_t, uint64_t))(*(void *)v11 + 64))(v11, &v12, a3, a4);
        if (*((void *)&v12 + 1)) {
          sub_10004D2C8(*((std::__shared_weak_count **)&v12 + 1));
        }
      }
      sub_10004D2C8(v10);
    }
  }
}

void sub_1005290CC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  sub_10004D2C8(v10);
  _Unwind_Resume(a1);
}

uint64_t sub_1005290EC(uint64_t a1, long long *a2)
{
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (!v3) {
    return 0;
  }
  uint64_t v5 = std::__shared_weak_count::lock(v3);
  if (!v5) {
    return 0;
  }
  CFDictionaryRef v6 = v5;
  uint64_t v7 = *(void *)(a1 + 8);
  if (!v7)
  {
    sub_10004D2C8(v6);
    return 0;
  }
  long long v10 = *a2;
  *(void *)a2 = 0;
  *((void *)a2 + 1) = 0;
  uint64_t v8 = (*(uint64_t (**)(uint64_t, long long *))(*(void *)v7 + 72))(v7, &v10);
  if (*((void *)&v10 + 1)) {
    sub_10004D2C8(*((std::__shared_weak_count **)&v10 + 1));
  }
  sub_10004D2C8(v6);
  return v8;
}

void sub_10052919C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  sub_10004D2C8(v10);
  _Unwind_Resume(a1);
}

void sub_1005291BC(capabilities::ct *a1@<X0>, int a2@<W1>, void *a3@<X8>)
{
  int v6 = a2;
  int v5 = capabilities::ct::supportsBasebandVoiceLinkQualityNotification(a1);
  *a3 = 0;
  a3[1] = 0;
  if (v5) {
    sub_1005293A4((Registry **)a1, &v6, a3);
  }
}

uint64_t sub_10052920C(uint64_t a1, int a2)
{
  if (*(_DWORD *)(a1 + 32) == 1) {
    sub_10025852C(a2);
  }
  uint64_t v3 = *(uint64_t (**)(void))(**(void **)(a1 + 40) + 48);

  return v3();
}

void sub_100529280(uint64_t a1)
{
  *(void *)a1 = off_1019F9E38;
  uint64_t v2 = *(void **)(a1 + 136);
  if (v2)
  {
    *(void *)(a1 + 144) = v2;
    operator delete(v2);
  }
  std::mutex::~mutex((std::mutex *)(a1 + 64));
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 48);
  if (v3) {
    sub_10004D2C8(v3);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 24);
  if (v4) {
    std::__shared_weak_count::__release_weak(v4);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 8));

  LinkQualityMetricModelInterface::~LinkQualityMetricModelInterface((LinkQualityMetricModelInterface *)a1);
}

void sub_100529308(uint64_t a1)
{
  *(void *)a1 = off_1019F9E38;
  uint64_t v2 = *(void **)(a1 + 136);
  if (v2)
  {
    *(void *)(a1 + 144) = v2;
    operator delete(v2);
  }
  std::mutex::~mutex((std::mutex *)(a1 + 64));
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 48);
  if (v3) {
    sub_10004D2C8(v3);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 24);
  if (v4) {
    std::__shared_weak_count::__release_weak(v4);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 8));
  LinkQualityMetricModelInterface::~LinkQualityMetricModelInterface((LinkQualityMetricModelInterface *)a1);

  operator delete();
}

void sub_1005293A4(Registry **a1@<X1>, int *a2@<X2>, void *a3@<X8>)
{
  int v6 = operator new(0xC0uLL);
  sub_100529420(v6, a1, a2);
  *a3 = v6 + 3;
  a3[1] = v6;

  sub_1000B3BC8((uint64_t)a3, v6 + 5, (uint64_t)(v6 + 3));
}

void sub_10052940C(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_100529420(void *a1, Registry **a2, int *a3)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = off_1019E0DC0;
  uint64_t v4 = (uint64_t)(a1 + 3);
  int v5 = *a3;
  int v6 = "reg.lqm.voice.?";
  if (v5 == 2) {
    int v6 = "reg.lqm.voice.2";
  }
  if (v5 == 1) {
    uint64_t v7 = "reg.lqm.voice.1";
  }
  else {
    uint64_t v7 = (char *)v6;
  }
  sub_1006C172C(v4, a2, v5, v7, (uint64_t)"VoiceLinkQualityMetricModel");
  a1[3] = off_1019E0D28;
  return a1;
}

void sub_1005294B8(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void sub_1005294CC(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1019E0DC0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1005294EC(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1019E0DC0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100529540(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

uint64_t sub_100529568()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_101B0D140, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_101B0D140))
  {
    byte_101B0D138 = objc_msgSend(+[LockdownModeManager shared](LockdownModeManager, "shared"), "enabled");
    __cxa_guard_release(&qword_101B0D140);
  }
  return byte_101B0D138;
}

void sub_1005295D4(_Unwind_Exception *a1)
{
}

uint64_t sub_1005295EC()
{
  if (qword_101B0D148 != -1) {
    dispatch_once(&qword_101B0D148, &stru_1019E0E00);
  }
  return byte_101B0D139;
}

void sub_100529630(id a1)
{
  uint64_t v9 = 0;
  long long v10 = 0;
  CCPreferences::create(&v9, (CCPreferences *)a1);
  uint64_t v8 = 0;
  uint64_t v1 = kCommCenterPreferencesNoBackupAppID;
  (*(void (**)(const void **__return_ptr))(*(void *)v9 + 40))(&v7);
  sub_1000057AC(&v8, &v7);
  sub_1000577C4(&v7);
  LOBYTE(v7) = 0;
  ctu::cf::assign((ctu::cf *)&v7, v8, v2);
  int v3 = v7;
  int v4 = sub_100529568();
  char v5 = (v3 != 0) ^ v4;
  if (v5)
  {
    if (v4) {
      CFBooleanRef v6 = kCFBooleanTrue;
    }
    else {
      CFBooleanRef v6 = 0;
    }
    (*(void (**)(uint64_t, const __CFString *, CFBooleanRef, uint64_t, const CFStringRef, const CFStringRef))(*(void *)v9 + 16))(v9, @"WasInLockDownKey", v6, v1, kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
  }
  sub_100062778((const void **)&v8);
  if (v10) {
    sub_10004D2C8(v10);
  }
  byte_101B0D139 = v5;
}

void sub_10052977C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, const void *a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    sub_10004D2C8(a12);
  }
  _Unwind_Resume(a1);
}

void sub_1005299B0(_Unwind_Exception *a1)
{
  if ((v3 & 1) == 0) {
    sub_10004D2C8(v2);
  }

  _Unwind_Resume(a1);
}

void sub_10052A498(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, std::__shared_weak_count *a10, int a11, char a12, uint64_t a13, uint64_t a14, void *a15, void *a16, void *a17, void *a18, void *a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,std::__shared_weak_count *a28,uint64_t a29,uint64_t a30,uint64_t a31,void *__p,uint64_t a33,int a34,__int16 a35,char a36,char a37,void *a38,uint64_t a39,uint64_t a40,char a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,void *a58,uint64_t a59,int a60,__int16 a61,char a62,char a63)
{
  if (a37 < 0) {
    operator delete(__p);
  }
  *(void *)(v75 - 240) = v74;
  sub_10030B640((void ***)(v75 - 240));
  if (a28) {
    sub_10004D2C8(a28);
  }
  sub_10010B788((uint64_t)&a41);
  if (a63 < 0) {
    operator delete(a58);
  }
  if (a74 < 0) {
    operator delete(a73);
  }
  a58 = &a72;
  sub_10030B640((void ***)&a58);
  if ((a12 & 1) == 0) {
    sub_10004D2C8(a10);
  }

  _Unwind_Resume(a1);
}

void sub_10052A6CC(uint64_t a1, char a2)
{
  if ((a2 & 2) != 0)
  {
    uint64_t v5 = *(void *)(a1 + 48);
    memset(v22, 0, sizeof(v22));
    sub_10030B4A4(v22, *(void *)(a1 + 64), *(void *)(a1 + 72), (uint64_t)(*(void *)(a1 + 72) - *(void *)(a1 + 64)) >> 7);
    if (*(char *)(a1 + 111) < 0)
    {
      sub_10004FC84(__dst, *(void **)(a1 + 88), *(void *)(a1 + 96));
    }
    else
    {
      *(_OWORD *)std::string __dst = *(_OWORD *)(a1 + 88);
      uint64_t v21 = *(void *)(a1 + 104);
    }
    if (*(char *)(a1 + 135) < 0)
    {
      sub_10004FC84(__p, *(void **)(a1 + 112), *(void *)(a1 + 120));
    }
    else
    {
      *(_OWORD *)std::string __p = *(_OWORD *)(a1 + 112);
      uint64_t v19 = *(void *)(a1 + 128);
    }
    uint64_t v12 = 0;
    uint64_t v13 = 0;
    uint64_t v14 = 0;
    sub_10030B4A4(&v12, *(void *)(a1 + 64), *(void *)(a1 + 72), (uint64_t)(*(void *)(a1 + 72) - *(void *)(a1 + 64)) >> 7);
    CFBooleanRef v6 = *(std::__shared_weak_count **)(a1 + 56);
    uint64_t v15 = *(void *)(a1 + 48);
    long long v16 = v6;
    if (v6) {
      atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    id v17 = objc_retainBlock(*(id *)(a1 + 40));
    std::string v24 = 0;
    uint64_t v7 = operator new(0x38uLL);
    *uint64_t v7 = off_1019E1020;
    v7[2] = 0;
    double v7[3] = 0;
    v7[1] = 0;
    sub_10030B4A4(v7 + 1, v12, v13, (v13 - v12) >> 7);
    uint64_t v8 = v16;
    void v7[4] = v15;
    v7[5] = v8;
    if (v8) {
      atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    id v9 = v17;
    id v17 = 0;
    void v7[6] = v9;
    std::string v24 = v7;
    (*(void (**)(uint64_t, void *, void **, void **, void *))(*(void *)v5 + 64))(v5, v22, __dst, __p, v23);
    sub_100060644(v23);

    if (v16) {
      sub_10004D2C8(v16);
    }
    long long v10 = (void **)&v12;
    sub_10030B640(&v10);
    if (SHIBYTE(v19) < 0) {
      operator delete(__p[0]);
    }
    if (SHIBYTE(v21) < 0) {
      operator delete(__dst[0]);
    }
    long long v10 = (void **)v22;
    sub_10030B640(&v10);
  }
  else
  {
    char v3 = *(void **)(a1 + 32);
    if (v3)
    {
      [v3 getLogContext];
      int v4 = v11;
    }
    else
    {
      int v4 = 0;
      long long v10 = 0;
      uint64_t v11 = 0;
    }
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v10);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v10) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "No support for Cellular Plan Add", (uint8_t *)&v10, 2u);
    }
    (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
  }
}

void sub_10052A95C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,void *__p,uint64_t a25,int a26,__int16 a27,char a28,char a29)
{
  if (a29 < 0) {
    operator delete(__p);
  }
  a9 = v29 - 80;
  sub_10030B640((void ***)&a9);
  _Unwind_Resume(a1);
}

uint64_t sub_10052A9E0(uint64_t a1)
{
  CFBooleanRef v2 = *(std::__shared_weak_count **)(a1 + 32);
  if (v2) {
    sub_10004D2C8(v2);
  }
  int v4 = (void **)a1;
  sub_10030B640(&v4);
  return a1;
}

unsigned char *sub_10052AA2C(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 56);
  *(void *)(a1 + 48) = *(void *)(a2 + 48);
  *(void *)(a1 + 56) = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 72) = 0;
  *(void *)(a1 + 80) = 0;
  sub_10030B4A4((void *)(a1 + 64), *(void *)(a2 + 64), *(void *)(a2 + 72), (uint64_t)(*(void *)(a2 + 72) - *(void *)(a2 + 64)) >> 7);
  if (*(char *)(a2 + 111) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 88), *(void **)(a2 + 88), *(void *)(a2 + 96));
  }
  else
  {
    long long v5 = *(_OWORD *)(a2 + 88);
    *(void *)(a1 + 104) = *(void *)(a2 + 104);
    *(_OWORD *)(a1 + 88) = v5;
  }
  uint64_t result = (unsigned char *)(a1 + 112);
  if (*(char *)(a2 + 135) < 0) {
    return sub_10004FC84(result, *(void **)(a2 + 112), *(void *)(a2 + 120));
  }
  long long v7 = *(_OWORD *)(a2 + 112);
  *(void *)(a1 + 128) = *(void *)(a2 + 128);
  *(_OWORD *)uint64_t result = v7;
  return result;
}

void sub_10052AAF4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  if (*(char *)(v2 + 111) < 0) {
    operator delete(*v3);
  }
  sub_10030B640((void ***)va);
  long long v5 = *(std::__shared_weak_count **)(v2 + 56);
  if (v5) {
    sub_10004D2C8(v5);
  }
  _Unwind_Resume(a1);
}

void sub_10052AB38(uint64_t a1)
{
  uint64_t v2 = (void **)(a1 + 64);
  if (*(char *)(a1 + 135) < 0) {
    operator delete(*(void **)(a1 + 112));
  }
  if (*(char *)(a1 + 111) < 0) {
    operator delete(*(void **)(a1 + 88));
  }
  uint64_t v4 = v2;
  sub_10030B640(&v4);
  char v3 = *(std::__shared_weak_count **)(a1 + 56);
  if (v3) {
    sub_10004D2C8(v3);
  }
}

void sub_10052AD94(_Unwind_Exception *a1)
{
  if ((v3 & 1) == 0) {
    sub_10004D2C8(v2);
  }

  _Unwind_Resume(a1);
}

void sub_10052B13C(_Unwind_Exception *a1)
{
  if ((v6 & 1) == 0) {
    sub_10004D2C8(v4);
  }

  _Unwind_Resume(a1);
}

void sub_10052B1E0(uint64_t a1, char a2)
{
  if ((a2 & 2) != 0)
  {
    long long v5 = *(void **)(a1 + 32);
    if (v5)
    {
      [v5 getLogContext];
      char v6 = v33;
    }
    else
    {
      char v6 = 0;
      *(void *)std::string buf = 0;
      uint64_t v33 = 0;
    }
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_INFO, "Supports Cellular Plan Add", buf, 2u);
    }
    uint64_t v7 = *(void *)(a1 + 64);
    uint64_t v8 = [*(id *)(a1 + 40) address];
    id v9 = v8;
    uint64_t v31 = v8;
    if (v8) {
      CFRetain(v8);
    }
    long long v10 = [*(id *)(a1 + 40) matchingID];
    uint64_t v11 = v10;
    char v30 = v10;
    if (v10) {
      CFRetain(v10);
    }
    uint64_t v12 = [*(id *)(a1 + 40) OID];
    uint64_t v13 = v12;
    uint64_t v29 = v12;
    if (v12) {
      CFRetain(v12);
    }
    uint64_t v14 = [*(id *)(a1 + 40) confirmationCode];
    uint64_t v15 = v14;
    BOOL v28 = v14;
    if (v14) {
      CFRetain(v14);
    }
    long long v16 = [*(id *)(a1 + 40) ICCID];
    id v17 = v16;
    id v27 = v16;
    if (v16) {
      CFRetain(v16);
    }
    long long v18 = [*(id *)(a1 + 40) EID];
    uint64_t v19 = v18;
    uint64_t v26 = v18;
    if (v18) {
      CFRetain(v18);
    }
    char v20 = *(const void **)(a1 + 48);
    char v25 = v20;
    if (v20) {
      CFRetain(v20);
    }
    uint64_t v21 = *(void *)(a1 + 80);
    if (v21 == 2) {
      char v22 = 2;
    }
    else {
      char v22 = v21 == 1;
    }
    v23[0] = _NSConcreteStackBlock;
    v23[1] = 3221225472;
    void v23[2] = sub_10052B59C;
    void v23[3] = &unk_1019E0E60;
    v23[4] = *(void *)(a1 + 32);
    id v24 = *(id *)(a1 + 56);
    (*(void (**)(uint64_t, const void **, const void **, const void **, const void **, const void **, const void **, const void **, char, void *))(*(void *)v7 + 240))(v7, &v31, &v30, &v29, &v28, &v27, &v26, &v25, v22, v23);
    sub_1000558F4(&v25);
    sub_1000558F4(&v26);

    sub_1000558F4(&v27);
    sub_1000558F4(&v28);

    sub_1000558F4(&v29);
    sub_1000558F4(&v30);

    sub_1000558F4(&v31);
  }
  else
  {
    char v3 = *(void **)(a1 + 32);
    if (v3)
    {
      [v3 getLogContext];
      uint64_t v4 = v33;
    }
    else
    {
      uint64_t v4 = 0;
      *(void *)std::string buf = 0;
      uint64_t v33 = 0;
    }
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "No support for Cellular Plan Add", buf, 2u);
    }
    (*(void (**)(void))(*(void *)(a1 + 56) + 16))();
  }
}

void sub_10052B510(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, ...)
{
  va_start(va5, a10);
  va_start(va4, a10);
  va_start(va3, a10);
  va_start(va2, a10);
  va_start(va1, a10);
  va_start(va, a10);
  long long v18 = va_arg(va1, const void *);
  va_copy(va2, va1);
  char v20 = va_arg(va2, const void *);
  va_copy(va3, va2);
  char v22 = va_arg(va3, const void *);
  va_copy(va4, va3);
  id v24 = va_arg(va4, const void *);
  va_copy(va5, va4);
  uint64_t v26 = va_arg(va5, const void *);

  sub_1000558F4((const void **)va);
  sub_1000558F4((const void **)va1);

  sub_1000558F4((const void **)va2);
  sub_1000558F4((const void **)va3);

  sub_1000558F4((const void **)va4);
  sub_1000558F4((const void **)va5);

  sub_1000558F4((const void **)(v16 - 104));
  _Unwind_Resume(a1);
}

void sub_10052B58C()
{
}

void sub_10052B594()
{
}

uint64_t sub_10052B59C(uint64_t a1, int a2)
{
  if (a2 == 45)
  {
    long long v5 = *(void **)(a1 + 32);
    if (v5)
    {
      [v5 getLogContext];
      char v6 = v12;
    }
    else
    {
      char v6 = 0;
      uint64_t v11 = 0;
      uint64_t v12 = 0;
    }
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v11);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v11) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "Invoking callback with Plan Add canceled", (uint8_t *)&v11, 2u);
    }
    id v9 = *(uint64_t (**)(void))(*(void *)(a1 + 40) + 16);
  }
  else if (a2)
  {
    uint64_t v7 = *(void **)(a1 + 32);
    if (v7)
    {
      [v7 getLogContext];
      uint64_t v8 = v12;
    }
    else
    {
      uint64_t v8 = 0;
      uint64_t v11 = 0;
      uint64_t v12 = 0;
    }
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v11);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v11) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "Invoking callback with Plan Add failed", (uint8_t *)&v11, 2u);
    }
    id v9 = *(uint64_t (**)(void))(*(void *)(a1 + 40) + 16);
  }
  else
  {
    char v3 = *(void **)(a1 + 32);
    if (v3)
    {
      [v3 getLogContext];
      uint64_t v4 = v12;
    }
    else
    {
      uint64_t v4 = 0;
      uint64_t v11 = 0;
      uint64_t v12 = 0;
    }
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v11);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
    {
      LOWORD(v11) = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_INFO, "Invoking callback with Plan Add Success", (uint8_t *)&v11, 2u);
    }
    id v9 = *(uint64_t (**)(void))(*(void *)(a1 + 40) + 16);
  }
  return v9();
}

uint64_t sub_10052B738(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 72);
  *(void *)(result + 64) = *(void *)(a2 + 64);
  *(void *)(result + 72) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_10052B754(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 72);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

void sub_10052BE50(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16, uint64_t a17)
{
  if ((v21 & 1) == 0) {
    sub_10004D2C8(v19);
  }

  _Unwind_Resume(a1);
}

void sub_10052C3B0(_Unwind_Exception *a1)
{
  if ((v4 & 1) == 0) {
    sub_10004D2C8(v2);
  }

  _Unwind_Resume(a1);
}

void sub_10052C428(uint64_t a1, int a2)
{
  if (a2)
  {
    char v3 = *(void **)(a1 + 32);
    if (v3)
    {
      [v3 getLogContext];
      char v4 = v30;
    }
    else
    {
      char v4 = 0;
      uint64_t v29 = 0;
      char v30 = 0;
    }
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v29);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v29) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "Device doesnt support eSIM QR code adding", (uint8_t *)&v29, 2u);
    }
    id v6 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:45 userInfo:0];
    (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
    goto LABEL_39;
  }
  long long v5 = *(Registry **)(a1 + 32);
  if (v5)
  {
    [(Registry *)v5 registry];
    long long v5 = v29;
  }
  else
  {
    uint64_t v29 = 0;
    char v30 = 0;
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(v5);
  uint64_t v8 = ServiceMap;
  unint64_t v10 = v9;
  if ((v9 & 0x8000000000000000) != 0)
  {
    uint64_t v11 = (unsigned __int8 *)(v9 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v12 = 5381;
    do
    {
      unint64_t v10 = v12;
      unsigned int v13 = *v11++;
      uint64_t v12 = (33 * v12) ^ v13;
    }
    while (v13);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v32 = v10;
  uint64_t v14 = sub_10004D37C(&v8[1].__m_.__sig, &v32);
  if (v14)
  {
    uint64_t v16 = v14[3];
    uint64_t v15 = (std::__shared_weak_count *)v14[4];
    if (v15)
    {
      atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v8);
      atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v15);
      char v17 = 0;
      goto LABEL_19;
    }
  }
  else
  {
    uint64_t v16 = 0;
  }
  std::mutex::unlock(v8);
  uint64_t v15 = 0;
  char v17 = 1;
LABEL_19:
  (*(void (**)(void **__return_ptr, uint64_t, void, const __CFString *, uint64_t))(*(void *)v16 + 16))(&v31, v16, kAlertDialogLocalizationTable, @"CELLULAR_PLAN_DETECTED_TITLE", 1);
  id v6 = v31;
  sub_1000558F4((const void **)&v31);
  if ((v17 & 1) == 0) {
    sub_10004D2C8(v15);
  }
  if (v30) {
    sub_10004D2C8((std::__shared_weak_count *)v30);
  }
  long long v18 = *(Registry **)(a1 + 32);
  if (v18)
  {
    [(Registry *)v18 registry];
    long long v18 = v29;
  }
  else
  {
    uint64_t v29 = 0;
    char v30 = 0;
  }
  uint64_t v19 = (std::mutex *)Registry::getServiceMap(v18);
  char v20 = v19;
  if ((v9 & 0x8000000000000000) != 0)
  {
    char v21 = (unsigned __int8 *)(v9 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v22 = 5381;
    do
    {
      unint64_t v9 = v22;
      unsigned int v23 = *v21++;
      uint64_t v22 = (33 * v22) ^ v23;
    }
    while (v23);
  }
  std::mutex::lock(v19);
  unint64_t v32 = v9;
  id v24 = sub_10004D37C(&v20[1].__m_.__sig, &v32);
  if (!v24)
  {
    uint64_t v26 = 0;
    goto LABEL_33;
  }
  uint64_t v26 = v24[3];
  char v25 = (std::__shared_weak_count *)v24[4];
  if (!v25)
  {
LABEL_33:
    std::mutex::unlock(v20);
    char v25 = 0;
    char v27 = 1;
    goto LABEL_34;
  }
  atomic_fetch_add_explicit(&v25->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v20);
  atomic_fetch_add_explicit(&v25->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v25);
  char v27 = 0;
LABEL_34:
  (*(void (**)(void **__return_ptr, uint64_t, const __CFString *, void, const __CFString *, uint64_t))(*(void *)v26 + 32))(&v31, v26, @"com.apple.CoreTelephony", kCBMessageLocalizationTable, @"ADD_ESIM", 1);
  BOOL v28 = v31;
  sub_1000558F4((const void **)&v31);
  if ((v27 & 1) == 0) {
    sub_10004D2C8(v25);
  }
  if (v30) {
    sub_10004D2C8((std::__shared_weak_count *)v30);
  }
  (*(void (**)(void))(*(void *)(a1 + 40) + 16))();

LABEL_39:
}

void sub_10052C77C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10052C8D0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10052CE2C(_Unwind_Exception *a1)
{
  sub_1002E26CC((const void **)(v6 - 96));
  if ((v5 & 1) == 0) {
    sub_10004D2C8(v3);
  }

  _Unwind_Resume(a1);
}

void sub_10052CF04(void *a1, int a2)
{
  char v4 = (Registry *)a1[4];
  if (v4)
  {
    [(Registry *)v4 registry];
    char v4 = v49;
  }
  else
  {
    uint64_t v49 = 0;
    uint64_t v50 = 0;
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(v4);
  uint64_t v6 = ServiceMap;
  unint64_t v8 = v7;
  if ((v7 & 0x8000000000000000) != 0)
  {
    unint64_t v9 = (unsigned __int8 *)(v7 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v10 = 5381;
    do
    {
      unint64_t v8 = v10;
      unsigned int v11 = *v9++;
      uint64_t v10 = (33 * v10) ^ v11;
    }
    while (v11);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v52 = v8;
  uint64_t v12 = sub_10004D37C(&v6[1].__m_.__sig, &v52);
  if (v12)
  {
    uint64_t v14 = v12[3];
    unsigned int v13 = (std::__shared_weak_count *)v12[4];
    if (v13)
    {
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v6);
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v13);
      char v15 = 0;
      goto LABEL_12;
    }
  }
  else
  {
    uint64_t v14 = 0;
  }
  std::mutex::unlock(v6);
  unsigned int v13 = 0;
  char v15 = 1;
LABEL_12:
  uint64_t v16 = kAlertDialogLocalizationTable;
  (*(void (**)(void **__return_ptr, uint64_t, void, const __CFString *, uint64_t))(*(void *)v14 + 16))(&v51, v14, kAlertDialogLocalizationTable, @"CELLULAR_PLAN_DETECTED_TITLE", 1);
  char v17 = v51;
  sub_1000558F4((const void **)&v51);
  if ((v15 & 1) == 0) {
    sub_10004D2C8(v13);
  }
  if (v50) {
    sub_10004D2C8(v50);
  }
  id v18 = objc_alloc_init((Class)CTCellularPlanManagerCameraScanAction);
  [v18 setTitle:v17];
  if (a2 == 13)
  {
    char v20 = (void *)a1[4];
    if (v20)
    {
      [v20 getLogContext];
      char v21 = v50;
    }
    else
    {
      char v21 = 0;
      uint64_t v49 = 0;
      uint64_t v50 = 0;
    }
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v49);
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v49) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "Cellular Provisioning cant be done now", (uint8_t *)&v49, 2u);
    }
    id v24 = (Registry *)a1[4];
    if (v24)
    {
      [(Registry *)v24 registry];
      id v24 = v49;
    }
    else
    {
      uint64_t v49 = 0;
      uint64_t v50 = 0;
    }
    uint64_t v26 = (std::mutex *)Registry::getServiceMap(v24);
    char v27 = v26;
    if ((v7 & 0x8000000000000000) != 0)
    {
      BOOL v28 = (unsigned __int8 *)(v7 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v29 = 5381;
      do
      {
        unint64_t v7 = v29;
        unsigned int v30 = *v28++;
        uint64_t v29 = (33 * v29) ^ v30;
      }
      while (v30);
    }
    std::mutex::lock(v26);
    unint64_t v52 = v7;
    uint64_t v31 = sub_10004D37C(&v27[1].__m_.__sig, &v52);
    if (v31)
    {
      uint64_t v33 = v31[3];
      unint64_t v32 = (std::__shared_weak_count *)v31[4];
      if (v32)
      {
        atomic_fetch_add_explicit(&v32->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v27);
        atomic_fetch_add_explicit(&v32->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v32);
        char v34 = 0;
LABEL_57:
        (*(void (**)(void **__return_ptr, uint64_t, uint64_t, const __CFString *, uint64_t))(*(void *)v33 + 16))(&v51, v33, v16, @"CELLULAR_PLAN_DETECTED_BODY_BUSY", 1);
        [v18 setMessage:v51];
        goto LABEL_64;
      }
    }
    else
    {
      uint64_t v33 = 0;
    }
    std::mutex::unlock(v27);
    unint64_t v32 = 0;
    char v34 = 1;
    goto LABEL_57;
  }
  if (a2)
  {
    uint64_t v22 = (void *)a1[4];
    if (v22)
    {
      [v22 getLogContext];
      unsigned int v23 = v50;
    }
    else
    {
      unsigned int v23 = 0;
      uint64_t v49 = 0;
      uint64_t v50 = 0;
    }
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v49);
    if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v49) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_ERROR, "Device doesnt support eSIM QR code adding", (uint8_t *)&v49, 2u);
    }
    char v25 = (Registry *)a1[4];
    if (v25)
    {
      [(Registry *)v25 registry];
      char v25 = v49;
    }
    else
    {
      uint64_t v49 = 0;
      uint64_t v50 = 0;
    }
    BOOL v35 = (std::mutex *)Registry::getServiceMap(v25);
    __int16 v36 = v35;
    if ((v7 & 0x8000000000000000) != 0)
    {
      uint64_t v37 = (unsigned __int8 *)(v7 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v38 = 5381;
      do
      {
        unint64_t v7 = v38;
        unsigned int v39 = *v37++;
        uint64_t v38 = (33 * v38) ^ v39;
      }
      while (v39);
    }
    std::mutex::lock(v35);
    unint64_t v52 = v7;
    int v40 = sub_10004D37C(&v36[1].__m_.__sig, &v52);
    if (v40)
    {
      uint64_t v41 = v40[3];
      unint64_t v32 = (std::__shared_weak_count *)v40[4];
      if (v32)
      {
        atomic_fetch_add_explicit(&v32->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v36);
        atomic_fetch_add_explicit(&v32->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v32);
        char v34 = 0;
LABEL_60:
        (*(void (**)(void **__return_ptr, uint64_t, uint64_t, const __CFString *, uint64_t))(*(void *)v41 + 16))(&v51, v41, v16, @"CELLULAR_PLAN_DETECTED_BODY_UNSUPPORTED", 1);
        [v18 setMessage:v51];
        goto LABEL_64;
      }
    }
    else
    {
      uint64_t v41 = 0;
    }
    std::mutex::unlock(v36);
    unint64_t v32 = 0;
    char v34 = 1;
    goto LABEL_60;
  }
  [v18 setSmdpAddress:a1[6]];
  [v18 setMatchingId:a1[7]];
  [v18 setOID:a1[8]];
  uint64_t v19 = (Registry *)a1[4];
  if (v19)
  {
    [(Registry *)v19 registry];
    uint64_t v19 = v49;
  }
  else
  {
    uint64_t v49 = 0;
    uint64_t v50 = 0;
  }
  __int16 v42 = (std::mutex *)Registry::getServiceMap(v19);
  int v43 = v42;
  if ((v7 & 0x8000000000000000) != 0)
  {
    int v44 = (unsigned __int8 *)(v7 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v45 = 5381;
    do
    {
      unint64_t v7 = v45;
      unsigned int v46 = *v44++;
      uint64_t v45 = (33 * v45) ^ v46;
    }
    while (v46);
  }
  std::mutex::lock(v42);
  unint64_t v52 = v7;
  __int16 v47 = sub_10004D37C(&v43[1].__m_.__sig, &v52);
  if (!v47)
  {
    uint64_t v48 = 0;
    goto LABEL_62;
  }
  uint64_t v48 = v47[3];
  unint64_t v32 = (std::__shared_weak_count *)v47[4];
  if (!v32)
  {
LABEL_62:
    std::mutex::unlock(v43);
    unint64_t v32 = 0;
    char v34 = 1;
    goto LABEL_63;
  }
  atomic_fetch_add_explicit(&v32->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v43);
  atomic_fetch_add_explicit(&v32->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v32);
  char v34 = 0;
LABEL_63:
  (*(void (**)(void **__return_ptr, uint64_t, uint64_t, const __CFString *, uint64_t))(*(void *)v48 + 16))(&v51, v48, v16, @"CELLULAR_PLAN_DETECTED_BODY_SUCCESS", 1);
  [v18 setMessage:v51];
LABEL_64:
  sub_1000558F4((const void **)&v51);
  if ((v34 & 1) == 0) {
    sub_10004D2C8(v32);
  }
  if (v50) {
    sub_10004D2C8(v50);
  }
  (*(void (**)(void))(a1[5] + 16))();
}

void sub_10052D494(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

const void **sub_10052D54C(const void **a1, const void **a2)
{
  sub_100083DA4(a1 + 6, a2 + 6);
  sub_100083DA4(a1 + 7, a2 + 7);

  return sub_100083DA4(a1 + 8, a2 + 8);
}

const void **sub_10052D5A0(const void **a1)
{
  uint64_t v2 = a1 + 6;
  sub_1000558F4(a1 + 8);
  sub_1000558F4(a1 + 7);

  return sub_1000558F4(v2);
}

void sub_10052D8C0(_Unwind_Exception *a1)
{
  if ((v4 & 1) == 0) {
    sub_10004D2C8(v2);
  }

  _Unwind_Resume(a1);
}

void sub_10052D930(uint64_t a1, void *a2, int a3)
{
  char v25 = objc_opt_new();
  [v25 setDevices:*a2];
  char v5 = [v25 devices];

  if (v5)
  {
    long long v36 = 0u;
    long long v37 = 0u;
    long long v34 = 0u;
    long long v35 = 0u;
    id obj = [v25 devices];
    id v6 = [obj countByEnumeratingWithState:&v34 objects:v39 count:16];
    if (v6)
    {
      uint64_t v27 = *(void *)v35;
      do
      {
        uint64_t v7 = 0;
        id v28 = v6;
        do
        {
          if (*(void *)v35 != v27) {
            objc_enumerationMutation(obj);
          }
          unint64_t v8 = *(void **)(*((void *)&v34 + 1) + 8 * v7);
          unint64_t v9 = *(void **)(a1 + 32);
          if (v9)
          {
            [v9 getLogContext];
            uint64_t v10 = *(NSObject **)&buf[8];
          }
          else
          {
            uint64_t v10 = 0;
            *(_OWORD *)std::string buf = 0uLL;
          }
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
          if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
          {
            unsigned int v11 = [v8 deviceID];
            *(_DWORD *)std::string buf = 138412290;
            *(void *)&uint8_t buf[4] = v11;
            _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "Transfer Device => %@", buf, 0xCu);
          }
          long long v32 = 0u;
          long long v33 = 0u;
          long long v30 = 0u;
          long long v31 = 0u;
          uint64_t v12 = [v8 remoteDisplayPlans];
          id v13 = [v12 countByEnumeratingWithState:&v30 objects:v38 count:16];
          uint64_t v29 = v7;
          if (v13)
          {
            uint64_t v14 = *(void *)v31;
            do
            {
              for (uint64_t i = 0; i != v13; uint64_t i = (char *)i + 1)
              {
                if (*(void *)v31 != v14) {
                  objc_enumerationMutation(v12);
                }
                uint64_t v16 = *(void *)(*((void *)&v30 + 1) + 8 * i);
                char v17 = *(void **)(a1 + 32);
                if (v17)
                {
                  [v17 getLogContext];
                  id v18 = *(NSObject **)&buf[8];
                }
                else
                {
                  id v18 = 0;
                  *(_OWORD *)std::string buf = 0uLL;
                }
                ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
                if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
                {
                  *(_DWORD *)std::string buf = 138412290;
                  *(void *)&uint8_t buf[4] = v16;
                  _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "  Transfer Plan => %@", buf, 0xCu);
                }
              }
              id v13 = [v12 countByEnumeratingWithState:&v30 objects:v38 count:16];
            }
            while (v13);
          }

          uint64_t v7 = v29 + 1;
        }
        while ((id)(v29 + 1) != v28);
        id v6 = [obj countByEnumeratingWithState:&v34 objects:v39 count:16];
      }
      while (v6);
    }

    uint64_t v19 = *(void *)(a1 + 40);
    char v20 = sub_1003DF5C4(a3);
    (*(void (**)(uint64_t, void *, void *))(v19 + 16))(v19, v25, v20);
  }
  else
  {
    char v21 = *(void **)(a1 + 32);
    if (v21)
    {
      [v21 getLogContext];
      uint64_t v22 = *(NSObject **)&buf[8];
    }
    else
    {
      uint64_t v22 = 0;
      *(_OWORD *)std::string buf = 0uLL;
    }
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "No transfer plans available", buf, 2u);
    }
    uint64_t v23 = *(void *)(a1 + 40);
    char v20 = sub_1003DF5C4(a3);
    (*(void (**)(uint64_t, void *, void *))(v23 + 16))(v23, v25, v20);
  }
}

void sub_10052DCD8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

void sub_10052E008(_Unwind_Exception *a1)
{
  if ((v4 & 1) == 0) {
    sub_10004D2C8(v2);
  }

  _Unwind_Resume(a1);
}

void sub_10052E448(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, char a16, int a17, __int16 a18, char a19, char a20,int a21,__int16 a22,char a23,char a24,uint64_t a25,uint64_t a26,uint64_t a27,char a28,uint64_t a29)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_10052E7D4(_Unwind_Exception *a1)
{
  id v6 = v5;

  _Unwind_Resume(a1);
}

void sub_10052EC54(_Unwind_Exception *a1)
{
  if ((v5 & 1) == 0) {
    sub_10004D2C8(v3);
  }

  _Unwind_Resume(a1);
}

void sub_10052EFF4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21)
{
  sub_1000605C0(&a16);
  if (a14 < 0) {
    operator delete(__p);
  }
  if ((v24 & 1) == 0) {
    sub_10004D2C8(v23);
  }

  _Unwind_Resume(a1);
}

void sub_10052F2D4(_Unwind_Exception *a1)
{
  if ((v4 & 1) == 0) {
    sub_10004D2C8(v3);
  }

  _Unwind_Resume(a1);
}

uint64_t sub_10052F348(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_10052F8E8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,void *a24,uint64_t a25,int a26,__int16 a27,char a28,char a29,char a30,uint64_t a31,char a32,uint64_t a33,uint64_t a34,uint64_t a35,void *__p,uint64_t a37,int a38,__int16 a39,char a40,char a41)
{
  if (a41 < 0) {
    operator delete(__p);
  }
  if (a17 < 0) {
    operator delete(a12);
  }
  if (a23 < 0) {
    operator delete(a18);
  }
  if (a29 < 0) {
    operator delete(a24);
  }
  if ((v45 & 1) == 0) {
    sub_10004D2C8(v44);
  }

  _Unwind_Resume(a1);
}

void sub_10052FD10(_Unwind_Exception *a1)
{
  id v6 = v5;

  _Unwind_Resume(a1);
}

void sub_1005304CC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, int a11, char a12, uint64_t a13, void *a14, void *a15, void *a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31,uint64_t a32,uint64_t a33,void *__p,uint64_t a35,int a36,__int16 a37,char a38,char a39,void *a40,uint64_t a41,int a42,__int16 a43,char a44,char a45,char a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,char *a55,uint64_t a56,int a57,__int16 a58,char a59,char a60)
{
  a55 = &a31;
  sub_10030A698((void ***)&a55);
  if (a39 < 0) {
    operator delete(__p);
  }
  if (a45 < 0) {
    operator delete(a40);
  }
  if ((a12 & 1) == 0) {
    sub_10004D2C8(a10);
  }

  _Unwind_Resume(a1);
}

void sub_100530918(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, void *a11, void *a12)
{
  _Unwind_Resume(a1);
}

void sub_100530EE0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, void *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if ((v31 & 1) == 0) {
    sub_10004D2C8(v28);
  }

  _Unwind_Resume(a1);
}

void sub_1005312C8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  if ((v20 & 1) == 0) {
    sub_10004D2C8(v19);
  }

  _Unwind_Resume(a1);
}

void sub_10053160C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  if ((v20 & 1) == 0) {
    sub_10004D2C8(v19);
  }

  _Unwind_Resume(a1);
}

void sub_100531984(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,uint64_t a22)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  if ((v26 & 1) == 0) {
    sub_10004D2C8(v25);
  }

  _Unwind_Resume(a1);
}

void sub_100531C40(_Unwind_Exception *a1)
{
  if ((v4 & 1) == 0) {
    sub_10004D2C8(v2);
  }

  _Unwind_Resume(a1);
}

void sub_100531F20(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, char a17)
{
  if ((v21 & 1) == 0) {
    sub_10004D2C8(v19);
  }

  _Unwind_Resume(a1);
}

void sub_100532440(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, int a10, char a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, uint64_t a18, void *a19, uint64_t a20,int a21,__int16 a22,char a23,char a24,uint64_t a25)
{
  sub_10030CF3C(&a25);
  if (a17 < 0) {
    operator delete(__p);
  }
  if (a24 < 0) {
    operator delete(a19);
  }
  if ((a11 & 1) == 0) {
    sub_10004D2C8(v28);
  }

  _Unwind_Resume(a1);
}

void sub_1005327D4(_Unwind_Exception *a1)
{
  if ((v4 & 1) == 0) {
    sub_10004D2C8(v2);
  }

  _Unwind_Resume(a1);
}

void sub_100532D10(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, void *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25)
{
  if ((v30 & 1) == 0) {
    sub_10004D2C8(v27);
  }

  _Unwind_Resume(a1);
}

void sub_10053358C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, int a11, char a12, uint64_t a13, uint64_t a14, void *a15, void *a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,char a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,char a43,uint64_t a44,uint64_t a45,uint64_t a46,char *a47,uint64_t a48)
{
  a47 = &a32;
  sub_1000C63B8((void ***)&a47);
  if ((a12 & 1) == 0) {
    sub_10004D2C8(a10);
  }

  _Unwind_Resume(a1);
}

uint64_t sub_1005336DC(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 304)) {
    sub_1000C64D4(a1 + 128);
  }
  if (*(char *)(a1 + 119) < 0) {
    operator delete(*(void **)(a1 + 96));
  }
  if (*(char *)(a1 + 95) < 0) {
    operator delete(*(void **)(a1 + 72));
  }
  if (*(char *)(a1 + 71) < 0) {
    operator delete(*(void **)(a1 + 48));
  }
  if (*(char *)(a1 + 47) < 0) {
    operator delete(*(void **)(a1 + 24));
  }
  if (*(char *)(a1 + 23) < 0) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void sub_100533960(_Unwind_Exception *a1)
{
  if ((v3 & 1) == 0) {
    sub_10004D2C8(v2);
  }

  _Unwind_Resume(a1);
}

void sub_100533BBC(_Unwind_Exception *a1)
{
  if ((v4 & 1) == 0) {
    sub_10004D2C8(v2);
  }

  _Unwind_Resume(a1);
}

void sub_100533DF8(_Unwind_Exception *a1)
{
  if ((v4 & 1) == 0) {
    sub_10004D2C8(v2);
  }

  _Unwind_Resume(a1);
}

void sub_100534214(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  sub_100313668(va);
  if ((v12 & 1) == 0) {
    sub_10004D2C8(v11);
  }

  _Unwind_Resume(a1);
}

void sub_100534568(_Unwind_Exception *a1)
{
  if ((v4 & 1) == 0) {
    sub_10004D2C8(v2);
  }

  _Unwind_Resume(a1);
}

void sub_10053485C(_Unwind_Exception *a1)
{
  if ((v4 & 1) == 0) {
    sub_10004D2C8(v2);
  }

  _Unwind_Resume(a1);
}

void sub_100534B54(_Unwind_Exception *a1)
{
  if ((v4 & 1) == 0) {
    sub_10004D2C8(v2);
  }

  _Unwind_Resume(a1);
}

void sub_100534DC8(_Unwind_Exception *a1)
{
  if ((v4 & 1) == 0) {
    sub_10004D2C8(v3);
  }

  _Unwind_Resume(a1);
}

void sub_1005351B4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, dispatch_object_t object, char a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21)
{
  if ((v24 & 1) == 0) {
    sub_10004D2C8(v22);
  }

  _Unwind_Resume(a1);
}

void sub_100535624(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, dispatch_object_t object, char a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20)
{
  if ((v24 & 1) == 0) {
    sub_10004D2C8(v22);
  }

  _Unwind_Resume(a1);
}

void sub_100535A70(_Unwind_Exception *a1)
{
  if ((v6 & 1) == 0) {
    sub_10004D2C8(v4);
  }

  _Unwind_Resume(a1);
}

void sub_100535B38(uint64_t a1, uint64_t a2, int a3)
{
  if (a3)
  {
    uint64_t v4 = sub_1003DF5C4(a3);
  }
  else
  {
    uint64_t v4 = 0;
  }
  id v5 = (id)v4;
  (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_100535BB0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_100536048(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21)
{
  if ((v26 & 1) == 0) {
    sub_10004D2C8(v24);
  }

  _Unwind_Resume(a1);
}

void sub_100536498(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, char a17)
{
  if ((v21 & 1) == 0) {
    sub_10004D2C8(v19);
  }

  _Unwind_Resume(a1);
}

void sub_10053686C(_Unwind_Exception *a1)
{
  if ((v5 & 1) == 0) {
    sub_10004D2C8(v3);
  }

  _Unwind_Resume(a1);
}

void sub_100536B18(_Unwind_Exception *a1)
{
  if ((v4 & 1) == 0) {
    sub_10004D2C8(v2);
  }

  _Unwind_Resume(a1);
}

void sub_100536DB0(_Unwind_Exception *a1)
{
  if ((v4 & 1) == 0) {
    sub_10004D2C8(v2);
  }

  _Unwind_Resume(a1);
}

void sub_100537058(_Unwind_Exception *a1)
{
  if ((v5 & 1) == 0) {
    sub_10004D2C8(v3);
  }

  _Unwind_Resume(a1);
}

void sub_100537358(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if ((v19 & 1) == 0) {
    sub_10004D2C8(v17);
  }

  _Unwind_Resume(a1);
}

void sub_1005373F0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  if (!a10) {
    JUMPOUT(0x1005373E0);
  }
  JUMPOUT(0x1005373DCLL);
}

void sub_100537690(_Unwind_Exception *a1)
{
  if ((v4 & 1) == 0) {
    sub_10004D2C8(v2);
  }

  _Unwind_Resume(a1);
}

void sub_100538E00(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, std::__shared_weak_count *a13, int a14, char a15, uint64_t a16, void *a17, void *a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,void *a24,uint64_t a25,std::__shared_weak_count *a26)
{
  sub_10030CBA4(v26);
  if (a26) {
    sub_10004D2C8(a26);
  }

  if (a13) {
    sub_10004D2C8(a13);
  }
  sub_10030CBA4((uint64_t)&STACK[0x380]);
  if (SLOBYTE(STACK[0x2F7]) < 0) {
    operator delete((void *)STACK[0x2E0]);
  }

  if ((a15 & 1) == 0) {
    sub_10004D2C8(a13);
  }

  _Unwind_Resume(a1);
}

uint64_t sub_100539590(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2) {
    sub_10004D2C8(v2);
  }

  return a1;
}

uint64_t sub_1005395D0(uint64_t *a1, uint64_t a2)
{
  unint64_t v6 = a1[2];
  uint64_t v4 = (uint64_t)(a1 + 2);
  unint64_t v5 = v6;
  unint64_t v7 = *(void *)(v4 - 8);
  if (v7 >= v6)
  {
    uint64_t v9 = (uint64_t)(v7 - *a1) >> 7;
    if ((unint64_t)(v9 + 1) >> 57) {
      sub_10006A748();
    }
    uint64_t v10 = v5 - *a1;
    uint64_t v11 = v10 >> 6;
    if (v10 >> 6 <= (unint64_t)(v9 + 1)) {
      uint64_t v11 = v9 + 1;
    }
    if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFF80) {
      unint64_t v12 = 0x1FFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v12 = v11;
    }
    uint64_t v19 = v4;
    if (v12) {
      id v13 = (char *)sub_100043864(v4, v12);
    }
    else {
      id v13 = 0;
    }
    char v15 = v13;
    uint64_t v16 = &v13[128 * v9];
    id v18 = &v13[128 * v12];
    sub_10030B264((uint64_t)v16, a2);
    char v17 = v16 + 128;
    sub_100313094(a1, &v15);
    uint64_t v8 = a1[1];
    sub_1003131D8((uint64_t)&v15);
  }
  else
  {
    sub_10030B264(*(void *)(v4 - 8), a2);
    uint64_t v8 = v7 + 128;
    a1[1] = v7 + 128;
  }
  a1[1] = v8;
  return v8 - 128;
}

void sub_1005396C8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  *(void *)(v10 + 8) = v11;
  _Unwind_Resume(exception_object);
}

uint64_t sub_1005396E8(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 8);
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

uint64_t sub_100539728(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 24) = 0;
  uint64_t v4 = (char *)operator new(0x160uLL);
  *(void *)uint64_t v4 = off_1019E20C0;
  *((void *)v4 + 1) = *(id *)a2;
  long long v5 = *(_OWORD *)(a2 + 8);
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  long long v6 = *(_OWORD *)(a2 + 24);
  *((_OWORD *)v4 + 1) = v5;
  *((_OWORD *)v4 + 2) = v6;
  *((void *)v4 + 6) = *(void *)(a2 + 40);
  *(void *)(a2 + 24) = 0;
  *(void *)(a2 + 32) = 0;
  *(_OWORD *)(v4 + 56) = *(_OWORD *)(a2 + 48);
  *((void *)v4 + 9) = *(void *)(a2 + 64);
  *(void *)(a2 + 40) = 0;
  *(void *)(a2 + 48) = 0;
  *(void *)(a2 + 56) = 0;
  *(void *)(a2 + 64) = 0;
  long long v7 = *(_OWORD *)(a2 + 72);
  *((void *)v4 + 12) = *(void *)(a2 + 88);
  *((_OWORD *)v4 + 5) = v7;
  *(void *)(a2 + 72) = 0;
  *(void *)(a2 + 80) = 0;
  long long v8 = *(_OWORD *)(a2 + 96);
  *((void *)v4 + 15) = *(void *)(a2 + 112);
  *(_OWORD *)(v4 + 104) = v8;
  *(void *)(a2 + 88) = 0;
  *(void *)(a2 + 96) = 0;
  *(void *)(a2 + 104) = 0;
  *(void *)(a2 + 112) = 0;
  long long v9 = *(_OWORD *)(a2 + 120);
  *((void *)v4 + 18) = *(void *)(a2 + 136);
  *((_OWORD *)v4 + 8) = v9;
  *(void *)(a2 + 120) = 0;
  *(void *)(a2 + 128) = 0;
  long long v10 = *(_OWORD *)(a2 + 144);
  *((void *)v4 + 21) = *(void *)(a2 + 160);
  *(_OWORD *)(v4 + 152) = v10;
  *(void *)(a2 + 136) = 0;
  *(void *)(a2 + 144) = 0;
  *(void *)(a2 + 152) = 0;
  *(void *)(a2 + 160) = 0;
  long long v11 = *(_OWORD *)(a2 + 168);
  *((void *)v4 + 24) = *(void *)(a2 + 184);
  *((_OWORD *)v4 + 11) = v11;
  *(void *)(a2 + 168) = 0;
  *(void *)(a2 + 176) = 0;
  long long v12 = *(_OWORD *)(a2 + 192);
  *((void *)v4 + 27) = *(void *)(a2 + 208);
  *(_OWORD *)(v4 + 200) = v12;
  *(void *)(a2 + 184) = 0;
  *(void *)(a2 + 192) = 0;
  *(void *)(a2 + 200) = 0;
  *(void *)(a2 + 208) = 0;
  long long v13 = *(_OWORD *)(a2 + 216);
  *((void *)v4 + 30) = *(void *)(a2 + 232);
  *((_OWORD *)v4 + 14) = v13;
  *(void *)(a2 + 216) = 0;
  *(void *)(a2 + 224) = 0;
  *(void *)(a2 + 232) = 0;
  v4[248] = *(unsigned char *)(a2 + 240);
  v4[256] = 0;
  v4[280] = 0;
  if (*(unsigned char *)(a2 + 272))
  {
    *((_OWORD *)v4 + 16) = *(_OWORD *)(a2 + 248);
    *((void *)v4 + 34) = *(void *)(a2 + 264);
    *(void *)(a2 + 256) = 0;
    *(void *)(a2 + 264) = 0;
    *(void *)(a2 + 248) = 0;
    v4[280] = 1;
  }
  v4[288] = 0;
  v4[312] = 0;
  if (*(unsigned char *)(a2 + 304))
  {
    *((void *)v4 + 38) = *(void *)(a2 + 296);
    *((_OWORD *)v4 + 18) = *(_OWORD *)(a2 + 280);
    *(void *)(a2 + 288) = 0;
    *(void *)(a2 + 296) = 0;
    *(void *)(a2 + 280) = 0;
    v4[312] = 1;
  }
  *((_OWORD *)v4 + 20) = *(_OWORD *)(a2 + 312);
  uint64_t v14 = *(void *)(a2 + 328);
  uint64_t v15 = *(void *)(a2 + 336);
  *(void *)(a2 + 328) = 0;
  *(void *)(a2 + 336) = 0;
  *(void *)(a2 + 312) = 0;
  *(void *)(a2 + 320) = 0;
  *((void *)v4 + 42) = v14;
  *((void *)v4 + 43) = v15;
  *(void *)(a1 + 24) = v4;
  return a1;
}

uint64_t sub_1005398F4(uint64_t a1)
{
  if (*(char *)(a1 + 335) < 0) {
    operator delete(*(void **)(a1 + 312));
  }
  sub_10030CBA4(a1 + 24);
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2) {
    sub_10004D2C8(v2);
  }

  return a1;
}

void *sub_10053994C(void *a1, void *a2, uint64_t a3)
{
  a1[3] = 0;
  *a1 = off_1019E21D0;
  id v5 = a2;
  a1[1] = v5;
  a1[2] = a3;
  a1[3] = a1;

  return a1;
}

void sub_100539D84(_Unwind_Exception *a1)
{
  if ((v5 & 1) == 0) {
    sub_10004D2C8(v3);
  }

  _Unwind_Resume(a1);
}

void sub_100539F70(_Unwind_Exception *a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  sub_10030D088((uint64_t *)va);
  sub_100545F18(v6);

  _Unwind_Resume(a1);
}

void sub_10053A58C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,void *a25,uint64_t a26,int a27,__int16 a28,char a29,char a30,uint64_t a31,void *a32,uint64_t a33,int a34,__int16 a35,char a36,char a37,void *a38,uint64_t a39,int a40,__int16 a41,char a42,char a43,uint64_t a44,uint64_t a45,uint64_t a46,void *a47,uint64_t a48,int a49,__int16 a50,char a51,char a52,void *a53,uint64_t a54,int a55,__int16 a56,char a57,char a58)
{
  if (a23 < 0) {
    operator delete(__p);
  }
  if (a30 < 0) {
    operator delete(a25);
  }
  if (a37 < 0) {
    operator delete(a32);
  }
  if (a43 < 0) {
    operator delete(a38);
  }
  if ((v64 & 1) == 0) {
    sub_10004D2C8(a10);
  }
  if (a52 < 0) {
    operator delete(a47);
  }
  if (a58 < 0) {
    operator delete(a53);
  }
  if (*(char *)(v65 - 177) < 0) {
    operator delete(*(void **)(v65 - 200));
  }
  if (*(char *)(v65 - 153) < 0) {
    operator delete(*(void **)(v65 - 176));
  }

  _Unwind_Resume(a1);
}

void sub_10053AA34(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, char a17)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_10053AD6C(_Unwind_Exception *a1)
{
  if ((v4 & 1) == 0) {
    sub_10004D2C8(v2);
  }

  _Unwind_Resume(a1);
}

void sub_10053B094(_Unwind_Exception *a1)
{
  if ((v4 & 1) == 0) {
    sub_10004D2C8(v2);
  }

  _Unwind_Resume(a1);
}

void sub_10053B428(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19)
{
  if ((v23 & 1) == 0) {
    sub_10004D2C8(v21);
  }

  _Unwind_Resume(a1);
}

void sub_10053B6B8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10053BC28(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  sub_10053BD9C((uint64_t)&a9);
  if ((v14 & 1) == 0) {
    sub_10004D2C8(v11);
  }

  _Unwind_Resume(a1);
}

uint64_t sub_10053BD9C(uint64_t a1)
{
  if (*(char *)(a1 + 143) < 0) {
    operator delete(*(void **)(a1 + 120));
  }
  if (*(char *)(a1 + 119) < 0) {
    operator delete(*(void **)(a1 + 96));
  }
  if (*(char *)(a1 + 95) < 0) {
    operator delete(*(void **)(a1 + 72));
  }
  if (*(char *)(a1 + 71) < 0) {
    operator delete(*(void **)(a1 + 48));
  }
  if (*(char *)(a1 + 47) < 0) {
    operator delete(*(void **)(a1 + 24));
  }
  if (*(char *)(a1 + 23) < 0) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void sub_10053C12C(_Unwind_Exception *a1)
{
  if ((v4 & 1) == 0) {
    sub_10004D2C8(v2);
  }

  _Unwind_Resume(a1);
}

void sub_10053C420(_Unwind_Exception *a1)
{
  if ((v4 & 1) == 0) {
    sub_10004D2C8(v2);
  }

  _Unwind_Resume(a1);
}

void sub_10053C484(uint64_t a1, void *a2)
{
  if (*a2) {
    char v3 = sub_100083F10;
  }
  else {
    char v3 = 0;
  }
  if (v3)
  {
    id v4 = [objc_alloc((Class)CTDisplayPlanList) initWithDisplayPlans:*a2];
    char v5 = *(void **)(a1 + 32);
    if (v5)
    {
      [v5 getLogContext];
      long long v6 = *((void *)&v8 + 1);
    }
    else
    {
      long long v6 = 0;
      long long v8 = 0uLL;
    }
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v8);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(v8) = 138412290;
      *(void *)((char *)&v8 + 4) = v4;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Crossplatform transferrable plans are: %@", (uint8_t *)&v8, 0xCu);
    }
    (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
  }
  else
  {
    long long v7 = *(void (**)(void))(*(void *)(a1 + 40) + 16);
    v7();
  }
}

void sub_10053C5F4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10053C800(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_10053C858(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_10053CC14(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19, void *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25,char a26)
{
  if ((v31 & 1) == 0) {
    sub_10004D2C8(v29);
  }

  _Unwind_Resume(a1);
}

void sub_10053CCC0(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v4 = *(void *)(a1 + 32);
  sub_1003DF5C4(a3);
  id v5 = (id)objc_claimAutoreleasedReturnValue();
  (*(void (**)(uint64_t, uint64_t))(v4 + 16))(v4, a2);
}

void sub_10053CD28(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_10053D4F8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, std::__shared_weak_count *a10, int a11, char a12, uint64_t a13, void *a14, void *a15, void *a16, void *a17, void *a18, void *a19, void *a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,void *a26,uint64_t a27,uint64_t a28,uint64_t a29,void *__p,uint64_t a31,int a32,__int16 a33,char a34,char a35,char a36,uint64_t a37,uint64_t a38,void *a39,uint64_t a40,int a41,__int16 a42,char a43,char a44)
{
  if (a35 < 0) {
    operator delete(__p);
  }
  *(void *)(v45 - 208) = &a36;
  sub_10030B640((void ***)(v45 - 208));
  if (*(char *)(v45 - 161) < 0) {
    operator delete(*(void **)(v45 - 184));
  }
  if (a44 < 0) {
    operator delete(a39);
  }
  a39 = (void *)(v45 - 160);
  sub_10030B640((void ***)&a39);
  if ((a12 & 1) == 0) {
    sub_10004D2C8(a10);
  }

  _Unwind_Resume(a1);
}

uint64_t sub_10053D73C(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_10053DCA4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, xpc_object_t a17, char a18)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_10053EE90(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, uint64_t a12, uint64_t a13, int a14, char a15, void *a16, void *a17)
{
  if ((a15 & 1) == 0) {
    sub_10004D2C8(a10);
  }

  _Unwind_Resume(a1);
}

void sub_10053F400(_Unwind_Exception *a1)
{
  if ((v3 & 1) == 0) {
    sub_10004D2C8(v2);
  }

  _Unwind_Resume(a1);
}

void sub_10053F45C(uint64_t a1, int a2)
{
  if (a2)
  {
    char v3 = *(Registry **)(a1 + 32);
    if (v3)
    {
      [(Registry *)v3 registry];
      char v3 = v20;
    }
    else
    {
      char v20 = 0;
      char v21 = 0;
    }
    ServiceMap = (std::mutex *)Registry::getServiceMap(v3);
    long long v7 = ServiceMap;
    long long v8 = "22TravelHandlerInterface";
    if (((unint64_t)"22TravelHandlerInterface" & 0x8000000000000000) != 0)
    {
      long long v9 = (unsigned __int8 *)((unint64_t)"22TravelHandlerInterface" & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v10 = 5381;
      do
      {
        long long v8 = (const char *)v10;
        unsigned int v11 = *v9++;
        uint64_t v10 = (33 * v10) ^ v11;
      }
      while (v11);
    }
    std::mutex::lock(ServiceMap);
    uint64_t v22 = v8;
    long long v12 = sub_10004D37C(&v7[1].__m_.__sig, (unint64_t *)&v22);
    if (v12)
    {
      char v14 = (uint64_t (***)(void))v12[3];
      long long v13 = (std::__shared_weak_count *)v12[4];
      if (v13)
      {
        atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v7);
        atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v13);
        char v15 = 0;
LABEL_15:
        if (v21) {
          sub_10004D2C8(v21);
        }
        if (v14)
        {
          uint64_t v16 = *(void *)(a1 + 40);
          uint64_t v17 = (**v14)(v14);
        }
        else
        {
          id v18 = *(void **)(a1 + 32);
          if (v18)
          {
            [v18 getLogContext];
            uint64_t v19 = v21;
          }
          else
          {
            uint64_t v19 = 0;
            char v20 = 0;
            char v21 = 0;
          }
          ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v20);
          if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
          {
            LOWORD(v20) = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Unable to get TravelHandler", (uint8_t *)&v20, 2u);
          }
          uint64_t v17 = 0;
          uint64_t v16 = *(void *)(a1 + 40);
        }
        (*(void (**)(uint64_t, uint64_t))(v16 + 16))(v16, v17);
        if ((v15 & 1) == 0) {
          sub_10004D2C8(v13);
        }
        return;
      }
    }
    else
    {
      char v14 = 0;
    }
    std::mutex::unlock(v7);
    long long v13 = 0;
    char v15 = 1;
    goto LABEL_15;
  }
  uint64_t v4 = *(void **)(a1 + 32);
  if (v4)
  {
    [v4 getLogContext];
    id v5 = v21;
  }
  else
  {
    id v5 = 0;
    char v20 = 0;
    char v21 = 0;
  }
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v20);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v20) = 0;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Device isn't eSIM capable", (uint8_t *)&v20, 2u);
  }
  (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
}

void sub_10053F68C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if ((v11 & 1) == 0) {
    sub_10004D2C8(v10);
  }
  _Unwind_Resume(exception_object);
}

void sub_10053F978(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if ((v26 & 1) == 0) {
    sub_10004D2C8(v24);
  }

  _Unwind_Resume(a1);
}

void sub_10053FBFC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10053FF08(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100540538(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, void *a15, void *a16, void *a17, void *a18)
{
  _Unwind_Resume(a1);
}

void sub_100540680(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10054093C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, char a17)
{
  if ((v20 & 1) == 0) {
    sub_10004D2C8(v19);
  }

  _Unwind_Resume(a1);
}

uint64_t sub_1005409BC(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 64;
    sub_10030A71C(i - 64);
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t sub_100540A0C(uint64_t *a1, uint64_t a2)
{
  uint64_t result = *a1;
  *a1 = a2;
  if (result)
  {
    sub_100540A5C(result);
    operator delete();
  }
  return result;
}

uint64_t sub_100540A5C(uint64_t a1)
{
  if (*(void *)(a1 + 24) && *(void *)(a1 + 56))
  {
    sub_100540CCC((uint64_t)v5, a1 + 32);
    v5[2] = *(_OWORD *)a1;
    *(void *)a1 = 0;
    *(void *)(a1 + 8) = 0;
    char v6 = *(unsigned char *)(a1 + 16);
    operator new();
  }
  sub_100540D4C((void *)(a1 + 32));
  uint64_t v2 = *(NSObject **)(a1 + 24);
  if (v2) {
    dispatch_release(v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 8);
  if (v3) {
    sub_10004D2C8(v3);
  }
  return a1;
}

void sub_100540B7C(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_10006A6AC(a1);
}

void sub_100540B88(uint64_t a1)
{
  sub_100540BB0((uint64_t)&v1, a1);
}

void sub_100540BB0(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (void *)a2;
  long long v5 = *(_OWORD *)(a2 + 32);
  *(void *)(a2 + 32) = 0;
  *(void *)(a2 + 40) = 0;
  char v6 = *(unsigned char *)(a2 + 48);
  uint64_t v2 = *(void *)(a2 + 24);
  if (!v2) {
    sub_10007B600();
  }
  (*(void (**)(uint64_t, long long *))(*(void *)v2 + 48))(v2, &v5);
  if (*((void *)&v5 + 1)) {
    sub_10004D2C8(*((std::__shared_weak_count **)&v5 + 1));
  }
  uint64_t v3 = v4;
  uint64_t v4 = 0;
  if (v3) {
    sub_100540C70((uint64_t)&v4, v3);
  }
}

void sub_100540C44(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    sub_10004D2C8(a12);
  }
  long long v13 = a10;
  a10 = 0;
  if (v13) {
    sub_100540C70((uint64_t)&a10, v13);
  }
  _Unwind_Resume(exception_object);
}

void sub_100540C70(uint64_t a1, void *a2)
{
  if (a2)
  {
    uint64_t v3 = (std::__shared_weak_count *)a2[5];
    if (v3) {
      sub_10004D2C8(v3);
    }
    sub_100540D4C(a2);
    operator delete();
  }
}

uint64_t sub_100540CCC(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (void *)(a2 + 24);
  uint64_t v4 = *(void *)(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(*(void *)*v3 + 24))(*v3, a1);
      return a1;
    }
    *(void *)(a1 + 24) = v4;
  }
  else
  {
    uint64_t v3 = (void *)(a1 + 24);
  }
  *uint64_t v3 = 0;
  return a1;
}

void *sub_100540D4C(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t sub_100540DD0(uint64_t *a1, uint64_t a2)
{
  uint64_t result = *a1;
  *a1 = a2;
  if (result)
  {
    sub_100540E20(result);
    operator delete();
  }
  return result;
}

uint64_t sub_100540E20(uint64_t a1)
{
  if (*(void *)(a1 + 24) && *(void *)(a1 + 56))
  {
    sub_100541090((uint64_t)v5, a1 + 32);
    v5[2] = *(_OWORD *)a1;
    *(void *)a1 = 0;
    *(void *)(a1 + 8) = 0;
    char v6 = *(unsigned char *)(a1 + 16);
    operator new();
  }
  sub_100541110((void *)(a1 + 32));
  uint64_t v2 = *(NSObject **)(a1 + 24);
  if (v2) {
    dispatch_release(v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 8);
  if (v3) {
    sub_10004D2C8(v3);
  }
  return a1;
}

void sub_100540F40(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_10006A6AC(a1);
}

void sub_100540F4C(uint64_t a1)
{
  sub_100540F74((uint64_t)&v1, a1);
}

void sub_100540F74(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (void *)a2;
  long long v5 = *(_OWORD *)(a2 + 32);
  *(void *)(a2 + 32) = 0;
  *(void *)(a2 + 40) = 0;
  char v6 = *(unsigned char *)(a2 + 48);
  uint64_t v2 = *(void *)(a2 + 24);
  if (!v2) {
    sub_10007B600();
  }
  (*(void (**)(uint64_t, long long *))(*(void *)v2 + 48))(v2, &v5);
  if (*((void *)&v5 + 1)) {
    sub_10004D2C8(*((std::__shared_weak_count **)&v5 + 1));
  }
  uint64_t v3 = v4;
  uint64_t v4 = 0;
  if (v3) {
    sub_100541034((uint64_t)&v4, v3);
  }
}

void sub_100541008(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    sub_10004D2C8(a12);
  }
  long long v13 = a10;
  a10 = 0;
  if (v13) {
    sub_100541034((uint64_t)&a10, v13);
  }
  _Unwind_Resume(exception_object);
}

void sub_100541034(uint64_t a1, void *a2)
{
  if (a2)
  {
    uint64_t v3 = (std::__shared_weak_count *)a2[5];
    if (v3) {
      sub_10004D2C8(v3);
    }
    sub_100541110(a2);
    operator delete();
  }
}

uint64_t sub_100541090(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (void *)(a2 + 24);
  uint64_t v4 = *(void *)(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(*(void *)*v3 + 24))(*v3, a1);
      return a1;
    }
    *(void *)(a1 + 24) = v4;
  }
  else
  {
    uint64_t v3 = (void *)(a1 + 24);
  }
  *uint64_t v3 = 0;
  return a1;
}

void *sub_100541110(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void sub_100541194(void **a1)
{
  char v1 = *a1;
  if (*a1)
  {
    uint64_t v3 = (uint64_t)a1[1];
    uint64_t v4 = *a1;
    if ((void *)v3 != v1)
    {
      do
      {
        v3 -= 136;
        sub_100320588(v3);
      }
      while ((void *)v3 != v1);
      uint64_t v4 = *a1;
    }
    a1[1] = v1;
    operator delete(v4);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

void sub_1005411FC(uint64_t a1)
{
  sub_1005412E0();
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = objc_getClass("_SWCServiceSpecifier");
  if (*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24))
  {
    qword_101B0D160 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  }
  else
  {
    uint64_t v2 = +[NSAssertionHandler currentHandler];
    uint64_t v3 = +[NSString stringWithUTF8String:"Class get_SWCServiceSpecifierClass()_block_invoke"];
    objc_msgSend(v2, "handleFailureInFunction:file:lineNumber:description:", v3, @"CTXPCClientHandler+CellularPlanManager.mm", 63, @"Unable to find class %s", "_SWCServiceSpecifier");

    __break(1u);
  }
}

void sub_1005412C4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1005412E0()
{
  v3[0] = 0;
  if (!qword_101B0D150)
  {
    v3[1] = _NSConcreteStackBlock;
    v3[2] = (void *)3221225472;
    v3[3] = sub_10054145C;
    void v3[4] = &unk_1019A1BF8;
    void v3[5] = v3;
    long long v4 = off_1019E0FF8;
    uint64_t v5 = 0;
    qword_101B0D150 = _sl_dlopen();
  }
  if (!qword_101B0D150)
  {
    char v1 = +[NSAssertionHandler currentHandler];
    uint64_t v2 = +[NSString stringWithUTF8String:"void *SharedWebCredentialsLibrary()"];
    objc_msgSend(v1, "handleFailureInFunction:file:lineNumber:description:", v2, @"CTXPCClientHandler+CellularPlanManager.mm", 62, @"%s", v3[0]);

    __break(1u);
    goto LABEL_7;
  }
  uint64_t v0 = v3[0];
  if (v3[0]) {
LABEL_7:
  }
    free(v0);
}

void sub_100541438(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, _Unwind_Exception *exception_object)
{
  _Unwind_Resume(a1);
}

uint64_t sub_10054145C()
{
  uint64_t result = _sl_dlopen();
  qword_101B0D150 = result;
  return result;
}

void sub_1005414D0(uint64_t a1)
{
  sub_1005412E0();
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = objc_getClass("_SWCServiceDetails");
  if (*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24))
  {
    qword_101B0D168 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  }
  else
  {
    uint64_t v2 = +[NSAssertionHandler currentHandler];
    uint64_t v3 = +[NSString stringWithUTF8String:"Class get_SWCServiceDetailsClass()_block_invoke"];
    objc_msgSend(v2, "handleFailureInFunction:file:lineNumber:description:", v3, @"CTXPCClientHandler+CellularPlanManager.mm", 64, @"Unable to find class %s", "_SWCServiceDetails");

    __break(1u);
  }
}

void sub_100541598(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1005415B4(uint64_t a1)
{
  *(void *)a1 = off_1019E1020;

  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 40);
  if (v2) {
    sub_10004D2C8(v2);
  }
  long long v4 = (void **)(a1 + 8);
  sub_10030B640(&v4);
  return a1;
}

void sub_100541620(uint64_t a1)
{
  *(void *)a1 = off_1019E1020;

  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 40);
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = (void **)(a1 + 8);
  sub_10030B640(&v3);
  operator delete();
}

void *sub_1005416A0(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t v2 = operator new(0x38uLL);
  void *v2 = off_1019E1020;
  sub_1005417D8(v2 + 1, v1);
  return v2;
}

void sub_1005416F4(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_100541708(uint64_t a1, void *a2)
{
  *a2 = off_1019E1020;
  return sub_1005417D8(a2 + 1, a1 + 8);
}

void sub_100541734(uint64_t a1)
{
}

void sub_10054173C(void *a1)
{
  sub_100541840((uint64_t)a1 + 8);

  operator delete(a1);
}

uint64_t sub_100541778(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 48) + 16))();
}

uint64_t sub_10054178C(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_1019E1080)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_1005417CC()
{
  return &off_1019E1080;
}

void *sub_1005417D8(void *a1, uint64_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  sub_10030B4A4(a1, *(void *)a2, *(void *)(a2 + 8), (uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 7);
  uint64_t v4 = *(void *)(a2 + 32);
  a1[3] = *(void *)(a2 + 24);
  a1[4] = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  a1[5] = objc_retainBlock(*(id *)(a2 + 40));
  return a1;
}

void sub_100541840(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 32);
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = (void **)a1;
  sub_10030B640(&v3);
}

uint64_t sub_100541888(uint64_t a1)
{
  return a1;
}

void sub_1005418B4(uint64_t a1)
{
  operator delete();
}

void *sub_100541900(uint64_t a1)
{
  uint64_t v2 = operator new(0x10uLL);
  void *v2 = off_1019E10A0;
  v2[1] = objc_retainBlock(*(id *)(a1 + 8));
  return v2;
}

id sub_100541958(uint64_t a1, void *a2)
{
  *a2 = off_1019E10A0;
  id result = objc_retainBlock(*(id *)(a1 + 8));
  a2[1] = result;
  return result;
}

void sub_1005419A0(uint64_t a1)
{
}

void sub_1005419A8(id *a1)
{
  operator delete(a1);
}

void sub_1005419E4(uint64_t a1, unsigned char *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (*a2)
  {
    sub_1003DF5C4(*a2);
    id v5 = (id)objc_claimAutoreleasedReturnValue();
    (*(void (**)(uint64_t, uint64_t))(v2 + 16))(v2, 1);
  }
  else
  {
    uint64_t v3 = *(void (**)(uint64_t, uint64_t, void))(v2 + 16);
    uint64_t v4 = *(void *)(a1 + 8);
    v3(v4, 2, 0);
  }
}

void sub_100541A88(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t sub_100541A9C(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_1019E1100)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_100541ADC()
{
  return &off_1019E1100;
}

uint64_t sub_100541AE8(uint64_t a1)
{
  return a1;
}

void sub_100541B14(uint64_t a1)
{
  operator delete();
}

uint64_t sub_100541B60()
{
  return 0;
}

id sub_100541B68(uint64_t a1, void *a2)
{
  *a2 = off_1019E1120;
  id result = objc_retainBlock(*(id *)(a1 + 8));
  a2[1] = result;
  return result;
}

void sub_100541BB0(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 8);
  *(void *)(a1 + 8) = 0;
}

uint64_t sub_100541BC0(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 8) + 16))();
}

uint64_t sub_100541BD4(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_1019E1180)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_100541C14()
{
  return &off_1019E1180;
}

uint64_t sub_100541C20(uint64_t a1)
{
  return a1;
}

void sub_100541C54(uint64_t a1)
{
  operator delete();
}

void *sub_100541CA8(uint64_t a1)
{
  uint64_t v2 = operator new(0x18uLL);
  void *v2 = off_1019E11A0;
  v2[1] = objc_retainBlock(*(id *)(a1 + 8));
  void v2[2] = *(id *)(a1 + 16);
  return v2;
}

id sub_100541D0C(uint64_t a1, void *a2)
{
  *a2 = off_1019E11A0;
  a2[1] = objc_retainBlock(*(id *)(a1 + 8));
  id result = *(id *)(a1 + 16);
  a2[2] = result;
  return result;
}

void sub_100541D64(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 8);
}

void sub_100541DA0(id *a1)
{
  operator delete(a1);
}

const void **sub_100541DE4(uint64_t a1, const void **a2)
{
  long long v9 = *a2;
  uint64_t v3 = v9;
  *a2 = 0;
  if (v3) {
    uint64_t v4 = sub_100083F10;
  }
  else {
    uint64_t v4 = 0;
  }
  if (v4)
  {
    id v5 = [objc_alloc((Class)CTDisplayPlanList) initWithDisplayPlans:v9];
    char v6 = *(void **)(a1 + 16);
    if (v6)
    {
      [v6 getLogContext];
      long long v7 = *(NSObject **)&buf[8];
    }
    else
    {
      long long v7 = 0;
      *(_OWORD *)std::string buf = 0uLL;
    }
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)std::string buf = 138412290;
      *(void *)&uint8_t buf[4] = v5;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Blacklist plans are: %@", buf, 0xCu);
    }
    (*(void (**)(void))(*(void *)(a1 + 8) + 16))();
  }
  else
  {
    (*(void (**)(void))(*(void *)(a1 + 8) + 16))();
  }
  return sub_100044D00(&v9);
}

void sub_100541F2C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);

  sub_100044D00((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100541F58(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_1019E1200)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_100541F98()
{
  return &off_1019E1200;
}

uint64_t sub_100541FA4(uint64_t a1)
{
  return a1;
}

void sub_100541FD0(uint64_t a1)
{
  operator delete();
}

void *sub_10054201C(uint64_t a1)
{
  uint64_t v2 = operator new(0x10uLL);
  void *v2 = off_1019E1220;
  v2[1] = objc_retainBlock(*(id *)(a1 + 8));
  return v2;
}

id sub_100542074(uint64_t a1, void *a2)
{
  *a2 = off_1019E1220;
  id result = objc_retainBlock(*(id *)(a1 + 8));
  a2[1] = result;
  return result;
}

void sub_1005420BC(uint64_t a1)
{
}

void sub_1005420C4(id *a1)
{
  operator delete(a1);
}

uint64_t sub_100542100(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 8) + 16))();
}

uint64_t sub_100542118(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_1019E1280)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_100542158()
{
  return &off_1019E1280;
}

uint64_t sub_100542164(uint64_t a1)
{
  return a1;
}

void sub_100542190(uint64_t a1)
{
  operator delete();
}

void *sub_1005421DC(uint64_t a1)
{
  uint64_t v2 = operator new(0x10uLL);
  void *v2 = off_1019E12A0;
  v2[1] = objc_retainBlock(*(id *)(a1 + 8));
  return v2;
}

id sub_100542234(uint64_t a1, void *a2)
{
  *a2 = off_1019E12A0;
  id result = objc_retainBlock(*(id *)(a1 + 8));
  a2[1] = result;
  return result;
}

void sub_10054227C(uint64_t a1)
{
}

void sub_100542284(id *a1)
{
  operator delete(a1);
}

uint64_t sub_1005422C0(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 8) + 16))();
}

uint64_t sub_1005422D8(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_1019E1300)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_100542318()
{
  return &off_1019E1300;
}

uint64_t sub_100542324(uint64_t a1)
{
  return a1;
}

void sub_100542350(uint64_t a1)
{
  operator delete();
}

void *sub_10054239C(uint64_t a1)
{
  uint64_t v2 = operator new(0x10uLL);
  void *v2 = off_1019E1320;
  v2[1] = objc_retainBlock(*(id *)(a1 + 8));
  return v2;
}

id sub_1005423F4(uint64_t a1, void *a2)
{
  *a2 = off_1019E1320;
  id result = objc_retainBlock(*(id *)(a1 + 8));
  a2[1] = result;
  return result;
}

void sub_10054243C(uint64_t a1)
{
}

void sub_100542444(id *a1)
{
  operator delete(a1);
}

uint64_t sub_100542480(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 8) + 16))();
}

uint64_t sub_100542494(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_1019E1380)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_1005424D4()
{
  return &off_1019E1380;
}

uint64_t sub_1005424E0(uint64_t a1)
{
  return a1;
}

void sub_10054250C(uint64_t a1)
{
  operator delete();
}

void *sub_100542558(uint64_t a1)
{
  uint64_t v2 = operator new(0x10uLL);
  void *v2 = off_1019E13A0;
  v2[1] = objc_retainBlock(*(id *)(a1 + 8));
  return v2;
}

id sub_1005425B0(uint64_t a1, void *a2)
{
  *a2 = off_1019E13A0;
  id result = objc_retainBlock(*(id *)(a1 + 8));
  a2[1] = result;
  return result;
}

void sub_1005425F8(uint64_t a1)
{
}

void sub_100542600(id *a1)
{
  operator delete(a1);
}

const void **sub_10054263C(uint64_t a1, unsigned __int8 *a2, const void **a3, const void **a4, unsigned char *a5)
{
  int v5 = *a2;
  char v6 = *a3;
  *a3 = 0;
  long long v7 = *a4;
  long long v13 = *a4;
  char v14 = v6;
  *a4 = 0;
  uint64_t v8 = *(void *)(a1 + 8);
  if (*a5)
  {
    long long v9 = sub_1003DF5C4(*a5);
    (*(void (**)(uint64_t, void, const void *, const void *, void *))(v8 + 16))(v8, 0, v6, v7, v9);
  }
  else
  {
    if (v5) {
      uint64_t v10 = 0;
    }
    else {
      uint64_t v10 = v6;
    }
    if (v5) {
      char v11 = 0;
    }
    else {
      char v11 = v7;
    }
    (*(void (**)(void, BOOL, const void *, const void *, void))(v8 + 16))(*(void *)(a1 + 8), v5 != 0, v10, v11, 0);
  }
  sub_100057D78(&v13);
  return sub_1000558F4(&v14);
}

void sub_1005426FC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, const void *a10)
{
  sub_100057D78(&a9);
  sub_1000558F4(&a10);
  _Unwind_Resume(a1);
}

uint64_t sub_100542724(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_1019E1400)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_100542764()
{
  return &off_1019E1400;
}

uint64_t sub_100542770(uint64_t a1)
{
  return a1;
}

void sub_10054279C(uint64_t a1)
{
  operator delete();
}

void *sub_1005427E8(uint64_t a1)
{
  uint64_t v2 = operator new(0x10uLL);
  void *v2 = off_1019E1420;
  v2[1] = objc_retainBlock(*(id *)(a1 + 8));
  return v2;
}

id sub_100542840(uint64_t a1, void *a2)
{
  *a2 = off_1019E1420;
  id result = objc_retainBlock(*(id *)(a1 + 8));
  a2[1] = result;
  return result;
}

void sub_100542888(uint64_t a1)
{
}

void sub_100542890(id *a1)
{
  operator delete(a1);
}

const void **sub_1005428CC(uint64_t a1, unsigned __int8 *a2, const void **a3, const void **a4, unsigned char *a5)
{
  int v5 = *a2;
  char v6 = *a3;
  *a3 = 0;
  long long v7 = *a4;
  long long v13 = *a4;
  char v14 = v6;
  *a4 = 0;
  uint64_t v8 = *(void *)(a1 + 8);
  if (*a5)
  {
    long long v9 = sub_1003DF5C4(*a5);
    (*(void (**)(uint64_t, void, const void *, const void *, void *))(v8 + 16))(v8, 0, v6, v7, v9);
  }
  else
  {
    if (v5) {
      uint64_t v10 = 0;
    }
    else {
      uint64_t v10 = v6;
    }
    if (v5) {
      char v11 = 0;
    }
    else {
      char v11 = v7;
    }
    (*(void (**)(void, BOOL, const void *, const void *, void))(v8 + 16))(*(void *)(a1 + 8), v5 != 0, v10, v11, 0);
  }
  sub_100057D78(&v13);
  return sub_1000558F4(&v14);
}

void sub_10054298C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, const void *a10)
{
  sub_100057D78(&a9);
  sub_1000558F4(&a10);
  _Unwind_Resume(a1);
}

uint64_t sub_1005429B4(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_1019E1480)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_1005429F4()
{
  return &off_1019E1480;
}

uint64_t sub_100542A00(uint64_t a1)
{
  return a1;
}

void sub_100542A2C(uint64_t a1)
{
  operator delete();
}

void *sub_100542A78(uint64_t a1)
{
  uint64_t v2 = operator new(0x10uLL);
  void *v2 = off_1019E14A0;
  v2[1] = objc_retainBlock(*(id *)(a1 + 8));
  return v2;
}

id sub_100542AD0(uint64_t a1, void *a2)
{
  *a2 = off_1019E14A0;
  id result = objc_retainBlock(*(id *)(a1 + 8));
  a2[1] = result;
  return result;
}

void sub_100542B18(uint64_t a1)
{
}

void sub_100542B20(id *a1)
{
  operator delete(a1);
}

void sub_100542B5C(uint64_t a1, unsigned __int8 *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  sub_1003DF5C4(*a2);
  id v3 = (id)objc_claimAutoreleasedReturnValue();
  (*(void (**)(uint64_t))(v2 + 16))(v2);
}

void sub_100542BC0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t sub_100542BD4(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_1019E1500)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_100542C14()
{
  return &off_1019E1500;
}

uint64_t sub_100542C20(uint64_t a1)
{
  return a1;
}

void sub_100542C4C(uint64_t a1)
{
  operator delete();
}

void *sub_100542C98(uint64_t a1)
{
  uint64_t v2 = operator new(0x10uLL);
  void *v2 = off_1019E1520;
  v2[1] = objc_retainBlock(*(id *)(a1 + 8));
  return v2;
}

id sub_100542CF0(uint64_t a1, void *a2)
{
  *a2 = off_1019E1520;
  id result = objc_retainBlock(*(id *)(a1 + 8));
  a2[1] = result;
  return result;
}

void sub_100542D38(uint64_t a1)
{
}

void sub_100542D40(id *a1)
{
  operator delete(a1);
}

void sub_100542D7C(uint64_t a1, unsigned __int8 *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  sub_1003DF5C4(*a2);
  id v3 = (id)objc_claimAutoreleasedReturnValue();
  (*(void (**)(uint64_t))(v2 + 16))(v2);
}

void sub_100542DE0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t sub_100542DF4(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_1019E1580)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_100542E34()
{
  return &off_1019E1580;
}

uint64_t sub_100542E40(uint64_t a1)
{
  return a1;
}

void sub_100542E6C(uint64_t a1)
{
  operator delete();
}

void *sub_100542EB8(uint64_t a1)
{
  uint64_t v2 = operator new(0x10uLL);
  void *v2 = off_1019E15A0;
  v2[1] = objc_retainBlock(*(id *)(a1 + 8));
  return v2;
}

id sub_100542F10(uint64_t a1, void *a2)
{
  *a2 = off_1019E15A0;
  id result = objc_retainBlock(*(id *)(a1 + 8));
  a2[1] = result;
  return result;
}

void sub_100542F58(uint64_t a1)
{
}

void sub_100542F60(id *a1)
{
  operator delete(a1);
}

void sub_100542F9C(uint64_t a1, uint64_t *a2, unsigned char *a3)
{
  uint64_t v3 = *(void *)(a1 + 8);
  if (*a3)
  {
    sub_1003DF5C4(*a3);
    id v5 = (id)objc_claimAutoreleasedReturnValue();
    (*(void (**)(uint64_t, void))(v3 + 16))(v3, 0);
  }
  else
  {
    if (*((char *)a2 + 23) >= 0) {
      uint64_t v4 = a2;
    }
    else {
      uint64_t v4 = (uint64_t *)*a2;
    }
    id v5 = +[NSString stringWithUTF8String:v4];
    (*(void (**)(uint64_t))(v3 + 16))(v3);
  }
}

void sub_100543044(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t sub_10054305C(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_1019E1610)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_10054309C()
{
  return &off_1019E1610;
}

uint64_t sub_1005430A8(uint64_t a1)
{
  return a1;
}

void sub_1005430D4(uint64_t a1)
{
  operator delete();
}

void *sub_100543120(uint64_t a1)
{
  uint64_t v2 = operator new(0x10uLL);
  void *v2 = off_1019E1630;
  v2[1] = objc_retainBlock(*(id *)(a1 + 8));
  return v2;
}

id sub_100543178(uint64_t a1, void *a2)
{
  *a2 = off_1019E1630;
  id result = objc_retainBlock(*(id *)(a1 + 8));
  a2[1] = result;
  return result;
}

void sub_1005431C0(uint64_t a1)
{
}

void sub_1005431C8(id *a1)
{
  operator delete(a1);
}

uint64_t sub_100543204(uint64_t a1, unsigned __int8 *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v3 = sub_1003DF970(*a2);
  uint64_t v4 = *(uint64_t (**)(uint64_t, uint64_t))(v2 + 16);

  return v4(v2, v3);
}

uint64_t sub_100543250(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_1019E16A0)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_100543290()
{
  return &off_1019E16A0;
}

uint64_t sub_10054329C(uint64_t a1)
{
  return a1;
}

void sub_1005432C8(uint64_t a1)
{
  operator delete();
}

void *sub_100543314(uint64_t a1)
{
  uint64_t v2 = operator new(0x10uLL);
  void *v2 = off_1019E16C0;
  v2[1] = objc_retainBlock(*(id *)(a1 + 8));
  return v2;
}

id sub_10054336C(uint64_t a1, void *a2)
{
  *a2 = off_1019E16C0;
  id result = objc_retainBlock(*(id *)(a1 + 8));
  a2[1] = result;
  return result;
}

void sub_1005433B4(uint64_t a1)
{
}

void sub_1005433BC(id *a1)
{
  operator delete(a1);
}

const void **sub_1005433F8(uint64_t a1, const void **a2)
{
  long long v7 = *a2;
  uint64_t v2 = v7;
  *a2 = 0;
  if (v2) {
    uint64_t v3 = sub_100083F10;
  }
  else {
    uint64_t v3 = 0;
  }
  uint64_t v4 = *(void *)(a1 + 8);
  if (v3)
  {
    id v5 = [objc_alloc((Class)CTDisplayPlanList) initWithDisplayPlans:v7];
    (*(void (**)(uint64_t, id, void))(v4 + 16))(v4, v5, 0);
  }
  else
  {
    (*(void (**)(void, void, void))(v4 + 16))(*(void *)(a1 + 8), 0, 0);
  }
  return sub_100044D00(&v7);
}

void sub_1005434A4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);

  sub_100044D00((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1005434C4(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_1019E1730)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_100543504()
{
  return &off_1019E1730;
}

uint64_t sub_100543510(uint64_t a1)
{
  return a1;
}

void sub_10054353C(uint64_t a1)
{
  operator delete();
}

void *sub_100543588(uint64_t a1)
{
  uint64_t v2 = operator new(0x10uLL);
  void *v2 = off_1019E1750;
  v2[1] = objc_retainBlock(*(id *)(a1 + 8));
  return v2;
}

id sub_1005435E0(uint64_t a1, void *a2)
{
  *a2 = off_1019E1750;
  id result = objc_retainBlock(*(id *)(a1 + 8));
  a2[1] = result;
  return result;
}

void sub_100543628(uint64_t a1)
{
}

void sub_100543630(id *a1)
{
  operator delete(a1);
}

void sub_10054366C(uint64_t a1, unsigned __int8 *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  sub_1003DF5C4(*a2);
  id v3 = (id)objc_claimAutoreleasedReturnValue();
  (*(void (**)(uint64_t))(v2 + 16))(v2);
}

void sub_1005436D0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1005436E4(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_1019E17B0)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_100543724()
{
  return &off_1019E17B0;
}

uint64_t sub_100543730(uint64_t a1)
{
  return a1;
}

void sub_10054375C(uint64_t a1)
{
  operator delete();
}

void *sub_1005437A8(uint64_t a1)
{
  uint64_t v2 = operator new(0x10uLL);
  void *v2 = off_1019E17D0;
  v2[1] = objc_retainBlock(*(id *)(a1 + 8));
  return v2;
}

id sub_100543800(uint64_t a1, void *a2)
{
  *a2 = off_1019E17D0;
  id result = objc_retainBlock(*(id *)(a1 + 8));
  a2[1] = result;
  return result;
}

void sub_100543848(uint64_t a1)
{
}

void sub_100543850(id *a1)
{
  operator delete(a1);
}

void sub_10054388C(uint64_t a1, unsigned __int8 *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  sub_1003DF5C4(*a2);
  id v3 = (id)objc_claimAutoreleasedReturnValue();
  (*(void (**)(uint64_t))(v2 + 16))(v2);
}

void sub_1005438F0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t sub_100543904(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_1019E1830)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_100543944()
{
  return &off_1019E1830;
}

uint64_t sub_100543950(uint64_t a1)
{
  return a1;
}

void sub_10054397C(uint64_t a1)
{
  operator delete();
}

void *sub_1005439C8(uint64_t a1)
{
  uint64_t v2 = operator new(0x10uLL);
  void *v2 = off_1019E1850;
  v2[1] = objc_retainBlock(*(id *)(a1 + 8));
  return v2;
}

id sub_100543A20(uint64_t a1, void *a2)
{
  *a2 = off_1019E1850;
  id result = objc_retainBlock(*(id *)(a1 + 8));
  a2[1] = result;
  return result;
}

void sub_100543A68(uint64_t a1)
{
}

void sub_100543A70(id *a1)
{
  operator delete(a1);
}

void sub_100543AAC(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  sub_1003DF5C4(0);
  id v2 = (id)objc_claimAutoreleasedReturnValue();
  (*(void (**)(uint64_t))(v1 + 16))(v1);
}

void sub_100543B0C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t sub_100543B20(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_1019E18B0)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_100543B60()
{
  return &off_1019E18B0;
}

uint64_t sub_100543B6C(uint64_t a1)
{
  return a1;
}

void sub_100543B98(uint64_t a1)
{
  operator delete();
}

void *sub_100543BE4(uint64_t a1)
{
  id v2 = operator new(0x10uLL);
  void *v2 = off_1019E18D0;
  v2[1] = objc_retainBlock(*(id *)(a1 + 8));
  return v2;
}

id sub_100543C3C(uint64_t a1, void *a2)
{
  *a2 = off_1019E18D0;
  id result = objc_retainBlock(*(id *)(a1 + 8));
  a2[1] = result;
  return result;
}

void sub_100543C84(uint64_t a1)
{
}

void sub_100543C8C(id *a1)
{
  operator delete(a1);
}

void sub_100543CC8(uint64_t a1, unsigned __int8 *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  sub_1003DF5C4(*a2);
  id v3 = (id)objc_claimAutoreleasedReturnValue();
  (*(void (**)(uint64_t))(v2 + 16))(v2);
}

void sub_100543D2C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t sub_100543D40(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_1019E1930)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_100543D80()
{
  return &off_1019E1930;
}

uint64_t sub_100543D8C(uint64_t a1)
{
  return a1;
}

void sub_100543DB8(uint64_t a1)
{
  operator delete();
}

void *sub_100543E04(uint64_t a1)
{
  uint64_t v2 = operator new(0x10uLL);
  void *v2 = off_1019E1950;
  v2[1] = objc_retainBlock(*(id *)(a1 + 8));
  return v2;
}

id sub_100543E5C(uint64_t a1, void *a2)
{
  *a2 = off_1019E1950;
  id result = objc_retainBlock(*(id *)(a1 + 8));
  a2[1] = result;
  return result;
}

void sub_100543EA4(uint64_t a1)
{
}

void sub_100543EAC(id *a1)
{
  operator delete(a1);
}

void sub_100543EE8(uint64_t a1, unsigned __int8 *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  sub_1003DF5C4(*a2);
  id v3 = (id)objc_claimAutoreleasedReturnValue();
  (*(void (**)(uint64_t))(v2 + 16))(v2);
}

void sub_100543F4C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t sub_100543F60(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_1019E19B0)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_100543FA0()
{
  return &off_1019E19B0;
}

uint64_t sub_100543FAC(uint64_t a1)
{
  return a1;
}

void sub_100543FD8(uint64_t a1)
{
  operator delete();
}

void *sub_100544024(uint64_t a1)
{
  uint64_t v2 = operator new(0x10uLL);
  void *v2 = off_1019E19D0;
  v2[1] = objc_retainBlock(*(id *)(a1 + 8));
  return v2;
}

id sub_10054407C(uint64_t a1, void *a2)
{
  *a2 = off_1019E19D0;
  id result = objc_retainBlock(*(id *)(a1 + 8));
  a2[1] = result;
  return result;
}

void sub_1005440C4(uint64_t a1)
{
}

void sub_1005440CC(id *a1)
{
  operator delete(a1);
}

void sub_100544108(uint64_t a1, unsigned __int8 *a2, unsigned __int8 *a3)
{
  uint64_t v3 = *a2;
  uint64_t v4 = *(void *)(a1 + 8);
  sub_1003DF5C4(*a3);
  id v5 = (id)objc_claimAutoreleasedReturnValue();
  (*(void (**)(uint64_t, uint64_t))(v4 + 16))(v4, v3);
}

void sub_100544174(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t sub_100544188(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_1019E1A30)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_1005441C8()
{
  return &off_1019E1A30;
}

uint64_t sub_1005441D4(uint64_t a1)
{
  return a1;
}

void sub_100544200(uint64_t a1)
{
  operator delete();
}

void *sub_10054424C(uint64_t a1)
{
  uint64_t v2 = operator new(0x10uLL);
  void *v2 = off_1019E1A50;
  v2[1] = objc_retainBlock(*(id *)(a1 + 8));
  return v2;
}

id sub_1005442A4(uint64_t a1, void *a2)
{
  *a2 = off_1019E1A50;
  id result = objc_retainBlock(*(id *)(a1 + 8));
  a2[1] = result;
  return result;
}

void sub_1005442EC(uint64_t a1)
{
}

void sub_1005442F4(id *a1)
{
  operator delete(a1);
}

void sub_100544330(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void **)a2;
  uint64_t v4 = *(std::__shared_weak_count **)(a2 + 8);
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = 0;
  int v5 = *(unsigned __int8 *)(a2 + 16);
  if (v3) {
    uint64_t v3 = (void *)*v3;
  }
  char v6 = v3;
  if (v5)
  {
    long long v7 = sub_1003DF5C4(v5);
  }
  else
  {
    long long v7 = 0;
  }
  (*(void (**)(void))(*(void *)(a1 + 8) + 16))();

  if (v4)
  {
    sub_10004D2C8(v4);
  }
}

void sub_1005443E8(_Unwind_Exception *a1)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100544408(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_1019E1AC0)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_100544448()
{
  return &off_1019E1AC0;
}

uint64_t sub_100544454(uint64_t a1)
{
  return a1;
}

void sub_100544480(uint64_t a1)
{
  operator delete();
}

void *sub_1005444CC(uint64_t a1)
{
  uint64_t v2 = operator new(0x10uLL);
  void *v2 = off_1019E1AE0;
  v2[1] = objc_retainBlock(*(id *)(a1 + 8));
  return v2;
}

id sub_100544524(uint64_t a1, void *a2)
{
  *a2 = off_1019E1AE0;
  id result = objc_retainBlock(*(id *)(a1 + 8));
  a2[1] = result;
  return result;
}

void sub_10054456C(uint64_t a1)
{
}

void sub_100544574(id *a1)
{
  operator delete(a1);
}

void sub_1005445B0(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void **)a2;
  uint64_t v4 = *(std::__shared_weak_count **)(a2 + 8);
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = 0;
  int v5 = *(unsigned __int8 *)(a2 + 16);
  if (v3) {
    uint64_t v3 = (void *)*v3;
  }
  char v6 = v3;
  if (v5)
  {
    long long v7 = sub_1003DF5C4(v5);
  }
  else
  {
    long long v7 = 0;
  }
  (*(void (**)(void))(*(void *)(a1 + 8) + 16))();

  if (v4)
  {
    sub_10004D2C8(v4);
  }
}

void sub_100544668(_Unwind_Exception *a1)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100544688(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_1019E1B50)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_1005446C8()
{
  return &off_1019E1B50;
}

uint64_t sub_1005446D4(uint64_t a1)
{
  return a1;
}

void sub_100544700(uint64_t a1)
{
  operator delete();
}

void *sub_10054474C(uint64_t a1)
{
  uint64_t v2 = operator new(0x10uLL);
  void *v2 = off_1019E1B70;
  v2[1] = objc_retainBlock(*(id *)(a1 + 8));
  return v2;
}

id sub_1005447A4(uint64_t a1, void *a2)
{
  *a2 = off_1019E1B70;
  id result = objc_retainBlock(*(id *)(a1 + 8));
  a2[1] = result;
  return result;
}

void sub_1005447EC(uint64_t a1)
{
}

void sub_1005447F4(id *a1)
{
  operator delete(a1);
}

const void **sub_100544830(uint64_t a1, const void **a2, const void **a3, _WORD *a4)
{
  int v5 = *a2;
  *a2 = 0;
  long long v9 = *a3;
  uint64_t v10 = v5;
  *a3 = 0;
  if ((unsigned __int16)*a4 >= 0x100u)
  {
    uint64_t v6 = *(void *)(a1 + 8);
    long long v7 = sub_1003DF5C4(*a4);
    (*(void (**)(uint64_t, void, void, void *))(v6 + 16))(v6, 0, 0, v7);
  }
  else
  {
    (*(void (**)(void, const void *))(*(void *)(a1 + 8) + 16))(*(void *)(a1 + 8), v5);
  }
  sub_100057D78(&v9);
  return sub_1000558F4(&v10);
}

void sub_1005448D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, const void *a10)
{
  sub_100057D78(&a9);
  sub_1000558F4(&a10);
  _Unwind_Resume(a1);
}

uint64_t sub_100544900(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_1019E1BE0)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_100544940()
{
  return &off_1019E1BE0;
}

uint64_t sub_10054494C(uint64_t a1)
{
  return a1;
}

void sub_100544978(uint64_t a1)
{
  operator delete();
}

void *sub_1005449C4(uint64_t a1)
{
  uint64_t v2 = operator new(0x10uLL);
  void *v2 = off_1019E1C00;
  v2[1] = objc_retainBlock(*(id *)(a1 + 8));
  return v2;
}

id sub_100544A1C(uint64_t a1, void *a2)
{
  *a2 = off_1019E1C00;
  id result = objc_retainBlock(*(id *)(a1 + 8));
  a2[1] = result;
  return result;
}

void sub_100544A64(uint64_t a1)
{
}

void sub_100544A6C(id *a1)
{
  operator delete(a1);
}

const void **sub_100544AA8(uint64_t a1, const void **a2, const void **a3, unsigned char *a4)
{
  int v5 = *a2;
  *a2 = 0;
  long long v9 = *a3;
  uint64_t v10 = v5;
  *a3 = 0;
  uint64_t v6 = *(void *)(a1 + 8);
  if (*a4)
  {
    long long v7 = sub_1003DF5C4(*a4);
    (*(void (**)(uint64_t, void, void, void *))(v6 + 16))(v6, 0, 0, v7);
  }
  else
  {
    (*(void (**)(void))(v6 + 16))(*(void *)(a1 + 8));
  }
  sub_100057D78(&v9);
  return sub_1000FE824(&v10);
}

void sub_100544B50(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, const void *a10)
{
  sub_100057D78(&a9);
  sub_1000FE824(&a10);
  _Unwind_Resume(a1);
}

uint64_t sub_100544B78(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_1019E1C70)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_100544BB8()
{
  return &off_1019E1C70;
}

void *sub_100544BC4(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t sub_100544C48(uint64_t a1)
{
  return a1;
}

void sub_100544C74(uint64_t a1)
{
  operator delete();
}

void *sub_100544CC0(uint64_t a1)
{
  uint64_t v2 = operator new(0x10uLL);
  void *v2 = off_1019E1C90;
  v2[1] = objc_retainBlock(*(id *)(a1 + 8));
  return v2;
}

id sub_100544D18(uint64_t a1, void *a2)
{
  *a2 = off_1019E1C90;
  id result = objc_retainBlock(*(id *)(a1 + 8));
  a2[1] = result;
  return result;
}

void sub_100544D60(uint64_t a1)
{
}

void sub_100544D68(id *a1)
{
  operator delete(a1);
}

const void **sub_100544DA4(uint64_t a1, const void **a2, const void **a3, unsigned char *a4)
{
  int v5 = *a2;
  *a2 = 0;
  long long v9 = *a3;
  uint64_t v10 = v5;
  *a3 = 0;
  uint64_t v6 = *(void *)(a1 + 8);
  if (*a4)
  {
    long long v7 = sub_1003DF5C4(*a4);
    (*(void (**)(uint64_t, void, void, void *))(v6 + 16))(v6, 0, 0, v7);
  }
  else
  {
    (*(void (**)(void))(v6 + 16))(*(void *)(a1 + 8));
  }
  sub_100057D78(&v9);
  return sub_1000FE824(&v10);
}

void sub_100544E4C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, const void *a10)
{
  sub_100057D78(&a9);
  sub_1000FE824(&a10);
  _Unwind_Resume(a1);
}

uint64_t sub_100544E74(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_1019E1CF0)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_100544EB4()
{
  return &off_1019E1CF0;
}

uint64_t sub_100544EC0(uint64_t a1)
{
  return a1;
}

void sub_100544EF4(uint64_t a1)
{
  operator delete();
}

void *sub_100544F48(uint64_t a1)
{
  uint64_t v2 = operator new(0x18uLL);
  void *v2 = off_1019E1D10;
  v2[1] = *(id *)(a1 + 8);
  void v2[2] = objc_retainBlock(*(id *)(a1 + 16));
  return v2;
}

id sub_100544FAC(uint64_t a1, void *a2)
{
  *a2 = off_1019E1D10;
  a2[1] = *(id *)(a1 + 8);
  id result = objc_retainBlock(*(id *)(a1 + 16));
  a2[2] = result;
  return result;
}

void sub_100545004(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 8);
}

void sub_100545040(id *a1)
{
  operator delete(a1);
}

const void **sub_100545084(uint64_t a1, const void **a2, unsigned char *a3)
{
  long long v35 = *a2;
  *a2 = 0;
  int v4 = *a3;
  if (*a3)
  {
    int v5 = *(void **)(a1 + 8);
    if (v5)
    {
      [v5 getLogContext];
      uint64_t v6 = *(NSObject **)&v46[8];
    }
    else
    {
      uint64_t v6 = 0;
      *(_OWORD *)unsigned int v46 = 0uLL;
    }
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)v46);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      uint64_t v29 = asString();
      *(_DWORD *)unsigned int v46 = 136315138;
      *(void *)&v46[4] = v29;
      _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "Get remote device plan items failed, error: %s", v46, 0xCu);
    }
    uint64_t v24 = *(void *)(a1 + 16);
    char v30 = sub_1003DF5C4(v4);
    (*(void (**)(uint64_t, void))(v24 + 16))(v24, 0);
  }
  else
  {
    char v30 = objc_opt_new();
    if (v35) {
      long long v7 = sub_100083F10;
    }
    else {
      long long v7 = 0;
    }
    if (v7) {
      objc_msgSend(v30, "setDevices:");
    }
    uint64_t v8 = [v30 devices];

    if (v8)
    {
      long long v42 = 0u;
      long long v43 = 0u;
      long long v40 = 0u;
      long long v41 = 0u;
      id obj = [v30 devices];
      id v9 = [obj countByEnumeratingWithState:&v40 objects:v46 count:16];
      if (v9)
      {
        uint64_t v32 = *(void *)v41;
        do
        {
          uint64_t v10 = 0;
          id v33 = v9;
          do
          {
            if (*(void *)v41 != v32) {
              objc_enumerationMutation(obj);
            }
            char v11 = *(void **)(*((void *)&v40 + 1) + 8 * v10);
            long long v12 = *(void **)(a1 + 8);
            if (v12)
            {
              [v12 getLogContext];
              long long v13 = *((void *)&buf + 1);
            }
            else
            {
              long long v13 = 0;
              long long buf = 0uLL;
            }
            ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&buf);
            if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
            {
              char v14 = [v11 deviceID];
              LODWORD(buf) = 138412290;
              *(void *)((char *)&buf + 4) = v14;
              _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "Remote device => %@", (uint8_t *)&buf, 0xCu);
            }
            long long v38 = 0u;
            long long v39 = 0u;
            long long v36 = 0u;
            long long v37 = 0u;
            char v15 = [v11 remoteDisplayPlans];
            uint64_t v34 = v10;
            id v16 = [v15 countByEnumeratingWithState:&v36 objects:v44 count:16];
            if (v16)
            {
              uint64_t v17 = *(void *)v37;
              do
              {
                for (uint64_t i = 0; i != v16; uint64_t i = (char *)i + 1)
                {
                  if (*(void *)v37 != v17) {
                    objc_enumerationMutation(v15);
                  }
                  uint64_t v19 = *(void *)(*((void *)&v36 + 1) + 8 * i);
                  char v20 = *(void **)(a1 + 8);
                  if (v20)
                  {
                    [v20 getLogContext];
                    char v21 = *((void *)&buf + 1);
                  }
                  else
                  {
                    char v21 = 0;
                    long long buf = 0uLL;
                  }
                  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&buf);
                  if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
                  {
                    LODWORD(buf) = 138412290;
                    *(void *)((char *)&buf + 4) = v19;
                    _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "Remote device plan => %@", (uint8_t *)&buf, 0xCu);
                  }
                }
                id v16 = [v15 countByEnumeratingWithState:&v36 objects:v44 count:16];
              }
              while (v16);
            }

            uint64_t v10 = v34 + 1;
          }
          while ((id)(v34 + 1) != v33);
          id v9 = [obj countByEnumeratingWithState:&v40 objects:v46 count:16];
        }
        while (v9);
      }

      uint64_t v22 = *(void *)(a1 + 16);
      char v23 = sub_1003DF5C4(0);
      (*(void (**)(uint64_t, void *, void *))(v22 + 16))(v22, v30, v23);
    }
    else
    {
      char v25 = *(void **)(a1 + 8);
      if (v25)
      {
        [v25 getLogContext];
        char v26 = *(NSObject **)&v46[8];
      }
      else
      {
        char v26 = 0;
        *(_OWORD *)unsigned int v46 = 0uLL;
      }
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)v46);
      if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)unsigned int v46 = 0;
        _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "No remote devices available", v46, 2u);
      }
      uint64_t v27 = *(void *)(a1 + 16);
      char v23 = sub_1003DF5C4(1);
      (*(void (**)(uint64_t, void, void *))(v27 + 16))(v27, 0, v23);
    }
  }
  return sub_100044D00(&v35);
}

void sub_1005454FC(_Unwind_Exception *a1, uint64_t a2, void *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  va_start(va, a10);

  sub_100044D00((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100545588(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_1019E1D70)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_1005455C8()
{
  return &off_1019E1D70;
}

uint64_t sub_1005455D4(uint64_t a1)
{
  return a1;
}

void sub_100545608(uint64_t a1)
{
  operator delete();
}

void *sub_10054565C(uint64_t a1)
{
  uint64_t v2 = operator new(0x18uLL);
  void *v2 = off_1019E1D90;
  v2[1] = *(id *)(a1 + 8);
  void v2[2] = objc_retainBlock(*(id *)(a1 + 16));
  return v2;
}

id sub_1005456C0(uint64_t a1, void *a2)
{
  *a2 = off_1019E1D90;
  a2[1] = *(id *)(a1 + 8);
  id result = objc_retainBlock(*(id *)(a1 + 16));
  a2[2] = result;
  return result;
}

void sub_100545718(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 8);
}

void sub_100545754(id *a1)
{
  operator delete(a1);
}

uint64_t sub_100545798(uint64_t a1, uint64_t a2)
{
  LODWORD(v30) = *(_DWORD *)a2;
  long long v31 = *(_OWORD *)(a2 + 8);
  uint64_t v32 = *(void *)(a2 + 24);
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  long long v33 = *(_OWORD *)(a2 + 32);
  uint64_t v34 = *(void *)(a2 + 48);
  *(void *)(a2 + 24) = 0;
  *(void *)(a2 + 32) = 0;
  *(void *)(a2 + 40) = 0;
  *(void *)(a2 + 48) = 0;
  long long v35 = *(_OWORD *)(a2 + 56);
  uint64_t v36 = *(void *)(a2 + 72);
  *(void *)(a2 + 56) = 0;
  *(void *)(a2 + 64) = 0;
  long long v3 = *(_OWORD *)(a2 + 80);
  uint64_t v38 = *(void *)(a2 + 96);
  long long v37 = v3;
  *(void *)(a2 + 72) = 0;
  *(void *)(a2 + 80) = 0;
  *(void *)(a2 + 88) = 0;
  *(void *)(a2 + 96) = 0;
  long long v4 = *(_OWORD *)(a2 + 104);
  uint64_t v40 = *(void *)(a2 + 120);
  long long v39 = v4;
  *(void *)(a2 + 104) = 0;
  *(void *)(a2 + 112) = 0;
  uint64_t v5 = *(void *)(a2 + 144);
  long long v41 = *(_OWORD *)(a2 + 128);
  *(void *)(a2 + 120) = 0;
  *(void *)(a2 + 128) = 0;
  *(void *)(a2 + 136) = 0;
  *(void *)(a2 + 144) = 0;
  long long v6 = *(_OWORD *)(a2 + 152);
  uint64_t v7 = *(void *)(a2 + 168);
  uint64_t v42 = v5;
  uint64_t v44 = v7;
  long long v43 = v6;
  *(void *)(a2 + 152) = 0;
  *(void *)(a2 + 160) = 0;
  uint64_t v8 = *(void *)(a2 + 192);
  long long v45 = *(_OWORD *)(a2 + 176);
  *(void *)(a2 + 168) = 0;
  *(void *)(a2 + 176) = 0;
  *(void *)(a2 + 184) = 0;
  *(void *)(a2 + 192) = 0;
  long long v9 = *(_OWORD *)(a2 + 200);
  uint64_t v10 = *(void *)(a2 + 216);
  uint64_t v46 = v8;
  uint64_t v48 = v10;
  long long v47 = v9;
  *(void *)(a2 + 200) = 0;
  *(void *)(a2 + 208) = 0;
  uint64_t v11 = HIBYTE(v34);
  if (v34 < 0) {
    uint64_t v11 = *((void *)&v33 + 1);
  }
  *(void *)(a2 + 216) = 0;
  if (!v11) {
    goto LABEL_15;
  }
  uint64_t v12 = HIBYTE(v44);
  if (v44 < 0) {
    uint64_t v12 = *((void *)&v43 + 1);
  }
  if (v12)
  {
    long long v13 = +[NSMutableDictionary dictionary];
    NSStringEncoding v14 = +[NSString defaultCStringEncoding];
    if (v34 >= 0) {
      char v15 = &v33;
    }
    else {
      char v15 = (long long *)v33;
    }
    id v16 = +[NSString stringWithCString:v15 encoding:v14];
    [v13 setObject:v16 forKeyedSubscript:@"eid"];

    int v17 = SHIBYTE(v44);
    id v18 = (long long *)v43;
    NSStringEncoding v19 = +[NSString defaultCStringEncoding];
    if (v17 >= 0) {
      char v20 = &v43;
    }
    else {
      char v20 = v18;
    }
    char v21 = +[NSString stringWithCString:v20 encoding:v19];
    [v13 setObject:v21 forKeyedSubscript:@"device-type"];

    uint64_t v22 = *(void **)(a1 + 8);
    if (v22)
    {
      [v22 getLogContext];
      char v23 = *(NSObject **)&buf[8];
    }
    else
    {
      char v23 = 0;
      *(_OWORD *)long long buf = 0uLL;
    }
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v23, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)long long buf = 138412290;
      *(void *)&uint8_t buf[4] = v13;
      _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_INFO, "returning device info: %@", buf, 0xCu);
    }
    uint64_t v27 = *(void *)(a1 + 16);
    id v28 = sub_1003DF5C4(0);
    (*(void (**)(uint64_t, void *, void *))(v27 + 16))(v27, v13, v28);
  }
  else
  {
LABEL_15:
    uint64_t v24 = *(void **)(a1 + 8);
    if (v24)
    {
      objc_msgSend(v24, "getLogContext", v30, v31, v32);
      char v25 = *(NSObject **)&buf[8];
    }
    else
    {
      char v25 = 0;
      *(_OWORD *)long long buf = 0uLL;
    }
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_ERROR, "Failed to get device info", buf, 2u);
    }
    uint64_t v26 = *(void *)(a1 + 16);
    long long v13 = sub_1003DF5C4(7);
    (*(void (**)(uint64_t, void, void *))(v26 + 16))(v26, 0, v13);
  }

  return sub_10030E938((uint64_t)&v30);
}

void sub_100545AF4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  sub_10030E938((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t sub_100545B48(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_1019E1E00)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_100545B88()
{
  return &off_1019E1E00;
}

uint64_t sub_100545B94(uint64_t a1)
{
  return a1;
}

void sub_100545BC8(uint64_t a1)
{
  operator delete();
}

void *sub_100545C1C(uint64_t a1)
{
  uint64_t v2 = operator new(0x18uLL);
  void *v2 = off_1019E1E20;
  v2[1] = *(id *)(a1 + 8);
  void v2[2] = objc_retainBlock(*(id *)(a1 + 16));
  return v2;
}

id sub_100545C80(uint64_t a1, void *a2)
{
  *a2 = off_1019E1E20;
  a2[1] = *(id *)(a1 + 8);
  id result = objc_retainBlock(*(id *)(a1 + 16));
  a2[2] = result;
  return result;
}

void sub_100545CD8(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 8);
}

void sub_100545D14(id *a1)
{
  operator delete(a1);
}

const void **sub_100545D58(uint64_t a1, const void **a2)
{
  long long v9 = *a2;
  long long v3 = v9;
  *a2 = 0;
  if (v3) {
    long long v4 = sub_100083F10;
  }
  else {
    long long v4 = 0;
  }
  if (v4)
  {
    id v5 = [objc_alloc((Class)CTDisplayPlanList) initWithDisplayPlans:v9];
    long long v6 = *(void **)(a1 + 8);
    if (v6)
    {
      [v6 getLogContext];
      uint64_t v7 = *(NSObject **)&buf[8];
    }
    else
    {
      uint64_t v7 = 0;
      *(_OWORD *)long long buf = 0uLL;
    }
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 138412290;
      *(void *)&uint8_t buf[4] = v5;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "On device activation plans are: %@", buf, 0xCu);
    }
    (*(void (**)(void))(*(void *)(a1 + 16) + 16))();
  }
  else
  {
    (*(void (**)(void))(*(void *)(a1 + 16) + 16))();
  }
  return sub_100044D00(&v9);
}

void sub_100545EA0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);

  sub_100044D00((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100545ECC(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_1019E1E80)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_100545F0C()
{
  return &off_1019E1E80;
}

void *sub_100545F18(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t sub_100545F9C(uint64_t a1)
{
  *(void *)a1 = off_1019E1EA0;

  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 24);
  if (v2) {
    sub_10004D2C8(v2);
  }

  return a1;
}

void sub_100545FF8(uint64_t a1)
{
  *(void *)a1 = off_1019E1EA0;

  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 24);
  if (v2) {
    sub_10004D2C8(v2);
  }

  operator delete();
}

void *sub_100546074(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t v2 = operator new(0x28uLL);
  void *v2 = off_1019E1EA0;
  sub_100546364(v2 + 1, v1);
  return v2;
}

void *sub_1005460C8(uint64_t a1, void *a2)
{
  *a2 = off_1019E1EA0;
  return sub_100546364(a2 + 1, a1 + 8);
}

void sub_1005460F4(uint64_t a1)
{
}

void sub_1005460FC(void *a1)
{
  sub_1005463BC((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_100546138(uint64_t a1, const void **a2, CFTypeRef *a3)
{
  long long v4 = *a2;
  *a2 = 0;
  CFTypeRef v8 = *a3;
  CFTypeRef cf = v4;
  *a3 = 0;
  id v5 = *(void **)(a1 + 8);
  if (v5)
  {
    [v5 getQueue];
    long long v6 = *(void **)(a1 + 8);
  }
  else
  {
    long long v6 = 0;
  }
  v6;
  objc_retainBlock(*(id *)(a1 + 32));
  uint64_t v7 = *(void *)(a1 + 24);
  if (v7) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v7 + 8), 1uLL, memory_order_relaxed);
  }
  if (cf) {
    CFRetain(cf);
  }
  if (v8) {
    CFRetain(v8);
  }
  operator new();
}

void sub_1005462F8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va1, a3);
  va_start(va, a3);
  long long v4 = va_arg(va1, const void *);
  sub_100057D78((const void **)va);
  sub_1000558F4((const void **)va1);
  _Unwind_Resume(a1);
}

uint64_t sub_100546318(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_1019E1F90)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_100546358()
{
  return &off_1019E1F90;
}

void *sub_100546364(void *a1, uint64_t a2)
{
  id v4 = *(id *)a2;
  uint64_t v6 = *(void *)(a2 + 8);
  uint64_t v5 = *(void *)(a2 + 16);
  *a1 = v4;
  a1[1] = v6;
  a1[2] = v5;
  if (v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
  }
  a1[3] = objc_retainBlock(*(id *)(a2 + 24));
  return a1;
}

void sub_1005463BC(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2) {
    sub_10004D2C8(v2);
  }
  long long v3 = *(void **)a1;
}

uint64_t *sub_100546404(uint64_t *result)
{
  uint64_t v1 = *result;
  *id result = 0;
  if (v1)
  {
    sub_100057D78((const void **)(v1 + 40));
    sub_1000558F4((const void **)(v1 + 32));
    uint64_t v2 = *(std::__shared_weak_count **)(v1 + 24);
    if (v2) {
      sub_10004D2C8(v2);
    }

    operator delete();
  }
  return result;
}

uint64_t *sub_100546478(uint64_t a1)
{
  uint64_t v10 = a1;
  if (*(unsigned char *)(a1 + 49))
  {
    uint64_t v2 = *(void *)(a1 + 8);
    long long v3 = sub_1003DF5C4(*(unsigned __int8 *)(a1 + 48));
    (*(void (**)(uint64_t, void, void, void, void *))(v2 + 16))(v2, 0, 0, 0, v3);
  }
  else
  {
    id v4 = *(void **)a1;
    uint64_t v5 = *(std::__shared_weak_count **)(a1 + 24);
    uint64_t v13 = *(void *)(a1 + 16);
    NSStringEncoding v14 = v5;
    if (v5) {
      atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    sub_100083DA4((const void **)&v11, (const void **)(a1 + 32));
    sub_100058198((const void **)&v11 + 1, (const void **)(a1 + 40));
    id v6 = objc_retainBlock(*(id *)(a1 + 8));
    id v12 = v6;
    id v16 = 0;
    uint64_t v7 = (char *)operator new(0x20uLL);
    *(void *)uint64_t v7 = off_1019E1F10;
    long long v8 = v11;
    *(void *)&long long v11 = 0;
    *(_OWORD *)(v7 + 8) = v8;
    *((void *)&v11 + 1) = 0;
    id v12 = 0;
    *((void *)v7 + 3) = v6;
    id v16 = v7;
    [v4 handoffTokenWithController:&v13 completion:v15];
    sub_100545F18(v15);

    sub_100057D78((const void **)&v11 + 1);
    sub_1000558F4((const void **)&v11);
    if (v14) {
      sub_10004D2C8(v14);
    }
  }
  return sub_100546404(&v10);
}

void sub_1005465F0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v4 = va_arg(va1, void);
  va_copy(va2, va1);
  id v6 = va_arg(va2, const void *);
  uint64_t v8 = va_arg(va2, void);
  id v9 = va_arg(va2, id);
  uint64_t v10 = va_arg(va2, void);
  long long v11 = va_arg(va2, std::__shared_weak_count *);
  sub_100545F18((uint64_t *)va2);

  sub_100057D78(v2);
  sub_1000558F4((const void **)va1);
  if (v11) {
    sub_10004D2C8(v11);
  }
  sub_100546404((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100546654(uint64_t a1)
{
  *(void *)a1 = off_1019E1F10;
  uint64_t v2 = (const void **)(a1 + 8);

  sub_100057D78((const void **)(a1 + 16));
  sub_1000558F4(v2);
  return a1;
}

void sub_1005466B0(uint64_t a1)
{
  *(void *)a1 = off_1019E1F10;
  uint64_t v2 = (const void **)(a1 + 8);

  sub_100057D78((const void **)(a1 + 16));
  sub_1000558F4(v2);

  operator delete();
}

void *sub_10054672C(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t v2 = operator new(0x20uLL);
  void *v2 = off_1019E1F10;
  sub_100546934((uint64_t)(v2 + 1), v1);
  return v2;
}

uint64_t sub_100546780(uint64_t a1, void *a2)
{
  *a2 = off_1019E1F10;
  return sub_100546934((uint64_t)(a2 + 1), a1 + 8);
}

const void **sub_1005467AC(uint64_t a1)
{
  return sub_100546978(a1 + 8);
}

void sub_1005467B4(void *a1)
{
  sub_100546978((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_1005467F0(uint64_t a1, id *a2, void **a3)
{
  uint64_t v4 = *a3;
  id v7 = *a2;
  id v5 = v4;
  if (v5)
  {
    (*(void (**)(void))(*(void *)(a1 + 24) + 16))();
  }
  else
  {
    id v6 = +[NSMutableDictionary dictionaryWithDictionary:v7];
    [v6 addEntriesFromDictionary:*(void *)(a1 + 16)];
    (*(void (**)(void))(*(void *)(a1 + 24) + 16))();
  }
}

void sub_1005468C0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1005468E8(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_1019E1F80)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_100546928()
{
  return &off_1019E1F80;
}

uint64_t sub_100546934(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = sub_100083DA4((const void **)a1, (const void **)a2);
  sub_100058198(v4 + 1, (const void **)(a2 + 8));
  *(void *)(a1 + 16) = objc_retainBlock(*(id *)(a2 + 16));
  return a1;
}

const void **sub_100546978(uint64_t a1)
{
  sub_100057D78((const void **)(a1 + 8));

  return sub_1000558F4((const void **)a1);
}

uint64_t sub_1005469BC(uint64_t a1)
{
  *(void *)a1 = off_1019E1FB0;

  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

void sub_100546A18(uint64_t a1)
{
  *(void *)a1 = off_1019E1FB0;

  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2) {
    sub_10004D2C8(v2);
  }

  operator delete();
}

void *sub_100546A94(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t v2 = operator new(0x28uLL);
  void *v2 = off_1019E1FB0;
  sub_100546DD8(v2 + 1, v1);
  return v2;
}

void *sub_100546AE8(uint64_t a1, void *a2)
{
  *a2 = off_1019E1FB0;
  return sub_100546DD8(a2 + 1, a1 + 8);
}

void sub_100546B14(uint64_t a1)
{
}

void sub_100546B1C(void *a1)
{
  sub_100546E30((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_100546B58(uint64_t a1, id *a2, void **a3)
{
  id v5 = *a3;
  id v6 = *a2;
  id v7 = v5;
  if (!v7)
  {
    uint64_t v8 = *(void *)(a1 + 8);
    id v9 = [*(id *)(a1 + 24) name];
    if (v9)
    {
      id v3 = [*(id *)(a1 + 24) name];
      uint64_t v10 = (char *)[v3 UTF8String];
    }
    else
    {
      uint64_t v10 = "";
    }
    sub_100058DB0(__p, v10);
    id v11 = *(id *)(a1 + 24);
    id v12 = v6;
    id v13 = objc_retainBlock(*(id *)(a1 + 32));
    id v18 = 0;
    NSStringEncoding v14 = operator new(0x20uLL);
    void *v14 = off_1019E2020;
    v14[1] = v11;
    uint64_t v14[2] = v12;
    uint64_t v14[3] = v13;
    id v18 = v14;
    (*(void (**)(uint64_t, void **, void *))(*(void *)v8 + 304))(v8, __p, v17);
    sub_10030C77C(v17);
    if (v16 < 0)
    {
      operator delete(__p[0]);
      if (!v9)
      {
LABEL_11:

        goto LABEL_12;
      }
    }
    else if (!v9)
    {
      goto LABEL_11;
    }

    goto LABEL_11;
  }
  (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
LABEL_12:
}

void sub_100546D14(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15)
{
  _Unwind_Resume(a1);
}

uint64_t sub_100546D8C(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_1019E20A0)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_100546DCC()
{
  return &off_1019E20A0;
}

void *sub_100546DD8(void *a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 8);
  *a1 = *(void *)a2;
  a1[1] = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  a1[2] = *(id *)(a2 + 16);
  a1[3] = objc_retainBlock(*(id *)(a2 + 24));
  return a1;
}

void sub_100546E30(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 8);
  if (v2)
  {
    sub_10004D2C8(v2);
  }
}

id *sub_100546E84(id *a1)
{
  return a1;
}

void sub_100546EC0(id *a1)
{
  operator delete();
}

void *sub_100546F1C(uint64_t a1)
{
  uint64_t v1 = (id *)(a1 + 8);
  uint64_t v2 = operator new(0x20uLL);
  void *v2 = off_1019E2020;
  sub_10054711C(v2 + 1, v1);
  return v2;
}

void *sub_100546F70(uint64_t a1, void *a2)
{
  *a2 = off_1019E2020;
  return sub_10054711C(a2 + 1, (id *)(a1 + 8));
}

void sub_100546F9C(uint64_t a1)
{
}

void sub_100546FA4(void **a1)
{
  sub_100547168(a1 + 1);

  operator delete(a1);
}

void sub_100546FE0(uint64_t a1, _WORD *a2)
{
  uint64_t v2 = *(void *)(a1 + 24);
  if ((unsigned __int16)*a2 >= 0x100u)
  {
    sub_1003DF5C4(*a2);
    id v6 = (id)objc_claimAutoreleasedReturnValue();
    (*(void (**)(uint64_t, void, void, void))(v2 + 16))(v2, 0, 0, 0);
  }
  else
  {
    id v6 = [*(id *)(a1 + 8) url];
    uint64_t v4 = *(void *)(a1 + 16);
    id v5 = [*(id *)(a1 + 8) type];
    (*(void (**)(uint64_t, id, uint64_t, void *, void))(v2 + 16))(v2, v6, v4, v5, 0);
  }
}

void sub_1005470AC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1005470D0(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_1019E2090)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_100547110()
{
  return &off_1019E2090;
}

void *sub_10054711C(void *a1, id *a2)
{
  *a1 = *a2;
  a1[1] = a2[1];
  a1[2] = objc_retainBlock(a2[2]);
  return a1;
}

void sub_100547168(void **a1)
{
  uint64_t v2 = *a1;
}

uint64_t sub_1005471AC(uint64_t a1)
{
  *(void *)a1 = off_1019E20C0;

  if (*(char *)(a1 + 343) < 0) {
    operator delete(*(void **)(a1 + 320));
  }
  sub_10030CBA4(a1 + 32);
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 24);
  if (v2) {
    sub_10004D2C8(v2);
  }

  return a1;
}

void sub_100547220(uint64_t a1)
{
  *(void *)a1 = off_1019E20C0;

  if (*(char *)(a1 + 343) < 0) {
    operator delete(*(void **)(a1 + 320));
  }
  sub_10030CBA4(a1 + 32);
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 24);
  if (v2) {
    sub_10004D2C8(v2);
  }

  operator delete();
}

void *sub_1005472B4(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t v2 = operator new(0x160uLL);
  void *v2 = off_1019E20C0;
  sub_1005475B4((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_100547308(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_10054731C(uint64_t a1, void *a2)
{
  *a2 = off_1019E20C0;
  return sub_1005475B4((uint64_t)(a2 + 1), a1 + 8);
}

void sub_100547348(uint64_t a1)
{
}

void sub_100547350(void *a1)
{
  sub_100547680((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_10054738C(uint64_t a1, id *a2, void **a3)
{
  uint64_t v4 = *a3;
  id v5 = *a2;
  id v6 = v4;
  if (v6)
  {
    (*(void (**)(void))(*(void *)(a1 + 344) + 16))();
  }
  else
  {
    uint64_t v7 = *(void *)(a1 + 16);
    id v8 = *(id *)(a1 + 8);
    uint64_t v9 = *(void *)(a1 + 16);
    uint64_t v10 = *(void *)(a1 + 24);
    if (v10) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v10 + 8), 1uLL, memory_order_relaxed);
    }
    id v11 = v5;
    id v12 = objc_retainBlock(*(id *)(a1 + 344));
    id v13 = operator new(0x30uLL);
    void *v13 = off_1019E2130;
    id v14 = v8;
    v13[1] = v14;
    v13[2] = v9;
    v13[3] = v10;
    void v13[4] = v11;
    v13[5] = v12;
    void v15[3] = v13;
    (*(void (**)(uint64_t, uint64_t, uint64_t, void *))(*(void *)v7 + 320))(v7, a1 + 32, a1 + 320, v15);
    sub_10030CC88(v15);
  }
}

void sub_100547518(_Unwind_Exception *a1, void *a2, ...)
{
  va_start(va, a2);
  sub_10030CC88((uint64_t *)va);

  _Unwind_Resume(a1);
}

uint64_t sub_100547568(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_1019E21B0)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_1005475A8()
{
  return &off_1019E21B0;
}

uint64_t sub_1005475B4(uint64_t a1, uint64_t a2)
{
  id v4 = *(id *)a2;
  uint64_t v6 = *(void *)(a2 + 8);
  uint64_t v5 = *(void *)(a2 + 16);
  *(void *)a1 = v4;
  *(void *)(a1 + 8) = v6;
  *(void *)(a1 + 16) = v5;
  if (v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
  }
  sub_10030C884((char *)(a1 + 24), (long long *)(a2 + 24));
  uint64_t v7 = (unsigned char *)(a1 + 312);
  if (*(char *)(a2 + 335) < 0)
  {
    sub_10004FC84(v7, *(void **)(a2 + 312), *(void *)(a2 + 320));
  }
  else
  {
    long long v8 = *(_OWORD *)(a2 + 312);
    *(void *)(a1 + 328) = *(void *)(a2 + 328);
    *(_OWORD *)uint64_t v7 = v8;
  }
  *(void *)(a1 + 336) = objc_retainBlock(*(id *)(a2 + 336));
  return a1;
}

void sub_100547650(_Unwind_Exception *a1)
{
  sub_10030CBA4(v2);
  id v4 = *(std::__shared_weak_count **)(v1 + 16);
  if (v4) {
    sub_10004D2C8(v4);
  }

  _Unwind_Resume(a1);
}

void sub_100547680(uint64_t a1)
{
  if (*(char *)(a1 + 335) < 0) {
    operator delete(*(void **)(a1 + 312));
  }
  sub_10030CBA4(a1 + 24);
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2) {
    sub_10004D2C8(v2);
  }
  id v3 = *(void **)a1;
}

uint64_t sub_1005476E0(uint64_t a1)
{
  *(void *)a1 = off_1019E2130;

  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 24);
  if (v2) {
    sub_10004D2C8(v2);
  }

  return a1;
}

void sub_100547744(uint64_t a1)
{
  *(void *)a1 = off_1019E2130;

  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 24);
  if (v2) {
    sub_10004D2C8(v2);
  }

  operator delete();
}

void *sub_1005477C8(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t v2 = operator new(0x30uLL);
  void *v2 = off_1019E2130;
  sub_100547AE0(v2 + 1, v1);
  return v2;
}

void *sub_10054781C(uint64_t a1, void *a2)
{
  *a2 = off_1019E2130;
  return sub_100547AE0(a2 + 1, a1 + 8);
}

void sub_100547848(uint64_t a1)
{
}

void sub_100547850(void *a1)
{
  sub_100547B44((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_10054788C(uint64_t a1, const void **a2, CFTypeRef *a3, CFTypeRef *a4)
{
  uint64_t v5 = *a2;
  *a2 = 0;
  CFTypeRef v9 = *a3;
  CFTypeRef cf = v5;
  *a3 = 0;
  CFTypeRef v8 = *a4;
  *a4 = 0;
  uint64_t v6 = *(void **)(a1 + 8);
  if (v6)
  {
    [v6 getQueue];
    uint64_t v7 = *(void **)(a1 + 8);
  }
  else
  {
    uint64_t v7 = 0;
  }
  v7;
  objc_retainBlock(*(id *)(a1 + 40));
  *(id *)(a1 + 32);
  if (cf) {
    CFRetain(cf);
  }
  if (v9) {
    CFRetain(v9);
  }
  if (v8) {
    CFRetain(v8);
  }
  operator new();
}

void sub_100547A6C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va2, a4);
  va_start(va1, a4);
  va_start(va, a4);
  uint64_t v5 = va_arg(va1, const void *);
  va_copy(va2, va1);
  uint64_t v7 = va_arg(va2, const void *);
  sub_1000558F4((const void **)va);
  sub_100057D78((const void **)va1);
  sub_1000558F4((const void **)va2);
  _Unwind_Resume(a1);
}

uint64_t sub_100547A94(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_1019E21A0)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_100547AD4()
{
  return &off_1019E21A0;
}

void *sub_100547AE0(void *a1, uint64_t a2)
{
  id v4 = *(id *)a2;
  uint64_t v6 = *(void *)(a2 + 8);
  uint64_t v5 = *(void *)(a2 + 16);
  *a1 = v4;
  a1[1] = v6;
  a1[2] = v5;
  if (v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
  }
  a1[3] = *(id *)(a2 + 24);
  a1[4] = objc_retainBlock(*(id *)(a2 + 32));
  return a1;
}

void sub_100547B44(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2) {
    sub_10004D2C8(v2);
  }
  id v3 = *(void **)a1;
}

uint64_t *sub_100547B94(uint64_t *result)
{
  uint64_t v1 = *result;
  *id result = 0;
  if (v1)
  {
    sub_1000558F4((const void **)(v1 + 40));
    sub_100057D78((const void **)(v1 + 32));
    sub_1000558F4((const void **)(v1 + 24));

    operator delete();
  }
  return result;
}

uint64_t *sub_100547C0C(uint64_t a1)
{
  uint64_t v10 = a1;
  if (*(unsigned char *)(a1 + 49))
  {
    uint64_t v2 = *(void *)(a1 + 8);
    id v3 = sub_1003DF5C4(*(unsigned __int8 *)(a1 + 48));
    (*(void (**)(uint64_t, void, void, void, void *))(v2 + 16))(v2, 0, 0, 0, v3);
  }
  else
  {
    if (*(void *)(a1 + 24)) {
      id v4 = sub_1000810B8;
    }
    else {
      id v4 = 0;
    }
    if (v4 && (*(void *)(a1 + 32) ? (uint64_t v5 = sub_100080778) : (uint64_t v5 = 0), v5))
    {
      id v3 = +[NSMutableDictionary dictionaryWithDictionary:*(void *)(a1 + 16)];
      [v3 addEntriesFromDictionary:*(void *)(a1 + 32)];
      (*(void (**)(void))(*(void *)(a1 + 8) + 16))();
    }
    else
    {
      uint64_t v6 = *(void **)a1;
      if (*(void *)a1)
      {
        [v6 getLogContext];
        uint64_t v7 = v12;
      }
      else
      {
        uint64_t v7 = 0;
        *(void *)long long buf = 0;
        id v12 = 0;
      }
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
      if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "Missing URL or postdata", buf, 2u);
      }
      uint64_t v8 = *(void *)(a1 + 8);
      id v3 = sub_1003DF5C4(5);
      (*(void (**)(uint64_t, void, void, void, void *))(v8 + 16))(v8, 0, 0, 0, v3);
    }
  }

  return sub_100547B94(&v10);
}

void sub_100547DA8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);

  sub_100547B94((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100547DD0(uint64_t a1)
{
  return a1;
}

void sub_100547E04(uint64_t a1)
{
  operator delete();
}

void *sub_100547E58(uint64_t a1)
{
  uint64_t v2 = operator new(0x18uLL);
  void *v2 = off_1019E21D0;
  v2[1] = *(id *)(a1 + 8);
  void v2[2] = objc_retainBlock(*(id *)(a1 + 16));
  return v2;
}

id sub_100547EBC(uint64_t a1, void *a2)
{
  *a2 = off_1019E21D0;
  a2[1] = *(id *)(a1 + 8);
  id result = objc_retainBlock(*(id *)(a1 + 16));
  a2[2] = result;
  return result;
}

void sub_100547F14(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 8);
}

void sub_100547F50(id *a1)
{
  operator delete(a1);
}

void sub_100547F94(uint64_t a1, const void **a2, CFTypeRef *a3, CFTypeRef *a4)
{
  uint64_t v5 = *a2;
  *a2 = 0;
  CFTypeRef v9 = *a3;
  CFTypeRef cf = v5;
  *a3 = 0;
  CFTypeRef v8 = *a4;
  *a4 = 0;
  uint64_t v6 = *(void **)(a1 + 8);
  if (v6)
  {
    [v6 getQueue];
    uint64_t v7 = *(void **)(a1 + 8);
  }
  else
  {
    uint64_t v7 = 0;
  }
  v7;
  objc_retainBlock(*(id *)(a1 + 16));
  if (cf) {
    CFRetain(cf);
  }
  if (v9) {
    CFRetain(v9);
  }
  if (v8) {
    CFRetain(v8);
  }
  operator new();
}

void sub_100548158(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va2, a3);
  va_start(va1, a3);
  va_start(va, a3);
  id v4 = va_arg(va1, const void *);
  va_copy(va2, va1);
  uint64_t v6 = va_arg(va2, const void *);
  sub_1000558F4((const void **)va);
  sub_100057D78((const void **)va1);
  sub_1000558F4((const void **)va2);
  _Unwind_Resume(a1);
}

uint64_t sub_100548180(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_1019E2230)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_1005481C0()
{
  return &off_1019E2230;
}

uint64_t *sub_1005481CC(uint64_t *result)
{
  uint64_t v1 = *result;
  *id result = 0;
  if (v1)
  {
    sub_1000558F4((const void **)(v1 + 32));
    sub_100057D78((const void **)(v1 + 24));
    sub_1000558F4((const void **)(v1 + 16));

    operator delete();
  }
  return result;
}

uint64_t *sub_10054823C(uint64_t a1)
{
  uint64_t v10 = a1;
  if (*(unsigned char *)(a1 + 41))
  {
    uint64_t v2 = *(void *)(a1 + 8);
    id v3 = sub_1003DF5C4(*(unsigned __int8 *)(a1 + 40));
    (*(void (**)(uint64_t, void, void, void, void *))(v2 + 16))(v2, 0, 0, 0, v3);
LABEL_18:

    return sub_1005481CC(&v10);
  }
  if (*(void *)(a1 + 16)) {
    id v4 = sub_1000810B8;
  }
  else {
    id v4 = 0;
  }
  if (!v4 || (*(void *)(a1 + 24) ? (uint64_t v5 = sub_100080778) : (uint64_t v5 = 0), !v5))
  {
    uint64_t v6 = *(void **)a1;
    if (*(void *)a1)
    {
      [v6 getLogContext];
      uint64_t v7 = v12;
    }
    else
    {
      uint64_t v7 = 0;
      *(void *)long long buf = 0;
      id v12 = 0;
    }
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "Missing URL or postdata", buf, 2u);
    }
    uint64_t v8 = *(void *)(a1 + 8);
    id v3 = sub_1003DF5C4(5);
    (*(void (**)(uint64_t, void, void, void, void *))(v8 + 16))(v8, 0, 0, 0, v3);
    goto LABEL_18;
  }
  (*(void (**)(void))(*(void *)(a1 + 8) + 16))();
  return sub_1005481CC(&v10);
}

void sub_1005483A8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);

  sub_1005481CC((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1005483CC(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

uint64_t sub_100548464(uint64_t a1)
{
  *(void *)a1 = off_1019E2250;
  sub_100545F18((void *)(a1 + 16));

  return a1;
}

void sub_1005484B0(uint64_t a1)
{
  *(void *)a1 = off_1019E2250;
  sub_100545F18((void *)(a1 + 16));

  operator delete();
}

void *sub_10054851C(uint64_t a1)
{
  uint64_t v1 = (id *)(a1 + 8);
  uint64_t v2 = operator new(0x30uLL);
  void *v2 = off_1019E2250;
  sub_100548954(v2 + 1, v1);
  return v2;
}

void sub_100548570(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_100548584(uint64_t a1, void *a2)
{
  *a2 = off_1019E2250;
  return sub_100548954(a2 + 1, (id *)(a1 + 8));
}

void sub_1005485B0(uint64_t a1)
{
  sub_100545F18((void *)(a1 + 16));
  uint64_t v2 = *(void **)(a1 + 8);
}

void sub_1005485EC(uint64_t a1)
{
  sub_100545F18((void *)(a1 + 16));

  operator delete((void *)a1);
}

void sub_100548630(uint64_t a1, uint64_t a2, uint64_t a3, __int16 *a4)
{
  __int16 v7 = *a4;
  uint64_t v8 = *(void **)(a1 + 8);
  if (v8) {
    [v8 getQueue];
  }
  if (*(char *)(a2 + 23) < 0)
  {
    sub_10004FC84(__dst, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)std::string __dst = *(_OWORD *)a2;
    uint64_t v10 = *(void *)(a2 + 16);
  }
  if (*(char *)(a3 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a3, *(void *)(a3 + 8));
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)a3;
    xpc_object_t __p[2] = *(void **)(a3 + 16);
  }
  __int16 v12 = v7;
  sub_1005483CC((uint64_t)&v13, a1 + 16);
  operator new();
}

void sub_100548808(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, void *a19, uint64_t a20,int a21,__int16 a22,char a23,char a24)
{
  if (a2)
  {
    if (*(char *)(v24 + 23) < 0) {
      operator delete(*(void **)v24);
    }
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100548888(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_1019E22C0)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_1005488C8()
{
  return &off_1019E22C0;
}

uint64_t sub_1005488D4(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (void *)(a2 + 24);
  uint64_t v4 = *(void *)(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(*(void *)*v3 + 24))(*v3, a1);
      return a1;
    }
    *(void *)(a1 + 24) = v4;
  }
  else
  {
    uint64_t v3 = (void *)(a1 + 24);
  }
  *uint64_t v3 = 0;
  return a1;
}

void *sub_100548954(void *a1, id *a2)
{
  uint64_t v3 = (uint64_t)(a2 + 1);
  *a1 = *a2;
  sub_1005483CC((uint64_t)(a1 + 1), v3);
  return a1;
}

void sub_100548998(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t *sub_1005489AC(uint64_t *result)
{
  uint64_t v1 = *result;
  *id result = 0;
  if (v1)
  {
    sub_100545F18((void *)(v1 + 56));
    if (*(char *)(v1 + 47) < 0) {
      operator delete(*(void **)(v1 + 24));
    }
    if (*(char *)(v1 + 23) < 0) {
      operator delete(*(void **)v1);
    }
    operator delete();
  }
  return result;
}

uint64_t *sub_100548A1C(uint64_t a1)
{
  uint64_t v9 = a1;
  if (*(unsigned char *)(a1 + 49))
  {
    uint64_t v2 = sub_1003DF5C4(*(unsigned __int8 *)(a1 + 48));
    sub_100548B9C(a1 + 56, 0, v2);
  }
  else
  {
    v10[0] = @"handoffToken";
    uint64_t v3 = a1;
    if (*(char *)(a1 + 23) < 0) {
      uint64_t v3 = *(void *)a1;
    }
    uint64_t v4 = +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v3, v9, v10[0]);
    v10[1] = @"podIdentifier";
    v11[0] = v4;
    uint64_t v5 = (void *)(a1 + 24);
    if (*(char *)(a1 + 47) < 0) {
      uint64_t v5 = (void *)*v5;
    }
    uint64_t v6 = +[NSString stringWithUTF8String:v5];
    v11[1] = v6;
    __int16 v7 = +[NSDictionary dictionaryWithObjects:v11 forKeys:v10 count:2];

    sub_100548B9C(a1 + 56, v7, 0);
  }
  return sub_1005489AC(&v9);
}

void sub_100548B50(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  sub_1005489AC(&a9);
  _Unwind_Resume(a1);
}

void sub_100548B9C(uint64_t a1, void *a2, void *a3)
{
  id v7 = a2;
  id v6 = a3;
  uint64_t v5 = *(void *)(a1 + 24);
  if (!v5) {
    sub_10007B600();
  }
  (*(void (**)(uint64_t, id *, id *))(*(void *)v5 + 48))(v5, &v7, &v6);
}

void sub_100548C24(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, void *a10)
{
  _Unwind_Resume(a1);
}

uint64_t sub_100548C40(uint64_t a1)
{
  return a1;
}

void sub_100548C74(uint64_t a1)
{
  operator delete();
}

void *sub_100548CC8(uint64_t a1)
{
  uint64_t v2 = operator new(0x18uLL);
  void *v2 = off_1019E22E0;
  v2[1] = *(id *)(a1 + 8);
  void v2[2] = objc_retainBlock(*(id *)(a1 + 16));
  return v2;
}

id sub_100548D2C(uint64_t a1, void *a2)
{
  *a2 = off_1019E22E0;
  a2[1] = *(id *)(a1 + 8);
  id result = objc_retainBlock(*(id *)(a1 + 16));
  a2[2] = result;
  return result;
}

void sub_100548D84(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 8);
}

void sub_100548DC0(id *a1)
{
  operator delete(a1);
}

const void **sub_100548E04(uint64_t a1, const void **a2, void **a3)
{
  uint64_t v4 = *a2;
  *a2 = 0;
  uint64_t v5 = *a3;
  uint64_t v13 = *a3;
  id v14 = v4;
  *a3 = 0;
  if (v4) {
    id v6 = sub_1000810B8;
  }
  else {
    id v6 = 0;
  }
  if (v6 && (v5 ? (id v7 = sub_10008324C) : (id v7 = 0), v7))
  {
    id v8 = [v5 base64EncodedStringWithOptions:0];
    uint64_t v9 = +[NSString stringWithFormat:@"%@|%@", v14, v8, v13];
    (*(void (**)(void))(*(void *)(a1 + 16) + 16))();
  }
  else
  {
    uint64_t v10 = *(void **)(a1 + 8);
    if (v10)
    {
      [v10 getLogContext];
      id v11 = v16;
    }
    else
    {
      id v11 = 0;
      *(void *)long long buf = 0;
      char v16 = 0;
    }
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "Could not get public certificate ID and encrypted data", buf, 2u);
    }
    id v8 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
    (*(void (**)(void))(*(void *)(a1 + 16) + 16))();
  }

  sub_100030068((const void **)&v13);
  return sub_1000558F4(&v14);
}

void sub_100548F8C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va1, a3);
  va_start(va, a3);
  id v6 = va_arg(va1, const void *);

  sub_100030068((const void **)va);
  sub_1000558F4((const void **)va1);
  _Unwind_Resume(a1);
}

uint64_t sub_100548FC4(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_1019E2350)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_100549004()
{
  return &off_1019E2350;
}

uint64_t sub_100549010(uint64_t a1)
{
  return a1;
}

void sub_10054903C(uint64_t a1)
{
  operator delete();
}

void *sub_100549088(uint64_t a1)
{
  uint64_t v2 = operator new(0x10uLL);
  void *v2 = off_1019E2370;
  v2[1] = objc_retainBlock(*(id *)(a1 + 8));
  return v2;
}

id sub_1005490E0(uint64_t a1, void *a2)
{
  *a2 = off_1019E2370;
  id result = objc_retainBlock(*(id *)(a1 + 8));
  a2[1] = result;
  return result;
}

void sub_100549128(uint64_t a1)
{
}

void sub_100549130(id *a1)
{
  operator delete(a1);
}

void sub_10054916C(uint64_t a1, uint64_t a2, unsigned __int8 *a3)
{
  uint64_t v4 = *(id **)a2;
  uint64_t v5 = *(std::__shared_weak_count **)(a2 + 8);
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = 0;
  int v6 = *a3;
  if (v4) {
    id v7 = *v4;
  }
  else {
    id v7 = 0;
  }
  uint64_t v8 = *(void *)(a1 + 8);
  uint64_t v9 = sub_1003DF5C4(v6);
  (*(void (**)(uint64_t, id, void *))(v8 + 16))(v8, v7, v9);

  if (v5)
  {
    sub_10004D2C8(v5);
  }
}

void sub_100549220(_Unwind_Exception *a1)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100549248(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_1019E23E0)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_100549288()
{
  return &off_1019E23E0;
}

uint64_t sub_100549294(uint64_t a1)
{
  return a1;
}

void sub_1005492C0(uint64_t a1)
{
  operator delete();
}

void *sub_10054930C(uint64_t a1)
{
  uint64_t v2 = operator new(0x10uLL);
  void *v2 = off_1019E2400;
  v2[1] = objc_retainBlock(*(id *)(a1 + 8));
  return v2;
}

id sub_100549364(uint64_t a1, void *a2)
{
  *a2 = off_1019E2400;
  id result = objc_retainBlock(*(id *)(a1 + 8));
  a2[1] = result;
  return result;
}

void sub_1005493AC(uint64_t a1)
{
}

void sub_1005493B4(id *a1)
{
  operator delete(a1);
}

void sub_1005493F0(uint64_t a1, unsigned __int8 *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  sub_1003DF5C4(*a2);
  id v3 = (id)objc_claimAutoreleasedReturnValue();
  (*(void (**)(uint64_t))(v2 + 16))(v2);
}

void sub_100549454(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t sub_100549468(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_1019E2460)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_1005494A8()
{
  return &off_1019E2460;
}

uint64_t sub_1005494B4(uint64_t a1)
{
  return a1;
}

void sub_1005494E0(uint64_t a1)
{
  operator delete();
}

void *sub_10054952C(uint64_t a1)
{
  uint64_t v2 = operator new(0x10uLL);
  void *v2 = off_1019E2480;
  v2[1] = objc_retainBlock(*(id *)(a1 + 8));
  return v2;
}

id sub_100549584(uint64_t a1, void *a2)
{
  *a2 = off_1019E2480;
  id result = objc_retainBlock(*(id *)(a1 + 8));
  a2[1] = result;
  return result;
}

void sub_1005495CC(uint64_t a1)
{
}

void sub_1005495D4(id *a1)
{
  operator delete(a1);
}

void sub_100549610(uint64_t a1, unsigned __int8 *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  sub_1003DF5C4(*a2);
  id v3 = (id)objc_claimAutoreleasedReturnValue();
  (*(void (**)(uint64_t))(v2 + 16))(v2);
}

void sub_100549674(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t sub_100549688(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_1019E24E0)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_1005496C8()
{
  return &off_1019E24E0;
}

uint64_t sub_1005496D4(uint64_t a1)
{
  return a1;
}

void sub_100549700(uint64_t a1)
{
  operator delete();
}

void *sub_10054974C(uint64_t a1)
{
  uint64_t v2 = operator new(0x10uLL);
  void *v2 = off_1019E2500;
  v2[1] = objc_retainBlock(*(id *)(a1 + 8));
  return v2;
}

id sub_1005497A4(uint64_t a1, void *a2)
{
  *a2 = off_1019E2500;
  id result = objc_retainBlock(*(id *)(a1 + 8));
  a2[1] = result;
  return result;
}

void sub_1005497EC(uint64_t a1)
{
}

void sub_1005497F4(id *a1)
{
  operator delete(a1);
}

void sub_100549830(uint64_t a1, unsigned __int8 *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  sub_1003DF5C4(*a2);
  id v3 = (id)objc_claimAutoreleasedReturnValue();
  (*(void (**)(uint64_t))(v2 + 16))(v2);
}

void sub_100549894(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1005498A8(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_1019E2560)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_1005498E8()
{
  return &off_1019E2560;
}

uint64_t sub_1005498F4(uint64_t a1)
{
  return a1;
}

void sub_100549920(uint64_t a1)
{
  operator delete();
}

void *sub_10054996C(uint64_t a1)
{
  uint64_t v2 = operator new(0x10uLL);
  void *v2 = off_1019E2580;
  v2[1] = objc_retainBlock(*(id *)(a1 + 8));
  return v2;
}

id sub_1005499C4(uint64_t a1, void *a2)
{
  *a2 = off_1019E2580;
  id result = objc_retainBlock(*(id *)(a1 + 8));
  a2[1] = result;
  return result;
}

void sub_100549A0C(uint64_t a1)
{
}

void sub_100549A14(id *a1)
{
  operator delete(a1);
}

void sub_100549A50(uint64_t a1, unsigned __int8 *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  sub_1003DF5C4(*a2);
  id v3 = (id)objc_claimAutoreleasedReturnValue();
  (*(void (**)(uint64_t))(v2 + 16))(v2);
}

void sub_100549AB4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t sub_100549AC8(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_1019E25E0)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_100549B08()
{
  return &off_1019E25E0;
}

uint64_t sub_100549B14(uint64_t a1)
{
  return a1;
}

void sub_100549B40(uint64_t a1)
{
  operator delete();
}

void *sub_100549B8C(uint64_t a1)
{
  uint64_t v2 = operator new(0x10uLL);
  void *v2 = off_1019E2600;
  v2[1] = objc_retainBlock(*(id *)(a1 + 8));
  return v2;
}

id sub_100549BE4(uint64_t a1, void *a2)
{
  *a2 = off_1019E2600;
  id result = objc_retainBlock(*(id *)(a1 + 8));
  a2[1] = result;
  return result;
}

void sub_100549C2C(uint64_t a1)
{
}

void sub_100549C34(id *a1)
{
  operator delete(a1);
}

void sub_100549C70(uint64_t a1, unsigned __int8 *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  sub_1003DF5C4(*a2);
  id v3 = (id)objc_claimAutoreleasedReturnValue();
  (*(void (**)(uint64_t))(v2 + 16))(v2);
}

void sub_100549CD4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t sub_100549CE8(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_1019E2660)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_100549D28()
{
  return &off_1019E2660;
}

uint64_t sub_100549D34(uint64_t a1)
{
  return a1;
}

void sub_100549D60(uint64_t a1)
{
  operator delete();
}

uint64_t sub_100549DAC()
{
  return 0;
}

id sub_100549DB4(uint64_t a1, void *a2)
{
  *a2 = off_1019E2680;
  id result = objc_retainBlock(*(id *)(a1 + 8));
  a2[1] = result;
  return result;
}

void sub_100549DFC(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 8);
  *(void *)(a1 + 8) = 0;
}

uint64_t sub_100549E0C(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 8) + 16))();
}

uint64_t sub_100549E24(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_1019E26E0)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_100549E64()
{
  return &off_1019E26E0;
}

uint64_t sub_100549E70(uint64_t a1)
{
  return a1;
}

void sub_100549E9C(uint64_t a1)
{
  operator delete();
}

uint64_t sub_100549EE8()
{
  return 0;
}

id sub_100549EF0(uint64_t a1, void *a2)
{
  *a2 = off_1019E2700;
  id result = objc_retainBlock(*(id *)(a1 + 8));
  a2[1] = result;
  return result;
}

void sub_100549F38(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 8);
  *(void *)(a1 + 8) = 0;
}

uint64_t sub_100549F48(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 8) + 16))();
}

uint64_t sub_100549F5C(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_1019CC988)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_100549F9C()
{
  return &off_1019CC988;
}

uint64_t sub_100549FA8(uint64_t a1)
{
  return a1;
}

void sub_100549FD4(uint64_t a1)
{
  operator delete();
}

void *sub_10054A020(uint64_t a1)
{
  uint64_t v2 = operator new(0x18uLL);
  uint64_t v4 = *(void *)(a1 + 8);
  id v3 = *(void **)(a1 + 16);
  void *v2 = off_1019E2770;
  v2[1] = v4;
  void v2[2] = objc_retainBlock(v3);
  return v2;
}

id sub_10054A078(uint64_t a1, void *a2)
{
  uint64_t v4 = *(void *)(a1 + 8);
  id v3 = *(void **)(a1 + 16);
  *a2 = off_1019E2770;
  a2[1] = v4;
  id result = objc_retainBlock(v3);
  a2[2] = result;
  return result;
}

void sub_10054A0C0(uint64_t a1)
{
}

void sub_10054A0C8(id *a1)
{
  operator delete(a1);
}

void sub_10054A104(uint64_t a1, uint64_t a2, uint64_t a3, unsigned char *a4)
{
  *(_OWORD *)char v16 = *(_OWORD *)a2;
  uint64_t v17 = *(void *)(a2 + 16);
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  *(void *)a2 = 0;
  *(_OWORD *)std::string __p = *(_OWORD *)a3;
  uint64_t v15 = *(void *)(a3 + 16);
  *(void *)(a3 + 8) = 0;
  *(void *)(a3 + 16) = 0;
  *(void *)a3 = 0;
  if (*a4)
  {
    uint64_t v5 = *(void *)(a1 + 16);
    int v6 = sub_1003DF5C4(*a4);
    (*(void (**)(uint64_t, void, void *))(v5 + 16))(v5, 0, v6);
  }
  else
  {
    uint64_t v7 = *(void *)(a1 + 8);
    if (v7)
    {
      if ((v7 & 2) == 0)
      {
        if (SHIBYTE(v15) < 0)
        {
          *(unsigned char *)__p[0] = 0;
          __p[1] = 0;
        }
        else
        {
          LOBYTE(__p[0]) = 0;
          HIBYTE(v15) = 0;
        }
      }
    }
    else if (SHIBYTE(v17) < 0)
    {
      *(unsigned char *)v16[0] = 0;
      v16[1] = 0;
    }
    else
    {
      LOBYTE(v16[0]) = 0;
      HIBYTE(v17) = 0;
    }
    id v8 = objc_alloc((Class)CTDeviceIdentifier);
    if (v17 >= 0) {
      uint64_t v9 = v16;
    }
    else {
      uint64_t v9 = (void **)v16[0];
    }
    uint64_t v10 = +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v9, __p[0], __p[1], v15);
    if (v15 >= 0) {
      id v11 = __p;
    }
    else {
      id v11 = (void **)__p[0];
    }
    __int16 v12 = +[NSString stringWithUTF8String:v11];
    id v13 = [v8 initWithDeviceType:2 EID:v10 IMEI:v12 idsDeviceId:0];

    (*(void (**)(void))(*(void *)(a1 + 16) + 16))();
    int v6 = v13;
  }

  if (SHIBYTE(v15) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v17) < 0) {
    operator delete(v16[0]);
  }
}

void sub_10054A2A8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a21 < 0) {
    operator delete(a16);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_10054A2FC(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_1019E27E0)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_10054A33C()
{
  return &off_1019E27E0;
}

uint64_t sub_10054A348(uint64_t a1)
{
  return a1;
}

void sub_10054A374(uint64_t a1)
{
  operator delete();
}

void *sub_10054A3C0(uint64_t a1)
{
  uint64_t v2 = operator new(0x10uLL);
  void *v2 = off_1019E2800;
  v2[1] = objc_retainBlock(*(id *)(a1 + 8));
  return v2;
}

id sub_10054A418(uint64_t a1, void *a2)
{
  *a2 = off_1019E2800;
  id result = objc_retainBlock(*(id *)(a1 + 8));
  a2[1] = result;
  return result;
}

void sub_10054A460(uint64_t a1)
{
}

void sub_10054A468(id *a1)
{
  operator delete(a1);
}

uint64_t sub_10054A4A4(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 8) + 16))();
}

uint64_t sub_10054A4B8(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_1019E2860)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_10054A4F8()
{
  return &off_1019E2860;
}

void sub_10054A504()
{
}

uint64_t sub_10054A52C(uint64_t a1)
{
  return a1;
}

void sub_10054A558(unint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  os_unfair_lock_lock((os_unfair_lock_t)&unk_101B13DB0);
  uint64_t v4 = qword_101B13DC0;
  if (!qword_101B13DC0) {
    goto LABEL_12;
  }
  uint64_t v5 = &qword_101B13DC0;
  do
  {
    unint64_t v6 = *(void *)(v4 + 32);
    BOOL v7 = v6 >= a1;
    if (v6 >= a1) {
      id v8 = (uint64_t *)v4;
    }
    else {
      id v8 = (uint64_t *)(v4 + 8);
    }
    if (v7) {
      uint64_t v5 = (uint64_t *)v4;
    }
    uint64_t v4 = *v8;
  }
  while (*v8);
  if (v5 != &qword_101B13DC0 && v5[4] <= a1)
  {
    uint64_t v10 = v5[5];
    uint64_t v9 = v5[6];
    *a2 = v10;
    a2[1] = v9;
    if (v9) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v9 + 16), 1uLL, memory_order_relaxed);
    }
  }
  else
  {
LABEL_12:
    *a2 = 0;
    a2[1] = 0;
  }

  os_unfair_lock_unlock((os_unfair_lock_t)&unk_101B13DB0);
}

void *sub_10054A608@<X0>(uint64_t *a1@<X1>, void *a2@<X8>)
{
  uint64_t v4 = operator new(0x20uLL);
  id result = sub_10054A664(v4, a1);
  *a2 = v4 + 3;
  a2[1] = v4;
  return result;
}

void sub_10054A650(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_10054A664(void *a1, uint64_t *a2)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = off_1019E2880;
  sub_10054A83C((unint64_t)(a1 + 3), a2);
  return a1;
}

void sub_10054A6AC(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void sub_10054A6C0(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1019E2880;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_10054A6E0(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1019E2880;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_10054A734(uint64_t a1)
{
  os_unfair_lock_lock((os_unfair_lock_t)&unk_101B13DB0);
  if (qword_101B13DC0)
  {
    unint64_t v2 = a1 + 24;
    id v3 = &qword_101B13DC0;
    uint64_t v4 = qword_101B13DC0;
    do
    {
      unint64_t v5 = *(void *)(v4 + 32);
      BOOL v6 = v5 >= v2;
      if (v5 >= v2) {
        BOOL v7 = (uint64_t *)v4;
      }
      else {
        BOOL v7 = (uint64_t *)(v4 + 8);
      }
      if (v6) {
        id v3 = (uint64_t *)v4;
      }
      uint64_t v4 = *v7;
    }
    while (*v7);
    if (v3 != &qword_101B13DC0 && v3[4] <= v2)
    {
      id v8 = (uint64_t *)v3[1];
      if (v8)
      {
        do
        {
          uint64_t v9 = v8;
          id v8 = (uint64_t *)*v8;
        }
        while (v8);
      }
      else
      {
        uint64_t v10 = v3;
        do
        {
          uint64_t v9 = (uint64_t *)v10[2];
          BOOL v11 = *v9 == (void)v10;
          uint64_t v10 = v9;
        }
        while (!v11);
      }
      if ((uint64_t *)qword_101B13DB8 == v3) {
        qword_101B13DB8 = (uint64_t)v9;
      }
      --qword_101B13DC8;
      sub_10005EE6C((uint64_t *)qword_101B13DC0, v3);
      __int16 v12 = (std::__shared_weak_count *)v3[6];
      if (v12) {
        std::__shared_weak_count::__release_weak(v12);
      }
      operator delete(v3);
    }
  }

  os_unfair_lock_unlock((os_unfair_lock_t)&unk_101B13DB0);
}

unint64_t sub_10054A83C(unint64_t a1, uint64_t *a2)
{
  os_unfair_lock_lock((os_unfair_lock_t)&unk_101B13DB0);
  uint64_t v5 = *a2;
  uint64_t v4 = a2[1];
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 16), 1uLL, memory_order_relaxed);
  }
  uint64_t v6 = qword_101B13DC0;
  if (qword_101B13DC0)
  {
    while (1)
    {
      while (1)
      {
        BOOL v7 = (uint64_t *)v6;
        unint64_t v8 = *(void *)(v6 + 32);
        if (v8 <= a1) {
          break;
        }
        uint64_t v6 = *v7;
        uint64_t v9 = v7;
        if (!*v7) {
          goto LABEL_11;
        }
      }
      if (v8 >= a1) {
        break;
      }
      uint64_t v6 = v7[1];
      if (!v6)
      {
        uint64_t v9 = v7 + 1;
        goto LABEL_11;
      }
    }
    uint64_t v10 = v7;
  }
  else
  {
    uint64_t v9 = &qword_101B13DC0;
    BOOL v7 = &qword_101B13DC0;
LABEL_11:
    uint64_t v10 = (uint64_t *)operator new(0x38uLL);
    v10[5] = 0;
    v10[6] = 0;
    v10[4] = a1;
    uint64_t *v10 = 0;
    v10[1] = 0;
    void v10[2] = (uint64_t)v7;
    *uint64_t v9 = (uint64_t)v10;
    BOOL v11 = v10;
    if (*(void *)qword_101B13DB8)
    {
      qword_101B13DB8 = *(void *)qword_101B13DB8;
      BOOL v11 = (uint64_t *)*v9;
    }
    sub_100046C90((uint64_t *)qword_101B13DC0, v11);
    ++qword_101B13DC8;
  }
  __int16 v12 = (std::__shared_weak_count *)v10[6];
  v10[5] = v5;
  v10[6] = v4;
  if (v12) {
    std::__shared_weak_count::__release_weak(v12);
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&unk_101B13DB0);
  return a1;
}

void sub_10054A95C(_Unwind_Exception *a1)
{
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&unk_101B13DB0);
  _Unwind_Resume(a1);
}

uint64_t sub_10054A980()
{
  qword_101B13DC8 = 0;
  qword_101B13DC0 = 0;
  qword_101B13DB8 = (uint64_t)&qword_101B13DC0;
  return __cxa_atexit((void (*)(void *))sub_10054A52C, &qword_101B13DB8, (void *)&_mh_execute_header);
}

const char *sub_10054A9B4(int a1)
{
  uint64_t v1 = "wea.gfm.?";
  if (a1 == 2) {
    uint64_t v1 = "wea.2";
  }
  if (a1 == 1) {
    return "wea.1";
  }
  else {
    return v1;
  }
}

void WeaGeofenceManager::create(Registry **a1@<X0>, uint64_t *a2@<X1>, NSObject **a3@<X2>, uint64_t *a4@<X3>, uint64_t *a5@<X4>, void *a6@<X8>)
{
  *a6 = 0;
  a6[1] = 0;
  uint64_t v12 = *a2;
  BOOL v11 = (std::__shared_weak_count *)a2[1];
  id v13 = (char *)operator new(0xD8uLL);
  *((void *)v13 + 1) = 0;
  *((void *)v13 + 2) = 0;
  *(void *)id v13 = off_1019E2B00;
  if (v11) {
    atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v36 = v11;
  id v14 = *a3;
  if (v14) {
    dispatch_retain(v14);
  }
  uint64_t v33 = *a4;
  *a4 = 0;
  uint64_t v15 = *a5;
  char v16 = (std::__shared_weak_count *)a5[1];
  uint64_t v35 = v15;
  if (v16) {
    atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  *((void *)v13 + 3) = off_1019E28D0;
  if (v14) {
    dispatch_retain(v14);
  }
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v43, kCtLoggingSystemName, "wea");
  uint64_t v34 = v13 + 24;
  if (v14)
  {
    dispatch_retain(v14);
    uint64_t v17 = dispatch_queue_attr_make_with_qos_class(0, QOS_CLASS_USER_INITIATED, 0);
    dispatch_retain(v14);
    dispatch_retain(v14);
    id v18 = dispatch_queue_create_with_target_V2("WeaLocationManager", v17, v14);
  }
  else
  {
    NSStringEncoding v19 = dispatch_queue_attr_make_with_qos_class(0, QOS_CLASS_USER_INITIATED, 0);
    id v18 = dispatch_queue_create("WeaLocationManager", v19);
  }
  char v20 = v18;
  *((void *)v13 + 4) = 0;
  *((void *)v13 + 5) = 0;
  *((void *)v13 + 6) = v18;
  if (v18) {
    dispatch_retain(v18);
  }
  *((void *)v13 + 7) = v14;
  if (v14) {
    dispatch_retain(v14);
  }
  if (v20) {
    dispatch_release(v20);
  }
  if (v14)
  {
    dispatch_release(v14);
    dispatch_release(v14);
    dispatch_release(v14);
  }
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v42, &v43);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(v13 + 64), (const ctu::OsLogLogger *)v42);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v42);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v43);
  if (v14) {
    dispatch_release(v14);
  }
  v42[0] = off_101999E18;
  v42[1] = sub_10054A9B4;
  v42[3] = v42;
  *((void *)v13 + 9) = 0;
  if ((capabilities::ct::supportsGemini(v21) & 1) == 0) {
    operator new();
  }
  if (!*((void *)v13 + 9)) {
    operator new();
  }
  sub_10008863C(v42);
  *((void *)v13 + 3) = off_1019E28D0;
  uint64_t v22 = a1[1];
  *((void *)v13 + 10) = *a1;
  *((void *)v13 + 11) = v22;
  if (v22) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)v22 + 1, 1uLL, memory_order_relaxed);
  }
  sub_100058DB0(&v43, "WeaLocationManager");
  char v23 = *((void *)v13 + 6);
  uint64_t v38 = v23;
  if (v23) {
    dispatch_retain(v23);
  }
  uint64_t v24 = *((void *)v13 + 7);
  dispatch_object_t object = v24;
  if (v24) {
    dispatch_retain(v24);
  }
  ctu::RestModule::RestModule();
  if (object) {
    dispatch_release(object);
  }
  if (v38) {
    dispatch_release(v38);
  }
  if (v44 < 0) {
    operator delete(v43.var0);
  }
  char v25 = a1;
  *((void *)v13 + 14) = v12;
  *((void *)v13 + 15) = v36;
  if (v36) {
    atomic_fetch_add_explicit(&v36->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v27 = *((void *)v13 + 10);
  uint64_t v26 = (std::__shared_weak_count *)*((void *)v13 + 11);
  id v28 = operator new(0x60uLL);
  uint64_t v29 = v28;
  v28[1] = 0;
  v28[2] = 0;
  *id v28 = off_1019E2AB0;
  uint64_t v30 = v28 + 3;
  uint64_t v40 = v27;
  long long v41 = v26;
  if (v26) {
    atomic_fetch_add_explicit(&v26->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  v39[0] = v35;
  v39[1] = v16;
  if (v16) {
    atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  sub_101216E2C((ctu::OsLogLogger *)(v28 + 3), &v40, (NSObject **)v13 + 6, v39);
  if (v16) {
    sub_10004D2C8(v16);
  }
  if (v26) {
    sub_10004D2C8(v26);
  }
  *((void *)v13 + 16) = v30;
  *((void *)v13 + 17) = v29;
  *((void *)v13 + 18) = v33;
  long long v31 = (std::__shared_weak_count *)*((void *)v13 + 11);
  uint64_t v40 = *((void *)v13 + 10);
  long long v41 = v31;
  if (v31) {
    atomic_fetch_add_explicit(&v31->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  (*(void (**)(uint64_t, uint64_t *, char *))(*(void *)v33 + 16))(v33, &v40, v13 + 48);
  if (v41) {
    sub_10004D2C8(v41);
  }
  v13[168] = 0;
  sub_100136414((uint64_t *)v13 + 22, (uint64_t)&rest::kDefaultRadioAccessTechnologies);
  *((void *)v13 + 25) = v35;
  *((void *)v13 + 26) = v16;
  if (v16) {
    atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (!*((void *)v13 + 14)) {
    __TUAssertTrigger();
  }
  if (v16) {
    sub_10004D2C8(v16);
  }
  if (v14) {
    dispatch_release(v14);
  }
  if (v36) {
    sub_10004D2C8(v36);
  }
  *a6 = v34;
  a6[1] = v13;
  uint64_t v32 = (std::__shared_weak_count *)*((void *)v13 + 5);
  if (v32)
  {
    if (v32->__shared_owners_ != -1) {
      goto LABEL_67;
    }
    atomic_fetch_add_explicit((atomic_ullong *volatile)v13 + 1, 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit((atomic_ullong *volatile)v13 + 2, 1uLL, memory_order_relaxed);
    *((void *)v13 + 4) = v34;
    *((void *)v13 + 5) = v13;
    std::__shared_weak_count::__release_weak(v32);
  }
  else
  {
    atomic_fetch_add_explicit((atomic_ullong *volatile)v13 + 1, 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit((atomic_ullong *volatile)v13 + 2, 1uLL, memory_order_relaxed);
    *((void *)v13 + 4) = v34;
    *((void *)v13 + 5) = v13;
  }
  sub_10004D2C8((std::__shared_weak_count *)v13);
LABEL_67:
  v43.var0 = 0;
  v43.var1.fRef = 0;
  Registry::getServiceManager((uint64_t *)&v43, *v25);
  if (v43.var0)
  {
    atomic_fetch_add_explicit((atomic_ullong *volatile)v13 + 1, 1uLL, memory_order_relaxed);
    operator new();
  }
  if (v43.var1.fRef) {
    sub_10004D2C8((std::__shared_weak_count *)v43.var1.fRef);
  }
}

void sub_10054B070(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, ctu::OsLogLogger *a10, uint64_t a11, uint64_t a12, uint64_t a13, WeaGeofenceManagerInterface *a14, uint64_t a15, uint64_t a16, dispatch_object_t object, dispatch_object_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23)
{
  sub_10008863C((void *)(v23 - 128));
  operator delete();
}

void sub_10054B308(uint64_t a1, uint64_t a2, uint64_t a3, void *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, ...)
{
  va_start(va, a14);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)va);
  sub_100087E88(a4);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)(v15 - 128));
  if (v14) {
    dispatch_release(v14);
  }
  JUMPOUT(0x10054B29CLL);
}

uint64_t sub_10054B344(void *a1)
{
  uint64_t v2 = a1[16];
  if (!v2)
  {
    uint64_t v3 = a1[15];
    uint64_t v4 = (std::__shared_weak_count *)a1[8];
    uint64_t v9 = v4;
    if (v4) {
      atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    (*(void (**)(long long *__return_ptr))(*(void *)v3 + 16))(&v10);
    long long v5 = v10;
    long long v10 = 0uLL;
    uint64_t v6 = (std::__shared_weak_count *)a1[17];
    *((_OWORD *)a1 + 8) = v5;
    if (v6)
    {
      sub_10004D2C8(v6);
      if (*((void *)&v10 + 1)) {
        sub_10004D2C8(*((std::__shared_weak_count **)&v10 + 1));
      }
    }
    if (v9) {
      sub_10004D2C8(v9);
    }
    uint64_t v2 = a1[16];
  }
  uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)v2 + 16))(v2);
  if ((result & 1) == 0)
  {
    (*(void (**)(void))(*(void *)a1[16] + 48))(a1[16]);
    unint64_t v8 = (std::__shared_weak_count *)a1[2];
    if (v8)
    {
      if (std::__shared_weak_count::lock(v8)) {
        operator new();
      }
    }
    sub_100088B9C();
  }
  return result;
}

void sub_10054B4F8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_10054B518(uint64_t a1, dispatch_object_t object)
{
  if (object)
  {
    dispatch_retain(object);
    dispatch_group_enter(object);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_10054B618(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 8);
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (v3)
  {
    if (std::__shared_weak_count::lock(v3)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_10054B734(uint64_t a1, uint64_t *a2)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 56));
  long long v5 = ServiceMap;
  if (v6 < 0)
  {
    BOOL v7 = (unsigned __int8 *)(v6 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v8 = 5381;
    do
    {
      uint64_t v6 = v8;
      unsigned int v9 = *v7++;
      uint64_t v8 = (33 * v8) ^ v9;
    }
    while (v9);
  }
  std::mutex::lock(ServiceMap);
  __p[0] = (void *)v6;
  long long v10 = sub_10004D37C(&v5[1].__m_.__sig, (unint64_t *)__p);
  if (v10)
  {
    uint64_t v12 = v10[3];
    BOOL v11 = (std::__shared_weak_count *)v10[4];
    if (v11)
    {
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v5);
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v11);
      char v13 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v12 = 0;
  }
  std::mutex::unlock(v5);
  BOOL v11 = 0;
  char v13 = 1;
LABEL_9:
  id v14 = *(NSObject **)(a1 + 40);
  if (v12)
  {
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      sub_1010DDA90(__p);
      uint64_t v15 = v20 >= 0 ? __p : (void **)__p[0];
      *(_DWORD *)long long buf = 136446210;
      uint64_t v22 = v15;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I %{public}s Wea dispatched. Geofencing done: true", buf, 0xCu);
      if (v20 < 0) {
        operator delete(__p[0]);
      }
    }
    char v16 = (std::__shared_weak_count *)a2[1];
    uint64_t v17 = *a2;
    id v18 = v16;
    if (v16) {
      atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    (*(void (**)(uint64_t, uint64_t *))(*(void *)v12 + 408))(v12, &v17);
    if (v18)
    {
      sub_10004D2C8(v18);
      if (v13) {
        return;
      }
      goto LABEL_23;
    }
LABEL_22:
    if (v13) {
      return;
    }
    goto LABEL_23;
  }
  if (!os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)) {
    goto LABEL_22;
  }
  LOWORD(__p[0]) = 0;
  _os_log_error_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "Failed to get Sms controller interface", (uint8_t *)__p, 2u);
  if (v13) {
    return;
  }
LABEL_23:
  sub_10004D2C8(v11);
}

void sub_10054B960(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if ((v11 & 1) == 0) {
    sub_10004D2C8(v10);
  }
  _Unwind_Resume(exception_object);
}

void sub_10054B9A0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(a3 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (v3)
  {
    if (std::__shared_weak_count::lock(v3)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_10054BAC0(uint64_t *a1)
{
  char v13 = 0;
  id v14 = 0;
  uint64_t v15 = 0;
  sub_1012191D8(a1[13], (uint64_t)&v13);
  uint64_t v2 = v13;
  uint64_t v3 = v14;
  if (v13 == v14)
  {
    long long v5 = v13;
  }
  else
  {
    do
    {
      uint64_t v4 = *(std::__shared_weak_count **)(*(void *)v2 + 72);
      uint64_t v11 = *(void *)(*(void *)v2 + 64);
      uint64_t v12 = v4;
      if (v4) {
        atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      (*(void (**)(uint64_t *, uint64_t *))(*a1 + 128))(a1, &v11);
      if (v12) {
        sub_10004D2C8(v12);
      }
      v2 += 16;
    }
    while (v2 != v3);
    long long v5 = v13;
    uint64_t v2 = v14;
  }
  uint64_t v8 = 0;
  unsigned int v9 = 0;
  uint64_t v10 = 0;
  sub_10054D830(&v8, v5, v2, (v2 - v5) >> 4);
  uint64_t v6 = v8;
  BOOL v7 = v9;
  while (v6 != v7)
  {
    sub_100926BDC(*v6);
    v6 += 2;
  }
  char v16 = (char **)&v8;
  sub_10005CBF0((void ***)&v16);
  char v16 = &v13;
  sub_10005CBF0((void ***)&v16);
}

void sub_10054BBD4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15)
{
  *(void *)(v15 - 40) = &a15;
  sub_10005CBF0((void ***)(v15 - 40));
  _Unwind_Resume(a1);
}

uint64_t sub_10054BC1C(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = operator new(0x18uLL);
  id v14 = v4 + 3;
  uint64_t v15 = (char *)(v4 + 3);
  *(_OWORD *)uint64_t v4 = *(_OWORD *)off_1019E2980;
  _OWORD v4[2] = @"FeatureEnabled";
  uint64_t v12 = 0;
  std::string __p = v4;
  sub_1007EC3B4(*(Registry ***)(a1 + 176), a2, 2, (uint64_t)&__p, (uint64_t)kCFBooleanFalse, 0, buf);
  sub_1000057AC(&v12, (CFTypeRef *)buf);
  sub_1000577C4((const void **)buf);
  buf[0] = 0;
  ctu::cf::assign((ctu::cf *)buf, v12, v5);
  int v6 = buf[0];
  unsigned int v7 = (*(uint64_t (**)(void))(**(void **)(a1 + 88) + 16))(*(void *)(a1 + 88));
  uint64_t v8 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    unsigned int v9 = "false";
    if (v6) {
      uint64_t v10 = "true";
    }
    else {
      uint64_t v10 = "false";
    }
    if (v7) {
      unsigned int v9 = "true";
    }
    *(_DWORD *)long long buf = 136315394;
    uint64_t v17 = v10;
    __int16 v18 = 2080;
    NSStringEncoding v19 = v9;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Geofence supported: %s Location services enabled: %s", buf, 0x16u);
  }
  sub_100062778((const void **)&v12);
  if (__p)
  {
    id v14 = __p;
    operator delete(__p);
  }
  if (v6) {
    return v7;
  }
  else {
    return 0;
  }
}

void sub_10054BDE4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, char a13)
{
  if (__p)
  {
    a11 = (uint64_t)__p;
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_10054BE28(uint64_t a1)
{
  uint64_t v2 = (*(uint64_t (**)(void))(**(void **)(a1 + 88) + 24))(*(void *)(a1 + 88));
  uint64_t v3 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v4 = "false";
    if (v2) {
      uint64_t v4 = "true";
    }
    int v6 = 136315138;
    unsigned int v7 = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Circular Geofence Supported: %s", (uint8_t *)&v6, 0xCu);
  }
  return v2;
}

uint64_t sub_10054BF0C(uint64_t a1)
{
  uint64_t v2 = (*(uint64_t (**)(void))(**(void **)(a1 + 88) + 32))(*(void *)(a1 + 88));
  uint64_t v3 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v4 = "false";
    if (v2) {
      uint64_t v4 = "true";
    }
    int v6 = 136315138;
    unsigned int v7 = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Polygonal Geofence Supported: %s", (uint8_t *)&v6, 0xCu);
  }
  return v2;
}

void sub_10054BFF0(uint64_t *a1)
{
  id v14 = 0;
  uint64_t v15 = 0;
  uint64_t v16 = 0;
  sub_101219784(a1[13], (unint64_t *)&v14);
  uint64_t v2 = v14;
  for (uint64_t i = v15; v2 != i; v2 += 2)
  {
    uint64_t v4 = a1[5];
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      sub_1010DDA90(__p);
      CFBooleanRef v5 = v13 >= 0 ? __p : (void **)__p[0];
      *(_DWORD *)long long buf = 136446210;
      __int16 v18 = v5;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I %{public}s will be dispatched, as Monitoring failed...", buf, 0xCu);
      if (v13 < 0) {
        operator delete(__p[0]);
      }
    }
    uint64_t v10 = *v2;
    int v6 = (std::__shared_weak_count *)v2[1];
    uint64_t v11 = v6;
    if (v6) {
      atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    (*(void (**)(uint64_t *, uint64_t *))(*a1 + 128))(a1, &v10);
    if (v11) {
      sub_10004D2C8(v11);
    }
    uint64_t v7 = a1[13];
    uint64_t v8 = (std::__shared_weak_count *)v2[1];
    v9[0] = *v2;
    v9[1] = v8;
    if (v8) {
      atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    sub_101219648(v7, (uint64_t)v9);
    if (v8) {
      sub_10004D2C8(v8);
    }
  }
  sub_10054BAC0(a1);
  __p[0] = &v14;
  sub_10005CBF0((void ***)__p);
}

void sub_10054C1AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void **a15, uint64_t a16, uint64_t a17, char a18)
{
  a15 = (void **)&a18;
  sub_10005CBF0(&a15);
  _Unwind_Resume(a1);
}

void sub_10054C1F8(uint64_t *a1)
{
  id v14 = 0;
  uint64_t v15 = 0;
  uint64_t v16 = 0;
  sub_101219784(a1[13], (unint64_t *)&v14);
  uint64_t v2 = v14;
  for (uint64_t i = v15; v2 != i; v2 += 2)
  {
    uint64_t v4 = a1[5];
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      sub_1010DDA90(__p);
      CFBooleanRef v5 = v13 >= 0 ? __p : (void **)__p[0];
      *(_DWORD *)long long buf = 136446210;
      __int16 v18 = v5;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I %{public}s will be dispatched, as device is OOS...", buf, 0xCu);
      if (v13 < 0) {
        operator delete(__p[0]);
      }
    }
    uint64_t v10 = *v2;
    int v6 = (std::__shared_weak_count *)v2[1];
    uint64_t v11 = v6;
    if (v6) {
      atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    (*(void (**)(uint64_t *, uint64_t *))(*a1 + 128))(a1, &v10);
    if (v11) {
      sub_10004D2C8(v11);
    }
    uint64_t v7 = a1[13];
    uint64_t v8 = (std::__shared_weak_count *)v2[1];
    v9[0] = *v2;
    v9[1] = v8;
    if (v8) {
      atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    sub_101219648(v7, (uint64_t)v9);
    if (v8) {
      sub_10004D2C8(v8);
    }
  }
  sub_10054BAC0(a1);
  __p[0] = &v14;
  sub_10005CBF0((void ***)__p);
}

void sub_10054C3B4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void **a15, uint64_t a16, uint64_t a17, char a18)
{
  a15 = (void **)&a18;
  sub_10005CBF0(&a15);
  _Unwind_Resume(a1);
}

void sub_10054C400(void *a1)
{
  __int16 v18 = 0;
  NSStringEncoding v19 = 0;
  uint64_t v20 = 0;
  sub_101219784(a1[13], (unint64_t *)&v18);
  uint64_t v2 = v18;
  uint64_t v3 = v19;
  if (v18 != v19)
  {
    do
    {
      uint64_t v5 = *v2;
      uint64_t v4 = (std::__shared_weak_count *)v2[1];
      if (v4) {
        atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      int v6 = a1[5];
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        sub_1010DDA90(__p);
        uint64_t v7 = v17 >= 0 ? __p : (void **)__p[0];
        *(_DWORD *)long long buf = 136446210;
        uint64_t v22 = v7;
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I %{public}s will be dispatched, as Location is disabled...", buf, 0xCu);
        if (v17 < 0) {
          operator delete(__p[0]);
        }
      }
      uint64_t v14 = v5;
      uint64_t v15 = v4;
      if (v4) {
        atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      (*(void (**)(void *, uint64_t *))(*a1 + 128))(a1, &v14);
      if (v15) {
        sub_10004D2C8(v15);
      }
      if (v4) {
        sub_10004D2C8(v4);
      }
      v2 += 2;
    }
    while (v2 != v3);
    uint64_t v8 = v18;
    for (uint64_t i = v19; v8 != i; v8 += 2)
    {
      uint64_t v10 = *v8;
      uint64_t v11 = (std::__shared_weak_count *)v8[1];
      if (v11)
      {
        atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
        uint64_t v12 = a1[13];
        atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      else
      {
        uint64_t v12 = a1[13];
      }
      v13[0] = v10;
      v13[1] = v11;
      sub_101219648(v12, (uint64_t)v13);
      if (v11)
      {
        sub_10004D2C8(v11);
        sub_10004D2C8(v11);
      }
    }
  }
  __p[0] = &v18;
  sub_10005CBF0((void ***)__p);
}

void sub_10054C5FC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18)
{
}

void sub_10054C654(uint64_t *a1, void **a2)
{
  uint64_t v4 = a1[5];
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = a2;
    if (*((char *)a2 + 23) < 0) {
      uint64_t v5 = *a2;
    }
    *(_DWORD *)long long buf = 136446210;
    uint64_t v10 = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I geofenceSetupError: %{public}s", buf, 0xCu);
  }
  uint64_t v6 = a1[13];
  if (*((char *)a2 + 23) < 0)
  {
    sub_10004FC84(__p, *a2, (unint64_t)a2[1]);
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)a2;
    uint64_t v8 = a2[2];
  }
  sub_101219DEC(v6, __p);
  if (SHIBYTE(v8) < 0) {
    operator delete(__p[0]);
  }
  sub_10054BAC0(a1);
}

void sub_10054C75C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_10054C780(uint64_t a1, void **a2)
{
  uint64_t v4 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = a2;
    if (*((char *)a2 + 23) < 0) {
      uint64_t v5 = *a2;
    }
    *(_DWORD *)long long buf = 136446210;
    uint64_t v10 = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Monitoring started for : %{public}s", buf, 0xCu);
  }
  uint64_t v6 = *(void *)(a1 + 104);
  if (*((char *)a2 + 23) < 0)
  {
    sub_10004FC84(__p, *a2, (unint64_t)a2[1]);
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)a2;
    uint64_t v8 = a2[2];
  }
  sub_101219B80(v6, __p);
  if (SHIBYTE(v8) < 0) {
    operator delete(__p[0]);
  }
}

void sub_10054C880(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
}

void sub_10054C8A4(uint64_t *a1, void **a2)
{
  uint64_t v4 = a1[5];
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = a2;
    if (*((char *)a2 + 23) < 0) {
      uint64_t v5 = *a2;
    }
    *(_DWORD *)long long buf = 136446210;
    uint64_t v10 = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Monitoring Failed for: %{public}s", buf, 0xCu);
  }
  uint64_t v6 = a1[13];
  if (*((char *)a2 + 23) < 0)
  {
    sub_10004FC84(__p, *a2, (unint64_t)a2[1]);
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)a2;
    uint64_t v8 = a2[2];
  }
  sub_10121A274(v6, (uint64_t *)__p);
  if (SHIBYTE(v8) < 0) {
    operator delete(__p[0]);
  }
  sub_10054BAC0(a1);
}

void sub_10054C9AC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_10054C9D0(uint64_t *a1, void **a2, unsigned int a3)
{
  uint64_t v6 = a1[5];
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v7 = a2;
    if (*((char *)a2 + 23) < 0) {
      uint64_t v7 = *a2;
    }
    if (a3 > 3) {
      uint64_t v8 = "???";
    }
    else {
      uint64_t v8 = off_1019E2CC0[a3];
    }
    *(_DWORD *)long long buf = 136446466;
    char v13 = v7;
    __int16 v14 = 2082;
    uint64_t v15 = v8;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I State determined for %{public}s - %{public}s", buf, 0x16u);
  }
  uint64_t v9 = a1[13];
  if (*((char *)a2 + 23) < 0)
  {
    sub_10004FC84(__p, *a2, (unint64_t)a2[1]);
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)a2;
    uint64_t v11 = a2[2];
  }
  sub_10121A6C4(v9, __p, a3);
  if (SHIBYTE(v11) < 0) {
    operator delete(__p[0]);
  }
  if (a3 == 2) {
    sub_10054BAC0(a1);
  }
}

void sub_10054CB14(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
}

void sub_10054CB38(uint64_t *a1, void **a2)
{
  uint64_t v4 = a1[5];
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = a2;
    if (*((char *)a2 + 23) < 0) {
      uint64_t v5 = *a2;
    }
    *(_DWORD *)long long buf = 136446210;
    uint64_t v10 = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Region entered for: %{public}s", buf, 0xCu);
  }
  uint64_t v6 = a1[13];
  if (*((char *)a2 + 23) < 0)
  {
    sub_10004FC84(__p, *a2, (unint64_t)a2[1]);
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)a2;
    uint64_t v8 = a2[2];
  }
  sub_10121A938(v6, __p);
  if (SHIBYTE(v8) < 0) {
    operator delete(__p[0]);
  }
  sub_10054BAC0(a1);
}

void sub_10054CC40(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_10054CC64(uint64_t a1, void **a2)
{
  uint64_t v4 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = a2;
    if (*((char *)a2 + 23) < 0) {
      uint64_t v5 = *a2;
    }
    *(_DWORD *)long long buf = 136446210;
    uint64_t v10 = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Region exited for: %{public}s", buf, 0xCu);
  }
  uint64_t v6 = *(void *)(a1 + 104);
  if (*((char *)a2 + 23) < 0)
  {
    sub_10004FC84(__p, *a2, (unint64_t)a2[1]);
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)a2;
    uint64_t v8 = a2[2];
  }
  sub_10121ABA4(v6, __p);
  if (SHIBYTE(v8) < 0) {
    operator delete(__p[0]);
  }
}

void sub_10054CD64(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
}

void sub_10054CD88(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = *a2;
  uint64_t v3 = *(NSObject **)(a1 + 40);
  if (*a2)
  {
    if (os_log_type_enabled(*(os_log_t *)(a1 + 40), OS_LOG_TYPE_DEFAULT))
    {
      sub_1010DDA90(__p);
      if (v15 >= 0) {
        uint64_t v6 = __p;
      }
      else {
        uint64_t v6 = (void **)__p[0];
      }
      *(_DWORD *)long long buf = 136446210;
      char v17 = v6;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I %{public}s Mwt expiry procedure", buf, 0xCu);
      if (v15 < 0) {
        operator delete(__p[0]);
      }
      uint64_t v2 = *a2;
    }
    uint64_t v7 = (std::__shared_weak_count *)a2[1];
    uint64_t v12 = v2;
    char v13 = v7;
    if (v7) {
      atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    (*(void (**)(uint64_t, uint64_t *))(*(void *)a1 + 128))(a1, &v12);
    if (v13) {
      sub_10004D2C8(v13);
    }
    uint64_t v8 = *(void *)(a1 + 104);
    uint64_t v9 = *a2;
    uint64_t v10 = (std::__shared_weak_count *)a2[1];
    v11[0] = v9;
    v11[1] = v10;
    if (v10) {
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    sub_101219648(v8, (uint64_t)v11);
    if (v10) {
      sub_10004D2C8(v10);
    }
  }
  else if (os_log_type_enabled(*(os_log_t *)(a1 + 40), OS_LOG_TYPE_ERROR))
  {
    LOWORD(__p[0]) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "weaDecoder is null", (uint8_t *)__p, 2u);
  }
}

void sub_10054CF34(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
}

void sub_10054CF64(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = *a2;
  uint64_t v3 = *(NSObject **)(a1 + 40);
  if (*a2)
  {
    if (os_log_type_enabled(*(os_log_t *)(a1 + 40), OS_LOG_TYPE_DEFAULT))
    {
      sub_1010DDA90(__p);
      if (v12 >= 0) {
        uint64_t v6 = __p;
      }
      else {
        uint64_t v6 = (void **)__p[0];
      }
      *(_DWORD *)long long buf = 136446210;
      __int16 v14 = v6;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I %{public}s Geofence Timeout expiry procedure", buf, 0xCu);
      if (v12 < 0) {
        operator delete(__p[0]);
      }
      uint64_t v2 = *a2;
    }
    uint64_t v7 = *(void *)(a1 + 104);
    uint64_t v8 = (std::__shared_weak_count *)a2[1];
    uint64_t v9 = v2;
    uint64_t v10 = v8;
    if (v8) {
      atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    sub_1012192A0(v7, (uint64_t)&v9);
    if (v10) {
      sub_10004D2C8(v10);
    }
  }
  else if (os_log_type_enabled(*(os_log_t *)(a1 + 40), OS_LOG_TYPE_ERROR))
  {
    LOWORD(__p[0]) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "weaDecoder is null", (uint8_t *)__p, 2u);
  }
}

void sub_10054D0C0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
}

BOOL sub_10054D0E0(void *a1, long long *a2)
{
  uint64_t v4 = a1[5];
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Injecting OOS Geofence", buf, 2u);
  }
  uint64_t v8 = a1;
  if (*((char *)a2 + 23) < 0)
  {
    sub_10004FC84(&__p, *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long __p = *a2;
    uint64_t v10 = *((void *)a2 + 2);
  }
  v11[0] = _NSConcreteStackBlock;
  v11[1] = 3221225472;
  void v11[2] = sub_10054E810;
  v11[3] = &unk_10199E4C0;
  void v11[4] = a1 + 1;
  v11[5] = &v8;
  char v12 = objc_retainBlock(v11);
  uint64_t v5 = a1[3];
  if (a1[4])
  {
    unsigned __int8 v19 = 0;
    *(void *)long long buf = _NSConcreteStackBlock;
    uint64_t v14 = 3221225472;
    char v15 = sub_10054EEF8;
    uint64_t v16 = &unk_10199E470;
    char v17 = &v19;
    __int16 v18 = &v12;
    dispatch_async_and_wait(v5, buf);
  }
  else
  {
    unsigned __int8 v19 = 0;
    *(void *)long long buf = _NSConcreteStackBlock;
    uint64_t v14 = 3221225472;
    char v15 = sub_10054EEBC;
    uint64_t v16 = &unk_10199E470;
    char v17 = &v19;
    __int16 v18 = &v12;
    dispatch_sync(v5, buf);
  }
  int v6 = v19;

  if (SHIBYTE(v10) < 0) {
    operator delete((void *)__p);
  }
  return v6 != 0;
}

uint64_t sub_10054D2BC(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 128);
  if (result)
  {
    uint64_t v5 = *(void *)(a1 + 160);
    uint64_t v3 = a1 + 160;
    uint64_t v4 = v5;
    if (v5)
    {
      uint64_t v6 = v3;
      uint64_t v7 = v3;
      uint64_t v8 = v4;
      do
      {
        int v9 = *(_DWORD *)(v8 + 28);
        BOOL v10 = v9 < 1;
        if (v9 >= 1) {
          uint64_t v11 = (uint64_t *)v8;
        }
        else {
          uint64_t v11 = (uint64_t *)(v8 + 8);
        }
        if (!v10) {
          uint64_t v7 = v8;
        }
        uint64_t v8 = *v11;
      }
      while (*v11);
      if (v7 == v3 || *(int *)(v7 + 28) > 1) {
        uint64_t v12 = 11;
      }
      else {
        uint64_t v12 = *(unsigned int *)(v7 + 32);
      }
      do
      {
        int v13 = *(_DWORD *)(v4 + 28);
        BOOL v14 = v13 < 2;
        if (v13 >= 2) {
          char v15 = (uint64_t *)v4;
        }
        else {
          char v15 = (uint64_t *)(v4 + 8);
        }
        if (!v14) {
          uint64_t v6 = v4;
        }
        uint64_t v4 = *v15;
      }
      while (*v15);
      if (v6 != v3 && *(int *)(v6 + 28) <= 2)
      {
        uint64_t v16 = *(unsigned int *)(v6 + 32);
        return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)result + 56))(result, v12, v16);
      }
    }
    else
    {
      uint64_t v12 = 11;
    }
    uint64_t v16 = 11;
    return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)result + 56))(result, v12, v16);
  }
  return result;
}

void (__cdecl ***sub_10054D380(void (__cdecl ***a1)(std::basic_stringstream<char> *__hidden this), const std::string *a2, int a3))(std::basic_stringstream<char> *__hidden this)
{
  uint64_t v6 = a1 + 2;
  uint64_t v7 = (uint64_t)(a1 + 3);
  *a1 = v9;
  *(void *)((char *)*(v9 - 3) + (void)a1) = v8;
  a1[1] = 0;
  BOOL v10 = (std::ios_base *)((char *)*(*a1 - 3) + (void)a1);
  std::ios_base::init(v10, a1 + 3);
  v10[1].__vftable = 0;
  v10[1].__fmtflags_ = -1;
  a1[2] = v12;
  *(void *)((char *)*(v12 - 3) + (void)v6) = v11;
  *a1 = v13;
  sub_1003C0C3C(v7, a2, a3);
  return a1;
}

void sub_10054D61C(_Unwind_Exception *a1)
{
}

void sub_10054D644(void *a1, void *a2)
{
  sub_10054B344(a1);
  if (*a2)
  {
    uint64_t v4 = a2[1];
    if (v4) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
    }
    uint64_t v5 = (std::__shared_weak_count *)a1[2];
    if (v5)
    {
      if (std::__shared_weak_count::lock(v5)) {
        operator new();
      }
    }
    sub_100088B9C();
  }
  uint64_t v6 = a1[5];
  if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "weaDecoder is null", buf, 2u);
  }
}

uint64_t sub_10054D7B4@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(result + 96);
  *a2 = *(void *)(result + 88);
  a2[1] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_10054D7D0@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(result + 136);
  *a2 = *(void *)(result + 128);
  a2[1] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_10054D7EC(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 144);
}

void sub_10054D7F8(uint64_t a1)
{
  sub_10054D8F8(a1);

  operator delete();
}

void *sub_10054D830(void *result, void *a2, void *a3, unint64_t a4)
{
  if (a4)
  {
    uint64_t v4 = result;
    if (a4 >> 60) {
      sub_10006A748();
    }
    uint64_t result = sub_10006A794((uint64_t)(result + 2), a4);
    void *v4 = result;
    v4[1] = result;
    _OWORD v4[2] = &result[2 * v7];
    if (a2 != a3)
    {
      uint64_t v8 = result;
      do
      {
        void *v8 = *a2;
        uint64_t v9 = a2[1];
        v8[1] = v9;
        if (v9) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v9 + 8), 1uLL, memory_order_relaxed);
        }
        result += 2;
        a2 += 2;
        v8 += 2;
      }
      while (a2 != a3);
    }
    v4[1] = result;
  }
  return result;
}

void sub_10054D8E4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
}

uint64_t sub_10054D8F8(uint64_t a1)
{
  *(void *)a1 = off_1019E28D0;
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 184);
  if (v2) {
    sub_10004D2C8(v2);
  }
  sub_1000346F8(a1 + 152, *(void **)(a1 + 160));
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 136);
  if (v3) {
    sub_10004D2C8(v3);
  }
  uint64_t v4 = *(void *)(a1 + 120);
  *(void *)(a1 + 120) = 0;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
  }
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 112);
  if (v5) {
    sub_10004D2C8(v5);
  }
  uint64_t v6 = *(std::__shared_weak_count **)(a1 + 96);
  if (v6) {
    sub_10004D2C8(v6);
  }
  uint64_t v7 = *(std::__shared_weak_count **)(a1 + 80);
  if (v7) {
    sub_10004D2C8(v7);
  }
  uint64_t v8 = *(std::__shared_weak_count **)(a1 + 64);
  if (v8) {
    sub_10004D2C8(v8);
  }
  WeaGeofenceManagerInterface::~WeaGeofenceManagerInterface((WeaGeofenceManagerInterface *)a1);
  uint64_t v9 = *(void *)(a1 + 48);
  *(void *)(a1 + 48) = 0;
  if (v9) {
    (*(void (**)(uint64_t))(*(void *)v9 + 8))(v9);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 40));
  sub_100087E88((void *)(a1 + 8));
  return a1;
}

void sub_10054DA0C()
{
}

uint64_t sub_10054DA20(uint64_t a1)
{
  return *(void *)(a1 + 8) + 40;
}

void sub_10054DA2C(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1019E2AB0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_10054DA4C(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1019E2AB0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_10054DAA0(uint64_t a1)
{
}

void sub_10054DAAC(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1019E2B00;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_10054DACC(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1019E2B00;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_10054DB20(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 24) + 160))();
}

void sub_10054DB48(ServiceManager::Service *this)
{
  *(void *)this = off_1019E2B50;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }

  ServiceManager::Service::~Service(this);
}

void sub_10054DBA4(ServiceManager::Service *this)
{
  *(void *)this = off_1019E2B50;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  ServiceManager::Service::~Service(this);

  operator delete();
}

void *sub_10054DC14@<X0>(void *a1@<X8>)
{
  return sub_100058DB0(a1, "WeaLocationManager");
}

unsigned char *sub_10054DC24@<X0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  uint64_t v2 = operator new(1uLL);
  *a1 = v2;
  unsigned char *v2 = 0;
  uint64_t result = v2 + 1;
  a1[1] = result;
  a1[2] = result;
  return result;
}

void sub_10054DC60(uint64_t a1, dispatch_object_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v3 = *a2;
  if (*a2)
  {
    dispatch_retain(*a2);
    dispatch_group_enter(v3);
    sub_10054B518(v2, v3);
  }
  uint64_t v4 = *(void *)(a1 + 8);

  sub_10054B518(v4, 0);
}

uint64_t sub_10054DCE4()
{
  return 0;
}

uint64_t sub_10054DCEC()
{
  return 1;
}

uint64_t sub_10054DCF4()
{
  return 0;
}

void sub_10054DD00(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(*(void *)(a1 + 8) + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_10054DDE0(uint64_t a1, int a2, ServiceStage *this)
{
  uint64_t v3 = *(void *)(a1 + 8);
  ServiceStage::holdOffStage((uint64_t *)&group[1], this);
  uint64_t v4 = *(std::__shared_weak_count **)(v3 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_10054DEF4(uint64_t **a1)
{
  uint64_t v2 = a1;
  uint64_t v1 = **a1;
  (*(void (**)(void))(**(void **)(v1 + 128) + 64))(*(void *)(v1 + 128));
  sub_10054D2BC(v1);
  operator delete();
}

void sub_10054DF74()
{
}

uint64_t *sub_10054DFA0(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v7 = a1;
  uint64_t v8 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v3 = *(NSObject **)(*(void *)v1 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Bootstrapping...", buf, 2u);
  }
  Registry::createRestModuleOneTimeUseConnection(&v9, *(Registry **)(v2 + 56));
  ctu::RestModule::connect();
  uint64_t v4 = (capabilities::ct *)v10;
  if (v10) {
    sub_10004D2C8(v10);
  }
  if (capabilities::ct::supportsMeadowMode(v4)) {
    sub_10054E158(v2 + 144);
  }
  sub_100058DB0(&__p, "/cc/props/rat");
  uint64_t v5 = operator new(0x28uLL);
  void *v5 = off_1019E2C50;
  v5[1] = v2 + 152;
  v5[2] = v2;
  _OWORD v5[3] = sub_10054D2BC;
  uint64_t v5[4] = 0;
  BOOL v14 = v5;
  ctu::RestModule::observeProperty();
  sub_10003F600(buf);
  if (v12 < 0) {
    operator delete(__p);
  }
  sub_100088C88(&v8);
  return sub_100046B58((uint64_t *)&v7);
}

void sub_10054E100(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19, uint64_t a20)
{
  if (a19 < 0) {
    operator delete(__p);
  }
  sub_100088C88(&a11);
  sub_100046B58(&a10);
  _Unwind_Resume(a1);
}

void sub_10054E158(uint64_t a1)
{
  sub_100058DB0(&__p, "/cc/props/battery_saver_mode");
  v4[0] = off_1019E2BD0;
  v4[1] = a1;
  double v4[3] = v4;
  ctu::RestModule::observeProperty();
  sub_10003F600(v4);
  if (v3 < 0) {
    operator delete(__p);
  }
}

void sub_10054E20C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_10054E23C()
{
}

void *sub_10054E250(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = off_1019E2BD0;
  result[1] = v3;
  return result;
}

uint64_t sub_10054E298(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019E2BD0;
  a2[1] = v2;
  return result;
}

uint64_t sub_10054E2C4(uint64_t a1, xpc *this, BOOL a3)
{
  uint64_t v3 = *(unsigned char **)(a1 + 8);
  uint64_t result = xpc::dyn_cast_or_default(this, 0, a3);
  *uint64_t v3 = result;
  return result;
}

uint64_t sub_10054E2F4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10054E334()
{
}

void sub_10054E344()
{
}

__n128 sub_10054E358(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_1019E2C50;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_10054E3AC(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019E2C50;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_10054E3E4(uint64_t *a1, xpc_object_t *a2)
{
  sub_100026EC0(a1[1], a2);
  uint64_t v3 = (uint64_t (*)(void *))a1[3];
  uint64_t v4 = a1[4];
  uint64_t v5 = (void *)(a1[2] + (v4 >> 1));
  if (v4) {
    uint64_t v3 = *(uint64_t (**)(void *))(*v5 + v3);
  }

  return v3(v5);
}

uint64_t sub_10054E460(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10054E4A0()
{
}

void sub_10054E4AC(uint64_t **a1)
{
  uint64_t v3 = a1;
  uint64_t v1 = **a1;
  uint64_t v2 = *(NSObject **)(v1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Service starting...", buf, 2u);
  }
  (***(void (****)(void))(v1 + 88))(*(void *)(v1 + 88));
  (*(void (**)(void))(**(void **)(v1 + 88) + 128))(*(void *)(v1 + 88));
  operator delete();
}

void sub_10054E590()
{
}

uint64_t *sub_10054E5BC(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v5 = a1;
  uint64_t v6 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v3 = *(NSObject **)(*(void *)v1 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Shutdown...", buf, 2u);
  }
  ctu::RestModule::disconnect((ctu::RestModule *)(v2 + 72));
  (*(void (**)(void))(**(void **)(v2 + 88) + 8))(*(void *)(v2 + 88));
  sub_100088C88(&v6);
  return sub_100046B58((uint64_t *)&v5);
}

void sub_10054E668(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

uint64_t *sub_10054E684(uint64_t **a1)
{
  uint64_t v1 = *a1;
  uint64_t v5 = a1;
  uint64_t v6 = v1;
  uint64_t v2 = *v1;
  uint64_t v3 = (std::__shared_weak_count *)v1[2];
  v7[0] = v1[1];
  v7[1] = (uint64_t)v3;
  if (v3) {
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  sub_10054B734(v2, v7);
  if (v3) {
    sub_10004D2C8(v3);
  }
  sub_100046B58((uint64_t *)&v6);
  return sub_100046B58((uint64_t *)&v5);
}

void sub_10054E6F0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  if (v10) {
    sub_10004D2C8(v10);
  }
  sub_100046B58(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_10054E718(uint64_t ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v8 = a1;
  uint64_t v9 = v1;
  uint64_t v2 = *v1;
  uint64_t v3 = (*v1)[13];
  uint64_t v4 = (std::__shared_weak_count *)v1[2];
  xpc_object_t v11 = v1[1];
  char v12 = v4;
  if (v4) {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  char v5 = sub_101217058(v3, &v11);
  if (v12) {
    sub_10004D2C8(v12);
  }
  if ((v5 & 1) == 0)
  {
    uint64_t v6 = (std::__shared_weak_count *)v1[2];
    v10[0] = (uint64_t)v1[1];
    v10[1] = (uint64_t)v6;
    if (v6) {
      atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    sub_10054B734((uint64_t)v2, v10);
    if (v6) {
      sub_10004D2C8(v6);
    }
  }
  sub_10054BAC0(v2);
  sub_100046B58((uint64_t *)&v9);
  return sub_100046B58((uint64_t *)&v8);
}

void sub_10054E7D0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  if (v10) {
    sub_10004D2C8(v10);
  }
  sub_100046B58(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t sub_10054E810(uint64_t a1)
{
  uint64_t v1 = *(uint64_t **)(a1 + 40);
  uint64_t v2 = *v1;
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(*v1 + 56));
  uint64_t v4 = ServiceMap;
  if (v5 < 0)
  {
    uint64_t v6 = (unsigned __int8 *)(v5 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v7 = 5381;
    do
    {
      uint64_t v5 = v7;
      unsigned int v8 = *v6++;
      uint64_t v7 = (33 * v7) ^ v8;
    }
    while (v8);
  }
  std::mutex::lock(ServiceMap);
  *(void *)uint64_t v42 = v5;
  uint64_t v9 = sub_10004D37C(&v4[1].__m_.__sig, (unint64_t *)v42);
  if (v9)
  {
    uint64_t v10 = v9[3];
    xpc_object_t v11 = (std::__shared_weak_count *)v9[4];
    if (v11)
    {
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v4);
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v11);
      char v12 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v10 = 0;
  }
  std::mutex::unlock(v4);
  xpc_object_t v11 = 0;
  char v12 = 1;
LABEL_9:
  char v13 = (*(uint64_t (**)(uint64_t))(*(void *)v10 + 32))(v10);
  if ((v12 & 1) == 0) {
    sub_10004D2C8(v11);
  }
  if (v13)
  {
    xpc_object_t v58 = 0;
    xpc_object_t v59 = 0;
    unsigned int v60 = 0;
    uint64_t v57 = 0;
    long long v55 = 0u;
    long long v56 = 0u;
    long long v53 = 0u;
    long long v54 = 0u;
    long long v51 = 0u;
    long long v52 = 0u;
    long long v49 = 0u;
    long long v50 = 0u;
    long long v47 = 0u;
    long long v48 = 0u;
    *(_OWORD *)long long __p = 0u;
    long long v46 = 0u;
    long long v43 = 0u;
    memset(v44, 0, sizeof(v44));
    *(_OWORD *)uint64_t v42 = 0u;
    sub_10054D380((void (__cdecl ***)(std::basic_stringstream<char> *__hidden))v42, (const std::string *)(v1 + 1), 24);
    memset(&__str, 0, sizeof(__str));
    BOOL v14 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      if (*((char *)v1 + 31) >= 0) {
        uint64_t v15 = (uint64_t)(v1 + 1);
      }
      else {
        uint64_t v15 = v1[1];
      }
      *(_DWORD *)long long buf = 136315138;
      uint64_t v62 = v15;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I Processing OOS geofence input string: %s", buf, 0xCu);
    }
    if (*(_DWORD *)((char *)v44 + *(void *)(*(void *)v42 - 24)))
    {
      uint64_t v16 = v59;
    }
    else
    {
      unsigned int v19 = 0;
      do
      {
        sub_10013EA34((uint64_t)v42);
        double v20 = std::stod(&__str, 0);
        double v21 = v20;
        uint64_t v22 = v59;
        if (v59 >= v60)
        {
          uint64_t v23 = v58;
          uint64_t v24 = v59 - v58;
          unint64_t v25 = v24 + 1;
          if ((unint64_t)(v24 + 1) >> 61) {
            sub_1004D66E0();
          }
          uint64_t v26 = (char *)v60 - (char *)v58;
          if (((char *)v60 - (char *)v58) >> 2 > v25) {
            unint64_t v25 = v26 >> 2;
          }
          if ((unint64_t)v26 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v27 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v27 = v25;
          }
          if (v27)
          {
            id v28 = (char *)sub_10004EF74((uint64_t)&v60, v27);
            uint64_t v23 = v58;
            uint64_t v22 = v59;
          }
          else
          {
            id v28 = 0;
          }
          uint64_t v29 = (double *)&v28[8 * v24];
          *uint64_t v29 = v21;
          uint64_t v16 = v29 + 1;
          while (v22 != v23)
          {
            uint64_t v30 = *((void *)v22-- - 1);
            *((void *)v29-- - 1) = v30;
          }
          xpc_object_t v58 = v29;
          xpc_object_t v59 = v16;
          unsigned int v60 = (double *)&v28[8 * v27];
          if (v23) {
            operator delete(v23);
          }
        }
        else
        {
          *xpc_object_t v59 = v20;
          uint64_t v16 = v22 + 1;
        }
        xpc_object_t v59 = v16;
        if (*(_DWORD *)((char *)v44 + *(void *)(*(void *)v42 - 24))) {
          BOOL v31 = 1;
        }
        else {
          BOOL v31 = v19 >= 2;
        }
        ++v19;
      }
      while (!v31);
    }
    uint64_t v32 = v58;
    uint64_t v33 = (char *)v16 - (char *)v58;
    uint64_t v34 = *(NSObject **)(v2 + 40);
    BOOL v35 = os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT);
    if (v33 == 24)
    {
      if (v35)
      {
        uint64_t v36 = *(void *)v32;
        uint64_t v37 = *((void *)v32 + 1);
        uint64_t v38 = *((void *)v32 + 2);
        *(_DWORD *)long long buf = 134218496;
        uint64_t v62 = v36;
        __int16 v63 = 2048;
        uint64_t v64 = v37;
        __int16 v65 = 2048;
        uint64_t v66 = v38;
        _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "#I Processed OOS geofence input as %f|%f|%f", buf, 0x20u);
      }
      sub_10054B344((void *)v2);
      uint64_t v18 = (*(uint64_t (**)(void, double, double, double))(**(void **)(v2 + 128) + 40))(*(void *)(v2 + 128), *v58, v58[1], v58[2]);
    }
    else
    {
      if (v35)
      {
        *(_DWORD *)long long buf = 134217984;
        uint64_t v62 = v33 >> 3;
        _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "#I Invalid input for OOS geofence. Expected 3 arguments, received:%lu", buf, 0xCu);
      }
      uint64_t v18 = 0;
    }
    if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__str.__r_.__value_.__l.__data_);
    }
    *(void *)&long long v43 = v39;
    if (SHIBYTE(v46) < 0) {
      operator delete(__p[1]);
    }
    std::streambuf::~streambuf();
    std::iostream::~basic_iostream();
    std::ios::~ios();
    if (v58)
    {
      xpc_object_t v59 = v58;
      operator delete(v58);
    }
  }
  else
  {
    char v17 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t v42 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "Injecting Cell Broadcast not supported", v42, 2u);
    }
    return 0;
  }
  return v18;
}

void sub_10054EDC0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  sub_10008248C((uint64_t)&a16);
  uint64_t v18 = *(void **)(v16 - 184);
  if (v18)
  {
    *(void *)(v16 - 176) = v18;
    operator delete(v18);
  }
  _Unwind_Resume(a1);
}

void sub_10054EE24(void *a1, int a2)
{
  if (a2 == 2)
  {
    uint64_t v6 = (int *)__cxa_begin_catch(a1);
    uint64_t v7 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      int v8 = *v6;
      if (*(char *)(v4 + 31) >= 0) {
        uint64_t v9 = v3;
      }
      else {
        uint64_t v9 = *(void *)(v4 + 8);
      }
      *(_DWORD *)(v5 - 160) = 67109378;
      *(_DWORD *)(v5 - 156) = v8;
      *(_WORD *)(v5 - 152) = 2082;
      *(void *)(v5 - 150) = v9;
      _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "Invalid input for OOS geofence has thrown error (%d) been rejected: %{public}s", (uint8_t *)(v5 - 160), 0x12u);
    }
    __cxa_end_catch();
    JUMPOUT(0x10054EC10);
  }
  JUMPOUT(0x10054EDC4);
}

uint64_t sub_10054EEBC(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 40) + 16))();
  **(unsigned char **)(a1 + 32) = result;
  return result;
}

uint64_t sub_10054EEF8(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 40) + 16))();
  **(unsigned char **)(a1 + 32) = result;
  return result;
}

uint64_t *sub_10054EF34(uint64_t *a1)
{
  uint64_t v1 = *a1;
  char v44 = a1;
  uint64_t v45 = v1;
  uint64_t v2 = *(void ***)v1;
  uint64_t v3 = *(NSObject **)(*(void *)v1 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    sub_1010DDA90(&__p);
    uint64_t v4 = v52 >= 0 ? &__p : (void **)__p;
    LODWORD(buf) = 136446210;
    *(void *)((char *)&buf + 4) = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I %{public}s Wireless alert received", (uint8_t *)&buf, 0xCu);
    if (SHIBYTE(v52) < 0) {
      operator delete(__p);
    }
  }
  uint64_t v5 = *(void *)(v1 + 8);
  uint64_t v7 = *(void ***)(v5 + 16);
  uint64_t v6 = *(std::__shared_weak_count **)(v5 + 24);
  if (v6)
  {
    atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
    uint64_t v5 = *(void *)(v1 + 8);
  }
  uint64_t v9 = *(void *)(v5 + 160);
  int v8 = *(std::__shared_weak_count **)(v5 + 168);
  if (v8)
  {
    atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
    uint64_t v5 = *(void *)(v1 + 8);
  }
  uint64_t v10 = (os_log_t *)(*(uint64_t (**)(void *, void))(*v2[6] + 16))(v2[6], *(unsigned int *)(v5 + 156));
  if (((uint64_t (*)(void **, void))(*v2)[1])(v2, *(unsigned int *)(*(void *)(v1 + 8) + 156)))
  {
    if (v7)
    {
      xpc_object_t v11 = *v10;
      if (os_log_type_enabled(*v10, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(__p) = 0;
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I Alert received with Wac:", (uint8_t *)&__p, 2u);
      }
      sub_1012F8694((uint64_t)v7);
      long long __p = 0;
      long long v51 = 0;
      uint64_t v52 = 0;
      sub_1012F8BC8(&__p, v7[6], v7[7], ((char *)v7[7] - (char *)v7[6]) >> 4);
      char v13 = __p;
      char v12 = v51;
      long long buf = 0uLL;
      uint64_t v56 = 0;
      sub_1012F8AB4(&buf, v7[3], v7[4], ((char *)v7[4] - (char *)v7[3]) >> 4);
      uint64_t v14 = (char *)v12 - v13;
      uint64_t v15 = (uint64_t)(*((void *)&buf + 1) - buf) >> 4;
      *(void *)long long v54 = &buf;
      sub_10005CBF0((void ***)v54);
      *(void *)&long long buf = &__p;
      sub_10005CBF0((void ***)&buf);
      if (!(v15 + (v14 >> 4)))
      {
        uint64_t v16 = *v10;
        if (!os_log_type_enabled(*v10, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_21;
        }
        LOWORD(__p) = 0;
        char v17 = "#I No valid shapes...";
        goto LABEL_20;
      }
      if (!v9)
      {
LABEL_36:
        uint64_t v23 = *(NSObject **)(*(uint64_t (**)(void *, void))(*v2[6] + 16))(v2[6], *(unsigned int *)(*(void *)(v1 + 8) + 156));
        BOOL v24 = os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT);
        if (!v9)
        {
          if (v24)
          {
            LOWORD(__p) = 0;
            _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "#I Wea dispatch will happen after geofencing results...", (uint8_t *)&__p, 2u);
          }
          uint64_t v39 = *(void *)(v1 + 8);
          uint64_t v40 = *(void *)(v1 + 16);
          if (v40)
          {
            atomic_fetch_add_explicit((atomic_ullong *volatile)(v40 + 8), 1uLL, memory_order_relaxed);
            sub_10054B9A0((uint64_t)v2, v39, v40);
          }
          sub_10054B9A0((uint64_t)v2, v39, 0);
        }
        if (v24)
        {
          LOWORD(__p) = 0;
          _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "#I Wham Handling...", (uint8_t *)&__p, 2u);
        }
        uint64_t v26 = *(void **)(v1 + 8);
        unint64_t v25 = *(std::__shared_weak_count **)(v1 + 16);
        if (v25) {
          atomic_fetch_add_explicit(&v25->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        uint64_t v27 = v26[20];
        id v28 = (std::__shared_weak_count *)v26[21];
        if (v28) {
          atomic_fetch_add_explicit(&v28->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        long long v51 = 0;
        uint64_t v52 = 0;
        long long __p = 0;
        sub_101093CD4(&__p, *(void **)(v27 + 8), *(void **)(v27 + 16), (uint64_t)(*(void *)(v27 + 16) - *(void *)(v27 + 8)) >> 4);
        uint64_t v29 = v26[2];
        uint64_t v30 = (std::__shared_weak_count *)v26[3];
        if (v30) {
          atomic_fetch_add_explicit(&v30->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        if (!v29)
        {
          BOOL v31 = v2[5];
          if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
          {
            LOWORD(buf) = 0;
            _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "#I Wham: received without Wac", (uint8_t *)&buf, 2u);
          }
        }
        uint64_t v32 = (uint64_t)v2[13];
        long long v48 = v26;
        long long v49 = v25;
        if (v25) {
          atomic_fetch_add_explicit(&v25->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        sub_1012186E0(v32, (uint64_t)&v48);
        if (v49) {
          sub_10004D2C8(v49);
        }
        long long buf = 0uLL;
        uint64_t v56 = 0;
        sub_1012191D8((uint64_t)v2[13], (uint64_t)&buf);
        uint64_t v33 = v2[5];
        if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
        {
          if (*((void *)&buf + 1) - (void)buf <= 0x10uLL) {
            uint64_t v34 = "";
          }
          else {
            uint64_t v34 = "s";
          }
          *(_DWORD *)long long v54 = 134218242;
          *(void *)&v54[4] = (uint64_t)(*((void *)&buf + 1) - buf) >> 4;
          *(_WORD *)&v54[12] = 2080;
          *(void *)&v54[14] = v34;
          _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "#I Wham: %lu alert%s will be dispatched", v54, 0x16u);
        }
        uint64_t v36 = (char *)*((void *)&buf + 1);
        BOOL v35 = (char *)buf;
        if ((void)buf == *((void *)&buf + 1))
        {
          uint64_t v38 = (char *)buf;
        }
        else
        {
          do
          {
            uint64_t v37 = *(std::__shared_weak_count **)(*(void *)v35 + 72);
            uint64_t v46 = *(void *)(*(void *)v35 + 64);
            long long v47 = v37;
            if (v37) {
              atomic_fetch_add_explicit(&v37->__shared_owners_, 1uLL, memory_order_relaxed);
            }
            ((void (*)(void **, uint64_t *))(*v2)[16])(v2, &v46);
            if (v47) {
              sub_10004D2C8(v47);
            }
            v35 += 16;
          }
          while (v35 != v36);
          BOOL v35 = (char *)*((void *)&buf + 1);
          uint64_t v38 = (char *)buf;
        }
        memset(v54, 0, 24);
        sub_10054D830(v54, v38, v35, (v35 - v38) >> 4);
        long long v41 = *(void ***)v54;
        uint64_t v42 = *(void ***)&v54[8];
        while (v41 != v42)
        {
          sub_100926BDC(*v41);
          v41 += 2;
        }
        p_long long buf = v54;
        sub_10005CBF0((void ***)&p_buf);
        p_long long buf = (uint8_t *)&buf;
        sub_10005CBF0((void ***)&p_buf);
        if (v30) {
          sub_10004D2C8(v30);
        }
        *(void *)&long long buf = &__p;
        sub_10005CBF0((void ***)&buf);
        if (v28) {
          sub_10004D2C8(v28);
        }
        if (!v25)
        {
LABEL_79:
          if (!v8) {
            goto LABEL_81;
          }
          goto LABEL_80;
        }
        double v21 = v25;
LABEL_78:
        sub_10004D2C8(v21);
        goto LABEL_79;
      }
    }
    else if (!v9)
    {
      unsigned int v19 = *v10;
      if (os_log_type_enabled(*v10, OS_LOG_TYPE_ERROR))
      {
        LOWORD(__p) = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Wac and Wham are null. Processing as a normal alert...", (uint8_t *)&__p, 2u);
      }
LABEL_28:
      double v20 = *(std::__shared_weak_count **)(v1 + 16);
      long long __p = *(void **)(v1 + 8);
      long long v51 = v20;
      if (v20) {
        atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      ((void (*)(void **, void **))(*v2)[16])(v2, &__p);
      double v21 = v51;
      if (!v51) {
        goto LABEL_79;
      }
      goto LABEL_78;
    }
    uint64_t v22 = *v10;
    if (os_log_type_enabled(*v10, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(__p) = 0;
      _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "#I Alert received with Wham:", (uint8_t *)&__p, 2u);
    }
    sub_101093908(v9);
    goto LABEL_36;
  }
  uint64_t v16 = *v10;
  if (!os_log_type_enabled(*v10, OS_LOG_TYPE_DEFAULT)) {
    goto LABEL_21;
  }
  LOWORD(__p) = 0;
  char v17 = "#I Geofencing is not possible...";
LABEL_20:
  _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, v17, (uint8_t *)&__p, 2u);
LABEL_21:
  if (!v9) {
    goto LABEL_28;
  }
  uint64_t v18 = *(NSObject **)(*(uint64_t (**)(void *, void))(*v2[6] + 16))(v2[6], *(unsigned int *)(*(void *)(v1 + 8) + 156));
  if (!os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT)) {
    goto LABEL_79;
  }
  LOWORD(__p) = 0;
  _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#I Wham ignored...", (uint8_t *)&__p, 2u);
  if (v8) {
LABEL_80:
  }
    sub_10004D2C8(v8);
LABEL_81:
  if (v6) {
    sub_10004D2C8(v6);
  }
  sub_100046B58(&v45);
  return sub_100046B58((uint64_t *)&v44);
}

void sub_10054F688(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, void ***a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void **a23)
{
  a18 = &a23;
  sub_10005CBF0((void ***)&a18);
  if (v27) {
    sub_10004D2C8(v27);
  }
  a23 = (void **)&a15;
  sub_10005CBF0(&a23);
  if (v26) {
    sub_10004D2C8(v26);
  }
  if (v25) {
    sub_10004D2C8(v25);
  }
  if (v24) {
    sub_10004D2C8(v24);
  }
  if (v23) {
    sub_10004D2C8(v23);
  }
  sub_100046B58(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

void sub_10054F794()
{
}

void sub_10054F800()
{
}

void *sub_10054F824(void *a1, uint64_t a2)
{
  initially_inactive = dispatch_queue_attr_make_initially_inactive(0);
  uint64_t v5 = dispatch_queue_create_with_target_V2("DMSettingsManager", initially_inactive, 0);
  dispatch_set_qos_class_floor(v5, QOS_CLASS_UTILITY, 0);
  dispatch_activate(v5);
  a1[1] = 0;
  a1[2] = 0;
  a1[3] = v5;
  if (v5)
  {
    dispatch_retain(v5);
    a1[4] = 0;
    dispatch_release(v5);
  }
  else
  {
    a1[4] = 0;
  }
  uint64_t v6 = (capabilities::ct *)ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 5), kCtLoggingSystemName, "dm.set");
  v10[0] = off_101999E18;
  v10[1] = sub_10054FBC0;
  uint64_t v10[3] = v10;
  a1[6] = 0;
  if ((capabilities::ct::supportsGemini(v6) & 1) == 0) {
    operator new();
  }
  if (!a1[6]) {
    operator new();
  }
  sub_10008863C(v10);
  *a1 = off_1019E2CF0;
  uint64_t v7 = *(Registry **)a2;
  a1[7] = *(void *)a2;
  uint64_t v8 = *(void *)(a2 + 8);
  a1[8] = v8;
  if (v8)
  {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v8 + 8), 1uLL, memory_order_relaxed);
    uint64_t v7 = (Registry *)a1[7];
  }
  Registry::getNotificationSenderFactory(&v11, v7);
  (*(void (**)(uint64_t))(*(void *)v11 + 168))(v11);
  if (v12) {
    sub_10004D2C8(v12);
  }
  return a1;
}

void sub_10054FAD4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  sub_10008863C((uint64_t *)va);
  operator delete();
}

void sub_10054FBB8()
{
}

const char *sub_10054FBC0(int a1)
{
  uint64_t v1 = "dm.set.?";
  if (a1 == 2) {
    uint64_t v1 = "dm.set.2";
  }
  if (a1 == 1) {
    return "dm.set.1";
  }
  else {
    return v1;
  }
}

uint64_t sub_10054FBEC(uint64_t a1, int a2)
{
  uint64_t v5 = a1;
  int v6 = a2;
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 0x40000000;
  uint64_t v7[2] = sub_1005502A8;
  double v7[3] = &unk_1019E2E80;
  void v7[4] = a1 + 8;
  v7[5] = &v5;
  uint64_t v8 = v7;
  uint64_t v3 = a1 + 24;
  uint64_t v2 = *(NSObject **)(a1 + 24);
  if (*(void *)(v3 + 8))
  {
    unsigned int v15 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v10 = 0x40000000;
    uint64_t v11 = sub_100550430;
    char v12 = &unk_1019E2EC0;
    char v13 = &v15;
    uint64_t v14 = &v8;
    dispatch_async_and_wait(v2, &block);
  }
  else
  {
    unsigned int v15 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v10 = 0x40000000;
    uint64_t v11 = sub_1005503F4;
    char v12 = &unk_1019E2EA0;
    char v13 = &v15;
    uint64_t v14 = &v8;
    dispatch_sync(v2, &block);
  }
  return v15;
}

BOOL sub_10054FD1C(uint64_t a1, int a2, char a3)
{
  uint64_t v6 = a1;
  int v7 = a2;
  char v8 = a3;
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 0x40000000;
  void v9[2] = sub_10055046C;
  void v9[3] = &unk_1019E2EE0;
  void v9[4] = a1 + 8;
  v9[5] = &v6;
  uint64_t v10 = v9;
  uint64_t v4 = a1 + 24;
  uint64_t v3 = *(NSObject **)(a1 + 24);
  if (*(void *)(v4 + 8))
  {
    char v17 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v12 = 0x40000000;
    char v13 = sub_10005AD5C;
    uint64_t v14 = &unk_1019E2F20;
    unsigned int v15 = &v17;
    uint64_t v16 = &v10;
    dispatch_async_and_wait(v3, &block);
  }
  else
  {
    char v17 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v12 = 0x40000000;
    char v13 = sub_100059FF8;
    uint64_t v14 = &unk_1019E2F00;
    unsigned int v15 = &v17;
    uint64_t v16 = &v10;
    dispatch_sync(v3, &block);
  }
  return v17 != 0;
}

void sub_10054FE58(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_10054FF48(void *a1)
{
  *a1 = off_1019E2CF0;
  uint64_t v2 = (std::__shared_weak_count *)a1[10];
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)a1[8];
  if (v3) {
    sub_10004D2C8(v3);
  }
  uint64_t v4 = a1[6];
  a1[6] = 0;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 5));
  sub_100087E88(a1 + 1);

  DMSettingsManagerInterface::~DMSettingsManagerInterface((DMSettingsManagerInterface *)a1);
}

void sub_10054FFF4(void *a1)
{
  *a1 = off_1019E2CF0;
  uint64_t v2 = (std::__shared_weak_count *)a1[10];
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)a1[8];
  if (v3) {
    sub_10004D2C8(v3);
  }
  uint64_t v4 = a1[6];
  a1[6] = 0;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 5));
  sub_100087E88(a1 + 1);
  DMSettingsManagerInterface::~DMSettingsManagerInterface((DMSettingsManagerInterface *)a1);

  operator delete();
}

void sub_1005500B4(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_100550180(void *a1)
{
  __cxa_begin_catch(a1);
  dispatch_barrier_async_f(v1[3], v1, (dispatch_function_t)sub_100550258);
  __cxa_rethrow();
}

void sub_1005501A8(_Unwind_Exception *a1)
{
}

void sub_1005501C0(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_1005501F8(uint64_t a1)
{
}

uint64_t sub_100550214(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_100550258(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 32))();
  }
  return result;
}

void sub_100550288()
{
}

uint64_t sub_10055029C(uint64_t a1)
{
  return *(void *)(a1 + 8) + 40;
}

uint64_t sub_1005502A8(uint64_t a1)
{
  uint64_t v1 = *(unsigned int **)(a1 + 40);
  uint64_t v2 = v1[2];
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(*(void *)v1 + 56));
  uint64_t v4 = ServiceMap;
  if ((v5 & 0x8000000000000000) != 0)
  {
    uint64_t v6 = (unsigned __int8 *)(v5 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v7 = 5381;
    do
    {
      unint64_t v5 = v7;
      unsigned int v8 = *v6++;
      uint64_t v7 = (33 * v7) ^ v8;
    }
    while (v8);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v15 = v5;
  uint64_t v9 = sub_10004D37C(&v4[1].__m_.__sig, &v15);
  if (v9)
  {
    uint64_t v11 = v9[3];
    uint64_t v10 = (std::__shared_weak_count *)v9[4];
    if (v10)
    {
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v4);
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v10);
      char v12 = 0;
      if (!v11) {
        goto LABEL_7;
      }
      goto LABEL_11;
    }
  }
  else
  {
    uint64_t v11 = 0;
  }
  std::mutex::unlock(v4);
  uint64_t v10 = 0;
  char v12 = 1;
  if (!v11)
  {
LABEL_7:
    uint64_t v13 = 0;
    if (v12) {
      return v13;
    }
    goto LABEL_12;
  }
LABEL_11:
  uint64_t v13 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v11 + 336))(v11, v2);
  if ((v12 & 1) == 0) {
LABEL_12:
  }
    sub_10004D2C8(v10);
  return v13;
}

void sub_1005503D8(_Unwind_Exception *exception_object)
{
  if ((v1 & 1) == 0) {
    sub_10004D2C8(v2);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1005503F4(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 40) + 16))();
  **(_DWORD **)(a1 + 32) = result;
  return result;
}

uint64_t sub_100550430(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 40) + 16))();
  **(_DWORD **)(a1 + 32) = result;
  return result;
}

BOOL sub_10055046C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 40);
  uint64_t v2 = *(unsigned int *)(v1 + 8);
  int v3 = *(unsigned __int8 *)(v1 + 12);
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(*(void *)v1 + 56));
  unint64_t v5 = ServiceMap;
  if ((v6 & 0x8000000000000000) != 0)
  {
    uint64_t v7 = (unsigned __int8 *)(v6 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v8 = 5381;
    do
    {
      unint64_t v6 = v8;
      unsigned int v9 = *v7++;
      uint64_t v8 = (33 * v8) ^ v9;
    }
    while (v9);
  }
  std::mutex::lock(ServiceMap);
  v15[0] = v6;
  uint64_t v10 = sub_10004D37C(&v5[1].__m_.__sig, v15);
  if (!v10)
  {
    uint64_t v11 = 0;
LABEL_9:
    std::mutex::unlock(v5);
    char v12 = 0;
    char v13 = 1;
    if (!v11) {
      goto LABEL_11;
    }
    goto LABEL_10;
  }
  uint64_t v11 = v10[3];
  char v12 = (std::__shared_weak_count *)v10[4];
  if (!v12) {
    goto LABEL_9;
  }
  atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v5);
  atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v12);
  char v13 = 0;
  if (v11)
  {
LABEL_10:
    void v15[3] = 0;
    (*(void (**)(uint64_t, uint64_t, BOOL, unint64_t *))(*(void *)v11 + 328))(v11, v2, v3 != 0, v15);
    sub_100060644(v15);
  }
LABEL_11:
  if ((v13 & 1) == 0) {
    sub_10004D2C8(v12);
  }
  return v11 != 0;
}

void sub_1005505E4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100060644((uint64_t *)va);
  if ((v3 & 1) == 0) {
    sub_10004D2C8(v2);
  }
  _Unwind_Resume(a1);
}

void sub_100550618(uint64_t a1)
{
  uint64_t v1 = a1;
  (*(void (**)(void, void))(**(void **)(**(void **)a1 + 72) + 16))(*(void *)(**(void **)a1 + 72), *(unsigned int *)(*(void *)a1 + 8));
  operator delete();
}

void sub_100550694()
{
}

uint64_t sub_1005506C0(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)a1;
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  block[2] = sub_100550768;
  block[3] = &unk_1019E2F40;
  void block[4] = a1;
  dispatch_sync(v2, block);
  char v3 = *(const void **)(a1 + 16);
  if (v3) {
    _Block_release(v3);
  }
  uint64_t v4 = *(NSObject **)(a1 + 8);
  if (v4) {
    dispatch_release(v4);
  }
  if (*(void *)a1) {
    dispatch_release(*(dispatch_object_t *)a1);
  }
  return a1;
}

void sub_100550768(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t v2 = *(NSObject **)(v1 + 24);
  if (v2)
  {
    dispatch_source_cancel(v2);
    dispatch_release(*(dispatch_object_t *)(v1 + 24));
    *(void *)(v1 + 24) = 0;
    *(unsigned char *)(v1 + 36) = 0;
  }
  char v3 = *(NSObject **)(v1 + 8);
  *(void *)(v1 + 8) = 0;
  if (v3) {
    dispatch_release(v3);
  }
  uint64_t v4 = *(const void **)(v1 + 16);
  *(void *)(v1 + 16) = 0;
  if (v4) {
    _Block_release(v4);
  }
}

void sub_1005507C8(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (!*(_DWORD *)(v1 + 32)) {
    *(unsigned char *)(v1 + 36) = 0;
  }
  uint64_t v2 = *(void **)(v1 + 16);
  if (v2) {
    dispatch_async(*(dispatch_queue_t *)(v1 + 8), v2);
  }
}

void sub_1005507EC(uint64_t a1)
{
  uint64_t v4 = a1 + 32;
  uint64_t v2 = *(void **)(a1 + 32);
  uint64_t v3 = *(void *)(v4 + 8);
  if (v2) {
    uint64_t v2 = _Block_copy(v2);
  }
  unint64_t v5 = *(const void **)(v3 + 16);
  *(void *)(v3 + 16) = v2;
  if (v5) {
    _Block_release(v5);
  }
  unint64_t v6 = *(NSObject **)(a1 + 48);
  if (v6) {
    dispatch_retain(v6);
  }
  uint64_t v7 = *(NSObject **)(v3 + 8);
  *(void *)(v3 + 8) = v6;
  if (v7)
  {
    dispatch_release(v7);
  }
}

void sub_10055086C(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  dispatch_time_t v3 = dispatch_time(0xFFFFFFFFFFFFFFFFLL, 0);
  dispatch_time_t v4 = dispatch_walltime(0, 1000000 * *(unsigned int *)(a1 + 40));
  unsigned int v5 = *(_DWORD *)(a1 + 44);
  if (v5) {
    uint64_t v6 = 1000000 * v5;
  }
  else {
    uint64_t v6 = v3;
  }
  *(_DWORD *)(v2 + 32) = v5;
  uint64_t v7 = *(NSObject **)(v2 + 24);
  if (v7)
  {
    dispatch_source_set_timer(v7, v4, v6, 0x989680uLL);
  }
  else
  {
    uint64_t v8 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_timer, 0, 0, *(dispatch_queue_t *)v2);
    *(void *)(v2 + 24) = v8;
    handler[0] = _NSConcreteStackBlock;
    handler[1] = 0x40000000;
    handler[2] = sub_1005507C8;
    handler[3] = &unk_1019E2F60;
    handler[4] = v2;
    dispatch_source_set_event_handler(v8, handler);
    dispatch_source_set_timer(*(dispatch_source_t *)(v2 + 24), v4, v6, 0x989680uLL);
    dispatch_activate(*(dispatch_object_t *)(v2 + 24));
  }
  *(unsigned char *)(v2 + 36) = 1;
}

void sub_10055099C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  dispatch_time_t v2 = dispatch_time(0xFFFFFFFFFFFFFFFFLL, 0);
  dispatch_time_t v3 = *(NSObject **)(v1 + 24);
  if (v3) {
    dispatch_source_set_timer(v3, v2, v2, 0x989680uLL);
  }
  *(unsigned char *)(v1 + 36) = 0;
}

void sub_100550A88(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100550B60(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100550C64(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100550D3C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100550E2C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100550EDC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100550F70(_Unwind_Exception *a1)
{
  dispatch_time_t v4 = v3;

  _Unwind_Resume(a1);
}

void sub_100551024(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_100551118(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100551418(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100551850(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18)
{
  _Unwind_Resume(a1);
}

void sub_100551BAC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  sub_100551DAC(v10);
  sub_100551DAC((uint64_t)va);
  objc_destroyWeak((id *)(v11 - 72));

  _Unwind_Resume(a1);
}

void sub_100551BD4(uint64_t a1, char a2, void *a3, void *a4)
{
  id v7 = a3;
  id v8 = a4;
  id v9 = v7;
  id v10 = v8;
  uint64_t v11 = *(void **)(a1 + 32);
  objc_copyWeak(&v13, (id *)(a1 + 40));
  sub_10012A394(&v14, (const void **)(a1 + 48));
  char v15 = a2;
  id v16 = v9;
  id v12 = v11;
  operator new();
}

const void **sub_100551D14(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 32) = *(id *)(a2 + 32);
  objc_copyWeak((id *)(a1 + 40), (id *)(a2 + 40));

  return sub_10012A394((const void **)(a1 + 48), (const void **)(a2 + 48));
}

void sub_100551D68(uint64_t a1)
{
  sub_10012577C((const void **)(a1 + 48));
  objc_destroyWeak((id *)(a1 + 40));
  dispatch_time_t v2 = *(void **)(a1 + 32);
}

uint64_t sub_100551DAC(uint64_t a1)
{
  return a1;
}

void sub_100551ED0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1005520D8(_Unwind_Exception *a1)
{
  sub_10004D2C8(v2);

  _Unwind_Resume(a1);
}

void sub_1005522C0()
{
}

void sub_1005526AC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18)
{
  _Unwind_Resume(a1);
}

void sub_100552970(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100552AB8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100552D10(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100552D70(uint64_t a1, char a2, void *a3)
{
  id v5 = a3;
  uint64_t v6 = *(void **)(a1 + 32);
  objc_copyWeak(&to, (id *)(a1 + 40));
  char v9 = a2;
  id v10 = v5;
  sub_1000DFC90((uint64_t)v11, a1 + 48);
  void v11[4] = *(id *)(a1 + 80);
  id v7 = v6;
  operator new();
}

void sub_100552EE4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, id location, uint64_t a13, uint64_t a14)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

id sub_100552F20(uint64_t a1, id *a2)
{
  *(void *)(a1 + 32) = a2[4];
  objc_copyWeak((id *)(a1 + 40), a2 + 5);
  sub_1000DFC90(a1 + 48, (uint64_t)(a2 + 6));
  id result = a2[10];
  *(void *)(a1 + 80) = result;
  return result;
}

void sub_100552F80(_Unwind_Exception *a1)
{
  objc_destroyWeak(v2);

  _Unwind_Resume(a1);
}

void sub_100552F9C(uint64_t a1)
{
  sub_100060644((void *)(a1 + 48));
  objc_destroyWeak((id *)(a1 + 40));
  dispatch_time_t v2 = *(void **)(a1 + 32);
}

uint64_t sub_100552FE8(uint64_t a1)
{
  sub_100060644((void *)(a1 + 16));
  objc_destroyWeak((id *)(a1 + 8));

  return a1;
}

void sub_10055315C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1005533B4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100553414(uint64_t a1, char a2, void *a3)
{
  id v5 = a3;
  uint64_t v6 = *(void **)(a1 + 32);
  objc_copyWeak(&to, (id *)(a1 + 40));
  char v9 = a2;
  id v10 = v5;
  sub_1000DFC90((uint64_t)v11, a1 + 48);
  void v11[4] = *(id *)(a1 + 80);
  id v7 = v6;
  operator new();
}

void sub_100553588(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, id location, uint64_t a13, uint64_t a14)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

id sub_1005535C4(uint64_t a1, id *a2)
{
  *(void *)(a1 + 32) = a2[4];
  objc_copyWeak((id *)(a1 + 40), a2 + 5);
  sub_1000DFC90(a1 + 48, (uint64_t)(a2 + 6));
  id result = a2[10];
  *(void *)(a1 + 80) = result;
  return result;
}

void sub_100553624(_Unwind_Exception *a1)
{
  objc_destroyWeak(v2);

  _Unwind_Resume(a1);
}

void sub_100553640(uint64_t a1)
{
  sub_100060644((void *)(a1 + 48));
  objc_destroyWeak((id *)(a1 + 40));
  dispatch_time_t v2 = *(void **)(a1 + 32);
}

void sub_1005538A0()
{
}

void sub_100553B44(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL sub_100553BC8(uint64_t a1, char a2)
{
  return (a2 & 0x29) != 0;
}

BOOL sub_100553BD8(uint64_t a1, char a2)
{
  return (a2 & 9) != 0;
}

void sub_100553BE8()
{
}

void sub_100553C5C()
{
}

uint64_t sub_100553C80(uint64_t a1, void *a2, id *a3)
{
  *(void *)a1 = &off_1019E3110;
  uint64_t v6 = (void *)(a1 + 8);
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v9, kCtLoggingSystemName, "stw.ids.ctr");
  sub_100553D78(v6, a3, &v9);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v9);
  *(void *)a1 = off_1019E3088;
  *(void *)(a1 + 48) = *a2;
  uint64_t v7 = a2[1];
  *(void *)(a1 + 56) = v7;
  if (v7) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v7 + 8), 1uLL, memory_order_relaxed);
  }
  *(unsigned char *)(a1 + 64) = 0;
  *(_DWORD *)(a1 + 68) = 0;
  *(unsigned char *)(a1 + 72) = 0;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  return a1;
}

void sub_100553D64(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void *sub_100553D78(void *a1, id *a2, const OsLogContext *a3)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = *a2;
  a1[3] = 0;
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v6, a3);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 4), (const ctu::OsLogLogger *)v6);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v6);
  return a1;
}

void sub_100553DD8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)va);
  sub_1004FDE68(v2);
  _Unwind_Resume(a1);
}

id sub_100553DFC(uint64_t a1, int a2)
{
  if (a2 == 8)
  {
    dispatch_time_t v3 = (id *)(a1 + 104);
LABEL_5:
    id v4 = *v3;
    return v4;
  }
  if (a2 == 1)
  {
    dispatch_time_t v3 = (id *)(a1 + 96);
    goto LABEL_5;
  }
  id v4 = 0;
  return v4;
}

void sub_100553E58(uint64_t a1, long long *a2)
{
  id v4 = sub_100200FB4((id *)(a1 + 40));
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v7 = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Bootstrap", v7, 2u);
  }

  long long v5 = *a2;
  *(void *)a2 = 0;
  *((void *)a2 + 1) = 0;
  uint64_t v6 = *(std::__shared_weak_count **)(a1 + 88);
  *(_OWORD *)(a1 + 80) = v5;
  if (v6) {
    std::__shared_weak_count::__release_weak(v6);
  }
}

void sub_100553EEC(uint64_t a1, uint64_t a2)
{
  if (*(void *)(a2 + 24))
  {
    if (*(void *)(a1 + 112))
    {
      id v4 = sub_100200FB4((id *)(a1 + 40));
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)id v10 = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "Destroying existing iMessage sign in tracker. Will create a new one for handling this new callback.", v10, 2u);
      }
    }
    long long v5 = sub_100200FB4((id *)(a1 + 40));
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)OsLogContext v9 = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Created iMessage sign in tracker, and registered callback", v9, 2u);
    }

    uint64_t v6 = [[StewieIMessageSignInTracker alloc] initWithSignInChangedCallback:a2];
    uint64_t v7 = *(void **)(a1 + 112);
    *(void *)(a1 + 112) = v6;
  }
  else
  {
    id v8 = sub_100200FB4((id *)(a1 + 40));
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Destroyed iMessage sign in tracker", buf, 2u);
    }

    uint64_t v7 = *(void **)(a1 + 112);
    *(void *)(a1 + 112) = 0;
  }
}

void sub_100554038(uint64_t a1, uint64_t a2, uint64_t a3)
{
  long long v5 = (id *)(a1 + 24);
  uint64_t v6 = sub_100200FB4((id *)(a1 + 24));
  dispatch_assert_queue_V2(v6);

  uint64_t v7 = sub_100200FB4((id *)(a1 + 40));
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    sub_100BC897C(a3, &__p);
    id v8 = (__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
       ? &__p
       : (std::string *)__p.__r_.__value_.__r.__words[0];
    *(_DWORD *)long long buf = 136446210;
    uint64_t v32 = v8;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Received request to enable transport for services: %{public}s", buf, 0xCu);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
  }

  if ((a3 & 1) != 0 && !*(void *)(a1 + 96))
  {
    OsLogContext v9 = [StewieIDSServerMessagingController alloc];
    id v10 = sub_100200FB4(v5);
    uint64_t v11 = *(std::__shared_weak_count **)(a1 + 88);
    uint64_t v28 = *(void *)(a1 + 80);
    uint64_t v29 = v11;
    if (v11) {
      atomic_fetch_add_explicit(&v11->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    }
    id v12 = [(StewieIDSServerMessagingController *)v9 initWithQueue:v10 service:1 delegate:&v28];
    id v13 = *(void **)(a1 + 96);
    *(void *)(a1 + 96) = v12;

    if (v29) {
      std::__shared_weak_count::__release_weak(v29);
    }
  }
  if ((a3 & 8) != 0 && !*(void *)(a1 + 104))
  {
    uint64_t v14 = [StewieIDSServerMessagingController alloc];
    char v15 = sub_100200FB4(v5);
    id v16 = *(std::__shared_weak_count **)(a1 + 88);
    uint64_t v26 = *(void *)(a1 + 80);
    uint64_t v27 = v16;
    if (v16) {
      atomic_fetch_add_explicit(&v16->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    }
    char v17 = [(StewieIDSServerMessagingController *)v14 initWithQueue:v15 service:8 delegate:&v26];
    uint64_t v18 = *(void **)(a1 + 104);
    *(void *)(a1 + 104) = v17;

    if (v27) {
      std::__shared_weak_count::__release_weak(v27);
    }
  }
  if ((a3 & 0x20) != 0 && !*(void *)(a1 + 120))
  {
    unsigned int v19 = [StewieIDSSatSmsController alloc];
    double v20 = sub_100200FB4(v5);
    double v21 = *(std::__shared_weak_count **)(a1 + 88);
    uint64_t v24 = *(void *)(a1 + 80);
    unint64_t v25 = v21;
    if (v21) {
      atomic_fetch_add_explicit(&v21->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    }
    uint64_t v22 = [(StewieIDSSatSmsController *)v19 initWithQueue:v20 delegate:&v24];
    uint64_t v23 = *(void **)(a1 + 120);
    *(void *)(a1 + 120) = v22;

    if (v25) {
      std::__shared_weak_count::__release_weak(v25);
    }
  }
  sub_10055430C(a1);
}

void sub_1005542A0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11, uint64_t a12, std::__shared_weak_count *a13, uint64_t a14, std::__shared_weak_count *a15)
{
  if (a11) {
    std::__shared_weak_count::__release_weak(a11);
  }

  _Unwind_Resume(a1);
}

void sub_10055430C(uint64_t a1)
{
  uint64_t v2 = sub_100200FB4((id *)(a1 + 24));
  dispatch_assert_queue_V2(v2);

  if (*(void *)(a1 + 96) || *(void *)(a1 + 104))
  {
    int v3 = *(unsigned char *)(a1 + 64) != 0;
    int v4 = 1;
  }
  else
  {
    int v4 = 0;
    int v3 = 0;
  }
  if (*(_DWORD *)(a1 + 68) != v4 || *(unsigned __int8 *)(a1 + 72) != v3)
  {
    *(_DWORD *)(a1 + 68) = v4;
    *(unsigned char *)(a1 + 72) = v3;
    long long v5 = *(std::__shared_weak_count **)(a1 + 16);
    if (v5)
    {
      if (std::__shared_weak_count::lock(v5)) {
        operator new();
      }
    }
    sub_100088B9C();
  }
}

void sub_100554480(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100554494(uint64_t a1, uint64_t a2, uint64_t a3)
{
  long long v5 = sub_100200FB4((id *)(a1 + 24));
  dispatch_assert_queue_V2(v5);

  if (*(void *)(a1 + 96) || *(void *)(a1 + 104))
  {
    uint64_t v6 = sub_100200FB4((id *)(a1 + 40));
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      sub_100BC897C(a3, &__p);
      uint64_t v7 = (__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
         ? &__p
         : (std::string *)__p.__r_.__value_.__r.__words[0];
      *(_DWORD *)long long buf = 136446210;
      id v13 = v7;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Received request to disable transport for services %{public}s", buf, 0xCu);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
    }

    if (a3)
    {
      id v8 = *(void **)(a1 + 96);
      if (v8)
      {
        *(void *)(a1 + 96) = 0;
      }
    }
    if ((a3 & 8) != 0)
    {
      OsLogContext v9 = *(void **)(a1 + 104);
      if (v9)
      {
        *(void *)(a1 + 104) = 0;
      }
    }
    if ((a3 & 0x20) != 0)
    {
      id v10 = *(void **)(a1 + 120);
      if (v10)
      {
        *(void *)(a1 + 120) = 0;
      }
    }
    sub_10055430C(a1);
  }
}

void sub_1005545E4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100554608(uint64_t a1, const void **a2, int a3, uint64_t a4)
{
  id v8 = sub_100200FB4((id *)(a1 + 24));
  dispatch_assert_queue_V2(v8);

  if ((a3 & 0x29) == 0) {
    __TUAssertTrigger();
  }
  OsLogContext v9 = sub_100553DFC(a1, a3);
  if (!v9)
  {
    uint64_t v11 = sub_100200FB4((id *)(a1 + 40));
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)id v16 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "Send is not allowed because transport is not requested", v16, 2u);
    }

    *(void *)id v16 = a1;
    sub_10012A394((const void **)&v16[8], a2);
    sub_10055489C(a1 + 8);
  }
  CFStringRef v15 = CFUUIDCreateString(kCFAllocatorDefault, (CFUUIDRef)*a2);
  id v10 = sub_100200FB4((id *)(a1 + 40));
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    memset(v16, 0, sizeof(v16));
    uint64_t v17 = 0;
    ctu::cf::assign();
    *(_OWORD *)std::string __p = 0u;
    uint64_t v14 = 0;
    *(_DWORD *)long long buf = 136315394;
    unsigned int v19 = __p;
    __int16 v20 = 2080;
    double v21 = sub_100BC87FC(a3);
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I Message accepted by IDS (id: %s) for service: %s", buf, 0x16u);
    if (SHIBYTE(v14) < 0) {
      operator delete(__p[0]);
    }
  }

  sub_10012A394(&v12, a2);
  [v9 sendMessageWithId:&v12 content:a4];
  sub_10012577C(&v12);
  sub_1000558F4((const void **)&v15);
}

void sub_100554838(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  _Unwind_Resume(a1);
}

void sub_10055489C(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 8);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_1005549A8(uint64_t a1, uint64_t a2)
{
  int v4 = sub_100200FB4((id *)(a1 + 24));
  dispatch_assert_queue_V2(v4);

  id v13 = 0;
  long long v5 = [[CTStewieIDSDeliveryContext alloc] initWithVectorRepresentation:a2 error:&v13];
  uint64_t v6 = (char *)v13;
  if (v6 || !v5)
  {
    id v8 = sub_100200FB4((id *)(a1 + 40));
    if (!os_log_type_enabled(v8, OS_LOG_TYPE_ERROR)) {
      goto LABEL_12;
    }
    *(_DWORD *)long long buf = 138412290;
    CFStringRef v15 = v6;
    OsLogContext v9 = "Couldn't unpack CTStewieIDSDeliveryContext. Error: %@";
    goto LABEL_8;
  }
  if ([(CTStewieIDSDeliveryContext *)v5 service] == 32)
  {
    uint64_t v7 = *(void **)(a1 + 120);
    if (v7)
    {
      id v8 = [(CTStewieIDSDeliveryContext *)v5 deliveryContext];
      [v7 ackReceivedMessageWithContext:v8];
      goto LABEL_12;
    }
    id v8 = sub_100200FB4((id *)(a1 + 40));
    if (!os_log_type_enabled(v8, OS_LOG_TYPE_ERROR)) {
      goto LABEL_12;
    }
    uint64_t v11 = sub_100BC87FC([(CTStewieIDSDeliveryContext *)v5 service]);
    *(_DWORD *)long long buf = 136315138;
    CFStringRef v15 = v11;
    OsLogContext v9 = "No controller exists for service: %s";
LABEL_8:
    _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, v9, buf, 0xCu);
    goto LABEL_12;
  }
  id v8 = sub_100553DFC(a1, [(CTStewieIDSDeliveryContext *)v5 service]);
  if (v8)
  {
    id v10 = [(CTStewieIDSDeliveryContext *)v5 deliveryContext];
    [v8 ackReceivedMessageWithContext:v10];
  }
  else
  {
    id v10 = sub_100200FB4((id *)(a1 + 40));
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      id v12 = sub_100BC87FC([(CTStewieIDSDeliveryContext *)v5 service]);
      *(_DWORD *)long long buf = 136315138;
      CFStringRef v15 = v12;
      _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "No controller exists for service: %s", buf, 0xCu);
    }
  }

LABEL_12:
}

void sub_100554BE8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100554C60(uint64_t a1, int a2)
{
  int v4 = sub_100200FB4((id *)(a1 + 24));
  dispatch_assert_queue_V2(v4);

  if (*(unsigned __int8 *)(a1 + 64) != a2)
  {
    *(unsigned char *)(a1 + 64) = a2;
    sub_100554CF0(a1);
    sub_10055430C(a1);
  }
}

void sub_100554CE0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100554CF0(uint64_t a1)
{
  uint64_t v2 = sub_100200FB4((id *)(a1 + 24));
  dispatch_assert_queue_V2(v2);

  if (*(void *)(a1 + 120) && *(void *)(a1 + 128))
  {
    Registry::getTimerService((uint64_t *)&v14, *(Registry **)(a1 + 48));
    uint64_t v3 = (**v14)(v14);
    uint64_t v4 = *(void *)(*(void *)(a1 + 128) + 48);
    if (v15) {
      sub_10004D2C8(v15);
    }
    if (v3 >= v4)
    {
      uint64_t v11 = sub_100200FB4((id *)(a1 + 40));
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
      {
        LOWORD(v14) = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "[Shutdown] Request expired", (uint8_t *)&v14, 2u);
      }

      uint64_t v12 = *(void *)(*(void *)(a1 + 128) + 16);
      if (v12) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v12 + 8), 1uLL, memory_order_relaxed);
      }
      sub_100555064(a1);
      if (v12) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v12 + 8), 1uLL, memory_order_relaxed);
      }
      id v13 = *(std::__shared_weak_count **)(a1 + 16);
      if (v13 && std::__shared_weak_count::lock(v13)) {
        operator new();
      }
      sub_100088B9C();
    }
    uint64_t v5 = *(void *)(a1 + 128);
    if (!*(unsigned char *)(v5 + 40)
      && *(unsigned char *)(a1 + 64)
      && ((*(uint64_t (**)(void))(**(void **)(v5 + 24) + 8))(*(void *)(v5 + 24)) & 1) == 0)
    {
      uint64_t v6 = *(uint64_t **)(a1 + 128);
      *((unsigned char *)v6 + 40) = 1;
      uint64_t v7 = *(void **)(a1 + 120);
      uint64_t v8 = *v6;
      uint64_t v9 = *(void *)(a1 + 136);
      if (v9) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v9 + 16), 1uLL, memory_order_relaxed);
      }
      id v10 = operator new(0x20uLL);
      void *v10 = off_1019E32B8;
      v10[1] = a1;
      uint64_t v10[2] = v6;
      uint64_t v10[3] = v9;
      void v16[3] = v10;
      [v7 shutDownSatSms:v8 completion:v16];
      sub_100060644(v16);
    }
  }
}

void sub_100554FF0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  sub_100060644((uint64_t *)va);
  _Unwind_Resume(a1);
}

void sub_100555064(uint64_t a1)
{
  uint64_t v2 = sub_100200FB4((id *)(a1 + 24));
  dispatch_assert_queue_V2(v2);

  uint64_t v3 = *(id **)(a1 + 128);
  if (v3)
  {
    id v4 = *v3;
    uint64_t v5 = *(std::__shared_weak_count **)(a1 + 136);
    *(void *)(a1 + 128) = 0;
    *(void *)(a1 + 136) = 0;
    if (v5) {
      sub_10004D2C8(v5);
    }
    uint64_t v6 = *(void **)(a1 + 120);
    if (v6)
    {
      v9[0] = off_1019E3458;
      void v9[3] = v9;
      [v6 cancelSatSmsShutDown:v4 completion:v9];
      sub_100060644(v9);
    }
    else
    {
      uint64_t v7 = sub_100200FB4((id *)(a1 + 40));
      if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)uint64_t v8 = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "[Cancel] No SatSms controller exists", v8, 2u);
      }
    }
  }
}

void sub_100555188(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1005551BC(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v6 = sub_100200FB4((id *)(a1 + 24));
  dispatch_assert_queue_V2(v6);

  if (*(void *)(a1 + 128))
  {
    uint64_t v7 = sub_100200FB4((id *)(a1 + 40));
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "Shutdown is already in progress", buf, 2u);
    }
LABEL_4:

    return 0;
  }
  if (!*(void *)(a1 + 120))
  {
    uint64_t v7 = sub_100200FB4((id *)(a1 + 40));
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "[Shutdown] No SatSms controller exists", buf, 2u);
    }
    goto LABEL_4;
  }
  uint64_t v9 = (char *)operator new(0x50uLL);
  *((void *)v9 + 1) = 0;
  *((void *)v9 + 2) = 0;
  *(_OWORD *)(v9 + 24) = 0u;
  *(void *)uint64_t v9 = off_1019E3338;
  *(_OWORD *)(v9 + 40) = 0u;
  *(_OWORD *)(v9 + 56) = 0u;
  *((void *)v9 + 9) = 0;
  *((void *)v9 + 3) = objc_opt_new();
  *((void *)v9 + 9) = 0;
  *((_OWORD *)v9 + 2) = 0u;
  *((_OWORD *)v9 + 3) = 0u;
  v9[64] = 0;
  id v10 = *(std::__shared_weak_count **)(a1 + 136);
  *(void *)(a1 + 128) = v9 + 24;
  *(void *)(a1 + 136) = v9;
  if (v10) {
    sub_10004D2C8(v10);
  }
  uint64_t v11 = operator new(0x38uLL);
  v11[1] = 0;
  void v11[2] = 0;
  void *v11 = off_1019E3388;
  sub_100023950((uint64_t)(v11 + 3), a3);
  uint64_t v12 = *(void *)(a1 + 128);
  id v13 = *(std::__shared_weak_count **)(v12 + 16);
  *(void *)(v12 + 8) = v11 + 3;
  *(void *)(v12 + 16) = v11;
  if (v13) {
    sub_10004D2C8(v13);
  }
  sub_100058DB0(&v20, "ShutDownSatSmsDebounce");
  uint64_t v14 = operator new(0x28uLL);
  v14[4] = 900000;
  *(_OWORD *)uint64_t v14 = xmmword_1014BB9B8;
  *((_OWORD *)v14 + 1) = unk_1014BB9C8;
  std::string __p = v14;
  v23[0] = off_1019E33D8;
  v23[1] = a1;
  void v23[3] = v23;
  CTDebounceTimer::create();
  uint64_t v15 = *(void *)(a1 + 128);
  long long v16 = *(_OWORD *)buf;
  memset(buf, 0, sizeof(buf));
  uint64_t v17 = *(std::__shared_weak_count **)(v15 + 32);
  *(_OWORD *)(v15 + 24) = v16;
  if (v17)
  {
    sub_10004D2C8(v17);
    if (*(void *)&buf[8]) {
      sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
    }
  }
  sub_10003B34C(v23);
  if (__p) {
    operator delete(__p);
  }
  if (v21 < 0) {
    operator delete(v20);
  }
  *(void *)(*(void *)(a1 + 128) + 48) = *a2;
  uint64_t v18 = sub_100200FB4((id *)(a1 + 40));
  if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#I [RequestQueued] ShutDownSatSms will be attempted (when Internet is available)", buf, 2u);
  }

  sub_100554CF0(a1);
  return 1;
}

void sub_1005554FC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21)
{
  if (__p) {
    operator delete(__p);
  }
  if (a17 < 0) {
    operator delete(a12);
  }
  _Unwind_Resume(a1);
}

BOOL sub_10055555C(uint64_t a1)
{
  uint64_t v2 = sub_100200FB4((id *)(a1 + 24));
  dispatch_assert_queue_V2(v2);

  return *(void *)(a1 + 128) != 0;
}

void sub_1005555A0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1005555B0(uint64_t a1)
{
  uint64_t v2 = sub_100200FB4((id *)(a1 + 24));
  dispatch_assert_queue_V2(v2);

  uint64_t v3 = sub_100200FB4((id *)(a1 + 40));
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v19) = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I [d] *****************************", (uint8_t *)&v19, 2u);
  }

  id v4 = sub_100200FB4((id *)(a1 + 40));
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v19) = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I [d] * StewieIDSController state *", (uint8_t *)&v19, 2u);
  }

  uint64_t v5 = sub_100200FB4((id *)(a1 + 40));
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v19) = 0;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I [d] *****************************", (uint8_t *)&v19, 2u);
  }

  uint64_t v6 = sub_100200FB4((id *)(a1 + 40));
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    if (*(void *)(a1 + 96) || *(void *)(a1 + 104)) {
      uint64_t v7 = "true";
    }
    else {
      uint64_t v7 = "false";
    }
    int v19 = 136315138;
    __int16 v20 = v7;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I [d] Transport Requested: %s", (uint8_t *)&v19, 0xCu);
  }

  uint64_t v8 = sub_100200FB4((id *)(a1 + 40));
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    if (*(unsigned char *)(a1 + 64)) {
      uint64_t v9 = "true";
    }
    else {
      uint64_t v9 = "false";
    }
    int v19 = 136315138;
    __int16 v20 = v9;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I [d] Internet active: %s", (uint8_t *)&v19, 0xCu);
  }

  id v10 = sub_100200FB4((id *)(a1 + 40));
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v11 = *(int *)(a1 + 68);
    if (v11 > 2) {
      uint64_t v12 = "???";
    }
    else {
      uint64_t v12 = off_1019E34C8[v11];
    }
    int v19 = 136315138;
    __int16 v20 = v12;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I [d] Previously reported status: %s", (uint8_t *)&v19, 0xCu);
  }

  id v13 = sub_100200FB4((id *)(a1 + 40));
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    if (*(unsigned char *)(a1 + 72)) {
      uint64_t v14 = "true";
    }
    else {
      uint64_t v14 = "false";
    }
    int v19 = 136315138;
    __int16 v20 = v14;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I [d] Previously reported connected: %s", (uint8_t *)&v19, 0xCu);
  }

  uint64_t v15 = sub_100200FB4((id *)(a1 + 40));
  if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
  {
    if (*(void *)(a1 + 96)) {
      long long v16 = "true";
    }
    else {
      long long v16 = "false";
    }
    int v19 = 136315138;
    __int16 v20 = v16;
    _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I [d] Emergency Messaging Controller instantiated: %s", (uint8_t *)&v19, 0xCu);
  }

  uint64_t v17 = sub_100200FB4((id *)(a1 + 40));
  if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
  {
    if (*(void *)(a1 + 104)) {
      uint64_t v18 = "true";
    }
    else {
      uint64_t v18 = "false";
    }
    int v19 = 136315138;
    __int16 v20 = v18;
    _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I [d] Roadside Messaging Controller instantiated: %s", (uint8_t *)&v19, 0xCu);
  }
}

void sub_1005559B0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1005559D4(uint64_t a1)
{
  sub_100555CFC(a1);

  operator delete();
}

uint64_t *sub_100555A0C(uint64_t *result)
{
  uint64_t v1 = *result;
  *id result = 0;
  if (v1)
  {

    sub_10012577C((const void **)(v1 + 8));
    objc_destroyWeak((id *)v1);
    operator delete();
  }
  return result;
}

uint64_t *sub_100555A6C(uint64_t a1)
{
  uint64_t v4 = a1;
  id WeakRetained = objc_loadWeakRetained((id *)a1);
  [WeakRetained handleTXMessageStatus:a1 + 8 didSendSucceed:*(unsigned __int8 *)(a1 + 16) error:*(void *)(a1 + 24)];

  return sub_100555A0C(&v4);
}

void sub_100555ABC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);

  sub_100555A0C((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t *sub_100555AD4(uint64_t *result)
{
  uint64_t v1 = *result;
  *id result = 0;
  if (v1)
  {

    sub_100060644((void *)(v1 + 24));
    objc_destroyWeak((id *)v1);
    operator delete();
  }
  return result;
}

uint64_t *sub_100555B3C(uint64_t a1)
{
  uint64_t v8 = a1;
  id WeakRetained = objc_loadWeakRetained((id *)a1);
  uint64_t v3 = *(void *)(a1 + 56);
  int v4 = *(unsigned __int8 *)(a1 + 8);
  uint64_t v5 = a1 + 24;
  uint64_t v6 = *(void *)(a1 + 16);
  sub_1000DFC90((uint64_t)v9, v5);
  objc_msgSend(WeakRetained, "handleShutDownSatSmsStatus:success:error:completion:", v3, v4 != 0, v6, v9, v8);
  sub_100060644(v9);

  return sub_100555AD4(&v8);
}

void sub_100555BEC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  sub_100060644(&a10);

  sub_100555AD4(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_100555C1C(uint64_t a1)
{
  uint64_t v8 = a1;
  id WeakRetained = objc_loadWeakRetained((id *)a1);
  uint64_t v3 = *(void *)(a1 + 56);
  int v4 = *(unsigned __int8 *)(a1 + 8);
  uint64_t v5 = a1 + 24;
  uint64_t v6 = *(void *)(a1 + 16);
  sub_1000DFC90((uint64_t)v9, v5);
  objc_msgSend(WeakRetained, "cancelShutDownSatSmsStatus:success:error:completion:", v3, v4 != 0, v6, v9, v8);
  sub_100060644(v9);

  return sub_100555AD4(&v8);
}

void sub_100555CCC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  sub_100060644(&a10);

  sub_100555AD4(&a9);
  _Unwind_Resume(a1);
}

uint64_t sub_100555CFC(uint64_t a1)
{
  *(void *)a1 = off_1019E3088;
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 136);
  if (v2) {
    sub_10004D2C8(v2);
  }

  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 88);
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  int v4 = *(std::__shared_weak_count **)(a1 + 56);
  if (v4) {
    sub_10004D2C8(v4);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 40));
  sub_1004FDE68(a1 + 8);
  return a1;
}

id **sub_100555D94(id **result)
{
  uint64_t v1 = *result;
  *id result = 0;
  if (v1)
  {

    objc_destroyWeak(v1);
    operator delete();
  }
  return result;
}

id **sub_100555DF4(uint64_t a1)
{
  int v4 = (id *)a1;
  id WeakRetained = objc_loadWeakRetained((id *)a1);
  [WeakRetained receivedIncomingMessageData:*(void *)(a1 + 8) context:*(void *)(a1 + 16)];

  return sub_100555D94(&v4);
}

void sub_100555E3C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);

  sub_100555D94((id **)va);
  _Unwind_Resume(a1);
}

id **sub_100555E54(uint64_t a1)
{
  int v4 = (id *)a1;
  id WeakRetained = objc_loadWeakRetained((id *)a1);
  [WeakRetained receivedIncomingMessageData:*(void *)(a1 + 8) context:*(void *)(a1 + 16)];

  return sub_100555D94(&v4);
}

void sub_100555E9C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);

  sub_100555D94((id **)va);
  _Unwind_Resume(a1);
}

void *sub_100555EB4(void *a1, uint64_t a2)
{
  sub_100555F38(a1);
  uint64_t v4 = *(void *)(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      a1[3] = a1;
      (*(void (**)(void, void *))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      a1[3] = v4;
      *(void *)(a2 + 24) = 0;
    }
  }
  else
  {
    a1[3] = 0;
  }
  return a1;
}

void *sub_100555F38(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  a1[3] = 0;
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

id **sub_100555FC0(id **result)
{
  uint64_t v1 = *result;
  *id result = 0;
  if (v1)
  {
    objc_destroyWeak(v1);
    operator delete();
  }
  return result;
}

id **sub_100556010(id *a1)
{
  uint64_t v3 = a1;
  id WeakRetained = objc_loadWeakRetained(a1);
  [WeakRetained initializeService];

  return sub_100555FC0(&v3);
}

void sub_100556050(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);

  sub_100555FC0((id **)va);
  _Unwind_Resume(a1);
}

void sub_100556068(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_1005560F0(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, __int16 a11, char a12, char a13)
{
  __cxa_begin_catch(a1);
  sub_10055611C((uint64_t)&a13, v13);
  __cxa_rethrow();
}

void sub_100556108(_Unwind_Exception *a1)
{
}

void sub_10055611C(uint64_t a1, id *a2)
{
  uint64_t v3 = sub_100200FB4(a2 + 3);
  dispatch_barrier_async_f(v3, a2, (dispatch_function_t)sub_100556268);
}

void sub_100556184(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_1005561BC(uint64_t a1)
{
  uint64_t v1 = *(id **)(a1 + 24);
  uint64_t v2 = sub_100200FB4(v1 + 3);
  dispatch_barrier_async_f(v2, v1, (dispatch_function_t)sub_100556268);
}

uint64_t sub_100556224(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_100556268(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 64))();
  }
  return result;
}

uint64_t *sub_100556294(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v8 = a1;
  uint64_t v9 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v3 = *(std::__shared_weak_count **)(*(void *)v1 + 88);
  if (v3)
  {
    uint64_t v4 = std::__shared_weak_count::lock(v3);
    if (v4)
    {
      uint64_t v5 = v4;
      uint64_t v6 = *(void *)(v2 + 80);
      if (v6) {
        (*(void (**)(uint64_t, uint64_t, uint64_t, void))(*(void *)v6 + 16))(v6, 2, v1 + 8, 0);
      }
      sub_10004D2C8(v5);
    }
  }
  sub_100556354(&v9);
  return sub_100046B58((uint64_t *)&v8);
}

void sub_100556330(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  sub_10004D2C8(v10);
  sub_100556354(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_100556354(uint64_t *result)
{
  uint64_t v1 = *result;
  *id result = 0;
  if (v1)
  {
    sub_10012577C((const void **)(v1 + 8));
    operator delete();
  }
  return result;
}

uint64_t *sub_1005563A4(uint64_t **a1)
{
  uint64_t v1 = *a1;
  uint64_t v3 = a1;
  uint64_t v4 = v1;
  sub_1000607A8(*v1, 1);
  sub_1000E3958((uint64_t *)&v4);
  return sub_100046B58((uint64_t *)&v3);
}

void sub_1005563EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

void *sub_100556408(void *a1)
{
  *a1 = off_1019E32B8;
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_100556454(void *a1)
{
  *a1 = off_1019E32B8;
  uint64_t v1 = (std::__shared_weak_count *)a1[3];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

char *sub_1005564C0(uint64_t a1)
{
  id result = (char *)operator new(0x20uLL);
  *(void *)id result = off_1019E32B8;
  *(_OWORD *)(result + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 24);
  *((void *)result + 3) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_100556524(uint64_t result, uint64_t a2)
{
  *(void *)a2 = off_1019E32B8;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(result + 8);
  uint64_t v2 = *(void *)(result + 24);
  *(void *)(a2 + 24) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100556564(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 24);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_100556574(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete(__p);
}

void sub_1005565B4(void *a1, unsigned __int8 *a2)
{
  int v3 = *a2;
  uint64_t v4 = a1[1];
  uint64_t v5 = sub_100200FB4((id *)(v4 + 24));
  dispatch_assert_queue_V2(v5);

  uint64_t v6 = (std::__shared_weak_count *)a1[3];
  if (v6)
  {
    uint64_t v7 = std::__shared_weak_count::lock(v6);
    if (v7)
    {
      uint64_t v8 = v7;
      if (a1[2])
      {
        uint64_t v9 = *(void *)(v4 + 128);
        *(unsigned char *)(v9 + 40) = 0;
        if (v3)
        {
          uint64_t v11 = *(void *)(v9 + 8);
          id v10 = *(std::__shared_weak_count **)(v9 + 16);
          if (v10) {
            atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          uint64_t v12 = *(std::__shared_weak_count **)(v4 + 136);
          *(void *)(v4 + 128) = 0;
          *(void *)(v4 + 136) = 0;
          if (v12) {
            sub_10004D2C8(v12);
          }
          sub_1000607A8(v11, 0);
          if (v10) {
            sub_10004D2C8(v10);
          }
        }
        else
        {
          id v13 = sub_100200FB4((id *)(v4 + 40));
          if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)uint64_t v17 = 0;
            _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I Starting debounce timer", v17, 2u);
          }

          uint64_t v14 = objc_opt_new();
          uint64_t v15 = *(void ***)(v4 + 128);
          long long v16 = *v15;
          *uint64_t v15 = (void *)v14;

          (***(void (****)(void))(*(void *)(v4 + 128) + 24))(*(void *)(*(void *)(v4 + 128) + 24));
        }
      }
      sub_10004D2C8(v8);
    }
  }
}

void sub_100556704(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_10055673C(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_10055677C()
{
}

void sub_100556788(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1019E3338;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1005567A8(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1019E3338;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_1005567FC(void *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[7];
  if (v2) {
    sub_10004D2C8(v2);
  }
  int v3 = (std::__shared_weak_count *)a1[5];
  if (v3) {
    sub_10004D2C8(v3);
  }
  uint64_t v4 = (void *)a1[3];
}

void sub_10055684C(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1019E3388;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_10055686C(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1019E3388;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void *sub_1005568C0(uint64_t a1)
{
  return sub_100060644((void *)(a1 + 24));
}

void sub_1005568D0()
{
}

void *sub_1005568E4(uint64_t a1)
{
  id result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *id result = off_1019E33D8;
  result[1] = v3;
  return result;
}

uint64_t sub_10055692C(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019E33D8;
  a2[1] = v2;
  return result;
}

void sub_100556958(uint64_t a1)
{
}

uint64_t sub_100556960(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1005569A0()
{
}

void sub_1005569B0()
{
}

void *sub_1005569C4()
{
  id result = operator new(0x10uLL);
  *id result = off_1019E3458;
  return result;
}

void sub_1005569FC(uint64_t a1, void *a2)
{
  *a2 = off_1019E3458;
}

uint64_t sub_100556A28(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_100556A68()
{
}

void sub_100556A74(uint64_t **a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  uint64_t v3 = *(std::__shared_weak_count **)(v2 + 88);
  if (v3)
  {
    uint64_t v4 = std::__shared_weak_count::lock(v3);
    if (v4)
    {
      uint64_t v5 = v4;
      uint64_t v6 = *(void (****)(void, uint64_t, void, void))(v2 + 80);
      if (v6)
      {
        uint64_t v7 = sub_100200FB4((id *)(v2 + 40));
        if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v8 = *((int *)v1 + 2);
          if (v8 > 2) {
            uint64_t v9 = "???";
          }
          else {
            uint64_t v9 = off_1019E34C8[v8];
          }
          id v10 = "";
          if (!*((unsigned char *)v1 + 12)) {
            id v10 = "not ";
          }
          *(_DWORD *)long long buf = 136315394;
          uint64_t v12 = v9;
          __int16 v13 = 2080;
          uint64_t v14 = v10;
          _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I IDS transport status: (%s, %sconnected)", buf, 0x16u);
        }

        (**v6)(v6, 2, *((unsigned int *)v1 + 2), *((unsigned __int8 *)v1 + 12));
      }
      sub_10004D2C8(v5);
    }
  }
  operator delete();
}

void sub_100556BF0()
{
  sub_10004D2C8(v0);
  operator delete();
}

void sub_100556C38()
{
}

void sub_100556D50(_Unwind_Exception *exception_object)
{
  if (v3)
  {
    sub_10004D2C8(v3);
    if (!v2)
    {
LABEL_3:
      if (!v1) {
        goto LABEL_4;
      }
      goto LABEL_9;
    }
  }
  else if (!v2)
  {
    goto LABEL_3;
  }
  sub_10004D2C8(v2);
  if (!v1)
  {
LABEL_4:
    if (v4) {
      goto LABEL_5;
    }
    goto LABEL_6;
  }
LABEL_9:
  dispatch_release(v1);
  if (v4) {
LABEL_5:
  }
    operator delete();
LABEL_6:
  _Unwind_Resume(exception_object);
}

void sub_100556DAC(uint64_t a1)
{
  *(void *)a1 = off_1019E34F0;
  if (*(unsigned char *)(a1 + 200) && *(char *)(a1 + 199) < 0) {
    operator delete(*(void **)(a1 + 176));
  }
  if (*(unsigned char *)(a1 + 168) && *(char *)(a1 + 167) < 0) {
    operator delete(*(void **)(a1 + 144));
  }
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 136);
  if (v2) {
    sub_10004D2C8(v2);
  }
  sub_10010C0E0(a1 + 96, *(void **)(a1 + 104));
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 88);
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  int v4 = *(std::__shared_weak_count **)(a1 + 72);
  if (v4) {
    sub_10004D2C8(v4);
  }
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 56);
  if (v5) {
    sub_10004D2C8(v5);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 40));
  sub_100087E88((void *)(a1 + 8));

  CellularPlanProvisioningMonitorModeDelegate::~CellularPlanProvisioningMonitorModeDelegate((CellularPlanProvisioningMonitorModeDelegate *)a1);
}

void sub_100556E80(uint64_t a1)
{
  sub_100556DAC(a1);

  operator delete();
}

uint64_t sub_100556EB8(uint64_t a1, dispatch_object_t *a2, void *a3, void *a4)
{
  *(void *)a1 = off_101AB94D8;
  uint64_t v8 = (void *)(a1 + 8);
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v16, kCtLoggingSystemName, "cp.ol.ctr");
  void *v8 = 0;
  v8[1] = 0;
  uint64_t v9 = *a2;
  *(void *)(a1 + 24) = *a2;
  if (v9) {
    dispatch_retain(v9);
  }
  *(void *)(a1 + 32) = 0;
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v17, &v16);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 40), (const ctu::OsLogLogger *)v17);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v17);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v16);
  *(void *)a1 = off_1019E34F0;
  *(void *)(a1 + 48) = *a4;
  uint64_t v10 = a4[1];
  *(void *)(a1 + 56) = v10;
  if (v10) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v10 + 8), 1uLL, memory_order_relaxed);
  }
  sub_100058DB0(&__p, "OffloadController");
  __int16 v13 = *a2;
  if (*a2) {
    dispatch_retain(*a2);
  }
  ctu::RestModule::RestModule();
  if (v13) {
    dispatch_release(v13);
  }
  if (v15 < 0) {
    operator delete(__p);
  }
  *(void *)(a1 + 80) = *a3;
  uint64_t v11 = a3[1];
  *(void *)(a1 + 88) = v11;
  if (v11) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v11 + 16), 1uLL, memory_order_relaxed);
  }
  *(void *)(a1 + 112) = 0;
  *(void *)(a1 + 104) = 0;
  *(void *)(a1 + 96) = a1 + 104;
  *(unsigned char *)(a1 + 120) = 0;
  *(unsigned char *)(a1 + 168) = 0;
  *(unsigned char *)(a1 + 176) = 0;
  *(unsigned char *)(a1 + 200) = 0;
  *(void *)(a1 + 128) = 0;
  *(void *)(a1 + 136) = 0;
  *(unsigned char *)(a1 + 144) = 0;
  return a1;
}

void sub_100557068(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, dispatch_object_t object, dispatch_object_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17, uint64_t a18, char a19)
{
  if (object) {
    dispatch_release(object);
  }
  if (a10) {
    dispatch_release(a10);
  }
  if (a16 < 0) {
    operator delete(__p);
  }
  uint64_t v23 = (std::__shared_weak_count *)*((void *)v19 + 7);
  if (v23) {
    sub_10004D2C8(v23);
  }
  ctu::OsLogLogger::~OsLogLogger(v21);
  sub_100087E88(v20);
  CellularPlanProvisioningMonitorModeDelegate::~CellularPlanProvisioningMonitorModeDelegate(v19);
  _Unwind_Resume(a1);
}

void sub_1005570F8(uint64_t a1)
{
  (***(void (****)(uint8_t *__return_ptr))(a1 + 48))(v27);
  Registry::createRestModuleOneTimeUseConnection(&v22, *(Registry **)v27);
  ctu::RestModule::connect();
  if (v23) {
    sub_10004D2C8(v23);
  }
  if (v28) {
    sub_10004D2C8(v28);
  }
  sub_100058DB0(&buf, "/cc/props/bound_sims");
  uint64_t v2 = operator new(0x28uLL);
  void *v2 = off_1019E36C8;
  v2[1] = a1 + 96;
  void v2[2] = a1;
  v2[3] = sub_100557708;
  v2[4] = 0;
  uint64_t v30 = (void *(*)(void *, void *))v2;
  ctu::RestModule::observeProperty();
  sub_10003F600(v27);
  if (SHIBYTE(v35) < 0) {
    operator delete((void *)buf);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 88);
  if (v3)
  {
    int v4 = std::__shared_weak_count::lock(v3);
    if (v4)
    {
      uint64_t v5 = *(void *)(a1 + 80);
      if (v5)
      {
        (***(void (****)(uint8_t *__return_ptr))(a1 + 48))(v27);
        ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)v27);
        uint64_t v7 = ServiceMap;
        if (v8 < 0)
        {
          uint64_t v9 = (unsigned __int8 *)(v8 & 0x7FFFFFFFFFFFFFFFLL);
          uint64_t v10 = 5381;
          do
          {
            uint64_t v8 = v10;
            unsigned int v11 = *v9++;
            uint64_t v10 = (33 * v10) ^ v11;
          }
          while (v11);
        }
        std::mutex::lock(ServiceMap);
        *(void *)&long long buf = v8;
        uint64_t v12 = sub_10004D37C(&v7[1].__m_.__sig, (unint64_t *)&buf);
        if (v12)
        {
          uint64_t v14 = v12[3];
          __int16 v13 = (std::__shared_weak_count *)v12[4];
          if (v13)
          {
            atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
            std::mutex::unlock(v7);
            atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
            sub_10004D2C8(v13);
            char v15 = 0;
LABEL_24:
            if (v28) {
              sub_10004D2C8(v28);
            }
            if (v14)
            {
              CFDictionaryRef theDict = 0;
              (*(void (**)(uint8_t *__return_ptr, uint64_t, const __CFString *, void, const CFStringRef, const CFStringRef))(*(void *)v14 + 40))(v27, v14, @"offloadBindingPairs", kCommCenterPreferencesNoBackupAppID, kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
              sub_10004EFE4(&theDict, (CFTypeRef *)v27);
              sub_1000577C4((const void **)v27);
              if (theDict) {
                uint64_t v17 = sub_100080778;
              }
              else {
                uint64_t v17 = 0;
              }
              if (v17)
              {
                *(void *)uint64_t v27 = 0;
                uint64_t v28 = (std::__shared_weak_count *)v27;
                uint64_t v29 = 0x4002000000;
                uint64_t v30 = sub_1005581F8;
                v33[0] = 0;
                v33[1] = 0;
                BOOL v31 = sub_100558234;
                uint64_t v32 = v33;
                v24[0] = _NSConcreteStackBlock;
                v24[1] = 0x40000000;
                void v24[2] = sub_100558244;
                v24[3] = &unk_1019E3538;
                uint8_t v24[4] = v27;
                *(void *)&long long buf = _NSConcreteStackBlock;
                *((void *)&buf + 1) = 0x40000000;
                BOOL v35 = sub_100559524;
                uint64_t v36 = &unk_1019E3770;
                uint64_t v37 = v24;
                context = &buf;
                CFDictionaryApplyFunction(theDict, (CFDictionaryApplierFunction)sub_1005595C4, &context);
                uint64_t v18 = *(NSObject **)(a1 + 40);
                if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
                {
                  uint64_t shared_owners = v28[2].__shared_owners_;
                  LODWORD(buf) = 134217984;
                  *(void *)((char *)&buf + 4) = shared_owners;
                  _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#I load bound info (%lu)", (uint8_t *)&buf, 0xCu);
                }
                (*(void (**)(uint64_t, uint64_t *))(*(void *)v5 + 24))(v5, &v28[1].__shared_weak_owners_);
                _Block_object_dispose(v27, 8);
                sub_10010C0E0((uint64_t)&v32, v33[0]);
              }
              else
              {
                char v21 = *(NSObject **)(a1 + 40);
                if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
                {
                  *(_WORD *)uint64_t v27 = 0;
                  _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "#I dictRef is null", v27, 2u);
                }
              }
              sub_100057D78((const void **)&theDict);
            }
            else
            {
              __int16 v20 = *(NSObject **)(a1 + 40);
              if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
              {
                *(_WORD *)uint64_t v27 = 0;
                _os_log_error_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, "Cannot get Preference", v27, 2u);
              }
            }
            if ((v15 & 1) == 0) {
              sub_10004D2C8(v13);
            }
            goto LABEL_19;
          }
        }
        else
        {
          uint64_t v14 = 0;
        }
        std::mutex::unlock(v7);
        __int16 v13 = 0;
        char v15 = 1;
        goto LABEL_24;
      }
    }
  }
  else
  {
    int v4 = 0;
  }
  OsLogContext v16 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)uint64_t v27 = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "Cannot get delegate", v27, 2u);
  }
LABEL_19:
  if (v4) {
    sub_10004D2C8(v4);
  }
}

void sub_100557634(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  sub_1000577C4((const void **)va);
  if ((v13 & 1) == 0) {
    sub_10004D2C8(v12);
  }
  sub_10004D2C8(v11);
  _Unwind_Resume(a1);
}

void sub_100557708(uint64_t a1)
{
  (***(void (****)(long long *__return_ptr))(a1 + 48))(&key);
  ServiceMap = (std::mutex *)Registry::getServiceMap((Registry *)key);
  uint64_t v3 = ServiceMap;
  if (v4 < 0)
  {
    uint64_t v5 = (unsigned __int8 *)(v4 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v6 = 5381;
    do
    {
      uint64_t v4 = v6;
      unsigned int v7 = *v5++;
      uint64_t v6 = (33 * v6) ^ v7;
    }
    while (v7);
  }
  std::mutex::lock(ServiceMap);
  uint64_t v31 = v4;
  uint64_t v8 = sub_10004D37C(&v3[1].__m_.__sig, (unint64_t *)&v31);
  if (v8)
  {
    uint64_t v10 = v8[3];
    uint64_t v9 = (std::__shared_weak_count *)v8[4];
    if (v9)
    {
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v3);
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v9);
      char v11 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v10 = 0;
  }
  std::mutex::unlock(v3);
  uint64_t v9 = 0;
  char v11 = 1;
LABEL_9:
  if (*((void *)&key + 1)) {
    sub_10004D2C8(*((std::__shared_weak_count **)&key + 1));
  }
  if (v10)
  {
    CFMutableDictionaryRef v28 = 0;
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    if (Mutable)
    {
      CFMutableDictionaryRef v13 = v28;
      CFMutableDictionaryRef v28 = Mutable;
      *(void *)&long long key = v13;
      sub_10005717C((const void **)&key);
    }
    uint64_t v14 = *(void **)(a1 + 96);
    if (v14 != (void *)(a1 + 104))
    {
      do
      {
        char v15 = (const char *)(v14 + 4);
        if (*((char *)v14 + 55) < 0) {
          char v15 = *(const char **)v15;
        }
        ctu::cf::MakeCFString::MakeCFString((ctu::cf::MakeCFString *)v27, v15);
        OsLogContext v16 = (const char *)(v14 + 7);
        if (*((char *)v14 + 79) < 0) {
          OsLogContext v16 = *(const char **)v16;
        }
        ctu::cf::MakeCFString::MakeCFString((ctu::cf::MakeCFString *)&v26, v16);
        uint64_t v17 = v28;
        ctu::cf::MakeCFString::MakeCFString((ctu::cf::MakeCFString *)&cf, (const ctu::cf::MakeCFString *)v27);
        ctu::cf::MakeCFString::MakeCFString((ctu::cf::MakeCFString *)&v29, (const ctu::cf::MakeCFString *)&v26);
        *(void *)&long long key = cf;
        if (cf) {
          CFRetain(cf);
        }
        CFTypeRef v18 = v29;
        uint64_t v31 = (uint64_t)v29;
        if (v29)
        {
          CFRetain(v29);
          if ((void)key) {
            CFDictionaryAddValue(v17, (const void *)key, v18);
          }
        }
        sub_10010F494((const void **)&v31);
        sub_10010F494((const void **)&key);
        ctu::cf::MakeCFString::~MakeCFString((ctu::cf::MakeCFString *)&v29);
        ctu::cf::MakeCFString::~MakeCFString((ctu::cf::MakeCFString *)&cf);
        ctu::cf::MakeCFString::~MakeCFString((ctu::cf::MakeCFString *)&v26);
        ctu::cf::MakeCFString::~MakeCFString((ctu::cf::MakeCFString *)v27);
        int v19 = (void *)v14[1];
        if (v19)
        {
          do
          {
            __int16 v20 = v19;
            int v19 = (void *)*v19;
          }
          while (v19);
        }
        else
        {
          do
          {
            __int16 v20 = (void *)v14[2];
            BOOL v21 = *v20 == (void)v14;
            uint64_t v14 = v20;
          }
          while (!v21);
        }
        uint64_t v14 = v20;
      }
      while (v20 != (void *)(a1 + 104));
    }
    uint64_t v22 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v23 = *(void *)(a1 + 112);
      LODWORD(key) = 134217984;
      *(void *)((char *)&key + 4) = v23;
      _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "#I Save Bound SIM (%lu)", (uint8_t *)&key, 0xCu);
    }
    uint64_t v24 = kCommCenterPreferencesNoBackupAppID;
    (*(void (**)(uint64_t, const __CFString *, CFMutableDictionaryRef, void, const CFStringRef, const CFStringRef))(*(void *)v10 + 16))(v10, @"offloadBindingPairs", v28, kCommCenterPreferencesNoBackupAppID, kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
    (*(void (**)(uint64_t, uint64_t, const CFStringRef, const CFStringRef))(*(void *)v10 + 48))(v10, v24, kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
    sub_10005717C((const void **)&v28);
  }
  else
  {
    unint64_t v25 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(key) = 0;
      _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "#I Cannot get Preference", (uint8_t *)&key, 2u);
    }
  }
  if ((v11 & 1) == 0) {
    sub_10004D2C8(v9);
  }
}

void sub_100557ABC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, int a11, __int16 a12, char a13, char a14, int a15, __int16 a16, char a17, char a18, int a19, __int16 a20,char a21,char a22,int a23,__int16 a24,char a25,char a26,int a27,__int16 a28,char a29,char a30,uint64_t a31)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100557B68(uint64_t a1)
{
  return ctu::RestModule::disconnect((ctu::RestModule *)(a1 + 64));
}

uint64_t sub_100557B70(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 120);
}

void sub_100557B78(uint64_t a1, uint64_t a2, const std::string *a3, const std::string *a4, char a5)
{
  sub_100179AF8((std::string *)(a1 + 176), a3);
  sub_100179AF8((std::string *)(a1 + 144), a4);
  if (*(char *)(a2 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)a2;
    xpc_object_t __p[2] = *(void **)(a2 + 16);
  }
  char v11 = a5;
  uint64_t v9 = *(std::__shared_weak_count **)(a1 + 16);
  if (v9)
  {
    if (std::__shared_weak_count::lock(v9)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100557CF0(void *a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v5 = a1[5];
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    if (*((char *)a3 + 23) < 0) {
      a3 = (uint64_t *)*a3;
    }
    *(_DWORD *)long long buf = 136315394;
    uint64_t v8 = a3;
    __int16 v9 = 2080;
    uint64_t v10 = printers::asString();
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I OffloadRecovery for SignUpForSimService(%s) is completed Success?=%s", buf, 0x16u);
  }
  uint64_t v6 = (std::__shared_weak_count *)a1[17];
  a1[16] = 0;
  a1[17] = 0;
  if (v6) {
    sub_10004D2C8(v6);
  }
}

void sub_100557DD0(long long *a1, long long *a2)
{
  if (*((char *)a2 + 23) < 0)
  {
    sub_10004FC84(&__dst, *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long __dst = *a2;
    uint64_t v10 = *((void *)a2 + 2);
  }
  sub_1000593FC((uint64_t)v6, a1 + 11);
  sub_1000593FC((uint64_t)__p, a1 + 9);
  (*(void (**)(long long *, long long *, void **, void **, void))(*(void *)a1 + 48))(a1, &__dst, v6, __p, 0);
  if (v5 && v4 < 0) {
    operator delete(__p[0]);
  }
  if (v8 && v7 < 0) {
    operator delete(v6[0]);
  }
  if (SHIBYTE(v10) < 0) {
    operator delete((void *)__dst);
  }
}

void sub_100557EB4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,char a22)
{
  if (a15 && a14 < 0) {
    operator delete(__p);
  }
  if (a22 && a21 < 0) {
    operator delete(a16);
  }
  if (*(char *)(v22 - 25) < 0) {
    operator delete(*(void **)(v22 - 48));
  }
  _Unwind_Resume(exception_object);
}

void sub_100557F10(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(unsigned __int8 *)(a3 + 23);
  if ((v3 & 0x80u) != 0) {
    uint64_t v3 = *(void *)(a3 + 8);
  }
  if (v3)
  {
    char v5 = *(std::__shared_weak_count **)(a1 + 88);
    if (v5)
    {
      char v8 = std::__shared_weak_count::lock(v5);
      if (v8)
      {
        __int16 v9 = v8;
        uint64_t v10 = *(void *)(a1 + 80);
        if (v10) {
          (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v10 + 16))(v10, a2, a3);
        }
        sub_10004D2C8(v9);
      }
    }
  }
}

void sub_100557FC4(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_100557FD8(void *a1, uint64_t *a2, int a3)
{
  uint64_t v6 = a1[5];
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    char v7 = (uint64_t *)*a2;
    char v8 = "False";
    if (*((char *)a2 + 23) >= 0) {
      char v7 = a2;
    }
    if (a3) {
      char v8 = "True";
    }
    int v16 = 136315394;
    uint64_t v17 = v7;
    __int16 v18 = 2080;
    int v19 = v8;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I trying to install iccid=%s useDS=%s", (uint8_t *)&v16, 0x16u);
  }
  __int16 v9 = (std::__shared_weak_count *)a1[11];
  if (v9)
  {
    uint64_t v10 = std::__shared_weak_count::lock(v9);
    if (v10)
    {
      char v11 = v10;
      uint64_t v12 = (void *)a1[10];
      if (v12)
      {
        if ((*(unsigned int (**)(void, uint64_t *))*v12)(a1[10], a2))
        {
          CFMutableDictionaryRef v13 = a1[5];
          if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
          {
            if (*((char *)a2 + 23) >= 0) {
              uint64_t v14 = a2;
            }
            else {
              uint64_t v14 = (uint64_t *)*a2;
            }
            int v16 = 136315138;
            uint64_t v17 = v14;
            _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I iccid %s already installed", (uint8_t *)&v16, 0xCu);
          }
          char v15 = (void (**)(void *, uint64_t *))(*v12 + 32);
          goto LABEL_19;
        }
        if (a3)
        {
          char v15 = (void (**)(void *, uint64_t *))(*v12 + 8);
LABEL_19:
          (*v15)(v12, a2);
        }
      }
      sub_10004D2C8(v11);
    }
  }
}

void sub_1005581E4(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void *sub_1005581F8(void *result, void *a2)
{
  result[5] = a2[5];
  uint64_t v2 = a2 + 6;
  uint64_t v3 = a2[6];
  result[6] = v3;
  char v4 = result + 6;
  uint64_t v5 = a2[7];
  result[7] = v5;
  if (v5)
  {
    *(void *)(v3 + 16) = v4;
    a2[5] = v2;
    void *v2 = 0;
    a2[7] = 0;
  }
  else
  {
    result[5] = v4;
  }
  return result;
}

void sub_100558234(uint64_t a1)
{
}

void sub_100558244(uint64_t a1)
{
  ctu::cf::assign();
  *(_OWORD *)uint64_t v5 = 0uLL;
  uint64_t v6 = 0;
  long long v7 = 0uLL;
  uint64_t v8 = 0;
  ctu::cf::assign();
  memset(&__p, 0, sizeof(__p));
  uint64_t v2 = (uint64_t **)(*(void *)(*(void *)(a1 + 32) + 8) + 40);
  *(void *)&long long v7 = v5;
  uint64_t v3 = sub_100366370(v2, v5, (uint64_t)&unk_10144E20E, (long long **)&v7);
  std::string::operator=((std::string *)(v3 + 7), &__p);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v6) < 0) {
    operator delete(v5[0]);
  }
}

void sub_100558310(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (*(char *)(v21 - 25) < 0) {
    operator delete(*(void **)(v21 - 48));
  }
  if (a21 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100558368(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_100558434(void *a1)
{
  __cxa_begin_catch(a1);
  dispatch_barrier_async_f(v1[3], v1, (dispatch_function_t)sub_10055850C);
  __cxa_rethrow();
}

void sub_10055845C(_Unwind_Exception *a1)
{
}

void sub_100558474(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_1005584AC(uint64_t a1)
{
}

uint64_t sub_1005584C8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_10055850C(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void sub_10055853C()
{
}

__n128 sub_100558550(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_1019E36C8;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_1005585A4(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019E36C8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_1005585DC(uint64_t *a1, xpc_object_t *a2)
{
  sub_100314828(a1[1], a2);
  uint64_t v3 = (uint64_t (*)(void *))a1[3];
  uint64_t v4 = a1[4];
  uint64_t v5 = (void *)(a1[2] + (v4 >> 1));
  if (v4) {
    uint64_t v3 = *(uint64_t (**)(void *))(*v5 + v3);
  }

  return v3(v5);
}

uint64_t sub_100558658(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100558698()
{
}

uint64_t *sub_1005586A4(uint64_t *a1)
{
  void (***v13)(uint64_t *__return_ptr, void, long long *);
  char v14;
  uint64_t *v15;
  std::__shared_weak_count *v16;
  std::__shared_weak_count *v17;
  std::__shared_weak_count *v18;
  unsigned int (***v19)(void, long long *);
  std::string::size_type size;
  std::__shared_weak_count *v21;
  uint64_t v22;
  std::__shared_weak_count *v23;
  std::__shared_weak_count *v24;
  atomic_ullong *p_shared_weak_owners;
  NSObject *v26;
  uint64_t v27;
  long long v28;
  uint64_t *v30;
  uint64_t v31;
  long long *v32;
  uint8_t buf[16];
  void *v34[2];
  long long v35;
  void *__p[2];
  long long v37;
  uint64_t v38;
  void *__src[2];
  void (*v40)(uint64_t, uint64_t, int);
  std::string v41[8];
  long long v42;
  long long v43;
  long long v44;
  uint64_t v45;
  uint64_t v46;
  std::__shared_weak_count *v47;
  long long __dst;
  uint64_t v49;
  long long *v50[2];
  long long v51;
  void (*v52)(uint64_t, uint64_t, int);
  long long v53;
  uint64_t v54;
  std::__shared_weak_count *v55;
  long long v56;
  uint64_t v57;
  char v58;

  uint64_t v1 = *a1;
  uint64_t v30 = a1;
  uint64_t v31 = v1;
  uint64_t v2 = *(void *)v1;
  long long __dst = 0uLL;
  long long v49 = 0;
  uint64_t v3 = (long long *)(v1 + 8);
  if (*(char *)(v1 + 31) < 0)
  {
    sub_10004FC84(&__dst, *(void **)(v1 + 8), *(void *)(v1 + 16));
  }
  else
  {
    long long v4 = *v3;
    long long v49 = *(void *)(v1 + 24);
    long long __dst = v4;
  }
  uint64_t v46 = 0;
  long long v47 = 0;
  (***(void (****)(std::string *__return_ptr))(v2 + 48))(v41);
  ServiceMap = (std::mutex *)Registry::getServiceMap((Registry *)v41[0].__r_.__value_.__l.__data_);
  uint64_t v6 = ServiceMap;
  if (v7 < 0)
  {
    uint64_t v8 = (unsigned __int8 *)(v7 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v9 = 5381;
    do
    {
      uint64_t v7 = v9;
      unsigned int v10 = *v8++;
      uint64_t v9 = (33 * v9) ^ v10;
    }
    while (v10);
  }
  std::mutex::lock(ServiceMap);
  *(void *)long long buf = v7;
  char v11 = sub_10004D37C(&v6[1].__m_.__sig, (unint64_t *)buf);
  if (v11)
  {
    CFMutableDictionaryRef v13 = (void (***)(uint64_t *__return_ptr, void, long long *))v11[3];
    uint64_t v12 = (std::__shared_weak_count *)v11[4];
    if (v12)
    {
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v6);
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v12);
      uint64_t v14 = 0;
      goto LABEL_12;
    }
  }
  else
  {
    CFMutableDictionaryRef v13 = 0;
  }
  std::mutex::unlock(v6);
  uint64_t v12 = 0;
  uint64_t v14 = 1;
LABEL_12:
  (**v13)(&v46, v13, &__dst);
  if ((v14 & 1) == 0) {
    sub_10004D2C8(v12);
  }
  if (v41[0].__r_.__value_.__l.__size_) {
    sub_10004D2C8((std::__shared_weak_count *)v41[0].__r_.__value_.__l.__size_);
  }
  uint64_t v45 = 0;
  long long v43 = 0u;
  char v44 = 0u;
  uint64_t v42 = 0u;
  memset(v41, 0, sizeof(v41));
  std::string::operator=(v41, (const std::string *)(v1 + 8));
  __src[0] = 0;
  __src[1] = 0;
  uint64_t v40 = 0;
  memset(buf, 0, sizeof(buf));
  v34[0] = 0;
  sub_100346B40((uint64_t)buf, v2 + 96);
  long long v51 = 0uLL;
  uint64_t v52 = 0;
  v50[0] = (long long *)(v1 + 8);
  char v15 = sub_100366370((uint64_t **)buf, (void **)(v1 + 8), (uint64_t)&unk_10144E20E, v50);
  if (*((char *)v15 + 79) < 0)
  {
    sub_10004FC84(&v51, (void *)v15[7], v15[8]);
  }
  else
  {
    long long v51 = *(_OWORD *)(v15 + 7);
    uint64_t v52 = (void (*)(uint64_t, uint64_t, int))v15[9];
  }
  int v16 = *(std::__shared_weak_count **)(v2 + 88);
  if (v16)
  {
    uint64_t v17 = std::__shared_weak_count::lock(v16);
    if (v17)
    {
      __int16 v18 = v17;
      int v19 = *(unsigned int (****)(void, long long *))(v2 + 80);
      if (v19 && (**v19)(v19, &v51))
      {
        *(_OWORD *)__srCC_SHA256_CTX c = v51;
        uint64_t v40 = v52;
        uint64_t v52 = 0;
        long long v51 = 0uLL;
        sub_10004D2C8(v18);
        goto LABEL_26;
      }
      sub_10004D2C8(v18);
    }
  }
  sub_100058DB0(__src, "");
LABEL_26:
  if (SHIBYTE(v52) < 0) {
    operator delete((void *)v51);
  }
  sub_10010C0E0((uint64_t)buf, *(void **)&buf[8]);
  if (SHIBYTE(v40) < 0)
  {
    if (!__src[1]) {
      goto LABEL_35;
    }
    sub_10004FC84(&v51, __src[0], (unint64_t)__src[1]);
  }
  else
  {
    if (!HIBYTE(v40)) {
      goto LABEL_35;
    }
    long long v51 = *(_OWORD *)__src;
    uint64_t v52 = v40;
  }
  memset(buf, 0, sizeof(buf));
  v34[0] = 0;
  v50[0] = (long long *)buf;
  v50[1] = 0;
  *(void *)long long buf = operator new(0x18uLL);
  *(void *)&uint8_t buf[8] = *(void *)buf;
  v34[0] = (void *)(*(void *)buf + 24);
  *(void *)&uint8_t buf[8] = sub_1000D8A18((uint64_t)v34, &v51, &v53, *(char **)buf);
  sub_100558E34((uint64_t)&v41[2].__r_.__value_.__l.__size_, (uint64_t)buf);
  v50[0] = (long long *)buf;
  sub_100047F64((void ***)v50);
  if (SHIBYTE(v52) < 0) {
    operator delete((void *)v51);
  }
LABEL_35:
  if (BYTE8(v43))
  {
    sub_10003ECB8((std::string *)&v42, "private-net-provisioning", 0x18uLL);
  }
  else
  {
    sub_100058DB0(&v42, "private-net-provisioning");
    BYTE8(v43) = 1;
  }
  sub_100179AF8(&v41[1], (const std::string *)(v2 + 176));
  sub_100179AF8((std::string *)&v41[3].__r_.__value_.__r.__words[2], (const std::string *)(v2 + 144));
  std::string::size_type size = HIBYTE(v41[0].__r_.__value_.__r.__words[2]);
  if ((v41[0].__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
    std::string::size_type size = v41[0].__r_.__value_.__l.__size_;
  }
  if (size)
  {
    uint64_t v21 = *(std::__shared_weak_count **)(v2 + 16);
    if (!v21 || (uint64_t v22 = *(void *)(v2 + 8), (v23 = std::__shared_weak_count::lock(v21)) == 0)) {
      sub_100088B9C();
    }
    uint64_t v24 = v23;
    p_shared_weak_owners = &v23->__shared_weak_owners_;
    atomic_fetch_add_explicit(&v23->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v23);
    *(unsigned char *)(v2 + 120) = 1;
    uint64_t v26 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "#I send signUpForSIMService request", buf, 2u);
    }
    uint64_t v38 = 0;
    *(_OWORD *)std::string __p = 0u;
    uint64_t v37 = 0u;
    *(_OWORD *)uint64_t v34 = 0u;
    BOOL v35 = 0u;
    *(_OWORD *)long long buf = 0u;
    uint64_t v27 = v46;
    LODWORD(v50[0]) = 18;
    BYTE4(v50[0]) = 1;
    *(void *)&long long v51 = _NSConcreteStackBlock;
    *((void *)&v51 + 1) = 1174405120;
    uint64_t v52 = sub_100558EB0;
    *(void *)&long long v53 = &unk_1019E3738;
    *((void *)&v53 + 1) = v2;
    long long v54 = v22;
    long long v55 = v24;
    atomic_fetch_add_explicit(p_shared_weak_owners, 1uLL, memory_order_relaxed);
    if (*(char *)(v1 + 31) < 0)
    {
      sub_10004FC84(&v56, *(void **)(v1 + 8), *(void *)(v1 + 16));
    }
    else
    {
      CFMutableDictionaryRef v28 = *v3;
      uint64_t v57 = *(void *)(v1 + 24);
      uint64_t v56 = v28;
    }
    xpc_object_t v58 = *(unsigned char *)(v1 + 32);
    uint64_t v32 = &v51;
    (*(void (**)(uint64_t, uint64_t, uint8_t *, long long **, std::string *, uint64_t, long long **))(*(void *)v27 + 160))(v27, 9, buf, v50, v41, v2 + 24, &v32);
    if (SHIBYTE(v57) < 0) {
      operator delete((void *)v56);
    }
    if (v55) {
      std::__shared_weak_count::__release_weak(v55);
    }
    if ((_BYTE)v38 && SHIBYTE(v37) < 0) {
      operator delete(__p[1]);
    }
    if (LOBYTE(__p[0]) && SHIBYTE(v35) < 0) {
      operator delete(v34[1]);
    }
    std::__shared_weak_count::__release_weak(v24);
  }
  if (SHIBYTE(v40) < 0) {
    operator delete(__src[0]);
  }
  sub_10019F1F4((uint64_t)v41);
  if (v47) {
    sub_10004D2C8(v47);
  }
  if (SHIBYTE(v49) < 0) {
    operator delete((void *)__dst);
  }
  sub_10023CBF8(&v31);
  return sub_100046B58((uint64_t *)&v30);
}

void sub_100558CB4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,char a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28,char a29,uint64_t a30,void *a31,uint64_t a32,int a33,__int16 a34,char a35,char a36,uint64_t a37,char a38,uint64_t a39)
{
  uint64_t v42 = *(std::__shared_weak_count **)(v40 - 128);
  if (v42) {
    std::__shared_weak_count::__release_weak(v42);
  }
  if (a29 && a28 < 0) {
    operator delete(__p);
  }
  if (a22 && a21 < 0) {
    operator delete(a16);
  }
  std::__shared_weak_count::__release_weak(v39);
  if (a36 < 0) {
    operator delete(a31);
  }
  sub_10019F1F4((uint64_t)&a38);
  long long v43 = *(std::__shared_weak_count **)(v40 - 232);
  if (v43) {
    sub_10004D2C8(v43);
  }
  if (*(char *)(v40 - 201) < 0) {
    operator delete(*(void **)(v40 - 224));
  }
  sub_10023CBF8(&a11);
  sub_100046B58(&a10);
  _Unwind_Resume(a1);
}

uint64_t sub_100558E34(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a1 + 24))
  {
    sub_10005CBB4((uint64_t *)a1);
    *(_OWORD *)a1 = *(_OWORD *)a2;
    *(void *)(a1 + 16) = *(void *)(a2 + 16);
    *(void *)a2 = 0;
    *(void *)(a2 + 8) = 0;
    *(void *)(a2 + 16) = 0;
  }
  else
  {
    *(void *)a1 = 0;
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
    *(_OWORD *)a1 = *(_OWORD *)a2;
    *(void *)(a1 + 16) = *(void *)(a2 + 16);
    *(void *)a2 = 0;
    *(void *)(a2 + 8) = 0;
    *(void *)(a2 + 16) = 0;
    *(unsigned char *)(a1 + 24) = 1;
  }
  return a1;
}

void sub_100558EB0(uint64_t a1, uint64_t a2, int a3)
{
  void (***v24)(long long *__return_ptr);
  NSObject *v25;
  void (***v26)(long long *__return_ptr);
  std::__shared_weak_count *v27;
  uint64_t v28;
  std::__shared_weak_count *v29;
  long long v30;
  std::__shared_weak_count *v31;
  _OWORD *v32;
  uint64_t v33;
  unsigned __int8 v34;
  uint64_t v35;
  std::__shared_weak_count *v36;
  long long v37;
  long long v38;
  dispatch_object_t object;
  uint8_t buf[16];
  _OWORD v41[2];
  long long v42;
  long long v43;
  long long v44;

  uint64_t v34 = a3;
  long long v4 = *(std::__shared_weak_count **)(a1 + 48);
  if (v4)
  {
    int v5 = a3;
    uint64_t v7 = *(void *)(a1 + 32);
    uint64_t v8 = std::__shared_weak_count::lock(v4);
    if (v8)
    {
      uint64_t v9 = v8;
      unsigned int v10 = *(void **)(a1 + 40);
      if (v10)
      {
        *(unsigned char *)(v7 + 120) = 0;
        char v11 = *(NSObject **)(v7 + 40);
        if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v13 = printers::asString((printers *)&v34, v12);
          *(_DWORD *)long long buf = 136315138;
          *(void *)&uint8_t buf[4] = v13;
          _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I signUpForSIMServiceWithCallback response, is success?=%s", buf, 0xCu);
          int v5 = v34;
        }
        if (*(void *)a2)
        {
          uint64_t v14 = *(long long **)(*(void *)a2 + 8);
          if (v14 && v5 != 0)
          {
            long long v43 = 0u;
            char v44 = 0u;
            uint64_t v42 = 0u;
            *(_OWORD *)long long buf = 0u;
            memset(v41, 0, sizeof(v41));
            if (*((char *)v14 + 23) < 0)
            {
              sub_10004FC84(buf, *(void **)v14, *((void *)v14 + 1));
            }
            else
            {
              long long v16 = *v14;
              *(void *)&v41[0] = *((void *)v14 + 2);
              *(_OWORD *)long long buf = v16;
            }
            if (*((char *)v14 + 47) < 0)
            {
              sub_10004FC84((unsigned char *)v41 + 8, *((void **)v14 + 3), *((void *)v14 + 4));
            }
            else
            {
              long long v17 = *(long long *)((char *)v14 + 24);
              *((void *)&v41[1] + 1) = *((void *)v14 + 5);
              *(_OWORD *)((char *)v41 + 8) = v17;
            }
            sub_1000593FC((uint64_t)&v42, v14 + 3);
            unsigned int v18 = *((unsigned __int16 *)v14 + 40);
            LOWORD(v44) = *((_WORD *)v14 + 40);
            BYTE8(v44) = 1;
            if (BYTE8(v43))
            {
              uint64_t v19 = BYTE7(v43);
              if (SBYTE7(v43) < 0) {
                uint64_t v19 = *((void *)&v42 + 1);
              }
              if (v19 && v18 >= 0x100)
              {
                sub_100557F10((uint64_t)v10, a1 + 56, (uint64_t)&v42);
                if (!BYTE8(v43) || !BYTE1(v44)) {
                  sub_10016C840();
                }
                sub_100557FD8(v10, (uint64_t *)&v42, v44);
              }
            }
            uint64_t v20 = *(void *)(v7 + 128);
            if (v20) {
              (*(void (**)(uint64_t, uint64_t))(*(void *)v20 + 40))(v20, 257);
            }
            sub_1005594C0((uint64_t)buf);
            int v5 = v34;
          }
        }
        if (!v5 && *(unsigned char *)(a1 + 80) && !*(void *)(v7 + 128))
        {
          uint64_t v21 = a1 + 56;
          uint64_t v22 = *(NSObject **)(v7 + 40);
          if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
          {
            if (*(char *)(a1 + 79) >= 0) {
              uint64_t v23 = a1 + 56;
            }
            else {
              uint64_t v23 = *(void *)(a1 + 56);
            }
            *(_DWORD *)long long buf = 136315138;
            *(void *)&uint8_t buf[4] = v23;
            _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "#I schedule SignUpForSimService for %s", buf, 0xCu);
          }
          uint64_t v24 = *(void (****)(long long *__return_ptr))(v7 + 48);
          unint64_t v25 = *(NSObject **)(v7 + 24);
          dispatch_object_t object = v25;
          uint64_t v26 = v24;
          if (v25)
          {
            dispatch_retain(v25);
            uint64_t v26 = *(void (****)(long long *__return_ptr))(v7 + 48);
          }
          (**v26)(&v37);
          uint64_t v38 = v37;
          uint64_t v37 = 0uLL;
          uint64_t v27 = *(std::__shared_weak_count **)(v7 + 16);
          if (!v27 || (CFMutableDictionaryRef v28 = *(void *)(v7 + 8), (v29 = std::__shared_weak_count::lock(v27)) == 0)) {
            sub_100088B9C();
          }
          BOOL v35 = v28;
          uint64_t v36 = v29;
          ((void (*)(uint8_t *__return_ptr, void (***)(long long *__return_ptr), dispatch_object_t *, long long *, uint64_t *, uint64_t, uint64_t))(*v24)[88])(buf, v24, &object, &v38, &v35, v21, 9);
          uint64_t v30 = *(_OWORD *)buf;
          memset(buf, 0, sizeof(buf));
          uint64_t v31 = *(std::__shared_weak_count **)(v7 + 136);
          *(_OWORD *)(v7 + 128) = v30;
          if (v31)
          {
            sub_10004D2C8(v31);
            if (*(void *)&buf[8]) {
              sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
            }
          }
          if (v36) {
            sub_10004D2C8(v36);
          }
          if (*((void *)&v38 + 1)) {
            sub_10004D2C8(*((std::__shared_weak_count **)&v38 + 1));
          }
          if (*((void *)&v37 + 1)) {
            sub_10004D2C8(*((std::__shared_weak_count **)&v37 + 1));
          }
          if (object) {
            dispatch_release(object);
          }
          uint64_t v32 = operator new(0x28uLL);
          *uint64_t v32 = xmmword_1014BBFA0;
          v32[1] = unk_1014BBFB0;
          *((void *)v32 + 4) = 1800;
          uint64_t v33 = *(void *)(v7 + 128);
          *(void *)&v41[0] = 0;
          memset(buf, 0, sizeof(buf));
          sub_10015C7D4(buf, v32, (uint64_t)v32 + 40, 5uLL);
          (*(void (**)(uint64_t, uint8_t *))(*(void *)v33 + 16))(v33, buf);
          if (*(void *)buf)
          {
            *(void *)&uint8_t buf[8] = *(void *)buf;
            operator delete(*(void **)buf);
          }
          (*(void (**)(void))(**(void **)(v7 + 128) + 24))(*(void *)(v7 + 128));
          operator delete(v32);
        }
      }
      sub_10004D2C8(v9);
    }
  }
}

void sub_100559320(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, dispatch_object_t object, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24,void *a25,uint64_t a26,int a27,__int16 a28,char a29,char a30)
{
  if (__p) {
    operator delete(__p);
  }
  operator delete(v31);
  sub_10004D2C8(v30);
  _Unwind_Resume(a1);
}

unsigned char *sub_1005593EC(void *a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 48);
  a1[5] = *(void *)(a2 + 40);
  a1[6] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  __n128 result = a1 + 7;
  if (*(char *)(a2 + 79) < 0) {
    return sub_10004FC84(result, *(void **)(a2 + 56), *(void *)(a2 + 64));
  }
  long long v5 = *(_OWORD *)(a2 + 56);
  a1[9] = *(void *)(a2 + 72);
  *(_OWORD *)__n128 result = v5;
  return result;
}

void sub_100559454(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(std::__shared_weak_count **)(v1 + 48);
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  _Unwind_Resume(exception_object);
}

void sub_10055946C(uint64_t a1)
{
  if (*(char *)(a1 + 79) < 0) {
    operator delete(*(void **)(a1 + 56));
  }
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 48);
  if (v2)
  {
    std::__shared_weak_count::__release_weak(v2);
  }
}

uint64_t sub_1005594C0(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 88))
  {
    if (*(unsigned char *)(a1 + 72) && *(char *)(a1 + 71) < 0) {
      operator delete(*(void **)(a1 + 48));
    }
    if (*(char *)(a1 + 47) < 0) {
      operator delete(*(void **)(a1 + 24));
    }
    if (*(char *)(a1 + 23) < 0) {
      operator delete(*(void **)a1);
    }
  }
  return a1;
}

uint64_t sub_100559524(uint64_t a1, CFTypeRef cf, const void *a3)
{
  uint64_t v4 = *(void *)(a1 + 32);
  if (cf)
  {
    CFTypeID v6 = CFGetTypeID(cf);
    if (v6 == CFStringGetTypeID()) {
      CFTypeRef v7 = cf;
    }
    else {
      CFTypeRef v7 = 0;
    }
  }
  else
  {
    CFTypeRef v7 = 0;
  }
  CFTypeRef v12 = v7;
  if (a3)
  {
    CFTypeID v8 = CFGetTypeID(a3);
    if (v8 == CFStringGetTypeID()) {
      uint64_t v9 = a3;
    }
    else {
      uint64_t v9 = 0;
    }
  }
  else
  {
    uint64_t v9 = 0;
  }
  char v11 = v9;
  return (*(uint64_t (**)(uint64_t, CFTypeRef *, const void **))(v4 + 16))(v4, &v12, &v11);
}

uint64_t sub_1005595C4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(*(void *)a3 + 16))();
}

uint64_t sub_1005595E0(uint64_t a1, uint64_t a2, uint64_t *a3, const char *a4, char *a5, dispatch_qos_class_t a6, const void **a7, char a8, char a9)
{
  long long v16 = (void *)(a1 + 8);
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v32, kCtLoggingSystemName, a5);
  long long v17 = dispatch_queue_attr_make_with_qos_class(0, a6, 0);
  unsigned int v18 = dispatch_queue_create(a4, v17);
  void *v16 = 0;
  v16[1] = 0;
  *(void *)(a1 + 24) = v18;
  if (v18)
  {
    uint64_t v19 = v18;
    dispatch_retain(v18);
    *(void *)(a1 + 32) = 0;
    dispatch_release(v19);
  }
  else
  {
    *(void *)(a1 + 32) = 0;
  }
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v33, &v32);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 40), (const ctu::OsLogLogger *)v33);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v33);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v32);
  *(void *)a1 = off_1019E37A0;
  *(void *)(a1 + 48) = a4;
  uint64_t v20 = *a3;
  *a3 = 0;
  *(void *)(a1 + 56) = v20;
  Registry::getFileSystemInterface((uint64_t *)(a1 + 64), *(Registry **)a2);
  *(void *)(a1 + 80) = *(void *)a2;
  add_explicit = *(uint64_t **)(a2 + 8);
  *(void *)(a1 + 88) = add_explicit;
  if (add_explicit) {
    add_explicit = (uint64_t *)atomic_fetch_add_explicit(add_explicit + 1, 1uLL, memory_order_relaxed);
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(add_explicit, *(Registry **)a2);
  uint64_t v23 = ServiceMap;
  if (v24 < 0)
  {
    unint64_t v25 = (unsigned __int8 *)(v24 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v26 = 5381;
    do
    {
      uint64_t v24 = v26;
      unsigned int v27 = *v25++;
      uint64_t v26 = (33 * v26) ^ v27;
    }
    while (v27);
  }
  std::mutex::lock(ServiceMap);
  v32.var0 = (char *)v24;
  CFMutableDictionaryRef v28 = sub_10004D37C(&v23[1].__m_.__sig, (unint64_t *)&v32);
  if (v28)
  {
    uint64_t v30 = v28[3];
    CFTypeRef v29 = (std::__shared_weak_count *)v28[4];
    if (v29) {
      atomic_fetch_add_explicit(&v29->__shared_owners_, 1uLL, memory_order_relaxed);
    }
  }
  else
  {
    uint64_t v30 = 0;
    CFTypeRef v29 = 0;
  }
  std::mutex::unlock(v23);
  *(void *)(a1 + 96) = v30;
  *(void *)(a1 + 104) = v29;
  if (v29)
  {
    atomic_fetch_add_explicit(&v29->__shared_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v29);
  }
  sub_100083DA4((const void **)(a1 + 112), a7);
  *(unsigned char *)(a1 + 120) = a8;
  *(unsigned char *)(a1 + 121) = a9;
  return a1;
}

void sub_1005597F0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, char a12)
{
  uint64_t v16 = *((void *)v12 + 7);
  *((void *)v12 + 7) = 0;
  if (v16) {
    (*(void (**)(uint64_t))(*(void *)v16 + 8))(v16);
  }
  ctu::OsLogLogger::~OsLogLogger(v14);
  sub_100087E88(v13);
  CarrierBundleUpdateInterface::~CarrierBundleUpdateInterface(v12);
  _Unwind_Resume(a1);
}

void sub_100559894(uint64_t a1)
{
  *(void *)a1 = off_1019E37A0;
  sub_1000558F4((const void **)(a1 + 112));
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 104);
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 88);
  if (v3) {
    sub_10004D2C8(v3);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 72);
  if (v4) {
    sub_10004D2C8(v4);
  }
  uint64_t v5 = *(void *)(a1 + 56);
  *(void *)(a1 + 56) = 0;
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 40));
  sub_100087E88((void *)(a1 + 8));

  CarrierBundleUpdateInterface::~CarrierBundleUpdateInterface((CarrierBundleUpdateInterface *)a1);
}

uint64_t sub_100559958(uint64_t a1, uint64_t a2, std::string::size_type a3, int a4)
{
  v101[0] = 0;
  v101[1] = 0;
  uint64_t v102 = 0;
  (*(void (**)(void **__return_ptr))(**(void **)(a1 + 64) + 128))(v101);
  unsigned int v98 = 0;
  size_t v99 = 0;
  uint64_t v100 = 0;
  sub_100058DB0(&v98, "/tmp");
  long long v95 = 0;
  std::string::size_type v96 = 0;
  uint64_t v97 = 0;
  (*(void (**)(void **__return_ptr))(**(void **)(a1 + 64) + 120))(&v95);
  v93[0] = 0;
  v93[1] = 0;
  int64_t v94 = 0;
  if (v100 >= 0) {
    size_t v8 = HIBYTE(v100);
  }
  else {
    size_t v8 = v99;
  }
  memset(&v108, 0, sizeof(v108));
  uint64_t v9 = &v108;
  sub_1000C140C((uint64_t)&v108, v8 + 1);
  if ((v108.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
    uint64_t v9 = (std::string *)v108.__r_.__value_.__r.__words[0];
  }
  if (v8)
  {
    if (v100 >= 0) {
      unsigned int v10 = &v98;
    }
    else {
      unsigned int v10 = v98;
    }
    memmove(v9, v10, v8);
  }
  *(_WORD *)((char *)&v9->__r_.__value_.__l.__data_ + v8) = 47;
  if (v97 >= 0) {
    char v11 = (const std::string::value_type *)&v95;
  }
  else {
    char v11 = (const std::string::value_type *)v95;
  }
  if (v97 >= 0) {
    std::string::size_type v12 = HIBYTE(v97);
  }
  else {
    std::string::size_type v12 = v96;
  }
  uint64_t v13 = std::string::append(&v108, v11, v12);
  long long v14 = *(_OWORD *)&v13->__r_.__value_.__l.__data_;
  int64_t v94 = v13->__r_.__value_.__r.__words[2];
  *(_OWORD *)CFStringRef v93 = v14;
  v13->__r_.__value_.__l.__size_ = 0;
  v13->__r_.__value_.__r.__words[2] = 0;
  v13->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v108.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v108.__r_.__value_.__l.__data_);
  }
  char v15 = (os_log_t *)(a1 + 40);
  uint64_t v16 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
  {
    long long v17 = v101;
    if (v102 < 0) {
      long long v17 = (void **)v101[0];
    }
    unsigned int v18 = &v98;
    if (v100 < 0) {
      unsigned int v18 = v98;
    }
    uint64_t v19 = &v95;
    if (v97 < 0) {
      uint64_t v19 = v95;
    }
    uint64_t v20 = v93;
    if (v94 < 0) {
      uint64_t v20 = (void **)v93[0];
    }
    LODWORD(v108.__r_.__value_.__l.__data_) = 136446978;
    *(std::string::size_type *)((char *)v108.__r_.__value_.__r.__words + 4) = (std::string::size_type)v17;
    WORD2(v108.__r_.__value_.__r.__words[1]) = 2082;
    *(std::string::size_type *)((char *)&v108.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v18;
    HIWORD(v108.__r_.__value_.__r.__words[2]) = 2082;
    uint64_t v109 = v19;
    __int16 v110 = 2082;
    uint64_t v111 = v20;
    _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I Bundle source dir: %{public}s, dest dir: %{public}s, file name: %{public}s, bundle path in mobile: %{public}s", (uint8_t *)&v108, 0x2Au);
  }
  memset(&v92, 0, sizeof(v92));
  uint64_t v90 = 0;
  uint64_t v91 = 0;
  (*(void (**)(uint64_t *__return_ptr))(**(void **)(a1 + 56) + 80))(&v90);
  if (v90)
  {
    if ((*(unsigned int (**)(void, void **))(**(void **)(a1 + 64) + 88))(*(void *)(a1 + 64), v93))
    {
      if ((*(uint64_t (**)(void, void **))(**(void **)(a1 + 64) + 112))(*(void *)(a1 + 64), v93))
      {
        uint64_t v21 = *v15;
        if (os_log_type_enabled(*v15, OS_LOG_TYPE_ERROR))
        {
          long long v50 = v93;
          if (v94 < 0) {
            long long v50 = (void **)v93[0];
          }
          LODWORD(v108.__r_.__value_.__l.__data_) = 136446210;
          *(std::string::size_type *)((char *)v108.__r_.__value_.__r.__words + 4) = (std::string::size_type)v50;
          _os_log_error_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "Failed to remove existing %{public}s", (uint8_t *)&v108, 0xCu);
        }
      }
    }
    uint64_t v88 = 0;
    uint64_t v89 = 0;
    Registry::getMobileHelper(&v88, *(Registry **)(a1 + 80));
    if (!v88)
    {
      os_log_t v33 = *v15;
      if (os_log_type_enabled(*v15, OS_LOG_TYPE_ERROR))
      {
        LOWORD(v108.__r_.__value_.__l.__data_) = 0;
        uint64_t v26 = "Failed to create Mobile Helper";
        unsigned int v27 = v33;
        uint32_t v28 = 2;
LABEL_120:
        _os_log_error_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_ERROR, v26, (uint8_t *)&v108, v28);
      }
LABEL_48:
      int v31 = 0;
      int v32 = 0;
      int v30 = 0;
LABEL_49:
      if (v89) {
        sub_10004D2C8(v89);
      }
      if (v91) {
        sub_10004D2C8(v91);
      }
      if (v30)
      {
        BOOL v35 = *v15;
        if (os_log_type_enabled(*v15, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v36 = v93;
          if (v94 < 0) {
            uint64_t v36 = (void **)v93[0];
          }
          LODWORD(v108.__r_.__value_.__l.__data_) = 136446210;
          *(std::string::size_type *)((char *)v108.__r_.__value_.__r.__words + 4) = (std::string::size_type)v36;
          _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_DEFAULT, "#I Installation is needed for the bundle at %{public}s", (uint8_t *)&v108, 0xCu);
        }
        *(_OWORD *)&v108.__r_.__value_.__l.__data_ = 0uLL;
        uint64_t v37 = *(void *)(a1 + 56);
        if (SHIBYTE(v94) < 0)
        {
          sub_10004FC84(__p, v93[0], (unint64_t)v93[1]);
        }
        else
        {
          *(_OWORD *)std::string __p = *(_OWORD *)v93;
          uint64_t v67 = v94;
        }
        (*(void (**)(std::string *__return_ptr, uint64_t, void **))(*(void *)v37 + 72))(&v108, v37, __p);
        if (SHIBYTE(v67) < 0) {
          operator delete(__p[0]);
        }
        if (v108.__r_.__value_.__r.__words[0]) {
          int v30 = (*(uint64_t (**)(std::string::size_type))(*(void *)v108.__r_.__value_.__l.__data_ + 16))(v108.__r_.__value_.__r.__words[0]);
        }
        else {
          int v30 = 0;
        }
        if (v108.__r_.__value_.__l.__size_) {
          sub_10004D2C8((std::__shared_weak_count *)v108.__r_.__value_.__l.__size_);
        }
      }
      goto LABEL_68;
    }
    if (((*(uint64_t (**)(void))(*(void *)v88 + 48))() & 1) == 0)
    {
      os_log_t v34 = *v15;
      if (os_log_type_enabled(*v15, OS_LOG_TYPE_ERROR))
      {
        long long v51 = &v95;
        if (v97 < 0) {
          long long v51 = v95;
        }
        uint64_t v52 = v101;
        if (v102 < 0) {
          uint64_t v52 = (void **)v101[0];
        }
        long long v53 = &v98;
        if (v100 < 0) {
          long long v53 = v98;
        }
        LODWORD(v108.__r_.__value_.__l.__data_) = 136446722;
        *(std::string::size_type *)((char *)v108.__r_.__value_.__r.__words + 4) = (std::string::size_type)v51;
        WORD2(v108.__r_.__value_.__r.__words[1]) = 2082;
        *(std::string::size_type *)((char *)&v108.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v52;
        HIWORD(v108.__r_.__value_.__r.__words[2]) = 2082;
        uint64_t v109 = v53;
        uint64_t v26 = "Failed to copy %{public}s from %{public}s to %{public}s";
        unsigned int v27 = v34;
        uint32_t v28 = 32;
        goto LABEL_120;
      }
      goto LABEL_48;
    }
    strcpy(v107, "/tmp/CBTemp.XXXXXXX");
    uint64_t v22 = mkdtemp(v107);
    sub_10003ED78(&v92, v22);
    int v23 = (*(uint64_t (**)(void))(*(void *)v90 + 16))();
    uint64_t v24 = *v15;
    if (v23)
    {
      if (os_log_type_enabled(*v15, OS_LOG_TYPE_ERROR))
      {
        unint64_t v25 = v93;
        if (v94 < 0) {
          unint64_t v25 = (void **)v93[0];
        }
        LODWORD(v108.__r_.__value_.__l.__data_) = 136446210;
        *(std::string::size_type *)((char *)v108.__r_.__value_.__r.__words + 4) = (std::string::size_type)v25;
        uint64_t v26 = "BOM copy failed from %{public}s";
        unsigned int v27 = v24;
        uint32_t v28 = 12;
        goto LABEL_120;
      }
      goto LABEL_48;
    }
    if (os_log_type_enabled(*v15, OS_LOG_TYPE_DEFAULT))
    {
      if (*(unsigned char *)(a1 + 121)) {
        long long v41 = "true";
      }
      else {
        long long v41 = "false";
      }
      LODWORD(v108.__r_.__value_.__l.__data_) = 136315138;
      *(std::string::size_type *)((char *)v108.__r_.__value_.__r.__words + 4) = (std::string::size_type)v41;
      _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "#I Suppress bundle update alert: %s", (uint8_t *)&v108, 0xCu);
    }
    if ((a4 - 1) < 2 || *(unsigned char *)(a1 + 121))
    {
      uint64_t v42 = *v15;
      if (os_log_type_enabled(*v15, OS_LOG_TYPE_DEFAULT))
      {
        long long v43 = &v95;
        if (v97 < 0) {
          long long v43 = v95;
        }
        LODWORD(v108.__r_.__value_.__l.__data_) = 136446210;
        *(std::string::size_type *)((char *)v108.__r_.__value_.__r.__words + 4) = (std::string::size_type)v43;
        _os_log_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_DEFAULT, "#I Not showing update alert for %{public}s", (uint8_t *)&v108, 0xCu);
      }
      int v31 = 0;
      int v32 = 0;
      int v30 = 1;
      goto LABEL_49;
    }
    CFStringRef v87 = 0;
    sub_10055AF5C("/Payload/", (const void **)&v92.__r_.__value_.__l.__data_, &v84);
    int v45 = *(char *)(a2 + 23);
    if (v45 >= 0) {
      uint64_t v46 = (const std::string::value_type *)a2;
    }
    else {
      uint64_t v46 = *(const std::string::value_type **)a2;
    }
    if (v45 >= 0) {
      std::string::size_type v47 = *(unsigned __int8 *)(a2 + 23);
    }
    else {
      std::string::size_type v47 = *(void *)(a2 + 8);
    }
    long long v48 = std::string::append(&v84, v46, v47);
    long long v49 = *(_OWORD *)&v48->__r_.__value_.__l.__data_;
    cf1.__r_.__value_.__r.__words[2] = v48->__r_.__value_.__r.__words[2];
    *(_OWORD *)&cf1.__r_.__value_.__l.__data_ = v49;
    v48->__r_.__value_.__l.__size_ = 0;
    v48->__r_.__value_.__r.__words[2] = 0;
    v48->__r_.__value_.__r.__words[0] = 0;
    sub_10055B020(".bundle", &cf1, &v86);
    if (SHIBYTE(v86.__r_.__value_.__r.__words[2]) < 0) {
      sub_10004FC84(&__dst, v86.__r_.__value_.__l.__data_, v86.__r_.__value_.__l.__size_);
    }
    else {
      std::string __dst = v86;
    }
    CFStringRef v103 = 0;
    if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
      sub_10004FC84(&v108, __dst.__r_.__value_.__l.__data_, __dst.__r_.__value_.__l.__size_);
    }
    else {
      std::string v108 = __dst;
    }
    CFStringRef v105 = 0;
    if (ctu::cf::convert_copy())
    {
      CFStringRef v54 = v103;
      CFStringRef v103 = v105;
      CFStringRef v106 = v54;
      sub_1000558F4((const void **)&v106);
    }
    if (SHIBYTE(v108.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v108.__r_.__value_.__l.__data_);
    }
    CFStringRef v87 = v103;
    CFStringRef v103 = 0;
    sub_1000558F4((const void **)&v103);
    if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__dst.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v86.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v86.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(cf1.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(cf1.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v84.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v84.__r_.__value_.__l.__data_);
    }
    CFStringRef v105 = 0;
    (*(void (**)(const __CFString **__return_ptr))(**(void **)(a1 + 96) + 24))(&v105);
    CFStringRef v103 = 0;
    if (*(char *)(a2 + 23) < 0) {
      sub_10004FC84(&v82, *(void **)a2, *(void *)(a2 + 8));
    }
    else {
      std::string v82 = *(std::string *)a2;
    }
    if (SHIBYTE(v82.__r_.__value_.__r.__words[2]) < 0) {
      sub_10004FC84(&__dst, v82.__r_.__value_.__l.__data_, v82.__r_.__value_.__l.__size_);
    }
    else {
      std::string __dst = v82;
    }
    CFStringRef v106 = 0;
    if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
      sub_10004FC84(&v108, __dst.__r_.__value_.__l.__data_, __dst.__r_.__value_.__l.__size_);
    }
    else {
      std::string v108 = __dst;
    }
    v84.__r_.__value_.__r.__words[0] = 0;
    if (ctu::cf::convert_copy())
    {
      CFStringRef v55 = v106;
      CFStringRef v106 = (const __CFString *)v84.__r_.__value_.__r.__words[0];
      cf1.__r_.__value_.__r.__words[0] = (std::string::size_type)v55;
      sub_1000558F4((const void **)&cf1.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v108.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v108.__r_.__value_.__l.__data_);
    }
    CFStringRef theString2 = v106;
    CFStringRef v106 = 0;
    sub_1000558F4((const void **)&v106);
    if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__dst.__r_.__value_.__l.__data_);
    }
    CFStringCompare(@"OtherKnown", theString2, 1uLL);
    sub_1000558F4((const void **)&theString2);
    if (SHIBYTE(v82.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v82.__r_.__value_.__l.__data_);
    }
    (*(void (**)(std::string *__return_ptr))(**(void **)(a1 + 96) + 24))(&__dst);
    v108.__r_.__value_.__r.__words[0] = (std::string::size_type)v103;
    CFStringRef v103 = (const __CFString *)__dst.__r_.__value_.__r.__words[0];
    __dst.__r_.__value_.__r.__words[0] = 0;
    sub_1000558F4((const void **)&v108.__r_.__value_.__l.__data_);
    sub_1000558F4((const void **)&__dst.__r_.__value_.__l.__data_);
    __dst.__r_.__value_.__r.__words[0] = 0;
    (*(void (**)(std::string *__return_ptr))(**(void **)(a1 + 96) + 24))(&__dst);
    cf1.__r_.__value_.__r.__words[0] = 0;
    (*(void (**)(std::string *__return_ptr))(**(void **)(a1 + 96) + 24))(&cf1);
    if (CFEqual(v105, @"CBMessageTitle")
      || CFEqual(v103, @"CBMessageBody")
      || CFEqual(v103, @"CBOtherKnownMessageBody")
      || CFEqual(__dst.__r_.__value_.__l.__data_, @"CBMessageAcceptButton"))
    {
      uint64_t v56 = *v15;
      if (os_log_type_enabled(*v15, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(v108.__r_.__value_.__l.__data_) = 0;
        _os_log_impl((void *)&_mh_execute_header, v56, OS_LOG_TYPE_DEFAULT, "#I There is no localization directory in the downloaded bundle, using the one from CoreTelephony framework itself", (uint8_t *)&v108, 2u);
      }
      (*(void (**)(std::string *__return_ptr))(**(void **)(a1 + 96) + 32))(&v84);
      v108.__r_.__value_.__r.__words[0] = (std::string::size_type)v105;
      CFStringRef v105 = (const __CFString *)v84.__r_.__value_.__r.__words[0];
      v84.__r_.__value_.__r.__words[0] = 0;
      sub_1000558F4((const void **)&v108.__r_.__value_.__l.__data_);
      sub_1000558F4((const void **)&v84.__r_.__value_.__l.__data_);
      (*(void (**)(std::string *__return_ptr))(**(void **)(a1 + 96) + 32))(&v84);
      v108.__r_.__value_.__r.__words[0] = (std::string::size_type)v103;
      CFStringRef v103 = (const __CFString *)v84.__r_.__value_.__r.__words[0];
      v84.__r_.__value_.__r.__words[0] = 0;
      sub_1000558F4((const void **)&v108.__r_.__value_.__l.__data_);
      sub_1000558F4((const void **)&v84.__r_.__value_.__l.__data_);
      (*(void (**)(std::string *__return_ptr))(**(void **)(a1 + 96) + 32))(&v84);
      v108.__r_.__value_.__r.__words[0] = __dst.__r_.__value_.__r.__words[0];
      __dst.__r_.__value_.__r.__words[0] = v84.__r_.__value_.__r.__words[0];
      v84.__r_.__value_.__r.__words[0] = 0;
      sub_1000558F4((const void **)&v108.__r_.__value_.__l.__data_);
      sub_1000558F4((const void **)&v84.__r_.__value_.__l.__data_);
      (*(void (**)(std::string *__return_ptr))(**(void **)(a1 + 96) + 32))(&v84);
      v108.__r_.__value_.__r.__words[0] = cf1.__r_.__value_.__r.__words[0];
      cf1.__r_.__value_.__r.__words[0] = v84.__r_.__value_.__r.__words[0];
      v84.__r_.__value_.__r.__words[0] = 0;
      sub_1000558F4((const void **)&v108.__r_.__value_.__l.__data_);
      sub_1000558F4((const void **)&v84.__r_.__value_.__l.__data_);
    }
    if (CFEqual(v105, @"CBMessageTitle")
      || CFEqual(v103, @"CBMessageBody")
      || CFEqual(v103, @"CBOtherKnownMessageBody")
      || CFEqual(__dst.__r_.__value_.__l.__data_, @"CBMessageAcceptButton"))
    {
      uint64_t v57 = *v15;
      if (os_log_type_enabled(*v15, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(v108.__r_.__value_.__l.__data_) = 0;
        _os_log_impl((void *)&_mh_execute_header, v57, OS_LOG_TYPE_DEFAULT, "#N Failed to load user strings to show the dialog", (uint8_t *)&v108, 2u);
      }
      int v31 = 0;
      int v32 = 0;
      int v30 = 0;
      goto LABEL_168;
    }
    xpc_object_t v58 = (capabilities::ct *)CFEqual(cf1.__r_.__value_.__l.__data_, @"CBMessageDeclineButton");
    if (v58)
    {
      xpc_object_t v59 = *v15;
      BOOL v60 = os_log_type_enabled(*v15, OS_LOG_TYPE_DEFAULT);
      if (v60)
      {
        LOWORD(v108.__r_.__value_.__l.__data_) = 0;
        _os_log_impl((void *)&_mh_execute_header, v59, OS_LOG_TYPE_DEFAULT, "#I This is a mandatory update, showing the notice", (uint8_t *)&v108, 2u);
      }
      if (capabilities::ct::getBasebandBootStrategy((capabilities::ct *)v60) == 2)
      {
        sub_100083DA4(&v81, (const void **)&v105);
        sub_100083DA4(&v80, (const void **)&v103);
        sub_100083DA4(&v79, (const void **)&__dst.__r_.__value_.__l.__data_);
        sub_10055B080((NSObject **)(a1 + 40), (uint64_t *)&v81, (uint64_t *)&v80, (uint64_t *)&v79);
        sub_1000558F4(&v79);
        sub_1000558F4(&v80);
        std::string::size_type v61 = &v81;
      }
      else
      {
        sub_100083DA4((const void **)&v78, (const void **)&v105);
        sub_100083DA4((const void **)&v77, (const void **)&v103);
        sub_100083DA4((const void **)&defaultButtonTitle, (const void **)&__dst.__r_.__value_.__l.__data_);
        CFUserNotificationDisplayNotice(0.0, 0, 0, 0, 0, v78, v77, defaultButtonTitle);
        sub_1000558F4((const void **)&defaultButtonTitle);
        sub_1000558F4((const void **)&v77);
        std::string::size_type v61 = (const void **)&v78;
      }
      sub_1000558F4(v61);
      int v32 = 0;
      int v31 = 1;
      goto LABEL_183;
    }
    if (capabilities::ct::getBasebandBootStrategy(v58) == 2)
    {
      sub_100083DA4(&v75, (const void **)&v105);
      sub_100083DA4(&v74, (const void **)&v103);
      sub_100083DA4(&v73, (const void **)&__dst.__r_.__value_.__l.__data_);
      sub_100083DA4(&v72, (const void **)&cf1.__r_.__value_.__l.__data_);
      BOOL v62 = sub_10055B218((NSObject **)(a1 + 40), (uint64_t *)&v75, (uint64_t *)&v74, (uint64_t *)&v73, (uint64_t *)&v72);
      sub_1000558F4(&v72);
      sub_1000558F4(&v73);
      sub_1000558F4(&v74);
      sub_1000558F4(&v75);
      if (!v62) {
        goto LABEL_184;
      }
    }
    else
    {
      sub_100083DA4((const void **)&v71, (const void **)&v105);
      sub_100083DA4((const void **)&v70, (const void **)&v103);
      sub_100083DA4((const void **)&v69, (const void **)&__dst.__r_.__value_.__l.__data_);
      sub_100083DA4((const void **)&v68, (const void **)&cf1.__r_.__value_.__l.__data_);
      BOOL v63 = sub_10055B410(v71, v70, v69, v68);
      sub_1000558F4((const void **)&v68);
      sub_1000558F4((const void **)&v69);
      sub_1000558F4((const void **)&v70);
      sub_1000558F4((const void **)&v71);
      if (!v63)
      {
LABEL_184:
        __int16 v65 = *v15;
        if (os_log_type_enabled(*v15, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(v108.__r_.__value_.__l.__data_) = 0;
          _os_log_impl((void *)&_mh_execute_header, v65, OS_LOG_TYPE_DEFAULT, "#N User has declined the update, aborting the update", (uint8_t *)&v108, 2u);
        }
        int v31 = 0;
        int v30 = 0;
        int v32 = 1;
        goto LABEL_168;
      }
      uint64_t v64 = *v15;
      if (os_log_type_enabled(*v15, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(v108.__r_.__value_.__l.__data_) = 0;
        _os_log_impl((void *)&_mh_execute_header, v64, OS_LOG_TYPE_DEFAULT, "#N User has accepted the update, will install the update", (uint8_t *)&v108, 2u);
      }
    }
    int v31 = 0;
    int v32 = 0;
LABEL_183:
    int v30 = 1;
LABEL_168:
    sub_1000558F4((const void **)&cf1.__r_.__value_.__l.__data_);
    sub_1000558F4((const void **)&__dst.__r_.__value_.__l.__data_);
    sub_1000558F4((const void **)&v103);
    sub_1000558F4((const void **)&v105);
    sub_1000558F4((const void **)&v87);
    goto LABEL_49;
  }
  CFTypeRef v29 = *v15;
  if (os_log_type_enabled(*v15, OS_LOG_TYPE_ERROR))
  {
    LOWORD(v108.__r_.__value_.__l.__data_) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_ERROR, "Failed to create BOM copier", (uint8_t *)&v108, 2u);
  }
  if (v91) {
    sub_10004D2C8(v91);
  }
  int v30 = 0;
  int v31 = 0;
  int v32 = 0;
LABEL_68:
  std::string::size_type size = HIBYTE(v92.__r_.__value_.__r.__words[2]);
  if ((v92.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
    std::string::size_type size = v92.__r_.__value_.__l.__size_;
  }
  if (size) {
    (*(void (**)(void, std::string *))(**(void **)(a1 + 64) + 112))(*(void *)(a1 + 64), &v92);
  }
  if ((*(unsigned int (**)(void, std::string::size_type))(**(void **)(a1 + 64) + 88))(*(void *)(a1 + 64), a3))
  {
    if ((*(uint64_t (**)(void, std::string::size_type))(**(void **)(a1 + 64) + 112))(*(void *)(a1 + 64), a3))
    {
      uint64_t v39 = *v15;
      if (os_log_type_enabled(*v15, OS_LOG_TYPE_ERROR))
      {
        if (*(char *)(a3 + 23) >= 0) {
          std::string::size_type v44 = a3;
        }
        else {
          std::string::size_type v44 = *(void *)a3;
        }
        LODWORD(v108.__r_.__value_.__l.__data_) = 136446210;
        *(std::string::size_type *)((char *)v108.__r_.__value_.__r.__words + 4) = v44;
        _os_log_error_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_ERROR, "Failed to remove existing %{public}s", (uint8_t *)&v108, 0xCu);
      }
    }
  }
  if (SHIBYTE(v92.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v92.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v94) < 0) {
    operator delete(v93[0]);
  }
  if (SHIBYTE(v97) < 0) {
    operator delete(v95);
  }
  if (SHIBYTE(v100) < 0) {
    operator delete(v98);
  }
  if (SHIBYTE(v102) < 0) {
    operator delete(v101[0]);
  }
  return v30 | (v31 << 8) | (v32 << 16);
}

void sub_10055AC9C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, uint64_t a10, uint64_t a11, uint64_t a12, const void *a13, const void *a14, const void *a15, const void *a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,void *a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,void *a32,uint64_t a33,uint64_t a34,void *a35,uint64_t a36,uint64_t a37,void *a38,uint64_t a39,uint64_t a40,const void *a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,void *__p,uint64_t a47,int a48,__int16 a49,char a50,char a51,void *a52,uint64_t a53,int a54,__int16 a55,char a56,char a57,uint64_t a58,void *a59,uint64_t a60,int a61,__int16 a62,char a63)
{
  sub_1000558F4(&a13);
  sub_1000558F4(&a14);
  sub_1000558F4(&a15);
  sub_1000558F4(&a16);
  sub_1000558F4((const void **)&a35);
  sub_1000558F4((const void **)(v70 - 208));
  sub_1000558F4((const void **)(v70 - 216));
  sub_1000558F4((const void **)(v70 - 176));
  sub_1000558F4(&a41);
  if (a43) {
    sub_10004D2C8((std::__shared_weak_count *)a43);
  }
  if (a45) {
    sub_10004D2C8((std::__shared_weak_count *)a45);
  }
  if (a51 < 0) {
    operator delete(__p);
  }
  if (a57 < 0) {
    operator delete(a52);
  }
  if (a64 < 0) {
    operator delete(a59);
  }
  if (a70 < 0) {
    operator delete(a65);
  }
  if (*(char *)(v70 - 217) < 0) {
    operator delete(*(void **)(v70 - 240));
  }
  _Unwind_Resume(a1);
}

uint64_t sub_10055AF5C@<X0>(char *__s@<X1>, const void **a2@<X0>, void *a3@<X8>)
{
  if (*((char *)a2 + 23) >= 0) {
    size_t v6 = *((unsigned __int8 *)a2 + 23);
  }
  else {
    size_t v6 = (size_t)a2[1];
  }
  size_t v7 = strlen(__s);
  a3[1] = 0;
  a3[2] = 0;
  *a3 = 0;
  uint64_t result = sub_1000C140C((uint64_t)a3, v6 + v7);
  if (*((char *)a3 + 23) < 0) {
    a3 = (void *)*a3;
  }
  if (v6)
  {
    if (*((char *)a2 + 23) >= 0) {
      uint64_t v9 = a2;
    }
    else {
      uint64_t v9 = *a2;
    }
    uint64_t result = (uint64_t)memmove(a3, v9, v6);
  }
  unsigned int v10 = (char *)a3 + v6;
  if (v7) {
    uint64_t result = (uint64_t)memmove(v10, __s, v7);
  }
  v10[v7] = 0;
  return result;
}

__n128 sub_10055B020@<Q0>(char *__s@<X1>, std::string *a2@<X0>, std::string *a3@<X8>)
{
  size_t v6 = strlen(__s);
  size_t v7 = (__n128 *)std::string::append(a2, __s, v6);
  __n128 result = *v7;
  *a3 = *(std::string *)v7->n128_u8;
  v7->n128_u64[0] = 0;
  v7->n128_u64[1] = 0;
  v7[1].n128_u64[0] = 0;
  return result;
}

const void **sub_10055B080(NSObject **a1, uint64_t *a2, uint64_t *a3, uint64_t *a4)
{
  CFDictionaryRef dictionary = 0;
  CFDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (Mutable)
  {
    CFDictionaryRef v9 = dictionary;
    CFDictionaryRef dictionary = Mutable;
    CFUserNotificationRef v15 = v9;
    sub_10005717C((const void **)&v15);
  }
  sub_10010F3F0(dictionary, (void *)kCFUserNotificationAlertHeaderKey, *a2);
  sub_10010F3F0(dictionary, (void *)kCFUserNotificationAlertMessageKey, *a3);
  sub_10010F3F0(dictionary, (void *)kCFUserNotificationDefaultButtonTitleKey, *a4);
  sub_10012C97C(dictionary, @"CSLSUserNotificationNeverDeny", (uint64_t)kCFBooleanTrue);
  SInt32 error = -1;
  CFUserNotificationRef v15 = CFUserNotificationCreate(kCFAllocatorDefault, 0.0, 0, &error, dictionary);
  if (error)
  {
    unsigned int v10 = *a1;
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::string::size_type v12 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "Failed to display carrier bundle update notice.", v12, 2u);
    }
  }
  sub_1001D88DC((const void **)&v15);
  return sub_10005717C((const void **)&dictionary);
}

void sub_10055B1F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sub_10005717C((const void **)va);
  _Unwind_Resume(a1);
}

BOOL sub_10055B218(NSObject **a1, uint64_t *a2, uint64_t *a3, uint64_t *a4, uint64_t *a5)
{
  CFDictionaryRef dictionary = 0;
  CFDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (Mutable)
  {
    CFDictionaryRef v11 = dictionary;
    CFDictionaryRef dictionary = Mutable;
    CFDictionaryRef v20 = v11;
    sub_10005717C((const void **)&v20);
  }
  sub_10010F3F0(dictionary, (void *)kCFUserNotificationAlertHeaderKey, *a2);
  sub_10010F3F0(dictionary, (void *)kCFUserNotificationAlertMessageKey, *a3);
  sub_10010F3F0(dictionary, (void *)kCFUserNotificationDefaultButtonTitleKey, *a4);
  sub_10010F3F0(dictionary, (void *)kCFUserNotificationAlternateButtonTitleKey, *a5);
  sub_10012C97C(dictionary, @"CSLSUserNotificationNeverDeny", (uint64_t)kCFBooleanTrue);
  SInt32 error = -1;
  CFUserNotificationRef v12 = CFUserNotificationCreate(kCFAllocatorDefault, 0.0, 0, &error, dictionary);
  CFDictionaryRef v20 = v12;
  if (!error)
  {
    CFOptionFlags responseFlags = 0;
    if (!CFUserNotificationReceiveResponse(v12, 0.0, &responseFlags))
    {
      BOOL v14 = responseFlags != 1;
      goto LABEL_8;
    }
    uint64_t v13 = *a1;
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t v16 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "Failed to display carrier bundle update alert.", v16, 2u);
    }
  }
  BOOL v14 = 0;
LABEL_8:
  sub_1001D88DC((const void **)&v20);
  sub_10005717C((const void **)&dictionary);
  return v14;
}

void sub_10055B3D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va1, a5);
  va_start(va, a5);
  size_t v6 = va_arg(va1, const void *);
  sub_1001D88DC((const void **)va1);
  sub_10005717C((const void **)va);
  _Unwind_Resume(a1);
}

BOOL sub_10055B410(CFStringRef alertHeader, CFStringRef alertMessage, CFStringRef defaultButtonTitle, CFStringRef alternateButtonTitle)
{
  CFOptionFlags v5 = 0;
  CFUserNotificationDisplayAlert(0.0, 0, 0, 0, 0, alertHeader, alertMessage, defaultButtonTitle, alternateButtonTitle, 0, &v5);
  return v5 != 1;
}

BOOL sub_10055B46C(uint64_t a1, void *a2)
{
  if (*a2) {
    uint64_t v2 = (uint64_t *)sub_1000810B8;
  }
  else {
    uint64_t v2 = 0;
  }
  if (!v2) {
    return 1;
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(v2, *(Registry **)(a1 + 80));
  uint64_t v4 = ServiceMap;
  if ((v5 & 0x8000000000000000) != 0)
  {
    size_t v6 = (unsigned __int8 *)(v5 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v7 = 5381;
    do
    {
      std::string::size_type v5 = v7;
      unsigned int v8 = *v6++;
      uint64_t v7 = (33 * v7) ^ v8;
    }
    while (v8);
  }
  std::mutex::lock(ServiceMap);
  v68.__r_.__value_.__r.__words[0] = v5;
  CFDictionaryRef v9 = sub_10004D37C(&v4[1].__m_.__sig, (unint64_t *)&v68);
  if (v9)
  {
    uint64_t v11 = v9[3];
    unsigned int v10 = (std::__shared_weak_count *)v9[4];
    if (v10)
    {
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v4);
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v10);
      char v12 = 0;
      goto LABEL_13;
    }
  }
  else
  {
    uint64_t v11 = 0;
  }
  std::mutex::unlock(v4);
  unsigned int v10 = 0;
  char v12 = 1;
LABEL_13:
  int v13 = (*(uint64_t (**)(uint64_t))(*(void *)v11 + 16))(v11);
  if ((v12 & 1) == 0) {
    sub_10004D2C8(v10);
  }
  if (!v13) {
    return 1;
  }
  memset(&v68, 0, sizeof(v68));
  ctu::cf::assign();
  std::string v67 = v68;
  if ((v68.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    BOOL v14 = (std::string *)((char *)&v67 + HIBYTE(v68.__r_.__value_.__r.__words[2]));
  }
  else {
    BOOL v14 = (std::string *)(v67.__r_.__value_.__r.__words[0] + v67.__r_.__value_.__l.__size_);
  }
  if ((v68.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    CFUserNotificationRef v15 = &v67;
  }
  else {
    CFUserNotificationRef v15 = (std::string *)v67.__r_.__value_.__r.__words[0];
  }
  while (v15 != v14)
  {
    v15->__r_.__value_.__s.__data_[0] = __tolower(v15->__r_.__value_.__s.__data_[0]);
    CFUserNotificationRef v15 = (std::string *)((char *)v15 + 1);
  }
  memset(&v68, 0, sizeof(v68));
  ctu::cf::assign();
  std::string v66 = v68;
  uint64_t v16 = HIBYTE(v67.__r_.__value_.__r.__words[2]);
  if ((v67.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type size = HIBYTE(v67.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type size = v67.__r_.__value_.__l.__size_;
  }
  std::string::size_type v18 = HIBYTE(v66.__r_.__value_.__r.__words[2]);
  int v19 = SHIBYTE(v66.__r_.__value_.__r.__words[2]);
  if ((v66.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
    std::string::size_type v18 = v66.__r_.__value_.__l.__size_;
  }
  if (size == v18)
  {
    if ((v66.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      CFDictionaryRef v20 = &v66;
    }
    else {
      CFDictionaryRef v20 = (std::string *)v66.__r_.__value_.__r.__words[0];
    }
    if ((*((unsigned char *)&v67.__r_.__value_.__s + 23) & 0x80) != 0)
    {
      if (memcmp(v67.__r_.__value_.__l.__data_, v20, v67.__r_.__value_.__l.__size_)) {
        goto LABEL_40;
      }
    }
    else if (*((unsigned char *)&v67.__r_.__value_.__s + 23))
    {
      uint64_t v21 = &v67;
      while (v21->__r_.__value_.__s.__data_[0] == v20->__r_.__value_.__s.__data_[0])
      {
        uint64_t v21 = (std::string *)((char *)v21 + 1);
        CFDictionaryRef v20 = (std::string *)((char *)v20 + 1);
        if (!--v16) {
          goto LABEL_42;
        }
      }
      goto LABEL_40;
    }
LABEL_42:
    BOOL v22 = 1;
    goto LABEL_133;
  }
LABEL_40:
  memset(&v68, 0, sizeof(v68));
  ctu::cf::assign();
  std::string __str = v68;
  if (SHIBYTE(v68.__r_.__value_.__r.__words[2]) < 0) {
    sub_10004FC84(&__dst, __str.__r_.__value_.__l.__data_, __str.__r_.__value_.__l.__size_);
  }
  else {
    std::string __dst = __str;
  }
  if (sub_1006CF100((uint64_t)&__dst))
  {
    if (SHIBYTE(v67.__r_.__value_.__r.__words[2]) < 0) {
      sub_10004FC84(&__p, v67.__r_.__value_.__l.__data_, v67.__r_.__value_.__l.__size_);
    }
    else {
      std::string __p = v67;
    }
    char v23 = sub_1006CF100((uint64_t)&__p) ^ 1;
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
  }
  else
  {
    char v23 = 1;
  }
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__dst.__r_.__value_.__l.__data_);
    if (v23) {
      goto LABEL_53;
    }
  }
  else if (v23)
  {
LABEL_53:
    int v24 = 1;
    BOOL v22 = 1;
    goto LABEL_128;
  }
  if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    unint64_t v25 = (std::string *)((char *)&__str + HIBYTE(__str.__r_.__value_.__r.__words[2]));
  }
  else {
    unint64_t v25 = (std::string *)(__str.__r_.__value_.__r.__words[0] + __str.__r_.__value_.__l.__size_);
  }
  if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    p_str = &__str;
  }
  else {
    p_str = (std::string *)__str.__r_.__value_.__r.__words[0];
  }
  while (p_str != v25)
  {
    p_str->__r_.__value_.__s.__data_[0] = __tolower(p_str->__r_.__value_.__s.__data_[0]);
    p_str = (std::string *)((char *)p_str + 1);
  }
  memset(&v68, 0, sizeof(v68));
  unsigned int v27 = (const char *)kBundleUpdatesUrlPrefix;
  size_t v28 = strlen(kBundleUpdatesUrlPrefix);
  std::string::basic_string(&v68, &__str, v28, 0xFFFFFFFFFFFFFFFFLL, (std::allocator<char> *)__s1);
  __s1[0] = 0;
  __s1[1] = 0;
  int64_t v62 = 0;
  if ((v68.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    CFTypeRef v29 = &v68;
  }
  else {
    CFTypeRef v29 = (std::string *)v68.__r_.__value_.__r.__words[0];
  }
  if ((v68.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type v30 = HIBYTE(v68.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type v30 = v68.__r_.__value_.__l.__size_;
  }
  if (v30)
  {
    int v31 = (std::string *)((char *)v29 + v30);
    int v32 = v29;
    while (v32->__r_.__value_.__s.__data_[0] != 47)
    {
      int v32 = (std::string *)((char *)v32 + 1);
      if (!--v30)
      {
        int v32 = v31;
        break;
      }
    }
    std::string::size_type v33 = (char *)v32 - (char *)v29;
    if (v32 == v31) {
      std::string::size_type v34 = -1;
    }
    else {
      std::string::size_type v34 = v33;
    }
  }
  else
  {
    std::string::size_type v34 = -1;
  }
  BOOL v35 = std::string::erase(&v68, v34, 0xFFFFFFFFFFFFFFFFLL);
  if (SHIBYTE(v35->__r_.__value_.__r.__words[2]) < 0)
  {
    sub_10004FC84(__s1, v35->__r_.__value_.__l.__data_, v35->__r_.__value_.__l.__size_);
  }
  else
  {
    long long v36 = *(_OWORD *)&v35->__r_.__value_.__l.__data_;
    int64_t v62 = v35->__r_.__value_.__r.__words[2];
    *(_OWORD *)__s1 = v36;
  }
  memset(&v60, 0, sizeof(v60));
  size_t v37 = strlen(v27);
  std::string::basic_string(&v60, &v67, v37, 0xFFFFFFFFFFFFFFFFLL, (std::allocator<char> *)v58);
  v58[0] = 0;
  v58[1] = 0;
  int64_t v59 = 0;
  if ((v60.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    uint64_t v38 = &v60;
  }
  else {
    uint64_t v38 = (std::string *)v60.__r_.__value_.__r.__words[0];
  }
  if ((v60.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type v39 = HIBYTE(v60.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type v39 = v60.__r_.__value_.__l.__size_;
  }
  if (v39)
  {
    uint64_t v40 = (std::string *)((char *)v38 + v39);
    long long v41 = v38;
    while (v41->__r_.__value_.__s.__data_[0] != 47)
    {
      long long v41 = (std::string *)((char *)v41 + 1);
      if (!--v39)
      {
        long long v41 = v40;
        break;
      }
    }
    std::string::size_type v42 = (char *)v41 - (char *)v38;
    if (v41 == v40) {
      std::string::size_type v43 = -1;
    }
    else {
      std::string::size_type v43 = v42;
    }
  }
  else
  {
    std::string::size_type v43 = -1;
  }
  std::string::size_type v44 = std::string::erase(&v60, v43, 0xFFFFFFFFFFFFFFFFLL);
  if (SHIBYTE(v44->__r_.__value_.__r.__words[2]) < 0)
  {
    sub_10004FC84(v58, v44->__r_.__value_.__l.__data_, v44->__r_.__value_.__l.__size_);
  }
  else
  {
    long long v45 = *(_OWORD *)&v44->__r_.__value_.__l.__data_;
    int64_t v59 = v44->__r_.__value_.__r.__words[2];
    *(_OWORD *)xpc_object_t v58 = v45;
  }
  if (v62 >= 0) {
    uint64_t v46 = (void *)HIBYTE(v62);
  }
  else {
    uint64_t v46 = __s1[1];
  }
  char v47 = HIBYTE(v59);
  if (v46)
  {
    long long v48 = v59 >= 0 ? (void *)HIBYTE(v59) : v58[1];
    if (v48)
    {
      if (v46 == v48)
      {
        if (v59 >= 0) {
          long long v49 = v58;
        }
        else {
          long long v49 = (void **)v58[0];
        }
        if (v62 < 0)
        {
          BOOL v22 = memcmp(__s1[0], v49, (size_t)__s1[1]) != 0;
        }
        else if (HIBYTE(v62))
        {
          uint64_t v50 = HIBYTE(v62) - 1;
          long long v51 = __s1;
          do
          {
            int v53 = *(unsigned __int8 *)v51;
            long long v51 = (void **)((char *)v51 + 1);
            int v52 = v53;
            int v54 = *(unsigned __int8 *)v49;
            long long v49 = (void **)((char *)v49 + 1);
            BOOL v22 = v52 != v54;
          }
          while (v52 == v54 && v50-- != 0);
        }
        else
        {
          BOOL v22 = 0;
        }
      }
      else
      {
        BOOL v22 = 1;
      }
      int v24 = 0;
      if ((v47 & 0x80) == 0) {
        goto LABEL_122;
      }
      goto LABEL_121;
    }
  }
  int v24 = 1;
  BOOL v22 = 1;
  if (v59 < 0) {
LABEL_121:
  }
    operator delete(v58[0]);
LABEL_122:
  if (SHIBYTE(v60.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v60.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v62) < 0) {
    operator delete(__s1[0]);
  }
  if (SHIBYTE(v68.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v68.__r_.__value_.__l.__data_);
  }
LABEL_128:
  if ((SHIBYTE(__str.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    if (v24) {
      goto LABEL_130;
    }
LABEL_133:
    char v56 = 1;
    if ((v19 & 0x80000000) == 0) {
      goto LABEL_135;
    }
    goto LABEL_134;
  }
  operator delete(__str.__r_.__value_.__l.__data_);
  if (!v24) {
    goto LABEL_133;
  }
LABEL_130:
  char v56 = 0;
  if ((v19 & 0x80000000) == 0) {
    goto LABEL_135;
  }
LABEL_134:
  operator delete(v66.__r_.__value_.__l.__data_);
LABEL_135:
  if (SHIBYTE(v67.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v67.__r_.__value_.__l.__data_);
  }
  BOOL result = v22;
  if ((v56 & 1) == 0) {
    return 1;
  }
  return result;
}

void sub_10055BA8C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,void *a25,uint64_t a26,int a27,__int16 a28,char a29,char a30,uint64_t a31,uint64_t a32,uint64_t a33,int a34,__int16 a35,char a36,char a37,uint64_t a38,void *a39,uint64_t a40,int a41,__int16 a42,char a43,char a44)
{
  if (a44 < 0) {
    operator delete(a39);
  }
  if (v44 < 0) {
    operator delete(*(void **)(v45 - 144));
  }
  if (*(char *)(v45 - 89) < 0) {
    operator delete(*(void **)(v45 - 112));
  }
  _Unwind_Resume(exception_object);
}

void sub_10055BBA4(uint64_t a1, const void **a2, CFDictionaryRef *a3, uint64_t a4)
{
  if (*a3) {
    size_t v6 = sub_100080778;
  }
  else {
    size_t v6 = 0;
  }
  if (v6 && (*a2 ? (unsigned int v8 = sub_100080778) : (unsigned int v8 = 0), v8))
  {
    CFArrayRef Value = (const __CFArray *)CFDictionaryGetValue(*a3, @"kBundleUpdateCheckCriteria");
    if (Value)
    {
      CFArrayRef v11 = Value;
      CFTypeID v12 = CFGetTypeID(Value);
      if (v12 == CFArrayGetTypeID())
      {
        int v13 = CFDictionaryGetValue(*a3, @"DeviceName");
        if (v13 && (BOOL v14 = v13, v15 = CFGetTypeID(v13), v15 == CFStringGetTypeID()))
        {
          CFTypeRef v75 = v14;
          CFRetain(v14);
        }
        else
        {
          CFTypeRef v75 = 0;
        }
        long long v73 = 0u;
        long long v74 = 0u;
        long long v71 = 0u;
        long long v72 = 0u;
        *(_OWORD *)uint64_t v70 = 0u;
        sub_100058198(&v69, a2);
        std::string v68 = v75;
        if (v75) {
          CFRetain(v75);
        }
        sub_100810FD0((uint64_t)v70, (void *)(a1 + 80), &v69, &v68);
        sub_1000558F4(&v68);
        sub_100057D78(&v69);
        CFArrayRef theArray = 0;
        CFArrayRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
        if (Mutable)
        {
          CFArrayRef v21 = theArray;
          CFArrayRef theArray = Mutable;
          *(void *)&long long buf = v21;
          sub_1000440D4((const void **)&buf);
        }
        BOOL v22 = operator new(0x30uLL);
        uint64_t v55 = a4;
        v22[1] = 0;
        void v22[2] = 0;
        void *v22 = off_1019E3880;
        void v22[3] = 0;
        char v23 = v22 + 3;
        v22[4] = 0;
        v22[5] = 0;
        CFIndex Count = CFArrayGetCount(v11);
        if (Count >= 1)
        {
          for (CFIndex i = 0; i != Count; ++i)
          {
            CFDictionaryRef theDict = 0;
            *(void *)&long long buf = CFArrayGetValueAtIndex(v11, i);
            sub_10004EFE4(&theDict, (CFTypeRef *)&buf);
            uint64_t v26 = (int *)CFDictionaryGetValue(theDict, @"kUpdateBundleType");
            unsigned int v27 = v26;
            LODWORD(buf) = 0;
            if (v26)
            {
              CFTypeID v28 = CFGetTypeID(v26);
              if (v28 == CFNumberGetTypeID()) {
                ctu::cf::assign((ctu::cf *)&buf, v27, v29);
              }
            }
            if (buf - 7 >= 0xFFFFFFFE)
            {
              CFTypeRef ValueAtIndex = 0;
              CFTypeRef cf = 0;
              CFDictionaryRef v63 = theDict;
              if (theDict) {
                CFRetain(theDict);
              }
              sub_100811544((uint64_t)v70, &v63, (uint64_t)&ValueAtIndex);
              sub_100057D78((const void **)&v63);
              int v30 = ValueAtIndex;
              CFDictionaryRef v62 = (CFDictionaryRef)cf;
              if (cf)
              {
                CFRetain(cf);
                CFDictionaryRef v31 = v62;
              }
              else
              {
                CFDictionaryRef v31 = 0;
              }
              if (v31) {
                int v32 = sub_100080778;
              }
              else {
                int v32 = 0;
              }
              if (v32 && v30 == 4)
              {
                sub_10055DA44(theArray, v31);
              }
              else if (v32 && v30 == 3)
              {
                CFTypeRef v61 = 0;
                std::string::size_type v33 = CFDictionaryGetValue(v31, @"BundleID");
                std::string::size_type v34 = v33;
                if (v33 && (CFTypeID v35 = CFGetTypeID(v33), v35 == CFStringGetTypeID()))
                {
                  CFTypeRef v61 = v34;
                  CFRetain(v34);
                  CFTypeRef v59 = v61;
                  if (v61) {
                    CFRetain(v61);
                  }
                }
                else
                {
                  CFTypeRef v61 = 0;
                  CFTypeRef v59 = 0;
                }
                char v60 = 3;
                long long v36 = (void *)v22[4];
                unint64_t v37 = v22[5];
                if ((unint64_t)v36 >= v37)
                {
                  uint64_t v40 = ((uint64_t)v36 - *v23) >> 4;
                  if ((unint64_t)(v40 + 1) >> 60) {
                    sub_10006A748();
                  }
                  uint64_t v41 = v37 - *v23;
                  uint64_t v42 = v41 >> 3;
                  if (v41 >> 3 <= (unint64_t)(v40 + 1)) {
                    uint64_t v42 = v40 + 1;
                  }
                  if ((unint64_t)v41 >= 0x7FFFFFFFFFFFFFF0) {
                    unint64_t v43 = 0xFFFFFFFFFFFFFFFLL;
                  }
                  else {
                    unint64_t v43 = v42;
                  }
                  std::string v81 = v22 + 5;
                  if (v43) {
                    int v44 = (char *)sub_10006A794((uint64_t)(v22 + 5), v43);
                  }
                  else {
                    int v44 = 0;
                  }
                  uint64_t v45 = &v44[16 * v40];
                  *(void *)&long long buf = v44;
                  *((void *)&buf + 1) = v45;
                  std::string v80 = &v44[16 * v43];
                  sub_100062708(v45, v59);
                  v45[8] = v60;
                  std::string::size_type v79 = v45 + 16;
                  sub_10055D6C4(v23, &buf);
                  std::string::size_type v39 = (void *)v22[4];
                  sub_10055D72C((uint64_t)&buf);
                }
                else
                {
                  uint64_t v38 = sub_100062708(v36, v59);
                  *((unsigned char *)v38 + 8) = v60;
                  std::string::size_type v39 = v38 + 2;
                }
                v22[4] = v39;
                sub_1000558F4(&v59);
                sub_1000558F4(&v61);
              }
              sub_100057D78((const void **)&v62);
              sub_100057D78(&cf);
            }
            sub_100057D78((const void **)&theDict);
          }
        }
        uint64_t v46 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v46, OS_LOG_TYPE_DEFAULT))
        {
          LODWORD(buf) = 138543362;
          *(void *)((char *)&buf + 4) = theArray;
          _os_log_impl((void *)&_mh_execute_header, v46, OS_LOG_TYPE_DEFAULT, "#I Available country bundle updates: %{public}@", (uint8_t *)&buf, 0xCu);
        }
        char v47 = dispatch_group_create();
        CFIndex v48 = CFArrayGetCount(theArray);
        if (v48 >= 1)
        {
          for (CFIndex j = 0; j != v48; ++j)
          {
            *(void *)&long long buf = 0;
            CFTypeRef ValueAtIndex = CFArrayGetValueAtIndex(theArray, j);
            sub_10004EFE4(&buf, &ValueAtIndex);
            CFTypeRef ValueAtIndex = 0;
            uint64_t v50 = CFDictionaryGetValue((CFDictionaryRef)buf, @"BundleID");
            long long v51 = v50;
            if (v50 && (CFTypeID v52 = CFGetTypeID(v50), v52 == CFStringGetTypeID()))
            {
              CFTypeRef ValueAtIndex = v51;
              CFRetain(v51);
            }
            else
            {
              CFTypeRef ValueAtIndex = 0;
            }
            xpc_object_t v58 = (const void *)buf;
            if ((void)buf) {
              CFRetain((CFTypeRef)buf);
            }
            *(void *)dispatch_group_t group = a1;
            *(void *)&group[8] = v47;
            if (v47)
            {
              dispatch_retain(v47);
              dispatch_group_enter(v47);
            }
            *(void *)&group[16] = ValueAtIndex;
            if (ValueAtIndex) {
              CFRetain(ValueAtIndex);
            }
            *(void *)&long long v57 = v22 + 3;
            *((void *)&v57 + 1) = v22;
            atomic_fetch_add_explicit(v22 + 1, 1uLL, memory_order_relaxed);
            std::string v84 = 0;
            int v53 = (char *)operator new(0x30uLL);
            *(void *)int v53 = off_1019E38D0;
            *(_OWORD *)(v53 + 8) = *(_OWORD *)group;
            uint64_t v54 = *(void *)&group[16];
            *(_OWORD *)&group[8] = 0u;
            *((void *)v53 + 3) = v54;
            *((void *)v53 + 4) = v23;
            *((void *)v53 + 5) = v22;
            long long v57 = 0u;
            std::string v84 = v53;
            sub_10055C514(a1, (CFDictionaryRef *)&v58, (uint64_t)v83);
            sub_10055E178(v83);
            if (*((void *)&v57 + 1)) {
              sub_10004D2C8(*((std::__shared_weak_count **)&v57 + 1));
            }
            sub_1000558F4((const void **)&group[16]);
            if (*(void *)&group[8])
            {
              dispatch_group_leave(*(dispatch_group_t *)&group[8]);
              dispatch_release(*(dispatch_object_t *)&group[8]);
            }
            sub_100057D78(&v58);
            sub_1000558F4(&ValueAtIndex);
            sub_100057D78((const void **)&buf);
          }
        }
        sub_10055E1FC((uint64_t)&buf, v55);
        std::string v81 = v22 + 3;
        std::string v82 = v22;
        atomic_fetch_add_explicit(v22 + 1, 1uLL, memory_order_relaxed);
        operator new();
      }
    }
    std::string::size_type v18 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t v70 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "Cannot find bundle match criteria in the device info", v70, 2u);
    }
    memset(v76, 0, sizeof(v76));
    uint64_t v19 = *(void *)(a4 + 24);
    if (!v19) {
      sub_10007B600();
    }
    long long v17 = v76;
    (*(void (**)(uint64_t, void *))(*(void *)v19 + 48))(v19, v76);
  }
  else
  {
    memset(v77, 0, sizeof(v77));
    uint64_t v16 = *(void *)(a4 + 24);
    if (!v16) {
      sub_10007B600();
    }
    long long v17 = v77;
    (*(void (**)(uint64_t, void *))(*(void *)v16 + 48))(v16, v77);
  }
  *(void *)uint64_t v70 = v17;
  sub_10055D640((void ***)v70);
}

void sub_10055C39C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,char a25,int a26,__int16 a27,char a28,char a29,int a30,__int16 a31,char a32,char a33,int a34,__int16 a35,char a36,char a37,uint64_t a38,char a39,int a40,__int16 a41,char a42,char a43,int a44,__int16 a45,char a46,char a47,int a48,__int16 a49,char a50,char a51,uint64_t a52)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_10055C514(uint64_t a1, CFDictionaryRef *a2, uint64_t a3)
{
  memset(v81, 0, sizeof(v81));
  memset(&v80, 0, sizeof(v80));
  CFArrayRef Value = (BOOL *)CFDictionaryGetValue(*a2, @"UseOldUpdateFormat");
  uint64_t v7 = Value;
  buf[0] = 0;
  if (Value)
  {
    CFTypeID v8 = CFGetTypeID(Value);
    if (v8 == CFBooleanGetTypeID()) {
      ctu::cf::assign((ctu::cf *)buf, v7, v9);
    }
    int v10 = buf[0];
  }
  else
  {
    int v10 = 0;
  }
  CFArrayRef v11 = CFDictionaryGetValue(*a2, @"BundleVersion");
  CFTypeID v12 = v11;
  if (v11)
  {
    CFTypeID v13 = CFGetTypeID(v11);
    if (v13 == CFStringGetTypeID()) {
      BOOL v14 = v12;
    }
    else {
      BOOL v14 = 0;
    }
  }
  else
  {
    BOOL v14 = 0;
  }
  std::string::size_type v79 = v14;
  if (v10)
  {
    CFTypeID v15 = CFDictionaryGetValue(*a2, @"BuildVersion");
    uint64_t v16 = v15;
    if (v15)
    {
      CFTypeID v17 = CFGetTypeID(v15);
      if (v17 == CFStringGetTypeID()) {
        BOOL v14 = v16;
      }
      else {
        BOOL v14 = 0;
      }
    }
    else
    {
      BOOL v14 = 0;
    }
    std::string::size_type v79 = v14;
  }
  if (v14)
  {
    CFTypeRef cf = 0;
    std::string::size_type v18 = CFDictionaryGetValue(*a2, @"BundleURL");
    uint64_t v19 = v18;
    if (v18 && (CFTypeID v20 = CFGetTypeID(v18), v20 == CFStringGetTypeID()))
    {
      CFTypeRef cf = v19;
      CFRetain(v19);
      CFTypeRef v21 = cf;
    }
    else
    {
      CFTypeRef v21 = 0;
      CFTypeRef cf = 0;
    }
    if (v21) {
      BOOL v22 = sub_1000810B8;
    }
    else {
      BOOL v22 = 0;
    }
    if (!v22)
    {
      uint64_t v45 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v45, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v45, OS_LOG_TYPE_DEFAULT, "#I No bundle URL key found in the version specific dict", buf, 2u);
      }
      buf[0] = 2;
      sub_10055D86C((uint64_t)v68, buf, (long long *)v81, (long long *)&v80);
      uint64_t v46 = *(void *)(a3 + 24);
      if (!v46) {
        sub_10007B600();
      }
      (*(void (**)(uint64_t, char *))(*(void *)v46 + 48))(v46, v68);
      if (v72 < 0) {
        operator delete(v71);
      }
      if (v70 < 0) {
        operator delete(v69);
      }
      goto LABEL_101;
    }
    CFTypeRef v67 = 0;
    CFDictionaryRef v23 = *a2;
    if (v10) {
      CFStringRef v24 = @"Digest3";
    }
    else {
      CFStringRef v24 = @"Digest";
    }
    *(void *)long long buf = v24;
    unint64_t v25 = CFDictionaryGetValue(v23, v24);
    uint64_t v26 = v25;
    if (v25 && (CFTypeID v27 = CFGetTypeID(v25), v27 == CFDataGetTypeID()))
    {
      CFTypeRef v67 = v26;
      CFRetain(v26);
    }
    else
    {
      CFTypeRef v67 = 0;
    }
    sub_1000558F4((const void **)buf);
    if (v67) {
      int v30 = sub_10008324C;
    }
    else {
      int v30 = 0;
    }
    if (!v30)
    {
      CFDictionaryRef v31 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "#N No bundle digest found in the versionXML bundle dict", buf, 2u);
      }
    }
    uint64_t v65 = 0;
    std::string v66 = 0;
    (*(void (**)(uint64_t *__return_ptr))(**(void **)(a1 + 56) + 96))(&v65);
    if (v65)
    {
      *(void *)long long buf = 0;
      uint64_t v58 = 0;
      uint64_t v59 = 0;
      generateUUIDForIPCC(buf);
      WirelessUserDirectory = (char *)_GetWirelessUserDirectory();
      sub_100058DB0(&v54, WirelessUserDirectory);
      std::string::size_type v33 = std::string::append(&v54, "/Library/", 9uLL);
      long long v34 = *(_OWORD *)&v33->__r_.__value_.__l.__data_;
      v55.__r_.__value_.__r.__words[2] = v33->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v55.__r_.__value_.__l.__data_ = v34;
      v33->__r_.__value_.__l.__size_ = 0;
      v33->__r_.__value_.__r.__words[2] = 0;
      v33->__r_.__value_.__r.__words[0] = 0;
      if (v59 >= 0) {
        CFTypeID v35 = buf;
      }
      else {
        CFTypeID v35 = *(uint8_t **)buf;
      }
      size_t v36 = strlen((const char *)v35);
      unint64_t v37 = std::string::append(&v55, (const std::string::value_type *)v35, v36);
      long long v38 = *(_OWORD *)&v37->__r_.__value_.__l.__data_;
      v56.__r_.__value_.__r.__words[2] = v37->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v56.__r_.__value_.__l.__data_ = v38;
      v37->__r_.__value_.__l.__size_ = 0;
      v37->__r_.__value_.__r.__words[2] = 0;
      v37->__r_.__value_.__r.__words[0] = 0;
      std::string::size_type v39 = std::string::append(&v56, ".ipcc", 5uLL);
      uint64_t v40 = (void *)v39->__r_.__value_.__r.__words[0];
      v90[0] = v39->__r_.__value_.__l.__size_;
      *(void *)((char *)v90 + 7) = *(std::string::size_type *)((char *)&v39->__r_.__value_.__r.__words[1] + 7);
      char v41 = HIBYTE(v39->__r_.__value_.__r.__words[2]);
      v39->__r_.__value_.__l.__size_ = 0;
      v39->__r_.__value_.__r.__words[2] = 0;
      v39->__r_.__value_.__r.__words[0] = 0;
      if (SHIBYTE(v81[2]) < 0) {
        operator delete(v81[0]);
      }
      v81[0] = v40;
      v81[1] = (void *)v90[0];
      *(void **)((char *)&v81[1] + 7) = *(void **)((char *)v90 + 7);
      HIBYTE(v81[2]) = v41;
      if (SHIBYTE(v56.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v56.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v55.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v55.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v54.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v54.__r_.__value_.__l.__data_);
      }
      sub_1000292E0((uint64_t)&v56);
      if (SHIBYTE(v80.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v80.__r_.__value_.__l.__data_);
      }
      std::string v80 = v56;
      CFTypeRef v53 = cf;
      if (cf) {
        CFRetain(cf);
      }
      BOOL v42 = sub_10055B46C(a1, &v53);
      sub_1000558F4(&v53);
      uint64_t v43 = v65;
      CFTypeRef v52 = cf;
      if (cf) {
        CFRetain(cf);
      }
      CFTypeRef v51 = v67;
      if (v67) {
        CFRetain(v67);
      }
      uint64_t v44 = *(unsigned __int8 *)(a1 + 120);
      *(void *)&long long v82 = a1;
      *((void *)&v82 + 1) = v65;
      unsigned __int8 v83 = v66;
      if (v66) {
        atomic_fetch_add_explicit(&v66->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      sub_10055E430((uint64_t)v84, a3);
      if (SHIBYTE(v81[2]) < 0)
      {
        sub_10004FC84(&v85, v81[0], (unint64_t)v81[1]);
      }
      else
      {
        long long v85 = *(_OWORD *)v81;
        std::string v86 = v81[2];
      }
      if (SHIBYTE(v80.__r_.__value_.__r.__words[2]) < 0) {
        sub_10004FC84(&v87, v80.__r_.__value_.__l.__data_, v80.__r_.__value_.__l.__size_);
      }
      else {
        std::string v87 = v80;
      }
      uint64_t v89 = 0;
      uint64_t v50 = (char *)operator new(0x70uLL);
      *(void *)uint64_t v50 = off_1019E3960;
      *(_OWORD *)(v50 + 8) = v82;
      *((void *)v50 + 3) = v83;
      *((void *)&v82 + 1) = 0;
      unsigned __int8 v83 = 0;
      sub_10055E9C8((uint64_t)(v50 + 32), (uint64_t)v84);
      *((_OWORD *)v50 + 4) = v85;
      *((void *)v50 + 10) = v86;
      std::string v86 = 0;
      long long v85 = 0uLL;
      *(std::string *)(v50 + 88) = v87;
      memset(&v87, 0, sizeof(v87));
      uint64_t v89 = v50;
      (*(void (**)(uint64_t, CFTypeRef *, void **, CFTypeRef *, uint64_t, BOOL, void *))(*(void *)v43 + 24))(v43, &v52, v81, &v51, v44, v42, v88);
      sub_100060644(v88);
      if (SHIBYTE(v87.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v87.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v86) < 0) {
        operator delete((void *)v85);
      }
      sub_10055E178(v84);
      if (v83) {
        sub_10004D2C8(v83);
      }
      sub_100030068(&v51);
      sub_1000558F4(&v52);
      if ((SHIBYTE(v59) & 0x80000000) == 0) {
        goto LABEL_98;
      }
      long long v49 = *(uint8_t **)buf;
    }
    else
    {
      char v47 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v47, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v47, OS_LOG_TYPE_ERROR, "Failed to create downloader.", buf, 2u);
      }
      buf[0] = 0;
      sub_10055D86C((uint64_t)v60, buf, (long long *)v81, (long long *)&v80);
      uint64_t v48 = *(void *)(a3 + 24);
      if (!v48) {
        sub_10007B600();
      }
      (*(void (**)(uint64_t, char *))(*(void *)v48 + 48))(v48, v60);
      if (v64 < 0) {
        operator delete(v63);
      }
      if ((v62 & 0x80000000) == 0) {
        goto LABEL_98;
      }
      long long v49 = v61;
    }
    operator delete(v49);
LABEL_98:
    if (v66) {
      sub_10004D2C8(v66);
    }
    sub_100030068(&v67);
LABEL_101:
    sub_1000558F4(&cf);
    goto LABEL_102;
  }
  CFTypeID v28 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "#I Bundle version missing from update dict.", buf, 2u);
  }
  buf[0] = 2;
  sub_10055D86C((uint64_t)v74, buf, (long long *)v81, (long long *)&v80);
  uint64_t v29 = *(void *)(a3 + 24);
  if (!v29) {
    sub_10007B600();
  }
  (*(void (**)(uint64_t, char *))(*(void *)v29 + 48))(v29, v74);
  if (v78 < 0) {
    operator delete(__p);
  }
  if (v76 < 0) {
    operator delete(v75);
  }
LABEL_102:
  if (SHIBYTE(v80.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v80.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v81[2]) < 0) {
    operator delete(v81[0]);
  }
}

void sub_10055CD6C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, const void *a10, uint64_t a11, void *a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20,uint64_t a21,uint64_t a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,const void *a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,const void *a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,void *a56,uint64_t a57,int a58,__int16 a59,char a60,char a61,void *a62,uint64_t a63)
{
  if (*(char *)(v68 - 161) < 0) {
    operator delete(*(void **)(v68 - 184));
  }
  sub_10055E178(v67);
  char v70 = *(std::__shared_weak_count **)(v68 - 224);
  if (v70) {
    sub_10004D2C8(v70);
  }
  sub_100030068(&a9);
  sub_1000558F4(&a10);
  if (a28 < 0) {
    operator delete(__p);
  }
  if (a38) {
    sub_10004D2C8((std::__shared_weak_count *)a38);
  }
  sub_100030068(&a39);
  sub_1000558F4(&a47);
  if (a61 < 0) {
    operator delete(a56);
  }
  if (a67 < 0) {
    operator delete(a62);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_10055CF18(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 32);
  if (v2) {
    sub_10004D2C8(v2);
  }
  sub_1000558F4((const void **)(a1 + 16));
  uint64_t v3 = *(NSObject **)(a1 + 8);
  if (v3)
  {
    dispatch_group_leave(v3);
    uint64_t v4 = *(NSObject **)(a1 + 8);
    if (v4) {
      dispatch_release(v4);
    }
  }
  return a1;
}

void *sub_10055CF68(void *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[5];
  if (v2) {
    sub_10004D2C8(v2);
  }

  return sub_10055D77C(a1);
}

uint64_t sub_10055CFA8(uint64_t a1)
{
  if (*(char *)(a1 + 103) < 0) {
    operator delete(*(void **)(a1 + 80));
  }
  if (*(char *)(a1 + 79) < 0) {
    operator delete(*(void **)(a1 + 56));
  }
  sub_10055E178((void *)(a1 + 24));
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

void sub_10055D000(uint64_t a1, const void **a2, char a3, uint64_t a4)
{
  void v7[4] = a1;
  sub_100062740(&v8, a2);
  char v9 = a3;
  sub_10055E1FC((uint64_t)&v10, a4);
  v7[0] = 0;
  v7[1] = 0;
  sub_10003E168(v7, (void *)(a1 + 8));
  operator new();
}

void sub_10055D164(_Unwind_Exception *exception_object, int a2)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

void sub_10055D190(uint64_t a1, int a2, const char *a3, BOOL a4)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(__stack_chk_guard, *(Registry **)(a1 + 80));
  char v9 = ServiceMap;
  if (v10 < 0)
  {
    CFArrayRef v11 = (unsigned __int8 *)(v10 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v12 = 5381;
    do
    {
      uint64_t v10 = v12;
      unsigned int v13 = *v11++;
      uint64_t v12 = (33 * v12) ^ v13;
    }
    while (v13);
  }
  std::mutex::lock(ServiceMap);
  *(void *)long long buf = v10;
  BOOL v14 = sub_10004D37C(&v9[1].__m_.__sig, (unint64_t *)buf);
  if (!v14)
  {
    uint64_t v16 = 0;
LABEL_9:
    std::mutex::unlock(v9);
    CFTypeID v15 = 0;
    char v17 = 1;
    if (!v16) {
      goto LABEL_44;
    }
    goto LABEL_10;
  }
  uint64_t v16 = v14[3];
  CFTypeID v15 = (std::__shared_weak_count *)v14[4];
  if (!v15) {
    goto LABEL_9;
  }
  atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v9);
  atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v15);
  char v17 = 0;
  if (!v16) {
    goto LABEL_44;
  }
LABEL_10:
  xpc_object_t v41 = 0;
  xpc_object_t v18 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v19 = v18;
  if (v18)
  {
    xpc_object_t v41 = v18;
  }
  else
  {
    xpc_object_t v19 = xpc_null_create();
    xpc_object_t v41 = v19;
    if (!v19)
    {
      xpc_object_t v20 = xpc_null_create();
      xpc_object_t v19 = 0;
      goto LABEL_17;
    }
  }
  if (xpc_get_type(v19) != (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_object_t v20 = xpc_null_create();
LABEL_17:
    xpc_object_t v41 = v20;
    goto LABEL_18;
  }
  xpc_retain(v19);
LABEL_18:
  xpc_release(v19);
  CFTypeRef v21 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
  {
    CFDictionaryRef v31 = v15;
    char v22 = v17;
    uint64_t v23 = asString();
    int v24 = a3[23];
    unint64_t v25 = *(uint64_t **)a3;
    uint64_t v26 = asString();
    if (v24 >= 0) {
      CFTypeID v27 = a3;
    }
    else {
      CFTypeID v27 = (const char *)v25;
    }
    *(_DWORD *)long long buf = 136315650;
    *(void *)&uint8_t buf[4] = v23;
    *(_WORD *)&unsigned char buf[12] = 2082;
    *(void *)&buf[14] = v27;
    __int16 v43 = 2080;
    uint64_t v44 = v26;
    _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "#I Submitting metric on update check with %s, %{public}s, %s", buf, 0x20u);
    char v17 = v22;
    CFTypeID v15 = v31;
  }
  if ((a2 - 1) < 6) {
    int64_t v28 = (a2 - 1) + 1;
  }
  else {
    int64_t v28 = 0;
  }
  xpc_object_t v39 = xpc_int64_create(v28);
  if (!v39) {
    xpc_object_t v39 = xpc_null_create();
  }
  *(void *)long long buf = &v41;
  *(void *)&uint8_t buf[8] = "bundle_update_check_info_bundle_type";
  sub_100035E70((uint64_t)buf, &v39, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(v39);
  xpc_object_t v39 = 0;
  if (a3[23] >= 0) {
    uint64_t v29 = a3;
  }
  else {
    uint64_t v29 = *(const char **)a3;
  }
  xpc_object_t v37 = xpc_string_create(v29);
  if (!v37) {
    xpc_object_t v37 = xpc_null_create();
  }
  *(void *)long long buf = &v41;
  *(void *)&uint8_t buf[8] = "bundle_update_check_info_bundle_name_to_check";
  sub_100035E70((uint64_t)buf, &v37, &v38);
  xpc_release(v38);
  xpc_object_t v38 = 0;
  xpc_release(v37);
  xpc_object_t v37 = 0;
  xpc_object_t v35 = xpc_BOOL_create(a4);
  if (!v35) {
    xpc_object_t v35 = xpc_null_create();
  }
  *(void *)long long buf = &v41;
  *(void *)&uint8_t buf[8] = "bundle_update_check_info_is_buddy_active";
  sub_100035E70((uint64_t)buf, &v35, &v36);
  xpc_release(v36);
  xpc_object_t v36 = 0;
  xpc_release(v35);
  xpc_object_t v35 = 0;
  if (((*(unsigned char *)(a1 + 120) - 1) & 0xF8) != 0) {
    int64_t v30 = 0;
  }
  else {
    int64_t v30 = (*(unsigned char *)(a1 + 120) - 1) + 1;
  }
  xpc_object_t v33 = xpc_int64_create(v30);
  if (!v33) {
    xpc_object_t v33 = xpc_null_create();
  }
  *(void *)long long buf = &v41;
  *(void *)&uint8_t buf[8] = "update_check_trigger";
  sub_100035E70((uint64_t)buf, &v33, &v34);
  xpc_release(v34);
  xpc_object_t v34 = 0;
  xpc_release(v33);
  xpc_object_t v32 = v41;
  xpc_object_t v33 = 0;
  if (v41) {
    xpc_retain(v41);
  }
  else {
    xpc_object_t v32 = xpc_null_create();
  }
  (*(void (**)(uint64_t, const char *, xpc_object_t *))(*(void *)v16 + 16))(v16, "commCenterBundleUpdateCheck", &v32);
  xpc_release(v32);
  xpc_object_t v32 = 0;
  xpc_release(v41);
LABEL_44:
  if ((v17 & 1) == 0) {
    sub_10004D2C8(v15);
  }
}

void sub_10055D58C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, xpc_object_t object, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, xpc_object_t a20)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

void sub_10055D640(void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (const void **)**a1;
  if (v2)
  {
    uint64_t v4 = (const void **)v1[1];
    std::string::size_type v5 = v2;
    if (v4 != v2)
    {
      do
        uint64_t v4 = sub_1000577C4(v4 - 2);
      while (v4 != v2);
      std::string::size_type v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t *sub_10055D6C4(uint64_t *result, void *a2)
{
  uint64_t v3 = *result;
  uint64_t v2 = result[1];
  uint64_t v4 = a2[1];
  while (v2 != v3)
  {
    *(void *)(v4 - 16) = 0;
    v4 -= 16;
    uint64_t v5 = *(void *)(v2 - 16);
    v2 -= 16;
    *(void *)uint64_t v4 = v5;
    *(void *)uint64_t v2 = 0;
    *(unsigned char *)(v4 + 8) = *(unsigned char *)(v2 + 8);
  }
  a2[1] = v4;
  uint64_t v6 = *result;
  *BOOL result = v4;
  a2[1] = v6;
  uint64_t v7 = result[1];
  result[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = result[2];
  result[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t sub_10055D72C(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 16;
    sub_1000577C4((const void **)(i - 16));
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void *sub_10055D77C(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void sub_10055D800(uint64_t a1)
{
  sub_10005CD2C(a1 + 56, *(char **)(a1 + 64));
  sub_100057D78((const void **)(a1 + 48));
  sub_100057D78((const void **)(a1 + 40));
  sub_100057D78((const void **)(a1 + 32));
  sub_1000558F4((const void **)(a1 + 24));
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2) {
    sub_10004D2C8(v2);
  }

  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)a1);
}

uint64_t sub_10055D86C(uint64_t a1, unsigned char *a2, long long *a3, long long *a4)
{
  *(unsigned char *)a1 = *a2;
  if (*((char *)a3 + 23) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 8), *(void **)a3, *((void *)a3 + 1));
  }
  else
  {
    long long v6 = *a3;
    *(void *)(a1 + 24) = *((void *)a3 + 2);
    *(_OWORD *)(a1 + 8) = v6;
  }
  uint64_t v7 = (unsigned char *)(a1 + 32);
  if (*((char *)a4 + 23) < 0)
  {
    sub_10004FC84(v7, *(void **)a4, *((void *)a4 + 1));
  }
  else
  {
    long long v8 = *a4;
    *(void *)(a1 + 48) = *((void *)a4 + 2);
    *(_OWORD *)uint64_t v7 = v8;
  }
  return a1;
}

void sub_10055D8F8(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 31) < 0) {
    operator delete(*v2);
  }
  _Unwind_Resume(exception_object);
}

const void **sub_10055D914(const void **result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    long long v6 = result;
    sub_1001577CC(result, a4);
    BOOL result = (const void **)v6[1];
    while (a2 != a3)
    {
      uint64_t v7 = sub_1000584C8(result, (const void **)a2);
      *((unsigned char *)v7 + 8) = *(unsigned char *)(a2 + 8);
      a2 += 16;
      BOOL result = v7 + 2;
    }
    v6[1] = result;
  }
  return result;
}

void sub_10055D98C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
}

void sub_10055D9A0(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1019E3880;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_10055D9C0(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1019E3880;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_10055DA14(uint64_t a1)
{
  uint64_t v1 = (void **)(a1 + 24);
  sub_10055D640(&v1);
}

BOOL sub_10055DA44(__CFArray *a1, CFTypeRef cf)
{
  uint64_t v5 = cf;
  if (cf)
  {
    CFRetain(cf);
    CFArrayAppendValue(a1, cf);
  }
  sub_10010F494(&v5);
  return cf != 0;
}

void sub_10055DAA0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_10010F494((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_10055DAB4(uint64_t a1)
{
  *(void *)a1 = off_1019E38D0;
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 40);
  if (v2) {
    sub_10004D2C8(v2);
  }
  sub_1000558F4((const void **)(a1 + 24));
  uint64_t v3 = *(NSObject **)(a1 + 16);
  if (v3)
  {
    dispatch_group_leave(v3);
    uint64_t v4 = *(NSObject **)(a1 + 16);
    if (v4) {
      dispatch_release(v4);
    }
  }
  return a1;
}

void sub_10055DB20(uint64_t a1)
{
  *(void *)a1 = off_1019E38D0;
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 40);
  if (v2) {
    sub_10004D2C8(v2);
  }
  sub_1000558F4((const void **)(a1 + 24));
  uint64_t v3 = *(NSObject **)(a1 + 16);
  if (v3)
  {
    dispatch_group_leave(v3);
    uint64_t v4 = *(NSObject **)(a1 + 16);
    if (v4) {
      dispatch_release(v4);
    }
  }

  operator delete();
}

void *sub_10055DBAC(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t v2 = operator new(0x30uLL);
  void *v2 = off_1019E38D0;
  sub_10055E0AC((uint64_t)(v2 + 1), v1);
  return v2;
}

uint64_t sub_10055DC00(uint64_t a1, void *a2)
{
  *a2 = off_1019E38D0;
  return sub_10055E0AC((uint64_t)(a2 + 1), a1 + 8);
}

void sub_10055DC2C(uint64_t a1)
{
}

void sub_10055DC34(void *a1)
{
  sub_10055E114((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_10055DC70(uint64_t a1, unsigned __int8 *a2)
{
  int v3 = *a2;
  uint64_t v5 = (void *)*((void *)a2 + 1);
  unint64_t v4 = *((void *)a2 + 2);
  *(_DWORD *)uint64_t v26 = *((_DWORD *)a2 + 6);
  *(_DWORD *)&v26[3] = *(_DWORD *)(a2 + 27);
  int v6 = (char)a2[31];
  *((void *)a2 + 1) = 0;
  *((void *)a2 + 2) = 0;
  uint64_t v7 = (void *)*((void *)a2 + 4);
  unint64_t v8 = *((void *)a2 + 5);
  *(_DWORD *)&v25[3] = *(_DWORD *)(a2 + 51);
  *(_DWORD *)unint64_t v25 = *((_DWORD *)a2 + 12);
  int v9 = (char)a2[55];
  *((void *)a2 + 3) = 0;
  *((void *)a2 + 4) = 0;
  *((void *)a2 + 5) = 0;
  *((void *)a2 + 6) = 0;
  uint64_t v10 = *(void **)(a1 + 8);
  std::string __dst = 0;
  unint64_t v31 = 0;
  uint64_t v32 = 0;
  if (v6 < 0)
  {
    sub_10004FC84(&__dst, v5, v4);
  }
  else
  {
    std::string __dst = v5;
    unint64_t v31 = v4;
    LODWORD(v32) = *(_DWORD *)v26;
    *(_DWORD *)((char *)&v32 + 3) = *(_DWORD *)&v26[3];
    HIBYTE(v32) = v6;
  }
  CFTypeID v27 = 0;
  unint64_t v28 = 0;
  uint64_t v29 = 0;
  if (v9 < 0)
  {
    sub_10004FC84(&v27, v7, v8);
  }
  else
  {
    CFTypeID v27 = v7;
    unint64_t v28 = v8;
    LODWORD(v29) = *(_DWORD *)v25;
    *(_DWORD *)((char *)&v29 + 3) = *(_DWORD *)&v25[3];
    HIBYTE(v29) = v9;
  }
  if (v3 == 4)
  {
    CFArrayRef v11 = v10[5];
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v37 = *(void *)(a1 + 24);
      sub_1000292E0((uint64_t)__p);
      uint64_t v12 = SHIBYTE(v34) >= 0 ? __p : (void **)__p[0];
      *(_DWORD *)long long buf = 136446210;
      *(void *)&uint8_t buf[4] = v12;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I Update downloaded for bundle: %{public}s", buf, 0xCu);
      if (SHIBYTE(v34) < 0) {
        operator delete(__p[0]);
      }
    }
    *(void *)long long buf = *(void *)(a1 + 24);
    double v13 = sub_1000292E0((uint64_t)__p);
    int v14 = (*(uint64_t (**)(void *, void **, void **, void, double))(*v10 + 24))(v10, __p, &__dst, 0, v13);
    if (SHIBYTE(v34) < 0) {
      operator delete(__p[0]);
    }
    if ((_BYTE)v14)
    {
      LOBYTE(v3) = 4;
    }
    else if ((v14 & 0xFF0000) != 0)
    {
      LOBYTE(v3) = 5;
    }
    else
    {
      LOBYTE(v3) = 7;
    }
  }
  CFTypeID v15 = *(uint64_t **)(a1 + 32);
  sub_100083DA4((const void **)buf, (const void **)(a1 + 24));
  uint8_t buf[8] = v3;
  unint64_t v16 = v15[1];
  unint64_t v17 = v15[2];
  if (v16 >= v17)
  {
    uint64_t v19 = (uint64_t)(v16 - *v15) >> 4;
    if ((unint64_t)(v19 + 1) >> 60) {
      sub_10006A748();
    }
    uint64_t v20 = v17 - *v15;
    uint64_t v21 = v20 >> 3;
    if (v20 >> 3 <= (unint64_t)(v19 + 1)) {
      uint64_t v21 = v19 + 1;
    }
    if ((unint64_t)v20 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v22 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v22 = v21;
    }
    xpc_object_t v36 = v15 + 2;
    if (v22) {
      uint64_t v23 = (char *)sub_10006A794((uint64_t)(v15 + 2), v22);
    }
    else {
      uint64_t v23 = 0;
    }
    int v24 = &v23[16 * v19];
    __p[0] = v23;
    __p[1] = v24;
    xpc_object_t v35 = &v23[16 * v22];
    sub_100062708(v24, *(CFTypeRef *)buf);
    v24[8] = buf[8];
    xpc_object_t v34 = v24 + 16;
    sub_10055D6C4(v15, __p);
    uint64_t v18 = v15[1];
    sub_10055D72C((uint64_t)__p);
  }
  else
  {
    sub_100062708((void *)v15[1], *(CFTypeRef *)buf);
    *(unsigned char *)(v16 + 8) = buf[8];
    uint64_t v18 = v16 + 16;
  }
  v15[1] = v18;
  sub_1000558F4((const void **)buf);
  if (SHIBYTE(v29) < 0) {
    operator delete(v27);
  }
  if (SHIBYTE(v32) < 0)
  {
    operator delete(__dst);
    if ((v9 & 0x80000000) == 0)
    {
LABEL_37:
      if ((v6 & 0x80000000) == 0) {
        return;
      }
LABEL_41:
      operator delete(v5);
      return;
    }
  }
  else if ((v9 & 0x80000000) == 0)
  {
    goto LABEL_37;
  }
  operator delete(v7);
  if (v6 < 0) {
    goto LABEL_41;
  }
}

void sub_10055DFC0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  if (a22 < 0)
  {
    operator delete(a17);
    if ((v31 & 0x80000000) == 0) {
      goto LABEL_5;
    }
  }
  else if ((v31 & 0x80000000) == 0)
  {
LABEL_5:
    if ((v30 & 0x80000000) == 0) {
      goto LABEL_7;
    }
    goto LABEL_6;
  }
  operator delete(v29);
  if ((v30 & 0x80000000) == 0) {
LABEL_7:
  }
    _Unwind_Resume(a1);
LABEL_6:
  operator delete(v28);
  goto LABEL_7;
}

uint64_t sub_10055E060(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10055E0A0()
{
}

uint64_t sub_10055E0AC(uint64_t a1, uint64_t a2)
{
  unint64_t v4 = *(NSObject **)(a2 + 8);
  *(void *)a1 = *(void *)a2;
  *(void *)(a1 + 8) = v4;
  if (v4)
  {
    dispatch_retain(v4);
    uint64_t v5 = *(NSObject **)(a1 + 8);
    if (v5) {
      dispatch_group_enter(v5);
    }
  }
  sub_100083DA4((const void **)(a1 + 16), (const void **)(a2 + 16));
  uint64_t v6 = *(void *)(a2 + 32);
  *(void *)(a1 + 24) = *(void *)(a2 + 24);
  *(void *)(a1 + 32) = v6;
  if (v6) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v6 + 8), 1uLL, memory_order_relaxed);
  }
  return a1;
}

void sub_10055E114(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 32);
  if (v2) {
    sub_10004D2C8(v2);
  }
  sub_1000558F4((const void **)(a1 + 16));
  int v3 = *(NSObject **)(a1 + 8);
  if (v3)
  {
    dispatch_group_leave(v3);
    unint64_t v4 = *(NSObject **)(a1 + 8);
    if (v4)
    {
      dispatch_release(v4);
    }
  }
}

void *sub_10055E178(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t sub_10055E1FC(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

void **sub_10055E294(void **result)
{
  uint64_t v1 = *result;
  *BOOL result = 0;
  if (v1)
  {
    uint64_t v2 = (std::__shared_weak_count *)v1[5];
    if (v2) {
      sub_10004D2C8(v2);
    }
    sub_10055D77C(v1);
    operator delete();
  }
  return result;
}

uint64_t sub_10055E2EC(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (void *)(a2 + 24);
  uint64_t v4 = *(void *)(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(*(void *)*v3 + 24))(*v3, a1);
      return a1;
    }
    *(void *)(a1 + 24) = v4;
  }
  else
  {
    uint64_t v3 = (void *)(a1 + 24);
  }
  *uint64_t v3 = 0;
  return a1;
}

void **sub_10055E36C(uint64_t a1)
{
  uint64_t v4 = (void *)a1;
  memset(v5, 0, sizeof(v5));
  sub_10055D914(v5, **(void **)(a1 + 32), *(void *)(*(void *)(a1 + 32) + 8), (uint64_t)(*(void *)(*(void *)(a1 + 32) + 8) - **(void **)(a1 + 32)) >> 4);
  uint64_t v2 = *(void *)(a1 + 24);
  if (!v2) {
    sub_10007B600();
  }
  (*(void (**)(uint64_t, const void **))(*(void *)v2 + 48))(v2, v5);
  uint64_t v6 = v5;
  sub_10055D640((void ***)&v6);
  return sub_10055E294(&v4);
}

void sub_10055E404(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_10055E294((void **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_10055E430(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

uint64_t sub_10055E4C8(uint64_t a1)
{
  *(void *)a1 = off_1019E3960;
  if (*(char *)(a1 + 111) < 0) {
    operator delete(*(void **)(a1 + 88));
  }
  if (*(char *)(a1 + 87) < 0) {
    operator delete(*(void **)(a1 + 64));
  }
  sub_10055E178((void *)(a1 + 32));
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 24);
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

void sub_10055E53C(uint64_t a1)
{
  *(void *)a1 = off_1019E3960;
  if (*(char *)(a1 + 111) < 0) {
    operator delete(*(void **)(a1 + 88));
  }
  if (*(char *)(a1 + 87) < 0) {
    operator delete(*(void **)(a1 + 64));
  }
  sub_10055E178((void *)(a1 + 32));
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 24);
  if (v2) {
    sub_10004D2C8(v2);
  }

  operator delete();
}

void *sub_10055E5D0(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t v2 = operator new(0x70uLL);
  void *v2 = off_1019E3960;
  sub_10055EA48((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_10055E624(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_10055E638(uint64_t a1, void *a2)
{
  *a2 = off_1019E3960;
  return sub_10055EA48((uint64_t)(a2 + 1), a1 + 8);
}

void sub_10055E664(uint64_t a1)
{
}

void sub_10055E66C(void *a1)
{
  sub_10055EB44((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_10055E6A8(uint64_t a1, unsigned char *a2)
{
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v4 = *(NSObject **)(v3 + 40);
  if (*a2)
  {
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v5 = a1 + 64;
      if (*(char *)(a1 + 87) < 0) {
        uint64_t v5 = *(void *)(a1 + 64);
      }
      *(_DWORD *)long long buf = 136446210;
      uint64_t v9 = v5;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Update has been successfully downloaded at %{public}s", buf, 0xCu);
    }
    char v6 = 4;
  }
  else
  {
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "Failed to download and save the update", buf, 2u);
    }
    char v6 = 6;
  }
  sub_10055E430((uint64_t)buf, a1 + 32);
  char v10 = v6;
  if (*(char *)(a1 + 87) < 0)
  {
    sub_10004FC84(v11, *(void **)(a1 + 64), *(void *)(a1 + 72));
  }
  else
  {
    *(_OWORD *)CFArrayRef v11 = *(_OWORD *)(a1 + 64);
    void v11[2] = *(void **)(a1 + 80);
  }
  if (*(char *)(a1 + 111) < 0)
  {
    sub_10004FC84(__p, *(void **)(a1 + 88), *(void *)(a1 + 96));
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)(a1 + 88);
    xpc_object_t __p[2] = *(void **)(a1 + 104);
  }
  v7[0] = 0;
  v7[1] = 0;
  sub_10003E168(v7, (void *)(v3 + 8));
  operator new();
}

void sub_10055E930(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  if (a23 < 0) {
    operator delete(__p);
  }
  sub_10055E178(&a13);
  _Unwind_Resume(a1);
}

uint64_t sub_10055E97C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10055E9BC()
{
}

uint64_t sub_10055E9C8(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (void *)(a2 + 24);
  uint64_t v4 = *(void *)(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(*(void *)*v3 + 24))(*v3, a1);
      return a1;
    }
    *(void *)(a1 + 24) = v4;
  }
  else
  {
    uint64_t v3 = (void *)(a1 + 24);
  }
  *uint64_t v3 = 0;
  return a1;
}

uint64_t sub_10055EA48(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = *(_OWORD *)a2;
  uint64_t v4 = *(void *)(a2 + 16);
  *(void *)(a1 + 16) = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  sub_10055E430(a1 + 24, a2 + 24);
  if (*(char *)(a2 + 79) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 56), *(void **)(a2 + 56), *(void *)(a2 + 64));
  }
  else
  {
    long long v5 = *(_OWORD *)(a2 + 56);
    *(void *)(a1 + 72) = *(void *)(a2 + 72);
    *(_OWORD *)(a1 + 56) = v5;
  }
  char v6 = (unsigned char *)(a1 + 80);
  if (*(char *)(a2 + 103) < 0)
  {
    sub_10004FC84(v6, *(void **)(a2 + 80), *(void *)(a2 + 88));
  }
  else
  {
    long long v7 = *(_OWORD *)(a2 + 80);
    *(void *)(a1 + 96) = *(void *)(a2 + 96);
    *(_OWORD *)char v6 = v7;
  }
  return a1;
}

void sub_10055EB04(_Unwind_Exception *a1)
{
  if (*(char *)(v1 + 79) < 0) {
    operator delete(*v3);
  }
  sub_10055E178(v2);
  long long v5 = *(std::__shared_weak_count **)(v1 + 16);
  if (v5) {
    sub_10004D2C8(v5);
  }
  _Unwind_Resume(a1);
}

void sub_10055EB44(uint64_t a1)
{
  if (*(char *)(a1 + 103) < 0) {
    operator delete(*(void **)(a1 + 80));
  }
  if (*(char *)(a1 + 79) < 0) {
    operator delete(*(void **)(a1 + 56));
  }
  sub_10055E178((void *)(a1 + 24));
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2)
  {
    sub_10004D2C8(v2);
  }
}

uint64_t *sub_10055EBB0(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v4 = a1;
  uint64_t v5 = v1;
  sub_10055ED08((uint64_t)v6, (unsigned char *)(v1 + 32), (long long *)(v1 + 40), (long long *)(v1 + 64));
  uint64_t v2 = *(void *)(v1 + 24);
  if (!v2) {
    sub_10007B600();
  }
  (*(void (**)(uint64_t, unsigned char *))(*(void *)v2 + 48))(v2, v6);
  if (v10 < 0) {
    operator delete(__p);
  }
  if (v8 < 0) {
    operator delete(v7);
  }
  sub_10055EC9C(&v5);
  return sub_100046B58((uint64_t *)&v4);
}

void sub_10055EC58(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, int a15, __int16 a16, char a17, char a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24)
{
}

uint64_t *sub_10055EC9C(uint64_t *result)
{
  uint64_t v1 = *result;
  *BOOL result = 0;
  if (v1)
  {
    if (*(char *)(v1 + 87) < 0) {
      operator delete(*(void **)(v1 + 64));
    }
    if (*(char *)(v1 + 63) < 0) {
      operator delete(*(void **)(v1 + 40));
    }
    sub_10055E178((void *)v1);
    operator delete();
  }
  return result;
}

uint64_t sub_10055ED08(uint64_t a1, unsigned char *a2, long long *a3, long long *a4)
{
  *(unsigned char *)a1 = *a2;
  if (*((char *)a3 + 23) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 8), *(void **)a3, *((void *)a3 + 1));
  }
  else
  {
    long long v6 = *a3;
    *(void *)(a1 + 24) = *((void *)a3 + 2);
    *(_OWORD *)(a1 + 8) = v6;
  }
  long long v7 = (unsigned char *)(a1 + 32);
  if (*((char *)a4 + 23) < 0)
  {
    sub_10004FC84(v7, *(void **)a4, *((void *)a4 + 1));
  }
  else
  {
    long long v8 = *a4;
    *(void *)(a1 + 48) = *((void *)a4 + 2);
    *(_OWORD *)long long v7 = v8;
  }
  return a1;
}

void sub_10055ED94(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 31) < 0) {
    operator delete(*v2);
  }
  _Unwind_Resume(exception_object);
}

uint64_t *sub_10055EDB0(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v58 = a1;
  uint64_t v59 = v1;
  uint64_t v2 = *(void **)v1;
  sub_100062740((const void **)&theArray, (const void **)(v1 + 8));
  int v57 = *(unsigned __int8 *)(v1 + 16);
  sub_10055E1FC((uint64_t)v75, v1 + 24);
  long long v70 = 0uLL;
  long long v71 = 0;
  if (theArray) {
    uint64_t v3 = sub_100083F10;
  }
  else {
    uint64_t v3 = 0;
  }
  if (v3)
  {
    BOOL v4 = sub_1005B6DE8();
    if (v4)
    {
      uint64_t v5 = v2[5];
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Verification turned off. Not checking digest for transferred bundles.", buf, 2u);
      }
    }
    CFIndex Count = CFArrayGetCount(theArray);
    CFIndex v7 = Count;
    if (Count >= 1)
    {
      CFIndex v8 = 0;
      CFIndex v56 = Count;
      while (1)
      {
        CFDictionaryRef theDict = 0;
        *(void *)long long buf = CFArrayGetValueAtIndex(theArray, v8);
        sub_10004EFE4(&theDict, (CFTypeRef *)buf);
        if (theDict ? sub_100080778 : 0) {
          break;
        }
LABEL_110:
        sub_100057D78((const void **)&theDict);
        if (++v8 == v7) {
          goto LABEL_111;
        }
      }
      v67[0] = 0;
      v67[1] = 0;
      uint64_t v68 = 0;
      CFDictionaryGetValue(theDict, @"BundleID");
      memset(buf, 0, sizeof(buf));
      ctu::cf::assign();
      *(_OWORD *)CFTypeRef v67 = *(_OWORD *)buf;
      uint64_t v68 = *(void *)&buf[16];
      v65[0] = 0;
      v65[1] = 0;
      uint64_t v66 = 0;
      CFDictionaryGetValue(theDict, @"LocalFilePath");
      memset(buf, 0, sizeof(buf));
      ctu::cf::assign();
      *(_OWORD *)uint64_t v65 = *(_OWORD *)buf;
      uint64_t v66 = *(void *)&buf[16];
      CFArrayRef Value = (BOOL *)CFDictionaryGetValue(theDict, @"UseOldUpdateFormat");
      CFArrayRef v11 = Value;
      buf[0] = 0;
      if (Value)
      {
        CFTypeID v12 = CFGetTypeID(Value);
        if (v12 == CFBooleanGetTypeID()) {
          ctu::cf::assign((ctu::cf *)buf, v11, v13);
        }
        int v14 = buf[0];
      }
      else
      {
        int v14 = 0;
      }
      CFTypeID v15 = (void *)HIBYTE(v68);
      if (v68 < 0) {
        CFTypeID v15 = v67[1];
      }
      if (v15)
      {
        unint64_t v16 = (void *)HIBYTE(v66);
        if (v66 < 0) {
          unint64_t v16 = v65[1];
        }
        if (v16)
        {
          if (v4)
          {
LABEL_26:
            BOOL v17 = v4;
            uint64_t v18 = (uint64_t)v2;
            uint64_t v19 = (*(uint64_t (**)(void *, void **, void **, void))(*v2 + 24))(v2, v67, v65, 2 * (v57 != 0));
            __int16 v20 = v19;
            if ((v19 & 0xFF0000) != 0) {
              int v21 = 5;
            }
            else {
              int v21 = 7;
            }
            if ((_BYTE)v19) {
              unsigned int v22 = 4;
            }
            else {
              unsigned int v22 = v21;
            }
            uint64_t v23 = (int *)CFDictionaryGetValue(theDict, @"kUpdateBundleType");
            int v24 = v23;
            *(_DWORD *)long long buf = 0;
            if (v23)
            {
              CFTypeID v25 = CFGetTypeID(v23);
              if (v25 == CFNumberGetTypeID()) {
                ctu::cf::assign((ctu::cf *)buf, v24, v26);
              }
            }
            uint8_t v27 = buf[0];
            memset(__p, 0, 24);
            CFDictionaryGetValue(theDict, @"BundleVersion");
            memset(buf, 0, sizeof(buf));
            ctu::cf::assign();
            *(_OWORD *)std::string __p = *(_OWORD *)buf;
            xpc_object_t __p[2] = *(void **)&buf[16];
            if (v14)
            {
              CFDictionaryGetValue(theDict, @"BuildVersion");
              memset(buf, 0, sizeof(buf));
              ctu::cf::assign();
              unint64_t v28 = *(void **)buf;
              *(void *)&long long v77 = *(void *)&buf[8];
              *(void *)((char *)&v77 + 7) = *(void *)&buf[15];
              uint8_t v29 = buf[23];
              if (SHIBYTE(__p[2]) < 0) {
                operator delete(__p[0]);
              }
              __p[0] = v28;
              __p[1] = (void *)v77;
              *(void **)((char *)&__p[1] + 7) = *(void **)((char *)&v77 + 7);
              HIBYTE(__p[2]) = v29;
            }
            CFTypeRef cf = 0;
            if (SHIBYTE(v68) < 0)
            {
              sub_10004FC84(__dst, v67[0], (unint64_t)v67[1]);
            }
            else
            {
              *(_OWORD *)std::string __dst = *(_OWORD *)v67;
              uint64_t v62 = v68;
            }
            if (SHIBYTE(v62) < 0)
            {
              sub_10004FC84(&v77, __dst[0], (unint64_t)__dst[1]);
            }
            else
            {
              long long v77 = *(_OWORD *)__dst;
              uint64_t v78 = v62;
            }
            char v72 = 0;
            if (SHIBYTE(v78) < 0)
            {
              sub_10004FC84(buf, (void *)v77, *((unint64_t *)&v77 + 1));
            }
            else
            {
              *(_OWORD *)long long buf = v77;
              *(void *)&uint8_t buf[16] = v78;
            }
            long long v73 = 0;
            if (ctu::cf::convert_copy())
            {
              xpc_object_t v36 = v72;
              char v72 = v73;
              long long v74 = v36;
              sub_1000558F4(&v74);
            }
            if ((char)buf[23] < 0) {
              operator delete(*(void **)buf);
            }
            CFTypeRef cf = v72;
            char v72 = 0;
            sub_1000558F4(&v72);
            if (SHIBYTE(v78) < 0) {
              operator delete((void *)v77);
            }
            if (SHIBYTE(v62) < 0) {
              operator delete(__dst[0]);
            }
            *(void *)&long long v77 = cf;
            if (cf) {
              CFRetain(cf);
            }
            BYTE8(v77) = v22;
            if (*((void *)&v70 + 1) >= (unint64_t)v71)
            {
              uint64_t v39 = (uint64_t)(*((void *)&v70 + 1) - v70) >> 4;
              if ((unint64_t)(v39 + 1) >> 60) {
                sub_10006A748();
              }
              unint64_t v40 = (uint64_t)&v71[-v70] >> 3;
              if (v40 <= v39 + 1) {
                unint64_t v40 = v39 + 1;
              }
              if ((unint64_t)&v71[-v70] >= 0x7FFFFFFFFFFFFFF0) {
                unint64_t v41 = 0xFFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v41 = v40;
              }
              std::string v81 = &v71;
              if (v41) {
                BOOL v42 = (char *)sub_10006A794((uint64_t)&v71, v41);
              }
              else {
                BOOL v42 = 0;
              }
              uint64_t v46 = &v42[16 * v39];
              *(void *)long long buf = v42;
              *(void *)&uint8_t buf[8] = v46;
              std::string v80 = &v42[16 * v41];
              sub_100062708(v46, (CFTypeRef)v77);
              v46[8] = BYTE8(v77);
              xpc_object_t v38 = v46 + 16;
              *(void *)&uint8_t buf[16] = v38;
              uint64_t v47 = *((void *)&v70 + 1);
              uint64_t v48 = v70;
              uint64_t v49 = *(void *)&buf[8];
              if (*((void *)&v70 + 1) == (void)v70)
              {
                int64x2_t v51 = vdupq_n_s64(*((unint64_t *)&v70 + 1));
              }
              else
              {
                do
                {
                  *(void *)(v49 - 16) = 0;
                  v49 -= 16;
                  uint64_t v50 = *(void *)(v47 - 16);
                  v47 -= 16;
                  *(void *)uint64_t v49 = v50;
                  *(void *)uint64_t v47 = 0;
                  *(unsigned char *)(v49 + 8) = *(unsigned char *)(v47 + 8);
                }
                while (v47 != v48);
                int64x2_t v51 = (int64x2_t)v70;
                xpc_object_t v38 = *(void **)&buf[16];
              }
              *(void *)&long long v70 = v49;
              *((void *)&v70 + 1) = v38;
              *(int64x2_t *)&uint8_t buf[8] = v51;
              CFTypeRef v52 = v71;
              long long v71 = v80;
              std::string v80 = v52;
              *(void *)long long buf = v51.i64[0];
              sub_10055D72C((uint64_t)buf);
            }
            else
            {
              uint64_t v37 = sub_100062708(*((void **)&v70 + 1), (CFTypeRef)v77);
              *((unsigned char *)v37 + 8) = BYTE8(v77);
              xpc_object_t v38 = v37 + 2;
            }
            *((void *)&v70 + 1) = v38;
            sub_1000558F4((const void **)&v77);
            (*(void (**)(uint8_t *__return_ptr))(**(void **)(v18 + 64) + 120))(buf);
            sub_10092D4C0(v18, v22, v27, v67, (void **)buf, __p, (v20 & 0xFF00) != 0, v57 != 0);
            uint64_t v2 = (void *)v18;
            CFIndex v7 = v56;
            BOOL v4 = v17;
            if ((char)buf[23] < 0) {
              operator delete(*(void **)buf);
            }
            sub_1000558F4(&cf);
            if (SHIBYTE(__p[2]) < 0) {
              operator delete(__p[0]);
            }
            goto LABEL_106;
          }
          *(void *)&long long v77 = 0;
          if (v14) {
            CFStringRef v30 = @"Digest3";
          }
          else {
            CFStringRef v30 = @"Digest";
          }
          *(void *)long long buf = v30;
          int v31 = CFDictionaryGetValue(theDict, v30);
          uint64_t v32 = v31;
          if (v31 && (CFTypeID v33 = CFGetTypeID(v31), v33 == CFDataGetTypeID()))
          {
            *(void *)&long long v77 = v32;
            CFRetain(v32);
          }
          else
          {
            *(void *)&long long v77 = 0;
          }
          sub_1000558F4((const void **)buf);
          if ((void)v77) {
            xpc_object_t v34 = sub_10008324C;
          }
          else {
            xpc_object_t v34 = 0;
          }
          if (v34)
          {
            __p[0] = 0;
            getDigestForIpcc();
            if (__p[0]) {
              xpc_object_t v35 = sub_10008324C;
            }
            else {
              xpc_object_t v35 = 0;
            }
            if (v35)
            {
              if (CFEqual(__p[0], (CFTypeRef)v77))
              {
                sub_100030068((const void **)__p);
                sub_100030068((const void **)&v77);
                goto LABEL_26;
              }
              CFTypeRef v53 = v2[5];
              if (os_log_type_enabled(v53, OS_LOG_TYPE_DEFAULT))
              {
                *(_WORD *)long long buf = 0;
                _os_log_impl((void *)&_mh_execute_header, v53, OS_LOG_TYPE_DEFAULT, "#N Verification failed for the downloaded bundle", buf, 2u);
              }
            }
            else
            {
              uint64_t v44 = v2[5];
              if (os_log_type_enabled(v44, OS_LOG_TYPE_ERROR))
              {
                uint64_t v45 = v65;
                if (v66 < 0) {
                  uint64_t v45 = (void **)v65[0];
                }
                *(_DWORD *)long long buf = 136446210;
                *(void *)&uint8_t buf[4] = v45;
                _os_log_error_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_ERROR, "Could not generate digest for: %{public}s", buf, 0xCu);
              }
            }
            sub_100030068((const void **)__p);
          }
          else
          {
            __int16 v43 = v2[5];
            if (os_log_type_enabled(v43, OS_LOG_TYPE_ERROR))
            {
              *(_WORD *)long long buf = 0;
              _os_log_error_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_ERROR, "Empty bundle Digest", buf, 2u);
            }
          }
          sub_100030068((const void **)&v77);
        }
      }
LABEL_106:
      if (SHIBYTE(v66) < 0) {
        operator delete(v65[0]);
      }
      if (SHIBYTE(v68) < 0) {
        operator delete(v67[0]);
      }
      goto LABEL_110;
    }
LABEL_111:
    memset(buf, 0, sizeof(buf));
    sub_10055D914((const void **)buf, v70, *((uint64_t *)&v70 + 1), (uint64_t)(*((void *)&v70 + 1) - v70) >> 4);
    uint64_t v54 = v76;
    if (!v76) {
      sub_10007B600();
    }
  }
  else
  {
    memset(buf, 0, sizeof(buf));
    uint64_t v54 = v76;
    if (!v76) {
      sub_10007B600();
    }
  }
  (*(void (**)(uint64_t, uint8_t *))(*(void *)v54 + 48))(v54, buf);
  *(void *)&long long v77 = buf;
  sub_10055D640((void ***)&v77);
  *(void *)&long long v77 = &v70;
  sub_10055D640((void ***)&v77);
  sub_10055D77C(v75);
  sub_100044D00((const void **)&theArray);
  sub_10055F964(&v59);
  return sub_100046B58((uint64_t *)&v58);
}

void sub_10055F774(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, char a20,int a21,__int16 a22,char a23,char a24,int a25,__int16 a26,char a27,char a28,void *a29,uint64_t a30,int a31,__int16 a32,char a33,char a34,char a35,void *__p,uint64_t a37,int a38,__int16 a39,char a40,char a41,uint64_t a42,void *a43,uint64_t a44,int a45,__int16 a46,char a47,char a48,uint64_t a49,void *a50,uint64_t a51,int a52,__int16 a53,char a54,char a55,char a56,int a57,__int16 a58,char a59,char a60)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t *sub_10055F964(uint64_t *result)
{
  uint64_t v1 = *result;
  *BOOL result = 0;
  if (v1)
  {
    sub_10055D77C((void *)(v1 + 24));
    sub_100044D00((const void **)(v1 + 8));
    operator delete();
  }
  return result;
}

time_t sub_10055F9BC(const std::string *a1)
{
  memset(&v20, 0, sizeof(v20));
  long long v18 = 0u;
  long long v19 = 0u;
  long long v16 = 0u;
  long long v17 = 0u;
  long long v14 = 0u;
  long long v15 = 0u;
  long long v12 = 0u;
  long long v13 = 0u;
  long long v10 = 0u;
  long long v11 = 0u;
  *(_OWORD *)std::string __p = 0u;
  long long v9 = 0u;
  long long v6 = 0u;
  long long v7 = 0u;
  long long v4 = 0u;
  long long v5 = 0u;
  long long v3 = 0u;
  sub_1003C09B4((void (__cdecl ***)(std::istringstream *__hidden))&v3, a1, 8);
  sub_10055FB54((uint64_t)&v3);
  time_t v1 = mktime(&v20);
  if (SBYTE7(v9) < 0) {
    operator delete(__p[0]);
  }
  std::streambuf::~streambuf();
  std::istream::~istream();
  std::ios::~ios();
  return v1;
}

void sub_10055FB3C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sub_1003C0B38((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_10055FB54(uint64_t a1)
{
  return a1;
}

void sub_10055FC64(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, std::locale a9)
{
  std::locale::~locale(&a9);
  __cxa_begin_catch(a1);
  std::ios_base::__set_badbit_and_consider_rethrow((std::ios_base *)((char *)v9 + *(void *)(*v9 - 24)));
  __cxa_end_catch();
  JUMPOUT(0x10055FC48);
}

void sub_10055FCAC(_Unwind_Exception *a1)
{
}

void *sub_10055FCC0@<X0>(time_t a1@<X0>, void *a2@<X8>)
{
  time_t v5 = a1;
  if (a1)
  {
    memset(&v4, 0, sizeof(v4));
    localtime_r(&v5, &v4);
    long long v36 = 0u;
    long long v37 = 0u;
    long long v34 = 0u;
    long long v35 = 0u;
    long long v32 = 0u;
    long long v33 = 0u;
    long long v30 = 0u;
    long long v31 = 0u;
    long long v28 = 0u;
    long long v29 = 0u;
    long long v26 = 0u;
    long long v27 = 0u;
    long long v24 = 0u;
    long long v25 = 0u;
    long long v22 = 0u;
    long long v23 = 0u;
    long long v20 = 0u;
    long long v21 = 0u;
    long long v18 = 0u;
    long long v19 = 0u;
    long long v16 = 0u;
    long long v17 = 0u;
    long long v14 = 0u;
    long long v15 = 0u;
    long long v12 = 0u;
    long long v13 = 0u;
    long long v10 = 0u;
    long long v11 = 0u;
    long long v8 = 0u;
    long long v9 = 0u;
    *(_OWORD *)__s = 0u;
    long long v7 = 0u;
    strftime(__s, 0x200uLL, "%Y-%m-%d %H:%M:%S", &v4);
    return sub_100058DB0(a2, __s);
  }
  else
  {
    return sub_100058DB0(a2, "(null)");
  }
}

void *sub_10055FDE4@<X0>(time_t a1@<X0>, void *a2@<X8>)
{
  time_t v5 = a1;
  long long v3 = localtime(&v5);
  long long v36 = 0u;
  long long v37 = 0u;
  long long v34 = 0u;
  long long v35 = 0u;
  long long v32 = 0u;
  long long v33 = 0u;
  long long v30 = 0u;
  long long v31 = 0u;
  long long v28 = 0u;
  long long v29 = 0u;
  long long v26 = 0u;
  long long v27 = 0u;
  long long v24 = 0u;
  long long v25 = 0u;
  long long v22 = 0u;
  long long v23 = 0u;
  long long v20 = 0u;
  long long v21 = 0u;
  long long v18 = 0u;
  long long v19 = 0u;
  long long v16 = 0u;
  long long v17 = 0u;
  long long v14 = 0u;
  long long v15 = 0u;
  long long v12 = 0u;
  long long v13 = 0u;
  long long v10 = 0u;
  long long v11 = 0u;
  long long v8 = 0u;
  long long v9 = 0u;
  *(_OWORD *)__s = 0u;
  long long v7 = 0u;
  strftime(__s, 0x200uLL, "%Y-%m-%dT%H:%M:%S.000Z", v3);
  return sub_100058DB0(a2, __s);
}

void sub_10055FEB8(Registry **a1@<X0>, void *a2@<X8>)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(*a1);
  time_t v5 = ServiceMap;
  unint64_t v7 = v6;
  if ((v6 & 0x8000000000000000) != 0)
  {
    long long v8 = (unsigned __int8 *)(v6 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v9 = 5381;
    do
    {
      unint64_t v7 = v9;
      unsigned int v10 = *v8++;
      uint64_t v9 = (33 * v9) ^ v10;
    }
    while (v10);
  }
  std::mutex::lock(ServiceMap);
  *(void *)&long long v36 = v7;
  long long v11 = sub_10004D37C(&v5[1].__m_.__sig, (unint64_t *)&v36);
  if (v11)
  {
    uint64_t v13 = v11[3];
    long long v12 = (std::__shared_weak_count *)v11[4];
    if (v12)
    {
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v5);
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v12);
      char v14 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v13 = 0;
  }
  std::mutex::unlock(v5);
  long long v12 = 0;
  char v14 = 1;
LABEL_9:
  time_t v55 = (uint64_t)(kCFAbsoluteTimeIntervalSince1970
                + (double)(uint64_t)(*(double (**)(uint64_t))(*(void *)v13 + 96))(v13));
  tm_zone = 0;
  long long v52 = 0u;
  long long v53 = 0u;
  long long v51 = 0u;
  long long v15 = localtime(&v55);
  long long v16 = *(_OWORD *)&v15->tm_sec;
  long long v17 = *(_OWORD *)&v15->tm_mon;
  long long v18 = *(_OWORD *)&v15->tm_isdst;
  tm_zone = v15->tm_zone;
  long long v52 = v17;
  long long v53 = v18;
  long long v51 = v16;
  uint64_t v50 = 0;
  long long v48 = 0u;
  long long v49 = 0u;
  long long v46 = 0u;
  long long v47 = 0u;
  long long v44 = 0u;
  long long v45 = 0u;
  long long v42 = 0u;
  long long v43 = 0u;
  long long v41 = 0u;
  long long v39 = 0u;
  long long v40 = 0u;
  *(_OWORD *)std::string __p = 0u;
  long long v36 = 0u;
  memset(v37, 0, sizeof(v37));
  sub_10004BD84((uint64_t)&v36);
  v56[0] = 0;
  v56[1] = 0;
  std::ostream::sentry::sentry();
  if (LOBYTE(v56[0]))
  {
    std::ios_base::getloc((const std::ios_base *)((char *)v37 + *(void *)(*(void *)&v37[0] - 24)));
    std::locale::use_facet(&v57, &std::time_put<char,std::ostreambuf_iterator<char>>::id);
    std::locale::~locale(&v57);
    long long v19 = (const std::ios_base *)((char *)v37 + *(void *)(*(void *)&v37[0] - 24));
    if (v19[1].__fmtflags_ == -1)
    {
      std::ios_base::getloc(v19);
      long long v20 = std::locale::use_facet(&v57, &std::ctype<char>::id);
      std::ios_base::fmtflags v21 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v20->__vftable[2].~facet_0)(v20, 32);
      std::locale::~locale(&v57);
      v19[1].__fmtflags_ = v21;
    }
    if (!std::time_put<char,std::ostreambuf_iterator<char>>::put()) {
      std::ios_base::clear((std::ios_base *)((char *)v37 + *(void *)(*(void *)&v37[0] - 24)), *(_DWORD *)((char *)&v37[2] + *(void *)(*(void *)&v37[0] - 24)) | 1);
    }
  }
  std::ostream::sentry::~sentry();
  CFTimeZoneRef tz = 0;
  long long v22 = (std::mutex *)Registry::getServiceMap(*a1);
  long long v23 = v22;
  if ((v6 & 0x8000000000000000) != 0)
  {
    long long v24 = (unsigned __int8 *)(v6 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v25 = 5381;
    do
    {
      unint64_t v6 = v25;
      unsigned int v26 = *v24++;
      uint64_t v25 = (33 * v25) ^ v26;
    }
    while (v26);
  }
  std::mutex::lock(v22);
  v56[0] = v6;
  long long v27 = sub_10004D37C(&v23[1].__m_.__sig, v56);
  if (v27)
  {
    uint64_t v29 = v27[3];
    long long v28 = (std::__shared_weak_count *)v27[4];
    if (v28)
    {
      atomic_fetch_add_explicit(&v28->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v23);
      atomic_fetch_add_explicit(&v28->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v28);
      char v30 = 0;
      goto LABEL_22;
    }
  }
  else
  {
    uint64_t v29 = 0;
  }
  std::mutex::unlock(v23);
  long long v28 = 0;
  char v30 = 1;
LABEL_22:
  (*(void (**)(CFTimeZoneRef *__return_ptr, uint64_t))(*(void *)v29 + 104))(&tz, v29);
  if ((v30 & 1) == 0) {
    sub_10004D2C8(v28);
  }
  double v31 = CFTimeZoneGetSecondsFromGMT(tz, (double)v55) / 3600.0;
  if (v31 <= 0.0) {
    long long v32 = "-";
  }
  else {
    long long v32 = "+";
  }
  sub_10004B96C(v37, (uint64_t)v32, 1);
  *(void *)((char *)&v37[1] + *(void *)(*(void *)&v37[0] - 24) + 8) = 2;
  LOBYTE(v56[0]) = 48;
  sub_1004DC904(v37, (char *)v56);
  std::ostream::operator<<();
  if (v31 == floor(v31)) {
    long long v33 = ":00";
  }
  else {
    long long v33 = ":30";
  }
  sub_10004B96C(v37, (uint64_t)v33, 3);
  sub_10004BC98((uint64_t)v37 + 8, a2);
  sub_1005653C4((const void **)&tz);
  *(void *)((char *)&v37[-1]
  *(void *)&v37[0] = v34;
  if (SHIBYTE(v39) < 0) {
    operator delete(__p[1]);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  std::ios::~ios();
  if ((v14 & 1) == 0) {
    sub_10004D2C8(v12);
  }
}

void sub_10056042C(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13)
{
  std::ostream::sentry::~sentry();
  __cxa_begin_catch(a1);
  std::ios_base::__set_badbit_and_consider_rethrow((std::ios_base *)(v13 + *(void *)(a13 - 24)));
  __cxa_end_catch();
  JUMPOUT(0x100560160);
}

void sub_1005604A0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sub_10008248C((uint64_t)va);
  if ((v4 & 1) == 0) {
    sub_10004D2C8(v3);
  }
  _Unwind_Resume(a1);
}

time_t sub_100560500(const std::string *a1)
{
  long long v19 = 0u;
  long long v20 = 0u;
  long long v17 = 0u;
  long long v18 = 0u;
  long long v15 = 0u;
  long long v16 = 0u;
  long long v13 = 0u;
  long long v14 = 0u;
  long long v11 = 0u;
  long long v12 = 0u;
  *(_OWORD *)std::string __p = 0u;
  long long v10 = 0u;
  long long v7 = 0u;
  long long v8 = 0u;
  long long v5 = 0u;
  long long v6 = 0u;
  long long v4 = 0u;
  sub_1003C09B4((void (__cdecl ***)(std::istringstream *__hidden))&v4, a1, 8);
  memset(&v3, 0, sizeof(v3));
  sub_10055FB54((uint64_t)&v4);
  time_t v1 = mktime(&v3);
  if (SBYTE7(v10) < 0) {
    operator delete(__p[0]);
  }
  std::streambuf::~streambuf();
  std::istream::~istream();
  std::ios::~ios();
  return v1;
}

void sub_100560690(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  sub_1003C0B38((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1005606A8(os_log_t *a1, void *a2, long long *a3, int a4, uint64_t *a5)
{
  sub_100058DB0(buf, "otp=");
  sub_100058DB0(&v60, "imei=");
  sub_100058DB0(v61, "imsi=");
  sub_100058DB0(v62, "msisdn=");
  uint64_t v58 = 0;
  CFIndex v56 = (char *)operator new(0x60uLL);
  uint64_t v58 = v56 + 96;
  uint64_t v8 = 0;
  std::locale v57 = sub_1000D8A18((uint64_t)&v58, (long long *)buf, &v63, v56);
  do
  {
    if (SHIBYTE(v62[v8 + 2]) < 0) {
      operator delete((void *)v62[v8]);
    }
    v8 -= 3;
  }
  while (v8 != -12);
  long long v53 = 0;
  uint64_t v54 = 0;
  uint64_t v55 = 0;
  long long __dst = 0uLL;
  uint64_t v52 = 0;
  long long v48 = a5;
  if (*((char *)a3 + 23) < 0)
  {
    sub_10004FC84(&__dst, *(void **)a3, *((void *)a3 + 1));
  }
  else
  {
    long long __dst = *a3;
    uint64_t v52 = *((void *)a3 + 2);
  }
  uint64_t v9 = v56;
  if (v56 != v57)
  {
    memset(v50, 0, sizeof(v50));
    if (v56[23] >= 0) {
      size_t v10 = v56[23];
    }
    else {
      size_t v10 = *((void *)v56 + 1);
    }
    memset(buf, 0, sizeof(buf));
    sub_1000C140C((uint64_t)buf, v10 + 10);
    if ((buf[23] & 0x80u) == 0) {
      long long v11 = buf;
    }
    else {
      long long v11 = *(uint8_t **)buf;
    }
    if (v10)
    {
      if (v9[23] >= 0) {
        long long v12 = v9;
      }
      else {
        long long v12 = *(char **)v9;
      }
      memmove(v11, v12, v10);
    }
    strcpy((char *)&v11[v10], "(.*?)(&|$)");
    sub_1005653F8((std::locale *)v50);
  }
  long long v13 = *a1;
  if (os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I =======================================", buf, 2u);
    long long v13 = *a1;
  }
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    long long v14 = "GET";
    if (a4) {
      long long v14 = "POST";
    }
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = v14;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I ---->>>> %s ---->>>>", buf, 0xCu);
    long long v13 = *a1;
  }
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    p_dst = &__dst;
    if (v52 < 0) {
      p_dst = (long long *)__dst;
    }
    *(_DWORD *)long long buf = 136446210;
    *(void *)&uint8_t buf[4] = p_dst;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I %{public}s", buf, 0xCu);
  }
  long long v16 = v53;
  for (uint64_t i = v54; v16 != i; v16 += 6)
  {
    long long v18 = *a1;
    if (os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT))
    {
      long long v19 = v16;
      if (*((char *)v16 + 23) < 0) {
        long long v19 = (uint64_t *)*v16;
      }
      long long v20 = v16 + 3;
      if (*((char *)v16 + 47) < 0) {
        long long v20 = (void *)*v20;
      }
      *(_DWORD *)long long buf = 136446723;
      *(void *)&uint8_t buf[4] = v19;
      *(_WORD *)&unsigned char buf[12] = 2160;
      *(void *)&buf[14] = 1752392040;
      *(_WORD *)&unsigned char buf[22] = 2081;
      char v60 = v20;
      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#I      %{public}s %{private, mask.hash}s", buf, 0x20u);
    }
  }
  std::ios_base::fmtflags v21 = *a1;
  if (os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "#I ================HEADERS================", buf, 2u);
  }
  long long v22 = (void *)*a2;
  if ((void *)*a2 != a2 + 1)
  {
    do
    {
      long long v23 = v22 + 4;
      long long v24 = v22 + 7;
      uint64_t v25 = *((unsigned __int8 *)v22 + 55);
      int v26 = (char)v25;
      if ((v25 & 0x80u) != 0) {
        uint64_t v25 = v22[5];
      }
      if (v25 == 10)
      {
        long long v27 = (uint64_t *)*v23;
        if (v26 >= 0) {
          long long v32 = v22 + 4;
        }
        else {
          long long v32 = (uint64_t *)*v23;
        }
        uint64_t v33 = *v32;
        int v30 = *((unsigned __int16 *)v32 + 4);
        BOOL v31 = v33 == 0x6B6F6F432D746553;
      }
      else
      {
        if (v25 != 6) {
          goto LABEL_58;
        }
        long long v27 = (uint64_t *)*v23;
        if (v26 >= 0) {
          long long v28 = v22 + 4;
        }
        else {
          long long v28 = (void *)*v23;
        }
        int v29 = *(_DWORD *)v28;
        int v30 = *((unsigned __int16 *)v28 + 2);
        BOOL v31 = v29 == 1802465091;
      }
      if (!v31 || v30 != 25961)
      {
LABEL_58:
        os_log_t v35 = *a1;
        if (os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT))
        {
          if (v26 < 0) {
            long long v23 = (uint64_t *)*v23;
          }
          if (*((char *)v22 + 79) < 0) {
            long long v24 = (void *)*v24;
          }
          *(_DWORD *)long long buf = 136446466;
          *(void *)&uint8_t buf[4] = v23;
          *(_WORD *)&unsigned char buf[12] = 2082;
          *(void *)&buf[14] = v24;
          long long v36 = v35;
          long long v37 = "#I [%{public}s]: %{public}s";
          uint32_t v38 = 22;
LABEL_71:
          _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_DEFAULT, v37, buf, v38);
          goto LABEL_72;
        }
        goto LABEL_72;
      }
      os_log_t v39 = *a1;
      if (os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT))
      {
        if (v26 >= 0) {
          long long v40 = v22 + 4;
        }
        else {
          long long v40 = v27;
        }
        if (*((char *)v22 + 79) < 0) {
          long long v24 = (void *)*v24;
        }
        *(_DWORD *)long long buf = 136446723;
        *(void *)&uint8_t buf[4] = v40;
        *(_WORD *)&unsigned char buf[12] = 2160;
        *(void *)&buf[14] = 1752392040;
        *(_WORD *)&unsigned char buf[22] = 2081;
        char v60 = v24;
        long long v36 = v39;
        long long v37 = "#I [%{public}s]: %{private, mask.hash}s";
        uint32_t v38 = 32;
        goto LABEL_71;
      }
LABEL_72:
      long long v41 = (void *)v22[1];
      if (v41)
      {
        do
        {
          long long v42 = v41;
          long long v41 = (void *)*v41;
        }
        while (v41);
      }
      else
      {
        do
        {
          long long v42 = (void *)v22[2];
          BOOL v31 = *v42 == (void)v22;
          long long v22 = v42;
        }
        while (!v31);
      }
      long long v22 = v42;
    }
    while (v42 != a2 + 1);
  }
  long long v43 = *a1;
  if (os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_DEFAULT, "#I =======================================", buf, 2u);
  }
  long long v44 = v48;
  char v45 = *((unsigned char *)v48 + 23);
  if (v45 < 0)
  {
    if (!v48[1]) {
      goto LABEL_90;
    }
  }
  else if (!*((unsigned char *)v48 + 23))
  {
    goto LABEL_90;
  }
  long long v46 = *a1;
  if (os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT))
  {
    if (v45 < 0) {
      long long v44 = (uint64_t *)*v48;
    }
    *(_DWORD *)long long buf = 141558275;
    *(void *)&uint8_t buf[4] = 1752392040;
    *(_WORD *)&unsigned char buf[12] = 2081;
    *(void *)&buf[14] = v44;
    _os_log_impl((void *)&_mh_execute_header, v46, OS_LOG_TYPE_DEFAULT, "#I %{private, mask.hash}s", buf, 0x16u);
    long long v46 = *a1;
  }
  if (os_log_type_enabled(v46, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v46, OS_LOG_TYPE_DEFAULT, "#I =======================================", buf, 2u);
  }
LABEL_90:
  if (SHIBYTE(v52) < 0) {
    operator delete((void *)__dst);
  }
  *(void *)long long buf = &v53;
  sub_100155410((void ***)buf);
  *(void *)long long buf = &v56;
  sub_100047F64((void ***)buf);
}

void sub_10056121C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,void *__p,uint64_t a36,uint64_t a37,uint64_t a38,void *a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,std::locale a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  *(void *)(v65 - 224) = &a65;
  sub_100155410((void ***)(v65 - 224));
  *(void *)(v65 - 224) = v65 - 248;
  sub_100047F64((void ***)(v65 - 224));
  _Unwind_Resume(a1);
}

void sub_1005612C8(void *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,void *a27,uint64_t a28,int a29,__int16 a30,char a31,char a32,uint64_t a33,void *__p,uint64_t a35,int a36,__int16 a37,char a38,char a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,void *a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,...)
{
  va_start(va, a58);
  if (a2)
  {
    if (a45) {
      operator delete(a45);
    }
    sub_100155138((std::locale *)va);
    __cxa_begin_catch(a1);
    CFTypeRef v61 = *v58;
    if (os_log_type_enabled(*v58, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)(v59 - 224) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v61, OS_LOG_TYPE_ERROR, "Exceptions seen during extracting content", (uint8_t *)(v59 - 224), 2u);
    }
    __cxa_end_catch();
    JUMPOUT(0x100560CF0);
  }
  JUMPOUT(0x1005612C0);
}

void sub_1005612F0(uint64_t a1, int a2)
{
  if (a2)
  {
    sub_1001085D8(v2 - 224);
    JUMPOUT(0x100561300);
  }
  JUMPOUT(0x1005612C0);
}

void sub_100561310(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,void *a34,uint64_t a35,uint64_t a36,uint64_t a37,void *__p,uint64_t a39,int a40,__int16 a41,char a42,char a43)
{
  if (a2)
  {
    if (*(char *)(v43 - 201) < 0) {
      operator delete(*(void **)(v43 - 224));
    }
    if (a43 < 0) {
      operator delete(__p);
    }
    if (a23 < 0) {
      operator delete(a18);
    }
    if (SHIBYTE(a36) < 0) {
      operator delete(a34);
    }
    JUMPOUT(0x100561370);
  }
  JUMPOUT(0x1005612C0);
}

void sub_100561368(uint64_t a1, int a2)
{
  if (a2) {
    JUMPOUT(0x100561370);
  }
  JUMPOUT(0x1005612C0);
}

void sub_100561384(uint64_t a1, int a2)
{
  if (a2) {
    JUMPOUT(0x10056138CLL);
  }
  JUMPOUT(0x1005612C0);
}

void sub_1005613AC(uint64_t a1, int a2)
{
  if (a2)
  {
    if (*(char *)(v2 - 201) < 0) {
      operator delete(*(void **)(v2 - 224));
    }
    JUMPOUT(0x100561404);
  }
  JUMPOUT(0x1005612C0);
}

void sub_1005613C8(uint64_t a1, int a2)
{
  if (!a2) {
    JUMPOUT(0x1005612C0);
  }
  JUMPOUT(0x100561404);
}

void sub_1005613D4(uint64_t a1, int a2)
{
  if (a2)
  {
    uint64_t v3 = *(void *)(v2 - 224);
    if (v3)
    {
      *(void *)(v2 - 216) = v3;
      JUMPOUT(0x1005613E8);
    }
    JUMPOUT(0x1005613ECLL);
  }
  JUMPOUT(0x1005612C0);
}

void sub_100561454(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,void *__p,uint64_t a62,int a63)
{
  if (a66 < 0) {
    operator delete(__p);
  }
  JUMPOUT(0x100561220);
}

void sub_10056146C(os_log_t *a1, uint64_t a2, std::string::size_type a3)
{
  long long v44 = 0;
  v45[0] = 0;
  v45[1] = 0;
  (*(void (**)(void ***__return_ptr))(**(void **)a2 + 56))(&v44);
  long long v6 = *a1;
  if (os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(buf.__r_.__value_.__l.__data_) = 0;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I =======================================", (uint8_t *)&buf, 2u);
    long long v6 = *a1;
  }
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    int v7 = (*(uint64_t (**)(void))(**(void **)a2 + 24))();
    uint64_t v8 = (*(uint64_t (**)(void))(**(void **)a2 + 32))();
    if (v8)
    {
      sub_100058DB0(&v53, "[error: ");
      std::to_string(&v46, v8);
      if ((v46.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        uint64_t v9 = &v46;
      }
      else {
        uint64_t v9 = (std::string *)v46.__r_.__value_.__r.__words[0];
      }
      if ((v46.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string::size_type size = HIBYTE(v46.__r_.__value_.__r.__words[2]);
      }
      else {
        std::string::size_type size = v46.__r_.__value_.__l.__size_;
      }
      long long v11 = std::string::append(&v53, (const std::string::value_type *)v9, size);
      long long v12 = *(_OWORD *)&v11->__r_.__value_.__l.__data_;
      buf.__r_.__value_.__r.__words[2] = v11->__r_.__value_.__r.__words[2];
      *(_OWORD *)&buf.__r_.__value_.__l.__data_ = v12;
      v11->__r_.__value_.__l.__size_ = 0;
      v11->__r_.__value_.__r.__words[2] = 0;
      v11->__r_.__value_.__r.__words[0] = 0;
      long long v13 = std::string::append(&buf, " ]", 2uLL);
      long long v14 = *(_OWORD *)&v13->__r_.__value_.__l.__data_;
      int64_t v43 = v13->__r_.__value_.__r.__words[2];
      *(_OWORD *)std::string __p = v14;
      v13->__r_.__value_.__l.__size_ = 0;
      v13->__r_.__value_.__r.__words[2] = 0;
      v13->__r_.__value_.__r.__words[0] = 0;
      if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(buf.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v46.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v46.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v53.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v53.__r_.__value_.__l.__data_);
      }
    }
    else
    {
      sub_100058DB0(__p, "OK");
    }
    long long v15 = __p;
    if (v43 < 0) {
      long long v15 = (void **)__p[0];
    }
    *(_DWORD *)long long v49 = 67109378;
    int v50 = v7;
    __int16 v51 = 2082;
    uint64_t v52 = v15;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I <<<<---- RES: [response: %d] %{public}s <<<<----", v49, 0x12u);
    if (SHIBYTE(v43) < 0) {
      operator delete(__p[0]);
    }
    long long v6 = *a1;
  }
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    if (*(char *)(a3 + 23) >= 0) {
      std::string::size_type v16 = a3;
    }
    else {
      std::string::size_type v16 = *(void *)a3;
    }
    LODWORD(buf.__r_.__value_.__l.__data_) = 136446210;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = v16;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I %{public}s", (uint8_t *)&buf, 0xCu);
    long long v6 = *a1;
  }
  uint64_t v41 = a2;
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(buf.__r_.__value_.__l.__data_) = 0;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I ================HEADERS================", (uint8_t *)&buf, 2u);
  }
  long long v17 = v44;
  if (v44 != v45)
  {
    do
    {
      long long v18 = (uint64_t *)(v17 + 4);
      long long v19 = v17 + 7;
      long long v20 = (void *)*((unsigned __int8 *)v17 + 55);
      int v21 = (char)v20;
      if ((char)v20 < 0) {
        long long v20 = v17[5];
      }
      if (v20 == (void *)10)
      {
        long long v22 = (uint64_t *)*v18;
        if (v21 >= 0) {
          long long v27 = (uint64_t *)(v17 + 4);
        }
        else {
          long long v27 = (uint64_t *)*v18;
        }
        uint64_t v28 = *v27;
        int v25 = *((unsigned __int16 *)v27 + 4);
        BOOL v26 = v28 == 0x6B6F6F432D746553;
      }
      else
      {
        if (v20 != (void *)6) {
          goto LABEL_47;
        }
        long long v22 = (uint64_t *)*v18;
        if (v21 >= 0) {
          long long v23 = (uint64_t *)(v17 + 4);
        }
        else {
          long long v23 = (uint64_t *)*v18;
        }
        int v24 = *(_DWORD *)v23;
        int v25 = *((unsigned __int16 *)v23 + 2);
        BOOL v26 = v24 == 1802465091;
      }
      if (!v26 || v25 != 25961)
      {
LABEL_47:
        os_log_t v30 = *a1;
        if (os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT))
        {
          if (v21 < 0) {
            long long v18 = (uint64_t *)*v18;
          }
          if (*((char *)v17 + 79) < 0) {
            long long v19 = (void *)*v19;
          }
          LODWORD(buf.__r_.__value_.__l.__data_) = 136446466;
          *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v18;
          WORD2(buf.__r_.__value_.__r.__words[1]) = 2082;
          *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v19;
          BOOL v31 = v30;
          long long v32 = "#I [%{public}s]: %{public}s";
          uint32_t v33 = 22;
LABEL_60:
          _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, v32, (uint8_t *)&buf, v33);
          goto LABEL_61;
        }
        goto LABEL_61;
      }
      os_log_t v34 = *a1;
      if (os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT))
      {
        if (v21 >= 0) {
          std::string::size_type v35 = (std::string::size_type)(v17 + 4);
        }
        else {
          std::string::size_type v35 = (std::string::size_type)v22;
        }
        if (*((char *)v17 + 79) < 0) {
          long long v19 = (void *)*v19;
        }
        LODWORD(buf.__r_.__value_.__l.__data_) = 136446723;
        *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = v35;
        WORD2(buf.__r_.__value_.__r.__words[1]) = 2160;
        *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = 1752392040;
        HIWORD(buf.__r_.__value_.__r.__words[2]) = 2081;
        long long v48 = v19;
        BOOL v31 = v34;
        long long v32 = "#I [%{public}s]: %{private, mask.hash}s";
        uint32_t v33 = 32;
        goto LABEL_60;
      }
LABEL_61:
      long long v36 = v17[1];
      if (v36)
      {
        do
        {
          long long v37 = (void **)v36;
          long long v36 = (void *)*v36;
        }
        while (v36);
      }
      else
      {
        do
        {
          long long v37 = (void **)v17[2];
          BOOL v26 = *v37 == v17;
          long long v17 = v37;
        }
        while (!v26);
      }
      long long v17 = v37;
    }
    while (v37 != v45);
  }
  uint32_t v38 = *a1;
  if (os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(buf.__r_.__value_.__l.__data_) = 0;
    _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_DEFAULT, "#I =================BODY==================", (uint8_t *)&buf, 2u);
  }
  memset(&buf, 0, sizeof(buf));
  (*(void (**)(std::string *__return_ptr))(**(void **)v41 + 48))(&buf);
  os_log_t v39 = *a1;
  if (os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT))
  {
    p_std::string buf = &buf;
    if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      p_std::string buf = (std::string *)buf.__r_.__value_.__r.__words[0];
    }
    LODWORD(v53.__r_.__value_.__l.__data_) = 141558275;
    *(std::string::size_type *)((char *)v53.__r_.__value_.__r.__words + 4) = 1752392040;
    WORD2(v53.__r_.__value_.__r.__words[1]) = 2081;
    *(std::string::size_type *)((char *)&v53.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)p_buf;
    _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_DEFAULT, "#I \n%{private, mask.hash}s", (uint8_t *)&v53, 0x16u);
    os_log_t v39 = *a1;
  }
  if (os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v53.__r_.__value_.__l.__data_) = 0;
    _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_DEFAULT, "#I =======================================", (uint8_t *)&v53, 2u);
  }
  if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(buf.__r_.__value_.__l.__data_);
  }
  sub_10010C0E0((uint64_t)&v44, v45[0]);
}

void sub_100561A90(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, void *a20,uint64_t a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,void *__p,uint64_t a29,int a30,__int16 a31,char a32,char a33)
{
  if (a33 < 0) {
    operator delete(__p);
  }
  if (a27 < 0) {
    operator delete(a22);
  }
  if (*(char *)(v33 - 105) < 0) {
    operator delete(*(void **)(v33 - 128));
  }
  sub_10010C0E0((uint64_t)&a19, a20);
  _Unwind_Resume(a1);
}

const void **sub_100561B00@<X0>(uint64_t a1@<X8>)
{
  CFUUIDRef v2 = CFUUIDCreate(kCFAllocatorDefault);
  CFUUIDRef v6 = v2;
  if (v2) {
    uint64_t v3 = sub_100136254;
  }
  else {
    uint64_t v3 = 0;
  }
  if (v3)
  {
    CFStringRef v5 = CFUUIDCreateString(kCFAllocatorDefault, v2);
    long long v7 = 0uLL;
    uint64_t v8 = 0;
    ctu::cf::assign();
    *(_OWORD *)a1 = 0uLL;
    *(void *)(a1 + 16) = v8;
    sub_1000558F4((const void **)&v5);
  }
  else
  {
    *(void *)a1 = 0;
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
  }
  return sub_10012577C((const void **)&v6);
}

void sub_100561BAC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, const void *a10, const void *a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  sub_1000558F4(&a10);
  sub_10012577C(&a11);
  _Unwind_Resume(a1);
}

char *sub_100561BE0@<X0>(const void **a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  if (*((char *)a1 + 23) >= 0) {
    size_t v6 = *((unsigned __int8 *)a1 + 23);
  }
  else {
    size_t v6 = (size_t)a1[1];
  }
  memset(&v22, 0, sizeof(v22));
  long long v7 = &v22;
  sub_1000C140C((uint64_t)&v22, v6 + 12);
  if ((v22.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
    long long v7 = (std::string *)v22.__r_.__value_.__r.__words[0];
  }
  if (v6)
  {
    if (*((char *)a1 + 23) >= 0) {
      uint64_t v8 = a1;
    }
    else {
      uint64_t v8 = *a1;
    }
    memmove(v7, v8, v6);
  }
  strcpy((char *)v7 + v6, "_random_ext_");
  int v9 = *(char *)(a2 + 23);
  if (v9 >= 0) {
    size_t v10 = (const std::string::value_type *)a2;
  }
  else {
    size_t v10 = *(const std::string::value_type **)a2;
  }
  if (v9 >= 0) {
    std::string::size_type v11 = *(unsigned __int8 *)(a2 + 23);
  }
  else {
    std::string::size_type v11 = *(void *)(a2 + 8);
  }
  long long v12 = std::string::append(&v22, v10, v11);
  long long v13 = *(_OWORD *)&v12->__r_.__value_.__l.__data_;
  std::string::size_type v25 = v12->__r_.__value_.__r.__words[2];
  *(_OWORD *)std::string __p = v13;
  v12->__r_.__value_.__l.__size_ = 0;
  v12->__r_.__value_.__r.__words[2] = 0;
  v12->__r_.__value_.__r.__words[0] = 0;
  long long v14 = (void *)sub_100206390((uint64_t)&v23, (uint64_t)__p);
  if (SHIBYTE(v25) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v22.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v22.__r_.__value_.__l.__data_);
  }
  __p[0] = v14;
  __p[1] = v14;
  a3[1] = 0;
  a3[2] = 0;
  *a3 = 0;
  BOOL result = (char *)operator new(0x28uLL);
  unint64_t v16 = 0;
  *a3 = result;
  *(_OWORD *)(a3 + 1) = xmmword_1014BC960;
  *(_OWORD *)BOOL result = 0u;
  *((_OWORD *)result + 1) = 0u;
  *(void *)(result + 29) = 0;
  do
  {
    if (*((unsigned __int8 *)__p + v16) >= 0xA0u) {
      char v17 = 87;
    }
    else {
      char v17 = 48;
    }
    *BOOL result = v17 + (*((unsigned char *)__p + v16) >> 4);
    unsigned int v18 = *((unsigned char *)__p + v16) & 0xF;
    if (v18 >= 0xA) {
      char v19 = 87;
    }
    else {
      char v19 = 48;
    }
    char v20 = v19 + v18;
    int v21 = result + 2;
    result[1] = v20;
    if (v16 <= 9 && ((1 << v16) & 0x2A8) != 0)
    {
      int v21 = result + 3;
      result[2] = 45;
    }
    ++v16;
    BOOL result = v21;
  }
  while (v16 != 16);
  return result;
}

void sub_100561DE0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100561E04(const void **a1@<X0>, const void **a2@<X1>, void *a3@<X8>)
{
  size_t v6 = *((unsigned __int8 *)a2 + 23);
  size_t v7 = (size_t)a2[1];
  __p[1] = 0;
  uint64_t v12 = 0;
  if ((v6 & 0x80u) == 0) {
    size_t v8 = v6;
  }
  else {
    size_t v8 = v7;
  }
  __p[0] = 0;
  int v9 = __p;
  sub_1000C140C((uint64_t)__p, v8 + 16);
  if (v12 < 0) {
    int v9 = (void **)__p[0];
  }
  if (v8)
  {
    if (*((char *)a2 + 23) >= 0) {
      size_t v10 = a2;
    }
    else {
      size_t v10 = *a2;
    }
    memmove(v9, v10, v8);
  }
  strcpy((char *)v9 + v8, "__contribution_y");
  sub_100561BE0(a1, (uint64_t)__p, a3);
  if (SHIBYTE(v12) < 0) {
    operator delete(__p[0]);
  }
}

void sub_100561EDC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100561EF8(const void **a1@<X0>, const void **a2@<X1>, void *a3@<X8>)
{
  size_t v6 = *((unsigned __int8 *)a2 + 23);
  size_t v7 = (size_t)a2[1];
  __p[1] = 0;
  uint64_t v12 = 0;
  if ((v6 & 0x80u) == 0) {
    size_t v8 = v6;
  }
  else {
    size_t v8 = v7;
  }
  __p[0] = 0;
  int v9 = __p;
  sub_1000C140C((uint64_t)__p, v8 + 16);
  if (v12 < 0) {
    int v9 = (void **)__p[0];
  }
  if (v8)
  {
    if (*((char *)a2 + 23) >= 0) {
      size_t v10 = a2;
    }
    else {
      size_t v10 = *a2;
    }
    memmove(v9, v10, v8);
  }
  strcpy((char *)v9 + v8, "__conversation_y");
  sub_100561BE0(a1, (uint64_t)__p, a3);
  if (SHIBYTE(v12) < 0) {
    operator delete(__p[0]);
  }
}

void sub_100561FD0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100561FEC(uint64_t *a1@<X0>, void *a2@<X8>)
{
  if (*((char *)a1 + 23) >= 0) {
    uint64_t v3 = a1;
  }
  else {
    uint64_t v3 = (uint64_t *)*a1;
  }
  id v6 = +[NSString stringWithUTF8String:v3];
  long long v4 = +[NSCharacterSet URLHostAllowedCharacterSet];
  CFStringRef v5 = [v6 stringByAddingPercentEncodingWithAllowedCharacters:v4];

  id v7 = v5;
  sub_100058DB0(a2, (char *)[v7 UTF8String]);
}

void sub_1005620A8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1005620C8(uint64_t *a1@<X0>, void *a2@<X8>)
{
  if (*((char *)a1 + 23) >= 0) {
    uint64_t v3 = a1;
  }
  else {
    uint64_t v3 = (uint64_t *)*a1;
  }
  id v5 = +[NSString stringWithUTF8String:v3];
  long long v4 = [v5 stringByRemovingPercentEncoding];

  id v6 = v4;
  sub_100058DB0(a2, (char *)[v6 UTF8String]);
}

void sub_10056215C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_100562170(uint64_t *a1@<X0>, void *a2@<X8>)
{
  if (*((char *)a1 + 23) >= 0) {
    uint64_t v3 = a1;
  }
  else {
    uint64_t v3 = (uint64_t *)*a1;
  }
  id v7 = +[NSString stringWithUTF8String:v3];
  long long v4 = +[NSCharacterSet URLQueryAllowedCharacterSet];
  id v5 = [v4 mutableCopy];

  [v5 removeCharactersInString:@"+"];
  id v6 = [v7 stringByAddingPercentEncodingWithAllowedCharacters:v5];

  id v8 = v6;
  sub_100058DB0(a2, (char *)[v8 UTF8String]);
}

void sub_100562248(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_100562274(Registry **a1@<X0>, uint64_t a2@<X8>)
{
  memset(v23, 0, sizeof(v23));
  ServiceMap = (std::mutex *)Registry::getServiceMap(*a1);
  long long v4 = ServiceMap;
  if ((v5 & 0x8000000000000000) != 0)
  {
    id v6 = (unsigned __int8 *)(v5 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v7 = 5381;
    do
    {
      std::string::size_type v5 = v7;
      unsigned int v8 = *v6++;
      uint64_t v7 = (33 * v7) ^ v8;
    }
    while (v8);
  }
  std::mutex::lock(ServiceMap);
  __p.__r_.__value_.__r.__words[0] = v5;
  int v9 = sub_10004D37C(&v4[1].__m_.__sig, (unint64_t *)&__p);
  if (v9)
  {
    uint64_t v11 = v9[3];
    size_t v10 = (std::__shared_weak_count *)v9[4];
    if (v10)
    {
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v4);
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v10);
      char v12 = 0;
      if (!v11) {
        goto LABEL_13;
      }
      goto LABEL_10;
    }
  }
  else
  {
    uint64_t v11 = 0;
  }
  std::mutex::unlock(v4);
  size_t v10 = 0;
  char v12 = 1;
  if (!v11) {
    goto LABEL_13;
  }
LABEL_10:
  (*(void (**)(std::string *__return_ptr, uint64_t))(*(void *)v11 + 16))(&__p, v11);
  sub_100179CB0((uint64_t)v23, (__n128 *)&__p);
  if (v22 && SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
LABEL_13:
  if ((v12 & 1) == 0) {
    sub_10004D2C8(v10);
  }
  if (!v23[24])
  {
    WirelessUserDirectory = (char *)_GetWirelessUserDirectory();
    sub_100058DB0(&__p, WirelessUserDirectory);
    sub_100058DB0(v19, "/Library");
    if ((v20 & 0x80u) == 0) {
      long long v14 = v19;
    }
    else {
      long long v14 = (void **)v19[0];
    }
    if ((v20 & 0x80u) == 0) {
      std::string::size_type v15 = v20;
    }
    else {
      std::string::size_type v15 = (std::string::size_type)v19[1];
    }
    unint64_t v16 = std::string::append(&__p, (const std::string::value_type *)v14, v15);
    std::string::size_type v17 = v16->__r_.__value_.__r.__words[0];
    v24[0] = v16->__r_.__value_.__l.__size_;
    *(void *)((char *)v24 + 7) = *(std::string::size_type *)((char *)&v16->__r_.__value_.__r.__words[1] + 7);
    char v18 = HIBYTE(v16->__r_.__value_.__r.__words[2]);
    v16->__r_.__value_.__l.__size_ = 0;
    v16->__r_.__value_.__r.__words[2] = 0;
    v16->__r_.__value_.__r.__words[0] = 0;
    if (v23[24])
    {
      if ((v23[23] & 0x80000000) != 0) {
        operator delete(*(void **)v23);
      }
      *(void *)char v23 = v17;
      *(void *)&v23[8] = v24[0];
      *(void *)&v23[15] = *(void *)((char *)v24 + 7);
      v23[23] = v18;
    }
    else
    {
      *(void *)char v23 = v17;
      *(void *)&v23[8] = v24[0];
      *(void *)&v23[15] = *(void *)((char *)v24 + 7);
      v23[23] = v18;
      v23[24] = 1;
    }
    if ((char)v20 < 0) {
      operator delete(v19[0]);
    }
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
  }
  std::string::append((std::string *)v23, "/RoyalBlue", 0xAuLL);
  if ((v23[23] & 0x80000000) != 0)
  {
    sub_10004FC84((unsigned char *)a2, *(void **)v23, *(unint64_t *)&v23[8]);
    if (v23[24])
    {
      if ((v23[23] & 0x80000000) != 0) {
        operator delete(*(void **)v23);
      }
    }
  }
  else
  {
    *(_OWORD *)a2 = *(_OWORD *)v23;
    *(void *)(a2 + 16) = *(void *)&v23[16];
  }
}

void sub_100562504(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,char a29)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  if (a21 < 0) {
    operator delete(a16);
  }
  if (a29)
  {
    if (a28 < 0) {
      operator delete(a23);
    }
  }
  _Unwind_Resume(exception_object);
}

void sub_100562588()
{
  memset(v0, 0, sizeof(v0));
  sub_10056D028((std::locale *)v0, "geo:([+-]*\\d{1,2}\\.*\\d{1,15}),([+-]*\\d{1,3}\\.*\\d{1,15});.*rcs-l=(.*)", 0);
}

void sub_10056263C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18)
{
  if (__p)
  {
    a18 = (uint64_t)__p;
    operator delete(__p);
  }
  sub_100155138((std::locale *)&a9);
  _Unwind_Resume(a1);
}

void sub_100562660()
{
  memset(v0, 0, sizeof(v0));
  sub_10056D028((std::locale *)v0, "Your Messenger verification code is G-\\d+", 0);
}

void sub_100562714(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18)
{
  if (__p)
  {
    a18 = (uint64_t)__p;
    operator delete(__p);
  }
  sub_100155138((std::locale *)&a9);
  _Unwind_Resume(a1);
}

uint64_t sub_100562738(char **a1, char *a2)
{
  int v2 = *((char *)a1 + 23);
  int v3 = a2[23];
  if (v3 >= 0) {
    long long v4 = a2;
  }
  else {
    long long v4 = *(char **)a2;
  }
  if (v3 >= 0) {
    int64_t v5 = a2[23];
  }
  else {
    int64_t v5 = *((void *)a2 + 1);
  }
  if (v2 >= 0) {
    id v6 = (char *)a1;
  }
  else {
    id v6 = *a1;
  }
  if (v2 >= 0) {
    unint64_t v7 = *((unsigned __int8 *)a1 + 23);
  }
  else {
    unint64_t v7 = (unint64_t)a1[1];
  }
  if (v5)
  {
    if ((uint64_t)v7 >= v5)
    {
      unsigned __int8 v20 = &v6[v7];
      int v21 = *v4;
      int64_t v22 = v7;
      char v23 = v6;
      do
      {
        int64_t v24 = v22 - v5;
        if (v24 == -1) {
          break;
        }
        std::string::size_type v25 = (char *)memchr(v23, v21, v24 + 1);
        if (!v25) {
          break;
        }
        BOOL v26 = v25;
        if (!memcmp(v25, v4, v5))
        {
          uint64_t v8 = 0;
          if (v26 != v20)
          {
            uint64_t v10 = v26 - v6;
            if (v26 - v6 != -1) {
              goto LABEL_18;
            }
          }
          return v8;
        }
        char v23 = v26 + 1;
        int64_t v22 = v20 - (v26 + 1);
      }
      while (v22 >= v5);
    }
    return 0;
  }
  else
  {
    uint64_t v10 = 0;
LABEL_18:
    LODWORD(v8) = 0;
    uint64_t v11 = &v6[v7];
    while (1)
    {
      uint64_t v8 = (v8 + 1);
      uint64_t v12 = v10 + v5;
      BOOL v13 = v7 >= v10 + v5;
      if (v7 < v10 + v5) {
        uint64_t v10 = -1;
      }
      else {
        v10 += v5;
      }
      if (v5 && v13) {
        break;
      }
LABEL_34:
      if (v10 == -1) {
        return v8;
      }
    }
    long long v14 = &v6[v12];
    int64_t v15 = v7 - v12;
    if ((uint64_t)(v7 - v12) >= v5)
    {
      int v16 = *v4;
      do
      {
        int64_t v17 = v15 - v5;
        if (v17 == -1) {
          break;
        }
        char v18 = (char *)memchr(v14, v16, v17 + 1);
        if (!v18) {
          break;
        }
        char v19 = v18;
        if (!memcmp(v18, v4, v5))
        {
          if (v19 == v11) {
            return v8;
          }
          uint64_t v10 = v19 - v6;
          goto LABEL_34;
        }
        long long v14 = v19 + 1;
        int64_t v15 = v11 - (v19 + 1);
      }
      while (v15 >= v5);
    }
  }
  return v8;
}

id sub_1005628AC(int *a1)
{
  if (*((unsigned char *)a1 + 4))
  {
    int v2 = +[NSString stringWithUTF8String:Lazuli::asString()];
    id v3 = objc_alloc((Class)NSError);
    if (!*((unsigned char *)a1 + 4)) {
      sub_10016C840();
    }
    long long v4 = v3;
    uint64_t v5 = *a1;
    NSErrorUserInfoKey v9 = NSLocalizedDescriptionKey;
    uint64_t v10 = v2;
    id v6 = +[NSDictionary dictionaryWithObjects:&v10 forKeys:&v9 count:1];
    id v7 = [v4 initWithDomain:NSPOSIXErrorDomain code:v5 userInfo:v6];
  }
  else
  {
    id v7 = 0;
  }

  return v7;
}

void sub_1005629CC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1005629F0(uint64_t *a1)
{
  uint64_t v1 = *a1;
  sub_100058DB0(__p, "com.apple.datausage.telephony.rcs");
  (*(void (**)(uint64_t, void **))(*(void *)v1 + 184))(v1, __p);
  if (v3 < 0) {
    operator delete(__p[0]);
  }
}

void sub_100562A64(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

CFStringRef sub_100562A80()
{
  return @"RCS";
}

const void **sub_100562A8C@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  (*(void (**)(const void **__return_ptr))(**(void **)a1 + 96))(&v4);
  sub_10004EFE4(a2, &v4);
  return sub_1000577C4(&v4);
}

void sub_100562B08(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000577C4((const void **)va);
  _Unwind_Resume(a1);
}

BOOL sub_100562B1C(uint64_t a1)
{
  CFDictionaryRef theDict = 0;
  sub_100562A8C(a1, &theDict);
  if (theDict) {
    uint64_t v1 = sub_100080778;
  }
  else {
    uint64_t v1 = 0;
  }
  if (!v1) {
    goto LABEL_8;
  }
  CFArrayRef Value = CFDictionaryGetValue(theDict, @"CarrierBasedService");
  BOOL v3 = (BOOL)Value;
  char v8 = 0;
  if (Value)
  {
    CFTypeID v4 = CFGetTypeID(Value);
    if (v4 == CFBooleanGetTypeID())
    {
      ctu::cf::assign((ctu::cf *)&v8, (BOOL *)v3, v5);
      BOOL v3 = v8 != 0;
      goto LABEL_9;
    }
LABEL_8:
    BOOL v3 = 0;
  }
LABEL_9:
  sub_100057D78((const void **)&theDict);
  return v3;
}

void sub_100562BC8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9)
{
}

BOOL sub_100562BDC(uint64_t a1)
{
  CFDictionaryRef theDict = 0;
  sub_100562A8C(a1, &theDict);
  if (theDict) {
    uint64_t v1 = sub_100080778;
  }
  else {
    uint64_t v1 = 0;
  }
  if (!v1) {
    goto LABEL_8;
  }
  CFArrayRef Value = CFDictionaryGetValue(theDict, @"UseBase64Encoding");
  BOOL v3 = (BOOL)Value;
  char v8 = 0;
  if (Value)
  {
    CFTypeID v4 = CFGetTypeID(Value);
    if (v4 == CFBooleanGetTypeID())
    {
      ctu::cf::assign((ctu::cf *)&v8, (BOOL *)v3, v5);
      BOOL v3 = v8 != 0;
      goto LABEL_9;
    }
LABEL_8:
    BOOL v3 = 0;
  }
LABEL_9:
  sub_100057D78((const void **)&theDict);
  return v3;
}

void sub_100562C88(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9)
{
}

BOOL sub_100562C9C(uint64_t a1)
{
  CFDictionaryRef theDict = 0;
  sub_100562A8C(a1, &theDict);
  if (theDict) {
    uint64_t v1 = sub_100080778;
  }
  else {
    uint64_t v1 = 0;
  }
  if (!v1) {
    goto LABEL_8;
  }
  CFArrayRef Value = (BOOL *)CFDictionaryGetValue(theDict, @"TriggerDiscoveryOnText");
  BOOL v3 = Value;
  BOOL v4 = 1;
  char v9 = 1;
  if (Value)
  {
    CFTypeID v5 = CFGetTypeID(Value);
    if (v5 == CFBooleanGetTypeID())
    {
      ctu::cf::assign((ctu::cf *)&v9, v3, v6);
      BOOL v4 = v9 != 0;
      goto LABEL_9;
    }
LABEL_8:
    BOOL v4 = 1;
  }
LABEL_9:
  sub_100057D78((const void **)&theDict);
  return v4;
}

void sub_100562D4C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9)
{
}

uint64_t sub_100562D60(uint64_t a1)
{
  CFDictionaryRef theDict = 0;
  sub_100562A8C(a1, &theDict);
  if (theDict) {
    uint64_t v1 = sub_100080778;
  }
  else {
    uint64_t v1 = 0;
  }
  if (v1)
  {
    CFArrayRef Value = (BOOL *)CFDictionaryGetValue(theDict, @"ShowRCSSwitch");
    BOOL v3 = Value;
    char v9 = 0;
    if (Value && (CFTypeID v4 = CFGetTypeID(Value), v4 == CFBooleanGetTypeID()) && (ctu::cf::assign((ctu::cf *)&v9, v3, v5), v9)) {
      uint64_t v6 = 1;
    }
    else {
      uint64_t v6 = (uint64_t)&_mh_execute_header;
    }
  }
  else
  {
    uint64_t v6 = 0x200000000;
  }
  sub_100057D78((const void **)&theDict);
  return v6;
}

void sub_100562E14(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9)
{
}

BOOL sub_100562E28(uint64_t a1)
{
  CFDictionaryRef theDict = 0;
  sub_100562A8C(a1, &theDict);
  if (theDict) {
    uint64_t v1 = sub_100080778;
  }
  else {
    uint64_t v1 = 0;
  }
  if (!v1) {
    goto LABEL_8;
  }
  CFArrayRef Value = CFDictionaryGetValue(theDict, @"EnableRCSByDefault");
  BOOL v3 = (BOOL)Value;
  char v8 = 0;
  if (Value)
  {
    CFTypeID v4 = CFGetTypeID(Value);
    if (v4 == CFBooleanGetTypeID())
    {
      ctu::cf::assign((ctu::cf *)&v8, (BOOL *)v3, v5);
      BOOL v3 = v8 != 0;
      goto LABEL_9;
    }
LABEL_8:
    BOOL v3 = 0;
  }
LABEL_9:
  sub_100057D78((const void **)&theDict);
  return v3;
}

void sub_100562ED4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9)
{
}

uint64_t sub_100562EE8(uint64_t a1)
{
  CFDictionaryRef theDict = 0;
  sub_100562A8C(a1, &theDict);
  if (theDict) {
    uint64_t v1 = sub_100080778;
  }
  else {
    uint64_t v1 = 0;
  }
  if (v1)
  {
    CFArrayRef Value = (BOOL *)CFDictionaryGetValue(theDict, @"ShowBusinessMessagingSwitch");
    BOOL v3 = Value;
    char v9 = 0;
    if (Value && (CFTypeID v4 = CFGetTypeID(Value), v4 == CFBooleanGetTypeID()) && (ctu::cf::assign((ctu::cf *)&v9, v3, v5), v9)) {
      uint64_t v6 = 1;
    }
    else {
      uint64_t v6 = (uint64_t)&_mh_execute_header;
    }
  }
  else
  {
    uint64_t v6 = 0x200000000;
  }
  sub_100057D78((const void **)&theDict);
  return v6;
}

void sub_100562F9C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9)
{
}

BOOL sub_100562FB0(uint64_t a1)
{
  CFDictionaryRef theDict = 0;
  sub_100562A8C(a1, &theDict);
  if (theDict) {
    uint64_t v1 = sub_100080778;
  }
  else {
    uint64_t v1 = 0;
  }
  if (!v1) {
    goto LABEL_8;
  }
  CFArrayRef Value = CFDictionaryGetValue(theDict, @"EnableBusinessMessagingByDefault");
  BOOL v3 = (BOOL)Value;
  char v8 = 0;
  if (Value)
  {
    CFTypeID v4 = CFGetTypeID(Value);
    if (v4 == CFBooleanGetTypeID())
    {
      ctu::cf::assign((ctu::cf *)&v8, (BOOL *)v3, v5);
      BOOL v3 = v8 != 0;
      goto LABEL_9;
    }
LABEL_8:
    BOOL v3 = 0;
  }
LABEL_9:
  sub_100057D78((const void **)&theDict);
  return v3;
}

void sub_10056305C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9)
{
}

unint64_t sub_100563070(uint64_t a1)
{
  CFDictionaryRef theDict = 0;
  sub_100562A8C(a1, &theDict);
  if (theDict) {
    uint64_t v1 = sub_100080778;
  }
  else {
    uint64_t v1 = 0;
  }
  if (!v1) {
    goto LABEL_8;
  }
  CFArrayRef Value = (unint64_t *)CFDictionaryGetValue(theDict, @"BsfPort");
  BOOL v3 = Value;
  if (!Value)
  {
    unint64_t v6 = 0;
    goto LABEL_10;
  }
  CFTypeID v4 = CFGetTypeID(Value);
  if (v4 != CFNumberGetTypeID())
  {
LABEL_8:
    unint64_t v6 = 0;
LABEL_10:
    uint64_t v7 = 0;
    goto LABEL_11;
  }
  uint64_t v10 = 0;
  ctu::cf::assign((ctu::cf *)&v10, v3, v5);
  unint64_t v6 = v10 & 0xFFFFFFFFFFFFFF00;
  uint64_t v7 = v10;
LABEL_11:
  sub_100057D78((const void **)&theDict);
  return v7 | v6;
}

void sub_10056313C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9)
{
}

BOOL sub_100563154(uint64_t a1)
{
  CFDictionaryRef theDict = 0;
  sub_100562A8C(a1, &theDict);
  if (theDict) {
    uint64_t v1 = sub_100080778;
  }
  else {
    uint64_t v1 = 0;
  }
  if (!v1) {
    goto LABEL_8;
  }
  CFArrayRef Value = CFDictionaryGetValue(theDict, @"BsfUseSecureTransport");
  BOOL v3 = (BOOL)Value;
  char v8 = 0;
  if (Value)
  {
    CFTypeID v4 = CFGetTypeID(Value);
    if (v4 == CFBooleanGetTypeID())
    {
      ctu::cf::assign((ctu::cf *)&v8, (BOOL *)v3, v5);
      BOOL v3 = v8 != 0;
      goto LABEL_9;
    }
LABEL_8:
    BOOL v3 = 0;
  }
LABEL_9:
  sub_100057D78((const void **)&theDict);
  return v3;
}

void sub_100563200(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9)
{
}

const void **sub_100563214@<X0>(uint64_t a1@<X0>, NSObject **a2@<X2>, void *a3@<X8>)
{
  CFDictionaryRef theDict = 0;
  sub_100562A8C(a1, &theDict);
  if (theDict) {
    CFBooleanRef v5 = sub_100080778;
  }
  else {
    CFBooleanRef v5 = 0;
  }
  if (!v5
    || (Value = (const __CFDictionary *)CFDictionaryGetValue(theDict, @"ProvisioningData"), (CFDictionaryRef v7 = Value) == 0)
    || (CFTypeID v8 = CFGetTypeID(Value), v8 != CFDictionaryGetTypeID())
    || (CFArrayRef v9 = (const __CFArray *)CFDictionaryGetValue(v7, @"TrustAnchorCertificates"), (v10 = v9) == 0)
    || (CFTypeID v11 = CFGetTypeID(v9), v11 != CFArrayGetTypeID())
    || !CFArrayGetCount(v10))
  {
    *a3 = 0;
    return sub_100057D78((const void **)&theDict);
  }
  uint64_t Count = CFArrayGetCount(v10);
  *(void *)long long v27 = 0;
  CFMutableArrayRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, Count, &kCFTypeArrayCallBacks);
  if (Mutable)
  {
    long long v14 = *(__CFArray **)v27;
    *(void *)long long v27 = Mutable;
    *(void *)std::string buf = v14;
    sub_1000440D4((const void **)buf);
  }
  if (Count < 1)
  {
LABEL_22:
    sub_100044D6C(a3, (CFTypeRef *)v27);
    goto LABEL_32;
  }
  CFIndex v15 = 0;
  while (1)
  {
    CFTypeRef ValueAtIndex = CFArrayGetValueAtIndex(v10, v15);
    int64_t v17 = ValueAtIndex;
    if (!ValueAtIndex || (CFTypeID v18 = CFGetTypeID(ValueAtIndex), v18 != CFStringGetTypeID()))
    {
      char v23 = *a2;
      if (!os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
      {
LABEL_28:
        *a3 = 0;
        goto LABEL_32;
      }
      *(_DWORD *)std::string buf = 134217984;
      *(void *)&uint8_t buf[4] = v15;
      int64_t v24 = "Invalid type for anchor certificate at index %ld (expected string)";
LABEL_34:
      _os_log_error_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_ERROR, v24, buf, 0xCu);
      goto LABEL_28;
    }
    CFDataRef v19 = (const __CFData *)[objc_alloc((Class)NSData) initWithBase64EncodedString:v17 options:0];
    if (!v19)
    {
      char v23 = *a2;
      if (!os_log_type_enabled(v23, OS_LOG_TYPE_ERROR)) {
        goto LABEL_28;
      }
      *(_DWORD *)std::string buf = 134217984;
      *(void *)&uint8_t buf[4] = v15;
      int64_t v24 = "Failed to base64-decode anchor certificate at index %ld";
      goto LABEL_34;
    }
    SecCertificateRef v26 = 0;
    SecCertificateRef v20 = SecCertificateCreateWithData(kCFAllocatorDefault, v19);
    SecCertificateRef v26 = v20;
    if (!(v20 ? sub_100563580 : 0)) {
      break;
    }
    sub_10057011C(*(__CFArray **)v27, v20);
    sub_100120040((const void **)&v26);

    if (Count == ++v15) {
      goto LABEL_22;
    }
  }
  std::string::size_type v25 = *a2;
  if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)std::string buf = 134217984;
    *(void *)&uint8_t buf[4] = v15;
    _os_log_error_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_ERROR, "Failed to DER-decode anchor certificate at index %ld", buf, 0xCu);
  }
  *a3 = 0;
  sub_100120040((const void **)&v26);

LABEL_32:
  sub_1000440D4((const void **)v27);
  return sub_100057D78((const void **)&theDict);
}

void sub_100563528(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  sub_100057D78((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100563580(uint64_t a1)
{
  return *(void *)a1;
}

uint64_t sub_100563588@<X0>(void *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  *(_OWORD *)(a3 + 448) = 0u;
  *(_OWORD *)(a3 + 464) = 0u;
  *(_OWORD *)(a3 + 416) = 0u;
  *(_OWORD *)(a3 + 432) = 0u;
  *(_OWORD *)(a3 + 384) = 0u;
  *(_OWORD *)(a3 + 400) = 0u;
  *(_OWORD *)(a3 + 352) = 0u;
  *(_OWORD *)(a3 + 368) = 0u;
  *(_OWORD *)(a3 + 320) = 0u;
  *(_OWORD *)(a3 + 336) = 0u;
  *(_OWORD *)(a3 + 288) = 0u;
  *(_OWORD *)(a3 + 304) = 0u;
  *(_OWORD *)(a3 + 256) = 0u;
  *(_OWORD *)(a3 + 272) = 0u;
  *(_OWORD *)(a3 + 224) = 0u;
  *(_OWORD *)(a3 + 240) = 0u;
  *(_OWORD *)(a3 + 192) = 0u;
  *(_OWORD *)(a3 + 208) = 0u;
  *(_OWORD *)(a3 + 160) = 0u;
  *(_OWORD *)(a3 + 176) = 0u;
  *(_OWORD *)(a3 + 128) = 0u;
  *(_OWORD *)(a3 + 144) = 0u;
  *(_OWORD *)(a3 + 96) = 0u;
  *(_OWORD *)(a3 + 112) = 0u;
  *(_OWORD *)(a3 + 64) = 0u;
  *(_OWORD *)(a3 + 80) = 0u;
  *(_OWORD *)(a3 + 32) = 0u;
  *(_OWORD *)(a3 + 48) = 0u;
  *(_OWORD *)a3 = 0u;
  *(_OWORD *)(a3 + 16) = 0u;
  *(unsigned char *)(a3 + 452) = (*(uint64_t (**)(void))(*(void *)*a1 + 40))(*a1);
  int v6 = (*(uint64_t (**)(void, uint64_t))(*(void *)*a1 + 48))(*a1, a2);
  *(unsigned char *)(a3 + 453) = v6;
  __int16 v7 = (*(uint64_t (**)(void, uint64_t))(*(void *)*a1 + 16))(*a1, a2);
  int v8 = 2 * (v7 == 0);
  if ((v7 & 0xFF00) == 0) {
    int v8 = v6 - 1;
  }
  *(_DWORD *)(a3 + 360) = -1;
  *(_DWORD *)(a3 + 364) = v8;
  *(_DWORD *)(a3 + 368) = -1;
  *(unsigned char *)(a3 + 372) = 1;
  __int16 v9 = (*(uint64_t (**)(void, uint64_t))(*(void *)*a1 + 56))(*a1, a2);
  int v10 = (*(uint64_t (**)(void, uint64_t))(*(void *)*a1 + 80))(*a1, a2);
  int v11 = (*(uint64_t (**)(void, uint64_t))(*(void *)*a1 + 72))(*a1, a2);
  uint64_t result = (*(uint64_t (**)(void, uint64_t))(*(void *)*a1 + 80))(*a1, a2);
  uint64_t v13 = 0xFFFFFFFFLL;
  if (v10) {
    uint64_t v13 = 1;
  }
  if ((v9 & 0xFF00) != 0) {
    uint64_t v13 = v9;
  }
  uint64_t v14 = 0x10000000000;
  if (!result) {
    uint64_t v14 = 0;
  }
  CFIndex v15 = &_mh_execute_header;
  if (!v11) {
    CFIndex v15 = 0;
  }
  *(void *)(a3 + 440) = (unint64_t)v15 | v14 | v13;
  *(unsigned char *)(a3 + 448) = 1;
  return result;
}

void sub_1005637BC(_Unwind_Exception *a1)
{
  sub_10044D2E4(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1005637DC(void *a1, uint64_t a2)
{
  int v4 = (*(uint64_t (**)(void))(*(void *)*a1 + 40))(*a1);
  int v5 = (*(uint64_t (**)(void, uint64_t))(*(void *)*a1 + 48))(*a1, a2);
  __int16 v6 = (*(uint64_t (**)(void, uint64_t))(*(void *)*a1 + 16))(*a1, a2);
  BOOL v7 = v6 != 0;
  if ((v6 & 0xFF00) == 0) {
    BOOL v7 = v5;
  }
  return v4 & v7;
}

BOOL sub_1005638A4(id *a1)
{
  if (*a1) {
    uint64_t v1 = sub_10039195C;
  }
  else {
    uint64_t v1 = 0;
  }
  if (!v1) {
    return 0;
  }
  id v2 = *a1;
  BOOL v3 = [v2 domain];
  if ([v3 isEqualToString:NSURLErrorDomain]) {
    BOOL v4 = [v2 code] == (id)-1202;
  }
  else {
    BOOL v4 = 0;
  }

  return v4;
}

void sub_10056393C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_100563958@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v27 = 0;
  long long v25 = 0u;
  long long v26 = 0u;
  uint64_t v4 = a1 / 86400;
  long long v23 = 0u;
  long long v24 = 0u;
  long long v21 = 0u;
  long long v22 = 0u;
  long long v19 = 0u;
  long long v20 = 0u;
  long long v17 = 0u;
  long long v18 = 0u;
  *(_OWORD *)CFIndex v15 = 0u;
  long long v16 = 0u;
  memset(v14, 0, sizeof(v14));
  long long v13 = 0u;
  sub_10004BD84((uint64_t)&v13);
  if (v4)
  {
    *(void *)((char *)&v14[1] + *(void *)(*(void *)&v14[0] - 24) + 8) = 2;
    LOBYTE(__p[0]) = 48;
    sub_1004DC904(v14, (char *)__p);
    int v5 = (void *)std::ostream::operator<<();
    sub_10004B96C(v5, (uint64_t)"d ", 2);
  }
  if (a1 / 3600 % 24)
  {
    *(void *)((char *)&v14[1] + *(void *)(*(void *)&v14[0] - 24) + 8) = 2;
    LOBYTE(__p[0]) = 48;
    sub_1004DC904(v14, (char *)__p);
    __int16 v6 = (void *)std::ostream::operator<<();
    sub_10004B96C(v6, (uint64_t)"h ", 2);
  }
  if (a1 / 60 % 60)
  {
    *(void *)((char *)&v14[1] + *(void *)(*(void *)&v14[0] - 24) + 8) = 2;
    LOBYTE(__p[0]) = 48;
    sub_1004DC904(v14, (char *)__p);
    BOOL v7 = (void *)std::ostream::operator<<();
    sub_10004B96C(v7, (uint64_t)"m ", 2);
  }
  if (a1 % 60)
  {
    *(void *)((char *)&v14[1] + *(void *)(*(void *)&v14[0] - 24) + 8) = 2;
    LOBYTE(__p[0]) = 48;
    sub_1004DC904(v14, (char *)__p);
    int v8 = (void *)std::ostream::operator<<();
    sub_10004B96C(v8, (uint64_t)"s", 1);
  }
  __p[0] = 0;
  __p[1] = 0;
  uint64_t v12 = 0;
  sub_10004BC98((uint64_t)v14 + 8, __p);
  if (SHIBYTE(v12) < 0)
  {
    if (__p[1])
    {
      sub_10004FC84((unsigned char *)a2, __p[0], (unint64_t)__p[1]);
      goto LABEL_15;
    }
  }
  else if (HIBYTE(v12))
  {
    *(_OWORD *)a2 = *(_OWORD *)__p;
    *(void *)(a2 + 16) = v12;
    goto LABEL_15;
  }
  sub_100058DB0((void *)a2, "(0 duration)");
LABEL_15:
  if (SHIBYTE(v12) < 0) {
    operator delete(__p[0]);
  }
  *(void *)((char *)&v14[-1]
  *(void *)&v14[0] = v9;
  if (SHIBYTE(v16) < 0) {
    operator delete(v15[1]);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return std::ios::~ios();
}

void sub_100563D2C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  sub_10008248C((uint64_t)&a16);
  _Unwind_Resume(a1);
}

void sub_100563D68(Registry **a1@<X0>, os_log_t *a2@<X1>, unsigned __int8 *a3@<X2>, unsigned char *a4@<X3>, uint64_t a5@<X8>)
{
  *a4 = 0;
  if (((char)a3[23] & 0x80000000) == 0)
  {
    if (!a3[23])
    {
      *(_OWORD *)a5 = *(_OWORD *)a3;
      *(void *)(a5 + 16) = *((void *)a3 + 2);
      return;
    }
LABEL_5:
    long long v40 = 0;
    std::string::size_type v41 = 0;
    uint64_t v42 = 0;
    sub_100058DB0(&v40, "+");
    uint64_t v10 = a3[23];
    if ((char)a3[23] < 0)
    {
      if (!*((void *)a3 + 1)) {
        goto LABEL_78;
      }
      int v11 = *(unsigned __int8 **)a3;
    }
    else
    {
      int v11 = a3;
      if (!a3[23]) {
LABEL_78:
      }
        sub_1000C14D8();
    }
    int v12 = *v11;
    long long v13 = (unsigned __int8 *)&v40;
    if (v42 < 0) {
      long long v13 = (unsigned __int8 *)v40;
    }
    if (v12 == *v13)
    {
      *a4 = 1;
      if ((char)a3[23] < 0)
      {
        sub_10004FC84((unsigned char *)a5, *(void **)a3, *((void *)a3 + 1));
        goto LABEL_74;
      }
      goto LABEL_73;
    }
    if ((v10 & 0x80u) != 0) {
      uint64_t v10 = *((void *)a3 + 1);
    }
    if (v10 != 10)
    {
      sub_1002055B4((const void **)&v40, (const void **)a3, (void *)a5);
      goto LABEL_74;
    }
    ServiceMap = (std::mutex *)Registry::getServiceMap((uint64_t *)0xA, *a1);
    CFIndex v15 = ServiceMap;
    if ((v16 & 0x8000000000000000) != 0)
    {
      long long v17 = (unsigned __int8 *)(v16 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v18 = 5381;
      do
      {
        std::string::size_type v16 = v18;
        unsigned int v19 = *v17++;
        uint64_t v18 = (33 * v18) ^ v19;
      }
      while (v19);
    }
    std::mutex::lock(ServiceMap);
    buf.__r_.__value_.__r.__words[0] = v16;
    long long v20 = sub_10004D37C(&v15[1].__m_.__sig, (unint64_t *)&buf);
    if (v20)
    {
      uint64_t v22 = v20[3];
      long long v21 = (std::__shared_weak_count *)v20[4];
      if (v21)
      {
        atomic_fetch_add_explicit(&v21->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v15);
        atomic_fetch_add_explicit(&v21->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v21);
        char v23 = 0;
        if (!v22) {
          goto LABEL_70;
        }
        goto LABEL_31;
      }
    }
    else
    {
      uint64_t v22 = 0;
    }
    std::mutex::unlock(v15);
    long long v21 = 0;
    char v23 = 1;
    if (!v22) {
      goto LABEL_70;
    }
LABEL_31:
    std::string::size_type v39 = 0;
    (*(void (**)(std::string *__return_ptr, uint64_t))(*(void *)v22 + 88))(&v38, v22);
    if (SHIBYTE(v38.__r_.__value_.__r.__words[2]) < 0) {
      sub_10004FC84(&__p, v38.__r_.__value_.__l.__data_, v38.__r_.__value_.__l.__size_);
    }
    else {
      std::string __p = v38;
    }
    std::string::size_type v43 = 0;
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      sub_10004FC84(&buf, __p.__r_.__value_.__l.__data_, __p.__r_.__value_.__l.__size_);
    }
    else {
      std::string buf = __p;
    }
    std::string::size_type v45 = 0;
    if (ctu::cf::convert_copy())
    {
      std::string::size_type v25 = v43;
      std::string::size_type v43 = v45;
      v37.__r_.__value_.__r.__words[0] = v25;
      sub_1000558F4((const void **)&v37.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(buf.__r_.__value_.__l.__data_);
    }
    std::string::size_type v39 = v43;
    std::string::size_type v43 = 0;
    sub_1000558F4((const void **)&v43);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v38.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v38.__r_.__value_.__l.__data_);
    }
    std::string::size_type v45 = 0;
    std::string::size_type v45 = _PNCopyInternationalCodeForCountry();
    if (v45) {
      long long v26 = sub_1000810B8;
    }
    else {
      long long v26 = 0;
    }
    if (v26)
    {
      *(void *)a5 = 0;
      *(void *)(a5 + 8) = 0;
      *(void *)(a5 + 16) = 0;
      memset(&buf, 0, sizeof(buf));
      ctu::cf::assign();
      std::string v37 = buf;
      if (v42 >= 0) {
        uint64_t v27 = (const std::string::value_type *)&v40;
      }
      else {
        uint64_t v27 = (const std::string::value_type *)v40;
      }
      if (v42 >= 0) {
        std::string::size_type v28 = HIBYTE(v42);
      }
      else {
        std::string::size_type v28 = v41;
      }
      int v29 = std::string::insert(&v37, 0, v27, v28);
      long long v30 = *(_OWORD *)&v29->__r_.__value_.__l.__data_;
      __p.__r_.__value_.__r.__words[2] = v29->__r_.__value_.__r.__words[2];
      *(_OWORD *)&__p.__r_.__value_.__l.__data_ = v30;
      v29->__r_.__value_.__l.__size_ = 0;
      v29->__r_.__value_.__r.__words[2] = 0;
      v29->__r_.__value_.__r.__words[0] = 0;
      int v31 = (char)a3[23];
      if (v31 >= 0) {
        long long v32 = (const std::string::value_type *)a3;
      }
      else {
        long long v32 = *(const std::string::value_type **)a3;
      }
      if (v31 >= 0) {
        std::string::size_type v33 = a3[23];
      }
      else {
        std::string::size_type v33 = *((void *)a3 + 1);
      }
      os_log_t v34 = std::string::append(&__p, v32, v33);
      long long v35 = *(_OWORD *)&v34->__r_.__value_.__l.__data_;
      *(void *)(a5 + 16) = *((void *)&v34->__r_.__value_.__l + 2);
      *(_OWORD *)a5 = v35;
      v34->__r_.__value_.__l.__size_ = 0;
      v34->__r_.__value_.__r.__words[2] = 0;
      v34->__r_.__value_.__r.__words[0] = 0;
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v37.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v37.__r_.__value_.__l.__data_);
      }
      *a4 = 1;
      long long v36 = *a2;
      if (os_log_type_enabled(*a2, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(buf.__r_.__value_.__l.__data_) = 138543618;
        *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = v45;
        WORD2(buf.__r_.__value_.__r.__words[1]) = 2114;
        *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = v39;
        _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_DEFAULT, "#I Appended country dialing code: %{public}@ for %{public}@", (uint8_t *)&buf, 0x16u);
      }
      sub_1000558F4((const void **)&v45);
      sub_1000558F4((const void **)&v39);
      if ((v23 & 1) == 0) {
        sub_10004D2C8(v21);
      }
      goto LABEL_74;
    }
    sub_1000558F4((const void **)&v45);
    sub_1000558F4((const void **)&v39);
LABEL_70:
    if ((v23 & 1) == 0) {
      sub_10004D2C8(v21);
    }
    if ((char)a3[23] < 0)
    {
      sub_10004FC84((unsigned char *)a5, *(void **)a3, *((void *)a3 + 1));
LABEL_74:
      if (SHIBYTE(v42) < 0) {
        operator delete(v40);
      }
      return;
    }
LABEL_73:
    *(_OWORD *)a5 = *(_OWORD *)a3;
    *(void *)(a5 + 16) = *((void *)a3 + 2);
    goto LABEL_74;
  }
  if (*((void *)a3 + 1)) {
    goto LABEL_5;
  }
  long long v24 = *(void **)a3;

  sub_10004FC84((unsigned char *)a5, v24, 0);
}

void sub_100564298(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,char a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,const void *a29,void *__p,uint64_t a31,int a32,__int16 a33,char a34,char a35,char a36)
{
  sub_1000558F4(&a29);
  if (a35 < 0) {
    operator delete(__p);
  }
  if (a21 < 0) {
    operator delete(a16);
  }
  if ((v37 & 1) == 0) {
    sub_10004D2C8(v36);
  }
  if (a28 < 0) {
    operator delete(a23);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100564398(uint64_t a1, Registry **a2, uint64_t a3)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(*a2);
  int v5 = ServiceMap;
  if (v6 < 0)
  {
    BOOL v7 = (unsigned __int8 *)(v6 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v8 = 5381;
    do
    {
      uint64_t v6 = v8;
      unsigned int v9 = *v7++;
      uint64_t v8 = (33 * v8) ^ v9;
    }
    while (v9);
  }
  uint64_t v26 = 0;
  uint64_t v27 = 0;
  std::mutex::lock(ServiceMap);
  __p[0] = (void *)v6;
  uint64_t v10 = sub_10004D37C(&v5[1].__m_.__sig, (unint64_t *)__p);
  if (v10)
  {
    uint64_t v12 = v10[3];
    int v11 = (std::__shared_weak_count *)v10[4];
    if (v11) {
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
    }
  }
  else
  {
    uint64_t v12 = 0;
    int v11 = 0;
  }
  std::mutex::unlock(v5);
  uint64_t v26 = v12;
  uint64_t v27 = v11;
  if (v11)
  {
    atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v11);
  }
  if (v12)
  {
    BOOL v13 = sub_100562B1C((uint64_t)&v26);
    __dst[0] = 0;
    __dst[1] = 0;
    uint64_t v25 = 0;
    uint64_t v14 = sub_100CC85C0(__dst, a3);
    if (sub_100CC7F88(v14))
    {
      if (v13) {
        goto LABEL_28;
      }
      uint64_t v15 = *(unsigned __int8 *)(a3 + 23);
      BOOL v16 = (v15 & 0x80u) != 0;
      if ((v15 & 0x80u) != 0) {
        uint64_t v15 = *(void *)(a3 + 8);
      }
      long long v17 = v16 ? *(char **)a3 : (char *)a3;
      if (v15 < 8) {
        goto LABEL_28;
      }
      uint64_t v18 = &v17[v15];
      unsigned int v19 = v17;
      while (1)
      {
        long long v20 = (char *)memchr(v19, 114, v15 - 7);
        if (!v20) {
          goto LABEL_28;
        }
        if (*(void *)v20 == 0x676F6F672E6D6272) {
          break;
        }
        unsigned int v19 = v20 + 1;
        uint64_t v15 = v18 - (unsigned char *)v19;
        if (v18 - (unsigned char *)v19 < 8) {
          goto LABEL_28;
        }
      }
      if (v20 == v18 || v20 - v17 == -1) {
LABEL_28:
      }
        sub_100CC80B0();
      uint64_t v21 = 1;
    }
    else
    {
      uint64_t v21 = 0;
    }
    if (SHIBYTE(v25) < 0) {
      operator delete(__dst[0]);
    }
  }
  else
  {
    uint64_t v21 = 0;
  }
  if (v11) {
    sub_10004D2C8(v11);
  }
  return v21;
}

void sub_10056479C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,std::locale a26)
{
  sub_100044D00((const void **)(v27 - 120));
  sub_100057D78((const void **)(v27 - 112));
  if (*(char *)(v27 - 81) < 0) {
    operator delete(*(void **)(v27 - 104));
  }
  if (v26) {
    sub_10004D2C8(v26);
  }
  _Unwind_Resume(a1);
}

void sub_100564870(uint64_t *a1@<X0>, std::string *a2@<X8>)
{
  a2->__r_.__value_.__r.__words[0] = 0;
  a2->__r_.__value_.__l.__size_ = 0;
  a2->__r_.__value_.__r.__words[2] = 0;
  if (*((char *)a1 + 23) >= 0) {
    std::string::size_type v4 = *((unsigned __int8 *)a1 + 23);
  }
  else {
    std::string::size_type v4 = a1[1];
  }
  std::string::reserve(a2, v4);
  BOOL v5 = *((char *)a1 + 23) < 0;
  uint64_t v6 = *((unsigned __int8 *)a1 + 23);
  if ((v6 & 0x80u) != 0) {
    uint64_t v6 = a1[1];
  }
  if (v6)
  {
    unint64_t v7 = 0;
    do
    {
      if (v5) {
        uint64_t v8 = (uint64_t *)*a1;
      }
      else {
        uint64_t v8 = a1;
      }
      int v9 = *((char *)v8 + v7);
      if (v9 <= 38)
      {
        if (v9 == 34)
        {
          uint64_t v10 = "&quot;";
          goto LABEL_23;
        }
        if (v9 != 38)
        {
LABEL_29:
          std::string::append(a2, 1uLL, v9);
          goto LABEL_25;
        }
        uint64_t v10 = "&amp;";
        std::string::size_type v11 = 5;
      }
      else
      {
        switch(v9)
        {
          case '\'':
            uint64_t v10 = "&apos;";
LABEL_23:
            std::string::size_type v11 = 6;
            goto LABEL_24;
          case '<':
            uint64_t v10 = "&lt;";
            break;
          case '>':
            uint64_t v10 = "&gt;";
            break;
          default:
            goto LABEL_29;
        }
        std::string::size_type v11 = 4;
      }
LABEL_24:
      std::string::append(a2, v10, v11);
LABEL_25:
      ++v7;
      BOOL v5 = *((char *)a1 + 23) < 0;
      unint64_t v12 = *((unsigned __int8 *)a1 + 23);
      if ((v12 & 0x80u) != 0) {
        unint64_t v12 = a1[1];
      }
    }
    while (v7 < v12);
  }
}

void sub_1005649D0(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1005649F0@<X0>(uint64_t a1@<X0>, void *a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t v26 = 0;
  long long v24 = 0u;
  long long v25 = 0u;
  long long v22 = 0u;
  long long v23 = 0u;
  long long v20 = 0u;
  long long v21 = 0u;
  long long v18 = 0u;
  long long v19 = 0u;
  long long v16 = 0u;
  long long v17 = 0u;
  *(_OWORD *)std::string __p = 0u;
  long long v15 = 0u;
  memset(v13, 0, sizeof(v13));
  long long v12 = 0u;
  sub_10004BD84((uint64_t)&v12);
  uint64_t v6 = sub_10004B96C(v13, (uint64_t)"http://", 7);
  int v7 = *(char *)(a1 + 23);
  if (v7 >= 0) {
    uint64_t v8 = a1;
  }
  else {
    uint64_t v8 = *(void *)a1;
  }
  if (v7 >= 0) {
    uint64_t v9 = *(unsigned __int8 *)(a1 + 23);
  }
  else {
    uint64_t v9 = *(void *)(a1 + 8);
  }
  sub_10004B96C(v6, v8, v9);
  if (a2[2]) {
    sub_100564BEC((uint64_t)&v12, a2, a3);
  }
  else {
    sub_10004BC98((uint64_t)v13 + 8, a3);
  }
  *(void *)((char *)&v13[-1]
  *(void *)&v13[0] = v10;
  if (SHIBYTE(v15) < 0) {
    operator delete(__p[1]);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return std::ios::~ios();
}

void sub_100564BD8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_100564BEC@<X0>(uint64_t a1@<X0>, void *a2@<X1>, uint64_t *a3@<X8>)
{
  if (a2[2]) {
    sub_10004B96C((void *)(a1 + 16), (uint64_t)"/?", 2);
  }
  uint64_t v6 = (void *)*a2;
  if ((void *)*a2 != a2 + 1)
  {
    do
    {
      int v7 = *((char *)v6 + 55);
      if (v7 >= 0) {
        uint64_t v8 = (uint64_t)(v6 + 4);
      }
      else {
        uint64_t v8 = v6[4];
      }
      if (v7 >= 0) {
        uint64_t v9 = *((unsigned __int8 *)v6 + 55);
      }
      else {
        uint64_t v9 = v6[5];
      }
      xpc_object_t v10 = sub_10004B96C((void *)(a1 + 16), v8, v9);
      std::string::size_type v11 = sub_10004B96C(v10, (uint64_t)"=", 1);
      int v12 = *((char *)v6 + 79);
      if (v12 >= 0) {
        uint64_t v13 = (uint64_t)(v6 + 7);
      }
      else {
        uint64_t v13 = v6[7];
      }
      if (v12 >= 0) {
        uint64_t v14 = *((unsigned __int8 *)v6 + 79);
      }
      else {
        uint64_t v14 = v6[8];
      }
      long long v15 = sub_10004B96C(v11, v13, v14);
      sub_10004B96C(v15, (uint64_t)"&", 1);
      long long v16 = (void *)v6[1];
      if (v16)
      {
        do
        {
          long long v17 = v16;
          long long v16 = (void *)*v16;
        }
        while (v16);
      }
      else
      {
        do
        {
          long long v17 = (void *)v6[2];
          BOOL v18 = *v17 == (void)v6;
          uint64_t v6 = v17;
        }
        while (!v18);
      }
      uint64_t v6 = v17;
    }
    while (v17 != a2 + 1);
  }
  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  uint64_t result = sub_10004BC98(a1 + 24, a3);
  if (a2[2])
  {
    if (*((char *)a3 + 23) < 0)
    {
      uint64_t v21 = a3[1];
      if (!v21) {
        return result;
      }
      uint64_t v20 = v21 - 1;
      a3[1] = v20;
      a3 = (uint64_t *)*a3;
    }
    else
    {
      if (!*((unsigned char *)a3 + 23)) {
        return result;
      }
      uint64_t v20 = *((unsigned __int8 *)a3 + 23) - 1;
      *((unsigned char *)a3 + 23) = v20;
    }
    *((unsigned char *)a3 + v20) = 0;
  }
  return result;
}

uint64_t sub_100564D6C@<X0>(uint64_t a1@<X0>, void *a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t v26 = 0;
  long long v24 = 0u;
  long long v25 = 0u;
  long long v22 = 0u;
  long long v23 = 0u;
  long long v20 = 0u;
  long long v21 = 0u;
  long long v18 = 0u;
  long long v19 = 0u;
  long long v16 = 0u;
  long long v17 = 0u;
  *(_OWORD *)std::string __p = 0u;
  long long v15 = 0u;
  memset(v13, 0, sizeof(v13));
  long long v12 = 0u;
  sub_10004BD84((uint64_t)&v12);
  uint64_t v6 = sub_10004B96C(v13, (uint64_t)"https://", 8);
  int v7 = *(char *)(a1 + 23);
  if (v7 >= 0) {
    uint64_t v8 = a1;
  }
  else {
    uint64_t v8 = *(void *)a1;
  }
  if (v7 >= 0) {
    uint64_t v9 = *(unsigned __int8 *)(a1 + 23);
  }
  else {
    uint64_t v9 = *(void *)(a1 + 8);
  }
  sub_10004B96C(v6, v8, v9);
  if (a2[2]) {
    sub_100564BEC((uint64_t)&v12, a2, a3);
  }
  else {
    sub_10004BC98((uint64_t)v13 + 8, a3);
  }
  *(void *)((char *)&v13[-1]
  *(void *)&v13[0] = v10;
  if (SHIBYTE(v15) < 0) {
    operator delete(__p[1]);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return std::ios::~ios();
}

void sub_100564F54(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_100564F68(uint64_t a1@<X1>, std::string *a2@<X8>)
{
  std::operator+<char>();
  std::string::size_type v4 = std::string::append(&v10, "/?otp=", 6uLL);
  long long v5 = *(_OWORD *)&v4->__r_.__value_.__l.__data_;
  v11.__r_.__value_.__r.__words[2] = v4->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v11.__r_.__value_.__l.__data_ = v5;
  v4->__r_.__value_.__l.__size_ = 0;
  v4->__r_.__value_.__r.__words[2] = 0;
  v4->__r_.__value_.__r.__words[0] = 0;
  int v6 = *(char *)(a1 + 23);
  if (v6 >= 0) {
    int v7 = (const std::string::value_type *)a1;
  }
  else {
    int v7 = *(const std::string::value_type **)a1;
  }
  if (v6 >= 0) {
    std::string::size_type v8 = *(unsigned __int8 *)(a1 + 23);
  }
  else {
    std::string::size_type v8 = *(void *)(a1 + 8);
  }
  uint64_t v9 = std::string::append(&v11, v7, v8);
  *a2 = *v9;
  v9->__r_.__value_.__l.__size_ = 0;
  v9->__r_.__value_.__r.__words[2] = 0;
  v9->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v11.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v11.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v10.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v10.__r_.__value_.__l.__data_);
  }
}

void sub_10056502C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_100565060(Registry **a1@<X0>, char *a2@<X1>, uint64_t a3@<X8>)
{
  sub_100562274(a1, (uint64_t)&v29);
  long long v5 = std::string::append(&v29, "/", 1uLL);
  long long v6 = *(_OWORD *)&v5->__r_.__value_.__l.__data_;
  v26.__r_.__value_.__r.__words[2] = v5->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v26.__r_.__value_.__l.__data_ = v6;
  v5->__r_.__value_.__l.__size_ = 0;
  v5->__r_.__value_.__r.__words[2] = 0;
  v5->__r_.__value_.__r.__words[0] = 0;
  sub_100058DB0(__p, "ProvisioningData");
  if ((v28 & 0x80u) == 0) {
    int v7 = __p;
  }
  else {
    int v7 = (void **)__p[0];
  }
  if ((v28 & 0x80u) == 0) {
    std::string::size_type v8 = v28;
  }
  else {
    std::string::size_type v8 = (std::string::size_type)__p[1];
  }
  uint64_t v9 = std::string::append(&v26, (const std::string::value_type *)v7, v8);
  long long v10 = *(_OWORD *)&v9->__r_.__value_.__l.__data_;
  int64_t v31 = v9->__r_.__value_.__r.__words[2];
  long long v30 = v10;
  v9->__r_.__value_.__l.__size_ = 0;
  v9->__r_.__value_.__r.__words[2] = 0;
  v9->__r_.__value_.__r.__words[0] = 0;
  if ((char)v28 < 0) {
    operator delete(__p[0]);
  }
  uint64_t v25 = a3;
  if (SHIBYTE(v26.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v26.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v29.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v29.__r_.__value_.__l.__data_);
  }
  char v11 = a2[23];
  long long v12 = *(char **)a2;
  if (v11 >= 0) {
    uint64_t v13 = a2;
  }
  else {
    uint64_t v13 = *(char **)a2;
  }
  char v14 = HIBYTE(v31);
  if (v31 >= 0) {
    long long v15 = (char *)&v30;
  }
  else {
    long long v15 = (char *)v30;
  }
  if (v31 >= 0) {
    int64_t v16 = HIBYTE(v31);
  }
  else {
    int64_t v16 = *((void *)&v30 + 1);
  }
  if (!v16) {
    goto LABEL_40;
  }
  unint64_t v24 = *((void *)a2 + 1);
  uint64_t v17 = v11 >= 0 ? a2[23] : *((void *)a2 + 1);
  if (v17 >= v16)
  {
    long long v18 = &v13[v17];
    int v19 = *v15;
    long long v20 = v13;
    while (1)
    {
      uint64_t v21 = v17 - v16;
      if (v21 == -1) {
        goto LABEL_27;
      }
      long long v22 = (char *)memchr(v20, v19, v21 + 1);
      if (!v22) {
        goto LABEL_27;
      }
      long long v23 = v22;
      if (!memcmp(v22, v15, v16)) {
        break;
      }
      long long v20 = v23 + 1;
      uint64_t v17 = v18 - (v23 + 1);
      if (v17 < v16) {
        goto LABEL_27;
      }
    }
    if (v23 != v18 && v23 - v13 != -1) {
LABEL_40:
    }
      sub_1005653F8((std::locale *)&v26);
  }
LABEL_27:
  if (v11 < 0)
  {
    sub_10004FC84((unsigned char *)v25, v12, v24);
    if (v14 < 0) {
LABEL_41:
    }
      operator delete((void *)v30);
  }
  else
  {
    *(_OWORD *)uint64_t v25 = *(_OWORD *)a2;
    *(void *)(v25 + 16) = *((void *)a2 + 2);
    if (v14 < 0) {
      goto LABEL_41;
    }
  }
}

void sub_100565320(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::locale a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33)
{
  if (v33 < 0) {
    operator delete(*(void **)(v34 - 112));
  }
  _Unwind_Resume(exception_object);
}

const void **sub_1005653C4(const void **a1)
{
  id v2 = *a1;
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

void sub_1005653F8(std::locale *a1)
{
  uint64_t v1 = sub_100565488(a1);
  v1[7].__locale_ = 0;
  *(_OWORD *)&v1[5].__locale_ = 0u;
  *(_OWORD *)&v1[3].__locale_ = 0u;
  sub_1005654E8();
}

void sub_100565468(_Unwind_Exception *a1)
{
  locale = (std::__shared_weak_count *)v1[6].__locale_;
  if (locale) {
    sub_10004D2C8(locale);
  }
  std::locale::~locale(v1);
  _Unwind_Resume(a1);
}

std::locale *sub_100565488(std::locale *a1)
{
  id v2 = std::locale::locale(a1);
  a1[1].__locale_ = (std::locale::__imp *)std::locale::use_facet(v2, &std::ctype<char>::id);
  a1[2].__locale_ = (std::locale::__imp *)std::locale::use_facet(a1, &std::collate<char>::id);
  return a1;
}

void sub_1005654D4(_Unwind_Exception *a1)
{
  std::locale::~locale(v1);
  _Unwind_Resume(a1);
}

void sub_1005654E8()
{
}

void sub_1005658D8(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

void sub_10056590C()
{
  exception = (std::regex_error *)__cxa_allocate_exception(0x18uLL);
  std::regex_error::regex_error(exception, __re_err_parse);
}

void sub_100565950(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void sub_100565964(uint64_t a1, uint64_t a2)
{
  sub_100565CE4(&v2, a2);
}

unsigned char *sub_1005659AC(_DWORD *a1, unsigned __int8 *a2, char *a3)
{
  long long v6 = a2;
  do
  {
    int v7 = v6;
    long long v6 = sub_100566140(a1, v6, a3);
  }
  while (v7 != v6);
  if (v7 == a2) {
    operator new();
  }
  if (v7 != a3 && *v7 == 124)
  {
    std::string::size_type v8 = v7 + 1;
    uint64_t v9 = v7 + 1;
    do
    {
      long long v10 = v9;
      uint64_t v9 = sub_100566140(a1, v9, a3);
    }
    while (v10 != v9);
    if (v8 == v10) {
      operator new();
    }
    sub_100566038();
  }
  return v7;
}

unsigned __int8 *sub_100565B0C(uint64_t a1, unsigned __int8 *a2, unsigned __int8 *a3)
{
  BOOL v3 = a2;
  if (a2 == a3) {
    return a2;
  }
  std::string::size_type v4 = a3;
  if (*a2 == 94) {
    sub_100566A7C();
  }
  if (a2 != a3)
  {
    do
    {
      long long v6 = v3;
      BOOL v3 = sub_10056BF40(a1, v3, v4);
    }
    while (v6 != v3);
    if (v6 != v4)
    {
      if (v6 + 1 == v4 && *v6 == 36) {
        sub_100566B00();
      }
      sub_10056BEE8();
    }
  }
  return v4;
}

char *sub_100565BBC(uint64_t a1, unsigned __int8 *a2, char *a3)
{
  long long v6 = sub_10056C464(a1, a2, a3);
  if (v6 == a2) {
LABEL_8:
  }
    sub_10056BEE8();
  int v7 = v6;
  if (v6 == (unsigned __int8 *)a3) {
    return a3;
  }
  if (*v6 == 124)
  {
    if (v6 + 1 != sub_10056C464(a1, v6 + 1, a3)) {
      sub_100566038();
    }
    goto LABEL_8;
  }
  return (char *)v7;
}

void sub_100565C60()
{
  exception = (std::regex_error *)__cxa_allocate_exception(0x18uLL);
  std::regex_error::regex_error(exception, __re_err_grammar);
}

void sub_100565CA4(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void sub_100565CBC()
{
}

void sub_100565CD0(uint64_t a1, _DWORD *a2)
{
  *a2 = -1000;
}

void sub_100565CE4(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_100565D4C(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100565D88(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100565DC0(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_100565DF0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

void *sub_100565E34(void *a1)
{
  *a1 = off_1019E3B28;
  uint64_t v2 = a1[1];
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  return a1;
}

void sub_100565EA0(void *a1)
{
  *a1 = off_1019E3B28;
  uint64_t v1 = a1[1];
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }

  operator delete();
}

uint64_t sub_100565F2C(uint64_t result, uint64_t a2)
{
  *(_DWORD *)a2 = -994;
  *(void *)(a2 + 80) = *(void *)(result + 8);
  return result;
}

void *sub_100565F40(void *a1)
{
  *a1 = off_1019E3B28;
  uint64_t v2 = a1[1];
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  return a1;
}

void sub_100565FAC(void *a1)
{
  *a1 = off_1019E3B28;
  uint64_t v1 = a1[1];
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }

  operator delete();
}

void sub_100566038()
{
}

unsigned __int8 *sub_100566140(_DWORD *a1, unsigned __int8 *a2, char *a3)
{
  if (a2 == (unsigned __int8 *)a3) {
    return a2;
  }
  int v6 = (char)*a2;
  int v7 = *a2;
  if (v6 > 91)
  {
    if (v6 == 92)
    {
      if (a2 + 1 != (unsigned __int8 *)a3)
      {
        int v13 = a2[1];
        if (v13 == 66 || v13 == 98) {
          sub_100566B84();
        }
      }
    }
    else if (v6 == 94)
    {
      sub_100566A7C();
    }
  }
  else
  {
    if (v6 == 36) {
      sub_100566B00();
    }
    BOOL v9 = v6 == 40;
    std::string::size_type v8 = (char *)(a2 + 1);
    BOOL v9 = !v9 || v8 == a3;
    if (!v9)
    {
      BOOL v9 = *v8 == 63;
      long long v10 = (char *)(a2 + 2);
      if (v9 && v10 != a3)
      {
        int v12 = *v10;
        if (v12 == 33)
        {
          long long v26 = 0u;
          memset(v27, 0, sizeof(v27));
          sub_100565488((std::locale *)&v26);
          memset((char *)v27 + 8, 0, 40);
          DWORD2(v27[0]) = a1[6];
          sub_1005654E8(&v26, a2 + 3, a3);
          sub_100566C18();
        }
        if (v12 == 61)
        {
          long long v26 = 0u;
          memset(v27, 0, sizeof(v27));
          sub_100565488((std::locale *)&v26);
          memset((char *)v27 + 8, 0, 40);
          DWORD2(v27[0]) = a1[6];
          sub_1005654E8(&v26, a2 + 3, a3);
          sub_100566C18();
        }
      }
    }
  }
  if ((char)v7 <= 91)
  {
    uint64_t result = a2;
    switch((char)v7)
    {
      case '$':
      case ')':
        return result;
      case '%':
      case '&':
      case '\'':
      case ',':
      case '-':
        goto LABEL_49;
      case '(':
        if (a2 + 1 == (unsigned __int8 *)a3) {
          goto LABEL_78;
        }
        if (a2 + 2 != (unsigned __int8 *)a3 && a2[1] == 63 && a2[2] == 58)
        {
          ++a1[9];
          long long v15 = (char *)sub_1005659AC(a1, a2 + 3, a3);
          if (v15 != a3 && *v15 == 41)
          {
            --a1[9];
            int64_t v16 = (unsigned __int8 *)(v15 + 1);
            goto LABEL_74;
          }
LABEL_78:
          sub_100566CC0();
        }
        sub_100567CA4((uint64_t)a1);
        ++a1[9];
        uint64_t v21 = (char *)sub_1005659AC(a1, a2 + 1, a3);
        if (v21 == a3) {
          goto LABEL_78;
        }
        long long v22 = v21;
        if (*v21 != 41) {
          goto LABEL_78;
        }
        sub_100567D28((uint64_t)a1);
        --a1[9];
        int64_t v16 = (unsigned __int8 *)(v22 + 1);
        goto LABEL_74;
      case '*':
      case '+':
        goto LABEL_51;
      case '.':
        operator new();
      default:
        if ((char)v7 == 91)
        {
          int64_t v16 = sub_100567570((uint64_t)a1, a2, a3);
          goto LABEL_74;
        }
        if ((char)v7 != 63) {
          goto LABEL_49;
        }
        goto LABEL_51;
    }
  }
  uint64_t v17 = ((char)v7 - 92);
  if (v17 > 0x21) {
LABEL_49:
  }
    sub_100568348((uint64_t)a1);
  if (((1 << (v7 - 92)) & 0x300000006) != 0) {
    return a2;
  }
  if ((char)v7 != 92)
  {
    if (v17 == 31) {
LABEL_51:
    }
      sub_100567DA4();
    goto LABEL_49;
  }
  int64_t v16 = a2;
  if (v7 != 92) {
    goto LABEL_74;
  }
  long long v18 = a2 + 1;
  if (a2 + 1 == (unsigned __int8 *)a3) {
    sub_100567EF4();
  }
  int v19 = *v18;
  unsigned int v20 = v19 - 48;
  if (v19 == 48) {
    sub_100568348((uint64_t)a1);
  }
  if ((v19 - 49) <= 8)
  {
    long long v23 = (char *)(a2 + 2);
    if (a2 + 2 == (unsigned __int8 *)a3) {
      goto LABEL_58;
    }
    do
    {
      int v24 = *v23;
      if ((v24 - 48) > 9) {
        break;
      }
      if (v20 >= 0x19999999) {
        goto LABEL_79;
      }
      ++v23;
      unsigned int v20 = v24 + 10 * v20 - 48;
    }
    while (v23 != a3);
    if (v20)
    {
LABEL_58:
      if (v20 <= a1[7]) {
        sub_1005684E0((uint64_t)a1);
      }
    }
LABEL_79:
    sub_100568488();
  }
  if ((char)v19 <= 99)
  {
    if ((char)v19 != 68)
    {
      if ((char)v19 != 83)
      {
        if ((char)v19 == 87) {
LABEL_69:
        }
          sub_100569160();
        goto LABEL_70;
      }
LABEL_73:
      sub_100569160();
    }
    goto LABEL_68;
  }
  switch((char)v19)
  {
    case 'w':
      goto LABEL_69;
    case 's':
      goto LABEL_73;
    case 'd':
LABEL_68:
      sub_100569160();
  }
LABEL_70:
  uint64_t v25 = sub_100567F4C((uint64_t)a1, a2 + 1, (unsigned __int8 *)a3, 0);
  if (v18 == v25) {
    int64_t v16 = a2;
  }
  else {
    int64_t v16 = v25;
  }
LABEL_74:
  uint64_t result = a2;
  if (v16 != a2)
  {
    return sub_100566774((uint64_t)a1, v16, (unsigned __int8 *)a3);
  }
  return result;
}

void sub_100566728(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, std::locale a9)
{
}

unsigned __int8 *sub_100566774(uint64_t a1, unsigned __int8 *a2, unsigned __int8 *a3)
{
  if (a2 == a3) {
    return a2;
  }
  int v4 = (char)*a2;
  if (v4 <= 62)
  {
    if (v4 == 42 || (long long v5 = a2, v4 == 43)) {
LABEL_18:
    }
      sub_10056B8E8();
    return v5;
  }
  if (v4 == 63) {
    goto LABEL_18;
  }
  long long v5 = a2;
  if (v4 == 123)
  {
    int v13 = 0;
    int v6 = a2 + 1;
    int v7 = sub_10056BA78(a2 + 1, a3, &v13);
    if (v6 == v7) {
      goto LABEL_24;
    }
    if (v7 != a3)
    {
      int v8 = (char)*v7;
      if (v8 != 44)
      {
        if (v8 == 125) {
          goto LABEL_18;
        }
LABEL_24:
        sub_10056BB14();
      }
      BOOL v9 = v7 + 1;
      if (v7 + 1 == a3) {
        goto LABEL_24;
      }
      if (*v9 == 125) {
        goto LABEL_18;
      }
      int v12 = -1;
      char v11 = sub_10056BA78(v7 + 1, a3, &v12);
      if (v9 != v11 && v11 != a3 && *v11 == 125)
      {
        if (v12 >= v13) {
          goto LABEL_18;
        }
        goto LABEL_24;
      }
    }
    sub_10056BB6C();
  }
  return v5;
}

void sub_100566A7C()
{
}

void sub_100566B00()
{
}

void sub_100566B84()
{
}

void sub_100566C18()
{
}

void sub_100566C9C()
{
}

void sub_100566CC0()
{
  exception = (std::regex_error *)__cxa_allocate_exception(0x18uLL);
  std::regex_error::regex_error(exception, error_paren);
}

void sub_100566D04(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void *sub_100566D18(void *a1)
{
  *a1 = off_1019E3B28;
  uint64_t v2 = a1[1];
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  return a1;
}

void sub_100566D84(void *a1)
{
  *a1 = off_1019E3B28;
  uint64_t v1 = a1[1];
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }

  operator delete();
}

uint64_t sub_100566E10(uint64_t result, uint64_t a2)
{
  if (*(unsigned char *)(a2 + 92))
  {
    if (*(void *)(a2 + 16) != *(void *)(a2 + 8) || (*(unsigned char *)(a2 + 88) & 1) != 0)
    {
LABEL_12:
      uint64_t v4 = 0;
      *(_DWORD *)a2 = -993;
      goto LABEL_13;
    }
  }
  else
  {
    if (!*(unsigned char *)(result + 16)) {
      goto LABEL_12;
    }
    int v2 = *(unsigned __int8 *)(*(void *)(a2 + 16) - 1);
    if (v2 != 13 && v2 != 10) {
      goto LABEL_12;
    }
  }
  *(_DWORD *)a2 = -994;
  uint64_t v4 = *(void *)(result + 8);
LABEL_13:
  *(void *)(a2 + 80) = v4;
  return result;
}

void *sub_100566E70(void *a1)
{
  *a1 = off_1019E3B28;
  uint64_t v2 = a1[1];
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  return a1;
}

void sub_100566EDC(void *a1)
{
  *a1 = off_1019E3B28;
  uint64_t v1 = a1[1];
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }

  operator delete();
}

uint64_t sub_100566F68(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(unsigned __int8 **)(a2 + 16);
  if (v2 == *(unsigned __int8 **)(a2 + 24) && (*(unsigned char *)(a2 + 88) & 2) == 0
    || *(unsigned char *)(result + 16) && ((int v3 = *v2, v3 != 13) ? (v4 = v3 == 10) : (v4 = 1), v4))
  {
    *(_DWORD *)a2 = -994;
    uint64_t v5 = *(void *)(result + 8);
  }
  else
  {
    uint64_t v5 = 0;
    *(_DWORD *)a2 = -993;
  }
  *(void *)(a2 + 80) = v5;
  return result;
}

std::locale *sub_100566FB8(std::locale *a1)
{
  a1->__locale_ = (std::locale::__imp *)off_1019E3BE8;
  std::locale::~locale(a1 + 2);
  a1->__locale_ = (std::locale::__imp *)off_1019E3B28;
  locale = a1[1].__locale_;
  if (locale) {
    (*(void (**)(std::locale::__imp *))(*(void *)locale + 8))(locale);
  }
  return a1;
}

void sub_100567044(std::locale *a1)
{
  a1->__locale_ = (std::locale::__imp *)off_1019E3BE8;
  std::locale::~locale(a1 + 2);
  a1->__locale_ = (std::locale::__imp *)off_1019E3B28;
  locale = a1[1].__locale_;
  if (locale) {
    (*(void (**)(std::locale::__imp *))(*(void *)locale + 8))(locale);
  }

  operator delete();
}

uint64_t sub_1005670F0(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(unsigned __int8 **)(a2 + 8);
  int v3 = *(unsigned __int8 **)(a2 + 24);
  if (v2 == v3) {
    goto LABEL_17;
  }
  BOOL v4 = *(unsigned __int8 **)(a2 + 16);
  if (v4 == v3)
  {
    if ((*(unsigned char *)(a2 + 88) & 8) == 0)
    {
      uint64_t v6 = *(v3 - 1);
      goto LABEL_13;
    }
LABEL_17:
    int v10 = 0;
    goto LABEL_25;
  }
  if (v4 == v2)
  {
    int v5 = *(_DWORD *)(a2 + 88);
    if ((v5 & 0x80) == 0)
    {
      if ((v5 & 4) == 0)
      {
        uint64_t v6 = *v2;
LABEL_13:
        if (v6 == 95
          || (v6 & 0x80) == 0 && (*(_DWORD *)(*(void *)(*(void *)(result + 24) + 16) + 4 * v6) & 0x500) != 0)
        {
          int v10 = 1;
          goto LABEL_25;
        }
        goto LABEL_17;
      }
      goto LABEL_17;
    }
  }
  uint64_t v7 = *(v4 - 1);
  uint64_t v8 = *v4;
  int v9 = v7 == 95 || (v7 & 0x80) == 0 && (*(_DWORD *)(*(void *)(*(void *)(result + 24) + 16) + 4 * v7) & 0x500) != 0;
  int v11 = v8 == 95
     || (v8 & 0x80) == 0 && (*(_DWORD *)(*(void *)(*(void *)(result + 24) + 16) + 4 * v8) & 0x500) != 0;
  int v10 = v9 != v11;
LABEL_25:
  if (*(unsigned __int8 *)(result + 40) == v10)
  {
    uint64_t v12 = 0;
    int v13 = -993;
  }
  else
  {
    uint64_t v12 = *(void *)(result + 8);
    int v13 = -994;
  }
  *(_DWORD *)a2 = v13;
  *(void *)(a2 + 80) = v12;
  return result;
}

uint64_t sub_100567204(uint64_t a1, uint64_t a2, char a3, uint64_t a4, int a5)
{
  *(void *)a1 = off_1019E3C30;
  *(void *)(a1 + 8) = a4;
  std::locale::locale((std::locale *)(a1 + 16), (const std::locale *)a2);
  *(_OWORD *)(a1 + 24) = *(_OWORD *)(a2 + 8);
  *(_OWORD *)(a1 + 40) = *(_OWORD *)(a2 + 24);
  uint64_t v9 = *(void *)(a2 + 48);
  *(void *)(a1 + 56) = *(void *)(a2 + 40);
  *(void *)(a1 + 64) = v9;
  if (v9) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v9 + 8), 1uLL, memory_order_relaxed);
  }
  *(void *)(a1 + 72) = *(void *)(a2 + 56);
  *(_DWORD *)(a1 + 80) = a5;
  *(unsigned char *)(a1 + 84) = a3;
  return a1;
}

std::locale *sub_100567294(std::locale *a1)
{
  a1->__locale_ = (std::locale::__imp *)off_1019E3C30;
  uint64_t v2 = a1 + 2;
  locale = (std::__shared_weak_count *)a1[8].__locale_;
  if (locale) {
    sub_10004D2C8(locale);
  }
  std::locale::~locale(v2);
  a1->__locale_ = (std::locale::__imp *)off_1019E3B28;
  BOOL v4 = a1[1].__locale_;
  if (v4) {
    (*(void (**)(std::locale::__imp *))(*(void *)v4 + 8))(v4);
  }
  return a1;
}

void sub_100567334(std::locale *a1)
{
  a1->__locale_ = (std::locale::__imp *)off_1019E3C30;
  uint64_t v2 = a1 + 2;
  locale = (std::__shared_weak_count *)a1[8].__locale_;
  if (locale) {
    sub_10004D2C8(locale);
  }
  std::locale::~locale(v2);
  a1->__locale_ = (std::locale::__imp *)off_1019E3B28;
  BOOL v4 = a1[1].__locale_;
  if (v4) {
    (*(void (**)(std::locale::__imp *))(*(void *)v4 + 8))(v4);
  }

  operator delete();
}

void sub_1005673F4(uint64_t a1, uint64_t a2)
{
  long long v21 = 0u;
  long long v19 = 0u;
  memset(v20, 0, sizeof(v20));
  memset(v18, 0, sizeof(v18));
  *(_OWORD *)std::string __p = 0u;
  unint64_t v4 = (*(_DWORD *)(a1 + 44) + 1);
  uint64_t v5 = *(void *)(a2 + 16);
  *((void *)&v18[0] + 1) = *(void *)(a2 + 24);
  *(void *)&v18[1] = *((void *)&v18[0] + 1);
  sub_100155E0C((char **)__p, v4, (long long *)((char *)v18 + 8));
  *(void *)&long long v19 = v5;
  *((void *)&v19 + 1) = v5;
  LOBYTE(v20[0]) = 0;
  *(_OWORD *)((char *)v20 + 8) = *(long long *)((char *)v18 + 8);
  BYTE8(v20[1]) = BYTE8(v18[1]);
  *((void *)&v21 + 1) = v5;
  LOBYTE(v21) = 1;
  uint64_t v6 = *(void *)(a2 + 16);
  if (*(unsigned char *)(a2 + 92)) {
    BOOL v7 = v6 == *(void *)(a2 + 8);
  }
  else {
    BOOL v7 = 0;
  }
  char v8 = v7;
  if (*(unsigned __int8 *)(a1 + 84) == sub_100155F84(a1 + 16, v6, *(void *)(a2 + 24), (uint64_t *)__p, *(_DWORD *)(a2 + 88) & 0xFBF | 0x40u, v8))
  {
    *(_DWORD *)a2 = -993;
    *(void *)(a2 + 80) = 0;
    uint64_t v9 = (char *)__p[0];
    goto LABEL_13;
  }
  *(_DWORD *)a2 = -994;
  *(void *)(a2 + 80) = *(void *)(a1 + 8);
  uint64_t v9 = (char *)__p[0];
  unint64_t v10 = 0xAAAAAAAAAAAAAAABLL * (((char *)__p[1] - (char *)__p[0]) >> 3);
  if (v10 < 2)
  {
LABEL_13:
    if (!v9) {
      return;
    }
    goto LABEL_14;
  }
  int v11 = 0;
  int v12 = *(_DWORD *)(a1 + 80);
  uint64_t v13 = *(void *)(a2 + 32);
  unint64_t v14 = 1;
  do
  {
    long long v15 = &v9[24 * v14];
    uint64_t v16 = v13 + 24 * (v12 + v11);
    *(_OWORD *)uint64_t v16 = *(_OWORD *)v15;
    *(unsigned char *)(v16 + 16) = v15[16];
    unint64_t v14 = (v11 + 2);
    ++v11;
  }
  while (v10 > v14);
LABEL_14:
  __p[1] = v9;
  operator delete(v9);
}

void sub_100567550(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

unsigned char *sub_100567570(uint64_t a1, unsigned char *a2, unsigned char *a3)
{
  if (a2 != a3 && *a2 == 91)
  {
    if (a2 + 1 != a3) {
      sub_100569160();
    }
    sub_10056A30C();
  }
  return a2;
}

void sub_100567C14(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,void *__p,uint64_t a28,int a29,__int16 a30,char a31,char a32)
{
  if (a32 < 0) {
    operator delete(__p);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100567CA4(uint64_t result)
{
  if ((*(unsigned char *)(result + 24) & 2) == 0) {
    operator new();
  }
  return result;
}

uint64_t sub_100567D28(uint64_t result)
{
  if ((*(unsigned char *)(result + 24) & 2) == 0) {
    operator new();
  }
  return result;
}

void sub_100567DA4()
{
  exception = (std::regex_error *)__cxa_allocate_exception(0x18uLL);
  std::regex_error::regex_error(exception, error_badrepeat);
}

void sub_100567DE8(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void *sub_100567DFC(void *a1)
{
  *a1 = off_1019E3B28;
  uint64_t v2 = a1[1];
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  return a1;
}

void sub_100567E68(void *a1)
{
  *a1 = off_1019E3B28;
  uint64_t v1 = a1[1];
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }

  operator delete();
}

void sub_100567EF4()
{
  exception = (std::regex_error *)__cxa_allocate_exception(0x18uLL);
  std::regex_error::regex_error(exception, error_escape);
}

void sub_100567F38(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

unsigned __int8 *sub_100567F4C(uint64_t a1, unsigned __int8 *a2, unsigned __int8 *a3, uint64_t *a4)
{
  unint64_t v4 = a2;
  if (a2 == a3) {
    return v4;
  }
  uint64_t v5 = *a2;
  if ((char)v5 > 109)
  {
    switch((char)v5)
    {
      case 'n':
        if (!a4) {
          goto LABEL_62;
        }
        if (*((char *)a4 + 23) < 0)
        {
          a4[1] = 1;
          a4 = (uint64_t *)*a4;
        }
        else
        {
          *((unsigned char *)a4 + 23) = 1;
        }
        __int16 v14 = 10;
        goto LABEL_74;
      case 'r':
        if (!a4) {
          goto LABEL_62;
        }
        if (*((char *)a4 + 23) < 0)
        {
          a4[1] = 1;
          a4 = (uint64_t *)*a4;
        }
        else
        {
          *((unsigned char *)a4 + 23) = 1;
        }
        __int16 v14 = 13;
        goto LABEL_74;
      case 't':
        if (!a4) {
          goto LABEL_62;
        }
        if (*((char *)a4 + 23) < 0)
        {
          a4[1] = 1;
          a4 = (uint64_t *)*a4;
        }
        else
        {
          *((unsigned char *)a4 + 23) = 1;
        }
        __int16 v14 = 9;
        goto LABEL_74;
      case 'u':
        if (a2 + 1 != a3)
        {
          int v6 = a2[1];
          if ((v6 & 0xF8) == 0x30 || (v6 & 0xFE) == 0x38 || (v6 | 0x20u) - 97 < 6)
          {
            unint64_t v4 = a2 + 2;
            if (a2 + 2 != a3)
            {
              int v7 = *v4;
              if ((v7 & 0xF8) == 0x30 || (v7 & 0xFE) == 0x38 || (v7 | 0x20u) - 97 < 6) {
                goto LABEL_27;
              }
            }
          }
        }
        goto LABEL_83;
      case 'v':
        if (!a4) {
          goto LABEL_62;
        }
        if (*((char *)a4 + 23) < 0)
        {
          a4[1] = 1;
          a4 = (uint64_t *)*a4;
        }
        else
        {
          *((unsigned char *)a4 + 23) = 1;
        }
        __int16 v14 = 11;
        goto LABEL_74;
      case 'x':
LABEL_27:
        if (v4 + 1 == a3) {
          goto LABEL_83;
        }
        unsigned __int8 v8 = v4[1];
        char v9 = -48;
        if ((v8 & 0xF8) == 0x30 || (v8 & 0xFE) == 0x38) {
          goto LABEL_32;
        }
        v8 |= 0x20u;
        if ((v8 - 97) >= 6u) {
          goto LABEL_83;
        }
        char v9 = -87;
LABEL_32:
        if (v4 + 2 == a3) {
          goto LABEL_83;
        }
        unsigned __int8 v10 = v4[2];
        char v11 = -48;
        if ((v10 & 0xF8) == 0x30 || (v10 & 0xFE) == 0x38) {
          goto LABEL_37;
        }
        v10 |= 0x20u;
        if ((v10 - 97) >= 6u) {
          goto LABEL_83;
        }
        char v11 = -87;
LABEL_37:
        char v12 = v10 + 16 * (v8 + v9) + v11;
        if (!a4) {
          sub_100568348(a1);
        }
        if (*((char *)a4 + 23) < 0)
        {
          a4[1] = 1;
          a4 = (uint64_t *)*a4;
        }
        else
        {
          *((unsigned char *)a4 + 23) = 1;
        }
        *(unsigned char *)a4 = v12;
        *((unsigned char *)a4 + 1) = 0;
        v4 += 3;
        break;
      default:
        goto LABEL_53;
    }
    return v4;
  }
  if ((char)v5 == 48)
  {
    if (!a4) {
      goto LABEL_62;
    }
    if (*((char *)a4 + 23) < 0)
    {
      a4[1] = 1;
      a4 = (uint64_t *)*a4;
    }
    else
    {
      *((unsigned char *)a4 + 23) = 1;
    }
    *(_WORD *)a4 = 0;
    return a2 + 1;
  }
  if ((char)v5 != 99)
  {
    if ((char)v5 == 102)
    {
      if (a4)
      {
        if (*((char *)a4 + 23) < 0)
        {
          a4[1] = 1;
          a4 = (uint64_t *)*a4;
        }
        else
        {
          *((unsigned char *)a4 + 23) = 1;
        }
        __int16 v14 = 12;
LABEL_74:
        *(_WORD *)a4 = v14;
        return a2 + 1;
      }
LABEL_62:
      sub_100568348(a1);
    }
LABEL_53:
    if ((char)v5 != 95
      && ((char)v5 < 0 || (*(_DWORD *)(*(void *)(*(void *)(a1 + 8) + 16) + 4 * v5) & 0x500) == 0))
    {
      if (!a4) {
        goto LABEL_62;
      }
      if (*((char *)a4 + 23) < 0)
      {
        a4[1] = 1;
        a4 = (uint64_t *)*a4;
      }
      else
      {
        *((unsigned char *)a4 + 23) = 1;
      }
      *(unsigned char *)a4 = v5;
      *((unsigned char *)a4 + 1) = 0;
      return a2 + 1;
    }
LABEL_83:
    sub_100567EF4();
  }
  if (a2 + 1 == a3) {
    goto LABEL_83;
  }
  if ((char)a2[1] < 65) {
    goto LABEL_83;
  }
  unsigned int v13 = a2[1];
  if (v13 >= 0x5B && (v13 - 97) > 0x19u) {
    goto LABEL_83;
  }
  if (!a4) {
    sub_100568348(a1);
  }
  if (*((char *)a4 + 23) < 0)
  {
    a4[1] = 1;
    a4 = (uint64_t *)*a4;
  }
  else
  {
    *((unsigned char *)a4 + 23) = 1;
  }
  *(unsigned char *)a4 = v13 & 0x1F;
  *((unsigned char *)a4 + 1) = 0;
  return a2 + 2;
}

void sub_100568348(uint64_t a1)
{
  int v1 = *(_DWORD *)(a1 + 24);
  if ((v1 & 1) == 0)
  {
    if ((v1 & 8) == 0) {
      operator new();
    }
    operator new();
  }
  operator new();
}

void sub_100568464()
{
}

void sub_100568488()
{
  exception = (std::regex_error *)__cxa_allocate_exception(0x18uLL);
  std::regex_error::regex_error(exception, error_backref);
}

void sub_1005684CC(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void sub_1005684E0(uint64_t a1)
{
  int v1 = *(_DWORD *)(a1 + 24);
  if ((v1 & 1) == 0)
  {
    if ((v1 & 8) == 0) {
      operator new();
    }
    operator new();
  }
  operator new();
}

uint64_t sub_100568610(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  *(void *)a1 = off_1019E3CC0;
  *(void *)(a1 + 8) = a4;
  std::locale::locale((std::locale *)(a1 + 16), (const std::locale *)a2);
  *(_OWORD *)(a1 + 24) = *(_OWORD *)(a2 + 8);
  *(unsigned char *)(a1 + 40) = (*(uint64_t (**)(void, uint64_t))(**(void **)(a2 + 8) + 40))(*(void *)(a2 + 8), a3);
  return a1;
}

void sub_1005686A4(_Unwind_Exception *a1)
{
  std::locale::~locale(v2);
  *int v1 = off_1019E3B28;
  uint64_t v4 = v1[1];
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
  }
  _Unwind_Resume(a1);
}

std::locale *sub_100568704(std::locale *a1)
{
  a1->__locale_ = (std::locale::__imp *)off_1019E3CC0;
  std::locale::~locale(a1 + 2);
  a1->__locale_ = (std::locale::__imp *)off_1019E3B28;
  locale = a1[1].__locale_;
  if (locale) {
    (*(void (**)(std::locale::__imp *))(*(void *)locale + 8))(locale);
  }
  return a1;
}

void sub_100568790(std::locale *a1)
{
  a1->__locale_ = (std::locale::__imp *)off_1019E3CC0;
  std::locale::~locale(a1 + 2);
  a1->__locale_ = (std::locale::__imp *)off_1019E3B28;
  locale = a1[1].__locale_;
  if (locale) {
    (*(void (**)(std::locale::__imp *))(*(void *)locale + 8))(locale);
  }

  operator delete();
}

uint64_t sub_10056883C(uint64_t result, uint64_t a2)
{
  int v3 = *(char **)(a2 + 16);
  if (v3 == *(char **)(a2 + 24)
    || (uint64_t v4 = result,
        uint64_t result = (*(uint64_t (**)(void, void))(**(void **)(result + 24) + 40))(*(void *)(result + 24), *v3), *(unsigned __int8 *)(v4 + 40) != result))
  {
    uint64_t v5 = 0;
    *(_DWORD *)a2 = -993;
  }
  else
  {
    *(_DWORD *)a2 = -995;
    ++*(void *)(a2 + 16);
    uint64_t v5 = *(void *)(v4 + 8);
  }
  *(void *)(a2 + 80) = v5;
  return result;
}

std::locale *sub_1005688D0(std::locale *a1)
{
  a1->__locale_ = (std::locale::__imp *)off_1019E3D08;
  std::locale::~locale(a1 + 2);
  a1->__locale_ = (std::locale::__imp *)off_1019E3B28;
  locale = a1[1].__locale_;
  if (locale) {
    (*(void (**)(std::locale::__imp *))(*(void *)locale + 8))(locale);
  }
  return a1;
}

void sub_10056895C(std::locale *a1)
{
  a1->__locale_ = (std::locale::__imp *)off_1019E3D08;
  std::locale::~locale(a1 + 2);
  a1->__locale_ = (std::locale::__imp *)off_1019E3B28;
  locale = a1[1].__locale_;
  if (locale) {
    (*(void (**)(std::locale::__imp *))(*(void *)locale + 8))(locale);
  }

  operator delete();
}

uint64_t sub_100568A08(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(unsigned __int8 **)(a2 + 16);
  if (v2 == *(unsigned __int8 **)(a2 + 24) || *v2 != *(unsigned __int8 *)(result + 40))
  {
    uint64_t v3 = 0;
    *(_DWORD *)a2 = -993;
  }
  else
  {
    *(_DWORD *)a2 = -995;
    *(void *)(a2 + 16) = v2 + 1;
    uint64_t v3 = *(void *)(result + 8);
  }
  *(void *)(a2 + 80) = v3;
  return result;
}

void *sub_100568A50(void *a1)
{
  *a1 = off_1019E3B28;
  uint64_t v2 = a1[1];
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  return a1;
}

void sub_100568ABC(void *a1)
{
  *a1 = off_1019E3B28;
  uint64_t v1 = a1[1];
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }

  operator delete();
}

uint64_t sub_100568B48(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(unsigned __int8 **)(a2 + 16);
  if (v2 == *(unsigned __int8 **)(a2 + 24) || *v2 != *(unsigned __int8 *)(result + 16))
  {
    uint64_t v3 = 0;
    *(_DWORD *)a2 = -993;
  }
  else
  {
    *(_DWORD *)a2 = -995;
    *(void *)(a2 + 16) = v2 + 1;
    uint64_t v3 = *(void *)(result + 8);
  }
  *(void *)(a2 + 80) = v3;
  return result;
}

std::locale *sub_100568B90(std::locale *a1)
{
  a1->__locale_ = (std::locale::__imp *)off_1019E3D98;
  std::locale::~locale(a1 + 2);
  a1->__locale_ = (std::locale::__imp *)off_1019E3B28;
  locale = a1[1].__locale_;
  if (locale) {
    (*(void (**)(std::locale::__imp *))(*(void *)locale + 8))(locale);
  }
  return a1;
}

void sub_100568C1C(std::locale *a1)
{
  a1->__locale_ = (std::locale::__imp *)off_1019E3D98;
  std::locale::~locale(a1 + 2);
  a1->__locale_ = (std::locale::__imp *)off_1019E3B28;
  locale = a1[1].__locale_;
  if (locale) {
    (*(void (**)(std::locale::__imp *))(*(void *)locale + 8))(locale);
  }

  operator delete();
}

uint64_t sub_100568CC8(uint64_t result, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 32) + 24 * (*(_DWORD *)(result + 40) - 1);
  if (*(unsigned char *)(v3 + 16))
  {
    uint64_t v4 = *(void *)(v3 + 8) - *(void *)v3;
    uint64_t v5 = *(void *)(a2 + 16);
    if (*(void *)(a2 + 24) - v5 >= v4)
    {
      uint64_t v7 = result;
      if (v4 < 1)
      {
LABEL_9:
        *(_DWORD *)a2 = -994;
        *(void *)(a2 + 16) = v5 + v4;
        uint64_t v6 = *(void *)(v7 + 8);
        goto LABEL_10;
      }
      uint64_t v8 = 0;
      while (1)
      {
        int v9 = (*(uint64_t (**)(void, void))(**(void **)(v7 + 24) + 40))(*(void *)(v7 + 24), *(char *)(*(void *)v3 + v8));
        uint64_t result = (*(uint64_t (**)(void, void))(**(void **)(v7 + 24) + 40))(*(void *)(v7 + 24), *(char *)(*(void *)(a2 + 16) + v8));
        if (v9 != result) {
          break;
        }
        if (v4 == ++v8)
        {
          uint64_t v5 = *(void *)(a2 + 16);
          goto LABEL_9;
        }
      }
    }
  }
  uint64_t v6 = 0;
  *(_DWORD *)a2 = -993;
LABEL_10:
  *(void *)(a2 + 80) = v6;
  return result;
}

std::locale *sub_100568DE0(std::locale *a1)
{
  a1->__locale_ = (std::locale::__imp *)off_1019E3DE0;
  std::locale::~locale(a1 + 2);
  a1->__locale_ = (std::locale::__imp *)off_1019E3B28;
  locale = a1[1].__locale_;
  if (locale) {
    (*(void (**)(std::locale::__imp *))(*(void *)locale + 8))(locale);
  }
  return a1;
}

void sub_100568E6C(std::locale *a1)
{
  a1->__locale_ = (std::locale::__imp *)off_1019E3DE0;
  std::locale::~locale(a1 + 2);
  a1->__locale_ = (std::locale::__imp *)off_1019E3B28;
  locale = a1[1].__locale_;
  if (locale) {
    (*(void (**)(std::locale::__imp *))(*(void *)locale + 8))(locale);
  }

  operator delete();
}

uint64_t sub_100568F18(uint64_t result, uint64_t a2)
{
  unsigned int v2 = *(_DWORD *)(result + 40) - 1;
  uint64_t v3 = *(void *)(a2 + 32);
  if (*(unsigned char *)(v3 + 24 * v2 + 16))
  {
    uint64_t v4 = (unsigned __int8 **)(v3 + 24 * v2);
    uint64_t v5 = *v4;
    uint64_t v6 = v4[1] - *v4;
    uint64_t v7 = *(void *)(a2 + 16);
    if (*(void *)(a2 + 24) - v7 >= v6)
    {
      if (v6 < 1)
      {
LABEL_8:
        *(_DWORD *)a2 = -994;
        *(void *)(a2 + 16) = v7 + v6;
        uint64_t v8 = *(void *)(result + 8);
        goto LABEL_9;
      }
      uint64_t v9 = v6;
      unsigned __int8 v10 = *(unsigned __int8 **)(a2 + 16);
      while (1)
      {
        int v12 = *v5++;
        int v11 = v12;
        int v13 = *v10++;
        if (v11 != v13) {
          break;
        }
        if (!--v9) {
          goto LABEL_8;
        }
      }
    }
  }
  uint64_t v8 = 0;
  *(_DWORD *)a2 = -993;
LABEL_9:
  *(void *)(a2 + 80) = v8;
  return result;
}

void *sub_100568FA8(void *a1)
{
  *a1 = off_1019E3B28;
  uint64_t v2 = a1[1];
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  return a1;
}

void sub_100569014(void *a1)
{
  *a1 = off_1019E3B28;
  uint64_t v1 = a1[1];
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }

  operator delete();
}

unsigned int *sub_1005690A0(unsigned int *result, uint64_t a2)
{
  unint64_t v2 = result[4];
  uint64_t v3 = *(void *)(a2 + 32);
  if (0xAAAAAAAAAAAAAAABLL * ((*(void *)(a2 + 40) - v3) >> 3) < v2) {
    sub_100568488();
  }
  unsigned int v5 = v2 - 1;
  if (*(unsigned char *)(v3 + 24 * v5 + 16)
    && (uint64_t v6 = result,
        uint64_t v7 = v3 + 24 * v5,
        uint64_t result = *(unsigned int **)v7,
        int64_t v8 = *(void *)(v7 + 8) - *(void *)v7,
        uint64_t v9 = *(void *)(a2 + 16),
        *(void *)(a2 + 24) - v9 >= v8)
    && (uint64_t result = (unsigned int *)memcmp(result, *(const void **)(a2 + 16), v8), !result))
  {
    *(_DWORD *)a2 = -994;
    *(void *)(a2 + 16) = v9 + v8;
    uint64_t v10 = *((void *)v6 + 1);
  }
  else
  {
    uint64_t v10 = 0;
    *(_DWORD *)a2 = -993;
  }
  *(void *)(a2 + 80) = v10;
  return result;
}

void sub_100569160()
{
}

void sub_1005691D8()
{
}

void sub_1005691FC(uint64_t a1, uint64_t a2)
{
  char v2 = a2;
  if (*(unsigned char *)(a1 + 169))
  {
    char v2 = (*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24), a2);
    unsigned int v5 = *(unsigned char **)(a1 + 48);
    unint64_t v4 = *(void *)(a1 + 56);
    if ((unint64_t)v5 >= v4)
    {
      uint64_t v6 = (unint64_t *)(a1 + 40);
      unint64_t v7 = *(void *)(a1 + 40);
      int64_t v8 = &v5[-v7];
      uint64_t v9 = (uint64_t)&v5[-v7 + 1];
      if (v9 >= 0)
      {
        unint64_t v10 = v4 - v7;
        if (2 * v10 > v9) {
          uint64_t v9 = 2 * v10;
        }
        if (v10 >= 0x3FFFFFFFFFFFFFFFLL) {
          size_t v11 = 0x7FFFFFFFFFFFFFFFLL;
        }
        else {
          size_t v11 = v9;
        }
        if (v11) {
          int v12 = operator new(v11);
        }
        else {
          int v12 = 0;
        }
        unsigned int v20 = &v8[(void)v12];
        long long v21 = (char *)v12 + v11;
        v8[(void)v12] = v2;
        uint64_t v19 = (uint64_t)&v8[(void)v12 + 1];
        if (v5 != (unsigned char *)v7)
        {
          long long v22 = &v5[~v7];
          do
          {
            char v23 = *--v5;
            (v22--)[(void)v12] = v23;
          }
          while (v5 != (unsigned char *)v7);
LABEL_45:
          unsigned int v5 = (unsigned char *)*v6;
          goto LABEL_47;
        }
        goto LABEL_46;
      }
LABEL_50:
      sub_100205700();
    }
    goto LABEL_22;
  }
  uint64_t v6 = (unint64_t *)(a1 + 40);
  unsigned int v5 = *(unsigned char **)(a1 + 48);
  unint64_t v13 = *(void *)(a1 + 56);
  if (!*(unsigned char *)(a1 + 170))
  {
    if ((unint64_t)v5 >= v13)
    {
      unint64_t v24 = *v6;
      uint64_t v25 = &v5[-*v6];
      unint64_t v26 = (unint64_t)(v25 + 1);
      if ((uint64_t)(v25 + 1) >= 0)
      {
        unint64_t v27 = v13 - v24;
        if (2 * v27 > v26) {
          unint64_t v26 = 2 * v27;
        }
        if (v27 >= 0x3FFFFFFFFFFFFFFFLL) {
          size_t v28 = 0x7FFFFFFFFFFFFFFFLL;
        }
        else {
          size_t v28 = v26;
        }
        if (v28) {
          int v12 = operator new(v28);
        }
        else {
          int v12 = 0;
        }
        unsigned int v20 = &v25[(void)v12];
        long long v21 = (char *)v12 + v28;
        v25[(void)v12] = v2;
        uint64_t v19 = (uint64_t)&v25[(void)v12 + 1];
        if (v5 != (unsigned char *)v24)
        {
          int64_t v31 = &v5[~v24];
          do
          {
            char v32 = *--v5;
            (v31--)[(void)v12] = v32;
          }
          while (v5 != (unsigned char *)v24);
          goto LABEL_45;
        }
        goto LABEL_46;
      }
      goto LABEL_50;
    }
LABEL_22:
    unsigned char *v5 = v2;
    uint64_t v19 = (uint64_t)(v5 + 1);
    goto LABEL_49;
  }
  if ((unint64_t)v5 < v13) {
    goto LABEL_22;
  }
  unint64_t v14 = *v6;
  long long v15 = &v5[-*v6];
  unint64_t v16 = (unint64_t)(v15 + 1);
  if ((uint64_t)(v15 + 1) < 0) {
    goto LABEL_50;
  }
  unint64_t v17 = v13 - v14;
  if (2 * v17 > v16) {
    unint64_t v16 = 2 * v17;
  }
  if (v17 >= 0x3FFFFFFFFFFFFFFFLL) {
    size_t v18 = 0x7FFFFFFFFFFFFFFFLL;
  }
  else {
    size_t v18 = v16;
  }
  if (v18) {
    int v12 = operator new(v18);
  }
  else {
    int v12 = 0;
  }
  unsigned int v20 = &v15[(void)v12];
  long long v21 = (char *)v12 + v18;
  v15[(void)v12] = v2;
  uint64_t v19 = (uint64_t)&v15[(void)v12 + 1];
  if (v5 != (unsigned char *)v14)
  {
    std::string v29 = &v5[~v14];
    do
    {
      char v30 = *--v5;
      (v29--)[(void)v12] = v30;
    }
    while (v5 != (unsigned char *)v14);
    goto LABEL_45;
  }
LABEL_46:
  int v12 = v20;
LABEL_47:
  *(void *)(a1 + 40) = v12;
  *(void *)(a1 + 48) = v19;
  *(void *)(a1 + 56) = v21;
  if (v5) {
    operator delete(v5);
  }
LABEL_49:
  *(void *)(a1 + 48) = v19;
}

uint64_t sub_100569444(uint64_t a1, uint64_t a2, uint64_t a3, char a4, char a5, char a6)
{
  *(void *)a1 = off_1019E3E70;
  *(void *)(a1 + 8) = a3;
  size_t v11 = (const std::locale *)(a1 + 16);
  std::locale::locale((std::locale *)(a1 + 16), (const std::locale *)a2);
  *(_OWORD *)(a1 + 24) = *(_OWORD *)(a2 + 8);
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 104) = 0u;
  *(_OWORD *)(a1 + 120) = 0u;
  *(_OWORD *)(a1 + 136) = 0u;
  *(_OWORD *)(a1 + 152) = 0u;
  *(unsigned char *)(a1 + 168) = a4;
  *(unsigned char *)(a1 + 169) = a5;
  *(unsigned char *)(a1 + 170) = a6;
  std::locale::locale(&v16, v11);
  std::locale::name(&v17, &v16);
  std::string::size_type size = HIBYTE(v17.__r_.__value_.__r.__words[2]);
  if ((v17.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
    std::string::size_type size = v17.__r_.__value_.__l.__size_;
  }
  if (size == 1)
  {
    unint64_t v13 = (std::string *)v17.__r_.__value_.__r.__words[0];
    if ((v17.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      unint64_t v13 = &v17;
    }
    BOOL v14 = v13->__r_.__value_.__s.__data_[0] != 67;
    if (SHIBYTE(v17.__r_.__value_.__r.__words[2]) < 0) {
      goto LABEL_9;
    }
  }
  else
  {
    BOOL v14 = 1;
    if (SHIBYTE(v17.__r_.__value_.__r.__words[2]) < 0) {
LABEL_9:
    }
      operator delete(v17.__r_.__value_.__l.__data_);
  }
  std::locale::~locale(&v16);
  *(unsigned char *)(a1 + 171) = v14;
  return a1;
}

void sub_100569590(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10)
{
  std::locale::~locale((std::locale *)&a9);
  a10 = v10 + 17;
  sub_100047F64((void ***)&a10);
  long long v15 = (void *)v10[14];
  if (v15)
  {
    v10[15] = v15;
    operator delete(v15);
  }
  sub_100155410((void ***)&a10);
  std::locale v16 = (void *)v10[8];
  if (v16)
  {
    v10[9] = v16;
    operator delete(v16);
  }
  std::string v17 = *v13;
  if (*v13)
  {
    v10[6] = v17;
    operator delete(v17);
  }
  std::locale::~locale(v12);
  void *v10 = v11;
  uint64_t v18 = v10[1];
  if (v18) {
    (*(void (**)(uint64_t))(*(void *)v18 + 8))(v18);
  }
  _Unwind_Resume(a1);
}

void sub_10056962C(std::locale *a1)
{
  sub_100569E8C(a1);

  operator delete();
}

void sub_100569664(uint64_t a1, uint64_t a2)
{
  unint64_t v4 = *(signed __int8 **)(a2 + 16);
  unsigned int v5 = *(signed __int8 **)(a2 + 24);
  if (v4 == v5)
  {
    uint64_t v17 = 0;
    int v18 = *(unsigned __int8 *)(a1 + 168);
LABEL_156:
    int v82 = v18;
    goto LABEL_157;
  }
  if (!*(unsigned char *)(a1 + 171) || v4 + 1 == v5) {
    goto LABEL_27;
  }
  signed __int8 v6 = *v4;
  unsigned __int8 v86 = *v4;
  signed __int8 v7 = v4[1];
  unsigned __int8 v87 = v7;
  if (*(unsigned char *)(a1 + 169))
  {
    unsigned __int8 v86 = (*(uint64_t (**)(void, void))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24), v6);
    unsigned __int8 v87 = (*(uint64_t (**)(void, void))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24), v7);
  }
  sub_10056A034(a1 + 16, (char *)&v86, (char *)&v88, (uint64_t)&__p);
  if ((SHIBYTE(v85) & 0x80000000) == 0)
  {
    if (HIBYTE(v85)) {
      goto LABEL_8;
    }
LABEL_27:
    int v82 = 0;
    uint64_t v17 = 1;
    goto LABEL_28;
  }
  size_t v19 = v84;
  operator delete(__p);
  if (!v19) {
    goto LABEL_27;
  }
LABEL_8:
  uint64_t v8 = *(void *)(a1 + 112);
  uint64_t v9 = *(void *)(a1 + 120) - v8;
  if (v9)
  {
    uint64_t v10 = v9 >> 1;
    if ((unint64_t)(v9 >> 1) <= 1) {
      uint64_t v10 = 1;
    }
    uint64_t v11 = (unsigned char *)(v8 + 1);
    do
    {
      if (v86 == *(v11 - 1) && v87 == *v11) {
        goto LABEL_164;
      }
      v11 += 2;
      --v10;
    }
    while (v10);
  }
  if (!*(unsigned char *)(a1 + 170) || *(void *)(a1 + 88) == *(void *)(a1 + 96))
  {
    int v82 = 0;
LABEL_99:
    if (*(void *)(a1 + 136) == *(void *)(a1 + 144)) {
      goto LABEL_129;
    }
    std::string __p = 0;
    size_t v84 = 0;
    uint64_t v85 = 0;
    sub_10056A1EC(a1 + 16, (char *)&v86, (char *)&v88, (uint64_t *)&__p);
    uint64_t v52 = *(void *)(a1 + 136);
    uint64_t v53 = HIBYTE(v85);
    uint64_t v54 = *(void *)(a1 + 144) - v52;
    if (!v54)
    {
LABEL_127:
      if ((v53 & 0x80) != 0) {
LABEL_128:
      }
        operator delete(__p);
      goto LABEL_129;
    }
    unint64_t v55 = 0;
    unint64_t v56 = v54 / 24;
    std::locale v57 = __p;
    size_t v58 = v84;
    if (v85 >= 0) {
      size_t v59 = HIBYTE(v85);
    }
    else {
      size_t v59 = v84;
    }
    if (v56 <= 1) {
      uint64_t v60 = 1;
    }
    else {
      uint64_t v60 = v54 / 24;
    }
    for (BOOL i = 1; ; BOOL i = v55 < v56)
    {
      uint64_t v62 = v52 + 24 * v55;
      uint64_t v63 = *(unsigned __int8 *)(v62 + 23);
      int v64 = (char)v63;
      if ((v63 & 0x80u) != 0) {
        uint64_t v63 = *(void *)(v62 + 8);
      }
      if (v59 != v63) {
        goto LABEL_120;
      }
      uint64_t v65 = v64 >= 0 ? (unsigned __int8 *)(v52 + 24 * v55) : *(unsigned __int8 **)v62;
      if ((v53 & 0x80) == 0) {
        break;
      }
      BOOL v81 = i;
      uint64_t v67 = v60;
      uint64_t v68 = v57;
      size_t v69 = v58;
      if (!memcmp(v57, v65, v58))
      {
        operator delete(__p);
        if (v81) {
          goto LABEL_164;
        }
LABEL_126:
        int v82 = 1;
LABEL_129:
        if ((char)v86 < 0)
        {
          int v73 = *(_DWORD *)(a1 + 164);
          goto LABEL_142;
        }
        int v70 = *(_DWORD *)(a1 + 160);
        uint64_t v71 = *(void *)(*(void *)(a1 + 24) + 16);
        int v72 = *(_DWORD *)(v71 + 4 * v86);
        if ((v72 & v70) == 0 && (v86 != 95 || (v70 & 0x80) == 0)
          || (char)v87 < 0
          || (*(_DWORD *)(v71 + 4 * v87) & v70) == 0 && ((v70 & 0x80) == 0 || v87 != 95))
        {
          int v73 = *(_DWORD *)(a1 + 164);
          if ((v73 & v72) != 0 || v86 == 95 && (v73 & 0x80) != 0) {
            goto LABEL_146;
          }
LABEL_142:
          if ((char)v87 < 0) {
            goto LABEL_164;
          }
          if ((*(_DWORD *)(*(void *)(*(void *)(a1 + 24) + 16) + 4 * v87) & v73) != 0
            || (int v74 = 1, v87 == 95) && (v73 & 0x80) != 0)
          {
LABEL_146:
            int v74 = v82;
          }
LABEL_165:
          int v82 = v74;
LABEL_166:
          uint64_t v17 = 2;
          goto LABEL_157;
        }
LABEL_164:
        int v74 = 1;
        goto LABEL_165;
      }
      ++v55;
      uint64_t v60 = v67;
      size_t v58 = v69;
      std::locale v57 = v68;
      if (v55 == v67) {
        goto LABEL_128;
      }
LABEL_124:
      ;
    }
    if (!v53)
    {
LABEL_125:
      if (i) {
        goto LABEL_164;
      }
      goto LABEL_126;
    }
    uint64_t v66 = 0;
    while (*((unsigned __int8 *)&__p + v66) == v65[v66])
    {
      if (v53 == ++v66) {
        goto LABEL_125;
      }
    }
LABEL_120:
    if (++v55 == v60) {
      goto LABEL_127;
    }
    goto LABEL_124;
  }
  std::string __p = 0;
  size_t v84 = 0;
  uint64_t v85 = 0;
  sub_100569F74(a1 + 16, (char *)&v86, (char *)&v88);
  uint64_t v13 = *(void *)(a1 + 88);
  if (*(void *)(a1 + 96) == v13)
  {
LABEL_24:
    int v82 = 0;
    char v16 = 1;
  }
  else
  {
    unint64_t v14 = 0;
    uint64_t v15 = 24;
    while ((int)(sub_100046FE8((void *)(v13 + v15 - 24), &__p) << 24) > 0xFFFFFF
         || (int)(sub_100046FE8(&__p, (void **)(*(void *)(a1 + 88) + v15)) << 24) >= 0x1000000)
    {
      ++v14;
      uint64_t v13 = *(void *)(a1 + 88);
      v15 += 48;
      if (v14 >= 0xAAAAAAAAAAAAAAABLL * ((*(void *)(a1 + 96) - v13) >> 4)) {
        goto LABEL_24;
      }
    }
    char v16 = 0;
    int v82 = 1;
  }
  if (SHIBYTE(v85) < 0) {
    operator delete(__p);
  }
  if ((v82 & 1) == 0) {
    goto LABEL_99;
  }
  if ((v16 & 1) == 0) {
    goto LABEL_166;
  }
  uint64_t v17 = 2;
LABEL_28:
  unsigned __int8 v20 = **(unsigned char **)(a2 + 16);
  unsigned __int8 v86 = v20;
  if (*(unsigned char *)(a1 + 169))
  {
    unsigned __int8 v20 = (*(uint64_t (**)(void, void))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24), (char)v20);
    unsigned __int8 v86 = v20;
  }
  long long v21 = *(unsigned __int8 **)(a1 + 40);
  unint64_t v22 = *(void *)(a1 + 48) - (void)v21;
  if (v22)
  {
    if (v22 <= 1) {
      unint64_t v22 = 1;
    }
    do
    {
      int v23 = *v21++;
      if (v23 == v20) {
        goto LABEL_155;
      }
    }
    while (--v22);
  }
  unsigned int v24 = *(_DWORD *)(a1 + 164);
  if (v24 || *(void *)(a1 + 64) != *(void *)(a1 + 72))
  {
    if ((v20 & 0x80) != 0 || (*(_DWORD *)(*(void *)(*(void *)(a1 + 24) + 16) + 4 * v20) & v24) == 0)
    {
      int v26 = (v24 >> 7) & 1;
      char v25 = v20 == 95 ? v26 : 0;
    }
    else
    {
      char v25 = 1;
    }
    unint64_t v27 = *(void **)(a1 + 72);
    size_t v28 = memchr(*(void **)(a1 + 64), (char)v20, (size_t)v27 - *(void *)(a1 + 64));
    std::string v29 = v28 ? v28 : v27;
    if ((v25 & 1) == 0 && v29 == v27)
    {
LABEL_155:
      int v18 = 1;
      goto LABEL_156;
    }
  }
  uint64_t v30 = *(void *)(a1 + 88);
  uint64_t v31 = *(void *)(a1 + 96);
  if (v30 != v31)
  {
    std::string __p = 0;
    size_t v84 = 0;
    uint64_t v85 = 0;
    if (*(unsigned char *)(a1 + 170))
    {
      sub_100569F74(a1 + 16, (char *)&v86, (char *)&v87);
      uint64_t v30 = *(void *)(a1 + 88);
      uint64_t v31 = *(void *)(a1 + 96);
    }
    else
    {
      HIBYTE(v85) = 1;
      LOWORD(__p) = v20;
    }
    if (v31 == v30)
    {
LABEL_58:
      char v34 = 0;
    }
    else
    {
      unint64_t v32 = 0;
      uint64_t v33 = 24;
      while ((int)(sub_100046FE8((void *)(v30 + v33 - 24), &__p) << 24) > 0xFFFFFF
           || (int)(sub_100046FE8(&__p, (void **)(*(void *)(a1 + 88) + v33)) << 24) >= 0x1000000)
      {
        ++v32;
        uint64_t v30 = *(void *)(a1 + 88);
        v33 += 48;
        if (v32 >= 0xAAAAAAAAAAAAAAABLL * ((*(void *)(a1 + 96) - v30) >> 4)) {
          goto LABEL_58;
        }
      }
      char v34 = 1;
      int v82 = 1;
    }
    if (SHIBYTE(v85) < 0) {
      operator delete(__p);
    }
    if (v34) {
      goto LABEL_157;
    }
  }
  if (*(void *)(a1 + 136) == *(void *)(a1 + 144))
  {
LABEL_150:
    if ((char)v86 < 0) {
      goto LABEL_157;
    }
    unsigned int v75 = *(_DWORD *)(a1 + 160);
    if ((*(_DWORD *)(*(void *)(*(void *)(a1 + 24) + 16) + 4 * v86) & v75) == 0)
    {
      int v76 = (v75 >> 7) & 1;
      if (v86 != 95) {
        int v76 = 0;
      }
      if (v76 != 1) {
        goto LABEL_157;
      }
    }
    goto LABEL_155;
  }
  std::string __p = 0;
  size_t v84 = 0;
  uint64_t v85 = 0;
  sub_10056A1EC(a1 + 16, (char *)&v86, (char *)&v87, (uint64_t *)&__p);
  uint64_t v35 = *(void *)(a1 + 136);
  uint64_t v36 = HIBYTE(v85);
  uint64_t v37 = *(void *)(a1 + 144) - v35;
  if (!v37)
  {
    if (v85 < 0) {
      operator delete(__p);
    }
    goto LABEL_150;
  }
  uint64_t v80 = v17;
  unint64_t v38 = 0;
  unint64_t v39 = v37 / 24;
  long long v40 = __p;
  size_t v41 = v84;
  if (v85 >= 0) {
    size_t v42 = HIBYTE(v85);
  }
  else {
    size_t v42 = v84;
  }
  if (v39 <= 1) {
    uint64_t v43 = 1;
  }
  else {
    uint64_t v43 = v37 / 24;
  }
  for (BOOL j = 1; ; BOOL j = v38 < v39)
  {
    std::string::size_type v45 = (unsigned __int8 **)(v35 + 24 * v38);
    std::string v46 = (unsigned __int8 *)*((unsigned __int8 *)v45 + 23);
    int v47 = (char)v46;
    if ((char)v46 < 0) {
      std::string v46 = v45[1];
    }
    if ((unsigned __int8 *)v42 == v46) {
      break;
    }
LABEL_84:
    if (++v38 == v43)
    {
      if ((v36 & 0x80) != 0) {
LABEL_148:
      }
        operator delete(__p);
      uint64_t v17 = v80;
      goto LABEL_150;
    }
LABEL_88:
    ;
  }
  if (v47 >= 0) {
    long long v48 = (unsigned __int8 *)(v35 + 24 * v38);
  }
  else {
    long long v48 = *v45;
  }
  if ((v36 & 0x80) == 0)
  {
    if (!v36)
    {
LABEL_89:
      int v82 = 1;
      uint64_t v17 = v80;
      if (!j) {
        goto LABEL_150;
      }
      goto LABEL_157;
    }
    uint64_t v49 = 0;
    while (*((unsigned __int8 *)&__p + v49) == v48[v49])
    {
      if (v36 == ++v49) {
        goto LABEL_89;
      }
    }
    goto LABEL_84;
  }
  BOOL v79 = j;
  int v50 = v40;
  size_t v51 = v41;
  if (memcmp(v40, v48, v41))
  {
    ++v38;
    size_t v41 = v51;
    long long v40 = v50;
    if (v38 == v43) {
      goto LABEL_148;
    }
    goto LABEL_88;
  }
  operator delete(__p);
  int v82 = 1;
  uint64_t v17 = v80;
  if (!v79) {
    goto LABEL_150;
  }
LABEL_157:
  if (v82 == *(unsigned __int8 *)(a1 + 168))
  {
    uint64_t v77 = 0;
    int v78 = -993;
  }
  else
  {
    *(void *)(a2 + 16) += v17;
    uint64_t v77 = *(void *)(a1 + 8);
    int v78 = -995;
  }
  *(_DWORD *)a2 = v78;
  *(void *)(a2 + 80) = v77;
}

std::locale *sub_100569E8C(std::locale *a1)
{
  a1->__locale_ = (std::locale::__imp *)off_1019E3E70;
  signed __int8 v7 = a1 + 17;
  sub_100047F64((void ***)&v7);
  locale = a1[14].__locale_;
  if (locale)
  {
    a1[15].__locale_ = locale;
    operator delete(locale);
  }
  signed __int8 v7 = a1 + 11;
  sub_100155410((void ***)&v7);
  uint64_t v3 = a1[8].__locale_;
  if (v3)
  {
    a1[9].__locale_ = v3;
    operator delete(v3);
  }
  unint64_t v4 = a1[5].__locale_;
  if (v4)
  {
    a1[6].__locale_ = v4;
    operator delete(v4);
  }
  std::locale::~locale(a1 + 2);
  a1->__locale_ = (std::locale::__imp *)off_1019E3B28;
  unsigned int v5 = a1[1].__locale_;
  if (v5) {
    (*(void (**)(std::locale::__imp *))(*(void *)v5 + 8))(v5);
  }
  return a1;
}

void sub_100569F74(uint64_t a1, char *a2, char *a3)
{
  std::string __p = 0;
  uint64_t v7 = 0;
  uint64_t v8 = 0;
  sub_10012CD04(&__p, a2, a3, a3 - a2);
  uint64_t v4 = HIBYTE(v8);
  if (v8 >= 0) {
    p_p = (char *)&__p;
  }
  else {
    p_p = (char *)__p;
  }
  if (v8 < 0) {
    uint64_t v4 = v7;
  }
  (*(void (**)(void, char *, char *))(**(void **)(a1 + 16) + 32))(*(void *)(a1 + 16), p_p, &p_p[v4]);
  if (SHIBYTE(v8) < 0) {
    operator delete(__p);
  }
}

void sub_10056A018(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_10056A034(uint64_t a1@<X0>, char *a2@<X1>, char *a3@<X2>, uint64_t a4@<X8>)
{
  memset(&__s, 0, sizeof(__s));
  sub_10012CD04(&__s, a2, a3, a3 - a2);
  *(void *)a4 = 0;
  *(void *)(a4 + 8) = 0;
  *(void *)(a4 + 16) = 0;
  if (SHIBYTE(__s.__r_.__value_.__r.__words[2]) < 0)
  {
    if (!__s.__r_.__value_.__l.__size_) {
      goto LABEL_9;
    }
    p_s = (std::string *)__s.__r_.__value_.__r.__words[0];
  }
  else
  {
    if (!*((unsigned char *)&__s.__r_.__value_.__s + 23)) {
      return;
    }
    p_s = &__s;
  }
  std::__get_collation_name(&v11, (const char *)p_s);
  *(_OWORD *)a4 = *(_OWORD *)&v11.__r_.__value_.__l.__data_;
  unint64_t v7 = v11.__r_.__value_.__r.__words[2];
  *(void *)(a4 + 16) = *((void *)&v11.__r_.__value_.__l + 2);
  unint64_t v8 = HIBYTE(v7);
  if ((v8 & 0x80u) != 0) {
    unint64_t v8 = *(void *)(a4 + 8);
  }
  if (v8) {
    goto LABEL_9;
  }
  if (SHIBYTE(__s.__r_.__value_.__r.__words[2]) < 0)
  {
    if (__s.__r_.__value_.__l.__size_ >= 3) {
      goto LABEL_9;
    }
  }
  else if (HIBYTE(__s.__r_.__value_.__r.__words[2]) >= 3u)
  {
    return;
  }
  (*(void (**)(std::string *__return_ptr))(**(void **)(a1 + 16) + 32))(&v11);
  if (*(char *)(a4 + 23) < 0) {
    operator delete(*(void **)a4);
  }
  *(std::string *)a4 = v11;
  if ((*(char *)(a4 + 23) & 0x80000000) == 0)
  {
    int v9 = *(unsigned __int8 *)(a4 + 23);
    if (v9 != 12 && v9 != 1)
    {
      *(unsigned char *)a4 = 0;
      *(unsigned char *)(a4 + 23) = 0;
      goto LABEL_9;
    }
    goto LABEL_23;
  }
  uint64_t v10 = *(void *)(a4 + 8);
  if (v10 == 1 || v10 == 12)
  {
LABEL_23:
    std::string::operator=((std::string *)a4, &__s);
    goto LABEL_9;
  }
  **(unsigned char **)a4 = 0;
  *(void *)(a4 + 8) = 0;
LABEL_9:
  if (SHIBYTE(__s.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__s.__r_.__value_.__l.__data_);
  }
}

void sub_10056A1B8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (*(char *)(v17 + 23) < 0) {
    operator delete(*(void **)v17);
  }
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_10056A1EC(uint64_t a1@<X0>, char *a2@<X1>, char *a3@<X2>, uint64_t *a4@<X8>)
{
  std::string __p = 0;
  uint64_t v12 = 0;
  uint64_t v13 = 0;
  sub_10012CD04(&__p, a2, a3, a3 - a2);
  *a4 = 0;
  a4[1] = 0;
  a4[2] = 0;
  uint64_t v6 = HIBYTE(v13);
  if (v13 >= 0) {
    p_p = (char *)&__p;
  }
  else {
    p_p = (char *)__p;
  }
  if (v13 < 0) {
    uint64_t v6 = v12;
  }
  (*(void (**)(void, char *, char *))(**(void **)(a1 + 16) + 32))(*(void *)(a1 + 16), p_p, &p_p[v6]);
  uint64_t v8 = *((unsigned __int8 *)a4 + 23);
  int v9 = (char)v8;
  if ((v8 & 0x80u) != 0) {
    uint64_t v8 = a4[1];
  }
  if (v8 != 1)
  {
    if (v8 == 12)
    {
      if (v9 >= 0) {
        uint64_t v10 = a4;
      }
      else {
        uint64_t v10 = (uint64_t *)*a4;
      }
      *((unsigned char *)v10 + 11) = *((unsigned char *)v10 + 3);
    }
    else if (v9 < 0)
    {
      *(unsigned char *)*a4 = 0;
      a4[1] = 0;
    }
    else
    {
      *(unsigned char *)a4 = 0;
      *((unsigned char *)a4 + 23) = 0;
    }
  }
  if (SHIBYTE(v13) < 0) {
    operator delete(__p);
  }
}

void sub_10056A2F0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_10056A30C()
{
  exception = (std::regex_error *)__cxa_allocate_exception(0x18uLL);
  std::regex_error::regex_error(exception, error_brack);
}

void sub_10056A350(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

char *sub_10056A364(uint64_t a1, char *a2, char *a3, uint64_t a4)
{
  if (a3 - a2 < 2 || a3 - 1 == a2) {
    goto LABEL_15;
  }
  unsigned int v5 = a3 - 2;
  uint64_t v6 = a2;
  unint64_t v7 = a2;
  for (i = a2; ; unint64_t v7 = i)
  {
    int v9 = *i++;
    if (v9 == 46 && *i == 93) {
      break;
    }
    if (a2 == v5) {
      goto LABEL_15;
    }
    ++v6;
    --v5;
  }
  if (v7 == a3) {
LABEL_15:
  }
    sub_10056A30C();
  sub_10056AFF4((uint64_t)&v13, a1, a2, v6);
  if (*(char *)(a4 + 23) < 0) {
    operator delete(*(void **)a4);
  }
  *(_OWORD *)a4 = v13;
  unint64_t v10 = v14;
  *(void *)(a4 + 16) = v14;
  unint64_t v11 = HIBYTE(v10);
  if ((v11 & 0x80u) != 0) {
    unint64_t v11 = *(void *)(a4 + 8);
  }
  if (v11 - 1 >= 2) {
    sub_10056AF58();
  }
  return v6 + 2;
}

unsigned __int8 *sub_10056A454(uint64_t a1, unsigned __int8 *a2, unsigned __int8 *a3, uint64_t a4, uint64_t a5)
{
  if (a2 == a3) {
    sub_100567EF4();
  }
  int v6 = (char)*a2;
  if (v6 > 97)
  {
    if (v6 > 114)
    {
      if (v6 != 115)
      {
        if (v6 != 119) {
          return sub_100567F4C(a1, a2, a3, (uint64_t *)a4);
        }
        *(_DWORD *)(a5 + 160) |= 0x500u;
        sub_1005691FC(a5, 95);
        return a2 + 1;
      }
      int v8 = *(_DWORD *)(a5 + 160) | 0x4000;
    }
    else
    {
      if (v6 == 98)
      {
        if (*(char *)(a4 + 23) < 0)
        {
          *(void *)(a4 + 8) = 1;
          a4 = *(void *)a4;
        }
        else
        {
          *(unsigned char *)(a4 + 23) = 1;
        }
        *(_WORD *)a4 = 8;
        return a2 + 1;
      }
      if (v6 != 100) {
        return sub_100567F4C(a1, a2, a3, (uint64_t *)a4);
      }
      int v8 = *(_DWORD *)(a5 + 160) | 0x400;
    }
    *(_DWORD *)(a5 + 160) = v8;
    return a2 + 1;
  }
  if (v6 <= 82)
  {
    if (!*a2)
    {
      if (*(char *)(a4 + 23) < 0)
      {
        *(void *)(a4 + 8) = 1;
        a4 = *(void *)a4;
      }
      else
      {
        *(unsigned char *)(a4 + 23) = 1;
      }
      *(unsigned char *)a4 = 0;
      *(unsigned char *)(a4 + 1) = 0;
      return a2 + 1;
    }
    if (v6 == 68)
    {
      int v7 = *(_DWORD *)(a5 + 164) | 0x400;
LABEL_22:
      *(_DWORD *)(a5 + 164) = v7;
      return a2 + 1;
    }
    return sub_100567F4C(a1, a2, a3, (uint64_t *)a4);
  }
  if (v6 == 83)
  {
    int v7 = *(_DWORD *)(a5 + 164) | 0x4000;
    goto LABEL_22;
  }
  if (v6 != 87) {
    return sub_100567F4C(a1, a2, a3, (uint64_t *)a4);
  }
  *(_DWORD *)(a5 + 164) |= 0x500u;
  sub_10056B330(a5, 95);
  return a2 + 1;
}

char *sub_10056A5B8(uint64_t a1, char *a2, char *a3, uint64_t *a4)
{
  if (a2 == a3) {
LABEL_78:
  }
    sub_100567EF4();
  int v4 = *a2;
  char v5 = *a2;
  if (v4 > 97)
  {
    switch(*a2)
    {
      case 'n':
        if (!a4) {
          goto LABEL_60;
        }
        if (*((char *)a4 + 23) < 0)
        {
          a4[1] = 1;
          a4 = (uint64_t *)*a4;
        }
        else
        {
          *((unsigned char *)a4 + 23) = 1;
        }
        __int16 v11 = 10;
        goto LABEL_75;
      case 'o':
      case 'p':
      case 'q':
      case 's':
      case 'u':
        goto LABEL_25;
      case 'r':
        if (!a4) {
          goto LABEL_60;
        }
        if (*((char *)a4 + 23) < 0)
        {
          a4[1] = 1;
          a4 = (uint64_t *)*a4;
        }
        else
        {
          *((unsigned char *)a4 + 23) = 1;
        }
        __int16 v11 = 13;
        goto LABEL_75;
      case 't':
        if (!a4) {
          goto LABEL_60;
        }
        if (*((char *)a4 + 23) < 0)
        {
          a4[1] = 1;
          a4 = (uint64_t *)*a4;
        }
        else
        {
          *((unsigned char *)a4 + 23) = 1;
        }
        __int16 v11 = 9;
        goto LABEL_75;
      case 'v':
        if (!a4) {
          goto LABEL_60;
        }
        if (*((char *)a4 + 23) < 0)
        {
          a4[1] = 1;
          a4 = (uint64_t *)*a4;
        }
        else
        {
          *((unsigned char *)a4 + 23) = 1;
        }
        __int16 v11 = 11;
        goto LABEL_75;
      default:
        if (v4 == 98)
        {
          if (!a4) {
            goto LABEL_60;
          }
          if (*((char *)a4 + 23) < 0)
          {
            a4[1] = 1;
            a4 = (uint64_t *)*a4;
          }
          else
          {
            *((unsigned char *)a4 + 23) = 1;
          }
          __int16 v11 = 8;
        }
        else
        {
          if (v4 != 102) {
            goto LABEL_25;
          }
          if (!a4) {
            goto LABEL_60;
          }
          if (*((char *)a4 + 23) < 0)
          {
            a4[1] = 1;
            a4 = (uint64_t *)*a4;
          }
          else
          {
            *((unsigned char *)a4 + 23) = 1;
          }
          __int16 v11 = 12;
        }
        break;
    }
    goto LABEL_75;
  }
  if (v4 > 91)
  {
    if (v4 == 92) {
      goto LABEL_16;
    }
    if (v4 != 97) {
      goto LABEL_25;
    }
    if (!a4) {
      goto LABEL_60;
    }
    if (*((char *)a4 + 23) < 0)
    {
      a4[1] = 1;
      a4 = (uint64_t *)*a4;
    }
    else
    {
      *((unsigned char *)a4 + 23) = 1;
    }
    __int16 v11 = 7;
LABEL_75:
    *(_WORD *)a4 = v11;
    return a2 + 1;
  }
  if (v4 == 34 || v4 == 47)
  {
LABEL_16:
    if (a4)
    {
      if (*((char *)a4 + 23) < 0)
      {
        a4[1] = 1;
        a4 = (uint64_t *)*a4;
      }
      else
      {
        *((unsigned char *)a4 + 23) = 1;
      }
      *(unsigned char *)a4 = v5;
      *((unsigned char *)a4 + 1) = 0;
      return a2 + 1;
    }
LABEL_60:
    sub_100568348(a1);
  }
LABEL_25:
  if ((v5 & 0xF8) != 0x30) {
    goto LABEL_78;
  }
  char v6 = v4 - 48;
  int v7 = a2 + 1;
  if (a2 + 1 == a3)
  {
LABEL_48:
    int v7 = a3;
    goto LABEL_49;
  }
  if ((*v7 & 0xF8) == 0x30)
  {
    char v6 = *v7 + 8 * v6 - 48;
    if (a2 + 2 != a3)
    {
      char v8 = a2[2];
      int v9 = v8 & 0xF8;
      char v10 = v8 + 8 * v6 - 48;
      if (v9 == 48) {
        int v7 = a2 + 3;
      }
      else {
        int v7 = a2 + 2;
      }
      if (v9 == 48) {
        char v6 = v10;
      }
      goto LABEL_49;
    }
    goto LABEL_48;
  }
LABEL_49:
  if (!a4) {
    sub_100568348(a1);
  }
  if (*((char *)a4 + 23) < 0)
  {
    a4[1] = 1;
    a4 = (uint64_t *)*a4;
  }
  else
  {
    *((unsigned char *)a4 + 23) = 1;
  }
  *(unsigned char *)a4 = v6;
  *((unsigned char *)a4 + 1) = 0;
  return v7;
}

void sub_10056A8D4(uint64_t a1, char *a2, char *a3)
{
  uint64_t v3 = a3;
  int v4 = a2;
  if (*(unsigned char *)(a1 + 170))
  {
    if (*(unsigned char *)(a1 + 169))
    {
      for (unint64_t i = 0; ; ++i)
      {
        unint64_t v7 = v4[23] < 0 ? *((void *)v4 + 1) : v4[23];
        if (i >= v7) {
          break;
        }
        char v8 = v4;
        if (v4[23] < 0) {
          char v8 = *(char **)v4;
        }
        char v9 = (*(uint64_t (**)(void, void))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24), v8[i]);
        char v10 = v4;
        if (v4[23] < 0) {
          char v10 = *(char **)v4;
        }
        v10[i] = v9;
      }
      for (unint64_t j = 0; ; ++j)
      {
        unint64_t v12 = v3[23] < 0 ? *((void *)v3 + 1) : v3[23];
        if (j >= v12) {
          break;
        }
        long long v13 = v3;
        if (v3[23] < 0) {
          long long v13 = *(char **)v3;
        }
        char v14 = (*(uint64_t (**)(void, void))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24), v13[j]);
        uint64_t v15 = v3;
        if (v3[23] < 0) {
          uint64_t v15 = *(char **)v3;
        }
        v15[j] = v14;
      }
    }
    else
    {
      for (unint64_t k = 0; ; ++k)
      {
        unint64_t v18 = a2[23] < 0 ? *((void *)a2 + 1) : a2[23];
        if (k >= v18) {
          break;
        }
        size_t v19 = a2;
        if (a2[23] < 0) {
          size_t v19 = *(char **)a2;
        }
        unsigned __int8 v20 = a2;
        if (a2[23] < 0) {
          unsigned __int8 v20 = *(char **)a2;
        }
        v20[k] = v19[k];
      }
      for (unint64_t m = 0; ; ++m)
      {
        unint64_t v22 = a3[23] < 0 ? *((void *)a3 + 1) : a3[23];
        if (m >= v22) {
          break;
        }
        int v23 = a3;
        if (a3[23] < 0) {
          int v23 = *(char **)a3;
        }
        unsigned int v24 = a3;
        if (a3[23] < 0) {
          unsigned int v24 = *(char **)a3;
        }
        v24[m] = v23[m];
      }
    }
    if (v4[23] < 0)
    {
      int v26 = v4;
      int v4 = *(char **)v4;
      uint64_t v25 = *((void *)v26 + 1);
    }
    else
    {
      uint64_t v25 = v4[23];
    }
    sub_10056B578(a1 + 16, v4, &v4[v25]);
    if (v3[23] < 0)
    {
      size_t v28 = v3;
      uint64_t v3 = *(char **)v3;
      uint64_t v27 = *((void *)v28 + 1);
    }
    else
    {
      uint64_t v27 = v3[23];
    }
    sub_10056B578(a1 + 16, v3, &v3[v27]);
    *(_OWORD *)long long v40 = v38;
    uint64_t v41 = v39;
    *(_OWORD *)std::string __p = *(_OWORD *)v36;
    uint64_t v43 = v37;
    sub_1002943D8((char **)(a1 + 88), (long long *)v40);
    if (SHIBYTE(v43) < 0) {
      operator delete(__p[0]);
    }
    if (SHIBYTE(v41) < 0) {
      operator delete(v40[0]);
    }
  }
  else
  {
    if (a2[23] < 0) {
      uint64_t v16 = *((void *)a2 + 1);
    }
    else {
      uint64_t v16 = a2[23];
    }
    if (v16 != 1 || (a3[23] < 0 ? (uint64_t v29 = *((void *)a3 + 1)) : (uint64_t v29 = a3[23]), v29 != 1)) {
      sub_10056B638();
    }
    if (*(unsigned char *)(a1 + 169))
    {
      uint64_t v30 = a2;
      if (a2[23] < 0) {
        uint64_t v30 = *(char **)a2;
      }
      char v31 = (*(uint64_t (**)(void, void))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24), *v30);
      unint64_t v32 = v4;
      if (v4[23] < 0) {
        unint64_t v32 = *(unsigned char **)v4;
      }
      *unint64_t v32 = v31;
      uint64_t v33 = v3;
      if (v3[23] < 0) {
        uint64_t v33 = *(char **)v3;
      }
      char v34 = (*(uint64_t (**)(void, void))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24), *v33);
      uint64_t v35 = v3;
      if (v3[23] < 0) {
        uint64_t v35 = *(unsigned char **)v3;
      }
      *uint64_t v35 = v34;
    }
    *(_OWORD *)long long v40 = *(_OWORD *)v4;
    uint64_t v41 = *((void *)v4 + 2);
    *((void *)v4 + 1) = 0;
    *((void *)v4 + 2) = 0;
    *(void *)int v4 = 0;
    *(_OWORD *)std::string __p = *(_OWORD *)v3;
    uint64_t v43 = *((void *)v3 + 2);
    *(void *)uint64_t v3 = 0;
    *((void *)v3 + 1) = 0;
    *((void *)v3 + 2) = 0;
    sub_1002943D8((char **)(a1 + 88), (long long *)v40);
    if (SHIBYTE(v43) < 0) {
      operator delete(__p[0]);
    }
    if (SHIBYTE(v41) < 0) {
      operator delete(v40[0]);
    }
  }
}

void sub_10056ACB0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,char a21)
{
}

void sub_10056ACFC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (!*(unsigned char *)(a1 + 169))
  {
    uint64_t v18 = a1 + 128;
    unint64_t v19 = *(void *)(a1 + 128);
    char v10 = (char **)(a1 + 112);
    __int16 v8 = a2 | (unsigned __int16)((_WORD)a3 << 8);
    char v9 = *(_WORD **)(a1 + 120);
    if (*(unsigned char *)(a1 + 170))
    {
      if ((unint64_t)v9 < v19) {
        goto LABEL_24;
      }
      uint64_t v20 = (char *)v9 - *v10;
      if (v20 > -3)
      {
        uint64_t v21 = v20 >> 1;
        unint64_t v22 = v19 - (void)*v10;
        if (v22 <= (v20 >> 1) + 1) {
          unint64_t v23 = v21 + 1;
        }
        else {
          unint64_t v23 = v22;
        }
        if (v22 >= 0x7FFFFFFFFFFFFFFELL) {
          uint64_t v24 = 0x7FFFFFFFFFFFFFFFLL;
        }
        else {
          uint64_t v24 = v23;
        }
        if (v24) {
          uint64_t v25 = (char *)sub_10006E5B8(v18, v24);
        }
        else {
          uint64_t v25 = 0;
        }
        uint64_t v27 = &v25[2 * v21];
        size_t v28 = &v25[2 * v24];
        *(_WORD *)uint64_t v27 = v8;
        int v26 = v27 + 2;
        long long v38 = *(char **)(a1 + 112);
        uint64_t v29 = *(char **)(a1 + 120);
        if (v29 == v38) {
          goto LABEL_46;
        }
        do
        {
          __int16 v39 = *((_WORD *)v29 - 1);
          v29 -= 2;
          *((_WORD *)v27 - 1) = v39;
          v27 -= 2;
        }
        while (v29 != v38);
        goto LABEL_45;
      }
    }
    else
    {
      if ((unint64_t)v9 < v19) {
        goto LABEL_24;
      }
      uint64_t v32 = (char *)v9 - *v10;
      if (v32 > -3)
      {
        uint64_t v33 = v32 >> 1;
        unint64_t v34 = v19 - (void)*v10;
        if (v34 <= (v32 >> 1) + 1) {
          unint64_t v35 = v33 + 1;
        }
        else {
          unint64_t v35 = v34;
        }
        if (v34 >= 0x7FFFFFFFFFFFFFFELL) {
          uint64_t v36 = 0x7FFFFFFFFFFFFFFFLL;
        }
        else {
          uint64_t v36 = v35;
        }
        if (v36) {
          uint64_t v37 = (char *)sub_10006E5B8(v18, v36);
        }
        else {
          uint64_t v37 = 0;
        }
        uint64_t v27 = &v37[2 * v33];
        size_t v28 = &v37[2 * v36];
        *(_WORD *)uint64_t v27 = v8;
        int v26 = v27 + 2;
        long long v40 = *(char **)(a1 + 112);
        uint64_t v29 = *(char **)(a1 + 120);
        if (v29 == v40) {
          goto LABEL_46;
        }
        do
        {
          __int16 v41 = *((_WORD *)v29 - 1);
          v29 -= 2;
          *((_WORD *)v27 - 1) = v41;
          v27 -= 2;
        }
        while (v29 != v40);
        goto LABEL_45;
      }
    }
LABEL_49:
    sub_10006A748();
  }
  unsigned __int8 v5 = (*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24), a2);
  __int16 v6 = (*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24), a3);
  unint64_t v7 = *(void *)(a1 + 128);
  __int16 v8 = v5 | (unsigned __int16)(v6 << 8);
  char v9 = *(_WORD **)(a1 + 120);
  if ((unint64_t)v9 < v7)
  {
LABEL_24:
    *char v9 = v8;
    int v26 = v9 + 1;
    goto LABEL_48;
  }
  char v10 = (char **)(a1 + 112);
  uint64_t v11 = *(void *)(a1 + 112);
  uint64_t v12 = (uint64_t)v9 - v11;
  if ((uint64_t)v9 - v11 <= -3) {
    goto LABEL_49;
  }
  uint64_t v13 = v12 >> 1;
  unint64_t v14 = v7 - v11;
  if (v14 <= (v12 >> 1) + 1) {
    unint64_t v15 = v13 + 1;
  }
  else {
    unint64_t v15 = v14;
  }
  if (v14 >= 0x7FFFFFFFFFFFFFFELL) {
    uint64_t v16 = 0x7FFFFFFFFFFFFFFFLL;
  }
  else {
    uint64_t v16 = v15;
  }
  if (v16) {
    uint64_t v17 = (char *)sub_10006E5B8(a1 + 128, v16);
  }
  else {
    uint64_t v17 = 0;
  }
  uint64_t v27 = &v17[2 * v13];
  size_t v28 = &v17[2 * v16];
  *(_WORD *)uint64_t v27 = v8;
  int v26 = v27 + 2;
  uint64_t v30 = *(char **)(a1 + 112);
  uint64_t v29 = *(char **)(a1 + 120);
  if (v29 == v30) {
    goto LABEL_46;
  }
  do
  {
    __int16 v31 = *((_WORD *)v29 - 1);
    v29 -= 2;
    *((_WORD *)v27 - 1) = v31;
    v27 -= 2;
  }
  while (v29 != v30);
LABEL_45:
  uint64_t v29 = *v10;
LABEL_46:
  *(void *)(a1 + 112) = v27;
  *(void *)(a1 + 120) = v26;
  *(void *)(a1 + 128) = v28;
  if (v29) {
    operator delete(v29);
  }
LABEL_48:
  *(void *)(a1 + 120) = v26;
}

void sub_10056AF58()
{
  exception = (std::regex_error *)__cxa_allocate_exception(0x18uLL);
  std::regex_error::regex_error(exception, error_collate);
}

void sub_10056AF9C(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_10056AFB0(uint64_t *a1, long long *a2)
{
  uint64_t v3 = a1 + 17;
  unint64_t v4 = a1[18];
  if (v4 >= a1[19])
  {
    uint64_t result = sub_100048008(v3, a2);
  }
  else
  {
    sub_1000D87F8(v3, a2);
    uint64_t result = v4 + 24;
  }
  a1[18] = result;
  return result;
}

void sub_10056AFF4(uint64_t a1, uint64_t a2, char *a3, char *a4)
{
  memset(&__s, 0, sizeof(__s));
  sub_10012CD04(&__s, a3, a4, a4 - a3);
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  if (SHIBYTE(__s.__r_.__value_.__r.__words[2]) < 0)
  {
    if (!__s.__r_.__value_.__l.__size_) {
      goto LABEL_9;
    }
    p_s = (std::string *)__s.__r_.__value_.__r.__words[0];
  }
  else
  {
    if (!*((unsigned char *)&__s.__r_.__value_.__s + 23)) {
      return;
    }
    p_s = &__s;
  }
  std::__get_collation_name(&v11, (const char *)p_s);
  *(_OWORD *)a1 = *(_OWORD *)&v11.__r_.__value_.__l.__data_;
  unint64_t v7 = v11.__r_.__value_.__r.__words[2];
  *(void *)(a1 + 16) = *((void *)&v11.__r_.__value_.__l + 2);
  unint64_t v8 = HIBYTE(v7);
  if ((v8 & 0x80u) != 0) {
    unint64_t v8 = *(void *)(a1 + 8);
  }
  if (v8) {
    goto LABEL_9;
  }
  if (SHIBYTE(__s.__r_.__value_.__r.__words[2]) < 0)
  {
    if (__s.__r_.__value_.__l.__size_ >= 3) {
      goto LABEL_9;
    }
  }
  else if (HIBYTE(__s.__r_.__value_.__r.__words[2]) >= 3u)
  {
    return;
  }
  (*(void (**)(std::string *__return_ptr))(**(void **)(a2 + 16) + 32))(&v11);
  if (*(char *)(a1 + 23) < 0) {
    operator delete(*(void **)a1);
  }
  *(std::string *)a1 = v11;
  if ((*(char *)(a1 + 23) & 0x80000000) == 0)
  {
    int v9 = *(unsigned __int8 *)(a1 + 23);
    if (v9 != 12 && v9 != 1)
    {
      *(unsigned char *)a1 = 0;
      *(unsigned char *)(a1 + 23) = 0;
      goto LABEL_9;
    }
    goto LABEL_23;
  }
  uint64_t v10 = *(void *)(a1 + 8);
  if (v10 == 1 || v10 == 12)
  {
LABEL_23:
    std::string::operator=((std::string *)a1, &__s);
    goto LABEL_9;
  }
  **(unsigned char **)a1 = 0;
  *(void *)(a1 + 8) = 0;
LABEL_9:
  if (SHIBYTE(__s.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__s.__r_.__value_.__l.__data_);
  }
}

void sub_10056B184(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (*(char *)(v17 + 23) < 0) {
    operator delete(*(void **)v17);
  }
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_10056B1B8(uint64_t a1@<X0>, char *a2@<X1>, char *a3@<X2>, uint64_t *a4@<X8>)
{
  std::string __p = 0;
  uint64_t v12 = 0;
  uint64_t v13 = 0;
  sub_10012CD04(&__p, a2, a3, a3 - a2);
  *a4 = 0;
  a4[1] = 0;
  a4[2] = 0;
  uint64_t v6 = HIBYTE(v13);
  if (v13 >= 0) {
    p_p = (char *)&__p;
  }
  else {
    p_p = (char *)__p;
  }
  if (v13 < 0) {
    uint64_t v6 = v12;
  }
  (*(void (**)(void, char *, char *))(**(void **)(a1 + 16) + 32))(*(void *)(a1 + 16), p_p, &p_p[v6]);
  uint64_t v8 = *((unsigned __int8 *)a4 + 23);
  int v9 = (char)v8;
  if ((v8 & 0x80u) != 0) {
    uint64_t v8 = a4[1];
  }
  if (v8 != 1)
  {
    if (v8 == 12)
    {
      if (v9 >= 0) {
        uint64_t v10 = a4;
      }
      else {
        uint64_t v10 = (uint64_t *)*a4;
      }
      *((unsigned char *)v10 + 11) = *((unsigned char *)v10 + 3);
    }
    else if (v9 < 0)
    {
      *(unsigned char *)*a4 = 0;
      a4[1] = 0;
    }
    else
    {
      *(unsigned char *)a4 = 0;
      *((unsigned char *)a4 + 23) = 0;
    }
  }
  if (SHIBYTE(v13) < 0) {
    operator delete(__p);
  }
}

void sub_10056B2BC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_10056B2D8()
{
  exception = (std::regex_error *)__cxa_allocate_exception(0x18uLL);
  std::regex_error::regex_error(exception, error_ctype);
}

void sub_10056B31C(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void sub_10056B330(uint64_t a1, uint64_t a2)
{
  char v2 = a2;
  if (*(unsigned char *)(a1 + 169))
  {
    char v2 = (*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24), a2);
    unsigned __int8 v5 = *(unsigned char **)(a1 + 72);
    unint64_t v4 = *(void *)(a1 + 80);
    if ((unint64_t)v5 >= v4)
    {
      uint64_t v6 = (unint64_t *)(a1 + 64);
      unint64_t v7 = *(void *)(a1 + 64);
      uint64_t v8 = &v5[-v7];
      uint64_t v9 = (uint64_t)&v5[-v7 + 1];
      if (v9 >= 0)
      {
        unint64_t v10 = v4 - v7;
        if (2 * v10 > v9) {
          uint64_t v9 = 2 * v10;
        }
        if (v10 >= 0x3FFFFFFFFFFFFFFFLL) {
          size_t v11 = 0x7FFFFFFFFFFFFFFFLL;
        }
        else {
          size_t v11 = v9;
        }
        if (v11) {
          uint64_t v12 = operator new(v11);
        }
        else {
          uint64_t v12 = 0;
        }
        uint64_t v20 = &v8[(void)v12];
        uint64_t v21 = (char *)v12 + v11;
        v8[(void)v12] = v2;
        uint64_t v19 = (uint64_t)&v8[(void)v12 + 1];
        if (v5 != (unsigned char *)v7)
        {
          unint64_t v22 = &v5[~v7];
          do
          {
            char v23 = *--v5;
            (v22--)[(void)v12] = v23;
          }
          while (v5 != (unsigned char *)v7);
LABEL_45:
          unsigned __int8 v5 = (unsigned char *)*v6;
          goto LABEL_47;
        }
        goto LABEL_46;
      }
LABEL_50:
      sub_100205700();
    }
    goto LABEL_22;
  }
  uint64_t v6 = (unint64_t *)(a1 + 64);
  unsigned __int8 v5 = *(unsigned char **)(a1 + 72);
  unint64_t v13 = *(void *)(a1 + 80);
  if (!*(unsigned char *)(a1 + 170))
  {
    if ((unint64_t)v5 >= v13)
    {
      unint64_t v24 = *v6;
      uint64_t v25 = &v5[-*v6];
      unint64_t v26 = (unint64_t)(v25 + 1);
      if ((uint64_t)(v25 + 1) >= 0)
      {
        unint64_t v27 = v13 - v24;
        if (2 * v27 > v26) {
          unint64_t v26 = 2 * v27;
        }
        if (v27 >= 0x3FFFFFFFFFFFFFFFLL) {
          size_t v28 = 0x7FFFFFFFFFFFFFFFLL;
        }
        else {
          size_t v28 = v26;
        }
        if (v28) {
          uint64_t v12 = operator new(v28);
        }
        else {
          uint64_t v12 = 0;
        }
        uint64_t v20 = &v25[(void)v12];
        uint64_t v21 = (char *)v12 + v28;
        v25[(void)v12] = v2;
        uint64_t v19 = (uint64_t)&v25[(void)v12 + 1];
        if (v5 != (unsigned char *)v24)
        {
          __int16 v31 = &v5[~v24];
          do
          {
            char v32 = *--v5;
            (v31--)[(void)v12] = v32;
          }
          while (v5 != (unsigned char *)v24);
          goto LABEL_45;
        }
        goto LABEL_46;
      }
      goto LABEL_50;
    }
LABEL_22:
    unsigned char *v5 = v2;
    uint64_t v19 = (uint64_t)(v5 + 1);
    goto LABEL_49;
  }
  if ((unint64_t)v5 < v13) {
    goto LABEL_22;
  }
  unint64_t v14 = *v6;
  unint64_t v15 = &v5[-*v6];
  unint64_t v16 = (unint64_t)(v15 + 1);
  if ((uint64_t)(v15 + 1) < 0) {
    goto LABEL_50;
  }
  unint64_t v17 = v13 - v14;
  if (2 * v17 > v16) {
    unint64_t v16 = 2 * v17;
  }
  if (v17 >= 0x3FFFFFFFFFFFFFFFLL) {
    size_t v18 = 0x7FFFFFFFFFFFFFFFLL;
  }
  else {
    size_t v18 = v16;
  }
  if (v18) {
    uint64_t v12 = operator new(v18);
  }
  else {
    uint64_t v12 = 0;
  }
  uint64_t v20 = &v15[(void)v12];
  uint64_t v21 = (char *)v12 + v18;
  v15[(void)v12] = v2;
  uint64_t v19 = (uint64_t)&v15[(void)v12 + 1];
  if (v5 != (unsigned char *)v14)
  {
    uint64_t v29 = &v5[~v14];
    do
    {
      char v30 = *--v5;
      (v29--)[(void)v12] = v30;
    }
    while (v5 != (unsigned char *)v14);
    goto LABEL_45;
  }
LABEL_46:
  uint64_t v12 = v20;
LABEL_47:
  *(void *)(a1 + 64) = v12;
  *(void *)(a1 + 72) = v19;
  *(void *)(a1 + 80) = v21;
  if (v5) {
    operator delete(v5);
  }
LABEL_49:
  *(void *)(a1 + 72) = v19;
}

void sub_10056B578(uint64_t a1, char *a2, char *a3)
{
  std::string __p = 0;
  uint64_t v7 = 0;
  uint64_t v8 = 0;
  sub_10012CD04(&__p, a2, a3, a3 - a2);
  uint64_t v4 = HIBYTE(v8);
  if (v8 >= 0) {
    p_p = (char *)&__p;
  }
  else {
    p_p = (char *)__p;
  }
  if (v8 < 0) {
    uint64_t v4 = v7;
  }
  (*(void (**)(void, char *, char *))(**(void **)(a1 + 16) + 32))(*(void *)(a1 + 16), p_p, &p_p[v4]);
  if (SHIBYTE(v8) < 0) {
    operator delete(__p);
  }
}

void sub_10056B61C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_10056B638()
{
  exception = (std::regex_error *)__cxa_allocate_exception(0x18uLL);
  std::regex_error::regex_error(exception, error_range);
}

void sub_10056B67C(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void *sub_10056B690(void *a1)
{
  *a1 = off_1019E3B28;
  uint64_t v2 = a1[1];
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  return a1;
}

void sub_10056B6FC(void *a1)
{
  *a1 = off_1019E3B28;
  uint64_t v1 = a1[1];
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }

  operator delete();
}

uint64_t sub_10056B788(uint64_t result, uint64_t a2)
{
  *(_DWORD *)a2 = -994;
  *(void *)(*(void *)(a2 + 32) + 24 * (*(_DWORD *)(result + 16) - 1)) = *(void *)(a2 + 16);
  *(void *)(a2 + 80) = *(void *)(result + 8);
  return result;
}

void *sub_10056B7B8(void *a1)
{
  *a1 = off_1019E3B28;
  uint64_t v2 = a1[1];
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  return a1;
}

void sub_10056B824(void *a1)
{
  *a1 = off_1019E3B28;
  uint64_t v1 = a1[1];
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }

  operator delete();
}

uint64_t sub_10056B8B0(uint64_t result, uint64_t a2)
{
  *(_DWORD *)a2 = -994;
  uint64_t v2 = *(void *)(a2 + 32) + 24 * (*(_DWORD *)(result + 16) - 1);
  *(void *)(v2 + 8) = *(void *)(a2 + 16);
  *(unsigned char *)(v2 + 16) = 1;
  *(void *)(a2 + 80) = *(void *)(result + 8);
  return result;
}

void sub_10056B8E8()
{
}

void sub_10056BA40(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

unsigned __int8 *sub_10056BA78(unsigned __int8 *result, unsigned __int8 *a2, int *a3)
{
  if (result != a2)
  {
    int v3 = *result;
    if ((v3 & 0xF8) == 0x30 || (v3 & 0xFE) == 0x38)
    {
      int v4 = v3 - 48;
      *a3 = v4;
      if (++result == a2)
      {
        return a2;
      }
      else
      {
        while (1)
        {
          int v5 = *result;
          if ((v5 & 0xF8) != 0x30 && (v5 & 0xFE) != 0x38) {
            break;
          }
          if (v4 >= 214748364) {
            sub_10056BB14();
          }
          int v4 = v5 + 10 * v4 - 48;
          *a3 = v4;
          if (++result == a2) {
            return a2;
          }
        }
      }
    }
  }
  return result;
}

void sub_10056BB14()
{
  exception = (std::regex_error *)__cxa_allocate_exception(0x18uLL);
  std::regex_error::regex_error(exception, error_badbrace);
}

void sub_10056BB58(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void sub_10056BB6C()
{
  exception = (std::regex_error *)__cxa_allocate_exception(0x18uLL);
  std::regex_error::regex_error(exception, error_brace);
}

void sub_10056BBB0(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void sub_10056BBC8(void *a1)
{
  sub_10056BD20(a1);

  operator delete();
}

unsigned int *sub_10056BC00(unsigned int *result, void *a2)
{
  uint64_t v2 = result[10];
  uint64_t v3 = a2[7];
  int v4 = (unint64_t *)(v3 + 16 * v2);
  if (*(_DWORD *)a2 == -991)
  {
    unint64_t v5 = *v4 + 1;
    unint64_t *v4 = v5;
    unint64_t v6 = *((void *)result + 3);
    unint64_t v7 = *((void *)result + 4);
    BOOL v8 = v5 < v7;
    if (v5 < v7 && v5 >= v6)
    {
      uint64_t v10 = *(void *)(v3 + 16 * v2 + 8);
      BOOL v8 = v5 < v7 && v10 != a2[2];
    }
    if (!v8 || v5 < v6)
    {
      *(_DWORD *)a2 = -994;
      if (!v8) {
        goto LABEL_25;
      }
LABEL_22:
      a2[10] = *((void *)result + 1);
      return sub_10056BDD4(result, a2);
    }
    goto LABEL_23;
  }
  unint64_t *v4 = 0;
  if (*((void *)result + 4))
  {
    if (*((void *)result + 3))
    {
      *(_DWORD *)a2 = -994;
      goto LABEL_22;
    }
LABEL_23:
    *(_DWORD *)a2 = -992;
    return result;
  }
  *(_DWORD *)a2 = -994;
LABEL_25:
  a2[10] = *((void *)result + 2);
  return result;
}

unsigned int *sub_10056BCB4(unsigned int *result, int a2, void *a3)
{
  *(_DWORD *)a3 = -994;
  if (*((unsigned __int8 *)result + 52) == a2)
  {
    a3[10] = *((void *)result + 2);
  }
  else
  {
    a3[10] = *((void *)result + 1);
    return sub_10056BDD4(result, a3);
  }
  return result;
}

void sub_10056BCE8(void *a1)
{
  sub_10056BD20(a1);

  operator delete();
}

void *sub_10056BD20(void *a1)
{
  *a1 = off_1019E3FA8;
  uint64_t v2 = a1[2];
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  *a1 = off_1019E3B28;
  uint64_t v3 = a1[1];
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  return a1;
}

unsigned int *sub_10056BDD4(unsigned int *result, void *a2)
{
  unsigned int v2 = result[11];
  *(void *)(a2[7] + 16 * result[10] + 8) = a2[2];
  unsigned int v3 = result[12];
  if (v2 != v3)
  {
    uint64_t v4 = v2 - 1;
    uint64_t v5 = a2[3];
    uint64_t v6 = v3 - 1 - v4;
    unint64_t v7 = (unsigned char *)(a2[4] + 24 * v4 + 16);
    do
    {
      *((void *)v7 - 2) = v5;
      *((void *)v7 - 1) = v5;
      *unint64_t v7 = 0;
      v7 += 24;
      --v6;
    }
    while (v6);
  }
  return result;
}

void sub_10056BE28()
{
}

uint64_t sub_10056BE3C(uint64_t result, uint64_t a2)
{
  *(_DWORD *)a2 = -991;
  *(void *)(a2 + 80) = *(void *)(result + 8);
  return result;
}

void sub_10056BE54(void *a1)
{
  sub_10056BD20(a1);

  operator delete();
}

void sub_10056BE8C(uint64_t a1, _DWORD *a2)
{
  *a2 = -992;
}

uint64_t sub_10056BE98(uint64_t result, int a2, uint64_t a3)
{
  *(_DWORD *)a3 = -994;
  uint64_t v3 = 8;
  if (a2) {
    uint64_t v3 = 16;
  }
  *(void *)(a3 + 80) = *(void *)(result + v3);
  return result;
}

void sub_10056BEC0()
{
}

uint64_t sub_10056BED4(uint64_t result, uint64_t a2)
{
  *(_DWORD *)a2 = -994;
  *(void *)(a2 + 80) = *(void *)(result + 8);
  return result;
}

void sub_10056BEE8()
{
  exception = (std::regex_error *)__cxa_allocate_exception(0x18uLL);
  std::regex_error::regex_error(exception, __re_err_empty);
}

void sub_10056BF2C(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

unsigned __int8 *sub_10056BF40(uint64_t a1, unsigned __int8 *a2, unsigned __int8 *a3)
{
  uint64_t v3 = a2;
  if (a2 != a3)
  {
    unint64_t v7 = a2 + 1;
    int v6 = *a2;
    if (a2 + 1 != a3 || v6 != 36)
    {
      if ((v6 - 46) > 0x2E || ((1 << (v6 - 46)) & 0x600000000001) == 0) {
        sub_100568348(a1);
      }
      if (v7 != a3 && v6 == 92)
      {
        unsigned int v10 = (char)*v7 - 36;
        if (v10 <= 0x3A && ((1 << v10) & 0x580000000000441) != 0) {
          sub_100568348(a1);
        }
      }
      if (*a2 == 46) {
        operator new();
      }
    }
    BOOL v8 = sub_100567570(a1, a2, a3);
    if (v3 == v8)
    {
      if (v7 == a3 || *v3 != 92) {
        return v3;
      }
      int v12 = *v7;
      if (v12 == 40)
      {
        uint64_t v13 = (uint64_t)(v3 + 2);
        sub_100567CA4(a1);
        do
        {
          unint64_t v14 = (unsigned __int8 *)v13;
          uint64_t v13 = sub_10056BF40(a1, v13, a3);
        }
        while (v14 != (unsigned __int8 *)v13);
        if (v14 == a3 || v14 + 1 == a3 || *v14 != 92 || v14[1] != 41) {
          sub_100566CC0();
        }
        BOOL v8 = v14 + 2;
        sub_100567D28(a1);
      }
      else
      {
        int v21 = sub_10056C404(a1, v12);
        uint64_t v22 = 2;
        if (!v21) {
          uint64_t v22 = 0;
        }
        BOOL v8 = &v3[v22];
      }
    }
    if (v8 != v3)
    {
      if (v8 == a3) {
        return a3;
      }
      int v11 = *v8;
      if (v11 == 42) {
        sub_10056B8E8();
      }
      if (v8 + 1 != a3 && v11 == 92 && v8[1] == 123)
      {
        unint64_t v16 = v8 + 2;
        int v24 = 0;
        unint64_t v17 = sub_10056BA78(v16, a3, &v24);
        if (v16 == v17) {
          goto LABEL_47;
        }
        if (v17 != a3)
        {
          size_t v18 = v17 + 1;
          int v19 = *v17;
          if (v19 == 44)
          {
            int v23 = -1;
            uint64_t v20 = sub_10056BA78(v17 + 1, a3, &v23);
            if (v20 != a3 && v20 + 1 != a3 && *v20 == 92 && v20[1] == 125)
            {
              if (v23 != -1 && v23 < v24) {
LABEL_47:
              }
                sub_10056BB14();
LABEL_54:
              sub_10056B8E8();
            }
          }
          else if (v18 != a3 && v19 == 92 && *v18 == 125)
          {
            goto LABEL_54;
          }
        }
        sub_10056BB6C();
      }
      return v8;
    }
  }
  return v3;
}

void *sub_10056C2CC(void *a1)
{
  *a1 = off_1019E3B28;
  uint64_t v2 = a1[1];
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  return a1;
}

void sub_10056C338(void *a1)
{
  *a1 = off_1019E3B28;
  uint64_t v1 = a1[1];
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }

  operator delete();
}

uint64_t sub_10056C3C4(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(unsigned char **)(a2 + 16);
  if (v2 == *(unsigned char **)(a2 + 24) || !*v2)
  {
    uint64_t v3 = 0;
    *(_DWORD *)a2 = -993;
  }
  else
  {
    *(_DWORD *)a2 = -995;
    *(void *)(a2 + 16) = v2 + 1;
    uint64_t v3 = *(void *)(result + 8);
  }
  *(void *)(a2 + 80) = v3;
  return result;
}

uint64_t sub_10056C404(uint64_t a1, unsigned __int8 a2)
{
  if (((a2 & 0xF8) == 0x30 || (a2 & 0xFE) == 0x38) && a2 - 49 <= 8)
  {
    if (a2 - 48 <= *(_DWORD *)(a1 + 28)) {
      sub_1005684E0(a1);
    }
    sub_100568488();
  }
  return 0;
}

unsigned __int8 *sub_10056C464(uint64_t a1, unsigned __int8 *a2, char *a3)
{
  int v6 = sub_10056C4C4(a1, a2, a3);
  if (v6 == a2) {
    sub_10056BEE8();
  }
  do
  {
    unint64_t v7 = v6;
    int v6 = sub_10056C4C4(a1, v6, a3);
  }
  while (v7 != v6);
  return v7;
}

unsigned __int8 *sub_10056C4C4(uint64_t a1, unsigned __int8 *a2, char *a3)
{
  if (a2 == (unsigned __int8 *)a3)
  {
LABEL_24:
    int v11 = sub_100567570(a1, a2, a3);
    goto LABEL_25;
  }
  int v6 = (char)*a2;
  int v7 = *a2;
  uint64_t v8 = (v6 - 36);
  if (v8 > 0x3A) {
    goto LABEL_13;
  }
  if (((1 << (v6 - 36)) & 0x5800000080004D1) == 0)
  {
    if (v8 == 5)
    {
      if (*(_DWORD *)(a1 + 36)) {
        goto LABEL_4;
      }
LABEL_14:
      sub_100568348(a1);
    }
LABEL_13:
    if ((v6 - 123) < 2) {
      goto LABEL_4;
    }
    goto LABEL_14;
  }
LABEL_4:
  uint64_t v9 = a2 + 1;
  if (a2 + 1 == (unsigned __int8 *)a3 || v7 != 92)
  {
LABEL_22:
    if (v7 == 46) {
      operator new();
    }
    goto LABEL_24;
  }
  int v10 = (char)*v9;
  if ((v10 - 36) <= 0x3A && ((1 << (v10 - 36)) & 0x5800000080004F1) != 0
    || (v10 - 123) < 3)
  {
    sub_100568348(a1);
  }
  if ((*(_DWORD *)(a1 + 24) & 0x1F0) == 0x40)
  {
    int v11 = (unsigned __int8 *)sub_10056A5B8(a1, (char *)a2 + 1, a3, 0);
  }
  else
  {
    int v12 = sub_10056C404(a1, *v9);
    uint64_t v13 = 2;
    if (!v12) {
      uint64_t v13 = 0;
    }
    int v11 = &a2[v13];
  }
  if (v11 == a2)
  {
    int v7 = *a2;
    goto LABEL_22;
  }
LABEL_25:
  if (v11 == a2 && v11 != (unsigned __int8 *)a3)
  {
    int v14 = (char)*a2;
    if (v14 == 36) {
      sub_100566B00();
    }
    if (v14 != 40)
    {
      if (v14 == 94) {
        sub_100566A7C();
      }
      return a2;
    }
    sub_100567CA4(a1);
    ++*(_DWORD *)(a1 + 36);
    unint64_t v15 = (char *)sub_100565BBC(a1, a2 + 1, a3);
    if (v15 == a3 || (unint64_t v16 = v15, *v15 != 41)) {
      sub_100566CC0();
    }
    sub_100567D28(a1);
    --*(_DWORD *)(a1 + 36);
    int v11 = (unsigned __int8 *)(v16 + 1);
  }
  if (v11 == a2) {
    return a2;
  }

  return sub_100566774(a1, v11, (unsigned __int8 *)a3);
}

std::string *sub_10056C78C(std::string *a1, uint64_t a2, uint64_t a3, uint64_t a4, char *a5, int a6)
{
  __int16 v6 = a6;
  uint64_t v9 = (std::string::value_type *)a2;
  long long v31 = 0u;
  long long v32 = 0u;
  long long v29 = 0u;
  long long v30 = 0u;
  long long v27 = 0u;
  long long v28 = 0u;
  *(_OWORD *)unint64_t v26 = 0u;
  memset(v25, 0, sizeof(v25));
  sub_10056CE04((uint64_t)v25, a2, a3, a4, a6);
  long long v23 = 0u;
  long long v24 = 0u;
  long long v21 = 0u;
  long long v22 = 0u;
  long long v19 = 0u;
  long long v20 = 0u;
  *(_OWORD *)std::string __p = 0u;
  memset(v17, 0, sizeof(v17));
  if (sub_10056C94C((uint64_t)v25, (uint64_t)v17))
  {
    if ((v6 & 0x200) == 0)
    {
      while (v9 != (std::string::value_type *)a3)
        std::string::push_back(a1, *v9++);
    }
  }
  else
  {
    int v11 = 0;
    int v12 = 0;
    uint64_t v13 = (unsigned __int8 *)&a5[strlen(a5)];
    while (!sub_10056C94C((uint64_t)v25, (uint64_t)v17))
    {
      if ((v6 & 0x200) == 0)
      {
        unint64_t v15 = (std::string::value_type *)*((void *)&v29 + 1);
        for (unint64_t i = (std::string::value_type *)v29; i != v15; ++i)
          std::string::push_back(a1, *i);
      }
      a1 = sub_10056C9E4((std::string::value_type ***)v26, a1, (unsigned __int8 *)a5, v13, v6);
      int v11 = (std::string::value_type *)*((void *)&v30 + 1);
      int v12 = (std::string::value_type *)v31;
      if ((v6 & 0x400) != 0) {
        break;
      }
      sub_10056CC60((uint64_t)v25);
    }
    if ((v6 & 0x200) == 0)
    {
      while (v11 != v12)
        std::string::push_back(a1, *v11++);
    }
  }
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  if (v26[0])
  {
    v26[1] = v26[0];
    operator delete(v26[0]);
  }
  return a1;
}

void sub_10056C90C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,void *a31,uint64_t a32)
{
  if (__p) {
    operator delete(__p);
  }
  if (a31) {
    operator delete(a31);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_10056C94C(uint64_t a1, uint64_t a2)
{
  uint64_t v6 = a1 + 32;
  uint64_t v4 = *(void *)(a1 + 32);
  uint64_t v5 = *(void *)(v6 + 8);
  uint64_t v9 = a2 + 32;
  uint64_t v7 = *(void *)(a2 + 32);
  uint64_t v8 = *(void *)(v9 + 8);
  BOOL v10 = v8 == v7 && v5 == v4;
  if (v5 != v4 && v8 != v7) {
    return *(void *)a1 == *(void *)a2
  }
        && *(void *)(a1 + 8) == *(void *)(a2 + 8)
        && *(void *)(a1 + 16) == *(void *)(a2 + 16)
        && *(_DWORD *)(a1 + 24) == *(_DWORD *)(a2 + 24)
        && sub_10056CEF8(v4, v7) == 0;
  return v10;
}

std::string *sub_10056C9E4(std::string::value_type ***a1, std::string *this, unsigned __int8 *a3, unsigned __int8 *a4, __int16 a5)
{
  uint64_t v6 = a3;
  if ((a5 & 0x100) != 0)
  {
    if (a3 == a4) {
      return this;
    }
    while (1)
    {
      int v29 = *v6;
      if (v29 == 92)
      {
        uint64_t v33 = v6 + 1;
        if (v6 + 1 == a4)
        {
          LOBYTE(v29) = 92;
        }
        else
        {
          int v29 = *v33;
          if ((v29 - 48) <= 9u)
          {
            unint64_t v34 = (v29 - 48);
            if (0xAAAAAAAAAAAAAAABLL * (a1[1] - *a1) <= v34) {
              uint64_t v35 = (uint64_t)(a1 + 3);
            }
            else {
              uint64_t v35 = (uint64_t)&(*a1)[3 * v34];
            }
            uint64_t v36 = *(std::string::value_type **)v35;
            uint64_t v37 = *(std::string::value_type **)(v35 + 8);
            while (v36 != v37)
            {
              std::string::value_type v38 = *v36++;
              std::string::push_back(this, v38);
            }
            goto LABEL_53;
          }
          ++v6;
        }
      }
      else if (v29 == 38)
      {
        long long v30 = **a1;
        long long v31 = (*a1)[1];
        while (v30 != v31)
        {
          std::string::value_type v32 = *v30++;
          std::string::push_back(this, v32);
        }
        goto LABEL_52;
      }
      std::string::push_back(this, v29);
LABEL_52:
      uint64_t v33 = v6;
LABEL_53:
      uint64_t v6 = v33 + 1;
      if (v33 + 1 == a4) {
        return this;
      }
    }
  }
  if (a3 != a4)
  {
    do
    {
      int v9 = *v6;
      if (v9 == 36)
      {
        BOOL v10 = v6 + 1;
        if (v6 + 1 == a4) {
          goto LABEL_31;
        }
        int v11 = (char)*v10;
        int v9 = *v10;
        if (v11 > 38)
        {
          if (v11 == 39)
          {
            size_t v18 = (std::string::value_type *)a1[9];
            long long v19 = (std::string::value_type *)a1[10];
            while (v18 != v19)
            {
              std::string::value_type v20 = *v18++;
              std::string::push_back(this, v20);
            }
            goto LABEL_33;
          }
          if (v11 == 96)
          {
            unint64_t v15 = (std::string::value_type *)a1[6];
            unint64_t v16 = (std::string::value_type *)a1[7];
            while (v15 != v16)
            {
              std::string::value_type v17 = *v15++;
              std::string::push_back(this, v17);
            }
            goto LABEL_33;
          }
LABEL_20:
          if ((v9 - 48) <= 9)
          {
            unint64_t v21 = *v10 - 48;
            if (v6 + 2 != a4)
            {
              uint64_t v22 = v6[2];
              unsigned int v23 = v22 - 48;
              uint64_t v24 = v22 + 10 * (int)v21 - 48;
              if (v23 > 9)
              {
                BOOL v10 = v6 + 1;
              }
              else
              {
                unint64_t v21 = v24;
                BOOL v10 = v6 + 2;
              }
            }
            if (0xAAAAAAAAAAAAAAABLL * (a1[1] - *a1) <= v21) {
              uint64_t v25 = (uint64_t)(a1 + 3);
            }
            else {
              uint64_t v25 = (uint64_t)&(*a1)[3 * (int)v21];
            }
            unint64_t v26 = *(std::string::value_type **)v25;
            long long v27 = *(std::string::value_type **)(v25 + 8);
            while (v26 != v27)
            {
              std::string::value_type v28 = *v26++;
              std::string::push_back(this, v28);
            }
            goto LABEL_33;
          }
LABEL_31:
          LOBYTE(v9) = 36;
          goto LABEL_32;
        }
        if (v11 != 36)
        {
          if (v11 == 38)
          {
            int v12 = **a1;
            uint64_t v13 = (*a1)[1];
            while (v12 != v13)
            {
              std::string::value_type v14 = *v12++;
              std::string::push_back(this, v14);
            }
            goto LABEL_33;
          }
          goto LABEL_20;
        }
        ++v6;
      }
LABEL_32:
      std::string::push_back(this, v9);
      BOOL v10 = v6;
LABEL_33:
      uint64_t v6 = v10 + 1;
    }
    while (v10 + 1 != a4);
  }
  return this;
}

uint64_t sub_10056CC60(uint64_t a1)
{
  uint64_t v3 = a1 + 32;
  uint64_t v2 = *(void **)(a1 + 32);
  int v4 = *(_DWORD *)(v3 - 8);
  int v5 = v4 | 0x800;
  *(_DWORD *)(v3 - 8) = v4 | 0x800;
  if (*(void **)(v3 + 8) == v2) {
    uint64_t v6 = (void *)(v3 + 24);
  }
  else {
    uint64_t v6 = v2;
  }
  uint64_t v7 = v6[1];
  if (*v6 != v7)
  {
LABEL_5:
    *(_DWORD *)(a1 + 24) = v5 | 0x80;
    uint64_t v9 = *(void *)(a1 + 8);
    uint64_t v8 = *(void *)(a1 + 16);
    long long v20 = 0u;
    long long v21 = 0u;
    long long v18 = 0u;
    long long v19 = 0u;
    long long v16 = 0u;
    long long v17 = 0u;
    *(_OWORD *)std::string __p = 0u;
    char v10 = sub_100155A0C(v8, v7, v9, (uint64_t)__p, v5 | 0x80u);
    sub_100155BE8(v3, v7, v9, (uint64_t *)__p, (v5 & 0x800) != 0);
    if (__p[0])
    {
      __p[1] = __p[0];
      operator delete(__p[0]);
    }
    if ((v10 & 1) == 0)
    {
      uint64_t v2 = *(void **)v3;
LABEL_14:
      if (v2)
      {
        *(void *)(a1 + 40) = v2;
        operator delete(v2);
        *(void *)uint64_t v3 = 0;
        *(void *)(v3 + 8) = 0;
        *(void *)(v3 + 16) = 0;
      }
      *(unsigned char *)(a1 + 128) = 0;
      *(_OWORD *)uint64_t v3 = 0u;
      *(_OWORD *)(v3 + 16) = 0u;
      *(_OWORD *)(v3 + 25) = 0u;
      *(void *)(a1 + 80) = 0;
      *(void *)(a1 + 88) = 0;
      *(unsigned char *)(a1 + 96) = 0;
      *(void *)(a1 + 104) = 0;
      *(void *)(a1 + 112) = 0;
      *(unsigned char *)(a1 + 120) = 0;
      *(void *)(a1 + 136) = 0;
      return a1;
    }
    return a1;
  }
  uint64_t v11 = *(void *)(a1 + 8);
  if (v11 == v7) {
    goto LABEL_14;
  }
  uint64_t v12 = *(void *)(a1 + 16);
  long long v20 = 0u;
  long long v21 = 0u;
  long long v18 = 0u;
  long long v19 = 0u;
  long long v16 = 0u;
  long long v17 = 0u;
  *(_OWORD *)std::string __p = 0u;
  char v13 = sub_100155A0C(v12, v7, v11, (uint64_t)__p, v4 | 0x860u);
  sub_100155BE8(v3, v7, v11, (uint64_t *)__p, 1);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  if ((v13 & 1) == 0)
  {
    ++v7;
    int v5 = *(_DWORD *)(a1 + 24);
    goto LABEL_5;
  }
  return a1;
}

void sub_10056CDE4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10056CE04(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  __int16 v5 = a5;
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = a3;
  *(void *)(a1 + 16) = a4;
  *(_OWORD *)(a1 + 32) = 0u;
  uint64_t v9 = a1 + 32;
  *(_DWORD *)(a1 + 24) = a5;
  *(void *)(a1 + 80) = 0;
  *(void *)(a1 + 88) = 0;
  *(unsigned char *)(a1 + 96) = 0;
  *(void *)(a1 + 104) = 0;
  *(void *)(a1 + 112) = 0;
  *(unsigned char *)(a1 + 120) = 0;
  *(unsigned char *)(a1 + 128) = 0;
  *(void *)(a1 + 136) = 0;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 57) = 0u;
  long long v16 = 0u;
  long long v17 = 0u;
  long long v14 = 0u;
  long long v15 = 0u;
  long long v12 = 0u;
  long long v13 = 0u;
  *(_OWORD *)std::string __p = 0u;
  sub_100155A0C(a4, a2, a3, (uint64_t)__p, a5);
  sub_100155BE8(v9, a2, a3, (uint64_t *)__p, (v5 & 0x800) != 0);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  return a1;
}

void sub_10056CECC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10)
{
  if (__p) {
    operator delete(__p);
  }
  long long v13 = *v11;
  if (*v11)
  {
    *(void *)(v10 + 40) = v13;
    operator delete(v13);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10056CEF8(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a1 + 16))
  {
    sub_10012CD04(&__p, *(char **)a1, *(char **)(a1 + 8), *(void *)(a1 + 8) - *(void *)a1);
  }
  else
  {
    std::string __p = 0;
    size_t v19 = 0;
    uint64_t v20 = 0;
  }
  if (*(unsigned char *)(a2 + 16))
  {
    sub_10012CD04(&v15, *(char **)a2, *(char **)(a2 + 8), *(void *)(a2 + 8) - *(void *)a2);
    unsigned int v3 = HIBYTE(v17);
    __int16 v5 = v15;
    size_t v4 = v16;
  }
  else
  {
    size_t v4 = 0;
    __int16 v5 = 0;
    unsigned int v3 = 0;
    long long v15 = 0;
    size_t v16 = 0;
    uint64_t v17 = 0;
  }
  char v6 = HIBYTE(v20);
  if (v20 >= 0) {
    size_t v7 = HIBYTE(v20);
  }
  else {
    size_t v7 = v19;
  }
  if (v20 >= 0) {
    p_p = &__p;
  }
  else {
    p_p = __p;
  }
  if ((v3 & 0x80u) == 0) {
    size_t v9 = v3;
  }
  else {
    size_t v9 = v4;
  }
  if ((v3 & 0x80u) == 0) {
    uint64_t v10 = (void **)&v15;
  }
  else {
    uint64_t v10 = v5;
  }
  if (v9 >= v7) {
    size_t v11 = v7;
  }
  else {
    size_t v11 = v9;
  }
  unsigned int v12 = memcmp(p_p, v10, v11);
  if ((v3 & 0x80) != 0)
  {
    operator delete(v5);
    if ((v20 & 0x8000000000000000) == 0) {
      goto LABEL_24;
    }
  }
  else if ((v6 & 0x80) == 0)
  {
    goto LABEL_24;
  }
  operator delete(__p);
LABEL_24:
  unsigned int v13 = v9 < v7;
  if (v7 < v9) {
    unsigned int v13 = -1;
  }
  if (v12) {
    return v12;
  }
  else {
    return v13;
  }
}

void sub_10056D00C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_10056D028(std::locale *a1, const char *a2, int a3)
{
  __int16 v5 = sub_100565488(a1);
  LODWORD(v5[3].__locale_) = a3;
  *(_OWORD *)((char *)&v5[3].__locale_ + 4) = 0u;
  *(_OWORD *)((char *)&v5[5].__locale_ + 4) = 0u;
  HIDWORD(v5[7].__locale_) = 0;
  strlen(a2);
  sub_10056D0C0();
}

void sub_10056D0A0(_Unwind_Exception *a1)
{
  locale = (std::__shared_weak_count *)v1[6].__locale_;
  if (locale) {
    sub_10004D2C8(locale);
  }
  std::locale::~locale(v1);
  _Unwind_Resume(a1);
}

void sub_10056D0C0()
{
}

void sub_10056D280(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

char *sub_10056D2B4(uint64_t a1, unsigned __int8 *a2, char *a3)
{
  char v6 = a2;
  do
  {
    size_t v7 = v6;
    char v6 = sub_10056D838(a1, (char *)v6, a3);
  }
  while (v6 != v7);
  if (v7 == a2) {
    operator new();
  }
  if (v7 != (unsigned __int8 *)a3)
  {
    if (*v7 == 124)
    {
      uint64_t v8 = v7 + 1;
      size_t v9 = v7 + 1;
      do
      {
        uint64_t v10 = v9;
        size_t v9 = sub_10056D838(a1, (char *)v9, a3);
      }
      while (v9 != v10);
      if (v10 == v8) {
        operator new();
      }
      sub_100566038();
    }
    return (char *)v7;
  }
  return a3;
}

unsigned __int8 *sub_10056D414(uint64_t a1, unsigned __int8 *a2, unsigned __int8 *a3)
{
  unsigned int v3 = a2;
  if (a2 == a3) {
    return a2;
  }
  size_t v4 = a3;
  if (*a2 == 94) {
    sub_100566A7C();
  }
  if (a2 != a3)
  {
    do
    {
      char v6 = v3;
      unsigned int v3 = sub_10056F740(a1, v3, v4);
    }
    while (v3 != v6);
    if (v6 != v4)
    {
      if (v6 + 1 == v4 && *v6 == 36) {
        sub_100566B00();
      }
      sub_10056BEE8();
    }
  }
  return v4;
}

unsigned __int8 *sub_10056D4C4(uint64_t a1, char *a2, char *a3)
{
  unsigned int v3 = a3;
  char v6 = sub_10056FC44(a1, a2, a3);
  if (v6 == (unsigned __int8 *)a2) {
LABEL_8:
  }
    sub_10056BEE8();
  if (v6 != (unsigned __int8 *)v3)
  {
    if (*v6 == 124)
    {
      if (sub_10056FC44(a1, (char *)v6 + 1, v3) != v6 + 1) {
        sub_100566038();
      }
      goto LABEL_8;
    }
    return v6;
  }
  return (unsigned __int8 *)v3;
}

unsigned __int8 *sub_10056D568(uint64_t a1, unsigned __int8 *__s, unsigned __int8 *a3)
{
  char v6 = (unsigned __int8 *)memchr(__s, 10, a3 - __s);
  if (v6) {
    size_t v7 = v6;
  }
  else {
    size_t v7 = a3;
  }
  if (v7 == __s) {
    operator new();
  }
  sub_10056D414(a1, __s, v7);
  if (v7 == a3) {
    uint64_t v10 = v7;
  }
  else {
    uint64_t v10 = v7 + 1;
  }
  if (v10 != a3)
  {
    uint64_t v8 = (unsigned __int8 *)memchr(v10, 10, a3 - v10);
    if (v8) {
      size_t v9 = v8;
    }
    else {
      size_t v9 = a3;
    }
    if (v9 != v10)
    {
      sub_10056D414(a1, v10, v9);
      sub_100566038();
    }
    operator new();
  }
  return a3;
}

char *sub_10056D6D0(uint64_t a1, char *__s, char *a3)
{
  char v6 = (char *)memchr(__s, 10, a3 - __s);
  if (v6) {
    size_t v7 = v6;
  }
  else {
    size_t v7 = a3;
  }
  if (v7 == __s) {
    operator new();
  }
  sub_10056D4C4(a1, __s, v7);
  if (v7 == a3) {
    uint64_t v10 = v7;
  }
  else {
    uint64_t v10 = v7 + 1;
  }
  if (v10 != a3)
  {
    uint64_t v8 = (char *)memchr(v10, 10, a3 - v10);
    if (v8) {
      size_t v9 = v8;
    }
    else {
      size_t v9 = a3;
    }
    if (v9 != v10)
    {
      sub_10056D4C4(a1, v10, v9);
      sub_100566038();
    }
    operator new();
  }
  return a3;
}

unsigned __int8 *sub_10056D838(uint64_t a1, char *a2, char *a3)
{
  uint64_t result = (unsigned __int8 *)sub_10056D8E0(a1, a2, a3);
  if (result == (unsigned __int8 *)a2)
  {
    size_t v7 = sub_10056DB08(a1, (unsigned __int8 *)a2, a3);
    uint64_t result = (unsigned __int8 *)a2;
    if (v7 != (unsigned __int8 *)a2)
    {
      return sub_10056DD50(a1, v7, (unsigned __int8 *)a3);
    }
  }
  return result;
}

char *sub_10056D8E0(uint64_t a1, char *a2, char *a3)
{
  if (a2 != a3)
  {
    int v6 = *a2;
    if (v6 > 91)
    {
      if (v6 == 92)
      {
        if (a2 + 1 != a3)
        {
          int v13 = a2[1];
          if (v13 == 66 || v13 == 98) {
            sub_100566B84();
          }
        }
      }
      else if (v6 == 94)
      {
        sub_100566A7C();
      }
    }
    else
    {
      if (v6 == 36) {
        sub_100566B00();
      }
      BOOL v8 = v6 == 40;
      size_t v7 = a2 + 1;
      BOOL v8 = !v8 || v7 == a3;
      if (!v8)
      {
        BOOL v8 = *v7 == 63;
        size_t v9 = a2 + 2;
        if (v8 && v9 != a3)
        {
          int v11 = *v9;
          if (v11 == 33)
          {
            long long v14 = 0u;
            memset(v15, 0, sizeof(v15));
            sub_100565488((std::locale *)&v14);
            memset((char *)v15 + 8, 0, 40);
            DWORD2(v15[0]) = *(_DWORD *)(a1 + 24);
            sub_10056D0C0(&v14, a2 + 3, a3);
            sub_100566C18();
          }
          if (v11 == 61)
          {
            long long v14 = 0u;
            memset(v15, 0, sizeof(v15));
            sub_100565488((std::locale *)&v14);
            memset((char *)v15 + 8, 0, 40);
            DWORD2(v15[0]) = *(_DWORD *)(a1 + 24);
            sub_10056D0C0(&v14, a2 + 3, a3);
            sub_100566C18();
          }
        }
      }
    }
  }
  return a2;
}

void sub_10056DAE8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, std::locale a9)
{
}

unsigned __int8 *sub_10056DB08(uint64_t a1, unsigned __int8 *a2, char *a3)
{
  unsigned int v3 = a2;
  if (a2 == (unsigned __int8 *)a3) {
    return v3;
  }
  int v6 = (char)*a2;
  if (v6 <= 62)
  {
    if (v6 != 40)
    {
      if (v6 == 46) {
        operator new();
      }
      if ((v6 - 42) >= 2) {
        goto LABEL_28;
      }
LABEL_34:
      sub_100567DA4();
    }
    if (a2 + 1 != (unsigned __int8 *)a3)
    {
      if (a2 + 2 != (unsigned __int8 *)a3 && a2[1] == 63 && a2[2] == 58)
      {
        BOOL v8 = (_DWORD *)(a1 + 36);
        ++*(_DWORD *)(a1 + 36);
        size_t v9 = (char *)sub_10056D2B4(a1, a2 + 3, a3);
        if (v9 == a3) {
          goto LABEL_35;
        }
        uint64_t v10 = v9;
        if (*v9 != 41) {
          goto LABEL_35;
        }
        goto LABEL_25;
      }
      sub_100567CA4(a1);
      BOOL v8 = (_DWORD *)(a1 + 36);
      ++*(_DWORD *)(a1 + 36);
      int v11 = (char *)sub_10056D2B4(a1, v3 + 1, a3);
      if (v11 != a3)
      {
        uint64_t v10 = v11;
        if (*v11 == 41)
        {
          sub_100567D28(a1);
LABEL_25:
          --*v8;
          return (unsigned __int8 *)(v10 + 1);
        }
      }
    }
LABEL_35:
    sub_100566CC0();
  }
  if (v6 <= 91)
  {
    if (v6 == 91)
    {
      return sub_10056E0FC(a1, a2, a3);
    }
    if (v6 == 63) {
      goto LABEL_34;
    }
LABEL_28:
    return sub_10056E210(a1, a2, a3);
  }
  if (v6 != 92)
  {
    if (v6 == 123) {
      goto LABEL_34;
    }
    goto LABEL_28;
  }

  return sub_10056E058(a1, a2, (unsigned __int8 *)a3);
}

unsigned __int8 *sub_10056DD50(uint64_t a1, unsigned __int8 *a2, unsigned __int8 *a3)
{
  if (a2 == a3) {
    return a2;
  }
  int v5 = (char)*a2;
  if (v5 <= 62)
  {
    if (v5 == 42 || v5 == 43) {
LABEL_18:
    }
      sub_10056B8E8();
    return a2;
  }
  if (v5 == 63) {
    goto LABEL_18;
  }
  if (v5 == 123)
  {
    int v13 = 0;
    int v6 = a2 + 1;
    size_t v7 = sub_10056F6A0(a1, a2 + 1, a3, &v13);
    if (v7 == v6) {
      goto LABEL_23;
    }
    if (v7 != a3)
    {
      int v8 = (char)*v7;
      if (v8 != 44)
      {
        if (v8 == 125) {
          goto LABEL_18;
        }
LABEL_23:
        sub_10056BB14();
      }
      size_t v9 = v7 + 1;
      if (v7 + 1 == a3) {
        goto LABEL_23;
      }
      if (*v9 == 125) {
        goto LABEL_18;
      }
      int v12 = -1;
      int v11 = sub_10056F6A0(a1, v9, a3, &v12);
      if (v11 != v9 && v11 != a3 && *v11 == 125)
      {
        if (v12 >= v13) {
          goto LABEL_18;
        }
        goto LABEL_23;
      }
    }
    sub_10056BB6C();
  }
  return a2;
}

unsigned __int8 *sub_10056E058(uint64_t a1, unsigned __int8 *a2, unsigned __int8 *a3)
{
  if (a2 == a3 || *a2 != 92) {
    return a2;
  }
  int v5 = a2 + 1;
  if (a2 + 1 == a3) {
    sub_100567EF4();
  }
  uint64_t result = sub_10056E284(a1, a2 + 1, a3);
  if (result == v5)
  {
    uint64_t result = (unsigned __int8 *)sub_10056E344(a1, (char *)a2 + 1, (char *)a3);
    if (result == v5)
    {
      uint64_t result = sub_10056E414(a1, a2 + 1, a3, 0);
      if (result == v5) {
        return a2;
      }
    }
  }
  return result;
}

unsigned char *sub_10056E0FC(uint64_t a1, unsigned char *a2, unsigned char *a3)
{
  if (a2 != a3 && *a2 == 91)
  {
    if (a2 + 1 != a3) {
      sub_100569160();
    }
    sub_10056A30C();
  }
  return a2;
}

unsigned char *sub_10056E210(uint64_t a1, unsigned char *a2, unsigned char *a3)
{
  if (a2 != a3)
  {
    int v3 = (char)*a2;
    BOOL v4 = (v3 - 36) > 0x3A || ((1 << (*a2 - 36)) & 0x7800000080004F1) == 0;
    if (v4 && (v3 - 123) >= 3) {
      sub_100568348(a1);
    }
  }
  return a2;
}

unsigned __int8 *sub_10056E284(uint64_t a1, unsigned __int8 *a2, unsigned __int8 *a3)
{
  if (a2 != a3)
  {
    int v4 = *a2;
    unsigned int v5 = v4 - 48;
    if (v4 == 48) {
      sub_100568348(a1);
    }
    if ((v4 - 49) <= 8)
    {
      int v6 = a2 + 1;
      if (a2 + 1 == a3) {
        goto LABEL_12;
      }
      do
      {
        int v7 = *v6;
        if ((v7 - 48) > 9) {
          break;
        }
        if (v5 >= 0x19999999) {
          goto LABEL_14;
        }
        ++v6;
        unsigned int v5 = v7 + 10 * v5 - 48;
      }
      while (v6 != a3);
      if (v5)
      {
LABEL_12:
        if (v5 <= *(_DWORD *)(a1 + 28)) {
          sub_1005684E0(a1);
        }
      }
LABEL_14:
      sub_100568488();
    }
  }
  return a2;
}

char *sub_10056E344(uint64_t a1, char *a2, char *a3)
{
  if (a2 == a3) {
    return a2;
  }
  int v3 = *a2;
  if (v3 > 99)
  {
    if (v3 == 119) {
      goto LABEL_12;
    }
    if (v3 == 115) {
LABEL_13:
    }
      sub_100569160();
    if (v3 != 100) {
      return a2;
    }
LABEL_10:
    sub_100569160();
  }
  switch(v3)
  {
    case 'D':
      goto LABEL_10;
    case 'S':
      goto LABEL_13;
    case 'W':
LABEL_12:
      sub_100569160();
  }
  return a2;
}

unsigned __int8 *sub_10056E414(uint64_t a1, unsigned __int8 *a2, unsigned __int8 *a3, uint64_t *a4)
{
  int v4 = a2;
  if (a2 == a3) {
    return v4;
  }
  uint64_t v5 = *a2;
  if ((char)v5 > 109)
  {
    switch((char)v5)
    {
      case 'n':
        if (!a4) {
          goto LABEL_60;
        }
        if (*((char *)a4 + 23) < 0)
        {
          a4[1] = 1;
          a4 = (uint64_t *)*a4;
        }
        else
        {
          *((unsigned char *)a4 + 23) = 1;
        }
        __int16 v14 = 10;
        goto LABEL_72;
      case 'r':
        if (!a4) {
          goto LABEL_60;
        }
        if (*((char *)a4 + 23) < 0)
        {
          a4[1] = 1;
          a4 = (uint64_t *)*a4;
        }
        else
        {
          *((unsigned char *)a4 + 23) = 1;
        }
        __int16 v14 = 13;
        goto LABEL_72;
      case 't':
        if (!a4) {
          goto LABEL_60;
        }
        if (*((char *)a4 + 23) < 0)
        {
          a4[1] = 1;
          a4 = (uint64_t *)*a4;
        }
        else
        {
          *((unsigned char *)a4 + 23) = 1;
        }
        __int16 v14 = 9;
        goto LABEL_72;
      case 'u':
        if (a2 + 1 != a3)
        {
          int v6 = a2[1];
          if ((v6 & 0xF8) == 0x30 || (v6 & 0xFE) == 0x38 || (v6 | 0x20u) - 97 < 6)
          {
            int v4 = a2 + 2;
            if (a2 + 2 != a3)
            {
              int v7 = *v4;
              if ((v7 & 0xF8) == 0x30 || (v7 & 0xFE) == 0x38 || (v7 | 0x20u) - 97 < 6) {
                goto LABEL_27;
              }
            }
          }
        }
        goto LABEL_81;
      case 'v':
        if (!a4) {
          goto LABEL_60;
        }
        if (*((char *)a4 + 23) < 0)
        {
          a4[1] = 1;
          a4 = (uint64_t *)*a4;
        }
        else
        {
          *((unsigned char *)a4 + 23) = 1;
        }
        __int16 v14 = 11;
        goto LABEL_72;
      case 'x':
LABEL_27:
        if (v4 + 1 == a3) {
          goto LABEL_81;
        }
        unsigned __int8 v8 = v4[1];
        char v9 = -48;
        if ((v8 & 0xF8) == 0x30 || (v8 & 0xFE) == 0x38) {
          goto LABEL_32;
        }
        v8 |= 0x20u;
        if ((v8 - 97) >= 6u) {
          goto LABEL_81;
        }
        char v9 = -87;
LABEL_32:
        if (v4 + 2 == a3) {
          goto LABEL_81;
        }
        unsigned __int8 v10 = v4[2];
        char v11 = -48;
        if ((v10 & 0xF8) == 0x30 || (v10 & 0xFE) == 0x38) {
          goto LABEL_37;
        }
        v10 |= 0x20u;
        if ((v10 - 97) >= 6u) {
          goto LABEL_81;
        }
        char v11 = -87;
LABEL_37:
        char v12 = v10 + 16 * (v8 + v9) + v11;
        if (!a4) {
          sub_100568348(a1);
        }
        if (*((char *)a4 + 23) < 0)
        {
          a4[1] = 1;
          a4 = (uint64_t *)*a4;
        }
        else
        {
          *((unsigned char *)a4 + 23) = 1;
        }
        *(unsigned char *)a4 = v12;
        *((unsigned char *)a4 + 1) = 0;
        v4 += 3;
        break;
      default:
        goto LABEL_51;
    }
    return v4;
  }
  if ((char)v5 == 48)
  {
    if (!a4) {
      goto LABEL_60;
    }
    if (*((char *)a4 + 23) < 0)
    {
      a4[1] = 1;
      a4 = (uint64_t *)*a4;
    }
    else
    {
      *((unsigned char *)a4 + 23) = 1;
    }
    *(_WORD *)a4 = 0;
    return a2 + 1;
  }
  if ((char)v5 != 99)
  {
    if ((char)v5 == 102)
    {
      if (a4)
      {
        if (*((char *)a4 + 23) < 0)
        {
          a4[1] = 1;
          a4 = (uint64_t *)*a4;
        }
        else
        {
          *((unsigned char *)a4 + 23) = 1;
        }
        __int16 v14 = 12;
LABEL_72:
        *(_WORD *)a4 = v14;
        return a2 + 1;
      }
LABEL_60:
      sub_100568348(a1);
    }
LABEL_51:
    if ((char)v5 != 95
      && ((char)v5 < 0 || (*(_DWORD *)(*(void *)(*(void *)(a1 + 8) + 16) + 4 * v5) & 0x500) == 0))
    {
      if (!a4) {
        goto LABEL_60;
      }
      if (*((char *)a4 + 23) < 0)
      {
        a4[1] = 1;
        a4 = (uint64_t *)*a4;
      }
      else
      {
        *((unsigned char *)a4 + 23) = 1;
      }
      *(unsigned char *)a4 = v5;
      *((unsigned char *)a4 + 1) = 0;
      return a2 + 1;
    }
LABEL_81:
    sub_100567EF4();
  }
  if (a2 + 1 == a3) {
    goto LABEL_81;
  }
  unsigned __int8 v13 = a2[1];
  if (((v13 & 0xDF) - 65) > 0x19u) {
    goto LABEL_81;
  }
  if (!a4) {
    sub_100568348(a1);
  }
  if (*((char *)a4 + 23) < 0)
  {
    a4[1] = 1;
    a4 = (uint64_t *)*a4;
  }
  else
  {
    *((unsigned char *)a4 + 23) = 1;
  }
  *(unsigned char *)a4 = v13 & 0x1F;
  *((unsigned char *)a4 + 1) = 0;
  return a2 + 2;
}

char *sub_10056E800(uint64_t a1, char *a2, char *a3, uint64_t *a4)
{
  int v4 = a2;
  if (a2 == a3) {
    return v4;
  }
  int v5 = *a2;
  if (v5 == 93) {
    return v4;
  }
  uint64_t v6 = (uint64_t)a4;
  unsigned int v9 = 0;
  uint64_t v10 = 0;
  long long v31 = 0uLL;
  uint64_t v32 = 0;
  if (a2 + 1 != a3 && v5 == 91)
  {
    int v11 = a2[1];
    switch(v11)
    {
      case '.':
        int v4 = (char *)sub_10056EE88(a1, a2 + 2, a3, (uint64_t)&v31);
        unsigned int v9 = HIBYTE(v32);
        uint64_t v10 = *((void *)&v31 + 1);
        break;
      case ':':
        uint64_t v12 = sub_10056EDCC(a1, a2 + 2, a3, (uint64_t)a4);
        goto LABEL_11;
      case '=':
        uint64_t v12 = sub_10056EBD4(a1, a2 + 2, a3, a4);
LABEL_11:
        uint64_t v6 = v12;
        char v13 = 0;
        goto LABEL_44;
      default:
        uint64_t v10 = 0;
        unsigned int v9 = 0;
        break;
    }
  }
  int v14 = *(_DWORD *)(a1 + 24) & 0x1F0;
  if ((v9 & 0x80u) == 0) {
    uint64_t v10 = v9;
  }
  if (v10)
  {
    long long v15 = v4;
    goto LABEL_28;
  }
  if ((*(_DWORD *)(a1 + 24) & 0x1B0 | 0x40) == 0x40)
  {
    int v16 = *v4;
    if (v16 == 92)
    {
      uint64_t v17 = v4 + 1;
      if (v14) {
        long long v18 = sub_10056F0F0(a1, v17, a3, (uint64_t *)&v31);
      }
      else {
        long long v18 = (char *)sub_10056EF78(a1, (unsigned __int8 *)v17, (unsigned __int8 *)a3, (uint64_t)&v31, v6);
      }
      long long v15 = v18;
      goto LABEL_28;
    }
  }
  else
  {
    LOBYTE(v16) = *v4;
  }
  if ((v9 & 0x80) != 0)
  {
    size_t v19 = (long long *)v31;
    *((void *)&v31 + 1) = 1;
  }
  else
  {
    HIBYTE(v32) = 1;
    size_t v19 = &v31;
  }
  *(unsigned char *)size_t v19 = v16;
  *((unsigned char *)v19 + 1) = 0;
  long long v15 = v4 + 1;
LABEL_28:
  if (v15 == a3
    || (int v20 = *v15, v20 == 93)
    || (long long v21 = v15 + 1, v15 + 1 == a3)
    || v20 != 45
    || *v21 == 93)
  {
    if (SHIBYTE(v32) < 0)
    {
      if (*((void *)&v31 + 1))
      {
        if (*((void *)&v31 + 1) != 1)
        {
          uint64_t v22 = (char *)v31;
LABEL_42:
          sub_10056ACFC(v6, *v22, v22[1]);
          goto LABEL_43;
        }
        uint64_t v22 = (char *)v31;
        goto LABEL_40;
      }
    }
    else if (HIBYTE(v32))
    {
      uint64_t v22 = (char *)&v31;
      if (HIBYTE(v32) != 1) {
        goto LABEL_42;
      }
LABEL_40:
      sub_1005691FC(v6, *v22);
    }
LABEL_43:
    char v13 = 1;
    int v4 = v15;
    goto LABEL_44;
  }
  int v4 = v15 + 2;
  v29[0] = 0;
  v29[1] = 0;
  uint64_t v30 = 0;
  if (v15 + 2 != a3 && *v21 == 91 && *v4 == 46)
  {
    uint64_t v24 = sub_10056EE88(a1, v15 + 3, a3, (uint64_t)v29);
LABEL_60:
    int v4 = (char *)v24;
    goto LABEL_61;
  }
  if ((v14 | 0x40) == 0x40)
  {
    LODWORD(v21) = *v21;
    if (v21 == 92)
    {
      if (v14) {
        uint64_t v24 = (uint64_t)sub_10056F0F0(a1, v15 + 2, a3, (uint64_t *)v29);
      }
      else {
        uint64_t v24 = (uint64_t)sub_10056EF78(a1, (unsigned __int8 *)v15 + 2, (unsigned __int8 *)a3, (uint64_t)v29, v6);
      }
      goto LABEL_60;
    }
  }
  else
  {
    LOBYTE(v21) = *v21;
  }
  HIBYTE(v30) = 1;
  LOWORD(v29[0]) = v21;
LABEL_61:
  *(_OWORD *)long long v27 = v31;
  uint64_t v28 = v32;
  uint64_t v32 = 0;
  long long v31 = 0uLL;
  *(_OWORD *)std::string __p = *(_OWORD *)v29;
  uint64_t v26 = v30;
  v29[0] = 0;
  v29[1] = 0;
  uint64_t v30 = 0;
  sub_10056A8D4(v6, (char *)v27, (char *)__p);
  if (SHIBYTE(v26) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v28) < 0) {
    operator delete(v27[0]);
  }
  if (SHIBYTE(v30) < 0) {
    operator delete(v29[0]);
  }
  char v13 = 1;
LABEL_44:
  if (SHIBYTE(v32) < 0) {
    operator delete((void *)v31);
  }
  if (v13) {
    return v4;
  }
  return (char *)v6;
}

void sub_10056EB74(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  if (a28 < 0) {
    operator delete(__p);
  }
  if (*(char *)(v28 - 49) < 0) {
    operator delete(*(void **)(v28 - 72));
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10056EBD4(uint64_t a1, char *a2, char *a3, uint64_t *a4)
{
  if (a3 - a2 < 2 || a3 - 1 == a2) {
    goto LABEL_33;
  }
  for (uint64_t i = 0; a2[i] != 61 || a2[i + 1] != 93; ++i)
  {
    if (a3 - a2 - 2 == i) {
      goto LABEL_33;
    }
  }
  if (&a2[i] == a3) {
LABEL_33:
  }
    sub_10056A30C();
  uint64_t v17 = 0;
  uint64_t v18 = 0;
  uint64_t v19 = 0;
  sub_10056F40C(a1, a2, &a2[i], (uint64_t)&v17);
  if ((SHIBYTE(v19) & 0x80000000) == 0)
  {
    uint64_t v8 = HIBYTE(v19);
    if (HIBYTE(v19))
    {
      long long __p = 0uLL;
      unsigned int v9 = (char *)&v17;
      uint64_t v16 = 0;
      goto LABEL_14;
    }
LABEL_34:
    sub_10056AF58();
  }
  uint64_t v8 = v18;
  if (!v18) {
    goto LABEL_34;
  }
  long long __p = 0uLL;
  uint64_t v16 = 0;
  unsigned int v9 = (char *)v17;
LABEL_14:
  sub_10056B1B8(a1, v9, &v9[v8], (uint64_t *)&__p);
  uint64_t v10 = HIBYTE(v16);
  if (v16 < 0) {
    uint64_t v10 = *((void *)&__p + 1);
  }
  if (v10)
  {
    sub_10056AFB0(a4, &__p);
  }
  else
  {
    uint64_t v11 = HIBYTE(v19);
    if (v19 < 0) {
      uint64_t v11 = v18;
    }
    if (v11 == 2)
    {
      char v13 = (char *)&v17;
      if (v19 < 0) {
        char v13 = (char *)v17;
      }
      sub_10056ACFC((uint64_t)a4, *v13, v13[1]);
    }
    else
    {
      if (v11 != 1) {
        sub_10056AF58();
      }
      uint64_t v12 = (char *)&v17;
      if (v19 < 0) {
        uint64_t v12 = (char *)v17;
      }
      sub_1005691FC((uint64_t)a4, *v12);
    }
  }
  if (SHIBYTE(v16) < 0) {
    operator delete((void *)__p);
  }
  if (SHIBYTE(v19) < 0) {
    operator delete(v17);
  }
  return (uint64_t)&a2[i + 2];
}

void sub_10056ED94(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10056EDCC(uint64_t a1, char *a2, char *a3, uint64_t a4)
{
  if (a3 - a2 < 2 || a3 - 1 == a2) {
    goto LABEL_11;
  }
  for (uint64_t i = 0; a2[i] != 58 || a2[i + 1] != 93; ++i)
  {
    if (a3 - a2 - 2 == i) {
      goto LABEL_11;
    }
  }
  if (&a2[i] == a3) {
LABEL_11:
  }
    sub_10056A30C();
  int v7 = sub_10056F5C4(a1, a2, &a2[i], *(unsigned char *)(a1 + 24) & 1);
  if (!v7) {
    sub_10056B2D8();
  }
  *(_DWORD *)(a4 + 160) |= v7;
  return (uint64_t)&a2[i + 2];
}

uint64_t sub_10056EE88(uint64_t a1, char *a2, char *a3, uint64_t a4)
{
  if (a3 - a2 < 2 || a3 - 1 == a2) {
    goto LABEL_15;
  }
  for (uint64_t i = 0; a2[i] != 46 || a2[i + 1] != 93; ++i)
  {
    if (a3 - a2 - 2 == i) {
      goto LABEL_15;
    }
  }
  if (&a2[i] == a3) {
LABEL_15:
  }
    sub_10056A30C();
  sub_10056F40C(a1, a2, &a2[i], (uint64_t)&v10);
  if (*(char *)(a4 + 23) < 0) {
    operator delete(*(void **)a4);
  }
  *(_OWORD *)a4 = v10;
  unint64_t v7 = v11;
  *(void *)(a4 + 16) = v11;
  unint64_t v8 = HIBYTE(v7);
  if ((v8 & 0x80u) != 0) {
    unint64_t v8 = *(void *)(a4 + 8);
  }
  if (v8 - 1 >= 2) {
    sub_10056AF58();
  }
  return (uint64_t)&a2[i + 2];
}

unsigned __int8 *sub_10056EF78(uint64_t a1, unsigned __int8 *a2, unsigned __int8 *a3, uint64_t a4, uint64_t a5)
{
  if (a2 == a3) {
    sub_100567EF4();
  }
  int v6 = (char)*a2;
  if (v6 > 97)
  {
    if (v6 > 114)
    {
      if (v6 != 115)
      {
        if (v6 != 119) {
          goto LABEL_25;
        }
        *(_DWORD *)(a5 + 160) |= 0x500u;
        sub_1005691FC(a5, 95);
        return a2 + 1;
      }
      int v8 = *(_DWORD *)(a5 + 160) | 0x4000;
    }
    else
    {
      if (v6 == 98)
      {
        if (*(char *)(a4 + 23) < 0)
        {
          *(void *)(a4 + 8) = 1;
          a4 = *(void *)a4;
        }
        else
        {
          *(unsigned char *)(a4 + 23) = 1;
        }
        *(_WORD *)a4 = 8;
        return a2 + 1;
      }
      if (v6 != 100) {
        goto LABEL_25;
      }
      int v8 = *(_DWORD *)(a5 + 160) | 0x400;
    }
    *(_DWORD *)(a5 + 160) = v8;
    return a2 + 1;
  }
  if (v6 <= 82)
  {
    if (!*a2)
    {
      if (*(char *)(a4 + 23) < 0)
      {
        *(void *)(a4 + 8) = 1;
        a4 = *(void *)a4;
      }
      else
      {
        *(unsigned char *)(a4 + 23) = 1;
      }
      *(unsigned char *)a4 = 0;
      *(unsigned char *)(a4 + 1) = 0;
      return a2 + 1;
    }
    if (v6 == 68)
    {
      int v7 = *(_DWORD *)(a5 + 164) | 0x400;
LABEL_22:
      *(_DWORD *)(a5 + 164) = v7;
      return a2 + 1;
    }
    goto LABEL_25;
  }
  if (v6 == 83)
  {
    int v7 = *(_DWORD *)(a5 + 164) | 0x4000;
    goto LABEL_22;
  }
  if (v6 == 87)
  {
    *(_DWORD *)(a5 + 164) |= 0x500u;
    sub_10056B330(a5, 95);
    return a2 + 1;
  }
LABEL_25:

  return sub_10056E414(a1, a2, a3, (uint64_t *)a4);
}

char *sub_10056F0F0(uint64_t a1, char *a2, char *a3, uint64_t *a4)
{
  if (a2 == a3) {
LABEL_78:
  }
    sub_100567EF4();
  int v4 = *a2;
  char v5 = *a2;
  if (v4 > 97)
  {
    switch(*a2)
    {
      case 'n':
        if (!a4) {
          goto LABEL_60;
        }
        if (*((char *)a4 + 23) < 0)
        {
          a4[1] = 1;
          a4 = (uint64_t *)*a4;
        }
        else
        {
          *((unsigned char *)a4 + 23) = 1;
        }
        __int16 v11 = 10;
        goto LABEL_75;
      case 'o':
      case 'p':
      case 'q':
      case 's':
      case 'u':
        goto LABEL_25;
      case 'r':
        if (!a4) {
          goto LABEL_60;
        }
        if (*((char *)a4 + 23) < 0)
        {
          a4[1] = 1;
          a4 = (uint64_t *)*a4;
        }
        else
        {
          *((unsigned char *)a4 + 23) = 1;
        }
        __int16 v11 = 13;
        goto LABEL_75;
      case 't':
        if (!a4) {
          goto LABEL_60;
        }
        if (*((char *)a4 + 23) < 0)
        {
          a4[1] = 1;
          a4 = (uint64_t *)*a4;
        }
        else
        {
          *((unsigned char *)a4 + 23) = 1;
        }
        __int16 v11 = 9;
        goto LABEL_75;
      case 'v':
        if (!a4) {
          goto LABEL_60;
        }
        if (*((char *)a4 + 23) < 0)
        {
          a4[1] = 1;
          a4 = (uint64_t *)*a4;
        }
        else
        {
          *((unsigned char *)a4 + 23) = 1;
        }
        __int16 v11 = 11;
        goto LABEL_75;
      default:
        if (v4 == 98)
        {
          if (!a4) {
            goto LABEL_60;
          }
          if (*((char *)a4 + 23) < 0)
          {
            a4[1] = 1;
            a4 = (uint64_t *)*a4;
          }
          else
          {
            *((unsigned char *)a4 + 23) = 1;
          }
          __int16 v11 = 8;
        }
        else
        {
          if (v4 != 102) {
            goto LABEL_25;
          }
          if (!a4) {
            goto LABEL_60;
          }
          if (*((char *)a4 + 23) < 0)
          {
            a4[1] = 1;
            a4 = (uint64_t *)*a4;
          }
          else
          {
            *((unsigned char *)a4 + 23) = 1;
          }
          __int16 v11 = 12;
        }
        break;
    }
    goto LABEL_75;
  }
  if (v4 > 91)
  {
    if (v4 == 92) {
      goto LABEL_16;
    }
    if (v4 != 97) {
      goto LABEL_25;
    }
    if (!a4) {
      goto LABEL_60;
    }
    if (*((char *)a4 + 23) < 0)
    {
      a4[1] = 1;
      a4 = (uint64_t *)*a4;
    }
    else
    {
      *((unsigned char *)a4 + 23) = 1;
    }
    __int16 v11 = 7;
LABEL_75:
    *(_WORD *)a4 = v11;
    return a2 + 1;
  }
  if (v4 == 34 || v4 == 47)
  {
LABEL_16:
    if (a4)
    {
      if (*((char *)a4 + 23) < 0)
      {
        a4[1] = 1;
        a4 = (uint64_t *)*a4;
      }
      else
      {
        *((unsigned char *)a4 + 23) = 1;
      }
      *(unsigned char *)a4 = v5;
      *((unsigned char *)a4 + 1) = 0;
      return a2 + 1;
    }
LABEL_60:
    sub_100568348(a1);
  }
LABEL_25:
  if ((v5 & 0xF8) != 0x30) {
    goto LABEL_78;
  }
  char v6 = v4 - 48;
  int v7 = a2 + 1;
  if (a2 + 1 == a3)
  {
LABEL_48:
    int v7 = a3;
    goto LABEL_49;
  }
  if ((*v7 & 0xF8) == 0x30)
  {
    char v6 = *v7 + 8 * v6 - 48;
    if (a2 + 2 != a3)
    {
      char v8 = a2[2];
      int v9 = v8 & 0xF8;
      char v10 = v8 + 8 * v6 - 48;
      if (v9 == 48) {
        int v7 = a2 + 3;
      }
      else {
        int v7 = a2 + 2;
      }
      if (v9 == 48) {
        char v6 = v10;
      }
      goto LABEL_49;
    }
    goto LABEL_48;
  }
LABEL_49:
  if (!a4) {
    sub_100568348(a1);
  }
  if (*((char *)a4 + 23) < 0)
  {
    a4[1] = 1;
    a4 = (uint64_t *)*a4;
  }
  else
  {
    *((unsigned char *)a4 + 23) = 1;
  }
  *(unsigned char *)a4 = v6;
  *((unsigned char *)a4 + 1) = 0;
  return v7;
}

void sub_10056F40C(uint64_t a1@<X0>, char *a2@<X1>, char *a3@<X2>, uint64_t a4@<X8>)
{
  memset(&__s, 0, sizeof(__s));
  sub_10012CD04(&__s, a2, a3, a3 - a2);
  *(void *)a4 = 0;
  *(void *)(a4 + 8) = 0;
  *(void *)(a4 + 16) = 0;
  if (SHIBYTE(__s.__r_.__value_.__r.__words[2]) < 0)
  {
    if (!__s.__r_.__value_.__l.__size_) {
      goto LABEL_9;
    }
    p_s = (std::string *)__s.__r_.__value_.__r.__words[0];
  }
  else
  {
    if (!*((unsigned char *)&__s.__r_.__value_.__s + 23)) {
      return;
    }
    p_s = &__s;
  }
  std::__get_collation_name(&v11, (const char *)p_s);
  *(_OWORD *)a4 = *(_OWORD *)&v11.__r_.__value_.__l.__data_;
  unint64_t v7 = v11.__r_.__value_.__r.__words[2];
  *(void *)(a4 + 16) = *((void *)&v11.__r_.__value_.__l + 2);
  unint64_t v8 = HIBYTE(v7);
  if ((v8 & 0x80u) != 0) {
    unint64_t v8 = *(void *)(a4 + 8);
  }
  if (v8) {
    goto LABEL_9;
  }
  if (SHIBYTE(__s.__r_.__value_.__r.__words[2]) < 0)
  {
    if (__s.__r_.__value_.__l.__size_ >= 3) {
      goto LABEL_9;
    }
  }
  else if (HIBYTE(__s.__r_.__value_.__r.__words[2]) >= 3u)
  {
    return;
  }
  (*(void (**)(std::string *__return_ptr))(**(void **)(a1 + 16) + 32))(&v11);
  if (*(char *)(a4 + 23) < 0) {
    operator delete(*(void **)a4);
  }
  *(std::string *)a4 = v11;
  if ((*(char *)(a4 + 23) & 0x80000000) == 0)
  {
    int v9 = *(unsigned __int8 *)(a4 + 23);
    if (v9 != 12 && v9 != 1)
    {
      *(unsigned char *)a4 = 0;
      *(unsigned char *)(a4 + 23) = 0;
      goto LABEL_9;
    }
    goto LABEL_23;
  }
  uint64_t v10 = *(void *)(a4 + 8);
  if (v10 == 1 || v10 == 12)
  {
LABEL_23:
    std::string::operator=((std::string *)a4, &__s);
    goto LABEL_9;
  }
  **(unsigned char **)a4 = 0;
  *(void *)(a4 + 8) = 0;
LABEL_9:
  if (SHIBYTE(__s.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__s.__r_.__value_.__l.__data_);
  }
}

void sub_10056F590(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (*(char *)(v17 + 23) < 0) {
    operator delete(*(void **)v17);
  }
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10056F5C4(uint64_t a1, char *a2, char *a3, BOOL a4)
{
  long long __p = 0;
  uint64_t v12 = 0;
  uint64_t v13 = 0;
  sub_10012CD04(&__p, a2, a3, a3 - a2);
  uint64_t v6 = HIBYTE(v13);
  if (v13 >= 0) {
    p_p = (char *)&__p;
  }
  else {
    p_p = (char *)__p;
  }
  if (v13 < 0) {
    uint64_t v6 = v12;
  }
  (*(void (**)(void, char *, char *))(**(void **)(a1 + 8) + 48))(*(void *)(a1 + 8), p_p, &p_p[v6]);
  if (v13 >= 0) {
    unint64_t v8 = (const char *)&__p;
  }
  else {
    unint64_t v8 = (const char *)__p;
  }
  uint64_t classname = std::__get_classname(v8, a4);
  if (SHIBYTE(v13) < 0) {
    operator delete(__p);
  }
  return classname;
}

void sub_10056F684(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

unsigned __int8 *sub_10056F6A0(uint64_t a1, unsigned __int8 *a2, unsigned __int8 *a3, int *a4)
{
  if (a2 != a3)
  {
    int v4 = *a2;
    if ((v4 & 0xF8) == 0x30 || (v4 & 0xFE) == 0x38)
    {
      int v5 = v4 - 48;
      *a4 = v5;
      if (++a2 == a3)
      {
        return a3;
      }
      else
      {
        while (1)
        {
          int v6 = *a2;
          if ((v6 & 0xF8) != 0x30 && (v6 & 0xFE) != 0x38) {
            break;
          }
          if (v5 >= 214748364) {
            sub_10056BB14();
          }
          int v5 = v6 + 10 * v5 - 48;
          *a4 = v5;
          if (++a2 == a3) {
            return a3;
          }
        }
      }
    }
  }
  return a2;
}

unsigned __int8 *sub_10056F740(uint64_t a1, unsigned __int8 *a2, unsigned __int8 *a3)
{
  if (a2 == a3) {
    return a2;
  }
  int v6 = sub_10056F7DC(a1, a2, a3);
  if (v6 == a2) {
    return a2;
  }

  return sub_10056F8EC(a1, v6, a3);
}

unsigned char *sub_10056F7DC(uint64_t a1, unsigned char *a2, unsigned char *a3)
{
  int v6 = sub_10056FA90(a1, a2, a3);
  unint64_t v7 = v6;
  if (v6 == a2 && v6 != a3)
  {
    if (a2 + 1 == a3 || *a2 != 92)
    {
      return a2;
    }
    else
    {
      int v8 = a2[1];
      if (v8 == 40)
      {
        uint64_t v9 = (uint64_t)(a2 + 2);
        sub_100567CA4(a1);
        do
        {
          uint64_t v10 = (unsigned char *)v9;
          uint64_t v9 = sub_10056F740(a1, v9, a3);
        }
        while ((unsigned char *)v9 != v10);
        if (v10 == a3 || v10 + 1 == a3 || *v10 != 92 || v10[1] != 41) {
          sub_100566CC0();
        }
        unint64_t v7 = v10 + 2;
        sub_100567D28(a1);
      }
      else
      {
        int v12 = sub_10056C404(a1, v8);
        uint64_t v13 = 2;
        if (!v12) {
          uint64_t v13 = 0;
        }
        return &a2[v13];
      }
    }
  }
  return v7;
}

unsigned __int8 *sub_10056F8EC(uint64_t a1, unsigned __int8 *a2, unsigned __int8 *a3)
{
  if (a2 != a3)
  {
    int v4 = *a2;
    if (v4 == 42) {
      sub_10056B8E8();
    }
    if (a2 + 1 != a3 && v4 == 92 && a2[1] == 123)
    {
      int v6 = a2 + 2;
      int v13 = 0;
      unint64_t v7 = sub_10056F6A0(a1, a2 + 2, a3, &v13);
      if (v7 == v6) {
        goto LABEL_16;
      }
      if (v7 != a3)
      {
        int v8 = v7 + 1;
        int v9 = *v7;
        if (v9 == 44)
        {
          int v12 = -1;
          uint64_t v10 = sub_10056F6A0(a1, v8, a3, &v12);
          if (v10 != a3 && v10 + 1 != a3 && *v10 == 92 && v10[1] == 125)
          {
            if (v12 != -1 && v12 < v13) {
LABEL_16:
            }
              sub_10056BB14();
LABEL_20:
            sub_10056B8E8();
          }
        }
        else if (v8 != a3 && v9 == 92 && *v8 == 125)
        {
          goto LABEL_20;
        }
      }
      sub_10056BB6C();
    }
  }
  return a2;
}

unsigned char *sub_10056FA90(uint64_t a1, unsigned char *a2, unsigned char *a3)
{
  if (a2 == a3)
  {
    uint64_t result = sub_10056FBC8(a1, a2, a2);
    if (result != a2) {
      return result;
    }
    goto LABEL_12;
  }
  int v6 = *a2;
  if ((a2 + 1 != a3 || v6 != 36)
    && ((v6 - 46) > 0x2E || ((1 << (v6 - 46)) & 0x600000000001) == 0))
  {
    sub_100568348(a1);
  }
  uint64_t result = sub_10056FBC8(a1, a2, a3);
  if (result == a2)
  {
    if (*a2 == 46) {
      operator new();
    }
LABEL_12:
    return sub_10056E0FC(a1, a2, a3);
  }
  return result;
}

unsigned char *sub_10056FBC8(uint64_t a1, unsigned char *a2, unsigned char *a3)
{
  if (a2 != a3
    && a2 + 1 != a3
    && *a2 == 92
    && ((char)a2[1] - 36) <= 0x3A
    && ((1 << (a2[1] - 36)) & 0x580000000000441) != 0)
  {
    sub_100568348(a1);
  }
  return a2;
}

unsigned __int8 *sub_10056FC44(uint64_t a1, char *a2, char *a3)
{
  int v6 = sub_10056FCA4(a1, a2, a3);
  if (v6 == (unsigned __int8 *)a2) {
    sub_10056BEE8();
  }
  do
  {
    unint64_t v7 = v6;
    int v6 = sub_10056FCA4(a1, (char *)v6, a3);
  }
  while (v6 != v7);
  return v7;
}

unsigned __int8 *sub_10056FCA4(uint64_t a1, char *a2, char *a3)
{
  int v6 = sub_10056FDE8(a1, a2, a3);
  unint64_t v7 = (unsigned __int8 *)v6;
  if (v6 == a2 && v6 != a3)
  {
    int v8 = *a2;
    if (v8 == 36) {
      sub_100566B00();
    }
    if (v8 != 40)
    {
      if (v8 == 94) {
        sub_100566A7C();
      }
      return (unsigned __int8 *)a2;
    }
    sub_100567CA4(a1);
    ++*(_DWORD *)(a1 + 36);
    int v9 = (char *)sub_10056D4C4(a1, a2 + 1, a3);
    if (v9 == a3 || (uint64_t v10 = v9, *v9 != 41)) {
      sub_100566CC0();
    }
    sub_100567D28(a1);
    --*(_DWORD *)(a1 + 36);
    unint64_t v7 = (unsigned __int8 *)(v10 + 1);
  }
  if (v7 == (unsigned __int8 *)a2) {
    return (unsigned __int8 *)a2;
  }

  return sub_10056DD50(a1, v7, (unsigned __int8 *)a3);
}

char *sub_10056FDE8(uint64_t a1, char *a2, char *a3)
{
  uint64_t result = sub_10056FED0(a1, a2, a3);
  if (result == a2)
  {
    uint64_t result = sub_10056FF5C(a1, a2, a3);
    if (result == a2)
    {
      if (a2 != a3 && *a2 == 46) {
        operator new();
      }
      return sub_10056E0FC(a1, a2, a3);
    }
  }
  return result;
}

char *sub_10056FED0(uint64_t a1, char *a2, char *a3)
{
  if (a2 != a3)
  {
    int v3 = *a2;
    uint64_t v4 = (v3 - 36);
    if (v4 > 0x3A) {
      goto LABEL_8;
    }
    if (((1 << (v3 - 36)) & 0x5800000080004D1) != 0) {
      return a2;
    }
    if (v4 == 5)
    {
      if (*(_DWORD *)(a1 + 36)) {
        return a2;
      }
    }
    else
    {
LABEL_8:
      if ((v3 - 123) < 2) {
        return a2;
      }
    }
    sub_100568348(a1);
  }
  return a2;
}

char *sub_10056FF5C(uint64_t a1, char *a2, char *a3)
{
  int v3 = a2;
  if (a2 == a3) {
    return v3;
  }
  uint64_t v4 = (unsigned __int8 *)(a2 + 1);
  if (v3 + 1 == a3 || *v3 != 92) {
    return v3;
  }
  int v5 = (char)*v4;
  BOOL v6 = (v5 - 36) > 0x3A || ((1 << (*v4 - 36)) & 0x5800000080004F1) == 0;
  if (!v6 || (v5 - 123) < 3) {
    sub_100568348(a1);
  }
  if ((*(_DWORD *)(a1 + 24) & 0x1F0) != 0x40)
  {
    int v8 = sub_10056C404(a1, *v4);
    uint64_t v9 = 2;
    if (!v8) {
      uint64_t v9 = 0;
    }
    v3 += v9;
    return v3;
  }

  return sub_10056F0F0(a1, (char *)v4, a3, 0);
}

uint64_t sub_100570034(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  __int16 v5 = a5;
  long long v16 = 0u;
  long long v17 = 0u;
  long long v14 = 0u;
  long long v15 = 0u;
  long long v12 = 0u;
  long long v13 = 0u;
  *(_OWORD *)long long __p = 0u;
  int v9 = sub_100155A0C(a4, a1, a2, (uint64_t)__p, a5 | 0x1040u);
  sub_100155BE8(a3, a1, a2, (uint64_t *)__p, (v5 & 0x800) != 0);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  if (!v9) {
    return 0;
  }
  if (!*(unsigned char *)(a3 + 88)) {
    return 1;
  }
  uint64_t result = 0;
  *(void *)(a3 + 8) = *(void *)a3;
  return result;
}

void sub_100570100(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_10057011C(__CFArray *a1, CFTypeRef cf)
{
  __int16 v5 = cf;
  if (cf)
  {
    CFRetain(cf);
    CFArrayAppendValue(a1, cf);
  }
  sub_10010F494(&v5);
  return cf != 0;
}

void sub_100570178(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_10010F494((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_10057018C(uint64_t a1, void *a2, NSObject **a3, void *a4, void *a5)
{
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v32, kCtLoggingSystemName, "set.cdma.wait");
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  uint64_t v10 = *a3;
  *(void *)(a1 + 24) = *a3;
  if (v10) {
    dispatch_retain(v10);
  }
  *(void *)(a1 + 32) = 0;
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)&v30, &v32);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 40), (const ctu::OsLogLogger *)&v30);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)&v30);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v32);
  v31[0] = off_101999E18;
  v31[1] = sub_100570760;
  v31[3] = v31;
  *(void *)(a1 + 48) = 0;
  if ((capabilities::ct::supportsGemini(v11) & 1) == 0) {
    operator new();
  }
  if (!*(void *)(a1 + 48)) {
    operator new();
  }
  sub_10008863C(v31);
  *(void *)a1 = off_1019E40F8;
  *(void *)(a1 + 56) = *a2;
  uint64_t v12 = a2[1];
  *(void *)(a1 + 64) = v12;
  if (v12) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v12 + 8), 1uLL, memory_order_relaxed);
  }
  sub_100058DB0(&__p, "CDMACallWaitingHandler");
  long long v13 = *(NSObject **)(a1 + 24);
  dispatch_object_t v27 = v13;
  if (v13) {
    dispatch_retain(v13);
  }
  dispatch_object_t object = 0;
  ctu::RestModule::RestModule();
  if (v27) {
    dispatch_release(v27);
  }
  if (v29 < 0) {
    operator delete(__p);
  }
  sub_1000FE9CC((uint64_t *)(a1 + 88), (uint64_t)&rest::kDefaultBundles);
  *(unsigned char *)(a1 + 112) = 0;
  *(void *)(a1 + 120) = *a4;
  uint64_t v14 = a4[1];
  *(void *)(a1 + 128) = v14;
  if (v14) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v14 + 8), 1uLL, memory_order_relaxed);
  }
  *(void *)(a1 + 144) = 0;
  *(void *)(a1 + 136) = a1 + 144;
  *(void *)(a1 + 168) = 0;
  *(void *)(a1 + 160) = a1 + 168;
  *(void *)(a1 + 152) = 0;
  *(void *)(a1 + 176) = 0;
  *(void *)(a1 + 184) = *a5;
  uint64_t v15 = a5[1];
  *(void *)(a1 + 192) = v15;
  if (v15) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v15 + 8), 1uLL, memory_order_relaxed);
  }
  if (!*a4) {
    __TUAssertTrigger();
  }
  subscriber::makeSimSlotRange();
  var0 = v32.var0;
  fRef = v32.var1.fRef;
  if (v32.var0 != (char *)v32.var1.fRef)
  {
    uint64_t v18 = v33;
    while ((v18(*(unsigned int *)var0) & 1) == 0)
    {
      var0 += 4;
      if (var0 == (char *)fRef)
      {
        var0 = (char *)fRef;
        break;
      }
    }
    uint64_t v19 = v32.var1.fRef;
    while (var0 != (char *)v19)
    {
      int v25 = 0;
      int v25 = *(_DWORD *)var0;
      uint64_t v30 = &v25;
      int v20 = sub_100571E00((uint64_t **)(a1 + 160), &v25, (uint64_t)&unk_10144E20E, &v30);
      long long v21 = (int *)v20[5];
      v20[5] = 0;
      uint64_t v30 = v21;
      sub_100057D78((const void **)&v30);
      uint64_t v22 = sub_100571F48((uint64_t **)(a1 + 136), v25, &v25);
      *((_DWORD *)v22 + 8) = 1;
      *((unsigned char *)v22 + 36) = 1;
      unsigned int v23 = var0 + 4;
      var0 = (char *)fRef;
      if (v23 != (char *)fRef)
      {
        var0 = v23;
        while ((v18(*(unsigned int *)var0) & 1) == 0)
        {
          var0 += 4;
          if (var0 == (char *)fRef)
          {
            var0 = (char *)fRef;
            break;
          }
        }
      }
    }
  }
  return a1;
}

void sub_1005705C4(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, dispatch_object_t object, dispatch_object_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,char a23,int a24,__int16 a25,char a26,char a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31)
{
}

const char *sub_100570760(int a1)
{
  uint64_t v1 = "set.cdma.wait.?";
  if (a1 == 2) {
    uint64_t v1 = "set.cdma.wait.2";
  }
  if (a1 == 1) {
    return "set.cdma.wait.1";
  }
  else {
    return v1;
  }
}

uint64_t sub_10057078C(uint64_t a1)
{
  *(void *)a1 = off_1019E40F8;
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 192);
  if (v2) {
    sub_10004D2C8(v2);
  }
  sub_100571DA4(a1 + 160, *(const void ***)(a1 + 168));
  sub_10005D144(*(void **)(a1 + 144));
  int v3 = *(std::__shared_weak_count **)(a1 + 128);
  if (v3) {
    sub_10004D2C8(v3);
  }
  sub_100087F94(a1 + 88, *(void **)(a1 + 96));
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 80);
  if (v4) {
    sub_10004D2C8(v4);
  }
  __int16 v5 = *(std::__shared_weak_count **)(a1 + 64);
  if (v5) {
    sub_10004D2C8(v5);
  }
  uint64_t v6 = *(void *)(a1 + 48);
  *(void *)(a1 + 48) = 0;
  if (v6) {
    (*(void (**)(uint64_t))(*(void *)v6 + 8))(v6);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 40));
  sub_100087E88((void *)(a1 + 8));
  return a1;
}

void sub_100570864(uint64_t a1)
{
  sub_10057078C(a1);

  operator delete();
}

uint64_t sub_10057089C(uint64_t a1)
{
  Registry::createRestModuleOneTimeUseConnection(&v9, *(Registry **)(a1 + 56));
  ctu::RestModule::connect();
  if (v10) {
    sub_10004D2C8(v10);
  }
  sub_100058DB0(&__p, "/cc/props/carrier_bundles");
  uint64_t v2 = operator new(0x28uLL);
  void *v2 = off_1019E4210;
  v2[1] = a1 + 88;
  void v2[2] = a1;
  v2[3] = sub_100570A84;
  v2[4] = 0;
  long long v16 = v2;
  ctu::RestModule::observeProperty();
  sub_10003F600(&v13);
  if (v12 < 0) {
    operator delete(__p);
  }
  sub_1002D795C(a1 + 112);
  uint64_t result = subscriber::makeSimSlotRange();
  __int16 v5 = v13;
  uint64_t v4 = v14;
  if (v13 != v14)
  {
    uint64_t v6 = v15;
    while (1)
    {
      uint64_t result = v6(*v5);
      if (result) {
        break;
      }
      if (++v5 == v4)
      {
        __int16 v5 = v4;
        break;
      }
    }
    unint64_t v7 = v14;
LABEL_11:
    while (v5 != v7)
    {
      uint64_t result = sub_10057100C(a1, *v5);
      int v8 = v5 + 1;
      __int16 v5 = v4;
      if (v8 != v4)
      {
        __int16 v5 = v8;
        while (1)
        {
          uint64_t result = v6(*v5);
          if (result) {
            break;
          }
          if (++v5 == v4)
          {
            __int16 v5 = v4;
            goto LABEL_11;
          }
        }
      }
    }
  }
  return result;
}

void sub_100570A3C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_100570A84(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void **)(a1 + 88);
  int v3 = (void *)(a1 + 96);
  if (v2 != (void *)(a1 + 96))
  {
    uint64_t v4 = a1;
    __int16 v5 = (void *)(a2 + 8);
    uint64_t v6 = (void *)(a1 + 168);
    uint64_t v49 = (uint64_t **)(a1 + 136);
    int v50 = (void *)(a2 + 8);
    do
    {
      uint64_t v7 = *v5;
      uint64_t v8 = *((unsigned int *)v2 + 8);
      if (*v5)
      {
        uint64_t v9 = v5;
        do
        {
          int v10 = *(_DWORD *)(v7 + 32);
          BOOL v11 = v10 < (int)v8;
          if (v10 >= (int)v8) {
            char v12 = (uint64_t *)v7;
          }
          else {
            char v12 = (uint64_t *)(v7 + 8);
          }
          if (!v11) {
            uint64_t v9 = (void *)v7;
          }
          uint64_t v7 = *v12;
        }
        while (*v12);
        if (v9 != v5 && (int)v8 >= *((_DWORD *)v9 + 8))
        {
          if (rest::operator==()) {
            goto LABEL_29;
          }
          uint64_t v8 = *((unsigned int *)v2 + 8);
        }
      }
      unsigned int v55 = v8;
      long long v13 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v4 + 48) + 16))(*(void *)(v4 + 48), v8);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v14 = asString();
        uint64_t v15 = asString();
        *(_DWORD *)std::string buf = 136315394;
        *(void *)&uint8_t buf[4] = v14;
        __int16 v57 = 2080;
        uint64_t v58 = v15;
        _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I Carrier bundle changed to %s (%s)", buf, 0x16u);
      }
      uint64_t v16 = *v6;
      if (*v6)
      {
        long long v17 = v6;
        do
        {
          int v18 = *(_DWORD *)(v16 + 32);
          BOOL v19 = v18 < (int)v8;
          if (v18 >= (int)v8) {
            int v20 = (uint64_t *)v16;
          }
          else {
            int v20 = (uint64_t *)(v16 + 8);
          }
          if (!v19) {
            long long v17 = (void *)v16;
          }
          uint64_t v16 = *v20;
        }
        while (*v20);
        if (v17 != v6 && *((_DWORD *)v17 + 8) <= (int)v8)
        {
          ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(v4 + 56));
          uint64_t v26 = ServiceMap;
          if (v27 < 0)
          {
            uint64_t v28 = (unsigned __int8 *)(v27 & 0x7FFFFFFFFFFFFFFFLL);
            uint64_t v29 = 5381;
            do
            {
              uint64_t v27 = v29;
              unsigned int v30 = *v28++;
              uint64_t v29 = (33 * v29) ^ v30;
            }
            while (v30);
          }
          std::mutex::lock(ServiceMap);
          *(void *)std::string buf = v27;
          long long v31 = sub_10004D37C(&v26[1].__m_.__sig, (unint64_t *)buf);
          if (v31)
          {
            uint64_t v32 = v4;
            uint64_t v33 = v6;
            uint64_t v35 = v31[3];
            unint64_t v34 = (std::__shared_weak_count *)v31[4];
            if (v34)
            {
              atomic_fetch_add_explicit(&v34->__shared_owners_, 1uLL, memory_order_relaxed);
              std::mutex::unlock(v26);
              atomic_fetch_add_explicit(&v34->__shared_owners_, 1uLL, memory_order_relaxed);
              size_t v51 = v34;
              sub_10004D2C8(v34);
              char v52 = 0;
              uint64_t v6 = v33;
              uint64_t v4 = v32;
              __int16 v5 = v50;
              if (!v35)
              {
LABEL_42:
                uint64_t v36 = *(NSObject **)(v4 + 40);
                if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
                {
                  *(_WORD *)std::string buf = 0;
                  _os_log_error_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_ERROR, "Could not get CarrierSettingsInterface", buf, 2u);
                }
LABEL_60:
                if ((v52 & 1) == 0) {
                  sub_10004D2C8(v51);
                }
                goto LABEL_29;
              }
LABEL_47:
              (*(void (**)(const void **__return_ptr, uint64_t, uint64_t, uint64_t, const __CFString *, void, void))(*(void *)v35 + 80))(&v53, v35, v8, 1, @"CallWaitingDialingCodes", 0, 0);
              sub_10004EFE4(&v54, &v53);
              std::string::value_type v38 = (const void **)(v17 + 5);
              if (v38 != &v54)
              {
                *(void *)std::string buf = *v38;
                char *v38 = v54;
                uint64_t v54 = 0;
                sub_100057D78((const void **)buf);
              }
              sub_100057D78(&v54);
              sub_1000577C4(&v53);
              uint64_t v39 = v55;
              if (!sub_10057100C(v4, v55))
              {
                if (*v38 ? sub_100080778 : 0)
                {
                  CFDictionaryRef Value = (BOOL *)CFDictionaryGetValue((CFDictionaryRef)*v38, @"CallWaitingEnabledByDefault");
                  size_t v42 = Value;
                  if (Value)
                  {
                    CFTypeID v43 = CFGetTypeID(Value);
                    if (v43 == CFBooleanGetTypeID())
                    {
                      buf[0] = 0;
                      ctu::cf::assign((ctu::cf *)buf, v42, v44);
                      char v45 = buf[0];
                      *((unsigned char *)sub_100571F48(v49, v39, &v55) + 36) = v45;
                      std::string v46 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v4 + 48) + 16))(*(void *)(v4 + 48), v39);
                      if (os_log_type_enabled(v46, OS_LOG_TYPE_DEFAULT))
                      {
                        int v47 = sub_100571F48(v49, v39, &v55);
                        long long v48 = "True";
                        if (!*((unsigned char *)v47 + 36)) {
                          long long v48 = "False";
                        }
                        *(_DWORD *)std::string buf = 136315138;
                        *(void *)&uint8_t buf[4] = v48;
                        _os_log_impl((void *)&_mh_execute_header, v46, OS_LOG_TYPE_DEFAULT, "#I Setting Call Waiting to %s for the first time", buf, 0xCu);
                      }
                    }
                  }
                }
              }
              goto LABEL_60;
            }
            uint64_t v6 = v33;
            uint64_t v4 = v32;
            __int16 v5 = v50;
          }
          else
          {
            uint64_t v35 = 0;
          }
          std::mutex::unlock(v26);
          size_t v51 = 0;
          char v52 = 1;
          if (!v35) {
            goto LABEL_42;
          }
          goto LABEL_47;
        }
      }
      long long v21 = *(NSObject **)(v4 + 40);
      if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
      {
        uint64_t v37 = subscriber::asString();
        *(_DWORD *)std::string buf = 136315138;
        *(void *)&uint8_t buf[4] = v37;
        _os_log_error_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "Cannot find slot %s!!", buf, 0xCu);
      }
LABEL_29:
      uint64_t v22 = (void *)v2[1];
      if (v22)
      {
        do
        {
          unsigned int v23 = v22;
          uint64_t v22 = (void *)*v22;
        }
        while (v22);
      }
      else
      {
        do
        {
          unsigned int v23 = (void *)v2[2];
          BOOL v24 = *v23 == (void)v2;
          uint64_t v2 = v23;
        }
        while (!v24);
      }
      uint64_t v2 = v23;
    }
    while (v23 != v3);
  }
}

void sub_100570FB8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, std::__shared_weak_count *a15, int a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21)
{
  if ((a17 & 1) == 0) {
    sub_10004D2C8(a15);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_10057100C(uint64_t a1, uint64_t a2)
{
  int v14 = a2;
  v12[0] = 0;
  v12[1] = 0;
  uint64_t v13 = 0;
  sub_10102024C(a2, v12);
  unsigned __int8 v11 = 0;
  uint64_t v4 = sub_100365D74();
  sub_1002055B4((const void **)qword_101B0D170, (const void **)v12, __p);
  BOOL v5 = sub_100571C98(v4, (void **)__p, &v11);
  BOOL v6 = v5;
  if (v16 < 0)
  {
    operator delete(*(void **)__p);
    if (!v6) {
      goto LABEL_10;
    }
  }
  else if (!v5)
  {
    goto LABEL_10;
  }
  int v7 = v11;
  *((unsigned char *)sub_100571F48((uint64_t **)(a1 + 136), a2, &v14) + 36) = v7 != 0;
  uint64_t v8 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    if (v11) {
      uint64_t v9 = "enabled";
    }
    else {
      uint64_t v9 = "disabled";
    }
    *(_DWORD *)long long __p = 136315138;
    *(void *)&__p[4] = v9;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Call Wating restored as %s", __p, 0xCu);
  }
LABEL_10:
  if (SHIBYTE(v13) < 0) {
    operator delete(v12[0]);
  }
  return v6;
}

void sub_100571198(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1005711DC(uint64_t a1, int a2)
{
  uint64_t v2 = *(void *)(a1 + 144);
  if (!v2) {
    goto LABEL_11;
  }
  uint64_t v3 = a1 + 144;
  do
  {
    int v4 = *(_DWORD *)(v2 + 28);
    BOOL v5 = v4 < a2;
    if (v4 >= a2) {
      BOOL v6 = (uint64_t *)v2;
    }
    else {
      BOOL v6 = (uint64_t *)(v2 + 8);
    }
    if (!v5) {
      uint64_t v3 = v2;
    }
    uint64_t v2 = *v6;
  }
  while (*v6);
  if (v3 != a1 + 144 && *(_DWORD *)(v3 + 28) <= a2)
  {
    uint64_t v8 = *(void (**)(void))(**(void **)(a1 + 184) + 72);
    v8();
  }
  else
  {
LABEL_11:
    int v7 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      int v9 = 136315138;
      uint64_t v10 = subscriber::asString();
      _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "Cannot find slot %s!!", (uint8_t *)&v9, 0xCu);
    }
  }
}

BOOL sub_100571328(uint64_t a1, int a2, unsigned char *a3)
{
  uint64_t v3 = *(void *)(a1 + 144);
  if (!v3) {
    goto LABEL_11;
  }
  uint64_t v4 = a1 + 144;
  do
  {
    int v5 = *(_DWORD *)(v3 + 28);
    BOOL v6 = v5 < a2;
    if (v5 >= a2) {
      int v7 = (uint64_t *)v3;
    }
    else {
      int v7 = (uint64_t *)(v3 + 8);
    }
    if (!v6) {
      uint64_t v4 = v3;
    }
    uint64_t v3 = *v7;
  }
  while (*v7);
  if (v4 != a1 + 144 && *(_DWORD *)(v4 + 28) <= a2)
  {
    *a3 = *(unsigned char *)(v4 + 36);
    return 1;
  }
  else
  {
LABEL_11:
    uint64_t v8 = *(NSObject **)(a1 + 40);
    BOOL result = os_log_type_enabled(v8, OS_LOG_TYPE_ERROR);
    if (result)
    {
      int v10 = 136315138;
      uint64_t v11 = subscriber::asString();
      _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "Cannot find slot %s!!", (uint8_t *)&v10, 0xCu);
      return 0;
    }
  }
  return result;
}

void sub_100571420(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  uint64_t v6 = a2;
  unsigned int v27 = a2;
  uint64_t v8 = *(NSObject **)(*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)std::string buf = 67109376;
    *(_DWORD *)&uint8_t buf[4] = a3;
    *(_WORD *)&uint8_t buf[8] = 1024;
    *(_DWORD *)&buf[10] = a4;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I saveCallWaitingValue: enabled to %d, class = %d", buf, 0xEu);
  }
  uint64_t v9 = *(void *)(a1 + 144);
  if (!v9) {
    goto LABEL_13;
  }
  uint64_t v10 = a1 + 144;
  do
  {
    int v11 = *(_DWORD *)(v9 + 28);
    BOOL v12 = v11 < (int)v6;
    if (v11 >= (int)v6) {
      uint64_t v13 = (uint64_t *)v9;
    }
    else {
      uint64_t v13 = (uint64_t *)(v9 + 8);
    }
    if (!v12) {
      uint64_t v10 = v9;
    }
    uint64_t v9 = *v13;
  }
  while (*v13);
  if (v10 != a1 + 144 && *(_DWORD *)(v10 + 28) <= (int)v6)
  {
    if (*(unsigned char *)(a1 + 112)
      || ((*(void *)std::string buf = &v27,
           sub_100571E00((uint64_t **)(a1 + 160), (int *)&v27, (uint64_t)&unk_10144E20E, (_DWORD **)buf)[5])
        ? (char v16 = sub_100080778)
        : (char v16 = 0),
          uint64_t v6 = v27,
          !v16))
    {
      uint64_t v15 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), v6);
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#E saveCallWaitingValue - Ongoing Voice call", buf, 2u);
      }
      (*(void (**)(void, void, uint64_t, void))(**(void **)(a1 + 184) + 64))(*(void *)(a1 + 184), v27, a4, 0);
    }
    else
    {
      *(unsigned char *)(v10 + 36) = a3;
      *(_DWORD *)(v10 + 32) = a4;
      int v30 = v6;
      memset(buf, 0, sizeof(buf));
      sub_10102024C(v6, buf);
      long long v17 = (uint64_t **)sub_100365D74();
      sub_1002055B4((const void **)qword_101B0D170, (const void **)buf, &__p);
      unsigned __int8 v28 = *((unsigned char *)sub_100571F48((uint64_t **)(a1 + 136), v6, &v30) + 36);
      sub_100571BC4(v17, &__p, &v28);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      if ((char)buf[23] < 0) {
        operator delete(*(void **)buf);
      }
      *(void *)std::string buf = &v27;
      CFDictionaryRef v18 = (const __CFDictionary *)sub_100571E00((uint64_t **)(a1 + 160), (int *)&v27, (uint64_t)&unk_10144E20E, (_DWORD **)buf)[5];
      if (a3) {
        CFStringRef v19 = @"EnableCallWaiting";
      }
      else {
        CFStringRef v19 = @"DisableCallWaiting";
      }
      CFDictionaryGetValue(v18, v19);
      memset(buf, 0, sizeof(buf));
      ctu::cf::assign();
      int v20 = *(std::string **)buf;
      *(_OWORD *)&__p.__r_.__value_.__l.__data_ = *(_OWORD *)buf;
      *(std::string::size_type *)((char *)&__p.__r_.__value_.__r.__words[1] + 7) = *(void *)&buf[15];
      int v21 = (char)buf[23];
      uint64_t v22 = v27;
      *((unsigned char *)&__p.__r_.__value_.__s + 23) = buf[23];
      unsigned int v23 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), v27);
      if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
      {
        p_p = &__p;
        if (v21 < 0) {
          p_p = v20;
        }
        *(_DWORD *)std::string buf = 136315138;
        *(void *)&uint8_t buf[4] = p_p;
        _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "#I Dialing %s", buf, 0xCu);
      }
      uint64_t v25 = *(void *)(a1 + 120);
      *(void *)std::string buf = off_1019E4290;
      *(void *)&uint8_t buf[8] = a1;
      *(void *)&uint8_t buf[16] = v22 | (a4 << 32);
      uint64_t v32 = buf;
      (*(void (**)(uint64_t, uint64_t, std::string *, uint8_t *))(*(void *)v25 + 16))(v25, v22, &__p, buf);
      sub_10003B34C(buf);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
    }
  }
  else
  {
LABEL_13:
    int v14 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      uint64_t v26 = subscriber::asString();
      *(_DWORD *)std::string buf = 136315138;
      *(void *)&uint8_t buf[4] = v26;
      _os_log_error_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "Cannot find slot %s!!", buf, 0xCu);
    }
  }
}

void sub_100571888(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_100571904(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 136);
  uint64_t v3 = (void *)(a1 + 144);
  if (v2 != (void *)(a1 + 144))
  {
    do
    {
      uint64_t v4 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), *((unsigned int *)v2 + 7));
      if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
      {
        int v5 = *((unsigned char *)v2 + 36) ? "enabled" : "disabled";
        sub_10058F068((std::string *)*((unsigned int *)v2 + 8), &__p);
        uint64_t v6 = (__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
           ? &__p
           : (std::string *)__p.__r_.__value_.__r.__words[0];
        *(_DWORD *)std::string buf = 136315394;
        unsigned int v23 = v5;
        __int16 v24 = 2080;
        uint64_t v25 = v6;
        _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Call Wating is %s for (%s)", buf, 0x16u);
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__p.__r_.__value_.__l.__data_);
        }
      }
      int v7 = (void *)v2[1];
      if (v7)
      {
        do
        {
          uint64_t v8 = v7;
          int v7 = (void *)*v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          uint64_t v8 = (void *)v2[2];
          BOOL v9 = *v8 == (void)v2;
          uint64_t v2 = v8;
        }
        while (!v9);
      }
      uint64_t v2 = v8;
    }
    while (v8 != v3);
  }
  uint64_t v10 = *(void **)(a1 + 160);
  if (v10 != (void *)(a1 + 168))
  {
    do
    {
      if (v10[5]) {
        int v11 = sub_100080778;
      }
      else {
        int v11 = 0;
      }
      BOOL v12 = v11 == 0;
      uint64_t v13 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), *((unsigned int *)v10 + 8));
      BOOL v14 = os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT);
      if (v12)
      {
        if (v14)
        {
          LOWORD(__p.__r_.__value_.__l.__data_) = 0;
          char v16 = v13;
          long long v17 = "#I no configuring numbers";
          uint32_t v18 = 2;
          goto LABEL_26;
        }
      }
      else if (v14)
      {
        std::string::size_type v15 = v10[5];
        LODWORD(__p.__r_.__value_.__l.__data_) = 138412290;
        *(std::string::size_type *)((char *)__p.__r_.__value_.__r.__words + 4) = v15;
        char v16 = v13;
        long long v17 = "#I configuring numbers are: %@";
        uint32_t v18 = 12;
LABEL_26:
        _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, v17, (uint8_t *)&__p, v18);
      }
      CFStringRef v19 = (void *)v10[1];
      if (v19)
      {
        do
        {
          int v20 = v19;
          CFStringRef v19 = (void *)*v19;
        }
        while (v19);
      }
      else
      {
        do
        {
          int v20 = (void *)v10[2];
          BOOL v9 = *v20 == (void)v10;
          uint64_t v10 = v20;
        }
        while (!v9);
      }
      uint64_t v10 = v20;
    }
    while (v20 != (void *)(a1 + 168));
  }
}

uint64_t sub_100571BC4(uint64_t **a1, std::string *a2, unsigned __int8 *a3)
{
  *(_OWORD *)std::string __str = 0u;
  long long v9 = 0u;
  snprintf(__str, 0x20uLL, "0x%x", *a3);
  sub_100058DB0(&__p, __str);
  uint64_t v5 = sub_10036627C(a1, a2, &__p);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  return v5;
}

void sub_100571C74(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_100571C98(uint64_t a1, void **a2, unsigned char *a3)
{
  std::mutex::lock(&stru_101B09FA8);
  memset(&v11, 0, sizeof(v11));
  uint64_t v6 = sub_100046F68(a1, a2);
  int v7 = v6;
  uint64_t v8 = (void **)(a1 + 8);
  if (v8 != v6)
  {
    std::string::operator=(&v11, (const std::string *)(v6 + 7));
    if ((v11.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      long long v9 = &v11;
    }
    else {
      long long v9 = (std::string *)v11.__r_.__value_.__r.__words[0];
    }
    *a3 = strtoll((const char *)v9, 0, 16);
    if (SHIBYTE(v11.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v11.__r_.__value_.__l.__data_);
    }
  }
  std::mutex::unlock(&stru_101B09FA8);
  return v8 != v7;
}

void sub_100571D58(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  std::mutex::unlock(&stru_101B09FA8);
  _Unwind_Resume(a1);
}

void sub_100571D84()
{
}

uint64_t sub_100571D98(uint64_t a1)
{
  return *(void *)(a1 + 8) + 40;
}

void sub_100571DA4(uint64_t a1, const void **a2)
{
  if (a2)
  {
    sub_100571DA4(a1, *a2);
    sub_100571DA4(a1, a2[1]);
    sub_100057D78(a2 + 5);
    operator delete(a2);
  }
}

uint64_t **sub_100571E00(uint64_t **a1, int *a2, uint64_t a3, _DWORD **a4)
{
  int v7 = a1 + 1;
  uint64_t v6 = a1[1];
  uint64_t v8 = a1 + 1;
  long long v9 = a1 + 1;
  if (v6)
  {
    int v10 = *a2;
    while (1)
    {
      while (1)
      {
        long long v9 = (uint64_t **)v6;
        int v11 = *((_DWORD *)v6 + 8);
        if (v10 >= v11) {
          break;
        }
        uint64_t v6 = *v9;
        uint64_t v8 = v9;
        if (!*v9) {
          goto LABEL_9;
        }
      }
      if (v11 >= v10) {
        break;
      }
      uint64_t v6 = v9[1];
      if (!v6)
      {
        uint64_t v8 = v9 + 1;
        goto LABEL_9;
      }
    }
  }
  else
  {
LABEL_9:
    uint64_t v14[2] = 1;
    BOOL v12 = operator new(0x30uLL);
    v14[1] = v7;
    v12[8] = **a4;
    *((void *)v12 + 5) = 0;
    sub_100046C38(a1, (uint64_t)v9, v8, (uint64_t *)v12);
    v14[0] = 0;
    sub_100571EF0((uint64_t)v14, 0);
    return (uint64_t **)v12;
  }
  return v9;
}

void sub_100571EF0(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(const void ***)a1;
  *(void *)a1 = a2;
  if (v2)
  {
    if (*(unsigned char *)(a1 + 16)) {
      sub_100057D78(v2 + 5);
    }
    operator delete(v2);
  }
}

uint64_t **sub_100571F48(uint64_t **a1, int a2, _DWORD *a3)
{
  uint64_t v6 = a1 + 1;
  uint64_t v5 = a1[1];
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        int v7 = (uint64_t **)v5;
        int v8 = *((_DWORD *)v5 + 7);
        if (v8 <= a2) {
          break;
        }
        uint64_t v5 = *v7;
        uint64_t v6 = v7;
        if (!*v7) {
          goto LABEL_9;
        }
      }
      if (v8 >= a2) {
        break;
      }
      uint64_t v5 = v7[1];
      if (!v5)
      {
        uint64_t v6 = v7 + 1;
        goto LABEL_9;
      }
    }
  }
  else
  {
    int v7 = a1 + 1;
LABEL_9:
    long long v9 = (uint64_t *)v7;
    int v7 = (uint64_t **)operator new(0x28uLL);
    *((_DWORD *)v7 + 7) = *a3;
    void v7[4] = (void *)(&_mh_execute_header + 1);
    *int v7 = 0;
    v7[1] = 0;
    void v7[2] = v9;
    *uint64_t v6 = (uint64_t *)v7;
    int v10 = (uint64_t *)**a1;
    int v11 = (uint64_t *)v7;
    if (v10)
    {
      *a1 = v10;
      int v11 = *v6;
    }
    sub_100046C90(a1[1], v11);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
  }
  return v7;
}

void sub_100572020()
{
}

__n128 sub_100572034(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_1019E4210;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100572088(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019E4210;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_1005720C0(void *a1, xpc_object_t *a2)
{
  uint64_t v3 = (void *)a1[1];
  uint64_t v4 = v3 + 1;
  uint64_t v5 = (void *)v3[1];
  long long v9 = (void **)*v3;
  int v10 = v5;
  if (v3[2])
  {
    v5[2] = &v10;
    *uint64_t v3 = v4;
    void *v4 = 0;
    v3[2] = 0;
  }
  else
  {
    long long v9 = &v10;
  }
  sub_10008AAD8((uint64_t)v3, a2);
  uint64_t v6 = (void (*)(void *, void ***))a1[3];
  uint64_t v7 = a1[4];
  int v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    uint64_t v6 = *(void (**)(void *, void ***))(*v8 + v6);
  }
  v6(v8, &v9);
  sub_100087F94((uint64_t)&v9, v10);
}

void sub_100572180(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11)
{
}

uint64_t sub_100572198(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1005721D8()
{
}

void sub_1005721E8()
{
}

__n128 sub_1005721FC(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_1019E4290;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_100572248(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019E4290;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100572278(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(*(void *)(a1 + 8) + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

uint64_t sub_100572370(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1005723B0()
{
}

void sub_1005723BC(uint64_t a1)
{
  uint64_t v1 = a1;
  (*(void (**)(void, void, void, void))(**(void **)(**(void **)a1 + 184) + 80))(*(void *)(**(void **)a1 + 184), *(unsigned int *)(*(void *)a1 + 12), *(unsigned int *)(*(void *)a1 + 8), 0);
  operator delete();
}

void sub_10057243C()
{
}

uint64_t sub_100572468()
{
  sub_100058DB0(qword_101B0D170, "SettingsModel::CallWaitingEnabled");

  return __cxa_atexit((void (*)(void *))&std::string::~string, qword_101B0D170, (void *)&_mh_execute_header);
}

uint64_t sub_1005724C8(uint64_t a1, int a2, void *a3, void *a4, void *a5)
{
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  *(void *)a1 = off_1019E4310;
  *(void *)(a1 + 8) = off_1019E4478;
  *(void *)(a1 + 88) = 0;
  *(void *)(a1 + 96) = 0;
  *(_OWORD *)(a1 + 32) = xmmword_1014BD370;
  *(_DWORD *)(a1 + 48) = a2;
  *(_OWORD *)(a1 + 56) = xmmword_1014BD380;
  *(void *)(a1 + 72) = 3600;
  *(void *)(a1 + 80) = 0;
  *(_DWORD *)(a1 + 104) = 0;
  uint64_t v6 = a3[1];
  *(void *)(a1 + 112) = *a3;
  *(void *)(a1 + 120) = v6;
  if (v6) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v6 + 8), 1uLL, memory_order_relaxed);
  }
  *(void *)(a1 + 128) = 0;
  *(void *)(a1 + 136) = 0;
  uint64_t v7 = a4[1];
  *(void *)(a1 + 144) = *a4;
  *(void *)(a1 + 152) = v7;
  if (v7) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v7 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v8 = a5[1];
  *(void *)(a1 + 160) = *a5;
  *(void *)(a1 + 168) = v8;
  if (v8) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v8 + 8), 1uLL, memory_order_relaxed);
  }
  *(void *)(a1 + 176) = 0;
  *(void *)(a1 + 184) = 0;
  *(void *)(a1 + 200) = 0;
  long long v9 = *(std::__shared_weak_count **)(a1 + 136);
  *(void *)(a1 + 128) = 0;
  *(void *)(a1 + 136) = 0;
  if (v9) {
    sub_10004D2C8(v9);
  }
  return a1;
}

void sub_1005725BC(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 112));
  uint64_t v6 = ServiceMap;
  if ((v7 & 0x8000000000000000) != 0)
  {
    uint64_t v8 = (unsigned __int8 *)(v7 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v9 = 5381;
    do
    {
      unint64_t v7 = v9;
      unsigned int v10 = *v8++;
      uint64_t v9 = (33 * v9) ^ v10;
    }
    while (v10);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v15 = v7;
  int v11 = sub_10004D37C(&v6[1].__m_.__sig, &v15);
  if (!v11)
  {
    uint64_t v12 = 0;
LABEL_9:
    std::mutex::unlock(v6);
    uint64_t v13 = 0;
    char v14 = 1;
    if (!v12) {
      goto LABEL_11;
    }
    goto LABEL_10;
  }
  uint64_t v12 = v11[3];
  uint64_t v13 = (std::__shared_weak_count *)v11[4];
  if (!v13) {
    goto LABEL_9;
  }
  atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v6);
  atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v13);
  char v14 = 0;
  if (v12) {
LABEL_10:
  }
    (*(void (**)(uint64_t, uint64_t))(*(void *)v12 + 192))(v12, a2);
LABEL_11:
  if ((v14 & 1) == 0) {
    sub_10004D2C8(v13);
  }
  if (!v12)
  {
    *a3 = 0;
    a3[1] = 0;
  }
}

void sub_1005726E4(_Unwind_Exception *exception_object)
{
  if ((v1 & 1) == 0) {
    sub_10004D2C8(v2);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100572700(uint64_t a1)
{
  *(void *)a1 = off_1019E4310;
  *(void *)(a1 + 8) = off_1019E4478;
  uint64_t v2 = *(NSObject **)(a1 + 200);
  if (v2) {
    dispatch_release(v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 184);
  if (v3) {
    sub_10004D2C8(v3);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 168);
  if (v4) {
    sub_10004D2C8(v4);
  }
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 152);
  if (v5) {
    sub_10004D2C8(v5);
  }
  uint64_t v6 = *(std::__shared_weak_count **)(a1 + 136);
  if (v6) {
    sub_10004D2C8(v6);
  }
  unint64_t v7 = *(std::__shared_weak_count **)(a1 + 120);
  if (v7) {
    sub_10004D2C8(v7);
  }
  if (*(char *)(a1 + 103) < 0) {
    operator delete(*(void **)(a1 + 80));
  }
  uint64_t v8 = *(std::__shared_weak_count **)(a1 + 24);
  if (v8) {
    std::__shared_weak_count::__release_weak(v8);
  }
  return a1;
}

uint64_t sub_1005727C8(uint64_t a1)
{
  return sub_100572700(a1 - 8);
}

void sub_1005727D0(uint64_t a1)
{
  sub_100572700(a1);

  operator delete();
}

void sub_100572808(uint64_t a1)
{
  sub_100572700(a1 - 8);

  operator delete();
}

uint64_t sub_100572844(uint64_t a1)
{
  return *(void *)(a1 + 192);
}

uint64_t sub_10057284C(uint64_t result, uint64_t a2)
{
  *(void *)(result + 192) = a2;
  return result;
}

char *sub_100572854@<X0>(char *result@<X0>, uint64_t a2@<X8>)
{
  if (result[103] < 0) {
    return (char *)sub_10004FC84((unsigned char *)a2, *((void **)result + 10), *((void *)result + 11));
  }
  *(_OWORD *)a2 = *((_OWORD *)result + 5);
  *(void *)(a2 + 16) = *((void *)result + 12);
  return result;
}

void sub_100572880(uint64_t a1, uint64_t a2)
{
  if (*(char *)(a2 + 23) < 0) {
    sub_10004FC84(&__p, *(void **)a2, *(void *)(a2 + 8));
  }
  else {
    std::string __p = *(std::string *)a2;
  }
  std::string::operator=((std::string *)(a1 + 80), &__p);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
}

void sub_1005728F0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10057290C(uint64_t a1)
{
  return *(unsigned int *)(a1 + 36);
}

uint64_t sub_100572914(uint64_t result, int a2)
{
  *(_DWORD *)(result + 36) = a2;
  return result;
}

uint64_t sub_10057291C(uint64_t a1)
{
  return *(unsigned int *)(a1 + 32);
}

uint64_t sub_100572924(uint64_t a1)
{
  return *(unsigned int *)(a1 + 40);
}

uint64_t sub_10057292C(uint64_t a1)
{
  Registry::getTimerService((uint64_t *)&v6, *(Registry **)(a1 + 112));
  uint64_t v2 = (**v6)(v6);
  int v3 = *(_DWORD *)(a1 + 40);
  uint64_t v4 = *(void *)(a1 + 64) << v3;
  if (v4 >= *(void *)(a1 + 72)) {
    uint64_t v4 = *(void *)(a1 + 72);
  }
  *(void *)(a1 + 56) = v2 + 1000000000 * v4;
  if (v7)
  {
    sub_10004D2C8(v7);
    int v3 = *(_DWORD *)(a1 + 40);
  }
  uint64_t result = (v3 + 1);
  *(_DWORD *)(a1 + 40) = result;
  return result;
}

void sub_1005729C4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1005729DC(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 64);
  if (v1 << *(_DWORD *)(a1 + 40) >= *(void *)(a1 + 72)) {
    return *(void *)(a1 + 72);
  }
  else {
    return v1 << *(_DWORD *)(a1 + 40);
  }
}

uint64_t sub_1005729F4(uint64_t a1)
{
  return *(unsigned int *)(a1 + 44);
}

BOOL sub_1005729FC(uint64_t a1)
{
  return *(_DWORD *)(a1 + 40) < *(_DWORD *)(a1 + 44);
}

uint64_t sub_100572A0C(uint64_t a1)
{
  return *(void *)(a1 + 64);
}

uint64_t sub_100572A14(uint64_t a1)
{
  return *(void *)(a1 + 72);
}

uint64_t sub_100572A1C(uint64_t a1)
{
  return *(unsigned int *)(a1 + 48);
}

uint64_t sub_100572A24(uint64_t a1)
{
  return *(void *)(a1 + 56);
}

uint64_t sub_100572A2C(uint64_t result, uint64_t a2)
{
  *(void *)(result + 56) = a2;
  return result;
}

BOOL sub_100572A34(uint64_t a1)
{
  return sub_100572A54(a1) < 1;
}

uint64_t sub_100572A54(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 56);
  Registry::getTimerService((uint64_t *)&v4, *(Registry **)(a1 + 112));
  uint64_t v2 = (**v4)(v4);
  if (v5) {
    sub_10004D2C8(v5);
  }
  return (v1 - v2) / 1000000000;
}

void sub_100572AE0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_100572AF8(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
}

BOOL sub_100572B04(uint64_t a1)
{
  return *(void *)(a1 + 144) != 0;
}

uint64_t sub_100572B14()
{
  return 0;
}

const char *sub_100572B1C()
{
  return "MMS";
}

uint64_t sub_100572B28()
{
  return 0;
}

uint64_t sub_100572B30()
{
  return 0;
}

uint64_t sub_100572B38()
{
  return 0;
}

uint64_t sub_100572B40(uint64_t result, int a2)
{
  *(_DWORD *)(result + 104) = a2;
  return result;
}

uint64_t sub_100572B48(uint64_t a1)
{
  return *(unsigned int *)(a1 + 104);
}

void sub_100572B50(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *a2;
  uint64_t v2 = a2[1];
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 136);
  *(void *)(a1 + 128) = v3;
  *(void *)(a1 + 136) = v2;
  if (v4) {
    sub_10004D2C8(v4);
  }
}

void sub_100572B7C(uint64_t a1, dispatch_object_t *a2)
{
  dispatch_object_t v3 = *a2;
  if (*a2) {
    dispatch_retain(*a2);
  }
  uint64_t v4 = *(NSObject **)(a1 + 200);
  *(void *)(a1 + 200) = v3;
  if (v4)
  {
    dispatch_release(v4);
  }
}

void sub_100572BD4(uint64_t a1)
{
  uint64_t v1 = **(NSObject ***)(a1 + 192);
  if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)uint64_t v2 = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_ERROR, "MMS Operation base class handleHTTPResponse() called.", v2, 2u);
  }
}

void sub_100572C3C(uint64_t a1, uint64_t *a2)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 112));
  uint64_t v5 = ServiceMap;
  if (v6 < 0)
  {
    unint64_t v7 = (unsigned __int8 *)(v6 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v8 = 5381;
    do
    {
      uint64_t v6 = v8;
      unsigned int v9 = *v7++;
      uint64_t v8 = (33 * v8) ^ v9;
    }
    while (v9);
  }
  std::mutex::lock(ServiceMap);
  *(void *)std::string buf = v6;
  unsigned int v10 = sub_10004D37C(&v5[1].__m_.__sig, (unint64_t *)buf);
  if (v10)
  {
    uint64_t v12 = v10[3];
    int v11 = (std::__shared_weak_count *)v10[4];
    if (v11)
    {
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v5);
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v11);
      char v13 = 0;
      if (!v12) {
        goto LABEL_7;
      }
      goto LABEL_13;
    }
  }
  else
  {
    uint64_t v12 = 0;
  }
  std::mutex::unlock(v5);
  int v11 = 0;
  char v13 = 1;
  if (!v12)
  {
LABEL_7:
    char v14 = **(NSObject ***)(a1 + 192);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "No data cache present in registry, unable to create MMS Server Connection.", buf, 2u);
    }
    unint64_t v15 = *(std::__shared_weak_count **)(a1 + 184);
    *(void *)(a1 + 176) = 0;
    *(void *)(a1 + 184) = 0;
    if (!v15) {
      goto LABEL_20;
    }
LABEL_19:
    sub_10004D2C8(v15);
    goto LABEL_20;
  }
LABEL_13:
  uint64_t v16 = *(unsigned int *)(a1 + 48);
  long long v17 = (std::__shared_weak_count *)a2[1];
  uint64_t v20 = *a2;
  int v21 = v17;
  if (v17) {
    atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  (*(void (**)(uint8_t *__return_ptr, uint64_t, uint64_t, uint64_t *))(*(void *)v12 + 264))(buf, v12, v16, &v20);
  long long v18 = *(_OWORD *)buf;
  memset(buf, 0, sizeof(buf));
  CFStringRef v19 = *(std::__shared_weak_count **)(a1 + 184);
  *(_OWORD *)(a1 + 176) = v18;
  if (v19)
  {
    sub_10004D2C8(v19);
    if (*(void *)&buf[8]) {
      sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
    }
  }
  unint64_t v15 = v21;
  if (v21) {
    goto LABEL_19;
  }
LABEL_20:
  if ((v13 & 1) == 0) {
    sub_10004D2C8(v11);
  }
}

void sub_100572E00(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  if ((v11 & 1) == 0) {
    sub_10004D2C8(v10);
  }
  _Unwind_Resume(exception_object);
}

void *sub_100572E28(uint64_t a1)
{
  (*(void (**)(void, uint64_t))(**(void **)(a1 + 176) + 72))(*(void *)(a1 + 176), a1 + 8);
  uint64_t v2 = *(void *)(a1 + 176);
  dispatch_object_t v3 = *(NSObject **)(a1 + 200);
  dispatch_object_t object = v3;
  if (v3) {
    dispatch_retain(v3);
  }
  (*(void (**)(uint64_t, dispatch_object_t *))(*(void *)v2 + 56))(v2, &object);
  if (object) {
    dispatch_release(object);
  }
  uint64_t v4 = *(void *)(a1 + 176);
  uint64_t v6 = *(void *)(a1 + 16);
  uint64_t v5 = *(void *)(a1 + 24);
  if (v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 16), 1uLL, memory_order_relaxed);
  }
  unint64_t v7 = operator new(0x20uLL);
  *unint64_t v7 = off_1019E44F8;
  v7[1] = a1;
  void v7[2] = v6;
  double v7[3] = v5;
  uint64_t v10[3] = v7;
  (*(void (**)(uint64_t, void *))(*(void *)v4 + 48))(v4, v10);
  return sub_10014BE48(v10);
}

void sub_100572F74(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, dispatch_object_t object, uint64_t a10)
{
}

uint64_t sub_100572FB0@<X0>(uint64_t a1@<X0>, char *a2@<X2>, int **a3@<X3>, void *a4@<X8>)
{
  uint64_t v8 = *(os_log_t **)(a1 + 192);
  unsigned int v9 = *v8;
  if (os_log_type_enabled(*v8, OS_LOG_TYPE_DEFAULT))
  {
    int v10 = *(_DWORD *)(a1 + 36);
    *(_DWORD *)std::string buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v10;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I Getting message from MMSC HTTP Response, MsgId %u", buf, 8u);
  }
  char v11 = *a3;
  int v12 = **a3;
  if ((v12 - 200) < 0x64)
  {
    uint64_t v46 = 0;
    *(_OWORD *)std::string __p = 0u;
    long long v45 = 0u;
    int v13 = *(_DWORD *)(a1 + 48);
    ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)__p, "com.apple.telephony", "msg.mms.pdu");
    *((void *)&v45 + 1) = 0x6A0000006ALL;
    LOWORD(v46) = 257;
    BYTE2(v46) = 1;
    HIDWORD(v46) = v13;
    __p[1] = 0;
    *(void *)&long long v45 = 0;
    char v14 = *a3;
    unint64_t v15 = *(os_log_t **)(a1 + 192);
    int v43 = *(_DWORD *)(a1 + 36);
    uint64_t v17 = *((void *)*a3 + 3);
    uint64_t v16 = *((void *)*a3 + 4);
    long long v18 = *v15;
    if (v17 == v16)
    {
      if (os_log_type_enabled(*v15, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)std::string buf = 67109120;
        *(_DWORD *)&uint8_t buf[4] = v43;
        _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "MMS response empty, MsgId: %u", buf, 8u);
      }
      operator new();
    }
    uint64_t v19 = *(unsigned int *)(a1 + 48);
    if (os_log_type_enabled(*v15, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)std::string buf = 134218240;
      *(void *)&uint8_t buf[4] = v16 - v17;
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&buf[14] = v43;
      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#I Decoding %lu byte response, MsgId %u", buf, 0x12u);
    }
    uint64_t v63 = 0;
    memset(buf, 0, sizeof(buf));
    ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)buf, "com.apple.telephony", "msg.mms.pdu");
    *(void *)&uint8_t buf[24] = 0x6A0000006ALL;
    LOWORD(v63) = 1;
    BYTE2(v63) = 1;
    HIDWORD(v63) = v19;
    *(void *)&uint8_t buf[8] = 0;
    *(void *)&uint8_t buf[16] = 0;
    unsigned int v20 = v14[8] - *((void *)v14 + 3);
    __p[1] = *((void **)v14 + 3);
    *(void *)&long long v45 = v20;
    ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 112));
    uint64_t v22 = ServiceMap;
    if (v23 < 0)
    {
      __int16 v24 = (unsigned __int8 *)(v23 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v25 = 5381;
      do
      {
        uint64_t v23 = v25;
        unsigned int v26 = *v24++;
        uint64_t v25 = (33 * v25) ^ v26;
      }
      while (v26);
    }
    std::mutex::lock(ServiceMap);
    *(void *)size_t v59 = v23;
    unsigned int v27 = sub_10004D37C(&v22[1].__m_.__sig, (unint64_t *)v59);
    if (v27)
    {
      uint64_t v29 = v27[3];
      unsigned __int8 v28 = (std::__shared_weak_count *)v27[4];
      if (v28)
      {
        atomic_fetch_add_explicit(&v28->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v22);
        atomic_fetch_add_explicit(&v28->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v28);
        char v30 = 0;
        if (!v29) {
          goto LABEL_13;
        }
        goto LABEL_26;
      }
    }
    else
    {
      uint64_t v29 = 0;
    }
    std::mutex::unlock(v22);
    unsigned __int8 v28 = 0;
    char v30 = 1;
    if (!v29)
    {
LABEL_13:
      long long v31 = *v15;
      if (os_log_type_enabled(*v15, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)size_t v59 = 67109120;
        *(_DWORD *)&v59[4] = v43;
        _os_log_error_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_ERROR, "Failed to get CarrierSettingsInterface, MsgId: %u", v59, 8u);
      }
      goto LABEL_32;
    }
LABEL_26:
    uint64_t v35 = operator new(0x10uLL);
    uint64_t v60 = v35 + 2;
    CFTypeRef v61 = v35 + 2;
    *uint64_t v35 = @"MMS";
    v35[1] = @"UseFullBufferForDecoding";
    *(void *)size_t v59 = v35;
    uint64_t v54 = 0;
    (*(void (**)(uint8_t *__return_ptr, uint64_t, uint64_t, uint64_t, uint8_t *, const CFBooleanRef, void))(*(void *)v29 + 104))(v55, v29, v19, 1, v59, kCFBooleanTrue, 0);
    sub_1000057AC(&v54, (CFTypeRef *)v55);
    sub_1000577C4((const void **)v55);
    v55[0] = 1;
    ctu::cf::assign((ctu::cf *)v55, v54, v36);
    int v37 = v55[0];
    std::string::value_type v38 = *v15;
    if (os_log_type_enabled(*v15, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v39 = "false";
      if (v37) {
        uint64_t v39 = "true";
      }
      *(_DWORD *)unsigned int v55 = 136315394;
      unint64_t v56 = v39;
      __int16 v57 = 1024;
      int v58 = v43;
      _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_DEFAULT, "#I MMS Response use full buffer: %s, MsgId: %u", v55, 0x12u);
    }
    sub_100062778((const void **)&v54);
    if (*(void *)v59)
    {
      uint64_t v60 = *(void **)v59;
      operator delete(*(void **)v59);
    }
LABEL_32:
    if ((v30 & 1) == 0) {
      sub_10004D2C8(v28);
    }
    sub_100FEEFA8();
  }
  uint64_t v32 = *v8;
  if (os_log_type_enabled(*v8, OS_LOG_TYPE_ERROR))
  {
    if (*((char *)v11 + 95) < 0)
    {
      sub_10004FC84(__p, *((void **)v11 + 9), *((void *)v11 + 10));
      char v11 = *a3;
      int v12 = **a3;
    }
    else
    {
      *(_OWORD *)std::string __p = *(_OWORD *)(v11 + 18);
      *(void *)&long long v45 = *((void *)v11 + 11);
    }
    long long v40 = __p;
    if (SBYTE7(v45) < 0) {
      long long v40 = (void **)__p[0];
    }
    uint64_t v49 = 0;
    uint64_t v50 = 0;
    memset(v53, 0, sizeof(v53));
    uint64_t v51 = 0;
    char v52 = v53;
    int v47 = v12;
    uint64_t v48 = *((void *)v11 + 1);
    if ((v12 + 3) > 8) {
      __int16 v41 = "???";
    }
    else {
      __int16 v41 = off_1019E4578[v12 + 3];
    }
    int v42 = *(_DWORD *)(a1 + 36);
    *(_DWORD *)std::string buf = 136315650;
    *(void *)&uint8_t buf[4] = v40;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = v41;
    *(_WORD *)&unsigned char buf[22] = 1024;
    *(_DWORD *)&uint8_t buf[24] = v42;
    _os_log_error_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_ERROR, "MMSC HTTP response NOT SUCCESSFUL: Status:%s Response:%s, MsgId %u", buf, 0x1Cu);
    sub_100A16310((uint64_t)&v47);
    if (SBYTE7(v45) < 0) {
      operator delete(__p[0]);
    }
    char v11 = *a3;
  }
  uint64_t result = sub_100A16494((uint64_t)v11, *(os_log_t **)(a1 + 192));
  if (result) {
    char v34 = 2;
  }
  else {
    char v34 = 1;
  }
  *a2 = v34;
  *a4 = 0;
  a4[1] = 0;
  return result;
}

void sub_100573900(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, std::__shared_weak_count *a5, ...)
{
  va_start(va, a5);
  if (a5) {
    sub_10004D2C8(a5);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)va);
  _Unwind_Resume(a1);
}

void sub_1005739C4(uint64_t a1)
{
  uint64_t v1 = **(NSObject ***)(a1 + 192);
  if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)uint64_t v2 = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_ERROR, "MMS Operation base class run() called.", v2, 2u);
  }
}

uint64_t sub_100573A2C(uint64_t *a1, uint64_t a2, char a3)
{
  if (!(*(unsigned int (**)(uint64_t *))(*a1 + 176))(a1)) {
    return 0;
  }
  if ((a3 & 1) == 0)
  {
    __p[0] = 0;
    __p[1] = 0;
    *(void *)&long long v15 = 0;
    uint64_t v6 = a1[20];
    if (v6)
    {
      unint64_t v7 = (const std::string *)(*(uint64_t (**)(uint64_t))(*(void *)v6 + 40))(v6);
      std::string::operator=((std::string *)__p, v7);
      uint64_t v8 = (SBYTE7(v15) & 0x80u) == 0 ? __p : (void **)__p[0];
    }
    else
    {
      uint64_t v8 = __p;
    }
    sub_10078E554(a2, v8);
    if (SBYTE7(v15) < 0) {
      operator delete(__p[0]);
    }
  }
  __p[0] = (void *)1;
  uint64_t v16 = 0;
  __p[1] = 0;
  long long v15 = 0uLL;
  uint64_t v9 = sub_10078F678((uint64_t)__p, a1[18]);
  if (v9)
  {
    if ((a3 & 1) == 0)
    {
      if (v15 >= 0) {
        unsigned int v10 = HIBYTE(v15);
      }
      else {
        unsigned int v10 = v15;
      }
      sub_10078E66C(a2, v10);
    }
    if (v15 >= 0) {
      char v11 = (const std::string::value_type *)&__p[1];
    }
    else {
      char v11 = (const std::string::value_type *)__p[1];
    }
    if (v15 >= 0) {
      std::string::size_type v12 = HIBYTE(v15);
    }
    else {
      std::string::size_type v12 = v15;
    }
    std::string::append((std::string *)(a2 + 8), v11, v12);
  }
  if (SHIBYTE(v15) < 0) {
    operator delete(__p[1]);
  }
  return v9;
}

void sub_100573B9C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, int a15, __int16 a16, char a17, char a18)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100573BCC@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(result + 152);
  *a2 = *(void *)(result + 144);
  a2[1] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_100573BE8(void *a1, uint64_t *a2)
{
  uint64_t v4 = (*(uint64_t (**)(void *))(*a1 + 192))(a1);
  if (v4 != (*(uint64_t (**)(uint64_t *))(*a2 + 192))(a2)) {
    return 0;
  }
  uint64_t v7 = a1[18];
  if (!v7) {
    return 0;
  }
  uint64_t v8 = a2[18];
  if (!v8) {
    return 0;
  }
  if (v7 == v8) {
    return 1;
  }
  std::string __p = 0;
  size_t __n = 0;
  uint64_t v28 = 0;
  uint64_t v23 = 0;
  uint64_t v24 = 0;
  uint64_t v25 = 0;
  uint64_t v9 = sub_100CCA3B0(v7, "X-Mms-Transaction-ID");
  if (v9
    && (*(unsigned int (**)(uint64_t, void **))(*(void *)v9 + 72))(v9, &__p)
    && (uint64_t v10 = sub_100CCA3B0(a2[18], "X-Mms-Transaction-ID")) != 0)
  {
    if ((*(uint64_t (**)(uint64_t, void **))(*(void *)v10 + 72))(v10, &v23))
    {
      if (v28 >= 0) {
        size_t v11 = HIBYTE(v28);
      }
      else {
        size_t v11 = __n;
      }
      uint64_t v12 = HIBYTE(v25);
      char v13 = HIBYTE(v25);
      if (v25 < 0) {
        uint64_t v12 = v24;
      }
      if (v11 == v12)
      {
        if (v25 >= 0) {
          char v14 = (unsigned __int8 *)&v23;
        }
        else {
          char v14 = (unsigned __int8 *)v23;
        }
        if (v28 < 0)
        {
          BOOL v5 = memcmp(__p, v14, __n) == 0;
        }
        else if (HIBYTE(v28))
        {
          uint64_t v15 = HIBYTE(v28) - 1;
          p_p = &__p;
          do
          {
            int v18 = *(unsigned __int8 *)p_p;
            p_p = (void **)((char *)p_p + 1);
            int v17 = v18;
            int v20 = *v14++;
            int v19 = v20;
            BOOL v22 = v15-- != 0;
            BOOL v5 = v17 == v19;
          }
          while (v17 == v19 && v22);
        }
        else
        {
          BOOL v5 = 1;
        }
      }
      else
      {
        BOOL v5 = 0;
      }
    }
    else
    {
      BOOL v5 = 0;
      char v13 = HIBYTE(v25);
    }
    if (v13 < 0) {
      operator delete(v23);
    }
  }
  else
  {
    BOOL v5 = 0;
  }
  if (SHIBYTE(v28) < 0) {
    operator delete(__p);
  }
  return v5;
}

void sub_100573DF0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100573E1C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void, uint64_t, const char *, uint64_t))(**(void **)(a1 + 128) + 40))(*(void *)(a1 + 128), a2, "MMS update notification.", a3);
}

uint64_t sub_100573E50(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void, uint64_t, const char *, uint64_t))(**(void **)(a1 + 120) + 40))(*(void *)(a1 + 120), a2, "MMS update notification.", a3);
}

uint64_t sub_100573E98()
{
  return 0;
}

uint64_t sub_100573EA0()
{
  return 0;
}

uint64_t sub_100573EA8()
{
  return 1;
}

void *sub_100573EB0(void *a1)
{
  *a1 = off_1019E44F8;
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_100573EFC(void *a1)
{
  *a1 = off_1019E44F8;
  uint64_t v1 = (std::__shared_weak_count *)a1[3];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

char *sub_100573F68(uint64_t a1)
{
  uint64_t result = (char *)operator new(0x20uLL);
  *(void *)uint64_t result = off_1019E44F8;
  *(_OWORD *)(result + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 24);
  *((void *)result + 3) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_100573FCC(uint64_t result, uint64_t a2)
{
  *(void *)a2 = off_1019E44F8;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(result + 8);
  uint64_t v2 = *(void *)(result + 24);
  *(void *)(a2 + 24) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_10057400C(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 24);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_10057401C(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete(__p);
}

void sub_10057405C(void *a1, uint64_t *a2)
{
  uint64_t v4 = *a2;
  uint64_t v3 = (std::__shared_weak_count *)a2[1];
  *a2 = 0;
  a2[1] = 0;
  BOOL v5 = (void **)a1[1];
  uint64_t v6 = (std::__shared_weak_count *)a1[3];
  if (v6)
  {
    uint64_t v7 = std::__shared_weak_count::lock(v6);
    if (v7 && a1[2])
    {
      uint64_t v9 = v4;
      uint64_t v10 = v3;
      if (v3) {
        atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      ((void (*)(void **, uint64_t *))(*v5)[39])(v5, &v9);
      if (v10) {
        sub_10004D2C8(v10);
      }
      goto LABEL_11;
    }
  }
  else
  {
    uint64_t v7 = 0;
  }
  uint64_t v8 = *v5[24];
  if (!os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
  {
    if (!v7) {
      goto LABEL_12;
    }
    goto LABEL_11;
  }
  LOWORD(v9) = 0;
  _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "Operation does not exist for HTTP response callback.", (uint8_t *)&v9, 2u);
  if (v7) {
LABEL_11:
  }
    sub_10004D2C8(v7);
LABEL_12:
  if (v3) {
    sub_10004D2C8(v3);
  }
}

void sub_100574178(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  sub_10004D2C8(v11);
  if (v10) {
    sub_10004D2C8(v10);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_1005741A4(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_1005741E4()
{
}

void sub_1005741F0(std::__shared_weak_count **a1@<X8>)
{
  uint64_t v2 = (std::__shared_weak_count *)operator new(0x38uLL);
  v2->__shared_owners_ = 0;
  v2->__shared_weak_owners_ = 0;
  v2->__vftable = (std::__shared_weak_count_vtbl *)off_1019E4660;
  uint64_t v3 = v2 + 1;
  sub_100574640(&v2[1].__vftable);
  v2[1].__vftable = (std::__shared_weak_count_vtbl *)off_1019E46B0;
  shared_weak_owners = (std::__shared_weak_count *)v2[1].__shared_weak_owners_;
  if (!shared_weak_owners)
  {
    atomic_fetch_add_explicit(&v2->__shared_owners_, 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit(&v2->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    v2[1].__shared_owners_ = (uint64_t)v3;
    v2[1].__shared_weak_owners_ = (uint64_t)v2;
    goto LABEL_5;
  }
  if (shared_weak_owners->__shared_owners_ == -1)
  {
    atomic_fetch_add_explicit(&v2->__shared_owners_, 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit(&v2->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    v2[1].__shared_owners_ = (uint64_t)v3;
    v2[1].__shared_weak_owners_ = (uint64_t)v2;
    std::__shared_weak_count::__release_weak(shared_weak_owners);
LABEL_5:
    sub_10004D2C8(v2);
  }
  *a1 = v3;
  a1[1] = v2;
}

void sub_1005742C4(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  operator delete(v3);
  _Unwind_Resume(a1);
}

void sub_1005742DC(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4)
{
  id v8 = objc_alloc_init((Class)NSMutableDictionary);
  uint64_t v9 = v8;
  if (*(unsigned char *)a3) {
    uint64_t v10 = &__kCFBooleanTrue;
  }
  else {
    uint64_t v10 = &__kCFBooleanFalse;
  }
  [v8 setObject:v10 forKey:LSOpenInBackgroundKey];
  if (xpc_get_type(*(xpc_object_t *)(a3 + 8)) == (xpc_type_t)&_xpc_type_dictionary)
  {
    *(void *)std::string buf = 0;
    size_t v11 = *(void **)(a3 + 8);
    xpc_object_t object = v11;
    if (v11) {
      xpc_retain(v11);
    }
    else {
      xpc_object_t object = xpc_null_create();
    }
    xpc::bridge((uint64_t *)&v27, (xpc *)&object, v12);
    sub_10004EFE4(buf, &v27);
    sub_1000577C4(&v27);
    xpc_release(object);
    [v9 setObject:*(void *)buf forKey:LSOpenApplicationPayloadOptionsKey];
    sub_100057D78((const void **)buf);
  }
  char v13 = *(NSObject **)(a1 + 24);
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    if (*((char *)a2 + 23) >= 0) {
      char v14 = a2;
    }
    else {
      char v14 = (uint64_t *)*a2;
    }
    id v15 = [v9 description];
    id v16 = [v15 UTF8String];
    *(_DWORD *)std::string buf = 136315394;
    *(void *)&uint8_t buf[4] = v14;
    __int16 v29 = 2080;
    id v30 = v16;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I Opening application with URL: %s, options: %s", buf, 0x16u);
  }
  id v17 = objc_alloc_init((Class)LSApplicationWorkspace);
  if (*((char *)a2 + 23) >= 0) {
    int v18 = a2;
  }
  else {
    int v18 = (uint64_t *)*a2;
  }
  int v19 = +[NSString stringWithUTF8String:v18];
  int v20 = +[NSURL URLWithString:v19];

  id v25 = 0;
  [v17 openSensitiveURL:v20 withOptions:v9 error:&v25];
  id v21 = v25;
  if (v21)
  {
    BOOL v22 = *(NSObject **)(a1 + 24);
    if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
    {
      id v23 = [v21 description];
      id v24 = [v23 UTF8String];
      *(_DWORD *)std::string buf = 136315138;
      *(void *)&uint8_t buf[4] = v24;
      _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "#I Completed opening application - Error: %s", buf, 0xCu);
    }
  }
  sub_1000607A8(a4, v21 == 0);
}

void sub_100574594(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, xpc_object_t object, char a12, int a13, __int16 a14, char a15, char a16)
{
  _Unwind_Resume(a1);
}

void *sub_100574640(void *a1)
{
  a1[1] = 0;
  a1[2] = 0;
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v3, kCtLoggingSystemName, "launch.services");
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v4, &v3);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 3), (const ctu::OsLogLogger *)v4);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v4);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v3);
  *a1 = off_1019E45D0;
  return a1;
}

void sub_1005746EC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v5 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)va1);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)va);
  uint64_t v4 = (std::__shared_weak_count *)*((void *)v2 + 2);
  if (v4) {
    std::__shared_weak_count::__release_weak(v4);
  }
  LaunchServicesInterface::~LaunchServicesInterface(v2);
  _Unwind_Resume(a1);
}

void sub_10057472C(void *a1)
{
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 3));
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  LaunchServicesInterface::~LaunchServicesInterface((LaunchServicesInterface *)a1);
}

void sub_100574774(void *a1)
{
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 3));
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  LaunchServicesInterface::~LaunchServicesInterface((LaunchServicesInterface *)a1);

  operator delete();
}

void sub_1005747D0(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1019E4660;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1005747F0(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1019E4660;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100574844(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_10057486C(void *a1)
{
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 3));
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  LaunchServicesInterface::~LaunchServicesInterface((LaunchServicesInterface *)a1);
}

void sub_1005748B4(void *a1)
{
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 3));
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  LaunchServicesInterface::~LaunchServicesInterface((LaunchServicesInterface *)a1);

  operator delete();
}

void sub_100574910(uint64_t a1@<X0>, uint64_t *a2@<X1>, NSObject **a3@<X2>, uint64_t *a4@<X3>, void *a5@<X8>)
{
  *a5 = 0;
  a5[1] = 0;
  uint64_t v10 = *a2;
  uint64_t v9 = (std::__shared_weak_count *)a2[1];
  size_t v11 = (char *)operator new(0xB0uLL);
  *((void *)v11 + 1) = 0;
  *((void *)v11 + 2) = 0;
  *(void *)size_t v11 = off_1019E48C8;
  if (v9) {
    atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v12 = *a3;
  if (v12) {
    dispatch_retain(v12);
  }
  char v13 = (std::__shared_weak_count *)a4[1];
  uint64_t v25 = *a4;
  if (v13) {
    atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  *((void *)v11 + 3) = off_1019E46F0;
  if (v12) {
    dispatch_retain(v12);
  }
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&__p, kCtLoggingSystemName, "wea.safety");
  if (v12)
  {
    dispatch_retain(v12);
    char v14 = dispatch_queue_attr_make_with_qos_class(0, QOS_CLASS_USER_INITIATED, 0);
    dispatch_retain(v12);
    dispatch_retain(v12);
    id v15 = dispatch_queue_create_with_target_V2("SafetyAlertGeofenceManager", v14, v12);
  }
  else
  {
    id v16 = dispatch_queue_attr_make_with_qos_class(0, QOS_CLASS_USER_INITIATED, 0);
    id v15 = dispatch_queue_create("SafetyAlertGeofenceManager", v16);
  }
  id v17 = v15;
  *((void *)v11 + 4) = 0;
  *((void *)v11 + 5) = 0;
  *((void *)v11 + 6) = v15;
  if (v15) {
    dispatch_retain(v15);
  }
  *((void *)v11 + 7) = v12;
  if (v12) {
    dispatch_retain(v12);
  }
  if (v17) {
    dispatch_release(v17);
  }
  if (v12)
  {
    dispatch_release(v12);
    dispatch_release(v12);
    dispatch_release(v12);
  }
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v31, &__p);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(v11 + 64), (const ctu::OsLogLogger *)v31);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v31);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&__p);
  if (v12) {
    dispatch_release(v12);
  }
  *((void *)v11 + 3) = off_1019E46F0;
  uint64_t v18 = *(void *)(a1 + 8);
  *((void *)v11 + 9) = *(void *)a1;
  *((void *)v11 + 10) = v18;
  if (v18) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v18 + 8), 1uLL, memory_order_relaxed);
  }
  unsigned int v26 = v11 + 24;
  sub_100058DB0(&__p, "SafetyAlertGeofenceManager");
  int v19 = *((void *)v11 + 6);
  uint64_t v28 = v19;
  if (v19) {
    dispatch_retain(v19);
  }
  int v20 = *((void *)v11 + 7);
  xpc_object_t object = v20;
  if (v20) {
    dispatch_retain(v20);
  }
  ctu::RestModule::RestModule();
  if (object) {
    dispatch_release(object);
  }
  if (v28) {
    dispatch_release(v28);
  }
  if (v30 < 0) {
    operator delete(__p.var0);
  }
  *((void *)v11 + 13) = v10;
  *((void *)v11 + 14) = v9;
  if (v9) {
    atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  v11[120] = 0;
  *((void *)v11 + 16) = 0;
  id v21 = operator new(0x48uLL);
  BOOL v22 = v21;
  v21[1] = 0;
  void v21[2] = 0;
  void *v21 = off_1019E4878;
  id v23 = v21 + 3;
  v31[0] = v10;
  v31[1] = v9;
  if (v9) {
    atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  sub_100DC06A0((ctu::OsLogLogger *)(v21 + 3), v31);
  if (v9) {
    sub_10004D2C8(v9);
  }
  *((void *)v11 + 19) = 0;
  *((void *)v11 + 17) = v23;
  *((void *)v11 + 18) = v22;
  *((void *)v11 + 20) = v25;
  *((void *)v11 + 21) = v13;
  if (v13) {
    atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (!*((void *)v11 + 13)) {
    __TUAssertTrigger();
  }
  if (!*((void *)v11 + 17)) {
    __TUAssertTrigger();
  }
  if (v13) {
    sub_10004D2C8(v13);
  }
  if (v12) {
    dispatch_release(v12);
  }
  if (v9) {
    sub_10004D2C8(v9);
  }
  *a5 = v26;
  a5[1] = v11;
  id v24 = (std::__shared_weak_count *)*((void *)v11 + 5);
  if (v24)
  {
    if (v24->__shared_owners_ != -1) {
      goto LABEL_57;
    }
    atomic_fetch_add_explicit((atomic_ullong *volatile)v11 + 1, 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit((atomic_ullong *volatile)v11 + 2, 1uLL, memory_order_relaxed);
    *((void *)v11 + 4) = v26;
    *((void *)v11 + 5) = v11;
    std::__shared_weak_count::__release_weak(v24);
  }
  else
  {
    atomic_fetch_add_explicit((atomic_ullong *volatile)v11 + 1, 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit((atomic_ullong *volatile)v11 + 2, 1uLL, memory_order_relaxed);
    *((void *)v11 + 4) = v26;
    *((void *)v11 + 5) = v11;
  }
  sub_10004D2C8((std::__shared_weak_count *)v11);
LABEL_57:
  __p.var0 = 0;
  __p.var1.fRef = 0;
  Registry::getServiceManager((uint64_t *)&__p, *(Registry **)a1);
  if (__p.var0)
  {
    atomic_fetch_add_explicit((atomic_ullong *volatile)v11 + 1, 1uLL, memory_order_relaxed);
    operator new();
  }
  if (__p.var1.fRef) {
    sub_10004D2C8((std::__shared_weak_count *)__p.var1.fRef);
  }
}

void sub_100574DA4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, ctu::OsLogLogger *a9, uint64_t a10, uint64_t a11, SafetyAlertGeofenceManagerInterface *a12, uint64_t a13, dispatch_object_t object, dispatch_object_t a15, void *__p, std::__shared_weak_count *a17, int a18, __int16 a19, char a20,char a21,uint64_t a22)
{
  if (a22) {
    (*(void (**)(uint64_t))(*(void *)a22 + 8))(a22);
  }
  if (a17) {
    sub_10004D2C8(a17);
  }
  sub_10004D2C8(v22);
  _Unwind_Resume(a1);
}

void sub_100574F84(uint64_t a1, dispatch_object_t object)
{
  if (object)
  {
    dispatch_retain(object);
    dispatch_group_enter(object);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

uint64_t sub_100575084(uint64_t a1)
{
  uint64_t v2 = (*(uint64_t (**)(void))(**(void **)(a1 + 80) + 24))(*(void *)(a1 + 80));
  OsLogContext v3 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v4 = "false";
    if (v2) {
      uint64_t v4 = "true";
    }
    int v6 = 136315138;
    uint64_t v7 = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Circular Geofence Supported: %s", (uint8_t *)&v6, 0xCu);
  }
  return v2;
}

uint64_t sub_100575168(uint64_t a1)
{
  uint64_t v2 = (*(uint64_t (**)(void))(**(void **)(a1 + 80) + 32))(*(void *)(a1 + 80));
  OsLogContext v3 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v4 = "false";
    if (v2) {
      uint64_t v4 = "true";
    }
    int v6 = 136315138;
    uint64_t v7 = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Polygonal Geofence Supported: %s", (uint8_t *)&v6, 0xCu);
  }
  return v2;
}

BOOL sub_10057524C(uint64_t a1)
{
  uint64_t v2 = operator new(0x18uLL);
  id v23 = v2 + 3;
  id v24 = (char *)(v2 + 3);
  void v2[2] = @"FeatureEnabled";
  *(_OWORD *)uint64_t v2 = *(_OWORD *)off_1019E4790;
  OsLogContext __p = v2;
  if (((*(uint64_t (**)(void))(**(void **)(a1 + 80) + 16))(*(void *)(a1 + 80)) & 1) == 0)
  {
    size_t v11 = *(NSObject **)(a1 + 40);
    BOOL v12 = 0;
    if (!os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_26;
    }
    *(_WORD *)std::string buf = 0;
    char v13 = "#I Safety alert Geofence not supported. Location services disabled.";
    goto LABEL_22;
  }
  if (((*(uint64_t (**)(void))(**(void **)(a1 + 80) + 32))(*(void *)(a1 + 80)) & 1) == 0)
  {
    char v14 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "Polygonal geofence is not supported", buf, 2u);
    }
    goto LABEL_25;
  }
  subscriber::makeSimSlotRange();
  uint64_t v4 = *(unsigned int **)buf;
  OsLogContext v3 = v20;
  if (*(unsigned int **)buf == v20) {
    goto LABEL_18;
  }
  uint64_t v5 = v21;
  while ((v21(*v4) & 1) == 0)
  {
    if (++v4 == v20)
    {
      uint64_t v4 = v20;
      break;
    }
  }
  int v6 = v20;
  if (v4 == v20)
  {
LABEL_18:
    size_t v11 = *(NSObject **)(a1 + 40);
    BOOL v12 = 0;
    if (!os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_26;
    }
    *(_WORD *)std::string buf = 0;
    char v13 = "#I Safety alert Geofence not supported from bundle";
LABEL_22:
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, v13, buf, 2u);
LABEL_25:
    BOOL v12 = 0;
    goto LABEL_26;
  }
  while (1)
  {
    uint64_t v7 = *v4;
    uint64_t v18 = 0;
    sub_1007EC3B4(*(Registry ***)(a1 + 136), v7, 2, (uint64_t)&__p, (uint64_t)kCFBooleanFalse, 0, &v17);
    sub_1000057AC(&v18, &v17);
    sub_1000577C4(&v17);
    LOBYTE(v17) = 0;
    ctu::cf::assign((ctu::cf *)&v17, v18, v8);
    if ((_BYTE)v17) {
      break;
    }
    uint64_t v9 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v17) = 0;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I Safety alert Geofence NOT supported", (uint8_t *)&v17, 2u);
    }
    sub_100062778((const void **)&v18);
    uint64_t v10 = v4 + 1;
    uint64_t v4 = v3;
    if (v10 != v3)
    {
      uint64_t v4 = v10;
      while ((v5(*v4) & 1) == 0)
      {
        if (++v4 == v3)
        {
          uint64_t v4 = v3;
          break;
        }
      }
    }
    if (v4 == v6) {
      goto LABEL_18;
    }
  }
  BOOL v12 = *(unsigned char *)(a1 + 96) == 0;
  if (*(unsigned char *)(a1 + 96))
  {
    id v16 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v17) = 0;
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I Geofencing not supported in battery saver mode...", (uint8_t *)&v17, 2u);
    }
  }
  sub_100062778((const void **)&v18);
LABEL_26:
  if (__p)
  {
    id v23 = __p;
    operator delete(__p);
  }
  return v12;
}

void sub_100575564(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_1005755B0(uint64_t a1)
{
  uint64_t v5 = a1;
  if (*(void *)(a1 + 32) && dispatch_workloop_is_current()) {
    return sub_10057524C(a1);
  }
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472;
  void v6[2] = sub_100578F1C;
  void v6[3] = &unk_10199E4C0;
  void v6[4] = a1 + 8;
  v6[5] = &v5;
  uint64_t v7 = objc_retainBlock(v6);
  OsLogContext v3 = *(NSObject **)(a1 + 24);
  if (*(void *)(a1 + 32))
  {
    char v14 = 0;
    blocunint64_t k = _NSConcreteStackBlock;
    uint64_t v9 = 3221225472;
    uint64_t v10 = sub_100578F64;
    size_t v11 = &unk_10199E470;
    BOOL v12 = &v14;
    char v13 = &v7;
    dispatch_async_and_wait(v3, &block);
  }
  else
  {
    char v14 = 0;
    blocunint64_t k = _NSConcreteStackBlock;
    uint64_t v9 = 3221225472;
    uint64_t v10 = sub_100578F28;
    size_t v11 = &unk_10199E470;
    BOOL v12 = &v14;
    char v13 = &v7;
    dispatch_sync(v3, &block);
  }
  BOOL v2 = v14 != 0;

  return v2;
}

uint64_t sub_100575730(uint64_t a1, void ***a2)
{
  v9[0] = a1;
  v9[1] = a2;
  if (*(void *)(a1 + 32) && dispatch_workloop_is_current())
  {
    uint64_t v4 = *a2;
    uint64_t v5 = (std::__shared_weak_count *)a2[1];
    blocunint64_t k = v4;
    uint64_t v13 = (uint64_t)v5;
    if (v5) {
      atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    uint64_t v6 = sub_1005758F0(a1, (uint64_t *)&block);
    if (v5) {
      sub_10004D2C8(v5);
    }
  }
  else
  {
    v10[0] = _NSConcreteStackBlock;
    v10[1] = 3221225472;
    uint64_t v10[2] = sub_100578FA0;
    uint64_t v10[3] = &unk_10199E4C0;
    void v10[4] = a1 + 8;
    v10[5] = v9;
    size_t v11 = objc_retainBlock(v10);
    uint64_t v7 = *(NSObject **)(a1 + 24);
    if (*(void *)(a1 + 32))
    {
      char v18 = 0;
      blocunint64_t k = _NSConcreteStackBlock;
      uint64_t v13 = 3221225472;
      char v14 = sub_100578F64;
      id v15 = &unk_10199E470;
      id v16 = &v18;
      id v17 = &v11;
      dispatch_async_and_wait(v7, &block);
    }
    else
    {
      char v18 = 0;
      blocunint64_t k = _NSConcreteStackBlock;
      uint64_t v13 = 3221225472;
      char v14 = sub_100578F28;
      id v15 = &unk_10199E470;
      id v16 = &v18;
      id v17 = &v11;
      dispatch_sync(v7, &block);
    }
    uint64_t v6 = v18 != 0;
  }
  return v6;
}

void sub_1005758D8(void *a1)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  sub_10006A6AC(a1);
}

uint64_t sub_1005758F0(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *a2;
  if (*a2)
  {
    uint64_t v5 = *(void *)(v3 + 16);
    uint64_t v6 = *(std::__shared_weak_count **)(v3 + 24);
    if (v6) {
      atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    long long v45 = 0;
    uint64_t v46 = 0;
    uint64_t v47 = 0;
    sub_1012F8AB4(&v45, *(void **)(v5 + 24), *(void **)(v5 + 32), (uint64_t)(*(void *)(v5 + 32) - *(void *)(v5 + 24)) >> 4);
    if (v6) {
      sub_10004D2C8(v6);
    }
    uint64_t v7 = *(void *)(*a2 + 16);
    CFBooleanRef v8 = *(std::__shared_weak_count **)(*a2 + 24);
    if (v8) {
      atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    uint64_t v42 = 0;
    uint64_t v43 = 0;
    uint64_t v44 = 0;
    sub_1012F8BC8(&v42, *(void **)(v7 + 48), *(void **)(v7 + 56), (uint64_t)(*(void *)(v7 + 56) - *(void *)(v7 + 48)) >> 4);
    if (v8) {
      sub_10004D2C8(v8);
    }
    uint64_t v9 = v45;
    uint64_t v10 = v46;
    if (v46 == v45 && v43 == v42)
    {
      long long v31 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
      {
        LOWORD(__p[0]) = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_ERROR, "Invalid shapes for CB decoder", (uint8_t *)__p, 2u);
      }
      uint64_t v13 = 0;
    }
    else
    {
      uint64_t v11 = *a2;
      if (*(char *)(*a2 + 111) < 0)
      {
        sub_10004FC84(__dst, *(void **)(v11 + 88), *(void *)(v11 + 96));
        uint64_t v9 = v45;
        uint64_t v10 = v46;
      }
      else
      {
        *(_OWORD *)long long __dst = *(_OWORD *)(v11 + 88);
        uint64_t v41 = *(void *)(v11 + 104);
      }
      uint64_t v37 = 0;
      uint64_t v38 = 0;
      uint64_t v39 = 0;
      char v34 = 0;
      uint64_t v35 = 0;
      CFBooleanRef v36 = 0;
      while (v9 != v10)
      {
        uint64_t v14 = *v9;
        memset(__p, 0, sizeof(__p));
        sub_1004081A4(__p, *(const void **)(v14 + 64), *(void *)(v14 + 72), (uint64_t)(*(void *)(v14 + 72) - *(void *)(v14 + 64)) >> 4);
        sub_100575E60(&v37, (uint64_t)__p);
        if (__p[0])
        {
          __p[1] = __p[0];
          operator delete(__p[0]);
        }
        v9 += 2;
      }
      uint64_t v15 = v42;
      uint64_t v16 = v43;
      if (v42 != v43)
      {
        id v17 = v35;
        do
        {
          uint64_t v19 = *(void *)(*(void *)v15 + 64);
          uint64_t v18 = *(void *)(*(void *)v15 + 72);
          uint64_t v20 = *(void *)(*(void *)v15 + 80);
          if (v17 >= v36)
          {
            id v21 = (char *)v34;
            unint64_t v22 = 0xAAAAAAAAAAAAAAABLL * ((v17 - (unsigned char *)v34) >> 3);
            unint64_t v23 = v22 + 1;
            if (v22 + 1 > 0xAAAAAAAAAAAAAAALL) {
              sub_100578470();
            }
            if (0x5555555555555556 * ((v36 - (unsigned char *)v34) >> 3) > v23) {
              unint64_t v23 = 0x5555555555555556 * ((v36 - (unsigned char *)v34) >> 3);
            }
            if (0xAAAAAAAAAAAAAAABLL * ((v36 - (unsigned char *)v34) >> 3) >= 0x555555555555555) {
              unint64_t v24 = 0xAAAAAAAAAAAAAAALL;
            }
            else {
              unint64_t v24 = v23;
            }
            if (v24)
            {
              uint64_t v25 = (char *)sub_10004812C((uint64_t)&v36, v24);
              id v21 = (char *)v34;
              id v17 = v35;
            }
            else
            {
              uint64_t v25 = 0;
            }
            unsigned int v26 = &v25[24 * v22];
            *(void *)unsigned int v26 = v19;
            *((void *)v26 + 1) = v18;
            *((void *)v26 + 2) = v20;
            unsigned int v27 = v26;
            if (v17 != v21)
            {
              do
              {
                long long v28 = *(_OWORD *)(v17 - 24);
                *((void *)v27 - 1) = *((void *)v17 - 1);
                *(_OWORD *)(v27 - 24) = v28;
                v27 -= 24;
                v17 -= 24;
              }
              while (v17 != v21);
              id v21 = (char *)v34;
            }
            id v17 = v26 + 24;
            char v34 = v27;
            uint64_t v35 = v26 + 24;
            CFBooleanRef v36 = &v25[24 * v24];
            if (v21) {
              operator delete(v21);
            }
          }
          else
          {
            *(void *)id v17 = v19;
            *((void *)v17 + 1) = v18;
            *((void *)v17 + 2) = v20;
            v17 += 24;
          }
          uint64_t v35 = v17;
          v15 += 16;
        }
        while (v15 != v16);
      }
      __int16 v29 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
      {
        LODWORD(__p[0]) = 134218240;
        *(void **)((char *)__p + 4) = (void *)(0xAAAAAAAAAAAAAAABLL * ((v38 - v37) >> 3));
        WORD2(__p[1]) = 2048;
        *(void **)((char *)&__p[1] + 6) = (void *)(0xAAAAAAAAAAAAAAABLL * ((v35 - (unsigned char *)v34) >> 3));
        _os_log_error_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_ERROR, "Early geofencing for: %zu polygons and %zu circles", (uint8_t *)__p, 0x16u);
      }
      uint64_t v30 = *(void *)(a1 + 112);
      sub_10122FBA0((uint64_t)__p, &v37, (long long **)&v34);
      sub_100575FA0(&v33, a1);
      uint64_t v13 = sub_100DC120C(v30, (unsigned __int8 *)__dst, (uint64_t *)__p, &v33);
      sub_100057D78(&v33);
      if (v50)
      {
        uint64_t v51 = v50;
        operator delete(v50);
      }
      uint64_t v48 = __p;
      sub_10011FF94(&v48);
      if (v34)
      {
        uint64_t v35 = (char *)v34;
        operator delete(v34);
      }
      __p[0] = &v37;
      sub_10011FF94((void ***)__p);
      if (SHIBYTE(v41) < 0) {
        operator delete(__dst[0]);
      }
    }
    __p[0] = &v42;
    sub_10005CBF0((void ***)__p);
    __p[0] = &v45;
    sub_10005CBF0((void ***)__p);
  }
  else
  {
    BOOL v12 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      LOWORD(__p[0]) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "Invalid CB Decoder", (uint8_t *)__p, 2u);
    }
    return 0;
  }
  return v13;
}

void sub_100575D90(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, void *__p, uint64_t a12, uint64_t a13, char a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,char a23,uint64_t a24,uint64_t a25,char a26,uint64_t a27,uint64_t a28,uint64_t a29,char *a30,uint64_t a31)
{
  a30 = &a23;
  sub_10005CBF0((void ***)&a30);
  a30 = &a26;
  sub_10005CBF0((void ***)&a30);
  _Unwind_Resume(a1);
}

uint64_t sub_100575E60(uint64_t *a1, uint64_t a2)
{
  unint64_t v6 = a1[2];
  uint64_t result = (uint64_t)(a1 + 2);
  unint64_t v5 = v6;
  uint64_t v7 = *(void **)(result - 8);
  if ((unint64_t)v7 >= v6)
  {
    unint64_t v9 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v7 - *a1) >> 3);
    unint64_t v10 = v9 + 1;
    if (v9 + 1 > 0xAAAAAAAAAAAAAAALL) {
      sub_100578470();
    }
    unint64_t v11 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v5 - *a1) >> 3);
    if (2 * v11 > v10) {
      unint64_t v10 = 2 * v11;
    }
    if (v11 >= 0x555555555555555) {
      unint64_t v12 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v12 = v10;
    }
    void v16[4] = result;
    uint64_t v13 = (char *)sub_10004812C(result, v12);
    uint64_t v14 = &v13[24 * v9];
    v16[0] = v13;
    v16[1] = v14;
    void v16[3] = &v13[24 * v15];
    *((void *)v14 + 1) = 0;
    *((void *)v14 + 2) = 0;
    *(void *)uint64_t v14 = 0;
    *(_OWORD *)uint64_t v14 = *(_OWORD *)a2;
    *((void *)v14 + 2) = *(void *)(a2 + 16);
    *(void *)a2 = 0;
    *(void *)(a2 + 8) = 0;
    *(void *)(a2 + 16) = 0;
    void v16[2] = v14 + 24;
    sub_1005783F8(a1, v16);
    CFBooleanRef v8 = (void *)a1[1];
    uint64_t result = sub_100205838((uint64_t)v16);
  }
  else
  {
    *uint64_t v7 = 0;
    v7[1] = 0;
    void v7[2] = 0;
    *(_OWORD *)uint64_t v7 = *(_OWORD *)a2;
    void v7[2] = *(void *)(a2 + 16);
    *(void *)a2 = 0;
    *(void *)(a2 + 8) = 0;
    *(void *)(a2 + 16) = 0;
    CFBooleanRef v8 = v7 + 3;
    a1[1] = (uint64_t)(v7 + 3);
  }
  a1[1] = (uint64_t)v8;
  return result;
}

void sub_100575F8C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100205838((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_100575FA0(const void **a1, uint64_t a2)
{
  uint64_t v5 = *(void *)(a2 + 128);
  uint64_t v4 = (const void **)(a2 + 128);
  if (v5) {
    unint64_t v6 = sub_100080778;
  }
  else {
    unint64_t v6 = 0;
  }
  if (v6)
  {
    sub_100058198(a1, v4);
  }
  else
  {
    uint64_t v7 = operator new(0x18uLL);
    uint64_t v13 = v7 + 3;
    uint64_t v14 = (char *)(v7 + 3);
    *(_OWORD *)uint64_t v7 = *(_OWORD *)off_1019E47A8;
    void v7[2] = @"CustomGeofencingScalars";
    unint64_t v11 = 0;
    OsLogContext __p = v7;
    sub_1007EC3B4(*(Registry ***)(a2 + 136), 1, 2, (uint64_t)&__p, 0, 0, buf);
    sub_10004EFE4(&v11, (CFTypeRef *)buf);
    sub_1000577C4((const void **)buf);
    CFBooleanRef v8 = v11;
    if (v11) {
      unint64_t v9 = sub_100080778;
    }
    else {
      unint64_t v9 = 0;
    }
    if (v9)
    {
      unint64_t v10 = *(NSObject **)(a2 + 40);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)std::string buf = 138543362;
        uint64_t v16 = v8;
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I Custom Geofencing Scalars from bundle: %{public}@", buf, 0xCu);
        CFBooleanRef v8 = v11;
      }
      *a1 = v8;
      unint64_t v11 = 0;
    }
    else
    {
      *a1 = 0;
    }
    sub_100057D78(&v11);
    if (__p)
    {
      uint64_t v13 = __p;
      operator delete(__p);
    }
  }
}

void sub_100576154(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, const void *a13)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100576180(uint64_t a1)
{
  BOOL v2 = *(void **)(a1 + 24);
  if (v2)
  {
    *(void *)(a1 + 32) = v2;
    operator delete(v2);
  }
  uint64_t v4 = (void **)a1;
  sub_10011FF94(&v4);
  return a1;
}

void sub_1005761C8(uint64_t a1, const void **a2, uint64_t a3, uint64_t a4)
{
  sub_100058198((const void **)&v8 + 1, a2);
  if (*(char *)(a3 + 23) < 0)
  {
    sub_10004FC84(v9, *(void **)a3, *(void *)(a3 + 8));
  }
  else
  {
    *(_OWORD *)unint64_t v9 = *(_OWORD *)a3;
    void v9[2] = *(void **)(a3 + 16);
  }
  if (*(char *)(a4 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a4, *(void *)(a4 + 8));
  }
  else
  {
    *(_OWORD *)OsLogContext __p = *(_OWORD *)a4;
    xpc_object_t __p[2] = *(void **)(a4 + 16);
  }
  uint64_t v7 = *(std::__shared_weak_count **)(a1 + 16);
  if (v7)
  {
    if (std::__shared_weak_count::lock(v7)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_1005763AC(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (*(char *)(v16 + 39) < 0) {
    operator delete(*v17);
  }
  sub_100057D78((const void **)(v16 + 8));
  sub_10006A6AC(a1);
}

void sub_100576410(void *a1, uint64_t a2, CFArrayRef theArray)
{
  OsLogContext __p = 0;
  uint64_t v39 = 0;
  long long v40 = 0;
  CFIndex Count = CFArrayGetCount(theArray);
  if (Count < 1)
  {
    uint64_t v30 = 0;
    uint64_t v20 = 0;
    __int16 v29 = 0;
LABEL_32:
    *a1 = v29;
    a1[1] = v20;
    a1[2] = v30;
  }
  else
  {
    CFIndex v6 = 0;
    while (1)
    {
      CFArrayRef ValueAtIndex = (const __CFArray *)CFArrayGetValueAtIndex(theArray, v6);
      CFArrayRef v8 = ValueAtIndex;
      if (ValueAtIndex)
      {
        CFTypeID v9 = CFGetTypeID(ValueAtIndex);
        if (v9 != CFArrayGetTypeID()) {
          CFArrayRef v8 = 0;
        }
      }
      CFIndex v10 = CFArrayGetCount(v8);
      if (v10 != 2) {
        break;
      }
      CFNumberRef v11 = (const __CFNumber *)CFArrayGetValueAtIndex(v8, 0);
      CFNumberRef v12 = v11;
      if (v11)
      {
        CFTypeID v13 = CFGetTypeID(v11);
        if (v13 != CFNumberGetTypeID()) {
          CFNumberRef v12 = 0;
        }
      }
      CFNumberRef v14 = (const __CFNumber *)CFArrayGetValueAtIndex(v8, 1);
      CFNumberRef v15 = v14;
      if (!v14 || (CFTypeID v16 = CFGetTypeID(v14), v16 != CFNumberGetTypeID()) || !v12)
      {
        long long v31 = *(NSObject **)(a2 + 40);
        if (!os_log_type_enabled(v31, OS_LOG_TYPE_ERROR)) {
          goto LABEL_36;
        }
        *(_WORD *)valuePtr = 0;
        uint64_t v32 = "Invalid lat/long combination";
        uint64_t v33 = v31;
        uint32_t v34 = 2;
        goto LABEL_40;
      }
      *(void *)valuePtr = 0;
      uint64_t v37 = 0;
      CFNumberGetValue(v12, kCFNumberDoubleType, valuePtr);
      CFNumberGetValue(v15, kCFNumberDoubleType, &v37);
      uint64_t v17 = v37;
      uint64_t v18 = *(void *)valuePtr;
      uint64_t v19 = v39;
      if (v39 >= v40)
      {
        id v21 = (char *)__p;
        uint64_t v22 = (v39 - (unsigned char *)__p) >> 4;
        unint64_t v23 = v22 + 1;
        if ((unint64_t)(v22 + 1) >> 60) {
          sub_100408264();
        }
        uint64_t v24 = v40 - (unsigned char *)__p;
        if ((v40 - (unsigned char *)__p) >> 3 > v23) {
          unint64_t v23 = v24 >> 3;
        }
        if ((unint64_t)v24 >= 0x7FFFFFFFFFFFFFF0) {
          unint64_t v25 = 0xFFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v25 = v23;
        }
        if (v25)
        {
          unsigned int v26 = (char *)sub_10006A794((uint64_t)&v40, v25);
          id v21 = (char *)__p;
          uint64_t v19 = v39;
        }
        else
        {
          unsigned int v26 = 0;
        }
        unsigned int v27 = &v26[16 * v22];
        *(void *)unsigned int v27 = v17;
        *((void *)v27 + 1) = v18;
        long long v28 = v27;
        if (v19 != v21)
        {
          do
          {
            *((_OWORD *)v28 - 1) = *((_OWORD *)v19 - 1);
            v28 -= 16;
            v19 -= 16;
          }
          while (v19 != v21);
          id v21 = (char *)__p;
        }
        uint64_t v20 = v27 + 16;
        OsLogContext __p = v28;
        uint64_t v39 = v27 + 16;
        long long v40 = &v26[16 * v25];
        if (v21) {
          operator delete(v21);
        }
      }
      else
      {
        *(void *)uint64_t v39 = v37;
        *((void *)v19 + 1) = v18;
        uint64_t v20 = v19 + 16;
      }
      uint64_t v39 = v20;
      if (++v6 == Count)
      {
        __int16 v29 = __p;
        uint64_t v30 = v40;
        goto LABEL_32;
      }
    }
    uint64_t v35 = *(NSObject **)(a2 + 40);
    if (!os_log_type_enabled(v35, OS_LOG_TYPE_ERROR)) {
      goto LABEL_36;
    }
    *(_DWORD *)valuePtr = 134217984;
    *(void *)&valuePtr[4] = v10;
    uint64_t v32 = "Invalid length of coordinates: %ld";
    uint64_t v33 = v35;
    uint32_t v34 = 12;
LABEL_40:
    _os_log_error_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_ERROR, v32, valuePtr, v34);
LABEL_36:
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
    if (__p)
    {
      uint64_t v39 = (char *)__p;
      operator delete(__p);
    }
  }
}

void sub_100576728(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100576760(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    uint64_t v2 = *(void *)(a1 + 112);
    if (*(char *)(a2 + 111) < 0)
    {
      sub_10004FC84(__p, *(void **)(a2 + 88), *(void *)(a2 + 96));
    }
    else
    {
      *(_OWORD *)OsLogContext __p = *(_OWORD *)(a2 + 88);
      uint64_t v5 = *(void *)(a2 + 104);
    }
    sub_100DC1D04(v2, (const void **)__p);
    if (SHIBYTE(v5) < 0) {
      operator delete(__p[0]);
    }
  }
  else
  {
    uint64_t v3 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      LOWORD(__p[0]) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "Invalid decoder object", (uint8_t *)__p, 2u);
    }
  }
}

void sub_100576818(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100576834(uint64_t a1, uint64_t *a2)
{
  v8[0] = a1;
  v8[1] = a2;
  if (*(void *)(a1 + 32) && dispatch_workloop_is_current())
  {
    uint64_t v4 = *a2;
    uint64_t v5 = (std::__shared_weak_count *)a2[1];
    if (v5) {
      atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    sub_100576760(a1, v4);
    if (v5)
    {
      sub_10004D2C8(v5);
    }
  }
  else
  {
    v9[0] = _NSConcreteStackBlock;
    v9[1] = 3221225472;
    void v9[2] = sub_100579C8C;
    void v9[3] = &unk_10199E470;
    void v9[4] = a1 + 8;
    v9[5] = v8;
    CFIndex v6 = objc_retainBlock(v9);
    uint64_t v7 = *(NSObject **)(a1 + 24);
    if (*(void *)(a1 + 32)) {
      dispatch_async_and_wait(v7, v6);
    }
    else {
      dispatch_sync(v7, v6);
    }
  }
}

void sub_100576930(void *a1)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  sub_10006A6AC(a1);
}

void sub_100576948(uint64_t a1, const void **a2)
{
  sub_100058140((const void **)(a1 + 128), a2);
  if (*(void *)(a1 + 128)) {
    uint64_t v4 = sub_100080778;
  }
  else {
    uint64_t v4 = 0;
  }
  uint64_t v5 = *(NSObject **)(a1 + 40);
  BOOL v6 = os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT);
  if (v4)
  {
    if (!v6) {
      return;
    }
    uint64_t v7 = *a2;
    int v11 = 138543362;
    CFNumberRef v12 = v7;
    CFArrayRef v8 = "#I Custom Geofencing Scalars: %{public}@";
    CFTypeID v9 = v5;
    uint32_t v10 = 12;
  }
  else
  {
    if (!v6) {
      return;
    }
    LOWORD(v11) = 0;
    CFArrayRef v8 = "#I Custom Geofencing Scalars reset";
    CFTypeID v9 = v5;
    uint32_t v10 = 2;
  }
  _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, v8, (uint8_t *)&v11, v10);
}

const void **sub_100576A48(void *a1, const void **a2)
{
  BOOL v6 = a1;
  sub_100058198(&v7, a2);
  if (a1[4] && dispatch_workloop_is_current())
  {
    v8[0] = v7;
    if (v7) {
      CFRetain(v7);
    }
    sub_100576948((uint64_t)v6, v8);
    sub_100057D78(v8);
  }
  else
  {
    v8[0] = _NSConcreteStackBlock;
    v8[1] = (const void *)3221225472;
    void v8[2] = sub_100579D04;
    v8[3] = &unk_10199E470;
    void v8[4] = a1 + 1;
    v8[5] = &v6;
    uint64_t v3 = objc_retainBlock(v8);
    uint64_t v4 = a1[3];
    if (a1[4]) {
      dispatch_async_and_wait(v4, v3);
    }
    else {
      dispatch_sync(v4, v3);
    }
  }
  return sub_100057D78(&v7);
}

void sub_100576B44(uint64_t a1@<X0>, const void **a2@<X8>)
{
  uint64_t v5 = a1;
  if (*(void *)(a1 + 32) && dispatch_workloop_is_current())
  {
    sub_100575FA0(a2, a1);
  }
  else
  {
    v6[0] = _NSConcreteStackBlock;
    v6[1] = 3221225472;
    void v6[2] = sub_100579D4C;
    void v6[3] = &unk_1019E4988;
    void v6[4] = a1 + 8;
    v6[5] = &v5;
    uint64_t v7 = objc_retainBlock(v6);
    uint64_t v4 = *(NSObject **)(a1 + 24);
    if (*(void *)(a1 + 32))
    {
      *a2 = 0;
      blocunint64_t k = _NSConcreteStackBlock;
      uint64_t v9 = 3221225472;
      uint32_t v10 = sub_100579DD4;
      int v11 = &unk_10199E470;
      CFNumberRef v12 = a2;
      CFTypeID v13 = &v7;
      dispatch_async_and_wait(v4, &block);
    }
    else
    {
      *a2 = 0;
      blocunint64_t k = _NSConcreteStackBlock;
      uint64_t v9 = 3221225472;
      uint32_t v10 = sub_100579D5C;
      int v11 = &unk_10199E470;
      CFNumberRef v12 = a2;
      CFTypeID v13 = &v7;
      dispatch_sync(v4, &block);
    }
  }
}

uint64_t sub_100576CB0(void *a1)
{
  uint64_t v2 = a1[5];
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v4 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Geofencing failed", v4, 2u);
  }
  return sub_100576D1C(a1);
}

uint64_t sub_100576D1C(void *a1)
{
  sub_10019E028((uint64_t *)(a1[14] + 8));
  uint64_t v2 = a1[5];
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v4 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Resetting all monitoring..", v4, 2u);
  }
  uint64_t result = a1[13];
  a1[13] = 0;
  if (result)
  {
    (*(void (**)(uint64_t))(*(void *)result + 8))(result);
    uint64_t result = a1[13];
    a1[13] = 0;
    if (result) {
      return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
    }
  }
  return result;
}

uint64_t sub_100576DEC(void *a1)
{
  uint64_t v2 = a1[5];
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v4 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Location Services disabled", v4, 2u);
  }
  return sub_100576D1C(a1);
}

uint64_t sub_100576E58(void *a1, uint64_t *a2)
{
  uint64_t v4 = a1[5];
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    if (*((char *)a2 + 23) >= 0) {
      uint64_t v5 = a2;
    }
    else {
      uint64_t v5 = (uint64_t *)*a2;
    }
    int v7 = 136446210;
    CFArrayRef v8 = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Setup error: %{public}s", (uint8_t *)&v7, 0xCu);
  }
  return sub_100576D1C(a1);
}

void sub_100576F18(uint64_t a1, void **a2)
{
  uint64_t v4 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    if (*((char *)a2 + 23) >= 0) {
      uint64_t v5 = a2;
    }
    else {
      uint64_t v5 = *a2;
    }
    *(_DWORD *)std::string buf = 136446210;
    uint64_t v9 = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Monitoring started: %{public}s", buf, 0xCu);
  }
  if (*((char *)a2 + 23) < 0)
  {
    sub_10004FC84(__p, *a2, (unint64_t)a2[1]);
  }
  else
  {
    *(_OWORD *)OsLogContext __p = *(_OWORD *)a2;
    int v7 = a2[2];
  }
  sub_100DC1B38(*(void *)(a1 + 112), __p, 1);
  if (SHIBYTE(v7) < 0) {
    operator delete(__p[0]);
  }
}

void sub_100577018(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
}

uint64_t sub_10057703C(void *a1, uint64_t *a2)
{
  uint64_t v4 = a1[5];
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    if (*((char *)a2 + 23) >= 0) {
      uint64_t v5 = a2;
    }
    else {
      uint64_t v5 = (uint64_t *)*a2;
    }
    int v7 = 136446210;
    CFArrayRef v8 = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Monitoring Failed: %{public}s", (uint8_t *)&v7, 0xCu);
  }
  return sub_100576D1C(a1);
}

void sub_1005770FC(uint64_t a1, void **a2, unsigned int a3)
{
  BOOL v6 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    if (*((char *)a2 + 23) >= 0) {
      int v7 = a2;
    }
    else {
      int v7 = *a2;
    }
    if (a3 > 3) {
      CFArrayRef v8 = "???";
    }
    else {
      CFArrayRef v8 = off_1019E4A28[a3];
    }
    *(_DWORD *)std::string buf = 136446466;
    CFNumberRef v12 = v7;
    __int16 v13 = 2080;
    CFNumberRef v14 = v8;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I State determined: %{public}s : %s", buf, 0x16u);
  }
  if (*((char *)a2 + 23) < 0)
  {
    sub_10004FC84(__p, *a2, (unint64_t)a2[1]);
  }
  else
  {
    *(_OWORD *)OsLogContext __p = *(_OWORD *)a2;
    uint32_t v10 = a2[2];
  }
  sub_100DC1B38(*(void *)(a1 + 112), __p, a3);
  if (SHIBYTE(v10) < 0) {
    operator delete(__p[0]);
  }
}

void sub_10057722C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
}

void sub_100577250(uint64_t a1, void **a2)
{
  uint64_t v4 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    if (*((char *)a2 + 23) >= 0) {
      uint64_t v5 = a2;
    }
    else {
      uint64_t v5 = *a2;
    }
    *(_DWORD *)std::string buf = 136446210;
    uint64_t v9 = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Geofence entered: %{public}s", buf, 0xCu);
  }
  if (*((char *)a2 + 23) < 0)
  {
    sub_10004FC84(__p, *a2, (unint64_t)a2[1]);
  }
  else
  {
    *(_OWORD *)OsLogContext __p = *(_OWORD *)a2;
    int v7 = a2[2];
  }
  sub_100DC1B38(*(void *)(a1 + 112), __p, 2);
  if (SHIBYTE(v7) < 0) {
    operator delete(__p[0]);
  }
}

void sub_100577350(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
}

void sub_100577374(uint64_t a1, void **a2)
{
  uint64_t v4 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    if (*((char *)a2 + 23) >= 0) {
      uint64_t v5 = a2;
    }
    else {
      uint64_t v5 = *a2;
    }
    *(_DWORD *)std::string buf = 136446210;
    uint64_t v9 = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Geofence exited: %{public}s", buf, 0xCu);
  }
  if (*((char *)a2 + 23) < 0)
  {
    sub_10004FC84(__p, *a2, (unint64_t)a2[1]);
  }
  else
  {
    *(_OWORD *)OsLogContext __p = *(_OWORD *)a2;
    int v7 = a2[2];
  }
  sub_100DC1B38(*(void *)(a1 + 112), __p, 3);
  if (SHIBYTE(v7) < 0) {
    operator delete(__p[0]);
  }
}

void sub_100577474(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
}

uint64_t sub_100577498@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(result + 88);
  *a2 = *(void *)(result + 80);
  a2[1] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

const void **sub_1005774B4(void *a1, uint64_t a2, uint64_t **a3, const void **a4)
{
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  CFArrayRef v8 = (uint64_t *)*((unsigned __int8 *)a3 + 23);
  int v9 = (char)v8;
  if ((char)v8 < 0) {
    CFArrayRef v8 = a3[1];
  }
  switch((unint64_t)v8)
  {
    case 0x10uLL:
      uint32_t v10 = *a3;
      if (v9 >= 0) {
        uint32_t v10 = (uint64_t *)a3;
      }
      uint64_t v12 = *v10;
      uint64_t v11 = v10[1];
      if (v12 != 0x696765722D746573 || v11 != 0x65746174732D6E6FLL) {
        goto LABEL_71;
      }
      __p[0] = 0;
      __p[1] = 0;
      uint64_t v78 = 0;
      CFDictionaryRef v14 = (const __CFDictionary *)*a4;
      ctu::cf::MakeCFString::MakeCFString((ctu::cf::MakeCFString *)key, "region");
      CFDictionaryGetValue(v14, key[0]);
      memset(buf, 0, sizeof(buf));
      *(void *)&long long v84 = 0;
      ctu::cf::assign();
      *(_OWORD *)OsLogContext __p = *(_OWORD *)buf;
      uint64_t v78 = v84;
      ctu::cf::MakeCFString::~MakeCFString((ctu::cf::MakeCFString *)key);
      key[0] = 0;
      key[1] = 0;
      uint64_t v76 = 0;
      CFDictionaryRef v15 = (const __CFDictionary *)*a4;
      ctu::cf::MakeCFString::MakeCFString((ctu::cf::MakeCFString *)value, "state");
      CFDictionaryGetValue(v15, *(const void **)value);
      memset(buf, 0, sizeof(buf));
      *(void *)&long long v84 = 0;
      ctu::cf::assign();
      *(_OWORD *)long long key = *(_OWORD *)buf;
      uint64_t v76 = v84;
      ctu::cf::MakeCFString::~MakeCFString((ctu::cf::MakeCFString *)value);
      CFTypeID v16 = (void *)HIBYTE(v78);
      if (v78 < 0) {
        CFTypeID v16 = __p[1];
      }
      if (!v16)
      {
        size_t v59 = Mutable;
        ctu::cf::MakeCFString::MakeCFString((ctu::cf::MakeCFString *)buf, "error");
        uint64_t v60 = *(const void **)buf;
        ctu::cf::MakeCFString::MakeCFString((ctu::cf::MakeCFString *)value, "Unknown region");
        CFDictionarySetValue(v59, v60, *(const void **)value);
        goto LABEL_86;
      }
      uint64_t v17 = (void *)HIBYTE(v76);
      if (v76 < 0) {
        uint64_t v17 = key[1];
      }
      if (v17 == (void *)1)
      {
        CFTypeRef v61 = key;
        if (v76 < 0) {
          CFTypeRef v61 = (void **)key[0];
        }
        int v62 = *(unsigned __int8 *)v61;
        if (v62 == 73)
        {
          unsigned int v63 = 2;
          goto LABEL_103;
        }
        if (v62 == 79)
        {
          unsigned int v63 = 3;
          goto LABEL_103;
        }
      }
      else if (!v17)
      {
        uint64_t v18 = Mutable;
        ctu::cf::MakeCFString::MakeCFString((ctu::cf::MakeCFString *)buf, "error");
        uint64_t v19 = *(const void **)buf;
        ctu::cf::MakeCFString::MakeCFString((ctu::cf::MakeCFString *)value, "Invalid State string");
        CFDictionarySetValue(v18, v19, *(const void **)value);
LABEL_86:
        ctu::cf::MakeCFString::~MakeCFString((ctu::cf::MakeCFString *)value);
        ctu::cf::MakeCFString::~MakeCFString((ctu::cf::MakeCFString *)buf);
        sub_10004EFE4(a1, (CFTypeRef *)&Mutable);
        if (SHIBYTE(v76) < 0) {
          operator delete(key[0]);
        }
        if (SHIBYTE(v78) < 0) {
          operator delete(__p[0]);
        }
        return sub_10005717C((const void **)&Mutable);
      }
      if (!sub_1002E6B08((const void **)key, "U"))
      {
        memset(buf, 0, sizeof(buf));
        *(void *)&long long v84 = 0;
        std::operator+<char>();
        int v64 = Mutable;
        ctu::cf::MakeCFString::MakeCFString((ctu::cf::MakeCFString *)value, "error");
        uint64_t v65 = *(const void **)value;
        if ((SBYTE7(v84) & 0x80u) == 0) {
          uint64_t v66 = buf;
        }
        else {
          uint64_t v66 = *(uint8_t **)buf;
        }
        ctu::cf::MakeCFString::MakeCFString((ctu::cf::MakeCFString *)&v74, (const char *)v66);
        CFDictionarySetValue(v64, v65, v74);
        ctu::cf::MakeCFString::~MakeCFString((ctu::cf::MakeCFString *)&v74);
        ctu::cf::MakeCFString::~MakeCFString((ctu::cf::MakeCFString *)value);
        if (SBYTE7(v84) < 0) {
          operator delete(*(void **)buf);
        }
        goto LABEL_104;
      }
      unsigned int v63 = 1;
LABEL_103:
      sub_1005770FC(a2, __p, v63);
LABEL_104:
      uint64_t v100 = 0;
      long long v98 = 0u;
      long long v99 = 0u;
      long long v96 = 0u;
      long long v97 = 0u;
      long long v94 = 0u;
      long long v95 = 0u;
      long long v92 = 0u;
      long long v93 = 0u;
      long long v90 = 0u;
      long long v91 = 0u;
      *(_OWORD *)uint64_t v88 = 0u;
      long long v89 = 0u;
      long long v86 = 0u;
      long long v87 = 0u;
      long long v84 = 0u;
      long long v85 = 0u;
      *(_OWORD *)std::string buf = 0u;
      sub_10004BD84((uint64_t)buf);
      uint64_t v67 = *(NSObject **)(a2 + 40);
      if (os_log_type_enabled(v67, OS_LOG_TYPE_DEFAULT))
      {
        if (*((char *)a3 + 23) >= 0) {
          uint64_t v68 = (uint64_t *)a3;
        }
        else {
          uint64_t v68 = *a3;
        }
        size_t v69 = __p;
        if (v78 < 0) {
          size_t v69 = (void **)__p[0];
        }
        *(_DWORD *)CFPropertyListRef value = 136446466;
        *(void *)&value[4] = v68;
        __int16 v81 = 2082;
        int v82 = v69;
        _os_log_impl((void *)&_mh_execute_header, v67, OS_LOG_TYPE_DEFAULT, "#I State set for shape %{public}s: %{public}s ", value, 0x16u);
      }
      int v70 = Mutable;
      ctu::cf::MakeCFString::MakeCFString((ctu::cf::MakeCFString *)value, "response");
      uint64_t v71 = *(const void **)value;
      ctu::cf::MakeCFString::MakeCFString((ctu::cf::MakeCFString *)&v74, "Region set");
      CFDictionarySetValue(v70, v71, v74);
      ctu::cf::MakeCFString::~MakeCFString((ctu::cf::MakeCFString *)&v74);
      ctu::cf::MakeCFString::~MakeCFString((ctu::cf::MakeCFString *)value);
      *(void *)&long long v84 = v72;
      if (SHIBYTE(v89) < 0) {
        operator delete(v88[1]);
      }
      std::streambuf::~streambuf();
      std::iostream::~basic_iostream();
      std::ios::~ios();
      if (SHIBYTE(v76) < 0) {
        operator delete(key[0]);
      }
      if (SHIBYTE(v78) < 0) {
        operator delete(__p[0]);
      }
      goto LABEL_83;
    case 0x15uLL:
      uint64_t v20 = *a3;
      if (v9 >= 0) {
        uint64_t v20 = (uint64_t *)a3;
      }
      uint64_t v21 = *v20;
      uint64_t v22 = v20[1];
      uint64_t v23 = *(uint64_t *)((char *)v20 + 13);
      if (v21 != 0x696E6F6D2D746567 || v22 != 0x65722D6465726F74 || v23 != 0x736E6F696765722DLL) {
        goto LABEL_71;
      }
      uint64_t v100 = 0;
      long long v98 = 0u;
      long long v99 = 0u;
      long long v96 = 0u;
      long long v97 = 0u;
      long long v94 = 0u;
      long long v95 = 0u;
      long long v92 = 0u;
      long long v93 = 0u;
      long long v90 = 0u;
      long long v91 = 0u;
      *(_OWORD *)uint64_t v88 = 0u;
      long long v89 = 0u;
      long long v86 = 0u;
      long long v87 = 0u;
      long long v84 = 0u;
      long long v85 = 0u;
      *(_OWORD *)std::string buf = 0u;
      sub_10004BD84((uint64_t)buf);
      unsigned int v26 = Mutable;
      ctu::cf::MakeCFString::MakeCFString((ctu::cf::MakeCFString *)key, "response");
      unsigned int v27 = key[0];
      sub_100DC2180(*(void *)(a2 + 112), __p);
      if (v78 >= 0) {
        long long v28 = __p;
      }
      else {
        long long v28 = (void **)__p[0];
      }
      ctu::cf::MakeCFString::MakeCFString((ctu::cf::MakeCFString *)value, (const char *)v28);
      CFDictionarySetValue(v26, v27, *(const void **)value);
      ctu::cf::MakeCFString::~MakeCFString((ctu::cf::MakeCFString *)value);
      if (SHIBYTE(v78) < 0) {
        operator delete(__p[0]);
      }
      ctu::cf::MakeCFString::~MakeCFString((ctu::cf::MakeCFString *)key);
      *(void *)&long long v84 = v29;
      if (SHIBYTE(v89) < 0) {
        operator delete(v88[1]);
      }
      std::streambuf::~streambuf();
      std::iostream::~basic_iostream();
      std::ios::~ios();
      goto LABEL_83;
    case 0x16uLL:
      uint64_t v30 = *a3;
      if (v9 >= 0) {
        uint64_t v30 = (uint64_t *)a3;
      }
      if (*v30 == 0x666F65672D746573
        && v30[1] == 0x732D676E69636E65
        && *(uint64_t *)((char *)v30 + 14) == 0x7372616C6163732DLL)
      {
        uint64_t v51 = *(NSObject **)(a2 + 40);
        if (os_log_type_enabled(v51, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)std::string buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v51, OS_LOG_TYPE_DEFAULT, "#I Custom geofencing scalars stored", buf, 2u);
        }
        sub_100058140((const void **)(a2 + 128), a4);
        char v52 = Mutable;
        ctu::cf::MakeCFString::MakeCFString((ctu::cf::MakeCFString *)buf, "response");
        uint64_t v53 = *(const void **)buf;
        ctu::cf::MakeCFString::MakeCFString((ctu::cf::MakeCFString *)__p, "Custom geofencing scalars stored...");
        CFDictionarySetValue(v52, v53, __p[0]);
LABEL_81:
        ctu::cf::MakeCFString::~MakeCFString((ctu::cf::MakeCFString *)__p);
        uint64_t v42 = (ctu::cf::MakeCFString *)buf;
        goto LABEL_82;
      }
      uint64_t v33 = *v30;
      uint64_t v34 = v30[1];
      uint64_t v35 = *(uint64_t *)((char *)v30 + 14);
      if (v33 == 0x666F65672D746567 && v34 == 0x732D676E69636E65 && v35 == 0x7372616C6163732DLL)
      {
        uint64_t v38 = *(NSObject **)(a2 + 40);
        if (os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)std::string buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_DEFAULT, "#I Reading custom geofencing scalars", buf, 2u);
        }
        memset(buf, 0, sizeof(buf));
        *(void *)&long long v84 = 0;
        sub_100058198(&v73, (const void **)(a2 + 128));
        sub_10122FD6C((double *)buf, &v73);
        sub_100057D78(&v73);
        uint64_t v39 = Mutable;
        ctu::cf::MakeCFString::MakeCFString((ctu::cf::MakeCFString *)key, "response");
        long long v40 = key[0];
        sub_10122FFD0(__p);
        if (v78 >= 0) {
          uint64_t v41 = __p;
        }
        else {
          uint64_t v41 = (void **)__p[0];
        }
        ctu::cf::MakeCFString::MakeCFString((ctu::cf::MakeCFString *)value, (const char *)v41);
        CFDictionarySetValue(v39, v40, *(const void **)value);
        ctu::cf::MakeCFString::~MakeCFString((ctu::cf::MakeCFString *)value);
        if (SHIBYTE(v78) < 0) {
          operator delete(__p[0]);
        }
        uint64_t v42 = (ctu::cf::MakeCFString *)key;
LABEL_82:
        ctu::cf::MakeCFString::~MakeCFString(v42);
        goto LABEL_83;
      }
LABEL_71:
      uint64_t v49 = *(NSObject **)(a2 + 40);
      if (os_log_type_enabled(v49, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v50 = *a3;
        if (v9 >= 0) {
          uint64_t v50 = (uint64_t *)a3;
        }
        *(_DWORD *)std::string buf = 136446210;
        *(void *)&uint8_t buf[4] = v50;
        _os_log_impl((void *)&_mh_execute_header, v49, OS_LOG_TYPE_DEFAULT, "#I Unhandled command: %{public}s", buf, 0xCu);
      }
LABEL_83:
      sub_10004EFE4(a1, (CFTypeRef *)&Mutable);
      return sub_10005717C((const void **)&Mutable);
    case 0x18uLL:
      uint64_t v43 = *a3;
      if (v9 >= 0) {
        uint64_t v43 = (uint64_t *)a3;
      }
      uint64_t v44 = *v43;
      uint64_t v45 = v43[1];
      uint64_t v46 = v43[2];
      if (v44 != 0x65672D7465736572 || v45 != 0x676E69636E65666FLL || v46 != 0x7372616C6163732DLL) {
        goto LABEL_71;
      }
      uint64_t v54 = *(NSObject **)(a2 + 40);
      if (os_log_type_enabled(v54, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v54, OS_LOG_TYPE_DEFAULT, "#I Reset geofencing scalars", buf, 2u);
      }
      uint64_t v55 = *(void *)(a2 + 128);
      *(void *)(a2 + 128) = 0;
      *(void *)std::string buf = v55;
      sub_100057D78((const void **)buf);
      unint64_t v56 = Mutable;
      ctu::cf::MakeCFString::MakeCFString((ctu::cf::MakeCFString *)buf, "response");
      __int16 v57 = *(const void **)buf;
      ctu::cf::MakeCFString::MakeCFString((ctu::cf::MakeCFString *)__p, "Scalars reset");
      CFDictionarySetValue(v56, v57, __p[0]);
      goto LABEL_81;
    default:
      goto LABEL_71;
  }
}

void sub_100577F8C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,const void *a24,__int16 a25,char a26,char a27,uint64_t a28,uint64_t a29,uint64_t a30,void *__p,uint64_t a32,int a33,__int16 a34,char a35,char a36)
{
  if (a36 < 0) {
    operator delete(__p);
  }
  if (a16 < 0) {
    operator delete(a11);
  }
  if (a23 < 0) {
    operator delete(a18);
  }
  sub_10005717C(&a24);
  _Unwind_Resume(a1);
}

const void **sub_10057819C@<X0>(uint64_t a1@<X0>, long long *a2@<X1>, const void **a3@<X2>, void *a4@<X8>)
{
  uint64_t v9 = a1;
  sub_100058198((const void **)&v10, a3);
  if (*((char *)a2 + 23) < 0)
  {
    sub_10004FC84(&__p, *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long __p = *a2;
    uint64_t v12 = *((void *)a2 + 2);
  }
  if (*(void *)(a1 + 32) && dispatch_workloop_is_current())
  {
    blocunint64_t k = v10;
    if (v10) {
      CFRetain(v10);
    }
    sub_1005774B4(a4, v9, (uint64_t **)&__p, (const void **)&block);
    sub_100057D78((const void **)&block);
  }
  else
  {
    v13[0] = _NSConcreteStackBlock;
    v13[1] = 3221225472;
    void v13[2] = sub_10057A1B0;
    v13[3] = &unk_1019E4988;
    _OWORD v13[4] = a1 + 8;
    v13[5] = &v9;
    CFDictionaryRef v14 = objc_retainBlock(v13);
    int v7 = *(NSObject **)(a1 + 24);
    if (*(void *)(a1 + 32))
    {
      *a4 = 0;
      blocunint64_t k = _NSConcreteStackBlock;
      uint64_t v16 = 3221225472;
      uint64_t v17 = sub_100579DD4;
      uint64_t v18 = &unk_10199E470;
      uint64_t v19 = a4;
      uint64_t v20 = &v14;
      dispatch_async_and_wait(v7, &block);
    }
    else
    {
      *a4 = 0;
      blocunint64_t k = _NSConcreteStackBlock;
      uint64_t v16 = 3221225472;
      uint64_t v17 = sub_100579D5C;
      uint64_t v18 = &unk_10199E470;
      uint64_t v19 = a4;
      uint64_t v20 = &v14;
      dispatch_sync(v7, &block);
    }
  }
  if (SHIBYTE(v12) < 0) {
    operator delete((void *)__p);
  }
  return sub_100057D78((const void **)&v10);
}

void sub_100578394(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va, a13);
  sub_100057D78((const void **)va);
  sub_10006A6AC(a1);
}

void sub_1005783A8(_Unwind_Exception *a1)
{
  sub_100057D78(v1);
  _Unwind_Resume(a1);
}

void sub_1005783C0(uint64_t a1)
{
  sub_100578678(a1);

  operator delete();
}

uint64_t sub_1005783F8(uint64_t *a1, void *a2)
{
  uint64_t result = sub_100578488((uint64_t)(a1 + 2), a1[1], (void *)a1[1], *a1, (void *)*a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

void sub_100578470()
{
}

uint64_t sub_100578488(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, void *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&long long v13 = a6;
  *((void *)&v13 + 1) = a7;
  long long v12 = v13;
  v11[0] = a1;
  v11[1] = &v12;
  void v11[2] = &v13;
  v11[3] = 1;
  if (a3 == a5)
  {
    uint64_t v9 = a6;
  }
  else
  {
    do
    {
      *(void *)(v7 - 24) = 0;
      *(void *)(v7 - 16) = 0;
      *(void *)(v7 - 8) = 0;
      long long v8 = *(_OWORD *)(a3 - 3);
      a3 -= 3;
      *(_OWORD *)(v7 - 24) = v8;
      *(void *)(v7 - 8) = a3[2];
      *a3 = 0;
      a3[1] = 0;
      a3[2] = 0;
      uint64_t v7 = *((void *)&v13 + 1) - 24;
      *((void *)&v13 + 1) -= 24;
    }
    while (a3 != a5);
    uint64_t v9 = v13;
  }
  sub_100578528((uint64_t)v11);
  return v9;
}

uint64_t sub_100578528(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    sub_1002057F0(a1);
  }
  return a1;
}

uint64_t sub_100578560(uint64_t *a1, uint64_t a2)
{
  uint64_t v3 = *a1;
  unint64_t v4 = 0xAAAAAAAAAAAAAAABLL * ((a1[1] - *a1) >> 3);
  unint64_t v5 = v4 + 1;
  if (v4 + 1 > 0xAAAAAAAAAAAAAAALL) {
    sub_100578470();
  }
  uint64_t v7 = (uint64_t)(a1 + 2);
  unint64_t v8 = 0xAAAAAAAAAAAAAAABLL * ((a1[2] - v3) >> 3);
  if (2 * v8 > v5) {
    unint64_t v5 = 2 * v8;
  }
  if (v8 >= 0x555555555555555) {
    unint64_t v9 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v9 = v5;
  }
  uint64_t v17 = a1 + 2;
  if (v9) {
    uint32_t v10 = (char *)sub_10004812C(v7, v9);
  }
  else {
    uint32_t v10 = 0;
  }
  uint64_t v11 = &v10[24 * v4];
  v14[0] = v10;
  v14[1] = v11;
  CFDictionaryRef v15 = v11;
  uint64_t v16 = &v10[24 * v9];
  *(void *)uint64_t v11 = 0;
  *((void *)v11 + 1) = 0;
  *((void *)v11 + 2) = 0;
  sub_1004081A4(v11, *(const void **)a2, *(void *)(a2 + 8), (uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 4);
  v15 += 24;
  sub_1005783F8(a1, v14);
  uint64_t v12 = a1[1];
  sub_100205838((uint64_t)v14);
  return v12;
}

void sub_100578664(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100205838((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100578678(uint64_t a1)
{
  *(void *)a1 = off_1019E46F0;
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 144);
  if (v2) {
    sub_10004D2C8(v2);
  }
  sub_100057D78((const void **)(a1 + 128));
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 120);
  if (v3) {
    sub_10004D2C8(v3);
  }
  uint64_t v4 = *(void *)(a1 + 104);
  *(void *)(a1 + 104) = 0;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
  }
  unint64_t v5 = *(std::__shared_weak_count **)(a1 + 88);
  if (v5) {
    sub_10004D2C8(v5);
  }
  uint64_t v6 = *(std::__shared_weak_count **)(a1 + 72);
  if (v6) {
    sub_10004D2C8(v6);
  }
  uint64_t v7 = *(std::__shared_weak_count **)(a1 + 56);
  if (v7) {
    sub_10004D2C8(v7);
  }
  SafetyAlertGeofenceManagerInterface::~SafetyAlertGeofenceManagerInterface((SafetyAlertGeofenceManagerInterface *)a1);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 40));
  sub_100087E88((void *)(a1 + 8));
  return a1;
}

void sub_100578748(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1019E4878;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100578768(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1019E4878;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_1005787BC(uint64_t *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[8];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  if (a1[4])
  {
    sub_10019E028(a1 + 4);
    operator delete((void *)a1[4]);
  }

  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 3));
}

void sub_10057881C(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1019E48C8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_10057883C(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1019E48C8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100578890(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 24) + 136))();
}

void sub_1005788B8(ServiceManager::Service *this)
{
  *(void *)this = off_1019E4918;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }

  ServiceManager::Service::~Service(this);
}

void sub_100578914(ServiceManager::Service *this)
{
  *(void *)this = off_1019E4918;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  ServiceManager::Service::~Service(this);

  operator delete();
}

void *sub_100578984@<X0>(void *a1@<X8>)
{
  return sub_100058DB0(a1, "SafetyAlertGeofenceManager");
}

unsigned char *sub_100578994@<X0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  uint64_t v2 = operator new(1uLL);
  *a1 = v2;
  unsigned char *v2 = 0;
  uint64_t result = v2 + 1;
  a1[1] = result;
  a1[2] = result;
  return result;
}

void sub_1005789D0(uint64_t a1, dispatch_object_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v3 = *a2;
  if (*a2)
  {
    dispatch_retain(*a2);
    dispatch_group_enter(v3);
    sub_100574F84(v2, v3);
  }
  uint64_t v4 = *(void *)(a1 + 8);

  sub_100574F84(v4, 0);
}

uint64_t sub_100578A54()
{
  return 0;
}

uint64_t sub_100578A5C()
{
  return 1;
}

uint64_t sub_100578A64()
{
  return 0;
}

void sub_100578A70(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(*(void *)(a1 + 8) + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100578B50(uint64_t a1, int a2, ServiceStage *this)
{
  uint64_t v3 = *(void *)(a1 + 8);
  ServiceStage::holdOffStage((uint64_t *)&group[1], this);
  uint64_t v4 = *(std::__shared_weak_count **)(v3 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

uint64_t *sub_100578C64(uint64_t *a1)
{
  uint64_t v1 = *a1;
  unint64_t v5 = a1;
  uint64_t v6 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v3 = *(NSObject **)(*(void *)v1 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(buf) = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Bootstrapping...", (uint8_t *)&buf, 2u);
  }
  Registry::createRestModuleOneTimeUseConnection(&buf, *(Registry **)(v2 + 48));
  ctu::RestModule::connect();
  if (v8) {
    sub_10004D2C8(v8);
  }
  sub_10054E158(v2 + 96);
  sub_100088C88(&v6);
  return sub_100046B58((uint64_t *)&v5);
}

void sub_100578D14(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    sub_10004D2C8(a12);
  }
  sub_100088C88(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

void sub_100578D44(uint64_t **a1)
{
  uint64_t v3 = a1;
  uint64_t v1 = **a1;
  uint64_t v2 = *(NSObject **)(v1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Service starting...", buf, 2u);
  }
  (***(void (****)(void))(v1 + 80))(*(void *)(v1 + 80));
  (*(void (**)(void))(**(void **)(v1 + 80) + 128))(*(void *)(v1 + 80));
  operator delete();
}

void sub_100578E28()
{
}

uint64_t *sub_100578E54(uint64_t *a1)
{
  uint64_t v1 = *a1;
  unint64_t v5 = a1;
  uint64_t v6 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v3 = *(NSObject **)(*(void *)v1 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Shutdown...", buf, 2u);
  }
  ctu::RestModule::disconnect((ctu::RestModule *)(v2 + 64));
  (*(void (**)(void))(**(void **)(v2 + 80) + 8))(*(void *)(v2 + 80));
  sub_100088C88(&v6);
  return sub_100046B58((uint64_t *)&v5);
}

void sub_100578F00(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

BOOL sub_100578F1C(uint64_t a1)
{
  return sub_10057524C(**(void **)(a1 + 40));
}

uint64_t sub_100578F28(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 40) + 16))();
  **(unsigned char **)(a1 + 32) = result;
  return result;
}

uint64_t sub_100578F64(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 40) + 16))();
  **(unsigned char **)(a1 + 32) = result;
  return result;
}

uint64_t sub_100578FA0(uint64_t a1)
{
  uint64_t v1 = *(uint64_t **)(a1 + 40);
  uint64_t v2 = *v1;
  uint64_t v3 = (uint64_t *)v1[1];
  uint64_t v4 = (std::__shared_weak_count *)v3[1];
  v7[0] = *v3;
  v7[1] = (uint64_t)v4;
  if (v4) {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v5 = sub_1005758F0(v2, v7);
  if (v4) {
    sub_10004D2C8(v4);
  }
  return v5;
}

void sub_100579000(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t *sub_100579018(uint64_t *a1)
{
  uint64_t v1 = *a1;
  CFTypeRef v61 = a1;
  uint64_t v62 = v1;
  uint64_t v2 = *(void *)v1;
  sub_100058198(&cf, (const void **)(v1 + 8));
  uint64_t v3 = *(unsigned __int8 *)(v1 + 39);
  if ((v3 & 0x80u) != 0) {
    uint64_t v3 = *(void *)(v1 + 24);
  }
  if (!v3)
  {
    uint64_t v4 = *(unsigned __int8 *)(v1 + 63);
    if ((v4 & 0x80u) != 0) {
      uint64_t v4 = *(void *)(v1 + 48);
    }
    if (!v4)
    {
      uint64_t v20 = *(NSObject **)(v2 + 40);
      if (!os_log_type_enabled(v20, OS_LOG_TYPE_ERROR)) {
        goto LABEL_90;
      }
      LOWORD(buf.__r_.__value_.__l.__data_) = 0;
      uint64_t v21 = "Early geofencing skipped: [Empty alert text recieved]";
      goto LABEL_31;
    }
  }
  if (cf) {
    uint64_t v5 = sub_100080778;
  }
  else {
    uint64_t v5 = 0;
  }
  if (!v5)
  {
    uint64_t v20 = *(NSObject **)(v2 + 40);
    if (!os_log_type_enabled(v20, OS_LOG_TYPE_ERROR)) {
      goto LABEL_90;
    }
    LOWORD(buf.__r_.__value_.__l.__data_) = 0;
    uint64_t v21 = "Early geofencing skipped: [Invalid area in Apple Safety alert]";
LABEL_31:
    _os_log_error_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, v21, (uint8_t *)&buf, 2u);
    goto LABEL_90;
  }
  if (sub_10057524C(v2))
  {
    int v70 = 0;
    uint64_t v71 = 0;
    (*(void (**)(double **__return_ptr))(**(void **)(v2 + 80) + 144))(&v70);
    if (!v70)
    {
      unint64_t v25 = *(NSObject **)(v2 + 40);
      if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(buf.__r_.__value_.__l.__data_) = 0;
        _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "#I Early geofencing skipped: [Current location unknown]", (uint8_t *)&buf, 2u);
      }
      goto LABEL_88;
    }
    memset(&v69, 0, sizeof(v69));
    CFDictionaryRef v6 = (const __CFDictionary *)cf;
    CFDictionaryRef theDict = (CFDictionaryRef)cf;
    if (cf)
    {
      CFRetain(cf);
      CFDictionaryRef v6 = theDict;
    }
    CFDictionaryRef Value = CFDictionaryGetValue(v6, @"type");
    unint64_t v8 = Value;
    if (Value && (CFTypeID v9 = CFGetTypeID(Value), v9 == CFStringGetTypeID()))
    {
      CFArrayRef v10 = (const __CFArray *)CFDictionaryGetValue(theDict, @"coordinates");
      CFArrayRef v11 = v10;
      if (v10 && (CFTypeID v12 = CFGetTypeID(v10), v12 == CFArrayGetTypeID()))
      {
        CFIndex Count = CFArrayGetCount(v11);
        if (Count)
        {
          memset(&buf, 0, sizeof(buf));
          if (CFEqual(v8, @"Polygon"))
          {
            CFArrayRef ValueAtIndex = (const __CFArray *)CFArrayGetValueAtIndex(v11, 0);
            CFArrayRef v15 = ValueAtIndex;
            if (ValueAtIndex)
            {
              CFTypeID v16 = CFGetTypeID(ValueAtIndex);
              if (v16 == CFArrayGetTypeID())
              {
                memset(&v77, 0, sizeof(v77));
                sub_100576410(&v77, v2, v15);
                std::string::size_type size = (void *)buf.__r_.__value_.__l.__size_;
                if (buf.__r_.__value_.__l.__size_ >= buf.__r_.__value_.__r.__words[2])
                {
                  std::string::size_type v19 = sub_100578560((uint64_t *)&buf, (uint64_t)&v77);
                  uint64_t v18 = (void *)v77.__r_.__value_.__r.__words[0];
                }
                else
                {
                  *(void *)buf.__r_.__value_.__l.__size_ = 0;
                  size[1] = 0;
                  size[2] = 0;
                  uint64_t v18 = (void *)v77.__r_.__value_.__r.__words[0];
                  sub_1004081A4(size, v77.__r_.__value_.__l.__data_, v77.__r_.__value_.__l.__size_, (uint64_t)(v77.__r_.__value_.__l.__size_ - v77.__r_.__value_.__r.__words[0]) >> 4);
                  std::string::size_type v19 = (std::string::size_type)(size + 3);
                }
                buf.__r_.__value_.__l.__size_ = v19;
                if (v18)
                {
                  v77.__r_.__value_.__l.__size_ = (std::string::size_type)v18;
                  operator delete(v18);
                }
                goto LABEL_112;
              }
            }
            char v52 = *(NSObject **)(v2 + 40);
            if (!os_log_type_enabled(v52, OS_LOG_TYPE_ERROR)) {
              goto LABEL_117;
            }
            LOWORD(v77.__r_.__value_.__l.__data_) = 0;
            uint64_t v53 = "Invalid polygon array for multi-polygon";
          }
          else
          {
            if (CFEqual(v8, @"MultiPolygon"))
            {
              if (Count >= 1)
              {
                CFIndex v54 = 0;
                while (1)
                {
                  CFArrayRef v55 = (const __CFArray *)CFArrayGetValueAtIndex(v11, v54);
                  CFArrayRef v56 = v55;
                  if (!v55) {
                    break;
                  }
                  CFTypeID v57 = CFGetTypeID(v55);
                  if (v57 != CFArrayGetTypeID()) {
                    break;
                  }
                  memset(&v77, 0, sizeof(v77));
                  sub_100576410(&v77, v2, v56);
                  int v58 = (void *)buf.__r_.__value_.__l.__size_;
                  if (buf.__r_.__value_.__l.__size_ >= buf.__r_.__value_.__r.__words[2])
                  {
                    std::string::size_type v59 = sub_100578560((uint64_t *)&buf, (uint64_t)&v77);
                  }
                  else
                  {
                    *(void *)buf.__r_.__value_.__l.__size_ = 0;
                    v58[1] = 0;
                    v58[2] = 0;
                    sub_1004081A4(v58, v77.__r_.__value_.__l.__data_, v77.__r_.__value_.__l.__size_, (uint64_t)(v77.__r_.__value_.__l.__size_ - v77.__r_.__value_.__r.__words[0]) >> 4);
                    std::string::size_type v59 = (std::string::size_type)(v58 + 3);
                  }
                  buf.__r_.__value_.__l.__size_ = v59;
                  if (v77.__r_.__value_.__r.__words[0])
                  {
                    v77.__r_.__value_.__l.__size_ = v77.__r_.__value_.__r.__words[0];
                    operator delete(v77.__r_.__value_.__l.__data_);
                  }
                  if (Count == ++v54) {
                    goto LABEL_112;
                  }
                }
                char v52 = *(NSObject **)(v2 + 40);
                if (!os_log_type_enabled(v52, OS_LOG_TYPE_ERROR)) {
                  goto LABEL_117;
                }
                LOWORD(v77.__r_.__value_.__l.__data_) = 0;
                uint64_t v53 = "Invalid polygon array for multi-polygon";
                goto LABEL_116;
              }
LABEL_112:
              if (buf.__r_.__value_.__l.__size_ != buf.__r_.__value_.__r.__words[0])
              {
                std::string v69 = buf;
                p_std::string buf = &buf;
LABEL_118:
                p_buf->__r_.__value_.__r.__words[0] = 0;
                p_buf->__r_.__value_.__l.__size_ = 0;
                p_buf->__r_.__value_.__r.__words[2] = 0;
                v77.__r_.__value_.__r.__words[0] = (std::string::size_type)&buf;
                sub_10011FF94((void ***)&v77);
                goto LABEL_41;
              }
              char v52 = *(NSObject **)(v2 + 40);
              if (os_log_type_enabled(v52, OS_LOG_TYPE_ERROR))
              {
                LOWORD(v77.__r_.__value_.__l.__data_) = 0;
                uint64_t v53 = "Invalid polygons received";
                goto LABEL_116;
              }
LABEL_117:
              p_std::string buf = &v69;
              goto LABEL_118;
            }
            char v52 = *(NSObject **)(v2 + 40);
            if (!os_log_type_enabled(v52, OS_LOG_TYPE_ERROR)) {
              goto LABEL_117;
            }
            LOWORD(v77.__r_.__value_.__l.__data_) = 0;
            uint64_t v53 = "Unhandled polygon type";
          }
LABEL_116:
          _os_log_error_impl((void *)&_mh_execute_header, v52, OS_LOG_TYPE_ERROR, v53, (uint8_t *)&v77, 2u);
          goto LABEL_117;
        }
        uint64_t v23 = *(NSObject **)(v2 + 40);
        if (!os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
        {
LABEL_40:
          memset(&v69, 0, sizeof(v69));
LABEL_41:
          sub_100057D78((const void **)&theDict);
          if (v69.__r_.__value_.__l.__size_ == v69.__r_.__value_.__r.__words[0])
          {
            uint64_t v49 = *(NSObject **)(v2 + 40);
            if (os_log_type_enabled(v49, OS_LOG_TYPE_ERROR))
            {
              LOWORD(buf.__r_.__value_.__l.__data_) = 0;
              _os_log_error_impl((void *)&_mh_execute_header, v49, OS_LOG_TYPE_ERROR, "Early geofencing skipped: [No shapes found]", (uint8_t *)&buf, 2u);
            }
          }
          else
          {
            *(_OWORD *)uint64_t v66 = 0u;
            long long v67 = 0u;
            memset(&buf, 0, sizeof(buf));
            double v26 = *v70;
            double v27 = v70[1];
            sub_100058198(&v65, (const void **)(v2 + 128));
            sub_101231760((uint64_t *)&v69, (double **)&buf, &v65, (uint64_t)v66, v26, v27);
            sub_100057D78(&v65);
            if (buf.__r_.__value_.__r.__words[0])
            {
              buf.__r_.__value_.__l.__size_ = buf.__r_.__value_.__r.__words[0];
              operator delete(buf.__r_.__value_.__l.__data_);
            }
            long long v28 = *(NSObject **)(v2 + 40);
            if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v30 = (char *)v66[1];
              xpc_object_t v29 = (double *)v67;
              if (LOBYTE(v66[0])) {
                long long v31 = "true";
              }
              else {
                long long v31 = "false";
              }
              memset(&v77, 0, sizeof(v77));
              if (v66[1] != (void *)v67)
              {
                std::to_string(&buf, *(double *)v66[1]);
                std::string v77 = buf;
                for (uint64_t i = (double *)(v30 + 8); i != v29; ++i)
                {
                  *((unsigned char *)&buf.__r_.__value_.__s + 23) = 2;
                  strcpy((char *)&buf, ", ");
                  std::string::append(&v77, (const std::string::value_type *)&buf, 2uLL);
                  if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
                    operator delete(buf.__r_.__value_.__l.__data_);
                  }
                  std::to_string(&buf, *i);
                  if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                    uint64_t v33 = &buf;
                  }
                  else {
                    uint64_t v33 = (std::string *)buf.__r_.__value_.__r.__words[0];
                  }
                  if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                    std::string::size_type v34 = HIBYTE(buf.__r_.__value_.__r.__words[2]);
                  }
                  else {
                    std::string::size_type v34 = buf.__r_.__value_.__l.__size_;
                  }
                  std::string::append(&v77, (const std::string::value_type *)v33, v34);
                  if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
                    operator delete(buf.__r_.__value_.__l.__data_);
                  }
                }
              }
              uint64_t v35 = &v77;
              if ((v77.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
                uint64_t v35 = (std::string *)v77.__r_.__value_.__r.__words[0];
              }
              *(_DWORD *)uint64_t v80 = 136315394;
              *(void *)&v80[4] = v31;
              *(_WORD *)&v80[12] = 2082;
              *(void *)&v80[14] = v35;
              _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "#I N-Test result: [%s], rad-list: [%{public}s]", v80, 0x16u);
              if (SHIBYTE(v77.__r_.__value_.__r.__words[2]) < 0) {
                operator delete(v77.__r_.__value_.__l.__data_);
              }
            }
            if (LOBYTE(v66[0]))
            {
              uint64_t v36 = *(void *)(v2 + 112);
              sub_100575FA0((const void **)&v64, v2);
              sub_100DC0760(v36, v1 + 16, v1 + 40, (uint64_t *)&v69, &v64);
              sub_100057D78((const void **)&v64);
              uint64_t v75 = 0;
              uint64_t v76 = 0;
              Registry::getTimerService(&v75, *(Registry **)(v2 + 48));
              if (v75)
              {
                uint64_t v37 = *(std::__shared_weak_count **)(v2 + 16);
                if (!v37 || (uint64_t v38 = std::__shared_weak_count::lock(v37)) == 0) {
                  sub_100088B9C();
                }
                uint64_t v39 = v38;
                atomic_fetch_add_explicit(&v38->__shared_weak_owners_, 1uLL, memory_order_relaxed);
                sub_10004D2C8(v38);
                memset(&v77, 0, sizeof(v77));
                long long v40 = *(std::__shared_weak_count **)(v2 + 16);
                if (!v40 || (uint64_t v41 = *(void *)(v2 + 8), (v42 = std::__shared_weak_count::lock(v40)) == 0)) {
                  sub_100088B9C();
                }
                uint64_t v43 = v42;
                atomic_fetch_add_explicit(&v42->__shared_weak_owners_, 1uLL, memory_order_relaxed);
                sub_10004D2C8(v42);
                uint64_t v44 = operator new(0x20uLL);
                *uint64_t v44 = off_1019E49B8;
                v44[1] = v2;
                void v44[2] = v41;
                _OWORD v44[3] = v43;
                uint64_t v78 = v44;
                uint64_t v45 = v75;
                sub_100058DB0(__p, "Geofence validity");
                *(_OWORD *)uint64_t v80 = *(_OWORD *)__p;
                *(void *)&v80[16] = v73;
                __p[0] = 0;
                __p[1] = 0;
                uint64_t v73 = 0;
                sub_1000DA470((uint64_t)&buf, (uint64_t)&v77);
                (*(void (**)(uint64_t *__return_ptr, uint64_t, unsigned char *, uint64_t, uint64_t, void, std::string *))(*(void *)v45 + 40))(&v74, v45, v80, 1, 300000000, 0, &buf);
                sub_10003B34C(&buf);
                if ((v80[23] & 0x80000000) != 0) {
                  operator delete(*(void **)v80);
                }
                uint64_t v46 = v74;
                uint64_t v74 = 0;
                uint64_t v47 = *(void *)(v2 + 104);
                *(void *)(v2 + 104) = v46;
                if (v47)
                {
                  (*(void (**)(uint64_t))(*(void *)v47 + 8))(v47);
                  uint64_t v48 = v74;
                  uint64_t v74 = 0;
                  if (v48) {
                    (*(void (**)(uint64_t))(*(void *)v48 + 8))(v48);
                  }
                }
                if (SHIBYTE(v73) < 0) {
                  operator delete(__p[0]);
                }
                sub_10003B34C(&v77);
                std::__shared_weak_count::__release_weak(v39);
              }
              else
              {
                uint64_t v50 = *(NSObject **)(v2 + 40);
                if (os_log_type_enabled(v50, OS_LOG_TYPE_ERROR))
                {
                  LOWORD(buf.__r_.__value_.__l.__data_) = 0;
                  _os_log_error_impl((void *)&_mh_execute_header, v50, OS_LOG_TYPE_ERROR, "Failed to get timer interface", (uint8_t *)&buf, 2u);
                }
              }
              if (v76) {
                sub_10004D2C8(v76);
              }
            }
            if (v66[1])
            {
              *(void **)&long long v67 = v66[1];
              operator delete(v66[1]);
            }
          }
          buf.__r_.__value_.__r.__words[0] = (std::string::size_type)&v69;
          sub_10011FF94((void ***)&buf);
LABEL_88:
          if (v71) {
            sub_10004D2C8(v71);
          }
          goto LABEL_90;
        }
        LOWORD(buf.__r_.__value_.__l.__data_) = 0;
        uint64_t v24 = "Empty coordinates";
      }
      else
      {
        uint64_t v23 = *(NSObject **)(v2 + 40);
        if (!os_log_type_enabled(v23, OS_LOG_TYPE_ERROR)) {
          goto LABEL_40;
        }
        LOWORD(buf.__r_.__value_.__l.__data_) = 0;
        uint64_t v24 = "Invalid coordinate type field";
      }
    }
    else
    {
      uint64_t v23 = *(NSObject **)(v2 + 40);
      if (!os_log_type_enabled(v23, OS_LOG_TYPE_ERROR)) {
        goto LABEL_40;
      }
      LOWORD(buf.__r_.__value_.__l.__data_) = 0;
      uint64_t v24 = "Invalid polygon/multi-polygon type field";
    }
    _os_log_error_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_ERROR, v24, (uint8_t *)&buf, 2u);
    goto LABEL_40;
  }
  uint64_t v22 = *(NSObject **)(v2 + 40);
  if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(buf.__r_.__value_.__l.__data_) = 0;
    _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "#I Early geofencing skipped: [Geofencing not allowed]", (uint8_t *)&buf, 2u);
  }
LABEL_90:
  sub_100057D78(&cf);
  sub_100579C1C(&v62);
  return sub_100046B58((uint64_t *)&v61);
}

void sub_100579A5C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, const void *a12, __int16 a13, char a14, char a15, int a16, __int16 a17, char a18, char a19, uint64_t a20,void *a21,uint64_t a22,uint64_t a23,const void *a24,__int16 a25,char a26,char a27,uint64_t a28,uint64_t a29,uint64_t a30,std::__shared_weak_count *a31,void *a32,uint64_t a33,int a34,__int16 a35,char a36,char a37,uint64_t a38,uint64_t a39,uint64_t a40,void *__p,uint64_t a42,int a43,__int16 a44,char a45,char a46)
{
  if (__p)
  {
    a42 = (uint64_t)__p;
    operator delete(__p);
  }
  long long __p = (void *)(v46 - 176);
  sub_10011FF94((void ***)&__p);
  sub_100057D78(&a24);
  if (a31) {
    sub_10004D2C8(a31);
  }
  sub_100057D78(&a12);
  sub_100579C1C(&a11);
  sub_100046B58(&a10);
  _Unwind_Resume(a1);
}

uint64_t *sub_100579C1C(uint64_t *result)
{
  uint64_t v1 = *result;
  *uint64_t result = 0;
  if (v1)
  {
    if (*(char *)(v1 + 63) < 0) {
      operator delete(*(void **)(v1 + 40));
    }
    if (*(char *)(v1 + 39) < 0) {
      operator delete(*(void **)(v1 + 16));
    }
    sub_100057D78((const void **)(v1 + 8));
    operator delete();
  }
  return result;
}

void sub_100579C8C(uint64_t a1)
{
  uint64_t v1 = *(uint64_t **)(a1 + 40);
  uint64_t v2 = *v1;
  uint64_t v3 = (uint64_t *)v1[1];
  uint64_t v4 = *v3;
  uint64_t v5 = (std::__shared_weak_count *)v3[1];
  if (v5) {
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  sub_100576760(v2, v4);
  if (v5)
  {
    sub_10004D2C8(v5);
  }
}

void sub_100579CEC(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

const void **sub_100579D04(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 40);
  uint64_t v2 = *(void *)v1;
  sub_100058198(&v4, (const void **)(v1 + 8));
  sub_100576948(v2, &v4);
  return sub_100057D78(&v4);
}

void sub_100579D4C(uint64_t a1@<X0>, const void **a2@<X8>)
{
}

const void **sub_100579D5C(uint64_t a1)
{
  (*(void (**)(const void **__return_ptr))(**(void **)(a1 + 40) + 16))(&v5);
  uint64_t v2 = *(const void ***)(a1 + 32);
  if (v2 != &v5)
  {
    uint64_t v3 = *v2;
    NSObject *v2 = 0;
    CFDictionaryRef v6 = v3;
    NSObject *v2 = v5;
    uint64_t v5 = 0;
    sub_100057D78(&v6);
  }
  return sub_100057D78(&v5);
}

const void **sub_100579DD4(uint64_t a1)
{
  (*(void (**)(const void **__return_ptr))(**(void **)(a1 + 40) + 16))(&v5);
  uint64_t v2 = *(const void ***)(a1 + 32);
  if (v2 != &v5)
  {
    uint64_t v3 = *v2;
    NSObject *v2 = 0;
    CFDictionaryRef v6 = v3;
    NSObject *v2 = v5;
    uint64_t v5 = 0;
    sub_100057D78(&v6);
  }
  return sub_100057D78(&v5);
}

void *sub_100579E4C(void *a1)
{
  *a1 = off_1019E49B8;
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_100579E98(void *a1)
{
  *a1 = off_1019E49B8;
  uint64_t v1 = (std::__shared_weak_count *)a1[3];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

char *sub_100579F04(uint64_t a1)
{
  uint64_t result = (char *)operator new(0x20uLL);
  *(void *)uint64_t result = off_1019E49B8;
  *(_OWORD *)(result + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 24);
  *((void *)result + 3) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_100579F68(uint64_t result, uint64_t a2)
{
  *(void *)a2 = off_1019E49B8;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(result + 8);
  uint64_t v2 = *(void *)(result + 24);
  *(void *)(a2 + 24) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100579FA8(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 24);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_100579FB8(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete(__p);
}

void sub_100579FF8(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 24);
  if (v2)
  {
    uint64_t v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      if (*(void *)(a1 + 16)) {
        operator new();
      }
      sub_10004D2C8(v3);
    }
  }
}

uint64_t sub_10057A0A4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10057A0E4()
{
}

void sub_10057A0F0(uint64_t a1)
{
  uint64_t v1 = *(void **)a1;
  uint64_t v2 = *(NSObject **)(*(void *)a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v3 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Geofence validity timer expired...", v3, 2u);
  }
  sub_100576D1C(v1);

  operator delete();
}

void sub_10057A18C()
{
}

const void **sub_10057A1B0@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t v3 = *(void *)(a1 + 40);
  uint64_t v4 = (uint64_t **)(v3 + 16);
  uint64_t v5 = *(void *)v3;
  sub_100058198(&v7, (const void **)(v3 + 8));
  sub_1005774B4(a2, v5, v4, &v7);
  return sub_100057D78(&v7);
}

void sub_10057A210(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100057D78((const void **)va);
  _Unwind_Resume(a1);
}

void sub_10057A380(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, dispatch_object_t object, dispatch_object_t a17)
{
  if (object) {
    dispatch_release(object);
  }
  if (a17) {
    dispatch_release(a17);
  }
  if (*(char *)(v17 - 33) < 0) {
    operator delete(*(void **)(v17 - 56));
  }
  operator delete();
}

void sub_10057A438(uint64_t a1)
{
  sub_100058DB0(&__p, "/cc/props/radio_mode");
  v4[0] = off_1019E4AE0;
  v4[1] = a1;
  double v4[3] = v4;
  ctu::RestModule::observeProperty();
  sub_10003F600(v4);
  if (v3 < 0) {
    operator delete(__p);
  }
}

void sub_10057A4EC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_10057A68C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void *sub_10057A920(unint64_t a1)
{
  if (a1 >= 0x492492492492493) {
    sub_10006A7CC();
  }
  return operator new(56 * a1);
}

void sub_10057A970()
{
}

void *sub_10057A984(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = off_1019E4AE0;
  result[1] = v3;
  return result;
}

uint64_t sub_10057A9CC(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019E4AE0;
  a2[1] = v2;
  return result;
}

uint64_t sub_10057A9F8(uint64_t a1)
{
  uint64_t v1 = *(BOOL **)(a1 + 8);
  uint64_t result = read_rest_value();
  *uint64_t v1 = ((unint64_t)&_mh_execute_header & 0x101FFFFFFFFLL) == 2;
  return result;
}

uint64_t sub_10057AA48(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10057AA88()
{
}

void sub_10057AA94()
{
}

void sub_10057AB5C(_Unwind_Exception *exception_object)
{
  if (v1) {
    dispatch_release(v1);
  }
  if (v2) {
    operator delete();
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10057AB90(uint64_t a1, void *a2, dispatch_object_t *a3)
{
  CFDictionaryRef v6 = *a3;
  dispatch_object_t object = v6;
  if (v6) {
    dispatch_retain(v6);
  }
  sub_100058DB0(__p, "/activation");
  v14[0] = off_101999E18;
  v14[1] = sub_10057ADE4;
  void v14[3] = v14;
  sub_100A85938(a1, a2, &object, "server.activation", (long long *)__p, (uint64_t)v14);
  sub_10008863C(v14);
  if (v12 < 0) {
    operator delete(__p[0]);
  }
  if (object) {
    dispatch_release(object);
  }
  *(void *)a1 = off_1019E4B60;
  *(void *)(a1 + 200) = 0;
  *(void *)(a1 + 232) = 0;
  *(void *)(a1 + 208) = 0;
  *(void *)(a1 + 216) = 0;
  *(void *)(a1 + 224) = a1 + 232;
  *(void *)(a1 + 240) = 0;
  *(void *)(a1 + 248) = a1 + 256;
  *(void *)(a1 + 256) = 0;
  *(void *)(a1 + 264) = 0;
  sub_100058DB0(&v9, *(char **)(a1 + 112));
  unint64_t v8 = *a3;
  if (*a3) {
    dispatch_retain(*a3);
  }
  ctu::RestModule::RestModule();
  if (v8) {
    dispatch_release(v8);
  }
  if (v10 < 0) {
    operator delete(v9);
  }
  return a1;
}

void sub_10057AD44(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, dispatch_object_t object, dispatch_object_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,dispatch_object_t a23,char a24)
{
  if (object) {
    dispatch_release(object);
  }
  if (a10) {
    dispatch_release(a10);
  }
  if (a16 < 0) {
    operator delete(__p);
  }
  sub_100088048(v26, *(void **)(v24 + 256));
  sub_1000881B0(v25, *(void **)(v24 + 232));
  if (*(char *)(v24 + 223) < 0) {
    operator delete(*v27);
  }
  sub_100A85CB8(v24);
  _Unwind_Resume(a1);
}

const char *sub_10057ADE4(int a1)
{
  uint64_t v1 = "server.activation.?";
  if (a1 == 2) {
    uint64_t v1 = "server.activation.2";
  }
  if (a1 == 1) {
    return "server.activation.1";
  }
  else {
    return v1;
  }
}

void sub_10057AE10(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v5 = *a3;
  uint64_t v4 = a3[1];
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 16), 1uLL, memory_order_relaxed);
  }
  CFDictionaryRef v6 = *(std::__shared_weak_count **)(a1 + 80);
  *(void *)(a1 + 72) = v5;
  *(void *)(a1 + 80) = v4;
  if (v6) {
    std::__shared_weak_count::__release_weak(v6);
  }
  Registry::createRestModuleOneTimeUseConnection(&v8, *(Registry **)(a1 + 56));
  ctu::RestModule::connect();
  uint64_t v7 = (capabilities::ct *)v9;
  if (v9) {
    sub_10004D2C8(v9);
  }
  if (capabilities::ct::supportsGemini(v7))
  {
    sub_100058DB0(__p, "/cc/props/subscriber_data_id_states");
    char v12 = off_1019E4C38;
    uint64_t v13 = a1 + 224;
    CFDictionaryRef v14 = &v12;
    ctu::RestModule::observeProperty();
    sub_10003F600(&v12);
    if (v11 < 0) {
      operator delete(__p[0]);
    }
    sub_1001F3BF8(a1 + 248);
  }
  else
  {
    sub_100058DB0(__p, "/cc/props/subscriber_id");
    char v12 = off_1019E4CB8;
    uint64_t v13 = a1 + 200;
    CFDictionaryRef v14 = &v12;
    ctu::RestModule::observeProperty();
    sub_10003F600(&v12);
    if (v11 < 0) {
      operator delete(__p[0]);
    }
  }
}

void sub_10057AF88(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_10057AFCC(uint64_t a1)
{
  return ctu::RestModule::disconnect((ctu::RestModule *)(a1 + 272));
}

uint64_t sub_10057AFD4(uint64_t a1, std::string::size_type a2)
{
  uint64_t v4 = *(NSObject **)(a1 + 40);
  BOOL v5 = os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT);
  if (v5)
  {
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = a2;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I %s checking to send report to the server", (uint8_t *)&buf, 0xCu);
  }
  int v6 = capabilities::ct::supportsVoiceCall((capabilities::ct *)v5);
  uint64_t v7 = sub_100A8692C(a1);
  if (v6)
  {
    if (v7 && (*(unsigned char *)(a1 + 137) || *(unsigned char *)(a1 + 138))) {
      goto LABEL_7;
    }
LABEL_74:
    uint64_t v33 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf.__r_.__value_.__l.__data_) = 0;
      _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "#N Cannot send the report", (uint8_t *)&buf, 2u);
    }
    sub_100A86644(a1);
    return 2;
  }
  if ((v7 & 1) == 0) {
    goto LABEL_74;
  }
LABEL_7:
  memset(&v43, 0, sizeof(v43));
  if ((capabilities::ct::supportsGemini((capabilities::ct *)v7) & 1) == 0)
  {
    if (*(char *)(a1 + 223) < 0) {
      sub_10004FC84(&v43, *(void **)(a1 + 200), *(void *)(a1 + 208));
    }
    else {
      std::string v43 = *(std::string *)(a1 + 200);
    }
    goto LABEL_97;
  }
  uint64_t v46 = 0;
  uint64_t v47 = 0;
  unint64_t v48 = 0;
  uint64_t v44 = 0;
  v45[0] = 0;
  v45[1] = 0;
  sub_10005DFF8((uint64_t *)&v44, a1 + 168);
  uint64_t v8 = *(void **)(a1 + 224);
  if (v8 == (void *)(a1 + 232)) {
    goto LABEL_70;
  }
  CFTypeID v9 = (void *)(a1 + 256);
  do
  {
    __dst[0] = 0;
    __dst[1] = 0;
    uint64_t v50 = 0;
    if (*((char *)v8 + 95) < 0)
    {
      sub_10004FC84(__dst, (void *)v8[9], v8[10]);
    }
    else
    {
      *(_OWORD *)long long __dst = *(_OWORD *)(v8 + 9);
      uint64_t v50 = v8[11];
    }
    char v10 = *(void **)(a1 + 248);
    if (v10 == v9) {
      goto LABEL_62;
    }
    while (1)
    {
      uint64_t v11 = *((unsigned __int8 *)v10 + 135);
      if ((v11 & 0x80u) == 0) {
        char v12 = (void *)*((unsigned __int8 *)v10 + 135);
      }
      else {
        char v12 = (void *)v10[15];
      }
      uint64_t v13 = (void *)HIBYTE(v50);
      if (v50 < 0) {
        uint64_t v13 = __dst[1];
      }
      if (v12 != v13) {
        goto LABEL_47;
      }
      CFDictionaryRef v14 = (const void **)(v10 + 14);
      CFArrayRef v15 = v50 >= 0 ? __dst : (void **)__dst[0];
      if ((v11 & 0x80) == 0) {
        break;
      }
      if (!memcmp(*v14, v15, v10[15])) {
        goto LABEL_29;
      }
LABEL_47:
      uint64_t v23 = (void *)v10[1];
      if (v23)
      {
        do
        {
          uint64_t v24 = v23;
          uint64_t v23 = (void *)*v23;
        }
        while (v23);
      }
      else
      {
        do
        {
          uint64_t v24 = (void *)v10[2];
          BOOL v22 = *v24 == (void)v10;
          char v10 = v24;
        }
        while (!v22);
      }
      char v10 = v24;
      if (v24 == v9) {
        goto LABEL_62;
      }
    }
    if (*((unsigned char *)v10 + 135))
    {
      while (*(unsigned __int8 *)v14 == *(unsigned __int8 *)v15)
      {
        CFDictionaryRef v14 = (const void **)((char *)v14 + 1);
        CFArrayRef v15 = (void **)((char *)v15 + 1);
        if (!--v11) {
          goto LABEL_29;
        }
      }
      goto LABEL_47;
    }
LABEL_29:
    int isSimReady = subscriber::isSimReady();
    uint64_t v17 = v44;
    if (v44 == v45) {
      int v18 = 0;
    }
    else {
      int v18 = isSimReady;
    }
    if (v18 != 1) {
      goto LABEL_47;
    }
    while (1)
    {
      if (*((_DWORD *)v10 + 10) == *((_DWORD *)v17 + 8))
      {
        MCCAndMNC::getMcc((uint64_t *)&buf, (MCCAndMNC *)(v17 + 5));
        if (MCC::valid((MCC *)&buf))
        {
          MCCAndMNC::getMnc(v51, (MCCAndMNC *)(v17 + 5));
          char v19 = MCC::valid((MCC *)v51);
          if (v52 < 0) {
            operator delete((void *)v51[1]);
          }
        }
        else
        {
          char v19 = 0;
        }
        if (v54 < 0) {
          operator delete((void *)buf.__r_.__value_.__l.__size_);
        }
        if (v19) {
          break;
        }
      }
      uint64_t v20 = v17[1];
      if (v20)
      {
        do
        {
          uint64_t v21 = (void **)v20;
          uint64_t v20 = (void *)*v20;
        }
        while (v20);
      }
      else
      {
        do
        {
          uint64_t v21 = (void **)v17[2];
          BOOL v22 = *v21 == v17;
          uint64_t v17 = v21;
        }
        while (!v22);
      }
      uint64_t v17 = v21;
      if (v21 == v45) {
        goto LABEL_47;
      }
    }
    if (v9 != v10)
    {
      uint64_t v25 = v47;
      if ((unint64_t)v47 >= v48)
      {
        double v27 = (long long *)sub_10030E9EC((uint64_t *)&v46, (long long *)__dst);
      }
      else
      {
        if (SHIBYTE(v50) < 0)
        {
          sub_10004FC84(v47, __dst[0], (unint64_t)__dst[1]);
        }
        else
        {
          long long v26 = *(_OWORD *)__dst;
          *((void *)v47 + 2) = v50;
          *uint64_t v25 = v26;
        }
        double v27 = (long long *)((char *)v25 + 24);
      }
      uint64_t v47 = v27;
    }
LABEL_62:
    if (SHIBYTE(v50) < 0) {
      operator delete(__dst[0]);
    }
    long long v28 = (void *)v8[1];
    if (v28)
    {
      do
      {
        xpc_object_t v29 = v28;
        long long v28 = (void *)*v28;
      }
      while (v28);
    }
    else
    {
      do
      {
        xpc_object_t v29 = (void *)v8[2];
        BOOL v22 = *v29 == (void)v8;
        uint64_t v8 = v29;
      }
      while (!v22);
    }
    uint64_t v8 = v29;
  }
  while (v29 != (void *)(a1 + 232));
LABEL_70:
  uint64_t v31 = (uint64_t)v46;
  uint64_t v30 = v47;
  memset(&v43, 0, sizeof(v43));
  if (v46 != v47)
  {
    if (*((char *)v46 + 23) < 0)
    {
      sub_10004FC84(&buf, *(void **)v46, *((void *)v46 + 1));
    }
    else
    {
      long long v32 = *v46;
      buf.__r_.__value_.__r.__words[2] = *((void *)v46 + 2);
      *(_OWORD *)&buf.__r_.__value_.__l.__data_ = v32;
    }
    std::string v43 = buf;
    for (uint64_t i = v31 + 24; (long long *)i != v30; i += 24)
    {
      *((unsigned char *)&buf.__r_.__value_.__s + 23) = 1;
      strcpy((char *)&buf, "_");
      std::string::append(&v43, (const std::string::value_type *)&buf, 1uLL);
      if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(buf.__r_.__value_.__l.__data_);
      }
      if (*(char *)(i + 23) < 0)
      {
        sub_10004FC84(&buf, *(void **)i, *(void *)(i + 8));
      }
      else
      {
        long long v36 = *(_OWORD *)i;
        buf.__r_.__value_.__r.__words[2] = *(void *)(i + 16);
        *(_OWORD *)&buf.__r_.__value_.__l.__data_ = v36;
      }
      if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        p_std::string buf = &buf;
      }
      else {
        p_std::string buf = (std::string *)buf.__r_.__value_.__r.__words[0];
      }
      if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string::size_type size = HIBYTE(buf.__r_.__value_.__r.__words[2]);
      }
      else {
        std::string::size_type size = buf.__r_.__value_.__l.__size_;
      }
      std::string::append(&v43, (const std::string::value_type *)p_buf, size);
      if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(buf.__r_.__value_.__l.__data_);
      }
    }
  }
  sub_10003FB28((uint64_t)&v44, v45[0]);
  buf.__r_.__value_.__r.__words[0] = (std::string::size_type)&v46;
  sub_100047F64((void ***)&buf);
LABEL_97:
  std::string::size_type v39 = HIBYTE(v43.__r_.__value_.__r.__words[2]);
  if ((v43.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
    std::string::size_type v39 = v43.__r_.__value_.__l.__size_;
  }
  if (v39)
  {
    if ((*(unsigned int (**)(uint64_t, std::string *))(*(void *)a1 + 48))(a1, &v43))
    {
      uint64_t v34 = (*(uint64_t (**)(uint64_t, std::string *))(*(void *)a1 + 16))(a1, &v43);
    }
    else
    {
      uint64_t v41 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v41, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(buf.__r_.__value_.__l.__data_) = 0;
        _os_log_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_DEFAULT, "#I No need to send activation report", (uint8_t *)&buf, 2u);
      }
      uint64_t v34 = 3;
    }
  }
  else
  {
    long long v40 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v40, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf.__r_.__value_.__l.__data_) = 0;
      uint64_t v34 = 2;
      _os_log_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_DEFAULT, "#E Current Subscriber ID is empty", (uint8_t *)&buf, 2u);
    }
    else
    {
      uint64_t v34 = 2;
    }
  }
  if (SHIBYTE(v43.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v43.__r_.__value_.__l.__data_);
  }
  return v34;
}

void sub_10057B608(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, char a16, void *a17, uint64_t a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,uint64_t a28,char *a29,void *a30,uint64_t a31,int a32,__int16 a33,char a34,char a35)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  sub_10003FB28((uint64_t)&a16, a17);
  a29 = &a19;
  sub_100047F64((void ***)&a29);
  _Unwind_Resume(a1);
}

uint64_t sub_10057B6EC(void *a1, unsigned __int8 *a2)
{
  uint64_t v21 = 0;
  DevicePersistentCopyValue((uint64_t *)buf, @"ReportedSubscriberIdentity", 0);
  sub_100056248(&v21, (CFTypeRef *)buf);
  sub_1000577C4((const void **)buf);
  if (v21) {
    uint64_t v4 = sub_1000810B8;
  }
  else {
    uint64_t v4 = 0;
  }
  if (!v4)
  {
    char v12 = a1[5];
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I No subscriber identity before, generating report", buf, 2u);
    }
    uint64_t v13 = 1;
    goto LABEL_33;
  }
  memset(buf, 0, sizeof(buf));
  ctu::cf::assign();
  uint64_t v20 = *(void *)&buf[16];
  *(_OWORD *)long long __p = *(_OWORD *)buf;
  uint64_t v5 = *((void *)a2 + 1);
  int v6 = (char)a2[23];
  uint64_t v7 = HIBYTE(*(void *)&buf[16]);
  int v8 = (char)buf[23];
  if ((buf[23] & 0x80u) == 0) {
    uint64_t v9 = HIBYTE(*(void *)&buf[16]);
  }
  else {
    uint64_t v9 = *(void *)&buf[8];
  }
  if (v6 >= 0) {
    uint64_t v5 = a2[23];
  }
  if (v9 != v5) {
    goto LABEL_23;
  }
  if (v6 >= 0) {
    char v10 = a2;
  }
  else {
    char v10 = *(unsigned __int8 **)a2;
  }
  if (((char)buf[23] & 0x80000000) == 0)
  {
    if (buf[23])
    {
      uint64_t v11 = __p;
      while (*(unsigned __int8 *)v11 == *v10)
      {
        uint64_t v11 = (void **)((char *)v11 + 1);
        ++v10;
        if (!--v7) {
          goto LABEL_37;
        }
      }
LABEL_23:
      CFDictionaryRef v14 = a1[5];
      if (!os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_31;
      }
      if (v8 >= 0) {
        CFArrayRef v15 = __p;
      }
      else {
        CFArrayRef v15 = (void **)__p[0];
      }
      if (v6 >= 0) {
        char v10 = a2;
      }
      else {
        char v10 = *(unsigned __int8 **)a2;
      }
      goto LABEL_30;
    }
LABEL_37:
    uint64_t v17 = a1[5];
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I Same subscriber identity, not reporting again", buf, 2u);
    }
    uint64_t v13 = 0;
    if ((v8 & 0x80) != 0) {
      goto LABEL_32;
    }
    goto LABEL_33;
  }
  CFArrayRef v15 = (void **)__p[0];
  if (!memcmp(__p[0], v10, *(size_t *)&buf[8])) {
    goto LABEL_37;
  }
  CFDictionaryRef v14 = a1[5];
  if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
  {
LABEL_30:
    *(_DWORD *)std::string buf = 136315394;
    *(void *)&uint8_t buf[4] = v15;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = v10;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I Subscriber identities are not matching, %s != %s, generating report", buf, 0x16u);
  }
LABEL_31:
  xpc_object_t object = xpc_null_create();
  (*(void (**)(void *, xpc_object_t *))(*a1 + 64))(a1, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  uint64_t v13 = 1;
  if (v20 < 0) {
LABEL_32:
  }
    operator delete(__p[0]);
LABEL_33:
  sub_1000558F4(&v21);
  return v13;
}

void sub_10057B9BC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, char a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

const void **sub_10057BA34@<X0>(uint64_t a1@<X0>, CFDataRef *a2@<X8>)
{
  *a2 = 0;
  CFTypeRef cf = 0;
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (Mutable)
  {
    CFTypeRef v5 = cf;
    CFTypeRef cf = Mutable;
    *(void *)&buf.var0 = v5;
    sub_10005717C((const void **)&buf);
  }
  CFTypeRef v71 = cf;
  if (cf) {
    CFRetain(cf);
  }
  int v6 = (os_log_t *)(a1 + 40);
  uint64_t v7 = (Registry **)(a1 + 56);
  BOOL v8 = sub_100105644((os_log_t *)(a1 + 40), (CFMutableDictionaryRef *)&v71, (Registry **)(a1 + 56));
  sub_10005717C(&v71);
  if (!v8)
  {
    char v12 = *v6;
    if (os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf.var0) = 0;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#N Failed to add common key values", (uint8_t *)&buf, 2u);
    }
    return sub_10005717C(&cf);
  }
  uint64_t v9 = *(std::__shared_weak_count **)(a1 + 80);
  if (v9)
  {
    char v10 = std::__shared_weak_count::lock(v9);
    if (v10)
    {
      uint64_t v11 = *(void *)(a1 + 72);
      if (v11)
      {
        CFTypeRef v70 = cf;
        if (cf) {
          CFRetain(cf);
        }
        (*(void (**)(uint64_t, CFTypeRef *))(*(void *)v11 + 24))(v11, &v70);
        sub_10005717C(&v70);
        CFTypeRef v69 = cf;
        if (cf) {
          CFRetain(cf);
        }
        (*(void (**)(uint64_t, CFTypeRef *, uint64_t))(*(void *)v11 + 32))(v11, &v69, 1);
        sub_10005717C(&v69);
        goto LABEL_19;
      }
    }
  }
  else
  {
    char v10 = 0;
  }
  uint64_t v13 = *v6;
  if (os_log_type_enabled(*v6, OS_LOG_TYPE_ERROR))
  {
    LOWORD(buf.var0) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "Could not get parent for adding device information in payload", (uint8_t *)&buf, 2u);
    if (!v10) {
      goto LABEL_20;
    }
    goto LABEL_19;
  }
  if (v10) {
LABEL_19:
  }
    sub_10004D2C8(v10);
LABEL_20:
  long long v67 = 0;
  v68[0] = 0;
  v68[1] = 0;
  sub_10005DFF8((uint64_t *)&v67, a1 + 168);
  CFDictionaryRef v14 = v67;
  if (v67 != v68)
  {
    long long v15 = 0uLL;
    while (1)
    {
      long long v66 = v15;
      *(_OWORD *)uint64_t v65 = v15;
      MCCAndMNC::getMcc((uint64_t *)v65, (MCCAndMNC *)(v14 + 5));
      *(_OWORD *)unsigned int v63 = 0u;
      long long v64 = 0u;
      MCCAndMNC::getMnc((uint64_t *)v63, (MCCAndMNC *)(v14 + 5));
      CFTypeID v16 = (os_log_t *)(*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), *((unsigned int *)v14 + 8));
      if ((MCC::valid((MCC *)v65) & 1) == 0 && (MCC::valid((MCC *)v63) & 1) == 0)
      {
        uint64_t v47 = *v16;
        if (os_log_type_enabled(*v16, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(buf.var0) = 0;
          _os_log_impl((void *)&_mh_execute_header, v47, OS_LOG_TYPE_DEFAULT, "#E Failed to get MCC or MNC", (uint8_t *)&buf, 2u);
        }
        goto LABEL_109;
      }
      uint64_t v17 = *v16;
      if (os_log_type_enabled(*v16, OS_LOG_TYPE_DEFAULT))
      {
        IntCFDictionaryRef Value = MCC::getIntValue((MCC *)v65);
        buf.var0 = 67109120;
        buf.var1 = IntValue;
        _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I Setting the Country: %03d", (uint8_t *)&buf, 8u);
      }
      char v19 = (__CFDictionary *)cf;
      if (*((_DWORD *)v14 + 8) == 2) {
        CFStringRef v20 = @"Country2";
      }
      else {
        CFStringRef v20 = @"Country";
      }
      MCC::getStringValue((uint64_t *)v61, (MCC *)v65);
      if (SHIBYTE(v62) < 0)
      {
        sub_10004FC84(&__p, v61[0], (unint64_t)v61[1]);
      }
      else
      {
        long long __p = *(_OWORD *)v61;
        int64_t size = v62;
      }
      uint64_t v76 = 0;
      if (SHIBYTE(size) < 0)
      {
        sub_10004FC84(&buf, (void *)__p, *((unint64_t *)&__p + 1));
      }
      else
      {
        *(_OWORD *)&buf.var0 = __p;
        buf.var2.__r_.__value_.var0.var1.__size_ = size;
      }
      std::string v77 = 0;
      if (ctu::cf::convert_copy())
      {
        uint64_t v21 = v76;
        uint64_t v76 = v77;
        *(void *)&long long __dst = v21;
        sub_1000558F4((const void **)&__dst);
      }
      if (buf.var2.__r_.__value_.var0.var0.__data_[15] < 0) {
        operator delete(*(void **)&buf.var0);
      }
      CFPropertyListRef value = v76;
      uint64_t v76 = 0;
      sub_1000558F4((const void **)&v76);
      if (SHIBYTE(size) < 0) {
        operator delete((void *)__p);
      }
      CFDictionarySetValue(v19, v20, value);
      sub_1000558F4((const void **)&value);
      if (SHIBYTE(v62) < 0) {
        operator delete(v61[0]);
      }
      BOOL v22 = *v16;
      if (os_log_type_enabled(*v16, OS_LOG_TYPE_DEFAULT))
      {
        int IntegerWidth = MNC::getIntegerWidth((MNC *)v63);
        int v24 = MCC::getIntValue((MCC *)v63);
        buf.var0 = 67109376;
        buf.var1 = IntegerWidth;
        *(_WORD *)buf.var2.__r_.__value_.var0.var0.__data_ = 1024;
        *(_DWORD *)((char *)&buf.var2.__r_.__value_.var0.var1.__data_ + 2) = v24;
        _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "#I Setting the Carrier: %0.*d", (uint8_t *)&buf, 0xEu);
      }
      uint64_t v25 = (__CFDictionary *)cf;
      if (*((_DWORD *)v14 + 8) == 2) {
        CFStringRef v26 = @"Carrier2";
      }
      else {
        CFStringRef v26 = @"Carrier";
      }
      MCC::getStringValue((uint64_t *)v59, (MCC *)v63);
      if (SHIBYTE(v60) < 0)
      {
        sub_10004FC84(&__p, v59[0], (unint64_t)v59[1]);
      }
      else
      {
        long long __p = *(_OWORD *)v59;
        int64_t size = v60;
      }
      uint64_t v76 = 0;
      if (SHIBYTE(size) < 0)
      {
        sub_10004FC84(&buf, (void *)__p, *((unint64_t *)&__p + 1));
      }
      else
      {
        *(_OWORD *)&buf.var0 = __p;
        buf.var2.__r_.__value_.var0.var1.__size_ = size;
      }
      std::string v77 = 0;
      if (ctu::cf::convert_copy())
      {
        double v27 = v76;
        uint64_t v76 = v77;
        *(void *)&long long __dst = v27;
        sub_1000558F4((const void **)&__dst);
      }
      if (buf.var2.__r_.__value_.var0.var0.__data_[15] < 0) {
        operator delete(*(void **)&buf.var0);
      }
      CFPropertyListRef value = v76;
      uint64_t v76 = 0;
      sub_1000558F4((const void **)&v76);
      if (SHIBYTE(size) < 0) {
        operator delete((void *)__p);
      }
      CFDictionarySetValue(v25, v26, value);
      sub_1000558F4((const void **)&value);
      if (SHIBYTE(v60) < 0) {
        operator delete(v59[0]);
      }
      int v58 = 0;
      ServiceMap = (std::mutex *)Registry::getServiceMap(*v7);
      xpc_object_t v29 = ServiceMap;
      if (v30 < 0)
      {
        uint64_t v31 = (unsigned __int8 *)(v30 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v32 = 5381;
        do
        {
          uint64_t v30 = v32;
          unsigned int v33 = *v31++;
          uint64_t v32 = (33 * v32) ^ v33;
        }
        while (v33);
      }
      std::mutex::lock(ServiceMap);
      *(void *)&buf.var0 = v30;
      uint64_t v34 = sub_10004D37C(&v29[1].__m_.__sig, (unint64_t *)&buf);
      if (!v34) {
        break;
      }
      uint64_t v36 = v34[3];
      uint64_t v35 = (std::__shared_weak_count *)v34[4];
      if (!v35) {
        goto LABEL_69;
      }
      atomic_fetch_add_explicit(&v35->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v29);
      atomic_fetch_add_explicit(&v35->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v35);
      char v37 = 0;
LABEL_70:
      (*(void (**)(long long *__return_ptr, uint64_t, void, uint64_t, const __CFString *, void, void))(*(void *)v36 + 80))(&__p, v36, *((unsigned int *)v14 + 8), 1, @"CarrierName", 0, 0);
      sub_100056248(&v58, (CFTypeRef *)&__p);
      sub_1000577C4((const void **)&__p);
      if ((v37 & 1) == 0) {
        sub_10004D2C8(v35);
      }
      uint64_t v38 = v58;
      if (v58) {
        std::string::size_type v39 = sub_1000810B8;
      }
      else {
        std::string::size_type v39 = 0;
      }
      if (v39)
      {
        long long v40 = *v16;
        if (os_log_type_enabled(*v16, OS_LOG_TYPE_DEFAULT))
        {
          memset(&buf, 0, 24);
          ctu::cf::assign();
          long long __p = *(_OWORD *)&buf.var0;
          int64_t size = buf.var2.__r_.__value_.var0.var1.__size_;
          p_p = *(long long **)&buf.var0;
          if (buf.var2.__r_.__value_.var0.var0.__data_[15] >= 0) {
            p_p = &__p;
          }
          LODWORD(__dst) = 136315138;
          *(void *)((char *)&__dst + 4) = p_p;
          _os_log_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_DEFAULT, "#I Setting the Carrier Name: %s", (uint8_t *)&__dst, 0xCu);
          if (SHIBYTE(size) < 0) {
            operator delete((void *)__p);
          }
          uint64_t v38 = v58;
        }
        if (*((_DWORD *)v14 + 8) == 2) {
          CFStringRef v42 = @"CarrierName2";
        }
        else {
          CFStringRef v42 = @"CarrierName";
        }
        CFDictionarySetValue((CFMutableDictionaryRef)cf, v42, v38);
      }
      long long v83 = 0u;
      long long v84 = 0u;
      long long v81 = 0u;
      long long v82 = 0u;
      long long v79 = 0u;
      long long v80 = 0u;
      memset(&buf, 0, sizeof(buf));
      sub_100105A4C(v7, v16, *((unsigned int *)v14 + 8), (uint64_t)&buf);
      if (BYTE8(v84))
      {
        std::string v43 = *v16;
        if (os_log_type_enabled(*v16, OS_LOG_TYPE_DEFAULT))
        {
          CSIPhoneNumber::getBaseNumber((uint64_t *)&__p, &buf);
          uint64_t v44 = &__p;
          if (size < 0) {
            uint64_t v44 = (long long *)__p;
          }
          LODWORD(__dst) = 136315138;
          *(void *)((char *)&__dst + 4) = v44;
          _os_log_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_DEFAULT, "#I Setting the Phone Number: %s", (uint8_t *)&__dst, 0xCu);
          if (SHIBYTE(size) < 0) {
            operator delete((void *)__p);
          }
        }
        uint64_t v45 = (__CFDictionary *)cf;
        CFStringRef v46 = sub_100A8590C(*((_DWORD *)v14 + 8));
        CSIPhoneNumber::getBaseNumber((uint64_t *)v55, &buf);
        if (SHIBYTE(v56) < 0)
        {
          sub_10004FC84(&__dst, v55[0], (unint64_t)v55[1]);
        }
        else
        {
          long long __dst = *(_OWORD *)v55;
          int64_t v86 = v56;
        }
        CFPropertyListRef value = 0;
        if (SHIBYTE(v86) < 0)
        {
          sub_10004FC84(&__p, (void *)__dst, *((unint64_t *)&__dst + 1));
        }
        else
        {
          long long __p = __dst;
          int64_t size = v86;
        }
        uint64_t v76 = 0;
        if (ctu::cf::convert_copy())
        {
          unint64_t v48 = value;
          CFPropertyListRef value = v76;
          std::string v77 = v48;
          sub_1000558F4((const void **)&v77);
        }
        if (SHIBYTE(size) < 0) {
          operator delete((void *)__p);
        }
        CFTypeID v57 = value;
        CFPropertyListRef value = 0;
        sub_1000558F4((const void **)&value);
        if (SHIBYTE(v86) < 0) {
          operator delete((void *)__dst);
        }
        CFDictionarySetValue(v45, v46, v57);
        sub_1000558F4((const void **)&v57);
        if (SHIBYTE(v56) < 0) {
          operator delete(v55[0]);
        }
      }
      sub_10057CA94((uint64_t)&buf);
      sub_1000558F4(&v58);
LABEL_109:
      if (SHIBYTE(v64) < 0) {
        operator delete(v63[1]);
      }
      if (SHIBYTE(v66) < 0) {
        operator delete(v65[1]);
      }
      uint64_t v49 = v14[1];
      if (v49)
      {
        do
        {
          uint64_t v50 = (void **)v49;
          uint64_t v49 = (void *)*v49;
        }
        while (v49);
      }
      else
      {
        do
        {
          uint64_t v50 = (void **)v14[2];
          BOOL v51 = *v50 == v14;
          CFDictionaryRef v14 = v50;
        }
        while (!v51);
      }
      CFDictionaryRef v14 = v50;
      long long v15 = 0uLL;
      if (v50 == v68) {
        goto LABEL_119;
      }
    }
    uint64_t v36 = 0;
LABEL_69:
    std::mutex::unlock(v29);
    uint64_t v35 = 0;
    char v37 = 1;
    goto LABEL_70;
  }
LABEL_119:
  CFDataRef Data = CFPropertyListCreateData(0, cf, kCFPropertyListXMLFormat_v1_0, 0, 0);
  CFDataRef v53 = *a2;
  *a2 = Data;
  *(void *)&buf.var0 = v53;
  sub_100030068((const void **)&buf);
  sub_10003FB28((uint64_t)&v67, v68[0]);
  return sub_10005717C(&cf);
}