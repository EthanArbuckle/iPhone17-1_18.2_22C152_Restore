void sub_100AF8148(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;

  *(void *)(v2 + 4760) = v1;
  *(void *)(v3 - 176) = v3 - 112;
  sub_100B06C10((void ***)(v3 - 176));
  _Unwind_Resume(a1);
}

void non-virtual thunk to'DataServiceController::sendNRSlicedRunningAppStateChanged_sync(DataServiceController *this)
{
}

void DataServiceController::updateActiveSliceStatus_sync(DataServiceController *this)
{
  v2 = (std::__shared_weak_count *)*((void *)this + 14);
  v14 = v2;
  if (v2) {
    atomic_fetch_add_explicit(&v2->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  subscriber::makeSimSlotRange();
  if (v14) {
    sub_10004D2C8(v14);
  }
  v3 = v15;
  if (v15 == v16) {
    goto LABEL_29;
  }
  while ((v17(*v3) & 1) == 0)
  {
    if (++v3 == v16)
    {
      v3 = v16;
      break;
    }
  }
  if (v3 == v16)
  {
LABEL_29:
    int v4 = 0;
  }
  else
  {
    int v4 = 0;
    do
    {
      int v5 = *v3;
      if (sub_100AF2240(*((void *)this + 18), *v3))
      {
        uint64_t v6 = sub_100AEFE40(*((void *)this + 18), v5);
        v8 = *(uint64_t **)v6;
        v7 = *(uint64_t **)(v6 + 8);
        while (v8 != v7)
        {
          uint64_t v10 = *v8;
          v9 = (std::__shared_weak_count *)v8[1];
          if (v9) {
            atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          if (v10)
          {
            (*(void (**)(uint64_t))(*(void *)v10 + 472))(v10);
            if (isSlice()) {
              v4 += (*(uint64_t (**)(uint64_t))(*(void *)v10 + 168))(v10);
            }
          }
          if (v9) {
            sub_10004D2C8(v9);
          }
          v8 += 2;
        }
      }
      v11 = v3 + 1;
      v3 = v16;
      if (v11 != v16)
      {
        v3 = v11;
        while ((v17(*v3) & 1) == 0)
        {
          if (++v3 == v16)
          {
            v3 = v16;
            break;
          }
        }
      }
    }
    while (v3 != v16);
  }
  if (!*((unsigned char *)this + 4883) || *((unsigned char *)this + 4882) != (v4 != 0))
  {
    *((_WORD *)this + 2441) = (v4 != 0) | 0x100;
    int v12 = (*(uint64_t (**)(DataServiceController *))(*(void *)this + 1088))(this);
    if (sub_100AF2240(*((void *)this + 18), v12))
    {
      if (*(void *)(sub_100AEFE40(*((void *)this + 18), v12) + 24))
      {
        uint64_t v13 = **(void **)(sub_100AEFE40(*((void *)this + 18), v12) + 24);
        (*(void (**)(void))(v13 + 960))();
      }
    }
  }
}

void sub_100AF8540(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11)
{
  if (a11) {
    sub_10004D2C8(a11);
  }
  _Unwind_Resume(exception_object);
}

void non-virtual thunk to'DataServiceController::updateActiveSliceStatus_sync(DataServiceController *this)
{
}

void DataServiceController::makeSlicesStruct(DataServiceController *this)
{
  v1 = (std::__shared_weak_count *)*((void *)this + 14);
  v3 = v1;
  if (v1) {
    atomic_fetch_add_explicit(&v1->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  subscriber::makeSimSlotRange();
  if (v3) {
    sub_10004D2C8(v3);
  }
  v2 = v4;
  if (v4 != v5)
  {
    while ((v6(*v2) & 1) == 0)
    {
      if (++v2 == v5)
      {
        v2 = v5;
        break;
      }
    }
    if (v2 != v5) {
      operator new();
    }
  }
}

void sub_100AF87DC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11)
{
  if (a11) {
    sub_10004D2C8(a11);
  }
  _Unwind_Resume(exception_object);
}

double DataServiceController::cleanSlicesStruct(DataServiceController *this)
{
  v2 = (char *)this + 4616;
  v3 = (char *)*((void *)this + 577);
  int v4 = (char *)this + 4624;
  if (v3 != (char *)this + 4624)
  {
    do
    {
      uint64_t v5 = *((void *)v3 + 5);
      if (v5)
      {
        sub_100B06C94(v5);
        operator delete();
      }
      uint64_t v6 = (char *)*((void *)v3 + 1);
      if (v6)
      {
        do
        {
          v7 = v6;
          uint64_t v6 = *(char **)v6;
        }
        while (v6);
      }
      else
      {
        do
        {
          v7 = (char *)*((void *)v3 + 2);
          BOOL v8 = *(void *)v7 == (void)v3;
          v3 = v7;
        }
        while (!v8);
      }
      v3 = v7;
    }
    while (v7 != v4);
  }
  sub_1000346F8((uint64_t)v2, *((void **)this + 578));
  *((void *)this + 577) = v4;
  double result = 0.0;
  *((_OWORD *)this + 289) = 0u;
  return result;
}

BOOL sub_100AF88A8(uint64_t a1, char a2, char a3)
{
  if (!*(unsigned char *)a1) {
    return 0;
  }
  if (a3)
  {
    if (a2) {
      return 1;
    }
    goto LABEL_7;
  }
  int v4 = *(unsigned __int8 *)(a1 + 19);
  BOOL result = *(unsigned char *)(a1 + 19) != 0;
  if (v4 && (a2 & 1) == 0)
  {
LABEL_7:
    if (*(unsigned char *)(a1 + 128) || *(void *)(a1 + 120)) {
      return 1;
    }
    if (*(unsigned char *)(a1 + 12))
    {
      if (!*(unsigned char *)(a1 + 13)) {
        return *(unsigned char *)(a1 + 14) != 0;
      }
      return 1;
    }
    return 0;
  }
  return result;
}

void DataServiceController::adjustSlicesAppsDb(uint64_t **this, int a2)
{
  int64x2_t v70 = 0uLL;
  v71[0] = 0;
  if ((((uint64_t (*)(uint64_t **))(*this)[275])(this) & 1) == 0)
  {
    uint64_t v5 = (void *)v70.i64[1];
    goto LABEL_28;
  }
  if (a2)
  {
    LODWORD(__p) = 6005;
    uint64_t v4 = v70.i64[1];
    if (v70.i64[1] >= v71[0])
    {
      uint64_t v6 = (void *)sub_100B06E1C(&v70, (int *)&__p, off_101A3A088);
      goto LABEL_24;
    }
    *(void *)v70.i64[1] = 6005;
    sub_100058DB0((void *)(v4 + 8), "com.apple.facetime");
  }
  else
  {
    uint64_t v4 = v70.i64[1];
    if (v70.i64[1] >= v71[0])
    {
      uint64_t v7 = (v70.i64[1] - v70.i64[0]) >> 5;
      if ((unint64_t)(v7 + 1) >> 59) {
        sub_10006A748();
      }
      unint64_t v8 = (v71[0] - v70.i64[0]) >> 4;
      if (v8 <= v7 + 1) {
        unint64_t v8 = v7 + 1;
      }
      if (v71[0] - v70.i64[0] >= 0x7FFFFFFFFFFFFFE0uLL) {
        unint64_t v9 = 0x7FFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v9 = v8;
      }
      v75 = v71;
      if (v9) {
        unint64_t v9 = (unint64_t)sub_1000509C0(v9);
      }
      else {
        uint64_t v10 = 0;
      }
      v11 = (void *)(v9 + 32 * v7);
      __p = (void *)v9;
      v73.i64[0] = (uint64_t)v11;
      v73.i64[1] = (uint64_t)v11;
      unint64_t v74 = v9 + 32 * v10;
      void *v11 = 9000;
      sub_100058DB0(v11 + 1, "com.apple.facetime");
      uint64_t v12 = v73.i64[0];
      uint64_t v6 = (void *)(v73.i64[1] + 32);
      v73.i64[1] += 32;
      uint64_t v13 = v70.i64[1];
      uint64_t v14 = v70.i64[0];
      if (v70.i64[1] == v70.i64[0])
      {
        int64x2_t v17 = vdupq_n_s64(v70.u64[1]);
      }
      else
      {
        do
        {
          uint64_t v15 = *(void *)(v13 - 32);
          v13 -= 32;
          *(void *)(v12 - 32) = v15;
          v12 -= 32;
          long long v16 = *(_OWORD *)(v13 + 8);
          *(void *)(v12 + 24) = *(void *)(v13 + 24);
          *(_OWORD *)(v12 + 8) = v16;
          *(void *)(v13 + 16) = 0;
          *(void *)(v13 + 24) = 0;
          *(void *)(v13 + 8) = 0;
        }
        while (v13 != v14);
        int64x2_t v17 = v70;
        uint64_t v6 = (void *)v73.i64[1];
      }
      v70.i64[0] = v12;
      v70.i64[1] = (uint64_t)v6;
      int64x2_t v73 = v17;
      unint64_t v18 = v71[0];
      v71[0] = v74;
      unint64_t v74 = v18;
      __p = (void *)v17.i64[0];
      sub_100255B70((uint64_t)&__p);
      goto LABEL_24;
    }
    *(void *)v70.i64[1] = 9000;
    sub_100058DB0((void *)(v4 + 8), "com.apple.facetime");
  }
  uint64_t v6 = (void *)(v4 + 32);
LABEL_24:
  v70.i64[1] = (uint64_t)v6;
  LODWORD(__p) = 6014;
  if ((unint64_t)v6 >= v71[0])
  {
    uint64_t v5 = (void *)sub_100B06E1C(&v70, (int *)&__p, off_101A3A090);
  }
  else
  {
    *uint64_t v6 = 6014;
    sub_100058DB0(v6 + 1, "com.apple.gamed");
    uint64_t v5 = v6 + 4;
  }
  v70.i64[1] = (uint64_t)v5;
LABEL_28:
  if ((unint64_t)v5 >= v71[0])
  {
    uint64_t v20 = ((uint64_t)v5 - v70.i64[0]) >> 5;
    if ((unint64_t)(v20 + 1) >> 59) {
      sub_10006A748();
    }
    unint64_t v21 = (v71[0] - v70.i64[0]) >> 4;
    if (v21 <= v20 + 1) {
      unint64_t v21 = v20 + 1;
    }
    if (v71[0] - v70.i64[0] >= 0x7FFFFFFFFFFFFFE0uLL) {
      unint64_t v22 = 0x7FFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v22 = v21;
    }
    v75 = v71;
    if (v22) {
      unint64_t v22 = (unint64_t)sub_1000509C0(v22);
    }
    else {
      uint64_t v23 = 0;
    }
    v24 = (void *)(v22 + 32 * v20);
    __p = (void *)v22;
    v73.i64[0] = (uint64_t)v24;
    v73.i64[1] = (uint64_t)v24;
    unint64_t v74 = v22 + 32 * v23;
    void *v24 = 9001;
    sub_100058DB0(v24 + 1, "com.apple.tv");
    uint64_t v25 = v73.i64[0];
    v19 = (void *)(v73.i64[1] + 32);
    v73.i64[1] += 32;
    uint64_t v26 = v70.i64[1];
    uint64_t v27 = v70.i64[0];
    if (v70.i64[1] == v70.i64[0])
    {
      int64x2_t v30 = vdupq_n_s64(v70.u64[1]);
    }
    else
    {
      do
      {
        uint64_t v28 = *(void *)(v26 - 32);
        v26 -= 32;
        *(void *)(v25 - 32) = v28;
        v25 -= 32;
        long long v29 = *(_OWORD *)(v26 + 8);
        *(void *)(v25 + 24) = *(void *)(v26 + 24);
        *(_OWORD *)(v25 + 8) = v29;
        *(void *)(v26 + 16) = 0;
        *(void *)(v26 + 24) = 0;
        *(void *)(v26 + 8) = 0;
      }
      while (v26 != v27);
      int64x2_t v30 = v70;
      v19 = (void *)v73.i64[1];
    }
    v70.i64[0] = v25;
    v70.i64[1] = (uint64_t)v19;
    int64x2_t v73 = v30;
    unint64_t v31 = v71[0];
    v71[0] = v74;
    unint64_t v74 = v31;
    __p = (void *)v30.i64[0];
    sub_100255B70((uint64_t)&__p);
  }
  else
  {
    *uint64_t v5 = 9001;
    sub_100058DB0(v5 + 1, "com.apple.tv");
    v19 = v5 + 4;
  }
  v70.i64[1] = (uint64_t)v19;
  if ((unint64_t)v19 >= v71[0])
  {
    uint64_t v33 = ((uint64_t)v19 - v70.i64[0]) >> 5;
    if ((unint64_t)(v33 + 1) >> 59) {
      sub_10006A748();
    }
    unint64_t v34 = (v71[0] - v70.i64[0]) >> 4;
    if (v34 <= v33 + 1) {
      unint64_t v34 = v33 + 1;
    }
    if (v71[0] - v70.i64[0] >= 0x7FFFFFFFFFFFFFE0uLL) {
      unint64_t v35 = 0x7FFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v35 = v34;
    }
    v75 = v71;
    if (v35) {
      unint64_t v35 = (unint64_t)sub_1000509C0(v35);
    }
    else {
      uint64_t v36 = 0;
    }
    v37 = (void *)(v35 + 32 * v33);
    __p = (void *)v35;
    v73.i64[0] = (uint64_t)v37;
    v73.i64[1] = (uint64_t)v37;
    unint64_t v74 = v35 + 32 * v36;
    void *v37 = 6011;
    sub_100058DB0(v37 + 1, "com.apple.Music");
    uint64_t v38 = v73.i64[0];
    uint64_t v32 = v73.i64[1] + 32;
    v73.i64[1] += 32;
    uint64_t v39 = v70.i64[1];
    uint64_t v40 = v70.i64[0];
    if (v70.i64[1] == v70.i64[0])
    {
      int64x2_t v43 = vdupq_n_s64(v70.u64[1]);
    }
    else
    {
      do
      {
        uint64_t v41 = *(void *)(v39 - 32);
        v39 -= 32;
        *(void *)(v38 - 32) = v41;
        v38 -= 32;
        long long v42 = *(_OWORD *)(v39 + 8);
        *(void *)(v38 + 24) = *(void *)(v39 + 24);
        *(_OWORD *)(v38 + 8) = v42;
        *(void *)(v39 + 16) = 0;
        *(void *)(v39 + 24) = 0;
        *(void *)(v39 + 8) = 0;
      }
      while (v39 != v40);
      int64x2_t v43 = v70;
      uint64_t v32 = v73.i64[1];
    }
    v70.i64[0] = v38;
    v70.i64[1] = v32;
    int64x2_t v73 = v43;
    unint64_t v44 = v71[0];
    v71[0] = v74;
    unint64_t v74 = v44;
    __p = (void *)v43.i64[0];
    sub_100255B70((uint64_t)&__p);
  }
  else
  {
    void *v19 = 6011;
    sub_100058DB0(v19 + 1, "com.apple.Music");
    uint64_t v32 = (uint64_t)(v19 + 4);
  }
  v70.i64[1] = v32;
  for (i = (uint64_t *)v70.i64[0]; i != (uint64_t *)v32; i = (uint64_t *)(v46 + 3))
  {
    uint64_t v47 = *i;
    v46 = (void **)(i + 1);
    sub_100AF91D0((uint64_t)this, v47, v46, 1);
  }
  uint64_t v48 = 0;
  v49 = this + 580;
  v50 = (void **)(this + 581);
  do
  {
    v51 = off_101A3A098[v48];
    sub_100058DB0(&__p, v51);
    v52 = sub_100046F68((uint64_t)(this + 580), &__p);
    if (v73.i8[15] < 0) {
      operator delete(__p);
    }
    if (v50 != v52)
    {
      sub_100058DB0(&__p, v51);
      sub_1000EA6A0(this + 601, &__p, (uint64_t)&__p);
      if (v73.i8[15] < 0) {
        operator delete(__p);
      }
    }
    ++v48;
  }
  while (v48 != 13);
  v53 = this[601];
  v54 = (uint64_t *)(this + 602);
  if (v53 != (uint64_t *)(this + 602))
  {
    v69 = this + 589;
    v68 = this + 583;
    do
    {
      if (v50 != sub_100046F68((uint64_t)v49, (void **)v53 + 4))
      {
        unint64_t v76 = 9000;
        __p = &v76;
        v55 = sub_100B0ADEC(v69, &v76, (uint64_t)&unk_10144E20E, (uint64_t **)&__p);
        sub_100046BAC((uint64_t **)v55 + 5, (void **)v53 + 4, (uint64_t)(v53 + 4));
        sub_100B076CC(v68, &v76, (uint64_t *)&v76);
        __p = v53 + 4;
        if (!*((unsigned char *)sub_100B0844C(v49, (void **)v53 + 4, (uint64_t)&unk_10144E20E, (long long **)&__p) + 80))
        {
          int64x2_t v73 = 0uLL;
          __p = &v73;
          v77 = (long long *)(v53 + 4);
          v56 = sub_100B0844C(v49, (void **)v53 + 4, (uint64_t)&unk_10144E20E, &v77);
          sub_100AF94D0((uint64_t)(v56 + 7), &__p);
          sub_1000346F8((uint64_t)&__p, v73.i64[0]);
        }
        __p = v53 + 4;
        v57 = sub_100B0844C(v49, (void **)v53 + 4, (uint64_t)&unk_10144E20E, (long long **)&__p);
        if (!*((unsigned char *)v57 + 80)) {
          goto LABEL_95;
        }
        sub_100B076CC((uint64_t **)v57 + 7, &v76, (uint64_t *)&v76);
        __p = v53 + 4;
        if (!*((unsigned char *)sub_100B0844C(v49, (void **)v53 + 4, (uint64_t)&unk_10144E20E, (long long **)&__p) + 160))
        {
          int64x2_t v73 = 0uLL;
          __p = &v73;
          v77 = (long long *)(v53 + 4);
          v58 = sub_100B0844C(v49, (void **)v53 + 4, (uint64_t)&unk_10144E20E, &v77);
          sub_100AF94D0((uint64_t)(v58 + 17), &__p);
          sub_1000346F8((uint64_t)&__p, v73.i64[0]);
        }
        uint64_t v59 = qword_101B0FE38;
        if ((uint64_t *)qword_101B0FE38 != &qword_101B0FE40)
        {
          while (1)
          {
            int v60 = *(unsigned __int16 *)(v59 + 26);
            __p = v53 + 4;
            v61 = sub_100B0844C(v49, (void **)v53 + 4, (uint64_t)&unk_10144E20E, (long long **)&__p);
            if (!*((unsigned char *)v61 + 160)) {
              break;
            }
            LODWORD(__p) = v60;
            sub_100A08300((uint64_t **)v61 + 17, (unsigned int *)&__p, &__p);
            v62 = *(uint64_t **)(v59 + 8);
            if (v62)
            {
              do
              {
                v63 = v62;
                v62 = (uint64_t *)*v62;
              }
              while (v62);
            }
            else
            {
              do
              {
                v63 = *(uint64_t **)(v59 + 16);
                BOOL v64 = *v63 == v59;
                uint64_t v59 = (uint64_t)v63;
              }
              while (!v64);
            }
            uint64_t v59 = (uint64_t)v63;
            if (v63 == &qword_101B0FE40) {
              goto LABEL_86;
            }
          }
LABEL_95:
          sub_10016C840();
        }
LABEL_86:
        __p = v53 + 4;
        v65 = sub_100B0844C(v49, (void **)v53 + 4, (uint64_t)&unk_10144E20E, (long long **)&__p);
        if (!*((unsigned char *)v65 + 160)) {
          goto LABEL_95;
        }
        LODWORD(__p) = 0;
        sub_100A08300((uint64_t **)v65 + 17, (unsigned int *)&__p, &__p);
      }
      v66 = (uint64_t *)v53[1];
      if (v66)
      {
        do
        {
          v67 = v66;
          v66 = (uint64_t *)*v66;
        }
        while (v66);
      }
      else
      {
        do
        {
          v67 = (uint64_t *)v53[2];
          BOOL v64 = *v67 == (void)v53;
          v53 = v67;
        }
        while (!v64);
      }
      v53 = v67;
    }
    while (v67 != v54);
  }
  __p = &v70;
  sub_100B05F98((void ***)&__p);
}

void sub_100AF9114(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, char *a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  a14 = &a11;
  sub_100B05F98((void ***)&a14);
  _Unwind_Resume(a1);
}

void sub_100AF91D0(uint64_t a1, uint64_t a2, void **a3, int a4)
{
  unint64_t v26 = a2;
  if (a4)
  {
    v24 = 0;
    uint64_t v25 = 0;
    uint64_t v23 = (uint64_t *)&v24;
    uint64_t v6 = *(void **)(a1 + 4712);
    uint64_t v7 = (void *)(a1 + 4720);
    if (v6 != (void *)(a1 + 4720))
    {
      do
      {
        if (v6[4] != v26) {
          sub_100B076CC(&v23, v6 + 4, v6 + 4);
        }
        unint64_t v8 = (void *)v6[1];
        if (v8)
        {
          do
          {
            unint64_t v9 = v8;
            unint64_t v8 = (void *)*v8;
          }
          while (v8);
        }
        else
        {
          do
          {
            unint64_t v9 = (void *)v6[2];
            BOOL v10 = *v9 == (void)v6;
            uint64_t v6 = v9;
          }
          while (!v10);
        }
        uint64_t v6 = v9;
      }
      while (v9 != v7);
      v11 = v23;
      if (v23 != (uint64_t *)&v24)
      {
        do
        {
          unint64_t v21 = (unsigned int *)(v11 + 4);
          uint64_t v12 = sub_100B0ADEC((uint64_t **)(a1 + 4712), (unint64_t *)v11 + 4, (uint64_t)&unk_10144E20E, (uint64_t **)&v21);
          sub_1000E9358((uint64_t **)v12 + 5, a3);
          uint64_t v13 = (uint64_t *)v11[1];
          if (v13)
          {
            do
            {
              uint64_t v14 = v13;
              uint64_t v13 = (uint64_t *)*v13;
            }
            while (v13);
          }
          else
          {
            do
            {
              uint64_t v14 = (uint64_t *)v11[2];
              BOOL v10 = *v14 == (void)v11;
              v11 = v14;
            }
            while (!v10);
          }
          v11 = v14;
        }
        while (v14 != (uint64_t *)&v24);
      }
    }
    sub_1000346F8((uint64_t)&v23, v24);
  }
  uint64_t v23 = (uint64_t *)&v26;
  uint64_t v15 = sub_100B0ADEC((uint64_t **)(a1 + 4712), &v26, (uint64_t)&unk_10144E20E, &v23);
  sub_100046BAC((uint64_t **)v15 + 5, a3, (uint64_t)a3);
  sub_100B076CC((uint64_t **)(a1 + 4664), &v26, (uint64_t *)&v26);
  v24 = 0;
  uint64_t v25 = 0;
  uint64_t v23 = (uint64_t *)&v24;
  sub_100B076CC(&v23, &v26, (uint64_t *)&v26);
  long long v16 = (uint64_t **)(a1 + 4640);
  unint64_t v21 = (unsigned int *)a3;
  int64x2_t v17 = sub_100B0844C(v16, a3, (uint64_t)&unk_10144E20E, (long long **)&v21);
  unint64_t v18 = (uint64_t **)(v17 + 7);
  if (*((unsigned char *)v17 + 80))
  {
    if (v18 != &v23) {
      sub_100B06F5C(v18, v23, &v24);
    }
  }
  else
  {
    sub_1001E0DB4((uint64_t *)v18, (uint64_t)&v23);
    *((unsigned char *)v17 + 80) = 1;
  }
  v22[0] = 0;
  v22[1] = 0;
  unint64_t v21 = (unsigned int *)v22;
  LODWORD(v27) = 100;
  do
  {
    sub_100A08300((uint64_t **)&v21, (unsigned int *)&v27, &v27);
    LODWORD(v27) = v27 + 100;
  }
  while (v27 < 0x3E8);
  uint64_t v27 = a3;
  v19 = sub_100B0844C(v16, a3, (uint64_t)&unk_10144E20E, (long long **)&v27);
  uint64_t v20 = (uint64_t **)(v19 + 17);
  if (*((unsigned char *)v19 + 160))
  {
    if (v20 != (uint64_t **)&v21) {
      sub_100B07150(v20, v21, (unsigned int *)v22);
    }
  }
  else
  {
    sub_100B073B4((uint64_t *)v20, (uint64_t)&v21);
    *((unsigned char *)v19 + 160) = 1;
  }
  sub_1000346F8((uint64_t)&v21, v22[0]);
  sub_1000346F8((uint64_t)&v23, v24);
}

void sub_100AF9498(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11, uint64_t a12, char a13, void *a14)
{
}

uint64_t sub_100AF94D0(uint64_t a1, void *a2)
{
  if (*(unsigned char *)(a1 + 24))
  {
    sub_10041F480(a1, a2);
  }
  else
  {
    *(void *)a1 = *a2;
    v3 = a2 + 1;
    uint64_t v4 = a2[1];
    *(void *)(a1 + 8) = v4;
    uint64_t v5 = a1 + 8;
    uint64_t v6 = a2[2];
    *(void *)(a1 + 16) = v6;
    if (v6)
    {
      *(void *)(v4 + 16) = v5;
      *a2 = v3;
      void *v3 = 0;
      a2[2] = 0;
    }
    else
    {
      *(void *)a1 = v5;
    }
    *(unsigned char *)(a1 + 24) = 1;
  }
  return a1;
}

BOOL DataServiceController::checkSlicingDnnValidity_sync(uint64_t a1, int a2, const std::string *a3)
{
  std::string::size_type size = HIBYTE(a3->__r_.__value_.__r.__words[2]);
  if ((size & 0x80u) != 0) {
    std::string::size_type size = a3->__r_.__value_.__l.__size_;
  }
  if (!size) {
    return 1;
  }
  uint64_t v4 = a3;
  uint64_t v6 = a1 + 4616;
  int v24 = a2;
  uint64_t v7 = sub_10003B194(a1 + 4616, &v24);
  unint64_t v8 = (unsigned __int8 *)(*v7 + 256);
  int v9 = *(char *)(*v7 + 279);
  if (v9 >= 0) {
    size_t v10 = *(unsigned __int8 *)(*v7 + 279);
  }
  else {
    size_t v10 = *(void *)(*v7 + 264);
  }
  if (v10 == strlen(kWildCardDnn))
  {
    v11 = v9 >= 0 ? v8 : *(unsigned __int8 **)v8;
    if (!memcmp(v11, kWildCardDnn, v10))
    {
      int v25 = a2;
      uint64_t v23 = sub_10003B194(v6, &v25);
      std::string::operator=((std::string *)(*v23 + 304), v4);
      return 1;
    }
  }
  uint64_t v12 = HIBYTE(v4->__r_.__value_.__r.__words[2]);
  if ((v12 & 0x80u) == 0) {
    std::string::size_type v13 = HIBYTE(v4->__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type v13 = v4->__r_.__value_.__l.__size_;
  }
  if (v13 != v10) {
    return 0;
  }
  if (v9 >= 0) {
    uint64_t v14 = v8;
  }
  else {
    uint64_t v14 = *(unsigned __int8 **)v8;
  }
  if ((v12 & 0x80) != 0) {
    return memcmp(v4->__r_.__value_.__l.__data_, v14, v4->__r_.__value_.__l.__size_) == 0;
  }
  if (!*((unsigned char *)&v4->__r_.__value_.__s + 23)) {
    return 1;
  }
  uint64_t v15 = v12 - 1;
  do
  {
    int v17 = v4->__r_.__value_.__s.__data_[0];
    uint64_t v4 = (const std::string *)((char *)v4 + 1);
    int v16 = v17;
    int v19 = *v14++;
    int v18 = v19;
    BOOL v21 = v15-- != 0;
    BOOL result = v16 == v18;
  }
  while (v16 == v18 && v21);
  return result;
}

BOOL non-virtual thunk to'DataServiceController::checkSlicingDnnValidity_sync(uint64_t a1, int a2, const std::string *a3)
{
  return DataServiceController::checkSlicingDnnValidity_sync(a1 - 80, a2, a3);
}

BOOL DataServiceController::validSlicingOsId_sync(uint64_t a1, int a2, void *a3)
{
  int v10 = a2;
  uint64_t v4 = sub_10003B194(a1 + 4616, &v10);
  uint64_t v5 = *v4;
  if (!*(unsigned char *)(*v4 + 208)) {
    return 1;
  }
  uint64_t v6 = *(void *)(v5 + 209);
  uint64_t v7 = *(void *)(v5 + 217);
  return *a3 == v6 && a3[1] == v7;
}

BOOL non-virtual thunk to'DataServiceController::validSlicingOsId_sync(uint64_t a1, int a2, void *a3)
{
  return DataServiceController::validSlicingOsId_sync(a1 - 80, a2, a3);
}

BOOL DataServiceController::slicingOsId_sync(uint64_t a1, int a2, _OWORD *a3)
{
  int v7 = a2;
  uint64_t v4 = sub_10003B194(a1 + 4616, &v7);
  int v5 = *(unsigned __int8 *)(*v4 + 208);
  if (*(unsigned char *)(*v4 + 208)) {
    *a3 = *(_OWORD *)(*v4 + 209);
  }
  return v5 != 0;
}

BOOL non-virtual thunk to'DataServiceController::slicingOsId_sync(uint64_t a1, int a2, _OWORD *a3)
{
  int v7 = a2;
  uint64_t v4 = sub_10003B194(a1 + 4536, &v7);
  int v5 = *(unsigned __int8 *)(*v4 + 208);
  if (*(unsigned char *)(*v4 + 208)) {
    *a3 = *(_OWORD *)(*v4 + 209);
  }
  return v5 != 0;
}

BOOL sub_100AF97D0(uint64_t a1, int a2, unint64_t a3)
{
  uint64_t v4 = a1 + 4616;
  int v13 = a2;
  uint64_t v5 = *sub_10003B194(a1 + 4616, &v13);
  if (a3 == -1 && *(unsigned char *)(v4 + 354)) {
    return 1;
  }
  uint64_t v6 = *(void **)(v5 + 336);
  if (!v6) {
    return 1;
  }
  uint64_t v7 = v5 + 336;
  uint64_t v8 = v5 + 336;
  do
  {
    unint64_t v9 = v6[4];
    BOOL v10 = v9 >= a3;
    if (v9 >= a3) {
      v11 = v6;
    }
    else {
      v11 = v6 + 1;
    }
    if (v10) {
      uint64_t v8 = (uint64_t)v6;
    }
    uint64_t v6 = (void *)*v11;
  }
  while (*v11);
  return v8 == v7 || *(void *)(v8 + 32) > a3 || !*(_DWORD *)(v8 + 44) || *(unsigned char *)(v8 + 40) != 0;
}

void DataServiceController::dumpSliceData_sync(DataServiceController *this)
{
  v253 = (char *)this + 4776;
  v2 = *((void *)this + 5);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I DATA:: ========== Slicing: ==========", buf, 2u);
    v2 = *((void *)this + 5);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = asStringBool(v253[196]);
    *(_DWORD *)buf = 136315138;
    *(void *)&buf[4] = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I DATA:: internalOrCarrierBuild: %s", buf, 0xCu);
    v2 = *((void *)this + 5);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    int v4 = (*(uint64_t (**)(DataServiceController *))(*(void *)this + 1088))(this);
    int v5 = (*(uint64_t (**)(DataServiceController *))(*(void *)this + 1088))(this);
    uint64_t v6 = (*(uint64_t (**)(DataServiceController *))(*(void *)this + 1088))(this);
    char v7 = (*(uint64_t (**)(DataServiceController *, uint64_t))(*(void *)this + 1040))(this, v6);
    BOOL v8 = DataServiceController::SlicesDataContainer::configured((uint64_t)this + 4616, v4, v5, v7);
    uint64_t v9 = asStringBool(v8);
    *(_DWORD *)buf = 136315138;
    *(void *)&buf[4] = v9;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I DATA:: configured(1): %s", buf, 0xCu);
    v2 = *((void *)this + 5);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v10 = asStringBool(v253[104]);
    *(_DWORD *)buf = 136315138;
    *(void *)&buf[4] = v10;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I DATA:: managedConfigObserverRegistered=%s", buf, 0xCu);
    v2 = *((void *)this + 5);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v11 = asStringBool(v253[105]);
    *(_DWORD *)buf = 136315138;
    *(void *)&buf[4] = v11;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I DATA:: appObserverRegistered=%s", buf, 0xCu);
    v2 = *((void *)this + 5);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v12 = asStringBool();
    *(_DWORD *)buf = 136315138;
    *(void *)&buf[4] = v12;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I DATA:: activeSliceStatus: %s", buf, 0xCu);
    v2 = *((void *)this + 5);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v13 = asStringBool(*((void *)this + 613) != 0);
    *(_DWORD *)buf = 136446210;
    *(void *)&buf[4] = v13;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I DATA:: vpnManager: %{public}s", buf, 0xCu);
    v2 = *((void *)this + 5);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v14 = asStringBool(v253[144]);
    *(_DWORD *)buf = 136315138;
    *(void *)&buf[4] = v14;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I DATA:: vpnActive: %s", buf, 0xCu);
    v2 = *((void *)this + 5);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v15 = asStringBool(v253[145]);
    *(_DWORD *)buf = 136315138;
    *(void *)&buf[4] = v15;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I DATA:: vpnUsesPolicyBasedRouting: %s", buf, 0xCu);
    v2 = *((void *)this + 5);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v16 = asStringBool(v253[192]);
    *(_DWORD *)buf = 136315138;
    *(void *)&buf[4] = v16;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I DATA:: ftCallStarting: %s", buf, 0xCu);
    v2 = *((void *)this + 5);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v17 = asStringBool(v253[193]);
    *(_DWORD *)buf = 136315138;
    *(void *)&buf[4] = v17;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I DATA:: ftCallActive: %s", buf, 0xCu);
    v2 = *((void *)this + 5);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    int v18 = *((_DWORD *)this + 1221);
    *(_DWORD *)buf = 67109120;
    *(_DWORD *)&buf[4] = v18;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I DATA:: screenLockRegToken: %d", buf, 8u);
    v2 = *((void *)this + 5);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    int v19 = *((_DWORD *)this + 1222);
    *(_DWORD *)buf = 67109120;
    *(_DWORD *)&buf[4] = v19;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I DATA:: slicingLLPHSStateNotifyToken: %d", buf, 8u);
    v2 = *((void *)this + 5);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    int v20 = *((_DWORD *)this + 1223);
    *(_DWORD *)buf = 67109120;
    *(_DWORD *)&buf[4] = v20;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I DATA:: slicingInterfacesActiveStateNotifyToken: %d", buf, 8u);
    v2 = *((void *)this + 5);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v21 = asStringBool(v253[194]);
    *(_DWORD *)buf = 136315138;
    *(void *)&buf[4] = v21;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I DATA:: supervisedDevice: %s", buf, 0xCu);
    v2 = *((void *)this + 5);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v22 = asStringBool(v253[195]);
    *(_DWORD *)buf = 136315138;
    *(void *)&buf[4] = v22;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I DATA:: managedDevice: %s", buf, 0xCu);
  }
  uint64_t v23 = (void *)*((void *)this + 592);
  if (v23 && v23[2])
  {
    int v24 = *((void *)this + 5);
    if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "#I DATA:: genreNames:", buf, 2u);
      uint64_t v23 = (void *)*((void *)this + 592);
    }
    uint64_t v27 = (void *)*v23;
    int v25 = v23 + 1;
    unint64_t v26 = v27;
    if (v27 != v25)
    {
      do
      {
        uint64_t v28 = *((void *)this + 5);
        if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
        {
          long long v29 = v26 + 5;
          if (*((char *)v26 + 63) < 0) {
            long long v29 = (void *)*v29;
          }
          uint64_t v30 = v26[4];
          *(_DWORD *)buf = 134218242;
          *(void *)&buf[4] = v30;
          *(_WORD *)&buf[12] = 2080;
          *(void *)&buf[14] = v29;
          _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "#I DATA:: \t%lu\t%s", buf, 0x16u);
        }
        unint64_t v31 = (void *)v26[1];
        if (v31)
        {
          do
          {
            uint64_t v32 = v31;
            unint64_t v31 = (void *)*v31;
          }
          while (v31);
        }
        else
        {
          do
          {
            uint64_t v32 = (void *)v26[2];
            BOOL v33 = *v32 == (void)v26;
            unint64_t v26 = v32;
          }
          while (!v33);
        }
        unint64_t v26 = v32;
      }
      while (v32 != v25);
    }
  }
  if (*((void *)this + 626))
  {
    unint64_t v34 = *((void *)this + 5);
    if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "#I DATA:: internalSliceAppCategory:", buf, 2u);
    }
    unint64_t v35 = (DataServiceController *)*((void *)this + 624);
    if (v35 != (DataServiceController *)((char *)this + 5000))
    {
      do
      {
        uint64_t v36 = *((void *)this + 5);
        if (os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT))
        {
          v37 = (void *)((char *)v35 + 48);
          if (*((char *)v35 + 71) < 0) {
            v37 = (void *)*v37;
          }
          uint64_t v38 = (void *)((char *)v35 + 72);
          if (*((char *)v35 + 95) < 0) {
            uint64_t v38 = (void *)*v38;
          }
          uint64_t v39 = (void *)((char *)v35 + 96);
          if (*((char *)v35 + 119) < 0) {
            uint64_t v39 = (void *)*v39;
          }
          int v40 = *((_DWORD *)v35 + 8);
          uint64_t v41 = *((void *)v35 + 5);
          *(_DWORD *)buf = 67110146;
          *(_DWORD *)&buf[4] = v40;
          *(_WORD *)&buf[8] = 2082;
          *(void *)&buf[10] = v37;
          *(_WORD *)&buf[18] = 2082;
          *(void *)&buf[20] = v38;
          *(_WORD *)&buf[28] = 2082;
          *(void *)&buf[30] = v39;
          __int16 v262 = 2048;
          uint64_t v263 = v41;
          _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_DEFAULT, "#I DATA:: \t\tpid=%d procName=%{public}s bundleId=%{public}s uuid=%{public}s category=%llu", buf, 0x30u);
        }
        long long v42 = (DataServiceController *)*((void *)v35 + 1);
        if (v42)
        {
          do
          {
            int64x2_t v43 = v42;
            long long v42 = *(DataServiceController **)v42;
          }
          while (v42);
        }
        else
        {
          do
          {
            int64x2_t v43 = (DataServiceController *)*((void *)v35 + 2);
            BOOL v33 = *(void *)v43 == (void)v35;
            unint64_t v35 = v43;
          }
          while (!v33);
        }
        unint64_t v35 = v43;
      }
      while (v43 != (DataServiceController *)((char *)this + 5000));
    }
  }
  unint64_t v44 = (DataServiceController *)*((void *)this + 580);
  if (v44 != (DataServiceController *)((char *)this + 4648))
  {
    do
    {
      v45 = *((void *)this + 5);
      if (os_log_type_enabled(v45, OS_LOG_TYPE_DEFAULT))
      {
        v46 = (void *)((char *)v44 + 32);
        if (*((char *)v44 + 55) < 0) {
          v46 = (void *)*v46;
        }
        *(_DWORD *)buf = 136446210;
        *(void *)&buf[4] = v46;
        _os_log_impl((void *)&_mh_execute_header, v45, OS_LOG_TYPE_DEFAULT, "#I DATA:: \tapp: %{public}s", buf, 0xCu);
      }
      if (*((unsigned char *)v44 + 128))
      {
        uint64_t v47 = *((void *)this + 5);
        if (os_log_type_enabled(v47, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v48 = rest::asString();
          if (!*((unsigned char *)v44 + 128)) {
            sub_10016C840();
          }
          int v49 = *((_DWORD *)v44 + 31);
          *(_DWORD *)buf = 136315394;
          *(void *)&buf[4] = v48;
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = v49;
          _os_log_impl((void *)&_mh_execute_header, v47, OS_LOG_TYPE_DEFAULT, "#I DATA::     \tappRunningStatus: %s (%d)", buf, 0x12u);
        }
      }
      if (*((unsigned char *)v44 + 121))
      {
        v50 = *((void *)this + 5);
        if (os_log_type_enabled(v50, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v51 = asStringBool(*((unsigned char *)v44 + 120));
          *(_DWORD *)buf = 136315138;
          *(void *)&buf[4] = v51;
          _os_log_impl((void *)&_mh_execute_header, v50, OS_LOG_TYPE_DEFAULT, "#I DATA::     \tappsBackgroundNetworkMode: %s", buf, 0xCu);
        }
      }
      if (*((unsigned char *)v44 + 112))
      {
        v52 = *((void *)this + 5);
        if (os_log_type_enabled(v52, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v52, OS_LOG_TYPE_DEFAULT, "#I DATA:: \t\tappUUids:", buf, 2u);
          if (!*((unsigned char *)v44 + 112)) {
            sub_10016C840();
          }
        }
        v53 = (void *)*((void *)v44 + 11);
        if (v53 != (void *)((char *)v44 + 96))
        {
          do
          {
            v54 = *((void *)this + 5);
            if (os_log_type_enabled(v54, OS_LOG_TYPE_DEFAULT))
            {
              v55 = v53 + 4;
              if (*((char *)v53 + 55) < 0) {
                v55 = (void *)*v55;
              }
              *(_DWORD *)buf = 136446210;
              *(void *)&buf[4] = v55;
              _os_log_impl((void *)&_mh_execute_header, v54, OS_LOG_TYPE_DEFAULT, "#I DATA::     \t\tuuid %{public}s", buf, 0xCu);
            }
            v56 = (void *)v53[1];
            if (v56)
            {
              do
              {
                v57 = v56;
                v56 = (void *)*v56;
              }
              while (v56);
            }
            else
            {
              do
              {
                v57 = (void *)v53[2];
                BOOL v33 = *v57 == (void)v53;
                v53 = v57;
              }
              while (!v33);
            }
            v53 = v57;
          }
          while (v57 != (void *)((char *)v44 + 96));
        }
      }
      if (*((unsigned char *)v44 + 80))
      {
        v58 = (void *)*((void *)v44 + 7);
        if (v58 != (void *)((char *)v44 + 64))
        {
          do
          {
            uint64_t v59 = *((void *)this + 5);
            if (os_log_type_enabled(v59, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v60 = v58[4];
              *(_DWORD *)buf = 134217984;
              *(void *)&buf[4] = v60;
              _os_log_impl((void *)&_mh_execute_header, v59, OS_LOG_TYPE_DEFAULT, "#I DATA::     \tgenre: %llu", buf, 0xCu);
            }
            v61 = (void *)v58[1];
            if (v61)
            {
              do
              {
                v62 = v61;
                v61 = (void *)*v61;
              }
              while (v61);
            }
            else
            {
              do
              {
                v62 = (void *)v58[2];
                BOOL v33 = *v62 == (void)v58;
                v58 = v62;
              }
              while (!v33);
            }
            v58 = v62;
          }
          while (v62 != (void *)((char *)v44 + 64));
        }
      }
      if (*((unsigned char *)v44 + 160))
      {
        v63 = (void *)*((void *)v44 + 17);
        if (v63 != (void *)((char *)v44 + 144))
        {
          do
          {
            BOOL v64 = *((void *)this + 5);
            if (os_log_type_enabled(v64, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v65 = *((unsigned int *)v63 + 7);
              *(_DWORD *)buf = 134217984;
              *(void *)&buf[4] = v65;
              _os_log_impl((void *)&_mh_execute_header, v64, OS_LOG_TYPE_DEFAULT, "#I DATA::     \ttrafficClass: %lu", buf, 0xCu);
            }
            v66 = (void *)v63[1];
            if (v66)
            {
              do
              {
                v67 = v66;
                v66 = (void *)*v66;
              }
              while (v66);
            }
            else
            {
              do
              {
                v67 = (void *)v63[2];
                BOOL v33 = *v67 == (void)v63;
                v63 = v67;
              }
              while (!v33);
            }
            v63 = v67;
          }
          while (v67 != (void *)((char *)v44 + 144));
        }
      }
      v68 = (DataServiceController *)*((void *)v44 + 1);
      if (v68)
      {
        do
        {
          v69 = v68;
          v68 = *(DataServiceController **)v68;
        }
        while (v68);
      }
      else
      {
        do
        {
          v69 = (DataServiceController *)*((void *)v44 + 2);
          BOOL v33 = *(void *)v69 == (void)v44;
          unint64_t v44 = v69;
        }
        while (!v33);
      }
      unint64_t v44 = v69;
    }
    while (v69 != (DataServiceController *)((char *)this + 4648));
  }
  if (*v253)
  {
    int64x2_t v70 = (void **)*((void *)this + 595);
    v71 = (void **)*((void *)this + 594);
    if (v70 != v71)
    {
      v72 = *((void *)this + 5);
      if (os_log_type_enabled(v72, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v72, OS_LOG_TYPE_DEFAULT, "#I DATA::     appsInfo:", buf, 2u);
        if (!*v253) {
          sub_10016C840();
        }
        v71 = (void **)*((void *)this + 594);
        int64x2_t v70 = (void **)*((void *)this + 595);
      }
      if (v71 != v70)
      {
        v256 = v70;
        do
        {
          uint64_t v73 = *((void *)this + 14);
          *(void *)&long long v259 = *((void *)this + 13);
          *((void *)&v259 + 1) = v73;
          if (v73) {
            atomic_fetch_add_explicit((atomic_ullong *volatile)(v73 + 8), 1uLL, memory_order_relaxed);
          }
          subscriber::makeSimSlotRange();
          if (*((void *)&v259 + 1)) {
            sub_10004D2C8(*((std::__shared_weak_count **)&v259 + 1));
          }
          v75 = *(int **)buf;
          unint64_t v74 = *(int **)&buf[8];
          if (*(void *)buf != *(void *)&buf[8])
          {
            unint64_t v76 = *(uint64_t (**)(void))&buf[16];
            while ((v76(*v75) & 1) == 0)
            {
              if (++v75 == v74)
              {
                v75 = v74;
                break;
              }
            }
            v77 = *(int **)&buf[8];
LABEL_135:
            while (v75 != v77)
            {
              if (DataServiceController::isAllowedApp(this, *v75, v71))
              {
                v79 = *((void *)this + 5);
                if (os_log_type_enabled(v79, OS_LOG_TYPE_DEFAULT))
                {
                  v80 = v71;
                  if (*((char *)v71 + 23) < 0) {
                    v80 = *v71;
                  }
                  uint64_t v81 = asStringBool(*((unsigned char *)v71 + 24));
                  *(_DWORD *)buf = 136446466;
                  *(void *)&buf[4] = v80;
                  *(_WORD *)&buf[12] = 2080;
                  *(void *)&buf[14] = v81;
                  _os_log_impl((void *)&_mh_execute_header, v79, OS_LOG_TYPE_DEFAULT, "#I DATA::     \tbundleId: %{public}s foreground: %s", buf, 0x16u);
                }
                v82 = v71[4];
                v83 = v71[5];
                while (v82 != v83)
                {
                  v84 = *((void *)this + 5);
                  if (os_log_type_enabled(v84, OS_LOG_TYPE_DEFAULT))
                  {
                    v85 = v82;
                    if (*((char *)v82 + 23) < 0) {
                      v85 = (void *)*v82;
                    }
                    *(_DWORD *)buf = 136446210;
                    *(void *)&buf[4] = v85;
                    _os_log_impl((void *)&_mh_execute_header, v84, OS_LOG_TYPE_DEFAULT, "#I DATA::     \tinterface: %{public}s", buf, 0xCu);
                  }
                  v86 = (void *)v82[3];
                  if (v86 != v82 + 4)
                  {
                    do
                    {
                      v87 = *((void *)this + 5);
                      if (os_log_type_enabled(v87, OS_LOG_TYPE_DEFAULT))
                      {
                        TrafficDescriptor::toString((uint64_t *)buf, (TrafficDescriptor *)(v86 + 4));
                        v88 = buf[23] >= 0 ? buf : *(unsigned char **)buf;
                        LODWORD(v259) = 136446210;
                        *(void *)((char *)&v259 + 4) = v88;
                        _os_log_impl((void *)&_mh_execute_header, v87, OS_LOG_TYPE_DEFAULT, "#I DATA::     \t\ttd: %{public}s", (uint8_t *)&v259, 0xCu);
                        if ((buf[23] & 0x80000000) != 0) {
                          operator delete(*(void **)buf);
                        }
                      }
                      v89 = (void *)v86[1];
                      if (v89)
                      {
                        do
                        {
                          v90 = v89;
                          v89 = (void *)*v89;
                        }
                        while (v89);
                      }
                      else
                      {
                        do
                        {
                          v90 = (void *)v86[2];
                          BOOL v33 = *v90 == (void)v86;
                          v86 = v90;
                        }
                        while (!v33);
                      }
                      v86 = v90;
                    }
                    while (v90 != v82 + 4);
                  }
                  v82 += 6;
                }
                break;
              }
              v78 = v75 + 1;
              v75 = v74;
              if (v78 != v74)
              {
                v75 = v78;
                while ((v76(*v75) & 1) == 0)
                {
                  if (++v75 == v74)
                  {
                    v75 = v74;
                    goto LABEL_135;
                  }
                }
              }
            }
          }
          v71 += 7;
        }
        while (v71 != v256);
      }
    }
  }
  v91 = *((void *)this + 5);
  if (os_log_type_enabled(v91, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v91, OS_LOG_TYPE_DEFAULT, "#I DATA:: genres vs apps:", buf, 2u);
  }
  v92 = (DataServiceController *)*((void *)this + 589);
  if (v92 != (DataServiceController *)((char *)this + 4720))
  {
    do
    {
      v93 = *((void *)this + 5);
      if (os_log_type_enabled(v93, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v94 = *((void *)v92 + 4);
        *(_DWORD *)buf = 134217984;
        *(void *)&buf[4] = v94;
        _os_log_impl((void *)&_mh_execute_header, v93, OS_LOG_TYPE_DEFAULT, "#I DATA::       \t\tgenre %llu", buf, 0xCu);
      }
      v95 = (void *)*((void *)v92 + 5);
      if (v95 != (void *)((char *)v92 + 48))
      {
        do
        {
          v96 = *((void *)this + 5);
          if (os_log_type_enabled(v96, OS_LOG_TYPE_DEFAULT))
          {
            v97 = v95 + 4;
            if (*((char *)v95 + 55) < 0) {
              v97 = (void *)*v97;
            }
            *(_DWORD *)buf = 136446210;
            *(void *)&buf[4] = v97;
            _os_log_impl((void *)&_mh_execute_header, v96, OS_LOG_TYPE_DEFAULT, "#I DATA::       \t\t\tapp %{public}s", buf, 0xCu);
          }
          v98 = (void *)v95[1];
          if (v98)
          {
            do
            {
              v99 = v98;
              v98 = (void *)*v98;
            }
            while (v98);
          }
          else
          {
            do
            {
              v99 = (void *)v95[2];
              BOOL v33 = *v99 == (void)v95;
              v95 = v99;
            }
            while (!v33);
          }
          v95 = v99;
        }
        while (v99 != (void *)((char *)v92 + 48));
      }
      v100 = (DataServiceController *)*((void *)v92 + 1);
      if (v100)
      {
        do
        {
          v101 = v100;
          v100 = *(DataServiceController **)v100;
        }
        while (v100);
      }
      else
      {
        do
        {
          v101 = (DataServiceController *)*((void *)v92 + 2);
          BOOL v33 = *(void *)v101 == (void)v92;
          v92 = v101;
        }
        while (!v33);
      }
      v92 = v101;
    }
    while (v101 != (DataServiceController *)((char *)this + 4720));
  }
  v102 = *((void *)this + 5);
  if (os_log_type_enabled(v102, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v102, OS_LOG_TYPE_DEFAULT, "#I DATA:: all local apps genres:", buf, 2u);
  }
  v103 = (DataServiceController *)*((void *)this + 583);
  if (v103 != (DataServiceController *)((char *)this + 4672))
  {
    do
    {
      v104 = *((void *)this + 5);
      if (os_log_type_enabled(v104, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v105 = *((void *)v103 + 4);
        *(_DWORD *)buf = 134217984;
        *(void *)&buf[4] = v105;
        _os_log_impl((void *)&_mh_execute_header, v104, OS_LOG_TYPE_DEFAULT, "#I DATA::       \t\tgenre %llu", buf, 0xCu);
      }
      v106 = (DataServiceController *)*((void *)v103 + 1);
      if (v106)
      {
        do
        {
          v107 = v106;
          v106 = *(DataServiceController **)v106;
        }
        while (v106);
      }
      else
      {
        do
        {
          v107 = (DataServiceController *)*((void *)v103 + 2);
          BOOL v33 = *(void *)v107 == (void)v103;
          v103 = v107;
        }
        while (!v33);
      }
      v103 = v107;
    }
    while (v107 != (DataServiceController *)((char *)this + 4672));
  }
  v108 = *((void *)this + 5);
  if (os_log_type_enabled(v108, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v108, OS_LOG_TYPE_DEFAULT, "#I DATA:: slicing genres:", buf, 2u);
  }
  v109 = (DataServiceController *)*((void *)this + 586);
  if (v109 != (DataServiceController *)((char *)this + 4696))
  {
    do
    {
      v110 = *((void *)this + 5);
      if (os_log_type_enabled(v110, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v111 = *((void *)v109 + 4);
        *(_DWORD *)buf = 134217984;
        *(void *)&buf[4] = v111;
        _os_log_impl((void *)&_mh_execute_header, v110, OS_LOG_TYPE_DEFAULT, "#I DATA::       \t\tgenre %llu", buf, 0xCu);
      }
      v112 = (DataServiceController *)*((void *)v109 + 1);
      if (v112)
      {
        do
        {
          v113 = v112;
          v112 = *(DataServiceController **)v112;
        }
        while (v112);
      }
      else
      {
        do
        {
          v113 = (DataServiceController *)*((void *)v109 + 2);
          BOOL v33 = *(void *)v113 == (void)v109;
          v109 = v113;
        }
        while (!v33);
      }
      v109 = v113;
    }
    while (v113 != (DataServiceController *)((char *)this + 4696));
  }
  v114 = *((void *)this + 5);
  if (os_log_type_enabled(v114, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v114, OS_LOG_TYPE_DEFAULT, "#I DATA:: frontApps:", buf, 2u);
  }
  v115 = (uint64_t *)*((void *)this + 136);
  for (i = (uint64_t *)*((void *)this + 137); v115 != i; v115 += 3)
  {
    v117 = *((void *)this + 5);
    if (os_log_type_enabled(v117, OS_LOG_TYPE_DEFAULT))
    {
      v118 = v115;
      if (*((char *)v115 + 23) < 0) {
        v118 = (uint64_t *)*v115;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&buf[4] = v118;
      _os_log_impl((void *)&_mh_execute_header, v117, OS_LOG_TYPE_DEFAULT, "#I DATA::     \tapp: %{public}s", buf, 0xCu);
    }
  }
  if (*((void *)this + 600))
  {
    v119 = *((void *)this + 5);
    if (os_log_type_enabled(v119, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v119, OS_LOG_TYPE_DEFAULT, "#I DATA:: Rogue Apps:", buf, 2u);
    }
    v120 = (DataServiceController *)*((void *)this + 598);
    if (v120 != (DataServiceController *)((char *)this + 4792))
    {
      do
      {
        v121 = *((void *)this + 5);
        if (os_log_type_enabled(v121, OS_LOG_TYPE_DEFAULT))
        {
          v122 = (void *)((char *)v120 + 32);
          if (*((char *)v120 + 55) < 0) {
            v122 = (void *)*v122;
          }
          *(_DWORD *)buf = 136446210;
          *(void *)&buf[4] = v122;
          _os_log_impl((void *)&_mh_execute_header, v121, OS_LOG_TYPE_DEFAULT, "#I DATA::     \tapp: %{public}s", buf, 0xCu);
        }
        v123 = (DataServiceController *)*((void *)v120 + 1);
        if (v123)
        {
          do
          {
            v124 = v123;
            v123 = *(DataServiceController **)v123;
          }
          while (v123);
        }
        else
        {
          do
          {
            v124 = (DataServiceController *)*((void *)v120 + 2);
            BOOL v33 = *(void *)v124 == (void)v120;
            v120 = v124;
          }
          while (!v33);
        }
        v120 = v124;
      }
      while (v124 != (DataServiceController *)((char *)this + 4792));
    }
  }
  if (*((void *)this + 603))
  {
    v125 = *((void *)this + 5);
    if (os_log_type_enabled(v125, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v125, OS_LOG_TYPE_DEFAULT, "#I DATA:: CallKit Apps:", buf, 2u);
    }
    v126 = (DataServiceController *)*((void *)this + 601);
    if (v126 != (DataServiceController *)((char *)this + 4816))
    {
      do
      {
        v127 = *((void *)this + 5);
        if (os_log_type_enabled(v127, OS_LOG_TYPE_DEFAULT))
        {
          v128 = (void *)((char *)v126 + 32);
          if (*((char *)v126 + 55) < 0) {
            v128 = (void *)*v128;
          }
          *(_DWORD *)buf = 136446210;
          *(void *)&buf[4] = v128;
          _os_log_impl((void *)&_mh_execute_header, v127, OS_LOG_TYPE_DEFAULT, "#I DATA::     \tapp: %{public}s", buf, 0xCu);
        }
        v129 = (DataServiceController *)*((void *)v126 + 1);
        if (v129)
        {
          do
          {
            v130 = v129;
            v129 = *(DataServiceController **)v129;
          }
          while (v129);
        }
        else
        {
          do
          {
            v130 = (DataServiceController *)*((void *)v126 + 2);
            BOOL v33 = *(void *)v130 == (void)v126;
            v126 = v130;
          }
          while (!v33);
        }
        v126 = v130;
      }
      while (v130 != (DataServiceController *)((char *)this + 4816));
    }
  }
  if (*((void *)this + 609))
  {
    v131 = *((void *)this + 5);
    if (os_log_type_enabled(v131, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v131, OS_LOG_TYPE_DEFAULT, "#I DATA:: Forwarded Apps:", buf, 2u);
    }
    v132 = (DataServiceController *)*((void *)this + 607);
    if (v132 != (DataServiceController *)((char *)this + 4864))
    {
      do
      {
        v133 = *((void *)this + 5);
        if (os_log_type_enabled(v133, OS_LOG_TYPE_DEFAULT))
        {
          v134 = (void *)((char *)v132 + 32);
          if (*((char *)v132 + 55) < 0) {
            v134 = (void *)*v134;
          }
          uint64_t v135 = (unsigned __int128)((std::chrono::steady_clock::now().__d_.__rep_ - *((void *)v132 + 7))
                                   * (__int128)0x112E0BE826D694B3) >> 64;
          *(_DWORD *)buf = 136446466;
          *(void *)&buf[4] = v134;
          *(_WORD *)&buf[12] = 2048;
          *(void *)&buf[14] = (v135 >> 26) + ((unint64_t)v135 >> 63);
          _os_log_impl((void *)&_mh_execute_header, v133, OS_LOG_TYPE_DEFAULT, "#I DATA::     \tapp: %{public}s timestamp: %llu secs old", buf, 0x16u);
        }
        v136 = (DataServiceController *)*((void *)v132 + 1);
        if (v136)
        {
          do
          {
            v137 = v136;
            v136 = *(DataServiceController **)v136;
          }
          while (v136);
        }
        else
        {
          do
          {
            v137 = (DataServiceController *)*((void *)v132 + 2);
            BOOL v33 = *(void *)v137 == (void)v132;
            v132 = v137;
          }
          while (!v33);
        }
        v132 = v137;
      }
      while (v137 != (DataServiceController *)((char *)this + 4864));
    }
  }
  if (*((void *)this + 618))
  {
    v138 = *((void *)this + 5);
    if (os_log_type_enabled(v138, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v138, OS_LOG_TYPE_DEFAULT, "#I DATA:: vpnAgnosticApps:", buf, 2u);
    }
    v139 = (DataServiceController *)*((void *)this + 616);
    if (v139 != (DataServiceController *)((char *)this + 4936))
    {
      do
      {
        v140 = *((void *)this + 5);
        if (os_log_type_enabled(v140, OS_LOG_TYPE_DEFAULT))
        {
          v141 = (void *)((char *)v139 + 32);
          if (*((char *)v139 + 55) < 0) {
            v141 = (void *)*v141;
          }
          *(_DWORD *)buf = 136315138;
          *(void *)&buf[4] = v141;
          _os_log_impl((void *)&_mh_execute_header, v140, OS_LOG_TYPE_DEFAULT, "#I DATA:: \t%s", buf, 0xCu);
        }
        v142 = (DataServiceController *)*((void *)v139 + 1);
        if (v142)
        {
          do
          {
            v143 = v142;
            v142 = *(DataServiceController **)v142;
          }
          while (v142);
        }
        else
        {
          do
          {
            v143 = (DataServiceController *)*((void *)v139 + 2);
            BOOL v33 = *(void *)v143 == (void)v139;
            v139 = v143;
          }
          while (!v33);
        }
        v139 = v143;
      }
      while (v143 != (DataServiceController *)((char *)this + 4936));
    }
  }
  uint64_t v144 = *((void *)this + 14);
  *(void *)buf = *((void *)this + 13);
  *(void *)&buf[8] = v144;
  if (v144) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v144 + 8), 1uLL, memory_order_relaxed);
  }
  subscriber::makeSimSlotRange();
  if (*(void *)&buf[8]) {
    sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
  }
  v254 = (unsigned int *)*((void *)&v259 + 1);
  v145 = (unsigned int *)v259;
  if ((void)v259 != *((void *)&v259 + 1))
  {
    v252 = v260;
    while ((v252(*v145) & 1) == 0)
    {
      if (++v145 == v254)
      {
        v145 = v254;
        break;
      }
    }
    v251 = (unsigned int *)*((void *)&v259 + 1);
    while (v145 != v251)
    {
      uint64_t v146 = *v145;
      v147 = *((void *)this + 5);
      if (os_log_type_enabled(v147, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v148 = subscriber::asString();
        *(_DWORD *)buf = 136315138;
        *(void *)&buf[4] = v148;
        _os_log_impl((void *)&_mh_execute_header, v147, OS_LOG_TYPE_DEFAULT, "#I DATA::     ---------------- simSlot: %s ----------------", buf, 0xCu);
      }
      *(_DWORD *)buf = v146;
      uint64_t v149 = *sub_10003B194((uint64_t)this + 4616, (int *)buf);
      v150 = *((void *)this + 5);
      uint64_t v255 = v149;
      if (os_log_type_enabled(v150, OS_LOG_TYPE_DEFAULT))
      {
        char v151 = *((void *)this + 626) != 0;
        char v152 = (*(uint64_t (**)(DataServiceController *, uint64_t))(*(void *)this + 1040))(this, v146);
        BOOL v153 = sub_100AF88A8(v255, v151, v152);
        uint64_t v154 = asStringBool(v153);
        *(_DWORD *)buf = 136315138;
        *(void *)&buf[4] = v154;
        _os_log_impl((void *)&_mh_execute_header, v150, OS_LOG_TYPE_DEFAULT, "#I DATA::     configured(2): %s", buf, 0xCu);
        v150 = *((void *)this + 5);
        uint64_t v149 = v255;
      }
      if (os_log_type_enabled(v150, OS_LOG_TYPE_DEFAULT))
      {
        char v155 = (*(uint64_t (**)(DataServiceController *, uint64_t, void))(*(void *)this + 2176))(this, v146, 0);
        uint64_t v156 = asStringBool(v155);
        *(_DWORD *)buf = 136315138;
        *(void *)&buf[4] = v156;
        _os_log_impl((void *)&_mh_execute_header, v150, OS_LOG_TYPE_DEFAULT, "#I DATA::     useInternetSlicing_sync: %s", buf, 0xCu);
        v150 = *((void *)this + 5);
        uint64_t v149 = v255;
      }
      if (os_log_type_enabled(v150, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v157 = asStringBool(*(unsigned char *)v149);
        *(_DWORD *)buf = 136315138;
        *(void *)&buf[4] = v157;
        _os_log_impl((void *)&_mh_execute_header, v150, OS_LOG_TYPE_DEFAULT, "#I DATA::     enabled: %s", buf, 0xCu);
        v150 = *((void *)this + 5);
        uint64_t v149 = v255;
      }
      if (os_log_type_enabled(v150, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v158 = asStringBool(*(unsigned char *)(v149 + 1));
        *(_DWORD *)buf = 136315138;
        *(void *)&buf[4] = v158;
        _os_log_impl((void *)&_mh_execute_header, v150, OS_LOG_TYPE_DEFAULT, "#I DATA::     managedApps: %s", buf, 0xCu);
        v150 = *((void *)this + 5);
        uint64_t v149 = v255;
      }
      if (os_log_type_enabled(v150, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v159 = asStringBool(*(unsigned char *)(v149 + 2));
        *(_DWORD *)buf = 136315138;
        *(void *)&buf[4] = v159;
        _os_log_impl((void *)&_mh_execute_header, v150, OS_LOG_TYPE_DEFAULT, "#I DATA::     managedSliceApps: %s", buf, 0xCu);
        v150 = *((void *)this + 5);
        uint64_t v149 = v255;
      }
      if (os_log_type_enabled(v150, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v160 = asStringBool(*(unsigned char *)(v149 + 21));
        *(_DWORD *)buf = 136315138;
        *(void *)&buf[4] = v160;
        _os_log_impl((void *)&_mh_execute_header, v150, OS_LOG_TYPE_DEFAULT, "#I DATA::     wifiSupported: %s", buf, 0xCu);
        v150 = *((void *)this + 5);
        uint64_t v149 = v255;
      }
      if (os_log_type_enabled(v150, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v161 = asStringBool(*(unsigned char *)(v149 + 23));
        *(_DWORD *)buf = 136315138;
        *(void *)&buf[4] = v161;
        _os_log_impl((void *)&_mh_execute_header, v150, OS_LOG_TYPE_DEFAULT, "#I DATA::     entitlementsGenres: %s", buf, 0xCu);
        v150 = *((void *)this + 5);
        uint64_t v149 = v255;
      }
      if (os_log_type_enabled(v150, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v162 = asStringBool(*(unsigned char *)(v149 + 22));
        *(_DWORD *)buf = 136315138;
        *(void *)&buf[4] = v162;
        _os_log_impl((void *)&_mh_execute_header, v150, OS_LOG_TYPE_DEFAULT, "#I DATA::     shutdownOnDataModeChange: %s", buf, 0xCu);
        v150 = *((void *)this + 5);
        uint64_t v149 = v255;
      }
      if (os_log_type_enabled(v150, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v163 = asStringBool(*(unsigned char *)(v149 + 24));
        *(_DWORD *)buf = 136315138;
        *(void *)&buf[4] = v163;
        _os_log_impl((void *)&_mh_execute_header, v150, OS_LOG_TYPE_DEFAULT, "#I DATA::     allowSocketAPIWithTrafficClasses: %s", buf, 0xCu);
        v150 = *((void *)this + 5);
        uint64_t v149 = v255;
      }
      if (os_log_type_enabled(v150, OS_LOG_TYPE_DEFAULT))
      {
        int v164 = *(_DWORD *)(v149 + 4);
        *(_DWORD *)buf = 67109120;
        *(_DWORD *)&buf[4] = v164;
        _os_log_impl((void *)&_mh_execute_header, v150, OS_LOG_TYPE_DEFAULT, "#I DATA::     technologyMask: %u", buf, 8u);
        v150 = *((void *)this + 5);
      }
      if (os_log_type_enabled(v150, OS_LOG_TYPE_DEFAULT))
      {
        int v165 = *(_DWORD *)(v149 + 8);
        *(_DWORD *)buf = 67109120;
        *(_DWORD *)&buf[4] = v165;
        _os_log_impl((void *)&_mh_execute_header, v150, OS_LOG_TYPE_DEFAULT, "#I DATA::     sliceInactivityTimeoutSecs: %u", buf, 8u);
        v150 = *((void *)this + 5);
      }
      if (os_log_type_enabled(v150, OS_LOG_TYPE_DEFAULT))
      {
        int v166 = *(unsigned __int8 *)(v149 + 12);
        *(_DWORD *)buf = 67109120;
        *(_DWORD *)&buf[4] = v166;
        _os_log_impl((void *)&_mh_execute_header, v150, OS_LOG_TYPE_DEFAULT, "#I DATA::     supportsLLPHS: %{BOOL}d", buf, 8u);
        v150 = *((void *)this + 5);
      }
      if (os_log_type_enabled(v150, OS_LOG_TYPE_DEFAULT))
      {
        int v167 = *(unsigned __int8 *)(v149 + 13);
        *(_DWORD *)buf = 67109120;
        *(_DWORD *)&buf[4] = v167;
        _os_log_impl((void *)&_mh_execute_header, v150, OS_LOG_TYPE_DEFAULT, "#I DATA::     entitledLLPHS: %{BOOL}d", buf, 8u);
        v150 = *((void *)this + 5);
      }
      if (os_log_type_enabled(v150, OS_LOG_TYPE_DEFAULT))
      {
        int v168 = *(unsigned __int8 *)(v149 + 14);
        *(_DWORD *)buf = 67109120;
        *(_DWORD *)&buf[4] = v168;
        _os_log_impl((void *)&_mh_execute_header, v150, OS_LOG_TYPE_DEFAULT, "#I DATA::     ignoreEntitledLLPHS: %{BOOL}d", buf, 8u);
        v150 = *((void *)this + 5);
      }
      if (os_log_type_enabled(v150, OS_LOG_TYPE_DEFAULT))
      {
        int v169 = *(unsigned __int8 *)(v149 + 15);
        *(_DWORD *)buf = 67109120;
        *(_DWORD *)&buf[4] = v169;
        _os_log_impl((void *)&_mh_execute_header, v150, OS_LOG_TYPE_DEFAULT, "#I DATA::     supportsConsumer: %{BOOL}d", buf, 8u);
        v150 = *((void *)this + 5);
      }
      if (os_log_type_enabled(v150, OS_LOG_TYPE_DEFAULT))
      {
        int v170 = *(unsigned __int8 *)(v149 + 16);
        *(_DWORD *)buf = 67109120;
        *(_DWORD *)&buf[4] = v170;
        _os_log_impl((void *)&_mh_execute_header, v150, OS_LOG_TYPE_DEFAULT, "#I DATA::     supportsCallKit: %{BOOL}d", buf, 8u);
        v150 = *((void *)this + 5);
      }
      if (os_log_type_enabled(v150, OS_LOG_TYPE_DEFAULT))
      {
        int v171 = *(unsigned __int8 *)(v149 + 17);
        *(_DWORD *)buf = 67109120;
        *(_DWORD *)&buf[4] = v171;
        _os_log_impl((void *)&_mh_execute_header, v150, OS_LOG_TYPE_DEFAULT, "#I DATA::     forceCallKitUdp: %{BOOL}d", buf, 8u);
        v150 = *((void *)this + 5);
      }
      if (os_log_type_enabled(v150, OS_LOG_TYPE_DEFAULT))
      {
        int v172 = *(unsigned __int8 *)(v149 + 18);
        *(_DWORD *)buf = 67109120;
        *(_DWORD *)&buf[4] = v172;
        _os_log_impl((void *)&_mh_execute_header, v150, OS_LOG_TYPE_DEFAULT, "#I DATA::     forcePoliciesDown: %{BOOL}d", buf, 8u);
        v150 = *((void *)this + 5);
      }
      if (os_log_type_enabled(v150, OS_LOG_TYPE_DEFAULT))
      {
        int v173 = *(unsigned __int8 *)(v149 + 19);
        *(_DWORD *)buf = 67109120;
        *(_DWORD *)&buf[4] = v173;
        _os_log_impl((void *)&_mh_execute_header, v150, OS_LOG_TYPE_DEFAULT, "#I DATA::     internationalRoaming: %{BOOL}d", buf, 8u);
        v150 = *((void *)this + 5);
      }
      if (os_log_type_enabled(v150, OS_LOG_TYPE_DEFAULT))
      {
        int v174 = *(unsigned __int8 *)(v149 + 20);
        *(_DWORD *)buf = 67109120;
        *(_DWORD *)&buf[4] = v174;
        _os_log_impl((void *)&_mh_execute_header, v150, OS_LOG_TYPE_DEFAULT, "#I DATA::     useOnlyXRForLLPHS: %{BOOL}d", buf, 8u);
      }
      if (*(void *)(v149 + 200))
      {
        v175 = *((void *)this + 5);
        if (os_log_type_enabled(v175, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v175, OS_LOG_TYPE_DEFAULT, "#I DATA:: \tcbConfiguredVpnAgnosticApps:", buf, 2u);
        }
        v176 = *(void **)(v149 + 184);
        if (v176 != (void *)(v149 + 192))
        {
          do
          {
            v177 = *((void *)this + 5);
            if (os_log_type_enabled(v177, OS_LOG_TYPE_DEFAULT))
            {
              v178 = v176 + 4;
              if (*((char *)v176 + 55) < 0) {
                v178 = (void *)*v178;
              }
              *(_DWORD *)buf = 136315138;
              *(void *)&buf[4] = v178;
              _os_log_impl((void *)&_mh_execute_header, v177, OS_LOG_TYPE_DEFAULT, "#I DATA:: \t\t%s", buf, 0xCu);
            }
            v179 = (void *)v176[1];
            if (v179)
            {
              do
              {
                v180 = v179;
                v179 = (void *)*v179;
              }
              while (v179);
            }
            else
            {
              do
              {
                v180 = (void *)v176[2];
                BOOL v33 = *v180 == (void)v176;
                v176 = v180;
              }
              while (!v33);
            }
            v176 = v180;
          }
          while (v180 != (void *)(v149 + 192));
        }
      }
      v181 = *(void **)(v149 + 328);
      v182 = (void *)(v149 + 336);
      if (v181 != v182)
      {
        do
        {
          v183 = *((void *)this + 5);
          if (os_log_type_enabled(v183, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v184 = v181[4];
            uint64_t v185 = asStringBool(*((unsigned char *)v181 + 40));
            uint64_t v186 = asString();
            *(_DWORD *)buf = 134218498;
            *(void *)&buf[4] = v184;
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = v185;
            *(_WORD *)&buf[22] = 2082;
            *(void *)&buf[24] = v186;
            _os_log_impl((void *)&_mh_execute_header, v183, OS_LOG_TYPE_DEFAULT, "#I DATA::     featureState: genre=%llu %{public}s / %{public}s", buf, 0x20u);
          }
          v187 = (void *)v181[1];
          if (v187)
          {
            do
            {
              v188 = v187;
              v187 = (void *)*v187;
            }
            while (v187);
          }
          else
          {
            do
            {
              v188 = (void *)v181[2];
              BOOL v33 = *v188 == (void)v181;
              v181 = v188;
            }
            while (!v33);
          }
          v181 = v188;
        }
        while (v188 != v182);
      }
      v189 = *(TrafficDescriptor **)(v255 + 32);
      v190 = *(TrafficDescriptor **)(v255 + 40);
      if (v189 != v190)
      {
        v191 = *((void *)this + 5);
        if (os_log_type_enabled(v191, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v191, OS_LOG_TYPE_DEFAULT, "#I DATA::     cbTrafficDescriptors:", buf, 2u);
          v189 = *(TrafficDescriptor **)(v255 + 32);
          v190 = *(TrafficDescriptor **)(v255 + 40);
        }
        while (v189 != v190)
        {
          v192 = *((void *)this + 5);
          if (os_log_type_enabled(v192, OS_LOG_TYPE_DEFAULT))
          {
            TrafficDescriptor::toString((uint64_t *)buf, v189);
            v193 = buf;
            if (buf[23] < 0) {
              v193 = *(unsigned char **)buf;
            }
            *(_DWORD *)v257 = 136446210;
            v258 = v193;
            _os_log_impl((void *)&_mh_execute_header, v192, OS_LOG_TYPE_DEFAULT, "#I DATA::     \ttd(cb) %{public}s", v257, 0xCu);
            if ((buf[23] & 0x80000000) != 0) {
              operator delete(*(void **)buf);
            }
          }
          v189 = (TrafficDescriptor *)((char *)v189 + 304);
        }
      }
      v194 = *(TrafficDescriptor **)(v255 + 56);
      v195 = *(TrafficDescriptor **)(v255 + 64);
      if (v194 != v195)
      {
        v196 = *((void *)this + 5);
        if (os_log_type_enabled(v196, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v196, OS_LOG_TYPE_DEFAULT, "#I DATA::     tdsCache:", buf, 2u);
          v194 = *(TrafficDescriptor **)(v255 + 56);
          v195 = *(TrafficDescriptor **)(v255 + 64);
        }
        while (v194 != v195)
        {
          v197 = *((void *)this + 5);
          if (os_log_type_enabled(v197, OS_LOG_TYPE_DEFAULT))
          {
            TrafficDescriptor::toString((uint64_t *)buf, v194);
            v198 = buf;
            if (buf[23] < 0) {
              v198 = *(unsigned char **)buf;
            }
            *(_DWORD *)v257 = 136446210;
            v258 = v198;
            _os_log_impl((void *)&_mh_execute_header, v197, OS_LOG_TYPE_DEFAULT, "#I DATA::     \ttd(cache) %{public}s", v257, 0xCu);
            if ((buf[23] & 0x80000000) != 0) {
              operator delete(*(void **)buf);
            }
          }
          v194 = (TrafficDescriptor *)((char *)v194 + 304);
        }
      }
      if (*(void *)(v255 + 96))
      {
        v199 = *((void *)this + 5);
        if (os_log_type_enabled(v199, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v199, OS_LOG_TYPE_DEFAULT, "#I DATA::     customAppCategories:", buf, 2u);
        }
        v200 = *(void **)(v255 + 80);
        if (v200 != (void *)(v255 + 88))
        {
          do
          {
            v201 = *((void *)this + 5);
            if (os_log_type_enabled(v201, OS_LOG_TYPE_DEFAULT))
            {
              v202 = v200 + 5;
              if (*((char *)v200 + 63) < 0) {
                v202 = (void *)*v202;
              }
              uint64_t v203 = v200[4];
              *(_DWORD *)buf = 134218242;
              *(void *)&buf[4] = v203;
              *(_WORD *)&buf[12] = 2082;
              *(void *)&buf[14] = v202;
              _os_log_impl((void *)&_mh_execute_header, v201, OS_LOG_TYPE_DEFAULT, "#I DATA::     \t%llu %{public}s", buf, 0x16u);
            }
            v204 = (uint64_t *)v200[8];
            v205 = (uint64_t *)v200[9];
            while (v204 != v205)
            {
              v206 = *((void *)this + 5);
              if (os_log_type_enabled(v206, OS_LOG_TYPE_DEFAULT))
              {
                v207 = v204;
                if (*((char *)v204 + 23) < 0) {
                  v207 = (uint64_t *)*v204;
                }
                *(_DWORD *)buf = 136446210;
                *(void *)&buf[4] = v207;
                _os_log_impl((void *)&_mh_execute_header, v206, OS_LOG_TYPE_DEFAULT, "#I DATA::     \t\tapp: %{public}s", buf, 0xCu);
              }
              v204 += 3;
            }
            v208 = (uint64_t *)v200[11];
            v209 = (uint64_t *)v200[12];
            while (v208 != v209)
            {
              v210 = *((void *)this + 5);
              if (os_log_type_enabled(v210, OS_LOG_TYPE_DEFAULT))
              {
                uint64_t v211 = *v208;
                *(_DWORD *)buf = 134217984;
                *(void *)&buf[4] = v211;
                _os_log_impl((void *)&_mh_execute_header, v210, OS_LOG_TYPE_DEFAULT, "#I DATA::     \t\tac: %llu", buf, 0xCu);
              }
              ++v208;
            }
            v212 = (void *)v200[1];
            if (v212)
            {
              do
              {
                v213 = v212;
                v212 = (void *)*v212;
              }
              while (v212);
            }
            else
            {
              do
              {
                v213 = (void *)v200[2];
                BOOL v33 = *v213 == (void)v200;
                v200 = v213;
              }
              while (!v33);
            }
            v200 = v213;
          }
          while (v213 != (void *)(v255 + 88));
        }
      }
      v214 = *((void *)this + 5);
      if (os_log_type_enabled(v214, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v215 = asStringBool(*(unsigned char *)(v255 + 128));
        *(_DWORD *)buf = 136315138;
        *(void *)&buf[4] = v215;
        _os_log_impl((void *)&_mh_execute_header, v214, OS_LOG_TYPE_DEFAULT, "#I DATA::     allowedAppsAll: %s", buf, 0xCu);
      }
      if (*(void *)(v255 + 120))
      {
        v216 = *((void *)this + 5);
        if (os_log_type_enabled(v216, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v216, OS_LOG_TYPE_DEFAULT, "#I DATA::     allowedApps:", buf, 2u);
        }
        v217 = *(void **)(v255 + 104);
        if (v217 != (void *)(v255 + 112))
        {
          do
          {
            v218 = *((void *)this + 5);
            if (os_log_type_enabled(v218, OS_LOG_TYPE_DEFAULT))
            {
              v219 = v217 + 4;
              if (*((char *)v217 + 55) < 0) {
                v219 = (void *)*v219;
              }
              *(_DWORD *)buf = 136446210;
              *(void *)&buf[4] = v219;
              _os_log_impl((void *)&_mh_execute_header, v218, OS_LOG_TYPE_DEFAULT, "#I DATA::     \tapp: %{public}s", buf, 0xCu);
            }
            v220 = (void *)v217[1];
            if (v220)
            {
              do
              {
                v221 = v220;
                v220 = (void *)*v220;
              }
              while (v220);
            }
            else
            {
              do
              {
                v221 = (void *)v217[2];
                BOOL v33 = *v221 == (void)v217;
                v217 = v221;
              }
              while (!v33);
            }
            v217 = v221;
          }
          while (v221 != (void *)(v255 + 112));
        }
      }
      if (*(void *)(v255 + 152))
      {
        v222 = *((void *)this + 5);
        if (os_log_type_enabled(v222, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v222, OS_LOG_TYPE_DEFAULT, "#I DATA::     managedAllowedApps:", buf, 2u);
        }
        v223 = *(void **)(v255 + 136);
        if (v223 != (void *)(v255 + 144))
        {
          do
          {
            v224 = *((void *)this + 5);
            if (os_log_type_enabled(v224, OS_LOG_TYPE_DEFAULT))
            {
              v225 = v223 + 4;
              if (*((char *)v223 + 55) < 0) {
                v225 = (void *)*v225;
              }
              v226 = v223 + 10;
              if (*((char *)v223 + 103) < 0) {
                v226 = (void *)*v226;
              }
              v227 = v223 + 7;
              if (*((char *)v223 + 79) < 0) {
                v227 = (void *)*v227;
              }
              *(_DWORD *)buf = 136446722;
              *(void *)&buf[4] = v225;
              *(_WORD *)&buf[12] = 2082;
              *(void *)&buf[14] = v226;
              *(_WORD *)&buf[22] = 2082;
              *(void *)&buf[24] = v227;
              _os_log_impl((void *)&_mh_execute_header, v224, OS_LOG_TYPE_DEFAULT, "#I DATA::     \tapp: %{public}s, dnn: %{public}s, fakeAppCategory: %{public}s", buf, 0x20u);
            }
            v228 = (void *)v223[1];
            if (v228)
            {
              do
              {
                v229 = v228;
                v228 = (void *)*v228;
              }
              while (v228);
            }
            else
            {
              do
              {
                v229 = (void *)v223[2];
                BOOL v33 = *v229 == (void)v223;
                v223 = v229;
              }
              while (!v33);
            }
            v223 = v229;
          }
          while (v229 != (void *)(v255 + 144));
        }
      }
      if (*(void *)(v255 + 176))
      {
        v230 = *((void *)this + 5);
        if (os_log_type_enabled(v230, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v230, OS_LOG_TYPE_DEFAULT, "#I DATA::     fakeAppCategorys:", buf, 2u);
        }
        v231 = *(void **)(v255 + 160);
        if (v231 != (void *)(v255 + 168))
        {
          do
          {
            v232 = *((void *)this + 5);
            if (os_log_type_enabled(v232, OS_LOG_TYPE_DEFAULT))
            {
              v233 = v231 + 4;
              if (*((char *)v231 + 55) < 0) {
                v233 = (void *)*v233;
              }
              *(_DWORD *)buf = 136446210;
              *(void *)&buf[4] = v233;
              _os_log_impl((void *)&_mh_execute_header, v232, OS_LOG_TYPE_DEFAULT, "#I DATA::     \tfake app category: %{public}s", buf, 0xCu);
            }
            v234 = (void *)v231[1];
            if (v234)
            {
              do
              {
                v235 = v234;
                v234 = (void *)*v234;
              }
              while (v234);
            }
            else
            {
              do
              {
                v235 = (void *)v231[2];
                BOOL v33 = *v235 == (void)v231;
                v231 = v235;
              }
              while (!v33);
            }
            v231 = v235;
          }
          while (v235 != (void *)(v255 + 168));
        }
      }
      if (*(unsigned char *)(v255 + 208))
      {
        char v236 = *(unsigned char *)(v255 + 255);
        if (v236 < 0) {
          uint64_t v237 = *(void *)(v255 + 240);
        }
        else {
          uint64_t v237 = *(unsigned __int8 *)(v255 + 255);
        }
        v238 = *((void *)this + 5);
        if (v237 && os_log_type_enabled(*((os_log_t *)this + 5), OS_LOG_TYPE_DEFAULT))
        {
          v239 = (void *)(v255 + 232);
          if (v236 < 0) {
            v239 = (void *)*v239;
          }
          *(_DWORD *)buf = 136446210;
          *(void *)&buf[4] = v239;
          _os_log_impl((void *)&_mh_execute_header, v238, OS_LOG_TYPE_DEFAULT, "#I DATA::     osId(str): %{public}s", buf, 0xCu);
          v238 = *((void *)this + 5);
        }
        if (os_log_type_enabled(v238, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v238, OS_LOG_TYPE_DEFAULT, "#I DATA::     osId:", buf, 2u);
        }
        for (uint64_t j = 0; j != 16; ++j)
        {
          v241 = *((void *)this + 5);
          if (os_log_type_enabled(v241, OS_LOG_TYPE_DEFAULT))
          {
            int v242 = *(unsigned __int8 *)(v255 + 209 + j);
            *(_DWORD *)buf = 67109120;
            *(_DWORD *)&buf[4] = v242;
            _os_log_impl((void *)&_mh_execute_header, v241, OS_LOG_TYPE_DEFAULT, "#I DATA::     \tosId 0x%x", buf, 8u);
          }
        }
      }
      char v243 = *(unsigned char *)(v255 + 279);
      if (v243 < 0)
      {
        if (!*(void *)(v255 + 264)) {
          goto LABEL_471;
        }
      }
      else if (!*(unsigned char *)(v255 + 279))
      {
        goto LABEL_471;
      }
      v244 = *((void *)this + 5);
      if (os_log_type_enabled(v244, OS_LOG_TYPE_DEFAULT))
      {
        v245 = (void *)(v255 + 256);
        if (v243 < 0) {
          v245 = (void *)*v245;
        }
        *(_DWORD *)buf = 136446210;
        *(void *)&buf[4] = v245;
        _os_log_impl((void *)&_mh_execute_header, v244, OS_LOG_TYPE_DEFAULT, "#I DATA::     dnn: %{public}s", buf, 0xCu);
        v244 = *((void *)this + 5);
      }
      if (os_log_type_enabled(v244, OS_LOG_TYPE_DEFAULT))
      {
        v246 = (void *)(v255 + 304);
        if (*(char *)(v255 + 327) < 0) {
          v246 = (void *)*v246;
        }
        *(_DWORD *)buf = 136446210;
        *(void *)&buf[4] = v246;
        _os_log_impl((void *)&_mh_execute_header, v244, OS_LOG_TYPE_DEFAULT, "#I DATA::     anyLookupDnn: %{public}s", buf, 0xCu);
      }
LABEL_471:
      char v247 = *(unsigned char *)(v255 + 303);
      if (v247 < 0)
      {
        if (*(void *)(v255 + 288))
        {
LABEL_475:
          v248 = *((void *)this + 5);
          if (os_log_type_enabled(v248, OS_LOG_TYPE_DEFAULT))
          {
            v249 = (void *)(v255 + 280);
            if (v247 < 0) {
              v249 = (void *)*v249;
            }
            *(_DWORD *)buf = 136446210;
            *(void *)&buf[4] = v249;
            _os_log_impl((void *)&_mh_execute_header, v248, OS_LOG_TYPE_DEFAULT, "#I DATA::     apn: %{public}s", buf, 0xCu);
          }
        }
      }
      else if (*(unsigned char *)(v255 + 303))
      {
        goto LABEL_475;
      }
      v250 = v145 + 1;
      v145 = v254;
      if (v250 != v254)
      {
        v145 = v250;
        while ((v252(*v145) & 1) == 0)
        {
          if (++v145 == v254)
          {
            v145 = v254;
            break;
          }
        }
      }
    }
  }
}

void sub_100AFC1C0(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(std::__shared_weak_count **)(v1 - 136);
  if (v3) {
    sub_10004D2C8(v3);
  }
  _Unwind_Resume(exception_object);
}

void DataServiceController::updateSlicingDefinitions_sync(uint64_t a1, uint64_t a2, std::string::size_type a3, BOOL a4)
{
  uint64_t v5 = a1;
  if (!(*(unsigned int (**)(uint64_t))(*(void *)a1 + 2192))(a1)) {
    return;
  }
  BOOL v678 = a4;
  int v6 = (*(uint64_t (**)(uint64_t))(*(void *)v5 + 1088))(v5);
  LODWORD(buf[0].__r_.__value_.__l.__data_) = v6;
  uint64_t v693 = v5 + 4616;
  int v680 = *(unsigned __int8 *)*sub_10003B194(v5 + 4616, (int *)buf);
  LODWORD(buf[0].__r_.__value_.__l.__data_) = v6;
  int v677 = *(unsigned __int8 *)(*sub_10003B194(v5 + 4616, (int *)buf) + 23);
  LODWORD(buf[0].__r_.__value_.__l.__data_) = v6;
  char v7 = sub_10003B194(v5 + 4616, (int *)buf);
  uint64_t v8 = *v7;
  if (*(unsigned char *)(*v7 + 12))
  {
    if (*(unsigned char *)(v8 + 13)) {
      BOOL v9 = 1;
    }
    else {
      BOOL v9 = *(unsigned char *)(v8 + 14) != 0;
    }
  }
  else
  {
    BOOL v9 = 0;
  }
  LODWORD(buf[0].__r_.__value_.__l.__data_) = v6;
  int v679 = *(unsigned __int8 *)(*sub_10003B194(v693, (int *)buf) + 15);
  LODWORD(buf[0].__r_.__value_.__l.__data_) = v6;
  uint64_t v10 = *sub_10003B194(v693, (int *)buf);
  uint64_t v11 = *(NSObject **)(v5 + 40);
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    BOOL v12 = *(unsigned char *)(v10 + 19) != 0;
    uint64_t v13 = subscriber::asString();
    if (*(char *)(a3 + 23) >= 0) {
      std::string::size_type v14 = a3;
    }
    else {
      std::string::size_type v14 = *(void *)a3;
    }
    uint64_t v15 = asStringBool(v680 != 0);
    std::string::size_type v16 = asStringBool(v9);
    std::string::size_type v17 = asStringBool(v679 != 0);
    std::string::size_type v18 = asStringBool(v12);
    LODWORD(buf[0].__r_.__value_.__l.__data_) = 136316418;
    *(std::string::size_type *)((char *)buf[0].__r_.__value_.__r.__words + 4) = v13;
    WORD2(buf[0].__r_.__value_.__r.__words[1]) = 2082;
    *(std::string::size_type *)((char *)&buf[0].__r_.__value_.__r.__words[1] + 6) = v14;
    HIWORD(buf[0].__r_.__value_.__r.__words[2]) = 2080;
    buf[1].__r_.__value_.__r.__words[0] = v15;
    LOWORD(buf[1].__r_.__value_.__r.__words[1]) = 2080;
    *(std::string::size_type *)((char *)&buf[1].__r_.__value_.__r.__words[1] + 2) = v16;
    WORD1(buf[1].__r_.__value_.__r.__words[2]) = 2080;
    *(std::string::size_type *)((char *)&buf[1].__r_.__value_.__r.__words[2] + 4) = v17;
    WORD2(buf[2].__r_.__value_.__r.__words[0]) = 2080;
    *(std::string::size_type *)((char *)buf[2].__r_.__value_.__r.__words + 6) = v18;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I update slicing: [%s] %{public}s, oldSliceUsed=%s oldLlphs=%s oldConsumer=%s oldInternationalRoaming=%s", (uint8_t *)buf, 0x3Eu);
  }
  std::string::size_type v19 = *(void *)(v5 + 112);
  buf[0].__r_.__value_.__r.__words[0] = *(void *)(v5 + 104);
  buf[0].__r_.__value_.__l.__size_ = v19;
  if (v19) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v19 + 8), 1uLL, memory_order_relaxed);
  }
  subscriber::makeSimSlotRange();
  if (buf[0].__r_.__value_.__l.__size_) {
    sub_10004D2C8((std::__shared_weak_count *)buf[0].__r_.__value_.__l.__size_);
  }
  int v20 = v707;
  v701 = v708;
  if (v707 != v708)
  {
    v700 = v709;
    while (1)
    {
      uint64_t v21 = v20;
      if (v709(*v20)) {
        break;
      }
      int v20 = v21 + 1;
      if (v21 + 1 == v708)
      {
        uint64_t v22 = v708;
        goto LABEL_22;
      }
    }
    uint64_t v22 = v21;
LABEL_22:
    v683 = v708;
    if (v22 != v708)
    {
      uint64_t v23 = v5 + 4640;
      int v24 = (void **)(v5 + 4648);
      v698 = (uint64_t **)(v5 + 4712);
      v704 = (void *)(v5 + 4720);
      __s = (char *)kWildCardDnn;
      v686 = (void *)v5;
      do
      {
        v685 = v22;
        unsigned int v702 = *v22;
        int v25 = (os_log_t *)(*(uint64_t (**)(void))(**(void **)(v5 + 48) + 16))(*(void *)(v5 + 48));
        LODWORD(buf[0].__r_.__value_.__l.__data_) = v702;
        uint64_t v26 = *sub_10003B194(v693, (int *)buf);
        *(unsigned char *)(v26 + 2) = 0;
        *(_WORD *)uint64_t v26 = 0;
        *(void *)(v26 + 4) = 0x1E00000000;
        uint64_t v694 = v26;
        *(unsigned char *)(v26 + 12) = 0;
        *(unsigned char *)(v26 + 13) = sub_100AF13BC(v5, v702);
        *(_WORD *)(v694 + 14) = 256;
        *(unsigned char *)(v694 + 16) = 1;
        *(unsigned char *)(v694 + 22) = 0;
        *(_DWORD *)(v694 + 17) = 0;
        *(_WORD *)(v694 + 23) = 1;
        uint64_t v27 = &qword_101B0FD78;
        LOBYTE(v27) = atomic_load_explicit((atomic_uchar *volatile)&qword_101B0FD78, memory_order_acquire);
        if ((v27 & 1) == 0 && __cxa_guard_acquire(&qword_101B0FD78))
        {
          buf[0].__r_.__value_.__r.__words[0] = (std::string::size_type)@"NRSlicing";
          sub_100367E88(qword_101B0FE68, buf, 1uLL);
          __cxa_atexit((void (*)(void *))sub_100367F0C, qword_101B0FE68, (void *)&_mh_execute_header);
          __cxa_guard_release(&qword_101B0FD78);
          uint64_t v5 = (uint64_t)v686;
        }
        __str.__r_.__value_.__r.__words[0] = 0;
        ServiceMap = (std::mutex *)Registry::getServiceMap(v27, *(Registry **)(v5 + 104));
        long long v29 = ServiceMap;
        std::string::size_type v31 = v30;
        if (v30 < 0)
        {
          uint64_t v32 = (unsigned __int8 *)(v30 & 0x7FFFFFFFFFFFFFFFLL);
          uint64_t v33 = 5381;
          do
          {
            std::string::size_type v31 = v33;
            unsigned int v34 = *v32++;
            uint64_t v33 = (33 * v33) ^ v34;
          }
          while (v34);
        }
        std::mutex::lock(ServiceMap);
        buf[0].__r_.__value_.__r.__words[0] = v31;
        unint64_t v35 = sub_10004D37C(&v29[1].__m_.__sig, (unint64_t *)buf);
        std::string::size_type v699 = v30;
        if (v35)
        {
          uint64_t v37 = v35[3];
          uint64_t v36 = (std::__shared_weak_count *)v35[4];
          if (v36)
          {
            atomic_fetch_add_explicit(&v36->__shared_owners_, 1uLL, memory_order_relaxed);
            std::mutex::unlock(v29);
            atomic_fetch_add_explicit(&v36->__shared_owners_, 1uLL, memory_order_relaxed);
            sub_10004D2C8(v36);
            char v38 = 0;
            goto LABEL_33;
          }
        }
        else
        {
          uint64_t v37 = 0;
        }
        std::mutex::unlock(v29);
        uint64_t v36 = 0;
        char v38 = 1;
LABEL_33:
        (*(void (**)(std::string *__return_ptr, uint64_t, void, uint64_t, void *, void, void))(*(void *)v37 + 88))(&__str, v37, v702, 1, qword_101B0FE68, 0, 0);
        if ((v38 & 1) == 0) {
          sub_10004D2C8(v36);
        }
        if (__str.__r_.__value_.__r.__words[0]) {
          uint64_t v39 = sub_100080934;
        }
        else {
          uint64_t v39 = 0;
        }
        int v40 = *v25;
        BOOL v41 = os_log_type_enabled(*v25, OS_LOG_TYPE_DEFAULT);
        if (!v39)
        {
          if (v41)
          {
            LOWORD(buf[0].__r_.__value_.__l.__data_) = 0;
            _os_log_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_DEFAULT, "#I no NRSlicing definitions", (uint8_t *)buf, 2u);
          }
          sub_1000577C4((const void **)&__str.__r_.__value_.__l.__data_);
          v53 = v685;
          goto LABEL_902;
        }
        if (v41)
        {
          LOWORD(buf[0].__r_.__value_.__l.__data_) = 0;
          _os_log_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_DEFAULT, "#I NRSlicing used", (uint8_t *)buf, 2u);
        }
        *(unsigned char *)uint64_t v694 = 1;
        sub_1000577C4((const void **)&__str.__r_.__value_.__l.__data_);
        long long v42 = &qword_101B0FD80;
        LOBYTE(v42) = atomic_load_explicit((atomic_uchar *volatile)&qword_101B0FD80, memory_order_acquire);
        if ((v42 & 1) == 0 && __cxa_guard_acquire(&qword_101B0FD80))
        {
          buf[0].__r_.__value_.__r.__words[0] = (std::string::size_type)@"NRSlicing";
          buf[0].__r_.__value_.__l.__size_ = (std::string::size_type)@"ShutdownOnDataModeChange";
          sub_100367E88(qword_101B0FE80, buf, 2uLL);
          __cxa_atexit((void (*)(void *))sub_100367F0C, qword_101B0FE80, (void *)&_mh_execute_header);
          __cxa_guard_release(&qword_101B0FD80);
          uint64_t v5 = (uint64_t)v686;
        }
        __str.__r_.__value_.__r.__words[0] = 0;
        int64x2_t v43 = (std::mutex *)Registry::getServiceMap(v42, *(Registry **)(v5 + 104));
        unint64_t v44 = v43;
        std::string::size_type v45 = v30;
        if (v30 < 0)
        {
          v46 = (unsigned __int8 *)(v30 & 0x7FFFFFFFFFFFFFFFLL);
          uint64_t v47 = 5381;
          do
          {
            std::string::size_type v45 = v47;
            unsigned int v48 = *v46++;
            uint64_t v47 = (33 * v47) ^ v48;
          }
          while (v48);
        }
        std::mutex::lock(v43);
        buf[0].__r_.__value_.__r.__words[0] = v45;
        int v49 = sub_10004D37C(&v44[1].__m_.__sig, (unint64_t *)buf);
        if (v49)
        {
          uint64_t v51 = v49[3];
          v50 = (std::__shared_weak_count *)v49[4];
          if (v50)
          {
            atomic_fetch_add_explicit(&v50->__shared_owners_, 1uLL, memory_order_relaxed);
            std::mutex::unlock(v44);
            atomic_fetch_add_explicit(&v50->__shared_owners_, 1uLL, memory_order_relaxed);
            sub_10004D2C8(v50);
            char v52 = 0;
            goto LABEL_53;
          }
        }
        else
        {
          uint64_t v51 = 0;
        }
        std::mutex::unlock(v44);
        v50 = 0;
        char v52 = 1;
LABEL_53:
        (*(void (**)(std::string *__return_ptr, uint64_t, void, uint64_t, void *, const CFBooleanRef, void))(*(void *)v51 + 104))(&__str, v51, v702, 1, qword_101B0FE80, kCFBooleanFalse, 0);
        if ((v52 & 1) == 0) {
          sub_10004D2C8(v50);
        }
        v54 = (BOOL *)__str.__r_.__value_.__r.__words[0];
        if (__str.__r_.__value_.__r.__words[0]) {
          v55 = sub_100080934;
        }
        else {
          v55 = 0;
        }
        if (v55)
        {
          buf[0].__r_.__value_.__s.__data_[0] = 0;
          if (__str.__r_.__value_.__r.__words[0])
          {
            CFTypeID v56 = CFGetTypeID(__str.__r_.__value_.__l.__data_);
            if (v56 == CFBooleanGetTypeID()) {
              ctu::cf::assign((ctu::cf *)buf, v54, v57);
            }
            if (buf[0].__r_.__value_.__s.__data_[0])
            {
              v58 = *v25;
              if (os_log_type_enabled(*v25, OS_LOG_TYPE_DEFAULT))
              {
                LOWORD(buf[0].__r_.__value_.__l.__data_) = 0;
                _os_log_impl((void *)&_mh_execute_header, v58, OS_LOG_TYPE_DEFAULT, "#I ShutdownOnDataModeChange used", (uint8_t *)buf, 2u);
              }
              *(unsigned char *)(v694 + 22) = 1;
            }
          }
        }
        sub_1000577C4((const void **)&__str.__r_.__value_.__l.__data_);
        uint64_t v60 = (std::mutex *)Registry::getServiceMap(v59, *(Registry **)(v5 + 104));
        v61 = v60;
        if ((v62 & 0x8000000000000000) != 0)
        {
          v63 = (unsigned __int8 *)(v62 & 0x7FFFFFFFFFFFFFFFLL);
          uint64_t v64 = 5381;
          do
          {
            std::string::size_type v62 = v64;
            unsigned int v65 = *v63++;
            uint64_t v64 = (33 * v64) ^ v65;
          }
          while (v65);
        }
        std::mutex::lock(v60);
        buf[0].__r_.__value_.__r.__words[0] = v62;
        v66 = sub_10004D37C(&v61[1].__m_.__sig, (unint64_t *)buf);
        if (v66)
        {
          uint64_t v67 = v66[3];
          v68 = (std::__shared_weak_count *)v66[4];
          if (v68)
          {
            atomic_fetch_add_explicit(&v68->__shared_owners_, 1uLL, memory_order_relaxed);
            std::mutex::unlock(v61);
            atomic_fetch_add_explicit(&v68->__shared_owners_, 1uLL, memory_order_relaxed);
            v682 = v68;
            sub_10004D2C8(v68);
            char v684 = 0;
            if (!v67) {
              goto LABEL_99;
            }
            goto LABEL_75;
          }
        }
        else
        {
          uint64_t v67 = 0;
        }
        std::mutex::unlock(v61);
        v682 = 0;
        char v684 = 1;
        if (!v67) {
          goto LABEL_99;
        }
LABEL_75:
        if (!(*(unsigned int (**)(uint64_t))(*(void *)v67 + 32))(v67)) {
          goto LABEL_99;
        }
        v69 = &qword_101B0FD88;
        LOBYTE(v69) = atomic_load_explicit((atomic_uchar *volatile)&qword_101B0FD88, memory_order_acquire);
        if ((v69 & 1) == 0 && __cxa_guard_acquire(&qword_101B0FD88))
        {
          buf[0].__r_.__value_.__r.__words[0] = (std::string::size_type)@"NRSlicing";
          buf[0].__r_.__value_.__l.__size_ = (std::string::size_type)@"EntitlementsGenres";
          sub_100367E88(qword_101B0FE98, buf, 2uLL);
          __cxa_atexit((void (*)(void *))sub_100367F0C, qword_101B0FE98, (void *)&_mh_execute_header);
          __cxa_guard_release(&qword_101B0FD88);
          uint64_t v5 = (uint64_t)v686;
        }
        __str.__r_.__value_.__r.__words[0] = 0;
        int64x2_t v70 = (std::mutex *)Registry::getServiceMap(v69, *(Registry **)(v5 + 104));
        v71 = v70;
        std::string::size_type v72 = v30;
        if (v30 < 0)
        {
          uint64_t v73 = (unsigned __int8 *)(v30 & 0x7FFFFFFFFFFFFFFFLL);
          uint64_t v74 = 5381;
          do
          {
            std::string::size_type v72 = v74;
            unsigned int v75 = *v73++;
            uint64_t v74 = (33 * v74) ^ v75;
          }
          while (v75);
        }
        std::mutex::lock(v70);
        buf[0].__r_.__value_.__r.__words[0] = v72;
        unint64_t v76 = sub_10004D37C(&v71[1].__m_.__sig, (unint64_t *)buf);
        if (!v76)
        {
          uint64_t v78 = 0;
LABEL_84:
          std::mutex::unlock(v71);
          v77 = 0;
          char v79 = 1;
          goto LABEL_85;
        }
        uint64_t v78 = v76[3];
        v77 = (std::__shared_weak_count *)v76[4];
        if (!v77) {
          goto LABEL_84;
        }
        atomic_fetch_add_explicit(&v77->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v71);
        atomic_fetch_add_explicit(&v77->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v77);
        char v79 = 0;
LABEL_85:
        (*(void (**)(std::string *__return_ptr, uint64_t, void, uint64_t, void *, const CFBooleanRef, void))(*(void *)v78 + 104))(&__str, v78, v702, 1, qword_101B0FE98, kCFBooleanTrue, 0);
        if ((v79 & 1) == 0) {
          sub_10004D2C8(v77);
        }
        v80 = (BOOL *)__str.__r_.__value_.__r.__words[0];
        if (__str.__r_.__value_.__r.__words[0]) {
          uint64_t v81 = sub_100080934;
        }
        else {
          uint64_t v81 = 0;
        }
        if (v81)
        {
          buf[0].__r_.__value_.__s.__data_[0] = 1;
          if (__str.__r_.__value_.__r.__words[0])
          {
            CFTypeID v82 = CFGetTypeID(__str.__r_.__value_.__l.__data_);
            if (v82 == CFBooleanGetTypeID()) {
              ctu::cf::assign((ctu::cf *)buf, v80, v83);
            }
            if (!buf[0].__r_.__value_.__s.__data_[0])
            {
              v84 = *v25;
              if (os_log_type_enabled(*v25, OS_LOG_TYPE_DEFAULT))
              {
                LOWORD(buf[0].__r_.__value_.__l.__data_) = 0;
                _os_log_impl((void *)&_mh_execute_header, v84, OS_LOG_TYPE_DEFAULT, "#I AppStore Genres used", (uint8_t *)buf, 2u);
              }
              *(unsigned char *)(v694 + 23) = 0;
            }
          }
        }
        sub_1000577C4((const void **)&__str.__r_.__value_.__l.__data_);
LABEL_99:
        v85 = &qword_101B0FD90;
        LOBYTE(v85) = atomic_load_explicit((atomic_uchar *volatile)&qword_101B0FD90, memory_order_acquire);
        if ((v85 & 1) == 0 && __cxa_guard_acquire(&qword_101B0FD90))
        {
          buf[0].__r_.__value_.__r.__words[0] = (std::string::size_type)@"NRSlicing";
          buf[0].__r_.__value_.__l.__size_ = (std::string::size_type)@"AllowSocketAPIWithTrafficClasses";
          sub_100367E88(qword_101B0FEB0, buf, 2uLL);
          __cxa_atexit((void (*)(void *))sub_100367F0C, qword_101B0FEB0, (void *)&_mh_execute_header);
          __cxa_guard_release(&qword_101B0FD90);
          uint64_t v5 = (uint64_t)v686;
        }
        __str.__r_.__value_.__r.__words[0] = 0;
        v86 = (std::mutex *)Registry::getServiceMap(v85, *(Registry **)(v5 + 104));
        v87 = v86;
        std::string::size_type v88 = v30;
        if (v30 < 0)
        {
          v89 = (unsigned __int8 *)(v30 & 0x7FFFFFFFFFFFFFFFLL);
          uint64_t v90 = 5381;
          do
          {
            std::string::size_type v88 = v90;
            unsigned int v91 = *v89++;
            uint64_t v90 = (33 * v90) ^ v91;
          }
          while (v91);
        }
        std::mutex::lock(v86);
        buf[0].__r_.__value_.__r.__words[0] = v88;
        v92 = sub_10004D37C(&v87[1].__m_.__sig, (unint64_t *)buf);
        if (v92)
        {
          uint64_t v94 = v92[3];
          v93 = (std::__shared_weak_count *)v92[4];
          if (v93)
          {
            atomic_fetch_add_explicit(&v93->__shared_owners_, 1uLL, memory_order_relaxed);
            std::mutex::unlock(v87);
            atomic_fetch_add_explicit(&v93->__shared_owners_, 1uLL, memory_order_relaxed);
            sub_10004D2C8(v93);
            char v95 = 0;
            goto LABEL_108;
          }
        }
        else
        {
          uint64_t v94 = 0;
        }
        std::mutex::unlock(v87);
        v93 = 0;
        char v95 = 1;
LABEL_108:
        (*(void (**)(std::string *__return_ptr, uint64_t, void, uint64_t, void *, const CFBooleanRef, void))(*(void *)v94 + 104))(&__str, v94, v702, 1, qword_101B0FEB0, kCFBooleanFalse, 0);
        if ((v95 & 1) == 0) {
          sub_10004D2C8(v93);
        }
        v96 = (BOOL *)__str.__r_.__value_.__r.__words[0];
        if (__str.__r_.__value_.__r.__words[0]) {
          v97 = sub_100080934;
        }
        else {
          v97 = 0;
        }
        if (v97)
        {
          buf[0].__r_.__value_.__s.__data_[0] = 0;
          if (__str.__r_.__value_.__r.__words[0])
          {
            CFTypeID v98 = CFGetTypeID(__str.__r_.__value_.__l.__data_);
            if (v98 == CFBooleanGetTypeID()) {
              ctu::cf::assign((ctu::cf *)buf, v96, v99);
            }
            if (buf[0].__r_.__value_.__s.__data_[0])
            {
              v100 = *v25;
              if (os_log_type_enabled(*v25, OS_LOG_TYPE_DEFAULT))
              {
                LOWORD(buf[0].__r_.__value_.__l.__data_) = 0;
                _os_log_impl((void *)&_mh_execute_header, v100, OS_LOG_TYPE_DEFAULT, "#I AllowSocketAPIWithTrafficClasses used", (uint8_t *)buf, 2u);
              }
              *(unsigned char *)(v694 + 24) = 1;
            }
          }
        }
        sub_1000577C4((const void **)&__str.__r_.__value_.__l.__data_);
        v101 = &qword_101B0FD98;
        LOBYTE(v101) = atomic_load_explicit((atomic_uchar *volatile)&qword_101B0FD98, memory_order_acquire);
        if ((v101 & 1) == 0 && __cxa_guard_acquire(&qword_101B0FD98))
        {
          buf[0].__r_.__value_.__r.__words[0] = (std::string::size_type)@"NRSlicing";
          buf[0].__r_.__value_.__l.__size_ = (std::string::size_type)@"TechnologyMask";
          sub_100367E88(qword_101B0FEC8, buf, 2uLL);
          __cxa_atexit((void (*)(void *))sub_100367F0C, qword_101B0FEC8, (void *)&_mh_execute_header);
          __cxa_guard_release(&qword_101B0FD98);
          uint64_t v5 = (uint64_t)v686;
        }
        __str.__r_.__value_.__r.__words[0] = 0;
        v102 = (std::mutex *)Registry::getServiceMap(v101, *(Registry **)(v5 + 104));
        v103 = v102;
        std::string::size_type v104 = v30;
        if (v30 < 0)
        {
          uint64_t v105 = (unsigned __int8 *)(v30 & 0x7FFFFFFFFFFFFFFFLL);
          uint64_t v106 = 5381;
          do
          {
            std::string::size_type v104 = v106;
            unsigned int v107 = *v105++;
            uint64_t v106 = (33 * v106) ^ v107;
          }
          while (v107);
        }
        std::mutex::lock(v102);
        buf[0].__r_.__value_.__r.__words[0] = v104;
        v108 = sub_10004D37C(&v103[1].__m_.__sig, (unint64_t *)buf);
        if (v108)
        {
          uint64_t v110 = v108[3];
          v109 = (std::__shared_weak_count *)v108[4];
          if (v109)
          {
            atomic_fetch_add_explicit(&v109->__shared_owners_, 1uLL, memory_order_relaxed);
            std::mutex::unlock(v103);
            atomic_fetch_add_explicit(&v109->__shared_owners_, 1uLL, memory_order_relaxed);
            sub_10004D2C8(v109);
            char v111 = 0;
            goto LABEL_130;
          }
        }
        else
        {
          uint64_t v110 = 0;
        }
        std::mutex::unlock(v103);
        v109 = 0;
        char v111 = 1;
LABEL_130:
        (*(void (**)(std::string *__return_ptr, uint64_t, void, uint64_t, void *, void, void))(*(void *)v110 + 104))(&v725, v110, v702, 1, qword_101B0FEC8, 0, 0);
        sub_1000842D0(&__str, (CFTypeRef *)&v725.__r_.__value_.__l.__data_);
        sub_1000577C4((const void **)&v725.__r_.__value_.__l.__data_);
        if ((v111 & 1) == 0) {
          sub_10004D2C8(v109);
        }
        if (__str.__r_.__value_.__r.__words[0]) {
          v112 = sub_100081E58;
        }
        else {
          v112 = 0;
        }
        if (v112)
        {
          LODWORD(buf[0].__r_.__value_.__l.__data_) = 0;
          if (CFNumberGetValue((CFNumberRef)__str.__r_.__value_.__l.__data_, kCFNumberIntType, buf))
          {
            *(_DWORD *)(v694 + 4) = buf[0].__r_.__value_.__l.__data_;
          }
          else
          {
            v113 = *v25;
            if (os_log_type_enabled(*v25, OS_LOG_TYPE_DEFAULT))
            {
              LOWORD(v725.__r_.__value_.__l.__data_) = 0;
              _os_log_impl((void *)&_mh_execute_header, v113, OS_LOG_TYPE_DEFAULT, "#E Cannot retreive TechnologyMask value", (uint8_t *)&v725, 2u);
            }
          }
        }
        sub_1000570E8((const void **)&__str.__r_.__value_.__l.__data_);
        v114 = &qword_101B0FDA0;
        LOBYTE(v114) = atomic_load_explicit((atomic_uchar *volatile)&qword_101B0FDA0, memory_order_acquire);
        if ((v114 & 1) == 0 && __cxa_guard_acquire(&qword_101B0FDA0))
        {
          buf[0].__r_.__value_.__r.__words[0] = (std::string::size_type)@"NRSlicing";
          buf[0].__r_.__value_.__l.__size_ = (std::string::size_type)@"SliceInactivityTimeoutSecs";
          sub_100367E88(qword_101B0FEE0, buf, 2uLL);
          __cxa_atexit((void (*)(void *))sub_100367F0C, qword_101B0FEE0, (void *)&_mh_execute_header);
          __cxa_guard_release(&qword_101B0FDA0);
          uint64_t v5 = (uint64_t)v686;
        }
        __str.__r_.__value_.__r.__words[0] = 0;
        v115 = (std::mutex *)Registry::getServiceMap(v114, *(Registry **)(v5 + 104));
        v116 = v115;
        std::string::size_type v117 = v30;
        if (v30 < 0)
        {
          v118 = (unsigned __int8 *)(v30 & 0x7FFFFFFFFFFFFFFFLL);
          uint64_t v119 = 5381;
          do
          {
            std::string::size_type v117 = v119;
            unsigned int v120 = *v118++;
            uint64_t v119 = (33 * v119) ^ v120;
          }
          while (v120);
        }
        std::mutex::lock(v115);
        buf[0].__r_.__value_.__r.__words[0] = v117;
        v121 = sub_10004D37C(&v116[1].__m_.__sig, (unint64_t *)buf);
        if (v121)
        {
          uint64_t v123 = v121[3];
          v122 = (std::__shared_weak_count *)v121[4];
          if (v122)
          {
            atomic_fetch_add_explicit(&v122->__shared_owners_, 1uLL, memory_order_relaxed);
            std::mutex::unlock(v116);
            atomic_fetch_add_explicit(&v122->__shared_owners_, 1uLL, memory_order_relaxed);
            sub_10004D2C8(v122);
            char v124 = 0;
            goto LABEL_149;
          }
        }
        else
        {
          uint64_t v123 = 0;
        }
        std::mutex::unlock(v116);
        v122 = 0;
        char v124 = 1;
LABEL_149:
        (*(void (**)(std::string *__return_ptr, uint64_t, void, uint64_t, void *, void, void))(*(void *)v123 + 104))(&v725, v123, v702, 1, qword_101B0FEE0, 0, 0);
        sub_1000842D0(&__str, (CFTypeRef *)&v725.__r_.__value_.__l.__data_);
        sub_1000577C4((const void **)&v725.__r_.__value_.__l.__data_);
        if ((v124 & 1) == 0) {
          sub_10004D2C8(v122);
        }
        if (__str.__r_.__value_.__r.__words[0]) {
          v125 = sub_100081E58;
        }
        else {
          v125 = 0;
        }
        if (v125)
        {
          LODWORD(buf[0].__r_.__value_.__l.__data_) = 30;
          if (CFNumberGetValue((CFNumberRef)__str.__r_.__value_.__l.__data_, kCFNumberIntType, buf))
          {
            *(_DWORD *)(v694 + 8) = buf[0].__r_.__value_.__l.__data_;
          }
          else
          {
            v126 = *v25;
            if (os_log_type_enabled(*v25, OS_LOG_TYPE_DEFAULT))
            {
              LOWORD(v725.__r_.__value_.__l.__data_) = 0;
              _os_log_impl((void *)&_mh_execute_header, v126, OS_LOG_TYPE_DEFAULT, "#E Cannot retreive SliceInactivityTimeoutSecs value", (uint8_t *)&v725, 2u);
            }
          }
        }
        sub_1000570E8((const void **)&__str.__r_.__value_.__l.__data_);
        v127 = &qword_101B0FDA8;
        LOBYTE(v127) = atomic_load_explicit((atomic_uchar *volatile)&qword_101B0FDA8, memory_order_acquire);
        if ((v127 & 1) == 0 && __cxa_guard_acquire(&qword_101B0FDA8))
        {
          buf[0].__r_.__value_.__r.__words[0] = (std::string::size_type)@"NRSlicing";
          buf[0].__r_.__value_.__l.__size_ = (std::string::size_type)@"SupportsLLPHS";
          sub_100367E88(qword_101B0FEF8, buf, 2uLL);
          __cxa_atexit((void (*)(void *))sub_100367F0C, qword_101B0FEF8, (void *)&_mh_execute_header);
          __cxa_guard_release(&qword_101B0FDA8);
          uint64_t v5 = (uint64_t)v686;
        }
        __str.__r_.__value_.__r.__words[0] = 0;
        v128 = (std::mutex *)Registry::getServiceMap(v127, *(Registry **)(v5 + 104));
        v129 = v128;
        std::string::size_type v130 = v30;
        if (v30 < 0)
        {
          v131 = (unsigned __int8 *)(v30 & 0x7FFFFFFFFFFFFFFFLL);
          uint64_t v132 = 5381;
          do
          {
            std::string::size_type v130 = v132;
            unsigned int v133 = *v131++;
            uint64_t v132 = (33 * v132) ^ v133;
          }
          while (v133);
        }
        std::mutex::lock(v128);
        buf[0].__r_.__value_.__r.__words[0] = v130;
        v134 = sub_10004D37C(&v129[1].__m_.__sig, (unint64_t *)buf);
        if (v134)
        {
          uint64_t v136 = v134[3];
          uint64_t v135 = (std::__shared_weak_count *)v134[4];
          if (v135)
          {
            atomic_fetch_add_explicit(&v135->__shared_owners_, 1uLL, memory_order_relaxed);
            std::mutex::unlock(v129);
            atomic_fetch_add_explicit(&v135->__shared_owners_, 1uLL, memory_order_relaxed);
            sub_10004D2C8(v135);
            char v137 = 0;
            goto LABEL_168;
          }
        }
        else
        {
          uint64_t v136 = 0;
        }
        std::mutex::unlock(v129);
        uint64_t v135 = 0;
        char v137 = 1;
LABEL_168:
        (*(void (**)(std::string *__return_ptr, uint64_t, void, uint64_t, void *, const CFBooleanRef, void))(*(void *)v136 + 104))(&__str, v136, v702, 1, qword_101B0FEF8, kCFBooleanFalse, 0);
        if ((v137 & 1) == 0) {
          sub_10004D2C8(v135);
        }
        v138 = (BOOL *)__str.__r_.__value_.__r.__words[0];
        if (__str.__r_.__value_.__r.__words[0]) {
          v139 = sub_100080934;
        }
        else {
          v139 = 0;
        }
        if (v139)
        {
          buf[0].__r_.__value_.__s.__data_[0] = 0;
          if (__str.__r_.__value_.__r.__words[0])
          {
            CFTypeID v140 = CFGetTypeID(__str.__r_.__value_.__l.__data_);
            if (v140 == CFBooleanGetTypeID()) {
              ctu::cf::assign((ctu::cf *)buf, v138, v141);
            }
            if (buf[0].__r_.__value_.__s.__data_[0])
            {
              v142 = *v25;
              if (os_log_type_enabled(*v25, OS_LOG_TYPE_DEFAULT))
              {
                LOWORD(buf[0].__r_.__value_.__l.__data_) = 0;
                _os_log_impl((void *)&_mh_execute_header, v142, OS_LOG_TYPE_DEFAULT, "#I SupportsLLPHS used", (uint8_t *)buf, 2u);
              }
              *(unsigned char *)(v694 + 12) = 1;
            }
          }
        }
        sub_1000577C4((const void **)&__str.__r_.__value_.__l.__data_);
        v143 = &qword_101B0FDB0;
        LOBYTE(v143) = atomic_load_explicit((atomic_uchar *volatile)&qword_101B0FDB0, memory_order_acquire);
        if ((v143 & 1) == 0 && __cxa_guard_acquire(&qword_101B0FDB0))
        {
          buf[0].__r_.__value_.__r.__words[0] = (std::string::size_type)@"NRSlicing";
          buf[0].__r_.__value_.__l.__size_ = (std::string::size_type)@"IgnoreEntitledLLPHS";
          sub_100367E88(qword_101B0FF10, buf, 2uLL);
          __cxa_atexit((void (*)(void *))sub_100367F0C, qword_101B0FF10, (void *)&_mh_execute_header);
          __cxa_guard_release(&qword_101B0FDB0);
          uint64_t v5 = (uint64_t)v686;
        }
        __str.__r_.__value_.__r.__words[0] = 0;
        uint64_t v144 = (std::mutex *)Registry::getServiceMap(v143, *(Registry **)(v5 + 104));
        v145 = v144;
        std::string::size_type v146 = v30;
        if (v30 < 0)
        {
          v147 = (unsigned __int8 *)(v30 & 0x7FFFFFFFFFFFFFFFLL);
          uint64_t v148 = 5381;
          do
          {
            std::string::size_type v146 = v148;
            unsigned int v149 = *v147++;
            uint64_t v148 = (33 * v148) ^ v149;
          }
          while (v149);
        }
        std::mutex::lock(v144);
        buf[0].__r_.__value_.__r.__words[0] = v146;
        v150 = sub_10004D37C(&v145[1].__m_.__sig, (unint64_t *)buf);
        if (v150)
        {
          uint64_t v152 = v150[3];
          char v151 = (std::__shared_weak_count *)v150[4];
          if (v151)
          {
            atomic_fetch_add_explicit(&v151->__shared_owners_, 1uLL, memory_order_relaxed);
            std::mutex::unlock(v145);
            atomic_fetch_add_explicit(&v151->__shared_owners_, 1uLL, memory_order_relaxed);
            sub_10004D2C8(v151);
            char v153 = 0;
            goto LABEL_190;
          }
        }
        else
        {
          uint64_t v152 = 0;
        }
        std::mutex::unlock(v145);
        char v151 = 0;
        char v153 = 1;
LABEL_190:
        (*(void (**)(std::string *__return_ptr, uint64_t, void, uint64_t, void *, const CFBooleanRef, void))(*(void *)v152 + 104))(&__str, v152, v702, 1, qword_101B0FF10, kCFBooleanFalse, 0);
        if ((v153 & 1) == 0) {
          sub_10004D2C8(v151);
        }
        uint64_t v154 = (BOOL *)__str.__r_.__value_.__r.__words[0];
        if (__str.__r_.__value_.__r.__words[0]) {
          char v155 = sub_100080934;
        }
        else {
          char v155 = 0;
        }
        if (v155)
        {
          buf[0].__r_.__value_.__s.__data_[0] = 0;
          if (__str.__r_.__value_.__r.__words[0])
          {
            CFTypeID v156 = CFGetTypeID(__str.__r_.__value_.__l.__data_);
            if (v156 == CFBooleanGetTypeID()) {
              ctu::cf::assign((ctu::cf *)buf, v154, v157);
            }
            if (buf[0].__r_.__value_.__s.__data_[0])
            {
              uint64_t v158 = *v25;
              if (os_log_type_enabled(*v25, OS_LOG_TYPE_DEFAULT))
              {
                LOWORD(buf[0].__r_.__value_.__l.__data_) = 0;
                _os_log_impl((void *)&_mh_execute_header, v158, OS_LOG_TYPE_DEFAULT, "#I IgnoreEntitledLLPHS used", (uint8_t *)buf, 2u);
              }
              *(unsigned char *)(v694 + 14) = 1;
            }
          }
        }
        sub_1000577C4((const void **)&__str.__r_.__value_.__l.__data_);
        uint64_t v159 = &qword_101B0FDB8;
        LOBYTE(v159) = atomic_load_explicit((atomic_uchar *volatile)&qword_101B0FDB8, memory_order_acquire);
        if ((v159 & 1) == 0 && __cxa_guard_acquire(&qword_101B0FDB8))
        {
          buf[0].__r_.__value_.__r.__words[0] = (std::string::size_type)@"NRSlicing";
          buf[0].__r_.__value_.__l.__size_ = (std::string::size_type)@"Consumer";
          sub_100367E88(qword_101B0FF28, buf, 2uLL);
          __cxa_atexit((void (*)(void *))sub_100367F0C, qword_101B0FF28, (void *)&_mh_execute_header);
          __cxa_guard_release(&qword_101B0FDB8);
          uint64_t v5 = (uint64_t)v686;
        }
        __str.__r_.__value_.__r.__words[0] = 0;
        uint64_t v160 = (std::mutex *)Registry::getServiceMap(v159, *(Registry **)(v5 + 104));
        uint64_t v161 = v160;
        std::string::size_type v162 = v30;
        if (v30 < 0)
        {
          uint64_t v163 = (unsigned __int8 *)(v30 & 0x7FFFFFFFFFFFFFFFLL);
          uint64_t v164 = 5381;
          do
          {
            std::string::size_type v162 = v164;
            unsigned int v165 = *v163++;
            uint64_t v164 = (33 * v164) ^ v165;
          }
          while (v165);
        }
        std::mutex::lock(v160);
        buf[0].__r_.__value_.__r.__words[0] = v162;
        int v166 = sub_10004D37C(&v161[1].__m_.__sig, (unint64_t *)buf);
        if (v166)
        {
          uint64_t v168 = v166[3];
          int v167 = (std::__shared_weak_count *)v166[4];
          if (v167)
          {
            atomic_fetch_add_explicit(&v167->__shared_owners_, 1uLL, memory_order_relaxed);
            std::mutex::unlock(v161);
            atomic_fetch_add_explicit(&v167->__shared_owners_, 1uLL, memory_order_relaxed);
            sub_10004D2C8(v167);
            char v169 = 0;
            goto LABEL_212;
          }
        }
        else
        {
          uint64_t v168 = 0;
        }
        std::mutex::unlock(v161);
        int v167 = 0;
        char v169 = 1;
LABEL_212:
        (*(void (**)(std::string *__return_ptr, uint64_t, void, uint64_t, void *, const CFBooleanRef, void))(*(void *)v168 + 104))(&v725, v168, v702, 1, qword_101B0FF28, kCFBooleanTrue, 0);
        sub_1000057AC(&__str, (CFTypeRef *)&v725.__r_.__value_.__l.__data_);
        sub_1000577C4((const void **)&v725.__r_.__value_.__l.__data_);
        if ((v169 & 1) == 0) {
          sub_10004D2C8(v167);
        }
        if (__str.__r_.__value_.__r.__words[0]) {
          int v171 = sub_100084B4C;
        }
        else {
          int v171 = 0;
        }
        if (v171)
        {
          buf[0].__r_.__value_.__s.__data_[0] = 0;
          ctu::cf::assign((ctu::cf *)buf, (BOOL *)__str.__r_.__value_.__l.__data_, v170);
          if (!buf[0].__r_.__value_.__s.__data_[0])
          {
            int v172 = *v25;
            if (os_log_type_enabled(*v25, OS_LOG_TYPE_DEFAULT))
            {
              LOWORD(buf[0].__r_.__value_.__l.__data_) = 0;
              _os_log_impl((void *)&_mh_execute_header, v172, OS_LOG_TYPE_DEFAULT, "#I Consumer used as false", (uint8_t *)buf, 2u);
            }
            *(unsigned char *)(v694 + 15) = 0;
          }
        }
        sub_100062778((const void **)&__str.__r_.__value_.__l.__data_);
        int v173 = &qword_101B0FDC0;
        LOBYTE(v173) = atomic_load_explicit((atomic_uchar *volatile)&qword_101B0FDC0, memory_order_acquire);
        if ((v173 & 1) == 0 && __cxa_guard_acquire(&qword_101B0FDC0))
        {
          buf[0].__r_.__value_.__r.__words[0] = (std::string::size_type)@"NRSlicing";
          buf[0].__r_.__value_.__l.__size_ = (std::string::size_type)@"CallKitSupported";
          sub_100367E88(qword_101B0FF40, buf, 2uLL);
          __cxa_atexit((void (*)(void *))sub_100367F0C, qword_101B0FF40, (void *)&_mh_execute_header);
          __cxa_guard_release(&qword_101B0FDC0);
          uint64_t v5 = (uint64_t)v686;
        }
        __str.__r_.__value_.__r.__words[0] = 0;
        int v174 = (std::mutex *)Registry::getServiceMap(v173, *(Registry **)(v5 + 104));
        v175 = v174;
        std::string::size_type v176 = v30;
        if (v30 < 0)
        {
          v177 = (unsigned __int8 *)(v30 & 0x7FFFFFFFFFFFFFFFLL);
          uint64_t v178 = 5381;
          do
          {
            std::string::size_type v176 = v178;
            unsigned int v179 = *v177++;
            uint64_t v178 = (33 * v178) ^ v179;
          }
          while (v179);
        }
        std::mutex::lock(v174);
        buf[0].__r_.__value_.__r.__words[0] = v176;
        v180 = sub_10004D37C(&v175[1].__m_.__sig, (unint64_t *)buf);
        if (v180)
        {
          uint64_t v182 = v180[3];
          v181 = (std::__shared_weak_count *)v180[4];
          if (v181)
          {
            atomic_fetch_add_explicit(&v181->__shared_owners_, 1uLL, memory_order_relaxed);
            std::mutex::unlock(v175);
            atomic_fetch_add_explicit(&v181->__shared_owners_, 1uLL, memory_order_relaxed);
            sub_10004D2C8(v181);
            char v183 = 0;
            goto LABEL_231;
          }
        }
        else
        {
          uint64_t v182 = 0;
        }
        std::mutex::unlock(v175);
        v181 = 0;
        char v183 = 1;
LABEL_231:
        (*(void (**)(std::string *__return_ptr, uint64_t, void, uint64_t, void *, const CFBooleanRef, void))(*(void *)v182 + 104))(&v725, v182, v702, 1, qword_101B0FF40, kCFBooleanTrue, 0);
        sub_1000057AC(&__str, (CFTypeRef *)&v725.__r_.__value_.__l.__data_);
        sub_1000577C4((const void **)&v725.__r_.__value_.__l.__data_);
        if ((v183 & 1) == 0) {
          sub_10004D2C8(v181);
        }
        if (__str.__r_.__value_.__r.__words[0]) {
          uint64_t v185 = sub_100084B4C;
        }
        else {
          uint64_t v185 = 0;
        }
        if (v185)
        {
          buf[0].__r_.__value_.__s.__data_[0] = 0;
          ctu::cf::assign((ctu::cf *)buf, (BOOL *)__str.__r_.__value_.__l.__data_, v184);
          if (!buf[0].__r_.__value_.__s.__data_[0])
          {
            uint64_t v186 = *v25;
            if (os_log_type_enabled(*v25, OS_LOG_TYPE_DEFAULT))
            {
              LOWORD(buf[0].__r_.__value_.__l.__data_) = 0;
              _os_log_impl((void *)&_mh_execute_header, v186, OS_LOG_TYPE_DEFAULT, "#I CallKit not supported", (uint8_t *)buf, 2u);
            }
            *(unsigned char *)(v694 + 16) = 0;
          }
        }
        sub_100062778((const void **)&__str.__r_.__value_.__l.__data_);
        v187 = &qword_101B0FDC8;
        LOBYTE(v187) = atomic_load_explicit((atomic_uchar *volatile)&qword_101B0FDC8, memory_order_acquire);
        if ((v187 & 1) == 0 && __cxa_guard_acquire(&qword_101B0FDC8))
        {
          buf[0].__r_.__value_.__r.__words[0] = (std::string::size_type)@"NRSlicing";
          buf[0].__r_.__value_.__l.__size_ = (std::string::size_type)@"ForceCallKitUdp";
          sub_100367E88(qword_101B0FF58, buf, 2uLL);
          __cxa_atexit((void (*)(void *))sub_100367F0C, qword_101B0FF58, (void *)&_mh_execute_header);
          __cxa_guard_release(&qword_101B0FDC8);
          uint64_t v5 = (uint64_t)v686;
        }
        __str.__r_.__value_.__r.__words[0] = 0;
        v188 = (std::mutex *)Registry::getServiceMap(v187, *(Registry **)(v5 + 104));
        v189 = v188;
        std::string::size_type v190 = v30;
        if (v30 < 0)
        {
          v191 = (unsigned __int8 *)(v30 & 0x7FFFFFFFFFFFFFFFLL);
          uint64_t v192 = 5381;
          do
          {
            std::string::size_type v190 = v192;
            unsigned int v193 = *v191++;
            uint64_t v192 = (33 * v192) ^ v193;
          }
          while (v193);
        }
        std::mutex::lock(v188);
        buf[0].__r_.__value_.__r.__words[0] = v190;
        v194 = sub_10004D37C(&v189[1].__m_.__sig, (unint64_t *)buf);
        if (v194)
        {
          uint64_t v196 = v194[3];
          v195 = (std::__shared_weak_count *)v194[4];
          if (v195)
          {
            atomic_fetch_add_explicit(&v195->__shared_owners_, 1uLL, memory_order_relaxed);
            std::mutex::unlock(v189);
            atomic_fetch_add_explicit(&v195->__shared_owners_, 1uLL, memory_order_relaxed);
            sub_10004D2C8(v195);
            char v197 = 0;
            goto LABEL_250;
          }
        }
        else
        {
          uint64_t v196 = 0;
        }
        std::mutex::unlock(v189);
        v195 = 0;
        char v197 = 1;
LABEL_250:
        (*(void (**)(std::string *__return_ptr, uint64_t, void, uint64_t, void *, const CFBooleanRef, void))(*(void *)v196 + 104))(&v725, v196, v702, 1, qword_101B0FF58, kCFBooleanFalse, 0);
        sub_1000057AC(&__str, (CFTypeRef *)&v725.__r_.__value_.__l.__data_);
        sub_1000577C4((const void **)&v725.__r_.__value_.__l.__data_);
        if ((v197 & 1) == 0) {
          sub_10004D2C8(v195);
        }
        if (__str.__r_.__value_.__r.__words[0]) {
          v199 = sub_100084B4C;
        }
        else {
          v199 = 0;
        }
        if (v199)
        {
          buf[0].__r_.__value_.__s.__data_[0] = 0;
          ctu::cf::assign((ctu::cf *)buf, (BOOL *)__str.__r_.__value_.__l.__data_, v198);
          if (buf[0].__r_.__value_.__s.__data_[0])
          {
            v200 = *v25;
            if (os_log_type_enabled(*v25, OS_LOG_TYPE_DEFAULT))
            {
              LOWORD(buf[0].__r_.__value_.__l.__data_) = 0;
              _os_log_impl((void *)&_mh_execute_header, v200, OS_LOG_TYPE_DEFAULT, "#I CallKit UDP forced", (uint8_t *)buf, 2u);
            }
            *(unsigned char *)(v694 + 17) = 1;
          }
        }
        sub_100062778((const void **)&__str.__r_.__value_.__l.__data_);
        v201 = &qword_101B0FDD0;
        LOBYTE(v201) = atomic_load_explicit((atomic_uchar *volatile)&qword_101B0FDD0, memory_order_acquire);
        if ((v201 & 1) == 0 && __cxa_guard_acquire(&qword_101B0FDD0))
        {
          buf[0].__r_.__value_.__r.__words[0] = (std::string::size_type)@"NRSlicing";
          buf[0].__r_.__value_.__l.__size_ = (std::string::size_type)@"ForcePoliciesDown";
          sub_100367E88(qword_101B0FF70, buf, 2uLL);
          __cxa_atexit((void (*)(void *))sub_100367F0C, qword_101B0FF70, (void *)&_mh_execute_header);
          __cxa_guard_release(&qword_101B0FDD0);
          uint64_t v5 = (uint64_t)v686;
        }
        __str.__r_.__value_.__r.__words[0] = 0;
        v202 = (std::mutex *)Registry::getServiceMap(v201, *(Registry **)(v5 + 104));
        uint64_t v203 = v202;
        std::string::size_type v204 = v30;
        if (v30 < 0)
        {
          v205 = (unsigned __int8 *)(v30 & 0x7FFFFFFFFFFFFFFFLL);
          uint64_t v206 = 5381;
          do
          {
            std::string::size_type v204 = v206;
            unsigned int v207 = *v205++;
            uint64_t v206 = (33 * v206) ^ v207;
          }
          while (v207);
        }
        std::mutex::lock(v202);
        buf[0].__r_.__value_.__r.__words[0] = v204;
        v208 = sub_10004D37C(&v203[1].__m_.__sig, (unint64_t *)buf);
        if (v208)
        {
          uint64_t v210 = v208[3];
          v209 = (std::__shared_weak_count *)v208[4];
          if (v209)
          {
            atomic_fetch_add_explicit(&v209->__shared_owners_, 1uLL, memory_order_relaxed);
            std::mutex::unlock(v203);
            atomic_fetch_add_explicit(&v209->__shared_owners_, 1uLL, memory_order_relaxed);
            sub_10004D2C8(v209);
            char v211 = 0;
            goto LABEL_269;
          }
        }
        else
        {
          uint64_t v210 = 0;
        }
        std::mutex::unlock(v203);
        v209 = 0;
        char v211 = 1;
LABEL_269:
        (*(void (**)(std::string *__return_ptr, uint64_t, void, uint64_t, void *, const CFBooleanRef, void))(*(void *)v210 + 104))(&v725, v210, v702, 1, qword_101B0FF70, kCFBooleanFalse, 0);
        sub_1000057AC(&__str, (CFTypeRef *)&v725.__r_.__value_.__l.__data_);
        sub_1000577C4((const void **)&v725.__r_.__value_.__l.__data_);
        if ((v211 & 1) == 0) {
          sub_10004D2C8(v209);
        }
        if (__str.__r_.__value_.__r.__words[0]) {
          v213 = sub_100084B4C;
        }
        else {
          v213 = 0;
        }
        if (v213)
        {
          buf[0].__r_.__value_.__s.__data_[0] = 0;
          ctu::cf::assign((ctu::cf *)buf, (BOOL *)__str.__r_.__value_.__l.__data_, v212);
          if (buf[0].__r_.__value_.__s.__data_[0])
          {
            v214 = *v25;
            if (os_log_type_enabled(*v25, OS_LOG_TYPE_DEFAULT))
            {
              LOWORD(buf[0].__r_.__value_.__l.__data_) = 0;
              _os_log_impl((void *)&_mh_execute_header, v214, OS_LOG_TYPE_DEFAULT, "#I Policies Down forced", (uint8_t *)buf, 2u);
            }
            *(unsigned char *)(v694 + 18) = 1;
          }
        }
        sub_100062778((const void **)&__str.__r_.__value_.__l.__data_);
        uint64_t v215 = &qword_101B0FDD8;
        LOBYTE(v215) = atomic_load_explicit((atomic_uchar *volatile)&qword_101B0FDD8, memory_order_acquire);
        if ((v215 & 1) == 0 && __cxa_guard_acquire(&qword_101B0FDD8))
        {
          buf[0].__r_.__value_.__r.__words[0] = (std::string::size_type)@"NRSlicing";
          buf[0].__r_.__value_.__l.__size_ = (std::string::size_type)@"InternationalRoaming";
          sub_100367E88(qword_101B0FF88, buf, 2uLL);
          __cxa_atexit((void (*)(void *))sub_100367F0C, qword_101B0FF88, (void *)&_mh_execute_header);
          __cxa_guard_release(&qword_101B0FDD8);
          uint64_t v5 = (uint64_t)v686;
        }
        __str.__r_.__value_.__r.__words[0] = 0;
        v216 = (std::mutex *)Registry::getServiceMap(v215, *(Registry **)(v5 + 104));
        v217 = v216;
        std::string::size_type v218 = v30;
        if (v30 < 0)
        {
          v219 = (unsigned __int8 *)(v30 & 0x7FFFFFFFFFFFFFFFLL);
          uint64_t v220 = 5381;
          do
          {
            std::string::size_type v218 = v220;
            unsigned int v221 = *v219++;
            uint64_t v220 = (33 * v220) ^ v221;
          }
          while (v221);
        }
        std::mutex::lock(v216);
        buf[0].__r_.__value_.__r.__words[0] = v218;
        v222 = sub_10004D37C(&v217[1].__m_.__sig, (unint64_t *)buf);
        if (v222)
        {
          uint64_t v224 = v222[3];
          v223 = (std::__shared_weak_count *)v222[4];
          if (v223)
          {
            atomic_fetch_add_explicit(&v223->__shared_owners_, 1uLL, memory_order_relaxed);
            std::mutex::unlock(v217);
            atomic_fetch_add_explicit(&v223->__shared_owners_, 1uLL, memory_order_relaxed);
            sub_10004D2C8(v223);
            char v225 = 0;
            goto LABEL_288;
          }
        }
        else
        {
          uint64_t v224 = 0;
        }
        std::mutex::unlock(v217);
        v223 = 0;
        char v225 = 1;
LABEL_288:
        (*(void (**)(std::string *__return_ptr, uint64_t, void, uint64_t, void *, const CFBooleanRef, void))(*(void *)v224 + 104))(&__str, v224, v702, 1, qword_101B0FF88, kCFBooleanFalse, 0);
        if ((v225 & 1) == 0) {
          sub_10004D2C8(v223);
        }
        v226 = (BOOL *)__str.__r_.__value_.__r.__words[0];
        if (__str.__r_.__value_.__r.__words[0]) {
          v227 = sub_100080934;
        }
        else {
          v227 = 0;
        }
        if (v227)
        {
          buf[0].__r_.__value_.__s.__data_[0] = 0;
          if (__str.__r_.__value_.__r.__words[0])
          {
            CFTypeID v228 = CFGetTypeID(__str.__r_.__value_.__l.__data_);
            if (v228 == CFBooleanGetTypeID()) {
              ctu::cf::assign((ctu::cf *)buf, v226, v229);
            }
            if (buf[0].__r_.__value_.__s.__data_[0])
            {
              v230 = *v25;
              if (os_log_type_enabled(*v25, OS_LOG_TYPE_DEFAULT))
              {
                LOWORD(buf[0].__r_.__value_.__l.__data_) = 0;
                _os_log_impl((void *)&_mh_execute_header, v230, OS_LOG_TYPE_DEFAULT, "#I InternationalRoaming used", (uint8_t *)buf, 2u);
              }
              *(unsigned char *)(v694 + 19) = 1;
            }
          }
        }
        sub_1000577C4((const void **)&__str.__r_.__value_.__l.__data_);
        v231 = &qword_101B0FDE0;
        LOBYTE(v231) = atomic_load_explicit((atomic_uchar *volatile)&qword_101B0FDE0, memory_order_acquire);
        if ((v231 & 1) == 0 && __cxa_guard_acquire(&qword_101B0FDE0))
        {
          buf[0].__r_.__value_.__r.__words[0] = (std::string::size_type)@"NRSlicing";
          buf[0].__r_.__value_.__l.__size_ = (std::string::size_type)@"UseOnlyXRForLLPHS";
          sub_100367E88(qword_101B0FFA0, buf, 2uLL);
          __cxa_atexit((void (*)(void *))sub_100367F0C, qword_101B0FFA0, (void *)&_mh_execute_header);
          __cxa_guard_release(&qword_101B0FDE0);
          uint64_t v5 = (uint64_t)v686;
        }
        __str.__r_.__value_.__r.__words[0] = 0;
        v232 = (std::mutex *)Registry::getServiceMap(v231, *(Registry **)(v5 + 104));
        v233 = v232;
        std::string::size_type v234 = v30;
        if (v30 < 0)
        {
          v235 = (unsigned __int8 *)(v30 & 0x7FFFFFFFFFFFFFFFLL);
          uint64_t v236 = 5381;
          do
          {
            std::string::size_type v234 = v236;
            unsigned int v237 = *v235++;
            uint64_t v236 = (33 * v236) ^ v237;
          }
          while (v237);
        }
        std::mutex::lock(v232);
        buf[0].__r_.__value_.__r.__words[0] = v234;
        v238 = sub_10004D37C(&v233[1].__m_.__sig, (unint64_t *)buf);
        if (v238)
        {
          uint64_t v240 = v238[3];
          v239 = (std::__shared_weak_count *)v238[4];
          if (v239)
          {
            atomic_fetch_add_explicit(&v239->__shared_owners_, 1uLL, memory_order_relaxed);
            std::mutex::unlock(v233);
            atomic_fetch_add_explicit(&v239->__shared_owners_, 1uLL, memory_order_relaxed);
            sub_10004D2C8(v239);
            char v241 = 0;
            goto LABEL_310;
          }
        }
        else
        {
          uint64_t v240 = 0;
        }
        std::mutex::unlock(v233);
        v239 = 0;
        char v241 = 1;
LABEL_310:
        (*(void (**)(std::string *__return_ptr, uint64_t, void, uint64_t, void *, const CFBooleanRef, void))(*(void *)v240 + 104))(&__str, v240, v702, 1, qword_101B0FFA0, kCFBooleanFalse, 0);
        if ((v241 & 1) == 0) {
          sub_10004D2C8(v239);
        }
        int v242 = (BOOL *)__str.__r_.__value_.__r.__words[0];
        if (__str.__r_.__value_.__r.__words[0]) {
          char v243 = sub_100080934;
        }
        else {
          char v243 = 0;
        }
        if (v243)
        {
          buf[0].__r_.__value_.__s.__data_[0] = 0;
          if (__str.__r_.__value_.__r.__words[0])
          {
            CFTypeID v244 = CFGetTypeID(__str.__r_.__value_.__l.__data_);
            if (v244 == CFBooleanGetTypeID()) {
              ctu::cf::assign((ctu::cf *)buf, v242, v245);
            }
            if (buf[0].__r_.__value_.__s.__data_[0])
            {
              v246 = *v25;
              if (os_log_type_enabled(*v25, OS_LOG_TYPE_DEFAULT))
              {
                LOWORD(buf[0].__r_.__value_.__l.__data_) = 0;
                _os_log_impl((void *)&_mh_execute_header, v246, OS_LOG_TYPE_DEFAULT, "#I UseOnlyXRForLLPHS used", (uint8_t *)buf, 2u);
              }
              *(unsigned char *)(v694 + 20) = 1;
            }
          }
        }
        sub_1000577C4((const void **)&__str.__r_.__value_.__l.__data_);
        v695 = (os_log_t *)(*(uint64_t (**)(void, void))(**(void **)(v5 + 48) + 16))(*(void *)(v5 + 48), v702);
        LODWORD(buf[0].__r_.__value_.__l.__data_) = v702;
        char v247 = sub_10003B194(v693, (int *)buf);
        uint64_t v248 = *v247;
        uint64_t v249 = *(void *)(*v247 + 32);
        v690 = (uint64_t *)(*v247 + 32);
        for (uint64_t i = *(void *)(*v247 + 40); i != v249; TrafficDescriptor::~TrafficDescriptor((TrafficDescriptor *)(i - 304)))
          ;
        *(void *)(v248 + 40) = v249;
        v723.__r_.__value_.__r.__words[0] = 0;
        v251 = &qword_101B0FE28;
        LOBYTE(v251) = atomic_load_explicit((atomic_uchar *volatile)&qword_101B0FE28, memory_order_acquire);
        if ((v251 & 1) == 0 && __cxa_guard_acquire(&qword_101B0FE28))
        {
          buf[0].__r_.__value_.__r.__words[0] = (std::string::size_type)@"NRSlicing";
          buf[0].__r_.__value_.__l.__size_ = (std::string::size_type)@"TrafficDescriptors";
          sub_100367E88(qword_101B10078, buf, 2uLL);
          __cxa_atexit((void (*)(void *))sub_100367F0C, qword_101B10078, (void *)&_mh_execute_header);
          __cxa_guard_release(&qword_101B0FE28);
          uint64_t v5 = (uint64_t)v686;
        }
        v252 = (std::mutex *)Registry::getServiceMap(v251, *(Registry **)(v5 + 104));
        v253 = v252;
        std::string::size_type v254 = v30;
        if (v30 < 0)
        {
          uint64_t v255 = (unsigned __int8 *)(v30 & 0x7FFFFFFFFFFFFFFFLL);
          uint64_t v256 = 5381;
          do
          {
            std::string::size_type v254 = v256;
            unsigned int v257 = *v255++;
            uint64_t v256 = (33 * v256) ^ v257;
          }
          while (v257);
        }
        std::mutex::lock(v252);
        buf[0].__r_.__value_.__r.__words[0] = v254;
        v258 = sub_10004D37C(&v253[1].__m_.__sig, (unint64_t *)buf);
        if (v258)
        {
          uint64_t v260 = v258[3];
          long long v259 = (std::__shared_weak_count *)v258[4];
          if (v259)
          {
            atomic_fetch_add_explicit(&v259->__shared_owners_, 1uLL, memory_order_relaxed);
            std::mutex::unlock(v253);
            atomic_fetch_add_explicit(&v259->__shared_owners_, 1uLL, memory_order_relaxed);
            sub_10004D2C8(v259);
            char v261 = 0;
            goto LABEL_335;
          }
        }
        else
        {
          uint64_t v260 = 0;
        }
        std::mutex::unlock(v253);
        long long v259 = 0;
        char v261 = 1;
LABEL_335:
        (*(void (**)(std::string *__return_ptr, uint64_t, void, uint64_t, void *, void, void))(*(void *)v260 + 104))(&v725, v260, v702, 1, qword_101B10078, 0, 0);
        sub_100044D6C(&__str, (CFTypeRef *)&v725.__r_.__value_.__l.__data_);
        buf[0].__r_.__value_.__r.__words[0] = v723.__r_.__value_.__r.__words[0];
        v723.__r_.__value_.__r.__words[0] = __str.__r_.__value_.__r.__words[0];
        __str.__r_.__value_.__r.__words[0] = 0;
        sub_100044D00((const void **)&buf[0].__r_.__value_.__l.__data_);
        sub_100044D00((const void **)&__str.__r_.__value_.__l.__data_);
        sub_1000577C4((const void **)&v725.__r_.__value_.__l.__data_);
        if ((v261 & 1) == 0) {
          sub_10004D2C8(v259);
        }
        if (v723.__r_.__value_.__r.__words[0]) {
          __int16 v262 = sub_100083F10;
        }
        else {
          __int16 v262 = 0;
        }
        if (v262)
        {
          CFIndex Count = CFArrayGetCount((CFArrayRef)v723.__r_.__value_.__l.__data_);
          if (Count >= 1)
          {
            CFIndex v264 = 0;
            while (1)
            {
              CFDictionaryRef theDict = 0;
              buf[0].__r_.__value_.__r.__words[0] = (std::string::size_type)CFArrayGetValueAtIndex((CFArrayRef)v723.__r_.__value_.__l.__data_, v264);
              sub_10004EFE4(&theDict, (CFTypeRef *)&buf[0].__r_.__value_.__l.__data_);
              if (theDict ? sub_100080778 : 0) {
                break;
              }
LABEL_418:
              sub_100057D78((const void **)&theDict);
              if (Count == ++v264) {
                goto LABEL_419;
              }
            }
            memset(v722, 0, sizeof(v722));
            long long v720 = 0u;
            long long v721 = 0u;
            memset(v719, 0, sizeof(v719));
            *(_OWORD *)__p = 0u;
            long long v718 = 0u;
            long long v715 = 0u;
            long long v716 = 0u;
            long long v714 = 0u;
            memset(buf, 0, sizeof(buf));
            TrafficDescriptor::TrafficDescriptor((TrafficDescriptor *)buf);
            if (CFDictionaryGetValue(theDict, @"Domain"))
            {
              memset(&__str, 0, sizeof(__str));
              ctu::cf::assign();
              v725.__r_.__value_.__r.__words[0] = __str.__r_.__value_.__l.__size_;
              v266 = (void *)__str.__r_.__value_.__r.__words[0];
              *(std::string::size_type *)((char *)v725.__r_.__value_.__r.__words + 7) = *(std::string::size_type *)((char *)&__str.__r_.__value_.__r.__words[1] + 7);
              char v267 = HIBYTE(__str.__r_.__value_.__r.__words[2]);
              if (LOBYTE(v719[0]))
              {
                if (SHIBYTE(v718) < 0) {
                  operator delete(__p[1]);
                }
                __p[1] = v266;
                *(void *)&long long v718 = v725.__r_.__value_.__r.__words[0];
                *(void *)((char *)&v718 + 7) = *(std::string::size_type *)((char *)v725.__r_.__value_.__r.__words + 7);
                HIBYTE(v718) = v267;
              }
              else
              {
                __p[1] = __str.__r_.__value_.__l.__data_;
                *(void *)&long long v718 = v725.__r_.__value_.__r.__words[0];
                *(void *)((char *)&v718 + 7) = *(std::string::size_type *)((char *)v725.__r_.__value_.__r.__words + 7);
                HIBYTE(v718) = *((unsigned char *)&__str.__r_.__value_.__s + 23);
                LOBYTE(v719[0]) = 1;
              }
            }
            if (CFDictionaryGetValue(theDict, @"Dnn"))
            {
              memset(&__str, 0, sizeof(__str));
              ctu::cf::assign();
              v725.__r_.__value_.__r.__words[0] = __str.__r_.__value_.__l.__size_;
              v268 = (void *)__str.__r_.__value_.__r.__words[0];
              *(std::string::size_type *)((char *)v725.__r_.__value_.__r.__words + 7) = *(std::string::size_type *)((char *)&__str.__r_.__value_.__r.__words[1] + 7);
              char v269 = HIBYTE(__str.__r_.__value_.__r.__words[2]);
              if (LOBYTE(v722[3]))
              {
                if (SHIBYTE(v722[2]) < 0) {
                  operator delete(v722[0]);
                }
                v722[0] = v268;
                v722[1] = v725.__r_.__value_.__l.__data_;
                *(void **)((char *)&v722[1] + 7) = *(void **)((char *)v725.__r_.__value_.__r.__words + 7);
                HIBYTE(v722[2]) = v269;
              }
              else
              {
                v722[0] = __str.__r_.__value_.__l.__data_;
                v722[1] = v725.__r_.__value_.__l.__data_;
                *(void **)((char *)&v722[1] + 7) = *(void **)((char *)v725.__r_.__value_.__r.__words + 7);
                HIBYTE(v722[2]) = *((unsigned char *)&__str.__r_.__value_.__s + 23);
                LOBYTE(v722[3]) = 1;
              }
            }
            if (CFDictionaryGetValue(theDict, @"RsDnn"))
            {
              memset(&__str, 0, sizeof(__str));
              ctu::cf::assign();
              v725.__r_.__value_.__r.__words[0] = __str.__r_.__value_.__l.__size_;
              v270 = (void *)__str.__r_.__value_.__r.__words[0];
              *(std::string::size_type *)((char *)v725.__r_.__value_.__r.__words + 7) = *(std::string::size_type *)((char *)&__str.__r_.__value_.__r.__words[1] + 7);
              char v271 = HIBYTE(__str.__r_.__value_.__r.__words[2]);
              if (LOBYTE(v722[7]))
              {
                if (SHIBYTE(v722[6]) < 0) {
                  operator delete(v722[4]);
                }
                v722[4] = v270;
                v722[5] = v725.__r_.__value_.__l.__data_;
                *(void **)((char *)&v722[5] + 7) = *(void **)((char *)v725.__r_.__value_.__r.__words + 7);
                HIBYTE(v722[6]) = v271;
              }
              else
              {
                v722[4] = __str.__r_.__value_.__l.__data_;
                v722[5] = v725.__r_.__value_.__l.__data_;
                *(void **)((char *)&v722[5] + 7) = *(void **)((char *)v725.__r_.__value_.__r.__words + 7);
                HIBYTE(v722[6]) = *((unsigned char *)&__str.__r_.__value_.__s + 23);
                LOBYTE(v722[7]) = 1;
              }
            }
            Value = (unsigned __int16 *)CFDictionaryGetValue(theDict, @"Port");
            v273 = Value;
            if (Value)
            {
              LOWORD(__str.__r_.__value_.__l.__data_) = 0;
              CFTypeID v274 = CFGetTypeID(Value);
              if (v274 == CFNumberGetTypeID()) {
                ctu::cf::assign((ctu::cf *)&__str, v273, v275);
              }
              WORD2(v720) = __str.__r_.__value_.__l.__data_;
              BYTE6(v720) = 1;
            }
            v276 = (void *)CFDictionaryGetValue(theDict, @"PortRangeStart");
            if (v276)
            {
              v277 = (void *)CFDictionaryGetValue(theDict, @"PortRangeEnd");
              if (v277)
              {
                LOWORD(__str.__r_.__value_.__l.__data_) = 0;
                CFTypeID v278 = CFGetTypeID(v276);
                if (v278 == CFNumberGetTypeID()) {
                  ctu::cf::assign((ctu::cf *)&__str, (unsigned __int16 *)v276, v279);
                }
                unsigned int data_low = LOWORD(__str.__r_.__value_.__l.__data_);
                LOWORD(__str.__r_.__value_.__l.__data_) = 0;
                CFTypeID v281 = CFGetTypeID(v277);
                if (v281 == CFNumberGetTypeID()) {
                  ctu::cf::assign((ctu::cf *)&__str, (unsigned __int16 *)v277, v282);
                }
                if (data_low <= LOWORD(__str.__r_.__value_.__l.__data_))
                {
                  if (BYTE12(v720))
                  {
                    WORD4(v720) = data_low;
                    WORD5(v720) = __str.__r_.__value_.__l.__data_;
                  }
                  else
                  {
                    DWORD2(v720) = data_low | (LOWORD(__str.__r_.__value_.__l.__data_) << 16);
                    BYTE12(v720) = 1;
                  }
                }
              }
            }
            if (CFDictionaryGetValue(theDict, @"Address"))
            {
              memset(&v725, 0, sizeof(v725));
              memset(&__str, 0, sizeof(__str));
              ctu::cf::assign();
              std::string v724 = __str;
              CSIPacketAddress::CSIPacketAddress();
              if (SHIBYTE(v724.__r_.__value_.__r.__words[2]) < 0) {
                operator delete(v724.__r_.__value_.__l.__data_);
              }
              v283 = (unsigned __int8 *)CFDictionaryGetValue(theDict, @"AddressPrefix");
              v284 = v283;
              if (v283)
              {
                __str.__r_.__value_.__s.__data_[0] = 0;
                CFTypeID v285 = CFGetTypeID(v283);
                if (v285 == CFNumberGetTypeID()) {
                  ctu::cf::assign((ctu::cf *)&__str, v284, v286);
                }
                CSIPacketAddress::setPrefixLen((CSIPacketAddress *)&v725, __str.__r_.__value_.__s.__data_[0]);
              }
              sub_1008B7C40((CSIPacketAddress *)((char *)v719 + 8), (const CSIPacketAddress *)&v725);
            }
            v287 = (unsigned __int16 *)CFDictionaryGetValue(theDict, @"IpProtocol");
            v288 = v287;
            if (v287)
            {
              LOWORD(__str.__r_.__value_.__l.__data_) = 0;
              CFTypeID v289 = CFGetTypeID(v287);
              if (v289 == CFNumberGetTypeID()) {
                ctu::cf::assign((ctu::cf *)&__str, v288, v290);
              }
              HIWORD(v720) = __str.__r_.__value_.__l.__data_;
              LOBYTE(v721) = 1;
            }
            v291 = (void *)CFDictionaryGetValue(theDict, @"TrafficClass");
            if (v291)
            {
              CFTypeID TypeID = CFNumberGetTypeID();
              if (TypeID == CFGetTypeID(v291))
              {
                LODWORD(__str.__r_.__value_.__l.__data_) = 0;
                CFTypeID v293 = CFGetTypeID(v291);
                if (v293 == CFNumberGetTypeID()) {
                  ctu::cf::assign((ctu::cf *)&__str, (unsigned int *)v291, v294);
                }
                DWORD1(v721) = __str.__r_.__value_.__l.__data_;
                BYTE8(v721) = 1;
              }
            }
            if (CFDictionaryGetValue(theDict, @"App"))
            {
              memset(&v725, 0, sizeof(v725));
              memset(&__str, 0, sizeof(__str));
              ctu::cf::assign();
              std::string v725 = __str;
              std::string::size_type size = __str.__r_.__value_.__l.__size_;
              char v296 = HIBYTE(__str.__r_.__value_.__r.__words[2]);
              if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                std::string::size_type size = HIBYTE(__str.__r_.__value_.__r.__words[2]);
              }
              if (size)
              {
                sub_100093B44(&buf[2], &v725);
                goto LABEL_406;
              }
              goto LABEL_407;
            }
            if (CFDictionaryGetValue(theDict, @"EApp"))
            {
              memset(&v725, 0, sizeof(v725));
              memset(&__str, 0, sizeof(__str));
              ctu::cf::assign();
              std::string v725 = __str;
              std::string::size_type v297 = __str.__r_.__value_.__l.__size_;
              char v296 = HIBYTE(__str.__r_.__value_.__r.__words[2]);
              if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                std::string::size_type v297 = HIBYTE(__str.__r_.__value_.__r.__words[2]);
              }
              if (v297)
              {
                sub_1000791C0(&buf[2], (char **)&kDefaultAppBundleId);
                sub_100093B44((std::string *)&buf[0].__r_.__value_.__r.__words[2], &v725);
LABEL_406:
                char v296 = HIBYTE(v725.__r_.__value_.__r.__words[2]);
              }
LABEL_407:
              if (v296 < 0) {
                operator delete(v725.__r_.__value_.__l.__data_);
              }
            }
            v298 = *v695;
            if (os_log_type_enabled(*v695, OS_LOG_TYPE_DEFAULT))
            {
              TrafficDescriptor::toString((uint64_t *)&__str, (TrafficDescriptor *)buf);
              p_str = &__str;
              if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
                p_str = (std::string *)__str.__r_.__value_.__r.__words[0];
              }
              LODWORD(v725.__r_.__value_.__l.__data_) = 136446210;
              *(std::string::size_type *)((char *)v725.__r_.__value_.__r.__words + 4) = (std::string::size_type)p_str;
              _os_log_impl((void *)&_mh_execute_header, v298, OS_LOG_TYPE_DEFAULT, "#I TrafficDescriptor from CB: %{public}s", (uint8_t *)&v725, 0xCu);
              if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
                operator delete(__str.__r_.__value_.__l.__data_);
              }
            }
            unint64_t v300 = *(void *)(v248 + 40);
            if (v300 >= *(void *)(v248 + 48))
            {
              uint64_t v301 = sub_100B06024(v690, (const TrafficDescriptor *)buf);
            }
            else
            {
              TrafficDescriptor::TrafficDescriptor(*(TrafficDescriptor **)(v248 + 40), (const TrafficDescriptor *)buf);
              uint64_t v301 = v300 + 304;
              *(void *)(v248 + 40) = v300 + 304;
            }
            *(void *)(v248 + 40) = v301;
            TrafficDescriptor::~TrafficDescriptor((TrafficDescriptor *)buf);
            goto LABEL_418;
          }
        }
LABEL_419:
        sub_100044D00((const void **)&v723.__r_.__value_.__l.__data_);
        v691 = (os_log_t *)(*(uint64_t (**)(void, void))(**(void **)(v5 + 48) + 16))(*(void *)(v5 + 48), v702);
        std::string::size_type v302 = v699;
        LODWORD(buf[0].__r_.__value_.__l.__data_) = v702;
        uint64_t v303 = *sub_10003B194(v693, (int *)buf);
        v304 = (void **)(v303 + 88);
        v688 = (uint64_t ***)(v303 + 80);
        sub_100B06D68(v303 + 80, *v304);
        *(void *)(v303 + 80) = v304;
        uint64_t v687 = v303;
        *(void *)(v303 + 96) = 0;
        v696 = (uint64_t **)(v303 + 88);
        *v304 = 0;
        if (!*(void *)(v5 + 4736))
        {
          v305 = operator new(0x30uLL);
          v305[1] = 0;
          v305[2] = 0;
          void *v305 = off_1019BEAC0;
          v305[5] = 0;
          v305[4] = 0;
          v305[3] = v305 + 4;
          *(void *)(v5 + 4736) = v305 + 3;
          v306 = *(std::__shared_weak_count **)(v5 + 4744);
          *(void *)(v5 + 4744) = v305;
          if (v306) {
            sub_10004D2C8(v306);
          }
        }
        CFArrayRef theArray = 0;
        v307 = &qword_101B0FE30;
        LOBYTE(v307) = atomic_load_explicit((atomic_uchar *volatile)&qword_101B0FE30, memory_order_acquire);
        if ((v307 & 1) == 0 && __cxa_guard_acquire(&qword_101B0FE30))
        {
          buf[0].__r_.__value_.__r.__words[0] = (std::string::size_type)@"NRSlicing";
          buf[0].__r_.__value_.__l.__size_ = (std::string::size_type)@"AppCategories";
          sub_100367E88(qword_101B10090, buf, 2uLL);
          __cxa_atexit((void (*)(void *))sub_100367F0C, qword_101B10090, (void *)&_mh_execute_header);
          __cxa_guard_release(&qword_101B0FE30);
          std::string::size_type v302 = v699;
          uint64_t v5 = (uint64_t)v686;
        }
        v308 = (std::mutex *)Registry::getServiceMap(v307, *(Registry **)(v5 + 104));
        v309 = v308;
        std::string::size_type v310 = v302;
        if ((v302 & 0x8000000000000000) != 0)
        {
          v311 = (unsigned __int8 *)(v302 & 0x7FFFFFFFFFFFFFFFLL);
          uint64_t v312 = 5381;
          do
          {
            std::string::size_type v310 = v312;
            unsigned int v313 = *v311++;
            uint64_t v312 = (33 * v312) ^ v313;
          }
          while (v313);
        }
        std::mutex::lock(v308);
        buf[0].__r_.__value_.__r.__words[0] = v310;
        v314 = sub_10004D37C(&v309[1].__m_.__sig, (unint64_t *)buf);
        if (v314)
        {
          uint64_t v316 = v314[3];
          v315 = (std::__shared_weak_count *)v314[4];
          if (v315)
          {
            atomic_fetch_add_explicit(&v315->__shared_owners_, 1uLL, memory_order_relaxed);
            std::mutex::unlock(v309);
            atomic_fetch_add_explicit(&v315->__shared_owners_, 1uLL, memory_order_relaxed);
            sub_10004D2C8(v315);
            char v317 = 0;
            goto LABEL_431;
          }
        }
        else
        {
          uint64_t v316 = 0;
        }
        std::mutex::unlock(v309);
        v315 = 0;
        char v317 = 1;
LABEL_431:
        (*(void (**)(std::string *__return_ptr, uint64_t, void, uint64_t, void *, void, void))(*(void *)v316 + 104))(&v725, v316, v702, 1, qword_101B10090, 0, 0);
        sub_100044D6C(&__str, (CFTypeRef *)&v725.__r_.__value_.__l.__data_);
        buf[0].__r_.__value_.__r.__words[0] = (std::string::size_type)theArray;
        CFArrayRef theArray = (CFArrayRef)__str.__r_.__value_.__r.__words[0];
        __str.__r_.__value_.__r.__words[0] = 0;
        sub_100044D00((const void **)&buf[0].__r_.__value_.__l.__data_);
        sub_100044D00((const void **)&__str.__r_.__value_.__l.__data_);
        sub_1000577C4((const void **)&v725.__r_.__value_.__l.__data_);
        if ((v317 & 1) == 0) {
          sub_10004D2C8(v315);
        }
        if (theArray) {
          v318 = sub_100083F10;
        }
        else {
          v318 = 0;
        }
        if (v318)
        {
          CFIndex v319 = CFArrayGetCount(theArray);
          if (v319 >= 1)
          {
            CFIndex v320 = 0;
            while (1)
            {
              CFDictionaryRef v710 = 0;
              buf[0].__r_.__value_.__r.__words[0] = (std::string::size_type)CFArrayGetValueAtIndex(theArray, v320);
              sub_10004EFE4(&v710, (CFTypeRef *)&buf[0].__r_.__value_.__l.__data_);
              if (v710 ? sub_100080778 : 0) {
                break;
              }
LABEL_540:
              sub_100057D78((const void **)&v710);
              if (++v320 == v319) {
                goto LABEL_558;
              }
            }
            memset(&__str, 0, sizeof(__str));
            memset(&v725, 0, sizeof(v725));
            memset(&v724, 0, sizeof(v724));
            if (CFDictionaryGetValue(v710, @"Name"))
            {
              memset(buf, 0, 24);
              ctu::cf::assign();
              v723.__r_.__value_.__r.__words[0] = buf[0].__r_.__value_.__l.__size_;
              std::string::size_type v322 = buf[0].__r_.__value_.__r.__words[0];
              *(std::string::size_type *)((char *)v723.__r_.__value_.__r.__words + 7) = *(std::string::size_type *)((char *)&buf[0].__r_.__value_.__r.__words[1] + 7);
              char v323 = HIBYTE(buf[0].__r_.__value_.__r.__words[2]);
              if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
                operator delete(__str.__r_.__value_.__l.__data_);
              }
              __str.__r_.__value_.__r.__words[0] = v322;
              __str.__r_.__value_.__l.__size_ = v723.__r_.__value_.__r.__words[0];
              *(std::string::size_type *)((char *)&__str.__r_.__value_.__r.__words[1] + 7) = *(std::string::size_type *)((char *)v723.__r_.__value_.__r.__words + 7);
              *((unsigned char *)&__str.__r_.__value_.__s + 23) = v323;
            }
            v324 = (unint64_t *)CFDictionaryGetValue(v710, @"ID");
            v325 = v324;
            if (v324)
            {
              buf[0].__r_.__value_.__r.__words[0] = 0;
              CFTypeID v326 = CFGetTypeID(v324);
              if (v326 == CFNumberGetTypeID()) {
                ctu::cf::assign((ctu::cf *)buf, v325, v327);
              }
              unint64_t v328 = buf[0].__r_.__value_.__r.__words[0];
            }
            else
            {
              unint64_t v328 = 0;
            }
            if (CFDictionaryGetValue(v710, @"Apps"))
            {
              memset(&v723, 0, sizeof(v723));
              memset(buf, 0, 24);
              ctu::cf::assign();
              std::string v723 = buf[0];
              ctu::split_any_copy();
              sub_10005CBB4((uint64_t *)&v724);
              std::string v724 = buf[0];
              CFDictionaryRef theDict = (CFDictionaryRef)buf;
              memset(buf, 0, 24);
              sub_100047F64((void ***)&theDict);
              if (SHIBYTE(v723.__r_.__value_.__r.__words[2]) < 0) {
                operator delete(v723.__r_.__value_.__l.__data_);
              }
            }
            v329 = (void *)CFDictionaryGetValue(v710, @"ACs");
            v330 = v329;
            if (v329)
            {
              CFTypeID v331 = CFGetTypeID(v329);
              if (v331 == CFStringGetTypeID())
              {
                memset(&v723, 0, sizeof(v723));
                memset(buf, 0, 24);
                ctu::cf::assign();
                std::string v723 = buf[0];
                memset(buf, 0, 24);
                ctu::split_any_copy();
                std::string::size_type v333 = buf[0].__r_.__value_.__l.__size_;
                for (uint64_t j = (const std::string *)buf[0].__r_.__value_.__r.__words[0]; j != (const std::string *)v333; ++j)
                {
                  unint64_t v334 = std::stoull(j, 0, 10);
                  unint64_t v335 = v334;
                  if (v334)
                  {
                    std::string::size_type v336 = v725.__r_.__value_.__l.__size_;
                    if (v725.__r_.__value_.__l.__size_ >= v725.__r_.__value_.__r.__words[2])
                    {
                      v338 = (void *)v725.__r_.__value_.__r.__words[0];
                      uint64_t v339 = (uint64_t)(v725.__r_.__value_.__l.__size_ - v725.__r_.__value_.__r.__words[0]) >> 3;
                      unint64_t v340 = v339 + 1;
                      if ((unint64_t)(v339 + 1) >> 61) {
                        sub_10010562C();
                      }
                      int64_t v341 = v725.__r_.__value_.__r.__words[2] - v725.__r_.__value_.__r.__words[0];
                      if ((uint64_t)(v725.__r_.__value_.__r.__words[2] - v725.__r_.__value_.__r.__words[0]) >> 2 > v340) {
                        unint64_t v340 = v341 >> 2;
                      }
                      if ((unint64_t)v341 >= 0x7FFFFFFFFFFFFFF8) {
                        unint64_t v342 = 0x1FFFFFFFFFFFFFFFLL;
                      }
                      else {
                        unint64_t v342 = v340;
                      }
                      if (v342)
                      {
                        v343 = (char *)sub_10004EF74((uint64_t)&v725.__r_.__value_.__r.__words[2], v342);
                        std::string::size_type v336 = v725.__r_.__value_.__l.__size_;
                        v338 = (void *)v725.__r_.__value_.__r.__words[0];
                      }
                      else
                      {
                        v343 = 0;
                      }
                      v344 = (unint64_t *)&v343[8 * v339];
                      unint64_t *v344 = v335;
                      std::string::size_type v337 = (std::string::size_type)(v344 + 1);
                      while ((void *)v336 != v338)
                      {
                        unint64_t v345 = *(void *)(v336 - 8);
                        v336 -= 8;
                        *--v344 = v345;
                      }
                      v725.__r_.__value_.__r.__words[0] = (std::string::size_type)v344;
                      v725.__r_.__value_.__l.__size_ = v337;
                      v725.__r_.__value_.__r.__words[2] = (std::string::size_type)&v343[8 * v342];
                      if (v338) {
                        operator delete(v338);
                      }
                    }
                    else
                    {
                      *(void *)v725.__r_.__value_.__l.__size_ = v334;
                      std::string::size_type v337 = v336 + 8;
                    }
                    v725.__r_.__value_.__l.__size_ = v337;
                  }
                }
                CFDictionaryRef theDict = (CFDictionaryRef)buf;
                sub_100047F64((void ***)&theDict);
                if (SHIBYTE(v723.__r_.__value_.__r.__words[2]) < 0)
                {
                  operator delete(v723.__r_.__value_.__l.__data_);
                  if (!v328) {
                    goto LABEL_536;
                  }
                  goto LABEL_490;
                }
              }
              else if (v331 == CFNumberGetTypeID())
              {
                buf[0].__r_.__value_.__r.__words[0] = 0;
                CFTypeID v346 = CFGetTypeID(v330);
                if (v346 == CFNumberGetTypeID()) {
                  ctu::cf::assign((ctu::cf *)buf, (unint64_t *)v330, v347);
                }
                std::string::size_type v348 = buf[0].__r_.__value_.__r.__words[0];
                if (buf[0].__r_.__value_.__r.__words[0])
                {
                  std::string::size_type v349 = v725.__r_.__value_.__l.__size_;
                  if (v725.__r_.__value_.__l.__size_ >= v725.__r_.__value_.__r.__words[2])
                  {
                    v377 = (void *)v725.__r_.__value_.__r.__words[0];
                    uint64_t v378 = (uint64_t)(v725.__r_.__value_.__l.__size_ - v725.__r_.__value_.__r.__words[0]) >> 3;
                    unint64_t v379 = v378 + 1;
                    if ((unint64_t)(v378 + 1) >> 61) {
                      sub_10010562C();
                    }
                    int64_t v380 = v725.__r_.__value_.__r.__words[2] - v725.__r_.__value_.__r.__words[0];
                    if ((uint64_t)(v725.__r_.__value_.__r.__words[2] - v725.__r_.__value_.__r.__words[0]) >> 2 > v379) {
                      unint64_t v379 = v380 >> 2;
                    }
                    if ((unint64_t)v380 >= 0x7FFFFFFFFFFFFFF8) {
                      unint64_t v381 = 0x1FFFFFFFFFFFFFFFLL;
                    }
                    else {
                      unint64_t v381 = v379;
                    }
                    if (v381)
                    {
                      v382 = (char *)sub_10004EF74((uint64_t)&v725.__r_.__value_.__r.__words[2], v381);
                      std::string::size_type v349 = v725.__r_.__value_.__l.__size_;
                      v377 = (void *)v725.__r_.__value_.__r.__words[0];
                    }
                    else
                    {
                      v382 = 0;
                    }
                    v383 = (std::string::size_type *)&v382[8 * v378];
                    std::string::size_type *v383 = v348;
                    std::string::size_type v350 = (std::string::size_type)(v383 + 1);
                    while ((void *)v349 != v377)
                    {
                      std::string::size_type v384 = *(void *)(v349 - 8);
                      v349 -= 8;
                      *--v383 = v384;
                    }
                    v725.__r_.__value_.__r.__words[0] = (std::string::size_type)v383;
                    v725.__r_.__value_.__l.__size_ = v350;
                    v725.__r_.__value_.__r.__words[2] = (std::string::size_type)&v382[8 * v381];
                    if (v377) {
                      operator delete(v377);
                    }
                  }
                  else
                  {
                    *(void *)v725.__r_.__value_.__l.__size_ = buf[0].__r_.__value_.__r.__words[0];
                    std::string::size_type v350 = v349 + 8;
                  }
                  v725.__r_.__value_.__l.__size_ = v350;
                  if (!v328) {
                    goto LABEL_536;
                  }
                  goto LABEL_490;
                }
              }
              else
              {
                v351 = v686[5];
                if (os_log_type_enabled(v351, OS_LOG_TYPE_DEFAULT))
                {
                  LODWORD(buf[0].__r_.__value_.__l.__data_) = 134217984;
                  *(std::string::size_type *)((char *)buf[0].__r_.__value_.__r.__words + 4) = v331;
                  _os_log_impl((void *)&_mh_execute_header, v351, OS_LOG_TYPE_DEFAULT, "#I Wrong ACs type: %lu", (uint8_t *)buf, 0xCu);
                }
              }
            }
            if (!v328)
            {
LABEL_536:
              buf[0].__r_.__value_.__r.__words[0] = (std::string::size_type)&v724;
              sub_100047F64((void ***)buf);
              if (v725.__r_.__value_.__r.__words[0])
              {
                v725.__r_.__value_.__l.__size_ = v725.__r_.__value_.__r.__words[0];
                operator delete(v725.__r_.__value_.__l.__data_);
              }
              if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
                operator delete(__str.__r_.__value_.__l.__data_);
              }
              goto LABEL_540;
            }
LABEL_490:
            std::string::size_type v352 = HIBYTE(__str.__r_.__value_.__r.__words[2]);
            char v353 = HIBYTE(__str.__r_.__value_.__r.__words[2]);
            std::string::size_type v354 = __str.__r_.__value_.__l.__size_;
            if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
              std::string::size_type v355 = HIBYTE(__str.__r_.__value_.__r.__words[2]);
            }
            else {
              std::string::size_type v355 = __str.__r_.__value_.__l.__size_;
            }
            if (!v355)
            {
              uint64_t v356 = v686[592];
              v359 = *(void **)(v356 + 8);
              v357 = (void *)(v356 + 8);
              v358 = v359;
              if (v359)
              {
                v360 = v357;
                do
                {
                  unint64_t v361 = v358[4];
                  BOOL v362 = v361 >= v328;
                  if (v361 >= v328) {
                    v363 = v358;
                  }
                  else {
                    v363 = v358 + 1;
                  }
                  if (v362) {
                    v360 = v358;
                  }
                  v358 = (void *)*v363;
                }
                while (*v363);
                if (v360 != v357 && v328 >= v360[4])
                {
                  std::string::operator=(&__str, (const std::string *)(v360 + 5));
                  std::string::size_type v352 = HIBYTE(__str.__r_.__value_.__r.__words[2]);
                  std::string::size_type v354 = __str.__r_.__value_.__l.__size_;
                  char v353 = HIBYTE(__str.__r_.__value_.__r.__words[2]);
                }
              }
              if (v353 < 0) {
                std::string::size_type v352 = v354;
              }
              if (!v352)
              {
                std::to_string(buf, v328);
                v364 = std::string::insert(buf, 0, "Genre ", 6uLL);
                std::string::size_type v365 = v364->__r_.__value_.__r.__words[0];
                v723.__r_.__value_.__r.__words[0] = v364->__r_.__value_.__l.__size_;
                *(std::string::size_type *)((char *)v723.__r_.__value_.__r.__words + 7) = *(std::string::size_type *)((char *)&v364->__r_.__value_.__r.__words[1] + 7);
                char v353 = HIBYTE(v364->__r_.__value_.__r.__words[2]);
                v364->__r_.__value_.__l.__size_ = 0;
                v364->__r_.__value_.__r.__words[2] = 0;
                v364->__r_.__value_.__r.__words[0] = 0;
                if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
                  operator delete(__str.__r_.__value_.__l.__data_);
                }
                __str.__r_.__value_.__r.__words[0] = v365;
                __str.__r_.__value_.__l.__size_ = v723.__r_.__value_.__r.__words[0];
                *(std::string::size_type *)((char *)&__str.__r_.__value_.__r.__words[1] + 7) = *(std::string::size_type *)((char *)v723.__r_.__value_.__r.__words + 7);
                *((unsigned char *)&__str.__r_.__value_.__s + 23) = v353;
                if (SHIBYTE(buf[0].__r_.__value_.__r.__words[2]) < 0)
                {
                  operator delete(buf[0].__r_.__value_.__l.__data_);
                  char v353 = HIBYTE(__str.__r_.__value_.__r.__words[2]);
                }
              }
            }
            v366 = *v691;
            if (os_log_type_enabled(*v691, OS_LOG_TYPE_DEFAULT))
            {
              v367 = &__str;
              if (v353 < 0) {
                v367 = (std::string *)__str.__r_.__value_.__r.__words[0];
              }
              LODWORD(buf[0].__r_.__value_.__l.__data_) = 134218242;
              *(std::string::size_type *)((char *)buf[0].__r_.__value_.__r.__words + 4) = v328;
              WORD2(buf[0].__r_.__value_.__r.__words[1]) = 2082;
              *(std::string::size_type *)((char *)&buf[0].__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v367;
              _os_log_impl((void *)&_mh_execute_header, v366, OS_LOG_TYPE_DEFAULT, "#I AppCategory from CB: %llu - %{public}s", (uint8_t *)buf, 0x16u);
              char v353 = HIBYTE(__str.__r_.__value_.__r.__words[2]);
            }
            if (v353 < 0) {
              sub_10004FC84(buf, __str.__r_.__value_.__l.__data_, __str.__r_.__value_.__l.__size_);
            }
            else {
              buf[0] = __str;
            }
            memset(&buf[1], 0, sizeof(std::string));
            sub_1000302C0((char *)&buf[1], (long long *)v724.__r_.__value_.__l.__data_, (long long *)v724.__r_.__value_.__l.__size_, 0xAAAAAAAAAAAAAAABLL* ((uint64_t)(v724.__r_.__value_.__l.__size_ - v724.__r_.__value_.__r.__words[0]) >> 3));
            memset(&buf[2], 0, sizeof(std::string));
            sub_10010556C(buf[2].__r_.__value_.__r.__words, v725.__r_.__value_.__l.__data_, v725.__r_.__value_.__l.__size_, (uint64_t)(v725.__r_.__value_.__l.__size_ - v725.__r_.__value_.__r.__words[0]) >> 3);
            v368 = v696;
            while (1)
            {
              v369 = *v368;
              v370 = v368;
              if (!*v368) {
                break;
              }
              while (1)
              {
                v368 = (uint64_t **)v369;
                unint64_t v371 = v369[4];
                if (v371 > v328) {
                  break;
                }
                if (v371 >= v328)
                {
                  v372 = (char *)v368;
                  goto LABEL_530;
                }
                v369 = v368[1];
                if (!v369)
                {
                  v370 = v368 + 1;
                  goto LABEL_526;
                }
              }
            }
LABEL_526:
            v372 = (char *)operator new(0x70uLL);
            *((void *)v372 + 4) = v328;
            *(_OWORD *)(v372 + 40) = 0u;
            *(_OWORD *)(v372 + 56) = 0u;
            *(_OWORD *)(v372 + 72) = 0u;
            *(_OWORD *)(v372 + 88) = 0u;
            *((void *)v372 + 13) = 0;
            *(void *)v372 = 0;
            *((void *)v372 + 1) = 0;
            *((void *)v372 + 2) = v368;
            *v370 = (uint64_t *)v372;
            v373 = **v688;
            v374 = (uint64_t *)v372;
            if (v373)
            {
              *v688 = (uint64_t **)v373;
              v374 = *v370;
            }
            sub_100046C90(*(uint64_t **)(v687 + 88), v374);
            ++*(void *)(v687 + 96);
LABEL_530:
            v375 = (void **)(v372 + 40);
            if (v372[63] < 0) {
              operator delete(*v375);
            }
            *(_OWORD *)v375 = *(_OWORD *)&buf[0].__r_.__value_.__l.__data_;
            *((void *)v372 + 7) = *((void *)&buf[0].__r_.__value_.__l + 2);
            *((unsigned char *)&buf[0].__r_.__value_.__s + 23) = 0;
            buf[0].__r_.__value_.__s.__data_[0] = 0;
            sub_10005CBB4((uint64_t *)v372 + 8);
            *((_OWORD *)v372 + 4) = *(_OWORD *)&buf[1].__r_.__value_.__l.__data_;
            v376 = (void *)*((void *)v372 + 11);
            *((void *)v372 + 10) = *((void *)&buf[1].__r_.__value_.__l + 2);
            memset(&buf[1], 0, sizeof(std::string));
            if (v376)
            {
              *((void *)v372 + 12) = v376;
              operator delete(v376);
              *((void *)v372 + 11) = 0;
              *((void *)v372 + 12) = 0;
              *((void *)v372 + 13) = 0;
            }
            *(std::string *)(v372 + 88) = buf[2];
            memset(&buf[2], 0, sizeof(std::string));
            v723.__r_.__value_.__r.__words[0] = (std::string::size_type)&buf[1];
            sub_100047F64((void ***)&v723);
            if (SHIBYTE(buf[0].__r_.__value_.__r.__words[2]) < 0) {
              operator delete(buf[0].__r_.__value_.__l.__data_);
            }
            goto LABEL_536;
          }
LABEL_558:
          uint64_t v5 = (uint64_t)v686;
          std::string::size_type v302 = v699;
          if ((*(unsigned int (**)(void *))(*v686 + 1088))(v686) == v702)
          {
            if (v686[592])
            {
              v385 = (uint64_t *)*v688;
              if (*v688 != v696)
              {
                do
                {
                  v386 = v385 + 4;
                  v387 = (uint64_t **)v686[592];
                  buf[0].__r_.__value_.__r.__words[0] = (std::string::size_type)(v385 + 4);
                  v388 = sub_100372E78(v387, (unint64_t *)v385 + 4, (uint64_t)&unk_10144E20E, (uint64_t **)buf);
                  std::string::operator=((std::string *)(v388 + 5), (const std::string *)(v385 + 5));
                  v389 = (void **)v385[8];
                  v390 = (void **)v385[9];
                  while (v389 != v390)
                  {
                    if (v24 != sub_100046F68(v23, v389)) {
                      sub_100AF91D0((uint64_t)v686, *v386, v389, 0);
                    }
                    v389 += 3;
                  }
                  v391 = (unint64_t *)v385[11];
                  v392 = (unint64_t *)v385[12];
                  while (v391 != v392)
                  {
                    v393 = (void *)*v704;
                    if (*v704)
                    {
                      unint64_t v394 = *v391;
                      v395 = v704;
                      do
                      {
                        unint64_t v396 = v393[4];
                        BOOL v397 = v396 >= v394;
                        if (v396 >= v394) {
                          v398 = v393;
                        }
                        else {
                          v398 = v393 + 1;
                        }
                        if (v397) {
                          v395 = v393;
                        }
                        v393 = (void *)*v398;
                      }
                      while (*v398);
                      if (v395 != v704 && v394 >= v395[4])
                      {
                        memset(buf, 0, 24);
                        sub_1000C6BDC((uint64_t *)buf, (uint64_t)(v395 + 5));
                        std::string::size_type v399 = buf[0].__r_.__value_.__r.__words[0];
                        if ((std::string::size_type *)buf[0].__r_.__value_.__l.__data_ != &buf[0].__r_.__value_.__r.__words[1])
                        {
                          do
                          {
                            if (v24 != sub_100046F68(v23, (void **)(v399 + 32))) {
                              sub_100AF91D0((uint64_t)v686, *v386, (void **)(v399 + 32), 1);
                            }
                            v400 = *(std::string **)(v399 + 8);
                            if (v400)
                            {
                              do
                              {
                                v401 = v400;
                                v400 = (std::string *)v400->__r_.__value_.__r.__words[0];
                              }
                              while (v400);
                            }
                            else
                            {
                              do
                              {
                                v401 = *(std::string **)(v399 + 16);
                                BOOL v402 = v401->__r_.__value_.__r.__words[0] == v399;
                                std::string::size_type v399 = (std::string::size_type)v401;
                              }
                              while (!v402);
                            }
                            std::string::size_type v399 = (std::string::size_type)v401;
                          }
                          while (v401 != (std::string *)&buf[0].__r_.__value_.__r.__words[1]);
                        }
                        __str.__r_.__value_.__r.__words[0] = (std::string::size_type)v391;
                        v403 = sub_100B0ADEC(v698, v391, (uint64_t)&unk_10144E20E, (uint64_t **)&__str);
                        sub_1002C4208((uint64_t **)v403 + 5, 0, 0);
                        sub_10005CD2C((uint64_t)buf, (char *)buf[0].__r_.__value_.__l.__size_);
                      }
                    }
                    ++v391;
                  }
                  v404 = (uint64_t *)v385[1];
                  if (v404)
                  {
                    do
                    {
                      v405 = (uint64_t **)v404;
                      v404 = (uint64_t *)*v404;
                    }
                    while (v404);
                  }
                  else
                  {
                    do
                    {
                      v405 = (uint64_t **)v385[2];
                      BOOL v402 = *v405 == v385;
                      v385 = (uint64_t *)v405;
                    }
                    while (!v402);
                  }
                  v385 = (uint64_t *)v405;
                  std::string::size_type v302 = v699;
                }
                while (v405 != v696);
              }
            }
          }
        }
        sub_100044D00((const void **)&theArray);
        LODWORD(buf[0].__r_.__value_.__l.__data_) = v702;
        v406 = sub_10003B194(v693, (int *)buf);
        uint64_t v407 = *v406;
        v408 = (void **)(*v406 + 256);
        if (*(char *)(*v406 + 279) < 0)
        {
          *(void *)(v407 + 264) = 0;
          v409 = *(void ***)(v407 + 256);
        }
        else
        {
          *(unsigned char *)(v407 + 279) = 0;
          v409 = v408;
        }
        *(unsigned char *)v409 = 0;
        v725.__r_.__value_.__r.__words[0] = 0;
        v410 = &qword_101B0FE18;
        LOBYTE(v410) = atomic_load_explicit((atomic_uchar *volatile)&qword_101B0FE18, memory_order_acquire);
        if ((v410 & 1) == 0 && __cxa_guard_acquire(&qword_101B0FE18))
        {
          buf[0].__r_.__value_.__r.__words[0] = (std::string::size_type)@"NRSlicing";
          buf[0].__r_.__value_.__l.__size_ = (std::string::size_type)@"Dnn";
          sub_100367E88(qword_101B10048, buf, 2uLL);
          __cxa_atexit((void (*)(void *))sub_100367F0C, qword_101B10048, (void *)&_mh_execute_header);
          __cxa_guard_release(&qword_101B0FE18);
          std::string::size_type v302 = v699;
          uint64_t v5 = (uint64_t)v686;
        }
        v411 = (std::mutex *)Registry::getServiceMap(v410, *(Registry **)(v5 + 104));
        v412 = v411;
        std::string::size_type v413 = v302;
        if ((v302 & 0x8000000000000000) != 0)
        {
          v414 = (unsigned __int8 *)(v302 & 0x7FFFFFFFFFFFFFFFLL);
          uint64_t v415 = 5381;
          do
          {
            std::string::size_type v413 = v415;
            unsigned int v416 = *v414++;
            uint64_t v415 = (33 * v415) ^ v416;
          }
          while (v416);
        }
        std::mutex::lock(v411);
        buf[0].__r_.__value_.__r.__words[0] = v413;
        v417 = sub_10004D37C(&v412[1].__m_.__sig, (unint64_t *)buf);
        if (v417)
        {
          uint64_t v419 = v417[3];
          v418 = (std::__shared_weak_count *)v417[4];
          if (v418)
          {
            atomic_fetch_add_explicit(&v418->__shared_owners_, 1uLL, memory_order_relaxed);
            std::mutex::unlock(v412);
            atomic_fetch_add_explicit(&v418->__shared_owners_, 1uLL, memory_order_relaxed);
            std::string::size_type v302 = v699;
            sub_10004D2C8(v418);
            char v420 = 0;
            goto LABEL_608;
          }
        }
        else
        {
          uint64_t v419 = 0;
        }
        std::mutex::unlock(v412);
        v418 = 0;
        char v420 = 1;
LABEL_608:
        (*(void (**)(std::string *__return_ptr, uint64_t, void, uint64_t, void *, void, void))(*(void *)v419 + 104))(&v724, v419, v702, 1, qword_101B10048, 0, 0);
        sub_100056248(&__str, (CFTypeRef *)&v724.__r_.__value_.__l.__data_);
        buf[0].__r_.__value_.__r.__words[0] = v725.__r_.__value_.__r.__words[0];
        v725.__r_.__value_.__r.__words[0] = __str.__r_.__value_.__r.__words[0];
        __str.__r_.__value_.__r.__words[0] = 0;
        sub_1000558F4((const void **)&buf[0].__r_.__value_.__l.__data_);
        sub_1000558F4((const void **)&__str.__r_.__value_.__l.__data_);
        sub_1000577C4((const void **)&v724.__r_.__value_.__l.__data_);
        if ((v420 & 1) == 0) {
          sub_10004D2C8(v418);
        }
        if (v725.__r_.__value_.__r.__words[0]) {
          v421 = sub_1000810B8;
        }
        else {
          v421 = 0;
        }
        if (v421)
        {
          memset(buf, 0, 24);
          ctu::cf::assign();
          __str.__r_.__value_.__r.__words[0] = buf[0].__r_.__value_.__l.__size_;
          std::string::size_type v422 = buf[0].__r_.__value_.__r.__words[0];
          *(std::string::size_type *)((char *)__str.__r_.__value_.__r.__words + 7) = *(std::string::size_type *)((char *)&buf[0].__r_.__value_.__r.__words[1] + 7);
          char v423 = HIBYTE(buf[0].__r_.__value_.__r.__words[2]);
          if (*(char *)(v407 + 279) < 0) {
            operator delete(*v408);
          }
          std::string::size_type v424 = __str.__r_.__value_.__r.__words[0];
          *(void *)(v407 + 256) = v422;
          *(void *)(v407 + 264) = v424;
          *(void *)(v407 + 271) = *(std::string::size_type *)((char *)__str.__r_.__value_.__r.__words + 7);
          *(unsigned char *)(v407 + 279) = v423;
        }
        sub_1000558F4((const void **)&v725.__r_.__value_.__l.__data_);
        if (*(char *)(v407 + 303) < 0)
        {
          *(void *)(v407 + 288) = 0;
          v425 = *(unsigned char **)(v407 + 280);
        }
        else
        {
          *(unsigned char *)(v407 + 303) = 0;
          v425 = (unsigned char *)(v407 + 280);
        }
        unsigned char *v425 = 0;
        v725.__r_.__value_.__r.__words[0] = 0;
        v426 = &qword_101B0FE20;
        LOBYTE(v426) = atomic_load_explicit((atomic_uchar *volatile)&qword_101B0FE20, memory_order_acquire);
        if ((v426 & 1) == 0 && __cxa_guard_acquire(&qword_101B0FE20))
        {
          buf[0].__r_.__value_.__r.__words[0] = (std::string::size_type)@"NRSlicing";
          buf[0].__r_.__value_.__l.__size_ = (std::string::size_type)@"Apn";
          sub_100367E88(qword_101B10060, buf, 2uLL);
          __cxa_atexit((void (*)(void *))sub_100367F0C, qword_101B10060, (void *)&_mh_execute_header);
          __cxa_guard_release(&qword_101B0FE20);
          std::string::size_type v302 = v699;
          uint64_t v5 = (uint64_t)v686;
        }
        v427 = (std::mutex *)Registry::getServiceMap(v426, *(Registry **)(v5 + 104));
        v428 = v427;
        std::string::size_type v429 = v302;
        if ((v302 & 0x8000000000000000) != 0)
        {
          v430 = (unsigned __int8 *)(v302 & 0x7FFFFFFFFFFFFFFFLL);
          uint64_t v431 = 5381;
          do
          {
            std::string::size_type v429 = v431;
            unsigned int v432 = *v430++;
            uint64_t v431 = (33 * v431) ^ v432;
          }
          while (v432);
        }
        std::mutex::lock(v427);
        buf[0].__r_.__value_.__r.__words[0] = v429;
        v433 = sub_10004D37C(&v428[1].__m_.__sig, (unint64_t *)buf);
        if (v433)
        {
          uint64_t v435 = v433[3];
          v434 = (std::__shared_weak_count *)v433[4];
          if (v434)
          {
            atomic_fetch_add_explicit(&v434->__shared_owners_, 1uLL, memory_order_relaxed);
            std::mutex::unlock(v428);
            atomic_fetch_add_explicit(&v434->__shared_owners_, 1uLL, memory_order_relaxed);
            std::string::size_type v302 = v699;
            sub_10004D2C8(v434);
            char v436 = 0;
            goto LABEL_629;
          }
        }
        else
        {
          uint64_t v435 = 0;
        }
        std::mutex::unlock(v428);
        v434 = 0;
        char v436 = 1;
LABEL_629:
        (*(void (**)(std::string *__return_ptr, uint64_t, void, uint64_t, void *, void, void))(*(void *)v435 + 104))(&v724, v435, v702, 1, qword_101B10060, 0, 0);
        sub_100056248(&__str, (CFTypeRef *)&v724.__r_.__value_.__l.__data_);
        buf[0].__r_.__value_.__r.__words[0] = v725.__r_.__value_.__r.__words[0];
        v725.__r_.__value_.__r.__words[0] = __str.__r_.__value_.__r.__words[0];
        __str.__r_.__value_.__r.__words[0] = 0;
        sub_1000558F4((const void **)&buf[0].__r_.__value_.__l.__data_);
        sub_1000558F4((const void **)&__str.__r_.__value_.__l.__data_);
        sub_1000577C4((const void **)&v724.__r_.__value_.__l.__data_);
        if ((v436 & 1) == 0) {
          sub_10004D2C8(v434);
        }
        if (v725.__r_.__value_.__r.__words[0]) {
          v437 = sub_1000810B8;
        }
        else {
          v437 = 0;
        }
        if (v437)
        {
          memset(buf, 0, 24);
          ctu::cf::assign();
          __str.__r_.__value_.__r.__words[0] = buf[0].__r_.__value_.__l.__size_;
          std::string::size_type v438 = buf[0].__r_.__value_.__r.__words[0];
          *(std::string::size_type *)((char *)__str.__r_.__value_.__r.__words + 7) = *(std::string::size_type *)((char *)&buf[0].__r_.__value_.__r.__words[1] + 7);
          char v439 = HIBYTE(buf[0].__r_.__value_.__r.__words[2]);
          if (*(char *)(v407 + 303) < 0) {
            operator delete(*(void **)(v407 + 280));
          }
          std::string::size_type v440 = __str.__r_.__value_.__r.__words[0];
          *(void *)(v407 + 280) = v438;
          *(void *)(v407 + 288) = v440;
          *(void *)(v407 + 295) = *(std::string::size_type *)((char *)__str.__r_.__value_.__r.__words + 7);
          *(unsigned char *)(v407 + 303) = v439;
        }
        sub_1000558F4((const void **)&v725.__r_.__value_.__l.__data_);
        LODWORD(buf[0].__r_.__value_.__l.__data_) = v702;
        uint64_t v441 = *sub_10003B194(v693, (int *)buf);
        *(unsigned char *)(v441 + 128) = 0;
        sub_10005CD2C(v441 + 104, *(char **)(v441 + 112));
        *(void *)(v441 + 104) = v441 + 112;
        *(void *)(v441 + 120) = 0;
        *(void *)(v441 + 112) = 0;
        sub_10010C01C(v441 + 136, *(void **)(v441 + 144));
        *(void *)(v441 + 136) = v441 + 144;
        *(void *)(v441 + 152) = 0;
        *(void *)(v441 + 144) = 0;
        sub_10005CD2C(v441 + 160, *(char **)(v441 + 168));
        *(void *)(v441 + 160) = v441 + 168;
        *(void *)(v441 + 176) = 0;
        *(void *)(v441 + 168) = 0;
        v442 = (uint64_t **)(v441 + 184);
        sub_10005CD2C(v441 + 184, *(char **)(v441 + 192));
        *(void *)(v441 + 184) = v441 + 192;
        uint64_t v697 = v441;
        *(void *)(v441 + 200) = 0;
        *(void *)(v441 + 192) = 0;
        v443 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v5 + 48) + 16))(*(void *)(v5 + 48), v702);
        if (os_log_type_enabled(v443, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(buf[0].__r_.__value_.__l.__data_) = 0;
          _os_log_impl((void *)&_mh_execute_header, v443, OS_LOG_TYPE_DEFAULT, "#I we are clearing cached traffic descriptors because we are re-reading carrier bundle info", (uint8_t *)buf, 2u);
        }
        uint64_t v445 = *(void *)(v441 + 56);
        for (uint64_t k = *(void *)(v441 + 64); k != v445; TrafficDescriptor::~TrafficDescriptor((TrafficDescriptor *)(k - 304)))
          ;
        *(void *)(v441 + 64) = v445;
        v725.__r_.__value_.__r.__words[0] = 0;
        v446 = &qword_101B0FDE8;
        LOBYTE(v446) = atomic_load_explicit((atomic_uchar *volatile)&qword_101B0FDE8, memory_order_acquire);
        if ((v446 & 1) == 0 && __cxa_guard_acquire(&qword_101B0FDE8))
        {
          buf[0].__r_.__value_.__r.__words[0] = (std::string::size_type)@"NRSlicing";
          buf[0].__r_.__value_.__l.__size_ = (std::string::size_type)@"VpnAgnosticApps";
          sub_100367E88(qword_101B0FFB8, buf, 2uLL);
          __cxa_atexit((void (*)(void *))sub_100367F0C, qword_101B0FFB8, (void *)&_mh_execute_header);
          __cxa_guard_release(&qword_101B0FDE8);
          std::string::size_type v302 = v699;
          uint64_t v5 = (uint64_t)v686;
        }
        v447 = (std::mutex *)Registry::getServiceMap(v446, *(Registry **)(v5 + 104));
        v448 = v447;
        std::string::size_type v449 = v302;
        if ((v302 & 0x8000000000000000) != 0)
        {
          v450 = (unsigned __int8 *)(v302 & 0x7FFFFFFFFFFFFFFFLL);
          uint64_t v451 = 5381;
          do
          {
            std::string::size_type v449 = v451;
            unsigned int v452 = *v450++;
            uint64_t v451 = (33 * v451) ^ v452;
          }
          while (v452);
        }
        std::mutex::lock(v447);
        buf[0].__r_.__value_.__r.__words[0] = v449;
        v453 = sub_10004D37C(&v448[1].__m_.__sig, (unint64_t *)buf);
        if (v453)
        {
          uint64_t v455 = v453[3];
          v454 = (std::__shared_weak_count *)v453[4];
          if (v454)
          {
            atomic_fetch_add_explicit(&v454->__shared_owners_, 1uLL, memory_order_relaxed);
            std::mutex::unlock(v448);
            atomic_fetch_add_explicit(&v454->__shared_owners_, 1uLL, memory_order_relaxed);
            std::string::size_type v302 = v699;
            sub_10004D2C8(v454);
            char v456 = 0;
            goto LABEL_652;
          }
        }
        else
        {
          uint64_t v455 = 0;
        }
        std::mutex::unlock(v448);
        v454 = 0;
        char v456 = 1;
LABEL_652:
        (*(void (**)(std::string *__return_ptr, uint64_t, void, uint64_t, void *, void, void))(*(void *)v455 + 104))(&v724, v455, v702, 1, qword_101B0FFB8, 0, 0);
        sub_100044D6C(&__str, (CFTypeRef *)&v724.__r_.__value_.__l.__data_);
        buf[0].__r_.__value_.__r.__words[0] = v725.__r_.__value_.__r.__words[0];
        v725.__r_.__value_.__r.__words[0] = __str.__r_.__value_.__r.__words[0];
        __str.__r_.__value_.__r.__words[0] = 0;
        sub_100044D00((const void **)&buf[0].__r_.__value_.__l.__data_);
        sub_100044D00((const void **)&__str.__r_.__value_.__l.__data_);
        sub_1000577C4((const void **)&v724.__r_.__value_.__l.__data_);
        if ((v456 & 1) == 0) {
          sub_10004D2C8(v454);
        }
        if (v725.__r_.__value_.__r.__words[0]) {
          v457 = sub_100083F10;
        }
        else {
          v457 = 0;
        }
        if (v457)
        {
          CFIndex v458 = CFArrayGetCount((CFArrayRef)v725.__r_.__value_.__l.__data_);
          if (v458 >= 1)
          {
            for (CFIndex m = 0; m != v458; ++m)
            {
              v724.__r_.__value_.__r.__words[0] = 0;
              buf[0].__r_.__value_.__r.__words[0] = (std::string::size_type)CFArrayGetValueAtIndex((CFArrayRef)v725.__r_.__value_.__l.__data_, m);
              sub_100056248(&v724, (CFTypeRef *)&buf[0].__r_.__value_.__l.__data_);
              if (v724.__r_.__value_.__r.__words[0]) {
                v460 = sub_1000810B8;
              }
              else {
                v460 = 0;
              }
              if (v460)
              {
                memset(&__str, 0, sizeof(__str));
                memset(buf, 0, 24);
                ctu::cf::assign();
                std::string __str = buf[0];
                std::string::size_type v461 = buf[0].__r_.__value_.__l.__size_;
                if ((buf[0].__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                  std::string::size_type v461 = HIBYTE(__str.__r_.__value_.__r.__words[2]);
                }
                if (v461)
                {
                  sub_100046BAC(v442, (void **)&__str.__r_.__value_.__l.__data_, (uint64_t)&__str);
                }
                else
                {
                  v463 = *(NSObject **)(v5 + 40);
                  if (os_log_type_enabled(v463, OS_LOG_TYPE_DEFAULT))
                  {
                    LOWORD(buf[0].__r_.__value_.__l.__data_) = 0;
                    _os_log_impl((void *)&_mh_execute_header, v463, OS_LOG_TYPE_DEFAULT, "#E VpnAgnosticApps contains empty app", (uint8_t *)buf, 2u);
                  }
                }
                if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
                  operator delete(__str.__r_.__value_.__l.__data_);
                }
              }
              else
              {
                v462 = *(NSObject **)(v5 + 40);
                if (os_log_type_enabled(v462, OS_LOG_TYPE_DEFAULT))
                {
                  LOWORD(buf[0].__r_.__value_.__l.__data_) = 0;
                  _os_log_impl((void *)&_mh_execute_header, v462, OS_LOG_TYPE_DEFAULT, "#E VpnAgnosticApps does not contain string", (uint8_t *)buf, 2u);
                }
              }
              sub_1000558F4((const void **)&v724.__r_.__value_.__l.__data_);
            }
          }
        }
        else
        {
          v464 = *(NSObject **)(v5 + 40);
          if (os_log_type_enabled(v464, OS_LOG_TYPE_DEFAULT))
          {
            LOWORD(buf[0].__r_.__value_.__l.__data_) = 0;
            _os_log_impl((void *)&_mh_execute_header, v464, OS_LOG_TYPE_DEFAULT, "#I CB section missed: VpnAgnosticApps", (uint8_t *)buf, 2u);
          }
        }
        sub_100044D00((const void **)&v725.__r_.__value_.__l.__data_);
        CFDictionaryRef theDict = 0;
        v465 = &qword_101B0FDF0;
        LOBYTE(v465) = atomic_load_explicit((atomic_uchar *volatile)&qword_101B0FDF0, memory_order_acquire);
        if ((v465 & 1) == 0 && __cxa_guard_acquire(&qword_101B0FDF0))
        {
          buf[0].__r_.__value_.__r.__words[0] = (std::string::size_type)@"NRSlicing";
          buf[0].__r_.__value_.__l.__size_ = (std::string::size_type)@"ManagedAllowedApps";
          sub_100367E88(qword_101B0FFD0, buf, 2uLL);
          __cxa_atexit((void (*)(void *))sub_100367F0C, qword_101B0FFD0, (void *)&_mh_execute_header);
          __cxa_guard_release(&qword_101B0FDF0);
          std::string::size_type v302 = v699;
          uint64_t v5 = (uint64_t)v686;
        }
        v466 = (std::mutex *)Registry::getServiceMap(v465, *(Registry **)(v5 + 104));
        v467 = v466;
        std::string::size_type v468 = v302;
        if ((v302 & 0x8000000000000000) != 0)
        {
          v469 = (unsigned __int8 *)(v302 & 0x7FFFFFFFFFFFFFFFLL);
          uint64_t v470 = 5381;
          do
          {
            std::string::size_type v468 = v470;
            unsigned int v471 = *v469++;
            uint64_t v470 = (33 * v470) ^ v471;
          }
          while (v471);
        }
        std::mutex::lock(v466);
        buf[0].__r_.__value_.__r.__words[0] = v468;
        v472 = sub_10004D37C(&v467[1].__m_.__sig, (unint64_t *)buf);
        if (v472)
        {
          uint64_t v474 = v472[3];
          v473 = (std::__shared_weak_count *)v472[4];
          if (v473)
          {
            atomic_fetch_add_explicit(&v473->__shared_owners_, 1uLL, memory_order_relaxed);
            std::mutex::unlock(v467);
            atomic_fetch_add_explicit(&v473->__shared_owners_, 1uLL, memory_order_relaxed);
            sub_10004D2C8(v473);
            char v475 = 0;
            goto LABEL_687;
          }
        }
        else
        {
          uint64_t v474 = 0;
        }
        std::mutex::unlock(v467);
        v473 = 0;
        char v475 = 1;
LABEL_687:
        (*(void (**)(std::string *__return_ptr, uint64_t, void, uint64_t, void *, void, void))(*(void *)v474 + 104))(&v725, v474, v702, 1, qword_101B0FFD0, 0, 0);
        sub_100044D6C(&__str, (CFTypeRef *)&v725.__r_.__value_.__l.__data_);
        CFDictionaryRef v476 = theDict;
        CFDictionaryRef theDict = (CFDictionaryRef)__str.__r_.__value_.__r.__words[0];
        buf[0].__r_.__value_.__r.__words[0] = (std::string::size_type)v476;
        __str.__r_.__value_.__r.__words[0] = 0;
        sub_100044D00((const void **)&buf[0].__r_.__value_.__l.__data_);
        sub_100044D00((const void **)&__str.__r_.__value_.__l.__data_);
        sub_1000577C4((const void **)&v725.__r_.__value_.__l.__data_);
        if ((v475 & 1) == 0) {
          sub_10004D2C8(v473);
        }
        if (theDict) {
          v477 = sub_100083F10;
        }
        else {
          v477 = 0;
        }
        if (v477)
        {
          CFIndex v478 = CFArrayGetCount(theDict);
          if (v478 >= 1)
          {
            for (CFIndex n = 0; n != v478; ++n)
            {
              CFArrayRef theArray = 0;
              buf[0].__r_.__value_.__r.__words[0] = (std::string::size_type)CFArrayGetValueAtIndex(theDict, n);
              sub_100056248(&theArray, (CFTypeRef *)&buf[0].__r_.__value_.__l.__data_);
              if (theArray) {
                v480 = sub_1000810B8;
              }
              else {
                v480 = 0;
              }
              if (v480)
              {
                memset(&__str, 0, sizeof(__str));
                memset(buf, 0, 24);
                ctu::cf::assign();
                std::string __str = buf[0];
                std::string::size_type v481 = buf[0].__r_.__value_.__l.__size_;
                if ((buf[0].__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                  std::string::size_type v481 = HIBYTE(__str.__r_.__value_.__r.__words[2]);
                }
                if (v481)
                {
                  memset(buf, 0, 24);
                  sub_100058DB0(buf, "");
                  memset(&v725, 0, sizeof(v725));
                  sub_100058DB0(&v725, "");
                  memset(&v724, 0, sizeof(v724));
                  ctu::tokenize();
                  if (0xAAAAAAAAAAAAAAABLL
                     * ((uint64_t)(v724.__r_.__value_.__l.__size_ - v724.__r_.__value_.__r.__words[0]) >> 3) >= 2)
                  {
                    std::string::operator=(&__str, (const std::string *)v724.__r_.__value_.__l.__data_);
                    std::string::operator=(buf, (const std::string *)(v724.__r_.__value_.__r.__words[0] + 24));
                    if (0xAAAAAAAAAAAAAAABLL
                       * ((uint64_t)(v724.__r_.__value_.__l.__size_ - v724.__r_.__value_.__r.__words[0]) >> 3) >= 3)
                      std::string::operator=(&v725, (const std::string *)(v724.__r_.__value_.__r.__words[0] + 48));
                  }
                  sub_100B02DE0(v5, v702, (uint64_t)&__str, (uint64_t)buf, (uint64_t)&v725, 1);
                  v723.__r_.__value_.__r.__words[0] = (std::string::size_type)&v724;
                  sub_100047F64((void ***)&v723);
                  if (SHIBYTE(v725.__r_.__value_.__r.__words[2]) < 0) {
                    operator delete(v725.__r_.__value_.__l.__data_);
                  }
                  if (SHIBYTE(buf[0].__r_.__value_.__r.__words[2]) < 0) {
                    operator delete(buf[0].__r_.__value_.__l.__data_);
                  }
                }
                else
                {
                  v483 = *(NSObject **)(v5 + 40);
                  if (os_log_type_enabled(v483, OS_LOG_TYPE_DEFAULT))
                  {
                    LOWORD(buf[0].__r_.__value_.__l.__data_) = 0;
                    _os_log_impl((void *)&_mh_execute_header, v483, OS_LOG_TYPE_DEFAULT, "#E ManagedAllowedApps contains empty app", (uint8_t *)buf, 2u);
                  }
                }
                if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
                  operator delete(__str.__r_.__value_.__l.__data_);
                }
              }
              else
              {
                v482 = *(NSObject **)(v5 + 40);
                if (os_log_type_enabled(v482, OS_LOG_TYPE_DEFAULT))
                {
                  LOWORD(buf[0].__r_.__value_.__l.__data_) = 0;
                  _os_log_impl((void *)&_mh_execute_header, v482, OS_LOG_TYPE_DEFAULT, "#E ManagedAllowedApps does not contain string", (uint8_t *)buf, 2u);
                }
              }
              sub_1000558F4((const void **)&theArray);
            }
          }
        }
        else
        {
          v484 = *(NSObject **)(v5 + 40);
          if (os_log_type_enabled(v484, OS_LOG_TYPE_DEFAULT))
          {
            LOWORD(buf[0].__r_.__value_.__l.__data_) = 0;
            _os_log_impl((void *)&_mh_execute_header, v484, OS_LOG_TYPE_DEFAULT, "#I CB section missed: ManagedAllowedApps", (uint8_t *)buf, 2u);
          }
        }
        sub_100044D00((const void **)&theDict);
        v485 = &qword_101B0FDF8;
        LOBYTE(v485) = atomic_load_explicit((atomic_uchar *volatile)&qword_101B0FDF8, memory_order_acquire);
        if ((v485 & 1) == 0 && __cxa_guard_acquire(&qword_101B0FDF8))
        {
          buf[0].__r_.__value_.__r.__words[0] = (std::string::size_type)@"NRSlicing";
          buf[0].__r_.__value_.__l.__size_ = (std::string::size_type)@"ManagedSliceApps";
          sub_100367E88(qword_101B0FFE8, buf, 2uLL);
          __cxa_atexit((void (*)(void *))sub_100367F0C, qword_101B0FFE8, (void *)&_mh_execute_header);
          __cxa_guard_release(&qword_101B0FDF8);
          std::string::size_type v302 = v699;
          uint64_t v5 = (uint64_t)v686;
        }
        __str.__r_.__value_.__r.__words[0] = 0;
        v486 = (std::mutex *)Registry::getServiceMap(v485, *(Registry **)(v5 + 104));
        v487 = v486;
        std::string::size_type v488 = v302;
        if ((v302 & 0x8000000000000000) != 0)
        {
          v489 = (unsigned __int8 *)(v302 & 0x7FFFFFFFFFFFFFFFLL);
          uint64_t v490 = 5381;
          do
          {
            std::string::size_type v488 = v490;
            unsigned int v491 = *v489++;
            uint64_t v490 = (33 * v490) ^ v491;
          }
          while (v491);
        }
        std::mutex::lock(v486);
        buf[0].__r_.__value_.__r.__words[0] = v488;
        v492 = sub_10004D37C(&v487[1].__m_.__sig, (unint64_t *)buf);
        if (v492)
        {
          uint64_t v494 = v492[3];
          v493 = (std::__shared_weak_count *)v492[4];
          if (v493)
          {
            atomic_fetch_add_explicit(&v493->__shared_owners_, 1uLL, memory_order_relaxed);
            std::mutex::unlock(v487);
            atomic_fetch_add_explicit(&v493->__shared_owners_, 1uLL, memory_order_relaxed);
            sub_10004D2C8(v493);
            char v495 = 0;
            goto LABEL_728;
          }
        }
        else
        {
          uint64_t v494 = 0;
        }
        std::mutex::unlock(v487);
        v493 = 0;
        char v495 = 1;
LABEL_728:
        (*(void (**)(std::string *__return_ptr, uint64_t, void, uint64_t, void *, const CFBooleanRef, void))(*(void *)v494 + 104))(&__str, v494, v702, 1, qword_101B0FFE8, kCFBooleanFalse, 0);
        if ((v495 & 1) == 0) {
          sub_10004D2C8(v493);
        }
        v496 = (BOOL *)__str.__r_.__value_.__r.__words[0];
        if (__str.__r_.__value_.__r.__words[0]) {
          v497 = sub_100080934;
        }
        else {
          v497 = 0;
        }
        if (v497)
        {
          buf[0].__r_.__value_.__s.__data_[0] = 0;
          if (__str.__r_.__value_.__r.__words[0])
          {
            CFTypeID v498 = CFGetTypeID(__str.__r_.__value_.__l.__data_);
            if (v498 == CFBooleanGetTypeID()) {
              ctu::cf::assign((ctu::cf *)buf, v496, v499);
            }
            if (buf[0].__r_.__value_.__s.__data_[0])
            {
              v500 = *(NSObject **)(v5 + 40);
              if (os_log_type_enabled(v500, OS_LOG_TYPE_DEFAULT))
              {
                LOWORD(buf[0].__r_.__value_.__l.__data_) = 0;
                _os_log_impl((void *)&_mh_execute_header, v500, OS_LOG_TYPE_DEFAULT, "#I ManagedSliceApps used", (uint8_t *)buf, 2u);
              }
              *(_WORD *)(v697 + 1) = 257;
              if (*(char *)(v697 + 279) < 0)
              {
                if (!*(void *)(v697 + 264)) {
LABEL_744:
                }
                  sub_10003ED78((std::string *)(v697 + 256), __s);
              }
              else if (!*(unsigned char *)(v697 + 279))
              {
                goto LABEL_744;
              }
            }
          }
        }
        sub_1000577C4((const void **)&__str.__r_.__value_.__l.__data_);
        v501 = &qword_101B0FE00;
        LOBYTE(v501) = atomic_load_explicit((atomic_uchar *volatile)&qword_101B0FE00, memory_order_acquire);
        if ((v501 & 1) == 0 && __cxa_guard_acquire(&qword_101B0FE00))
        {
          buf[0].__r_.__value_.__r.__words[0] = (std::string::size_type)@"NRSlicing";
          buf[0].__r_.__value_.__l.__size_ = (std::string::size_type)@"ManagedApps";
          sub_100367E88(qword_101B10000, buf, 2uLL);
          __cxa_atexit((void (*)(void *))sub_100367F0C, qword_101B10000, (void *)&_mh_execute_header);
          __cxa_guard_release(&qword_101B0FE00);
          std::string::size_type v302 = v699;
          uint64_t v5 = (uint64_t)v686;
        }
        __str.__r_.__value_.__r.__words[0] = 0;
        v502 = (std::mutex *)Registry::getServiceMap(v501, *(Registry **)(v5 + 104));
        v503 = v502;
        std::string::size_type v504 = v302;
        if ((v302 & 0x8000000000000000) != 0)
        {
          v505 = (unsigned __int8 *)(v302 & 0x7FFFFFFFFFFFFFFFLL);
          uint64_t v506 = 5381;
          do
          {
            std::string::size_type v504 = v506;
            unsigned int v507 = *v505++;
            uint64_t v506 = (33 * v506) ^ v507;
          }
          while (v507);
        }
        std::mutex::lock(v502);
        buf[0].__r_.__value_.__r.__words[0] = v504;
        v508 = sub_10004D37C(&v503[1].__m_.__sig, (unint64_t *)buf);
        if (v508)
        {
          uint64_t v510 = v508[3];
          v509 = (std::__shared_weak_count *)v508[4];
          if (v509)
          {
            atomic_fetch_add_explicit(&v509->__shared_owners_, 1uLL, memory_order_relaxed);
            std::mutex::unlock(v503);
            atomic_fetch_add_explicit(&v509->__shared_owners_, 1uLL, memory_order_relaxed);
            sub_10004D2C8(v509);
            char v511 = 0;
            goto LABEL_754;
          }
        }
        else
        {
          uint64_t v510 = 0;
        }
        std::mutex::unlock(v503);
        v509 = 0;
        char v511 = 1;
LABEL_754:
        (*(void (**)(std::string *__return_ptr, uint64_t, void, uint64_t, void *, const CFBooleanRef, void))(*(void *)v510 + 104))(&__str, v510, v702, 1, qword_101B10000, kCFBooleanFalse, 0);
        if ((v511 & 1) == 0) {
          sub_10004D2C8(v509);
        }
        v512 = (BOOL *)__str.__r_.__value_.__r.__words[0];
        if (__str.__r_.__value_.__r.__words[0]) {
          v513 = sub_100080934;
        }
        else {
          v513 = 0;
        }
        if (v513)
        {
          buf[0].__r_.__value_.__s.__data_[0] = 0;
          if (__str.__r_.__value_.__r.__words[0])
          {
            CFTypeID v514 = CFGetTypeID(__str.__r_.__value_.__l.__data_);
            if (v514 == CFBooleanGetTypeID()) {
              ctu::cf::assign((ctu::cf *)buf, v512, v515);
            }
            if (buf[0].__r_.__value_.__s.__data_[0])
            {
              v516 = *(NSObject **)(v5 + 40);
              if (os_log_type_enabled(v516, OS_LOG_TYPE_DEFAULT))
              {
                LOWORD(buf[0].__r_.__value_.__l.__data_) = 0;
                _os_log_impl((void *)&_mh_execute_header, v516, OS_LOG_TYPE_DEFAULT, "#I managedApps used", (uint8_t *)buf, 2u);
              }
              *(unsigned char *)(v697 + 1) = 1;
              if (*(char *)(v697 + 279) < 0)
              {
                if (*(void *)(v697 + 264)) {
                  goto LABEL_771;
                }
              }
              else if (*(unsigned char *)(v697 + 279))
              {
                goto LABEL_771;
              }
              sub_10003ED78((std::string *)(v697 + 256), __s);
            }
          }
        }
LABEL_771:
        sub_1000577C4((const void **)&__str.__r_.__value_.__l.__data_);
        v518 = (std::mutex *)Registry::getServiceMap(v517, *(Registry **)(v5 + 104));
        v519 = v518;
        if ((v520 & 0x8000000000000000) != 0)
        {
          v521 = (unsigned __int8 *)(v520 & 0x7FFFFFFFFFFFFFFFLL);
          uint64_t v522 = 5381;
          do
          {
            std::string::size_type v520 = v522;
            unsigned int v523 = *v521++;
            uint64_t v522 = (33 * v522) ^ v523;
          }
          while (v523);
        }
        std::mutex::lock(v518);
        buf[0].__r_.__value_.__r.__words[0] = v520;
        v524 = sub_10004D37C(&v519[1].__m_.__sig, (unint64_t *)buf);
        if (!v524)
        {
          uint64_t v525 = 0;
LABEL_779:
          std::mutex::unlock(v519);
          v692 = 0;
          char v527 = 1;
          if (!v525) {
            goto LABEL_811;
          }
LABEL_780:
          if (!*(unsigned char *)(v697 + 1)) {
            goto LABEL_811;
          }
          char v689 = v527;
          (*(void (**)(std::string *__return_ptr, uint64_t))(*(void *)v525 + 48))(buf, v525);
          std::string::size_type v528 = buf[0].__r_.__value_.__l.__size_;
          std::string::size_type v529 = buf[0].__r_.__value_.__r.__words[0];
          while (2)
          {
            if (v529 == v528)
            {
              __str.__r_.__value_.__r.__words[0] = (std::string::size_type)buf;
              sub_100047F64((void ***)&__str);
              char v527 = v689;
              goto LABEL_811;
            }
            v530 = sub_100046F68(v23, (void **)v529);
            v531 = *(NSObject **)(v5 + 40);
            BOOL v532 = os_log_type_enabled(v531, OS_LOG_TYPE_DEFAULT);
            if (v24 == v530)
            {
              if (v532)
              {
                v540 = (void *)v529;
                if (*(char *)(v529 + 23) < 0) {
                  v540 = *(void **)v529;
                }
                LODWORD(__str.__r_.__value_.__l.__data_) = 136315394;
                *(std::string::size_type *)((char *)__str.__r_.__value_.__r.__words + 4) = (std::string::size_type)"updateCarrierBundleAllowedApps_sync";
                WORD2(__str.__r_.__value_.__r.__words[1]) = 2080;
                *(std::string::size_type *)((char *)&__str.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v540;
                v541 = v531;
                v542 = "#I %s: app not installed: %s";
LABEL_808:
                _os_log_impl((void *)&_mh_execute_header, v541, OS_LOG_TYPE_DEFAULT, v542, (uint8_t *)&__str, 0x16u);
              }
            }
            else
            {
              if (v532)
              {
                v533 = (void *)v529;
                if (*(char *)(v529 + 23) < 0) {
                  v533 = *(void **)v529;
                }
                LODWORD(__str.__r_.__value_.__l.__data_) = 136315394;
                *(std::string::size_type *)((char *)__str.__r_.__value_.__r.__words + 4) = (std::string::size_type)"updateCarrierBundleAllowedApps_sync";
                WORD2(__str.__r_.__value_.__r.__words[1]) = 2080;
                *(std::string::size_type *)((char *)&__str.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v533;
                _os_log_impl((void *)&_mh_execute_header, v531, OS_LOG_TYPE_DEFAULT, "#I %s: app installed: %s", (uint8_t *)&__str, 0x16u);
              }
              if (*(unsigned char *)(v697 + 2))
              {
                char v534 = (*(uint64_t (**)(uint64_t, std::string::size_type))(*(void *)v525 + 64))(v525, v529);
                v535 = *(NSObject **)(v5 + 40);
                BOOL v536 = os_log_type_enabled(v535, OS_LOG_TYPE_DEFAULT);
                if (v534)
                {
                  if (v536)
                  {
                    v537 = (void *)v529;
                    if (*(char *)(v529 + 23) < 0) {
                      v537 = *(void **)v529;
                    }
                    LODWORD(__str.__r_.__value_.__l.__data_) = 136315394;
                    *(std::string::size_type *)((char *)__str.__r_.__value_.__r.__words + 4) = (std::string::size_type)"updateCarrierBundleAllowedApps_sync";
                    WORD2(__str.__r_.__value_.__r.__words[1]) = 2080;
                    *(std::string::size_type *)((char *)&__str.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v537;
                    v538 = v535;
                    v539 = "#I %s: app managed and sliced: %s";
                    goto LABEL_802;
                  }
                  goto LABEL_803;
                }
                if (v536)
                {
                  v545 = (void *)v529;
                  if (*(char *)(v529 + 23) < 0) {
                    v545 = *(void **)v529;
                  }
                  LODWORD(__str.__r_.__value_.__l.__data_) = 136315394;
                  *(std::string::size_type *)((char *)__str.__r_.__value_.__r.__words + 4) = (std::string::size_type)"updateCarrierBundleAllowedApps_sync";
                  WORD2(__str.__r_.__value_.__r.__words[1]) = 2080;
                  *(std::string::size_type *)((char *)&__str.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v545;
                  v541 = v535;
                  v542 = "#I %s: app managed but not sliced: %s";
                  goto LABEL_808;
                }
              }
              else
              {
                v543 = *(NSObject **)(v5 + 40);
                if (os_log_type_enabled(v543, OS_LOG_TYPE_DEFAULT))
                {
                  v544 = (void *)v529;
                  if (*(char *)(v529 + 23) < 0) {
                    v544 = *(void **)v529;
                  }
                  LODWORD(__str.__r_.__value_.__l.__data_) = 136315394;
                  *(std::string::size_type *)((char *)__str.__r_.__value_.__r.__words + 4) = (std::string::size_type)"updateCarrierBundleAllowedApps_sync";
                  WORD2(__str.__r_.__value_.__r.__words[1]) = 2080;
                  *(std::string::size_type *)((char *)&__str.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v544;
                  v538 = v543;
                  v539 = "#I %s: app managed: %s";
LABEL_802:
                  _os_log_impl((void *)&_mh_execute_header, v538, OS_LOG_TYPE_DEFAULT, v539, (uint8_t *)&__str, 0x16u);
                }
LABEL_803:
                sub_100AF2618(v5, v702, (void **)v529, 1);
              }
            }
            v529 += 24;
            continue;
          }
        }
        uint64_t v525 = v524[3];
        v526 = (std::__shared_weak_count *)v524[4];
        if (!v526) {
          goto LABEL_779;
        }
        atomic_fetch_add_explicit(&v526->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v519);
        atomic_fetch_add_explicit(&v526->__shared_owners_, 1uLL, memory_order_relaxed);
        v692 = v526;
        sub_10004D2C8(v526);
        char v527 = 0;
        if (v525) {
          goto LABEL_780;
        }
LABEL_811:
        if ((v527 & 1) == 0) {
          sub_10004D2C8(v692);
        }
        if (!(*(unsigned __int8 *)(v694 + 1) | *(unsigned __int8 *)(v694 + 2)))
        {
          if (*(char *)(v694 + 303) < 0)
          {
            *(void *)(v694 + 288) = 0;
            v546 = *(unsigned char **)(v694 + 280);
          }
          else
          {
            v546 = (unsigned char *)(v694 + 280);
            *(unsigned char *)(v694 + 303) = 0;
          }
          unsigned char *v546 = 0;
          if (*(char *)(v694 + 279) < 0)
          {
            *(void *)(v694 + 264) = 0;
            v547 = *(unsigned char **)(v694 + 256);
          }
          else
          {
            v547 = (unsigned char *)(v694 + 256);
            *(unsigned char *)(v694 + 279) = 0;
          }
          unsigned char *v547 = 0;
        }
        LODWORD(buf[0].__r_.__value_.__l.__data_) = v702;
        uint64_t v548 = *sub_10003B194(v693, (int *)buf);
        *(unsigned char *)(v548 + 208) = 0;
        v549 = (std::string *)(v548 + 232);
        if (*(char *)(v548 + 255) < 0)
        {
          *(void *)(v548 + 240) = 0;
          v550 = *(unsigned char **)(v548 + 232);
        }
        else
        {
          *(unsigned char *)(v548 + 255) = 0;
          v550 = (unsigned char *)(v548 + 232);
        }
        unsigned char *v550 = 0;
        *(void *)(v548 + 209) = 0;
        v551 = (std::string::value_type *)(v548 + 209);
        *(void *)(v548 + 217) = 0;
        v725.__r_.__value_.__r.__words[0] = 0;
        v724.__r_.__value_.__r.__words[0] = 0;
        v552 = &qword_101B0FE08;
        LOBYTE(v552) = atomic_load_explicit((atomic_uchar *volatile)&qword_101B0FE08, memory_order_acquire);
        if ((v552 & 1) == 0 && __cxa_guard_acquire(&qword_101B0FE08))
        {
          buf[0].__r_.__value_.__r.__words[0] = (std::string::size_type)@"NRSlicing";
          buf[0].__r_.__value_.__l.__size_ = (std::string::size_type)@"OsId";
          sub_100367E88(qword_101B10018, buf, 2uLL);
          __cxa_atexit((void (*)(void *))sub_100367F0C, qword_101B10018, (void *)&_mh_execute_header);
          __cxa_guard_release(&qword_101B0FE08);
          uint64_t v5 = (uint64_t)v686;
        }
        __str.__r_.__value_.__r.__words[0] = 0;
        v553 = (std::mutex *)Registry::getServiceMap(v552, *(Registry **)(v5 + 104));
        v554 = v553;
        std::string::size_type v555 = v699;
        if ((v699 & 0x8000000000000000) != 0)
        {
          v556 = (unsigned __int8 *)(v699 & 0x7FFFFFFFFFFFFFFFLL);
          uint64_t v557 = 5381;
          do
          {
            std::string::size_type v555 = v557;
            unsigned int v558 = *v556++;
            uint64_t v557 = (33 * v557) ^ v558;
          }
          while (v558);
        }
        std::mutex::lock(v553);
        buf[0].__r_.__value_.__r.__words[0] = v555;
        v559 = sub_10004D37C(&v554[1].__m_.__sig, (unint64_t *)buf);
        if (v559)
        {
          uint64_t v561 = v559[3];
          v560 = (std::__shared_weak_count *)v559[4];
          if (v560)
          {
            atomic_fetch_add_explicit(&v560->__shared_owners_, 1uLL, memory_order_relaxed);
            std::mutex::unlock(v554);
            atomic_fetch_add_explicit(&v560->__shared_owners_, 1uLL, memory_order_relaxed);
            v549 = (std::string *)(v548 + 232);
            sub_10004D2C8(v560);
            char v562 = 0;
            goto LABEL_833;
          }
        }
        else
        {
          uint64_t v561 = 0;
        }
        std::mutex::unlock(v554);
        v560 = 0;
        char v562 = 1;
LABEL_833:
        (*(void (**)(std::string *__return_ptr, uint64_t, void, uint64_t, void *, void, void))(*(void *)v561 + 104))(&__str, v561, v702, 1, qword_101B10018, 0, 0);
        if ((v562 & 1) == 0) {
          sub_10004D2C8(v560);
        }
        if (__str.__r_.__value_.__r.__words[0]) {
          v563 = sub_100080934;
        }
        else {
          v563 = 0;
        }
        if (v563)
        {
          sub_100044D6C(&v723, (CFTypeRef *)&__str.__r_.__value_.__l.__data_);
          buf[0].__r_.__value_.__r.__words[0] = v725.__r_.__value_.__r.__words[0];
          v725.__r_.__value_.__r.__words[0] = v723.__r_.__value_.__r.__words[0];
          v723.__r_.__value_.__r.__words[0] = 0;
          sub_100044D00((const void **)&buf[0].__r_.__value_.__l.__data_);
          sub_100044D00((const void **)&v723.__r_.__value_.__l.__data_);
          goto LABEL_856;
        }
        v564 = &qword_101B0FE10;
        LOBYTE(v564) = atomic_load_explicit((atomic_uchar *volatile)&qword_101B0FE10, memory_order_acquire);
        if ((v564 & 1) == 0 && __cxa_guard_acquire(&qword_101B0FE10))
        {
          buf[0].__r_.__value_.__r.__words[0] = (std::string::size_type)@"NRSlicing";
          buf[0].__r_.__value_.__l.__size_ = (std::string::size_type)@"OsIdStr";
          sub_100367E88(qword_101B10030, buf, 2uLL);
          __cxa_atexit((void (*)(void *))sub_100367F0C, qword_101B10030, (void *)&_mh_execute_header);
          __cxa_guard_release(&qword_101B0FE10);
          uint64_t v5 = (uint64_t)v686;
        }
        v565 = (std::mutex *)Registry::getServiceMap(v564, *(Registry **)(v5 + 104));
        v566 = v565;
        std::string::size_type v567 = v699;
        if ((v699 & 0x8000000000000000) != 0)
        {
          v568 = (unsigned __int8 *)(v699 & 0x7FFFFFFFFFFFFFFFLL);
          uint64_t v569 = 5381;
          do
          {
            std::string::size_type v567 = v569;
            unsigned int v570 = *v568++;
            uint64_t v569 = (33 * v569) ^ v570;
          }
          while (v570);
        }
        std::string::size_type v571 = v567;
        std::mutex::lock(v565);
        buf[0].__r_.__value_.__r.__words[0] = v571;
        v572 = sub_10004D37C(&v566[1].__m_.__sig, (unint64_t *)buf);
        if (!v572)
        {
          uint64_t v574 = 0;
LABEL_848:
          std::mutex::unlock(v566);
          v573 = 0;
          char v575 = 1;
          goto LABEL_849;
        }
        uint64_t v574 = v572[3];
        v573 = (std::__shared_weak_count *)v572[4];
        if (!v573) {
          goto LABEL_848;
        }
        atomic_fetch_add_explicit(&v573->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v566);
        atomic_fetch_add_explicit(&v573->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v573);
        char v575 = 0;
LABEL_849:
        (*(void (**)(std::string *__return_ptr, uint64_t, void, uint64_t, void *, void, void))(*(void *)v574 + 104))(&v723, v574, v702, 1, qword_101B10030, 0, 0);
        buf[0].__r_.__value_.__r.__words[0] = __str.__r_.__value_.__r.__words[0];
        __str.__r_.__value_.__r.__words[0] = v723.__r_.__value_.__r.__words[0];
        v723.__r_.__value_.__r.__words[0] = 0;
        sub_1000577C4((const void **)&buf[0].__r_.__value_.__l.__data_);
        sub_1000577C4((const void **)&v723.__r_.__value_.__l.__data_);
        if ((v575 & 1) == 0) {
          sub_10004D2C8(v573);
        }
        if (__str.__r_.__value_.__r.__words[0]) {
          v576 = sub_100080934;
        }
        else {
          v576 = 0;
        }
        if (!v576)
        {
          v590 = *(NSObject **)(v5 + 40);
          if (os_log_type_enabled(v590, OS_LOG_TYPE_DEFAULT))
          {
            LOWORD(buf[0].__r_.__value_.__l.__data_) = 0;
            _os_log_impl((void *)&_mh_execute_header, v590, OS_LOG_TYPE_DEFAULT, "#I OsId: empty (1)", (uint8_t *)buf, 2u);
          }
          sub_1000577C4((const void **)&__str.__r_.__value_.__l.__data_);
          goto LABEL_900;
        }
        sub_100056248(&v723, (CFTypeRef *)&__str.__r_.__value_.__l.__data_);
        buf[0].__r_.__value_.__r.__words[0] = v724.__r_.__value_.__r.__words[0];
        v724.__r_.__value_.__r.__words[0] = v723.__r_.__value_.__r.__words[0];
        v723.__r_.__value_.__r.__words[0] = 0;
        sub_1000558F4((const void **)&buf[0].__r_.__value_.__l.__data_);
        sub_1000558F4((const void **)&v723.__r_.__value_.__l.__data_);
LABEL_856:
        sub_1000577C4((const void **)&__str.__r_.__value_.__l.__data_);
        if (v725.__r_.__value_.__r.__words[0]) {
          v577 = sub_100083F10;
        }
        else {
          v577 = 0;
        }
        if (v577)
        {
          CFIndex v578 = CFArrayGetCount((CFArrayRef)v725.__r_.__value_.__l.__data_);
          unint64_t v579 = v578 - 1;
          if (v578 >= 1)
          {
            CFIndex v580 = 0;
            if (v579 >= 0xF) {
              unint64_t v579 = 15;
            }
            unint64_t v581 = v579 + 1;
            while (1)
            {
              buf[0].__r_.__value_.__r.__words[0] = 0;
              __str.__r_.__value_.__r.__words[0] = (std::string::size_type)CFArrayGetValueAtIndex((CFArrayRef)v725.__r_.__value_.__l.__data_, v580);
              sub_1000842D0(buf, (CFTypeRef *)&__str.__r_.__value_.__l.__data_);
              if (!(buf[0].__r_.__value_.__r.__words[0] ? sub_100081E58 : 0)) {
                break;
              }
              __str.__r_.__value_.__s.__data_[0] = 0;
              ctu::cf::assign((ctu::cf *)&__str, (unsigned __int8 *)buf[0].__r_.__value_.__l.__data_, v582);
              v551[v580] = __str.__r_.__value_.__s.__data_[0];
              sub_1000570E8((const void **)&buf[0].__r_.__value_.__l.__data_);
              if (v581 == ++v580) {
                goto LABEL_899;
              }
            }
            v589 = *(NSObject **)(v5 + 40);
            if (os_log_type_enabled(v589, OS_LOG_TYPE_DEFAULT))
            {
              LOWORD(__str.__r_.__value_.__l.__data_) = 0;
              _os_log_impl((void *)&_mh_execute_header, v589, OS_LOG_TYPE_DEFAULT, "#E OsId value incorrect", (uint8_t *)&__str, 2u);
            }
            sub_1000570E8((const void **)&buf[0].__r_.__value_.__l.__data_);
            goto LABEL_900;
          }
        }
        else
        {
          if (v724.__r_.__value_.__r.__words[0]) {
            v584 = sub_1000810B8;
          }
          else {
            v584 = 0;
          }
          if (!v584)
          {
            v591 = *(NSObject **)(v5 + 40);
            if (os_log_type_enabled(v591, OS_LOG_TYPE_DEFAULT))
            {
              LOWORD(buf[0].__r_.__value_.__l.__data_) = 0;
              _os_log_impl((void *)&_mh_execute_header, v591, OS_LOG_TYPE_DEFAULT, "#E OsId: empty (2)", (uint8_t *)buf, 2u);
            }
            goto LABEL_900;
          }
          memset(buf, 0, 24);
          ctu::cf::assign();
          std::string __str = buf[0];
          *(_OWORD *)&buf[0].__r_.__value_.__l.__data_ = 0uLL;
          if ((buf[0].__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            v585 = &__str;
          }
          else {
            v585 = (std::string *)__str.__r_.__value_.__r.__words[0];
          }
          if (uuid_parse((const char *)v585, (unsigned __int8 *)buf))
          {
            std::string::size_type v586 = HIBYTE(__str.__r_.__value_.__r.__words[2]);
            if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
              std::string::size_type v586 = __str.__r_.__value_.__l.__size_;
            }
            if (v586 >= 0x10) {
              std::string::size_type v586 = 16;
            }
            if (v586)
            {
              v587 = &__str;
              if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
                v587 = (std::string *)__str.__r_.__value_.__r.__words[0];
              }
              do
              {
                std::string::value_type v588 = v587->__r_.__value_.__s.__data_[0];
                v587 = (std::string *)((char *)v587 + 1);
                *v551++ = v588;
                --v586;
              }
              while (v586);
            }
          }
          else
          {
            for (iuint64_t i = 0; ii != 16; ++ii)
              v551[ii] = buf[0].__r_.__value_.__s.__data_[ii];
          }
          std::string::operator=(v549, &__str);
          if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(__str.__r_.__value_.__l.__data_);
          }
        }
LABEL_899:
        *(unsigned char *)(v548 + 208) = 1;
LABEL_900:
        sub_1000558F4((const void **)&v724.__r_.__value_.__l.__data_);
        sub_100044D00((const void **)&v725.__r_.__value_.__l.__data_);
        sub_100AEC4B4(v5, v702, (uint64_t)"update");
        v53 = v685;
        if ((v684 & 1) == 0) {
          sub_10004D2C8(v682);
        }
LABEL_902:
        uint64_t v22 = v701;
        if (v53 + 1 != v701)
        {
          v593 = v53 + 1;
          while (1)
          {
            v594 = v593;
            if (v700(*v593)) {
              break;
            }
            v593 = v594 + 1;
            if (v594 + 1 == v701)
            {
              uint64_t v22 = v701;
              goto LABEL_908;
            }
          }
          uint64_t v22 = v594;
        }
LABEL_908:
        ;
      }
      while (v22 != v683);
    }
  }
  buf[0].__r_.__value_.__r.__words[0] = 1;
  memset(&buf[0].__r_.__value_.__r.__words[2], 0, sizeof(std::string));
  buf[0].__r_.__value_.__l.__size_ = v5 + 3928;
  sub_100B0AEB8(&buf[0].__r_.__value_.__r.__words[2], (void *)(v5 + 3960));
  std::string::size_type v595 = *(void *)(v5 + 112);
  v725.__r_.__value_.__r.__words[0] = *(void *)(v5 + 104);
  v725.__r_.__value_.__l.__size_ = v595;
  if (v595) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v595 + 8), 1uLL, memory_order_relaxed);
  }
  subscriber::makeSimSlotRange();
  if (v725.__r_.__value_.__l.__size_) {
    sub_10004D2C8((std::__shared_weak_count *)v725.__r_.__value_.__l.__size_);
  }
  std::string::size_type v596 = __str.__r_.__value_.__l.__size_;
  v597 = (_DWORD *)__str.__r_.__value_.__r.__words[0];
  if (__str.__r_.__value_.__r.__words[0] != __str.__r_.__value_.__l.__size_)
  {
    v598 = (uint64_t (*)(void))__str.__r_.__value_.__r.__words[2];
    while ((v598(*v597) & 1) == 0)
    {
      if (++v597 == (_DWORD *)v596)
      {
        v597 = (_DWORD *)v596;
        break;
      }
    }
    std::string::size_type v599 = __str.__r_.__value_.__l.__size_;
    while (v597 != (_DWORD *)v599)
    {
      LODWORD(v723.__r_.__value_.__l.__data_) = 0;
      LODWORD(v723.__r_.__value_.__l.__data_) = *v597;
      int data = (int)v723.__r_.__value_.__l.__data_;
      v601 = (os_log_t *)(*(uint64_t (**)(void, void))(**(void **)(v5 + 48) + 16))(*(void *)(v5 + 48), LODWORD(v723.__r_.__value_.__l.__data_));
      LODWORD(v707) = 0;
      LODWORD(v707) = sub_100B02B1C(v5, data);
      v602 = *v601;
      if (os_log_type_enabled(*v601, OS_LOG_TYPE_DEFAULT))
      {
        rest::SlicingSupportInfo::toString((uint64_t *)&v725, (rest::SlicingSupportInfo *)&v707);
        v603 = &v725;
        if ((v725.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
          v603 = (std::string *)v725.__r_.__value_.__r.__words[0];
        }
        LODWORD(v724.__r_.__value_.__l.__data_) = 136315138;
        *(std::string::size_type *)((char *)v724.__r_.__value_.__r.__words + 4) = (std::string::size_type)v603;
        _os_log_impl((void *)&_mh_execute_header, v602, OS_LOG_TYPE_DEFAULT, "#I update slicing: data_slicing_configured = %s (1)", (uint8_t *)&v724, 0xCu);
        if (SHIBYTE(v725.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v725.__r_.__value_.__l.__data_);
        }
      }
      sub_100B02BC0((uint64_t *)&buf[0].__r_.__value_.__r.__words[2], (int *)&v723, &v707);
      v604 = v597 + 1;
      v597 = (_DWORD *)v596;
      if (v604 != (_DWORD *)v596)
      {
        v597 = v604;
        while ((v598(*v597) & 1) == 0)
        {
          if (++v597 == (_DWORD *)v596)
          {
            v597 = (_DWORD *)v596;
            break;
          }
        }
      }
    }
  }
  sub_100B0B138((uint64_t)buf);
  buf[0].__r_.__value_.__r.__words[0] = 1;
  memset(&buf[0].__r_.__value_.__r.__words[2], 0, sizeof(std::string));
  buf[0].__r_.__value_.__l.__size_ = v5 + 3984;
  sub_100B0AEB8(&buf[0].__r_.__value_.__r.__words[2], (void *)(v5 + 4016));
  std::string::size_type v605 = *(void *)(v5 + 112);
  v725.__r_.__value_.__r.__words[0] = *(void *)(v5 + 104);
  v725.__r_.__value_.__l.__size_ = v605;
  if (v605) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v605 + 8), 1uLL, memory_order_relaxed);
  }
  subscriber::makeSimSlotRange();
  if (v725.__r_.__value_.__l.__size_) {
    sub_10004D2C8((std::__shared_weak_count *)v725.__r_.__value_.__l.__size_);
  }
  std::string::size_type v606 = __str.__r_.__value_.__l.__size_;
  v607 = (_DWORD *)__str.__r_.__value_.__r.__words[0];
  if (__str.__r_.__value_.__r.__words[0] != __str.__r_.__value_.__l.__size_)
  {
    v608 = (uint64_t (*)(void))__str.__r_.__value_.__r.__words[2];
    while ((v608(*v607) & 1) == 0)
    {
      if (++v607 == (_DWORD *)v606)
      {
        v607 = (_DWORD *)v606;
        break;
      }
    }
    std::string::size_type v609 = __str.__r_.__value_.__l.__size_;
    while (v607 != (_DWORD *)v609)
    {
      LODWORD(v723.__r_.__value_.__l.__data_) = 0;
      LODWORD(v723.__r_.__value_.__l.__data_) = *v607;
      uint64_t v610 = LODWORD(v723.__r_.__value_.__l.__data_);
      v611 = (os_log_t *)(*(uint64_t (**)(void, void))(**(void **)(v5 + 48) + 16))(*(void *)(v5 + 48), LODWORD(v723.__r_.__value_.__l.__data_));
      LODWORD(v707) = 0;
      LODWORD(v707) = sub_100B02C94((unsigned __int8 *)v5, v610);
      v612 = *v611;
      if (os_log_type_enabled(*v611, OS_LOG_TYPE_DEFAULT))
      {
        rest::SlicingSupportInfo::toString((uint64_t *)&v725, (rest::SlicingSupportInfo *)&v707);
        v613 = &v725;
        if ((v725.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
          v613 = (std::string *)v725.__r_.__value_.__r.__words[0];
        }
        LODWORD(v724.__r_.__value_.__l.__data_) = 136315138;
        *(std::string::size_type *)((char *)v724.__r_.__value_.__r.__words + 4) = (std::string::size_type)v613;
        _os_log_impl((void *)&_mh_execute_header, v612, OS_LOG_TYPE_DEFAULT, "#I update slicing: data_slicing_support = %s (1)", (uint8_t *)&v724, 0xCu);
        if (SHIBYTE(v725.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v725.__r_.__value_.__l.__data_);
        }
      }
      sub_100B02BC0((uint64_t *)&buf[0].__r_.__value_.__r.__words[2], (int *)&v723, &v707);
      v614 = v607 + 1;
      v607 = (_DWORD *)v606;
      if (v614 != (_DWORD *)v606)
      {
        v607 = v614;
        while ((v608(*v607) & 1) == 0)
        {
          if (++v607 == (_DWORD *)v606)
          {
            v607 = (_DWORD *)v606;
            break;
          }
        }
      }
    }
  }
  sub_100B0B280((uint64_t)buf);
  std::string::size_type v615 = *(void *)(v5 + 112);
  __str.__r_.__value_.__r.__words[0] = *(void *)(v5 + 104);
  __str.__r_.__value_.__l.__size_ = v615;
  if (v615) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v615 + 8), 1uLL, memory_order_relaxed);
  }
  subscriber::makeSimSlotRange();
  if (__str.__r_.__value_.__l.__size_) {
    sub_10004D2C8((std::__shared_weak_count *)__str.__r_.__value_.__l.__size_);
  }
  std::string::size_type v616 = buf[0].__r_.__value_.__l.__size_;
  v617 = (int *)buf[0].__r_.__value_.__r.__words[0];
  if (buf[0].__r_.__value_.__r.__words[0] != buf[0].__r_.__value_.__l.__size_)
  {
    v618 = (uint64_t (*)(void))buf[0].__r_.__value_.__r.__words[2];
    while ((v618(*v617) & 1) == 0)
    {
      if (++v617 == (int *)v616)
      {
        v617 = (int *)v616;
        break;
      }
    }
    std::string::size_type v619 = buf[0].__r_.__value_.__l.__size_;
LABEL_1010:
    while (v617 != (int *)v619)
    {
      DataServiceController::resetSlicePolicies_sync(v5, *v617, 1, 0);
      v620 = v617 + 1;
      v617 = (int *)v616;
      if (v620 != (int *)v616)
      {
        v617 = v620;
        while ((v618(*v617) & 1) == 0)
        {
          if (++v617 == (int *)v616)
          {
            v617 = (int *)v616;
            goto LABEL_1010;
          }
        }
      }
    }
  }
  int v621 = (*(uint64_t (**)(uint64_t))(*(void *)v5 + 1088))(v5);
  LODWORD(buf[0].__r_.__value_.__l.__data_) = v621;
  int v622 = *(unsigned __int8 *)*sub_10003B194(v693, (int *)buf);
  LODWORD(buf[0].__r_.__value_.__l.__data_) = v621;
  int v623 = *(unsigned __int8 *)(*sub_10003B194(v693, (int *)buf) + 23);
  LODWORD(buf[0].__r_.__value_.__l.__data_) = v621;
  v624 = sub_10003B194(v693, (int *)buf);
  uint64_t v625 = *v624;
  if (*(unsigned char *)(*v624 + 12))
  {
    if (*(unsigned char *)(v625 + 13)) {
      BOOL v626 = 1;
    }
    else {
      BOOL v626 = *(unsigned __int8 *)(v625 + 14) != 0;
    }
  }
  else
  {
    BOOL v626 = 0;
  }
  LODWORD(buf[0].__r_.__value_.__l.__data_) = v621;
  int v705 = *(unsigned __int8 *)(*sub_10003B194(v693, (int *)buf) + 15);
  LODWORD(buf[0].__r_.__value_.__l.__data_) = v621;
  uint64_t v627 = *sub_10003B194(v693, (int *)buf);
  v628 = *(NSObject **)(v5 + 40);
  if (os_log_type_enabled(v628, OS_LOG_TYPE_DEFAULT))
  {
    BOOL v629 = *(unsigned char *)(v627 + 19) != 0;
    if (*(char *)(a3 + 23) >= 0) {
      std::string::size_type v630 = a3;
    }
    else {
      std::string::size_type v630 = *(void *)a3;
    }
    std::string::size_type v631 = asStringBool(v622 != 0);
    uint64_t v632 = asStringBool(v626);
    std::string::size_type v633 = asStringBool(v705 != 0);
    std::string::size_type v634 = asStringBool(v629);
    LODWORD(buf[0].__r_.__value_.__l.__data_) = 136447234;
    *(std::string::size_type *)((char *)buf[0].__r_.__value_.__r.__words + 4) = v630;
    WORD2(buf[0].__r_.__value_.__r.__words[1]) = 2080;
    *(std::string::size_type *)((char *)&buf[0].__r_.__value_.__r.__words[1] + 6) = v631;
    HIWORD(buf[0].__r_.__value_.__r.__words[2]) = 2080;
    buf[1].__r_.__value_.__r.__words[0] = v632;
    LOWORD(buf[1].__r_.__value_.__r.__words[1]) = 2080;
    *(std::string::size_type *)((char *)&buf[1].__r_.__value_.__r.__words[1] + 2) = v633;
    WORD1(buf[1].__r_.__value_.__r.__words[2]) = 2080;
    *(std::string::size_type *)((char *)&buf[1].__r_.__value_.__r.__words[2] + 4) = v634;
    _os_log_impl((void *)&_mh_execute_header, v628, OS_LOG_TYPE_DEFAULT, "#I update slicing: %{public}s, newSliceUsed=%s, llphs=%s, consumer=%s,internationalRoaming=%s", (uint8_t *)buf, 0x34u);
  }
  DataServiceController::setSliceEventsListeners_sync((DataServiceController *)v5, v622 != 0, v626, 1);
  v635 = (uint64_t *)*(unsigned __int8 *)(v5 + 4880);
  if (v635 != v622)
  {
    if (v622)
    {
      sub_10003E168(buf, (void *)(v5 + 8));
      long long v637 = *(_OWORD *)&buf[0].__r_.__value_.__l.__data_;
      if (buf[0].__r_.__value_.__l.__size_)
      {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(buf[0].__r_.__value_.__l.__size_ + 16), 1uLL, memory_order_relaxed);
        sub_10004D2C8(*((std::__shared_weak_count **)&v637 + 1));
      }
      v638 = (std::mutex *)Registry::getServiceMap(v636, *(Registry **)(v5 + 104));
      v639 = v638;
      if ((v640 & 0x8000000000000000) != 0)
      {
        v641 = (unsigned __int8 *)(v640 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v642 = 5381;
        do
        {
          std::string::size_type v640 = v642;
          unsigned int v643 = *v641++;
          uint64_t v642 = (33 * v642) ^ v643;
        }
        while (v643);
      }
      std::mutex::lock(v638);
      buf[0].__r_.__value_.__r.__words[0] = v640;
      v644 = sub_10004D37C(&v639[1].__m_.__sig, (unint64_t *)buf);
      if (v644)
      {
        uint64_t v646 = v644[3];
        v645 = (std::__shared_weak_count *)v644[4];
        if (v645)
        {
          atomic_fetch_add_explicit(&v645->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v639);
          atomic_fetch_add_explicit(&v645->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v645);
          char v647 = 0;
          if (!v646) {
            goto LABEL_1050;
          }
          goto LABEL_1046;
        }
      }
      else
      {
        uint64_t v646 = 0;
      }
      std::mutex::unlock(v639);
      v645 = 0;
      char v647 = 1;
      if (!v646)
      {
LABEL_1050:
        if ((v647 & 1) == 0) {
          sub_10004D2C8(v645);
        }
        if (*((void *)&v637 + 1)) {
          std::__shared_weak_count::__release_weak(*((std::__shared_weak_count **)&v637 + 1));
        }
LABEL_1060:
        *(unsigned char *)(v5 + 4880) = v622;
        goto LABEL_1061;
      }
LABEL_1046:
      sub_100058DB0(&__str, "slice");
      if (*((void *)&v637 + 1)) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v637 + 1) + 16), 1uLL, memory_order_relaxed);
      }
      buf[1].__r_.__value_.__r.__words[0] = 0;
      v658 = operator new(0x20uLL);
      void *v658 = off_101A3A730;
      v658[1] = v5;
      *((_OWORD *)v658 + 1) = v637;
      buf[1].__r_.__value_.__r.__words[0] = (std::string::size_type)v658;
      (*(void (**)(uint64_t, std::string *, std::string *))(*(void *)v646 + 112))(v646, &__str, buf);
      sub_10003B34C(buf);
      if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__str.__r_.__value_.__l.__data_);
      }
      goto LABEL_1050;
    }
    v648 = (std::mutex *)Registry::getServiceMap(v635, *(Registry **)(v5 + 104));
    v649 = v648;
    if ((v650 & 0x8000000000000000) != 0)
    {
      v651 = (unsigned __int8 *)(v650 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v652 = 5381;
      do
      {
        std::string::size_type v650 = v652;
        unsigned int v653 = *v651++;
        uint64_t v652 = (33 * v652) ^ v653;
      }
      while (v653);
    }
    std::mutex::lock(v648);
    buf[0].__r_.__value_.__r.__words[0] = v650;
    v654 = sub_10004D37C(&v649[1].__m_.__sig, (unint64_t *)buf);
    if (v654)
    {
      uint64_t v656 = v654[3];
      v655 = (std::__shared_weak_count *)v654[4];
      if (v655)
      {
        atomic_fetch_add_explicit(&v655->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v649);
        atomic_fetch_add_explicit(&v655->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v655);
        char v657 = 0;
        if (!v656)
        {
LABEL_1058:
          if ((v657 & 1) == 0) {
            sub_10004D2C8(v655);
          }
          goto LABEL_1060;
        }
LABEL_1056:
        sub_100058DB0(buf, "slice");
        (*(void (**)(uint64_t, std::string *))(*(void *)v656 + 120))(v656, buf);
        if (SHIBYTE(buf[0].__r_.__value_.__r.__words[2]) < 0) {
          operator delete(buf[0].__r_.__value_.__l.__data_);
        }
        goto LABEL_1058;
      }
    }
    else
    {
      uint64_t v656 = 0;
    }
    std::mutex::unlock(v649);
    v655 = 0;
    char v657 = 1;
    if (!v656) {
      goto LABEL_1058;
    }
    goto LABEL_1056;
  }
LABEL_1061:
  int v659 = (v677 != 0) ^ (v623 != 0);
  if (!v680) {
    int v659 = 1;
  }
  if ((v659 | (v679 != 0) ^ (v705 != 0) | v678) == 1 && v622)
  {
    sub_100058DB0(buf, ": just something updated");
    int v660 = *(char *)(a3 + 23);
    if (v660 >= 0) {
      v661 = (const std::string::value_type *)a3;
    }
    else {
      v661 = *(const std::string::value_type **)a3;
    }
    if (v660 >= 0) {
      std::string::size_type v662 = *(unsigned __int8 *)(a3 + 23);
    }
    else {
      std::string::size_type v662 = *(void *)(a3 + 8);
    }
    v663 = std::string::insert(buf, 0, v661, v662);
    long long v664 = *(_OWORD *)&v663->__r_.__value_.__l.__data_;
    __str.__r_.__value_.__r.__words[2] = v663->__r_.__value_.__r.__words[2];
    *(_OWORD *)&__str.__r_.__value_.__l.__data_ = v664;
    v663->__r_.__value_.__l.__size_ = 0;
    v663->__r_.__value_.__r.__words[2] = 0;
    v663->__r_.__value_.__r.__words[0] = 0;
    if (SHIBYTE(buf[0].__r_.__value_.__r.__words[2]) < 0) {
      operator delete(buf[0].__r_.__value_.__l.__data_);
    }
    int v665 = (*(uint64_t (**)(uint64_t))(*(void *)v5 + 1080))(v5);
    v666 = *(NSObject **)(v5 + 40);
    if (os_log_type_enabled(v666, OS_LOG_TYPE_DEFAULT))
    {
      v667 = &__str;
      if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        v667 = (std::string *)__str.__r_.__value_.__r.__words[0];
      }
      std::string::size_type v703 = (std::string::size_type)v667;
      std::string::size_type v668 = asStringBool(v678);
      uint64_t v669 = asStringBool(v680 != 0);
      std::string::size_type v670 = asStringBool(v623 != 0);
      std::string::size_type v671 = asStringBool(v677 != 0);
      std::string::size_type v672 = asStringBool(1);
      uint64_t v673 = asStringBool(v665);
      std::string::size_type v674 = asStringBool(v679 != 0);
      std::string::size_type v675 = asStringBool(v705 != 0);
      LODWORD(buf[0].__r_.__value_.__l.__data_) = 136317186;
      *(std::string::size_type *)((char *)buf[0].__r_.__value_.__r.__words + 4) = v703;
      WORD2(buf[0].__r_.__value_.__r.__words[1]) = 2080;
      *(std::string::size_type *)((char *)&buf[0].__r_.__value_.__r.__words[1] + 6) = v668;
      HIWORD(buf[0].__r_.__value_.__r.__words[2]) = 2080;
      buf[1].__r_.__value_.__r.__words[0] = v669;
      LOWORD(buf[1].__r_.__value_.__r.__words[1]) = 2080;
      *(std::string::size_type *)((char *)&buf[1].__r_.__value_.__r.__words[1] + 2) = v670;
      WORD1(buf[1].__r_.__value_.__r.__words[2]) = 2080;
      *(std::string::size_type *)((char *)&buf[1].__r_.__value_.__r.__words[2] + 4) = v671;
      WORD2(buf[2].__r_.__value_.__r.__words[0]) = 2080;
      *(std::string::size_type *)((char *)buf[2].__r_.__value_.__r.__words + 6) = v672;
      HIWORD(buf[2].__r_.__value_.__r.__words[1]) = 2080;
      buf[2].__r_.__value_.__r.__words[2] = v673;
      LOWORD(buf[3].__r_.__value_.__l.__data_) = 2080;
      *(std::string::size_type *)((char *)buf[3].__r_.__value_.__r.__words + 2) = v674;
      WORD1(buf[3].__r_.__value_.__r.__words[1]) = 2080;
      *(std::string::size_type *)((char *)&buf[3].__r_.__value_.__r.__words[1] + 4) = v675;
      _os_log_impl((void *)&_mh_execute_header, v666, OS_LOG_TYPE_DEFAULT, "#I Update slicing definitions (full), reason: %s: readAppDbForced=%s oldSliceUsed=%s newEntitlementsGeneresUsed=%s oldEntitlementsGeneresUsed=%s newSliceUsed=%s knownSim=%s oldConsumer=%s consumer=%s", (uint8_t *)buf, 0x5Cu);
    }
    if (v665)
    {
      if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
        sub_10004FC84(&__dst, __str.__r_.__value_.__l.__data_, __str.__r_.__value_.__l.__size_);
      }
      else {
        std::string __dst = __str;
      }
      DataServiceController::updateSlicingDefinitionsWithAppDB(v5, (unint64_t *)&__dst);
      if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__dst.__r_.__value_.__l.__data_);
      }
    }
    if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__str.__r_.__value_.__l.__data_);
    }
  }
}

void sub_100B021BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, std::__shared_weak_count *a19, uint64_t a20,int a21,char a22)
{
  __cxa_guard_abort(&qword_101B0FE08);
  sub_1000558F4((const void **)(v22 - 208));
  sub_100044D00((const void **)(v22 - 176));
  if ((a22 & 1) == 0) {
    sub_10004D2C8(a19);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100B02B1C(uint64_t a1, int a2)
{
  int v9 = a2;
  uint64_t v3 = sub_10003B194(a1 + 4616, &v9);
  int v4 = (unsigned __int8 *)*v3;
  if (!*(unsigned char *)*v3)
  {
    int v6 = 0;
    int v5 = 0;
LABEL_9:
    int v7 = 0;
    return v6 | v5 | v7 | *(unsigned __int8 *)*v3;
  }
  int v5 = v4[1] | v4[2];
  if (v5) {
    int v5 = *(unsigned __int8 *)(a1 + 4971) << 8;
  }
  int v6 = v4[15] << 16;
  if (!v4[12]) {
    goto LABEL_9;
  }
  if (v4[13] || (int v7 = v4[14]) != 0) {
    int v7 = 0x1000000;
  }
  return v6 | v5 | v7 | *(unsigned __int8 *)*v3;
}

uint64_t *sub_100B02BC0(uint64_t *result, int *a2, _DWORD *a3)
{
  int v5 = (uint64_t **)result;
  int v6 = result + 1;
  uint64_t v7 = result[1];
  int v8 = *a2;
  if (v7)
  {
    int v9 = result + 1;
    do
    {
      int v10 = *(_DWORD *)(v7 + 28);
      BOOL v11 = v10 < v8;
      if (v10 >= v8) {
        BOOL v12 = (uint64_t *)v7;
      }
      else {
        BOOL v12 = (uint64_t *)(v7 + 8);
      }
      if (!v11) {
        int v9 = (uint64_t *)v7;
      }
      uint64_t v7 = *v12;
    }
    while (*v12);
    if (v9 != v6 && v8 >= *((_DWORD *)v9 + 7))
    {
      *((_DWORD *)v9 + 8) = *a3;
      return result;
    }
    int v6 = v9;
  }
  uint64_t v16 = 0;
  std::string::size_type v17 = 0;
  BOOL result = sub_100B0AFB0(result, v6, &v17, &v16, v8);
  if (!*result)
  {
    uint64_t v13 = (uint64_t **)result;
    std::string::size_type v14 = (uint64_t *)operator new(0x28uLL);
    int v15 = *a3;
    *((_DWORD *)v14 + 7) = *a2;
    *((_DWORD *)v14 + 8) = v15;
    return sub_100046C38(v5, (uint64_t)v17, v13, v14);
  }
  return result;
}

uint64_t sub_100B02C94(unsigned __int8 *a1, uint64_t a2)
{
  uint64_t v4 = (uint64_t)(a1 + 4616);
  int v13 = a2;
  int v5 = (unsigned __int8 *)*sub_10003B194((uint64_t)(a1 + 4616), &v13);
  int v6 = (*(uint64_t (**)(unsigned __int8 *))(*(void *)a1 + 1088))(a1);
  char v7 = (*(uint64_t (**)(unsigned __int8 *, uint64_t))(*(void *)a1 + 1040))(a1, a2);
  BOOL v8 = DataServiceController::SlicesDataContainer::configured(v4, a2, v6, v7);
  if (v8)
  {
    int v9 = v5[1] | v5[2];
    if (v9) {
      int v9 = a1[4971] << 8;
    }
    int v10 = v5[15] << 16;
    int v11 = v5[12];
    if (v5[12])
    {
      if (v5[13] || (int v11 = v5[14]) != 0) {
        int v11 = 0x1000000;
      }
    }
  }
  else
  {
    int v10 = 0;
    int v9 = 0;
    int v11 = 0;
  }
  return v10 | v9 | v11 | v8;
}

void sub_100B02DE0(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, char a6)
{
  uint64_t v68 = a1 + 4616;
  if (*(unsigned char *)(a1 + 4972))
  {
    for (uint64_t i = 0; i != 3; ++i)
    {
      int v11 = *(char *)(a3 + 23);
      if (v11 >= 0) {
        size_t v12 = *(unsigned __int8 *)(a3 + 23);
      }
      else {
        size_t v12 = *(void *)(a3 + 8);
      }
      if (v12 == strlen(off_101A3A100[i]))
      {
        int v13 = v11 >= 0 ? (const void *)a3 : *(const void **)a3;
        if (!memcmp(v13, off_101A3A100[i], v12)) {
          sub_100046BAC((uint64_t **)(a1 + 4928), (void **)a3, a3);
        }
      }
    }
  }
  sub_100AEB680(&v78, a1, a2);
  std::string::size_type v14 = v78;
  v66 = v79;
  if (v78 != v79)
  {
    char v69 = a6;
    uint64_t v64 = a1 + 4640;
    v63 = (void **)(a1 + 4648);
    uint64_t v15 = a5;
    while (1)
    {
      uint64_t v16 = *v14;
      unsigned int v77 = v16;
      LODWORD(__p[0]) = v16;
      uint64_t v17 = *sub_10003B194(v68, (int *)__p);
      int v76 = 0;
      int v18 = sub_100B02B1C(a1, v16);
      int v75 = 0;
      int v76 = v18;
      int v75 = sub_100B02C94((unsigned __int8 *)a1, v16);
      uint64_t v19 = *(unsigned __int8 *)(a3 + 23);
      if ((v19 & 0x80u) != 0) {
        uint64_t v19 = *(void *)(a3 + 8);
      }
      if (!v19)
      {
LABEL_131:
        std::string::size_type v14 = v78;
        break;
      }
      if (*(unsigned char *)(v68 + 356))
      {
        int v20 = *(void **)(v17 + 184);
        if (v20 != (void *)(v17 + 192))
        {
          while (1)
          {
            uint64_t v21 = *(unsigned __int8 *)(a3 + 23);
            if ((v21 & 0x80u) == 0) {
              uint64_t v22 = *(unsigned __int8 *)(a3 + 23);
            }
            else {
              uint64_t v22 = *(void *)(a3 + 8);
            }
            uint64_t v23 = *((unsigned __int8 *)v20 + 55);
            int v24 = (char)v23;
            if ((v23 & 0x80u) != 0) {
              uint64_t v23 = v20[5];
            }
            if (v22 != v23) {
              goto LABEL_37;
            }
            int v25 = v24 >= 0 ? (unsigned __int8 *)(v20 + 4) : (unsigned __int8 *)v20[4];
            if ((v21 & 0x80) == 0) {
              break;
            }
            if (!memcmp(*(const void **)a3, v25, *(void *)(a3 + 8))) {
              goto LABEL_36;
            }
LABEL_37:
            uint64_t v27 = (void *)v20[1];
            if (v27)
            {
              do
              {
                uint64_t v28 = v27;
                uint64_t v27 = (void *)*v27;
              }
              while (v27);
            }
            else
            {
              do
              {
                uint64_t v28 = (void *)v20[2];
                BOOL v32 = *v28 == (void)v20;
                int v20 = v28;
              }
              while (!v32);
            }
            int v20 = v28;
            if (v28 == (void *)(v17 + 192)) {
              goto LABEL_43;
            }
          }
          if (*(unsigned char *)(a3 + 23))
          {
            uint64_t v26 = (unsigned __int8 *)a3;
            while (*v26 == *v25)
            {
              ++v26;
              ++v25;
              if (!--v21) {
                goto LABEL_36;
              }
            }
            goto LABEL_37;
          }
LABEL_36:
          sub_100046BAC((uint64_t **)(a1 + 4928), (void **)a3, a3);
          goto LABEL_37;
        }
      }
LABEL_43:
      sub_100046BAC((uint64_t **)(v17 + 104), (void **)a3, a3);
      uint64_t v29 = *(unsigned __int8 *)(a3 + 23);
      int v30 = (char)v29;
      if ((v29 & 0x80u) != 0) {
        uint64_t v29 = *(void *)(a3 + 8);
      }
      if (v29 == 17)
      {
        if (v30 >= 0) {
          std::string::size_type v31 = (void *)a3;
        }
        else {
          std::string::size_type v31 = *(void **)a3;
        }
        BOOL v32 = *v31 == 0x637369632E6D6F63 && v31[1] == 0x6572617571732E6FLL;
        if (v32 && *((unsigned char *)v31 + 16) == 100)
        {
          sub_100058DB0(__p, "com.webex.meeting");
          int v40 = sub_100046F68(v64, __p);
          if (SHIBYTE(v73[0]) < 0) {
            operator delete(__p[0]);
          }
          if (v63 == v40) {
            goto LABEL_74;
          }
          sub_100058DB0(__p, "com.webex.meeting");
          sub_1000EA6A0((uint64_t **)(v17 + 104), __p, (uint64_t)__p);
        }
        else
        {
          uint64_t v34 = *v31;
          uint64_t v35 = v31[1];
          int v36 = *((unsigned __int8 *)v31 + 16);
          if (v34 != 0x656265772E6D6F63 || v35 != 0x6E697465656D2E78 || v36 != 103) {
            goto LABEL_74;
          }
          sub_100058DB0(__p, "com.cisco.squared");
          uint64_t v39 = sub_100046F68(v64, __p);
          if (SHIBYTE(v73[0]) < 0) {
            operator delete(__p[0]);
          }
          if (v63 == v39) {
            goto LABEL_74;
          }
          sub_100058DB0(__p, "com.cisco.squared");
          sub_1000EA6A0((uint64_t **)(v17 + 104), __p, (uint64_t)__p);
        }
        if (SHIBYTE(v73[0]) < 0) {
          operator delete(__p[0]);
        }
      }
LABEL_74:
      if ((v69 & 1) != 0 || sub_100AF092C(a1, v16, (void **)a3))
      {
        if (*(char *)(v15 + 23) < 0)
        {
          sub_10004FC84(__p, *(void **)v15, *(void *)(v15 + 8));
        }
        else
        {
          *(_OWORD *)__p = *(_OWORD *)v15;
          v73[0] = *(void *)(v15 + 16);
        }
        if (*(char *)(a4 + 23) < 0)
        {
          sub_10004FC84(&v73[1], *(void **)a4, *(void *)(a4 + 8));
        }
        else
        {
          *(_OWORD *)&v73[1] = *(_OWORD *)a4;
          uint64_t v74 = *(void *)(a4 + 16);
        }
        BOOL v41 = *(uint64_t **)(v17 + 144);
        long long v42 = (uint64_t **)(v17 + 144);
        int64x2_t v43 = (uint64_t **)(v17 + 144);
        if (!v41) {
          goto LABEL_99;
        }
        long long v42 = (uint64_t **)(v17 + 144);
        while (1)
        {
          while (1)
          {
            int64x2_t v43 = (uint64_t **)v41;
            unint64_t v44 = v41 + 4;
            if ((sub_100046FE8((void *)a3, (void **)v41 + 4) & 0x80) == 0) {
              break;
            }
            BOOL v41 = *v43;
            long long v42 = v43;
            if (!*v43) {
              goto LABEL_99;
            }
          }
          if ((sub_100046FE8(v44, (void **)a3) & 0x80) == 0) {
            break;
          }
          long long v42 = v43 + 1;
          BOOL v41 = v43[1];
          if (!v41) {
            goto LABEL_99;
          }
        }
        unsigned int v48 = *v42;
        if (!*v42)
        {
LABEL_99:
          uint64_t v81 = 0;
          int v49 = (char *)operator new(0x68uLL);
          *(void *)&long long buf = v49;
          *((void *)&buf + 1) = v17 + 144;
          v50 = v49 + 32;
          if (*(char *)(a3 + 23) < 0)
          {
            sub_10004FC84(v50, *(void **)a3, *(void *)(a3 + 8));
            uint64_t v51 = (uint64_t *)buf;
          }
          else
          {
            *(_OWORD *)v50 = *(_OWORD *)a3;
            *((void *)v49 + 6) = *(void *)(a3 + 16);
            uint64_t v51 = (uint64_t *)v49;
          }
          *(_OWORD *)(v49 + 88) = 0u;
          *(_OWORD *)(v49 + 72) = 0u;
          *(_OWORD *)(v49 + 56) = 0u;
          LOBYTE(v81) = 1;
          uint64_t *v51 = 0;
          v51[1] = 0;
          v51[2] = (uint64_t)v43;
          *long long v42 = v51;
          uint64_t v52 = **(void **)(v17 + 136);
          if (v52)
          {
            *(void *)(v17 + 136) = v52;
            uint64_t v51 = *v42;
          }
          sub_100046C90(*(uint64_t **)(v17 + 144), v51);
          ++*(void *)(v17 + 152);
          unsigned int v48 = (uint64_t *)buf;
          *(void *)&long long buf = 0;
          sub_100B0B670((uint64_t)&buf);
        }
        v53 = (void **)(v48 + 7);
        if (*((char *)v48 + 79) < 0) {
          operator delete(*v53);
        }
        *(_OWORD *)v53 = *(_OWORD *)__p;
        v48[9] = v73[0];
        HIBYTE(v73[0]) = 0;
        LOBYTE(__p[0]) = 0;
        v54 = (void **)(v48 + 10);
        if (*((char *)v48 + 103) < 0)
        {
          operator delete(*v54);
          int v55 = SHIBYTE(v73[0]);
          *(_OWORD *)v54 = *(_OWORD *)&v73[1];
          v48[12] = v74;
          HIBYTE(v74) = 0;
          LOBYTE(v73[1]) = 0;
          if (v55 < 0) {
            operator delete(__p[0]);
          }
        }
        else
        {
          *(_OWORD *)v54 = *(_OWORD *)&v73[1];
          v48[12] = v74;
        }
        uint64_t v15 = a5;
        uint64_t v56 = *(unsigned __int8 *)(a5 + 23);
        if ((v56 & 0x80u) != 0) {
          uint64_t v56 = *(void *)(a5 + 8);
        }
        if (v56) {
          sub_100046BAC((uint64_t **)(v17 + 160), (void **)a5, a5);
        }
        sub_100B076CC((uint64_t **)(a1 + 4664), &qword_10153E408, (uint64_t *)&qword_10153E408);
        sub_100B076CC((uint64_t **)(a1 + 4688), &qword_10153E408, (uint64_t *)&qword_10153E408);
        char v69 = 1;
      }
      else
      {
        __p[0] = 0;
        __p[1] = 0;
        v73[0] = 0;
        (*(void (**)(void **__return_ptr, uint64_t, uint64_t))(*(void *)a1 + 2264))(__p, a1, a3);
        std::string::size_type v45 = (void **)__p[0];
        if (__p[0] != &__p[1])
        {
          do
          {
            sub_100B076CC((uint64_t **)(a1 + 4664), (unint64_t *)v45 + 4, (uint64_t *)v45 + 4);
            sub_100B076CC((uint64_t **)(a1 + 4688), (unint64_t *)v45 + 4, (uint64_t *)v45 + 4);
            v46 = (void **)v45[1];
            if (v46)
            {
              do
              {
                uint64_t v47 = v46;
                v46 = (void **)*v46;
              }
              while (v46);
            }
            else
            {
              do
              {
                uint64_t v47 = (void **)v45[2];
                BOOL v32 = *v47 == v45;
                std::string::size_type v45 = v47;
              }
              while (!v32);
            }
            std::string::size_type v45 = v47;
          }
          while (v47 != &__p[1]);
        }
        sub_1000346F8((uint64_t)__p, (void *)__p[1]);
        char v69 = 0;
        uint64_t v15 = a5;
      }
      int v71 = 0;
      uint64_t v57 = v77;
      int v58 = sub_100B02B1C(a1, v77);
      int v70 = 0;
      int v71 = v58;
      int v70 = sub_100B02C94((unsigned __int8 *)a1, v57);
      if ((rest::operator==() & 1) == 0)
      {
        uint64_t v59 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v59, OS_LOG_TYPE_DEFAULT))
        {
          rest::SlicingSupportInfo::toString((uint64_t *)__p, (rest::SlicingSupportInfo *)&v71);
          uint64_t v60 = __p;
          if (v73[0] < 0) {
            uint64_t v60 = (void **)__p[0];
          }
          LODWORD(buf) = 136315138;
          *(void *)((char *)&buf + 4) = v60;
          _os_log_impl((void *)&_mh_execute_header, v59, OS_LOG_TYPE_DEFAULT, "#I update slicing: data_slicing_configured = %s (2)", (uint8_t *)&buf, 0xCu);
          if (SHIBYTE(v73[0]) < 0) {
            operator delete(__p[0]);
          }
        }
        __p[0] = (void *)1;
        memset(v73, 0, sizeof(v73));
        __p[1] = (void *)(a1 + 3928);
        sub_100B0AEB8(v73, (void *)(a1 + 3960));
        sub_100B02BC0(v73, (int *)&v77, &v71);
        sub_100B0B138((uint64_t)__p);
      }
      if ((rest::operator==() & 1) == 0)
      {
        v61 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v61, OS_LOG_TYPE_DEFAULT))
        {
          rest::SlicingSupportInfo::toString((uint64_t *)__p, (rest::SlicingSupportInfo *)&v70);
          std::string::size_type v62 = __p;
          if (v73[0] < 0) {
            std::string::size_type v62 = (void **)__p[0];
          }
          LODWORD(buf) = 136315138;
          *(void *)((char *)&buf + 4) = v62;
          _os_log_impl((void *)&_mh_execute_header, v61, OS_LOG_TYPE_DEFAULT, "#I update slicing: data_slicing_support = %s (2)", (uint8_t *)&buf, 0xCu);
          if (SHIBYTE(v73[0]) < 0) {
            operator delete(__p[0]);
          }
        }
        __p[0] = (void *)1;
        memset(v73, 0, sizeof(v73));
        __p[1] = (void *)(a1 + 3984);
        sub_100B0AEB8(v73, (void *)(a1 + 4016));
        sub_100B02BC0(v73, (int *)&v77, &v70);
        sub_100B0B280((uint64_t)__p);
      }
      if (++v14 == v66) {
        goto LABEL_131;
      }
    }
  }
  if (v14) {
    operator delete(v14);
  }
}

void sub_100B03748(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,void *__p,uint64_t a30,int a31,__int16 a32,char a33,char a34)
{
  if (a34 < 0) {
    operator delete(__p);
  }
  int v36 = *(void **)(v34 - 152);
  if (v36) {
    operator delete(v36);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100B03820(uint64_t a1)
{
  v2 = *(void **)(a1 + 48);
  if (v2)
  {
    *(void *)(a1 + 56) = v2;
    operator delete(v2);
  }
  uint64_t v4 = (void **)(a1 + 24);
  sub_100047F64(&v4);
  if (*(char *)(a1 + 23) < 0) {
    operator delete(*(void **)a1);
  }
  return a1;
}

BOOL DataServiceController::isSlicingEnabledInCarrierBundle_sync(uint64_t a1, int a2)
{
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 112);
  uint64_t v7 = *(void *)(a1 + 104);
  BOOL v8 = v4;
  if (v4) {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  int isValidSimSlot = subscriber::isValidSimSlot();
  if (v8) {
    sub_10004D2C8(v8);
  }
  if (!isValidSimSlot) {
    return 0;
  }
  LODWORD(v7) = a2;
  return *(unsigned char *)*sub_10003B194(a1 + 4616, (int *)&v7) != 0;
}

void sub_100B03914(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

BOOL non-virtual thunk to'DataServiceController::isSlicingEnabledInCarrierBundle_sync(uint64_t a1, int a2)
{
  return DataServiceController::isSlicingEnabledInCarrierBundle_sync(a1 - 80, a2);
}

void DataServiceController::processUrsp_sync(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5 = *(void *)(a1 + 144);
  uint64_t v7 = *(void **)(v5 + 8);
  for (uint64_t i = *(void **)(v5 + 16); v7 != i; v7 += 54)
  {
    uint64_t v14 = v7[52];
    int v13 = (std::__shared_weak_count *)v7[53];
    if (v13)
    {
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
      int v15 = *(_DWORD *)(v14 + 52);
      sub_10004D2C8(v13);
    }
    else
    {
      int v15 = *(_DWORD *)(v14 + 52);
    }
    if (v15 == a2)
    {
      uint64_t v16 = v7[50];
      if (v16)
      {
        uint64_t v17 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v18 = subscriber::asString();
          *(_DWORD *)long long buf = 136315138;
          uint64_t v20 = v18;
          _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I processUrsp_sync on simSlot %s", buf, 0xCu);
          uint64_t v16 = v7[50];
        }
        (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v16 + 40))(v16, a3, a4, a5);
      }
    }
  }
}

void non-virtual thunk to'DataServiceController::processUrsp_sync(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
}

void DataServiceController::updateHomePlmnUrspList_sync(uint64_t a1, int a2)
{
  uint64_t v2 = *(void *)(a1 + 144);
  uint64_t v3 = *(void **)(v2 + 8);
  for (uint64_t i = *(void **)(v2 + 16); v3 != i; v3 += 54)
  {
    uint64_t v8 = v3[52];
    uint64_t v7 = (std::__shared_weak_count *)v3[53];
    if (v7)
    {
      atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
      int v9 = *(_DWORD *)(v8 + 52);
      sub_10004D2C8(v7);
    }
    else
    {
      int v9 = *(_DWORD *)(v8 + 52);
    }
    if (v9 == a2)
    {
      uint64_t v10 = v3[50];
      if (v10)
      {
        int v11 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v12 = subscriber::asString();
          *(_DWORD *)long long buf = 136315138;
          uint64_t v14 = v12;
          _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I updateHomePlmnUrspList_sync on simSlot %s", buf, 0xCu);
          uint64_t v10 = v3[50];
        }
        (*(void (**)(uint64_t, uint64_t))(*(void *)v10 + 48))(v10, 1);
      }
    }
  }
}

void non-virtual thunk to'DataServiceController::updateHomePlmnUrspList_sync(uint64_t a1, int a2)
{
}

void DataServiceController::updateAllowedNssaiList_sync(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a1 + 144);
  uint64_t v4 = *(void **)(v3 + 8);
  for (uint64_t i = *(void **)(v3 + 16); v4 != i; v4 += 54)
  {
    uint64_t v10 = v4[52];
    int v9 = (std::__shared_weak_count *)v4[53];
    if (v9)
    {
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      int v11 = *(_DWORD *)(v10 + 52);
      sub_10004D2C8(v9);
    }
    else
    {
      int v11 = *(_DWORD *)(v10 + 52);
    }
    if (v11 == a2)
    {
      uint64_t v12 = v4[50];
      if (v12)
      {
        int v13 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v14 = subscriber::asString();
          *(_DWORD *)long long buf = 136315138;
          uint64_t v16 = v14;
          _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I updateAllowedNssaiList_sync on simSlot %s", buf, 0xCu);
          uint64_t v12 = v4[50];
        }
        (*(void (**)(uint64_t, uint64_t))(*(void *)v12 + 56))(v12, a3);
      }
    }
  }
}

void non-virtual thunk to'DataServiceController::updateAllowedNssaiList_sync(uint64_t a1, int a2, uint64_t a3)
{
}

void *DataServiceController::allTdCombinationsFromUrsp_sync(uint64_t a1, int a2)
{
  uint64_t v2 = *(void *)(a1 + 144);
  uint64_t v3 = *(void **)(v2 + 8);
  uint64_t v4 = *(void **)(v2 + 16);
  if (v3 == v4) {
    return &unk_10153E410;
  }
  uint64_t v7 = &unk_10153E410;
  while (1)
  {
    uint64_t v9 = v3[52];
    uint64_t v8 = (std::__shared_weak_count *)v3[53];
    if (v8)
    {
      atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
      int v10 = *(_DWORD *)(v9 + 52);
      sub_10004D2C8(v8);
    }
    else
    {
      int v10 = *(_DWORD *)(v9 + 52);
    }
    if (v10 == a2)
    {
      uint64_t v11 = v3[50];
      if (v11) {
        break;
      }
    }
    v3 += 54;
    if (v3 == v4) {
      return v7;
    }
  }
  uint64_t v12 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
  {
    int v14 = 136315138;
    uint64_t v15 = subscriber::asString();
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I allTdCombinationsFromUrsp_sync on simSlot %s", (uint8_t *)&v14, 0xCu);
    uint64_t v11 = v3[50];
  }
  return (void *)(*(uint64_t (**)(uint64_t))(*(void *)v11 + 64))(v11);
}

void *non-virtual thunk to'DataServiceController::allTdCombinationsFromUrsp_sync(uint64_t a1, int a2)
{
  return DataServiceController::allTdCombinationsFromUrsp_sync(a1 - 80, a2);
}

void DataServiceController::resetAllUrspRules_sync(uint64_t a1, int a2, int a3)
{
  if (a3 == 8 || a3 == 1)
  {
    uint64_t v5 = *(void *)(a1 + 144);
    int v6 = *(void **)(v5 + 8);
    for (uint64_t i = *(void **)(v5 + 16); v6 != i; v6 += 54)
    {
      uint64_t v9 = v6[52];
      uint64_t v8 = (std::__shared_weak_count *)v6[53];
      if (v8)
      {
        atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
        int v10 = *(_DWORD *)(v9 + 52);
        sub_10004D2C8(v8);
      }
      else
      {
        int v10 = *(_DWORD *)(v9 + 52);
      }
      if (v10 == a2)
      {
        uint64_t v11 = v6[50];
        if (v11)
        {
          uint64_t v12 = *(NSObject **)(a1 + 40);
          if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v13 = subscriber::asString();
            *(_DWORD *)long long buf = 136315138;
            uint64_t v15 = v13;
            _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I resetAllUrspRules_sync on simSlot %s", buf, 0xCu);
            uint64_t v11 = v6[50];
          }
          (*(void (**)(uint64_t))(*(void *)v11 + 72))(v11);
        }
      }
    }
  }
}

void non-virtual thunk to'DataServiceController::resetAllUrspRules_sync(uint64_t a1, int a2, int a3)
{
}

uint64_t DataServiceController::evaluateUrspWithTd_sync(void *a1, int a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6 = a1[18];
  uint64_t v7 = *(void **)(v6 + 8);
  uint64_t v8 = *(void **)(v6 + 16);
  if (v7 == v8)
  {
LABEL_8:
    *(void *)long long buf = a1;
    sub_10012CA20((uint64_t)&buf[8], a4);
    v18[0] = 0;
    v18[1] = 0;
    sub_10003E168(v18, a1 + 1);
    operator new();
  }
  while (1)
  {
    uint64_t v12 = v7[52];
    uint64_t v11 = (std::__shared_weak_count *)v7[53];
    if (v11)
    {
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      int v13 = *(_DWORD *)(v12 + 52);
      sub_10004D2C8(v11);
    }
    else
    {
      int v13 = *(_DWORD *)(v12 + 52);
    }
    if (v13 == a2)
    {
      uint64_t v14 = v7[50];
      if (v14) {
        break;
      }
    }
    v7 += 54;
    if (v7 == v8) {
      goto LABEL_8;
    }
  }
  uint64_t v15 = a1[5];
  if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = subscriber::asString();
    _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I evaluateUrspWithTd_sync on simSlot %s", buf, 0xCu);
    uint64_t v14 = v7[50];
  }
  sub_10012CA20((uint64_t)v20, a4);
  uint64_t v16 = (*(uint64_t (**)(uint64_t, uint64_t, void *))(*(void *)v14 + 80))(v14, a3, v20);
  sub_10012C330(v20);
  return v16;
}

void sub_100B04274(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  va_start(va, a10);
  sub_10012C330((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t non-virtual thunk to'DataServiceController::evaluateUrspWithTd_sync(uint64_t a1, int a2, uint64_t a3, uint64_t a4)
{
  return DataServiceController::evaluateUrspWithTd_sync((void *)(a1 - 80), a2, a3, a4);
}

uint64_t DataServiceController::checkSliceDataStall(DataServiceController *this, void **a2)
{
  uint64_t v2 = (uint64_t)(*a2 + 1);
  uint64_t v3 = (void *)**a2;
  if (v3 == (void *)v2)
  {
    LOBYTE(v5) = 0;
  }
  else
  {
    int v5 = 0;
    do
    {
      if (*((unsigned char *)v3 + 80)) {
        v5 |= DataServiceController::checkSliceDataStall(this, *((_DWORD *)v3 + 8));
      }
      uint64_t v6 = (void *)v3[1];
      if (v6)
      {
        do
        {
          uint64_t v7 = v6;
          uint64_t v6 = (void *)*v6;
        }
        while (v6);
      }
      else
      {
        do
        {
          uint64_t v7 = (void *)v3[2];
          BOOL v8 = *v7 == (void)v3;
          uint64_t v3 = v7;
        }
        while (!v8);
      }
      uint64_t v3 = v7;
    }
    while (v7 != (void *)v2);
  }
  return v5 & 1;
}

uint64_t DataServiceController::checkSliceDataStall(DataServiceController *this, int a2)
{
  uint64_t v3 = *((void *)this + 14);
  *(void *)__p = *((void *)this + 13);
  *(void *)&__p[8] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  subscriber::makeSimSlotRange();
  if (*(void *)&__p[8]) {
    sub_10004D2C8(*(std::__shared_weak_count **)&__p[8]);
  }
  uint64_t v4 = (unsigned int *)v124;
  v100 = v125;
  if (v124 != v125)
  {
    CFBooleanRef v99 = v126;
    while (1)
    {
      int v5 = v4;
      if (v126(*v4)) {
        break;
      }
      uint64_t v4 = v5 + 1;
      if (v5 + 1 == (unsigned int *)v125)
      {
        uint64_t v6 = v125;
        goto LABEL_11;
      }
    }
    uint64_t v6 = (int *)v5;
LABEL_11:
    v86 = v125;
    if (v6 != v125)
    {
      uint64_t v7 = (char *)this + 5000;
      do
      {
        v87 = v6;
        int v101 = *v6;
        int v8 = 28;
        while (1)
        {
          uint64_t v122 = 0;
          uint64_t v123 = 0;
          DataServiceController::getConnection_sync((uint64_t)this, v101, v8, &v122);
          uint64_t v9 = v122;
          if (v122
            && ((*(uint64_t (**)(uint64_t))(*(void *)v122 + 168))(v122) & 1) != 0
            && (*(unsigned int (**)(uint64_t))(*(void *)v9 + 200))(v9) == a2)
          {
            v120[0] = 0;
            v120[1] = 0;
            uint64_t v121 = 0;
            int v10 = (void *)(*(uint64_t (**)(uint64_t, void **))(*(void *)v9 + 408))(v9, v120);
            uint64_t v11 = v10 + 1;
            uint64_t v12 = (void *)*v10;
            if ((void *)*v10 != v10 + 1)
            {
              while (1)
              {
                int v13 = *((void *)this + 5);
                if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
                {
                  TrafficDescriptor::toString((uint64_t *)__p, (TrafficDescriptor *)(v12 + 4));
                  uint64_t v14 = __p;
                  if (__p[23] < 0) {
                    uint64_t v14 = *(unsigned char **)__p;
                  }
                  *(_DWORD *)long long buf = 136446210;
                  *(void *)&uint8_t buf[4] = v14;
                  _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I checkSliceDataStall ???: %{public}s", buf, 0xCu);
                  if ((__p[23] & 0x80000000) != 0) {
                    operator delete(*(void **)__p);
                  }
                }
                if (sub_100AEAD30((uint64_t)this, (TrafficDescriptor *)(v12 + 4)))
                {
                  uint64_t v15 = (char *)*((void *)this + 624);
                  if (v15 == v7)
                  {
LABEL_36:
                    uint64_t v19 = *((void *)this + 5);
                    if (!os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT)) {
                      goto LABEL_168;
                    }
                    uint64_t v20 = asString();
                    TrafficDescriptor::toString((uint64_t *)buf, (TrafficDescriptor *)(v12 + 4));
                    uint64_t v21 = buf;
                    if ((buf[23] & 0x80u) != 0) {
                      uint64_t v21 = *(uint8_t **)buf;
                    }
                    *(_DWORD *)__p = 136315650;
                    *(void *)&__p[4] = v20;
                    *(_WORD *)&__p[12] = 2048;
                    *(void *)&__p[14] = 9000;
                    *(_WORD *)&__p[22] = 2082;
                    *(void *)&__p[24] = v21;
                    _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#I checkSliceDataStall: do not report slice connection %s because TD does not belong to %llu: internal traffic descriptor: %{public}s", __p, 0x20u);
                    if (((char)buf[23] & 0x80000000) == 0) {
                      goto LABEL_168;
                    }
                    uint64_t v22 = *(void **)buf;
                    goto LABEL_63;
                  }
                  while (1)
                  {
                    if (*((unsigned char *)v12 + 40))
                    {
                      BOOL v16 = *((_DWORD *)v12 + 9) == *((_DWORD *)v15 + 8) && *((void *)v15 + 5) == 9000;
                      if (v16) {
                        break;
                      }
                    }
                    uint64_t v17 = (char *)*((void *)v15 + 1);
                    if (v17)
                    {
                      do
                      {
                        uint64_t v18 = v17;
                        uint64_t v17 = *(char **)v17;
                      }
                      while (v17);
                    }
                    else
                    {
                      do
                      {
                        uint64_t v18 = (char *)*((void *)v15 + 2);
                        BOOL v16 = *(void *)v18 == (void)v15;
                        uint64_t v15 = v18;
                      }
                      while (!v16);
                    }
                    uint64_t v15 = v18;
                    if (v18 == v7) {
                      goto LABEL_36;
                    }
                  }
                }
                else
                {
                  if ((TrafficDescriptor::hasBundleInfo((TrafficDescriptor *)(v12 + 4)) & 1) == 0)
                  {
                    uint64_t v29 = *((void *)this + 5);
                    if (!os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT)) {
                      goto LABEL_168;
                    }
                    uint64_t v30 = asString();
                    TrafficDescriptor::toString((uint64_t *)__p, (TrafficDescriptor *)(v12 + 4));
                    std::string::size_type v31 = __p;
                    if (__p[23] < 0) {
                      std::string::size_type v31 = *(unsigned char **)__p;
                    }
                    *(_DWORD *)long long buf = 136315394;
                    *(void *)&uint8_t buf[4] = v30;
                    *(_WORD *)&buf[12] = 2082;
                    *(void *)&buf[14] = v31;
                    _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "#I checkSliceDataStall: do not report slice connection %s because TD has non-bundle-id based traffic descriptor: %{public}s", buf, 0x16u);
                    if ((__p[23] & 0x80000000) == 0) {
                      goto LABEL_168;
                    }
                    uint64_t v22 = *(void **)__p;
LABEL_63:
                    operator delete(v22);
                    goto LABEL_168;
                  }
                  memset(buf, 0, 24);
                  if (!*((unsigned char *)v12 + 104)) {
                    sub_10016C840();
                  }
                  (*(void (**)(uint8_t *__return_ptr, DataServiceController *, void *))(*(void *)this + 2264))(buf, this, v12 + 10);
                  uint64_t v23 = *(void **)&buf[8];
                  if (!*(void *)&buf[8]) {
                    goto LABEL_64;
                  }
                  int v24 = &buf[8];
                  int v25 = *(uint8_t **)&buf[8];
                  do
                  {
                    uint64_t v26 = v25;
                    uint64_t v27 = v24;
                    unint64_t v28 = *((void *)v25 + 4) >> 3;
                    if (v28 >= 0x465) {
                      int v24 = v25;
                    }
                    else {
                      v25 += 8;
                    }
                    int v25 = *(uint8_t **)v25;
                  }
                  while (v25);
                  if (v24 == &buf[8]) {
                    goto LABEL_64;
                  }
                  if (v28 < 0x465) {
                    uint64_t v26 = v27;
                  }
                  if (*((void *)v26 + 4) >= 0x2329uLL)
                  {
LABEL_64:
                    BOOL v32 = *((void *)this + 5);
                    if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
                    {
                      uint64_t v33 = asString();
                      TrafficDescriptor::toString((uint64_t *)v127, (TrafficDescriptor *)(v12 + 4));
                      uint64_t v34 = v127;
                      if (v130 < 0) {
                        uint64_t v34 = *(unsigned char **)v127;
                      }
                      *(_DWORD *)__p = 136315650;
                      *(void *)&__p[4] = v33;
                      *(_WORD *)&__p[12] = 2048;
                      *(void *)&__p[14] = 9000;
                      *(_WORD *)&__p[22] = 2082;
                      *(void *)&__p[24] = v34;
                      _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, "#I checkSliceDataStall: do not report slice connection %s because TD does not belong to %llu: traffic descriptor: %{public}s", __p, 0x20u);
                      if (v130 < 0) {
                        operator delete(*(void **)v127);
                      }
                      uint64_t v23 = *(void **)&buf[8];
                    }
                    sub_1000346F8((uint64_t)buf, v23);
                    goto LABEL_168;
                  }
                  sub_1000346F8((uint64_t)buf, *(void **)&buf[8]);
                }
                uint64_t v118 = 0;
                uint64_t v119 = 0;
                (*(void (**)(uint64_t *__return_ptr))(*(void *)v122 + 136))(&v118);
                if (v118) {
                  break;
                }
                uint64_t v35 = *((void *)this + 5);
                if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT))
                {
                  uint64_t v36 = asString();
                  TrafficDescriptor::toString((uint64_t *)__p, (TrafficDescriptor *)(v12 + 4));
                  uint64_t v37 = __p;
                  if (__p[23] < 0) {
                    uint64_t v37 = *(unsigned char **)__p;
                  }
                  *(_DWORD *)long long buf = 136315394;
                  *(void *)&uint8_t buf[4] = v36;
                  *(_WORD *)&buf[12] = 2082;
                  *(void *)&buf[14] = v37;
                  _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_DEFAULT, "#I checkSliceDataStall: do not report slice connection %s because settings object is empty: traffic descriptor: %{public}s", buf, 0x16u);
                  if ((__p[23] & 0x80000000) != 0) {
                    operator delete(*(void **)__p);
                  }
                }
                int v38 = 8;
LABEL_165:
                if (v119) {
                  sub_10004D2C8(v119);
                }
                if ((v38 | 8) != 8) {
                  goto LABEL_195;
                }
LABEL_168:
                int v76 = (void *)v12[1];
                if (v76)
                {
                  do
                  {
                    unsigned int v77 = v76;
                    int v76 = (void *)*v76;
                  }
                  while (v76);
                }
                else
                {
                  do
                  {
                    unsigned int v77 = (void *)v12[2];
                    BOOL v16 = *v77 == (void)v12;
                    uint64_t v12 = v77;
                  }
                  while (!v16);
                }
                uint64_t v12 = v77;
                if (v77 == v11) {
                  goto LABEL_194;
                }
              }
              uint64_t v116 = 0;
              std::string::size_type v117 = 0;
              (*(void (**)(uint64_t *__return_ptr))(*(void *)v118 + 464))(&v116);
              if (!v116)
              {
                uint64_t v39 = *((void *)this + 5);
                if (os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT))
                {
                  uint64_t v40 = asString();
                  TrafficDescriptor::toString((uint64_t *)__p, (TrafficDescriptor *)(v12 + 4));
                  BOOL v41 = __p;
                  if (__p[23] < 0) {
                    BOOL v41 = *(unsigned char **)__p;
                  }
                  *(_DWORD *)long long buf = 136315394;
                  *(void *)&uint8_t buf[4] = v40;
                  *(_WORD *)&buf[12] = 2082;
                  *(void *)&buf[14] = v41;
                  _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_DEFAULT, "#I checkSliceDataStall: do not report slice connection %s because apnInfo object is empty: traffic descriptor: %{public}s", buf, 0x16u);
                  if ((__p[23] & 0x80000000) != 0) {
                    operator delete(*(void **)__p);
                  }
                }
                int v38 = 8;
                goto LABEL_163;
              }
              memset(buf, 0, 24);
              if (*(char *)(v116 + 71) < 0)
              {
                sub_10004FC84(buf, *(void **)(v116 + 48), *(void *)(v116 + 56));
              }
              else
              {
                *(_OWORD *)long long buf = *(_OWORD *)(v116 + 48);
                *(void *)&buf[16] = *(void *)(v116 + 64);
              }
              long long v42 = (uint64_t *)buf[23];
              if ((buf[23] & 0x80u) != 0) {
                long long v42 = *(uint64_t **)&buf[8];
              }
              if (!v42)
              {
                uint64_t v52 = *((void *)this + 5);
                if (os_log_type_enabled(v52, OS_LOG_TYPE_DEFAULT))
                {
                  uint64_t v53 = asString();
                  TrafficDescriptor::toString((uint64_t *)__p, (TrafficDescriptor *)(v12 + 4));
                  v54 = __p;
                  if (__p[23] < 0) {
                    v54 = *(unsigned char **)__p;
                  }
                  *(_DWORD *)v127 = 136315394;
                  *(void *)&v127[4] = v53;
                  __int16 v128 = 2082;
                  v129 = v54;
                  _os_log_impl((void *)&_mh_execute_header, v52, OS_LOG_TYPE_DEFAULT, "#I checkSliceDataStall: do not report slice connection %s because DNN is empty: traffic descriptor: %{public}s", v127, 0x16u);
                  if ((__p[23] & 0x80000000) != 0) {
                    operator delete(*(void **)__p);
                  }
                }
                int v38 = 8;
                goto LABEL_161;
              }
              ServiceMap = (std::mutex *)Registry::getServiceMap(v42, *((Registry **)this + 13));
              unint64_t v44 = ServiceMap;
              if (v45 < 0)
              {
                v46 = (unsigned __int8 *)(v45 & 0x7FFFFFFFFFFFFFFFLL);
                uint64_t v47 = 5381;
                do
                {
                  uint64_t v45 = v47;
                  unsigned int v48 = *v46++;
                  uint64_t v47 = (33 * v47) ^ v48;
                }
                while (v48);
              }
              std::mutex::lock(ServiceMap);
              *(void *)__p = v45;
              int v49 = sub_10004D37C(&v44[1].__m_.__sig, (unint64_t *)__p);
              if (v49)
              {
                v50 = (std::__shared_weak_count *)v49[4];
                int64_t v97 = v49[3];
                if (v50)
                {
                  atomic_fetch_add_explicit(&v50->__shared_owners_, 1uLL, memory_order_relaxed);
                  std::mutex::unlock(v44);
                  atomic_fetch_add_explicit(&v50->__shared_owners_, 1uLL, memory_order_relaxed);
                  sub_10004D2C8(v50);
                  char v51 = 0;
                  goto LABEL_101;
                }
              }
              else
              {
                int64_t v97 = 0;
              }
              std::mutex::unlock(v44);
              v50 = 0;
              char v51 = 1;
LABEL_101:
              if (!v97)
              {
                int v38 = 0;
                if ((v51 & 1) == 0) {
                  goto LABEL_160;
                }
                goto LABEL_161;
              }
              xpc_object_t v115 = 0;
              xpc_object_t v55 = xpc_dictionary_create(0, 0, 0);
              xpc_object_t v56 = v55;
              if (v55)
              {
                xpc_object_t v115 = v55;
                goto LABEL_107;
              }
              xpc_object_t v56 = xpc_null_create();
              xpc_object_t v115 = v56;
              if (v56)
              {
LABEL_107:
                if (xpc_get_type(v56) != (xpc_type_t)&_xpc_type_dictionary)
                {
                  xpc_object_t v57 = xpc_null_create();
                  goto LABEL_111;
                }
                xpc_retain(v56);
              }
              else
              {
                xpc_object_t v57 = xpc_null_create();
                xpc_object_t v56 = 0;
LABEL_111:
                xpc_object_t v115 = v57;
              }
              xpc_release(v56);
              if ((buf[23] & 0x80u) == 0) {
                int v58 = buf;
              }
              else {
                int v58 = *(uint8_t **)buf;
              }
              xpc_object_t v113 = xpc_string_create((const char *)v58);
              if (!v113) {
                xpc_object_t v113 = xpc_null_create();
              }
              *(void *)__p = &v115;
              *(void *)&__p[8] = "dnn";
              sub_100035E70((uint64_t)__p, &v113, &object);
              xpc_release(object);
              xpc_object_t object = 0;
              xpc_release(v113);
              xpc_object_t v113 = 0;
              xpc_object_t v111 = xpc_int64_create((unsigned __int16)a2);
              if (!v111) {
                xpc_object_t v111 = xpc_null_create();
              }
              *(void *)__p = &v115;
              *(void *)&__p[8] = "pdp";
              sub_100035E70((uint64_t)__p, &v111, &v112);
              xpc_release(v112);
              xpc_object_t v112 = 0;
              xpc_release(v111);
              xpc_object_t v111 = 0;
              v92 = v50;
              *(_DWORD *)unsigned int v91 = (*(uint64_t (**)(DataServiceController *))(*(void *)this + 1256))(this);
              bzero(__p, 0x320uLL);
              RegisteredNetworkInfo::RegisteredNetworkInfo((RegisteredNetworkInfo *)__p, (DataServiceController *)((char *)this + 1176));
              if (v101 == 2) {
                RegisteredNetworkInfo::operator=();
              }
              if (*(_DWORD *)&__p[4] == 14)
              {
                if (!v146) {
                  goto LABEL_135;
                }
                unsigned int IntValue = MCC::getIntValue((MCC *)v143);
                unsigned int v96 = MCC::getIntValue((MCC *)v142);
                int64_t v94 = v144;
                uint64_t v93 = v145;
                v66 = *((void *)this + 5);
                if (!os_log_type_enabled(v66, OS_LOG_TYPE_DEFAULT)) {
                  goto LABEL_134;
                }
                *(_WORD *)v127 = 0;
                v61 = v66;
                std::string::size_type v62 = "#I Slice cell info from LTE";
              }
              else
              {
                if (*(_DWORD *)&__p[4] != 16)
                {
                  if (*(_DWORD *)&__p[4] == 17 && v152)
                  {
                    unsigned int IntValue = MCC::getIntValue((MCC *)v149);
                    unsigned int v96 = MCC::getIntValue((MCC *)v148);
                    int64_t v94 = v150;
                    uint64_t v93 = v151;
                    uint64_t v60 = *((void *)this + 5);
                    if (os_log_type_enabled(v60, OS_LOG_TYPE_DEFAULT))
                    {
                      *(_WORD *)v127 = 0;
                      v61 = v60;
                      std::string::size_type v62 = "#I Slice cell info from NR (SA)";
                      goto LABEL_133;
                    }
LABEL_134:
                    int v67 = 1;
LABEL_137:
                    if (v156 && v155 < 0) {
                      operator delete(v154);
                    }
                    sub_10002B2D8((uint64_t)&v153);
                    sub_10002B28C((uint64_t)&v147);
                    sub_10002B1F4((uint64_t)&v141);
                    sub_10002B1A8((uint64_t)&v140);
                    sub_10002B1A8((uint64_t)&v139);
                    sub_10002B240((uint64_t)&__p[16]);
                    uint64_t v90 = v11;
                    if (v67)
                    {
                      xpc_object_t v109 = xpc_int64_create(IntValue);
                      if (!v109) {
                        xpc_object_t v109 = xpc_null_create();
                      }
                      *(void *)__p = &v115;
                      *(void *)&__p[8] = "mnc";
                      sub_100035E70((uint64_t)__p, &v109, &v110);
                      xpc_release(v110);
                      xpc_object_t v110 = 0;
                      xpc_release(v109);
                      xpc_object_t v109 = 0;
                      xpc_object_t v107 = xpc_int64_create(v96);
                      if (!v107) {
                        xpc_object_t v107 = xpc_null_create();
                      }
                      *(void *)__p = &v115;
                      *(void *)&__p[8] = "mcc";
                      sub_100035E70((uint64_t)__p, &v107, &v108);
                      xpc_release(v108);
                      xpc_object_t v108 = 0;
                      xpc_release(v107);
                      int64_t v68 = 0;
                      uint64_t v69 = 0;
                      xpc_object_t v107 = 0;
                      if (*(_DWORD *)v91)
                      {
                        xpc_object_t v105 = xpc_int64_create(v94);
                        if (!v105) {
                          xpc_object_t v105 = xpc_null_create();
                        }
                        *(void *)__p = &v115;
                        *(void *)&__p[8] = "areaId";
                        sub_100035E70((uint64_t)__p, &v105, &v106);
                        xpc_release(v106);
                        xpc_object_t v106 = 0;
                        xpc_release(v105);
                        xpc_object_t v105 = 0;
                        xpc_object_t v103 = xpc_uint64_create(v93);
                        if (!v103) {
                          xpc_object_t v103 = xpc_null_create();
                        }
                        *(void *)__p = &v115;
                        *(void *)&__p[8] = "cellId";
                        sub_100035E70((uint64_t)__p, &v103, &v104);
                        xpc_release(v104);
                        xpc_object_t v104 = 0;
                        xpc_release(v103);
                        xpc_object_t v103 = 0;
                        goto LABEL_151;
                      }
                    }
                    else
                    {
LABEL_151:
                      uint64_t v69 = v93;
                      int64_t v68 = v94;
                    }
                    int v70 = *((void *)this + 5);
                    if (os_log_type_enabled(v70, OS_LOG_TYPE_DEFAULT))
                    {
                      char v95 = v70;
                      unsigned int v71 = IntValue;
                      char v89 = v51;
                      int v72 = (char)buf[23];
                      uint64_t v73 = *(uint8_t **)buf;
                      uint64_t v74 = asStringBool(v91[0]);
                      *(_DWORD *)__p = 136447746;
                      int v75 = buf;
                      if (v72 < 0) {
                        int v75 = v73;
                      }
                      *(void *)&__p[4] = v75;
                      *(_WORD *)&__p[12] = 1024;
                      *(_DWORD *)&__p[14] = a2;
                      *(_WORD *)&__p[18] = 2048;
                      *(void *)&__p[20] = v71;
                      *(_WORD *)&__p[28] = 2048;
                      *(void *)&__p[30] = v96;
                      __int16 v133 = 2048;
                      int64_t v134 = v68;
                      __int16 v135 = 2048;
                      uint64_t v136 = v69;
                      __int16 v137 = 2080;
                      uint64_t v138 = v74;
                      _os_log_impl((void *)&_mh_execute_header, v95, OS_LOG_TYPE_DEFAULT, "#E checkSliceDataStall: submitCoreAnalytics metricCCSliceDataStall for 5G Slice: dnn=%{public}s contextId=%u mnc=%lu mcc=%lu areaId=%lu cellId=%llu locationAuthorized=%s", __p, 0x44u);
                      char v51 = v89;
                    }
                    xpc_object_t v102 = v115;
                    if (v115)
                    {
                      xpc_retain(v115);
                      v50 = v92;
                      uint64_t v11 = v90;
                    }
                    else
                    {
                      v50 = v92;
                      uint64_t v11 = v90;
                      xpc_object_t v102 = xpc_null_create();
                    }
                    (*(void (**)(int64_t, const char *, xpc_object_t *))(*(void *)v97 + 16))(v97, "metricCCSliceDataStall", &v102);
                    xpc_release(v102);
                    xpc_object_t v102 = 0;
                    xpc_release(v115);
                    int v38 = 1;
                    if ((v51 & 1) == 0) {
LABEL_160:
                    }
                      sub_10004D2C8(v50);
LABEL_161:
                    if ((char)buf[23] < 0) {
                      operator delete(*(void **)buf);
                    }
LABEL_163:
                    if (v117) {
                      sub_10004D2C8(v117);
                    }
                    goto LABEL_165;
                  }
LABEL_135:
                  unsigned int IntValue = 0;
                  unsigned int v96 = 0;
                  uint64_t v93 = 0;
                  int64_t v94 = 0;
LABEL_136:
                  int v67 = 0;
                  goto LABEL_137;
                }
                if (v152)
                {
                  unsigned int v63 = MCC::getIntValue((MCC *)v149);
                  unsigned int v96 = MCC::getIntValue((MCC *)v148);
                  int64_t v94 = v150;
                  uint64_t v93 = v151;
                  char v88 = v51;
                  if (MCC::valid((MCC *)v149))
                  {
                    char v64 = MCC::valid((MCC *)v148);
                    unsigned int v65 = v63;
                  }
                  else
                  {
                    unsigned int v65 = v63;
                    char v64 = 0;
                  }
                  uint64_t v78 = *((void *)this + 5);
                  if (os_log_type_enabled(v78, OS_LOG_TYPE_DEFAULT))
                  {
                    uint64_t v79 = asStringBool(v64);
                    *(_DWORD *)v127 = 136315138;
                    *(void *)&v127[4] = v79;
                    _os_log_impl((void *)&_mh_execute_header, v78, OS_LOG_TYPE_DEFAULT, "#I Slice cell info from NR (NSA): %s", v127, 0xCu);
                  }
                  unsigned int IntValue = v65;
                  if (v64)
                  {
                    int v67 = 1;
                    char v51 = v88;
                    goto LABEL_137;
                  }
                  char v51 = v88;
                }
                else
                {
                  unsigned int IntValue = 0;
                  unsigned int v96 = 0;
                  uint64_t v93 = 0;
                  int64_t v94 = 0;
                }
                if (!v146 || !MCC::valid((MCC *)v143) || !MCC::valid((MCC *)v142)) {
                  goto LABEL_136;
                }
                unsigned int IntValue = MCC::getIntValue((MCC *)v143);
                unsigned int v96 = MCC::getIntValue((MCC *)v142);
                int64_t v94 = v144;
                uint64_t v93 = v145;
                v80 = *((void *)this + 5);
                if (!os_log_type_enabled(v80, OS_LOG_TYPE_DEFAULT)) {
                  goto LABEL_134;
                }
                *(_WORD *)v127 = 0;
                v61 = v80;
                std::string::size_type v62 = "#I Slice cell info from LTE (NR NSA)";
              }
LABEL_133:
              _os_log_impl((void *)&_mh_execute_header, v61, OS_LOG_TYPE_DEFAULT, v62, v127, 2u);
              goto LABEL_134;
            }
LABEL_194:
            int v38 = 0;
LABEL_195:
            if (SHIBYTE(v121) < 0) {
              operator delete(v120[0]);
            }
          }
          else
          {
            int v38 = 6;
          }
          if (v123) {
            sub_10004D2C8(v123);
          }
          if (v38 != 6 && v38) {
            break;
          }
          if (++v8 == 36) {
            goto LABEL_198;
          }
        }
        if ((v38 & 0xFFFFFFFB) != 0) {
          return 1;
        }
LABEL_198:
        uint64_t v6 = v100;
        if (v87 + 1 != v100)
        {
          uint64_t v81 = (unsigned int *)(v87 + 1);
          while (1)
          {
            CFTypeID v82 = v81;
            if (v99(*v81)) {
              break;
            }
            uint64_t v81 = v82 + 1;
            if (v82 + 1 == (unsigned int *)v100)
            {
              uint64_t v6 = v100;
              goto LABEL_204;
            }
          }
          uint64_t v6 = (int *)v82;
        }
LABEL_204:
        ;
      }
      while (v6 != v86);
    }
  }
  CFBooleanRef v83 = *((void *)this + 5);
  BOOL v84 = os_log_type_enabled(v83, OS_LOG_TYPE_DEFAULT);
  uint64_t result = 0;
  if (v84)
  {
    *(_DWORD *)__p = 67109120;
    *(_DWORD *)&__p[4] = a2;
    _os_log_impl((void *)&_mh_execute_header, v83, OS_LOG_TYPE_DEFAULT, "#I checkSliceDataStall[%u]: false", __p, 8u);
    return 0;
  }
  return result;
}

void sub_100B05524(_Unwind_Exception *a1)
{
  if (STACK[0x258]) {
    sub_10004D2C8((std::__shared_weak_count *)STACK[0x258]);
  }
  _Unwind_Resume(a1);
}

void DataServiceController::requestSliceByUUID(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v5[4] = a1;
  if (*(char *)(a2 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)__p = *(_OWORD *)a2;
    __p[2] = *(void **)(a2 + 16);
  }
  sub_1005237A0((uint64_t)&v7, a3);
  v5[0] = 0;
  v5[1] = 0;
  sub_10003E168(v5, (void *)(a1 + 8));
  operator new();
}

void sub_100B05888(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
}

void non-virtual thunk to'DataServiceController::requestSliceByUUID(uint64_t a1, uint64_t a2, uint64_t a3)
{
}

uint64_t sub_100B058CC(uint64_t a1, TrafficDescriptor *this)
{
  uint64_t result = TrafficDescriptor::hasAppInfo(this);
  if (result)
  {
    v5.__d_.__rep_ = std::chrono::steady_clock::now().__d_.__rep_;
    if (!*((unsigned char *)this + 72)) {
      sub_10016C840();
    }
    std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep rep = v5.__d_.__rep_;
    uint64_t v7 = (uint64_t **)(a1 + 4864);
    int v8 = *(uint64_t **)(a1 + 4864);
    if (v8)
    {
      while (1)
      {
        while (1)
        {
          uint64_t v9 = (uint64_t **)v8;
          int v10 = v8 + 4;
          if ((sub_100046FE8((void *)this + 6, (void **)v8 + 4) & 0x80) == 0) {
            break;
          }
          int v8 = *v9;
          uint64_t v7 = v9;
          if (!*v9) {
            goto LABEL_11;
          }
        }
        uint64_t result = sub_100046FE8(v10, (void **)this + 6);
        if ((result & 0x80) == 0) {
          break;
        }
        uint64_t v7 = v9 + 1;
        int v8 = v9[1];
        if (!v8) {
          goto LABEL_11;
        }
      }
      uint64_t v11 = *v7;
      if (*v7) {
        goto LABEL_17;
      }
    }
    else
    {
      uint64_t v9 = (uint64_t **)(a1 + 4864);
    }
LABEL_11:
    uint64_t v11 = (uint64_t *)operator new(0x40uLL);
    uint64_t v12 = v11 + 4;
    if (*((char *)this + 71) < 0)
    {
      sub_10004FC84(v12, *((void **)this + 6), *((void *)this + 7));
    }
    else
    {
      *(_OWORD *)uint64_t v12 = *((_OWORD *)this + 3);
      v11[6] = *((void *)this + 8);
    }
    v11[7] = 0;
    uint64_t *v11 = 0;
    v11[1] = 0;
    v11[2] = (uint64_t)v9;
    char *v7 = v11;
    uint64_t v13 = **(void **)(a1 + 4856);
    uint64_t v14 = v11;
    if (v13)
    {
      *(void *)(a1 + 4856) = v13;
      uint64_t v14 = *v7;
    }
    uint64_t result = (uint64_t)sub_100046C90(*(uint64_t **)(a1 + 4864), v14);
    ++*(void *)(a1 + 4872);
LABEL_17:
    v11[7] = rep;
  }
  return result;
}

void sub_100B05A08(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void DataServiceController::requestSliceDeactivation(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = (void *)(a1 + 8);
  if (*(char *)(a2 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)__p = *(_OWORD *)a2;
    __p[2] = *(void **)(a2 + 16);
  }
  v4[0] = 0;
  v4[1] = 0;
  sub_10003E168(v4, v2);
  operator new();
}

void non-virtual thunk to'DataServiceController::requestSliceDeactivation(uint64_t a1, uint64_t a2)
{
}

uint64_t sub_100B05B6C(uint64_t *a1, const TrafficDescriptor *a2)
{
  uint64_t v3 = *a1;
  unint64_t v4 = 0x86BCA1AF286BCA1BLL * ((a1[1] - *a1) >> 4);
  unint64_t v5 = v4 + 1;
  if (v4 + 1 > 0xD79435E50D7943) {
    sub_10006A748();
  }
  uint64_t v7 = (uint64_t)(a1 + 2);
  unint64_t v8 = 0x86BCA1AF286BCA1BLL * ((a1[2] - v3) >> 4);
  if (2 * v8 > v5) {
    unint64_t v5 = 2 * v8;
  }
  if (v8 >= 0x6BCA1AF286BCA1) {
    unint64_t v9 = 0xD79435E50D7943;
  }
  else {
    unint64_t v9 = v5;
  }
  uint64_t v17 = a1 + 2;
  if (v9) {
    int v10 = (char *)sub_100B05D04(v7, v9);
  }
  else {
    int v10 = 0;
  }
  uint64_t v13 = v10;
  uint64_t v14 = (TrafficDescriptor *)&v10[304 * v4];
  BOOL v16 = &v10[304 * v9];
  TrafficDescriptor::TrafficDescriptor(v14, a2);
  uint64_t v15 = (char *)v14 + 304;
  sub_100B05C8C(a1, &v13);
  uint64_t v11 = a1[1];
  sub_100B05DE4((uint64_t)&v13);
  return v11;
}

void sub_100B05C78(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100B05DE4((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100B05C8C(uint64_t *a1, void *a2)
{
  uint64_t result = sub_100B05D50((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

void *sub_100B05D04(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0xD79435E50D7944) {
    sub_10006A7CC();
  }
  return operator new(304 * a2);
}

uint64_t sub_100B05D50(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10 = 0;
  uint64_t v11 = a7 - 304;
  while (a3 + v10 != a5)
  {
    uint64_t v12 = (TrafficDescriptor *)(v11 + v10);
    v10 -= 304;
    TrafficDescriptor::TrafficDescriptor(v12, (const TrafficDescriptor *)(v10 + a3));
  }
  return a6;
}

uint64_t sub_100B05DE4(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 304;
    TrafficDescriptor::~TrafficDescriptor((TrafficDescriptor *)(i - 304));
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void *sub_100B05E34(void *result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    uint64_t v6 = result;
    sub_100B05EBC(result, a4);
    uint64_t result = (void *)sub_100B05F14((uint64_t)(v6 + 2), a2, a3, v6[1]);
    v6[1] = result;
  }
  return result;
}

void sub_100B05E9C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  *(void *)(v9 + 8) = v10;
  sub_1008BE774(&a9);
  _Unwind_Resume(a1);
}

char *sub_100B05EBC(void *a1, unint64_t a2)
{
  if (a2 >= 0xD79435E50D7944) {
    sub_10006A748();
  }
  uint64_t result = (char *)sub_100B05D04((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[304 * v4];
  return result;
}

uint64_t sub_100B05F14(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a2 != a3)
  {
    uint64_t v7 = 0;
    do
    {
      TrafficDescriptor::TrafficDescriptor((TrafficDescriptor *)(a4 + v7), (const TrafficDescriptor *)(a2 + v7));
      v7 += 304;
    }
    while (a2 + v7 != a3);
    a4 += v7;
  }
  return a4;
}

void sub_100B05F74(_Unwind_Exception *exception_object)
{
  if (v2)
  {
    uint64_t v4 = v1 - 304;
    do
    {
      TrafficDescriptor::~TrafficDescriptor((TrafficDescriptor *)(v4 + v2));
      v2 -= 304;
    }
    while (v2);
  }
  _Unwind_Resume(exception_object);
}

void sub_100B05F98(void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (void **)**a1;
  if (v2)
  {
    uint64_t v4 = (void **)v1[1];
    uint64_t v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        if (*((char *)v4 - 1) < 0) {
          operator delete(*(v4 - 3));
        }
        v4 -= 4;
      }
      while (v4 != v2);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t sub_100B06024(uint64_t *a1, const TrafficDescriptor *a2)
{
  uint64_t v3 = *a1;
  unint64_t v4 = 0x86BCA1AF286BCA1BLL * ((a1[1] - *a1) >> 4);
  unint64_t v5 = v4 + 1;
  if (v4 + 1 > 0xD79435E50D7943) {
    sub_10006A748();
  }
  uint64_t v7 = (uint64_t)(a1 + 2);
  unint64_t v8 = 0x86BCA1AF286BCA1BLL * ((a1[2] - v3) >> 4);
  if (2 * v8 > v5) {
    unint64_t v5 = 2 * v8;
  }
  if (v8 >= 0x6BCA1AF286BCA1) {
    unint64_t v9 = 0xD79435E50D7943;
  }
  else {
    unint64_t v9 = v5;
  }
  uint64_t v17 = a1 + 2;
  if (v9) {
    uint64_t v10 = (char *)sub_100B05D04(v7, v9);
  }
  else {
    uint64_t v10 = 0;
  }
  uint64_t v13 = v10;
  uint64_t v14 = (TrafficDescriptor *)&v10[304 * v4];
  BOOL v16 = &v10[304 * v9];
  TrafficDescriptor::TrafficDescriptor(v14, a2);
  uint64_t v15 = (char *)v14 + 304;
  sub_100B05C8C(a1, &v13);
  uint64_t v11 = a1[1];
  sub_100B05DE4((uint64_t)&v13);
  return v11;
}

void sub_100B06130(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100B05DE4((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_100B06144(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  uint64_t v8 = a1 + 16;
  unint64_t v9 = *(void **)a1;
  if (0x86BCA1AF286BCA1BLL * ((uint64_t)(*(void *)(a1 + 16) - *(void *)a1) >> 4) < a4)
  {
    sub_1008BE714((void **)a1);
    if (a4 > 0xD79435E50D7943) {
      sub_10006A748();
    }
    unint64_t v10 = 0xD79435E50D79436 * ((uint64_t)(*(void *)(a1 + 16) - *(void *)a1) >> 4);
    if (v10 <= a4) {
      unint64_t v10 = a4;
    }
    if (0x86BCA1AF286BCA1BLL * ((uint64_t)(*(void *)(a1 + 16) - *(void *)a1) >> 4) >= 0x6BCA1AF286BCA1) {
      unint64_t v11 = 0xD79435E50D7943;
    }
    else {
      unint64_t v11 = v10;
    }
    sub_100B05EBC((void *)a1, v11);
    uint64_t v12 = sub_100B05F14(v8, a2, a3, *(void *)(a1 + 8));
    goto LABEL_11;
  }
  if (0x86BCA1AF286BCA1BLL * ((uint64_t)(*(void *)(a1 + 8) - (void)v9) >> 4) < a4)
  {
    uint64_t v13 = a2 + 16 * ((uint64_t)(*(void *)(a1 + 8) - (void)v9) >> 4);
    sub_100B062D0(a2, v13, (uint64_t)v9);
    uint64_t v12 = sub_100B05F14(v8, v13, a3, *(void *)(a1 + 8));
LABEL_11:
    *(void *)(a1 + 8) = v12;
    return;
  }
  sub_100B062D0(a2, a3, (uint64_t)v9);
  uint64_t v15 = v14;
  uint64_t v16 = *(void *)(a1 + 8);
  if (v16 != v14)
  {
    do
      TrafficDescriptor::~TrafficDescriptor((TrafficDescriptor *)(v16 - 304));
    while (v16 != v15);
  }
  *(void *)(a1 + 8) = v15;
}

void sub_100B062C0(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

void sub_100B062C8(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

uint64_t sub_100B062D0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = a1;
  if (a1 != a2)
  {
    do
    {
      TrafficDescriptor::operator=();
      v4 += 304;
      a3 += 304;
    }
    while (v4 != a2);
    return a2;
  }
  return v4;
}

uint64_t sub_100B06330(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (void *)(a2 + 24);
  uint64_t v4 = *(void *)(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(*(void *)*v3 + 24))(*v3, a1);
      return a1;
    }
    *(void *)(a1 + 24) = v4;
  }
  else
  {
    uint64_t v3 = (void *)(a1 + 24);
  }
  void *v3 = 0;
  return a1;
}

uint64_t sub_100B063B0(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 32;
    sub_100B08BB0((void *)(i - 32));
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

TrafficDescriptor *sub_100B06400(TrafficDescriptor *a1, const TrafficDescriptor *a2)
{
  *(unsigned char *)a1 = 0;
  *((unsigned char *)a1 + 304) = 0;
  if (*((unsigned char *)a2 + 304))
  {
    TrafficDescriptor::TrafficDescriptor(a1, a2);
    *((unsigned char *)a1 + 304) = 1;
  }
  return a1;
}

void sub_100B06444(_Unwind_Exception *exception_object)
{
  if (*((unsigned char *)v1 + 304)) {
    TrafficDescriptor::~TrafficDescriptor(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100B06460(void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  if (v2)
  {
    uint64_t v4 = v1[1];
    unint64_t v5 = v2;
    if (v4 != v2)
    {
      do
        uint64_t v4 = sub_100B08BB0(v4 - 4);
      while (v4 != v2);
      unint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void *sub_100B064E4(void *__dst, long long *a2)
{
  if (*((char *)a2 + 23) < 0)
  {
    sub_10004FC84(__dst, *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v4 = *a2;
    __dst[2] = *((void *)a2 + 2);
    *(_OWORD *)std::string __dst = v4;
  }
  sub_100AE5DD4(__dst + 3, (uint64_t)a2 + 24);
  return __dst;
}

void sub_100B06540(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100B0655C(uint64_t a1)
{
  sub_10005D9E0(a1 + 24, *(void **)(a1 + 32));
  if (*(char *)(a1 + 23) < 0)
  {
    uint64_t v2 = *(void **)a1;
    operator delete(v2);
  }
}

uint64_t sub_100B065B0(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 48;
    sub_100B0655C(i - 48);
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void *sub_100B06600(void *__dst, long long *a2)
{
  if (*((char *)a2 + 23) < 0)
  {
    sub_10004FC84(__dst, *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v4 = *a2;
    __dst[2] = *((void *)a2 + 2);
    *(_OWORD *)std::string __dst = v4;
  }
  char v5 = *((unsigned char *)a2 + 24);
  __dst[4] = 0;
  *((unsigned char *)__dst + 24) = v5;
  __dst[5] = 0;
  __dst[6] = 0;
  uint64_t v7 = *((void *)a2 + 4);
  uint64_t v6 = *((void *)a2 + 5);
  if (v6 != v7)
  {
    sub_100B066E4(__dst + 4, 0xAAAAAAAAAAAAAAABLL * ((v6 - v7) >> 4));
    __dst[5] = sub_100B06734(v7, v6, __dst[5]);
  }
  return __dst;
}

void sub_100B066B4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  *(void *)(v9 + 40) = v10;
  sub_100B067B8(&a9);
  if (*(char *)(v9 + 23) < 0) {
    operator delete(*(void **)v9);
  }
  _Unwind_Resume(a1);
}

char *sub_100B066E4(void *a1, unint64_t a2)
{
  if (a2 >= 0x555555555555556) {
    sub_10006A748();
  }
  uint64_t result = (char *)sub_100A52878(a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[48 * v4];
  return result;
}

uint64_t sub_100B06734(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a1 != a2)
  {
    uint64_t v6 = 0;
    do
    {
      sub_100B064E4((void *)(a3 + v6), (long long *)(a1 + v6));
      v6 += 48;
    }
    while (a1 + v6 != a2);
    a3 += v6;
  }
  return a3;
}

void sub_100B06794(_Unwind_Exception *exception_object)
{
  if (v2)
  {
    uint64_t v4 = v1 - 48;
    do
    {
      sub_100B0655C(v4 + v2);
      v2 -= 48;
    }
    while (v2);
  }
  _Unwind_Resume(exception_object);
}

void sub_100B067B8(void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  if (v2)
  {
    uint64_t v4 = (uint64_t)v1[1];
    char v5 = **a1;
    if ((void *)v4 != v2)
    {
      do
      {
        v4 -= 48;
        sub_100B0655C(v4);
      }
      while ((void *)v4 != v2);
      char v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void sub_100B0683C(uint64_t a1)
{
  uint64_t v2 = (void **)(a1 + 32);
  sub_100B067B8(&v2);
  if (*(char *)(a1 + 23) < 0) {
    operator delete(*(void **)a1);
  }
}

uint64_t sub_100B06884(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 56;
    sub_100B0683C(i - 56);
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

char *sub_100B068D4(void *a1, unint64_t a2)
{
  if (a2 >= 0x492492492492493) {
    sub_10006A748();
  }
  uint64_t result = (char *)sub_10057A920(a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[56 * v4];
  return result;
}

uint64_t sub_100B06928(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a1 != a2)
  {
    uint64_t v6 = 0;
    do
    {
      sub_100B06600((void *)(a3 + v6), (long long *)(a1 + v6));
      v6 += 56;
    }
    while (a1 + v6 != a2);
    a3 += v6;
  }
  return a3;
}

void sub_100B06988(_Unwind_Exception *exception_object)
{
  if (v2)
  {
    uint64_t v4 = v1 - 56;
    do
    {
      sub_100B0683C(v4 + v2);
      v2 -= 56;
    }
    while (v2);
  }
  _Unwind_Resume(exception_object);
}

std::string *sub_100B069AC(std::string *__str, std::string *a2, std::string *this)
{
  if (__str != a2)
  {
    for (uint64_t i = __str; i != a2; uint64_t i = (std::string *)((char *)i + 56))
    {
      std::string::operator=(this, i);
      this[1].__r_.__value_.__s.__data_[0] = i[1].__r_.__value_.__s.__data_[0];
      if (this != i)
      {
        p_std::string::size_type size = (void **)&this[1].__r_.__value_.__l.__size_;
        std::string::size_type size = this[1].__r_.__value_.__l.__size_;
        uint64_t v9 = i[1].__r_.__value_.__l.__size_;
        uint64_t v8 = i[1].__r_.__value_.__r.__words[2];
        unint64_t v10 = 0xAAAAAAAAAAAAAAABLL * ((v8 - v9) >> 4);
        std::string::pointer data = this[2].__r_.__value_.__l.__data_;
        if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)&data[-size] >> 4) >= v10)
        {
          if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(this[1].__r_.__value_.__r.__words[2] - size) >> 4) >= v10)
          {
            uint64_t v19 = sub_100B06B98((std::string *)i[1].__r_.__value_.__l.__size_, (std::string *)i[1].__r_.__value_.__r.__words[2], (std::string *)this[1].__r_.__value_.__l.__size_);
            for (uint64_t j = this[1].__r_.__value_.__r.__words[2]; (std::string *)j != v19; sub_100B0655C(j))
              j -= 48;
            this[1].__r_.__value_.__r.__words[2] = (std::string::size_type)v19;
            goto LABEL_23;
          }
          uint64_t v18 = (std::string *)(v9 + 16 * ((uint64_t)(this[1].__r_.__value_.__r.__words[2] - size) >> 4));
          sub_100B06B98((std::string *)i[1].__r_.__value_.__l.__size_, v18, (std::string *)this[1].__r_.__value_.__l.__size_);
          uint64_t v17 = sub_100B06734((uint64_t)v18, v8, this[1].__r_.__value_.__r.__words[2]);
        }
        else
        {
          if (size)
          {
            uint64_t v12 = this[1].__r_.__value_.__r.__words[2];
            uint64_t v13 = (void *)this[1].__r_.__value_.__l.__size_;
            if (v12 != size)
            {
              do
              {
                v12 -= 48;
                sub_100B0655C(v12);
              }
              while (v12 != size);
              uint64_t v13 = *p_size;
            }
            this[1].__r_.__value_.__r.__words[2] = size;
            operator delete(v13);
            std::string::pointer data = 0;
            *p_std::string::size_type size = 0;
            this[1].__r_.__value_.__r.__words[2] = 0;
            this[2].__r_.__value_.__r.__words[0] = 0;
          }
          if (v10 > 0x555555555555555) {
            sub_10006A748();
          }
          unint64_t v14 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)data >> 4);
          uint64_t v15 = 2 * v14;
          if (2 * v14 <= v10) {
            uint64_t v15 = 0xAAAAAAAAAAAAAAABLL * ((v8 - v9) >> 4);
          }
          if (v14 >= 0x2AAAAAAAAAAAAAALL) {
            unint64_t v16 = 0x555555555555555;
          }
          else {
            unint64_t v16 = v15;
          }
          sub_100B066E4(&this[1].__r_.__value_.__l.__size_, v16);
          uint64_t v17 = sub_100B06734(v9, v8, this[1].__r_.__value_.__r.__words[2]);
        }
        this[1].__r_.__value_.__r.__words[2] = v17;
      }
LABEL_23:
      this = (std::string *)((char *)this + 56);
    }
  }
  return this;
}

void sub_100B06B88(_Unwind_Exception *a1)
{
  *(void *)(v1 + 40) = v2;
  _Unwind_Resume(a1);
}

void sub_100B06B90(_Unwind_Exception *a1)
{
  *(void *)(v1 + 40) = v2;
  _Unwind_Resume(a1);
}

std::string *sub_100B06B98(std::string *__str, std::string *a2, std::string *this)
{
  if (__str != a2)
  {
    char v5 = __str;
    p_std::string::size_type size = &__str[1].__r_.__value_.__l.__size_;
    do
    {
      std::string::operator=(this, v5);
      if (v5 != this) {
        sub_10005DA3C((uint64_t **)&this[1], (void *)v5[1].__r_.__value_.__l.__data_, p_size);
      }
      v5 += 2;
      this += 2;
      p_size += 6;
    }
    while (v5 != a2);
  }
  return this;
}

void sub_100B06C10(void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  if (v2)
  {
    uint64_t v4 = (uint64_t)v1[1];
    char v5 = **a1;
    if ((void *)v4 != v2)
    {
      do
      {
        v4 -= 56;
        sub_100B0683C(v4);
      }
      while ((void *)v4 != v2);
      char v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t sub_100B06C94(uint64_t a1)
{
  sub_1000346F8(a1 + 328, *(void **)(a1 + 336));
  if (*(char *)(a1 + 327) < 0) {
    operator delete(*(void **)(a1 + 304));
  }
  if (*(char *)(a1 + 303) < 0) {
    operator delete(*(void **)(a1 + 280));
  }
  if (*(char *)(a1 + 279) < 0) {
    operator delete(*(void **)(a1 + 256));
  }
  if (*(char *)(a1 + 255) < 0) {
    operator delete(*(void **)(a1 + 232));
  }
  sub_10005CD2C(a1 + 184, *(char **)(a1 + 192));
  sub_10005CD2C(a1 + 160, *(char **)(a1 + 168));
  sub_10010C01C(a1 + 136, *(void **)(a1 + 144));
  sub_10005CD2C(a1 + 104, *(char **)(a1 + 112));
  sub_100B06D68(a1 + 80, *(void **)(a1 + 88));
  uint64_t v3 = (void **)(a1 + 56);
  sub_1008BE774(&v3);
  uint64_t v3 = (void **)(a1 + 32);
  sub_1008BE774(&v3);
  return a1;
}

void sub_100B06D68(uint64_t a1, void *a2)
{
  if (a2)
  {
    sub_100B06D68(a1, *a2);
    sub_100B06D68(a1, a2[1]);
    sub_100B06DC4((uint64_t)(a2 + 4));
    operator delete(a2);
  }
}

void sub_100B06DC4(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 56);
  if (v2)
  {
    *(void *)(a1 + 64) = v2;
    operator delete(v2);
  }
  uint64_t v3 = (void **)(a1 + 32);
  sub_100047F64(&v3);
  if (*(char *)(a1 + 31) < 0) {
    operator delete(*(void **)(a1 + 8));
  }
}

uint64_t sub_100B06E1C(int64x2_t *a1, int *a2, char **a3)
{
  uint64_t v3 = (a1->i64[1] - a1->i64[0]) >> 5;
  unint64_t v4 = v3 + 1;
  if ((unint64_t)(v3 + 1) >> 59) {
    sub_10006A748();
  }
  uint64_t v8 = a1 + 1;
  uint64_t v9 = a1[1].i64[0] - a1->i64[0];
  if (v9 >> 4 > v4) {
    unint64_t v4 = v9 >> 4;
  }
  if ((unint64_t)v9 >= 0x7FFFFFFFFFFFFFE0) {
    unint64_t v10 = 0x7FFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v10 = v4;
  }
  int v25 = (uint64_t *)v8;
  if (v10) {
    unint64_t v10 = (unint64_t)sub_1000509C0(v10);
  }
  else {
    uint64_t v11 = 0;
  }
  uint64_t v12 = (void *)(v10 + 32 * v3);
  unint64_t v22 = v10;
  v23.i64[0] = (uint64_t)v12;
  v23.i64[1] = (uint64_t)v12;
  unint64_t v24 = v10 + 32 * v11;
  *uint64_t v12 = *a2;
  sub_100058DB0(v12 + 1, *a3);
  uint64_t v13 = v23.i64[0];
  uint64_t v14 = v23.i64[1] + 32;
  v23.i64[1] += 32;
  uint64_t v16 = a1->i64[0];
  unint64_t v15 = a1->u64[1];
  if (v15 == a1->i64[0])
  {
    int64x2_t v19 = vdupq_n_s64(v15);
  }
  else
  {
    do
    {
      uint64_t v17 = *(void *)(v15 - 32);
      v15 -= 32;
      *(void *)(v13 - 32) = v17;
      v13 -= 32;
      long long v18 = *(_OWORD *)(v15 + 8);
      *(void *)(v13 + 24) = *(void *)(v15 + 24);
      *(_OWORD *)(v13 + 8) = v18;
      *(void *)(v15 + 16) = 0;
      *(void *)(v15 + 24) = 0;
      *(void *)(v15 + 8) = 0;
    }
    while (v15 != v16);
    int64x2_t v19 = *a1;
    uint64_t v14 = v23.i64[1];
  }
  a1->i64[0] = v13;
  a1->i64[1] = v14;
  int64x2_t v23 = v19;
  unint64_t v20 = a1[1].u64[0];
  a1[1].i64[0] = v24;
  unint64_t v24 = v20;
  unint64_t v22 = v19.i64[0];
  sub_100255B70((uint64_t)&v22);
  return v14;
}

void sub_100B06F48(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100255B70((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t **sub_100B06F5C(uint64_t **result, void *a2, void *a3)
{
  char v5 = result;
  if (result[2])
  {
    uint64_t v6 = *result;
    uint64_t v7 = result[1];
    *uint64_t result = (uint64_t *)(result + 1);
    v7[2] = 0;
    result[1] = 0;
    result[2] = 0;
    if (v6[1]) {
      uint64_t v8 = (uint64_t *)v6[1];
    }
    else {
      uint64_t v8 = v6;
    }
    uint64_t v14 = result;
    unint64_t v15 = v8;
    uint64_t v16 = v8;
    if (v8)
    {
      unint64_t v15 = sub_1000EA590((uint64_t)v8);
      if (a2 != a3)
      {
        uint64_t v9 = a2;
        do
        {
          v8[4] = v9[4];
          sub_10024F188(v5, v8);
          uint64_t v8 = v15;
          uint64_t v16 = v15;
          if (v15) {
            unint64_t v15 = sub_1000EA590((uint64_t)v15);
          }
          unint64_t v10 = (void *)v9[1];
          if (v10)
          {
            do
            {
              a2 = v10;
              unint64_t v10 = (void *)*v10;
            }
            while (v10);
          }
          else
          {
            do
            {
              a2 = (void *)v9[2];
              BOOL v11 = *a2 == (void)v9;
              uint64_t v9 = a2;
            }
            while (!v11);
          }
          if (!v8) {
            break;
          }
          uint64_t v9 = a2;
        }
        while (a2 != a3);
      }
    }
    uint64_t result = (uint64_t **)sub_1001A09B4((uint64_t)&v14);
  }
  if (a2 != a3)
  {
    do
    {
      uint64_t result = (uint64_t **)sub_100B070C0(v5, a2 + 4);
      uint64_t v12 = (void *)a2[1];
      if (v12)
      {
        do
        {
          uint64_t v13 = v12;
          uint64_t v12 = (void *)*v12;
        }
        while (v12);
      }
      else
      {
        do
        {
          uint64_t v13 = (void *)a2[2];
          BOOL v11 = *v13 == (void)a2;
          a2 = v13;
        }
        while (!v11);
      }
      a2 = v13;
    }
    while (v13 != a3);
  }
  return result;
}

void sub_100B070AC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1001A09B4((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t *sub_100B070C0(uint64_t **a1, unint64_t *a2)
{
  unint64_t v4 = (uint64_t *)operator new(0x28uLL);
  unint64_t v5 = *a2;
  v4[4] = *a2;
  uint64_t v6 = a1 + 1;
  uint64_t v7 = a1[1];
  if (v7)
  {
    do
    {
      while (1)
      {
        uint64_t v6 = (uint64_t **)v7;
        if (v5 >= v7[4]) {
          break;
        }
        uint64_t v7 = (uint64_t *)*v7;
        uint64_t v8 = v6;
        if (!*v6) {
          goto LABEL_8;
        }
      }
      uint64_t v7 = (uint64_t *)v7[1];
    }
    while (v7);
    uint64_t v8 = v6 + 1;
  }
  else
  {
    uint64_t v8 = a1 + 1;
  }
LABEL_8:
  sub_100046C38(a1, (uint64_t)v6, v8, v4);
  return v4;
}

uint64_t **sub_100B07150(uint64_t **result, unsigned int *a2, unsigned int *a3)
{
  unint64_t v5 = result;
  if (result[2])
  {
    uint64_t v6 = *result;
    uint64_t v7 = result[1];
    *uint64_t result = (uint64_t *)(result + 1);
    v7[2] = 0;
    result[1] = 0;
    result[2] = 0;
    if (v6[1]) {
      uint64_t v8 = (uint64_t *)v6[1];
    }
    else {
      uint64_t v8 = v6;
    }
    uint64_t v14 = result;
    unint64_t v15 = v8;
    uint64_t v16 = v8;
    if (v8)
    {
      unint64_t v15 = sub_1000EA590((uint64_t)v8);
      if (a2 != a3)
      {
        uint64_t v9 = a2;
        do
        {
          *((_DWORD *)v8 + 7) = v9[7];
          sub_100B072B4(v5, (uint64_t)v8);
          uint64_t v8 = v15;
          uint64_t v16 = v15;
          if (v15) {
            unint64_t v15 = sub_1000EA590((uint64_t)v15);
          }
          unint64_t v10 = (unsigned int *)*((void *)v9 + 1);
          if (v10)
          {
            do
            {
              a2 = v10;
              unint64_t v10 = *(unsigned int **)v10;
            }
            while (v10);
          }
          else
          {
            do
            {
              a2 = (unsigned int *)*((void *)v9 + 2);
              BOOL v11 = *(void *)a2 == (void)v9;
              uint64_t v9 = a2;
            }
            while (!v11);
          }
          if (!v8) {
            break;
          }
          uint64_t v9 = a2;
        }
        while (a2 != a3);
      }
    }
    uint64_t result = (uint64_t **)sub_1001A09B4((uint64_t)&v14);
  }
  if (a2 != a3)
  {
    do
    {
      uint64_t result = (uint64_t **)sub_100B07324(v5, a2 + 7);
      uint64_t v12 = (unsigned int *)*((void *)a2 + 1);
      if (v12)
      {
        do
        {
          uint64_t v13 = v12;
          uint64_t v12 = *(unsigned int **)v12;
        }
        while (v12);
      }
      else
      {
        do
        {
          uint64_t v13 = (unsigned int *)*((void *)a2 + 2);
          BOOL v11 = *(void *)v13 == (void)a2;
          a2 = v13;
        }
        while (!v11);
      }
      a2 = v13;
    }
    while (v13 != a3);
  }
  return result;
}

void sub_100B072A0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1001A09B4((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100B072B4(uint64_t **a1, uint64_t a2)
{
  uint64_t v3 = a1 + 1;
  unint64_t v4 = a1[1];
  if (v4)
  {
    do
    {
      while (1)
      {
        uint64_t v3 = (uint64_t **)v4;
        if (*(_DWORD *)(a2 + 28) >= *((_DWORD *)v4 + 7)) {
          break;
        }
        unint64_t v4 = (uint64_t *)*v4;
        unint64_t v5 = v3;
        if (!*v3) {
          goto LABEL_8;
        }
      }
      unint64_t v4 = (uint64_t *)v4[1];
    }
    while (v4);
    unint64_t v5 = v3 + 1;
  }
  else
  {
    unint64_t v5 = a1 + 1;
  }
LABEL_8:
  sub_100046C38(a1, (uint64_t)v3, v5, (uint64_t *)a2);
  return a2;
}

uint64_t *sub_100B07324(uint64_t **a1, unsigned int *a2)
{
  unint64_t v4 = (uint64_t *)operator new(0x20uLL);
  unsigned int v5 = *a2;
  *((_DWORD *)v4 + 7) = *a2;
  uint64_t v6 = a1 + 1;
  uint64_t v7 = a1[1];
  if (v7)
  {
    do
    {
      while (1)
      {
        uint64_t v6 = (uint64_t **)v7;
        if (v5 >= *((_DWORD *)v7 + 7)) {
          break;
        }
        uint64_t v7 = (uint64_t *)*v7;
        uint64_t v8 = v6;
        if (!*v6) {
          goto LABEL_8;
        }
      }
      uint64_t v7 = (uint64_t *)v7[1];
    }
    while (v7);
    uint64_t v8 = v6 + 1;
  }
  else
  {
    uint64_t v8 = a1 + 1;
  }
LABEL_8:
  sub_100046C38(a1, (uint64_t)v6, v8, v4);
  return v4;
}

uint64_t *sub_100B073B4(uint64_t *a1, uint64_t a2)
{
  a1[2] = 0;
  a1[1] = 0;
  *a1 = (uint64_t)(a1 + 1);
  sub_100B0740C(a1, *(unsigned int **)a2, (unsigned int *)(a2 + 8));
  return a1;
}

void sub_100B073F4(_Unwind_Exception *a1)
{
  sub_1000346F8(v1, *(void **)(v1 + 8));
  _Unwind_Resume(a1);
}

uint64_t *sub_100B0740C(uint64_t *result, unsigned int *a2, unsigned int *a3)
{
  if (a2 != a3)
  {
    unint64_t v4 = a2;
    unsigned int v5 = (uint64_t **)result;
    uint64_t v6 = result + 1;
    do
    {
      uint64_t result = sub_100B07498(v5, v6, v4 + 7, v4 + 7);
      uint64_t v7 = (unsigned int *)*((void *)v4 + 1);
      if (v7)
      {
        do
        {
          uint64_t v8 = v7;
          uint64_t v7 = *(unsigned int **)v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          uint64_t v8 = (unsigned int *)*((void *)v4 + 2);
          BOOL v9 = *(void *)v8 == (void)v4;
          unint64_t v4 = v8;
        }
        while (!v9);
      }
      unint64_t v4 = v8;
    }
    while (v8 != a3);
  }
  return result;
}

uint64_t *sub_100B07498(uint64_t **a1, uint64_t *a2, unsigned int *a3, _DWORD *a4)
{
  uint64_t v10 = 0;
  BOOL v11 = 0;
  uint64_t v6 = sub_100B07524(a1, a2, &v11, &v10, a3);
  uint64_t v7 = (uint64_t *)*v6;
  if (!*v6)
  {
    uint64_t v8 = (uint64_t **)v6;
    uint64_t v7 = (uint64_t *)operator new(0x20uLL);
    *((_DWORD *)v7 + 7) = *a4;
    sub_100046C38(a1, (uint64_t)v11, v8, v7);
  }
  return v7;
}

uint64_t *sub_100B07524(void *a1, uint64_t *a2, uint64_t **a3, uint64_t *a4, unsigned int *a5)
{
  unsigned int v5 = a1 + 1;
  if (a1 + 1 == a2 || (unsigned int v6 = *a5, v7 = *((_DWORD *)a2 + 7), *a5 < v7))
  {
    uint64_t v8 = (uint64_t *)*a2;
    if ((uint64_t *)*a1 == a2)
    {
      uint64_t v10 = a2;
LABEL_17:
      if (v8)
      {
        *a3 = v10;
        return v10 + 1;
      }
      else
      {
        *a3 = a2;
        return a2;
      }
    }
    if (v8)
    {
      BOOL v9 = (uint64_t *)*a2;
      do
      {
        uint64_t v10 = v9;
        BOOL v9 = (uint64_t *)v9[1];
      }
      while (v9);
    }
    else
    {
      uint64_t v13 = a2;
      do
      {
        uint64_t v10 = (uint64_t *)v13[2];
        BOOL v14 = *v10 == (void)v13;
        uint64_t v13 = v10;
      }
      while (v14);
    }
    unsigned int v15 = *a5;
    if (*((_DWORD *)v10 + 7) < *a5) {
      goto LABEL_17;
    }
    uint64_t v16 = *v5;
    if (*v5)
    {
      do
      {
        while (1)
        {
          uint64_t v17 = (uint64_t *)v16;
          unsigned int v18 = *(_DWORD *)(v16 + 28);
          if (v15 >= v18) {
            break;
          }
          uint64_t v16 = *v17;
          unsigned int v5 = v17;
          if (!*v17) {
            goto LABEL_29;
          }
        }
        if (v18 >= v15) {
          break;
        }
        unsigned int v5 = v17 + 1;
        uint64_t v16 = v17[1];
      }
      while (v16);
    }
    else
    {
      uint64_t v17 = a1 + 1;
    }
LABEL_29:
    *a3 = v17;
    return v5;
  }
  if (v7 >= v6)
  {
    *a3 = a2;
    *a4 = (uint64_t)a2;
    return a4;
  }
  uint64_t v11 = a2[1];
  if (v11)
  {
    uint64_t v12 = (uint64_t *)a2[1];
    do
    {
      a4 = v12;
      uint64_t v12 = (uint64_t *)*v12;
    }
    while (v12);
  }
  else
  {
    int64x2_t v19 = a2;
    do
    {
      a4 = (uint64_t *)v19[2];
      BOOL v14 = *a4 == (void)v19;
      int64x2_t v19 = a4;
    }
    while (!v14);
  }
  if (a4 != v5 && v6 >= *((_DWORD *)a4 + 7))
  {
    uint64_t v20 = *v5;
    if (*v5)
    {
      do
      {
        while (1)
        {
          uint64_t v21 = (uint64_t *)v20;
          unsigned int v22 = *(_DWORD *)(v20 + 28);
          if (v6 >= v22) {
            break;
          }
          uint64_t v20 = *v21;
          unsigned int v5 = v21;
          if (!*v21) {
            goto LABEL_48;
          }
        }
        if (v22 >= v6) {
          break;
        }
        unsigned int v5 = v21 + 1;
        uint64_t v20 = v21[1];
      }
      while (v20);
    }
    else
    {
      uint64_t v21 = a1 + 1;
    }
LABEL_48:
    *a3 = v21;
    return v5;
  }
  if (v11)
  {
    *a3 = a4;
  }
  else
  {
    *a3 = a2;
    return a2 + 1;
  }
  return a4;
}

uint64_t *sub_100B076CC(uint64_t **a1, unint64_t *a2, uint64_t *a3)
{
  unsigned int v6 = a1 + 1;
  unsigned int v5 = a1[1];
  if (v5)
  {
    unint64_t v7 = *a2;
    while (1)
    {
      while (1)
      {
        uint64_t v8 = (uint64_t **)v5;
        unint64_t v9 = v5[4];
        if (v7 >= v9) {
          break;
        }
        unsigned int v5 = *v8;
        unsigned int v6 = v8;
        if (!*v8) {
          goto LABEL_10;
        }
      }
      if (v9 >= v7) {
        break;
      }
      unsigned int v5 = v8[1];
      if (!v5)
      {
        unsigned int v6 = v8 + 1;
        goto LABEL_10;
      }
    }
  }
  else
  {
    uint64_t v8 = a1 + 1;
LABEL_10:
    uint64_t v10 = (uint64_t *)operator new(0x28uLL);
    v10[4] = *a3;
    sub_100046C38(a1, (uint64_t)v8, v6, v10);
    return v10;
  }
  return (uint64_t *)v8;
}

void sub_100B07788(char *a1)
{
  if (a1)
  {
    sub_100B07788(*(void *)a1);
    sub_100B07788(*((void *)a1 + 1));
    if (a1[80] && a1[79] < 0) {
      operator delete(*((void **)a1 + 7));
    }
    operator delete(a1);
  }
}

uint64_t sub_100B077EC(uint64_t **a1, uint64_t a2, uint64_t a3)
{
  unsigned int v6 = a1 + 1;
  unsigned int v5 = a1[1];
  if (v5)
  {
    do
    {
      while (1)
      {
        uint64_t v8 = (uint64_t **)v5;
        uint64_t v9 = (uint64_t)(v5 + 4);
        if ((sub_100B078D4(a2, (uint64_t)(v5 + 4)) & 0x80) == 0) {
          break;
        }
        unsigned int v5 = *v8;
        unsigned int v6 = v8;
        if (!*v8) {
          goto LABEL_9;
        }
      }
      uint64_t result = sub_100B078D4(v9, a2);
      if ((result & 0x80) == 0) {
        return result;
      }
      unsigned int v5 = v8[1];
    }
    while (v5);
    unsigned int v6 = v8 + 1;
  }
  else
  {
    uint64_t v8 = a1 + 1;
  }
LABEL_9:
  uint64_t v11 = operator new(0x38uLL);
  v11[2] = *(_OWORD *)a3;
  *((void *)v11 + 6) = *(void *)(a3 + 16);
  *(void *)uint64_t v11 = 0;
  *((void *)v11 + 1) = 0;
  *((void *)v11 + 2) = v8;
  *unsigned int v6 = (uint64_t *)v11;
  uint64_t v12 = (uint64_t *)**a1;
  if (v12)
  {
    *a1 = v12;
    uint64_t v13 = *v6;
  }
  else
  {
    uint64_t v13 = (uint64_t *)v11;
  }
  uint64_t result = (uint64_t)sub_100046C90(a1[1], v13);
  a1[2] = (uint64_t *)((char *)a1[2] + 1);
  return result;
}

uint64_t sub_100B078D4(uint64_t a1, uint64_t a2)
{
  int v2 = *(unsigned __int8 *)(a1 + 8);
  int v3 = *(unsigned __int8 *)(a2 + 8);
  if (*(unsigned char *)(a1 + 8)) {
    BOOL v4 = v3 == 0;
  }
  else {
    BOOL v4 = 1;
  }
  if (v4)
  {
    BOOL v5 = v3 != 0;
    BOOL v6 = v2 != 0;
    if (v5 && v2 == 0) {
      uint64_t v7 = 0xFFFFFFFFLL;
    }
    else {
      uint64_t v7 = 1;
    }
    if (((v6 ^ v5) & 1) == 0) {
      goto LABEL_15;
    }
  }
  else
  {
    if (*(void *)a1 < *(void *)a2) {
      uint64_t v7 = 0xFFFFFFFFLL;
    }
    else {
      uint64_t v7 = 1;
    }
    if (*(void *)a1 == *(void *)a2)
    {
LABEL_15:
      int v8 = *(unsigned __int8 *)(a1 + 20);
      if (*(unsigned char *)(a1 + 20) && *(unsigned char *)(a2 + 20))
      {
        unsigned int v9 = *(_DWORD *)(a1 + 16);
        unsigned int v10 = *(_DWORD *)(a2 + 16);
        BOOL v11 = v9 == v10;
        if (v9 < v10) {
          LODWORD(v7) = -1;
        }
        else {
          LODWORD(v7) = 1;
        }
        if (v11) {
          return 0;
        }
        else {
          return v7;
        }
      }
      else
      {
        int v12 = *(unsigned __int8 *)(a2 + 20) != 0;
        BOOL v4 = v8 == 0;
        int v13 = v8 != 0;
        int v14 = v4;
        if ((v12 & v14) != 0) {
          unsigned int v15 = -1;
        }
        else {
          unsigned int v15 = 1;
        }
        if (v13 != v12) {
          return v15;
        }
        else {
          return 0;
        }
      }
    }
  }
  return v7;
}

uint64_t sub_100B0798C(uint64_t **a1, uint64_t a2, uint64_t a3)
{
  BOOL v6 = (char **)(a1 + 1);
  BOOL v5 = (char *)a1[1];
  if (!v5)
  {
    int v8 = (char **)(a1 + 1);
LABEL_9:
    BOOL v11 = (char *)operator new(0x58uLL);
    *((void *)v11 + 4) = *(void *)a3;
    *(_OWORD *)(v11 + 40) = *(_OWORD *)(a3 + 8);
    sub_1000593FC((uint64_t)(v11 + 56), (long long *)(a3 + 24));
    *(void *)BOOL v11 = 0;
    *((void *)v11 + 1) = 0;
    *((void *)v11 + 2) = v8;
    *BOOL v6 = v11;
    int v12 = (uint64_t *)**a1;
    if (v12)
    {
      *a1 = v12;
      BOOL v11 = *v6;
    }
    uint64_t result = (uint64_t)sub_100046C90(a1[1], (uint64_t *)v11);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
    return result;
  }
  while (1)
  {
    while (1)
    {
      int v8 = (char **)v5;
      uint64_t v9 = (uint64_t)(v5 + 32);
      if ((sub_100B07A9C(a2, (uint64_t)(v5 + 32)) & 0x80) == 0) {
        break;
      }
      BOOL v5 = *v8;
      BOOL v6 = v8;
      if (!*v8) {
        goto LABEL_9;
      }
    }
    uint64_t result = sub_100B07A9C(v9, a2);
    if ((result & 0x80) == 0) {
      break;
    }
    BOOL v6 = v8 + 1;
    BOOL v5 = v8[1];
    if (!v5) {
      goto LABEL_9;
    }
  }
  if (!*v6) {
    goto LABEL_9;
  }
  return result;
}

void sub_100B07A88(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100B07A9C(uint64_t a1, uint64_t a2)
{
  int v2 = *(unsigned __int8 *)(a1 + 4);
  int v3 = *(unsigned __int8 *)(a2 + 4);
  if (*(unsigned char *)(a1 + 4)) {
    BOOL v4 = v3 == 0;
  }
  else {
    BOOL v4 = 1;
  }
  if (v4)
  {
    BOOL v5 = v3 != 0;
    BOOL v6 = v2 != 0;
    if (v5 && v2 == 0) {
      uint64_t v7 = 0xFFFFFFFFLL;
    }
    else {
      uint64_t v7 = 1;
    }
    if ((v6 ^ v5)) {
      return v7;
    }
  }
  else
  {
    if (*(_DWORD *)a1 < *(_DWORD *)a2) {
      uint64_t v7 = 0xFFFFFFFFLL;
    }
    else {
      uint64_t v7 = 1;
    }
    if (*(_DWORD *)a1 != *(_DWORD *)a2) {
      return v7;
    }
  }
  int v8 = *(unsigned __int8 *)(a1 + 16);
  if (*(unsigned char *)(a1 + 16) && *(unsigned char *)(a2 + 16))
  {
    unint64_t v9 = *(void *)(a1 + 8);
    unint64_t v10 = *(void *)(a2 + 8);
    BOOL v11 = v9 == v10;
    if (v9 < v10) {
      uint64_t v7 = 0xFFFFFFFFLL;
    }
    else {
      uint64_t v7 = 1;
    }
    if (!v11) {
      return v7;
    }
  }
  else
  {
    BOOL v12 = *(unsigned __int8 *)(a2 + 16) != 0;
    BOOL v13 = v8 != 0;
    if (v12 && v8 == 0) {
      uint64_t v7 = 0xFFFFFFFFLL;
    }
    else {
      uint64_t v7 = 1;
    }
    if ((v13 ^ v12)) {
      return v7;
    }
  }
  int v14 = *(unsigned __int8 *)(a1 + 48);
  if (*(unsigned char *)(a1 + 48) && *(unsigned char *)(a2 + 48)) {
    return sub_100046FE8((void *)(a1 + 24), (void **)(a2 + 24));
  }
  int v16 = *(unsigned __int8 *)(a2 + 48) != 0;
  BOOL v4 = v14 == 0;
  int v17 = v14 != 0;
  int v18 = v4;
  if ((v16 & v18) != 0) {
    unsigned int v19 = -1;
  }
  else {
    unsigned int v19 = 1;
  }
  if (v17 != v16) {
    return v19;
  }
  else {
    return 0;
  }
}

void sub_100B07B9C()
{
}

__n128 sub_100B07BB0(uint64_t a1)
{
  int v2 = (char *)operator new(0x18uLL);
  *(void *)int v2 = off_101A3A128;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_100B07BFC(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A3A128;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100B07C2C(uint64_t a1, void **this)
{
  return sub_100AF0654(*(void **)(a1 + 8), *(unsigned int *)(a1 + 16), this, 1, 1);
}

uint64_t sub_100B07C48(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100B07C88()
{
}

void *sub_100B07C94(void *a1)
{
  int v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t sub_100B07D18(void *a1)
{
  uint64_t v16 = 0;
  long long v14 = 0u;
  long long v15 = 0u;
  long long v12 = 0u;
  long long v13 = 0u;
  long long v10 = 0u;
  long long v11 = 0u;
  long long v8 = 0u;
  long long v9 = 0u;
  long long v6 = 0u;
  long long v7 = 0u;
  *(_OWORD *)__p = 0u;
  long long v5 = 0u;
  memset(v3, 0, sizeof(v3));
  sub_10004DE24((uint64_t)v3);
  std::ostream::operator<<();
  sub_10004BC98((uint64_t)v3 + 8, a1);
  if (SHIBYTE(v5) < 0) {
    operator delete(__p[1]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return std::ios::~ios();
}

void sub_100B07E78(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_100B07E90()
{
}

void *sub_100B07EA4(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_101A3A1B8;
  result[1] = v3;
  return result;
}

uint64_t sub_100B07EEC(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A3A1B8;
  a2[1] = v2;
  return result;
}

void sub_100B07F18(uint64_t a1, unsigned int *a2, int *a3)
{
  uint64_t v4 = *a2;
  int v5 = *a3;
  TrafficDescriptor::TrafficDescriptor();
  uint64_t v6 = *(void *)(a1 + 8);
  if (!v5)
  {
LABEL_9:
    uint64_t v4 = (*(uint64_t (**)(uint64_t))(*(void *)v6 + 1088))(v6);
    int v5 = 0;
    goto LABEL_10;
  }
  int v7 = (*(uint64_t (**)(uint64_t))(*(void *)v6 + 1088))(v6);
  int v8 = (*(uint64_t (**)(uint64_t))(*(void *)v6 + 1088))(v6);
  uint64_t v9 = (*(uint64_t (**)(uint64_t))(*(void *)v6 + 1088))(v6);
  char v10 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v6 + 1040))(v6, v9);
  if (!DataServiceController::SlicesDataContainer::configured(v6 + 4616, v7, v8, v10))
  {
    long long v11 = *(NSObject **)(v6 + 40);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      TrafficDescriptor::toString((uint64_t *)&v26, (TrafficDescriptor *)v23);
      long long v12 = v28 >= 0 ? (void **)&v26 : v26;
      *(_DWORD *)long long buf = 136446210;
      uint64_t v30 = v12;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#N Do not have slicing allowed, forwarding to Internet: %{public}s", buf, 0xCu);
      if (v28 < 0) {
        operator delete(v26);
      }
    }
    goto LABEL_9;
  }
LABEL_10:
  long long v13 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(v6 + 48) + 16))(*(void *)(v6 + 48), v4);
  unint64_t v24 = 0;
  int v25 = 0;
  DataServiceController::getConnection_sync(v6, v4, v5, (uint64_t *)&v24);
  long long v14 = v24;
  if (v24) {
    goto LABEL_14;
  }
  int v15 = (*(uint64_t (**)(uint64_t))(*(void *)v6 + 1088))(v6);
  DataServiceController::getConnection_sync(v6, v15, 0, (uint64_t *)&v26);
  long long v14 = v26;
  uint64_t v16 = v27;
  int v17 = v25;
  int v25 = v27;
  if (v17) {
    sub_10004D2C8(v17);
  }
  if (v14)
  {
LABEL_14:
    char v18 = sub_100AEAD30(v6, (TrafficDescriptor *)v23);
    if (v23[40]) {
      char v19 = v18;
    }
    else {
      char v19 = 1;
    }
    if ((v19 & 1) == 0)
    {
      v23[4] = 0;
      v23[8] = 0;
    }
    uint64_t v20 = *v13;
    if (os_log_type_enabled(*v13, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v21 = &v26;
      TrafficDescriptor::toString((uint64_t *)&v26, (TrafficDescriptor *)v23);
      if (v28 < 0) {
        uint64_t v21 = (void ***)v26;
      }
      (*((void (**)(void **))*v14 + 59))(v14);
      uint64_t v22 = asString();
      *(_DWORD *)long long buf = 136446466;
      uint64_t v30 = v21;
      __int16 v31 = 2082;
      uint64_t v32 = v22;
      _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#I TrafficDescriptor traffic forward: %{public}s to %{public}s", buf, 0x16u);
      if (v28 < 0) {
        operator delete(v26);
      }
    }
    sub_100B058CC(v6, (TrafficDescriptor *)v23);
    (*((void (**)(void **, unsigned char *))*v14 + 55))(v14, v23);
    uint64_t v16 = v25;
  }
  if (v16) {
    sub_10004D2C8(v16);
  }
  TrafficDescriptor::~TrafficDescriptor((TrafficDescriptor *)v23);
}

void sub_100B0832C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  uint64_t v4 = *(std::__shared_weak_count **)(v2 - 128);
  if (v4) {
    sub_10004D2C8(v4);
  }
  TrafficDescriptor::~TrafficDescriptor((TrafficDescriptor *)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100B0837C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100B083BC()
{
}

void *sub_100B083C8(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t *sub_100B0844C(uint64_t **a1, void **a2, uint64_t a3, long long **a4)
{
  uint64_t v11 = 0;
  uint64_t v6 = (uint64_t **)sub_100046ED4((uint64_t)a1, &v11, a2);
  int v7 = *v6;
  if (!*v6)
  {
    int v8 = v6;
    memset(v10, 0, sizeof(v10));
    sub_100B08504((uint64_t)a1, a4, v10);
    sub_100046C38(a1, v11, v8, v10[0]);
    int v7 = v10[0];
    v10[0] = 0;
    sub_100B085BC((uint64_t)v10, 0);
  }
  return v7;
}

double sub_100B08504@<D0>(uint64_t a1@<X0>, long long **a2@<X2>, void *a3@<X8>)
{
  uint64_t v5 = a1 + 8;
  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  uint64_t v6 = (char *)operator new(0xA8uLL);
  *a3 = v6;
  a3[1] = v5;
  *((unsigned char *)a3 + 16) = 0;
  int v7 = v6 + 32;
  int v8 = *a2;
  if (*((char *)*a2 + 23) < 0)
  {
    sub_10004FC84(v7, *(void **)v8, *((void *)v8 + 1));
  }
  else
  {
    long long v9 = *v8;
    *((void *)v6 + 6) = *((void *)v8 + 2);
    *(_OWORD *)int v7 = v9;
  }
  double result = 0.0;
  *(_OWORD *)(v6 + 152) = 0u;
  *(_OWORD *)(v6 + 136) = 0u;
  *(_OWORD *)(v6 + 120) = 0u;
  *(_OWORD *)(v6 + 104) = 0u;
  *(_OWORD *)(v6 + 88) = 0u;
  *(_OWORD *)(v6 + 72) = 0u;
  *(_OWORD *)(v6 + 56) = 0u;
  *((unsigned char *)a3 + 16) = 1;
  return result;
}

void sub_100B085A4(_Unwind_Exception *a1)
{
  sub_100B085BC(v1, 0);
  _Unwind_Resume(a1);
}

void sub_100B085BC(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void **)a1;
  *(void *)a1 = a2;
  if (v2)
  {
    if (*(unsigned char *)(a1 + 16)) {
      sub_100B08614((uint64_t)v2 + 32);
    }
    operator delete(v2);
  }
}

void sub_100B08614(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 128)) {
    sub_1000346F8(a1 + 104, *(void **)(a1 + 112));
  }
  if (*(unsigned char *)(a1 + 80)) {
    sub_10005CD2C(a1 + 56, *(char **)(a1 + 64));
  }
  if (*(unsigned char *)(a1 + 48)) {
    sub_1000346F8(a1 + 24, *(void **)(a1 + 32));
  }
  if (*(char *)(a1 + 23) < 0)
  {
    uint64_t v2 = *(void **)a1;
    operator delete(v2);
  }
}

void sub_100B08698(uint64_t a1)
{
  uint64_t v1 = *(void **)a1;
  *(void *)a1 = 0;
  if (v1)
  {
    if (*(unsigned char *)(a1 + 16)) {
      sub_10021BC80((uint64_t)v1 + 40);
    }
    operator delete(v1);
  }
}

void sub_100B086F4()
{
}

void *sub_100B08708()
{
  double result = operator new(0x10uLL);
  *double result = off_101A3A248;
  return result;
}

void sub_100B08740(uint64_t a1, void *a2)
{
  *a2 = off_101A3A248;
}

uint64_t sub_100B08768(uint64_t a1, unsigned __int8 *a2, char *a3)
{
  uint64_t v5 = a2[23];
  size_t v6 = *((void *)a2 + 1);
  if ((v5 & 0x80u) == 0) {
    size_t v7 = a2[23];
  }
  else {
    size_t v7 = *((void *)a2 + 1);
  }
  uint64_t v8 = a3[23];
  int v9 = (char)v8;
  if ((v8 & 0x80u) != 0) {
    uint64_t v8 = *((void *)a3 + 1);
  }
  if (v7 == v8)
  {
    if (v9 >= 0) {
      char v10 = a3;
    }
    else {
      char v10 = *(char **)a3;
    }
    if ((v5 & 0x80) != 0)
    {
      if (!memcmp(*(const void **)a2, v10, v6)) {
        return 1;
      }
    }
    else
    {
      if (!v5) {
        return 1;
      }
      for (uint64_t i = a2; *i == *v10; ++i)
      {
        ++v10;
        if (!--v5) {
          return 1;
        }
      }
    }
  }
  __s1 = 0;
  __CFIndex n = 0;
  uint64_t v43 = 0;
  p_s1 = &__s1;
  sub_1000C140C((uint64_t)&__s1, v7 + 5);
  if (v43 < 0) {
    p_s1 = __s1;
  }
  if (v7)
  {
    if ((a2[23] & 0x80u) == 0) {
      long long v13 = a2;
    }
    else {
      long long v13 = *(const void **)a2;
    }
    memmove(p_s1, v13, v7);
  }
  strcpy((char *)p_s1 + v7, "_NULL");
  uint64_t v14 = HIBYTE(v43);
  if (v43 >= 0) {
    size_t v15 = HIBYTE(v43);
  }
  else {
    size_t v15 = __n;
  }
  int v16 = a3[23];
  if (v16 >= 0) {
    size_t v17 = a3[23];
  }
  else {
    size_t v17 = *((void *)a3 + 1);
  }
  if (v15 != v17) {
    goto LABEL_43;
  }
  if (v16 >= 0) {
    char v18 = a3;
  }
  else {
    char v18 = *(char **)a3;
  }
  if ((SHIBYTE(v43) & 0x80000000) == 0)
  {
    if (HIBYTE(v43))
    {
      char v19 = &__s1;
      while (*(unsigned __int8 *)v19 == *v18)
      {
        char v19 = (void **)((char *)v19 + 1);
        ++v18;
        if (!--v14)
        {
          BOOL v20 = 1;
          if ((v43 & 0x8000000000000000) == 0) {
            return v20;
          }
          goto LABEL_75;
        }
      }
      goto LABEL_43;
    }
    return 1;
  }
  uint64_t v21 = __s1;
  if (!memcmp(__s1, v18, __n))
  {
    BOOL v20 = 1;
    goto LABEL_76;
  }
LABEL_43:
  __p = 0;
  size_t v39 = 0;
  uint64_t v40 = 0;
  p_p = &__p;
  sub_1000C140C((uint64_t)&__p, v17 + 5);
  if (v40 < 0) {
    p_p = __p;
  }
  if (v17)
  {
    if (a3[23] >= 0) {
      int64x2_t v23 = a3;
    }
    else {
      int64x2_t v23 = *(char **)a3;
    }
    memmove(p_p, v23, v17);
  }
  strcpy((char *)p_p + v17, "_NULL");
  if (v40 >= 0) {
    size_t v24 = HIBYTE(v40);
  }
  else {
    size_t v24 = v39;
  }
  uint64_t v25 = a2[23];
  int v26 = (char)v25;
  if ((v25 & 0x80u) != 0) {
    uint64_t v25 = *((void *)a2 + 1);
  }
  if (v24 != v25)
  {
    BOOL v20 = 0;
LABEL_69:
    if ((v40 & 0x8000000000000000) == 0) {
      goto LABEL_74;
    }
    uint64_t v36 = __p;
    goto LABEL_72;
  }
  if (v26 >= 0) {
    uint64_t v27 = a2;
  }
  else {
    uint64_t v27 = *(unsigned __int8 **)a2;
  }
  if (v40 < 0)
  {
    uint64_t v36 = __p;
    BOOL v20 = memcmp(__p, v27, v39) == 0;
LABEL_72:
    operator delete(v36);
    goto LABEL_74;
  }
  if (HIBYTE(v40))
  {
    uint64_t v28 = HIBYTE(v40) - 1;
    uint64_t v29 = &__p;
    do
    {
      int v31 = *(unsigned __int8 *)v29;
      uint64_t v29 = (void **)((char *)v29 + 1);
      int v30 = v31;
      int v33 = *v27++;
      int v32 = v33;
      BOOL v35 = v28-- != 0;
      BOOL v20 = v30 == v32;
    }
    while (v30 == v32 && v35);
    goto LABEL_69;
  }
  BOOL v20 = 1;
LABEL_74:
  if (v43 < 0)
  {
LABEL_75:
    uint64_t v21 = __s1;
LABEL_76:
    operator delete(v21);
  }
  return v20;
}

void sub_100B08A2C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100B08A48(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100B08A88()
{
}

void *sub_100B08A94(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t sub_100B08B18(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

void *sub_100B08BB0(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t sub_100B08C34(uint64_t a1)
{
  *(void *)a1 = off_101A3A2D8;
  sub_100B08A94((void *)(a1 + 32));
  if (*(char *)(a1 + 31) < 0) {
    operator delete(*(void **)(a1 + 8));
  }
  return a1;
}

void sub_100B08C88(uint64_t a1)
{
  *(void *)a1 = off_101A3A2D8;
  sub_100B08A94((void *)(a1 + 32));
  if (*(char *)(a1 + 31) < 0) {
    operator delete(*(void **)(a1 + 8));
  }

  operator delete();
}

void *sub_100B08CFC(uint64_t a1)
{
  uint64_t v1 = (long long *)(a1 + 8);
  uint64_t v2 = operator new(0x40uLL);
  void *v2 = off_101A3A2D8;
  sub_100B08E78(v2 + 1, v1);
  return v2;
}

void sub_100B08D50(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_100B08D64(uint64_t a1, void *a2)
{
  *a2 = off_101A3A2D8;
  return sub_100B08E78(a2 + 1, (long long *)(a1 + 8));
}

void sub_100B08D90(uint64_t a1)
{
}

void sub_100B08D98(void *a1)
{
  sub_100B08EF0((uint64_t)a1 + 8);

  operator delete(a1);
}

uint64_t sub_100B08DD4(uint64_t a1, void *a2)
{
  uint64_t v3 = *(void *)(a1 + 56);
  if (!v3) {
    sub_10007B600();
  }
  return (*(unsigned int (**)(uint64_t, uint64_t, uint64_t))(*(void *)v3 + 48))(v3, *a2 + 48, a1 + 8) ^ 1;
}

uint64_t sub_100B08E2C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100B08E6C()
{
}

void *sub_100B08E78(void *__dst, long long *a2)
{
  if (*((char *)a2 + 23) < 0)
  {
    sub_10004FC84(__dst, *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v4 = *a2;
    __dst[2] = *((void *)a2 + 2);
    *(_OWORD *)std::string __dst = v4;
  }
  sub_100B08B18((uint64_t)(__dst + 3), (uint64_t)a2 + 24);
  return __dst;
}

void sub_100B08ED4(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100B08EF0(uint64_t a1)
{
  sub_100B08A94((void *)(a1 + 24));
  if (*(char *)(a1 + 23) < 0)
  {
    uint64_t v2 = *(void **)a1;
    operator delete(v2);
  }
}

uint64_t sub_100B08F40(uint64_t a1)
{
  *(void *)a1 = off_101A3A368;
  if (*(char *)(a1 + 31) < 0) {
    operator delete(*(void **)(a1 + 8));
  }
  return a1;
}

void sub_100B08F90(uint64_t a1)
{
  *(void *)a1 = off_101A3A368;
  if (*(char *)(a1 + 31) < 0) {
    operator delete(*(void **)(a1 + 8));
  }

  operator delete();
}

void *sub_100B09000(uint64_t a1)
{
  uint64_t v2 = operator new(0x20uLL);
  void *v2 = off_101A3A368;
  uint64_t v3 = v2 + 1;
  if (*(char *)(a1 + 31) < 0)
  {
    sub_10004FC84(v3, *(void **)(a1 + 8), *(void *)(a1 + 16));
  }
  else
  {
    *(_OWORD *)uint64_t v3 = *(_OWORD *)(a1 + 8);
    v2[3] = *(void *)(a1 + 24);
  }
  return v2;
}

void sub_100B09074(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

char *sub_100B09088(char *result, void *a2)
{
  *a2 = off_101A3A368;
  uint64_t v2 = a2 + 1;
  if (result[31] < 0) {
    return (char *)sub_10004FC84(v2, *((void **)result + 1), *((void *)result + 2));
  }
  long long v3 = *(_OWORD *)(result + 8);
  v2[2] = *((void *)result + 3);
  *(_OWORD *)uint64_t v2 = v3;
  return result;
}

void sub_100B090D4(uint64_t a1)
{
  if (*(char *)(a1 + 31) < 0) {
    operator delete(*(void **)(a1 + 8));
  }
}

void sub_100B090E8(void **__p)
{
  if (*((char *)__p + 31) < 0) {
    operator delete(__p[1]);
  }

  operator delete(__p);
}

uint64_t sub_100B0912C(uint64_t a1, void *a2, uint64_t a3, void *a4)
{
  return (*(unsigned int (**)(void, uint64_t, uint64_t))(*(void *)*a4 + 944))(*a4, *a2 + 48, a1 + 8) ^ 1;
}

uint64_t sub_100B09180(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100B091C0()
{
}

uint64_t sub_100B091CC(uint64_t a1)
{
  *(void *)a1 = off_101A3A3E8;
  if (*(unsigned char *)(a1 + 328)) {
    TrafficDescriptor::~TrafficDescriptor((TrafficDescriptor *)(a1 + 24));
  }
  return a1;
}

void sub_100B0921C(uint64_t a1)
{
  *(void *)a1 = off_101A3A3E8;
  if (*(unsigned char *)(a1 + 328)) {
    TrafficDescriptor::~TrafficDescriptor((TrafficDescriptor *)(a1 + 24));
  }

  operator delete();
}

void *sub_100B0928C(uint64_t a1)
{
  uint64_t v2 = operator new(0x150uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *v2 = off_101A3A3E8;
  v2[1] = v3;
  *((_DWORD *)v2 + 4) = *(_DWORD *)(a1 + 16);
  sub_100B06400((TrafficDescriptor *)(v2 + 3), (const TrafficDescriptor *)(a1 + 24));
  return v2;
}

void sub_100B092F0(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

TrafficDescriptor *sub_100B09304(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A3A3E8;
  uint64_t v2 = *(void *)(a1 + 8);
  *(_DWORD *)(a2 + 16) = *(_DWORD *)(a1 + 16);
  *(void *)(a2 + 8) = v2;
  return sub_100B06400((TrafficDescriptor *)(a2 + 24), (const TrafficDescriptor *)(a1 + 24));
}

void sub_100B09340(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 328)) {
    TrafficDescriptor::~TrafficDescriptor((TrafficDescriptor *)(a1 + 24));
  }
}

void sub_100B09354(char *__p)
{
  if (__p[328]) {
    TrafficDescriptor::~TrafficDescriptor((TrafficDescriptor *)(__p + 24));
  }

  operator delete(__p);
}

uint64_t sub_100B09398(uint64_t a1, uint64_t a2, int *a3, void *a4)
{
  int v5 = *a3;
  uint64_t v6 = *(void *)(a1 + 8);
  if ((*(uint64_t (**)(void, uint64_t))(*(void *)*a4 + 928))(*a4, 2)) {
    return 1;
  }
  uint64_t v7 = sub_100AEFE40(*(void *)(v6 + 144), *(_DWORD *)(a1 + 16));
  int v9 = *(uint64_t **)v7;
  uint64_t v8 = *(uint64_t **)(v7 + 8);
  if (*(uint64_t **)v7 == v8) {
    return 1;
  }
  uint64_t v23 = v6;
  while (1)
  {
    uint64_t v11 = *v9;
    char v10 = (std::__shared_weak_count *)v9[1];
    if (v10) {
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    if (!v11 || (*(unsigned int (**)(uint64_t))(*(void *)v11 + 472))(v11) != v5)
    {
      int v18 = 3;
      if (!v10) {
        goto LABEL_35;
      }
      goto LABEL_34;
    }
    v30[0] = 0;
    v30[1] = 0;
    uint64_t v31 = 0;
    uint64_t v28 = 0;
    v29[0] = 0;
    v29[1] = 0;
    uint64_t v12 = (*(uint64_t (**)(uint64_t, void **))(*(void *)v11 + 408))(v11, v30);
    sub_100AE5DD4(&v28, v12);
    long long v13 = v28;
    if (v28 == v29)
    {
LABEL_17:
      int v18 = 0;
    }
    else
    {
      while (1)
      {
        if (!*(unsigned char *)(a1 + 328)) {
          sub_10016C840();
        }
        uint64_t v14 = (TrafficDescriptor *)(v13 + 4);
        if (TrafficDescriptor::operator==()) {
          break;
        }
        size_t v15 = v13[1];
        if (v15)
        {
          do
          {
            int v16 = (void **)v15;
            size_t v15 = (void *)*v15;
          }
          while (v15);
        }
        else
        {
          do
          {
            int v16 = (void **)v13[2];
            BOOL v17 = *v16 == v13;
            long long v13 = v16;
          }
          while (!v17);
        }
        long long v13 = v16;
        if (v16 == v29) {
          goto LABEL_17;
        }
      }
      char v19 = *(NSObject **)(v23 + 40);
      if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
      {
        TrafficDescriptor::toString((uint64_t *)v26, v14);
        if (v27 >= 0) {
          BOOL v20 = v26;
        }
        else {
          BOOL v20 = (void **)v26[0];
        }
        if (!*(unsigned char *)(a1 + 328)) {
          sub_10016C840();
        }
        TrafficDescriptor::toString((uint64_t *)__p, (TrafficDescriptor *)(a1 + 24));
        uint64_t v21 = __p;
        if (v25 < 0) {
          uint64_t v21 = (void **)__p[0];
        }
        *(_DWORD *)long long buf = 136315394;
        int v33 = v20;
        __int16 v34 = 2080;
        BOOL v35 = v21;
        _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#I matched td=%s, dnnTd=%s", buf, 0x16u);
        if (v25 < 0) {
          operator delete(__p[0]);
        }
        if (v27 < 0) {
          operator delete(v26[0]);
        }
      }
      int v18 = 1;
    }
    sub_10005D9E0((uint64_t)&v28, v29[0]);
    if (SHIBYTE(v31) < 0)
    {
      operator delete(v30[0]);
      if (!v10) {
        goto LABEL_35;
      }
LABEL_34:
      sub_10004D2C8(v10);
      goto LABEL_35;
    }
    if (v10) {
      goto LABEL_34;
    }
LABEL_35:
    if (v18 != 3 && v18) {
      return 0;
    }
    v9 += 2;
    if (v9 == v8) {
      return 1;
    }
  }
}

void sub_100B096C8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,char a22,void *a23,uint64_t a24,void *a25,uint64_t a26,int a27,__int16 a28,char a29,char a30)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  sub_10005D9E0((uint64_t)&a22, a23);
  if (a30 < 0) {
    operator delete(a25);
  }
  if (v30) {
    sub_10004D2C8(v30);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100B09730(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100B09770()
{
}

void sub_100B09780()
{
}

void *sub_100B09794()
{
  double result = operator new(0x10uLL);
  *double result = off_101A3A468;
  return result;
}

void sub_100B097CC(uint64_t a1, void *a2)
{
  *a2 = off_101A3A468;
}

BOOL sub_100B097F4(uint64_t a1, uint64_t *a2, uint64_t a3, void *a4)
{
  if (!(*(unsigned int (**)(void, uint64_t))(*(void *)*a4 + 928))(*a4, 2)) {
    return 1;
  }
  uint64_t v5 = *a2;
  uint64_t v6 = (const char *)asString();
  uint64_t v7 = v6;
  int v8 = *(char *)(v5 + 71);
  size_t v9 = v8 >= 0 ? *(unsigned __int8 *)(v5 + 71) : *(void *)(v5 + 56);
  if (v9 != strlen(v6)) {
    return 1;
  }
  uint64_t v12 = *(const void **)(v5 + 48);
  uint64_t v11 = (const void *)(v5 + 48);
  char v10 = v12;
  if (v8 >= 0) {
    long long v13 = v11;
  }
  else {
    long long v13 = v10;
  }
  return memcmp(v13, v7, v9) != 0;
}

uint64_t sub_100B098B0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100B098F0()
{
}

void sub_100B09900()
{
}

__n128 sub_100B09914(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_101A3A4E8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_100B09960(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A3A4E8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100B09990(uint64_t a1, uint64_t a2, int *a3, void *a4)
{
  int v5 = *a3;
  uint64_t v6 = *(void *)(a1 + 8);
  if ((*(unsigned int (**)(void, uint64_t))(*(void *)*a4 + 928))(*a4, 2))
  {
    uint64_t v7 = sub_100AEFE40(*(void *)(v6 + 144), *(_DWORD *)(a1 + 16));
    int v8 = *(uint64_t **)v7;
    size_t v9 = *(uint64_t **)(v7 + 8);
    if (*(uint64_t **)v7 == v9) {
      return 0;
    }
    while (1)
    {
      uint64_t v11 = *v8;
      char v10 = (std::__shared_weak_count *)v8[1];
      if (v10) {
        atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      if (v11 && (*(unsigned int (**)(uint64_t))(*(void *)v11 + 472))(v11) == v5)
      {
        __p[0] = 0;
        __p[1] = 0;
        uint64_t v15 = 0;
        int v12 = *(void *)((*(uint64_t (**)(uint64_t, void **))(*(void *)v11 + 408))(v11, __p) + 16) != 0;
        if (SHIBYTE(v15) < 0) {
          operator delete(__p[0]);
        }
      }
      else
      {
        int v12 = 3;
      }
      if (v10) {
        sub_10004D2C8(v10);
      }
      if (v12 != 3 && v12) {
        break;
      }
      v8 += 2;
      if (v8 == v9) {
        return 0;
      }
    }
  }
  return 1;
}

void sub_100B09B00(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  if (v15) {
    sub_10004D2C8(v15);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100B09B30(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100B09B70()
{
}

void sub_100B09B80()
{
}

void *sub_100B09B94()
{
  __n128 result = operator new(0x10uLL);
  *__n128 result = off_101A3A568;
  return result;
}

void sub_100B09BCC(uint64_t a1, void *a2)
{
  *a2 = off_101A3A568;
}

uint64_t sub_100B09BF4(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  return (*(unsigned int (**)(void, uint64_t))(*(void *)*a4 + 928))(*a4, 2) ^ 1;
}

uint64_t sub_100B09C40(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100B09C80()
{
}

uint64_t sub_100B09C8C(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

uint64_t sub_100B09D24(uint64_t a1)
{
  *(void *)a1 = off_101A3A5E8;
  uint64_t v3 = (void **)(a1 + 56);
  sub_1008BE774(&v3);
  sub_100B083C8((void *)(a1 + 24));
  return a1;
}

void sub_100B09D84(uint64_t a1)
{
  *(void *)a1 = off_101A3A5E8;
  uint64_t v2 = (void **)(a1 + 56);
  sub_1008BE774(&v2);
  sub_100B083C8((void *)(a1 + 24));
  operator delete();
}

void *sub_100B09DF8(uint64_t a1)
{
  uint64_t v1 = (uint64_t *)(a1 + 8);
  uint64_t v2 = operator new(0x50uLL);
  void *v2 = off_101A3A5E8;
  sub_100B0A360((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_100B09E4C(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100B09E60(uint64_t a1, void *a2)
{
  *a2 = off_101A3A5E8;
  return sub_100B0A360((uint64_t)(a2 + 1), (uint64_t *)(a1 + 8));
}

void *sub_100B09E8C(uint64_t a1)
{
  uint64_t v3 = (void **)(a1 + 56);
  sub_1008BE774(&v3);
  return sub_100B083C8((void *)(a1 + 24));
}

void sub_100B09ECC(uint64_t a1)
{
  uint64_t v2 = (void **)(a1 + 56);
  sub_1008BE774(&v2);
  sub_100B083C8((void *)(a1 + 24));
  operator delete((void *)a1);
}

void sub_100B09F14(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  long long v4 = *(const TrafficDescriptor **)(a1 + 56);
  if (*(const TrafficDescriptor **)(a1 + 64) == v4) {
    sub_10015B728();
  }
  uint64_t v27 = a2;
  uint64_t v6 = *a3;
  uint64_t v26 = *(void *)(a1 + 8);
  memset(v36, 0, sizeof(v36));
  long long v34 = 0u;
  long long v35 = 0u;
  memset(v33, 0, sizeof(v33));
  long long v31 = 0u;
  long long v32 = 0u;
  long long v30 = 0u;
  TrafficDescriptor::TrafficDescriptor((TrafficDescriptor *)&v30, v4);
  if (v6)
  {
    uint64_t v7 = 0;
    uint64_t v8 = 304;
    do
    {
      uint64_t v9 = *(void *)(a1 + 56);
      if (v7 + 1 >= 0x86BCA1AF286BCA1BLL * ((*(void *)(a1 + 64) - v9) >> 4)) {
        break;
      }
      uint64_t v10 = v9 + v8;
      if ((_BYTE)v34) {
        BOOL v11 = 1;
      }
      else {
        BOOL v11 = *(unsigned char *)(v9 + v8 + 208) == 0;
      }
      if (!v11)
      {
        CSIPacketAddress::CSIPacketAddress((CSIPacketAddress *)&v33[136], (const CSIPacketAddress *)(v10 + 184));
        LOBYTE(v34) = 1;
      }
      if (!BYTE8(v30) && *(unsigned char *)(v10 + 8))
      {
        int v12 = *(_DWORD *)(v9 + v8 + 4);
        BYTE8(v30) = *(unsigned char *)(v9 + v8 + 8);
        DWORD1(v30) = v12;
      }
      if (!BYTE8(v32) && *(unsigned char *)(v9 + v8 + 40)) {
        sub_100179AF8((std::string *)&v31, (const std::string *)(v9 + v8 + 16));
      }
      if ((TrafficDescriptor::hasBundleInfo((TrafficDescriptor *)&v30) & 1) == 0
        && TrafficDescriptor::hasBundleInfo((TrafficDescriptor *)(v9 + v8)))
      {
        sub_100179AF8((std::string *)v33, (const std::string *)(v9 + v8 + 48));
      }
      uint64_t v13 = v9 + v8;
      if (!v33[128] && *(unsigned char *)(v13 + 176)) {
        sub_100179AF8((std::string *)&v33[104], (const std::string *)(v9 + v8 + 152));
      }
      if (!BYTE6(v34) && *(unsigned char *)(v13 + 214))
      {
        __int16 v14 = *(_WORD *)(v9 + v8 + 212);
        BYTE6(v34) = *(unsigned char *)(v9 + v8 + 214);
        WORD2(v34) = v14;
      }
      uint64_t v15 = v9 + v8;
      if (!BYTE12(v34) && *(unsigned char *)(v15 + 220))
      {
        DWORD2(v34) = *(_DWORD *)(v9 + v8 + 216);
        BYTE12(v34) = 1;
      }
      if (!(_BYTE)v35 && *(unsigned char *)(v15 + 224))
      {
        __int16 v16 = *(_WORD *)(v9 + v8 + 222);
        LOBYTE(v35) = *(unsigned char *)(v9 + v8 + 224);
        HIWORD(v34) = v16;
      }
      if (!BYTE8(v35) && *(unsigned char *)(v9 + v8 + 232))
      {
        int v17 = *(_DWORD *)(v9 + v8 + 228);
        BYTE8(v35) = *(unsigned char *)(v9 + v8 + 232);
        DWORD1(v35) = v17;
      }
      if ((TrafficDescriptor::hasDnnInfo((TrafficDescriptor *)&v30) & 1) == 0
        && TrafficDescriptor::hasDnnInfo((TrafficDescriptor *)(v9 + v8)))
      {
        sub_100179AF8((std::string *)v36, (const std::string *)(v9 + v8 + 240));
      }
      v8 += 304;
      ++v7;
    }
    while (v6 != v7);
  }
  unsigned int v18 = *(_DWORD *)(a1 + 16);
  TrafficDescriptor::TrafficDescriptor((TrafficDescriptor *)v28, (const TrafficDescriptor *)&v30);
  char v29 = 1;
  int v19 = sub_100AF4954(v26, v18, (void **)v27, (const TrafficDescriptor *)v28);
  if (v29) {
    TrafficDescriptor::~TrafficDescriptor((TrafficDescriptor *)v28);
  }
  BOOL v20 = *(NSObject **)(v26 + 40);
  if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
  {
    int v21 = *(char *)(v27 + 23);
    uint64_t v22 = *(void **)v27;
    uint64_t v23 = asString();
    if (v21 >= 0) {
      size_t v24 = (void *)v27;
    }
    else {
      size_t v24 = v22;
    }
    *(_DWORD *)long long buf = 136446466;
    int v38 = v24;
    __int16 v39 = 2080;
    uint64_t v40 = v23;
    _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#I TrafficDescriptor match: for dnn %{public}s selected connection %s", buf, 0x16u);
  }
  int v25 = *(_DWORD *)(a1 + 16);
  TrafficDescriptor::TrafficDescriptor((TrafficDescriptor *)buf, (const TrafficDescriptor *)&v30);
  sub_100AF58F0(*(void *)(a1 + 48), v25, v19);
  TrafficDescriptor::~TrafficDescriptor((TrafficDescriptor *)buf);
  TrafficDescriptor::~TrafficDescriptor((TrafficDescriptor *)&v30);
}

void sub_100B0A2CC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,char a57)
{
}

uint64_t sub_100B0A314(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100B0A354()
{
}

uint64_t sub_100B0A360(uint64_t a1, uint64_t *a2)
{
  uint64_t v4 = *a2;
  *(_DWORD *)(a1 + 8) = *((_DWORD *)a2 + 2);
  *(void *)a1 = v4;
  sub_100B09C8C(a1 + 16, (uint64_t)(a2 + 2));
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 64) = 0;
  sub_100B05E34((void *)(a1 + 48), a2[6], a2[7], 0x86BCA1AF286BCA1BLL * ((a2[7] - a2[6]) >> 4));
  return a1;
}

void sub_100B0A3E0(_Unwind_Exception *a1)
{
  sub_100B083C8(v1);
  _Unwind_Resume(a1);
}

void *sub_100B0A3F4(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t sub_100B0A478(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

uint64_t sub_100B0A510(uint64_t a1)
{
  *(void *)a1 = off_101A3A678;
  uint64_t v2 = (TrafficDescriptor *)(a1 + 56);
  uint64_t v4 = (void **)(a1 + 368);
  sub_1008BE774(&v4);
  TrafficDescriptor::~TrafficDescriptor(v2);
  sub_100B0A3F4((void *)(a1 + 24));
  return a1;
}

void sub_100B0A57C(uint64_t a1)
{
  *(void *)a1 = off_101A3A678;
  uint64_t v2 = (TrafficDescriptor *)(a1 + 56);
  uint64_t v3 = (void **)(a1 + 368);
  sub_1008BE774(&v3);
  TrafficDescriptor::~TrafficDescriptor(v2);
  sub_100B0A3F4((void *)(a1 + 24));
  operator delete();
}

void *sub_100B0A5FC(uint64_t a1)
{
  uint64_t v1 = (uint64_t *)(a1 + 8);
  uint64_t v2 = operator new(0x188uLL);
  void *v2 = off_101A3A678;
  sub_100B0A948((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_100B0A650(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100B0A664(uint64_t a1, void *a2)
{
  *a2 = off_101A3A678;
  return sub_100B0A948((uint64_t)(a2 + 1), (uint64_t *)(a1 + 8));
}

void *sub_100B0A690(uint64_t a1)
{
  return sub_100B0AA00(a1 + 8);
}

void sub_100B0A698(void *a1)
{
  sub_100B0AA00((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_100B0A6D4(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 8);
  int v5 = *(NSObject **)(v4 + 40);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    int v6 = *(_DWORD *)(a1 + 360);
    TrafficDescriptor::toString((uint64_t *)__p, (TrafficDescriptor *)(a1 + 56));
    uint64_t v7 = v18 >= 0 ? __p : (void **)__p[0];
    uint64_t v8 = *(char *)(a2 + 23) >= 0 ? a2 : *(void *)a2;
    LODWORD(buf) = 67109634;
    HIDWORD(buf) = v6;
    __int16 v21 = 2080;
    uint64_t v22 = v7;
    __int16 v23 = 2082;
    uint64_t v24 = v8;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I TrafficDescriptor lookup result[%u] for %s: dnn %{public}s", (uint8_t *)&buf, 0x1Cu);
    if (SHIBYTE(v18) < 0) {
      operator delete(__p[0]);
    }
  }
  uint64_t v9 = *(unsigned __int8 *)(a2 + 23);
  if ((v9 & 0x80u) != 0) {
    uint64_t v9 = *(void *)(a2 + 8);
  }
  if (v9) {
    goto LABEL_15;
  }
  uint64_t v10 = *(void *)(a1 + 368);
  unint64_t v11 = *(void *)(a1 + 360) + 1;
  uint64_t v12 = *(void *)(a1 + 376);
  unint64_t v13 = 0x86BCA1AF286BCA1BLL * ((v12 - v10) >> 4);
  if (v11 >= v13) {
    goto LABEL_15;
  }
  int v14 = *(_DWORD *)(a1 + 16);
  __p[1] = 0;
  uint64_t v18 = 0;
  __p[0] = 0;
  sub_100B05E34(__p, v10, v12, v13);
  sub_100B0A478((uint64_t)&buf, a1 + 24);
  char v15 = sub_100AF59F4(v4, v14, v11, (uint64_t *)__p, (uint64_t)&buf);
  sub_100B0A3F4(&buf);
  int v19 = __p;
  sub_1008BE774(&v19);
  if ((v15 & 1) == 0)
  {
LABEL_15:
    uint64_t v16 = *(void *)(a1 + 48);
    int v19 = *(void ***)(a1 + 360);
    if (!v16) {
      sub_10007B600();
    }
    (*(void (**)(uint64_t, uint64_t, void ***))(*(void *)v16 + 48))(v16, a2, &v19);
  }
}

void sub_100B0A8C8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void **a12, uint64_t a13)
{
  a12 = (void **)&a9;
  sub_1008BE774(&a12);
  _Unwind_Resume(a1);
}

uint64_t sub_100B0A8FC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100B0A93C()
{
}

uint64_t sub_100B0A948(uint64_t a1, uint64_t *a2)
{
  uint64_t v4 = *a2;
  *(_DWORD *)(a1 + 8) = *((_DWORD *)a2 + 2);
  *(void *)a1 = v4;
  sub_100B0A478(a1 + 16, (uint64_t)(a2 + 2));
  TrafficDescriptor::TrafficDescriptor((TrafficDescriptor *)(a1 + 48), (const TrafficDescriptor *)(a2 + 6));
  *(void *)(a1 + 352) = a2[44];
  *(void *)(a1 + 360) = 0;
  *(void *)(a1 + 368) = 0;
  *(void *)(a1 + 376) = 0;
  sub_100B05E34((void *)(a1 + 360), a2[45], a2[46], 0x86BCA1AF286BCA1BLL * ((a2[46] - a2[45]) >> 4));
  return a1;
}

void sub_100B0A9DC(_Unwind_Exception *a1)
{
  TrafficDescriptor::~TrafficDescriptor(v2);
  sub_100B0A3F4(v1);
  _Unwind_Resume(a1);
}

void *sub_100B0AA00(uint64_t a1)
{
  uint64_t v3 = (void **)(a1 + 360);
  sub_1008BE774(&v3);
  TrafficDescriptor::~TrafficDescriptor((TrafficDescriptor *)(a1 + 48));
  return sub_100B0A3F4((void *)(a1 + 16));
}

uint64_t sub_100B0AA48(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

uint64_t sub_100B0AAE0(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

uint64_t sub_100B0AAF0(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100B0AB0C(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

uint64_t sub_100B0AB1C(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

uint64_t sub_100B0ABB4(void *a1, uint64_t a2)
{
  if (a1[2] == *(void *)(a2 + 16))
  {
    uint64_t v4 = (void *)*a1;
    uint64_t v2 = a1 + 1;
    uint64_t v3 = v4;
    if (v4 == v2) {
      return 1;
    }
    if (*(void *)(a2 + 8))
    {
      while (1)
      {
        unint64_t v5 = v3[4];
        int v6 = (void *)(a2 + 8);
        uint64_t v7 = *(void **)(a2 + 8);
        do
        {
          unint64_t v8 = v7[4];
          BOOL v9 = v8 >= v5;
          if (v8 >= v5) {
            uint64_t v10 = v7;
          }
          else {
            uint64_t v10 = v7 + 1;
          }
          if (v9) {
            int v6 = v7;
          }
          uint64_t v7 = (void *)*v10;
        }
        while (*v10);
        if (v6 == (void *)(a2 + 8)
          || v5 < v6[4]
          || *((unsigned __int8 *)v6 + 40) != *((unsigned __int8 *)v3 + 40)
          || *((_DWORD *)v6 + 11) != *((_DWORD *)v3 + 11))
        {
          break;
        }
        unint64_t v11 = (void *)v3[1];
        if (v11)
        {
          do
          {
            uint64_t v12 = v11;
            unint64_t v11 = (void *)*v11;
          }
          while (v11);
        }
        else
        {
          do
          {
            uint64_t v12 = (void *)v3[2];
            BOOL v13 = *v12 == (void)v3;
            uint64_t v3 = v12;
          }
          while (!v13);
        }
        uint64_t v3 = v12;
        if (v12 == v2) {
          return 1;
        }
      }
    }
  }
  return 0;
}

uint64_t **sub_100B0AC80(uint64_t **result, void *a2, void *a3)
{
  unint64_t v5 = result;
  if (result[2])
  {
    int v6 = *result;
    uint64_t v7 = result[1];
    *__n128 result = (uint64_t *)(result + 1);
    v7[2] = 0;
    result[1] = 0;
    result[2] = 0;
    if (v6[1]) {
      unint64_t v8 = (uint64_t *)v6[1];
    }
    else {
      unint64_t v8 = v6;
    }
    int v14 = result;
    char v15 = v8;
    uint64_t v16 = v8;
    if (v8)
    {
      char v15 = sub_1000EA590((uint64_t)v8);
      if (a2 != a3)
      {
        BOOL v9 = a2;
        do
        {
          v8[4] = v9[4];
          v8[5] = v9[5];
          sub_10024F188(v5, v8);
          unint64_t v8 = v15;
          uint64_t v16 = v15;
          if (v15) {
            char v15 = sub_1000EA590((uint64_t)v15);
          }
          uint64_t v10 = (void *)v9[1];
          if (v10)
          {
            do
            {
              a2 = v10;
              uint64_t v10 = (void *)*v10;
            }
            while (v10);
          }
          else
          {
            do
            {
              a2 = (void *)v9[2];
              BOOL v11 = *a2 == (void)v9;
              BOOL v9 = a2;
            }
            while (!v11);
          }
          if (!v8) {
            break;
          }
          BOOL v9 = a2;
        }
        while (a2 != a3);
      }
    }
    __n128 result = (uint64_t **)sub_1001A09B4((uint64_t)&v14);
  }
  if (a2 != a3)
  {
    do
    {
      __n128 result = (uint64_t **)sub_10024F1F8(v5, (_OWORD *)a2 + 2);
      uint64_t v12 = (void *)a2[1];
      if (v12)
      {
        do
        {
          BOOL v13 = v12;
          uint64_t v12 = (void *)*v12;
        }
        while (v12);
      }
      else
      {
        do
        {
          BOOL v13 = (void *)a2[2];
          BOOL v11 = *v13 == (void)a2;
          a2 = v13;
        }
        while (!v11);
      }
      a2 = v13;
    }
    while (v13 != a3);
  }
  return result;
}

void sub_100B0ADD8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1001A09B4((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t *sub_100B0ADEC(uint64_t **a1, unint64_t *a2, uint64_t a3, uint64_t **a4)
{
  uint64_t v7 = a1 + 1;
  int v6 = a1[1];
  if (v6)
  {
    unint64_t v8 = *a2;
    while (1)
    {
      while (1)
      {
        BOOL v9 = (uint64_t **)v6;
        unint64_t v10 = v6[4];
        if (v8 >= v10) {
          break;
        }
        int v6 = *v9;
        uint64_t v7 = v9;
        if (!*v9) {
          goto LABEL_10;
        }
      }
      if (v10 >= v8) {
        break;
      }
      int v6 = v9[1];
      if (!v6)
      {
        uint64_t v7 = v9 + 1;
        goto LABEL_10;
      }
    }
  }
  else
  {
    BOOL v9 = a1 + 1;
LABEL_10:
    BOOL v11 = (uint64_t *)operator new(0x40uLL);
    uint64_t v12 = **a4;
    v11[7] = 0;
    v11[6] = 0;
    v11[4] = v12;
    v11[5] = (uint64_t)(v11 + 6);
    sub_100046C38(a1, (uint64_t)v9, v7, v11);
    return v11;
  }
  return (uint64_t *)v9;
}

void *sub_100B0AEB8(void *a1, void *a2)
{
  a1[1] = 0;
  uint64_t v3 = a1 + 1;
  a1[2] = 0;
  *a1 = a1 + 1;
  uint64_t v4 = a2 + 1;
  unint64_t v5 = (void *)*a2;
  if ((void *)*a2 != a2 + 1)
  {
    do
    {
      int v6 = *((_DWORD *)v5 + 7);
      uint64_t v14 = 0;
      char v15 = 0;
      uint64_t v7 = sub_100B0AFB0(a1, v3, &v15, &v14, v6);
      if (!*v7)
      {
        unint64_t v8 = (uint64_t **)v7;
        BOOL v9 = (uint64_t *)operator new(0x28uLL);
        *(uint64_t *)((char *)v9 + 28) = *(void *)((char *)v5 + 28);
        sub_100046C38((uint64_t **)a1, (uint64_t)v15, v8, v9);
      }
      unint64_t v10 = (void *)v5[1];
      if (v10)
      {
        do
        {
          BOOL v11 = v10;
          unint64_t v10 = (void *)*v10;
        }
        while (v10);
      }
      else
      {
        do
        {
          BOOL v11 = (void *)v5[2];
          BOOL v12 = *v11 == (void)v5;
          unint64_t v5 = v11;
        }
        while (!v12);
      }
      unint64_t v5 = v11;
    }
    while (v11 != v4);
  }
  return a1;
}

void sub_100B0AF98(_Unwind_Exception *a1)
{
  sub_1000346F8(v1, *(void **)(v1 + 8));
  _Unwind_Resume(a1);
}

uint64_t *sub_100B0AFB0(void *a1, uint64_t *a2, uint64_t **a3, uint64_t *a4, int a5)
{
  unint64_t v5 = a1 + 1;
  if (a1 + 1 == a2 || (int v6 = *((_DWORD *)a2 + 7), v6 > a5))
  {
    uint64_t v7 = (uint64_t *)*a2;
    if ((uint64_t *)*a1 == a2)
    {
      BOOL v9 = a2;
LABEL_18:
      if (v7)
      {
        *a3 = v9;
        return v9 + 1;
      }
      else
      {
        *a3 = a2;
        return a2;
      }
    }
    if (v7)
    {
      unint64_t v8 = (uint64_t *)*a2;
      do
      {
        BOOL v9 = v8;
        unint64_t v8 = (uint64_t *)v8[1];
      }
      while (v8);
    }
    else
    {
      BOOL v12 = a2;
      do
      {
        BOOL v9 = (uint64_t *)v12[2];
        BOOL v13 = *v9 == (void)v12;
        BOOL v12 = v9;
      }
      while (v13);
    }
    if (*((_DWORD *)v9 + 7) < a5) {
      goto LABEL_18;
    }
    uint64_t v14 = *v5;
    if (*v5)
    {
      do
      {
        while (1)
        {
          char v15 = (uint64_t *)v14;
          int v16 = *(_DWORD *)(v14 + 28);
          if (v16 <= a5) {
            break;
          }
          uint64_t v14 = *v15;
          unint64_t v5 = v15;
          if (!*v15) {
            goto LABEL_43;
          }
        }
        if (v16 >= a5) {
          break;
        }
        unint64_t v5 = v15 + 1;
        uint64_t v14 = v15[1];
      }
      while (v14);
      goto LABEL_43;
    }
LABEL_42:
    char v15 = a1 + 1;
LABEL_43:
    *a3 = v15;
    return v5;
  }
  if (v6 >= a5)
  {
    *a3 = a2;
    *a4 = (uint64_t)a2;
    return a4;
  }
  uint64_t v10 = a2[1];
  if (v10)
  {
    BOOL v11 = (uint64_t *)a2[1];
    do
    {
      a4 = v11;
      BOOL v11 = (uint64_t *)*v11;
    }
    while (v11);
  }
  else
  {
    int v17 = a2;
    do
    {
      a4 = (uint64_t *)v17[2];
      BOOL v13 = *a4 == (void)v17;
      int v17 = a4;
    }
    while (!v13);
  }
  if (a4 != v5 && *((_DWORD *)a4 + 7) <= a5)
  {
    uint64_t v18 = *v5;
    if (*v5)
    {
      do
      {
        while (1)
        {
          char v15 = (uint64_t *)v18;
          int v19 = *(_DWORD *)(v18 + 28);
          if (v19 <= a5) {
            break;
          }
          uint64_t v18 = *v15;
          unint64_t v5 = v15;
          if (!*v15) {
            goto LABEL_43;
          }
        }
        if (v19 >= a5) {
          break;
        }
        unint64_t v5 = v15 + 1;
        uint64_t v18 = v15[1];
      }
      while (v18);
      goto LABEL_43;
    }
    goto LABEL_42;
  }
  if (v10)
  {
    *a3 = a4;
  }
  else
  {
    *a3 = a2;
    return a2 + 1;
  }
  return a4;
}

uint64_t sub_100B0B138(uint64_t a1)
{
  if (*(unsigned char *)a1)
  {
    uint64_t v2 = *(void **)(a1 + 8);
    if (v2[6] == *(void *)(a1 + 32))
    {
      uint64_t v3 = (void *)v2[4];
      if (v3 == v2 + 5) {
        goto LABEL_21;
      }
      uint64_t v4 = *(void **)(a1 + 16);
      while (*((_DWORD *)v3 + 7) == *((_DWORD *)v4 + 7) && rest::operator==())
      {
        unint64_t v5 = (void *)v3[1];
        int v6 = v3;
        if (v5)
        {
          do
          {
            uint64_t v3 = v5;
            unint64_t v5 = (void *)*v5;
          }
          while (v5);
        }
        else
        {
          do
          {
            uint64_t v3 = (void *)v6[2];
            BOOL v7 = *v3 == (void)v6;
            int v6 = v3;
          }
          while (!v7);
        }
        unint64_t v8 = (void *)v4[1];
        if (v8)
        {
          do
          {
            BOOL v9 = v8;
            unint64_t v8 = (void *)*v8;
          }
          while (v8);
        }
        else
        {
          do
          {
            BOOL v9 = (void *)v4[2];
            BOOL v7 = *v9 == (void)v4;
            uint64_t v4 = v9;
          }
          while (!v7);
        }
        uint64_t v4 = v9;
        if (v3 == v2 + 5) {
          goto LABEL_21;
        }
      }
    }
    sub_10041F480((uint64_t)(v2 + 4), (void *)(a1 + 16));
    uint64_t v10 = v2[3];
    if (v10) {
      (*(void (**)(uint64_t, void *))(*(void *)v10 + 48))(v10, v2 + 4);
    }
  }
LABEL_21:
  sub_1000346F8(a1 + 16, *(void **)(a1 + 24));
  return a1;
}

uint64_t sub_100B0B280(uint64_t a1)
{
  if (*(unsigned char *)a1)
  {
    uint64_t v2 = *(void **)(a1 + 8);
    if (v2[6] == *(void *)(a1 + 32))
    {
      uint64_t v3 = (void *)v2[4];
      if (v3 == v2 + 5) {
        goto LABEL_21;
      }
      uint64_t v4 = *(void **)(a1 + 16);
      while (*((_DWORD *)v3 + 7) == *((_DWORD *)v4 + 7) && rest::operator==())
      {
        unint64_t v5 = (void *)v3[1];
        int v6 = v3;
        if (v5)
        {
          do
          {
            uint64_t v3 = v5;
            unint64_t v5 = (void *)*v5;
          }
          while (v5);
        }
        else
        {
          do
          {
            uint64_t v3 = (void *)v6[2];
            BOOL v7 = *v3 == (void)v6;
            int v6 = v3;
          }
          while (!v7);
        }
        unint64_t v8 = (void *)v4[1];
        if (v8)
        {
          do
          {
            BOOL v9 = v8;
            unint64_t v8 = (void *)*v8;
          }
          while (v8);
        }
        else
        {
          do
          {
            BOOL v9 = (void *)v4[2];
            BOOL v7 = *v9 == (void)v4;
            uint64_t v4 = v9;
          }
          while (!v7);
        }
        uint64_t v4 = v9;
        if (v3 == v2 + 5) {
          goto LABEL_21;
        }
      }
    }
    sub_10041F480((uint64_t)(v2 + 4), (void *)(a1 + 16));
    uint64_t v10 = v2[3];
    if (v10) {
      (*(void (**)(uint64_t, void *))(*(void *)v10 + 48))(v10, v2 + 4);
    }
  }
LABEL_21:
  sub_1000346F8(a1 + 16, *(void **)(a1 + 24));
  return a1;
}

void *sub_100B0B3C8(void *a1)
{
  *a1 = off_101A3A730;
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_100B0B414(void *a1)
{
  *a1 = off_101A3A730;
  uint64_t v1 = (std::__shared_weak_count *)a1[3];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

char *sub_100B0B480(uint64_t a1)
{
  __n128 result = (char *)operator new(0x20uLL);
  *(void *)__n128 result = off_101A3A730;
  *(_OWORD *)(result + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 24);
  *((void *)result + 3) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_100B0B4E4(uint64_t result, uint64_t a2)
{
  *(void *)a2 = off_101A3A730;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(result + 8);
  uint64_t v2 = *(void *)(result + 24);
  *(void *)(a2 + 24) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100B0B524(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 24);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_100B0B534(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete(__p);
}

void sub_100B0B574(void *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2)
  {
    uint64_t v3 = a1[1];
    uint64_t v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      unint64_t v5 = v4;
      if (a1[2])
      {
        sub_100058DB0(__p, "Managed DB update");
        DataServiceController::updateSlicingDefinitionsWithAppDB(v3, (unint64_t *)__p);
        if (v7 < 0) {
          operator delete(__p[0]);
        }
      }
      sub_10004D2C8(v5);
    }
  }
}

void sub_100B0B5F8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  sub_10004D2C8(v15);
  _Unwind_Resume(a1);
}

uint64_t sub_100B0B624(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_100B0B664()
{
}

uint64_t sub_100B0B670(uint64_t a1)
{
  uint64_t v2 = *(void **)a1;
  *(void *)a1 = 0;
  if (v2)
  {
    if (*(unsigned char *)(a1 + 16)) {
      sub_10010C078((uint64_t)v2 + 32);
    }
    operator delete(v2);
  }
  return a1;
}

uint64_t *sub_100B0B6B8(void **a1)
{
  uint64_t v1 = *a1;
  unint64_t v5 = a1;
  int v6 = v1;
  uint64_t v2 = *(NSObject **)(*v1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
  {
    LOWORD(__p[0]) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_ERROR, "evaluateUrspWithTd_sync return empty cb", (uint8_t *)__p, 2u);
  }
  sub_100058DB0(__p, "");
  uint64_t v3 = v1[4];
  if (!v3) {
    sub_10007B600();
  }
  (*(void (**)(uint64_t, void **))(*(void *)v3 + 48))(v3, __p);
  if (v8 < 0) {
    operator delete(__p[0]);
  }
  sub_100B0B7C4((uint64_t *)&v6);
  return sub_100046B58((uint64_t *)&v5);
}

void sub_100B0B790(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
}

uint64_t *sub_100B0B7C4(uint64_t *result)
{
  uint64_t v1 = *result;
  *__n128 result = 0;
  if (v1)
  {
    sub_10012C330((void *)(v1 + 8));
    operator delete();
  }
  return result;
}

uint64_t sub_100B0B814(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (void *)(a2 + 24);
  uint64_t v4 = *(void *)(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(*(void *)*v3 + 24))(*v3, a1);
      return a1;
    }
    *(void *)(a1 + 24) = v4;
  }
  else
  {
    uint64_t v3 = (void *)(a1 + 24);
  }
  void *v3 = 0;
  return a1;
}

uint64_t *sub_100B0B894(uint64_t *a1)
{
  uint64_t v1 = *a1;
  int v19 = a1;
  uint64_t v20 = v1;
  uint64_t v2 = *(void *)v1;
  memset(v34, 0, sizeof(v34));
  long long v32 = 0u;
  long long v33 = 0u;
  long long v30 = 0u;
  long long v31 = 0u;
  long long v28 = 0u;
  long long v29 = 0u;
  long long v26 = 0u;
  long long v27 = 0u;
  long long v25 = 0u;
  long long v24 = 0u;
  memset(v23, 0, sizeof(v23));
  memset(v22, 0, sizeof(v22));
  TrafficDescriptor::TrafficDescriptor((TrafficDescriptor *)v22);
  memset(&v21, 0, sizeof(v21));
  sub_100058DB0(__p, "DNN:");
  uint64_t v3 = (void *)(v1 + 8);
  sub_100B0BFC8(&v21, v1 + 8, (unsigned __int8 **)__p);
  if (SHIBYTE(__p[0].__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p[0].__r_.__value_.__l.__data_);
  }
  std::string::size_type size = HIBYTE(v21.__r_.__value_.__r.__words[2]);
  if ((v21.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
    std::string::size_type size = v21.__r_.__value_.__l.__size_;
  }
  if (size)
  {
    sub_100093B44((std::string *)v34, &v21);
  }
  else
  {
    memset(__p, 0, 24);
    sub_100058DB0(buf, "dnn:");
    sub_100B0BFC8(__p, v1 + 8, (unsigned __int8 **)buf);
    if ((buf[23] & 0x80000000) != 0) {
      operator delete(*(void **)buf);
    }
    std::string::size_type v5 = HIBYTE(__p[0].__r_.__value_.__r.__words[2]);
    if ((__p[0].__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      std::string::size_type v5 = __p[0].__r_.__value_.__l.__size_;
    }
    if (v5)
    {
      sub_100093B44((std::string *)v34, __p);
    }
    else
    {
      memset(buf, 0, 24);
      sub_100058DB0(&v35, "AppCategory:");
      sub_100B0BFC8((std::string *)buf, v1 + 8, (unsigned __int8 **)&v35);
      if (SHIBYTE(v35.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v35.__r_.__value_.__l.__data_);
      }
      uint64_t v6 = buf[23];
      if (buf[23] < 0) {
        uint64_t v6 = *(void *)&buf[8];
      }
      if (v6)
      {
        sub_100093B44((std::string *)v23, (const std::string *)buf);
      }
      else
      {
        memset(&v35, 0, sizeof(v35));
        sub_100058DB0(v38, "appcategory:");
        sub_100B0BFC8(&v35, v1 + 8, (unsigned __int8 **)v38);
        if (v39 < 0) {
          operator delete(v38[0]);
        }
        std::string::size_type v7 = HIBYTE(v35.__r_.__value_.__r.__words[2]);
        char v8 = HIBYTE(v35.__r_.__value_.__r.__words[2]);
        if ((v35.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
          std::string::size_type v7 = v35.__r_.__value_.__l.__size_;
        }
        if (v7)
        {
          sub_100093B44((std::string *)v23, &v35);
          char v8 = HIBYTE(v35.__r_.__value_.__r.__words[2]);
        }
        if (v8 < 0) {
          operator delete(v35.__r_.__value_.__l.__data_);
        }
      }
      if ((buf[23] & 0x80000000) != 0) {
        operator delete(*(void **)buf);
      }
    }
    if (SHIBYTE(__p[0].__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p[0].__r_.__value_.__l.__data_);
    }
  }
  if (TrafficDescriptor::empty((TrafficDescriptor *)v22))
  {
    BOOL v9 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      if (*(char *)(v1 + 31) < 0) {
        uint64_t v3 = (void *)*v3;
      }
      LODWORD(__p[0].__r_.__value_.__l.__data_) = 136315138;
      *(std::string::size_type *)((char *)__p[0].__r_.__value_.__r.__words + 4) = (std::string::size_type)v3;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#N Slice requested for %s - but we found no slice info, failing the request", (uint8_t *)__p, 0xCu);
    }
    memset(__p, 0, 24);
    sub_100B0C14C(*(void *)(v1 + 56), 0, 0, (uint64_t)__p, 22);
    if (SHIBYTE(__p[0].__r_.__value_.__r.__words[2]) < 0)
    {
      uint64_t v10 = (void *)__p[0].__r_.__value_.__r.__words[0];
LABEL_62:
      operator delete(v10);
    }
  }
  else
  {
    BOOL v11 = &v24;
    if (BYTE8(v25))
    {
      if (SBYTE7(v25) < 0)
      {
        *((void *)&v24 + 1) = 3;
        BOOL v11 = (long long *)v24;
      }
      else
      {
        BYTE7(v25) = 3;
      }
      *(_DWORD *)BOOL v11 = 7237750;
    }
    else
    {
      sub_100058DB0(&v24, "vpn");
      BYTE8(v25) = 1;
    }
    BOOL v12 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      BOOL v13 = (void *)(v1 + 8);
      if (*(char *)(v1 + 31) < 0) {
        BOOL v13 = (void *)*v3;
      }
      TrafficDescriptor::toString((uint64_t *)__p, (TrafficDescriptor *)v22);
      if ((__p[0].__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        uint64_t v14 = __p;
      }
      else {
        uint64_t v14 = (std::string *)__p[0].__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)uint64_t buf = 136315394;
      *(void *)&uint8_t buf[4] = v13;
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = v14;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I Slice requested for %s - trying to forward traffic descriptor %{public}s", buf, 0x16u);
      if (SHIBYTE(__p[0].__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p[0].__r_.__value_.__l.__data_);
      }
    }
    memset(&buf[8], 0, 48);
    uint64_t v43 = 0;
    *(void *)uint64_t buf = v2;
    if (*(char *)(v1 + 31) < 0)
    {
      sub_10004FC84(&buf[8], *(void **)(v1 + 8), *(void *)(v1 + 16));
    }
    else
    {
      long long v15 = *(_OWORD *)v3;
      *(void *)&buf[24] = *(void *)(v1 + 24);
      *(_OWORD *)&buf[8] = v15;
    }
    sub_1005237A0((uint64_t)&buf[32], v1 + 32);
    TrafficDescriptor::TrafficDescriptor((TrafficDescriptor *)__p, (const TrafficDescriptor *)v22);
    v35.__r_.__value_.__r.__words[0] = *(void *)buf;
    if ((buf[31] & 0x80000000) != 0)
    {
      sub_10004FC84(&v35.__r_.__value_.__s.__data_[8], *(void **)&buf[8], *(unint64_t *)&buf[16]);
    }
    else
    {
      *(_OWORD *)&v35.__r_.__value_.__r.__words[1] = *(_OWORD *)&buf[8];
      uint64_t v36 = *(void *)&buf[24];
    }
    sub_1005237A0((uint64_t)v37, (uint64_t)&buf[32]);
    uint64_t v40 = 0;
    int v16 = operator new(0x48uLL);
    std::string::size_type v17 = v35.__r_.__value_.__r.__words[0];
    void *v16 = off_101A3A7B0;
    v16[1] = v17;
    *((_OWORD *)v16 + 1) = *(_OWORD *)&v35.__r_.__value_.__r.__words[1];
    v16[4] = v36;
    *(_OWORD *)&v35.__r_.__value_.__r.__words[1] = 0uLL;
    uint64_t v36 = 0;
    sub_100B0B814((uint64_t)(v16 + 5), (uint64_t)v37);
    uint64_t v40 = v16;
    sub_100AF2A2C();
    sub_100B083C8(v38);
    sub_10052371C(v37);
    if (SHIBYTE(v36) < 0) {
      operator delete((void *)v35.__r_.__value_.__l.__size_);
    }
    TrafficDescriptor::~TrafficDescriptor((TrafficDescriptor *)__p);
    sub_10052371C(&buf[32]);
    if ((buf[31] & 0x80000000) != 0)
    {
      uint64_t v10 = *(void **)&buf[8];
      goto LABEL_62;
    }
  }
  if (SHIBYTE(v21.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v21.__r_.__value_.__l.__data_);
  }
  TrafficDescriptor::~TrafficDescriptor((TrafficDescriptor *)v22);
  sub_100B0BF68(&v20);
  return sub_100046B58((uint64_t *)&v19);
}

void sub_100B0BE08(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, char a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,void *__p,void *a57,int a58,__int16 a59,char a60,char a61,uint64_t a62,uint64_t a63)
{
  if (a61 < 0) {
    operator delete(__p);
  }
  if (*(char *)(v72 - 121) < 0) {
    operator delete(*(void **)(v72 - 144));
  }
  if (a72 < 0) {
    operator delete(a71);
  }
  if (a17 < 0) {
    operator delete(a12);
  }
  TrafficDescriptor::~TrafficDescriptor((TrafficDescriptor *)&a18);
  sub_100B0BF68(&a11);
  sub_100046B58(&a10);
  _Unwind_Resume(a1);
}

uint64_t *sub_100B0BF68(uint64_t *result)
{
  uint64_t v1 = *result;
  *__n128 result = 0;
  if (v1)
  {
    sub_10052371C((void *)(v1 + 32));
    if (*(char *)(v1 + 31) < 0) {
      operator delete(*(void **)(v1 + 8));
    }
    operator delete();
  }
  return result;
}

std::string *sub_100B0BFC8(std::string *a1, uint64_t a2, unsigned __int8 **a3)
{
  if (*((char *)a3 + 23) >= 0) {
    std::string::size_type v4 = *((unsigned __int8 *)a3 + 23);
  }
  else {
    std::string::size_type v4 = (std::string::size_type)a3[1];
  }
  std::string::size_type v5 = *(unsigned __int8 *)(a2 + 23);
  if ((v5 & 0x80u) != 0) {
    std::string::size_type v5 = *(void *)(a2 + 8);
  }
  if (v5 > v4)
  {
    std::string::basic_string(&__p, (const std::string *)a2, 0, v4, (std::allocator<char> *)&v20);
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
    }
    else {
      std::string::size_type size = __p.__r_.__value_.__l.__size_;
    }
    BOOL v9 = (unsigned __int8 *)*((unsigned __int8 *)a3 + 23);
    int v10 = (char)v9;
    if ((char)v9 < 0) {
      BOOL v9 = a3[1];
    }
    if ((unsigned __int8 *)size == v9)
    {
      if (v10 >= 0) {
        BOOL v11 = (unsigned __int8 *)a3;
      }
      else {
        BOOL v11 = *a3;
      }
      if ((*((unsigned char *)&__p.__r_.__value_.__s + 23) & 0x80) != 0)
      {
        std::string::size_type v17 = (void *)__p.__r_.__value_.__r.__words[0];
        int v18 = memcmp(__p.__r_.__value_.__l.__data_, v11, __p.__r_.__value_.__l.__size_);
        operator delete(v17);
        if (!v18) {
          return std::string::basic_string(a1, (const std::string *)a2, v4, 0xFFFFFFFFFFFFFFFFLL, (std::allocator<char> *)&__p);
        }
      }
      else
      {
        if (!*((unsigned char *)&__p.__r_.__value_.__s + 23)) {
          return std::string::basic_string(a1, (const std::string *)a2, v4, 0xFFFFFFFFFFFFFFFFLL, (std::allocator<char> *)&__p);
        }
        uint64_t v12 = 0;
        do
        {
          int v13 = __p.__r_.__value_.__s.__data_[v12];
          int v14 = v11[v12];
        }
        while (v13 == v14 && HIBYTE(__p.__r_.__value_.__r.__words[2]) - 1 != v12++);
        if (v13 == v14) {
          return std::string::basic_string(a1, (const std::string *)a2, v4, 0xFFFFFFFFFFFFFFFFLL, (std::allocator<char> *)&__p);
        }
      }
    }
    else if ((*((unsigned char *)&__p.__r_.__value_.__s + 23) & 0x80) != 0)
    {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    return (std::string *)sub_100058DB0(a1, "");
  }

  return (std::string *)sub_100058DB0(a1, "");
}

uint64_t sub_100B0C14C(uint64_t a1, int a2, int a3, uint64_t a4, int a5)
{
  int v8 = a2;
  int v6 = a5;
  int v7 = a3;
  if (!a1) {
    sub_10007B600();
  }
  return (*(uint64_t (**)(uint64_t, int *, int *, uint64_t, int *))(*(void *)a1 + 48))(a1, &v8, &v7, a4, &v6);
}

uint64_t sub_100B0C1A8(uint64_t a1)
{
  *(void *)a1 = off_101A3A7B0;
  sub_10052371C((void *)(a1 + 40));
  if (*(char *)(a1 + 39) < 0) {
    operator delete(*(void **)(a1 + 16));
  }
  return a1;
}

void sub_100B0C1FC(uint64_t a1)
{
  *(void *)a1 = off_101A3A7B0;
  sub_10052371C((void *)(a1 + 40));
  if (*(char *)(a1 + 39) < 0) {
    operator delete(*(void **)(a1 + 16));
  }

  operator delete();
}

void *sub_100B0C270(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t v2 = operator new(0x48uLL);
  void *v2 = off_101A3A7B0;
  sub_100B0CA80((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_100B0C2C4(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100B0C2D8(uint64_t a1, void *a2)
{
  *a2 = off_101A3A7B0;
  return sub_100B0CA80((uint64_t)(a2 + 1), a1 + 8);
}

void sub_100B0C304(uint64_t a1)
{
}

void sub_100B0C30C(void *a1)
{
  sub_100B0CB10((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_100B0C348(uint64_t a1, unsigned int *a2, int *a3)
{
  uint64_t v4 = *a2;
  int v5 = *a3;
  TrafficDescriptor::TrafficDescriptor();
  int v6 = *(void ***)(a1 + 8);
  int v7 = (os_log_t *)(*(uint64_t (**)(void *, uint64_t))(*v6[6] + 16))(v6[6], v4);
  if (isSlice())
  {
    int v8 = ((uint64_t (*)(void **))(*v6)[136])(v6);
    int v9 = ((uint64_t (*)(void **))(*v6)[136])(v6);
    uint64_t v10 = ((uint64_t (*)(void **))(*v6)[136])(v6);
    char v11 = ((uint64_t (*)(void **, uint64_t))(*v6)[130])(v6, v10);
    if (DataServiceController::SlicesDataContainer::configured((uint64_t)(v6 + 577), v8, v9, v11))
    {
      uint64_t v33 = 0;
      long long v34 = 0;
      DataServiceController::getConnection_sync((uint64_t)v6, v4, v5, &v33);
      uint64_t v12 = v33;
      if (!v33)
      {
        std::string v21 = *v7;
        if (os_log_type_enabled(*v7, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v22 = a1 + 16;
          if (*(char *)(a1 + 39) < 0) {
            uint64_t v22 = *(void *)(a1 + 16);
          }
          *(_DWORD *)uint64_t buf = 136315138;
          *(void *)&uint8_t buf[4] = v22;
          _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "#N Slice requested for %s: failure (3): ???", buf, 0xCu);
        }
        memset(buf, 0, sizeof(buf));
        sub_100B0C14C(*(void *)(a1 + 64), 0, 0, (uint64_t)buf, 61);
        if (((char)buf[23] & 0x80000000) == 0) {
          goto LABEL_51;
        }
        __int16 v23 = *(void **)buf;
        goto LABEL_50;
      }
      long long v31 = 0uLL;
      uint64_t v32 = 0;
      if ((*(uint64_t (**)(uint64_t))(*(void *)v33 + 168))(v33))
      {
        (*(void (**)(uint8_t *__return_ptr, uint64_t, void, void))(*(void *)v12 + 456))(buf, v12, 0, 0);
        int v13 = *v7;
        uint64_t v32 = *(void *)&buf[16];
        long long v31 = *(_OWORD *)buf;
        uint64_t v14 = HIBYTE(*(void *)&buf[16]);
        int v15 = (char)buf[23];
        if ((buf[23] & 0x80u) != 0) {
          uint64_t v14 = *((void *)&v31 + 1);
        }
        if (!v14)
        {
          if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v16 = a1 + 16;
            if (*(char *)(a1 + 39) < 0) {
              uint64_t v16 = *(void *)(a1 + 16);
            }
            *(_DWORD *)uint64_t buf = 136315138;
            *(void *)&uint8_t buf[4] = v16;
            _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#E Slice requested for %s: failure (4): interface name empty", buf, 0xCu);
          }
          memset(buf, 0, sizeof(buf));
          sub_100B0C14C(*(void *)(a1 + 64), 0, 0, (uint64_t)buf, 61);
          if ((char)buf[23] < 0) {
            operator delete(*(void **)buf);
          }
LABEL_48:
          if ((v15 & 0x80) == 0) {
            goto LABEL_51;
          }
          __int16 v23 = (void *)v31;
LABEL_50:
          operator delete(v23);
LABEL_51:
          if (v34) {
            sub_10004D2C8(v34);
          }
          goto LABEL_53;
        }
      }
      else
      {
        int v15 = 0;
        int v13 = *v7;
      }
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
      {
        if (*(char *)(a1 + 39) >= 0) {
          uint64_t v24 = a1 + 16;
        }
        else {
          uint64_t v24 = *(void *)(a1 + 16);
        }
        long long v25 = v29;
        TrafficDescriptor::toString((uint64_t *)v29, (TrafficDescriptor *)v28);
        if (v30 < 0) {
          long long v25 = (void **)v29[0];
        }
        (*(void (**)(uint64_t))(*(void *)v12 + 472))(v12);
        uint64_t v26 = asString();
        long long v27 = (long long *)v31;
        if (v15 >= 0) {
          long long v27 = &v31;
        }
        *(_DWORD *)uint64_t buf = 136315906;
        *(void *)&uint8_t buf[4] = v24;
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = v25;
        *(_WORD *)&buf[22] = 2080;
        uint64_t v36 = v26;
        __int16 v37 = 2080;
        int v38 = v27;
        _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I Slice requested for %s: TrafficDescriptor traffic forward: %{public}s to %s, current interface name: %s", buf, 0x2Au);
        if (v30 < 0) {
          operator delete(v29[0]);
        }
      }
      sub_100B058CC((uint64_t)v6, (TrafficDescriptor *)v28);
      if (SHIBYTE(v32) < 0)
      {
        sub_10004FC84(buf, (void *)v31, *((unint64_t *)&v31 + 1));
      }
      else
      {
        *(_OWORD *)uint64_t buf = v31;
        *(void *)&buf[16] = v32;
      }
      sub_100B0C14C(*(void *)(a1 + 64), v4, v5, (uint64_t)buf, 0);
      if ((char)buf[23] < 0) {
        operator delete(*(void **)buf);
      }
      (*(void (**)(uint64_t, unsigned char *))(*(void *)v12 + 440))(v12, v28);
      LOBYTE(v15) = HIBYTE(v32);
      goto LABEL_48;
    }
    int v19 = *v7;
    if (os_log_type_enabled(*v7, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v20 = a1 + 16;
      if (*(char *)(a1 + 39) < 0) {
        uint64_t v20 = *(void *)(a1 + 16);
      }
      *(_DWORD *)uint64_t buf = 136315138;
      *(void *)&uint8_t buf[4] = v20;
      _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#N Slice requested for %s: failure (2): do not have slicing allowed", buf, 0xCu);
    }
  }
  else
  {
    std::string::size_type v17 = *v7;
    if (os_log_type_enabled(*v7, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v18 = a1 + 16;
      if (*(char *)(a1 + 39) < 0) {
        uint64_t v18 = *(void *)(a1 + 16);
      }
      *(_DWORD *)uint64_t buf = 136315138;
      *(void *)&uint8_t buf[4] = v18;
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#N Slice requested for %s: failure (1)", buf, 0xCu);
    }
  }
  memset(buf, 0, sizeof(buf));
  sub_100B0C14C(*(void *)(a1 + 64), 0, 0, (uint64_t)buf, 61);
  if ((char)buf[23] < 0) {
    operator delete(*(void **)buf);
  }
LABEL_53:
  TrafficDescriptor::~TrafficDescriptor((TrafficDescriptor *)v28);
}

void sub_100B0C98C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  if (*(char *)(v2 - 137) < 0) {
    operator delete(*(void **)(v2 - 160));
  }
  if (*(char *)(v2 - 185) < 0) {
    operator delete(*(void **)(v2 - 208));
  }
  uint64_t v4 = *(std::__shared_weak_count **)(v2 - 168);
  if (v4) {
    sub_10004D2C8(v4);
  }
  TrafficDescriptor::~TrafficDescriptor((TrafficDescriptor *)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100B0CA34(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100B0CA74()
{
}

uint64_t sub_100B0CA80(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = *(void *)a2;
  if (*(char *)(a2 + 31) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 8), *(void **)(a2 + 8), *(void *)(a2 + 16));
  }
  else
  {
    long long v4 = *(_OWORD *)(a2 + 8);
    *(void *)(a1 + 24) = *(void *)(a2 + 24);
    *(_OWORD *)(a1 + 8) = v4;
  }
  sub_1005237A0(a1 + 32, a2 + 32);
  return a1;
}

void sub_100B0CAF4(_Unwind_Exception *exception_object)
{
  if (*(char *)(v2 + 31) < 0) {
    operator delete(*v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100B0CB10(uint64_t a1)
{
  sub_10052371C((void *)(a1 + 32));
  if (*(char *)(a1 + 31) < 0)
  {
    uint64_t v2 = *(void **)(a1 + 8);
    operator delete(v2);
  }
}

uint64_t *sub_100B0CB60(uint64_t *a1)
{
  uint64_t v1 = *a1;
  long long v31 = a1;
  uint64_t v32 = v1;
  uint64_t v2 = *(void *)v1;
  size_t v3 = *(void *)(*(void *)v1 + 112);
  __s1 = *(void **)(*(void *)v1 + 104);
  __CFIndex n = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  subscriber::makeSimSlotRange();
  if (__n) {
    sub_10004D2C8((std::__shared_weak_count *)__n);
  }
  int v5 = (int *)*((void *)&v40 + 1);
  long long v4 = (int *)v40;
  if ((void)v40 != *((void *)&v40 + 1))
  {
    while ((v41(*v4) & 1) == 0)
    {
      if (++v4 == *((int **)&v40 + 1))
      {
        long long v4 = (int *)*((void *)&v40 + 1);
        break;
      }
    }
    char v30 = (int *)*((void *)&v40 + 1);
    if (v4 != *((int **)&v40 + 1))
    {
      long long v29 = v41;
      do
      {
        int v6 = *v4;
        uint64_t v7 = 28;
        do
        {
          uint64_t v36 = 0;
          __int16 v37 = 0;
          DataServiceController::getConnection_sync(v2, v6, v7, &v36);
          uint64_t v8 = v36;
          if (!v36 || ((*(uint64_t (**)(uint64_t))(*(void *)v36 + 168))(v36) & 1) == 0)
          {
            int v17 = 6;
            goto LABEL_46;
          }
          __s1 = 0;
          __CFIndex n = 0;
          uint64_t v35 = 0;
          uint64_t v9 = (*(uint64_t (**)(uint64_t, void **))(*(void *)v8 + 408))(v8, &__s1);
          uint64_t v10 = HIBYTE(v35);
          if (v35 >= 0) {
            size_t v11 = HIBYTE(v35);
          }
          else {
            size_t v11 = __n;
          }
          uint64_t v12 = *(unsigned __int8 *)(v1 + 31);
          int v13 = (char)v12;
          if ((v12 & 0x80u) != 0) {
            uint64_t v12 = *(void *)(v1 + 16);
          }
          if (v11 == v12)
          {
            uint64_t v14 = (void *)v9;
            if (v13 >= 0) {
              int v15 = (unsigned __int8 *)(v1 + 8);
            }
            else {
              int v15 = *(unsigned __int8 **)(v1 + 8);
            }
            if (v35 < 0)
            {
              if (!memcmp(__s1, v15, __n))
              {
LABEL_32:
                unsigned __int16 v18 = sub_100AEA570(v2, v7, v14, 0, 0, 1);
                char v19 = v18;
                unsigned int v20 = v18;
                std::string v21 = *(NSObject **)(v2 + 40);
                BOOL v22 = os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT);
                if (v20 >= 0x100 && v19)
                {
                  if (v22)
                  {
                    p_s1 = &__s1;
                    if (v35 < 0) {
                      p_s1 = __s1;
                    }
                    *(_DWORD *)uint64_t buf = 136315138;
                    char v39 = p_s1;
                    _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "#I requestSliceDeactivation: cannot deactivate interface %s", buf, 0xCu);
                  }
                }
                else
                {
                  if (v22)
                  {
                    uint64_t v24 = &__s1;
                    if (v35 < 0) {
                      uint64_t v24 = __s1;
                    }
                    *(_DWORD *)uint64_t buf = 136315138;
                    char v39 = v24;
                    _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "#I requestSliceDeactivation: found interface %s", buf, 0xCu);
                  }
                  (*(void (**)(uint64_t, const char *, const char *))(*(void *)v8 + 96))(v8, "slice deactivation requested", "CommCenter");
                }
                int v17 = 1;
                goto LABEL_44;
              }
            }
            else
            {
              if (!HIBYTE(v35)) {
                goto LABEL_32;
              }
              uint64_t v16 = &__s1;
              while (*(unsigned __int8 *)v16 == *v15)
              {
                uint64_t v16 = (void **)((char *)v16 + 1);
                ++v15;
                if (!--v10) {
                  goto LABEL_32;
                }
              }
            }
          }
          int v17 = 0;
LABEL_44:
          if (SHIBYTE(v35) < 0) {
            operator delete(__s1);
          }
LABEL_46:
          if (v37) {
            sub_10004D2C8(v37);
          }
          if (v17 != 6 && v17) {
            goto LABEL_61;
          }
          uint64_t v7 = (v7 + 1);
        }
        while (v7 != 36);
        long long v25 = v4 + 1;
        long long v4 = v5;
        if (v25 != v5)
        {
          long long v4 = v25;
          while ((v29(*v4) & 1) == 0)
          {
            if (++v4 == v5)
            {
              long long v4 = v5;
              break;
            }
          }
        }
      }
      while (v4 != v30);
    }
  }
  uint64_t v26 = *(NSObject **)(v2 + 40);
  if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
  {
    long long v27 = (void *)(v1 + 8);
    if (*(char *)(v1 + 31) < 0) {
      long long v27 = (void *)*v27;
    }
    LODWORD(v40) = 136315138;
    *(void *)((char *)&v40 + 4) = v27;
    _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "#I requestSliceDeactivation: cannot find interface %s", (uint8_t *)&v40, 0xCu);
  }
LABEL_61:
  sub_1001102C4(&v32);
  return sub_100046B58((uint64_t *)&v31);
}

void sub_100B0CF74(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, std::__shared_weak_count *a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23)
{
  if (a17) {
    sub_10004D2C8(a17);
  }
  sub_1001102C4(&a15);
  sub_100046B58(&a14);
  _Unwind_Resume(a1);
}

uint64_t sub_100B0CFD8()
{
  uint64_t v0 = 0;
  uint64_t v1 = 0;
  int v13 = 52429500;
  qword_101B0FE48 = 0;
  qword_101B0FE40 = 0;
  uint64_t v2 = &qword_101B0FE40;
  qword_101B0FE38 = (uint64_t)&qword_101B0FE40;
  for (unsigned int i = 700; ; unsigned int i = *((unsigned __int16 *)&v13 + v1))
  {
    if (v2 == &qword_101B0FE40)
    {
      int v5 = &qword_101B0FE40;
LABEL_10:
      if (v0)
      {
        uint64_t v8 = v5 + 1;
        if (v5[1]) {
          goto LABEL_25;
        }
      }
      else
      {
LABEL_21:
        uint64_t v8 = &qword_101B0FE40;
        int v5 = &qword_101B0FE40;
      }
LABEL_22:
      size_t v11 = operator new(0x20uLL);
      v11[13] = i;
      *(void *)size_t v11 = 0;
      *((void *)v11 + 1) = 0;
      *((void *)v11 + 2) = v5;
      uint64_t *v8 = (uint64_t)v11;
      if (*(void *)qword_101B0FE38)
      {
        qword_101B0FE38 = *(void *)qword_101B0FE38;
        size_t v11 = (_WORD *)*v8;
      }
      sub_100046C90((uint64_t *)qword_101B0FE40, (uint64_t *)v11);
      ++qword_101B0FE48;
      goto LABEL_25;
    }
    long long v4 = (uint64_t *)v0;
    if (v0)
    {
      do
      {
        int v5 = v4;
        long long v4 = (uint64_t *)v4[1];
      }
      while (v4);
    }
    else
    {
      int v6 = &qword_101B0FE40;
      do
      {
        int v5 = (uint64_t *)v6[2];
        BOOL v7 = *v5 == (void)v6;
        int v6 = v5;
      }
      while (v7);
    }
    if (*((unsigned __int16 *)v5 + 13) < i) {
      goto LABEL_10;
    }
    if (!v0) {
      goto LABEL_21;
    }
    uint64_t v9 = v0;
    while (1)
    {
      while (1)
      {
        int v5 = (uint64_t *)v9;
        unsigned int v10 = *(unsigned __int16 *)(v9 + 26);
        if (v10 <= i) {
          break;
        }
        uint64_t v9 = *v5;
        uint64_t v8 = v5;
        if (!*v5) {
          goto LABEL_22;
        }
      }
      if (v10 >= i) {
        break;
      }
      uint64_t v9 = v5[1];
      if (!v9)
      {
        uint64_t v8 = v5 + 1;
        goto LABEL_22;
      }
    }
LABEL_25:
    if (++v1 == 2) {
      break;
    }
    uint64_t v2 = (uint64_t *)qword_101B0FE38;
    uint64_t v0 = qword_101B0FE40;
  }

  return __cxa_atexit((void (*)(void *))sub_100AE9B34, &qword_101B0FE38, (void *)&_mh_execute_header);
}

void sub_100B0D18C(_Unwind_Exception *a1)
{
  sub_10005D144(v1);
  _Unwind_Resume(a1);
}

void *sub_100B0D1A0(void *a1, void *a2)
{
  *a1 = off_101A3A830;
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v6, kCtLoggingSystemName, "CSIAppInfo.CSIAppInfo");
  sub_100B0D27C(a1 + 1, "CSIAppInfo", QOS_CLASS_USER_INITIATED, &v6);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v6);
  *a1 = off_101A3A830;
  a1[6] = *a2;
  uint64_t v4 = a2[1];
  a1[7] = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  return a1;
}

void sub_100B0D258(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&a9);
  CSIAppInfoInterface::~CSIAppInfoInterface(v9);
  _Unwind_Resume(a1);
}

void *sub_100B0D27C(void *a1, const char *a2, dispatch_qos_class_t a3, const OsLogContext *a4)
{
  dispatch_object_t object = 0;
  sub_100104718(a1, a2, a3, &object);
  if (object) {
    dispatch_release(object);
  }
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)&v7, a4);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 4), (const ctu::OsLogLogger *)&v7);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)&v7);
  return a1;
}

void sub_100B0D2E4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object)
{
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)&a9);
  sub_100087E88(v10);
  _Unwind_Resume(a1);
}

void sub_100B0D31C(void *a1)
{
  *a1 = off_101A3A830;
  uint64_t v2 = (std::__shared_weak_count *)a1[7];
  if (v2) {
    sub_10004D2C8(v2);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 5));
  sub_100087E88(a1 + 1);

  CSIAppInfoInterface::~CSIAppInfoInterface((CSIAppInfoInterface *)a1);
}

void sub_100B0D390(void *a1)
{
  sub_100B0D31C(a1);

  operator delete();
}

void sub_100B0D3D8(uint64_t a1, dispatch_object_t *a2)
{
  uint64_t v2 = (void *)(a1 + 8);
  size_t v3 = *a2;
  if (*a2)
  {
    dispatch_retain(*a2);
    dispatch_group_enter(v3);
  }
  v4[0] = 0;
  v4[1] = 0;
  sub_10003E168(v4, v2);
  operator new();
}

void sub_100B0D4D0(uint64_t a1)
{
  v1[0] = 0;
  v1[1] = 0;
  sub_10003E168(v1, (void *)(a1 + 8));
  operator new();
}

void sub_100B0D5AC(uint64_t a1, int a2, ServiceStage *this)
{
  size_t v3 = (void *)(a1 + 8);
  ServiceStage::holdOffStage((uint64_t *)&group, this);
  v5[0] = 0;
  v5[1] = 0;
  sub_10003E168(v5, v3);
  operator new();
}

uint64_t sub_100B0D6D8(uint64_t a1, char a2)
{
  return a2 & 1;
}

uint64_t sub_100B0D6E0(uint64_t a1, unint64_t a2)
{
  return (a2 >> 4) & 1;
}

uint64_t sub_100B0D6E8@<X0>(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(a2, *(Registry **)(a1 + 48));
  size_t v3 = ServiceMap;
  if ((v4 & 0x8000000000000000) != 0)
  {
    int v5 = (unsigned __int8 *)(v4 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v6 = 5381;
    do
    {
      unint64_t v4 = v6;
      unsigned int v7 = *v5++;
      uint64_t v6 = (33 * v6) ^ v7;
    }
    while (v7);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v14 = v4;
  uint64_t v8 = sub_10004D37C(&v3[1].__m_.__sig, &v14);
  if (v8)
  {
    uint64_t v10 = v8[3];
    uint64_t v9 = (std::__shared_weak_count *)v8[4];
    if (v9)
    {
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v3);
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v9);
      char v11 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v10 = 0;
  }
  std::mutex::unlock(v3);
  uint64_t v9 = 0;
  char v11 = 1;
LABEL_9:
  uint64_t v12 = (*(uint64_t (**)(uint64_t))(*(void *)v10 + 16))(v10);
  if ((v11 & 1) == 0) {
    sub_10004D2C8(v9);
  }
  return v12;
}

void sub_100B0D7F0(_Unwind_Exception *exception_object)
{
  if ((v2 & 1) == 0) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100B0D80C(uint64_t a1, void *a2)
{
  uint64_t v35 = 0;
  uint64_t v36 = 0;
  sub_100224000(*(Registry **)(a1 + 48), &v35);
  if (v35)
  {
    uint64_t v32 = 0;
    uint64_t v33 = 0;
    uint64_t v34 = 0;
    CallController::getCurrentCalls(v35, &v32);
    uint64_t v3 = v32;
    uint64_t v4 = v33;
    if (v32 != v33)
    {
      uint64_t v5 = 0;
      uint64_t v6 = 0;
      while (1)
      {
        uint64_t v31 = 0;
        long long v29 = 0u;
        long long v30 = 0u;
        long long v27 = 0u;
        long long v28 = 0u;
        long long v25 = 0u;
        long long v26 = 0u;
        long long v23 = 0u;
        long long v24 = 0u;
        long long v21 = 0u;
        long long v22 = 0u;
        long long v19 = 0u;
        long long v20 = 0u;
        long long v17 = 0u;
        long long v18 = 0u;
        long long v15 = 0u;
        long long v16 = 0u;
        long long v13 = 0u;
        long long v14 = 0u;
        long long v11 = 0u;
        long long v12 = 0u;
        long long v9 = 0u;
        long long v10 = 0u;
        memset(v8, 0, sizeof(v8));
        sub_100245B5C((uint64_t)v8, v3);
        if (DWORD2(v9) <= 8)
        {
          if (((1 << SBYTE8(v9)) & 0x193) == 0)
          {
            if (DWORD2(v9) != 5) {
              goto LABEL_7;
            }
            ++v6;
          }
          ++v5;
        }
LABEL_7:
        sub_1002243E8((uint64_t)v8);
        v3 += 408;
        if (v3 == v4) {
          goto LABEL_14;
        }
      }
    }
    uint64_t v6 = 0;
    uint64_t v5 = 0;
LABEL_14:
    *(void *)&v8[0] = &v32;
    sub_1002244D8((void ***)v8);
    if (a2) {
      goto LABEL_15;
    }
  }
  else
  {
    uint64_t v6 = 0;
    uint64_t v5 = 0;
    if (a2) {
LABEL_15:
    }
      *a2 = v6;
  }
  if (v36) {
    sub_10004D2C8(v36);
  }
  return v5;
}

void sub_100B0D95C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9)
{
  long long v11 = *(std::__shared_weak_count **)(v9 - 72);
  if (v11) {
    sub_10004D2C8(v11);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100B0D98C()
{
  return 0;
}

void sub_100B0D994(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
}

uint64_t sub_100B0D9A0()
{
  return 0;
}

uint64_t sub_100B0D9A8()
{
  return 0;
}

uint64_t sub_100B0D9B0()
{
  return 0xFFFFFFFFLL;
}

uint64_t sub_100B0D9B8()
{
  return 0;
}

uint64_t sub_100B0D9C0()
{
  return 1;
}

uint64_t sub_100B0D9C8()
{
  return 0;
}

uint64_t sub_100B0D9D0()
{
  return 0;
}

uint64_t sub_100B0D9D8()
{
  return 0;
}

uint64_t sub_100B0D9E0()
{
  return 0;
}

uint64_t sub_100B0D9E8()
{
  return 0;
}

uint64_t sub_100B0D9F0()
{
  return 0;
}

uint64_t sub_100B0D9F8()
{
  return 0;
}

uint64_t sub_100B0DA00()
{
  return 1;
}

uint64_t sub_100B0DA08()
{
  return 0;
}

uint64_t sub_100B0DA14()
{
  return 0;
}

uint64_t sub_100B0DA1C()
{
  return 1;
}

void sub_100B0DA24(void *a1@<X8>)
{
  *a1 = 0;
}

uint64_t *sub_100B0DA2C(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v5 = a1;
  uint64_t v6 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v3 = *(NSObject **)(*(void *)v1 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I bootstrapping", buf, 2u);
  }
  (*(void (**)(uint64_t))(*(void *)v2 + 208))(v2);
  sub_100088C88(&v6);
  return sub_100046B58((uint64_t *)&v5);
}

void sub_100B0DAD0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

void sub_100B0DAEC(void **a1)
{
  uint64_t v3 = a1;
  uint64_t v1 = (void *)**a1;
  uint64_t v2 = v1[5];
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I starting", buf, 2u);
  }
  (*(void (**)(void *))(*v1 + 216))(v1);
  operator delete();
}

void sub_100B0DBA8()
{
}

uint64_t *sub_100B0DBD4(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v6 = a1;
  uint64_t v7 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v3 = *(NSObject **)(*(void *)v1 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I shutting down", buf, 2u);
  }
  if (!*(unsigned char *)(v1 + 8))
  {
    uint64_t v5 = *(NSObject **)(v1 + 16);
    *(void *)uint64_t buf = v5;
    if (v5)
    {
      dispatch_retain(v5);
      dispatch_group_enter(v5);
    }
    (*(void (**)(uint64_t, uint8_t *))(*(void *)v2 + 224))(v2, buf);
    if (*(void *)buf)
    {
      dispatch_group_leave(*(dispatch_group_t *)buf);
      if (*(void *)buf) {
        dispatch_release(*(dispatch_object_t *)buf);
      }
    }
  }
  sub_100113010(&v7);
  return sub_100046B58((uint64_t *)&v6);
}

void sub_100B0DCC4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, dispatch_group_t group)
{
  if (group)
  {
    dispatch_group_leave(group);
    if (group) {
      dispatch_release(group);
    }
  }
  sub_100113010(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

void sub_100B0DCFC(uint64_t a1)
{
  sub_100AB9684(a1);

  operator delete();
}

const char *sub_100B0DD34()
{
  return "TrekC2K";
}

void sub_100B0DD40(uint64_t a1@<X1>, int *a2@<X2>, void *a3@<X8>)
{
  uint64_t v6 = operator new(0x2D0uLL);
  sub_100B0DDBC((uint64_t)v6, a1, a2);
  *a3 = v6 + 3;
  a3[1] = v6;

  sub_1000B3BC8((uint64_t)a3, v6 + 17, (uint64_t)(v6 + 3));
}

void sub_100B0DDA8(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100B0DDBC(uint64_t a1, uint64_t a2, int *a3)
{
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = off_101A3AA70;
  sub_100AB9388(a1 + 24, a2, *a3);
  *(void *)(a1 + 24) = &off_101A3A9D8;
  *(unsigned char *)(a1 + 512) = 1;
  *(void *)(a1 + 128) &= ~1uLL;
  return a1;
}

void sub_100B0DE38(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void sub_100B0DE4C(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A3AA70;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100B0DE6C(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A3AA70;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100B0DEC0(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

uint64_t PrivateNetworkTelemetryController::PrivateNetworkTelemetryController(uint64_t a1, NSObject **a2, void *a3)
{
  *(void *)a1 = off_101A052C8;
  uint64_t v6 = (void *)(a1 + 8);
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v10, kCtLoggingSystemName, "pnw.metric");
  *uint64_t v6 = 0;
  v6[1] = 0;
  uint64_t v7 = *a2;
  *(void *)(a1 + 24) = *a2;
  if (v7) {
    dispatch_retain(v7);
  }
  *(void *)(a1 + 32) = 0;
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v11, &v10);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 40), (const ctu::OsLogLogger *)v11);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v11);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v10);
  *(void *)a1 = off_101A3AAC0;
  *(void *)(a1 + 48) = *a3;
  uint64_t v8 = a3[1];
  *(void *)(a1 + 56) = v8;
  if (v8) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v8 + 8), 1uLL, memory_order_relaxed);
  }
  *(_DWORD *)(a1 + 88) = 0;
  *(_DWORD *)(a1 + 64) = 0;
  *(_WORD *)(a1 + 68) = 0;
  *(_DWORD *)(a1 + 72) = 0;
  *(_WORD *)(a1 + 76) = 0;
  *(_WORD *)(a1 + 80) = 0;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  sub_100058DB0((void *)(a1 + 144), "");
  sub_100058DB0((void *)(a1 + 168), "");
  *(void *)(a1 + 208) = 0;
  *(_WORD *)(a1 + 192) = 0;
  *(_DWORD *)(a1 + 196) = 0;
  *(void *)(a1 + 216) = 0;
  *(void *)(a1 + 200) = a1 + 208;
  sub_100B123E8(a1 + 224);
  *(void *)(a1 + 488) = 0;
  *(void *)(a1 + 496) = 0;
  *(void *)(a1 + 480) = a1 + 488;
  sub_100B125D4(a1 + 504);
  return a1;
}

void sub_100B0E07C(_Unwind_Exception *a1)
{
  sub_100B12798(*v6);
  sub_100B126D4(v5);
  sub_1002F1208(v4);
  uint64_t v8 = *(std::__shared_weak_count **)(v2 + 56);
  if (v8) {
    sub_10004D2C8(v8);
  }
  ctu::OsLogLogger::~OsLogLogger(v3);
  sub_100087E88(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100B0E134(uint64_t a1)
{
  *(void *)a1 = off_101A3AAC0;
  if (*(char *)(a1 + 631) < 0) {
    operator delete(*(void **)(a1 + 608));
  }
  if (*(char *)(a1 + 599) < 0) {
    operator delete(*(void **)(a1 + 576));
  }
  if (*(char *)(a1 + 567) < 0) {
    operator delete(*(void **)(a1 + 544));
  }
  if (*(char *)(a1 + 543) < 0) {
    operator delete(*(void **)(a1 + 520));
  }
  sub_100B12798(*(void **)(a1 + 488));
  sub_100B126D4(a1 + 224);
  sub_10005CD90(a1 + 200, *(void **)(a1 + 208));
  if (*(char *)(a1 + 191) < 0) {
    operator delete(*(void **)(a1 + 168));
  }
  if (*(char *)(a1 + 167) < 0) {
    operator delete(*(void **)(a1 + 144));
  }
  if (*(char *)(a1 + 143) < 0) {
    operator delete(*(void **)(a1 + 120));
  }
  if (*(char *)(a1 + 119) < 0) {
    operator delete(*(void **)(a1 + 96));
  }
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 56);
  if (v2) {
    sub_10004D2C8(v2);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 40));
  sub_100087E88((void *)(a1 + 8));
  return a1;
}

uint64_t sub_100B0E230(uint64_t a1)
{
  if (*(char *)(a1 + 127) < 0) {
    operator delete(*(void **)(a1 + 104));
  }
  if (*(char *)(a1 + 95) < 0) {
    operator delete(*(void **)(a1 + 72));
  }
  if (*(char *)(a1 + 63) < 0) {
    operator delete(*(void **)(a1 + 40));
  }
  if (*(char *)(a1 + 39) < 0) {
    operator delete(*(void **)(a1 + 16));
  }
  return a1;
}

void sub_100B0E298(uint64_t a1)
{
  sub_100B0E134(a1);

  operator delete();
}

void PrivateNetworkTelemetryController::create()
{
}

void sub_100B0E3BC(_Unwind_Exception *exception_object)
{
  if (v2)
  {
    sub_10004D2C8(v2);
    if (!v1)
    {
LABEL_3:
      if (v3) {
        goto LABEL_4;
      }
      goto LABEL_5;
    }
  }
  else if (!v1)
  {
    goto LABEL_3;
  }
  dispatch_release(v1);
  if (v3) {
LABEL_4:
  }
    operator delete();
LABEL_5:
  _Unwind_Resume(exception_object);
}

void sub_100B0E408(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

uint64_t sub_100B0E4E8(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  long long v64 = 0u;
  long long v65 = 0u;
  long long v62 = 0u;
  long long v63 = 0u;
  long long v60 = 0u;
  long long v61 = 0u;
  long long v58 = 0u;
  long long v59 = 0u;
  long long v56 = 0u;
  long long v57 = 0u;
  long long v54 = 0u;
  long long v55 = 0u;
  long long v52 = 0u;
  long long v53 = 0u;
  memset(__str, 0, sizeof(__str));
  sub_100B123E8((uint64_t)__str);
  uint64_t v6 = (void **)(a1 + 224);
  std::string::operator=((std::string *)(a1 + 224), (const std::string *)__str);
  std::string::operator=((std::string *)(a1 + 248), (const std::string *)&__str[24]);
  std::string::operator=((std::string *)(a1 + 272), (const std::string *)&v53);
  std::string::operator=((std::string *)(a1 + 296), (const std::string *)((char *)&v54 + 8));
  std::string::operator=((std::string *)(a1 + 320), (const std::string *)&v56);
  std::string::operator=((std::string *)(a1 + 344), (const std::string *)((char *)&v57 + 8));
  std::string::operator=((std::string *)(a1 + 368), (const std::string *)&v59);
  std::string::operator=((std::string *)(a1 + 392), (const std::string *)((char *)&v60 + 8));
  std::string::operator=((std::string *)(a1 + 416), (const std::string *)&v62);
  *(_WORD *)(a1 + 440) = WORD4(v63);
  *(unsigned char *)(a1 + 442) = BYTE10(v63);
  long long v24 = (void **)(a1 + 448);
  std::string::operator=((std::string *)(a1 + 448), (const std::string *)&v64);
  *(_DWORD *)(a1 + 472) = DWORD2(v65);
  *(_WORD *)(a1 + 476) = WORD6(v65);
  uint64_t result = sub_100B126D4((uint64_t)__str);
  uint64_t v9 = *a3;
  uint64_t v8 = a3[1];
  if (v9 != v8)
  {
    OsLogContext v10 = (const std::string *)((char *)&v52 + 8);
    long long v30 = (int *)(a1 + 88);
    long long v29 = (std::string *)(a1 + 96);
    long long v27 = (std::string *)(a1 + 144);
    long long v28 = (std::string *)(a1 + 120);
    long long v26 = (std::string *)(a1 + 168);
    long long v25 = (void ***)(a1 + 456);
    long long v23 = (uint64_t **)(a1 + 200);
    do
    {
      uint64_t result = (uint64_t)sub_100046F68(a2, (void **)(v9 + 72));
      if (a2 + 8 != result)
      {
        long long v70 = 0u;
        long long v71 = 0u;
        long long v68 = 0u;
        long long v69 = 0u;
        long long v66 = 0u;
        long long v67 = 0u;
        long long v64 = 0u;
        long long v65 = 0u;
        long long v62 = 0u;
        long long v63 = 0u;
        long long v60 = 0u;
        long long v61 = 0u;
        long long v58 = 0u;
        long long v59 = 0u;
        long long v56 = 0u;
        long long v57 = 0u;
        long long v54 = 0u;
        long long v55 = 0u;
        long long v52 = 0u;
        long long v53 = 0u;
        memset(__str, 0, sizeof(__str));
        long long v11 = sub_100046F68(a2, (void **)(v9 + 72));
        sub_100059120((uint64_t)__str, (uint64_t)(v11 + 7));
        if (BYTE8(v62))
        {
          sub_10002E664((uint64_t)v39, v9);
          if (subscriber::isEsimCapable()) {
            long long v12 = "eSIM";
          }
          else {
            long long v12 = "pSIM";
          }
          sub_100058DB0(v72, v12);
          if (*(char *)(a1 + 247) < 0) {
            operator delete(*v6);
          }
          *(_OWORD *)uint64_t v6 = *(_OWORD *)v72;
          *(void *)(a1 + 240) = *(void *)&v72[16];
          v72[23] = 0;
          v72[0] = 0;
          if (v50 < 0) {
            operator delete(__p);
          }
          if (v48 < 0) {
            operator delete(v47);
          }
          if (v46 < 0) {
            operator delete(v45);
          }
          if (v44 < 0) {
            operator delete(v43);
          }
          v80[0] = (void **)&v42;
          sub_10002E39C(v80);
          if (v40)
          {
            BOOL v41 = v40;
            operator delete(v40);
          }
          std::string::operator=((std::string *)(a1 + 248), v10);
          std::string::operator=((std::string *)(a1 + 272), (const std::string *)&v54);
          std::string::operator=((std::string *)(a1 + 296), (const std::string *)((char *)&v55 + 8));
          std::string::operator=((std::string *)(a1 + 320), (const std::string *)&v57);
          *(unsigned char *)(a1 + 442) = 1;
          sub_10006891C((uint64_t)&v31, (uint64_t)&v63);
          if (*((void *)&v38 + 1))
          {
            long long v13 = v10;
            *long long v30 = v31;
            std::string::operator=(v29, &v32);
            std::string::operator=(v28, &v33);
            std::string::operator=(v27, &v34);
            std::string::operator=(v26, &v35);
            *(void *)(a1 + 192) = v36;
            if (v30 != &v31) {
              sub_100601150(v23, v37, &v38);
            }
            *(unsigned char *)(a1 + 440) = 1;
            if ((v32.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
              size_t size = HIBYTE(v32.__r_.__value_.__r.__words[2]);
            }
            else {
              size_t size = v32.__r_.__value_.__l.__size_;
            }
            memset(v72, 0, 24);
            sub_1000C140C((uint64_t)v72, size + 1);
            if (v72[23] >= 0) {
              long long v15 = v72;
            }
            else {
              long long v15 = *(unsigned char **)v72;
            }
            if (size)
            {
              if ((v32.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                long long v16 = &v32;
              }
              else {
                long long v16 = (std::string *)v32.__r_.__value_.__r.__words[0];
              }
              memmove(v15, v16, size);
            }
            *(_WORD *)&v15[size] = 32;
            if ((v33.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
              long long v17 = &v33;
            }
            else {
              long long v17 = (std::string *)v33.__r_.__value_.__r.__words[0];
            }
            if ((v33.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
              std::string::size_type v18 = HIBYTE(v33.__r_.__value_.__r.__words[2]);
            }
            else {
              std::string::size_type v18 = v33.__r_.__value_.__l.__size_;
            }
            long long v19 = std::string::append((std::string *)v72, (const std::string::value_type *)v17, v18);
            std::string::size_type v20 = v19->__r_.__value_.__r.__words[0];
            v80[0] = (void **)v19->__r_.__value_.__l.__size_;
            *(void ***)((char *)v80 + 7) = *(void ***)((char *)&v19->__r_.__value_.__r.__words[1] + 7);
            char v21 = HIBYTE(v19->__r_.__value_.__r.__words[2]);
            v19->__r_.__value_.__l.__size_ = 0;
            v19->__r_.__value_.__r.__words[2] = 0;
            v19->__r_.__value_.__r.__words[0] = 0;
            if (*(char *)(a1 + 471) < 0) {
              operator delete(*v24);
            }
            *(void *)(a1 + 448) = v20;
            *long long v25 = v80[0];
            *(void ***)(a1 + 463) = *(void ***)((char *)v80 + 7);
            *(unsigned char *)(a1 + 471) = v21;
            if ((v72[23] & 0x80000000) != 0) {
              operator delete(*(void **)v72);
            }
            *(_DWORD *)(a1 + 472) = v31;
            *(unsigned char *)(a1 + 441) = BYTE1(v36);
            *(_WORD *)(a1 + 476) = WORD4(v38);
            OsLogContext v10 = v13;
          }
          else
          {
            *(unsigned char *)(a1 + 440) = 0;
            if (*(char *)(a1 + 471) < 0)
            {
              *long long v25 = 0;
              long long v22 = *v24;
            }
            else
            {
              *(unsigned char *)(a1 + 471) = 0;
              long long v22 = (unsigned char *)(a1 + 448);
            }
            *long long v22 = 0;
            *(_DWORD *)(a1 + 472) = 0;
            *(unsigned char *)(a1 + 441) = 0;
            *(_WORD *)(a1 + 476) = 0;
            uint64_t v79 = 0;
            long long v77 = 0u;
            long long v78 = 0u;
            long long v75 = 0u;
            long long v76 = 0u;
            long long v73 = 0u;
            long long v74 = 0u;
            memset(v72, 0, sizeof(v72));
            sub_100058DB0((void *)&v74 + 1, "");
            sub_100058DB0(&v76, "");
            WORD4(v77) = 0;
            HIDWORD(v77) = 0;
            *((void *)&v78 + 1) = 0;
            uint64_t v79 = 0;
            *(void *)&long long v78 = (char *)&v78 + 8;
            *long long v30 = *(_DWORD *)v72;
            std::string::operator=(v29, (const std::string *)&v72[8]);
            std::string::operator=(v28, (const std::string *)&v73);
            std::string::operator=(v27, (const std::string *)((char *)&v74 + 8));
            std::string::operator=(v26, (const std::string *)&v76);
            *(void *)(a1 + 192) = *((void *)&v77 + 1);
            if (v30 != (int *)v72) {
              sub_100601150(v23, (long long *)v78, (long long *)((char *)&v78 + 8));
            }
            sub_10005CD90((uint64_t)&v78, *((void **)&v78 + 1));
            if (SBYTE7(v77) < 0) {
              operator delete((void *)v76);
            }
            if (SHIBYTE(v75) < 0) {
              operator delete(*((void **)&v74 + 1));
            }
            if (SBYTE7(v74) < 0) {
              operator delete((void *)v73);
            }
            if ((v72[31] & 0x80000000) != 0) {
              operator delete(*(void **)&v72[8]);
            }
          }
          sub_10005CD90((uint64_t)&v37, (void *)v38);
          if (SHIBYTE(v35.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v35.__r_.__value_.__l.__data_);
          }
          if (SHIBYTE(v34.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v34.__r_.__value_.__l.__data_);
          }
          if (SHIBYTE(v33.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v33.__r_.__value_.__l.__data_);
          }
          if (SHIBYTE(v32.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v32.__r_.__value_.__l.__data_);
          }
        }
        else if (*(_DWORD *)(v9 + 8) == 5)
        {
          std::string::operator=((std::string *)(a1 + 344), v10);
          std::string::operator=((std::string *)(a1 + 368), (const std::string *)&v54);
          std::string::operator=((std::string *)(a1 + 392), (const std::string *)((char *)&v55 + 8));
          std::string::operator=((std::string *)(a1 + 416), (const std::string *)&v57);
        }
        uint64_t result = sub_10006544C((uint64_t)__str);
      }
      v9 += 168;
    }
    while (v9 != v8);
  }
  return result;
}

void sub_100B0EC0C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,char a45)
{
  if (*(char *)(v45 - 177) < 0) {
    operator delete(*(void **)(v45 - 200));
  }
  if (*(char *)(v45 - 201) < 0) {
    operator delete(*(void **)(v45 - 224));
  }
  if (*(char *)(v45 - 225) < 0) {
    operator delete(*(void **)(v45 - 248));
  }
  sub_1002F1208((uint64_t)&a45);
  sub_10006544C((uint64_t)&STACK[0x250]);
  _Unwind_Resume(a1);
}

void sub_100B0ECC0(uint64_t a1, int a2, std::string *a3, double *a4, unsigned char *a5, int a6)
{
  int v50 = a2;
  switch(a2)
  {
    case 0:
      sub_100B0F3D0(a1);
      return;
    case 1:
      sub_100B0F474(a1, &v50);
      uint64_t v7 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I end master session", buf, 2u);
      }
      if (*(unsigned char *)(a1 + 80))
      {
        *(unsigned char *)(a1 + 80) = 0;
        sub_100B10EF4(a1, (unsigned int *)(a1 + 504));
        sub_100B12138(a1);
        uint64_t v8 = *(unsigned int **)(a1 + 480);
        uint64_t v9 = (unsigned int *)(a1 + 488);
        if (v8 != (unsigned int *)(a1 + 488))
        {
          do
          {
            sub_100B10EF4(a1, v8 + 14);
            OsLogContext v10 = (unsigned int *)*((void *)v8 + 1);
            if (v10)
            {
              do
              {
                long long v11 = v10;
                OsLogContext v10 = *(unsigned int **)v10;
              }
              while (v10);
            }
            else
            {
              do
              {
                long long v11 = (unsigned int *)*((void *)v8 + 2);
                BOOL v12 = *(void *)v11 == (void)v8;
                uint64_t v8 = v11;
              }
              while (!v12);
            }
            uint64_t v8 = v11;
          }
          while (v11 != v9);
        }
      }
      else
      {
        long long v29 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)uint64_t buf = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_ERROR, "no active session", buf, 2u);
        }
        uint64_t v9 = (unsigned int *)(a1 + 488);
      }
      sub_100B12798(*(void **)(a1 + 488));
      *(void *)(a1 + 496) = 0;
      *(void *)(a1 + 480) = v9;
      *(void *)uint64_t v9 = 0;
      return;
    case 2:
      (***(void (****)(unsigned char *__return_ptr))(a1 + 48))(buf);
      ServiceMap = (std::mutex *)Registry::getServiceMap(v14, *(Registry **)buf);
      long long v16 = ServiceMap;
      if (v17 < 0)
      {
        std::string::size_type v18 = (unsigned __int8 *)(v17 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v19 = 5381;
        do
        {
          uint64_t v17 = v19;
          unsigned int v20 = *v18++;
          uint64_t v19 = (33 * v19) ^ v20;
        }
        while (v20);
      }
      std::mutex::lock(ServiceMap);
      v48[0] = (void *)v17;
      char v21 = sub_10004D37C(&v16[1].__m_.__sig, (unint64_t *)v48);
      if (v21)
      {
        uint64_t v22 = v21[3];
        long long v23 = (std::__shared_weak_count *)v21[4];
        if (v23)
        {
          atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v16);
          atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v23);
          char v24 = 0;
          goto LABEL_36;
        }
      }
      else
      {
        uint64_t v22 = 0;
      }
      std::mutex::unlock(v16);
      long long v23 = 0;
      char v24 = 1;
LABEL_36:
      if (*(void *)&buf[8]) {
        sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
      }
      if (v22)
      {
        uint64_t v30 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v22 + 104))(v22, 1);
        uint64_t v31 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v22 + 104))(v22, 2);
        int v32 = v31;
        int v33 = WORD2(v30);
        int v34 = WORD2(v31);
        if (v24) {
          goto LABEL_41;
        }
        goto LABEL_40;
      }
      long long v40 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v40, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_ERROR, "Could not get CellMonitor to retrieve band info", buf, 2u);
      }
      int v34 = 0;
      int v33 = 0;
      int v32 = -1;
      LODWORD(v30) = -1;
      if ((v24 & 1) == 0) {
LABEL_40:
      }
        sub_10004D2C8(v23);
LABEL_41:
      if (a6 == 2)
      {
        BOOL v41 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v41, OS_LOG_TYPE_DEFAULT))
        {
          sub_100B0F698(v48, v32);
          int v42 = v49;
          uint64_t v43 = (void **)v48[0];
          sub_100B0F698(__p, v30);
          char v44 = v48;
          if (v42 < 0) {
            char v44 = v43;
          }
          if (v47 >= 0) {
            uint64_t v45 = __p;
          }
          else {
            uint64_t v45 = (void **)__p[0];
          }
          *(_DWORD *)uint64_t buf = 136315906;
          *(void *)&uint8_t buf[4] = v44;
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = v34;
          __int16 v52 = 2080;
          long long v53 = v45;
          __int16 v54 = 1024;
          int v55 = v33;
          _os_log_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_DEFAULT, "#I Private Network registered event with rat [%s], band [%d] - macro rat [%s], band [%d]", buf, 0x22u);
          if (v47 < 0) {
            operator delete(__p[0]);
          }
          if (v49 < 0) {
            operator delete(v48[0]);
          }
        }
        if (v32 != 11 && v34)
        {
          *(_DWORD *)(a1 + 64) = v32;
          *(_WORD *)(a1 + 68) = v34;
        }
        if (v30 == 11) {
          goto LABEL_79;
        }
        int v32 = v30;
        LOWORD(v34) = v33;
        if (!v33) {
          goto LABEL_79;
        }
LABEL_78:
        *(_DWORD *)(a1 + 72) = v32;
        *(_WORD *)(a1 + 76) = v34;
        goto LABEL_79;
      }
      if (a6 == 1)
      {
        std::string v35 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT))
        {
          sub_100B0F698(v48, v30);
          int v36 = v49;
          __int16 v37 = (void **)v48[0];
          sub_100B0F698(__p, v32);
          long long v38 = v48;
          if (v36 < 0) {
            long long v38 = v37;
          }
          if (v47 >= 0) {
            char v39 = __p;
          }
          else {
            char v39 = (void **)__p[0];
          }
          *(_DWORD *)uint64_t buf = 136315906;
          *(void *)&uint8_t buf[4] = v38;
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = v33;
          __int16 v52 = 2080;
          long long v53 = v39;
          __int16 v54 = 1024;
          int v55 = v34;
          _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_DEFAULT, "#I Private Network registered event with rat [%s], band [%d] - macro rat [%s], band [%d]", buf, 0x22u);
          if (v47 < 0) {
            operator delete(__p[0]);
          }
          if (v49 < 0) {
            operator delete(v48[0]);
          }
        }
        if (v30 != 11 && v33)
        {
          *(_DWORD *)(a1 + 64) = v30;
          *(_WORD *)(a1 + 68) = v33;
        }
        if (v32 != 11 && v34) {
          goto LABEL_78;
        }
      }
LABEL_79:
      sub_100B0F474(a1, &v50);
      return;
    case 3:
      ++*(_WORD *)(a1 + 652);
      *(unsigned char *)(a1 + 81) = 1;
      sub_100B0F474(a1, &v50);
      return;
    case 4:
      ++*(_WORD *)(a1 + 652);
      *(unsigned char *)(a1 + 81) = 0;
      sub_100B0F474(a1, &v50);
      return;
    case 5:
      sub_100B0F474(a1, &v50);
      return;
    case 6:
      long long v25 = a3;
      long long v26 = a4;
      long long v27 = a5;
      int v28 = 1;
      goto LABEL_27;
    case 7:
      long long v25 = a3;
      long long v26 = a4;
      long long v27 = a5;
      int v28 = 0;
LABEL_27:
      sub_100B0F6AC(a1, v25, v26, v27, v28);
      return;
    default:
      return;
  }
}

void sub_100B0F350(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,uint64_t a21)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100B0F3D0(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I begin master session", buf, 2u);
  }
  *(unsigned char *)(a1 + 80) = 1;
  *(void *)(a1 + 508) = &_mh_execute_header;
  int v4 = 0;
  sub_100B10D0C(*(void (****)(Registry **__return_ptr))(a1 + 48), (_DWORD *)(a1 + 504), &v4);
  int v3 = 4;
  sub_100B10D0C(*(void (****)(Registry **__return_ptr))(a1 + 48), (_DWORD *)(a1 + 504), &v3);
}

void sub_100B0F474(uint64_t a1, int *a2)
{
  if (*a2 == 3)
  {
    int v6 = *(_DWORD *)(a1 + 672);
    if (!v6) {
      goto LABEL_8;
    }
    uint64_t v5 = (_DWORD *)(a1 + 504);
    *(_DWORD *)(a1 + 648) += sub_100B1226C(*(void (****)(Registry **__return_ptr))(a1 + 48), v6);
    goto LABEL_7;
  }
  if (*a2 == 4)
  {
    int v4 = *(_DWORD *)(a1 + 672);
    if (v4)
    {
      uint64_t v5 = (_DWORD *)(a1 + 504);
      *(_DWORD *)(a1 + 644) += sub_100B1226C(*(void (****)(Registry **__return_ptr))(a1 + 48), v4);
LABEL_7:
      int v23 = 4;
      sub_100B10D0C(*(void (****)(Registry **__return_ptr))(a1 + 48), v5, &v23);
    }
  }
LABEL_8:
  uint64_t v7 = *(void **)(a1 + 480);
  if (v7 != (void *)(a1 + 488))
  {
    do
    {
      if (*((_DWORD *)v7 + 15) == 2)
      {
        if (*a2 == 5)
        {
          int v11 = *((_DWORD *)v7 + 54);
          if (!v11) {
            goto LABEL_39;
          }
          unsigned int v12 = sub_100B1226C(*(void (****)(Registry **__return_ptr))(a1 + 48), v11);
          if (v12 >= 0x12C) {
            int v13 = 300;
          }
          else {
            int v13 = v12;
          }
          *((_DWORD *)v7 + 48) = v13;
          *((_DWORD *)v7 + 54) = 0;
        }
        else if (*a2 == 2)
        {
          int v8 = *((_DWORD *)v7 + 53);
          if (!v8) {
            goto LABEL_39;
          }
          *((unsigned char *)v7 + 68) = 1;
          unsigned int v9 = sub_100B1226C(*(void (****)(Registry **__return_ptr))(a1 + 48), v8);
          if (v9 >= 0x12C) {
            int v10 = 300;
          }
          else {
            int v10 = v9;
          }
          *((_DWORD *)v7 + 47) = v10;
          *((_DWORD *)v7 + 53) = 0;
        }
      }
      int v14 = *a2;
      BOOL v15 = *((_DWORD *)v7 + 16) == 4 && v14 == 1;
      if (v15)
      {
        int v16 = *((_DWORD *)v7 + 55);
        if (!v16) {
          goto LABEL_39;
        }
        unsigned int v17 = sub_100B1226C(*(void (****)(Registry **__return_ptr))(a1 + 48), v16);
        if (v17 >= 0x12C) {
          int v18 = 300;
        }
        else {
          int v18 = v17;
        }
        *((_DWORD *)v7 + 46) = v18;
        *((_DWORD *)v7 + 55) = 0;
        int v14 = *a2;
      }
      if (v14 == 3)
      {
        int v20 = *((_DWORD *)v7 + 56);
        if (v20)
        {
          ++*((_WORD *)v7 + 102);
          *((_DWORD *)v7 + 50) += sub_100B1226C(*(void (****)(Registry **__return_ptr))(a1 + 48), v20);
          goto LABEL_38;
        }
      }
      else if (v14 == 4)
      {
        int v19 = *((_DWORD *)v7 + 56);
        if (v19)
        {
          ++*((_WORD *)v7 + 102);
          *((_DWORD *)v7 + 49) += sub_100B1226C(*(void (****)(Registry **__return_ptr))(a1 + 48), v19);
LABEL_38:
          int v23 = 4;
          sub_100B10D0C(*(void (****)(Registry **__return_ptr))(a1 + 48), (_DWORD *)v7 + 14, &v23);
        }
      }
LABEL_39:
      char v21 = (void *)v7[1];
      if (v21)
      {
        do
        {
          uint64_t v22 = v21;
          char v21 = (void *)*v21;
        }
        while (v21);
      }
      else
      {
        do
        {
          uint64_t v22 = (void *)v7[2];
          BOOL v15 = *v22 == (void)v7;
          uint64_t v7 = v22;
        }
        while (!v15);
      }
      uint64_t v7 = v22;
    }
    while (v22 != (void *)(a1 + 488));
  }
}

void *sub_100B0F698(void *a1, int a2)
{
  return sub_100058DB0(a1, off_101A3AC48[a2 + 1]);
}

void sub_100B0F6AC(uint64_t a1, std::string *a2, double *a3, unsigned char *a4, int a5)
{
  int v10 = (uint64_t **)(a1 + 480);
  int v11 = (void **)(a1 + 488);
  BOOL v12 = (void **)(a1 + 488) != sub_100046F68(a1 + 480, (void **)&a2->__r_.__value_.__l.__data_) || a5 == 0;
  if (v12)
  {
    if (v11 != sub_100046F68((uint64_t)v10, (void **)&a2->__r_.__value_.__l.__data_) && (a5 & 1) == 0)
    {
      *(void *)&long long v24 = a2;
      int v13 = sub_100B12F68(v10, (void **)&a2->__r_.__value_.__l.__data_, (long long **)&v24);
      int v14 = (unsigned int *)(v13 + 56);
      if (*a4)
      {
        *((_DWORD *)v13 + 16) = 5;
        sub_100B10EF4(a1, v14);
        BOOL v15 = sub_100046F68((uint64_t)v10, (void **)&a2->__r_.__value_.__l.__data_);
        if (v11 != v15)
        {
          int v16 = (uint64_t *)v15;
          unsigned int v17 = (uint64_t *)v15[1];
          if (v17)
          {
            do
            {
              int v18 = v17;
              unsigned int v17 = (uint64_t *)*v17;
            }
            while (v17);
          }
          else
          {
            uint64_t v22 = v15;
            do
            {
              int v18 = (uint64_t *)v22[2];
              BOOL v12 = *v18 == (void)v22;
              uint64_t v22 = (void **)v18;
            }
            while (!v12);
          }
          if (*v10 == (uint64_t *)v15) {
            *int v10 = v18;
          }
          int v23 = *(uint64_t **)(a1 + 488);
          --*(void *)(a1 + 496);
          sub_10005EE6C(v23, v16);
          sub_100B127EC((uint64_t)(v16 + 4));
          operator delete(v16);
        }
      }
      else
      {
        *((_DWORD *)v13 + 16) = 4;
        LODWORD(v24) = 3;
        sub_100B10D0C(*(void (****)(Registry **__return_ptr))(a1 + 48), v14, &v24);
      }
    }
  }
  else
  {
    memset(v33, 0, sizeof(v33));
    long long v31 = 0u;
    long long v32 = 0u;
    long long v29 = 0u;
    *(_OWORD *)std::string __p = 0u;
    long long v27 = 0u;
    *(_OWORD *)int v28 = 0u;
    *(_OWORD *)long long v25 = 0u;
    *(_OWORD *)long long v26 = 0u;
    long long v24 = 0u;
    sub_100B125D4((uint64_t)&v24);
    std::string::operator=((std::string *)v25, a2);
    LOWORD(v28[0]) = (int)*a3;
    if (*a4 <= 1u) {
      int v19 = 2;
    }
    else {
      int v19 = 3;
    }
    DWORD1(v24) = v19;
    LODWORD(v34) = 0;
    sub_100B10D0C(*(void (****)(Registry **__return_ptr))(a1 + 48), &v24, &v34);
    LODWORD(v34) = 4;
    sub_100B10D0C(*(void (****)(Registry **__return_ptr))(a1 + 48), &v24, &v34);
    LODWORD(v34) = 1;
    sub_100B10D0C(*(void (****)(Registry **__return_ptr))(a1 + 48), &v24, &v34);
    LODWORD(v34) = 2;
    sub_100B10D0C(*(void (****)(Registry **__return_ptr))(a1 + 48), &v24, &v34);
    int v34 = a2;
    int v20 = sub_100B12F68(v10, (void **)&a2->__r_.__value_.__l.__data_, (long long **)&v34);
    *((void *)v20 + 7) = v24;
    *(void *)(v20 + 61) = *(void *)((char *)&v24 + 5);
    std::string::operator=((std::string *)v20 + 3, (const std::string *)v25);
    std::string::operator=((std::string *)v20 + 4, (const std::string *)&v26[1]);
    *((_WORD *)v20 + 60) = v28[0];
    v20[122] = BYTE2(v28[0]);
    std::string::operator=((std::string *)(v20 + 128), (const std::string *)&v28[1]);
    v20[152] = __p[0];
    std::string::operator=((std::string *)(v20 + 160), (const std::string *)&__p[1]);
    long long v21 = v33[0];
    *(_OWORD *)(v20 + 184) = v32;
    *(_OWORD *)(v20 + 200) = v21;
    *(_OWORD *)(v20 + 212) = *(_OWORD *)((char *)v33 + 12);
    if (SHIBYTE(v31) < 0) {
      operator delete(__p[1]);
    }
    if (SHIBYTE(v29) < 0) {
      operator delete(v28[1]);
    }
    if (SHIBYTE(v27) < 0) {
      operator delete(v26[1]);
    }
    if (SHIBYTE(v26[0]) < 0) {
      operator delete(v25[0]);
    }
  }
}

void sub_100B0F9A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_100B0F9CC(uint64_t a1)
{
  sub_100B0FA0C(a1);
  sub_100B102A4(a1);

  sub_100B10BB4(a1);
}

void sub_100B0FA0C(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 442))
  {
    (***(void (****)(uint8_t *__return_ptr))(a1 + 48))(buf);
    ServiceMap = (std::mutex *)Registry::getServiceMap(v2, *(Registry **)buf);
    int v4 = ServiceMap;
    if ((v5 & 0x8000000000000000) != 0)
    {
      int v6 = (unsigned __int8 *)(v5 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v7 = 5381;
      do
      {
        unint64_t v5 = v7;
        unsigned int v8 = *v6++;
        uint64_t v7 = (33 * v7) ^ v8;
      }
      while (v8);
    }
    std::mutex::lock(ServiceMap);
    v33[0] = v5;
    unsigned int v9 = sub_10004D37C(&v4[1].__m_.__sig, v33);
    if (v9)
    {
      uint64_t v11 = v9[3];
      int v10 = (std::__shared_weak_count *)v9[4];
      if (v10)
      {
        atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v4);
        atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v10);
        char v12 = 0;
        goto LABEL_10;
      }
    }
    else
    {
      uint64_t v11 = 0;
    }
    std::mutex::unlock(v4);
    int v10 = 0;
    char v12 = 1;
LABEL_10:
    if (v35) {
      sub_10004D2C8(v35);
    }
    if (!v11)
    {
      BOOL v15 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "Missing telephony analytics interface", buf, 2u);
      }
      goto LABEL_80;
    }
    xpc_object_t v61 = 0;
    xpc_object_t v13 = xpc_dictionary_create(0, 0, 0);
    xpc_object_t v14 = v13;
    if (v13)
    {
      xpc_object_t v61 = v13;
    }
    else
    {
      xpc_object_t v14 = xpc_null_create();
      xpc_object_t v61 = v14;
      if (!v14)
      {
        xpc_object_t v16 = xpc_null_create();
        xpc_object_t v14 = 0;
        goto LABEL_22;
      }
    }
    if (xpc_get_type(v14) == (xpc_type_t)&_xpc_type_dictionary)
    {
      xpc_retain(v14);
LABEL_23:
      xpc_release(v14);
      unsigned int v17 = (const char *)(a1 + 224);
      if (*(char *)(a1 + 247) < 0) {
        unsigned int v17 = *(const char **)v17;
      }
      xpc_object_t v59 = xpc_string_create(v17);
      if (!v59) {
        xpc_object_t v59 = xpc_null_create();
      }
      *(void *)uint64_t buf = &v61;
      std::string v35 = (std::__shared_weak_count *)"privateNetworkSimType";
      sub_100035E70((uint64_t)buf, &v59, &v60);
      xpc_release(v60);
      xpc_object_t v60 = 0;
      xpc_release(v59);
      xpc_object_t v59 = 0;
      int v18 = (const char *)(a1 + 248);
      if (*(char *)(a1 + 271) < 0) {
        int v18 = *(const char **)v18;
      }
      xpc_object_t v57 = xpc_string_create(v18);
      if (!v57) {
        xpc_object_t v57 = xpc_null_create();
      }
      *(void *)uint64_t buf = &v61;
      std::string v35 = (std::__shared_weak_count *)"privateNetworkHplmnMcc";
      sub_100035E70((uint64_t)buf, &v57, &v58);
      xpc_release(v58);
      xpc_object_t v58 = 0;
      xpc_release(v57);
      xpc_object_t v57 = 0;
      int v19 = (const char *)(a1 + 272);
      if (*(char *)(a1 + 295) < 0) {
        int v19 = *(const char **)v19;
      }
      xpc_object_t v55 = xpc_string_create(v19);
      if (!v55) {
        xpc_object_t v55 = xpc_null_create();
      }
      *(void *)uint64_t buf = &v61;
      std::string v35 = (std::__shared_weak_count *)"privateNetworkHplmnMnc";
      sub_100035E70((uint64_t)buf, &v55, &v56);
      xpc_release(v56);
      xpc_object_t v56 = 0;
      xpc_release(v55);
      xpc_object_t v55 = 0;
      int v20 = (const char *)(a1 + 344);
      if (*(char *)(a1 + 367) < 0) {
        int v20 = *(const char **)v20;
      }
      xpc_object_t v53 = xpc_string_create(v20);
      if (!v53) {
        xpc_object_t v53 = xpc_null_create();
      }
      *(void *)uint64_t buf = &v61;
      std::string v35 = (std::__shared_weak_count *)"macroHplmnMcc";
      sub_100035E70((uint64_t)buf, &v53, &v54);
      xpc_release(v54);
      xpc_object_t v54 = 0;
      xpc_release(v53);
      xpc_object_t v53 = 0;
      long long v21 = (const char *)(a1 + 368);
      if (*(char *)(a1 + 391) < 0) {
        long long v21 = *(const char **)v21;
      }
      xpc_object_t v51 = xpc_string_create(v21);
      if (!v51) {
        xpc_object_t v51 = xpc_null_create();
      }
      *(void *)uint64_t buf = &v61;
      std::string v35 = (std::__shared_weak_count *)"macroHplmnMnc";
      sub_100035E70((uint64_t)buf, &v51, &v52);
      xpc_release(v52);
      xpc_object_t v52 = 0;
      xpc_release(v51);
      xpc_object_t v51 = 0;
      uint64_t v22 = (const char *)(a1 + 296);
      if (*(char *)(a1 + 319) < 0) {
        uint64_t v22 = *(const char **)v22;
      }
      xpc_object_t v49 = xpc_string_create(v22);
      if (!v49) {
        xpc_object_t v49 = xpc_null_create();
      }
      *(void *)uint64_t buf = &v61;
      std::string v35 = (std::__shared_weak_count *)"privateNetworkGid1";
      sub_100035E70((uint64_t)buf, &v49, &v50);
      xpc_release(v50);
      xpc_object_t v50 = 0;
      xpc_release(v49);
      xpc_object_t v49 = 0;
      int v23 = (const char *)(a1 + 320);
      if (*(char *)(a1 + 343) < 0) {
        int v23 = *(const char **)v23;
      }
      xpc_object_t v47 = xpc_string_create(v23);
      if (!v47) {
        xpc_object_t v47 = xpc_null_create();
      }
      *(void *)uint64_t buf = &v61;
      std::string v35 = (std::__shared_weak_count *)"privateNetworkGid2";
      sub_100035E70((uint64_t)buf, &v47, &object);
      xpc_release(object);
      xpc_object_t object = 0;
      xpc_release(v47);
      xpc_object_t v47 = 0;
      long long v24 = (const char *)(a1 + 392);
      if (*(char *)(a1 + 415) < 0) {
        long long v24 = *(const char **)v24;
      }
      xpc_object_t v45 = xpc_string_create(v24);
      if (!v45) {
        xpc_object_t v45 = xpc_null_create();
      }
      *(void *)uint64_t buf = &v61;
      std::string v35 = (std::__shared_weak_count *)"macroGid1";
      sub_100035E70((uint64_t)buf, &v45, &v46);
      xpc_release(v46);
      xpc_object_t v46 = 0;
      xpc_release(v45);
      xpc_object_t v45 = 0;
      long long v25 = (const char *)(a1 + 416);
      if (*(char *)(a1 + 439) < 0) {
        long long v25 = *(const char **)v25;
      }
      xpc_object_t v43 = xpc_string_create(v25);
      if (!v43) {
        xpc_object_t v43 = xpc_null_create();
      }
      *(void *)uint64_t buf = &v61;
      std::string v35 = (std::__shared_weak_count *)"macroGid2";
      sub_100035E70((uint64_t)buf, &v43, &v44);
      xpc_release(v44);
      xpc_object_t v44 = 0;
      xpc_release(v43);
      xpc_object_t v43 = 0;
      xpc_object_t v41 = xpc_BOOL_create(*(unsigned char *)(a1 + 440));
      if (!v41) {
        xpc_object_t v41 = xpc_null_create();
      }
      *(void *)uint64_t buf = &v61;
      std::string v35 = (std::__shared_weak_count *)"isGeofenceInfoLoaded";
      sub_100035E70((uint64_t)buf, &v41, &v42);
      xpc_release(v42);
      xpc_object_t v42 = 0;
      xpc_release(v41);
      xpc_object_t v41 = 0;
      long long v26 = (const char *)(a1 + 448);
      if (*(char *)(a1 + 471) < 0) {
        long long v26 = *(const char **)v26;
      }
      xpc_object_t v39 = xpc_string_create(v26);
      if (!v39) {
        xpc_object_t v39 = xpc_null_create();
      }
      *(void *)uint64_t buf = &v61;
      std::string v35 = (std::__shared_weak_count *)"geofenceInfoProfileVersion";
      sub_100035E70((uint64_t)buf, &v39, &v40);
      xpc_release(v40);
      xpc_object_t v40 = 0;
      xpc_release(v39);
      xpc_object_t v39 = 0;
      sub_100058DB0(buf, off_101A3ACB0[*(int *)(a1 + 472)]);
      if (v36 >= 0) {
        long long v27 = (Registry *)buf;
      }
      else {
        long long v27 = *(Registry **)buf;
      }
      xpc_object_t v37 = xpc_string_create((const char *)v27);
      if (!v37) {
        xpc_object_t v37 = xpc_null_create();
      }
      v33[0] = (unint64_t)&v61;
      v33[1] = (unint64_t)"geofenceInfoSource";
      sub_100035E70((uint64_t)v33, &v37, &v38);
      xpc_release(v38);
      xpc_object_t v38 = 0;
      xpc_release(v37);
      xpc_object_t v37 = 0;
      if (v36 < 0) {
        operator delete(*(void **)buf);
      }
      xpc_object_t v31 = xpc_BOOL_create(*(unsigned char *)(a1 + 441));
      if (!v31) {
        xpc_object_t v31 = xpc_null_create();
      }
      *(void *)uint64_t buf = &v61;
      std::string v35 = (std::__shared_weak_count *)"isCellularDataPreferredOverWifi";
      sub_100035E70((uint64_t)buf, &v31, &v32);
      xpc_release(v32);
      xpc_object_t v32 = 0;
      xpc_release(v31);
      xpc_object_t v31 = 0;
      xpc_object_t v29 = xpc_int64_create(*(unsigned __int16 *)(a1 + 476));
      if (!v29) {
        xpc_object_t v29 = xpc_null_create();
      }
      *(void *)uint64_t buf = &v61;
      std::string v35 = (std::__shared_weak_count *)"numOfGeofences";
      sub_100035E70((uint64_t)buf, &v29, &v30);
      xpc_release(v30);
      xpc_object_t v30 = 0;
      xpc_release(v29);
      xpc_object_t v28 = v61;
      xpc_object_t v29 = 0;
      if (v61) {
        xpc_retain(v61);
      }
      else {
        xpc_object_t v28 = xpc_null_create();
      }
      (*(void (**)(uint64_t, const char *, xpc_object_t *))(*(void *)v11 + 16))(v11, "commCenterPrivateNetworkPopulation", &v28);
      xpc_release(v28);
      xpc_object_t v28 = 0;
      xpc_release(v61);
LABEL_80:
      if ((v12 & 1) == 0) {
        sub_10004D2C8(v10);
      }
      return;
    }
    xpc_object_t v16 = xpc_null_create();
LABEL_22:
    xpc_object_t v61 = v16;
    goto LABEL_23;
  }
}

void sub_100B1019C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18)
{
  xpc_release(object);
  xpc_release(*(xpc_object_t *)(v20 - 72));
  if ((v19 & 1) == 0) {
    sub_10004D2C8(v18);
  }
  _Unwind_Resume(a1);
}

void sub_100B102A4(uint64_t a1)
{
  if (!*(void *)(a1 + 216)) {
    return;
  }
  (***(void (****)(void **__return_ptr))(a1 + 48))(&__p);
  ServiceMap = (std::mutex *)Registry::getServiceMap(v2, (Registry *)__p);
  int v4 = ServiceMap;
  if ((v5 & 0x8000000000000000) != 0)
  {
    int v6 = (unsigned __int8 *)(v5 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v7 = 5381;
    do
    {
      unint64_t v5 = v7;
      unsigned int v8 = *v6++;
      uint64_t v7 = (33 * v7) ^ v8;
    }
    while (v8);
  }
  std::mutex::lock(ServiceMap);
  v42[0] = v5;
  unsigned int v9 = sub_10004D37C(&v4[1].__m_.__sig, v42);
  if (!v9)
  {
    uint64_t v10 = 0;
    goto LABEL_9;
  }
  uint64_t v10 = v9[3];
  uint64_t v11 = (std::__shared_weak_count *)v9[4];
  if (!v11)
  {
LABEL_9:
    std::mutex::unlock(v4);
    uint64_t v11 = 0;
    char v32 = 1;
    goto LABEL_10;
  }
  atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v4);
  atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v11);
  char v32 = 0;
LABEL_10:
  if (v44) {
    sub_10004D2C8(v44);
  }
  xpc_object_t v31 = v11;
  if (v10)
  {
    char v12 = *(void **)(a1 + 200);
    if (v12 != (void *)(a1 + 208))
    {
      do
      {
        v66[0] = 0;
        xpc_object_t v13 = xpc_dictionary_create(0, 0, 0);
        xpc_object_t v14 = v13;
        if (v13)
        {
          v66[0] = v13;
        }
        else
        {
          xpc_object_t v14 = xpc_null_create();
          v66[0] = v14;
          if (!v14)
          {
            xpc_object_t v15 = xpc_null_create();
            xpc_object_t v14 = 0;
            goto LABEL_21;
          }
        }
        if (xpc_get_type(v14) != (xpc_type_t)&_xpc_type_dictionary)
        {
          xpc_object_t v15 = xpc_null_create();
LABEL_21:
          v66[0] = v15;
          goto LABEL_22;
        }
        xpc_retain(v14);
LABEL_22:
        xpc_release(v14);
        xpc_object_t v16 = (const char *)(a1 + 248);
        if (*(char *)(a1 + 271) < 0) {
          xpc_object_t v16 = *(const char **)(a1 + 248);
        }
        xpc_object_t v64 = xpc_string_create(v16);
        if (!v64) {
          xpc_object_t v64 = xpc_null_create();
        }
        std::string __p = v66;
        xpc_object_t v44 = (std::__shared_weak_count *)"privateNetworkHplmnMcc";
        sub_100035E70((uint64_t)&__p, &v64, &v65);
        xpc_release(v65);
        xpc_object_t v65 = 0;
        xpc_release(v64);
        xpc_object_t v64 = 0;
        unsigned int v17 = (const char *)(a1 + 272);
        if (*(char *)(a1 + 295) < 0) {
          unsigned int v17 = *(const char **)(a1 + 272);
        }
        xpc_object_t v62 = xpc_string_create(v17);
        if (!v62) {
          xpc_object_t v62 = xpc_null_create();
        }
        std::string __p = v66;
        xpc_object_t v44 = (std::__shared_weak_count *)"privateNetworkHplmnMnc";
        sub_100035E70((uint64_t)&__p, &v62, &v63);
        xpc_release(v63);
        xpc_object_t v63 = 0;
        xpc_release(v62);
        xpc_object_t v62 = 0;
        int v18 = (const char *)(a1 + 344);
        if (*(char *)(a1 + 367) < 0) {
          int v18 = *(const char **)(a1 + 344);
        }
        xpc_object_t v60 = xpc_string_create(v18);
        if (!v60) {
          xpc_object_t v60 = xpc_null_create();
        }
        std::string __p = v66;
        xpc_object_t v44 = (std::__shared_weak_count *)"macroHplmnMcc";
        sub_100035E70((uint64_t)&__p, &v60, &v61);
        xpc_release(v61);
        xpc_object_t v61 = 0;
        xpc_release(v60);
        xpc_object_t v60 = 0;
        char v19 = (const char *)(a1 + 368);
        if (*(char *)(a1 + 391) < 0) {
          char v19 = *(const char **)(a1 + 368);
        }
        xpc_object_t v58 = xpc_string_create(v19);
        if (!v58) {
          xpc_object_t v58 = xpc_null_create();
        }
        std::string __p = v66;
        xpc_object_t v44 = (std::__shared_weak_count *)"macroHplmnMnc";
        sub_100035E70((uint64_t)&__p, &v58, &v59);
        xpc_release(v59);
        xpc_object_t v59 = 0;
        xpc_release(v58);
        xpc_object_t v58 = 0;
        uint64_t v20 = (const char *)(a1 + 296);
        if (*(char *)(a1 + 319) < 0) {
          uint64_t v20 = *(const char **)(a1 + 296);
        }
        xpc_object_t v56 = xpc_string_create(v20);
        if (!v56) {
          xpc_object_t v56 = xpc_null_create();
        }
        std::string __p = v66;
        xpc_object_t v44 = (std::__shared_weak_count *)"privateNetworkGid1";
        sub_100035E70((uint64_t)&__p, &v56, &v57);
        xpc_release(v57);
        xpc_object_t v57 = 0;
        xpc_release(v56);
        xpc_object_t v56 = 0;
        long long v21 = (const char *)(a1 + 320);
        if (*(char *)(a1 + 343) < 0) {
          long long v21 = *(const char **)(a1 + 320);
        }
        xpc_object_t v54 = xpc_string_create(v21);
        if (!v54) {
          xpc_object_t v54 = xpc_null_create();
        }
        std::string __p = v66;
        xpc_object_t v44 = (std::__shared_weak_count *)"privateNetworkGid2";
        sub_100035E70((uint64_t)&__p, &v54, &v55);
        xpc_release(v55);
        xpc_object_t v55 = 0;
        xpc_release(v54);
        xpc_object_t v54 = 0;
        uint64_t v22 = (const char *)(a1 + 392);
        if (*(char *)(a1 + 415) < 0) {
          uint64_t v22 = *(const char **)(a1 + 392);
        }
        xpc_object_t v52 = xpc_string_create(v22);
        if (!v52) {
          xpc_object_t v52 = xpc_null_create();
        }
        std::string __p = v66;
        xpc_object_t v44 = (std::__shared_weak_count *)"macroGid1";
        sub_100035E70((uint64_t)&__p, &v52, &v53);
        xpc_release(v53);
        xpc_object_t v53 = 0;
        xpc_release(v52);
        xpc_object_t v52 = 0;
        int v23 = (const char *)(a1 + 416);
        if (*(char *)(a1 + 439) < 0) {
          int v23 = *(const char **)(a1 + 416);
        }
        xpc_object_t v50 = xpc_string_create(v23);
        if (!v50) {
          xpc_object_t v50 = xpc_null_create();
        }
        std::string __p = v66;
        xpc_object_t v44 = (std::__shared_weak_count *)"macroGid2";
        sub_100035E70((uint64_t)&__p, &v50, &object);
        xpc_release(object);
        xpc_object_t object = 0;
        xpc_release(v50);
        xpc_object_t v50 = 0;
        long long v24 = (const char *)(a1 + 448);
        if (*(char *)(a1 + 471) < 0) {
          long long v24 = *(const char **)(a1 + 448);
        }
        xpc_object_t v48 = xpc_string_create(v24);
        if (!v48) {
          xpc_object_t v48 = xpc_null_create();
        }
        std::string __p = v66;
        xpc_object_t v44 = (std::__shared_weak_count *)"geofenceInfoProfileVersion";
        sub_100035E70((uint64_t)&__p, &v48, &v49);
        xpc_release(v49);
        xpc_object_t v49 = 0;
        xpc_release(v48);
        xpc_object_t v48 = 0;
        sub_100058DB0(&__p, off_101A3ACB0[*(int *)(a1 + 472)]);
        if (v45 >= 0) {
          p_p = (const char *)&__p;
        }
        else {
          p_p = (const char *)__p;
        }
        xpc_object_t v46 = xpc_string_create(p_p);
        if (!v46) {
          xpc_object_t v46 = xpc_null_create();
        }
        v42[0] = (unint64_t)v66;
        v42[1] = (unint64_t)"geofenceInfoSource";
        sub_100035E70((uint64_t)v42, &v46, &v47);
        xpc_release(v47);
        xpc_object_t v47 = 0;
        xpc_release(v46);
        xpc_object_t v46 = 0;
        if (v45 < 0) {
          operator delete(__p);
        }
        xpc_object_t v40 = xpc_BOOL_create(*(unsigned char *)(a1 + 441));
        if (!v40) {
          xpc_object_t v40 = xpc_null_create();
        }
        std::string __p = v66;
        xpc_object_t v44 = (std::__shared_weak_count *)"isCellularDataPreferredOverWifi";
        sub_100035E70((uint64_t)&__p, &v40, &v41);
        xpc_release(v41);
        xpc_object_t v41 = 0;
        xpc_release(v40);
        xpc_object_t v40 = 0;
        xpc_object_t v38 = xpc_int64_create(*(unsigned __int16 *)(a1 + 476));
        if (!v38) {
          xpc_object_t v38 = xpc_null_create();
        }
        std::string __p = v66;
        xpc_object_t v44 = (std::__shared_weak_count *)"numOfGeofences";
        sub_100035E70((uint64_t)&__p, &v38, &v39);
        xpc_release(v39);
        xpc_object_t v39 = 0;
        xpc_release(v38);
        xpc_object_t v38 = 0;
        long long v26 = (const char *)(v12 + 10);
        if (*((char *)v12 + 103) < 0) {
          long long v26 = *(const char **)v26;
        }
        xpc_object_t v36 = xpc_string_create(v26);
        if (!v36) {
          xpc_object_t v36 = xpc_null_create();
        }
        std::string __p = v66;
        xpc_object_t v44 = (std::__shared_weak_count *)"geofenceId";
        sub_100035E70((uint64_t)&__p, &v36, &v37);
        xpc_release(v37);
        xpc_object_t v37 = 0;
        xpc_release(v36);
        xpc_object_t v36 = 0;
        xpc_object_t v34 = xpc_int64_create((int)*((double *)v12 + 7));
        if (!v34) {
          xpc_object_t v34 = xpc_null_create();
        }
        std::string __p = v66;
        xpc_object_t v44 = (std::__shared_weak_count *)"geofenceRadius";
        sub_100035E70((uint64_t)&__p, &v34, &v35);
        xpc_release(v35);
        xpc_object_t v35 = 0;
        xpc_release(v34);
        xpc_object_t v33 = v66[0];
        xpc_object_t v34 = 0;
        if (v66[0]) {
          xpc_retain(v66[0]);
        }
        else {
          xpc_object_t v33 = xpc_null_create();
        }
        (*(void (**)(uint64_t, const char *, xpc_object_t *))(*(void *)v10 + 16))(v10, "commCenterPrivateNetworkGeofences", &v33);
        xpc_release(v33);
        xpc_object_t v33 = 0;
        xpc_release(v66[0]);
        long long v27 = (void *)v12[1];
        if (v27)
        {
          do
          {
            xpc_object_t v28 = v27;
            long long v27 = (void *)*v27;
          }
          while (v27);
        }
        else
        {
          do
          {
            xpc_object_t v28 = (void *)v12[2];
            BOOL v29 = *v28 == (void)v12;
            char v12 = v28;
          }
          while (!v29);
        }
        char v12 = v28;
      }
      while (v28 != (void *)(a1 + 208));
    }
  }
  else
  {
    xpc_object_t v30 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
    {
      LOWORD(__p) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_ERROR, "Missing telephony analytics interface", (uint8_t *)&__p, 2u);
    }
  }
  if ((v32 & 1) == 0) {
    sub_10004D2C8(v31);
  }
}

void sub_100B10A68(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, int a10, int a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, xpc_object_t object, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,std::__shared_weak_count *a29)
{
  if (a29) {
    sub_10004D2C8(a29);
  }
  _Unwind_Resume(exception_object);
}

void sub_100B10BB4(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Cleaning up any outstanding sessions at end of day", buf, 2u);
  }
  if (*(unsigned char *)(a1 + 80))
  {
    sub_100B10EF4(a1, (unsigned int *)(a1 + 504));
    sub_100B12138(a1);
    int v3 = *(void **)(a1 + 480);
    if (v3 != (void *)(a1 + 488))
    {
      do
      {
        *((_DWORD *)v3 + 16) = 8;
        sub_100B10EF4(a1, (unsigned int *)v3 + 14);
        *((_DWORD *)v3 + 16) = 9;
        v3[7] = 0x800000000;
        *((_DWORD *)v3 + 49) = 0;
        *((_DWORD *)v3 + 50) = 0;
        *((_WORD *)v3 + 102) = 0;
        v3[26] = 0;
        v3[27] = 0;
        *((_DWORD *)v3 + 56) = 0;
        int v8 = 0;
        sub_100B10D0C(*(void (****)(Registry **__return_ptr))(a1 + 48), (_DWORD *)v3 + 14, &v8);
        int v7 = 4;
        sub_100B10D0C(*(void (****)(Registry **__return_ptr))(a1 + 48), (_DWORD *)v3 + 14, &v7);
        int v4 = (void *)v3[1];
        if (v4)
        {
          do
          {
            unint64_t v5 = v4;
            int v4 = (void *)*v4;
          }
          while (v4);
        }
        else
        {
          do
          {
            unint64_t v5 = (void *)v3[2];
            BOOL v6 = *v5 == (void)v3;
            int v3 = v5;
          }
          while (!v6);
        }
        int v3 = v5;
      }
      while (v5 != (void *)(a1 + 488));
    }
    sub_100B0F3D0(a1);
  }
}

void sub_100B10D0C(void (***a1)(Registry **__return_ptr), _DWORD *a2, _DWORD *a3)
{
  (**a1)(&v17);
  ServiceMap = (std::mutex *)Registry::getServiceMap(v5, v17);
  int v7 = ServiceMap;
  if ((v8 & 0x8000000000000000) != 0)
  {
    unsigned int v9 = (unsigned __int8 *)(v8 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v10 = 5381;
    do
    {
      unint64_t v8 = v10;
      unsigned int v11 = *v9++;
      uint64_t v10 = (33 * v10) ^ v11;
    }
    while (v11);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v19 = v8;
  char v12 = sub_10004D37C(&v7[1].__m_.__sig, &v19);
  if (v12)
  {
    uint64_t v14 = v12[3];
    xpc_object_t v13 = (std::__shared_weak_count *)v12[4];
    if (v13)
    {
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v7);
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v13);
      char v15 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v14 = 0;
  }
  std::mutex::unlock(v7);
  xpc_object_t v13 = 0;
  char v15 = 1;
LABEL_9:
  if (v18) {
    sub_10004D2C8(v18);
  }
  if (v14)
  {
    int v16 = (*(uint64_t (**)(uint64_t))(*(void *)v14 + 32))(v14);
    switch(*a3)
    {
      case 0:
        a2[38] = v16;
        if ((v15 & 1) == 0) {
          goto LABEL_21;
        }
        break;
      case 1:
        a2[39] = v16;
        goto LABEL_20;
      case 2:
        a2[40] = v16;
        if ((v15 & 1) == 0) {
          goto LABEL_21;
        }
        break;
      case 3:
        a2[41] = v16;
        if ((v15 & 1) == 0) {
          goto LABEL_21;
        }
        break;
      case 4:
        a2[42] = v16;
        if ((v15 & 1) == 0) {
          goto LABEL_21;
        }
        break;
      default:
        goto LABEL_20;
    }
  }
  else
  {
LABEL_20:
    if ((v15 & 1) == 0) {
LABEL_21:
    }
      sub_10004D2C8(v13);
  }
}

void sub_100B10EB4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  if ((v12 & 1) == 0) {
    sub_10004D2C8(v11);
  }
  _Unwind_Resume(exception_object);
}

void sub_100B10EF4(uint64_t a1, unsigned int *a2)
{
  int v4 = a2[38];
  if (v4)
  {
    *a2 = sub_100B1226C(*(void (****)(Registry **__return_ptr))(a1 + 48), v4);
    a2[38] = 0;
  }
  int v5 = a2[42];
  if (v5)
  {
    int v6 = *(unsigned __int8 *)(a1 + 81);
    int v7 = sub_100B1226C(*(void (****)(Registry **__return_ptr))(a1 + 48), v5);
    if (v6) {
      a2[35] += v7;
    }
    else {
      a2[36] += v7;
    }
    *(_DWORD *)uint64_t buf = 4;
    sub_100B10D0C(*(void (****)(Registry **__return_ptr))(a1 + 48), a2, buf);
  }
  (***(void (****)(unsigned char *__return_ptr))(a1 + 48))(buf);
  ServiceMap = (std::mutex *)Registry::getServiceMap(v8, *(Registry **)buf);
  uint64_t v10 = ServiceMap;
  if (v11 < 0)
  {
    char v12 = (unsigned __int8 *)(v11 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v13 = 5381;
    do
    {
      uint64_t v11 = v13;
      unsigned int v14 = *v12++;
      uint64_t v13 = (33 * v13) ^ v14;
    }
    while (v14);
  }
  std::mutex::lock(ServiceMap);
  int64_t v134 = (void *)v11;
  char v15 = sub_10004D37C(&v10[1].__m_.__sig, (unint64_t *)&v134);
  if (v15)
  {
    uint64_t v17 = v15[3];
    int v16 = (std::__shared_weak_count *)v15[4];
    if (v16)
    {
      atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v10);
      atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v16);
      char v18 = 0;
      goto LABEL_16;
    }
  }
  else
  {
    uint64_t v17 = 0;
  }
  std::mutex::unlock(v10);
  int v16 = 0;
  char v18 = 1;
LABEL_16:
  if (*(void *)&buf[8]) {
    sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
  }
  if (v17)
  {
    xpc_object_t v127 = 0;
    xpc_object_t v19 = xpc_dictionary_create(0, 0, 0);
    xpc_object_t v20 = v19;
    if (v19)
    {
      xpc_object_t v127 = v19;
    }
    else
    {
      xpc_object_t v20 = xpc_null_create();
      xpc_object_t v127 = v20;
      if (!v20)
      {
        xpc_object_t v22 = xpc_null_create();
        xpc_object_t v20 = 0;
        goto LABEL_28;
      }
    }
    if (xpc_get_type(v20) == (xpc_type_t)&_xpc_type_dictionary)
    {
      xpc_retain(v20);
LABEL_29:
      xpc_release(v20);
      int v23 = (const char **)(a1 + 248);
      long long v24 = (const char *)(a1 + 248);
      if (*(char *)(a1 + 271) < 0) {
        long long v24 = *v23;
      }
      xpc_object_t v125 = xpc_string_create(v24);
      if (!v125) {
        xpc_object_t v125 = xpc_null_create();
      }
      *(void *)uint64_t buf = &v127;
      *(void *)&uint8_t buf[8] = "privateNetworkHplmnMcc";
      sub_100035E70((uint64_t)buf, &v125, &object);
      xpc_release(object);
      xpc_object_t object = 0;
      xpc_release(v125);
      xpc_object_t v125 = 0;
      long long v25 = (const char **)(a1 + 272);
      long long v26 = (const char *)(a1 + 272);
      if (*(char *)(a1 + 295) < 0) {
        long long v26 = *v25;
      }
      xpc_object_t v123 = xpc_string_create(v26);
      if (!v123) {
        xpc_object_t v123 = xpc_null_create();
      }
      *(void *)uint64_t buf = &v127;
      *(void *)&uint8_t buf[8] = "privateNetworkHplmnMnc";
      sub_100035E70((uint64_t)buf, &v123, &v124);
      xpc_release(v124);
      xpc_object_t v124 = 0;
      xpc_release(v123);
      xpc_object_t v123 = 0;
      long long v27 = (const char **)(a1 + 296);
      xpc_object_t v28 = (const char *)(a1 + 296);
      if (*(char *)(a1 + 319) < 0) {
        xpc_object_t v28 = *v27;
      }
      xpc_object_t v121 = xpc_string_create(v28);
      if (!v121) {
        xpc_object_t v121 = xpc_null_create();
      }
      *(void *)uint64_t buf = &v127;
      *(void *)&uint8_t buf[8] = "privateNetworkGid1";
      sub_100035E70((uint64_t)buf, &v121, &v122);
      xpc_release(v122);
      xpc_object_t v122 = 0;
      xpc_release(v121);
      xpc_object_t v121 = 0;
      BOOL v29 = (const char **)(a1 + 320);
      xpc_object_t v30 = (const char *)(a1 + 320);
      if (*(char *)(a1 + 343) < 0) {
        xpc_object_t v30 = *v29;
      }
      xpc_object_t v119 = xpc_string_create(v30);
      if (!v119) {
        xpc_object_t v119 = xpc_null_create();
      }
      *(void *)uint64_t buf = &v127;
      *(void *)&uint8_t buf[8] = "privateNetworkGid2";
      sub_100035E70((uint64_t)buf, &v119, &v120);
      xpc_release(v120);
      xpc_object_t v120 = 0;
      xpc_release(v119);
      xpc_object_t v119 = 0;
      sub_100B0F698(buf, *(_DWORD *)(a1 + 64));
      if (v138 >= 0) {
        xpc_object_t v31 = buf;
      }
      else {
        xpc_object_t v31 = *(const char **)buf;
      }
      xpc_object_t v117 = xpc_string_create(v31);
      if (!v117) {
        xpc_object_t v117 = xpc_null_create();
      }
      int64_t v134 = &v127;
      __int16 v135 = "privateNetworkRat";
      sub_100035E70((uint64_t)&v134, &v117, &v118);
      xpc_release(v118);
      xpc_object_t v118 = 0;
      xpc_release(v117);
      xpc_object_t v117 = 0;
      if (SHIBYTE(v138) < 0) {
        operator delete(*(void **)buf);
      }
      xpc_object_t v115 = xpc_int64_create(*(unsigned __int16 *)(a1 + 68));
      if (!v115) {
        xpc_object_t v115 = xpc_null_create();
      }
      *(void *)uint64_t buf = &v127;
      *(void *)&uint8_t buf[8] = "privateNetworkBand";
      sub_100035E70((uint64_t)buf, &v115, &v116);
      xpc_release(v116);
      xpc_object_t v116 = 0;
      xpc_release(v115);
      xpc_object_t v115 = 0;
      char v32 = (const char *)(a1 + 344);
      long long v73 = (const char **)(a1 + 344);
      if (*(char *)(a1 + 367) < 0) {
        char v32 = *v73;
      }
      xpc_object_t v113 = xpc_string_create(v32);
      if (!v113) {
        xpc_object_t v113 = xpc_null_create();
      }
      *(void *)uint64_t buf = &v127;
      *(void *)&uint8_t buf[8] = "macroHplmnMcc";
      sub_100035E70((uint64_t)buf, &v113, &v114);
      xpc_release(v114);
      xpc_object_t v114 = 0;
      xpc_release(v113);
      xpc_object_t v113 = 0;
      xpc_object_t v33 = (const char *)(a1 + 368);
      uint64_t v72 = (const char **)(a1 + 368);
      if (*(char *)(a1 + 391) < 0) {
        xpc_object_t v33 = *v72;
      }
      xpc_object_t v111 = xpc_string_create(v33);
      if (!v111) {
        xpc_object_t v111 = xpc_null_create();
      }
      *(void *)uint64_t buf = &v127;
      *(void *)&uint8_t buf[8] = "macroHplmnMnc";
      sub_100035E70((uint64_t)buf, &v111, &v112);
      xpc_release(v112);
      xpc_object_t v112 = 0;
      xpc_release(v111);
      xpc_object_t v111 = 0;
      xpc_object_t v34 = (const char *)(a1 + 392);
      long long v71 = (const char **)(a1 + 392);
      if (*(char *)(a1 + 415) < 0) {
        xpc_object_t v34 = *v71;
      }
      xpc_object_t v109 = xpc_string_create(v34);
      if (!v109) {
        xpc_object_t v109 = xpc_null_create();
      }
      *(void *)uint64_t buf = &v127;
      *(void *)&uint8_t buf[8] = "macroGid1";
      sub_100035E70((uint64_t)buf, &v109, &v110);
      xpc_release(v110);
      xpc_object_t v110 = 0;
      xpc_release(v109);
      xpc_object_t v109 = 0;
      xpc_object_t v35 = (const char *)(a1 + 416);
      long long v70 = (const char **)(a1 + 416);
      if (*(char *)(a1 + 439) < 0) {
        xpc_object_t v35 = *v70;
      }
      xpc_object_t v107 = xpc_string_create(v35);
      if (!v107) {
        xpc_object_t v107 = xpc_null_create();
      }
      *(void *)uint64_t buf = &v127;
      *(void *)&uint8_t buf[8] = "macroGid2";
      sub_100035E70((uint64_t)buf, &v107, &v108);
      xpc_release(v108);
      xpc_object_t v108 = 0;
      xpc_release(v107);
      xpc_object_t v107 = 0;
      sub_100B0F698(buf, *(_DWORD *)(a1 + 72));
      if (v138 >= 0) {
        xpc_object_t v36 = buf;
      }
      else {
        xpc_object_t v36 = *(const char **)buf;
      }
      xpc_object_t v105 = xpc_string_create(v36);
      if (!v105) {
        xpc_object_t v105 = xpc_null_create();
      }
      int64_t v134 = &v127;
      __int16 v135 = "macroRat";
      sub_100035E70((uint64_t)&v134, &v105, &v106);
      xpc_release(v106);
      xpc_object_t v106 = 0;
      xpc_release(v105);
      xpc_object_t v105 = 0;
      if (SHIBYTE(v138) < 0) {
        operator delete(*(void **)buf);
      }
      xpc_object_t v103 = xpc_int64_create(*(unsigned __int16 *)(a1 + 76));
      if (!v103) {
        xpc_object_t v103 = xpc_null_create();
      }
      *(void *)uint64_t buf = &v127;
      *(void *)&uint8_t buf[8] = "macroBand";
      sub_100035E70((uint64_t)buf, &v103, &v104);
      xpc_release(v104);
      xpc_object_t v104 = 0;
      xpc_release(v103);
      xpc_object_t v103 = 0;
      xpc_object_t v101 = xpc_BOOL_create(*(unsigned char *)(a1 + 441));
      if (!v101) {
        xpc_object_t v101 = xpc_null_create();
      }
      *(void *)uint64_t buf = &v127;
      *(void *)&uint8_t buf[8] = "isCellularDataPreferredOverWifi";
      sub_100035E70((uint64_t)buf, &v101, &v102);
      xpc_release(v102);
      xpc_object_t v102 = 0;
      xpc_release(v101);
      xpc_object_t v101 = 0;
      xpc_object_t v37 = (const char *)(a1 + 448);
      long long v69 = (const char **)(a1 + 448);
      if (*(char *)(a1 + 471) < 0) {
        xpc_object_t v37 = *v69;
      }
      xpc_object_t v99 = xpc_string_create(v37);
      if (!v99) {
        xpc_object_t v99 = xpc_null_create();
      }
      *(void *)uint64_t buf = &v127;
      *(void *)&uint8_t buf[8] = "geofenceInfoProfileVersion";
      sub_100035E70((uint64_t)buf, &v99, &v100);
      xpc_release(v100);
      xpc_object_t v100 = 0;
      xpc_release(v99);
      xpc_object_t v99 = 0;
      xpc_object_t v97 = xpc_int64_create(*a2);
      if (!v97) {
        xpc_object_t v97 = xpc_null_create();
      }
      *(void *)uint64_t buf = &v127;
      *(void *)&uint8_t buf[8] = "sessionLength";
      sub_100035E70((uint64_t)buf, &v97, &v98);
      xpc_release(v98);
      xpc_object_t v98 = 0;
      xpc_release(v97);
      xpc_object_t v97 = 0;
      sub_100B1225C(buf, a2[1]);
      if (v138 >= 0) {
        xpc_object_t v38 = buf;
      }
      else {
        xpc_object_t v38 = *(const char **)buf;
      }
      xpc_object_t v95 = xpc_string_create(v38);
      if (!v95) {
        xpc_object_t v95 = xpc_null_create();
      }
      int64_t v134 = &v127;
      __int16 v135 = "sessionStartReason";
      sub_100035E70((uint64_t)&v134, &v95, &v96);
      xpc_release(v96);
      xpc_object_t v96 = 0;
      xpc_release(v95);
      xpc_object_t v95 = 0;
      if (SHIBYTE(v138) < 0) {
        operator delete(*(void **)buf);
      }
      sub_100B1225C(buf, a2[2]);
      if (v138 >= 0) {
        xpc_object_t v39 = buf;
      }
      else {
        xpc_object_t v39 = *(const char **)buf;
      }
      xpc_object_t v93 = xpc_string_create(v39);
      if (!v93) {
        xpc_object_t v93 = xpc_null_create();
      }
      int64_t v134 = &v127;
      __int16 v135 = "sessionEndReason";
      sub_100035E70((uint64_t)&v134, &v93, &v94);
      xpc_release(v94);
      xpc_object_t v94 = 0;
      xpc_release(v93);
      xpc_object_t v93 = 0;
      if (SHIBYTE(v138) < 0) {
        operator delete(*(void **)buf);
      }
      xpc_object_t v91 = xpc_BOOL_create(*((unsigned char *)a2 + 12));
      if (!v91) {
        xpc_object_t v91 = xpc_null_create();
      }
      *(void *)uint64_t buf = &v127;
      *(void *)&uint8_t buf[8] = "isRegisteredSuccessfully";
      sub_100035E70((uint64_t)buf, &v91, &v92);
      xpc_release(v92);
      xpc_object_t v92 = 0;
      xpc_release(v91);
      xpc_object_t v91 = 0;
      if (*((char *)a2 + 39) >= 0) {
        xpc_object_t v40 = (const char *)(a2 + 4);
      }
      else {
        xpc_object_t v40 = (const char *)*((void *)a2 + 2);
      }
      xpc_object_t v89 = xpc_string_create(v40);
      if (!v89) {
        xpc_object_t v89 = xpc_null_create();
      }
      *(void *)uint64_t buf = &v127;
      *(void *)&uint8_t buf[8] = "geofenceId";
      sub_100035E70((uint64_t)buf, &v89, &v90);
      xpc_release(v90);
      xpc_object_t v90 = 0;
      xpc_release(v89);
      xpc_object_t v89 = 0;
      xpc_object_t v87 = xpc_int64_create(*((unsigned __int16 *)a2 + 32));
      if (!v87) {
        xpc_object_t v87 = xpc_null_create();
      }
      *(void *)uint64_t buf = &v127;
      *(void *)&uint8_t buf[8] = "geofenceRadius";
      sub_100035E70((uint64_t)buf, &v87, &v88);
      xpc_release(v88);
      xpc_object_t v88 = 0;
      xpc_release(v87);
      xpc_object_t v87 = 0;
      xpc_object_t v85 = xpc_int64_create(a2[32]);
      if (!v85) {
        xpc_object_t v85 = xpc_null_create();
      }
      *(void *)uint64_t buf = &v127;
      *(void *)&uint8_t buf[8] = "timeToDisablePrivateNetworkAfterGeofenceExit";
      sub_100035E70((uint64_t)buf, &v85, &v86);
      xpc_release(v86);
      xpc_object_t v86 = 0;
      xpc_release(v85);
      xpc_object_t v85 = 0;
      xpc_object_t v83 = xpc_int64_create(a2[33]);
      if (!v83) {
        xpc_object_t v83 = xpc_null_create();
      }
      *(void *)uint64_t buf = &v127;
      *(void *)&uint8_t buf[8] = "timeToRegisterPrivateNetworkAfterGeofenceEntry";
      sub_100035E70((uint64_t)buf, &v83, &v84);
      xpc_release(v84);
      xpc_object_t v84 = 0;
      xpc_release(v83);
      xpc_object_t v83 = 0;
      xpc_object_t v81 = xpc_int64_create(a2[34]);
      if (!v81) {
        xpc_object_t v81 = xpc_null_create();
      }
      *(void *)uint64_t buf = &v127;
      *(void *)&uint8_t buf[8] = "timeToSwitchDdsToPrivateNetworkGeofenceEntry";
      sub_100035E70((uint64_t)buf, &v81, &v82);
      xpc_release(v82);
      xpc_object_t v82 = 0;
      xpc_release(v81);
      xpc_object_t v81 = 0;
      xpc_object_t v79 = xpc_int64_create(a2[35]);
      if (!v79) {
        xpc_object_t v79 = xpc_null_create();
      }
      *(void *)uint64_t buf = &v127;
      *(void *)&uint8_t buf[8] = "durationprivateNetworkIsRecommended";
      sub_100035E70((uint64_t)buf, &v79, &v80);
      xpc_release(v80);
      xpc_object_t v80 = 0;
      xpc_release(v79);
      xpc_object_t v79 = 0;
      xpc_object_t v77 = xpc_int64_create(a2[36]);
      if (!v77) {
        xpc_object_t v77 = xpc_null_create();
      }
      *(void *)uint64_t buf = &v127;
      *(void *)&uint8_t buf[8] = "durationprivateNetworkIsNotRecommended";
      sub_100035E70((uint64_t)buf, &v77, &v78);
      xpc_release(v78);
      xpc_object_t v78 = 0;
      xpc_release(v77);
      xpc_object_t v77 = 0;
      xpc_object_t v75 = xpc_int64_create(*((unsigned __int16 *)a2 + 74));
      if (!v75) {
        xpc_object_t v75 = xpc_null_create();
      }
      *(void *)uint64_t buf = &v127;
      *(void *)&uint8_t buf[8] = "numDataSwitches";
      sub_100035E70((uint64_t)buf, &v75, &v76);
      xpc_release(v76);
      xpc_object_t v76 = 0;
      xpc_release(v75);
      xpc_object_t v75 = 0;
      log = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(log, OS_LOG_TYPE_DEFAULT))
      {
        if (*(char *)(a1 + 271) < 0) {
          int v23 = (const char **)*v23;
        }
        if (*(char *)(a1 + 295) < 0) {
          long long v25 = (const char **)*v25;
        }
        if (*(char *)(a1 + 319) < 0) {
          long long v27 = (const char **)*v27;
        }
        if (*(char *)(a1 + 343) < 0) {
          BOOL v29 = (const char **)*v29;
        }
        long long v66 = v16;
        char v67 = v18;
        sub_100B0F698(&v134, *(_DWORD *)(a1 + 64));
        if (v136 >= 0) {
          xpc_object_t v41 = &v134;
        }
        else {
          xpc_object_t v41 = v134;
        }
        xpc_object_t v65 = v41;
        if (*(char *)(a1 + 367) < 0) {
          long long v73 = (const char **)*v73;
        }
        if (*(char *)(a1 + 391) < 0) {
          uint64_t v72 = (const char **)*v72;
        }
        if (*(char *)(a1 + 415) < 0) {
          long long v71 = (const char **)*v71;
        }
        if (*(char *)(a1 + 439) < 0) {
          long long v70 = (const char **)*v70;
        }
        xpc_object_t v42 = v25;
        int v64 = *(unsigned __int16 *)(a1 + 68);
        sub_100B0F698(v132, *(_DWORD *)(a1 + 72));
        xpc_object_t v43 = v29;
        if (v133 >= 0) {
          xpc_object_t v44 = v132;
        }
        else {
          xpc_object_t v44 = (void **)v132[0];
        }
        xpc_object_t v62 = v44;
        uint64_t v63 = v17;
        char v45 = v27;
        if (*(char *)(a1 + 471) < 0) {
          long long v69 = (const char **)*v69;
        }
        xpc_object_t v46 = v42;
        int v47 = *(unsigned __int16 *)(a1 + 76);
        int v48 = *(unsigned __int8 *)(a1 + 441);
        int v61 = *a2;
        sub_100B1225C(v130, a2[1]);
        int v49 = v131;
        xpc_object_t v50 = (void **)v130[0];
        sub_100B1225C(__p, a2[2]);
        xpc_object_t v51 = v130;
        xpc_object_t v52 = (void **)__p[0];
        if (v49 < 0) {
          xpc_object_t v51 = v50;
        }
        int v53 = *((unsigned __int8 *)a2 + 12);
        if (v129 >= 0) {
          xpc_object_t v52 = __p;
        }
        xpc_object_t v54 = a2 + 4;
        if (*((char *)a2 + 39) < 0) {
          xpc_object_t v54 = (unsigned int *)*((void *)a2 + 2);
        }
        int v55 = *((unsigned __int16 *)a2 + 32);
        unsigned int v56 = a2[32];
        unsigned int v57 = a2[33];
        unsigned int v58 = a2[34];
        unsigned int v59 = a2[35];
        unsigned int v60 = a2[36];
        *(_DWORD *)uint64_t buf = 136321282;
        *(void *)&uint8_t buf[4] = v23;
        *(_WORD *)&buf[12] = 2080;
        *(void *)&buf[14] = v46;
        __int16 v138 = 2080;
        uint64_t v139 = v45;
        __int16 v140 = 2080;
        uint64_t v141 = v43;
        __int16 v142 = 2080;
        v143 = v65;
        __int16 v144 = 1024;
        int v145 = v64;
        __int16 v146 = 2080;
        uint64_t v147 = v73;
        __int16 v148 = 2080;
        unsigned int v149 = v72;
        __int16 v150 = 2080;
        uint64_t v151 = v71;
        __int16 v152 = 2080;
        uint64_t v153 = v70;
        __int16 v154 = 2080;
        char v155 = v62;
        __int16 v156 = 1024;
        int v157 = v47;
        __int16 v158 = 1024;
        int v159 = v48;
        __int16 v160 = 2080;
        uint64_t v161 = v69;
        __int16 v162 = 1024;
        int v163 = v61;
        __int16 v164 = 2080;
        unsigned int v165 = v51;
        __int16 v166 = 2080;
        int v167 = v52;
        __int16 v168 = 1024;
        int v169 = v53;
        __int16 v170 = 2080;
        int v171 = v54;
        __int16 v172 = 1024;
        int v173 = v55;
        __int16 v174 = 1024;
        unsigned int v175 = v56;
        __int16 v176 = 1024;
        unsigned int v177 = v57;
        __int16 v178 = 1024;
        unsigned int v179 = v58;
        __int16 v180 = 1024;
        unsigned int v181 = v59;
        __int16 v182 = 1024;
        unsigned int v183 = v60;
        _os_log_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_DEFAULT, "#I [PnwMcc, PnwMnc, PnwGid1, PnwGid2, PnwRat, PnwBand]: (%s, %s, %s, %s, %s, %d), [MacroMcc, MacroMnc, MacroGid1, MacroGid2, MacroRat, MacroBand]: (%s, %s, %s, %s, %s, %d), IsCellularDataPreferredOverWifi: %d, GeofenceInfoProfileVersion: %s, SessionLength: %d, StartReason: %s, EndReason: %s, IsRegisteredSuccessfully: %d, GeofenceId: %s, GeofenceRadius: %d, TimeToDisablePnwAfterGeofenceExit: %d, TimeToRegisterPnwAfterGeofenceEntry: %d, TimeToSwitchDdsToPnwAfterGeofenceEntry: %d, DurationPnwIsRecommended: %d, DurationPnwIsNotRecommended: %d", buf, 0xD0u);
        if (v129 < 0) {
          operator delete(__p[0]);
        }
        int v16 = v66;
        char v18 = v67;
        uint64_t v17 = v63;
        if (v131 < 0) {
          operator delete(v130[0]);
        }
        if (v133 < 0) {
          operator delete(v132[0]);
        }
        if (v136 < 0) {
          operator delete(v134);
        }
      }
      xpc_object_t v74 = v127;
      if (v127) {
        xpc_retain(v127);
      }
      else {
        xpc_object_t v74 = xpc_null_create();
      }
      (*(void (**)(uint64_t, const char *, xpc_object_t *))(*(void *)v17 + 16))(v17, "commCenterprivateNetworkSession", &v74);
      xpc_release(v74);
      xpc_object_t v74 = 0;
      xpc_release(v127);
      goto LABEL_165;
    }
    xpc_object_t v22 = xpc_null_create();
LABEL_28:
    xpc_object_t v127 = v22;
    goto LABEL_29;
  }
  long long v21 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)uint64_t buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "Missing telephony analytics interface", buf, 2u);
  }
LABEL_165:
  if ((v18 & 1) == 0) {
    sub_10004D2C8(v16);
  }
}

void sub_100B11EA8(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_10006A6AC(a1);
}

void sub_100B12138(uint64_t a1)
{
  memset(v12, 0, sizeof(v12));
  long long v10 = 0u;
  long long v11 = 0u;
  long long v8 = 0u;
  *(_OWORD *)std::string __p = 0u;
  long long v6 = 0u;
  *(_OWORD *)int v7 = 0u;
  *(_OWORD *)int v4 = 0u;
  *(_OWORD *)int v5 = 0u;
  long long v3 = 0u;
  sub_100B125D4((uint64_t)&v3);
  *(void *)(a1 + 504) = v3;
  *(void *)(a1 + 509) = *(void *)((char *)&v3 + 5);
  std::string::operator=((std::string *)(a1 + 520), (const std::string *)v4);
  std::string::operator=((std::string *)(a1 + 544), (const std::string *)&v5[1]);
  *(_WORD *)(a1 + 568) = v7[0];
  *(unsigned char *)(a1 + 570) = BYTE2(v7[0]);
  std::string::operator=((std::string *)(a1 + 576), (const std::string *)&v7[1]);
  *(unsigned char *)(a1 + 600) = __p[0];
  std::string::operator=((std::string *)(a1 + 608), (const std::string *)&__p[1]);
  long long v2 = v12[0];
  *(_OWORD *)(a1 + 632) = v11;
  *(_OWORD *)(a1 + 648) = v2;
  *(_OWORD *)(a1 + 660) = *(_OWORD *)((char *)v12 + 12);
  if (SHIBYTE(v10) < 0) {
    operator delete(__p[1]);
  }
  if (SHIBYTE(v8) < 0) {
    operator delete(v7[1]);
  }
  if (SHIBYTE(v6) < 0) {
    operator delete(v5[1]);
  }
  if (SHIBYTE(v5[0]) < 0) {
    operator delete(v4[0]);
  }
}

void sub_100B12248(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void *sub_100B1225C(void *a1, int a2)
{
  return sub_100058DB0(a1, off_101A3ACC8[a2]);
}

uint64_t sub_100B1226C(void (***a1)(Registry **__return_ptr), int a2)
{
  (**a1)(&v16);
  ServiceMap = (std::mutex *)Registry::getServiceMap(v3, v16);
  int v5 = ServiceMap;
  if ((v6 & 0x8000000000000000) != 0)
  {
    int v7 = (unsigned __int8 *)(v6 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v8 = 5381;
    do
    {
      unint64_t v6 = v8;
      unsigned int v9 = *v7++;
      uint64_t v8 = (33 * v8) ^ v9;
    }
    while (v9);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v18 = v6;
  long long v10 = sub_10004D37C(&v5[1].__m_.__sig, &v18);
  if (v10)
  {
    uint64_t v12 = v10[3];
    long long v11 = (std::__shared_weak_count *)v10[4];
    if (v11)
    {
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v5);
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v11);
      char v13 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v12 = 0;
  }
  std::mutex::unlock(v5);
  long long v11 = 0;
  char v13 = 1;
LABEL_9:
  if (v17) {
    sub_10004D2C8(v17);
  }
  if (!v12)
  {
    uint64_t v14 = 0;
    if (v13) {
      return v14;
    }
    goto LABEL_13;
  }
  uint64_t v14 = (*(unsigned int (**)(uint64_t))(*(void *)v12 + 32))(v12) - a2;
  if ((v13 & 1) == 0) {
LABEL_13:
  }
    sub_10004D2C8(v11);
  return v14;
}

void sub_100B123BC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  if ((v12 & 1) == 0) {
    sub_10004D2C8(v11);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100B123E8(uint64_t a1)
{
  long long v2 = sub_100058DB0((void *)a1, "");
  sub_100058DB0(v2 + 3, "");
  sub_100058DB0((void *)(a1 + 48), "");
  sub_100058DB0((void *)(a1 + 72), "");
  sub_100058DB0((void *)(a1 + 96), "");
  sub_100058DB0((void *)(a1 + 120), "");
  sub_100058DB0((void *)(a1 + 144), "");
  sub_100058DB0((void *)(a1 + 168), "");
  sub_100058DB0((void *)(a1 + 192), "");
  *(_WORD *)(a1 + 216) = 0;
  *(unsigned char *)(a1 + 218) = 0;
  sub_100058DB0((void *)(a1 + 224), "");
  *(_DWORD *)(a1 + 248) = 0;
  *(_WORD *)(a1 + 252) = 0;
  return a1;
}

void sub_100B124F8(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 215) < 0) {
    operator delete(*v9);
  }
  if (*(char *)(v1 + 191) < 0) {
    operator delete(*v8);
  }
  if (*(char *)(v1 + 167) < 0) {
    operator delete(*v7);
  }
  if (*(char *)(v1 + 143) < 0) {
    operator delete(*v6);
  }
  if (*(char *)(v1 + 119) < 0) {
    operator delete(*v5);
  }
  if (*(char *)(v1 + 95) < 0) {
    operator delete(*v4);
  }
  if (*(char *)(v1 + 71) < 0) {
    operator delete(*v3);
  }
  if (*(char *)(v1 + 47) < 0) {
    operator delete(*v2);
  }
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100B125D4(uint64_t a1)
{
  *(void *)a1 = 0x900000000;
  *(_DWORD *)(a1 + 8) = 9;
  *(unsigned char *)(a1 + 12) = 0;
  sub_100058DB0((void *)(a1 + 16), "");
  sub_100058DB0((void *)(a1 + 40), "");
  *(_WORD *)(a1 + 64) = 0;
  *(unsigned char *)(a1 + 66) = 0;
  sub_100058DB0((void *)(a1 + 72), "");
  *(unsigned char *)(a1 + 96) = 0;
  sub_100058DB0((void *)(a1 + 104), "");
  *(void *)(a1 + 128) = 0;
  *(void *)(a1 + 136) = 0;
  *(void *)(a1 + 142) = 0;
  *(void *)(a1 + 152) = 0;
  *(void *)(a1 + 160) = 0;
  *(_DWORD *)(a1 + 168) = 0;
  return a1;
}

void sub_100B12688(_Unwind_Exception *exception_object)
{
  if (v1[95] < 0) {
    operator delete(*v4);
  }
  if (v1[63] < 0) {
    operator delete(*v3);
  }
  if (v1[39] < 0) {
    operator delete(*v2);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100B126D4(uint64_t a1)
{
  if (*(char *)(a1 + 247) < 0) {
    operator delete(*(void **)(a1 + 224));
  }
  if (*(char *)(a1 + 215) < 0) {
    operator delete(*(void **)(a1 + 192));
  }
  if (*(char *)(a1 + 191) < 0) {
    operator delete(*(void **)(a1 + 168));
  }
  if (*(char *)(a1 + 167) < 0) {
    operator delete(*(void **)(a1 + 144));
  }
  if (*(char *)(a1 + 143) < 0) {
    operator delete(*(void **)(a1 + 120));
  }
  if (*(char *)(a1 + 119) < 0) {
    operator delete(*(void **)(a1 + 96));
  }
  if (*(char *)(a1 + 95) < 0) {
    operator delete(*(void **)(a1 + 72));
  }
  if (*(char *)(a1 + 71) < 0) {
    operator delete(*(void **)(a1 + 48));
  }
  if (*(char *)(a1 + 47) < 0) {
    operator delete(*(void **)(a1 + 24));
  }
  if (*(char *)(a1 + 23) < 0) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void sub_100B12798(void *a1)
{
  if (a1)
  {
    sub_100B12798(*a1);
    sub_100B12798(a1[1]);
    sub_100B127EC((uint64_t)(a1 + 4));
    operator delete(a1);
  }
}

void sub_100B127EC(uint64_t a1)
{
  if (*(char *)(a1 + 151) < 0) {
    operator delete(*(void **)(a1 + 128));
  }
  if (*(char *)(a1 + 119) < 0) {
    operator delete(*(void **)(a1 + 96));
  }
  if (*(char *)(a1 + 87) < 0) {
    operator delete(*(void **)(a1 + 64));
  }
  if (*(char *)(a1 + 63) < 0) {
    operator delete(*(void **)(a1 + 40));
  }
  if (*(char *)(a1 + 23) < 0)
  {
    long long v2 = *(void **)a1;
    operator delete(v2);
  }
}

void sub_100B12874(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_100B12940(void *a1)
{
  __cxa_begin_catch(a1);
  dispatch_barrier_async_f(v1[3], v1, (dispatch_function_t)sub_100B12A18);
  __cxa_rethrow();
}

void sub_100B12968(_Unwind_Exception *a1)
{
}

void sub_100B12980(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100B129B8(uint64_t a1)
{
}

uint64_t sub_100B129D4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_100B12A18(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void sub_100B12A44(unint64_t **a1)
{
  unint64_t v1 = **a1;
  (***(void (****)(uint8_t *__return_ptr))(v1 + 48))(buf);
  ServiceMap = (std::mutex *)Registry::getServiceMap(v2, *(Registry **)buf);
  int v4 = ServiceMap;
  if ((v5 & 0x8000000000000000) != 0)
  {
    unint64_t v6 = (unsigned __int8 *)(v5 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v7 = 5381;
    do
    {
      unint64_t v5 = v7;
      unsigned int v8 = *v6++;
      uint64_t v7 = (33 * v7) ^ v8;
    }
    while (v8);
  }
  std::mutex::lock(ServiceMap);
  aBlock[0] = v5;
  unsigned int v9 = sub_10004D37C(&v4[1].__m_.__sig, aBlock);
  if (v9)
  {
    uint64_t v11 = v9[3];
    long long v10 = (std::__shared_weak_count *)v9[4];
    if (v10)
    {
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v4);
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v10);
      char v12 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v11 = 0;
  }
  std::mutex::unlock(v4);
  long long v10 = 0;
  char v12 = 1;
LABEL_9:
  if (v24) {
    sub_10004D2C8((std::__shared_weak_count *)v24);
  }
  if (v11)
  {
    char v13 = *(std::__shared_weak_count **)(v1 + 16);
    if (!v13 || (uint64_t v14 = *(void *)(v1 + 8), (v15 = std::__shared_weak_count::lock(v13)) == 0)) {
      sub_100088B9C();
    }
    int v16 = v15;
    atomic_fetch_add_explicit(&v15->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v15);
    uint64_t v17 = *(NSObject **)(v1 + 24);
    if (v17) {
      dispatch_retain(*(dispatch_object_t *)(v1 + 24));
    }
    aBlock[0] = (unint64_t)_NSConcreteStackBlock;
    aBlock[1] = 0x40000000;
    aBlock[2] = (unint64_t)sub_100B12DF8;
    aBlock[3] = (unint64_t)&unk_101A3ABF8;
    aBlock[4] = v1;
    if (v17)
    {
      unint64_t v18 = _Block_copy(aBlock);
      xpc_object_t v19 = v18;
      dispatch_object_t v30 = v17;
      *(void *)uint64_t buf = _NSConcreteStackBlock;
      uint64_t v24 = 1174405120;
      long long v25 = sub_100B12E3C;
      long long v26 = &unk_101A3AC18;
      uint64_t v27 = v14;
      xpc_object_t v28 = v16;
      atomic_fetch_add_explicit(&v16->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      if (v18) {
        xpc_object_t v20 = _Block_copy(v18);
      }
      else {
        xpc_object_t v20 = 0;
      }
      BOOL v29 = v20;
      (*(void (**)(uint64_t, const char *, uint64_t, dispatch_object_t *, uint8_t *))(*(void *)v11 + 40))(v11, "commCenterPnwDailyEvents", 1, &v30, buf);
      if (v30) {
        dispatch_release(v30);
      }
      if (v29) {
        _Block_release(v29);
      }
      if (v28) {
        std::__shared_weak_count::__release_weak(v28);
      }
      if (v19) {
        _Block_release(v19);
      }
    }
    std::__shared_weak_count::__release_weak(v16);
  }
  else
  {
    long long v21 = *(NSObject **)(v1 + 40);
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "Missing telephony analytics interface", buf, 2u);
    }
  }
  if ((v12 & 1) == 0) {
    sub_10004D2C8(v10);
  }
  operator delete();
}

void sub_100B12D54(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, std::__shared_weak_count *a20,void *aBlock)
{
  if (aBlock) {
    _Block_release(aBlock);
  }
  if (a20) {
    std::__shared_weak_count::__release_weak(a20);
  }
  long long v26 = *(NSObject **)(v25 - 72);
  if (v26) {
    dispatch_release(v26);
  }
  if (v23) {
    _Block_release(v23);
  }
  std::__shared_weak_count::__release_weak(v22);
  if ((v24 & 1) == 0) {
    sub_10004D2C8(v21);
  }
  operator delete();
}

void sub_100B12DF8(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  sub_100B0FA0C(v1);
  sub_100B102A4(v1);

  sub_100B10BB4(v1);
}

void sub_100B12E3C(void *a1, uint64_t a2)
{
  long long v3 = (std::__shared_weak_count *)a1[5];
  if (v3)
  {
    unint64_t v5 = std::__shared_weak_count::lock(v3);
    if (v5)
    {
      unint64_t v6 = v5;
      if (a1[4]) {
        sub_10041DE0C(a1 + 6, a2);
      }
      sub_10004D2C8(v6);
    }
  }
}

void sub_100B12EB4(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void *sub_100B12EC8(void *a1, void *a2)
{
  uint64_t v3 = a2[5];
  a1[4] = a2[4];
  a1[5] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  uint64_t result = (void *)a2[6];
  if (result) {
    uint64_t result = _Block_copy(result);
  }
  a1[6] = result;
  return result;
}

void sub_100B12F14(uint64_t a1)
{
  long long v2 = *(const void **)(a1 + 48);
  if (v2) {
    _Block_release(v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 40);
  if (v3)
  {
    std::__shared_weak_count::__release_weak(v3);
  }
}

unsigned char *sub_100B12F68(uint64_t **a1, void **a2, long long **a3)
{
  unint64_t v6 = a1 + 1;
  unint64_t v5 = a1[1];
  uint64_t v7 = (uint64_t *)(a1 + 1);
  unsigned int v8 = (uint64_t *)(a1 + 1);
  if (!v5) {
    goto LABEL_10;
  }
  uint64_t v7 = (uint64_t *)(a1 + 1);
  while (1)
  {
    while (1)
    {
      unsigned int v8 = v5;
      long long v10 = v5 + 4;
      if ((sub_100046FE8(a2, (void **)v5 + 4) & 0x80) == 0) {
        break;
      }
      unint64_t v5 = (uint64_t *)*v8;
      uint64_t v7 = v8;
      if (!*v8) {
        goto LABEL_10;
      }
    }
    if ((sub_100046FE8(v10, a2) & 0x80) == 0) {
      break;
    }
    uint64_t v7 = v8 + 1;
    unint64_t v5 = (uint64_t *)v8[1];
    if (!v5) {
      goto LABEL_10;
    }
  }
  uint64_t v11 = (unsigned char *)*v7;
  if (!*v7)
  {
LABEL_10:
    char v12 = *a3;
    uint64_t v19 = 0;
    char v13 = operator new(0xE8uLL);
    uint64_t v14 = v13;
    v18[0] = v13;
    v18[1] = v6;
    if (*((char *)v12 + 23) < 0)
    {
      sub_10004FC84(v13 + 32, *(void **)v12, *((void *)v12 + 1));
    }
    else
    {
      long long v15 = *v12;
      *((void *)v13 + 6) = *((void *)v12 + 2);
      *((_OWORD *)v13 + 2) = v15;
    }
    *(_OWORD *)(v14 + 56) = 0u;
    *(_OWORD *)(v14 + 200) = 0u;
    *(_OWORD *)(v14 + 216) = 0u;
    *(_OWORD *)(v14 + 168) = 0u;
    *(_OWORD *)(v14 + 184) = 0u;
    *(_OWORD *)(v14 + 136) = 0u;
    *(_OWORD *)(v14 + 152) = 0u;
    *(_OWORD *)(v14 + 104) = 0u;
    *(_OWORD *)(v14 + 120) = 0u;
    *(_OWORD *)(v14 + 72) = 0u;
    *(_OWORD *)(v14 + 88) = 0u;
    sub_100B125D4((uint64_t)(v14 + 56));
    LOBYTE(v19) = 1;
    *(void *)uint64_t v14 = 0;
    *((void *)v14 + 1) = 0;
    *((void *)v14 + 2) = v8;
    uint64_t *v7 = (uint64_t)v14;
    int v16 = (uint64_t *)**a1;
    if (v16)
    {
      *a1 = v16;
      uint64_t v14 = (unsigned char *)*v7;
    }
    sub_100046C90(a1[1], (uint64_t *)v14);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
    uint64_t v11 = (unsigned char *)v18[0];
    v18[0] = 0;
    sub_100B13104((uint64_t)v18);
  }
  return v11;
}

void sub_100B130D8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100B13104((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_100B13104(uint64_t a1)
{
  uint64_t v1 = *(void **)a1;
  *(void *)a1 = 0;
  if (v1)
  {
    if (*(unsigned char *)(a1 + 16)) {
      sub_100B127EC((uint64_t)v1 + 32);
    }
    operator delete(v1);
  }
}

uint64_t sub_100B1315C(uint64_t a1, uint64_t a2, int a3)
{
  unint64_t v5 = "sig.gw.?";
  if (a3 == 2) {
    unint64_t v5 = "sig.gw.2";
  }
  if (a3 == 1) {
    unint64_t v6 = "sig.gw.1";
  }
  else {
    unint64_t v6 = v5;
  }
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)v16, kCtLoggingSystemName, v6);
  SignalStrengthModel::SignalStrengthModel();
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)v16);
  *(void *)(a1 + 112) = 0;
  *(void *)(a1 + 120) = 0;
  *(void *)a1 = off_101A3AD28;
  *(_OWORD *)(a1 + 136) = 0u;
  *(_OWORD *)(a1 + 152) = 0u;
  *(void *)(a1 + 128) = 0xC022000000000000;
  *(void *)(a1 + 144) = 0xC05F400000000000;
  *(void *)(a1 + 160) = 0xC060400000000000;
  *(void *)(a1 + 168) = 0;
  *(void *)(a1 + 184) = 0;
  *(void *)(a1 + 176) = off_101A375C0;
  __asm { FMOV            V1.2D, #-9.0 }
  *(_OWORD *)(a1 + 192) = _Q1;
  *(void *)(a1 + 224) = 0;
  *(void *)(a1 + 208) = 0x3F90000000000000;
  *(void *)(a1 + 216) = off_101A375C0;
  *(int64x2_t *)(a1 + 232) = vdupq_n_s64(0xC05F400000000000);
  *(void *)(a1 + 264) = 0;
  *(void *)(a1 + 248) = 0x3FD8000000000000;
  *(void *)(a1 + 256) = off_101A375C0;
  *(void *)(a1 + 288) = 0x3FD8000000000000;
  *(int64x2_t *)(a1 + 272) = vdupq_n_s64(0xC060400000000000);
  *(void *)(a1 + 328) = 0;
  char v12 = (char *)operator new(0x10uLL);
  *(void *)(a1 + 296) = v12;
  *(void *)(a1 + 304) = v12 + 16;
  *(void *)(a1 + 312) = v12;
  *(void *)(a1 + 320) = v12;
  *(void *)(a1 + 368) = 0;
  char v13 = (char *)operator new(0x10uLL);
  *(void *)(a1 + 336) = v13;
  *(void *)(a1 + 344) = v13 + 16;
  *(void *)(a1 + 352) = v13;
  *(void *)(a1 + 360) = v13;
  *(void *)(a1 + 408) = 0;
  uint64_t v14 = (char *)operator new(0x10uLL);
  *(void *)(a1 + 376) = v14;
  *(void *)(a1 + 384) = v14 + 16;
  *(void *)(a1 + 392) = v14;
  *(void *)(a1 + 400) = v14;
  *(_WORD *)(a1 + 416) = 0;
  *(unsigned char *)(a1 + 418) = 0;
  *(void *)(a1 + 424) = a1 + 432;
  *(void *)(a1 + 432) = 0;
  *(void *)(a1 + 456) = 0;
  *(void *)(a1 + 464) = 0;
  *(void *)(a1 + 440) = 0;
  *(void *)(a1 + 448) = a1 + 456;
  *(void *)(a1 + 472) = a1 + 480;
  *(void *)(a1 + 480) = 0;
  *(void *)(a1 + 504) = 0;
  *(void *)(a1 + 512) = 0;
  *(void *)(a1 + 488) = 0;
  *(void *)(a1 + 496) = a1 + 504;
  *(void *)(a1 + 520) = 0x100000001;
  *(_DWORD *)(a1 + 528) = 1;
  *(void *)(a1 + 568) = 0;
  *(void *)(a1 + 576) = 0;
  *(void *)(a1 + 560) = a1 + 568;
  *(void *)(a1 + 600) = 0;
  *(void *)(a1 + 592) = 0;
  *(void *)(a1 + 584) = a1 + 592;
  *(void *)(a1 + 608) = 0x100000001;
  *(_OWORD *)(a1 + 536) = xmmword_101536F50;
  *(_DWORD *)(a1 + 552) = 0;
  *(_DWORD *)(a1 + 616) = a3;
  return a1;
}

void sub_100B13390(_Unwind_Exception *a1)
{
  sub_100ABB244(v2);
  sub_100ABB244((uint64_t)v1 + 296);
  int v4 = (std::__shared_weak_count *)*((void *)v1 + 15);
  if (v4) {
    std::__shared_weak_count::__release_weak(v4);
  }
  SignalStrengthModel::~SignalStrengthModel(v1);
  _Unwind_Resume(a1);
}

void sub_100B133E0(uint64_t a1)
{
  *(void *)a1 = off_101A3AD28;
  sub_1000346F8(a1 + 584, *(void **)(a1 + 592));
  sub_1000346F8(a1 + 560, *(void **)(a1 + 568));
  sub_1000346F8(a1 + 496, *(void **)(a1 + 504));
  sub_1000346F8(a1 + 472, *(void **)(a1 + 480));
  sub_1000346F8(a1 + 448, *(void **)(a1 + 456));
  sub_1000346F8(a1 + 424, *(void **)(a1 + 432));
  sub_100ABB244(a1 + 376);
  sub_100ABB244(a1 + 336);
  sub_100ABB244(a1 + 296);
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 120);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  SignalStrengthModel::~SignalStrengthModel((SignalStrengthModel *)a1);
}

uint64_t sub_100B134A4(uint64_t a1)
{
  uint64_t v1 = a1;
  sub_100B1354C(*(void *)(a1 + 24), *(std::__shared_weak_count **)(v1 + 32), v1);
  sub_100B13728(v1);
  uint64_t v4 = 0;
  v5[0] = 2;
  v5[1] = (uint64_t)&v4;
  void v5[2] = v1 + 376;
  sub_100ABC274((void *)(v1 + 376), 2, 2, v5);
  sub_100B137A4((uint64_t **)v1);
  uint64_t v2 = *(void *)(v1 + 176);
  v1 += 176;
  LODWORD(v5[0]) = *(_DWORD *)(v1 + 12) + 1;
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t *))(v2 + 24))(v1, v1 - 48, v5);
}

void sub_100B1354C(uint64_t a1, std::__shared_weak_count *a2, uint64_t a3)
{
  if (a2) {
    atomic_fetch_add_explicit(&a2->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v10 = 0;
  double v11 = 0.0;
  uint64_t v12 = 0;
  double v6 = *(double *)(a3 + 128);
  double v7 = 1.0;
  if (v6 > -9.0 && *(double *)(a3 + 160) > -75.0)
  {
    int v14 = 0;
    double v13 = v6 + 9.0;
    sub_100ABB420(&v14, &v13);
    double v7 = (double)v14;
    if ((double)v14 < 1.0) {
      double v7 = 1.0;
    }
  }
  double v11 = v7;
  uint64_t v12 = 0;
  uint64_t v10 = 1;
  sub_100ABB280(a1, 0x400000000, (uint64_t)&v10);
  if (a2) {
    atomic_fetch_add_explicit(&a2->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v10 = 0;
  double v11 = 0.0;
  uint64_t v12 = 0;
  double v8 = 1.0;
  if (*(double *)(a3 + 128) > -9.0)
  {
    double v9 = *(double *)(a3 + 160);
    if (v9 > -75.0)
    {
      int v14 = 0;
      double v13 = v9 + 75.0;
      sub_100ABB420(&v14, &v13);
      double v8 = (double)v14;
      if ((double)v14 < 1.0) {
        double v8 = 1.0;
      }
    }
  }
  double v11 = v8;
  uint64_t v12 = 0;
  uint64_t v10 = 1;
  sub_100ABB280(a1, 0, (uint64_t)&v10);
  if (a2) {
    atomic_fetch_add_explicit(&a2->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v10 = 0;
  double v11 = 0.0;
  uint64_t v12 = 0;
  sub_100ABB280(a1, 0x300000000, (uint64_t)&v10);
  if (a2)
  {
    sub_10004D2C8(a2);
    sub_10004D2C8(a2);
    sub_10004D2C8(a2);
  }
}

void sub_100B136E8(_Unwind_Exception *exception_object)
{
  if (v1)
  {
    sub_10004D2C8(v1);
    sub_10004D2C8(v1);
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100B13728(uint64_t a1)
{
  unint64_t v2 = 0xC022000000000000;
  uint64_t v3 = 2;
  uint64_t v4 = &v2;
  uint64_t v5 = a1 + 296;
  sub_100ABC274((void *)(a1 + 296), 2, 2, &v3);
  unint64_t v2 = 0xC060400000000000;
  uint64_t v3 = 2;
  uint64_t v4 = &v2;
  uint64_t v5 = a1 + 336;
  sub_100ABC274((void *)(a1 + 336), 2, 2, &v3);
}

uint64_t *sub_100B137A4(uint64_t **a1)
{
  uint64_t v1 = a1;
  unint64_t v2 = a1 + 53;
  unsigned int v4 = 1;
  uint64_t v5 = &v4;
  sub_100ABC158(a1 + 53, &v4, (uint64_t)&unk_10144E20E, &v5)[5] = (uint64_t *)0xC030000000000000;
  unsigned int v4 = 2;
  uint64_t v5 = &v4;
  sub_100ABC158(v2, &v4, (uint64_t)&unk_10144E20E, &v5)[5] = (uint64_t *)0xC02C000000000000;
  unsigned int v4 = 3;
  uint64_t v5 = &v4;
  sub_100ABC158(v2, &v4, (uint64_t)&unk_10144E20E, &v5)[5] = (uint64_t *)0xC028000000000000;
  unsigned int v4 = 4;
  uint64_t v5 = &v4;
  sub_100ABC158(v2, &v4, (uint64_t)&unk_10144E20E, &v5)[5] = (uint64_t *)0xC024000000000000;
  unsigned int v4 = 1;
  uint64_t v5 = &v4;
  sub_100ABC158(v1 + 56, &v4, (uint64_t)&unk_10144E20E, &v5)[5] = (uint64_t *)0xC05A800000000000;
  unsigned int v4 = 2;
  uint64_t v5 = &v4;
  sub_100ABC158(v1 + 56, &v4, (uint64_t)&unk_10144E20E, &v5)[5] = (uint64_t *)0xC059000000000000;
  unsigned int v4 = 3;
  uint64_t v5 = &v4;
  sub_100ABC158(v1 + 56, &v4, (uint64_t)&unk_10144E20E, &v5)[5] = (uint64_t *)0xC056800000000000;
  unsigned int v4 = 4;
  uint64_t v5 = &v4;
  sub_100ABC158(v1 + 56, &v4, (uint64_t)&unk_10144E20E, &v5)[5] = (uint64_t *)0xC054000000000000;
  unsigned int v4 = 1;
  uint64_t v5 = &v4;
  sub_100ABC158(v1 + 59, &v4, (uint64_t)&unk_10144E20E, &v5)[5] = (uint64_t *)0xC05A000000000000;
  unsigned int v4 = 2;
  uint64_t v5 = &v4;
  sub_100ABC158(v1 + 59, &v4, (uint64_t)&unk_10144E20E, &v5)[5] = (uint64_t *)0xC058800000000000;
  unsigned int v4 = 3;
  uint64_t v5 = &v4;
  sub_100ABC158(v1 + 59, &v4, (uint64_t)&unk_10144E20E, &v5)[5] = (uint64_t *)0xC056400000000000;
  unsigned int v4 = 4;
  uint64_t v5 = &v4;
  sub_100ABC158(v1 + 59, &v4, (uint64_t)&unk_10144E20E, &v5)[5] = (uint64_t *)0xC054000000000000;
  unsigned int v4 = 1;
  uint64_t v5 = &v4;
  sub_100ABC158(v1 + 62, &v4, (uint64_t)&unk_10144E20E, &v5)[5] = (uint64_t *)0xC05D000000000000;
  unsigned int v4 = 2;
  uint64_t v5 = &v4;
  sub_100ABC158(v1 + 62, &v4, (uint64_t)&unk_10144E20E, &v5)[5] = (uint64_t *)0xC05C400000000000;
  unsigned int v4 = 3;
  uint64_t v5 = &v4;
  sub_100ABC158(v1 + 62, &v4, (uint64_t)&unk_10144E20E, &v5)[5] = (uint64_t *)0xC05B800000000000;
  unsigned int v4 = 4;
  uint64_t v5 = &v4;
  sub_100ABC158(v1 + 62, &v4, (uint64_t)&unk_10144E20E, &v5)[5] = (uint64_t *)0xC05AC00000000000;
  unsigned int v4 = 2;
  v1 += 70;
  uint64_t v5 = &v4;
  *((_DWORD *)sub_100ABCA70(v1, &v4, (uint64_t)&unk_10144E20E, &v5) + 8) = 8;
  unsigned int v4 = 3;
  uint64_t v5 = &v4;
  *((_DWORD *)sub_100ABCA70(v1, &v4, (uint64_t)&unk_10144E20E, &v5) + 8) = 5;
  unsigned int v4 = 4;
  uint64_t v5 = &v4;
  *((_DWORD *)sub_100ABCA70(v1, &v4, (uint64_t)&unk_10144E20E, &v5) + 8) = 5;
  unsigned int v4 = 5;
  uint64_t v5 = &v4;
  uint64_t result = sub_100ABCA70(v1, &v4, (uint64_t)&unk_10144E20E, &v5);
  *((_DWORD *)result + 8) = 8;
  return result;
}

uint64_t sub_100B13B4C(uint64_t a1, uint64_t a2, double a3)
{
  if (a2)
  {
    if (*(_DWORD *)(a1 + 16) >= 3u)
    {
      uint64_t v5 = *(NSObject **)(a1 + 8);
      BOOL v6 = os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT);
      uint64_t result = 0;
      if (!v6) {
        return result;
      }
      asString();
      if (v10 >= 0) {
        p_p = &__p;
      }
      else {
        p_p = __p;
      }
      *(_DWORD *)uint64_t buf = 136315394;
      uint64_t v12 = p_p;
      __int16 v13 = 2048;
      double v14 = a3;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Input rejected of wrong type: %s = %f", buf, 0x16u);
      if (v10 < 0) {
        operator delete(__p);
      }
    }
    return 0;
  }
  if (HIDWORD(a2) == 4)
  {
    uint64_t result = 0;
    if (a3 < 0.0 && a3 >= -24.5)
    {
      *(double *)(a1 + 128) = a3;
      uint64_t result = 1;
      *(unsigned char *)(a1 + 136) = 1;
    }
  }
  else if (HIDWORD(a2) == 3)
  {
    uint64_t result = 0;
    if (a3 < -25.0 && a3 >= -130.0)
    {
      *(double *)(a1 + 160) = a3;
      uint64_t result = 1;
      *(unsigned char *)(a1 + 168) = 1;
    }
  }
  else
  {
    if (HIDWORD(a2)) {
      return 0;
    }
    uint64_t result = 0;
    if (a3 < -25.0 && a3 >= -125.0)
    {
      *(double *)(a1 + 144) = a3;
      uint64_t result = 1;
      *(unsigned char *)(a1 + 152) = 1;
    }
  }
  return result;
}

const void **sub_100B13D04(uint64_t a1)
{
  CFTypeRef cf = 0;
  ServiceMap = (std::mutex *)Registry::getServiceMap(__stack_chk_guard, *(Registry **)(a1 + 72));
  uint64_t v3 = ServiceMap;
  if (v4 < 0)
  {
    uint64_t v5 = (unsigned __int8 *)(v4 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v6 = 5381;
    do
    {
      uint64_t v4 = v6;
      unsigned int v7 = *v5++;
      uint64_t v6 = (33 * v6) ^ v7;
    }
    while (v7);
  }
  std::mutex::lock(ServiceMap);
  *(void *)uint64_t buf = v4;
  double v8 = sub_10004D37C(&v3[1].__m_.__sig, (unint64_t *)buf);
  if (v8)
  {
    uint64_t v10 = v8[3];
    double v9 = (std::__shared_weak_count *)v8[4];
    if (v9)
    {
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v3);
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v9);
      char v11 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v10 = 0;
  }
  std::mutex::unlock(v3);
  double v9 = 0;
  char v11 = 1;
LABEL_9:
  (*(void (**)(CFTypeRef *__return_ptr, uint64_t, void, uint64_t, const __CFString *, const CFBooleanRef, void))(*(void *)v10 + 96))(&cf, v10, *(unsigned int *)(a1 + 616), 2, @"UseEcn0Bars", kCFBooleanFalse, 0);
  if ((v11 & 1) == 0) {
    sub_10004D2C8(v9);
  }
  uint64_t v12 = (BOOL *)cf;
  buf[0] = 0;
  if (cf)
  {
    CFTypeID v13 = CFGetTypeID(cf);
    if (v13 == CFBooleanGetTypeID())
    {
      ctu::cf::assign((ctu::cf *)buf, v12, v14);
      LODWORD(v12) = buf[0];
    }
    else
    {
      LODWORD(v12) = 0;
    }
  }
  *(unsigned char *)(a1 + 418) = (_BYTE)v12;
  long long v15 = *(NSObject **)(a1 + 8);
  if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
  {
    int v16 = "true";
    if (!v12) {
      int v16 = "false";
    }
    *(_DWORD *)uint64_t buf = 136315138;
    *(void *)&uint8_t buf[4] = v16;
    _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I Using ecN0 bars = %s", buf, 0xCu);
  }
  return sub_1000577C4(&cf);
}

void sub_100B13F04(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  if ((v10 & 1) == 0) {
    sub_10004D2C8(v11);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100B13F3C(uint64_t a1)
{
  uint64_t result = SignalStrengthModel::heartBeat((SignalStrengthModel *)a1);
  if (result)
  {
    if (*(_DWORD *)(a1 + 16))
    {
      uint64_t v3 = *(NSObject **)(a1 + 8);
      if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v4 = *(void *)(a1 + 144);
        uint64_t v5 = *(void *)(a1 + 128);
        *(_DWORD *)uint64_t buf = 134218240;
        *(void *)&uint8_t buf[4] = v4;
        *(_WORD *)&buf[12] = 2048;
        *(void *)&buf[14] = v5;
        _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I X_RSSI(n) = %f, X_EcN0(n) = %f", buf, 0x16u);
      }
    }
    if (!*(unsigned char *)(a1 + 152) || !*(unsigned char *)(a1 + 136) && *(_DWORD *)(a1 + 64)) {
      return 0;
    }
    *(unsigned char *)(a1 + 40) = 1;
    double v6 = *(double *)(a1 + 144) + *(double *)(a1 + 128);
    if (v6 < -25.0 && v6 >= -130.0)
    {
      *(double *)(a1 + 160) = v6;
      *(unsigned char *)(a1 + 168) = 1;
    }
    if (*(_DWORD *)(a1 + 16))
    {
      unsigned int v7 = *(NSObject **)(a1 + 8);
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v8 = *(void *)(a1 + 160);
        *(_DWORD *)uint64_t buf = 134217984;
        *(void *)&uint8_t buf[4] = v8;
        _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I X_RSCP(n) = %f", buf, 0xCu);
      }
    }
    uint64_t v9 = *(void *)(a1 + 216);
    *(_DWORD *)uint64_t buf = *(_DWORD *)(a1 + 228) + 1;
    (*(void (**)(uint64_t, uint64_t, unsigned char *))(v9 + 24))(a1 + 216, a1 + 144, buf);
    *(_DWORD *)uint64_t buf = *(_DWORD *)(a1 + 268) + 1;
    (*(void (**)(uint64_t, uint64_t, unsigned char *))(*(void *)(a1 + 256) + 24))(a1 + 256, a1 + 160, buf);
    *(void *)uint64_t buf = *(void *)(a1 + 280);
    sub_100ABC21C((void *)(a1 + 336), buf);
    double v10 = *(double *)(a1 + 160);
    double v11 = **(double **)(a1 + 352);
    *(double *)long long v69 = v10 - v11;
    if (*(_DWORD *)(a1 + 16) >= 4u)
    {
      uint64_t v12 = *(NSObject **)(a1 + 8);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)uint64_t buf = 134218496;
        *(double *)&uint8_t buf[4] = v10 - v11;
        *(_WORD *)&buf[12] = 2048;
        *(double *)&buf[14] = v10;
        *(_WORD *)&unsigned char buf[22] = 2048;
        double v79 = v11;
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I e(n) = %f, X_RSCP(n) = %f, Y_RSCP(n-1) = %f", buf, 0x20u);
      }
    }
    sub_100ABC21C((void *)(a1 + 376), v69);
    if (*(_DWORD *)(a1 + 16) >= 3u)
    {
      CFTypeID v13 = *(NSObject **)(a1 + 8);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v14 = **(void **)(a1 + 352);
        *(_DWORD *)uint64_t buf = 134218240;
        *(void *)&uint8_t buf[4] = v14;
        *(_WORD *)&buf[12] = 2048;
        *(void *)&buf[14] = 0xC053800000000000;
        _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I Y_RSCP(n-1) = %f, threshold = %f", buf, 0x16u);
        CFTypeID v13 = *(NSObject **)(a1 + 8);
      }
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v15 = *(void *)(a1 + 320);
        if (v15 == *(void *)(a1 + 296)) {
          uint64_t v15 = *(void *)(a1 + 304);
        }
        uint64_t v16 = *(void *)(v15 - 8);
        *(_DWORD *)uint64_t buf = 134218240;
        *(void *)&uint8_t buf[4] = v16;
        *(_WORD *)&buf[12] = 2048;
        *(void *)&buf[14] = 0xC022000000000000;
        _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I Y_EcN0(n-1) = %f, threshold = %f", buf, 0x16u);
      }
    }
    uint64_t v17 = *(void *)(a1 + 400);
    uint64_t v18 = *(void *)(a1 + 376);
    uint64_t v19 = v17;
    if (v17 == v18) {
      uint64_t v19 = *(void *)(a1 + 384);
    }
    if (*(double *)(v19 - 8) < 0.0 || **(double **)(a1 + 352) > -78.0) {
      goto LABEL_30;
    }
    uint64_t v20 = *(void *)(a1 + 320);
    if (v20 == *(void *)(a1 + 296)) {
      uint64_t v20 = *(void *)(a1 + 304);
    }
    if (*(double *)(v20 - 8) <= -9.0)
    {
      if (v17 == v18) {
        uint64_t v17 = *(void *)(a1 + 384);
      }
      double v61 = **(double **)(a1 + 392) + *(double *)(v17 - 8);
      if (*(_DWORD *)(a1 + 16) >= 3u)
      {
        xpc_object_t v62 = *(NSObject **)(a1 + 8);
        if (os_log_type_enabled(v62, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)uint64_t buf = 134218240;
          *(double *)&uint8_t buf[4] = v61;
          *(_WORD *)&buf[12] = 2048;
          *(void *)&buf[14] = 0x4030000000000000;
          _os_log_impl((void *)&_mh_execute_header, v62, OS_LOG_TYPE_DEFAULT, "#I e(n) + e(n - 1) = %f, threshold = %f", buf, 0x16u);
        }
      }
      if (v61 >= 16.0) {
        sub_100B14D6C(a1, 1);
      }
    }
    else
    {
LABEL_30:
      sub_100B14D6C(a1, 0);
      int v64 = 0;
      *(void *)uint64_t buf = 2;
      *(void *)&uint8_t buf[8] = &v64;
      *(void *)&uint8_t buf[16] = a1 + 376;
      sub_100ABC274((void *)(a1 + 376), 2, 2, (uint64_t *)buf);
    }
    if (*(_DWORD *)(a1 + 16) >= 3u)
    {
      long long v21 = *(NSObject **)(a1 + 8);
      if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v22 = *(void *)(a1 + 280);
        *(_DWORD *)uint64_t buf = 134218240;
        *(void *)&uint8_t buf[4] = v22;
        *(_WORD *)&buf[12] = 2048;
        *(void *)&buf[14] = 0xC05B800000000000;
        _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "#I Y_RSCP(n) = %f, threshold = %f", buf, 0x16u);
      }
    }
    *(unsigned char *)(a1 + 417) = *(double *)(a1 + 280) <= -110.0;
    double v23 = 0.015625;
    if (*(unsigned char *)(a1 + 416)) {
      double v23 = 0.375;
    }
    *(double *)(a1 + 208) = v23;
    uint64_t v24 = *(void *)(a1 + 176);
    *(_DWORD *)uint64_t buf = *(_DWORD *)(a1 + 188) + 1;
    (*(void (**)(uint64_t, uint64_t, unsigned char *))(v24 + 24))(a1 + 176, a1 + 128, buf);
    *(void *)uint64_t buf = *(void *)(a1 + 200);
    sub_100ABC21C((void *)(a1 + 296), buf);
    unsigned int v63 = 0;
    if (*(_DWORD *)(a1 + 64))
    {
      double v25 = *(double *)(a1 + 200);
      double v26 = -24.5;
      if (v25 >= -24.5) {
        double v26 = *(double *)(a1 + 200);
      }
      if (v25 <= 0.0) {
        double v27 = v26;
      }
      else {
        double v27 = 0.0;
      }
      double v28 = *(double *)(a1 + 280);
      double v29 = -130.0;
      if (v28 >= -130.0) {
        double v29 = *(double *)(a1 + 280);
      }
      if (v28 <= -25.0) {
        double v30 = v29;
      }
      else {
        double v30 = -25.0;
      }
      double v70 = v30;
      double v71 = v27;
      if (*(_DWORD *)(a1 + 16))
      {
        xpc_object_t v31 = *(NSObject **)(a1 + 8);
        if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)uint64_t buf = 134218240;
          *(double *)&uint8_t buf[4] = v27;
          *(_WORD *)&buf[12] = 2048;
          *(double *)&buf[14] = v30;
          _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "#I Y_EcN0(n) = %f, Y_RSCP(n) = %f", buf, 0x16u);
        }
      }
      if (*(unsigned char *)(a1 + 418))
      {
        if (v27 < -12.0
          || (LODWORD(v64) = 4,
              *(void *)uint64_t buf = &v64,
              v30 <= *((double *)sub_100ABC158((uint64_t **)(a1 + 496), (unsigned int *)&v64, (uint64_t)&unk_10144E20E, (_DWORD **)buf)+ 5)))
        {
          if (v27 < -16.0
            || (LODWORD(v64) = 3,
                *(void *)uint64_t buf = &v64,
                v30 <= *((double *)sub_100ABC158((uint64_t **)(a1 + 496), (unsigned int *)&v64, (uint64_t)&unk_10144E20E, (_DWORD **)buf)+ 5)))
          {
            xpc_object_t v42 = (uint64_t *)(a1 + 504);
            for (unsigned int i = 1; i != 4; ++i)
            {
              uint64_t v43 = *v42;
              xpc_object_t v44 = (uint64_t **)(a1 + 504);
              uint64_t v45 = a1 + 504;
              if (*v42)
              {
                do
                {
                  while (1)
                  {
                    uint64_t v45 = v43;
                    unsigned int v46 = *(_DWORD *)(v43 + 32);
                    if (v46 <= i) {
                      break;
                    }
                    uint64_t v43 = *(void *)v45;
                    xpc_object_t v44 = (uint64_t **)v45;
                    if (!*(void *)v45) {
                      goto LABEL_85;
                    }
                  }
                  if (v46 >= i) {
                    goto LABEL_86;
                  }
                  uint64_t v43 = *(void *)(v45 + 8);
                }
                while (v43);
                xpc_object_t v44 = (uint64_t **)(v45 + 8);
              }
LABEL_85:
              int v47 = operator new(0x30uLL);
              v47[8] = i;
              *((void *)v47 + 5) = 0;
              sub_100046C38((uint64_t **)(a1 + 496), v45, v44, (uint64_t *)v47);
              uint64_t v45 = (uint64_t)v47;
LABEL_86:
              if (v30 <= *(double *)(v45 + 40)) {
                break;
              }
            }
          }
          else
          {
            unsigned int i = 4;
          }
        }
        else
        {
          unsigned int i = 5;
        }
        int v48 = *(NSObject **)(a1 + 8);
        if (os_log_type_enabled(v48, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)uint64_t buf = 67109120;
          *(_DWORD *)&uint8_t buf[4] = i;
          _os_log_impl((void *)&_mh_execute_header, v48, OS_LOG_TYPE_DEFAULT, "#I EcN0 bars %u", buf, 8u);
        }
      }
      else
      {
        sub_100ABC340(v69, a1 + 424);
        *(void *)uint64_t buf = _NSConcreteStackBlock;
        *(void *)&uint8_t buf[8] = 0x40000000;
        *(void *)&uint8_t buf[16] = sub_100B15014;
        double v79 = COERCE_DOUBLE(&unk_101A3ADB8);
        uint64_t v80 = a1;
        *(_DWORD *)(a1 + 520) = sub_100B14E50(v69, &v71, (uint64_t)buf);
        sub_1000346F8((uint64_t)v69, (void *)v69[1]);
        sub_100ABC340(&v76, a1 + 448);
        int v64 = _NSConcreteStackBlock;
        uint64_t v65 = 0x40000000;
        long long v66 = sub_100B15104;
        char v67 = &unk_101A3ADD8;
        uint64_t v68 = a1;
        *(_DWORD *)(a1 + 524) = sub_100B14E50(&v76, &v70, (uint64_t)&v64);
        sub_1000346F8((uint64_t)&v76, v77);
        if (*(_DWORD *)(a1 + 16))
        {
          xpc_object_t v39 = *(NSObject **)(a1 + 8);
          if (os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT))
          {
            int v40 = *(_DWORD *)(a1 + 520);
            int v41 = *(_DWORD *)(a1 + 524);
            *(_DWORD *)uint64_t v72 = 67109376;
            int v73 = v40;
            __int16 v74 = 1024;
            int v75 = v41;
            _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_DEFAULT, "#I EcN0 bars %u, RSCP bars %u", v72, 0xEu);
          }
        }
        if (*(_DWORD *)(a1 + 524) >= *(_DWORD *)(a1 + 520)) {
          unsigned int i = *(_DWORD *)(a1 + 520);
        }
        else {
          unsigned int i = *(_DWORD *)(a1 + 524);
        }
      }
    }
    else
    {
      double v33 = *(double *)(a1 + 240);
      double v34 = -125.0;
      if (v33 >= -125.0) {
        double v34 = *(double *)(a1 + 240);
      }
      if (v33 <= -25.0) {
        double v35 = v34;
      }
      else {
        double v35 = -25.0;
      }
      *(double *)long long v69 = v35;
      if (*(_DWORD *)(a1 + 16))
      {
        xpc_object_t v36 = *(NSObject **)(a1 + 8);
        if (os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)uint64_t buf = 134217984;
          *(double *)&uint8_t buf[4] = v35;
          _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_DEFAULT, "#I Y_RSSI(n) = %f", buf, 0xCu);
        }
      }
      sub_100ABC340((uint64_t *)&v64, a1 + 472);
      *(void *)uint64_t buf = _NSConcreteStackBlock;
      *(void *)&uint8_t buf[8] = 0x40000000;
      *(void *)&uint8_t buf[16] = sub_100B14F18;
      double v79 = COERCE_DOUBLE(&unk_101A3AD98);
      uint64_t v80 = a1;
      *(_DWORD *)(a1 + 528) = sub_100B14E50(&v64, (double *)v69, (uint64_t)buf);
      sub_1000346F8((uint64_t)&v64, (void *)v65);
      if (*(_DWORD *)(a1 + 16))
      {
        xpc_object_t v37 = *(NSObject **)(a1 + 8);
        if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
        {
          int v38 = *(_DWORD *)(a1 + 528);
          LODWORD(v76) = 67109120;
          HIDWORD(v76) = v38;
          _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEFAULT, "#I Bars %u", (uint8_t *)&v76, 8u);
        }
      }
      unsigned int i = *(_DWORD *)(a1 + 528);
    }
    unsigned int v63 = i;
    int v49 = *(unsigned __int8 *)(a1 + 60);
    *(unsigned char *)(a1 + 60) = 0;
    if (v49)
    {
      if (*(_DWORD *)(a1 + 16) >= 2u)
      {
        xpc_object_t v50 = *(NSObject **)(a1 + 8);
        if (os_log_type_enabled(v50, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)uint64_t buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v50, OS_LOG_TYPE_DEFAULT, "#I Jumping instantly", buf, 2u);
        }
      }
      BOOL v51 = 1;
      unsigned int v52 = -1;
LABEL_101:
      if ((sub_100ABC838((_DWORD *)(a1 + 536), &v63, v51, v52) & 1) != 0
        || SignalStrengthModel::shouldForceNotificationOnNextHeartbeat((SignalStrengthModel *)a1))
      {
        LODWORD(v64) = 0;
        sub_100ABA920((unsigned int *)&v64, *(_DWORD *)(a1 + 608));
        SignalStrengthModel::setForceNotificationOnNextHeartbeat((SignalStrengthModel *)a1, 0);
        int v53 = *(NSObject **)(a1 + 8);
        if (os_log_type_enabled(v53, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)uint64_t buf = 67109376;
          *(_DWORD *)&uint8_t buf[4] = v64;
          *(_WORD *)&uint8_t buf[8] = 1024;
          *(_DWORD *)&buf[10] = i;
          _os_log_impl((void *)&_mh_execute_header, v53, OS_LOG_TYPE_DEFAULT, "#I bars changed! old bars %u, new bars %u", buf, 0xEu);
        }
        xpc_object_t v54 = *(std::__shared_weak_count **)(a1 + 96);
        if (v54)
        {
          int v55 = std::__shared_weak_count::lock(v54);
          if (v55)
          {
            unsigned int v56 = v55;
            uint64_t v57 = *(void *)(a1 + 88);
            if (v57)
            {
              unsigned int v58 = *(std::__shared_weak_count **)(a1 + 120);
              if (!v58 || (uint64_t v59 = *(void *)(a1 + 112), (v60 = std::__shared_weak_count::lock(v58)) == 0)) {
                sub_100088B9C();
              }
              *(void *)uint64_t buf = v59;
              *(void *)&uint8_t buf[8] = v60;
              (*(void (**)(uint64_t, unsigned char *))(*(void *)v57 + 24))(v57, buf);
              if (*(void *)&buf[8]) {
                sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
              }
            }
            sub_10004D2C8(v56);
          }
        }
      }
      *(void *)uint64_t buf = 0;
      *(void *)&uint8_t buf[8] = 0;
      operator new();
    }
    if (*(_DWORD *)(a1 + 64))
    {
      if (!*(unsigned char *)(a1 + 61))
      {
        BOOL v51 = *(unsigned char *)(a1 + 417) != 0;
LABEL_100:
        unsigned int v52 = 1;
        goto LABEL_101;
      }
    }
    else if (!*(unsigned char *)(a1 + 61))
    {
      BOOL v51 = 0;
      goto LABEL_100;
    }
    BOOL v51 = *(_DWORD *)(a1 + 612) < i;
    goto LABEL_100;
  }
  return result;
}

void sub_100B14CCC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,std::__shared_weak_count *a32)
{
  if (a32) {
    sub_10004D2C8(a32);
  }
  sub_10004D2C8(v32);
  _Unwind_Resume(a1);
}

void sub_100B14D6C(uint64_t a1, int a2)
{
  int v2 = *(unsigned __int8 *)(a1 + 416);
  if (v2 != a2)
  {
    uint64_t v5 = *(NSObject **)(a1 + 8);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      double v6 = "true";
      if (v2) {
        unsigned int v7 = "true";
      }
      else {
        unsigned int v7 = "false";
      }
      if (!a2) {
        double v6 = "false";
      }
      int v8 = 136315394;
      uint64_t v9 = v7;
      __int16 v10 = 2080;
      double v11 = v6;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Step up going from %s to %s", (uint8_t *)&v8, 0x16u);
    }
    *(unsigned char *)(a1 + 416) = a2;
  }
}

uint64_t sub_100B14E50(void *a1, double *a2, uint64_t a3)
{
  uint64_t v3 = a1 + 1;
  uint64_t v4 = (void *)*a1;
  if ((void *)*a1 == a1 + 1) {
    return 5;
  }
  while (1)
  {
    unsigned int v12 = *((_DWORD *)v4 + 8);
    double v11 = *((double *)v4 + 5);
    (*(void (**)(uint64_t, double *, unsigned int *))(a3 + 16))(a3, &v11, &v12);
    if (*a2 <= v11) {
      break;
    }
    unsigned int v7 = (void *)v4[1];
    if (v7)
    {
      do
      {
        int v8 = v7;
        unsigned int v7 = (void *)*v7;
      }
      while (v7);
    }
    else
    {
      do
      {
        int v8 = (void *)v4[2];
        BOOL v9 = *v8 == (void)v4;
        uint64_t v4 = v8;
      }
      while (!v9);
    }
    uint64_t v4 = v8;
    if (v8 == v3) {
      return 5;
    }
  }
  return v12;
}

void sub_100B14F18(uint64_t a1, double *a2, unsigned int *a3)
{
  uint64_t v3 = *(void *)(a1 + 32);
  double v4 = *a2;
  unsigned int v5 = *a3;
  double v6 = -1.0;
  if (*a3 > 1) {
    double v6 = -2.0;
  }
  unsigned int v7 = *(_DWORD *)(v3 + 528);
  if (v5 >= v7) {
    double v6 = -v6;
  }
  double v8 = v4 + v6;
  *a2 = v4 + v6;
  if (*(_DWORD *)(v3 + 16) >= 0x14u)
  {
    BOOL v9 = *(NSObject **)(v3 + 8);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      int v10 = 134218496;
      double v11 = v8;
      __int16 v12 = 1024;
      unsigned int v13 = v5;
      __int16 v14 = 1024;
      unsigned int v15 = v7;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I iCFIndex n = %f, bars = %u / %u", (uint8_t *)&v10, 0x18u);
    }
  }
}

void sub_100B15014(uint64_t a1, double *a2, unsigned int *a3)
{
  uint64_t v3 = *(void *)(a1 + 32);
  double v4 = *a2;
  unsigned int v5 = *a3;
  unsigned int v6 = *(_DWORD *)(v3 + 520);
  double v7 = 1.0;
  if (*a3 < v6) {
    double v7 = -1.0;
  }
  double v8 = v4 + v7;
  *a2 = v4 + v7;
  if (*(_DWORD *)(v3 + 16) >= 0x14u)
  {
    BOOL v9 = *(NSObject **)(v3 + 8);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      int v10 = 134218496;
      double v11 = v8;
      __int16 v12 = 1024;
      unsigned int v13 = v5;
      __int16 v14 = 1024;
      unsigned int v15 = v6;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I iCFIndex n = %f, bars = %u / %u", (uint8_t *)&v10, 0x18u);
    }
  }
}

void sub_100B15104(uint64_t a1, double *a2, unsigned int *a3)
{
  uint64_t v3 = *(void *)(a1 + 32);
  double v4 = *a2;
  unsigned int v5 = *a3;
  double v6 = -1.0;
  if (*a3 > 1) {
    double v6 = -2.0;
  }
  unsigned int v7 = *(_DWORD *)(v3 + 524);
  if (v5 >= v7) {
    double v6 = -v6;
  }
  double v8 = v4 + v6;
  *a2 = v4 + v6;
  if (*(_DWORD *)(v3 + 16) >= 0x14u)
  {
    BOOL v9 = *(NSObject **)(v3 + 8);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      int v10 = 134218496;
      double v11 = v8;
      __int16 v12 = 1024;
      unsigned int v13 = v5;
      __int16 v14 = 1024;
      unsigned int v15 = v7;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I iCFIndex n = %f, bars = %u / %u", (uint8_t *)&v10, 0x18u);
    }
  }
}

uint64_t sub_100B15200()
{
  return 1000;
}

void sub_100B15208(uint64_t a1, BOOL a2)
{
  SignalStrengthModel::reset((SignalStrengthModel *)a1, a2);
  sub_100B14D6C(a1, 0);
  *(unsigned char *)(a1 + 417) = 0;
  sub_100B13728(a1);
  uint64_t v5 = 0;
  v6[0] = 2;
  v6[1] = (uint64_t)&v5;
  v6[2] = a1 + 376;
  sub_100ABC274((void *)(a1 + 376), 2, 2, v6);
  sub_100B137A4((uint64_t **)a1);
  *(void *)(a1 + 128) = 0xC022000000000000;
  *(unsigned char *)(a1 + 136) = 0;
  *(void *)(a1 + 144) = 0xC05F400000000000;
  *(unsigned char *)(a1 + 152) = 0;
  *(void *)(a1 + 160) = 0xC060400000000000;
  *(unsigned char *)(a1 + 168) = 0;
  *(void *)(a1 + 200) = *(void *)(a1 + 192);
  int v4 = *(_DWORD *)(a1 + 184);
  *(_DWORD *)(a1 + 188) = v4;
  *(void *)(a1 + 240) = *(void *)(a1 + 232);
  *(_DWORD *)(a1 + 228) = *(_DWORD *)(a1 + 224);
  *(void *)(a1 + 280) = *(void *)(a1 + 272);
  *(_DWORD *)(a1 + 268) = *(_DWORD *)(a1 + 264);
  LODWORD(v6[0]) = v4 + 1;
  (*(void (**)(uint64_t, uint64_t, uint64_t *))(*(void *)(a1 + 176) + 24))(a1 + 176, a1 + 128, v6);
  *(void *)(a1 + 520) = 0x100000001;
  *(_DWORD *)(a1 + 528) = 1;
  if (a2)
  {
    *(_DWORD *)(a1 + 608) = *(_DWORD *)(a1 + 612);
    *(_DWORD *)(a1 + 612) = *(_DWORD *)(a1 + 536);
  }
  *(void *)(a1 + 548) = 0;
  sub_100B1354C(*(void *)(a1 + 24), *(std::__shared_weak_count **)(a1 + 32), a1);
}

uint64_t sub_100B15354(uint64_t a1)
{
  return *(unsigned int *)(a1 + 612);
}

void sub_100B1535C(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  operator new();
}

void sub_100B1546C(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(std::__shared_weak_count **)(v1 + 8);
  if (v3) {
    sub_10004D2C8(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100B15484(uint64_t a1)
{
  return *(unsigned int *)(a1 + 616);
}

uint64_t sub_100B1548C(uint64_t a1, void *a2)
{
  id v2 = a2;
  id v3 = [v2 wifiBehavior];
  if (v3 == (id)1) {
    uint64_t v4 = 2;
  }
  else {
    uint64_t v4 = v3 != (id)2;
  }

  return v4;
}

void sub_100B154D0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL sub_100B154E0(uint64_t a1, void *a2, int a3)
{
  BOOL v4 = a3 == 0;
  id v5 = a2;
  double v6 = v5;
  if (a3 == 2) {
    uint64_t v7 = 1;
  }
  else {
    uint64_t v7 = 2 * v4;
  }
  id v8 = [v5 wifiBehavior];
  if (v8 != (id)v7) {
    [v6 setWifiBehavior:v7];
  }

  return v8 != (id)v7;
}

void sub_100B15550(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_100B15560(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 8)) {
    return 2;
  }
  else {
    return byte_101B13ED8;
  }
}

uint64_t sub_100B15580(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
  uint64_t v5 = (*(uint64_t (**)(uint64_t, id, uint64_t))(*(void *)a1 + 8))(a1, v3, v4);

  return v5;
}

void sub_100B1560C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL sub_100B1561C(uint64_t a1, int a2)
{
  return a2 == 2;
}

void sub_100B1562C()
{
}

void sub_100B15640()
{
}

void sub_100B1568C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_100B156A4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5 = *(std::__shared_weak_count **)(a5 + 8);
  double v6 = v5;
  if (v5) {
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  ctu::Http::HttpRequest::create();
  if (v6) {
    sub_10004D2C8(v6);
  }
}

void sub_100B15704(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_100B15720(HttpRequestFactoryInterface *a1)
{
  HttpRequestFactoryInterface::~HttpRequestFactoryInterface(a1);

  operator delete();
}

const char *sub_100B15758(int a1)
{
  if ((a1 - 1) > 0x17) {
    return "kInitializeController";
  }
  else {
    return off_101A3AEE8[a1 - 1];
  }
}

uint64_t sub_100B15784(uint64_t a1)
{
  pthread_mutex_lock((pthread_mutex_t *)a1);
  id v2 = *(std::__shared_weak_count **)(a1 + 72);
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 72) = 0;
  pthread_mutex_unlock((pthread_mutex_t *)a1);
  if (v2) {
    sub_10004D2C8(v2);
  }
  id v3 = *(std::__shared_weak_count **)(a1 + 72);
  if (v3) {
    sub_10004D2C8(v3);
  }
  return a1;
}

uint64_t sub_100B157DC()
{
  if ((byte_101B0B120 & 1) == 0)
  {
    byte_101B0B120 = 1;
    return __cxa_atexit((void (*)(void *))sub_100B15780, &unk_101B0B0D0, (void *)&_mh_execute_header);
  }
  return result;
}

uint64_t sub_100B15818()
{
  __cxa_atexit((void (*)(void *))&std::string::~string, &unk_101B10168, (void *)&_mh_execute_header);

  return __cxa_atexit((void (*)(void *))&std::string::~string, &unk_101B10180, (void *)&_mh_execute_header);
}

uint64_t sub_100B15888(uint64_t a1, void *a2, NSObject **a3, uint64_t a4)
{
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v11, kCtLoggingSystemName, "em.searcher");
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  id v8 = *a3;
  *(void *)(a1 + 24) = *a3;
  if (v8) {
    dispatch_retain(v8);
  }
  *(void *)(a1 + 32) = 0;
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v12, &v11);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 40), (const ctu::OsLogLogger *)v12);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v12);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v11);
  *(void *)a1 = off_101A3AFB8;
  *(void *)(a1 + 72) = 0;
  *(void *)(a1 + 104) = 0;
  *(unsigned char *)(a1 + 112) = 0;
  *(unsigned char *)(a1 + 120) = 0;
  *(_WORD *)(a1 + 124) = 0;
  *(void *)(a1 + 128) = *a2;
  uint64_t v9 = a2[1];
  *(void *)(a1 + 136) = v9;
  if (v9) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v9 + 8), 1uLL, memory_order_relaxed);
  }
  *(void *)(a1 + 144) = a4;
  *(void *)(a1 + 152) = 0;
  return a1;
}

void sub_100B15984(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v4 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)va1);
  sub_100087E88(v2);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)va);
  _Unwind_Resume(a1);
}

void *sub_100B159B0(void *a1)
{
  sub_100B1601C((uint64_t)a1, (void (*)(_OWORD *__return_ptr, void *))sub_100B161E0);
  uint64_t v2 = a1[19];
  a1[19] = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  id v3 = (std::__shared_weak_count *)a1[17];
  if (v3) {
    sub_10004D2C8(v3);
  }
  sub_10035D6A8(a1 + 10);
  sub_10003B34C(a1 + 6);
  emergency::Searcher::~Searcher((emergency::Searcher *)a1);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 5));
  sub_100087E88(a1 + 1);
  return a1;
}

void *sub_100B15A58(uint64_t a1)
{
  return sub_100B1601C(a1, (void (*)(_OWORD *__return_ptr, void *))sub_100B161E0);
}

void sub_100B15A70(void *a1)
{
  sub_100B159B0(a1);

  operator delete();
}

void *sub_100B15AA8(uint64_t a1, uint64_t a2, char a3, char a4, uint64_t a5, uint64_t a6)
{
  long long v22 = 0u;
  long long v23 = 0u;
  long long v21 = 0u;
  memset(v20, 0, sizeof(v20));
  memset(v19, 0, sizeof(v19));
  __int16 v12 = (void *)(a1 + 48);
  sub_1000F0058((uint64_t)v16, a1 + 48);
  sub_10035E960((uint64_t)v17, a1 + 80);
  v18[0] = *(void *)(a1 + 112);
  *(void *)((char *)v18 + 6) = *(void *)(a1 + 118);
  sub_10035E960((uint64_t)v15, a5);
  sub_1000F0058((uint64_t)v14, a6);
  sub_100B15CFC((uint64_t)v16, a2, a3, a4, (uint64_t)v15, (uint64_t)v14, v19);
  sub_10003B34C(v14);
  sub_10035D6A8(v15);
  sub_10035D6A8(v17);
  sub_10003B34C(v16);
  sub_1003351AC(v12, (uint64_t)v19);
  sub_10035C138((void *)(a1 + 80), (uint64_t)v20);
  if (*(unsigned __int8 *)(a1 + 120) == BYTE8(v21))
  {
    if (*(unsigned char *)(a1 + 120))
    {
      *(unsigned char *)(a1 + 112) = v21;
      *(_DWORD *)(a1 + 116) = DWORD1(v21);
    }
  }
  else if (*(unsigned char *)(a1 + 120))
  {
    *(unsigned char *)(a1 + 120) = 0;
  }
  else
  {
    *(void *)(a1 + 112) = v21;
    *(unsigned char *)(a1 + 120) = 1;
  }
  *(_WORD *)(a1 + 124) = WORD6(v21);
  if (*((void *)&v23 + 1)) {
    (*(void (**)(void, uint64_t))(**((void **)&v23 + 1) + 48))(*((void *)&v23 + 1), a1);
  }
  sub_100B17934(&v22);
  sub_10035D6A8(v20);
  return sub_10003B34C(v19);
}

void sub_100B15C8C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17)
{
  sub_10003B34C(&a9);
  sub_10035D6A8(&a13);
  sub_10035D6A8(v17);
  sub_10003B34C(&a17);
  _Unwind_Resume(a1);
}

void sub_100B15CFC(uint64_t a1@<X0>, uint64_t a2@<X1>, char a3@<W2>, char a4@<W3>, uint64_t a5@<X4>, uint64_t a6@<X5>, void *a7@<X8>)
{
  int v10 = (void *)(a1 + 64);
  if (*(unsigned char *)(a1 + 72))
  {
    uint64_t v18 = 0;
    *(_OWORD *)uint64_t v16 = 0u;
    long long v17 = 0u;
    sub_10035E960((uint64_t)v16, a5);
    uint64_t v18 = *(void *)(a1 + 64);
    if (*(unsigned char *)(a1 + 72)) {
      *(unsigned char *)(a1 + 72) = 0;
    }
    sub_1000F0058((uint64_t)a7, a1);
    sub_10035E960((uint64_t)(a7 + 4), a1 + 32);
    a7[8] = *v10;
    *(void *)((char *)a7 + 70) = *(void *)((char *)v10 + 6);
    sub_10035E960((uint64_t)&__p, (uint64_t)v16);
    uint64_t v23 = v18;
    a7[13] = 0;
    OsLogContext v11 = operator new(0x30uLL);
    void *v11 = off_101A3B0C0;
    sub_100B168E0((uint64_t)(v11 + 1), (uint64_t)&__p);
    v11[5] = v23;
    a7[13] = v11;
    sub_10035D6A8(&__p);
    sub_10035D6A8(v16);
  }
  else
  {
    *(_OWORD *)uint64_t v16 = 0u;
    long long v17 = 0u;
    sub_10035D43C(v16, *(const void **)a2, *(void *)(a2 + 8), (uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 2);
    BYTE8(v17) = a3;
    BYTE9(v17) = a4;
    BYTE10(v17) = *(void *)(a6 + 24) != 0;
    BYTE11(v17) = *(unsigned char *)(a1 + 76) ^ 1;
    sub_10035C138((void *)(a1 + 32), a5);
    sub_1003351AC((void *)a1, a6);
    *(_WORD *)(a1 + 76) = 257;
    sub_1000F0058((uint64_t)a7, a1);
    sub_10035E960((uint64_t)(a7 + 4), a1 + 32);
    a7[8] = *v10;
    *(void *)((char *)a7 + 70) = *(void *)((char *)v10 + 6);
    uint64_t v20 = 0;
    uint64_t v21 = 0;
    std::string __p = 0;
    sub_10035D43C(&__p, v16[0], (uint64_t)v16[1], ((char *)v16[1] - (char *)v16[0]) >> 2);
    int v22 = DWORD2(v17);
    a7[13] = 0;
    unsigned int v15 = operator new(0x28uLL);
    void *v15 = off_101A3B150;
    v15[2] = 0;
    v15[3] = 0;
    v15[1] = 0;
    sub_10035D43C(v15 + 1, __p, (uint64_t)v20, (v20 - (unsigned char *)__p) >> 2);
    *((_DWORD *)v15 + 8) = v22;
    a7[13] = v15;
    if (__p)
    {
      uint64_t v20 = __p;
      operator delete(__p);
    }
    if (v16[0])
    {
      v16[1] = v16[0];
      operator delete(v16[0]);
    }
  }
}

void sub_100B15F70(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  operator delete(v18);
  if (__p) {
    operator delete(__p);
  }
  sub_10035D6A8(v17);
  sub_10003B34C(v16);
  if (a9) {
    operator delete(a9);
  }
  _Unwind_Resume(a1);
}

void *sub_100B1601C(uint64_t a1, void (*a2)(_OWORD *__return_ptr, void *))
{
  long long v12 = 0u;
  long long v13 = 0u;
  long long v11 = 0u;
  memset(v10, 0, sizeof(v10));
  memset(v9, 0, sizeof(v9));
  uint64_t v4 = (void *)(a1 + 48);
  sub_1000F0058((uint64_t)v6, a1 + 48);
  sub_10035E960((uint64_t)v7, a1 + 80);
  v8[0] = *(void *)(a1 + 112);
  *(void *)((char *)v8 + 6) = *(void *)(a1 + 118);
  a2(v9, v6);
  sub_10035D6A8(v7);
  sub_10003B34C(v6);
  sub_1003351AC(v4, (uint64_t)v9);
  sub_10035C138((void *)(a1 + 80), (uint64_t)v10);
  if (*(unsigned __int8 *)(a1 + 120) == BYTE8(v11))
  {
    if (*(unsigned char *)(a1 + 120))
    {
      *(unsigned char *)(a1 + 112) = v11;
      *(_DWORD *)(a1 + 116) = DWORD1(v11);
    }
  }
  else if (*(unsigned char *)(a1 + 120))
  {
    *(unsigned char *)(a1 + 120) = 0;
  }
  else
  {
    *(void *)(a1 + 112) = v11;
    *(unsigned char *)(a1 + 120) = 1;
  }
  *(_WORD *)(a1 + 124) = WORD6(v11);
  if (*((void *)&v13 + 1)) {
    (*(void (**)(void, uint64_t))(**((void **)&v13 + 1) + 48))(*((void *)&v13 + 1), a1);
  }
  sub_100B17934(&v12);
  sub_10035D6A8(v10);
  return sub_10003B34C(v9);
}

void sub_100B161A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  sub_10035D6A8(v9);
  sub_10003B34C(&a9);
  _Unwind_Resume(a1);
}

void *sub_100B161E0@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  char v3 = *(unsigned char *)(a1 + 77);
  long long v7 = 0u;
  memset(v6, 0, sizeof(v6));
  memset(v5, 0, sizeof(v5));
  sub_1000DA470(a2, (uint64_t)v5);
  sub_100B168E0(a2 + 32, (uint64_t)v6);
  *(void *)(a2 + 64) = v7;
  *(void *)(a2 + 70) = *(void *)((char *)&v7 + 6);
  *(void *)(a2 + 80) = off_101A3B1D0;
  *(unsigned char *)(a2 + 88) = v3;
  *(void *)(a2 + 104) = a2 + 80;
  sub_10035D6A8(v6);
  return sub_10003B34C(v5);
}

void *sub_100B162B8@<X0>(uint64_t a1@<X0>, unsigned int a2@<W1>, uint64_t a3@<X2>, void *a4@<X8>)
{
  uint64_t v13 = 0;
  memset(v12, 0, sizeof(v12));
  LOBYTE(v12[0]) = a2;
  DWORD1(v12[0]) = a3;
  id v8 = (void *)(a1 + 32);
  sub_10035E960((uint64_t)v12 + 8, a1 + 32);
  if (!*(void *)(a1 + 56))
  {
    if (*(unsigned char *)(a1 + 72))
    {
      *(unsigned char *)(a1 + 64) = a2;
      *(_DWORD *)(a1 + 68) = a3;
    }
    else
    {
      *(void *)(a1 + 64) = a2 | (unint64_t)(a3 << 32);
      *(unsigned char *)(a1 + 72) = 1;
    }
  }
  sub_10035E8D8(v8);
  sub_1003355AC((void *)a1);
  *(unsigned char *)(a1 + 76) = 0;
  sub_1000F0058((uint64_t)a4, a1);
  sub_10035E960((uint64_t)(a4 + 4), (uint64_t)v8);
  a4[8] = *(void *)(a1 + 64);
  *(void *)((char *)a4 + 70) = *(void *)(a1 + 70);
  uint64_t v14 = *(void *)&v12[0];
  sub_10035E960((uint64_t)v15, (uint64_t)v12 + 8);
  a4[13] = 0;
  uint64_t v9 = operator new(0x30uLL);
  uint64_t v10 = v14;
  void *v9 = off_101A3B250;
  v9[1] = v10;
  sub_100B168E0((uint64_t)(v9 + 2), (uint64_t)v15);
  a4[13] = v9;
  sub_10035D6A8(v15);
  return sub_10035D6A8((void *)v12 + 1);
}

void sub_100B16434(_Unwind_Exception *a1)
{
  sub_10035D6A8(v3);
  sub_10035D6A8(v4);
  sub_10003B34C(v2);
  sub_10035D6A8(v1);
  _Unwind_Resume(a1);
}

void *sub_100B16480@<X0>(void *a1@<X0>, void *a2@<X8>)
{
  memset(v7, 0, sizeof(v7));
  sub_1000F0058((uint64_t)v7, (uint64_t)a1);
  memset(v6, 0, sizeof(v6));
  sub_1000F0058((uint64_t)v6, (uint64_t)a1);
  sub_10035E8D8(a1 + 4);
  sub_1003355AC(a1);
  sub_1000F0058((uint64_t)a2, (uint64_t)a1);
  sub_10035E960((uint64_t)(a2 + 4), (uint64_t)(a1 + 4));
  a2[8] = a1[8];
  *(void *)((char *)a2 + 70) = *(void *)((char *)a1 + 70);
  sub_1000F0058((uint64_t)v8, (uint64_t)v6);
  a2[13] = 0;
  uint64_t v4 = operator new(0x28uLL);
  *uint64_t v4 = off_101A3B2D0;
  sub_1000DA470((uint64_t)(v4 + 1), (uint64_t)v8);
  a2[13] = v4;
  sub_10003B34C(v8);
  sub_10003B34C(v6);
  return sub_10003B34C(v7);
}

void sub_100B165AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18)
{
  sub_10003B34C(&a18);
  sub_10035D6A8(v19);
  sub_10003B34C(v18);
  sub_10003B34C(&a9);
  sub_10003B34C(&a13);
  _Unwind_Resume(a1);
}

void sub_100B16600()
{
}

void sub_100B16608(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 40);
  if (v2)
  {
    char v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      uint64_t v4 = v3;
      uint64_t v5 = *(void *)(a1 + 32);
      if (v5) {
        sub_100B1601C(v5, (void (*)(_OWORD *__return_ptr, void *))sub_100B16480);
      }
      sub_10004D2C8(v4);
    }
  }
}

void sub_100B16678(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100B1668C(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100B166A8(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void *sub_100B166B8(void *a1)
{
  *a1 = off_101A3B0C0;
  sub_10035D6A8(a1 + 1);
  return a1;
}

void sub_100B166FC(void *a1)
{
  *a1 = off_101A3B0C0;
  sub_10035D6A8(a1 + 1);

  operator delete();
}

void *sub_100B16760(uint64_t a1)
{
  uint64_t v2 = a1 + 8;
  char v3 = operator new(0x30uLL);
  void *v3 = off_101A3B0C0;
  sub_10035E960((uint64_t)(v3 + 1), v2);
  v3[5] = *(void *)(a1 + 40);
  return v3;
}

void sub_100B167C8(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100B167DC(uint64_t a1, void *a2)
{
  *a2 = off_101A3B0C0;
  uint64_t result = sub_10035E960((uint64_t)(a2 + 1), a1 + 8);
  a2[5] = *(void *)(a1 + 40);
  return result;
}

void *sub_100B16830(uint64_t a1)
{
  return sub_10035D6A8((void *)(a1 + 8));
}

void sub_100B16838(void *a1)
{
  sub_10035D6A8(a1 + 1);

  operator delete(a1);
}

uint64_t sub_100B16874(uint64_t result)
{
  if (*(void *)(result + 32)) {
    return sub_10035D3E0(result + 8, *(unsigned char *)(result + 40), *(_DWORD *)(result + 44));
  }
  return result;
}

uint64_t sub_100B16894(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100B168D4()
{
}

uint64_t sub_100B168E0(uint64_t a1, uint64_t a2)
{
  char v3 = (void *)(a2 + 24);
  uint64_t v4 = *(void *)(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(*(void *)*v3 + 24))(*v3, a1);
      return a1;
    }
    *(void *)(a1 + 24) = v4;
  }
  else
  {
    char v3 = (void *)(a1 + 24);
  }
  void *v3 = 0;
  return a1;
}

void *sub_100B16960(void *a1)
{
  *a1 = off_101A3B150;
  uint64_t v2 = (void *)a1[1];
  if (v2)
  {
    a1[2] = v2;
    operator delete(v2);
  }
  return a1;
}

void sub_100B169B0(void *a1)
{
  *a1 = off_101A3B150;
  uint64_t v2 = (void *)a1[1];
  if (v2)
  {
    a1[2] = v2;
    operator delete(v2);
  }

  operator delete();
}

void *sub_100B16A20(uint64_t a1)
{
  uint64_t v2 = operator new(0x28uLL);
  void *v2 = off_101A3B150;
  v2[2] = 0;
  v2[3] = 0;
  v2[1] = 0;
  sub_10035D43C(v2 + 1, *(const void **)(a1 + 8), *(void *)(a1 + 16), (uint64_t)(*(void *)(a1 + 16) - *(void *)(a1 + 8)) >> 2);
  *((_DWORD *)v2 + 8) = *(_DWORD *)(a1 + 32);
  return v2;
}

void sub_100B16A8C(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_100B16AA0(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A3B150;
  *(void *)(a2 + 16) = 0;
  *(void *)(a2 + 24) = 0;
  *(void *)(a2 + 8) = 0;
  uint64_t result = sub_10035D43C((void *)(a2 + 8), *(const void **)(a1 + 8), *(void *)(a1 + 16), (uint64_t)(*(void *)(a1 + 16) - *(void *)(a1 + 8)) >> 2);
  *(_DWORD *)(a2 + 32) = *(_DWORD *)(a1 + 32);
  return result;
}

void sub_100B16B04(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 8);
  if (v2)
  {
    *(void *)(a1 + 16) = v2;
    operator delete(v2);
  }
}

void sub_100B16B1C(void *__p)
{
  uint64_t v2 = (void *)__p[1];
  if (v2)
  {
    __p[2] = v2;
    operator delete(v2);
  }

  operator delete(__p);
}

void sub_100B16B60(unsigned __int8 *a1, uint64_t a2)
{
  uint64_t v4 = (uint64_t *)a1[34];
  if (!a1[34]) {
    goto LABEL_46;
  }
  uint64_t v42 = 0;
  std::string __p = 0;
  int v40 = 0;
  ServiceMap = (std::mutex *)Registry::getServiceMap(v4, *(Registry **)(a2 + 128));
  uint64_t v6 = ServiceMap;
  if (v7 < 0)
  {
    id v8 = (unsigned __int8 *)(v7 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v9 = 5381;
    do
    {
      uint64_t v7 = v9;
      unsigned int v10 = *v8++;
      uint64_t v9 = (33 * v9) ^ v10;
    }
    while (v10);
  }
  std::mutex::lock(ServiceMap);
  CFTypeRef cf = (CFTypeRef)v7;
  long long v11 = sub_10004D37C(&v6[1].__m_.__sig, (unint64_t *)&cf);
  if (v11)
  {
    uint64_t v13 = v11[3];
    long long v12 = (std::__shared_weak_count *)v11[4];
    if (v12)
    {
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v6);
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v12);
      char v14 = 0;
      goto LABEL_10;
    }
  }
  else
  {
    uint64_t v13 = 0;
  }
  std::mutex::unlock(v6);
  long long v12 = 0;
  char v14 = 1;
LABEL_10:
  PersonalityIdFromSlotIdEx();
  (*(void (**)(void **__return_ptr, uint64_t, CFTypeRef *))(*(void *)v13 + 40))(&__p, v13, &cf);
  if (SHIBYTE(v47) < 0)
  {
    operator delete((void *)cf);
    if (v14) {
      goto LABEL_13;
    }
    goto LABEL_12;
  }
  if ((v14 & 1) == 0) {
LABEL_12:
  }
    sub_10004D2C8(v12);
LABEL_13:
  if (__p)
  {
    CFTypeRef cf = 0;
    (*(void (**)(CFTypeRef *__return_ptr))(*(void *)__p + 40))(&cf);
    unsigned int v15 = (int *)cf;
    if (cf) {
      uint64_t v16 = sub_100080934;
    }
    else {
      uint64_t v16 = 0;
    }
    int v17 = 20;
    if (v16)
    {
      LODWORD(v44) = 20;
      if (cf)
      {
        CFTypeID v18 = CFGetTypeID(cf);
        if (v18 == CFNumberGetTypeID())
        {
          ctu::cf::assign((ctu::cf *)&v44, v15, v19);
          int v17 = v44;
        }
        else
        {
          int v17 = 20;
        }
      }
    }
    sub_1000577C4(&cf);
  }
  else
  {
    int v17 = 20;
  }
  if (v40) {
    sub_10004D2C8(v40);
  }
  sub_1000577C4((const void **)&v42);
  uint64_t v20 = *(std::__shared_weak_count **)(a2 + 16);
  if (!v20 || (uint64_t v21 = *(void *)(a2 + 8), (v22 = std::__shared_weak_count::lock(v20)) == 0)) {
    sub_100088B9C();
  }
  uint64_t v23 = v22;
  atomic_fetch_add_explicit(&v22->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v22);
  Registry::getTimerService(&v42, *(Registry **)(a2 + 128));
  uint64_t v24 = v42;
  sub_100058DB0(&__p, "EmergencyPhoneSearcher");
  double v25 = *(NSObject **)(a2 + 24);
  dispatch_object_t object = v25;
  if (v25) {
    dispatch_retain(v25);
  }
  CFTypeRef cf = _NSConcreteStackBlock;
  uint64_t v46 = 1174405120;
  int v47 = sub_100B16608;
  p_CFTypeRef cf = (CFTypeRef *)&unk_101A3AFD8;
  uint64_t v49 = v21;
  xpc_object_t v50 = v23;
  atomic_fetch_add_explicit(&v23->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  aBlocuint64_t k = _Block_copy(&cf);
  sub_100118A44(v24, (uint64_t)&__p, 1, 1000000 * v17, &object, &aBlock);
  uint64_t v26 = v44;
  uint64_t v44 = 0;
  uint64_t v27 = *(void *)(a2 + 152);
  *(void *)(a2 + 152) = v26;
  if (v27)
  {
    (*(void (**)(uint64_t))(*(void *)v27 + 8))(v27);
    uint64_t v28 = v44;
    uint64_t v44 = 0;
    if (v28) {
      (*(void (**)(uint64_t))(*(void *)v28 + 8))(v28);
    }
  }
  if (aBlock) {
    _Block_release(aBlock);
  }
  if (object) {
    dispatch_release(object);
  }
  if (v41 < 0) {
    operator delete(__p);
  }
  if (v43) {
    sub_10004D2C8(v43);
  }
  if (v50) {
    std::__shared_weak_count::__release_weak(v50);
  }
  std::__shared_weak_count::__release_weak(v23);
LABEL_46:
  if (a1[35])
  {
    double v29 = *(std::__shared_weak_count **)(a2 + 16);
    if (!v29
      || (int v30 = a1[32], v31 = a1[33], v32 = *(void *)(a2 + 8), (v33 = std::__shared_weak_count::lock(v29)) == 0))
    {
      sub_100088B9C();
    }
    double v34 = v33;
    p_shared_weak_owners = &v33->__shared_weak_owners_;
    atomic_fetch_add_explicit(&v33->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v33);
    uint64_t v36 = *(void *)(a2 + 144);
    atomic_fetch_add_explicit(p_shared_weak_owners, 1uLL, memory_order_relaxed);
    CFTypeRef cf = off_101A3B3A0;
    uint64_t v46 = v32;
    int v47 = (void (*)(uint64_t))v34;
    p_CFTypeRef cf = &cf;
    (*(void (**)(uint64_t, unsigned __int8 *, BOOL, BOOL, CFTypeRef *))(*(void *)v36 + 32))(v36, a1 + 8, v30 != 0, v31 != 0, &cf);
    sub_10035D6A8(&cf);
    std::__shared_weak_count::__release_weak(v34);
  }
}

void sub_100B1700C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *aBlock, dispatch_object_t object, void *__p, std::__shared_weak_count *a13, int a14, __int16 a15, char a16, char a17, const void *a18, uint64_t a19, uint64_t a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,uint64_t a27,uint64_t a28,std::__shared_weak_count *a29)
{
  if (a13) {
    sub_10004D2C8(a13);
  }
  sub_1000577C4(&a18);
  _Unwind_Resume(a1);
}

uint64_t sub_100B17104(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100B17144()
{
}

void sub_100B17154()
{
}

unsigned char *sub_100B17168(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  *(void *)uint64_t result = off_101A3B1D0;
  result[8] = *(unsigned char *)(a1 + 8);
  return result;
}

uint64_t sub_100B171B4(uint64_t result, uint64_t a2)
{
  *(void *)a2 = off_101A3B1D0;
  *(unsigned char *)(a2 + 8) = *(unsigned char *)(result + 8);
  return result;
}

uint64_t sub_100B171E4(uint64_t a1, uint64_t a2)
{
  uint64_t result = *(void *)(a2 + 152);
  if (result)
  {
    *(void *)(a2 + 152) = 0;
    uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
  }
  if (*(unsigned char *)(a1 + 8))
  {
    uint64_t v5 = *(uint64_t (**)(void))(**(void **)(a2 + 144) + 40);
    return v5();
  }
  return result;
}

uint64_t sub_100B17280(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100B172C0()
{
}

void *sub_100B172CC(void *a1)
{
  *a1 = off_101A3B250;
  sub_10035D6A8(a1 + 2);
  return a1;
}

void sub_100B17310(void *a1)
{
  *a1 = off_101A3B250;
  sub_10035D6A8(a1 + 2);

  operator delete();
}

void *sub_100B17374(uint64_t a1)
{
  uint64_t v2 = operator new(0x30uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *v2 = off_101A3B250;
  v2[1] = v3;
  sub_10035E960((uint64_t)(v2 + 2), a1 + 16);
  return v2;
}

void sub_100B173CC(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100B173E0(uint64_t a1, void *a2)
{
  *a2 = off_101A3B250;
  a2[1] = *(void *)(a1 + 8);
  return sub_10035E960((uint64_t)(a2 + 2), a1 + 16);
}

void *sub_100B17414(uint64_t a1)
{
  return sub_10035D6A8((void *)(a1 + 16));
}

void sub_100B1741C(void *a1)
{
  sub_10035D6A8(a1 + 2);

  operator delete(a1);
}

uint64_t sub_100B17458(uint64_t a1, uint64_t a2)
{
  uint64_t result = *(void *)(a2 + 152);
  if (result)
  {
    *(void *)(a2 + 152) = 0;
    uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
  }
  if (*(void *)(a1 + 40))
  {
    char v4 = *(unsigned char *)(a1 + 8);
    int v5 = *(_DWORD *)(a1 + 12);
    return sub_10035D3E0(a1 + 16, v4, v5);
  }
  return result;
}

uint64_t sub_100B174D8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100B17518()
{
}

void *sub_100B17524(void *a1)
{
  *a1 = off_101A3B2D0;
  sub_10003B34C(a1 + 1);
  return a1;
}

void sub_100B17568(void *a1)
{
  *a1 = off_101A3B2D0;
  sub_10003B34C(a1 + 1);

  operator delete();
}

void *sub_100B175CC(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t v2 = operator new(0x28uLL);
  void *v2 = off_101A3B2D0;
  sub_1000F0058((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_100B17620(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100B17634(uint64_t a1, void *a2)
{
  *a2 = off_101A3B2D0;
  return sub_1000F0058((uint64_t)(a2 + 1), a1 + 8);
}

void *sub_100B17660(uint64_t a1)
{
  return sub_10003B34C((void *)(a1 + 8));
}

void sub_100B17668(void *a1)
{
  sub_10003B34C(a1 + 1);

  operator delete(a1);
}

uint64_t sub_100B176A4(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 152);
  if (v3)
  {
    *(void *)(a2 + 152) = 0;
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  uint64_t result = *(void *)(a1 + 32);
  if (result)
  {
    int v5 = *(uint64_t (**)(void))(*(void *)result + 48);
    return v5();
  }
  return result;
}

uint64_t sub_100B17738(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100B17778()
{
}

void sub_100B17784(void *a1@<X1>, NSObject **a2@<X2>, uint64_t *a3@<X3>, void *a4@<X8>)
{
  id v8 = operator new(0xB8uLL);
  sub_100B17810(v8, a1, a2, a3);
  *a4 = v8 + 3;
  a4[1] = v8;

  sub_1000B3BC8((uint64_t)a4, v8 + 4, (uint64_t)(v8 + 3));
}

void sub_100B177FC(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_100B17810(void *a1, void *a2, NSObject **a3, uint64_t *a4)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = off_101A3B350;
  sub_100B15888((uint64_t)(a1 + 3), a2, a3, *a4);
  return a1;
}

void sub_100B1785C(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void sub_100B17870(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A3B350;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100B17890(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A3B350;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void *sub_100B178E4(uint64_t a1)
{
  return sub_100B159B0((void *)(a1 + 24));
}

void *sub_100B178F0(void *a1)
{
  sub_100B17934(a1 + 10);
  sub_10035D6A8(a1 + 4);

  return sub_10003B34C(a1);
}

void *sub_100B17934(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *sub_100B179B8(void *a1)
{
  *a1 = off_101A3B3A0;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_100B17A04(void *a1)
{
  *a1 = off_101A3B3A0;
  uint64_t v1 = (std::__shared_weak_count *)a1[2];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

void *sub_100B17A70(uint64_t a1)
{
  uint64_t result = operator new(0x18uLL);
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 16);
  *uint64_t result = off_101A3B3A0;
  result[1] = v4;
  result[2] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_100B17ACC(uint64_t result, void *a2)
{
  uint64_t v3 = *(void *)(result + 8);
  uint64_t v2 = *(void *)(result + 16);
  *a2 = off_101A3B3A0;
  a2[1] = v3;
  a2[2] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100B17B04(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_100B17B14(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[2];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete(__p);
}

void sub_100B17B54(uint64_t a1, unsigned __int8 *a2, unsigned int *a3)
{
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4)
  {
    int v5 = *a2;
    uint64_t v6 = *a3;
    uint64_t v7 = std::__shared_weak_count::lock(v4);
    if (v7)
    {
      id v8 = v7;
      uint64_t v9 = *(void *)(a1 + 8);
      if (v9)
      {
        unsigned int v10 = *(NSObject **)(v9 + 40);
        if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v11 = subscriber::asString();
          long long v12 = "succeed";
          if (!v5) {
            long long v12 = "failed";
          }
          LODWORD(buf[0]) = 136315394;
          *(void *)((char *)buf + 4) = v11;
          WORD2(buf[1]) = 2080;
          *(void *)((char *)&buf[1] + 6) = v12;
          _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I search done on %s: %s", (uint8_t *)buf, 0x16u);
        }
        long long v19 = 0u;
        long long v20 = 0u;
        long long v18 = 0u;
        memset(v17, 0, sizeof(v17));
        memset(buf, 0, sizeof(buf));
        sub_1000F0058((uint64_t)v13, v9 + 48);
        sub_10035E960((uint64_t)v14, v9 + 80);
        v15[0] = *(void *)(v9 + 112);
        *(void *)((char *)v15 + 6) = *(void *)(v9 + 118);
        sub_100B162B8((uint64_t)v13, v5 != 0, v6, buf);
        sub_10035D6A8(v14);
        sub_10003B34C(v13);
        sub_1003351AC((void *)(v9 + 48), (uint64_t)buf);
        sub_10035C138((void *)(v9 + 80), (uint64_t)v17);
        if (*(unsigned __int8 *)(v9 + 120) == BYTE8(v18))
        {
          if (*(unsigned char *)(v9 + 120))
          {
            *(unsigned char *)(v9 + 112) = v18;
            *(_DWORD *)(v9 + 116) = DWORD1(v18);
          }
        }
        else if (*(unsigned char *)(v9 + 120))
        {
          *(unsigned char *)(v9 + 120) = 0;
        }
        else
        {
          *(void *)(v9 + 112) = v18;
          *(unsigned char *)(v9 + 120) = 1;
        }
        *(_WORD *)(v9 + 124) = WORD6(v18);
        if (*((void *)&v20 + 1)) {
          (*(void (**)(void, uint64_t))(**((void **)&v20 + 1) + 48))(*((void *)&v20 + 1), v9);
        }
        sub_100B17934(&v19);
        sub_10035D6A8(v17);
        sub_10003B34C(buf);
      }
      sub_10004D2C8(v8);
    }
  }
}

void sub_100B17D8C(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100B17DD4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100B17E14()
{
}

uint64_t sub_100B17E20(uint64_t a1, int a2, void *a3, long long *a4, void *a5, void *a6, long long *a7, long long *a8)
{
  *(_DWORD *)a1 = a2;
  uint64_t v13 = a3[1];
  *(void *)(a1 + 8) = *a3;
  *(void *)(a1 + 16) = v13;
  if (v13) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v13 + 8), 1uLL, memory_order_relaxed);
  }
  if (*((char *)a4 + 23) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 24), *(void **)a4, *((void *)a4 + 1));
  }
  else
  {
    long long v14 = *a4;
    *(void *)(a1 + 40) = *((void *)a4 + 2);
    *(_OWORD *)(a1 + 24) = v14;
  }
  uint64_t v15 = a5[1];
  *(void *)(a1 + 48) = *a5;
  *(void *)(a1 + 56) = v15;
  if (v15) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v15 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v16 = a6[1];
  *(void *)(a1 + 64) = *a6;
  *(void *)(a1 + 72) = v16;
  if (v16) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v16 + 8), 1uLL, memory_order_relaxed);
  }
  if (*((char *)a7 + 23) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 80), *(void **)a7, *((void *)a7 + 1));
  }
  else
  {
    long long v17 = *a7;
    *(void *)(a1 + 96) = *((void *)a7 + 2);
    *(_OWORD *)(a1 + 80) = v17;
  }
  long long v18 = (unsigned char *)(a1 + 104);
  if (*((char *)a8 + 23) < 0)
  {
    sub_10004FC84(v18, *(void **)a8, *((void *)a8 + 1));
  }
  else
  {
    long long v19 = *a8;
    *(void *)(a1 + 120) = *((void *)a8 + 2);
    *(_OWORD *)long long v18 = v19;
  }
  return a1;
}

void sub_100B17F30(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 103) < 0) {
    operator delete(*v3);
  }
  int v5 = *(std::__shared_weak_count **)(v1 + 72);
  if (v5) {
    sub_10004D2C8(v5);
  }
  uint64_t v6 = *(std::__shared_weak_count **)(v1 + 56);
  if (v6) {
    sub_10004D2C8(v6);
  }
  if (*(char *)(v1 + 47) < 0) {
    operator delete(*v2);
  }
  uint64_t v7 = *(std::__shared_weak_count **)(v1 + 16);
  if (v7) {
    sub_10004D2C8(v7);
  }
  _Unwind_Resume(exception_object);
}

void *sub_100B17F90(void *a1, void *a2, long long *a3)
{
  uint64_t v4 = a2[1];
  *a1 = *a2;
  a1[1] = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  int v5 = a1 + 2;
  if (*((char *)a3 + 23) < 0)
  {
    sub_10004FC84(v5, *(void **)a3, *((void *)a3 + 1));
  }
  else
  {
    long long v6 = *a3;
    a1[4] = *((void *)a3 + 2);
    *(_OWORD *)int v5 = v6;
  }
  return a1;
}

void sub_100B17FF4(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(std::__shared_weak_count **)(v1 + 8);
  if (v3) {
    sub_10004D2C8(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100B1800C(uint64_t a1, uint64_t a2, char *a3)
{
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&__p, kCtLoggingSystemName, "lazuli.store");
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v14, &__p);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 8), (const ctu::OsLogLogger *)v14);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v14);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&__p);
  v15[0] = off_101999E18;
  v15[1] = sub_100B182AC;
  v15[3] = v15;
  sub_100B182D8((capabilities::ct *)(a1 + 16));
  sub_10008863C(v15);
  *(void *)a1 = off_101A3B420;
  sub_100B1A2A4(a1 + 24, a2);
  *(void *)(a1 + 152) = 0;
  *(unsigned char *)(a1 + 191) = 0;
  *(void *)(a1 + 160) = 0;
  *(unsigned char *)(a1 + 168) = 0;
  int v6 = *(_DWORD *)a2;
  *(_DWORD *)(a1 + 192) = *(_DWORD *)a2;
  uint64_t v7 = *(std::__shared_weak_count **)(a2 + 16);
  uint64_t v11 = *(void *)(a2 + 8);
  long long v12 = v7;
  if (v7) {
    atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  sub_100058DB0(&__p, a3);
  v14[0] = 0;
  v14[1] = 0;
  int v13 = v6;
  sub_100B8C1D0(&v13, &v11, a2 + 104, (uint64_t)&__p, v14, (void *)(a1 + 200));
  if (v10 < 0) {
    operator delete(__p.var0);
  }
  if (v12) {
    sub_10004D2C8(v12);
  }
  if (!*(void *)(a1 + 200)) {
    __TUAssertTrigger();
  }
  return a1;
}

void sub_100B181E4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18, uint64_t a19, uint64_t a20,char a21)
{
  uint64_t v27 = *(std::__shared_weak_count **)(v23 + 208);
  if (v27) {
    sub_10004D2C8(v27);
  }
  sub_1000D3AC0(v25);
  sub_100B1849C(v24);
  uint64_t v28 = *v22;
  *int v22 = 0;
  if (v28) {
    (*(void (**)(uint64_t))(*(void *)v28 + 8))(v28);
  }
  ctu::OsLogLogger::~OsLogLogger(v21);
  _Unwind_Resume(a1);
}

const char *sub_100B182AC(int a1)
{
  uint64_t v1 = "lazuli.store.?";
  if (a1 == 2) {
    uint64_t v1 = "lazuli.store.2";
  }
  if (a1 == 1) {
    return "lazuli.store.1";
  }
  else {
    return v1;
  }
}

capabilities::ct *sub_100B182D8(capabilities::ct *a1)
{
  *(void *)a1 = 0;
  if ((capabilities::ct::supportsGemini(a1) & 1) == 0) {
    operator new();
  }
  if (!*(void *)a1) {
    operator new();
  }
  return a1;
}

void sub_100B18430(uint64_t a1, ...)
{
  va_start(va, a1);
  sub_10008863C((uint64_t *)va);
  operator delete();
}

uint64_t sub_100B1849C(uint64_t a1)
{
  if (*(char *)(a1 + 127) < 0) {
    operator delete(*(void **)(a1 + 104));
  }
  if (*(char *)(a1 + 103) < 0) {
    operator delete(*(void **)(a1 + 80));
  }
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 72);
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 56);
  if (v3) {
    sub_10004D2C8(v3);
  }
  if (*(char *)(a1 + 47) < 0) {
    operator delete(*(void **)(a1 + 24));
  }
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4) {
    sub_10004D2C8(v4);
  }
  return a1;
}

uint64_t sub_100B18514(uint64_t a1, uint64_t a2, uint64_t a3, char *a4)
{
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&__p, kCtLoggingSystemName, "lazuli.store");
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v19, &__p);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 8), (const ctu::OsLogLogger *)v19);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v19);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&__p);
  v20[0] = off_101999E18;
  v20[1] = sub_100B182AC;
  v20[3] = v20;
  sub_100B182D8((capabilities::ct *)(a1 + 16));
  sub_10008863C(v20);
  *(void *)a1 = off_101A3B420;
  sub_100B1A2A4(a1 + 24, a2);
  *(void *)(a1 + 152) = *(void *)a3;
  uint64_t v8 = *(void *)(a3 + 8);
  *(void *)(a1 + 160) = v8;
  if (v8) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v8 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v9 = (unsigned char *)(a1 + 168);
  if (*(char *)(a3 + 39) < 0)
  {
    sub_10004FC84(v9, *(void **)(a3 + 16), *(void *)(a3 + 24));
  }
  else
  {
    long long v10 = *(_OWORD *)(a3 + 16);
    *(void *)(a1 + 184) = *(void *)(a3 + 32);
    *(_OWORD *)uint64_t v9 = v10;
  }
  int v11 = *(_DWORD *)a2;
  *(_DWORD *)(a1 + 192) = *(_DWORD *)a2;
  long long v12 = *(std::__shared_weak_count **)(a2 + 16);
  uint64_t v16 = *(void *)(a2 + 8);
  long long v17 = v12;
  if (v12) {
    atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  sub_100058DB0(&__p, a4);
  v19[0] = 0;
  v19[1] = 0;
  int v18 = v11;
  sub_100B8C1D0(&v18, &v16, a2 + 104, (uint64_t)&__p, v19, (void *)(a1 + 200));
  if (v15 < 0) {
    operator delete(__p.var0);
  }
  if (v17) {
    sub_10004D2C8(v17);
  }
  if (!*(void *)(a1 + 200)) {
    __TUAssertTrigger();
  }
  return a1;
}

void sub_100B1872C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18, uint64_t a19, uint64_t a20,char a21)
{
  uint64_t v27 = *(std::__shared_weak_count **)(v23 + 208);
  if (v27) {
    sub_10004D2C8(v27);
  }
  sub_1000D3AC0(v25);
  sub_100B1849C(v24);
  uint64_t v28 = *v22;
  *int v22 = 0;
  if (v28) {
    (*(void (**)(uint64_t))(*(void *)v28 + 8))(v28);
  }
  ctu::OsLogLogger::~OsLogLogger(v21);
  _Unwind_Resume(a1);
}

uint64_t sub_100B18808(uint64_t a1)
{
  *(void *)a1 = off_101A3B420;
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 208);
  if (v2) {
    sub_10004D2C8(v2);
  }
  if (*(char *)(a1 + 191) < 0) {
    operator delete(*(void **)(a1 + 168));
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 160);
  if (v3) {
    sub_10004D2C8(v3);
  }
  if (*(char *)(a1 + 151) < 0) {
    operator delete(*(void **)(a1 + 128));
  }
  if (*(char *)(a1 + 127) < 0) {
    operator delete(*(void **)(a1 + 104));
  }
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 96);
  if (v4) {
    sub_10004D2C8(v4);
  }
  int v5 = *(std::__shared_weak_count **)(a1 + 80);
  if (v5) {
    sub_10004D2C8(v5);
  }
  if (*(char *)(a1 + 71) < 0) {
    operator delete(*(void **)(a1 + 48));
  }
  int v6 = *(std::__shared_weak_count **)(a1 + 40);
  if (v6) {
    sub_10004D2C8(v6);
  }
  uint64_t v7 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = 0;
  if (v7) {
    (*(void (**)(uint64_t))(*(void *)v7 + 8))(v7);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 8));
  return a1;
}

void sub_100B18904(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)int v22 = 0u;
  long long v23 = 0u;
  uint64_t v4 = *(os_log_t **)(a1 + 200);
  int v5 = (long long *)(a1 + 48);
  if (*(char *)(a1 + 71) < 0)
  {
    sub_10004FC84(__dst, *(void **)(a1 + 48), *(void *)(a1 + 56));
  }
  else
  {
    *(_OWORD *)std::string __dst = *v5;
    uint64_t v21 = *(void *)(a1 + 64);
  }
  sub_100178D18(buf, (uint64_t)__dst);
  sub_100058DB0(__p, "conversationID");
  sub_100B18DB4(v4, (uint64_t)buf, (uint64_t)__p, v22);
  if (v19 < 0) {
    operator delete(__p[0]);
  }
  if (v27 < 0) {
    operator delete(*(void **)buf);
  }
  if (SHIBYTE(v21) < 0) {
    operator delete(__dst[0]);
  }
  if (BYTE8(v23))
  {
    if (sub_100197A80((unsigned __int8 *)v22, (unsigned __int8 *)a2))
    {
      int v6 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 16) + 16))(*(void *)(a1 + 16), *(unsigned int *)(a1 + 192));
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        if (!BYTE8(v23)) {
          sub_10016C840();
        }
        uint64_t v7 = v22;
        if (SBYTE7(v23) < 0) {
          uint64_t v7 = (void **)v22[0];
        }
        if (*(char *)(a2 + 23) >= 0) {
          uint64_t v8 = a2;
        }
        else {
          uint64_t v8 = *(void *)a2;
        }
        *(_DWORD *)uint64_t buf = 136446466;
        *(void *)&void buf[4] = v7;
        __int16 v25 = 2082;
        uint64_t v26 = v8;
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Updating ConversationID from: %{public}s ==> %{public}s", buf, 0x16u);
      }
      uint64_t v9 = *(void *)(a1 + 200);
      if (*(char *)(a1 + 71) < 0)
      {
        sub_10004FC84(v14, *(void **)(a1 + 48), *(void *)(a1 + 56));
      }
      else
      {
        *(_OWORD *)long long v14 = *v5;
        uint64_t v15 = *((void *)v5 + 2);
      }
      sub_100178D18(buf, (uint64_t)v14);
      sub_100058DB0(__p, "conversationID");
      sub_100B18E6C(v9, (uint64_t)buf, (uint64_t)__p, a2, 0, 0);
      if (v19 < 0) {
        operator delete(__p[0]);
      }
      if (v27 < 0) {
        operator delete(*(void **)buf);
      }
      if (SHIBYTE(v15) < 0)
      {
        int v13 = v14[0];
        goto LABEL_43;
      }
    }
  }
  else
  {
    long long v10 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 16) + 16))(*(void *)(a1 + 16), *(unsigned int *)(a1 + 192));
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      if (*(char *)(a2 + 23) >= 0) {
        uint64_t v11 = a2;
      }
      else {
        uint64_t v11 = *(void *)a2;
      }
      *(_DWORD *)uint64_t buf = 136446210;
      *(void *)&void buf[4] = v11;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I Storing new ConversationID: %{public}s", buf, 0xCu);
    }
    uint64_t v12 = *(void *)(a1 + 200);
    if (*(char *)(a1 + 71) < 0)
    {
      sub_10004FC84(&v16, *(void **)(a1 + 48), *(void *)(a1 + 56));
    }
    else
    {
      long long v16 = *v5;
      uint64_t v17 = *((void *)v5 + 2);
    }
    sub_100178D18(buf, (uint64_t)&v16);
    sub_100058DB0(__p, "conversationID");
    sub_100B18E6C(v12, (uint64_t)buf, (uint64_t)__p, a2, 0, 0);
    if (v19 < 0) {
      operator delete(__p[0]);
    }
    if (v27 < 0) {
      operator delete(*(void **)buf);
    }
    if (SHIBYTE(v17) < 0)
    {
      int v13 = (void *)v16;
LABEL_43:
      operator delete(v13);
    }
  }
  std::string::operator=((std::string *)(a1 + 168), (const std::string *)a2);
  if (BYTE8(v23))
  {
    if (SBYTE7(v23) < 0) {
      operator delete(v22[0]);
    }
  }
}

void sub_100B18CA4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,uint64_t a28,uint64_t a29,int a30,__int16 a31,char a32,char a33,uint64_t a34,void *__p,uint64_t a36,int a37,__int16 a38,char a39,char a40,char a41)
{
  if (a41)
  {
    if (a40 < 0) {
      operator delete(__p);
    }
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100B18DB4@<X0>(os_log_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, unsigned char *a4@<X8>)
{
  xpc_object_t object = 0;
  uint64_t v8 = 0;
  sub_100B8BCF4(a1, a2, a3, (uint64_t)&object);
  if ((_BYTE)v8)
  {
    xpc_object_t v6 = object;
    if (object) {
      xpc_retain(object);
    }
    else {
      xpc_object_t v6 = xpc_null_create();
    }
    sub_100B1A434((uint64_t)&v6, (uint64_t)a4);
    xpc_release(v6);
    xpc_object_t v6 = 0;
  }
  else
  {
    *a4 = 0;
    a4[24] = 0;
  }
  return sub_100179294((uint64_t)&object);
}

void sub_100B18E44(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, char a11)
{
}

void sub_100B18E6C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int64_t a5, char a6)
{
  xpc_object_t v32 = 0;
  sub_100B8B41C(a1, a2, &v32);
  if (xpc_get_type(v32) != (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_object_t v22 = 0;
    xpc_object_t v12 = xpc_dictionary_create(0, 0, 0);
    xpc_object_t v13 = v12;
    if (v12)
    {
      xpc_object_t v22 = v12;
    }
    else
    {
      xpc_object_t v13 = xpc_null_create();
      xpc_object_t v22 = v13;
      if (!v13)
      {
        xpc_object_t v14 = xpc_null_create();
        xpc_object_t v13 = 0;
        goto LABEL_25;
      }
    }
    if (xpc_get_type(v13) == (xpc_type_t)&_xpc_type_dictionary)
    {
      xpc_retain(v13);
LABEL_26:
      xpc_release(v13);
      if (*(char *)(a4 + 23) < 0)
      {
        sub_10004FC84(v18, *(void **)a4, *(void *)(a4 + 8));
      }
      else
      {
        *(_OWORD *)int v18 = *(_OWORD *)a4;
        uint64_t v19 = *(void *)(a4 + 16);
      }
      sub_100B1A5CC(a1, (const char *)v18, a5, a6, &v20);
      if (*(char *)(a3 + 23) < 0)
      {
        sub_10004FC84(__p, *(void **)a3, *(void *)(a3 + 8));
      }
      else
      {
        *(_OWORD *)OsLogContext __p = *(_OWORD *)a3;
        uint64_t v25 = *(void *)(a3 + 16);
      }
      long long v16 = __p;
      if (v25 < 0) {
        long long v16 = (void **)__p[0];
      }
      uint64_t v26 = &v22;
      char v27 = v16;
      sub_10014E03C((uint64_t)&v26, &v20, &v21);
      xpc_release(v21);
      xpc_object_t v21 = 0;
      if (SHIBYTE(v25) < 0) {
        operator delete(__p[0]);
      }
      xpc_release(v20);
      xpc_object_t v20 = 0;
      if (SHIBYTE(v19) < 0) {
        operator delete(v18[0]);
      }
      xpc_object_t v17 = v22;
      if (v22) {
        xpc_retain(v22);
      }
      else {
        xpc_object_t v17 = xpc_null_create();
      }
      sub_100B8AC04(a1, a2, &v17);
      xpc_release(v17);
      xpc_object_t v17 = 0;
      xpc_release(v22);
      goto LABEL_42;
    }
    xpc_object_t v14 = xpc_null_create();
LABEL_25:
    xpc_object_t v22 = v14;
    goto LABEL_26;
  }
  if (*(char *)(a4 + 23) < 0)
  {
    sub_10004FC84(__dst, *(void **)a4, *(void *)(a4 + 8));
  }
  else
  {
    *(_OWORD *)std::string __dst = *(_OWORD *)a4;
    uint64_t v29 = *(void *)(a4 + 16);
  }
  sub_100B1A5CC(a1, (const char *)__dst, a5, a6, &v30);
  if (*(char *)(a3 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a3, *(void *)(a3 + 8));
  }
  else
  {
    *(_OWORD *)OsLogContext __p = *(_OWORD *)a3;
    uint64_t v25 = *(void *)(a3 + 16);
  }
  uint64_t v15 = __p;
  if (v25 < 0) {
    uint64_t v15 = (void **)__p[0];
  }
  uint64_t v26 = &v32;
  char v27 = v15;
  sub_10014E03C((uint64_t)&v26, &v30, &v31);
  xpc_release(v31);
  xpc_object_t v31 = 0;
  if (SHIBYTE(v25) < 0) {
    operator delete(__p[0]);
  }
  xpc_release(v30);
  int v30 = 0;
  if (SHIBYTE(v29) < 0) {
    operator delete(__dst[0]);
  }
  xpc_object_t object = v32;
  if (v32) {
    xpc_retain(v32);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  sub_100B8AC04(a1, a2, &object);
  xpc_release(object);
  xpc_object_t object = 0;
LABEL_42:
  xpc_release(v32);
}

void sub_100B19174(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, xpc_object_t object, uint64_t a19, xpc_object_t a20,xpc_object_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,void *__p,uint64_t a29,int a30,__int16 a31,char a32,char a33)
{
  xpc_release(*(xpc_object_t *)(v33 - 104));
  *(void *)(v33 - 104) = 0;
  if (a33 < 0) {
    operator delete(__p);
  }
  xpc_release(*(xpc_object_t *)(v33 - 88));
  _Unwind_Resume(a1);
}

void sub_100B19268(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3 = (void **)(a1 + 168);
  if (*(char *)(a1 + 191) < 0)
  {
    unint64_t v5 = *(void *)(a1 + 176);
    if (v5)
    {
      sub_10004FC84((unsigned char *)a2, *v3, v5);
LABEL_19:
      *(unsigned char *)(a2 + 24) = 1;
      return;
    }
  }
  else if (*(unsigned char *)(a1 + 191))
  {
    *(_OWORD *)a2 = *(_OWORD *)v3;
    uint64_t v4 = *(void *)(a1 + 184);
LABEL_18:
    *(void *)(a2 + 16) = v4;
    goto LABEL_19;
  }
  long long v15 = 0u;
  long long v16 = 0u;
  xpc_object_t v6 = *(os_log_t **)(a1 + 200);
  if (*(char *)(a1 + 71) < 0)
  {
    sub_10004FC84(__dst, *(void **)(a1 + 48), *(void *)(a1 + 56));
  }
  else
  {
    *(_OWORD *)std::string __dst = *(_OWORD *)(a1 + 48);
    uint64_t v12 = *(void *)(a1 + 64);
  }
  sub_100178D18(v13, (uint64_t)__dst);
  sub_100058DB0(__p, "conversationID");
  sub_100B18DB4(v6, (uint64_t)v13, (uint64_t)__p, &v15);
  if (v10 < 0) {
    operator delete(__p[0]);
  }
  if (v14 < 0) {
    operator delete(v13[0]);
  }
  if (SHIBYTE(v12) < 0) {
    operator delete(__dst[0]);
  }
  if (!BYTE8(v16))
  {
    *(unsigned char *)a2 = 0;
    *(unsigned char *)(a2 + 24) = 0;
    return;
  }
  if ((SBYTE7(v16) & 0x80000000) == 0)
  {
    *(_OWORD *)a2 = v15;
    uint64_t v4 = v16;
    goto LABEL_18;
  }
  sub_10004FC84((unsigned char *)a2, (void *)v15, *((unint64_t *)&v15 + 1));
  int v7 = BYTE8(v16);
  int v8 = SBYTE7(v16);
  *(unsigned char *)(a2 + 24) = 1;
  if (v7)
  {
    if (v8 < 0) {
      operator delete((void *)v15);
    }
  }
}

void sub_100B193C4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (*(unsigned char *)(v27 - 24))
  {
    if (*(char *)(v27 - 25) < 0) {
      operator delete(*(void **)(v27 - 48));
    }
  }
  _Unwind_Resume(exception_object);
}

void sub_100B1942C(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (os_log_t *)(*(uint64_t (**)(void, void))(**(void **)(a1 + 16) + 16))(*(void *)(a1 + 16), *(unsigned int *)(a1 + 192));
  unint64_t v5 = v4;
  if (*(void *)(a1 + 152))
  {
    xpc_object_t v6 = *v4;
    if (os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT))
    {
      int v7 = (void *)(a1 + 168);
      if (*(char *)(a1 + 191) < 0) {
        int v7 = (void *)*v7;
      }
      *(_DWORD *)uint64_t buf = 136446210;
      *(void *)&void buf[4] = v7;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Transport already connected: %{public}s", buf, 0xCu);
    }
    return;
  }
  uint64_t v8 = *(void *)(a1 + 72);
  if (v8 && *(void *)(a1 + 88))
  {
    xpc_object_t v40 = 0;
    if (*(char *)(a2 + 23) < 0)
    {
      sub_10004FC84(string, *(void **)a2, *(void *)(a2 + 8));
    }
    else
    {
      *(_OWORD *)string = *(_OWORD *)a2;
      uint64_t v39 = *(void *)(a2 + 16);
    }
    xpc_object_t v40 = 0;
    xpc_object_t v12 = xpc_dictionary_create(0, 0, 0);
    xpc_object_t v13 = v12;
    if (v12)
    {
      xpc_object_t v40 = v12;
    }
    else
    {
      xpc_object_t v13 = xpc_null_create();
      xpc_object_t v40 = v13;
      if (!v13)
      {
        xpc_object_t v14 = xpc_null_create();
        xpc_object_t v13 = 0;
        goto LABEL_25;
      }
    }
    if (xpc_get_type(v13) == (xpc_type_t)&_xpc_type_dictionary)
    {
      xpc_retain(v13);
      goto LABEL_26;
    }
    xpc_object_t v14 = xpc_null_create();
LABEL_25:
    xpc_object_t v40 = v14;
LABEL_26:
    xpc_release(v13);
    (*(void (**)(unsigned char *__return_ptr, uint64_t))(*(void *)a1 + 40))(buf, a1);
    if (buf[23] >= 0) {
      long long v15 = buf;
    }
    else {
      long long v15 = *(const char **)buf;
    }
    xpc_object_t v51 = xpc_string_create(v15);
    if (!v51) {
      xpc_object_t v51 = xpc_null_create();
    }
    v55.__r_.__value_.__r.__words[0] = (std::string::size_type)&v40;
    v55.__r_.__value_.__l.__size_ = ims::lazuli::kRemoteUri;
    sub_100035E70((uint64_t)&v55, &v51, &v52);
    xpc_release(v52);
    xpc_object_t v52 = 0;
    xpc_release(v51);
    xpc_object_t v51 = 0;
    if ((buf[23] & 0x80000000) != 0) {
      operator delete(*(void **)buf);
    }
    sub_100561B00((uint64_t)buf);
    if (buf[23] >= 0) {
      long long v16 = buf;
    }
    else {
      long long v16 = *(const char **)buf;
    }
    xpc_object_t v49 = xpc_string_create(v16);
    if (!v49) {
      xpc_object_t v49 = xpc_null_create();
    }
    v55.__r_.__value_.__r.__words[0] = (std::string::size_type)&v40;
    v55.__r_.__value_.__l.__size_ = ims::lazuli::kTransactionId;
    sub_100035E70((uint64_t)&v55, &v49, &object);
    xpc_release(object);
    xpc_object_t object = 0;
    xpc_release(v49);
    xpc_object_t v49 = 0;
    if ((buf[23] & 0x80000000) != 0) {
      operator delete(*(void **)buf);
    }
    if (SHIBYTE(v39) < 0)
    {
      if (string[1])
      {
        xpc_object_t v17 = string[0];
        goto LABEL_45;
      }
    }
    else if (HIBYTE(v39))
    {
      xpc_object_t v17 = (const char *)string;
LABEL_45:
      *(void *)&long long __p = xpc_string_create(v17);
      if (!(void)__p) {
        *(void *)&long long __p = xpc_null_create();
      }
      *(void *)uint64_t buf = &v40;
      *(void *)&uint8_t buf[8] = ims::lazuli::kConversationId;
      sub_100035E70((uint64_t)buf, (xpc_object_t *)&__p, (xpc_object_t *)&v55.__r_.__value_.__l.__data_);
      xpc_release(v55.__r_.__value_.__l.__data_);
      v55.__r_.__value_.__r.__words[0] = 0;
      xpc_release((xpc_object_t)__p);
      *(void *)&long long __p = 0;
      int v18 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 16) + 16))(*(void *)(a1 + 16), *(unsigned int *)(a1 + 192));
      if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v19 = string;
        if (v39 < 0) {
          uint64_t v19 = (char **)string[0];
        }
        *(_DWORD *)uint64_t buf = 136446210;
        *(void *)&void buf[4] = v19;
        _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#I Conversation ID used from client: %{public}s", buf, 0xCu);
      }
LABEL_98:
      if (SHIBYTE(v39) < 0) {
        operator delete(string[0]);
      }
      uint64_t v29 = *v5;
      if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
      {
        int v30 = (void *)(a1 + 168);
        if (*(char *)(a1 + 191) < 0) {
          int v30 = (void *)*v30;
        }
        *(_DWORD *)uint64_t buf = 136446210;
        *(void *)&void buf[4] = v30;
        _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "#I Connecting with transport: %{public}s", buf, 0xCu);
      }
      uint64_t v31 = *(void *)(a1 + 72);
      xpc_object_t v32 = *(std::__shared_weak_count **)(a1 + 96);
      uint64_t v36 = *(void *)(a1 + 88);
      xpc_object_t v37 = v32;
      if (v32) {
        atomic_fetch_add_explicit(&v32->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      xpc_object_t v35 = v40;
      if (v40) {
        xpc_retain(v40);
      }
      else {
        xpc_object_t v35 = xpc_null_create();
      }
      (*(void (**)(unsigned char *__return_ptr, uint64_t, uint64_t *, xpc_object_t *))(*(void *)v31 + 136))(buf, v31, &v36, &v35);
      long long v33 = *(_OWORD *)buf;
      *(void *)uint64_t buf = 0;
      *(void *)&uint8_t buf[8] = 0;
      double v34 = *(std::__shared_weak_count **)(a1 + 160);
      *(_OWORD *)(a1 + 152) = v33;
      if (v34)
      {
        sub_10004D2C8(v34);
        if (*(void *)&buf[8]) {
          sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
        }
      }
      xpc_release(v35);
      xpc_object_t v35 = 0;
      if (v37) {
        sub_10004D2C8(v37);
      }
      xpc_release(v40);
      return;
    }
    memset(buf, 0, sizeof(buf));
    xpc_object_t v20 = *(os_log_t **)(a1 + 200);
    xpc_object_t v21 = (long long *)(a1 + 48);
    if (*(char *)(a1 + 71) < 0)
    {
      sub_10004FC84(&__p, *(void **)(a1 + 48), *(void *)(a1 + 56));
    }
    else
    {
      long long __p = *v21;
      uint64_t v48 = *(void *)(a1 + 64);
    }
    sub_100178D18(&v55, (uint64_t)&__p);
    sub_100058DB0(&v53, "conversationID");
    sub_100B18DB4(v20, (uint64_t)&v55, (uint64_t)&v53, buf);
    if (v54 < 0) {
      operator delete((void *)v53);
    }
    if (SHIBYTE(v55.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v55.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v48) < 0) {
      operator delete((void *)__p);
    }
    if (buf[24])
    {
      if (buf[23] >= 0) {
        xpc_object_t v22 = buf;
      }
      else {
        xpc_object_t v22 = *(const char **)buf;
      }
      __dst[0] = xpc_string_create(v22);
      if (!__dst[0]) {
        __dst[0] = xpc_null_create();
      }
      v55.__r_.__value_.__r.__words[0] = (std::string::size_type)&v40;
      v55.__r_.__value_.__l.__size_ = ims::lazuli::kConversationId;
      sub_100035E70((uint64_t)&v55, __dst, (xpc_object_t *)&v53);
      xpc_release((xpc_object_t)v53);
      *(void *)&long long v53 = 0;
      xpc_release(__dst[0]);
      __dst[0] = 0;
      long long v23 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 16) + 16))(*(void *)(a1 + 16), *(unsigned int *)(a1 + 192));
      if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
      {
        if (!buf[24]) {
          sub_10016C840();
        }
        uint64_t v24 = buf;
        if (buf[23] < 0) {
          uint64_t v24 = *(unsigned char **)buf;
        }
        LODWORD(v55.__r_.__value_.__l.__data_) = 136446210;
        *(std::string::size_type *)((char *)v55.__r_.__value_.__r.__words + 4) = (std::string::size_type)v24;
        _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "#I Conversation ID found in storage: %{public}s", (uint8_t *)&v55, 0xCu);
      }
      if (!buf[24]) {
        sub_10016C840();
      }
      std::string::operator=((std::string *)(a1 + 168), (const std::string *)buf);
    }
    else
    {
      memset(&v55, 0, sizeof(v55));
      (*(void (**)(long long *__return_ptr, uint64_t))(*(void *)a1 + 40))(&v53, a1);
      sub_100561EF8((const void **)&v53, (const void **)(a1 + 104), &v55);
      if (v54 < 0) {
        operator delete((void *)v53);
      }
      if ((v55.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        uint64_t v25 = &v55;
      }
      else {
        uint64_t v25 = (std::string *)v55.__r_.__value_.__r.__words[0];
      }
      xpc_object_t v45 = xpc_string_create((const char *)v25);
      if (!v45) {
        xpc_object_t v45 = xpc_null_create();
      }
      *(void *)&long long v53 = &v40;
      *((void *)&v53 + 1) = ims::lazuli::kConversationId;
      sub_100035E70((uint64_t)&v53, &v45, &v46);
      xpc_release(v46);
      xpc_object_t v46 = 0;
      xpc_release(v45);
      xpc_object_t v45 = 0;
      uint64_t v26 = *(void *)(a1 + 200);
      if (*(char *)(a1 + 71) < 0)
      {
        sub_10004FC84(__dst, *(void **)(a1 + 48), *(void *)(a1 + 56));
      }
      else
      {
        *(_OWORD *)std::string __dst = *v21;
        uint64_t v44 = *(void *)(a1 + 64);
      }
      sub_100178D18(&v53, (uint64_t)__dst);
      sub_100058DB0(v41, "conversationID");
      sub_100B18E6C(v26, (uint64_t)&v53, (uint64_t)v41, (uint64_t)&v55, 0, 0);
      if (v42 < 0) {
        operator delete(v41[0]);
      }
      if (v54 < 0) {
        operator delete((void *)v53);
      }
      if (SHIBYTE(v44) < 0) {
        operator delete(__dst[0]);
      }
      uint64_t v27 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 16) + 16))(*(void *)(a1 + 16), *(unsigned int *)(a1 + 192));
      if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v28 = &v55;
        if ((v55.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
          uint64_t v28 = (std::string *)v55.__r_.__value_.__r.__words[0];
        }
        LODWORD(v53) = 136446210;
        *(void *)((char *)&v53 + 4) = v28;
        _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "#I Conversation ID not found in storage. Created new conversation ID: %{public}s", (uint8_t *)&v53, 0xCu);
      }
      std::string::operator=((std::string *)(a1 + 168), &v55);
      if (SHIBYTE(v55.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v55.__r_.__value_.__l.__data_);
      }
    }
    if (buf[24] && (buf[23] & 0x80000000) != 0) {
      operator delete(*(void **)buf);
    }
    goto LABEL_98;
  }
  uint64_t v9 = *v4;
  if (os_log_type_enabled(*v4, OS_LOG_TYPE_ERROR))
  {
    char v10 = "valid";
    if (v8) {
      uint64_t v11 = "valid";
    }
    else {
      uint64_t v11 = "invalid";
    }
    if (!*(void *)(a1 + 88)) {
      char v10 = "invalid";
    }
    *(_DWORD *)uint64_t buf = 136315394;
    *(void *)&void buf[4] = v11;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = v10;
    _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "Transport connection failed [sip stack ref: %s] [ims client ref: %s]", buf, 0x16u);
  }
}

void sub_100B19D48(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, xpc_object_t object,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,void *a27,uint64_t a28,int a29,__int16 a30,char a31,char a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,int a38,__int16 a39,char a40,char a41)
{
  if (*(char *)(v41 - 105) < 0) {
    operator delete(*(void **)(v41 - 128));
  }
  if (*(unsigned char *)(v41 - 72) && *(char *)(v41 - 73) < 0) {
    operator delete(*(void **)(v41 - 96));
  }
  xpc_release(object);
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_100B19F20(uint64_t a1, uint64_t *a2)
{
  uint64_t v4 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 16) + 16))(*(void *)(a1 + 16), *(unsigned int *)(a1 + 192));
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    v15[0] = 0;
    v15[8] = 0;
    sub_100A66208((uint64_t)v15, v16);
    int v5 = v17;
    xpc_object_t v6 = (void **)v16[0];
    v12[0] = 0;
    unsigned char v12[8] = 0;
    sub_100A66208((uint64_t)v12, __p);
    int v7 = v16;
    if (v5 < 0) {
      int v7 = v6;
    }
    if (v14 >= 0) {
      uint64_t v8 = __p;
    }
    else {
      uint64_t v8 = (void **)__p[0];
    }
    *(_DWORD *)uint64_t buf = 134218240;
    uint64_t v19 = v7;
    __int16 v20 = 2048;
    xpc_object_t v21 = v8;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Updating chat: %p ==> %p", buf, 0x16u);
    if (v14 < 0) {
      operator delete(__p[0]);
    }
    sub_100179294((uint64_t)v12);
    if (v17 < 0) {
      operator delete(v16[0]);
    }
    sub_100179294((uint64_t)v15);
  }
  uint64_t v10 = *a2;
  uint64_t v9 = a2[1];
  if (v9) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v9 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v11 = *(std::__shared_weak_count **)(a1 + 160);
  *(void *)(a1 + 152) = v10;
  *(void *)(a1 + 160) = v9;
  if (v11) {
    sub_10004D2C8(v11);
  }
}

void sub_100B1A0B4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  sub_100179294((uint64_t)&a14);
  _Unwind_Resume(a1);
}

BOOL sub_100B1A0E8(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 152);
  if (!v2) {
    return 0;
  }
  __s1 = 0;
  __CFIndex n = 0;
  uint64_t v25 = 0;
  (*(void (**)(void **__return_ptr))(*(void *)v2 + 64))(&__s1);
  size_t v4 = HIBYTE(v25);
  if (v25 < 0) {
    size_t v4 = __n;
  }
  if (!v4)
  {
    BOOL v7 = 0;
    if (v25 < 0) {
      goto LABEL_34;
    }
    return v7;
  }
  if (*(void *)a2)
  {
    (*(void (**)(void **__return_ptr))(**(void **)a2 + 64))(&__p);
    unsigned int v5 = HIBYTE(v22);
    uint64_t v6 = v21;
  }
  else
  {
    uint64_t v6 = 0;
    unsigned int v5 = 0;
    long long __p = 0;
    uint64_t v21 = 0;
    uint64_t v22 = 0;
  }
  char v8 = HIBYTE(v25);
  if (v25 >= 0) {
    size_t v9 = HIBYTE(v25);
  }
  else {
    size_t v9 = __n;
  }
  if ((v5 & 0x80u) == 0) {
    uint64_t v6 = v5;
  }
  if (v9 != v6)
  {
    BOOL v7 = 0;
    if ((v5 & 0x80) == 0) {
      goto LABEL_33;
    }
    goto LABEL_37;
  }
  if ((v5 & 0x80u) == 0) {
    p_p = (unsigned __int8 *)&__p;
  }
  else {
    p_p = (unsigned __int8 *)__p;
  }
  if (SHIBYTE(v25) < 0)
  {
    BOOL v7 = memcmp(__s1, p_p, __n) == 0;
    goto LABEL_32;
  }
  if (HIBYTE(v25))
  {
    uint64_t v11 = HIBYTE(v25) - 1;
    p_s1 = &__s1;
    do
    {
      int v14 = *(unsigned __int8 *)p_s1;
      p_s1 = (void **)((char *)p_s1 + 1);
      int v13 = v14;
      int v16 = *p_p++;
      int v15 = v16;
      BOOL v18 = v11-- != 0;
      BOOL v7 = v13 == v15;
    }
    while (v13 == v15 && v18);
LABEL_32:
    if ((v5 & 0x80) == 0) {
      goto LABEL_33;
    }
LABEL_37:
    operator delete(__p);
    if ((v25 & 0x8000000000000000) == 0) {
      return v7;
    }
    goto LABEL_34;
  }
  BOOL v7 = 1;
  if ((v5 & 0x80) != 0) {
    goto LABEL_37;
  }
LABEL_33:
  if (v8 < 0) {
LABEL_34:
  }
    operator delete(__s1);
  return v7;
}

void sub_100B1A288(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100B1A2A4(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)a1 = *(_DWORD *)a2;
  uint64_t v4 = *(void *)(a2 + 16);
  *(void *)(a1 + 8) = *(void *)(a2 + 8);
  *(void *)(a1 + 16) = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  if (*(char *)(a2 + 47) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 24), *(void **)(a2 + 24), *(void *)(a2 + 32));
  }
  else
  {
    long long v5 = *(_OWORD *)(a2 + 24);
    *(void *)(a1 + 40) = *(void *)(a2 + 40);
    *(_OWORD *)(a1 + 24) = v5;
  }
  uint64_t v6 = *(void *)(a2 + 56);
  *(void *)(a1 + 48) = *(void *)(a2 + 48);
  *(void *)(a1 + 56) = v6;
  if (v6) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v6 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v7 = *(void *)(a2 + 72);
  *(void *)(a1 + 64) = *(void *)(a2 + 64);
  *(void *)(a1 + 72) = v7;
  if (v7) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v7 + 8), 1uLL, memory_order_relaxed);
  }
  if (*(char *)(a2 + 103) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 80), *(void **)(a2 + 80), *(void *)(a2 + 88));
  }
  else
  {
    long long v8 = *(_OWORD *)(a2 + 80);
    *(void *)(a1 + 96) = *(void *)(a2 + 96);
    *(_OWORD *)(a1 + 80) = v8;
  }
  size_t v9 = (unsigned char *)(a1 + 104);
  if (*(char *)(a2 + 127) < 0)
  {
    sub_10004FC84(v9, *(void **)(a2 + 104), *(void *)(a2 + 112));
  }
  else
  {
    long long v10 = *(_OWORD *)(a2 + 104);
    *(void *)(a1 + 120) = *(void *)(a2 + 120);
    *(_OWORD *)size_t v9 = v10;
  }
  return a1;
}

void sub_100B1A3B0(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 103) < 0) {
    operator delete(*v3);
  }
  long long v5 = *(std::__shared_weak_count **)(v1 + 72);
  if (v5) {
    sub_10004D2C8(v5);
  }
  uint64_t v6 = *(std::__shared_weak_count **)(v1 + 56);
  if (v6) {
    sub_10004D2C8(v6);
  }
  if (*(char *)(v1 + 47) < 0) {
    operator delete(*v2);
  }
  uint64_t v7 = *(std::__shared_weak_count **)(v1 + 16);
  if (v7) {
    sub_10004D2C8(v7);
  }
  _Unwind_Resume(exception_object);
}

void sub_100B1A414()
{
}

uint64_t sub_100B1A428(uint64_t a1)
{
  return *(void *)(a1 + 8) + 8;
}

void sub_100B1A434(uint64_t a1@<X1>, uint64_t a2@<X8>)
{
  long long v12 = 0uLL;
  uint64_t v13 = 0;
  sub_100058DB0(__s2, "data");
  if (v9 >= 0) {
    uint64_t v4 = __s2;
  }
  else {
    uint64_t v4 = (void **)__s2[0];
  }
  v10[0] = a1;
  v10[1] = v4;
  sub_100048BAC((uint64_t)v10, &object);
  xpc::dyn_cast_or_default();
  xpc_release(object);
  xpc_object_t object = 0;
  if (SHIBYTE(v9) < 0) {
    operator delete(__s2[0]);
  }
  __s2[0] = 0;
  __s2[1] = 0;
  uint64_t v9 = 0;
  if (v13 >= 0) {
    uint64_t v5 = HIBYTE(v13);
  }
  else {
    uint64_t v5 = *((void *)&v12 + 1);
  }
  if (v5) {
    goto LABEL_10;
  }
  if (v13 < 0)
  {
    uint64_t v7 = (void *)v12;
    if (memcmp((const void *)v12, __s2, *((size_t *)&v12 + 1)))
    {
LABEL_10:
      *(_OWORD *)a2 = v12;
      *(void *)(a2 + 16) = v13;
      *(unsigned char *)(a2 + 24) = 1;
      return;
    }
    *(unsigned char *)a2 = 0;
    *(unsigned char *)(a2 + 24) = 0;
    operator delete(v7);
  }
  else
  {
    if (HIBYTE(v13))
    {
      uint64_t v6 = 0;
      while (*((unsigned __int8 *)&v12 + v6) == *((unsigned __int8 *)__s2 + v6))
      {
        if (HIBYTE(v13) == ++v6) {
          goto LABEL_16;
        }
      }
      goto LABEL_10;
    }
LABEL_16:
    *(unsigned char *)a2 = 0;
    *(unsigned char *)(a2 + 24) = 0;
  }
}

void sub_100B1A588(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,uint64_t a22,xpc_object_t object)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  xpc_release(object);
  if (a20 < 0) {
    operator delete(a15);
  }
  _Unwind_Resume(a1);
}

void sub_100B1A5CC(uint64_t a1@<X0>, const char *a2@<X1>, int64_t a3@<X2>, char a4@<W3>, void **a5@<X8>)
{
  *a5 = 0;
  xpc_object_t v10 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v11 = v10;
  if (v10)
  {
    *a5 = v10;
  }
  else
  {
    xpc_object_t v11 = xpc_null_create();
    *a5 = v11;
    if (!v11)
    {
      xpc_object_t v12 = xpc_null_create();
      xpc_object_t v11 = 0;
      goto LABEL_8;
    }
  }
  if (xpc_get_type(v11) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v11);
    goto LABEL_9;
  }
  xpc_object_t v12 = xpc_null_create();
LABEL_8:
  *a5 = v12;
LABEL_9:
  xpc_release(v11);
  uint64_t v13 = *a5;
  sub_100058DB0(__p, "created");
  if (v29 >= 0) {
    int v14 = __p;
  }
  else {
    int v14 = (void **)__p[0];
  }
  int v15 = *(std::__shared_weak_count **)(a1 + 32);
  if (v15) {
    atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  v16.__d_.__rep_ = std::chrono::system_clock::now().__d_.__rep_;
  xpc_dictionary_set_int64(v13, (const char *)v14, (uint64_t)((double)v16.__d_.__rep_ / 1000000.0));
  if (v15) {
    sub_10004D2C8(v15);
  }
  if (v29 < 0) {
    operator delete(__p[0]);
  }
  if (a4)
  {
    xpc_object_t v26 = xpc_int64_create(a3);
    if (!v26) {
      xpc_object_t v26 = xpc_null_create();
    }
    sub_100058DB0(__p, "validity");
    if (v29 >= 0) {
      char v17 = __p;
    }
    else {
      char v17 = (void **)__p[0];
    }
    uint64_t v24 = a5;
    uint64_t v25 = v17;
    sub_100035E70((uint64_t)&v24, &v26, &object);
    xpc_release(object);
    xpc_object_t object = 0;
    if (v29 < 0) {
      operator delete(__p[0]);
    }
    xpc_release(v26);
    xpc_object_t v26 = 0;
  }
  else if (*(unsigned char *)(a1 + 112))
  {
    xpc_object_t v22 = xpc_int64_create(*(void *)(a1 + 104));
    if (!v22) {
      xpc_object_t v22 = xpc_null_create();
    }
    sub_100058DB0(__p, "validity");
    if (v29 >= 0) {
      BOOL v18 = __p;
    }
    else {
      BOOL v18 = (void **)__p[0];
    }
    uint64_t v24 = a5;
    uint64_t v25 = v18;
    sub_100035E70((uint64_t)&v24, &v22, &v23);
    xpc_release(v23);
    xpc_object_t v23 = 0;
    if (v29 < 0) {
      operator delete(__p[0]);
    }
    xpc_release(v22);
    xpc_object_t v22 = 0;
  }
  if (a2[23] < 0) {
    a2 = *(const char **)a2;
  }
  xpc_object_t v20 = xpc_string_create(a2);
  if (!v20) {
    xpc_object_t v20 = xpc_null_create();
  }
  sub_100058DB0(__p, "data");
  if (v29 >= 0) {
    uint64_t v19 = __p;
  }
  else {
    uint64_t v19 = (void **)__p[0];
  }
  uint64_t v24 = a5;
  uint64_t v25 = v19;
  sub_100035E70((uint64_t)&v24, &v20, &v21);
  xpc_release(v21);
  xpc_object_t v21 = 0;
  if (v29 < 0) {
    operator delete(__p[0]);
  }
  xpc_release(v20);
}

void sub_100B1A8B4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  xpc_release(v24);
  sub_10017143C(v23);
  _Unwind_Resume(a1);
}

capabilities::ct *sub_100B1A964@<X0>(void *a1@<X8>)
{
  uint64_t result = (capabilities::ct *)sub_10004D710();
  if (result)
  {
    uint64_t result = (capabilities::ct *)capabilities::ct::supportsTEMS(result);
    if (result)
    {
      *a1 = 0;
      a1[1] = 0;
      operator new();
    }
  }
  *a1 = 0;
  a1[1] = 0;
  return result;
}

void sub_100B1ACC8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, dispatch_object_t object, dispatch_object_t a10, void *__p, std::__shared_weak_count *a12, int a13, __int16 a14, char a15, char a16, dispatch_object_t a17)
{
  if (a17) {
    (*((void (**)(dispatch_object_t))a17->isa + 1))(a17);
  }
  if (a12) {
    sub_10004D2C8(a12);
  }
  sub_10004D2C8(v17);
  _Unwind_Resume(a1);
}

uint64_t sub_100B1AE34(uint64_t a1)
{
  *(void *)a1 = off_101A3B530;
  uint64_t v6 = (void **)(a1 + 96);
  sub_1001F1FAC(&v6);
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 88);
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 72);
  if (v3) {
    sub_10004D2C8(v3);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 56);
  if (v4) {
    sub_10004D2C8(v4);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 40));
  sub_100087E88((void *)(a1 + 8));
  return a1;
}

void sub_100B1AEC8(uint64_t a1)
{
  sub_100B1AE34(a1);

  operator delete();
}

void sub_100B1AF00(uint64_t a1, dispatch_object_t object)
{
  if (object)
  {
    dispatch_retain(object);
    dispatch_group_enter(object);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

uint64_t sub_100B1B000(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 32);
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 8);
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  return a1;
}

void *sub_100B1B03C(void *a1, uint64_t a2)
{
  uint64_t v4 = operator new(0x40uLL);
  v4[1] = 0;
  void v4[2] = 0;
  *uint64_t v4 = off_101A3B5E8;
  sub_100B1B224((uint64_t)v6, a2);
  *((_WORD *)v4 + 12) = 0;
  sub_100B1B224((uint64_t)(v4 + 4), (uint64_t)v6);
  uint64_t result = sub_100B1B2BC(v6);
  *a1 = v4 + 3;
  a1[1] = v4;
  return result;
}

void sub_100B1B0F4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100B1B2BC((uint64_t *)va);
  std::__shared_weak_count::~__shared_weak_count(v2);
  operator delete(v4);
  _Unwind_Resume(a1);
}

void sub_100B1B11C(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A3B5E8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100B1B13C(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A3B5E8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void *sub_100B1B190(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 56);
  if (v2)
  {
    if (*(unsigned char *)(a1 + 24)) {
      BOOL v3 = *(unsigned char *)(a1 + 25) == 0;
    }
    else {
      BOOL v3 = 1;
    }
    BOOL v5 = v3;
    (*(void (**)(uint64_t, BOOL *))(*(void *)v2 + 48))(v2, &v5);
  }

  return sub_100B1B2BC((void *)(a1 + 32));
}

uint64_t sub_100B1B224(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

void *sub_100B1B2BC(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void sub_100B1B344(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100B1B37C(uint64_t a1)
{
}

uint64_t sub_100B1B398(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_100B1B3DC(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void sub_100B1B408(ServiceManager::Service *this)
{
  *(void *)this = off_101A3B698;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }

  ServiceManager::Service::~Service(this);
}

void sub_100B1B464(ServiceManager::Service *this)
{
  *(void *)this = off_101A3B698;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  ServiceManager::Service::~Service(this);

  operator delete();
}

void *sub_100B1B4D4@<X0>(void *a1@<X8>)
{
  return sub_100058DB0(a1, "ATController");
}

unsigned char *sub_100B1B4E4@<X0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  uint64_t v2 = operator new(1uLL);
  *a1 = v2;
  unsigned char *v2 = 0;
  uint64_t result = v2 + 1;
  a1[1] = result;
  a1[2] = result;
  return result;
}

void sub_100B1B520(uint64_t a1, dispatch_object_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v3 = *a2;
  if (*a2)
  {
    dispatch_retain(*a2);
    dispatch_group_enter(v3);
    sub_100B1AF00(v2, v3);
  }
  uint64_t v4 = *(void *)(a1 + 8);

  sub_100B1AF00(v4, 0);
}

uint64_t sub_100B1B5A4()
{
  return 0;
}

uint64_t sub_100B1B5AC()
{
  return 1;
}

uint64_t sub_100B1B5B4()
{
  return 0;
}

void sub_100B1B5C0(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(*(void *)(a1 + 8) + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100B1B6A0(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(*(void *)(a1 + 8) + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

uint64_t *sub_100B1B780(void **a1)
{
  uint64_t v1 = *a1;
  uint64_t v19 = a1;
  xpc_object_t v20 = v1;
  uint64_t v2 = (void *)*v1;
  Registry::createRestModuleOneTimeUseConnection(&v22, *(Registry **)(*v1 + 64));
  ctu::RestModule::connect();
  if (v23) {
    sub_10004D2C8(v23);
  }
  sub_1001F0320((uint64_t)(v2 + 12));
  uint64_t v3 = v2[6];
  uint64_t v4 = v1[1];
  dispatch_group_t group = v4;
  if (v4)
  {
    dispatch_retain(v4);
    dispatch_group_enter(v4);
  }
  (*(void (**)(uint64_t, dispatch_group_t *))(*(void *)v3 + 16))(v3, &group);
  if (group)
  {
    dispatch_group_leave(group);
    if (group) {
      dispatch_release(group);
    }
  }
  BOOL v5 = (std::__shared_weak_count *)v2[2];
  if (!v5 || (uint64_t v6 = v2[1], (v7 = std::__shared_weak_count::lock(v5)) == 0)) {
    sub_100088B9C();
  }
  long long v8 = v7;
  p_shared_weak_owners = &v7->__shared_weak_owners_;
  atomic_fetch_add_explicit(&v7->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v7);
  uint64_t v10 = v2[6];
  atomic_fetch_add_explicit(p_shared_weak_owners, 1uLL, memory_order_relaxed);
  int v30 = 0;
  xpc_object_t v11 = operator new(0x20uLL);
  void *v11 = off_101A3B718;
  v11[1] = v6;
  v11[2] = v8;
  v11[3] = v2;
  int v30 = v11;
  LODWORD(v27[0]) = 0;
  xpc_object_t v12 = sub_100B1BD98((uint64_t **)(v10 + 48), 0, v27);
  sub_100B1BA88(v12 + 5, v29);
  sub_100B1C680(v29);
  uint64_t v13 = v2[6];
  atomic_fetch_add_explicit(&v8->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  uint64_t v28 = 0;
  int v14 = operator new(0x20uLL);
  void *v14 = off_101A3B7A8;
  v14[1] = v6;
  uint64_t v14[2] = v8;
  v14[3] = v2;
  uint64_t v28 = v14;
  sub_100B1C704((void *)(v13 + 72), v27);
  sub_100B1D08C(v27);
  uint64_t v15 = v2[6];
  atomic_fetch_add_explicit(&v8->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  xpc_object_t v26 = 0;
  std::chrono::system_clock::time_point v16 = operator new(0x20uLL);
  void *v16 = off_101A3B838;
  v16[1] = v6;
  v16[2] = v8;
  v16[3] = v2;
  xpc_object_t v26 = v16;
  int v24 = 2;
  char v17 = sub_100B1BD98((uint64_t **)(v15 + 48), 2, &v24);
  sub_100B1BA88(v17 + 5, v25);
  sub_100B1C680(v25);
  std::__shared_weak_count::__release_weak(v8);
  sub_100088C88((uint64_t *)&v20);
  return sub_100046B58((uint64_t *)&v19);
}

void sub_100B1B9EC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, dispatch_group_t group, uint64_t a13, uint64_t a14, uint64_t a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, char a20)
{
  std::__shared_weak_count::__release_weak(v20);
  std::__shared_weak_count::__release_weak(v20);
  sub_100088C88(&a11);
  sub_100046B58(&a10);
  _Unwind_Resume(a1);
}

void *sub_100B1BA88(void *a1, void *a2)
{
  uint64_t v3 = (void *)a2[3];
  if (v3)
  {
    if (v3 == a2)
    {
      long long v8 = v7;
      (*(void (**)(void *, void *))(*a2 + 24))(a2, v7);
    }
    else
    {
      long long v8 = (void *)(*(uint64_t (**)(void *))(*v3 + 16))(v3);
    }
  }
  else
  {
    long long v8 = 0;
  }
  if (v7 != a1)
  {
    uint64_t v4 = v8;
    BOOL v5 = (void *)a1[3];
    if (v8 == v7)
    {
      if (v5 == a1)
      {
        memset(v9, 0, sizeof(v9));
        (*(void (**)(void *, void *))(v7[0] + 24))(v7, v9);
        (*(void (**)(void *))(*v8 + 32))(v8);
        long long v8 = 0;
        (*(void (**)(void, void *))(*(void *)a1[3] + 24))(a1[3], v7);
        (*(void (**)(void))(*(void *)a1[3] + 32))(a1[3]);
        a1[3] = 0;
        long long v8 = v7;
        (*(void (**)(void *, void *))(v9[0] + 24))(v9, a1);
        (*(void (**)(void *))(v9[0] + 32))(v9);
      }
      else
      {
        (*(void (**)(void *, void *))(v7[0] + 24))(v7, a1);
        (*(void (**)(void *))(*v8 + 32))(v8);
        long long v8 = (void *)a1[3];
      }
      a1[3] = a1;
    }
    else if (v5 == a1)
    {
      (*(void (**)(void *, void *))(*a1 + 24))(a1, v7);
      (*(void (**)(void))(*(void *)a1[3] + 32))(a1[3]);
      a1[3] = v8;
      long long v8 = v7;
    }
    else
    {
      long long v8 = (void *)a1[3];
      a1[3] = v4;
    }
  }
  sub_100B1C680(v7);
  return a1;
}

void sub_100B1BD8C(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_10006A6AC(a1);
}

uint64_t **sub_100B1BD98(uint64_t **a1, int a2, _DWORD *a3)
{
  uint64_t v6 = a1 + 1;
  BOOL v5 = a1[1];
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        uint64_t v7 = (uint64_t **)v5;
        int v8 = *((_DWORD *)v5 + 8);
        if (v8 <= a2) {
          break;
        }
        BOOL v5 = *v7;
        uint64_t v6 = v7;
        if (!*v7) {
          goto LABEL_9;
        }
      }
      if (v8 >= a2) {
        break;
      }
      BOOL v5 = v7[1];
      if (!v5)
      {
        uint64_t v6 = v7 + 1;
        goto LABEL_9;
      }
    }
  }
  else
  {
    uint64_t v7 = a1 + 1;
LABEL_9:
    uint64_t v9 = (uint64_t *)v7;
    uint64_t v7 = (uint64_t **)operator new(0x48uLL);
    *((_DWORD *)v7 + 8) = *a3;
    v7[8] = 0;
    std::__shared_weak_count *v7 = 0;
    v7[1] = 0;
    _OWORD v7[2] = v9;
    *uint64_t v6 = (uint64_t *)v7;
    uint64_t v10 = (uint64_t *)**a1;
    xpc_object_t v11 = (uint64_t *)v7;
    if (v10)
    {
      *a1 = v10;
      xpc_object_t v11 = *v6;
    }
    sub_100046C90(a1[1], v11);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
  }
  return v7;
}

void *sub_100B1BE68(void *a1)
{
  *a1 = off_101A3B718;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_100B1BEB4(void *a1)
{
  *a1 = off_101A3B718;
  uint64_t v1 = (std::__shared_weak_count *)a1[2];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

void *sub_100B1BF20(void *a1)
{
  uint64_t result = operator new(0x20uLL);
  uint64_t v4 = a1[1];
  uint64_t v3 = a1[2];
  *uint64_t result = off_101A3B718;
  result[1] = v4;
  result[2] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  result[3] = a1[3];
  return result;
}

void *sub_100B1BF84(void *result, void *a2)
{
  uint64_t v3 = result[1];
  uint64_t v2 = result[2];
  *a2 = off_101A3B718;
  a2[1] = v3;
  a2[2] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  a2[3] = result[3];
  return result;
}

void sub_100B1BFC4(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_100B1BFD4(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[2];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete(__p);
}

void *sub_100B1C014(void *a1, uint64_t a2)
{
  sub_100B1C600((uint64_t)v47, a2);
  uint64_t v3 = (std::__shared_weak_count *)a1[2];
  if (v3)
  {
    uint64_t v4 = (void *)a1[3];
    BOOL v5 = std::__shared_weak_count::lock(v3);
    if (v5)
    {
      uint64_t v6 = v5;
      if (a1[1])
      {
        uint64_t v28 = v5;
        sub_100B1B224((uint64_t)v48, (uint64_t)v47);
        uint64_t v36 = 0;
        xpc_object_t v37 = 0;
        sub_100B1B224((uint64_t)v49, (uint64_t)v48);
        sub_100B1B03C(&v36, (uint64_t)v49);
        sub_100B1B2BC(v49);
        uint64_t v7 = (xpc_object_t *)v4[12];
        int v8 = (xpc_object_t *)v4[13];
        if (v7 != v8)
        {
          char v29 = (xpc_object_t *)v4[13];
          uint64_t v9 = "kCallStatus";
          do
          {
            xpc_object_t v10 = *v7;
            if (*v7)
            {
              xpc_retain(*v7);
              xpc_object_t v35 = v10;
            }
            else
            {
              xpc_object_t v10 = xpc_null_create();
              xpc_object_t v35 = v10;
              if (!v10)
              {
                xpc_object_t v10 = 0;
                xpc_object_t v35 = xpc_null_create();
                goto LABEL_10;
              }
            }
            xpc_retain(v10);
LABEL_10:
            __p[0] = &v35;
            __p[1] = (void *)v9;
            sub_100048BAC((uint64_t)__p, &object);
            int v12 = xpc::dyn_cast_or_default((xpc *)&object, 0, v11);
            xpc_release(object);
            __p[0] = &v35;
            __p[1] = "kCallDirectionMobileOriginated";
            sub_100048BAC((uint64_t)__p, &object);
            char v14 = xpc::dyn_cast_or_default((xpc *)&object, 0, v13);
            xpc_release(object);
            __p[0] = &v35;
            __p[1] = "kCallSubType";
            sub_100048BAC((uint64_t)__p, &object);
            char v16 = xpc::dyn_cast_or_default((xpc *)&object, (const object *)1, v15);
            xpc_release(object);
            if (v12 == 5) {
              char v17 = v14;
            }
            else {
              char v17 = 1;
            }
            if ((v17 & 1) == 0 && (v16 == 8 || v16 == 4))
            {
              *(_OWORD *)long long v33 = 0u;
              long long v34 = 0u;
              *(_OWORD *)long long __p = 0u;
              v50[0] = &v35;
              v50[1] = "kUuid";
              sub_100048BAC((uint64_t)v50, v44);
              xpc_object_t object = 0;
              uint64_t v39 = 0;
              xpc_object_t v40 = 0;
              xpc::dyn_cast_or_default();
              if (SHIBYTE(v40) < 0) {
                operator delete(object);
              }
              if (SHIBYTE(v33[0]) < 0) {
                operator delete(__p[0]);
              }
              *(_OWORD *)long long __p = v30;
              v33[0] = v31;
              xpc_release(v44[0]);
              BOOL v18 = (std::__shared_weak_count *)v4[2];
              if (!v18 || (v19 = v9, xpc_object_t v20 = (void *)v4[1], (v21 = std::__shared_weak_count::lock(v18)) == 0)) {
                sub_100088B9C();
              }
              uint64_t v22 = v21;
              p_shared_weak_owners = &v21->__shared_weak_owners_;
              atomic_fetch_add_explicit(&v21->__shared_weak_owners_, 1uLL, memory_order_relaxed);
              sub_10004D2C8(v21);
              atomic_fetch_add_explicit(p_shared_weak_owners, 1uLL, memory_order_relaxed);
              uint64_t v25 = v36;
              int v24 = v37;
              uint64_t v31 = v4;
              if (v37) {
                atomic_fetch_add_explicit(&v37->__shared_owners_, 1uLL, memory_order_relaxed);
              }
              xpc_object_t v46 = 0;
              write_rest_value();
              sub_100058DB0(v44, "/cc/requests/answer");
              xpc_object_t v43 = v46;
              xpc_object_t v46 = xpc_null_create();
              xpc_object_t object = v20;
              uint64_t v39 = v22;
              long long v30 = 0uLL;
              xpc_object_t v40 = v4;
              uint64_t v41 = v25;
              char v42 = v24;
              xpc_object_t v51 = 0;
              xpc_object_t v26 = operator new(0x30uLL);
              *xpc_object_t v26 = off_101A3B8B8;
              v26[1] = v20;
              xpc_object_t object = 0;
              uint64_t v39 = 0;
              v26[2] = v22;
              v26[3] = v4;
              v26[4] = v25;
              v26[5] = v24;
              uint64_t v41 = 0;
              char v42 = 0;
              xpc_object_t v51 = v26;
              ctu::RestModule::sendRequest();
              sub_10003F600(v50);
              xpc_release(v43);
              uint64_t v9 = v19;
              xpc_object_t v43 = 0;
              if (v45 < 0) {
                operator delete(v44[0]);
              }
              xpc_release(v46);
              int v8 = v29;
              std::__shared_weak_count::__release_weak(v22);
              if (SHIBYTE(v34) < 0) {
                operator delete(v33[1]);
              }
              if (SHIBYTE(v33[0]) < 0) {
                operator delete(__p[0]);
              }
            }
            xpc_release(v35);
            xpc_release(v10);
            ++v7;
          }
          while (v7 != v8);
        }
        if (v37) {
          sub_10004D2C8(v37);
        }
        sub_100B1B2BC(v48);
        uint64_t v6 = v28;
      }
      sub_10004D2C8(v6);
    }
  }
  return sub_100B1B2BC(v47);
}

void sub_100B1C428(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, std::__shared_weak_count *a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,xpc_object_t a26,uint64_t a27,uint64_t a28,xpc_object_t a29,uint64_t a30,int a31,__int16 a32,char a33,char a34,uint64_t a35,uint64_t a36,xpc_object_t a37,void *__p,uint64_t a39,int a40,__int16 a41,char a42,char a43,xpc_object_t object)
{
  sub_100B1B2BC((void *)(v44 - 160));
  sub_100B1B2BC((void *)(v44 - 192));
  sub_10004D2C8(a9);
  sub_100B1B2BC((void *)(v44 - 224));
  _Unwind_Resume(a1);
}

uint64_t sub_100B1C5B4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100B1C5F4()
{
}

uint64_t sub_100B1C600(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (void *)(a2 + 24);
  uint64_t v4 = *(void *)(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(*(void *)*v3 + 24))(*v3, a1);
      return a1;
    }
    *(void *)(a1 + 24) = v4;
  }
  else
  {
    uint64_t v3 = (void *)(a1 + 24);
  }
  void *v3 = 0;
  return a1;
}

void *sub_100B1C680(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *sub_100B1C704(void *a1, void *a2)
{
  uint64_t v3 = (void *)a2[3];
  if (v3)
  {
    if (v3 == a2)
    {
      int v8 = v7;
      (*(void (**)(void *, void *))(*a2 + 24))(a2, v7);
    }
    else
    {
      int v8 = (void *)(*(uint64_t (**)(void *))(*v3 + 16))(v3);
    }
  }
  else
  {
    int v8 = 0;
  }
  if (v7 != a1)
  {
    uint64_t v4 = v8;
    BOOL v5 = (void *)a1[3];
    if (v8 == v7)
    {
      if (v5 == a1)
      {
        memset(v9, 0, sizeof(v9));
        (*(void (**)(void *, void *))(v7[0] + 24))(v7, v9);
        (*(void (**)(void *))(*v8 + 32))(v8);
        int v8 = 0;
        (*(void (**)(void, void *))(*(void *)a1[3] + 24))(a1[3], v7);
        (*(void (**)(void))(*(void *)a1[3] + 32))(a1[3]);
        a1[3] = 0;
        int v8 = v7;
        (*(void (**)(void *, void *))(v9[0] + 24))(v9, a1);
        (*(void (**)(void *))(v9[0] + 32))(v9);
      }
      else
      {
        (*(void (**)(void *, void *))(v7[0] + 24))(v7, a1);
        (*(void (**)(void *))(*v8 + 32))(v8);
        int v8 = (void *)a1[3];
      }
      a1[3] = a1;
    }
    else if (v5 == a1)
    {
      (*(void (**)(void *, void *))(*a1 + 24))(a1, v7);
      (*(void (**)(void))(*(void *)a1[3] + 32))(a1[3]);
      a1[3] = v8;
      int v8 = v7;
    }
    else
    {
      int v8 = (void *)a1[3];
      a1[3] = v4;
    }
  }
  sub_100B1D08C(v7);
  return a1;
}

void sub_100B1CA08(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_10006A6AC(a1);
}

void *sub_100B1CA14(void *a1)
{
  *a1 = off_101A3B7A8;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_100B1CA60(void *a1)
{
  *a1 = off_101A3B7A8;
  uint64_t v1 = (std::__shared_weak_count *)a1[2];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

void *sub_100B1CACC(void *a1)
{
  uint64_t result = operator new(0x20uLL);
  uint64_t v4 = a1[1];
  uint64_t v3 = a1[2];
  *uint64_t result = off_101A3B7A8;
  result[1] = v4;
  result[2] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  result[3] = a1[3];
  return result;
}

void *sub_100B1CB30(void *result, void *a2)
{
  uint64_t v3 = result[1];
  uint64_t v2 = result[2];
  *a2 = off_101A3B7A8;
  a2[1] = v3;
  a2[2] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  a2[3] = result[3];
  return result;
}

void sub_100B1CB70(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_100B1CB80(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[2];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete(__p);
}

void sub_100B1CBC0(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = *(void **)a2;
  unint64_t v5 = *(void *)(a2 + 8);
  *(_DWORD *)uint64_t v19 = *(_DWORD *)(a2 + 16);
  *(_DWORD *)&v19[3] = *(_DWORD *)(a2 + 19);
  int v6 = *(char *)(a2 + 23);
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  *(void *)a2 = 0;
  sub_100B1C600((uint64_t)v46, a3);
  uint64_t v7 = (std::__shared_weak_count *)a1[2];
  if (v7)
  {
    uint64_t v8 = a1[3];
    uint64_t v9 = std::__shared_weak_count::lock(v7);
    if (v9)
    {
      xpc_object_t v10 = v9;
      if (a1[1])
      {
        if (v6 < 0)
        {
          sub_10004FC84(&__str, v4, v5);
        }
        else
        {
          __str.__r_.__value_.__r.__words[0] = (std::string::size_type)v4;
          __str.__r_.__value_.__l.__size_ = v5;
          LODWORD(__str.__r_.__value_.__r.__words[2]) = *(_DWORD *)v19;
          *(_DWORD *)((char *)&__str.__r_.__value_.__r.__words[2] + 3) = *(_DWORD *)&v19[3];
          *((unsigned char *)&__str.__r_.__value_.__s + 23) = v6;
        }
        sub_100B1B224((uint64_t)v47, (uint64_t)v46);
        uint64_t v36 = 0;
        xpc_object_t v37 = 0;
        sub_100B1B224((uint64_t)v48, (uint64_t)v47);
        sub_100B1B03C(&v36, (uint64_t)v48);
        sub_100B1B2BC(v48);
        long long v32 = 0u;
        uint64_t v33 = 0;
        long long v31 = 0u;
        *(_OWORD *)char v29 = 0u;
        long long v30 = 0u;
        *(_OWORD *)long long __p = 0u;
        uint64_t v34 = 1;
        uint64_t v35 = 0;
        CFTypeRef cf = 0;
        CFTypeRef cf = CFUUIDCreate(kCFAllocatorDefault);
        std::string::operator=((std::string *)&v29[1], &__str);
        CFTypeRef v26 = cf;
        if (cf) {
          CFRetain(cf);
        }
        sub_101328F44((CFUUIDRef *)&v26, (uint64_t)&v38);
        if (SHIBYTE(v29[0]) < 0) {
          operator delete(__p[0]);
        }
        *(_OWORD *)long long __p = v38;
        v29[0] = v39;
        HIBYTE(v39) = 0;
        LOBYTE(v38) = 0;
        sub_10012577C(&v26);
        uint64_t v11 = *(std::__shared_weak_count **)(v8 + 16);
        if (!v11 || (uint64_t v12 = *(void *)(v8 + 8), (v13 = std::__shared_weak_count::lock(v11)) == 0)) {
          sub_100088B9C();
        }
        char v14 = v13;
        p_shared_weak_owners = &v13->__shared_weak_owners_;
        atomic_fetch_add_explicit(&v13->__shared_weak_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v13);
        uint64_t v21 = v12;
        uint64_t v22 = v14;
        atomic_fetch_add_explicit(p_shared_weak_owners, 1uLL, memory_order_relaxed);
        uint64_t v17 = v36;
        char v16 = v37;
        uint64_t v23 = v8;
        uint64_t v24 = v36;
        uint64_t v25 = v37;
        if (v37) {
          atomic_fetch_add_explicit(&v37->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        xpc_object_t v45 = 0;
        write_rest_value();
        sub_100058DB0(&v43, "/cc/requests/dial");
        xpc_object_t object = v45;
        xpc_object_t v45 = xpc_null_create();
        *(void *)&long long v38 = v12;
        *((void *)&v38 + 1) = v14;
        uint64_t v21 = 0;
        uint64_t v22 = 0;
        uint64_t v39 = (void *)v8;
        uint64_t v40 = v17;
        uint64_t v41 = v16;
        uint64_t v24 = 0;
        uint64_t v25 = 0;
        xpc_object_t v50 = 0;
        BOOL v18 = operator new(0x30uLL);
        *BOOL v18 = off_101A3B938;
        v18[1] = v12;
        long long v38 = 0uLL;
        void v18[2] = v14;
        v18[3] = v8;
        v18[4] = v17;
        v18[5] = v16;
        uint64_t v40 = 0;
        uint64_t v41 = 0;
        xpc_object_t v50 = v18;
        ctu::RestModule::sendRequest();
        sub_10003F600(v49);
        xpc_release(object);
        xpc_object_t object = 0;
        if (v44 < 0) {
          operator delete(v43);
        }
        xpc_release(v45);
        std::__shared_weak_count::__release_weak(v14);
        sub_10012577C(&cf);
        if (SBYTE7(v32) < 0) {
          operator delete((void *)v31);
        }
        if (SHIBYTE(v30) < 0) {
          operator delete(v29[1]);
        }
        if (SHIBYTE(v29[0]) < 0) {
          operator delete(__p[0]);
        }
        if (v16) {
          sub_10004D2C8(v16);
        }
        sub_100B1B2BC(v47);
        if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__str.__r_.__value_.__l.__data_);
        }
      }
      sub_10004D2C8(v10);
    }
  }
  sub_100B1B2BC(v46);
  if (v6 < 0) {
    operator delete(v4);
  }
}

void sub_100B1CF18(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,char a22,int a23,__int16 a24,char a25,char a26,int a27,__int16 a28,char a29,char a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,char a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,xpc_object_t object)
{
  sub_10004D2C8(v51);
  sub_100B1B2BC((void *)(v53 - 216));
  if (v52 < 0) {
    operator delete(v50);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100B1D040(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100B1D080()
{
}

void *sub_100B1D08C(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *sub_100B1D110(void *a1)
{
  *a1 = off_101A3B838;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_100B1D15C(void *a1)
{
  *a1 = off_101A3B838;
  uint64_t v1 = (std::__shared_weak_count *)a1[2];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

void *sub_100B1D1C8(void *a1)
{
  uint64_t result = operator new(0x20uLL);
  uint64_t v4 = a1[1];
  uint64_t v3 = a1[2];
  *uint64_t result = off_101A3B838;
  result[1] = v4;
  result[2] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  result[3] = a1[3];
  return result;
}

void *sub_100B1D22C(void *result, void *a2)
{
  uint64_t v3 = result[1];
  uint64_t v2 = result[2];
  *a2 = off_101A3B838;
  a2[1] = v3;
  a2[2] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  a2[3] = result[3];
  return result;
}

void sub_100B1D26C(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_100B1D27C(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[2];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete(__p);
}

void *sub_100B1D2BC(void *a1, uint64_t a2)
{
  sub_100B1C600((uint64_t)v40, a2);
  uint64_t v3 = (std::__shared_weak_count *)a1[2];
  if (v3)
  {
    uint64_t v4 = (void *)a1[3];
    unint64_t v5 = std::__shared_weak_count::lock(v3);
    if (v5)
    {
      int v6 = v5;
      if (a1[1])
      {
        uint64_t v21 = v5;
        sub_100B1B224((uint64_t)v41, (uint64_t)v40);
        uint64_t v29 = 0;
        long long v30 = 0;
        sub_100B1B224((uint64_t)v42, (uint64_t)v41);
        sub_100B1B03C(&v29, (uint64_t)v42);
        sub_100B1B2BC(v42);
        uint64_t v7 = (xpc_object_t *)v4[12];
        for (unsigned int i = (xpc_object_t *)v4[13]; v7 != i; ++v7)
        {
          xpc_object_t v9 = *v7;
          if (*v7)
          {
            xpc_retain(*v7);
            xpc_object_t v28 = v9;
          }
          else
          {
            xpc_object_t v9 = xpc_null_create();
            xpc_object_t v28 = v9;
            if (!v9)
            {
              xpc_object_t v9 = 0;
              xpc_object_t v28 = xpc_null_create();
              goto LABEL_9;
            }
          }
          xpc_retain(v9);
LABEL_9:
          long long __p = &v28;
          long long v32 = "kCallSubType";
          sub_100048BAC((uint64_t)&__p, object);
          char v11 = xpc::dyn_cast_or_default((xpc *)object, (const object *)1, v10);
          xpc_release(object[0]);
          if (v11 == 4)
          {
            *(_OWORD *)CFTypeRef v26 = 0u;
            long long v27 = 0u;
            v43[0] = &v28;
            v43[1] = "kUuid";
            sub_100048BAC((uint64_t)v43, v37);
            long long __p = 0;
            long long v32 = 0;
            uint64_t v33 = 0;
            xpc::dyn_cast_or_default();
            if (SHIBYTE(v33) < 0) {
              operator delete(__p);
            }
            if (SBYTE7(v27) < 0) {
              operator delete(v26[0]);
            }
            *(_OWORD *)CFTypeRef v26 = *(_OWORD *)object;
            *(void *)&long long v27 = v23;
            HIBYTE(v23) = 0;
            LOBYTE(object[0]) = 0;
            xpc_release(v37[0]);
            uint64_t v12 = (std::__shared_weak_count *)v4[2];
            if (!v12 || (BOOL v13 = (void *)v4[1], (v14 = std::__shared_weak_count::lock(v12)) == 0)) {
              sub_100088B9C();
            }
            uint64_t v15 = v14;
            p_shared_weak_owners = &v14->__shared_weak_owners_;
            atomic_fetch_add_explicit(&v14->__shared_weak_owners_, 1uLL, memory_order_relaxed);
            sub_10004D2C8(v14);
            object[0] = v13;
            object[1] = v15;
            atomic_fetch_add_explicit(p_shared_weak_owners, 1uLL, memory_order_relaxed);
            uint64_t v18 = v29;
            uint64_t v17 = v30;
            uint64_t v23 = v4;
            uint64_t v24 = v29;
            uint64_t v25 = v30;
            if (v30) {
              atomic_fetch_add_explicit(&v30->__shared_owners_, 1uLL, memory_order_relaxed);
            }
            xpc_object_t v39 = 0;
            write_rest_value();
            sub_100058DB0(v37, "/cc/requests/end_this_call");
            xpc_object_t v36 = v39;
            xpc_object_t v39 = xpc_null_create();
            long long __p = v13;
            long long v32 = (const char *)v15;
            object[0] = 0;
            object[1] = 0;
            uint64_t v33 = v4;
            uint64_t v34 = v18;
            uint64_t v35 = v17;
            uint64_t v24 = 0;
            uint64_t v25 = 0;
            char v44 = 0;
            uint64_t v19 = operator new(0x30uLL);
            void *v19 = off_101A3B9B8;
            v19[1] = v13;
            long long __p = 0;
            long long v32 = 0;
            uint64_t v19[2] = v15;
            v19[3] = v4;
            v19[4] = v18;
            v19[5] = v17;
            uint64_t v34 = 0;
            uint64_t v35 = 0;
            char v44 = v19;
            ctu::RestModule::sendRequest();
            sub_10003F600(v43);
            xpc_release(v36);
            xpc_object_t v36 = 0;
            if (v38 < 0) {
              operator delete(v37[0]);
            }
            xpc_release(v39);
            std::__shared_weak_count::__release_weak(v15);
            if (SBYTE7(v27) < 0) {
              operator delete(v26[0]);
            }
          }
          xpc_release(v28);
          xpc_release(v9);
        }
        if (v30) {
          sub_10004D2C8(v30);
        }
        sub_100B1B2BC(v41);
        int v6 = v21;
      }
      sub_10004D2C8(v6);
    }
  }
  return sub_100B1B2BC(v40);
}

void sub_100B1D628(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, std::__shared_weak_count *a9, uint64_t a10, uint64_t a11, xpc_object_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,uint64_t a24,xpc_object_t object,uint64_t a26,uint64_t a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33,uint64_t a34,uint64_t a35,xpc_object_t a36,xpc_object_t a37,uint64_t a38,int a39,__int16 a40,char a41,char a42,xpc_object_t a43,uint64_t a44)
{
  sub_100B1B2BC((void *)(v44 - 160));
  sub_100B1B2BC((void *)(v44 - 192));
  sub_10004D2C8(a9);
  sub_100B1B2BC(&a44);
  _Unwind_Resume(a1);
}

uint64_t sub_100B1D784(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100B1D7C4()
{
}

void sub_100B1D7D0(uint64_t a1)
{
  uint64_t v1 = a1;
  (*(void (**)(void))(**(void **)(**(void **)a1 + 48) + 24))(*(void *)(**(void **)a1 + 48));
  operator delete();
}

void sub_100B1D848()
{
}

void sub_100B1D874(uint64_t **a1)
{
  uint64_t v1 = **a1;
  uint64_t v2 = *(void *)(v1 + 48);
  dispatch_group_t group = 0;
  (*(void (**)(uint64_t, dispatch_group_t *))(*(void *)v2 + 32))(v2, &group);
  if (group)
  {
    dispatch_group_leave(group);
    if (group) {
      dispatch_release(group);
    }
  }
  uint64_t v3 = *(void *)(v1 + 48);
  v12[3] = 0;
  LODWORD(v11[0]) = 0;
  uint64_t v4 = sub_100B1BD98((uint64_t **)(v3 + 48), 0, v11);
  sub_100B1BA88(v4 + 5, v12);
  sub_100B1C680(v12);
  uint64_t v5 = *(void *)(v1 + 48);
  v11[3] = 0;
  sub_100B1C704((void *)(v5 + 72), v11);
  sub_100B1D08C(v11);
  uint64_t v6 = *(void *)(v1 + 48);
  v10[3] = 0;
  int v9 = 2;
  uint64_t v7 = sub_100B1BD98((uint64_t **)(v6 + 48), 2, &v9);
  sub_100B1BA88(v7 + 5, v10);
  sub_100B1C680(v10);
  ctu::RestModule::disconnect((ctu::RestModule *)(v1 + 80));
  operator delete();
}

void sub_100B1D9C0(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_group_t group, uint64_t a11, char a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16)
{
}

void *sub_100B1DA38(void *a1)
{
  *a1 = off_101A3B8B8;
  uint64_t v2 = (std::__shared_weak_count *)a1[5];
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)a1[2];
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  return a1;
}

void sub_100B1DA90(void *a1)
{
  *a1 = off_101A3B8B8;
  uint64_t v2 = (std::__shared_weak_count *)a1[5];
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)a1[2];
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }

  operator delete();
}

char *sub_100B1DB08(uint64_t a1)
{
  uint64_t result = (char *)operator new(0x30uLL);
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 16);
  *(void *)uint64_t result = off_101A3B8B8;
  *((void *)result + 1) = v4;
  *((void *)result + 2) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  *(_OWORD *)(result + 24) = *(_OWORD *)(a1 + 24);
  uint64_t v5 = *(void *)(a1 + 40);
  *((void *)result + 5) = v5;
  if (v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_100B1DB84(uint64_t result, uint64_t a2)
{
  uint64_t v3 = *(void *)(result + 8);
  uint64_t v2 = *(void *)(result + 16);
  *(void *)a2 = off_101A3B8B8;
  *(void *)(a2 + 8) = v3;
  *(void *)(a2 + 16) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(result + 24);
  uint64_t v4 = *(void *)(result + 40);
  *(void *)(a2 + 40) = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100B1DBDC(uint64_t a1)
{
}

void sub_100B1DBE4(void *a1)
{
  sub_100AB6848((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_100B1DC20(void *a1, xpc_object_t *a2)
{
  xpc_object_t object = *a2;
  *a2 = xpc_null_create();
  int v4 = xpc::dyn_cast_or_default((xpc *)&object, 0, v3);
  uint64_t v5 = (std::__shared_weak_count *)a1[2];
  if (v5)
  {
    uint64_t v6 = a1[3];
    uint64_t v7 = std::__shared_weak_count::lock(v5);
    if (v7)
    {
      uint64_t v8 = v7;
      if (a1[1])
      {
        int v9 = *(NSObject **)(v6 + 40);
        if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v10 = "failed!!";
          if (v4) {
            uint64_t v10 = "succeeded!";
          }
          *(_DWORD *)uint64_t buf = 136315138;
          uint64_t v15 = v10;
          _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I ATA %s!", buf, 0xCu);
        }
        char v11 = (unsigned char *)a1[4];
        if (*v11)
        {
          if (v11[1]) {
            char v12 = v4;
          }
          else {
            char v12 = 0;
          }
          v11[1] = v12;
        }
        else
        {
          unsigned char *v11 = 1;
          v11[1] = v4;
        }
      }
      sub_10004D2C8(v8);
    }
  }
  xpc_release(object);
}

void sub_100B1DD5C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

uint64_t sub_100B1DD8C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100B1DDCC()
{
}

void *sub_100B1DDD8(void *a1)
{
  *a1 = off_101A3B938;
  uint64_t v2 = (std::__shared_weak_count *)a1[5];
  if (v2) {
    sub_10004D2C8(v2);
  }
  BOOL v3 = (std::__shared_weak_count *)a1[2];
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  return a1;
}

void sub_100B1DE30(void *a1)
{
  *a1 = off_101A3B938;
  uint64_t v2 = (std::__shared_weak_count *)a1[5];
  if (v2) {
    sub_10004D2C8(v2);
  }
  BOOL v3 = (std::__shared_weak_count *)a1[2];
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }

  operator delete();
}

char *sub_100B1DEA8(uint64_t a1)
{
  uint64_t result = (char *)operator new(0x30uLL);
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 16);
  *(void *)uint64_t result = off_101A3B938;
  *((void *)result + 1) = v4;
  *((void *)result + 2) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  *(_OWORD *)(result + 24) = *(_OWORD *)(a1 + 24);
  uint64_t v5 = *(void *)(a1 + 40);
  *((void *)result + 5) = v5;
  if (v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_100B1DF24(uint64_t result, uint64_t a2)
{
  uint64_t v3 = *(void *)(result + 8);
  uint64_t v2 = *(void *)(result + 16);
  *(void *)a2 = off_101A3B938;
  *(void *)(a2 + 8) = v3;
  *(void *)(a2 + 16) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(result + 24);
  uint64_t v4 = *(void *)(result + 40);
  *(void *)(a2 + 40) = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100B1DF7C(uint64_t a1)
{
}

void sub_100B1DF84(void *a1)
{
  sub_100AB6848((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_100B1DFC0(void *a1, xpc_object_t *a2)
{
  xpc_object_t object = *a2;
  *a2 = xpc_null_create();
  int v4 = xpc::dyn_cast_or_default((xpc *)&object, 0, v3);
  uint64_t v5 = (std::__shared_weak_count *)a1[2];
  if (v5)
  {
    uint64_t v6 = a1[3];
    uint64_t v7 = std::__shared_weak_count::lock(v5);
    if (v7)
    {
      uint64_t v8 = v7;
      if (a1[1])
      {
        int v9 = *(NSObject **)(v6 + 40);
        if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v10 = "failed!!";
          if (v4) {
            uint64_t v10 = "succeeded!";
          }
          *(_DWORD *)uint64_t buf = 136315138;
          uint64_t v15 = v10;
          _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I ATD %s!", buf, 0xCu);
        }
        char v11 = (unsigned char *)a1[4];
        if (*v11)
        {
          if (v11[1]) {
            char v12 = v4;
          }
          else {
            char v12 = 0;
          }
          v11[1] = v12;
        }
        else
        {
          unsigned char *v11 = 1;
          v11[1] = v4;
        }
      }
      sub_10004D2C8(v8);
    }
  }
  xpc_release(object);
}

void sub_100B1E0FC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

uint64_t sub_100B1E12C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100B1E16C()
{
}

void *sub_100B1E178(void *a1)
{
  *a1 = off_101A3B9B8;
  uint64_t v2 = (std::__shared_weak_count *)a1[5];
  if (v2) {
    sub_10004D2C8(v2);
  }
  BOOL v3 = (std::__shared_weak_count *)a1[2];
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  return a1;
}

void sub_100B1E1D0(void *a1)
{
  *a1 = off_101A3B9B8;
  uint64_t v2 = (std::__shared_weak_count *)a1[5];
  if (v2) {
    sub_10004D2C8(v2);
  }
  BOOL v3 = (std::__shared_weak_count *)a1[2];
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }

  operator delete();
}

char *sub_100B1E248(uint64_t a1)
{
  uint64_t result = (char *)operator new(0x30uLL);
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 16);
  *(void *)uint64_t result = off_101A3B9B8;
  *((void *)result + 1) = v4;
  *((void *)result + 2) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  *(_OWORD *)(result + 24) = *(_OWORD *)(a1 + 24);
  uint64_t v5 = *(void *)(a1 + 40);
  *((void *)result + 5) = v5;
  if (v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_100B1E2C4(uint64_t result, uint64_t a2)
{
  uint64_t v3 = *(void *)(result + 8);
  uint64_t v2 = *(void *)(result + 16);
  *(void *)a2 = off_101A3B9B8;
  *(void *)(a2 + 8) = v3;
  *(void *)(a2 + 16) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(result + 24);
  uint64_t v4 = *(void *)(result + 40);
  *(void *)(a2 + 40) = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100B1E31C(uint64_t a1)
{
}

void sub_100B1E324(void *a1)
{
  sub_100AB6848((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_100B1E360(void *a1, xpc_object_t *a2)
{
  xpc_object_t object = *a2;
  *a2 = xpc_null_create();
  int v4 = xpc::dyn_cast_or_default((xpc *)&object, 0, v3);
  uint64_t v5 = (std::__shared_weak_count *)a1[2];
  if (v5)
  {
    uint64_t v6 = a1[3];
    uint64_t v7 = std::__shared_weak_count::lock(v5);
    if (v7)
    {
      uint64_t v8 = v7;
      if (a1[1])
      {
        int v9 = *(NSObject **)(v6 + 40);
        if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v10 = "failed!!";
          if (v4) {
            uint64_t v10 = "succeeded!";
          }
          *(_DWORD *)uint64_t buf = 136315138;
          uint64_t v15 = v10;
          _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I AT+CHUP %s!", buf, 0xCu);
        }
        char v11 = (unsigned char *)a1[4];
        if (*v11)
        {
          if (v11[1]) {
            char v12 = v4;
          }
          else {
            char v12 = 0;
          }
          v11[1] = v12;
        }
        else
        {
          unsigned char *v11 = 1;
          v11[1] = v4;
        }
      }
      sub_10004D2C8(v8);
    }
  }
  xpc_release(object);
}

void sub_100B1E49C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

uint64_t sub_100B1E4CC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100B1E50C()
{
}

void sub_100B1E518(void *a1@<X0>, uint64_t **a2@<X1>, uint64_t *a3@<X2>, void *a4@<X8>)
{
  uint64_t v8 = (const char *)kCtLoggingSystemName;
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&buf, kCtLoggingSystemName, "cu.message");
  int v9 = *(id *)&buf_4[4];
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&buf);
  if (*a2 && **a2)
  {
    uint64_t v25 = a1;
    id v10 = [objc_alloc((Class)CUMessageSession) initWithTemplate:**a2];
    if (v10)
    {
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v11 = **a2;
        int buf = 134218240;
        *(void *)buf_4 = v11;
        *(_WORD *)&buf_4[8] = 2048;
        *(void *)&buf_4[10] = v10;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "template session: %p, actual session: %p", (uint8_t *)&buf, 0x16u);
      }
      char v12 = operator new(0x20uLL);
      v12[1] = 0;
      _OWORD v12[2] = 0;
      *char v12 = off_1019AF4C8;
      v12[3] = v10;
      *a4 = 0;
      a4[1] = 0;
      BOOL v13 = (char *)operator new(0x80uLL);
      *((void *)v13 + 1) = 0;
      *((void *)v13 + 2) = 0;
      *(void *)BOOL v13 = off_101A3BBD0;
      char v14 = v13 + 24;
      uint64_t v15 = *a3;
      uint64_t v24 = a3[1];
      *a3 = 0;
      a3[1] = 0;
      uint64_t v23 = v15;
      *((void *)v13 + 3) = off_101A3BA38;
      dispatch_queue_attr_make_with_qos_class(0, QOS_CLASS_USER_INTERACTIVE, 0);
      char v16 = (id)objc_claimAutoreleasedReturnValue();
      dispatch_queue_t v17 = dispatch_queue_create("CoreUtilsMessageSessionHandler", v16);

      uint64_t v18 = v17;
      *((void *)v13 + 4) = 0;
      *((void *)v13 + 5) = 0;
      uint64_t v19 = v18;
      *((void *)v13 + 6) = v19;
      *((void *)v13 + 7) = 0;

      ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(v13 + 64), v8, "cu.message");
      *((void *)v13 + 3) = off_101A3BA38;
      uint64_t v20 = v25[1];
      *((void *)v13 + 9) = *v25;
      *((void *)v13 + 10) = v20;
      if (v20) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v20 + 8), 1uLL, memory_order_relaxed);
      }
      *((void *)v13 + 11) = v12 + 3;
      *((void *)v13 + 12) = v12;
      *((void *)v13 + 13) = v23;
      *((void *)v13 + 14) = v24;
      v13[120] = 0;
      *((void *)v13 + 3) = off_101A3BC20;
      uint64_t v21 = (std::__shared_weak_count *)*((void *)v13 + 5);
      if (v21)
      {
        if (v21->__shared_owners_ != -1)
        {
          *a4 = v14;
          a4[1] = v13;
          atomic_fetch_add_explicit((atomic_ullong *volatile)v13 + 1, 1uLL, memory_order_relaxed);
LABEL_20:
          if (std::__shared_weak_count::lock(v21)) {
            operator new();
          }
LABEL_23:
          sub_100088B9C();
        }
        atomic_fetch_add_explicit((atomic_ullong *volatile)v13 + 1, 1uLL, memory_order_relaxed);
        atomic_fetch_add_explicit((atomic_ullong *volatile)v13 + 2, 1uLL, memory_order_relaxed);
        *((void *)v13 + 4) = v14;
        *((void *)v13 + 5) = v13;
        std::__shared_weak_count::__release_weak(v21);
      }
      else
      {
        atomic_fetch_add_explicit((atomic_ullong *volatile)v13 + 1, 1uLL, memory_order_relaxed);
        atomic_fetch_add_explicit((atomic_ullong *volatile)v13 + 2, 1uLL, memory_order_relaxed);
        *((void *)v13 + 4) = v14;
        *((void *)v13 + 5) = v13;
      }
      sub_10004D2C8((std::__shared_weak_count *)v13);
      uint64_t v21 = (std::__shared_weak_count *)*((void *)v13 + 5);
      *a4 = v14;
      a4[1] = v13;
      atomic_fetch_add_explicit((atomic_ullong *volatile)v13 + 1, 1uLL, memory_order_relaxed);
      if (!v21) {
        goto LABEL_23;
      }
      goto LABEL_20;
    }
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      uint64_t v22 = **a2;
      int buf = 134217984;
      *(void *)buf_4 = v22;
      _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "failed to create session from template session (%p)", (uint8_t *)&buf, 0xCu);
    }
    *a4 = 0;
    a4[1] = 0;
  }
  else
  {
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      LOWORD(buf) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "invalid parameters", (uint8_t *)&buf, 2u);
    }
    *a4 = 0;
    a4[1] = 0;
  }
}

void sub_100B1E9AC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_100B1EA34(uint64_t a1)
{
  *(void *)a1 = off_101A3BA38;
  [**(id **)(a1 + 64) setInvalidationHandler:0];
  [**(id **)(a1 + 64) invalidate];
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 88);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  BOOL v3 = *(std::__shared_weak_count **)(a1 + 72);
  if (v3) {
    sub_10004D2C8(v3);
  }
  int v4 = *(std::__shared_weak_count **)(a1 + 56);
  if (v4) {
    sub_10004D2C8(v4);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 40));
  sub_1004FDE68(a1 + 8);

  CoreUtilsMessageSessionHandlerInterface::~CoreUtilsMessageSessionHandlerInterface((CoreUtilsMessageSessionHandlerInterface *)a1);
}

void sub_100B1EAE0(uint64_t a1)
{
  sub_100B1EA34(a1);

  operator delete();
}

void sub_100B1EB18(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t v2 = *(std::__shared_weak_count **)(v1 + 88);
  if (v2)
  {
    BOOL v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      int v4 = v3;
      uint64_t v5 = *(void *)(v1 + 80);
      if (v5)
      {
        uint64_t v6 = sub_100200FB4((id *)(v1 + 40));
        if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)uint64_t v7 = 0;
          _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I session got invalidated", v7, 2u);
        }

        (*(void (**)(uint64_t))(*(void *)v5 + 16))(v5);
      }
      sub_10004D2C8(v4);
    }
  }
}

void sub_100B1EBDC(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_100B1EBF0(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 96))
  {
    [**(id **)(a1 + 64) activate];
    uint64_t v2 = sub_100200FB4((id *)(a1 + 40));
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)BOOL v3 = 0;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I session activated", v3, 2u);
    }

    *(unsigned char *)(a1 + 96) = 1;
  }
}

uint64_t sub_100B1EC7C(uint64_t a1)
{
  sub_100B202F4((void *)(a1 + 56));
  uint64_t v2 = *(void **)(a1 + 48);
  *(void *)(a1 + 48) = 0;

  if (*(char *)(a1 + 47) < 0) {
    operator delete(*(void **)(a1 + 24));
  }
  BOOL v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  return a1;
}

void sub_100B1ECD8(uint64_t a1, int a2, void *a3, void *a4)
{
  id v7 = a3;
  id v8 = a4;
  if (*(void *)(a1 + 64))
  {
    int v9 = *(std::__shared_weak_count **)(a1 + 80);
    if (v9)
    {
      uint64_t v10 = *(void *)(a1 + 32);
      uint64_t v11 = std::__shared_weak_count::lock(v9);
      if (v11 && *(void *)(a1 + 72))
      {
        char v12 = (id *)(v10 + 40);
        BOOL v13 = sub_100200FB4(v12);
        if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
        {
          char v14 = (void *)(a1 + 88);
          if (*(char *)(a1 + 111) < 0) {
            char v14 = (void *)*v14;
          }
          *(_DWORD *)int buf = 136315394;
          *(void *)&uint8_t buf[4] = v14;
          *(_WORD *)&unsigned char buf[12] = 1024;
          *(_DWORD *)&buf[14] = a2;
          _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I received response for request: %s, error %d", buf, 0x12u);
        }

        uint64_t v15 = *(void *)(a1 + 112);
        if (v15)
        {
          if ((*(unsigned int (**)(uint64_t))(*(void *)v15 + 24))(v15))
          {
            char v16 = sub_100200FB4(v12);
            if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)int buf = 0;
              _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I response has already timed out", buf, 2u);
            }

LABEL_23:
            sub_10004D2C8(v11);
            goto LABEL_24;
          }
          (*(void (**)(void))(**(void **)(a1 + 112) + 16))(*(void *)(a1 + 112));
        }
        *(void *)int buf = v8;
        sub_100B2025C((uint64_t)&buf[8], a1 + 40);
        sub_100200FB4((id *)(a1 + 128));
        id v19 = (id)objc_claimAutoreleasedReturnValue();
        operator new();
      }
    }
    else
    {
      uint64_t v11 = 0;
    }
    ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)buf, kCtLoggingSystemName, "cu.message");
    uint64_t v18 = *(id *)&buf[8];
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)int buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "weak reference is invalid", buf, 2u);
    }

    if (v11) {
      goto LABEL_23;
    }
  }
  else
  {
    dispatch_queue_t v17 = sCTOsLogDefault;
    if (os_log_type_enabled(sCTOsLogDefault, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)int buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "no response callback", buf, 2u);
    }
  }
LABEL_24:
}

void sub_100B1F01C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  if (a2)
  {

    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

id sub_100B1F080(void *a1, uint64_t a2)
{
  sub_100B2025C((uint64_t)(a1 + 5), a2 + 40);
  uint64_t v4 = *(void *)(a2 + 80);
  a1[9] = *(void *)(a2 + 72);
  a1[10] = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 16), 1uLL, memory_order_relaxed);
  }
  uint64_t v5 = a1 + 11;
  if (*(char *)(a2 + 111) < 0)
  {
    sub_10004FC84(v5, *(void **)(a2 + 88), *(void *)(a2 + 96));
  }
  else
  {
    long long v6 = *(_OWORD *)(a2 + 88);
    a1[13] = *(void *)(a2 + 104);
    *(_OWORD *)uint64_t v5 = v6;
  }
  uint64_t v7 = *(void *)(a2 + 120);
  a1[14] = *(void *)(a2 + 112);
  a1[15] = v7;
  if (v7) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v7 + 8), 1uLL, memory_order_relaxed);
  }
  id result = *(id *)(a2 + 128);
  a1[16] = result;
  return result;
}

void sub_100B1F124(_Unwind_Exception *a1)
{
  uint64_t v4 = *(std::__shared_weak_count **)(v1 + 80);
  if (v4) {
    std::__shared_weak_count::__release_weak(v4);
  }
  sub_100B202F4(v2);
  _Unwind_Resume(a1);
}

void *sub_100B1F144(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 128);
  *(void *)(a1 + 128) = 0;

  BOOL v3 = *(std::__shared_weak_count **)(a1 + 120);
  if (v3) {
    sub_10004D2C8(v3);
  }
  if (*(char *)(a1 + 111) < 0) {
    operator delete(*(void **)(a1 + 88));
  }
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 80);
  if (v4) {
    std::__shared_weak_count::__release_weak(v4);
  }

  return sub_100B202F4((void *)(a1 + 40));
}

void sub_100B1F1B4(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7 = a2;
  id v8 = a3;
  id v9 = a4;
  uint64_t v10 = *(std::__shared_weak_count **)(a1 + 48);
  if (v10)
  {
    uint64_t v11 = *(void *)(a1 + 32);
    char v12 = std::__shared_weak_count::lock(v10);
    if (v12 && *(void *)(a1 + 40))
    {
      BOOL v13 = sub_100200FB4((id *)(v11 + 40));
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
      {
        char v14 = (void *)(a1 + 56);
        if (*(char *)(a1 + 79) < 0) {
          char v14 = (void *)*v14;
        }
        *(_DWORD *)int buf = 136315138;
        *(void *)&uint8_t buf[4] = v14;
        _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I received request: %s", buf, 0xCu);
      }

      uint64_t v18 = v8;
      *(void *)int buf = 0;
      if (v8) {
        CFRetain(v8);
      }
      uint64_t v15 = *(void *)(a1 + 104);
      if (!v15) {
        sub_10007B600();
      }
      (*(void (**)(unsigned char *__return_ptr))(*(void *)v15 + 48))(buf);
      sub_100057D78(&v18);
      id v16 = *(id *)buf;
      if (v9) {
        (*((void (**)(id, void, void, id))v9 + 2))(v9, 0, 0, v16);
      }

      sub_100057D78((const void **)buf);
      goto LABEL_19;
    }
  }
  else
  {
    char v12 = 0;
  }
  if (!os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR))
  {
    if (!v9) {
      goto LABEL_18;
    }
    goto LABEL_17;
  }
  dispatch_queue_t v17 = (void *)(a1 + 56);
  if (*(char *)(a1 + 79) < 0) {
    dispatch_queue_t v17 = (void *)*v17;
  }
  *(_DWORD *)int buf = 136446210;
  *(void *)&uint8_t buf[4] = v17;
  _os_log_error_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR, "invalid msg.handler. %{public}s", buf, 0xCu);
  if (v9) {
LABEL_17:
  }
    (*((void (**)(id, uint64_t, void, void))v9 + 2))(v9, 4294960582, 0, 0);
LABEL_18:
  if (v12) {
LABEL_19:
  }
    sub_10004D2C8(v12);
}

void sub_100B1F3F0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);

  sub_100057D78((const void **)va);
  sub_10004D2C8(v6);

  _Unwind_Resume(a1);
}

uint64_t sub_100B1F44C(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 48);
  *(void *)(a1 + 40) = *(void *)(a2 + 40);
  *(void *)(a1 + 48) = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 16), 1uLL, memory_order_relaxed);
  }
  if (*(char *)(a2 + 79) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 56), *(void **)(a2 + 56), *(void *)(a2 + 64));
  }
  else
  {
    long long v5 = *(_OWORD *)(a2 + 56);
    *(void *)(a1 + 72) = *(void *)(a2 + 72);
    *(_OWORD *)(a1 + 56) = v5;
  }
  return sub_100B20C18(a1 + 80, a2 + 80);
}

void sub_100B1F4CC(_Unwind_Exception *exception_object)
{
  BOOL v3 = *(std::__shared_weak_count **)(v1 + 48);
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  _Unwind_Resume(exception_object);
}

void sub_100B1F4FC(uint64_t a1)
{
  sub_100B20B94((void *)(a1 + 80));
  if (*(char *)(a1 + 79) < 0) {
    operator delete(*(void **)(a1 + 56));
  }
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 48);
  if (v2)
  {
    std::__shared_weak_count::__release_weak(v2);
  }
}

void sub_100B1F558(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7 = a2;
  id v8 = a3;
  id v9 = a4;
  uint64_t v10 = *(std::__shared_weak_count **)(a1 + 48);
  if (!v10)
  {
    char v12 = 0;
    goto LABEL_13;
  }
  uint64_t v11 = *(void *)(a1 + 32);
  char v12 = std::__shared_weak_count::lock(v10);
  if (!v12 || !*(void *)(a1 + 40))
  {
LABEL_13:
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR))
    {
      uint64_t v18 = (void *)(a1 + 56);
      if (*(char *)(a1 + 79) < 0) {
        uint64_t v18 = (void *)*v18;
      }
      *(_DWORD *)int buf = 136446210;
      CFTypeRef v26 = v18;
      _os_log_error_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR, "invalid msg.handler. %{public}s", buf, 0xCu);
      if (!v9)
      {
LABEL_16:
        if (!v12) {
          goto LABEL_27;
        }
        goto LABEL_26;
      }
    }
    else if (!v9)
    {
      goto LABEL_16;
    }
    (*((void (**)(id, uint64_t, void, void))v9 + 2))(v9, 4294960582, 0, 0);
    goto LABEL_16;
  }
  BOOL v13 = sub_100200FB4((id *)(v11 + 40));
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    char v14 = (void *)(a1 + 56);
    if (*(char *)(a1 + 79) < 0) {
      char v14 = (void *)*v14;
    }
    *(_DWORD *)int buf = 136315138;
    CFTypeRef v26 = v14;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I received request: %s", buf, 0xCu);
  }

  uint64_t v22 = v8;
  if (v8) {
    CFRetain(v8);
  }
  id v19 = objc_retainBlock(v9);
  if (*(char *)(a1 + 79) < 0)
  {
    sub_10004FC84(&__p, *(void **)(a1 + 56), *(void *)(a1 + 64));
  }
  else
  {
    long long __p = *(_OWORD *)(a1 + 56);
    uint64_t v21 = *(void *)(a1 + 72);
  }
  uint64_t v24 = 0;
  uint64_t v15 = operator new(0x28uLL);
  void *v15 = off_101A3BD60;
  v15[1] = v19;
  id v16 = v15 + 2;
  if (SHIBYTE(v21) < 0)
  {
    sub_10004FC84(v16, (void *)__p, *((unint64_t *)&__p + 1));
  }
  else
  {
    *(_OWORD *)id v16 = __p;
    void v15[4] = v21;
  }
  uint64_t v24 = v15;
  uint64_t v17 = *(void *)(a1 + 104);
  if (!v17) {
    sub_10007B600();
  }
  (*(void (**)(uint64_t, uint64_t, const void **, void *))(*(void *)v17 + 48))(v17, a1 + 56, &v22, v23);
  sub_10010E020(v23);
  if (SHIBYTE(v21) < 0) {
    operator delete((void *)__p);
  }

  sub_100057D78(&v22);
LABEL_26:
  sub_10004D2C8(v12);
LABEL_27:
}

void sub_100B1F820(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v11 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);

  operator delete(v6);
  sub_100B1F8AC((uint64_t)va);
  sub_100057D78((const void **)va1);
  sub_10004D2C8(v5);

  _Unwind_Resume(a1);
}

uint64_t sub_100B1F8AC(uint64_t a1)
{
  if (*(char *)(a1 + 31) < 0) {
    operator delete(*(void **)(a1 + 8));
  }

  return a1;
}

uint64_t sub_100B1F8E8(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 48);
  *(void *)(a1 + 40) = *(void *)(a2 + 40);
  *(void *)(a1 + 48) = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 16), 1uLL, memory_order_relaxed);
  }
  if (*(char *)(a2 + 79) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 56), *(void **)(a2 + 56), *(void *)(a2 + 64));
  }
  else
  {
    long long v5 = *(_OWORD *)(a2 + 56);
    *(void *)(a1 + 72) = *(void *)(a2 + 72);
    *(_OWORD *)(a1 + 56) = v5;
  }
  return sub_100B210BC(a1 + 80, a2 + 80);
}

void sub_100B1F968(_Unwind_Exception *exception_object)
{
  BOOL v3 = *(std::__shared_weak_count **)(v1 + 48);
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  _Unwind_Resume(exception_object);
}

void sub_100B1F998(uint64_t a1)
{
  sub_10010E0A4((void *)(a1 + 80));
  if (*(char *)(a1 + 79) < 0) {
    operator delete(*(void **)(a1 + 56));
  }
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 48);
  if (v2)
  {
    std::__shared_weak_count::__release_weak(v2);
  }
}

void sub_100B1F9F4(uint64_t a1, uint64_t a2, void **a3, id *a4, void **a5, uint64_t a6)
{
  uint64_t v14 = a1;
  if (*(char *)(a2 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)long long __p = *(_OWORD *)a2;
    __p[2] = *(void **)(a2 + 16);
  }
  __p[3] = *a3;
  *a3 = 0;
  id v11 = *a4;
  uint64_t v12 = *a5;
  __p[4] = v11;
  __p[5] = v12;
  sub_100B21154((uint64_t)&v16, a6);
  BOOL v13 = *(std::__shared_weak_count **)(a1 + 16);
  if (v13)
  {
    if (std::__shared_weak_count::lock(v13)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100B1FC20(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

void sub_100B1FC34(unint64_t a1, long long **a2, uint64_t a3)
{
  v6[0] = a1;
  v6[1] = 0uLL;
  sub_1000302C0((char *)v6 + 8, *a2, a2[1], 0xAAAAAAAAAAAAAAABLL * (((char *)a2[1] - (char *)*a2) >> 3));
  sub_100B21B2C((uint64_t)&v7, a3);
  long long v5 = *(std::__shared_weak_count **)(a1 + 16);
  if (v5)
  {
    if (std::__shared_weak_count::lock(v5)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100B1FDCC(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_10006A6AC(a1);
}

void sub_100B1FDE4(unint64_t a1, long long **a2, uint64_t a3)
{
  v6[0] = a1;
  v6[1] = 0uLL;
  sub_1000302C0((char *)v6 + 8, *a2, a2[1], 0xAAAAAAAAAAAAAAABLL * (((char *)a2[1] - (char *)*a2) >> 3));
  sub_100B21FC4((uint64_t)&v7, a3);
  long long v5 = *(std::__shared_weak_count **)(a1 + 16);
  if (v5)
  {
    if (std::__shared_weak_count::lock(v5)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100B1FF7C(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_10006A6AC(a1);
}

void sub_100B1FF94(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100B2008C(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A3BBD0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100B200AC(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A3BBD0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100B20100(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_100B2012C(uint64_t a1)
{
  sub_100B1EA34(a1);

  operator delete();
}

uint64_t *sub_100B20164(uint64_t *a1)
{
  uint64_t v1 = *a1;
  long long v5 = a1;
  uint64_t v6 = v1;
  uint64_t v2 = *(void *)v1;
  [**(id **)(*(void *)v1 + 64) setLabel:@"com.apple.commcenter"];
  BOOL v3 = sub_100200FB4((id *)(v2 + 24));
  [**(id **)(v2 + 64) setDispatchQueue:v3];

  v7[0] = _NSConcreteStackBlock;
  v7[1] = 3221225472;
  _OWORD v7[2] = sub_100B1EB18;
  void v7[3] = &unk_1019A1BF8;
  void v7[4] = v2;
  [**(id **)(v2 + 64) setInvalidationHandler:v7];
  sub_1000E3958(&v6);
  return sub_100046B58((uint64_t *)&v5);
}

void sub_100B20234(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v4 = va_arg(va1, void);

  sub_1000E3958((uint64_t *)va1);
  sub_100046B58((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100B2025C(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

void *sub_100B202F4(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t sub_100B20378(uint64_t a1)
{
  *(void *)a1 = off_101A3BC78;
  sub_100B202F4((void *)(a1 + 64));
  uint64_t v2 = *(void **)(a1 + 56);
  *(void *)(a1 + 56) = 0;

  if (*(char *)(a1 + 55) < 0) {
    operator delete(*(void **)(a1 + 32));
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 24);
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  return a1;
}

void sub_100B203EC(uint64_t a1)
{
  *(void *)a1 = off_101A3BC78;
  sub_100B202F4((void *)(a1 + 64));
  uint64_t v2 = *(void **)(a1 + 56);
  *(void *)(a1 + 56) = 0;

  if (*(char *)(a1 + 55) < 0) {
    operator delete(*(void **)(a1 + 32));
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 24);
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }

  operator delete();
}

void *sub_100B20480(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t v2 = operator new(0x60uLL);
  void *v2 = off_101A3BC78;
  sub_100B207C8((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_100B204D4(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100B204E8(uint64_t a1, void *a2)
{
  *a2 = off_101A3BC78;
  return sub_100B207C8((uint64_t)(a2 + 1), a1 + 8);
}

void sub_100B20514(uint64_t a1)
{
}

void sub_100B2051C(void *a1)
{
  sub_100B208A4((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_100B20558(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 24);
  if (v2)
  {
    uint64_t v3 = *(void *)(a1 + 8);
    uint64_t v4 = std::__shared_weak_count::lock(v2);
    if (v4 && *(void *)(a1 + 16))
    {
      long long v5 = sub_100200FB4((id *)(v3 + 40));
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v6 = a1 + 32;
        if (*(char *)(a1 + 55) < 0) {
          uint64_t v6 = *(void *)(a1 + 32);
        }
        *(_DWORD *)int buf = 136315138;
        v10[0] = v6;
        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I response timed out for request: %s", buf, 0xCu);
      }

      sub_100B2025C((uint64_t)buf, a1 + 64);
      sub_100200FB4((id *)(a1 + 56));
      id v7 = (id)objc_claimAutoreleasedReturnValue();
      operator new();
    }
  }
  else
  {
    uint64_t v4 = 0;
  }
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)buf, kCtLoggingSystemName, "cu.message");
  uint64_t v8 = *(id *)((char *)v10 + 4);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)int buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "weak reference is invalid", buf, 2u);
  }

  if (v4) {
    sub_10004D2C8(v4);
  }
}

void sub_100B20744(_Unwind_Exception *exception_object, int a2)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100B2077C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100B207BC()
{
}

uint64_t sub_100B207C8(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = *(_OWORD *)a2;
  uint64_t v4 = *(void *)(a2 + 16);
  *(void *)(a1 + 16) = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 16), 1uLL, memory_order_relaxed);
  }
  if (*(char *)(a2 + 47) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 24), *(void **)(a2 + 24), *(void *)(a2 + 32));
  }
  else
  {
    long long v5 = *(_OWORD *)(a2 + 24);
    *(void *)(a1 + 40) = *(void *)(a2 + 40);
    *(_OWORD *)(a1 + 24) = v5;
  }
  *(void *)(a1 + 48) = *(id *)(a2 + 48);
  sub_100B2025C(a1 + 56, a2 + 56);
  return a1;
}

void sub_100B20860(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(std::__shared_weak_count **)(v1 + 16);
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  _Unwind_Resume(exception_object);
}

void sub_100B208A4(uint64_t a1)
{
  sub_100B202F4((void *)(a1 + 56));
  uint64_t v2 = *(void **)(a1 + 48);
  *(void *)(a1 + 48) = 0;

  if (*(char *)(a1 + 47) < 0) {
    operator delete(*(void **)(a1 + 24));
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (v3)
  {
    std::__shared_weak_count::__release_weak(v3);
  }
}

void **sub_100B20914(void **a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    sub_100B202F4(v2);
    operator delete();
  }
  return a1;
}

void **sub_100B2095C(void *a1)
{
  uint64_t v2 = a1;
  uint64_t v3 = 0;
  sub_100B209C0(a1[3], 1);
  sub_100057D78(&v3);
  return sub_100B20914(&v2);
}

void sub_100B209A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, const void *a10)
{
}

uint64_t sub_100B209C0(uint64_t a1, char a2)
{
  char v3 = a2;
  if (!a1) {
    sub_10007B600();
  }
  return (*(uint64_t (**)(uint64_t, char *))(*(void *)a1 + 48))(a1, &v3);
}

void sub_100B20A14(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100B20A4C(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_100B20A7C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t *sub_100B20AC0(uint64_t *result)
{
  uint64_t v1 = *result;
  *uint64_t result = 0;
  if (v1)
  {
    sub_100B202F4((void *)(v1 + 8));

    operator delete();
  }
  return result;
}

uint64_t *sub_100B20B18(uint64_t a1)
{
  uint64_t v4 = a1;
  uint64_t v2 = *(const void **)a1;
  long long v5 = v2;
  if (v2) {
    CFRetain(v2);
  }
  sub_100B209C0(*(void *)(a1 + 32), 0);
  sub_100057D78(&v5);
  return sub_100B20AC0(&v4);
}

void sub_100B20B78(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, const void *a10)
{
}

void *sub_100B20B94(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t sub_100B20C18(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

uint64_t sub_100B20CB0(uint64_t a1)
{
  *(void *)a1 = off_101A3BD60;
  if (*(char *)(a1 + 39) < 0) {
    operator delete(*(void **)(a1 + 16));
  }

  return a1;
}

void sub_100B20D08(uint64_t a1)
{
  *(void *)a1 = off_101A3BD60;
  if (*(char *)(a1 + 39) < 0) {
    operator delete(*(void **)(a1 + 16));
  }

  operator delete();
}

id *sub_100B20D80(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t v2 = (id *)operator new(0x28uLL);
  id *v2 = off_101A3BD60;
  sub_100B21000(v2 + 1, v1);
  return v2;
}

void sub_100B20DD4(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

id *sub_100B20DE8(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A3BD60;
  return sub_100B21000((id *)(a2 + 8), a1 + 8);
}

void sub_100B20E14(uint64_t a1)
{
}

void sub_100B20E1C(void *a1)
{
  sub_100B21078((uint64_t)a1 + 8);

  operator delete(a1);
}

const void **sub_100B20E58(uint64_t a1, void **a2)
{
  uint64_t v3 = *a2;
  uint64_t v8 = *a2;
  *a2 = 0;
  if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_INFO))
  {
    uint64_t v4 = a1 + 16;
    if (*(char *)(a1 + 39) < 0) {
      uint64_t v4 = *(void *)(a1 + 16);
    }
    *(_DWORD *)int buf = 136315138;
    uint64_t v10 = v4;
    _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_INFO, "sending response: %s", buf, 0xCu);
  }
  id v5 = v3;
  uint64_t v6 = *(void *)(a1 + 8);
  if (v6)
  {
    (*(void (**)(uint64_t, void, void, id))(v6 + 16))(v6, 0, 0, v5);
  }
  else if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)int buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR, "response callback doesn't exist", buf, 2u);
  }

  return sub_100057D78((const void **)&v8);
}

void sub_100B20F94(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);

  sub_100057D78((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100B20FB4(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101A3BDC0)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_100B20FF4()
{
  return &off_101A3BDC0;
}

id *sub_100B21000(id *a1, uint64_t a2)
{
  *a1 = objc_retainBlock(*(id *)a2);
  uint64_t v4 = a1 + 1;
  if (*(char *)(a2 + 31) < 0)
  {
    sub_10004FC84(v4, *(void **)(a2 + 8), *(void *)(a2 + 16));
  }
  else
  {
    long long v5 = *(_OWORD *)(a2 + 8);
    a1[3] = *(id *)(a2 + 24);
    *(_OWORD *)uint64_t v4 = v5;
  }
  return a1;
}

void sub_100B21064(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100B21078(uint64_t a1)
{
  if (*(char *)(a1 + 31) < 0) {
    operator delete(*(void **)(a1 + 8));
  }
  uint64_t v2 = *(void **)a1;
}

uint64_t sub_100B210BC(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

uint64_t sub_100B21154(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (void *)(a2 + 24);
  uint64_t v4 = *(void *)(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(*(void *)*v3 + 24))(*v3, a1);
      return a1;
    }
    *(void *)(a1 + 24) = v4;
  }
  else
  {
    uint64_t v3 = (void *)(a1 + 24);
  }
  void *v3 = 0;
  return a1;
}

uint64_t *sub_100B211D4(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v29 = a1;
  uint64_t v30 = v1;
  uint64_t v2 = *(void *)v1;
  if (*(char *)(v1 + 31) < 0)
  {
    sub_10004FC84(__dst, *(void **)(v1 + 8), *(void *)(v1 + 16));
  }
  else
  {
    long long v3 = *(_OWORD *)(v1 + 8);
    uint64_t v33 = *(void *)(v1 + 24);
    *(_OWORD *)std::string __dst = v3;
  }
  sub_100058198((const void **)&v31, (const void **)(v1 + 32));
  id v27 = *(id *)(v1 + 40);
  sub_100B2025C((uint64_t)v43, v1 + 56);
  sub_100B1EBF0(v2);
  uint64_t v4 = +[NSDictionary dictionary];
  if (v31) {
    long long v5 = sub_100080778;
  }
  else {
    long long v5 = 0;
  }
  if (v5)
  {
    uint64_t v6 = v31;

    uint64_t v4 = v6;
  }
  v39[0] = 0;
  v39[1] = 0;
  uint64_t v40 = 0;
  std::operator+<char>();
  id v7 = *(std::__shared_weak_count **)(v2 + 16);
  if (!v7 || (uint64_t v8 = *(std::__shared_weak_count **)(v2 + 8), (v9 = std::__shared_weak_count::lock(v7)) == 0)) {
    sub_100088B9C();
  }
  uint64_t v10 = v9;
  atomic_fetch_add_explicit(&v9->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v9);
  if (*(void *)(v1 + 48) && v43[3])
  {
    id v11 = sub_100200FB4((id *)(v2 + 40));
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v12 = v39;
      if (v40 < 0) {
        uint64_t v12 = (void **)v39[0];
      }
      uint64_t v13 = *(void *)(v1 + 48);
      *(_DWORD *)int buf = 136315394;
      *(void *)&uint8_t buf[4] = v12;
      *(_WORD *)&unsigned char buf[12] = 2048;
      *(void *)&buf[14] = v13;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I starting timer (%s) for %lld seconds", buf, 0x16u);
    }

    long long v60 = 0u;
    long long v61 = 0u;
    *(void *)&long long v54 = v2;
    *((void *)&v54 + 1) = v8;
    std::string v55 = v10;
    atomic_fetch_add_explicit(&v10->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    if (SHIBYTE(v33) < 0)
    {
      sub_10004FC84(&v56, __dst[0], (unint64_t)__dst[1]);
    }
    else
    {
      long long v56 = *(_OWORD *)__dst;
      uint64_t v57 = v33;
    }
    id v58 = v27;
    sub_100B2025C((uint64_t)v59, (uint64_t)v43);
    *((void *)&v61 + 1) = 0;
    uint64_t v14 = (char *)operator new(0x60uLL);
    *(void *)uint64_t v14 = off_101A3BC78;
    *(_OWORD *)(v14 + 8) = v54;
    *((void *)v14 + 3) = v55;
    *((void *)&v54 + 1) = 0;
    std::string v55 = 0;
    uint64_t v15 = v14 + 32;
    if (SHIBYTE(v57) < 0)
    {
      sub_10004FC84(v15, (void *)v56, *((unint64_t *)&v56 + 1));
    }
    else
    {
      *(_OWORD *)uint64_t v15 = v56;
      *((void *)v14 + 6) = v57;
    }
    *((void *)v14 + 7) = v58;
    sub_100B21154((uint64_t)(v14 + 64), (uint64_t)v59);
    *((void *)&v61 + 1) = v14;
    sub_100B202F4(v59);
    id v16 = v58;
    id v58 = 0;

    if (SHIBYTE(v57) < 0) {
      operator delete((void *)v56);
    }
    if (v55) {
      std::__shared_weak_count::__release_weak(v55);
    }
    uint64_t v38 = 0;
    Registry::getTimerService(&v36, *(Registry **)(v2 + 48));
    uint64_t v17 = v36;
    if (SHIBYTE(v40) < 0)
    {
      sub_10004FC84(v34, v39[0], (unint64_t)v39[1]);
    }
    else
    {
      *(_OWORD *)uint64_t v34 = *(_OWORD *)v39;
      uint64_t v35 = v40;
    }
    uint64_t v18 = 1000000 * *(void *)(v1 + 48);
    long long __p = *(_OWORD *)v34;
    uint64_t v42 = v35;
    v34[0] = 0;
    v34[1] = 0;
    uint64_t v35 = 0;
    sub_1000DA470((uint64_t)buf, (uint64_t)&v60);
    (*(void (**)(uint64_t *__return_ptr, uint64_t, long long *, uint64_t, uint64_t, void, unsigned char *))(*(void *)v17 + 40))(&v38, v17, &__p, 1, v18, 0, buf);
    sub_10003B34C(buf);
    if (SHIBYTE(v42) < 0) {
      operator delete((void *)__p);
    }
    if (SHIBYTE(v35) < 0) {
      operator delete(v34[0]);
    }
    if (v37) {
      sub_10004D2C8(v37);
    }
    uint64_t v38 = 0;
    operator new();
  }
  id v19 = sub_100200FB4((id *)(v2 + 40));
  if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v20 = __dst;
    if (v33 < 0) {
      uint64_t v20 = (void **)__dst[0];
    }
    *(_DWORD *)int buf = 136315138;
    *(void *)&uint8_t buf[4] = v20;
    _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#I sending request: %s", buf, 0xCu);
  }

  uint64_t v21 = **(void ***)(v2 + 64);
  if (v33 >= 0) {
    uint64_t v22 = __dst;
  }
  else {
    uint64_t v22 = (void **)__dst[0];
  }
  uint64_t v23 = +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v22, v27, v29, v30);
  *(void *)int buf = _NSConcreteStackBlock;
  *(void *)&uint8_t buf[8] = 3321888768;
  *(void *)&uint8_t buf[16] = sub_100B1ECD8;
  xpc_object_t v45 = &unk_101A3BA68;
  uint64_t v46 = v2;
  sub_100B2025C((uint64_t)v47, (uint64_t)v43);
  void v47[4] = v8;
  uint64_t v48 = v10;
  atomic_fetch_add_explicit(&v10->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  if (SHIBYTE(v33) < 0)
  {
    sub_10004FC84(&v49, __dst[0], (unint64_t)__dst[1]);
  }
  else
  {
    long long v49 = *(_OWORD *)__dst;
    uint64_t v50 = v33;
  }
  uint64_t v51 = 0;
  int v52 = 0;
  id v24 = v28;
  id v53 = v24;
  [v21 sendRequestID:v23 options:0 request:v4 responseHandler:buf];

  id v25 = v53;
  id v53 = 0;

  if (v52) {
    sub_10004D2C8(v52);
  }
  if (SHIBYTE(v50) < 0) {
    operator delete((void *)v49);
  }
  if (v48) {
    std::__shared_weak_count::__release_weak(v48);
  }
  sub_100B202F4(v47);
  std::__shared_weak_count::__release_weak(v10);
  if (SHIBYTE(v40) < 0) {
    operator delete(v39[0]);
  }

  sub_100B202F4(v43);
  sub_100057D78((const void **)&v31);
  if (SHIBYTE(v33) < 0) {
    operator delete(__dst[0]);
  }
  sub_100B21AB0(&v30);
  return sub_100046B58((uint64_t *)&v29);
}

void sub_100B21880(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, uint64_t a10, uint64_t a11, const void *a12, void *a13, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, void *a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,void *__p,uint64_t a28,int a29,__int16 a30,char a31,char a32,void *a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37)
{
  if (a25) {
    sub_10004D2C8((std::__shared_weak_count *)a25);
  }
  sub_10003B34C((void *)(v39 - 144));
  std::__shared_weak_count::__release_weak(v38);
  if (a32 < 0) {
    operator delete(__p);
  }

  sub_100B202F4(&a37);
  sub_100057D78(&a12);
  if (a18 < 0) {
    operator delete(a13);
  }
  sub_100B21AB0(&a11);
  sub_100046B58(&a10);
  _Unwind_Resume(a1);
}

uint64_t *sub_100B21AB0(uint64_t *result)
{
  uint64_t v1 = *result;
  *uint64_t result = 0;
  if (v1)
  {
    sub_100B202F4((void *)(v1 + 56));
    uint64_t v2 = *(void **)(v1 + 40);
    *(void *)(v1 + 40) = 0;

    sub_100057D78((const void **)(v1 + 32));
    if (*(char *)(v1 + 31) < 0) {
      operator delete(*(void **)(v1 + 8));
    }
    operator delete();
  }
  return result;
}

uint64_t sub_100B21B2C(uint64_t a1, uint64_t a2)
{
  long long v3 = (void *)(a2 + 24);
  uint64_t v4 = *(void *)(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(*(void *)*v3 + 24))(*v3, a1);
      return a1;
    }
    *(void *)(a1 + 24) = v4;
  }
  else
  {
    long long v3 = (void *)(a1 + 24);
  }
  void *v3 = 0;
  return a1;
}

uint64_t *sub_100B21BAC(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v18 = a1;
  uint64_t v19 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v21 = 0;
  uint64_t v22 = 0;
  uint64_t v20 = 0;
  sub_1000302C0((char *)&v20, *(long long **)(v1 + 8), *(long long **)(v1 + 16), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(v1 + 16) - *(void *)(v1 + 8)) >> 3));
  sub_100B20C18((uint64_t)v25, v1 + 32);
  long long v3 = *(std::__shared_weak_count **)(v2 + 16);
  if (!v3 || (v17 = *(void ***)(v2 + 8), (uint64_t v4 = std::__shared_weak_count::lock(v3)) == 0)) {
    sub_100088B9C();
  }
  long long v5 = v4;
  atomic_fetch_add_explicit(&v4->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v4);
  id v7 = v20;
  uint64_t v8 = v21;
  if (v20 != v21)
  {
    *(void *)&long long v6 = 136315138;
    long long v16 = v6;
    do
    {
      __dst[0] = 0;
      __dst[1] = 0;
      uint64_t v24 = 0;
      if (*((char *)v7 + 23) < 0)
      {
        sub_10004FC84(__dst, *(void **)v7, *((void *)v7 + 1));
      }
      else
      {
        long long v9 = *v7;
        uint64_t v24 = *((void *)v7 + 2);
        *(_OWORD *)std::string __dst = v9;
      }
      uint64_t v10 = sub_100200FB4((id *)(v2 + 40));
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
        id v11 = __dst;
        if (v24 < 0) {
          id v11 = (void **)__dst[0];
        }
        *(_DWORD *)int buf = v16;
        long long v32 = v11;
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I registering for request: %s", buf, 0xCu);
      }

      uint64_t v12 = **(void ***)(v2 + 64);
      if (v24 >= 0) {
        uint64_t v13 = __dst;
      }
      else {
        uint64_t v13 = (void **)__dst[0];
      }
      uint64_t v14 = +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v13, v16);
      v26[0] = _NSConcreteStackBlock;
      v26[1] = (void **)3321888768;
      v26[2] = (void **)sub_100B1F1B4;
      v26[3] = (void **)&unk_101A3BA98;
      v26[4] = (void **)v2;
      v26[5] = v17;
      id v27 = v5;
      atomic_fetch_add_explicit(&v5->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      if (SHIBYTE(v24) < 0)
      {
        sub_10004FC84(&__p, __dst[0], (unint64_t)__dst[1]);
      }
      else
      {
        long long __p = *(_OWORD *)__dst;
        uint64_t v29 = v24;
      }
      sub_100B20C18((uint64_t)v30, (uint64_t)v25);
      [v12 registerRequestID:v14 options:0 handler:v26];

      sub_100B20B94(v30);
      if (SHIBYTE(v29) < 0) {
        operator delete((void *)__p);
      }
      if (v27) {
        std::__shared_weak_count::__release_weak(v27);
      }
      if (SHIBYTE(v24) < 0) {
        operator delete(__dst[0]);
      }
      id v7 = (long long *)((char *)v7 + 24);
    }
    while (v7 != v8);
  }
  sub_100B1EBF0(v2);
  std::__shared_weak_count::__release_weak(v5);
  sub_100B20B94(v25);
  v26[0] = (void **)&v20;
  sub_100047F64(v26);
  sub_100B21F5C(&v19);
  return sub_100046B58((uint64_t *)&v18);
}

void sub_100B21EA4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, __int16 *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,std::__shared_weak_count *a36,void *a37,uint64_t a38,int a39,__int16 a40,char a41,char a42)
{
  std::__shared_weak_count::__release_weak(v42);
  sub_100B20B94(&a26);
  long long __p = &a14;
  sub_100047F64((void ***)&__p);
  sub_100B21F5C(&a13);
  sub_100046B58(&a12);
  _Unwind_Resume(a1);
}

uint64_t *sub_100B21F5C(uint64_t *result)
{
  uint64_t v1 = *result;
  *uint64_t result = 0;
  if (v1)
  {
    sub_100B20B94((void *)(v1 + 32));
    uint64_t v2 = (void **)(v1 + 8);
    sub_100047F64(&v2);
    operator delete();
  }
  return result;
}

uint64_t sub_100B21FC4(uint64_t a1, uint64_t a2)
{
  long long v3 = (void *)(a2 + 24);
  uint64_t v4 = *(void *)(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(*(void *)*v3 + 24))(*v3, a1);
      return a1;
    }
    *(void *)(a1 + 24) = v4;
  }
  else
  {
    long long v3 = (void *)(a1 + 24);
  }
  void *v3 = 0;
  return a1;
}

uint64_t *sub_100B22044(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v18 = a1;
  uint64_t v19 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v21 = 0;
  uint64_t v22 = 0;
  uint64_t v20 = 0;
  sub_1000302C0((char *)&v20, *(long long **)(v1 + 8), *(long long **)(v1 + 16), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(v1 + 16) - *(void *)(v1 + 8)) >> 3));
  sub_100B210BC((uint64_t)v25, v1 + 32);
  long long v3 = *(std::__shared_weak_count **)(v2 + 16);
  if (!v3 || (v17 = *(void ***)(v2 + 8), (uint64_t v4 = std::__shared_weak_count::lock(v3)) == 0)) {
    sub_100088B9C();
  }
  long long v5 = v4;
  atomic_fetch_add_explicit(&v4->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v4);
  id v7 = v20;
  uint64_t v8 = v21;
  if (v20 != v21)
  {
    *(void *)&long long v6 = 136315138;
    long long v16 = v6;
    do
    {
      __dst[0] = 0;
      __dst[1] = 0;
      uint64_t v24 = 0;
      if (*((char *)v7 + 23) < 0)
      {
        sub_10004FC84(__dst, *(void **)v7, *((void *)v7 + 1));
      }
      else
      {
        long long v9 = *v7;
        uint64_t v24 = *((void *)v7 + 2);
        *(_OWORD *)std::string __dst = v9;
      }
      uint64_t v10 = sub_100200FB4((id *)(v2 + 40));
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
        id v11 = __dst;
        if (v24 < 0) {
          id v11 = (void **)__dst[0];
        }
        *(_DWORD *)int buf = v16;
        long long v32 = v11;
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I registering for request: %s", buf, 0xCu);
      }

      uint64_t v12 = **(void ***)(v2 + 64);
      if (v24 >= 0) {
        uint64_t v13 = __dst;
      }
      else {
        uint64_t v13 = (void **)__dst[0];
      }
      uint64_t v14 = +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v13, v16);
      v26[0] = _NSConcreteStackBlock;
      v26[1] = (void **)3321888768;
      v26[2] = (void **)sub_100B1F558;
      v26[3] = (void **)&unk_101A3BAC8;
      v26[4] = (void **)v2;
      v26[5] = v17;
      id v27 = v5;
      atomic_fetch_add_explicit(&v5->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      if (SHIBYTE(v24) < 0)
      {
        sub_10004FC84(&__p, __dst[0], (unint64_t)__dst[1]);
      }
      else
      {
        long long __p = *(_OWORD *)__dst;
        uint64_t v29 = v24;
      }
      sub_100B210BC((uint64_t)v30, (uint64_t)v25);
      [v12 registerRequestID:v14 options:0 handler:v26];

      sub_10010E0A4(v30);
      if (SHIBYTE(v29) < 0) {
        operator delete((void *)__p);
      }
      if (v27) {
        std::__shared_weak_count::__release_weak(v27);
      }
      if (SHIBYTE(v24) < 0) {
        operator delete(__dst[0]);
      }
      id v7 = (long long *)((char *)v7 + 24);
    }
    while (v7 != v8);
  }
  sub_100B1EBF0(v2);
  std::__shared_weak_count::__release_weak(v5);
  sub_10010E0A4(v25);
  v26[0] = (void **)&v20;
  sub_100047F64(v26);
  sub_100B223F4(&v19);
  return sub_100046B58((uint64_t *)&v18);
}

void sub_100B2233C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, __int16 *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,std::__shared_weak_count *a36,void *a37,uint64_t a38,int a39,__int16 a40,char a41,char a42)
{
  std::__shared_weak_count::__release_weak(v42);
  sub_10010E0A4(&a26);
  long long __p = &a14;
  sub_100047F64((void ***)&__p);
  sub_100B223F4(&a13);
  sub_100046B58(&a12);
  _Unwind_Resume(a1);
}

uint64_t *sub_100B223F4(uint64_t *result)
{
  uint64_t v1 = *result;
  *uint64_t result = 0;
  if (v1)
  {
    sub_10010E0A4((void *)(v1 + 32));
    uint64_t v2 = (void **)(v1 + 8);
    sub_100047F64(&v2);
    operator delete();
  }
  return result;
}

void sub_100B2245C(uint64_t **a1)
{
  uint64_t v1 = **a1;
  uint64_t v2 = sub_100200FB4((id *)(v1 + 40));
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)int buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I invalidating session upon client request", buf, 2u);
  }

  if (**(void **)(v1 + 64))
  {
    long long v3 = sub_100200FB4((id *)(v1 + 40));
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long v5 = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I clearing invalidation handler", v5, 2u);
    }

    [**(id **)(v1 + 64) setInvalidationHandler:0];
    [**(id **)(v1 + 64) invalidate];
  }
  operator delete();
}

void sub_100B22570()
{
}

void sub_100B2259C(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  operator new();
}

void sub_100B22608()
{
}

uint64_t sub_100B2262C(uint64_t a1, void *a2)
{
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v7, kCtLoggingSystemName, "call.dtmf");
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v8, &v7);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)a1, (const ctu::OsLogLogger *)v8);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v8);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v7);
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = *a2;
  uint64_t v4 = a2[1];
  *(void *)(a1 + 32) = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(void *)(a1 + 176) = 0;
  *(_DWORD *)(a1 + 184) = 0;
  *(void *)(a1 + 192) = 0;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_DWORD *)(a1 + 87) = 0;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(void *)(a1 + 144) = 0;
  *(void *)(a1 + 200) = 0;
  *(void *)(a1 + 208) = 0;
  sub_10057F630(a1 + 216);
  sub_100BD482C((std::__shared_weak_count **)&v7);
  long long v5 = *(std::__shared_weak_count **)(a1 + 208);
  *(OsLogContext *)(a1 + 200) = v7;
  if (v5) {
    sub_10004D2C8(v5);
  }
  return a1;
}

void sub_100B22738(_Unwind_Exception *a1)
{
  uint64_t v6 = v2;
  sub_1002243E8(v6);
  uint64_t v8 = *(std::__shared_weak_count **)(v1 + 208);
  if (v8) {
    sub_10004D2C8(v8);
  }
  if (*v5) {
    dispatch_release(*v5);
  }
  sub_100B245F8(v3 + 14);
  if (*(char *)(v1 + 151) < 0) {
    operator delete(*(void **)(v1 + 128));
  }
  if (*(char *)(v1 + 127) < 0) {
    operator delete(*(void **)(v1 + 104));
  }
  uint64_t v9 = *v4;
  *uint64_t v4 = 0;
  if (v9) {
    (*(void (**)(uint64_t))(*(void *)v9 + 8))(v9);
  }
  sub_100B24550(v3);
  uint64_t v10 = *(std::__shared_weak_count **)(v1 + 32);
  if (v10) {
    sub_10004D2C8(v10);
  }
  id v11 = *(std::__shared_weak_count **)(v1 + 16);
  if (v11) {
    std::__shared_weak_count::__release_weak(v11);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v1);
  _Unwind_Resume(a1);
}

void sub_100B22820(uint64_t a1)
{
  sub_100B228F4(a1);
  sub_1002243E8(a1 + 216);
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 208);
  if (v2) {
    sub_10004D2C8(v2);
  }
  long long v3 = *(NSObject **)(a1 + 192);
  if (v3) {
    dispatch_release(v3);
  }
  sub_100B245F8((void *)(a1 + 152));
  if (*(char *)(a1 + 151) < 0) {
    operator delete(*(void **)(a1 + 128));
  }
  if (*(char *)(a1 + 127) < 0) {
    operator delete(*(void **)(a1 + 104));
  }
  uint64_t v4 = *(void *)(a1 + 96);
  *(void *)(a1 + 96) = 0;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
  }
  sub_100B24550((void *)(a1 + 40));
  long long v5 = *(std::__shared_weak_count **)(a1 + 32);
  if (v5) {
    sub_10004D2C8(v5);
  }
  uint64_t v6 = *(std::__shared_weak_count **)(a1 + 16);
  if (v6) {
    std::__shared_weak_count::__release_weak(v6);
  }

  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)a1);
}

void sub_100B228F4(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)a1;
  if (os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v12 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Clearing DTMF queue", v12, 2u);
  }
  int v3 = *(unsigned __int8 *)(a1 + 90);
  uint64_t v4 = *(void *)(a1 + 96);
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 16))(v4);
  }
  *(_WORD *)(a1 + 88) = 0;
  *(unsigned char *)(a1 + 90) = 0;
  if (*(char *)(a1 + 127) < 0)
  {
    *(void *)(a1 + 112) = 0;
    long long v5 = *(unsigned char **)(a1 + 104);
  }
  else
  {
    long long v5 = (unsigned char *)(a1 + 104);
    *(unsigned char *)(a1 + 127) = 0;
  }
  *long long v5 = 0;
  if (*(char *)(a1 + 151) < 0)
  {
    *(void *)(a1 + 136) = 0;
    uint64_t v6 = *(unsigned char **)(a1 + 128);
  }
  else
  {
    uint64_t v6 = (unsigned char *)(a1 + 128);
    *(unsigned char *)(a1 + 151) = 0;
  }
  *uint64_t v6 = 0;
  OsLogContext v7 = *(void ***)(a1 + 48);
  uint64_t v8 = *(void *)(a1 + 56);
  *(void *)(a1 + 80) = 0;
  unint64_t v9 = v8 - (void)v7;
  if (v9 >= 0x11)
  {
    do
    {
      operator delete(*v7);
      uint64_t v10 = *(void *)(a1 + 56);
      OsLogContext v7 = (void **)(*(void *)(a1 + 48) + 8);
      *(void *)(a1 + 48) = v7;
      unint64_t v9 = v10 - (void)v7;
    }
    while (v9 > 0x10);
  }
  if (v9 >> 3 == 1)
  {
    uint64_t v11 = 2048;
  }
  else
  {
    if (v9 >> 3 != 2) {
      goto LABEL_18;
    }
    uint64_t v11 = 4096;
  }
  *(void *)(a1 + 72) = v11;
LABEL_18:
  if (v3) {
    (*(void (**)(void, uint64_t))(**(void **)(a1 + 200) + 24))(*(void *)(a1 + 200), 112);
  }
}

void sub_100B22A58(uint64_t a1, char *__s)
{
  if (__s)
  {
    size_t v4 = strlen(__s);
    if (v4)
    {
      *(unsigned char *)(a1 + 88) = 1;
      sub_100B2467C(a1 + 40, __s, v4);
      sub_100B22AE8((void *)(a1 + 40), "!NSt3__120__shared_ptr_pointerIP9DtmfQueueNS_10shared_ptrIS1_E27__shared_ptr_default_deleteIS1_S1_EENS_9allocatorIS1_EEEE");
      *(unsigned char *)(a1 + 89) = 1;
      sub_100B22B74(a1);
    }
  }
}

void sub_100B22AE8(void *a1, unsigned char *a2)
{
  uint64_t v4 = a1[2];
  uint64_t v5 = a1[1];
  uint64_t v6 = ((v4 - v5) << 9) - 1;
  if (v4 == v5) {
    uint64_t v6 = 0;
  }
  unint64_t v7 = a1[5] + a1[4];
  if (v6 == v7)
  {
    sub_100B24FEC(a1);
    uint64_t v5 = a1[1];
    unint64_t v7 = a1[5] + a1[4];
  }
  *(unsigned char *)(*(void *)(v5 + ((v7 >> 9) & 0x7FFFFFFFFFFFF8)) + (v7 & 0xFFF)) = *a2;
  ++a1[5];
}

void sub_100B22B74(uint64_t a1)
{
  if (*(void *)(a1 + 80))
  {
    memset(&__str, 0, sizeof(__str));
    uint64_t v2 = *(void *)(a1 + 48);
    int v3 = (void *)(v2 + 8 * (*(void *)(a1 + 72) >> 12));
    uint64_t v4 = (unsigned char *)*v3;
    uint64_t v5 = (unsigned char *)(*v3 + (*(void *)(a1 + 72) & 0xFFFLL));
    int v6 = *v5;
    if (v6 != 33)
    {
      if (v6 != 44)
      {
        if (v6 == 59)
        {
          do
          {
            if (++v5 - v4 == 4096)
            {
              unint64_t v7 = (unsigned char *)v3[1];
              ++v3;
              uint64_t v4 = v7;
              uint64_t v5 = v7;
            }
            int v8 = *v5;
          }
          while (v8 == 59);
          while (v8 != 33 && v8 != 59)
          {
            if (&(++v5)[-*v3] == (unsigned char *)4096)
            {
              unint64_t v9 = (unsigned char *)v3[1];
              ++v3;
              uint64_t v5 = v9;
            }
            std::string::push_back(&__str, v8);
            LOBYTE(v8) = *v5;
          }
LABEL_14:
          std::string::operator=((std::string *)(a1 + 128), &__str);
        }
        goto LABEL_40;
      }
      if (*(void *)(a1 + 56) == v2) {
        uint64_t v5 = 0;
      }
LABEL_21:
      uint64_t v12 = v4 - v5 + 4096;
      while (1)
      {
        int v13 = *v5;
        if (v13 == 33) {
          break;
        }
        if (v13 == 59)
        {
          do
          {
            if (++v5 - v4 == 4096)
            {
              uint64_t v15 = (unsigned char *)v3[1];
              ++v3;
              uint64_t v4 = v15;
              uint64_t v5 = v15;
            }
            int v16 = *v5;
          }
          while (v16 == 59);
          while (v16 != 33 && v16 != 59)
          {
            if (&(++v5)[-*v3] == (unsigned char *)4096)
            {
              uint64_t v17 = (unsigned char *)v3[1];
              ++v3;
              uint64_t v5 = v17;
            }
            std::string::push_back(&__str, v16);
            LOBYTE(v16) = *v5;
          }
          goto LABEL_14;
        }
        ++v5;
        if (!--v12)
        {
          uint64_t v14 = (unsigned char *)v3[1];
          ++v3;
          uint64_t v4 = v14;
          uint64_t v5 = v14;
          goto LABEL_21;
        }
      }
    }
    if (*(char *)(a1 + 151) < 0)
    {
      *(void *)(a1 + 136) = 0;
      uint64_t v18 = *(unsigned char **)(a1 + 128);
    }
    else
    {
      uint64_t v18 = (unsigned char *)(a1 + 128);
      *(unsigned char *)(a1 + 151) = 0;
    }
    *uint64_t v18 = 0;
LABEL_40:
    uint64_t v19 = *(NSObject **)a1;
    if (os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v20 = (void *)(a1 + 128);
      if (*(char *)(a1 + 151) < 0) {
        uint64_t v20 = (void *)*v20;
      }
      int v21 = 136315138;
      uint64_t v22 = v20;
      _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#I fUpcomingHardPauseDigits = %s", (uint8_t *)&v21, 0xCu);
    }
    if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__str.__r_.__value_.__l.__data_);
    }
    return;
  }
  uint64_t v10 = *(NSObject **)a1;
  if (os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v11 = (void *)(a1 + 128);
    if (*(char *)(a1 + 151) < 0) {
      uint64_t v11 = (void *)*v11;
    }
    LODWORD(__str.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)__str.__r_.__value_.__r.__words + 4) = (std::string::size_type)v11;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I fUpcomingHardPauseDigits = %s", (uint8_t *)&__str, 0xCu);
  }
}

void sub_100B22E24(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *sub_100B22E4C(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(NSObject **)a1;
  if (os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)unint64_t v9 = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Setting New DTMF Digits Callback", v9, 2u);
  }
  sub_100B25304((uint64_t)v9, a2);
  uint64_t v5 = a1 + 152;
  if (v9 != (uint8_t *)(a1 + 152))
  {
    int v6 = v10;
    uint64_t v7 = *(void *)(a1 + 176);
    if (v10 == v9)
    {
      if (v7 == v5)
      {
        memset(v11, 0, sizeof(v11));
        (*(void (**)(uint8_t *, void *))(*(void *)v9 + 24))(v9, v11);
        (*(void (**)(uint8_t *))(*(void *)v10 + 32))(v10);
        uint64_t v10 = 0;
        (*(void (**)(void, uint8_t *))(**(void **)(a1 + 176) + 24))(*(void *)(a1 + 176), v9);
        (*(void (**)(void))(**(void **)(a1 + 176) + 32))(*(void *)(a1 + 176));
        *(void *)(a1 + 176) = 0;
        uint64_t v10 = v9;
        (*(void (**)(void *, uint64_t))(v11[0] + 24))(v11, a1 + 152);
        (*(void (**)(void *))(v11[0] + 32))(v11);
      }
      else
      {
        (*(void (**)(uint8_t *, uint64_t))(*(void *)v9 + 24))(v9, a1 + 152);
        (*(void (**)(uint8_t *))(*(void *)v10 + 32))(v10);
        uint64_t v10 = *(uint8_t **)(a1 + 176);
      }
      *(void *)(a1 + 176) = v5;
    }
    else if (v7 == v5)
    {
      (*(void (**)(uint64_t, uint8_t *))(*(void *)v5 + 24))(a1 + 152, v9);
      (*(void (**)(void))(**(void **)(a1 + 176) + 32))(*(void *)(a1 + 176));
      *(void *)(a1 + 176) = v10;
      uint64_t v10 = v9;
    }
    else
    {
      uint64_t v10 = *(uint8_t **)(a1 + 176);
      *(void *)(a1 + 176) = v6;
    }
  }
  return sub_100B245F8(v9);
}

void sub_100B23128(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

__n128 sub_100B23134(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(NSObject **)a1;
  if (os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v14 = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Setting New Call for DTMF Digits Callback", v14, 2u);
  }
  sub_100224390((const void **)(a1 + 216), (const void **)a2);
  std::string::operator=((std::string *)(a1 + 224), (const std::string *)(a2 + 8));
  std::string::operator=((std::string *)(a1 + 248), (const std::string *)(a2 + 32));
  *(_OWORD *)(a1 + 272) = *(_OWORD *)(a2 + 56);
  long long v5 = *(_OWORD *)(a2 + 88);
  long long v6 = *(_OWORD *)(a2 + 104);
  long long v7 = *(_OWORD *)(a2 + 72);
  *(void *)(a1 + 333) = *(void *)(a2 + 117);
  *(_OWORD *)(a1 + 304) = v5;
  *(_OWORD *)(a1 + 320) = v6;
  *(_OWORD *)(a1 + 288) = v7;
  std::string::operator=((std::string *)(a1 + 344), (const std::string *)(a2 + 128));
  *(_DWORD *)(a1 + 368) = *(_DWORD *)(a2 + 152);
  std::string::operator=((std::string *)(a1 + 376), (const std::string *)(a2 + 160));
  long long v8 = *(_OWORD *)(a2 + 193);
  *(_OWORD *)(a1 + 400) = *(_OWORD *)(a2 + 184);
  *(_OWORD *)(a1 + 409) = v8;
  sub_100840CD0(a1 + 432, a2 + 216);
  long long v9 = *(_OWORD *)(a2 + 248);
  *(unsigned char *)(a1 + 480) = *(unsigned char *)(a2 + 264);
  *(_OWORD *)(a1 + 464) = v9;
  std::string::operator=((std::string *)(a1 + 488), (const std::string *)(a2 + 272));
  std::string::operator=((std::string *)(a1 + 512), (const std::string *)(a2 + 296));
  long long v10 = *(_OWORD *)(a2 + 336);
  *(_OWORD *)(a1 + 536) = *(_OWORD *)(a2 + 320);
  *(_OWORD *)(a1 + 552) = v10;
  long long v12 = *(_OWORD *)(a2 + 368);
  __n128 result = *(__n128 *)(a2 + 384);
  long long v13 = *(_OWORD *)(a2 + 352);
  *(void *)(a1 + 613) = *(void *)(a2 + 397);
  *(_OWORD *)(a1 + 584) = v12;
  *(__n128 *)(a1 + 600) = result;
  *(_OWORD *)(a1 + 568) = v13;
  return result;
}

void sub_100B2327C(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 89) || !*(void *)(a1 + 80))
  {
    *(unsigned char *)(a1 + 89) = 0;
    uint64_t v19 = *(void ***)(a1 + 48);
    uint64_t v20 = *(void *)(a1 + 56);
    *(void *)(a1 + 80) = 0;
    unint64_t v21 = v20 - (void)v19;
    if (v21 >= 0x11)
    {
      do
      {
        operator delete(*v19);
        uint64_t v22 = *(void *)(a1 + 56);
        uint64_t v19 = (void **)(*(void *)(a1 + 48) + 8);
        *(void *)(a1 + 48) = v19;
        unint64_t v21 = v22 - (void)v19;
      }
      while (v21 > 0x10);
    }
    if (v21 >> 3 == 1)
    {
      uint64_t v23 = 2048;
    }
    else
    {
      if (v21 >> 3 != 2) {
        return;
      }
      uint64_t v23 = 4096;
    }
    *(void *)(a1 + 72) = v23;
    return;
  }
  long long v31 = 0;
  long long v32 = 0;
  uint64_t v33 = 0;
  uint64_t v2 = *(NSObject **)a1;
  if (os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT))
  {
    int v3 = *(char *)(*(void *)(*(void *)(a1 + 48) + ((*(void *)(a1 + 72) >> 9) & 0x7FFFFFFFFFFFF8))
                 + (*(void *)(a1 + 72) & 0xFFFLL));
    *(_DWORD *)int buf = 67109120;
    int v35 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I %c", buf, 8u);
  }
  uint64_t v4 = 0;
  for (unsigned int i = 0; ; unsigned int i = v9)
  {
    unsigned int v6 = *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 48) + ((*(void *)(a1 + 72) >> 9) & 0x7FFFFFFFFFFFF8))
                            + (*(void *)(a1 + 72) & 0xFFFLL));
    if (v6 <= 0x3B && ((1 << v6) & 0x800100200000000) != 0) {
      break;
    }
    long long v8 = *(NSObject **)a1;
    if (os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)int buf = 67109120;
      int v35 = (char)v6;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I doKey: Pushing back %hhd digit for dtmf tones", buf, 8u);
      LOBYTE(v6) = *(unsigned char *)(*(void *)(*(void *)(a1 + 48) + ((*(void *)(a1 + 72) >> 9) & 0x7FFFFFFFFFFFF8))
                            + (*(void *)(a1 + 72) & 0xFFFLL));
    }
    if (i >= v33)
    {
      unint64_t v10 = (unint64_t)v31;
      uint64_t v11 = (unsigned char *)(i - v31);
      uint64_t v12 = i - v31 + 1;
      if (v12 < 0) {
        sub_10006A748();
      }
      unint64_t v13 = v33 - v31;
      if (2 * (v33 - v31) > (unint64_t)v12) {
        uint64_t v12 = 2 * v13;
      }
      if (v13 >= 0x3FFFFFFFFFFFFFFFLL) {
        size_t v14 = 0x7FFFFFFFFFFFFFFFLL;
      }
      else {
        size_t v14 = v12;
      }
      if (v14) {
        uint64_t v15 = (char *)operator new(v14);
      }
      else {
        uint64_t v15 = 0;
      }
      uint64_t v4 = &v11[(void)v15];
      int v16 = &v11[(void)v15];
      unsigned char *v16 = v6;
      long long v9 = v16 + 1;
      if (i != (char *)v10)
      {
        uint64_t v17 = &i[~v10];
        do
        {
          char v18 = *--i;
          (v17--)[(void)v15] = v18;
        }
        while (i != (char *)v10);
        unsigned int i = v31;
        uint64_t v4 = v15;
      }
      long long v31 = v4;
      long long v32 = v9;
      uint64_t v33 = &v15[v14];
      if (i) {
        operator delete(i);
      }
    }
    else
    {
      char *i = v6;
      long long v9 = i + 1;
    }
    long long v32 = v9;
    *(int64x2_t *)(a1 + 72) = vaddq_s64(*(int64x2_t *)(a1 + 72), (int64x2_t)xmmword_10144F900);
    sub_100B2539C(a1 + 40, 1);
  }
  uint64_t v24 = *(NSObject **)a1;
  if (os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)int buf = 67109120;
    int v35 = i - v4;
    _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "#I Queing up burst of DTMF, count = %d", buf, 8u);
  }
  if (i == v4)
  {
    sub_100B2384C(a1);
    if (!v4) {
      return;
    }
    goto LABEL_46;
  }
  if (*(void *)(a1 + 176))
  {
    xpc_object_t v28 = 0;
    uint64_t v29 = 0;
    uint64_t v30 = 0;
    sub_10005C928(&v28, v4, (uint64_t)i, i - v4);
    sub_100245B5C((uint64_t)v27, a1 + 216);
    uint64_t v25 = *(void *)(a1 + 176);
    if (!v25) {
      sub_10007B600();
    }
    (*(void (**)(uint64_t, void **, unsigned char *))(*(void *)v25 + 48))(v25, &v28, v27);
    sub_1002243E8((uint64_t)v27);
    if (v28)
    {
      uint64_t v29 = v28;
      operator delete(v28);
    }
  }
  else
  {
    CFTypeRef v26 = *(NSObject **)a1;
    if (os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)int buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "#N fSendDTMFDigitsCallback is not valid. Not sending digits", buf, 2u);
    }
  }
  sub_100B22B74(a1);
  uint64_t v4 = v31;
  if (v31)
  {
LABEL_46:
    long long v32 = v4;
    operator delete(v4);
  }
}

void sub_100B236AC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14)
{
  int v16 = *(void **)(v14 - 160);
  if (v16)
  {
    *(void *)(v14 - 152) = v16;
    operator delete(v16);
  }
  uint64_t v17 = *(void **)(v14 - 136);
  if (v17)
  {
    *(void *)(v14 - 128) = v17;
    operator delete(v17);
  }
  _Unwind_Resume(exception_object);
}

void sub_100B236FC(os_log_t *a1)
{
  uint64_t v2 = *a1;
  if (os_log_type_enabled(*a1, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)int v3 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Going to start DTMF tones after a hard pause", v3, 2u);
  }
  sub_100B2327C((uint64_t)a1);
}

void sub_100B23768(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4 = *(NSObject **)a1;
  if (os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT))
  {
    long long v5 = (void *)(a1 + 128);
    if (*(char *)(a1 + 151) < 0) {
      long long v5 = (void *)*v5;
    }
    int v6 = 136315138;
    long long v7 = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I fUpcomingHardPauseDigits = %s", (uint8_t *)&v6, 0xCu);
  }
  if (*(char *)(a1 + 151) < 0)
  {
    sub_10004FC84((unsigned char *)a2, *(void **)(a1 + 128), *(void *)(a1 + 136));
  }
  else
  {
    *(_OWORD *)a2 = *(_OWORD *)(a1 + 128);
    *(void *)(a2 + 16) = *(void *)(a1 + 144);
  }
}

void sub_100B2384C(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)a1;
  if (os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(buf.__r_.__value_.__l.__data_) = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I processDtmf", (uint8_t *)&buf, 2u);
  }
  memset(&buf, 0, sizeof(buf));
  uint64_t v3 = *(void *)(a1 + 80);
  if (v3)
  {
    unint64_t v4 = *(void *)(a1 + 72);
    int v5 = *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 48) + ((v4 >> 9) & 0x7FFFFFFFFFFFF8)) + (v4 & 0xFFF));
    switch(v5)
    {
      case '!':
        *(unsigned char *)(a1 + 89) = 0;
        *(void *)(a1 + 72) = v4 + 1;
        *(void *)(a1 + 80) = v3 - 1;
        sub_100B2539C(a1 + 40, 1);
        break;
      case ',':
        *(void *)(a1 + 72) = v4 + 1;
        *(void *)(a1 + 80) = v3 - 1;
        sub_100B2539C(a1 + 40, 1);
        if (*(void *)(a1 + 192))
        {
          Registry::getTimerService((uint64_t *)v27, *(Registry **)(a1 + 24));
          uint64_t v11 = *(void *)v27;
          sub_100058DB0(__p, "DTMFSoftPauseTimer");
          uint64_t v12 = *(NSObject **)(a1 + 192);
          dispatch_object_t object = v12;
          if (v12) {
            dispatch_retain(v12);
          }
          v22[0] = _NSConcreteStackBlock;
          v22[1] = 0x40000000;
          v22[2] = sub_100B23C34;
          _OWORD v22[3] = &unk_101A3BDD0;
          v22[4] = a1;
          aBlocuint64_t k = _Block_copy(v22);
          sub_100118A44(v11, (uint64_t)__p, 1, 3000000, &object, &aBlock);
          uint64_t v13 = v29;
          uint64_t v29 = 0;
          uint64_t v14 = *(void *)(a1 + 96);
          *(void *)(a1 + 96) = v13;
          if (v14)
          {
            (*(void (**)(uint64_t))(*(void *)v14 + 8))(v14);
            uint64_t v15 = v29;
            uint64_t v29 = 0;
            if (v15) {
              (*(void (**)(uint64_t))(*(void *)v15 + 8))(v15);
            }
          }
          if (aBlock) {
            _Block_release(aBlock);
          }
          if (object) {
            dispatch_release(object);
          }
          if (v26 < 0) {
            operator delete(__p[0]);
          }
          if (v28) {
            sub_10004D2C8(v28);
          }
        }
        else
        {
          unint64_t v21 = *(NSObject **)a1;
          if (os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)id v27 = 0;
            _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "#N Parent queue is null!", v27, 2u);
          }
          sub_100B2327C(a1);
        }
        break;
      case ';':
        while (1)
        {
          uint64_t v6 = *(void *)(a1 + 48);
          unint64_t v7 = *(void *)(a1 + 72);
          uint64_t v8 = *(void *)(v6 + 8 * (v7 >> 12));
          int v9 = *(unsigned __int8 *)(v8 + (v7 & 0xFFF));
          if (v9 != 59) {
            break;
          }
          uint64_t v10 = *(void *)(a1 + 80) - 1;
          *(void *)(a1 + 72) = v7 + 1;
          *(void *)(a1 + 80) = v10;
          sub_100B2539C(a1 + 40, 1);
        }
        if (v9 != 33)
        {
          int v16 = (void *)(v6 + 8 * (v7 >> 12));
          uint64_t v17 = v8 + (*(void *)(a1 + 72) & 0xFFFLL);
          *(unsigned char *)(a1 + 90) = 1;
          char v18 = *(void *)(a1 + 56) == v6 ? 0 : (unsigned __int8 *)v17;
          while (1)
          {
            int v19 = *v18;
            if (v19 == 33 || v19 == 59) {
              break;
            }
            if (&(++v18)[-*v16] == (unsigned __int8 *)4096)
            {
              uint64_t v20 = (unsigned __int8 *)v16[1];
              ++v16;
              char v18 = v20;
            }
            std::string::push_back(&buf, v19);
          }
          std::string::operator=((std::string *)(a1 + 104), &buf);
          (*(void (**)(void, uint64_t))(**(void **)(a1 + 200) + 24))(*(void *)(a1 + 200), 112);
          if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(buf.__r_.__value_.__l.__data_);
          }
        }
        break;
    }
  }
}

void sub_100B23BBC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *aBlock, dispatch_object_t object, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,std::__shared_weak_count *a23)
{
  if (aBlock) {
    _Block_release(aBlock);
  }
  if (object) {
    dispatch_release(object);
  }
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a23) {
    sub_10004D2C8(a23);
  }
  if (*(char *)(v23 - 41) < 0) {
    operator delete(*(void **)(v23 - 64));
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100B23C34(uint64_t a1)
{
  return sub_100B2327C(*(void *)(a1 + 32));
}

uint64_t sub_100B23C3C@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t v50 = 0;
  long long v48 = 0u;
  long long v49 = 0u;
  long long v46 = 0u;
  long long v47 = 0u;
  long long v44 = 0u;
  long long v45 = 0u;
  long long v42 = 0u;
  long long v43 = 0u;
  long long v40 = 0u;
  long long v41 = 0u;
  *(_OWORD *)long long __p = 0u;
  long long v39 = 0u;
  memset(v37, 0, sizeof(v37));
  long long v36 = 0u;
  sub_10004BD84((uint64_t)&v36);
  unint64_t v4 = sub_10004B96C(v37, (uint64_t)"DTMF Info: ", 11);
  std::ios_base::getloc((const std::ios_base *)((char *)v4 + *(void *)(*v4 - 24)));
  int v5 = std::locale::use_facet(&v51, &std::ctype<char>::id);
  ((void (*)(const std::locale::facet *, uint64_t))v5->__vftable[2].~facet_0)(v5, 10);
  std::locale::~locale(&v51);
  std::ostream::put();
  std::ostream::flush();
  sub_10004B96C(v4, (uint64_t)"\t fWaitingForConnect =  ", 24);
  uint64_t v6 = (void *)std::ostream::operator<<();
  std::ios_base::getloc((const std::ios_base *)((char *)v6 + *(void *)(*v6 - 24)));
  unint64_t v7 = std::locale::use_facet(&v51, &std::ctype<char>::id);
  ((void (*)(const std::locale::facet *, uint64_t))v7->__vftable[2].~facet_0)(v7, 10);
  std::locale::~locale(&v51);
  std::ostream::put();
  std::ostream::flush();
  sub_10004B96C(v6, (uint64_t)"\t fPauseString = ", 17);
  uint64_t v8 = (void *)std::ostream::operator<<();
  std::ios_base::getloc((const std::ios_base *)((char *)v8 + *(void *)(*v8 - 24)));
  int v9 = std::locale::use_facet(&v51, &std::ctype<char>::id);
  ((void (*)(const std::locale::facet *, uint64_t))v9->__vftable[2].~facet_0)(v9, 10);
  std::locale::~locale(&v51);
  std::ostream::put();
  std::ostream::flush();
  sub_10004B96C(v8, (uint64_t)"\t fHardPausePresent = ", 22);
  uint64_t v10 = (void *)std::ostream::operator<<();
  std::ios_base::getloc((const std::ios_base *)((char *)v10 + *(void *)(*v10 - 24)));
  uint64_t v11 = std::locale::use_facet(&v51, &std::ctype<char>::id);
  ((void (*)(const std::locale::facet *, uint64_t))v11->__vftable[2].~facet_0)(v11, 10);
  std::locale::~locale(&v51);
  std::ostream::put();
  std::ostream::flush();
  uint64_t v12 = sub_10004B96C(v10, (uint64_t)"\t fNextHardPauseDigits = ", 25);
  int v13 = *(char *)(a1 + 127);
  if (v13 >= 0) {
    uint64_t v14 = a1 + 104;
  }
  else {
    uint64_t v14 = *(void *)(a1 + 104);
  }
  if (v13 >= 0) {
    uint64_t v15 = *(unsigned __int8 *)(a1 + 127);
  }
  else {
    uint64_t v15 = *(void *)(a1 + 112);
  }
  int v16 = sub_10004B96C(v12, v14, v15);
  std::ios_base::getloc((const std::ios_base *)((char *)v16 + *(void *)(*v16 - 24)));
  uint64_t v17 = std::locale::use_facet(&v51, &std::ctype<char>::id);
  ((void (*)(const std::locale::facet *, uint64_t))v17->__vftable[2].~facet_0)(v17, 10);
  std::locale::~locale(&v51);
  std::ostream::put();
  std::ostream::flush();
  char v18 = sub_10004B96C(v16, (uint64_t)"\t fUpcomingHardPauseDigits = ", 29);
  int v19 = *(char *)(a1 + 151);
  if (v19 >= 0) {
    uint64_t v20 = a1 + 128;
  }
  else {
    uint64_t v20 = *(void *)(a1 + 128);
  }
  if (v19 >= 0) {
    uint64_t v21 = *(unsigned __int8 *)(a1 + 151);
  }
  else {
    uint64_t v21 = *(void *)(a1 + 136);
  }
  uint64_t v22 = sub_10004B96C(v18, v20, v21);
  std::ios_base::getloc((const std::ios_base *)((char *)v22 + *(void *)(*v22 - 24)));
  uint64_t v23 = std::locale::use_facet(&v51, &std::ctype<char>::id);
  ((void (*)(const std::locale::facet *, uint64_t))v23->__vftable[2].~facet_0)(v23, 10);
  std::locale::~locale(&v51);
  std::ostream::put();
  std::ostream::flush();
  sub_10004B96C(v22, (uint64_t)"\t fQueue.size() = ", 18);
  uint64_t v24 = (void *)std::ostream::operator<<();
  std::ios_base::getloc((const std::ios_base *)((char *)v24 + *(void *)(*v24 - 24)));
  uint64_t v25 = std::locale::use_facet(&v51, &std::ctype<char>::id);
  ((void (*)(const std::locale::facet *, uint64_t))v25->__vftable[2].~facet_0)(v25, 10);
  std::locale::~locale(&v51);
  std::ostream::put();
  std::ostream::flush();
  sub_10004B96C(v24, (uint64_t)"\t Digits = ", 11);
  uint64_t v26 = *(void *)(a1 + 48);
  if (*(void *)(a1 + 56) != v26)
  {
    unint64_t v27 = *(void *)(a1 + 72);
    xpc_object_t v28 = (void *)(v26 + 8 * (v27 >> 12));
    uint64_t v29 = (unsigned char *)(*v28 + (v27 & 0xFFF));
    uint64_t v30 = *(void *)(v26 + (((*(void *)(a1 + 80) + v27) >> 9) & 0x7FFFFFFFFFFFF8))
        + ((*(void *)(a1 + 80) + v27) & 0xFFF);
    while (v29 != (unsigned char *)v30)
    {
      LOBYTE(v51.__locale_) = *v29;
      long long v31 = sub_10004B96C(v37, (uint64_t)&v51, 1);
      sub_10004B96C(v31, (uint64_t)", ", 2);
      if (&(++v29)[-*v28] == (unsigned char *)4096)
      {
        long long v32 = (unsigned char *)v28[1];
        ++v28;
        uint64_t v29 = v32;
      }
    }
  }
  std::ios_base::getloc((const std::ios_base *)((char *)v37 + *(void *)(*(void *)&v37[0] - 24)));
  uint64_t v33 = std::locale::use_facet(&v51, &std::ctype<char>::id);
  ((void (*)(const std::locale::facet *, uint64_t))v33->__vftable[2].~facet_0)(v33, 10);
  std::locale::~locale(&v51);
  std::ostream::put();
  std::ostream::flush();
  sub_10004BC98((uint64_t)v37 + 8, a2);
  *(void *)((char *)&v37[-1]
  *(void *)&v37[0] = v34;
  if (SHIBYTE(v39) < 0) {
    operator delete(__p[1]);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return std::ios::~ios();
}

void sub_100B24350(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::locale::~locale((std::locale *)(v9 - 72));
  sub_10008248C((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void sub_100B24394(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_100B24420(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100B24500((uint64_t *)va, 0);
  _Unwind_Resume(a1);
}

void sub_100B2443C(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100B24474(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result)
  {
    sub_100B22820(result);
    operator delete();
  }
  return result;
}

uint64_t sub_100B244BC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_100B24500(uint64_t *a1, uint64_t a2)
{
  uint64_t result = *a1;
  *a1 = a2;
  if (result)
  {
    sub_100B22820(result);
    operator delete();
  }
  return result;
}

uint64_t sub_100B24550(void *a1)
{
  uint64_t v2 = (void **)a1[1];
  uint64_t v3 = (void **)a1[2];
  a1[5] = 0;
  unint64_t v4 = (char *)v3 - (char *)v2;
  if ((unint64_t)((char *)v3 - (char *)v2) >= 0x11)
  {
    do
    {
      operator delete(*v2);
      uint64_t v3 = (void **)a1[2];
      uint64_t v2 = (void **)(a1[1] + 8);
      a1[1] = v2;
      unint64_t v4 = (char *)v3 - (char *)v2;
    }
    while ((unint64_t)((char *)v3 - (char *)v2) > 0x10);
  }
  unint64_t v5 = v4 >> 3;
  if (v5 == 1)
  {
    uint64_t v6 = 2048;
  }
  else
  {
    if (v5 != 2) {
      goto LABEL_9;
    }
    uint64_t v6 = 4096;
  }
  a1[4] = v6;
LABEL_9:
  while (v2 != v3)
  {
    unint64_t v7 = *v2++;
    operator delete(v7);
  }

  return sub_10005EE1C((uint64_t)a1);
}

void *sub_100B245F8(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t sub_100B2467C(uint64_t result, char *__src, unint64_t a3)
{
  unint64_t v4 = __src;
  unint64_t v5 = (void *)result;
  unint64_t v6 = *(void *)(result + 40);
  if (v6 < a3)
  {
    unint64_t v7 = *(void *)(result + 32);
    unint64_t v8 = v7 >> 12;
    uint64_t v9 = *(void *)(result + 8);
    uint64_t v10 = *(void *)(result + 16);
    if (v10 == v9) {
      uint64_t v11 = 0;
    }
    else {
      uint64_t v11 = (unsigned char *)(*(void *)(v9 + 8 * v8) + (*(void *)(result + 32) & 0xFFFLL));
    }
    uint64_t v17 = &__src[v6];
    if (v6)
    {
      char v18 = (void *)(v9 + 8 * v8);
      uint64_t v21 = (unsigned char *)*v18;
      uint64_t v20 = (void **)(v18 + 1);
      int v19 = v21;
      while (1)
      {
        uint64_t v22 = v19 - v11 + 4096;
        if (v17 - v4 >= v22) {
          size_t v23 = v22;
        }
        else {
          size_t v23 = v17 - v4;
        }
        if (v23) {
          memmove(v11, v4, v23);
        }
        v4 += v23;
        if (v4 == v17) {
          break;
        }
        uint64_t v24 = *v20++;
        int v19 = v24;
        uint64_t v11 = v24;
      }
      uint64_t v9 = v5[1];
      uint64_t v10 = v5[2];
      unint64_t v7 = v5[4];
      unint64_t v6 = v5[5];
    }
    uint64_t v25 = ((v10 - v9) << 9) - 1;
    if (v10 == v9) {
      uint64_t v25 = 0;
    }
    unint64_t v26 = a3 - v6;
    unint64_t v27 = v6 + v7;
    if (v26 > v25 - v27)
    {
      sub_100B2498C(v5, v26 - (v25 - v27));
      uint64_t v9 = v5[1];
      uint64_t v10 = v5[2];
      unint64_t v27 = v5[4] + v5[5];
    }
    xpc_object_t v28 = (void *)(v9 + 8 * (v27 >> 12));
    if (v10 == v9) {
      uint64_t v29 = 0;
    }
    else {
      uint64_t v29 = (char *)(*v28 + (v27 & 0xFFF));
    }
    int v52 = (char *)(v9 + 8 * (v27 >> 12));
    id v53 = v29;
    uint64_t result = (uint64_t)sub_100B24F18((uint64_t)&v52, v26);
    while (v29 != (char *)v37)
    {
      uint64_t v38 = (char *)(v28 == (void *)result ? v37 : *v28 + 4096);
      if (v29 == v38)
      {
        uint64_t v38 = v29;
      }
      else
      {
        long long v39 = v29;
        do
        {
          char v40 = *v17++;
          *v39++ = v40;
        }
        while (v39 != v38);
      }
      v5[5] += v38 - v29;
      if (v28 == (void *)result) {
        break;
      }
      long long v41 = (char *)v28[1];
      ++v28;
      uint64_t v29 = v41;
    }
    return result;
  }
  unint64_t v12 = *(void *)(result + 32);
  uint64_t v13 = *(void *)(result + 8);
  uint64_t v14 = *(void *)(result + 16);
  uint64_t v15 = (char *)(v13 + 8 * (v12 >> 12));
  if (v14 == v13)
  {
    int v16 = 0;
    if (!a3) {
      goto LABEL_50;
    }
LABEL_25:
    uint64_t v30 = &__src[a3];
    long long v31 = (void *)(v13 + 8 * (v12 >> 12));
    uint64_t v33 = (char *)*v31;
    uint64_t v15 = (char *)(v31 + 1);
    long long v32 = v33;
    while (1)
    {
      uint64_t v34 = v32 - v16 + 4096;
      if (v30 - v4 >= v34) {
        size_t v35 = v34;
      }
      else {
        size_t v35 = v30 - v4;
      }
      if (v35) {
        uint64_t result = (uint64_t)memmove(v16, v4, v35);
      }
      v4 += v35;
      if (v4 == v30) {
        break;
      }
      long long v36 = *(char **)v15;
      v15 += 8;
      long long v32 = v36;
      int v16 = v36;
    }
    v16 += v35;
    if ((char *)(*((void *)v15 - 1) + 4096) == v16) {
      int v16 = *(char **)v15;
    }
    else {
      v15 -= 8;
    }
    unint64_t v12 = v5[4];
    unint64_t v6 = v5[5];
    uint64_t v13 = v5[1];
    uint64_t v14 = v5[2];
    goto LABEL_50;
  }
  int v16 = (char *)(*(void *)v15 + (*(void *)(result + 32) & 0xFFFLL));
  if (a3) {
    goto LABEL_25;
  }
LABEL_50:
  __int16 v42 = v12 + v6;
  long long v43 = (char *)(v13 + 8 * ((v12 + v6) >> 12));
  if (v14 == v13) {
    long long v44 = 0;
  }
  else {
    long long v44 = (char *)(*(void *)v43 + (v42 & 0xFFF));
  }
  if (v44 != v16)
  {
    int64_t v45 = v43 - v15;
    uint64_t v46 = *(void *)v43;
    long long v47 = *(char **)v15;
    uint64_t v48 = &v44[512 * v45] - v16 - v46 + *(void *)v15;
    if (v48 >= 1)
    {
      long long v49 = (char *)(v13 + 8 * (v12 >> 12));
      if (v14 == v13) {
        uint64_t v50 = 0;
      }
      else {
        uint64_t v50 = (char *)(*(void *)v49 + (v12 & 0xFFF));
      }
      int v52 = v49;
      id v53 = v50;
      if (v50 == v16) {
        uint64_t v51 = 0;
      }
      else {
        uint64_t v51 = &v16[512 * (v15 - v49)] - v50 - (void)v47 + *(void *)v49;
      }
      sub_100B24F18((uint64_t)&v52, v51);
      v5[5] -= v48;
      do
        uint64_t result = sub_100B24F7C(v5, 1);
      while ((result & 1) != 0);
    }
  }
  return result;
}

void sub_100B2498C(void *a1, unint64_t a2)
{
  uint64_t v3 = (char *)a1[2];
  uint64_t v4 = (uint64_t)&v3[-a1[1]];
  if (v4) {
    unint64_t v5 = a2;
  }
  else {
    unint64_t v5 = a2 + 1;
  }
  if ((v5 & 0xFFF) != 0) {
    unint64_t v6 = (v5 >> 12) + 1;
  }
  else {
    unint64_t v6 = v5 >> 12;
  }
  unint64_t v7 = a1[4];
  if (v6 >= v7 >> 12) {
    unint64_t v8 = v7 >> 12;
  }
  else {
    unint64_t v8 = v6;
  }
  if (v6 <= v7 >> 12)
  {
    for (a1[4] = v7 - (v8 << 12); v8; --v8)
    {
      int v16 = (void *)a1[1];
      uint64_t v19 = *v16;
      uint64_t v17 = (char *)(v16 + 1);
      uint64_t v18 = v19;
      a1[1] = v17;
      if (v3 == (char *)a1[3])
      {
        uint64_t v20 = (uint64_t)&v17[-*a1];
        if ((unint64_t)v17 <= *a1)
        {
          if (v3 == (char *)*a1) {
            unint64_t v28 = 1;
          }
          else {
            unint64_t v28 = (uint64_t)&v3[-*a1] >> 2;
          }
          uint64_t v29 = (char *)sub_10004EF74((uint64_t)(a1 + 3), v28);
          long long v31 = &v29[8 * (v28 >> 2)];
          long long v32 = (uint64_t *)a1[1];
          uint64_t v3 = v31;
          uint64_t v33 = a1[2] - (void)v32;
          if (v33)
          {
            uint64_t v3 = &v31[v33 & 0xFFFFFFFFFFFFFFF8];
            uint64_t v34 = 8 * (v33 >> 3);
            size_t v35 = &v29[8 * (v28 >> 2)];
            do
            {
              uint64_t v36 = *v32++;
              *(void *)size_t v35 = v36;
              v35 += 8;
              v34 -= 8;
            }
            while (v34);
          }
          uint64_t v37 = (char *)*a1;
          *a1 = v29;
          a1[1] = v31;
          a1[2] = v3;
          a1[3] = &v29[8 * v30];
          if (v37)
          {
            operator delete(v37);
            uint64_t v3 = (char *)a1[2];
          }
        }
        else
        {
          uint64_t v21 = v20 >> 3;
          BOOL v22 = v20 >> 3 < -1;
          uint64_t v23 = (v20 >> 3) + 2;
          if (v22) {
            uint64_t v24 = v23;
          }
          else {
            uint64_t v24 = v21 + 1;
          }
          uint64_t v25 = &v17[-8 * (v24 >> 1)];
          int64_t v26 = v3 - v17;
          if (v3 != v17)
          {
            memmove(&v17[-8 * (v24 >> 1)], v17, v3 - v17);
            uint64_t v3 = (char *)a1[1];
          }
          unint64_t v27 = &v3[-8 * (v24 >> 1)];
          uint64_t v3 = &v25[v26];
          a1[1] = v27;
          a1[2] = &v25[v26];
        }
      }
      *(void *)uint64_t v3 = v18;
      uint64_t v3 = (char *)(a1[2] + 8);
      a1[2] = v3;
    }
  }
  else
  {
    unint64_t v9 = v6 - v8;
    uint64_t v10 = a1[3] - *a1;
    if (v6 - v8 <= (v10 >> 3) - (v4 >> 3))
    {
      if (v9)
      {
        while (a1[3] != a1[2])
        {
          __p[0] = operator new(0x1000uLL);
          sub_100097C14(a1, __p);
          --v6;
          if (!--v9) {
            goto LABEL_75;
          }
        }
        for (uint64_t i = 0; i != v9; ++i)
        {
          __p[0] = operator new(0x1000uLL);
          sub_100097D2C((uint64_t)a1, __p);
          if (a1[2] - a1[1] == 8) {
            uint64_t v64 = 4095;
          }
          else {
            uint64_t v64 = 4096;
          }
          uint64_t v65 = v64 + a1[4];
          a1[4] = v65;
        }
        unint64_t v8 = v6;
      }
      else
      {
LABEL_75:
        uint64_t v65 = a1[4];
      }
      a1[4] = v65 - (v8 << 12);
      if (v8)
      {
        long long v66 = (char *)a1[2];
        do
        {
          char v67 = (void *)a1[1];
          uint64_t v70 = *v67;
          uint64_t v68 = (char *)(v67 + 1);
          uint64_t v69 = v70;
          a1[1] = v68;
          if (v66 == (char *)a1[3])
          {
            uint64_t v71 = (uint64_t)&v68[-*a1];
            if ((unint64_t)v68 <= *a1)
            {
              if (v66 == (char *)*a1) {
                unint64_t v78 = 1;
              }
              else {
                unint64_t v78 = (uint64_t)&v66[-*a1] >> 2;
              }
              double v79 = (char *)sub_10004EF74((uint64_t)(a1 + 3), v78);
              xpc_object_t v81 = &v79[8 * (v78 >> 2)];
              xpc_object_t v82 = (uint64_t *)a1[1];
              long long v66 = v81;
              uint64_t v83 = a1[2] - (void)v82;
              if (v83)
              {
                long long v66 = &v81[v83 & 0xFFFFFFFFFFFFFFF8];
                uint64_t v84 = 8 * (v83 >> 3);
                xpc_object_t v85 = &v79[8 * (v78 >> 2)];
                do
                {
                  uint64_t v86 = *v82++;
                  *(void *)xpc_object_t v85 = v86;
                  v85 += 8;
                  v84 -= 8;
                }
                while (v84);
              }
              xpc_object_t v87 = (char *)*a1;
              *a1 = v79;
              a1[1] = v81;
              a1[2] = v66;
              a1[3] = &v79[8 * v80];
              if (v87)
              {
                operator delete(v87);
                long long v66 = (char *)a1[2];
              }
            }
            else
            {
              uint64_t v72 = v71 >> 3;
              BOOL v22 = v71 >> 3 < -1;
              uint64_t v73 = (v71 >> 3) + 2;
              if (v22) {
                uint64_t v74 = v73;
              }
              else {
                uint64_t v74 = v72 + 1;
              }
              int v75 = &v68[-8 * (v74 >> 1)];
              int64_t v76 = v66 - v68;
              if (v66 != v68)
              {
                memmove(&v68[-8 * (v74 >> 1)], v68, v66 - v68);
                long long v66 = (char *)a1[1];
              }
              xpc_object_t v77 = &v66[-8 * (v74 >> 1)];
              long long v66 = &v75[v76];
              a1[1] = v77;
              a1[2] = &v75[v76];
            }
          }
          *(void *)long long v66 = v69;
          long long v66 = (char *)(a1[2] + 8);
          a1[2] = v66;
          --v8;
        }
        while (v8);
      }
    }
    else
    {
      uint64_t v11 = v4 >> 3;
      unint64_t v12 = v10 >> 2;
      if (v12 <= v9 + v11) {
        unint64_t v13 = v9 + v11;
      }
      else {
        unint64_t v13 = v12;
      }
      unint64_t v14 = v11 - v8;
      xpc_object_t v91 = a1 + 3;
      if (v13) {
        uint64_t v15 = (char *)sub_10004EF74((uint64_t)(a1 + 3), v13);
      }
      else {
        uint64_t v15 = 0;
      }
      uint64_t v38 = v8 << 12;
      __p[0] = v15;
      __p[1] = &v15[8 * v14];
      *(void **)&long long v90 = __p[1];
      *((void *)&v90 + 1) = &v15[8 * v13];
      do
      {
        xpc_object_t v88 = operator new(0x1000uLL);
        sub_100097E4C(__p, &v88);
        --v9;
      }
      while (v9);
      if (v8)
      {
        long long v39 = (void *)a1[1];
        char v40 = (char *)v90;
        do
        {
          if (v40 == *((char **)&v90 + 1))
          {
            int64_t v41 = (char *)__p[1] - (char *)__p[0];
            if (__p[1] <= __p[0])
            {
              if (v40 == __p[0]) {
                unint64_t v48 = 1;
              }
              else {
                unint64_t v48 = (v40 - (char *)__p[0]) >> 2;
              }
              long long v49 = (char *)sub_10004EF74((uint64_t)v91, v48);
              uint64_t v51 = (uint64_t *)__p[1];
              char v40 = &v49[8 * (v48 >> 2)];
              uint64_t v52 = v90 - (unint64_t)__p[1];
              if ((void *)v90 != __p[1])
              {
                char v40 = &v49[8 * (v48 >> 2) + (v52 & 0xFFFFFFFFFFFFFFF8)];
                uint64_t v53 = 8 * (v52 >> 3);
                long long v54 = &v49[8 * (v48 >> 2)];
                do
                {
                  uint64_t v55 = *v51++;
                  *(void *)long long v54 = v55;
                  v54 += 8;
                  v53 -= 8;
                }
                while (v53);
              }
              long long v56 = __p[0];
              __p[0] = v49;
              __p[1] = &v49[8 * (v48 >> 2)];
              *(void *)&long long v90 = v40;
              *((void *)&v90 + 1) = &v49[8 * v50];
              if (v56)
              {
                operator delete(v56);
                char v40 = (char *)v90;
              }
            }
            else
            {
              uint64_t v42 = v41 >> 3;
              BOOL v22 = v41 >> 3 < -1;
              uint64_t v43 = (v41 >> 3) + 2;
              if (v22) {
                uint64_t v44 = v43;
              }
              else {
                uint64_t v44 = v42 + 1;
              }
              int64_t v45 = (char *)__p[1] - 8 * (v44 >> 1);
              int64_t v46 = v40 - (char *)__p[1];
              if (v40 != __p[1])
              {
                memmove((char *)__p[1] - 8 * (v44 >> 1), __p[1], v40 - (char *)__p[1]);
                char v40 = (char *)__p[1];
              }
              long long v47 = &v40[-8 * (v44 >> 1)];
              char v40 = &v45[v46];
              __p[1] = v47;
              *(void *)&long long v90 = &v45[v46];
            }
          }
          *(void *)char v40 = *v39;
          char v40 = (char *)(v90 + 8);
          *(void *)&long long v90 = v90 + 8;
          long long v39 = (void *)(a1[1] + 8);
          a1[1] = v39;
          --v8;
        }
        while (v8);
      }
      uint64_t v57 = (void *)a1[2];
      uint64_t v58 = -7 - (void)v57;
      while (v57 != (void *)a1[1])
      {
        --v57;
        v58 += 8;
        sub_100097F64((uint64_t)__p, v57);
      }
      uint64_t v59 = (char *)*a1;
      long long v60 = *(_OWORD *)__p;
      long long v61 = v90;
      __p[0] = *(void **)a1;
      __p[1] = v57;
      long long v62 = *((_OWORD *)a1 + 1);
      *(_OWORD *)a1 = v60;
      *((_OWORD *)a1 + 1) = v61;
      long long v90 = v62;
      a1[4] -= v38;
      if (v57 != (void *)v62) {
        *(void *)&long long v90 = v62 + (-(v62 + v58) & 0xFFFFFFFFFFFFFFF8);
      }
      if (v59) {
        operator delete(v59);
      }
    }
  }
}

void sub_100B24EA4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *sub_100B24F18(uint64_t a1, uint64_t a2)
{
  uint64_t result = *(void **)a1;
  if (a2)
  {
    uint64_t v4 = *(void *)(a1 + 8) - *result + a2;
    if (v4 < 1) {
      result -= (unint64_t)(4095 - v4) >> 12;
    }
    else {
      result += (unint64_t)v4 >> 12;
    }
  }
  return result;
}

uint64_t sub_100B24F7C(void *a1, int a2)
{
  uint64_t v3 = a1[1];
  uint64_t v2 = a1[2];
  if (v2 == v3) {
    uint64_t v4 = 0;
  }
  else {
    uint64_t v4 = ((v2 - v3) << 9) - 1;
  }
  unint64_t v5 = v4 - (a1[5] + a1[4]);
  if (v5 < 0x1000) {
    a2 = 1;
  }
  if (v5 < 0x2000) {
    int v7 = a2;
  }
  else {
    int v7 = 0;
  }
  if ((v7 & 1) == 0)
  {
    operator delete(*(void **)(v2 - 8));
    a1[2] -= 8;
  }
  return v7 ^ 1u;
}

void sub_100B24FEC(void *a1)
{
  unint64_t v2 = a1[4];
  BOOL v3 = v2 >= 0x1000;
  unint64_t v4 = v2 - 4096;
  if (v3)
  {
    uint64_t v5 = (uint64_t)(a1 + 3);
    unint64_t v6 = (char *)a1[3];
    a1[4] = v4;
    int v7 = (void *)a1[1];
    unint64_t v8 = (char *)a1[2];
    uint64_t v11 = *v7;
    unint64_t v9 = (char *)(v7 + 1);
    uint64_t v10 = v11;
    a1[1] = v9;
    if (v8 != v6)
    {
LABEL_33:
      *(void *)unint64_t v8 = v10;
      a1[2] += 8;
      return;
    }
    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      if (v8 == (char *)*a1) {
        unint64_t v33 = 1;
      }
      else {
        unint64_t v33 = (uint64_t)&v8[-*a1] >> 2;
      }
      uint64_t v34 = (char *)sub_10004EF74(v5, v33);
      size_t v35 = &v34[8 * (v33 >> 2)];
      uint64_t v37 = &v34[8 * v36];
      uint64_t v38 = (uint64_t *)a1[1];
      unint64_t v8 = v35;
      uint64_t v39 = a1[2] - (void)v38;
      if (v39)
      {
        unint64_t v8 = &v35[v39 & 0xFFFFFFFFFFFFFFF8];
        uint64_t v40 = 8 * (v39 >> 3);
        int64_t v41 = &v34[8 * (v33 >> 2)];
        do
        {
          uint64_t v42 = *v38++;
          *(void *)int64_t v41 = v42;
          v41 += 8;
          v40 -= 8;
        }
        while (v40);
      }
      goto LABEL_30;
    }
LABEL_5:
    uint64_t v13 = v12 >> 3;
    BOOL v14 = v12 >> 3 < -1;
    uint64_t v15 = (v12 >> 3) + 2;
    if (v14) {
      uint64_t v16 = v15;
    }
    else {
      uint64_t v16 = v13 + 1;
    }
    uint64_t v17 = -(v16 >> 1);
    uint64_t v18 = v16 >> 1;
    uint64_t v19 = &v9[-8 * v18];
    int64_t v20 = v8 - v9;
    if (v8 != v9)
    {
      memmove(&v9[-8 * v18], v9, v8 - v9);
      unint64_t v9 = (char *)a1[1];
    }
    unint64_t v8 = &v19[v20];
    a1[1] = &v9[8 * v17];
    a1[2] = &v19[v20];
    goto LABEL_33;
  }
  uint64_t v21 = a1[2];
  unint64_t v22 = (v21 - a1[1]) >> 3;
  uint64_t v23 = a1[3];
  uint64_t v24 = v23 - *a1;
  if (v22 < v24 >> 3)
  {
    if (v23 != v21)
    {
      *(void *)&long long v54 = operator new(0x1000uLL);
      sub_100097C14(a1, &v54);
      return;
    }
    *(void *)&long long v54 = operator new(0x1000uLL);
    sub_100097D2C((uint64_t)a1, &v54);
    uint64_t v44 = (void *)a1[1];
    unint64_t v8 = (char *)a1[2];
    uint64_t v45 = *v44;
    unint64_t v9 = (char *)(v44 + 1);
    uint64_t v10 = v45;
    a1[1] = v9;
    if (v8 != (char *)a1[3]) {
      goto LABEL_33;
    }
    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      if (v8 == (char *)*a1) {
        unint64_t v46 = 1;
      }
      else {
        unint64_t v46 = (uint64_t)&v8[-*a1] >> 2;
      }
      uint64_t v34 = (char *)sub_10004EF74((uint64_t)(a1 + 3), v46);
      size_t v35 = &v34[8 * (v46 >> 2)];
      uint64_t v37 = &v34[8 * v47];
      unint64_t v48 = (uint64_t *)a1[1];
      unint64_t v8 = v35;
      uint64_t v49 = a1[2] - (void)v48;
      if (v49)
      {
        unint64_t v8 = &v35[v49 & 0xFFFFFFFFFFFFFFF8];
        uint64_t v50 = 8 * (v49 >> 3);
        uint64_t v51 = &v34[8 * (v46 >> 2)];
        do
        {
          uint64_t v52 = *v48++;
          *(void *)uint64_t v51 = v52;
          v51 += 8;
          v50 -= 8;
        }
        while (v50);
      }
LABEL_30:
      uint64_t v43 = (char *)*a1;
      *a1 = v34;
      a1[1] = v35;
      a1[2] = v8;
      a1[3] = v37;
      if (v43)
      {
        operator delete(v43);
        unint64_t v8 = (char *)a1[2];
      }
      goto LABEL_33;
    }
    goto LABEL_5;
  }
  if (v23 == *a1) {
    unint64_t v25 = 1;
  }
  else {
    unint64_t v25 = v24 >> 2;
  }
  long long v56 = a1 + 3;
  *(void *)&long long v54 = sub_10004EF74((uint64_t)(a1 + 3), v25);
  *((void *)&v54 + 1) = v54 + 8 * v22;
  *(void *)&long long v55 = *((void *)&v54 + 1);
  *((void *)&v55 + 1) = v54 + 8 * v26;
  uint64_t v53 = operator new(0x1000uLL);
  sub_100097E4C(&v54, &v53);
  unint64_t v27 = (void *)a1[2];
  uint64_t v28 = -7 - (void)v27;
  while (v27 != (void *)a1[1])
  {
    --v27;
    v28 += 8;
    sub_100097F64((uint64_t)&v54, v27);
  }
  uint64_t v29 = (char *)*a1;
  long long v30 = v54;
  long long v31 = v55;
  *(void *)&long long v54 = *a1;
  *((void *)&v54 + 1) = v27;
  long long v32 = *((_OWORD *)a1 + 1);
  *(_OWORD *)a1 = v30;
  *((_OWORD *)a1 + 1) = v31;
  long long v55 = v32;
  if (v27 != (void *)v32) {
    *(void *)&long long v55 = v32 + (-(v32 + v28) & 0xFFFFFFFFFFFFFFF8);
  }
  if (v29) {
    operator delete(v29);
  }
}

void sub_100B252B8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13)
{
  operator delete(v13);
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100B25304(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

uint64_t sub_100B2539C(uint64_t a1, int a2)
{
  unint64_t v2 = *(void *)(a1 + 32);
  if (v2 < 0x1000) {
    a2 = 1;
  }
  if (v2 < 0x2000) {
    int v4 = a2;
  }
  else {
    int v4 = 0;
  }
  if ((v4 & 1) == 0)
  {
    operator delete(**(void ***)(a1 + 8));
    *(void *)(a1 + 8) += 8;
    *(void *)(a1 + 32) -= 4096;
  }
  return v4 ^ 1u;
}

void sub_100B253FC()
{
}

void sub_100B254C4(_Unwind_Exception *exception_object)
{
  if (v1) {
    dispatch_release(v1);
  }
  if (v2) {
    operator delete();
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100B254F8(uint64_t a1, NSObject **a2, uint64_t a3)
{
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  unint64_t v6 = *a2;
  *(void *)(a1 + 24) = *a2;
  if (v6) {
    dispatch_retain(v6);
  }
  *(void *)(a1 + 32) = 0;
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 40), "com.apple.telephony", "subscr.info");
  *(void *)a1 = off_101A3BE78;
  *(void *)(a1 + 48) = *(void *)a3;
  uint64_t v7 = *(void *)(a3 + 8);
  *(void *)(a1 + 56) = v7;
  if (v7) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v7 + 8), 1uLL, memory_order_relaxed);
  }
  sub_100058DB0(&__p, "SubscriberInfoController");
  unint64_t v8 = *a2;
  dispatch_object_t v17 = v8;
  if (v8) {
    dispatch_retain(v8);
  }
  unint64_t v9 = *(NSObject **)(a1 + 32);
  dispatch_object_t object = v9;
  if (v9) {
    dispatch_retain(v9);
  }
  ctu::RestModule::RestModule();
  if (object) {
    dispatch_release(object);
  }
  if (v17) {
    dispatch_release(v17);
  }
  if (v19 < 0) {
    operator delete(__p);
  }
  Registry::getCommandDriversFactory(&v14, *(Registry **)a3);
  uint64_t v10 = v14;
  uint64_t v11 = *a2;
  dispatch_object_t v13 = v11;
  if (v11) {
    dispatch_retain(v11);
  }
  (*(void (**)(uint64_t, dispatch_object_t *))(*(void *)v10 + 48))(v10, &v13);
  if (v13) {
    dispatch_release(v13);
  }
  if (v15) {
    sub_10004D2C8(v15);
  }
  Registry::getNotificationSenderFactory(&v14, *(Registry **)(a1 + 48));
  (*(void (**)(uint64_t))(*(void *)v14 + 88))(v14);
  if (v15) {
    sub_10004D2C8(v15);
  }
  *(void *)(a1 + 120) = 0;
  *(void *)(a1 + 112) = a1 + 120;
  *(void *)(a1 + 144) = 0;
  *(void *)(a1 + 128) = 0;
  *(void *)(a1 + 136) = a1 + 144;
  *(void *)(a1 + 152) = 0;
  sub_1000FE9CC((uint64_t *)(a1 + 160), (uint64_t)&rest::kDefaultBundles);
  *(void *)(a1 + 200) = 0;
  *(void *)(a1 + 192) = 0;
  *(void *)(a1 + 184) = a1 + 192;
  return a1;
}

void sub_100B25738(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, dispatch_object_t object, uint64_t a10, uint64_t a11, dispatch_object_t a12, dispatch_object_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19)
{
  sub_1000346F8(v23, *(void **)(v19 + 144));
  sub_100088048(v22, *(void **)(v19 + 120));
  unint64_t v25 = *(std::__shared_weak_count **)(v19 + 104);
  if (v25) {
    sub_10004D2C8(v25);
  }
  uint64_t v26 = *(std::__shared_weak_count **)(v19 + 88);
  if (v26) {
    sub_10004D2C8(v26);
  }
  unint64_t v27 = *(std::__shared_weak_count **)(v19 + 72);
  if (v27) {
    sub_10004D2C8(v27);
  }
  uint64_t v28 = *(std::__shared_weak_count **)(v19 + 56);
  if (v28) {
    sub_10004D2C8(v28);
  }
  ctu::OsLogLogger::~OsLogLogger(v21);
  sub_100087E88(v20);
  SubscriberInfoControllerInterface::~SubscriberInfoControllerInterface((SubscriberInfoControllerInterface *)v19);
  _Unwind_Resume(a1);
}

void sub_100B25818()
{
}

uint64_t sub_100B25820(uint64_t a1)
{
  Registry::createRestModuleOneTimeUseConnection(&v7, *(Registry **)(a1 + 48));
  ctu::RestModule::connect();
  if (v8) {
    sub_10004D2C8(v8);
  }
  sub_100058DB0(__p, "/cc/props/sims_in_use");
  int v2 = operator new(0x28uLL);
  void *v2 = off_101A3BFB0;
  v2[1] = a1 + 112;
  v2[2] = a1;
  v2[3] = sub_100B25B14;
  v2[4] = 0;
  uint64_t v12 = v2;
  ctu::RestModule::observeProperty();
  sub_10003F600(v11);
  if (v10 < 0) {
    operator delete(__p[0]);
  }
  sub_100058DB0(__p, "/cc/props/cdma_aux_info_ready");
  uint64_t v3 = operator new(0x28uLL);
  void *v3 = off_101A3C030;
  v3[1] = a1 + 136;
  v3[2] = a1;
  v3[3] = sub_100B25C34;
  _OWORD v3[4] = 0;
  uint64_t v12 = v3;
  ctu::RestModule::observeProperty();
  sub_10003F600(v11);
  if (v10 < 0) {
    operator delete(__p[0]);
  }
  sub_100058DB0(__p, "/cc/props/carrier_bundles");
  int v4 = operator new(0x28uLL);
  *int v4 = off_101A3C0B0;
  v4[1] = a1 + 160;
  void v4[2] = a1;
  v4[3] = sub_100B25FB4;
  v4[4] = 0;
  uint64_t v12 = v4;
  ctu::RestModule::observeProperty();
  sub_10003F600(v11);
  if (v10 < 0) {
    operator delete(__p[0]);
  }
  sub_100058DB0(__p, "/cc/device_info/prl_versions");
  uint64_t v5 = operator new(0x28uLL);
  *uint64_t v5 = off_101A3C130;
  v5[1] = a1 + 184;
  _OWORD v5[2] = a1;
  uint64_t v5[3] = sub_100B26164;
  v5[4] = 0;
  uint64_t v12 = v5;
  ctu::RestModule::observeProperty();
  sub_10003F600(v11);
  if (v10 < 0) {
    operator delete(__p[0]);
  }
  return (*(uint64_t (**)(void))(**(void **)(a1 + 80) + 16))(*(void *)(a1 + 80));
}

void sub_100B25AB4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100B25B14(uint64_t result, uint64_t a2)
{
  int v2 = *(void **)(result + 112);
  uint64_t v3 = (void *)(result + 120);
  if (v2 != (void *)(result + 120))
  {
    uint64_t v4 = result;
    uint64_t v5 = (void *)(a2 + 8);
    while (1)
    {
      uint64_t v6 = *v5;
      if (!*v5) {
        break;
      }
      uint64_t v7 = *((unsigned int *)v2 + 8);
      unint64_t v8 = v5;
      do
      {
        int v9 = *(_DWORD *)(v6 + 32);
        BOOL v10 = v9 < (int)v7;
        if (v9 >= (int)v7) {
          uint64_t v11 = (uint64_t *)v6;
        }
        else {
          uint64_t v11 = (uint64_t *)(v6 + 8);
        }
        if (!v10) {
          unint64_t v8 = (void *)v6;
        }
        uint64_t v6 = *v11;
      }
      while (*v11);
      if (v8 == v5 || (int)v7 < *((_DWORD *)v8 + 8)) {
        goto LABEL_15;
      }
      uint64_t result = BasicSimInfo::operator==();
      if ((result & 1) == 0) {
        break;
      }
LABEL_18:
      uint64_t v12 = (void *)v2[1];
      if (v12)
      {
        do
        {
          dispatch_object_t v13 = v12;
          uint64_t v12 = (void *)*v12;
        }
        while (v12);
      }
      else
      {
        do
        {
          dispatch_object_t v13 = (void *)v2[2];
          BOOL v14 = *v13 == (void)v2;
          int v2 = v13;
        }
        while (!v14);
      }
      int v2 = v13;
      if (v13 == v3) {
        return result;
      }
    }
    uint64_t v7 = *((unsigned int *)v2 + 8);
LABEL_15:
    uint64_t result = subscriber::isSimAbsent();
    if (result)
    {
      uint64_t result = subscriber::isPhySimDisabled();
      if ((result & 1) == 0) {
        uint64_t result = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(v4 + 80) + 48))(*(void *)(v4 + 80), v7, 192);
      }
    }
    goto LABEL_18;
  }
  return result;
}

void sub_100B25C34(uint64_t a1, void *a2)
{
  if (a2[2] == *(void *)(a1 + 152))
  {
    uint64_t v3 = (void *)*a2;
    if ((void *)*a2 == a2 + 1)
    {
LABEL_20:
      uint64_t v11 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I No change in CDMA Aux Info readiness", buf, 2u);
      }
      uint64_t v12 = *(void **)(a1 + 136);
      if (v12 != (void *)(a1 + 144))
      {
        do
        {
          if (!*((unsigned char *)v12 + 32)) {
            (*(void (**)(void, void, uint64_t))(**(void **)(a1 + 80) + 48))(*(void *)(a1 + 80), *((unsigned int *)v12 + 7), 192);
          }
          dispatch_object_t v13 = (void *)v12[1];
          if (v13)
          {
            do
            {
              BOOL v14 = v13;
              dispatch_object_t v13 = (void *)*v13;
            }
            while (v13);
          }
          else
          {
            do
            {
              BOOL v14 = (void *)v12[2];
              BOOL v6 = *v14 == (void)v12;
              uint64_t v12 = v14;
            }
            while (!v6);
          }
          uint64_t v12 = v14;
        }
        while (v14 != (void *)(a1 + 144));
      }
      return;
    }
    uint64_t v4 = *(void **)(a1 + 136);
    uint64_t v5 = v4;
    while (1)
    {
      BOOL v6 = *((_DWORD *)v3 + 7) == *((_DWORD *)v5 + 7) && *((unsigned __int8 *)v3 + 32) == *((unsigned __int8 *)v5 + 32);
      if (!v6) {
        break;
      }
      uint64_t v7 = (void *)v3[1];
      unint64_t v8 = v3;
      if (v7)
      {
        do
        {
          uint64_t v3 = v7;
          uint64_t v7 = (void *)*v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          uint64_t v3 = (void *)v8[2];
          BOOL v6 = *v3 == (void)v8;
          unint64_t v8 = v3;
        }
        while (!v6);
      }
      int v9 = (void *)v5[1];
      if (v9)
      {
        do
        {
          BOOL v10 = v9;
          int v9 = (void *)*v9;
        }
        while (v9);
      }
      else
      {
        do
        {
          BOOL v10 = (void *)v5[2];
          BOOL v6 = *v10 == (void)v5;
          uint64_t v5 = v10;
        }
        while (!v6);
      }
      uint64_t v5 = v10;
      if (v3 == a2 + 1) {
        goto LABEL_20;
      }
    }
  }
  else
  {
    uint64_t v4 = *(void **)(a1 + 136);
  }
  uint64_t v15 = (void *)(a1 + 144);
  if (v4 != (void *)(a1 + 144))
  {
    uint64_t v16 = a2 + 1;
    do
    {
      uint64_t v17 = *v16;
      uint64_t v18 = *((unsigned int *)v4 + 7);
      if (!*v16) {
        goto LABEL_45;
      }
      uint64_t v19 = v16;
      do
      {
        int v20 = *(_DWORD *)(v17 + 28);
        BOOL v21 = v20 < (int)v18;
        if (v20 >= (int)v18) {
          uint64_t v22 = (uint64_t *)v17;
        }
        else {
          uint64_t v22 = (uint64_t *)(v17 + 8);
        }
        if (!v21) {
          uint64_t v19 = (void *)v17;
        }
        uint64_t v17 = *v22;
      }
      while (*v22);
      if (v19 != v16 && (int)v18 >= *((_DWORD *)v19 + 7))
      {
        int v26 = *((unsigned __int8 *)v4 + 32);
        if (*((unsigned __int8 *)v19 + 32) == v26) {
          goto LABEL_54;
        }
        unint64_t v27 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v28 = subscriber::asString();
          *(_DWORD *)std::string buf = 136315394;
          uint64_t v32 = v28;
          __int16 v33 = 1024;
          int v34 = v26;
          _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "#I slot %s, isReady %d", buf, 0x12u);
        }
        if (!v26)
        {
LABEL_53:
          (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 80) + 48))(*(void *)(a1 + 80), v18, 192);
          goto LABEL_54;
        }
      }
      else
      {
LABEL_45:
        int v23 = *((unsigned __int8 *)v4 + 32);
        uint64_t v24 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v25 = subscriber::asString();
          *(_DWORD *)std::string buf = 136315394;
          uint64_t v32 = v25;
          __int16 v33 = 1024;
          int v34 = v23;
          _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "#I slot %s, isReady %d", buf, 0x12u);
        }
        if (!v23) {
          goto LABEL_53;
        }
      }
      sub_100B26378(a1, v18);
LABEL_54:
      uint64_t v29 = (void *)v4[1];
      if (v29)
      {
        do
        {
          long long v30 = v29;
          uint64_t v29 = (void *)*v29;
        }
        while (v29);
      }
      else
      {
        do
        {
          long long v30 = (void *)v4[2];
          BOOL v6 = *v30 == (void)v4;
          uint64_t v4 = v30;
        }
        while (!v6);
      }
      uint64_t v4 = v30;
    }
    while (v30 != v15);
  }
}

void sub_100B25FB4(uint64_t a1, uint64_t a2)
{
  int v2 = *(void **)(a1 + 160);
  uint64_t v3 = (void *)(a1 + 168);
  if (v2 != (void *)(a1 + 168))
  {
    uint64_t v5 = (void *)(a2 + 8);
    BOOL v6 = (void *)(a1 + 120);
    while (1)
    {
      uint64_t v7 = *v5;
      if (!*v5) {
        break;
      }
      uint64_t v8 = *((unsigned int *)v2 + 8);
      int v9 = v5;
      do
      {
        int v10 = *(_DWORD *)(v7 + 32);
        BOOL v11 = v10 < (int)v8;
        if (v10 >= (int)v8) {
          uint64_t v12 = (uint64_t *)v7;
        }
        else {
          uint64_t v12 = (uint64_t *)(v7 + 8);
        }
        if (!v11) {
          int v9 = (void *)v7;
        }
        uint64_t v7 = *v12;
      }
      while (*v12);
      if (v9 == v5 || (int)v8 < *((_DWORD *)v9 + 8)) {
        goto LABEL_30;
      }
      if ((rest::operator==() & 1) == 0)
      {
        if (*((unsigned char *)v2 + 40))
        {
          uint64_t v13 = *v6;
          if (*v6)
          {
            uint64_t v8 = *((unsigned int *)v2 + 8);
            BOOL v14 = v6;
            do
            {
              int v15 = *(_DWORD *)(v13 + 32);
              BOOL v16 = v15 < (int)v8;
              if (v15 >= (int)v8) {
                uint64_t v17 = (uint64_t *)v13;
              }
              else {
                uint64_t v17 = (uint64_t *)(v13 + 8);
              }
              if (!v16) {
                BOOL v14 = (void *)v13;
              }
              uint64_t v13 = *v17;
            }
            while (*v17);
            if (v14 != v6 && *((_DWORD *)v14 + 8) <= (int)v8)
            {
              uint64_t v19 = (_DWORD *)v14[7];
              uint64_t v18 = (_DWORD *)v14[8];
              while (v19 != v18)
              {
                if ((*v19 - 3) <= 1) {
                  goto LABEL_45;
                }
                ++v19;
              }
            }
          }
        }
      }
LABEL_46:
      unint64_t v27 = (void *)v2[1];
      if (v27)
      {
        do
        {
          uint64_t v28 = v27;
          unint64_t v27 = (void *)*v27;
        }
        while (v27);
      }
      else
      {
        do
        {
          uint64_t v28 = (void *)v2[2];
          BOOL v29 = *v28 == (void)v2;
          int v2 = v28;
        }
        while (!v29);
      }
      int v2 = v28;
      if (v28 == v3) {
        return;
      }
    }
    uint64_t v8 = *((unsigned int *)v2 + 8);
LABEL_30:
    if (*((unsigned char *)v2 + 40))
    {
      uint64_t v20 = *v6;
      if (*v6)
      {
        BOOL v21 = v6;
        do
        {
          int v22 = *(_DWORD *)(v20 + 32);
          BOOL v23 = v22 < (int)v8;
          if (v22 >= (int)v8) {
            uint64_t v24 = (uint64_t *)v20;
          }
          else {
            uint64_t v24 = (uint64_t *)(v20 + 8);
          }
          if (!v23) {
            BOOL v21 = (void *)v20;
          }
          uint64_t v20 = *v24;
        }
        while (*v24);
        if (v21 != v6 && *((_DWORD *)v21 + 8) <= (int)v8)
        {
          int v26 = (_DWORD *)v21[7];
          uint64_t v25 = (_DWORD *)v21[8];
          while (v26 != v25)
          {
            if ((*v26 - 3) < 2)
            {
LABEL_45:
              sub_100B26378(a1, v8);
              goto LABEL_46;
            }
            ++v26;
          }
        }
      }
    }
    goto LABEL_46;
  }
}

uint64_t sub_100B26164(uint64_t result, void *a2)
{
  uint64_t v2 = result;
  if (a2[2] == *(void *)(result + 200))
  {
    uint64_t v3 = (void *)*a2;
    if ((void *)*a2 == a2 + 1) {
      return result;
    }
    uint64_t v4 = *(void **)(result + 184);
    uint64_t v5 = v4;
    while (1)
    {
      BOOL v6 = *((_DWORD *)v3 + 7) == *((_DWORD *)v5 + 7)
        && *((unsigned __int16 *)v3 + 16) == *((unsigned __int16 *)v5 + 16);
      if (!v6) {
        break;
      }
      uint64_t v7 = (void *)v3[1];
      uint64_t v8 = v3;
      if (v7)
      {
        do
        {
          uint64_t v3 = v7;
          uint64_t v7 = (void *)*v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          uint64_t v3 = (void *)v8[2];
          BOOL v6 = *v3 == (void)v8;
          uint64_t v8 = v3;
        }
        while (!v6);
      }
      int v9 = (void *)v5[1];
      if (v9)
      {
        do
        {
          int v10 = v9;
          int v9 = (void *)*v9;
        }
        while (v9);
      }
      else
      {
        do
        {
          int v10 = (void *)v5[2];
          BOOL v6 = *v10 == (void)v5;
          uint64_t v5 = v10;
        }
        while (!v6);
      }
      uint64_t v5 = v10;
      if (v3 == a2 + 1) {
        return result;
      }
    }
  }
  else
  {
    uint64_t v4 = *(void **)(result + 184);
  }
  BOOL v11 = (void *)(result + 192);
  if (v4 != (void *)(result + 192))
  {
    uint64_t v12 = a2 + 1;
    do
    {
      uint64_t v13 = *v12;
      uint64_t v14 = *((unsigned int *)v4 + 7);
      if (!*v12) {
        goto LABEL_34;
      }
      int v15 = v12;
      do
      {
        int v16 = *(_DWORD *)(v13 + 28);
        BOOL v17 = v16 < (int)v14;
        if (v16 >= (int)v14) {
          uint64_t v18 = (uint64_t *)v13;
        }
        else {
          uint64_t v18 = (uint64_t *)(v13 + 8);
        }
        if (!v17) {
          int v15 = (void *)v13;
        }
        uint64_t v13 = *v18;
      }
      while (*v18);
      if (v15 != v12 && (int)v14 >= *((_DWORD *)v15 + 7))
      {
        uint64_t v20 = *((unsigned __int16 *)v4 + 16);
        if (*((unsigned __int16 *)v15 + 16) == v20) {
          goto LABEL_36;
        }
        uint64_t v19 = *(void *)(v2 + 96);
      }
      else
      {
LABEL_34:
        uint64_t v19 = *(void *)(v2 + 96);
        uint64_t v20 = *((unsigned __int16 *)v4 + 16);
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v19 + 88))(v19, v14, v20);
LABEL_36:
      BOOL v21 = (void *)v4[1];
      if (v21)
      {
        do
        {
          int v22 = v21;
          BOOL v21 = (void *)*v21;
        }
        while (v21);
      }
      else
      {
        do
        {
          int v22 = (void *)v4[2];
          BOOL v6 = *v22 == (void)v4;
          uint64_t v4 = v22;
        }
        while (!v6);
      }
      uint64_t v4 = v22;
    }
    while (v22 != v11);
  }
  return result;
}

uint64_t sub_100B26310(uint64_t result, int a2)
{
  if (a2 == 3)
  {
    uint64_t v3 = result;
    (*(void (**)(void))(**(void **)(result + 80) + 24))(*(void *)(result + 80));
    return ctu::RestModule::disconnect((ctu::RestModule *)(v3 + 64));
  }
  return result;
}

void sub_100B26378(uint64_t a1, uint64_t a2)
{
  if (capabilities::ct::supportsCapabilityC2KDevice((capabilities::ct *)a1))
  {
    uint64_t v4 = *(void *)(a1 + 144);
    if (!v4) {
      goto LABEL_12;
    }
    uint64_t v5 = a1 + 144;
    do
    {
      int v6 = *(_DWORD *)(v4 + 28);
      BOOL v7 = v6 < (int)a2;
      if (v6 >= (int)a2) {
        uint64_t v8 = (uint64_t *)v4;
      }
      else {
        uint64_t v8 = (uint64_t *)(v4 + 8);
      }
      if (!v7) {
        uint64_t v5 = v4;
      }
      uint64_t v4 = *v8;
    }
    while (*v8);
    if (v5 == a1 + 144 || *(_DWORD *)(v5 + 28) > (int)a2)
    {
LABEL_12:
      int v9 = *(NSObject **)(a1 + 40);
      if (!os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT)) {
        return;
      }
      LOWORD(v15[0]) = 0;
      int v10 = "#I CDMA Aux Info not available";
      BOOL v11 = v9;
      goto LABEL_14;
    }
    int v12 = *(unsigned __int8 *)(v5 + 32);
    uint64_t v13 = *(NSObject **)(a1 + 40);
    BOOL v14 = os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT);
    if (v12)
    {
      if (v14)
      {
        v15[0] = 67109120;
        v15[1] = 192;
        _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I sending query to read 0x%x", (uint8_t *)v15, 8u);
      }
      (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 80) + 40))(*(void *)(a1 + 80), a2, 192);
    }
    else if (v14)
    {
      LOWORD(v15[0]) = 0;
      int v10 = "#I CDMA Aux Info not yet ready";
      BOOL v11 = v13;
LABEL_14:
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, v10, (uint8_t *)v15, 2u);
    }
  }
}

void sub_100B26510(uint64_t a1)
{
  sub_100B26548(a1);

  operator delete();
}

void sub_100B26548(uint64_t a1)
{
  *(void *)a1 = off_101A3BE78;
  sub_1000346F8(a1 + 184, *(void **)(a1 + 192));
  sub_100087F94(a1 + 160, *(void **)(a1 + 168));
  sub_1000346F8(a1 + 136, *(void **)(a1 + 144));
  sub_100088048(a1 + 112, *(void **)(a1 + 120));
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 104);
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 88);
  if (v3) {
    sub_10004D2C8(v3);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 72);
  if (v4) {
    sub_10004D2C8(v4);
  }
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 56);
  if (v5) {
    sub_10004D2C8(v5);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 40));
  sub_100087E88((void *)(a1 + 8));

  SubscriberInfoControllerInterface::~SubscriberInfoControllerInterface((SubscriberInfoControllerInterface *)a1);
}

void sub_100B26608(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_100B266D4(void *a1)
{
  __cxa_begin_catch(a1);
  dispatch_barrier_async_f(v1[3], v1, (dispatch_function_t)sub_100B267AC);
  __cxa_rethrow();
}

void sub_100B266FC(_Unwind_Exception *a1)
{
}

void sub_100B26714(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100B2674C(uint64_t a1)
{
}

uint64_t sub_100B26768(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_100B267AC(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void sub_100B267DC()
{
}

__n128 sub_100B267F0(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A3BFB0;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100B26844(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A3BFB0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100B2687C(void *a1, xpc_object_t *a2)
{
  uint64_t v3 = (std::string *)a1[1];
  long long v21 = 0uLL;
  uint64_t v22 = 0;
  sub_100089CF0((uint64_t *)&v21, a2);
  p_size_t size = &v3->__r_.__value_.__l.__size_;
  size_t size = (void *)v3->__r_.__value_.__l.__size_;
  uint64_t v18 = (void **)v3->__r_.__value_.__r.__words[0];
  uint64_t v19 = size;
  std::string::size_type v20 = v3->__r_.__value_.__r.__words[2];
  if (v20)
  {
    size[2] = &v19;
    v3->__r_.__value_.__r.__words[0] = (std::string::size_type)p_size;
    *p_size_t size = 0;
    v3->__r_.__value_.__r.__words[2] = 0;
  }
  else
  {
    uint64_t v18 = (void **)&v19;
  }
  long long v16 = v21;
  uint64_t v17 = v22;
  uint64_t v22 = 0;
  long long v21 = 0uLL;
  sub_10008A04C(v3, (uint64_t *)&v16);
  BOOL v23 = (void **)&v16;
  sub_10008A88C(&v23);
  if (v20 == v3->__r_.__value_.__r.__words[2])
  {
    int v6 = v18;
    if (v18 == (void **)&v19) {
      goto LABEL_24;
    }
    BOOL v7 = (void *)v3->__r_.__value_.__r.__words[0];
    while (*((_DWORD *)v6 + 8) == *((_DWORD *)v7 + 8) && BasicSimInfo::operator==())
    {
      uint64_t v8 = (void **)v6[1];
      int v9 = (void ***)v6;
      if (v8)
      {
        do
        {
          int v6 = v8;
          uint64_t v8 = (void **)*v8;
        }
        while (v8);
      }
      else
      {
        do
        {
          int v6 = v9[2];
          BOOL v10 = *v6 == v9;
          int v9 = (void ***)v6;
        }
        while (!v10);
      }
      BOOL v11 = (void *)v7[1];
      if (v11)
      {
        do
        {
          int v12 = v11;
          BOOL v11 = (void *)*v11;
        }
        while (v11);
      }
      else
      {
        do
        {
          int v12 = (void *)v7[2];
          BOOL v10 = *v12 == (void)v7;
          BOOL v7 = v12;
        }
        while (!v10);
      }
      BOOL v7 = v12;
      if (v6 == (void **)&v19) {
        goto LABEL_24;
      }
    }
  }
  uint64_t v13 = (void (*)(void *, void ***))a1[3];
  uint64_t v14 = a1[4];
  int v15 = (void *)(a1[2] + (v14 >> 1));
  if (v14) {
    uint64_t v13 = *(void (**)(void *, void ***))(*v15 + v13);
  }
  v13(v15, &v18);
LABEL_24:
  sub_100088048((uint64_t)&v18, v19);
  uint64_t v18 = (void **)&v21;
  sub_10008A88C(&v18);
}

void sub_100B26A40(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void **a12, void *a13, uint64_t a14, char a15)
{
  a12 = (void **)&a15;
  sub_10008A88C(&a12);
  _Unwind_Resume(a1);
}

uint64_t sub_100B26A88(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100B26AC8()
{
}

void sub_100B26AD8()
{
}

__n128 sub_100B26AEC(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A3C030;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100B26B40(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A3C030;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100B26B78(void *a1, xpc_object_t *a2)
{
  uint64_t v3 = (void *)a1[1];
  uint64_t v4 = v3 + 1;
  uint64_t v5 = (void *)v3[1];
  int v9 = (void **)*v3;
  BOOL v10 = v5;
  if (v3[2])
  {
    _OWORD v5[2] = &v10;
    void *v3 = v4;
    *uint64_t v4 = 0;
    v3[2] = 0;
  }
  else
  {
    int v9 = &v10;
  }
  sub_10003447C((uint64_t)v3, a2);
  int v6 = (void (*)(void *, void ***))a1[3];
  uint64_t v7 = a1[4];
  uint64_t v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    int v6 = *(void (**)(void *, void ***))(*v8 + v6);
  }
  v6(v8, &v9);
  sub_1000346F8((uint64_t)&v9, v10);
}

void sub_100B26C38(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11)
{
}

uint64_t sub_100B26C50(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100B26C90()
{
}

void sub_100B26CA0()
{
}

__n128 sub_100B26CB4(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A3C0B0;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100B26D08(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A3C0B0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100B26D40(void *a1, xpc_object_t *a2)
{
  uint64_t v3 = (void *)a1[1];
  uint64_t v4 = v3 + 1;
  uint64_t v5 = (void *)v3[1];
  int v9 = (void **)*v3;
  BOOL v10 = v5;
  if (v3[2])
  {
    _OWORD v5[2] = &v10;
    void *v3 = v4;
    *uint64_t v4 = 0;
    v3[2] = 0;
  }
  else
  {
    int v9 = &v10;
  }
  sub_10008AAD8((uint64_t)v3, a2);
  int v6 = (void (*)(void *, void ***))a1[3];
  uint64_t v7 = a1[4];
  uint64_t v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    int v6 = *(void (**)(void *, void ***))(*v8 + v6);
  }
  v6(v8, &v9);
  sub_100087F94((uint64_t)&v9, v10);
}

void sub_100B26E00(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11)
{
}

uint64_t sub_100B26E18(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100B26E58()
{
}

void sub_100B26E68()
{
}

__n128 sub_100B26E7C(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A3C130;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100B26ED0(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A3C130;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100B26F08(void *a1, xpc_object_t *a2)
{
  uint64_t v3 = (void *)a1[1];
  uint64_t v4 = v3 + 1;
  uint64_t v5 = (void *)v3[1];
  int v9 = (void **)*v3;
  BOOL v10 = v5;
  if (v3[2])
  {
    _OWORD v5[2] = &v10;
    void *v3 = v4;
    *uint64_t v4 = 0;
    v3[2] = 0;
  }
  else
  {
    int v9 = &v10;
  }
  sub_1008FD8A8((uint64_t)v3, a2);
  int v6 = (void (*)(void *, void ***))a1[3];
  uint64_t v7 = a1[4];
  uint64_t v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    int v6 = *(void (**)(void *, void ***))(*v8 + v6);
  }
  v6(v8, &v9);
  sub_1000346F8((uint64_t)&v9, v10);
}

void sub_100B26FC8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11)
{
}

uint64_t sub_100B26FE0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100B27020()
{
}

uint64_t sub_100B2702C@<X0>(uint64_t a1@<X0>, int a2@<W1>, void *a3@<X8>)
{
  uint64_t v37 = 0;
  long long v35 = 0u;
  long long v36 = 0u;
  long long v33 = 0u;
  long long v34 = 0u;
  long long v31 = 0u;
  long long v32 = 0u;
  long long v29 = 0u;
  long long v30 = 0u;
  long long v28 = 0u;
  long long v26 = 0u;
  long long v27 = 0u;
  *(_OWORD *)uint64_t v25 = 0u;
  memset(v24, 0, sizeof(v24));
  sub_10004DE24((uint64_t)v24);
  long long __p = 0;
  uint64_t v22 = 0;
  uint64_t v23 = 0;
  (*(void (**)(uint64_t, void **))(*(void *)a1 + 72))(a1, &__p);
  int v6 = *(uint64_t (**)(uint64_t))(*(void *)a1 + 64);
  if (a2)
  {
    uint64_t v7 = (const char *)v6(a1);
    size_t v8 = strlen(v7);
    int v9 = sub_10004B96C(v24, (uint64_t)v7, v8);
    BOOL v10 = sub_10004B96C(v9, (uint64_t)": [", 3);
    BOOL v11 = (const char *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 88))(a1);
    size_t v12 = strlen(v11);
    uint64_t v13 = sub_10004B96C(v10, (uint64_t)v11, v12);
    uint64_t v14 = sub_10004B96C(v13, (uint64_t)"] ", 2);
  }
  else
  {
    int v15 = (const char *)v6(a1);
    size_t v16 = strlen(v15);
    uint64_t v17 = sub_10004B96C(v24, (uint64_t)v15, v16);
    uint64_t v14 = sub_10004B96C(v17, (uint64_t)": ", 2);
  }
  if (v23 >= 0) {
    p_p = &__p;
  }
  else {
    p_p = __p;
  }
  if (v23 >= 0) {
    uint64_t v19 = HIBYTE(v23);
  }
  else {
    uint64_t v19 = v22;
  }
  sub_10004B96C(v14, (uint64_t)p_p, v19);
  sub_10004BC98((uint64_t)v24 + 8, a3);
  if (SHIBYTE(v23) < 0) {
    operator delete(__p);
  }
  if (SHIBYTE(v26) < 0) {
    operator delete(v25[1]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return std::ios::~ios();
}

void sub_100B272D4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  sub_1000C937C((uint64_t)&a16);
  _Unwind_Resume(a1);
}

uint64_t sub_100B272F8()
{
  return 0;
}

void sub_100B27300(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, NSObject **a5, uint64_t a6)
{
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v12, kCtLoggingSystemName, "5wi.ctr");
  a1[2] = 0;
  a1[3] = 0;
  int v9 = *a5;
  a1[4] = *a5;
  if (v9) {
    dispatch_retain(v9);
  }
  a1[5] = 0;
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v11, &v12);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 6), (const ctu::OsLogLogger *)v11);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v11);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v12);
  uint64_t v10 = *(void *)(a6 + 8);
  if (v10)
  {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v10 + 16), 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v10 + 16), 1uLL, memory_order_relaxed);
  }
  operator new();
}

void sub_100B27620(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, ctu::OsLogLogger *a10, char a11, int a12, __int16 a13, char a14, char a15, std::__shared_weak_count *a16)
{
  if (a16) {
    sub_10004D2C8(a16);
  }
  std::string::size_type v20 = (std::__shared_weak_count *)*((void *)v16 + 17);
  if (v20) {
    sub_10004D2C8(v20);
  }
  long long v21 = (std::__shared_weak_count *)*((void *)v16 + 15);
  if (v21) {
    sub_10004D2C8(v21);
  }
  uint64_t v22 = (std::__shared_weak_count *)*((void *)v16 + 13);
  if (v22) {
    sub_10004D2C8(v22);
  }
  uint64_t v23 = (std::__shared_weak_count *)*((void *)v16 + 11);
  if (v23) {
    sub_10004D2C8(v23);
  }
  uint64_t v24 = (std::__shared_weak_count *)*((void *)v16 + 9);
  if (v24) {
    sub_10004D2C8(v24);
  }
  uint64_t v25 = *((void *)v16 + 7);
  *((void *)v16 + 7) = 0;
  if (v25) {
    (*(void (**)(uint64_t))(*(void *)v25 + 8))(v25);
  }
  ctu::OsLogLogger::~OsLogLogger(a10);
  sub_100087E88(v18);
  sd::IMSConnectivityHelperEventDelegate::~IMSConnectivityHelperEventDelegate(v17);
  sd::IMSConnectivityHelperInterface::~IMSConnectivityHelperInterface(v16);
  _Unwind_Resume(a1);
}

void sub_100B2774C(void *a1)
{
  *a1 = off_101A3C1D0;
  uint64_t v2 = (sd::IMSConnectivityHelperEventDelegate *)(a1 + 1);
  a1[1] = off_101A3C308;
  uint64_t v3 = a1[23];
  a1[23] = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  uint64_t v4 = a1[22];
  a1[22] = 0;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
  }
  uint64_t v5 = (std::__shared_weak_count *)a1[17];
  if (v5) {
    sub_10004D2C8(v5);
  }
  int v6 = (std::__shared_weak_count *)a1[15];
  if (v6) {
    sub_10004D2C8(v6);
  }
  uint64_t v7 = (std::__shared_weak_count *)a1[13];
  if (v7) {
    sub_10004D2C8(v7);
  }
  size_t v8 = (std::__shared_weak_count *)a1[11];
  if (v8) {
    sub_10004D2C8(v8);
  }
  int v9 = (std::__shared_weak_count *)a1[9];
  if (v9) {
    sub_10004D2C8(v9);
  }
  uint64_t v10 = a1[7];
  a1[7] = 0;
  if (v10) {
    (*(void (**)(uint64_t))(*(void *)v10 + 8))(v10);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 6));
  sub_100087E88(a1 + 2);
  sd::IMSConnectivityHelperEventDelegate::~IMSConnectivityHelperEventDelegate(v2);

  sd::IMSConnectivityHelperInterface::~IMSConnectivityHelperInterface((sd::IMSConnectivityHelperInterface *)a1);
}

void sub_100B278B0(uint64_t a1)
{
}

void sub_100B278B8(void *a1)
{
  sub_100B2774C(a1);

  operator delete();
}

void sub_100B278F0(uint64_t a1)
{
  sub_100B2774C((void *)(a1 - 8));

  operator delete();
}

void sub_100B2792C(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  operator new();
}

void sub_100B279CC()
{
}

void sub_100B279F0(uint64_t a1, uint64_t *a2)
{
  (*(void (**)(uint8_t *__return_ptr))(**(void **)(a1 + 96) + 176))(buf);
  uint64_t v4 = (NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 56) + 16))(*(void *)(a1 + 56), *(unsigned int *)(*(void *)buf + 52));
  if (v28) {
    sub_10004D2C8(v28);
  }
  uint64_t v5 = *v4;
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I start using IMSConnectivityHelperCT", buf, 2u);
  }
  uint64_t v7 = *a2;
  uint64_t v6 = a2[1];
  if (v6) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v6 + 8), 1uLL, memory_order_relaxed);
  }
  size_t v8 = *(std::__shared_weak_count **)(a1 + 136);
  *(void *)(a1 + 128) = v7;
  *(void *)(a1 + 136) = v6;
  if (v8)
  {
    sub_10004D2C8(v8);
    uint64_t v7 = *(void *)(a1 + 128);
  }
  (*(void (**)(uint8_t *__return_ptr))(**(void **)(a1 + 96) + 176))(buf);
  int v9 = *(std::__shared_weak_count **)(a1 + 24);
  if (v9)
  {
    uint64_t v10 = *(void *)buf;
    uint64_t v11 = *(void *)(a1 + 16);
    OsLogContext v12 = std::__shared_weak_count::lock(v9);
    if (v12)
    {
      uint64_t v13 = v11 + 8;
      if (!v11) {
        uint64_t v13 = 0;
      }
      uint64_t v25 = v13;
      long long v26 = v12;
      (*(void (**)(uint64_t, uint64_t, uint64_t *))(*(void *)v7 + 40))(v7, v10 + 24, &v25);
      if (v26) {
        sub_10004D2C8(v26);
      }
      if (v28) {
        sub_10004D2C8(v28);
      }
      uint64_t v14 = 0;
      while (1)
      {
        uint64_t v15 = *(void *)(a1 + 128);
        (*(void (**)(uint8_t *__return_ptr))(**(void **)(a1 + 96) + 176))(buf);
        uint64_t v16 = *(unsigned int *)(*(void *)buf + 52);
        uint64_t v17 = sub_100004808(*(void *)(a1 + 96));
        int v18 = dword_101542A78[v14];
        *(unsigned char *)(a1 + v18 + 148) = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, void))(*(void *)v15
                                                                                                  + 456))(v15, v16, v17, v18);
        if (v28) {
          sub_10004D2C8(v28);
        }
        if (++v14 == 2)
        {
          sub_100B27E18(a1);
          sub_100B27EAC(a1);
          for (uint64_t i = 0; i != 2; ++i)
            *(_DWORD *)(a1 + 164 + 4 * dword_101542A78[i]) = 0;
          int v20 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a1 + 152))(a1, 1);
          uint64_t v21 = **(void **)(a1 + 96);
          if (v20) {
            (*(void (**)(void))(v21 + 16))();
          }
          else {
            (*(void (**)(void))(v21 + 24))();
          }
          uint64_t v22 = *(std::__shared_weak_count **)(a1 + 24);
          if (v22)
          {
            uint64_t v23 = std::__shared_weak_count::lock(v22);
            if (v23)
            {
              atomic_fetch_add_explicit(&v23->__shared_weak_owners_, 1uLL, memory_order_relaxed);
              sub_10004D2C8(v23);
              uint64_t v24 = *(std::__shared_weak_count **)(a1 + 24);
              if (v24)
              {
                if (std::__shared_weak_count::lock(v24)) {
                  operator new();
                }
              }
              sub_100088B9C();
            }
          }
          sub_100088B9C();
        }
      }
    }
  }
  sub_100088B9C();
}

void sub_100B27DE0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  if (a12) {
    sub_10004D2C8(a12);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100B27E18(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 176);
  if (result)
  {
    (*(void (**)(uint64_t))(*(void *)result + 16))(result);
    uint64_t result = *(void *)(a1 + 176);
    *(void *)(a1 + 176) = 0;
    if (result)
    {
      uint64_t v3 = *(uint64_t (**)(void))(*(void *)result + 8);
      return v3();
    }
  }
  return result;
}

uint64_t sub_100B27EAC(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 184);
  if (result)
  {
    (*(void (**)(uint64_t))(*(void *)result + 16))(result);
    uint64_t result = *(void *)(a1 + 184);
    *(void *)(a1 + 184) = 0;
    if (result)
    {
      uint64_t v3 = *(uint64_t (**)(void))(*(void *)result + 8);
      return v3();
    }
  }
  return result;
}

void sub_100B27F40(uint64_t a1, uint64_t *a2)
{
  (*(void (**)(uint64_t *__return_ptr))(**(void **)(a1 + 96) + 176))(&v12);
  uint64_t v4 = (NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 56) + 16))(*(void *)(a1 + 56), *(unsigned int *)(v12 + 52));
  if (v13) {
    sub_10004D2C8(v13);
  }
  uint64_t v5 = *v4;
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v12) = 0;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I stop using IMSConnectivityHelperCT", (uint8_t *)&v12, 2u);
  }
  uint64_t v6 = *a2;
  (*(void (**)(uint64_t *__return_ptr))(**(void **)(a1 + 96) + 176))(&v12);
  uint64_t v7 = v12;
  uint64_t v8 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v6 + 48))(v6, v7 + 24, v8);
  if (v13) {
    sub_10004D2C8(v13);
  }
  (*(void (**)(uint64_t))(*(void *)a1 + 56))(a1);
  (*(void (**)(uint64_t, uint64_t))(*(void *)a1 + 40))(a1, 1);
  int v9 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a1 + 152))(a1, 1);
  uint64_t v10 = **(void **)(a1 + 96);
  if (v9) {
    (*(void (**)(void))(v10 + 16))();
  }
  else {
    (*(void (**)(void))(v10 + 24))();
  }
  uint64_t v11 = *(std::__shared_weak_count **)(a1 + 136);
  *(void *)(a1 + 128) = 0;
  *(void *)(a1 + 136) = 0;
  if (v11) {
    sub_10004D2C8(v11);
  }
}

void sub_100B2819C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_100B281B8(uint64_t a1, char a2)
{
  (*(void (**)(uint64_t *__return_ptr))(**(void **)(a1 + 96) + 176))(&v11);
  uint64_t v4 = (os_log_t *)(*(uint64_t (**)(void, void))(**(void **)(a1 + 56) + 16))(*(void *)(a1 + 56), *(unsigned int *)(v11 + 52));
  if (v12) {
    sub_10004D2C8(v12);
  }
  if ((a2 & 1) == 0
    && (uint64_t v5 = *(void *)(a1 + 128)) != 0
    && (uint64_t v6 = sub_10000F848(a1),
        uint64_t v7 = sub_100004808(*(void *)(a1 + 96)),
        ((*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v5 + 416))(v5, v6, v7) & 1) != 0))
  {
    uint64_t v8 = *v4;
    if (os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v11) = 0;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Not resetting transport because IMS connection is still active", (uint8_t *)&v11, 2u);
    }
  }
  else
  {
    uint64_t v9 = 0;
    *(_DWORD *)(a1 + 152) = 0;
    do
      *(_DWORD *)(a1 + 164 + 4 * dword_101542A78[v9++]) = 0;
    while (v9 != 2);
    uint64_t v10 = 0;
    *(_DWORD *)(a1 + 156) = -1;
    do
      *(unsigned char *)(a1 + dword_101542A78[v10++] + 148) = 0;
    while (v10 != 2);
    sub_100B27E18(a1);
    sub_100B27EAC(a1);
  }
}

void sub_100B2835C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100B28374(void **a1)
{
  (*(void (**)(uint64_t *__return_ptr))(*a1[12] + 176))(&v5);
  uint64_t v2 = (NSObject **)(*(uint64_t (**)(void *, void))(*a1[7] + 16))(a1[7], *(unsigned int *)(v5 + 52));
  if (v6) {
    sub_10004D2C8(v6);
  }
  uint64_t v3 = *v2;
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v5) = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Reset current transport", (uint8_t *)&v5, 2u);
  }
  sub_100B2847C(a1, 0, 2);
  sub_100B27E18((uint64_t)a1);
  return sub_100B27EAC((uint64_t)a1);
}

void sub_100B28464(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100B2847C(void **a1, char a2, int a3)
{
  char v8 = a2;
  int v7 = a3;
  uint64_t v4 = operator new(0x20uLL);
  *uint64_t v4 = off_101A3C700;
  v4[1] = &v7;
  void v4[2] = a1;
  v4[3] = &v8;
  void v9[3] = v4;
  uint64_t v5 = sub_100B292E8(a1, (uint64_t)v9);
  sub_10003B34C(v9);
  return v5;
}

void sub_100B28528(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_10003B34C((uint64_t *)va);
  _Unwind_Resume(a1);
}

void sub_100B2853C(uint64_t a1)
{
  if (validContextType()) {
    *(_DWORD *)(a1 + 156) = *(_DWORD *)(a1 + 160);
  }
  uint64_t valid = validContextType();
  if ((valid & 1) == 0)
  {
    if (capabilities::ct::supportsVoiceCall((capabilities::ct *)valid))
    {
      (*(void (**)(void *__return_ptr))(**(void **)(a1 + 96) + 176))(v4);
      uint64_t v3 = (std::__shared_weak_count *)v4[1];
      *(_DWORD *)(a1 + 156) = *(unsigned __int8 *)(v4[0] + 49) == 1;
      if (v3) {
        sub_10004D2C8(v3);
      }
    }
    else
    {
      *(_DWORD *)(a1 + 156) = 1;
    }
  }
  *(_DWORD *)(a1 + 4 * *(int *)(a1 + 156) + 164) = 0;
  sub_100B285FC(a1, 1);
}

void sub_100B285FC(uint64_t a1, int a2)
{
  (*(void (**)(uint8_t *__return_ptr))(**(void **)(a1 + 96) + 176))(buf);
  uint64_t v4 = (os_log_t *)(*(uint64_t (**)(void, void))(**(void **)(a1 + 56) + 16))(*(void *)(a1 + 56), *(unsigned int *)(*(void *)buf + 52));
  if (*(void *)v23) {
    sub_10004D2C8(*(std::__shared_weak_count **)v23);
  }
  if (!*(void *)(a1 + 184)) {
    goto LABEL_8;
  }
  uint64_t v5 = *v4;
  BOOL v6 = os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT);
  if (a2)
  {
    if (v6)
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I PdnBringUp: There is already Pdn bring up request on the queue. cancel it and activate right away.", buf, 2u);
    }
    sub_100B27EAC(a1);
LABEL_8:
    if (validContextType()) {
      uint64_t v7 = *(unsigned int *)(a1 + 4 * *(int *)(a1 + 156) + 164);
    }
    else {
      uint64_t v7 = 0;
    }
    unsigned int v8 = (*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 112) + 440))(*(void *)(a1 + 112), v7);
    uint64_t v9 = *v4;
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v10 = asString();
      *(_DWORD *)std::string buf = 67109634;
      *(_DWORD *)&uint8_t buf[4] = v8;
      *(_WORD *)uint64_t v23 = 2080;
      *(void *)&v23[2] = v10;
      __int16 v24 = 1024;
      int v25 = v7;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I PdnBringUp: Attempting pdn bring up after %u seconds. Attempt [%s] # %u", buf, 0x18u);
    }
    Registry::getTimerService((uint64_t *)buf, *(Registry **)(a1 + 64));
    uint64_t v11 = *(void *)buf;
    sub_100058DB0(__p, "PDP Retry timer");
    uint64_t v12 = *(NSObject **)(a1 + 32);
    dispatch_object_t object = v12;
    if (v12) {
      dispatch_retain(v12);
    }
    aBlock[0] = _NSConcreteStackBlock;
    aBlock[1] = 0x40000000;
    aBlock[2] = sub_100B29988;
    aBlock[3] = &unk_101A3C398;
    aBlock[4] = a1;
    uint64_t v17 = _Block_copy(aBlock);
    sub_100118A44(v11, (uint64_t)__p, 1, 1000000 * v8, &object, &v17);
    uint64_t v13 = v21;
    uint64_t v21 = 0;
    uint64_t v14 = *(void *)(a1 + 184);
    *(void *)(a1 + 184) = v13;
    if (v14)
    {
      (*(void (**)(uint64_t))(*(void *)v14 + 8))(v14);
      uint64_t v15 = v21;
      uint64_t v21 = 0;
      if (v15) {
        (*(void (**)(uint64_t))(*(void *)v15 + 8))(v15);
      }
    }
    if (v17) {
      _Block_release(v17);
    }
    if (object) {
      dispatch_release(object);
    }
    if (v20 < 0) {
      operator delete(__p[0]);
    }
    if (*(void *)v23) {
      sub_10004D2C8(*(std::__shared_weak_count **)v23);
    }
    if (v7 >= 3 && *(_DWORD *)(a1 + 156) != 1) {
      (*(void (**)(void, void))(**(void **)(a1 + 96) + 160))(*(void *)(a1 + 96), 0);
    }
    return;
  }
  if (v6)
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I PdnBringUp: There is already Pdn bring up request on the queue. Do nothing", buf, 2u);
  }
}

void sub_100B28994(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *aBlock, dispatch_object_t object, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_100B28A00(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(a2, *(Registry **)(a1 + 64));
  uint64_t v4 = ServiceMap;
  if (v5 < 0)
  {
    BOOL v6 = (unsigned __int8 *)(v5 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v7 = 5381;
    do
    {
      uint64_t v5 = v7;
      unsigned int v8 = *v6++;
      uint64_t v7 = (33 * v7) ^ v8;
    }
    while (v8);
  }
  std::mutex::lock(ServiceMap);
  long long __p = (void *)v5;
  uint64_t v9 = sub_10004D37C(&v4[1].__m_.__sig, (unint64_t *)&__p);
  if (!v9)
  {
    uint64_t v11 = 0;
LABEL_9:
    std::mutex::unlock(v4);
    uint64_t v10 = 0;
    char v12 = 1;
    if (!v11) {
      goto LABEL_15;
    }
    goto LABEL_10;
  }
  uint64_t v11 = v9[3];
  uint64_t v10 = (std::__shared_weak_count *)v9[4];
  if (!v10) {
    goto LABEL_9;
  }
  atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v4);
  atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v10);
  char v12 = 0;
  if (!v11) {
    goto LABEL_15;
  }
LABEL_10:
  (*(void (**)(void **__return_ptr))(**(void **)(a1 + 96) + 176))(&__p);
  uint64_t v13 = (NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 56) + 16))(*(void *)(a1 + 56), *((unsigned int *)__p + 13));
  if (v18) {
    sub_10004D2C8(v18);
  }
  uint64_t v14 = *v13;
  if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(__p) = 0;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I PdnBringDown: Attempting to deactivate IMS connection", (uint8_t *)&__p, 2u);
  }
  uint64_t v15 = sub_10000F848(a1);
  uint64_t v16 = sub_100B294A4(*(void *)(a1 + 96));
  sub_100058DB0(&__p, "Deactivating an Apn");
  (*(void (**)(uint64_t, uint64_t, uint64_t, void, void **, void, void))(*(void *)v11 + 80))(v11, v15, v16, 0, &__p, 0, 0);
  if ((v19 & 0x80000000) == 0)
  {
LABEL_15:
    if (v12) {
      return;
    }
    goto LABEL_16;
  }
  operator delete(__p);
  if (v12) {
    return;
  }
LABEL_16:
  sub_10004D2C8(v10);
}

void sub_100B28C0C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if ((v15 & 1) == 0) {
    sub_10004D2C8(v14);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100B28C58(uint64_t a1)
{
  (*(void (**)(uint64_t *__return_ptr))(**(void **)(a1 + 96) + 176))(&v7);
  uint64_t v2 = (NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 56) + 16))(*(void *)(a1 + 56), *(unsigned int *)(v7 + 52));
  if (v8) {
    sub_10004D2C8(v8);
  }
  if (validContextType()) {
    int v3 = *(_DWORD *)(a1 + 4 * *(int *)(a1 + 156) + 164);
  }
  else {
    int v3 = 0;
  }
  uint64_t v4 = *v2;
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(v7) = 67109120;
    HIDWORD(v7) = v3;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Resetting helper. Number of tries was: %du", (uint8_t *)&v7, 8u);
  }
  uint64_t result = sub_100B27EAC(a1);
  for (uint64_t i = 0; i != 2; ++i)
    *(_DWORD *)(a1 + 164 + 4 * dword_101542A78[i]) = 0;
  *(_DWORD *)(a1 + 156) = -1;
  return result;
}

void sub_100B28DC0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100B28DE4(void **a1)
{
  v3[0] = off_101A3C780;
  v3[1] = a1;
  v3[3] = v3;
  uint64_t v1 = sub_100B292E8(a1, (uint64_t)v3);
  sub_10003B34C(v3);
  return v1;
}

void sub_100B28E70(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_10003B34C((uint64_t *)va);
  _Unwind_Resume(a1);
}

void sub_100B28E84(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4 = (uint64_t *)__stack_chk_guard;
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  ServiceMap = (std::mutex *)Registry::getServiceMap(v4, *(Registry **)(a1 + 64));
  BOOL v6 = ServiceMap;
  if (v7 < 0)
  {
    unsigned int v8 = (unsigned __int8 *)(v7 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v9 = 5381;
    do
    {
      uint64_t v7 = v9;
      unsigned int v10 = *v8++;
      uint64_t v9 = (33 * v9) ^ v10;
    }
    while (v10);
  }
  std::mutex::lock(ServiceMap);
  *(void *)&long long v20 = v7;
  uint64_t v11 = sub_10004D37C(&v6[1].__m_.__sig, (unint64_t *)&v20);
  if (v11)
  {
    uint64_t v13 = v11[3];
    char v12 = (std::__shared_weak_count *)v11[4];
    if (v12)
    {
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v6);
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v12);
      char v14 = 0;
      if (!v13) {
        goto LABEL_19;
      }
      goto LABEL_10;
    }
  }
  else
  {
    uint64_t v13 = 0;
  }
  std::mutex::unlock(v6);
  char v12 = 0;
  char v14 = 1;
  if (!v13) {
    goto LABEL_19;
  }
LABEL_10:
  (*(void (**)(long long *__return_ptr))(**(void **)(a1 + 96) + 176))(&v20);
  char v15 = (os_log_t *)(*(uint64_t (**)(void, void))(**(void **)(a1 + 56) + 16))(*(void *)(a1 + 56), *(unsigned int *)(v20 + 52));
  if (*((void *)&v20 + 1)) {
    sub_10004D2C8(*((std::__shared_weak_count **)&v20 + 1));
  }
  uint64_t v16 = sub_10000F848(a1);
  uint64_t v17 = sub_100004808(*(void *)(a1 + 96));
  (*(void (**)(long long *__return_ptr, uint64_t, uint64_t, uint64_t))(*(void *)v13 + 144))(&v20, v13, v16, v17);
  if (*(char *)(a2 + 23) < 0) {
    operator delete(*(void **)a2);
  }
  *(_OWORD *)a2 = v20;
  *(void *)(a2 + 16) = v21;
  int v18 = *v15;
  if (os_log_type_enabled(*v15, OS_LOG_TYPE_DEFAULT))
  {
    if (*(char *)(a2 + 23) >= 0) {
      char v19 = (void *)a2;
    }
    else {
      char v19 = *(void **)a2;
    }
    LODWORD(v20) = 136315138;
    *(void *)((char *)&v20 + 4) = v19;
    _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#I IMS APN Name: %s", (uint8_t *)&v20, 0xCu);
  }
LABEL_19:
  if ((v14 & 1) == 0) {
    sub_10004D2C8(v12);
  }
}

void sub_100B290D4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  if ((v12 & 1) == 0) {
    sub_10004D2C8(v11);
  }
  if (*(char *)(v10 + 23) < 0) {
    operator delete(*(void **)v10);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_100B2912C(uint64_t a1, int a2)
{
  if (*(unsigned char *)(a1 + 148) || *(unsigned char *)(a1 + 149))
  {
    BOOL v3 = *(void *)(a1 + 176) == 0;
    if (!a2) {
      return v3;
    }
  }
  else
  {
    BOOL v3 = 0;
    if (!a2) {
      return v3;
    }
  }
  (*(void (**)(unsigned char *__return_ptr))(**(void **)(a1 + 96) + 176))(v11);
  uint64_t v4 = (NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 56) + 16))(*(void *)(a1 + 56), *(unsigned int *)(*(void *)v11 + 52));
  if (*(void *)&v11[8]) {
    sub_10004D2C8(*(std::__shared_weak_count **)&v11[8]);
  }
  uint64_t v5 = *v4;
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v6 = asStringBool(v3);
    uint64_t v7 = asStringBool(*(unsigned char *)(a1 + 148));
    uint64_t v8 = asStringBool(*(unsigned char *)(a1 + 149));
    uint64_t v9 = asStringBool(*(void *)(a1 + 176) == 0);
    *(_DWORD *)uint64_t v11 = 136315906;
    *(void *)&void v11[4] = v6;
    *(_WORD *)&v11[12] = 2080;
    *(void *)&v11[14] = v7;
    __int16 v12 = 2080;
    uint64_t v13 = v8;
    __int16 v14 = 2080;
    uint64_t v15 = v9;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Connectivity(%s): [ConnectionAvailable(BB: %s, iWLAN: %s), No BackoffTimer(%s)]", v11, 0x2Au);
  }
  return v3;
}

void sub_100B292C8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100B292E8(void **a1, uint64_t a2)
{
  int v4 = ((uint64_t (*)(void **, void))(*a1)[19])(a1, 0);
  uint64_t v5 = *(void *)(a2 + 24);
  if (!v5) {
    sub_10007B600();
  }
  (*(void (**)(uint64_t))(*(void *)v5 + 48))(v5);
  unsigned int v6 = ((uint64_t (*)(void **, uint64_t))(*a1)[19])(a1, 1);
  uint64_t v7 = v4 ^ v6;
  if (v7 == 1)
  {
    uint64_t v8 = *a1[12];
    if (v6) {
      (*(void (**)(void))(v8 + 16))();
    }
    else {
      (*(void (**)(void))(v8 + 24))();
    }
  }
  return v7;
}

void *sub_100B29404(void **a1, int a2)
{
  int v3 = a2;
  v4[0] = off_101A3C800;
  v4[1] = a1;
  void v4[2] = &v3;
  v4[3] = v4;
  sub_100B292E8(a1, (uint64_t)v4);
  return sub_10003B34C(v4);
}

void sub_100B29490(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_10003B34C((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100B294A4(uint64_t a1)
{
  (*(void (**)(uint64_t *__return_ptr))(*(void *)a1 + 176))(&v3);
  int v1 = *(unsigned __int8 *)(v3 + 49);
  if (v4) {
    sub_10004D2C8(v4);
  }
  if (v1 == 1) {
    return 0x4000000;
  }
  else {
    return 0x20000;
  }
}

void sub_100B29510(uint64_t a1, ConnectionAvailabilityContainer *a2)
{
  (*(void (**)(unsigned char *__return_ptr))(**(void **)(a1 + 96) + 176))(v15);
  int v4 = (os_log_t *)(*(uint64_t (**)(void, void))(**(void **)(a1 + 56) + 16))(*(void *)(a1 + 56), *(unsigned int *)(*(void *)v15 + 52));
  if (*(void *)&v15[8]) {
    sub_10004D2C8(*(std::__shared_weak_count **)&v15[8]);
  }
  sub_100004808(*(void *)(a1 + 96));
  uint64_t v5 = *v4;
  if (os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v6 = ConnectionAvailabilityContainer::size(a2);
    uint64_t v7 = asString();
    ConnectionAvailabilityContainer::error();
    uint64_t v8 = asString();
    char v9 = ConnectionAvailabilityContainer::available();
    uint64_t v10 = asStringBool(v9);
    ConnectionAvailabilityContainer::contextType();
    uint64_t v11 = asString();
    *(_DWORD *)uint64_t v15 = 134219010;
    *(void *)&void v15[4] = v6;
    *(_WORD *)&v15[12] = 2080;
    *(void *)&v15[14] = v7;
    __int16 v16 = 2080;
    uint64_t v17 = v8;
    __int16 v18 = 2080;
    uint64_t v19 = v10;
    __int16 v20 = 2080;
    uint64_t v21 = v11;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I ConnectionAvailability: size=%lu, ct=%s, error=%s, available=%s, contextType=%s", v15, 0x34u);
  }
  if (ConnectionAvailabilityContainer::error() == -9)
  {
    __int16 v12 = *v4;
    if (os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v15 = 0;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I Ignoring temporary availablity error", v15, 2u);
    }
  }
  else
  {
    int v13 = ConnectionAvailabilityContainer::available();
    int v14 = ConnectionAvailabilityContainer::contextType();
    sub_100B29760((void **)a1, v13, v14);
  }
}

void sub_100B29740(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_100B29760(void **a1, int a2, int a3)
{
  if (!validContextType() || *((unsigned __int8 *)a1 + a3 + 148) != a2)
  {
    int v6 = sub_100B2847C(a1, a2, a3);
    char v15 = 0;
    int v14 = 0;
    char v13 = 0;
    int v12 = 0;
    (*(void (**)(void *, char *, int *, char *, int *, uint64_t))(*a1[12] + 144))(a1[12], &v15, &v14, &v13, &v12, 1);
    if (a2 && v6 && v15 && a3 == 1 && !v13)
    {
      (*(void (**)(uint64_t *__return_ptr))(*a1[12] + 176))(&v10);
      uint64_t v7 = (NSObject **)(*(uint64_t (**)(void *, void))(*a1[7] + 16))(a1[7], *(unsigned int *)(v10 + 52));
      if (v11) {
        sub_10004D2C8(v11);
      }
      uint64_t v8 = *v7;
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(v10) = 0;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Connection availability transport type not matching to current IMS transport - Ignoring!", (uint8_t *)&v10, 2u);
      }
    }
    else
    {
      uint64_t v9 = *a1[12];
      if (a2)
      {
        (*(void (**)(void))(v9 + 32))();
        (*(void (**)(void *))(*a1[12] + 128))(a1[12]);
      }
      else
      {
        (*(void (**)(void))(v9 + 120))();
      }
    }
  }
}

void sub_100B29968(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_100B29980(uint64_t a1, ConnectionAvailabilityContainer *a2)
{
}

void sub_100B29988(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  sub_100B27EAC(v1);
  if ((*(unsigned int (**)(void))(**(void **)(v1 + 96) + 104))(*(void *)(v1 + 96)))
  {
    if (validContextType())
    {
      uint64_t v2 = v1 + 4 * *(int *)(v1 + 156);
      ++*(_DWORD *)(v2 + 164);
    }
    (*(void (**)(void))(**(void **)(v1 + 96) + 168))(*(void *)(v1 + 96));
    ServiceMap = (std::mutex *)Registry::getServiceMap(v3, *(Registry **)(v1 + 64));
    uint64_t v5 = ServiceMap;
    if (v6 < 0)
    {
      uint64_t v7 = (unsigned __int8 *)(v6 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v8 = 5381;
      do
      {
        uint64_t v6 = v8;
        unsigned int v9 = *v7++;
        uint64_t v8 = (33 * v8) ^ v9;
      }
      while (v9);
    }
    std::mutex::lock(ServiceMap);
    long long __p = (void *)v6;
    uint64_t v10 = sub_10004D37C(&v5[1].__m_.__sig, (unint64_t *)&__p);
    if (v10)
    {
      uint64_t v12 = v10[3];
      uint64_t v11 = (std::__shared_weak_count *)v10[4];
      if (v11)
      {
        atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v5);
        atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v11);
        char v13 = 0;
        if (!v12)
        {
LABEL_24:
          if ((v13 & 1) == 0) {
            sub_10004D2C8(v11);
          }
          return;
        }
LABEL_15:
        (*(void (**)(void **__return_ptr))(**(void **)(v1 + 96) + 176))(&__p);
        int v14 = (NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v1 + 56) + 16))(*(void *)(v1 + 56), *((unsigned int *)__p + 13));
        if (v21) {
          sub_10004D2C8(v21);
        }
        int v15 = *(_DWORD *)(v1 + 152);
        __int16 v16 = *v14;
        BOOL v17 = os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT);
        if (v15 == 2)
        {
          if (v17)
          {
            LOWORD(__p) = 0;
            _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I PdnBringUp: Pdp is already active", (uint8_t *)&__p, 2u);
          }
        }
        else
        {
          if (v17)
          {
            LOWORD(__p) = 0;
            _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I PdnBringUp: Attempting to activate IMS", (uint8_t *)&__p, 2u);
          }
          uint64_t v18 = sub_10000F848(v1);
          uint64_t v19 = sub_100B294A4(*(void *)(v1 + 96));
          sub_100058DB0(&__p, "Activating an Apn");
          (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, void **, void, void))(*(void *)v12 + 80))(v12, v18, v19, 1, &__p, 0, 0);
          if (v22 < 0) {
            operator delete(__p);
          }
        }
        goto LABEL_24;
      }
    }
    else
    {
      uint64_t v12 = 0;
    }
    std::mutex::unlock(v5);
    uint64_t v11 = 0;
    char v13 = 1;
    if (!v12) {
      goto LABEL_24;
    }
    goto LABEL_15;
  }
  if (validContextType()) {
    *(_DWORD *)(v1 + 4 * *(int *)(v1 + 156) + 164) = 0;
  }
}

void sub_100B29C60(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if ((v15 & 1) == 0) {
    sub_10004D2C8(v14);
  }
  _Unwind_Resume(exception_object);
}

void sub_100B29CAC(uint64_t a1, uint64_t a2)
{
  if ((*(_WORD *)(a2 + 10) & 0x402) != 0 && (*(_DWORD *)(a2 + 4) & 0x80000000) == 0)
  {
    (*(void (**)(uint64_t *__return_ptr))(**(void **)(a1 + 96) + 176))(&v12);
    int v4 = (os_log_t *)(*(uint64_t (**)(void, void))(**(void **)(a1 + 56) + 16))(*(void *)(a1 + 56), *(unsigned int *)(v12 + 52));
    if (*(void *)v13) {
      sub_10004D2C8(*(std::__shared_weak_count **)v13);
    }
    uint64_t v5 = *v4;
    if (os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT))
    {
      int v6 = *(_DWORD *)(a2 + 4);
      uint64_t v7 = *(void *)(a2 + 16);
      uint64_t v8 = asString();
      LODWORD(v12) = 67109634;
      HIDWORD(v12) = v6;
      *(_WORD *)char v13 = 2048;
      *(void *)&v13[2] = v7;
      __int16 v14 = 2080;
      uint64_t v15 = v8;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I IMS DataContext blocked: pdp=%d, serviceMask=0x%02llx, contextType=%s", (uint8_t *)&v12, 0x1Cu);
    }
    sub_100B27EAC(a1);
    if (validContextType())
    {
      uint64_t v9 = *(int *)(a2 + 24);
      *(_DWORD *)(a1 + 4 * v9 + 164) = 0;
    }
    else
    {
      LODWORD(v9) = *(_DWORD *)(a2 + 24);
    }
    uint64_t v10 = *v4;
    BOOL v11 = os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT);
    if (v9)
    {
      if (v11)
      {
        LOWORD(v12) = 0;
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I IMS DataContext blocked: Not reporting IMS status to Baseband - wrong context type", (uint8_t *)&v12, 2u);
      }
    }
    else
    {
      if (v11)
      {
        LOWORD(v12) = 0;
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I IMS DataContext blocked: Trying to report IMS status to Baseband", (uint8_t *)&v12, 2u);
      }
      (*(void (**)(void, uint64_t))(**(void **)(a1 + 96) + 160))(*(void *)(a1 + 96), 1);
    }
  }
}

void sub_100B29ED0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_100B29EF0(uint64_t a1, uint64_t a2)
{
}

void sub_100B29EF8(uint64_t a1, uint64_t a2)
{
  int v4 = sub_100004808(*(void *)(a1 + 96));
  uint64_t v7 = *(void *)(a2 + 8);
  int v6 = (_DWORD *)(a2 + 8);
  uint64_t v5 = v7;
  if (!v7) {
    return;
  }
  uint64_t v8 = v6;
  do
  {
    int v9 = *(_DWORD *)(v5 + 32);
    BOOL v10 = v9 < v4;
    if (v9 >= v4) {
      BOOL v11 = (uint64_t *)v5;
    }
    else {
      BOOL v11 = (uint64_t *)(v5 + 8);
    }
    if (!v10) {
      uint64_t v8 = (_DWORD *)v5;
    }
    uint64_t v5 = *v11;
  }
  while (*v11);
  if (v8 == v6 || v4 < v8[8]) {
    return;
  }
  (*(void (**)(unsigned char *__return_ptr))(**(void **)(a1 + 96) + 176))(v25);
  uint64_t v12 = (os_log_t *)(*(uint64_t (**)(void, void))(**(void **)(a1 + 56) + 16))(*(void *)(a1 + 56), *(unsigned int *)(*(void *)v25 + 52));
  if (*(void *)&v25[8]) {
    sub_10004D2C8(*(std::__shared_weak_count **)&v25[8]);
  }
  char v13 = *v12;
  if (os_log_type_enabled(*v12, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v14 = asString();
    uint64_t v15 = asString();
    *(_DWORD *)int v25 = 136315394;
    *(void *)&void v25[4] = v14;
    *(_WORD *)&v25[12] = 2080;
    *(void *)&v25[14] = v15;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I ConnectionState: %s, own PDP state: %s", v25, 0x16u);
  }
  int v16 = v8[11];
  if (v16 != 2) {
    goto LABEL_24;
  }
  if (*(_DWORD *)(a1 + 152) == 2)
  {
    BOOL v17 = *v12;
    if (os_log_type_enabled(*v12, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)int v25 = 0;
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I ConnectionState: Going from kActive to kActive", v25, 2u);
    }
    for (uint64_t i = 0; i != 8; i += 4)
    {
      if ((v8[i + 14] & 0x4020000) != 0) {
        (*(void (**)(void, BOOL, void))(**(void **)(a1 + 96) + 64))(*(void *)(a1 + 96), v8[i + 12] == 18, v8[21]);
      }
    }
    int v16 = v8[11];
LABEL_24:
    int v19 = *(_DWORD *)(a1 + 152);
    if (v16 == v19) {
      return;
    }
    *(_DWORD *)(a1 + 152) = v16;
    if (v16 != 2)
    {
      if (v19 == 2)
      {
        __int16 v20 = *v12;
        if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)int v25 = 0;
          _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#I ConnectionState: Pdp became inactive", v25, 2u);
        }
        (*(void (**)(void))(**(void **)(a1 + 96) + 56))(*(void *)(a1 + 96));
      }
      return;
    }
    goto LABEL_31;
  }
  *(_DWORD *)(a1 + 152) = 2;
LABEL_31:
  uint64_t v21 = *v12;
  if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)int v25 = 0;
    _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "#I ConnectionState: Pdp became active", v25, 2u);
  }
  uint64_t v22 = 0;
  while ((v8[v22 + 14] & 0x4020000) == 0)
  {
    v22 += 4;
    if (v22 == 8)
    {
      BOOL v23 = 0;
      goto LABEL_38;
    }
  }
  BOOL v23 = v8[v22 + 12] == 18;
LABEL_38:
  for (uint64_t j = 0; j != 2; ++j)
    *(_DWORD *)(a1 + 164 + 4 * dword_101542A78[j]) = 0;
  (*(void (**)(void, BOOL, void))(**(void **)(a1 + 96) + 48))(*(void *)(a1 + 96), v23, v8[21]);
}

void sub_100B2A284(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_100B2A2A4(uint64_t a1, uint64_t a2)
{
}

uint64_t sub_100B2A2AC(uint64_t a1, int *a2)
{
  (*(void (**)(unsigned char *__return_ptr))(**(void **)(a1 + 96) + 176))(v23);
  int v4 = (os_log_t *)(*(uint64_t (**)(void, void))(**(void **)(a1 + 56) + 16))(*(void *)(a1 + 56), *(unsigned int *)(*(void *)v23 + 52));
  if (*(void *)&v23[8]) {
    sub_10004D2C8(*(std::__shared_weak_count **)&v23[8]);
  }
  int v5 = *a2;
  int v6 = a2[1];
  int v7 = a2[2];
  if (validContextType())
  {
    int v5 = *(_DWORD *)(a1 + 160);
    os_log_t v8 = *v4;
    if (os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT))
    {
LABEL_16:
      uint64_t v17 = asString();
      uint64_t v18 = asString();
      uint64_t v19 = sd::asString();
      uint64_t v20 = sd::asString();
      *(_DWORD *)BOOL v23 = 136315906;
      *(void *)&v23[4] = v17;
      *(_WORD *)&v23[12] = 2080;
      *(void *)&v23[14] = v18;
      __int16 v24 = 2080;
      uint64_t v25 = v19;
      __int16 v26 = 2080;
      uint64_t v27 = v20;
      char v13 = "#I IMS Pref: ct=%s --> %s, bb_mask=[%s], tech_mask=[%s]";
      uint64_t v14 = v8;
      uint32_t v15 = 42;
      goto LABEL_17;
    }
  }
  else if (validContextType())
  {
    os_log_t v9 = *v4;
    if (os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v10 = asString();
      uint64_t v11 = sd::asString();
      uint64_t v12 = sd::asString();
      *(_DWORD *)BOOL v23 = 136315650;
      *(void *)&v23[4] = v10;
      *(_WORD *)&v23[12] = 2080;
      *(void *)&v23[14] = v11;
      __int16 v24 = 2080;
      uint64_t v25 = v12;
      char v13 = "#I IMS Pref: ct=%s, bb_mask=[%s], tech_mask=[%s]";
      uint64_t v14 = v9;
      uint32_t v15 = 32;
LABEL_17:
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, v13, v23, v15);
    }
  }
  else
  {
    if (v7) {
      int v16 = 1;
    }
    else {
      int v16 = 2;
    }
    if (v6) {
      int v5 = 0;
    }
    else {
      int v5 = v16;
    }
    os_log_t v8 = *v4;
    if (os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_16;
    }
  }
  if (validContextType())
  {
    if (*(_DWORD *)(a1 + 156) != v5)
    {
      *(_DWORD *)(a1 + 156) = v5;
      if (*(void *)(a1 + 184))
      {
        uint64_t v21 = *v4;
        if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)BOOL v23 = 0;
          _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "#I ContextType changed, retrying PDN bringup", v23, 2u);
        }
        sub_100B285FC(a1, 1);
      }
    }
  }
  return (*(uint64_t (**)(void, int *))(**(void **)(a1 + 96) + 72))(*(void *)(a1 + 96), a2);
}

void sub_100B2A5E8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100B2A608(uint64_t a1, int *a2)
{
  return sub_100B2A2AC(a1 - 8, a2);
}

void sub_100B2A610(uint64_t a1, int a2, int a3)
{
  if (*(_DWORD *)(a1 + 144) == a2)
  {
    (*(void (**)(unsigned char *__return_ptr))(**(void **)(a1 + 96) + 176))(v12);
    int v5 = (os_log_t *)(*(uint64_t (**)(void, void))(**(void **)(a1 + 56) + 16))(*(void *)(a1 + 56), *(unsigned int *)(*(void *)v12 + 52));
    if (*(void *)&v12[8]) {
      sub_10004D2C8(*(std::__shared_weak_count **)&v12[8]);
    }
    *(_DWORD *)(a1 + 160) = a3;
    int v6 = *v5;
    if (os_log_type_enabled(*v5, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v7 = asString();
      *(_DWORD *)uint64_t v12 = 136315138;
      *(void *)&void v12[4] = v7;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Got iRatChange event with dataContextType %s", v12, 0xCu);
    }
    if (validContextType())
    {
      int v8 = *(_DWORD *)(a1 + 160);
      if (v8 != *(_DWORD *)(a1 + 156))
      {
        os_log_t v9 = *v5;
        if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v10 = asString();
          uint64_t v11 = asString();
          *(_DWORD *)uint64_t v12 = 136315394;
          *(void *)&void v12[4] = v10;
          *(_WORD *)&v12[12] = 2080;
          *(void *)&v12[14] = v11;
          _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I Current context type type changed %s --> %s", v12, 0x16u);
          int v8 = *(_DWORD *)(a1 + 160);
        }
        *(_DWORD *)(a1 + 156) = v8;
      }
    }
  }
}

void sub_100B2A7D0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_100B2A7F0(uint64_t a1, int a2, int a3)
{
}

uint64_t sub_100B2A7F8(uint64_t a1, unsigned __int16 *a2)
{
  (*(void (**)(uint64_t *__return_ptr))(**(void **)(a1 + 96) + 176))(&v8);
  int v4 = (NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 56) + 16))(*(void *)(a1 + 56), *(unsigned int *)(v8 + 52));
  if (v9) {
    sub_10004D2C8(v9);
  }
  int v5 = *v4;
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    int v6 = *a2;
    LODWORD(v8) = 67109120;
    HIDWORD(v8) = v6;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I IMS PCO: containerId=0x%04x", (uint8_t *)&v8, 8u);
  }
  return (*(uint64_t (**)(void, unsigned __int16 *))(**(void **)(a1 + 96) + 80))(*(void *)(a1 + 96), a2);
}

void sub_100B2A940(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100B2A960(uint64_t a1, unsigned __int16 *a2)
{
  return sub_100B2A7F8(a1 - 8, a2);
}

uint64_t sub_100B2A968(uint64_t a1, BOOL a2)
{
  (*(void (**)(long long *__return_ptr))(**(void **)(a1 + 96) + 176))(&v8);
  int v4 = (NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 56) + 16))(*(void *)(a1 + 56), *(unsigned int *)(v8 + 52));
  if (*((void *)&v8 + 1)) {
    sub_10004D2C8(*((std::__shared_weak_count **)&v8 + 1));
  }
  int v5 = *v4;
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v6 = asStringBool(a2);
    LODWORD(v8) = 136315138;
    *(void *)((char *)&v8 + 4) = v6;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I IMS HandoverStateChange: %s", (uint8_t *)&v8, 0xCu);
  }
  return (*(uint64_t (**)(void, BOOL))(**(void **)(a1 + 96) + 88))(*(void *)(a1 + 96), a2);
}

void sub_100B2AAB4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100B2AAD4(uint64_t a1, BOOL a2)
{
  return sub_100B2A968(a1 - 8, a2);
}

void sub_100B2AADC(uint64_t a1, unsigned int a2)
{
  (*(void (**)(unsigned char *__return_ptr))(**(void **)(a1 + 96) + 176))(v7);
  int v4 = (NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 56) + 16))(*(void *)(a1 + 56), *(unsigned int *)(*(void *)v7 + 52));
  if (*(void *)&v7[8]) {
    sub_10004D2C8(*(std::__shared_weak_count **)&v7[8]);
  }
  int v5 = *v4;
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v6 = *(unsigned int *)(a1 + 172);
    *(_DWORD *)uint64_t v7 = 134218240;
    *(void *)&void v7[4] = v6;
    *(_WORD *)&v7[12] = 2048;
    *(void *)&v7[14] = a2;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Changed T3402 timer value from %lu to %lu", v7, 0x16u);
  }
  *(_DWORD *)(a1 + 172) = a2;
}

void sub_100B2AC0C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_100B2AC2C(uint64_t a1, unsigned int a2)
{
}

void sub_100B2AC34(uint64_t a1, uint64_t a2)
{
  if ((*(_WORD *)(a2 + 10) & 0x402) == 0) {
    return;
  }
  (*(void (**)(unsigned char *__return_ptr))(**(void **)(a1 + 96) + 176))(v16);
  int v4 = (os_log_t *)(*(uint64_t (**)(void, void))(**(void **)(a1 + 56) + 16))(*(void *)(a1 + 56), *(unsigned int *)(*(void *)v16 + 52));
  if (*(void *)&v16[8]) {
    sub_10004D2C8(*(std::__shared_weak_count **)&v16[8]);
  }
  int v5 = *v4;
  if (os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v6 = CSIErrorString();
    *(_DWORD *)int v16 = 136315138;
    *(void *)&void v16[4] = v6;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I ConnectionActivateError: Activate error for 5wi PdCFIndex n = %s", v16, 0xCu);
  }
  int v7 = *(_DWORD *)(a2 + 4);
  if (!isT3402CSIError())
  {
    if (v7 == 96)
    {
      unsigned int v9 = (*(uint64_t (**)(void))(**(void **)(a1 + 112) + 320))(*(void *)(a1 + 112));
    }
    else
    {
      if (v7 != 89) {
        goto LABEL_12;
      }
      unsigned int v9 = (*(uint64_t (**)(void))(**(void **)(a1 + 112) + 312))(*(void *)(a1 + 112));
    }
    unsigned int v8 = v9;
    goto LABEL_15;
  }
  if (!(*(unsigned int (**)(void))(**(void **)(a1 + 112) + 328))(*(void *)(a1 + 112)))
  {
LABEL_12:
    unsigned int v8 = 0;
    goto LABEL_15;
  }
  unsigned int v8 = *(_DWORD *)(a1 + 172);
LABEL_15:
  (*(void (**)(unsigned char *__return_ptr))(**(void **)(a1 + 96) + 176))(v16);
  uint64_t v10 = (NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 56) + 16))(*(void *)(a1 + 56), *(unsigned int *)(*(void *)v16 + 52));
  if (*(void *)&v16[8]) {
    sub_10004D2C8(*(std::__shared_weak_count **)&v16[8]);
  }
  uint64_t v11 = *v10;
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v12 = CSIErrorString();
    *(_DWORD *)int v16 = 136315394;
    *(void *)&void v16[4] = v12;
    *(_WORD *)&v16[12] = 2048;
    *(void *)&v16[14] = v8;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I PdpActivateError: %s requires backoff timer = %lu", v16, 0x16u);
  }
  if (v8)
  {
    char v13 = *v4;
    if (os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)int v16 = 134217984;
      *(void *)&void v16[4] = v8;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I ConnectionActivateError: Unsetting the service Option mask with backoff timer = %lu", v16, 0xCu);
    }
    if (validContextType()) {
      *(_DWORD *)(a1 + 4 * *(int *)(a1 + 156) + 164) = 0;
    }
    sub_100B29404((void **)a1, v8);
  }
  if (*(_DWORD *)(a2 + 4) == 103)
  {
    uint64_t v14 = *v4;
    if (os_log_type_enabled(*v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)int v16 = 0;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I PDN is not transferrable - suppressing IMS status to Baseband", v16, 2u);
    }
    (*(void (**)(void, const char *))(**(void **)(a1 + 96) + 152))(*(void *)(a1 + 96), "NonTransferrablePdn");
  }
  if ((*(unsigned int (**)(void))(**(void **)(a1 + 96) + 104))(*(void *)(a1 + 96)))
  {
    uint32_t v15 = *v4;
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)int v16 = 0;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#N ConnectionActivateError: Potential PDN bring up failure. Retry?", v16, 2u);
    }
    sub_100B285FC(a1, 0);
  }
}

void sub_100B2B064(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_100B2B088(uint64_t a1, uint64_t a2)
{
}

uint64_t sub_100B2B090(uint64_t a1)
{
  if (!*(_DWORD *)(a1 + 172)) {
    return 0;
  }
  (*(void (**)(long long *__return_ptr))(**(void **)(a1 + 96) + 176))(&v6);
  uint64_t v2 = (NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 56) + 16))(*(void *)(a1 + 56), *(unsigned int *)(v6 + 52));
  if (*((void *)&v6 + 1)) {
    sub_10004D2C8(*((std::__shared_weak_count **)&v6 + 1));
  }
  uint64_t v3 = *v2;
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v4 = *(unsigned int *)(a1 + 172);
    LODWORD(v6) = 134217984;
    *(void *)((char *)&v6 + 4) = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I triggerT3402BackOff: Unsetting the service Option mask with backoff timer = %lu", (uint8_t *)&v6, 0xCu);
  }
  if (validContextType()) {
    *(_DWORD *)(a1 + 4 * *(int *)(a1 + 156) + 164) = 0;
  }
  sub_100B29404((void **)a1, *(_DWORD *)(a1 + 172));
  return *(unsigned int *)(a1 + 172);
}

void sub_100B2B1DC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100B2B1FC(uint64_t a1)
{
  (*(void (**)(uint8_t *__return_ptr))(**(void **)(a1 + 96) + 176))(buf);
  uint64_t v2 = (os_log_t *)(*(uint64_t (**)(void, void))(**(void **)(a1 + 56) + 16))(*(void *)(a1 + 56), *(unsigned int *)(*(void *)buf + 52));
  if (*(void *)&buf[8]) {
    sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
  }
  uint64_t v3 = *v2;
  if (os_log_type_enabled(*v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)std::string buf = 136315394;
    *(void *)&uint8_t buf[4] = "IMSConnectivityHelperCT";
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = "IMSConnectivityHelperCT";
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I 5wi.ct:: ----------------- %s %s ==>> -------------------", buf, 0x16u);
  }
  uint64_t v71 = 0;
  long long v69 = 0u;
  long long v70 = 0u;
  long long v67 = 0u;
  long long v68 = 0u;
  long long v65 = 0u;
  long long v66 = 0u;
  long long v63 = 0u;
  long long v64 = 0u;
  long long v61 = 0u;
  long long v62 = 0u;
  long long v60 = 0u;
  long long v58 = 0u;
  *(_OWORD *)uint64_t v59 = 0u;
  long long v57 = 0u;
  memset(buf, 0, sizeof(buf));
  sub_10004DE24((uint64_t)buf);
  uint64_t v4 = sub_10004B96C(buf, (uint64_t)"\t", 1);
  int v5 = sub_10004B96C(v4, (uint64_t)"AccountId", 9);
  (*(void (**)(unsigned char *__return_ptr))(**(void **)(a1 + 96) + 176))(__p);
  uint64_t v6 = *(void *)__p + 24;
  uint64_t v7 = *(unsigned __int8 *)(*(void *)__p + 47);
  int v8 = (char)v7;
  if ((v7 & 0x80u) != 0) {
    uint64_t v7 = *(void *)(*(void *)__p + 32);
  }
  if (v8 < 0) {
    uint64_t v6 = *(void *)(*(void *)__p + 24);
  }
  if (v7) {
    unsigned int v9 = (const char *)v6;
  }
  else {
    unsigned int v9 = "<invalid>";
  }
  size_t v10 = strlen(v9);
  uint64_t v11 = sub_10004B96C(v5, (uint64_t)v9, v10);
  uint64_t v12 = sub_10004B96C(v11, (uint64_t)", ", 2);
  char v13 = sub_10004B96C(v12, (uint64_t)"\t", 1);
  uint64_t v14 = sub_10004B96C(v13, (uint64_t)"ConnectionBB: ", 14);
  uint32_t v15 = (const char *)asStringBool(*(unsigned char *)(a1 + 148));
  size_t v16 = strlen(v15);
  uint64_t v17 = sub_10004B96C(v14, (uint64_t)v15, v16);
  uint64_t v18 = sub_10004B96C(v17, (uint64_t)", ", 2);
  uint64_t v19 = sub_10004B96C(v18, (uint64_t)"\t", 1);
  uint64_t v20 = sub_10004B96C(v19, (uint64_t)"ConnectioniWLAN: ", 17);
  uint64_t v21 = (const char *)asStringBool(*(unsigned char *)(a1 + 149));
  size_t v22 = strlen(v21);
  BOOL v23 = sub_10004B96C(v20, (uint64_t)v21, v22);
  __int16 v24 = sub_10004B96C(v23, (uint64_t)", ", 2);
  uint64_t v25 = sub_10004B96C(v24, (uint64_t)"\t", 1);
  sub_10004B96C(v25, (uint64_t)"fImsPdpState=", 13);
  __int16 v26 = (void *)std::ostream::operator<<();
  uint64_t v27 = sub_10004B96C(v26, (uint64_t)", ", 2);
  long long v28 = sub_10004B96C(v27, (uint64_t)"\t", 1);
  sub_10004B96C(v28, (uint64_t)"fImsPdnNumberOfTries[kDataContextBB]=", 37);
  long long v29 = (void *)std::ostream::operator<<();
  long long v30 = sub_10004B96C(v29, (uint64_t)", ", 2);
  long long v31 = sub_10004B96C(v30, (uint64_t)"\t", 1);
  sub_10004B96C(v31, (uint64_t)"fImsPdnNumberOfTries[kDataContextIWLAN]=", 40);
  long long v32 = (void *)std::ostream::operator<<();
  long long v33 = sub_10004B96C(v32, (uint64_t)", ", 2);
  long long v34 = sub_10004B96C(v33, (uint64_t)"\t", 1);
  sub_10004B96C(v34, (uint64_t)"fT3402TimerValue=", 17);
  long long v35 = (void *)std::ostream::operator<<();
  long long v36 = sub_10004B96C(v35, (uint64_t)", ", 2);
  uint64_t v37 = sub_10004B96C(v36, (uint64_t)"\t", 1);
  uint64_t v38 = sub_10004B96C(v37, (uint64_t)"fPdpBringUpBackOffTimer=", 24);
  uint64_t v39 = (const char *)asStringBool(*(void *)(a1 + 176) != 0);
  size_t v40 = strlen(v39);
  int64_t v41 = sub_10004B96C(v38, (uint64_t)v39, v40);
  uint64_t v42 = sub_10004B96C(v41, (uint64_t)", ", 2);
  uint64_t v43 = sub_10004B96C(v42, (uint64_t)"\t", 1);
  uint64_t v44 = sub_10004B96C(v43, (uint64_t)"fPdpRetryTimer=", 15);
  uint64_t v45 = (const char *)asStringBool(*(void *)(a1 + 184) != 0);
  size_t v46 = strlen(v45);
  uint64_t v47 = sub_10004B96C(v44, (uint64_t)v45, v46);
  unint64_t v48 = sub_10004B96C(v47, (uint64_t)", ", 2);
  std::ios_base::getloc((const std::ios_base *)((char *)v48 + *(void *)(*v48 - 24)));
  uint64_t v49 = std::locale::use_facet(v55, &std::ctype<char>::id);
  ((void (*)(const std::locale::facet *, uint64_t))v49->__vftable[2].~facet_0)(v49, 10);
  std::locale::~locale(v55);
  std::ostream::put();
  std::ostream::flush();
  if (*(void *)&__p[8]) {
    sub_10004D2C8(*(std::__shared_weak_count **)&__p[8]);
  }
  uint64_t v50 = *v2;
  if (os_log_type_enabled(*v2, OS_LOG_TYPE_DEFAULT))
  {
    sub_10004BC98((uint64_t)&buf[8], __p);
    if (v54 >= 0) {
      uint64_t v51 = (std::locale::__imp *)__p;
    }
    else {
      uint64_t v51 = *(std::locale::__imp **)__p;
    }
    LODWORD(v55[0].__locale_) = 136315138;
    *(std::locale::__imp **)((char *)&v55[0].__locale_ + 4) = v51;
    _os_log_impl((void *)&_mh_execute_header, v50, OS_LOG_TYPE_DEFAULT, "#I 5wi.ct:: %s", (uint8_t *)v55, 0xCu);
    if (v54 < 0) {
      operator delete(*(void **)__p);
    }
    uint64_t v50 = *v2;
  }
  if (os_log_type_enabled(v50, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long __p = 136315394;
    *(void *)&__p[4] = "IMSConnectivityHelperCT";
    *(_WORD *)&std::string __p[12] = 2080;
    *(void *)&__p[14] = "IMSConnectivityHelperCT";
    _os_log_impl((void *)&_mh_execute_header, v50, OS_LOG_TYPE_DEFAULT, "#I 5wi.ct:: ------------ <<== %s %s ------------------------", __p, 0x16u);
  }
  if (SHIBYTE(v60) < 0) {
    operator delete(v59[1]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return std::ios::~ios();
}

void sub_100B2B890(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, std::locale a15, uint64_t a16, char a17, uint64_t a18)
{
}

uint64_t sub_100B2B8EC()
{
  return 0;
}

uint64_t sub_100B2B920()
{
  return 0;
}

void *sub_100B2B940(void *a1)
{
  *a1 = off_101A3C4A0;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_100B2B98C(void *a1)
{
  *a1 = off_101A3C4A0;
  uint64_t v1 = (std::__shared_weak_count *)a1[2];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

void *sub_100B2B9F8(uint64_t a1)
{
  uint64_t result = operator new(0x18uLL);
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 16);
  *uint64_t result = off_101A3C4A0;
  result[1] = v4;
  result[2] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_100B2BA54(uint64_t result, void *a2)
{
  uint64_t v3 = *(void *)(result + 8);
  uint64_t v2 = *(void *)(result + 16);
  *a2 = off_101A3C4A0;
  a2[1] = v3;
  a2[2] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100B2BA8C(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_100B2BA9C(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[2];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete(__p);
}

const char *sub_100B2BADC(uint64_t a1, int *a2)
{
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (v3)
  {
    int v4 = *a2;
    int v5 = std::__shared_weak_count::lock(v3);
    if (v5)
    {
      uint64_t v6 = *(unsigned __int8 **)(a1 + 8);
      if (v6)
      {
        int v7 = *((_DWORD *)v6 + 1);
        if (v7 < 0)
        {
          size_t v10 = "5wi.ct.x.X";
          goto LABEL_17;
        }
        int v8 = *v6;
        if (v8 == 2)
        {
          size_t v10 = "5wi.ct.M";
          goto LABEL_17;
        }
        unsigned int v9 = off_101A3C600;
        if (v8 == 1) {
          goto LABEL_12;
        }
        if (!v8)
        {
          if (v4 == 2) {
            unsigned int v9 = off_101A3C580;
          }
          if (v4 == 1) {
            unsigned int v9 = off_101A3C500;
          }
LABEL_12:
          size_t v10 = v9[v7 & 0xF];
LABEL_17:
          sub_10004D2C8(v5);
          return v10;
        }
      }
      size_t v10 = "5wi.ct.?";
      goto LABEL_17;
    }
  }
  return "5wi.ct.?";
}

uint64_t sub_100B2BBA0(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_100B2BBE0()
{
}

void sub_100B2BBEC(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_100B2BCB8(void *a1)
{
  __cxa_begin_catch(a1);
  dispatch_barrier_async_f(v1[4], v1, (dispatch_function_t)sub_100B2BD90);
  __cxa_rethrow();
}

void sub_100B2BCE0(_Unwind_Exception *a1)
{
}

void sub_100B2BCF8(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100B2BD30(uint64_t a1)
{
}

uint64_t sub_100B2BD4C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_100B2BD90(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t *sub_100B2BDBC(uint64_t **a1)
{
  uint64_t v1 = *a1;
  __int16 v24 = a1;
  uint64_t v25 = v1;
  uint64_t v2 = (std::__shared_weak_count *)v1[2];
  if (v2)
  {
    uint64_t v3 = *v1;
    int v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      int v5 = v4;
      uint64_t v6 = (uint64_t *)v1[1];
      if (!v6)
      {
LABEL_23:
        sub_10004D2C8(v5);
        goto LABEL_24;
      }
      ServiceMap = (std::mutex *)Registry::getServiceMap(v6, *(Registry **)(v3 + 64));
      int v8 = ServiceMap;
      if ((v9 & 0x8000000000000000) != 0)
      {
        size_t v10 = (unsigned __int8 *)(v9 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v11 = 5381;
        do
        {
          unint64_t v9 = v11;
          unsigned int v12 = *v10++;
          uint64_t v11 = (33 * v11) ^ v12;
        }
        while (v12);
      }
      std::mutex::lock(ServiceMap);
      unint64_t v26 = v9;
      char v13 = sub_10004D37C(&v8[1].__m_.__sig, &v26);
      if (v13)
      {
        uint64_t v15 = v13[3];
        uint64_t v14 = (std::__shared_weak_count *)v13[4];
        if (v14)
        {
          atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v8);
          atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v14);
          char v16 = 0;
          if (!v15)
          {
LABEL_21:
            if ((v16 & 1) == 0) {
              sub_10004D2C8(v14);
            }
            goto LABEL_23;
          }
LABEL_13:
          unint64_t v26 = 0;
          uint64_t v27 = 0;
          uint64_t v28 = 0;
          uint64_t v17 = sub_10000F848(v3);
          (*(void (**)(unint64_t *__return_ptr, uint64_t, uint64_t))(*(void *)v15 + 568))(&v26, v15, v17);
          unint64_t v19 = v26;
          uint64_t v18 = v27;
          if (0x6DB6DB6DB6DB6DB7 * ((uint64_t)(v18 - v19) >> 3) >= (unint64_t)(sub_100004808(*(void *)(v3 + 96))
                                                                                      + 1))
          {
            unsigned int v22 = sub_100004808(*(void *)(v3 + 96));
            if (0x6DB6DB6DB6DB6DB7 * ((uint64_t)(v27 - v26) >> 3) <= (unint64_t)v22) {
              sub_10015B728();
            }
            sub_100B29760((void **)v3, *(_DWORD *)(v26 + 56 * v22) == 0, 2);
          }
          else
          {
            (*(void (**)(uint8_t *__return_ptr))(**(void **)(v3 + 96) + 176))(buf);
            uint64_t v20 = (NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v3 + 56) + 16))(*(void *)(v3 + 56), *(unsigned int *)(*(void *)buf + 52));
            if (v30) {
              sub_10004D2C8(v30);
            }
            uint64_t v21 = *v20;
            if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
            {
              *(_WORD *)std::string buf = 0;
              _os_log_error_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "Connection vector doesn't contain information for IMS data connection", buf, 2u);
            }
          }
          *(void *)std::string buf = &v26;
          sub_1002AC5A8((void ***)buf);
          goto LABEL_21;
        }
      }
      else
      {
        uint64_t v15 = 0;
      }
      std::mutex::unlock(v8);
      uint64_t v14 = 0;
      char v16 = 1;
      if (!v15) {
        goto LABEL_21;
      }
      goto LABEL_13;
    }
  }
LABEL_24:
  sub_100004A84((uint64_t *)&v25);
  return sub_100046B58((uint64_t *)&v24);
}

void sub_100B2C07C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, void **a14, uint64_t a15, std::__shared_weak_count *a16)
{
  if (a16) {
    sub_10004D2C8(a16);
  }
  a14 = (void **)&a11;
  sub_1002AC5A8(&a14);
  if ((v18 & 1) == 0) {
    sub_10004D2C8(v17);
  }
  sub_10004D2C8(v16);
  sub_100004A84(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

void sub_100B2C0E8()
{
}

__n128 sub_100B2C0FC(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_101A3C700;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_100B2C150(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A3C700;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100B2C188(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 16);
  uint64_t result = validContextType();
  char v4 = **(unsigned char **)(a1 + 24);
  if (result)
  {
    *(unsigned char *)(v2 + **(int **)(a1 + 8) + 148) = v4;
  }
  else
  {
    *(unsigned char *)(v2 + 149) = v4;
    *(unsigned char *)(v2 + 148) = v4;
  }
  return result;
}

uint64_t sub_100B2C1DC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100B2C21C()
{
}

void sub_100B2C22C()
{
}

void *sub_100B2C240(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = off_101A3C780;
  result[1] = v3;
  return result;
}

uint64_t sub_100B2C288(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A3C780;
  a2[1] = v2;
  return result;
}

uint64_t sub_100B2C2B4(uint64_t a1)
{
  return sub_100B27E18(*(void *)(a1 + 8));
}

uint64_t sub_100B2C2BC(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_100B2C2FC()
{
}

void sub_100B2C30C()
{
}

__n128 sub_100B2C320(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_101A3C800;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_100B2C36C(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A3C800;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100B2C39C(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  uint64_t v3 = *(void *)(a1 + 8);
  ServiceMap = (std::mutex *)Registry::getServiceMap(a2, *(Registry **)(v3 + 64));
  int v5 = ServiceMap;
  if (v6 < 0)
  {
    int v7 = (unsigned __int8 *)(v6 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v8 = 5381;
    do
    {
      uint64_t v6 = v8;
      unsigned int v9 = *v7++;
      uint64_t v8 = (33 * v8) ^ v9;
    }
    while (v9);
  }
  std::mutex::lock(ServiceMap);
  v22[0] = (const void *)v6;
  size_t v10 = sub_10004D37C(&v5[1].__m_.__sig, (unint64_t *)v22);
  if (v10)
  {
    uint64_t v12 = v10[3];
    uint64_t v11 = (std::__shared_weak_count *)v10[4];
    if (v11)
    {
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v5);
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v11);
      char v13 = 0;
      if (!v12) {
        goto LABEL_13;
      }
      goto LABEL_10;
    }
  }
  else
  {
    uint64_t v12 = 0;
  }
  std::mutex::unlock(v5);
  uint64_t v11 = 0;
  char v13 = 1;
  if (!v12) {
    goto LABEL_13;
  }
LABEL_10:
  unsigned int v14 = **(_DWORD **)(a1 + 16) / 0x3E8u;
  v22[0] = 0;
  CFDateRef v15 = CFDateCreate(0, (double)v14);
  v22[0] = v15;
  CFDateRef v30 = v15;
  if (v15) {
    CFRetain(v15);
  }
  (*(void (**)(uint64_t, CFDateRef *, const __CFString *))(*(void *)v12 + 24))(v12, &v30, @"com.apple.sd.SystemWake");
  sub_10007CA64((const void **)&v30);
  sub_10007CA64(v22);
LABEL_13:
  if ((v13 & 1) == 0) {
    sub_10004D2C8(v11);
  }
  Registry::getTimerService(&v27, *(Registry **)(v3 + 64));
  uint64_t v16 = v27;
  sub_100058DB0(__p, "PDP BringUp BackOff timer");
  unsigned int v17 = **(_DWORD **)(a1 + 16);
  char v18 = *(NSObject **)(v3 + 32);
  dispatch_object_t object = v18;
  if (v18) {
    dispatch_retain(v18);
  }
  v22[0] = _NSConcreteStackBlock;
  v22[1] = (const void *)0x40000000;
  v22[2] = sub_100B2C724;
  _OWORD v22[3] = &unk_101A3C860;
  v22[4] = (const void *)v3;
  aBlocuint64_t k = _Block_copy(v22);
  sub_100118A44(v16, (uint64_t)__p, 1, 1000 * v17, &object, &aBlock);
  uint64_t v19 = v29;
  uint64_t v29 = 0;
  uint64_t v20 = *(void *)(v3 + 176);
  *(void *)(v3 + 176) = v19;
  if (v20)
  {
    (*(void (**)(uint64_t))(*(void *)v20 + 8))(v20);
    uint64_t v21 = v29;
    uint64_t v29 = 0;
    if (v21) {
      (*(void (**)(uint64_t))(*(void *)v21 + 8))(v21);
    }
  }
  if (aBlock) {
    _Block_release(aBlock);
  }
  if (object) {
    dispatch_release(object);
  }
  if (v26 < 0) {
    operator delete(__p[0]);
  }
  if (v28) {
    sub_10004D2C8(v28);
  }
}

void sub_100B2C65C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *aBlock, dispatch_object_t object, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23)
{
  sub_10007CA64((const void **)(v25 - 72));
  sub_10007CA64((const void **)&a9);
  if ((v24 & 1) == 0) {
    sub_10004D2C8(v23);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100B2C6D8(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_100B2C718()
{
}

uint64_t sub_100B2C724(uint64_t a1)
{
  uint64_t v1 = *(void ***)(a1 + 32);
  (*(void (**)(uint64_t *__return_ptr))(*v1[12] + 176))(&v5);
  uint64_t v2 = (NSObject **)(*(uint64_t (**)(void *, void))(*v1[7] + 16))(v1[7], *(unsigned int *)(v5 + 52));
  if (v6) {
    sub_10004D2C8(v6);
  }
  uint64_t v3 = *v2;
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v5) = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I PdpBringUp: Back-Off timer expired", (uint8_t *)&v5, 2u);
  }
  uint64_t result = sub_100B28DE4(v1);
  if (result) {
    return (*(uint64_t (**)(void *, const char *, uint64_t))(*v1[12] + 32))(v1[12], "CT::handlePdpBringUpBackOffTimerExpired", 5);
  }
  return result;
}

void sub_100B2C834(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_100B2C84C(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  operator new();
}

void sub_100B2C8D8(uint64_t a1, int a2, uint64_t *a3)
{
  int v7 = a2;
  if (*((char *)a3 + 23) < 0) {
    a3 = (uint64_t *)*a3;
  }
  id v6 = +[NSString stringWithUTF8String:a3];
  char v4 = *(void ***)(a1 + 8);
  v8[0] = off_101A3C9E8;
  v8[1] = &v7;
  void v8[2] = &v6;
  _OWORD v8[3] = v8;
  sub_100043ED0((uint64_t)v8, *v4);
  sub_100043E48(v8);
}

void sub_100B2C9AC(_Unwind_Exception *a1, uint64_t a2, void *a3, uint64_t a4, ...)
{
  va_start(va, a4);
  sub_100043E48((uint64_t *)va);

  _Unwind_Resume(a1);
}

void *sub_100B2C9D0(uint64_t a1, int a2, uint64_t a3)
{
  int v6 = a2;
  uint64_t v3 = *(void ***)(a1 + 8);
  v7[0] = off_101A3CA68;
  v7[1] = a3;
  _OWORD v7[2] = &v6;
  void v7[3] = v7;
  sub_100043ED0((uint64_t)v7, *v3);
  return sub_100043E48(v7);
}

void sub_100B2CA74(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100043E48((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *sub_100B2CA90(uint64_t a1, int a2, uint64_t a3)
{
  int v6 = a2;
  uint64_t v3 = *(void ***)(a1 + 8);
  v7[0] = off_101A3CAE8;
  v7[1] = a3;
  _OWORD v7[2] = &v6;
  void v7[3] = v7;
  sub_100043ED0((uint64_t)v7, *v3);
  return sub_100043E48(v7);
}

void sub_100B2CB34(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100043E48((uint64_t *)va);
  _Unwind_Resume(a1);
}

void sub_100B2CB50(uint64_t a1, int a2)
{
  int v6 = a2;
  +[NSNumber numberWithInt:](NSNumber, "numberWithInt:");
  id v5 = (id)objc_claimAutoreleasedReturnValue();
  uint64_t v3 = *(void ***)(a1 + 8);
  v7[0] = off_101A3CB68;
  v7[1] = &v6;
  _OWORD v7[2] = &v5;
  void v7[3] = v7;
  sub_100043ED0((uint64_t)v7, *v3);
  sub_100043E48(v7);
}

void sub_100B2CC18(_Unwind_Exception *a1, uint64_t a2, void *a3, uint64_t a4, ...)
{
  va_start(va, a4);
  sub_100043E48((uint64_t *)va);

  _Unwind_Resume(a1);
}

void *sub_100B2CC3C(uint64_t a1, int a2, int a3)
{
  int v6 = a3;
  int v7 = a2;
  uint64_t v3 = *(void ***)(a1 + 8);
  v8[0] = off_101A3CBE8;
  v8[1] = &v6;
  void v8[2] = &v7;
  _OWORD v8[3] = v8;
  sub_100043ED0((uint64_t)v8, *v3);
  return sub_100043E48(v8);
}

void sub_100B2CCE4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100043E48((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *sub_100B2CD00(uint64_t a1, int a2, uint64_t a3)
{
  int v6 = a2;
  uint64_t v3 = *(void ***)(a1 + 8);
  v7[0] = off_101A3CC68;
  v7[1] = a3;
  _OWORD v7[2] = &v6;
  void v7[3] = v7;
  sub_100043ED0((uint64_t)v7, *v3);
  return sub_100043E48(v7);
}

void sub_100B2CDA4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100043E48((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *sub_100B2CDC0(uint64_t a1, int a2, int a3, uint64_t a4)
{
  int v9 = a3;
  int v10 = a2;
  id v5 = *(void ***)(a1 + 8);
  int v6 = operator new(0x20uLL);
  *int v6 = off_101A3CCE8;
  v6[1] = a4;
  _OWORD v6[2] = &v9;
  uint64_t v6[3] = &v10;
  void v11[3] = v6;
  sub_100043ED0((uint64_t)v11, *v5);
  return sub_100043E48(v11);
}

void sub_100B2CE74(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100043E48((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *sub_100B2CE90(uint64_t a1, uint64_t a2, uint64_t a3, char a4, int a5, int a6)
{
  char v14 = a4;
  int v12 = a6;
  int v13 = a5;
  uint64_t v8 = *(void ***)(a1 + 8);
  int v9 = operator new(0x30uLL);
  void *v9 = off_101A3CD68;
  v9[1] = &v14;
  _OWORD v9[2] = &v13;
  void v9[3] = &v12;
  void v9[4] = a2;
  v9[5] = a3;
  v15[3] = v9;
  sub_100043ED0((uint64_t)v15, *v8);
  return sub_100043E48(v15);
}

void sub_100B2CF5C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  sub_100043E48((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *sub_100B2CF78(uint64_t a1, uint64_t a2, int a3, uint64_t a4, char a5)
{
  int v12 = a3;
  char v11 = a5;
  int v7 = *(void ***)(a1 + 8);
  uint64_t v8 = operator new(0x28uLL);
  void *v8 = off_101A3CEE8;
  v8[1] = a4;
  void v8[2] = a2;
  _OWORD v8[3] = &v12;
  void v8[4] = &v11;
  v13[3] = v8;
  sub_100043ED0((uint64_t)v13, *v7);
  return sub_100043E48(v13);
}

void sub_100B2D040(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100043E48((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *sub_100B2D05C(uint64_t a1, int a2, char a3)
{
  int v7 = a2;
  char v6 = a3;
  uint64_t v3 = *(void ***)(a1 + 8);
  v8[0] = off_101A3CF68;
  v8[1] = &v7;
  void v8[2] = &v6;
  _OWORD v8[3] = v8;
  sub_100043ED0((uint64_t)v8, *v3);
  return sub_100043E48(v8);
}

void sub_100B2D108(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100043E48((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *sub_100B2D124(uint64_t a1, int a2, char a3, int a4)
{
  int v10 = a2;
  char v9 = a3;
  int v8 = a4;
  char v4 = *(void ***)(a1 + 8);
  id v5 = operator new(0x20uLL);
  *id v5 = off_101A3CFE8;
  v5[1] = &v10;
  _OWORD v5[2] = &v9;
  uint64_t v5[3] = &v8;
  void v11[3] = v5;
  sub_100043ED0((uint64_t)v11, *v4);
  return sub_100043E48(v11);
}

void sub_100B2D1E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  sub_100043E48((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *sub_100B2D1FC(uint64_t a1, int a2)
{
  int v5 = a2;
  uint64_t v2 = *(void ***)(a1 + 8);
  v6[0] = off_101A3D068;
  v6[1] = &v5;
  uint64_t v6[3] = v6;
  sub_100043ED0((uint64_t)v6, *v2);
  return sub_100043E48(v6);
}

void sub_100B2D2A0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100043E48((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *sub_100B2D2BC(uint64_t a1, int a2, int a3)
{
  int v6 = a2;
  int v7 = a3;
  uint64_t v3 = *(void ***)(a1 + 8);
  v8[0] = off_101A3D0E8;
  v8[1] = &v6;
  void v8[2] = &v7;
  _OWORD v8[3] = v8;
  sub_100043ED0((uint64_t)v8, *v3);
  return sub_100043E48(v8);
}

void sub_100B2D364(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100043E48((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *sub_100B2D380(uint64_t a1, int a2, char a3, char a4)
{
  int v10 = a2;
  char v9 = a3;
  char v8 = a4;
  char v4 = *(void ***)(a1 + 8);
  int v5 = operator new(0x20uLL);
  *int v5 = off_101A3D168;
  v5[1] = &v9;
  _OWORD v5[2] = &v8;
  uint64_t v5[3] = &v10;
  void v11[3] = v5;
  sub_100043ED0((uint64_t)v11, *v4);
  return sub_100043E48(v11);
}

void sub_100B2D43C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100043E48((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *sub_100B2D458(uint64_t a1, int a2, uint64_t a3)
{
  int v5 = *(void ***)(a1 + 8);
  int v6 = (char *)operator new(0x20uLL);
  *(void *)int v6 = off_101A3D1E8;
  *(_OWORD *)(v6 + 8) = *(_OWORD *)a3;
  *((_DWORD *)v6 + 6) = *(_DWORD *)(a3 + 16);
  *((_DWORD *)v6 + 7) = a2;
  void v9[3] = v6;
  sub_100043ED0((uint64_t)v9, *v5);
  return sub_100043E48(v9);
}

void sub_100B2D518(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
}

void sub_100B2D534(uint64_t a1, int a2, MCC *a3, const MCC *a4)
{
  int v6 = *(void ***)(a1 + 8);
  MCC::MCC((MCC *)&v9, a3);
  MCC::MCC((MCC *)&v12, a4);
  int v15 = a2;
  unsigned int v17 = 0;
  int v7 = operator new(0x50uLL);
  *(void *)int v7 = off_101A3D268;
  MCC::MCC((MCC *)(v7 + 2), (const MCC *)&v9);
  MCC::MCC((MCC *)(v7 + 10), (const MCC *)&v12);
  v7[18] = v15;
  unsigned int v17 = v7;
  sub_100043ED0((uint64_t)v16, *v6);
  sub_100043E48(v16);
  if (v14 < 0) {
    operator delete(__p);
  }
  if (v11 < 0) {
    operator delete(v10);
  }
}

void sub_100B2D64C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21)
{
}

void *sub_100B2D6B8(uint64_t a1)
{
  uint64_t v1 = *(void ***)(a1 + 8);
  v4[0] = off_101A3D2E8;
  v4[3] = v4;
  sub_100043ED0((uint64_t)v4, *v1);
  return sub_100043E48(v4);
}

void sub_100B2D754(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100043E48((uint64_t *)va);
  _Unwind_Resume(a1);
}

void sub_100B2D770(CTXPCRegistrationNotificationInterface *this)
{
  *(void *)this = off_101A3C8A0;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }

  CTXPCRegistrationNotificationInterface::~CTXPCRegistrationNotificationInterface(this);
}

void sub_100B2D7CC(CTXPCRegistrationNotificationInterface *this)
{
  *(void *)this = off_101A3C8A0;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  CTXPCRegistrationNotificationInterface::~CTXPCRegistrationNotificationInterface(this);

  operator delete();
}

void sub_100B2D83C(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_100B2D8A4(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100B2D8E0(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100B2D918(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_100B2D948(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

void sub_100B2D990()
{
}

__n128 sub_100B2D9A4(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_101A3C9E8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_100B2D9F0(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A3C9E8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100B2DA20(uint64_t a1, id *a2)
{
  id v4 = *a2;
  uint64_t v3 = +[CTXPCPlaceholder simSlot:**(unsigned int **)(a1 + 8)];
  [v4 operatorNameChanged:v3 name:**(void **)(a1 + 16)];
}

void sub_100B2DA9C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t sub_100B2DABC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100B2DAFC()
{
}

void sub_100B2DB0C()
{
}

__n128 sub_100B2DB20(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_101A3CA68;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_100B2DB6C(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A3CA68;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100B2DB9C(uint64_t a1, id *a2)
{
  id v8 = *a2;
  uint64_t v3 = objc_opt_new();
  id v4 = v3;
  int v5 = **(_DWORD **)(a1 + 8) - 1;
  if (v5 > 5) {
    int v6 = &kCTRegistrationStatusUnknown;
  }
  else {
    int v6 = *(&off_101A3D358 + v5);
  }
  [v3 setRegistrationDisplayStatus:*v6];
  [v4 setIsInHomeCountry:*(unsigned __int8 *)(*(void *)(a1 + 8) + 4)];
  [v4 setChangedDueToSimRemoval:*(unsigned __int8 *)(*(void *)(a1 + 8) + 5)];
  [v4 setIsRegistrationForcedHome:*(unsigned __int8 *)(*(void *)(a1 + 8) + 6)];
  [v4 setIsSatelliteSystem:*(unsigned __int8 *)(*(void *)(a1 + 8) + 7)];
  int v7 = +[CTXPCPlaceholder simSlot:**(unsigned int **)(a1 + 16)];
  [v8 displayStatusChanged:v7 status:v4];
}

void sub_100B2DCA0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  uint64_t v12 = v11;

  _Unwind_Resume(a1);
}

uint64_t sub_100B2DCD0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100B2DD10()
{
}

void sub_100B2DD20()
{
}

__n128 sub_100B2DD34(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_101A3CAE8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_100B2DD80(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A3CAE8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100B2DDB0(uint64_t a1, id *a2)
{
  id v8 = *a2;
  uint64_t v3 = objc_opt_new();
  id v4 = +[NSNumber numberWithInt:**(unsigned int **)(a1 + 8)];
  [v3 setBars:v4];

  int v5 = +[NSNumber numberWithInt:*(unsigned int *)(*(void *)(a1 + 8) + 4)];
  [v3 setDisplayBars:v5];

  int v6 = +[NSNumber numberWithInt:*(unsigned int *)(*(void *)(a1 + 8) + 8)];
  [v3 setMaxDisplayBars:v6];

  int v7 = +[CTXPCPlaceholder simSlot:**(unsigned int **)(a1 + 16)];
  [v8 signalStrengthChanged:v7 info:v3];
}

void sub_100B2DEC0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  uint64_t v12 = v11;

  _Unwind_Resume(a1);
}

uint64_t sub_100B2DF04(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100B2DF44()
{
}

void sub_100B2DF54()
{
}

__n128 sub_100B2DF68(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_101A3CB68;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_100B2DFB4(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A3CB68;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100B2DFE4(uint64_t a1, id *a2)
{
  id v4 = *a2;
  uint64_t v3 = +[CTXPCPlaceholder simSlot:**(unsigned int **)(a1 + 8)];
  [v4 rejectCauseCodeChanged:v3 causeCode:**(void **)(a1 + 16)];
}

void sub_100B2E060(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t sub_100B2E080(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100B2E0C0()
{
}

void sub_100B2E0D0()
{
}

__n128 sub_100B2E0E4(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_101A3CBE8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_100B2E130(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A3CBE8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100B2E160(uint64_t a1, id *a2)
{
  id v6 = *a2;
  uint64_t v3 = +[NSNumber numberWithInteger:**(int **)(a1 + 8)];
  id v4 = [objc_alloc((Class)CTVoiceLinkQualityMetric) initWithLinkQuality:v3];
  int v5 = +[CTXPCPlaceholder simSlot:**(unsigned int **)(a1 + 16)];
  [v6 voiceLinkQualityChanged:v5 metric:v4];
}

void sub_100B2E21C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  int v13 = v12;

  _Unwind_Resume(a1);
}

uint64_t sub_100B2E258(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100B2E298()
{
}

void sub_100B2E2A8()
{
}

__n128 sub_100B2E2BC(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_101A3CC68;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_100B2E308(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A3CC68;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100B2E338(uint64_t a1, id *a2)
{
  id v6 = *a2;
  uint64_t v3 = +[NSData dataWithBytes:**(void **)(a1 + 8) length:*(void *)(*(void *)(a1 + 8) + 8) - **(void **)(a1 + 8)];
  id v4 = [objc_alloc((Class)CTEnhancedLinkQualityMetric) initWithEnhancedLinkQuality:v3];
  int v5 = +[CTXPCPlaceholder simSlot:**(unsigned int **)(a1 + 16)];
  [v6 enhancedVoiceLinkQualityChanged:v5 metric:v4];
}

void sub_100B2E3F8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  int v13 = v12;

  _Unwind_Resume(a1);
}

uint64_t sub_100B2E434(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100B2E474()
{
}

void sub_100B2E484()
{
}

__n128 sub_100B2E498(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_101A3CCE8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_100B2E4EC(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A3CCE8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100B2E524(uint64_t a1, id *a2)
{
  id v9 = *a2;
  uint64_t v3 = +[NSData dataWithBytes:**(void **)(a1 + 8) length:*(void *)(*(void *)(a1 + 8) + 8) - **(void **)(a1 + 8)];
  id v4 = objc_alloc((Class)CTEnhancedDataLinkQualityMetric);
  int v5 = **(_DWORD **)(a1 + 16) - 16;
  if (v5 > 8) {
    uint64_t v6 = 0;
  }
  else {
    uint64_t v6 = qword_101544818[v5];
  }
  id v7 = [v4 initWithType:v6 enhancedLinkQuality:v3];
  id v8 = +[CTXPCPlaceholder simSlot:**(unsigned int **)(a1 + 24)];
  [v9 enhancedDataLinkQualityChanged:v8 metric:v7];
}

void sub_100B2E60C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  int v13 = v11;

  _Unwind_Resume(a1);
}

uint64_t sub_100B2E648(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100B2E688()
{
}

void sub_100B2E698()
{
}

__n128 sub_100B2E6AC(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x30uLL);
  *(void *)uint64_t v2 = off_101A3CD68;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  *((void *)v2 + 5) = *(void *)(a1 + 40);
  return result;
}

__n128 sub_100B2E708(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A3CD68;
  __n128 result = *(__n128 *)(a1 + 8);
  long long v3 = *(_OWORD *)(a1 + 24);
  *(void *)(a2 + 40) = *(void *)(a1 + 40);
  *(_OWORD *)(a2 + 24) = v3;
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100B2E748(uint64_t a1, id *a2)
{
  id v5 = *a2;
  long long v3 = objc_opt_new();
  [v3 setIsRegistered:**(unsigned __int8 **)(a1 + 8)];
  [v3 setContextType:**(unsigned int **)(a1 + 16)];
  [v3 setTransportType:**(unsigned int **)(a1 + 24)];
  id v4 = +[CTXPCPlaceholder simSlot:SlotIdFromPersonalityId()];
  [v5 imsRegistrationChanged:v4 info:v3];
}

void sub_100B2E804(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  uint64_t v12 = v11;

  _Unwind_Resume(a1);
}

uint64_t sub_100B2E838(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100B2E878()
{
}

void sub_100B2E888()
{
}

__n128 sub_100B2E89C(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_101A3CDE8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_100B2E8E8(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A3CDE8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100B2E914(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100B2E954()
{
}

void sub_100B2E964()
{
}

__n128 sub_100B2E978(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_101A3CE68;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_100B2E9C4(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A3CE68;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100B2E9F0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100B2EA30()
{
}

void sub_100B2EA40()
{
}

__n128 sub_100B2EA54(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_101A3CEE8;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100B2EAA8(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A3CEE8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100B2EAE0(uint64_t a1, id *a2)
{
  id v3 = *a2;
  id v4 = objc_opt_new();
  if (**(void **)(a1 + 8) != *(void *)(*(void *)(a1 + 8) + 8))
  {
    id v16 = v3;
    id v5 = objc_opt_new();
    uint64_t v6 = *(NetworkListOperator ***)(a1 + 8);
    id v7 = *v6;
    id v8 = v6[1];
    if (*v6 != v8)
    {
      do
      {
        id v9 = objc_opt_new();
        NetworkListOperator::getLocalizedCompositeName();
        if (v19 >= 0) {
          int v10 = __p;
        }
        else {
          int v10 = (void **)__p[0];
        }
        char v11 = +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v10, v16);
        [v9 setName:v11];

        if (v19 < 0) {
          operator delete(__p[0]);
        }
        NetworkListOperator::getKey((uint64_t *)__p, v7);
        if (v19 >= 0) {
          uint64_t v12 = __p;
        }
        else {
          uint64_t v12 = (void **)__p[0];
        }
        int v13 = +[NSString stringWithUTF8String:v12];
        [v9 setPlmn:v13];

        if (v19 < 0) {
          operator delete(__p[0]);
        }
        int RAT = NetworkListOperator::getRAT(v7);
        [v9 setRat:sub_10006941C(RAT)];
        [v5 addObject:v9];

        id v7 = (NetworkListOperator *)((char *)v7 + 136);
      }
      while (v7 != v8);
    }
    objc_msgSend(v4, "setNetworks:", v5, v16);

    id v3 = v17;
  }
  [v4 setMoreComing:**(unsigned __int8 **)(a1 + 32)];
  int v15 = +[CTXPCPlaceholder simSlot:**(unsigned int **)(a1 + 24)];
  [v3 networkListAvailable:v15 list:v4];
}

void sub_100B2ECC8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  _Unwind_Resume(a1);
}

uint64_t sub_100B2ED4C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100B2ED8C()
{
}

void sub_100B2ED9C()
{
}

__n128 sub_100B2EDB0(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_101A3CF68;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_100B2EDFC(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A3CF68;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100B2EE2C(uint64_t a1, id *a2)
{
  id v4 = *a2;
  id v3 = +[CTXPCPlaceholder simSlot:**(unsigned int **)(a1 + 8)];
  [v4 customerServiceProfileChanged:v3 visible:**(unsigned __int8 **)(a1 + 16)];
}

void sub_100B2EEA8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t sub_100B2EEC8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100B2EF08()
{
}

void sub_100B2EF18()
{
}

__n128 sub_100B2EF2C(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_101A3CFE8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_100B2EF80(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A3CFE8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100B2EFB8(uint64_t a1, id *a2)
{
  id v7 = *a2;
  id v3 = +[CTXPCPlaceholder simSlot:**(unsigned int **)(a1 + 8)];
  int v4 = **(_DWORD **)(a1 + 24);
  id v5 = &kCTRegistrationNetworkSelectionModeManual;
  if (v4 != 1) {
    id v5 = &kCTRegistrationNetworkSelectionModeDisabled;
  }
  if (v4) {
    uint64_t v6 = v5;
  }
  else {
    uint64_t v6 = &kCTRegistrationNetworkSelectionModeAutomatic;
  }
  [v7 networkSelected:v3 success:**(unsigned __int8 **)(a1 + 16) mode:*v6];
}

void sub_100B2F064(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t sub_100B2F084(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100B2F0C4()
{
}

void sub_100B2F0D4()
{
}

void *sub_100B2F0E8(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = off_101A3D068;
  result[1] = v3;
  return result;
}

uint64_t sub_100B2F130(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A3D068;
  a2[1] = v2;
  return result;
}

void sub_100B2F15C(uint64_t a1, id *a2)
{
  id v4 = *a2;
  uint64_t v3 = +[CTXPCPlaceholder simSlot:**(unsigned int **)(a1 + 8)];
  [v4 networkReselectionNeeded:v3];
}

void sub_100B2F1D0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t sub_100B2F1F0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100B2F230()
{
}

void sub_100B2F240()
{
}

__n128 sub_100B2F254(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_101A3D0E8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_100B2F2A0(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A3D0E8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100B2F2D0(uint64_t a1, id *a2)
{
  id v5 = *a2;
  uint64_t v3 = sub_1005AF7F8(**(_DWORD **)(a1 + 8));
  id v4 = sub_10132AE88(*(_DWORD **)(a1 + 16));
  [v5 encryptionStatusChanged:v3 info:v4];
}

void sub_100B2F354(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  uint64_t v12 = v11;

  _Unwind_Resume(a1);
}

uint64_t sub_100B2F384(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100B2F3C4()
{
}

void sub_100B2F3D4()
{
}

__n128 sub_100B2F3E8(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_101A3D168;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_100B2F43C(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A3D168;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100B2F474(uint64_t a1, id *a2)
{
  id v3 = *a2;
  uint64_t v6 = 0;
  uint64_t v7 = 0;
  sub_100DC3114(**(unsigned __int8 **)(a1 + 8), **(unsigned __int8 **)(a1 + 16), &v7, &v6);
  id v4 = objc_opt_new();
  [v4 setMask:**(unsigned __int8 **)(a1 + 8)];
  [v4 setSelection:v7];
  [v4 setPreferred:v6];
  id v5 = sub_1005AF7F8(**(_DWORD **)(a1 + 24));
  [v3 ratSelectionChanged:v5 selection:v4];
}

void sub_100B2F530(_Unwind_Exception *a1)
{
  id v4 = v3;

  _Unwind_Resume(a1);
}

uint64_t sub_100B2F560(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100B2F5A0()
{
}

void sub_100B2F5B0()
{
}

__n128 sub_100B2F5C4(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_101A3D1E8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_100B2F618(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A3D1E8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100B2F650(uint64_t a1, id *a2)
{
  id v3 = (unsigned __int8 *)(a1 + 8);
  id v6 = *a2;
  id v4 = sub_10132B15C(v3);
  id v5 = sub_1005AF7F8(*(_DWORD *)(a1 + 28));
  [v6 nrDisableStatusChanged:v5 status:v4];
}

void sub_100B2F6D4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  uint64_t v12 = v11;

  _Unwind_Resume(a1);
}

uint64_t sub_100B2F704(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100B2F744()
{
}

uint64_t sub_100B2F750(uint64_t a1)
{
  *(void *)a1 = off_101A3D268;
  if (*(char *)(a1 + 71) < 0) {
    operator delete(*(void **)(a1 + 48));
  }
  if (*(char *)(a1 + 39) < 0) {
    operator delete(*(void **)(a1 + 16));
  }
  return a1;
}

void sub_100B2F7B0(uint64_t a1)
{
  *(void *)a1 = off_101A3D268;
  if (*(char *)(a1 + 71) < 0) {
    operator delete(*(void **)(a1 + 48));
  }
  if (*(char *)(a1 + 39) < 0) {
    operator delete(*(void **)(a1 + 16));
  }

  operator delete();
}

void *sub_100B2F830(uint64_t a1)
{
  uint64_t v1 = (_DWORD *)(a1 + 8);
  uint64_t v2 = operator new(0x50uLL);
  void *v2 = off_101A3D268;
  sub_100B2FA74((MCC *)(v2 + 1), v1);
  return v2;
}

void sub_100B2F884(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

MCC *sub_100B2F898(uint64_t a1, void *a2)
{
  *a2 = off_101A3D268;
  return sub_100B2FA74((MCC *)(a2 + 1), (_DWORD *)(a1 + 8));
}

void sub_100B2F8C4(uint64_t a1)
{
}

void sub_100B2F8CC(void *a1)
{
  sub_10008820C((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_100B2F908(int *a1, id *a2)
{
  id v3 = *a2;
  id v4 = objc_alloc((Class)CTPlmnInfo);
  MCC::MCC((MCC *)v10, (const MCC *)(a1 + 2));
  MCC::MCC((MCC *)&v7, (const MCC *)(a1 + 10));
  id v5 = [v4 initWithMcc:v10 mnc:&v7];
  if (v9 < 0) {
    operator delete(__p);
  }
  if (v12 < 0) {
    operator delete(v11);
  }
  id v6 = sub_1005AF7F8(a1[18]);
  [v3 plmnChanged:v6 plmn:v5];
}

void sub_100B2F9CC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  uint64_t v25 = v23;

  _Unwind_Resume(a1);
}

uint64_t sub_100B2FA28(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100B2FA68()
{
}

MCC *sub_100B2FA74(MCC *a1, _DWORD *a2)
{
  MCC::MCC(a1, (const MCC *)a2);
  MCC::MCC((MCC *)(v4 + 32), (const MCC *)(a2 + 8));
  *((_DWORD *)a1 + 16) = a2[16];
  return a1;
}

void sub_100B2FAB4(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 31) < 0) {
    operator delete(*(void **)(v1 + 8));
  }
  _Unwind_Resume(exception_object);
}

void sub_100B2FAD4()
{
}

void *sub_100B2FAE8()
{
  __n128 result = operator new(0x10uLL);
  *__n128 result = off_101A3D2E8;
  return result;
}

void sub_100B2FB20(uint64_t a1, void *a2)
{
  *a2 = off_101A3D2E8;
}

id sub_100B2FB48(uint64_t a1, id *a2)
{
  return [*a2 dataRatesChanged];
}

uint64_t sub_100B2FB50(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_100B2FB90()
{
}

void sub_100B2FB9C()
{
}

void *sub_100B2FC24(uint64_t a1)
{
  uint64_t v1 = *(void ***)(a1 + 8);
  v4[0] = off_101A3D450;
  v4[3] = v4;
  sub_100043ED0((uint64_t)v4, *v1);
  return sub_100043E48(v4);
}

void sub_100B2FCC0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100043E48((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *sub_100B2FCDC(void *a1)
{
  *a1 = off_101A3D398;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

void sub_100B2FD28(void *a1)
{
  *a1 = off_101A3D398;
  uint64_t v1 = (std::__shared_weak_count *)a1[2];
  if (v1) {
    sub_10004D2C8(v1);
  }

  operator delete();
}

void sub_100B2FD94(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_100B2FDFC(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100B2FE38(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100B2FE70(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_100B2FEA0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

void sub_100B2FEE8()
{
}

void *sub_100B2FEFC()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = off_101A3D450;
  return result;
}

void sub_100B2FF34(uint64_t a1, void *a2)
{
  *a2 = off_101A3D450;
}

id sub_100B2FF5C(uint64_t a1, id *a2)
{
  return [*a2 refreshDataUsageUINotification];
}

uint64_t sub_100B2FF64(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100B2FFA4()
{
}

void sub_100B3032C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,char a22)
{
  if ((v27 & 1) == 0) {
    sub_10004D2C8(v25);
  }

  _Unwind_Resume(a1);
}

void sub_100B307E0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,char a23,uint64_t a24)
{
  if ((v30 & 1) == 0) {
    sub_10004D2C8(v28);
  }

  _Unwind_Resume(a1);
}

void sub_100B30BCC(_Unwind_Exception *a1)
{
  if ((v5 & 1) == 0) {
    sub_10004D2C8(v3);
  }

  _Unwind_Resume(a1);
}

void sub_100B30F5C(_Unwind_Exception *a1)
{
  if ((v5 & 1) == 0) {
    sub_10004D2C8(v3);
  }

  _Unwind_Resume(a1);
}

void sub_100B312FC(_Unwind_Exception *a1)
{
  if ((v5 & 1) == 0) {
    sub_10004D2C8(v3);
  }

  _Unwind_Resume(a1);
}

uint64_t sub_100B31384(uint64_t a1)
{
  return a1;
}

void sub_100B313B0(uint64_t a1)
{
  operator delete();
}

void *sub_100B313FC(uint64_t a1)
{
  uint64_t v2 = operator new(0x10uLL);
  void *v2 = off_101A3D4D0;
  v2[1] = objc_retainBlock(*(id *)(a1 + 8));
  return v2;
}

id sub_100B31454(uint64_t a1, void *a2)
{
  *a2 = off_101A3D4D0;
  id result = objc_retainBlock(*(id *)(a1 + 8));
  a2[1] = result;
  return result;
}

void sub_100B3149C(uint64_t a1)
{
}

void sub_100B314A4(id *a1)
{
  operator delete(a1);
}

void sub_100B314E0(uint64_t a1, unsigned char *a2)
{
  if (*a2) {
    id v3 = 0;
  }
  else {
    id v3 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
  }
  id v4 = v3;
  (*(void (**)(void))(*(void *)(a1 + 8) + 16))();
}

void sub_100B31570(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t sub_100B31584(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101A3D530)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_100B315C4()
{
  return &off_101A3D530;
}

uint64_t sub_100B315D0(uint64_t a1)
{
  return a1;
}

void sub_100B315FC(uint64_t a1)
{
  operator delete();
}

void *sub_100B31648(uint64_t a1)
{
  uint64_t v2 = operator new(0x10uLL);
  void *v2 = off_101A3D550;
  v2[1] = objc_retainBlock(*(id *)(a1 + 8));
  return v2;
}

id sub_100B316A0(uint64_t a1, void *a2)
{
  *a2 = off_101A3D550;
  id result = objc_retainBlock(*(id *)(a1 + 8));
  a2[1] = result;
  return result;
}

void sub_100B316E8(uint64_t a1)
{
}

void sub_100B316F0(id *a1)
{
  operator delete(a1);
}

void sub_100B3172C(uint64_t a1, unsigned char *a2)
{
  if (*a2) {
    id v3 = 0;
  }
  else {
    id v3 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
  }
  id v4 = v3;
  (*(void (**)(void))(*(void *)(a1 + 8) + 16))();
}

void sub_100B317BC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t sub_100B317D0(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101A3D5B0)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_100B31810()
{
  return &off_101A3D5B0;
}

uint64_t sub_100B3181C(uint64_t a1)
{
  return a1;
}

void sub_100B31848(uint64_t a1)
{
  operator delete();
}

void *sub_100B31894(uint64_t a1)
{
  uint64_t v2 = operator new(0x10uLL);
  void *v2 = off_101A3D5D0;
  v2[1] = objc_retainBlock(*(id *)(a1 + 8));
  return v2;
}

id sub_100B318EC(uint64_t a1, void *a2)
{
  *a2 = off_101A3D5D0;
  id result = objc_retainBlock(*(id *)(a1 + 8));
  a2[1] = result;
  return result;
}

void sub_100B31934(uint64_t a1)
{
}

void sub_100B3193C(id *a1)
{
  operator delete(a1);
}

void sub_100B31978(uint64_t a1, unsigned char *a2)
{
  if (*a2) {
    id v3 = 0;
  }
  else {
    id v3 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
  }
  id v4 = v3;
  (*(void (**)(void))(*(void *)(a1 + 8) + 16))();
}

void sub_100B31A08(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t sub_100B31A1C(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101A3D630)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_100B31A5C()
{
  return &off_101A3D630;
}

uint64_t sub_100B31A68(uint64_t a1)
{
  return a1;
}

void sub_100B31A94(uint64_t a1)
{
  operator delete();
}

void *sub_100B31AE0(uint64_t a1)
{
  uint64_t v2 = operator new(0x10uLL);
  void *v2 = off_101A3D650;
  v2[1] = objc_retainBlock(*(id *)(a1 + 8));
  return v2;
}

id sub_100B31B38(uint64_t a1, void *a2)
{
  *a2 = off_101A3D650;
  id result = objc_retainBlock(*(id *)(a1 + 8));
  a2[1] = result;
  return result;
}

void sub_100B31B80(uint64_t a1)
{
}

void sub_100B31B88(id *a1)
{
  operator delete(a1);
}

void sub_100B31BC4(uint64_t a1, unsigned char *a2)
{
  if (*a2)
  {
    (*(void (**)(void))(*(void *)(a1 + 8) + 16))();
    id v3 = 0;
  }
  else
  {
    id v4 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
    (*(void (**)(void))(*(void *)(a1 + 8) + 16))();
    id v3 = v4;
  }
}

void sub_100B31C78(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_100B31C88(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101A3D6B0)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_100B31CC8()
{
  return &off_101A3D6B0;
}

uint64_t sub_100B31CD4(uint64_t a1)
{
  return a1;
}

void sub_100B31D00(uint64_t a1)
{
  operator delete();
}

void *sub_100B31D4C(uint64_t a1)
{
  uint64_t v2 = operator new(0x10uLL);
  void *v2 = off_101A3D6D0;
  v2[1] = objc_retainBlock(*(id *)(a1 + 8));
  return v2;
}

id sub_100B31DA4(uint64_t a1, void *a2)
{
  *a2 = off_101A3D6D0;
  id result = objc_retainBlock(*(id *)(a1 + 8));
  a2[1] = result;
  return result;
}

void sub_100B31DEC(uint64_t a1)
{
}

void sub_100B31DF4(id *a1)
{
  operator delete(a1);
}

void sub_100B31E30(uint64_t a1, unsigned char *a2, uint64_t a3)
{
  if (!*a2)
  {
    id v7 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:22 userInfo:0];
    (*(void (**)(void))(*(void *)(a1 + 8) + 16))();
    goto LABEL_118;
  }
  char v5 = objc_opt_new();
  id v6 = (void **)(a3 + 8);
  if (*(char *)(a3 + 31) < 0)
  {
    unint64_t v8 = *(void *)(a3 + 16);
    if (!v8) {
      goto LABEL_22;
    }
    sub_10004FC84(__p, *v6, v8);
  }
  else
  {
    if (!*(unsigned char *)(a3 + 31)) {
      goto LABEL_22;
    }
    *(_OWORD *)long long __p = *(_OWORD *)v6;
    uint64_t v36 = *(void *)(a3 + 24);
  }
  if (SHIBYTE(v36) < 0)
  {
    sub_10004FC84(&__dst, __p[0], (unint64_t)__p[1]);
  }
  else
  {
    long long __dst = *(_OWORD *)__p;
    uint64_t v39 = v36;
  }
  v29[0] = 0;
  if (SHIBYTE(v39) < 0)
  {
    sub_10004FC84(&v40, (void *)__dst, *((unint64_t *)&__dst + 1));
  }
  else
  {
    long long v40 = __dst;
    uint64_t v41 = v39;
  }
  v31[0] = 0;
  if (ctu::cf::convert_copy())
  {
    char v9 = v29[0];
    v29[0] = v31[0];
    v33[0] = v9;
    sub_1000558F4((const void **)v33);
  }
  if (SHIBYTE(v41) < 0) {
    operator delete((void *)v40);
  }
  v27[0] = v29[0];
  v29[0] = 0;
  sub_1000558F4((const void **)v29);
  if (SHIBYTE(v39) < 0) {
    operator delete((void *)__dst);
  }
  [v5 setName:v27[0]];
  sub_1000558F4((const void **)v27);
  if (SHIBYTE(v36) < 0) {
    operator delete(__p[0]);
  }
LABEL_22:
  CSIPhoneNumber::getFullNumber((uint64_t *)&v40, (CSIPhoneNumber *)(a3 + 32));
  if (SHIBYTE(v41) < 0)
  {
    uint64_t v10 = *((void *)&v40 + 1);
    operator delete((void *)v40);
    if (!v10) {
      goto LABEL_40;
    }
  }
  else if (!HIBYTE(v41))
  {
    goto LABEL_40;
  }
  CSIPhoneNumber::getFullNumber((uint64_t *)v33, (CSIPhoneNumber *)(a3 + 32));
  if (SHIBYTE(v34) < 0)
  {
    sub_10004FC84(&__dst, v33[0], (unint64_t)v33[1]);
  }
  else
  {
    long long __dst = *(_OWORD *)v33;
    uint64_t v39 = v34;
  }
  v27[0] = 0;
  if (SHIBYTE(v39) < 0)
  {
    sub_10004FC84(&v40, (void *)__dst, *((unint64_t *)&__dst + 1));
  }
  else
  {
    long long v40 = __dst;
    uint64_t v41 = v39;
  }
  v29[0] = 0;
  if (ctu::cf::convert_copy())
  {
    char v11 = v27[0];
    v27[0] = v29[0];
    v31[0] = v11;
    sub_1000558F4((const void **)v31);
  }
  if (SHIBYTE(v41) < 0) {
    operator delete((void *)v40);
  }
  v24[0] = v27[0];
  v27[0] = 0;
  sub_1000558F4((const void **)v27);
  if (SHIBYTE(v39) < 0) {
    operator delete((void *)__dst);
  }
  objc_msgSend(v5, "setNumber:", v24[0], v24[0]);
  sub_1000558F4((const void **)v24);
  if (SHIBYTE(v34) < 0) {
    operator delete(v33[0]);
  }
LABEL_40:
  CSIPhoneNumber::getFullNumber((uint64_t *)&v40, (CSIPhoneNumber *)(a3 + 168));
  if (SHIBYTE(v41) < 0)
  {
    uint64_t v12 = *((void *)&v40 + 1);
    operator delete((void *)v40);
    if (!v12) {
      goto LABEL_58;
    }
  }
  else if (!HIBYTE(v41))
  {
    goto LABEL_58;
  }
  CSIPhoneNumber::getFullNumber((uint64_t *)v31, (CSIPhoneNumber *)(a3 + 168));
  if (SHIBYTE(v32) < 0)
  {
    sub_10004FC84(&__dst, v31[0], (unint64_t)v31[1]);
  }
  else
  {
    long long __dst = *(_OWORD *)v31;
    uint64_t v39 = v32;
  }
  v24[0] = 0;
  if (SHIBYTE(v39) < 0)
  {
    sub_10004FC84(&v40, (void *)__dst, *((unint64_t *)&__dst + 1));
  }
  else
  {
    long long v40 = __dst;
    uint64_t v41 = v39;
  }
  v27[0] = 0;
  if (ctu::cf::convert_copy())
  {
    int v13 = v24[0];
    v24[0] = v27[0];
    v29[0] = v13;
    sub_1000558F4((const void **)v29);
  }
  if (SHIBYTE(v41) < 0) {
    operator delete((void *)v40);
  }
  uint64_t v43 = v24[0];
  v24[0] = 0;
  sub_1000558F4((const void **)v24);
  if (SHIBYTE(v39) < 0) {
    operator delete((void *)__dst);
  }
  [v5 setAltNumber:v43];
  sub_1000558F4((const void **)&v43);
  if (SHIBYTE(v32) < 0) {
    operator delete(v31[0]);
  }
LABEL_58:
  char v14 = (void **)(a3 + 304);
  if (*(char *)(a3 + 327) < 0)
  {
    unint64_t v15 = *(void *)(a3 + 312);
    if (!v15) {
      goto LABEL_77;
    }
    sub_10004FC84(v29, *v14, v15);
  }
  else
  {
    if (!*(unsigned char *)(a3 + 327)) {
      goto LABEL_77;
    }
    *(_OWORD *)uint64_t v29 = *(_OWORD *)v14;
    uint64_t v30 = *(void *)(a3 + 320);
  }
  if (SHIBYTE(v30) < 0)
  {
    sub_10004FC84(&__dst, v29[0], (unint64_t)v29[1]);
  }
  else
  {
    long long __dst = *(_OWORD *)v29;
    uint64_t v39 = v30;
  }
  uint64_t v43 = 0;
  if (SHIBYTE(v39) < 0)
  {
    sub_10004FC84(&v40, (void *)__dst, *((unint64_t *)&__dst + 1));
  }
  else
  {
    long long v40 = __dst;
    uint64_t v41 = v39;
  }
  v24[0] = 0;
  if (ctu::cf::convert_copy())
  {
    id v16 = v43;
    uint64_t v43 = v24[0];
    v27[0] = v16;
    sub_1000558F4((const void **)v27);
  }
  if (SHIBYTE(v41) < 0) {
    operator delete((void *)v40);
  }
  uint64_t v42 = v43;
  uint64_t v43 = 0;
  sub_1000558F4((const void **)&v43);
  if (SHIBYTE(v39) < 0) {
    operator delete((void *)__dst);
  }
  [v5 setGroup:v42];
  sub_1000558F4((const void **)&v42);
  if (SHIBYTE(v30) < 0) {
    operator delete(v29[0]);
  }
LABEL_77:
  unsigned int v17 = (void **)(a3 + 328);
  if (*(char *)(a3 + 351) < 0)
  {
    unint64_t v18 = *(void *)(a3 + 336);
    if (!v18) {
      goto LABEL_96;
    }
    sub_10004FC84(v27, *v17, v18);
  }
  else
  {
    if (!*(unsigned char *)(a3 + 351)) {
      goto LABEL_96;
    }
    *(_OWORD *)char v27 = *(_OWORD *)v17;
    uint64_t v28 = *(void *)(a3 + 344);
  }
  if (SHIBYTE(v28) < 0)
  {
    sub_10004FC84(&__dst, v27[0], (unint64_t)v27[1]);
  }
  else
  {
    long long __dst = *(_OWORD *)v27;
    uint64_t v39 = v28;
  }
  uint64_t v42 = 0;
  if (SHIBYTE(v39) < 0)
  {
    sub_10004FC84(&v40, (void *)__dst, *((unint64_t *)&__dst + 1));
  }
  else
  {
    long long v40 = __dst;
    uint64_t v41 = v39;
  }
  uint64_t v43 = 0;
  if (ctu::cf::convert_copy())
  {
    char v19 = v42;
    uint64_t v42 = v43;
    v24[0] = v19;
    sub_1000558F4((const void **)v24);
  }
  if (SHIBYTE(v41) < 0) {
    operator delete((void *)v40);
  }
  uint64_t v37 = v42;
  uint64_t v42 = 0;
  sub_1000558F4((const void **)&v42);
  if (SHIBYTE(v39) < 0) {
    operator delete((void *)__dst);
  }
  [v5 setAltText:v37];
  sub_1000558F4((const void **)&v37);
  if (SHIBYTE(v28) < 0) {
    operator delete(v27[0]);
  }
LABEL_96:
  uint64_t v20 = (void **)(a3 + 352);
  if (*(char *)(a3 + 375) < 0)
  {
    unint64_t v21 = *(void *)(a3 + 360);
    if (v21)
    {
      sub_10004FC84(v24, *v20, v21);
      goto LABEL_101;
    }
  }
  else if (*(unsigned char *)(a3 + 375))
  {
    *(_OWORD *)char v24 = *(_OWORD *)v20;
    uint64_t v25 = *(void *)(a3 + 368);
LABEL_101:
    if (SHIBYTE(v25) < 0)
    {
      sub_10004FC84(&__dst, v24[0], (unint64_t)v24[1]);
    }
    else
    {
      long long __dst = *(_OWORD *)v24;
      uint64_t v39 = v25;
    }
    uint64_t v37 = 0;
    if (SHIBYTE(v39) < 0)
    {
      sub_10004FC84(&v40, (void *)__dst, *((unint64_t *)&__dst + 1));
    }
    else
    {
      long long v40 = __dst;
      uint64_t v41 = v39;
    }
    uint64_t v42 = 0;
    if (ctu::cf::convert_copy())
    {
      unsigned int v22 = v37;
      uint64_t v37 = v42;
      uint64_t v43 = v22;
      sub_1000558F4((const void **)&v43);
    }
    if (SHIBYTE(v41) < 0) {
      operator delete((void *)v40);
    }
    BOOL v23 = v37;
    char v26 = v37;
    uint64_t v37 = 0;
    sub_1000558F4((const void **)&v37);
    if (SHIBYTE(v39) < 0) {
      operator delete((void *)__dst);
    }
    objc_msgSend(v5, "setEmail:", v23, v24[0]);
    sub_1000558F4(&v26);
    if (SHIBYTE(v25) < 0) {
      operator delete(v24[0]);
    }
  }
  if (*(unsigned char *)(a3 + 376)) {
    [v5 setIsHidden:1];
  }
  (*(void (**)(void))(*(void *)(a1 + 8) + 16))();

  id v7 = 0;
LABEL_118:
}

void sub_100B325BC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15, uint64_t a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,uint64_t a29,uint64_t a30,uint64_t a31,int a32,__int16 a33,char a34,char a35,uint64_t a36,uint64_t a37,int a38,__int16 a39,char a40,char a41,uint64_t a42,uint64_t a43,int a44,__int16 a45,char a46,char a47)
{
  sub_1000558F4((const void **)(v48 - 152));
  if (*(char *)(v48 - 121) < 0) {
    operator delete(*(void **)(v48 - 144));
  }
  if (a14 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

uint64_t sub_100B3281C(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101A3D730)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_100B3285C()
{
  return &off_101A3D730;
}

uint64_t sub_100B32868(uint64_t a1)
{
  return a1;
}

void sub_100B3289C(uint64_t a1)
{
  operator delete();
}

void *sub_100B328F0(uint64_t a1)
{
  uint64_t v2 = operator new(0x18uLL);
  void *v2 = off_101A3D750;
  v2[1] = *(id *)(a1 + 8);
  v2[2] = objc_retainBlock(*(id *)(a1 + 16));
  return v2;
}

void sub_100B32954(id *a1)
{
  operator delete(a1);
}

uint64_t sub_100B32998(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101A3D7C0)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_100B329D8()
{
  return &off_101A3D7C0;
}

void CarrierSpaceDataPlanMetricsProvider::create()
{
}

void sub_100B32A58()
{
}

void sub_100B32A7C(uint64_t a1)
{
  *(void *)a1 = off_101A3D7E0;
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 136);
  if (v2) {
    sub_10004D2C8(v2);
  }

  id v3 = *(id **)(a1 + 104);
  *(void *)(a1 + 104) = 0;
  if (v3)
  {

    operator delete();
  }
  id v4 = *(std::__shared_weak_count **)(a1 + 88);
  if (v4) {
    std::__shared_weak_count::__release_weak(v4);
  }
  char v5 = *(std::__shared_weak_count **)(a1 + 72);
  if (v5) {
    sub_10004D2C8(v5);
  }
  id v6 = *(std::__shared_weak_count **)(a1 + 56);
  if (v6) {
    sub_10004D2C8(v6);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 40));
  sub_100087E88((void *)(a1 + 8));

  CarrierSpaceDataPlanMetricsProviderInterface::~CarrierSpaceDataPlanMetricsProviderInterface((CarrierSpaceDataPlanMetricsProviderInterface *)a1);
}

void sub_100B32B48(uint64_t a1)
{
  sub_100B32A7C(a1);

  operator delete();
}

void CarrierSpaceDataPlanMetricsProvider::CarrierSpaceDataPlanMetricsProvider(void *a1, void *a2, NSObject **a3)
{
  id v6 = a1 + 1;
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v13, kCtLoggingSystemName, "carrier.space.dpm");
  *id v6 = 0;
  v6[1] = 0;
  id v7 = *a3;
  a1[3] = *a3;
  if (v7) {
    dispatch_retain(v7);
  }
  a1[4] = 0;
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v14, &v13);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 5), (const ctu::OsLogLogger *)v14);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v14);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v13);
  *a1 = off_101A3D7E0;
  a1[6] = *a2;
  uint64_t v8 = a2[1];
  a1[7] = v8;
  if (v8) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v8 + 8), 1uLL, memory_order_relaxed);
  }
  sub_100058DB0(&__p, "CarrierSpaceDataPlanMetricsProvider");
  char v9 = a1[3];
  uint64_t v10 = v9;
  if (v9) {
    dispatch_retain(v9);
  }
  ctu::RestModule::RestModule();
  if (v10) {
    dispatch_release(v10);
  }
  if (v12 < 0) {
    operator delete(__p);
  }
  a1[10] = 0;
  a1[11] = 0;
  a1[12] = 0;
  operator new();
}

void sub_100B32D0C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, dispatch_object_t object, dispatch_object_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17)
{
  unint64_t v21 = (std::__shared_weak_count *)*((void *)v17 + 11);
  if (v21) {
    std::__shared_weak_count::__release_weak(v21);
  }
  unsigned int v22 = (std::__shared_weak_count *)*((void *)v17 + 9);
  if (v22) {
    sub_10004D2C8(v22);
  }
  BOOL v23 = (std::__shared_weak_count *)*((void *)v17 + 7);
  if (v23) {
    sub_10004D2C8(v23);
  }
  ctu::OsLogLogger::~OsLogLogger(v19);
  sub_100087E88(v18);
  CarrierSpaceDataPlanMetricsProviderInterface::~CarrierSpaceDataPlanMetricsProviderInterface(v17);
  _Unwind_Resume(a1);
}

void sub_100B32DBC(uint64_t a1)
{
  Registry::createRestModuleOneTimeUseConnection(&v4, *(Registry **)(a1 + 48));
  ctu::RestModule::connect();
  if (v5) {
    sub_10004D2C8(v5);
  }
  sub_100058DB0(__p, "/cc/props/roaming_results");
  uint64_t v2 = operator new(0x28uLL);
  void *v2 = off_101A3D938;
  v2[1] = a1 + 96;
  v2[2] = a1;
  v2[3] = sub_100B32F80;
  v2[4] = 0;
  char v9 = v2;
  ctu::RestModule::observeProperty();
  sub_10003F600(v8);
  if (v7 < 0) {
    operator delete(__p[0]);
  }
  sub_100058DB0(__p, "/cc/props/carrier_space_debug_roaming_status");
  id v3 = operator new(0x28uLL);
  void *v3 = off_101A3D9B8;
  v3[1] = a1 + 100;
  v3[2] = a1;
  v3[3] = sub_100B330BC;
  void v3[4] = 0;
  char v9 = v3;
  ctu::RestModule::observeProperty();
  sub_10003F600(v8);
  if (v7 < 0) {
    operator delete(__p[0]);
  }
}

void sub_100B32F30(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_100B32F80(uint64_t a1, int a2)
{
  if (sub_100B33B24(a1, __stack_chk_guard) != a2)
  {
    id v3 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      sub_100B33B24(a1, v4);
      int v10 = 136315138;
      uint64_t v11 = asString();
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Sending notification to clients upon roaming status change %s", (uint8_t *)&v10, 0xCu);
    }
    if (sub_100B33B24(a1, v4) == 4) {
      uint64_t v5 = 2;
    }
    else {
      uint64_t v5 = 1;
    }
    [**(id **)(a1 + 104) setRegStatus:v5];
    id v6 = *(std::__shared_weak_count **)(a1 + 88);
    if (v6)
    {
      char v7 = std::__shared_weak_count::lock(v6);
      if (v7)
      {
        uint64_t v8 = v7;
        uint64_t v9 = *(void *)(a1 + 80);
        if (v9) {
          (*(void (**)(uint64_t))(*(void *)v9 + 16))(v9);
        }
        sub_10004D2C8(v8);
      }
    }
  }
}

void sub_100B330A0(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_100B330BC(uint64_t a1, int a2)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(__stack_chk_guard, *(Registry **)(a1 + 48));
  uint64_t v5 = ServiceMap;
  if (v6 < 0)
  {
    char v7 = (unsigned __int8 *)(v6 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v8 = 5381;
    do
    {
      uint64_t v6 = v8;
      unsigned int v9 = *v7++;
      uint64_t v8 = (33 * v8) ^ v9;
    }
    while (v9);
  }
  std::mutex::lock(ServiceMap);
  *(void *)char v19 = v6;
  int v10 = sub_10004D37C(&v5[1].__m_.__sig, (unint64_t *)v19);
  if (v10)
  {
    uint64_t v12 = v10[3];
    uint64_t v11 = (std::__shared_weak_count *)v10[4];
    if (v11)
    {
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v5);
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v11);
      char v13 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v12 = 0;
  }
  std::mutex::unlock(v5);
  uint64_t v11 = 0;
  char v13 = 1;
LABEL_9:
  char v14 = (*(uint64_t (**)(uint64_t))(*(void *)v12 + 16))(v12);
  if ((v13 & 1) == 0) {
    sub_10004D2C8(v11);
  }
  if (v14)
  {
    unint64_t v15 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v16 = asString();
      uint64_t v17 = asString();
      *(_DWORD *)char v19 = 136315394;
      *(void *)&v19[4] = v16;
      __int16 v20 = 2080;
      uint64_t v21 = v17;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I Debug Roaming status: previous %s, new %s", v19, 0x16u);
    }
    if (a2 == 2) {
      int v18 = 4;
    }
    else {
      int v18 = 5;
    }
    sub_100B32F80(a1, v18);
  }
}

void sub_100B3327C(_Unwind_Exception *exception_object)
{
}

const void **sub_100B332B4(uint64_t a1)
{
  char v7 = 0;
  DevicePersistentCopyValue((uint64_t *)&v6, @"CarrierSpaceDataPlanMetricsCacheKey", 0);
  sub_100044D6C(&v7, &v6);
  sub_1000577C4(&v6);
  if (v7) {
    uint64_t v2 = sub_100083F10;
  }
  else {
    uint64_t v2 = 0;
  }
  if (v2)
  {
    id v3 = [v7 mutableCopy];
    uint64_t v4 = *(void **)(a1 + 120);
    *(void *)(a1 + 120) = v3;
  }
  return sub_100044D00((const void **)&v7);
}

void sub_100B33340(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100044D00((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100B33364(void *a1)
{
  uint64_t v2 = (void **)a1[13];
  id v3 = *v2;
  void *v2 = 0;

  uint64_t v4 = (void *)a1[15];
  a1[15] = 0;

  uint64_t v5 = (std::__shared_weak_count *)a1[17];
  a1[16] = 0;
  a1[17] = 0;
  if (v5) {
    sub_10004D2C8(v5);
  }
  a1[14] = 0;

  return DevicePersistentSaveValue(@"CarrierSpaceDataPlanMetricsCacheKey", 0);
}

uint64_t sub_100B333D0@<X0>(uint64_t a1@<X0>, id **a2@<X1>, uint64_t *a3@<X8>)
{
  if (sub_100B33B24(a1, a3) == 4)
  {
    uint64_t v5 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I roaming is not supported", buf, 2u);
    }
    uint64_t v6 = 0;
    *(void *)(a1 + 112) = 19;
    return v6;
  }
  *(void *)(a1 + 112) = 0;
  char v7 = (uint64_t *)(a1 + 112);
  if (*a2)
  {
    id v8 = **a2;
    for (unint64_t i = 0; ; ++i)
    {
      int v10 = [v8 accountMetrics];
      id v11 = [v10 count];

      if (i >= (unint64_t)v11)
      {
        long long v66 = 0;
        unint64_t v15 = 0;
        goto LABEL_24;
      }
      uint64_t v12 = [v8 accountMetrics];
      char v13 = [v12 objectAtIndexedSubscript:i];

      if ([v13 localDevice]) {
        break;
      }
      uint64_t *v7 = 1;
    }
    uint64_t v16 = [v13 subscriptionStatus];
    unsigned __int8 v17 = [v16 isEqualToString:@"subscribed"];

    if (v17)
    {
      int v18 = [v13 billingCycleEndDate];

      if (v18)
      {
        char v19 = +[NSDate date];
        __int16 v20 = [v13 billingCycleEndDate];
        [v19 timeIntervalSinceDate:v20];
        double v22 = v21;

        if (v22 <= 864000.0)
        {
          char v24 = [v13 planType];
          unsigned __int8 v25 = [v24 isEqualToString:@"prepaid"];

          if ((v25 & 1) == 0)
          {
            id v26 = v13;
            unint64_t v15 = sub_100B33C68(a1, v26, (uint64_t *)(a1 + 112));
            goto LABEL_23;
          }
          uint64_t v23 = 6;
        }
        else
        {
          uint64_t v23 = 4;
        }
      }
      else
      {
        uint64_t v23 = 3;
      }
    }
    else
    {
      uint64_t v23 = 2;
    }
    id v26 = 0;
    unint64_t v15 = 0;
    uint64_t *v7 = v23;
LABEL_23:

    long long v66 = v26;
LABEL_24:
    unsigned int v65 = [v15 isEqual:**(void **)(a1 + 104)];
    if ((v65 & 1) == 0) {
      objc_storeStrong(*(id **)(a1 + 104), v15);
    }
    id v27 = v66;
    id v67 = v15;
    uint64_t v28 = *(std::__shared_weak_count **)(a1 + 136);
    *(void *)(a1 + 128) = 0;
    *(void *)(a1 + 136) = 0;
    if (v28) {
      sub_10004D2C8(v28);
    }
    if (!v27) {
      goto LABEL_65;
    }
    uint64_t v29 = (char *)operator new(0x40uLL);
    *((void *)v29 + 1) = 0;
    *((void *)v29 + 2) = 0;
    *(void *)uint64_t v29 = off_101A3DA88;
    *(_OWORD *)(v29 + 40) = 0u;
    *(_OWORD *)(v29 + 24) = 0u;
    *((void *)v29 + 4) = kCellularDPMAnalyticsCapacityGroupVersionValue;
    *((void *)v29 + 7) = 0;
    uint64_t v30 = *(std::__shared_weak_count **)(a1 + 136);
    *(void *)(a1 + 128) = v29 + 24;
    *(void *)(a1 + 136) = v29;
    if (v30) {
      sub_10004D2C8(v30);
    }
    long long v31 = [v27 billingCycleEndDate];
    [v31 timeIntervalSinceNow];
    **(void **)(a1 + 128) = (unint64_t)(v32 / 86400.0);

    long long v33 = 0;
    unint64_t v68 = 0;
    for (unint64_t j = 0; ; ++j)
    {
      long long v35 = [v27 applicablePlans];
      id v36 = [v35 count];

      if (j >= (unint64_t)v36) {
        break;
      }
      uint64_t v37 = [v27 applicablePlans];
      uint64_t v38 = [v37 objectAtIndexedSubscript:j];

      if (v38)
      {
        if ([v38 currentUsedPlan])
        {
          uint64_t v39 = [v38 dataUsage];

          if (v39)
          {
            long long v40 = [v38 dataUsage];
            uint64_t v41 = [v40 sharedDataUsed];

            if (v41)
            {
              uint64_t v42 = *(void *)(a1 + 128);
              if (!*(unsigned char *)(v42 + 20)) {
                *(unsigned char *)(v42 + 20) = 1;
              }
            }
            uint64_t v71 = 0;
            uint64_t v43 = [v38 dataUsage];
            uint64_t v44 = sub_100B344F8(v43, 1, &v71);
            id v45 = [v44 unsignedLongValue];

            size_t v46 = [v38 dataUsage];
            uint64_t v47 = [v46 thisDeviceDataUsed];
            BOOL v48 = sub_100B3481C(v47);

            if (v48)
            {
              uint64_t v49 = [v38 dataUsage];
              uint64_t v50 = [v49 thisDeviceDataUsed];
              [v50 doubleValue];
              uint64_t v51 = [v38 dataUsage];
              [v51 units];
              CTCarrierSpaceConvertDataUnits();
              unint64_t v68 = (unint64_t)(v52 + (double)v68);
            }
            long long v33 = &v33[(void)v45];
          }
        }
      }
    }
    if (*(unsigned char *)(*(void *)(a1 + 128) + 20))
    {
      uint64_t v53 = [v67 domestic];
      char v54 = [v53 capacityBytes];
      unint64_t v55 = (unint64_t)[v54 unsignedLongValue];
    }
    else
    {
      unint64_t v55 = 0;
    }
    CTCarrierSpaceConvertDataUnits();
    if ((unint64_t)v56 == 2) {
      int v57 = 2;
    }
    else {
      int v57 = 1;
    }
    if ((unint64_t)v56 <= 2) {
      int v58 = v57;
    }
    else {
      int v58 = 3;
    }
    if ((unint64_t)v56 <= 0xA) {
      int v59 = v58;
    }
    else {
      int v59 = 4;
    }
    *(_DWORD *)(*(void *)(a1 + 128) + 16) = v59;
    CTCarrierSpaceConvertDataUnits();
    unint64_t v61 = (unint64_t)v60;
    if ((unint64_t)v60 <= 0xA)
    {
      if (v61 <= 2)
      {
        if (v61 == 2) {
          int v62 = 2;
        }
        else {
          int v62 = 1;
        }
      }
      else
      {
        int v62 = 3;
      }
    }
    else
    {
      int v62 = 4;
    }
    uint64_t v63 = *(void *)(a1 + 128);
    *(_DWORD *)(v63 + 24) = v62;
    if (*(unsigned char *)(v63 + 20))
    {
      if (!v55)
      {
LABEL_65:

        DevicePersistentSaveValue(@"CarrierSpaceDataPlanMetricsCacheKey", *(const void **)(a1 + 120));
        uint64_t v6 = v65 ^ 1;

        return v6;
      }
    }
    else
    {
      unint64_t v55 = (unint64_t)v33;
      if (!v33) {
        goto LABEL_65;
      }
    }
    *(void *)(v63 + 32) = 100 * v68 / v55;
    goto LABEL_65;
  }
  char v14 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long v69 = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "updateDataPlanMetrics - usageInfoPtr is null", v69, 2u);
  }
  return 0;
}

void sub_100B33A08(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_100B33B24@<X0>(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(a2, *(Registry **)(a1 + 48));
  uint64_t v4 = ServiceMap;
  if ((v5 & 0x8000000000000000) != 0)
  {
    uint64_t v6 = (unsigned __int8 *)(v5 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v7 = 5381;
    do
    {
      unint64_t v5 = v7;
      unsigned int v8 = *v6++;
      uint64_t v7 = (33 * v7) ^ v8;
    }
    while (v8);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v16 = v5;
  unsigned int v9 = sub_10004D37C(&v4[1].__m_.__sig, &v16);
  if (v9)
  {
    uint64_t v11 = v9[3];
    int v10 = (std::__shared_weak_count *)v9[4];
    if (v10)
    {
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v4);
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v10);
      char v12 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v11 = 0;
  }
  std::mutex::unlock(v4);
  int v10 = 0;
  char v12 = 1;
LABEL_9:
  int v13 = (*(uint64_t (**)(uint64_t))(*(void *)v11 + 16))(v11);
  if ((v12 & 1) == 0) {
    sub_10004D2C8(v10);
  }
  if (!v13) {
    return *(unsigned int *)(a1 + 96);
  }
  int v14 = *(_DWORD *)(a1 + 100);
  if (!v14) {
    return *(unsigned int *)(a1 + 96);
  }
  if (v14 == 2) {
    return 4;
  }
  return 5;
}

void sub_100B33C4C(_Unwind_Exception *exception_object)
{
  if ((v2 & 1) == 0) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

id sub_100B33C68(uint64_t a1, void *a2, uint64_t *a3)
{
  id v62 = a2;
  uint64_t v59 = 0;
  char v3 = 0;
  unint64_t v4 = 0;
  *(void *)&long long v5 = 67109120;
  long long v58 = v5;
  while (1)
  {
    uint64_t v6 = objc_msgSend(v62, "applicablePlans", v58);
    BOOL v7 = v4 < (unint64_t)[v6 count];

    if (!v7)
    {
      if (v3)
      {
        +[NSNumber numberWithUnsignedInteger:v59];
        goto LABEL_54;
      }
      goto LABEL_66;
    }
    unsigned int v8 = [v62 applicablePlans];
    unsigned int v9 = [v8 objectAtIndexedSubscript:v4];

    if (!v9)
    {
      uint64_t v12 = 7;
      goto LABEL_11;
    }
    if (([v9 currentUsedPlan] & 1) == 0)
    {
      uint64_t v12 = 8;
      goto LABEL_11;
    }
    int v10 = [v9 dataUsage];
    BOOL v11 = v10 == 0;

    if (v11)
    {
      uint64_t v12 = 9;
      goto LABEL_11;
    }
    if ([v9 planCategory] == (id)3)
    {
      uint64_t v12 = 10;
LABEL_11:
      *a3 = v12;
      goto LABEL_12;
    }
    int v13 = [v9 dataUsage];
    int v14 = [v13 sharedDataUsed];

    if (!v14) {
      goto LABEL_27;
    }
    unint64_t v15 = [v9 lastUpdatedAt];
    BOOL v16 = v15 == 0;

    if (v16)
    {
      uint64_t v56 = 11;
LABEL_64:
      *a3 = v56;
LABEL_65:

LABEL_66:
      uint64_t v49 = 0;
      goto LABEL_67;
    }
    unsigned __int8 v17 = [v62 billingCycleEndDate];
    int v18 = [v9 lastUpdatedAt];
    [v17 timeIntervalSinceDate:v18];
    double v20 = v19;

    if (v20 < 0.0)
    {
      uint64_t v56 = 5;
      goto LABEL_64;
    }
    if (v20 > 1728000.0)
    {
      double v21 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)std::string buf = v58;
        *(_DWORD *)&uint8_t buf[4] = 20;
        _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "#I shared plan but more than %u days left in billing cycle, so reuse last plan information", buf, 8u);
      }
      id v22 = v9;
      for (unint64_t i = 0; i < (unint64_t)[*(id *)(a1 + 120) count]; ++i)
      {
        char v24 = [*(id *)(a1 + 120) objectAtIndexedSubscript:i];
        unsigned __int8 v25 = [v22 planLabel];
        if (v25)
        {
          id v26 = [v24 objectForKeyedSubscript:@"planLabel"];
          if (v26)
          {
            id v27 = [v24 objectForKeyedSubscript:@"planLabel"];
            uint64_t v28 = [v22 planLabel];
            unsigned __int8 v29 = [v27 isEqualToString:v28];

            if (v29)
            {
              id v42 = [v24 objectForKeyedSubscript:@"planDataCapacity"];

              goto LABEL_40;
            }
          }
          else
          {
          }
        }
        *a3 = 12;
      }
      id v42 = 0;
LABEL_40:

      goto LABEL_41;
    }
LABEL_27:
    uint64_t v30 = [v9 dataUsage];
    sub_100B344F8(v30, 0, a3);
    id v42 = (id)objc_claimAutoreleasedReturnValue();

    if (v42) {
      BOOL v31 = v14 != 0;
    }
    else {
      BOOL v31 = 0;
    }
    if (v31)
    {
      id v32 = v9;
      id v42 = v42;
      long long v33 = [v32 planLabel];
      BOOL v34 = v33 == 0;

      if (!v34)
      {
        long long v35 = *(void **)(a1 + 120);
        if (v35)
        {
          for (unint64_t j = 0; ; ++j)
          {
            if (j >= (unint64_t)[v35 count])
            {
              uint64_t v37 = 0;
              goto LABEL_45;
            }
            uint64_t v37 = [*(id *)(a1 + 120) objectAtIndexedSubscript:j];
            uint64_t v38 = [v37 objectForKeyedSubscript:@"planLabel"];
            if (v38)
            {
              uint64_t v39 = [v37 objectForKeyedSubscript:@"planLabel"];
              long long v40 = [v32 planLabel];
              unsigned __int8 v41 = [v39 isEqualToString:v40];

              if (v41) {
                break;
              }
            }

            long long v35 = *(void **)(a1 + 120);
          }
          if (v37) {
            [*(id *)(a1 + 120) removeObjectAtIndex:j];
          }
LABEL_45:
        }
        v63[0] = @"planLabel";
        uint64_t v43 = [v32 planLabel];
        v63[1] = @"planDataCapacity";
        *(void *)std::string buf = v43;
        id v65 = v42;
        uint64_t v44 = +[NSDictionary dictionaryWithObjects:buf forKeys:v63 count:2];

        id v45 = *(void **)(a1 + 120);
        if (!v45)
        {
          uint64_t v46 = +[NSMutableArray array];
          uint64_t v47 = *(void **)(a1 + 120);
          *(void *)(a1 + 120) = v46;

          id v45 = *(void **)(a1 + 120);
        }
        [v45 addObject:v44];
      }
      goto LABEL_50;
    }
LABEL_41:
    if (!v42)
    {
      char v54 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v54, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v54, OS_LOG_TYPE_ERROR, "can't determine plan capacity", buf, 2u);
      }
      goto LABEL_65;
    }
LABEL_50:
    if ((unint64_t)[v42 unsignedIntegerValue] > 0xC7FFFFFFFLL) {
      break;
    }
    id v48 = [v42 unsignedIntegerValue];

    v59 += (uint64_t)v48;
    char v3 = 1;
LABEL_12:

    ++v4;
  }

  +[NSNumber numberWithUnsignedInteger:0xC80000000];
  uint64_t v49 = LABEL_54:;

  if (!v49)
  {
LABEL_67:
    id v50 = 0;
    goto LABEL_68;
  }
  id v50 = objc_alloc_init((Class)CTCarrierSpaceDataPlanMetrics);
  uint64_t v51 = [v62 billingCycleEndDate];
  [v50 setBillingCycleEndDate:v51];

  if (sub_100B33B24(a1, v52) == 4) {
    uint64_t v53 = 2;
  }
  else {
    uint64_t v53 = 1;
  }
  [v50 setRegStatus:v53];
  [v50 setDomesticCapacity:v49];
LABEL_68:

  return v50;
}

void sub_100B342FC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  _Unwind_Resume(a1);
}

void **sub_100B3446C@<X0>(void **result@<X0>, _DWORD *a2@<X1>, void *a3@<X8>)
{
  unint64_t v4 = result;
  *a3 = 0;
  a3[1] = 0;
  uint64_t v6 = (void *)*result[13];
  if (v6)
  {
    BOOL v7 = operator new(0x20uLL);
    v7[1] = 0;
    _OWORD v7[2] = 0;
    void *v7 = off_101A3DA38;
    id result = v6;
    void v7[3] = result;
    *a3 = v7 + 3;
    a3[1] = v7;
  }
  *a2 = v4[14];
  return result;
}

id sub_100B344F8(void *a1, char a2, uint64_t *a3)
{
  id v5 = a1;
  uint64_t v6 = [v5 capacity];
  id v7 = [v6 caseInsensitiveCompare:@"unlimited"];

  if (v7)
  {
    unsigned int v8 = [v5 capacity];
    BOOL v9 = sub_100B3481C(v8);

    if (!v9)
    {
      uint64_t v27 = 14;
      goto LABEL_26;
    }
    int v10 = [v5 capacity];
    [v10 doubleValue];
  }
  else
  {
    uint64_t v12 = [v5 maxDataBeforeThrottling];

    if (!v12)
    {
      uint64_t v28 = +[NSNumber numberWithUnsignedInteger:-1];
      goto LABEL_28;
    }
    int v13 = [v5 maxDataBeforeThrottling];
    BOOL v14 = sub_100B3481C(v13);

    if (!v14)
    {
      uint64_t v27 = 13;
      goto LABEL_26;
    }
    int v10 = [v5 maxDataBeforeThrottling];
    [v10 doubleValue];
  }
  double v15 = v11;

  BOOL v16 = [v5 sharedDataUsed];

  if (v16 && (a2 & 1) == 0)
  {
    unsigned __int8 v17 = [v5 sharedDataUsed];
    BOOL v18 = sub_100B3481C(v17);

    if (!v18)
    {
      uint64_t v27 = 15;
      goto LABEL_26;
    }
    double v19 = [v5 thisDeviceDataUsed];
    BOOL v20 = sub_100B3481C(v19);

    if (!v20)
    {
      uint64_t v27 = 16;
      goto LABEL_26;
    }
    double v21 = [v5 sharedDataUsed];
    [v21 doubleValue];
    double v23 = v22;
    char v24 = [v5 thisDeviceDataUsed];
    [v24 doubleValue];
    double v26 = v25;

    if (v23 < v26)
    {
      uint64_t v27 = 17;
LABEL_26:
      uint64_t v39 = 0;
      *a3 = v27;
      goto LABEL_29;
    }
    unsigned __int8 v29 = [v5 sharedDataUsed];
    [v29 doubleValue];
    if (v30 == 0.0)
    {
      double v34 = 1.0;
    }
    else
    {
      BOOL v31 = [v5 thisDeviceDataUsed];
      [v31 doubleValue];
      double v33 = v32;

      double v34 = 1.0;
      if (v33 == 0.0)
      {
LABEL_23:
        double v15 = v15 * v34;
        goto LABEL_24;
      }
      unsigned __int8 v29 = [v5 thisDeviceDataUsed];
      [v29 doubleValue];
      double v36 = v35;
      uint64_t v37 = [v5 sharedDataUsed];
      [v37 doubleValue];
      double v34 = v36 / v38;
    }
    goto LABEL_23;
  }
LABEL_24:
  if (v15 == 0.0)
  {
    uint64_t v27 = 18;
    goto LABEL_26;
  }
  [v5 units];
  CTCarrierSpaceConvertDataUnits();
  uint64_t v28 = +[NSNumber numberWithUnsignedInteger:(unint64_t)v40];
LABEL_28:
  uint64_t v39 = (void *)v28;
LABEL_29:

  return v39;
}

void sub_100B347B8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL sub_100B3481C(void *a1)
{
  id v1 = a1;
  char v2 = v1;
  if (v1)
  {
    sub_100058DB0(&__str, (char *)[v1 UTF8String]);
    double v3 = std::stod(&__str, 0);
    if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__str.__r_.__value_.__l.__data_);
    }
    BOOL v4 = v3 >= 0.0;
  }
  else
  {
    BOOL v4 = 0;
  }

  return v4;
}

void sub_100B348DC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100B348EC(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_100B349B8(void *a1)
{
  __cxa_begin_catch(a1);
  dispatch_barrier_async_f(v1[3], v1, (dispatch_function_t)sub_100B34A90);
  __cxa_rethrow();
}

void sub_100B349E0(_Unwind_Exception *a1)
{
}

void sub_100B349F8(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100B34A30(uint64_t a1)
{
}

uint64_t sub_100B34A4C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_100B34A90(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void sub_100B34AC0()
{
}

__n128 sub_100B34AD4(uint64_t a1)
{
  char v2 = (char *)operator new(0x28uLL);
  *(void *)char v2 = off_101A3D938;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100B34B28(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A3D938;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100B34B60(void *a1, xpc_object_t *a2)
{
  double v3 = (_DWORD *)a1[1];
  double v19 = 0;
  uint64_t v20 = 0;
  BOOL v18 = &v19;
  sub_100026EC0((uint64_t)&v18, a2);
  uint64_t v4 = *v3;
  id v5 = v19;
  BOOL v16 = v18;
  v17[0] = v19;
  v17[1] = v20;
  if (v20)
  {
    uint64_t v19[2] = v17;
    BOOL v18 = &v19;
    double v19 = 0;
    uint64_t v20 = 0;
    if (!v5) {
      goto LABEL_19;
    }
  }
  else
  {
    BOOL v16 = v17;
    if (!v19) {
      goto LABEL_19;
    }
  }
  uint64_t v6 = v17;
  id v7 = v5;
  do
  {
    unsigned int v8 = v7;
    BOOL v9 = v6;
    int v10 = *((_DWORD *)v7 + 7);
    if (v10 >= 1) {
      uint64_t v6 = v7;
    }
    else {
      ++v7;
    }
    id v7 = (void *)*v7;
  }
  while (v7);
  if (v6 != v17)
  {
    double v11 = (int *)(v10 >= 1 ? v8 : v9);
    if (v11[7] <= 1)
    {
      if (v10 >= 1) {
        uint64_t v12 = v8;
      }
      else {
        uint64_t v12 = v9;
      }
      _DWORD *v3 = *((_DWORD *)v12 + 8);
    }
  }
LABEL_19:
  sub_1000346F8((uint64_t)&v16, v5);
  if (v4 != *v3)
  {
    int v13 = (void (*)(void *, uint64_t))a1[3];
    uint64_t v14 = a1[4];
    double v15 = (void *)(a1[2] + (v14 >> 1));
    if (v14) {
      int v13 = *(void (**)(void *, uint64_t))(*v15 + v13);
    }
    v13(v15, v4);
  }
  sub_1000346F8((uint64_t)&v18, v19);
}

void sub_100B34CAC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, void *a13)
{
}

uint64_t sub_100B34CC8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100B34D08()
{
}

void sub_100B34D18()
{
}

__n128 sub_100B34D2C(uint64_t a1)
{
  char v2 = (char *)operator new(0x28uLL);
  *(void *)char v2 = off_101A3D9B8;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100B34D80(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A3D9B8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100B34DB8(void *a1, xpc *this, uint64_t a3)
{
  uint64_t v4 = (_DWORD *)a1[1];
  uint64_t v5 = *v4;
  *uint64_t v4 = xpc::dyn_cast_or_default(this, 0, a3);
  uint64_t v6 = (uint64_t (*)(void *, uint64_t))a1[3];
  uint64_t v7 = a1[4];
  unsigned int v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    uint64_t v6 = *(uint64_t (**)(void *, uint64_t))(*v8 + v6);
  }

  return v6(v8, v5);
}

uint64_t sub_100B34E50(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100B34E90()
{
}

void sub_100B34E9C(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A3DA38;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100B34EBC(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A3DA38;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_100B34F10(uint64_t a1)
{
}

void sub_100B34F1C(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A3DA88;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100B34F3C(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A3DA88;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100B34F98(uint64_t a1, void *a2, int a3, uint64_t a4)
{
  unsigned int v8 = "roam.?";
  if (a3 == 2) {
    unsigned int v8 = "roam.awd.2";
  }
  if (a3 == 1) {
    BOOL v9 = "roam.awd.1";
  }
  else {
    BOOL v9 = v8;
  }
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v12, kCtLoggingSystemName, v9);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v13, &v12);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 8), (const ctu::OsLogLogger *)v13);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v13);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v12);
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  *(void *)a1 = off_101A3DAD8;
  *(void *)(a1 + 32) = *a2;
  uint64_t v10 = a2[1];
  *(void *)(a1 + 40) = v10;
  if (v10) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v10 + 8), 1uLL, memory_order_relaxed);
  }
  *(_DWORD *)(a1 + 48) = a3;
  *(void *)(a1 + 56) = a4;
  *(_WORD *)(a1 + 64) = 0;
  return a1;
}

void sub_100B35088(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, void);
  uint64_t v5 = va_arg(va1, void);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)va1);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)va);
  _Unwind_Resume(a1);
}

void *sub_100B350AC(void *a1)
{
  *a1 = off_101A3DAD8;
  char v2 = (std::__shared_weak_count *)a1[5];
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)a1[3];
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 1));
  return a1;
}

void sub_100B35114(uint64_t a1)
{
  char v2 = *(NSObject **)(a1 + 8);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = *(void *)(a1 + 56);
    int v4 = 136315138;
    uint64_t v5 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Metric submitted for %s", (uint8_t *)&v4, 0xCu);
  }
  *(unsigned char *)(a1 + 65) = 0;
}

uint64_t sub_100B351B8(uint64_t a1)
{
  char v2 = *(NSObject **)(a1 + 8);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = *(const char **)(a1 + 56);
    int v7 = 136315138;
    unsigned int v8 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I %s dump state", (uint8_t *)&v7, 0xCu);
    char v2 = *(NSObject **)(a1 + 8);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    int v4 = "true";
    if (*(unsigned char *)(a1 + 64)) {
      uint64_t v5 = "true";
    }
    else {
      uint64_t v5 = "false";
    }
    if (!*(unsigned char *)(a1 + 65)) {
      int v4 = "false";
    }
    int v7 = 136315394;
    unsigned int v8 = v5;
    __int16 v9 = 2080;
    uint64_t v10 = v4;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Valid state: %s, Needs submission: %s", (uint8_t *)&v7, 0x16u);
  }
  return (*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
}

void sub_100B352FC(PB::Base *this)
{
  *(void *)this = &off_101A3DB58;
  uint64_t v4 = *((void *)this + 5);
  char v2 = (void *)((char *)this + 40);
  uint64_t v3 = v4;
  void *v2 = 0;
  if (v4) {
    sub_100206334((uint64_t)v2, v3);
  }
  uint64_t v5 = *((void *)this + 4);
  *((void *)this + 4) = 0;
  if (v5) {
    sub_100206334((uint64_t)this + 32, v5);
  }
  uint64_t v6 = *((void *)this + 3);
  *((void *)this + 3) = 0;
  if (v6) {
    sub_100206334((uint64_t)this + 24, v6);
  }
  uint64_t v7 = *((void *)this + 2);
  *((void *)this + 2) = 0;
  if (v7) {
    sub_100206334((uint64_t)this + 16, v7);
  }
  uint64_t v8 = *((void *)this + 1);
  *((void *)this + 1) = 0;
  if (v8) {
    sub_100206334((uint64_t)this + 8, v8);
  }

  PB::Base::~Base(this);
}

void sub_100B353B0(PB::Base *a1)
{
  sub_100B352FC(a1);

  operator delete();
}

uint64_t sub_100B353E8(uint64_t result, void *a2)
{
  *(void *)__n128 result = &off_101A3DB58;
  *(_OWORD *)(result + 8) = 0u;
  *(_OWORD *)(result + 24) = 0u;
  *(void *)(result + 40) = 0;
  if (a2[3]) {
    operator new();
  }
  if (a2[4]) {
    operator new();
  }
  if (a2[5]) {
    operator new();
  }
  if (a2[1]) {
    operator new();
  }
  if (a2[2]) {
    operator new();
  }
  return result;
}

uint64_t sub_100B35650(void *a1, PB::TextFormatter *this, char *a3)
{
  PB::TextFormatter::beginObject(this, a3);
  if (a1[1]) {
    PB::TextFormatter::format();
  }
  if (a1[2]) {
    PB::TextFormatter::format();
  }
  if (a1[3]) {
    PB::TextFormatter::format();
  }
  if (a1[4]) {
    PB::TextFormatter::format();
  }
  if (a1[5]) {
    PB::TextFormatter::format();
  }

  return PB::TextFormatter::endObject(this);
}

BOOL sub_100B3570C(int a1, PB::Reader *this)
{
  unint64_t v2 = *((void *)this + 1);
  unint64_t v3 = *((void *)this + 2);
  int v4 = *((unsigned __int8 *)this + 24);
  if (v2 < v3 && v4 == 0)
  {
    while (1)
    {
      uint64_t v7 = *(void *)this;
      if (v2 > 0xFFFFFFFFFFFFFFF5 || v2 + 10 > v3) {
        break;
      }
      char v8 = 0;
      unsigned int v9 = 0;
      unint64_t v10 = 0;
      while (1)
      {
        unint64_t v11 = v2 + 1;
        *((void *)this + 1) = v2 + 1;
        char v12 = *(unsigned char *)(v7 + v2);
        v10 |= (unint64_t)(v12 & 0x7F) << v8;
        if ((v12 & 0x80) == 0) {
          break;
        }
        v8 += 7;
        unint64_t v2 = v11;
        BOOL v13 = v9++ > 8;
        if (v13) {
          goto LABEL_19;
        }
      }
LABEL_22:
      unsigned __int8 v18 = v10 & 7;
      if ((v10 & 7) == 4)
      {
        int v4 = 0;
        return v4 == 0;
      }
      unint64_t v19 = v10 >> 3;
      switch((v10 >> 3))
      {
        case 1u:
          operator new();
        case 2u:
          operator new();
        case 3u:
          operator new();
        case 4u:
          operator new();
        case 5u:
          operator new();
        default:
          break;
      }
LABEL_20:
      if ((PB::Reader::skip(this, v19, v18, 0) & 1) == 0) {
        return 0;
      }
      unint64_t v2 = *((void *)this + 1);
      unint64_t v3 = *((void *)this + 2);
      int v4 = *((unsigned __int8 *)this + 24);
      if (v2 >= v3 || *((unsigned char *)this + 24)) {
        return v4 == 0;
      }
    }
    char v14 = 0;
    unsigned int v15 = 0;
    unint64_t v10 = 0;
    if (v2 > v3) {
      unint64_t v3 = v2;
    }
    while (v3 != v2)
    {
      unint64_t v16 = v2 + 1;
      char v17 = *(unsigned char *)(v7 + v2);
      *((void *)this + 1) = v16;
      v10 |= (unint64_t)(v17 & 0x7F) << v14;
      if ((v17 & 0x80) == 0) {
        goto LABEL_22;
      }
      v14 += 7;
      unint64_t v2 = v16;
      BOOL v13 = v15++ > 8;
      if (v13)
      {
LABEL_19:
        unsigned __int8 v18 = 0;
        LODWORD(v19) = 0;
        goto LABEL_20;
      }
    }
    int v4 = 1;
    *((unsigned char *)this + 24) = 1;
  }
  return v4 == 0;
}

uint64_t sub_100B35A68(uint64_t result)
{
  id v1 = (void *)result;
  if (*(void *)(result + 24)) {
    __n128 result = PB::Writer::write();
  }
  if (v1[4]) {
    __n128 result = PB::Writer::write();
  }
  if (v1[5]) {
    __n128 result = PB::Writer::write();
  }
  if (v1[1]) {
    __n128 result = PB::Writer::write();
  }
  if (v1[2])
  {
    return PB::Writer::write();
  }
  return result;
}

void sub_100B35B08(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(a2, *(Registry **)(a1 + 16));
  int v4 = ServiceMap;
  if ((v5 & 0x8000000000000000) != 0)
  {
    uint64_t v6 = (unsigned __int8 *)(v5 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v7 = 5381;
    do
    {
      unint64_t v5 = v7;
      unsigned int v8 = *v6++;
      uint64_t v7 = (33 * v7) ^ v8;
    }
    while (v8);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v20 = v5;
  unsigned int v9 = sub_10004D37C(&v4[1].__m_.__sig, &v20);
  if (v9)
  {
    uint64_t v11 = v9[3];
    unint64_t v10 = (std::__shared_weak_count *)v9[4];
    if (v10)
    {
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v4);
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v10);
      char v12 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v11 = 0;
  }
  std::mutex::unlock(v4);
  unint64_t v10 = 0;
  char v12 = 1;
LABEL_9:
  (*(void (**)(uint64_t **__return_ptr, uint64_t))(*(void *)v11 + 40))(&v17, v11);
  char v14 = *(char **)(a1 + 40);
  BOOL v13 = (void *)(a1 + 40);
  sub_10005CD2C((uint64_t)(v13 - 1), v14);
  uint64_t v15 = v18;
  *(v13 - 1) = v17;
  *BOOL v13 = v15;
  uint64_t v16 = v19;
  v13[1] = v19;
  if (v16)
  {
    *(void *)(v15 + 16) = v13;
    char v17 = &v18;
    uint64_t v18 = 0;
    uint64_t v19 = 0;
    uint64_t v15 = 0;
  }
  else
  {
    *(v13 - 1) = v13;
  }
  sub_10005CD2C((uint64_t)&v17, (char *)v15);
  if ((v12 & 1) == 0) {
    sub_10004D2C8(v10);
  }
}

void sub_100B35C5C(_Unwind_Exception *exception_object)
{
  if ((v2 & 1) == 0) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100B35C78(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t *a4@<X8>)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(a4, *(Registry **)(a1 + 16));
  uint64_t v7 = ServiceMap;
  if ((v8 & 0x8000000000000000) != 0)
  {
    unsigned int v9 = (unsigned __int8 *)(v8 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v10 = 5381;
    do
    {
      unint64_t v8 = v10;
      unsigned int v11 = *v9++;
      uint64_t v10 = (33 * v10) ^ v11;
    }
    while (v11);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v16 = v8;
  char v12 = sub_10004D37C(&v7[1].__m_.__sig, &v16);
  if (v12)
  {
    uint64_t v14 = v12[3];
    BOOL v13 = (std::__shared_weak_count *)v12[4];
    if (v13)
    {
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v7);
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v13);
      char v15 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v14 = 0;
  }
  std::mutex::unlock(v7);
  BOOL v13 = 0;
  char v15 = 1;
LABEL_9:
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v14 + 24))(v14, a2, a3);
  if ((v15 & 1) == 0) {
    sub_10004D2C8(v13);
  }
}

void sub_100B35D90(_Unwind_Exception *exception_object)
{
  if ((v1 & 1) == 0) {
    sub_10004D2C8(v2);
  }
  _Unwind_Resume(exception_object);
}

void sub_100B35DAC(char *a1@<X8>)
{
  sub_100058DB0(v4, "CELLULAR_DATA_IS_TURNED_OFF_FOR_APP_NAME");
  sub_100058DB0(__p, "YOU_CAN_TURN_ON_CELLULAR_DATA_FOR_THIS_APP_IN_SETTINGS");
  sub_100461830(a1, (long long *)v4, (long long *)__p);
  if (v3 < 0) {
    operator delete(__p[0]);
  }
  if (v5 < 0) {
    operator delete(v4[0]);
  }
}

void sub_100B35E24(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  _Unwind_Resume(exception_object);
}

void sub_100B35E5C(uint64_t a1)
{
  sub_100461404(a1);

  operator delete();
}

uint64_t sub_100B35E94(uint64_t a1, void *a2, NSObject **a3, uint64_t a4, long long *a5)
{
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v17, kCtLoggingSystemName, "enh.thpt.slt.ctl");
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  unsigned int v9 = *a3;
  *(void *)(a1 + 24) = *a3;
  if (v9) {
    dispatch_retain(v9);
  }
  *(void *)(a1 + 32) = 0;
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v18, &v17);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 40), (const ctu::OsLogLogger *)v18);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v18);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v17);
  *(void *)a1 = off_101A3DC00;
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 48) = &off_101A3DC48;
  *(unsigned char *)(a1 + 72) = 0;
  *(void *)(a1 + 80) = *a2;
  uint64_t v10 = a2[1];
  *(void *)(a1 + 88) = v10;
  if (v10) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v10 + 8), 1uLL, memory_order_relaxed);
  }
  if (*((char *)a5 + 23) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 96), *(void **)a5, *((void *)a5 + 1));
  }
  else
  {
    long long v11 = *a5;
    *(void *)(a1 + 112) = *((void *)a5 + 2);
    *(_OWORD *)(a1 + 96) = v11;
  }
  *(_OWORD *)(a1 + 120) = 0u;
  *(void *)(a1 + 200) = 0;
  *(_OWORD *)(a1 + 168) = 0u;
  *(_OWORD *)(a1 + 184) = 0u;
  *(_OWORD *)(a1 + 136) = 0u;
  *(_OWORD *)(a1 + 152) = 0u;
  *(unsigned char *)(a1 + 208) = 1;
  sub_100058DB0(&__p, "EnhancedWifiQosSlotController");
  char v12 = *(NSObject **)(a1 + 24);
  uint64_t v14 = v12;
  if (v12) {
    dispatch_retain(v12);
  }
  ctu::RestModule::RestModule();
  if (v14) {
    dispatch_release(v14);
  }
  if (v16 < 0) {
    operator delete(__p);
  }
  return a1;
}

void sub_100B36054(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, dispatch_object_t object, dispatch_object_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17, uint64_t a18, char a19)
{
  double v23 = *(std::__shared_weak_count **)(v19 + 88);
  if (v23) {
    sub_10004D2C8(v23);
  }
  char v24 = *(std::__shared_weak_count **)(v19 + 64);
  if (v24) {
    sub_10004D2C8(v24);
  }
  ctu::OsLogLogger::~OsLogLogger(v21);
  sub_100087E88(v20);
  _Unwind_Resume(a1);
}

uint64_t sub_100B36158(uint64_t a1)
{
  *(void *)a1 = off_101A3DC00;
  *(void *)(a1 + 48) = &off_101A3DC48;
  char v2 = *(std::__shared_weak_count **)(a1 + 224);
  if (v2) {
    sub_10004D2C8(v2);
  }
  if (*(char *)(a1 + 207) < 0) {
    operator delete(*(void **)(a1 + 184));
  }
  if (*(char *)(a1 + 183) < 0) {
    operator delete(*(void **)(a1 + 160));
  }
  uint64_t v3 = *(void *)(a1 + 144);
  *(void *)(a1 + 144) = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  if (*(char *)(a1 + 143) < 0) {
    operator delete(*(void **)(a1 + 120));
  }
  if (*(char *)(a1 + 119) < 0) {
    operator delete(*(void **)(a1 + 96));
  }
  int v4 = *(std::__shared_weak_count **)(a1 + 88);
  if (v4) {
    sub_10004D2C8(v4);
  }
  char v5 = *(std::__shared_weak_count **)(a1 + 64);
  if (v5) {
    sub_10004D2C8(v5);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 40));
  sub_100087E88((void *)(a1 + 8));
  return a1;
}

uint64_t sub_100B36264(uint64_t a1)
{
  return sub_100B36158(a1 - 48);
}

void sub_100B3626C(uint64_t a1)
{
  sub_100B36158(a1);

  operator delete();
}

void sub_100B362A4(uint64_t a1)
{
  sub_100B36158(a1 - 48);

  operator delete();
}

void sub_100B362E0(uint64_t a1)
{
  char v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100B363C0(uint64_t a1)
{
}

void sub_100B363C8(uint64_t a1, unsigned int a2)
{
  xpc_object_t v16 = 0;
  xpc_object_t v4 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v5 = v4;
  if (v4)
  {
    xpc_object_t v16 = v4;
  }
  else
  {
    xpc_object_t v5 = xpc_null_create();
    xpc_object_t v16 = v5;
    if (!v5)
    {
      xpc_object_t v6 = xpc_null_create();
      xpc_object_t v5 = 0;
      goto LABEL_8;
    }
  }
  if (xpc_get_type(v5) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v5);
    goto LABEL_9;
  }
  xpc_object_t v6 = xpc_null_create();
LABEL_8:
  xpc_object_t v16 = v6;
LABEL_9:
  xpc_release(v5);
  xpc_object_t object = xpc_BOOL_create(0);
  if (!object) {
    xpc_object_t object = xpc_null_create();
  }
  char v12 = &v16;
  BOOL v13 = "is_successful";
  sub_100035E70((uint64_t)&v12, &object, &v15);
  xpc_release(v15);
  xpc_object_t v15 = 0;
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_object_t v10 = xpc_int64_create(a2);
  if (!v10) {
    xpc_object_t v10 = xpc_null_create();
  }
  char v12 = &v16;
  BOOL v13 = "failure_reason";
  sub_100035E70((uint64_t)&v12, &v10, &v11);
  xpc_release(v11);
  xpc_object_t v11 = 0;
  xpc_release(v10);
  xpc_object_t v10 = 0;
  uint64_t v7 = (const char *)(a1 + 160);
  if (*(char *)(a1 + 183) < 0) {
    uint64_t v7 = *(const char **)v7;
  }
  xpc_object_t v8 = xpc_string_create(v7);
  if (!v8) {
    xpc_object_t v8 = xpc_null_create();
  }
  char v12 = &v16;
  BOOL v13 = "request_reason";
  sub_100035E70((uint64_t)&v12, &v8, &v9);
  xpc_release(v9);
  xpc_object_t v9 = 0;
  xpc_release(v8);
  xpc_object_t v8 = 0;
  sub_100B37E4C(a1, (xpc::object *)&v16);
  xpc_release(v16);
}

void sub_100B36594(_Unwind_Exception *a1)
{
  xpc_release(*(xpc_object_t *)(v1 - 40));
  _Unwind_Resume(a1);
}

void sub_100B365DC(uint64_t a1, int a2)
{
  xpc_object_t v4 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    xpc_object_t v5 = "True";
    if (a2) {
      xpc_object_t v6 = "True";
    }
    else {
      xpc_object_t v6 = "False";
    }
    if (!*(unsigned char *)(a1 + 72)) {
      xpc_object_t v5 = "False";
    }
    uint64_t v7 = (void *)(a1 + 96);
    if (*(char *)(a1 + 119) < 0) {
      uint64_t v7 = (void *)*v7;
    }
    *(_DWORD *)long long __p = 136315650;
    *(void *)&__p[4] = v6;
    __int16 v9 = 2080;
    xpc_object_t v10 = v5;
    __int16 v11 = 2080;
    char v12 = v7;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I handlePvdEnhancedThroughputFlagUpdated %s prev(%s), iccid=%s", __p, 0x20u);
  }
  if (*(unsigned __int8 *)(a1 + 72) != a2)
  {
    *(unsigned char *)(a1 + 72) = a2;
    if (a2)
    {
      sub_100058DB0(__p, "pvdEnhancedThroughputFlag");
      sub_100B36730(a1, (std::string::size_type)__p);
      if (SHIBYTE(v11) < 0) {
        operator delete(*(void **)__p);
      }
    }
  }
}

void sub_100B3670C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100B36730(uint64_t a1, std::string::size_type a2)
{
  void (***v41)(void **__return_ptr, void, void **);
  char v42;
  NSObject *v43;
  std::string *v44;
  std::string *data;
  std::string *v46;
  void *v47;
  void *v48;
  char *v49;
  void *v50;
  char *v51;
  void *v52;
  void *v53;
  uint8_t *v54;
  uint64_t v55;
  void *v56;
  void *v57;
  void *v58;
  xpc_object_t v59;
  xpc_object_t v60;
  std::string::size_type v61;
  std::string::size_type v62;
  void *p_p;
  void *v64;
  void *v65;
  std::string v66;
  std::string v67;
  std::string __str[2];
  std::string v69[2];
  uint64_t v70;
  std::string v71;
  std::string v72;
  void *__p;
  std::__shared_weak_count *v74;
  uint64_t v75;
  ifaddrs *v76;
  void *__dst[2];
  uint64_t *v78;
  unsigned char v79[32];
  long long v80;
  long long v81;
  long long v82;
  void *v83[2];
  long long v84;
  long long v85;
  long long v86;
  long long v87;
  long long v88;
  long long v89;
  long long v90;
  long long v91;
  long long v92;
  long long v93;
  long long v94;
  uint64_t v95;
  char v96;
  uint8_t v97[24];
  std::string v98;
  std::string buf[2];
  void *v100[4];
  void *v101[2];
  long long v102;
  long long v103;
  long long v104;
  long long v105;
  long long v106;
  long long v107;
  long long v108;
  long long v109;
  long long v110;
  long long v111;
  long long v112;
  uint64_t v113;

  xpc_object_t v4 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = *(void *)(a1 + 56);
    if (v5 && ((*(uint64_t (**)(uint64_t))(*(void *)v5 + 24))(v5) & 1) != 0) {
      xpc_object_t v6 = "True";
    }
    else {
      xpc_object_t v6 = "False";
    }
    uint64_t v7 = "False";
    if (*(unsigned char *)(a1 + 72)) {
      uint64_t v7 = "True";
    }
    xpc_object_t v8 = (void *)(a1 + 120);
    if (*(char *)(a1 + 143) < 0) {
      xpc_object_t v8 = (void *)*v8;
    }
    if (*(char *)(a2 + 23) >= 0) {
      std::string::size_type v9 = a2;
    }
    else {
      std::string::size_type v9 = *(void *)a2;
    }
    LODWORD(buf[0].__r_.__value_.__l.__data_) = 136315906;
    *(std::string::size_type *)((char *)buf[0].__r_.__value_.__r.__words + 4) = (std::string::size_type)v6;
    WORD2(buf[0].__r_.__value_.__r.__words[1]) = 2080;
    *(std::string::size_type *)((char *)&buf[0].__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v7;
    HIWORD(buf[0].__r_.__value_.__r.__words[2]) = 2080;
    buf[1].__r_.__value_.__r.__words[0] = (std::string::size_type)v8;
    LOWORD(buf[1].__r_.__value_.__r.__words[1]) = 2080;
    *(std::string::size_type *)((char *)&buf[1].__r_.__value_.__r.__words[1] + 2) = v9;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I maybeEnableService hasToken %s, flag %s, ipv6(%s) trigger %s", (uint8_t *)buf, 0x2Au);
  }
  uint64_t result = *(void *)(a1 + 56);
  if (!result) {
    return result;
  }
  uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 24))(result);
  if (!result || !*(unsigned char *)(a1 + 72)) {
    return result;
  }
  if (*(char *)(a1 + 143) < 0)
  {
    if (!*(void *)(a1 + 128)) {
      return result;
    }
  }
  else if (!*(unsigned char *)(a1 + 143))
  {
    return result;
  }
  long long v70 = 0;
  memset(v69, 0, sizeof(v69));
  memset(__str, 0, sizeof(__str));
  (*(void (**)(std::string *__return_ptr))(**(void **)(a1 + 56) + 16))(__str);
  if ((_BYTE)v70)
  {
    std::string::size_type size = HIBYTE(v69[0].__r_.__value_.__r.__words[2]);
    if ((v69[0].__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      std::string::size_type size = v69[0].__r_.__value_.__l.__size_;
    }
    if (size != 19
      || ((v69[0].__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
        ? (char v12 = v69)
        : (char v12 = (std::string *)v69[0].__r_.__value_.__r.__words[0]),
          (std::string::size_type v13 = v12->__r_.__value_.__r.__words[0],
           std::string::size_type v14 = v12->__r_.__value_.__l.__size_,
           uint64_t v15 = *(std::string::size_type *)((char *)&v12->__r_.__value_.__r.__words[1] + 3),
           v13 == 0x6465636E61686E65)
        ? (BOOL v16 = v14 == 0x6867756F7268742DLL)
        : (BOOL v16 = 0),
          v16 ? (BOOL v17 = v15 == 0x7475706867756F72) : (BOOL v17 = 0),
          !v17))
    {
      uint64_t v18 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
      {
        LOWORD(buf[0].__r_.__value_.__l.__data_) = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "ERROR: token is not EnhancedThroughput", (uint8_t *)buf, 2u);
      }
      return sub_1005ADA04((uint64_t)__str);
    }
  }
  int v75 = 0;
  int64_t v76 = 0;
  memset(&v67, 0, sizeof(v67));
  long long __p = 0;
  uint64_t v74 = 0;
  sub_100058DB0(&__p, "en0");
  if (getifaddrs(&v76))
  {
    uint64_t v19 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
    {
      p_p = &__p;
      if (v75 < 0) {
        p_p = __p;
      }
      LODWORD(buf[0].__r_.__value_.__l.__data_) = 136315138;
      *(std::string::size_type *)((char *)buf[0].__r_.__value_.__r.__words + 4) = (std::string::size_type)p_p;
      _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Unable to get interface addresses for: %s", (uint8_t *)buf, 0xCu);
    }
    goto LABEL_50;
  }
  unint64_t v20 = v76;
  if (!v76) {
    goto LABEL_49;
  }
  size_t v21 = HIBYTE(v75);
  double v23 = (void **)__p;
  double v22 = v74;
  while (1)
  {
    size_t v24 = strlen(v20->ifa_name);
    double v25 = (std::__shared_weak_count *)v24;
    if ((v21 & 0x80) == 0) {
      break;
    }
    double v26 = v23;
    size_t v27 = (size_t)v22;
    if (v22 == v25) {
      goto LABEL_46;
    }
LABEL_48:
    unint64_t v20 = v20->ifa_next;
    if (!v20) {
      goto LABEL_49;
    }
  }
  if (v24 != v21) {
    goto LABEL_48;
  }
  double v26 = &__p;
  size_t v27 = v21;
LABEL_46:
  if (strncmp((const char *)v26, v20->ifa_name, v27)) {
    goto LABEL_48;
  }
  ifa_addr = v20->ifa_addr;
  if (ifa_addr->sa_data[4] != 6) {
    goto LABEL_48;
  }
  uint64_t v51 = ether_ntoa((const ether_addr *)&ifa_addr->sa_data[ifa_addr->sa_data[3] + 6]);
  sub_100058DB0(&v71, v51);
  xpc_object_t v113 = 0;
  xpc_object_t v111 = 0u;
  xpc_object_t v112 = 0u;
  xpc_object_t v109 = 0u;
  xpc_object_t v110 = 0u;
  xpc_object_t v107 = 0u;
  xpc_object_t v108 = 0u;
  xpc_object_t v105 = 0u;
  xpc_object_t v106 = 0u;
  xpc_object_t v103 = 0u;
  xpc_object_t v104 = 0u;
  *(_OWORD *)xpc_object_t v101 = 0u;
  xpc_object_t v102 = 0u;
  memset(v100, 0, sizeof(v100));
  memset(buf, 0, sizeof(buf));
  sub_10054D380((void (__cdecl ***)(std::basic_stringstream<char> *__hidden))buf, &v71, 24);
  memset(v97, 0, sizeof(v97));
  xpc_object_t v95 = 0;
  xpc_object_t v93 = 0u;
  xpc_object_t v94 = 0u;
  xpc_object_t v91 = 0u;
  xpc_object_t v92 = 0u;
  xpc_object_t v89 = 0u;
  long long v90 = 0u;
  xpc_object_t v87 = 0u;
  xpc_object_t v88 = 0u;
  xpc_object_t v85 = 0u;
  uint64_t v86 = 0u;
  *(_OWORD *)uint64_t v83 = 0u;
  uint64_t v84 = 0u;
  xpc_object_t v81 = 0u;
  xpc_object_t v82 = 0u;
  uint64_t v80 = 0u;
  memset(v79, 0, sizeof(v79));
  sub_10004BD84((uint64_t)v79);
  while (1)
  {
    double v52 = (void *)sub_10013EA34((uint64_t)buf);
    if ((*((unsigned char *)v52 + *(void *)(*v52 - 24) + 32) & 5) != 0) {
      break;
    }
    *(void *)((char *)&v80 + *(void *)(*(void *)&v79[16] - 24) + 8) = 2;
    LOBYTE(v65) = 48;
    uint64_t v53 = sub_1004DC904(&v79[16], (char *)&v65);
    if ((v97[23] & 0x80u) == 0) {
      char v54 = v97;
    }
    else {
      char v54 = *(uint8_t **)v97;
    }
    if ((v97[23] & 0x80u) == 0) {
      unint64_t v55 = v97[23];
    }
    else {
      unint64_t v55 = *(void *)&v97[8];
    }
    uint64_t v56 = sub_10004B96C(v53, (uint64_t)v54, v55);
    sub_10004B96C(v56, (uint64_t)":", 1);
  }
  sub_10004BC98((uint64_t)&v79[24], &v65);
  sub_10004BC98((uint64_t)&v79[24], __dst);
  int v57 = (void *)HIBYTE(v78);
  if (SHIBYTE(v78) < 0) {
    int v57 = __dst[1];
  }
  std::string::basic_string(&v72, (const std::string *)&v65, 0, (std::string::size_type)v57 - 1, (std::allocator<char> *)&v96);
  if (SHIBYTE(v78) < 0) {
    operator delete(__dst[0]);
  }
  if (v66.__r_.__value_.__s.__data_[15] < 0) {
    operator delete(v65);
  }
  unint64_t v61 = (std::string::size_type)v59;
  *(void *)&v79[16] = v59;
  if (SHIBYTE(v84) < 0) {
    operator delete(v83[1]);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  std::ios::~ios();
  if ((char)v97[23] < 0) {
    operator delete(*(void **)v97);
  }
  buf[0].__r_.__value_.__r.__words[0] = (std::string::size_type)v58;
  *(std::string::size_type *)((char *)buf[0].__r_.__value_.__r.__words + *(v58 - 3)) = (std::string::size_type)v60;
  buf[0].__r_.__value_.__r.__words[2] = v61;
  if (SHIBYTE(v102) < 0) {
    operator delete(v101[1]);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  std::ios::~ios();
  id v67 = v72;
  *((unsigned char *)&v72.__r_.__value_.__s + 23) = 0;
  v72.__r_.__value_.__s.__data_[0] = 0;
  if (SHIBYTE(v71.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v71.__r_.__value_.__l.__data_);
  }
  id v62 = HIBYTE(v67.__r_.__value_.__r.__words[2]);
  if ((v67.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
    id v62 = v67.__r_.__value_.__l.__size_;
  }
  if (!v62)
  {
LABEL_49:
    unsigned __int8 v29 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
    {
      long long v64 = &__p;
      if (v75 < 0) {
        long long v64 = __p;
      }
      LODWORD(buf[0].__r_.__value_.__l.__data_) = 136315138;
      *(std::string::size_type *)((char *)buf[0].__r_.__value_.__r.__words + 4) = (std::string::size_type)v64;
      _os_log_error_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_ERROR, "Couldn't find mac address for interface: %s", (uint8_t *)buf, 0xCu);
    }
  }
LABEL_50:
  if (v76) {
    freeifaddrs(v76);
  }
  if (SHIBYTE(v75) < 0) {
    operator delete(__p);
  }
  std::string::size_type v30 = HIBYTE(v67.__r_.__value_.__r.__words[2]);
  if ((v67.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
    std::string::size_type v30 = v67.__r_.__value_.__l.__size_;
  }
  if (v30)
  {
    __dst[0] = 0;
    __dst[1] = 0;
    unint64_t v78 = 0;
    if (*(char *)(a1 + 119) < 0)
    {
      sub_10004FC84(__dst, *(void **)(a1 + 96), *(void *)(a1 + 104));
    }
    else
    {
      *(_OWORD *)long long __dst = *(_OWORD *)(a1 + 96);
      BOOL v31 = *(uint64_t **)(a1 + 112);
      unint64_t v78 = v31;
    }
    long long __p = 0;
    uint64_t v74 = 0;
    ServiceMap = (std::mutex *)Registry::getServiceMap(v31, *(Registry **)(a1 + 80));
    double v34 = ServiceMap;
    if ((v35 & 0x8000000000000000) != 0)
    {
      double v36 = (unsigned __int8 *)(v35 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v37 = 5381;
      do
      {
        std::string::size_type v35 = v37;
        unsigned int v38 = *v36++;
        uint64_t v37 = (33 * v37) ^ v38;
      }
      while (v38);
    }
    std::mutex::lock(ServiceMap);
    buf[0].__r_.__value_.__r.__words[0] = v35;
    uint64_t v39 = sub_10004D37C(&v34[1].__m_.__sig, (unint64_t *)buf);
    if (v39)
    {
      unsigned __int8 v41 = (void (***)(void **__return_ptr, void, void **))v39[3];
      double v40 = (std::__shared_weak_count *)v39[4];
      if (v40)
      {
        atomic_fetch_add_explicit(&v40->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v34);
        atomic_fetch_add_explicit(&v40->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v40);
        id v42 = 0;
        goto LABEL_70;
      }
    }
    else
    {
      unsigned __int8 v41 = 0;
    }
    std::mutex::unlock(v34);
    double v40 = 0;
    id v42 = 1;
LABEL_70:
    (**v41)(&__p, v41, __dst);
    if ((v42 & 1) == 0) {
      sub_10004D2C8(v40);
    }
    memset(buf, 0, sizeof(buf));
    v101[0] = 0;
    memset(v100, 0, sizeof(v100));
    HIDWORD(buf[0].__r_.__value_.__r.__words[0]) = 15;
    buf[0].__r_.__value_.__s.__data_[8] = 1;
    HIDWORD(buf[0].__r_.__value_.__r.__words[1]) = 1;
    buf[0].__r_.__value_.__s.__data_[16] = 1;
    if (SHIBYTE(__str[0].__r_.__value_.__r.__words[2]) < 0) {
      sub_10004FC84(&buf[1], __str[0].__r_.__value_.__l.__data_, __str[0].__r_.__value_.__l.__size_);
    }
    else {
      buf[1] = __str[0];
    }
    LOBYTE(v100[0]) = 1;
    if (SHIBYTE(__str[1].__r_.__value_.__r.__words[2]) < 0) {
      sub_10004FC84(&v100[1], __str[1].__r_.__value_.__l.__data_, __str[1].__r_.__value_.__l.__size_);
    }
    else {
      *(std::string *)&v100[1] = __str[1];
    }
    LOBYTE(v101[0]) = 1;
    *(void *)&xpc_object_t v82 = 0;
    uint64_t v80 = 0u;
    xpc_object_t v81 = 0u;
    memset(v79, 0, sizeof(v79));
    std::string::operator=((std::string *)v79, v69);
    std::string::operator=((std::string *)&v79[24], &v69[1]);
    uint64_t v43 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v44 = __str;
      if ((__str[0].__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        uint64_t v44 = (std::string *)__str[0].__r_.__value_.__r.__words[0];
      }
      if ((__str[1].__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string::pointer data = &__str[1];
      }
      else {
        std::string::pointer data = (std::string *)__str[1].__r_.__value_.__l.__data_;
      }
      uint64_t v46 = (std::string *)v67.__r_.__value_.__r.__words[0];
      if ((v67.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        uint64_t v46 = &v67;
      }
      uint64_t v47 = (void *)(a1 + 120);
      if (*(char *)(a1 + 143) < 0) {
        uint64_t v47 = (void *)*v47;
      }
      *(_DWORD *)xpc_object_t v97 = 136315906;
      *(void *)&v97[4] = v44;
      *(_WORD *)&v97[12] = 2080;
      *(void *)&v97[14] = data;
      *(_WORD *)&v97[22] = 2080;
      v98.__r_.__value_.__r.__words[0] = (std::string::size_type)v46;
      LOWORD(v98.__r_.__value_.__r.__words[1]) = 2080;
      *(std::string::size_type *)((char *)&v98.__r_.__value_.__r.__words[1] + 2) = (std::string::size_type)v47;
      _os_log_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_DEFAULT, "#I send enableService Request with token %s, message %s mac (%s) ip (%s)", v97, 0x2Au);
    }
    sub_100058DB0(v97, "MAC-address");
    if (SHIBYTE(v67.__r_.__value_.__r.__words[2]) < 0) {
      sub_10004FC84(&v98, v67.__r_.__value_.__l.__data_, v67.__r_.__value_.__l.__size_);
    }
    else {
      xpc_object_t v98 = v67;
    }
    sub_100B377CC((void **)&v81, (long long *)v97);
    if (SHIBYTE(v98.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v98.__r_.__value_.__l.__data_);
    }
    if ((char)v97[23] < 0) {
      operator delete(*(void **)v97);
    }
    sub_100058DB0(v97, "IPv6-address");
    if (*(char *)(a1 + 143) < 0) {
      sub_10004FC84(&v98, *(void **)(a1 + 120), *(void *)(a1 + 128));
    }
    else {
      xpc_object_t v98 = *(std::string *)(a1 + 120);
    }
    sub_100B377CC((void **)&v81, (long long *)v97);
    if (SHIBYTE(v98.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v98.__r_.__value_.__l.__data_);
    }
    if ((char)v97[23] < 0) {
      operator delete(*(void **)v97);
    }
    std::string::operator=((std::string *)(a1 + 184), __str);
    std::string::operator=((std::string *)(a1 + 160), (const std::string *)a2);
    id v48 = __p;
    id v65 = (void *)a1;
    if (SHIBYTE(v67.__r_.__value_.__r.__words[2]) < 0) {
      sub_10004FC84(&v66, v67.__r_.__value_.__l.__data_, v67.__r_.__value_.__l.__size_);
    }
    else {
      long long v66 = v67;
    }
    v98.__r_.__value_.__r.__words[0] = 0;
    uint64_t v49 = (char *)operator new(0x28uLL);
    id v50 = v65;
    *(void *)uint64_t v49 = off_101A3DFF8;
    *((void *)v49 + 1) = v50;
    *(std::string *)(v49 + 16) = v66;
    memset(&v66, 0, sizeof(v66));
    v98.__r_.__value_.__r.__words[0] = (std::string::size_type)v49;
    (*(void (**)(void *, uint64_t, std::string *, unsigned char *, uint64_t, uint8_t *))(*(void *)v48 + 232))(v48, 12, buf, v79, a1 + 24, v97);
    sub_10019FBA0(v97);
    if (SHIBYTE(v66.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v66.__r_.__value_.__l.__data_);
    }
    *(void *)xpc_object_t v97 = &v81;
    sub_100155410((void ***)v97);
    if (SHIBYTE(v80) < 0) {
      operator delete(*(void **)&v79[24]);
    }
    if ((v79[23] & 0x80000000) != 0) {
      operator delete(*(void **)v79);
    }
    if (LOBYTE(v101[0]) && SHIBYTE(v100[3]) < 0) {
      operator delete(v100[1]);
    }
    if (LOBYTE(v100[0]) && SHIBYTE(buf[1].__r_.__value_.__r.__words[2]) < 0) {
      operator delete(buf[1].__r_.__value_.__l.__data_);
    }
    if (v74) {
      sub_10004D2C8(v74);
    }
    if (SHIBYTE(v78) < 0) {
      operator delete(__dst[0]);
    }
  }
  else
  {
    double v32 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
    {
      LOWORD(buf[0].__r_.__value_.__l.__data_) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_ERROR, "cannot get mac address", (uint8_t *)buf, 2u);
    }
  }
  if (SHIBYTE(v67.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v67.__r_.__value_.__l.__data_);
  }
  return sub_1005ADA04((uint64_t)__str);
}

void sub_100B37464(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *a16, uint64_t a17, uint64_t a18, uint64_t a19, char a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,void *a34,uint64_t a35,int a36,__int16 a37,char a38,char a39,uint64_t a40,uint64_t a41,uint64_t a42,void *a43,uint64_t a44,int a45,__int16 a46,char a47,char a48,uint64_t a49,void *__p,uint64_t a51,int a52,__int16 a53,char a54,char a55,uint64_t a56,char a57)
{
  if (a55 < 0) {
    operator delete(__p);
  }
  if (a14 < 0) {
    operator delete(a9);
  }
  sub_10008248C((uint64_t)&a57);
  if (SLOBYTE(STACK[0x257]) < 0) {
    operator delete((void *)STACK[0x240]);
  }
  sub_10008248C((uint64_t)&STACK[0x270]);
  if (a39 < 0) {
    operator delete(a34);
  }
  if (a48 < 0) {
    operator delete(a43);
  }
  sub_1005ADA04((uint64_t)&a20);
  _Unwind_Resume(a1);
}

void sub_100B37624(uint64_t a1, int a2)
{
}

void sub_100B3762C(uint64_t a1, const std::string *a2)
{
  uint64_t v3 = (void *)(a1 + 120);
  std::string::operator=((std::string *)(a1 + 120), a2);
  xpc_object_t v4 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    if (*(char *)(a1 + 143) < 0) {
      uint64_t v3 = (void *)*v3;
    }
    *(_DWORD *)long long __p = 136315138;
    *(void *)&__p[4] = v3;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I handleWifiAddressUpdated %s", __p, 0xCu);
  }
  if (*(char *)(a1 + 143) < 0)
  {
    if (!*(void *)(a1 + 128)) {
      return;
    }
  }
  else if (!*(unsigned char *)(a1 + 143))
  {
    return;
  }
  sub_100058DB0(__p, "wifiAddressUpdated");
  sub_100B36730(a1, (std::string::size_type)__p);
  if (v6 < 0) {
    operator delete(*(void **)__p);
  }
}

void sub_100B37730(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100B37754(uint64_t a1, const std::string *a2)
{
}

void sub_100B3775C(uint64_t a1)
{
  sub_100058DB0(__p, "tokenAvailable");
  sub_100B36730(a1, (std::string::size_type)__p);
  if (v3 < 0) {
    operator delete(__p[0]);
  }
}

void sub_100B377B0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100B377CC(void **a1, long long *a2)
{
  char v6 = a1[2];
  uint64_t v4 = (uint64_t)(a1 + 2);
  uint64_t v5 = v6;
  unint64_t v7 = *(void *)(v4 - 8);
  if (v7 >= (unint64_t)v6)
  {
    unint64_t v11 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v7 - (void)*a1) >> 4);
    unint64_t v12 = v11 + 1;
    if (v11 + 1 > 0x555555555555555) {
      sub_10006A748();
    }
    unint64_t v13 = 0xAAAAAAAAAAAAAAABLL * ((v5 - (unsigned char *)*a1) >> 4);
    if (2 * v13 > v12) {
      unint64_t v12 = 2 * v13;
    }
    if (v13 >= 0x2AAAAAAAAAAAAAALL) {
      unint64_t v14 = 0x555555555555555;
    }
    else {
      unint64_t v14 = v12;
    }
    if (v14) {
      uint64_t v15 = (char *)sub_10019F624(v4, v14);
    }
    else {
      uint64_t v15 = 0;
    }
    BOOL v16 = &v15[48 * v11];
    long long v17 = *a2;
    *((void *)v16 + 2) = *((void *)a2 + 2);
    *(_OWORD *)BOOL v16 = v17;
    *((void *)a2 + 1) = 0;
    *((void *)a2 + 2) = 0;
    *(void *)a2 = 0;
    long long v18 = *(long long *)((char *)a2 + 24);
    *((void *)v16 + 5) = *((void *)a2 + 5);
    *(_OWORD *)(v16 + 24) = v18;
    *((void *)a2 + 4) = 0;
    *((void *)a2 + 5) = 0;
    *((void *)a2 + 3) = 0;
    uint64_t v19 = (char *)*a1;
    unint64_t v20 = (char *)a1[1];
    if (v20 == *a1)
    {
      xpc_object_t v10 = v16 + 48;
      *a1 = v16;
      a1[1] = v16 + 48;
      a1[2] = &v15[48 * v14];
    }
    else
    {
      size_t v21 = &v15[48 * v11];
      do
      {
        long long v22 = *((_OWORD *)v20 - 3);
        *((void *)v21 - 4) = *((void *)v20 - 4);
        *((_OWORD *)v21 - 3) = v22;
        *((void *)v20 - 5) = 0;
        *((void *)v20 - 4) = 0;
        *((void *)v20 - 6) = 0;
        long long v23 = *(_OWORD *)(v20 - 24);
        *((void *)v21 - 1) = *((void *)v20 - 1);
        *(_OWORD *)(v21 - 24) = v23;
        v21 -= 48;
        *((void *)v20 - 2) = 0;
        *((void *)v20 - 1) = 0;
        *((void *)v20 - 3) = 0;
        v20 -= 48;
      }
      while (v20 != v19);
      unint64_t v20 = (char *)*a1;
      uint64_t v24 = (uint64_t)a1[1];
      xpc_object_t v10 = v16 + 48;
      *a1 = v21;
      a1[1] = v16 + 48;
      a1[2] = &v15[48 * v14];
      while ((char *)v24 != v20)
      {
        v24 -= 48;
        sub_1000FECD4(v24);
      }
    }
    if (v20) {
      operator delete(v20);
    }
  }
  else
  {
    long long v8 = *a2;
    *(void *)(v7 + 16) = *((void *)a2 + 2);
    *(_OWORD *)unint64_t v7 = v8;
    *((void *)a2 + 1) = 0;
    *((void *)a2 + 2) = 0;
    *(void *)a2 = 0;
    long long v9 = *(long long *)((char *)a2 + 24);
    *(void *)(v7 + 40) = *((void *)a2 + 5);
    *(_OWORD *)(v7 + 24) = v9;
    *((void *)a2 + 4) = 0;
    *((void *)a2 + 5) = 0;
    *((void *)a2 + 3) = 0;
    xpc_object_t v10 = (char *)(v7 + 48);
  }
  a1[1] = v10;
}

void sub_100B3798C(uint64_t a1)
{
  uint64_t v1 = (uint64_t *)*(unsigned __int8 *)(a1 + 208);
  if (v1 != 1) {
    sub_100B379A4(a1, 2, v1);
  }
}

void sub_100B379A4(uint64_t a1@<X0>, int a2@<W1>, uint64_t *a3@<X8>)
{
  if (*(double *)(a1 + 152) == 0.0) {
    return;
  }
  uint64_t v5 = sub_100B37D10(*(Registry **)(a1 + 80), a3);
  double v6 = *(double *)(a1 + 152);
  xpc_object_t v27 = 0;
  xpc_object_t v7 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v8 = v7;
  if (v7)
  {
    xpc_object_t v27 = v7;
  }
  else
  {
    xpc_object_t v8 = xpc_null_create();
    xpc_object_t v27 = v8;
    if (!v8)
    {
      xpc_object_t v9 = xpc_null_create();
      xpc_object_t v8 = 0;
      goto LABEL_9;
    }
  }
  if (xpc_get_type(v8) != (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_object_t v9 = xpc_null_create();
LABEL_9:
    xpc_object_t v27 = v9;
    goto LABEL_10;
  }
  xpc_retain(v8);
LABEL_10:
  xpc_release(v8);
  uint64_t v24 = 0;
  uint64_t v25 = 0;
  uint64_t v26 = 0;
  sub_100058DB0(&v24, "wifi disconnect");
  if (a2 == 1)
  {
    if (SHIBYTE(v26) < 0)
    {
      uint64_t v25 = 14;
      xpc_object_t v10 = v24;
    }
    else
    {
      HIBYTE(v26) = 14;
      xpc_object_t v10 = (char *)&v24;
    }
    strcpy(v10, "service expire");
  }
  xpc_object_t object = xpc_BOOL_create(1);
  if (!object) {
    xpc_object_t object = xpc_null_create();
  }
  v15.__r_.__value_.__r.__words[0] = (std::string::size_type)&v27;
  v15.__r_.__value_.__l.__size_ = (std::string::size_type)"is_successful";
  sub_100035E70((uint64_t)&v15, &object, &v23);
  xpc_release(v23);
  xpc_object_t v23 = 0;
  xpc_release(object);
  xpc_object_t object = 0;
  if (v26 >= 0) {
    unint64_t v11 = (const char *)&v24;
  }
  else {
    unint64_t v11 = v24;
  }
  xpc_object_t v20 = xpc_string_create(v11);
  if (!v20) {
    xpc_object_t v20 = xpc_null_create();
  }
  v15.__r_.__value_.__r.__words[0] = (std::string::size_type)&v27;
  v15.__r_.__value_.__l.__size_ = (std::string::size_type)"session_end";
  sub_100035E70((uint64_t)&v15, &v20, &v21);
  xpc_release(v21);
  xpc_object_t v21 = 0;
  xpc_release(v20);
  xpc_object_t v20 = 0;
  unint64_t v12 = (const char *)(a1 + 160);
  if (*(char *)(a1 + 183) < 0) {
    unint64_t v12 = *(const char **)v12;
  }
  xpc_object_t v18 = xpc_string_create(v12);
  if (!v18) {
    xpc_object_t v18 = xpc_null_create();
  }
  v15.__r_.__value_.__r.__words[0] = (std::string::size_type)&v27;
  v15.__r_.__value_.__l.__size_ = (std::string::size_type)"request_reason";
  sub_100035E70((uint64_t)&v15, &v18, &v19);
  xpc_release(v19);
  xpc_object_t v19 = 0;
  xpc_release(v18);
  xpc_object_t v18 = 0;
  std::to_string(&v15, (unint64_t)((double)v5 - v6));
  if ((v15.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    unint64_t v13 = &v15;
  }
  else {
    unint64_t v13 = (std::string *)v15.__r_.__value_.__r.__words[0];
  }
  xpc_object_t v16 = xpc_string_create((const char *)v13);
  if (!v16) {
    xpc_object_t v16 = xpc_null_create();
  }
  v14[0] = &v27;
  v14[1] = "duration";
  sub_100035E70((uint64_t)v14, &v16, &v17);
  xpc_release(v17);
  xpc_object_t v17 = 0;
  xpc_release(v16);
  xpc_object_t v16 = 0;
  if (SHIBYTE(v15.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v15.__r_.__value_.__l.__data_);
  }
  sub_100B37E4C(a1, (xpc::object *)&v27);
  *(void *)(a1 + 152) = 0;
  if (SHIBYTE(v26) < 0) {
    operator delete(v24);
  }
  xpc_release(v27);
}

void sub_100B37CA0(_Unwind_Exception *a1)
{
  if (*(char *)(v1 - 57) < 0) {
    operator delete(*(void **)(v1 - 80));
  }
  xpc_release(*(xpc_object_t *)(v1 - 56));
  _Unwind_Resume(a1);
}

uint64_t sub_100B37D10@<X0>(Registry *a1@<X0>, uint64_t *a2@<X8>)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(a2, a1);
  char v3 = ServiceMap;
  if ((v4 & 0x8000000000000000) != 0)
  {
    uint64_t v5 = (unsigned __int8 *)(v4 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v6 = 5381;
    do
    {
      unint64_t v4 = v6;
      unsigned int v7 = *v5++;
      uint64_t v6 = (33 * v6) ^ v7;
    }
    while (v7);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v14 = v4;
  xpc_object_t v8 = sub_10004D37C(&v3[1].__m_.__sig, &v14);
  if (v8)
  {
    uint64_t v10 = v8[3];
    xpc_object_t v9 = (std::__shared_weak_count *)v8[4];
    if (v9)
    {
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v3);
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v9);
      char v11 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v10 = 0;
  }
  std::mutex::unlock(v3);
  xpc_object_t v9 = 0;
  char v11 = 1;
LABEL_9:
  double v12 = (*(double (**)(uint64_t))(*(void *)v10 + 96))(v10);
  if ((v11 & 1) == 0) {
    sub_10004D2C8(v9);
  }
  return (uint64_t)(v12 + kCFAbsoluteTimeIntervalSince1970);
}

void sub_100B37E2C(_Unwind_Exception *exception_object)
{
  char v3 = v1;
  if ((v3 & 1) == 0) {
    sub_10004D2C8(v2);
  }
  _Unwind_Resume(exception_object);
}

void sub_100B37E4C(uint64_t a1, xpc::object *a2)
{
  unint64_t v4 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    xpc::object::to_string((uint64_t *)__p, a2);
    uint64_t v6 = v21 >= 0 ? __p : (void **)__p[0];
    *(_DWORD *)std::string buf = 136315138;
    xpc_object_t v23 = v6;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Send Event %s", buf, 0xCu);
    uint64_t v5 = (uint64_t *)v21;
    if ((v5 & 0x80000000) != 0) {
      operator delete(__p[0]);
    }
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(v5, *(Registry **)(a1 + 80));
  xpc_object_t v8 = ServiceMap;
  if (v9 < 0)
  {
    uint64_t v10 = (unsigned __int8 *)(v9 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v11 = 5381;
    do
    {
      uint64_t v9 = v11;
      unsigned int v12 = *v10++;
      uint64_t v11 = (33 * v11) ^ v12;
    }
    while (v12);
  }
  std::mutex::lock(ServiceMap);
  __p[0] = (void *)v9;
  unint64_t v13 = sub_10004D37C(&v8[1].__m_.__sig, (unint64_t *)__p);
  if (v13)
  {
    uint64_t v15 = v13[3];
    unint64_t v14 = (std::__shared_weak_count *)v13[4];
    if (v14)
    {
      atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v8);
      atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v14);
      char v16 = 0;
      if (!v15) {
        goto LABEL_13;
      }
LABEL_17:
      xpc_object_t v18 = *(void **)a2;
      xpc_object_t object = v18;
      if (v18) {
        xpc_retain(v18);
      }
      else {
        xpc_object_t object = xpc_null_create();
      }
      (*(void (**)(uint64_t, const char *, xpc_object_t *))(*(void *)v15 + 16))(v15, "EnhancedThroughputSession", &object);
      xpc_release(object);
      xpc_object_t object = 0;
      goto LABEL_21;
    }
  }
  else
  {
    uint64_t v15 = 0;
  }
  std::mutex::unlock(v8);
  unint64_t v14 = 0;
  char v16 = 1;
  if (v15) {
    goto LABEL_17;
  }
LABEL_13:
  xpc_object_t v17 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
  {
    LOWORD(__p[0]) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "Couldn't get analytics handler", (uint8_t *)__p, 2u);
  }
LABEL_21:
  if ((v16 & 1) == 0) {
    sub_10004D2C8(v14);
  }
}

void sub_100B38078(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

char *sub_100B380C0@<X0>(char *result@<X0>, uint64_t a2@<X8>)
{
  if (result[119] < 0) {
    return (char *)sub_10004FC84((unsigned char *)a2, *((void **)result + 12), *((void *)result + 13));
  }
  *(_OWORD *)a2 = *((_OWORD *)result + 6);
  *(void *)(a2 + 16) = *((void *)result + 14);
  return result;
}

char *sub_100B380EC@<X0>(char *result@<X0>, uint64_t a2@<X8>)
{
  if (result[71] < 0) {
    return (char *)sub_10004FC84((unsigned char *)a2, *((void **)result + 6), *((void *)result + 7));
  }
  *(_OWORD *)a2 = *((_OWORD *)result + 3);
  *(void *)(a2 + 16) = *((void *)result + 8);
  return result;
}

void sub_100B38118(uint64_t **a1)
{
  void (***v12)(void **__return_ptr, void, void **);
  char v13;
  _OWORD *v14;
  const void *Value;
  NSObject *v16;
  NSObject *v17;
  uint64_t (*v18)(uint64_t);
  CFArrayRef v19;
  CFArrayRef v20;
  CFTypeID v21;
  CFIndex Count;
  CFIndex v23;
  CFDictionaryRef ValueAtIndex;
  CFDictionaryRef v25;
  CFTypeID v26;
  int *v27;
  int *v28;
  CFTypeID v29;
  CFNumberRef v30;
  const void *v31;
  const void *v32;
  CFTypeID v33;
  CFStringRef v34;
  int v35;
  NSObject *v36;
  std::__shared_weak_count *v37;
  std::__shared_weak_count *v38;
  std::__shared_weak_count *v39;
  std::__shared_weak_count *v40;
  NSObject *v41;
  NSObject *v42;
  const char *v43;
  NSObject *v44;
  void *v45;
  CFNumberRef v46;
  CFNumberRef v47;
  CFTypeID v48;
  uint64_t v49;
  CFDictionaryRef theDict[2];
  uint64_t v51;
  std::__shared_weak_count *v52;
  dispatch_object_t object;
  void *__p[2];
  long long v55;
  void *v56;
  std::__shared_weak_count *v57;
  char v58;
  unsigned char buf[12];

  uint64_t v1 = **a1;
  Registry::createRestModuleOneTimeUseConnection(&v51, *(Registry **)(v1 + 80));
  ctu::RestModule::connect();
  if (v52) {
    sub_10004D2C8(v52);
  }
  sub_100058DB0(&v56, "/cc/props/wifi_status");
  char v2 = operator new(0x28uLL);
  void *v2 = off_101A3DD40;
  v2[1] = v1 + 208;
  v2[2] = v1;
  v2[3] = sub_100B3798C;
  v2[4] = 0;
  *((void *)&v55 + 1) = v2;
  ctu::RestModule::observeProperty();
  sub_10003F600(__p);
  char v3 = (uint64_t *)v58;
  if ((v3 & 0x80000000) != 0) {
    operator delete(v56);
  }
  LODWORD(object) = 0;
  theDict[0] = 0;
  uint64_t v56 = 0;
  int v57 = 0;
  ServiceMap = (std::mutex *)Registry::getServiceMap(v3, *(Registry **)(v1 + 80));
  uint64_t v5 = ServiceMap;
  if (v6 < 0)
  {
    unsigned int v7 = (unsigned __int8 *)(v6 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v8 = 5381;
    do
    {
      uint64_t v6 = v8;
      unsigned int v9 = *v7++;
      uint64_t v8 = (33 * v8) ^ v9;
    }
    while (v9);
  }
  std::mutex::lock(ServiceMap);
  __p[0] = (void *)v6;
  uint64_t v10 = sub_10004D37C(&v5[1].__m_.__sig, (unint64_t *)__p);
  if (v10)
  {
    unsigned int v12 = (void (***)(void **__return_ptr, void, void **))v10[3];
    uint64_t v11 = (std::__shared_weak_count *)v10[4];
    if (v11)
    {
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v5);
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v11);
      unint64_t v13 = 0;
      goto LABEL_13;
    }
  }
  else
  {
    unsigned int v12 = 0;
  }
  std::mutex::unlock(v5);
  uint64_t v11 = 0;
  unint64_t v13 = 1;
LABEL_13:
  unint64_t v14 = (_OWORD *)(v1 + 96);
  if (*(char *)(v1 + 119) < 0)
  {
    sub_10004FC84(__p, *(void **)(v1 + 96), *(void *)(v1 + 104));
  }
  else
  {
    *(_OWORD *)long long __p = *v14;
    *(void *)&unint64_t v55 = *(void *)(v1 + 112);
  }
  (**v12)(&v56, v12, __p);
  if (SBYTE7(v55) < 0)
  {
    operator delete(__p[0]);
    if (v13)
    {
LABEL_19:
      if (v56)
      {
        __p[0] = 0;
        __p[1] = 0;
        (*(void (**)(void **__return_ptr))(*(void *)v56 + 64))(__p);
        if (__p[0])
        {
          theDict[0] = 0;
          Value = CFDictionaryGetValue(*((CFDictionaryRef *)__p[0] + 8), @"BlindToken");
          *(void *)std::string buf = Value;
          if (Value) {
            CFRetain(Value);
          }
          sub_10004EFE4(theDict, (CFTypeRef *)buf);
          sub_1000577C4((const void **)buf);
        }
        else
        {
          xpc_object_t v17 = *(NSObject **)(v1 + 40);
          if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
          {
            uint64_t v49 = v1 + 96;
            if (*(char *)(v1 + 119) < 0) {
              uint64_t v49 = *(void *)v14;
            }
            *(_DWORD *)std::string buf = 136315138;
            *(void *)&uint8_t buf[4] = v49;
            _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "Cannot get settings for iccid (%s)", buf, 0xCu);
          }
          theDict[0] = 0;
        }
        if (__p[1]) {
          sub_10004D2C8((std::__shared_weak_count *)__p[1]);
        }
      }
      else
      {
        char v16 = *(NSObject **)(v1 + 40);
        if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
        {
          id v45 = (void *)(v1 + 96);
          if (*(char *)(v1 + 119) < 0) {
            id v45 = *(void **)v14;
          }
          LODWORD(__p[0]) = 136315138;
          *(void **)((char *)__p + 4) = v45;
          _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "entitlementController is null for iccid (%s)", (uint8_t *)__p, 0xCu);
        }
        theDict[0] = 0;
      }
      if (v57) {
        sub_10004D2C8(v57);
      }
      if (theDict[0]) {
        xpc_object_t v18 = sub_100080778;
      }
      else {
        xpc_object_t v18 = 0;
      }
      if (v18)
      {
        xpc_object_t v19 = (const __CFArray *)CFDictionaryGetValue(theDict[0], @"SupportedServices");
        xpc_object_t v20 = v19;
        if (v19)
        {
          char v21 = CFGetTypeID(v19);
          if (v21 == CFArrayGetTypeID())
          {
            CFIndex Count = CFArrayGetCount(v20);
            if (Count < 1) {
              goto LABEL_55;
            }
            xpc_object_t v23 = 0;
            while (1)
            {
              ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v20, v23);
              uint64_t v25 = ValueAtIndex;
              if (ValueAtIndex)
              {
                uint64_t v26 = CFGetTypeID(ValueAtIndex);
                if (v26 != CFDictionaryGetTypeID()) {
                  uint64_t v25 = 0;
                }
              }
              xpc_object_t v27 = (int *)CFDictionaryGetValue(v25, @"ServiceNames");
              uint64_t v28 = v27;
              if (v27)
              {
                unsigned __int8 v29 = CFGetTypeID(v27);
                if (v29 == CFNumberGetTypeID())
                {
                  LODWORD(__p[0]) = 0;
                  ctu::cf::assign((ctu::cf *)__p, v28, v30);
                  if (LODWORD(__p[0]) == 1)
                  {
                    BOOL v31 = CFDictionaryGetValue(v25, @"DeviceType");
                    double v32 = v31;
                    if (v31)
                    {
                      double v33 = CFGetTypeID(v31);
                      double v34 = v33 == CFStringGetTypeID() ? (const __CFString *)v32 : 0;
                    }
                    else
                    {
                      double v34 = 0;
                    }
                    if (CFEqual(v34, @"iPhone")) {
                      break;
                    }
                  }
                }
              }
              if (Count == ++v23) {
                goto LABEL_55;
              }
            }
            uint64_t v46 = (const __CFNumber *)CFDictionaryGetValue(theDict[0], @"NumTokens");
            uint64_t v47 = v46;
            if (v46 && (id v48 = CFGetTypeID(v46), v48 == CFNumberGetTypeID()))
            {
              CFNumberGetValue(v47, kCFNumberIntType, &object);
              std::string::size_type v35 = (int)object;
            }
            else
            {
LABEL_55:
              std::string::size_type v35 = 0;
            }
            double v36 = *(NSObject **)(v1 + 40);
            if (os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT))
            {
              LODWORD(__p[0]) = 67109120;
              HIDWORD(__p[0]) = v35;
              _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_DEFAULT, "#I Token Configuration: token number %d", (uint8_t *)__p, 8u);
              std::string::size_type v35 = (int)object;
            }
            sub_100057D78((const void **)theDict);
            if (v35)
            {
              uint64_t v37 = *(std::__shared_weak_count **)(v1 + 16);
              if (v37)
              {
                unsigned int v38 = std::__shared_weak_count::lock(v37);
                if (v38)
                {
                  uint64_t v39 = v38;
                  atomic_fetch_add_explicit(&v38->__shared_weak_owners_, 1uLL, memory_order_relaxed);
                  sub_10004D2C8(v38);
                  double v40 = *(std::__shared_weak_count **)(v1 + 16);
                  if (v40)
                  {
                    if (std::__shared_weak_count::lock(v40))
                    {
                      unsigned __int8 v41 = *(NSObject **)(v1 + 24);
                      atomic_fetch_add_explicit(&v39->__shared_weak_owners_, 1uLL, memory_order_relaxed);
                      dispatch_retain(v41);
                      *(_OWORD *)long long __p = 0u;
                      unint64_t v55 = 0u;
                      atomic_fetch_add_explicit(&v39->__shared_weak_owners_, 1uLL, memory_order_relaxed);
                      dispatch_retain(v41);
                      atomic_fetch_add_explicit(&v39->__shared_weak_owners_, 1uLL, memory_order_relaxed);
                      dispatch_retain(v41);
                      atomic_fetch_add_explicit(&v39->__shared_weak_owners_, 1uLL, memory_order_relaxed);
                      dispatch_retain(v41);
                      atomic_fetch_add_explicit(&v39->__shared_weak_owners_, 1uLL, memory_order_relaxed);
                      dispatch_retain(v41);
                      atomic_fetch_add_explicit(&v39->__shared_weak_owners_, 1uLL, memory_order_relaxed);
                      dispatch_retain(v41);
                      atomic_fetch_add_explicit(&v39->__shared_weak_owners_, 1uLL, memory_order_relaxed);
                      dispatch_retain(v41);
                      atomic_fetch_add_explicit(&v39->__shared_weak_owners_, 1uLL, memory_order_relaxed);
                      uint64_t v56 = 0;
                      dispatch_retain(v41);
                      operator new();
                    }
                  }
                  sub_100088B9C();
                }
              }
              sub_100088B9C();
            }
LABEL_68:
            uint64_t v44 = *(NSObject **)(v1 + 40);
            if (os_log_type_enabled(v44, OS_LOG_TYPE_ERROR))
            {
              LOWORD(__p[0]) = 0;
              _os_log_error_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_ERROR, "Cannot get configured token number", (uint8_t *)__p, 2u);
            }
            operator delete();
          }
        }
        id v42 = *(NSObject **)(v1 + 40);
        if (os_log_type_enabled(v42, OS_LOG_TYPE_ERROR))
        {
          LOWORD(__p[0]) = 0;
          uint64_t v43 = "Cannot find SupportedServices in BlindToken section";
LABEL_75:
          _os_log_error_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_ERROR, v43, (uint8_t *)__p, 2u);
        }
      }
      else
      {
        id v42 = *(NSObject **)(v1 + 40);
        if (os_log_type_enabled(v42, OS_LOG_TYPE_ERROR))
        {
          LOWORD(__p[0]) = 0;
          uint64_t v43 = "cannot find BlindToken in CB";
          goto LABEL_75;
        }
      }
      sub_100057D78((const void **)theDict);
      goto LABEL_68;
    }
  }
  else if (v13)
  {
    goto LABEL_19;
  }
  sub_10004D2C8(v11);
  goto LABEL_19;
}

void sub_100B38C8C(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, const void *a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, dispatch_object_t object,void *__p,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
}

void sub_100B38FA0()
{
}

__n128 sub_100B38FB4(uint64_t a1)
{
  char v2 = (char *)operator new(0x28uLL);
  *(void *)char v2 = off_101A3DD40;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_100B39008(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A3DD40;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_100B39040(void *a1, xpc_object_t *a2)
{
  unint64_t v4 = (char *)a1[1];
  xpc_type_t type = xpc_get_type(*a2);
  if (type == (xpc_type_t)&_xpc_type_string)
  {
    char v13 = *v4;
    ctu::rest::detail::read_enum_string_value((ctu::rest::detail *)&v13, (unsigned __int8 *)a2, v6);
    *unint64_t v4 = v13;
  }
  else if (type == (xpc_type_t)&_xpc_type_BOOL {
         || type == (xpc_type_t)&_xpc_type_int64
  }
         || type == (xpc_type_t)&_xpc_type_uint64)
  {
    *unint64_t v4 = xpc::dyn_cast_or_default((xpc *)a2, 0, (uint64_t)v6);
  }
  unsigned int v9 = (uint64_t (*)(void *))a1[3];
  uint64_t v10 = a1[4];
  uint64_t v11 = (void *)(a1[2] + (v10 >> 1));
  if (v10) {
    unsigned int v9 = *(uint64_t (**)(void *))(*v11 + v9);
  }
  return v9(v11);
}

uint64_t sub_100B39130(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100B39170()
{
}

uint64_t sub_100B3917C(uint64_t *a1)
{
  uint64_t result = *a1;
  if (!result) {
    __assert_rtn("operator*", "shared_ptr.hpp", 780, "px != 0");
  }
  return result;
}

void sub_100B391C0(uint64_t *a1)
{
  memset(v3, 0, sizeof(v3));
  char v2 = (pthread_mutex_t *)sub_100060E64(a1 + 3);
  sub_100061F70(v3, v2);
  sub_100B392B8(a1, v3);
}

void sub_100B39288(_Unwind_Exception *exception_object, int a2)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_100B392B8(uint64_t *a1, void *a2)
{
  uint64_t v2 = 0;
  uint64_t v3 = 0;
  sub_100B393B0(a1, a2);
}

void sub_100B39398(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  sub_10000A740((atomic_uint **)va);
  _Unwind_Resume(a1);
}

void sub_100B393B0(uint64_t *a1, void *a2)
{
}

void sub_100B39424()
{
}

uint64_t sub_100B39448(uint64_t *a1)
{
  uint64_t result = *a1;
  if (!result) {
    __assert_rtn("operator->", "shared_ptr.hpp", 786, "px != 0");
  }
  return result;
}

uint64_t sub_100B3948C(uint64_t *a1)
{
  uint64_t result = *a1;
  if (!result) {
    __assert_rtn("operator->", "shared_ptr.hpp", 786, "px != 0");
  }
  return result;
}

uint64_t *sub_100B394D0(uint64_t *a1, void *a2)
{
  uint64_t v2 = a1[1];
  if (!v2 || atomic_load_explicit((atomic_uint *volatile)(v2 + 8), memory_order_acquire) != 1) {
    operator new();
  }

  return sub_100B397EC(a1, a2, 1, 2);
}

void sub_100B395CC()
{
}

void sub_100B395F0(void *a1, uint64_t a2)
{
  if (a2)
  {
    if (*a1 == a2) {
      __assert_rtn("reset", "shared_ptr.hpp", 734, "p == 0 || p != px");
    }
  }
  sub_100B398A0(&v2, a2);
}

uint64_t sub_100B3966C(uint64_t *a1)
{
  uint64_t result = *a1;
  if (!result) {
    __assert_rtn("operator*", "shared_ptr.hpp", 780, "px != 0");
  }
  return result;
}

uint64_t *sub_100B396B0(uint64_t *a1, void *a2, int a3, uint64_t **a4, int a5)
{
  uint64_t v5 = a1[1];
  if (!v5 || atomic_load_explicit((atomic_uint *volatile)(v5 + 8), memory_order_acquire) != 1) {
    __assert_rtn("nolock_cleanup_connections_from", "signal_template.hpp", 436, "_shared_state.unique()");
  }
  long long v22 = *a4;
  uint64_t v10 = (uint64_t *)sub_100B39448(a1);
  uint64_t result = (uint64_t *)sub_100B3A7AC(v10);
  if (result != v22)
  {
    unsigned int v12 = a5 - 1;
    unsigned int v13 = 1;
    uint64_t result = v22;
    do
    {
      if (a3)
      {
        uint64_t v14 = sub_100B3948C(result + 2);
        sub_100B39ED4(v14, a2);
        uint64_t result = v22;
      }
      if (*(unsigned char *)(sub_100B3948C(result + 2) + 24))
      {
        uint64_t v15 = (atomic_uint *)v22[1];
      }
      else
      {
        char v16 = (uint64_t *)sub_100B39448(a1);
        uint64_t v17 = sub_100B3A7AC(v16);
        uint64_t v18 = sub_100B3948C(v22 + 2);
        uint64_t v15 = sub_1001631B0(v17, (void *)(v18 + 64), (void **)&v22);
      }
      long long v22 = (uint64_t *)v15;
      xpc_object_t v19 = (uint64_t *)sub_100B39448(a1);
      xpc_object_t v20 = (uint64_t *)sub_100B3A7AC(v19);
      uint64_t result = v22;
      if (v22 == v20) {
        break;
      }
    }
    while (v12 >= v13++);
  }
  a1[2] = (uint64_t)result;
  return result;
}

uint64_t *sub_100B397EC(uint64_t *a1, void *a2, int a3, int a4)
{
  uint64_t v4 = a1[1];
  if (!v4 || atomic_load_explicit((atomic_uint *volatile)(v4 + 8), memory_order_acquire) != 1) {
    __assert_rtn("nolock_cleanup_connections", "signal_template.hpp", 461, "_shared_state.unique()");
  }
  unsigned int v9 = (uint64_t *)sub_100B39448(a1);
  uint64_t v10 = sub_100B3A7AC(v9);
  uint64_t v11 = (uint64_t *)a1[2];
  if (v11 == (uint64_t *)v10)
  {
    unsigned int v12 = (uint64_t *)sub_100B39448(a1);
    uint64_t v11 = *(uint64_t **)(sub_100B3A7AC(v12) + 8);
  }
  uint64_t v14 = v11;
  return sub_100B396B0(a1, a2, a3, &v14, a4);
}

void sub_100B398A0(void *a1, uint64_t a2)
{
  *a1 = a2;
  a1[1] = 0;
  sub_100B3990C(&v2);
}

void sub_100B398F8(_Unwind_Exception *a1)
{
  sub_10000A740(v1);
  _Unwind_Resume(a1);
}

void sub_100B3990C(void *a1)
{
  *a1 = 0;
  operator new();
}

void sub_100B3997C(void *a1)
{
  __cxa_begin_catch(a1);
  sub_10016267C(v1);
  __cxa_rethrow();
}

void sub_100B39990(_Unwind_Exception *a1)
{
}

void sub_100B399A8()
{
}

uint64_t sub_100B399BC(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 16);
  if (v1)
  {
    sub_10000A740((atomic_uint **)(v1 + 24));
    sub_10000A740((atomic_uint **)(v1 + 8));
    operator delete();
  }
  return result;
}

uint64_t sub_100B39A20()
{
  return 0;
}

uint64_t sub_100B39A28()
{
  return 0;
}

uint64_t sub_100B39A30()
{
  return 0;
}

void sub_100B39A38()
{
}

void sub_100B39AB4()
{
}

uint64_t sub_100B39AD8(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = sub_100B39C64((uint64_t *)a1, a2);
  sub_100B39CD0((uint64_t)(v4 + 3), a2 + 24);
  *(unsigned char *)(a1 + 56) = *(unsigned char *)(a2 + 56);
  uint64_t v5 = *(void **)(a2 + 24);
  uint64_t v6 = (void *)(a2 + 32);
  if (v5 != (void *)(a2 + 32))
  {
    unsigned int v7 = *(void **)(a1 + 24);
    uint64_t v8 = *(void *)(a1 + 8);
    do
    {
      if (v7 == (void *)(a1 + 32)) {
        __assert_rtn("grouped_list", "slot_groups.hpp", 80, "this_map_it != _group_map.end()");
      }
      v7[6] = v8;
      uint64_t v9 = a2;
      if (v5 != v6) {
        uint64_t v9 = v5[6];
      }
      uint64_t v10 = (void *)v5[1];
      uint64_t v11 = v10;
      unsigned int v12 = v5;
      if (v10)
      {
        do
        {
          unsigned int v13 = v11;
          uint64_t v11 = (void *)*v11;
        }
        while (v11);
      }
      else
      {
        do
        {
          unsigned int v13 = (void *)v12[2];
          BOOL v14 = *v13 == (void)v12;
          unsigned int v12 = v13;
        }
        while (!v14);
      }
      uint64_t v15 = a2;
      if (v13 != v6) {
        uint64_t v15 = v13[6];
      }
      while (v9 != v15)
      {
        uint64_t v9 = *(void *)(v9 + 8);
        uint64_t v8 = *(void *)(v8 + 8);
      }
      if (v10)
      {
        do
        {
          char v16 = v10;
          uint64_t v10 = (void *)*v10;
        }
        while (v10);
      }
      else
      {
        do
        {
          char v16 = (void *)v5[2];
          BOOL v14 = *v16 == (void)v5;
          uint64_t v5 = v16;
        }
        while (!v14);
      }
      uint64_t v17 = (void *)v7[1];
      if (v17)
      {
        do
        {
          uint64_t v18 = v17;
          uint64_t v17 = (void *)*v17;
        }
        while (v17);
      }
      else
      {
        do
        {
          uint64_t v18 = (void *)v7[2];
          BOOL v14 = *v18 == (void)v7;
          unsigned int v7 = v18;
        }
        while (!v14);
      }
      uint64_t v5 = v16;
      unsigned int v7 = v18;
    }
    while (v16 != v6);
  }
  return a1;
}

void sub_100B39C3C(_Unwind_Exception *a1)
{
  sub_100162A90(v1);
  _Unwind_Resume(a1);
}

uint64_t *sub_100B39C64(uint64_t *a1, uint64_t a2)
{
  *a1 = (uint64_t)a1;
  a1[1] = (uint64_t)a1;
  a1[2] = 0;
  for (uint64_t i = a2; ; sub_100162A30(a1, (void *)(i + 16)))
  {
    uint64_t i = *(void *)(i + 8);
    if (i == a2) {
      break;
    }
  }
  return a1;
}

void sub_100B39CBC(_Unwind_Exception *a1)
{
  sub_100162A90(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100B39CD0(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(unsigned char *)(a1 + 24) = *(unsigned char *)(a2 + 24);
  *(void *)a1 = a1 + 8;
  sub_100162B6C((_OWORD *)a1, *(void **)a2, (void *)(a2 + 8));
  return a1;
}

void sub_100B39D20(_Unwind_Exception *a1)
{
  sub_1000346F8(v1, *(void **)(v1 + 8));
  _Unwind_Resume(a1);
}

void sub_100B39D38(void *a1, uint64_t a2)
{
  *a1 = a2;
  a1[1] = 0;
  sub_100B39DA4(&v2);
}

void sub_100B39D90(_Unwind_Exception *a1)
{
  sub_10000A740(v1);
  _Unwind_Resume(a1);
}

void sub_100B39DA4(void *a1)
{
  *a1 = 0;
  operator new();
}

void sub_100B39E14(void *a1)
{
  __cxa_begin_catch(a1);
  sub_100163050(v1);
  __cxa_rethrow();
}

void sub_100B39E28(_Unwind_Exception *a1)
{
}

void sub_100B39E40()
{
}

uint64_t sub_100B39E54(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 16);
  if (v1)
  {
    sub_1000346F8(v1 + 24, *(void **)(v1 + 32));
    sub_100162A90((atomic_uint **)v1);
    operator delete();
  }
  return result;
}

uint64_t sub_100B39EBC()
{
  return 0;
}

uint64_t sub_100B39EC4()
{
  return 0;
}

uint64_t sub_100B39ECC()
{
  return 0;
}

uint64_t *sub_100B39ED4(uint64_t a1, void *a2)
{
  uint64_t v4 = *(void *)(a1 + 32);
  uint64_t result = (uint64_t *)(a1 + 32);
  if (v4)
  {
    uint64_t v6 = (uint64_t *)sub_100B39F3C(result);
    uint64_t result = (uint64_t *)sub_100163358(v6);
    if (result)
    {
      if (*(unsigned char *)(a1 + 24))
      {
        *(unsigned char *)(a1 + 24) = 0;
        return (uint64_t *)sub_100163448((atomic_uint **)a1, a2);
      }
    }
  }
  return result;
}

uint64_t sub_100B39F3C(uint64_t *a1)
{
  uint64_t result = *a1;
  if (!result) {
    __assert_rtn("operator*", "shared_ptr.hpp", 780, "px != 0");
  }
  return result;
}

void sub_100B39F80(uint64_t a1)
{
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(unsigned char *)(a1 + 24) = 1;
  *(_DWORD *)(a1 + 28) = 1;
  *(void *)a1 = off_101A3DDC0;
  operator new();
}

void sub_100B3A094(uint64_t a1, ...)
{
  va_start(va, a1);
  sub_100163C60((void ***)va);
  operator delete();
}

void sub_100B3A0FC(uint64_t a1)
{
  sub_100B3A4B0(a1);

  operator delete();
}

BOOL sub_100B3A134(uint64_t a1)
{
  uint64_t v1 = a1;
  long long v5 = 0u;
  memset(v4, 0, sizeof(v4));
  uint64_t v2 = (pthread_mutex_t *)sub_100060E64((uint64_t *)(a1 + 48));
  sub_100061F70(v4, v2);
  sub_100B3A520((atomic_uint **)v1, v4);
  LODWORD(v1) = *(unsigned __int8 *)(v1 + 24);
  sub_10000A6C8(*((pthread_mutex_t **)&v5 + 1));
  sub_10000A5F8(v4);
  return v1 != 0;
}

void sub_100B3A1E4(_Unwind_Exception *exception_object, int a2)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100B3A214(uint64_t a1)
{
  uint64_t v1 = (pthread_mutex_t *)sub_10000A588((uint64_t *)(a1 + 48));

  return sub_10000A704(v1);
}

uint64_t sub_100B3A240(uint64_t a1)
{
  uint64_t v1 = (pthread_mutex_t *)sub_10000A588((uint64_t *)(a1 + 48));

  return sub_10000A6C8(v1);
}

atomic_uint **sub_100B3A26C@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t v3 = *(void *)(a1 + 32);
  uint64_t v4 = *(void *)(a1 + 40);
  uint64_t v2 = (long long *)(a1 + 32);
  *a2 = v3;
  a2[1] = v4;
  if (v4)
  {
    atomic_fetch_add_explicit((atomic_uint *volatile)(v4 + 8), 1u, memory_order_relaxed);
    long long v5 = *v2;
  }
  else
  {
    *((void *)&v5 + 1) = 0;
  }
  *(void *)uint64_t v2 = 0;
  *((void *)v2 + 1) = 0;
  *((void *)&v7 + 1) = *((void *)&v5 + 1);
  return sub_10000A740((atomic_uint **)&v7 + 1);
}

void sub_100B3A2C8(void *a1, uint64_t a2)
{
  *a1 = a2;
  a1[1] = 0;
  sub_100B3A334(&v2);
}

void sub_100B3A320(_Unwind_Exception *a1)
{
  sub_10000A740(v1);
  _Unwind_Resume(a1);
}

void sub_100B3A334(void *a1)
{
  *a1 = 0;
  operator new();
}

void sub_100B3A3A4(void *a1)
{
  __cxa_begin_catch(a1);
  sub_100B3A3CC(v1);
  __cxa_rethrow();
}

void sub_100B3A3B8(_Unwind_Exception *a1)
{
}

uint64_t sub_100B3A3CC(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = (void **)result;
    sub_100B3B188((uint64_t *)(result + 24));
    uint64_t v2 = v1;
    sub_100163C60(&v2);
    operator delete();
  }
  return result;
}

void sub_100B3A42C()
{
}

uint64_t sub_100B3A440(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 16);
  if (v1)
  {
    sub_100B3B188((uint64_t *)(v1 + 24));
    uint64_t v2 = (void **)v1;
    sub_100163C60(&v2);
    operator delete();
  }
  return result;
}

uint64_t sub_100B3A498()
{
  return 0;
}

uint64_t sub_100B3A4A0()
{
  return 0;
}

uint64_t sub_100B3A4A8()
{
  return 0;
}

uint64_t sub_100B3A4B0(uint64_t a1)
{
  *(void *)a1 = off_101A3DDC0;
  sub_10000A740((atomic_uint **)(a1 + 56));
  sub_10000A740((atomic_uint **)(a1 + 40));
  *(void *)a1 = off_1019A5688;
  sub_100160AF8((atomic_uint **)(a1 + 16));
  return a1;
}

atomic_uint **sub_100B3A520(atomic_uint **result, void *a2)
{
  uint64_t v2 = (uint64_t *)(result + 4);
  if (result[4])
  {
    uint64_t v4 = result;
    for (uint64_t i = *(atomic_uint **)sub_100B39F3C((uint64_t *)result + 4); ; i += 6)
    {
      uint64_t result = (atomic_uint **)sub_100B39F3C(v2);
      if (i == result[1]) {
        break;
      }
      memset(v6, 0, sizeof(v6));
      sub_100060B10(i, (uint64_t)v6);
      if (sub_100060A68((uint64_t)i))
      {
        if (*((unsigned char *)v4 + 24))
        {
          *((unsigned char *)v4 + 24) = 0;
          sub_100163448(v4, a2);
        }
        return sub_1000624B4((uint64_t)v6);
      }
      sub_1000624B4((uint64_t)v6);
    }
  }
  return result;
}

void sub_100B3A604(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sub_1000624B4((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_100B3A624(void *a1, uint64_t a2)
{
  *a1 = a2;
  a1[1] = 0;
  sub_100B3A690(&v2);
}

void sub_100B3A67C(_Unwind_Exception *a1)
{
  sub_10000A740(v1);
  _Unwind_Resume(a1);
}

void sub_100B3A690(void *a1)
{
  *a1 = 0;
  operator new();
}

void sub_100B3A700(void *a1)
{
  __cxa_begin_catch(a1);
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }
  __cxa_rethrow();
}

void sub_100B3A738(_Unwind_Exception *a1)
{
}

void sub_100B3A750()
{
}

uint64_t sub_100B3A764(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 16);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_100B3A794()
{
  return 0;
}

uint64_t sub_100B3A79C()
{
  return 0;
}

uint64_t sub_100B3A7A4()
{
  return 0;
}

uint64_t sub_100B3A7AC(uint64_t *a1)
{
  uint64_t result = *a1;
  if (!result) {
    __assert_rtn("operator*", "shared_ptr.hpp", 780, "px != 0");
  }
  return result;
}

uint64_t *sub_100B3A7F0(uint64_t *result, uint64_t *a2)
{
  if (a2 != result)
  {
    uint64_t v3 = (uint64_t)result;
    memset(v4, 0, sizeof(v4));
    sub_100B3B0C8((uint64_t)v4, result);
    sub_100B3B0C8(v3, a2);
    sub_100B3B0C8((uint64_t)a2, (uint64_t *)v4);
    return sub_100B3B188((uint64_t *)v4);
  }
  return result;
}

void sub_100B3A858(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_100B3A86C(uint64_t result, _WORD *a2, int a3)
{
  uint64_t v4 = (void *)result;
  switch(a3)
  {
    case 0:
      operator new();
    case 1:
      *(void *)a2 = *(void *)result;
      *(void *)uint64_t result = 0;
      return result;
    case 2:
      uint64_t v5 = *(void *)a2;
      if (*(void *)a2)
      {
        dispatch_release(*(dispatch_object_t *)v5);
        uint64_t v6 = *(std::__shared_weak_count **)(v5 + 24);
        if (v6) {
          std::__shared_weak_count::__release_weak(v6);
        }
        operator delete();
      }
      goto LABEL_11;
    case 3:
      uint64_t result = *(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL;
      if (result == ((unint64_t)"N3ctu12DispatchSlotIZZN29EnhancedWifiQosSlotController4initEvENK3$_0clEvEUlRK13P"
                                        "ersonalityIDRKNSt3__112basic_stringIcNS6_11char_traitsIcEENS6_9allocatorIcEEEEE_EE" & 0x7FFFFFFFFFFFFFFFLL)
        || (uint64_t result = strcmp((const char *)result, (const char *)((unint64_t)"N3ctu12DispatchSlotIZZN29EnhancedWifiQosSlotController4initEvENK3$_0clEvEUlRK13PersonalityIDRKNSt3__112basic_stringIcNS6_11char_traitsIcEENS6_9allocatorIcEEEEE_EE" & 0x7FFFFFFFFFFFFFFFLL)), !result))
      {
        *(void *)a2 = *v4;
      }
      else
      {
LABEL_11:
        *(void *)a2 = 0;
      }
      break;
    default:
      a2[4] = 0;
      break;
  }
  return result;
}

void sub_100B3A9BC(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = (void *)*a1;
  if (*(char *)(a2 + 23) < 0)
  {
    sub_10004FC84(__dst, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)long long __dst = *(_OWORD *)a2;
    uint64_t v11 = *(void *)(a2 + 16);
  }
  if (*(char *)(a3 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a3, *(void *)(a3 + 8));
  }
  else
  {
    *(_OWORD *)long long __p = *(_OWORD *)a3;
    uint64_t v9 = *(void *)(a3 + 16);
  }
  uint64_t v5 = v4[1];
  uint64_t v6 = v4[2];
  long long v7 = (std::__shared_weak_count *)v4[3];
  if (v7)
  {
    atomic_fetch_add_explicit(&v7->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit(&v7->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit(&v7->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit(&v7->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit(&v7->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit(&v7->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    uint64_t v14 = v6;
    uint64_t v15 = v7;
    atomic_fetch_add_explicit(&v7->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    std::__shared_weak_count::__release_weak(v7);
    std::__shared_weak_count::__release_weak(v7);
    std::__shared_weak_count::__release_weak(v7);
    std::__shared_weak_count::__release_weak(v7);
    std::__shared_weak_count::__release_weak(v7);
  }
  else
  {
    uint64_t v14 = v4[2];
    uint64_t v15 = 0;
  }
  unsigned int v12 = off_101A3DEE8;
  uint64_t v13 = v5;
  sub_100B3AB44();
}

void sub_100B3AAFC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,char a23)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100B3AB44()
{
}

void sub_100B3ACC4()
{
}

uint64_t *sub_100B3AD10(uint64_t a1)
{
  sub_100B3ADD4(*(void **)(a1 + 32));
  uint64_t result = *(uint64_t **)(a1 + 32);
  if (result)
  {
    sub_100B3B188(result);
    operator delete();
  }
  uint64_t v3 = *(void *)(a1 + 40);
  if (v3)
  {
    if (*(char *)(v3 + 23) < 0) {
      operator delete(*(void **)v3);
    }
    operator delete();
  }
  uint64_t v4 = *(void *)(a1 + 48);
  if (v4)
  {
    if (*(char *)(v4 + 23) < 0) {
      operator delete(*(void **)v4);
    }
    operator delete();
  }
  return result;
}

uint64_t sub_100B3ADD4(void *a1)
{
  if (!*a1)
  {
    std::runtime_error::runtime_error(&v4, "call to empty boost::function");
    v4.__vftable = (std::runtime_error_vtbl *)&off_10199A8C8;
    sub_100098518(&v4);
  }
  uint64_t v1 = *(uint64_t (**)(void *))((*a1 & 0xFFFFFFFFFFFFFFFELL) + 8);
  uint64_t v2 = a1 + 1;

  return v1(v2);
}

void sub_100B3AE58(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, std::runtime_error a9)
{
}

void sub_100B3AE6C(uint64_t a1, uint64_t a2, unsigned int a3)
{
  if (a3 == 4) {
    goto LABEL_2;
  }
  if (a3 <= 1)
  {
    *(_OWORD *)a2 = *(_OWORD *)a1;
    uint64_t v5 = *(void *)(a1 + 16);
    *(void *)(a2 + 16) = v5;
    if (v5) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 16), 1uLL, memory_order_relaxed);
    }
    if (a3 != 1) {
      return;
    }
    uint64_t v6 = *(std::__shared_weak_count **)(a1 + 16);
    if (!v6) {
      return;
    }
LABEL_13:
    std::__shared_weak_count::__release_weak(v6);
    return;
  }
  if (a3 == 3)
  {
    long long v7 = (const char *)(*(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL);
    if (v7 == (const char *)((unint64_t)"ZZN29EnhancedWifiQosSlotController4initEvENK3$_0clEvEUlRK13PersonalityID"
                                                "RKNSt3__112basic_stringIcNS4_11char_traitsIcEENS4_9allocatorIcEEEEE_" & 0x7FFFFFFFFFFFFFFFLL)
      || !strcmp(v7, (const char *)((unint64_t)"ZZN29EnhancedWifiQosSlotController4initEvENK3$_0clEvEUlRK13PersonalityIDRKNSt3__112basic_stringIcNS4_11char_traitsIcEENS4_9allocatorIcEEEEE_" & 0x7FFFFFFFFFFFFFFFLL)))
    {
      *(void *)a2 = a1;
    }
    else
    {
      *(void *)a2 = 0;
    }
    return;
  }
  if (a3 != 2)
  {
LABEL_2:
    *(_WORD *)(a2 + 8) = 0;
    return;
  }
  uint64_t v6 = *(std::__shared_weak_count **)(a2 + 16);
  if (v6) {
    goto LABEL_13;
  }
}

void sub_100B3AF50(uint64_t *a1, uint64_t a2, unsigned __int8 *a3)
{
  std::runtime_error v4 = (std::__shared_weak_count *)a1[2];
  if (!v4) {
    return;
  }
  uint64_t v6 = *a1;
  long long v7 = std::__shared_weak_count::lock(v4);
  if (!v7) {
    return;
  }
  uint64_t v8 = v7;
  if (a1[1])
  {
    uint64_t v9 = a3[23];
    if ((v9 & 0x80u) == 0) {
      uint64_t v10 = a3[23];
    }
    else {
      uint64_t v10 = *((void *)a3 + 1);
    }
    uint64_t v11 = *(unsigned __int8 *)(v6 + 207);
    int v12 = (char)v11;
    if ((v11 & 0x80u) != 0) {
      uint64_t v11 = *(void *)(v6 + 192);
    }
    if (v10 == v11)
    {
      if (v12 >= 0) {
        uint64_t v13 = (unsigned __int8 *)(v6 + 184);
      }
      else {
        uint64_t v13 = *(unsigned __int8 **)(v6 + 184);
      }
      if ((v9 & 0x80) == 0)
      {
        if (a3[23])
        {
          while (*a3 == *v13)
          {
            ++a3;
            ++v13;
            if (!--v9) {
              goto LABEL_20;
            }
          }
          goto LABEL_23;
        }
        goto LABEL_20;
      }
      if (!memcmp(*(const void **)a3, v13, *((void *)a3 + 1)))
      {
LABEL_20:
        uint64_t v14 = *(NSObject **)(v6 + 40);
        if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)uint64_t v15 = 0;
          _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I Token Expired, clean it", v15, 2u);
        }
        (*(void (**)(void))(**(void **)(v6 + 56) + 32))(*(void *)(v6 + 56));
        sub_100B363C8(v6, 2u);
      }
    }
  }
LABEL_23:

  sub_10004D2C8(v8);
}

void sub_100B3B0B4(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100B3B0C8(uint64_t result, uint64_t *a2)
{
  if (a2 != (uint64_t *)result)
  {
    uint64_t v2 = a2;
    uint64_t v3 = (uint64_t *)result;
    uint64_t v4 = *a2;
    if (*a2)
    {
      *(void *)uint64_t result = v4;
      if (v4)
      {
        long long v7 = *(_OWORD *)(a2 + 1);
        *(void *)(result + 24) = a2[3];
        *(_OWORD *)(result + 8) = v7;
      }
      else
      {
        uint64_t result = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(v4 & 0xFFFFFFFFFFFFFFFELL))(a2 + 1, result + 8, 1);
      }
    }
    else
    {
      uint64_t v5 = *(void *)result;
      if (!*(void *)result) {
        return result;
      }
      if ((v5 & 1) == 0)
      {
        uint64_t v6 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v5 & 0xFFFFFFFFFFFFFFFELL);
        if (v6) {
          uint64_t result = v6(result + 8, result + 8, 2);
        }
      }
      uint64_t v2 = v3;
    }
    uint64_t *v2 = 0;
  }
  return result;
}

void sub_100B3B164(void *a1)
{
  __cxa_begin_catch(a1);
  void *v1 = 0;
  __cxa_rethrow();
}

void sub_100B3B174(_Unwind_Exception *a1)
{
}

uint64_t *sub_100B3B188(uint64_t *a1)
{
  uint64_t v2 = *a1;
  if (*a1)
  {
    if ((v2 & 1) == 0)
    {
      uint64_t v3 = *(void (**)(uint64_t *, uint64_t *, uint64_t))(v2 & 0xFFFFFFFFFFFFFFFELL);
      if (v3) {
        v3(a1 + 1, a1 + 1, 2);
      }
    }
    *a1 = 0;
  }
  return a1;
}

void *sub_100B3B1DC(void *a1)
{
  *a1 = off_101A3DF18;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_100B3B228(void *a1)
{
  *a1 = off_101A3DF18;
  uint64_t v1 = (std::__shared_weak_count *)a1[2];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

void sub_100B3B294(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1) {
    std::__shared_weak_count::lock(v1);
  }
  operator new();
}

void sub_100B3B344(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_100B3B35C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 16);
  return !v1 || *(void *)(v1 + 8) == -1;
}

void sub_100B3B37C()
{
}

void *sub_100B3B3E8(void *a1)
{
  *a1 = off_101A3DF68;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

void sub_100B3B434(void *a1)
{
  *a1 = off_101A3DF68;
  uint64_t v1 = (std::__shared_weak_count *)a1[2];
  if (v1) {
    sub_10004D2C8(v1);
  }

  operator delete();
}

void sub_100B3B4A0()
{
}

void sub_100B3B50C(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101A3DFA8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100B3B52C(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101A3DFA8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100B3B580(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 24) + 40))();
}

uint64_t sub_100B3B5A8(uint64_t a1)
{
  *(void *)a1 = off_101A3DFF8;
  if (*(char *)(a1 + 39) < 0) {
    operator delete(*(void **)(a1 + 16));
  }
  return a1;
}

void sub_100B3B5F8(uint64_t a1)
{
  *(void *)a1 = off_101A3DFF8;
  if (*(char *)(a1 + 39) < 0) {
    operator delete(*(void **)(a1 + 16));
  }

  operator delete();
}

void *sub_100B3B668(uint64_t a1)
{
  uint64_t v2 = operator new(0x28uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *v2 = off_101A3DFF8;
  v2[1] = v3;
  uint64_t v4 = v2 + 2;
  if (*(char *)(a1 + 39) < 0)
  {
    sub_10004FC84(v4, *(void **)(a1 + 16), *(void *)(a1 + 24));
  }
  else
  {
    *(_OWORD *)uint64_t v4 = *(_OWORD *)(a1 + 16);
    v2[4] = *(void *)(a1 + 32);
  }
  return v2;
}

void sub_100B3B6E0(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

char *sub_100B3B6F4(char *result, void *a2)
{
  uint64_t v2 = *((void *)result + 1);
  *a2 = off_101A3DFF8;
  a2[1] = v2;
  uint64_t v3 = a2 + 2;
  if (result[39] < 0) {
    return (char *)sub_10004FC84(v3, *((void **)result + 2), *((void *)result + 3));
  }
  long long v4 = *((_OWORD *)result + 1);
  a2[4] = *((void *)result + 4);
  *(_OWORD *)uint64_t v3 = v4;
  return result;
}

void sub_100B3B744(uint64_t a1)
{
  if (*(char *)(a1 + 39) < 0) {
    operator delete(*(void **)(a1 + 16));
  }
}

void sub_100B3B758(void **__p)
{
  if (*((char *)__p + 39) < 0) {
    operator delete(__p[2]);
  }

  operator delete(__p);
}

void sub_100B3B79C(uint64_t a1, uint64_t *a2, unsigned __int8 *a3)
{
  uint64_t v4 = *a2;
  uint64_t v3 = (std::__shared_weak_count *)a2[1];
  *a2 = 0;
  a2[1] = 0;
  int v5 = *a3;
  uint64_t v6 = *(void *)(a1 + 8);
  long long v7 = *(NSObject **)(v6 + 40);
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v9 = "True";
    if (!v5) {
      uint64_t v9 = "False";
    }
    *(_DWORD *)std::string buf = 136315138;
    double v34 = v9;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I get enableService response isSuccess %s", buf, 0xCu);
  }
  if (!v4)
  {
    if (!v5) {
      goto LABEL_31;
    }
LABEL_30:
    *(double *)(v6 + 152) = (double)sub_100B37D10(*(Registry **)(v6 + 80), v8);
    goto LABEL_31;
  }
  if (v5)
  {
    uint64_t v10 = *(const char ***)(v4 + 8);
    if (v10)
    {
      uint64_t v11 = *(NSObject **)(v6 + 40);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v13 = *v10;
        *(_DWORD *)std::string buf = 134217984;
        double v34 = v13;
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I expire in enableService response is %lld", buf, 0xCu);
      }
      uint64_t v14 = **(void **)(v4 + 8) - sub_100B37D10(*(Registry **)(v6 + 80), v12);
      if (v14 < 1)
      {
        uint64_t v24 = *(NSObject **)(v6 + 40);
        if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)std::string buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "#I No expire or expire is incorrect.", buf, 2u);
        }
      }
      else
      {
        uint64_t v15 = *(std::__shared_weak_count **)(v6 + 16);
        if (!v15 || (uint64_t v16 = *(void *)(v6 + 8), (v17 = std::__shared_weak_count::lock(v15)) == 0)) {
          sub_100088B9C();
        }
        uint64_t v18 = v17;
        memset(v32, 0, 24);
        atomic_fetch_add_explicit(&v17->__shared_weak_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v17);
        xpc_object_t v19 = operator new(0x20uLL);
        void *v19 = off_101A3E078;
        v19[1] = v6;
        uint64_t v19[2] = v16;
        v19[3] = v18;
        v32[3] = v19;
        Registry::getTimerService(&v27, *(Registry **)(v6 + 80));
        uint64_t v20 = v27;
        sub_100058DB0(v25, "enable.service.timer");
        *(_OWORD *)long long __p = *(_OWORD *)v25;
        uint64_t v31 = v26;
        v25[0] = 0;
        v25[1] = 0;
        uint64_t v26 = 0;
        sub_1000DA470((uint64_t)buf, (uint64_t)v32);
        (*(void (**)(uint64_t *__return_ptr, uint64_t, void **, uint64_t, uint64_t, void, uint8_t *))(*(void *)v20 + 40))(&v29, v20, __p, 1, 1000000 * v14, 0, buf);
        sub_10003B34C(buf);
        if (SHIBYTE(v31) < 0) {
          operator delete(__p[0]);
        }
        uint64_t v21 = v29;
        uint64_t v29 = 0;
        uint64_t v22 = *(void *)(v6 + 144);
        *(void *)(v6 + 144) = v21;
        if (v22)
        {
          (*(void (**)(uint64_t))(*(void *)v22 + 8))(v22);
          uint64_t v23 = v29;
          uint64_t v29 = 0;
          if (v23) {
            (*(void (**)(uint64_t))(*(void *)v23 + 8))(v23);
          }
        }
        if (SHIBYTE(v26) < 0) {
          operator delete(v25[0]);
        }
        if (v28) {
          sub_10004D2C8(v28);
        }
        sub_10003B34C(v32);
      }
      goto LABEL_30;
    }
  }
  if (v5) {
    goto LABEL_30;
  }
  if (*(_DWORD *)v4 == 6002) {
    sub_100B363C8(v6, 1u);
  }
LABEL_31:
  if (v3) {
    sub_10004D2C8(v3);
  }
}

void sub_100B3BB04(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, std::__shared_weak_count *a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,uint64_t a25)
{
  sub_10003B34C((void *)(v26 - 96));
  if (a23 < 0) {
    operator delete(__p);
  }
  if (a14 < 0) {
    operator delete(a9);
  }
  if (a16) {
    sub_10004D2C8(a16);
  }
  sub_10003B34C(&a25);
  if (v25) {
    sub_10004D2C8(v25);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100B3BB80(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_100B3BBC0()
{
}

void *sub_100B3BBCC(void *a1)
{
  *a1 = off_101A3E078;
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_100B3BC18(void *a1)
{
  *a1 = off_101A3E078;
  uint64_t v1 = (std::__shared_weak_count *)a1[3];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

char *sub_100B3BC84(uint64_t a1)
{
  uint64_t result = (char *)operator new(0x20uLL);
  *(void *)uint64_t result = off_101A3E078;
  *(_OWORD *)(result + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 24);
  *((void *)result + 3) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_100B3BCE8(uint64_t result, uint64_t a2)
{
  *(void *)a2 = off_101A3E078;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(result + 8);
  uint64_t v2 = *(void *)(result + 24);
  *(void *)(a2 + 24) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100B3BD28(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 24);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_100B3BD38(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete(__p);
}

void sub_100B3BD78(void *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2)
  {
    uint64_t v3 = a1[1];
    uint64_t v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      int v5 = v4;
      uint64_t v6 = (uint64_t *)a1[2];
      if (v6)
      {
        sub_100B379A4(v3, 1, v6);
        sub_100058DB0(__p, "service expired");
        sub_100B36730(v3, (std::string::size_type)__p);
        if (v8 < 0) {
          operator delete(__p[0]);
        }
      }
      sub_10004D2C8(v5);
    }
  }
}

void sub_100B3BE08(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  sub_10004D2C8(v15);
  _Unwind_Resume(a1);
}

uint64_t sub_100B3BE38(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100B3BE78()
{
}

void sub_100B3BE84()
{
}

void sub_100B3BEAC(uint64_t a1, uint64_t a2)
{
}

uint64_t sub_100B3BF34(wis::MetricFactory *a1)
{
  unsigned int v1 = a1;
  SharedMetricFactory = (wis::MetricFactory *)wis::MetricFactory::getSharedMetricFactory(a1);
  uint64_t v3 = wis::MetricFactory::newMetricContainerWithIdentifier(SharedMetricFactory, v1);
  if (v3)
  {
    uint64_t v4 = (wis::MetricContainer *)v3;
    int v5 = sub_10001C8F4(8);
    uint64_t v7 = *v5;
    uint64_t v6 = (std::__shared_weak_count *)v5[1];
    if (v6) {
      atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    if (v7) {
      operator new();
    }
    if (v6) {
      sub_10004D2C8(v6);
    }
    wis::MetricContainer::~MetricContainer(v4);
    operator delete();
  }
  return 0;
}

void sub_100B3C090(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  sub_100129880((wis::MetricContainer **)va, 0);
  _Unwind_Resume(a1);
}

uint64_t sub_100B3C114(uint64_t a1, int *a2)
{
  int v4 = a2[7];
  uint64_t v5 = a2[6];
  if ((int)v5 >= v4)
  {
    if (v4 == a2[8])
    {
      wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve((wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(a2 + 4), v4 + 1);
      int v4 = a2[7];
    }
    a2[7] = v4 + 1;
    sub_100B3C4F0();
  }
  uint64_t v6 = *((void *)a2 + 2);
  a2[6] = v5 + 1;
  uint64_t v7 = *(void *)(v6 + 8 * v5);
  char v8 = *(int **)(a1 + 32);
  int v9 = *(_DWORD *)(v7 + 44);
  LODWORD(v10) = v8[2];
  *(_DWORD *)(v7 + 44) = v9 | 1;
  DWORD1(v10) = v8[3];
  *(_DWORD *)(v7 + 44) = v9 | 3;
  DWORD2(v10) = v8[4];
  *(_DWORD *)(v7 + 44) = v9 | 7;
  HIDWORD(v10) = v8[5];
  *(_DWORD *)(v7 + 44) = v9 | 0xF;
  *(_OWORD *)(v7 + 8) = v10;
  int v11 = v8[6];
  *(_DWORD *)(v7 + 44) = v9 | 0x1F;
  int v12 = v8[7];
  *(_DWORD *)(v7 + 44) = v9 | 0x3F;
  *(_DWORD *)(v7 + 24) = v11;
  *(_DWORD *)(v7 + 28) = v12;
  int v13 = v8[8];
  *(_DWORD *)(v7 + 44) = v9 | 0x7F;
  int v14 = v8[14];
  *(_DWORD *)(v7 + 44) = v9 | 0xFF;
  *(_DWORD *)(v7 + 32) = v13;
  *(_DWORD *)(v7 + 36) = v14;
  int v15 = *v8;
  a2[20] |= 2u;
  a2[10] = v15;
  int IntValue = MCC::getIntValue((MCC *)(v8 + 16));
  a2[20] |= 8u;
  a2[11] = IntValue;
  uint64_t result = MCC::getIntValue((MCC *)(*(void *)(a1 + 32) + 96));
  int v18 = a2[20];
  a2[20] = v18 | 0x10;
  xpc_object_t v19 = *(int **)(a1 + 32);
  int v20 = v19[33];
  a2[20] = v18 | 0x30;
  a2[12] = result;
  a2[13] = v20;
  int v21 = *v19;
  int v22 = v19[32];
  if (v21 == 7)
  {
    int v23 = v18 | 0xB0;
    a2[15] = v22;
  }
  else
  {
    int v23 = v18 | 0x70;
    a2[14] = v22;
  }
  a2[20] = v23;
  return result;
}

void sub_100B3C29C(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 136))
  {
    if (*(char *)(a1 + 127) < 0) {
      operator delete(*(void **)(a1 + 104));
    }
    if (*(char *)(a1 + 95) < 0) {
      operator delete(*(void **)(a1 + 72));
    }
    *(unsigned char *)(a1 + 136) = 0;
  }
}

void sub_100B3C2E8(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a2 + 112))
  {
    if (*(char *)(a2 + 95) < 0) {
      operator delete(*(void **)(a2 + 72));
    }
    *(unsigned char *)(a2 + 112) = 0;
  }
}

uint64_t sub_100B3C384(uint64_t a1, int *a2)
{
  int v4 = a2[7];
  uint64_t v5 = a2[6];
  if ((int)v5 >= v4)
  {
    if (v4 == a2[8])
    {
      wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve((wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(a2 + 4), v4 + 1);
      int v4 = a2[7];
    }
    a2[7] = v4 + 1;
    sub_100B3C4F0();
  }
  uint64_t v6 = *((void *)a2 + 2);
  a2[6] = v5 + 1;
  uint64_t v7 = *(void *)(v6 + 8 * v5);
  char v8 = *(int **)(a1 + 32);
  int v9 = *(_DWORD *)(v7 + 44);
  LODWORD(v10) = v8[2];
  *(_DWORD *)(v7 + 44) = v9 | 1;
  DWORD1(v10) = v8[3];
  *(_DWORD *)(v7 + 44) = v9 | 3;
  DWORD2(v10) = v8[4];
  *(_DWORD *)(v7 + 44) = v9 | 7;
  HIDWORD(v10) = v8[5];
  *(_DWORD *)(v7 + 44) = v9 | 0xF;
  *(_OWORD *)(v7 + 8) = v10;
  int v11 = v8[6];
  *(_DWORD *)(v7 + 44) = v9 | 0x1F;
  int v12 = v8[7];
  *(_DWORD *)(v7 + 44) = v9 | 0x3F;
  *(_DWORD *)(v7 + 24) = v11;
  *(_DWORD *)(v7 + 28) = v12;
  int v13 = v8[8];
  *(_DWORD *)(v7 + 44) = v9 | 0x7F;
  int v14 = v8[14];
  *(_DWORD *)(v7 + 44) = v9 | 0xFF;
  *(_DWORD *)(v7 + 32) = v13;
  *(_DWORD *)(v7 + 36) = v14;
  int v15 = *v8;
  a2[20] |= 2u;
  a2[10] = v15;
  uint64_t result = MCC::getIntValue((MCC *)(v8 + 16));
  int v17 = a2[20];
  a2[20] = v17 | 8;
  a2[11] = result;
  int v18 = *(_DWORD **)(a1 + 32);
  int v19 = v18[24];
  a2[20] = v17 | 0x108;
  int v20 = v18[25];
  a2[20] = v17 | 0x308;
  a2[16] = v19;
  a2[17] = v20;
  LODWORD(v18) = v18[26];
  a2[20] = v17 | 0x708;
  a2[18] = (int)v18;
  return result;
}

void sub_100B3C4F0()
{
}

void sub_100B3C530()
{
}

void sub_100B3C554(void **a1)
{
  *a1 = off_101A3E1F8;
  uint64_t v2 = (void ***)(a1 + 1);
  uint64_t v3 = a1 + 2;
  sub_100465E6C(&v3);
  sub_100110A40(v2, 0);
  PB::Base::~Base((PB::Base *)a1);
}

void sub_100B3C5C4(void **a1)
{
  sub_100B3C554(a1);

  operator delete();
}

uint64_t sub_100B3C5FC(uint64_t result, uint64_t a2)
{
  *(void *)uint64_t result = off_101A3E1F8;
  *(_OWORD *)(result + 8) = 0u;
  *(_DWORD *)(result + 44) = 0;
  *(_OWORD *)(result + 24) = 0u;
  if (*(void *)(a2 + 8)) {
    operator new();
  }
  if (*(void *)(a2 + 16) != *(void *)(a2 + 24)) {
    sub_100744C5C();
  }
  if (*(unsigned char *)(a2 + 44))
  {
    char v2 = *(unsigned char *)(a2 + 40);
    *(unsigned char *)(result + 44) |= 1u;
    *(unsigned char *)(result + 40) = v2;
  }
  return result;
}

uint64_t sub_100B3C700(uint64_t a1, PB::TextFormatter *this, char *a3)
{
  PB::TextFormatter::beginObject(this, a3);
  uint64_t v5 = *(const PB::Data **)(a1 + 8);
  if (v5) {
    PB::TextFormatter::format(this, "csn", v5);
  }
  if (*(unsigned char *)(a1 + 44)) {
    PB::TextFormatter::format(this, "updateOnly", *(unsigned char *)(a1 + 40));
  }
  uint64_t v6 = *(uint64_t **)(a1 + 16);
  uint64_t v7 = *(uint64_t **)(a1 + 24);
  while (v6 != v7)
  {
    uint64_t v8 = *v6++;
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(void *)v8 + 32))(v8, this, "updatedSubscription");
  }

  return PB::TextFormatter::endObject(this);
}

uint64_t sub_100B3C7CC(uint64_t a1, PB::Reader *this)
{
  unint64_t v2 = *((void *)this + 1);
  unint64_t v3 = *((void *)this + 2);
  int v4 = *((unsigned __int8 *)this + 24);
  if (v2 < v3 && v4 == 0)
  {
    while (1)
    {
      uint64_t v8 = *(void *)this;
      if (v2 > 0xFFFFFFFFFFFFFFF5 || v2 + 10 > v3) {
        break;
      }
      char v9 = 0;
      unsigned int v10 = 0;
      unint64_t v11 = 0;
      while (1)
      {
        unint64_t v12 = v2 + 1;
        *((void *)this + 1) = v2 + 1;
        char v13 = *(unsigned char *)(v8 + v2);
        v11 |= (unint64_t)(v13 & 0x7F) << v9;
        if ((v13 & 0x80) == 0) {
          break;
        }
        v9 += 7;
        unint64_t v2 = v12;
        BOOL v14 = v10++ > 8;
        if (v14) {
          goto LABEL_19;
        }
      }
LABEL_24:
      unsigned __int8 v19 = v11 & 7;
      if ((v11 & 7) == 4)
      {
        int v4 = 0;
        return v4 == 0;
      }
      unint64_t v20 = v11 >> 3;
      if ((v11 >> 3) == 3)
      {
        *(unsigned char *)(a1 + 44) |= 1u;
        unint64_t v22 = *((void *)this + 1);
        if (v22 >= *((void *)this + 2))
        {
          BOOL v25 = 0;
          *((unsigned char *)this + 24) = 1;
        }
        else
        {
          unint64_t v23 = v22 + 1;
          int v24 = *(unsigned __int8 *)(*(void *)this + v22);
          *((void *)this + 1) = v23;
          BOOL v25 = v24 != 0;
        }
        *(unsigned char *)(a1 + 40) = v25;
      }
      else
      {
        if (v20 == 2) {
          sub_100745204();
        }
        if (v20 == 1) {
          operator new();
        }
LABEL_20:
        uint64_t result = PB::Reader::skip(this, v20, v19, 0);
        if (!result) {
          return result;
        }
      }
      unint64_t v2 = *((void *)this + 1);
      unint64_t v3 = *((void *)this + 2);
      int v4 = *((unsigned __int8 *)this + 24);
      if (v2 >= v3 || *((unsigned char *)this + 24)) {
        return v4 == 0;
      }
    }
    char v15 = 0;
    unsigned int v16 = 0;
    unint64_t v11 = 0;
    if (v2 > v3) {
      unint64_t v3 = v2;
    }
    while (v3 != v2)
    {
      unint64_t v17 = v2 + 1;
      char v18 = *(unsigned char *)(v8 + v2);
      *((void *)this + 1) = v17;
      v11 |= (unint64_t)(v18 & 0x7F) << v15;
      if ((v18 & 0x80) == 0) {
        goto LABEL_24;
      }
      v15 += 7;
      unint64_t v2 = v17;
      BOOL v14 = v16++ > 8;
      if (v14)
      {
LABEL_19:
        unsigned __int8 v19 = 0;
        LODWORD(v20) = 0;
        goto LABEL_20;
      }
    }
    int v4 = 1;
    *((unsigned char *)this + 24) = 1;
  }
  return v4 == 0;
}

uint64_t sub_100B3CA3C(uint64_t result, PB::Writer *this)
{
  uint64_t v3 = result;
  int v4 = *(const PB::Data **)(result + 8);
  if (v4) {
    uint64_t result = PB::Writer::write(this, v4, 1u);
  }
  uint64_t v5 = *(const PB::Base ***)(v3 + 16);
  uint64_t v6 = *(const PB::Base ***)(v3 + 24);
  while (v5 != v6)
  {
    uint64_t v7 = *v5++;
    uint64_t result = PB::Writer::writeSubmessage(this, v7, 2u);
  }
  if (*(unsigned char *)(v3 + 44))
  {
    char v8 = *(unsigned char *)(v3 + 40);
    return PB::Writer::write(this, v8, 3u);
  }
  return result;
}

void TransportMasterController::setupAwdMetricCallbacks_sync(TransportMasterController *this)
{
  sub_10003E168(&v2, (void *)this + 1);
  unsigned int v1 = v3;
  if (v3)
  {
    atomic_fetch_add_explicit(&v3->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v1);
  }
  if (v1) {
    atomic_fetch_add_explicit(&v1->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  }
  sub_10017B514();
  if (v1)
  {
    std::__shared_weak_count::__release_weak(v1);
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_100B3CBAC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16)
{
  if (a16) {
    std::__shared_weak_count::__release_weak(a16);
  }
  if (v16) {
    std::__shared_weak_count::__release_weak(v16);
  }
  _Unwind_Resume(exception_object);
}

void sub_100B3CBD0(void *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[6];
  if (v2)
  {
    uint64_t v3 = a1[4];
    int v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      if (a1[5])
      {
        uint64_t v5 = a1[6];
        if (v5) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 16), 1uLL, memory_order_relaxed);
        }
        v6[0] = 0;
        v6[1] = 0;
        sub_10003E168(v6, (void *)(v3 + 8));
        operator new();
      }
      sub_10004D2C8(v4);
    }
  }
}

uint64_t sub_100B3CD10(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100B3CD2C(uint64_t a1)
{
  unsigned int v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

double sub_100B3CD3C(uint64_t a1, _DWORD *a2)
{
  uint64_t v3 = *(_DWORD **)(a1 + 32);
  BOOL isDynamicCellularDataSwitchingSupported_sync = TransportMasterController::isDynamicCellularDataSwitchingSupported_sync((TransportMasterController *)v3);
  BOOL v5 = isDynamicCellularDataSwitchingSupported_sync;
  if ((awd::metrics::switch_state_t_IsValid((awd::metrics *)isDynamicCellularDataSwitchingSupported_sync, v6) & 1) == 0) {
    __assert_rtn("set_switchstate", "CCMetricsAdHoc.pb.h", 28562, "::awd::metrics::switch_state_t_IsValid(value)");
  }
  int v7 = a2[11];
  a2[11] = v7 | 2;
  int v8 = v3[179];
  a2[11] = v7 | 6;
  a2[4] = v5;
  a2[5] = v8;
  int v9 = v3[181];
  a2[11] = v7 | 0xE;
  int v10 = v3[180];
  a2[11] = v7 | 0x1E;
  a2[6] = v9;
  a2[7] = v10;
  v3[181] = 0;
  double result = 0.0;
  *(void *)(v3 + 179) = 0;
  return result;
}

uint64_t *sub_100B3CDE4(uint64_t **a1)
{
  unsigned int v1 = *a1;
  unint64_t v12 = a1;
  v13[0] = (uint64_t)v1;
  uint64_t v2 = (std::__shared_weak_count *)v1[2];
  if (v2)
  {
    uint64_t v3 = *v1;
    int v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      BOOL v5 = v4;
      if (v1[1])
      {
        v13[1] = (uint64_t)_NSConcreteStackBlock;
        v13[2] = 0x40000000;
        v13[3] = (uint64_t)sub_100B3CD3C;
        void v13[4] = (uint64_t)&unk_101A3E268;
        v13[5] = v3;
        SharedMetricFactory = (wis::MetricFactory *)wis::MetricFactory::getSharedMetricFactory((wis::MetricFactory *)v4);
        int v7 = (wis::MetricContainer *)wis::MetricFactory::newMetricContainerWithIdentifier(SharedMetricFactory, 0x80124u);
        v13[6] = (uint64_t)v7;
        if (v7)
        {
          int v8 = sub_10001C8F4(8);
          uint64_t v10 = *v8;
          int v9 = (std::__shared_weak_count *)v8[1];
          if (v9) {
            atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          if (v10) {
            operator new();
          }
          if (v9) {
            sub_10004D2C8(v9);
          }
          if (v7)
          {
            wis::MetricContainer::~MetricContainer(v7);
            operator delete();
          }
        }
      }
      sub_10004D2C8(v5);
    }
  }
  sub_100004A84(v13);
  return sub_100046B58((uint64_t *)&v12);
}

void sub_100B3CFAC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, wis::MetricContainer *a16)
{
  if (v17) {
    sub_10004D2C8(v17);
  }
  sub_100129880(&a16, 0);
  sub_10004D2C8(v16);
  sub_100004A84(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t sub_100B3D058(uint64_t a1, NSObject **a2, void *a3, void *a4, void *a5)
{
  *(void *)a1 = off_101A3E520;
  uint64_t v10 = (void *)(a1 + 8);
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v20, kCtLoggingSystemName, "cp.tr.ctr");
  *uint64_t v10 = 0;
  v10[1] = 0;
  unint64_t v11 = *a2;
  *(void *)(a1 + 24) = *a2;
  if (v11) {
    dispatch_retain(v11);
  }
  *(void *)(a1 + 32) = 0;
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v21, &v20);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 40), (const ctu::OsLogLogger *)v21);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v21);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v20);
  *(void *)a1 = off_101A3E298;
  *(void *)(a1 + 48) = *a4;
  uint64_t v12 = a4[1];
  *(void *)(a1 + 56) = v12;
  if (v12) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v12 + 8), 1uLL, memory_order_relaxed);
  }
  *(void *)(a1 + 64) = *a3;
  uint64_t v13 = a3[1];
  *(void *)(a1 + 72) = v13;
  if (v13) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v13 + 16), 1uLL, memory_order_relaxed);
  }
  *(void *)(a1 + 80) = *a5;
  uint64_t v14 = a5[1];
  *(void *)(a1 + 88) = v14;
  if (v14) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v14 + 16), 1uLL, memory_order_relaxed);
  }
  *(void *)(a1 + 256) = 0;
  *(unsigned char *)(a1 + 264) = 0;
  *(unsigned char *)(a1 + 360) = 0;
  *(void *)(a1 + 376) = 0;
  *(void *)(a1 + 384) = 0;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 129) = 0u;
  *(_OWORD *)(a1 + 145) = 0u;
  *(_OWORD *)(a1 + 161) = 0u;
  *(_OWORD *)(a1 + 177) = 0u;
  *(_OWORD *)(a1 + 193) = 0u;
  *(_OWORD *)(a1 + 209) = 0u;
  *(void *)(a1 + 224) = 0;
  *(_OWORD *)(a1 + 296) = 0u;
  *(_OWORD *)(a1 + 312) = 0u;
  *(_OWORD *)(a1 + 321) = 0u;
  *(void *)(a1 + 368) = a1 + 376;
  *(void *)(a1 + 416) = 0;
  *(unsigned char *)(a1 + 424) = 0;
  *(unsigned char *)(a1 + 480) = 0;
  *(void *)(a1 + 512) = 0;
  sub_100058DB0(&__p, "CellularPlanTransferFlowController");
  char v15 = *(NSObject **)(a1 + 24);
  unint64_t v17 = v15;
  if (v15) {
    dispatch_retain(v15);
  }
  ctu::RestModule::RestModule();
  if (v17) {
    dispatch_release(v17);
  }
  if (v19 < 0) {
    operator delete(__p);
  }
  *(void *)(a1 + 560) = 0;
  *(_OWORD *)(a1 + 576) = 0u;
  *(void *)(a1 + 568) = a1 + 576;
  *(unsigned char *)(a1 + 592) = 0;
  *(_OWORD *)(a1 + 600) = 0u;
  *(_OWORD *)(a1 + 616) = 0u;
  *(_OWORD *)(a1 + 632) = 0u;
  *(void *)(a1 + 648) = a1 + 656;
  *(_OWORD *)(a1 + 728) = 0u;
  *(_OWORD *)(a1 + 656) = 0u;
  *(_OWORD *)(a1 + 672) = 0u;
  *(_OWORD *)(a1 + 688) = 0u;
  *(_OWORD *)(a1 + 704) = 0u;
  *(void *)(a1 + 720) = a1 + 728;
  *(unsigned char *)(a1 + 744) = 0;
  *(unsigned char *)(a1 + 768) = 0;
  *(unsigned char *)(a1 + 840) = 0;
  *(_WORD *)(a1 + 848) = 0;
  *(void *)(a1 + 872) = 0;
  *(_OWORD *)(a1 + 856) = 0u;
  *(_OWORD *)(a1 + 888) = 0u;
  *(_OWORD *)(a1 + 776) = 0u;
  *(_OWORD *)(a1 + 792) = 0u;
  *(_OWORD *)(a1 + 801) = 0u;
  *(void *)(a1 + 880) = a1 + 888;
  *(_OWORD *)(a1 + 912) = 0u;
  *(_OWORD *)(a1 + 936) = 0u;
  *(void *)(a1 + 904) = a1 + 912;
  *(void *)(a1 + 928) = a1 + 936;
  *(_OWORD *)(a1 + 1000) = 0u;
  *(unsigned char *)(a1 + 984) = 0;
  *(void *)(a1 + 968) = 0;
  *(_OWORD *)(a1 + 952) = 0u;
  *(unsigned char *)(a1 + 976) = 0;
  *(void *)(a1 + 992) = a1 + 1000;
  *(unsigned char *)(a1 + 1016) = 0;
  *(unsigned char *)(a1 + 1020) = 0;
  *(unsigned char *)(a1 + 1024) = 0;
  *(unsigned char *)(a1 + 1028) = 0;
  *(_OWORD *)(a1 + 1032) = 0u;
  return a1;
}

void sub_100B3D330(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, dispatch_object_t object, dispatch_object_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,char a21)
{
  if (object) {
    dispatch_release(object);
  }
  if (a12) {
    dispatch_release(a12);
  }
  if (a18 < 0) {
    operator delete(__p);
  }
  sub_10003B34C((void *)(v21 + 488));
  sub_100B6136C(v21 + 424);
  sub_10023D374((void *)(v21 + 392));
  sub_10005CD2C(v21 + 368, *(char **)(v21 + 376));
  if (*(unsigned char *)(v21 + 360) && *(char *)(v21 + 359) < 0) {
    operator delete(*(void **)(v21 + 336));
  }
  a19 = v21 + 304;
  sub_100B613B8((void ***)&a19);
  sub_100060644((void *)(v21 + 272));
  sub_100313790((void *)(v21 + 232));
  BOOL v25 = *(std::__shared_weak_count **)(v21 + 224);
  if (v25) {
    sub_10004D2C8(v25);
  }
  a19 = v21 + 192;
  sub_10010DF1C((void ***)&a19);
  a19 = v21 + 168;
  sub_10034251C((void ***)&a19);
  a19 = v21 + 144;
  sub_1000C5238((void ***)&a19);
  uint64_t v26 = *(std::__shared_weak_count **)(v21 + 120);
  if (v26) {
    sub_10004D2C8(v26);
  }
  uint64_t v27 = *(std::__shared_weak_count **)(v21 + 104);
  if (v27) {
    sub_10004D2C8(v27);
  }
  uint64_t v28 = *(std::__shared_weak_count **)(v21 + 88);
  if (v28) {
    std::__shared_weak_count::__release_weak(v28);
  }
  uint64_t v29 = *(std::__shared_weak_count **)(v21 + 72);
  if (v29) {
    std::__shared_weak_count::__release_weak(v29);
  }
  std::string::size_type v30 = *(std::__shared_weak_count **)(v21 + 56);
  if (v30) {
    sub_10004D2C8(v30);
  }
  ctu::OsLogLogger::~OsLogLogger(v23);
  sub_100087E88(v22);
  _Unwind_Resume(a1);
}

uint64_t sub_100B3D49C(uint64_t a1)
{
  *(void *)a1 = off_101A3E298;
  uint64_t v2 = (ctu::OsLogLogger *)(a1 + 40);
  uint64_t v3 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)std::string buf = 134217984;
    *(void *)&uint8_t buf[4] = a1;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I destructor tr.ctr : %p", buf, 0xCu);
  }
  int v4 = *(std::__shared_weak_count **)(a1 + 72);
  if (v4)
  {
    BOOL v5 = std::__shared_weak_count::lock(v4);
    if (v5)
    {
      int v6 = v5;
      uint64_t v7 = *(void *)(a1 + 64);
      if (v7)
      {
        uint64_t v8 = *(void *)(a1 + 304);
        uint64_t v9 = *(void *)(a1 + 312);
        while (v8 != v9)
        {
          if (*(unsigned char *)(v8 + 1460))
          {
            uint64_t v10 = *(void *)(v8 + 1032);
            uint64_t v11 = *(void *)(v8 + 1040);
            if (*(char *)(v8 + 1071) < 0)
            {
              sub_10004FC84(__dst, *(void **)(v8 + 1048), *(void *)(v8 + 1056));
            }
            else
            {
              long long v12 = *(_OWORD *)(v8 + 1048);
              uint64_t v32 = *(void *)(v8 + 1064);
              *(_OWORD *)long long __dst = v12;
            }
            uint64_t v13 = *(void *)(v8 + 1168);
            uint64_t v14 = *(void *)(v8 + 1176);
            if (*(char *)(v8 + 1279) < 0)
            {
              sub_10004FC84(__p, *(void **)(v8 + 1256), *(void *)(v8 + 1264));
            }
            else
            {
              long long v15 = *(_OWORD *)(v8 + 1256);
              uint64_t v30 = *(void *)(v8 + 1272);
              *(_OWORD *)long long __p = v15;
            }
            (*(void (**)(uint64_t, uint64_t, uint64_t, void **, uint64_t, uint64_t, void **, uint64_t))(*(void *)v7 + 24))(v7, v10, v11, __dst, v13, v14, __p, 3);
            if (SHIBYTE(v30) < 0) {
              operator delete(__p[0]);
            }
            if (SHIBYTE(v32) < 0) {
              operator delete(__dst[0]);
            }
          }
          v8 += 1520;
        }
      }
      sub_10004D2C8(v6);
    }
  }
  uint64_t v16 = *(void *)(a1 + 1040);
  *(void *)(a1 + 1040) = 0;
  if (v16) {
    (*(void (**)(uint64_t))(*(void *)v16 + 8))(v16);
  }
  sub_100B63EF8((uint64_t **)(a1 + 1032), 0);
  sub_100B6143C(*(void **)(a1 + 1000));
  uint64_t v17 = *(void *)(a1 + 968);
  *(void *)(a1 + 968) = 0;
  if (v17) {
    (*(void (**)(uint64_t))(*(void *)v17 + 8))(v17);
  }
  uint64_t v18 = *(void *)(a1 + 960);
  *(void *)(a1 + 960) = 0;
  if (v18) {
    (*(void (**)(uint64_t))(*(void *)v18 + 8))(v18);
  }
  uint64_t v19 = *(void *)(a1 + 952);
  *(void *)(a1 + 952) = 0;
  if (v19) {
    (*(void (**)(uint64_t))(*(void *)v19 + 8))(v19);
  }
  sub_10005CD2C(a1 + 928, *(char **)(a1 + 936));
  sub_1001FEC70(*(void **)(a1 + 912));
  sub_10008E5B8(a1 + 880, *(void **)(a1 + 888));
  *(void *)std::string buf = a1 + 856;
  sub_10030AFC8((void ***)buf);
  if (*(unsigned char *)(a1 + 840)) {
    sub_10005CD2C(a1 + 816, *(char **)(a1 + 824));
  }
  OsLogContext v20 = *(std::__shared_weak_count **)(a1 + 808);
  if (v20) {
    sub_10004D2C8(v20);
  }
  if (*(char *)(a1 + 799) < 0) {
    operator delete(*(void **)(a1 + 776));
  }
  if (*(unsigned char *)(a1 + 768) && *(char *)(a1 + 767) < 0) {
    operator delete(*(void **)(a1 + 744));
  }
  sub_1000886C0(a1 + 720, *(char **)(a1 + 728));
  if (*(char *)(a1 + 719) < 0) {
    operator delete(*(void **)(a1 + 696));
  }
  if (*(char *)(a1 + 695) < 0) {
    operator delete(*(void **)(a1 + 672));
  }
  sub_10023A670(a1 + 648, *(void **)(a1 + 656));
  *(void *)std::string buf = a1 + 624;
  sub_10008A88C((void ***)buf);
  *(void *)std::string buf = a1 + 600;
  sub_1000C56F4((void ***)buf);
  sub_100030EE0(a1 + 568, *(char **)(a1 + 576));
  sub_100B612E8((void *)(a1 + 536));
  uint64_t v21 = *(std::__shared_weak_count **)(a1 + 528);
  if (v21) {
    sub_10004D2C8(v21);
  }
  sub_10003B34C((void *)(a1 + 488));
  sub_100B6136C(a1 + 424);
  sub_10023D374((void *)(a1 + 392));
  sub_10005CD2C(a1 + 368, *(char **)(a1 + 376));
  if (*(unsigned char *)(a1 + 360) && *(char *)(a1 + 359) < 0) {
    operator delete(*(void **)(a1 + 336));
  }
  *(void *)std::string buf = a1 + 304;
  sub_100B613B8((void ***)buf);
  sub_100060644((void *)(a1 + 272));
  sub_100313790((void *)(a1 + 232));
  unint64_t v22 = *(std::__shared_weak_count **)(a1 + 224);
  if (v22) {
    sub_10004D2C8(v22);
  }
  *(void *)std::string buf = a1 + 192;
  sub_10010DF1C((void ***)buf);
  *(void *)std::string buf = a1 + 168;
  sub_10034251C((void ***)buf);
  *(void *)std::string buf = a1 + 144;
  sub_1000C5238((void ***)buf);
  unint64_t v23 = *(std::__shared_weak_count **)(a1 + 120);
  if (v23) {
    sub_10004D2C8(v23);
  }
  int v24 = *(std::__shared_weak_count **)(a1 + 104);
  if (v24) {
    sub_10004D2C8(v24);
  }
  BOOL v25 = *(std::__shared_weak_count **)(a1 + 88);
  if (v25) {
    std::__shared_weak_count::__release_weak(v25);
  }
  uint64_t v26 = *(std::__shared_weak_count **)(a1 + 72);
  if (v26) {
    std::__shared_weak_count::__release_weak(v26);
  }
  uint64_t v27 = *(std::__shared_weak_count **)(a1 + 56);
  if (v27) {
    sub_10004D2C8(v27);
  }
  ctu::OsLogLogger::~OsLogLogger(v2);
  sub_100087E88((void *)(a1 + 8));
  return a1;
}

void sub_100B3D940(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_10006A6AC(a1);
}

void sub_100B3D950(uint64_t a1)
{
  sub_100B3D49C(a1);

  operator delete();
}

void sub_100B3D988(uint64_t a1, uint64_t *a2, uint64_t *a3, char a4, uint64_t a5, const std::string *a6, uint64_t a7, const std::string *a8, uint64_t a9, uint64_t a10, const std::string **a11)
{
  uint64_t v19 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)std::string buf = 134217984;
    *(void *)&uint8_t buf[4] = a1;
    _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#I Target Transfer Controller init. %p", buf, 0xCu);
  }
  (***(void (****)(uint8_t *__return_ptr))(a1 + 48))(buf);
  Registry::createRestModuleOneTimeUseConnection(&v53, *(Registry **)buf);
  ctu::RestModule::connect();
  if (v54) {
    sub_10004D2C8(v54);
  }
  if (*(void *)&buf[8]) {
    sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
  }
  if ((uint64_t *)(a1 + 600) != a2) {
    sub_1003DB294(a1 + 600, *a2, a2[1], 0x2E8BA2E8BA2E8BA3 * ((a2[1] - *a2) >> 3));
  }
  if ((uint64_t *)(a1 + 624) != a3) {
    sub_1003DB990(a1 + 624, *a3, a3[1], 0xCF3CF3CF3CF3CF3DLL * ((a3[1] - *a3) >> 3));
  }
  *(unsigned char *)(a1 + 131) = a4;
  if (a1 + 648 != a7) {
    sub_100426EA4((uint64_t **)(a1 + 648), *(long long **)a7, (long long *)(a7 + 8));
  }
  std::string::operator=((std::string *)(a1 + 672), a8);
  if (a1 + 720 != a5) {
    sub_100429B2C((uint64_t **)(a1 + 720), *(void **)a5, (void *)(a5 + 8));
  }
  sub_100179AF8((std::string *)(a1 + 744), a6);
  (***(void (****)(uint8_t *__return_ptr))(a1 + 48))(buf);
  ServiceMap = (std::mutex *)Registry::getServiceMap(v20, *(Registry **)buf);
  unint64_t v22 = ServiceMap;
  if (v23 < 0)
  {
    int v24 = (unsigned __int8 *)(v23 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v25 = 5381;
    do
    {
      uint64_t v23 = v25;
      unsigned int v26 = *v24++;
      uint64_t v25 = (33 * v25) ^ v26;
    }
    while (v26);
  }
  std::mutex::lock(ServiceMap);
  __p[0] = (void *)v23;
  uint64_t v27 = sub_10004D37C(&v22[1].__m_.__sig, (unint64_t *)__p);
  if (v27)
  {
    uint64_t v29 = v27[3];
    uint64_t v28 = (std::__shared_weak_count *)v27[4];
    if (v28)
    {
      atomic_fetch_add_explicit(&v28->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v22);
      atomic_fetch_add_explicit(&v28->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v28);
      char v30 = 0;
      goto LABEL_23;
    }
  }
  else
  {
    uint64_t v29 = 0;
  }
  std::mutex::unlock(v22);
  uint64_t v28 = 0;
  char v30 = 1;
LABEL_23:
  if (*(void *)&buf[8]) {
    sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
  }
  if (v29)
  {
    (*(void (**)(uint8_t *__return_ptr, uint64_t))(*(void *)v29 + 248))(buf, v29);
    uint64_t v31 = (void **)(a1 + 776);
    if (*(char *)(a1 + 799) < 0) {
      operator delete(*v31);
    }
    *(_OWORD *)uint64_t v31 = *(_OWORD *)buf;
    *(void *)(a1 + 792) = v56;
  }
  if ((v30 & 1) == 0) {
    sub_10004D2C8(v28);
  }
  uint64_t v32 = (uint8_t *)(a1 + 536);
  *(void *)std::string buf = off_101A3E7D0;
  *(void *)&uint8_t buf[8] = a1 + 520;
  int v57 = buf;
  if (buf != (uint8_t *)(a1 + 536))
  {
    double v33 = *(uint8_t **)(a1 + 560);
    if (v33 == v32)
    {
      __p[1] = (void *)(a1 + 520);
      uint64_t v59 = 0;
      int v57 = 0;
      __p[0] = off_101A3E7D0;
      (*(void (**)(uint64_t, uint8_t *))(*(void *)v32 + 24))(a1 + 536, buf);
      (*(void (**)(void))(**(void **)(a1 + 560) + 32))(*(void *)(a1 + 560));
      *(void *)(a1 + 560) = 0;
      int v57 = buf;
      (*((void (**)(void **, uint64_t))__p[0] + 3))(__p, a1 + 536);
      (*((void (**)(void **))__p[0] + 4))(__p);
    }
    else
    {
      *(void *)(a1 + 536) = off_101A3E7D0;
      *(void *)(a1 + 544) = a1 + 520;
      int v57 = v33;
    }
    *(void *)(a1 + 560) = v32;
  }
  sub_100B612E8(buf);
  uint64_t v34 = *(void *)(a1 + 560);
  if (v34) {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v34 + 48))(v34, a1 + 568);
  }
  std::string::size_type v35 = *(std::__shared_weak_count **)(a1 + 16);
  if (!v35 || (uint64_t v36 = *(void *)(a1 + 8), (v37 = std::__shared_weak_count::lock(v35)) == 0)) {
    sub_100088B9C();
  }
  unsigned int v38 = v37;
  atomic_fetch_add_explicit(&v37->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v37);
  sub_100058DB0(__p, "/cc/events/pending_install_plan_push_notification_received");
  uint64_t v39 = (uint8_t *)operator new(0x20uLL);
  *(void *)uint64_t v39 = off_101A3E860;
  *((void *)v39 + 1) = v36;
  *((void *)v39 + 2) = v38;
  *((void *)v39 + 3) = a1;
  int v57 = v39;
  ctu::RestModule::observeEvent();
  sub_10003F600(buf);
  if (SHIBYTE(v59) < 0) {
    operator delete(__p[0]);
  }
  sub_1000DDC20(a1 + 592);
  double v40 = (void **)(a1 + 856);
  uint64_t v41 = *(void *)(a1 + 856);
  if (v41)
  {
    uint64_t v42 = *(void *)(a1 + 864);
    uint64_t v43 = *(void **)(a1 + 856);
    if (v42 != v41)
    {
      do
        uint64_t v42 = sub_10030D10C(v42 - 1248);
      while (v42 != v41);
      uint64_t v43 = *v40;
    }
    *(void *)(a1 + 864) = v41;
    operator delete(v43);
    *double v40 = 0;
    *(void *)(a1 + 864) = 0;
    *(void *)(a1 + 872) = 0;
  }
  *(_OWORD *)double v40 = *(_OWORD *)a10;
  *(void *)(a1 + 872) = *(void *)(a10 + 16);
  *(void *)a10 = 0;
  *(void *)(a10 + 8) = 0;
  *(void *)(a10 + 16) = 0;
  (*(void (**)(uint8_t *__return_ptr))(**(void **)(a1 + 48) + 584))(buf);
  long long v44 = *(_OWORD *)buf;
  memset(buf, 0, sizeof(buf));
  id v45 = *(std::__shared_weak_count **)(a1 + 120);
  *(_OWORD *)(a1 + 112) = v44;
  if (v45)
  {
    sub_10004D2C8(v45);
    if (*(void *)&buf[8]) {
      sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
    }
  }
  uint64_t v46 = *a11;
  if (*a11)
  {
    std::string::operator=((std::string *)(a1 + 696), v46 + 4);
    uint64_t v46 = *a11;
  }
  uint64_t v47 = a11[1];
  if (v47) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)&v47->__r_.__value_.__l.__size_, 1uLL, memory_order_relaxed);
  }
  *(void *)(a1 + 800) = v46;
  id v48 = *(std::__shared_weak_count **)(a1 + 808);
  *(void *)(a1 + 808) = v47;
  if (v48) {
    sub_10004D2C8(v48);
  }
  uint64_t v49 = *(std::__shared_weak_count **)(a1 + 88);
  if (v49)
  {
    id v50 = std::__shared_weak_count::lock(v49);
    if (v50)
    {
      uint64_t v51 = v50;
      uint64_t v52 = *(void *)(a1 + 80);
      if (v52)
      {
        (*(void (**)(uint8_t *__return_ptr))(*(void *)v52 + 296))(buf);
        sub_100B61500(a1 + 816, (uint64_t)buf);
        if ((_BYTE)v57) {
          sub_10005CD2C((uint64_t)buf, *(char **)&buf[8]);
        }
      }
      sub_10004D2C8(v51);
    }
  }
}

void sub_100B3E034(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_100B3E0E0(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    if ((*(unsigned char *)(a1 + 128) - 1) > 3u) {
      uint64_t v3 = "kUnknown";
    }
    else {
      uint64_t v3 = off_101A3FD50[(char)(*(unsigned char *)(a1 + 128) - 1)];
    }
    int v4 = *(unsigned __int8 *)(a1 + 129);
    int v5 = *(unsigned __int8 *)(a1 + 130);
    *(_DWORD *)std::string buf = 136315650;
    *(void *)&uint8_t buf[4] = v3;
    *(_WORD *)&unsigned char buf[12] = 1024;
    *(_DWORD *)uint64_t v21 = v4;
    *(_WORD *)&v21[4] = 1024;
    *(_DWORD *)unint64_t v22 = v5;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I List source: (%s), Local transfer: (%{BOOL}d), QR Code transfer: (%{BOOL}d)", buf, 0x18u);
    uint64_t v2 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    int v6 = *(unsigned __int8 *)(a1 + 134);
    BOOL v7 = *(void *)(a1 + 416) != 0;
    int v8 = *(unsigned __int8 *)(a1 + 135);
    int v9 = *(unsigned __int8 *)(a1 + 137);
    int v10 = *(unsigned __int8 *)(a1 + 138);
    int v11 = *(unsigned __int8 *)(a1 + 139);
    int v12 = *(unsigned __int8 *)(a1 + 848);
    *(_DWORD *)std::string buf = 67110656;
    *(_DWORD *)&uint8_t buf[4] = v6;
    *(_WORD *)&uint8_t buf[8] = 1024;
    *(_DWORD *)&buf[10] = v7;
    *(_WORD *)uint64_t v21 = 1024;
    *(_DWORD *)&v21[2] = v8;
    *(_WORD *)unint64_t v22 = 1024;
    *(_DWORD *)&v22[2] = v9;
    __int16 v23 = 1024;
    int v24 = v10;
    __int16 v25 = 1024;
    int v26 = v11;
    __int16 v27 = 1024;
    int v28 = v12;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Plan data available: (%{BOOL}d), Transfer ongoing: (%{BOOL}d), Awaiting CUMessage resp: (%{BOOL}d), Awaiting push: (%{BOOL}d), Awaiting TSS: (%{BOOL}d), Awaiting TSS webservice: (%{BOOL}d), Denylist Uploaded: (%{BOOL}d)", buf, 0x2Cu);
    uint64_t v2 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    int v13 = -723362913 * ((*(void *)(a1 + 312) - *(void *)(a1 + 304)) >> 4);
    *(_DWORD *)std::string buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v13;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Target ent data map size: %d", buf, 8u);
  }
  uint64_t v14 = *(void *)(a1 + 304);
  for (uint64_t i = *(void *)(a1 + 312); v14 != i; v14 += 1520)
  {
    uint64_t v16 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      sub_100991C78(v14, buf);
      if (v22[3] >= 0) {
        uint64_t v17 = buf;
      }
      else {
        uint64_t v17 = *(unsigned char **)buf;
      }
      *(_DWORD *)uint64_t v18 = 136315138;
      uint64_t v19 = v17;
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I %s", v18, 0xCu);
      if ((v22[3] & 0x80000000) != 0) {
        operator delete(*(void **)buf);
      }
    }
  }
}

void sub_100B3E384(uint64_t a1, const void **a2)
{
  uint64_t v16 = 0;
  uint64_t v17 = 0;
  (***(void (****)(Registry **__return_ptr))(a1 + 48))(&v12);
  Registry::getNotificationSenderFactory((uint64_t *)buf, v12);
  uint64_t v4 = *(void *)buf;
  (***(void (****)(Registry **__return_ptr))(a1 + 48))(&v8);
  Registry::getTimerService(&v10, v8);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t *, uint64_t))(*(void *)v4 + 160))(&v16, v4, &v10, a1 + 24);
  if (v11) {
    sub_10004D2C8(v11);
  }
  if (v9) {
    sub_10004D2C8(v9);
  }
  if (v15) {
    sub_10004D2C8(v15);
  }
  if (v13) {
    sub_10004D2C8(v13);
  }
  uint64_t v5 = v16;
  if (v16)
  {
    sub_100058198(&v7, a2);
    (*(void (**)(uint64_t, const void **))(*(void *)v5 + 40))(v5, &v7);
    sub_100057D78(&v7);
  }
  else
  {
    int v6 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "invalid CellularPlanManagementSender", buf, 2u);
    }
  }
  if (v17) {
    sub_10004D2C8(v17);
  }
}

void sub_100B3E52C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100057D78((const void **)va);
  uint64_t v4 = *(std::__shared_weak_count **)(v2 - 40);
  if (v4) {
    sub_10004D2C8(v4);
  }
  _Unwind_Resume(a1);
}

void sub_100B3E598(void *a1, unsigned __int8 **a2, unsigned __int8 *a3, char a4, const void **a5, char *a6, const void **a7, unsigned __int8 a8, char a9, uint64_t a10, uint64_t *a11)
{
  if (a9 && !*(unsigned char *)(*a11 + 1465)) {
    *(_WORD *)(*a11 + 1464) = a8 | 0x100;
  }
  if (*(unsigned char *)(a10 + 4) && *(_DWORD *)a10 != 70000)
  {
    uint64_t v18 = *a11;
    *(_DWORD *)(v18 + 1468) = *(_DWORD *)a10;
    *(unsigned char *)(v18 + 1472) = 1;
  }
  if (*(unsigned char *)(*a11 + 1514)) {
    sub_100B3E764(a1, (uint64_t)a2, 1);
  }
  uint64_t v19 = *a3;
  int v20 = *a6;
  sub_100083DA4(&v30, a5);
  sub_100058198(&v29, a7);
  sub_100B3EA60((uint64_t)a1, (uint64_t)a2, v19, v20, &v30, &v29);
  sub_100057D78(&v29);
  sub_1000558F4(&v30);
  sub_100B3F0F4((uint64_t)v21, a1[38], a1[39], a2);
  v23[0] = a4;
  *(_OWORD *)long long __p = *(_OWORD *)v21;
  uint64_t v25 = v22;
  v21[0] = 0;
  v21[1] = 0;
  uint64_t v22 = 0;
  sub_100083DA4(&v26, a5);
  sub_100058198(&v27, a7);
  char v28 = *a6;
  sub_100B3F218((uint64_t)(a1 + 53), (uint64_t)v23);
  sub_100057D78(&v27);
  sub_1000558F4(&v26);
  if (SHIBYTE(v25) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v22) < 0) {
    operator delete(v21[0]);
  }
  sub_100B3F32C((uint64_t)a1);
  sub_100B3F548((uint64_t)a1);
}

void sub_100B3E748(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  sub_100057D78((const void **)va);
  sub_1000558F4((const void **)(v11 - 72));
  _Unwind_Resume(a1);
}

void sub_100B3E764(void *a1, uint64_t a2, uint64_t a3)
{
  if (a1[27])
  {
    uint64_t v6 = a1[39];
    uint64_t v7 = sub_100B45F5C(a1[38], v6, (unsigned __int8 **)a2);
    if (v6 == v7)
    {
      int v12 = a1[5];
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
      {
        if (*(char *)(a2 + 23) >= 0) {
          int v13 = (unsigned __int8 *)a2;
        }
        else {
          int v13 = *(unsigned __int8 **)a2;
        }
        *(_DWORD *)std::string buf = 136315138;
        *(void *)&uint8_t buf[4] = v13;
        _os_log_error_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "source iccid:%s already removed", buf, 0xCu);
      }
    }
    else
    {
      *(unsigned char *)(v7 + 1514) = a3 ^ 1;
      int v8 = a1[5];
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        int v9 = "hide";
        if (a3) {
          int v9 = "show";
        }
        *(_DWORD *)std::string buf = 136315138;
        *(void *)&uint8_t buf[4] = v9;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Sending request to %s prox card on source", buf, 0xCu);
      }
      CFTypeRef cf = 0;
      sub_100CD8AD8(a3, &cf);
      uint64_t v10 = a1[27];
      sub_100058DB0(buf, "kUpdateProxCardVisibilityReq");
      CFTypeRef v16 = cf;
      if (cf) {
        CFRetain(cf);
      }
      uint64_t v15 = 0;
      v18[0] = off_101A3FB50;
      v18[3] = v18;
      (*(void (**)(uint64_t, unsigned char *, CFTypeRef *, void *, uint64_t *, void *))(*(void *)v10 + 16))(v10, buf, &v16, a1 + 3, &v15, v18);
      sub_100B202F4(v18);
      sub_100057D78(&v16);
      if (v20 < 0) {
        operator delete(*(void **)buf);
      }
      *(void *)std::string buf = 0;
      sub_100CD8CA8(a3, buf);
      uint64_t v14 = *(const void **)buf;
      if (*(void *)buf) {
        CFRetain(*(CFTypeRef *)buf);
      }
      sub_100B3E384((uint64_t)a1, &v14);
      sub_100057D78(&v14);
      sub_100057D78((const void **)buf);
      sub_100057D78(&cf);
    }
  }
  else
  {
    uint64_t v11 = a1[5];
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I No change to prox card required in Manatee flow.", buf, 2u);
    }
  }
}

void sub_100B3E9EC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, int a12, __int16 a13, char a14, char a15, int a16, __int16 a17, char a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_100B3EA60(uint64_t a1, uint64_t a2, uint64_t a3, int a4, const void **a5, const void **a6)
{
  unsigned __int8 v60 = a3;
  if (!*(unsigned char *)(a1 + 360))
  {
    *(unsigned char *)(a1 + 140) = a3;
    int v8 = *(std::__shared_weak_count **)(a1 + 72);
    if (v8)
    {
      int v13 = std::__shared_weak_count::lock(v8);
      if (v13)
      {
        uint64_t v14 = *(void *)(a1 + 64);
        if (v14)
        {
          *(_OWORD *)long long v58 = 0u;
          long long v59 = 0u;
          memset(&v57, 0, sizeof(v57));
          __p[0] = 0;
          __p[1] = 0;
          uint64_t v56 = 0;
          memset(&v54, 0, sizeof(v54));
          memset(&v53, 0, sizeof(v53));
          uint64_t v15 = *(void *)(a1 + 312);
          uint64_t v16 = sub_100B45F5C(*(void *)(a1 + 304), v15, (unsigned __int8 **)a2);
          uint64_t v18 = v16;
          if (v15 == v16)
          {
LABEL_21:
            char v20 = *(NSObject **)(a1 + 40);
            uint64_t v45 = v18;
            if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v21 = sub_1008A2228(a3);
              if ((v57.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                uint64_t v22 = &v57;
              }
              else {
                uint64_t v22 = (std::string *)v57.__r_.__value_.__r.__words[0];
              }
              __int16 v23 = *(unsigned __int8 **)a2;
              if (*(char *)(a2 + 23) >= 0) {
                __int16 v23 = (unsigned __int8 *)a2;
              }
              if (BYTE8(v59))
              {
                uint64_t v42 = v23;
                uint64_t v43 = v21;
                sub_100058DB0(&v52, " -> ");
                if (!BYTE8(v59)) {
                  sub_10016C840();
                }
                if ((SBYTE7(v59) & 0x80u) == 0) {
                  int v24 = v58;
                }
                else {
                  int v24 = (void **)v58[0];
                }
                if ((SBYTE7(v59) & 0x80u) == 0) {
                  std::string::size_type v25 = BYTE7(v59);
                }
                else {
                  std::string::size_type v25 = (std::string::size_type)v58[1];
                }
                int v26 = std::string::append(&v52, (const std::string::value_type *)v24, v25);
                long long v27 = *(_OWORD *)&v26->__r_.__value_.__l.__data_;
                int64_t v62 = v26->__r_.__value_.__r.__words[2];
                long long v61 = v27;
                v26->__r_.__value_.__l.__size_ = 0;
                v26->__r_.__value_.__r.__words[2] = 0;
                v26->__r_.__value_.__r.__words[0] = 0;
                char v28 = (const char *)&v61;
                if (v62 < 0) {
                  char v28 = (const char *)v61;
                }
                *(_DWORD *)std::string buf = 136315906;
                *(void *)&uint8_t buf[4] = v43;
                *(_WORD *)&unsigned char buf[12] = 2080;
                *(void *)&unsigned char buf[14] = v22;
                *(_WORD *)&unsigned char buf[22] = 2080;
                long long v64 = v42;
                __int16 v65 = 2080;
                long long v66 = v28;
                _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#I update pending plan state %s: [IMEI:%s ICCID:%s]%s", buf, 0x2Au);
                if (SHIBYTE(v62) < 0) {
                  operator delete((void *)v61);
                }
                if (SHIBYTE(v52.__r_.__value_.__r.__words[2]) < 0) {
                  operator delete(v52.__r_.__value_.__l.__data_);
                }
              }
              else
              {
                *(_DWORD *)std::string buf = 136315906;
                *(void *)&uint8_t buf[4] = v21;
                *(_WORD *)&unsigned char buf[12] = 2080;
                *(void *)&unsigned char buf[14] = v22;
                *(_WORD *)&unsigned char buf[22] = 2080;
                long long v64 = v23;
                __int16 v65 = 2080;
                long long v66 = "";
                _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#I update pending plan state %s: [IMEI:%s ICCID:%s]%s", buf, 0x2Au);
              }
            }
            (*(void (**)(uint64_t, std::string *, void **, uint64_t, uint64_t, void **))(*(void *)v14 + 56))(v14, &v57, __p, a2, a3, v58);
            uint64_t v29 = *(void *)(a1 + 856);
            uint64_t v30 = *(void *)(a1 + 864);
            int v46 = a4;
            if (*(char *)(a2 + 23) < 0)
            {
              sub_10004FC84(__dst, *(void **)a2, *(void *)(a2 + 8));
            }
            else
            {
              *(_OWORD *)long long __dst = *(_OWORD *)a2;
              uint64_t v51 = *(void *)(a2 + 16);
            }
            uint64_t v31 = HIBYTE(v51);
            if (v29 == v30)
            {
              char v40 = 0;
            }
            else
            {
              long long v44 = v13;
              double v33 = __dst[0];
              uint64_t v32 = __dst[1];
              if (v51 >= 0) {
                uint64_t v34 = (void *)HIBYTE(v51);
              }
              else {
                uint64_t v34 = __dst[1];
              }
              do
              {
                std::string::size_type v35 = (void *)*(unsigned __int8 *)(v29 + 455);
                int v36 = (char)v35;
                if ((char)v35 < 0) {
                  std::string::size_type v35 = *(void **)(v29 + 440);
                }
                if (v34 == v35)
                {
                  if (v36 >= 0) {
                    uint64_t v37 = (unsigned __int8 *)(v29 + 432);
                  }
                  else {
                    uint64_t v37 = *(unsigned __int8 **)(v29 + 432);
                  }
                  if ((v31 & 0x80) != 0)
                  {
                    if (!memcmp(v33, v37, (size_t)v32))
                    {
                      char v40 = 1;
                      int v13 = v44;
                      int v41 = v46;
                      goto LABEL_67;
                    }
                  }
                  else
                  {
                    if (!v31)
                    {
                      char v40 = 1;
                      int v13 = v44;
                      int v41 = v46;
                      goto LABEL_68;
                    }
                    unsigned int v38 = __dst;
                    uint64_t v39 = v31;
                    while (*(unsigned __int8 *)v38 == *v37)
                    {
                      unsigned int v38 = (void **)((char *)v38 + 1);
                      ++v37;
                      if (!--v39)
                      {
                        char v40 = 1;
                        goto LABEL_64;
                      }
                    }
                  }
                }
                v29 += 1248;
              }
              while (v29 != v30);
              char v40 = 0;
LABEL_64:
              int v13 = v44;
            }
            int v41 = v46;
            if ((v31 & 0x80) != 0) {
LABEL_67:
            }
              operator delete(__dst[0]);
LABEL_68:
            if (a3 == 11)
            {
              buf[0] = 1;
              sub_100B4B75C(a1, buf, &v60, v45, v40, *(unsigned __int8 *)(v45 + 1284));
            }
            sub_100083DA4(&v49, a5);
            sub_100058198(&v48, a6);
            if (SHIBYTE(v54.__r_.__value_.__r.__words[2]) < 0) {
              sub_10004FC84(&v47, v54.__r_.__value_.__l.__data_, v54.__r_.__value_.__l.__size_);
            }
            else {
              std::string v47 = v54;
            }
            sub_100B51F3C(a1, a3, v41, (uint64_t *)&v49, (uint64_t *)&v48, (uint64_t *)&v47, (char *)&v53);
            if (SHIBYTE(v47.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(v47.__r_.__value_.__l.__data_);
            }
            sub_100057D78(&v48);
            sub_1000558F4(&v49);
            if (SHIBYTE(v53.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(v53.__r_.__value_.__l.__data_);
            }
            if (SHIBYTE(v54.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(v54.__r_.__value_.__l.__data_);
            }
            if (SHIBYTE(v56) < 0) {
              operator delete(__p[0]);
            }
            if (SHIBYTE(v57.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(v57.__r_.__value_.__l.__data_);
            }
            if (BYTE8(v59) && SBYTE7(v59) < 0) {
              operator delete(v58[0]);
            }
            goto LABEL_12;
          }
          if (*(char *)(v16 + 1231) < 0)
          {
            if (!*(void *)(v16 + 1216))
            {
LABEL_17:
              long long v61 = *(_OWORD *)(v18 + 1032);
              ctu::hex((uint64_t *)buf, (ctu *)&v61, (const void *)0x10, v17);
              if (SHIBYTE(v56) < 0) {
                operator delete(__p[0]);
              }
              *(_OWORD *)long long __p = *(_OWORD *)buf;
              uint64_t v56 = *(void *)&buf[16];
              std::string::operator=(&v57, (const std::string *)(v18 + 1072));
              std::string::operator=(&v54, (const std::string *)(v18 + 1144));
              if (*(unsigned char *)(v18 + 1504)) {
                std::string::operator=(&v53, (const std::string *)(v18 + 1480));
              }
              goto LABEL_21;
            }
          }
          else if (!*(unsigned char *)(v16 + 1231))
          {
            goto LABEL_17;
          }
          sub_100093B44((std::string *)v58, (const std::string *)(v16 + 1208));
          goto LABEL_17;
        }
      }
    }
    else
    {
      int v13 = 0;
    }
    uint64_t v19 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "invalid delegate to update pending plan state", buf, 2u);
    }
LABEL_12:
    if (v13) {
      sub_10004D2C8(v13);
    }
  }
}

void sub_100B3F02C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *a22,uint64_t a23,uint64_t a24,void *__p,uint64_t a26,int a27,__int16 a28,char a29,char a30,void *a31,uint64_t a32,int a33,__int16 a34,char a35,char a36,void *a37,uint64_t a38,int a39,__int16 a40,char a41,char a42,void *a43,uint64_t a44,int a45,__int16 a46,char a47,char a48,void *a49,uint64_t a50,int a51,__int16 a52,char a53,char a54,char a55)
{
  if (a30 < 0) {
    operator delete(__p);
  }
  if (a36 < 0) {
    operator delete(a31);
  }
  if (a42 < 0) {
    operator delete(a37);
  }
  if (a48 < 0) {
    operator delete(a43);
  }
  if (a55)
  {
    if (a54 < 0) {
      operator delete(a49);
    }
  }
  sub_10004D2C8(v55);
  _Unwind_Resume(a1);
}

uint64_t sub_100B3F0F4(uint64_t __dst, uint64_t a2, uint64_t a3, unsigned __int8 **a4)
{
  uint64_t v5 = a2;
  uint64_t v6 = __dst;
  if (a2 != a3)
  {
    char v7 = *((unsigned char *)a4 + 23);
    if (v7 >= 0) {
      int v8 = (unsigned __int8 *)*((unsigned __int8 *)a4 + 23);
    }
    else {
      int v8 = a4[1];
    }
    if (v7 >= 0) {
      int v9 = (unsigned __int8 *)a4;
    }
    else {
      int v9 = *a4;
    }
    do
    {
      uint64_t v10 = *(unsigned __int8 *)(v5 + 1071);
      if ((v10 & 0x80u) == 0) {
        uint64_t v11 = (unsigned __int8 *)*(unsigned __int8 *)(v5 + 1071);
      }
      else {
        uint64_t v11 = *(unsigned __int8 **)(v5 + 1056);
      }
      if (v11 == v8)
      {
        if ((v10 & 0x80) != 0)
        {
          long long __dst = memcmp(*(const void **)(v5 + 1048), v9, *(void *)(v5 + 1056));
          if (!__dst) {
            goto LABEL_21;
          }
        }
        else
        {
          if (!*(unsigned char *)(v5 + 1071)) {
            goto LABEL_21;
          }
          uint64_t v12 = 0;
          while (*(unsigned __int8 *)(v5 + v12 + 1048) == v9[v12])
          {
            if (v10 == ++v12) {
              goto LABEL_21;
            }
          }
        }
      }
      v5 += 1520;
    }
    while (v5 != a3);
    goto LABEL_24;
  }
LABEL_21:
  if (v5 == a3)
  {
LABEL_24:
    *(void *)uint64_t v6 = 0;
    *(void *)(v6 + 8) = 0;
    *(void *)(v6 + 16) = 0;
    return __dst;
  }
  if (*(char *)(v5 + 1167) < 0)
  {
    uint64_t v14 = *(void **)(v5 + 1144);
    unint64_t v15 = *(void *)(v5 + 1152);
    return (uint64_t)sub_10004FC84((unsigned char *)v6, v14, v15);
  }
  else
  {
    long long v13 = *(_OWORD *)(v5 + 1144);
    *(void *)(v6 + 16) = *(void *)(v5 + 1160);
    *(_OWORD *)uint64_t v6 = v13;
  }
  return __dst;
}

uint64_t sub_100B3F218(uint64_t a1, uint64_t a2)
{
  int v4 = *(unsigned __int8 *)(a1 + 56);
  *(unsigned char *)a1 = *(unsigned char *)a2;
  if (v4)
  {
    uint64_t v5 = (long long *)(a2 + 8);
    uint64_t v6 = (void **)(a1 + 8);
    if (*(char *)(a1 + 31) < 0) {
      operator delete(*v6);
    }
    long long v7 = *v5;
    *(void *)(a1 + 24) = *(void *)(a2 + 24);
    *(_OWORD *)uint64_t v6 = v7;
    *(unsigned char *)(a2 + 31) = 0;
    *(unsigned char *)(a2 + 8) = 0;
    if (a1 != a2)
    {
      int v8 = *(const void **)(a1 + 32);
      *(void *)(a1 + 32) = 0;
      uint64_t v12 = v8;
      *(void *)(a1 + 32) = *(void *)(a2 + 32);
      *(void *)(a2 + 32) = 0;
      sub_1000558F4(&v12);
      int v9 = *(const void **)(a1 + 40);
      *(void *)(a1 + 40) = 0;
      uint64_t v12 = v9;
      *(void *)(a1 + 40) = *(void *)(a2 + 40);
      *(void *)(a2 + 40) = 0;
      sub_100057D78(&v12);
    }
    *(unsigned char *)(a1 + 48) = *(unsigned char *)(a2 + 48);
  }
  else
  {
    long long v10 = *(_OWORD *)(a2 + 8);
    *(void *)(a1 + 24) = *(void *)(a2 + 24);
    *(_OWORD *)(a1 + 8) = v10;
    *(void *)(a2 + 16) = 0;
    *(void *)(a2 + 24) = 0;
    *(void *)(a2 + 8) = 0;
    *(void *)(a1 + 32) = 0;
    *(void *)(a1 + 32) = *(void *)(a2 + 32);
    *(void *)(a2 + 32) = 0;
    *(void *)(a1 + 40) = 0;
    *(void *)(a1 + 40) = *(void *)(a2 + 40);
    *(void *)(a2 + 40) = 0;
    *(unsigned char *)(a1 + 48) = *(unsigned char *)(a2 + 48);
    *(unsigned char *)(a1 + 56) = 1;
  }
  return a1;
}

void sub_100B3F32C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 312);
  if (*(void *)(a1 + 304) == v1) {
    return;
  }
  uint64_t v3 = *(void *)(a1 + 328);
  if (v3 == v1) {
    return;
  }
  __p[0] = 0;
  __p[1] = 0;
  uint64_t v21 = 0;
  sub_100B49750((uint64_t)__p, v3 + 1048);
  sub_100991BC4(*(void *)(a1 + 328));
  (***(void (****)(Registry **__return_ptr))(a1 + 48))(&v18);
  ServiceMap = (std::mutex *)Registry::getServiceMap(v4, v18);
  uint64_t v6 = ServiceMap;
  if ((v7 & 0x8000000000000000) != 0)
  {
    int v8 = (unsigned __int8 *)(v7 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v9 = 5381;
    do
    {
      unint64_t v7 = v9;
      unsigned int v10 = *v8++;
      uint64_t v9 = (33 * v9) ^ v10;
    }
    while (v10);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v22 = v7;
  uint64_t v11 = sub_10004D37C(&v6[1].__m_.__sig, &v22);
  if (!v11)
  {
    uint64_t v13 = 0;
    goto LABEL_10;
  }
  uint64_t v13 = v11[3];
  uint64_t v12 = (std::__shared_weak_count *)v11[4];
  if (!v12)
  {
LABEL_10:
    std::mutex::unlock(v6);
    uint64_t v12 = 0;
    char v14 = 1;
    goto LABEL_11;
  }
  atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v6);
  atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v12);
  char v14 = 0;
LABEL_11:
  (*(void (**)(uint64_t, void **))(*(void *)v13 + 88))(v13, __p);
  if ((v14 & 1) == 0) {
    sub_10004D2C8(v12);
  }
  if (v19) {
    sub_10004D2C8(v19);
  }
  uint64_t v15 = *(void *)(a1 + 328);
  uint64_t v16 = sub_100B62A44(v15 + 1520, *(void *)(a1 + 312), v15);
  for (uint64_t i = *(void *)(a1 + 312); i != v16; uint64_t i = sub_100B615AC(i - 1520))
    ;
  *(void *)(a1 + 312) = v16;
  *(void *)(a1 + 328) = v15;
  if (SHIBYTE(v21) < 0) {
    operator delete(__p[0]);
  }
}

void sub_100B3F4FC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100B3F548(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 360))
  {
    uint64_t v2 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Preflight ongoing, dont trigger", buf, 2u);
    }
    return;
  }
  if (!*(unsigned char *)(a1 + 131) && *(unsigned char *)(a1 + 480))
  {
    int v10 = *(unsigned __int8 *)(a1 + 472);
    CFStringRef v11 = *(const __CFString **)(a1 + 456);
    if (v11) {
      uint64_t v12 = sub_1000810B8;
    }
    else {
      uint64_t v12 = 0;
    }
    if (v12 && CFStringGetLength(v11) >= 1)
    {
      uint64_t v13 = *(void *)(a1 + 328);
      if (v13 != *(void *)(a1 + 312))
      {
        uint64_t v84 = 0;
        uint64_t v83 = 0;
        sub_100B3EA60(a1, v13 + 1048, 6, v10, &v84, &v83);
        sub_100057D78(&v83);
        sub_1000558F4(&v84);
      }
      (***(void (****)(std::string *__return_ptr))(a1 + 48))(&__p);
      Registry::getNotificationSenderFactory((uint64_t *)buf, (Registry *)__p.__r_.__value_.__l.__data_);
      uint64_t v14 = *(void *)buf;
      (***(void (****)(Registry **__return_ptr))(a1 + 48))(&v77);
      Registry::getTimerService(&v79, v77);
      (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t *, uint64_t))(*(void *)v14 + 160))(&v81, v14, &v79, a1 + 24);
      (***(void (****)(Registry **__return_ptr))(a1 + 48))(&v74);
      ServiceMap = (std::mutex *)Registry::getServiceMap(v15, v74);
      unint64_t v17 = ServiceMap;
      if ((v18 & 0x8000000000000000) != 0)
      {
        uint64_t v19 = (unsigned __int8 *)(v18 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v20 = 5381;
        do
        {
          unint64_t v18 = v20;
          unsigned int v21 = *v19++;
          uint64_t v20 = (33 * v20) ^ v21;
        }
        while (v21);
      }
      std::mutex::lock(ServiceMap);
      unint64_t v85 = v18;
      unint64_t v22 = sub_10004D37C(&v17[1].__m_.__sig, &v85);
      if (v22)
      {
        uint64_t v24 = v22[3];
        __int16 v23 = (std::__shared_weak_count *)v22[4];
        if (v23) {
          atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
        }
      }
      else
      {
        uint64_t v24 = 0;
        __int16 v23 = 0;
      }
      std::mutex::unlock(v17);
      v76[0] = v24;
      v76[1] = (uint64_t)v23;
      if (v23)
      {
        atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v23);
      }
      sub_100083DA4(&v73, (const void **)(a1 + 456));
      sub_100058198(&v72, (const void **)(a1 + 464));
      int v38 = *(unsigned __int8 *)(a1 + 130);
      uint64_t v39 = *(NSObject **)(a1 + 24);
      uint64_t v71 = v39;
      if (v39) {
        dispatch_retain(v39);
      }
      char v40 = *(std::__shared_weak_count **)(a1 + 72);
      v70[0] = *(void *)(a1 + 64);
      v70[1] = v40;
      if (v40) {
        atomic_fetch_add_explicit(&v40->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      }
      sub_100B525AC(&v81, v76, (long long *)(a1 + 432), &v73, &v72, v10, v38 != 0, &v71, (uint64_t)v70);
      if (v40) {
        std::__shared_weak_count::__release_weak(v40);
      }
      if (v39) {
        dispatch_release(v39);
      }
      sub_100057D78(&v72);
      sub_1000558F4(&v73);
      if (v23) {
        sub_10004D2C8(v23);
      }
      if (v75) {
        sub_10004D2C8(v75);
      }
      if (v82) {
        sub_10004D2C8(v82);
      }
      if (v80) {
        sub_10004D2C8(v80);
      }
      if (v78) {
        sub_10004D2C8(v78);
      }
      if (*(void *)&buf[8]) {
        sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
      }
      if (__p.__r_.__value_.__l.__size_) {
        sub_10004D2C8((std::__shared_weak_count *)__p.__r_.__value_.__l.__size_);
      }
    }
    int v41 = *(unsigned __int8 *)(a1 + 424);
    sub_100B45AA0(a1 + 424);
    if (*(void *)(a1 + 416))
    {
      sub_1002EB2F8(a1 + 392, v41 != 0, v10);
      sub_100B69D80((void *)(a1 + 392));
    }
    if (*(void *)(a1 + 304) == *(void *)(a1 + 312))
    {
      uint64_t v42 = *(std::__shared_weak_count **)(a1 + 72);
      if (v42)
      {
        uint64_t v30 = std::__shared_weak_count::lock(v42);
        if (v30)
        {
          uint64_t v43 = *(void *)(a1 + 64);
          if (v43)
          {
            (*(void (**)(uint64_t))(*(void *)v43 + 80))(v43);
            goto LABEL_108;
          }
        }
        goto LABEL_105;
      }
      goto LABEL_104;
    }
    return;
  }
  uint64_t v3 = *(void *)(a1 + 312);
  uint64_t v4 = *(void *)(a1 + 328);
  if (v4 == v3)
  {
    if (*(void *)(a1 + 416))
    {
      if (*(unsigned char *)(a1 + 480))
      {
        sub_1002EB2F8(a1 + 392, *(unsigned char *)(a1 + 424), *(unsigned char *)(a1 + 472));
        sub_100B45AA0(a1 + 424);
      }
      else
      {
        sub_1002EB2F8(a1 + 392, 1, 0);
      }
      sub_100B69D80((void *)(a1 + 392));
      if (*(void *)(a1 + 304) != *(void *)(a1 + 312)) {
        return;
      }
      uint64_t v32 = *(std::__shared_weak_count **)(a1 + 72);
      if (v32)
      {
        uint64_t v30 = std::__shared_weak_count::lock(v32);
        if (v30)
        {
          uint64_t v31 = *(void *)(a1 + 64);
          if (v31)
          {
LABEL_56:
            (*(void (**)(uint64_t))(*(void *)v31 + 80))(v31);
            goto LABEL_108;
          }
        }
LABEL_105:
        long long v44 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v44, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)std::string buf = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_ERROR, "invalid delegate - allTransferPlansHandled", buf, 2u);
        }
LABEL_107:
        if (!v30) {
          return;
        }
LABEL_108:
        sub_10004D2C8(v30);
        return;
      }
    }
    else
    {
      if (*(void *)(a1 + 304) != v3) {
        return;
      }
      uint64_t v29 = *(std::__shared_weak_count **)(a1 + 72);
      if (v29)
      {
        uint64_t v30 = std::__shared_weak_count::lock(v29);
        if (v30)
        {
          uint64_t v31 = *(void *)(a1 + 64);
          if (v31) {
            goto LABEL_56;
          }
        }
        goto LABEL_105;
      }
    }
LABEL_104:
    uint64_t v30 = 0;
    goto LABEL_105;
  }
  uint64_t v5 = (uint64_t *)(a1 + 328);
  uint64_t v6 = (_OWORD *)(v4 + 1048);
  int v7 = *(unsigned __int8 *)(a1 + 128);
  if ((v7 - 3) < 2 || v7 == 1)
  {
    if (!*(unsigned char *)(a1 + 130) && !*(unsigned char *)(a1 + 132))
    {
      double v33 = *(std::__shared_weak_count **)(a1 + 72);
      if (v33)
      {
        uint64_t v30 = std::__shared_weak_count::lock(v33);
        if (v30)
        {
          uint64_t v34 = *(void *)(a1 + 64);
          if (v34)
          {
            *(unsigned char *)(v4 + 1460) = 1;
            long long v58 = 0;
            long long v59 = 0;
            sub_100B3EA60(a1, v4 + 1048, 2, 0, &v59, &v58);
            sub_100057D78(&v58);
            sub_1000558F4(&v59);
            uint64_t v35 = *(void *)(v4 + 1032);
            uint64_t v36 = *(void *)(v4 + 1040);
            if (*(char *)(v4 + 1071) < 0)
            {
              sub_10004FC84(__dst, *(void **)(v4 + 1048), *(void *)(v4 + 1056));
            }
            else
            {
              *(_OWORD *)long long __dst = *v6;
              uint64_t v57 = *(void *)(v4 + 1064);
            }
            uint64_t v47 = *(void *)(v4 + 1168);
            uint64_t v48 = *(void *)(v4 + 1176);
            if (*(char *)(v4 + 1207) < 0)
            {
              sub_10004FC84(v54, *(void **)(v4 + 1184), *(void *)(v4 + 1192));
            }
            else
            {
              *(_OWORD *)std::string v54 = *(_OWORD *)(v4 + 1184);
              uint64_t v55 = *(void *)(v4 + 1200);
            }
            if (*(char *)(v4 + 1279) < 0)
            {
              sub_10004FC84(v52, *(void **)(v4 + 1256), *(void *)(v4 + 1264));
            }
            else
            {
              *(_OWORD *)std::string v52 = *(_OWORD *)(v4 + 1256);
              uint64_t v53 = *(void *)(v4 + 1272);
            }
            if (*(char *)(v4 + 1255) < 0)
            {
              sub_10004FC84(v50, *(void **)(v4 + 1232), *(void *)(v4 + 1240));
            }
            else
            {
              *(_OWORD *)id v50 = *(_OWORD *)(v4 + 1232);
              uint64_t v51 = *(void *)(v4 + 1248);
            }
            (*(void (**)(uint64_t, uint64_t, uint64_t, void **, uint64_t, uint64_t, void **, void **, void **))(*(void *)v34 + 16))(v34, v35, v36, __dst, v47, v48, v54, v52, v50);
            if (SHIBYTE(v51) < 0) {
              operator delete(v50[0]);
            }
            if (SHIBYTE(v53) < 0) {
              operator delete(v52[0]);
            }
            if (SHIBYTE(v55) < 0) {
              operator delete(v54[0]);
            }
            if (SHIBYTE(v57) < 0) {
              operator delete(__dst[0]);
            }
            goto LABEL_108;
          }
        }
      }
      else
      {
        uint64_t v30 = 0;
      }
      int v46 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v46, OS_LOG_TYPE_ERROR))
      {
        uint64_t v49 = v4 + 1048;
        if (*(char *)(v4 + 1071) < 0) {
          uint64_t v49 = *(void *)v6;
        }
        *(_DWORD *)std::string buf = 136315138;
        *(void *)&uint8_t buf[4] = v49;
        _os_log_error_impl((void *)&_mh_execute_header, v46, OS_LOG_TYPE_ERROR, "Invalid Delegate iccid : %s", buf, 0xCu);
      }
      LOBYTE(v74) = 2;
      sub_100B49888((CFStringRef *)buf, a1);
      LOBYTE(v85) = 56;
      __p.__r_.__value_.__r.__words[0] = 0;
      LODWORD(v77) = 70009;
      BYTE4(v77) = 1;
      sub_100B3E598(a1, v4 + 1048, &v74, 0, buf, &v85, &__p, 0, 1, &v77, a1 + 328);
      sub_100057D78((const void **)&__p.__r_.__value_.__l.__data_);
      sub_1000558F4((const void **)buf);
      goto LABEL_107;
    }
    uint64_t v102 = 0;
    long long v101 = 0u;
    long long v100 = 0u;
    long long v99 = 0u;
    long long v98 = 0u;
    long long v97 = 0u;
    long long v96 = 0u;
    long long v95 = 0u;
    long long v94 = 0u;
    long long v93 = 0u;
    long long v92 = 0u;
    long long v91 = 0u;
    long long v90 = 0u;
    long long v89 = 0u;
    long long v88 = 0u;
    long long v87 = 0u;
    *(_OWORD *)std::string buf = 0u;
    if (*(unsigned char *)(v4 + 624)) {
      sub_100B53774((char *)buf, (std::string *)(v4 + 368));
    }
    *(unsigned char *)(v4 + 1460) = 1;
    sub_10030D9BC((char *)v61, (uint64_t)buf);
    __int16 v60 = 257;
    sub_100B53840(a1, v4 + 1048, v61, (unsigned __int8 *)&v60);
    LOBYTE(v60) = 0;
    if (v62) {
      sub_1000C5578((uint64_t)v61);
    }
    if (!(_BYTE)v102) {
      return;
    }
    uint64_t v9 = buf;
LABEL_20:
    sub_1000C5578((uint64_t)v9);
    return;
  }
  if (v7 != 2) {
    return;
  }
  if (!*(unsigned char *)(v4 + 624))
  {
    uint64_t v37 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEFAULT, "#I Failed TA. No response", buf, 2u);
    }
    v68[0] = 0;
    char v69 = 0;
    sub_100B52E14(a1, v4 + 1048, (uint64_t)v68);
    if (!v69) {
      return;
    }
    uint64_t v9 = v68;
    goto LABEL_20;
  }
  sub_100B53774((char *)(v4 + 632), (std::string *)(v4 + 368));
  if (*(unsigned char *)(v4 + 424))
  {
    long long v64 = 0;
    __int16 v65 = 0;
    sub_100B3EA60(a1, v4 + 1048, 4, 0, &v65, &v64);
    sub_100057D78(&v64);
    sub_1000558F4(&v65);
    memset(buf, 0, sizeof(buf));
    *(void *)&long long v87 = 0;
    sub_100B49750((uint64_t)buf, v4 + 1048);
    uint64_t v25 = *v5;
    if (*(unsigned char *)(*v5 + 216))
    {
      memset(&__p, 0, sizeof(__p));
      BOOL v26 = sub_100B51B0C(a1, v25);
      char v27 = (*(uint64_t (**)(void))(**(void **)(a1 + 48) + 32))(*(void *)(a1 + 48));
      sub_100CDA4C8((void *)(a1 + 720), (uint64_t *)(a1 + 624), (uint64_t *)(a1 + 600), v26, v27, *(unsigned __int8 *)(a1 + 129), &__p);
      uint64_t v28 = sub_100CDB150((void *)(a1 + 720), (unsigned __int8 **)&__p);
      if (v28) {
        (*(void (**)(void, uint8_t *, uint64_t))(**(void **)(a1 + 48) + 288))(*(void *)(a1 + 48), buf, v28);
      }
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
    }
    (***(void (****)(Registry **__return_ptr))(a1 + 48))(&v77);
    sub_1003D59E4(v77, &__p);
    LOBYTE(v74) = 2;
    (*(void (**)(std::string::size_type, uint8_t *, Registry **))(*(void *)__p.__r_.__value_.__l.__data_
                                                                           + 80))(__p.__r_.__value_.__r.__words[0], buf, &v74);
    if (__p.__r_.__value_.__l.__size_) {
      sub_10004D2C8((std::__shared_weak_count *)__p.__r_.__value_.__l.__size_);
    }
    if (v78) {
      sub_10004D2C8(v78);
    }
    if (SBYTE7(v87) < 0) {
      operator delete(*(void **)buf);
    }
    return;
  }
  uint64_t v45 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v45, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v45, OS_LOG_TYPE_DEFAULT, "#I Failed TA. No transfer token in response", buf, 2u);
  }
  sub_10030DA1C(v66, (long long *)(v4 + 368));
  char v67 = 1;
  sub_100B52E14(a1, v4 + 1048, (uint64_t)v66);
  if (v67)
  {
    uint64_t v9 = (uint8_t *)v66;
    goto LABEL_20;
  }
}

void sub_100B400D0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,void *a24,uint64_t a25,int a26,__int16 a27,char a28,char a29,uint64_t a30,void *a31,uint64_t a32,int a33,__int16 a34,char a35,char a36)
{
  if (a22 < 0) {
    operator delete(__p);
  }
  if (a29 < 0) {
    operator delete(a24);
  }
  if (a36 < 0) {
    operator delete(a31);
  }
  sub_10004D2C8(v36);
  _Unwind_Resume(a1);
}

void sub_100B40338(uint64_t a1, uint64_t *a2, char a3, uint64_t a4)
{
  *(unsigned char *)(a1 + 128) = 2;
  *(unsigned char *)(a1 + 133) = a3;
  int v7 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)std::string buf = 134217984;
    *(void *)&uint8_t buf[4] = a1;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I start transfer session on target. proximity. %p", buf, 0xCu);
  }
  uint64_t v8 = *a2;
  if (!*a2)
  {
    sub_10024924C(a4, 6);
    uint64_t v19 = *(NSObject **)(a1 + 40);
    if (!os_log_type_enabled(v19, OS_LOG_TYPE_ERROR)) {
      return;
    }
    *(_WORD *)std::string buf = 0;
    uint64_t v20 = "Invalid message session handler";
    goto LABEL_21;
  }
  uint64_t v9 = a2[1];
  if (v9) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v9 + 8), 1uLL, memory_order_relaxed);
  }
  int v10 = *(std::__shared_weak_count **)(a1 + 224);
  *(void *)(a1 + 216) = v8;
  *(void *)(a1 + 224) = v9;
  if (v10) {
    sub_10004D2C8(v10);
  }
  CFStringRef v11 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I fetching transfer plan list from source device", buf, 2u);
  }
  if (!*(void *)(a1 + 800))
  {
    sub_10024924C(a4, 56);
    uint64_t v19 = *(NSObject **)(a1 + 40);
    if (!os_log_type_enabled(v19, OS_LOG_TYPE_ERROR)) {
      return;
    }
    *(_WORD *)std::string buf = 0;
    uint64_t v20 = "invalid mobile gestalt";
LABEL_21:
    _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, v20, buf, 2u);
    return;
  }
  uint64_t v12 = *(void *)(a1 + 216);
  sub_100058DB0(buf, "kTransferConsentStatusUpdate");
  uint64_t v35 = 0;
  uint64_t v36 = 0;
  uint64_t v37 = 0;
  v30[0] = &v35;
  v30[1] = 0;
  uint64_t v35 = (char *)operator new(0x18uLL);
  uint64_t v36 = v35;
  uint64_t v37 = v35 + 24;
  uint64_t v36 = sub_1000D8A18((uint64_t)&v37, (long long *)buf, (long long *)&buf[24], v35);
  uint64_t v13 = *(std::__shared_weak_count **)(a1 + 16);
  if (!v13 || (uint64_t v14 = *(void *)(a1 + 8), (v15 = std::__shared_weak_count::lock(v13)) == 0)) {
    sub_100088B9C();
  }
  uint64_t v16 = v15;
  atomic_fetch_add_explicit(&v15->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v15);
  uint64_t v45 = 0;
  unint64_t v17 = operator new(0x20uLL);
  *unint64_t v17 = off_101A3E8E0;
  v17[1] = a1;
  void v17[2] = v14;
  v17[3] = v16;
  uint64_t v45 = v17;
  (*(void (**)(uint64_t, char **, void *))(*(void *)v12 + 32))(v12, &v35, v44);
  sub_10010E0A4(v44);
  v30[0] = &v35;
  sub_100047F64((void ***)v30);
  if ((char)buf[23] < 0) {
    operator delete(*(void **)buf);
  }
  *(unsigned char *)(a1 + 135) = 1;
  long long v42 = 0u;
  long long v43 = 0u;
  long long v41 = 0u;
  memset(buf, 0, sizeof(buf));
  uint64_t v18 = *(void *)(a1 + 800);
  if (*(char *)(v18 + 47) < 0)
  {
    sub_10004FC84(__p, *(void **)(v18 + 24), *(void *)(v18 + 32));
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)(v18 + 24);
    uint64_t v34 = *(void *)(v18 + 40);
  }
  *(_DWORD *)std::string buf = sub_100CD1928((const char *)__p);
  uint64_t v21 = *(void *)(a1 + 800);
  if (*(char *)(v21 + 167) < 0)
  {
    sub_10004FC84(&buf[8], *(void **)(v21 + 144), *(void *)(v21 + 152));
  }
  else
  {
    *(_OWORD *)&uint8_t buf[8] = *(_OWORD *)(v21 + 144);
    *(void *)&unsigned char buf[24] = *(void *)(v21 + 160);
  }
  sub_100B4094C((uint64_t *)&v41, *(_DWORD **)(a1 + 600), *(void *)(a1 + 608));
  char v22 = (*(uint64_t (**)(void))(**(void **)(a1 + 48) + 32))(*(void *)(a1 + 48));
  sub_100CDA4C8((void *)(a1 + 720), (uint64_t *)(a1 + 624), (uint64_t *)(a1 + 600), 0, v22, *(unsigned __int8 *)(a1 + 129), (std::string *)((char *)&v42 + 8));
  if (SHIBYTE(v34) < 0) {
    operator delete(__p[0]);
  }
  CFTypeRef cf = 0;
  sub_100CD7C80((unsigned int *)buf, &cf);
  uint64_t v23 = *(void *)(a1 + 216);
  sub_100058DB0(v30, "kTransferPlanListReq");
  CFTypeRef v29 = cf;
  if (cf) {
    CFRetain(cf);
  }
  uint64_t v24 = *(std::__shared_weak_count **)(a1 + 16);
  if (!v24 || (uint64_t v25 = *(void *)(a1 + 8), (v26 = std::__shared_weak_count::lock(v24)) == 0)) {
    sub_100088B9C();
  }
  char v27 = v26;
  atomic_fetch_add_explicit(&v26->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v26);
  uint64_t v39 = 0;
  uint64_t v28 = operator new(0x20uLL);
  *uint64_t v28 = off_101A3E960;
  v28[1] = a1;
  v28[2] = v25;
  v28[3] = v27;
  uint64_t v39 = v28;
  (*(void (**)(uint64_t, void **, CFTypeRef *, uint64_t, void *, void *))(*(void *)v23 + 16))(v23, v30, &v29, a1 + 24, &unk_1015465A0, v38);
  sub_100B202F4(v38);
  sub_100057D78(&v29);
  if (v31 < 0) {
    operator delete(v30[0]);
  }
  sub_10024924C(a4, 0);
  sub_100057D78(&cf);
  if (SHIBYTE(v43) < 0) {
    operator delete(*((void **)&v42 + 1));
  }
  if (SBYTE7(v42) < 0) {
    operator delete((void *)v41);
  }
  if ((char)buf[31] < 0) {
    operator delete(*(void **)&buf[8]);
  }
}

void sub_100B40828(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23,char a24,uint64_t a25,uint64_t a26,char a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,void *a32,int a33,__int16 a34,char a35,char a36,int a37,__int16 a38,char a39,char a40,void *a41,uint64_t a42,int a43,__int16 a44,char a45,char a46)
{
  if (a23 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t *sub_100B4094C(uint64_t *result, _DWORD *a2, unint64_t a3)
{
  if (a2 != (_DWORD *)a3)
  {
    while (a2[1] != 2)
    {
      a2 += 22;
      if (a2 == (_DWORD *)a3) {
        goto LABEL_8;
      }
    }
  }
  if (a2 != (_DWORD *)a3 && a2[3] == 3) {
    return ctu::hex(result, (ctu *)(a2 + 4), (const void *)0x10, a3);
  }
LABEL_8:
  *double result = 0;
  result[1] = 0;
  result[2] = 0;
  return result;
}

BOOL sub_100B409A4(uint64_t a1, uint64_t a2, uint64_t a3, _OWORD *a4, const std::string *a5)
{
  memset(&v74, 0, sizeof(v74));
  memset(v73, 0, sizeof(v73));
  long long v71 = 0u;
  memset(v72, 0, sizeof(v72));
  long long v70 = 0u;
  memset(v69, 0, sizeof(v69));
  long long v68 = 0u;
  uint64_t v10 = *(void *)(a1 + 144);
  uint64_t v11 = *(void *)(a1 + 152);
  if (v10 == v11)
  {
    long long v65 = 0uLL;
    long long v66 = 0uLL;
    long long v63 = 0uLL;
    long long v64 = 0uLL;
    long long v61 = 0uLL;
    long long v62 = 0uLL;
    long long v59 = 0uLL;
    long long v60 = 0uLL;
    long long v57 = 0uLL;
    long long v58 = 0uLL;
    long long v55 = 0uLL;
    long long v56 = 0uLL;
    long long v53 = 0uLL;
    long long v54 = 0uLL;
    long long v51 = 0uLL;
    long long v52 = 0uLL;
    long long v49 = 0uLL;
    long long v50 = 0uLL;
    long long v47 = 0uLL;
    long long v48 = 0uLL;
    long long v45 = 0uLL;
    long long v46 = 0uLL;
    long long v43 = 0uLL;
    long long v44 = 0uLL;
    long long v42 = 0uLL;
  }
  else
  {
    uint64_t v12 = (_OWORD *)(a3 + 40);
    do
    {
      int v13 = sub_10098E79C(v10, (unsigned __int8 **)(a3 + 40), (uint64_t)&v68);
      v10 += 400;
      if (v10 == v11) {
        int v14 = 1;
      }
      else {
        int v14 = v13;
      }
    }
    while (v14 != 1);
    uint64_t v15 = *(void *)(a1 + 144);
    uint64_t v16 = *(void *)(a1 + 152);
    long long v65 = 0u;
    long long v66 = 0u;
    long long v63 = 0u;
    long long v64 = 0u;
    long long v61 = 0u;
    long long v62 = 0u;
    long long v59 = 0u;
    long long v60 = 0u;
    long long v57 = 0u;
    long long v58 = 0u;
    long long v55 = 0u;
    long long v56 = 0u;
    long long v53 = 0u;
    long long v54 = 0u;
    long long v51 = 0u;
    long long v52 = 0u;
    long long v49 = 0u;
    long long v50 = 0u;
    long long v47 = 0u;
    long long v48 = 0u;
    long long v45 = 0u;
    long long v46 = 0u;
    long long v43 = 0u;
    long long v44 = 0u;
    long long v42 = 0u;
    if (v15 != v16)
    {
      do
      {
        if (*(char *)(a3 + 63) < 0)
        {
          sub_10004FC84(__p, *(void **)(a3 + 40), *(void *)(a3 + 48));
        }
        else
        {
          *(_OWORD *)std::string __p = *v12;
          uint64_t v41 = *(void *)(a3 + 56);
        }
        char v17 = sub_10098EC38(v15, __p, (uint64_t)&v42);
        if (SHIBYTE(v41) < 0) {
          operator delete(__p[0]);
        }
        v15 += 400;
        if (v15 == v16) {
          char v18 = 1;
        }
        else {
          char v18 = v17;
        }
      }
      while ((v18 & 1) == 0);
    }
  }
  if ((v69[0].__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type size = HIBYTE(v69[0].__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type size = v69[0].__r_.__value_.__l.__size_;
  }
  if (size)
  {
    uint64_t v20 = *(void *)(a1 + 144);
    uint64_t v21 = *(void *)(a1 + 152);
    if (v20 != v21)
    {
      while (!sub_10098F510(v20, a3 + 40, a2 + 1144))
      {
        v20 += 400;
        if (v20 == v21) {
          goto LABEL_34;
        }
      }
      std::string::operator=((std::string *)(a2 + 1096), (const std::string *)(v20 + 248));
      sub_10098FD3C((void *)v20, (uint64_t)&buf);
      BOOL v26 = (void **)(a2 + 1120);
      if (*(char *)(a2 + 1143) < 0) {
        operator delete(*v26);
      }
      *(_OWORD *)BOOL v26 = *(_OWORD *)&buf.__r_.__value_.__l.__data_;
      *(void *)(a2 + 1136) = *((void *)&buf.__r_.__value_.__l + 2);
    }
LABEL_34:
    if (*(unsigned char *)(a2 + 216))
    {
      *(_OWORD *)a2 = v68;
      std::string::operator=((std::string *)(a2 + 16), v69);
      std::string::operator=((std::string *)(a2 + 40), &v69[1]);
      std::string::operator=((std::string *)(a2 + 64), (const std::string *)&v70);
      *(_DWORD *)(a2 + 88) = DWORD2(v71);
      std::string::operator=((std::string *)(a2 + 96), v72);
      std::string::operator=((std::string *)(a2 + 120), &v72[1]);
      std::string::operator=((std::string *)(a2 + 144), v73);
      std::string::operator=((std::string *)(a2 + 168), &v73[1]);
      std::string::operator=((std::string *)(a2 + 192), &v74);
    }
    else
    {
      sub_1000C5AB4(a2, (uint64_t)&v68);
      *(unsigned char *)(a2 + 216) = 1;
    }
    char v27 = (char *)(a2 + 224);
    if (*(unsigned char *)(a2 + 624))
    {
      sub_100312ECC((uint64_t)v27, (uint64_t)&v42);
    }
    else
    {
      sub_1003126AC(v27, &v42);
      *(unsigned char *)(a2 + 624) = 1;
    }
    if (*(unsigned char *)(a2 + 888))
    {
      sub_1000C5578(a2 + 632);
      *(unsigned char *)(a2 + 888) = 0;
    }
    std::string::operator=((std::string *)(a2 + 1072), (const std::string *)a3);
    *(_OWORD *)(a2 + 1032) = *(_OWORD *)(a3 + 24);
    uint64_t v28 = (std::string *)(a3 + 40);
    std::string::operator=((std::string *)(a2 + 1048), v28);
    *(_OWORD *)(a2 + 1168) = *a4;
    std::string::operator=((std::string *)(a2 + 1184), a5);
    BOOL v29 = sub_100B51B0C(a1, (uint64_t)&v68);
    char v30 = (*(uint64_t (**)(void))(**(void **)(a1 + 48) + 32))(*(void *)(a1 + 48));
    sub_100CDA4C8((void *)(a1 + 720), (uint64_t *)(a1 + 624), (uint64_t *)(a1 + 600), v29, v30, *(unsigned __int8 *)(a1 + 129), &buf);
    uint64_t v32 = (void **)(a2 + 1232);
    if (*(char *)(a2 + 1255) < 0) {
      operator delete(*v32);
    }
    *(_OWORD *)uint64_t v32 = *(_OWORD *)&buf.__r_.__value_.__l.__data_;
    *(void *)(a2 + 1248) = *((void *)&buf.__r_.__value_.__l + 2);
    CodingUtility::generateUUID((uint64_t *)&buf, v31);
    double v33 = (void **)(a2 + 1256);
    if (*(char *)(a2 + 1279) < 0) {
      operator delete(*v33);
    }
    *(_OWORD *)double v33 = *(_OWORD *)&buf.__r_.__value_.__l.__data_;
    *(void *)(a2 + 1272) = *((void *)&buf.__r_.__value_.__l + 2);
    *(unsigned char *)(a2 + 1463) = 0;
    uint64_t v35 = *(void *)(a1 + 144);
    uint64_t v34 = *(void *)(a1 + 152);
    if (v35 != v34)
    {
      uint64_t v36 = (BOOL *)(a2 + 1463);
      do
      {
        int v37 = sub_10098EA6C(v35, (unsigned __int8 **)v28, v36);
        v35 += 400;
        if (v35 == v34) {
          int v38 = 1;
        }
        else {
          int v38 = v37;
        }
      }
      while (v38 != 1);
    }
  }
  else
  {
    char v22 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
    {
      std::string::size_type v25 = *(void *)(a3 + 40);
      std::string::size_type v24 = a3 + 40;
      std::string::size_type v23 = v25;
      if (*(char *)(v24 + 23) >= 0) {
        std::string::size_type v23 = v24;
      }
      LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = v23;
      _os_log_error_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_ERROR, "No Profile details for iccid: [%s]", (uint8_t *)&buf, 0xCu);
    }
  }
  sub_1000C54EC((uint64_t)&v42);
  sub_1000C584C((uint64_t)&v68);
  return size != 0;
}

void sub_100B40E58(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *__p, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  sub_1000C54EC((uint64_t)&a13);
  sub_1000C584C((uint64_t)&a67);
  _Unwind_Resume(a1);
}

uint64_t sub_100B40EB0(uint64_t a1)
{
  sub_100060644((void *)(a1 + 24));
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_100B40EE8(void *a1, uint64_t a2)
{
  uint64_t v3 = *(std::__shared_weak_count **)(a2 + 88);
  if (!v3) {
    goto LABEL_8;
  }
  uint64_t v5 = std::__shared_weak_count::lock(v3);
  if (!v5) {
    goto LABEL_8;
  }
  uint64_t v6 = v5;
  uint64_t v7 = *(void *)(a2 + 80);
  if (!v7)
  {
    sub_10004D2C8(v6);
LABEL_8:
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
    return;
  }
  (*(void (**)(uint64_t))(*(void *)v7 + 72))(v7);

  sub_10004D2C8(v6);
}

void sub_100B40F8C(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_100B40FA0(uint64_t a1, char a2, uint64_t a3)
{
  *(unsigned char *)(a1 + 133) = a2;
  uint64_t v19 = 0;
  uint64_t v20 = 0;
  (***(void (****)(uint8_t *__return_ptr))(a1 + 48))(buf);
  Registry::getTimerService(&v19, *(Registry **)buf);
  if (v18) {
    sub_10004D2C8(v18);
  }
  uint64_t v5 = v19;
  if (v19)
  {
    sub_100058DB0(__p, "Transfer bootstrap Timeout");
    uint64_t v6 = *(NSObject **)(a1 + 24);
    dispatch_object_t object = v6;
    if (v6) {
      dispatch_retain(v6);
    }
    v12[0] = _NSConcreteStackBlock;
    v12[1] = 0x40000000;
    _OWORD v12[2] = sub_100B4124C;
    v12[3] = &unk_101A3E3F0;
    void v12[4] = a1;
    aBlocuint64_t k = _Block_copy(v12);
    sub_100118A44(v5, (uint64_t)__p, 0, 60000000, &object, &aBlock);
    uint64_t v7 = *(Registry **)buf;
    *(void *)std::string buf = 0;
    uint64_t v8 = *(void *)(a1 + 952);
    *(void *)(a1 + 952) = v7;
    if (v8)
    {
      (*(void (**)(uint64_t))(*(void *)v8 + 8))(v8);
      uint64_t v9 = *(Registry **)buf;
      *(void *)std::string buf = 0;
      if (v9) {
        (*(void (**)(Registry *))(*(void *)v9 + 8))(v9);
      }
    }
    if (aBlock) {
      _Block_release(aBlock);
    }
    if (object) {
      dispatch_release(object);
    }
    if (v16 < 0) {
      operator delete(__p[0]);
    }
    *(unsigned char *)(a1 + 128) = 1;
    if (*(unsigned char *)(a1 + 848) && *(unsigned char *)(a1 + 849)) {
      sub_100B41630(a1);
    }
    char v10 = 0;
  }
  else
  {
    uint64_t v11 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "No Timer service", buf, 2u);
    }
    char v10 = 56;
  }
  sub_10024924C(a3, v10);
  if (v20) {
    sub_10004D2C8(v20);
  }
}

void sub_100B411E8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *aBlock, dispatch_object_t object, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (aBlock) {
    _Block_release(aBlock);
  }
  if (object) {
    dispatch_release(object);
  }
  if (a21 < 0) {
    operator delete(__p);
  }
  std::string::size_type v23 = *(std::__shared_weak_count **)(v21 - 40);
  if (v23) {
    sub_10004D2C8(v23);
  }
  _Unwind_Resume(exception_object);
}

void sub_100B4124C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t v2 = *(NSObject **)(v1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_ERROR, "Transfer list fetching timed out", buf, 2u);
  }
  *(unsigned char *)(v1 + 848) = 0;
  if (*(void *)(v1 + 256))
  {
    uint64_t v34 = 0;
    sub_10031F910(v1 + 232, (uint64_t)&v34, 5);
    sub_100044D00(&v34);
    sub_100343904((void *)(v1 + 232));
  }
  sub_1003355AC((void *)(v1 + 488));
  *(unsigned char *)(v1 + 128) = 0;
  long long v27 = 0u;
  uint64_t v29 = 0x400000000000000;
  long long v28 = 0u;
  *(_OWORD *)&v30[8] = 0u;
  BYTE1(v31[2]) = 0;
  WORD1(v31[2]) = 0;
  HIDWORD(v31[2]) = 318767104;
  long long v33 = 0u;
  long long v32 = 0u;
  HIBYTE(v27) = 8;
  *(void *)std::string buf = 0x72616C756C6C6543;
  LODWORD(v28) = 1296651109;
  v30[23] = 21;
  qmemcpy(v30, "Transfer plan listing", 21);
  strcpy((char *)v31, "1 min timer expi");
  v31[3] = (void *)23;
  (***(void (****)(Registry **__return_ptr))(v1 + 48))(&v24);
  ServiceMap = (std::mutex *)Registry::getServiceMap(v3, v24);
  uint64_t v5 = ServiceMap;
  if ((v6 & 0x8000000000000000) != 0)
  {
    uint64_t v7 = (unsigned __int8 *)(v6 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v8 = 5381;
    do
    {
      unint64_t v6 = v8;
      unsigned int v9 = *v7++;
      uint64_t v8 = (33 * v8) ^ v9;
    }
    while (v9);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v35 = v6;
  char v10 = sub_10004D37C(&v5[1].__m_.__sig, &v35);
  if (v10)
  {
    uint64_t v12 = v10[3];
    uint64_t v11 = (std::__shared_weak_count *)v10[4];
    if (v11)
    {
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v5);
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v11);
      char v13 = 0;
      goto LABEL_13;
    }
  }
  else
  {
    uint64_t v12 = 0;
  }
  std::mutex::unlock(v5);
  uint64_t v11 = 0;
  char v13 = 1;
LABEL_13:
  sub_1000DB86C((char *)__dst, (long long *)buf);
  v36[3] = 0;
  (*(void (**)(uint64_t, void **, void *))(*(void *)v12 + 16))(v12, __dst, v36);
  sub_1000DBADC(v36);
  if (v23 < 0) {
    operator delete(__p);
  }
  if (v21 < 0) {
    operator delete(v20);
  }
  if (v19 < 0) {
    operator delete(v18);
  }
  if (v17 < 0) {
    operator delete(v16);
  }
  if ((v15 & 0x80000000) == 0)
  {
    if (v13) {
      goto LABEL_24;
    }
    goto LABEL_23;
  }
  operator delete(__dst[0]);
  if ((v13 & 1) == 0) {
LABEL_23:
  }
    sub_10004D2C8(v11);
LABEL_24:
  if (v25) {
    sub_10004D2C8(v25);
  }
  if (SBYTE7(v33) < 0) {
    operator delete((void *)v32);
  }
  if (SHIBYTE(v31[2]) < 0) {
    operator delete(v31[0]);
  }
  if ((v30[23] & 0x80000000) != 0) {
    operator delete(*(void **)v30);
  }
  if (SHIBYTE(v29) < 0) {
    operator delete((void *)v28);
  }
  if (SHIBYTE(v27) < 0) {
    operator delete(*(void **)buf);
  }
}

void sub_100B415BC(_Unwind_Exception *a1)
{
  sub_100044D00((const void **)(v1 - 104));
  _Unwind_Resume(a1);
}

void sub_100B41630(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 976)) {
    return;
  }
  *(unsigned char *)(a1 + 976) = 1;
  if (*(void *)(a1 + 112))
  {
    uint64_t v2 = dispatch_group_create();
    uint64_t v3 = operator new(0x20uLL);
    v3[1] = 0;
    v3[2] = 0;
    void *v3 = off_1019B3378;
    *((unsigned char *)v3 + 24) = 0;
    uint64_t v4 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(buf) = 134217984;
      *(void *)((char *)&buf + 4) = a1;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I start transfer session on target. manatee. %p. fetching remote devices info from cloud", (uint8_t *)&buf, 0xCu);
    }
    uint64_t v37 = 0;
    uint64_t v38 = 0;
    *(void *)&long long buf = "CellularPlanTransferFlowController";
    sub_1002BFAE4((char **)&buf, (dispatch_object_t *)(a1 + 24), &v37);
    (***(void (****)(long long *__return_ptr))(a1 + 48))(&buf);
    Registry::createRestModuleOneTimeUseMobileHelperConnection(&v35, (Registry *)buf);
    ctu::RestModule::connect();
    if (v36) {
      sub_10004D2C8(v36);
    }
    if (*((void *)&buf + 1)) {
      sub_10004D2C8(*((std::__shared_weak_count **)&buf + 1));
    }
    uint64_t v5 = *(void *)(a1 + 112);
    uint64_t v6 = v37;
    uint64_t v7 = *(std::__shared_weak_count **)(a1 + 16);
    if (!v7 || (uint64_t v8 = *(void *)(a1 + 8), (v9 = std::__shared_weak_count::lock(v7)) == 0)) {
      sub_100088B9C();
    }
    char v10 = v9;
    atomic_fetch_add_explicit(&v9->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v9);
    uint64_t v11 = v37;
    uint64_t v12 = v38;
    if (v38) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v38 + 8), 1uLL, memory_order_relaxed);
    }
    atomic_fetch_add_explicit(v3 + 1, 1uLL, memory_order_relaxed);
    if (v2)
    {
      dispatch_retain(v2);
      dispatch_group_enter(v2);
    }
    long long v42 = 0;
    char v13 = operator new(0x48uLL);
    *char v13 = off_101A3EAF0;
    v13[1] = a1;
    v13[2] = v8;
    v13[3] = v10;
    void v13[4] = v11;
    v13[5] = v12;
    v13[6] = v3 + 3;
    uint64_t v13[7] = v3;
    unsigned char v13[8] = v2;
    long long v42 = v13;
    (*(void (**)(uint64_t, uint64_t, void *))(*(void *)v5 + 24))(v5, v6, v41);
    sub_1003425A0(v41);
    int v14 = operator new(0x30uLL);
    void v14[2] = 0;
    v14[1] = 0;
    void *v14 = off_1019BB170;
    void v14[4] = 0;
    v14[3] = v14 + 4;
    v14[5] = 0;
    atomic_fetch_add_explicit(v14 + 1, 1uLL, memory_order_relaxed);
    if (v2)
    {
      dispatch_retain(v2);
      dispatch_group_enter(v2);
    }
    char v40 = 0;
    char v15 = operator new(0x20uLL);
    void *v15 = off_101A3EC70;
    v15[1] = v14 + 3;
    _DWORD v15[2] = v14;
    v15[3] = v2;
    char v40 = v15;
    (***(void (****)(long long *__return_ptr))(a1 + 48))(&buf);
    ServiceMap = (std::mutex *)Registry::getServiceMap(v16, (Registry *)buf);
    char v18 = ServiceMap;
    char v19 = "30AKRemoteDeviceServiceInterface";
    if (((unint64_t)"30AKRemoteDeviceServiceInterface" & 0x8000000000000000) != 0)
    {
      uint64_t v20 = (unsigned __int8 *)((unint64_t)"30AKRemoteDeviceServiceInterface" & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v21 = 5381;
      do
      {
        char v19 = (const char *)v21;
        unsigned int v22 = *v20++;
        uint64_t v21 = (33 * v21) ^ v22;
      }
      while (v22);
    }
    std::mutex::lock(ServiceMap);
    v46[0] = (unint64_t)v19;
    char v23 = sub_10004D37C(&v18[1].__m_.__sig, v46);
    if (v23)
    {
      uint64_t v25 = v23[3];
      std::string::size_type v24 = (std::__shared_weak_count *)v23[4];
      if (v24)
      {
        atomic_fetch_add_explicit(&v24->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v18);
        atomic_fetch_add_explicit(&v24->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v24);
        char v26 = 0;
        goto LABEL_28;
      }
    }
    else
    {
      uint64_t v25 = 0;
    }
    std::mutex::unlock(v18);
    std::string::size_type v24 = 0;
    char v26 = 1;
LABEL_28:
    if (*((void *)&buf + 1)) {
      sub_10004D2C8(*((std::__shared_weak_count **)&buf + 1));
    }
    if (v25)
    {
      *(void *)&long long buf = a1;
      long long v28 = *(std::__shared_weak_count **)(a1 + 16);
      if (!v28 || (uint64_t v29 = *(void *)(a1 + 8), (v30 = std::__shared_weak_count::lock(v28)) == 0)) {
        sub_100088B9C();
      }
      *((void *)&buf + 1) = v29;
      long long v44 = v30;
      atomic_fetch_add_explicit(&v30->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v30);
      sub_10034CAE4((uint64_t)v45, (uint64_t)v39);
      long long v47 = 0;
      char v31 = (char *)operator new(0x40uLL);
      *(void *)char v31 = off_101A3F280;
      *(_OWORD *)(v31 + 8) = buf;
      *((void *)v31 + 3) = v44;
      *((void *)&buf + 1) = 0;
      long long v44 = 0;
      sub_10034CAE4((uint64_t)(v31 + 32), (uint64_t)v45);
      long long v47 = v31;
      (*(void (**)(uint64_t, unint64_t *))(*(void *)v25 + 24))(v25, v46);
      sub_10034D594(v46);
      sub_10034B83C(v45);
      if (v44) {
        std::__shared_weak_count::__release_weak(v44);
      }
      if ((v26 & 1) == 0) {
LABEL_36:
      }
        sub_10004D2C8(v24);
    }
    else
    {
      *((void *)&buf + 1) = 0;
      long long v44 = 0;
      *(void *)&long long buf = (char *)&buf + 8;
      if (!v40) {
        sub_10007B600();
      }
      (*(void (**)(void *, long long *))(*v40 + 48))(v40, &buf);
      sub_100313460((uint64_t)&buf, *((void **)&buf + 1));
      if ((v26 & 1) == 0) {
        goto LABEL_36;
      }
    }
    sub_10034B83C(v39);
    *(void *)&long long buf = v14 + 3;
    *((void *)&buf + 1) = v14;
    atomic_fetch_add_explicit(v14 + 1, 1uLL, memory_order_relaxed);
    long long v44 = (std::__shared_weak_count *)a1;
    long long v32 = *(std::__shared_weak_count **)(a1 + 16);
    if (v32)
    {
      uint64_t v33 = *(void *)(a1 + 8);
      uint64_t v34 = std::__shared_weak_count::lock(v32);
      if (v34)
      {
        v45[0] = v33;
        v45[1] = v34;
        atomic_fetch_add_explicit(&v34->__shared_weak_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v34);
        v45[2] = v3 + 3;
        v45[3] = v3;
        atomic_fetch_add_explicit(v3 + 1, 1uLL, memory_order_relaxed);
        operator new();
      }
    }
    sub_100088B9C();
  }
  long long v27 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
  {
    LOWORD(buf) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_ERROR, "invalid cloud sender - allTransferPlansHandled", (uint8_t *)&buf, 2u);
  }
}

void sub_100B41CEC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,std::__shared_weak_count *a26,uint64_t a27)
{
  sub_10034D594((void *)(v32 - 136));
  sub_10030A2EC(v32 - 192);
  if ((v29 & 1) == 0) {
    sub_10004D2C8(v31);
  }
  sub_10034B83C(&a27);
  sub_1003081C0((uint64_t)&a12);
  sub_10004D2C8(v30);
  if (a26) {
    sub_10004D2C8(a26);
  }
  sub_10004D2C8(v28);
  if (v27) {
    dispatch_release(v27);
  }
  _Unwind_Resume(a1);
}

void sub_100B41E2C(uint64_t a1)
{
  *(unsigned char *)(a1 + 848) = 1;
  if (*(unsigned char *)(a1 + 849)) {
    sub_100B41630(a1);
  }
}

void sub_100B41E44(uint64_t a1, int a2)
{
  if (*(unsigned __int8 *)(a1 + 849) != a2)
  {
    *(unsigned char *)(a1 + 849) = a2;
    if (*(unsigned char *)(a1 + 848)) {
      BOOL v2 = a2 == 0;
    }
    else {
      BOOL v2 = 1;
    }
    if (!v2) {
      sub_100B41630(a1);
    }
  }
}

void *sub_100B41E6C(void *a1)
{
  BOOL v2 = a1[7];
  if (v2)
  {
    dispatch_group_leave(v2);
    uint64_t v3 = a1[7];
    if (v3) {
      dispatch_release(v3);
    }
  }
  uint64_t v4 = (std::__shared_weak_count *)a1[6];
  if (v4) {
    sub_10004D2C8(v4);
  }
  uint64_t v5 = (std::__shared_weak_count *)a1[4];
  if (v5) {
    sub_10004D2C8(v5);
  }
  uint64_t v6 = (std::__shared_weak_count *)a1[2];
  if (v6) {
    std::__shared_weak_count::__release_weak(v6);
  }
  return a1;
}

void *sub_100B41ECC(void *a1)
{
  BOOL v2 = (std::__shared_weak_count *)a1[6];
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)a1[4];
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  uint64_t v4 = (std::__shared_weak_count *)a1[1];
  if (v4) {
    sub_10004D2C8(v4);
  }
  return a1;
}

void sub_100B41F14(uint64_t a1, uint64_t a2)
{
  uint64_t v5 = (os_log_t *)(a1 + 40);
  uint64_t v4 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Carrier Bundle update requested.", buf, 2u);
  }
  if (!*(unsigned char *)(a1 + 133))
  {
    char v17 = *v5;
    if (os_log_type_enabled(*v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I Carrier Bundle update not required", buf, 2u);
    }
    uint64_t v18 = *(void *)(a2 + 24);
    if (!v18) {
      sub_10007B600();
    }
    (*(void (**)(uint64_t))(*(void *)v18 + 48))(v18);
    return;
  }
  (***(void (****)(uint8_t *__return_ptr))(a1 + 48))(buf);
  ServiceMap = (std::mutex *)Registry::getServiceMap(v6, *(Registry **)buf);
  uint64_t v8 = ServiceMap;
  if (v9 < 0)
  {
    char v10 = (unsigned __int8 *)(v9 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v11 = 5381;
    do
    {
      uint64_t v9 = v11;
      unsigned int v12 = *v10++;
      uint64_t v11 = (33 * v11) ^ v12;
    }
    while (v12);
  }
  std::mutex::lock(ServiceMap);
  *(void *)&long long v39 = v9;
  char v13 = sub_10004D37C(&v8[1].__m_.__sig, (unint64_t *)&v39);
  if (!v13)
  {
    char v15 = 0;
    goto LABEL_15;
  }
  char v15 = (GestaltUtilityInterface *)v13[3];
  int v14 = (std::__shared_weak_count *)v13[4];
  if (!v14)
  {
LABEL_15:
    std::mutex::unlock(v8);
    int v14 = 0;
    char v16 = 1;
    goto LABEL_16;
  }
  atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v8);
  atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v14);
  char v16 = 0;
LABEL_16:
  isIPad = (capabilities::ct *)GestaltUtilityInterface::isIPad(v15);
  if (isIPad)
  {
    char v20 = capabilities::ct::defaultVinylCardTypeToGSMA(isIPad);
    if ((v16 & 1) == 0) {
      sub_10004D2C8(v14);
    }
    if (*(void *)&buf[8]) {
      sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
    }
    if ((v20 & 1) == 0)
    {
      uint64_t v21 = *v5;
      if (os_log_type_enabled(*v5, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "#I Carrier Bundle update not required for non GSMA iPad", buf, 2u);
      }
      uint64_t v22 = *(void *)(a2 + 24);
      if (!v22) {
        sub_10007B600();
      }
      (*(void (**)(uint64_t))(*(void *)v22 + 48))(v22);
      return;
    }
  }
  else
  {
    if ((v16 & 1) == 0) {
      sub_10004D2C8(v14);
    }
    if (*(void *)&buf[8]) {
      sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
    }
  }
  char v23 = *(std::__shared_weak_count **)(a1 + 72);
  if (v23)
  {
    std::string::size_type v24 = std::__shared_weak_count::lock(v23);
    if (v24)
    {
      uint64_t v25 = *(void *)(a1 + 64);
      if (v25)
      {
        if ((*(unsigned int (**)(uint64_t))(*(void *)v25 + 208))(v25) && *(unsigned char *)(a1 + 592) == 2)
        {
          char v26 = *v5;
          if (os_log_type_enabled(*v5, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)long long buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "#I Carrier Bundle update not available over bootstrap", buf, 2u);
          }
          uint64_t v27 = *(void *)(a2 + 24);
          if (!v27) {
            sub_10007B600();
          }
          (*(void (**)(uint64_t))(*(void *)v27 + 48))(v27);
        }
        else
        {
          memset(v34, 0, sizeof(v34));
          sub_100CDC204(v5, (uint64_t **)(a1 + 144), v34);
          *(void *)&long long v39 = a1;
          char v30 = *(std::__shared_weak_count **)(a1 + 16);
          if (!v30 || (uint64_t v31 = *(void *)(a1 + 8), (v32 = std::__shared_weak_count::lock(v30)) == 0)) {
            sub_100088B9C();
          }
          *((void *)&v39 + 1) = v31;
          char v40 = v32;
          atomic_fetch_add_explicit(&v32->__shared_weak_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v32);
          sub_1000F0058((uint64_t)v41, a2);
          xpc_object_t v38 = 0;
          rest::write_rest_value();
          sub_100058DB0(&__p, "/cc/requests/transfer_carrier_bundle_update");
          xpc_object_t object = v38;
          xpc_object_t v38 = xpc_null_create();
          *(_OWORD *)long long buf = v39;
          long long v43 = v40;
          *((void *)&v39 + 1) = 0;
          char v40 = 0;
          sub_1000DA470((uint64_t)v44, (uint64_t)v41);
          long long v46 = 0;
          uint64_t v33 = (char *)operator new(0x40uLL);
          *(void *)uint64_t v33 = off_101A3ED70;
          *(_OWORD *)(v33 + 8) = *(_OWORD *)buf;
          *((void *)v33 + 3) = v43;
          *(void *)&uint8_t buf[8] = 0;
          long long v43 = 0;
          sub_1000DA470((uint64_t)(v33 + 32), (uint64_t)v44);
          long long v46 = v33;
          ctu::RestModule::sendRequest();
          sub_10003F600(v45);
          sub_10003B34C(v44);
          if (v43) {
            std::__shared_weak_count::__release_weak(v43);
          }
          xpc_release(object);
          xpc_object_t object = 0;
          if (v37 < 0) {
            operator delete(__p);
          }
          xpc_release(v38);
          sub_10003B34C(v41);
          if (v40) {
            std::__shared_weak_count::__release_weak(v40);
          }
          *(void *)long long buf = v34;
          sub_1006881C0((void ***)buf);
        }
LABEL_54:
        sub_10004D2C8(v24);
        return;
      }
    }
  }
  else
  {
    std::string::size_type v24 = 0;
  }
  long long v28 = *v5;
  if (os_log_type_enabled(*v5, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_ERROR, "invalid delegate to check bootstrap", buf, 2u);
  }
  uint64_t v29 = *(void *)(a2 + 24);
  if (!v29) {
    sub_10007B600();
  }
  (*(void (**)(uint64_t))(*(void *)v29 + 48))(v29);
  if (v24) {
    goto LABEL_54;
  }
}

void sub_100B424A0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, xpc_object_t object, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, xpc_object_t a19, uint64_t a20,uint64_t a21,std::__shared_weak_count *a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,char a28,uint64_t a29)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_100B4259C(uint64_t a1)
{
  *(_WORD *)(a1 + 128) = 257;
  memset(&v15, 0, sizeof(v15));
  if (*(unsigned char *)(a1 + 768))
  {
    if ((*(char *)(a1 + 767) & 0x80000000) == 0)
    {
      if (!*(unsigned char *)(a1 + 767)) {
        goto LABEL_7;
      }
      goto LABEL_6;
    }
    if (*(void *)(a1 + 752)) {
LABEL_6:
    }
      std::string::operator=(&v15, (const std::string *)(a1 + 744));
  }
LABEL_7:
  *((void *)&v13 + 1) = 0;
  uint64_t v14 = 0;
  *(void *)&long long v13 = (char *)&v13 + 8;
  BOOL v2 = *(std::__shared_weak_count **)(a1 + 88);
  if (v2)
  {
    uint64_t v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      uint64_t v4 = v3;
      uint64_t v5 = *(void *)(a1 + 80);
      if (v5)
      {
        (*(void (**)(long long *__return_ptr))(*(void *)v5 + 224))(&v31);
        sub_10005CD2C((uint64_t)&v13, *((char **)&v13 + 1));
        uint64_t v6 = (char *)*((void *)&v31 + 1);
        long long v13 = v31;
        uint64_t v14 = v32;
        if ((void)v32)
        {
          *(void *)(*((void *)&v31 + 1) + 16) = (char *)&v13 + 8;
          *(void *)&long long v31 = (char *)&v31 + 8;
          *((void *)&v31 + 1) = 0;
          *(void *)&long long v32 = 0;
          uint64_t v6 = 0;
        }
        else
        {
          *(void *)&long long v13 = (char *)&v13 + 8;
        }
        sub_10005CD2C((uint64_t)&v31, v6);
      }
      sub_10004D2C8(v4);
    }
  }
  memset(v76, 0, 32);
  long long v74 = 0u;
  long long v75 = 0u;
  long long v72 = 0u;
  long long v73 = 0u;
  long long v70 = 0u;
  long long v71 = 0u;
  long long v69 = 0u;
  memset(v68, 0, sizeof(v68));
  long long v66 = 0u;
  long long v67 = 0u;
  long long v64 = 0u;
  long long v65 = 0u;
  long long v62 = 0u;
  long long v63 = 0u;
  long long v60 = 0u;
  long long v61 = 0u;
  long long v58 = 0u;
  long long v59 = 0u;
  long long v56 = 0u;
  long long v57 = 0u;
  long long v31 = 0uLL;
  *(void *)&long long v32 = 0;
  v17[1] = 0;
  *(void *)&long long v18 = 0;
  v17[0] = &v17[1];
  uint64_t v11 = 0;
  uint64_t v12 = 0;
  char v10 = (void **)&v11;
  sub_100CD1EF8((std::string *)(a1 + 672), (void *)(a1 + 48), (os_log_t *)(a1 + 40), (uint64_t *)&v31, (uint64_t *)(a1 + 624), a1 + 720, (uint64_t)&v15, (uint64_t)v17, (uint64_t)&v56, (const std::string **)(a1 + 800), (uint64_t)&v13, (uint64_t)&v10);
  sub_10010E37C((uint64_t)&v10, v11);
  sub_100330068((uint64_t)v17, (void *)v17[1]);
  v17[0] = &v31;
  sub_1000C56F4((void ***)v17);
  long long v54 = 0u;
  long long v55 = 0u;
  long long v52 = 0u;
  long long v53 = 0u;
  long long v50 = 0u;
  long long v51 = 0u;
  long long v48 = 0u;
  long long v49 = 0u;
  long long v46 = 0u;
  long long v47 = 0u;
  long long v44 = 0u;
  long long v45 = 0u;
  long long v42 = 0u;
  long long v43 = 0u;
  long long v40 = 0u;
  long long v41 = 0u;
  long long v38 = 0u;
  long long v39 = 0u;
  long long v36 = 0u;
  long long v37 = 0u;
  long long v34 = 0u;
  long long v35 = 0u;
  long long v32 = 0u;
  long long v33 = 0u;
  long long v31 = 0u;
  uint64_t v30 = 0;
  long long v28 = 0u;
  memset(v29, 0, sizeof(v29));
  long long v26 = 0u;
  long long v27 = 0u;
  long long v24 = 0u;
  long long v25 = 0u;
  long long v22 = 0u;
  long long v23 = 0u;
  long long v20 = 0u;
  long long v21 = 0u;
  long long v19 = 0u;
  *(_OWORD *)char v17 = 0u;
  long long v18 = 0u;
  sub_100311D64((uint64_t)v17, (uint64_t)&v56);
  LOBYTE(v30) = 1;
  char v10 = 0;
  uint64_t v11 = 0;
  uint64_t v12 = 0;
  memset(v9, 0, sizeof(v9));
  sub_10098E0F8((uint64_t)&v31, (os_log_t *)(a1 + 40), (uint64_t)v17, (const std::string *)&v69, (uint64_t *)&v10, v9);
  char v16 = v9;
  sub_100047F64((void ***)&v16);
  v9[0] = (void **)&v10;
  sub_10010DF1C(v9);
  unint64_t v7 = *(void *)(a1 + 152);
  if (v7 >= *(void *)(a1 + 160))
  {
    uint64_t v8 = sub_100312884((uint64_t *)(a1 + 144), (uint64_t)&v31);
  }
  else
  {
    sub_1003129A4(*(void *)(a1 + 152), (uint64_t)&v31);
    uint64_t v8 = v7 + 400;
    *(void *)(a1 + 152) = v7 + 400;
  }
  *(void *)(a1 + 152) = v8;
  if ((_BYTE)v30)
  {
    char v10 = (void **)&v29[8];
    sub_1000C56F4(&v10);
    if (SHIBYTE(v28) < 0) {
      operator delete(*((void **)&v27 + 1));
    }
    if (SBYTE7(v26) < 0) {
      operator delete((void *)v25);
    }
    if (BYTE8(v22))
    {
      if (SBYTE7(v24) < 0) {
        operator delete((void *)v23);
      }
      BYTE8(v22) = 0;
    }
    if (BYTE8(v20))
    {
      if (SBYTE7(v22) < 0) {
        operator delete((void *)v21);
      }
      BYTE8(v20) = 0;
    }
    if (SBYTE7(v20) < 0) {
      operator delete((void *)v19);
    }
    if (LOBYTE(v17[0]) && SHIBYTE(v18) < 0) {
      operator delete(v17[1]);
    }
  }
  sub_1000C52BC((uint64_t)&v31);
  *(void *)&long long v31 = &v76[8];
  sub_1000C5358((void ***)&v31);
  if ((v76[7] & 0x80000000) != 0) {
    operator delete((void *)v75);
  }
  if (SHIBYTE(v74) < 0) {
    operator delete(*((void **)&v73 + 1));
  }
  if (SBYTE7(v73) < 0) {
    operator delete((void *)v72);
  }
  if (SHIBYTE(v71) < 0) {
    operator delete(*((void **)&v70 + 1));
  }
  if (SBYTE7(v70) < 0) {
    operator delete((void *)v69);
  }
  *(void *)&long long v31 = &v68[8];
  sub_1000C56F4((void ***)&v31);
  if (SHIBYTE(v67) < 0) {
    operator delete(*((void **)&v66 + 1));
  }
  if (SBYTE7(v65) < 0) {
    operator delete((void *)v64);
  }
  if (BYTE8(v61))
  {
    if (SBYTE7(v63) < 0) {
      operator delete((void *)v62);
    }
    BYTE8(v61) = 0;
  }
  if (BYTE8(v59))
  {
    if (SBYTE7(v61) < 0) {
      operator delete((void *)v60);
    }
    BYTE8(v59) = 0;
  }
  if (SBYTE7(v59) < 0) {
    operator delete((void *)v58);
  }
  if ((_BYTE)v56 && SHIBYTE(v57) < 0) {
    operator delete(*((void **)&v56 + 1));
  }
  sub_10005CD2C((uint64_t)&v13, *((char **)&v13 + 1));
  if (SHIBYTE(v15.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v15.__r_.__value_.__l.__data_);
  }
}

void sub_100B42A58(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18, uint64_t a19, uint64_t a20,void *__p,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  long long v27 = v26;
  sub_10004D2C8(v27);
  sub_10005CD2C((uint64_t)&a18, (char *)a19);
  if (a26 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100B42B20(uint64_t a1)
{
  uint64_t v3 = (void **)(a1 + 360);
  sub_1000C5358(&v3);
  if (*(char *)(a1 + 359) < 0) {
    operator delete(*(void **)(a1 + 336));
  }
  if (*(char *)(a1 + 335) < 0) {
    operator delete(*(void **)(a1 + 312));
  }
  if (*(char *)(a1 + 311) < 0) {
    operator delete(*(void **)(a1 + 288));
  }
  if (*(char *)(a1 + 287) < 0) {
    operator delete(*(void **)(a1 + 264));
  }
  if (*(char *)(a1 + 263) < 0) {
    operator delete(*(void **)(a1 + 240));
  }
  return sub_1000C5634(a1);
}

void sub_100B42BB0(uint64_t a1)
{
  BOOL v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v5 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I session invalidated", v5, 2u);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 224);
  *(void *)(a1 + 216) = 0;
  *(void *)(a1 + 224) = 0;
  if (v3) {
    sub_10004D2C8(v3);
  }
  if (*(unsigned char *)(a1 + 135))
  {
    *(_WORD *)(a1 + 134) = 1;
    if (!*(unsigned char *)(a1 + 1020))
    {
      *(_DWORD *)(a1 + 1016) = 3;
      *(unsigned char *)(a1 + 1020) = 1;
    }
    if (!*(unsigned char *)(a1 + 1028))
    {
      *(_DWORD *)(a1 + 1024) = 70003;
      *(unsigned char *)(a1 + 1028) = 1;
    }
    sub_100B42C90(a1);
    if (*(void *)(a1 + 416))
    {
      uint64_t v4 = (void *)(a1 + 392);
      sub_1002EB2F8((uint64_t)v4, 0, 56);
      sub_100B69D80(v4);
    }
  }
}

void sub_100B42C90(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 952);
  *(void *)(a1 + 952) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  if (*(void *)(a1 + 296))
  {
    uint64_t v3 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v5 = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Clear cached transfer available plans callback", v5, 2u);
    }
    v7[0] = *(unsigned char *)(a1 + 264);
    sub_1000DFC90((uint64_t)v8, a1 + 272);
    sub_100B44058(*(void *)(a1 + 144), *(void *)(a1 + 152), (uint64_t)v7);
    sub_100060644(v8);
    sub_100555F38((void *)(a1 + 272));
  }
  if (*(void *)(a1 + 256))
  {
    uint64_t v4 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v5 = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Clear cached transfer plans list callback", v5, 2u);
    }
    sub_10031F4D0((uint64_t)v6, a1 + 232);
    sub_100B43250(a1, (uint64_t)v6);
    sub_100313790(v6);
    sub_100343904((void *)(a1 + 232));
  }
  if (*(unsigned char *)(a1 + 360))
  {
    if (*(char *)(a1 + 359) < 0) {
      operator delete(*(void **)(a1 + 336));
    }
    *(unsigned char *)(a1 + 360) = 0;
  }
}

void sub_100B42E30(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sub_100313790((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100B42E5C(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v6 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(v18) = 134217984;
    *(void *)((char *)&v18 + 4) = a1;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I start transfer session on target. card data. %p", (uint8_t *)&v18, 0xCu);
  }
  unint64_t v7 = (void *)(a1 + 144);
  unint64_t v8 = *(void *)(a1 + 144);
  *(unsigned char *)(a1 + 128) = a3;
  *(unsigned char *)(a1 + 130) = a3 == 3;
  *(unsigned char *)(a1 + 132) = a3 == 4;
  for (uint64_t i = *(void *)(a1 + 152); i != v8; uint64_t i = sub_1000C52BC(i - 400))
    ;
  unint64_t v10 = *(void *)(a1 + 160);
  *(void *)(a1 + 152) = v8;
  if (v8 >= v10)
  {
    unint64_t v13 = 0x8F5C28F5C28F5C29 * ((uint64_t)(v8 - *v7) >> 4);
    if (v13 + 1 > 0xA3D70A3D70A3D7) {
      sub_10006A748();
    }
    unint64_t v14 = 0x8F5C28F5C28F5C29 * ((uint64_t)(v10 - *v7) >> 4);
    uint64_t v15 = 2 * v14;
    if (2 * v14 <= v13 + 1) {
      uint64_t v15 = v13 + 1;
    }
    if (v14 >= 0x51EB851EB851EBLL) {
      unint64_t v16 = 0xA3D70A3D70A3D7;
    }
    else {
      unint64_t v16 = v15;
    }
    uint64_t v21 = a1 + 160;
    if (v16) {
      char v17 = (char *)sub_100312BAC(a1 + 160, v16);
    }
    else {
      char v17 = 0;
    }
    *(void *)&long long v18 = v17;
    *((void *)&v18 + 1) = &v17[400 * v13];
    uint64_t v19 = *((void *)&v18 + 1);
    long long v20 = &v17[400 * v16];
    sub_100312C8C(*((uint64_t *)&v18 + 1), a2);
    v19 += 400;
    sub_100312B34((uint64_t *)(a1 + 144), &v18);
    unint64_t v12 = *(void *)(a1 + 152);
    uint64_t result = sub_100312CE8((uint64_t)&v18);
  }
  else
  {
    uint64_t result = sub_100312C8C(v8, a2);
    unint64_t v12 = v8 + 400;
    *(void *)(a1 + 152) = v8 + 400;
  }
  *(void *)(a1 + 152) = v12;
  return result;
}

void sub_100B4304C(_Unwind_Exception *exception_object)
{
  *(void *)(v1 + 152) = v2;
  _Unwind_Resume(exception_object);
}

const void **sub_100B43074(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Get transfer plans list request", buf, 2u);
  }
  if (*(unsigned char *)(a1 + 128) == 2)
  {
    if (!*(void *)(a1 + 216))
    {
      uint64_t v9 = 0;
      sub_10031F910(a2, (uint64_t)&v9, 5);
      uint64_t v6 = (const void **)&v9;
      return sub_100044D00(v6);
    }
  }
  else if (!*(unsigned char *)(a1 + 128))
  {
    uint64_t v5 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "No ongoing transfer session exists", buf, 2u);
    }
    uint64_t v10 = 0;
    sub_10031F910(a2, (uint64_t)&v10, 5);
    uint64_t v6 = (const void **)&v10;
    return sub_100044D00(v6);
  }
  if (*(unsigned char *)(a1 + 134))
  {
    sub_10031F4D0((uint64_t)v12, a2);
    sub_100B43250(a1, (uint64_t)v12);
    return (const void **)sub_100313790(v12);
  }
  else
  {
    unint64_t v8 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Transfer Plan Listing callback cached", buf, 2u);
    }
    return (const void **)sub_10031F89C((void *)(a1 + 232), a2);
  }
}

void sub_100B43218(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9)
{
}

void sub_100B43250(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a1 + 143))
  {
    long long v92 = 0;
    sub_10031F910(a2, (uint64_t)&v92, 63);
    sub_100044D00(&v92);
    return;
  }
  *(void *)&long long v98 = a1;
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (!v4 || (uint64_t v5 = *(void *)(a1 + 8), (v6 = std::__shared_weak_count::lock(v4)) == 0)) {
    sub_100088B9C();
  }
  *((void *)&v98 + 1) = v5;
  long long v99 = v6;
  atomic_fetch_add_explicit(&v6->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v6);
  sub_10031F4D0((uint64_t)v100, a2);
  uint64_t v102 = 0;
  unint64_t v7 = (char *)operator new(0x40uLL);
  *(void *)unint64_t v7 = off_101A3F100;
  *(_OWORD *)(v7 + 8) = v98;
  *((void *)v7 + 3) = v99;
  *((void *)&v98 + 1) = 0;
  long long v99 = 0;
  sub_100349184((uint64_t)(v7 + 32), (uint64_t)v100);
  uint64_t v102 = v7;
  (***(void (****)(uint8_t *__return_ptr))(a1 + 48))(buf);
  ServiceMap = (std::mutex *)Registry::getServiceMap(v8, *(Registry **)buf);
  uint64_t v10 = ServiceMap;
  if (v11 < 0)
  {
    unint64_t v12 = (unsigned __int8 *)(v11 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v13 = 5381;
    do
    {
      uint64_t v11 = v13;
      unsigned int v14 = *v12++;
      uint64_t v13 = (33 * v13) ^ v14;
    }
    while (v14);
  }
  std::mutex::lock(ServiceMap);
  xpc_object_t v108 = (const std::string *)v11;
  uint64_t v15 = sub_10004D37C(&v10[1].__m_.__sig, (unint64_t *)&v108);
  if (!v15)
  {
    uint64_t v16 = 0;
    goto LABEL_12;
  }
  uint64_t v16 = v15[3];
  char v17 = (std::__shared_weak_count *)v15[4];
  if (!v17)
  {
LABEL_12:
    std::mutex::unlock(v10);
    char v17 = 0;
    char v18 = 1;
    goto LABEL_13;
  }
  atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v10);
  atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v17);
  char v18 = 0;
LABEL_13:
  if (*(void *)&buf[8]) {
    sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
  }
  if (v16 && (*(unsigned int (**)(uint64_t))(*(void *)v16 + 152))(v16) == 1)
  {
    *(void *)&uint8_t buf[8] = 0;
    xpc_object_t v104 = 0;
    *(void *)long long buf = &buf[8];
    if (!v102) {
      sub_10007B600();
    }
    (*(void (**)(char *, uint8_t *))(*(void *)v102 + 48))(v102, buf);
    sub_10005CD2C((uint64_t)buf, *(char **)&buf[8]);
    if ((v18 & 1) == 0) {
      goto LABEL_85;
    }
    goto LABEL_86;
  }
  long long v94 = 0;
  long long v95 = 0;
  uint64_t v96 = 0;
  uint64_t v19 = *(void *)(a1 + 144);
  uint64_t v91 = *(void *)(a1 + 152);
  if (v19 == v91)
  {
LABEL_76:
    *(void *)&uint8_t buf[8] = 0;
    xpc_object_t v104 = 0;
    *(void *)long long buf = &buf[8];
    if (!v102) {
      sub_10007B600();
    }
    (*(void (**)(char *, uint8_t *))(*(void *)v102 + 48))(v102, buf);
    sub_10005CD2C((uint64_t)buf, *(char **)&buf[8]);
    goto LABEL_84;
  }
  long long v87 = (void *)a1;
  char v89 = v18;
  long long v88 = v17;
  do
  {
    xpc_object_t v108 = 0;
    uint64_t v109 = 0;
    uint64_t v110 = 0;
    sub_10098EFE8(v19, (uint64_t *)&v108);
    long long v20 = v108;
    if (v109 - (uint64_t)v108 < 1) {
      goto LABEL_66;
    }
    uint64_t v21 = (v109 - (uint64_t)v108) >> 7;
    unint64_t v22 = (unint64_t)v95;
    uint64_t v23 = ((char *)v95 - (char *)v94) >> 7;
    long long v24 = (std::string *)((char *)v94 + (((char *)v95 - (char *)v94) & 0xFFFFFFFFFFFFFF80));
    if (v21 <= (v96 - (uint64_t)v95) >> 7)
    {
      uint64_t v29 = (char *)v95 - (char *)v24;
      uint64_t v30 = ((char *)v95 - (char *)v24) >> 7;
      if (v30 >= v21)
      {
        uint64_t v31 = (uint64_t)v108 + 128 * v21;
        uint64_t v32 = (uint64_t)v95;
      }
      else
      {
        uint64_t v31 = (uint64_t)v108 + 128 * v30;
        uint64_t v32 = sub_10030B52C((uint64_t)&v96, v31, v109, (uint64_t)v95);
        long long v95 = (std::string *)v32;
        if (v29 < 1) {
          goto LABEL_66;
        }
      }
      long long v33 = (char *)v24 + 128 * v21;
      uint64_t v34 = (v32 - (uint64_t)v33) >> 7;
      unint64_t v35 = v32 - (v21 << 7);
      uint64_t v36 = v32;
      if (v35 < v22)
      {
        uint64_t v37 = 0;
        uint64_t v38 = (uint64_t)v94 + 128 * v23 + 128 * v34;
        do
        {
          uint64_t v39 = v32 + v37;
          long long v40 = (long long *)(v38 + v37);
          *(unsigned char *)uint64_t v39 = 0;
          *(unsigned char *)(v39 + 24) = 0;
          if (*(unsigned char *)(v38 + v37 + 24))
          {
            long long v41 = *v40;
            *(void *)(v39 + 16) = *((void *)v40 + 2);
            *(_OWORD *)uint64_t v39 = v41;
            *((void *)v40 + 1) = 0;
            *((void *)v40 + 2) = 0;
            *(void *)long long v40 = 0;
            *(unsigned char *)(v39 + 24) = 1;
          }
          long long v42 = v40[2];
          *(void *)(v39 + 48) = *((void *)v40 + 6);
          *(_OWORD *)(v39 + 32) = v42;
          *((void *)v40 + 5) = 0;
          *((void *)v40 + 6) = 0;
          *((void *)v40 + 4) = 0;
          long long v43 = *(long long *)((char *)v40 + 56);
          *(void *)(v39 + 72) = *((void *)v40 + 9);
          *(_OWORD *)(v39 + 56) = v43;
          *((void *)v40 + 8) = 0;
          *((void *)v40 + 9) = 0;
          *((void *)v40 + 7) = 0;
          long long v44 = v40[5];
          *(void *)(v39 + 96) = *((void *)v40 + 12);
          *(_OWORD *)(v39 + 80) = v44;
          *((void *)v40 + 11) = 0;
          *((void *)v40 + 12) = 0;
          *((void *)v40 + 10) = 0;
          long long v45 = *(long long *)((char *)v40 + 104);
          *(void *)(v39 + 120) = *((void *)v40 + 15);
          *(_OWORD *)(v39 + 104) = v45;
          *((void *)v40 + 13) = 0;
          *((void *)v40 + 14) = 0;
          *((void *)v40 + 15) = 0;
          v37 += 128;
        }
        while (v38 + v37 < v22);
        uint64_t v36 = v32 + v37;
      }
      uint64_t v90 = v19;
      long long v95 = (std::string *)v36;
      if ((char *)v32 != v33)
      {
        uint64_t v46 = 0;
        uint64_t v47 = -128 * v34;
        do
        {
          sub_100179CB0(v32 + v46 - 128, (__n128 *)(v35 + v46 - 128));
          long long v48 = (void **)(v32 + v46 - 96);
          if (*(char *)(v32 + v46 - 73) < 0) {
            operator delete(*v48);
          }
          long long v49 = (long long *)(v35 + v46 - 96);
          uint64_t v50 = v35 + v46;
          long long v51 = *v49;
          *(void *)(v32 + v46 - 80) = *(void *)(v35 + v46 - 80);
          *(_OWORD *)long long v48 = v51;
          *(unsigned char *)(v35 + v46 - 73) = 0;
          *(unsigned char *)long long v49 = 0;
          uint64_t v52 = v32 + v46;
          long long v53 = (void **)(v32 + v46 - 72);
          if (*(char *)(v32 + v46 - 49) < 0) {
            operator delete(*v53);
          }
          long long v54 = *(_OWORD *)(v50 - 72);
          *(void *)(v32 + v46 - 56) = *(void *)(v50 - 56);
          *(_OWORD *)long long v53 = v54;
          *(unsigned char *)(v50 - 49) = 0;
          *(unsigned char *)(v50 - 72) = 0;
          long long v55 = (void **)(v52 - 48);
          if (*(char *)(v52 - 25) < 0) {
            operator delete(*v55);
          }
          long long v56 = (long long *)(v50 - 48);
          uint64_t v57 = v35 + v46;
          long long v58 = *v56;
          *(void *)(v52 - 32) = *((void *)v56 + 2);
          *(_OWORD *)long long v55 = v58;
          *(unsigned char *)(v35 + v46 - 25) = 0;
          *(unsigned char *)long long v56 = 0;
          long long v59 = (void **)(v32 + v46 - 24);
          if (*(char *)(v32 + v46 - 1) < 0) {
            operator delete(*v59);
          }
          long long v60 = *(_OWORD *)(v57 - 24);
          *(void *)(v32 + v46 - 8) = *(void *)(v57 - 8);
          *(_OWORD *)long long v59 = v60;
          *(unsigned char *)(v57 - 1) = 0;
          *(unsigned char *)(v57 - 24) = 0;
          v46 -= 128;
        }
        while (v47 != v46);
      }
      uint64_t v19 = v90;
      if ((const std::string *)v31 != v20)
      {
        do
        {
          sub_100179AF8(v24, v20);
          long long v61 = (std::string *)((char *)v24 + 32);
          long long v62 = (const std::string *)((char *)v20 + 32);
          std::string::operator=(v61++, v62);
          std::string::operator=(v61++, ++v62);
          std::string::operator=(v61++, ++v62);
          std::string::operator=(v61, ++v62);
          long long v20 = v62 + 1;
          long long v24 = v61 + 1;
        }
        while (v20 != (const std::string *)v31);
      }
    }
    else
    {
      unint64_t v25 = v23 + v21;
      if ((unint64_t)(v23 + v21) >> 57) {
        sub_10006A748();
      }
      uint64_t v26 = v96 - (void)v94;
      if ((v96 - (uint64_t)v94) >> 6 > v25) {
        unint64_t v25 = v26 >> 6;
      }
      if ((unint64_t)v26 >= 0x7FFFFFFFFFFFFF80) {
        unint64_t v27 = 0x1FFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v27 = v25;
      }
      *((void *)&v105 + 1) = &v96;
      if (v27) {
        long long v28 = (char *)sub_100043864((uint64_t)&v96, v27);
      }
      else {
        long long v28 = 0;
      }
      long long v63 = (std::__shared_weak_count *)&v28[128 * v23];
      *(void *)long long buf = v28;
      *(void *)&uint8_t buf[8] = v63;
      xpc_object_t v104 = v63;
      *(void *)&long long v105 = &v28[128 * v27];
      uint64_t v64 = v21 << 7;
      long long v65 = (std::__shared_weak_count *)((char *)v63 + 128 * v21);
      do
      {
        sub_10030B264((uint64_t)v63, (uint64_t)v20);
        long long v63 = (std::__shared_weak_count *)((char *)v63 + 128);
        long long v20 = (const std::string *)((char *)v20 + 128);
        v64 -= 128;
      }
      while (v64);
      xpc_object_t v104 = v65;
      sub_10031310C((uint64_t)&v96, (uint64_t)v24, (uint64_t)v24, (uint64_t)v94, (uint64_t)v94, *(uint64_t *)&buf[8], *(uint64_t *)&buf[8]);
      *(void *)&uint8_t buf[8] = v66;
      uint64_t v67 = (uint64_t)v95;
      long long v68 = v104;
      if (v95 != v24)
      {
        uint64_t v69 = 0;
        do
        {
          long long v70 = (char *)v68 + v69;
          long long v71 = (char *)v24 + v69;
          *long long v70 = 0;
          v70[24] = 0;
          if (v24[1].__r_.__value_.__s.__data_[v69])
          {
            long long v72 = *(_OWORD *)v71;
            *((void *)v70 + 2) = *((void *)v71 + 2);
            *(_OWORD *)long long v70 = v72;
            *((void *)v71 + 1) = 0;
            *((void *)v71 + 2) = 0;
            *(void *)long long v71 = 0;
            v70[24] = 1;
          }
          long long v73 = *((_OWORD *)v71 + 2);
          *((void *)v70 + 6) = *((void *)v71 + 6);
          *((_OWORD *)v70 + 2) = v73;
          *((void *)v71 + 5) = 0;
          *((void *)v71 + 6) = 0;
          *((void *)v71 + 4) = 0;
          long long v74 = *(_OWORD *)(v71 + 56);
          *((void *)v70 + 9) = *((void *)v71 + 9);
          *(_OWORD *)(v70 + 56) = v74;
          *((void *)v71 + 8) = 0;
          *((void *)v71 + 9) = 0;
          *((void *)v71 + 7) = 0;
          long long v75 = *((_OWORD *)v71 + 5);
          *((void *)v70 + 12) = *((void *)v71 + 12);
          *((_OWORD *)v70 + 5) = v75;
          *((void *)v71 + 11) = 0;
          *((void *)v71 + 12) = 0;
          *((void *)v71 + 10) = 0;
          long long v76 = *(_OWORD *)(v71 + 104);
          *((void *)v70 + 15) = *((void *)v71 + 15);
          *(_OWORD *)(v70 + 104) = v76;
          *((void *)v71 + 13) = 0;
          *((void *)v71 + 14) = 0;
          *((void *)v71 + 15) = 0;
          v69 += 128;
        }
        while ((std::string *)((char *)v24 + v69) != (std::string *)v67);
        uint64_t v66 = *(void *)&buf[8];
        long long v24 = v95;
        long long v68 = (std::__shared_weak_count *)((char *)v68 + v69);
      }
      uint64_t v77 = (uint64_t)v94;
      uint64_t v78 = v96;
      long long v94 = (std::string *)v66;
      long long v95 = (std::string *)v68;
      uint64_t v96 = v105;
      xpc_object_t v104 = (std::__shared_weak_count *)v24;
      *(void *)&long long v105 = v78;
      *(void *)long long buf = v77;
      *(void *)&uint8_t buf[8] = v77;
      sub_1003131D8((uint64_t)buf);
    }
LABEL_66:
    *(void *)long long buf = &v108;
    sub_10030B640((void ***)buf);
    v19 += 400;
  }
  while (v19 != v91);
  char v17 = v88;
  char v18 = v89;
  if (v94 == v95) {
    goto LABEL_76;
  }
  uint64_t v79 = (std::__shared_weak_count *)v87[9];
  if (v79)
  {
    uint64_t v80 = std::__shared_weak_count::lock(v79);
    if (v80)
    {
      uint64_t v81 = v87[8];
      if (v81)
      {
        memset(v93, 0, sizeof(v93));
        sub_10030B4A4(v93, (uint64_t)v94, (uint64_t)v95, ((char *)v95 - (char *)v94) >> 7);
        *(void *)long long buf = v87;
        xpc_object_t v82 = (std::__shared_weak_count *)v87[2];
        if (!v82 || (uint64_t v83 = v87[1], (v84 = std::__shared_weak_count::lock(v82)) == 0)) {
          sub_100088B9C();
        }
        *(void *)&uint8_t buf[8] = v83;
        xpc_object_t v104 = v84;
        atomic_fetch_add_explicit(&v84->__shared_weak_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v84);
        long long v105 = 0uLL;
        uint64_t v106 = 0;
        sub_10030B4A4(&v105, (uint64_t)v94, (uint64_t)v95, ((char *)v95 - (char *)v94) >> 7);
        sub_10033D1E4((uint64_t)v107, (uint64_t)v101);
        xpc_object_t v111 = 0;
        unint64_t v85 = (char *)operator new(0x58uLL);
        *(void *)unint64_t v85 = off_101A3F200;
        *(_OWORD *)(v85 + 8) = *(_OWORD *)buf;
        *((void *)v85 + 3) = v104;
        *(void *)&uint8_t buf[8] = 0;
        xpc_object_t v104 = 0;
        *((_OWORD *)v85 + 2) = v105;
        *((void *)v85 + 6) = v106;
        uint64_t v106 = 0;
        long long v105 = 0uLL;
        sub_10033D27C((uint64_t)(v85 + 56), (uint64_t)v107);
        xpc_object_t v111 = v85;
        (*(void (**)(uint64_t, void *, const std::string **))(*(void *)v81 + 72))(v81, v93, &v108);
        sub_10030DD28(&v108);
        sub_10030DD28(v107);
        long long v97 = (std::string **)&v105;
        sub_10030B640((void ***)&v97);
        if (v104) {
          std::__shared_weak_count::__release_weak(v104);
        }
        long long v97 = (std::string **)v93;
        sub_10030B640((void ***)&v97);
        goto LABEL_83;
      }
    }
  }
  else
  {
    uint64_t v80 = 0;
  }
  uint64_t v86 = v87[5];
  if (os_log_type_enabled(v86, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v86, OS_LOG_TYPE_ERROR, "Invalid delegate to check eligibility", buf, 2u);
  }
  *(void *)&uint8_t buf[8] = 0;
  xpc_object_t v104 = 0;
  *(void *)long long buf = &buf[8];
  if (!v102) {
    sub_10007B600();
  }
  (*(void (**)(char *, uint8_t *))(*(void *)v102 + 48))(v102, buf);
  sub_10005CD2C((uint64_t)buf, *(char **)&buf[8]);
  if (v80) {
LABEL_83:
  }
    sub_10004D2C8(v80);
LABEL_84:
  long long v97 = &v94;
  sub_10030B640((void ***)&v97);
  if ((v18 & 1) == 0) {
LABEL_85:
  }
    sub_10004D2C8(v17);
LABEL_86:
  sub_10030DD28(v101);
  sub_100313790(v100);
  if (v99) {
    std::__shared_weak_count::__release_weak(v99);
  }
}

void sub_100B43C98(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12, int a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18, uint64_t a19, uint64_t a20,uint64_t a21,char a22,uint64_t a23,uint64_t a24,uint64_t *a25,char a26,uint64_t a27,std::__shared_weak_count *a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34)
{
  sub_10030DD28((void *)(v35 - 128));
  sub_100B50A70(v35 - 208);
  a25 = &a19;
  sub_10030B640((void ***)&a25);
  sub_10004D2C8(v34);
  a25 = (uint64_t *)&a22;
  sub_10030B640((void ***)&a25);
  if ((a14 & 1) == 0) {
    sub_10004D2C8(a12);
  }
  sub_10030DD28(&a34);
  sub_100B4E6D8((uint64_t)&a26);
  _Unwind_Resume(a1);
}

void *sub_100B43E6C(uint64_t a1, unsigned int a2, uint64_t a3)
{
  if (*(unsigned char *)(a1 + 128) != 2)
  {
    if (!*(unsigned char *)(a1 + 128))
    {
      uint64_t v6 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "No ongoing transfer seession exists", buf, 2u);
      }
      return (void *)sub_1000607A8(a3, 0);
    }
    goto LABEL_7;
  }
  if (*(void *)(a1 + 216))
  {
LABEL_7:
    if (*(unsigned char *)(a1 + 134))
    {
      v10[0] = sub_1008A200C(a2);
      unint64_t v8 = v11;
      sub_1000DFC90((uint64_t)v11, a3);
      sub_100B44058(*(void *)(a1 + 144), *(void *)(a1 + 152), (uint64_t)v10);
    }
    else
    {
      uint64_t v9 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I Transfer Plan Available callback cached", buf, 2u);
      }
      buf[0] = sub_1008A200C(a2);
      unint64_t v8 = v13;
      sub_1000DFC90((uint64_t)v13, a3);
      *(unsigned char *)(a1 + 264) = buf[0];
      sub_100555EB4((void *)(a1 + 272), (uint64_t)v13);
    }
    return sub_100060644(v8);
  }

  return (void *)sub_1000607A8(a3, 0);
}

void sub_100B4402C(_Unwind_Exception *exception_object, int a2)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100B44058(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a1 == a2)
  {
    char v6 = 0;
  }
  else
  {
    uint64_t v5 = a1;
    do
    {
      char v6 = sub_10098EF00(v5, 0);
      if (v6) {
        break;
      }
      v5 += 400;
    }
    while (v5 != a2);
  }

  return sub_1000607A8(a3 + 8, v6);
}

void sub_100B440CC(uint64_t a1, uint64_t *a2, long long *a3, char a4, uint64_t a5)
{
  sub_100B45AA0(a1 + 424);
  uint64_t v8 = a2[1];
  xpc_object_t v127 = a2;
  if (*a2 != v8)
  {
    uint64_t v9 = *a2 + 40;
    do
    {
      uint64_t v10 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
        std::string::size_type v11 = v9;
        if (*(char *)(v9 + 23) < 0) {
          std::string::size_type v11 = *(void *)v9;
        }
        LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
        *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = v11;
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I plan(%s) is scheduled to transfer", (uint8_t *)&buf, 0xCu);
      }
      uint64_t v12 = v9 + 24;
      v9 += 64;
    }
    while (v12 != v8);
  }
  int v13 = *(unsigned __int8 *)(a1 + 128);
  if ((v13 - 3) < 2) {
    goto LABEL_11;
  }
  if (*(unsigned char *)(a1 + 128))
  {
    if (v13 != 1)
    {
      char v126 = a4;
      uint64_t v15 = *a2;
      uint64_t v14 = a2[1];
LABEL_19:
      long long v131 = 0uLL;
      unint64_t v132 = 0;
      if (v15 == v14) {
        goto LABEL_248;
      }
      char v130 = (const std::string *)(a1 + 776);
      while (1)
      {
        char v18 = *(unsigned __int8 **)(a1 + 856);
        uint64_t v19 = *(unsigned __int8 **)(a1 + 864);
        if (*(char *)(v15 + 63) < 0)
        {
          sub_10004FC84(__p, *(void **)(v15 + 40), *(void *)(v15 + 48));
        }
        else
        {
          *(_OWORD *)std::string __p = *(_OWORD *)(v15 + 40);
          uint64_t v139 = *(void *)(v15 + 56);
        }
        uint64_t v20 = HIBYTE(v139);
        if (v18 != v19)
        {
          unint64_t v22 = __p[0];
          uint64_t v21 = __p[1];
          if (v139 >= 0) {
            uint64_t v23 = (void *)HIBYTE(v139);
          }
          else {
            uint64_t v23 = __p[1];
          }
          do
          {
            long long v24 = (void *)v18[455];
            int v25 = (char)v24;
            if ((char)v24 < 0) {
              long long v24 = (void *)*((void *)v18 + 55);
            }
            if (v23 == v24)
            {
              if (v25 >= 0) {
                uint64_t v26 = v18 + 432;
              }
              else {
                uint64_t v26 = (unsigned __int8 *)*((void *)v18 + 54);
              }
              if ((v20 & 0x80) != 0)
              {
                if (!memcmp(v22, v26, (size_t)v21)) {
                  goto LABEL_44;
                }
              }
              else
              {
                if (!v20) {
                  goto LABEL_45;
                }
                unint64_t v27 = __p;
                uint64_t v28 = v20;
                while (*(unsigned __int8 *)v27 == *v26)
                {
                  unint64_t v27 = (void **)((char *)v27 + 1);
                  ++v26;
                  if (!--v28) {
                    goto LABEL_43;
                  }
                }
              }
            }
            v18 += 1248;
          }
          while (v18 != v19);
          char v18 = v19;
        }
LABEL_43:
        if ((v20 & 0x80) != 0) {
LABEL_44:
        }
          operator delete(__p[0]);
LABEL_45:
        if (v18 == *(unsigned __int8 **)(a1 + 864)) {
          goto LABEL_126;
        }
        bzero(&buf, 0x5F0uLL);
        if (!sub_100B409A4(a1, (uint64_t)&buf, v15, a3, v130))
        {
          uint64_t v29 = *(NSObject **)(a1 + 40);
          if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)__int16 v162 = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_ERROR, "failed to create TransferPlanDetails", v162, 2u);
          }
        }
        int v30 = v18[1];
        if ((v30 - 7) < 2) {
          break;
        }
        if (v30 != 9) {
          goto LABEL_125;
        }
        long long v33 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
        {
          if (*(char *)(v15 + 63) >= 0) {
            uint64_t v34 = v15 + 40;
          }
          else {
            uint64_t v34 = *(void *)(v15 + 40);
          }
          *(_DWORD *)__int16 v162 = 136315138;
          *(void *)&v162[4] = v34;
          _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "#I trigger install from DS flow. iccid: %s", v162, 0xCu);
        }
        uint64_t v173 = 0;
        sub_100B4B5F8((void *)a1, 16, (uint64_t)v171);
        sub_100313668(v171);
        unsigned int v35 = *v18 - 1;
        if (v35 > 0xA) {
          uint8_t v36 = 0;
        }
        else {
          uint8_t v36 = byte_10154B635[(char)v35];
        }
        v162[0] = v36;
        v156[0] = 9;
        sub_100B4B75C(a1, v162, v156, (uint64_t)&buf, 1, 0);
LABEL_194:
        sub_100B615AC((uint64_t)&buf);
LABEL_195:
        v15 += 64;
        if (v15 == v14)
        {
          if ((void)v131 != *((void *)&v131 + 1))
          {
            uint64_t v74 = *v127;
            uint64_t v75 = v127[1];
            if (*v127 != v75)
            {
              while (2)
              {
                uint64_t v76 = *(void *)(a1 + 856);
                uint64_t v77 = *(void *)(a1 + 864);
                if (*(char *)(v74 + 63) < 0) {
                  sub_10004FC84(&buf, *(void **)(v74 + 40), *(void *)(v74 + 48));
                }
                else {
                  std::string buf = *(std::string *)(v74 + 40);
                }
                uint64_t v78 = HIBYTE(buf.__r_.__value_.__r.__words[2]);
                if (v76 != v77)
                {
                  size_t size = buf.__r_.__value_.__l.__size_;
                  uint64_t v80 = (const void *)buf.__r_.__value_.__r.__words[0];
                  if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                    std::string::size_type v81 = HIBYTE(buf.__r_.__value_.__r.__words[2]);
                  }
                  else {
                    std::string::size_type v81 = buf.__r_.__value_.__l.__size_;
                  }
                  do
                  {
                    uint64_t v82 = *(unsigned __int8 *)(v76 + 455);
                    int v83 = (char)v82;
                    if ((v82 & 0x80u) != 0) {
                      uint64_t v82 = *(void *)(v76 + 440);
                    }
                    if (v81 == v82)
                    {
                      if (v83 >= 0) {
                        uint64_t v84 = (unsigned __int8 *)(v76 + 432);
                      }
                      else {
                        uint64_t v84 = *(unsigned __int8 **)(v76 + 432);
                      }
                      if ((v78 & 0x80) != 0)
                      {
                        if (!memcmp(v80, v84, size)) {
                          goto LABEL_226;
                        }
                      }
                      else
                      {
                        if (!v78) {
                          goto LABEL_227;
                        }
                        p_std::string buf = &buf;
                        uint64_t v86 = v78;
                        while (p_buf->__r_.__value_.__s.__data_[0] == *v84)
                        {
                          p_std::string buf = (std::string *)((char *)p_buf + 1);
                          ++v84;
                          if (!--v86) {
                            goto LABEL_225;
                          }
                        }
                      }
                    }
                    v76 += 1248;
                  }
                  while (v76 != v77);
                  uint64_t v76 = v77;
                }
LABEL_225:
                if ((v78 & 0x80) != 0) {
LABEL_226:
                }
                  operator delete(buf.__r_.__value_.__l.__data_);
LABEL_227:
                if (v76 == *(void *)(a1 + 864) || *(unsigned char *)(v76 + 1) != 6) {
                  goto LABEL_243;
                }
                (***(void (****)(uint8_t *__return_ptr))(a1 + 48))(v162);
                ServiceMap = (std::mutex *)Registry::getServiceMap(v87, *(Registry **)v162);
                char v89 = ServiceMap;
                if (v90 < 0)
                {
                  uint64_t v91 = (unsigned __int8 *)(v90 & 0x7FFFFFFFFFFFFFFFLL);
                  uint64_t v92 = 5381;
                  do
                  {
                    uint64_t v90 = v92;
                    unsigned int v93 = *v91++;
                    uint64_t v92 = (33 * v92) ^ v93;
                  }
                  while (v93);
                }
                std::mutex::lock(ServiceMap);
                *(void *)__int16 v156 = v90;
                long long v94 = sub_10004D37C(&v89[1].__m_.__sig, (unint64_t *)v156);
                if (v94)
                {
                  uint64_t v96 = v94[3];
                  long long v95 = (std::__shared_weak_count *)v94[4];
                  if (v95)
                  {
                    atomic_fetch_add_explicit(&v95->__shared_owners_, 1uLL, memory_order_relaxed);
                    std::mutex::unlock(v89);
                    atomic_fetch_add_explicit(&v95->__shared_owners_, 1uLL, memory_order_relaxed);
                    sub_10004D2C8(v95);
                    char v97 = 0;
                    if (!v96)
                    {
LABEL_239:
                      if ((v97 & 1) == 0) {
                        sub_10004D2C8(v95);
                      }
                      if (*(void *)&v162[8]) {
                        sub_10004D2C8(*(std::__shared_weak_count **)&v162[8]);
                      }
LABEL_243:
                      v74 += 64;
                      if (v74 == v75) {
                        goto LABEL_244;
                      }
                      continue;
                    }
LABEL_238:
                    (*(void (**)(uint64_t, uint64_t))(*(void *)v96 + 24))(v96, 4);
                    goto LABEL_239;
                  }
                }
                else
                {
                  uint64_t v96 = 0;
                }
                break;
              }
              std::mutex::unlock(v89);
              long long v95 = 0;
              char v97 = 1;
              if (!v96) {
                goto LABEL_239;
              }
              goto LABEL_238;
            }
LABEL_244:
            sub_10031DDB0((uint64_t)&buf, a5);
            uint64_t v98 = a1 + 392;
            if (&buf != (std::string *)(a1 + 392))
            {
              uint64_t v99 = v175[0];
              uint64_t v100 = *(void *)(a1 + 416);
              if ((std::string *)v175[0] == &buf)
              {
                if (v100 == v98)
                {
                  memset(v162, 0, sizeof(v162));
                  v163[0] = 0;
                  (*(void (**)(std::string *, uint8_t *))(buf.__r_.__value_.__r.__words[0] + 24))(&buf, v162);
                  (*(void (**)(void))(*(void *)v175[0] + 32))(v175[0]);
                  v175[0] = 0;
                  (*(void (**)(void, std::string *))(**(void **)(a1 + 416) + 24))(*(void *)(a1 + 416), &buf);
                  (*(void (**)(void))(**(void **)(a1 + 416) + 32))(*(void *)(a1 + 416));
                  *(void *)(a1 + 416) = 0;
                  v175[0] = &buf;
                  (*(void (**)(uint8_t *, uint64_t))(*(void *)v162 + 24))(v162, a1 + 392);
                  (*(void (**)(uint8_t *))(*(void *)v162 + 32))(v162);
                }
                else
                {
                  (*(void (**)(std::string *, uint64_t))(buf.__r_.__value_.__r.__words[0] + 24))(&buf, a1 + 392);
                  (*(void (**)(void))(*(void *)v175[0] + 32))(v175[0]);
                  v175[0] = *(void *)(a1 + 416);
                }
                *(void *)(a1 + 416) = v98;
              }
              else if (v100 == v98)
              {
                (*(void (**)(uint64_t, std::string *))(*(void *)v98 + 24))(a1 + 392, &buf);
                (*(void (**)(void))(**(void **)(a1 + 416) + 32))(*(void *)(a1 + 416));
                *(void *)(a1 + 416) = v175[0];
                v175[0] = &buf;
              }
              else
              {
                v175[0] = *(void *)(a1 + 416);
                *(void *)(a1 + 416) = v99;
              }
            }
            sub_10023D374(&buf);
            *(void *)&long long v140 = a1;
            long long v105 = *(std::__shared_weak_count **)(a1 + 16);
            if (!v105 || (uint64_t v106 = *(void *)(a1 + 8), (v107 = std::__shared_weak_count::lock(v105)) == 0)) {
              sub_100088B9C();
            }
            *((void *)&v140 + 1) = v106;
            uint64_t v141 = v107;
            atomic_fetch_add_explicit(&v107->__shared_weak_owners_, 1uLL, memory_order_relaxed);
            sub_10004D2C8(v107);
            long long v142 = 0uLL;
            uint64_t v143 = 0;
            sub_10030CD0C(&v142, v131, *((uint64_t *)&v131 + 1), (uint64_t)(*((void *)&v131 + 1) - v131) >> 6);
            long long v144 = *a3;
            char v145 = v126;
            uint64_t v147 = 0;
            xpc_object_t v108 = (char *)operator new(0x50uLL);
            *(void *)xpc_object_t v108 = off_101A3EDF0;
            *(_OWORD *)(v108 + 8) = v140;
            uint64_t v109 = v143;
            *((void *)v108 + 3) = v141;
            *((void *)&v140 + 1) = 0;
            uint64_t v141 = 0;
            *((_OWORD *)v108 + 2) = v142;
            *((void *)v108 + 6) = v109;
            uint64_t v143 = 0;
            long long v142 = 0uLL;
            *(_OWORD *)(v108 + 56) = v144;
            v108[72] = v145;
            uint64_t v147 = v108;
            int v110 = *(unsigned __int8 *)(a1 + 128);
            if (v110 != 2)
            {
              xpc_object_t v111 = *(NSObject **)(a1 + 40);
              if (os_log_type_enabled(v111, OS_LOG_TYPE_DEFAULT))
              {
                LOWORD(buf.__r_.__value_.__l.__data_) = 0;
                _os_log_impl((void *)&_mh_execute_header, v111, OS_LOG_TYPE_DEFAULT, "#I Skip for non proximity flow", (uint8_t *)&buf, 2u);
              }
              goto LABEL_300;
            }
            if (*(void *)(a1 + 216))
            {
              memset(v156, 0, sizeof(v156));
              v157[0] = 0;
              uint64_t v112 = *((void *)&v131 + 1);
              if ((void)v131 != *((void *)&v131 + 1))
              {
                unint64_t v113 = 0;
                uint64_t v114 = v131 + 40;
                do
                {
                  if ((void *)v113 >= v157[0])
                  {
                    unint64_t v113 = sub_10030E9EC((uint64_t *)v156, (long long *)v114);
                  }
                  else
                  {
                    if (*(char *)(v114 + 23) < 0)
                    {
                      sub_10004FC84((unsigned char *)v113, *(void **)v114, *(void *)(v114 + 8));
                    }
                    else
                    {
                      long long v115 = *(_OWORD *)v114;
                      *(void *)(v113 + 16) = *(void *)(v114 + 16);
                      *(_OWORD *)unint64_t v113 = v115;
                    }
                    v113 += 24;
                  }
                  *(void *)&v156[8] = v113;
                  uint64_t v116 = v114 + 24;
                  v114 += 64;
                }
                while (v116 != v112);
              }
              xpc_object_t v117 = *(NSObject **)(a1 + 40);
              if (os_log_type_enabled(v117, OS_LOG_TYPE_DEFAULT))
              {
                LOWORD(buf.__r_.__value_.__l.__data_) = 0;
                _os_log_impl((void *)&_mh_execute_header, v117, OS_LOG_TYPE_DEFAULT, "#I fetching transfer plan information from source device", (uint8_t *)&buf, 2u);
              }
              *(unsigned char *)(a1 + 135) = 1;
              memset(&v148, 0, sizeof(v148));
              if (*((void *)&v131 + 1) - (void)v131 != 64) {
                goto LABEL_284;
              }
              bzero(&buf, 0x5F0uLL);
              memset(v162, 0, sizeof(v162));
              if (sub_100B409A4(a1, (uint64_t)&buf, v131, v162, v130)) {
                std::string::operator=(&v148, v176);
              }
              sub_100B615AC((uint64_t)&buf);
              std::string::size_type v118 = HIBYTE(v148.__r_.__value_.__r.__words[2]);
              if ((v148.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
                std::string::size_type v118 = v148.__r_.__value_.__l.__size_;
              }
              if (!v118)
              {
LABEL_284:
                char v119 = (*(uint64_t (**)(void))(**(void **)(a1 + 48) + 32))(*(void *)(a1 + 48));
                sub_100CDA4C8((void *)(a1 + 720), (uint64_t *)(a1 + 624), (uint64_t *)(a1 + 600), 0, v119, *(unsigned __int8 *)(a1 + 129), &buf);
                if (SHIBYTE(v148.__r_.__value_.__r.__words[2]) < 0) {
                  operator delete(v148.__r_.__value_.__l.__data_);
                }
                std::string v148 = buf;
              }
              uint64_t v120 = *(void *)(a1 + 216);
              sub_100058DB0(v171, "kTransferPlanTransferReq");
              sub_100B4094C((uint64_t *)__p, *(_DWORD **)(a1 + 600), *(void *)(a1 + 608));
              sub_100CCCBBC(v156, (uint64_t *)__p, (uint64_t *)&v148, __dst);
              buf.__r_.__value_.__r.__words[0] = a1;
              xpc_object_t v121 = *(std::__shared_weak_count **)(a1 + 16);
              if (!v121 || (v122 = *(void *)(a1 + 8), (xpc_object_t v123 = std::__shared_weak_count::lock(v121)) == 0)) {
                sub_100088B9C();
              }
              buf.__r_.__value_.__l.__size_ = v122;
              buf.__r_.__value_.__r.__words[2] = (std::string::size_type)v123;
              atomic_fetch_add_explicit(&v123->__shared_weak_owners_, 1uLL, memory_order_relaxed);
              sub_10004D2C8(v123);
              sub_1000DFC90((uint64_t)v175, (uint64_t)v146);
              v163[1] = 0;
              xpc_object_t v124 = (char *)operator new(0x40uLL);
              *(void *)xpc_object_t v124 = off_101A3EA70;
              *(std::string *)(v124 + 8) = buf;
              *(_OWORD *)&buf.__r_.__value_.__r.__words[1] = 0uLL;
              sub_100023950((uint64_t)(v124 + 32), (uint64_t)v175);
              v163[1] = v124;
              (*(void (**)(uint64_t, void **, void **, uint64_t, void *, uint8_t *))(*(void *)v120 + 16))(v120, v171, __dst, a1 + 24, &unk_1015465A8, v162);
              sub_100B202F4(v162);
              sub_100060644(v175);
              if (buf.__r_.__value_.__r.__words[2]) {
                std::__shared_weak_count::__release_weak((std::__shared_weak_count *)buf.__r_.__value_.__r.__words[2]);
              }
              sub_100057D78((const void **)__dst);
              if (SHIBYTE(v139) < 0) {
                operator delete(__p[0]);
              }
              if (v172 < 0) {
                operator delete(v171[0]);
              }
              if (SHIBYTE(v148.__r_.__value_.__r.__words[2]) < 0) {
                operator delete(v148.__r_.__value_.__l.__data_);
              }
              v148.__r_.__value_.__r.__words[0] = (std::string::size_type)v156;
              sub_100047F64((void ***)&v148);
            }
            else
            {
              xpc_object_t v125 = *(NSObject **)(a1 + 40);
              if (os_log_type_enabled(v125, OS_LOG_TYPE_ERROR))
              {
                LOWORD(buf.__r_.__value_.__l.__data_) = 0;
                _os_log_error_impl((void *)&_mh_execute_header, v125, OS_LOG_TYPE_ERROR, "No Message Session handler exists", (uint8_t *)&buf, 2u);
              }
LABEL_300:
              sub_1000607A8((uint64_t)v146, v110 != 2);
            }
            sub_100060644(v146);
            buf.__r_.__value_.__r.__words[0] = (std::string::size_type)&v142;
            sub_10030A698((void ***)&buf);
            if (v141) {
              std::__shared_weak_count::__release_weak(v141);
            }
LABEL_303:
            buf.__r_.__value_.__r.__words[0] = (std::string::size_type)&v131;
            sub_10030A698((void ***)&buf);
            return;
          }
LABEL_248:
          sub_1002EB2F8(a5, 1, 0);
          long long v101 = *(std::__shared_weak_count **)(a1 + 72);
          if (v101)
          {
            uint64_t v102 = std::__shared_weak_count::lock(v101);
            if (v102)
            {
              uint64_t v103 = *(void *)(a1 + 64);
              if (v103)
              {
                (*(void (**)(uint64_t))(*(void *)v103 + 80))(v103);
                goto LABEL_255;
              }
            }
          }
          else
          {
            uint64_t v102 = 0;
          }
          xpc_object_t v104 = *(NSObject **)(a1 + 40);
          if (os_log_type_enabled(v104, OS_LOG_TYPE_ERROR))
          {
            LOWORD(buf.__r_.__value_.__l.__data_) = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v104, OS_LOG_TYPE_ERROR, "invalid delegate - allTransferPlansHandled", (uint8_t *)&buf, 2u);
            if (!v102) {
              goto LABEL_303;
            }
          }
          else if (!v102)
          {
            goto LABEL_303;
          }
LABEL_255:
          sub_10004D2C8(v102);
          goto LABEL_303;
        }
      }
      if (!v18[680])
      {
        if ((char)v18[527] < 0)
        {
          if (!*((void *)v18 + 64)) {
            goto LABEL_124;
          }
        }
        else if (!v18[527])
        {
          goto LABEL_124;
        }
        if ((char)v18[479] < 0)
        {
          if (!*((void *)v18 + 58))
          {
LABEL_124:
            long long v51 = *(NSObject **)(a1 + 40);
            if (os_log_type_enabled(v51, OS_LOG_TYPE_ERROR))
            {
              if (*(char *)(v15 + 63) >= 0) {
                uint64_t v73 = v15 + 40;
              }
              else {
                uint64_t v73 = *(void *)(v15 + 40);
              }
              *(_DWORD *)__int16 v162 = 136315138;
              *(void *)&v162[4] = v73;
              _os_log_error_impl((void *)&_mh_execute_header, v51, OS_LOG_TYPE_ERROR, "no transfer sim response for pending plan: %s", v162, 0xCu);
            }
LABEL_125:
            sub_100B615AC((uint64_t)&buf);
LABEL_126:
            if (*((void *)&v131 + 1) >= v132)
            {
              uint64_t v53 = (uint64_t)(*((void *)&v131 + 1) - v131) >> 6;
              if ((unint64_t)(v53 + 1) >> 58) {
                sub_10006A748();
              }
              unint64_t v54 = (uint64_t)(v132 - v131) >> 5;
              if (v54 <= v53 + 1) {
                unint64_t v54 = v53 + 1;
              }
              if (v132 - (unint64_t)v131 >= 0x7FFFFFFFFFFFFFC0) {
                unint64_t v55 = 0x3FFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v55 = v54;
              }
              v175[1] = &v132;
              if (v55) {
                long long v56 = (char *)sub_1001A14BC((uint64_t)&v132, v55);
              }
              else {
                long long v56 = 0;
              }
              buf.__r_.__value_.__r.__words[0] = (std::string::size_type)v56;
              buf.__r_.__value_.__l.__size_ = (std::string::size_type)&v56[64 * v53];
              buf.__r_.__value_.__r.__words[2] = buf.__r_.__value_.__l.__size_;
              v175[0] = &v56[64 * v55];
              sub_10030BB00((char *)buf.__r_.__value_.__l.__size_, (long long *)v15);
              uint64_t v57 = *((void *)&v131 + 1);
              uint64_t v58 = v131;
              std::string::size_type v59 = buf.__r_.__value_.__r.__words[2];
              std::string::size_type v60 = buf.__r_.__value_.__l.__size_;
              if (*((void *)&v131 + 1) == (void)v131)
              {
                int64x2_t v63 = vdupq_n_s64(*((unint64_t *)&v131 + 1));
              }
              else
              {
                do
                {
                  long long v61 = *(_OWORD *)(v57 - 64);
                  *(void *)(v60 - 48) = *(void *)(v57 - 48);
                  *(_OWORD *)(v60 - 64) = v61;
                  *(void *)(v57 - 56) = 0;
                  *(void *)(v57 - 48) = 0;
                  *(void *)(v57 - 64) = 0;
                  *(_OWORD *)(v60 - 40) = *(_OWORD *)(v57 - 40);
                  long long v62 = *(_OWORD *)(v57 - 24);
                  *(void *)(v60 - 8) = *(void *)(v57 - 8);
                  *(_OWORD *)(v60 - 24) = v62;
                  v60 -= 64;
                  *(void *)(v57 - 16) = 0;
                  *(void *)(v57 - 8) = 0;
                  *(void *)(v57 - 24) = 0;
                  v57 -= 64;
                }
                while (v57 != v58);
                int64x2_t v63 = (int64x2_t)v131;
              }
              uint64_t v52 = v59 + 64;
              *(void *)&long long v131 = v60;
              *((void *)&v131 + 1) = v59 + 64;
              *(int64x2_t *)&buf.__r_.__value_.__r.__words[1] = v63;
              unint64_t v64 = v132;
              unint64_t v132 = v175[0];
              v175[0] = v64;
              buf.__r_.__value_.__r.__words[0] = v63.i64[0];
              sub_1005409BC((uint64_t)&buf);
            }
            else
            {
              sub_10030BB00(*((char **)&v131 + 1), (long long *)v15);
              uint64_t v52 = *((void *)&v131 + 1) + 64;
            }
            *((void *)&v131 + 1) = v52;
            goto LABEL_195;
          }
        }
        else if (!v18[479])
        {
          goto LABEL_124;
        }
        long long v49 = v18 + 504;
        uint64_t v170 = 0;
        long long v168 = 0u;
        *(_OWORD *)int v169 = 0u;
        memset(v167, 0, sizeof(v167));
        *(_OWORD *)unsigned int v165 = 0u;
        long long v166 = 0u;
        *(_OWORD *)int v163 = 0u;
        long long v164 = 0u;
        *(_OWORD *)__int16 v162 = 0u;
        sub_100093B44((std::string *)&v167[1], (const std::string *)v18 + 21);
        uint64_t v50 = v18 + 456;
        long long v160 = 0u;
        long long v161 = 0u;
        long long v158 = 0u;
        *(_OWORD *)int v159 = 0u;
        *(_OWORD *)__int16 v156 = 0u;
        *(_OWORD *)int v157 = 0u;
        if ((char)v18[479] < 0)
        {
          sub_10004FC84(v134, *((void **)v18 + 57), *((void *)v18 + 58));
        }
        else
        {
          *(_OWORD *)int64_t v134 = *v50;
          uint64_t v135 = *((void *)v18 + 59);
        }
        sub_100B620D8(v156, (long long *)v134);
        if (SHIBYTE(v135) < 0) {
          operator delete(v134[0]);
        }
        WORD4(v161) = 257;
        if (SHIBYTE(v157[0]) < 0)
        {
          sub_10004FC84(&v148, *(void **)v156, *(unint64_t *)&v156[8]);
        }
        else
        {
          *(_OWORD *)&v148.__r_.__value_.__l.__data_ = *(_OWORD *)v156;
          v148.__r_.__value_.__r.__words[2] = (std::string::size_type)v157[0];
        }
        sub_1000593FC((uint64_t)v149, (long long *)&v157[1]);
        sub_1000593FC((uint64_t)v152, (long long *)&v159[1]);
        __int16 v155 = WORD4(v161);
        sub_100B6213C((char **)v162, &v148, (std::string *)v156);
        if (v154 && v153 < 0) {
          operator delete(v152[0]);
        }
        if (v151 && v150 < 0) {
          operator delete(v149[0]);
        }
        if (SHIBYTE(v148.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v148.__r_.__value_.__l.__data_);
        }
        long long v65 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v65, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v66 = sub_1008A2228(v18[1]);
          if ((char)v18[527] < 0) {
            long long v49 = (void *)*v49;
          }
          if ((char)v18[479] < 0) {
            uint64_t v50 = *(_OWORD **)v50;
          }
          LODWORD(v148.__r_.__value_.__l.__data_) = 136315650;
          *(std::string::size_type *)((char *)v148.__r_.__value_.__r.__words + 4) = (std::string::size_type)v66;
          WORD2(v148.__r_.__value_.__r.__words[1]) = 2080;
          *(std::string::size_type *)((char *)&v148.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v49;
          HIWORD(v148.__r_.__value_.__r.__words[2]) = 2080;
          v149[0] = v50;
          _os_log_impl((void *)&_mh_execute_header, v65, OS_LOG_TYPE_DEFAULT, "#I trigger install pending plan. state:%s, altSmdp:%s, target iccid:%s", (uint8_t *)&v148, 0x20u);
        }
        uint64_t v67 = *(std::__shared_weak_count **)(a1 + 72);
        if (v67)
        {
          long long v68 = std::__shared_weak_count::lock(v67);
          if (v68)
          {
            uint64_t v69 = v68;
            uint64_t v70 = *(void *)(a1 + 64);
            if (v70)
            {
              (*(void (**)(uint64_t, uint64_t, uint8_t *, uint64_t))(*(void *)v70 + 40))(v70, v15 + 40, v162, 16);
              unsigned int v71 = *v18 - 1;
              if (v71 > 0xA) {
                std::string::value_type v72 = 0;
              }
              else {
                std::string::value_type v72 = byte_10154B635[(char)v71];
              }
              v148.__r_.__value_.__s.__data_[0] = v72;
              unsigned __int8 v133 = 7;
              sub_100B4B75C(a1, &v148, &v133, (uint64_t)&buf, 1, 0);
            }
            sub_10004D2C8(v69);
          }
        }
        if ((_BYTE)v161 && SHIBYTE(v160) < 0) {
          operator delete(v159[1]);
        }
        if (LOBYTE(v159[0]) && SHIBYTE(v158) < 0) {
          operator delete(v157[1]);
        }
        if (SHIBYTE(v157[0]) < 0) {
          operator delete(*(void **)v156);
        }
        goto LABEL_182;
      }
      uint64_t v31 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v32 = sub_1008A2228(v30);
        *(_DWORD *)__int16 v162 = 136315138;
        *(void *)&v162[4] = v32;
        _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "#I trigger install pending plan. state:%s", v162, 0xCu);
      }
      uint64_t v170 = 0;
      long long v168 = 0u;
      *(_OWORD *)int v169 = 0u;
      memset(v167, 0, sizeof(v167));
      *(_OWORD *)unsigned int v165 = 0u;
      long long v166 = 0u;
      *(_OWORD *)int v163 = 0u;
      long long v164 = 0u;
      *(_OWORD *)__int16 v162 = 0u;
      sub_10030DBE4((uint64_t)v162, (uint64_t)(v18 + 528));
      if ((char)v18[527] < 0)
      {
        if (!*((void *)v18 + 64)) {
          goto LABEL_74;
        }
      }
      else if (!v18[527])
      {
        goto LABEL_74;
      }
      uint64_t v37 = v18 + 504;
      sub_100093B44((std::string *)&v167[1], (const std::string *)v18 + 21);
      uint64_t v38 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT))
      {
        if ((char)v18[527] < 0) {
          uint64_t v37 = (void *)*v37;
        }
        *(_DWORD *)__int16 v156 = 136315138;
        *(void *)&v156[4] = v37;
        _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_DEFAULT, "#I trigger install pending plan. altSmdp:%s", v156, 0xCu);
      }
LABEL_74:
      if (!(_BYTE)v168) {
        goto LABEL_78;
      }
      uint64_t v39 = (void *)HIBYTE(v167[3]);
      if (SHIBYTE(v167[3]) < 0) {
        uint64_t v39 = v167[2];
      }
      if (!v39)
      {
LABEL_78:
        sub_100B4AC10(a1, v156);
        if ((_BYTE)v168)
        {
          if (SHIBYTE(v167[3]) < 0) {
            operator delete(v167[1]);
          }
          *(_OWORD *)&v167[1] = *(_OWORD *)v156;
          v167[3] = v157[0];
        }
        else
        {
          *(_OWORD *)&v167[1] = *(_OWORD *)v156;
          v167[3] = v157[0];
          LOBYTE(v168) = 1;
        }
      }
      long long v40 = (void **)(v18 + 456);
      if ((char)v18[479] < 0)
      {
        unint64_t v41 = *((void *)v18 + 58);
        if (v41)
        {
          long long v160 = 0u;
          long long v161 = 0u;
          long long v158 = 0u;
          *(_OWORD *)int v159 = 0u;
          *(_OWORD *)__int16 v156 = 0u;
          *(_OWORD *)int v157 = 0u;
          sub_10004FC84(__dst, *v40, v41);
          goto LABEL_88;
        }
      }
      else if (v18[479])
      {
        long long v160 = 0u;
        long long v161 = 0u;
        long long v158 = 0u;
        *(_OWORD *)int v159 = 0u;
        *(_OWORD *)__int16 v156 = 0u;
        *(_OWORD *)int v157 = 0u;
        *(_OWORD *)long long __dst = *(_OWORD *)v40;
        uint64_t v137 = *((void *)v18 + 59);
LABEL_88:
        sub_100B620D8(v156, (long long *)__dst);
        if (SHIBYTE(v137) < 0) {
          operator delete(__dst[0]);
        }
        WORD4(v161) = 257;
        if (SHIBYTE(v157[0]) < 0)
        {
          sub_10004FC84(&v148, *(void **)v156, *(unint64_t *)&v156[8]);
        }
        else
        {
          *(_OWORD *)&v148.__r_.__value_.__l.__data_ = *(_OWORD *)v156;
          v148.__r_.__value_.__r.__words[2] = (std::string::size_type)v157[0];
        }
        sub_1000593FC((uint64_t)v149, (long long *)&v157[1]);
        sub_1000593FC((uint64_t)v152, (long long *)&v159[1]);
        __int16 v155 = WORD4(v161);
        sub_100B6213C((char **)v162, &v148, (std::string *)v156);
        if (v154 && v153 < 0) {
          operator delete(v152[0]);
        }
        if (v151 && v150 < 0) {
          operator delete(v149[0]);
        }
        if (SHIBYTE(v148.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v148.__r_.__value_.__l.__data_);
        }
        long long v42 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v42, OS_LOG_TYPE_DEFAULT))
        {
          if ((char)v18[479] < 0) {
            long long v40 = (void **)*v40;
          }
          LODWORD(v148.__r_.__value_.__l.__data_) = 136315138;
          *(std::string::size_type *)((char *)v148.__r_.__value_.__r.__words + 4) = (std::string::size_type)v40;
          _os_log_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_DEFAULT, "#I trigger install pending plan. target iccid:%s", (uint8_t *)&v148, 0xCu);
        }
        if ((_BYTE)v161 && SHIBYTE(v160) < 0) {
          operator delete(v159[1]);
        }
        if (LOBYTE(v159[0]) && SHIBYTE(v158) < 0) {
          operator delete(v157[1]);
        }
        if (SHIBYTE(v157[0]) < 0) {
          operator delete(*(void **)v156);
        }
      }
      long long v43 = *(std::__shared_weak_count **)(a1 + 72);
      if (v43)
      {
        long long v44 = std::__shared_weak_count::lock(v43);
        if (v44)
        {
          long long v45 = v44;
          uint64_t v46 = *(void *)(a1 + 64);
          if (v46)
          {
            (*(void (**)(uint64_t, uint64_t, uint8_t *, uint64_t))(*(void *)v46 + 40))(v46, v15 + 40, v162, 16);
            unsigned int v47 = *v18 - 1;
            if (v47 > 0xA) {
              uint8_t v48 = 0;
            }
            else {
              uint8_t v48 = byte_10154B635[(char)v47];
            }
            v156[0] = v48;
            sub_100B4B75C(a1, v156, v18 + 1, (uint64_t)&buf, 1, 0);
          }
          sub_10004D2C8(v45);
        }
      }
LABEL_182:
      if (SHIBYTE(v170) < 0) {
        operator delete(v169[0]);
      }
      if ((_BYTE)v168 && SHIBYTE(v167[3]) < 0) {
        operator delete(v167[1]);
      }
      if (LOBYTE(v167[0]) && SHIBYTE(v166) < 0) {
        operator delete(v165[1]);
      }
      if (LOBYTE(v165[0]) && SHIBYTE(v164) < 0) {
        operator delete(v163[1]);
      }
      *(void *)__int16 v156 = v162;
      sub_1001A010C((void ***)v156);
      goto LABEL_194;
    }
LABEL_11:
    char v126 = a4;
    uint64_t v15 = *a2;
    uint64_t v14 = a2[1];
    if ((unint64_t)(v14 - *v127) >= 0x41)
    {
      uint64_t v16 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
      {
        LOWORD(buf.__r_.__value_.__l.__data_) = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "Post buddy only one plan can be transfered", (uint8_t *)&buf, 2u);
      }
      sub_1002EB2F8(a5, 0, 6);
      return;
    }
    goto LABEL_19;
  }
  char v17 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
  {
    LOWORD(buf.__r_.__value_.__l.__data_) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "No ongoing transfer seession exists", (uint8_t *)&buf, 2u);
  }
  sub_1002EB2F8(a5, 0, 56);
}

void sub_100B457FC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27,uint64_t a28,uint64_t a29,uint64_t a30,void *a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,void *a39,uint64_t a40,uint64_t a41,uint64_t a42,char a43,uint64_t a44,std::__shared_weak_count *a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,void *__p,uint64_t a58,int a59,__int16 a60,char a61,char a62,void *a63)
{
  sub_100B615AC((uint64_t)&STACK[0x300]);
  if (a62 < 0) {
    operator delete(__p);
  }
  std::string __p = &a72;
  sub_100047F64((void ***)&__p);
  sub_100060644(&a53);
  sub_100B45AEC((uint64_t)&a43);
  a72 = (uint64_t)&a27;
  sub_10030A698((void ***)&a72);
  _Unwind_Resume(a1);
}

void sub_100B45AA0(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 56))
  {
    sub_100057D78((const void **)(a1 + 40));
    sub_1000558F4((const void **)(a1 + 32));
    if (*(char *)(a1 + 31) < 0) {
      operator delete(*(void **)(a1 + 8));
    }
    *(unsigned char *)(a1 + 56) = 0;
  }
}

uint64_t sub_100B45AEC(uint64_t a1)
{
  uint64_t v4 = (void **)(a1 + 24);
  sub_10030A698(&v4);
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

uint64_t sub_100B45B34(void *a1, uint64_t a2)
{
  uint64_t v2 = a1[39];
  uint64_t v3 = a1[41];
  if (v3 == v2 || a1[38] == v2) {
    return 1;
  }
  v6[0] = off_101A3EE70;
  void v6[3] = v6;
  uint64_t v4 = sub_100B45BFC(a1, a2, v3 + 1048, (uint64_t)v6);
  sub_100313668(v6);
  return v4;
}

void sub_100B45BE8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100313668((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100B45BFC(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v7 = a1[5];
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Cancelling ongoing transfer", buf, 2u);
  }
  uint64_t v8 = (std::__shared_weak_count *)a1[9];
  if (!v8)
  {
    uint64_t v9 = 0;
    goto LABEL_14;
  }
  uint64_t v9 = std::__shared_weak_count::lock(v8);
  if (!v9 || (uint64_t v10 = a1[8]) == 0)
  {
LABEL_14:
    sub_10024924C(a4, 56);
    uint64_t v17 = 0;
    if (!v9) {
      return v17;
    }
    goto LABEL_33;
  }
  uint64_t v11 = a1[39];
  uint64_t v12 = sub_100B45F5C(a1[38], v11, (unsigned __int8 **)a3);
  if (v11 == v12)
  {
    uint64_t v14 = a1[5];
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      if (*(char *)(a3 + 23) >= 0) {
        long long v24 = (unsigned __int8 *)a3;
      }
      else {
        long long v24 = *(unsigned __int8 **)a3;
      }
      *(_DWORD *)std::string buf = 136315138;
      uint64_t v31 = v24;
      uint64_t v16 = "cancel not ongoing transfered plan: %s";
      goto LABEL_39;
    }
LABEL_17:
    char v18 = 56;
    goto LABEL_18;
  }
  uint64_t v13 = v12;
  if (a1[41] != v12)
  {
    uint64_t v14 = a1[5];
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      if (*(char *)(a3 + 23) >= 0) {
        uint64_t v15 = (unsigned __int8 *)a3;
      }
      else {
        uint64_t v15 = *(unsigned __int8 **)a3;
      }
      *(_DWORD *)std::string buf = 136315138;
      uint64_t v31 = v15;
      uint64_t v16 = "cannot cancel not ongoing transfer plan : %s";
LABEL_39:
      _os_log_error_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, v16, buf, 0xCu);
      goto LABEL_17;
    }
    goto LABEL_17;
  }
  if (*(unsigned char *)(v12 + 1460) || *(unsigned char *)(v12 + 1461) || *(unsigned char *)(v12 + 1462))
  {
    uint64_t v19 = *(void *)(v12 + 1032);
    uint64_t v20 = *(void *)(v12 + 1040);
    if (*(char *)(a3 + 23) < 0)
    {
      sub_10004FC84(__dst, *(void **)a3, *(void *)(a3 + 8));
    }
    else
    {
      *(_OWORD *)long long __dst = *(_OWORD *)a3;
      uint64_t v29 = *(void *)(a3 + 16);
    }
    uint64_t v21 = *(void *)(v13 + 1168);
    uint64_t v22 = *(void *)(v13 + 1176);
    if (*(char *)(v13 + 1279) < 0)
    {
      sub_10004FC84(__p, *(void **)(v13 + 1256), *(void *)(v13 + 1264));
    }
    else
    {
      *(_OWORD *)std::string __p = *(_OWORD *)(v13 + 1256);
      uint64_t v27 = *(void *)(v13 + 1272);
    }
    (*(void (**)(uint64_t, uint64_t, uint64_t, void **, uint64_t, uint64_t, void **, uint64_t))(*(void *)v10 + 24))(v10, v19, v20, __dst, v21, v22, __p, 3);
    if (SHIBYTE(v27) < 0) {
      operator delete(__p[0]);
    }
    if (SHIBYTE(v29) < 0) {
      operator delete(__dst[0]);
    }
    sub_10024924C(a4, 0);
    uint64_t v17 = 1;
    goto LABEL_33;
  }
  int v25 = a1[5];
  if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_ERROR, "already receive transfer auth from source, cannot cancel", buf, 2u);
  }
  char v18 = 5;
LABEL_18:
  sub_10024924C(a4, v18);
  uint64_t v17 = 0;
LABEL_33:
  sub_10004D2C8(v9);
  return v17;
}

void sub_100B45F0C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  sub_10004D2C8(v21);
  _Unwind_Resume(a1);
}

uint64_t sub_100B45F5C(uint64_t a1, uint64_t a2, unsigned __int8 **a3)
{
  uint64_t v3 = a1;
  if (a1 != a2)
  {
    char v5 = *((unsigned char *)a3 + 23);
    if (v5 >= 0) {
      char v6 = (unsigned __int8 *)*((unsigned __int8 *)a3 + 23);
    }
    else {
      char v6 = a3[1];
    }
    if (v5 >= 0) {
      unint64_t v7 = (unsigned __int8 *)a3;
    }
    else {
      unint64_t v7 = *a3;
    }
    do
    {
      uint64_t v8 = *(unsigned __int8 *)(v3 + 1071);
      if ((v8 & 0x80u) == 0) {
        uint64_t v9 = (unsigned __int8 *)*(unsigned __int8 *)(v3 + 1071);
      }
      else {
        uint64_t v9 = *(unsigned __int8 **)(v3 + 1056);
      }
      if (v9 == v6)
      {
        if ((v8 & 0x80) != 0)
        {
          if (!memcmp(*(const void **)(v3 + 1048), v7, *(void *)(v3 + 1056))) {
            return v3;
          }
        }
        else
        {
          if (!*(unsigned char *)(v3 + 1071)) {
            return v3;
          }
          uint64_t v10 = 0;
          while (*(unsigned __int8 *)(v3 + v10 + 1048) == v7[v10])
          {
            if (v8 == ++v10) {
              return v3;
            }
          }
        }
      }
      v3 += 1520;
    }
    while (v3 != a2);
    return a2;
  }
  return v3;
}

void sub_100B46018(std::string::size_type a1, uint64_t a2)
{
  if (*(unsigned char *)(a2 + 24) == 1)
  {
    if (*(char *)(a2 + 23) < 0) {
      sub_10004FC84(&__dst, *(void **)a2, *(void *)(a2 + 8));
    }
    else {
      std::string __dst = *(std::string *)a2;
    }
    std::string::size_type size = HIBYTE(__dst.__r_.__value_.__r.__words[2]);
    if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      std::string::size_type size = __dst.__r_.__value_.__l.__size_;
    }
    if (size < 0x15)
    {
      BOOL v21 = 0;
      if ((*((unsigned char *)&__dst.__r_.__value_.__s + 23) & 0x80) != 0)
      {
LABEL_51:
        operator delete(__dst.__r_.__value_.__l.__data_);
        if (!v21) {
          return;
        }
        goto LABEL_55;
      }
LABEL_54:
      if (!v21) {
        return;
      }
LABEL_55:
      uint64_t v22 = *(void *)(a1 + 312);
      if (*(void *)(a1 + 304) == v22 || (uint64_t v23 = *(void *)(a1 + 328), v23 == v22))
      {
        long long v45 = *(NSObject **)(a1 + 40);
        if (!os_log_type_enabled(v45, OS_LOG_TYPE_ERROR)) {
          return;
        }
        LOWORD(v176[0].__r_.__value_.__l.__data_) = 0;
        uint64_t v46 = "No elements in the map";
        goto LABEL_126;
      }
      long long v24 = (unsigned __int8 **)(v23 + 1048);
      memset(&v175, 0, sizeof(v175));
      sub_100B49750((uint64_t)&v175, v23 + 1048);
      int v25 = *(char *)(a2 + 23);
      if (v25 >= 0) {
        uint64_t v26 = *(unsigned __int8 *)(a2 + 23);
      }
      else {
        uint64_t v26 = *(void *)(a2 + 8);
      }
      unint64_t v27 = *(unsigned __int8 *)(v23 + 1071);
      int v28 = (char)v27;
      if ((v27 & 0x80u) != 0) {
        unint64_t v27 = *(void *)(v23 + 1056);
      }
      if (v26 == v27 + 21)
      {
        if (!v27) {
          goto LABEL_367;
        }
        uint64_t v29 = v25 >= 0 ? a2 : *(void *)a2;
        int v30 = v28 >= 0 ? (unsigned __int8 *)(v23 + 1048) : *v24;
        if (*(unsigned __int8 *)(v29 + 21) == *v30)
        {
          uint64_t v31 = 0;
          uint64_t v32 = v29 + 22;
          long long v33 = v30 + 1;
          do
          {
            uint64_t v34 = v31;
            if (v27 - 1 == v31) {
              break;
            }
            int v35 = *(unsigned __int8 *)(v32 + v31);
            int v36 = v33[v31++];
          }
          while (v35 == v36);
          if (v34 + 1 >= v27)
          {
LABEL_367:
            if (*(unsigned char *)(a1 + 360))
            {
              uint64_t v37 = *(NSObject **)(a1 + 40);
              if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT)
                && (LOWORD(v176[0].__r_.__value_.__l.__data_) = 0,
                    _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEFAULT, "#I Triggering preflight entitlements", (uint8_t *)v176, 2u), !*(unsigned char *)(a1 + 360)))
              {
                uint64_t v82 = *(NSObject **)(a1 + 40);
                if (os_log_type_enabled(v82, OS_LOG_TYPE_DEFAULT))
                {
                  LOWORD(buf.__r_.__value_.__l.__data_) = 0;
                  _os_log_impl((void *)&_mh_execute_header, v82, OS_LOG_TYPE_DEFAULT, "#I No Preflight Iccid", (uint8_t *)&buf, 2u);
                }
              }
              else
              {
                uint64_t v38 = *(void *)(a1 + 328);
                if (v38 != *(void *)(a1 + 312))
                {
                  uint64_t v39 = *(std::__shared_weak_count **)(a1 + 16);
                  if (!v39 || (uint64_t v40 = *(void *)(a1 + 8), (v41 = std::__shared_weak_count::lock(v39)) == 0)) {
                    sub_100088B9C();
                  }
                  long long v42 = v41;
                  atomic_fetch_add_explicit(&v41->__shared_weak_owners_, 1uLL, memory_order_relaxed);
                  sub_10004D2C8(v41);
                  long long v43 = operator new(0x28uLL);
                  *long long v43 = off_101A3F8B0;
                  v43[1] = a1;
                  v43[2] = v40;
                  void v43[3] = v42;
                  void v43[4] = a1;
                  v176[1].__r_.__value_.__r.__words[0] = (std::string::size_type)v43;
                  LOBYTE(v42) = sub_100B49984(a1, v38 + 1048, (uint64_t)v176);
                  sub_100060644(v176);
                  if (v42) {
                    goto LABEL_149;
                  }
                  buf.__r_.__value_.__r.__words[0] = a1 + 336;
                  long long v44 = sub_100B6C578((uint64_t **)(a1 + 992), (void **)(a1 + 336), (long long **)&buf);
                  *((_DWORD *)v44 + 21) = 70023;
                  v44[88] = 1;
                }
              }
              sub_100B47BD0(a1);
              sub_100B47C9C(a1);
            }
            else
            {
              uint64_t v76 = *(unsigned char **)(a1 + 328);
              if (v76[216] && v76[624] && v76[888])
              {
                v176[0].__r_.__value_.__r.__words[0] = a1;
                uint64_t v77 = *(std::__shared_weak_count **)(a1 + 16);
                if (!v77 || (std::string::size_type v78 = *(void *)(a1 + 8), (v79 = std::__shared_weak_count::lock(v77)) == 0)) {
                  sub_100088B9C();
                }
                v176[0].__r_.__value_.__l.__size_ = v78;
                v176[0].__r_.__value_.__r.__words[2] = (std::string::size_type)v79;
                atomic_fetch_add_explicit(&v79->__shared_weak_owners_, 1uLL, memory_order_relaxed);
                sub_10004D2C8(v79);
                if (*(char *)(v23 + 1071) < 0)
                {
                  sub_10004FC84(&v176[1], *(void **)(v23 + 1048), *(void *)(v23 + 1056));
                }
                else
                {
                  *(_OWORD *)&v176[1].__r_.__value_.__l.__data_ = *(_OWORD *)v24;
                  v176[1].__r_.__value_.__r.__words[2] = *(void *)(v23 + 1064);
                }
                __int16 v174 = 0;
                uint64_t v103 = (char *)operator new(0x38uLL);
                *(void *)uint64_t v103 = off_101A3EFF0;
                *(std::string *)(v103 + 8) = v176[0];
                *(_OWORD *)&v176[0].__r_.__value_.__r.__words[1] = 0uLL;
                xpc_object_t v104 = v103 + 32;
                if (SHIBYTE(v176[1].__r_.__value_.__r.__words[2]) < 0)
                {
                  sub_10004FC84(v104, v176[1].__r_.__value_.__l.__data_, v176[1].__r_.__value_.__l.__size_);
                }
                else
                {
                  *(_OWORD *)xpc_object_t v104 = *(_OWORD *)&v176[1].__r_.__value_.__l.__data_;
                  *((void *)v103 + 6) = *((void *)&v176[1].__r_.__value_.__l + 2);
                }
                __int16 v174 = v103;
                char v105 = sub_100B49984(a1, (uint64_t)v24, (uint64_t)&buf);
                sub_100060644(&buf);
                if (SHIBYTE(v176[1].__r_.__value_.__r.__words[2]) < 0) {
                  operator delete(v176[1].__r_.__value_.__l.__data_);
                }
                if (v176[0].__r_.__value_.__r.__words[2]) {
                  std::__shared_weak_count::__release_weak((std::__shared_weak_count *)v176[0].__r_.__value_.__r.__words[2]);
                }
                if (v105) {
                  goto LABEL_149;
                }
                v161.__r_.__value_.__s.__data_[0] = 11;
                sub_100B49888((CFStringRef *)&__str, a1);
                LOBYTE(__p[0]) = 56;
                v167.__r_.__value_.__r.__words[0] = 0;
                LODWORD(v162[0]) = 70023;
                BYTE4(v162[0]) = 1;
                sub_100B3E598((void *)a1, v24, (unsigned __int8 *)&v161, 0, (const void **)&__str.__r_.__value_.__l.__data_, (char *)__p, (const void **)&v167.__r_.__value_.__l.__data_, 0, 1, (uint64_t)v162, (uint64_t *)(a1 + 328));
                sub_100057D78((const void **)&v167.__r_.__value_.__l.__data_);
                p_str = &__str;
              }
              else
              {
                uint64_t v80 = *(NSObject **)(a1 + 40);
                if (os_log_type_enabled(v80, OS_LOG_TYPE_ERROR))
                {
                  LOWORD(v176[0].__r_.__value_.__l.__data_) = 0;
                  _os_log_error_impl((void *)&_mh_execute_header, v80, OS_LOG_TYPE_ERROR, "Data to perform transfer unavailable", (uint8_t *)v176, 2u);
                }
                v167.__r_.__value_.__s.__data_[0] = 11;
                sub_100B49888((CFStringRef *)v176, a1);
                LOBYTE(v162[0]) = 56;
                buf.__r_.__value_.__r.__words[0] = 0;
                LODWORD(__str.__r_.__value_.__l.__data_) = 70018;
                __str.__r_.__value_.__s.__data_[4] = 1;
                sub_100B3E598((void *)a1, (unsigned __int8 **)(v23 + 1048), (unsigned __int8 *)&v167, 0, (const void **)&v176[0].__r_.__value_.__l.__data_, (char *)v162, (const void **)&buf.__r_.__value_.__l.__data_, 0, 1, (uint64_t)&__str, (uint64_t *)(a1 + 328));
                sub_100057D78((const void **)&buf.__r_.__value_.__l.__data_);
                p_str = v176;
              }
              sub_1000558F4((const void **)&p_str->__r_.__value_.__l.__data_);
            }
          }
        }
      }
LABEL_149:
      if (SHIBYTE(v175.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v175.__r_.__value_.__l.__data_);
      }
      return;
    }
    std::string::basic_string(v176, &__dst, 0, 0x14uLL, (std::allocator<char> *)&buf);
    std::string::size_type v14 = HIBYTE(v176[0].__r_.__value_.__r.__words[2]);
    if ((v176[0].__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      std::string::size_type v14 = v176[0].__r_.__value_.__l.__size_;
    }
    if (v14 == 20)
    {
      uint64_t v15 = (std::string *)v176[0].__r_.__value_.__r.__words[0];
      if ((v176[0].__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        uint64_t v15 = v176;
      }
      std::string::size_type v16 = v15->__r_.__value_.__r.__words[0];
      std::string::size_type v17 = v15->__r_.__value_.__l.__size_;
      int v18 = v15->__r_.__value_.__r.__words[2];
      BOOL v21 = v16 == 0x72616C756C6C6543 && v17 == 0x6E6172546E616C50 && v18 == 1919247987;
      if (SHIBYTE(v176[0].__r_.__value_.__r.__words[2]) < 0) {
        goto LABEL_49;
      }
    }
    else
    {
      BOOL v21 = 0;
      if (SHIBYTE(v176[0].__r_.__value_.__r.__words[2]) < 0) {
LABEL_49:
      }
        operator delete(v176[0].__r_.__value_.__l.__data_);
    }
    if ((*((unsigned char *)&__dst.__r_.__value_.__s + 23) & 0x80) != 0) {
      goto LABEL_51;
    }
    goto LABEL_54;
  }
  if (*(unsigned char *)(a2 + 24)) {
    return;
  }
  if (*(char *)(a2 + 23) < 0) {
    sub_10004FC84(&__str, *(void **)a2, *(void *)(a2 + 8));
  }
  else {
    std::string __str = *(std::string *)a2;
  }
  std::string::size_type v4 = HIBYTE(__str.__r_.__value_.__r.__words[2]);
  if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
    std::string::size_type v4 = __str.__r_.__value_.__l.__size_;
  }
  if (v4 < 0x15)
  {
    BOOL v12 = 0;
    if ((*((unsigned char *)&__str.__r_.__value_.__s + 23) & 0x80) != 0) {
      goto LABEL_88;
    }
LABEL_28:
    if (!v12) {
      return;
    }
    goto LABEL_89;
  }
  std::string::basic_string(v176, &__str, 0, 0x14uLL, (std::allocator<char> *)&buf);
  std::string::size_type v5 = HIBYTE(v176[0].__r_.__value_.__r.__words[2]);
  if ((v176[0].__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
    std::string::size_type v5 = v176[0].__r_.__value_.__l.__size_;
  }
  if (v5 != 20)
  {
    BOOL v12 = 0;
    if ((SHIBYTE(v176[0].__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_87;
    }
    goto LABEL_86;
  }
  char v6 = (std::string *)v176[0].__r_.__value_.__r.__words[0];
  if ((v176[0].__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    char v6 = v176;
  }
  std::string::size_type v7 = v6->__r_.__value_.__r.__words[0];
  std::string::size_type v8 = v6->__r_.__value_.__l.__size_;
  int v9 = v6->__r_.__value_.__r.__words[2];
  BOOL v12 = v7 == 0x72616C756C6C6543 && v8 == 0x6E6172546E616C50 && v9 == 1919247987;
  if (SHIBYTE(v176[0].__r_.__value_.__r.__words[2]) < 0) {
LABEL_86:
  }
    operator delete(v176[0].__r_.__value_.__l.__data_);
LABEL_87:
  if ((*((unsigned char *)&__str.__r_.__value_.__s + 23) & 0x80) == 0) {
    goto LABEL_28;
  }
LABEL_88:
  operator delete(__str.__r_.__value_.__l.__data_);
  if (!v12) {
    return;
  }
LABEL_89:
  uint64_t v47 = *(void *)(a1 + 312);
  if (*(void *)(a1 + 304) == v47 || (uint64_t v48 = *(void *)(a1 + 328), v48 == v47))
  {
    long long v45 = *(NSObject **)(a1 + 40);
    if (!os_log_type_enabled(v45, OS_LOG_TYPE_ERROR)) {
      return;
    }
    LOWORD(v176[0].__r_.__value_.__l.__data_) = 0;
    uint64_t v46 = "No elements in the map";
LABEL_126:
    _os_log_error_impl((void *)&_mh_execute_header, v45, OS_LOG_TYPE_ERROR, v46, (uint8_t *)v176, 2u);
    return;
  }
  int v49 = *(char *)(a2 + 23);
  if (v49 >= 0) {
    uint64_t v50 = *(unsigned __int8 *)(a2 + 23);
  }
  else {
    uint64_t v50 = *(void *)(a2 + 8);
  }
  unint64_t v51 = *(unsigned __int8 *)(v48 + 1071);
  int v52 = (char)v51;
  if ((v51 & 0x80u) != 0) {
    unint64_t v51 = *(void *)(v48 + 1056);
  }
  if (v50 == v51 + 21)
  {
    if (!v51) {
      goto LABEL_368;
    }
    uint64_t v53 = v49 >= 0 ? a2 : *(void *)a2;
    unint64_t v54 = v52 >= 0 ? (unsigned __int8 *)(v48 + 1048) : *(unsigned __int8 **)(v48 + 1048);
    if (*(unsigned __int8 *)(v53 + 21) == *v54)
    {
      uint64_t v55 = 0;
      uint64_t v56 = v53 + 22;
      uint64_t v57 = v54 + 1;
      do
      {
        uint64_t v58 = v55;
        if (v51 - 1 == v55) {
          break;
        }
        int v59 = *(unsigned __int8 *)(v56 + v55);
        int v60 = v57[v55++];
      }
      while (v59 == v60);
      if (v58 + 1 >= v51)
      {
LABEL_368:
        if (*(unsigned char *)(v48 + 216) && *(unsigned char *)(v48 + 624) && *(unsigned char *)(v48 + 888))
        {
          CFDictionaryRef theDict = 0;
          sub_100B48258((const void **)&theDict, a1, v48);
          if (theDict) {
            long long v61 = sub_100080778;
          }
          else {
            long long v61 = 0;
          }
          long long v62 = *(NSObject **)(a1 + 40);
          if (!v61)
          {
            if (os_log_type_enabled(*(os_log_t *)(a1 + 40), OS_LOG_TYPE_ERROR))
            {
              LOWORD(v176[0].__r_.__value_.__l.__data_) = 0;
              _os_log_error_impl((void *)&_mh_execute_header, v62, OS_LOG_TYPE_ERROR, "No Entitlement settings", (uint8_t *)v176, 2u);
            }
            v175.__r_.__value_.__s.__data_[0] = 11;
            v176[0].__r_.__value_.__r.__words[0] = 0;
            v167.__r_.__value_.__s.__data_[0] = 56;
            buf.__r_.__value_.__r.__words[0] = 0;
            LODWORD(__dst.__r_.__value_.__l.__data_) = 70015;
            __dst.__r_.__value_.__s.__data_[4] = 1;
            sub_100B3E598((void *)a1, (unsigned __int8 **)(v48 + 1048), (unsigned __int8 *)&v175, 0, (const void **)&v176[0].__r_.__value_.__l.__data_, (char *)&v167, (const void **)&buf.__r_.__value_.__l.__data_, 0, 1, (uint64_t)&__dst, (uint64_t *)(a1 + 328));
            sub_100057D78((const void **)&buf.__r_.__value_.__l.__data_);
            sub_1000558F4((const void **)&v176[0].__r_.__value_.__l.__data_);
            if (*(unsigned char *)(a1 + 360))
            {
              if (!*(unsigned char *)(a1 + 1020))
              {
                *(_DWORD *)(a1 + 1016) = 1;
                *(unsigned char *)(a1 + 1020) = 1;
              }
              v176[0].__r_.__value_.__r.__words[0] = a1 + 336;
              int v83 = sub_100B6C578((uint64_t **)(a1 + 992), (void **)(a1 + 336), (long long **)v176);
              *((_DWORD *)v83 + 21) = 70015;
              v83[88] = 1;
              sub_100B47BD0(a1);
              sub_100B47C9C(a1);
            }
            goto LABEL_217;
          }
          if (os_log_type_enabled(*(os_log_t *)(a1 + 40), OS_LOG_TYPE_DEFAULT))
          {
            LODWORD(v176[0].__r_.__value_.__l.__data_) = 136315394;
            *(std::string::size_type *)((char *)v176[0].__r_.__value_.__r.__words + 4) = (std::string::size_type)"";
            WORD2(v176[0].__r_.__value_.__r.__words[1]) = 2080;
            *(std::string::size_type *)((char *)&v176[0].__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)"";
            _os_log_impl((void *)&_mh_execute_header, v62, OS_LOG_TYPE_DEFAULT, "#I %s%sEntitlement+Push Dictionary :", (uint8_t *)v176, 0x16u);
          }
          v176[0].__r_.__value_.__r.__words[0] = (std::string::size_type)off_101A3EEF0;
          v176[0].__r_.__value_.__l.__size_ = a1;
          v176[1].__r_.__value_.__r.__words[0] = (std::string::size_type)v176;
          logger::CFTypeRefLogger();
          sub_10012C330(v176);
          (***(void (****)(std::string *__return_ptr))(a1 + 48))(v176);
          ServiceMap = (std::mutex *)Registry::getServiceMap(v63, (Registry *)v176[0].__r_.__value_.__l.__data_);
          long long v65 = ServiceMap;
          std::string::size_type v67 = v66;
          if ((v66 & 0x8000000000000000) != 0)
          {
            long long v68 = (unsigned __int8 *)(v66 & 0x7FFFFFFFFFFFFFFFLL);
            uint64_t v69 = 5381;
            do
            {
              std::string::size_type v67 = v69;
              unsigned int v70 = *v68++;
              uint64_t v69 = (33 * v69) ^ v70;
            }
            while (v70);
          }
          std::mutex::lock(ServiceMap);
          buf.__r_.__value_.__r.__words[0] = v67;
          unsigned int v71 = sub_10004D37C(&v65[1].__m_.__sig, (unint64_t *)&buf);
          if (v71)
          {
            uint64_t v73 = v71[3];
            std::string::value_type v72 = (std::__shared_weak_count *)v71[4];
            if (v72)
            {
              atomic_fetch_add_explicit(&v72->__shared_owners_, 1uLL, memory_order_relaxed);
              std::mutex::unlock(v65);
              atomic_fetch_add_explicit(&v72->__shared_owners_, 1uLL, memory_order_relaxed);
              sub_10004D2C8(v72);
              char v74 = 0;
              goto LABEL_160;
            }
          }
          else
          {
            uint64_t v73 = 0;
          }
          std::mutex::unlock(v65);
          std::string::value_type v72 = 0;
          char v74 = 1;
LABEL_160:
          (*(void (**)(uint64_t, uint64_t, CFDictionaryRef))(*(void *)v73 + 104))(v73, a2, theDict);
          if ((v74 & 1) == 0) {
            sub_10004D2C8(v72);
          }
          if (v176[0].__r_.__value_.__l.__size_) {
            sub_10004D2C8((std::__shared_weak_count *)v176[0].__r_.__value_.__l.__size_);
          }
          if (!*(unsigned char *)(v48 + 784))
          {
LABEL_203:
            if (*(unsigned char *)(v48 + 688)) {
              (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 48) + 280))(*(void *)(a1 + 48), a2, v48 + 664);
            }
            (***(void (****)(std::string *__return_ptr))(a1 + 48))(v176);
            long long v94 = (std::mutex *)Registry::getServiceMap(v93, (Registry *)v176[0].__r_.__value_.__l.__data_);
            long long v95 = v94;
            if ((v66 & 0x8000000000000000) != 0)
            {
              uint64_t v96 = (unsigned __int8 *)(v66 & 0x7FFFFFFFFFFFFFFFLL);
              uint64_t v97 = 5381;
              do
              {
                std::string::size_type v66 = v97;
                unsigned int v98 = *v96++;
                uint64_t v97 = (33 * v97) ^ v98;
              }
              while (v98);
            }
            std::mutex::lock(v94);
            buf.__r_.__value_.__r.__words[0] = v66;
            uint64_t v99 = sub_10004D37C(&v95[1].__m_.__sig, (unint64_t *)&buf);
            if (v99)
            {
              uint64_t v101 = v99[3];
              uint64_t v100 = (std::__shared_weak_count *)v99[4];
              if (v100)
              {
                atomic_fetch_add_explicit(&v100->__shared_owners_, 1uLL, memory_order_relaxed);
                std::mutex::unlock(v95);
                atomic_fetch_add_explicit(&v100->__shared_owners_, 1uLL, memory_order_relaxed);
                sub_10004D2C8(v100);
                char v102 = 0;
LABEL_213:
                (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v101 + 96))(v101, a2, 1);
                if ((v102 & 1) == 0) {
                  sub_10004D2C8(v100);
                }
                if (v176[0].__r_.__value_.__l.__size_) {
                  sub_10004D2C8((std::__shared_weak_count *)v176[0].__r_.__value_.__l.__size_);
                }
LABEL_217:
                sub_100057D78((const void **)&theDict);
                return;
              }
            }
            else
            {
              uint64_t v101 = 0;
            }
            std::mutex::unlock(v95);
            uint64_t v100 = 0;
            char v102 = 1;
            goto LABEL_213;
          }
          Value = CFDictionaryGetValue(theDict, @"CarrierEntitlements");
          CFTypeRef cf = Value;
          if (Value) {
            CFRetain(Value);
          }
          memset(&v167, 0, sizeof(v167));
          (***(void (****)(uint64_t *__return_ptr))(a1 + 48))(&v165);
          CFDictionaryRef v164 = (CFDictionaryRef)cf;
          if (cf) {
            CFRetain(cf);
          }
          if (*(char *)(v48 + 119) < 0)
          {
            sub_10004FC84(v162, *(void **)(v48 + 96), *(void *)(v48 + 104));
          }
          else
          {
            *(_OWORD *)__int16 v162 = *(_OWORD *)(v48 + 96);
            uint64_t v163 = *(void *)(v48 + 112);
          }
          if (*(char *)(v48 + 143) < 0) {
            sub_10004FC84(&v161, *(void **)(v48 + 120), *(void *)(v48 + 128));
          }
          else {
            std::string v161 = *(std::string *)(v48 + 120);
          }
          if (*(char *)(v48 + 783) < 0)
          {
            sub_10004FC84(__p, *(void **)(v48 + 760), *(void *)(v48 + 768));
          }
          else
          {
            *(_OWORD *)std::string __p = *(_OWORD *)(v48 + 760);
            uint64_t v160 = *(void *)(v48 + 776);
          }
          memset(&v167, 0, sizeof(v167));
          if (v164) {
            unint64_t v85 = sub_100080778;
          }
          else {
            unint64_t v85 = 0;
          }
          if (!v85)
          {
            uint64_t v91 = (ctu::OsLogContext *)ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)v176, kCtLoggingSystemName, "cp.tr.ctr");
            uint64_t v92 = v176[0].__r_.__value_.__l.__size_;
            ctu::OsLogContext::~OsLogContext(v91);
            if (os_log_type_enabled(v92, OS_LOG_TYPE_ERROR))
            {
              LOWORD(v176[0].__r_.__value_.__l.__data_) = 0;
              _os_log_error_impl((void *)&_mh_execute_header, v92, OS_LOG_TYPE_ERROR, "No Entitlement setting in Carrier bundle", (uint8_t *)v176, 2u);
            }
            goto LABEL_192;
          }
          CFDictionaryRef v172 = 0;
          CFDictionaryRef v86 = (const __CFDictionary *)CFDictionaryGetValue(v164, @"Authentication");
          CFDictionaryRef v172 = v86;
          if (!v86 || (CFRetain(v86), !v172))
          {
            char v89 = (ctu::OsLogContext *)ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)v176, kCtLoggingSystemName, "cp.tr.ctr");
            uint64_t v90 = v176[0].__r_.__value_.__l.__size_;
            ctu::OsLogContext::~OsLogContext(v89);
            if (os_log_type_enabled(v90, OS_LOG_TYPE_ERROR))
            {
              LOWORD(v176[0].__r_.__value_.__l.__data_) = 0;
              _os_log_error_impl((void *)&_mh_execute_header, v90, OS_LOG_TYPE_ERROR, "No Authentication Settings for Entitlements Server", (uint8_t *)v176, 2u);
            }
            goto LABEL_189;
          }
          memset(&buf, 0, sizeof(buf));
          CFDictionaryGetValue(v172, @"Username");
          memset(v176, 0, 24);
          ctu::cf::assign();
          std::string buf = v176[0];
          if (SHIBYTE(v176[0].__r_.__value_.__r.__words[2]) < 0)
          {
            int64_t v87 = buf.__r_.__value_.__l.__size_;
            if (buf.__r_.__value_.__l.__size_)
            {
              long long v88 = (std::string *)buf.__r_.__value_.__r.__words[0];
LABEL_230:
              if (v87 < 5)
              {
LABEL_255:
                xpc_object_t v117 = (ctu::OsLogContext *)ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)v176, kCtLoggingSystemName, "cp.tr.ctr");
                std::string::size_type v118 = v176[0].__r_.__value_.__l.__size_;
                ctu::OsLogContext::~OsLogContext(v117);
                if (!os_log_type_enabled(v118, OS_LOG_TYPE_ERROR)) {
                  goto LABEL_256;
                }
                LOWORD(v176[0].__r_.__value_.__l.__data_) = 0;
                xpc_object_t v121 = "Unable to find subscriber key for replacement";
                goto LABEL_265;
              }
              uint64_t v106 = (char *)v88 + v87;
              xpc_object_t v107 = v88;
              while (1)
              {
                xpc_object_t v108 = (char *)memchr(v107, 36, v87 - 4);
                if (!v108) {
                  goto LABEL_255;
                }
                if (*(_DWORD *)v108 == 1397573924 && v108[4] == 73) {
                  break;
                }
                xpc_object_t v107 = (std::string *)(v108 + 1);
                int64_t v87 = v106 - (char *)v107;
                if (v106 - (char *)v107 < 5) {
                  goto LABEL_255;
                }
              }
              if (v108 == v106 || v108 - (char *)v88 == -1) {
                goto LABEL_255;
              }
              if (v160 >= 0) {
                std::string::size_type v112 = HIBYTE(v160);
              }
              else {
                std::string::size_type v112 = (std::string::size_type)__p[1];
              }
              if (!v112)
              {
                std::string::size_type v122 = (ctu::OsLogContext *)ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)v176, kCtLoggingSystemName, "cp.tr.ctr");
                std::string::size_type v118 = v176[0].__r_.__value_.__l.__size_;
                ctu::OsLogContext::~OsLogContext(v122);
                if (!os_log_type_enabled(v118, OS_LOG_TYPE_ERROR)) {
                  goto LABEL_256;
                }
                LOWORD(v176[0].__r_.__value_.__l.__data_) = 0;
                xpc_object_t v121 = "No IMSI is available";
                goto LABEL_265;
              }
              if (v160 >= 0) {
                unint64_t v113 = __p;
              }
              else {
                unint64_t v113 = (void **)__p[0];
              }
              std::string::replace(&buf, v108 - (char *)v88, 5uLL, (const std::string::value_type *)v113, v112);
              int64_t v114 = HIBYTE(buf.__r_.__value_.__r.__words[2]);
              if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0)
              {
                int64_t v116 = buf.__r_.__value_.__l.__size_;
                if (buf.__r_.__value_.__l.__size_)
                {
                  p_std::string buf = (std::string *)buf.__r_.__value_.__r.__words[0];
                  goto LABEL_270;
                }
              }
              else if (*((unsigned char *)&buf.__r_.__value_.__s + 23))
              {
                p_std::string buf = &buf;
                int64_t v116 = HIBYTE(buf.__r_.__value_.__r.__words[2]);
LABEL_270:
                xpc_object_t v123 = (char *)p_buf + v116;
                if (v116 >= 4)
                {
                  xpc_object_t v124 = p_buf;
                  do
                  {
                    xpc_object_t v125 = (char *)memchr(v124, 36, v116 - 3);
                    if (!v125) {
                      break;
                    }
                    if (*(_DWORD *)v125 == 1128484132) {
                      goto LABEL_276;
                    }
                    xpc_object_t v124 = (std::string *)(v125 + 1);
                    int64_t v116 = v123 - (char *)v124;
                  }
                  while (v123 - (char *)v124 > 3);
                }
                xpc_object_t v125 = v123;
LABEL_276:
                if (v125 == v123) {
                  std::string::size_type v126 = -1;
                }
                else {
                  std::string::size_type v126 = v125 - (char *)p_buf;
                }
                int64_t v127 = buf.__r_.__value_.__l.__size_;
                if ((v114 & 0x80u) != 0)
                {
                  __int16 v128 = (std::string *)buf.__r_.__value_.__r.__words[0];
                }
                else
                {
                  int64_t v127 = v114;
                  __int16 v128 = &buf;
                }
                char v129 = (char *)v128 + v127;
                if (v127 >= 4)
                {
                  char v130 = v128;
                  do
                  {
                    long long v131 = (char *)memchr(v130, 36, v127 - 3);
                    if (!v131) {
                      break;
                    }
                    if (*(_DWORD *)v131 == 1129205028) {
                      goto LABEL_288;
                    }
                    char v130 = (std::string *)(v131 + 1);
                    int64_t v127 = v129 - (char *)v130;
                  }
                  while (v129 - (char *)v130 > 3);
                }
                long long v131 = v129;
LABEL_288:
                if (v131 == v129) {
                  std::string::size_type v132 = -1;
                }
                else {
                  std::string::size_type v132 = v131 - (char *)v128;
                }
                if (v126 == -1 && v132 == -1)
                {
LABEL_326:
                  long long v142 = (const char *)kCtLoggingSystemName;
                  uint64_t v143 = (ctu::OsLogContext *)ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)v176, kCtLoggingSystemName, "cp.tr.ctr");
                  long long v144 = v176[0].__r_.__value_.__l.__size_;
                  ctu::OsLogContext::~OsLogContext(v143);
                  if (os_log_type_enabled(v144, OS_LOG_TYPE_INFO))
                  {
                    char v145 = &buf;
                    if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
                      char v145 = (std::string *)buf.__r_.__value_.__r.__words[0];
                    }
                    LODWORD(v176[0].__r_.__value_.__l.__data_) = 136315138;
                    *(std::string::size_type *)((char *)v176[0].__r_.__value_.__r.__words + 4) = (std::string::size_type)v145;
                    _os_log_impl((void *)&_mh_execute_header, v144, OS_LOG_TYPE_INFO, "User name is %s", (uint8_t *)v176, 0xCu);
                  }
                  long long v177 = 0u;
                  long long v178 = 0u;
                  memset(v176, 0, sizeof(v176));
                  if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                    __int16 v146 = &buf;
                  }
                  else {
                    __int16 v146 = (std::string *)buf.__r_.__value_.__r.__words[0];
                  }
                  if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                    size_t v147 = HIBYTE(buf.__r_.__value_.__r.__words[2]);
                  }
                  else {
                    size_t v147 = buf.__r_.__value_.__l.__size_;
                  }
                  memset(&__dst, 0, sizeof(__dst));
                  sub_1007DC9C0((char *)&__dst, (char *)v146, (char *)v146 + v147, v147);
                  sub_1010E83D4((uint64_t)v176, 0, 1, 0, (uint64_t)&__dst);
                  if (__dst.__r_.__value_.__r.__words[0])
                  {
                    __dst.__r_.__value_.__l.__size_ = __dst.__r_.__value_.__r.__words[0];
                    operator delete(__dst.__r_.__value_.__l.__data_);
                  }
                  memset(&__dst, 0, sizeof(__dst));
                  sub_1010E7AC0(v176, &v175);
                  if (__dst.__r_.__value_.__r.__words[0])
                  {
                    __dst.__r_.__value_.__l.__size_ = __dst.__r_.__value_.__r.__words[0];
                    operator delete(__dst.__r_.__value_.__l.__data_);
                  }
                  std::string __dst = v175;
                  if (v175.__r_.__value_.__r.__words[0] == v175.__r_.__value_.__l.__size_)
                  {
                    char v154 = (ctu::OsLogContext *)ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v175, v142, "cp.tr.ctr");
                    __int16 v155 = v175.__r_.__value_.__l.__size_;
                    ctu::OsLogContext::~OsLogContext(v154);
                    if (!os_log_type_enabled(v155, OS_LOG_TYPE_ERROR)) {
                      goto LABEL_354;
                    }
                    LOWORD(v175.__r_.__value_.__l.__data_) = 0;
                    __int16 v156 = "Invalid Identity Data";
                  }
                  else
                  {
                    ctu::base64::encode();
                    if (SHIBYTE(v167.__r_.__value_.__r.__words[2]) < 0) {
                      operator delete(v167.__r_.__value_.__l.__data_);
                    }
                    std::string v167 = v175;
                    std::string::size_type v148 = HIBYTE(v175.__r_.__value_.__r.__words[2]);
                    int v149 = SHIBYTE(v175.__r_.__value_.__r.__words[2]);
                    if ((v175.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
                      std::string::size_type v148 = v167.__r_.__value_.__l.__size_;
                    }
                    if (v148)
                    {
                      char v150 = (ctu::OsLogContext *)ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v175, v142, "cp.tr.ctr");
                      char v151 = v175.__r_.__value_.__l.__size_;
                      ctu::OsLogContext::~OsLogContext(v150);
                      char v152 = 1;
                      if (os_log_type_enabled(v151, OS_LOG_TYPE_INFO))
                      {
                        char v153 = (std::string *)v167.__r_.__value_.__r.__words[0];
                        if (v149 >= 0) {
                          char v153 = &v167;
                        }
                        LODWORD(v175.__r_.__value_.__l.__data_) = 136315138;
                        *(std::string::size_type *)((char *)v175.__r_.__value_.__r.__words + 4) = (std::string::size_type)v153;
                        _os_log_impl((void *)&_mh_execute_header, v151, OS_LOG_TYPE_INFO, "Base64 Encoded String: [%s]", (uint8_t *)&v175, 0xCu);
                      }
                      char v119 = 0;
LABEL_355:
                      if (__dst.__r_.__value_.__r.__words[0])
                      {
                        __dst.__r_.__value_.__l.__size_ = __dst.__r_.__value_.__r.__words[0];
                        operator delete(__dst.__r_.__value_.__l.__data_);
                      }
                      sub_100B63E7C(v176);
                      if ((v152 & 1) == 0) {
                        goto LABEL_257;
                      }
                      goto LABEL_241;
                    }
                    int v157 = (ctu::OsLogContext *)ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v175, v142, "cp.tr.ctr");
                    __int16 v155 = v175.__r_.__value_.__l.__size_;
                    ctu::OsLogContext::~OsLogContext(v157);
                    if (!os_log_type_enabled(v155, OS_LOG_TYPE_ERROR))
                    {
LABEL_354:
                      char v152 = 0;
                      char v119 = 1;
                      goto LABEL_355;
                    }
                    LOWORD(v175.__r_.__value_.__l.__data_) = 0;
                    __int16 v156 = "Invalid User Name";
                  }
                  _os_log_error_impl((void *)&_mh_execute_header, v155, OS_LOG_TYPE_ERROR, v156, (uint8_t *)&v175, 2u);
                  goto LABEL_354;
                }
                if (v126 == -1) {
                  goto LABEL_302;
                }
                if (v163 >= 0) {
                  std::string::size_type v133 = HIBYTE(v163);
                }
                else {
                  std::string::size_type v133 = (std::string::size_type)v162[1];
                }
                if (v133)
                {
                  if (v163 >= 0) {
                    int64_t v134 = v162;
                  }
                  else {
                    int64_t v134 = (void **)v162[0];
                  }
                  std::string::replace(&buf, v126, 4uLL, (const std::string::value_type *)v134, v133);
LABEL_302:
                  if (v132 == -1) {
                    goto LABEL_326;
                  }
                  unsigned __int8 v135 = HIBYTE(v161.__r_.__value_.__r.__words[2]);
                  if (SHIBYTE(v161.__r_.__value_.__r.__words[2]) < 0)
                  {
                    int v136 = v161.__r_.__value_.__r.__words[1];
                    if (v161.__r_.__value_.__l.__size_) {
                      goto LABEL_311;
                    }
                  }
                  else if (*((unsigned char *)&v161.__r_.__value_.__s + 23))
                  {
                    int v136 = HIBYTE(v161.__r_.__value_.__r.__words[2]);
LABEL_311:
                    if (v136 <= 2)
                    {
                      if (3 - v136 <= 1) {
                        int v139 = 1;
                      }
                      else {
                        int v139 = 3 - v136;
                      }
                      do
                      {
                        std::operator+<char>();
                        if (SHIBYTE(v161.__r_.__value_.__r.__words[2]) < 0) {
                          operator delete(v161.__r_.__value_.__l.__data_);
                        }
                        std::string v161 = v176[0];
                        --v139;
                      }
                      while (v139);
                      unsigned __int8 v135 = HIBYTE(v161.__r_.__value_.__r.__words[2]);
                    }
                    if ((v135 & 0x80u) == 0) {
                      long long v140 = &v161;
                    }
                    else {
                      long long v140 = (std::string *)v161.__r_.__value_.__r.__words[0];
                    }
                    if ((v135 & 0x80u) == 0) {
                      std::string::size_type v141 = v135;
                    }
                    else {
                      std::string::size_type v141 = v161.__r_.__value_.__l.__size_;
                    }
                    std::string::replace(&buf, v132, 4uLL, (const std::string::value_type *)v140, v141);
                    goto LABEL_326;
                  }
                  long long v158 = (ctu::OsLogContext *)ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)v176, kCtLoggingSystemName, "cp.tr.ctr");
                  std::string::size_type v118 = v176[0].__r_.__value_.__l.__size_;
                  ctu::OsLogContext::~OsLogContext(v158);
                  if (!os_log_type_enabled(v118, OS_LOG_TYPE_ERROR)) {
                    goto LABEL_256;
                  }
                  LOWORD(v176[0].__r_.__value_.__l.__data_) = 0;
                  xpc_object_t v121 = "Required MNC not found";
                  goto LABEL_265;
                }
                __int16 v138 = (ctu::OsLogContext *)ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)v176, kCtLoggingSystemName, "cp.tr.ctr");
                std::string::size_type v118 = v176[0].__r_.__value_.__l.__size_;
                ctu::OsLogContext::~OsLogContext(v138);
                if (!os_log_type_enabled(v118, OS_LOG_TYPE_ERROR)) {
                  goto LABEL_256;
                }
                LOWORD(v176[0].__r_.__value_.__l.__data_) = 0;
                xpc_object_t v121 = "Required MCC not found";
LABEL_265:
                _os_log_error_impl((void *)&_mh_execute_header, v118, OS_LOG_TYPE_ERROR, v121, (uint8_t *)v176, 2u);
LABEL_256:
                char v119 = 1;
LABEL_257:
                if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
                  operator delete(buf.__r_.__value_.__l.__data_);
                }
                sub_100057D78((const void **)&v172);
                if ((v167.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                  char v120 = 1;
                }
                else {
                  char v120 = v119;
                }
                if ((v120 & 1) == 0) {
                  operator delete(v167.__r_.__value_.__l.__data_);
                }
                goto LABEL_192;
              }
              uint64_t v137 = (ctu::OsLogContext *)ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)v176, kCtLoggingSystemName, "cp.tr.ctr");
              std::string::size_type v118 = v176[0].__r_.__value_.__l.__size_;
              ctu::OsLogContext::~OsLogContext(v137);
              if (!os_log_type_enabled(v118, OS_LOG_TYPE_ERROR)) {
                goto LABEL_256;
              }
              LOWORD(v176[0].__r_.__value_.__l.__data_) = 0;
              xpc_object_t v121 = "Unable to replace subscriber identifier";
              goto LABEL_265;
            }
          }
          else
          {
            int64_t v87 = HIBYTE(v176[0].__r_.__value_.__r.__words[2]);
            if (*((unsigned char *)&v176[0].__r_.__value_.__s + 23))
            {
              long long v88 = &buf;
              goto LABEL_230;
            }
          }
          int v110 = (ctu::OsLogContext *)ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)v176, kCtLoggingSystemName, "cp.tr.ctr");
          xpc_object_t v111 = v176[0].__r_.__value_.__l.__size_;
          ctu::OsLogContext::~OsLogContext(v110);
          if (os_log_type_enabled(v111, OS_LOG_TYPE_ERROR))
          {
            LOWORD(v176[0].__r_.__value_.__l.__data_) = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v111, OS_LOG_TYPE_ERROR, "Authentication without Username", (uint8_t *)v176, 2u);
          }
LABEL_241:
          if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(buf.__r_.__value_.__l.__data_);
          }
LABEL_189:
          sub_100057D78((const void **)&v172);
LABEL_192:
          if (SHIBYTE(v160) < 0) {
            operator delete(__p[0]);
          }
          if (SHIBYTE(v161.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v161.__r_.__value_.__l.__data_);
          }
          if (SHIBYTE(v163) < 0) {
            operator delete(v162[0]);
          }
          sub_100057D78((const void **)&v164);
          if (v166) {
            sub_10004D2C8(v166);
          }
          (*(void (**)(void, uint64_t, std::string *))(**(void **)(a1 + 48) + 272))(*(void *)(a1 + 48), a2, &v167);
          if (SHIBYTE(v167.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v167.__r_.__value_.__l.__data_);
          }
          sub_100057D78(&cf);
          goto LABEL_203;
        }
        v175.__r_.__value_.__s.__data_[0] = 11;
        v176[0].__r_.__value_.__r.__words[0] = 0;
        v167.__r_.__value_.__s.__data_[0] = 56;
        buf.__r_.__value_.__r.__words[0] = 0;
        LODWORD(__dst.__r_.__value_.__l.__data_) = 70017;
        __dst.__r_.__value_.__s.__data_[4] = 1;
        sub_100B3E598((void *)a1, (unsigned __int8 **)(v48 + 1048), (unsigned __int8 *)&v175, 0, (const void **)&v176[0].__r_.__value_.__l.__data_, (char *)&v167, (const void **)&buf.__r_.__value_.__l.__data_, 0, 1, (uint64_t)&__dst, (uint64_t *)(a1 + 328));
        sub_100057D78((const void **)&buf.__r_.__value_.__l.__data_);
        sub_1000558F4((const void **)&v176[0].__r_.__value_.__l.__data_);
        if (*(unsigned char *)(a1 + 360))
        {
          if (!*(unsigned char *)(a1 + 1020))
          {
            *(_DWORD *)(a1 + 1016) = 1;
            *(unsigned char *)(a1 + 1020) = 1;
          }
          v176[0].__r_.__value_.__r.__words[0] = a1 + 336;
          uint64_t v75 = sub_100B6C578((uint64_t **)(a1 + 992), (void **)(a1 + 336), (long long **)v176);
          *((_DWORD *)v75 + 21) = 70017;
          v75[88] = 1;
          sub_100B47BD0(a1);
          sub_100B47C9C(a1);
        }
        long long v45 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v45, OS_LOG_TYPE_ERROR))
        {
          LOWORD(v176[0].__r_.__value_.__l.__data_) = 0;
          uint64_t v46 = "Data to perform transfer unavailable";
          goto LABEL_126;
        }
      }
    }
  }
}

void sub_100B477F8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, void *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25,uint64_t a26,void *a27,uint64_t a28,int a29,__int16 a30,char a31,char a32,const void *a33,uint64_t a34,uint64_t a35,void *a36,uint64_t a37,int a38,__int16 a39,char a40,char a41,uint64_t a42,const void *a43,const void *a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,void *a49,uint64_t a50,uint64_t a51,const void *a52,void *__p,uint64_t a54,int a55,__int16 a56,char a57,char a58)
{
  if (a58 < 0) {
    operator delete(__p);
  }
  int v59 = a41;
  sub_100057D78(&a52);
  if (v59 < 0) {
    operator delete(a36);
  }
  if (a18 < 0) {
    operator delete(a13);
  }
  if (a25 < 0) {
    operator delete(a20);
  }
  if (a32 < 0) {
    operator delete(a27);
  }
  sub_100057D78(&a33);
  if (a35) {
    sub_10004D2C8((std::__shared_weak_count *)a35);
  }
  sub_100057D78(&a43);
  sub_100057D78(&a44);
  _Unwind_Resume(a1);
}

void sub_100B47BD0(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 360))
  {
    uint64_t v2 = (std::string *)(a1 + 336);
    if (*(char *)(a1 + 359) < 0)
    {
      sub_10004FC84(__p, *(void **)(a1 + 336), *(void *)(a1 + 344));
    }
    else
    {
      *(_OWORD *)std::string __p = *(_OWORD *)&v2->__r_.__value_.__l.__data_;
      uint64_t v5 = *(void *)(a1 + 352);
    }
    sub_100B4A3B8(a1, (uint64_t)__p);
    if (SHIBYTE(v5) < 0) {
      operator delete(__p[0]);
    }
    if (*(unsigned char *)(a1 + 360))
    {
      if (*(char *)(a1 + 359) < 0) {
        operator delete(v2->__r_.__value_.__l.__data_);
      }
      *(unsigned char *)(a1 + 360) = 0;
    }
    uint64_t v3 = *(void *)(a1 + 328);
    if (v3 != *(void *)(a1 + 312)) {
      sub_100093B44(v2, (const std::string *)(v3 + 1048));
    }
  }
}

void sub_100B47C80(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100B47C9C(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 360))
  {
    memset(&v28, 0, sizeof(v28));
    std::string::operator=(&v28, (const std::string *)(a1 + 336));
    *(void *)&long long buf = &v28;
    sub_100B6C578((uint64_t **)(a1 + 992), (void **)&v28.__r_.__value_.__l.__data_, (long long **)&buf)[82] = 1;
    if (!*(unsigned char *)(a1 + 360))
    {
      uint64_t v20 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(buf) = 0;
        _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#I No Preflight Iccid", (uint8_t *)&buf, 2u);
      }
      goto LABEL_38;
    }
    uint64_t v2 = *(void *)(a1 + 328);
    if (v2 == *(void *)(a1 + 312))
    {
LABEL_38:
      uint64_t v26 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
      {
        unint64_t v27 = &v28;
        if ((v28.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
          unint64_t v27 = (std::string *)v28.__r_.__value_.__r.__words[0];
        }
        LODWORD(buf) = 136315138;
        *(void *)((char *)&buf + 4) = v27;
        _os_log_error_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_ERROR, "Start Personality failed for : %s", (uint8_t *)&buf, 0xCu);
      }
      sub_100B47BD0(a1);
      sub_100B47C9C(a1);
      goto LABEL_40;
    }
    uint64_t v3 = (void *)(v2 + 1048);
    if (!*(unsigned char *)(v2 + 624) || !*(unsigned char *)(v2 + 424))
    {
      BOOL v21 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
      {
        if (*(char *)(v2 + 1071) < 0) {
          uint64_t v3 = (void *)*v3;
        }
        LODWORD(buf) = 136315138;
        *(void *)((char *)&buf + 4) = v3;
        _os_log_error_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "No Transfer Token for iccid: [%s]", (uint8_t *)&buf, 0xCu);
      }
      *(void *)&long long buf = a1 + 336;
      uint64_t v22 = sub_100B6C578((uint64_t **)(a1 + 992), (void **)(a1 + 336), (long long **)&buf);
      *((_DWORD *)v22 + 21) = 70019;
      v22[88] = 1;
      sub_100991BC4(*(void *)(a1 + 328));
      goto LABEL_38;
    }
    sub_100B53774((char *)(v2 + 632), (std::string *)(v2 + 368));
    long long buf = 0uLL;
    uint64_t v34 = 0;
    sub_100B49750((uint64_t)&buf, *(void *)(a1 + 328) + 1048);
    uint64_t v4 = *(void *)(a1 + 328);
    if (!*(unsigned char *)(v4 + 216) || !*(unsigned char *)(v4 + 888))
    {
      uint64_t v23 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
      {
        if (*(char *)(v2 + 1071) < 0) {
          uint64_t v3 = (void *)*v3;
        }
        LODWORD(__p.__r_.__value_.__l.__data_) = 136315138;
        *(std::string::size_type *)((char *)__p.__r_.__value_.__r.__words + 4) = (std::string::size_type)v3;
        _os_log_error_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_ERROR, "Target entitlements unavailable. iccid: [%s]", (uint8_t *)&__p, 0xCu);
      }
      __p.__r_.__value_.__r.__words[0] = a1 + 336;
      long long v24 = sub_100B6C578((uint64_t **)(a1 + 992), (void **)(a1 + 336), (long long **)&__p);
      char v25 = 0;
      *((_DWORD *)v24 + 21) = 70021;
      v24[88] = 1;
LABEL_34:
      if (SHIBYTE(v34) < 0)
      {
        operator delete((void *)buf);
        if (v25) {
          goto LABEL_40;
        }
      }
      else if (v25)
      {
LABEL_40:
        if (SHIBYTE(v28.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v28.__r_.__value_.__l.__data_);
        }
        return;
      }
      goto LABEL_38;
    }
    memset(&__p, 0, sizeof(__p));
    BOOL v5 = sub_100B51B0C(a1, v4);
    char v6 = (*(uint64_t (**)(void))(**(void **)(a1 + 48) + 32))(*(void *)(a1 + 48));
    sub_100CDA4C8((void *)(a1 + 720), (uint64_t *)(a1 + 624), (uint64_t *)(a1 + 600), v5, v6, *(unsigned __int8 *)(a1 + 129), &__p);
    uint64_t v7 = sub_100CDB150((void *)(a1 + 720), (unsigned __int8 **)&__p);
    if (v7) {
      (*(void (**)(void, long long *, uint64_t))(**(void **)(a1 + 48) + 288))(*(void *)(a1 + 48), &buf, v7);
    }
    (***(void (****)(Registry **__return_ptr))(a1 + 48))(&v29);
    ServiceMap = (std::mutex *)Registry::getServiceMap(v8, v29);
    uint64_t v10 = ServiceMap;
    if ((v11 & 0x8000000000000000) != 0)
    {
      BOOL v12 = (unsigned __int8 *)(v11 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v13 = 5381;
      do
      {
        unint64_t v11 = v13;
        unsigned int v14 = *v12++;
        uint64_t v13 = (33 * v13) ^ v14;
      }
      while (v14);
    }
    std::mutex::lock(ServiceMap);
    unint64_t v31 = v11;
    uint64_t v15 = sub_10004D37C(&v10[1].__m_.__sig, &v31);
    if (v15)
    {
      uint64_t v17 = v15[3];
      std::string::size_type v16 = (std::__shared_weak_count *)v15[4];
      if (v16)
      {
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v10);
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v16);
        char v18 = 0;
LABEL_27:
        LOBYTE(v31) = 2;
        (*(void (**)(uint64_t, long long *, unint64_t *))(*(void *)v17 + 80))(v17, &buf, &v31);
        if ((v18 & 1) == 0) {
          sub_10004D2C8(v16);
        }
        if (v30) {
          sub_10004D2C8(v30);
        }
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__p.__r_.__value_.__l.__data_);
        }
        char v25 = 1;
        goto LABEL_34;
      }
    }
    else
    {
      uint64_t v17 = 0;
    }
    std::mutex::unlock(v10);
    std::string::size_type v16 = 0;
    char v18 = 1;
    goto LABEL_27;
  }
  uint64_t v19 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(buf) = 0;
    _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#I No Preflight Iccid", (uint8_t *)&buf, 2u);
  }
  *(unsigned char *)(a1 + 134) = 1;
  sub_100B3F32C(a1);
  sub_100B42C90(a1);
}

void sub_100B481C4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,void *a25,uint64_t a26,int a27,__int16 a28,char a29,char a30)
{
  if (a23 < 0) {
    operator delete(__p);
  }
  if (a30 < 0) {
    operator delete(a25);
  }
  if (a14 < 0) {
    operator delete(a9);
  }
  _Unwind_Resume(exception_object);
}

const void **sub_100B48258(const void **result, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = result;
  if (!*(unsigned char *)(a3 + 216)) {
    goto LABEL_15;
  }
  uint64_t v5 = *(unsigned __int8 *)(a3 + 39);
  if ((v5 & 0x80u) != 0) {
    uint64_t v5 = *(void *)(a3 + 24);
  }
  if (!v5)
  {
LABEL_15:
    *uint64_t result = 0;
    return result;
  }
  uint64_t v7 = (uint64_t **)(a2 + 880);
  std::string::size_type v8 = *(void ***)(a2 + 888);
  if (!v8)
  {
LABEL_10:
    unsigned int v14 = 0;
    (*(void (**)(const void **__return_ptr))(**(void **)(a2 + 48) + 216))(&v14);
    if (v14) {
      int v9 = sub_100080778;
    }
    else {
      int v9 = 0;
    }
    if (v9)
    {
      *(void *)long long buf = a3 + 16;
      uint64_t v10 = sub_100B6FE88(v7, (void **)(a3 + 16), (uint64_t)&unk_10144E20E, (long long **)buf);
      sub_100058140((const void **)v10 + 7, &v14);
      void *v3 = v14;
      unsigned int v14 = 0;
    }
    else
    {
      unint64_t v11 = *(NSObject **)(a2 + 40);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        if (*(char *)(a3 + 39) >= 0) {
          uint64_t v12 = a3 + 16;
        }
        else {
          uint64_t v12 = *(void *)(a3 + 16);
        }
        *(_DWORD *)long long buf = 136315138;
        *(void *)&uint8_t buf[4] = v12;
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I failed loading CB for ICCID: [%s]", buf, 0xCu);
      }
      void *v3 = 0;
    }
    return sub_100057D78(&v14);
  }
  while ((sub_100046FE8((void *)(a3 + 16), v8 + 4) & 0x80) != 0)
  {
LABEL_9:
    std::string::size_type v8 = (void **)*v8;
    if (!v8) {
      goto LABEL_10;
    }
  }
  if ((sub_100046FE8(v8 + 4, (void **)(a3 + 16)) & 0x80) != 0)
  {
    ++v8;
    goto LABEL_9;
  }
  *(void *)long long buf = 0;
  uint64_t v13 = *sub_100046ED4((uint64_t)v7, buf, (void **)(a3 + 16));
  if (!v13) {
    sub_1000C14F0("map::at:  key not found");
  }

  return sub_100058198(v3, (const void **)(v13 + 56));
}

void sub_100B484B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9)
{
}

void sub_100B484CC(uint64_t a1, uint64_t a2)
{
  void (***v15)(long long *__return_ptr, void, void **);
  char v16;
  NSObject *v17;
  unsigned __int8 *v18;
  uint64_t v19;
  std::__shared_weak_count *v20;
  uint64_t v21;
  std::__shared_weak_count *v22;
  NSObject *v23;
  char *v24;
  unsigned char *v25;
  uint64_t v26;
  std::__shared_weak_count *v27;
  uint64_t v28;
  std::__shared_weak_count *v29;
  char *v30;
  char *v31;
  unsigned char *v32;
  uint64_t v33;
  void *v34;
  unint64_t v35;
  int v36;
  void *v37;
  void **v38;
  unsigned __int8 *v39;
  uint64_t v40;
  char *v41;
  unsigned __int8 *v42;
  uint64_t v43;
  int v44;
  int v45;
  uint64_t *v46;
  std::mutex *v47;
  std::mutex *v48;
  unsigned __int8 *v49;
  uint64_t v50;
  unsigned int v51;
  void *v52;
  std::__shared_weak_count *v53;
  void (***v54)(uint64_t *__return_ptr, void, void **);
  char v55;
  uint64_t v56;
  uint64_t v57;
  NSObject *v58;
  uint64_t v59;
  long long v60;
  uint64_t v61;
  uint64_t v62;
  int v63;
  unsigned __int8 *v64;
  unsigned __int8 *p_dst;
  uint64_t v66;
  uint64_t v67;
  NSObject *v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  unint64_t v72;
  unint64_t v73;
  unsigned __int16 v74;
  BOOL v75;
  char **v76;
  NSObject *v77;
  uint64_t v78;
  std::__shared_weak_count *v79;
  uint64_t v80;
  std::__shared_weak_count *v81;
  std::__shared_weak_count *v82;
  atomic_ullong *p_shared_weak_owners;
  uint64_t v84;
  uint64_t v85;
  NSObject *v86;
  void **v87;
  long long v88;
  std::__shared_weak_count *v89;
  long long v90;
  long long v91;
  uint64_t v92;
  long long v93;
  uint64_t v94;
  long long v95;
  std::__shared_weak_count *v96;
  long long __p;
  uint64_t v98;
  long long v99;
  void *v100[2];
  uint64_t v101;
  uint64_t v102;
  void *v103[2];
  void (*v104)(void *, void *, int, int);
  void *v105;
  uint64_t v106;
  uint64_t v107;
  std::__shared_weak_count *v108;
  uint64_t v109;
  void **v110;
  uint64_t v111;
  std::__shared_weak_count *v112;
  uint8_t *v113;
  void v114[3];
  char *v115;
  uint8_t buf[16];
  long long v117;
  long long v118;
  void *v119[4];
  _OWORD v120[4];
  long long v121;
  long long v122;
  long long v123;
  long long v124;
  long long v125;
  long long v126;
  long long v127;
  long long v128;
  long long v129;
  long long v130;
  long long v131;
  long long v132;
  uint64_t v133;
  uint8_t v134[16];
  uint64_t v135;
  long long __dst;
  long long v137;
  long long v138;
  long long v139;
  long long v140;
  uint64_t v141;
  std::string v142;

  uint64_t v4 = *(void *)(a1 + 312);
  char v102 = sub_100B45F5C(*(void *)(a1 + 304), v4, (unsigned __int8 **)a2);
  if (v4 != v102)
  {
    v100[0] = 0;
    v100[1] = 0;
    uint64_t v101 = 0;
    sub_100B49750((uint64_t)v100, a2);
    uint64_t v99 = 0uLL;
    (***(void (****)(uint8_t *__return_ptr))(a1 + 48))(buf);
    ServiceMap = (std::mutex *)Registry::getServiceMap(v5, *(Registry **)buf);
    uint64_t v7 = ServiceMap;
    uint64_t v9 = v8;
    if (v8 < 0)
    {
      uint64_t v10 = (unsigned __int8 *)(v8 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v11 = 5381;
      do
      {
        uint64_t v9 = v11;
        unsigned int v12 = *v10++;
        uint64_t v11 = (33 * v11) ^ v12;
      }
      while (v12);
    }
    std::mutex::lock(ServiceMap);
    *(void *)&std::string __dst = v9;
    uint64_t v13 = sub_10004D37C(&v7[1].__m_.__sig, (unint64_t *)&__dst);
    if (v13)
    {
      uint64_t v15 = (void (***)(long long *__return_ptr, void, void **))v13[3];
      unsigned int v14 = (std::__shared_weak_count *)v13[4];
      if (v14)
      {
        atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v7);
        atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v14);
        std::string::size_type v16 = 0;
        goto LABEL_15;
      }
    }
    else
    {
      uint64_t v15 = 0;
    }
    std::mutex::unlock(v7);
    unsigned int v14 = 0;
    std::string::size_type v16 = 1;
LABEL_15:
    (**v15)(&v99, v15, v100);
    if ((v16 & 1) == 0) {
      sub_10004D2C8(v14);
    }
    if (*(void *)&buf[8]) {
      sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
    }
    uint64_t v19 = v99;
    if ((void)v99)
    {
      *(void *)&long long v95 = a1;
      uint64_t v20 = *(std::__shared_weak_count **)(a1 + 16);
      if (!v20 || (BOOL v21 = *(void *)(a1 + 8), (v22 = std::__shared_weak_count::lock(v20)) == 0)) {
        sub_100088B9C();
      }
      *((void *)&v95 + 1) = v21;
      uint64_t v96 = v22;
      atomic_fetch_add_explicit(&v22->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v22);
      if (*(char *)(a2 + 23) < 0)
      {
        sub_10004FC84(&__p, *(void **)a2, *(void *)(a2 + 8));
      }
      else
      {
        std::string __p = *(_OWORD *)a2;
        unsigned int v98 = *(void *)(a2 + 16);
      }
      long long v115 = 0;
      long long v24 = (char *)operator new(0x38uLL);
      *(void *)long long v24 = off_101A3F6A0;
      *(_OWORD *)(v24 + 8) = v95;
      *((void *)v24 + 3) = v96;
      *((void *)&v95 + 1) = 0;
      uint64_t v96 = 0;
      char v25 = v24 + 32;
      if (SHIBYTE(v98) < 0)
      {
        sub_10004FC84(v25, (void *)__p, *((unint64_t *)&__p + 1));
      }
      else
      {
        *(_OWORD *)char v25 = __p;
        *((void *)v24 + 6) = v98;
      }
      long long v115 = v24;
      (*(void (**)(uint64_t, void *))(*(void *)v19 + 512))(v19, v114);
      sub_1001A2BEC(v114);
      if (SHIBYTE(v98) < 0) {
        operator delete((void *)__p);
      }
      if (v96) {
        std::__shared_weak_count::__release_weak(v96);
      }
      uint64_t v26 = v99;
      *(void *)&long long v88 = a1;
      unint64_t v27 = *(std::__shared_weak_count **)(a1 + 16);
      if (!v27 || (std::string v28 = *(void *)(a1 + 8), (v29 = std::__shared_weak_count::lock(v27)) == 0)) {
        sub_100088B9C();
      }
      *((void *)&v88 + 1) = v28;
      char v89 = v29;
      atomic_fetch_add_explicit(&v29->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v29);
      uint64_t v90 = v99;
      if (*((void *)&v99 + 1)) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v99 + 1) + 8), 1uLL, memory_order_relaxed);
      }
      if (*(char *)(a2 + 23) < 0)
      {
        sub_10004FC84(&v91, *(void **)a2, *(void *)(a2 + 8));
      }
      else
      {
        uint64_t v91 = *(_OWORD *)a2;
        uint64_t v92 = *(void *)(a2 + 16);
      }
      if (SHIBYTE(v101) < 0)
      {
        sub_10004FC84(&v93, v100[0], (unint64_t)v100[1]);
      }
      else
      {
        unsigned int v93 = *(_OWORD *)v100;
        long long v94 = v101;
      }
      *((void *)&v117 + 1) = 0;
      int v30 = (char *)operator new(0x60uLL);
      unint64_t v31 = v30;
      *(void *)int v30 = off_101A3F730;
      *(_OWORD *)(v30 + 8) = v88;
      *((void *)v30 + 3) = v89;
      *((_OWORD *)v30 + 2) = v90;
      if (SHIBYTE(v92) < 0)
      {
        sub_10004FC84(v30 + 48, (void *)v91, *((unint64_t *)&v91 + 1));
      }
      else
      {
        *((_OWORD *)v30 + 3) = v91;
        *((void *)v30 + 8) = v92;
      }
      uint64_t v32 = v31 + 72;
      if (SHIBYTE(v94) < 0)
      {
        sub_10004FC84(v32, (void *)v93, *((unint64_t *)&v93 + 1));
      }
      else
      {
        *(_OWORD *)uint64_t v32 = v93;
        *((void *)v31 + 11) = v94;
      }
      *((void *)&v117 + 1) = v31;
      (*(void (**)(uint64_t, uint64_t, uint8_t *))(*(void *)v26 + 328))(v26, 7, buf);
      sub_100060644(buf);
      if (SHIBYTE(v94) < 0) {
        operator delete((void *)v93);
      }
      if (SHIBYTE(v92) < 0) {
        operator delete((void *)v91);
      }
      long long v33 = *(void *)(a1 + 328);
      if (v33 != *(void *)(a1 + 312))
      {
        if (v101 >= 0) {
          uint64_t v34 = (void *)HIBYTE(v101);
        }
        else {
          uint64_t v34 = v100[1];
        }
        int v35 = *(unsigned __int8 *)(v33 + 1071);
        int v36 = (char)v35;
        if ((v35 & 0x80u) != 0) {
          int v35 = *(void *)(v33 + 1056);
        }
        if (v34 == (void *)(v35 + 21))
        {
          uint64_t v37 = (void *)(v33 + 1048);
          if (!v35) {
            goto LABEL_73;
          }
          uint64_t v38 = v100;
          if (v101 < 0) {
            uint64_t v38 = (void **)v100[0];
          }
          uint64_t v39 = (unsigned __int8 *)(v36 >= 0 ? v33 + 1048 : *v37);
          if (*((unsigned __int8 *)v38 + 21) == *v39)
          {
            uint64_t v40 = 0;
            unint64_t v41 = (char *)v38 + 22;
            long long v42 = v39 + 1;
            do
            {
              long long v43 = v40;
              if (v35 - 1 == v40) {
                break;
              }
              long long v44 = v41[v40];
              long long v45 = v42[v40++];
            }
            while (v44 == v45);
            if (v43 + 1 >= v35)
            {
LABEL_73:
              xpc_object_t v111 = 0;
              std::string::size_type v112 = 0;
              (***(void (****)(uint8_t *__return_ptr))(a1 + 48))(buf);
              uint64_t v47 = (std::mutex *)Registry::getServiceMap(v46, *(Registry **)buf);
              uint64_t v48 = v47;
              if (v8 < 0)
              {
                int v49 = (unsigned __int8 *)(v8 & 0x7FFFFFFFFFFFFFFFLL);
                uint64_t v50 = 5381;
                do
                {
                  uint64_t v8 = v50;
                  unint64_t v51 = *v49++;
                  uint64_t v50 = (33 * v50) ^ v51;
                }
                while (v51);
              }
              std::mutex::lock(v47);
              *(void *)&std::string __dst = v8;
              int v52 = sub_10004D37C(&v48[1].__m_.__sig, (unint64_t *)&__dst);
              if (v52)
              {
                unint64_t v54 = (void (***)(uint64_t *__return_ptr, void, void **))v52[3];
                uint64_t v53 = (std::__shared_weak_count *)v52[4];
                if (v53)
                {
                  atomic_fetch_add_explicit(&v53->__shared_owners_, 1uLL, memory_order_relaxed);
                  std::mutex::unlock(v48);
                  atomic_fetch_add_explicit(&v53->__shared_owners_, 1uLL, memory_order_relaxed);
                  sub_10004D2C8(v53);
                  uint64_t v55 = 0;
LABEL_81:
                  (**v54)(&v111, v54, v100);
                  if ((v55 & 1) == 0) {
                    sub_10004D2C8(v53);
                  }
                  if (*(void *)&buf[8]) {
                    sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
                  }
                  if (v111)
                  {
                    uint64_t v56 = *(void *)(a1 + 856);
                    uint64_t v57 = *(void *)(a1 + 864);
                    if (*(char *)(v33 + 1071) < 0)
                    {
                      sub_10004FC84(&__dst, *(void **)(v33 + 1048), *(void *)(v33 + 1056));
                    }
                    else
                    {
                      std::string __dst = *(_OWORD *)v37;
                      *(void *)&uint64_t v137 = *(void *)(v33 + 1064);
                    }
                    int v59 = BYTE7(v137);
                    if (v56 != v57)
                    {
                      int v60 = __dst;
                      if ((SBYTE7(v137) & 0x80u) == 0) {
                        long long v61 = BYTE7(v137);
                      }
                      else {
                        long long v61 = *((void *)&__dst + 1);
                      }
                      do
                      {
                        long long v62 = *(unsigned __int8 *)(v56 + 455);
                        int64x2_t v63 = (char)v62;
                        if ((v62 & 0x80u) != 0) {
                          long long v62 = *(void *)(v56 + 440);
                        }
                        if (v61 == v62)
                        {
                          if (v63 >= 0) {
                            unint64_t v64 = (unsigned __int8 *)(v56 + 432);
                          }
                          else {
                            unint64_t v64 = *(unsigned __int8 **)(v56 + 432);
                          }
                          if ((v59 & 0x80) != 0)
                          {
                            if (!memcmp((const void *)v60, v64, *((size_t *)&v60 + 1))) {
                              goto LABEL_112;
                            }
                          }
                          else
                          {
                            if (!v59) {
                              goto LABEL_113;
                            }
                            p_dst = (unsigned __int8 *)&__dst;
                            std::string::size_type v66 = v59;
                            while (*p_dst == *v64)
                            {
                              ++p_dst;
                              ++v64;
                              if (!--v66) {
                                goto LABEL_111;
                              }
                            }
                          }
                        }
                        v56 += 1248;
                      }
                      while (v56 != v57);
                      uint64_t v56 = v57;
                    }
LABEL_111:
                    if ((v59 & 0x80) != 0) {
LABEL_112:
                    }
                      operator delete((void *)__dst);
LABEL_113:
                    if (v56 == *(void *)(a1 + 864)
                      || (*(char *)(v56 + 679) < 0
                        ? (std::string::size_type v67 = *(void *)(v56 + 664))
                        : (std::string::size_type v67 = *(unsigned __int8 *)(v56 + 679)),
                          v67 || *(unsigned char *)(a1 + 132) || !*(unsigned char *)(v56 + 680)))
                    {
                      long long v68 = *(NSObject **)(a1 + 40);
                      if (os_log_type_enabled(v68, OS_LOG_TYPE_DEFAULT))
                      {
                        uint64_t v69 = v33 + 1048;
                        if (*(char *)(v33 + 1071) < 0) {
                          uint64_t v69 = *v37;
                        }
                        *(_DWORD *)long long buf = 136315138;
                        *(void *)&uint8_t buf[4] = v69;
                        _os_log_impl((void *)&_mh_execute_header, v68, OS_LOG_TYPE_DEFAULT, "#I [req][tss] perform TransferSIM request. source iccid : %s", buf, 0xCu);
                      }
                      std::string::size_type v133 = 0;
                      long long v131 = 0u;
                      std::string::size_type v132 = 0u;
                      char v129 = 0u;
                      char v130 = 0u;
                      int64_t v127 = 0u;
                      __int16 v128 = 0u;
                      xpc_object_t v125 = 0u;
                      std::string::size_type v126 = 0u;
                      xpc_object_t v123 = 0u;
                      xpc_object_t v124 = 0u;
                      xpc_object_t v121 = 0u;
                      std::string::size_type v122 = 0u;
                      memset(v120, 0, sizeof(v120));
                      memset(v119, 0, sizeof(v119));
                      xpc_object_t v117 = 0u;
                      std::string::size_type v118 = 0u;
                      *(_OWORD *)long long buf = 0u;
                      unsigned int v70 = *(void *)(a1 + 312);
                      unsigned int v71 = sub_100B45F5C(*(void *)(a1 + 304), v70, (unsigned __int8 **)(v33 + 1048));
                      if (v70 == v71)
                      {
                        buf[0] = 0;
                        BYTE8(v117) = 0;
                        LOBYTE(v120[0]) = 0;
                        LOBYTE(v122) = 0;
                        BYTE8(v122) = 0;
                        BYTE12(v122) = 0;
                        LOBYTE(v123) = 0;
                        BYTE8(v124) = 0;
                        LOBYTE(v125) = 0;
                        BYTE8(v126) = 0;
                        LOWORD(v127) = 0;
                        BYTE8(v127) = 0;
                        LOBYTE(v129) = 0;
                        BYTE8(v129) = 0;
                        LOBYTE(v133) = 0;
                        v119[0] = 0;
                        std::string::size_type v118 = 0uLL;
                        LOBYTE(v119[1]) = 0;
                        memset((char *)v120 + 8, 0, 49);
                      }
                      else
                      {
                        std::string::value_type v72 = v71;
                        std::string::size_type v133 = 0;
                        long long v131 = 0u;
                        std::string::size_type v132 = 0u;
                        char v129 = 0u;
                        char v130 = 0u;
                        int64_t v127 = 0u;
                        __int16 v128 = 0u;
                        xpc_object_t v125 = 0u;
                        std::string::size_type v126 = 0u;
                        xpc_object_t v123 = 0u;
                        xpc_object_t v124 = 0u;
                        xpc_object_t v121 = 0u;
                        std::string::size_type v122 = 0u;
                        memset(v120, 0, sizeof(v120));
                        memset(v119, 0, sizeof(v119));
                        xpc_object_t v117 = 0u;
                        std::string::size_type v118 = 0u;
                        *(_OWORD *)long long buf = 0u;
                        if (*(char *)(v33 + 1071) < 0)
                        {
                          sub_10004FC84(v103, *(void **)(v33 + 1048), *(void *)(v33 + 1056));
                        }
                        else
                        {
                          *(_OWORD *)uint64_t v103 = *(_OWORD *)v37;
                          xpc_object_t v104 = *(void (**)(void *, void *, int, int))(v33 + 1064);
                        }
                        sub_100B620D8(&__dst, (long long *)v103);
                        sub_100B6213C((char **)&v118, (std::string *)&__dst, &v142);
                        if ((_BYTE)v141 && SHIBYTE(v140) < 0) {
                          operator delete(*((void **)&v139 + 1));
                        }
                        if ((_BYTE)v139 && SHIBYTE(v138) < 0) {
                          operator delete(*((void **)&v137 + 1));
                        }
                        if (SBYTE7(v137) < 0) {
                          operator delete((void *)__dst);
                        }
                        if (SHIBYTE(v104) < 0) {
                          operator delete(v103[0]);
                        }
                        ctu::hex((uint64_t *)&__dst, (ctu *)(v72 + 1032), (const void *)0x10, v73);
                        if (LOBYTE(v120[0]))
                        {
                          if (SHIBYTE(v119[3]) < 0) {
                            operator delete(v119[1]);
                          }
                          *(_OWORD *)&v119[1] = __dst;
                          v119[3] = (void *)v137;
                        }
                        else
                        {
                          *(_OWORD *)&v119[1] = __dst;
                          v119[3] = (void *)v137;
                          LOBYTE(v120[0]) = 1;
                        }
                        sub_100B50FB0(a1, (uint64_t)v120 + 8, v72);
                        if (sub_100B515C8(a1, (unsigned __int8 **)(v33 + 1048))) {
                          LOWORD(v127) = 256;
                        }
                        if (*(unsigned char *)(v72 + 216))
                        {
                          std::string __dst = 0uLL;
                          sub_100B50AC0((const void **)&__dst, a1, v72);
                          if ((void)__dst)
                          {
                            char v74 = sub_100B50DA4((NSObject **)(a1 + 40), *(CFDictionaryRef *)(__dst + 64), @"ReportTransferSimServiceFlowType", (uint64_t *)(v72 + 16));
                            uint64_t v75 = v74 < 0x100u || v74 != 0;
                          }
                          else
                          {
                            uint64_t v75 = 0;
                          }
                          if (*((void *)&__dst + 1)) {
                            sub_10004D2C8(*((std::__shared_weak_count **)&__dst + 1));
                          }
                          if (v75)
                          {
                            if (*(unsigned char *)(a1 + 131)) {
                              uint64_t v76 = off_101A3E440;
                            }
                            else {
                              uint64_t v76 = &off_101A3E448;
                            }
                            sub_1000791C0((std::string *)((char *)&v127 + 8), v76);
                          }
                        }
                        if (*(unsigned char *)(v72 + 1476))
                        {
                          *(void *)&int v139 = 0;
                          uint64_t v137 = 0u;
                          __int16 v138 = 0u;
                          std::string __dst = 0u;
                          sub_100B51674((uint64_t *)v134, (void *)a1, v33 + 1048);
                          sub_10005CBB4((uint64_t *)&__dst);
                          std::string __dst = *(_OWORD *)v134;
                          *(void *)&uint64_t v137 = v135;
                          unsigned __int8 v135 = 0;
                          memset(v134, 0, sizeof(v134));
                          unint64_t v113 = v134;
                          sub_100047F64((void ***)&v113);
                          if (*((void *)&__dst + 1) != (void)__dst)
                          {
                            uint64_t v77 = *(NSObject **)(a1 + 40);
                            if (os_log_type_enabled(v77, OS_LOG_TYPE_DEFAULT))
                            {
                              if (*(char *)(v33 + 1071) >= 0) {
                                std::string::size_type v78 = v33 + 1048;
                              }
                              else {
                                std::string::size_type v78 = *(void *)(v33 + 1048);
                              }
                              *(_DWORD *)int64_t v134 = 136315138;
                              *(void *)&v134[4] = v78;
                              _os_log_impl((void *)&_mh_execute_header, v77, OS_LOG_TYPE_DEFAULT, "#I Set transfer-metadata for sourceIccid [%s]", v134, 0xCu);
                            }
                            sub_100B519F8((std::string *)((char *)&v129 + 8), (uint64_t)&__dst);
                          }
                          if ((_BYTE)v139 && SHIBYTE(v138) < 0) {
                            operator delete(*((void **)&v137 + 1));
                          }
                          *(void *)int64_t v134 = &__dst;
                          sub_100047F64((void ***)v134);
                        }
                      }
                      *(void *)int64_t v134 = 0;
                      unint64_t v113 = 0;
                      sub_100B3EA60(a1, v33 + 1048, 5, 0, (const void **)v134, (const void **)&v113);
                      sub_100057D78((const void **)&v113);
                      sub_1000558F4((const void **)v134);
                      *(unsigned char *)(a1 + 141) = 0;
                      std::string __dst = 0u;
                      uint64_t v137 = 0u;
                      std::string::size_type v141 = 0;
                      int v139 = 0u;
                      long long v140 = 0u;
                      __int16 v138 = 0u;
                      WORD1(__dst) = 257;
                      DWORD1(__dst) = 15;
                      BYTE8(__dst) = 1;
                      HIDWORD(__dst) = 1;
                      LOBYTE(v137) = 1;
                      uint64_t v79 = *(std::__shared_weak_count **)(a1 + 16);
                      if (!v79 || (v80 = *(void *)(a1 + 8), (std::string::size_type v81 = std::__shared_weak_count::lock(v79)) == 0)) {
                        sub_100088B9C();
                      }
                      uint64_t v82 = v81;
                      p_shared_weak_owners = &v81->__shared_weak_owners_;
                      atomic_fetch_add_explicit(&v81->__shared_weak_owners_, 1uLL, memory_order_relaxed);
                      sub_10004D2C8(v81);
                      *(unsigned char *)(a1 + 138) = 1;
                      sub_100B55694(a1, 1);
                      uint64_t v84 = v111;
                      v103[0] = _NSConcreteStackBlock;
                      v103[1] = (void *)1174405120;
                      xpc_object_t v104 = sub_100B58CB4;
                      char v105 = &unk_101A3E4B0;
                      uint64_t v106 = a1;
                      xpc_object_t v107 = v80;
                      xpc_object_t v108 = v82;
                      atomic_fetch_add_explicit(p_shared_weak_owners, 1uLL, memory_order_relaxed);
                      uint64_t v109 = v33 + 1048;
                      int v110 = v103;
                      (*(void (**)(uint64_t, uint64_t, long long *, uint8_t *, uint64_t, void ***))(*(void *)v84 + 192))(v84, 8, &__dst, buf, a1 + 24, &v110);
                      if (v108) {
                        std::__shared_weak_count::__release_weak(v108);
                      }
                      std::__shared_weak_count::__release_weak(v82);
                      if ((_BYTE)v141 && SHIBYTE(v140) < 0) {
                        operator delete(*((void **)&v139 + 1));
                      }
                      if ((_BYTE)v139 && SHIBYTE(v138) < 0) {
                        operator delete(*((void **)&v137 + 1));
                      }
                      sub_1001A03F4((uint64_t)buf);
                    }
                    else
                    {
                      unint64_t v85 = v56 + 528;
                      CFDictionaryRef v86 = *(NSObject **)(a1 + 40);
                      if (os_log_type_enabled(v86, OS_LOG_TYPE_DEFAULT))
                      {
                        sub_1008C1E00(v85);
                        int64_t v87 = SHIBYTE(v104) >= 0 ? v103 : (void **)v103[0];
                        *(_DWORD *)int64_t v134 = 136315138;
                        *(void *)&v134[4] = v87;
                        _os_log_impl((void *)&_mh_execute_header, v86, OS_LOG_TYPE_DEFAULT, "#I [resume] from pending TransferSIMResponse. source iccid : %s", v134, 0xCu);
                        if (SHIBYTE(v104) < 0) {
                          operator delete(v103[0]);
                        }
                      }
                      sub_10030E654(buf, v85);
                      sub_100B591A0(a1, v33 + 1048, (uint64_t)buf);
                      sub_10030D3C0((uint64_t)buf);
                    }
                  }
                  else
                  {
                    uint64_t v58 = *(NSObject **)(a1 + 40);
                    if (os_log_type_enabled(v58, OS_LOG_TYPE_ERROR))
                    {
                      *(_WORD *)long long buf = 0;
                      _os_log_error_impl((void *)&_mh_execute_header, v58, OS_LOG_TYPE_ERROR, "No entitlement controller available", buf, 2u);
                    }
                    v134[0] = 11;
                    *(void *)long long buf = 0;
                    LOBYTE(v113) = 56;
                    *(void *)&std::string __dst = 0;
                    LODWORD(v103[0]) = 70014;
                    BYTE4(v103[0]) = 1;
                    sub_100B3E598((void *)a1, (unsigned __int8 **)(v33 + 1048), v134, 0, (const void **)buf, (char *)&v113, (const void **)&__dst, 0, 1, (uint64_t)v103, (uint64_t *)(a1 + 328));
                    sub_100057D78((const void **)&__dst);
                    sub_1000558F4((const void **)buf);
                  }
                  if (v112) {
                    sub_10004D2C8(v112);
                  }
                  goto LABEL_183;
                }
              }
              else
              {
                unint64_t v54 = 0;
              }
              std::mutex::unlock(v48);
              uint64_t v53 = 0;
              uint64_t v55 = 1;
              goto LABEL_81;
            }
          }
        }
      }
    }
    else
    {
      uint64_t v23 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_ERROR, "No entitlement controller available", buf, 2u);
      }
      v134[0] = 11;
      sub_100B49888((CFStringRef *)buf, a1);
      LOBYTE(v111) = 56;
      *(void *)&std::string __dst = 0;
      LODWORD(v103[0]) = 70014;
      BYTE4(v103[0]) = 1;
      sub_100B3E598((void *)a1, (unsigned __int8 **)a2, v134, 0, (const void **)buf, (char *)&v111, (const void **)&__dst, 0, 1, (uint64_t)v103, &v102);
      sub_100057D78((const void **)&__dst);
      sub_1000558F4((const void **)buf);
    }
LABEL_183:
    if (*((void *)&v99 + 1)) {
      sub_10004D2C8(*((std::__shared_weak_count **)&v99 + 1));
    }
    if (SHIBYTE(v101) < 0) {
      operator delete(v100[0]);
    }
    return;
  }
  uint64_t v17 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
  {
    if (*(char *)(a2 + 23) >= 0) {
      char v18 = (unsigned __int8 *)a2;
    }
    else {
      char v18 = *(unsigned __int8 **)a2;
    }
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = v18;
    _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "source iccid [%s] already removed, skip subscribe push notification", buf, 0xCu);
  }
}

void sub_100B49488(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, std::__shared_weak_count *a15, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,std::__shared_weak_count *a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,std::__shared_weak_count *a32,void *__p,uint64_t a34,int a35,__int16 a36,char a37,char a38,uint64_t a39,void *a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,std::__shared_weak_count *a46,uint64_t a47,uint64_t a48,uint64_t a49,std::__shared_weak_count *a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,char a56)
{
  if (a50) {
    sub_10004D2C8(a50);
  }
  if (a32) {
    sub_10004D2C8(a32);
  }
  if (a38 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100B49710(uint64_t a1)
{
  if (*(char *)(a1 + 47) < 0) {
    operator delete(*(void **)(a1 + 24));
  }
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_100B49750(uint64_t a1, uint64_t a2)
{
  sub_100058DB0(&v11, "CellularPlanTransfer");
  std::string::push_back(&v11, 58);
  std::string v12 = v11;
  memset(&v11, 0, sizeof(v11));
  int v4 = *(char *)(a2 + 23);
  if (v4 >= 0) {
    uint64_t v5 = (const std::string::value_type *)a2;
  }
  else {
    uint64_t v5 = *(const std::string::value_type **)a2;
  }
  if (v4 >= 0) {
    std::string::size_type v6 = *(unsigned __int8 *)(a2 + 23);
  }
  else {
    std::string::size_type v6 = *(void *)(a2 + 8);
  }
  uint64_t v7 = std::string::append(&v12, v5, v6);
  uint64_t v9 = (void *)v7->__r_.__value_.__r.__words[0];
  unint64_t size = v7->__r_.__value_.__l.__size_;
  v13[0] = v7->__r_.__value_.__r.__words[2];
  *(_DWORD *)((char *)v13 + 3) = *(_DWORD *)((char *)&v7->__r_.__value_.__r.__words[2] + 3);
  int v10 = SHIBYTE(v7->__r_.__value_.__r.__words[2]);
  v7->__r_.__value_.__l.__size_ = 0;
  v7->__r_.__value_.__r.__words[2] = 0;
  v7->__r_.__value_.__r.__words[0] = 0;
  if (v10 < 0)
  {
    sub_10004FC84((unsigned char *)a1, v9, size);
    operator delete(v9);
  }
  else
  {
    *(void *)a1 = v9;
    *(void *)(a1 + 8) = size;
    *(_DWORD *)(a1 + 16) = v13[0];
    *(_DWORD *)(a1 + 19) = *(_DWORD *)((char *)v13 + 3);
    *(unsigned char *)(a1 + 23) = v10;
  }
  if (SHIBYTE(v12.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v12.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v11.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v11.__r_.__value_.__l.__data_);
  }
}

void sub_100B49844(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  operator delete(v21);
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  _Unwind_Resume(a1);
}

void sub_100B49888(CFStringRef *a1, uint64_t a2)
{
  if (*(unsigned char *)(a2 + 131) || (uint64_t v3 = *(void *)(a2 + 328), v3 == *(void *)(a2 + 312)) || !*(unsigned char *)(v3 + 216))
  {
    *a1 = 0;
  }
  else
  {
    __p[0] = 0;
    __p[1] = 0;
    uint64_t v6 = 0;
    (*(void (**)(void **__return_ptr))(**(void **)(a2 + 48) + 784))(__p);
    if (v6 >= 0) {
      int v4 = __p;
    }
    else {
      int v4 = (void **)__p[0];
    }
    *a1 = CFStringCreateWithCString(kCFAllocatorDefault, (const char *)v4, 0x8000100u);
    if (SHIBYTE(v6) < 0) {
      operator delete(__p[0]);
    }
  }
}

void sub_100B49968(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100B49984(uint64_t a1, uint64_t a2, uint64_t a3)
{
  void (***v15)(uint64_t *__return_ptr, void, void **);
  char v16;
  uint64_t v17;
  uint64_t v18;
  NSObject *v19;
  uint64_t v20;
  unsigned __int8 *v21;
  std::string *v22;
  int v23;
  uint64_t v24;
  std::__shared_weak_count *v25;
  uint64_t v26;
  std::__shared_weak_count *v27;
  std::__shared_weak_count *v28;
  uint64_t v29;
  uint64_t v30;
  NSObject *v31;
  const char *v32;
  NSObject *v33;
  uint32_t v34;
  unsigned __int8 *v36;
  void *__p[2];
  char v38;
  long long v39;
  void *v40[2];
  long long v41;
  void *v42[2];
  long long v43;
  uint64_t v44;
  std::string __str[2];
  long long v46;
  long long v47;
  long long v48;
  long long v49;
  long long v50;
  long long v51;
  uint64_t v52;
  uint64_t v53;
  std::__shared_weak_count *v54;
  void *v55[2];
  uint64_t v56;
  void v57[6];
  std::__shared_weak_count *v58;
  uint64_t v59;
  void v60[5];
  void (*v61[4])(void, void, void, void, void);
  long long buf;
  long long v63;
  void v64[20];
  long long v65;
  uint64_t v66;

  v55[0] = 0;
  v55[1] = 0;
  uint64_t v56 = 0;
  sub_100B49750((uint64_t)v55, a2);
  uint64_t v53 = 0;
  unint64_t v54 = 0;
  (***(void (****)(long long *__return_ptr))(a1 + 48))(&buf);
  ServiceMap = (std::mutex *)Registry::getServiceMap(v6, (Registry *)buf);
  uint64_t v8 = ServiceMap;
  if ((v9 & 0x8000000000000000) != 0)
  {
    int v10 = (unsigned __int8 *)(v9 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v11 = 5381;
    do
    {
      std::string::size_type v9 = v11;
      unsigned int v12 = *v10++;
      uint64_t v11 = (33 * v11) ^ v12;
    }
    while (v12);
  }
  std::mutex::lock(ServiceMap);
  __str[0].__r_.__value_.__r.__words[0] = v9;
  uint64_t v13 = sub_10004D37C(&v8[1].__m_.__sig, (unint64_t *)__str);
  if (v13)
  {
    uint64_t v15 = (void (***)(uint64_t *__return_ptr, void, void **))v13[3];
    unsigned int v14 = (std::__shared_weak_count *)v13[4];
    if (v14)
    {
      atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v8);
      atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v14);
      std::string::size_type v16 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v15 = 0;
  }
  std::mutex::unlock(v8);
  unsigned int v14 = 0;
  std::string::size_type v16 = 1;
LABEL_9:
  (**v15)(&v53, v15, v55);
  if ((v16 & 1) == 0) {
    sub_10004D2C8(v14);
  }
  if (*((void *)&buf + 1)) {
    sub_10004D2C8(*((std::__shared_weak_count **)&buf + 1));
  }
  if (!v53)
  {
    unint64_t v31 = *(NSObject **)(a1 + 40);
    if (!os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
    {
LABEL_52:
      int v30 = 0;
      goto LABEL_53;
    }
    LOWORD(buf) = 0;
    uint64_t v32 = "No entitlement controller available";
    long long v33 = v31;
    uint64_t v34 = 2;
LABEL_62:
    _os_log_error_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_ERROR, v32, (uint8_t *)&buf, v34);
    goto LABEL_52;
  }
  uint64_t v17 = *(void *)(a1 + 312);
  char v18 = sub_100B45F5C(*(void *)(a1 + 304), v17, (unsigned __int8 **)a2);
  uint64_t v19 = *(NSObject **)(a1 + 40);
  if (v17 == v18)
  {
    if (!os_log_type_enabled(*(os_log_t *)(a1 + 40), OS_LOG_TYPE_ERROR)) {
      goto LABEL_52;
    }
    if (*(char *)(a2 + 23) >= 0) {
      int v36 = (unsigned __int8 *)a2;
    }
    else {
      int v36 = *(unsigned __int8 **)a2;
    }
    LODWORD(buf) = 136315138;
    *(void *)((char *)&buf + 4) = v36;
    uint64_t v32 = "source iccid:%s already removed";
    long long v33 = v19;
    uint64_t v34 = 12;
    goto LABEL_62;
  }
  uint64_t v20 = v18;
  if (os_log_type_enabled(*(os_log_t *)(a1 + 40), OS_LOG_TYPE_DEFAULT))
  {
    if (*(char *)(a2 + 23) >= 0) {
      BOOL v21 = (unsigned __int8 *)a2;
    }
    else {
      BOOL v21 = *(unsigned __int8 **)a2;
    }
    LODWORD(buf) = 136315138;
    *(void *)((char *)&buf + 4) = v21;
    _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#I [req][ta] perform TransferAuthorization request from target side. source iccid : %s", (uint8_t *)&buf, 0xCu);
  }
  std::string::size_type v66 = 0;
  long long v65 = 0u;
  int64x2_t v63 = 0u;
  memset(v64, 0, sizeof(v64));
  long long buf = 0u;
  int v52 = 0;
  uint64_t v50 = 0u;
  unint64_t v51 = 0u;
  uint64_t v48 = 0u;
  int v49 = 0u;
  uint64_t v46 = 0u;
  uint64_t v47 = 0u;
  memset(__str, 0, sizeof(__str));
  sub_100B50FB0(a1, (uint64_t)__str, *(void *)(a1 + 328));
  uint64_t v22 = sub_1008C26DC((std::string *)&v64[1], __str);
  WORD2(v64[0]) = 257;
  uint64_t v23 = capabilities::ct::supportsSIMTransferWithSecureIntent((capabilities::ct *)v22);
  long long v24 = 2;
  if (v23) {
    long long v24 = 3;
  }
  *((void *)&v65 + 1) = v24;
  LOBYTE(v66) = 1;
  char v25 = *(std::__shared_weak_count **)(a1 + 16);
  if (!v25 || (uint64_t v26 = *(void *)(a1 + 8), (v27 = std::__shared_weak_count::lock(v25)) == 0)) {
    sub_100088B9C();
  }
  std::string v28 = v27;
  atomic_fetch_add_explicit(&v27->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v27);
  uint64_t v39 = 0u;
  *(_OWORD *)uint64_t v40 = 0u;
  *(_OWORD *)long long v42 = 0u;
  long long v43 = 0u;
  unint64_t v41 = 0u;
  WORD1(v39) = 257;
  DWORD1(v39) = 15;
  BYTE8(v39) = 1;
  HIDWORD(v39) = 1;
  LOBYTE(v40[0]) = 1;
  long long v44 = 0;
  sub_100B55694(a1, 1);
  sub_100058DB0(__p, "TransferAuthRequestTime");
  v61[1] = COERCE_VOID_FASTCALLvoidvoidvoidvoidvoid_(CFAbsoluteTimeGetCurrent());
  v61[0] = (void (*)(void, void, void, void, void))sub_100B71B34;
  sub_100B4A9E0((void *)a1, a2, (uint64_t)__p, v61);
  sub_100146540((uint64_t (**)(void, void, void, void, void))v61);
  if (v38 < 0) {
    operator delete(__p[0]);
  }
  uint64_t v29 = v53;
  v57[0] = _NSConcreteStackBlock;
  v57[1] = 1174405120;
  v57[2] = sub_100B55B50;
  v57[3] = &unk_101A3E480;
  v57[4] = a1;
  v57[5] = v26;
  uint64_t v58 = v28;
  atomic_fetch_add_explicit(&v28->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  int v59 = a2;
  sub_1000DFC90((uint64_t)v60, a3);
  v60[4] = v20;
  v61[0] = (void (*)(void, void, void, void, void))v57;
  (*(void (**)(uint64_t, uint64_t, long long *, long long *, uint64_t, void (**)(void, void, void, void, void)))(*(void *)v29 + 200))(v29, 8, &v39, &buf, a1 + 24, v61);
  sub_100060644(v60);
  if (v58) {
    std::__shared_weak_count::__release_weak(v58);
  }
  if ((_BYTE)v44 && SHIBYTE(v43) < 0) {
    operator delete(v42[1]);
  }
  if (LOBYTE(v42[0]) && SHIBYTE(v41) < 0) {
    operator delete(v40[1]);
  }
  std::__shared_weak_count::__release_weak(v28);
  if ((_BYTE)v52 && SHIBYTE(v51) < 0) {
    operator delete(*((void **)&v50 + 1));
  }
  if ((_BYTE)v50 && SHIBYTE(v49) < 0) {
    operator delete(*((void **)&v48 + 1));
  }
  if (BYTE8(v47) && SBYTE7(v47) < 0) {
    operator delete((void *)v46);
  }
  *(void *)&uint64_t v39 = &__str[1];
  sub_1001A010C((void ***)&v39);
  if (SHIBYTE(__str[0].__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__str[0].__r_.__value_.__l.__data_);
  }
  sub_1001A0540((uint64_t)&v64[1]);
  if (BYTE8(v63) && SBYTE7(v63) < 0) {
    operator delete((void *)buf);
  }
  int v30 = 1;
LABEL_53:
  if (v54) {
    sub_10004D2C8(v54);
  }
  if (SHIBYTE(v56) < 0) {
    operator delete(v55[0]);
  }
  return v30;
}

void sub_100B49F34(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,char a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,void *__p,uint64_t a48,int a49,__int16 a50,char a51,char a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,std::__shared_weak_count *a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  sub_100060644(v70);
  if (a59) {
    std::__shared_weak_count::__release_weak(a59);
  }
  sub_10016A3E8((uint64_t)&a13);
  std::__shared_weak_count::__release_weak(v71);
  sub_10019FD98((uint64_t)&a25);
  sub_100B56FB8((uint64_t)&a70);
  if (a46) {
    sub_10004D2C8((std::__shared_weak_count *)a46);
  }
  if (a52 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_100B4A020(uint64_t a1)
{
  uint64_t v1 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)uint64_t v2 = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_ERROR, "unexpected call", v2, 2u);
  }
}

void sub_100B4A084(uint64_t a1, uint64_t *a2)
{
  if ((uint64_t *)(a1 + 600) != a2) {
    sub_1003DB294(a1 + 600, *a2, a2[1], 0x2E8BA2E8BA2E8BA3 * ((a2[1] - *a2) >> 3));
  }
  uint64_t v3 = *(void *)(a1 + 304);
  uint64_t v4 = *(void *)(a1 + 312);
  if (v3 == v4)
  {
    unsigned int v12 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v20 = 0;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I No plan awaiting transfer", v20, 2u);
    }
  }
  else
  {
    do
    {
      bzero(v20, 0x5F0uLL);
      sub_100B617E8((uint64_t)v20, v3);
      if (sIsProfileInstalled())
      {
        uint64_t v5 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
        {
          if (v22 >= 0) {
            p_src = &__src;
          }
          else {
            p_src = (long long *)__src;
          }
          if (v24 >= 0) {
            uint64_t v7 = &v23;
          }
          else {
            uint64_t v7 = v23;
          }
          *(_DWORD *)long long buf = 136315394;
          uint64_t v17 = p_src;
          __int16 v18 = 2080;
          uint64_t v19 = v7;
          _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I profile [%s -> %s] already installed, removing it from cached list", buf, 0x16u);
        }
        *(unsigned char *)(a1 + 137) = 0;
        if (SHIBYTE(v22) < 0)
        {
          sub_10004FC84(__p, (void *)__src, *((unint64_t *)&__src + 1));
        }
        else
        {
          *(_OWORD *)std::string __p = __src;
          uint64_t v15 = v22;
        }
        sub_100B4A3B8(a1, (uint64_t)__p);
        if (SHIBYTE(v15) < 0) {
          operator delete(__p[0]);
        }
      }
      sub_100B615AC((uint64_t)v20);
      v3 += 1520;
    }
    while (v3 != v4);
    if (*(void *)(a1 + 304) == *(void *)(a1 + 312))
    {
      uint64_t v8 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t v20 = 0;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I All transfer plans handled", v20, 2u);
      }
      std::string::size_type v9 = *(std::__shared_weak_count **)(a1 + 72);
      if (v9)
      {
        int v10 = std::__shared_weak_count::lock(v9);
        if (v10)
        {
          uint64_t v11 = *(void *)(a1 + 64);
          if (v11)
          {
            (*(void (**)(uint64_t))(*(void *)v11 + 80))(v11);
LABEL_32:
            sub_10004D2C8(v10);
            return;
          }
        }
      }
      else
      {
        int v10 = 0;
      }
      uint64_t v13 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)uint64_t v20 = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "invalid delegate - allTransferPlansHandled", v20, 2u);
      }
      if (v10) {
        goto LABEL_32;
      }
    }
  }
}

void sub_100B4A370(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,char a22)
{
  sub_10004D2C8(v22);
  _Unwind_Resume(a1);
}

void sub_100B4A3B8(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 304);
  uint64_t v4 = *(void *)(a1 + 312);
  if (v3 != v4)
  {
    uint64_t v6 = sub_100B45F5C(v3, *(void *)(a1 + 312), (unsigned __int8 **)a2);
    if (v4 != v6)
    {
      uint64_t v7 = v6;
      sub_100991BC4(v6);
      __p[0] = 0;
      __p[1] = 0;
      uint64_t v38 = 0;
      sub_100B49750((uint64_t)__p, a2);
      (***(void (****)(Registry **__return_ptr))(a1 + 48))(&v35);
      ServiceMap = (std::mutex *)Registry::getServiceMap(v8, v35);
      int v10 = ServiceMap;
      if ((v11 & 0x8000000000000000) != 0)
      {
        unsigned int v12 = (unsigned __int8 *)(v11 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v13 = 5381;
        do
        {
          unint64_t v11 = v13;
          unsigned int v14 = *v12++;
          uint64_t v13 = (33 * v13) ^ v14;
        }
        while (v14);
      }
      std::mutex::lock(ServiceMap);
      unint64_t v39 = v11;
      uint64_t v15 = sub_10004D37C(&v10[1].__m_.__sig, &v39);
      if (v15)
      {
        uint64_t v17 = v15[3];
        std::string::size_type v16 = (std::__shared_weak_count *)v15[4];
        if (v16)
        {
          atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v10);
          atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v16);
          char v18 = 0;
          goto LABEL_11;
        }
      }
      else
      {
        uint64_t v17 = 0;
      }
      std::mutex::unlock(v10);
      std::string::size_type v16 = 0;
      char v18 = 1;
LABEL_11:
      (*(void (**)(uint64_t, void **))(*(void *)v17 + 88))(v17, __p);
      if ((v18 & 1) == 0) {
        sub_10004D2C8(v16);
      }
      if (v36) {
        sub_10004D2C8(v36);
      }
      uint64_t v19 = *(void *)(a1 + 312);
      uint64_t v20 = *(void *)(a1 + 328);
      if (v20 == v19)
      {
        uint64_t v29 = sub_100B62A44(v7 + 1520, *(void *)(a1 + 312), v7);
        for (uint64_t i = *(void *)(a1 + 312); i != v29; uint64_t i = sub_100B615AC(i - 1520))
          ;
        *(void *)(a1 + 312) = v29;
        goto LABEL_45;
      }
      BOOL v21 = (unsigned __int8 **)(v20 + 1048);
      uint64_t v22 = *(unsigned __int8 *)(v20 + 1071);
      size_t v23 = *(void *)(v20 + 1056);
      if ((v22 & 0x80u) == 0) {
        uint64_t v24 = *(unsigned __int8 *)(v20 + 1071);
      }
      else {
        uint64_t v24 = *(void *)(v20 + 1056);
      }
      uint64_t v25 = *(unsigned __int8 *)(a2 + 23);
      int v26 = (char)v25;
      if ((v25 & 0x80u) != 0) {
        uint64_t v25 = *(void *)(a2 + 8);
      }
      if (v24 != v25) {
        goto LABEL_36;
      }
      if (v26 >= 0) {
        unint64_t v27 = (unsigned __int8 *)a2;
      }
      else {
        unint64_t v27 = *(unsigned __int8 **)a2;
      }
      if ((v22 & 0x80) != 0)
      {
        if (memcmp(*v21, v27, v23))
        {
LABEL_36:
          uint64_t v31 = sub_100B62A44(v7 + 1520, v19, v7);
          for (uint64_t j = *(void *)(a1 + 312); j != v31; uint64_t j = sub_100B615AC(j - 1520))
            ;
          *(void *)(a1 + 312) = v31;
          uint64_t v7 = sub_100B45F5C(*(void *)(a1 + 304), v31, v21);
          goto LABEL_44;
        }
      }
      else if (v22)
      {
        std::string v28 = v21;
        while (*(unsigned __int8 *)v28 == *v27)
        {
          std::string v28 = (unsigned __int8 **)((char *)v28 + 1);
          ++v27;
          if (!--v22) {
            goto LABEL_40;
          }
        }
        goto LABEL_36;
      }
LABEL_40:
      uint64_t v33 = sub_100B62A44(v7 + 1520, v19, v7);
      for (uint64_t k = *(void *)(a1 + 312); k != v33; uint64_t k = sub_100B615AC(k - 1520))
        ;
      *(void *)(a1 + 312) = v33;
LABEL_44:
      *(void *)(a1 + 328) = v7;
LABEL_45:
      if (SHIBYTE(v38) < 0) {
        operator delete(__p[0]);
      }
    }
  }
}

void sub_100B4A6A4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100B4A6F8(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = a1 + 624;
  if ((uint64_t *)v2 != a2) {
    sub_1003DB990(v2, *a2, a2[1], 0xCF3CF3CF3CF3CF3DLL * ((a2[1] - *a2) >> 3));
  }
}

uint64_t sub_100B4A730(uint64_t result, char a2)
{
  *(unsigned char *)(result + 131) = a2;
  return result;
}

void sub_100B4A738(void *a1, const void **a2)
{
  uint64_t v2 = *((unsigned __int8 *)a2 + 23);
  size_t v3 = (size_t)a2[1];
  if ((v2 & 0x80u) == 0) {
    uint64_t v4 = (const void *)*((unsigned __int8 *)a2 + 23);
  }
  else {
    uint64_t v4 = a2[1];
  }
  if (v4)
  {
    uint64_t v7 = a1[39];
    uint64_t v8 = a1[41];
    if (v8 == v7 || a1[38] == v7)
    {
      unsigned int v14 = a1[5];
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
      {
        if ((v2 & 0x80u) == 0) {
          uint64_t v15 = a2;
        }
        else {
          uint64_t v15 = (void *)*a2;
        }
        *(_DWORD *)long long buf = 136315138;
        *(void *)&uint8_t buf[4] = v15;
        _os_log_error_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "no ongoing transfer plan. altSmdp: %s", buf, 0xCu);
      }
    }
    else
    {
      if (*(unsigned char *)(v8 + 1408))
      {
        std::string::size_type v9 = (const void *)*(unsigned __int8 *)(v8 + 1407);
        int v10 = (char)v9;
        if ((char)v9 < 0) {
          std::string::size_type v9 = *(const void **)(v8 + 1392);
        }
        if (v4 == v9)
        {
          if (v10 >= 0) {
            unint64_t v11 = (unsigned __int8 *)(v8 + 1384);
          }
          else {
            unint64_t v11 = *(unsigned __int8 **)(v8 + 1384);
          }
          if ((v2 & 0x80) != 0)
          {
            if (!memcmp(*a2, v11, v3)) {
              return;
            }
          }
          else
          {
            if (!v2) {
              return;
            }
            unsigned int v12 = a2;
            uint64_t v13 = v2;
            while (*(unsigned __int8 *)v12 == *v11)
            {
              unsigned int v12 = (const void **)((char *)v12 + 1);
              ++v11;
              if (!--v13) {
                return;
              }
            }
          }
        }
      }
      std::string::size_type v16 = a1[5];
      if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
      {
        if ((v2 & 0x80u) == 0) {
          uint64_t v17 = a2;
        }
        else {
          uint64_t v17 = (void *)*a2;
        }
        uint64_t v18 = v8 + 1048;
        if (*(char *)(v8 + 1071) < 0) {
          uint64_t v18 = *(void *)(v8 + 1048);
        }
        *(_DWORD *)long long buf = 136315394;
        *(void *)&uint8_t buf[4] = v17;
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&unsigned char buf[14] = v18;
        _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I update alt smdp with websheet result. smdp: %s, iccid: [%s]", buf, 0x16u);
      }
      sub_100093B44((std::string *)(v8 + 1384), (const std::string *)a2);
      sub_100058DB0(__p, "AltSmdpFqdn");
      *(void *)long long buf = 0;
      *(void *)&uint8_t buf[8] = 0;
      if (*((char *)a2 + 23) < 0)
      {
        sub_10004FC84(&buf[8], (void *)*a2, (unint64_t)a2[1]);
      }
      else
      {
        *(_OWORD *)&uint8_t buf[8] = *(_OWORD *)a2;
        uint64_t v22 = a2[2];
      }
      *(void *)long long buf = sub_100333A04;
      sub_100B4A9E0(a1, v8 + 1048, (uint64_t)__p, (void (**)(void, void, void, void, void))buf);
      sub_100146540((uint64_t (**)(void, void, void, void, void))buf);
      if (v20 < 0) {
        operator delete(__p[0]);
      }
    }
  }
}

void sub_100B4A9AC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100B4A9E0(void *a1, uint64_t a2, uint64_t a3, void (**a4)(void, void, void, void, void))
{
  uint64_t v5 = (std::__shared_weak_count *)a1[11];
  if (v5)
  {
    std::string::size_type v9 = std::__shared_weak_count::lock(v5);
    if (v9)
    {
      uint64_t v10 = a1[10];
      if (v10)
      {
        if (*(char *)(a3 + 23) < 0)
        {
          sub_10004FC84(__p, *(void **)a3, *(void *)(a3 + 8));
        }
        else
        {
          *(_OWORD *)std::string __p = *(_OWORD *)a3;
          uint64_t v17 = *(void *)(a3 + 16);
        }
        v18[0] = 0;
        v18[1] = 0;
        if (*a4) {
          (*a4)(1, a4, v18, 0, 0);
        }
        unsigned int v12 = 0;
        uint64_t v13 = 0;
        unsigned int v14 = 0;
        v15[0] = (void **)&v12;
        v15[1] = 0;
        unsigned int v12 = (char *)operator new(0x38uLL);
        uint64_t v13 = (uint64_t)v12;
        unsigned int v14 = v12 + 56;
        uint64_t v13 = sub_100333B38((uint64_t)&v14, (uint64_t)__p, (uint64_t)&v19, (uint64_t)v12);
        (*(void (**)(uint64_t, uint64_t, char **))(*(void *)v10 + 120))(v10, a2, &v12);
        v15[0] = (void **)&v12;
        sub_100333C9C(v15);
        sub_100146540(v18);
        if (SHIBYTE(v17) < 0) {
          operator delete(__p[0]);
        }
        goto LABEL_16;
      }
    }
  }
  else
  {
    std::string::size_type v9 = 0;
  }
  unint64_t v11 = a1[5];
  if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
  {
    LOWORD(__p[0]) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "invalid pendingTransferHandler to update pending plan state", (uint8_t *)__p, 2u);
    if (!v9) {
      return;
    }
    goto LABEL_16;
  }
  if (v9) {
LABEL_16:
  }
    sub_10004D2C8(v9);
}

void sub_100B4ABB4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  sub_10004D2C8(v20);
  _Unwind_Resume(a1);
}

void sub_100B4AC10(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t v3 = *(void *)(a1 + 328);
  if (v3 == *(void *)(a1 + 312))
  {
    uint64_t v5 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t v6 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "No elements in the map", v6, 2u);
    }
    goto LABEL_8;
  }
  if (!*(unsigned char *)(v3 + 216))
  {
LABEL_8:
    *a2 = 0;
    a2[1] = 0;
    a2[2] = 0;
    return;
  }
  uint64_t v4 = *(void (**)(void))(**(void **)(a1 + 48) + 776);

  v4();
}

void sub_100B4ACFC(uint64_t a1@<X0>, void **a2@<X1>, const std::string *a3@<X2>, int a4@<W3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  uint64_t v12 = *(unsigned __int8 *)(a5 + 23);
  if ((v12 & 0x80u) != 0) {
    uint64_t v12 = *(void *)(a5 + 8);
  }
  if (v12)
  {
    sub_100B4A738((void *)a1, (const void **)a5);
    goto LABEL_20;
  }
  uint64_t v13 = *(void *)(a1 + 312);
  uint64_t v14 = *(void *)(a1 + 328);
  if (v14 == v13 || *(void *)(a1 + 304) == v13)
  {
    std::string::size_type v16 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "no ongoing transfer plan.", buf, 2u);
    }
    memset(buf, 0, sizeof(buf));
    goto LABEL_17;
  }
  if (!*(unsigned char *)(v14 + 1408)) {
    goto LABEL_16;
  }
  uint64_t v15 = (void **)(v14 + 1384);
  if (*(char *)(v14 + 1407) < 0)
  {
    unint64_t v17 = *(void *)(v14 + 1392);
    if (v17)
    {
      sub_10004FC84(buf, *v15, v17);
      goto LABEL_17;
    }
LABEL_16:
    sub_100B4AC10(a1, buf);
    goto LABEL_17;
  }
  if (!*(unsigned char *)(v14 + 1407)) {
    goto LABEL_16;
  }
  *(_OWORD *)long long buf = *(_OWORD *)v15;
  *(void *)&uint8_t buf[16] = *(void *)(v14 + 1400);
LABEL_17:
  if (*(char *)(a5 + 23) < 0) {
    operator delete(*(void **)a5);
  }
  *(_OWORD *)a5 = *(_OWORD *)buf;
  *(void *)(a5 + 16) = *(void *)&buf[16];
LABEL_20:
  uint64_t v18 = *(void *)(a1 + 312);
  uint64_t v19 = *(void *)(a1 + 328);
  if (v19 != v18 && *(void *)(a1 + 304) != v18)
  {
    unsigned __int8 v75 = 0;
    __n[1] = 0;
    uint64_t v74 = 0;
    __n[0] = 0;
    char v20 = (void *)*((unsigned __int8 *)a2 + 23);
    if ((char)v20 < 0) {
      char v20 = a2[1];
    }
    BOOL v21 = (void **)(v19 + 1048);
    if (v20) {
      BOOL v21 = a2;
    }
    if (*((char *)v21 + 23) < 0)
    {
      sub_10004FC84(__n, *v21, (unint64_t)v21[1]);
    }
    else
    {
      *(_OWORD *)__CFIndex n = *(_OWORD *)v21;
      uint64_t v74 = (uint64_t)v21[2];
    }
    size_t v23 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
    {
      if ((a4 - 1) > 3u) {
        uint64_t v24 = "kUnknown";
      }
      else {
        uint64_t v24 = off_101A3FD70[(char)(a4 - 1)];
      }
      uint64_t v25 = (const std::string *)a3->__r_.__value_.__r.__words[0];
      if ((a3->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        uint64_t v25 = a3;
      }
      int v26 = __n;
      if (v74 < 0) {
        int v26 = (size_t *)__n[0];
      }
      *(_DWORD *)long long buf = 136315650;
      *(void *)&uint8_t buf[4] = v26;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&unsigned char buf[14] = v25;
      *(_WORD *)&unsigned char buf[22] = 2080;
      std::string::size_type v78 = v24;
      _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "#I websheet result for iccid: [%s]. target iccid: [%s], state: %s", buf, 0x20u);
    }
    sub_100B4B494((void *)a1, (uint64_t)__n, a3);
    if (a4 == 1)
    {
      uint64_t v27 = 7;
      unsigned __int8 v75 = 7;
    }
    else if (a4 == 4)
    {
      unsigned __int8 v75 = 9;
      v76[3] = 0;
      sub_100B4B5F8((void *)a1, 4, (uint64_t)v76);
      sub_100313668(v76);
      uint64_t v27 = 9;
    }
    else
    {
      uint64_t v27 = 8;
      unsigned __int8 v75 = 8;
      *(unsigned char *)(a1 + 137) = 1;
    }
    unsigned int v71 = 0;
    std::string::value_type v72 = 0;
    sub_100B3EA60(a1, (uint64_t)__n, v27, 0, &v72, &v71);
    sub_100057D78(&v71);
    sub_1000558F4(&v72);
    uint64_t v28 = *(void *)(a1 + 856);
    uint64_t v29 = *(void *)(a1 + 864);
    if (SHIBYTE(v74) < 0)
    {
      sub_10004FC84(__p, (void *)__n[0], __n[1]);
    }
    else
    {
      *(_OWORD *)std::string __p = *(_OWORD *)__n;
      uint64_t v70 = v74;
    }
    uint64_t v30 = HIBYTE(v70);
    if (v28 != v29)
    {
      uint64_t v32 = __p[0];
      uint64_t v31 = __p[1];
      if (v70 >= 0) {
        uint64_t v33 = (void *)HIBYTE(v70);
      }
      else {
        uint64_t v33 = __p[1];
      }
      do
      {
        uint64_t v34 = (void *)*(unsigned __int8 *)(v28 + 455);
        int v35 = (char)v34;
        if ((char)v34 < 0) {
          uint64_t v34 = *(void **)(v28 + 440);
        }
        if (v33 == v34)
        {
          if (v35 >= 0) {
            int v36 = (unsigned __int8 *)(v28 + 432);
          }
          else {
            int v36 = *(unsigned __int8 **)(v28 + 432);
          }
          if ((v30 & 0x80) != 0)
          {
            if (!memcmp(v32, v36, (size_t)v31))
            {
              char v39 = 1;
              goto LABEL_71;
            }
          }
          else
          {
            if (!v30)
            {
              char v39 = 1;
              goto LABEL_72;
            }
            uint64_t v37 = __p;
            uint64_t v38 = v30;
            while (*(unsigned __int8 *)v37 == *v36)
            {
              uint64_t v37 = (void **)((char *)v37 + 1);
              ++v36;
              if (!--v38)
              {
                char v39 = 1;
                if ((v30 & 0x80) == 0) {
                  goto LABEL_72;
                }
                goto LABEL_71;
              }
            }
          }
        }
        v28 += 1248;
      }
      while (v28 != v29);
    }
    char v39 = 0;
    if ((v30 & 0x80) != 0) {
LABEL_71:
    }
      operator delete(__p[0]);
LABEL_72:
    uint64_t v40 = *(void *)(a1 + 312);
    uint64_t v41 = sub_100B45F5C(*(void *)(a1 + 304), v40, (unsigned __int8 **)__n);
    if (v40 == v41) {
      goto LABEL_115;
    }
    uint64_t v42 = v41;
    buf[0] = 2;
    sub_100B4B75C(a1, buf, &v75, v41, v39, *(unsigned __int8 *)(v41 + 1284));
    if (a4 != 4 && a4 != 1) {
      goto LABEL_115;
    }
    sub_100058DB0(v67, "TransferSimServiceResponse");
    *(void *)long long buf = 0;
    *(void *)&uint8_t buf[8] = 0;
    long long v43 = operator new(0x98uLL);
    sub_10030DBE4((uint64_t)v43, v42 + 1296);
    *(void *)long long buf = sub_100B6D118;
    *(void *)&uint8_t buf[8] = v43;
    sub_100B4A9E0((void *)a1, (uint64_t)__n, (uint64_t)v67, (void (**)(void, void, void, void, void))buf);
    sub_100146540((uint64_t (**)(void, void, void, void, void))buf);
    if (v68 < 0) {
      operator delete(v67[0]);
    }
    uint64_t v44 = *(void *)(a1 + 328);
    unint64_t v45 = __n[1];
    if (v74 >= 0) {
      size_t v46 = HIBYTE(v74);
    }
    else {
      size_t v46 = __n[1];
    }
    uint64_t v47 = *(unsigned __int8 *)(v44 + 1071);
    int v48 = (char)v47;
    if ((v47 & 0x80u) != 0) {
      uint64_t v47 = *(void *)(v44 + 1056);
    }
    if (v46 == v47)
    {
      int v49 = (unsigned __int8 *)(v44 + 1048);
      uint64_t v50 = *(unsigned __int8 **)(v44 + 1048);
      if (v48 >= 0) {
        unint64_t v51 = v49;
      }
      else {
        unint64_t v51 = v50;
      }
      if (v74 < 0)
      {
        long long v61 = (void *)__n[0];
        BOOL v60 = memcmp((const void *)__n[0], v51, __n[1]) == 0;
        goto LABEL_107;
      }
      if (!HIBYTE(v74))
      {
        BOOL v60 = 1;
        goto LABEL_109;
      }
      uint64_t v52 = HIBYTE(v74) - 1;
      uint64_t v53 = __n;
      do
      {
        int v55 = *(unsigned __int8 *)v53;
        uint64_t v53 = (size_t *)((char *)v53 + 1);
        int v54 = v55;
        int v57 = *v51++;
        int v56 = v57;
        BOOL v59 = v52-- != 0;
        BOOL v60 = v54 == v56;
      }
      while (v54 == v56 && v59);
    }
    else
    {
      BOOL v60 = 0;
    }
    if (v74 < 0)
    {
      long long v61 = (void *)__n[0];
LABEL_107:
      sub_10004FC84(v65, v61, v45);
      goto LABEL_110;
    }
LABEL_109:
    *(_OWORD *)long long v65 = *(_OWORD *)__n;
    uint64_t v66 = v74;
LABEL_110:
    sub_100B4A3B8(a1, (uint64_t)v65);
    if (SHIBYTE(v66) < 0)
    {
      operator delete(v65[0]);
      if (!v60)
      {
LABEL_115:
        if (*(char *)(a5 + 23) < 0)
        {
          sub_10004FC84((unsigned char *)a6, *(void **)a5, *(void *)(a5 + 8));
        }
        else
        {
          *(_OWORD *)a6 = *(_OWORD *)a5;
          *(void *)(a6 + 16) = *(void *)(a5 + 16);
        }
        if (SHIBYTE(v74) < 0) {
          operator delete((void *)__n[0]);
        }
        return;
      }
    }
    else if (!v60)
    {
      goto LABEL_115;
    }
    sub_100B3F548(a1);
    goto LABEL_115;
  }
  uint64_t v22 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
  {
    if (*((char *)a2 + 23) >= 0) {
      long long v62 = (uint64_t *)a2;
    }
    else {
      long long v62 = (uint64_t *)*a2;
    }
    if ((a3->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      int64x2_t v63 = a3;
    }
    else {
      int64x2_t v63 = (const std::string *)a3->__r_.__value_.__r.__words[0];
    }
    if ((a4 - 1) > 3u) {
      unint64_t v64 = "kUnknown";
    }
    else {
      unint64_t v64 = off_101A3FD70[(char)(a4 - 1)];
    }
    *(_DWORD *)long long buf = 136315650;
    *(void *)&uint8_t buf[4] = v62;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&unsigned char buf[14] = v63;
    *(_WORD *)&unsigned char buf[22] = 2080;
    std::string::size_type v78 = v64;
    _os_log_error_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_ERROR, "websheet callback. source iccid: %s, target iccid: %s, state: %s. no ongoing transfer plan.", buf, 0x20u);
  }
  if (*(char *)(a5 + 23) < 0)
  {
    sub_10004FC84((unsigned char *)a6, *(void **)a5, *(void *)(a5 + 8));
  }
  else
  {
    *(_OWORD *)a6 = *(_OWORD *)a5;
    *(void *)(a6 + 16) = *(void *)(a5 + 16);
  }
}

void sub_100B4B3E8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,char a25,int a26,__int16 a27,char a28,char a29,void *__p,uint64_t a31,int a32,__int16 a33,char a34,char a35,uint64_t a36,uint64_t a37)
{
  if (a35 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_100B4B494(void *a1, uint64_t a2, const std::string *a3)
{
  uint64_t v4 = a1[38];
  uint64_t v5 = a1[39];
  if (v4 == v5)
  {
    uint64_t v10 = a1[5];
    if (!os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
      return;
    }
    LOWORD(v16) = 0;
    unint64_t v11 = "no transfer plan data available";
    uint64_t v12 = v10;
    uint32_t v13 = 2;
    goto LABEL_14;
  }
  uint64_t v8 = sub_100B45F5C(v4, a1[39], (unsigned __int8 **)a2);
  if (v5 == v8)
  {
    uint64_t v14 = a1[5];
    if (!os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)) {
      return;
    }
    if (*(char *)(a2 + 23) >= 0) {
      uint64_t v15 = (unsigned __int8 *)a2;
    }
    else {
      uint64_t v15 = *(unsigned __int8 **)a2;
    }
    int v16 = 136315138;
    unint64_t v17 = v15;
    unint64_t v11 = "no transfer plan data for iccid : %s";
    uint64_t v12 = v14;
    uint32_t v13 = 12;
LABEL_14:
    _os_log_error_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, v11, (uint8_t *)&v16, v13);
    return;
  }
  std::string::size_type v9 = (std::string *)(v8 + 1208);

  std::string::operator=(v9, a3);
}

void sub_100B4B5F8(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = (std::__shared_weak_count *)a1[9];
  if (v5)
  {
    uint64_t v7 = std::__shared_weak_count::lock(v5);
    if (v7)
    {
      uint64_t v8 = a1[8];
      if (v8)
      {
        sub_10031ECD8((uint64_t)v11, a3);
        (*(void (**)(uint64_t, uint64_t, void *))(*(void *)v8 + 64))(v8, a2, v11);
        sub_100313668(v11);
LABEL_11:
        sub_10004D2C8(v7);
        return;
      }
    }
  }
  else
  {
    uint64_t v7 = 0;
  }
  std::string::size_type v9 = a1[5];
  if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)uint64_t v10 = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "Invalid delegate to update pending plan state", v10, 2u);
  }
  if (*(void *)(a3 + 24)) {
    sub_10024924C(a3, 4);
  }
  if (v7) {
    goto LABEL_11;
  }
}

void sub_100B4B72C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100313668((uint64_t *)va);
  sub_10004D2C8(v2);
  _Unwind_Resume(a1);
}

void sub_100B4B75C(uint64_t a1, unsigned char *a2, unsigned __int8 *a3, uint64_t a4, char a5, int a6)
{
  if (*a2)
  {
    uint64_t v7 = *(std::__shared_weak_count **)(a1 + 72);
    if (v7)
    {
      uint32_t v13 = std::__shared_weak_count::lock(v7);
      if (v13)
      {
        uint64_t v14 = *(void *)(a1 + 64);
        if (v14)
        {
          uint64_t v15 = *(std::__shared_weak_count **)(a1 + 88);
          if (v15)
          {
            int v16 = std::__shared_weak_count::lock(v15);
            if (v16)
            {
              uint64_t v17 = *(void *)(a1 + 80);
              if (v17)
              {
                bzero(buf, 0x4E8uLL);
                uint64_t v74 = v16;
                (*(void (**)(uint8_t *__return_ptr, uint64_t, uint64_t))(*(void *)v17 + 168))(buf, v17, a4 + 1048);
                if (*(unsigned char *)(a4 + 888)) {
                  BOOL v18 = *(unsigned char *)(a4 + 657) == 0;
                }
                else {
                  BOOL v18 = 1;
                }
                int v19 = !v18;
                __int16 v72 = *(unsigned __int8 *)(a4 + 656);
                long long __p = 0uLL;
                uint64_t v101 = 0;
                if (*(char *)(a4 + 1167) < 0)
                {
                  sub_10004FC84(&__p, *(void **)(a4 + 1144), *(void *)(a4 + 1152));
                }
                else
                {
                  long long __p = *(_OWORD *)(a4 + 1144);
                  uint64_t v101 = *(void *)(a4 + 1160);
                }
                uint64_t v22 = HIBYTE(v101);
                if (v101 < 0) {
                  uint64_t v22 = *((void *)&__p + 1);
                }
                if (!v22 && *(unsigned char *)(a4 + 216))
                {
                  (*(void (**)(long long *__return_ptr))(**(void **)(a1 + 48) + 160))(&__dst);
                  if (SHIBYTE(v101) < 0) {
                    operator delete((void *)__p);
                  }
                  long long __p = __dst;
                  uint64_t v101 = v87;
                }
                if (*(unsigned char *)(a1 + 131)) {
                  char v23 = 1;
                }
                else {
                  char v23 = 2;
                }
                char v73 = v23;
                long long v24 = 0uLL;
                long long v98 = 0u;
                long long v99 = 0u;
                int v71 = v19;
                if (*(unsigned char *)(a4 + 1465))
                {
                  int v25 = *(unsigned __int8 *)(a4 + 1464);
                  if ((v25 - 1) > 0xA) {
                    int v26 = "kCPMetricsTransferFailureInternal";
                  }
                  else {
                    int v26 = off_101A3FD90[(char)(v25 - 1)];
                  }
                  *(void *)&long long __dst = v26;
                  sub_1000791C0((std::string *)&v98, (char **)&__dst);
                  char v27 = 1;
                  long long v24 = 0uLL;
                }
                else
                {
                  int v25 = 0;
                  char v27 = 0;
                }
                uint64_t v28 = (int *)(a4 + 1468);
                long long v96 = v24;
                long long v97 = v24;
                if (*(unsigned char *)(a4 + 1472) && (*v28 - 70000) <= 0x48)
                {
                  char v69 = v27;
                  *(void *)&long long __dst = sub_1008A2254(*v28);
                  sub_1000791C0((std::string *)&v96, (char **)&__dst);
                  char v27 = v69;
                }
                long long v94 = 0u;
                long long v95 = 0u;
                long long v92 = 0u;
                long long v93 = 0u;
                long long v90 = 0u;
                long long v91 = 0u;
                long long __val = 0u;
                long long v89 = 0u;
                long long __dst = 0u;
                long long v87 = 0u;
                if (SHIBYTE(v101) < 0)
                {
                  uint64_t v70 = v14;
                  int v29 = v25;
                  char v30 = v27;
                  sub_10004FC84(&__dst, (void *)__p, *((unint64_t *)&__p + 1));
                  char v27 = v30;
                  int v25 = v29;
                  uint64_t v14 = v70;
                }
                else
                {
                  long long __dst = __p;
                  *(void *)&long long v87 = v101;
                }
                BYTE8(v87) = *a2;
                BYTE9(v87) = v73;
                int v31 = *a3;
                BYTE10(v87) = v31 == 8;
                BYTE11(v87) = v31 == 9;
                BYTE12(v87) = *(unsigned char *)(a4 + 1463);
                BYTE13(v87) = a5;
                BYTE14(v87) = *(unsigned char *)(a1 + 129);
                if (*(unsigned char *)(a4 + 216)) {
                  BOOL v32 = *(unsigned char *)(a4 + 89) == 0;
                }
                else {
                  BOOL v32 = 1;
                }
                char v33 = !v32;
                HIBYTE(v87) = v33;
                LODWORD(__val) = v25;
                BYTE4(__val) = v27;
                int v34 = *v28;
                BYTE12(__val) = *(unsigned char *)(a4 + 1472);
                DWORD2(__val) = v34;
                sub_1000593FC((uint64_t)&v89, (long long *)(a4 + 1480));
                __int16 v35 = v72 | 0x100;
                if (!v71) {
                  __int16 v35 = 0;
                }
                LOWORD(v91) = v35;
                if (*(unsigned char *)(a1 + 129))
                {
                  LOBYTE(v36) = 4;
                }
                else
                {
                  unsigned int v37 = *(unsigned __int8 *)(a1 + 128);
                  if (v37 > 4) {
                    LOBYTE(v36) = 0;
                  }
                  else {
                    unint64_t v36 = 0x503020100uLL >> (8 * v37);
                  }
                }
                BYTE2(v91) = v36;
                int v38 = (*(uint64_t (**)(uint64_t))(*(void *)v14 + 208))(v14);
                int v39 = *(unsigned __int8 *)(a1 + 592);
                if (v39 == 2)
                {
                  if (v38) {
                    LOBYTE(v39) = 3;
                  }
                }
                else if (*(unsigned char *)(a1 + 592))
                {
                  LOBYTE(v39) = 1;
                }
                else if (v38)
                {
                  LOBYTE(v39) = 3;
                }
                else
                {
                  LOBYTE(v39) = 0;
                }
                BYTE3(v91) = v39;
                BYTE4(v91) = 1;
                if (v105) {
                  BOOL v40 = buf[18] == 0;
                }
                else {
                  BOOL v40 = 1;
                }
                char v41 = !v40;
                BYTE5(v91) = v41;
                DWORD2(v91) = a6;
                sub_1000593FC((uint64_t)&v92, &v98);
                sub_1000593FC((uint64_t)&v94, &v96);
                int v16 = v74;
                (*(void (**)(uint64_t, long long *))(*(void *)v14 + 96))(v14, &__dst);
                if (*a2 == 1)
                {
                  v84[0] = 0;
                  v84[1] = 0;
                  uint64_t v85 = 0;
                  if (BYTE14(v87)) {
                    uint64_t v42 = "true";
                  }
                  else {
                    uint64_t v42 = "false";
                  }
                  sub_100058DB0(v84, v42);
                  v82[0] = 0;
                  v82[1] = 0;
                  uint64_t v83 = 0;
                  std::operator+<char>();
                  memset(&v81, 0, sizeof(v81));
                  sub_100058DB0(&v81, "Empty");
                  if (BYTE8(v90))
                  {
                    std::string::operator=(&v81, (const std::string *)&v89);
                  }
                  else if (BYTE12(__val))
                  {
                    if ((DWORD2(__val) - 70000) > 0x48)
                    {
                      std::to_string(&v80, DWORD2(__val));
                      if (SHIBYTE(v81.__r_.__value_.__r.__words[2]) < 0) {
                        operator delete(v81.__r_.__value_.__l.__data_);
                      }
                      std::string v81 = v80;
                    }
                    else
                    {
                      uint64_t v44 = (char *)sub_1008A2254(SDWORD2(__val));
                      sub_10003ED78(&v81, v44);
                    }
                  }
                  memset(&v80, 0, sizeof(v80));
                  sub_100058DB0(&v80, "Empty");
                  if (BYTE4(__val))
                  {
                    if (__val > 0xB)
                    {
                      std::to_string(&v79, __val);
                      if (SHIBYTE(v80.__r_.__value_.__r.__words[2]) < 0) {
                        operator delete(v80.__r_.__value_.__l.__data_);
                      }
                      std::string v80 = v79;
                    }
                    else
                    {
                      long long v43 = (char *)sub_1008A2C08(__val);
                      sub_10003ED78(&v80, v43);
                    }
                  }
                  memset(&v79, 0, sizeof(v79));
                  if ((SBYTE7(v87) & 0x80u) == 0) {
                    size_t v45 = BYTE7(v87);
                  }
                  else {
                    size_t v45 = *((void *)&__dst + 1);
                  }
                  memset(&v75, 0, sizeof(v75));
                  sub_1000C140C((uint64_t)&v75, v45 + 2);
                  if ((v75.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                    size_t v46 = &v75;
                  }
                  else {
                    size_t v46 = (std::string *)v75.__r_.__value_.__r.__words[0];
                  }
                  if (v45)
                  {
                    if ((SBYTE7(v87) & 0x80u) == 0) {
                      p_dst = &__dst;
                    }
                    else {
                      p_dst = (long long *)__dst;
                    }
                    memmove(v46, p_dst, v45);
                  }
                  strcpy((char *)v46 + v45, ", ");
                  int v48 = "TransferFlowUnknown";
                  if (BYTE9(v87) == 2) {
                    int v48 = "TransferFlowPostBuddy";
                  }
                  if (BYTE9(v87) == 1) {
                    int v49 = "TransferFlowBuddy";
                  }
                  else {
                    int v49 = v48;
                  }
                  size_t v50 = strlen(v49);
                  int v16 = v74;
                  unint64_t v51 = std::string::append(&v75, v49, v50);
                  long long v52 = *(_OWORD *)&v51->__r_.__value_.__l.__data_;
                  v76.__r_.__value_.__r.__words[2] = v51->__r_.__value_.__r.__words[2];
                  *(_OWORD *)&v76.__r_.__value_.__l.__data_ = v52;
                  v51->__r_.__value_.__l.__size_ = 0;
                  v51->__r_.__value_.__r.__words[2] = 0;
                  v51->__r_.__value_.__r.__words[0] = 0;
                  uint64_t v53 = std::string::append(&v76, ", errorCode:", 0xCuLL);
                  long long v54 = *(_OWORD *)&v53->__r_.__value_.__l.__data_;
                  v103.__r_.__value_.__r.__words[2] = v53->__r_.__value_.__r.__words[2];
                  *(_OWORD *)&v103.__r_.__value_.__l.__data_ = v54;
                  v53->__r_.__value_.__l.__size_ = 0;
                  v53->__r_.__value_.__r.__words[2] = 0;
                  v53->__r_.__value_.__r.__words[0] = 0;
                  if ((v81.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                    int v55 = &v81;
                  }
                  else {
                    int v55 = (std::string *)v81.__r_.__value_.__r.__words[0];
                  }
                  if ((v81.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                    std::string::size_type size = HIBYTE(v81.__r_.__value_.__r.__words[2]);
                  }
                  else {
                    std::string::size_type size = v81.__r_.__value_.__l.__size_;
                  }
                  int v57 = std::string::append(&v103, (const std::string::value_type *)v55, size);
                  long long v58 = *(_OWORD *)&v57->__r_.__value_.__l.__data_;
                  v77.__r_.__value_.__r.__words[2] = v57->__r_.__value_.__r.__words[2];
                  *(_OWORD *)&v77.__r_.__value_.__l.__data_ = v58;
                  v57->__r_.__value_.__l.__size_ = 0;
                  v57->__r_.__value_.__r.__words[2] = 0;
                  v57->__r_.__value_.__r.__words[0] = 0;
                  BOOL v59 = std::string::append(&v77, ", failureReason:", 0x10uLL);
                  long long v60 = *(_OWORD *)&v59->__r_.__value_.__l.__data_;
                  v78.__r_.__value_.__r.__words[2] = v59->__r_.__value_.__r.__words[2];
                  *(_OWORD *)&v78.__r_.__value_.__l.__data_ = v60;
                  v59->__r_.__value_.__l.__size_ = 0;
                  v59->__r_.__value_.__r.__words[2] = 0;
                  v59->__r_.__value_.__r.__words[0] = 0;
                  if ((v80.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                    long long v61 = &v80;
                  }
                  else {
                    long long v61 = (std::string *)v80.__r_.__value_.__r.__words[0];
                  }
                  if ((v80.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                    std::string::size_type v62 = HIBYTE(v80.__r_.__value_.__r.__words[2]);
                  }
                  else {
                    std::string::size_type v62 = v80.__r_.__value_.__l.__size_;
                  }
                  int64x2_t v63 = std::string::append(&v78, (const std::string::value_type *)v61, v62);
                  long long v64 = *(_OWORD *)&v63->__r_.__value_.__l.__data_;
                  v79.__r_.__value_.__r.__words[2] = v63->__r_.__value_.__r.__words[2];
                  *(_OWORD *)&v79.__r_.__value_.__l.__data_ = v64;
                  v63->__r_.__value_.__l.__size_ = 0;
                  v63->__r_.__value_.__r.__words[2] = 0;
                  v63->__r_.__value_.__r.__words[0] = 0;
                  if (SHIBYTE(v78.__r_.__value_.__r.__words[2]) < 0) {
                    operator delete(v78.__r_.__value_.__l.__data_);
                  }
                  if (SHIBYTE(v77.__r_.__value_.__r.__words[2]) < 0) {
                    operator delete(v77.__r_.__value_.__l.__data_);
                  }
                  if (SHIBYTE(v103.__r_.__value_.__r.__words[2]) < 0) {
                    operator delete(v103.__r_.__value_.__l.__data_);
                  }
                  if (SHIBYTE(v76.__r_.__value_.__r.__words[2]) < 0) {
                    operator delete(v76.__r_.__value_.__l.__data_);
                  }
                  if (SHIBYTE(v75.__r_.__value_.__r.__words[2]) < 0) {
                    operator delete(v75.__r_.__value_.__l.__data_);
                  }
                  memset(&v78, 0, sizeof(v78));
                  sub_100058DB0(&v78, "eSIM iOS");
                  uint64_t v65 = *(void *)(a1 + 800);
                  if (v65)
                  {
                    if (*(char *)(v65 + 167) < 0 ? *(void *)(v65 + 152) : *(unsigned __int8 *)(v65 + 167))
                    {
                      std::operator+<char>();
                      if (SHIBYTE(v78.__r_.__value_.__r.__words[2]) < 0) {
                        operator delete(v78.__r_.__value_.__l.__data_);
                      }
                      std::string v78 = v77;
                    }
                  }
                  memset(&v77, 0, sizeof(v77));
                  if (*(unsigned char *)(a4 + 888))
                  {
                    std::string::operator=(&v77, (const std::string *)(a4 + 800));
                    std::string::size_type v67 = *(NSObject **)(a1 + 40);
                    if (os_log_type_enabled(v67, OS_LOG_TYPE_DEFAULT))
                    {
                      char v68 = &v77;
                      if ((v77.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
                        char v68 = (std::string *)v77.__r_.__value_.__r.__words[0];
                      }
                      LODWORD(v103.__r_.__value_.__l.__data_) = 136315138;
                      *(std::string::size_type *)((char *)v103.__r_.__value_.__r.__words + 4) = (std::string::size_type)v68;
                      _os_log_impl((void *)&_mh_execute_header, v67, OS_LOG_TYPE_DEFAULT, "#I ABC group ID : %s", (uint8_t *)&v103, 0xCu);
                    }
                  }
                  sub_100058DB0(&v103, "Cellular");
                  v102[3] = 0;
                  (*(void (**)(uint64_t, std::string *, std::string *, void **, std::string *, void, std::string *, void *))(*(void *)v14 + 192))(v14, &v103, &v78, v82, &v79, 0, &v77, v102);
                  sub_1000DBADC(v102);
                  if (SHIBYTE(v103.__r_.__value_.__r.__words[2]) < 0) {
                    operator delete(v103.__r_.__value_.__l.__data_);
                  }
                  if (SHIBYTE(v77.__r_.__value_.__r.__words[2]) < 0) {
                    operator delete(v77.__r_.__value_.__l.__data_);
                  }
                  if (SHIBYTE(v78.__r_.__value_.__r.__words[2]) < 0) {
                    operator delete(v78.__r_.__value_.__l.__data_);
                  }
                  if (SHIBYTE(v79.__r_.__value_.__r.__words[2]) < 0) {
                    operator delete(v79.__r_.__value_.__l.__data_);
                  }
                  if (SHIBYTE(v80.__r_.__value_.__r.__words[2]) < 0) {
                    operator delete(v80.__r_.__value_.__l.__data_);
                  }
                  if (SHIBYTE(v81.__r_.__value_.__r.__words[2]) < 0) {
                    operator delete(v81.__r_.__value_.__l.__data_);
                  }
                  if (SHIBYTE(v83) < 0) {
                    operator delete(v82[0]);
                  }
                  if (SHIBYTE(v85) < 0) {
                    operator delete(v84[0]);
                  }
                }
                if (BYTE8(v95) && SBYTE7(v95) < 0) {
                  operator delete((void *)v94);
                }
                if (BYTE8(v93) && SBYTE7(v93) < 0) {
                  operator delete((void *)v92);
                }
                if (BYTE8(v90) && SBYTE7(v90) < 0) {
                  operator delete((void *)v89);
                }
                if (SBYTE7(v87) < 0) {
                  operator delete((void *)__dst);
                }
                if (BYTE8(v97) && SBYTE7(v97) < 0) {
                  operator delete((void *)v96);
                }
                if (BYTE8(v99) && SBYTE7(v99) < 0) {
                  operator delete((void *)v98);
                }
                if (SHIBYTE(v101) < 0) {
                  operator delete((void *)__p);
                }
                if (v105) {
                  sub_10030D10C((uint64_t)buf);
                }
                goto LABEL_182;
              }
            }
          }
          else
          {
            int v16 = 0;
          }
          BOOL v21 = *(NSObject **)(a1 + 40);
          if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)long long buf = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "invalid pendingTransferHandler to submit transfer details metric", buf, 2u);
            if (!v16) {
              goto LABEL_183;
            }
          }
          else if (!v16)
          {
            goto LABEL_183;
          }
LABEL_182:
          sub_10004D2C8(v16);
LABEL_183:
          sub_10004D2C8(v13);
          return;
        }
      }
    }
    else
    {
      uint32_t v13 = 0;
    }
    char v20 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, "invalid delegate to submit transfer details metric", buf, 2u);
      if (!v13) {
        return;
      }
    }
    else if (!v13)
    {
      return;
    }
    goto LABEL_183;
  }
}

void sub_100B4C268(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, std::__shared_weak_count *a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, uint64_t a19, uint64_t a20,void *a21,uint64_t a22,uint64_t a23,uint64_t a24,void *a25,uint64_t a26,uint64_t a27,uint64_t a28,void *a29,uint64_t a30,uint64_t a31,uint64_t a32,void *a33,uint64_t a34,uint64_t a35,uint64_t a36,void *__p,uint64_t a38,int a39,__int16 a40,char a41,char a42,uint64_t a43,void *a44,uint64_t a45,int a46,__int16 a47,char a48,char a49,void *a50,uint64_t a51,int a52,__int16 a53,char a54,char a55,char a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  if (a42 < 0) {
    operator delete(__p);
  }
  if (a49 < 0) {
    operator delete(a44);
  }
  if (a55 < 0) {
    operator delete(a50);
  }
  sub_100B51C24((uint64_t)&a56);
  if (a74 && a73 < 0) {
    operator delete(a72);
  }
  if (LOBYTE(STACK[0x208]) && SLOBYTE(STACK[0x207]) < 0) {
    operator delete(a75);
  }
  if (SLOBYTE(STACK[0x227]) < 0) {
    operator delete((void *)STACK[0x210]);
  }
  if (LOBYTE(STACK[0x750])) {
    sub_10030D10C((uint64_t)&STACK[0x270]);
  }
  sub_10004D2C8(a13);
  sub_10004D2C8(v75);
  _Unwind_Resume(a1);
}

void sub_100B4C454(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,void *a47,uint64_t a48,int a49,__int16 a50,char a51,char a52,uint64_t a53,uint64_t a54,uint64_t a55,void *a56,uint64_t a57,int a58,__int16 a59,char a60,char a61,char a62,uint64_t a63)
{
  if (a71 && a70 < 0) {
    operator delete(__p);
  }
  if (a62 && a61 < 0) {
    operator delete(a56);
  }
  if (a52 < 0) {
    operator delete(a47);
  }
  JUMPOUT(0x100B4C3ECLL);
}

void sub_100B4C4B4(uint64_t a1, int a2)
{
  uint64_t v2 = *(void *)(a1 + 312);
  uint64_t v3 = *(void *)(a1 + 328);
  if (v3 != v2 && *(void *)(a1 + 304) != v2)
  {
    if ((a2 & 1) != 0 || *(unsigned char *)(a1 + 137) || *(unsigned char *)(a1 + 140) != 6)
    {
      std::string::size_type v9 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v10 = "enter";
        if (!a2) {
          uint64_t v10 = "exit";
        }
        unint64_t v11 = (void *)(v3 + 1048);
        if (*(char *)(v3 + 1071) < 0) {
          unint64_t v11 = (void *)*v11;
        }
        LODWORD(__p[0]) = 136315394;
        *(void **)((char *)__p + 4) = (void *)v10;
        WORD2(__p[1]) = 2080;
        *(void **)((char *)&__p[1] + 6) = v11;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I %s websheet for iccid: %s", (uint8_t *)__p, 0x16u);
      }
    }
    else
    {
      memset(__p, 0, sizeof(__p));
      sub_100B49750((uint64_t)__p, v3 + 1048);
      uint64_t v6 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v7 = *(void *)(a1 + 328);
        uint64_t v8 = (void *)(v7 + 1048);
        if (*(char *)(v7 + 1071) < 0) {
          uint64_t v8 = (void *)*v8;
        }
        int v12 = 136315138;
        uint32_t v13 = v8;
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I clear websheet based transfer:%s", (uint8_t *)&v12, 0xCu);
      }
      sub_100B3F32C(a1);
      sub_100B3F548(a1);
      if (SHIBYTE(__p[2]) < 0) {
        operator delete(__p[0]);
      }
    }
  }
}

void sub_100B4C658(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
}

BOOL sub_100B4C67C(void *a1)
{
  uint64_t v1 = (uint64_t *)a1[38];
  uint64_t v2 = (uint64_t *)a1[39];
  if (v1 != v2)
  {
    uint64_t v4 = v1 + 131;
    do
    {
      uint64_t v5 = a1[5];
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v6 = v4;
        if (*((char *)v4 + 23) < 0) {
          uint64_t v6 = (uint64_t *)*v4;
        }
        *(_DWORD *)long long buf = 136315138;
        uint64_t v10 = v6;
        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I source iccid: %s", buf, 0xCu);
      }
      uint64_t v7 = v4 + 59;
      v4 += 190;
    }
    while (v7 != v2);
  }
  return v1 != v2;
}

BOOL sub_100B4C778(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 416);
  if (v1)
  {
    uint64_t v2 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v4 = 0;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Transfer Entitlements ongoing", v4, 2u);
    }
  }
  return v1 != 0;
}

BOOL sub_100B4C7E8(uint64_t a1)
{
  return *(unsigned char *)(a1 + 139) || *(unsigned char *)(a1 + 138) != 0;
}

void sub_100B4C808(uint64_t a1, int a2)
{
  uint64_t v4 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = "kUnknown";
    if (a2 == 1) {
      uint64_t v5 = "kSource";
    }
    if (a2 == 2) {
      uint64_t v5 = "kTarget";
    }
    int v12 = 136315138;
    uint32_t v13 = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I EndPoint Type: %s", (uint8_t *)&v12, 0xCu);
  }
  if (a2 == 2)
  {
    sub_100B3F32C(a1);
    *(unsigned char *)(a1 + 128) = 0;
    uint64_t v6 = *(std::__shared_weak_count **)(a1 + 224);
    *(void *)(a1 + 216) = 0;
    *(void *)(a1 + 224) = 0;
    if (v6) {
      sub_10004D2C8(v6);
    }
    *(unsigned char *)(a1 + 130) = 0;
    *(_DWORD *)(a1 + 132) = 0;
    uint64_t v8 = *(void *)(a1 + 144);
    for (uint64_t i = *(void *)(a1 + 152); i != v8; uint64_t i = sub_1000C52BC(i - 400))
      ;
    *(void *)(a1 + 152) = v8;
    uint64_t v11 = *(void *)(a1 + 560);
    *(void *)(a1 + 560) = 0;
    if (v11 == a1 + 536)
    {
      (*(void (**)(uint64_t))(*(void *)(a1 + 536) + 32))(a1 + 536);
    }
    else if (v11)
    {
      (*(void (**)(uint64_t))(*(void *)v11 + 40))(v11);
    }
  }
  else
  {
    std::string::size_type v9 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      uint64_t v10 = "kUnknown";
      if (a2 == 1) {
        uint64_t v10 = "kSource";
      }
      int v12 = 136315138;
      uint32_t v13 = v10;
      _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "Target finishTransferSession mismatched end point: %s", (uint8_t *)&v12, 0xCu);
    }
  }
}

uint64_t sub_100B4C9F0(uint64_t a1)
{
  uint64_t v1 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)uint64_t v3 = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_ERROR, "unexpected call", v3, 2u);
  }
  return 0;
}

uint64_t sub_100B4CA58(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "unexpected call", buf, 2u);
  }
  v6[0] = 0;
  char v7 = 0;
  uint64_t result = sub_100B4CB0C(a3, (uint64_t)v6, 17);
  if (v7) {
    return sub_1000C5578((uint64_t)v6);
  }
  return result;
}

void sub_100B4CAF0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,char a42)
{
  if (a42) {
    sub_1000C5578((uint64_t)&a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100B4CB0C(uint64_t a1, uint64_t a2, char a3)
{
  char v5 = a3;
  uint64_t v3 = *(void *)(a1 + 24);
  if (!v3) {
    sub_10007B600();
  }
  return (*(uint64_t (**)(uint64_t, uint64_t, char *))(*(void *)v3 + 48))(v3, a2, &v5);
}

uint64_t sub_100B4CB60(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  char v5 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "unexpected call", buf, 2u);
  }
  v7[0] = 0;
  char v8 = 0;
  uint64_t result = sub_100B4CB0C(a4, (uint64_t)v7, 17);
  if (v8) {
    return sub_1000C5578((uint64_t)v7);
  }
  return result;
}

void sub_100B4CBF8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,char a42)
{
  if (a42) {
    sub_1000C5578((uint64_t)&a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100B4CC14(uint64_t a1)
{
  uint64_t v1 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)uint64_t v3 = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_ERROR, "unexpected call", v3, 2u);
  }
  return 0;
}

void sub_100B4CC7C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unsigned __int8 *a6)
{
  if (*(char *)(a2 + 23) < 0)
  {
    sub_10004FC84(v11, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)uint64_t v11 = *(_OWORD *)a2;
    v11[2] = *(void **)(a2 + 16);
  }
  if (*(char *)(a4 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a4, *(void *)(a4 + 8));
  }
  else
  {
    *(_OWORD *)long long __p = *(_OWORD *)a4;
    __p[2] = *(void **)(a4 + 16);
  }
  sub_10030D9BC(v13, a5);
  __int16 v14 = 0;
  if (*a6 - 1 <= 1) {
    __int16 v14 = *(_WORD *)a6;
  }
  uint64_t v10 = *(std::__shared_weak_count **)(a1 + 16);
  if (v10)
  {
    if (std::__shared_weak_count::lock(v10)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_100B4CED0(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  if (*(char *)(v22 + 31) < 0) {
    operator delete(*v23);
  }
  sub_10006A6AC(a1);
}

void sub_100B4CF44(uint64_t a1, unsigned __int8 *a2, uint64_t a3, uint64_t a4, int a5)
{
  uint64_t v9 = *(void *)(a1 + 312);
  uint64_t v10 = sub_100B45F5C(*(void *)(a1 + 304), v9, (unsigned __int8 **)a3);
  if (v9 == v10)
  {
    char v20 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
    {
      if (*(char *)(a3 + 23) >= 0) {
        BOOL v21 = (unsigned __int8 *)a3;
      }
      else {
        BOOL v21 = *(unsigned __int8 **)a3;
      }
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = v21;
      uint64_t v22 = "cannot find source iccid in tr.ctr : %s. drop transfer consent indication";
      char v23 = v20;
      uint32_t v24 = 12;
LABEL_32:
      _os_log_error_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_ERROR, v22, buf, v24);
      return;
    }
    return;
  }
  signed __int8 v11 = a2[23];
  size_t v12 = *((void *)a2 + 1);
  if (v11 >= 0) {
    uint64_t v13 = a2[23];
  }
  else {
    uint64_t v13 = *((void *)a2 + 1);
  }
  if (!v13) {
    goto LABEL_36;
  }
  __int16 v14 = (unsigned __int8 **)(v10 + 1256);
  uint64_t v15 = *(unsigned __int8 *)(v10 + 1279);
  int v16 = (char)v15;
  if ((v15 & 0x80u) != 0) {
    uint64_t v15 = *(void *)(v10 + 1264);
  }
  if (v13 != v15) {
    goto LABEL_23;
  }
  if (v16 >= 0) {
    uint64_t v17 = (unsigned __int8 **)(v10 + 1256);
  }
  else {
    uint64_t v17 = (unsigned __int8 **)*v14;
  }
  if ((a2[23] & 0x80) == 0)
  {
    if (a2[23])
    {
      BOOL v18 = a2;
      uint64_t v19 = a2[23];
      while (*v18 == *(unsigned __int8 *)v17)
      {
        ++v18;
        uint64_t v17 = (unsigned __int8 **)((char *)v17 + 1);
        if (!--v19) {
          goto LABEL_36;
        }
      }
LABEL_23:
      int v25 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
      {
        if (v11 < 0) {
          a2 = *(unsigned __int8 **)a2;
        }
        goto LABEL_26;
      }
      return;
    }
LABEL_36:
    char v27 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
    {
      if ((a5 - 2) > 2) {
        uint64_t v28 = "kAccepted";
      }
      else {
        uint64_t v28 = off_101A3FE60[(char)(a5 - 2)];
      }
      if (*(char *)(a3 + 23) >= 0) {
        int v29 = (unsigned __int8 *)a3;
      }
      else {
        int v29 = *(unsigned __int8 **)a3;
      }
      *(_DWORD *)long long buf = 136315394;
      *(void *)&uint8_t buf[4] = v28;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&unsigned char buf[14] = v29;
      _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "#I consent state [%s] received - plan [%s]", buf, 0x16u);
    }
    long long v52 = 0;
    unint64_t v51 = 0;
    sub_100B3EA60(a1, a3, 3, 0, &v52, &v51);
    sub_100057D78(&v51);
    sub_1000558F4(&v52);
    uint64_t v49 = 0;
    size_t v50 = 0;
    (***(void (****)(uint8_t *__return_ptr))(a1 + 48))(buf);
    Registry::getTimerService(&v49, *(Registry **)buf);
    if (*(void *)&buf[8]) {
      sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
    }
    if (v49)
    {
      memset(buf, 0, sizeof(buf));
      if (*(char *)(a3 + 23) < 0)
      {
        sub_10004FC84(buf, *(void **)a3, *(void *)(a3 + 8));
      }
      else
      {
        *(_OWORD *)long long buf = *(_OWORD *)a3;
        *(void *)&uint8_t buf[16] = *(void *)(a3 + 16);
      }
      int v31 = *(std::__shared_weak_count **)(a1 + 16);
      if (!v31 || (uint64_t v32 = *(void *)(a1 + 8), (v33 = std::__shared_weak_count::lock(v31)) == 0)) {
        sub_100088B9C();
      }
      int v34 = v33;
      atomic_fetch_add_explicit(&v33->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v33);
      uint64_t v35 = v49;
      sub_100058DB0(__p, "Transfer profile indication wait timer");
      unint64_t v36 = *(NSObject **)(a1 + 24);
      dispatch_object_t object = v36;
      if (v36) {
        dispatch_retain(v36);
      }
      v40[0] = _NSConcreteStackBlock;
      v40[1] = 1174405120;
      v40[2] = sub_100B4D5A4;
      v40[3] = &unk_101A3E410;
      void v40[4] = a1;
      v40[5] = v32;
      char v41 = v34;
      atomic_fetch_add_explicit(&v34->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      if ((char)buf[23] < 0)
      {
        sub_10004FC84(&v42, *(void **)buf, *(unint64_t *)&buf[8]);
      }
      else
      {
        long long v42 = *(_OWORD *)buf;
        uint64_t v43 = *(void *)&buf[16];
      }
      aBlocuint64_t k = _Block_copy(v40);
      sub_100118A44(v35, (uint64_t)__p, 0, 120000000, &object, &aBlock);
      uint64_t v37 = v48;
      uint64_t v48 = 0;
      uint64_t v38 = *(void *)(a1 + 960);
      *(void *)(a1 + 960) = v37;
      if (v38)
      {
        (*(void (**)(uint64_t))(*(void *)v38 + 8))(v38);
        uint64_t v39 = v48;
        uint64_t v48 = 0;
        if (v39) {
          (*(void (**)(uint64_t))(*(void *)v39 + 8))(v39);
        }
      }
      if (aBlock) {
        _Block_release(aBlock);
      }
      if (object) {
        dispatch_release(object);
      }
      if (v47 < 0) {
        operator delete(__p[0]);
      }
      if (SHIBYTE(v43) < 0) {
        operator delete((void *)v42);
      }
      if (v41) {
        std::__shared_weak_count::__release_weak(v41);
      }
      std::__shared_weak_count::__release_weak(v34);
      if ((char)buf[23] < 0) {
        operator delete(*(void **)buf);
      }
    }
    else
    {
      char v30 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_ERROR, "No Timer service", buf, 2u);
      }
    }
    if (v50) {
      sub_10004D2C8(v50);
    }
    return;
  }
  a2 = *(unsigned __int8 **)a2;
  if (!memcmp(a2, v17, v12)) {
    goto LABEL_36;
  }
  int v25 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
  {
LABEL_26:
    if (v16 < 0) {
      __int16 v14 = (unsigned __int8 **)*v14;
    }
    if (*(char *)(a3 + 23) >= 0) {
      int v26 = (unsigned __int8 *)a3;
    }
    else {
      int v26 = *(unsigned __int8 **)a3;
    }
    *(_DWORD *)long long buf = 136315650;
    *(void *)&uint8_t buf[4] = a2;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&unsigned char buf[14] = v14;
    *(_WORD *)&unsigned char buf[22] = 2080;
    long long v54 = v26;
    uint64_t v22 = "uuid mismatched : %s != %s, source iccid : %s. drop transfer consent indication";
    char v23 = v25;
    uint32_t v24 = 32;
    goto LABEL_32;
  }
}

void sub_100B4D4C8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, std::__shared_weak_count *a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,void *aBlock,dispatch_object_t object,void *__p,uint64_t a25,int a26,__int16 a27,char a28,char a29,uint64_t a30,uint64_t a31,std::__shared_weak_count *a32,char a33)
{
  if (a15) {
    std::__shared_weak_count::__release_weak(a15);
  }
  if (object) {
    dispatch_release(object);
  }
  if (a29 < 0) {
    operator delete(__p);
  }
  std::__shared_weak_count::__release_weak(v33);
  if (*(char *)(v34 - 105) < 0) {
    operator delete(*(void **)(v34 - 128));
  }
  if (a32) {
    sub_10004D2C8(a32);
  }
  _Unwind_Resume(a1);
}

void sub_100B4D5A4(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 48);
  if (v2)
  {
    uint64_t v3 = *(void *)(a1 + 32);
    uint64_t v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      if (*(void *)(a1 + 40))
      {
        char v5 = *(NSObject **)(v3 + 40);
        if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
        {
          LOWORD(v7) = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "Transfer profile indication wait timed out", (uint8_t *)&v7, 2u);
        }
        uint64_t v7 = v3;
        if (*(char *)(a1 + 79) < 0)
        {
          sub_10004FC84(__p, *(void **)(a1 + 56), *(void *)(a1 + 64));
        }
        else
        {
          *(_OWORD *)long long __p = *(_OWORD *)(a1 + 56);
          __p[2] = *(void **)(a1 + 72);
        }
        uint64_t v6 = *(std::__shared_weak_count **)(v3 + 16);
        if (v6)
        {
          if (std::__shared_weak_count::lock(v6)) {
            operator new();
          }
        }
        sub_100088B9C();
      }
      sub_10004D2C8(v4);
    }
  }
}

void sub_100B4D75C(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

unsigned char *sub_100B4D778(void *a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 48);
  a1[5] = *(void *)(a2 + 40);
  a1[6] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  uint64_t result = a1 + 7;
  if (*(char *)(a2 + 79) < 0) {
    return sub_10004FC84(result, *(void **)(a2 + 56), *(void *)(a2 + 64));
  }
  long long v5 = *(_OWORD *)(a2 + 56);
  a1[9] = *(void *)(a2 + 72);
  *(_OWORD *)uint64_t result = v5;
  return result;
}

void sub_100B4D7E0(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(std::__shared_weak_count **)(v1 + 48);
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  _Unwind_Resume(exception_object);
}

void sub_100B4D7F8(uint64_t a1)
{
  if (*(char *)(a1 + 79) < 0) {
    operator delete(*(void **)(a1 + 56));
  }
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 48);
  if (v2)
  {
    std::__shared_weak_count::__release_weak(v2);
  }
}

uint64_t sub_100B4D84C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)uint64_t v7 = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "unexpected call", v7, 2u);
  }
  v7[0] = 0;
  char v8 = 0;
  uint64_t v5 = *(void *)(a3 + 24);
  if (!v5) {
    sub_10007B600();
  }
  (*(void (**)(uint64_t, uint8_t *))(*(void *)v5 + 48))(v5, v7);
  return sub_1000C636C((uint64_t)v7);
}

void sub_100B4D8FC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_100B4D910(uint64_t a1)
{
  uint64_t v1 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)uint64_t v2 = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_ERROR, "unexpected call", v2, 2u);
  }
}

void *sub_100B4D974(uint64_t a1, uint64_t a2)
{
  sub_100634518(a1 + 816, a2);
  uint64_t result = *(void **)(a1 + 512);
  if (result && *(unsigned char *)(a1 + 840))
  {
    (*(void (**)(void *))(*result + 48))(result);
    return sub_1003355AC((void *)(a1 + 488));
  }
  return result;
}

void sub_100B4D9F8(void *a1, unsigned __int8 *a2, uint64_t a3, uint64_t a4)
{
  int v5 = *(char *)(a4 + 23);
  if (v5 >= 0) {
    uint64_t v6 = *(unsigned __int8 *)(a4 + 23);
  }
  else {
    uint64_t v6 = *(void *)(a4 + 8);
  }
  if (!v6)
  {
    BOOL v21 = a1[5];
    if (!os_log_type_enabled(v21, OS_LOG_TYPE_ERROR)) {
      return;
    }
    *(_WORD *)long long buf = 0;
    uint64_t v22 = "unrecognized response received";
    char v23 = v21;
    uint32_t v24 = 2;
    goto LABEL_38;
  }
  uint64_t v10 = a1[38];
  uint64_t v9 = a1[39];
  uint64_t v11 = sub_100B45F5C(v10, v9, (unsigned __int8 **)a3);
  if (v9 == v11)
  {
    int v25 = a1[5];
    if (!os_log_type_enabled(v25, OS_LOG_TYPE_ERROR)) {
      return;
    }
    if (*(char *)(a3 + 23) >= 0) {
      int v26 = (unsigned __int8 *)a3;
    }
    else {
      int v26 = *(unsigned __int8 **)a3;
    }
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = v26;
    uint64_t v22 = "cannot find source iccid in tr.ctr : %s. drop tr.rsp";
    char v23 = v25;
    uint32_t v24 = 12;
LABEL_38:
    _os_log_error_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_ERROR, v22, buf, v24);
    return;
  }
  signed __int8 v12 = a2[23];
  size_t v13 = *((void *)a2 + 1);
  if (v12 >= 0) {
    uint64_t v14 = a2[23];
  }
  else {
    uint64_t v14 = *((void *)a2 + 1);
  }
  if (!v14) {
    goto LABEL_42;
  }
  uint64_t v15 = (unsigned __int8 **)(v11 + 1256);
  uint64_t v16 = *(unsigned __int8 *)(v11 + 1279);
  int v17 = (char)v16;
  if ((v16 & 0x80u) != 0) {
    uint64_t v16 = *(void *)(v11 + 1264);
  }
  if (v14 != v16) {
    goto LABEL_29;
  }
  if (v17 >= 0) {
    BOOL v18 = (unsigned __int8 **)(v11 + 1256);
  }
  else {
    BOOL v18 = (unsigned __int8 **)*v15;
  }
  if ((a2[23] & 0x80) == 0)
  {
    if (a2[23])
    {
      uint64_t v19 = a2;
      uint64_t v20 = a2[23];
      while (*v19 == *(unsigned __int8 *)v18)
      {
        ++v19;
        BOOL v18 = (unsigned __int8 **)((char *)v18 + 1);
        if (!--v20) {
          goto LABEL_42;
        }
      }
LABEL_29:
      char v27 = a1[5];
      if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
      {
        if (v12 < 0) {
          a2 = *(unsigned __int8 **)a2;
        }
        goto LABEL_32;
      }
      return;
    }
LABEL_42:
    if (v6 == 22)
    {
      int v29 = *(uint64_t **)a4;
      if (v5 >= 0) {
        int v29 = (uint64_t *)a4;
      }
      uint64_t v30 = *v29;
      uint64_t v31 = v29[1];
      uint64_t v32 = *(uint64_t *)((char *)v29 + 14);
      if (v30 == *(void *)"kDeleteProfileResponse"
        && v31 == *(void *)"rofileResponse"
        && v32 == *(void *)"Response")
      {
        uint64_t v35 = a1[5];
        if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT))
        {
          unint64_t v36 = (unsigned __int8 **)a3;
          uint64_t v37 = *(char *)(a3 + 23) >= 0 ? a3 : *(void *)a3;
          *(_DWORD *)long long buf = 136315138;
          *(void *)&uint8_t buf[4] = v37;
          _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_DEFAULT, "#I received delete profile response for iccid: %s", buf, 0xCu);
          uint64_t v10 = a1[38];
          uint64_t v9 = a1[39];
        }
        else
        {
          unint64_t v36 = (unsigned __int8 **)a3;
        }
        uint64_t v38 = sub_100B45F5C(v10, v9, v36);
        if (v9 != v38)
        {
          uint64_t v39 = v38;
          BOOL v40 = (std::__shared_weak_count *)a1[11];
          if (v40)
          {
            char v41 = std::__shared_weak_count::lock(v40);
            if (v41)
            {
              long long v42 = v41;
              uint64_t v43 = a1[10];
              if (v43)
              {
                int64x2_t v83 = 0uLL;
                v84[0] = 0;
                long long v89 = v84;
                *(void *)long long buf = operator new(0x38uLL);
                *(void *)&uint8_t buf[8] = *(void *)buf;
                *(void *)&uint8_t buf[16] = *(void *)buf;
                uint64_t v88 = *(void *)buf + 56;
                uint64_t v44 = sub_100058DB0(*(void **)buf, "IsSourcePlanDeleted");
                void v44[3] = sub_100B6D7B0;
                void v44[4] = 1;
                uint64_t v45 = *(void *)&buf[8];
                unint64_t v46 = *(void *)&buf[16] + 56;
                *(void *)&buf[16] += 56;
                uint64_t v47 = v83.i64[1];
                uint64_t v48 = v83.i64[0];
                if (v83.i64[1] == v83.i64[0])
                {
                  int64x2_t v52 = vdupq_n_s64(v83.u64[1]);
                }
                else
                {
                  do
                  {
                    long long v49 = *(_OWORD *)(v47 - 56);
                    *(void *)(v45 - 40) = *(void *)(v47 - 40);
                    *(_OWORD *)(v45 - 56) = v49;
                    size_t v50 = (void *)(v45 - 32);
                    v45 -= 56;
                    uint64_t v51 = v47 - 56;
                    *(void *)(v47 - 48) = 0;
                    *(void *)(v47 - 40) = 0;
                    *(void *)(v47 - 56) = 0;
                    sub_1009515A0(v50, (void (**)(uint64_t))(v47 - 32));
                    uint64_t v47 = v51;
                  }
                  while (v51 != v48);
                  int64x2_t v52 = v83;
                  unint64_t v46 = *(void *)&buf[16];
                }
                v83.i64[0] = v45;
                v83.i64[1] = v46;
                *(int64x2_t *)&uint8_t buf[8] = v52;
                uint64_t v53 = v84[0];
                v84[0] = v88;
                uint64_t v88 = v53;
                *(void *)long long buf = v52.i64[0];
                sub_100B61E54((uint64_t)buf);
                int v54 = *(char *)(v39 + 1095);
                v83.i64[1] = v46;
                *(void *)long long buf = "SourceImei";
                if (v54 < 0)
                {
                  sub_10004FC84(&buf[8], *(void **)(v39 + 1072), *(void *)(v39 + 1080));
                  unint64_t v46 = v83.u64[1];
                }
                else
                {
                  *(_OWORD *)&uint8_t buf[8] = *(_OWORD *)(v39 + 1072);
                  uint64_t v88 = *(void *)(v39 + 1088);
                }
                if (v46 >= v84[0])
                {
                  unint64_t v55 = sub_100B61EA4(v83.i64, (uint64_t)buf);
                }
                else
                {
                  sub_100058DB0((void *)v46, *(char **)buf);
                  *(void *)(v46 + 24) = 0;
                  *(_OWORD *)(v46 + 32) = *(_OWORD *)&buf[8];
                  *(void *)(v46 + 48) = v88;
                  uint64_t v88 = 0;
                  *(_OWORD *)&uint8_t buf[8] = 0uLL;
                  *(void *)(v46 + 24) = sub_100333A04;
                  unint64_t v55 = v46 + 56;
                }
                v83.i64[1] = v55;
                if (SHIBYTE(v88) < 0)
                {
                  operator delete(*(void **)&buf[8]);
                  unint64_t v55 = v83.u64[1];
                }
                *(_OWORD *)long long __p = *(_OWORD *)(v39 + 1032);
                if (v55 >= v84[0])
                {
                  uint64_t v57 = 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(v55 - v83.i64[0]) >> 3);
                  if ((unint64_t)(v57 + 1) > 0x492492492492492) {
                    sub_10006A748();
                  }
                  unint64_t v58 = 0xDB6DB6DB6DB6DB6ELL * ((v84[0] - v83.i64[0]) >> 3);
                  if (v58 <= v57 + 1) {
                    unint64_t v58 = v57 + 1;
                  }
                  if ((unint64_t)(0x6DB6DB6DB6DB6DB7 * ((v84[0] - v83.i64[0]) >> 3)) >= 0x249249249249249) {
                    unint64_t v59 = 0x492492492492492;
                  }
                  else {
                    unint64_t v59 = v58;
                  }
                  long long v89 = v84;
                  if (v59) {
                    long long v60 = (char *)sub_100341ECC((uint64_t)v84, v59);
                  }
                  else {
                    long long v60 = 0;
                  }
                  *(void *)long long buf = v60;
                  *(void *)&uint8_t buf[8] = &v60[56 * v57];
                  *(void *)&uint8_t buf[16] = *(void *)&buf[8];
                  uint64_t v88 = (uint64_t)&v60[56 * v59];
                  sub_100058DB0(*(void **)&buf[8], "SourceCsn");
                  long long v61 = &v60[56 * v57];
                  *((_OWORD *)v61 + 2) = *(_OWORD *)__p;
                  *((void *)v61 + 3) = sub_100B61FF8;
                  uint64_t v62 = *(void *)&buf[8];
                  unint64_t v56 = *(void *)&buf[16] + 56;
                  *(void *)&buf[16] += 56;
                  uint64_t v63 = v83.i64[1];
                  uint64_t v64 = v83.i64[0];
                  if (v83.i64[1] == v83.i64[0])
                  {
                    int64x2_t v68 = vdupq_n_s64(v83.u64[1]);
                  }
                  else
                  {
                    do
                    {
                      long long v65 = *(_OWORD *)(v63 - 56);
                      *(void *)(v62 - 40) = *(void *)(v63 - 40);
                      *(_OWORD *)(v62 - 56) = v65;
                      uint64_t v66 = (void *)(v62 - 32);
                      v62 -= 56;
                      uint64_t v67 = v63 - 56;
                      *(void *)(v63 - 48) = 0;
                      *(void *)(v63 - 40) = 0;
                      *(void *)(v63 - 56) = 0;
                      sub_1009515A0(v66, (void (**)(uint64_t))(v63 - 32));
                      uint64_t v63 = v67;
                    }
                    while (v67 != v64);
                    int64x2_t v68 = v83;
                    unint64_t v56 = *(void *)&buf[16];
                  }
                  v83.i64[0] = v62;
                  v83.i64[1] = v56;
                  *(int64x2_t *)&uint8_t buf[8] = v68;
                  uint64_t v69 = v84[0];
                  v84[0] = v88;
                  uint64_t v88 = v69;
                  *(void *)long long buf = v68.i64[0];
                  sub_100B61E54((uint64_t)buf);
                }
                else
                {
                  sub_100058DB0((void *)v55, "SourceCsn");
                  *(_OWORD *)(v55 + 32) = *(_OWORD *)__p;
                  *(void *)(v55 + 24) = sub_100B61FF8;
                  unint64_t v56 = v55 + 56;
                }
                v83.i64[1] = v56;
                *(void *)long long buf = "SourceDeviceType";
                if (*(char *)(v39 + 1143) < 0)
                {
                  sub_10004FC84(&buf[8], *(void **)(v39 + 1120), *(void *)(v39 + 1128));
                  unint64_t v56 = v83.u64[1];
                }
                else
                {
                  *(_OWORD *)&uint8_t buf[8] = *(_OWORD *)(v39 + 1120);
                  uint64_t v88 = *(void *)(v39 + 1136);
                }
                if (v56 >= v84[0])
                {
                  uint64_t v70 = sub_100B61EA4(v83.i64, (uint64_t)buf);
                }
                else
                {
                  sub_100058DB0((void *)v56, *(char **)buf);
                  *(void *)(v56 + 24) = 0;
                  *(_OWORD *)(v56 + 32) = *(_OWORD *)&buf[8];
                  *(void *)(v56 + 48) = v88;
                  uint64_t v88 = 0;
                  *(_OWORD *)&uint8_t buf[8] = 0uLL;
                  *(void *)(v56 + 24) = sub_100333A04;
                  uint64_t v70 = v56 + 56;
                }
                v83.i64[1] = v70;
                if (SHIBYTE(v88) < 0) {
                  operator delete(*(void **)&buf[8]);
                }
                *(void *)long long buf = "SourceDisplayName";
                if (*(char *)(v39 + 1119) < 0)
                {
                  sub_10004FC84(&buf[8], *(void **)(v39 + 1096), *(void *)(v39 + 1104));
                }
                else
                {
                  *(_OWORD *)&uint8_t buf[8] = *(_OWORD *)(v39 + 1096);
                  uint64_t v88 = *(void *)(v39 + 1112);
                }
                uint64_t v71 = v83.i64[1];
                if (v83.i64[1] >= v84[0])
                {
                  uint64_t v72 = sub_100B61EA4(v83.i64, (uint64_t)buf);
                }
                else
                {
                  sub_100058DB0((void *)v83.i64[1], *(char **)buf);
                  *(void *)(v71 + 24) = 0;
                  *(_OWORD *)(v71 + 32) = *(_OWORD *)&buf[8];
                  *(void *)(v71 + 48) = v88;
                  uint64_t v88 = 0;
                  *(_OWORD *)&uint8_t buf[8] = 0uLL;
                  *(void *)(v71 + 24) = sub_100333A04;
                  uint64_t v72 = v71 + 56;
                }
                v83.i64[1] = v72;
                if (SHIBYTE(v88) < 0) {
                  operator delete(*(void **)&buf[8]);
                }
                if (*(unsigned char *)(v39 + 888))
                {
                  if (!*(unsigned char *)(v39 + 688)) {
                    goto LABEL_159;
                  }
                  *(void *)long long buf = "TransferToken";
                  if (*(char *)(v39 + 687) < 0)
                  {
                    sub_10004FC84(&buf[8], *(void **)(v39 + 664), *(void *)(v39 + 672));
                  }
                  else
                  {
                    *(_OWORD *)&uint8_t buf[8] = *(_OWORD *)(v39 + 664);
                    uint64_t v88 = *(void *)(v39 + 680);
                  }
                  uint64_t v73 = v83.i64[1];
                  if (v83.i64[1] >= v84[0])
                  {
                    uint64_t v74 = sub_100B61EA4(v83.i64, (uint64_t)buf);
                  }
                  else
                  {
                    sub_100058DB0((void *)v83.i64[1], *(char **)buf);
                    *(void *)(v73 + 24) = 0;
                    *(_OWORD *)(v73 + 32) = *(_OWORD *)&buf[8];
                    *(void *)(v73 + 48) = v88;
                    uint64_t v88 = 0;
                    *(_OWORD *)&uint8_t buf[8] = 0uLL;
                    *(void *)(v73 + 24) = sub_100333A04;
                    uint64_t v74 = v73 + 56;
                  }
                  v83.i64[1] = v74;
                  if (SHIBYTE(v88) < 0) {
                    operator delete(*(void **)&buf[8]);
                  }
                  if (*(unsigned char *)(v39 + 888))
                  {
LABEL_159:
                    if (!*(unsigned char *)(v39 + 784)) {
                      goto LABEL_160;
                    }
                    *(void *)long long buf = "Imsi";
                    if (*(char *)(v39 + 783) < 0)
                    {
                      sub_10004FC84(&buf[8], *(void **)(v39 + 760), *(void *)(v39 + 768));
                    }
                    else
                    {
                      *(_OWORD *)&uint8_t buf[8] = *(_OWORD *)(v39 + 760);
                      uint64_t v88 = *(void *)(v39 + 776);
                    }
                    uint64_t v75 = v83.i64[1];
                    if (v83.i64[1] >= v84[0])
                    {
                      uint64_t v76 = sub_100B61EA4(v83.i64, (uint64_t)buf);
                    }
                    else
                    {
                      sub_100058DB0((void *)v83.i64[1], *(char **)buf);
                      *(void *)(v75 + 24) = 0;
                      *(_OWORD *)(v75 + 32) = *(_OWORD *)&buf[8];
                      *(void *)(v75 + 48) = v88;
                      uint64_t v88 = 0;
                      *(_OWORD *)&uint8_t buf[8] = 0uLL;
                      *(void *)(v75 + 24) = sub_100333A04;
                      uint64_t v76 = v75 + 56;
                    }
                    v83.i64[1] = v76;
                    if (SHIBYTE(v88) < 0) {
                      operator delete(*(void **)&buf[8]);
                    }
                    if (*(unsigned char *)(v39 + 888))
                    {
LABEL_160:
                      if (!*(unsigned char *)(v39 + 752)) {
                        goto LABEL_161;
                      }
                      *(void *)long long buf = "CarrierTransferData";
                      if (*(char *)(v39 + 751) < 0)
                      {
                        sub_10004FC84(&buf[8], *(void **)(v39 + 728), *(void *)(v39 + 736));
                      }
                      else
                      {
                        *(_OWORD *)&uint8_t buf[8] = *(_OWORD *)(v39 + 728);
                        uint64_t v88 = *(void *)(v39 + 744);
                      }
                      uint64_t v77 = v83.i64[1];
                      if (v83.i64[1] >= v84[0])
                      {
                        uint64_t v78 = sub_100B61EA4(v83.i64, (uint64_t)buf);
                      }
                      else
                      {
                        sub_100058DB0((void *)v83.i64[1], *(char **)buf);
                        *(void *)(v77 + 24) = 0;
                        *(_OWORD *)(v77 + 32) = *(_OWORD *)&buf[8];
                        *(void *)(v77 + 48) = v88;
                        uint64_t v88 = 0;
                        *(_OWORD *)&uint8_t buf[8] = 0uLL;
                        *(void *)(v77 + 24) = sub_100333A04;
                        uint64_t v78 = v77 + 56;
                      }
                      v83.i64[1] = v78;
                      if (SHIBYTE(v88) < 0) {
                        operator delete(*(void **)&buf[8]);
                      }
                      if (*(unsigned char *)(v39 + 888))
                      {
LABEL_161:
                        if (*(unsigned char *)(v39 + 720))
                        {
                          *(void *)long long buf = "TransferTokenExpiration";
                          if (*(char *)(v39 + 719) < 0)
                          {
                            sub_10004FC84(&buf[8], *(void **)(v39 + 696), *(void *)(v39 + 704));
                          }
                          else
                          {
                            *(_OWORD *)&uint8_t buf[8] = *(_OWORD *)(v39 + 696);
                            uint64_t v88 = *(void *)(v39 + 712);
                          }
                          uint64_t v79 = v83.i64[1];
                          if (v83.i64[1] >= v84[0])
                          {
                            uint64_t v80 = sub_100B61EA4(v83.i64, (uint64_t)buf);
                          }
                          else
                          {
                            sub_100058DB0((void *)v83.i64[1], *(char **)buf);
                            *(void *)(v79 + 24) = 0;
                            *(_OWORD *)(v79 + 32) = *(_OWORD *)&buf[8];
                            *(void *)(v79 + 48) = v88;
                            uint64_t v88 = 0;
                            *(_OWORD *)&uint8_t buf[8] = 0uLL;
                            *(void *)(v79 + 24) = sub_100333A04;
                            uint64_t v80 = v79 + 56;
                          }
                          v83.i64[1] = v80;
                          if (SHIBYTE(v88) < 0) {
                            operator delete(*(void **)&buf[8]);
                          }
                        }
                      }
                    }
                  }
                }
                if (*(unsigned char *)(v39 + 624))
                {
                  sub_100CD6B88((const void **)(v39 + 224), v39 + 320, (uint64_t)__p);
                  *(void *)long long buf = "PhoneNumber";
                  *(_OWORD *)&uint8_t buf[8] = *(_OWORD *)__p;
                  uint64_t v88 = v86;
                  __p[0] = 0;
                  __p[1] = 0;
                  uint64_t v86 = 0;
                  uint64_t v81 = v83.i64[1];
                  if (v83.i64[1] >= v84[0])
                  {
                    v83.i64[1] = sub_100B61EA4(v83.i64, (uint64_t)buf);
                    if (SHIBYTE(v88) < 0) {
                      operator delete(*(void **)&buf[8]);
                    }
                  }
                  else
                  {
                    sub_100058DB0((void *)v83.i64[1], "PhoneNumber");
                    *(_OWORD *)(v81 + 32) = *(_OWORD *)&buf[8];
                    *(void *)(v81 + 48) = v88;
                    *(void *)(v81 + 24) = sub_100333A04;
                    v83.i64[1] = v81 + 56;
                  }
                  if (SHIBYTE(v86) < 0) {
                    operator delete(__p[0]);
                  }
                }
                (*(void (**)(uint64_t, uint64_t, int64x2_t *))(*(void *)v43 + 120))(v43, a3, &v83);
                *(void *)long long buf = &v83;
                sub_100333C9C((void ***)buf);
              }
              sub_10004D2C8(v42);
            }
          }
        }
      }
    }
    return;
  }
  a2 = *(unsigned __int8 **)a2;
  if (!memcmp(a2, v18, v13)) {
    goto LABEL_42;
  }
  char v27 = a1[5];
  if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
  {
LABEL_32:
    if (v17 < 0) {
      uint64_t v15 = (unsigned __int8 **)*v15;
    }
    if (*(char *)(a3 + 23) >= 0) {
      uint64_t v28 = (unsigned __int8 *)a3;
    }
    else {
      uint64_t v28 = *(unsigned __int8 **)a3;
    }
    *(_DWORD *)long long buf = 136315650;
    *(void *)&uint8_t buf[4] = a2;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&unsigned char buf[14] = v15;
    *(_WORD *)&unsigned char buf[22] = 2080;
    uint64_t v88 = (uint64_t)v28;
    uint64_t v22 = "uuid mismatched : %s != %s, source iccid : %s. drop tr.rsp";
    char v23 = v27;
    uint32_t v24 = 32;
    goto LABEL_38;
  }
}

void sub_100B4E5E0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, char *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,char a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  a15 = &a11;
  sub_100333C9C((void ***)&a15);
  sub_10004D2C8(v28);
  _Unwind_Resume(a1);
}

uint64_t sub_100B4E6D8(uint64_t a1)
{
  sub_100313790((void *)(a1 + 24));
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

uint64_t sub_100B4E710(uint64_t a1, const void **a2, long long **a3)
{
  uint64_t v9 = *(void *)(a1 + 144);
  uint64_t v7 = *(void *)(a1 + 152);
  char v8 = (uint64_t *)(a1 + 144);
  while (v7 != v9)
    uint64_t v7 = sub_1000C52BC(v7 - 400);
  *(void *)(a1 + 152) = v9;
  memset(v39, 0, sizeof(v39));
  uint64_t v38 = 0;
  long long v36 = 0u;
  long long v37 = 0u;
  *(_OWORD *)uint64_t v35 = 0u;
  char v27 = 0;
  uint64_t v28 = 0;
  uint64_t v29 = 0;
  sub_100058198(&v26, a2);
  sub_100CCCA04((id *)&v26, &v27);
  sub_100057D78(&v26);
  *(void *)long long buf = 0;
  uint64_t v32 = 0;
  uint64_t v33 = 0;
  memset(v25, 0, sizeof(v25));
  sub_1000302C0((char *)v25, *a3, a3[1], 0xAAAAAAAAAAAAAAABLL * (((char *)a3[1] - (char *)*a3) >> 3));
  uint64_t v10 = (os_log_t *)(a1 + 40);
  uint64_t v11 = sub_100CD7B0C((os_log_t *)(a1 + 40), (const unsigned __int8 **)&v27, (void *)(a1 + 720), (uint64_t *)buf, v25, (uint64_t)v39, (uint64_t)v35);
  v24[0] = (void **)v25;
  sub_100047F64(v24);
  v24[0] = (void **)buf;
  sub_10010DF1C(v24);
  if (v11)
  {
    memset(&v24[1], 0, 32);
    v24[0] = (void **)&off_101A17F50;
    if (LOBYTE(v39[15])
      && (sub_10031203C((char *)buf, (long long *)((char *)&v39[15] + 8)),
          char v34 = 1,
          int v12 = sub_1006D10BC((uint64_t)v39, (uint64_t)buf, (uint64_t)v24),
          sub_10023F804((uint64_t)buf),
          v12))
    {
      sub_100058DB0(__p, "Target_TransferData_");
      sub_1008E268C((uint64_t)buf, (uint64_t)v24);
      uint64_t v19 = 0;
      uint64_t v20 = 0;
      BOOL v21 = 0;
      v30[0] = (void **)&v19;
      v30[1] = 0;
      uint64_t v19 = (char *)operator new(0x28uLL);
      uint64_t v20 = v19;
      size_t v13 = v19 + 40;
      BOOL v21 = v19 + 40;
      sub_1008E268C((uint64_t)v19, (uint64_t)buf);
      uint64_t v20 = v13;
      sub_100CD467C((os_log_t *)(a1 + 40), (uint64_t **)__p, (uint64_t *)&v19);
      v30[0] = (void **)&v19;
      sub_100B61728(v30);
      sub_1008E25A0((PB::Base *)buf);
      if (v23 < 0) {
        operator delete(__p[0]);
      }
    }
    else
    {
      uint64_t v15 = *v10;
      if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "Unable to serialize manatee device info", buf, 2u);
      }
    }
    unint64_t v16 = *(void *)(a1 + 152);
    if (v16 >= *(void *)(a1 + 160))
    {
      uint64_t v17 = sub_100341B84(v8, (uint64_t)v39);
    }
    else
    {
      sub_100341CA4(*(void *)(a1 + 152), (uint64_t)v39);
      uint64_t v17 = v16 + 400;
      *(void *)(a1 + 152) = v16 + 400;
    }
    *(void *)(a1 + 152) = v17;
    sub_1008E25A0((PB::Base *)v24);
  }
  else
  {
    uint64_t v14 = *v10;
    if (os_log_type_enabled(*v10, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "Failed to get transfer Info", buf, 2u);
    }
  }
  if (v27)
  {
    uint64_t v28 = v27;
    operator delete(v27);
  }
  if (SBYTE7(v36) < 0) {
    operator delete(v35[0]);
  }
  sub_1000C52BC((uint64_t)v39);
  return v11;
}

void sub_100B4EA64(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26,void *a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,char a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,void *a52,uint64_t a53,int a54,__int16 a55,char a56,char a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,char a63)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  sub_1008E25A0((PB::Base *)&a18);
  if (a27)
  {
    a28 = (uint64_t)a27;
    operator delete(a27);
  }
  if (a57 < 0) {
    operator delete(a52);
  }
  sub_1000C52BC((uint64_t)&a63);
  _Unwind_Resume(a1);
}

void sub_100B4EB30(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a1 + 328);
  if (v5 == *(void *)(a1 + 312))
  {
    uint64_t v17 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long __p = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "No ongoing transfer", __p, 2u);
    }
    goto LABEL_21;
  }
  if (!*(unsigned char *)(v5 + 216))
  {
    BOOL v18 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long __p = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "invalid profile details", __p, 2u);
    }
LABEL_21:
    sub_1000607A8(a3, 0);
    return;
  }
  uint64_t v6 = *(std::__shared_weak_count **)(a1 + 88);
  if (v6)
  {
    char v8 = std::__shared_weak_count::lock(v6);
    if (v8)
    {
      uint64_t v9 = *(void *)(a1 + 80);
      if (v9)
      {
        bzero(v40, 0x4E8uLL);
        (*(void (**)(void *__return_ptr, uint64_t, uint64_t *))(*(void *)v9 + 168))(v40, v9, a2);
        if (!v41)
        {
          uint64_t v20 = *(NSObject **)(a1 + 40);
          if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)long long __p = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, "Pending plan not found. Cannot start recovery monitor mode", __p, 2u);
          }
          sub_1000607A8(a3, 0);
          goto LABEL_51;
        }
        uint64_t v10 = *(std::__shared_weak_count **)(a1 + 72);
        if (v10)
        {
          uint64_t v11 = std::__shared_weak_count::lock(v10);
          if (v11)
          {
            uint64_t v12 = *(void *)(a1 + 64);
            if (v12)
            {
              int v13 = (*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(**(void **)(a1 + 48) + 976))(*(void *)(a1 + 48), v5 + 96, v5 + 120, v5 + 144, v5 + 168, v5 + 16);
              sub_100058DB0(__p, "IsTransferUsingRecoveryWithoutExplicitIccidMapping");
              *(void *)&long long v36 = 1;
              uint64_t v35 = (uint64_t (*)(void, void, void, void, void))sub_100B6D7B0;
              long long v23 = 0uLL;
              __s = 0;
              v26[0] = &__s;
              v26[1] = 0;
              __s = (char *)operator new(0x38uLL);
              *(void *)&long long v23 = __s;
              *((void *)&v23 + 1) = __s + 56;
              *(void *)&long long v23 = sub_100333B38((uint64_t)&v23 + 8, (uint64_t)__p, (uint64_t)v38, (uint64_t)__s);
              (*(void (**)(uint64_t, uint64_t *, char **))(*(void *)v9 + 120))(v9, a2, &__s);
              v26[0] = &__s;
              sub_100333C9C((void ***)v26);
              sub_100146540(&v35);
              if (v34 < 0) {
                operator delete(*(void **)__p);
              }
              uint64_t v14 = *(NSObject **)(a1 + 40);
              if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
              {
                uint64_t v15 = a2;
                if (*((char *)a2 + 23) < 0) {
                  uint64_t v15 = (uint64_t *)*a2;
                }
                *(_DWORD *)long long __p = 136315394;
                *(void *)&__p[4] = v15;
                __int16 v32 = 1024;
                int v33 = v13 ^ 1;
                _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I Attempting recovery installation of plan with source iccid: %s, useDS=%d", __p, 0x12u);
              }
              if (v13)
              {
                v26[0] = 0;
                v26[1] = 0;
                uint64_t v27 = 0;
                sub_100B4AC10(a1, v26);
                __s = "AltSmdpFqdn";
                if (SHIBYTE(v27) < 0)
                {
                  sub_10004FC84(&v23, v26[0], (unint64_t)v26[1]);
                  unint64_t v16 = __s;
                }
                else
                {
                  long long v23 = *(_OWORD *)v26;
                  uint64_t v24 = v27;
                  unint64_t v16 = "AltSmdpFqdn";
                }
                sub_100058DB0(__p, v16);
                long long v36 = v23;
                uint64_t v37 = v24;
                uint64_t v24 = 0;
                long long v23 = 0uLL;
                uint64_t v35 = (uint64_t (*)(void, void, void, void, void))sub_100333A04;
                sub_100B4F35C(v25, (uint64_t)__p, 1uLL);
                (*(void (**)(uint64_t, uint64_t *, void **))(*(void *)v9 + 120))(v9, a2, v25);
                uint64_t v28 = v25;
                sub_100333C9C(&v28);
                sub_100146540(&v35);
                if (v34 < 0) {
                  operator delete(*(void **)__p);
                }
                if (SHIBYTE(v24) < 0) {
                  operator delete((void *)v23);
                }
                __p[0] = 0;
                LOBYTE(v35) = 0;
                (*(void (**)(uint64_t, uint64_t *, void **, unsigned char *, void, uint64_t))(*(void *)v12 + 136))(v12, a2, v26, __p, 0, 3);
                if ((_BYTE)v35 && v34 < 0) {
                  operator delete(*(void **)__p);
                }
                if (!v41) {
                  sub_10016C840();
                }
                (*(void (**)(uint64_t, void *))(*(void *)v9 + 304))(v9, v40);
                sub_1000607A8(a3, 0);
                if (SHIBYTE(v27) < 0) {
                  operator delete(v26[0]);
                }
              }
              else
              {
                bzero(&__p[8], 0x528uLL);
                *(void *)long long __p = a1;
                sub_1002598D0(&__p[8], *(void *)(a1 + 8), *(std::__shared_weak_count **)(a1 + 16));
                sub_1000DFC90((uint64_t)&v35, a3);
                v38[0] = v9;
                v38[1] = v8;
                atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
                sub_100311A9C(v39, (uint64_t)v40);
                sub_100B4F438((uint64_t)v29, (uint64_t)__p);
                sub_100B4F4F0((uint64_t)v30, (uint64_t)v29);
                sub_100B4B5F8((void *)a1, 3, (uint64_t)v30);
                sub_100313668(v30);
                sub_100B4F5C0((uint64_t)v29);
                sub_100B4F5C0((uint64_t)__p);
              }
LABEL_50:
              sub_10004D2C8(v11);
LABEL_51:
              if (v41) {
                sub_10030D10C((uint64_t)v40);
              }
LABEL_53:
              sub_10004D2C8(v8);
              return;
            }
          }
        }
        else
        {
          uint64_t v11 = 0;
        }
        BOOL v21 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)long long __p = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "delegate handler not available", __p, 2u);
        }
        sub_1000607A8(a3, 0);
        if (!v11) {
          goto LABEL_51;
        }
        goto LABEL_50;
      }
    }
  }
  else
  {
    char v8 = 0;
  }
  uint64_t v19 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long __p = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Pending transfer handler not available", __p, 2u);
  }
  sub_1000607A8(a3, 0);
  if (v8) {
    goto LABEL_53;
  }
}

void sub_100B4F1EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  if (a22 < 0) {
    operator delete(__p);
  }
  sub_10004D2C8(v23);
  if (LOBYTE(STACK[0xFC0])) {
    sub_10030D10C((uint64_t)&STACK[0xAE0]);
  }
  sub_10004D2C8(v22);
  _Unwind_Resume(a1);
}

void *sub_100B4F35C(void *a1, uint64_t a2, unint64_t a3)
{
  a1[2] = 0;
  uint64_t v4 = (uint64_t)(a1 + 2);
  *a1 = 0;
  a1[1] = 0;
  if (a3)
  {
    sub_10034235C(a1, a3);
    a1[1] = sub_100333B38(v4, a2, a2 + 56 * a3, a1[1]);
  }
  return a1;
}

void sub_100B4F3DC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  *(void *)(v9 + 8) = v10;
  sub_100333C9C(&a9);
  _Unwind_Resume(a1);
}

uint64_t sub_100B4F3FC(uint64_t a1)
{
  if (*(char *)(a1 + 23) < 0) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t sub_100B4F438(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = *(_OWORD *)a2;
  uint64_t v4 = *(void *)(a2 + 16);
  *(void *)(a1 + 16) = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 16), 1uLL, memory_order_relaxed);
  }
  sub_1000DFC90(a1 + 24, a2 + 24);
  uint64_t v5 = *(void *)(a2 + 64);
  *(void *)(a1 + 56) = *(void *)(a2 + 56);
  *(void *)(a1 + 64) = v5;
  if (v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
  }
  sub_100311A9C((unsigned char *)(a1 + 72), a2 + 72);
  return a1;
}

void sub_100B4F4BC(_Unwind_Exception *a1)
{
  uint64_t v4 = *(std::__shared_weak_count **)(v1 + 64);
  if (v4) {
    sub_10004D2C8(v4);
  }
  sub_100060644(v2);
  uint64_t v5 = *(std::__shared_weak_count **)(v1 + 16);
  if (v5) {
    std::__shared_weak_count::__release_weak(v5);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100B4F4F0(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 24) = 0;
  uint64_t v4 = (char *)operator new(0x538uLL);
  *(void *)uint64_t v4 = off_101A3F180;
  *(_OWORD *)(v4 + 8) = *(_OWORD *)a2;
  *((void *)v4 + 3) = *(void *)(a2 + 16);
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  sub_100023950((uint64_t)(v4 + 32), a2 + 24);
  *((_OWORD *)v4 + 4) = *(_OWORD *)(a2 + 56);
  *(void *)(a2 + 56) = 0;
  *(void *)(a2 + 64) = 0;
  sub_1003489A0(v4 + 80, a2 + 72);
  *(void *)(a1 + 24) = v4;
  return a1;
}

void sub_100B4F58C(_Unwind_Exception *a1)
{
  uint64_t v4 = (std::__shared_weak_count *)v1[9];
  if (v4) {
    sub_10004D2C8(v4);
  }
  sub_100060644(v2);
  uint64_t v5 = (std::__shared_weak_count *)v1[3];
  if (v5) {
    std::__shared_weak_count::__release_weak(v5);
  }
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100B4F5C0(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 1320)) {
    sub_10030D10C(a1 + 72);
  }
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 64);
  if (v2) {
    sub_10004D2C8(v2);
  }
  sub_100060644((void *)(a1 + 24));
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  return a1;
}

void sub_100B4F614(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 144);
  uint64_t v102 = *(void *)(a1 + 152);
  if (v2 != v102)
  {
    char v105 = (os_log_t *)(a1 + 40);
    std::string v103 = (uint64_t **)(a1 + 928);
    while (1)
    {
      sub_10098FAB8((uint64_t *)v2, (uint64_t)&v127);
      uint64_t v4 = v127;
      if (v127 != v128) {
        break;
      }
LABEL_245:
      sub_10005CD2C((uint64_t)&v127, v128[0]);
      v2 += 400;
      if (v2 == v102) {
        return;
      }
    }
    while (1)
    {
      uint64_t v5 = v4 + 4;
      uint64_t v137 = 0;
      memset(v136, 0, sizeof(v136));
      long long v134 = 0u;
      memset(v135, 0, sizeof(v135));
      memset(v133, 0, sizeof(v133));
      long long v132 = 0u;
      if ((sub_10098E79C(v2, (unsigned __int8 **)v4 + 4, (uint64_t)&v132) & 1) == 0)
      {
        uint64_t v17 = *v105;
        if (os_log_type_enabled(*v105, OS_LOG_TYPE_ERROR))
        {
          LOWORD(buf[0].__r_.__value_.__l.__data_) = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "No vinyl details available", (uint8_t *)buf, 2u);
        }
        goto LABEL_133;
      }
      (***(void (****)(std::string *__return_ptr))(a1 + 48))(buf);
      ServiceMap = (std::mutex *)Registry::getServiceMap(v6, (Registry *)buf[0].__r_.__value_.__l.__data_);
      char v8 = ServiceMap;
      if (v9 < 0)
      {
        uint64_t v10 = (unsigned __int8 *)(v9 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v11 = 5381;
        do
        {
          uint64_t v9 = v11;
          unsigned int v12 = *v10++;
          uint64_t v11 = (33 * v11) ^ v12;
        }
        while (v12);
      }
      std::mutex::lock(ServiceMap);
      *(void *)__int16 v138 = v9;
      int v13 = sub_10004D37C(&v8[1].__m_.__sig, (unint64_t *)v138);
      if (v13)
      {
        uint64_t v15 = v13[3];
        uint64_t v14 = (std::__shared_weak_count *)v13[4];
        if (v14)
        {
          atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v8);
          atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v14);
          char v16 = 0;
          goto LABEL_15;
        }
      }
      else
      {
        uint64_t v15 = 0;
      }
      std::mutex::unlock(v8);
      uint64_t v14 = 0;
      char v16 = 1;
LABEL_15:
      if (buf[0].__r_.__value_.__l.__size_) {
        sub_10004D2C8((std::__shared_weak_count *)buf[0].__r_.__value_.__l.__size_);
      }
      if (!v15) {
        goto LABEL_27;
      }
      memset(buf, 0, 24);
      (*(void (**)(std::string *__return_ptr, uint64_t, _OWORD *))(*(void *)v15 + 24))(buf, v15, v135);
      std::string::size_type size = HIBYTE(buf[0].__r_.__value_.__r.__words[2]);
      int v19 = SHIBYTE(buf[0].__r_.__value_.__r.__words[2]);
      if ((buf[0].__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        std::string::size_type size = buf[0].__r_.__value_.__l.__size_;
      }
      if (size)
      {
        uint64_t v20 = *v105;
        if (os_log_type_enabled(*v105, OS_LOG_TYPE_DEFAULT))
        {
          BOOL v21 = (std::string *)buf[0].__r_.__value_.__r.__words[0];
          if (v19 >= 0) {
            BOOL v21 = buf;
          }
          *(_DWORD *)__int16 v138 = 136446210;
          *(void *)&v138[4] = v21;
          _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#I Updating country code: %{public}s", v138, 0xCu);
        }
        sub_10098F3C4(v2, (void **)v4 + 4, buf);
        LOBYTE(v19) = *((unsigned char *)&buf[0].__r_.__value_.__s + 23);
      }
      if ((v19 & 0x80) == 0)
      {
LABEL_27:
        if (v16) {
          goto LABEL_29;
        }
LABEL_28:
        sub_10004D2C8(v14);
        goto LABEL_29;
      }
      operator delete(buf[0].__r_.__value_.__l.__data_);
      if ((v16 & 1) == 0) {
        goto LABEL_28;
      }
LABEL_29:
      uint64_t v22 = *a2;
      uint64_t v23 = a2[1];
      buf[0].__r_.__value_.__s.__data_[0] = 0;
      if (sub_1000D8740(v22, v23, (unsigned __int8 **)v4 + 4) == a2[1]) {
        goto LABEL_49;
      }
      if (*((char *)v4 + 55) < 0)
      {
        sub_10004FC84(__p, v4[4], (unint64_t)v4[5]);
      }
      else
      {
        *(_OWORD *)long long __p = *v5;
        std::string::size_type v126 = v4[6];
      }
      uint64_t v24 = *(void *)(v2 + 368);
      uint64_t v25 = *(void *)(v2 + 376);
      while (1)
      {
        if (v24 == v25)
        {
          int v27 = 0;
          goto LABEL_41;
        }
        int v26 = sub_100046F68(v24 + 56, __p);
        if ((void **)(v24 + 64) != v26) {
          break;
        }
        v24 += 80;
      }
      *((_WORD *)v26 + 112) = 263;
      int v27 = 1;
LABEL_41:
      if (SHIBYTE(v126) < 0)
      {
        operator delete(__p[0]);
        if (!v27)
        {
LABEL_49:
          if (*((char *)v4 + 55) < 0)
          {
            sub_10004FC84(__dst, v4[4], (unint64_t)v4[5]);
          }
          else
          {
            *(_OWORD *)long long __dst = *v5;
            xpc_object_t v124 = v4[6];
          }
          sub_10098F2E0(v2, __dst);
          if (SHIBYTE(v124) < 0) {
            operator delete(__dst[0]);
          }
          if (*((char *)v4 + 55) < 0)
          {
            sub_10004FC84(v121, v4[4], (unint64_t)v4[5]);
          }
          else
          {
            *(_OWORD *)xpc_object_t v121 = *v5;
            std::string::size_type v122 = v4[6];
          }
          uint64_t v32 = sub_10098ECAC(v2, (uint64_t)v121);
          if (SHIBYTE(v122) < 0) {
            operator delete(v121[0]);
          }
          int v33 = *v105;
          if (os_log_type_enabled(*v105, OS_LOG_TYPE_DEFAULT))
          {
            char v34 = sub_1008A1E44(v32);
            std::string::size_type v35 = (std::string::size_type)(v4 + 4);
            if (*((char *)v4 + 55) < 0) {
              std::string::size_type v35 = *(void *)v5;
            }
            LODWORD(buf[0].__r_.__value_.__l.__data_) = 136446466;
            *(std::string::size_type *)((char *)buf[0].__r_.__value_.__r.__words + 4) = (std::string::size_type)v34;
            WORD2(buf[0].__r_.__value_.__r.__words[1]) = 2080;
            *(std::string::size_type *)((char *)&buf[0].__r_.__value_.__r.__words[1] + 6) = v35;
            _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "#I Transfer type available from source: %{public}s, iccid: %s", (uint8_t *)buf, 0x16u);
          }
          if ((sub_10098EDA0(v2, (uint64_t)v133) & 1) == 0)
          {
            if (BYTE9(v134))
            {
              if (!sub_1008A200C(v32)) {
                goto LABEL_76;
              }
LABEL_75:
              sub_1000F29CC(v103, (void **)v133, (uint64_t)v133);
              goto LABEL_76;
            }
            *(void *)&v138[8] = 0;
            *(void *)__int16 v138 = 0;
            sub_1000C5AB4((uint64_t)buf, (uint64_t)&v132);
            char v141 = 1;
            sub_100B50AC0((const void **)v138, a1, (uint64_t)buf);
            if (v141) {
              sub_1000C584C((uint64_t)buf);
            }
            if (*(void *)v138) {
              int v36 = sub_100CEBB54(*(uint64_t *)v138);
            }
            else {
              int v36 = 0;
            }
            if (*(void *)&v138[8]) {
              sub_10004D2C8(*(std::__shared_weak_count **)&v138[8]);
            }
            if (v36) {
              goto LABEL_75;
            }
          }
LABEL_76:
          unsigned __int8 v120 = 0;
          unsigned __int8 v120 = (*(uint64_t (**)(void, _OWORD *, char *, _OWORD *, char *, char **))(**(void **)(a1 + 48)
                                                                                                + 240))(*(void *)(a1 + 48), v135, (char *)&v135[1] + 8, v136, (char *)&v136[1] + 8, v4 + 4);
          CFDictionaryRef theDict = 0;
          (*(void (**)(CFDictionaryRef *__return_ptr))(**(void **)(a1 + 48) + 768))(&theDict);
          if (theDict) {
            uint64_t v37 = sub_100080778;
          }
          else {
            uint64_t v37 = 0;
          }
          if (v37)
          {
            if (CFDictionaryContainsKey(theDict, @"PhoneAccountTransfer"))
            {
              CFDictionaryRef v38 = (const __CFDictionary *)CFDictionaryGetValue(theDict, @"PhoneAccountTransfer");
              value = 0;
              int ValueIfPresent = CFDictionaryGetValueIfPresent(v38, @"MinCompatibleOS", (const void **)&value);
              BOOL v40 = *v105;
              BOOL v41 = os_log_type_enabled(*v105, OS_LOG_TYPE_DEFAULT);
              if (ValueIfPresent)
              {
                if (v41)
                {
                  LODWORD(buf[0].__r_.__value_.__l.__data_) = 138412290;
                  *(std::string::size_type *)((char *)buf[0].__r_.__value_.__r.__words + 4) = (std::string::size_type)value;
                  _os_log_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_DEFAULT, "#I MinCompatibleOS : %@", (uint8_t *)buf, 0xCu);
                }
                CFTypeID TypeID = CFStringGetTypeID();
                if (TypeID == CFGetTypeID(value))
                {
                  memset(buf, 0, 24);
                  ctu::cf::assign();
                  uint64_t v43 = (void *)buf[0].__r_.__value_.__r.__words[0];
                  v129[0] = buf[0].__r_.__value_.__r.__words[2];
                  *(_DWORD *)((char *)v129 + 3) = *(_DWORD *)((char *)&buf[0].__r_.__value_.__r.__words[2] + 3);
                  int v44 = SHIBYTE(buf[0].__r_.__value_.__r.__words[2]);
                  if (SHIBYTE(buf[0].__r_.__value_.__r.__words[2]) < 0)
                  {
                    sub_10004FC84(v138, buf[0].__r_.__value_.__l.__data_, buf[0].__r_.__value_.__l.__size_);
                  }
                  else
                  {
                    *(_OWORD *)__int16 v138 = *(_OWORD *)&buf[0].__r_.__value_.__l.__data_;
                    *(_DWORD *)&v138[16] = v129[0];
                    *(_DWORD *)&v138[19] = *(_DWORD *)((char *)v129 + 3);
                    char v139 = HIBYTE(buf[0].__r_.__value_.__r.__words[2]);
                  }
                  unsigned int v49 = sub_100CD1928(v138);
                  if (v139 < 0) {
                    operator delete(*(void **)v138);
                  }
                  uint64_t v75 = *v105;
                  if (os_log_type_enabled(*v105, OS_LOG_TYPE_DEFAULT))
                  {
                    LODWORD(buf[0].__r_.__value_.__l.__data_) = 67109120;
                    HIDWORD(buf[0].__r_.__value_.__r.__words[0]) = v49;
                    _os_log_impl((void *)&_mh_execute_header, v75, OS_LOG_TYPE_DEFAULT, "#I minimum supported source OS version is %d", (uint8_t *)buf, 8u);
                  }
                  if (v44 < 0) {
                    operator delete(v43);
                  }
                }
                else
                {
                  uint64_t v71 = *v105;
                  if (os_log_type_enabled(*v105, OS_LOG_TYPE_ERROR))
                  {
                    LOWORD(buf[0].__r_.__value_.__l.__data_) = 0;
                    _os_log_error_impl((void *)&_mh_execute_header, v71, OS_LOG_TYPE_ERROR, "invalid format of MinCompatibleOS", (uint8_t *)buf, 2u);
                  }
                  unsigned int v49 = -1;
                }
LABEL_96:
                sub_100057D78((const void **)&theDict);
                size_t v50 = *v105;
                if (os_log_type_enabled(*v105, OS_LOG_TYPE_DEFAULT))
                {
                  std::string::size_type v52 = printers::asString((printers *)&v120, v51);
                  std::string::size_type v53 = (std::string::size_type)(v4 + 4);
                  if (*((char *)v4 + 55) < 0) {
                    std::string::size_type v53 = *(void *)v5;
                  }
                  LODWORD(buf[0].__r_.__value_.__l.__data_) = 136446466;
                  *(std::string::size_type *)((char *)buf[0].__r_.__value_.__r.__words + 4) = v52;
                  WORD2(buf[0].__r_.__value_.__r.__words[1]) = 2080;
                  *(std::string::size_type *)((char *)&buf[0].__r_.__value_.__r.__words[1] + 6) = v53;
                  _os_log_impl((void *)&_mh_execute_header, v50, OS_LOG_TYPE_DEFAULT, "#I iphone plan transfer support on target:[%{public}s] for iccid: %s", (uint8_t *)buf, 0x16u);
                }
                if (!v120 || (v32 - 129) < 2 || v32 == 16 || v32 == 6)
                {
                  memset(buf, 0, 24);
                  (*(void (**)(std::string *__return_ptr))(**(void **)(a1 + 48) + 792))(buf);
                  if (v32 == 16) {
                    goto LABEL_115;
                  }
                  std::string::size_type v54 = HIBYTE(buf[0].__r_.__value_.__r.__words[2]);
                  if ((buf[0].__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
                    std::string::size_type v54 = buf[0].__r_.__value_.__l.__size_;
                  }
                  if (!v54)
                  {
LABEL_115:
                    int v59 = v120;
                    unsigned int v60 = *(_DWORD *)(v2 + 232);
                    uint64_t v61 = *(void *)(a1 + 800);
                    if (*(char *)(v61 + 47) < 0)
                    {
                      sub_10004FC84(v118, *(void **)(v61 + 24), *(void *)(v61 + 32));
                    }
                    else
                    {
                      *(_OWORD *)std::string::size_type v118 = *(_OWORD *)(v61 + 24);
                      uint64_t v119 = *(void *)(v61 + 40);
                    }
                    unsigned int v62 = sub_100CD1928((const char *)v118);
                    int v58 = sub_100CDCFE8(v32, v59 != 0, v60, v62, v49);
                    if (SHIBYTE(v119) < 0) {
                      operator delete(v118[0]);
                    }
                    sub_10098EE88(v2, (void **)v4 + 4);
                  }
                  else
                  {
                    sub_10098F340((std::string *)v2, (void **)v4 + 4, buf);
                    unint64_t v55 = *v105;
                    if (os_log_type_enabled(*v105, OS_LOG_TYPE_DEFAULT))
                    {
                      unint64_t v56 = buf;
                      if ((buf[0].__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
                        unint64_t v56 = (std::string *)buf[0].__r_.__value_.__r.__words[0];
                      }
                      uint64_t v57 = v4 + 4;
                      if (*((char *)v4 + 55) < 0) {
                        uint64_t v57 = *(char ***)v5;
                      }
                      *(_DWORD *)__int16 v138 = 136446466;
                      *(void *)&v138[4] = v56;
                      *(_WORD *)&v138[12] = 2080;
                      *(void *)&v138[14] = v57;
                      _os_log_impl((void *)&_mh_execute_header, v55, OS_LOG_TYPE_DEFAULT, "#I Setting transfer endpoint to: (%{public}s) for iccid: %s", v138, 0x16u);
                    }
                    int v58 = 8;
                  }
                  uint64_t v63 = *v105;
                  if (os_log_type_enabled(*v105, OS_LOG_TYPE_DEFAULT))
                  {
                    uint64_t v64 = sub_1008A1E44(v58);
                    long long v65 = v4 + 4;
                    if (*((char *)v4 + 55) < 0) {
                      long long v65 = *(char ***)v5;
                    }
                    *(_DWORD *)__int16 v138 = 136446466;
                    *(void *)&v138[4] = v64;
                    *(_WORD *)&v138[12] = 2080;
                    *(void *)&v138[14] = v65;
                    _os_log_impl((void *)&_mh_execute_header, v63, OS_LOG_TYPE_DEFAULT, "#I No Magnolia support, setting transfer type to: %{public}s for iccid: %s", v138, 0x16u);
                  }
                  if (*((char *)v4 + 55) < 0)
                  {
                    sub_10004FC84(v116, v4[4], (unint64_t)v4[5]);
                  }
                  else
                  {
                    *(_OWORD *)int64_t v116 = *v5;
                    xpc_object_t v117 = v4[6];
                  }
                  sub_10098F270(v2, v116, v58);
                  if (SHIBYTE(v117) < 0) {
                    operator delete(v116[0]);
                  }
                  if ((SHIBYTE(buf[0].__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
                    goto LABEL_133;
                  }
                  uint64_t v66 = (void *)buf[0].__r_.__value_.__r.__words[0];
                  goto LABEL_132;
                }
                unsigned int v70 = *(_DWORD *)(v2 + 232);
                if (v70 && v70 < v49)
                {
                  sub_10098EE88(v2, (void **)v4 + 4);
                  if (*((char *)v4 + 55) < 0)
                  {
                    sub_10004FC84(v114, v4[4], (unint64_t)v4[5]);
                  }
                  else
                  {
                    *(_OWORD *)int64_t v114 = *v5;
                    long long v115 = v4[6];
                  }
                  uint64_t v76 = *(void *)(v2 + 368);
                  uint64_t v77 = *(void *)(v2 + 376);
                  while (v76 != v77)
                  {
                    uint64_t v78 = sub_100046F68(v76 + 56, v114);
                    if ((void **)(v76 + 64) != v78)
                    {
                      *((_WORD *)v78 + 112) = 386;
                      break;
                    }
                    v76 += 80;
                  }
                  if (SHIBYTE(v115) < 0) {
                    operator delete(v114[0]);
                  }
                  os_log_t v79 = *v105;
                  if (!os_log_type_enabled(*v105, OS_LOG_TYPE_DEFAULT)) {
                    goto LABEL_133;
                  }
                  if (*((char *)v4 + 55) < 0) {
                    uint64_t v5 = *(_OWORD **)v5;
                  }
                  int v80 = *(_DWORD *)(v2 + 232);
                  LODWORD(buf[0].__r_.__value_.__l.__data_) = 136315394;
                  *(std::string::size_type *)((char *)buf[0].__r_.__value_.__r.__words + 4) = (std::string::size_type)v5;
                  WORD2(buf[0].__r_.__value_.__r.__words[1]) = 1024;
                  *(_DWORD *)((char *)&buf[0].__r_.__value_.__r.__words[1] + 6) = v80;
                  uint64_t v29 = v79;
                  uint64_t v30 = "#I Sim transfer for iccid: [%s] not supported for source device OS version: [%d]";
LABEL_187:
                  uint32_t v31 = 18;
                }
                else
                {
                  LOBYTE(theDict) = 0;
                  sub_10098EA6C(v2, (unsigned __int8 **)v4 + 4, (BOOL *)&theDict);
                  if (!(_BYTE)theDict) {
                    goto LABEL_192;
                  }
                  if (*(_DWORD *)(v2 + 232) >> 17 <= 6u)
                  {
                    sub_10098EE88(v2, (void **)v4 + 4);
                    if (*((char *)v4 + 55) < 0)
                    {
                      sub_10004FC84(v112, v4[4], (unint64_t)v4[5]);
                    }
                    else
                    {
                      *(_OWORD *)std::string::size_type v112 = *v5;
                      unint64_t v113 = v4[6];
                    }
                    uint64_t v81 = *(void *)(v2 + 368);
                    uint64_t v82 = *(void *)(v2 + 376);
                    while (v81 != v82)
                    {
                      int64x2_t v83 = sub_100046F68(v81 + 56, v112);
                      if ((void **)(v81 + 64) != v83)
                      {
                        *((_WORD *)v83 + 112) = 386;
                        break;
                      }
                      v81 += 80;
                    }
                    if (SHIBYTE(v113) < 0) {
                      operator delete(v112[0]);
                    }
                    os_log_t v84 = *v105;
                    if (!os_log_type_enabled(*v105, OS_LOG_TYPE_DEFAULT)) {
                      goto LABEL_133;
                    }
                    if (*((char *)v4 + 55) < 0) {
                      uint64_t v5 = *(_OWORD **)v5;
                    }
                    int v85 = *(_DWORD *)(v2 + 232);
                    LODWORD(buf[0].__r_.__value_.__l.__data_) = 136315394;
                    *(std::string::size_type *)((char *)buf[0].__r_.__value_.__r.__words + 4) = (std::string::size_type)v5;
                    WORD2(buf[0].__r_.__value_.__r.__words[1]) = 1024;
                    *(_DWORD *)((char *)&buf[0].__r_.__value_.__r.__words[1] + 6) = v85;
                    uint64_t v29 = v84;
                    uint64_t v30 = "#I Physical sim transfer for iccid: [%s] not supported for OS version: [%d]";
                    goto LABEL_187;
                  }
                  *(void *)&v138[8] = 0;
                  *(void *)__int16 v138 = 0;
                  sub_1000C5AB4((uint64_t)buf, (uint64_t)&v132);
                  char v141 = 1;
                  sub_100B50AC0((const void **)v138, a1, (uint64_t)buf);
                  if (v141) {
                    sub_1000C584C((uint64_t)buf);
                  }
                  BOOL v74 = *(void *)v138
                     && (unsigned __int16 v73 = sub_100B50DA4(v105, *(CFDictionaryRef *)(*(void *)v138 + 64), @"SupportPhysicalSIMtoESIMTransfer", (uint64_t *)v133), v73 >= 0x100u)&& v73 != 0;
                  if (*(void *)&v138[8]) {
                    sub_10004D2C8(*(std::__shared_weak_count **)&v138[8]);
                  }
                  if (v74)
                  {
LABEL_192:
                    *(void *)&v138[8] = 0;
                    *(void *)__int16 v138 = 0;
                    sub_1000C5AB4((uint64_t)buf, (uint64_t)&v132);
                    char v141 = 1;
                    sub_100B50AC0((const void **)v138, a1, (uint64_t)buf);
                    if (v141) {
                      sub_1000C584C((uint64_t)buf);
                    }
                    if (*(void *)v138)
                    {
                      unsigned __int16 v86 = sub_100B50DA4(v105, *(CFDictionaryRef *)(*(void *)v138 + 64), @"AllowCellularPlanTransferTarget", (uint64_t *)v133);
                      BOOL v87 = v86 >= 0x100u && v86 == 0;
                    }
                    else
                    {
                      BOOL v87 = 1;
                    }
                    if (*(void *)&v138[8]) {
                      sub_10004D2C8(*(std::__shared_weak_count **)&v138[8]);
                    }
                    if (v87)
                    {
                      uint64_t v88 = *v105;
                      if (os_log_type_enabled(*v105, OS_LOG_TYPE_DEFAULT))
                      {
                        std::string::size_type v89 = (std::string::size_type)(v4 + 4);
                        if (*((char *)v4 + 55) < 0) {
                          std::string::size_type v89 = *(void *)v5;
                        }
                        LODWORD(buf[0].__r_.__value_.__l.__data_) = 136446466;
                        *(std::string::size_type *)((char *)buf[0].__r_.__value_.__r.__words + 4) = (std::string::size_type)"kNotAllowedHW";
                        WORD2(buf[0].__r_.__value_.__r.__words[1]) = 2080;
                        *(std::string::size_type *)((char *)&buf[0].__r_.__value_.__r.__words[1] + 6) = v89;
                        _os_log_impl((void *)&_mh_execute_header, v88, OS_LOG_TYPE_DEFAULT, "#I maybe clear transfer token and update tranfer type: %{public}s, iccid: %s", (uint8_t *)buf, 0x16u);
                      }
                      sub_10098EE88(v2, (void **)v4 + 4);
                      if (*((char *)v4 + 55) < 0)
                      {
                        sub_10004FC84(&v108, v4[4], (unint64_t)v4[5]);
                      }
                      else
                      {
                        long long v108 = *v5;
                        uint64_t v109 = v4[6];
                      }
                      uint64_t v92 = *(void *)(v2 + 368);
                      uint64_t v93 = *(void *)(v2 + 376);
                      while (v92 != v93)
                      {
                        long long v94 = sub_100046F68(v92 + 56, (void **)&v108);
                        if ((void **)(v92 + 64) != v94)
                        {
                          *((_WORD *)v94 + 112) = 384;
                          break;
                        }
                        v92 += 80;
                      }
                      if ((SHIBYTE(v109) & 0x80000000) == 0) {
                        goto LABEL_133;
                      }
                      uint64_t v66 = (void *)v108;
                    }
                    else
                    {
                      if (v32) {
                        goto LABEL_133;
                      }
                      long long v90 = *v105;
                      if (os_log_type_enabled(*v105, OS_LOG_TYPE_DEFAULT))
                      {
                        std::string::size_type v91 = (std::string::size_type)(v4 + 4);
                        if (*((char *)v4 + 55) < 0) {
                          std::string::size_type v91 = *(void *)v5;
                        }
                        LODWORD(buf[0].__r_.__value_.__l.__data_) = 136446466;
                        *(std::string::size_type *)((char *)buf[0].__r_.__value_.__r.__words + 4) = (std::string::size_type)"kWebsheet";
                        WORD2(buf[0].__r_.__value_.__r.__words[1]) = 2080;
                        *(std::string::size_type *)((char *)&buf[0].__r_.__value_.__r.__words[1] + 6) = v91;
                        _os_log_impl((void *)&_mh_execute_header, v90, OS_LOG_TYPE_DEFAULT, "#I Updating tranfer type: %{public}s, iccid: %s", (uint8_t *)buf, 0x16u);
                      }
                      if (*((char *)v4 + 55) < 0)
                      {
                        sub_10004FC84(&v106, v4[4], (unint64_t)v4[5]);
                      }
                      else
                      {
                        long long v106 = *v5;
                        xpc_object_t v107 = v4[6];
                      }
                      uint64_t v99 = *(void *)(v2 + 368);
                      uint64_t v100 = *(void *)(v2 + 376);
                      while (v99 != v100)
                      {
                        uint64_t v101 = sub_100046F68(v99 + 56, (void **)&v106);
                        if ((void **)(v99 + 64) != v101)
                        {
                          *((_WORD *)v101 + 112) = 259;
                          break;
                        }
                        v99 += 80;
                      }
                      if ((SHIBYTE(v107) & 0x80000000) == 0) {
                        goto LABEL_133;
                      }
                      uint64_t v66 = (void *)v106;
                    }
LABEL_132:
                    operator delete(v66);
                    goto LABEL_133;
                  }
                  if (*((char *)v4 + 55) < 0)
                  {
                    sub_10004FC84(v110, v4[4], (unint64_t)v4[5]);
                  }
                  else
                  {
                    *(_OWORD *)int v110 = *v5;
                    xpc_object_t v111 = v4[6];
                  }
                  uint64_t v95 = *(void *)(v2 + 368);
                  uint64_t v96 = *(void *)(v2 + 376);
                  while (v95 != v96)
                  {
                    long long v97 = sub_100046F68(v95 + 56, v110);
                    if ((void **)(v95 + 64) != v97)
                    {
                      *((_WORD *)v97 + 112) = 262;
                      break;
                    }
                    v95 += 80;
                  }
                  if (SHIBYTE(v111) < 0) {
                    operator delete(v110[0]);
                  }
                  os_log_t v98 = *v105;
                  if (!os_log_type_enabled(*v105, OS_LOG_TYPE_DEFAULT)) {
                    goto LABEL_133;
                  }
                  if (*((char *)v4 + 55) < 0) {
                    uint64_t v5 = *(_OWORD **)v5;
                  }
                  LODWORD(buf[0].__r_.__value_.__l.__data_) = 136315138;
                  *(std::string::size_type *)((char *)buf[0].__r_.__value_.__r.__words + 4) = (std::string::size_type)v5;
                  uint64_t v29 = v98;
                  uint64_t v30 = "#I Physical sim transfer for iccid: [%s] not supported by carrier";
                  uint32_t v31 = 12;
                }
LABEL_47:
                _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, v30, (uint8_t *)buf, v31);
                goto LABEL_133;
              }
              if (v41)
              {
                LOWORD(buf[0].__r_.__value_.__l.__data_) = 0;
                _os_log_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_DEFAULT, "#I MinCompatibleOS does not exist, always allow SIM transfer", (uint8_t *)buf, 2u);
              }
LABEL_95:
              unsigned int v49 = 0;
              goto LABEL_96;
            }
            os_log_t v48 = *v105;
            if (!os_log_type_enabled(*v105, OS_LOG_TYPE_ERROR)) {
              goto LABEL_95;
            }
            LOWORD(buf[0].__r_.__value_.__l.__data_) = 0;
            unint64_t v46 = v48;
            uint64_t v47 = "Missing PhoneAccountTransfer in CB";
          }
          else
          {
            os_log_t v45 = *v105;
            if (!os_log_type_enabled(*v105, OS_LOG_TYPE_ERROR)) {
              goto LABEL_95;
            }
            LOWORD(buf[0].__r_.__value_.__l.__data_) = 0;
            unint64_t v46 = v45;
            uint64_t v47 = "Failed loading PhoneAccountTransfer CB";
          }
          _os_log_error_impl((void *)&_mh_execute_header, v46, OS_LOG_TYPE_ERROR, v47, (uint8_t *)buf, 2u);
          goto LABEL_95;
        }
      }
      else if (!v27)
      {
        goto LABEL_49;
      }
      os_log_t v28 = *v105;
      if (os_log_type_enabled(*v105, OS_LOG_TYPE_DEFAULT))
      {
        if (*((char *)v4 + 55) < 0) {
          uint64_t v5 = *(_OWORD **)v5;
        }
        LODWORD(buf[0].__r_.__value_.__l.__data_) = 136446466;
        *(std::string::size_type *)((char *)buf[0].__r_.__value_.__r.__words + 4) = (std::string::size_type)"kOnDeviceTransferred";
        WORD2(buf[0].__r_.__value_.__r.__words[1]) = 2080;
        *(std::string::size_type *)((char *)&buf[0].__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v5;
        uint64_t v29 = v28;
        uint64_t v30 = "#I Updating transfer type: %{public}s, iccid: %s";
        uint32_t v31 = 22;
        goto LABEL_47;
      }
LABEL_133:
      sub_1000C584C((uint64_t)&v132);
      uint64_t v67 = v4[1];
      if (v67)
      {
        do
        {
          int64x2_t v68 = (char **)v67;
          uint64_t v67 = *(char **)v67;
        }
        while (v67);
      }
      else
      {
        do
        {
          int64x2_t v68 = (char **)v4[2];
          BOOL v69 = *v68 == (char *)v4;
          uint64_t v4 = v68;
        }
        while (!v69);
      }
      uint64_t v4 = v68;
      if (v68 == v128) {
        goto LABEL_245;
      }
    }
  }
}

void sub_100B5089C(_Unwind_Exception *a1)
{
  if (STACK[0x338]) {
    sub_10004D2C8((std::__shared_weak_count *)STACK[0x338]);
  }
  sub_1000C584C((uint64_t)&STACK[0x250]);
  sub_10005CD2C((uint64_t)&STACK[0x220], (char *)STACK[0x228]);
  _Unwind_Resume(a1);
}

uint64_t sub_100B50A70(uint64_t a1)
{
  sub_10030DD28((void *)(a1 + 48));
  uint64_t v4 = (void **)(a1 + 24);
  sub_10030B640(&v4);
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

const void **sub_100B50AC0(const void **result, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = result;
  if (!*(unsigned char *)(a3 + 216))
  {
    *uint64_t result = 0;
    result[1] = 0;
    return result;
  }
  uint64_t v6 = (uint64_t **)(a2 + 904);
  uint64_t v7 = (long long *)(a3 + 16);
  char v8 = *(void ***)(a2 + 912);
  if (!v8)
  {
LABEL_7:
    CFDictionaryRef theDict = 0;
    sub_100B48258((const void **)&theDict, a2, a3);
    if (theDict) {
      uint64_t v9 = sub_100080778;
    }
    else {
      uint64_t v9 = 0;
    }
    if (v9)
    {
      CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(theDict, @"CarrierEntitlements");
      if (Value)
      {
        CFDictionaryGetValue(theDict, @"PushSettings");
        (***(void (****)(uint64_t *__return_ptr))(a2 + 48))(&v19);
        uint64_t v11 = v20;
        uint64_t v21 = v19;
        uint64_t v22 = v20;
        uint64_t v19 = 0;
        uint64_t v20 = 0;
        long long buf = 0uLL;
        uint64_t v27 = 0;
        sub_100CE946C(Value, 8u, &v23);
        uint64_t v25 = v7;
        unsigned int v12 = sub_100B70034(v6, (void **)v7, &v25);
        int v13 = (std::__shared_weak_count *)v12[8];
        *(_OWORD *)(v12 + 7) = v23;
        if (v13) {
          sub_10004D2C8(v13);
        }
        if (v11) {
          sub_10004D2C8(v11);
        }
        if (v20) {
          sub_10004D2C8(v20);
        }
        *(void *)&long long buf = v7;
        uint64_t v14 = sub_100B70034(v6, (void **)v7, (long long **)&buf);
        uint64_t v15 = v14[8];
        std::__shared_weak_count *v3 = (const void *)v14[7];
        v3[1] = (const void *)v15;
        if (v15) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v15 + 8), 1uLL, memory_order_relaxed);
        }
        return sub_100057D78((const void **)&theDict);
      }
      uint64_t v17 = *(NSObject **)(a2 + 40);
      if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
      {
        if (*(char *)(a3 + 39) >= 0) {
          BOOL v18 = v7;
        }
        else {
          BOOL v18 = *(long long **)(a3 + 16);
        }
        LODWORD(buf) = 136315138;
        *(void *)((char *)&buf + 4) = v18;
        _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I failed loading CB entitlements for ICCID: [%s]", (uint8_t *)&buf, 0xCu);
      }
    }
    std::__shared_weak_count *v3 = 0;
    v3[1] = 0;
    return sub_100057D78((const void **)&theDict);
  }
  while ((sub_100046FE8(v7, v8 + 4) & 0x80) != 0)
  {
LABEL_6:
    char v8 = (void **)*v8;
    if (!v8) {
      goto LABEL_7;
    }
  }
  if ((sub_100046FE8(v8 + 4, (void **)v7) & 0x80) != 0)
  {
    ++v8;
    goto LABEL_6;
  }
  *(void *)&long long buf = v7;
  uint64_t result = (const void **)sub_100B70034(v6, (void **)v7, (long long **)&buf);
  char v16 = (atomic_ullong *)result[8];
  std::__shared_weak_count *v3 = result[7];
  v3[1] = v16;
  if (v16) {
    atomic_fetch_add_explicit(v16 + 1, 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100B50D4C(_Unwind_Exception *a1, uint64_t a2, std::__shared_weak_count *a3, uint64_t a4, uint64_t a5, uint64_t a6, std::__shared_weak_count *a7, ...)
{
  va_start(va, a7);
  if (a7) {
    sub_10004D2C8(a7);
  }
  if (v7) {
    sub_10004D2C8(v7);
  }
  if (a3) {
    sub_10004D2C8(a3);
  }
  sub_100057D78((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100B50DA4(NSObject **a1, CFDictionaryRef theDict, void *key, uint64_t *a4)
{
  CFDictionaryRef Value = (void *)CFDictionaryGetValue(theDict, key);
  char v8 = Value;
  BOOL v18 = Value;
  if (Value)
  {
    uint64_t v9 = sub_100080934;
    CFRetain(Value);
  }
  else
  {
    uint64_t v9 = 0;
  }
  if (v9)
  {
    buf[0] = 0;
    if (v8)
    {
      CFTypeID v10 = CFGetTypeID(v8);
      if (v10 == CFBooleanGetTypeID())
      {
        ctu::cf::assign((ctu::cf *)buf, (BOOL *)v8, v11);
        LODWORD(v8) = buf[0];
      }
      else
      {
        LODWORD(v8) = 0;
      }
    }
    uint64_t v15 = *a1;
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      if (*((char *)a4 + 23) >= 0) {
        char v16 = a4;
      }
      else {
        char v16 = (uint64_t *)*a4;
      }
      *(_DWORD *)long long buf = 138412802;
      uint64_t v20 = key;
      __int16 v21 = 1024;
      LODWORD(v22[0]) = v8;
      WORD2(v22[0]) = 2080;
      *(void *)((char *)v22 + 6) = v16;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I %@ is set to %d for ICCID: [%s]", buf, 0x1Cu);
    }
    int v13 = 1;
  }
  else
  {
    unsigned int v12 = *a1;
    int v13 = 0;
    LODWORD(v8) = 0;
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      if (*((char *)a4 + 23) >= 0) {
        uint64_t v14 = a4;
      }
      else {
        uint64_t v14 = (uint64_t *)*a4;
      }
      *(_DWORD *)long long buf = 138412546;
      uint64_t v20 = key;
      __int16 v21 = 2080;
      v22[0] = v14;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I %@ not present in CB entitlements for ICCID: [%s]", buf, 0x16u);
      int v13 = 0;
      LODWORD(v8) = 0;
    }
  }
  sub_1000577C4(&v18);
  return v8 | (v13 << 8);
}

void sub_100B50F8C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_100B50FB0(uint64_t a1, uint64_t a2, unint64_t a3)
{
  ctu::hex((uint64_t *)__dst, (ctu *)(a3 + 1168), (const void *)0x10, a3);
  if (*(char *)(a2 + 23) < 0) {
    operator delete(*(void **)a2);
  }
  *(_OWORD *)a2 = *(_OWORD *)__dst;
  *(void *)(a2 + 16) = v23;
  sub_100093B44((std::string *)(a2 + 48), (const std::string *)(a3 + 1184));
  long long v20 = 0u;
  long long v21 = 0u;
  long long v18 = 0u;
  *(_OWORD *)uint64_t v19 = 0u;
  *(_OWORD *)char v16 = 0u;
  *(_OWORD *)uint64_t v17 = 0u;
  sub_100093B44((std::string *)&v17[1], (const std::string *)(a3 + 1232));
  if (*(unsigned char *)(a1 + 768))
  {
    if (*(char *)(a1 + 767) < 0)
    {
      if (!*(void *)(a1 + 752)) {
        goto LABEL_9;
      }
    }
    else if (!*(unsigned char *)(a1 + 767))
    {
      goto LABEL_9;
    }
    sub_100179AF8((std::string *)&v19[1], (const std::string *)(a1 + 744));
  }
LABEL_9:
  if (LOBYTE(v19[0]) | v21)
  {
    if (SHIBYTE(v17[0]) < 0)
    {
      sub_10004FC84(__dst, v16[0], (unint64_t)v16[1]);
    }
    else
    {
      *(_OWORD *)long long __dst = *(_OWORD *)v16;
      *(void **)&long long v23 = v17[0];
    }
    sub_1000593FC((uint64_t)&v23 + 8, (long long *)&v17[1]);
    sub_1000593FC((uint64_t)&v25 + 8, (long long *)&v19[1]);
    WORD4(v27) = WORD4(v21);
    sub_100B6213C((char **)(a2 + 24), (std::string *)__dst, (std::string *)&v28);
    if ((_BYTE)v27 && SHIBYTE(v26) < 0) {
      operator delete(*((void **)&v25 + 1));
    }
    if ((_BYTE)v25 && SHIBYTE(v24) < 0) {
      operator delete(*((void **)&v23 + 1));
    }
    if (SBYTE7(v23) < 0) {
      operator delete(__dst[0]);
    }
  }
  (*(void (**)(void))(**(void **)(a1 + 48) + 8))(*(void *)(a1 + 48));
  uint64_t v39 = 0;
  long long v37 = 0u;
  long long v38 = 0u;
  long long v35 = 0u;
  long long v36 = 0u;
  long long v33 = 0u;
  long long v34 = 0u;
  long long v31 = 0u;
  long long v32 = 0u;
  long long v29 = 0u;
  long long v30 = 0u;
  long long v27 = 0u;
  long long v28 = 0u;
  long long v25 = 0u;
  long long v26 = 0u;
  long long v23 = 0u;
  long long v24 = 0u;
  *(_OWORD *)long long __dst = 0u;
  sub_10004BD84((uint64_t)__dst);
  uint64_t v6 = (void *)std::ostream::operator<<();
  sub_10004B96C(v6, (uint64_t)".", 1);
  uint64_t v7 = (void *)std::ostream::operator<<();
  sub_10004B96C(v7, (uint64_t)".", 1);
  std::ostream::operator<<();
  sub_10004BC98((uint64_t)&v23 + 8, v14);
  sub_10008BE4C(a2 + 120, (long long *)v14);
  if (v15 < 0) {
    operator delete(v14[0]);
  }
  *(void **)((char *)__dst
  xpc_object_t v11 = v9;
  *(void *)&long long v23 = v9;
  if (SHIBYTE(v28) < 0) {
    operator delete(*((void **)&v27 + 1));
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  std::ios::~ios();
  (*(void (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
  uint64_t v39 = 0;
  long long v37 = 0u;
  long long v38 = 0u;
  long long v35 = 0u;
  long long v36 = 0u;
  long long v33 = 0u;
  long long v34 = 0u;
  long long v31 = 0u;
  long long v32 = 0u;
  long long v29 = 0u;
  long long v30 = 0u;
  long long v27 = 0u;
  long long v28 = 0u;
  long long v25 = 0u;
  long long v26 = 0u;
  long long v23 = 0u;
  long long v24 = 0u;
  *(_OWORD *)long long __dst = 0u;
  sub_10004BD84((uint64_t)__dst);
  unsigned int v12 = (void *)std::ostream::operator<<();
  sub_10004B96C(v12, (uint64_t)".", 1);
  int v13 = (void *)std::ostream::operator<<();
  sub_10004B96C(v13, (uint64_t)".", 1);
  std::ostream::operator<<();
  sub_10004BC98((uint64_t)&v23 + 8, v14);
  sub_10008BE4C(a2 + 88, (long long *)v14);
  if (v15 < 0) {
    operator delete(v14[0]);
  }
  __dst[0] = v8;
  *(void **)((char *)__dst + *((void *)v8 - 3)) = v10;
  *(void *)&long long v23 = v11;
  if (SHIBYTE(v28) < 0) {
    operator delete(*((void **)&v27 + 1));
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  std::ios::~ios();
  if ((_BYTE)v21 && SHIBYTE(v20) < 0) {
    operator delete(v19[1]);
  }
  if (LOBYTE(v19[0]) && SHIBYTE(v18) < 0) {
    operator delete(v17[1]);
  }
  if (SHIBYTE(v17[0]) < 0) {
    operator delete(v16[0]);
  }
}

void sub_100B51518(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,void *a30,uint64_t a31,int a32,__int16 a33,char a34,char a35,void *__p,uint64_t a37,int a38,__int16 a39,char a40,char a41,char a42)
{
}

uint64_t sub_100B515C8(uint64_t a1, unsigned __int8 **a2)
{
  uint64_t v3 = *(void *)(a1 + 312);
  uint64_t v4 = sub_100B45F5C(*(void *)(a1 + 304), v3, a2);
  if (v3 == v4) {
    return 0;
  }
  uint64_t v5 = v4;
  if (*(unsigned char *)(v4 + 1449)) {
    return *(unsigned char *)(v4 + 1448) != 0;
  }
  uint64_t result = (*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(**(void **)(a1 + 48)
                                                                                          + 248))(*(void *)(a1 + 48), v4 + 96, v4 + 120, v4 + 144, v4 + 168, v4 + 16);
  *(_WORD *)(v5 + 1448) = result | 0x100;
  return result;
}

void sub_100B51674(uint64_t *a1, void *a2, uint64_t a3)
{
  uint64_t v6 = a2[39];
  uint64_t v7 = sub_100B45F5C(a2[38], v6, (unsigned __int8 **)a3);
  if (v6 == v7)
  {
    char v16 = a2[5];
    if (!os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
    {
LABEL_22:
      *a1 = 0;
      a1[1] = 0;
      a1[2] = 0;
      return;
    }
    if (*(char *)(a3 + 23) >= 0) {
      uint64_t v17 = (unsigned __int8 *)a3;
    }
    else {
      uint64_t v17 = *(unsigned __int8 **)a3;
    }
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = v17;
    long long v18 = "Failed to find sourceIccid [%s]";
LABEL_33:
    _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, v18, buf, 0xCu);
    goto LABEL_22;
  }
  if (!*(unsigned char *)(v7 + 216))
  {
    char v16 = a2[5];
    if (!os_log_type_enabled(v16, OS_LOG_TYPE_ERROR)) {
      goto LABEL_22;
    }
    if (*(char *)(a3 + 23) >= 0) {
      long long v20 = (unsigned __int8 *)a3;
    }
    else {
      long long v20 = *(unsigned __int8 **)a3;
    }
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = v20;
    long long v18 = "VinylProfileDetails is not set for sourceIccid [%s]";
    goto LABEL_33;
  }
  long long v21 = 0;
  uint64_t v22 = 0;
  sub_100B50AC0(&v21, (uint64_t)a2, v7);
  xpc_object_t v8 = v21;
  a1[1] = 0;
  a1[2] = 0;
  *a1 = 0;
  if (v8)
  {
    CFDictionaryRef v9 = (const __CFDictionary *)*((void *)v8 + 8);
    CFDictionaryRef theDict = 0;
    CFDictionaryRef Value = CFDictionaryGetValue(v9, @"TransferMetadata");
    *(void *)long long buf = Value;
    if (Value) {
      CFRetain(Value);
    }
    sub_10004EFE4(&theDict, (CFTypeRef *)buf);
    sub_1000577C4((const void **)buf);
    if (theDict)
    {
      CFDictionaryGetValue(theDict, @"OnDeviceActivation");
      memset(buf, 0, sizeof(buf));
      unint64_t v27 = 0;
      ctu::cf::assign();
      uint64_t v24 = v27;
      *(_OWORD *)long long __p = *(_OWORD *)buf;
      unint64_t v11 = HIBYTE(v27);
      char v12 = HIBYTE(v27);
      if ((v27 & 0x8000000000000000) != 0) {
        unint64_t v11 = *(void *)&buf[8];
      }
      if (v11)
      {
        a1[1] = sub_1000D8CE8(a1, (long long *)__p);
        ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)buf, kCtLoggingSystemName, "cp.tr.ctr");
        int v13 = *(NSObject **)&buf[8];
        ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
        BOOL v14 = os_log_type_enabled(v13, OS_LOG_TYPE_INFO);
        char v12 = HIBYTE(v24);
        if (v14)
        {
          char v15 = __p;
          if (v24 < 0) {
            char v15 = (void **)__p[0];
          }
          *(_DWORD *)long long buf = 136315138;
          *(void *)&uint8_t buf[4] = v15;
          _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_INFO, "TransferMetadata with OnDeviceActivation [%s]", buf, 0xCu);
          char v12 = HIBYTE(v24);
        }
      }
      if (v12 < 0) {
        operator delete(__p[0]);
      }
    }
    else
    {
      ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)buf, kCtLoggingSystemName, "cp.tr.ctr");
      uint64_t v19 = *(NSObject **)&buf[8];
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
      if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "No transfer metadata in CarrierEntitlements", buf, 2u);
      }
    }
    sub_100057D78((const void **)&theDict);
  }
  if (v22) {
    sub_10004D2C8(v22);
  }
}

void sub_100B51968(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, const void *a17, uint64_t a18, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(a1);
}

std::string *sub_100B519F8(std::string *a1, uint64_t a2)
{
  if (a1[2].__r_.__value_.__s.__data_[8])
  {
    if (a1 != (std::string *)a2) {
      sub_10005CA3C((uint64_t)a1, *(std::string **)a2, *(long long **)(a2 + 8), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 3));
    }
    sub_100179AF8(a1 + 1, (const std::string *)(a2 + 24));
  }
  else
  {
    a1->__r_.__value_.__r.__words[0] = 0;
    a1->__r_.__value_.__l.__size_ = 0;
    a1->__r_.__value_.__r.__words[2] = 0;
    sub_1000302C0((char *)a1, *(long long **)a2, *(long long **)(a2 + 8), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 3));
    sub_1000593FC((uint64_t)&a1[1], (long long *)(a2 + 24));
    a1[2].__r_.__value_.__s.__data_[8] = 1;
  }
  return a1;
}

void sub_100B51AA4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100047F64((void ***)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100B51ABC(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 48) && *(char *)(a1 + 47) < 0) {
    operator delete(*(void **)(a1 + 24));
  }
  uint64_t v3 = (void **)a1;
  sub_100047F64(&v3);
  return a1;
}

BOOL sub_100B51B0C(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = 0;
  xpc_object_t v8 = 0;
  sub_1000C5AB4((uint64_t)v9, a2);
  char v10 = 1;
  sub_100B50AC0((const void **)&v7, a1, (uint64_t)v9);
  if (v10) {
    sub_1000C584C((uint64_t)v9);
  }
  if (v7)
  {
    unsigned __int16 v4 = sub_100B50DA4((NSObject **)(a1 + 40), v7[8], @"SupportIMEIPredictionForSIMTransfer", (uint64_t *)(a2 + 16));
    BOOL v5 = v4 >= 0x100u && v4 != 0;
  }
  else
  {
    BOOL v5 = 0;
  }
  if (v8) {
    sub_10004D2C8(v8);
  }
  return v5;
}

void sub_100B51BEC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11, char a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,char a39)
{
  if (a11) {
    sub_10004D2C8(a11);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100B51C24(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 152) && *(char *)(a1 + 151) < 0) {
    operator delete(*(void **)(a1 + 128));
  }
  if (*(unsigned char *)(a1 + 120) && *(char *)(a1 + 119) < 0) {
    operator delete(*(void **)(a1 + 96));
  }
  if (*(unsigned char *)(a1 + 72) && *(char *)(a1 + 71) < 0) {
    operator delete(*(void **)(a1 + 48));
  }
  if (*(char *)(a1 + 23) < 0) {
    operator delete(*(void **)a1);
  }
  return a1;
}

BOOL sub_100B51CA0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t **a6)
{
  CFDictionaryRef theDict = 0;
  (*(void (**)(CFDictionaryRef *__return_ptr))(**(void **)(a1 + 48) + 768))(&theDict);
  if (theDict) {
    xpc_object_t v8 = sub_100080778;
  }
  else {
    xpc_object_t v8 = 0;
  }
  if (!v8)
  {
    char v15 = *(NSObject **)(a1 + 40);
    if (!os_log_type_enabled(v15, OS_LOG_TYPE_ERROR)) {
      goto LABEL_24;
    }
    *(_WORD *)long long buf = 0;
    char v16 = "Failed loading PhoneAccountTransfer CB";
LABEL_14:
    _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, v16, buf, 2u);
    goto LABEL_24;
  }
  if (!CFDictionaryContainsKey(theDict, @"PhoneAccountTransfer"))
  {
    char v15 = *(NSObject **)(a1 + 40);
    if (!os_log_type_enabled(v15, OS_LOG_TYPE_ERROR)) {
      goto LABEL_24;
    }
    *(_WORD *)long long buf = 0;
    char v16 = "Missing PhoneAccountTransfer in CB";
    goto LABEL_14;
  }
  CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(theDict, @"PhoneAccountTransfer");
  if (!CFDictionaryContainsKey(Value, @"RequiresPinForTransfer"))
  {
    uint64_t v19 = *(NSObject **)(a1 + 40);
    BOOL v17 = 0;
    if (!os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_25;
    }
    if (*((char *)a6 + 23) < 0) {
      a6 = (uint64_t **)*a6;
    }
    *(_DWORD *)long long buf = 136315138;
    v23[0] = a6;
    _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#I RequiresPinForTransfer not present in CB entitlements for ICCID: [%s]", buf, 0xCu);
LABEL_24:
    BOOL v17 = 0;
    goto LABEL_25;
  }
  char v10 = (BOOL *)CFDictionaryGetValue(Value, @"RequiresPinForTransfer");
  unint64_t v11 = v10;
  buf[0] = 0;
  if (v10 && (CFTypeID v12 = CFGetTypeID(v10), v12 == CFBooleanGetTypeID()))
  {
    ctu::cf::assign((ctu::cf *)buf, v11, v13);
    int v14 = buf[0];
  }
  else
  {
    int v14 = 0;
  }
  BOOL v17 = v14 != 0;
  long long v18 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
  {
    if (*((char *)a6 + 23) < 0) {
      a6 = (uint64_t **)*a6;
    }
    *(_DWORD *)long long buf = 67109378;
    LODWORD(v23[0]) = v14;
    WORD2(v23[0]) = 2080;
    *(void *)((char *)v23 + 6) = a6;
    _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#I RequiresPinForTransfer is set to %d for ICCID: [%s]", buf, 0x12u);
  }
LABEL_25:
  sub_100057D78((const void **)&theDict);
  return v17;
}

void sub_100B51F18(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100057D78((const void **)va);
  _Unwind_Resume(a1);
}

CFStringRef sub_100B51F3C(uint64_t a1, int a2, int a3, uint64_t *a4, uint64_t *a5, uint64_t *a6, char *a7)
{
  CFStringRef result = (const __CFString *)*a4;
  if (*a4 && (CFStringRef result = (const __CFString *)CFStringGetLength(result), (uint64_t)result > 0))
  {
    int v15 = 3;
  }
  else if (a3)
  {
    int v15 = 4;
  }
  else if (a2 == 3)
  {
    int v15 = 1;
  }
  else
  {
    if (a2 != 4) {
      return result;
    }
    int v15 = 2;
  }
  *(void *)long long v21 = 0;
  if (*a4 && CFStringGetLength((CFStringRef)*a4) >= 1)
  {
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    if (Mutable)
    {
      BOOL v17 = *(__CFDictionary **)v21;
      *(void *)long long v21 = Mutable;
      CFTypeRef cf = v17;
      sub_10005717C(&cf);
    }
    sub_10010F3F0(*(__CFDictionary **)v21, @"WebsheetURLKey", *a4);
    if (*a5) {
      long long v18 = sub_100080778;
    }
    else {
      long long v18 = 0;
    }
    if (v18) {
      sub_1001C6A4C(*(__CFDictionary **)v21, @"WebsheetPostdataKey", *a5);
    }
  }
  CFTypeRef cf = 0;
  sub_10004EFE4(&v20, (CFTypeRef *)v21);
  sub_100CD9BDC(v15, a3, &v20, a6, a7, &cf);
  sub_100057D78(&v20);
  CFTypeRef v19 = cf;
  if (cf) {
    CFRetain(cf);
  }
  sub_100B3E384(a1, &v19);
  sub_100057D78(&v19);
  sub_100057D78(&cf);
  return (const __CFString *)sub_10005717C((const void **)v21);
}

void sub_100B520E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sub_10005717C((const void **)va);
  _Unwind_Resume(a1);
}

void sub_100B52128(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = a1[38];
  uint64_t v7 = a1[39];
  if (v6 == v7)
  {
    CFDictionaryRef v9 = a1[5];
    if (!os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
      goto LABEL_7;
    }
    *(_WORD *)long long buf = 0;
    char v10 = "no transfer plan data available";
    unint64_t v11 = v9;
    uint32_t v12 = 2;
    goto LABEL_17;
  }
  uint64_t v8 = sub_100B45F5C(v6, a1[39], (unsigned __int8 **)a2);
  if (v7 != v8)
  {
    sub_100093B44((std::string *)(v8 + 1384), (const std::string *)a3);
    goto LABEL_7;
  }
  CFBooleanRef v13 = a1[5];
  if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
  {
    if (*(char *)(a2 + 23) >= 0) {
      int v14 = (unsigned __int8 *)a2;
    }
    else {
      int v14 = *(unsigned __int8 **)a2;
    }
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = v14;
    char v10 = "no transfer plan data for iccid : %s";
    unint64_t v11 = v13;
    uint32_t v12 = 12;
LABEL_17:
    _os_log_error_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, v10, buf, v12);
  }
LABEL_7:
  sub_100058DB0(__p, "AltSmdpFqdn");
  *(void *)long long buf = 0;
  *(void *)&uint8_t buf[8] = 0;
  if (*(char *)(a3 + 23) < 0)
  {
    sub_10004FC84(&buf[8], *(void **)a3, *(void *)(a3 + 8));
  }
  else
  {
    *(_OWORD *)&uint8_t buf[8] = *(_OWORD *)a3;
    uint64_t v18 = *(void *)(a3 + 16);
  }
  *(void *)long long buf = sub_100333A04;
  sub_100B4A9E0(a1, a2, (uint64_t)__p, (void (**)(void, void, void, void, void))buf);
  sub_100146540((uint64_t (**)(void, void, void, void, void))buf);
  if (v16 < 0) {
    operator delete(__p[0]);
  }
}

void sub_100B522D4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100B52308(void *a1, uint64_t a2, uint64_t a3)
{
  unsigned __int16 v4 = (std::__shared_weak_count *)a1[11];
  if (v4)
  {
    uint64_t v7 = std::__shared_weak_count::lock(v4);
    if (v7)
    {
      uint64_t v8 = a1[10];
      if (v8)
      {
        (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v8 + 128))(v8, a2, a3);
LABEL_9:
        sub_10004D2C8(v7);
        return;
      }
    }
  }
  else
  {
    uint64_t v7 = 0;
  }
  CFDictionaryRef v9 = a1[5];
  if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)char v10 = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "invalid pendingTransferHandler to update pending plan state", v10, 2u);
  }
  if (v7) {
    goto LABEL_9;
  }
}

void sub_100B523DC(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_100B523F0(void *a1, uint64_t a2, CFStringRef *a3)
{
  if (*a1)
  {
    if (*a3) {
      uint64_t v3 = sub_1000810B8;
    }
    else {
      uint64_t v3 = 0;
    }
    if (v3)
    {
      if (CFStringGetLength(*a3) >= 1) {
        ctu::cf::assign();
      }
    }
  }
}

void sub_100B52568(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, const void *a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_100B525AC(uint64_t *a1, uint64_t *a2, long long *a3, const void **a4, const void **a5, char a6, int a7, NSObject **a8, uint64_t a9)
{
  uint64_t v13 = *a1;
  if (*a1)
  {
    if (a7)
    {
      dispatch_time_t v17 = dispatch_time(0, 100000000);
      uint64_t v18 = *a8;
      block[0] = _NSConcreteStackBlock;
      block[1] = 1174405120;
      block[2] = sub_100B528EC;
      block[3] = &unk_101A3E450;
      uint64_t v19 = a1[1];
      block[4] = *a1;
      long long v36 = (std::__shared_weak_count *)v19;
      if (v19) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v19 + 8), 1uLL, memory_order_relaxed);
      }
      long long v20 = (std::__shared_weak_count *)a2[1];
      uint64_t v37 = *a2;
      long long v38 = v20;
      if (v20) {
        atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      uint64_t v39 = a3;
      sub_100083DA4(&v40, a4);
      sub_100058198(v41, a5);
      char v43 = a6;
      long long v21 = *(std::__shared_weak_count **)(a9 + 8);
      v41[1] = *(const void **)a9;
      long long v42 = v21;
      if (v21) {
        atomic_fetch_add_explicit(&v21->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      }
      dispatch_after(v17, v18, block);
      if (v42) {
        std::__shared_weak_count::__release_weak(v42);
      }
      sub_100057D78(v41);
      sub_1000558F4(&v40);
      if (v38) {
        sub_10004D2C8(v38);
      }
      uint64_t v22 = v36;
    }
    else
    {
      uint64_t v22 = (std::__shared_weak_count *)a1[1];
      if (v22) {
        atomic_fetch_add_explicit(&v22->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      uint64_t v24 = (std::__shared_weak_count *)a2[1];
      v34[0] = *a2;
      v34[1] = v24;
      if (v24) {
        atomic_fetch_add_explicit(&v24->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      sub_100083DA4(&v33, a4);
      sub_100058198(&v32, a5);
      long long v25 = *(std::__shared_weak_count **)(a9 + 8);
      v31[0] = *(void *)a9;
      v31[1] = v25;
      if (v25) {
        atomic_fetch_add_explicit(&v25->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      }
      sub_100B52A18(v13, v34, a3, &v33, &v32, a6, v31);
      if (v25) {
        std::__shared_weak_count::__release_weak(v25);
      }
      sub_100057D78(&v32);
      sub_1000558F4(&v33);
      if (v24) {
        sub_10004D2C8(v24);
      }
    }
  }
  else
  {
    ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)buf, kCtLoggingSystemName, "cp.tr.ctr");
    long long v23 = v30;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "invalid notifier", buf, 2u);
    }
    uint64_t v22 = (std::__shared_weak_count *)a2[1];
    v28[0] = *a2;
    v28[1] = v22;
    if (v22) {
      atomic_fetch_add_explicit(&v22->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    sub_100083DA4(&v27, a4);
    sub_100058198(&v26, a5);
    sub_100B523F0(v28, (uint64_t)a3, (CFStringRef *)&v27);
    sub_100057D78(&v26);
    sub_1000558F4(&v27);
  }
  if (v22) {
    sub_10004D2C8(v22);
  }
}

void sub_100B52894(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, const void *a18, const void *a19)
{
  if (v20) {
    std::__shared_weak_count::__release_weak(v20);
  }
  sub_100057D78(&a18);
  sub_1000558F4(&a19);
  if (v21) {
    sub_10004D2C8(v21);
  }
  if (v19) {
    sub_10004D2C8(v19);
  }
  _Unwind_Resume(a1);
}

void sub_100B528EC(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 32);
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 40);
  if (v2) {
    atomic_fetch_add_explicit(&v2->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  unsigned __int16 v4 = *(std::__shared_weak_count **)(a1 + 56);
  v12[0] = *(void *)(a1 + 48);
  v12[1] = v4;
  if (v4) {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  BOOL v5 = *(long long **)(a1 + 64);
  sub_100083DA4(&v11, (const void **)(a1 + 72));
  sub_100058198(&v10, (const void **)(a1 + 80));
  char v6 = *(unsigned char *)(a1 + 105);
  uint64_t v7 = *(void *)(a1 + 88);
  uint64_t v8 = *(std::__shared_weak_count **)(a1 + 96);
  v9[0] = v7;
  v9[1] = v8;
  if (v8) {
    atomic_fetch_add_explicit(&v8->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  }
  sub_100B52A18(v3, v12, v5, &v11, &v10, v6, v9);
  if (v8) {
    std::__shared_weak_count::__release_weak(v8);
  }
  sub_100057D78(&v10);
  sub_1000558F4(&v11);
  if (v4) {
    sub_10004D2C8(v4);
  }
  if (v2) {
    sub_10004D2C8(v2);
  }
}

void sub_100B529D8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, const void *a11, const void *a12)
{
  if (v14) {
    std::__shared_weak_count::__release_weak(v14);
  }
  sub_100057D78(&a11);
  sub_1000558F4(&a12);
  if (v13) {
    sub_10004D2C8(v13);
  }
  if (v12) {
    sub_10004D2C8(v12);
  }
  _Unwind_Resume(a1);
}

void sub_100B52A18(uint64_t a1, void *a2, long long *a3, const void **a4, const void **a5, char a6, void *a7)
{
  long long v28 = 0uLL;
  uint64_t v29 = 0;
  ctu::cf::assign();
  *(_OWORD *)long long v26 = 0uLL;
  uint64_t v27 = 0;
  sub_100058198(&v25, a5);
  uint64_t v14 = a2[1];
  *(void *)&long long v19 = *a2;
  *((void *)&v19 + 1) = v14;
  if (v14) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v14 + 8), 1uLL, memory_order_relaxed);
  }
  if (*((char *)a3 + 23) < 0)
  {
    sub_10004FC84(&__p, *(void **)a3, *((void *)a3 + 1));
  }
  else
  {
    long long __p = *a3;
    uint64_t v21 = *((void *)a3 + 2);
  }
  sub_100083DA4((const void **)&v22, a4);
  sub_100058198((const void **)&v22 + 1, a5);
  char v23 = a6;
  long long v24 = 0uLL;
  int v15 = (std::__shared_weak_count *)a7[1];
  if (v15)
  {
    char v16 = std::__shared_weak_count::lock(v15);
    *((void *)&v24 + 1) = v16;
    if (v16) {
      *(void *)&long long v24 = *a7;
    }
  }
  else
  {
    char v16 = 0;
  }
  long long v31 = 0;
  dispatch_time_t v17 = (char *)operator new(0x58uLL);
  *(void *)dispatch_time_t v17 = off_101A3E750;
  *(_OWORD *)(v17 + 8) = v19;
  uint64_t v18 = v17 + 24;
  if (SHIBYTE(v21) < 0)
  {
    sub_10004FC84(v18, (void *)__p, *((unint64_t *)&__p + 1));
    char v16 = (std::__shared_weak_count *)*((void *)&v24 + 1);
  }
  else
  {
    *(_OWORD *)uint64_t v18 = __p;
    *((void *)v17 + 5) = v21;
  }
  *((_OWORD *)v17 + 3) = v22;
  long long v22 = 0u;
  v17[64] = v23;
  *((void *)v17 + 9) = v24;
  *((void *)v17 + 10) = v16;
  long long v24 = 0u;
  long long v31 = v17;
  (*(void (**)(uint64_t, void **, const void **, void *))(*(void *)a1 + 16))(a1, v26, &v25, v30);
  sub_100060644(v30);
  if (*((void *)&v24 + 1)) {
    sub_10004D2C8(*((std::__shared_weak_count **)&v24 + 1));
  }
  sub_100057D78((const void **)&v22 + 1);
  sub_1000558F4((const void **)&v22);
  if (SHIBYTE(v21) < 0) {
    operator delete((void *)__p);
  }
  sub_100057D78(&v25);
  if (SHIBYTE(v27) < 0) {
    operator delete(v26[0]);
  }
}

void sub_100B52C8C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, const void *a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,uint64_t a27,char a28,uint64_t a29,int a30,__int16 a31,char a32,char a33)
{
  long long v35 = (std::__shared_weak_count *)v33[2];
  if (v35) {
    sub_10004D2C8(v35);
  }
  operator delete(v33);
  sub_100B623AC((uint64_t)&a9);
  sub_100057D78(&a20);
  if (a26 < 0) {
    operator delete(a21);
  }
  _Unwind_Resume(a1);
}

const void **sub_100B52D10(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 40);
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  *(void *)(a1 + 40) = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v5 = *(void *)(a2 + 56);
  *(void *)(a1 + 48) = *(void *)(a2 + 48);
  *(void *)(a1 + 56) = v5;
  if (v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
  }
  sub_100083DA4((const void **)(a1 + 72), (const void **)(a2 + 72));
  CFStringRef result = sub_100058198((const void **)(a1 + 80), (const void **)(a2 + 80));
  uint64_t v7 = *(void *)(a2 + 96);
  *(void *)(a1 + 88) = *(void *)(a2 + 88);
  *(void *)(a1 + 96) = v7;
  if (v7) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v7 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100B52D94(void *a1)
{
  uint64_t v2 = (const void **)(a1 + 9);
  uint64_t v3 = (const void **)(a1 + 10);
  uint64_t v4 = (std::__shared_weak_count *)a1[12];
  if (v4) {
    std::__shared_weak_count::__release_weak(v4);
  }
  sub_100057D78(v3);
  sub_1000558F4(v2);
  uint64_t v5 = (std::__shared_weak_count *)a1[7];
  if (v5) {
    sub_10004D2C8(v5);
  }
  char v6 = (std::__shared_weak_count *)a1[5];
  if (v6)
  {
    sub_10004D2C8(v6);
  }
}

uint64_t sub_100B52E14(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *(void *)(a1 + 304);
  uint64_t v7 = *(void *)(a1 + 312);
  uint64_t v8 = sub_100B45F5C(v6, v7, (unsigned __int8 **)a2);
  if (v7 == v8)
  {
    sub_100B3F0F4((uint64_t)v52, v6, v7, (unsigned __int8 **)a2);
    LOBYTE(__p[0]) = 1;
    *(_OWORD *)&__p[1] = *(_OWORD *)v52;
    uint64_t v14 = v53;
    v52[0] = 0;
    v52[1] = 0;
    std::string::size_type v53 = 0;
    size_t v50 = 0;
    uint64_t v51 = 0;
    long long v55 = 0uLL;
    __p[3] = v14;
    LOBYTE(v56) = 56;
    sub_100B3F218(a1 + 424, (uint64_t)__p);
    sub_100057D78((const void **)&v55 + 1);
    sub_1000558F4((const void **)&v55);
    if (SHIBYTE(__p[3]) < 0) {
      operator delete(__p[1]);
    }
    sub_100057D78(&v50);
    sub_1000558F4(&v51);
    if (SHIBYTE(v53) < 0) {
      operator delete(v52[0]);
    }
    os_log_t v48 = 0;
    unsigned int v49 = 0;
    int v15 = &v49;
    char v16 = &v48;
    sub_100B3EA60(a1, a2, 11, 56, &v49, &v48);
  }
  else
  {
    uint64_t v9 = v8;
    int v10 = 70020;
    if (*(unsigned char *)(a3 + 256))
    {
      if (*(unsigned char *)(a3 + 56))
      {
LABEL_4:
        __int16 v11 = 0;
        int v12 = 56;
      }
      else
      {
        dispatch_time_t v17 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
        {
          unsigned int v18 = *(unsigned __int8 *)(a3 + 194) - 1;
          if (v18 > 8) {
            long long v19 = "kNoError";
          }
          else {
            long long v19 = off_101A3FDE8[(char)v18];
          }
          if (*(unsigned char *)(a3 + 25)) {
            long long v20 = sub_1008A1E44(*(unsigned __int8 *)(a3 + 24));
          }
          else {
            long long v20 = "Undefined";
          }
          if (*(char *)(a2 + 23) >= 0) {
            long long v24 = (unsigned __int8 *)a2;
          }
          else {
            long long v24 = *(unsigned __int8 **)a2;
          }
          LODWORD(__p[0]) = 136315650;
          *(void **)((char *)__p + 4) = (void *)v19;
          WORD2(__p[1]) = 2080;
          *(void **)((char *)&__p[1] + 6) = (void *)v20;
          HIWORD(__p[2]) = 2080;
          __p[3] = v24;
          _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I Error:[%s] Transfer-type:[%s] sourceIccid: [%s]", (uint8_t *)__p, 0x20u);
        }
        switch(*(unsigned char *)(a3 + 194))
        {
          case 2:
            long long v25 = *(NSObject **)(a1 + 40);
            if (!os_log_type_enabled(v25, OS_LOG_TYPE_ERROR)) {
              goto LABEL_89;
            }
            if (*(char *)(a2 + 23) >= 0) {
              long long v26 = (unsigned __int8 *)a2;
            }
            else {
              long long v26 = *(unsigned __int8 **)a2;
            }
            LODWORD(__p[0]) = 136315138;
            *(void **)((char *)__p + 4) = v26;
            uint64_t v27 = "token generation failed by carrier on source for iccid: %s";
            goto LABEL_98;
          case 3:
            long long v28 = *(NSObject **)(a1 + 40);
            int v10 = 70023;
            if (!os_log_type_enabled(v28, OS_LOG_TYPE_ERROR)) {
              goto LABEL_4;
            }
            if (*(char *)(a2 + 23) >= 0) {
              long long v35 = (unsigned __int8 *)a2;
            }
            else {
              long long v35 = *(unsigned __int8 **)a2;
            }
            LODWORD(__p[0]) = 136315138;
            *(void **)((char *)__p + 4) = v35;
            long long v30 = "token generation failed due to internal error on source for iccid: %s";
            goto LABEL_82;
          case 4:
            long long v25 = *(NSObject **)(a1 + 40);
            if (!os_log_type_enabled(v25, OS_LOG_TYPE_ERROR)) {
              goto LABEL_89;
            }
            if (*(char *)(a2 + 23) >= 0) {
              long long v31 = (unsigned __int8 *)a2;
            }
            else {
              long long v31 = *(unsigned __int8 **)a2;
            }
            LODWORD(__p[0]) = 136315138;
            *(void **)((char *)__p + 4) = v31;
            uint64_t v27 = "transfer authorization for type failed by carrier on source for iccid: %s";
            goto LABEL_98;
          case 5:
            long long v28 = *(NSObject **)(a1 + 40);
            int v10 = 70023;
            if (!os_log_type_enabled(v28, OS_LOG_TYPE_ERROR)) {
              goto LABEL_4;
            }
            if (*(char *)(a2 + 23) >= 0) {
              long long v32 = (unsigned __int8 *)a2;
            }
            else {
              long long v32 = *(unsigned __int8 **)a2;
            }
            LODWORD(__p[0]) = 136315138;
            *(void **)((char *)__p + 4) = v32;
            long long v30 = "transfer authorization for type failed due to internal error on source for iccid: %s";
            goto LABEL_82;
          case 6:
            long long v28 = *(NSObject **)(a1 + 40);
            int v10 = 70049;
            if (!os_log_type_enabled(v28, OS_LOG_TYPE_ERROR)) {
              goto LABEL_4;
            }
            if (*(char *)(a2 + 23) >= 0) {
              uint64_t v29 = (unsigned __int8 *)a2;
            }
            else {
              uint64_t v29 = *(unsigned __int8 **)a2;
            }
            LODWORD(__p[0]) = 136315138;
            *(void **)((char *)__p + 4) = v29;
            long long v30 = "secure intent failed on source for iccid: %s";
LABEL_82:
            _os_log_error_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_ERROR, v30, (uint8_t *)__p, 0xCu);
            goto LABEL_4;
          case 7:
            long long v25 = *(NSObject **)(a1 + 40);
            if (!os_log_type_enabled(v25, OS_LOG_TYPE_ERROR)) {
              goto LABEL_89;
            }
            if (*(char *)(a2 + 23) >= 0) {
              long long v36 = (unsigned __int8 *)a2;
            }
            else {
              long long v36 = *(unsigned __int8 **)a2;
            }
            LODWORD(__p[0]) = 136315138;
            *(void **)((char *)__p + 4) = v36;
            uint64_t v27 = "transfer authorization for token failed with error code by carrier on source for iccid: %s";
            goto LABEL_98;
          case 8:
            long long v25 = *(NSObject **)(a1 + 40);
            if (!os_log_type_enabled(v25, OS_LOG_TYPE_ERROR)) {
              goto LABEL_89;
            }
            if (*(char *)(a2 + 23) >= 0) {
              uint64_t v39 = (unsigned __int8 *)a2;
            }
            else {
              uint64_t v39 = *(unsigned __int8 **)a2;
            }
            LODWORD(__p[0]) = 136315138;
            *(void **)((char *)__p + 4) = v39;
            uint64_t v27 = "transfer authorization for type failed with error code by carrier on source for iccid: %s";
LABEL_98:
            _os_log_error_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_ERROR, v27, (uint8_t *)__p, 0xCu);
LABEL_89:
            __int16 v11 = 7;
            int v12 = 52;
            int v10 = 70010;
            break;
          default:
            int v10 = 70020;
            if (!*(unsigned char *)(a3 + 25)) {
              goto LABEL_4;
            }
            int v33 = *(unsigned __int8 *)(a3 + 24);
            switch(v33)
            {
              case 129:
                long long v38 = *(NSObject **)(a1 + 40);
                int v10 = 70036;
                if (os_log_type_enabled(v38, OS_LOG_TYPE_ERROR))
                {
                  if (*(char *)(a2 + 23) >= 0) {
                    long long v42 = (unsigned __int8 *)a2;
                  }
                  else {
                    long long v42 = *(unsigned __int8 **)a2;
                  }
                  LODWORD(__p[0]) = 136315138;
                  *(void **)((char *)__p + 4) = v42;
                  _os_log_error_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_ERROR, "target os version not supported for transfer by carrier for iccid: %s", (uint8_t *)__p, 0xCu);
                }
                __int16 v11 = 10;
                int v12 = 61;
                break;
              case 16:
                uint64_t v37 = *(NSObject **)(a1 + 40);
                int v10 = 70008;
                if (os_log_type_enabled(v37, OS_LOG_TYPE_ERROR))
                {
                  if (*(char *)(a2 + 23) >= 0) {
                    BOOL v41 = (unsigned __int8 *)a2;
                  }
                  else {
                    BOOL v41 = *(unsigned __int8 **)a2;
                  }
                  LODWORD(__p[0]) = 136315138;
                  *(void **)((char *)__p + 4) = v41;
                  _os_log_error_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_ERROR, "iccid: %s is not eligble for transfer", (uint8_t *)__p, 0xCu);
                }
                __int16 v11 = 9;
                int v12 = 37;
                break;
              case 6:
                if (*(unsigned char *)(v9 + 216))
                {
                  uint64_t v61 = 0;
                  memset(v60, 0, sizeof(v60));
                  long long v58 = 0u;
                  memset(v59, 0, sizeof(v59));
                  long long v56 = 0u;
                  long long v57 = 0u;
                  long long v55 = 0u;
                  memset(__p, 0, sizeof(__p));
                  sub_1000C5AB4((uint64_t)__p, v9);
                  (*(void (**)(void, _OWORD *, char *, _OWORD *, char *, void **))(**(void **)(a1 + 48)
                                                                                              + 240))(*(void *)(a1 + 48), v59, (char *)&v59[1] + 8, v60, (char *)&v60[1] + 8, &__p[2]);
                  uint64_t v34 = *(void *)(a1 + 800);
                  if (*(char *)(v34 + 47) < 0)
                  {
                    sub_10004FC84(__dst, *(void **)(v34 + 24), *(void *)(v34 + 32));
                  }
                  else
                  {
                    *(_OWORD *)long long __dst = *(_OWORD *)(v34 + 24);
                    uint64_t v47 = *(void *)(v34 + 40);
                  }
                  sub_100CD1928((const char *)__dst);
                  if (SHIBYTE(v47) < 0) {
                    operator delete(__dst[0]);
                  }
                  sub_1000C584C((uint64_t)__p);
                }
                BOOL v40 = *(NSObject **)(a1 + 40);
                int v10 = 70036;
                if (os_log_type_enabled(v40, OS_LOG_TYPE_ERROR))
                {
                  if (*(char *)(a2 + 23) >= 0) {
                    char v43 = (unsigned __int8 *)a2;
                  }
                  else {
                    char v43 = *(unsigned __int8 **)a2;
                  }
                  LODWORD(__p[0]) = 136315138;
                  *(void **)((char *)__p + 4) = v43;
                  _os_log_error_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_ERROR, "carrier does not support transfer for iccid: %s", (uint8_t *)__p, 0xCu);
                }
                __int16 v11 = 8;
                int v12 = 22;
                break;
              default:
                goto LABEL_4;
            }
            break;
        }
      }
      if (*(unsigned char *)(a3 + 256) && *(unsigned char *)(a3 + 224))
      {
        uint64_t v13 = (void *)(a3 + 200);
        sub_100B5457C((char *)__p, a1, a2, (unsigned __int8 **)(a3 + 200));
        int v12 = sub_100CDAF4C((unsigned __int8 *)__p);
        if (SHIBYTE(__p[2]) < 0) {
          operator delete(__p[0]);
        }
        int v10 = 70040;
        if (v12 > 53)
        {
          if (v12 == 54)
          {
            int v10 = 70042;
          }
          else if (v12 == 55)
          {
            int v10 = 70044;
          }
        }
        else if (v12 == 37)
        {
          int v10 = 70043;
        }
        else if (v12 == 53)
        {
          int v10 = 70041;
        }
        if (!*(unsigned char *)(a3 + 224)) {
          sub_10016C840();
        }
        sub_100093B44((std::string *)(v9 + 1480), (const std::string *)(a3 + 200));
        uint64_t v21 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
        {
          if (*(char *)(a3 + 223) < 0) {
            uint64_t v13 = (void *)*v13;
          }
          LODWORD(__p[0]) = 136315138;
          *(void **)((char *)__p + 4) = v13;
          _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "#I carrier error code in TA response from source: %s", (uint8_t *)__p, 0xCu);
        }
      }
    }
    else
    {
      __int16 v11 = 0;
      int v12 = 56;
    }
    if (!*(unsigned char *)(a1 + 480))
    {
      sub_100B3F0F4((uint64_t)v52, *(void *)(a1 + 304), *(void *)(a1 + 312), (unsigned __int8 **)a2);
      LOBYTE(__p[0]) = 1;
      *(_OWORD *)&__p[1] = *(_OWORD *)v52;
      long long v22 = v53;
      v52[0] = 0;
      v52[1] = 0;
      std::string::size_type v53 = 0;
      size_t v50 = 0;
      uint64_t v51 = 0;
      long long v55 = 0uLL;
      __p[3] = v22;
      LOBYTE(v56) = v12;
      sub_100B3F218(a1 + 424, (uint64_t)__p);
      sub_100057D78((const void **)&v55 + 1);
      sub_1000558F4((const void **)&v55);
      if (SHIBYTE(__p[3]) < 0) {
        operator delete(__p[1]);
      }
      sub_100057D78(&v50);
      sub_1000558F4(&v51);
      if (SHIBYTE(v53) < 0) {
        operator delete(v52[0]);
      }
    }
    if (!*(unsigned char *)(v9 + 1465)) {
      *(_WORD *)(v9 + 1464) = v11 | 0x100;
    }
    *(_DWORD *)(v9 + 1468) = v10;
    *(unsigned char *)(v9 + 1472) = 1;
    int v44 = 0;
    os_log_t v45 = 0;
    int v15 = &v45;
    char v16 = &v44;
    sub_100B3EA60(a1, a2, 11, v12, &v45, &v44);
  }
  sub_100057D78(v16);
  sub_1000558F4(v15);
  sub_100B3F32C(a1);
  return sub_100B3F548(a1);
}

void sub_100B536F8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,void *__p,uint64_t a25,int a26,__int16 a27,char a28,char a29)
{
}

char *sub_100B53774(char *__dst, std::string *__str)
{
  if (__dst[256])
  {
    std::string::operator=((std::string *)__dst, __str);
    *((_WORD *)__dst + 12) = __str[1].__r_.__value_.__l.__data_;
    sub_100179AF8((std::string *)(__dst + 32), (std::string *)((char *)__str + 32));
    sub_100179AF8((std::string *)(__dst + 64), (std::string *)((char *)__str + 64));
    sub_100179AF8((std::string *)__dst + 4, __str + 4);
    sub_100179AF8((std::string *)(__dst + 128), (std::string *)((char *)__str + 128));
    *((_WORD *)__dst + 80) = __str[6].__r_.__value_.__r.__words[2];
    std::string::operator=((std::string *)__dst + 7, __str + 7);
    std::string::value_type v4 = __str[8].__r_.__value_.__s.__data_[2];
    *((_WORD *)__dst + 96) = __str[8].__r_.__value_.__l.__data_;
    __dst[194] = v4;
    sub_100179AF8((std::string *)(__dst + 200), (std::string *)((char *)__str + 200));
    long long v5 = *(_OWORD *)&__str[9].__r_.__value_.__r.__words[2];
    *((_WORD *)__dst + 124) = __str[10].__r_.__value_.__r.__words[1];
    *(_OWORD *)(__dst + 232) = v5;
  }
  else
  {
    sub_10030DA1C(__dst, (long long *)__str);
    __dst[256] = 1;
  }
  return __dst;
}

void sub_100B53840(uint64_t a1, uint64_t a2, std::string *a3, unsigned __int8 *a4)
{
  uint64_t v73 = 0;
  uint64_t v71 = a1;
  long long v72 = 0uLL;
  if (*(char *)(a2 + 23) < 0)
  {
    sub_10004FC84(&v72, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    long long v72 = *(_OWORD *)a2;
    uint64_t v73 = *(void *)(a2 + 16);
  }
  uint64_t v8 = *(void *)(a1 + 312);
  uint64_t v9 = sub_100B45F5C(*(void *)(a1 + 304), v8, (unsigned __int8 **)a2);
  if (v8 == v9)
  {
    uint64_t v13 = *(NSObject **)(a1 + 40);
    if (!os_log_type_enabled(v13, OS_LOG_TYPE_ERROR)) {
      goto LABEL_107;
    }
    *(_WORD *)long long buf = 0;
    uint64_t v14 = "No ongoing current Iccid";
LABEL_28:
    _os_log_error_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, v14, buf, 2u);
    goto LABEL_107;
  }
  uint64_t v10 = v9;
  if (!*(unsigned char *)(v9 + 1460))
  {
    uint64_t v13 = *(NSObject **)(a1 + 40);
    if (!os_log_type_enabled(v13, OS_LOG_TYPE_ERROR)) {
      goto LABEL_107;
    }
    *(_WORD *)long long buf = 0;
    uint64_t v14 = "already receive transfer auth from source.";
    goto LABEL_28;
  }
  *(unsigned char *)(v9 + 1460) = 0;
  int v11 = a3[10].__r_.__value_.__s.__data_[16];
  if (a3[10].__r_.__value_.__s.__data_[16] && a3[2].__r_.__value_.__s.__data_[8] && a3[6].__r_.__value_.__s.__data_[8])
  {
    char v12 = 1;
  }
  else
  {
    int v15 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I failed to get transfer token from source", buf, 2u);
      int v11 = a3[10].__r_.__value_.__s.__data_[16];
    }
    if (!v11) {
      goto LABEL_71;
    }
    char v12 = 0;
  }
  sub_100CDB2AC((uint64_t)a3);
  sub_100B53774((char *)(v10 + 632), a3);
  if (!a3[10].__r_.__value_.__s.__data_[16] || !a3[6].__r_.__value_.__s.__data_[17]) {
    goto LABEL_30;
  }
  int v16 = a3[6].__r_.__value_.__s.__data_[16];
  if ((v16 & 0xFE) == 2)
  {
    if (!*(unsigned char *)(v10 + 1465))
    {
      if (v16 == 3) {
        __int16 v17 = 260;
      }
      else {
        __int16 v17 = 259;
      }
      *(_WORD *)(v10 + 1464) = v17;
    }
    *(void *)long long buf = a1;
    sub_10030D9BC((char *)&buf[8], (uint64_t)a3);
    if (*(char *)(a2 + 23) < 0)
    {
      sub_10004FC84(__src, *(void **)a2, *(void *)(a2 + 8));
    }
    else
    {
      *(_OWORD *)long long __src = *(_OWORD *)a2;
      __src[2] = *(void **)(a2 + 16);
    }
    os_log_t v45 = *(std::__shared_weak_count **)(a1 + 16);
    if (v45)
    {
      if (std::__shared_weak_count::lock(v45)) {
        operator new();
      }
    }
    sub_100088B9C();
  }
  if (v16 != 1)
  {
    char v43 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT))
    {
      if ((v16 - 2) > 2) {
        int v44 = "kAccepted";
      }
      else {
        int v44 = off_101A3FE60[(char)(v16 - 2)];
      }
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = v44;
      _os_log_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_DEFAULT, "#I failed to get transfer token. transfer consent : %s", buf, 0xCu);
    }
  }
  else
  {
LABEL_30:
    if (v12)
    {
      BOOL v69 = 0;
      unsigned int v70 = 0;
      sub_100B3EA60(a1, a2, 4, 0, &v70, &v69);
      sub_100057D78(&v69);
      sub_1000558F4(&v70);
      memset(buf, 0, 24);
      sub_100B49750((uint64_t)buf, a2);
      (***(void (****)(std::string *__return_ptr))(a1 + 48))(&__p);
      ServiceMap = (std::mutex *)Registry::getServiceMap(v18, (Registry *)__p.__r_.__value_.__l.__data_);
      long long v20 = ServiceMap;
      unint64_t v22 = v21;
      if ((v21 & 0x8000000000000000) != 0)
      {
        char v23 = (unsigned __int8 *)(v21 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v24 = 5381;
        do
        {
          unint64_t v22 = v24;
          unsigned int v25 = *v23++;
          uint64_t v24 = (33 * v24) ^ v25;
        }
        while (v25);
      }
      std::mutex::lock(ServiceMap);
      unint64_t v74 = v22;
      long long v26 = sub_10004D37C(&v20[1].__m_.__sig, &v74);
      if (v26)
      {
        uint64_t v28 = v26[3];
        uint64_t v27 = (std::__shared_weak_count *)v26[4];
        if (v27)
        {
          atomic_fetch_add_explicit(&v27->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v20);
          atomic_fetch_add_explicit(&v27->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v27);
          char v29 = 0;
          goto LABEL_39;
        }
      }
      else
      {
        uint64_t v28 = 0;
      }
      std::mutex::unlock(v20);
      uint64_t v27 = 0;
      char v29 = 1;
LABEL_39:
      (*(void (**)(uint64_t, uint8_t *))(*(void *)v28 + 88))(v28, buf);
      if ((v29 & 1) == 0) {
        sub_10004D2C8(v27);
      }
      if (__p.__r_.__value_.__l.__size_) {
        sub_10004D2C8((std::__shared_weak_count *)__p.__r_.__value_.__l.__size_);
      }
      if (*(unsigned char *)(v10 + 216))
      {
        memset(&__p, 0, sizeof(__p));
        BOOL v30 = sub_100B51B0C(a1, v10);
        char v31 = (*(uint64_t (**)(void))(**(void **)(a1 + 48) + 32))(*(void *)(a1 + 48));
        sub_100CDA4C8((void *)(a1 + 720), (uint64_t *)(a1 + 624), (uint64_t *)(a1 + 600), v30, v31, *(unsigned __int8 *)(a1 + 129), &__p);
        uint64_t v32 = sub_100CDB150((void *)(a1 + 720), (unsigned __int8 **)&__p);
        if (v32) {
          (*(void (**)(void, uint8_t *, uint64_t))(**(void **)(a1 + 48) + 288))(*(void *)(a1 + 48), buf, v32);
        }
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__p.__r_.__value_.__l.__data_);
        }
      }
      (***(void (****)(std::string *__return_ptr))(a1 + 48))(&__p);
      uint64_t v34 = (std::mutex *)Registry::getServiceMap(v33, (Registry *)__p.__r_.__value_.__l.__data_);
      long long v35 = v34;
      if ((v21 & 0x8000000000000000) != 0)
      {
        long long v36 = (unsigned __int8 *)(v21 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v37 = 5381;
        do
        {
          unint64_t v21 = v37;
          unsigned int v38 = *v36++;
          uint64_t v37 = (33 * v37) ^ v38;
        }
        while (v38);
      }
      std::mutex::lock(v34);
      unint64_t v74 = v21;
      uint64_t v39 = sub_10004D37C(&v35[1].__m_.__sig, &v74);
      if (v39)
      {
        uint64_t v41 = v39[3];
        BOOL v40 = (std::__shared_weak_count *)v39[4];
        if (v40)
        {
          atomic_fetch_add_explicit(&v40->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v35);
          atomic_fetch_add_explicit(&v40->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v40);
          char v42 = 0;
LABEL_56:
          LOBYTE(v74) = 2;
          (*(void (**)(uint64_t, uint8_t *, unint64_t *))(*(void *)v41 + 80))(v41, buf, &v74);
          if ((v42 & 1) == 0) {
            sub_10004D2C8(v40);
          }
          if (__p.__r_.__value_.__l.__size_) {
            sub_10004D2C8((std::__shared_weak_count *)__p.__r_.__value_.__l.__size_);
          }
          if ((char)buf[23] < 0) {
            operator delete(*(void **)buf);
          }
          goto LABEL_107;
        }
      }
      else
      {
        uint64_t v41 = 0;
      }
      std::mutex::unlock(v35);
      BOOL v40 = 0;
      char v42 = 1;
      goto LABEL_56;
    }
  }
LABEL_71:
  if (sub_100B54BDC((void *)a1, a2))
  {
    unint64_t v46 = *(std::__shared_weak_count **)(a1 + 16);
    if (v46 && std::__shared_weak_count::lock(v46)) {
      operator new();
    }
    sub_100088B9C();
  }
  uint64_t v47 = *(NSObject **)(a1 + 40);
  if (*a4 != 2)
  {
    if (os_log_type_enabled(v47, OS_LOG_TYPE_DEFAULT))
    {
      if (*(char *)(a2 + 23) >= 0) {
        uint64_t v51 = (void *)a2;
      }
      else {
        uint64_t v51 = *(void **)a2;
      }
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = v51;
      _os_log_impl((void *)&_mh_execute_header, v47, OS_LOG_TYPE_DEFAULT, "#I TA failed. no transfer token in response from source for iccid: [%s]", buf, 0xCu);
    }
    sub_10030D9BC(__dst, (uint64_t)a3);
    sub_100B52E14(a1, a2, (uint64_t)__dst);
    if (__dst[256]) {
      sub_1000C5578((uint64_t)__dst);
    }
    goto LABEL_107;
  }
  if (os_log_type_enabled(v47, OS_LOG_TYPE_ERROR))
  {
    uint64_t v57 = *(char *)(a2 + 23) >= 0 ? a2 : *(void *)a2;
    sub_100B55308(a4);
    uint64_t v58 = asString();
    *(_DWORD *)long long buf = 136315394;
    *(void *)&uint8_t buf[4] = v57;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&unsigned char buf[14] = v58;
    _os_log_error_impl((void *)&_mh_execute_header, v47, OS_LOG_TYPE_ERROR, "failed to get transfer token from source for [%s]. error: %s", buf, 0x16u);
    int v59 = *a4;
    if (v59 != 2)
    {
      if (v59 == 1) {
        goto LABEL_131;
      }
      goto LABEL_133;
    }
  }
  int v48 = a4[1];
  if (v48 == 21)
  {
    int v49 = 70006;
    if (*(unsigned char *)(v10 + 1465)) {
      goto LABEL_94;
    }
LABEL_92:
    __int16 v50 = 257;
    goto LABEL_93;
  }
  if (v48 == 20)
  {
    int v49 = 70005;
    if (!*(unsigned char *)(v10 + 1465)) {
      goto LABEL_80;
    }
    goto LABEL_94;
  }
  if (*sub_100B55308(a4) == 24)
  {
    int v49 = 70045;
    if (*(unsigned char *)(v10 + 1465)) {
      goto LABEL_94;
    }
    goto LABEL_92;
  }
  if (*sub_100B55308(a4) == 22)
  {
    int v49 = 70037;
    if (*(unsigned char *)(v10 + 1465)) {
      goto LABEL_94;
    }
    goto LABEL_80;
  }
  if (*sub_100B55308(a4) == 23)
  {
    int v49 = 70038;
    if (*(unsigned char *)(v10 + 1465)) {
      goto LABEL_94;
    }
    goto LABEL_80;
  }
  if (*sub_100B55308(a4) != 17)
  {
    if (!*(unsigned char *)(v10 + 1465)) {
      *(_WORD *)(v10 + 1464) = 261;
    }
    int v49 = *sub_100B55308(a4);
    goto LABEL_94;
  }
  int v49 = 70039;
  if (!*(unsigned char *)(v10 + 1465))
  {
LABEL_80:
    __int16 v50 = 258;
LABEL_93:
    *(_WORD *)(v10 + 1464) = v50;
  }
LABEL_94:
  *(_DWORD *)(v10 + 1468) = v49;
  *(unsigned char *)(v10 + 1472) = 1;
  int v52 = *a4;
  if (v52 != 2)
  {
    if (v52 == 1)
    {
LABEL_131:
      exceptioCFIndex n = (ctu::ResultIsNotError *)__cxa_allocate_exception(0x10uLL);
      uint64_t v61 = &ctu::ResultIsNotError::~ResultIsNotError;
      ctu::ResultIsNotError::ResultIsNotError(exception);
      goto LABEL_134;
    }
LABEL_133:
    exceptioCFIndex n = (ctu::ResultIsNotError *)__cxa_allocate_exception(0x10uLL);
    uint64_t v61 = &ctu::ResultIsEmptyError::~ResultIsEmptyError;
    ctu::ResultIsEmptyError::ResultIsEmptyError(exception);
LABEL_134:
    __cxa_throw(exception, v62, (void (*)(void *))v61);
  }
  int v53 = a4[1];
  if (v53 == 17 || v53 == 23 || *sub_100B55308(a4) == 22 || *sub_100B55308(a4) == 21 || *sub_100B55308(a4) == 24)
  {
    std::string::size_type v54 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v54, OS_LOG_TYPE_DEFAULT))
    {
      if (*(char *)(a2 + 23) >= 0) {
        long long v55 = (void *)a2;
      }
      else {
        long long v55 = *(void **)a2;
      }
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = v55;
      _os_log_impl((void *)&_mh_execute_header, v54, OS_LOG_TYPE_DEFAULT, "#I IDS error occurred for iccid: [%s]. goto BT flow", buf, 0xCu);
    }
    uint64_t v66 = 0;
    uint64_t v67 = 0;
    sub_100B553A8(&v71, &v67, 50, &v66);
    sub_100057D78(&v66);
    long long v56 = &v67;
  }
  else
  {
    uint64_t v64 = 0;
    long long v65 = 0;
    sub_100B553A8(&v71, &v65, 56, &v64);
    sub_100057D78(&v64);
    long long v56 = &v65;
  }
  sub_1000558F4(v56);
LABEL_107:
  if (SHIBYTE(v73) < 0) {
    operator delete((void *)v72);
  }
}

void sub_100B5440C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,void *a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,void *__p,uint64_t a54,int a55,__int16 a56,char a57,char a58)
{
  if (a58 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_100B5457C(char *a1, uint64_t a2, uint64_t a3, unsigned __int8 **a4)
{
  uint64_t v8 = *(void *)(a2 + 312);
  uint64_t v9 = sub_100B45F5C(*(void *)(a2 + 304), v8, (unsigned __int8 **)a3);
  if (v8 == v9)
  {
    uint64_t v34 = *(NSObject **)(a2 + 40);
    if (!os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
    {
LABEL_58:
      strcpy(a1, "CarrierDefaultErrors");
      a1[21] = unk_101546B25;
      *((_WORD *)a1 + 11) = unk_101546B26;
      return;
    }
    if (*(char *)(a3 + 23) >= 0) {
      long long v35 = (unsigned __int8 *)a3;
    }
    else {
      long long v35 = *(unsigned __int8 **)a3;
    }
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = v35;
    long long v36 = "Failed to find iccid [%s]";
LABEL_81:
    _os_log_error_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_ERROR, v36, buf, 0xCu);
    goto LABEL_58;
  }
  if (!*(unsigned char *)(v9 + 216))
  {
    uint64_t v34 = *(NSObject **)(a2 + 40);
    if (!os_log_type_enabled(v34, OS_LOG_TYPE_ERROR)) {
      goto LABEL_58;
    }
    if (*(char *)(a3 + 23) >= 0) {
      char v43 = (unsigned __int8 *)a3;
    }
    else {
      char v43 = *(unsigned __int8 **)a3;
    }
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = v43;
    long long v36 = "VinylProfileDetails is not set for iccid [%s]";
    goto LABEL_81;
  }
  CFDictionaryRef theDict = 0;
  (*(void (**)(CFDictionaryRef *__return_ptr, void, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(**(void **)(a2 + 48) + 768))(&theDict, *(void *)(a2 + 48), v9 + 96, v9 + 120, v9 + 144, v9 + 168, a3);
  if (theDict) {
    uint64_t v10 = sub_100080778;
  }
  else {
    uint64_t v10 = 0;
  }
  if (!v10)
  {
    uint64_t v37 = *(NSObject **)(a2 + 40);
    if (!os_log_type_enabled(v37, OS_LOG_TYPE_ERROR)) {
      goto LABEL_75;
    }
    if (*(char *)(a3 + 23) >= 0) {
      unsigned int v38 = (unsigned __int8 *)a3;
    }
    else {
      unsigned int v38 = *(unsigned __int8 **)a3;
    }
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = v38;
    uint64_t v39 = "Failed loading PhoneAccountTransfer CB for iccid: %s";
LABEL_69:
    _os_log_error_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_ERROR, v39, buf, 0xCu);
    goto LABEL_75;
  }
  if (!CFDictionaryContainsKey(theDict, @"PhoneAccountTransfer"))
  {
    uint64_t v37 = *(NSObject **)(a2 + 40);
    if (!os_log_type_enabled(v37, OS_LOG_TYPE_ERROR)) {
      goto LABEL_75;
    }
    if (*(char *)(a3 + 23) >= 0) {
      BOOL v40 = (unsigned __int8 *)a3;
    }
    else {
      BOOL v40 = *(unsigned __int8 **)a3;
    }
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = v40;
    uint64_t v39 = "Missing PhoneAccountTransfer from CB for iccid: %s";
    goto LABEL_69;
  }
  CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(theDict, @"PhoneAccountTransfer");
  if (CFDictionaryContainsKey(Value, @"TransferErrorCodes"))
  {
    CFDictionaryRef v12 = (const __CFDictionary *)CFDictionaryGetValue(Value, @"TransferErrorCodes");
    CFIndex Count = CFDictionaryGetCount(v12);
    keys = 0;
    int v52 = 0;
    uint64_t v53 = 0;
    sub_10004EE3C(&keys, Count);
    values = 0;
    int v49 = 0;
    uint64_t v50 = 0;
    sub_10004EE3C(&values, Count);
    CFDictionaryGetKeysAndValues(v12, (const void **)keys, (const void **)values);
    if (Count >= 1)
    {
      uint64_t v14 = 0;
      CFIndex v44 = Count;
      CFDictionaryRef v45 = v12;
      do
      {
        *(void *)a1 = 0;
        *((void *)a1 + 1) = 0;
        *((void *)a1 + 2) = 0;
        memset(buf, 0, sizeof(buf));
        ctu::cf::assign();
        *(_OWORD *)a1 = *(_OWORD *)buf;
        *((void *)a1 + 2) = *(void *)&buf[16];
        CFArrayRef v15 = (const __CFArray *)CFDictionaryGetValue(v12, keys[v14]);
        CFArrayRef v16 = v15;
        if (v15 && (CFTypeID v17 = CFGetTypeID(v15), v17 == CFArrayGetTypeID()))
        {
          CFIndex v18 = CFArrayGetCount(v16);
          if (v18 >= 1)
          {
            for (CFIndex i = 0; i != v18; ++i)
            {
              CFArrayGetValueAtIndex(v16, i);
              memset(buf, 0, sizeof(buf));
              ctu::cf::assign();
              uint64_t v47 = *(void *)&buf[16];
              *(_OWORD *)std::string __p = *(_OWORD *)buf;
              long long v20 = a4[1];
              int v21 = *((char *)a4 + 23);
              uint64_t v22 = HIBYTE(*(void *)&buf[16]);
              if ((buf[23] & 0x80u) == 0) {
                char v23 = (unsigned __int8 *)HIBYTE(*(void *)&buf[16]);
              }
              else {
                char v23 = *(unsigned __int8 **)&buf[8];
              }
              if (v21 >= 0) {
                long long v20 = (unsigned __int8 *)*((unsigned __int8 *)a4 + 23);
              }
              if (v23 == v20)
              {
                if (v21 >= 0) {
                  uint64_t v24 = (unsigned __int8 *)a4;
                }
                else {
                  uint64_t v24 = *a4;
                }
                if ((buf[23] & 0x80) != 0)
                {
                  BOOL v30 = __p[0];
                  int v31 = memcmp(__p[0], v24, *(size_t *)&buf[8]);
                  operator delete(v30);
                  if (!v31) {
                    goto LABEL_48;
                  }
                }
                else
                {
                  if (!v22) {
                    goto LABEL_48;
                  }
                  uint64_t v25 = 0;
                  uint64_t v26 = v22 - 1;
                  do
                  {
                    int v27 = *((unsigned __int8 *)__p + v25);
                    int v28 = v24[v25];
                  }
                  while (v27 == v28 && v26 != v25++);
                  if (v27 == v28) {
                    goto LABEL_48;
                  }
                }
              }
              else if ((buf[23] & 0x80) != 0)
              {
                operator delete(__p[0]);
              }
            }
          }
        }
        else
        {
          uint64_t v32 = *(NSObject **)(a2 + 40);
          if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
          {
            if (a1[23] >= 0) {
              int v33 = a1;
            }
            else {
              int v33 = *(char **)a1;
            }
            *(_DWORD *)long long buf = 136315138;
            *(void *)&uint8_t buf[4] = v33;
            _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, "#I Carrier Error Codes array not found for key %s", buf, 0xCu);
          }
        }
        if (a1[23] < 0) {
          operator delete(*(void **)a1);
        }
        ++v14;
        CFDictionaryRef v12 = v45;
      }
      while (v14 != v44);
    }
    strcpy(a1, "CarrierDefaultErrors");
    a1[21] = unk_101546B25;
    *((_WORD *)a1 + 11) = unk_101546B26;
LABEL_48:
    if (values)
    {
      int v49 = values;
      operator delete(values);
    }
    if (keys)
    {
      int v52 = keys;
      operator delete(keys);
    }
    goto LABEL_76;
  }
  uint64_t v41 = *(NSObject **)(a2 + 40);
  if (os_log_type_enabled(v41, OS_LOG_TYPE_DEFAULT))
  {
    if (*(char *)(a3 + 23) >= 0) {
      char v42 = (unsigned __int8 *)a3;
    }
    else {
      char v42 = *(unsigned __int8 **)a3;
    }
    *(_DWORD *)long long buf = 138412546;
    *(void *)&uint8_t buf[4] = @"TransferErrorCodes";
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&unsigned char buf[14] = v42;
    _os_log_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_DEFAULT, "#I %@ not present in CB for ICCID: [%s]", buf, 0x16u);
  }
LABEL_75:
  strcpy(a1, "CarrierDefaultErrors");
  a1[21] = unk_101546B25;
  *((_WORD *)a1 + 11) = unk_101546B26;
LABEL_76:
  sub_100057D78((const void **)&theDict);
}

void sub_100B54B34(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, uint64_t a18, void *a19, uint64_t a20,uint64_t a21,const void *a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  if (__p) {
    operator delete(__p);
  }
  if (a19) {
    operator delete(a19);
  }
  sub_100057D78(&a22);
  _Unwind_Resume(a1);
}

uint64_t sub_100B54BDC(void *a1, uint64_t a2)
{
  uint64_t v4 = a1[107];
  uint64_t v5 = a1[108];
  if (*(char *)(a2 + 23) < 0)
  {
    sub_10004FC84(&__dst, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    long long __dst = *(_OWORD *)a2;
    uint64_t v39 = *(void *)(a2 + 16);
  }
  uint64_t v6 = HIBYTE(v39);
  if (v4 != v5)
  {
    long long v7 = __dst;
    if (v39 >= 0) {
      uint64_t v8 = HIBYTE(v39);
    }
    else {
      uint64_t v8 = *((void *)&__dst + 1);
    }
    do
    {
      uint64_t v9 = *(unsigned __int8 *)(v4 + 455);
      int v10 = (char)v9;
      if ((v9 & 0x80u) != 0) {
        uint64_t v9 = *(void *)(v4 + 440);
      }
      if (v8 == v9)
      {
        if (v10 >= 0) {
          int v11 = (unsigned __int8 *)(v4 + 432);
        }
        else {
          int v11 = *(unsigned __int8 **)(v4 + 432);
        }
        if ((v6 & 0x80) != 0)
        {
          if (!memcmp((const void *)v7, v11, *((size_t *)&v7 + 1))) {
            goto LABEL_24;
          }
        }
        else
        {
          if (!v6) {
            goto LABEL_25;
          }
          p_dst = (unsigned __int8 *)&__dst;
          uint64_t v13 = v6;
          while (*p_dst == *v11)
          {
            ++p_dst;
            ++v11;
            if (!--v13) {
              goto LABEL_23;
            }
          }
        }
      }
      v4 += 1248;
    }
    while (v4 != v5);
    uint64_t v4 = v5;
  }
LABEL_23:
  if ((v6 & 0x80) != 0) {
LABEL_24:
  }
    operator delete((void *)__dst);
LABEL_25:
  if (v4 == a1[108] || *(unsigned __int8 *)(v4 + 1) - 5 > 2) {
    return 0;
  }
  uint64_t v14 = (std::__shared_weak_count *)a1[9];
  if (v14)
  {
    CFArrayRef v15 = std::__shared_weak_count::lock(v14);
    if (v15)
    {
      uint64_t v16 = a1[8];
      if (v16)
      {
        long long v36 = 0uLL;
        uint64_t v37 = 0;
        if (*(char *)(v4 + 527) < 0)
        {
          sub_10004FC84(&v36, *(void **)(v4 + 504), *(void *)(v4 + 512));
        }
        else
        {
          long long v36 = *(_OWORD *)(v4 + 504);
          uint64_t v37 = *(void **)(v4 + 520);
        }
        uint64_t v19 = HIBYTE(v37);
        if (SHIBYTE(v37) < 0) {
          uint64_t v19 = *((void *)&v36 + 1);
        }
        if (!v19)
        {
          sub_100B4AC10((uint64_t)a1, __p);
          if (SHIBYTE(v37) < 0) {
            operator delete((void *)v36);
          }
          long long v36 = *(_OWORD *)__p;
          uint64_t v37 = *(void **)&__p[16];
        }
        memset(v35, 0, sizeof(v35));
        if (*(char *)(v4 + 479) < 0)
        {
          if (!*(void *)(v4 + 464)) {
            goto LABEL_49;
          }
        }
        else if (!*(unsigned char *)(v4 + 479))
        {
LABEL_49:
          uint64_t v20 = *(unsigned __int8 *)(v4 + 1);
          uint64_t v34 = 0;
          int v33 = 0;
          sub_100B3EA60((uint64_t)a1, a2, v20, 56, &v34, &v33);
          sub_100057D78(&v33);
          sub_1000558F4(&v34);
          sub_100B3F0F4((uint64_t)v31, a1[38], a1[39], (unsigned __int8 **)a2);
          __p[0] = 1;
          *(_OWORD *)&__p[8] = *(_OWORD *)v31;
          unint64_t v21 = v32;
          v31[0] = 0;
          v31[1] = 0;
          unint64_t v32 = 0;
          BOOL v40 = 0;
          uint64_t v25 = 0;
          long long v24 = v21;
          LOBYTE(v26[0]) = 56;
          BOOL v30 = 0;
          sub_100B3F218((uint64_t)(a1 + 53), (uint64_t)__p);
          sub_100057D78(&v25);
          sub_1000558F4((const void **)&v24 + 1);
          if (SBYTE7(v24) < 0) {
            operator delete(*(void **)&__p[8]);
          }
          sub_100057D78(&v30);
          sub_1000558F4(&v40);
          if (SHIBYTE(v32) < 0) {
            operator delete(v31[0]);
          }
          *(void *)std::string __p = a1;
          *(void *)&__p[8] = v16;
          *(void *)&__p[16] = v15;
          atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
          if (*(char *)(a2 + 23) < 0)
          {
            sub_10004FC84(&v24, *(void **)a2, *(void *)(a2 + 8));
          }
          else
          {
            long long v24 = *(_OWORD *)a2;
            uint64_t v25 = *(const void **)(a2 + 16);
          }
          if (SHIBYTE(v37) < 0)
          {
            sub_10004FC84(v26, (void *)v36, *((unint64_t *)&v36 + 1));
          }
          else
          {
            *(_OWORD *)uint64_t v26 = v36;
            v26[2] = v37;
          }
          sub_1000593FC((uint64_t)&v27, (long long *)v35);
          if (*(char *)(v4 + 215) < 0)
          {
            sub_10004FC84(v28, *(void **)(v4 + 192), *(void *)(v4 + 200));
          }
          else
          {
            *(_OWORD *)int v28 = *(_OWORD *)(v4 + 192);
            void v28[2] = *(void **)(v4 + 208);
          }
          if (*(char *)(v4 + 239) < 0)
          {
            sub_10004FC84(v29, *(void **)(v4 + 216), *(void *)(v4 + 224));
          }
          else
          {
            *(_OWORD *)char v29 = *(_OWORD *)(v4 + 216);
            v29[2] = *(void **)(v4 + 232);
          }
          uint64_t v22 = (std::__shared_weak_count *)a1[2];
          if (v22)
          {
            if (std::__shared_weak_count::lock(v22)) {
              operator new();
            }
          }
          sub_100088B9C();
        }
        sub_100093B44((std::string *)v35, (const std::string *)(v4 + 456));
        goto LABEL_49;
      }
    }
  }
  else
  {
    CFArrayRef v15 = 0;
  }
  CFIndex v18 = a1[5];
  if (!os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
  {
    if (!v15) {
      return 1;
    }
    goto LABEL_69;
  }
  *(_WORD *)std::string __p = 0;
  _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "invalid delegate", __p, 2u);
  if (v15) {
LABEL_69:
  }
    sub_10004D2C8(v15);
  return 1;
}

void sub_100B55200(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, int a16, __int16 a17, char a18, char a19, void *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25,void *a26,uint64_t a27,int a28,__int16 a29,char a30,char a31,char a32,void *__p,uint64_t a34,int a35,__int16 a36,char a37,char a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,char a47)
{
  int v49 = *(std::__shared_weak_count **)(v47 + 16);
  if (v49) {
    sub_10004D2C8(v49);
  }
  sub_10006A6AC(a1);
}

unsigned __int8 *sub_100B55308(unsigned __int8 *a1)
{
  int v1 = *a1;
  if (v1 != 2)
  {
    if (v1 == 1)
    {
      exceptioCFIndex n = (ctu::ResultIsNotError *)__cxa_allocate_exception(0x10uLL);
      ctu::ResultIsNotError::ResultIsNotError(exception);
      uint64_t v5 = &ctu::ResultIsNotError::~ResultIsNotError;
    }
    else
    {
      exceptioCFIndex n = (ctu::ResultIsNotError *)__cxa_allocate_exception(0x10uLL);
      ctu::ResultIsEmptyError::ResultIsEmptyError(exception);
      uint64_t v5 = &ctu::ResultIsEmptyError::~ResultIsEmptyError;
    }
    __cxa_throw(exception, v4, (void (*)(void *))v5);
  }
  return a1 + 1;
}

void sub_100B55390(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100B553A8(uint64_t *a1, const void **a2, int a3, const void **a4)
{
  uint64_t v8 = (unsigned __int8 **)(a1 + 1);
  uint64_t v7 = *a1;
  sub_100083DA4(&v19, a2);
  sub_100058198(&v18, a4);
  sub_100B3EA60(v7, (uint64_t)v8, 11, a3, &v19, &v18);
  sub_100057D78(&v18);
  sub_1000558F4(&v19);
  sub_100B3F0F4((uint64_t)v10, *(void *)(v7 + 304), *(void *)(v7 + 312), v8);
  v12[0] = 0;
  *(_OWORD *)std::string __p = *(_OWORD *)v10;
  uint64_t v14 = v11;
  v10[0] = 0;
  v10[1] = 0;
  uint64_t v11 = 0;
  sub_100083DA4(&v15, a2);
  sub_100058198(&v16, a4);
  char v17 = a3;
  sub_100B3F218(v7 + 424, (uint64_t)v12);
  sub_100057D78(&v16);
  sub_1000558F4(&v15);
  if (SHIBYTE(v14) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v11) < 0) {
    operator delete(v10[0]);
  }
  sub_100B3F32C(v7);
  return sub_100B3F548(v7);
}

void sub_100B554D0(_Unwind_Exception *a1)
{
  sub_100057D78((const void **)(v1 - 64));
  sub_1000558F4((const void **)(v1 - 56));
  _Unwind_Resume(a1);
}

void sub_100B554EC(uint64_t a1, uint64_t a2, __int16 a3, uint64_t a4, unsigned __int8 *a5)
{
  if (a1 != a2)
  {
    uint64_t v9 = a1;
    while (1)
    {
      __s1 = 0;
      __CFIndex n = 0;
      uint64_t v23 = 0;
      if (sub_10098F640(v9, (unsigned __int8 **)a4, (unint64_t)&__s1))
      {
        uint64_t v10 = HIBYTE(v23);
        if (v23 >= 0) {
          size_t v11 = HIBYTE(v23);
        }
        else {
          size_t v11 = __n;
        }
        uint64_t v12 = a5[23];
        int v13 = (char)v12;
        if ((v12 & 0x80u) != 0) {
          uint64_t v12 = *((void *)a5 + 1);
        }
        if (v11 != v12) {
          goto LABEL_28;
        }
        if (v13 >= 0) {
          uint64_t v14 = a5;
        }
        else {
          uint64_t v14 = *(unsigned __int8 **)a5;
        }
        if (v23 < 0)
        {
          if (memcmp(__s1, v14, __n)) {
            goto LABEL_28;
          }
        }
        else if (HIBYTE(v23))
        {
          p_s1 = &__s1;
          while (*(unsigned __int8 *)p_s1 == *v14)
          {
            p_s1 = (void **)((char *)p_s1 + 1);
            ++v14;
            if (!--v10) {
              goto LABEL_21;
            }
          }
LABEL_28:
          int v16 = 0;
          goto LABEL_29;
        }
LABEL_21:
        if (*(char *)(a4 + 23) < 0)
        {
          sub_10004FC84(__p, *(void **)a4, *(void *)(a4 + 8));
        }
        else
        {
          *(_OWORD *)std::string __p = *(_OWORD *)a4;
          uint64_t v20 = *(void *)(a4 + 16);
        }
        char v17 = sub_10098F270(v9, __p, a3);
        char v18 = v17;
        if (SHIBYTE(v20) < 0)
        {
          operator delete(__p[0]);
          if ((v18 & 1) == 0) {
            goto LABEL_28;
          }
        }
        else if ((v17 & 1) == 0)
        {
          goto LABEL_28;
        }
        int v16 = 2;
      }
      else
      {
        int v16 = 3;
      }
LABEL_29:
      if (SHIBYTE(v23) < 0) {
        operator delete(__s1);
      }
      if (v16 == 3 || !v16)
      {
        v9 += 400;
        if (v9 != a2) {
          continue;
        }
      }
      return;
    }
  }
}

void sub_100B55660(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  _Unwind_Resume(exception_object);
}

void sub_100B55694(uint64_t a1, int a2)
{
  if (a2)
  {
    uint64_t v3 = *(void *)(a1 + 1040);
    *(void *)(a1 + 1040) = 0;
    if (v3) {
      (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
    }
    if (!*(void *)(a1 + 1032)) {
      operator new();
    }
  }
  else
  {
    uint64_t v17 = 0;
    char v18 = 0;
    (***(void (****)(uint8_t *__return_ptr))(a1 + 48))(buf);
    Registry::getTimerService(&v17, *(Registry **)buf);
    if (v22) {
      sub_10004D2C8(v22);
    }
    uint64_t v4 = v17;
    uint64_t v5 = *(NSObject **)(a1 + 40);
    if (v17)
    {
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I delay de-assert bootstrap for 2min", buf, 2u);
        uint64_t v4 = v17;
      }
      sub_100058DB0(v14, "delay bootstrap de-assertion timer");
      uint64_t v6 = *(std::__shared_weak_count **)(a1 + 16);
      if (!v6 || (v7 = *(void *)(a1 + 8), (uint64_t v8 = std::__shared_weak_count::lock(v6)) == 0)) {
        sub_100088B9C();
      }
      uint64_t v9 = v8;
      atomic_fetch_add_explicit(&v8->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v8);
      *(_OWORD *)std::string __p = *(_OWORD *)v14;
      uint64_t v20 = v15;
      v14[0] = 0;
      v14[1] = 0;
      uint64_t v15 = 0;
      uint64_t v23 = 0;
      uint64_t v10 = operator new(0x20uLL);
      *uint64_t v10 = off_101A3FCD0;
      v10[1] = a1;
      void v10[2] = v7;
      v10[3] = v9;
      uint64_t v23 = v10;
      (*(void (**)(uint64_t *__return_ptr, uint64_t, void **, void, uint64_t, void, uint8_t *))(*(void *)v4 + 40))(&v16, v4, __p, 0, 120000000, 0, buf);
      sub_10003B34C(buf);
      if (SHIBYTE(v20) < 0) {
        operator delete(__p[0]);
      }
      uint64_t v11 = v16;
      uint64_t v16 = 0;
      uint64_t v12 = *(void *)(a1 + 1040);
      *(void *)(a1 + 1040) = v11;
      if (v12)
      {
        (*(void (**)(uint64_t))(*(void *)v12 + 8))(v12);
        uint64_t v13 = v16;
        uint64_t v16 = 0;
        if (v13) {
          (*(void (**)(uint64_t))(*(void *)v13 + 8))(v13);
        }
      }
      if (SHIBYTE(v15) < 0) {
        operator delete(v14[0]);
      }
    }
    else
    {
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "No Timer service", buf, 2u);
      }
      sub_100B63EF8((uint64_t **)(a1 + 1032), 0);
    }
    if (v18) {
      sub_10004D2C8(v18);
    }
  }
}

void sub_100B55A9C(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,char a25,uint64_t a26)
{
  sub_10004D2C8(v28);
  char v29 = *(std::__shared_weak_count **)(v26 + 8);
  if (v29) {
    std::__shared_weak_count::__release_weak(v29);
  }
  std::__shared_weak_count::__release_weak(v27);
  operator delete();
}

void sub_100B55B50(void *a1, int **a2, int a3, int a4)
{
  uint64_t v5 = (std::__shared_weak_count *)a1[6];
  if (v5)
  {
    uint64_t v9 = a1[4];
    uint64_t v10 = std::__shared_weak_count::lock(v5);
    if (v10)
    {
      uint64_t v11 = v10;
      uint64_t v12 = a1[5];
      if (v12)
      {
        sub_100B55694(v9, 0);
        bzero(v34, 0x258uLL);
        if (a3)
        {
          if (*a2)
          {
            uint64_t v13 = *((void *)*a2 + 1);
            if (v13)
            {
              sub_100B63100((uint64_t)v34, v13);
              char v35 = 1;
              *(void *)long long buf = v9;
              *(void *)&uint8_t buf[8] = v12;
              *(void *)&uint8_t buf[16] = v11;
              atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
              uint64_t v14 = (long long *)a1[7];
              if (*((char *)v14 + 23) < 0)
              {
                sub_10004FC84(v45, *(void **)v14, *((void *)v14 + 1));
              }
              else
              {
                long long v15 = *v14;
                *(void *)&v45[1] = *((void *)v14 + 2);
                v45[0] = v15;
              }
              sub_1000DFC90((uint64_t)&v45[1] + 8, (uint64_t)(a1 + 8));
              sub_100B630A0((unsigned char *)&v45[3] + 8, (uint64_t)v34);
              int v27 = *(std::__shared_weak_count **)(v9 + 16);
              if (v27)
              {
                if (std::__shared_weak_count::lock(v27)) {
                  operator new();
                }
              }
              sub_100088B9C();
            }
          }
        }
        uint64_t v16 = *(NSObject **)(v9 + 40);
        if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
        {
          int v28 = *a2;
          if (*a2) {
            char v29 = "";
          }
          else {
            char v29 = "No Response.";
          }
          if ((a4 - 1) > 2) {
            BOOL v30 = "RequestCanceled";
          }
          else {
            BOOL v30 = off_101A3FE78[a4 - 1];
          }
          if (v28) {
            int v31 = sub_100FB56F4(*v28);
          }
          else {
            int v31 = "";
          }
          *(_DWORD *)long long buf = 136315650;
          *(void *)&uint8_t buf[4] = v29;
          *(_WORD *)&unsigned char buf[12] = 2080;
          *(void *)&unsigned char buf[14] = v30;
          *(_WORD *)&unsigned char buf[22] = 2080;
          *(void *)&v45[0] = v31;
          _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "TA request failed. %s EventCause: [%s], response status: [%s]", buf, 0x20u);
        }
        memset(v45, 0, 72);
        *(_OWORD *)&uint8_t buf[8] = 0u;
        *(void *)long long buf = v9;
        uint64_t v17 = (long long *)a1[7];
        if (*((char *)v17 + 23) < 0)
        {
          sub_10004FC84(&buf[8], *(void **)v17, *((void *)v17 + 1));
        }
        else
        {
          long long v18 = *v17;
          *(void *)&v45[0] = *((void *)v17 + 2);
          *(_OWORD *)&uint8_t buf[8] = v18;
        }
        sub_1000DFC90((uint64_t)v45 + 8, (uint64_t)(a1 + 8));
        DWORD2(v45[2]) = a4;
        uint64_t v20 = *a2;
        uint64_t v19 = a2[1];
        *(void *)&void v45[3] = a1[12];
        *((void *)&v45[3] + 1) = v20;
        *(void *)&void v45[4] = v19;
        if (v19) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)v19 + 1, 1uLL, memory_order_relaxed);
        }
        unint64_t v21 = (long long *)a1[7];
        if (*((char *)v21 + 23) < 0)
        {
          sub_10004FC84(__dst, *(void **)v21, *((void *)v21 + 1));
        }
        else
        {
          long long v22 = *v21;
          uint64_t v33 = *((void *)v21 + 2);
          *(_OWORD *)long long __dst = v22;
        }
        int v23 = *(unsigned __int8 *)(v9 + 132);
        uint64_t v36 = *(void *)buf;
        if (SBYTE7(v45[0]) < 0)
        {
          sub_10004FC84(&__p, *(void **)&buf[8], *(unint64_t *)&buf[16]);
        }
        else
        {
          long long __p = *(_OWORD *)&buf[8];
          uint64_t v38 = *(void *)&v45[0];
        }
        sub_1000DFC90((uint64_t)v39, (uint64_t)v45 + 8);
        long long v40 = *(_OWORD *)((char *)&v45[2] + 8);
        long long v41 = *(_OWORD *)((char *)&v45[3] + 8);
        if (*(void *)&v45[4]) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(*(void *)&v45[4] + 8), 1uLL, memory_order_relaxed);
        }
        char v43 = 0;
        long long v24 = (char *)operator new(0x68uLL);
        uint64_t v25 = v36;
        *(void *)long long v24 = off_101A3F480;
        *((void *)v24 + 1) = v25;
        uint64_t v26 = v24 + 16;
        if (SHIBYTE(v38) < 0)
        {
          sub_10004FC84(v26, (void *)__p, *((unint64_t *)&__p + 1));
        }
        else
        {
          *(_OWORD *)uint64_t v26 = __p;
          *((void *)v24 + 4) = v38;
        }
        sub_100023950((uint64_t)(v24 + 40), (uint64_t)v39);
        *(_OWORD *)(v24 + 72) = v40;
        *(_OWORD *)(v24 + 88) = v41;
        long long v41 = 0uLL;
        char v43 = v24;
        sub_100B5626C(v9, (unsigned __int8 **)__dst, a4, a3, v23 != 0, 0, 0, 0, (uint64_t)v42);
        sub_100060644(v42);
        if (*((void *)&v41 + 1)) {
          sub_10004D2C8(*((std::__shared_weak_count **)&v41 + 1));
        }
        sub_100060644(v39);
        if (SHIBYTE(v38) < 0) {
          operator delete((void *)__p);
        }
        if (SHIBYTE(v33) < 0) {
          operator delete(__dst[0]);
        }
        if (*(void *)&v45[4]) {
          sub_10004D2C8(*(std::__shared_weak_count **)&v45[4]);
        }
        sub_100060644((void *)v45 + 1);
        if (SBYTE7(v45[0]) < 0) {
          operator delete(*(void **)&buf[8]);
        }
        if (v35) {
          sub_1008C2D48((uint64_t)v34);
        }
      }
      sub_10004D2C8(v11);
    }
  }
}

void sub_100B5611C(_Unwind_Exception *a1, int a2)
{
  if (a2)
  {
    uint64_t v4 = *(std::__shared_weak_count **)(v2 + 16);
    if (v4) {
      sub_10004D2C8(v4);
    }
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

void sub_100B5626C(uint64_t a1, unsigned __int8 **a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9)
{
  uint64_t v14 = a2;
  uint64_t v16 = a9;
  uint64_t v17 = *(void *)(a1 + 312);
  uint64_t v18 = sub_100B45F5C(*(void *)(a1 + 304), v17, a2);
  if (v17 == v18)
  {
    unint64_t v32 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
    {
      if (*((char *)v14 + 23) < 0) {
        uint64_t v14 = (unsigned __int8 **)*v14;
      }
      *(_DWORD *)long long buf = 136315138;
      std::string::size_type v89 = v14;
      _os_log_error_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_ERROR, "source iccid:%s already removed", buf, 0xCu);
    }
    sub_1000607A8(a9, 0);
  }
  else
  {
    uint64_t v19 = v18;
    uint64_t v20 = *(std::__shared_weak_count **)(a1 + 88);
    if (v20)
    {
      unint64_t v21 = std::__shared_weak_count::lock(v20);
      if (v21)
      {
        int v60 = a8;
        int v22 = a3;
        int v23 = a7;
        int v24 = a4;
        int v25 = a5;
        uint64_t v26 = *(void *)(a1 + 80);
        if (v26)
        {
          bzero(buf, 0x4E8uLL);
          uint64_t v58 = v26;
          int v59 = v21;
          (*(void (**)(uint8_t *__return_ptr, uint64_t, unsigned __int8 **))(*(void *)v26 + 168))(buf, v26, v14);
          if (!v91)
          {
            uint64_t v34 = *(NSObject **)(a1 + 40);
            if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
            {
              *(_WORD *)uint64_t v92 = 0;
              _os_log_error_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_ERROR, "Pending plan not found. No recovery/retry possible.", v92, 2u);
            }
            sub_1000607A8(a9, 0);
            goto LABEL_79;
          }
          int v27 = v25;
          int v57 = v90;
          if (!*(unsigned char *)(v19 + 216))
          {
            BOOL v35 = 0;
            int v28 = v24;
            int v29 = v23;
            int v30 = v22;
            int v31 = v60;
LABEL_72:
            switch(v31)
            {
              case 0:
              case 1:
                if (!v57 || (v35 & v27) == 0) {
                  goto LABEL_78;
                }
                if (*((char *)v14 + 23) < 0)
                {
                  sub_10004FC84(&v70, *v14, (unint64_t)v14[1]);
                }
                else
                {
                  long long v70 = *(_OWORD *)v14;
                  uint64_t v71 = v14[2];
                }
                sub_1000DFC90((uint64_t)v87, v16);
                sub_100B4EB30(a1, (uint64_t *)&v70, (uint64_t)v87);
                sub_100060644(v87);
                if (SHIBYTE(v71) < 0)
                {
                  long long v56 = (void **)&v70;
                  goto LABEL_119;
                }
                goto LABEL_79;
              case 2:
              case 3:
              case 4:
              case 5:
              case 6:
              case 7:
                uint64_t v51 = *(NSObject **)(a1 + 40);
                if (os_log_type_enabled(v51, OS_LOG_TYPE_DEFAULT))
                {
                  uint64_t v52 = entitlements::asString();
                  *(_DWORD *)uint64_t v92 = 136315138;
                  *(void *)uint64_t v93 = v52;
                  _os_log_impl((void *)&_mh_execute_header, v51, OS_LOG_TYPE_DEFAULT, "#I Recovery not required for %s", v92, 0xCu);
                }
                sub_1000607A8(v16, 0);
                goto LABEL_76;
              case 8:
                if (a6)
                {
                  if (!v57 || !v35) {
                    goto LABEL_78;
                  }
                  if (!v27) {
                    goto LABEL_120;
                  }
                  if (*((char *)v14 + 23) < 0)
                  {
                    sub_10004FC84(&v68, *v14, (unint64_t)v14[1]);
                  }
                  else
                  {
                    long long v68 = *(_OWORD *)v14;
                    BOOL v69 = v14[2];
                  }
                  sub_1000DFC90((uint64_t)v86, v16);
                  sub_100B4EB30(a1, (uint64_t *)&v68, (uint64_t)v86);
                  sub_100060644(v86);
                  if (SHIBYTE(v69) < 0)
                  {
                    long long v56 = (void **)&v68;
                    goto LABEL_119;
                  }
                }
                else
                {
                  if (v30 == 3) {
                    int v55 = v28;
                  }
                  else {
                    int v55 = 1;
                  }
                  if (((v55 | v35) & 1) == 0) {
                    goto LABEL_78;
                  }
                  if (v57 && (v27 & 1) == 0)
                  {
                    if (!v91) {
                      sub_10016C840();
                    }
                    (*(void (**)(uint64_t, uint8_t *))(*(void *)v58 + 320))(v58, buf);
                    goto LABEL_78;
                  }
                  if (*((char *)v14 + 23) < 0)
                  {
                    sub_10004FC84(&v66, *v14, (unint64_t)v14[1]);
                  }
                  else
                  {
                    long long v66 = *(_OWORD *)v14;
                    uint64_t v67 = v14[2];
                  }
                  sub_1000DFC90((uint64_t)v85, v16);
                  sub_100B4EB30(a1, (uint64_t *)&v66, (uint64_t)v85);
                  sub_100060644(v85);
                  if (SHIBYTE(v67) < 0)
                  {
                    long long v56 = (void **)&v66;
                    goto LABEL_119;
                  }
                }
                goto LABEL_79;
              case 9:
                if (a6)
                {
                  if (v57 && v35)
                  {
                    if (v27)
                    {
                      if (*((char *)v14 + 23) < 0)
                      {
                        sub_10004FC84(&v64, *v14, (unint64_t)v14[1]);
                      }
                      else
                      {
                        long long v64 = *(_OWORD *)v14;
                        long long v65 = v14[2];
                      }
                      sub_1000DFC90((uint64_t)v84, v16);
                      sub_100B4EB30(a1, (uint64_t *)&v64, (uint64_t)v84);
                      sub_100060644(v84);
                      if ((SHIBYTE(v65) & 0x80000000) == 0) {
                        goto LABEL_79;
                      }
                      long long v56 = (void **)&v64;
LABEL_119:
                      operator delete(*v56);
LABEL_79:
                      if (v91) {
                        sub_10030D10C((uint64_t)buf);
                      }
                      unint64_t v21 = v59;
LABEL_82:
                      sub_10004D2C8(v21);
                      return;
                    }
LABEL_120:
                    if (!v91) {
                      sub_10016C840();
                    }
                    (*(void (**)(uint64_t, uint8_t *))(*(void *)v58 + 320))(v58, buf);
                  }
                }
                else
                {
                  int v54 = v28 ^ 1;
                  if (v30 != 3) {
                    int v54 = 1;
                  }
                  if ((v54 | v29 | v35))
                  {
                    if (!v57 || (v27 & 1) != 0)
                    {
                      if (*((char *)v14 + 23) < 0)
                      {
                        sub_10004FC84(&v62, *v14, (unint64_t)v14[1]);
                      }
                      else
                      {
                        long long v62 = *(_OWORD *)v14;
                        uint64_t v63 = v14[2];
                      }
                      sub_1000DFC90((uint64_t)v83, v16);
                      sub_100B4EB30(a1, (uint64_t *)&v62, (uint64_t)v83);
                      sub_100060644(v83);
                      if ((SHIBYTE(v63) & 0x80000000) == 0) {
                        goto LABEL_79;
                      }
                      long long v56 = (void **)&v62;
                      goto LABEL_119;
                    }
                    if (!v91) {
                      sub_10016C840();
                    }
                    (*(void (**)(uint64_t, uint8_t *))(*(void *)v58 + 320))(v58, buf);
                  }
                }
LABEL_78:
                sub_1000607A8(v16, 0);
                goto LABEL_79;
              default:
LABEL_76:
                uint64_t v53 = *(NSObject **)(a1 + 40);
                if (os_log_type_enabled(v53, OS_LOG_TYPE_ERROR))
                {
                  *(_WORD *)uint64_t v92 = 0;
                  _os_log_error_impl((void *)&_mh_execute_header, v53, OS_LOG_TYPE_ERROR, "Unknown request type", v92, 2u);
                }
                goto LABEL_78;
            }
          }
          int v28 = v24;
          if (*(char *)(v19 + 119) < 0)
          {
            sub_10004FC84(__dst, *(void **)(v19 + 96), *(void *)(v19 + 104));
            int v29 = v23;
            int v30 = v22;
            int v31 = v60;
            if (!*(unsigned char *)(v19 + 216)) {
              sub_10016C840();
            }
          }
          else
          {
            *(_OWORD *)long long __dst = *(_OWORD *)(v19 + 96);
            uint64_t v81 = *(void *)(v19 + 112);
            int v29 = v23;
            int v30 = v22;
            int v31 = v60;
          }
          if (*(char *)(v19 + 143) < 0)
          {
            sub_10004FC84(v78, *(void **)(v19 + 120), *(void *)(v19 + 128));
            if (!*(unsigned char *)(v19 + 216)) {
              sub_10016C840();
            }
          }
          else
          {
            *(_OWORD *)uint64_t v78 = *(_OWORD *)(v19 + 120);
            uint64_t v79 = *(void *)(v19 + 136);
          }
          if (*(char *)(v19 + 167) < 0)
          {
            sub_10004FC84(v76, *(void **)(v19 + 144), *(void *)(v19 + 152));
            if (!*(unsigned char *)(v19 + 216)) {
              sub_10016C840();
            }
          }
          else
          {
            *(_OWORD *)uint64_t v76 = *(_OWORD *)(v19 + 144);
            uint64_t v77 = *(void *)(v19 + 160);
          }
          if (*(char *)(v19 + 191) < 0)
          {
            sub_10004FC84(v74, *(void **)(v19 + 168), *(void *)(v19 + 176));
          }
          else
          {
            *(_OWORD *)unint64_t v74 = *(_OWORD *)(v19 + 168);
            uint64_t v75 = *(void *)(v19 + 184);
          }
          if (*((char *)v14 + 23) < 0)
          {
            sub_10004FC84(__p, *v14, (unint64_t)v14[1]);
          }
          else
          {
            *(_OWORD *)long long __p = *(_OWORD *)v14;
            uint64_t v73 = v14[2];
          }
          CFDictionaryRef theDict = 0;
          (*(void (**)(CFDictionaryRef *__return_ptr))(**(void **)(a1 + 48) + 768))(&theDict);
          if (theDict) {
            uint64_t v36 = sub_100080778;
          }
          else {
            uint64_t v36 = 0;
          }
          if (v36)
          {
            if (CFDictionaryContainsKey(theDict, @"PhoneAccountTransfer"))
            {
              CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(theDict, @"PhoneAccountTransfer");
              if (CFDictionaryContainsKey(Value, @"SupportsRecoveryOnTransferFailureResponse"))
              {
                uint64_t v38 = (BOOL *)CFDictionaryGetValue(Value, @"SupportsRecoveryOnTransferFailureResponse");
                uint64_t v39 = v38;
                v92[0] = 0;
                if (v38)
                {
                  CFTypeID v40 = CFGetTypeID(v38);
                  if (v40 == CFBooleanGetTypeID())
                  {
                    ctu::cf::assign((ctu::cf *)v92, v39, v41);
                    int v42 = v30;
                    int v43 = v29;
                    int v44 = v28;
                    LODWORD(v39) = v92[0];
                  }
                  else
                  {
                    int v42 = v30;
                    int v43 = v29;
                    int v44 = v28;
                    LODWORD(v39) = 0;
                  }
                }
                else
                {
                  int v42 = v30;
                  int v43 = v29;
                  int v44 = v28;
                }
                BOOL v35 = v39 != 0;
                int v49 = *(NSObject **)(a1 + 40);
                if (os_log_type_enabled(v49, OS_LOG_TYPE_DEFAULT))
                {
                  uint64_t v50 = __p;
                  if (SHIBYTE(v73) < 0) {
                    uint64_t v50 = (void **)__p[0];
                  }
                  *(_DWORD *)uint64_t v92 = 67109378;
                  *(_DWORD *)uint64_t v93 = v39;
                  *(_WORD *)&v93[4] = 2080;
                  *(void *)&v93[6] = v50;
                  _os_log_impl((void *)&_mh_execute_header, v49, OS_LOG_TYPE_DEFAULT, "#I SupportsRecoveryOnTransferFailureResponse is set to %d for ICCID: [%s]", v92, 0x12u);
                }
                int v28 = v44;
                int v29 = v43;
                int v30 = v42;
                uint64_t v16 = a9;
                goto LABEL_62;
              }
              uint64_t v47 = *(NSObject **)(a1 + 40);
              BOOL v35 = 0;
              if (!os_log_type_enabled(v47, OS_LOG_TYPE_DEFAULT))
              {
LABEL_62:
                sub_100057D78((const void **)&theDict);
                if (SHIBYTE(v73) < 0) {
                  operator delete(__p[0]);
                }
                if (SHIBYTE(v75) < 0) {
                  operator delete(v74[0]);
                }
                if (SHIBYTE(v77) < 0) {
                  operator delete(v76[0]);
                }
                if (SHIBYTE(v79) < 0) {
                  operator delete(v78[0]);
                }
                if (SHIBYTE(v81) < 0) {
                  operator delete(__dst[0]);
                }
                goto LABEL_72;
              }
              int v48 = __p;
              if (SHIBYTE(v73) < 0) {
                int v48 = (void **)__p[0];
              }
              *(_DWORD *)uint64_t v92 = 136315138;
              *(void *)uint64_t v93 = v48;
              _os_log_impl((void *)&_mh_execute_header, v47, OS_LOG_TYPE_DEFAULT, "#I SupportsRecoveryOnTransferFailureResponse not present in CB entitlements for ICCID: [%s]", v92, 0xCu);
LABEL_54:
              BOOL v35 = 0;
              goto LABEL_62;
            }
            CFDictionaryRef v45 = *(NSObject **)(a1 + 40);
            if (!os_log_type_enabled(v45, OS_LOG_TYPE_ERROR)) {
              goto LABEL_54;
            }
            *(_WORD *)uint64_t v92 = 0;
            unint64_t v46 = "Missing PhoneAccountTransfer in CB";
          }
          else
          {
            CFDictionaryRef v45 = *(NSObject **)(a1 + 40);
            if (!os_log_type_enabled(v45, OS_LOG_TYPE_ERROR)) {
              goto LABEL_54;
            }
            *(_WORD *)uint64_t v92 = 0;
            unint64_t v46 = "Failed loading PhoneAccountTransfer CB";
          }
          _os_log_error_impl((void *)&_mh_execute_header, v45, OS_LOG_TYPE_ERROR, v46, v92, 2u);
          goto LABEL_54;
        }
      }
    }
    else
    {
      unint64_t v21 = 0;
    }
    uint64_t v33 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_ERROR, "Pending transfer handler not available", buf, 2u);
    }
    sub_1000607A8(a9, 0);
    if (v21) {
      goto LABEL_82;
    }
  }
}

void sub_100B56D08(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, std::__shared_weak_count *a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,void *__p,uint64_t a28,int a29,__int16 a30,char a31,char a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,void *a38,uint64_t a39,uint64_t a40,uint64_t a41,void *a42,uint64_t a43,uint64_t a44,uint64_t a45,void *a46,uint64_t a47,uint64_t a48,uint64_t a49,void *a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  sub_100060644(&a70);
  if (a32 < 0) {
    operator delete(__p);
  }
  if (LOBYTE(STACK[0x6F0])) {
    sub_10030D10C((uint64_t)&STACK[0x210]);
  }
  sub_10004D2C8(a13);
  _Unwind_Resume(a1);
}

uint64_t sub_100B56EC8(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 88);
  if (v2) {
    sub_10004D2C8(v2);
  }
  sub_100060644((void *)(a1 + 32));
  if (*(char *)(a1 + 31) < 0) {
    operator delete(*(void **)(a1 + 8));
  }
  return a1;
}

uint64_t sub_100B56F10(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(a1 + 40) = *(void *)(a2 + 40);
  *(void *)(a1 + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return sub_1000DFC90(a1 + 64, a2 + 64);
}

void sub_100B56F54(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(std::__shared_weak_count **)(v1 + 48);
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  _Unwind_Resume(exception_object);
}

void sub_100B56F6C(uint64_t a1)
{
  sub_100060644((void *)(a1 + 64));
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 48);
  if (v2)
  {
    std::__shared_weak_count::__release_weak(v2);
  }
}

uint64_t sub_100B56FB8(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 24) && *(char *)(a1 + 23) < 0) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void sub_100B56FFC(uint64_t a1, uint64_t a2, int a3, int a4, uint64_t a5)
{
  uint64_t v10 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
  {
    if ((a3 - 1) > 2) {
      uint64_t v18 = "RequestCanceled";
    }
    else {
      uint64_t v18 = off_101A3FE78[a3 - 1];
    }
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = v18;
    _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "TA webservice request failed. EventCause: [%s]", buf, 0xCu);
  }
  uint64_t v11 = *(void *)(a1 + 312);
  uint64_t v12 = sub_100B45F5C(*(void *)(a1 + 304), v11, (unsigned __int8 **)a2);
  if (v11 == v12)
  {
    uint64_t v13 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      if (*(char *)(a2 + 23) >= 0) {
        uint64_t v14 = (unsigned __int8 *)a2;
      }
      else {
        uint64_t v14 = *(unsigned __int8 **)a2;
      }
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = v14;
      _os_log_error_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "source iccid:%s already removed", buf, 0xCu);
    }
  }
  else
  {
    *(_DWORD *)&unsigned char buf[12] = 0;
    long long v32 = 0u;
    memset(v31, 0, sizeof(v31));
    *(void *)long long buf = a1;
    *(_DWORD *)&uint8_t buf[8] = a3;
    uint64_t v30 = v12;
    if (*(char *)(a2 + 23) < 0)
    {
      sub_10004FC84(v31, *(void **)a2, *(void *)(a2 + 8));
    }
    else
    {
      *(_OWORD *)int v31 = *(_OWORD *)a2;
      void v31[2] = *(void **)(a2 + 16);
    }
    sub_100023950((uint64_t)&v31[3], a5);
    DWORD2(v32) = a4;
    if (*(char *)(a2 + 23) < 0)
    {
      sub_10004FC84(__dst, *(void **)a2, *(void *)(a2 + 8));
    }
    else
    {
      *(_OWORD *)long long __dst = *(_OWORD *)a2;
      uint64_t v20 = *(void *)(a2 + 16);
    }
    int v15 = *(unsigned __int8 *)(a1 + 132);
    long long v21 = *(_OWORD *)buf;
    uint64_t v22 = v30;
    if (SHIBYTE(v31[2]) < 0)
    {
      sub_10004FC84(&__p, v31[0], (unint64_t)v31[1]);
    }
    else
    {
      long long __p = *(_OWORD *)v31;
      int v24 = v31[2];
    }
    sub_1000DFC90((uint64_t)v25, (uint64_t)&v31[3]);
    int v26 = DWORD2(v32);
    int v28 = 0;
    uint64_t v16 = (char *)operator new(0x60uLL);
    *(void *)uint64_t v16 = off_101A3F500;
    *(_OWORD *)(v16 + 8) = v21;
    *((void *)v16 + 3) = v22;
    uint64_t v17 = v16 + 32;
    if (SHIBYTE(v24) < 0)
    {
      sub_10004FC84(v17, (void *)__p, *((unint64_t *)&__p + 1));
    }
    else
    {
      *(_OWORD *)uint64_t v17 = __p;
      *((void *)v16 + 6) = v24;
    }
    sub_100023950((uint64_t)(v16 + 56), (uint64_t)v25);
    *((_DWORD *)v16 + 22) = v26;
    int v28 = v16;
    sub_100B5626C(a1, (unsigned __int8 **)__dst, a3, 1, v15 != 0, 1, 0, 1, (uint64_t)v27);
    sub_100060644(v27);
    sub_100060644(v25);
    if (SHIBYTE(v24) < 0) {
      operator delete((void *)__p);
    }
    if (SHIBYTE(v20) < 0) {
      operator delete(__dst[0]);
    }
    sub_100060644(&v31[3]);
    if (SHIBYTE(v31[2]) < 0) {
      operator delete(v31[0]);
    }
  }
}

void sub_100B57354(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, char a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,char a30,uint64_t a31,uint64_t a32,uint64_t a33,char a34)
{
  operator delete(v34);
  sub_100B573D0((uint64_t)&a18);
  if (a16 < 0) {
    operator delete(__p);
  }
  sub_100B573D0((uint64_t)&a34);
  _Unwind_Resume(a1);
}

void sub_100B573B8(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  if (a23 < 0) {
    operator delete(__p);
  }
  JUMPOUT(0x100B57398);
}

uint64_t sub_100B573D0(uint64_t a1)
{
  if (*(char *)(a1 + 47) < 0) {
    operator delete(*(void **)(a1 + 24));
  }
  return a1;
}

void sub_100B5740C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8 = *(void *)(a1 + 312);
  uint64_t v9 = sub_100B45F5C(*(void *)(a1 + 304), v8, (unsigned __int8 **)a2);
  uint64_t v91 = v9;
  uint64_t v10 = *(NSObject **)(a1 + 40);
  if (v8 == v9)
  {
    if (os_log_type_enabled(*(os_log_t *)(a1 + 40), OS_LOG_TYPE_ERROR))
    {
      if (*(char *)(a2 + 23) >= 0) {
        uint64_t v17 = (unsigned __int8 *)a2;
      }
      else {
        uint64_t v17 = *(unsigned __int8 **)a2;
      }
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = v17;
      _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "source iccid:%s already removed", buf, 0xCu);
    }
  }
  else
  {
    uint64_t v11 = v9;
    if (os_log_type_enabled(*(os_log_t *)(a1 + 40), OS_LOG_TYPE_DEFAULT))
    {
      if (*(char *)(a2 + 23) >= 0) {
        uint64_t v12 = (unsigned __int8 *)a2;
      }
      else {
        uint64_t v12 = *(unsigned __int8 **)a2;
      }
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = v12;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I [resp][ta] processing TransferAuthorization response. source iccid : %s", buf, 0xCu);
    }
    if (*(unsigned char *)(a4 + 592))
    {
      bzero(buf, 0x250uLL);
      sub_100B63100((uint64_t)buf, a4);
      int v13 = buf[1];
      if (buf[1] && !buf[0] && v130)
      {
        uint64_t v14 = v129;
        if ((v129 & 0x80u) != 0) {
          uint64_t v14 = v128[1];
        }
        if (!v14 || !v132) {
          goto LABEL_43;
        }
        if (sub_100B515C8(a1, (unsigned __int8 **)a2))
        {
          sub_100058DB0(__p, "TransferAuthWebServRequestTime");
          v116[0].__r_.__value_.__l.__size_ = CFAbsoluteTimeGetCurrent();
          v116[0].__r_.__value_.__r.__words[0] = (std::string::size_type)sub_100B71B34;
          sub_100B4A9E0((void *)a1, a2, (uint64_t)__p, v116);
          sub_100146540(v116);
          if (SBYTE7(v88) < 0) {
            operator delete(__p[0]);
          }
          memset(v123, 0, sizeof(v123));
          long long v122 = 0u;
          long long v121 = 0u;
          long long v120 = 0u;
          long long v119 = 0u;
          long long v118 = 0u;
          long long v117 = 0u;
          memset(v116, 0, sizeof(v116));
          sub_100093B44(v116, &v131);
          if (*(unsigned char *)(v11 + 1476))
          {
            uint64_t v90 = 0;
            long long v88 = 0u;
            long long v89 = 0u;
            *(_OWORD *)long long __p = 0u;
            sub_100B51674((uint64_t *)v114, (void *)a1, a2);
            sub_10005CBB4((uint64_t *)__p);
            *(_OWORD *)long long __p = *(_OWORD *)v114;
            *(void *)&long long v88 = v115;
            uint64_t v115 = 0;
            memset(v114, 0, sizeof(v114));
            uint64_t v93 = v114;
            sub_100047F64((void ***)&v93);
            if (__p[1] != __p[0])
            {
              sub_100B519F8((std::string *)v123, (uint64_t)__p);
              int v15 = *(NSObject **)(a1 + 40);
              if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
              {
                if (*(char *)(a2 + 23) >= 0) {
                  uint64_t v16 = (unsigned __int8 *)a2;
                }
                else {
                  uint64_t v16 = *(unsigned __int8 **)a2;
                }
                *(_DWORD *)int64_t v114 = 136315138;
                *(void *)&v114[4] = v16;
                _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I Set transfer-metadata for sourceIccid [%s] in TA HTTP POST", v114, 0xCu);
              }
            }
            if ((_BYTE)v90 && SHIBYTE(v89) < 0) {
              operator delete(*((void **)&v88 + 1));
            }
            *(void *)int64_t v114 = __p;
            sub_100047F64((void ***)v114);
          }
          if (*(char *)(a2 + 23) < 0)
          {
            sub_10004FC84(v85, *(void **)a2, *(void *)(a2 + 8));
          }
          else
          {
            *(_OWORD *)int v85 = *(_OWORD *)a2;
            uint64_t v86 = *(void *)(a2 + 16);
          }
          *(void *)&long long v105 = a1;
          int v42 = *(std::__shared_weak_count **)(a1 + 16);
          if (!v42 || (uint64_t v43 = *(void *)(a1 + 8), (v44 = std::__shared_weak_count::lock(v42)) == 0)) {
            sub_100088B9C();
          }
          *((void *)&v105 + 1) = v43;
          long long v106 = v44;
          atomic_fetch_add_explicit(&v44->__shared_weak_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v44);
          sub_1000DFC90((uint64_t)v107, a3);
          sub_100B63100((uint64_t)v108, (uint64_t)buf);
          if (*(char *)(a2 + 23) < 0)
          {
            sub_10004FC84(&v109, *(void **)a2, *(void *)(a2 + 8));
          }
          else
          {
            long long v109 = *(_OWORD *)a2;
            uint64_t v110 = *(void *)(a2 + 16);
          }
          uint64_t v111 = v11;
          unint64_t v113 = 0;
          CFDictionaryRef v45 = (char *)operator new(0x2B0uLL);
          *(void *)CFDictionaryRef v45 = off_101A3F580;
          *(_OWORD *)(v45 + 8) = v105;
          *((void *)v45 + 3) = v106;
          *((void *)&v105 + 1) = 0;
          long long v106 = 0;
          sub_100023950((uint64_t)(v45 + 32), (uint64_t)v107);
          sub_1008C2990((uint64_t)(v45 + 64), (uint64_t)v108);
          unint64_t v46 = v45 + 656;
          if (SHIBYTE(v110) < 0)
          {
            sub_10004FC84(v46, (void *)v109, *((unint64_t *)&v109 + 1));
          }
          else
          {
            *(_OWORD *)unint64_t v46 = v109;
            *((void *)v45 + 84) = v110;
          }
          *((void *)v45 + 85) = v111;
          unint64_t v113 = v45;
          BOOL v47 = sub_100B588AC(a1, (uint64_t)v85, (uint64_t)v128, (uint64_t)v116, 1, (uint64_t)v112);
          sub_100777F50(v112);
          if (SHIBYTE(v110) < 0) {
            operator delete((void *)v109);
          }
          sub_1008C2D48((uint64_t)v108);
          sub_100060644(v107);
          if (v106) {
            std::__shared_weak_count::__release_weak(v106);
          }
          if (SHIBYTE(v86) < 0) {
            operator delete(v85[0]);
          }
          if (!v47)
          {
            sub_1000DFC90((uint64_t)v104, a3);
            sub_100B56FFC(a1, a2, 0, 1, (uint64_t)v104);
            sub_100060644(v104);
          }
          sub_100B632F8((uint64_t)v116);
          goto LABEL_193;
        }
        int v13 = buf[1];
      }
      if (!v13)
      {
        uint64_t v22 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
        {
          LOWORD(v116[0].__r_.__value_.__l.__data_) = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_ERROR, "Failed Transfer Type retrieval. invalid transfer type", (uint8_t *)v116, 2u);
        }
        unsigned int v21 = 0;
LABEL_47:
        if (*(char *)(a2 + 23) < 0)
        {
          sub_10004FC84(__dst, *(void **)a2, *(void *)(a2 + 8));
        }
        else
        {
          *(_OWORD *)long long __dst = *(_OWORD *)a2;
          uint64_t v84 = *(void *)(a2 + 16);
        }
        ctu::hex((uint64_t *)v81, (ctu *)(v11 + 1032), (const void *)0x10, v20);
        sub_100B554EC(*(void *)(a1 + 144), *(void *)(a1 + 152), v21, (uint64_t)__dst, (unsigned __int8 *)v81);
        if (v82 < 0) {
          operator delete(v81[0]);
        }
        if (SHIBYTE(v84) < 0) {
          operator delete(__dst[0]);
        }
        *(unsigned char *)(v11 + 1280) = v21;
        sub_100058DB0(__p, "TransferType");
        v116[0].__r_.__value_.__l.__size_ = v21;
        v116[0].__r_.__value_.__r.__words[0] = (std::string::size_type)sub_100B73190;
        sub_100B4A9E0((void *)a1, a2, (uint64_t)__p, v116);
        sub_100146540(v116);
        if (SBYTE7(v88) < 0) {
          operator delete(__p[0]);
        }
        if (v127)
        {
          int v23 = __str;
          int v24 = v126;
          if (__str != v126)
          {
            while (SHIBYTE(v23->__r_.__value_.__r.__words[2]) < 0)
            {
              if (v23->__r_.__value_.__l.__size_) {
                goto LABEL_62;
              }
LABEL_63:
              v23 += 4;
              if (v23 == v24) {
                goto LABEL_64;
              }
            }
            if (!*((unsigned char *)&v23->__r_.__value_.__s + 23)) {
              goto LABEL_63;
            }
LABEL_62:
            std::string::operator=((std::string *)(v11 + 1208), v23);
            goto LABEL_63;
          }
        }
LABEL_64:
        if (v21 == 16)
        {
          if (!v134)
          {
            std::string::value_type v27 = 9;
            LOBYTE(v28) = 37;
            int v66 = 70008;
LABEL_106:
            if (*(unsigned char *)(a1 + 360))
            {
              v116[0].__r_.__value_.__r.__words[0] = a1 + 336;
              sub_100B6C578((uint64_t **)(a1 + 992), (void **)(a1 + 336), (long long **)v116)[83] = 1;
              v116[0].__r_.__value_.__r.__words[0] = a1 + 336;
              uint64_t v36 = sub_100B6C578((uint64_t **)(a1 + 992), (void **)(a1 + 336), (long long **)v116);
              *((_DWORD *)v36 + 21) = 70008;
              v36[88] = 1;
              if (v134)
              {
                v116[0].__r_.__value_.__r.__words[0] = a1 + 336;
                uint64_t v37 = (std::string *)sub_100B6C578((uint64_t **)(a1 + 992), (void **)(a1 + 336), (long long **)v116);
                sub_100093B44(v37 + 4, &v133);
              }
            }
            CFTypeRef cf = 0;
            if (!*(unsigned char *)(a1 + 131) && v137)
            {
              if (SHIBYTE(v136) < 0)
              {
                sub_10004FC84(v69, (void *)v135, *((unint64_t *)&v135 + 1));
              }
              else
              {
                *(_OWORD *)BOOL v69 = v135;
                uint64_t v70 = v136;
              }
              if (SHIBYTE(v70) < 0)
              {
                sub_10004FC84(__p, v69[0], (unint64_t)v69[1]);
              }
              else
              {
                *(_OWORD *)long long __p = *(_OWORD *)v69;
                *(void *)&long long v88 = v70;
              }
              uint64_t v92 = 0;
              if (SBYTE7(v88) < 0)
              {
                sub_10004FC84(v116, __p[0], (unint64_t)__p[1]);
              }
              else
              {
                *(_OWORD *)&v116[0].__r_.__value_.__l.__data_ = *(_OWORD *)__p;
                v116[0].__r_.__value_.__r.__words[2] = v88;
              }
              uint64_t v93 = 0;
              if (ctu::cf::convert_copy())
              {
                long long v64 = v92;
                uint64_t v92 = v93;
                *(void *)int64_t v114 = v64;
                sub_1000558F4((const void **)v114);
              }
              if (SHIBYTE(v116[0].__r_.__value_.__r.__words[2]) < 0) {
                operator delete(v116[0].__r_.__value_.__l.__data_);
              }
              uint64_t v71 = v92;
              uint64_t v92 = 0;
              sub_1000558F4((const void **)&v92);
              if (SBYTE7(v88) < 0) {
                operator delete(__p[0]);
              }
              v116[0].__r_.__value_.__r.__words[0] = (std::string::size_type)cf;
              long long v65 = v71;
              uint64_t v71 = 0;
              CFTypeRef cf = v65;
              sub_1000558F4((const void **)&v116[0].__r_.__value_.__l.__data_);
              sub_1000558F4((const void **)&v71);
              if (SHIBYTE(v70) < 0) {
                operator delete(v69[0]);
              }
            }
            memset(&v116[0].__r_.__value_.__r.__words[1], 0, 88);
            v116[0].__r_.__value_.__r.__words[0] = a1;
            sub_100023950((uint64_t)&v116[0].__r_.__value_.__l.__size_, a3);
            if (*(char *)(a2 + 23) < 0)
            {
              sub_10004FC84(&v116[1].__r_.__value_.__s.__data_[16], *(void **)a2, *(void *)(a2 + 8));
            }
            else
            {
              *(_OWORD *)&v116[1].__r_.__value_.__r.__words[2] = *(_OWORD *)a2;
              v116[2].__r_.__value_.__l.__size_ = *(void *)(a2 + 16);
            }
            v116[2].__r_.__value_.__s.__data_[16] = v28;
            v116[3].__r_.__value_.__r.__words[0] = (std::string::size_type)cf;
            if (cf) {
              CFRetain(cf);
            }
            v116[3].__r_.__value_.__s.__data_[8] = v27;
            HIDWORD(v116[3].__r_.__value_.__r.__words[1]) = v66;
            v116[3].__r_.__value_.__r.__words[2] = v11;
            if (*(char *)(a2 + 23) < 0)
            {
              sub_10004FC84(v67, *(void **)a2, *(void *)(a2 + 8));
            }
            else
            {
              *(_OWORD *)uint64_t v67 = *(_OWORD *)a2;
              uint64_t v68 = *(void *)(a2 + 16);
            }
            int v38 = *(unsigned __int8 *)(a1 + 132);
            std::string::size_type v94 = v116[0].__r_.__value_.__r.__words[0];
            sub_1000DFC90((uint64_t)v95, (uint64_t)&v116[0].__r_.__value_.__l.__size_);
            if (v116[2].__r_.__value_.__s.__data_[15] < 0)
            {
              sub_10004FC84(&v96, (void *)v116[1].__r_.__value_.__r.__words[2], v116[2].__r_.__value_.__r.__words[0]);
            }
            else
            {
              long long v96 = *(_OWORD *)&v116[1].__r_.__value_.__r.__words[2];
              std::string::size_type size = v116[2].__r_.__value_.__l.__size_;
            }
            std::string::value_type v98 = v116[2].__r_.__value_.__s.__data_[16];
            std::string::pointer data = v116[3].__r_.__value_.__l.__data_;
            if (v116[3].__r_.__value_.__r.__words[0]) {
              CFRetain(v116[3].__r_.__value_.__l.__data_);
            }
            long long v100 = *(_OWORD *)&v116[3].__r_.__value_.__r.__words[1];
            uint64_t v102 = 0;
            uint64_t v39 = (char *)operator new(0x68uLL);
            std::string::size_type v40 = v94;
            *(void *)uint64_t v39 = off_101A3F620;
            *((void *)v39 + 1) = v40;
            sub_100023950((uint64_t)(v39 + 16), (uint64_t)v95);
            CFBooleanRef v41 = v39 + 48;
            if (SHIBYTE(size) < 0)
            {
              sub_10004FC84(v41, (void *)v96, *((unint64_t *)&v96 + 1));
            }
            else
            {
              *(_OWORD *)CFBooleanRef v41 = v96;
              *((void *)v39 + 8) = size;
            }
            v39[72] = v98;
            *((void *)v39 + 10) = data;
            std::string::pointer data = 0;
            *(_OWORD *)(v39 + 88) = v100;
            uint64_t v102 = v39;
            sub_100B5626C(a1, (unsigned __int8 **)v67, 3, 1, v38 != 0, 1, 1, 0, (uint64_t)v101);
            sub_100060644(v101);
            sub_1000558F4((const void **)&data);
            if (SHIBYTE(size) < 0) {
              operator delete((void *)v96);
            }
            sub_100060644(v95);
            if (SHIBYTE(v68) < 0) {
              operator delete(v67[0]);
            }
            sub_1000558F4((const void **)&v116[3].__r_.__value_.__l.__data_);
            if (v116[2].__r_.__value_.__s.__data_[15] < 0) {
              operator delete((void *)v116[1].__r_.__value_.__r.__words[2]);
            }
            sub_100060644(&v116[0].__r_.__value_.__l.__size_);
            sub_1000558F4(&cf);
            goto LABEL_193;
          }
        }
        else
        {
          if (v21 == 2)
          {
            uint64_t v79 = 0;
            int v80 = 0;
            sub_100B3EA60(a1, a2, 9, 0, &v80, &v79);
            sub_100057D78(&v79);
            sub_1000558F4(&v80);
            if (!*(unsigned char *)(a1 + 360))
            {
              v103[3] = 0;
              sub_100B4B5F8((void *)a1, 3, (uint64_t)v103);
              sub_100313668(v103);
              uint64_t v25 = *(void *)(a1 + 856);
              uint64_t v26 = *(void *)(a1 + 864);
              if (*(char *)(a2 + 23) < 0)
              {
                sub_10004FC84(v77, *(void **)a2, *(void *)(a2 + 8));
              }
              else
              {
                *(_OWORD *)uint64_t v77 = *(_OWORD *)a2;
                uint64_t v78 = *(void *)(a2 + 16);
              }
              uint64_t v54 = HIBYTE(v78);
              if (v25 != v26)
              {
                long long v56 = v77[0];
                int v55 = v77[1];
                if (v78 >= 0) {
                  int v57 = (void *)HIBYTE(v78);
                }
                else {
                  int v57 = v77[1];
                }
                while (1)
                {
                  uint64_t v58 = (void *)*(unsigned __int8 *)(v25 + 455);
                  int v59 = (char)v58;
                  if ((char)v58 < 0) {
                    uint64_t v58 = *(void **)(v25 + 440);
                  }
                  if (v57 == v58)
                  {
                    if (v59 >= 0) {
                      int v60 = (unsigned __int8 *)(v25 + 432);
                    }
                    else {
                      int v60 = *(unsigned __int8 **)(v25 + 432);
                    }
                    if ((v54 & 0x80) != 0)
                    {
                      if (!memcmp(v56, v60, (size_t)v55))
                      {
                        char v63 = 1;
                        goto LABEL_188;
                      }
                    }
                    else
                    {
                      if (!v54)
                      {
                        char v63 = 1;
                        goto LABEL_189;
                      }
                      uint64_t v61 = v77;
                      uint64_t v62 = v54;
                      while (*(unsigned __int8 *)v61 == *v60)
                      {
                        uint64_t v61 = (void **)((char *)v61 + 1);
                        ++v60;
                        if (!--v62)
                        {
                          char v63 = 1;
                          goto LABEL_187;
                        }
                      }
                    }
                  }
                  v25 += 1248;
                  if (v25 == v26)
                  {
                    char v63 = 0;
                    goto LABEL_187;
                  }
                }
              }
              char v63 = 0;
LABEL_187:
              if ((v54 & 0x80) != 0) {
LABEL_188:
              }
                operator delete(v77[0]);
LABEL_189:
              v116[0].__r_.__value_.__s.__data_[0] = 4;
              LOBYTE(__p[0]) = 9;
              sub_100B4B75C(a1, v116, (unsigned __int8 *)__p, v11, v63, *(unsigned __int8 *)(v11 + 1284));
            }
            LOBYTE(v93) = 9;
            v116[0].__r_.__value_.__r.__words[0] = 0;
            LOBYTE(v92) = 0;
            __p[0] = 0;
            v114[0] = 0;
            v114[4] = 0;
            sub_100B3E598((void *)a1, (unsigned __int8 **)a2, (unsigned __int8 *)&v93, 1, (const void **)&v116[0].__r_.__value_.__l.__data_, (char *)&v92, (const void **)__p, 0, 0, (uint64_t)v114, &v91);
            sub_100057D78((const void **)__p);
            sub_1000558F4((const void **)&v116[0].__r_.__value_.__l.__data_);
            goto LABEL_191;
          }
          if (!v134) {
            goto LABEL_81;
          }
          std::string::size_type v29 = HIBYTE(v133.__r_.__value_.__r.__words[2]);
          if ((v133.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
            std::string::size_type v29 = v133.__r_.__value_.__l.__size_;
          }
          if (!v29)
          {
LABEL_81:
            switch(v21)
            {
              case 0xBu:
                uint64_t v49 = *(void *)(a1 + 328);
                *(_WORD *)(v49 + 1512) = 257;
                *(_WORD *)(v49 + 1461) = 257;
                break;
              case 0xAu:
                uint64_t v48 = *(void *)(a1 + 328);
                *(unsigned char *)(v48 + 1513) = 1;
                *(unsigned char *)(v48 + 1462) = 1;
                break;
              case 9u:
                uint64_t v31 = *(void *)(a1 + 328);
                *(unsigned char *)(v31 + 1512) = 1;
                *(unsigned char *)(v31 + 1461) = 1;
                break;
            }
            uint64_t v50 = *(NSObject **)(a1 + 40);
            if (os_log_type_enabled(v50, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v51 = sub_1008A1E44(v21);
              LODWORD(v116[0].__r_.__value_.__l.__data_) = 136315138;
              *(std::string::size_type *)((char *)v116[0].__r_.__value_.__r.__words + 4) = (std::string::size_type)v51;
              _os_log_impl((void *)&_mh_execute_header, v50, OS_LOG_TYPE_DEFAULT, "#I TransferType: %s", (uint8_t *)v116, 0xCu);
            }
            if (*(unsigned char *)(a1 + 131))
            {
              if (!sub_1008A200C(v21))
              {
                uint64_t v53 = *(NSObject **)(a1 + 40);
                if (os_log_type_enabled(v53, OS_LOG_TYPE_ERROR))
                {
                  LOWORD(v116[0].__r_.__value_.__l.__data_) = 0;
                  _os_log_error_impl((void *)&_mh_execute_header, v53, OS_LOG_TYPE_ERROR, "Non one-click transfer not allowed in buddy", (uint8_t *)v116, 2u);
                }
                LOBYTE(v93) = 11;
                v116[0].__r_.__value_.__r.__words[0] = 0;
                LOBYTE(v92) = 40;
                __p[0] = 0;
                *(_DWORD *)int64_t v114 = 70022;
                v114[4] = 1;
                sub_100B3E598((void *)a1, (unsigned __int8 **)a2, (unsigned __int8 *)&v93, 0, (const void **)&v116[0].__r_.__value_.__l.__data_, (char *)&v92, (const void **)__p, 6u, 1, (uint64_t)v114, &v91);
                sub_100057D78((const void **)__p);
                sub_1000558F4((const void **)&v116[0].__r_.__value_.__l.__data_);
                sub_100058DB0(__p, "WebsheetRequiredInbuddy");
                v116[0].__r_.__value_.__l.__size_ = 1;
                v116[0].__r_.__value_.__r.__words[0] = (std::string::size_type)sub_100B6D7B0;
                sub_100B4A9E0((void *)a1, a2, (uint64_t)__p, v116);
                sub_100146540(v116);
                if (SBYTE7(v88) < 0) {
                  operator delete(__p[0]);
                }
LABEL_191:
                char v52 = 1;
                goto LABEL_192;
              }
              char v52 = 0;
            }
            else
            {
              char v52 = 0;
            }
LABEL_192:
            sub_1000607A8(a3, v52);
LABEL_193:
            sub_1008C2D48((uint64_t)buf);
            return;
          }
        }
        sub_100B5457C((char *)v116, a1, a2, (unsigned __int8 **)&v133);
        int v28 = sub_100CDAF4C((unsigned __int8 *)v116);
        if (SHIBYTE(v116[0].__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v116[0].__r_.__value_.__l.__data_);
        }
        int v30 = 70040;
        if (v28 > 53)
        {
          if (v28 == 54)
          {
            int v30 = 70042;
          }
          else if (v28 == 55)
          {
            int v30 = 70044;
          }
        }
        else if (v28 == 37)
        {
          int v30 = 70043;
        }
        else if (v28 == 53)
        {
          int v30 = 70041;
        }
        int v66 = v30;
        sub_100093B44((std::string *)(v11 + 1480), &v133);
        if (*(char *)(a2 + 23) < 0)
        {
          sub_10004FC84(v75, *(void **)a2, *(void *)(a2 + 8));
        }
        else
        {
          *(_OWORD *)uint64_t v75 = *(_OWORD *)a2;
          uint64_t v76 = *(void *)(a2 + 16);
        }
        ctu::hex((uint64_t *)v73, (ctu *)(v11 + 1032), (const void *)0x10, v32);
        sub_100B554EC(*(void *)(a1 + 144), *(void *)(a1 + 152), 16, (uint64_t)v75, (unsigned __int8 *)v73);
        if (v74 < 0) {
          operator delete(v73[0]);
        }
        if (SHIBYTE(v76) < 0) {
          operator delete(v75[0]);
        }
        uint64_t v33 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
        {
          if ((v133.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            uint64_t v34 = &v133;
          }
          else {
            uint64_t v34 = (std::string *)v133.__r_.__value_.__r.__words[0];
          }
          if (*(char *)(a2 + 23) >= 0) {
            BOOL v35 = (unsigned __int8 *)a2;
          }
          else {
            BOOL v35 = *(unsigned __int8 **)a2;
          }
          LODWORD(v116[0].__r_.__value_.__l.__data_) = 136315394;
          *(std::string::size_type *)((char *)v116[0].__r_.__value_.__r.__words + 4) = (std::string::size_type)v34;
          WORD2(v116[0].__r_.__value_.__r.__words[1]) = 2080;
          *(std::string::size_type *)((char *)&v116[0].__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v35;
          _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "#E Carrier error-code in TA response: %s for source iccid:%s", (uint8_t *)v116, 0x16u);
        }
        std::string::value_type v27 = 7;
        goto LABEL_106;
      }
LABEL_43:
      unsigned int v21 = sub_1008A1FE0(buf[0]);
      goto LABEL_47;
    }
    uint64_t v18 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "Failed Transfer Type retrieval. empty response", buf, 2u);
    }
    if (*(unsigned char *)(a1 + 360))
    {
      *(void *)long long buf = a1 + 336;
      sub_100B6C578((uint64_t **)(a1 + 992), (void **)(a1 + 336), (long long **)buf)[83] = 1;
      *(void *)long long buf = a1 + 336;
      uint64_t v19 = sub_100B6C578((uint64_t **)(a1 + 992), (void **)(a1 + 336), (long long **)buf);
      *((_DWORD *)v19 + 21) = 70010;
      v19[88] = 1;
    }
    v114[0] = 11;
    *(void *)long long buf = 0;
    LOBYTE(v93) = 52;
    v116[0].__r_.__value_.__r.__words[0] = 0;
    LODWORD(__p[0]) = 70010;
    BYTE4(__p[0]) = 1;
    sub_100B3E598((void *)a1, (unsigned __int8 **)a2, v114, 0, (const void **)buf, (char *)&v93, (const void **)&v116[0].__r_.__value_.__l.__data_, 7u, 1, (uint64_t)__p, &v91);
    sub_100057D78((const void **)&v116[0].__r_.__value_.__l.__data_);
    sub_1000558F4((const void **)buf);
    sub_1000607A8(a3, 1);
  }
}

void sub_100B585B4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20,int a21,__int16 a22,char a23,char a24,uint64_t a25,const void *a26,void *a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,void *a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,void *a46,uint64_t a47,uint64_t a48,uint64_t a49,void *__p,uint64_t a51,int a52,__int16 a53,char a54,char a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,const void *a61)
{
  if (a55 < 0) {
    operator delete(__p);
  }
  if (a24 < 0) {
    operator delete(a19);
  }
  sub_1000558F4(&a26);
  sub_1008C2D48((uint64_t)&STACK[0x630]);
  _Unwind_Resume(a1);
}

BOOL sub_100B588AC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v6 = *(void *)(a6 + 24);
  if (v6)
  {
    uint64_t v12 = (uint64_t *)sub_100B5B348(a1);
    int v13 = *(NSObject **)(a1 + 40);
    if (!*v12)
    {
      if (os_log_type_enabled(*(os_log_t *)(a1 + 40), OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "invalid webservice delegate", buf, 2u);
      }
      v26[0] = 0;
      v26[272] = 0;
      sub_100776E68(a6, (uint64_t)v26, 0);
      int v23 = v26;
      goto LABEL_14;
    }
    uint64_t v14 = v12;
    if (os_log_type_enabled(*(os_log_t *)(a1 + 40), OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v15 = entitlements::asString();
      uint64_t v16 = a2;
      if (*(char *)(a2 + 23) < 0) {
        uint64_t v16 = *(void *)a2;
      }
      *(_DWORD *)long long buf = 136446466;
      uint64_t v33 = v15;
      __int16 v34 = 2080;
      uint64_t v35 = v16;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I [req][tapost] perform TransferAuthorization with WebServiceRequest [%{public}s] post request. source iccid : %s", buf, 0x16u);
    }
    sub_100B55694(a1, 1);
    *(_DWORD *)long long buf = sub_100B5B3E4((void *)a1, a2);
    uint64_t v17 = *v14;
    *(void *)&long long v27 = a1;
    uint64_t v18 = *(std::__shared_weak_count **)(a1 + 16);
    if (!v18 || (v19 = *(void *)(a1 + 8), (unint64_t v20 = std::__shared_weak_count::lock(v18)) == 0)) {
      sub_100088B9C();
    }
    *((void *)&v27 + 1) = v19;
    int v28 = v20;
    atomic_fetch_add_explicit(&v20->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v20);
    sub_100777EB8((uint64_t)v29, a6);
    uint64_t v31 = 0;
    unsigned int v21 = (char *)operator new(0x40uLL);
    *(void *)unsigned int v21 = off_101A3F930;
    *(_OWORD *)(v21 + 8) = v27;
    *((void *)v21 + 3) = v28;
    *((void *)&v27 + 1) = 0;
    int v28 = 0;
    sub_1007780F0((uint64_t)(v21 + 32), (uint64_t)v29);
    uint64_t v31 = v21;
    char v22 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint8_t *, void *))(*(void *)v17 + 16))(v17, a3, a4, buf, v30);
    sub_100777F50(v30);
    sub_100777F50(v29);
    if ((v22 & 1) == 0)
    {
      sub_100B55694(a1, 0);
      v25[0] = 0;
      v25[272] = 0;
      sub_100776E68(a6, (uint64_t)v25, 0);
      int v23 = v25;
LABEL_14:
      sub_100777C48((uint64_t)v23);
    }
  }
  return v6 != 0;
}

void sub_100B58B68(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_100B58BC4(uint64_t a1)
{
  if (*(char *)(a1 + 671) < 0) {
    operator delete(*(void **)(a1 + 648));
  }
  sub_1008C2D48(a1 + 56);
  sub_100060644((void *)(a1 + 24));
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

uint64_t sub_100B58C14(uint64_t a1)
{
  if (*(char *)(a1 + 63) < 0) {
    operator delete(*(void **)(a1 + 40));
  }
  sub_100060644((void *)(a1 + 8));
  return a1;
}

uint64_t sub_100B58C58(uint64_t a1)
{
  if (*(char *)(a1 + 87) < 0) {
    operator delete(*(void **)(a1 + 64));
  }
  if (*(char *)(a1 + 63) < 0) {
    operator delete(*(void **)(a1 + 40));
  }
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 32);
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  return a1;
}

void sub_100B58CB4(void *a1, void *a2, int a3, int a4)
{
  uint64_t v5 = (std::__shared_weak_count *)a1[6];
  if (v5)
  {
    uint64_t v9 = a1[4];
    uint64_t v10 = std::__shared_weak_count::lock(v5);
    if (v10 && a1[5])
    {
      sub_100B55694(v9, 0);
      uint64_t v11 = *a2;
      if (a3 && v11 && *(void *)(v11 + 8))
      {
        uint64_t v12 = *(NSObject **)(v9 + 40);
        if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
        {
          int v13 = sub_100FB56F4(*(_DWORD *)v11);
          *(_DWORD *)long long buf = 136315138;
          *(void *)&uint8_t buf[4] = v13;
          _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I TSS response with status: %s", buf, 0xCu);
          uint64_t v11 = *a2;
        }
        if (*(_DWORD *)v11 == 6000)
        {
          uint64_t v14 = a1[7];
          sub_100058DB0(v35, "TransferSimServiceResponse");
          uint64_t v15 = *(void *)(*a2 + 8);
          memset(buf, 0, sizeof(buf));
          sub_100B6D288(buf, v15);
          sub_100B4A9E0((void *)v9, v14, (uint64_t)v35, (void (**)(void, void, void, void, void))buf);
          sub_100146540((uint64_t (**)(void, void, void, void, void))buf);
          if (v36 < 0) {
            operator delete(v35[0]);
          }
          uint64_t v11 = *a2;
        }
        uint64_t v16 = a1[7];
        sub_10030DBE4((uint64_t)v34, *(void *)(v11 + 8));
        v34[152] = 1;
        sub_100B591A0(v9, v16, (uint64_t)v34);
        sub_10030D3C0((uint64_t)v34);
      }
      else
      {
        long long v42 = 0u;
        long long v41 = 0u;
        *(void *)long long buf = v9;
        *(void *)&uint8_t buf[8] = v11;
        uint64_t v19 = (std::__shared_weak_count *)a2[1];
        std::string::size_type v40 = v19;
        if (v19) {
          atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        unint64_t v20 = (long long *)a1[7];
        if (*((char *)v20 + 23) < 0)
        {
          sub_10004FC84(&v41, *(void **)v20, *((void *)v20 + 1));
          unint64_t v20 = (long long *)a1[7];
        }
        else
        {
          long long v21 = *v20;
          *(void *)&long long v42 = *((void *)v20 + 2);
          long long v41 = v21;
        }
        DWORD2(v42) = a4;
        if (*((char *)v20 + 23) < 0)
        {
          sub_10004FC84(__dst, *(void **)v20, *((void *)v20 + 1));
        }
        else
        {
          long long v22 = *v20;
          uint64_t v33 = *((void *)v20 + 2);
          *(_OWORD *)long long __dst = v22;
        }
        int v23 = *(unsigned __int8 *)(v9 + 132);
        long long v27 = *(_OWORD *)buf;
        int v28 = v40;
        if (v40) {
          atomic_fetch_add_explicit(&v40->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        if (SBYTE7(v42) < 0)
        {
          sub_10004FC84(&__p, (void *)v41, *((unint64_t *)&v41 + 1));
        }
        else
        {
          long long __p = v41;
          uint64_t v30 = v42;
        }
        int v24 = DWORD2(v42);
        int v31 = DWORD2(v42);
        int v38 = 0;
        uint64_t v25 = (char *)operator new(0x40uLL);
        *(void *)uint64_t v25 = off_101A3F7B0;
        *(_OWORD *)(v25 + 8) = v27;
        *((void *)v25 + 3) = v28;
        uint64_t v26 = v25 + 32;
        if (SHIBYTE(v30) < 0)
        {
          sub_10004FC84(v26, (void *)__p, *((unint64_t *)&__p + 1));
          int v24 = v31;
        }
        else
        {
          *(_OWORD *)uint64_t v26 = __p;
          *((void *)v25 + 6) = v30;
        }
        *((_DWORD *)v25 + 14) = v24;
        int v38 = v25;
        sub_100B5626C(v9, (unsigned __int8 **)__dst, a4, a3, v23 != 0, 0, 0, 8, (uint64_t)v37);
        sub_100060644(v37);
        if (SHIBYTE(v30) < 0) {
          operator delete((void *)__p);
        }
        if (SHIBYTE(v33) < 0) {
          operator delete(__dst[0]);
        }
        if (SBYTE7(v42) < 0) {
          operator delete((void *)v41);
        }
        if (v40) {
          sub_10004D2C8(v40);
        }
      }
      goto LABEL_17;
    }
  }
  else
  {
    uint64_t v10 = 0;
  }
  uint64_t v17 = (ctu::OsLogContext *)ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)buf, kCtLoggingSystemName, "cp.tr.ctr");
  uint64_t v18 = *(NSObject **)&buf[8];
  ctu::OsLogContext::~OsLogContext(v17);
  if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "invalid CellularPlanTransferFlowController (weak_ptr)", buf, 2u);
    if (!v10) {
      return;
    }
  }
  else if (!v10)
  {
    return;
  }
LABEL_17:
  sub_10004D2C8(v10);
}

void sub_100B590C0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24,char a25)
{
  sub_100146540((uint64_t (**)(void, void, void, void, void))(v26 - 144));
  if (*(char *)(v26 - 177) < 0) {
    operator delete(*(void **)(v26 - 200));
  }
  sub_10004D2C8(v25);
  _Unwind_Resume(a1);
}

const void **sub_100B591A0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = a1;
  uint64_t v6 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    if (*(char *)(a2 + 23) >= 0) {
      uint64_t v7 = (unsigned __int8 *)a2;
    }
    else {
      uint64_t v7 = *(unsigned __int8 **)a2;
    }
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = v7;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I [resp][tss] processing TransferSIM response. source iccid : %s", buf, 0xCu);
  }
  *(unsigned char *)(v5 + 138) = 0;
  uint64_t v8 = *(void *)(v5 + 312);
  CFStringRef result = (const void **)sub_100B45F5C(*(void *)(v5 + 304), v8, (unsigned __int8 **)a2);
  char v132 = result;
  if ((const void **)v8 == result) {
    return result;
  }
  CFTypeRef v130 = 0;
  CFTypeRef cf = 0;
  if (!*(unsigned char *)(a3 + 152))
  {
    int v13 = *(NSObject **)(v5 + 40);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#E No response for Transfer Sim service", buf, 2u);
    }
    sub_100058DB0(buf, "TransferSimServiceResponse");
    sub_100058DB0(&buf[24], "TransferSimServiceViaWebServiceResponse");
    memset(v167, 0, 24);
    *(void *)&long long v161 = v167;
    *((void *)&v161 + 1) = 0;
    *(void *)std::string v167 = operator new(0x30uLL);
    *(void *)&v167[8] = *(void *)v167;
    *(void *)&v167[16] = *(void *)v167 + 48;
    *(void *)&v167[8] = sub_1000D8A18((uint64_t)&v167[16], (long long *)buf, (long long *)&buf[48], *(char **)v167);
    sub_100B52308((void *)v5, a2, (uint64_t)v167);
    *(void *)&long long v161 = v167;
    sub_100047F64((void ***)&v161);
    for (uint64_t i = 0; i != -48; i -= 24)
    {
      if ((char)buf[i + 47] < 0) {
        operator delete(*(void **)&buf[i + 24]);
      }
    }
    LOBYTE(v161) = 11;
    LOBYTE(__s1) = 56;
    sub_10004EFE4(buf, &v130);
    *(_DWORD *)std::string v167 = 70025;
    v167[4] = 1;
    sub_100B3E598((void *)v5, (unsigned __int8 **)a2, (unsigned __int8 *)&v161, 0, &cf, (char *)&__s1, (const void **)buf, 0, 1, (uint64_t)v167, (uint64_t *)&v132);
    goto LABEL_83;
  }
  uint64_t v10 = (uint64_t)result;
  char v11 = *(unsigned char *)(a3 + 151);
  if (v11 < 0) {
    uint64_t v12 = *(void *)(a3 + 136);
  }
  else {
    uint64_t v12 = *(unsigned __int8 *)(a3 + 151);
  }
  if (v12)
  {
    uint64_t v15 = *(NSObject **)(v5 + 40);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v16 = a3 + 128;
      if (v11 < 0) {
        uint64_t v16 = *(void *)(a3 + 128);
      }
      if (*(char *)(a2 + 23) >= 0) {
        uint64_t v17 = (unsigned __int8 *)a2;
      }
      else {
        uint64_t v17 = *(unsigned __int8 **)a2;
      }
      *(_DWORD *)long long buf = 136315394;
      *(void *)&uint8_t buf[4] = v16;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&unsigned char buf[14] = v17;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#E Carrier error in response: %s for source iccid:%s", buf, 0x16u);
    }
    sub_100B5457C(buf, v5, a2, (unsigned __int8 **)(a3 + 128));
    int v18 = sub_100CDAF4C(buf);
    if ((buf[23] & 0x80000000) != 0) {
      operator delete(*(void **)buf);
    }
    uint64_t v19 = *(std::string **)a3;
    if (*(void *)a3 != *(void *)(a3 + 8))
    {
      if (SHIBYTE(v19->__r_.__value_.__r.__words[2]) < 0)
      {
        if (v19->__r_.__value_.__l.__size_)
        {
LABEL_31:
          if (v18 == 57)
          {
            CFTypeRef v116 = cf;
            sub_10004EFE4(&v115, &v130);
            sub_100B3EA60(v5, a2, 5, 57, &v116, &v115);
            sub_100057D78(&v115);
            sub_1000558F4(&v116);
          }
          goto LABEL_33;
        }
      }
      else if (*((unsigned char *)&v19->__r_.__value_.__s + 23))
      {
        goto LABEL_31;
      }
    }
    if (v18 == 57) {
      int v18 = 52;
    }
    if (!*(unsigned char *)(v10 + 1465)) {
      *(_WORD *)(v10 + 1464) = 263;
    }
    int v20 = 70040;
    if (v18 > 53)
    {
      if (v18 == 54)
      {
        int v20 = 70042;
      }
      else if (v18 == 55)
      {
        int v20 = 70044;
      }
    }
    else if (v18 == 37)
    {
      int v20 = 70043;
    }
    else if (v18 == 53)
    {
      int v20 = 70041;
    }
    *(_DWORD *)(v10 + 1468) = v20;
    *(unsigned char *)(v10 + 1472) = 1;
    sub_100093B44((std::string *)(v10 + 1480), (const std::string *)(a3 + 128));
    if (!*(unsigned char *)(v5 + 131) && *(unsigned char *)(a3 + 48))
    {
      memset(v167, 0, 24);
      if (*(char *)(a3 + 47) < 0)
      {
        sub_10004FC84(v167, *(void **)(a3 + 24), *(void *)(a3 + 32));
      }
      else
      {
        *(_OWORD *)std::string v167 = *(_OWORD *)(a3 + 24);
        *(void *)&v167[16] = *(void *)(a3 + 40);
      }
      if ((v167[23] & 0x80u) == 0) {
        char v63 = v167;
      }
      else {
        char v63 = *(uint8_t **)v167;
      }
      CFStringRef v64 = CFStringCreateWithCString(kCFAllocatorDefault, (const char *)v63, 0x8000100u);
      CFTypeRef v65 = cf;
      CFTypeRef cf = v64;
      *(void *)long long buf = v65;
      sub_1000558F4((const void **)buf);
      uint64_t v158 = 0;
      long long v156 = 0u;
      long long v157 = 0u;
      long long v154 = 0u;
      long long v155 = 0u;
      long long v152 = 0u;
      long long v153 = 0u;
      long long v150 = 0u;
      long long v151 = 0u;
      long long v148 = 0u;
      long long v149 = 0u;
      long long v146 = 0u;
      long long v147 = 0u;
      long long v144 = 0u;
      long long v145 = 0u;
      long long v142 = 0u;
      long long v143 = 0u;
      memset(buf, 0, sizeof(buf));
      sub_1000593FC((uint64_t)&v128, (long long *)(a3 + 56));
      sub_100B5B0EC((uint64_t)buf, v10, &v128);
      if (v129 && SHIBYTE(v128.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v128.__r_.__value_.__l.__data_);
      }
      CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
      if (Mutable)
      {
        CFTypeRef v67 = v130;
        CFTypeRef v130 = Mutable;
        *(void *)&long long v161 = v67;
        sub_10005717C((const void **)&v161);
        CFTypeRef v127 = v130;
        if (v130) {
          CFRetain(v130);
        }
        sub_100DDCEB8((CFMutableDictionaryRef *)&v127, (uint64_t)buf);
        sub_10005717C(&v127);
      }
      sub_100310520((uint64_t)buf);
      if ((char)v167[23] < 0) {
        operator delete(*(void **)v167);
      }
    }
    memset(&buf[8], 0, 64);
    *(void *)long long buf = v5;
    if (*(char *)(a2 + 23) < 0)
    {
      sub_10004FC84(&buf[8], *(void **)a2, *(void *)(a2 + 8));
    }
    else
    {
      *(_OWORD *)&uint8_t buf[8] = *(_OWORD *)a2;
      *(void *)&unsigned char buf[24] = *(void *)(a2 + 16);
    }
    uint8_t buf[32] = 0;
    *(void *)&uint8_t buf[40] = cf;
    if (cf) {
      CFRetain(cf);
    }
    buf[48] = v18;
    *(void *)&unsigned char buf[56] = v130;
    if (v130) {
      CFRetain(v130);
    }
    *(void *)&buf[64] = v10;
    sub_100058DB0(v167, "TransferSimServiceResponse");
    sub_100058DB0(&v167[24], "TransferSimServiceViaWebServiceResponse");
    long long v161 = 0uLL;
    uint64_t v162 = 0;
    *(void *)&long long __s1 = &v161;
    *((void *)&__s1 + 1) = 0;
    *(void *)&long long v161 = operator new(0x30uLL);
    *((void *)&v161 + 1) = v161;
    uint64_t v162 = v161 + 48;
    *((void *)&v161 + 1) = sub_1000D8A18((uint64_t)&v162, (long long *)v167, v169, (char *)v161);
    sub_100B52308((void *)v5, a2, (uint64_t)&v161);
    *(void *)&long long __s1 = &v161;
    sub_100047F64((void ***)&__s1);
    for (uint64_t j = 0; j != -48; j -= 24)
    {
      if (*((char *)&v168 + j + 15) < 0) {
        operator delete(*(void **)&v167[j + 24]);
      }
    }
    if (*(char *)(a2 + 23) < 0)
    {
      sub_10004FC84(&v125, *(void **)a2, *(void *)(a2 + 8));
    }
    else
    {
      long long v125 = *(_OWORD *)a2;
      uint64_t v126 = *(void *)(a2 + 16);
    }
    int v48 = *(unsigned __int8 *)(v5 + 132);
    uint64_t v117 = *(void *)buf;
    if ((buf[31] & 0x80000000) != 0)
    {
      sub_10004FC84(&v118, *(void **)&buf[8], *(unint64_t *)&buf[16]);
    }
    else
    {
      long long v118 = *(_OWORD *)&buf[8];
      uint64_t v119 = *(void *)&buf[24];
    }
    char v120 = buf[32];
    long long v121 = *(const void **)&buf[40];
    if (*(void *)&buf[40]) {
      CFRetain(*(CFTypeRef *)&buf[40]);
    }
    char v122 = buf[48];
    xpc_object_t v123 = *(const void **)&buf[56];
    if (*(void *)&buf[56]) {
      CFRetain(*(CFTypeRef *)&buf[56]);
    }
    uint64_t v49 = *(void *)&buf[64];
    uint64_t v124 = *(void *)&buf[64];
    long long v140 = 0;
    uint64_t v50 = (char *)operator new(0x50uLL);
    uint64_t v51 = v117;
    *(void *)uint64_t v50 = off_101A3F830;
    *((void *)v50 + 1) = v51;
    char v52 = v50 + 16;
    if (SHIBYTE(v119) < 0)
    {
      sub_10004FC84(v52, (void *)v118, *((unint64_t *)&v118 + 1));
      uint64_t v49 = v124;
    }
    else
    {
      *(_OWORD *)char v52 = v118;
      *((void *)v50 + 4) = v119;
    }
    v50[40] = v120;
    *((void *)v50 + 6) = v121;
    v50[56] = v122;
    uint64_t v53 = v123;
    long long v121 = 0;
    xpc_object_t v123 = 0;
    *((void *)v50 + 8) = v53;
    *((void *)v50 + 9) = v49;
    long long v140 = v50;
    sub_100B5626C(v5, (unsigned __int8 **)&v125, 3, 1, v48 != 0, 1, 1, 8, (uint64_t)v139);
    sub_100060644(v139);
    sub_10005717C(&v123);
    sub_1000558F4(&v121);
    if (SHIBYTE(v119) < 0) {
      operator delete((void *)v118);
    }
    if (SHIBYTE(v126) < 0) {
      operator delete((void *)v125);
    }
    sub_10005717C((const void **)&buf[56]);
    sub_1000558F4((const void **)&buf[40]);
    if ((buf[31] & 0x80000000) != 0) {
      operator delete(*(void **)&buf[8]);
    }
    goto LABEL_292;
  }
LABEL_33:
  if (v10 + 1296 != a3) {
    sub_1008C278C(v10 + 1296, *(std::string **)a3, *(std::string **)(a3 + 8), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a3 + 8) - *(void *)a3) >> 5));
  }
  if (!*(unsigned char *)(a3 + 112)) {
    goto LABEL_52;
  }
  if (*(char *)(a3 + 111) < 0)
  {
    if (*(void *)(a3 + 96)) {
      goto LABEL_38;
    }
LABEL_52:
    sub_100B4AC10(v5, buf);
    sub_100B52128((void *)v5, a2, (uint64_t)buf);
    if ((buf[23] & 0x80000000) != 0) {
      operator delete(*(void **)buf);
    }
    goto LABEL_54;
  }
  if (!*(unsigned char *)(a3 + 111)) {
    goto LABEL_52;
  }
LABEL_38:
  sub_100B52128((void *)v5, a2, a3 + 88);
LABEL_54:
  if (*(unsigned char *)(a3 + 123) && !*(unsigned char *)(a3 + 122) && *(unsigned char *)(a3 + 48))
  {
    uint64_t v21 = *(unsigned __int8 *)(a3 + 47);
    if ((v21 & 0x80u) != 0) {
      uint64_t v21 = *(void *)(a3 + 32);
    }
    if (v21 && *(unsigned char *)(a3 + 80) && sub_100B515C8(v5, (unsigned __int8 **)a2))
    {
      long long v151 = 0u;
      long long v152 = 0u;
      long long v149 = 0u;
      long long v150 = 0u;
      long long v147 = 0u;
      long long v148 = 0u;
      long long v145 = 0u;
      long long v146 = 0u;
      long long v143 = 0u;
      long long v144 = 0u;
      long long v142 = 0u;
      memset(buf, 0, sizeof(buf));
      if (*(unsigned char *)(a3 + 80)) {
        sub_100093B44((std::string *)&buf[32], (const std::string *)(a3 + 56));
      }
      if (*(unsigned char *)(v10 + 1476))
      {
        *(void *)&v169[0] = 0;
        long long v168 = 0u;
        memset(v167, 0, sizeof(v167));
        sub_100B51674((uint64_t *)&v161, (void *)v5, a2);
        sub_10005CBB4((uint64_t *)v167);
        *(_OWORD *)std::string v167 = v161;
        *(void *)&v167[16] = v162;
        uint64_t v162 = 0;
        long long v161 = 0uLL;
        *(void *)&long long __s1 = &v161;
        sub_100047F64((void ***)&__s1);
        if (*(void *)&v167[8] != *(void *)v167)
        {
          sub_100B519F8((std::string *)&v149, (uint64_t)v167);
          long long v22 = *(NSObject **)(v5 + 40);
          if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
          {
            if (*(char *)(a2 + 23) >= 0) {
              int v23 = (unsigned __int8 *)a2;
            }
            else {
              int v23 = *(unsigned __int8 **)a2;
            }
            LODWORD(v161) = 136315138;
            *(void *)((char *)&v161 + 4) = v23;
            _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "#I Set transfer-metadata for sourceIccid [%s] in TSS HTTP POST", (uint8_t *)&v161, 0xCu);
          }
        }
        if (LOBYTE(v169[0]) && SHIBYTE(v168) < 0) {
          operator delete(*(void **)&v167[24]);
        }
        *(void *)&long long v161 = v167;
        sub_100047F64((void ***)&v161);
      }
      uint64_t v24 = *(void *)(v5 + 328);
      if (v24 == *(void *)(v5 + 312))
      {
        uint64_t v68 = *(NSObject **)(v5 + 40);
        if (os_log_type_enabled(v68, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)std::string v167 = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v68, OS_LOG_TYPE_ERROR, "invalid fCurrentTransferIccid. skip perform tss.webservice request", v167, 2u);
        }
        goto LABEL_291;
      }
      uint64_t v25 = (long long *)(v24 + 1048);
      uint64_t v26 = *(void *)(v5 + 856);
      uint64_t v27 = *(void *)(v5 + 864);
      if (*(char *)(v24 + 1071) < 0)
      {
        sub_10004FC84(&__s1, *(void **)(v24 + 1048), *(void *)(v24 + 1056));
      }
      else
      {
        long long __s1 = *v25;
        uint64_t v160 = *(void *)(v24 + 1064);
      }
      uint64_t v76 = HIBYTE(v160);
      if (v26 != v27)
      {
        size_t v77 = *((void *)&__s1 + 1);
        uint64_t v78 = (const void *)__s1;
        if (v160 >= 0) {
          uint64_t v79 = HIBYTE(v160);
        }
        else {
          uint64_t v79 = *((void *)&__s1 + 1);
        }
        do
        {
          uint64_t v80 = *(unsigned __int8 *)(v26 + 455);
          int v81 = (char)v80;
          if ((v80 & 0x80u) != 0) {
            uint64_t v80 = *(void *)(v26 + 440);
          }
          if (v79 == v80)
          {
            if (v81 >= 0) {
              char v82 = (unsigned __int8 *)(v26 + 432);
            }
            else {
              char v82 = *(unsigned __int8 **)(v26 + 432);
            }
            if ((v76 & 0x80) != 0)
            {
              if (!memcmp(v78, v82, v77)) {
                goto LABEL_263;
              }
            }
            else
            {
              if (!v76) {
                goto LABEL_264;
              }
              p_s1 = &__s1;
              uint64_t v84 = v76;
              while (*(unsigned __int8 *)p_s1 == *v82)
              {
                p_s1 = (long long *)((char *)p_s1 + 1);
                ++v82;
                if (!--v84) {
                  goto LABEL_262;
                }
              }
            }
          }
          v26 += 1248;
        }
        while (v26 != v27);
        uint64_t v26 = v27;
      }
LABEL_262:
      if ((v76 & 0x80) != 0) {
LABEL_263:
      }
        operator delete((void *)__s1);
LABEL_264:
      if (v26 != *(void *)(v5 + 864))
      {
        uint64_t v85 = *(char *)(v26 + 823) < 0 ? *(void *)(v26 + 808) : *(unsigned __int8 *)(v26 + 823);
        if (!v85 && !*(unsigned char *)(v5 + 132))
        {
          uint64_t v170 = 0;
          long long v168 = 0u;
          memset(v169, 0, sizeof(v169));
          memset(v167, 0, sizeof(v167));
          sub_10030E6AC(v167, v26 + 688);
          if ((_BYTE)v170)
          {
            uint64_t v93 = *(NSObject **)(v5 + 40);
            if (os_log_type_enabled(v93, OS_LOG_TYPE_DEFAULT))
            {
              sub_1008C223C((uint64_t *)v167);
              std::string::size_type v94 = v134 >= 0 ? v133 : (void **)v133[0];
              *(_DWORD *)uint64_t v165 = 136315138;
              long long v166 = v94;
              _os_log_impl((void *)&_mh_execute_header, v93, OS_LOG_TYPE_DEFAULT, "#I [resume] from pending TransferSIM post response: %s", v165, 0xCu);
              if (v134 < 0) {
                operator delete(v133[0]);
              }
            }
            sub_10030E6AC(&v161, (uint64_t)v167);
            sub_100B5B9BC(v5, v24 + 1048, (uint64_t)&v161, 3);
            sub_10030D32C((uint64_t)&v161);
LABEL_312:
            sub_10030D32C((uint64_t)v167);
            goto LABEL_291;
          }
          sub_10030D32C((uint64_t)v167);
        }
      }
      if (!*(unsigned char *)(a3 + 123) || *(unsigned char *)(a3 + 122))
      {
        uint64_t v91 = *(NSObject **)(v5 + 40);
        if (os_log_type_enabled(v91, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)std::string v167 = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v91, OS_LOG_TYPE_ERROR, "invalid webservice request for transfer sim service", v167, 2u);
        }
      }
      else
      {
        if (*(unsigned char *)(a3 + 48))
        {
          uint64_t v86 = *(unsigned __int8 *)(a3 + 47);
          if ((v86 & 0x80u) != 0) {
            uint64_t v86 = *(void *)(a3 + 32);
          }
          if (v86 && *(unsigned char *)(a3 + 80))
          {
            BOOL v87 = (uint64_t *)sub_100B5B348(v5);
            if (*v87)
            {
              *(unsigned char *)(v5 + 139) = 1;
              sub_100B55694(v5, 1);
              LODWORD(v133[0]) = sub_100B5B3E4((void *)v5, v24 + 1048);
              long long v88 = *(NSObject **)(v5 + 40);
              if (os_log_type_enabled(v88, OS_LOG_TYPE_DEFAULT))
              {
                uint64_t v89 = v24 + 1048;
                if (*(char *)(v24 + 1071) < 0) {
                  uint64_t v89 = *(void *)v25;
                }
                *(_DWORD *)std::string v167 = 136315138;
                *(void *)&v167[4] = v89;
                _os_log_impl((void *)&_mh_execute_header, v88, OS_LOG_TYPE_DEFAULT, "#I [req][tsspost] perform TransferSIM post request with WebServiceRequest. source iccid : %s", v167, 0xCu);
              }
              uint64_t v90 = *v87;
              *(void *)&long long v161 = v5;
              sub_1002598D0((void *)&v161 + 1, *(void *)(v5 + 8), *(std::__shared_weak_count **)(v5 + 16));
              if (*(char *)(v24 + 1071) < 0)
              {
                sub_10004FC84(&v163, *(void **)(v24 + 1048), *(void *)(v24 + 1056));
              }
              else
              {
                long long v163 = *v25;
                uint64_t v164 = *(void *)(v24 + 1064);
              }
              sub_100B5B8FC((uint64_t)&__s1, (uint64_t)&v161);
              int v96 = (*(uint64_t (**)(uint64_t, uint64_t, unsigned char *, void **, long long *))(*(void *)v90 + 24))(v90, a3 + 24, buf, v133, &__s1);
              sub_10077806C(&__s1);
              sub_100B49710((uint64_t)&v161);
              long long v97 = *(NSObject **)(v5 + 40);
              if (os_log_type_enabled(v97, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)std::string v167 = 67109120;
                *(_DWORD *)&v167[4] = v96;
                _os_log_impl((void *)&_mh_execute_header, v97, OS_LOG_TYPE_DEFAULT, "#I TSS post request success: %d", v167, 8u);
              }
              if (v96) {
                goto LABEL_291;
              }
              sub_100B55694(v5, 0);
              v167[0] = 0;
              LOBYTE(v170) = 0;
              sub_100B5B9BC(v5, v24 + 1048, (uint64_t)v167, 0);
              goto LABEL_312;
            }
            uint64_t v95 = *(NSObject **)(v5 + 40);
            if (os_log_type_enabled(v95, OS_LOG_TYPE_ERROR))
            {
              *(_WORD *)std::string v167 = 0;
              _os_log_error_impl((void *)&_mh_execute_header, v95, OS_LOG_TYPE_ERROR, "invalid webservice delegate", v167, 2u);
            }
            LOBYTE(v133[0]) = 11;
            *(void *)std::string v167 = 0;
            v165[0] = 56;
            *(void *)&long long v161 = 0;
            LODWORD(__s1) = 70013;
            BYTE4(__s1) = 1;
            sub_100B3E598((void *)v5, (unsigned __int8 **)(v24 + 1048), (unsigned __int8 *)v133, 0, (const void **)v167, (char *)v165, (const void **)&v161, 0, 1, (uint64_t)&__s1, (uint64_t *)(v5 + 328));
LABEL_290:
            sub_100057D78((const void **)&v161);
            sub_1000558F4((const void **)v167);
LABEL_291:
            sub_100B632F8((uint64_t)buf);
            goto LABEL_292;
          }
        }
        uint64_t v92 = *(NSObject **)(v5 + 40);
        if (os_log_type_enabled(v92, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)std::string v167 = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v92, OS_LOG_TYPE_ERROR, "incomplete webservice request url or post data", v167, 2u);
        }
      }
      LOBYTE(v133[0]) = 11;
      *(void *)std::string v167 = 0;
      v165[0] = 52;
      *(void *)&long long v161 = 0;
      LODWORD(__s1) = 70011;
      BYTE4(__s1) = 1;
      sub_100B3E598((void *)v5, (unsigned __int8 **)(v24 + 1048), (unsigned __int8 *)v133, 0, (const void **)v167, (char *)v165, (const void **)&v161, 7u, 1, (uint64_t)&__s1, (uint64_t *)(v5 + 328));
      goto LABEL_290;
    }
  }
  std::string::size_type v29 = *(std::string **)a3;
  int v28 = *(std::string **)(a3 + 8);
  if (*(unsigned char *)(v5 + 131) && v29 == v28)
  {
    uint64_t v30 = *(NSObject **)(v5 + 40);
    if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "#E No websheet allowed in buddy", buf, 2u);
    }
    LOBYTE(v161) = 11;
    LOBYTE(__s1) = 40;
    sub_10004EFE4(buf, &v130);
    *(_DWORD *)std::string v167 = 70022;
    v167[4] = 1;
    sub_100B3E598((void *)v5, (unsigned __int8 **)a2, (unsigned __int8 *)&v161, 0, &cf, (char *)&__s1, (const void **)buf, 6u, 1, (uint64_t)v167, (uint64_t *)&v132);
LABEL_83:
    sub_100057D78((const void **)buf);
    goto LABEL_292;
  }
  uint64_t v101 = *(std::string **)(a3 + 8);
  BOOL v98 = *(void *)a3 != (void)v28;
  uint64_t v31 = *(void *)(v10 + 1296);
  uint64_t v32 = *(void *)(v10 + 1304);
  char v33 = 1;
  while (v31 != v32)
  {
    if (*(char *)(v31 + 23) < 0)
    {
      if (!*(void *)(v31 + 8)) {
        goto LABEL_92;
      }
    }
    else if (!*(unsigned char *)(v31 + 23))
    {
      goto LABEL_92;
    }
    sub_100B4B494((void *)v5, a2, (const std::string *)v31);
    if (*(unsigned char *)(v31 + 89)) {
      v33 &= *(unsigned char *)(v31 + 88) != 0;
    }
LABEL_92:
    v31 += 96;
  }
  uint64_t v34 = *(void *)(v5 + 856);
  uint64_t v35 = *(void *)(v5 + 864);
  long long v100 = v29;
  if (*(char *)(a2 + 23) < 0)
  {
    sub_10004FC84(__dst, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)long long __dst = *(_OWORD *)a2;
    uint64_t v114 = *(void *)(a2 + 16);
  }
  uint64_t v36 = HIBYTE(v114);
  if (v34 == v35)
  {
    char v45 = 0;
    if (v114 < 0) {
      goto LABEL_118;
    }
  }
  else
  {
    uint64_t v99 = v5;
    int v38 = __dst[0];
    uint64_t v37 = __dst[1];
    if (v114 >= 0) {
      uint64_t v39 = (void *)HIBYTE(v114);
    }
    else {
      uint64_t v39 = __dst[1];
    }
    do
    {
      std::string::size_type v40 = (void *)*(unsigned __int8 *)(v34 + 455);
      int v41 = (char)v40;
      if ((char)v40 < 0) {
        std::string::size_type v40 = *(void **)(v34 + 440);
      }
      if (v39 == v40)
      {
        if (v41 >= 0) {
          long long v42 = (unsigned __int8 *)(v34 + 432);
        }
        else {
          long long v42 = *(unsigned __int8 **)(v34 + 432);
        }
        if ((v36 & 0x80) != 0)
        {
          if (!memcmp(v38, v42, (size_t)v37))
          {
            char v45 = 1;
            uint64_t v5 = v99;
            goto LABEL_118;
          }
        }
        else
        {
          if (!v36)
          {
            char v45 = 1;
            uint64_t v5 = v99;
            goto LABEL_119;
          }
          uint64_t v43 = __dst;
          uint64_t v44 = v36;
          while (*(unsigned __int8 *)v43 == *v42)
          {
            uint64_t v43 = (void **)((char *)v43 + 1);
            ++v42;
            if (!--v44)
            {
              char v45 = 1;
              goto LABEL_115;
            }
          }
        }
      }
      v34 += 1248;
    }
    while (v34 != v35);
    char v45 = 0;
LABEL_115:
    uint64_t v5 = v99;
    if ((v36 & 0x80) != 0) {
LABEL_118:
    }
      operator delete(__dst[0]);
  }
LABEL_119:
  if (*(unsigned char *)(a3 + 121) && *(unsigned char *)(a3 + 120))
  {
    CFTypeRef v112 = cf;
    if (cf) {
      CFRetain(cf);
    }
    sub_10004EFE4(&v111, &v130);
    sub_100B3EA60(v5, a2, 9, 0, &v112, &v111);
    sub_100057D78(&v111);
    sub_1000558F4(&v112);
    if (v33)
    {
      uint64_t v138 = 0;
      unint64_t v46 = v137;
      sub_100B4B5F8((void *)v5, 3, (uint64_t)v137);
      goto LABEL_163;
    }
    if (*(unsigned char *)(v5 + 141))
    {
      uint64_t v136 = 0;
      unint64_t v46 = v135;
      sub_100B4B5F8((void *)v5, 3, (uint64_t)v135);
LABEL_163:
      sub_100313668(v46);
    }
    unsigned int v54 = *(unsigned __int8 *)(v10 + 1280) - 1;
    if (v54 > 0xA) {
      char v55 = 0;
    }
    else {
      char v55 = byte_10154B635[(char)v54];
    }
    buf[0] = v55;
    v167[0] = 9;
    sub_100B4B75C(v5, buf, v167, v10, v45, *(unsigned __int8 *)(v10 + 1284));
  }
  if (v100 != v101)
  {
    if (*(unsigned char *)(a3 + 121) && *(unsigned char *)(a3 + 120))
    {
      CFTypeRef v110 = cf;
      if (cf) {
        CFRetain(cf);
      }
      sub_10004EFE4(&v109, &v130);
      sub_100B3EA60(v5, a2, 9, 0, &v110, &v109);
      sub_100057D78(&v109);
      sub_1000558F4(&v110);
      sub_100B3F32C(v5);
    }
    else if (v33)
    {
      long long v56 = *(std::__shared_weak_count **)(v5 + 72);
      if (v56)
      {
        int v57 = std::__shared_weak_count::lock(v56);
        if (v57)
        {
          uint64_t v58 = v57;
          uint64_t v59 = *(void *)(v5 + 64);
          if (v59)
          {
            sub_100083DA4(&v108, &cf);
            sub_10004EFE4(&v107, &v130);
            sub_100B3EA60(v5, a2, 7, 0, &v108, &v107);
            sub_100057D78(&v107);
            sub_1000558F4(&v108);
            (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v59 + 40))(v59, a2, v10 + 1296, 3);
            buf[0] = sub_100CDB2F8(*(unsigned __int8 *)(v10 + 1280));
            v167[0] = 7;
            sub_100B4B75C(v5, buf, v167, v10, v45, *(unsigned __int8 *)(v10 + 1284));
          }
          sub_10004D2C8(v58);
        }
      }
      sub_100B3F32C(v5);
    }
    else
    {
      *(unsigned char *)(v5 + 137) = 1;
      *(void *)long long buf = 0;
      *(void *)std::string v167 = 0;
      sub_100B3EA60(v5, a2, 8, 0, (const void **)buf, (const void **)v167);
      sub_100057D78((const void **)v167);
      sub_1000558F4((const void **)buf);
      uint64_t v60 = *(void *)(v5 + 328);
      if (v60 != *(void *)(v5 + 312)) {
        *(void *)(v5 + 328) = v60 + 1520;
      }
    }
    goto LABEL_241;
  }
  if (!*(unsigned char *)(a3 + 48))
  {
    uint64_t v61 = *(NSObject **)(v5 + 40);
    if (os_log_type_enabled(v61, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v61, OS_LOG_TYPE_DEFAULT, "#E TSS response error. Non one-click response without websheet url", buf, 2u);
    }
    sub_100058DB0(buf, "TransferSimServiceResponse");
    sub_100058DB0(&buf[24], "TransferSimServiceViaWebServiceResponse");
    sub_1001F69F4((uint64_t)v167, (long long *)buf, 2uLL);
    sub_100B52308((void *)v5, a2, (uint64_t)v167);
    *(void *)&long long v161 = v167;
    sub_100047F64((void ***)&v161);
    for (uint64_t k = 0; k != -48; k -= 24)
    {
      if ((char)buf[k + 47] < 0) {
        operator delete(*(void **)&buf[k + 24]);
      }
    }
    LOBYTE(v161) = 11;
    LOBYTE(__s1) = 52;
    sub_10004EFE4(buf, &v130);
    *(_DWORD *)std::string v167 = 70011;
    v167[4] = 1;
    sub_100B3E598((void *)v5, (unsigned __int8 **)a2, (unsigned __int8 *)&v161, 0, &cf, (char *)&__s1, (const void **)buf, 7u, 1, (uint64_t)v167, (uint64_t *)&v132);
    goto LABEL_83;
  }
  long long v161 = 0uLL;
  uint64_t v162 = 0;
  if (*(char *)(a3 + 47) < 0)
  {
    sub_10004FC84(&v161, *(void **)(a3 + 24), *(void *)(a3 + 32));
  }
  else
  {
    long long v161 = *(_OWORD *)(a3 + 24);
    uint64_t v162 = *(void *)(a3 + 40);
  }
  if (v162 >= 0) {
    BOOL v69 = (const char *)&v161;
  }
  else {
    BOOL v69 = (const char *)v161;
  }
  CFStringRef v70 = CFStringCreateWithCString(kCFAllocatorDefault, v69, 0x8000100u);
  CFTypeRef v71 = cf;
  CFTypeRef cf = v70;
  *(void *)long long buf = v71;
  sub_1000558F4((const void **)buf);
  uint64_t v158 = 0;
  long long v156 = 0u;
  long long v157 = 0u;
  long long v154 = 0u;
  long long v155 = 0u;
  long long v152 = 0u;
  long long v153 = 0u;
  long long v150 = 0u;
  long long v151 = 0u;
  long long v148 = 0u;
  long long v149 = 0u;
  long long v146 = 0u;
  long long v147 = 0u;
  long long v144 = 0u;
  long long v145 = 0u;
  long long v142 = 0u;
  long long v143 = 0u;
  memset(buf, 0, sizeof(buf));
  sub_1000593FC((uint64_t)&v105, (long long *)(a3 + 56));
  sub_100B5B0EC((uint64_t)buf, v10, &v105);
  if (v106 && SHIBYTE(v105.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v105.__r_.__value_.__l.__data_);
  }
  CFMutableDictionaryRef v72 = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (v72)
  {
    CFTypeRef v73 = v130;
    CFTypeRef v130 = v72;
    *(void *)std::string v167 = v73;
    sub_10005717C((const void **)v167);
    sub_100057240(&v104, &v130);
    sub_100DDCEB8((CFMutableDictionaryRef *)&v104, (uint64_t)buf);
    sub_10005717C(&v104);
  }
  v167[0] = v98;
  if (*(char *)(v10 + 1167) < 0)
  {
    sub_10004FC84(&v167[8], *(void **)(v10 + 1144), *(void *)(v10 + 1152));
  }
  else
  {
    *(_OWORD *)&v167[8] = *(_OWORD *)(v10 + 1144);
    *(void *)&v167[24] = *(void *)(v10 + 1160);
  }
  *(void *)&long long v168 = cf;
  if (cf) {
    CFRetain(cf);
  }
  *((void *)&v168 + 1) = v130;
  if (v130) {
    CFRetain(v130);
  }
  LOBYTE(v169[0]) = 0;
  char v74 = (void **)(v5 + 432);
  if (*(unsigned char *)(v5 + 480))
  {
    *(unsigned char *)(v5 + 424) = v167[0];
    if (*(char *)(v5 + 455) < 0) {
      operator delete(*v74);
    }
    *(_OWORD *)char v74 = *(_OWORD *)&v167[8];
    *(void *)(v5 + 448) = *(void *)&v167[24];
    v167[31] = 0;
    v167[8] = 0;
    if ((uint8_t *)(v5 + 424) != v167)
    {
      *(void *)&long long __s1 = *(void *)(v5 + 456);
      *(void *)(v5 + 456) = v168;
      *(void *)&long long v168 = 0;
      sub_1000558F4((const void **)&__s1);
    }
    sub_10004EFE4(v133, (CFTypeRef *)&v168 + 1);
    uint64_t v75 = (void *)(v5 + 464);
    if ((void **)(v5 + 464) != v133)
    {
      *(void *)&long long __s1 = *v75;
      void *v75 = v133[0];
      v133[0] = 0;
      sub_100057D78((const void **)&__s1);
    }
    *(unsigned char *)(v5 + 472) = v169[0];
    sub_100057D78((const void **)v133);
  }
  else
  {
    *(unsigned char *)(v5 + 424) = v167[0];
    *(_OWORD *)char v74 = *(_OWORD *)&v167[8];
    *(void *)(v5 + 448) = *(void *)&v167[24];
    memset(&v167[8], 0, 24);
    *(void *)(v5 + 456) = v168;
    *(void *)&long long v168 = 0;
    sub_10004EFE4((void *)(v5 + 464), (CFTypeRef *)&v168 + 1);
    *(unsigned char *)(v5 + 472) = v169[0];
    *(unsigned char *)(v5 + 480) = 1;
  }
  sub_10005717C((const void **)&v168 + 1);
  sub_1000558F4((const void **)&v168);
  if ((char)v167[31] < 0) {
    operator delete(*(void **)&v167[8]);
  }
  sub_100B4AC10(v5, v167);
  sub_100B4A738((void *)v5, (const void **)v167);
  if ((char)v167[23] < 0) {
    operator delete(*(void **)v167);
  }
  CFTypeRef v103 = cf;
  if (cf) {
    CFRetain(cf);
  }
  sub_10004EFE4(&v102, &v130);
  sub_100B3EA60(v5, a2, 6, 0, &v103, &v102);
  sub_100057D78(&v102);
  sub_1000558F4(&v103);
  sub_100310520((uint64_t)buf);
  if (SHIBYTE(v162) < 0) {
    operator delete((void *)v161);
  }
LABEL_241:
  sub_100B3F548(v5);
LABEL_292:
  sub_10005717C(&v130);
  return sub_1000558F4(&cf);
}

void sub_100B5ABE8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,void *a45,uint64_t a46,uint64_t a47,uint64_t a48,void *a49,uint64_t a50,uint64_t a51,uint64_t a52,const void *a53,const void *a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  sub_10030D32C((uint64_t)&STACK[0x430]);
  sub_100B632F8((uint64_t)&a71);
  sub_10005717C(&a53);
  sub_1000558F4(&a54);
  _Unwind_Resume(a1);
}

uint64_t sub_100B5B080(uint64_t a1)
{
  if (*(char *)(a1 + 47) < 0) {
    operator delete(*(void **)(a1 + 24));
  }
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

uint64_t sub_100B5B0C0(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100B5B0DC(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

std::string *sub_100B5B0EC(uint64_t a1, uint64_t a2, const std::string *a3)
{
  *(_OWORD *)(a1 + 32) = 0u;
  uint64_t v6 = (std::string *)(a1 + 32);
  *(_OWORD *)(a1 + 112) = 0u;
  uint64_t v7 = (std::string *)(a1 + 112);
  *(void *)(a1 + 336) = 0;
  *(_OWORD *)(a1 + 304) = 0u;
  *(_OWORD *)(a1 + 320) = 0u;
  *(_OWORD *)(a1 + 272) = 0u;
  *(_OWORD *)(a1 + 288) = 0u;
  *(_OWORD *)(a1 + 240) = 0u;
  *(_OWORD *)(a1 + 256) = 0u;
  *(_OWORD *)(a1 + 208) = 0u;
  *(_OWORD *)(a1 + 224) = 0u;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  ctu::hex((uint64_t *)&v19, (ctu *)(a2 + 1032), (const void *)0x10, (unint64_t)a3);
  uint64_t v8 = (void **)(a1 + 56);
  if (*(char *)(a1 + 79) < 0) {
    operator delete(*v8);
  }
  *(_OWORD *)uint64_t v8 = v19;
  *(void *)(a1 + 72) = v20;
  std::string::operator=(v7, (const std::string *)(a2 + 1120));
  sub_10032AFC0((unsigned char *)(a1 + 136), (const std::string *)(a2 + 1120));
  uint64_t v9 = a2 + 1048;
  uint64_t v10 = (long long *)(a2 + 1072);
  unint64_t v11 = *(void *)(a1 + 88);
  if (v11 >= *(void *)(a1 + 96))
  {
    uint64_t v13 = sub_100B633B4((uint64_t *)(a1 + 80), v9, v10);
  }
  else
  {
    sub_100B634DC(*(void **)(a1 + 88), v9, v10);
    uint64_t v13 = v11 + 88;
    *(void *)(a1 + 88) = v11 + 88;
  }
  *(void *)(a1 + 88) = v13;
  ctu::hex((uint64_t *)&v19, (ctu *)(a2 + 1168), (const void *)0x10, v12);
  uint64_t v14 = (void **)(a1 + 200);
  if (*(char *)(a1 + 223) < 0) {
    operator delete(*v14);
  }
  *(_OWORD *)uint64_t v14 = v19;
  *(void *)(a1 + 216) = v20;
  std::string::operator=((std::string *)(a1 + 256), (const std::string *)(a2 + 1184));
  sub_10032AFC0((unsigned char *)(a1 + 280), (const std::string *)(a2 + 1184));
  uint64_t v15 = a2 + 1208;
  uint64_t v16 = (long long *)(a2 + 1232);
  unint64_t v17 = *(void *)(a1 + 232);
  if (v17 >= *(void *)(a1 + 240))
  {
    CFStringRef result = (std::string *)sub_100B633B4((uint64_t *)(a1 + 224), v15, v16);
  }
  else
  {
    sub_100B634DC(*(void **)(a1 + 232), v15, v16);
    CFStringRef result = (std::string *)(v17 + 88);
    *(void *)(a1 + 232) = v17 + 88;
  }
  *(void *)(a1 + 232) = result;
  if (a3[1].__r_.__value_.__s.__data_[0]) {
    return std::string::operator=(v6, a3);
  }
  return result;
}

void sub_100B5B28C(_Unwind_Exception *a1)
{
  *(void *)(v1 + 232) = v2;
  sub_100310520(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100B5B2C0(uint64_t a1)
{
  if (*(char *)(a1 + 31) < 0) {
    operator delete(*(void **)(a1 + 8));
  }
  return a1;
}

uint64_t sub_100B5B304(uint64_t a1)
{
  if (*(char *)(a1 + 31) < 0) {
    operator delete(*(void **)(a1 + 8));
  }
  return a1;
}

uint64_t sub_100B5B348(uint64_t a1)
{
  uint64_t v1 = a1 + 96;
  if (!*(void *)(a1 + 96))
  {
    uint64_t v4 = *(void *)(a1 + 48);
    if (v4)
    {
      (*(void (**)(long long *__return_ptr))(*(void *)v4 + 592))(&v7);
      long long v5 = v7;
      long long v7 = 0uLL;
      uint64_t v6 = *(std::__shared_weak_count **)(a1 + 104);
      *(_OWORD *)(a1 + 96) = v5;
      if (v6)
      {
        sub_10004D2C8(v6);
        if (*((void *)&v7 + 1)) {
          sub_10004D2C8(*((std::__shared_weak_count **)&v7 + 1));
        }
      }
    }
  }
  return v1;
}

uint64_t sub_100B5B3E4(void *a1, uint64_t a2)
{
  uint64_t v4 = a1[39];
  uint64_t v5 = sub_100B45F5C(a1[38], v4, (unsigned __int8 **)a2);
  if (v4 == v5) {
    return 60;
  }
  uint64_t v6 = v5;
  if (*(unsigned char *)(v5 + 1456)) {
    return *(unsigned int *)(v5 + 1452);
  }
  if (!*(unsigned char *)(v5 + 216))
  {
    uint64_t v10 = a1[5];
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      if (*(char *)(a2 + 23) >= 0) {
        uint64_t v14 = (unsigned __int8 *)a2;
      }
      else {
        uint64_t v14 = *(unsigned __int8 **)a2;
      }
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = v14;
      _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "VinylProfileDetails is not set for sourceIccid [%s]", buf, 0xCu);
    }
    return 60;
  }
  *(_OWORD *)long long buf = 0uLL;
  sub_100B50AC0((const void **)buf, (uint64_t)a1, v5);
  if (*(void *)buf)
  {
    CFDictionaryRef Value = CFDictionaryGetValue(*(CFDictionaryRef *)(*(void *)buf + 64), @"TransferWebservicesTimeout");
    uint64_t v7 = (uint64_t)Value;
    uint64_t v15 = Value;
    if (Value)
    {
      uint64_t v9 = sub_100080934;
      CFRetain(Value);
    }
    else
    {
      uint64_t v9 = 0;
    }
    if (v9)
    {
      unsigned int v16 = 0;
      if (v7)
      {
        CFTypeID v12 = CFGetTypeID((CFTypeRef)v7);
        if (v12 == CFNumberGetTypeID())
        {
          ctu::cf::assign((ctu::cf *)&v16, (unsigned int *)v7, v13);
          uint64_t v7 = v16;
        }
        else
        {
          uint64_t v7 = 0;
        }
      }
      *(_DWORD *)(v6 + 1452) = v7;
      *(unsigned char *)(v6 + 1456) = 1;
    }
    else
    {
      uint64_t v7 = 60;
    }
    sub_1000577C4(&v15);
  }
  else
  {
    uint64_t v7 = 60;
  }
  if (*(void *)&buf[8]) {
    sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
  }
  return v7;
}

void sub_100B5B5B8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100B5B5F8(uint64_t a1)
{
  sub_100777F50((void *)(a1 + 24));
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_100B5B630(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4)
{
  if (*(unsigned char *)(a4 + 480))
  {
    if (*(char *)(a4 + 479) < 0) {
      operator delete(*(void **)(a4 + 456));
    }
    *(unsigned char *)(a4 + 480) = 0;
  }
  if (*(unsigned char *)(a4 + 512))
  {
    if (*(char *)(a4 + 511) < 0) {
      operator delete(*(void **)(a4 + 488));
    }
    *(unsigned char *)(a4 + 512) = 0;
  }
  if (*(unsigned char *)(a4 + 1)) {
    *(unsigned char *)(a4 + 1) = 0;
  }
  if (*(unsigned char *)(a4 + 544))
  {
    if (*(char *)(a4 + 543) < 0) {
      operator delete(*(void **)(a4 + 520));
    }
    *(unsigned char *)(a4 + 544) = 0;
  }
  if (*(unsigned char *)(a4 + 576))
  {
    if (*(char *)(a4 + 575) < 0) {
      operator delete(*(void **)(a4 + 552));
    }
    *(unsigned char *)(a4 + 576) = 0;
  }
  if (*(unsigned char *)(a3 + 272))
  {
    uint64_t v8 = *(NSObject **)(a1 + 40);
    if (*(unsigned char *)(a3 + 1))
    {
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        if (*((char *)a2 + 23) < 0) {
          a2 = (uint64_t *)*a2;
        }
        int v14 = 136315394;
        uint64_t v15 = a2;
        __int16 v16 = 2080;
        uint64_t v17 = entitlements::asString();
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I plan(%s) got transfer type from post request : %s", (uint8_t *)&v14, 0x16u);
        if (!*(unsigned char *)(a3 + 1)) {
          sub_10016C840();
        }
      }
      if (!*(unsigned char *)a3)
      {
        if (*(unsigned char *)(a3 + 44))
        {
          uint64_t v9 = *(NSObject **)(a1 + 40);
          if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
          {
            int v13 = *(_DWORD *)(a3 + 40);
            int v14 = 67109120;
            LODWORD(v15) = v13;
            _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "TransferAuthorization via web service failure. reason code : %d", (uint8_t *)&v14, 8u);
          }
        }
        if (*(unsigned char *)(a3 + 72))
        {
          uint64_t v10 = *(NSObject **)(a1 + 40);
          if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
          {
            unint64_t v11 = (void *)(a3 + 48);
            if (*(char *)(a3 + 71) < 0) {
              unint64_t v11 = (void *)*v11;
            }
            int v14 = 136315138;
            uint64_t v15 = v11;
            _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "TransferAuthorization via web service failure. reason code url : %s", (uint8_t *)&v14, 0xCu);
          }
        }
      }
    }
    else
    {
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
      {
        LOWORD(v14) = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "No preflight-state in post response", (uint8_t *)&v14, 2u);
      }
      *(_WORD *)a3 = 256;
    }
    entitlements::TransferAuthorizationResponse::convert();
  }
  else
  {
    CFTypeID v12 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v14) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "transfer authorization via web service failure", (uint8_t *)&v14, 2u);
    }
  }
}

uint64_t sub_100B5B8FC(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 24) = 0;
  uint64_t v4 = (char *)operator new(0x38uLL);
  *(void *)uint64_t v4 = off_101A3F9B0;
  *(_OWORD *)(v4 + 8) = *(_OWORD *)a2;
  *((void *)v4 + 3) = *(void *)(a2 + 16);
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  uint64_t v5 = v4 + 32;
  if (*(char *)(a2 + 47) < 0)
  {
    sub_10004FC84(v5, *(void **)(a2 + 24), *(void *)(a2 + 32));
  }
  else
  {
    *(_OWORD *)uint64_t v5 = *(_OWORD *)(a2 + 24);
    *((void *)v4 + 6) = *(void *)(a2 + 40);
  }
  *(void *)(a1 + 24) = v4;
  return a1;
}

void sub_100B5B99C(_Unwind_Exception *a1)
{
  uint64_t v3 = (std::__shared_weak_count *)v1[3];
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_100B5B9BC(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  *(unsigned char *)(a1 + 139) = 0;
  uint64_t v8 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    if (*(char *)(a2 + 23) >= 0) {
      uint64_t v9 = (unsigned __int8 *)a2;
    }
    else {
      uint64_t v9 = *(unsigned __int8 **)a2;
    }
    LODWORD(buf[0]) = 136315138;
    *(void *)((char *)buf + 4) = v9;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I [resp][tsspost] processing TransferSIM post response: %s", (uint8_t *)buf, 0xCu);
  }
  uint64_t v10 = *(void *)(a1 + 312);
  uint64_t v11 = sub_100B45F5C(*(void *)(a1 + 304), v10, (unsigned __int8 **)a2);
  if (v10 == v11)
  {
    int v13 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      if (*(char *)(a2 + 23) >= 0) {
        int v14 = (unsigned __int8 *)a2;
      }
      else {
        int v14 = *(unsigned __int8 **)a2;
      }
      LODWORD(buf[0]) = 136315138;
      *(void *)((char *)buf + 4) = v14;
      _os_log_error_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "no transfer plan data for iccid : %s", (uint8_t *)buf, 0xCu);
    }
  }
  else
  {
    uint64_t v12 = v11;
    long long v49 = 0u;
    memset(v48, 0, sizeof(v48));
    long long v47 = 0u;
    long long v46 = 0u;
    long long v45 = 0u;
    long long v44 = 0u;
    long long v43 = 0u;
    long long v42 = 0u;
    long long v41 = 0u;
    long long v40 = 0u;
    long long v39 = 0u;
    *(_OWORD *)&buf[1] = 0u;
    buf[0] = a1;
    sub_10030E6AC(&buf[1], a3);
    if (*(char *)(a2 + 23) < 0)
    {
      sub_10004FC84(&v48[1], *(void **)a2, *(void *)(a2 + 8));
    }
    else
    {
      *(_OWORD *)&v48[1] = *(_OWORD *)a2;
      v48[3] = *(void *)(a2 + 16);
    }
    LODWORD(v49) = a4;
    *((void *)&v49 + 1) = v12;
    if (*(unsigned char *)(a3 + 160)
      && (entitlements::TransferSIMViaWebServiceResponse::success((entitlements::TransferSIMViaWebServiceResponse *)a3) & 1) != 0)
    {
      sub_100058DB0(__p, "TransferSimServiceViaWebServiceResponse");
      uint64_t v15 = operator new(0xA0uLL);
      sub_10030E704((uint64_t)v15, a3);
      v35[0] = (void (*)(void, void, void, void, void))sub_100B761A8;
      v35[1] = (void (*)(void, void, void, void, void))v15;
      sub_100B4A9E0((void *)a1, a2, (uint64_t)__p, v35);
      sub_100146540((uint64_t (**)(void, void, void, void, void))v35);
      if (v27 < 0) {
        operator delete(__p[0]);
      }
      entitlements::TransferSIMResponse::convert((entitlements::TransferSIMResponse *)(v12 + 1296), (const entitlements::TransferSIMViaWebServiceResponse *)a3);
      sub_10030DBE4((uint64_t)v25, v12 + 1296);
      v25[152] = 1;
      sub_100B591A0(a1, a2, v25);
      sub_10030D3C0((uint64_t)v25);
    }
    else
    {
      if (*(char *)(a2 + 23) < 0)
      {
        sub_10004FC84(__dst, *(void **)a2, *(void *)(a2 + 8));
      }
      else
      {
        *(_OWORD *)long long __dst = *(_OWORD *)a2;
        uint64_t v34 = *(void *)(a2 + 16);
      }
      int v16 = *(unsigned __int8 *)(a3 + 160);
      int v17 = *(unsigned __int8 *)(a1 + 132);
      if (*(unsigned char *)(a3 + 160))
      {
        if (*(char *)(a3 + 135) < 0) {
          uint64_t v18 = *(void *)(a3 + 120);
        }
        else {
          uint64_t v18 = *(unsigned __int8 *)(a3 + 135);
        }
        BOOL v19 = v18 != 0;
        int v20 = entitlements::TransferSIMViaWebServiceResponse::success((entitlements::TransferSIMViaWebServiceResponse *)a3);
      }
      else
      {
        BOOL v19 = 0;
        int v20 = 0;
      }
      uint64_t v28 = buf[0];
      sub_10030E6AC(v29, (uint64_t)&buf[1]);
      if (SHIBYTE(v48[3]) < 0)
      {
        sub_10004FC84(&v30, (void *)v48[1], v48[2]);
      }
      else
      {
        long long v30 = *(_OWORD *)&v48[1];
        uint64_t v31 = v48[3];
      }
      long long v32 = v49;
      uint64_t v37 = 0;
      uint64_t v21 = operator new(0xE0uLL);
      long long v22 = v21;
      uint64_t v23 = v28;
      *uint64_t v21 = off_101A3FA40;
      v21[1] = v23;
      *((unsigned char *)v21 + 16) = 0;
      *((unsigned char *)v21 + 176) = 0;
      if (v29[160])
      {
        sub_1003113F8((uint64_t)(v21 + 2), (uint64_t)v29);
        *((unsigned char *)v22 + 176) = 1;
      }
      uint64_t v24 = v22 + 23;
      if (SHIBYTE(v31) < 0)
      {
        sub_10004FC84(v24, (void *)v30, *((unint64_t *)&v30 + 1));
      }
      else
      {
        *(_OWORD *)uint64_t v24 = v30;
        v22[25] = v31;
      }
      *((_OWORD *)v22 + 13) = v32;
      uint64_t v37 = v22;
      sub_100B5626C(a1, (unsigned __int8 **)__dst, a4, v16 != 0, v17 != 0, v19, v20, 9, (uint64_t)v36);
      sub_100060644(v36);
      if (SHIBYTE(v31) < 0) {
        operator delete((void *)v30);
      }
      sub_10030D32C((uint64_t)v29);
      if (SHIBYTE(v34) < 0) {
        operator delete(__dst[0]);
      }
    }
    if (SHIBYTE(v48[3]) < 0) {
      operator delete((void *)v48[1]);
    }
    sub_10030D32C((uint64_t)&buf[1]);
  }
}

void sub_100B5BE1C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,char a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,void *__p,uint64_t a62,int a63)
{
  sub_10030D32C(v67);
  operator delete(v66);
  sub_100B5BEF4((uint64_t)&a34);
  if (a66 < 0) {
    operator delete(__p);
  }
  sub_100B5BEF4((uint64_t)&STACK[0x200]);
  _Unwind_Resume(a1);
}

uint64_t sub_100B5BEF4(uint64_t a1)
{
  if (*(char *)(a1 + 199) < 0) {
    operator delete(*(void **)(a1 + 176));
  }
  sub_10030D32C(a1 + 8);
  return a1;
}

void sub_100B5BF30(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 312);
  uint64_t v5 = sub_100B45F5C(*(void *)(a1 + 304), v4, (unsigned __int8 **)a2);
  if (v4 == v5)
  {
    uint64_t v8 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      if (*(char *)(a2 + 23) >= 0) {
        uint64_t v10 = (unsigned __int8 *)a2;
      }
      else {
        uint64_t v10 = *(unsigned __int8 **)a2;
      }
      LODWORD(buf[0].__r_.__value_.__l.__data_) = 136315138;
      *(std::string::size_type *)((char *)buf[0].__r_.__value_.__r.__words + 4) = (std::string::size_type)v10;
      _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "source iccid [%s] already removed, skip TA for T&C", (uint8_t *)buf, 0xCu);
    }
    return;
  }
  uint64_t v6 = v5;
  int v7 = *(unsigned __int8 *)(v5 + 1512);
  if (v7 == 4) {
    return;
  }
  if (*(unsigned char *)(a1 + 132))
  {
    *(_WORD *)(v5 + 1512) = 0;
LABEL_5:
    if (*(unsigned char *)(v5 + 1463)) {
      goto LABEL_12;
    }
    if (*(unsigned char *)(v5 + 216))
    {
      if ((*(unsigned int (**)(void, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(**(void **)(a1 + 48)
                                                                                               + 984))(*(void *)(a1 + 48), v5 + 96, v5 + 120, v5 + 144, v5 + 168, a2))
      {
        if (*(unsigned char *)(a1 + 132))
        {
LABEL_9:
          sub_100B484CC(a1, a2);
          return;
        }
        uint64_t v101 = 0;
        uint64_t v102 = 0;
        (***(void (****)(std::string *__return_ptr))(a1 + 48))(buf);
        Registry::getTimerService(&v101, (Registry *)buf[0].__r_.__value_.__l.__data_);
        if (buf[0].__r_.__value_.__l.__size_) {
          sub_10004D2C8((std::__shared_weak_count *)buf[0].__r_.__value_.__l.__size_);
        }
        if (!v101)
        {
          uint64_t v21 = *(NSObject **)(a1 + 40);
          if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
          {
            LOWORD(buf[0].__r_.__value_.__l.__data_) = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "No Timer service", (uint8_t *)buf, 2u);
          }
          goto LABEL_266;
        }
        if (*(char *)(a2 + 23) < 0) {
          sub_10004FC84(&__str, *(void **)a2, *(void *)(a2 + 8));
        }
        else {
          std::string __str = *(std::string *)a2;
        }
        uint64_t v28 = *(void *)(a1 + 304);
        uint64_t v29 = *(void *)(a1 + 312);
        uint64_t v30 = sub_100B45F5C(v28, v29, (unsigned __int8 **)&__str);
        if (v29 == v30)
        {
          uint64_t v34 = *(NSObject **)(a1 + 40);
          if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
          {
            p_str = &__str;
            if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
              p_str = (std::string *)__str.__r_.__value_.__r.__words[0];
            }
            LODWORD(buf[0].__r_.__value_.__l.__data_) = 136315138;
            *(std::string::size_type *)((char *)buf[0].__r_.__value_.__r.__words + 4) = (std::string::size_type)p_str;
            _os_log_error_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_ERROR, "cannot find source iccid in tr.ctr : %s. skip sending delete request", (uint8_t *)buf, 0xCu);
            uint64_t v28 = *(void *)(a1 + 304);
            uint64_t v29 = *(void *)(a1 + 312);
          }
          sub_100B3F0F4((uint64_t)&theDict, v28, v29, (unsigned __int8 **)&__str);
          buf[0].__r_.__value_.__s.__data_[0] = 1;
          *(_OWORD *)&buf[0].__r_.__value_.__r.__words[1] = *(_OWORD *)&theDict.__r_.__value_.__l.__data_;
          std::string::size_type v35 = theDict.__r_.__value_.__r.__words[2];
          memset(&theDict, 0, sizeof(theDict));
          *(void *)&long long v121 = 0;
          *(_OWORD *)&buf[1].__r_.__value_.__r.__words[1] = 0uLL;
          buf[1].__r_.__value_.__r.__words[0] = v35;
          LOBYTE(v125) = 56;
          v110[0] = 0;
          sub_100B3F218(a1 + 424, (uint64_t)buf);
          sub_100057D78((const void **)&buf[1].__r_.__value_.__r.__words[2]);
          sub_1000558F4((const void **)&buf[1].__r_.__value_.__l.__size_);
          if (buf[1].__r_.__value_.__s.__data_[7] < 0) {
            operator delete((void *)buf[0].__r_.__value_.__l.__size_);
          }
          sub_100057D78((const void **)v110);
          sub_1000558F4((const void **)&v121);
          if (SHIBYTE(theDict.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(theDict.__r_.__value_.__l.__data_);
          }
          buf[0].__r_.__value_.__r.__words[0] = 0;
          theDict.__r_.__value_.__r.__words[0] = 0;
          sub_100B3EA60(a1, (uint64_t)&__str, 11, 56, (const void **)&buf[0].__r_.__value_.__l.__data_, (const void **)&theDict.__r_.__value_.__l.__data_);
          sub_100057D78((const void **)&theDict.__r_.__value_.__l.__data_);
          sub_1000558F4((const void **)&buf[0].__r_.__value_.__l.__data_);
          sub_100B3F32C(a1);
          sub_100B3F548(a1);
LABEL_188:
          if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(__str.__r_.__value_.__l.__data_);
          }
          uint64_t v47 = *(void *)(a1 + 328);
          if (!*(unsigned char *)(v47 + 216)) {
            sub_10016C840();
          }
          if (*(char *)(v47 + 119) < 0)
          {
            sub_10004FC84(v98, *(void **)(v47 + 96), *(void *)(v47 + 104));
            uint64_t v47 = *(void *)(a1 + 328);
            if (!*(unsigned char *)(v47 + 216)) {
              sub_10016C840();
            }
          }
          else
          {
            *(_OWORD *)BOOL v98 = *(_OWORD *)(v47 + 96);
            uint64_t v99 = *(void *)(v47 + 112);
          }
          if (*(char *)(v47 + 143) < 0)
          {
            sub_10004FC84(v96, *(void **)(v47 + 120), *(void *)(v47 + 128));
            uint64_t v47 = *(void *)(a1 + 328);
            if (!*(unsigned char *)(v47 + 216)) {
              sub_10016C840();
            }
          }
          else
          {
            *(_OWORD *)int v96 = *(_OWORD *)(v47 + 120);
            uint64_t v97 = *(void *)(v47 + 136);
          }
          if (*(char *)(v47 + 167) < 0)
          {
            sub_10004FC84(v94, *(void **)(v47 + 144), *(void *)(v47 + 152));
            uint64_t v47 = *(void *)(a1 + 328);
            if (!*(unsigned char *)(v47 + 216)) {
              sub_10016C840();
            }
          }
          else
          {
            *(_OWORD *)std::string::size_type v94 = *(_OWORD *)(v47 + 144);
            uint64_t v95 = *(void *)(v47 + 160);
          }
          if (*(char *)(v47 + 191) < 0)
          {
            sub_10004FC84(v92, *(void **)(v47 + 168), *(void *)(v47 + 176));
          }
          else
          {
            *(_OWORD *)uint64_t v92 = *(_OWORD *)(v47 + 168);
            uint64_t v93 = *(void *)(v47 + 184);
          }
          if (*(char *)(a2 + 23) < 0)
          {
            sub_10004FC84(v90, *(void **)a2, *(void *)(a2 + 8));
          }
          else
          {
            *(_OWORD *)uint64_t v90 = *(_OWORD *)a2;
            uint64_t v91 = *(void *)(a2 + 16);
          }
          theDict.__r_.__value_.__r.__words[0] = 0;
          (*(void (**)(std::string *__return_ptr))(**(void **)(a1 + 48) + 768))(&theDict);
          if (theDict.__r_.__value_.__r.__words[0]) {
            int v48 = sub_100080778;
          }
          else {
            int v48 = 0;
          }
          if (v48)
          {
            if (CFDictionaryContainsKey((CFDictionaryRef)theDict.__r_.__value_.__l.__data_, @"PhoneAccountTransfer"))
            {
              CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue((CFDictionaryRef)theDict.__r_.__value_.__l.__data_, @"PhoneAccountTransfer");
              if (CFDictionaryContainsKey(Value, @"DelayTimeForTSSAfterDeletion"))
              {
                uint64_t v50 = (int *)CFDictionaryGetValue(Value, @"DelayTimeForTSSAfterDeletion");
                uint64_t v51 = v50;
                LODWORD(buf[0].__r_.__value_.__l.__data_) = 0;
                if (v50 && (CFTypeID v52 = CFGetTypeID(v50), v52 == CFNumberGetTypeID()))
                {
                  ctu::cf::assign((ctu::cf *)buf, v51, v53);
                  int data = (int)buf[0].__r_.__value_.__l.__data_;
                }
                else
                {
                  int data = 0;
                }
                int v57 = *(NSObject **)(a1 + 40);
                if (os_log_type_enabled(v57, OS_LOG_TYPE_DEFAULT))
                {
                  uint64_t v58 = v90;
                  if (v91 < 0) {
                    uint64_t v58 = (void **)v90[0];
                  }
                  LODWORD(buf[0].__r_.__value_.__l.__data_) = 67109378;
                  HIDWORD(buf[0].__r_.__value_.__r.__words[0]) = data;
                  LOWORD(buf[0].__r_.__value_.__r.__words[1]) = 2080;
                  *(std::string::size_type *)((char *)&buf[0].__r_.__value_.__r.__words[1] + 2) = (std::string::size_type)v58;
                  _os_log_impl((void *)&_mh_execute_header, v57, OS_LOG_TYPE_DEFAULT, "#I DelayTimeForTSSAfterDeletion is set to %d for ICCID: [%s]", (uint8_t *)buf, 0x12u);
                }
                goto LABEL_230;
              }
              uint64_t v59 = *(NSObject **)(a1 + 40);
              if (os_log_type_enabled(v59, OS_LOG_TYPE_DEFAULT))
              {
                uint64_t v60 = v90;
                if (v91 < 0) {
                  uint64_t v60 = (void **)v90[0];
                }
                LODWORD(buf[0].__r_.__value_.__l.__data_) = 136315138;
                *(std::string::size_type *)((char *)buf[0].__r_.__value_.__r.__words + 4) = (std::string::size_type)v60;
                _os_log_impl((void *)&_mh_execute_header, v59, OS_LOG_TYPE_DEFAULT, "#I DelayTimeForTSSAfterDeletion not present in CB entitlements for ICCID: [%s]", (uint8_t *)buf, 0xCu);
              }
LABEL_229:
              int data = 10;
LABEL_230:
              sub_100057D78((const void **)&theDict.__r_.__value_.__l.__data_);
              if (SHIBYTE(v91) < 0) {
                operator delete(v90[0]);
              }
              if (SHIBYTE(v93) < 0) {
                operator delete(v92[0]);
              }
              if (SHIBYTE(v95) < 0) {
                operator delete(v94[0]);
              }
              if (SHIBYTE(v97) < 0) {
                operator delete(v96[0]);
              }
              if (SHIBYTE(v99) < 0) {
                operator delete(v98[0]);
              }
              uint64_t v61 = v101;
              sub_100058DB0(&v88, "send.tss.after.delete");
              theDict.__r_.__value_.__r.__words[0] = a1;
              uint64_t v62 = *(std::__shared_weak_count **)(a1 + 16);
              if (!v62 || (v63 = *(void *)(a1 + 8), (CFStringRef v64 = std::__shared_weak_count::lock(v62)) == 0)) {
                sub_100088B9C();
              }
              theDict.__r_.__value_.__l.__size_ = v63;
              theDict.__r_.__value_.__r.__words[2] = (std::string::size_type)v64;
              atomic_fetch_add_explicit(&v64->__shared_weak_owners_, 1uLL, memory_order_relaxed);
              sub_10004D2C8(v64);
              if (*(char *)(a2 + 23) < 0)
              {
                sub_10004FC84(v114, *(void **)a2, *(void *)(a2 + 8));
              }
              else
              {
                *(_OWORD *)uint64_t v114 = *(_OWORD *)a2;
                *(void *)&uint8_t v114[16] = *(void *)(a2 + 16);
              }
              *(_OWORD *)CFTypeRef v110 = v88;
              uint64_t v111 = v89;
              long long v88 = 0uLL;
              uint64_t v89 = 0;
              buf[0] = theDict;
              *(_OWORD *)&theDict.__r_.__value_.__r.__words[1] = 0uLL;
              if ((v114[23] & 0x80000000) != 0) {
                sub_10004FC84(&buf[1], *(void **)v114, *(unint64_t *)&v114[8]);
              }
              else {
                buf[1] = *(std::string *)v114;
              }
              xpc_object_t v123 = 0;
              CFTypeRef v65 = (char *)operator new(0x38uLL);
              *(void *)CFTypeRef v65 = off_101A3EF70;
              *(std::string *)(v65 + 8) = buf[0];
              *(_OWORD *)&buf[0].__r_.__value_.__r.__words[1] = 0uLL;
              int v66 = v65 + 32;
              if (SHIBYTE(buf[1].__r_.__value_.__r.__words[2]) < 0)
              {
                sub_10004FC84(v66, buf[1].__r_.__value_.__l.__data_, buf[1].__r_.__value_.__l.__size_);
              }
              else
              {
                *(_OWORD *)int v66 = *(_OWORD *)&buf[1].__r_.__value_.__l.__data_;
                *((void *)v65 + 6) = *((void *)&buf[1].__r_.__value_.__l + 2);
              }
              xpc_object_t v123 = v65;
              (*(void (**)(CFTypeRef *__return_ptr, uint64_t, void **, void, uint64_t, void, long long *))(*(void *)v61 + 40))(&cf, v61, v110, 0, 1000000 * data, 0, &v121);
              sub_10003B34C(&v121);
              if (SHIBYTE(buf[1].__r_.__value_.__r.__words[2]) < 0) {
                operator delete(buf[1].__r_.__value_.__l.__data_);
              }
              if (buf[0].__r_.__value_.__r.__words[2]) {
                std::__shared_weak_count::__release_weak((std::__shared_weak_count *)buf[0].__r_.__value_.__r.__words[2]);
              }
              if (SHIBYTE(v111) < 0) {
                operator delete(v110[0]);
              }
              CFTypeRef v67 = cf;
              CFTypeRef cf = 0;
              uint64_t v68 = *(void *)(a1 + 968);
              *(void *)(a1 + 968) = v67;
              if (v68)
              {
                (*(void (**)(uint64_t))(*(void *)v68 + 8))(v68);
                CFTypeRef v69 = cf;
                CFTypeRef cf = 0;
                if (v69) {
                  (*(void (**)(CFTypeRef))(*(void *)v69 + 8))(v69);
                }
              }
              if ((v114[23] & 0x80000000) != 0) {
                operator delete(*(void **)v114);
              }
              if (theDict.__r_.__value_.__r.__words[2]) {
                std::__shared_weak_count::__release_weak((std::__shared_weak_count *)theDict.__r_.__value_.__r.__words[2]);
              }
              if (SHIBYTE(v89) < 0) {
                operator delete((void *)v88);
              }
LABEL_266:
              if (v102) {
                sub_10004D2C8(v102);
              }
              return;
            }
            char v55 = *(NSObject **)(a1 + 40);
            if (!os_log_type_enabled(v55, OS_LOG_TYPE_ERROR)) {
              goto LABEL_229;
            }
            LOWORD(buf[0].__r_.__value_.__l.__data_) = 0;
            long long v56 = "Missing PhoneAccountTransfer in CB";
          }
          else
          {
            char v55 = *(NSObject **)(a1 + 40);
            if (!os_log_type_enabled(v55, OS_LOG_TYPE_ERROR)) {
              goto LABEL_229;
            }
            LOWORD(buf[0].__r_.__value_.__l.__data_) = 0;
            long long v56 = "Failed loading PhoneAccountTransfer CB";
          }
          _os_log_error_impl((void *)&_mh_execute_header, v55, OS_LOG_TYPE_ERROR, v56, (uint8_t *)buf, 2u);
          goto LABEL_229;
        }
        uint64_t v31 = v30;
        v110[0] = off_101AB3BC8;
        v110[1] = 0;
        uint64_t v112 = 0;
        uint64_t v111 = 0;
        sub_1005E4B2C((uint64_t)v110);
        std::string::operator=(v111, &__str);
        long long v32 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
        {
          char v33 = &__str;
          if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
            char v33 = (std::string *)__str.__r_.__value_.__r.__words[0];
          }
          LODWORD(buf[0].__r_.__value_.__l.__data_) = 136315138;
          *(std::string::size_type *)((char *)buf[0].__r_.__value_.__r.__words + 4) = (std::string::size_type)v33;
          _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, "#I sending delete profile request for iccid: %s", (uint8_t *)buf, 0xCu);
        }
        if (*(char *)(v31 + 1279) < 0) {
          sub_10004FC84(&__src, *(void **)(v31 + 1256), *(void *)(v31 + 1264));
        }
        else {
          std::string __src = *(std::string *)(v31 + 1256);
        }
        if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
          sub_10004FC84(&v108, __str.__r_.__value_.__l.__data_, __str.__r_.__value_.__l.__size_);
        }
        else {
          std::string v108 = __str;
        }
        uint64_t v36 = *(void *)(v31 + 1168);
        uint64_t v37 = *(void *)(v31 + 1176);
        sub_100058DB0(&v106, "kDeleteProfileRequest");
        memset(buf, 0, 24);
        PB::Writer::Writer((PB::Writer *)buf);
        (*((void (**)(void **, std::string *))v110[0] + 3))(v110, buf);
        *(void *)xpc_object_t v104 = 0;
        CFTypeRef v103 = 0;
        uint64_t v105 = 0;
        sub_10006E4A8(&v103, (char *)buf[0].__r_.__value_.__l.__size_, buf[0].__r_.__value_.__l.__data_, buf[0].__r_.__value_.__r.__words[0] - buf[0].__r_.__value_.__l.__size_);
        PB::Writer::~Writer((PB::Writer *)buf);
        if (!*(void *)(a1 + 216))
        {
          int v38 = *(std::__shared_weak_count **)(a1 + 72);
          if (v38)
          {
            long long v39 = std::__shared_weak_count::lock(v38);
            if (v39)
            {
              long long v40 = v39;
              uint64_t v41 = *(void *)(a1 + 64);
              if (v41)
              {
                if (SHIBYTE(__src.__r_.__value_.__r.__words[2]) < 0) {
                  sub_10004FC84(buf, __src.__r_.__value_.__l.__data_, __src.__r_.__value_.__l.__size_);
                }
                else {
                  buf[0] = __src;
                }
                if (SHIBYTE(v108.__r_.__value_.__r.__words[2]) < 0) {
                  sub_10004FC84(&theDict, v108.__r_.__value_.__l.__data_, v108.__r_.__value_.__l.__size_);
                }
                else {
                  std::string theDict = v108;
                }
                if (SHIBYTE(v107) < 0)
                {
                  sub_10004FC84(&v121, (void *)v106, *((unint64_t *)&v106 + 1));
                }
                else
                {
                  long long v121 = v106;
                  uint64_t v122 = v107;
                }
                CFTypeRef v119 = 0;
                CFTypeRef cf = 0;
                uint64_t v120 = 0;
                sub_10005C928(&cf, v103, *(uint64_t *)v104, *(void *)v104 - (void)v103);
                (*(void (**)(uint64_t, std::string *, std::string *, uint64_t, uint64_t, long long *, CFTypeRef *))(*(void *)v41 + 32))(v41, buf, &theDict, v36, v37, &v121, &cf);
                if (cf)
                {
                  CFTypeRef v119 = cf;
                  operator delete((void *)cf);
                }
                if (SHIBYTE(v122) < 0) {
                  operator delete((void *)v121);
                }
                if (SHIBYTE(theDict.__r_.__value_.__r.__words[2]) < 0) {
                  operator delete(theDict.__r_.__value_.__l.__data_);
                }
                if (SHIBYTE(buf[0].__r_.__value_.__r.__words[2]) < 0) {
                  operator delete(buf[0].__r_.__value_.__l.__data_);
                }
                sub_10004D2C8(v40);
LABEL_179:
                if (v103)
                {
                  *(void *)xpc_object_t v104 = v103;
                  operator delete(v103);
                }
                if (SHIBYTE(v107) < 0) {
                  operator delete((void *)v106);
                }
                if (SHIBYTE(v108.__r_.__value_.__r.__words[2]) < 0) {
                  operator delete(v108.__r_.__value_.__l.__data_);
                }
                if (SHIBYTE(__src.__r_.__value_.__r.__words[2]) < 0) {
                  operator delete(__src.__r_.__value_.__l.__data_);
                }
                sub_10132CDD0((uint64_t)v110);
                goto LABEL_188;
              }
              sub_10004D2C8(v39);
            }
          }
        }
        uint64_t v129 = 0;
        long long v127 = 0u;
        long long v128 = 0u;
        long long v125 = 0u;
        long long v126 = 0u;
        memset(buf, 0, sizeof(buf));
        if (SHIBYTE(__src.__r_.__value_.__r.__words[2]) < 0) {
          sub_10004FC84(buf, __src.__r_.__value_.__l.__data_, __src.__r_.__value_.__l.__size_);
        }
        else {
          buf[0] = __src;
        }
        if (SHIBYTE(v108.__r_.__value_.__r.__words[2]) < 0) {
          sub_10004FC84(&buf[1], v108.__r_.__value_.__l.__data_, v108.__r_.__value_.__l.__size_);
        }
        else {
          buf[1] = v108;
        }
        long long v125 = 0uLL;
        if (SHIBYTE(v107) < 0)
        {
          sub_10004FC84(&v126, (void *)v106, *((unint64_t *)&v106 + 1));
        }
        else
        {
          long long v126 = v106;
          *(void *)&long long v127 = v107;
        }
        *((void *)&v127 + 1) = 0;
        long long v128 = 0uLL;
        sub_10005C928((void *)&v127 + 1, v103, *(uint64_t *)v104, *(void *)v104 - (void)v103);
        LOBYTE(v129) = 0;
        CFTypeRef cf = 0;
        sub_100CD81C4((uint64_t *)buf, &cf);
        uint64_t v42 = *(void *)(a1 + 216);
        CFTypeRef v117 = cf;
        if (cf) {
          CFRetain(cf);
        }
        uint64_t v116 = 45;
        theDict.__r_.__value_.__r.__words[0] = a1;
        if (SHIBYTE(v107) < 0)
        {
          sub_10004FC84(&theDict.__r_.__value_.__s.__data_[8], (void *)v106, *((unint64_t *)&v106 + 1));
        }
        else
        {
          *(_OWORD *)&theDict.__r_.__value_.__r.__words[1] = v106;
          *(void *)uint64_t v114 = v107;
        }
        if (SHIBYTE(v108.__r_.__value_.__r.__words[2]) < 0) {
          sub_10004FC84(&v114[8], v108.__r_.__value_.__l.__data_, v108.__r_.__value_.__l.__size_);
        }
        else {
          *(std::string *)&v114[8] = v108;
        }
        if (SHIBYTE(__src.__r_.__value_.__r.__words[2]) < 0) {
          sub_10004FC84(&v115, __src.__r_.__value_.__l.__data_, __src.__r_.__value_.__l.__size_);
        }
        else {
          std::string v115 = __src;
        }
        xpc_object_t v123 = 0;
        long long v43 = (char *)operator new(0x58uLL);
        std::string::size_type v44 = theDict.__r_.__value_.__r.__words[0];
        *(void *)long long v43 = off_101A3F080;
        *((void *)v43 + 1) = v44;
        *((_OWORD *)v43 + 1) = *(_OWORD *)&theDict.__r_.__value_.__r.__words[1];
        *((void *)v43 + 4) = *(void *)v114;
        *(_OWORD *)&theDict.__r_.__value_.__r.__words[1] = 0uLL;
        *(void *)uint64_t v114 = 0;
        *(_OWORD *)(v43 + 40) = *(_OWORD *)&v114[8];
        *((void *)v43 + 7) = *(void *)&v114[24];
        memset(&v114[8], 0, 24);
        long long v45 = *(_OWORD *)&v115.__r_.__value_.__l.__data_;
        *((void *)v43 + 10) = *((void *)&v115.__r_.__value_.__l + 2);
        *((_OWORD *)v43 + 4) = v45;
        memset(&v115, 0, sizeof(v115));
        xpc_object_t v123 = v43;
        (*(void (**)(uint64_t, long long *, CFTypeRef *, uint64_t, uint64_t *, long long *))(*(void *)v42 + 16))(v42, &v106, &v117, a1 + 24, &v116, &v121);
        sub_100B202F4(&v121);
        if (SHIBYTE(v115.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v115.__r_.__value_.__l.__data_);
        }
        if ((v114[31] & 0x80000000) != 0) {
          operator delete(*(void **)&v114[8]);
        }
        if ((v114[7] & 0x80000000) != 0) {
          operator delete((void *)theDict.__r_.__value_.__l.__size_);
        }
        sub_100057D78(&v117);
        sub_100057D78(&cf);
        if (*((void *)&v127 + 1))
        {
          *(void *)&long long v128 = *((void *)&v127 + 1);
          operator delete(*((void **)&v127 + 1));
        }
        if (SBYTE7(v127) < 0) {
          operator delete((void *)v126);
        }
        if (SHIBYTE(buf[1].__r_.__value_.__r.__words[2]) < 0) {
          operator delete(buf[1].__r_.__value_.__l.__data_);
        }
        if (SHIBYTE(buf[0].__r_.__value_.__r.__words[2]) < 0) {
          operator delete(buf[0].__r_.__value_.__l.__data_);
        }
        goto LABEL_179;
      }
LABEL_12:
      goto LABEL_9;
    }
LABEL_268:
    sub_10016C840();
  }
  int v9 = *(unsigned __int8 *)(v5 + 1513);
  if (v7 != 1)
  {
    if (v9 != 1) {
      goto LABEL_5;
    }
    if (*(char *)(a2 + 23) < 0)
    {
      sub_10004FC84(&v70, *(void **)a2, *(void *)(a2 + 8));
    }
    else
    {
      long long v70 = *(_OWORD *)a2;
      uint64_t v71 = *(void *)(a2 + 16);
    }
    sub_100B5D858(a1, (unsigned __int8 **)&v70, 5);
    if ((SHIBYTE(v71) & 0x80000000) == 0) {
      return;
    }
    uint64_t v11 = (void *)v70;
LABEL_100:
    operator delete(v11);
    return;
  }
  if (v9 != 1)
  {
    if (*(char *)(a2 + 23) < 0)
    {
      sub_10004FC84(&__dst, *(void **)a2, *(void *)(a2 + 8));
    }
    else
    {
      long long __dst = *(_OWORD *)a2;
      uint64_t v73 = *(void *)(a2 + 16);
    }
    sub_100B5D858(a1, (unsigned __int8 **)&__dst, 2);
    if ((SHIBYTE(v73) & 0x80000000) == 0) {
      return;
    }
    uint64_t v11 = (void *)__dst;
    goto LABEL_100;
  }
  if (!*(unsigned char *)(v5 + 216)) {
    goto LABEL_268;
  }
  if (*(char *)(v5 + 119) < 0)
  {
    sub_10004FC84(v86, *(void **)(v5 + 96), *(void *)(v5 + 104));
    if (!*(unsigned char *)(v6 + 216)) {
      sub_10016C840();
    }
  }
  else
  {
    *(_OWORD *)uint64_t v86 = *(_OWORD *)(v5 + 96);
    uint64_t v87 = *(void *)(v5 + 112);
  }
  if (*(char *)(v6 + 143) < 0)
  {
    sub_10004FC84(v84, *(void **)(v6 + 120), *(void *)(v6 + 128));
    if (!*(unsigned char *)(v6 + 216)) {
      sub_10016C840();
    }
  }
  else
  {
    *(_OWORD *)uint64_t v84 = *(_OWORD *)(v6 + 120);
    uint64_t v85 = *(void *)(v6 + 136);
  }
  if (*(char *)(v6 + 167) < 0)
  {
    sub_10004FC84(v82, *(void **)(v6 + 144), *(void *)(v6 + 152));
    if (!*(unsigned char *)(v6 + 216)) {
      sub_10016C840();
    }
  }
  else
  {
    *(_OWORD *)char v82 = *(_OWORD *)(v6 + 144);
    uint64_t v83 = *(void *)(v6 + 160);
  }
  if (*(char *)(v6 + 191) < 0)
  {
    sub_10004FC84(v80, *(void **)(v6 + 168), *(void *)(v6 + 176));
  }
  else
  {
    *(_OWORD *)uint64_t v80 = *(_OWORD *)(v6 + 168);
    uint64_t v81 = *(void *)(v6 + 184);
  }
  if (*(char *)(a2 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)long long __p = *(_OWORD *)a2;
    uint64_t v79 = *(void *)(a2 + 16);
  }
  theDict.__r_.__value_.__r.__words[0] = 0;
  (*(void (**)(std::string *__return_ptr))(**(void **)(a1 + 48) + 768))(&theDict);
  if (theDict.__r_.__value_.__r.__words[0]) {
    uint64_t v12 = sub_100080778;
  }
  else {
    uint64_t v12 = 0;
  }
  if (!v12)
  {
    BOOL v19 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
    {
      LOWORD(buf[0].__r_.__value_.__l.__data_) = 0;
      int v20 = "Failed loading PhoneAccountTransfer CB";
LABEL_66:
      _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, v20, (uint8_t *)buf, 2u);
    }
LABEL_78:
    BOOL v22 = 0;
    goto LABEL_79;
  }
  if (!CFDictionaryContainsKey((CFDictionaryRef)theDict.__r_.__value_.__l.__data_, @"PhoneAccountTransfer"))
  {
    BOOL v19 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
    {
      LOWORD(buf[0].__r_.__value_.__l.__data_) = 0;
      int v20 = "Missing PhoneAccountTransfer in CB";
      goto LABEL_66;
    }
    goto LABEL_78;
  }
  CFDictionaryRef v13 = (const __CFDictionary *)CFDictionaryGetValue((CFDictionaryRef)theDict.__r_.__value_.__l.__data_, @"PhoneAccountTransfer");
  if (!CFDictionaryContainsKey(v13, @"DisplayOtpBeforeTc"))
  {
    uint64_t v25 = *(NSObject **)(a1 + 40);
    BOOL v22 = 0;
    if (!os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_79;
    }
    uint64_t v26 = __p;
    if (v79 < 0) {
      uint64_t v26 = (void **)__p[0];
    }
    LODWORD(buf[0].__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)buf[0].__r_.__value_.__r.__words + 4) = (std::string::size_type)v26;
    _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "#I DisplayOtpBeforeTc not present in CB entitlements for ICCID: [%s]", (uint8_t *)buf, 0xCu);
    goto LABEL_78;
  }
  int v14 = (BOOL *)CFDictionaryGetValue(v13, @"DisplayOtpBeforeTc");
  uint64_t v15 = v14;
  buf[0].__r_.__value_.__s.__data_[0] = 0;
  if (v14 && (CFTypeID v16 = CFGetTypeID(v14), v16 == CFBooleanGetTypeID()))
  {
    ctu::cf::assign((ctu::cf *)buf, v15, v17);
    int v18 = buf[0].__r_.__value_.__s.__data_[0];
  }
  else
  {
    int v18 = 0;
  }
  BOOL v22 = v18 != 0;
  uint64_t v23 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v24 = __p;
    if (v79 < 0) {
      uint64_t v24 = (void **)__p[0];
    }
    LODWORD(buf[0].__r_.__value_.__l.__data_) = 67109378;
    HIDWORD(buf[0].__r_.__value_.__r.__words[0]) = v18;
    LOWORD(buf[0].__r_.__value_.__r.__words[1]) = 2080;
    *(std::string::size_type *)((char *)&buf[0].__r_.__value_.__r.__words[1] + 2) = (std::string::size_type)v24;
    _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "#I DisplayOtpBeforeTc is set to %d for ICCID: [%s]", (uint8_t *)buf, 0x12u);
  }
LABEL_79:
  sub_100057D78((const void **)&theDict.__r_.__value_.__l.__data_);
  if (SHIBYTE(v79) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v81) < 0) {
    operator delete(v80[0]);
  }
  if (SHIBYTE(v83) < 0) {
    operator delete(v82[0]);
  }
  if (SHIBYTE(v85) < 0) {
    operator delete(v84[0]);
  }
  if (SHIBYTE(v87) < 0) {
    operator delete(v86[0]);
  }
  int v27 = *(char *)(a2 + 23);
  if (v22)
  {
    if (v27 < 0)
    {
      sub_10004FC84(&v76, *(void **)a2, *(void *)(a2 + 8));
    }
    else
    {
      long long v76 = *(_OWORD *)a2;
      uint64_t v77 = *(void *)(a2 + 16);
    }
    sub_100B5D858(a1, (unsigned __int8 **)&v76, 5);
    if (SHIBYTE(v77) < 0)
    {
      uint64_t v11 = (void *)v76;
      goto LABEL_100;
    }
  }
  else
  {
    if (v27 < 0)
    {
      sub_10004FC84(v74, *(void **)a2, *(void *)(a2 + 8));
    }
    else
    {
      *(_OWORD *)char v74 = *(_OWORD *)a2;
      uint64_t v75 = *(void *)(a2 + 16);
    }
    sub_100B5D858(a1, (unsigned __int8 **)v74, 2);
    if (SHIBYTE(v75) < 0)
    {
      uint64_t v11 = v74[0];
      goto LABEL_100;
    }
  }
}

void sub_100B5D418(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,void *a25,uint64_t a26,uint64_t a27,uint64_t a28,void *a29,uint64_t a30,uint64_t a31,uint64_t a32,void *a33,uint64_t a34,uint64_t a35,uint64_t a36,void *a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,void *a47,uint64_t a48,uint64_t a49,uint64_t a50,void *a51,uint64_t a52,uint64_t a53,uint64_t a54,void *a55,uint64_t a56,uint64_t a57,uint64_t a58,void *a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  if (SLOBYTE(STACK[0x2A7]) < 0) {
    operator delete((void *)STACK[0x290]);
  }
  if (*(char *)(v74 - 185) < 0) {
    operator delete(*(void **)(v74 - 208));
  }
  sub_10004D2C8(v73);
  long long v76 = (void *)STACK[0x200];
  if (STACK[0x200])
  {
    STACK[0x208] = (unint64_t)v76;
    operator delete(v76);
  }
  if (SLOBYTE(STACK[0x22F]) < 0) {
    operator delete((void *)STACK[0x218]);
  }
  if (SLOBYTE(STACK[0x247]) < 0) {
    operator delete((void *)STACK[0x230]);
  }
  if (SLOBYTE(STACK[0x267]) < 0) {
    operator delete((void *)STACK[0x250]);
  }
  sub_10132CDD0((uint64_t)&STACK[0x270]);
  if (a72 < 0) {
    operator delete(a67);
  }
  if (a73) {
    sub_10004D2C8(a73);
  }
  _Unwind_Resume(a1);
}

void sub_100B5D858(uint64_t a1, unsigned __int8 **a2, int a3)
{
  void (***v16)(uint64_t *__return_ptr, void, void **);
  char v17;
  NSObject *v18;
  NSObject *v19;
  uint64_t v20;
  unint64_t *v21;
  std::string *v22;
  int v23;
  uint64_t v24;
  std::__shared_weak_count *v25;
  uint64_t v26;
  std::__shared_weak_count *v27;
  std::__shared_weak_count *v28;
  atomic_ullong *p_shared_weak_owners;
  uint64_t v30;
  void v31[6];
  std::__shared_weak_count *v32;
  long long __p;
  unint64_t v34;
  uint64_t v35;
  int v36;
  void *v37;
  long long v38;
  void *v39[2];
  long long v40;
  long long v41;
  long long v42;
  uint64_t v43;
  std::string __str[2];
  long long v45;
  long long v46;
  long long v47;
  long long v48;
  long long v49;
  long long v50;
  uint64_t v51;
  char v52;
  uint64_t v53;
  std::__shared_weak_count *v54;
  void *v55[2];
  uint64_t v56;
  uint64_t v57;
  void buf[24];
  long long v59;
  uint64_t v60;

  uint64_t v4 = (unint64_t *)a2;
  uint64_t v6 = *(void *)(a1 + 312);
  int v57 = sub_100B45F5C(*(void *)(a1 + 304), v6, a2);
  if (v6 != v57)
  {
    v55[0] = 0;
    v55[1] = 0;
    long long v56 = 0;
    sub_100B49750((uint64_t)v55, (uint64_t)v4);
    CFNumberRef v53 = 0;
    unsigned int v54 = 0;
    (***(void (****)(void *__return_ptr))(a1 + 48))(buf);
    ServiceMap = (std::mutex *)Registry::getServiceMap(v7, (Registry *)buf[0]);
    int v9 = ServiceMap;
    if ((v10 & 0x8000000000000000) != 0)
    {
      uint64_t v11 = (unsigned __int8 *)(v10 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v12 = 5381;
      do
      {
        std::string::size_type v10 = v12;
        unsigned int v13 = *v11++;
        uint64_t v12 = (33 * v12) ^ v13;
      }
      while (v13);
    }
    std::mutex::lock(ServiceMap);
    __str[0].__r_.__value_.__r.__words[0] = v10;
    int v14 = sub_10004D37C(&v9[1].__m_.__sig, (unint64_t *)__str);
    if (v14)
    {
      CFTypeID v16 = (void (***)(uint64_t *__return_ptr, void, void **))v14[3];
      uint64_t v15 = (std::__shared_weak_count *)v14[4];
      if (v15)
      {
        atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v9);
        atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v15);
        CFBooleanRef v17 = 0;
LABEL_14:
        (**v16)(&v53, v16, v55);
        if ((v17 & 1) == 0) {
          sub_10004D2C8(v15);
        }
        if (buf[1]) {
          sub_10004D2C8((std::__shared_weak_count *)buf[1]);
        }
        BOOL v19 = *(NSObject **)(a1 + 40);
        if (v53)
        {
          if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
          {
            int v20 = entitlements::asString();
            uint64_t v21 = v4;
            if (*((char *)v4 + 23) < 0) {
              uint64_t v21 = (unint64_t *)*v4;
            }
            LODWORD(buf[0]) = 136446466;
            *(void *)((char *)buf + 4) = v20;
            WORD2(buf[1]) = 2080;
            *(void *)((char *)&buf[1] + 6) = v21;
            _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#I [req][ta] perform TransferAuthorization [%{public}s] request from target side. source iccid : %s", (uint8_t *)buf, 0x16u);
          }
          uint64_t v60 = 0;
          uint64_t v59 = 0u;
          memset(buf, 0, sizeof(buf));
          uint64_t v51 = 0;
          long long v49 = 0u;
          uint64_t v50 = 0u;
          uint64_t v47 = 0u;
          int v48 = 0u;
          long long v45 = 0u;
          long long v46 = 0u;
          memset(__str, 0, sizeof(__str));
          sub_100B50FB0(a1, (uint64_t)__str, *(void *)(a1 + 328));
          BOOL v22 = sub_1008C26DC((std::string *)&buf[5], __str);
          uint64_t v23 = capabilities::ct::supportsSIMTransferWithSecureIntent((capabilities::ct *)v22);
          uint64_t v24 = 2;
          if (v23) {
            uint64_t v24 = 3;
          }
          *((void *)&v59 + 1) = v24;
          LOBYTE(v60) = 1;
          if (a3 == 5)
          {
            LOWORD(buf[4]) = 257;
          }
          else if (a3 == 2)
          {
            WORD1(buf[4]) = 257;
          }
          uint64_t v25 = *(std::__shared_weak_count **)(a1 + 16);
          if (!v25 || (uint64_t v26 = *(void *)(a1 + 8), (v27 = std::__shared_weak_count::lock(v25)) == 0)) {
            sub_100088B9C();
          }
          uint64_t v28 = v27;
          p_shared_weak_owners = &v27->__shared_weak_owners_;
          atomic_fetch_add_explicit(&v27->__shared_weak_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v27);
          int v38 = 0u;
          *(_OWORD *)long long v39 = 0u;
          long long v43 = 0;
          uint64_t v41 = 0u;
          uint64_t v42 = 0u;
          long long v40 = 0u;
          WORD1(v38) = 257;
          DWORD1(v38) = 15;
          BYTE8(v38) = 1;
          HIDWORD(v38) = 1;
          LOBYTE(v39[0]) = 1;
          sub_100B55694(a1, 1);
          uint64_t v30 = v53;
          v31[0] = _NSConcreteStackBlock;
          v31[1] = 1174405120;
          void v31[2] = sub_100B5DF70;
          v31[3] = &unk_101A3E4E0;
          v31[4] = a1;
          v31[5] = v26;
          long long v32 = v28;
          atomic_fetch_add_explicit(p_shared_weak_owners, 1uLL, memory_order_relaxed);
          if (*((char *)v4 + 23) < 0)
          {
            sub_10004FC84(&__p, (void *)*v4, v4[1]);
          }
          else
          {
            long long __p = *(_OWORD *)v4;
            uint64_t v34 = v4[2];
          }
          uint64_t v36 = a3;
          std::string::size_type v35 = v57;
          uint64_t v37 = v31;
          (*(void (**)(uint64_t, uint64_t, long long *, void *, uint64_t, void **))(*(void *)v30 + 200))(v30, 8, &v38, buf, a1 + 24, &v37);
          if (SHIBYTE(v34) < 0) {
            operator delete((void *)__p);
          }
          if (v32) {
            std::__shared_weak_count::__release_weak(v32);
          }
          if ((_BYTE)v43 && SHIBYTE(v42) < 0) {
            operator delete(*((void **)&v41 + 1));
          }
          if ((_BYTE)v41 && SHIBYTE(v40) < 0) {
            operator delete(v39[1]);
          }
          std::__shared_weak_count::__release_weak(v28);
          if ((_BYTE)v51 && SHIBYTE(v50) < 0) {
            operator delete(*((void **)&v49 + 1));
          }
          if ((_BYTE)v49 && SHIBYTE(v48) < 0) {
            operator delete(*((void **)&v47 + 1));
          }
          if (BYTE8(v46) && SBYTE7(v46) < 0) {
            operator delete((void *)v45);
          }
          *(void *)&int v38 = &__str[1];
          sub_1001A010C((void ***)&v38);
          if (SHIBYTE(__str[0].__r_.__value_.__r.__words[2]) < 0) {
            operator delete(__str[0].__r_.__value_.__l.__data_);
          }
          sub_1001A0540((uint64_t)&buf[5]);
          if (LOBYTE(buf[3]) && SHIBYTE(buf[2]) < 0) {
            operator delete((void *)buf[0]);
          }
        }
        else
        {
          if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
          {
            LOWORD(buf[0]) = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "No entitlement controller available", (uint8_t *)buf, 2u);
          }
          LOBYTE(v37) = 11;
          buf[0] = 0;
          CFTypeID v52 = 4;
          __str[0].__r_.__value_.__r.__words[0] = 0;
          LODWORD(v38) = 70014;
          BYTE4(v38) = 1;
          sub_100B3E598((void *)a1, (unsigned __int8 **)v4, (unsigned __int8 *)&v37, 1, (const void **)buf, &v52, (const void **)&__str[0].__r_.__value_.__l.__data_, 0, 1, (uint64_t)&v38, &v57);
          sub_100057D78((const void **)&__str[0].__r_.__value_.__l.__data_);
          sub_1000558F4((const void **)buf);
        }
        if (v54) {
          sub_10004D2C8(v54);
        }
        if (SHIBYTE(v56) < 0) {
          operator delete(v55[0]);
        }
        return;
      }
    }
    else
    {
      CFTypeID v16 = 0;
    }
    std::mutex::unlock(v9);
    uint64_t v15 = 0;
    CFBooleanRef v17 = 1;
    goto LABEL_14;
  }
  int v18 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
  {
    if (*((char *)v4 + 23) < 0) {
      uint64_t v4 = (unint64_t *)*v4;
    }
    LODWORD(buf[0]) = 136315394;
    *(void *)((char *)buf + 4) = v4;
    WORD2(buf[1]) = 2082;
    *(void *)((char *)&buf[1] + 6) = entitlements::asString();
    _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "source iccid [%s] already removed, skip TA for %{public}s", (uint8_t *)buf, 0x16u);
  }
}

void sub_100B5DE88(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, std::__shared_weak_count *a18, void *a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,char a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,char a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,void *__p,uint64_t a60,int a61,__int16 a62,char a63)
{
  if (a18) {
    std::__shared_weak_count::__release_weak(a18);
  }
  sub_10016A3E8((uint64_t)&a25);
  std::__shared_weak_count::__release_weak(v66);
  sub_10019FD98((uint64_t)&a37);
  sub_100B56FB8((uint64_t)&a66);
  if (a58) {
    sub_10004D2C8((std::__shared_weak_count *)a58);
  }
  if (a64 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_100B5DF70(uint64_t a1, int **a2, int a3, int a4)
{
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 48);
  if (v5)
  {
    int v9 = *(void **)(a1 + 32);
    std::string::size_type v10 = std::__shared_weak_count::lock(v5);
    if (v10)
    {
      uint64_t v11 = v10;
      if (*(void *)(a1 + 40))
      {
        sub_100B55694((uint64_t)v9, 0);
        if (a3)
        {
          if (*a2)
          {
            uint64_t v12 = *((void *)*a2 + 1);
            if (v12)
            {
              bzero(v29, 0x250uLL);
              sub_100B63100((uint64_t)v29, v12);
              int v13 = **a2;
              buf[0] = v9;
              if (*(char *)(a1 + 79) < 0)
              {
                sub_10004FC84(&buf[1], *(void **)(a1 + 56), *(void *)(a1 + 64));
              }
              else
              {
                *(_OWORD *)&buf[1] = *(_OWORD *)(a1 + 56);
                uint64_t v34 = *(const char **)(a1 + 72);
              }
              sub_100B63100((uint64_t)&v35, (uint64_t)v29);
              int v37 = *(_DWORD *)(a1 + 88);
              int v38 = v13;
              BOOL v22 = (std::__shared_weak_count *)v9[2];
              if (v22)
              {
                if (std::__shared_weak_count::lock(v22)) {
                  operator new();
                }
              }
              sub_100088B9C();
            }
          }
        }
        int v14 = v9[5];
        if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
        {
          uint64_t v23 = (const void *)entitlements::asString();
          uint64_t v24 = *a2;
          if (*a2) {
            uint64_t v25 = "";
          }
          else {
            uint64_t v25 = "No Response.";
          }
          if ((a4 - 1) > 2) {
            uint64_t v26 = "RequestCanceled";
          }
          else {
            uint64_t v26 = off_101A3FE78[a4 - 1];
          }
          if (v24) {
            int v27 = sub_100FB56F4(*v24);
          }
          else {
            int v27 = "";
          }
          LODWORD(buf[0]) = 136446978;
          *(const void **)((char *)buf + 4) = v23;
          WORD2(buf[1]) = 2080;
          *(const void **)((char *)&buf[1] + 6) = v25;
          HIWORD(buf[2]) = 2080;
          uint64_t v34 = v26;
          __int16 v35 = 2080;
          uint64_t v36 = v27;
          _os_log_error_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "TA request [%{public}s] failed. %s EventCause: [%s], response status: [%s]", (uint8_t *)buf, 0x2Au);
          int v14 = v9[5];
        }
        BOOL v15 = os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT);
        if (a4 == 3)
        {
          if (v15)
          {
            CFTypeID v16 = (const void *)entitlements::asString();
            LODWORD(buf[0]) = 136446210;
            *(const void **)((char *)buf + 4) = v16;
            _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I Invalid TA [%{public}s] response by carrier", (uint8_t *)buf, 0xCu);
          }
          int v17 = *(_DWORD *)(a1 + 88) - 1;
          if (v17 > 8) {
            int v18 = 70010;
          }
          else {
            int v18 = dword_10154B640[v17];
          }
          v30[0] = 11;
          buf[0] = 0;
          char v28 = 52;
          v29[0] = 0;
          int v31 = v18;
          char v32 = 1;
          sub_100B3E598(v9, (unsigned __int8 **)(a1 + 56), v30, 1, buf, &v28, v29, 7u, 1, (uint64_t)&v31, (uint64_t *)(a1 + 80));
        }
        else
        {
          if (v15)
          {
            BOOL v19 = (const void *)entitlements::asString();
            LODWORD(buf[0]) = 136446210;
            *(const void **)((char *)buf + 4) = v19;
            _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I No TA [%{public}s] response due to internal error", (uint8_t *)buf, 0xCu);
          }
          int v20 = *(_DWORD *)(a1 + 88) - 1;
          if (v20 > 8) {
            int v21 = 70023;
          }
          else {
            int v21 = dword_10154B664[v20];
          }
          v30[0] = 11;
          buf[0] = 0;
          char v28 = 56;
          v29[0] = 0;
          int v31 = v21;
          char v32 = 1;
          sub_100B3E598(v9, (unsigned __int8 **)(a1 + 56), v30, 1, buf, &v28, v29, 0, 1, (uint64_t)&v31, (uint64_t *)(a1 + 80));
        }
        sub_100057D78(v29);
        sub_1000558F4(buf);
      }
      sub_10004D2C8(v11);
    }
  }
}

void sub_100B5E438(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  sub_1008C2D48((uint64_t)va);
  sub_10004D2C8(v5);
  _Unwind_Resume(a1);
}

unsigned char *sub_100B5E4B4(void *a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 48);
  a1[5] = *(void *)(a2 + 40);
  a1[6] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  CFStringRef result = a1 + 7;
  if (*(char *)(a2 + 79) < 0) {
    return sub_10004FC84(result, *(void **)(a2 + 56), *(void *)(a2 + 64));
  }
  long long v5 = *(_OWORD *)(a2 + 56);
  a1[9] = *(void *)(a2 + 72);
  *(_OWORD *)CFStringRef result = v5;
  return result;
}

void sub_100B5E51C(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(std::__shared_weak_count **)(v1 + 48);
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  _Unwind_Resume(exception_object);
}

void sub_100B5E534(uint64_t a1)
{
  if (*(char *)(a1 + 79) < 0) {
    operator delete(*(void **)(a1 + 56));
  }
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 48);
  if (v2)
  {
    std::__shared_weak_count::__release_weak(v2);
  }
}

void sub_100B5E588(uint64_t a1, uint64_t a2, uint64_t a3, int a4, int a5)
{
  std::string::size_type v10 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    if (entitlements::isWebServiceRequest()) {
      uint64_t v11 = "post";
    }
    else {
      uint64_t v11 = "";
    }
    uint64_t v12 = entitlements::asString();
    if (*(char *)(a2 + 23) >= 0) {
      int v13 = (unsigned __int8 *)a2;
    }
    else {
      int v13 = *(unsigned __int8 **)a2;
    }
    LODWORD(buf[0].__r_.__value_.__l.__data_) = 136446722;
    *(std::string::size_type *)((char *)buf[0].__r_.__value_.__r.__words + 4) = (std::string::size_type)v11;
    WORD2(buf[0].__r_.__value_.__r.__words[1]) = 2082;
    *(std::string::size_type *)((char *)&buf[0].__r_.__value_.__r.__words[1] + 6) = v12;
    HIWORD(buf[0].__r_.__value_.__r.__words[2]) = 2080;
    buf[1].__r_.__value_.__r.__words[0] = (std::string::size_type)v13;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I [resp][ta%{public}s] processing TransferAuthorization [%{public}s] response. source iccid : %s", (uint8_t *)buf, 0x20u);
  }
  uint64_t v14 = *(void *)(a1 + 312);
  uint64_t v15 = sub_100B45F5C(*(void *)(a1 + 304), v14, (unsigned __int8 **)a2);
  uint64_t v88 = v15;
  if (v14 == v15)
  {
    int v20 = *(NSObject **)(a1 + 40);
    if (!os_log_type_enabled(v20, OS_LOG_TYPE_ERROR)) {
      return;
    }
    if (*(char *)(a2 + 23) >= 0) {
      int v21 = (unsigned __int8 *)a2;
    }
    else {
      int v21 = *(unsigned __int8 **)a2;
    }
    LODWORD(buf[0].__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)buf[0].__r_.__value_.__r.__words + 4) = (std::string::size_type)v21;
    goto LABEL_24;
  }
  uint64_t v16 = v15;
  if (*(unsigned char *)(a3 + 544))
  {
    if (*(char *)(a3 + 543) < 0)
    {
      if (*(void *)(a3 + 528)) {
        goto LABEL_13;
      }
    }
    else if (*(unsigned char *)(a3 + 543))
    {
LABEL_13:
      int v17 = (const std::string *)(a3 + 520);
      sub_100B5457C((char *)buf, a1, a2, (unsigned __int8 **)(a3 + 520));
      int v18 = sub_100CDAF4C((unsigned __int8 *)buf);
      if (SHIBYTE(buf[0].__r_.__value_.__r.__words[2]) < 0) {
        operator delete(buf[0].__r_.__value_.__l.__data_);
      }
      int v19 = 70040;
      LOBYTE(v96) = v18;
      if (v18 > 53)
      {
        if (v18 == 54)
        {
          int v19 = 70042;
        }
        else if (v18 == 55)
        {
          int v19 = 70044;
        }
      }
      else if (v18 == 37)
      {
        int v19 = 70043;
      }
      else if (v18 == 53)
      {
        int v19 = 70041;
      }
      long long v49 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v49, OS_LOG_TYPE_DEFAULT))
      {
        if (entitlements::isWebServiceRequest()) {
          uint64_t v50 = "post";
        }
        else {
          uint64_t v50 = "";
        }
        uint64_t v51 = entitlements::asString();
        std::string::size_type v52 = a3 + 520;
        if (*(char *)(a3 + 543) < 0) {
          std::string::size_type v52 = v17->__r_.__value_.__r.__words[0];
        }
        if (*(char *)(a2 + 23) >= 0) {
          CFNumberRef v53 = (unsigned __int8 *)a2;
        }
        else {
          CFNumberRef v53 = *(unsigned __int8 **)a2;
        }
        LODWORD(buf[0].__r_.__value_.__l.__data_) = 136446978;
        *(std::string::size_type *)((char *)buf[0].__r_.__value_.__r.__words + 4) = (std::string::size_type)v50;
        WORD2(buf[0].__r_.__value_.__r.__words[1]) = 2080;
        *(std::string::size_type *)((char *)&buf[0].__r_.__value_.__r.__words[1] + 6) = v51;
        HIWORD(buf[0].__r_.__value_.__r.__words[2]) = 2082;
        buf[1].__r_.__value_.__r.__words[0] = v52;
        LOWORD(buf[1].__r_.__value_.__r.__words[1]) = 2080;
        *(std::string::size_type *)((char *)&buf[1].__r_.__value_.__r.__words[1] + 2) = (std::string::size_type)v53;
        _os_log_impl((void *)&_mh_execute_header, v49, OS_LOG_TYPE_DEFAULT, "#E Carrier error-code in TA%{public}s [%s] response: %{public}s for source iccid:%s", (uint8_t *)buf, 0x2Au);
      }
      *(void *)std::string v115 = 0;
      if (!*(unsigned char *)(a1 + 131) && *(unsigned char *)(a3 + 576))
      {
        if (*(char *)(a3 + 575) < 0) {
          sub_10004FC84(&__dst, *(void **)(a3 + 552), *(void *)(a3 + 560));
        }
        else {
          std::string __dst = *(std::string *)(a3 + 552);
        }
        if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
          sub_10004FC84(&__p, __dst.__r_.__value_.__l.__data_, __dst.__r_.__value_.__l.__size_);
        }
        else {
          std::string __p = __dst;
        }
        v89[0] = 0;
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
          sub_10004FC84(buf, __p.__r_.__value_.__l.__data_, __p.__r_.__value_.__l.__size_);
        }
        else {
          buf[0] = __p;
        }
        v91[0] = 0;
        if (ctu::cf::convert_copy())
        {
          unsigned int v54 = v89[0];
          v89[0] = v91[0];
          v93[0] = v54;
          sub_1000558F4((const void **)v93);
        }
        if (SHIBYTE(buf[0].__r_.__value_.__r.__words[2]) < 0) {
          operator delete(buf[0].__r_.__value_.__l.__data_);
        }
        char v55 = v89[0];
        v89[0] = 0;
        sub_1000558F4((const void **)v89);
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__p.__r_.__value_.__l.__data_);
        }
        buf[0].__r_.__value_.__r.__words[0] = *(void *)v115;
        *(void *)std::string v115 = v55;
        uint64_t v97 = 0;
        sub_1000558F4((const void **)&buf[0].__r_.__value_.__l.__data_);
        sub_1000558F4(&v97);
        if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__dst.__r_.__value_.__l.__data_);
        }
      }
      sub_100093B44((std::string *)(v16 + 1480), v17);
      LOBYTE(v93[0]) = 11;
      buf[0].__r_.__value_.__r.__words[0] = 0;
      LODWORD(__p.__r_.__value_.__l.__data_) = v19;
      __p.__r_.__value_.__s.__data_[4] = 1;
      sub_100B3E598((void *)a1, (unsigned __int8 **)a2, (unsigned __int8 *)v93, 1, (const void **)v115, (char *)&v96, (const void **)&buf[0].__r_.__value_.__l.__data_, 7u, 1, (uint64_t)&__p, &v88);
      sub_100057D78((const void **)&buf[0].__r_.__value_.__l.__data_);
      long long v46 = (std::string *)v115;
      goto LABEL_106;
    }
  }
  if (a5 != 6013 || !*(unsigned char *)(a3 + 585) || *(unsigned char *)(a3 + 584) || !*(unsigned char *)(a3 + 480)) {
    goto LABEL_41;
  }
  uint64_t v23 = *(unsigned __int8 *)(a3 + 479);
  if ((v23 & 0x80u) != 0) {
    uint64_t v23 = *(void *)(a3 + 464);
  }
  if (!v23 || !*(unsigned char *)(a3 + 512) || !sub_100B515C8(a1, (unsigned __int8 **)a2))
  {
LABEL_41:
    if ((a4 & 0xFFFFFFFE) == 2)
    {
      uint64_t v25 = *(void *)(a1 + 312);
      uint64_t v26 = (char *)sub_100B45F5C(*(void *)(a1 + 304), v25, (unsigned __int8 **)a2);
      v93[0] = v26;
      if ((char *)v25 != v26)
      {
        if (*(unsigned char *)(a3 + 360))
        {
          uint64_t v27 = *(unsigned __int8 *)(a3 + 287);
          if ((v27 & 0x80u) != 0) {
            uint64_t v27 = *(void *)(a3 + 272);
          }
          if (v27)
          {
            uint64_t v28 = *(unsigned __int8 *)(a3 + 311);
            int v29 = (char)v28;
            if ((v28 & 0x80u) != 0) {
              uint64_t v28 = *(void *)(a3 + 296);
            }
            if (v28)
            {
              uint64_t v30 = *(unsigned __int8 *)(a3 + 359);
              if ((v30 & 0x80u) != 0) {
                uint64_t v30 = *(void *)(a3 + 344);
              }
              if (v30)
              {
                uint64_t v31 = *(unsigned __int8 *)(a3 + 335);
                char v32 = v31;
                if ((v31 & 0x80u) != 0) {
                  uint64_t v31 = *(void *)(a3 + 320);
                }
                if (v31)
                {
                  char v33 = v26;
                  if (v29 < 0)
                  {
                    sub_10004FC84(buf, *(void **)(a3 + 288), *(void *)(a3 + 296));
                    char v32 = *(unsigned char *)(a3 + 335);
                  }
                  else
                  {
                    buf[0] = *(std::string *)(a3 + 288);
                  }
                  if (v32 < 0) {
                    sub_10004FC84(&buf[1], *(void **)(a3 + 312), *(void *)(a3 + 320));
                  }
                  else {
                    buf[1] = *(std::string *)(a3 + 312);
                  }
                  if (*(char *)(a3 + 359) < 0)
                  {
                    sub_10004FC84(&v102, *(void **)(a3 + 336), *(void *)(a3 + 344));
                  }
                  else
                  {
                    long long v102 = *(_OWORD *)(a3 + 336);
                    *(void *)&long long v103 = *(void *)(a3 + 352);
                  }
                  uint64_t v71 = (void **)(v33 + 896);
                  if (v33[968])
                  {
                    if (v33[919] < 0) {
                      operator delete(*v71);
                    }
                    *((void *)v33 + 114) = *((void *)&buf[0].__r_.__value_.__l + 2);
                    *(_OWORD *)uint64_t v71 = *(_OWORD *)&buf[0].__r_.__value_.__l.__data_;
                    *((unsigned char *)&buf[0].__r_.__value_.__s + 23) = 0;
                    buf[0].__r_.__value_.__s.__data_[0] = 0;
                    CFMutableDictionaryRef v72 = (void **)(v33 + 920);
                    if (v33[943] < 0) {
                      operator delete(*v72);
                    }
                    *((void *)v33 + 117) = *((void *)&buf[1].__r_.__value_.__l + 2);
                    *(_OWORD *)CFMutableDictionaryRef v72 = *(_OWORD *)&buf[1].__r_.__value_.__l.__data_;
                    *((unsigned char *)&buf[1].__r_.__value_.__s + 23) = 0;
                    buf[1].__r_.__value_.__s.__data_[0] = 0;
                    uint64_t v73 = (void **)(v33 + 944);
                    if (v33[967] < 0)
                    {
                      operator delete(*v73);
                      int v74 = SHIBYTE(buf[1].__r_.__value_.__r.__words[2]);
                      *(_OWORD *)uint64_t v73 = v102;
                      *((void *)v33 + 120) = v103;
                      BYTE7(v103) = 0;
                      LOBYTE(v102) = 0;
                      if (v74 < 0) {
                        operator delete(buf[1].__r_.__value_.__l.__data_);
                      }
                    }
                    else
                    {
                      *(_OWORD *)uint64_t v73 = v102;
                      *((void *)v33 + 120) = v103;
                      BYTE7(v103) = 0;
                      LOBYTE(v102) = 0;
                    }
                  }
                  else
                  {
                    *(_OWORD *)uint64_t v71 = *(_OWORD *)&buf[0].__r_.__value_.__l.__data_;
                    *((void *)v33 + 114) = *((void *)&buf[0].__r_.__value_.__l + 2);
                    memset(buf, 0, 24);
                    *(std::string *)(v33 + 920) = buf[1];
                    memset(&buf[1], 0, sizeof(std::string));
                    *((_OWORD *)v33 + 59) = v102;
                    *((void *)v33 + 120) = v103;
                    *(void *)&long long v103 = 0;
                    long long v102 = 0uLL;
                    v33[968] = 1;
                  }
                  if (SHIBYTE(buf[0].__r_.__value_.__r.__words[2]) < 0) {
                    operator delete(buf[0].__r_.__value_.__l.__data_);
                  }
                  uint64_t v75 = *(void *)(a1 + 312);
                  uint64_t v76 = sub_100B45F5C(*(void *)(a1 + 304), v75, (unsigned __int8 **)a2);
                  if (v75 != v76)
                  {
                    *(unsigned char *)(v76 + 1512) = 2;
                    buf[0].__r_.__value_.__r.__words[0] = 0;
                    sub_100CD9E80((uint64_t *)a2, (uint64_t *)(a3 + 264), buf);
                    __p.__r_.__value_.__r.__words[0] = buf[0].__r_.__value_.__r.__words[0];
                    if (buf[0].__r_.__value_.__r.__words[0]) {
                      CFRetain(buf[0].__r_.__value_.__l.__data_);
                    }
                    sub_100B3E384(a1, (const void **)&__p.__r_.__value_.__l.__data_);
                    sub_100057D78((const void **)&__p.__r_.__value_.__l.__data_);
                    CFTypeRef v69 = buf;
LABEL_215:
                    sub_100057D78((const void **)&v69->__r_.__value_.__l.__data_);
                    return;
                  }
                  int v20 = *(NSObject **)(a1 + 40);
                  if (!os_log_type_enabled(v20, OS_LOG_TYPE_ERROR)) {
                    return;
                  }
                  if (*(char *)(a2 + 23) >= 0) {
                    uint64_t v77 = (unsigned __int8 *)a2;
                  }
                  else {
                    uint64_t v77 = *(unsigned __int8 **)a2;
                  }
                  LODWORD(buf[0].__r_.__value_.__l.__data_) = 136315138;
                  *(std::string::size_type *)((char *)buf[0].__r_.__value_.__r.__words + 4) = (std::string::size_type)v77;
                  goto LABEL_24;
                }
              }
            }
          }
        }
        std::string::size_type v44 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v44, OS_LOG_TYPE_ERROR))
        {
          LOWORD(buf[0].__r_.__value_.__l.__data_) = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_ERROR, "invalid Tc content in response", (uint8_t *)buf, 2u);
        }
        LOBYTE(v89[0]) = 11;
        buf[0].__r_.__value_.__r.__words[0] = 0;
        v115[0] = 52;
        __p.__r_.__value_.__r.__words[0] = 0;
        LODWORD(v91[0]) = 70070;
        BYTE4(v91[0]) = 1;
        sub_100B3E598((void *)a1, (unsigned __int8 **)a2, (unsigned __int8 *)v89, 1, (const void **)&buf[0].__r_.__value_.__l.__data_, v115, (const void **)&__p.__r_.__value_.__l.__data_, 7u, 1, (uint64_t)v91, (uint64_t *)v93);
LABEL_81:
        sub_100057D78((const void **)&__p.__r_.__value_.__l.__data_);
        long long v46 = buf;
LABEL_106:
        sub_1000558F4((const void **)&v46->__r_.__value_.__l.__data_);
        return;
      }
      int v20 = *(NSObject **)(a1 + 40);
      if (!os_log_type_enabled(v20, OS_LOG_TYPE_ERROR)) {
        return;
      }
      if (*(char *)(a2 + 23) >= 0) {
        uint64_t v47 = (unsigned __int8 *)a2;
      }
      else {
        uint64_t v47 = *(unsigned __int8 **)a2;
      }
      LODWORD(buf[0].__r_.__value_.__l.__data_) = 136315138;
      *(std::string::size_type *)((char *)buf[0].__r_.__value_.__r.__words + 4) = (std::string::size_type)v47;
    }
    else
    {
      uint64_t v34 = *(void *)(a1 + 312);
      uint64_t v35 = sub_100B45F5C(*(void *)(a1 + 304), v34, (unsigned __int8 **)a2);
      uint64_t v96 = v35;
      if (v34 != v35)
      {
        if (*(unsigned char *)(a3 + 448))
        {
          uint64_t v36 = *(unsigned __int8 *)(a3 + 415);
          int v37 = (char)v36;
          unint64_t v38 = *(void *)(a3 + 400);
          if ((v36 & 0x80u) != 0) {
            uint64_t v36 = *(void *)(a3 + 400);
          }
          if (v36)
          {
            uint64_t v39 = *(unsigned __int8 *)(a3 + 439);
            char v40 = v39;
            if ((v39 & 0x80u) != 0) {
              uint64_t v39 = *(void *)(a3 + 424);
            }
            if (v39)
            {
              uint64_t v41 = v35;
              uint64_t v42 = (uint64_t *)(a3 + 368);
              uint64_t v43 = *(unsigned __int8 *)(a3 + 391);
              if ((v43 & 0x80u) != 0) {
                uint64_t v43 = *(void *)(a3 + 376);
              }
              if (!v43 || (sub_100CD9E24((char *)(a3 + 368)) & 1) != 0)
              {
                if (v37 < 0)
                {
                  sub_10004FC84(buf, *(void **)(a3 + 392), v38);
                  char v40 = *(unsigned char *)(a3 + 439);
                }
                else
                {
                  buf[0] = *(std::string *)(a3 + 392);
                }
                if (v40 < 0) {
                  sub_10004FC84(&buf[1], *(void **)(a3 + 416), *(void *)(a3 + 424));
                }
                else {
                  buf[1] = *(std::string *)(a3 + 416);
                }
                uint64_t v62 = (void **)(v41 + 976);
                if (*(unsigned char *)(v41 + 1024))
                {
                  if (*(char *)(v41 + 999) < 0) {
                    operator delete(*v62);
                  }
                  *(void *)(v41 + 992) = *((void *)&buf[0].__r_.__value_.__l + 2);
                  *(_OWORD *)uint64_t v62 = *(_OWORD *)&buf[0].__r_.__value_.__l.__data_;
                  *((unsigned char *)&buf[0].__r_.__value_.__s + 23) = 0;
                  buf[0].__r_.__value_.__s.__data_[0] = 0;
                  std::string::size_type v63 = (void **)(v41 + 1000);
                  if (*(char *)(v41 + 1023) < 0)
                  {
                    operator delete(*v63);
                    int v64 = SHIBYTE(buf[0].__r_.__value_.__r.__words[2]);
                    *(_OWORD *)std::string::size_type v63 = *(_OWORD *)&buf[1].__r_.__value_.__l.__data_;
                    *(void *)(v41 + 1016) = *((void *)&buf[1].__r_.__value_.__l + 2);
                    *((unsigned char *)&buf[1].__r_.__value_.__s + 23) = 0;
                    buf[1].__r_.__value_.__s.__data_[0] = 0;
                    if (v64 < 0) {
                      operator delete(buf[0].__r_.__value_.__l.__data_);
                    }
                  }
                  else
                  {
                    *(_OWORD *)std::string::size_type v63 = *(_OWORD *)&buf[1].__r_.__value_.__l.__data_;
                    *(void *)(v41 + 1016) = *((void *)&buf[1].__r_.__value_.__l + 2);
                  }
                }
                else
                {
                  *(_OWORD *)uint64_t v62 = *(_OWORD *)&buf[0].__r_.__value_.__l.__data_;
                  *(void *)(v41 + 992) = *((void *)&buf[0].__r_.__value_.__l + 2);
                  *(std::string *)(v41 + 1000) = buf[1];
                  *(unsigned char *)(v41 + 1024) = 1;
                }
                if (!*(unsigned char *)(v41 + 216)) {
                  sub_10016C840();
                }
                if (*(char *)(v41 + 119) < 0)
                {
                  sub_10004FC84(buf, *(void **)(v41 + 96), *(void *)(v41 + 104));
                  if (!*(unsigned char *)(v41 + 216)) {
                    sub_10016C840();
                  }
                }
                else
                {
                  buf[0] = *(std::string *)(v41 + 96);
                }
                if (*(char *)(v41 + 143) < 0)
                {
                  sub_10004FC84(&__p, *(void **)(v41 + 120), *(void *)(v41 + 128));
                  if (!*(unsigned char *)(v41 + 216)) {
                    sub_10016C840();
                  }
                }
                else
                {
                  std::string __p = *(std::string *)(v41 + 120);
                }
                if (*(char *)(v41 + 167) < 0)
                {
                  sub_10004FC84(v93, *(void **)(v41 + 144), *(void *)(v41 + 152));
                  if (!*(unsigned char *)(v41 + 216)) {
                    sub_10016C840();
                  }
                }
                else
                {
                  *(_OWORD *)uint64_t v93 = *(_OWORD *)(v41 + 144);
                  uint64_t v94 = *(void *)(v41 + 160);
                }
                if (*(char *)(v41 + 191) < 0)
                {
                  sub_10004FC84(v91, *(void **)(v41 + 168), *(void *)(v41 + 176));
                }
                else
                {
                  *(_OWORD *)uint64_t v91 = *(_OWORD *)(v41 + 168);
                  uint64_t v92 = *(void *)(v41 + 184);
                }
                if (*(char *)(a2 + 23) < 0)
                {
                  sub_10004FC84(v89, *(void **)a2, *(void *)(a2 + 8));
                }
                else
                {
                  *(_OWORD *)uint64_t v89 = *(_OWORD *)a2;
                  uint64_t v90 = *(void *)(a2 + 16);
                }
                BOOL v65 = sub_100B51CA0(a1, (uint64_t)buf, (uint64_t)&__p, (uint64_t)v93, (uint64_t)v91, (uint64_t **)v89);
                if (SHIBYTE(v90) < 0) {
                  operator delete(v89[0]);
                }
                if (SHIBYTE(v92) < 0) {
                  operator delete(v91[0]);
                }
                if (SHIBYTE(v94) < 0) {
                  operator delete(v93[0]);
                }
                if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
                  operator delete(__p.__r_.__value_.__l.__data_);
                }
                if (SHIBYTE(buf[0].__r_.__value_.__r.__words[2]) < 0) {
                  operator delete(buf[0].__r_.__value_.__l.__data_);
                }
                uint64_t v66 = *(void *)(a1 + 312);
                uint64_t v67 = sub_100B45F5C(*(void *)(a1 + 304), v66, (unsigned __int8 **)a2);
                if (v66 != v67)
                {
                  uint64_t v68 = v67;
                  *(void *)std::string v115 = 0;
                  sub_100CD9FE4((uint64_t *)a2, v42, (uint64_t *)(v67 + 1144), v65, v115);
                  uint64_t v97 = *(const void **)v115;
                  if (*(void *)v115) {
                    CFRetain(*(CFTypeRef *)v115);
                  }
                  sub_100B3E384(a1, &v97);
                  sub_100057D78(&v97);
                  if (*(unsigned char *)(v68 + 1513) == 1) {
                    sub_100B3E764((void *)a1, a2, 0);
                  }
                  *(unsigned char *)(v68 + 1513) = 2;
                  CFTypeRef v69 = (std::string *)v115;
                  goto LABEL_215;
                }
                int v20 = *(NSObject **)(a1 + 40);
                if (!os_log_type_enabled(v20, OS_LOG_TYPE_ERROR)) {
                  return;
                }
                if (*(char *)(a2 + 23) >= 0) {
                  long long v70 = (unsigned __int8 *)a2;
                }
                else {
                  long long v70 = *(unsigned __int8 **)a2;
                }
                *(_DWORD *)std::string v115 = 136315138;
                *(void *)&v115[4] = v70;
                BOOL v22 = (std::string *)v115;
LABEL_25:
                _os_log_error_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, "source iccid:%s already removed", (uint8_t *)v22, 0xCu);
                return;
              }
            }
          }
        }
        long long v45 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v45, OS_LOG_TYPE_ERROR))
        {
          LOWORD(buf[0].__r_.__value_.__l.__data_) = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v45, OS_LOG_TYPE_ERROR, "invalid Otp content in response", (uint8_t *)buf, 2u);
        }
        LOBYTE(v91[0]) = 11;
        buf[0].__r_.__value_.__r.__words[0] = 0;
        LOBYTE(v89[0]) = 52;
        __p.__r_.__value_.__r.__words[0] = 0;
        LODWORD(v93[0]) = 70069;
        BYTE4(v93[0]) = 1;
        sub_100B3E598((void *)a1, (unsigned __int8 **)a2, (unsigned __int8 *)v91, 1, (const void **)&buf[0].__r_.__value_.__l.__data_, (char *)v89, (const void **)&__p.__r_.__value_.__l.__data_, 7u, 1, (uint64_t)v93, &v96);
        goto LABEL_81;
      }
      int v20 = *(NSObject **)(a1 + 40);
      if (!os_log_type_enabled(v20, OS_LOG_TYPE_ERROR)) {
        return;
      }
      if (*(char *)(a2 + 23) >= 0) {
        int v48 = (unsigned __int8 *)a2;
      }
      else {
        int v48 = *(unsigned __int8 **)a2;
      }
      LODWORD(buf[0].__r_.__value_.__l.__data_) = 136315138;
      *(std::string::size_type *)((char *)buf[0].__r_.__value_.__r.__words + 4) = (std::string::size_type)v48;
    }
LABEL_24:
    BOOL v22 = buf;
    goto LABEL_25;
  }
  long long v114 = 0u;
  long long v113 = 0u;
  if (a4 == 2) {
    uint64_t v24 = 3;
  }
  else {
    uint64_t v24 = 6;
  }
  long long v112 = 0uLL;
  long long v111 = 0uLL;
  long long v110 = 0uLL;
  long long v109 = 0uLL;
  long long v108 = 0uLL;
  long long v107 = 0uLL;
  long long v106 = 0uLL;
  long long v105 = 0uLL;
  long long v104 = 0uLL;
  long long v102 = 0uLL;
  long long v103 = 0uLL;
  memset(buf, 0, sizeof(buf));
  sub_100093B44(buf, (const std::string *)(a3 + 488));
  if (*(char *)(a2 + 23) < 0)
  {
    sub_10004FC84(v85, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)uint64_t v85 = *(_OWORD *)a2;
    uint64_t v86 = *(void *)(a2 + 16);
  }
  if (!*(unsigned char *)(a3 + 480)) {
    sub_10016C840();
  }
  *(void *)&long long v78 = a1;
  long long v56 = *(std::__shared_weak_count **)(a1 + 16);
  if (!v56 || (uint64_t v57 = *(void *)(a1 + 8), (v58 = std::__shared_weak_count::lock(v56)) == 0)) {
    sub_100088B9C();
  }
  *((void *)&v78 + 1) = v57;
  uint64_t v79 = v58;
  atomic_fetch_add_explicit(&v58->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v58);
  sub_100B63100((uint64_t)v80, a3);
  if (*(char *)(a2 + 23) < 0)
  {
    sub_10004FC84(&__src, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    long long __src = *(_OWORD *)a2;
    uint64_t v82 = *(void *)(a2 + 16);
  }
  uint64_t v83 = v16;
  int v84 = v24;
  long long v100 = 0;
  uint64_t v59 = (char *)operator new(0x298uLL);
  *(void *)uint64_t v59 = off_101A3FAD0;
  *(_OWORD *)(v59 + 8) = v78;
  *((void *)v59 + 3) = v79;
  sub_1008C2990((uint64_t)(v59 + 32), (uint64_t)v80);
  uint64_t v60 = v59 + 624;
  if (SHIBYTE(v82) < 0)
  {
    sub_10004FC84(v60, (void *)__src, *((unint64_t *)&__src + 1));
  }
  else
  {
    *(_OWORD *)uint64_t v60 = __src;
    *((void *)v59 + 80) = v82;
  }
  *((void *)v59 + 81) = v83;
  *((_DWORD *)v59 + 164) = v84;
  long long v100 = v59;
  BOOL v61 = sub_100B588AC(a1, (uint64_t)v85, a3 + 456, (uint64_t)buf, v24, (uint64_t)v99);
  sub_100777F50(v99);
  if (SHIBYTE(v82) < 0) {
    operator delete((void *)__src);
  }
  sub_1008C2D48((uint64_t)v80);
  if (SHIBYTE(v86) < 0) {
    operator delete(v85[0]);
  }
  if (!v61)
  {
    v98[3] = 0;
    sub_100B56FFC(a1, a2, 0, v24, (uint64_t)v98);
    sub_100060644(v98);
  }
  sub_100B632F8((uint64_t)buf);
}

void sub_100B5F584(_Unwind_Exception *a1)
{
  if (SLOBYTE(STACK[0x3EF]) < 0) {
    operator delete((void *)STACK[0x3D8]);
  }
  if (SLOBYTE(STACK[0x3D7]) < 0) {
    operator delete((void *)STACK[0x3C0]);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100B5F7A0(uint64_t a1)
{
  if (*(char *)(a1 + 639) < 0) {
    operator delete(*(void **)(a1 + 616));
  }
  sub_1008C2D48(a1 + 24);
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_100B5F7E8(uint64_t a1, uint64_t a2, uint64_t a3, int a4, int a5)
{
  std::string::size_type v10 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v11 = entitlements::asString();
    if (*(char *)(a2 + 23) >= 0) {
      uint64_t v12 = (unsigned __int8 *)a2;
    }
    else {
      uint64_t v12 = *(unsigned __int8 **)a2;
    }
    *(_DWORD *)long long buf = 136446466;
    *(void *)&uint8_t buf[4] = v11;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&unsigned char buf[14] = v12;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I [resp][tapost][%{public}s] source iccid : %s", buf, 0x16u);
  }
  uint64_t v14 = *(void *)(a1 + 304);
  uint64_t v13 = *(void *)(a1 + 312);
  uint64_t v15 = sub_100B45F5C(v14, v13, (unsigned __int8 **)a2);
  uint64_t v49 = v15;
  if (v13 == v15)
  {
    int v19 = *(NSObject **)(a1 + 40);
    if (!os_log_type_enabled(v19, OS_LOG_TYPE_ERROR)) {
      return;
    }
    if (*(char *)(a2 + 23) >= 0) {
      int v20 = (unsigned __int8 *)a2;
    }
    else {
      int v20 = *(unsigned __int8 **)a2;
    }
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = v20;
    goto LABEL_20;
  }
  if (!*(unsigned char *)(a3 + 272))
  {
    int v21 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
    {
      uint64_t v41 = entitlements::asString();
      if ((a5 - 1) > 2) {
        uint64_t v42 = "RequestCanceled";
      }
      else {
        uint64_t v42 = off_101A3FE78[a5 - 1];
      }
      *(_DWORD *)long long buf = 136446466;
      *(void *)&uint8_t buf[4] = v41;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&unsigned char buf[14] = v42;
      _os_log_error_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "TA webservice [%{public}s] failed. EventCause: [%s]", buf, 0x16u);
      int v21 = *(NSObject **)(a1 + 40);
    }
    int v22 = 70010;
    BOOL v23 = os_log_type_enabled(v21, OS_LOG_TYPE_ERROR);
    if (a5 == 3)
    {
      if (v23)
      {
        uint64_t v43 = entitlements::asString();
        *(_DWORD *)long long buf = 136446210;
        *(void *)&uint8_t buf[4] = v43;
        _os_log_error_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "TA webservice response [%{public}s] failed due to carrier error", buf, 0xCu);
      }
      if ((a4 - 1) <= 8) {
        int v22 = dword_10154B640[a4 - 1];
      }
      LOBYTE(v57[0]) = 11;
      *(void *)long long buf = 0;
      LOBYTE(v55[0]) = 52;
      *(void *)&long long __dst = 0;
      LODWORD(v59.__r_.__value_.__l.__data_) = v22;
      v59.__r_.__value_.__s.__data_[4] = 1;
      sub_100B3E598((void *)a1, (unsigned __int8 **)a2, (unsigned __int8 *)v57, 1, (const void **)buf, (char *)v55, (const void **)&__dst, 7u, 1, (uint64_t)&v59, &v49);
    }
    else
    {
      if (v23)
      {
        uint64_t v44 = entitlements::asString();
        *(_DWORD *)long long buf = 136446210;
        *(void *)&uint8_t buf[4] = v44;
        _os_log_error_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "TA webservice response [%{public}s] failed due to internal error", buf, 0xCu);
      }
      if ((a4 - 1) > 8) {
        int v30 = 70023;
      }
      else {
        int v30 = dword_10154B664[a4 - 1];
      }
      LOBYTE(v57[0]) = 11;
      *(void *)long long buf = 0;
      LOBYTE(v55[0]) = 56;
      *(void *)&long long __dst = 0;
      LODWORD(v59.__r_.__value_.__l.__data_) = v30;
      v59.__r_.__value_.__s.__data_[4] = 1;
      sub_100B3E598((void *)a1, (unsigned __int8 **)a2, (unsigned __int8 *)v57, 1, (const void **)buf, (char *)v55, (const void **)&__dst, 0, 1, (uint64_t)&v59, &v49);
    }
    goto LABEL_50;
  }
  if (!*(unsigned char *)(a3 + 44))
  {
    if (a4 != 7)
    {
      sub_100B5BF30(a1, a2);
      return;
    }
    uint64_t v24 = (unsigned char *)sub_100B45F5C(v14, v13, (unsigned __int8 **)a2);
    std::string::size_type v63 = v24;
    if ((unsigned char *)v13 != v24)
    {
      if (*(unsigned char *)(a3 + 264))
      {
        uint64_t v25 = v24;
        int v26 = *(unsigned __int8 *)(a3 + 256);
        if (v26 == 1) {
          char v27 = 3;
        }
        else {
          char v27 = 4;
        }
        v24[1513] = v27;
        uint64_t v28 = *(NSObject **)(a1 + 40);
        BOOL v29 = os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT);
        if (v26 == 1)
        {
          if (v29)
          {
            *(_WORD *)long long buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "#I Valid OTP", buf, 2u);
          }
          v25[1462] = 0;
          *(void *)long long buf = 0;
          sub_100CDA1EC(1, buf);
          *(void *)&long long __dst = *(void *)buf;
          if (*(void *)buf) {
            CFRetain(*(CFTypeRef *)buf);
          }
          sub_100B3E384(a1, (const void **)&__dst);
          sub_100057D78((const void **)&__dst);
          sub_100B3E764((void *)a1, a2, 1);
          sub_100B5BF30(a1, a2);
LABEL_103:
          sub_100057D78((const void **)buf);
          return;
        }
        if (v29)
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "#I Invalid OTP", buf, 2u);
          int v26 = *(unsigned __int8 *)(a3 + 256);
        }
        if (v26 != 2)
        {
          *(void *)long long buf = 0;
          sub_100CDA1EC(0, buf);
          *(void *)&long long __dst = *(void *)buf;
          if (*(void *)buf) {
            CFRetain(*(CFTypeRef *)buf);
          }
          sub_100B3E384(a1, (const void **)&__dst);
          sub_100057D78((const void **)&__dst);
          goto LABEL_103;
        }
        char v40 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v40, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_DEFAULT, "#I OTP retry not allowed", buf, 2u);
        }
        if (!v25[216]) {
          sub_10016C840();
        }
        if ((char)v25[119] < 0)
        {
          sub_10004FC84(buf, *((void **)v25 + 12), *((void *)v25 + 13));
          if (!v25[216]) {
            sub_10016C840();
          }
        }
        else
        {
          *(_OWORD *)long long buf = *((_OWORD *)v25 + 6);
          *(void *)&uint8_t buf[16] = *((void *)v25 + 14);
        }
        if ((char)v25[143] < 0)
        {
          sub_10004FC84(&__dst, *((void **)v25 + 15), *((void *)v25 + 16));
          if (!v25[216]) {
            sub_10016C840();
          }
        }
        else
        {
          long long __dst = *(_OWORD *)(v25 + 120);
          uint64_t v61 = *((void *)v25 + 17);
        }
        if ((char)v25[167] < 0)
        {
          sub_10004FC84(&v59, *((void **)v25 + 18), *((void *)v25 + 19));
          if (!v25[216]) {
            sub_10016C840();
          }
        }
        else
        {
          std::string v59 = *(std::string *)(v25 + 6);
        }
        if ((char)v25[191] < 0)
        {
          sub_10004FC84(v57, *((void **)v25 + 21), *((void *)v25 + 22));
        }
        else
        {
          *(_OWORD *)uint64_t v57 = *(_OWORD *)(v25 + 168);
          uint64_t v58 = *((void *)v25 + 23);
        }
        if (*(char *)(a2 + 23) < 0)
        {
          sub_10004FC84(v55, *(void **)a2, *(void *)(a2 + 8));
        }
        else
        {
          *(_OWORD *)char v55 = *(_OWORD *)a2;
          uint64_t v56 = *(void *)(a2 + 16);
        }
        if (sub_100B51CA0(a1, (uint64_t)buf, (uint64_t)&__dst, (uint64_t)&v59, (uint64_t)v57, (uint64_t **)v55)) {
          char v45 = 66;
        }
        else {
          char v45 = 65;
        }
        if (SHIBYTE(v56) < 0) {
          operator delete(v55[0]);
        }
        if (SHIBYTE(v58) < 0) {
          operator delete(v57[0]);
        }
        if (SHIBYTE(v59.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v59.__r_.__value_.__l.__data_);
        }
        if (SHIBYTE(v61) < 0) {
          operator delete((void *)__dst);
        }
        if ((buf[23] & 0x80000000) != 0) {
          operator delete(*(void **)buf);
        }
        char v62 = v45;
        unsigned __int8 v54 = 11;
        std::string::size_type v52 = 0;
        CFNumberRef v53 = 0;
        int v50 = 70061;
        char v51 = 1;
        sub_100B3E598((void *)a1, (unsigned __int8 **)a2, &v54, 1, &v53, &v62, &v52, 0xBu, 1, (uint64_t)&v50, (uint64_t *)&v63);
        sub_100057D78(&v52);
        uint64_t v31 = &v53;
LABEL_51:
        sub_1000558F4(v31);
        return;
      }
      uint64_t v39 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v39, OS_LOG_TYPE_ERROR))
      {
        uint64_t v46 = entitlements::asString();
        *(_DWORD *)long long buf = 136446210;
        *(void *)&uint8_t buf[4] = v46;
        _os_log_error_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_ERROR, "TA webservice response [%{public}s] does not contain OTP content", buf, 0xCu);
      }
      LOBYTE(v57[0]) = 11;
      *(void *)long long buf = 0;
      LOBYTE(v55[0]) = 52;
      *(void *)&long long __dst = 0;
      LODWORD(v59.__r_.__value_.__l.__data_) = 70069;
      v59.__r_.__value_.__s.__data_[4] = 1;
      sub_100B3E598((void *)a1, (unsigned __int8 **)a2, (unsigned __int8 *)v57, 1, (const void **)buf, (char *)v55, (const void **)&__dst, 7u, 1, (uint64_t)&v59, (uint64_t *)&v63);
LABEL_50:
      sub_100057D78((const void **)&__dst);
      uint64_t v31 = (const void **)buf;
      goto LABEL_51;
    }
    int v19 = *(NSObject **)(a1 + 40);
    if (!os_log_type_enabled(v19, OS_LOG_TYPE_ERROR)) {
      return;
    }
    if (*(char *)(a2 + 23) >= 0) {
      uint64_t v36 = (unsigned __int8 *)a2;
    }
    else {
      uint64_t v36 = *(unsigned __int8 **)a2;
    }
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = v36;
LABEL_20:
    _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "source iccid:%s already removed", buf, 0xCu);
    return;
  }
  uint64_t v16 = v15;
  memset(&v59, 0, sizeof(v59));
  std::to_string(&v59, *(_DWORD *)(a3 + 40));
  sub_100B5457C(buf, a1, a2, (unsigned __int8 **)&v59);
  int v17 = sub_100CDAF4C(buf);
  if ((buf[23] & 0x80000000) != 0) {
    operator delete(*(void **)buf);
  }
  LOBYTE(v50) = v17;
  int v18 = 70040;
  if (v17 > 53)
  {
    if (v17 == 54)
    {
      int v18 = 70042;
    }
    else if (v17 == 55)
    {
      int v18 = 70044;
    }
  }
  else if (v17 == 37)
  {
    int v18 = 70043;
  }
  else if (v17 == 53)
  {
    int v18 = 70041;
  }
  char v32 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v33 = entitlements::asString();
    uint64_t v34 = &v59;
    if ((v59.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      uint64_t v34 = (std::string *)v59.__r_.__value_.__r.__words[0];
    }
    if (*(char *)(a2 + 23) >= 0) {
      uint64_t v35 = (unsigned __int8 *)a2;
    }
    else {
      uint64_t v35 = *(unsigned __int8 **)a2;
    }
    *(_DWORD *)long long buf = 136446722;
    *(void *)&uint8_t buf[4] = v33;
    *(_WORD *)&unsigned char buf[12] = 2082;
    *(void *)&unsigned char buf[14] = v34;
    *(_WORD *)&unsigned char buf[22] = 2080;
    BOOL v65 = v35;
    _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, "#E Carrier error-code in TA [%{public}s] response: %{public}s for source iccid:%s", buf, 0x20u);
  }
  CFNumberRef v53 = 0;
  if (!*(unsigned char *)(a1 + 131) && *(unsigned char *)(a3 + 72))
  {
    if (*(char *)(a3 + 71) < 0)
    {
      sub_10004FC84(__p, *(void **)(a3 + 48), *(void *)(a3 + 56));
    }
    else
    {
      *(_OWORD *)std::string __p = *(_OWORD *)(a3 + 48);
      uint64_t v48 = *(void *)(a3 + 64);
    }
    if (SHIBYTE(v48) < 0)
    {
      sub_10004FC84(&__dst, __p[0], (unint64_t)__p[1]);
    }
    else
    {
      long long __dst = *(_OWORD *)__p;
      uint64_t v61 = v48;
    }
    std::string::size_type v63 = 0;
    if (SHIBYTE(v61) < 0)
    {
      sub_10004FC84(buf, (void *)__dst, *((unint64_t *)&__dst + 1));
    }
    else
    {
      *(_OWORD *)long long buf = __dst;
      *(void *)&uint8_t buf[16] = v61;
    }
    v55[0] = 0;
    if (ctu::cf::convert_copy())
    {
      int v37 = v63;
      std::string::size_type v63 = v55[0];
      v57[0] = v37;
      sub_1000558F4((const void **)v57);
    }
    if ((buf[23] & 0x80000000) != 0) {
      operator delete(*(void **)buf);
    }
    unint64_t v38 = v63;
    std::string::size_type v63 = 0;
    sub_1000558F4((const void **)&v63);
    if (SHIBYTE(v61) < 0) {
      operator delete((void *)__dst);
    }
    *(void *)long long buf = v53;
    std::string::size_type v52 = 0;
    CFNumberRef v53 = v38;
    sub_1000558F4((const void **)buf);
    sub_1000558F4(&v52);
    if (SHIBYTE(v48) < 0) {
      operator delete(__p[0]);
    }
  }
  sub_100093B44((std::string *)(v16 + 1480), &v59);
  LOBYTE(v55[0]) = 11;
  *(void *)long long buf = 0;
  *(void *)&long long __dst = 0;
  LODWORD(v57[0]) = v18;
  BYTE4(v57[0]) = 1;
  sub_100B3E598((void *)a1, (unsigned __int8 **)a2, (unsigned __int8 *)v55, 1, (const void **)buf, (char *)&v50, (const void **)&__dst, 7u, 1, (uint64_t)v57, &v49);
  sub_100057D78((const void **)&__dst);
  sub_1000558F4((const void **)buf);
  sub_1000558F4(&v53);
  if (SHIBYTE(v59.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v59.__r_.__value_.__l.__data_);
  }
}

void sub_100B60318(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,char a21,int a22,__int16 a23,char a24,char a25,uint64_t a26,void *a27,uint64_t a28,int a29,__int16 a30,char a31,char a32,uint64_t a33,void *__p,uint64_t a35,int a36,__int16 a37,char a38,char a39,uint64_t a40,void *a41,uint64_t a42,int a43,__int16 a44,char a45,char a46)
{
  if (a39 < 0) {
    operator delete(__p);
  }
  if (a46 < 0) {
    operator delete(a41);
  }
  if (*(char *)(v46 - 153) < 0) {
    operator delete(*(void **)(v46 - 176));
  }
  if (*(char *)(v46 - 105) < 0) {
    operator delete(*(void **)(v46 - 128));
  }
  _Unwind_Resume(exception_object);
}

void sub_100B604B4(void *a1, uint64_t a2)
{
  uint64_t v4 = a1[39];
  uint64_t v5 = sub_100B45F5C(a1[38], v4, (unsigned __int8 **)a2);
  if (v4 == v5)
  {
    uint64_t v6 = a1[5];
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      if (*(char *)(a2 + 23) >= 0) {
        int v7 = (unsigned __int8 *)a2;
      }
      else {
        int v7 = *(unsigned __int8 **)a2;
      }
      *(_DWORD *)long long buf = 136315138;
      uint64_t v11 = v7;
      _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "source iccid:%s already removed", buf, 0xCu);
    }
  }
  else
  {
    ++*(_DWORD *)(v5 + 1284);
    if (*(char *)(a2 + 23) < 0)
    {
      sub_10004FC84(__p, *(void **)a2, *(void *)(a2 + 8));
    }
    else
    {
      *(_OWORD *)std::string __p = *(_OWORD *)a2;
      uint64_t v9 = *(void *)(a2 + 16);
    }
    sub_100B5D858((uint64_t)a1, (unsigned __int8 **)__p, 5);
    if (SHIBYTE(v9) < 0) {
      operator delete(__p[0]);
    }
  }
}

void sub_100B605E0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
}

void sub_100B60604(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v6 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    int v7 = "Declined";
    if (a3) {
      int v7 = "Accepted";
    }
    if (*(char *)(a2 + 23) >= 0) {
      uint64_t v8 = (unsigned __int8 *)a2;
    }
    else {
      uint64_t v8 = *(unsigned __int8 **)a2;
    }
    *(_DWORD *)long long buf = 136446466;
    *(void *)&uint8_t buf[4] = v7;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&unsigned char buf[14] = v8;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Tc %{public}s by user for iccid: %s", buf, 0x16u);
  }
  uint64_t v9 = *(void *)(a1 + 312);
  uint64_t v10 = sub_100B45F5C(*(void *)(a1 + 304), v9, (unsigned __int8 **)a2);
  uint64_t v50 = v10;
  if (v9 != v10)
  {
    uint64_t v11 = v10;
    if (a3)
    {
      *(unsigned char *)(v10 + 1512) = 3;
      memset(&v45, 0, sizeof(v45));
      uint64_t v12 = v10 + 920;
      uint64_t v13 = (const std::string *)"agree";
    }
    else
    {
      if (*(unsigned char *)(a1 + 128) == 1)
      {
        uint64_t v16 = *(std::__shared_weak_count **)(a1 + 72);
        if (v16)
        {
          int v17 = std::__shared_weak_count::lock(v16);
          if (v17)
          {
            int v18 = v17;
            uint64_t v19 = *(void *)(a1 + 64);
            if (v19)
            {
              uint64_t v20 = *(void *)(v11 + 1032);
              uint64_t v21 = *(void *)(v11 + 1040);
              if (*(char *)(a2 + 23) < 0)
              {
                sub_10004FC84(__dst, *(void **)a2, *(void *)(a2 + 8));
              }
              else
              {
                *(_OWORD *)long long __dst = *(_OWORD *)a2;
                uint64_t v49 = *(void *)(a2 + 16);
              }
              uint64_t v22 = *(void *)(v11 + 1168);
              uint64_t v23 = *(void *)(v11 + 1176);
              if (*(char *)(v11 + 1279) < 0)
              {
                sub_10004FC84(__p, *(void **)(v11 + 1256), *(void *)(v11 + 1264));
              }
              else
              {
                *(_OWORD *)std::string __p = *(_OWORD *)(v11 + 1256);
                uint64_t v47 = *(void *)(v11 + 1272);
              }
              (*(void (**)(uint64_t, uint64_t, uint64_t, void **, uint64_t, uint64_t, void **, uint64_t))(*(void *)v19 + 24))(v19, v20, v21, __dst, v22, v23, __p, 2);
              if (SHIBYTE(v47) < 0) {
                operator delete(__p[0]);
              }
              if (SHIBYTE(v49) < 0) {
                operator delete(__dst[0]);
              }
            }
            sub_10004D2C8(v18);
          }
        }
      }
      *(unsigned char *)(v11 + 1512) = 4;
      memset(&v45, 0, sizeof(v45));
      uint64_t v12 = v11 + 944;
      uint64_t v13 = (const std::string *)"disagree";
    }
    if (*(char *)(v12 + 23) < 0) {
      sub_10004FC84(&v45, *(void **)v12, *(void *)(v12 + 8));
    }
    else {
      std::string v45 = *(std::string *)v12;
    }
    memset(v61, 0, sizeof(v61));
    memset(v60, 0, sizeof(v60));
    long long v58 = 0u;
    long long v59 = 0u;
    long long v56 = 0u;
    long long v57 = 0u;
    long long v54 = 0u;
    long long v55 = 0u;
    memset(buf, 0, sizeof(buf));
    sub_100093B44(v61, v13);
    sub_100093B44((std::string *)v60, &v45);
    if (*(char *)(a2 + 23) < 0)
    {
      sub_10004FC84(v43, *(void **)a2, *(void *)(a2 + 8));
    }
    else
    {
      *(_OWORD *)uint64_t v43 = *(_OWORD *)a2;
      uint64_t v44 = *(void *)(a2 + 16);
    }
    *(void *)&long long v37 = a1;
    uint64_t v24 = *(std::__shared_weak_count **)(a1 + 16);
    if (!v24 || (uint64_t v25 = *(void *)(a1 + 8), (v26 = std::__shared_weak_count::lock(v24)) == 0)) {
      sub_100088B9C();
    }
    *((void *)&v37 + 1) = v25;
    unint64_t v38 = v26;
    atomic_fetch_add_explicit(&v26->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v26);
    if (*(char *)(a2 + 23) < 0)
    {
      sub_10004FC84(&v39, *(void **)a2, *(void *)(a2 + 8));
    }
    else
    {
      long long v39 = *(_OWORD *)a2;
      uint64_t v40 = *(void *)(a2 + 16);
    }
    uint64_t v41 = v11;
    char v42 = a3;
    std::string::size_type v52 = 0;
    char v27 = (char *)operator new(0x48uLL);
    *(void *)char v27 = off_101A3FBD0;
    *(_OWORD *)(v27 + 8) = v37;
    *((void *)v27 + 3) = v38;
    *((void *)&v37 + 1) = 0;
    unint64_t v38 = 0;
    uint64_t v28 = v27 + 32;
    if (SHIBYTE(v40) < 0)
    {
      sub_10004FC84(v28, (void *)v39, *((unint64_t *)&v39 + 1));
    }
    else
    {
      *(_OWORD *)uint64_t v28 = v39;
      *((void *)v27 + 6) = v40;
    }
    *((void *)v27 + 7) = v41;
    v27[64] = v42;
    std::string::size_type v52 = v27;
    BOOL v29 = sub_100B588AC(a1, (uint64_t)v43, v11 + 896, (uint64_t)buf, 4, (uint64_t)v51);
    sub_100777F50(v51);
    if (SHIBYTE(v40) < 0) {
      operator delete((void *)v39);
    }
    if (v38) {
      std::__shared_weak_count::__release_weak(v38);
    }
    if (SHIBYTE(v44) < 0)
    {
      operator delete(v43[0]);
      if (v29) {
        goto LABEL_57;
      }
    }
    else if (v29)
    {
LABEL_57:
      sub_100B632F8((uint64_t)buf);
      if (SHIBYTE(v45.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v45.__r_.__value_.__l.__data_);
      }
      return;
    }
    if (a3)
    {
      v30[0] = 0;
      v30[272] = 0;
      sub_100B5F7E8(a1, a2, (uint64_t)v30, 4, 0);
      sub_100777C48((uint64_t)v30);
    }
    else
    {
      unsigned __int8 v36 = 11;
      uint64_t v35 = 0;
      char v34 = 45;
      uint64_t v33 = 0;
      int v31 = 70062;
      char v32 = 1;
      sub_100B3E598((void *)a1, (unsigned __int8 **)a2, &v36, 1, &v35, &v34, &v33, 4u, 1, (uint64_t)&v31, &v50);
      sub_100057D78(&v33);
      sub_1000558F4(&v35);
    }
    goto LABEL_57;
  }
  uint64_t v14 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
  {
    if (*(char *)(a2 + 23) >= 0) {
      uint64_t v15 = (unsigned __int8 *)a2;
    }
    else {
      uint64_t v15 = *(unsigned __int8 **)a2;
    }
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = v15;
    _os_log_error_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "source iccid:%s already removed", buf, 0xCu);
  }
}

void sub_100B60B54(_Unwind_Exception *a1)
{
  if (SLOBYTE(STACK[0x217]) < 0) {
    operator delete((void *)STACK[0x200]);
  }
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_100B60C54(void *a1, uint64_t a2, const std::string *a3)
{
  uint64_t v6 = a1[5];
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(buf[0]) = 0;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I User entered OTP", (uint8_t *)buf, 2u);
  }
  uint64_t v7 = a1[39];
  uint64_t v8 = sub_100B45F5C(a1[38], v7, (unsigned __int8 **)a2);
  uint64_t v45 = v8;
  if (v7 != v8)
  {
    uint64_t v9 = v8;
    unsigned int v10 = *(_DWORD *)(v8 + 1288) + 1;
    *(_DWORD *)(v8 + 1288) = v10;
    if (v10 >= 0xB)
    {
      uint64_t v11 = a1[5];
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(buf[0]) = 0;
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I Max otp submissions reached.", (uint8_t *)buf, 2u);
      }
      if (!*(unsigned char *)(v9 + 216)) {
        sub_10016C840();
      }
      if (*(char *)(v9 + 119) < 0)
      {
        sub_10004FC84(&__dst, *(void **)(v9 + 96), *(void *)(v9 + 104));
        if (!*(unsigned char *)(v9 + 216)) {
          sub_10016C840();
        }
      }
      else
      {
        long long __dst = *(_OWORD *)(v9 + 96);
        uint64_t v43 = *(void *)(v9 + 112);
      }
      if (*(char *)(v9 + 143) < 0)
      {
        sub_10004FC84(&v40, *(void **)(v9 + 120), *(void *)(v9 + 128));
        if (!*(unsigned char *)(v9 + 216)) {
          sub_10016C840();
        }
      }
      else
      {
        long long v40 = *(_OWORD *)(v9 + 120);
        uint64_t v41 = *(void *)(v9 + 136);
      }
      if (*(char *)(v9 + 167) < 0)
      {
        sub_10004FC84(&v38, *(void **)(v9 + 144), *(void *)(v9 + 152));
        if (!*(unsigned char *)(v9 + 216)) {
          sub_10016C840();
        }
      }
      else
      {
        long long v38 = *(_OWORD *)(v9 + 144);
        uint64_t v39 = *(void *)(v9 + 160);
      }
      if (*(char *)(v9 + 191) < 0)
      {
        sub_10004FC84(&v36, *(void **)(v9 + 168), *(void *)(v9 + 176));
      }
      else
      {
        long long v36 = *(_OWORD *)(v9 + 168);
        uint64_t v37 = *(void *)(v9 + 184);
      }
      if (*(char *)(a2 + 23) < 0)
      {
        sub_10004FC84(&__p, *(void **)a2, *(void *)(a2 + 8));
      }
      else
      {
        long long __p = *(_OWORD *)a2;
        uint64_t v35 = *(void *)(a2 + 16);
      }
      if (sub_100B51CA0((uint64_t)a1, (uint64_t)&__dst, (uint64_t)&v40, (uint64_t)&v38, (uint64_t)&v36, (uint64_t **)&__p)) {
        char v17 = 66;
      }
      else {
        char v17 = 65;
      }
      if (SHIBYTE(v35) < 0) {
        operator delete((void *)__p);
      }
      if (SHIBYTE(v37) < 0) {
        operator delete((void *)v36);
      }
      if (SHIBYTE(v39) < 0) {
        operator delete((void *)v38);
      }
      if (SHIBYTE(v41) < 0) {
        operator delete((void *)v40);
      }
      if (SHIBYTE(v43) < 0) {
        operator delete((void *)__dst);
      }
      char v44 = v17;
      unsigned __int8 v33 = 11;
      *(void *)&buf[0] = 0;
      char v32 = 0;
      int v30 = 70061;
      char v31 = 1;
      sub_100B3E598(a1, (unsigned __int8 **)a2, &v33, 1, (const void **)buf, &v44, &v32, 0xBu, 1, (uint64_t)&v30, &v45);
      sub_100057D78(&v32);
      sub_1000558F4((const void **)buf);
      return;
    }
    memset(v50, 0, 160);
    memset(v49, 0, sizeof(v49));
    memset(buf, 0, sizeof(buf));
    sub_100093B44((std::string *)v49, a3);
    sub_100093B44(v50, (const std::string *)(v9 + 1000));
    if (*(char *)(a2 + 23) < 0)
    {
      sub_10004FC84(&v28, *(void **)a2, *(void *)(a2 + 8));
    }
    else
    {
      long long v28 = *(_OWORD *)a2;
      uint64_t v29 = *(void *)(a2 + 16);
    }
    *(void *)&long long v23 = a1;
    uint64_t v14 = (std::__shared_weak_count *)a1[2];
    if (!v14 || (uint64_t v15 = a1[1], (v16 = std::__shared_weak_count::lock(v14)) == 0)) {
      sub_100088B9C();
    }
    *((void *)&v23 + 1) = v15;
    uint64_t v24 = v16;
    atomic_fetch_add_explicit(&v16->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v16);
    if (*(char *)(a2 + 23) < 0)
    {
      sub_10004FC84(&v25, *(void **)a2, *(void *)(a2 + 8));
    }
    else
    {
      long long v25 = *(_OWORD *)a2;
      uint64_t v26 = *(void *)(a2 + 16);
    }
    uint64_t v27 = v9;
    uint64_t v47 = 0;
    int v18 = (char *)operator new(0x40uLL);
    *(void *)int v18 = off_101A3FC50;
    *(_OWORD *)(v18 + 8) = v23;
    *((void *)v18 + 3) = v24;
    *((void *)&v23 + 1) = 0;
    uint64_t v24 = 0;
    uint64_t v19 = v18 + 32;
    if (SHIBYTE(v26) < 0)
    {
      sub_10004FC84(v19, (void *)v25, *((unint64_t *)&v25 + 1));
      uint64_t v20 = v27;
    }
    else
    {
      *(_OWORD *)uint64_t v19 = v25;
      *((void *)v18 + 6) = v26;
      uint64_t v20 = v9;
    }
    *((void *)v18 + 7) = v20;
    uint64_t v47 = v18;
    BOOL v21 = sub_100B588AC((uint64_t)a1, (uint64_t)&v28, v9 + 976, (uint64_t)buf, 7, (uint64_t)v46);
    sub_100777F50(v46);
    if (SHIBYTE(v26) < 0) {
      operator delete((void *)v25);
    }
    if (v24) {
      std::__shared_weak_count::__release_weak(v24);
    }
    if (SHIBYTE(v29) < 0)
    {
      operator delete((void *)v28);
      if (v21)
      {
LABEL_62:
        sub_100B632F8((uint64_t)buf);
        return;
      }
    }
    else if (v21)
    {
      goto LABEL_62;
    }
    v22[0] = 0;
    v22[272] = 0;
    sub_100B5F7E8((uint64_t)a1, a2, (uint64_t)v22, 7, 0);
    sub_100777C48((uint64_t)v22);
    goto LABEL_62;
  }
  uint64_t v12 = a1[5];
  if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
  {
    if (*(char *)(a2 + 23) >= 0) {
      uint64_t v13 = (unsigned __int8 *)a2;
    }
    else {
      uint64_t v13 = *(unsigned __int8 **)a2;
    }
    LODWORD(buf[0]) = 136315138;
    *(void *)((char *)buf + 4) = v13;
    _os_log_error_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "source iccid:%s already removed", (uint8_t *)buf, 0xCu);
  }
}

void sub_100B611B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,char a47,uint64_t a48,std::__shared_weak_count *a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,void *__p,uint64_t a56,int a57,__int16 a58,char a59,char a60)
{
  char v62 = (std::__shared_weak_count *)v60[3];
  if (v62) {
    std::__shared_weak_count::__release_weak(v62);
  }
  operator delete(v60);
  sub_100B49710((uint64_t)&a47);
  if (a60 < 0) {
    operator delete(__p);
  }
  sub_100B632F8((uint64_t)&STACK[0x270]);
  _Unwind_Resume(a1);
}

uint64_t sub_100B612E0()
{
  return 2;
}

void *sub_100B612E8(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t sub_100B6136C(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 56))
  {
    sub_100057D78((const void **)(a1 + 40));
    sub_1000558F4((const void **)(a1 + 32));
    if (*(char *)(a1 + 31) < 0) {
      operator delete(*(void **)(a1 + 8));
    }
  }
  return a1;
}

void sub_100B613B8(void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  if (v2)
  {
    uint64_t v4 = (uint64_t)v1[1];
    uint64_t v5 = v2;
    if ((void *)v4 != v2)
    {
      do
        uint64_t v4 = sub_100B615AC(v4 - 1520);
      while ((void *)v4 != v2);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void sub_100B6143C(void *a1)
{
  if (a1)
  {
    sub_100B6143C(*a1);
    sub_100B6143C(a1[1]);
    sub_100B61490((uint64_t)(a1 + 4));
    operator delete(a1);
  }
}

void sub_100B61490(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 88) && *(char *)(a1 + 87) < 0) {
    operator delete(*(void **)(a1 + 64));
  }
  if (*(char *)(a1 + 47) < 0) {
    operator delete(*(void **)(a1 + 24));
  }
  if (*(char *)(a1 + 23) < 0)
  {
    uint64_t v2 = *(void **)a1;
    operator delete(v2);
  }
}

void sub_100B61500(uint64_t a1, uint64_t a2)
{
  if (*(unsigned __int8 *)(a1 + 24) == *(unsigned __int8 *)(a2 + 24))
  {
    if (*(unsigned char *)(a1 + 24))
    {
      sub_1006347E0(a1, (void *)a2);
    }
  }
  else if (*(unsigned char *)(a1 + 24))
  {
    sub_10005CD2C(a1, *(char **)(a1 + 8));
    *(unsigned char *)(a1 + 24) = 0;
  }
  else
  {
    *(void *)a1 = *(void *)a2;
    uint64_t v3 = (void *)(a2 + 8);
    uint64_t v4 = *(void *)(a2 + 8);
    *(void *)(a1 + 8) = v4;
    uint64_t v5 = a1 + 8;
    uint64_t v6 = *(void *)(a2 + 16);
    *(void *)(a1 + 16) = v6;
    if (v6)
    {
      *(void *)(v4 + 16) = v5;
      *(void *)a2 = v3;
      void *v3 = 0;
      *(void *)(a2 + 16) = 0;
    }
    else
    {
      *(void *)a1 = v5;
    }
    *(unsigned char *)(a1 + 24) = 1;
  }
}

uint64_t sub_100B615AC(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 1504) && *(char *)(a1 + 1503) < 0) {
    operator delete(*(void **)(a1 + 1480));
  }
  if (*(char *)(a1 + 1447) < 0) {
    operator delete(*(void **)(a1 + 1424));
  }
  if (*(unsigned char *)(a1 + 1408) && *(char *)(a1 + 1407) < 0) {
    operator delete(*(void **)(a1 + 1384));
  }
  if (*(unsigned char *)(a1 + 1376) && *(char *)(a1 + 1375) < 0) {
    operator delete(*(void **)(a1 + 1352));
  }
  if (*(unsigned char *)(a1 + 1344) && *(char *)(a1 + 1343) < 0) {
    operator delete(*(void **)(a1 + 1320));
  }
  uint64_t v3 = (void **)(a1 + 1296);
  sub_1001A010C(&v3);
  if (*(char *)(a1 + 1279) < 0) {
    operator delete(*(void **)(a1 + 1256));
  }
  if (*(char *)(a1 + 1255) < 0) {
    operator delete(*(void **)(a1 + 1232));
  }
  if (*(char *)(a1 + 1231) < 0) {
    operator delete(*(void **)(a1 + 1208));
  }
  if (*(char *)(a1 + 1207) < 0) {
    operator delete(*(void **)(a1 + 1184));
  }
  if (*(char *)(a1 + 1167) < 0) {
    operator delete(*(void **)(a1 + 1144));
  }
  if (*(char *)(a1 + 1143) < 0) {
    operator delete(*(void **)(a1 + 1120));
  }
  if (*(char *)(a1 + 1119) < 0) {
    operator delete(*(void **)(a1 + 1096));
  }
  if (*(char *)(a1 + 1095) < 0) {
    operator delete(*(void **)(a1 + 1072));
  }
  if (*(char *)(a1 + 1071) < 0) {
    operator delete(*(void **)(a1 + 1048));
  }
  sub_10013E528(a1 + 976);
  sub_1002B24B0(a1 + 896);
  if (*(unsigned char *)(a1 + 888)) {
    sub_1000C5578(a1 + 632);
  }
  if (*(unsigned char *)(a1 + 624)) {
    sub_1000C54EC(a1 + 224);
  }
  if (*(unsigned char *)(a1 + 216)) {
    sub_1000C584C(a1);
  }
  return a1;
}

void sub_100B61728(void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (char *)**a1;
  if (v2)
  {
    uint64_t v4 = (char *)v1[1];
    uint64_t v5 = **a1;
    if (v4 != v2)
    {
      uint64_t v6 = v4 - 40;
      uint64_t v7 = v4 - 40;
      uint64_t v8 = v4 - 40;
      do
      {
        uint64_t v9 = *(void (***)(char *))v8;
        v8 -= 40;
        (*v9)(v7);
        v6 -= 40;
        BOOL v10 = v7 == v2;
        uint64_t v7 = v8;
      }
      while (!v10);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t sub_100B617E8(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = sub_1003DABB4((unsigned char *)a1, a2);
  v4[224] = 0;
  v4[624] = 0;
  if (*(unsigned char *)(a2 + 624))
  {
    sub_1003126AC(v4 + 224, (long long *)(a2 + 224));
    *(unsigned char *)(a1 + 624) = 1;
  }
  sub_10030D9BC((char *)(a1 + 632), a2 + 632);
  *(unsigned char *)(a1 + 896) = 0;
  *(unsigned char *)(a1 + 968) = 0;
  if (*(unsigned char *)(a2 + 968))
  {
    if (*(char *)(a2 + 919) < 0)
    {
      sub_10004FC84((unsigned char *)(a1 + 896), *(void **)(a2 + 896), *(void *)(a2 + 904));
    }
    else
    {
      long long v5 = *(_OWORD *)(a2 + 896);
      *(void *)(a1 + 912) = *(void *)(a2 + 912);
      *(_OWORD *)(a1 + 896) = v5;
    }
    if (*(char *)(a2 + 943) < 0)
    {
      sub_10004FC84((unsigned char *)(a1 + 920), *(void **)(a2 + 920), *(void *)(a2 + 928));
    }
    else
    {
      long long v6 = *(_OWORD *)(a2 + 920);
      *(void *)(a1 + 936) = *(void *)(a2 + 936);
      *(_OWORD *)(a1 + 920) = v6;
    }
    uint64_t v7 = (unsigned char *)(a1 + 944);
    if (*(char *)(a2 + 967) < 0)
    {
      sub_10004FC84(v7, *(void **)(a2 + 944), *(void *)(a2 + 952));
    }
    else
    {
      long long v8 = *(_OWORD *)(a2 + 944);
      *(void *)(a1 + 960) = *(void *)(a2 + 960);
      *(_OWORD *)uint64_t v7 = v8;
    }
    *(unsigned char *)(a1 + 968) = 1;
  }
  *(unsigned char *)(a1 + 976) = 0;
  *(unsigned char *)(a1 + 1024) = 0;
  if (*(unsigned char *)(a2 + 1024))
  {
    if (*(char *)(a2 + 999) < 0)
    {
      sub_10004FC84((unsigned char *)(a1 + 976), *(void **)(a2 + 976), *(void *)(a2 + 984));
    }
    else
    {
      long long v9 = *(_OWORD *)(a2 + 976);
      *(void *)(a1 + 992) = *(void *)(a2 + 992);
      *(_OWORD *)(a1 + 976) = v9;
    }
    BOOL v10 = (unsigned char *)(a1 + 1000);
    if (*(char *)(a2 + 1023) < 0)
    {
      sub_10004FC84(v10, *(void **)(a2 + 1000), *(void *)(a2 + 1008));
    }
    else
    {
      long long v11 = *(_OWORD *)(a2 + 1000);
      *(void *)(a1 + 1016) = *(void *)(a2 + 1016);
      *(_OWORD *)BOOL v10 = v11;
    }
    *(unsigned char *)(a1 + 1024) = 1;
  }
  *(_OWORD *)(a1 + 1032) = *(_OWORD *)(a2 + 1032);
  if (*(char *)(a2 + 1071) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 1048), *(void **)(a2 + 1048), *(void *)(a2 + 1056));
  }
  else
  {
    long long v12 = *(_OWORD *)(a2 + 1048);
    *(void *)(a1 + 1064) = *(void *)(a2 + 1064);
    *(_OWORD *)(a1 + 1048) = v12;
  }
  if (*(char *)(a2 + 1095) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 1072), *(void **)(a2 + 1072), *(void *)(a2 + 1080));
  }
  else
  {
    long long v13 = *(_OWORD *)(a2 + 1072);
    *(void *)(a1 + 1088) = *(void *)(a2 + 1088);
    *(_OWORD *)(a1 + 1072) = v13;
  }
  if (*(char *)(a2 + 1119) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 1096), *(void **)(a2 + 1096), *(void *)(a2 + 1104));
  }
  else
  {
    long long v14 = *(_OWORD *)(a2 + 1096);
    *(void *)(a1 + 1112) = *(void *)(a2 + 1112);
    *(_OWORD *)(a1 + 1096) = v14;
  }
  if (*(char *)(a2 + 1143) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 1120), *(void **)(a2 + 1120), *(void *)(a2 + 1128));
  }
  else
  {
    long long v15 = *(_OWORD *)(a2 + 1120);
    *(void *)(a1 + 1136) = *(void *)(a2 + 1136);
    *(_OWORD *)(a1 + 1120) = v15;
  }
  if (*(char *)(a2 + 1167) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 1144), *(void **)(a2 + 1144), *(void *)(a2 + 1152));
  }
  else
  {
    long long v16 = *(_OWORD *)(a2 + 1144);
    *(void *)(a1 + 1160) = *(void *)(a2 + 1160);
    *(_OWORD *)(a1 + 1144) = v16;
  }
  *(_OWORD *)(a1 + 1168) = *(_OWORD *)(a2 + 1168);
  if (*(char *)(a2 + 1207) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 1184), *(void **)(a2 + 1184), *(void *)(a2 + 1192));
  }
  else
  {
    long long v17 = *(_OWORD *)(a2 + 1184);
    *(void *)(a1 + 1200) = *(void *)(a2 + 1200);
    *(_OWORD *)(a1 + 1184) = v17;
  }
  if (*(char *)(a2 + 1231) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 1208), *(void **)(a2 + 1208), *(void *)(a2 + 1216));
  }
  else
  {
    long long v18 = *(_OWORD *)(a2 + 1208);
    *(void *)(a1 + 1224) = *(void *)(a2 + 1224);
    *(_OWORD *)(a1 + 1208) = v18;
  }
  if (*(char *)(a2 + 1255) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 1232), *(void **)(a2 + 1232), *(void *)(a2 + 1240));
  }
  else
  {
    long long v19 = *(_OWORD *)(a2 + 1232);
    *(void *)(a1 + 1248) = *(void *)(a2 + 1248);
    *(_OWORD *)(a1 + 1232) = v19;
  }
  if (*(char *)(a2 + 1279) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 1256), *(void **)(a2 + 1256), *(void *)(a2 + 1264));
  }
  else
  {
    long long v20 = *(_OWORD *)(a2 + 1256);
    *(void *)(a1 + 1272) = *(void *)(a2 + 1272);
    *(_OWORD *)(a1 + 1256) = v20;
  }
  uint64_t v21 = *(void *)(a2 + 1280);
  *(_DWORD *)(a1 + 1288) = *(_DWORD *)(a2 + 1288);
  *(void *)(a1 + 1280) = v21;
  sub_10030DBE4(a1 + 1296, a2 + 1296);
  long long v22 = *(_OWORD *)(a2 + 1448);
  *(_OWORD *)(a1 + 1461) = *(_OWORD *)(a2 + 1461);
  *(_OWORD *)(a1 + 1448) = v22;
  sub_1000593FC(a1 + 1480, (long long *)(a2 + 1480));
  __int16 v23 = *(_WORD *)(a2 + 1512);
  *(unsigned char *)(a1 + 1514) = *(unsigned char *)(a2 + 1514);
  *(_WORD *)(a1 + 1512) = v23;
  return a1;
}

void sub_100B61BF8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void **a12, uint64_t a13, uint64_t a14)
{
  if ((char)v14[999] < 0) {
    operator delete(*a12);
  }
  sub_10013E528((uint64_t)a12);
  sub_1002B24B0(a14);
  if (v14[888]) {
    sub_1000C5578(a11);
  }
  if (v14[624]) {
    sub_1000C54EC(a13);
  }
  if (v14[216]) {
    sub_1000C584C((uint64_t)v14);
  }
  _Unwind_Resume(a1);
}

uint64_t *sub_100B61D94(uint64_t *result, void *a2)
{
  uint64_t v3 = result;
  uint64_t v5 = *result;
  uint64_t v4 = result[1];
  uint64_t v6 = a2[1];
  if (v4 == *result)
  {
    uint64_t v7 = a2[1];
  }
  else
  {
    do
    {
      uint64_t v7 = v6 - 56;
      uint64_t v8 = v4 - 56;
      long long v9 = *(_OWORD *)(v4 - 56);
      *(void *)(v6 - 40) = *(void *)(v4 - 40);
      *(_OWORD *)(v6 - 56) = v9;
      *(void *)(v4 - 48) = 0;
      *(void *)(v4 - 40) = 0;
      *(void *)(v4 - 56) = 0;
      CFStringRef result = sub_1009515A0((void *)(v6 - 32), (void (**)(uint64_t))(v4 - 32));
      uint64_t v4 = v8;
      uint64_t v6 = v7;
    }
    while (v8 != v5);
  }
  a2[1] = v7;
  uint64_t v10 = *v3;
  uint64_t *v3 = v7;
  a2[1] = v10;
  uint64_t v11 = v3[1];
  v3[1] = a2[2];
  a2[2] = v11;
  uint64_t v12 = v3[2];
  v3[2] = a2[3];
  a2[3] = v12;
  *a2 = a2[1];
  return result;
}

uint64_t sub_100B61E54(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 56;
    sub_100333C4C(i - 56);
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t sub_100B61EA4(uint64_t *a1, uint64_t a2)
{
  uint64_t v3 = *a1;
  uint64_t v4 = 0x6DB6DB6DB6DB6DB7 * ((a1[1] - *a1) >> 3);
  unint64_t v5 = v4 + 1;
  if ((unint64_t)(v4 + 1) > 0x492492492492492) {
    sub_10006A748();
  }
  uint64_t v7 = (uint64_t)(a1 + 2);
  unint64_t v8 = 0x6DB6DB6DB6DB6DB7 * ((a1[2] - v3) >> 3);
  if (2 * v8 > v5) {
    unint64_t v5 = 2 * v8;
  }
  if (v8 >= 0x249249249249249) {
    unint64_t v9 = 0x492492492492492;
  }
  else {
    unint64_t v9 = v5;
  }
  long long v19 = a1 + 2;
  if (v9) {
    uint64_t v10 = (char *)sub_100341ECC(v7, v9);
  }
  else {
    uint64_t v10 = 0;
  }
  long long v15 = v10;
  long long v16 = &v10[56 * v4];
  long long v17 = v16;
  long long v18 = &v10[56 * v9];
  sub_100058DB0(v16, *(char **)a2);
  uint64_t v11 = v16;
  *((void *)v16 + 3) = 0;
  *((void *)v11 + 4) = 0;
  long long v12 = *(_OWORD *)(a2 + 8);
  *((void *)v11 + 6) = *(void *)(a2 + 24);
  *((_OWORD *)v11 + 2) = v12;
  *(void *)(a2 + 16) = 0;
  *(void *)(a2 + 24) = 0;
  *(void *)(a2 + 8) = 0;
  *((void *)v11 + 3) = sub_100333A04;
  v17 += 56;
  sub_100B61D94(a1, &v15);
  uint64_t v13 = a1[1];
  sub_100B61E54((uint64_t)&v15);
  return v13;
}

void sub_100B61FE4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100B61E54((uint64_t)va);
  _Unwind_Resume(a1);
}

_UNKNOWN **sub_100B61FF8(unsigned int a1, uint64_t a2, uint64_t a3, uint64_t a4, void *a5)
{
  uint64_t v5 = a1;
  switch(v5)
  {
    case 1:
      CFStringRef result = 0;
      *(_OWORD *)(a3 + 8) = *(_OWORD *)(a2 + 8);
      *(void *)a3 = sub_100B61FF8;
      break;
    case 2:
      CFStringRef result = 0;
      *(_OWORD *)(a3 + 8) = *(_OWORD *)(a2 + 8);
      *(void *)a3 = sub_100B61FF8;
      goto LABEL_5;
    case 3:
      if (a4) {
      else
      }
        BOOL v8 = a5 == &unk_101546768;
      if (v8) {
        CFStringRef result = (_UNKNOWN **)(a2 + 8);
      }
      else {
        CFStringRef result = 0;
      }
      break;
    case 4:
      return result;
    default:
      CFStringRef result = 0;
LABEL_5:
      *(void *)a2 = 0;
      break;
  }
  return result;
}

void *sub_100B620D8(void *__dst, long long *a2)
{
  if (*((char *)a2 + 23) < 0)
  {
    sub_10004FC84(__dst, *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v3 = *a2;
    xpc_object_t __dst[2] = *((void *)a2 + 2);
    *(_OWORD *)long long __dst = v3;
  }
  *((unsigned char *)__dst + 24) = 0;
  *((unsigned char *)__dst + 48) = 0;
  *((unsigned char *)__dst + 56) = 0;
  *((unsigned char *)__dst + 80) = 0;
  *((_WORD *)__dst + 44) = 0;
  return __dst;
}

void sub_100B6213C(char **a1, std::string *__str, std::string *a3)
{
  uint64_t v4 = __str;
  uint64_t v6 = *a1;
  if (a1[2] == *a1)
  {
    sub_1003110D0((void **)a1);
    unint64_t v9 = 0x5555555555555556 * ((a1[2] - *a1) >> 5);
    if (v9 <= 1) {
      unint64_t v9 = 1;
    }
    if (0xAAAAAAAAAAAAAAABLL * ((a1[2] - *a1) >> 5) >= 0x155555555555555) {
      unint64_t v10 = 0x2AAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v10 = v9;
    }
    sub_10019FF04(a1, v10);
    uint64_t v11 = sub_100B62290((uint64_t)v4, (uint64_t)a3, (uint64_t)a1[1]);
    goto LABEL_14;
  }
  uint64_t v7 = (uint64_t)a1[1];
  if ((char *)v7 == v6)
  {
    uint64_t v11 = sub_100B62290((uint64_t)__str, (uint64_t)a3, (uint64_t)v6);
LABEL_14:
    a1[1] = (char *)v11;
    return;
  }
  if (__str == a3)
  {
    BOOL v8 = *a1;
  }
  else
  {
    BOOL v8 = *a1;
    do
    {
      std::string::operator=((std::string *)v6, v4);
      sub_100179AF8((std::string *)v6 + 1, v4 + 1);
      sub_100179AF8((std::string *)(v6 + 56), (std::string *)((char *)v4 + 56));
      *((_WORD *)v6 + 44) = v4[3].__r_.__value_.__r.__words[2];
      v8 += 96;
      v4 += 4;
      v6 += 96;
    }
    while (v4 != a3);
    uint64_t v7 = (uint64_t)a1[1];
  }
  while ((char *)v7 != v8)
  {
    v7 -= 96;
    sub_1001A0094(v7);
  }
  a1[1] = v8;
}

void sub_100B62284(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

uint64_t sub_100B62290(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a1 != a2)
  {
    uint64_t v6 = 0;
    do
    {
      uint64_t v7 = a3 + v6;
      BOOL v8 = (long long *)(a1 + v6);
      if (*(char *)(a1 + v6 + 23) < 0)
      {
        sub_10004FC84((unsigned char *)v7, *(void **)v8, *((void *)v8 + 1));
      }
      else
      {
        long long v9 = *v8;
        *(void *)(v7 + 16) = *((void *)v8 + 2);
        *(_OWORD *)uint64_t v7 = v9;
      }
      sub_1000593FC(a3 + v6 + 24, (long long *)(a1 + v6 + 24));
      sub_1000593FC(a3 + v6 + 56, (long long *)(a1 + v6 + 56));
      *(_WORD *)(a3 + v6 + 88) = *(_WORD *)(a1 + v6 + 88);
      v6 += 96;
    }
    while (a1 + v6 != a2);
    a3 += v6;
  }
  return a3;
}

void sub_100B62348(_Unwind_Exception *exception_object)
{
  if (v2)
  {
    uint64_t v4 = v1 - 96;
    do
    {
      sub_1001A0094(v4 + v2);
      v2 -= 96;
    }
    while (v2);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100B623AC(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 72);
  if (v2) {
    sub_10004D2C8(v2);
  }
  sub_100057D78((const void **)(a1 + 48));
  sub_1000558F4((const void **)(a1 + 40));
  if (*(char *)(a1 + 39) < 0) {
    operator delete(*(void **)(a1 + 16));
  }
  long long v3 = *(std::__shared_weak_count **)(a1 + 8);
  if (v3) {
    sub_10004D2C8(v3);
  }
  return a1;
}

uint64_t sub_100B62408(uint64_t a1)
{
  *(void *)a1 = off_101A3E750;
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 80);
  if (v2) {
    sub_10004D2C8(v2);
  }
  sub_100057D78((const void **)(a1 + 56));
  sub_1000558F4((const void **)(a1 + 48));
  if (*(char *)(a1 + 47) < 0) {
    operator delete(*(void **)(a1 + 24));
  }
  long long v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (v3) {
    sub_10004D2C8(v3);
  }
  return a1;
}

void sub_100B62480(uint64_t a1)
{
  *(void *)a1 = off_101A3E750;
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 80);
  if (v2) {
    sub_10004D2C8(v2);
  }
  sub_100057D78((const void **)(a1 + 56));
  sub_1000558F4((const void **)(a1 + 48));
  if (*(char *)(a1 + 47) < 0) {
    operator delete(*(void **)(a1 + 24));
  }
  long long v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (v3) {
    sub_10004D2C8(v3);
  }

  operator delete();
}

void *sub_100B62518(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t v2 = operator new(0x58uLL);
  void *v2 = off_101A3E750;
  sub_100B62918((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_100B6256C(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100B62580(uint64_t a1, void *a2)
{
  *a2 = off_101A3E750;
  return sub_100B62918((uint64_t)(a2 + 1), a1 + 8);
}

void sub_100B625AC(uint64_t a1)
{
}

void sub_100B625B4(void *a1)
{
  sub_100B629D4((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_100B625F0(uint64_t a1, unsigned __int8 *a2)
{
  int v3 = *a2;
  uint64_t v4 = (const char *)kCtLoggingSystemName;
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&buf, kCtLoggingSystemName, "cp.tr.ctr");
  uint64_t v5 = *((void *)&buf + 1);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&buf);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v6 = "succeed";
    if (!v3) {
      uint64_t v6 = "failed";
    }
    LODWORD(buf) = 136315138;
    *(void *)((char *)&buf + 4) = v6;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "launch websheet %s", (uint8_t *)&buf, 0xCu);
  }
  if (!v3)
  {
    if (!*(void *)(a1 + 8) || *(unsigned char *)(a1 + 64))
    {
      if (*(void *)(a1 + 72))
      {
        ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&buf, v4, "cp.tr.ctr");
        long long v9 = *((void *)&buf + 1);
        ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&buf);
        if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(buf) = 0;
          _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "Showing failed transfer popup.", (uint8_t *)&buf, 2u);
        }
        (*(void (**)(void, void, uint64_t))(**(void **)(a1 + 72) + 128))(*(void *)(a1 + 72), *(unsigned __int8 *)(a1 + 64), a1 + 24);
      }
      else
      {
        ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&buf, v4, "cp.tr.ctr");
        unint64_t v10 = *((void *)&buf + 1);
        ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&buf);
        if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
        {
          LOWORD(buf) = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "Delegate not available. Unable to show failed transfer popup", (uint8_t *)&buf, 2u);
        }
      }
    }
    else
    {
      ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&buf, v4, "cp.tr.ctr");
      uint64_t v7 = *((void *)&buf + 1);
      ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&buf);
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(buf) = 0;
        _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "create followup in case inline launch websheet failure.", (uint8_t *)&buf, 2u);
      }
      BOOL v8 = *(std::__shared_weak_count **)(a1 + 16);
      *(void *)&long long buf = *(void *)(a1 + 8);
      *((void *)&buf + 1) = v8;
      if (v8) {
        atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      sub_100083DA4(&v12, (const void **)(a1 + 48));
      sub_100058198(&v11, (const void **)(a1 + 56));
      sub_100B523F0(&buf, a1 + 24, (CFStringRef *)&v12);
      sub_100057D78(&v11);
      sub_1000558F4(&v12);
      if (v8) {
        sub_10004D2C8(v8);
      }
    }
  }
}

void sub_100B6289C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, const void *a10)
{
  sub_100057D78(&a9);
  sub_1000558F4(&a10);
  if (v10) {
    sub_10004D2C8(v10);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100B628CC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100B6290C()
{
}

uint64_t sub_100B62918(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 8);
  *(void *)a1 = *(void *)a2;
  *(void *)(a1 + 8) = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v5 = (unsigned char *)(a1 + 16);
  if (*(char *)(a2 + 39) < 0)
  {
    sub_10004FC84(v5, *(void **)(a2 + 16), *(void *)(a2 + 24));
  }
  else
  {
    long long v6 = *(_OWORD *)(a2 + 16);
    *(void *)(a1 + 32) = *(void *)(a2 + 32);
    *(_OWORD *)uint64_t v5 = v6;
  }
  sub_100083DA4((const void **)(a1 + 40), (const void **)(a2 + 40));
  sub_100058198((const void **)(a1 + 48), (const void **)(a2 + 48));
  *(unsigned char *)(a1 + 56) = *(unsigned char *)(a2 + 56);
  uint64_t v7 = *(void *)(a2 + 72);
  *(void *)(a1 + 64) = *(void *)(a2 + 64);
  *(void *)(a1 + 72) = v7;
  if (v7) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v7 + 8), 1uLL, memory_order_relaxed);
  }
  return a1;
}

void sub_100B629BC(_Unwind_Exception *exception_object)
{
  int v3 = *(std::__shared_weak_count **)(v1 + 8);
  if (v3) {
    sub_10004D2C8(v3);
  }
  _Unwind_Resume(exception_object);
}

void sub_100B629D4(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 72);
  if (v2) {
    sub_10004D2C8(v2);
  }
  sub_100057D78((const void **)(a1 + 48));
  sub_1000558F4((const void **)(a1 + 40));
  if (*(char *)(a1 + 39) < 0) {
    operator delete(*(void **)(a1 + 16));
  }
  int v3 = *(std::__shared_weak_count **)(a1 + 8);
  if (v3)
  {
    sub_10004D2C8(v3);
  }
}

uint64_t sub_100B62A44(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a1 != a2)
  {
    uint64_t v5 = a1;
    do
    {
      sub_100B62A9C(a3, v5);
      v5 += 1520;
      a3 += 1520;
    }
    while (v5 != a2);
  }
  return a3;
}

uint64_t sub_100B62A9C(uint64_t a1, uint64_t a2)
{
  sub_10048DF0C(a1, a2);
  uint64_t v4 = (char *)(a1 + 224);
  uint64_t v5 = (long long *)(a2 + 224);
  if (*(unsigned __int8 *)(a1 + 624) == *(unsigned __int8 *)(a2 + 624))
  {
    if (*(unsigned char *)(a1 + 624)) {
      sub_100312ECC((uint64_t)v4, (uint64_t)v5);
    }
  }
  else if (*(unsigned char *)(a1 + 624))
  {
    sub_1000C54EC((uint64_t)v4);
    *(unsigned char *)(a1 + 624) = 0;
  }
  else
  {
    sub_1003126AC(v4, v5);
    *(unsigned char *)(a1 + 624) = 1;
  }
  uint64_t v6 = a1 + 632;
  uint64_t v7 = (long long *)(a2 + 632);
  if (*(unsigned __int8 *)(a1 + 888) == *(unsigned __int8 *)(a2 + 888))
  {
    if (*(unsigned char *)(a1 + 888)) {
      sub_100B62F98(v6, v7);
    }
  }
  else if (*(unsigned char *)(a1 + 888))
  {
    sub_1000C5578(v6);
    *(unsigned char *)(a1 + 888) = 0;
  }
  else
  {
    sub_1003300C4(v6, v7);
    *(unsigned char *)(a1 + 888) = 1;
  }
  BOOL v8 = (void **)(a1 + 896);
  long long v9 = (long long *)(a2 + 896);
  if (*(unsigned __int8 *)(a1 + 968) == *(unsigned __int8 *)(a2 + 968))
  {
    if (*(unsigned char *)(a1 + 968))
    {
      if (*(char *)(a1 + 919) < 0) {
        operator delete(*v8);
      }
      long long v10 = *v9;
      *(void *)(a1 + 912) = *(void *)(a2 + 912);
      *(_OWORD *)BOOL v8 = v10;
      *(unsigned char *)(a2 + 919) = 0;
      *(unsigned char *)(a2 + 896) = 0;
      uint64_t v11 = (void **)(a1 + 920);
      if (*(char *)(a1 + 943) < 0) {
        operator delete(*v11);
      }
      long long v12 = *(_OWORD *)(a2 + 920);
      *(void *)(a1 + 936) = *(void *)(a2 + 936);
      *(_OWORD *)uint64_t v11 = v12;
      *(unsigned char *)(a2 + 943) = 0;
      *(unsigned char *)(a2 + 920) = 0;
      uint64_t v13 = (void **)(a1 + 944);
      if (*(char *)(a1 + 967) < 0) {
        operator delete(*v13);
      }
      long long v14 = *(_OWORD *)(a2 + 944);
      *(void *)(a1 + 960) = *(void *)(a2 + 960);
      *(_OWORD *)uint64_t v13 = v14;
      *(unsigned char *)(a2 + 967) = 0;
      *(unsigned char *)(a2 + 944) = 0;
    }
  }
  else if (*(unsigned char *)(a1 + 968))
  {
    if (*(char *)(a1 + 967) < 0) {
      operator delete(*(void **)(a1 + 944));
    }
    if (*(char *)(a1 + 943) < 0) {
      operator delete(*(void **)(a1 + 920));
    }
    if (*(char *)(a1 + 919) < 0) {
      operator delete(*v8);
    }
    *(unsigned char *)(a1 + 968) = 0;
  }
  else
  {
    long long v15 = *v9;
    *(void *)(a1 + 912) = *(void *)(a2 + 912);
    *(_OWORD *)BOOL v8 = v15;
    *(void *)(a2 + 904) = 0;
    *(void *)(a2 + 912) = 0;
    *(void *)long long v9 = 0;
    long long v16 = *(_OWORD *)(a2 + 920);
    *(void *)(a1 + 936) = *(void *)(a2 + 936);
    *(_OWORD *)(a1 + 920) = v16;
    *(void *)(a2 + 936) = 0;
    *(void *)(a2 + 928) = 0;
    *(void *)(a2 + 920) = 0;
    long long v17 = *(_OWORD *)(a2 + 944);
    *(void *)(a1 + 960) = *(void *)(a2 + 960);
    *(_OWORD *)(a1 + 944) = v17;
    *(void *)(a2 + 960) = 0;
    *(void *)(a2 + 952) = 0;
    *(void *)(a2 + 944) = 0;
    *(unsigned char *)(a1 + 968) = 1;
  }
  long long v18 = (void **)(a1 + 976);
  long long v19 = (long long *)(a2 + 976);
  if (*(unsigned __int8 *)(a1 + 1024) == *(unsigned __int8 *)(a2 + 1024))
  {
    if (*(unsigned char *)(a1 + 1024))
    {
      if (*(char *)(a1 + 999) < 0) {
        operator delete(*v18);
      }
      long long v20 = *v19;
      *(void *)(a1 + 992) = *(void *)(a2 + 992);
      *(_OWORD *)long long v18 = v20;
      *(unsigned char *)(a2 + 999) = 0;
      *(unsigned char *)(a2 + 976) = 0;
      uint64_t v21 = (void **)(a1 + 1000);
      if (*(char *)(a1 + 1023) < 0) {
        operator delete(*v21);
      }
      long long v22 = *(_OWORD *)(a2 + 1000);
      *(void *)(a1 + 1016) = *(void *)(a2 + 1016);
      *(_OWORD *)uint64_t v21 = v22;
      *(unsigned char *)(a2 + 1023) = 0;
      *(unsigned char *)(a2 + 1000) = 0;
    }
  }
  else if (*(unsigned char *)(a1 + 1024))
  {
    if (*(char *)(a1 + 1023) < 0) {
      operator delete(*(void **)(a1 + 1000));
    }
    if (*(char *)(a1 + 999) < 0) {
      operator delete(*v18);
    }
    *(unsigned char *)(a1 + 1024) = 0;
  }
  else
  {
    long long v23 = *v19;
    *(void *)(a1 + 992) = *(void *)(a2 + 992);
    *(_OWORD *)long long v18 = v23;
    *(void *)(a2 + 984) = 0;
    *(void *)(a2 + 992) = 0;
    *(void *)long long v19 = 0;
    long long v24 = *(_OWORD *)(a2 + 1000);
    *(void *)(a1 + 1016) = *(void *)(a2 + 1016);
    *(_OWORD *)(a1 + 1000) = v24;
    *(void *)(a2 + 1016) = 0;
    *(void *)(a2 + 1008) = 0;
    *(void *)(a2 + 1000) = 0;
    *(unsigned char *)(a1 + 1024) = 1;
  }
  *(_OWORD *)(a1 + 1032) = *(_OWORD *)(a2 + 1032);
  long long v25 = (void **)(a1 + 1048);
  if (*(char *)(a1 + 1071) < 0) {
    operator delete(*v25);
  }
  long long v26 = *(_OWORD *)(a2 + 1048);
  *(void *)(a1 + 1064) = *(void *)(a2 + 1064);
  *(_OWORD *)long long v25 = v26;
  *(unsigned char *)(a2 + 1071) = 0;
  *(unsigned char *)(a2 + 1048) = 0;
  uint64_t v27 = (void **)(a1 + 1072);
  if (*(char *)(a1 + 1095) < 0) {
    operator delete(*v27);
  }
  long long v28 = *(_OWORD *)(a2 + 1072);
  *(void *)(a1 + 1088) = *(void *)(a2 + 1088);
  *(_OWORD *)uint64_t v27 = v28;
  *(unsigned char *)(a2 + 1095) = 0;
  *(unsigned char *)(a2 + 1072) = 0;
  uint64_t v29 = (void **)(a1 + 1096);
  if (*(char *)(a1 + 1119) < 0) {
    operator delete(*v29);
  }
  long long v30 = *(_OWORD *)(a2 + 1096);
  *(void *)(a1 + 1112) = *(void *)(a2 + 1112);
  *(_OWORD *)uint64_t v29 = v30;
  *(unsigned char *)(a2 + 1119) = 0;
  *(unsigned char *)(a2 + 1096) = 0;
  char v31 = (void **)(a1 + 1120);
  if (*(char *)(a1 + 1143) < 0) {
    operator delete(*v31);
  }
  long long v32 = *(_OWORD *)(a2 + 1120);
  *(void *)(a1 + 1136) = *(void *)(a2 + 1136);
  *(_OWORD *)char v31 = v32;
  *(unsigned char *)(a2 + 1143) = 0;
  *(unsigned char *)(a2 + 1120) = 0;
  unsigned __int8 v33 = (void **)(a1 + 1144);
  if (*(char *)(a1 + 1167) < 0) {
    operator delete(*v33);
  }
  long long v34 = *(_OWORD *)(a2 + 1144);
  *(void *)(a1 + 1160) = *(void *)(a2 + 1160);
  *(_OWORD *)unsigned __int8 v33 = v34;
  *(unsigned char *)(a2 + 1167) = 0;
  *(unsigned char *)(a2 + 1144) = 0;
  *(_OWORD *)(a1 + 1168) = *(_OWORD *)(a2 + 1168);
  uint64_t v35 = (void **)(a1 + 1184);
  if (*(char *)(a1 + 1207) < 0) {
    operator delete(*v35);
  }
  long long v36 = *(_OWORD *)(a2 + 1184);
  *(void *)(a1 + 1200) = *(void *)(a2 + 1200);
  *(_OWORD *)uint64_t v35 = v36;
  *(unsigned char *)(a2 + 1207) = 0;
  *(unsigned char *)(a2 + 1184) = 0;
  uint64_t v37 = (void **)(a1 + 1208);
  if (*(char *)(a1 + 1231) < 0) {
    operator delete(*v37);
  }
  long long v38 = *(_OWORD *)(a2 + 1208);
  *(void *)(a1 + 1224) = *(void *)(a2 + 1224);
  *(_OWORD *)uint64_t v37 = v38;
  *(unsigned char *)(a2 + 1231) = 0;
  *(unsigned char *)(a2 + 1208) = 0;
  uint64_t v39 = (void **)(a1 + 1232);
  if (*(char *)(a1 + 1255) < 0) {
    operator delete(*v39);
  }
  long long v40 = *(_OWORD *)(a2 + 1232);
  *(void *)(a1 + 1248) = *(void *)(a2 + 1248);
  *(_OWORD *)uint64_t v39 = v40;
  *(unsigned char *)(a2 + 1255) = 0;
  *(unsigned char *)(a2 + 1232) = 0;
  uint64_t v41 = (void **)(a1 + 1256);
  if (*(char *)(a1 + 1279) < 0) {
    operator delete(*v41);
  }
  long long v42 = *(_OWORD *)(a2 + 1256);
  *(void *)(a1 + 1272) = *(void *)(a2 + 1272);
  *(_OWORD *)uint64_t v41 = v42;
  *(unsigned char *)(a2 + 1279) = 0;
  *(unsigned char *)(a2 + 1256) = 0;
  uint64_t v43 = *(void *)(a2 + 1280);
  *(_DWORD *)(a1 + 1288) = *(_DWORD *)(a2 + 1288);
  *(void *)(a1 + 1280) = v43;
  sub_100310F88(a1 + 1296, a2 + 1296);
  long long v44 = *(_OWORD *)(a2 + 1461);
  *(_OWORD *)(a1 + 1448) = *(_OWORD *)(a2 + 1448);
  *(_OWORD *)(a1 + 1461) = v44;
  sub_100179CB0(a1 + 1480, (__n128 *)(a2 + 1480));
  __int16 v45 = *(_WORD *)(a2 + 1512);
  *(unsigned char *)(a1 + 1514) = *(unsigned char *)(a2 + 1514);
  *(_WORD *)(a1 + 1512) = v45;
  return a1;
}

uint64_t sub_100B62F98(uint64_t a1, long long *a2)
{
  if (*(char *)(a1 + 23) < 0) {
    operator delete(*(void **)a1);
  }
  long long v4 = *a2;
  *(void *)(a1 + 16) = *((void *)a2 + 2);
  *(_OWORD *)a1 = v4;
  *((unsigned char *)a2 + 23) = 0;
  *(unsigned char *)a2 = 0;
  *(_WORD *)(a1 + 24) = *((_WORD *)a2 + 12);
  sub_100179CB0(a1 + 32, (__n128 *)a2 + 2);
  sub_100179CB0(a1 + 64, (__n128 *)a2 + 4);
  sub_100179CB0(a1 + 96, (__n128 *)a2 + 6);
  sub_100179CB0(a1 + 128, (__n128 *)a2 + 8);
  *(_WORD *)(a1 + 160) = *((_WORD *)a2 + 80);
  uint64_t v5 = (void **)(a1 + 168);
  if (*(char *)(a1 + 191) < 0) {
    operator delete(*v5);
  }
  long long v6 = *(long long *)((char *)a2 + 168);
  *(void *)(a1 + 184) = *((void *)a2 + 23);
  *(_OWORD *)uint64_t v5 = v6;
  *((unsigned char *)a2 + 191) = 0;
  *((unsigned char *)a2 + 168) = 0;
  __int16 v7 = *((_WORD *)a2 + 96);
  *(unsigned char *)(a1 + 194) = *((unsigned char *)a2 + 194);
  *(_WORD *)(a1 + 192) = v7;
  sub_100179CB0(a1 + 200, (__n128 *)((char *)a2 + 200));
  long long v8 = *(long long *)((char *)a2 + 232);
  *(_WORD *)(a1 + 248) = *((_WORD *)a2 + 124);
  *(_OWORD *)(a1 + 232) = v8;
  return a1;
}

unsigned char *sub_100B630A0(unsigned char *a1, uint64_t a2)
{
  *a1 = 0;
  a1[592] = 0;
  if (*(unsigned char *)(a2 + 592))
  {
    sub_100B63100((uint64_t)a1, a2);
    a1[592] = 1;
  }
  return a1;
}

void sub_100B630E4(_Unwind_Exception *exception_object)
{
  if (*(unsigned char *)(v1 + 592)) {
    sub_1008C2D48(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100B63100(uint64_t a1, uint64_t a2)
{
  long long v4 = (long long *)(a2 + 40);
  *(_WORD *)a1 = *(_WORD *)a2;
  uint64_t v5 = a1 + 40;
  sub_1000593FC(a1 + 8, (long long *)(a2 + 8));
  sub_1000593FC(v5, v4);
  sub_1001A04E8((unsigned char *)(a1 + 72), a2 + 72);
  sub_1000593FC(a1 + 232, (long long *)(a2 + 232));
  sub_100778F3C((char *)(a1 + 264), a2 + 264);
  sub_1007790C4((char *)(a1 + 368), a2 + 368);
  sub_1000593FC(a1 + 456, (long long *)(a2 + 456));
  sub_1000593FC(a1 + 488, (long long *)(a2 + 488));
  sub_1000593FC(a1 + 520, (long long *)(a2 + 520));
  sub_1000593FC(a1 + 552, (long long *)(a2 + 552));
  *(_WORD *)(a1 + 584) = *(_WORD *)(a2 + 584);
  return a1;
}

void sub_100B63200(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void **a10)
{
  if (v10[544] && v10[543] < 0) {
    operator delete(*v11);
  }
  if (v10[512] && v10[511] < 0) {
    operator delete(*v18);
  }
  if (v10[480] && v10[479] < 0) {
    operator delete(*v17);
  }
  sub_100777CB4(v16);
  sub_1005ADA04(v15);
  if (v10[256] && v10[255] < 0) {
    operator delete(*v14);
  }
  sub_1001A0540(v13);
  if (v10[64] && v10[63] < 0) {
    operator delete(*v12);
  }
  if (v10[32])
  {
    if (v10[31] < 0) {
      operator delete(*a10);
    }
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100B632F8(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 184) && *(char *)(a1 + 183) < 0) {
    operator delete(*(void **)(a1 + 160));
  }
  if (*(unsigned char *)(a1 + 152) && *(char *)(a1 + 151) < 0) {
    operator delete(*(void **)(a1 + 128));
  }
  if (*(unsigned char *)(a1 + 120) && *(char *)(a1 + 119) < 0) {
    operator delete(*(void **)(a1 + 96));
  }
  if (*(unsigned char *)(a1 + 88) && *(char *)(a1 + 87) < 0) {
    operator delete(*(void **)(a1 + 64));
  }
  if (*(unsigned char *)(a1 + 56) && *(char *)(a1 + 55) < 0) {
    operator delete(*(void **)(a1 + 32));
  }
  if (*(unsigned char *)(a1 + 24) && *(char *)(a1 + 23) < 0) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t sub_100B633B4(uint64_t *a1, uint64_t a2, long long *a3)
{
  uint64_t v4 = *a1;
  uint64_t v5 = 0x2E8BA2E8BA2E8BA3 * ((a1[1] - *a1) >> 3);
  unint64_t v6 = v5 + 1;
  if ((unint64_t)(v5 + 1) > 0x2E8BA2E8BA2E8BALL) {
    sub_10006A748();
  }
  uint64_t v9 = (uint64_t)(a1 + 2);
  unint64_t v10 = 0x2E8BA2E8BA2E8BA3 * ((a1[2] - v4) >> 3);
  if (2 * v10 > v6) {
    unint64_t v6 = 2 * v10;
  }
  if (v10 >= 0x1745D1745D1745DLL) {
    unint64_t v11 = 0x2E8BA2E8BA2E8BALL;
  }
  else {
    unint64_t v11 = v6;
  }
  long long v19 = a1 + 2;
  if (v11) {
    long long v12 = (char *)sub_10010C8A4(v9, v11);
  }
  else {
    long long v12 = 0;
  }
  uint64_t v15 = v12;
  uint64_t v16 = &v12[88 * v5];
  long long v18 = &v12[88 * v11];
  sub_100B634DC(v16, a2, a3);
  long long v17 = v16 + 88;
  sub_100B6371C(a1, &v15);
  uint64_t v13 = a1[1];
  sub_100B6382C((uint64_t)&v15);
  return v13;
}

void sub_100B634C8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100B6382C((uint64_t)va);
  _Unwind_Resume(a1);
}

void *sub_100B634DC(void *__dst, uint64_t a2, long long *a3)
{
  if (*(char *)(a2 + 23) < 0)
  {
    sub_10004FC84(v6, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)unint64_t v6 = *(_OWORD *)a2;
    uint64_t v7 = *(void *)(a2 + 16);
  }
  v11[0] = 0;
  if (*((char *)a3 + 23) < 0)
  {
    sub_10004FC84(&v12, *(void **)a3, *((void *)a3 + 1));
  }
  else
  {
    long long v12 = *a3;
    uint64_t v13 = *((void *)a3 + 2);
  }
  v11[0] = 1;
  v8[0] = 0;
  sub_100B63660(__dst, (long long *)v6, (uint64_t)v11, (uint64_t)v8);
  if (v8[0])
  {
    if (v10 < 0) {
      operator delete(__p);
    }
    v8[0] = 0;
  }
  if (v11[0])
  {
    if (SHIBYTE(v13) < 0) {
      operator delete((void *)v12);
    }
    v11[0] = 0;
  }
  if (SHIBYTE(v7) < 0) {
    operator delete(v6[0]);
  }
  return __dst;
}

void sub_100B635FC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,char a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *sub_100B63660(void *__dst, long long *a2, uint64_t a3, uint64_t a4)
{
  if (*((char *)a2 + 23) < 0)
  {
    sub_10004FC84(__dst, *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v7 = *a2;
    xpc_object_t __dst[2] = *((void *)a2 + 2);
    *(_OWORD *)long long __dst = v7;
  }
  sub_100311E70((uint64_t)(__dst + 3), a3);
  sub_100311E70((uint64_t)(__dst + 7), a4);
  return __dst;
}

void sub_100B636DC(_Unwind_Exception *exception_object)
{
  if (*v2)
  {
    if (*(char *)(v1 + 55) < 0) {
      operator delete(*(void **)(v1 + 32));
    }
    unsigned char *v2 = 0;
  }
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100B6371C(uint64_t *a1, void *a2)
{
  uint64_t result = sub_100B63794((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t sub_100B63794(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  uint64_t result = a6;
  if (a3 != a5)
  {
    uint64_t v9 = a7 - 32;
    do
    {
      long long v10 = *(_OWORD *)(a3 - 88);
      *(void *)(v9 - 40) = *(void *)(a3 - 72);
      *(_OWORD *)(v9 - 56) = v10;
      *(void *)(a3 - 80) = 0;
      *(void *)(a3 - 72) = 0;
      *(void *)(a3 - 88) = 0;
      *(unsigned char *)(v9 - 32) = 0;
      if (*(unsigned char *)(a3 - 64))
      {
        long long v11 = *(_OWORD *)(a3 - 56);
        *(void *)(v9 - 8) = *(void *)(a3 - 40);
        *(_OWORD *)(v9 - 24) = v11;
        *(void *)(a3 - 48) = 0;
        *(void *)(a3 - 40) = 0;
        *(void *)(a3 - 56) = 0;
        *(unsigned char *)(v9 - 32) = 1;
      }
      *(unsigned char *)uint64_t v9 = 0;
      if (*(unsigned char *)(a3 - 32))
      {
        long long v12 = *(_OWORD *)(a3 - 24);
        *(void *)(v9 + 24) = *(void *)(a3 - 8);
        *(_OWORD *)(v9 + 8) = v12;
        *(void *)(a3 - 16) = 0;
        *(void *)(a3 - 8) = 0;
        *(void *)(a3 - 24) = 0;
        *(unsigned char *)uint64_t v9 = 1;
      }
      a3 -= 88;
      v9 -= 88;
      v7 -= 88;
    }
    while (a3 != a5);
  }
  return result;
}

uint64_t sub_100B6382C(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 88;
    sub_100310760(i - 88);
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t sub_100B6387C(void *a1, uint64_t a2)
{
  uint64_t v2 = 0x4E25B9EFD4E25B9FLL * ((uint64_t)(a1[1] - *a1) >> 4);
  unint64_t v3 = v2 + 1;
  if ((unint64_t)(v2 + 1) > 0x2B1DA46102B1DALL) {
    sub_10006A748();
  }
  if (0x9C4B73DFA9C4B73ELL * ((uint64_t)(a1[2] - *a1) >> 4) > v3) {
    unint64_t v3 = 0x9C4B73DFA9C4B73ELL * ((uint64_t)(a1[2] - *a1) >> 4);
  }
  if ((unint64_t)(0x4E25B9EFD4E25B9FLL * ((uint64_t)(a1[2] - *a1) >> 4)) >= 0x158ED2308158EDLL) {
    unint64_t v6 = 0x2B1DA46102B1DALL;
  }
  else {
    unint64_t v6 = v3;
  }
  long long v18 = a1 + 2;
  if (v6)
  {
    if (v6 > 0x2B1DA46102B1DALL) {
      sub_10006A7CC();
    }
    uint64_t v7 = (char *)operator new(1520 * v6);
  }
  else
  {
    uint64_t v7 = 0;
  }
  uint64_t v16 = v7;
  *(void *)long long v17 = &v7[1520 * v2];
  *(void *)&v17[16] = &v7[1520 * v6];
  sub_100B63A1C(*(uint64_t *)v17, a2);
  uint64_t v8 = 0;
  *(void *)&v17[8] = *(void *)v17 + 1520;
  uint64_t v10 = *a1;
  for (uint64_t i = a1[1]; i + v8 != v10; sub_100B617E8(v8 + *(void *)v17, v8 + i))
    v8 -= 1520;
  uint64_t v11 = a1[2];
  long long v12 = *(_OWORD *)&v17[8];
  uint64_t v15 = *(void *)&v17[8];
  long long v13 = *(_OWORD *)a1;
  *a1 = *(void *)v17 + v8;
  *(_OWORD *)long long v17 = v13;
  *(_OWORD *)(a1 + 1) = v12;
  *(void *)&v17[16] = v11;
  uint64_t v16 = (char *)v13;
  sub_100B63E2C((uint64_t)&v16);
  return v15;
}

void sub_100B639E4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  sub_100B63E2C((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100B63A1C(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = sub_100690AC0((unsigned char *)a1, a2);
  v4[224] = 0;
  v4[624] = 0;
  if (*(unsigned char *)(a2 + 624))
  {
    sub_1003126AC(v4 + 224, (long long *)(a2 + 224));
    *(unsigned char *)(a1 + 624) = 1;
  }
  *(unsigned char *)(a1 + 632) = 0;
  *(unsigned char *)(a1 + 888) = 0;
  if (*(unsigned char *)(a2 + 888))
  {
    sub_1003300C4(a1 + 632, (long long *)(a2 + 632));
    *(unsigned char *)(a1 + 888) = 1;
  }
  *(unsigned char *)(a1 + 896) = 0;
  *(unsigned char *)(a1 + 968) = 0;
  if (*(unsigned char *)(a2 + 968))
  {
    long long v5 = *(_OWORD *)(a2 + 896);
    *(void *)(a1 + 912) = *(void *)(a2 + 912);
    *(_OWORD *)(a1 + 896) = v5;
    *(void *)(a2 + 912) = 0;
    *(void *)(a2 + 904) = 0;
    *(void *)(a2 + 896) = 0;
    long long v6 = *(_OWORD *)(a2 + 920);
    *(void *)(a1 + 936) = *(void *)(a2 + 936);
    *(_OWORD *)(a1 + 920) = v6;
    *(void *)(a2 + 936) = 0;
    *(void *)(a2 + 928) = 0;
    *(void *)(a2 + 920) = 0;
    long long v7 = *(_OWORD *)(a2 + 944);
    *(void *)(a1 + 960) = *(void *)(a2 + 960);
    *(_OWORD *)(a1 + 944) = v7;
    *(void *)(a2 + 960) = 0;
    *(void *)(a2 + 952) = 0;
    *(void *)(a2 + 944) = 0;
    *(unsigned char *)(a1 + 968) = 1;
  }
  *(unsigned char *)(a1 + 976) = 0;
  *(unsigned char *)(a1 + 1024) = 0;
  if (*(unsigned char *)(a2 + 1024))
  {
    long long v8 = *(_OWORD *)(a2 + 976);
    *(void *)(a1 + 992) = *(void *)(a2 + 992);
    *(_OWORD *)(a1 + 976) = v8;
    *(void *)(a2 + 992) = 0;
    *(void *)(a2 + 984) = 0;
    *(void *)(a2 + 976) = 0;
    long long v9 = *(_OWORD *)(a2 + 1000);
    *(void *)(a1 + 1016) = *(void *)(a2 + 1016);
    *(_OWORD *)(a1 + 1000) = v9;
    *(void *)(a2 + 1016) = 0;
    *(void *)(a2 + 1008) = 0;
    *(void *)(a2 + 1000) = 0;
    *(unsigned char *)(a1 + 1024) = 1;
  }
  *(_OWORD *)(a1 + 1032) = *(_OWORD *)(a2 + 1032);
  long long v10 = *(_OWORD *)(a2 + 1048);
  *(void *)(a1 + 1064) = *(void *)(a2 + 1064);
  *(_OWORD *)(a1 + 1048) = v10;
  *(_OWORD *)(a2 + 1056) = 0u;
  *(void *)(a2 + 1048) = 0;
  long long v11 = *(_OWORD *)(a2 + 1072);
  *(void *)(a1 + 1088) = *(void *)(a2 + 1088);
  *(_OWORD *)(a1 + 1072) = v11;
  *(_OWORD *)(a2 + 1080) = 0u;
  *(void *)(a2 + 1072) = 0;
  long long v12 = *(_OWORD *)(a2 + 1096);
  *(void *)(a1 + 1112) = *(void *)(a2 + 1112);
  *(_OWORD *)(a1 + 1096) = v12;
  *(void *)(a2 + 1112) = 0;
  *(_OWORD *)(a2 + 1096) = 0u;
  long long v13 = *(_OWORD *)(a2 + 1120);
  *(void *)(a1 + 1136) = *(void *)(a2 + 1136);
  *(_OWORD *)(a1 + 1120) = v13;
  *(void *)(a2 + 1136) = 0;
  *(_OWORD *)(a2 + 1120) = 0u;
  long long v14 = *(_OWORD *)(a2 + 1144);
  *(void *)(a1 + 1160) = *(void *)(a2 + 1160);
  *(_OWORD *)(a1 + 1144) = v14;
  *(void *)(a2 + 1160) = 0;
  *(_OWORD *)(a2 + 1144) = 0u;
  *(_OWORD *)(a1 + 1168) = *(_OWORD *)(a2 + 1168);
  long long v15 = *(_OWORD *)(a2 + 1184);
  *(void *)(a1 + 1200) = *(void *)(a2 + 1200);
  *(_OWORD *)(a1 + 1184) = v15;
  *(void *)(a2 + 1200) = 0;
  *(_OWORD *)(a2 + 1184) = 0u;
  long long v16 = *(_OWORD *)(a2 + 1208);
  *(void *)(a1 + 1224) = *(void *)(a2 + 1224);
  *(_OWORD *)(a1 + 1208) = v16;
  *(void *)(a2 + 1224) = 0;
  *(_OWORD *)(a2 + 1208) = 0u;
  long long v17 = *(_OWORD *)(a2 + 1232);
  *(void *)(a1 + 1248) = *(void *)(a2 + 1248);
  *(_OWORD *)(a1 + 1232) = v17;
  *(void *)(a2 + 1248) = 0;
  *(_OWORD *)(a2 + 1232) = 0u;
  long long v18 = *(_OWORD *)(a2 + 1256);
  *(void *)(a1 + 1272) = *(void *)(a2 + 1272);
  *(_OWORD *)(a1 + 1256) = v18;
  *(void *)(a2 + 1272) = 0;
  *(_OWORD *)(a2 + 1256) = 0u;
  uint64_t v19 = *(void *)(a2 + 1280);
  *(_DWORD *)(a1 + 1288) = *(_DWORD *)(a2 + 1288);
  *(void *)(a1 + 1280) = v19;
  *(void *)(a1 + 1296) = 0;
  *(_OWORD *)(a1 + 1304) = 0u;
  *(_OWORD *)(a1 + 1296) = *(_OWORD *)(a2 + 1296);
  *(void *)(a1 + 1312) = *(void *)(a2 + 1312);
  *(void *)(a2 + 1312) = 0;
  *(_OWORD *)(a2 + 1296) = 0u;
  *(unsigned char *)(a1 + 1320) = 0;
  *(unsigned char *)(a1 + 1344) = 0;
  if (*(unsigned char *)(a2 + 1344))
  {
    long long v20 = *(_OWORD *)(a2 + 1320);
    *(void *)(a1 + 1336) = *(void *)(a2 + 1336);
    *(_OWORD *)(a1 + 1320) = v20;
    *(void *)(a2 + 1336) = 0;
    *(void *)(a2 + 1328) = 0;
    *(void *)(a2 + 1320) = 0;
    *(unsigned char *)(a1 + 1344) = 1;
  }
  *(unsigned char *)(a1 + 1352) = 0;
  *(unsigned char *)(a1 + 1376) = 0;
  if (*(unsigned char *)(a2 + 1376))
  {
    long long v21 = *(_OWORD *)(a2 + 1352);
    *(void *)(a1 + 1368) = *(void *)(a2 + 1368);
    *(_OWORD *)(a1 + 1352) = v21;
    *(void *)(a2 + 1368) = 0;
    *(void *)(a2 + 1360) = 0;
    *(void *)(a2 + 1352) = 0;
    *(unsigned char *)(a1 + 1376) = 1;
  }
  *(unsigned char *)(a1 + 1384) = 0;
  *(unsigned char *)(a1 + 1408) = 0;
  if (*(unsigned char *)(a2 + 1408))
  {
    long long v22 = *(_OWORD *)(a2 + 1384);
    *(void *)(a1 + 1400) = *(void *)(a2 + 1400);
    *(_OWORD *)(a1 + 1384) = v22;
    *(void *)(a2 + 1400) = 0;
    *(void *)(a2 + 1392) = 0;
    *(void *)(a2 + 1384) = 0;
    *(unsigned char *)(a1 + 1408) = 1;
  }
  *(_DWORD *)(a1 + 1416) = *(_DWORD *)(a2 + 1416);
  long long v23 = *(_OWORD *)(a2 + 1424);
  *(void *)(a1 + 1440) = *(void *)(a2 + 1440);
  *(_OWORD *)(a1 + 1424) = v23;
  *(void *)(a2 + 1440) = 0;
  *(void *)(a2 + 1432) = 0;
  *(void *)(a2 + 1424) = 0;
  long long v24 = *(_OWORD *)(a2 + 1448);
  *(_OWORD *)(a1 + 1461) = *(_OWORD *)(a2 + 1461);
  *(_OWORD *)(a1 + 1448) = v24;
  *(unsigned char *)(a1 + 1480) = 0;
  *(unsigned char *)(a1 + 1504) = 0;
  if (*(unsigned char *)(a2 + 1504))
  {
    long long v25 = *(_OWORD *)(a2 + 1480);
    *(void *)(a1 + 1496) = *(void *)(a2 + 1496);
    *(_OWORD *)(a1 + 1480) = v25;
    *(void *)(a2 + 1496) = 0;
    *(void *)(a2 + 1488) = 0;
    *(void *)(a2 + 1480) = 0;
    *(unsigned char *)(a1 + 1504) = 1;
  }
  __int16 v26 = *(_WORD *)(a2 + 1512);
  *(unsigned char *)(a1 + 1514) = *(unsigned char *)(a2 + 1514);
  *(_WORD *)(a1 + 1512) = v26;
  return a1;
}

void sub_100B63E00(_Unwind_Exception *exception_object)
{
  if (*(unsigned char *)(v1 + 624)) {
    sub_1000C54EC(v2);
  }
  if (*(unsigned char *)(v1 + 216)) {
    sub_1000C584C(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100B63E2C(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 1520;
    sub_100B615AC(i - 1520);
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void *sub_100B63E7C(void *a1)
{
  *a1 = off_101A8C2E0;
  uint64_t v2 = (void *)a1[7];
  if (v2)
  {
    a1[8] = v2;
    operator delete(v2);
  }
  *a1 = off_101A8C2A0;
  uint64_t v3 = (void *)a1[2];
  if (v3)
  {
    a1[3] = v3;
    operator delete(v3);
  }
  return a1;
}

uint64_t **sub_100B63EF8(uint64_t **result, uint64_t *a2)
{
  uint64_t v2 = *result;
  *uint64_t result = a2;
  if (v2)
  {
    uint64_t v3 = (std::__shared_weak_count *)v2[1];
    if (v3)
    {
      uint64_t v4 = std::__shared_weak_count::lock(v3);
      if (v4)
      {
        long long v5 = v4;
        uint64_t v6 = *v2;
        if (*v2)
        {
          long long v7 = *(NSObject **)v2[2];
          if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)long long v9 = 0;
            _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I de-assert bootstrap for transfer", v9, 2u);
          }
          (*(void (**)(uint64_t, void))(*(void *)v6 + 88))(v6, 0);
        }
        sub_10004D2C8(v5);
      }
      long long v8 = (std::__shared_weak_count *)v2[1];
      if (v8) {
        std::__shared_weak_count::__release_weak(v8);
      }
    }
    operator delete();
  }
  return result;
}

void sub_100B6400C()
{
}

void *sub_100B64020(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = off_101A3E7D0;
  result[1] = v3;
  return result;
}

uint64_t sub_100B64068(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A3E7D0;
  a2[1] = v2;
  return result;
}

void sub_100B64094(uint64_t a1, void *a2)
{
  xpc_object_t v3 = xpc_array_create(0, 0);
  if (v3 || (xpc_object_t v3 = xpc_null_create()) != 0)
  {
    if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_array)
    {
      xpc_retain(v3);
      xpc_object_t v4 = v3;
    }
    else
    {
      xpc_object_t v4 = xpc_null_create();
    }
  }
  else
  {
    xpc_object_t v4 = xpc_null_create();
    xpc_object_t v3 = 0;
  }
  xpc_release(v3);
  long long v7 = (void *)*a2;
  long long v5 = a2 + 1;
  uint64_t v6 = v7;
  if (v7 != v5)
  {
    do
    {
      xpc_object_t v8 = xpc_dictionary_create(0, 0, 0);
      xpc_object_t v9 = v8;
      if (v8)
      {
        xpc_object_t v24 = v8;
      }
      else
      {
        xpc_object_t v9 = xpc_null_create();
        xpc_object_t v24 = v9;
        if (!v9)
        {
          xpc_object_t v10 = xpc_null_create();
          xpc_object_t v9 = 0;
          goto LABEL_15;
        }
      }
      if (xpc_get_type(v9) != (xpc_type_t)&_xpc_type_dictionary)
      {
        xpc_object_t v10 = xpc_null_create();
LABEL_15:
        xpc_object_t v24 = v10;
        goto LABEL_16;
      }
      xpc_retain(v9);
LABEL_16:
      xpc_release(v9);
      xpc_object_t v22 = xpc_data_create(v6 + 4, 0x10uLL);
      if (!v22) {
        xpc_object_t v22 = xpc_null_create();
      }
      long long __p = &v24;
      long long v18 = "first";
      sub_100035E70((uint64_t)&__p, &v22, &object);
      xpc_release(object);
      xpc_object_t object = 0;
      xpc_release(v22);
      xpc_object_t v22 = 0;
      if (*((char *)v6 + 71) >= 0) {
        long long v11 = (const char *)(v6 + 6);
      }
      else {
        long long v11 = (const char *)v6[6];
      }
      xpc_object_t v20 = xpc_string_create(v11);
      if (!v20) {
        xpc_object_t v20 = xpc_null_create();
      }
      long long __p = &v24;
      long long v18 = "second";
      sub_100035E70((uint64_t)&__p, &v20, &v21);
      xpc_release(v21);
      xpc_object_t v21 = 0;
      xpc_release(v20);
      xpc_object_t v20 = 0;
      xpc_object_t v12 = v24;
      if (v24) {
        xpc_retain(v24);
      }
      else {
        xpc_object_t v12 = xpc_null_create();
      }
      xpc_release(v24);
      xpc_array_append_value(v4, v12);
      xpc_release(v12);
      long long v13 = (void *)v6[1];
      if (v13)
      {
        do
        {
          long long v14 = v13;
          long long v13 = (void *)*v13;
        }
        while (v13);
      }
      else
      {
        do
        {
          long long v14 = (void *)v6[2];
          BOOL v15 = *v14 == (void)v6;
          uint64_t v6 = v14;
        }
        while (!v15);
      }
      uint64_t v6 = v14;
    }
    while (v14 != v5);
  }
  if (v4)
  {
    xpc_retain(v4);
    xpc_object_t v16 = v4;
  }
  else
  {
    xpc_object_t v16 = xpc_null_create();
  }
  xpc_release(v4);
  sub_100058DB0(&__p, "/cc/props/csn_to_ids_device_id_map");
  xpc_object_t v24 = v16;
  if (v16) {
    xpc_retain(v16);
  }
  else {
    xpc_object_t v24 = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(v24);
  xpc_object_t v24 = 0;
  if (v19 < 0) {
    operator delete(__p);
  }
  xpc_release(v16);
}

void sub_100B64378(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, xpc_object_t object)
{
  xpc_release(object);
  if (a14 < 0) {
    operator delete(__p);
  }
  xpc_release(v19);
  _Unwind_Resume(a1);
}

uint64_t sub_100B6442C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100B6446C()
{
}

void *sub_100B64478(void *a1)
{
  *a1 = off_101A3E860;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_100B644C4(void *a1)
{
  *a1 = off_101A3E860;
  uint64_t v1 = (std::__shared_weak_count *)a1[2];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

void *sub_100B64530(void *a1)
{
  uint64_t result = operator new(0x20uLL);
  uint64_t v4 = a1[1];
  uint64_t v3 = a1[2];
  *uint64_t result = off_101A3E860;
  result[1] = v4;
  result[2] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  result[3] = a1[3];
  return result;
}

void *sub_100B64594(void *result, void *a2)
{
  uint64_t v3 = result[1];
  uint64_t v2 = result[2];
  *a2 = off_101A3E860;
  a2[1] = v3;
  a2[2] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  a2[3] = result[3];
  return result;
}

void sub_100B645D4(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_100B645E4(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[2];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete(__p);
}

void sub_100B64624(void *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2)
  {
    uint64_t v3 = a1[3];
    uint64_t v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      if (a1[1] && *(unsigned char *)(v3 + 140) == 5) {
        *(unsigned char *)(v3 + 141) = 1;
      }
      sub_10004D2C8(v4);
    }
  }
}

uint64_t sub_100B64690(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100B646D0()
{
}

void *sub_100B646DC(void *a1)
{
  *a1 = off_101A3E8E0;
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_100B64728(void *a1)
{
  *a1 = off_101A3E8E0;
  uint64_t v1 = (std::__shared_weak_count *)a1[3];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

char *sub_100B64794(uint64_t a1)
{
  uint64_t result = (char *)operator new(0x20uLL);
  *(void *)uint64_t result = off_101A3E8E0;
  *(_OWORD *)(result + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 24);
  *((void *)result + 3) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_100B647F8(uint64_t result, uint64_t a2)
{
  *(void *)a2 = off_101A3E8E0;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(result + 8);
  uint64_t v2 = *(void *)(result + 24);
  *(void *)(a2 + 24) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100B64838(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 24);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_100B64848(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete(__p);
}

void sub_100B64888(void *a1, uint64_t a2, const void **a3, uint64_t a4)
{
  if (*(char *)(a2 + 23) < 0)
  {
    sub_10004FC84(v12, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)xpc_object_t v12 = *(_OWORD *)a2;
    long long v13 = *(void **)(a2 + 16);
  }
  sub_10010DFA0((uint64_t)v15, a4);
  uint64_t v7 = a1[1];
  long long v14 = 0;
  if (!v16) {
    sub_10007B600();
  }
  (*(void (**)(uint64_t, const void **))(*(void *)v16 + 48))(v16, &v14);
  sub_100057D78(&v14);
  xpc_object_t v8 = (std::__shared_weak_count *)a1[3];
  if (v8)
  {
    xpc_object_t v9 = std::__shared_weak_count::lock(v8);
    if (v9 && a1[2])
    {
      *(void *)long long buf = v7;
      sub_100058198((const void **)&buf[8], a3);
      if (SHIBYTE(v13) < 0)
      {
        sub_10004FC84(__p, v12[0], (unint64_t)v12[1]);
      }
      else
      {
        *(_OWORD *)long long __p = *(_OWORD *)v12;
        __p[2] = v13;
      }
      xpc_object_t v10 = *(std::__shared_weak_count **)(v7 + 16);
      if (v10)
      {
        if (std::__shared_weak_count::lock(v10)) {
          operator new();
        }
      }
      sub_100088B9C();
    }
  }
  else
  {
    xpc_object_t v9 = 0;
  }
  if (!os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR))
  {
    if (!v9) {
      goto LABEL_19;
    }
LABEL_18:
    sub_10004D2C8(v9);
    goto LABEL_19;
  }
  long long v11 = v12;
  if (SHIBYTE(v13) < 0) {
    long long v11 = (void **)v12[0];
  }
  *(_DWORD *)long long buf = 136446210;
  *(void *)&_OWORD buf[4] = v11;
  _os_log_error_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR, "invalid cp.tr.ctr for %{public}s", buf, 0xCu);
  if (v9) {
    goto LABEL_18;
  }
LABEL_19:
  sub_10010E020(v15);
  if (SHIBYTE(v13) < 0) {
    operator delete(v12[0]);
  }
}

void sub_100B64B54(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18)
{
  sub_100057D78(v19);
  sub_10004D2C8(v18);
  sub_10010E020(&a18);
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100B64BB4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100B64BF4()
{
}

uint64_t *sub_100B64C00(uint64_t *a1)
{
  uint64_t v1 = *a1;
  xpc_object_t v8 = a1;
  uint64_t v9 = v1;
  uint64_t v2 = *(void *)v1;
  int v3 = sub_100CD89E0((id *)(v1 + 8));
  uint64_t v4 = *(NSObject **)(v2 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    long long v5 = (void *)(v1 + 16);
    if (*(char *)(v1 + 39) < 0) {
      long long v5 = (void *)*v5;
    }
    if ((v3 - 2) > 2) {
      uint64_t v6 = "kAccepted";
    }
    else {
      uint64_t v6 = off_101A3FE60[(char)(v3 - 2)];
    }
    *(_DWORD *)long long buf = 136315394;
    *(void *)&_OWORD buf[4] = v5;
    __int16 v15 = 2080;
    uint64_t v16 = v6;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Received: [%s], consent state : %s", buf, 0x16u);
  }
  xpc_object_t v12 = 0;
  long long v13 = 0;
  sub_100058DB0(buf, "");
  sub_100058DB0(__p, "");
  sub_100B51F3C(v2, 3, 0, (uint64_t *)&v13, (uint64_t *)&v12, (uint64_t *)buf, (char *)__p);
  if (v11 < 0) {
    operator delete(__p[0]);
  }
  if (v17 < 0) {
    operator delete(*(void **)buf);
  }
  sub_100057D78(&v12);
  sub_1000558F4(&v13);
  sub_100B64DE4(&v9);
  return sub_100046B58((uint64_t *)&v8);
}

void sub_100B64D80(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, const void *a18, const void *a19, void *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  if (a25 < 0) {
    operator delete(a20);
  }
  sub_100057D78(&a18);
  sub_1000558F4(&a19);
  sub_100B64DE4(&a11);
  sub_100046B58(&a10);
  _Unwind_Resume(a1);
}

uint64_t *sub_100B64DE4(uint64_t *result)
{
  uint64_t v1 = *result;
  *uint64_t result = 0;
  if (v1)
  {
    if (*(char *)(v1 + 39) < 0) {
      operator delete(*(void **)(v1 + 16));
    }
    sub_100057D78((const void **)(v1 + 8));
    operator delete();
  }
  return result;
}

void *sub_100B64E44(void *a1)
{
  *a1 = off_101A3E960;
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_100B64E90(void *a1)
{
  *a1 = off_101A3E960;
  uint64_t v1 = (std::__shared_weak_count *)a1[3];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

char *sub_100B64EFC(uint64_t a1)
{
  uint64_t result = (char *)operator new(0x20uLL);
  *(void *)uint64_t result = off_101A3E960;
  *(_OWORD *)(result + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 24);
  *((void *)result + 3) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_100B64F60(uint64_t result, uint64_t a2)
{
  *(void *)a2 = off_101A3E960;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(result + 8);
  uint64_t v2 = *(void *)(result + 24);
  *(void *)(a2 + 24) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100B64FA0(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 24);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_100B64FB0(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete(__p);
}

void sub_100B64FF0(void *a1, unsigned __int8 *a2, CFDictionaryRef *a3)
{
  uint64_t v4 = (std::__shared_weak_count *)a1[3];
  if (v4)
  {
    int v6 = *a2;
    uint64_t v7 = a1[1];
    xpc_object_t v8 = std::__shared_weak_count::lock(v4);
    if (v8 && a1[2])
    {
      *(unsigned char *)(v7 + 135) = 0;
      if (*a3) {
        uint64_t v9 = sub_100080778;
      }
      else {
        uint64_t v9 = 0;
      }
      if (v9) {
        BOOL v10 = CFDictionaryGetCount(*a3) > 0;
      }
      else {
        BOOL v10 = 0;
      }
      xpc_object_t v12 = *(NSObject **)(v7 + 40);
      BOOL v13 = os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT);
      if (v13)
      {
        LODWORD(buf) = 136315138;
        *(void *)((char *)&buf + 4) = "kTransferPlanListReq";
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I Response for: [%s]", (uint8_t *)&buf, 0xCu);
      }
      if (v6) {
        char v14 = 1;
      }
      else {
        char v14 = v10;
      }
      if ((v14 & 1) == 0 && capabilities::ct::supportsSequoia((capabilities::ct *)v13))
      {
        __int16 v15 = *(NSObject **)(v7 + 40);
        if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(buf) = 0;
          _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I response is empty. source is different class", (uint8_t *)&buf, 2u);
        }
        *(unsigned char *)(v7 + 134) = 1;
        *(unsigned char *)(v7 + 143) = 1;
        sub_100B42C90(v7);
        goto LABEL_38;
      }
      xpc_object_t v24 = 0;
      long long v25 = 0;
      uint64_t v26 = 0;
      sub_100B40EE8(&v24, v7);
      if (sub_100B4E710(v7, (const void **)a3, &v24))
      {
        long long buf = (unint64_t)v7;
        char v31 = 0;
        uint64_t v32 = 0;
        sub_1000302C0((char *)&buf + 8, v24, v25, 0xAAAAAAAAAAAAAAABLL * (((char *)v25 - (char *)v24) >> 3));
        long long v22 = (unint64_t)buf;
        long long v23 = 0uLL;
        sub_1000302C0((char *)&v22 + 8, *((long long **)&buf + 1), v31, 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v31 - *((void *)&buf + 1)) >> 3));
        uint64_t v29 = 0;
        uint64_t v16 = (char *)operator new(0x28uLL);
        *(void *)uint64_t v16 = off_101A3E9E0;
        long long v17 = v23;
        *(_OWORD *)(v16 + 8) = v22;
        *(_OWORD *)(v16 + 24) = v17;
        long long v23 = 0uLL;
        *((void *)&v22 + 1) = 0;
        uint64_t v29 = v16;
        sub_100B41F14(v7, (uint64_t)v28);
        sub_10003B34C(v28);
        uint64_t v27 = (void **)&v22 + 1;
        sub_100047F64(&v27);
        uint64_t v27 = (void **)&buf + 1;
        sub_100047F64(&v27);
LABEL_37:
        *(void *)&long long buf = &v24;
        sub_100047F64((void ***)&buf);
        goto LABEL_38;
      }
      *(unsigned char *)(v7 + 134) = 1;
      if (!*(unsigned char *)(v7 + 1020))
      {
        *(_DWORD *)(v7 + 1016) = 3;
        *(unsigned char *)(v7 + 1020) = 1;
      }
      int v18 = 70002;
      char v19 = *(NSObject **)(v7 + 40);
      BOOL v20 = os_log_type_enabled(v19, OS_LOG_TYPE_ERROR);
      if (v6)
      {
        int v18 = 70004;
        if (v20)
        {
          LOWORD(buf) = 0;
          xpc_object_t v21 = "cumessage session - planlist request timeout";
LABEL_40:
          _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, v21, (uint8_t *)&buf, 2u);
        }
      }
      else if (v20)
      {
        LOWORD(buf) = 0;
        xpc_object_t v21 = "cumessage session - planlist missing response";
        goto LABEL_40;
      }
      if (!*(unsigned char *)(v7 + 1028))
      {
        *(_DWORD *)(v7 + 1024) = v18;
        *(unsigned char *)(v7 + 1028) = 1;
      }
      sub_100B42C90(v7);
      goto LABEL_37;
    }
  }
  else
  {
    xpc_object_t v8 = 0;
  }
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&buf, kCtLoggingSystemName, "cp.tr.ctr");
  char v11 = *((void *)&buf + 1);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&buf);
  if (!os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
  {
    if (!v8) {
      return;
    }
LABEL_38:
    sub_10004D2C8(v8);
    return;
  }
  LOWORD(buf) = 0;
  _os_log_error_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "invalid CellularPlanTransferFlowController (weak_ptr)", (uint8_t *)&buf, 2u);
  if (v8) {
    goto LABEL_38;
  }
}

void sub_100B65390(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, void **a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void **a21)
{
  sub_10003B34C(&a17);
  sub_100047F64(&a16);
  sub_100047F64(&a16);
  a21 = (void **)&a13;
  sub_100047F64(&a21);
  sub_10004D2C8(v21);
  _Unwind_Resume(a1);
}

uint64_t sub_100B65408(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100B65448()
{
}

uint64_t sub_100B65454(uint64_t a1)
{
  *(void *)a1 = off_101A3E9E0;
  uint64_t v3 = (void **)(a1 + 16);
  sub_100047F64(&v3);
  return a1;
}

void sub_100B654AC(uint64_t a1)
{
  *(void *)a1 = off_101A3E9E0;
  uint64_t v1 = (void **)(a1 + 16);
  sub_100047F64(&v1);
  operator delete();
}

void *sub_100B65518(uint64_t a1)
{
  uint64_t v2 = operator new(0x28uLL);
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v3 = *(long long **)(a1 + 16);
  *(void *)uint64_t v2 = off_101A3E9E0;
  *((void *)v2 + 1) = v4;
  *((void *)v2 + 2) = 0;
  *((void *)v2 + 3) = 0;
  *((void *)v2 + 4) = 0;
  sub_1000302C0((char *)v2 + 16, v3, *(long long **)(a1 + 24), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a1 + 24) - (void)v3) >> 3));
  return v2;
}

void sub_100B6558C(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

char *sub_100B655A0(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  *(void *)a2 = off_101A3E9E0;
  *(void *)(a2 + 8) = v2;
  *(void *)(a2 + 24) = 0;
  *(void *)(a2 + 32) = 0;
  *(void *)(a2 + 16) = 0;
  return sub_1000302C0((char *)(a2 + 16), *(long long **)(a1 + 16), *(long long **)(a1 + 24), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a1 + 24) - *(void *)(a1 + 16)) >> 3));
}

void sub_100B655EC(uint64_t a1)
{
  uint64_t v1 = (void **)(a1 + 16);
  sub_100047F64(&v1);
}

void sub_100B65618(void **a1)
{
  uint64_t v2 = a1 + 2;
  sub_100047F64(&v2);
  operator delete(a1);
}

void sub_100B65658(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  sub_100B4F614(v1, (uint64_t *)(a1 + 16));
  if (*(unsigned char *)(v1 + 128) != 2)
  {
    long long v5 = *(NSObject **)(v1 + 40);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      int v6 = "#I No preflight in non proximity flow";
LABEL_10:
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, v6, buf, 2u);
    }
LABEL_55:
    *(unsigned char *)(v1 + 134) = 1;
    sub_100B42C90(v1);
    return;
  }
  uint64_t v2 = *(char **)(v1 + 144);
  if (*(void *)(v1 + 152) - (void)v2 != 400)
  {
    long long v5 = *(NSObject **)(v1 + 40);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      int v6 = "#I Preflight only for prox setup device";
      goto LABEL_10;
    }
    goto LABEL_55;
  }
  uint64_t v4 = *(void *)(v1 + 304);
  for (uint64_t i = *(void *)(v1 + 312); i != v4; uint64_t i = sub_100B615AC(i - 1520))
    ;
  *(void *)(v1 + 312) = v4;
  *(void *)(v1 + 328) = v4;
  uint64_t v37 = 0;
  uint64_t v38 = 0;
  uint64_t v39 = 0;
  sub_10098EB38((uint64_t)v2, &v37);
  if (v37 == v38)
  {
    long long v23 = *(NSObject **)(v1 + 40);
    if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "#I No vinyl details available for enabled plan", buf, 2u);
    }
    goto LABEL_54;
  }
  uint64_t v7 = *(void *)(v1 + 600);
  uint64_t v8 = *(void *)(v1 + 608);
  if (v7 != v8)
  {
    while (*(_DWORD *)(v7 + 4) != 2)
    {
      v7 += 88;
      if (v7 == v8) {
        goto LABEL_51;
      }
    }
  }
  if (v7 == v8)
  {
LABEL_51:
    xpc_object_t v24 = *(NSObject **)(v1 + 40);
    if (!os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
    {
LABEL_54:
      *(void *)long long buf = &v37;
      sub_100992538((void ***)buf);
      goto LABEL_55;
    }
    *(_WORD *)long long buf = 0;
LABEL_87:
    _os_log_error_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "No CSN on target device", buf, 2u);
    goto LABEL_54;
  }
  if (*(_DWORD *)(v7 + 12) != 3)
  {
    xpc_object_t v24 = *(NSObject **)(v1 + 40);
    if (!os_log_type_enabled(v24, OS_LOG_TYPE_ERROR)) {
      goto LABEL_54;
    }
    *(_WORD *)long long buf = 0;
    goto LABEL_87;
  }
  long long v45 = *(_OWORD *)(v7 + 16);
  uint64_t v34 = 0;
  uint64_t v35 = 0;
  uint64_t v36 = 0;
  sub_100B40EE8(&v34, v1);
  uint64_t v10 = v37;
  for (uint64_t j = v38; v10 != j; v10 += 232)
  {
    char v11 = (_OWORD *)(v10 + 16);
    buf[0] = 0;
    uint64_t v12 = sub_1000D8740(v34, v35, (unsigned __int8 **)(v10 + 16));
    if (v12 == v35)
    {
      if (sub_10098EDA0((uint64_t)v2, v10 + 16))
      {
        memset(v44, 0, sizeof(v44));
        sub_10098FCF4(v2, (uint64_t)v44);
        *(_OWORD *)&v44[24] = *(_OWORD *)(v10 + 216);
        if (*(char *)(v10 + 39) < 0)
        {
          sub_10004FC84(&v44[40], *(void **)(v10 + 16), *(void *)(v10 + 24));
        }
        else
        {
          long long v16 = *v11;
          *(void *)&v44[56] = *(void *)(v10 + 32);
          *(_OWORD *)&v44[40] = v16;
        }
        bzero(buf, 0x5F0uLL);
        if (sub_100B409A4(v1, (uint64_t)buf, (uint64_t)v44, &v45, (const std::string *)(v1 + 776)))
        {
          unint64_t v18 = *(void *)(v1 + 312);
          if (v18 >= *(void *)(v1 + 320))
          {
            uint64_t v19 = sub_100B6387C((void *)(v1 + 304), (uint64_t)buf);
          }
          else
          {
            sub_100B63A1C(*(void *)(v1 + 312), (uint64_t)buf);
            uint64_t v19 = v18 + 1520;
            *(void *)(v1 + 312) = v18 + 1520;
          }
          *(void *)(v1 + 312) = v19;
        }
        else
        {
          BOOL v20 = *(NSObject **)(v1 + 40);
          if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
          {
            if (*(char *)(v10 + 39) < 0) {
              char v11 = *(_OWORD **)v11;
            }
            *(_DWORD *)long long v40 = 136315138;
            uint64_t v41 = v11;
            _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#I Unable to create transfer plan : %s", v40, 0xCu);
          }
        }
        sub_100B615AC((uint64_t)buf);
        if ((v44[63] & 0x80000000) != 0) {
          operator delete(*(void **)&v44[40]);
        }
        if ((v44[23] & 0x80000000) != 0) {
          operator delete(*(void **)v44);
        }
        continue;
      }
      long long v17 = *(NSObject **)(v1 + 40);
      if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
      {
        if (*(char *)(v10 + 39) < 0) {
          char v11 = *(_OWORD **)v11;
        }
        *(_DWORD *)long long buf = 136315138;
        *(void *)&_OWORD buf[4] = v11;
        char v14 = v17;
        __int16 v15 = "#I No transfer credentials available for plan : %s";
        goto LABEL_31;
      }
    }
    else
    {
      BOOL v13 = *(NSObject **)(v1 + 40);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
      {
        if (*(char *)(v10 + 39) < 0) {
          char v11 = *(_OWORD **)v11;
        }
        *(_DWORD *)long long buf = 136315138;
        *(void *)&_OWORD buf[4] = v11;
        char v14 = v13;
        __int16 v15 = "#I Skip preflight for OnDeviceTransferred plan : %s";
LABEL_31:
        _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, v15, buf, 0xCu);
      }
    }
  }
  uint64_t v21 = *(void *)(v1 + 304);
  uint64_t v22 = *(void *)(v1 + 312);
  if (v21 == v22)
  {
    long long v25 = *(NSObject **)(v1 + 40);
    if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "#I no active plan to preflight", buf, 2u);
    }
  }
  else
  {
    *(void *)(v1 + 328) = v21;
    sub_100093B44((std::string *)(v1 + 336), (const std::string *)(v21 + 1048));
  }
  *(void *)long long buf = &v34;
  sub_100047F64((void ***)buf);
  *(void *)long long buf = &v37;
  sub_100992538((void ***)buf);
  if (v21 == v22) {
    goto LABEL_55;
  }
  uint64_t v26 = *(NSObject **)(v1 + 40);
  if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v28 = *(void *)(v1 + 304);
    uint64_t v27 = *(void *)(v1 + 312);
    memset(v44, 0, 24);
    if (v28 != v27)
    {
      if (*(char *)(v28 + 1071) < 0)
      {
        sub_10004FC84(buf, *(void **)(v28 + 1048), *(void *)(v28 + 1056));
      }
      else
      {
        *(_OWORD *)long long buf = *(_OWORD *)(v28 + 1048);
        uint64_t v43 = *(void *)(v28 + 1064);
      }
      *(_OWORD *)long long v44 = *(_OWORD *)buf;
      *(void *)&v44[16] = v43;
      for (uint64_t k = v28 + 1520; k != v27; k += 1520)
      {
        HIBYTE(v43) = 2;
        strcpy((char *)buf, ", ");
        std::string::append((std::string *)v44, (const std::string::value_type *)buf, 2uLL);
        if (SHIBYTE(v43) < 0) {
          operator delete(*(void **)buf);
        }
        if (*(char *)(k + 1071) < 0)
        {
          sub_10004FC84(buf, *(void **)(k + 1048), *(void *)(k + 1056));
        }
        else
        {
          long long v30 = *(_OWORD *)(k + 1048);
          uint64_t v43 = *(void *)(k + 1064);
          *(_OWORD *)long long buf = v30;
        }
        if (v43 >= 0) {
          char v31 = buf;
        }
        else {
          char v31 = *(uint8_t **)buf;
        }
        if (v43 >= 0) {
          std::string::size_type v32 = HIBYTE(v43);
        }
        else {
          std::string::size_type v32 = *(void *)&buf[8];
        }
        std::string::append((std::string *)v44, (const std::string::value_type *)v31, v32);
        if (SHIBYTE(v43) < 0) {
          operator delete(*(void **)buf);
        }
      }
    }
    unsigned __int8 v33 = v44;
    if (v44[23] < 0) {
      unsigned __int8 v33 = *(unsigned char **)v44;
    }
    *(_DWORD *)long long buf = 136315138;
    *(void *)&_OWORD buf[4] = v33;
    _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "#I preflight iccids : [%s]", buf, 0xCu);
    if ((v44[23] & 0x80000000) != 0) {
      operator delete(*(void **)v44);
    }
  }
  sub_100B47C9C(v1);
}

void sub_100B65D38(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *__p,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  if (*(char *)(v26 - 153) < 0) {
    operator delete(*(void **)(v26 - 176));
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100B65DF0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100B65E30()
{
}

void *sub_100B65E3C(void *a1)
{
  *a1 = off_101A3EA70;
  sub_100060644(a1 + 4);
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_100B65E8C(void *a1)
{
  *a1 = off_101A3EA70;
  sub_100060644(a1 + 4);
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete();
}

void *sub_100B65EFC(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t v2 = operator new(0x40uLL);
  void *v2 = off_101A3EA70;
  sub_100B6654C((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_100B65F50(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100B65F64(uint64_t a1, void *a2)
{
  *a2 = off_101A3EA70;
  return sub_100B6654C((uint64_t)(a2 + 1), a1 + 8);
}

void sub_100B65F90(uint64_t a1)
{
}

void sub_100B65F98(void *a1)
{
  sub_100B665B4((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_100B65FD4(void *a1, unsigned __int8 *a2, const void **a3)
{
  uint64_t v4 = (std::__shared_weak_count *)a1[3];
  if (v4)
  {
    int v6 = *a2;
    uint64_t v7 = a1[1];
    uint64_t v8 = std::__shared_weak_count::lock(v4);
    if (v8 && a1[2])
    {
      uint64_t v9 = *(std::__shared_weak_count **)(v7 + 72);
      if (v9)
      {
        uint64_t v10 = std::__shared_weak_count::lock(v9);
        if (v10)
        {
          uint64_t v11 = *(void *)(v7 + 64);
          if (v11)
          {
            *(unsigned char *)(v7 + 135) = 0;
            uint64_t v12 = *(NSObject **)(v7 + 40);
            if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)long long buf = 136315138;
              *(void *)&_OWORD buf[4] = "kTransferPlanTransferReq";
              _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I Response for: [%s]", buf, 0xCu);
            }
            memset(v26, 0, sizeof(v26));
            sub_100B40EE8(v26, v7);
            sub_100B4E710(v7, a3, v26);
            sub_100B4F614(v7, (uint64_t *)v26);
            if (v6)
            {
              BOOL v13 = *(NSObject **)(v7 + 40);
              int v14 = 70004;
              if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
              {
                *(_WORD *)long long buf = 0;
                _os_log_error_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "cu - plan transfer request timeout", buf, 2u);
              }
              int v15 = 1;
            }
            else
            {
              if (*a3) {
                uint64_t v19 = sub_100080778;
              }
              else {
                uint64_t v19 = 0;
              }
              if (v19)
              {
LABEL_58:
                sub_1000607A8((uint64_t)(a1 + 4), 1);
                *(void *)long long buf = v26;
                sub_100047F64((void ***)buf);
LABEL_59:
                sub_10004D2C8(v10);
                goto LABEL_60;
              }
              int v14 = 70001;
              BOOL v20 = *(NSObject **)(v7 + 40);
              if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
              {
                *(_WORD *)long long buf = 0;
                _os_log_error_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, "cu - invalid plan transfer response", buf, 2u);
              }
              int v15 = 5;
            }
            long long __p = 0u;
            long long v36 = 0u;
            long long v34 = 0u;
            long long v32 = 0u;
            *(_OWORD *)unsigned __int8 v33 = 0u;
            *(_OWORD *)long long v30 = 0u;
            long long v31 = 0u;
            long long v28 = 0u;
            long long v29 = 0u;
            *(_OWORD *)long long buf = 0u;
            sub_100058DB0(buf, "NoCarrierName");
            WORD4(v28) = 257;
            *(_DWORD *)((char *)&v28 + 10) = 0;
            HIWORD(v28) = 0;
            LODWORD(v29) = v15;
            BYTE4(v29) = 1;
            DWORD2(v29) = v14;
            BYTE12(v29) = 1;
            LOBYTE(v30[0]) = 0;
            BYTE8(v31) = 0;
            LOWORD(v32) = 0;
            if (*(unsigned char *)(v7 + 129))
            {
              LOBYTE(v16) = 4;
            }
            else
            {
              unsigned int v21 = *(unsigned __int8 *)(v7 + 128);
              if (v21 > 4) {
                LOBYTE(v16) = 0;
              }
              else {
                unint64_t v16 = 0x503020100uLL >> (8 * v21);
              }
            }
            BYTE2(v32) = v16;
            int v22 = (*(uint64_t (**)(uint64_t))(*(void *)v11 + 208))(v11);
            if (v22) {
              char v23 = 3;
            }
            else {
              char v23 = 2;
            }
            if (v22) {
              char v24 = 3;
            }
            else {
              char v24 = 0;
            }
            if (*(unsigned char *)(v7 + 592)) {
              char v24 = 1;
            }
            if (*(unsigned char *)(v7 + 592) == 2) {
              char v25 = v23;
            }
            else {
              char v25 = v24;
            }
            BYTE3(v32) = v25;
            WORD2(v32) = 1;
            DWORD2(v32) = 0;
            LOBYTE(v33[0]) = 0;
            BYTE8(v34) = 0;
            LOBYTE(__p) = 0;
            BYTE8(v36) = 0;
            (*(void (**)(uint64_t, uint8_t *))(*(void *)v11 + 96))(v11, buf);
            if (BYTE8(v36) && SBYTE7(v36) < 0) {
              operator delete((void *)__p);
            }
            if (BYTE8(v34) && SBYTE7(v34) < 0) {
              operator delete(v33[0]);
            }
            if (BYTE8(v31) && SBYTE7(v31) < 0) {
              operator delete(v30[0]);
            }
            if (SBYTE7(v28) < 0) {
              operator delete(*(void **)buf);
            }
            goto LABEL_58;
          }
        }
      }
      else
      {
        uint64_t v10 = 0;
      }
      unint64_t v18 = *(NSObject **)(v7 + 40);
      if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "invalid delegate to submit transfer details metric", buf, 2u);
      }
      if (!v10) {
        goto LABEL_60;
      }
      goto LABEL_59;
    }
  }
  else
  {
    uint64_t v8 = 0;
  }
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)buf, kCtLoggingSystemName, "cp.tr.ctr");
  long long v17 = *(NSObject **)&buf[8];
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
  if (!os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
  {
    if (!v8) {
      return;
    }
LABEL_60:
    sub_10004D2C8(v8);
    return;
  }
  *(_WORD *)long long buf = 0;
  _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "invalid CellularPlanTransferFlowController (weak_ptr)", buf, 2u);
  if (v8) {
    goto LABEL_60;
  }
}

void sub_100B66450(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,uint64_t a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,char a28,uint64_t a29,uint64_t a30,void *a31,uint64_t a32,int a33,__int16 a34,char a35,char a36,char a37,void *__p,uint64_t a39,int a40,__int16 a41,char a42,char a43,char a44)
{
  if (a44 && a43 < 0) {
    operator delete(__p);
  }
  if (a37 && a36 < 0) {
    operator delete(a31);
  }
  if (a28 && a27 < 0) {
    operator delete(a22);
  }
  if (a18 < 0) {
    operator delete(a13);
  }
  a13 = &a10;
  sub_100047F64((void ***)&a13);
  sub_10004D2C8(v45);
  sub_10004D2C8(v44);
  _Unwind_Resume(a1);
}

uint64_t sub_100B66500(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100B66540()
{
}

uint64_t sub_100B6654C(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = *(_OWORD *)a2;
  uint64_t v3 = *(void *)(a2 + 16);
  *(void *)(a1 + 16) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  sub_1000DFC90(a1 + 24, a2 + 24);
  return a1;
}

void sub_100B6659C(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(std::__shared_weak_count **)(v1 + 16);
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  _Unwind_Resume(exception_object);
}

void sub_100B665B4(uint64_t a1)
{
  sub_100060644((void *)(a1 + 24));
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2)
  {
    std::__shared_weak_count::__release_weak(v2);
  }
}

uint64_t sub_100B66600(uint64_t a1)
{
  sub_100030EE0(*(void *)a1, *(char **)(a1 + 16));
  uint64_t v2 = *(void *)(a1 + 8);
  if (v2)
  {
    uint64_t v3 = *(void *)(v2 + 16);
    if (v3)
    {
      do
      {
        uint64_t v2 = v3;
        uint64_t v3 = *(void *)(v3 + 16);
      }
      while (v3);
      *(void *)(a1 + 8) = v2;
    }
    sub_100030EE0(*(void *)a1, (char *)v2);
  }
  return a1;
}

void *sub_100B66658(void *a1)
{
  *a1 = off_101A3EAF0;
  uint64_t v2 = a1[8];
  if (v2)
  {
    dispatch_group_leave(v2);
    uint64_t v3 = a1[8];
    if (v3) {
      dispatch_release(v3);
    }
  }
  uint64_t v4 = (std::__shared_weak_count *)a1[7];
  if (v4) {
    sub_10004D2C8(v4);
  }
  long long v5 = (std::__shared_weak_count *)a1[5];
  if (v5) {
    sub_10004D2C8(v5);
  }
  int v6 = (std::__shared_weak_count *)a1[3];
  if (v6) {
    std::__shared_weak_count::__release_weak(v6);
  }
  return a1;
}

void sub_100B666D4(void *a1)
{
  *a1 = off_101A3EAF0;
  uint64_t v2 = a1[8];
  if (v2)
  {
    dispatch_group_leave(v2);
    uint64_t v3 = a1[8];
    if (v3) {
      dispatch_release(v3);
    }
  }
  uint64_t v4 = (std::__shared_weak_count *)a1[7];
  if (v4) {
    sub_10004D2C8(v4);
  }
  long long v5 = (std::__shared_weak_count *)a1[5];
  if (v5) {
    sub_10004D2C8(v5);
  }
  int v6 = (std::__shared_weak_count *)a1[3];
  if (v6) {
    std::__shared_weak_count::__release_weak(v6);
  }

  operator delete();
}

void *sub_100B66770(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t v2 = operator new(0x48uLL);
  void *v2 = off_101A3EAF0;
  sub_100B66FB0((uint64_t)(v2 + 1), v1);
  return v2;
}

uint64_t sub_100B667C4(uint64_t a1, void *a2)
{
  *a2 = off_101A3EAF0;
  return sub_100B66FB0((uint64_t)(a2 + 1), a1 + 8);
}

void sub_100B667F0(uint64_t a1)
{
}

void sub_100B667F8(void *a1)
{
  sub_100B67040(a1 + 1);

  operator delete(a1);
}

void sub_100B66834(uint64_t a1, uint64_t *a2)
{
  uint64_t v4 = *a2;
  uint64_t v3 = (std::string *)a2[1];
  uint64_t v47 = *a2;
  uint64_t v48 = v3;
  long long v5 = *((_OWORD *)a2 + 1);
  long long v49 = v5;
  a2[1] = 0;
  a2[2] = 0;
  a2[3] = 0;
  int v6 = *(std::__shared_weak_count **)(a1 + 24);
  if (!v6)
  {
    uint64_t v8 = 0;
    goto LABEL_20;
  }
  uint64_t v46 = (std::string *)v5;
  uint64_t v7 = *(void *)(a1 + 8);
  uint64_t v8 = std::__shared_weak_count::lock(v6);
  if (!v8 || !*(void *)(a1 + 16))
  {
LABEL_20:
    ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&buf, kCtLoggingSystemName, "cp.tr.ctr");
    uint64_t v19 = *((void *)&buf + 1);
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&buf);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
    {
      LOWORD(buf) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "invalid CellularPlanTransferFlowController (weak_ptr)", (uint8_t *)&buf, 2u);
      if (v8) {
        goto LABEL_76;
      }
    }
    else if (v8)
    {
      goto LABEL_76;
    }
    goto LABEL_77;
  }
  if (!(_BYTE)v4)
  {
    BOOL v20 = *(NSObject **)(v7 + 40);
    if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
    {
      LOWORD(buf) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, "Device info cloud fetch failed", (uint8_t *)&buf, 2u);
    }
    if (!*(unsigned char *)(v7 + 1020))
    {
      *(_DWORD *)(v7 + 1016) = 2;
      *(unsigned char *)(v7 + 1020) = 1;
    }
    *(_DWORD *)(v7 + 1024) = HIDWORD(v47);
    *(unsigned char *)(v7 + 1028) = 1;
    *(unsigned char *)(v7 + 134) = 1;
    sub_100B42C90(v7);
    goto LABEL_76;
  }
  uint64_t v9 = (void **)(v7 + 168);
  if ((std::string **)(v7 + 168) == &v48) {
    goto LABEL_37;
  }
  uint64_t v10 = *(void *)(v7 + 184);
  unint64_t v11 = 0x6DB6DB6DB6DB6DB7 * (((char *)v46 - (char *)v3) >> 3);
  uint64_t v12 = *(void *)(v7 + 168);
  if (0x6DB6DB6DB6DB6DB7 * ((v10 - v12) >> 3) >= v11)
  {
    if (0x6DB6DB6DB6DB6DB7 * ((*(void *)(v7 + 176) - v12) >> 3) >= v11)
    {
      int v22 = sub_100B670B4(v3, v46, *(std::string **)(v7 + 168));
      for (uint64_t i = *(void *)(v7 + 176); (std::string *)i != v22; sub_1003424C4(i))
        i -= 56;
      *(void *)(v7 + 176) = v22;
      goto LABEL_37;
    }
    unsigned int v21 = (std::string *)((char *)v3 + 8 * ((*(void *)(v7 + 176) - v12) >> 3));
    sub_100B670B4(v3, v21, *(std::string **)(v7 + 168));
    uint64_t v18 = sub_1003423B4(v7 + 184, (uint64_t)v21, (uint64_t)v46, *(void *)(v7 + 176));
  }
  else
  {
    if (v12)
    {
      uint64_t v13 = *(void *)(v7 + 176);
      int v14 = *(void **)(v7 + 168);
      if (v13 != v12)
      {
        do
        {
          v13 -= 56;
          sub_1003424C4(v13);
        }
        while (v13 != v12);
        int v14 = *v9;
      }
      *(void *)(v7 + 176) = v12;
      operator delete(v14);
      uint64_t v10 = 0;
      std::__shared_weak_count *v9 = 0;
      *(void *)(v7 + 176) = 0;
      *(void *)(v7 + 184) = 0;
    }
    if (v11 > 0x492492492492492) {
      sub_10006A748();
    }
    unint64_t v15 = 0x6DB6DB6DB6DB6DB7 * (v10 >> 3);
    uint64_t v16 = 2 * v15;
    if (2 * v15 <= v11) {
      uint64_t v16 = 0x6DB6DB6DB6DB6DB7 * (((char *)v46 - (char *)v3) >> 3);
    }
    if (v15 >= 0x249249249249249) {
      unint64_t v17 = 0x492492492492492;
    }
    else {
      unint64_t v17 = v16;
    }
    sub_10034235C((void *)(v7 + 168), v17);
    uint64_t v18 = sub_1003423B4(v7 + 184, (uint64_t)v3, (uint64_t)v46, *(void *)(v7 + 176));
  }
  *(void *)(v7 + 176) = v18;
LABEL_37:
  char v24 = *(std::__shared_weak_count **)(v7 + 16);
  if (!v24
    || (uint64_t v25 = *(void *)(v7 + 112),
        uint64_t v26 = *(void *)(a1 + 32),
        uint64_t v27 = *(void *)(v7 + 8),
        (long long v28 = std::__shared_weak_count::lock(v24)) == 0))
  {
    sub_100088B9C();
  }
  long long v29 = v28;
  atomic_fetch_add_explicit(&v28->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v28);
  uint64_t v31 = *(void *)(a1 + 48);
  uint64_t v30 = *(void *)(a1 + 56);
  if (v30) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v30 + 8), 1uLL, memory_order_relaxed);
  }
  long long v32 = *(NSObject **)(a1 + 64);
  if (v32)
  {
    dispatch_retain(*(dispatch_object_t *)(a1 + 64));
    dispatch_group_enter(v32);
  }
  long long v56 = 0;
  unsigned __int8 v33 = operator new(0x38uLL);
  *unsigned __int8 v33 = off_101A3EB60;
  v33[1] = v7;
  unint64_t v33[2] = v27;
  v33[3] = v29;
  v33[4] = v31;
  v33[5] = v30;
  v33[6] = v32;
  long long v56 = v33;
  (*(void (**)(uint64_t, uint64_t, void *))(*(void *)v25 + 56))(v25, v26, v55);
  sub_1003216C8(v55);
  long long v34 = *(NSObject **)(a1 + 64);
  if (v34)
  {
    dispatch_retain(v34);
    dispatch_group_enter(v34);
  }
  v53[0] = off_101A3EBE0;
  v53[1] = v34;
  long long v54 = v53;
  if (*(unsigned char *)(v7 + 840)) {
    goto LABEL_75;
  }
  uint64_t v35 = *(void *)(v7 + 168);
  uint64_t v36 = *(void *)(v7 + 176);
  if (v35 == v36)
  {
    long long v45 = v53;
    goto LABEL_74;
  }
  int v37 = 0;
  do
  {
    long long v84 = 0u;
    long long v85 = 0u;
    long long v82 = 0u;
    long long v83 = 0u;
    __CFIndex n = 0u;
    long long v81 = 0u;
    long long v78 = 0u;
    long long v79 = 0u;
    long long v76 = 0u;
    long long v77 = 0u;
    long long v74 = 0u;
    long long v75 = 0u;
    long long v72 = 0u;
    long long v73 = 0u;
    long long v70 = 0u;
    long long v71 = 0u;
    long long v68 = 0u;
    long long v69 = 0u;
    long long v66 = 0u;
    long long v67 = 0u;
    long long v64 = 0u;
    long long v65 = 0u;
    long long v62 = 0u;
    long long v63 = 0u;
    long long buf = 0u;
    uint64_t v60 = 0;
    long long v58 = 0u;
    long long v59 = 0u;
    long long __p = 0u;
    memset(v51, 0, sizeof(v51));
    memset(v50, 0, sizeof(v50));
    char v38 = sub_100CD7B0C((os_log_t *)(v7 + 40), (const unsigned __int8 **)(v35 + 24), (void *)(v7 + 720), v51, v50, (uint64_t)&buf, (uint64_t)&__p);
    std::string::size_type v52 = (void **)v50;
    sub_100047F64(&v52);
    std::string::size_type v52 = (void **)v51;
    sub_10010DF1C(&v52);
    if ((v38 & 1) == 0) {
      goto LABEL_67;
    }
    uint64_t v39 = HIBYTE(__n);
    if (__n >= 0) {
      uint64_t v40 = HIBYTE(__n);
    }
    else {
      uint64_t v40 = __n;
    }
    if (v40)
    {
      uint64_t v41 = *(unsigned __int8 *)(v7 + 719);
      int v42 = (char)v41;
      if ((v41 & 0x80u) != 0) {
        uint64_t v41 = *(void *)(v7 + 704);
      }
      if (v40 == v41)
      {
        if (v42 >= 0) {
          uint64_t v43 = (unsigned __int8 *)(v7 + 696);
        }
        else {
          uint64_t v43 = *(unsigned __int8 **)(v7 + 696);
        }
        if ((HIBYTE(__n) & 0x80) != 0)
        {
          if (!memcmp(*((const void **)&v79 + 1), v43, __n)) {
            goto LABEL_67;
          }
        }
        else
        {
          if (!HIBYTE(__n)) {
            goto LABEL_67;
          }
          long long v44 = (unsigned __int8 *)&v79 + 8;
          while (*v44 == *v43)
          {
            ++v44;
            ++v43;
            if (!--v39) {
              goto LABEL_67;
            }
          }
        }
      }
    }
    ++v37;
LABEL_67:
    if (SBYTE7(v58) < 0) {
      operator delete((void *)__p);
    }
    sub_1000C52BC((uint64_t)&buf);
    v35 += 56;
  }
  while (v35 != v36);
  if (v37)
  {
    sub_1003351AC((void *)(v7 + 488), (uint64_t)v53);
    goto LABEL_75;
  }
  long long v45 = v54;
  if (!v54) {
    sub_10007B600();
  }
LABEL_74:
  (*(void (**)(void *))(*v45 + 48))(v45);
LABEL_75:
  sub_10003B34C(v53);
LABEL_76:
  sub_10004D2C8(v8);
LABEL_77:
  *(void *)&long long buf = &v48;
  sub_10034251C((void ***)&buf);
}

void sub_100B66E84(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18, uint64_t a19, uint64_t a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,char a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29,uint64_t a30,uint64_t a31,uint64_t a32,void *__p,uint64_t a34,int a35,__int16 a36,char a37,char a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44)
{
  *(void *)(v45 + 176) = v46;
  sub_10004D2C8(v44);
  a44 = a10;
  sub_10034251C((void ***)&a44);
  _Unwind_Resume(a1);
}

uint64_t sub_100B66F64(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100B66FA4()
{
}

uint64_t sub_100B66FB0(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = *(_OWORD *)a2;
  uint64_t v3 = *(void *)(a2 + 16);
  *(void *)(a1 + 16) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  uint64_t v4 = *(void *)(a2 + 32);
  *(void *)(a1 + 24) = *(void *)(a2 + 24);
  *(void *)(a1 + 32) = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v5 = *(void *)(a2 + 48);
  *(void *)(a1 + 40) = *(void *)(a2 + 40);
  *(void *)(a1 + 48) = v5;
  if (v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
  }
  int v6 = *(NSObject **)(a2 + 56);
  *(void *)(a1 + 56) = v6;
  if (v6)
  {
    dispatch_retain(v6);
    uint64_t v7 = *(NSObject **)(a1 + 56);
    if (v7) {
      dispatch_group_enter(v7);
    }
  }
  return a1;
}

void sub_100B67040(void *a1)
{
  uint64_t v2 = a1[7];
  if (v2)
  {
    dispatch_group_leave(v2);
    uint64_t v3 = a1[7];
    if (v3) {
      dispatch_release(v3);
    }
  }
  uint64_t v4 = (std::__shared_weak_count *)a1[6];
  if (v4) {
    sub_10004D2C8(v4);
  }
  uint64_t v5 = (std::__shared_weak_count *)a1[4];
  if (v5) {
    sub_10004D2C8(v5);
  }
  int v6 = (std::__shared_weak_count *)a1[2];
  if (v6)
  {
    std::__shared_weak_count::__release_weak(v6);
  }
}

std::string *sub_100B670B4(std::string *__str, std::string *a2, std::string *this)
{
  if (__str != a2)
  {
    uint64_t v5 = __str;
    do
    {
      std::string::operator=(this, v5);
      if (this != v5) {
        sub_10006E4A8(this[1].__r_.__value_.__r.__words, v5[1].__r_.__value_.__l.__data_, (char *)v5[1].__r_.__value_.__l.__size_, v5[1].__r_.__value_.__l.__size_ - v5[1].__r_.__value_.__r.__words[0]);
      }
      this[2].__r_.__value_.__r.__words[0] = v5[2].__r_.__value_.__r.__words[0];
      this = (std::string *)((char *)this + 56);
      uint64_t v5 = (std::string *)((char *)v5 + 56);
    }
    while (v5 != a2);
  }
  return this;
}

void *sub_100B6712C(void *a1)
{
  *a1 = off_101A3EB60;
  uint64_t v2 = a1[6];
  if (v2)
  {
    dispatch_group_leave(v2);
    uint64_t v3 = a1[6];
    if (v3) {
      dispatch_release(v3);
    }
  }
  uint64_t v4 = (std::__shared_weak_count *)a1[5];
  if (v4) {
    sub_10004D2C8(v4);
  }
  uint64_t v5 = (std::__shared_weak_count *)a1[3];
  if (v5) {
    std::__shared_weak_count::__release_weak(v5);
  }
  return a1;
}

void sub_100B6719C(void *a1)
{
  *a1 = off_101A3EB60;
  uint64_t v2 = a1[6];
  if (v2)
  {
    dispatch_group_leave(v2);
    uint64_t v3 = a1[6];
    if (v3) {
      dispatch_release(v3);
    }
  }
  uint64_t v4 = (std::__shared_weak_count *)a1[5];
  if (v4) {
    sub_10004D2C8(v4);
  }
  uint64_t v5 = (std::__shared_weak_count *)a1[3];
  if (v5) {
    std::__shared_weak_count::__release_weak(v5);
  }

  operator delete();
}

void *sub_100B6722C(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t v2 = operator new(0x38uLL);
  void *v2 = off_101A3EB60;
  sub_100B67540((uint64_t)(v2 + 1), v1);
  return v2;
}

uint64_t sub_100B67280(uint64_t a1, void *a2)
{
  *a2 = off_101A3EB60;
  return sub_100B67540((uint64_t)(a2 + 1), a1 + 8);
}

void sub_100B672AC(uint64_t a1)
{
}

void sub_100B672B4(void *a1)
{
  sub_100B675B8(a1 + 1);

  operator delete(a1);
}

void sub_100B672F0(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(std::string **)(a2 + 8);
  unint64_t v11 = v3;
  long long v4 = *(_OWORD *)(a2 + 16);
  long long v12 = v4;
  *(void *)(a2 + 16) = 0;
  *(void *)(a2 + 24) = 0;
  *(void *)(a2 + 8) = 0;
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 24);
  if (v5)
  {
    uint64_t v10 = v4;
    uint64_t v6 = *(void *)(a1 + 8);
    uint64_t v7 = std::__shared_weak_count::lock(v5);
    if (v7 && *(void *)(a1 + 16))
    {
      uint64_t v8 = *(NSObject **)(v6 + 40);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(buf) = 134217984;
        *(void *)((char *)&buf + 4) = 0x8F5C28F5C28F5C29 * ((v10 - (uint64_t)v3) >> 3);
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Retrieved %ld blacklist plans", (uint8_t *)&buf, 0xCu);
      }
      if ((std::string **)(v6 + 192) != &v11) {
        sub_10034B104(v6 + 192, v11, (std::string *)v12, 0x8F5C28F5C28F5C29 * ((uint64_t)(v12 - (void)v11) >> 3));
      }
      **(unsigned char **)(a1 + 32) = 1;
      goto LABEL_12;
    }
  }
  else
  {
    uint64_t v7 = 0;
  }
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&buf, kCtLoggingSystemName, "cp.tr.ctr");
  uint64_t v9 = *((void *)&buf + 1);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&buf);
  if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
  {
    LOWORD(buf) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "invalid CellularPlanTransferFlowController (weak_ptr)", (uint8_t *)&buf, 2u);
    if (!v7) {
      goto LABEL_13;
    }
    goto LABEL_12;
  }
  if (v7) {
LABEL_12:
  }
    sub_10004D2C8(v7);
LABEL_13:
  *(void *)&long long buf = &v11;
  sub_10010DF1C((void ***)&buf);
}

void sub_100B674C8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  sub_10004D2C8(v7);
  sub_10010DF1C((void ***)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100B674F4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100B67534()
{
}

uint64_t sub_100B67540(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = *(_OWORD *)a2;
  uint64_t v3 = *(void *)(a2 + 16);
  *(void *)(a1 + 16) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  uint64_t v4 = *(void *)(a2 + 32);
  *(void *)(a1 + 24) = *(void *)(a2 + 24);
  *(void *)(a1 + 32) = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v5 = *(NSObject **)(a2 + 40);
  *(void *)(a1 + 40) = v5;
  if (v5)
  {
    dispatch_retain(v5);
    uint64_t v6 = *(NSObject **)(a1 + 40);
    if (v6) {
      dispatch_group_enter(v6);
    }
  }
  return a1;
}

void sub_100B675B8(void *a1)
{
  uint64_t v2 = a1[5];
  if (v2)
  {
    dispatch_group_leave(v2);
    uint64_t v3 = a1[5];
    if (v3) {
      dispatch_release(v3);
    }
  }
  uint64_t v4 = (std::__shared_weak_count *)a1[4];
  if (v4) {
    sub_10004D2C8(v4);
  }
  uint64_t v5 = (std::__shared_weak_count *)a1[2];
  if (v5)
  {
    std::__shared_weak_count::__release_weak(v5);
  }
}

void *sub_100B67620(void *a1)
{
  *a1 = off_101A3EBE0;
  uint64_t v2 = a1[1];
  if (v2)
  {
    dispatch_group_leave(v2);
    uint64_t v3 = a1[1];
    if (v3) {
      dispatch_release(v3);
    }
  }
  return a1;
}

void sub_100B67678(void *a1)
{
  *a1 = off_101A3EBE0;
  uint64_t v2 = a1[1];
  if (v2)
  {
    dispatch_group_leave(v2);
    uint64_t v3 = a1[1];
    if (v3) {
      dispatch_release(v3);
    }
  }

  operator delete();
}

dispatch_group_t *sub_100B676F0(uint64_t a1)
{
  uint64_t v1 = (NSObject **)(a1 + 8);
  uint64_t v2 = (dispatch_group_t *)operator new(0x10uLL);
  dispatch_group_t *v2 = (dispatch_group_t)off_101A3EBE0;
  sub_1006E8FD8(v2 + 1, v1);
  return v2;
}

dispatch_group_t *sub_100B67744(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_101A3EBE0;
  return sub_1006E8FD8((dispatch_group_t *)(a2 + 8), (NSObject **)(a1 + 8));
}

void sub_100B67770(uint64_t a1)
{
}

void sub_100B67778(NSObject **a1)
{
  sub_1006E9018(a1 + 1);

  operator delete(a1);
}

uint64_t sub_100B677B8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100B677F8()
{
}

void *sub_100B67804(void *a1)
{
  *a1 = off_101A3EC70;
  uint64_t v2 = a1[3];
  if (v2)
  {
    dispatch_group_leave(v2);
    uint64_t v3 = a1[3];
    if (v3) {
      dispatch_release(v3);
    }
  }
  uint64_t v4 = (std::__shared_weak_count *)a1[2];
  if (v4) {
    sub_10004D2C8(v4);
  }
  return a1;
}

void sub_100B67868(void *a1)
{
  *a1 = off_101A3EC70;
  uint64_t v2 = a1[3];
  if (v2)
  {
    dispatch_group_leave(v2);
    uint64_t v3 = a1[3];
    if (v3) {
      dispatch_release(v3);
    }
  }
  uint64_t v4 = (std::__shared_weak_count *)a1[2];
  if (v4) {
    sub_10004D2C8(v4);
  }

  operator delete();
}

void *sub_100B678EC(uint64_t a1)
{
  uint64_t v1 = (void *)(a1 + 8);
  uint64_t v2 = operator new(0x20uLL);
  void *v2 = off_101A3EC70;
  sub_10034B788(v2 + 1, v1);
  return v2;
}

void *sub_100B67940(uint64_t a1, void *a2)
{
  *a2 = off_101A3EC70;
  return sub_10034B788(a2 + 1, (void *)(a1 + 8));
}

void sub_100B6796C(uint64_t a1)
{
}

void sub_100B67974(void *a1)
{
  sub_10034B7E0((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_100B679B0(uint64_t a1, void *a2)
{
  uint64_t v3 = (long long *)*a2;
  uint64_t v5 = a2 + 1;
  uint64_t v4 = (void *)a2[1];
  uint64_t v7 = v3;
  *(void *)&long long v8 = v4;
  *((void *)&v8 + 1) = a2[2];
  if (*((void *)&v8 + 1))
  {
    _OWORD v4[2] = &v8;
    *a2 = v5;
    *uint64_t v5 = 0;
    v5[1] = 0;
  }
  else
  {
    uint64_t v7 = &v8;
    uint64_t v3 = &v8;
  }
  uint64_t v6 = *(uint64_t ***)(a1 + 8);
  if (v6 != (uint64_t **)&v7)
  {
    sub_100846934(v6, v3, &v8);
    uint64_t v4 = (void *)v8;
  }
  sub_100313460((uint64_t)&v7, v4);
}

void sub_100B67A38(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11)
{
}

uint64_t sub_100B67A50(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100B67A90()
{
}

void *sub_100B67A9C(void *result)
{
  uint64_t v1 = (void *)*result;
  *uint64_t result = 0;
  if (v1)
  {
    uint64_t v2 = (std::__shared_weak_count *)v1[6];
    if (v2) {
      sub_10004D2C8(v2);
    }
    uint64_t v3 = (std::__shared_weak_count *)v1[4];
    if (v3) {
      std::__shared_weak_count::__release_weak(v3);
    }
    uint64_t v4 = (std::__shared_weak_count *)v1[1];
    if (v4) {
      sub_10004D2C8(v4);
    }
    operator delete();
  }
  return result;
}

void *sub_100B67B08(uint64_t a1)
{
  uint64_t v153 = a1;
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 32);
  if (v2)
  {
    uint64_t v3 = *(void *)(a1 + 16);
    uint64_t v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      if (!*(void *)(a1 + 24) || !**(unsigned char **)(a1 + 40))
      {
LABEL_296:
        sub_10004D2C8(v4);
        return sub_100B67A9C(&v153);
      }
      long long v151 = v4;
      uint64_t v5 = *(NSObject ***)a1;
      v183[0] = 0;
      v183[1] = 0;
      uint64_t v181 = 0;
      __int16 v182 = v183;
      unsigned int v179 = (uint64_t *)&v180;
      __int16 v180 = 0;
      memset(v178, 0, sizeof(v178));
      sub_100B40EE8(v178, v3);
      std::string v175 = 0;
      __int16 v176 = 0;
      unint64_t v177 = 0;
      CFDictionaryRef v172 = 0;
      uint64_t v173 = 0;
      unint64_t v174 = 0;
      uint64_t v169 = 0;
      uint64_t v170 = 0;
      unint64_t v171 = 0;
      long long v166 = 0;
      std::string v167 = 0;
      uint64_t v168 = 0;
      long long v163 = 0;
      unint64_t v164 = 0;
      unint64_t v165 = 0;
      long long v161 = 0u;
      long long v162 = 0u;
      long long v160 = 0u;
      uint64_t v6 = (os_log_t *)(v3 + 40);
      uint64_t v7 = *(void *)(v3 + 56);
      v159[0] = *(NSObject ***)(v3 + 48);
      v159[1] = (NSObject **)v7;
      if (v7) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v7 + 8), 1uLL, memory_order_relaxed);
      }
      sub_101199D7C((NSObject ***)&v160, (NSObject **)(v3 + 40), v159, v5, (NSObject **)(v3 + 696));
      if (v7) {
        sub_10004D2C8((std::__shared_weak_count *)v7);
      }
      uint64_t v8 = *(void *)(v3 + 168);
      uint64_t v152 = *(void *)(v3 + 176);
      if (v8 != v152)
      {
        while (1)
        {
          long long v218 = 0u;
          long long v219 = 0u;
          long long v216 = 0u;
          long long v217 = 0u;
          long long v214 = 0u;
          long long v215 = 0u;
          long long v212 = 0u;
          long long v213 = 0u;
          long long v210 = 0u;
          long long v211 = 0u;
          long long v208 = 0u;
          long long v209 = 0u;
          long long v206 = 0u;
          long long v207 = 0u;
          long long v204 = 0u;
          long long v205 = 0u;
          long long v202 = 0u;
          long long v203 = 0u;
          long long v200 = 0u;
          long long v201 = 0u;
          long long v198 = 0u;
          long long v199 = 0u;
          long long v196 = 0u;
          *(_OWORD *)long long __src = 0u;
          *(_OWORD *)__s = 0u;
          memset(__str, 0, sizeof(__str));
          memset(&buf, 0, sizeof(buf));
          memset(v158, 0, sizeof(v158));
          char v9 = sub_100CD7B0C(v6, (const unsigned __int8 **)(v8 + 24), (void *)(v3 + 720), (uint64_t *)&buf, v158, (uint64_t)__s, (uint64_t)__str);
          *(void *)v227 = v158;
          sub_100047F64((void ***)v227);
          *(void *)v227 = &buf;
          sub_10010DF1C((void ***)v227);
          if (v9) {
            break;
          }
LABEL_180:
          if ((__str[23] & 0x80000000) != 0) {
            operator delete(*(void **)__str);
          }
          sub_1000C52BC((uint64_t)__s);
          v8 += 56;
          if (v8 == v152) {
            goto LABEL_183;
          }
        }
        uint64_t v10 = *(void *)(v8 + 32);
        if (v10 != *(void *)(v8 + 24))
        {
          memset(v227, 0, sizeof(v227));
          PB::Reader::Reader((PB::Reader *)v227, *(const unsigned __int8 **)(v8 + 24), v10 - *(void *)(v8 + 24));
          *(void *)unsigned int v221 = 0;
          *(void *)&v221[8] = 0;
          buf.__r_.__value_.__r.__words[0] = (std::string::size_type)&off_101A17F50;
          *(_OWORD *)&buf.__r_.__value_.__r.__words[1] = 0uLL;
          sub_1008E296C((uint64_t)&buf, (PB::Reader *)v227);
          if (v164 >= v165)
          {
            unint64_t v12 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v164 - (void)v163) >> 3);
            unint64_t v13 = v12 + 1;
            if (v12 + 1 > 0x666666666666666) {
              sub_10006A748();
            }
            if (0x999999999999999ALL * ((uint64_t)(v165 - (void)v163) >> 3) > v13) {
              unint64_t v13 = 0x999999999999999ALL * ((uint64_t)(v165 - (void)v163) >> 3);
            }
            if (0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v165 - (void)v163) >> 3) >= 0x333333333333333) {
              unint64_t v14 = 0x666666666666666;
            }
            else {
              unint64_t v14 = v13;
            }
            if (v14)
            {
              if (v14 > 0x666666666666666) {
                sub_10006A7CC();
              }
              unint64_t v15 = (char *)operator new(40 * v14);
            }
            else
            {
              unint64_t v15 = 0;
            }
            uint64_t v16 = &v15[40 * v14];
            uint64_t v17 = sub_1008E268C((uint64_t)&v15[40 * v12], (uint64_t)&buf);
            uint64_t v11 = v17 + 40;
            uint64_t v19 = (uint64_t)v163;
            uint64_t v18 = (char *)v164;
            if ((char *)v164 == v163)
            {
              long long v163 = (char *)v17;
              unint64_t v164 = v17 + 40;
              unint64_t v165 = (unint64_t)v16;
            }
            else
            {
              do
              {
                v18 -= 40;
                uint64_t v17 = sub_1008E27C0(v17 - 40, (uint64_t)v18);
              }
              while (v18 != (char *)v19);
              uint64_t v18 = v163;
              unint64_t v20 = v164;
              long long v163 = (char *)v17;
              unint64_t v164 = v11;
              unint64_t v165 = (unint64_t)v16;
              if ((char *)v20 != v18)
              {
                unint64_t v21 = v20 - 40;
                int v22 = (char *)(v20 - 40);
                char v23 = (void (***)(char *))(v20 - 40);
                do
                {
                  char v24 = *v23;
                  v23 -= 5;
                  (*v24)(v22);
                  v21 -= 40;
                  BOOL v58 = v22 == v18;
                  int v22 = (char *)v23;
                }
                while (!v58);
              }
            }
            if (v18) {
              operator delete(v18);
            }
          }
          else
          {
            uint64_t v11 = sub_1008E268C(v164, (uint64_t)&buf) + 40;
          }
          unint64_t v164 = v11;
          sub_1008E25A0((PB::Base *)&buf);
        }
        long long __p = 0;
        uint64_t v156 = 0;
        uint64_t v157 = 0;
        memset(v227, 0, 24);
        sub_10098FB74((uint64_t *)__s, (uint64_t)v227);
        long long v224 = 0uLL;
        uint64_t v225 = 0;
        sub_10098FC00((uint64_t)__s, v25, (uint64_t)&v224);
        v189 = 0;
        uint64_t v188 = 0;
        uint64_t v190 = 0;
        sub_10098FAB8((uint64_t *)__s, (uint64_t)&v188);
        uint64_t v26 = *(char **)(v3 + 192);
        uint64_t v27 = *(char **)(v3 + 200);
        if (v26 != v27)
        {
          long long v28 = v26 + 95;
          do
          {
            if (sub_10010E128((uint64_t)v227, (void **)(v28 - 71)) || sub_10010E128((uint64_t)&v224, (void **)(v28 - 47)))
            {
              if (sub_10010E128((uint64_t)&v188, (void **)(v28 - 23)))
              {
                sub_10098FD84((uint64_t)__s, (unsigned __int8 **)(v28 - 23));
              }
              else
              {
                if (*(v28 - 48) < 0)
                {
                  sub_10004FC84(&buf, *(void **)(v28 - 71), *(void *)(v28 - 63));
                }
                else
                {
                  long long v29 = *(_OWORD *)(v28 - 71);
                  buf.__r_.__value_.__r.__words[2] = *(void *)(v28 - 55);
                  *(_OWORD *)&buf.__r_.__value_.__l.__data_ = v29;
                }
                if (*(v28 - 24) < 0)
                {
                  sub_10004FC84(v221, *(void **)(v28 - 47), *(void *)(v28 - 39));
                }
                else
                {
                  long long v30 = *(_OWORD *)(v28 - 47);
                  *(void *)&v221[16] = *(void *)(v28 - 31);
                  *(_OWORD *)unsigned int v221 = v30;
                }
                if (*v28 < 0)
                {
                  sub_10004FC84(&v222, *(void **)(v28 - 23), *(void *)(v28 - 15));
                }
                else
                {
                  long long v31 = *(_OWORD *)(v28 - 23);
                  uint64_t v223 = *(void *)(v28 - 7);
                  long long v222 = v31;
                }
                sub_1002FC1CC((uint64_t *)&__p, (long long *)&buf);
                if (SHIBYTE(v223) < 0) {
                  operator delete((void *)v222);
                }
                if ((v221[23] & 0x80000000) != 0) {
                  operator delete(*(void **)v221);
                }
                if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
                  operator delete(buf.__r_.__value_.__l.__data_);
                }
              }
            }
            long long v32 = v28 + 105;
            v28 += 200;
          }
          while (v32 != v27);
        }
        sub_10005CD2C((uint64_t)&v188, v189);
        sub_10005CD2C((uint64_t)&v224, *((char **)&v224 + 1));
        sub_10005CD2C((uint64_t)v227, *(char **)&v227[8]);
        unsigned __int8 v33 = (std::string *)__p;
        if (v156 - (uint64_t)__p >= 1)
        {
          uint64_t v34 = (v156 - (uint64_t)__p) / 72;
          uint64_t v35 = (std::string *)v167;
          if ((uint64_t)(0x8E38E38E38E38E39 * ((v168 - (uint64_t)v167) >> 3)) >= v34)
          {
            if (v34 <= 0)
            {
              uint64_t v40 = (std::string *)((char *)__p + 72 * v34);
              sub_100427370((uint64_t)&v166, (uint64_t)v167, (unint64_t)v167, (uint64_t)v167 + 72 * v34);
              sub_100428F20((int)&buf, v33, v40, v35);
            }
            else
            {
              std::string v167 = (long long *)sub_100322A2C((uint64_t)&v168, (uint64_t)__p, v156, (uint64_t)v167);
            }
          }
          else
          {
            unint64_t v36 = 0x8E38E38E38E38E39 * (((char *)v167 - (char *)v166) >> 3);
            unint64_t v37 = v36 + v34;
            if (v36 + v34 > 0x38E38E38E38E38ELL) {
              sub_10006A748();
            }
            if (0x1C71C71C71C71C72 * ((v168 - (uint64_t)v166) >> 3) > v37) {
              unint64_t v37 = 0x1C71C71C71C71C72 * ((v168 - (uint64_t)v166) >> 3);
            }
            if (0x8E38E38E38E38E39 * ((v168 - (uint64_t)v166) >> 3) >= 0x1C71C71C71C71C7) {
              unint64_t v38 = 0x38E38E38E38E38ELL;
            }
            else {
              unint64_t v38 = v37;
            }
            *(void *)&v221[8] = &v168;
            if (v38) {
              uint64_t v39 = (char *)sub_10016ACDC((uint64_t)&v168, v38);
            }
            else {
              uint64_t v39 = 0;
            }
            uint64_t v41 = &v39[72 * v36];
            buf.__r_.__value_.__r.__words[0] = (std::string::size_type)v39;
            buf.__r_.__value_.__l.__size_ = (std::string::size_type)v41;
            buf.__r_.__value_.__r.__words[2] = (std::string::size_type)v41;
            *(void *)unsigned int v221 = &v39[72 * v38];
            uint64_t v42 = 9 * v34;
            std::string::size_type v43 = (std::string::size_type)&v41[72 * v34];
            uint64_t v44 = 8 * v42;
            do
            {
              sub_100322AB0(v41, (long long *)v33);
              v41 += 72;
              v33 += 3;
              v44 -= 72;
            }
            while (v44);
            buf.__r_.__value_.__r.__words[2] = v43;
            sub_100427418(&v166, &buf, (long long *)v35);
            sub_10030EC38((uint64_t)&buf);
          }
        }
        *(_OWORD *)&buf.__r_.__value_.__l.__data_ = 0uLL;
        if (*(_OWORD *)&__str[40] == 0)
        {
          uint64_t v6 = (os_log_t *)(v3 + 40);
        }
        else
        {
          uint64_t v45 = __str[23];
          if (__str[23] < 0) {
            uint64_t v45 = *(void *)&__str[8];
          }
          uint64_t v6 = (os_log_t *)(v3 + 40);
          if (v45)
          {
            buf.__r_.__value_.__r.__words[0] = (std::string::size_type)&__str[40];
            uint64_t v46 = (std::string *)sub_1003DE940((uint64_t **)&v182, (uint64_t)&__str[40], (uint64_t)&unk_10144E20E, &buf);
            std::string::operator=(v46 + 2, (const std::string *)__str);
          }
        }
        if (sub_10119A09C((uint64_t)&v160, (uint64_t)__s)) {
          goto LABEL_179;
        }
        sub_10098FD3C(__s, (uint64_t)&buf);
        uint64_t v47 = *(void *)(v3 + 800);
        if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          std::string::size_type size = HIBYTE(buf.__r_.__value_.__r.__words[2]);
        }
        else {
          std::string::size_type size = buf.__r_.__value_.__l.__size_;
        }
        uint64_t v49 = *(unsigned __int8 *)(v47 + 167);
        int v50 = (char)v49;
        if ((v49 & 0x80u) != 0) {
          uint64_t v49 = *(void *)(v47 + 152);
        }
        if (size == v49)
        {
          CFNumberRef v53 = *(unsigned __int8 **)(v47 + 144);
          char v51 = (unsigned __int8 *)(v47 + 144);
          std::string::size_type v52 = v53;
          if (v50 >= 0) {
            long long v54 = v51;
          }
          else {
            long long v54 = v52;
          }
          if ((*((unsigned char *)&buf.__r_.__value_.__s + 23) & 0x80) != 0)
          {
            long long v59 = (void *)buf.__r_.__value_.__r.__words[0];
            int v60 = memcmp(buf.__r_.__value_.__l.__data_, v54, buf.__r_.__value_.__l.__size_);
            operator delete(v59);
            if (!v60)
            {
LABEL_113:
              if (sub_10119A214((NSObject ***)&v160, (uint64_t)__s, *(double *)(v8 + 48)))
              {
                if (*(unsigned char *)(v3 + 128) == 1 && !*(unsigned char *)(v3 + 129))
                {
                  if (*(unsigned char *)(v3 + 840))
                  {
                    sub_1000C6BDC(v154, v3 + 816);
                    char v75 = sub_10119A774((NSObject ***)&v160, (uint64_t)__s, (uint64_t)v154);
                    sub_10005CD2C((uint64_t)v154, (char *)v154[1]);
                    if ((v75 & 1) == 0) {
                      goto LABEL_179;
                    }
                  }
                }
                *((void *)&v219 + 1) = *(void *)(v8 + 48);
                unint64_t v67 = *(void *)(v3 + 152);
                if (v67 >= *(void *)(v3 + 160))
                {
                  uint64_t v68 = sub_100341B84((uint64_t *)(v3 + 144), (uint64_t)__s);
                }
                else
                {
                  sub_100341CA4(*(void *)(v3 + 152), (uint64_t)__s);
                  uint64_t v68 = v67 + 400;
                  *(void *)(v3 + 152) = v67 + 400;
                }
                *(void *)(v3 + 152) = v68;
                long long v72 = v170;
                if ((unint64_t)v170 >= v171)
                {
                  long long v74 = (unsigned char *)sub_100341D00(&v169, (long long *)__str);
                }
                else
                {
                  if ((__str[23] & 0x80000000) != 0)
                  {
                    sub_10004FC84(v170, *(void **)__str, *(unint64_t *)&__str[8]);
                  }
                  else
                  {
                    long long v73 = *(_OWORD *)__str;
                    *((void *)v170 + 2) = *(void *)&__str[16];
                    _OWORD *v72 = v73;
                  }
                  long long v92 = *(_OWORD *)&__str[24];
                  *(_OWORD *)((char *)v72 + 40) = *(_OWORD *)&__str[40];
                  *(_OWORD *)((char *)v72 + 24) = v92;
                  long long v74 = (char *)v72 + 56;
                }
                uint64_t v170 = v74;
                memset(&buf, 0, sizeof(buf));
                if ((_BYTE)v210)
                {
                  if (SBYTE7(v198) < 0)
                  {
                    sub_10004FC84(&buf, __src[0], (unint64_t)__src[1]);
                  }
                  else
                  {
                    *(_OWORD *)&buf.__r_.__value_.__l.__data_ = *(_OWORD *)__src;
                    buf.__r_.__value_.__r.__words[2] = v198;
                  }
                }
                memset(v227, 0, 24);
                sub_10098FAB8((uint64_t *)__s, (uint64_t)v227);
                uint64_t v93 = *(void ***)v227;
                if (*(unsigned char **)v227 != &v227[8])
                {
                  do
                  {
                    sub_1002C3E94(&v179, v93 + 4, (long long *)v93 + 2, (long long *)&buf);
                    uint64_t v94 = (void **)v93[1];
                    if (v94)
                    {
                      do
                      {
                        uint64_t v95 = v94;
                        uint64_t v94 = (void **)*v94;
                      }
                      while (v94);
                    }
                    else
                    {
                      do
                      {
                        uint64_t v95 = (void **)v93[2];
                        BOOL v58 = *v95 == v93;
                        uint64_t v93 = v95;
                      }
                      while (!v58);
                    }
                    uint64_t v93 = v95;
                  }
                  while (v95 != (void **)&v227[8]);
                }
                sub_10005CD2C((uint64_t)v227, *(char **)&v227[8]);
                if ((SHIBYTE(buf.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
                  goto LABEL_179;
                }
                uint64_t v91 = (void *)buf.__r_.__value_.__r.__words[0];
              }
              else
              {
                long long v69 = v176;
                if ((unint64_t)v176 >= v177)
                {
                  long long v71 = (long long *)sub_100048008((uint64_t *)&v175, (long long *)v8);
                }
                else
                {
                  if (*(char *)(v8 + 23) < 0)
                  {
                    sub_10004FC84(v176, *(void **)v8, *(void *)(v8 + 8));
                  }
                  else
                  {
                    long long v70 = *(_OWORD *)v8;
                    v176->__r_.__value_.__r.__words[2] = *(void *)(v8 + 16);
                    *(_OWORD *)&v69->__r_.__value_.__l.__data_ = v70;
                  }
                  long long v71 = (long long *)&v69[1];
                }
                __int16 v176 = (std::string *)v71;
                if (v214 >= 0) {
                  size_t v76 = HIBYTE(v214);
                }
                else {
                  size_t v76 = v214;
                }
                memset(v227, 0, 24);
                sub_1000C140C((uint64_t)v227, v76 + 1);
                if (v227[23] >= 0) {
                  long long v77 = v227;
                }
                else {
                  long long v77 = *(unsigned char **)v227;
                }
                if (v76)
                {
                  if (v214 >= 0) {
                    long long v78 = (char *)&v213 + 8;
                  }
                  else {
                    long long v78 = (char *)*((void *)&v213 + 1);
                  }
                  memmove(v77, v78, v76);
                }
                *(_WORD *)&v77[v76] = 58;
                if (v211 >= 0) {
                  long long v79 = (char *)&v210 + 8;
                }
                else {
                  long long v79 = (const std::string::value_type *)*((void *)&v210 + 1);
                }
                if (v211 >= 0) {
                  std::string::size_type v80 = HIBYTE(v211);
                }
                else {
                  std::string::size_type v80 = v211;
                }
                long long v81 = std::string::append((std::string *)v227, v79, v80);
                std::string::size_type v82 = v81->__r_.__value_.__r.__words[0];
                *(void *)&long long v224 = v81->__r_.__value_.__l.__size_;
                *(void *)((char *)&v224 + 7) = *(std::string::size_type *)((char *)&v81->__r_.__value_.__r.__words[1]
                                                                           + 7);
                char v83 = HIBYTE(v81->__r_.__value_.__r.__words[2]);
                v81->__r_.__value_.__l.__size_ = 0;
                v81->__r_.__value_.__r.__words[2] = 0;
                v81->__r_.__value_.__r.__words[0] = 0;
                long long v84 = v173;
                if ((unint64_t)v173 >= v174)
                {
                  unint64_t v86 = 0xAAAAAAAAAAAAAAABLL * (((char *)v173 - (char *)v172) >> 3);
                  unint64_t v87 = v86 + 1;
                  if (v86 + 1 > 0xAAAAAAAAAAAAAAALL) {
                    sub_1000D8578();
                  }
                  if (0x5555555555555556 * ((uint64_t)(v174 - (void)v172) >> 3) > v87) {
                    unint64_t v87 = 0x5555555555555556 * ((uint64_t)(v174 - (void)v172) >> 3);
                  }
                  if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v174 - (void)v172) >> 3) >= 0x555555555555555) {
                    unint64_t v88 = 0xAAAAAAAAAAAAAAALL;
                  }
                  else {
                    unint64_t v88 = v87;
                  }
                  *(void *)&v221[8] = &v174;
                  if (v88) {
                    uint64_t v89 = (char *)sub_10004812C((uint64_t)&v174, v88);
                  }
                  else {
                    uint64_t v89 = 0;
                  }
                  std::string::size_type v90 = (std::string::size_type)&v89[24 * v86];
                  buf.__r_.__value_.__r.__words[0] = (std::string::size_type)v89;
                  buf.__r_.__value_.__l.__size_ = v90;
                  *(void *)unsigned int v221 = &v89[24 * v88];
                  *(void *)std::string::size_type v90 = v82;
                  *(void *)(v90 + 8) = v224;
                  *(void *)(v90 + 15) = *(void *)((char *)&v224 + 7);
                  *(unsigned char *)(v90 + 23) = v83;
                  buf.__r_.__value_.__r.__words[2] = v90 + 24;
                  sub_100048204((uint64_t *)&v172, &buf);
                  long long v85 = v173;
                  sub_100048174((uint64_t)&buf);
                }
                else
                {
                  v173->__r_.__value_.__r.__words[0] = v82;
                  v84->__r_.__value_.__l.__size_ = v224;
                  *(std::string::size_type *)((char *)&v84->__r_.__value_.__r.__words[1] + 7) = *(void *)((char *)&v224 + 7);
                  *((unsigned char *)&v84->__r_.__value_.__s + 23) = v83;
                  long long v85 = v84 + 1;
                }
                uint64_t v173 = v85;
                if ((v227[23] & 0x80000000) == 0) {
                  goto LABEL_179;
                }
                uint64_t v91 = *(void **)v227;
              }
              operator delete(v91);
LABEL_179:
              buf.__r_.__value_.__r.__words[0] = (std::string::size_type)&__p;
              sub_10030EC88((void ***)&buf);
              goto LABEL_180;
            }
          }
          else
          {
            if (!*((unsigned char *)&buf.__r_.__value_.__s + 23)) {
              goto LABEL_113;
            }
            uint64_t v55 = 0;
            do
            {
              int v56 = buf.__r_.__value_.__s.__data_[v55];
              int v57 = v54[v55];
              BOOL v58 = v56 != v57 || HIBYTE(buf.__r_.__value_.__r.__words[2]) - 1 == v55++;
            }
            while (!v58);
            if (v56 == v57) {
              goto LABEL_113;
            }
          }
        }
        else if ((*((unsigned char *)&buf.__r_.__value_.__s + 23) & 0x80) != 0)
        {
          operator delete(buf.__r_.__value_.__l.__data_);
        }
        uint64_t v61 = *v6;
        if (os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v62 = *(void *)(v3 + 800);
          long long v63 = (void *)(v62 + 144);
          if (*(char *)(v62 + 167) < 0) {
            long long v63 = (void *)*v63;
          }
          long long v64 = (char *)&v213 + 8;
          if (v214 < 0) {
            long long v64 = (char *)*((void *)&v213 + 1);
          }
          long long v65 = (char *)&v210 + 8;
          if (v211 < 0) {
            long long v65 = (char *)*((void *)&v210 + 1);
          }
          long long v66 = &v215;
          if (SBYTE7(v216) < 0) {
            long long v66 = (long long *)v215;
          }
          LODWORD(buf.__r_.__value_.__l.__data_) = 136315906;
          *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v63;
          WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
          *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v64;
          HIWORD(buf.__r_.__value_.__r.__words[2]) = 2080;
          *(void *)unsigned int v221 = v65;
          *(_WORD *)&v221[8] = 2082;
          *(void *)&v221[10] = v66;
          _os_log_impl((void *)&_mh_execute_header, v61, OS_LOG_TYPE_DEFAULT, "#I filter out non %s record. S/N:%s, name:%s, model:%{public}s", (uint8_t *)&buf, 0x2Au);
        }
        goto LABEL_179;
      }
LABEL_183:
      sub_100058DB0(&__p, "Manatee_DownloadData_");
      sub_100CD467C(v6, (uint64_t **)&__p, (uint64_t *)&v163);
      if (SHIBYTE(v157) < 0) {
        operator delete(__p);
      }
      if (!*(void *)(v3 + 112)) {
        goto LABEL_238;
      }
      if (v175 == v176)
      {
LABEL_207:
        long long v108 = v166;
        long long v109 = v167;
        if (v166 != v167)
        {
          long long v110 = *v6;
          if (os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT))
          {
            memset(__str, 0, 24);
            sub_100B704F4((std::string *)__s, (uint64_t)v108);
            *(_OWORD *)std::string __str = *(_OWORD *)__s;
            *(void *)&__str[16] = v196;
            for (uint64_t i = (uint64_t)v108 + 72; (long long *)i != v109; i += 72)
            {
              BYTE7(v196) = 2;
              strcpy(__s, "\n\t");
              std::string::append((std::string *)__str, __s, 2uLL);
              if (SBYTE7(v196) < 0) {
                operator delete(*(void **)__s);
              }
              sub_100B704F4((std::string *)__s, i);
              if ((SBYTE7(v196) & 0x80u) == 0) {
                long long v112 = __s;
              }
              else {
                long long v112 = *(std::string::value_type **)__s;
              }
              if ((SBYTE7(v196) & 0x80u) == 0) {
                std::string::size_type v113 = BYTE7(v196);
              }
              else {
                std::string::size_type v113 = *(void *)&__s[8];
              }
              std::string::append((std::string *)__str, v112, v113);
              if (SBYTE7(v196) < 0) {
                operator delete(*(void **)__s);
              }
            }
            long long v114 = __str;
            if (__str[23] < 0) {
              long long v114 = *(unsigned char **)__str;
            }
            *(_DWORD *)__s = 136315138;
            *(void *)&__s[4] = v114;
            _os_log_impl((void *)&_mh_execute_header, v110, OS_LOG_TYPE_DEFAULT, "#I deleting dangling blocklist items:\n\t%s", (uint8_t *)__s, 0xCu);
            if ((__str[23] & 0x80000000) != 0) {
              operator delete(*(void **)__str);
            }
          }
          v187 = 0;
          uint64_t v186 = 0;
          *(void *)__s = "CellularPlanTransferFlowController";
          sub_1002BFAE4((char **)__s, (dispatch_object_t *)(v3 + 24), &v186);
          (***(void (****)(std::string::value_type *__return_ptr))(v3 + 48))(__s);
          Registry::createRestModuleOneTimeUseMobileHelperConnection(&v184, *(Registry **)__s);
          ctu::RestModule::connect();
          if (v185) {
            sub_10004D2C8(v185);
          }
          if (*(void *)&__s[8]) {
            sub_10004D2C8(*(std::__shared_weak_count **)&__s[8]);
          }
          uint64_t v115 = *(void *)(v3 + 112);
          uint64_t v116 = v186;
          *(_OWORD *)__s = 0u;
          long long v196 = 0u;
          *(_OWORD *)long long __src = 0u;
          sub_1003229A4((void *)&v196 + 1, (uint64_t)v166, (uint64_t)v167, 0x8E38E38E38E38E39 * (((char *)v167 - (char *)v166) >> 3));
          *(void *)std::string __str = v3;
          CFTypeRef v117 = *(std::__shared_weak_count **)(v3 + 16);
          if (!v117 || (v118 = *(void *)(v3 + 8), (CFTypeRef v119 = std::__shared_weak_count::lock(v117)) == 0)) {
            sub_100088B9C();
          }
          uint64_t v120 = v119;
          *(void *)&__str[8] = v118;
          *(void *)&__str[16] = v119;
          atomic_fetch_add_explicit(&v119->__shared_weak_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v119);
          *(void *)&unsigned char __str[32] = 0;
          *(void *)&__str[24] = 0;
          long long v121 = *(std::__shared_weak_count **)(v3 + 72);
          if (v121)
          {
            uint64_t v122 = std::__shared_weak_count::lock(v121);
            *(void *)&unsigned char __str[32] = v122;
            if (v122)
            {
              uint64_t v123 = *(void *)(v3 + 64);
              *(void *)&__str[24] = v123;
              goto LABEL_236;
            }
          }
          else
          {
            uint64_t v122 = 0;
          }
          uint64_t v123 = 0;
LABEL_236:
          v226 = 0;
          uint64_t v124 = operator new(0x30uLL);
          void *v124 = off_101A3F380;
          v124[1] = v3;
          v124[2] = v118;
          v124[3] = v120;
          *(_OWORD *)&__str[8] = 0uLL;
          v124[4] = v123;
          v124[5] = v122;
          *(void *)&__str[24] = 0;
          *(void *)&unsigned char __str[32] = 0;
          v226 = v124;
          (*(void (**)(uint64_t, uint64_t, std::string::value_type *, long long *))(*(void *)v115 + 64))(v115, v116, __s, &v224);
          sub_100322EB8(&v224);
          unsigned int v193 = (char *)&v196 + 8;
          sub_10030EC88((void ***)&v193);
          unsigned int v193 = __s;
          sub_10010DF1C((void ***)&v193);
          if (v187) {
            sub_10004D2C8(v187);
          }
        }
LABEL_238:
        if (v181) {
          sub_10034C1EC(v3 + 520, &v179);
        }
        if ((char ***)(v3 + 568) != &v182)
        {
          long long v125 = (uint64_t *)v182;
          if (*(void *)(v3 + 584))
          {
            uint64_t v126 = *(void *)(v3 + 568);
            long long v127 = (uint64_t **)(v3 + 576);
            *(void *)(v3 + 568) = v3 + 576;
            *(void *)(*(void *)(v3 + 576) + 16) = 0;
            *(void *)(v3 + 576) = 0;
            *(void *)(v3 + 584) = 0;
            if (*(void *)(v126 + 8)) {
              uint64_t v128 = *(void *)(v126 + 8);
            }
            else {
              uint64_t v128 = v126;
            }
            *(void *)__s = v3 + 568;
            *(void *)&__s[8] = v128;
            *(void *)&long long v196 = v128;
            if (v128)
            {
              *(void *)&__s[8] = sub_1000EA590(v128);
              if (v125 == (uint64_t *)v183)
              {
                uint64_t v136 = v183;
              }
              else
              {
                do
                {
                  *(_OWORD *)(v128 + 32) = *((_OWORD *)v125 + 2);
                  std::string::operator=((std::string *)(v128 + 48), (const std::string *)v125 + 2);
                  uint64_t v129 = *v127;
                  CFTypeRef v130 = (uint64_t **)(v3 + 576);
                  std::string v131 = (uint64_t **)(v3 + 576);
                  if (*v127)
                  {
                    do
                    {
                      while (1)
                      {
                        CFTypeRef v130 = (uint64_t **)v129;
                        uint64_t v132 = 32;
                        do
                        {
                          unsigned int v133 = *(unsigned __int8 *)(v196 + v132);
                          unsigned int v134 = *((unsigned __int8 *)v130 + v132);
                          if (v133 != v134) {
                            break;
                          }
                          BOOL v58 = v132++ == 47;
                        }
                        while (!v58);
                        if (v133 >= v134) {
                          break;
                        }
                        uint64_t v129 = *v130;
                        std::string v131 = v130;
                        if (!*v130) {
                          goto LABEL_257;
                        }
                      }
                      uint64_t v129 = v130[1];
                    }
                    while (v129);
                    std::string v131 = v130 + 1;
                  }
LABEL_257:
                  sub_100046C38((uint64_t **)(v3 + 568), (uint64_t)v130, v131, (uint64_t *)v196);
                  uint64_t v128 = *(void *)&__s[8];
                  *(void *)&long long v196 = *(void *)&__s[8];
                  if (*(void *)&__s[8]) {
                    *(void *)&__s[8] = sub_1000EA590(*(uint64_t *)&__s[8]);
                  }
                  long long v135 = (char *)v125[1];
                  if (v135)
                  {
                    do
                    {
                      uint64_t v136 = (char **)v135;
                      long long v135 = *(char **)v135;
                    }
                    while (v135);
                  }
                  else
                  {
                    do
                    {
                      uint64_t v136 = (char **)v125[2];
                      BOOL v58 = *v136 == (char *)v125;
                      long long v125 = (uint64_t *)v136;
                    }
                    while (!v58);
                  }
                  if (!v128) {
                    break;
                  }
                  long long v125 = (uint64_t *)v136;
                }
                while (v136 != v183);
              }
            }
            else
            {
              uint64_t v136 = (char **)v125;
            }
            sub_100B66600((uint64_t)__s);
            long long v125 = (uint64_t *)v136;
          }
          if (v125 != (uint64_t *)v183)
          {
            char v137 = (uint64_t **)(v3 + 576);
            do
            {
              uint64_t v138 = (char *)operator new(0x48uLL);
              *((_OWORD *)v138 + 2) = *((_OWORD *)v125 + 2);
              char v139 = v138 + 48;
              if (*((char *)v125 + 71) < 0)
              {
                sub_10004FC84(v139, (void *)v125[6], v125[7]);
              }
              else
              {
                long long v140 = *((_OWORD *)v125 + 3);
                *((void *)v138 + 8) = v125[8];
                *(_OWORD *)char v139 = v140;
              }
              char v141 = *v137;
              long long v142 = (uint64_t **)(v3 + 576);
              long long v143 = (uint64_t **)(v3 + 576);
              if (*v137)
              {
                do
                {
                  while (1)
                  {
                    long long v142 = (uint64_t **)v141;
                    uint64_t v144 = 32;
                    do
                    {
                      unsigned int v145 = v138[v144];
                      unsigned int v146 = *((unsigned __int8 *)v142 + v144);
                      if (v145 != v146) {
                        break;
                      }
                      BOOL v58 = v144++ == 47;
                    }
                    while (!v58);
                    if (v145 >= v146) {
                      break;
                    }
                    char v141 = *v142;
                    long long v143 = v142;
                    if (!*v142) {
                      goto LABEL_285;
                    }
                  }
                  char v141 = v142[1];
                }
                while (v141);
                long long v143 = v142 + 1;
              }
LABEL_285:
              sub_100046C38((uint64_t **)(v3 + 568), (uint64_t)v142, v143, (uint64_t *)v138);
              long long v147 = (char *)v125[1];
              if (v147)
              {
                do
                {
                  long long v148 = (char **)v147;
                  long long v147 = *(char **)v147;
                }
                while (v147);
              }
              else
              {
                do
                {
                  long long v148 = (char **)v125[2];
                  BOOL v58 = *v148 == (char *)v125;
                  long long v125 = (uint64_t *)v148;
                }
                while (!v58);
              }
              long long v125 = (uint64_t *)v148;
            }
            while (v148 != v183);
          }
        }
        uint64_t v149 = *(void *)(v3 + 560);
        if (v149) {
          (*(void (**)(uint64_t, uint64_t))(*(void *)v149 + 48))(v149, v3 + 568);
        }
        if ((void)v161) {
          sub_10004D2C8((std::__shared_weak_count *)v161);
        }
        *(void *)__s = &v163;
        sub_100B61728((void ***)__s);
        *(void *)__s = &v166;
        sub_10030EC88((void ***)__s);
        *(void *)__s = &v169;
        sub_100342230((void ***)__s);
        *(void *)__s = &v172;
        sub_100047F64((void ***)__s);
        *(void *)__s = &v175;
        sub_100047F64((void ***)__s);
        *(void *)__s = v178;
        sub_100047F64((void ***)__s);
        sub_10010C0E0((uint64_t)&v179, v180);
        sub_100030EE0((uint64_t)&v182, v183[0]);
        *(void *)__s = off_101A3ECF0;
        *(void *)&__s[8] = v3;
        *((void *)&v196 + 1) = __s;
        sub_100B41F14(v3, (uint64_t)__s);
        sub_10003B34C(__s);
        uint64_t v4 = v151;
        goto LABEL_296;
      }
      memset(__s, 0, sizeof(__s));
      *(void *)&long long v196 = 0;
      sub_10005CA3C((uint64_t)__s, v175, (long long *)v176, 0xAAAAAAAAAAAAAAABLL * (((char *)v176 - (char *)v175) >> 3));
      uint64_t v96 = *v6;
      if (os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT))
      {
        sub_100062B40(v172, v173, "\n\t", 2uLL, &buf);
        uint64_t v97 = (buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
            ? &buf
            : (std::string *)buf.__r_.__value_.__r.__words[0];
        *(_DWORD *)std::string __str = 136315138;
        *(void *)&__str[4] = v97;
        _os_log_impl((void *)&_mh_execute_header, v96, OS_LOG_TYPE_DEFAULT, "#I delete record from :\n\t%s", __str, 0xCu);
        if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(buf.__r_.__value_.__l.__data_);
        }
      }
      *(_OWORD *)std::string __str = 0uLL;
      buf.__r_.__value_.__r.__words[0] = (std::string::size_type)"CellularPlanTransferFlowController";
      sub_1002BFAE4(&buf.__r_.__value_.__l.__data_, (dispatch_object_t *)(v3 + 24), __str);
      (***(void (****)(std::string *__return_ptr))(v3 + 48))(&buf);
      Registry::createRestModuleOneTimeUseMobileHelperConnection(&v191, (Registry *)buf.__r_.__value_.__l.__data_);
      ctu::RestModule::connect();
      if (v192) {
        sub_10004D2C8(v192);
      }
      if (buf.__r_.__value_.__l.__size_) {
        sub_10004D2C8((std::__shared_weak_count *)buf.__r_.__value_.__l.__size_);
      }
      uint64_t v98 = *(void *)(v3 + 112);
      uint64_t v99 = *(void *)__str;
      uint64_t v190 = 0;
      uint64_t v188 = 0;
      v189 = 0;
      sub_1000302C0((char *)&v188, *(long long **)__s, *(long long **)&__s[8], 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)&__s[8] - *(void *)__s) >> 3));
      buf.__r_.__value_.__r.__words[0] = v3;
      long long v100 = *(std::__shared_weak_count **)(v3 + 16);
      if (!v100 || (std::string::size_type v101 = *(void *)(v3 + 8), (v102 = std::__shared_weak_count::lock(v100)) == 0)) {
        sub_100088B9C();
      }
      long long v103 = v102;
      buf.__r_.__value_.__l.__size_ = v101;
      buf.__r_.__value_.__r.__words[2] = (std::string::size_type)v102;
      atomic_fetch_add_explicit(&v102->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v102);
      *(void *)unsigned int v221 = 0;
      *(void *)&v221[8] = 0;
      long long v104 = *(std::__shared_weak_count **)(v3 + 72);
      if (v104)
      {
        long long v105 = std::__shared_weak_count::lock(v104);
        *(void *)&v221[8] = v105;
        if (v105)
        {
          uint64_t v106 = *(void *)(v3 + 64);
          *(void *)unsigned int v221 = v106;
LABEL_204:
          *(void *)&v227[24] = 0;
          long long v107 = operator new(0x30uLL);
          void *v107 = off_101A3F300;
          v107[1] = v3;
          v107[2] = v101;
          v107[3] = v103;
          *(_OWORD *)&buf.__r_.__value_.__r.__words[1] = 0uLL;
          void v107[4] = v106;
          v107[5] = v105;
          *(void *)unsigned int v221 = 0;
          *(void *)&v221[8] = 0;
          *(void *)&v227[24] = v107;
          (*(void (**)(uint64_t, uint64_t, uint64_t *, unsigned char *))(*(void *)v98 + 40))(v98, v99, &v188, v227);
          sub_100060644(v227);
          *(void *)&long long v224 = &v188;
          sub_100047F64((void ***)&v224);
          if (*(void *)&__str[8]) {
            sub_10004D2C8(*(std::__shared_weak_count **)&__str[8]);
          }
          *(void *)std::string __str = __s;
          sub_100047F64((void ***)__str);
          goto LABEL_207;
        }
      }
      else
      {
        long long v105 = 0;
      }
      uint64_t v106 = 0;
      goto LABEL_204;
    }
  }
  return sub_100B67A9C(&v153);
}

void sub_100B691EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,__int16 a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,char a47,uint64_t a48,uint64_t a49,char a50,uint64_t a51,uint64_t a52,char a53,uint64_t a54,uint64_t a55,char a56,uint64_t a57,uint64_t a58,char a59,uint64_t a60,uint64_t a61,char a62,uint64_t a63)
{
  sub_10005CD2C((uint64_t)&a30, (char *)a31);
  *(void *)(v69 - 144) = &a33;
  sub_10030EC88((void ***)(v69 - 144));
  if (SLOBYTE(STACK[0x257]) < 0) {
    operator delete((void *)STACK[0x240]);
  }
  sub_1000C52BC((uint64_t)&STACK[0x280]);
  if (a43) {
    sub_10004D2C8((std::__shared_weak_count *)a43);
  }
  a41 = (uint64_t)&a47;
  sub_100B61728((void ***)&a41);
  a41 = (uint64_t)&a50;
  sub_10030EC88((void ***)&a41);
  a41 = (uint64_t)&a53;
  sub_100342230((void ***)&a41);
  a41 = (uint64_t)&a56;
  sub_100047F64((void ***)&a41);
  a41 = (uint64_t)&a59;
  sub_100047F64((void ***)&a41);
  a41 = (uint64_t)&a62;
  sub_100047F64((void ***)&a41);
  sub_10010C0E0((uint64_t)&a65, (void *)a66);
  sub_100030EE0((uint64_t)&a68, (char *)a69);
  sub_10004D2C8(a16);
  sub_100B67A9C(&a29);
  _Unwind_Resume(a1);
}

void sub_100B69620()
{
}

void *sub_100B69634(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = off_101A3ECF0;
  result[1] = v3;
  return result;
}

uint64_t sub_100B6967C(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A3ECF0;
  a2[1] = v2;
  return result;
}

void sub_100B696A8(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  *(unsigned char *)(v1 + 134) = 1;
  sub_100B40EE8(v2, v1);
  sub_100B4F614(v1, v2);
  uint64_t v3 = (void **)v2;
  sub_100047F64(&v3);
  sub_100B42C90(v1);
}

void sub_100B69708(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  sub_100047F64((void ***)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100B69720(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100B69760()
{
}

void *sub_100B6976C(void *a1)
{
  *a1 = off_101A3ED70;
  sub_10003B34C(a1 + 4);
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_100B697BC(void *a1)
{
  *a1 = off_101A3ED70;
  sub_10003B34C(a1 + 4);
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete();
}

void *sub_100B6982C(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t v2 = operator new(0x40uLL);
  void *v2 = off_101A3ED70;
  sub_100B69BB4((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_100B69880(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100B69894(uint64_t a1, void *a2)
{
  *a2 = off_101A3ED70;
  return sub_100B69BB4((uint64_t)(a2 + 1), a1 + 8);
}

void sub_100B698C0(uint64_t a1)
{
}

void sub_100B698C8(void *a1)
{
  sub_100211E94((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_100B69904(void *a1, xpc_object_t *a2)
{
  xpc_object_t object = *a2;
  *a2 = xpc_null_create();
  char v4 = xpc::dyn_cast_or_default((xpc *)&object, 0, v3);
  uint64_t v5 = (std::__shared_weak_count *)a1[3];
  if (v5)
  {
    uint64_t v6 = a1[1];
    uint64_t v7 = std::__shared_weak_count::lock(v5);
    if (v7 && a1[2])
    {
      *(void *)std::string buf = v6;
      LOBYTE(v12) = v4;
      sub_1000F0058((uint64_t)&v13, (uint64_t)(a1 + 4));
      uint64_t v8 = *(std::__shared_weak_count **)(v6 + 16);
      if (v8)
      {
        if (std::__shared_weak_count::lock(v8)) {
          operator new();
        }
      }
      sub_100088B9C();
    }
  }
  else
  {
    uint64_t v7 = 0;
  }
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)buf, kCtLoggingSystemName, "cp.tr.ctr");
  char v9 = v12;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
  if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "invalid CellularPlanTransferFlowController (weak_ptr)", buf, 2u);
    if (!v7) {
      goto LABEL_11;
    }
    goto LABEL_10;
  }
  if (v7) {
LABEL_10:
  }
    sub_10004D2C8(v7);
LABEL_11:
  xpc_release(object);
}

void sub_100B69B14(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

uint64_t sub_100B69B68(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100B69BA8()
{
}

uint64_t sub_100B69BB4(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = *(_OWORD *)a2;
  uint64_t v3 = *(void *)(a2 + 16);
  *(void *)(a1 + 16) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  sub_1000F0058(a1 + 24, a2 + 24);
  return a1;
}

void sub_100B69C04(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(std::__shared_weak_count **)(v1 + 16);
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t *sub_100B69C1C(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v8 = a1;
  uint64_t v9 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v3 = (void **)(*(void *)v1 + 912);
  sub_1001FEC70(*v3);
  *(void *)(v2 + 904) = v3;
  *(void *)(v2 + 920) = 0;
  *(void *)(v2 + 912) = 0;
  sub_10008E5B8(v2 + 880, *(void **)(v2 + 888));
  *(void *)(v2 + 880) = v2 + 888;
  *(void *)(v2 + 896) = 0;
  *(void *)(v2 + 888) = 0;
  char v4 = *(NSObject **)(v2 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    char v5 = *(unsigned char *)(v1 + 8);
    *(_DWORD *)std::string buf = 16777472;
    char v11 = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Carrier bundle update error: %hhu", buf, 5u);
  }
  uint64_t v6 = *(void *)(v1 + 40);
  if (!v6) {
    sub_10007B600();
  }
  (*(void (**)(uint64_t))(*(void *)v6 + 48))(v6);
  sub_100B69D30(&v9);
  return sub_100046B58((uint64_t *)&v8);
}

void sub_100B69D14(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

uint64_t *sub_100B69D30(uint64_t *result)
{
  uint64_t v1 = *result;
  *uint64_t result = 0;
  if (v1)
  {
    sub_10003B34C((void *)(v1 + 16));
    operator delete();
  }
  return result;
}

void *sub_100B69D80(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  a1[3] = 0;
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t sub_100B69E08(uint64_t a1)
{
  *(void *)a1 = off_101A3EDF0;
  char v4 = (void **)(a1 + 32);
  sub_10030A698(&v4);
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 24);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_100B69E6C(uint64_t a1)
{
  *(void *)a1 = off_101A3EDF0;
  uint64_t v3 = (void **)(a1 + 32);
  sub_10030A698(&v3);
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 24);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  operator delete();
}

void *sub_100B69EE4(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t v2 = operator new(0x50uLL);
  void *v2 = off_101A3EDF0;
  sub_100B6A970((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_100B69F38(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100B69F4C(uint64_t a1, void *a2)
{
  *a2 = off_101A3EDF0;
  return sub_100B6A970((uint64_t)(a2 + 1), a1 + 8);
}

void sub_100B69F78(uint64_t a1)
{
}

void sub_100B69F80(void *a1)
{
  sub_10032DB8C((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_100B69FBC(void *a1, unsigned __int8 *a2)
{
  uint64_t v3 = (std::__shared_weak_count *)a1[3];
  if (!v3 || (int v4 = *a2, v5 = a1[1], (v6 = std::__shared_weak_count::lock(v3)) == 0))
  {
    int v60 = 0;
LABEL_86:
    ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)buf, kCtLoggingSystemName, "cp.tr.ctr");
    uint64_t v47 = *(NSObject **)&buf[8];
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v47, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v47, OS_LOG_TYPE_ERROR, "invalid CellularPlanTransferFlowController (weak_ptr)", buf, 2u);
    }
    goto LABEL_88;
  }
  int v60 = v6;
  if (!a1[2]) {
    goto LABEL_86;
  }
  if (v4)
  {
    uint64_t v7 = a1[4];
    uint64_t v8 = a1[5];
    uint64_t v62 = a1;
    if (v7 != v8)
    {
      uint64_t v9 = a1 + 7;
      while (1)
      {
        bzero(buf, 0x5F0uLL);
        if (!sub_100B409A4(v5, (uint64_t)buf, v7, v9, (const std::string *)(v5 + 776))) {
          break;
        }
        char v80 = *((unsigned char *)v62 + 72);
        unint64_t v10 = *(void *)(v5 + 312);
        if (v10 >= *(void *)(v5 + 320))
        {
          uint64_t v11 = sub_100B6387C((void *)(v5 + 304), (uint64_t)buf);
        }
        else
        {
          sub_100B63A1C(*(void *)(v5 + 312), (uint64_t)buf);
          uint64_t v11 = v10 + 1520;
          *(void *)(v5 + 312) = v10 + 1520;
        }
        *(void *)(v5 + 312) = v11;
        sub_100B615AC((uint64_t)buf);
        v7 += 64;
        if (v7 == v8) {
          goto LABEL_12;
        }
      }
      int v50 = *(NSObject **)(v5 + 40);
      if (os_log_type_enabled(v50, OS_LOG_TYPE_ERROR))
      {
        sub_1008A1B90(v7, &__str);
        long long v59 = (__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
            ? &__str
            : (std::string *)__str.__r_.__value_.__r.__words[0];
        LODWORD(v81) = 136315138;
        *(void *)((char *)&v81 + 4) = v59;
        _os_log_error_impl((void *)&_mh_execute_header, v50, OS_LOG_TYPE_ERROR, "can not create transfer plan data for %s", (uint8_t *)&v81, 0xCu);
        if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__str.__r_.__value_.__l.__data_);
        }
      }
      sub_100B54BDC((void *)v5, v7 + 40);
      if (*(void *)(v5 + 416)) {
        sub_1002EB2F8(v5 + 392, 0, 51);
      }
      sub_100B69D80((void *)(v5 + 392));
      sub_100B615AC((uint64_t)buf);
LABEL_88:
      uint64_t v48 = v60;
      if (!v60) {
        return;
      }
      goto LABEL_89;
    }
LABEL_12:
    long long v81 = 0uLL;
    unint64_t v82 = 0;
    uint64_t v12 = *(void *)(v5 + 144);
    for (uint64_t i = *(void *)(v5 + 152); v12 != i; v12 += 400)
    {
      uint64_t v67 = 0;
      unint64_t v68 = 0;
      unint64_t v69 = 0;
      if (*(unsigned char *)(v12 + 240))
      {
        uint64_t v14 = *(void *)(v12 + 200);
        uint64_t v13 = *(void *)(v12 + 208);
        uint64_t v63 = v13;
        while (v14 != v13)
        {
          if (*(unsigned char *)(v14 + 80))
          {
            uint64_t v16 = *(void *)(v14 + 56);
            for (uint64_t j = *(void *)(v14 + 64); v16 != j; v16 += 216)
            {
              bzero(buf, 0x4E0uLL);
              if ((sub_10098F7E8(v12, v16 + 16, (uint64_t)buf) & 1) == 0)
              {
                uint64_t v17 = *(NSObject **)(v5 + 40);
                if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
                {
                  std::string::size_type v26 = v16 + 16;
                  if (*(char *)(v16 + 39) < 0) {
                    std::string::size_type v26 = *(void *)(v16 + 16);
                  }
                  LODWORD(__str.__r_.__value_.__l.__data_) = 136315138;
                  *(std::string::size_type *)((char *)__str.__r_.__value_.__r.__words + 4) = v26;
                  _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "generate pending transfer plan failure. source iccid : %s", (uint8_t *)&__str, 0xCu);
                }
              }
              uint64_t v18 = *(void *)(v5 + 312);
              uint64_t v19 = (const std::string *)sub_100B45F5C(*(void *)(v5 + 304), v18, (unsigned __int8 **)(v16 + 16));
              if ((const std::string *)v18 != v19)
              {
                unint64_t v20 = v19;
                if (v19[9].__r_.__value_.__s.__data_[0])
                {
                  std::string::operator=(&v72, v19 + 4);
                  std::string::operator=(&v73, v20 + 5);
                  std::string::operator=(&v74, v20 + 6);
                  std::string::operator=(v75, v20 + 7);
                  memset(&__str, 0, sizeof(__str));
                  if (sub_10098F640(v12, (unsigned __int8 **)(v16 + 16), (unint64_t)&__str)) {
                    std::string::operator=(v77, &__str);
                  }
                  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
                    operator delete(__str.__r_.__value_.__l.__data_);
                  }
                }
              }
              long long v79 = *(_OWORD *)(v14 + 16);
              sub_10098FCF4((char *)v12, (uint64_t)&__str);
              if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
                operator delete(__p.__r_.__value_.__l.__data_);
              }
              std::string __p = __str;
              *(_WORD *)&buf[1] = 257;
              uint8_t buf[4] = *(unsigned char *)(v5 + 129);
              std::string::operator=(v78, (const std::string *)(v16 + 16));
              unint64_t v21 = *(int **)(v12 + 368);
              int v22 = *(int **)(v12 + 376);
              while (1)
              {
                if (v21 == v22)
                {
                  int v23 = 0;
                  goto LABEL_34;
                }
                if (sub_10010E128((uint64_t)(v21 + 14), (void **)(v16 + 16))) {
                  break;
                }
                v21 += 20;
              }
              int v23 = *v21;
LABEL_34:
              *(_DWORD *)&uint8_t buf[8] = v23;
              unsigned char buf[12] = 1;
              unsigned char buf[14] = *(unsigned char *)(v5 + 128) == 3;
              unint64_t v24 = v68;
              if (v68 >= v69)
              {
                uint64_t v25 = sub_1003252B8(&v67, (long long *)buf);
              }
              else
              {
                sub_10030DDAC(v68, (long long *)buf);
                uint64_t v25 = v24 + 1248;
              }
              unint64_t v68 = v25;
              sub_10030D10C((uint64_t)buf);
            }
          }
          else
          {
            uint64_t v27 = *(NSObject **)(v5 + 40);
            if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
            {
              sCardSerialNumberAsString();
              long long v28 = buf;
              if (v71 < 0) {
                long long v28 = *(uint8_t **)buf;
              }
              LODWORD(__str.__r_.__value_.__l.__data_) = 136315138;
              *(std::string::size_type *)((char *)__str.__r_.__value_.__r.__words + 4) = (std::string::size_type)v28;
              _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "#I no profile for vinyl : %s", (uint8_t *)&__str, 0xCu);
              if (v71 < 0) {
                operator delete(*(void **)buf);
              }
            }
          }
          v14 += 88;
          uint64_t v13 = v63;
        }
      }
      uint64_t v30 = v62[4];
      uint64_t v29 = v62[5];
      uint64_t v64 = v29;
      while (v30 != v29)
      {
        uint64_t v31 = v67;
        unint64_t v32 = v68;
        if (*(char *)(v30 + 63) < 0)
        {
          sub_10004FC84(__dst, *(void **)(v30 + 40), *(void *)(v30 + 48));
        }
        else
        {
          *(_OWORD *)long long __dst = *(_OWORD *)(v30 + 40);
          uint64_t v66 = *(void *)(v30 + 56);
        }
        uint64_t v33 = HIBYTE(v66);
        if (v31 != v32)
        {
          uint64_t v35 = __dst[0];
          uint64_t v34 = __dst[1];
          if (v66 >= 0) {
            unint64_t v36 = (void *)HIBYTE(v66);
          }
          else {
            unint64_t v36 = __dst[1];
          }
          do
          {
            unint64_t v37 = (void *)*(unsigned __int8 *)(v31 + 455);
            int v38 = (char)v37;
            if ((char)v37 < 0) {
              unint64_t v37 = *(void **)(v31 + 440);
            }
            if (v36 == v37)
            {
              if (v38 >= 0) {
                uint64_t v39 = (unsigned __int8 *)(v31 + 432);
              }
              else {
                uint64_t v39 = *(unsigned __int8 **)(v31 + 432);
              }
              if ((v33 & 0x80) != 0)
              {
                if (!memcmp(v35, v39, (size_t)v34)) {
                  goto LABEL_73;
                }
              }
              else
              {
                if (!v33) {
                  goto LABEL_74;
                }
                uint64_t v40 = __dst;
                uint64_t v41 = v33;
                while (*(unsigned __int8 *)v40 == *v39)
                {
                  uint64_t v40 = (void **)((char *)v40 + 1);
                  ++v39;
                  if (!--v41) {
                    goto LABEL_72;
                  }
                }
              }
            }
            v31 += 1248;
          }
          while (v31 != v32);
          uint64_t v31 = v32;
        }
LABEL_72:
        if ((v33 & 0x80) != 0) {
LABEL_73:
        }
          operator delete(__dst[0]);
LABEL_74:
        if (v31 != v68)
        {
          uint64_t v42 = *((void *)&v81 + 1);
          if (*((void *)&v81 + 1) >= v82)
          {
            uint64_t v43 = sub_1003252B8((uint64_t *)&v81, (long long *)v31);
          }
          else
          {
            sub_10030DDAC(*((uint64_t *)&v81 + 1), (long long *)v31);
            uint64_t v43 = v42 + 1248;
          }
          *((void *)&v81 + 1) = v43;
        }
        v30 += 64;
        uint64_t v29 = v64;
      }
      *(void *)std::string buf = &v67;
      sub_10030AFC8((void ***)buf);
    }
    uint64_t v44 = *(std::__shared_weak_count **)(v5 + 88);
    if (v44)
    {
      uint64_t v45 = std::__shared_weak_count::lock(v44);
      if (v45)
      {
        uint64_t v46 = *(void *)(v5 + 80);
        if (v46)
        {
          (*(void (**)(uint64_t, long long *))(*(void *)v46 + 32))(v46, &v81);
          goto LABEL_103;
        }
      }
    }
    else
    {
      uint64_t v45 = 0;
    }
    char v51 = *(NSObject **)(v5 + 40);
    if (os_log_type_enabled(v51, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v51, OS_LOG_TYPE_ERROR, "pendingTransferHandler not available", buf, 2u);
      if (!v45)
      {
LABEL_104:
        *(void *)std::string buf = &v81;
        sub_10030AFC8((void ***)buf);
        uint64_t v52 = *(void *)(v5 + 304);
        CFNumberRef v53 = *(void ***)(v5 + 312);
        unint64_t v54 = 126 - 2 * __clz(0x4E25B9EFD4E25B9FLL * (((uint64_t)v53 - v52) >> 4));
        if (v53 == (void **)v52) {
          uint64_t v55 = 0;
        }
        else {
          uint64_t v55 = v54;
        }
        sub_100B6A9FC(v52, v53, v55, 1);
        uint64_t v56 = *(void *)(v5 + 304);
        uint64_t v57 = *(void *)(v5 + 312);
        *(void *)(v5 + 328) = v56;
        if (v56 == v57)
        {
          BOOL v58 = *(NSObject **)(v5 + 40);
          if (os_log_type_enabled(v58, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)std::string buf = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v58, OS_LOG_TYPE_ERROR, "No elements in the transfer map", buf, 2u);
          }
          if (*(void *)(v5 + 416)) {
            sub_1002EB2F8(v5 + 392, 0, 56);
          }
          sub_100B69D80((void *)(v5 + 392));
        }
        else
        {
          sub_100B3F548(v5);
        }
        goto LABEL_88;
      }
    }
    else if (!v45)
    {
      goto LABEL_104;
    }
LABEL_103:
    sub_10004D2C8(v45);
    goto LABEL_104;
  }
  uint64_t v49 = *(NSObject **)(v5 + 40);
  if (os_log_type_enabled(v49, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v49, OS_LOG_TYPE_ERROR, "Unable to get transfer Auth Response from source", buf, 2u);
  }
  if (*(void *)(v5 + 416)) {
    sub_1002EB2F8(v5 + 392, 0, 56);
  }
  sub_100B69D80((void *)(v5 + 392));
  uint64_t v48 = v60;
LABEL_89:
  sub_10004D2C8(v48);
}

void sub_100B6A858(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,void **a29)
{
  sub_10004D2C8(v29);
  a29 = (void **)(v30 - 160);
  sub_10030AFC8(&a29);
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100B6A924(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100B6A964()
{
}

uint64_t sub_100B6A970(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = *(_OWORD *)a2;
  uint64_t v4 = *(void *)(a2 + 16);
  *(void *)(a1 + 16) = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 16), 1uLL, memory_order_relaxed);
  }
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  sub_10030CD0C((void *)(a1 + 24), *(void *)(a2 + 24), *(void *)(a2 + 32), (uint64_t)(*(void *)(a2 + 32) - *(void *)(a2 + 24)) >> 6);
  long long v5 = *(_OWORD *)(a2 + 48);
  *(unsigned char *)(a1 + 64) = *(unsigned char *)(a2 + 64);
  *(_OWORD *)(a1 + 48) = v5;
  return a1;
}

void sub_100B6A9E4(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(std::__shared_weak_count **)(v1 + 16);
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100B6A9FC(uint64_t result, void **a2, uint64_t a3, char a4)
{
  uint64_t v8 = result;
LABEL_2:
  uint64_t v9 = v8;
  uint64_t v10 = v8 + 1520;
  uint64_t v11 = v8 + 3040;
  unint64_t v24 = (void *)(v8 - 472);
  uint64_t v12 = (void **)(v8 + 1048);
  for (uint64_t i = 1 - a3; ; ++i)
  {
    uint64_t v14 = (uint64_t)a2 - v9;
    unint64_t v15 = 0x4E25B9EFD4E25B9FLL * (((uint64_t)a2 - v9) >> 4);
    if (!(!v5 & v4))
    {
      switch(v15)
      {
        case 0uLL:
        case 1uLL:
          return result;
        case 2uLL:
          if (a2 - 190 == (void **)v9) {
            return result;
          }
          if (*((unsigned __int8 *)a2 - 57) == *(unsigned __int8 *)(v9 + 1463))
          {
            uint64_t result = sub_100046FE8(a2 - 59, (void **)(v9 + 1048));
            if ((result & 0x80) == 0) {
              return result;
            }
          }
          else if (!*((unsigned char *)a2 - 57))
          {
            return result;
          }
          uint64_t result = sub_100B6AE00(v9, (uint64_t)(a2 - 190));
          break;
        case 3uLL:
          return sub_100B6B19C(v9, v9 + 1520, (uint64_t)(a2 - 190));
        case 4uLL:
          return sub_100B6BC6C(v9, v9 + 1520, v9 + 3040, (uint64_t)(a2 - 190));
        case 5uLL:
          return sub_100B6BD70(v9, v9 + 1520, v9 + 3040, v9 + 4560, (uint64_t)(a2 - 190));
        default:
          JUMPOUT(0);
      }
      return result;
    }
    if (v14 <= 36479) {
      break;
    }
    if (i == 1)
    {
      if ((void **)v9 != a2)
      {
        return sub_100B6BEC0(v9, (uint64_t)a2, (uint64_t)a2);
      }
      return result;
    }
    unint64_t v16 = v15 >> 1;
    uint64_t v17 = v9 + 1520 * (v15 >> 1);
    uint64_t v18 = (uint64_t)(a2 - 190);
    if ((unint64_t)v14 >= 0x2F801)
    {
      sub_100B6B19C(v9, v9 + 1520 * (v15 >> 1), v18);
      uint64_t v19 = v9 + 1520 * v16;
      uint64_t v20 = v19 - 1520;
      sub_100B6B19C(v10, v19 - 1520, (uint64_t)(a2 - 380));
      v19 += 1520;
      sub_100B6B19C(v11, v19, (uint64_t)(a2 - 570));
      sub_100B6B19C(v20, v17, v19);
      sub_100B6B30C(v9, v17);
      if (a4) {
        goto LABEL_16;
      }
    }
    else
    {
      sub_100B6B19C(v9 + 1520 * (v15 >> 1), v9, v18);
      if (a4) {
        goto LABEL_16;
      }
    }
    if (*(unsigned __int8 *)(v9 - 57) == *(unsigned __int8 *)(v9 + 1463))
    {
      if ((sub_100046FE8(v24, v12) & 0x80) == 0) {
        goto LABEL_22;
      }
    }
    else if (!*(unsigned char *)(v9 - 57))
    {
LABEL_22:
      uint64_t result = sub_100B6B3C0(v9, a2);
      uint64_t v8 = result;
      goto LABEL_23;
    }
LABEL_16:
    uint64_t v21 = sub_100B6B690(v9, a2);
    if ((v22 & 1) == 0) {
      goto LABEL_21;
    }
    char v23 = sub_100B6B998(v9, v21);
    uint64_t v8 = v21 + 1520;
    uint64_t result = sub_100B6B998(v21 + 1520, (uint64_t)a2);
    if (!result)
    {
      a3 = -i;
      if (v23) {
        goto LABEL_2;
      }
LABEL_21:
      uint64_t result = sub_100B6A9FC(v9, v21, -i, a4 & 1);
      uint64_t v8 = v21 + 1520;
LABEL_23:
      a4 = 0;
      a3 = -i;
      goto LABEL_2;
    }
    a2 = (void **)v21;
    if (v23) {
      return result;
    }
  }
  if (a4)
  {
    return sub_100B6AEB4(v9, (uint64_t)a2);
  }
  else
  {
    return sub_100B6B044(v9, (uint64_t)a2);
  }
}

uint64_t sub_100B6AE00(uint64_t a1, uint64_t a2)
{
  bzero(v5, 0x5F0uLL);
  sub_100B63A1C((uint64_t)v5, a1);
  sub_100B62A9C(a1, a2);
  sub_100B62A9C(a2, (uint64_t)v5);
  return sub_100B615AC((uint64_t)v5);
}

void sub_100B6AE98(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
}

uint64_t sub_100B6AEB4(uint64_t result, uint64_t a2)
{
  if (result != a2)
  {
    uint64_t v3 = result;
    uint64_t v4 = result + 1520;
    if (result + 1520 != a2)
    {
      uint64_t v5 = 0;
      uint64_t v6 = result;
      do
      {
        uint64_t v7 = v6;
        uint64_t v6 = v4;
        int v8 = *(unsigned __int8 *)(v4 + 1463);
        if (v8 == *(unsigned __int8 *)(v7 + 1463))
        {
          uint64_t result = sub_100046FE8((void *)(v6 + 1048), (void **)(v7 + 1048));
          if ((result & 0x80) != 0) {
            goto LABEL_8;
          }
        }
        else if (v8)
        {
LABEL_8:
          bzero(v10, 0x5F0uLL);
          sub_100B63A1C((uint64_t)v10, v6);
          for (uint64_t i = v5; ; i -= 1520)
          {
            sub_100B62A9C(v3 + i + 1520, v3 + i);
            if (!i) {
              break;
            }
            if ((unsigned char *)(v3 + i - 1520) == v10) {
              goto LABEL_17;
            }
            if (v12 == *(unsigned char *)(v3 + i - 57))
            {
              if ((sub_100046FE8(v11, (void **)(v3 + i - 472)) & 0x80) == 0)
              {
                uint64_t v7 = v3 + i;
                goto LABEL_17;
              }
            }
            else if (!v12)
            {
              goto LABEL_17;
            }
            v7 -= 1520;
          }
          uint64_t v7 = v3;
LABEL_17:
          sub_100B62A9C(v7, (uint64_t)v10);
          uint64_t result = sub_100B615AC((uint64_t)v10);
        }
        uint64_t v4 = v6 + 1520;
        v5 += 1520;
      }
      while (v6 + 1520 != a2);
    }
  }
  return result;
}

void sub_100B6B024(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100B615AC((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100B6B044(uint64_t result, uint64_t a2)
{
  if (result != a2)
  {
    uint64_t v3 = result;
    for (uint64_t i = result + 1520; v3 + 1520 != a2; uint64_t i = v3 + 1520)
    {
      uint64_t v5 = v3;
      uint64_t v3 = i;
      int v6 = *(unsigned __int8 *)(i + 1463);
      if (v6 == *(unsigned __int8 *)(v5 + 1463))
      {
        uint64_t result = sub_100046FE8((void *)(v3 + 1048), (void **)(v5 + 1048));
        if ((result & 0x80) != 0) {
          goto LABEL_7;
        }
      }
      else if (v6)
      {
LABEL_7:
        bzero(v8, 0x5F0uLL);
        sub_100B63A1C((uint64_t)v8, v3);
        while (1)
        {
          uint64_t v7 = v5;
          sub_100B62A9C(v5 + 1520, v5);
          v5 -= 1520;
          if ((unsigned char *)(v7 - 1520) == v8) {
            break;
          }
          if (v10 == *(unsigned char *)(v7 - 57))
          {
            if ((sub_100046FE8(v9, (void **)(v7 - 472)) & 0x80) == 0) {
              break;
            }
          }
          else if (!v10)
          {
            break;
          }
        }
        sub_100B62A9C(v7, (uint64_t)v8);
        uint64_t result = sub_100B615AC((uint64_t)v8);
      }
    }
  }
  return result;
}

void sub_100B6B17C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100B615AC((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100B6B19C(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = result;
  if (a2 == result)
  {
    if (a3 == a2) {
      return result;
    }
    LOBYTE(v7) = 0;
LABEL_8:
    int v8 = *(unsigned __int8 *)(a3 + 1463);
    if (v8 == *(unsigned __int8 *)(a2 + 1463))
    {
      uint64_t result = sub_100046FE8((void *)(a3 + 1048), (void **)(a2 + 1048));
      BOOL v9 = (result & 0x80u) != 0;
      if (!v7) {
        goto LABEL_10;
      }
    }
    else
    {
      BOOL v9 = v8 != 0;
      if (!v7)
      {
LABEL_10:
        if (!v9) {
          return result;
        }
        uint64_t result = sub_100B6AE00(a2, a3);
        if (a2 == v5) {
          return result;
        }
        if (*(unsigned __int8 *)(a2 + 1463) == *(unsigned __int8 *)(v5 + 1463))
        {
          uint64_t result = sub_100046FE8((void *)(a2 + 1048), (void **)(v5 + 1048));
          if ((result & 0x80) == 0) {
            return result;
          }
        }
        else if (!*(unsigned char *)(a2 + 1463))
        {
          return result;
        }
        goto LABEL_26;
      }
    }
    uint64_t v10 = v5;
    if (!v9)
    {
      uint64_t result = sub_100B6AE00(v5, a2);
      if (*(unsigned __int8 *)(a3 + 1463) == *(unsigned __int8 *)(a2 + 1463))
      {
        uint64_t result = sub_100046FE8((void *)(a3 + 1048), (void **)(a2 + 1048));
        if ((result & 0x80) == 0) {
          return result;
        }
      }
      else if (!*(unsigned char *)(a3 + 1463))
      {
        return result;
      }
      uint64_t v10 = a2;
    }
    uint64_t v11 = a3;
    goto LABEL_27;
  }
  int v6 = *(unsigned __int8 *)(a2 + 1463);
  if (v6 == *(unsigned __int8 *)(result + 1463))
  {
    uint64_t result = sub_100046FE8((void *)(a2 + 1048), (void **)(result + 1048));
    BOOL v7 = (result & 0x80u) != 0;
  }
  else
  {
    BOOL v7 = v6 != 0;
  }
  if (a3 != a2) {
    goto LABEL_8;
  }
  if (!v7) {
    return result;
  }
LABEL_26:
  uint64_t v10 = v5;
  uint64_t v11 = a2;
LABEL_27:

  return sub_100B6AE00(v10, v11);
}

uint64_t sub_100B6B30C(uint64_t a1, uint64_t a2)
{
  bzero(v5, 0x5F0uLL);
  sub_100B63A1C((uint64_t)v5, a1);
  sub_100B62A9C(a1, a2);
  sub_100B62A9C(a2, (uint64_t)v5);
  return sub_100B615AC((uint64_t)v5);
}

void sub_100B6B3A4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
}

unint64_t sub_100B6B3C0(uint64_t a1, void **a2)
{
  bzero(v10, 0x5F0uLL);
  sub_100B63A1C((uint64_t)v10, a1);
  if (v10 != (unsigned char *)(a2 - 190))
  {
    if (v12 == *((unsigned char *)a2 - 57))
    {
      if ((sub_100046FE8(v11, a2 - 59) & 0x80) == 0) {
        goto LABEL_4;
      }
LABEL_40:
      for (unint64_t i = a1 + 1520; ; i += 1520)
      {
        if ((unsigned char *)i != v10)
        {
          if (v12 == *(unsigned char *)(i + 1463))
          {
            if ((sub_100046FE8(v11, (void **)(i + 1048)) & 0x80) != 0) {
              goto LABEL_11;
            }
          }
          else if (v12)
          {
            goto LABEL_11;
          }
        }
      }
    }
    if (v12) {
      goto LABEL_40;
    }
  }
LABEL_4:
  for (unint64_t i = a1 + 1520; i < (unint64_t)a2; i += 1520)
  {
    if ((unsigned char *)i != v10)
    {
      if (v12 == *(unsigned char *)(i + 1463))
      {
        if ((sub_100046FE8(v11, (void **)(i + 1048)) & 0x80) != 0) {
          break;
        }
      }
      else if (v12)
      {
        break;
      }
    }
  }
LABEL_11:
  if (i >= (unint64_t)a2) {
    goto LABEL_20;
  }
  if (v10 != (unsigned char *)(a2 - 190))
  {
    uint64_t v5 = a2 - 59;
    a2 -= 190;
    do
    {
      if (v12 == *((unsigned char *)v5 + 415))
      {
        if ((sub_100046FE8(v11, v5) & 0x80) == 0)
        {
          a2 = v5 - 131;
          goto LABEL_20;
        }
      }
      else if (!v12)
      {
        goto LABEL_20;
      }
      a2 -= 190;
      int v6 = v5 - 321;
      v5 -= 190;
    }
    while (v6 != (void **)v10);
  }
  a2 = (void **)v10;
LABEL_20:
  while (i < (unint64_t)a2)
  {
    sub_100B6AE00(i, (uint64_t)a2);
    do
    {
      while (1)
      {
        do
          i += 1520;
        while ((unsigned char *)i == v10);
        if (v12 != *(unsigned char *)(i + 1463)) {
          break;
        }
        if ((sub_100046FE8(v11, (void **)(i + 1048)) & 0x80) != 0) {
          goto LABEL_27;
        }
      }
    }
    while (!v12);
LABEL_27:
    if (v10 != (unsigned char *)(a2 - 190))
    {
      BOOL v7 = a2 - 59;
      a2 -= 190;
      do
      {
        if (v12 == *((unsigned char *)v7 + 415))
        {
          if ((sub_100046FE8(v11, v7) & 0x80) == 0)
          {
            a2 = v7 - 131;
            goto LABEL_35;
          }
        }
        else if (!v12)
        {
          goto LABEL_35;
        }
        a2 -= 190;
        int v8 = v7 - 321;
        v7 -= 190;
      }
      while (v8 != (void **)v10);
    }
    a2 = (void **)v10;
LABEL_35:
    ;
  }
  if (i - 1520 != a1) {
    sub_100B62A9C(a1, i - 1520);
  }
  sub_100B62A9C(i - 1520, (uint64_t)v10);
  sub_100B615AC((uint64_t)v10);
  return i;
}

void sub_100B6B670(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
}

uint64_t sub_100B6B690(uint64_t a1, unsigned char *a2)
{
  uint64_t v4 = v19;
  bzero(v19, 0x5F0uLL);
  sub_100B63A1C((uint64_t)v19, a1);
  uint64_t v5 = (unsigned char *)(a1 + 1520);
  if ((unsigned char *)(a1 + 1520) == v19)
  {
    uint64_t v6 = a1;
  }
  else
  {
    uint64_t v6 = a1;
    do
    {
      uint64_t v4 = v5;
      int v7 = v5[1463];
      if (v7 == v21)
      {
        if ((sub_100046FE8((void *)v4 + 131, v20) & 0x80) == 0)
        {
          uint64_t v6 = (uint64_t)(v4 - 1520);
          goto LABEL_10;
        }
      }
      else if (!v7)
      {
        goto LABEL_10;
      }
      uint64_t v5 = v4 + 1520;
      uint64_t v6 = (uint64_t)v4;
    }
    while (v4 + 1520 != v19);
    uint64_t v6 = (uint64_t)v4;
    uint64_t v4 = v19;
LABEL_10:
    if (v6 != a1)
    {
      for (unint64_t i = a2 - 472; ; i -= 1520)
      {
        a2 = i - 1048;
        if (i - 1048 != v19)
        {
          if (i[415] == v21)
          {
            if ((sub_100046FE8(i, v20) & 0x80) != 0) {
              goto LABEL_33;
            }
          }
          else if (i[415])
          {
            goto LABEL_33;
          }
        }
      }
    }
  }
  if (v4 >= a2) {
    goto LABEL_33;
  }
  for (uint64_t j = a2 - 472; ; j -= 1520)
  {
    a2 -= 1520;
    unint64_t v10 = (unint64_t)(j - 1048);
    if (j - 1048 != v19) {
      break;
    }
    if (v4 >= v19)
    {
      a2 = v19;
      goto LABEL_33;
    }
LABEL_31:
    ;
  }
  if (j[415] != v21)
  {
    if (j[415]) {
      BOOL v11 = 1;
    }
    else {
      BOOL v11 = (unint64_t)v4 >= v10;
    }
    if (v11) {
      goto LABEL_33;
    }
    goto LABEL_31;
  }
  if ((sub_100046FE8(j, v20) & 0x80) == 0 && (unint64_t)v4 < v10) {
    goto LABEL_31;
  }
  a2 = j - 1048;
LABEL_33:
  if (v4 >= a2) {
    goto LABEL_54;
  }
  char v12 = v4;
  unint64_t v13 = (unint64_t)a2;
  while (2)
  {
    sub_100B6AE00((uint64_t)v12, v13);
    uint64_t v14 = v12 + 1520;
    if (v12 + 1520 == v19)
    {
      uint64_t v6 = (uint64_t)v12;
LABEL_43:
      char v12 = v19;
      goto LABEL_46;
    }
    while (2)
    {
      uint64_t v15 = (uint64_t)v14;
      int v16 = v14[1463];
      if (v16 == v21)
      {
        if ((sub_100046FE8((void *)(v15 + 1048), v20) & 0x80) == 0)
        {
          uint64_t v6 = v15 - 1520;
          goto LABEL_45;
        }
        goto LABEL_40;
      }
      if (v16)
      {
LABEL_40:
        uint64_t v14 = (unsigned char *)(v15 + 1520);
        char v12 = (unsigned char *)v15;
        if ((unsigned char *)(v15 + 1520) == v19)
        {
          uint64_t v6 = v15;
          goto LABEL_43;
        }
        continue;
      }
      break;
    }
    uint64_t v6 = (uint64_t)v12;
LABEL_45:
    char v12 = (unsigned char *)v15;
LABEL_46:
    unint64_t v17 = v13 - 472;
    while (2)
    {
      unint64_t v13 = v17 - 1048;
      if ((unsigned char *)(v17 - 1048) == v19) {
        goto LABEL_52;
      }
      if (*(unsigned __int8 *)(v17 + 415) == v21)
      {
        if ((sub_100046FE8((void *)v17, v20) & 0x80) != 0) {
          break;
        }
        goto LABEL_52;
      }
      if (!*(unsigned char *)(v17 + 415))
      {
LABEL_52:
        v17 -= 1520;
        continue;
      }
      break;
    }
    if ((unint64_t)v12 < v13) {
      continue;
    }
    break;
  }
LABEL_54:
  if (v6 != a1) {
    sub_100B62A9C(a1, v6);
  }
  sub_100B62A9C(v6, (uint64_t)v19);
  sub_100B615AC((uint64_t)v19);
  return v6;
}

void sub_100B6B978(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
}

uint64_t sub_100B6B998(uint64_t a1, uint64_t a2)
{
  BOOL v4 = 1;
  switch(0x4E25B9EFD4E25B9FLL * ((a2 - a1) >> 4))
  {
    case 0:
    case 1:
      return v4;
    case 2:
      if (a2 - 1520 == a1) {
        return 1;
      }
      if (*(unsigned __int8 *)(a2 - 57) == *(unsigned __int8 *)(a1 + 1463))
      {
        if ((sub_100046FE8((void *)(a2 - 472), (void **)(a1 + 1048)) & 0x80) == 0) {
          return 1;
        }
      }
      else if (!*(unsigned char *)(a2 - 57))
      {
        return 1;
      }
      sub_100B6AE00(a1, a2 - 1520);
      return 1;
    case 3:
      sub_100B6B19C(a1, a1 + 1520, a2 - 1520);
      return v4;
    case 4:
      sub_100B6BC6C(a1, a1 + 1520, a1 + 3040, a2 - 1520);
      return v4;
    case 5:
      sub_100B6BD70(a1, a1 + 1520, a1 + 3040, a1 + 4560, a2 - 1520);
      return v4;
    default:
      uint64_t v5 = a1 + 3040;
      sub_100B6B19C(a1, a1 + 1520, a1 + 3040);
      uint64_t v6 = a1 + 4560;
      if (a1 + 4560 == a2) {
        return 1;
      }
      uint64_t v7 = 0;
      int v8 = 0;
      uint64_t v9 = 4560;
      break;
  }
  while (*(unsigned __int8 *)(v6 + 1463) == *(unsigned __int8 *)(v5 + 1463))
  {
    if ((sub_100046FE8((void *)(v6 + 1048), (void **)(v5 + 1048)) & 0x80) != 0) {
      goto LABEL_12;
    }
LABEL_24:
    uint64_t v5 = v6;
    v9 += 1520;
    v7 += 1520;
    v6 += 1520;
    if (v6 == a2) {
      return 1;
    }
  }
  if (!*(unsigned char *)(v6 + 1463)) {
    goto LABEL_24;
  }
LABEL_12:
  bzero(v14, 0x5F0uLL);
  sub_100B63A1C((uint64_t)v14, v6);
  uint64_t v10 = v7;
  uint64_t v11 = v9;
  while (1)
  {
    sub_100B62A9C(a1 + v11, a1 + v10 + 3040);
    v11 -= 1520;
    if (!v11)
    {
      uint64_t v5 = a1;
      goto LABEL_22;
    }
    uint64_t v12 = a1 + v10;
    if ((unsigned char *)(a1 + v10 + 1520) == v14) {
      break;
    }
    if (v16 == *(unsigned char *)(v12 + 2983))
    {
      if ((sub_100046FE8(v15, (void **)(a1 + v10 + 2568)) & 0x80) == 0) {
        goto LABEL_22;
      }
    }
    else if (!v16)
    {
      goto LABEL_22;
    }
    v5 -= 1520;
    v10 -= 1520;
  }
  uint64_t v5 = v12 + 3040;
LABEL_22:
  sub_100B62A9C(v5, (uint64_t)v14);
  if (++v8 != 8)
  {
    sub_100B615AC((uint64_t)v14);
    goto LABEL_24;
  }
  BOOL v4 = v6 + 1520 == a2;
  sub_100B615AC((uint64_t)v14);
  return v4;
}

void sub_100B6BC34(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sub_100B615AC((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100B6BC6C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t result = sub_100B6B19C(a1, a2, a3);
  if (a4 != a3)
  {
    if (*(unsigned __int8 *)(a4 + 1463) == *(unsigned __int8 *)(a3 + 1463))
    {
      uint64_t result = sub_100046FE8((void *)(a4 + 1048), (void **)(a3 + 1048));
      if ((result & 0x80) == 0) {
        return result;
      }
    }
    else if (!*(unsigned char *)(a4 + 1463))
    {
      return result;
    }
    uint64_t result = sub_100B6AE00(a3, a4);
    if (a3 != a2)
    {
      if (*(unsigned __int8 *)(a3 + 1463) == *(unsigned __int8 *)(a2 + 1463))
      {
        uint64_t result = sub_100046FE8((void *)(a3 + 1048), (void **)(a2 + 1048));
        if ((result & 0x80) == 0) {
          return result;
        }
      }
      else if (!*(unsigned char *)(a3 + 1463))
      {
        return result;
      }
      uint64_t result = sub_100B6AE00(a2, a3);
      if (a2 != a1)
      {
        if (*(unsigned __int8 *)(a2 + 1463) == *(unsigned __int8 *)(a1 + 1463))
        {
          uint64_t result = sub_100046FE8((void *)(a2 + 1048), (void **)(a1 + 1048));
          if ((result & 0x80) == 0) {
            return result;
          }
        }
        else if (!*(unsigned char *)(a2 + 1463))
        {
          return result;
        }
        return sub_100B6AE00(a1, a2);
      }
    }
  }
  return result;
}

uint64_t sub_100B6BD70(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result = sub_100B6BC6C(a1, a2, a3, a4);
  if (a5 != a4)
  {
    if (*(unsigned __int8 *)(a5 + 1463) == *(unsigned __int8 *)(a4 + 1463))
    {
      uint64_t result = sub_100046FE8((void *)(a5 + 1048), (void **)(a4 + 1048));
      if ((result & 0x80) == 0) {
        return result;
      }
    }
    else if (!*(unsigned char *)(a5 + 1463))
    {
      return result;
    }
    uint64_t result = sub_100B6AE00(a4, a5);
    if (a4 != a3)
    {
      if (*(unsigned __int8 *)(a4 + 1463) == *(unsigned __int8 *)(a3 + 1463))
      {
        uint64_t result = sub_100046FE8((void *)(a4 + 1048), (void **)(a3 + 1048));
        if ((result & 0x80) == 0) {
          return result;
        }
      }
      else if (!*(unsigned char *)(a4 + 1463))
      {
        return result;
      }
      uint64_t result = sub_100B6AE00(a3, a4);
      if (a3 != a2)
      {
        if (*(unsigned __int8 *)(a3 + 1463) == *(unsigned __int8 *)(a2 + 1463))
        {
          uint64_t result = sub_100046FE8((void *)(a3 + 1048), (void **)(a2 + 1048));
          if ((result & 0x80) == 0) {
            return result;
          }
        }
        else if (!*(unsigned char *)(a3 + 1463))
        {
          return result;
        }
        uint64_t result = sub_100B6AE00(a2, a3);
        if (a2 != a1)
        {
          if (*(unsigned __int8 *)(a2 + 1463) == *(unsigned __int8 *)(a1 + 1463))
          {
            uint64_t result = sub_100046FE8((void *)(a2 + 1048), (void **)(a1 + 1048));
            if ((result & 0x80) == 0) {
              return result;
            }
          }
          else if (!*(unsigned char *)(a2 + 1463))
          {
            return result;
          }
          return sub_100B6AE00(a1, a2);
        }
      }
    }
  }
  return result;
}

uint64_t sub_100B6BEC0(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (result != a2)
  {
    uint64_t v4 = a2;
    uint64_t v5 = result;
    uint64_t v6 = a2 - result;
    uint64_t v7 = (a2 - result) / 1520;
    if (a2 - result >= 1521)
    {
      unint64_t v8 = (unint64_t)(v7 - 2) >> 1;
      unint64_t v9 = v8 + 1;
      uint64_t v10 = result + 1520 * v8;
      do
      {
        uint64_t result = sub_100B6C260(v5, v7, v10);
        v10 -= 1520;
        --v9;
      }
      while (v9);
    }
    if (v4 != a3)
    {
      uint64_t v11 = v4 + 1048;
      do
      {
        if (v11 - 1048 != v5)
        {
          if (*(unsigned __int8 *)(v11 + 415) == *(unsigned __int8 *)(v5 + 1463))
          {
            uint64_t result = sub_100046FE8((void *)v11, (void **)(v5 + 1048));
            if ((result & 0x80) != 0) {
              goto LABEL_12;
            }
          }
          else if (*(unsigned char *)(v11 + 415))
          {
LABEL_12:
            sub_100B6AE00(v11 - 1048, v5);
            uint64_t result = sub_100B6C260(v5, v7, v5);
          }
        }
        uint64_t v12 = v11 + 472;
        v11 += 1520;
      }
      while (v12 != a3);
    }
    if (v6 >= 1521)
    {
      int64_t v13 = v6 / 0x5F0uLL;
      while (v13 < 2)
      {
LABEL_42:
        v4 -= 1520;
        if ((unint64_t)v13-- <= 2) {
          return result;
        }
      }
      bzero(v26, 0x5F0uLL);
      sub_100B63A1C((uint64_t)v26, v5);
      uint64_t v14 = 0;
      uint64_t v15 = v5;
      do
      {
        uint64_t v16 = v15 + 1520 * v14 + 1520;
        uint64_t v17 = 2 * v14;
        uint64_t v14 = (2 * v14) | 1;
        uint64_t v18 = v17 + 2;
        if (v17 + 2 < v13)
        {
          int v19 = *(unsigned __int8 *)(v16 + 1463);
          if (v19 == *(unsigned __int8 *)(v16 + 2983)) {
            BOOL v20 = (sub_100046FE8((void *)(v16 + 1048), (void **)(v16 + 2568)) & 0x80u) != 0;
          }
          else {
            BOOL v20 = v19 != 0;
          }
          v16 += 1520 * v20;
          if (v20) {
            uint64_t v14 = v18;
          }
        }
        sub_100B62A9C(v15, v16);
        uint64_t v15 = v16;
      }
      while (v14 <= (uint64_t)((unint64_t)(v13 - 2) >> 1));
      if (v16 == v4 - 1520)
      {
        sub_100B62A9C(v16, (uint64_t)v26);
      }
      else
      {
        sub_100B62A9C(v16, v4 - 1520);
        sub_100B62A9C(v4 - 1520, (uint64_t)v26);
        uint64_t v21 = v16 - v5 + 1520;
        if (v21 >= 1521)
        {
          unint64_t v22 = (v21 / 0x5F0uLL - 2) >> 1;
          uint64_t v23 = v5 + 1520 * v22;
          if (v23 != v16)
          {
            if (*(unsigned __int8 *)(v23 + 1463) == *(unsigned __int8 *)(v16 + 1463))
            {
              if ((sub_100046FE8((void *)(v23 + 1048), (void **)(v16 + 1048)) & 0x80) != 0)
              {
LABEL_33:
                bzero(v27, 0x5F0uLL);
                sub_100B63A1C((uint64_t)v27, v16);
                while (1)
                {
                  uint64_t v24 = v23;
                  sub_100B62A9C(v16, v23);
                  if (!v22) {
                    break;
                  }
                  unint64_t v22 = (v22 - 1) >> 1;
                  uint64_t v23 = v5 + 1520 * v22;
                  if ((unsigned char *)v23 == v27) {
                    break;
                  }
                  if (*(unsigned __int8 *)(v23 + 1463) == v29)
                  {
                    uint64_t v16 = v24;
                    if ((sub_100046FE8((void *)(v23 + 1048), &v28) & 0x80) == 0) {
                      break;
                    }
                  }
                  else
                  {
                    uint64_t v16 = v24;
                    if (!*(unsigned char *)(v23 + 1463)) {
                      break;
                    }
                  }
                }
                sub_100B62A9C(v24, (uint64_t)v27);
                sub_100B615AC((uint64_t)v27);
              }
            }
            else if (*(unsigned char *)(v23 + 1463))
            {
              goto LABEL_33;
            }
          }
        }
      }
      uint64_t result = sub_100B615AC((uint64_t)v26);
      goto LABEL_42;
    }
  }
  return result;
}

void sub_100B6C22C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sub_100B615AC((uint64_t)&STACK[0x600]);
  sub_100B615AC((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100B6C260(uint64_t result, uint64_t a2, uint64_t a3)
{
  unint64_t v3 = a2 - 2;
  if (a2 >= 2)
  {
    uint64_t v4 = a3;
    uint64_t v5 = result;
    int64_t v6 = v3 >> 1;
    if ((uint64_t)(v3 >> 1) >= 0x4E25B9EFD4E25B9FLL * ((a3 - result) >> 4))
    {
      int64_t v8 = (0x9C4B73DFA9C4B73ELL * ((a3 - result) >> 4)) | 1;
      uint64_t v9 = result + 1520 * v8;
      int64_t v10 = 0x9C4B73DFA9C4B73ELL * ((a3 - result) >> 4) + 2;
      if (v10 < a2)
      {
        int v11 = *(unsigned __int8 *)(v9 + 1463);
        if (v11 == *(unsigned __int8 *)(v9 + 2983))
        {
          uint64_t result = sub_100046FE8((void *)(v9 + 1048), (void **)(v9 + 2568));
          BOOL v12 = (result & 0x80u) != 0;
        }
        else
        {
          BOOL v12 = v11 != 0;
        }
        v9 += 1520 * v12;
        if (v12) {
          int64_t v8 = v10;
        }
      }
      if (v9 != v4)
      {
        if (*(unsigned __int8 *)(v9 + 1463) == *(unsigned __int8 *)(v4 + 1463))
        {
          uint64_t result = sub_100046FE8((void *)(v9 + 1048), (void **)(v4 + 1048));
          if ((result & 0x80) != 0) {
            return result;
          }
        }
        else if (*(unsigned char *)(v9 + 1463))
        {
          return result;
        }
      }
      bzero(v17, 0x5F0uLL);
      sub_100B63A1C((uint64_t)v17, v4);
      while (1)
      {
        uint64_t v13 = v9;
        sub_100B62A9C(v4, v9);
        if (v6 < v8) {
          break;
        }
        uint64_t v14 = (2 * v8) | 1;
        uint64_t v9 = v5 + 1520 * v14;
        int64_t v8 = 2 * v8 + 2;
        if (v8 >= a2)
        {
          int64_t v8 = v14;
        }
        else
        {
          int v15 = *(unsigned __int8 *)(v9 + 1463);
          if (v15 == *(unsigned __int8 *)(v9 + 2983)) {
            BOOL v16 = (sub_100046FE8((void *)(v9 + 1048), (void **)(v9 + 2568)) & 0x80u) != 0;
          }
          else {
            BOOL v16 = v15 != 0;
          }
          v9 += 1520 * v16;
          if (!v16) {
            int64_t v8 = v14;
          }
        }
        uint64_t v4 = v13;
        if ((unsigned char *)v9 != v17)
        {
          if (*(unsigned __int8 *)(v9 + 1463) == v19)
          {
            uint64_t v4 = v13;
            if ((sub_100046FE8((void *)(v9 + 1048), &v18) & 0x80) != 0) {
              break;
            }
          }
          else
          {
            uint64_t v4 = v13;
            if (*(unsigned char *)(v9 + 1463)) {
              break;
            }
          }
        }
      }
      sub_100B62A9C(v13, (uint64_t)v17);
      return sub_100B615AC((uint64_t)v17);
    }
  }
  return result;
}

void sub_100B6C490(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_100B6C4B4()
{
}

void *sub_100B6C4C8()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = off_101A3EE70;
  return result;
}

void sub_100B6C500(uint64_t a1, void *a2)
{
  *a2 = off_101A3EE70;
}

uint64_t sub_100B6C52C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100B6C56C()
{
}

char *sub_100B6C578(uint64_t **a1, void **a2, long long **a3)
{
  int64_t v6 = a1 + 1;
  uint64_t v5 = (char *)a1[1];
  uint64_t v7 = (char **)(a1 + 1);
  int64_t v8 = (char **)(a1 + 1);
  if (!v5) {
    goto LABEL_10;
  }
  uint64_t v7 = (char **)(a1 + 1);
  while (1)
  {
    while (1)
    {
      int64_t v8 = (char **)v5;
      int64_t v10 = v5 + 32;
      if ((sub_100046FE8(a2, (void **)v5 + 4) & 0x80) == 0) {
        break;
      }
      uint64_t v5 = *v8;
      uint64_t v7 = v8;
      if (!*v8) {
        goto LABEL_10;
      }
    }
    if ((sub_100046FE8(v10, a2) & 0x80) == 0) {
      break;
    }
    uint64_t v7 = v8 + 1;
    uint64_t v5 = v8[1];
    if (!v5) {
      goto LABEL_10;
    }
  }
  int v11 = *v7;
  if (!*v7)
  {
LABEL_10:
    BOOL v12 = *a3;
    uint64_t v19 = 0;
    uint64_t v13 = (char *)operator new(0x80uLL);
    v18[0] = v13;
    v18[1] = v6;
    uint64_t v14 = v13 + 32;
    if (*((char *)v12 + 23) < 0)
    {
      sub_10004FC84(v14, *(void **)v12, *((void *)v12 + 1));
    }
    else
    {
      long long v15 = *v12;
      *((void *)v13 + 6) = *((void *)v12 + 2);
      *(_OWORD *)uint64_t v14 = v15;
    }
    *((void *)v13 + 15) = 0;
    *(_OWORD *)(v13 + 104) = 0u;
    *(_OWORD *)(v13 + 88) = 0u;
    *(_OWORD *)(v13 + 72) = 0u;
    *(_OWORD *)(v13 + 56) = 0u;
    LOBYTE(v19) = 1;
    *(void *)uint64_t v13 = 0;
    *((void *)v13 + 1) = 0;
    *((void *)v13 + 2) = v8;
    std::__shared_weak_count *v7 = v13;
    BOOL v16 = (uint64_t *)**a1;
    if (v16)
    {
      *a1 = v16;
      uint64_t v13 = *v7;
    }
    sub_100046C90(a1[1], (uint64_t *)v13);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
    int v11 = (char *)v18[0];
    v18[0] = 0;
    sub_100B6C6EC((uint64_t)v18);
  }
  return v11;
}

void sub_100B6C6D8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100B6C6EC((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_100B6C6EC(uint64_t a1)
{
  uint64_t v1 = *(void **)a1;
  *(void *)a1 = 0;
  if (v1)
  {
    if (*(unsigned char *)(a1 + 16)) {
      sub_100B61490((uint64_t)v1 + 32);
    }
    operator delete(v1);
  }
}

void sub_100B6C748()
{
}

void *sub_100B6C75C(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = off_101A3EEF0;
  result[1] = v3;
  return result;
}

uint64_t sub_100B6C7A4(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_101A3EEF0;
  a2[1] = v2;
  return result;
}

void sub_100B6C7D0(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *(NSObject **)(*(void *)(a1 + 8) + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    if (*((char *)a2 + 23) >= 0) {
      uint64_t v4 = a2;
    }
    else {
      uint64_t v4 = (uint64_t *)*a2;
    }
    int v5 = 136315650;
    int64_t v6 = "";
    __int16 v7 = 2080;
    int64_t v8 = "";
    __int16 v9 = 2080;
    int64_t v10 = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I %s%s%s", (uint8_t *)&v5, 0x20u);
  }
}

uint64_t sub_100B6C89C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100B6C8DC()
{
}

uint64_t sub_100B6C8E8(uint64_t a1)
{
  *(void *)a1 = off_101A3EF70;
  if (*(char *)(a1 + 55) < 0) {
    operator delete(*(void **)(a1 + 32));
  }
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 24);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_100B6C944(uint64_t a1)
{
  *(void *)a1 = off_101A3EF70;
  if (*(char *)(a1 + 55) < 0) {
    operator delete(*(void **)(a1 + 32));
  }
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 24);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete();
}

void *sub_100B6C9C0(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t v2 = operator new(0x38uLL);
  void *v2 = off_101A3EF70;
  sub_100B6CD10((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_100B6CA14(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100B6CA28(uint64_t a1, void *a2)
{
  *a2 = off_101A3EF70;
  return sub_100B6CD10((uint64_t)(a2 + 1), a1 + 8);
}

void sub_100B6CA54(uint64_t a1)
{
}

void sub_100B6CA5C(void *a1)
{
  sub_10010FC80((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_100B6CA98(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 24);
  if (v2)
  {
    uint64_t v3 = *(void *)(a1 + 8);
    uint64_t v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      if (*(void *)(a1 + 16))
      {
        int v5 = *(NSObject **)(v3 + 40);
        if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v6 = a1 + 32;
          if (*(char *)(a1 + 55) < 0) {
            uint64_t v6 = *(void *)(a1 + 32);
          }
          *(_DWORD *)std::string buf = 136315138;
          *(void *)&uint8_t buf[4] = v6;
          _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I send.tss.after.delete timer expired, sourceIccid: %s", buf, 0xCu);
        }
        *(void *)std::string buf = v3;
        if (*(char *)(a1 + 55) < 0)
        {
          sub_10004FC84(&buf[8], *(void **)(a1 + 32), *(void *)(a1 + 40));
        }
        else
        {
          *(_OWORD *)&uint8_t buf[8] = *(_OWORD *)(a1 + 32);
          uint64_t v9 = *(void *)(a1 + 48);
        }
        __int16 v7 = *(std::__shared_weak_count **)(v3 + 16);
        if (v7)
        {
          if (std::__shared_weak_count::lock(v7)) {
            operator new();
          }
        }
        sub_100088B9C();
      }
      sub_10004D2C8(v4);
    }
  }
}

void sub_100B6CC98(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100B6CCC4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100B6CD04()
{
}

uint64_t sub_100B6CD10(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = *(_OWORD *)a2;
  uint64_t v3 = *(void *)(a2 + 16);
  *(void *)(a1 + 16) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  uint64_t v4 = (unsigned char *)(a1 + 24);
  if (*(char *)(a2 + 47) < 0)
  {
    sub_10004FC84(v4, *(void **)(a2 + 24), *(void *)(a2 + 32));
  }
  else
  {
    long long v5 = *(_OWORD *)(a2 + 24);
    *(void *)(a1 + 40) = *(void *)(a2 + 40);
    *(_OWORD *)uint64_t v4 = v5;
  }
  return a1;
}

void sub_100B6CD84(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(std::__shared_weak_count **)(v1 + 16);
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t *sub_100B6CD9C(uint64_t **a1)
{
  uint64_t v1 = *a1;
  uint64_t v3 = a1;
  uint64_t v4 = v1;
  sub_100B484CC(*v1, (uint64_t)(v1 + 1));
  sub_1001102C4((uint64_t *)&v4);
  return sub_100046B58((uint64_t *)&v3);
}

void sub_100B6CDE0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

uint64_t sub_100B6CDFC(uint64_t a1)
{
  *(void *)a1 = off_101A3EFF0;
  if (*(char *)(a1 + 55) < 0) {
    operator delete(*(void **)(a1 + 32));
  }
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 24);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_100B6CE58(uint64_t a1)
{
  *(void *)a1 = off_101A3EFF0;
  if (*(char *)(a1 + 55) < 0) {
    operator delete(*(void **)(a1 + 32));
  }
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 24);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete();
}

void *sub_100B6CED4(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t v2 = operator new(0x38uLL);
  void *v2 = off_101A3EFF0;
  sub_100B6D08C((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_100B6CF28(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100B6CF3C(uint64_t a1, void *a2)
{
  *a2 = off_101A3EFF0;
  return sub_100B6D08C((uint64_t)(a2 + 1), a1 + 8);
}

void sub_100B6CF68(uint64_t a1)
{
}

void sub_100B6CF70(void *a1)
{
  sub_10010FC80((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_100B6CFAC(void *a1, unsigned __int8 *a2)
{
  uint64_t v3 = (std::__shared_weak_count *)a1[3];
  if (v3)
  {
    int v4 = *a2;
    uint64_t v5 = a1[1];
    uint64_t v6 = std::__shared_weak_count::lock(v3);
    if (v6)
    {
      __int16 v7 = v6;
      if (!v4 && a1[2]) {
        sub_100B5BF30(v5, (uint64_t)(a1 + 4));
      }
      sub_10004D2C8(v7);
    }
  }
}

void sub_100B6D02C(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100B6D040(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100B6D080()
{
}

uint64_t sub_100B6D08C(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = *(_OWORD *)a2;
  uint64_t v3 = *(void *)(a2 + 16);
  *(void *)(a1 + 16) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  int v4 = (unsigned char *)(a1 + 24);
  if (*(char *)(a2 + 47) < 0)
  {
    sub_10004FC84(v4, *(void **)(a2 + 24), *(void *)(a2 + 32));
  }
  else
  {
    long long v5 = *(_OWORD *)(a2 + 24);
    *(void *)(a1 + 40) = *(void *)(a2 + 40);
    *(_OWORD *)int v4 = v5;
  }
  return a1;
}

void sub_100B6D100(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(std::__shared_weak_count **)(v1 + 16);
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  _Unwind_Resume(exception_object);
}

_UNKNOWN **sub_100B6D118(unsigned int a1, void *a2, void *a3, uint64_t a4, void *a5)
{
  uint64_t v5 = a1;
  switch(v5)
  {
    case 1:
      sub_100B6D288(a3, a2[1]);
      uint64_t result = 0;
      break;
    case 2:
      uint64_t result = 0;
      uint64_t v9 = a2[1];
      *a3 = sub_100B6D118;
      a3[1] = v9;
      goto LABEL_5;
    case 3:
      if (a4) {
      else
      }
        BOOL v10 = a5 == &unk_101548974;
      if (v10) {
        uint64_t result = (_UNKNOWN **)a2[1];
      }
      else {
        uint64_t result = 0;
      }
      break;
    case 4:
      return result;
    default:
      int64_t v8 = (void *)a2[1];
      sub_100B6D1FC((uint64_t)v8);
      operator delete(v8);
      uint64_t result = 0;
LABEL_5:
      *a2 = 0;
      break;
  }
  return result;
}

void sub_100B6D1FC(uint64_t a1)
{
  if (*(char *)(a1 + 151) < 0) {
    operator delete(*(void **)(a1 + 128));
  }
  if (*(unsigned char *)(a1 + 112) && *(char *)(a1 + 111) < 0) {
    operator delete(*(void **)(a1 + 88));
  }
  if (*(unsigned char *)(a1 + 80) && *(char *)(a1 + 79) < 0) {
    operator delete(*(void **)(a1 + 56));
  }
  if (*(unsigned char *)(a1 + 48) && *(char *)(a1 + 47) < 0) {
    operator delete(*(void **)(a1 + 24));
  }
  uint64_t v2 = (void **)a1;
  sub_1001A010C(&v2);
}

uint64_t sub_100B6D288(void *a1, uint64_t a2)
{
  int v4 = operator new(0x98uLL);
  uint64_t result = sub_10030DBE4((uint64_t)v4, a2);
  *a1 = sub_100B6D118;
  a1[1] = v4;
  return result;
}

void sub_100B6D2D8(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t *sub_100B6D2EC(uint64_t *a1)
{
  uint64_t v1 = *a1;
  unint64_t v22 = a1;
  uint64_t v23 = v1;
  uint64_t v2 = (void *)(v1 + 32);
  uint64_t v3 = *(void *)v1;
  uint64_t v4 = *(void *)(*(void *)v1 + 312);
  uint64_t v5 = sub_100B45F5C(*(void *)(*(void *)v1 + 304), v4, (unsigned __int8 **)(v1 + 32));
  if (v4 == v5)
  {
    __int16 v7 = *(NSObject **)(v3 + 40);
    if (!os_log_type_enabled(v7, OS_LOG_TYPE_ERROR)) {
      goto LABEL_42;
    }
    if (*(char *)(v1 + 55) < 0) {
      uint64_t v2 = (void *)*v2;
    }
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315394;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v2;
    WORD2(buf.__r_.__value_.__r.__words[1]) = 2048;
    *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = v3;
    int64_t v8 = "cannot find source iccid in tr.ctr : %s. drop tr.ind. Target Transfer Controller: %p";
    uint64_t v9 = v7;
    uint32_t v10 = 22;
LABEL_35:
    _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, v8, (uint8_t *)&buf, v10);
    goto LABEL_42;
  }
  char v6 = *(unsigned char *)(v1 + 31);
  if (v6 < 0)
  {
    if (!*(void *)(v1 + 16)) {
      goto LABEL_36;
    }
  }
  else if (!*(unsigned char *)(v1 + 31))
  {
    goto LABEL_36;
  }
  int v11 = (void *)(v1 + 8);
  BOOL v12 = (unsigned __int8 **)(v5 + 1256);
  if (v6 >= 0) {
    uint64_t v13 = *(unsigned __int8 *)(v1 + 31);
  }
  else {
    uint64_t v13 = *(void *)(v1 + 16);
  }
  uint64_t v14 = *(unsigned __int8 *)(v5 + 1279);
  int v15 = (char)v14;
  if ((v14 & 0x80u) != 0) {
    uint64_t v14 = *(void *)(v5 + 1264);
  }
  if (v13 != v14)
  {
LABEL_25:
    uint64_t v19 = *(NSObject **)(v3 + 40);
    if (!os_log_type_enabled(v19, OS_LOG_TYPE_ERROR)) {
      goto LABEL_42;
    }
    if (v6 < 0) {
      int v11 = (void *)*v11;
    }
    goto LABEL_30;
  }
  if (v15 >= 0) {
    BOOL v16 = (unsigned __int8 **)(v5 + 1256);
  }
  else {
    BOOL v16 = (unsigned __int8 **)*v12;
  }
  if ((*(unsigned char *)(v1 + 31) & 0x80) != 0)
  {
    int v11 = (void *)*v11;
    if (memcmp(v11, v16, *(void *)(v1 + 16)))
    {
      uint64_t v19 = *(NSObject **)(v3 + 40);
      if (!os_log_type_enabled(v19, OS_LOG_TYPE_ERROR)) {
        goto LABEL_42;
      }
LABEL_30:
      if (v15 < 0) {
        BOOL v12 = (unsigned __int8 **)*v12;
      }
      if (*(char *)(v1 + 55) < 0) {
        uint64_t v2 = (void *)*v2;
      }
      LODWORD(buf.__r_.__value_.__l.__data_) = 136315650;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v11;
      WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
      *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v12;
      HIWORD(buf.__r_.__value_.__r.__words[2]) = 2080;
      std::string::size_type v26 = v2;
      int64_t v8 = "uuid mismatched : %s != %s, source iccid : %s. drop tr.ind";
      uint64_t v9 = v19;
      uint32_t v10 = 32;
      goto LABEL_35;
    }
  }
  else if (*(unsigned char *)(v1 + 31))
  {
    uint64_t v17 = (unsigned __int8 *)(v1 + 8);
    uint64_t v18 = *(unsigned __int8 *)(v1 + 31);
    while (*v17 == *(unsigned __int8 *)v16)
    {
      ++v17;
      BOOL v16 = (unsigned __int8 **)((char *)v16 + 1);
      if (!--v18) {
        goto LABEL_36;
      }
    }
    goto LABEL_25;
  }
LABEL_36:
  uint64_t v20 = *(void *)(v3 + 960);
  *(void *)(v3 + 960) = 0;
  if (v20) {
    (*(void (**)(uint64_t))(*(void *)v20 + 8))(v20);
  }
  sub_10030D9BC((char *)&buf, v1 + 56);
  __int16 v24 = 0;
  if (*(unsigned __int8 *)(v1 + 320) - 1 <= 1) {
    __int16 v24 = *(_WORD *)(v1 + 320);
  }
  sub_100B53840(v3, v1 + 32, &buf, (unsigned __int8 *)&v24);
  LOBYTE(v24) = 0;
  if (v27) {
    sub_1000C5578((uint64_t)&buf);
  }
LABEL_42:
  sub_100B6D5E0(&v23);
  return sub_100046B58((uint64_t *)&v22);
}

void sub_100B6D5A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,char a48)
{
  a14 = 0;
  if (a48) {
    sub_1000C5578((uint64_t)&a16);
  }
  sub_100B6D5E0(&a11);
  sub_100046B58(&a10);
  _Unwind_Resume(a1);
}

uint64_t *sub_100B6D5E0(uint64_t *result)
{
  uint64_t v1 = *result;
  *uint64_t result = 0;
  if (v1)
  {
    *(unsigned char *)(v1 + 320) = 0;
    if (*(unsigned char *)(v1 + 312)) {
      sub_1000C5578(v1 + 56);
    }
    if (*(char *)(v1 + 55) < 0) {
      operator delete(*(void **)(v1 + 32));
    }
    if (*(char *)(v1 + 31) < 0) {
      operator delete(*(void **)(v1 + 8));
    }
    operator delete();
  }
  return result;
}

uint64_t *sub_100B6D65C(uint64_t *a1)
{
  uint64_t v1 = *a1;
  __int16 v7 = a1;
  uint64_t v8 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v3 = *(void *)(*(void *)v1 + 312);
  uint64_t v4 = sub_100B45F5C(*(void *)(*(void *)v1 + 304), v3, (unsigned __int8 **)(v1 + 8));
  if (v3 != v4)
  {
    if (!*(unsigned char *)(v4 + 1465)) {
      *(_WORD *)(v4 + 1464) = 256;
    }
    *(_DWORD *)(v4 + 1468) = 70005;
    *(unsigned char *)(v4 + 1472) = 1;
  }
  BOOL v12 = 0;
  int v11 = 0;
  sub_100B3EA60(v2, v1 + 8, 11, 56, &v12, &v11);
  sub_100057D78(&v11);
  sub_1000558F4(&v12);
  if (*(char *)(v1 + 31) < 0)
  {
    sub_10004FC84(__p, *(void **)(v1 + 8), *(void *)(v1 + 16));
  }
  else
  {
    long long v5 = *(_OWORD *)(v1 + 8);
    uint64_t v10 = *(void *)(v1 + 24);
    *(_OWORD *)std::string __p = v5;
  }
  sub_100B4A3B8(v2, (uint64_t)__p);
  if (SHIBYTE(v10) < 0) {
    operator delete(__p[0]);
  }
  sub_100B3F548(v2);
  sub_1001102C4(&v8);
  return sub_100046B58((uint64_t *)&v7);
}

void sub_100B6D764(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, char a18)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  sub_1001102C4(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

void *sub_100B6D7B0(unsigned int a1, void *a2, uint64_t a3, uint64_t a4, void *a5)
{
  uint64_t v5 = a1;
  switch(v5)
  {
    case 1:
      uint64_t result = 0;
      *(unsigned char *)(a3 + 8) = *((unsigned char *)a2 + 8);
      *(void *)a3 = sub_100B6D7B0;
      break;
    case 2:
      uint64_t result = 0;
      *(unsigned char *)(a3 + 8) = *((unsigned char *)a2 + 8);
      *(void *)a3 = sub_100B6D7B0;
      goto LABEL_5;
    case 3:
      if (a4) {
      else
      }
        BOOL v8 = a5 == &unk_101548978;
      if (v8) {
        uint64_t result = a2 + 1;
      }
      else {
        uint64_t result = 0;
      }
      break;
    case 4:
      return result;
    default:
      uint64_t result = 0;
LABEL_5:
      *a2 = 0;
      break;
  }
  return result;
}

uint64_t sub_100B6D890(uint64_t a1)
{
  *(void *)a1 = off_101A3F080;
  if (*(char *)(a1 + 87) < 0) {
    operator delete(*(void **)(a1 + 64));
  }
  if (*(char *)(a1 + 63) < 0) {
    operator delete(*(void **)(a1 + 40));
  }
  if (*(char *)(a1 + 39) < 0) {
    operator delete(*(void **)(a1 + 16));
  }
  return a1;
}

void sub_100B6D900(uint64_t a1)
{
  *(void *)a1 = off_101A3F080;
  if (*(char *)(a1 + 87) < 0) {
    operator delete(*(void **)(a1 + 64));
  }
  if (*(char *)(a1 + 63) < 0) {
    operator delete(*(void **)(a1 + 40));
  }
  if (*(char *)(a1 + 39) < 0) {
    operator delete(*(void **)(a1 + 16));
  }

  operator delete();
}

void *sub_100B6D990(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t v2 = operator new(0x58uLL);
  void *v2 = off_101A3F080;
  sub_100B6DC50((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_100B6D9E4(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100B6D9F8(uint64_t a1, void *a2)
{
  *a2 = off_101A3F080;
  return sub_100B6DC50((uint64_t)(a2 + 1), a1 + 8);
}

void sub_100B6DA24(uint64_t a1)
{
}

void sub_100B6DA2C(void *a1)
{
  sub_1001F6FB4((uint64_t)a1 + 8);

  operator delete(a1);
}

const void **sub_100B6DA68(uint64_t a1, unsigned __int8 *a2, const void **a3)
{
  int v4 = *a2;
  uint64_t v13 = *a3;
  *a3 = 0;
  if (v4)
  {
    ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)buf, kCtLoggingSystemName, "cp.tr.ctr");
    uint64_t v5 = *(NSObject **)&buf[8];
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      uint64_t v8 = *(void *)(a1 + 64);
      uint64_t v7 = a1 + 64;
      uint64_t v6 = v8;
      if (*(char *)(v7 - 25) >= 0) {
        uint64_t v9 = v7 - 48;
      }
      else {
        uint64_t v9 = *(void *)(v7 - 48);
      }
      if (*(char *)(v7 - 1) >= 0) {
        uint64_t v10 = v7 - 24;
      }
      else {
        uint64_t v10 = *(void *)(v7 - 24);
      }
      if (*(char *)(v7 + 23) >= 0) {
        uint64_t v6 = v7;
      }
      *(_DWORD *)std::string buf = 136446722;
      *(void *)&uint8_t buf[4] = v9;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&unsigned char buf[14] = v10;
      *(_WORD *)&unsigned char buf[22] = 2082;
      uint64_t v15 = v6;
      _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "send %{public}s for plan %s timeout. uuid : %{public}s", buf, 0x20u);
    }
  }
  else
  {
    int v11 = *(void **)(a1 + 8);
    memset(buf, 0, sizeof(buf));
    sub_100CDB988((void *)(a1 + 16), buf);
    sub_100B4D9F8(v11, (unsigned __int8 *)(a1 + 64), a1 + 40, (uint64_t)buf);
    if ((char)buf[23] < 0) {
      operator delete(*(void **)buf);
    }
  }
  return sub_100057D78(&v13);
}

void sub_100B6DBD8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, const void *a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  sub_100057D78(&a10);
  _Unwind_Resume(a1);
}

uint64_t sub_100B6DC04(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100B6DC44()
{
}

uint64_t sub_100B6DC50(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = *(void *)a2;
  if (*(char *)(a2 + 31) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 8), *(void **)(a2 + 8), *(void *)(a2 + 16));
  }
  else
  {
    long long v4 = *(_OWORD *)(a2 + 8);
    *(void *)(a1 + 24) = *(void *)(a2 + 24);
    *(_OWORD *)(a1 + 8) = v4;
  }
  if (*(char *)(a2 + 55) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 32), *(void **)(a2 + 32), *(void *)(a2 + 40));
  }
  else
  {
    long long v5 = *(_OWORD *)(a2 + 32);
    *(void *)(a1 + 48) = *(void *)(a2 + 48);
    *(_OWORD *)(a1 + 32) = v5;
  }
  uint64_t v6 = (unsigned char *)(a1 + 56);
  if (*(char *)(a2 + 79) < 0)
  {
    sub_10004FC84(v6, *(void **)(a2 + 56), *(void *)(a2 + 64));
  }
  else
  {
    long long v7 = *(_OWORD *)(a2 + 56);
    *(void *)(a1 + 72) = *(void *)(a2 + 72);
    *(_OWORD *)uint64_t v6 = v7;
  }
  return a1;
}

void sub_100B6DD14(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 55) < 0) {
    operator delete(*v3);
  }
  if (*(char *)(v1 + 31) < 0) {
    operator delete(*v2);
  }
  _Unwind_Resume(exception_object);
}

void *sub_100B6DD48(void *a1)
{
  *a1 = off_101A3F100;
  sub_100313790(a1 + 4);
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_100B6DD98(void *a1)
{
  *a1 = off_101A3F100;
  sub_100313790(a1 + 4);
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete();
}

void *sub_100B6DE08(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t v2 = operator new(0x40uLL);
  void *v2 = off_101A3F100;
  sub_100B6E8AC((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_100B6DE5C(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100B6DE70(uint64_t a1, void *a2)
{
  *a2 = off_101A3F100;
  return sub_100B6E8AC((uint64_t)(a2 + 1), a1 + 8);
}

void sub_100B6DE9C(uint64_t a1)
{
}

void sub_100B6DEA4(void *a1)
{
  sub_100B6E914((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_100B6DEE0(void *a1, void *a2)
{
  uint64_t v3 = a2 + 1;
  uint64_t v4 = a2[1];
  uint64_t v43 = (char **)*a2;
  uint64_t v44 = (char *)v4;
  if (a2[2])
  {
    *(void *)(v4 + 16) = &v44;
    *a2 = v3;
    void *v3 = 0;
    a2[2] = 0;
  }
  else
  {
    uint64_t v43 = &v44;
  }
  long long v5 = (std::__shared_weak_count *)a1[3];
  if (v5 && (uint64_t v6 = a1[1], (v7 = std::__shared_weak_count::lock(v5)) != 0))
  {
    if (a1[2])
    {
      long long v56 = 0uLL;
      *(void *)&long long v57 = 0;
      sub_100B40EE8(&v56, v6);
      uint64_t v8 = *(uint64_t **)(v6 + 144);
      uint64_t v42 = *(uint64_t **)(v6 + 152);
      if (v8 == v42)
      {
LABEL_34:
        CFNumberRef v53 = (char **)&v56;
        sub_100047F64((void ***)&v53);
        int v50 = 0;
        CFTypeRef cf = 0;
        uint64_t v49 = 0;
        sub_100CCEE00((const std::string **)(v6 + 144), &v49, v6 + 928, &cf);
        if (v50) {
          sub_10004D2C8(v50);
        }
        if (*(unsigned char *)(v6 + 131))
        {
          uint64_t v20 = *(std::__shared_weak_count **)(v6 + 88);
          if (v20)
          {
            uint64_t v21 = std::__shared_weak_count::lock(v20);
            if (v21)
            {
              unint64_t v22 = v21;
              uint64_t v23 = *(void *)(v6 + 80);
              if (v23)
              {
                if ((*(unsigned int (**)(void, uint64_t))(*(void *)v23 + 336))(*(void *)(v6 + 80), 1) != 2)
                {
                  CFTypeRef v48 = cf;
                  if (cf) {
                    CFRetain(cf);
                  }
                  if (sub_100CDBDD4((os_log_t *)(v6 + 40), &v48, 1)) {
                    uint64_t v24 = 2;
                  }
                  else {
                    uint64_t v24 = 1;
                  }
                  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v23 + 328))(v23, v24, 1);
                  sub_100044D00(&v48);
                }
                if ((*(unsigned int (**)(uint64_t, void))(*(void *)v23 + 336))(v23, 0) != 2)
                {
                  CFTypeRef v47 = cf;
                  if (cf) {
                    CFRetain(cf);
                  }
                  if (sub_100CDBDD4((os_log_t *)(v6 + 40), &v47, 0)) {
                    uint64_t v25 = 2;
                  }
                  else {
                    uint64_t v25 = 1;
                  }
                  (*(void (**)(uint64_t, uint64_t, void))(*(void *)v23 + 328))(v23, v25, 0);
                  sub_100044D00(&v47);
                }
              }
              sub_10004D2C8(v22);
            }
          }
        }
        CFTypeRef v46 = cf;
        if (cf) {
          CFRetain(cf);
        }
        sub_10031F910((uint64_t)(a1 + 4), (uint64_t)&v46, 0);
        sub_100044D00(&v46);
        if (*(unsigned char *)(v6 + 131)) {
          char v26 = 1;
        }
        else {
          char v26 = 2;
        }
        *(unsigned char *)(v6 + 984) = v26;
        long long v28 = *(uint64_t **)(v6 + 144);
        for (unint64_t i = *(uint64_t **)(v6 + 152); v28 != i; v28 += 50)
        {
          sub_10098FAB8(v28, (uint64_t)&v53);
          unsigned __int8 v29 = (void **)v53;
          if (v53 != v54)
          {
            do
            {
              uint64_t v30 = v29 + 4;
              memset(&__p, 0, sizeof(__p));
              if (sub_10098F510((uint64_t)v28, (uint64_t)(v29 + 4), (uint64_t)&__p))
              {
                *(void *)&long long v56 = v29 + 4;
                uint64_t v31 = sub_100B6C578((uint64_t **)(v6 + 992), v29 + 4, (long long **)&v56);
                std::string::operator=((std::string *)(v31 + 56), &__p);
              }
              else
              {
                unint64_t v32 = *(NSObject **)(v6 + 40);
                if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
                {
                  int v38 = v29 + 4;
                  if (*((char *)v29 + 55) < 0) {
                    int v38 = (void **)*v30;
                  }
                  LODWORD(v56) = 136315138;
                  *(void *)((char *)&v56 + 4) = v38;
                  _os_log_error_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_ERROR, "invalid carrier name for [%s]", (uint8_t *)&v56, 0xCu);
                }
              }
              if (*((char *)v29 + 55) < 0)
              {
                sub_10004FC84(buf, v29[4], (unint64_t)v29[5]);
              }
              else
              {
                *(_OWORD *)std::string buf = *(_OWORD *)v30;
                *(void *)&uint8_t buf[16] = v29[6];
              }
              char v33 = sub_10098ECAC((uint64_t)v28, (uint64_t)buf);
              *(void *)&long long v56 = v29 + 4;
              sub_100B6C578((uint64_t **)(v6 + 992), v29 + 4, (long long **)&v56)[80] = v33;
              if ((buf[23] & 0x80000000) != 0) {
                operator delete(*(void **)buf);
              }
              uint64_t v69 = 0;
              long long v67 = 0u;
              long long v68 = 0u;
              long long v65 = 0u;
              long long v66 = 0u;
              long long v63 = 0u;
              long long v64 = 0u;
              long long v61 = 0u;
              long long v62 = 0u;
              long long v59 = 0u;
              long long v60 = 0u;
              long long v57 = 0u;
              long long v58 = 0u;
              long long v56 = 0u;
              if (sub_10098E79C((uint64_t)v28, (unsigned __int8 **)v29 + 4, (uint64_t)&v56))
              {
                char v34 = BYTE9(v61);
                *(void *)uint64_t v55 = v29 + 4;
                sub_100B6C578((uint64_t **)(v6 + 992), v29 + 4, (long long **)v55)[81] = v34;
              }
              else
              {
                uint64_t v35 = *(NSObject **)(v6 + 40);
                if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
                {
                  if (*((char *)v29 + 55) < 0) {
                    uint64_t v30 = (void **)*v30;
                  }
                  *(_DWORD *)uint64_t v55 = 136315138;
                  *(void *)&v55[4] = v30;
                  _os_log_error_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_ERROR, "invalid VinylProfileDetails for [%s]", v55, 0xCu);
                }
              }
              sub_1000C584C((uint64_t)&v56);
              if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
                operator delete(__p.__r_.__value_.__l.__data_);
              }
              unint64_t v36 = (char *)v29[1];
              if (v36)
              {
                do
                {
                  unint64_t v37 = (char **)v36;
                  unint64_t v36 = *(char **)v36;
                }
                while (v36);
              }
              else
              {
                do
                {
                  unint64_t v37 = (char **)v29[2];
                  BOOL v19 = *v37 == (char *)v29;
                  unsigned __int8 v29 = (void **)v37;
                }
                while (!v19);
              }
              unsigned __int8 v29 = (void **)v37;
            }
            while (v37 != v54);
          }
          sub_10005CD2C((uint64_t)&v53, v54[0]);
        }
        uint64_t v39 = *(std::__shared_weak_count **)(v6 + 16);
        if (v39)
        {
          if (std::__shared_weak_count::lock(v39)) {
            operator new();
          }
        }
        sub_100088B9C();
      }
      while (1)
      {
        sub_10098FAB8(v8, (uint64_t)&v53);
        uint64_t v9 = (void **)v53;
        if (v53 != v54) {
          break;
        }
LABEL_33:
        sub_10005CD2C((uint64_t)&v53, v54[0]);
        v8 += 50;
        if (v8 == v42) {
          goto LABEL_34;
        }
      }
      while (1)
      {
        uint64_t v10 = v9 + 4;
        buf[0] = 0;
        uint64_t v11 = sub_1000D8740(v56, *((uint64_t *)&v56 + 1), (unsigned __int8 **)v9 + 4);
        if (v11 != *((void *)&v56 + 1))
        {
          if (*((char *)v9 + 55) < 0)
          {
            sub_10004FC84(&__p, v9[4], (unint64_t)v9[5]);
          }
          else
          {
            *(_OWORD *)&__p.__r_.__value_.__l.__data_ = *v10;
            __p.__r_.__value_.__r.__words[2] = (std::string::size_type)v9[6];
          }
          uint64_t v13 = v8[46];
          uint64_t v12 = v8[47];
          while (1)
          {
            if (v13 == v12)
            {
              int v15 = 0;
              goto LABEL_19;
            }
            uint64_t v14 = sub_100046F68(v13 + 56, (void **)&__p.__r_.__value_.__l.__data_);
            if ((void **)(v13 + 64) != v14) {
              break;
            }
            v13 += 80;
          }
          *((_WORD *)v14 + 112) = 263;
          int v15 = 1;
LABEL_19:
          if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
          {
            operator delete(__p.__r_.__value_.__l.__data_);
            if (v15)
            {
LABEL_23:
              BOOL v16 = *(NSObject **)(v6 + 40);
              if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
              {
                if (*((char *)v9 + 55) < 0) {
                  uint64_t v10 = *(_OWORD **)v10;
                }
                *(_DWORD *)std::string buf = 136446466;
                *(void *)&uint8_t buf[4] = "kOnDeviceTransferred";
                *(_WORD *)&unsigned char buf[12] = 2080;
                *(void *)&unsigned char buf[14] = v10;
                _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I Updating transfer type to %{public}s, iccid:%s", buf, 0x16u);
              }
            }
          }
          else if (v15)
          {
            goto LABEL_23;
          }
        }
        uint64_t v17 = (char *)v9[1];
        if (v17)
        {
          do
          {
            uint64_t v18 = (char **)v17;
            uint64_t v17 = *(char **)v17;
          }
          while (v17);
        }
        else
        {
          do
          {
            uint64_t v18 = (char **)v9[2];
            BOOL v19 = *v18 == (char *)v9;
            uint64_t v9 = (void **)v18;
          }
          while (!v19);
        }
        uint64_t v9 = (void **)v18;
        if (v18 == v54) {
          goto LABEL_33;
        }
      }
    }
    uint64_t v40 = v7;
  }
  else
  {
    uint64_t v40 = 0;
  }
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v56, kCtLoggingSystemName, "cp.tr.ctr");
  uint64_t v41 = *((void *)&v56 + 1);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v56);
  if (os_log_type_enabled(v41, OS_LOG_TYPE_ERROR))
  {
    LOWORD(v56) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_ERROR, "invalid CellularPlanTransferFlowController (weak_ptr)", (uint8_t *)&v56, 2u);
  }
  *(void *)&long long v56 = 0;
  sub_10031F910((uint64_t)(a1 + 4), (uint64_t)&v56, 5);
  sub_100044D00((const void **)&v56);
  if (v40) {
    sub_10004D2C8(v40);
  }
  sub_10005CD2C((uint64_t)&v43, v44);
}

void sub_100B6E710(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16, uint64_t a17, uint64_t a18, char a19, int a20,__int16 a21,char a22,char a23,int a24,__int16 a25,char a26,char a27,uint64_t a28,uint64_t a29,char a30,void *__p,uint64_t a32,int a33,__int16 a34,char a35,char a36,char a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,char a42)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100B6E860(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100B6E8A0()
{
}

uint64_t sub_100B6E8AC(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = *(_OWORD *)a2;
  uint64_t v3 = *(void *)(a2 + 16);
  *(void *)(a1 + 16) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  sub_10031F4D0(a1 + 24, a2 + 24);
  return a1;
}

void sub_100B6E8FC(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(std::__shared_weak_count **)(v1 + 16);
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  _Unwind_Resume(exception_object);
}

void sub_100B6E914(uint64_t a1)
{
  sub_100313790((void *)(a1 + 24));
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2)
  {
    std::__shared_weak_count::__release_weak(v2);
  }
}

uint64_t sub_100B6E960(uint64_t a1)
{
  *(void *)a1 = off_101A3F180;
  if (*(unsigned char *)(a1 + 1328)) {
    sub_10030D10C(a1 + 80);
  }
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 72);
  if (v2) {
    sub_10004D2C8(v2);
  }
  sub_100060644((void *)(a1 + 32));
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 24);
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  return a1;
}

void sub_100B6E9D0(uint64_t a1)
{
  *(void *)a1 = off_101A3F180;
  if (*(unsigned char *)(a1 + 1328)) {
    sub_10030D10C(a1 + 80);
  }
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 72);
  if (v2) {
    sub_10004D2C8(v2);
  }
  sub_100060644((void *)(a1 + 32));
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 24);
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }

  operator delete();
}

void *sub_100B6EA60(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t v2 = operator new(0x538uLL);
  void *v2 = off_101A3F180;
  sub_100B6EE3C((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_100B6EAB4(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100B6EAC8(uint64_t a1, void *a2)
{
  *a2 = off_101A3F180;
  return sub_100B6EE3C((uint64_t)(a2 + 1), a1 + 8);
}

void sub_100B6EAF4(uint64_t a1)
{
}

void sub_100B6EAFC(void *a1)
{
  sub_100B6EEF4((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_100B6EB38(void *a1, char *a2)
{
  uint64_t v3 = (std::__shared_weak_count *)a1[3];
  if (v3)
  {
    char v4 = *a2;
    uint64_t v5 = a1[1];
    uint64_t v6 = std::__shared_weak_count::lock(v3);
    if (v6 && a1[2])
    {
      sub_1000DFC90((uint64_t)buf, (uint64_t)(a1 + 4));
      uint64_t v7 = a1[9];
      uint64_t v12 = a1[8];
      uint64_t v13 = v7;
      if (v7) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v7 + 8), 1uLL, memory_order_relaxed);
      }
      sub_100311A9C(v14, (uint64_t)(a1 + 10));
      v14[1256] = v4;
      uint64_t v8 = *(std::__shared_weak_count **)(v5 + 16);
      if (v8)
      {
        if (std::__shared_weak_count::lock(v8)) {
          operator new();
        }
      }
      sub_100088B9C();
    }
  }
  else
  {
    uint64_t v6 = 0;
  }
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)buf, kCtLoggingSystemName, "cp.tr.ctr");
  uint64_t v9 = v11;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
  if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "invalid CellularPlanTransferFlowController (weak_ptr)", buf, 2u);
  }
  sub_1000607A8((uint64_t)(a1 + 4), 0);
  if (v6) {
    sub_10004D2C8(v6);
  }
}

void sub_100B6ED7C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100B6EDF0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100B6EE30()
{
}

uint64_t sub_100B6EE3C(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = *(_OWORD *)a2;
  uint64_t v4 = *(void *)(a2 + 16);
  *(void *)(a1 + 16) = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 16), 1uLL, memory_order_relaxed);
  }
  sub_1000DFC90(a1 + 24, a2 + 24);
  uint64_t v5 = *(void *)(a2 + 64);
  *(void *)(a1 + 56) = *(void *)(a2 + 56);
  *(void *)(a1 + 64) = v5;
  if (v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
  }
  sub_100311A9C((unsigned char *)(a1 + 72), a2 + 72);
  return a1;
}

void sub_100B6EEC0(_Unwind_Exception *a1)
{
  uint64_t v4 = *(std::__shared_weak_count **)(v1 + 64);
  if (v4) {
    sub_10004D2C8(v4);
  }
  sub_100060644(v2);
  uint64_t v5 = *(std::__shared_weak_count **)(v1 + 16);
  if (v5) {
    std::__shared_weak_count::__release_weak(v5);
  }
  _Unwind_Resume(a1);
}

void sub_100B6EEF4(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 1320)) {
    sub_10030D10C(a1 + 72);
  }
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 64);
  if (v2) {
    sub_10004D2C8(v2);
  }
  sub_100060644((void *)(a1 + 24));
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (v3)
  {
    std::__shared_weak_count::__release_weak(v3);
  }
}

uint64_t *sub_100B6EF5C(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v4 = a1;
  uint64_t v5 = v1;
  if (*(unsigned char *)(v1 + 1304))
  {
    if (!*(unsigned char *)(v1 + 1296)) {
      sub_10016C840();
    }
    (*(void (**)(void, uint64_t))(**(void **)(v1 + 32) + 304))(*(void *)(v1 + 32), v1 + 48);
    char v2 = *(unsigned char *)(v1 + 1304) == 0;
  }
  else
  {
    char v2 = 1;
  }
  sub_1000607A8(v1, v2);
  sub_100B6F01C(&v5);
  return sub_100046B58((uint64_t *)&v4);
}

void sub_100B6F000(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

uint64_t *sub_100B6F01C(uint64_t *result)
{
  uint64_t v1 = *result;
  *uint64_t result = 0;
  if (v1)
  {
    if (*(unsigned char *)(v1 + 1296)) {
      sub_10030D10C(v1 + 48);
    }
    char v2 = *(std::__shared_weak_count **)(v1 + 40);
    if (v2) {
      sub_10004D2C8(v2);
    }
    sub_100060644((void *)v1);
    operator delete();
  }
  return result;
}

uint64_t sub_100B6F084(uint64_t a1)
{
  *(void *)a1 = off_101A3F200;
  sub_10030DD28((void *)(a1 + 56));
  uint64_t v4 = (void **)(a1 + 32);
  sub_10030B640(&v4);
  char v2 = *(std::__shared_weak_count **)(a1 + 24);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_100B6F0EC(uint64_t a1)
{
  *(void *)a1 = off_101A3F200;
  sub_10030DD28((void *)(a1 + 56));
  uint64_t v3 = (void **)(a1 + 32);
  sub_10030B640(&v3);
  char v2 = *(std::__shared_weak_count **)(a1 + 24);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  operator delete();
}

void *sub_100B6F168(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  char v2 = operator new(0x58uLL);
  void *v2 = off_101A3F200;
  sub_100B6F7B0((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_100B6F1BC(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100B6F1D0(uint64_t a1, void *a2)
{
  *a2 = off_101A3F200;
  return sub_100B6F7B0((uint64_t)(a2 + 1), a1 + 8);
}

void sub_100B6F1FC(uint64_t a1)
{
}

void sub_100B6F204(void *a1)
{
  sub_100B6F860((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_100B6F240(void *a1, void *a2)
{
  uint64_t v3 = a2 + 1;
  uint64_t v4 = a2[1];
  char v27 = (char **)*a2;
  long long v28 = (char *)v4;
  if (a2[2])
  {
    *(void *)(v4 + 16) = &v28;
    *a2 = v3;
    void *v3 = 0;
    a2[2] = 0;
  }
  else
  {
    char v27 = &v28;
  }
  uint64_t v5 = (std::__shared_weak_count *)a1[3];
  if (v5 && (uint64_t v6 = a1[1], (v23 = std::__shared_weak_count::lock(v5)) != 0))
  {
    if (a1[2])
    {
      unint64_t v22 = a1;
      uint64_t v7 = *(void *)(v6 + 144);
      uint64_t v24 = *(void *)(v6 + 152);
      if (v7 != v24)
      {
        do
        {
          uint64_t v25 = v7;
          if (*(unsigned char *)(v7 + 240))
          {
            uint64_t v9 = *(void *)(v7 + 200);
            uint64_t v8 = *(void *)(v7 + 208);
            uint64_t v26 = v8;
            while (v9 != v8)
            {
              if (*(unsigned char *)(v9 + 80))
              {
                uint64_t v10 = *(void *)(v9 + 56);
                for (uint64_t i = *(void *)(v9 + 64); v10 != i; v10 += 216)
                {
                  memset(v41, 0, 32);
                  *(_OWORD *)uint64_t v40 = 0u;
                  *(_OWORD *)int v38 = 0u;
                  memset(v39, 0, sizeof(v39));
                  *(_OWORD *)std::string buf = 0u;
                  long long v37 = 0u;
                  if (*(char *)(v10 + 119) < 0)
                  {
                    sub_10004FC84(v38, *(void **)(v10 + 96), *(void *)(v10 + 104));
                  }
                  else
                  {
                    long long v12 = *(_OWORD *)(v10 + 96);
                    v39[0] = *(void **)(v10 + 112);
                    *(_OWORD *)int v38 = v12;
                  }
                  if (*(char *)(v10 + 143) < 0)
                  {
                    sub_10004FC84(&v39[1], *(void **)(v10 + 120), *(void *)(v10 + 128));
                  }
                  else
                  {
                    long long v13 = *(_OWORD *)(v10 + 120);
                    void v39[3] = *(void **)(v10 + 136);
                    *(_OWORD *)&v39[1] = v13;
                  }
                  if (*(char *)(v10 + 167) < 0)
                  {
                    sub_10004FC84(v40, *(void **)(v10 + 144), *(void *)(v10 + 152));
                  }
                  else
                  {
                    long long v14 = *(_OWORD *)(v10 + 144);
                    v41[0] = *(void **)(v10 + 160);
                    *(_OWORD *)uint64_t v40 = v14;
                  }
                  if (*(char *)(v10 + 191) < 0)
                  {
                    sub_10004FC84(&v41[1], *(void **)(v10 + 168), *(void *)(v10 + 176));
                  }
                  else
                  {
                    long long v15 = *(_OWORD *)(v10 + 168);
                    void v41[3] = *(void **)(v10 + 184);
                    *(_OWORD *)&v41[1] = v15;
                  }
                  sub_100A9CFA4((const void **)buf, __p);
                  uint64_t v17 = sub_100046F68((uint64_t)&v27, __p);
                  if (v35 < 0) {
                    operator delete(__p[0]);
                  }
                  if (&v28 != (char **)v17 && !*((unsigned char *)v17 + 56))
                  {
                    if (*(char *)(v10 + 39) < 0)
                    {
                      sub_10004FC84(__dst, *(void **)(v10 + 16), *(void *)(v10 + 24));
                    }
                    else
                    {
                      long long v18 = *(_OWORD *)(v10 + 16);
                      uint64_t v33 = *(void *)(v10 + 32);
                      *(_OWORD *)long long __dst = v18;
                    }
                    ctu::hex((uint64_t *)v30, (ctu *)(v9 + 16), (const void *)0x10, v16);
                    sub_100B554EC(*(void *)(v6 + 144), *(void *)(v6 + 152), 17, (uint64_t)__dst, (unsigned __int8 *)v30);
                    if (v31 < 0) {
                      operator delete(v30[0]);
                    }
                    if (SHIBYTE(v33) < 0) {
                      operator delete(__dst[0]);
                    }
                  }
                  if (SHIBYTE(v41[3]) < 0) {
                    operator delete(v41[1]);
                  }
                  if (SHIBYTE(v41[0]) < 0) {
                    operator delete(v40[0]);
                  }
                  if (SHIBYTE(v39[3]) < 0) {
                    operator delete(v39[1]);
                  }
                  if (SHIBYTE(v39[0]) < 0) {
                    operator delete(v38[0]);
                  }
                  if (BYTE8(v37))
                  {
                    if (SBYTE7(v37) < 0) {
                      operator delete(*(void **)buf);
                    }
                  }
                }
              }
              v9 += 88;
              uint64_t v8 = v26;
            }
          }
          uint64_t v7 = v25 + 400;
        }
        while (v25 + 400 != v24);
      }
      sub_10005DD08((uint64_t *)buf, (uint64_t)&v27);
      uint64_t v19 = v22[10];
      if (!v19) {
        sub_10007B600();
      }
      (*(void (**)(uint64_t, uint8_t *))(*(void *)v19 + 48))(v19, buf);
      goto LABEL_57;
    }
  }
  else
  {
    uint64_t v23 = 0;
  }
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)buf, kCtLoggingSystemName, "cp.tr.ctr");
  uint64_t v20 = *(NSObject **)&buf[8];
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
  if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, "invalid CellularPlanTransferFlowController (weak_ptr)", buf, 2u);
  }
  *(void *)&uint8_t buf[8] = 0;
  *(void *)&long long v37 = 0;
  *(void *)std::string buf = &buf[8];
  uint64_t v21 = a1[10];
  if (!v21) {
    sub_10007B600();
  }
  (*(void (**)(uint64_t, uint8_t *))(*(void *)v21 + 48))(v21, buf);
LABEL_57:
  sub_10005CD2C((uint64_t)buf, *(char **)&buf[8]);
  if (v23) {
    sub_10004D2C8(v23);
  }
  sub_10005CD2C((uint64_t)&v27, v28);
}

void sub_100B6F65C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  sub_10005CD2C((uint64_t)&a15, (char *)a16);
  _Unwind_Resume(a1);
}

uint64_t sub_100B6F764(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100B6F7A4()
{
}

uint64_t sub_100B6F7B0(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = *(_OWORD *)a2;
  uint64_t v4 = *(void *)(a2 + 16);
  *(void *)(a1 + 16) = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 16), 1uLL, memory_order_relaxed);
  }
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  sub_10030B4A4((void *)(a1 + 24), *(void *)(a2 + 24), *(void *)(a2 + 32), (uint64_t)(*(void *)(a2 + 32) - *(void *)(a2 + 24)) >> 7);
  sub_10033D1E4(a1 + 48, a2 + 48);
  return a1;
}

void sub_100B6F834(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_10030B640((void ***)va);
  uint64_t v4 = *(std::__shared_weak_count **)(v2 + 16);
  if (v4) {
    std::__shared_weak_count::__release_weak(v4);
  }
  _Unwind_Resume(a1);
}

void sub_100B6F860(uint64_t a1)
{
  sub_10030DD28((void *)(a1 + 48));
  uint64_t v3 = (void **)(a1 + 24);
  sub_10030B640(&v3);
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
}

void *sub_100B6F8AC(void *a1)
{
  *a1 = off_101A3F280;
  sub_10034B83C(a1 + 4);
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_100B6F8FC(void *a1)
{
  *a1 = off_101A3F280;
  sub_10034B83C(a1 + 4);
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete();
}

void *sub_100B6F96C(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t v2 = operator new(0x40uLL);
  void *v2 = off_101A3F280;
  sub_100B6FE20((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_100B6F9C0(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100B6F9D4(uint64_t a1, void *a2)
{
  *a2 = off_101A3F280;
  return sub_100B6FE20((uint64_t)(a2 + 1), a1 + 8);
}

void sub_100B6FA00(uint64_t a1)
{
}

void sub_100B6FA08(void *a1)
{
  sub_10034D1D4((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_100B6FA44(void *a1, unsigned __int8 *a2, void *a3)
{
  unsigned int v4 = *a2;
  uint64_t v5 = a3 + 1;
  uint64_t v6 = (void *)a3[1];
  uint64_t v20 = (void **)*a3;
  uint64_t v21 = v6;
  if (a3[2])
  {
    void v6[2] = &v21;
    *a3 = v5;
    *uint64_t v5 = 0;
    a3[2] = 0;
  }
  else
  {
    uint64_t v20 = &v21;
  }
  uint64_t v7 = (std::__shared_weak_count *)a1[3];
  if (!v7)
  {
    uint64_t v9 = 0;
LABEL_12:
    *((void *)&buf + 1) = 0;
    uint64_t v24 = 0;
    *(void *)&long long buf = (char *)&buf + 8;
    uint64_t v12 = a1[7];
    if (!v12) {
      sub_10007B600();
    }
    (*(void (**)(uint64_t, long long *))(*(void *)v12 + 48))(v12, &buf);
    goto LABEL_14;
  }
  uint64_t v8 = a1[1];
  uint64_t v9 = std::__shared_weak_count::lock(v7);
  if (!v9 || !a1[2]) {
    goto LABEL_12;
  }
  if (v4)
  {
    uint64_t v10 = *(NSObject **)(v8 + 40);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      if (v4 > 6) {
        uint64_t v19 = "kSuccess";
      }
      else {
        uint64_t v19 = off_101A3FE30[(char)(v4 - 1)];
      }
      LODWORD(buf) = 136315138;
      *(void *)((char *)&buf + 4) = v19;
      _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "fetch AKRemoteDevice failure : %s", (uint8_t *)&buf, 0xCu);
    }
    *((void *)&buf + 1) = 0;
    uint64_t v24 = 0;
    *(void *)&long long buf = (char *)&buf + 8;
    uint64_t v11 = a1[7];
    if (!v11) {
      sub_10007B600();
    }
    (*(void (**)(uint64_t, long long *))(*(void *)v11 + 48))(v11, &buf);
    sub_100313460((uint64_t)&buf, *((void **)&buf + 1));
    goto LABEL_15;
  }
  long long v13 = *(void ***)(v8 + 720);
  if (v13 == (void **)(v8 + 728))
  {
LABEL_25:
    uint64_t v17 = *(NSObject **)(v8 + 40);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
    {
      LOWORD(buf) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "invalid AKRemoteDevice lists - cannot find self device", (uint8_t *)&buf, 2u);
    }
    *((void *)&buf + 1) = 0;
    uint64_t v24 = 0;
    *(void *)&long long buf = (char *)&buf + 8;
    uint64_t v18 = a1[7];
    if (!v18) {
      sub_10007B600();
    }
  }
  else
  {
    while (!sub_10010E128((uint64_t)&v20, v13 + 5))
    {
      long long v14 = (void **)v13[1];
      if (v14)
      {
        do
        {
          long long v15 = v14;
          long long v14 = (void **)*v14;
        }
        while (v14);
      }
      else
      {
        do
        {
          long long v15 = (void **)v13[2];
          BOOL v16 = *v15 == v13;
          long long v13 = v15;
        }
        while (!v16);
      }
      long long v13 = v15;
      if (v15 == (void **)(v8 + 728)) {
        goto LABEL_25;
      }
    }
    sub_10034D220((uint64_t *)&buf, (uint64_t)&v20);
    uint64_t v18 = a1[7];
    if (!v18) {
      sub_10007B600();
    }
  }
  (*(void (**)(uint64_t, long long *))(*(void *)v18 + 48))(v18, &buf);
LABEL_14:
  sub_100313460((uint64_t)&buf, *((void **)&buf + 1));
  if (v9) {
LABEL_15:
  }
    sub_10004D2C8(v9);
  sub_100313460((uint64_t)&v20, v21);
}

void sub_100B6FD7C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11)
{
  if (v11) {
    sub_10004D2C8(v11);
  }
  sub_100313460((uint64_t)&a10, a11);
  _Unwind_Resume(a1);
}

uint64_t sub_100B6FDD4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100B6FE14()
{
}

uint64_t sub_100B6FE20(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = *(_OWORD *)a2;
  uint64_t v3 = *(void *)(a2 + 16);
  *(void *)(a1 + 16) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  sub_10034D13C(a1 + 24, a2 + 24);
  return a1;
}

void sub_100B6FE70(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(std::__shared_weak_count **)(v1 + 16);
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t *sub_100B6FE88(uint64_t **a1, void **a2, uint64_t a3, long long **a4)
{
  uint64_t v11 = 0;
  uint64_t v6 = (uint64_t **)sub_100046ED4((uint64_t)a1, &v11, a2);
  uint64_t v7 = *v6;
  if (!*v6)
  {
    uint64_t v8 = v6;
    memset(v10, 0, sizeof(v10));
    sub_100B6FF40((uint64_t)a1, a4, v10);
    sub_100046C38(a1, v11, v8, v10[0]);
    uint64_t v7 = v10[0];
    v10[0] = 0;
    sub_100B6FFDC((uint64_t)v10, 0);
  }
  return v7;
}

unsigned char *sub_100B6FF40@<X0>(uint64_t a1@<X0>, long long **a2@<X2>, void *a3@<X8>)
{
  uint64_t v5 = a1 + 8;
  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  uint64_t v6 = (char *)operator new(0x40uLL);
  *a3 = v6;
  a3[1] = v5;
  *((unsigned char *)a3 + 16) = 0;
  uint64_t result = v6 + 32;
  uint64_t v8 = *a2;
  if (*((char *)*a2 + 23) < 0)
  {
    uint64_t result = sub_10004FC84(result, *(void **)v8, *((void *)v8 + 1));
  }
  else
  {
    long long v9 = *v8;
    *((void *)v6 + 6) = *((void *)v8 + 2);
    *(_OWORD *)uint64_t result = v9;
  }
  *((void *)v6 + 7) = 0;
  *((unsigned char *)a3 + 16) = 1;
  return result;
}

void sub_100B6FFC4(_Unwind_Exception *a1)
{
  sub_100B6FFDC(v1, 0);
  _Unwind_Resume(a1);
}

void sub_100B6FFDC(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void **)a1;
  *(void *)a1 = a2;
  if (v2)
  {
    if (*(unsigned char *)(a1 + 16)) {
      sub_10008E614((uint64_t)v2 + 32);
    }
    operator delete(v2);
  }
}

uint64_t *sub_100B70034(uint64_t **a1, void **a2, long long **a3)
{
  uint64_t v6 = a1 + 1;
  uint64_t v5 = a1[1];
  uint64_t v7 = a1 + 1;
  uint64_t v8 = a1 + 1;
  if (!v5) {
    goto LABEL_10;
  }
  uint64_t v7 = a1 + 1;
  while (1)
  {
    while (1)
    {
      uint64_t v8 = (uint64_t **)v5;
      uint64_t v10 = v5 + 4;
      if ((sub_100046FE8(a2, (void **)v5 + 4) & 0x80) == 0) {
        break;
      }
      uint64_t v5 = *v8;
      uint64_t v7 = v8;
      if (!*v8) {
        goto LABEL_10;
      }
    }
    if ((sub_100046FE8(v10, a2) & 0x80) == 0) {
      break;
    }
    uint64_t v7 = v8 + 1;
    uint64_t v5 = v8[1];
    if (!v5) {
      goto LABEL_10;
    }
  }
  uint64_t v11 = *v7;
  if (!*v7)
  {
LABEL_10:
    uint64_t v12 = *a3;
    uint64_t v19 = 0;
    long long v13 = (uint64_t *)operator new(0x48uLL);
    v18[0] = v13;
    v18[1] = v6;
    long long v14 = v13 + 4;
    if (*((char *)v12 + 23) < 0)
    {
      sub_10004FC84(v14, *(void **)v12, *((void *)v12 + 1));
    }
    else
    {
      long long v15 = *v12;
      v13[6] = *((void *)v12 + 2);
      *(_OWORD *)long long v14 = v15;
    }
    uint64_t v13[7] = 0;
    unsigned char v13[8] = 0;
    LOBYTE(v19) = 1;
    *long long v13 = 0;
    v13[1] = 0;
    _DWORD v13[2] = (uint64_t)v8;
    uint64_t *v7 = v13;
    BOOL v16 = (uint64_t *)**a1;
    if (v16)
    {
      *a1 = v16;
      long long v13 = *v7;
    }
    sub_100046C90(a1[1], v13);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
    uint64_t v11 = (uint64_t *)v18[0];
    v18[0] = 0;
    sub_1001FEBC4((uint64_t)v18);
  }
  return v11;
}

void sub_100B70180(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1001FEBC4((uint64_t)va);
  _Unwind_Resume(a1);
}

void *sub_100B70194(void *a1)
{
  *a1 = off_101A3F300;
  uint64_t v2 = (std::__shared_weak_count *)a1[5];
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)a1[3];
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  return a1;
}

void sub_100B701EC(void *a1)
{
  *a1 = off_101A3F300;
  uint64_t v2 = (std::__shared_weak_count *)a1[5];
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)a1[3];
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }

  operator delete();
}

char *sub_100B70264(uint64_t a1)
{
  uint64_t result = (char *)operator new(0x30uLL);
  *(void *)uint64_t result = off_101A3F300;
  *(_OWORD *)(result + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 24);
  *((void *)result + 3) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  uint64_t v4 = *(void *)(a1 + 40);
  *((void *)result + 4) = *(void *)(a1 + 32);
  *((void *)result + 5) = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_100B702E0(uint64_t result, uint64_t a2)
{
  *(void *)a2 = off_101A3F300;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(result + 8);
  uint64_t v2 = *(void *)(result + 24);
  *(void *)(a2 + 24) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  uint64_t v3 = *(void *)(result + 40);
  *(void *)(a2 + 32) = *(void *)(result + 32);
  *(void *)(a2 + 40) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100B70338(uint64_t a1)
{
}

void sub_100B70340(void *a1)
{
  sub_100388C68((uint64_t)a1 + 8);

  operator delete(a1);
}

uint64_t sub_100B7037C(void *a1, unsigned __int8 *a2)
{
  int v3 = *a2;
  uint64_t v4 = (std::__shared_weak_count *)a1[3];
  if (v4)
  {
    uint64_t v5 = a1[1];
    uint64_t v6 = std::__shared_weak_count::lock(v4);
    if (v6)
    {
      uint64_t v7 = v6;
      if (a1[2])
      {
        uint64_t v8 = *(NSObject **)(v5 + 40);
        if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
        {
          long long v9 = "success";
          if (!v3) {
            long long v9 = "failure";
          }
          LODWORD(v11) = 136315138;
          *(void *)((char *)&v11 + 4) = v9;
          _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Record delete : %s", (uint8_t *)&v11, 0xCu);
        }
      }
      sub_10004D2C8(v7);
    }
  }
  uint64_t result = a1[4];
  if (result)
  {
    long long v11 = xmmword_101546590;
    BYTE8(v11) = v3;
    return (*(uint64_t (**)(uint64_t, long long *))(*(void *)result + 104))(result, &v11);
  }
  return result;
}

uint64_t sub_100B704A8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100B704E8()
{
}

void sub_100B704F4(std::string *a1, uint64_t a2)
{
  std::operator+<char>();
  uint64_t v4 = std::string::append(&v22, ", IMEI:", 7uLL);
  long long v5 = *(_OWORD *)&v4->__r_.__value_.__l.__data_;
  v23.__r_.__value_.__r.__words[2] = v4->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v23.__r_.__value_.__l.__data_ = v5;
  v4->__r_.__value_.__l.__size_ = 0;
  v4->__r_.__value_.__r.__words[2] = 0;
  v4->__r_.__value_.__r.__words[0] = 0;
  int v6 = *(char *)(a2 + 23);
  if (v6 >= 0) {
    uint64_t v7 = (const std::string::value_type *)a2;
  }
  else {
    uint64_t v7 = *(const std::string::value_type **)a2;
  }
  if (v6 >= 0) {
    std::string::size_type v8 = *(unsigned __int8 *)(a2 + 23);
  }
  else {
    std::string::size_type v8 = *(void *)(a2 + 8);
  }
  long long v9 = std::string::append(&v23, v7, v8);
  long long v10 = *(_OWORD *)&v9->__r_.__value_.__l.__data_;
  v24.__r_.__value_.__r.__words[2] = v9->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v24.__r_.__value_.__l.__data_ = v10;
  v9->__r_.__value_.__l.__size_ = 0;
  v9->__r_.__value_.__r.__words[2] = 0;
  v9->__r_.__value_.__r.__words[0] = 0;
  long long v11 = std::string::append(&v24, ", EID:", 6uLL);
  long long v12 = *(_OWORD *)&v11->__r_.__value_.__l.__data_;
  v25.__r_.__value_.__r.__words[2] = v11->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v25.__r_.__value_.__l.__data_ = v12;
  v11->__r_.__value_.__l.__size_ = 0;
  v11->__r_.__value_.__r.__words[2] = 0;
  v11->__r_.__value_.__r.__words[0] = 0;
  long long v15 = *(const std::string::value_type **)(a2 + 24);
  uint64_t v14 = a2 + 24;
  long long v13 = v15;
  int v16 = *(char *)(v14 + 23);
  if (v16 >= 0) {
    uint64_t v17 = (const std::string::value_type *)v14;
  }
  else {
    uint64_t v17 = v13;
  }
  if (v16 >= 0) {
    std::string::size_type v18 = *(unsigned __int8 *)(v14 + 23);
  }
  else {
    std::string::size_type v18 = *(void *)(v14 + 8);
  }
  uint64_t v19 = std::string::append(&v25, v17, v18);
  long long v20 = *(_OWORD *)&v19->__r_.__value_.__l.__data_;
  v26.__r_.__value_.__r.__words[2] = v19->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v26.__r_.__value_.__l.__data_ = v20;
  v19->__r_.__value_.__l.__size_ = 0;
  v19->__r_.__value_.__r.__words[2] = 0;
  v19->__r_.__value_.__r.__words[0] = 0;
  uint64_t v21 = std::string::append(&v26, " }", 2uLL);
  *a1 = *v21;
  v21->__r_.__value_.__l.__size_ = 0;
  v21->__r_.__value_.__r.__words[2] = 0;
  v21->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v26.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v26.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v25.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v25.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v24.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v24.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v23.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v23.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v22.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v22.__r_.__value_.__l.__data_);
  }
}

void sub_100B7067C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  if (*(char *)(v28 - 25) < 0) {
    operator delete(*(void **)(v28 - 48));
  }
  if (*(char *)(v28 - 57) < 0) {
    operator delete(*(void **)(v28 - 80));
  }
  if (a28 < 0) {
    operator delete(__p);
  }
  if (a21 < 0) {
    operator delete(a16);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  _Unwind_Resume(exception_object);
}

void *sub_100B706F8(void *a1)
{
  *a1 = off_101A3F380;
  uint64_t v2 = (std::__shared_weak_count *)a1[5];
  if (v2) {
    sub_10004D2C8(v2);
  }
  int v3 = (std::__shared_weak_count *)a1[3];
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  return a1;
}

void sub_100B70750(void *a1)
{
  *a1 = off_101A3F380;
  uint64_t v2 = (std::__shared_weak_count *)a1[5];
  if (v2) {
    sub_10004D2C8(v2);
  }
  int v3 = (std::__shared_weak_count *)a1[3];
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }

  operator delete();
}

char *sub_100B707C8(uint64_t a1)
{
  uint64_t result = (char *)operator new(0x30uLL);
  *(void *)uint64_t result = off_101A3F380;
  *(_OWORD *)(result + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 24);
  *((void *)result + 3) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  uint64_t v4 = *(void *)(a1 + 40);
  *((void *)result + 4) = *(void *)(a1 + 32);
  *((void *)result + 5) = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_100B70844(uint64_t result, uint64_t a2)
{
  *(void *)a2 = off_101A3F380;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(result + 8);
  uint64_t v2 = *(void *)(result + 24);
  *(void *)(a2 + 24) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  uint64_t v3 = *(void *)(result + 40);
  *(void *)(a2 + 32) = *(void *)(result + 32);
  *(void *)(a2 + 40) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100B7089C(uint64_t a1)
{
}

void sub_100B708A4(void *a1)
{
  sub_100388C68((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_100B708E0(void *a1, uint64_t *a2)
{
  uint64_t v3 = *a2;
  unint64_t v4 = HIDWORD(*a2);
  long long v5 = (std::__shared_weak_count *)a1[3];
  if (v5)
  {
    uint64_t v6 = a1[1];
    uint64_t v7 = std::__shared_weak_count::lock(v5);
    if (v7)
    {
      std::string::size_type v8 = v7;
      if (a1[2])
      {
        long long v9 = *(NSObject **)(v6 + 40);
        if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
        {
          long long v11 = "succeed";
          if ((v3 & 1) == 0) {
            long long v11 = "fail";
          }
          *(_DWORD *)long long v13 = 136315650;
          *(void *)&void v13[4] = v11;
          if ((v3 & 0x100) != 0) {
            long long v12 = "true";
          }
          else {
            long long v12 = "false";
          }
          *(_WORD *)uint64_t v14 = 2080;
          *(void *)&void v14[2] = v12;
          __int16 v15 = 1024;
          int v16 = v4;
          _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "deleting blocklist %s. modified: %s, with error code: %d", v13, 0x1Cu);
        }
      }
      sub_10004D2C8(v8);
    }
  }
  if ((v3 & 0x100) != 0)
  {
    uint64_t v10 = a1[4];
    if (v10)
    {
      *(void *)long long v13 = 0x800002000;
      *(_DWORD *)&unsigned char v13[8] = 256;
      *(_DWORD *)uint64_t v14 = v4;
      unsigned char v13[8] = v3 & 1;
      (*(void (**)(uint64_t, unsigned char *))(*(void *)v10 + 104))(v10, v13);
    }
  }
}

uint64_t sub_100B70A5C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100B70A9C()
{
}

uint64_t *sub_100B70AA8(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v7 = a1;
  uint64_t v8 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v3 = *(NSObject **)(*(void *)v1 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    unsigned int v4 = *(unsigned __int8 *)(v1 + 168) - 2;
    if (v4 > 2) {
      long long v5 = "kAccepted";
    }
    else {
      long long v5 = off_101A3FE60[(char)v4];
    }
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = v5;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I abort due to consent : %s", buf, 0xCu);
  }
  long long v9 = 0;
  uint64_t v10 = 0;
  sub_100B3EA60(v2, v1 + 272, 11, 45, &v10, &v9);
  sub_100057D78(&v9);
  sub_1000558F4(&v10);
  if (*(char *)(v1 + 295) < 0)
  {
    sub_10004FC84(buf, *(void **)(v1 + 272), *(void *)(v1 + 280));
  }
  else
  {
    *(_OWORD *)long long buf = *(_OWORD *)(v1 + 272);
    uint64_t v12 = *(void *)(v1 + 288);
  }
  sub_100B4A3B8(v2, (uint64_t)buf);
  if (SHIBYTE(v12) < 0) {
    operator delete(*(void **)buf);
  }
  sub_100B3F548(v2);
  sub_100B70C5C(&v8);
  return sub_100046B58((uint64_t *)&v7);
}

void sub_100B70C10(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, __int16 a11, char a12, char a13, int a14, __int16 a15, char a16, char a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  if (a23 < 0) {
    operator delete(__p);
  }
  sub_100B70C5C(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_100B70C5C(uint64_t *result)
{
  uint64_t v1 = *result;
  *uint64_t result = 0;
  if (v1)
  {
    if (*(char *)(v1 + 295) < 0) {
      operator delete(*(void **)(v1 + 272));
    }
    if (*(unsigned char *)(v1 + 264)) {
      sub_1000C5578(v1 + 8);
    }
    operator delete();
  }
  return result;
}

void sub_100B70CC4(uint64_t **a1)
{
  uint64_t v2 = a1;
  uint64_t v1 = **a1;
  sub_100B3F32C(v1);
  sub_100B3F548(v1);
  operator delete();
}

void sub_100B70D24()
{
}

uint64_t *sub_100B70D50(uint64_t *a1)
{
  uint64_t v1 = *a1;
  std::string v25 = a1;
  uint64_t v26 = v1;
  uint64_t v2 = *(void *)v1;
  long long __dst = 0uLL;
  uint64_t v49 = 0;
  sub_100B3F0F4((uint64_t)&__dst, *(void *)(v2 + 304), *(void *)(v2 + 312), (unsigned __int8 **)(v1 + 24));
  (***(void (****)(Registry **__return_ptr))(v2 + 48))(&v27);
  ServiceMap = (std::mutex *)Registry::getServiceMap(v3, v27);
  long long v5 = ServiceMap;
  if (v6 < 0)
  {
    uint64_t v7 = (unsigned __int8 *)(v6 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v8 = 5381;
    do
    {
      uint64_t v6 = v8;
      unsigned int v9 = *v7++;
      uint64_t v8 = (33 * v8) ^ v9;
    }
    while (v9);
  }
  std::mutex::lock(ServiceMap);
  int v50 = (Registry *)v6;
  uint64_t v10 = sub_10004D37C(&v5[1].__m_.__sig, (unint64_t *)&v50);
  if (v10)
  {
    uint64_t v11 = v10[3];
    uint64_t v12 = (std::__shared_weak_count *)v10[4];
    if (v12)
    {
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v5);
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v12);
      char v24 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v11 = 0;
  }
  std::mutex::unlock(v5);
  uint64_t v12 = 0;
  char v24 = 1;
LABEL_9:
  if ((void)v28) {
    sub_10004D2C8((std::__shared_weak_count *)v28);
  }
  long long v47 = 0uLL;
  (***(void (****)(Registry **__return_ptr))(v2 + 48))(&v50);
  Registry::getNotificationSenderFactory((uint64_t *)&v27, v50);
  long long v13 = v27;
  (***(void (****)(Registry **__return_ptr))(v2 + 48))(&v43);
  Registry::getTimerService(&v45, v43);
  (*(void (**)(long long *__return_ptr, Registry *, uint64_t *, uint64_t))(*(void *)v13 + 160))(&v47, v13, &v45, v2 + 24);
  if (v46) {
    sub_10004D2C8(v46);
  }
  if (v44) {
    sub_10004D2C8(v44);
  }
  if ((void)v28) {
    sub_10004D2C8((std::__shared_weak_count *)v28);
  }
  if (v51) {
    sub_10004D2C8(v51);
  }
  uint64_t v14 = *(void *)(v1 + 8);
  sub_100B49888((CFStringRef *)&v27, v2);
  if (SHIBYTE(v49) < 0)
  {
    sub_10004FC84(&v28, (void *)__dst, *((unint64_t *)&__dst + 1));
  }
  else
  {
    long long v28 = __dst;
    uint64_t v29 = v49;
  }
  if (*(char *)(v1 + 47) < 0)
  {
    sub_10004FC84(&v30, *(void **)(v1 + 24), *(void *)(v1 + 32));
  }
  else
  {
    long long v15 = *(_OWORD *)(v1 + 24);
    uint64_t v31 = *(void *)(v1 + 40);
    long long v30 = v15;
  }
  sub_1000593FC((uint64_t)&v32, (long long *)(v1 + 72));
  *(void *)&long long v35 = *(void *)(v1 + 8);
  uint64_t v16 = *(void *)(v1 + 16);
  *((void *)&v35 + 1) = v16;
  if (v16) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v16 + 8), 1uLL, memory_order_relaxed);
  }
  *(void *)&long long v36 = v11;
  *((void *)&v36 + 1) = v12;
  if ((v24 & 1) == 0) {
    atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (*(char *)(v1 + 127) < 0)
  {
    sub_10004FC84(&v37, *(void **)(v1 + 104), *(void *)(v1 + 112));
  }
  else
  {
    long long v17 = *(_OWORD *)(v1 + 104);
    uint64_t v38 = *(void *)(v1 + 120);
    long long v37 = v17;
  }
  if (*(char *)(v1 + 151) < 0)
  {
    sub_10004FC84(&v39, *(void **)(v1 + 128), *(void *)(v1 + 136));
  }
  else
  {
    long long v18 = *(_OWORD *)(v1 + 128);
    uint64_t v40 = *(void *)(v1 + 144);
    long long v39 = v18;
  }
  long long v41 = v47;
  if (*((void *)&v47 + 1)) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v47 + 1) + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v42 = v2;
  uint64_t v52 = 0;
  uint64_t v19 = (char *)operator new(0xC8uLL);
  *(void *)uint64_t v19 = off_101A3F400;
  *((void *)v19 + 1) = v27;
  char v27 = 0;
  *((_OWORD *)v19 + 1) = v28;
  *((void *)v19 + 4) = v29;
  long long v28 = 0uLL;
  uint64_t v29 = 0;
  long long v20 = v19 + 40;
  if (SHIBYTE(v31) < 0)
  {
    sub_10004FC84(v20, (void *)v30, *((unint64_t *)&v30 + 1));
  }
  else
  {
    *(_OWORD *)long long v20 = v30;
    *((void *)v19 + 7) = v31;
  }
  v19[64] = 0;
  v19[88] = 0;
  if (v34)
  {
    *((_OWORD *)v19 + 4) = v32;
    *((void *)v19 + 10) = v33;
    uint64_t v33 = 0;
    long long v32 = 0uLL;
    v19[88] = 1;
  }
  long long v21 = v35;
  long long v22 = v36;
  long long v35 = 0uLL;
  *((_OWORD *)v19 + 6) = v21;
  *((_OWORD *)v19 + 7) = v22;
  long long v36 = 0uLL;
  *((_OWORD *)v19 + 8) = v37;
  *((void *)v19 + 18) = v38;
  long long v37 = 0uLL;
  uint64_t v38 = 0;
  *((void *)v19 + 21) = v40;
  *(_OWORD *)(v19 + 152) = v39;
  long long v39 = 0uLL;
  uint64_t v40 = 0;
  *((_OWORD *)v19 + 11) = v41;
  long long v41 = 0uLL;
  *((void *)v19 + 24) = v42;
  uint64_t v52 = v19;
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, Registry **))(*(void *)v14 + 48))(v14, v1 + 24, v1 + 48, v1 + 72, &v50);
  sub_100060644(&v50);
  sub_100B714E0((uint64_t)&v27);
  if (*((void *)&v47 + 1)) {
    sub_10004D2C8(*((std::__shared_weak_count **)&v47 + 1));
  }
  if ((v24 & 1) == 0) {
    sub_10004D2C8(v12);
  }
  if (SHIBYTE(v49) < 0) {
    operator delete((void *)__dst);
  }
  sub_100B71434(&v26);
  return sub_100046B58((uint64_t *)&v25);
}

void sub_100B71290(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, int a11, char a12, uint64_t a13, uint64_t a14, __int16 a15, char a16, char a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,void *a24,uint64_t a25,int a26,__int16 a27,char a28,char a29,void *a30,uint64_t a31,int a32,__int16 a33,char a34,char a35,char a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,void *__p,uint64_t a42,int a43,__int16 a44,char a45,char a46)
{
  if (v47[39] < 0) {
    operator delete(*v48);
  }
  sub_1000558F4(v46);
  operator delete(v47);
  sub_100B714E0((uint64_t)&a15);
  char v51 = *(std::__shared_weak_count **)(v49 - 160);
  if (v51) {
    sub_10004D2C8(v51);
  }
  if ((a12 & 1) == 0) {
    sub_10004D2C8(a10);
  }
  if (*(char *)(v49 - 129) < 0) {
    operator delete(*(void **)(v49 - 152));
  }
  sub_100B71434(&a14);
  sub_100046B58(&a13);
  _Unwind_Resume(a1);
}

void sub_100B713FC()
{
}

void sub_100B71404(void *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  JUMPOUT(0x100B713F4);
}

void sub_100B71414()
{
}

void sub_100B7141C()
{
}

void sub_100B71424(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15)
{
  if (!a15) {
    JUMPOUT(0x100B713D4);
  }
  JUMPOUT(0x100B713D0);
}

uint64_t *sub_100B71434(uint64_t *result)
{
  uint64_t v1 = *result;
  *uint64_t result = 0;
  if (v1)
  {
    if (*(char *)(v1 + 151) < 0) {
      operator delete(*(void **)(v1 + 128));
    }
    if (*(char *)(v1 + 127) < 0) {
      operator delete(*(void **)(v1 + 104));
    }
    if (*(unsigned char *)(v1 + 96) && *(char *)(v1 + 95) < 0) {
      operator delete(*(void **)(v1 + 72));
    }
    if (*(char *)(v1 + 71) < 0) {
      operator delete(*(void **)(v1 + 48));
    }
    if (*(char *)(v1 + 47) < 0) {
      operator delete(*(void **)(v1 + 24));
    }
    uint64_t v2 = *(std::__shared_weak_count **)(v1 + 16);
    if (v2) {
      sub_10004D2C8(v2);
    }
    operator delete();
  }
  return result;
}

const void **sub_100B714E0(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 176);
  if (v2) {
    sub_10004D2C8(v2);
  }
  if (*(char *)(a1 + 167) < 0) {
    operator delete(*(void **)(a1 + 144));
  }
  if (*(char *)(a1 + 143) < 0) {
    operator delete(*(void **)(a1 + 120));
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 112);
  if (v3) {
    sub_10004D2C8(v3);
  }
  unsigned int v4 = *(std::__shared_weak_count **)(a1 + 96);
  if (v4) {
    sub_10004D2C8(v4);
  }
  if (*(unsigned char *)(a1 + 80) && *(char *)(a1 + 79) < 0) {
    operator delete(*(void **)(a1 + 56));
  }
  if (*(char *)(a1 + 55) < 0) {
    operator delete(*(void **)(a1 + 32));
  }
  if (*(char *)(a1 + 31) < 0) {
    operator delete(*(void **)(a1 + 8));
  }

  return sub_1000558F4((const void **)a1);
}

void *sub_100B71590(void *a1)
{
  *a1 = off_101A3F400;
  sub_100B714E0((uint64_t)(a1 + 1));
  return a1;
}

void sub_100B715D4(void *a1)
{
  *a1 = off_101A3F400;
  sub_100B714E0((uint64_t)(a1 + 1));

  operator delete();
}

void *sub_100B71638(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t v2 = operator new(0xC8uLL);
  void *v2 = off_101A3F400;
  sub_100B71948((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_100B7168C(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100B716A0(uint64_t a1, void *a2)
{
  *a2 = off_101A3F400;
  return sub_100B71948((uint64_t)(a2 + 1), a1 + 8);
}

const void **sub_100B716CC(uint64_t a1)
{
  return sub_100B714E0(a1 + 8);
}

void sub_100B716D4(void *a1)
{
  sub_100B714E0((uint64_t)a1 + 8);

  operator delete(a1);
}

CFIndex sub_100B71710(CFIndex result, unsigned char *a2)
{
  if (!*a2)
  {
    CFIndex v2 = result;
    uint64_t v3 = (const void **)(result + 8);
    uint64_t result = *(void *)(result + 8);
    if (result ? sub_1000810B8 : 0)
    {
      uint64_t v5 = *(void *)(v2 + 192);
      uint64_t result = CFStringGetLength((CFStringRef)result);
      if (result >= 1)
      {
        uint64_t v6 = *(std::__shared_weak_count **)(v2 + 184);
        v17[0] = *(void *)(v2 + 176);
        v17[1] = (uint64_t)v6;
        if (v6) {
          atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        uint64_t v7 = *(std::__shared_weak_count **)(v2 + 120);
        v16[0] = *(void *)(v2 + 112);
        v16[1] = (uint64_t)v7;
        if (v7) {
          atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        sub_100083DA4(&v15, v3);
        int v8 = *(unsigned __int8 *)(v5 + 130);
        unsigned int v9 = *(NSObject **)(v5 + 24);
        long long v13 = v9;
        uint64_t v14 = 0;
        if (v9) {
          dispatch_retain(v9);
        }
        uint64_t v10 = *(void *)(v5 + 64);
        uint64_t v11 = *(std::__shared_weak_count **)(v5 + 72);
        v12[0] = v10;
        v12[1] = v11;
        if (v11) {
          atomic_fetch_add_explicit(&v11->__shared_weak_owners_, 1uLL, memory_order_relaxed);
        }
        sub_100B525AC(v17, v16, (long long *)(v2 + 16), &v15, &v14, 0, v8 != 0, &v13, (uint64_t)v12);
        if (v11) {
          std::__shared_weak_count::__release_weak(v11);
        }
        if (v9) {
          dispatch_release(v9);
        }
        sub_100057D78(&v14);
        sub_1000558F4(&v15);
        if (v7) {
          sub_10004D2C8(v7);
        }
        if (v6) {
          sub_10004D2C8(v6);
        }
        uint64_t result = *(void *)(v2 + 96);
        if (result) {
          return (*(uint64_t (**)(CFIndex, CFIndex, CFIndex, CFIndex, uint64_t, CFIndex))(*(void *)result
        }
                                                                                                 + 56))(result, v2 + 128, v2 + 152, v2 + 40, 6, v2 + 64);
      }
    }
  }
  return result;
}

void sub_100B718B0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, const void *a13, const void *a14)
{
  if (v17) {
    std::__shared_weak_count::__release_weak(v17);
  }
  if (v16) {
    dispatch_release(v16);
  }
  sub_100057D78(&a13);
  sub_1000558F4(&a14);
  if (v15) {
    sub_10004D2C8(v15);
  }
  if (v14) {
    sub_10004D2C8(v14);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100B718FC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100B7193C()
{
}

uint64_t sub_100B71948(uint64_t a1, uint64_t a2)
{
  unsigned int v4 = sub_100083DA4((const void **)a1, (const void **)a2);
  if (*(char *)(a2 + 31) < 0)
  {
    sub_10004FC84((unsigned char *)v4 + 8, *(void **)(a2 + 8), *(void *)(a2 + 16));
  }
  else
  {
    long long v5 = *(_OWORD *)(a2 + 8);
    v4[3] = *(const void **)(a2 + 24);
    *(_OWORD *)(v4 + 1) = v5;
  }
  if (*(char *)(a2 + 55) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 32), *(void **)(a2 + 32), *(void *)(a2 + 40));
  }
  else
  {
    long long v6 = *(_OWORD *)(a2 + 32);
    *(void *)(a1 + 48) = *(void *)(a2 + 48);
    *(_OWORD *)(a1 + 32) = v6;
  }
  sub_1000593FC(a1 + 56, (long long *)(a2 + 56));
  uint64_t v7 = *(void *)(a2 + 96);
  *(void *)(a1 + 88) = *(void *)(a2 + 88);
  *(void *)(a1 + 96) = v7;
  if (v7) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v7 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v8 = *(void *)(a2 + 112);
  *(void *)(a1 + 104) = *(void *)(a2 + 104);
  *(void *)(a1 + 112) = v8;
  if (v8) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v8 + 8), 1uLL, memory_order_relaxed);
  }
  if (*(char *)(a2 + 143) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 120), *(void **)(a2 + 120), *(void *)(a2 + 128));
  }
  else
  {
    long long v9 = *(_OWORD *)(a2 + 120);
    *(void *)(a1 + 136) = *(void *)(a2 + 136);
    *(_OWORD *)(a1 + 120) = v9;
  }
  uint64_t v10 = (unsigned char *)(a1 + 144);
  if (*(char *)(a2 + 167) < 0)
  {
    sub_10004FC84(v10, *(void **)(a2 + 144), *(void *)(a2 + 152));
  }
  else
  {
    long long v11 = *(_OWORD *)(a2 + 144);
    *(void *)(a1 + 160) = *(void *)(a2 + 160);
    *(_OWORD *)uint64_t v10 = v11;
  }
  uint64_t v12 = *(void *)(a2 + 176);
  *(void *)(a1 + 168) = *(void *)(a2 + 168);
  *(void *)(a1 + 176) = v12;
  if (v12) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v12 + 8), 1uLL, memory_order_relaxed);
  }
  *(void *)(a1 + 184) = *(void *)(a2 + 184);
  return a1;
}

void sub_100B71AA0(_Unwind_Exception *a1)
{
  if (*(char *)(v1 + 143) < 0) {
    operator delete(*v5);
  }
  uint64_t v7 = *(std::__shared_weak_count **)(v1 + 112);
  if (v7) {
    sub_10004D2C8(v7);
  }
  uint64_t v8 = *(std::__shared_weak_count **)(v1 + 96);
  if (v8) {
    sub_10004D2C8(v8);
  }
  if (*(unsigned char *)(v1 + 80) && *(char *)(v1 + 79) < 0) {
    operator delete(*v4);
  }
  if (*(char *)(v1 + 55) < 0) {
    operator delete(*v3);
  }
  if (*(char *)(v1 + 31) < 0) {
    operator delete(*v2);
  }
  sub_1000558F4((const void **)v1);
  _Unwind_Resume(a1);
}

void *sub_100B71B34(unsigned int a1, void *a2, void *a3, uint64_t a4, void *a5)
{
  uint64_t v5 = a1;
  switch(v5)
  {
    case 1:
      uint64_t result = 0;
      a3[1] = a2[1];
      *a3 = sub_100B71B34;
      break;
    case 2:
      uint64_t result = 0;
      a3[1] = a2[1];
      *a3 = sub_100B71B34;
      goto LABEL_5;
    case 3:
      if (a4) {
      else
      }
        BOOL v8 = a5 == &unk_1015497C0;
      if (v8) {
        uint64_t result = a2 + 1;
      }
      else {
        uint64_t result = 0;
      }
      break;
    case 4:
      return result;
    default:
      uint64_t result = 0;
LABEL_5:
      *a2 = 0;
      break;
  }
  return result;
}

uint64_t *sub_100B71C14(void ***a1)
{
  uint64_t v1 = *a1;
  unsigned int v4 = a1;
  uint64_t v5 = v1;
  CFIndex v2 = *v1;
  sub_100058DB0(v8, "TransferAuthResponseTime");
  v6[1] = COERCE_VOID_FASTCALLvoidvoidvoidvoidvoid_(CFAbsoluteTimeGetCurrent());
  v6[0] = (void (*)(void, void, void, void, void))sub_100B71B34;
  sub_100B4A9E0(v2, (uint64_t)(v1 + 3), (uint64_t)v8, v6);
  sub_100146540((uint64_t (**)(void, void, void, void, void))v6);
  if (v9 < 0) {
    operator delete(v8[0]);
  }
  sub_1000DFC90((uint64_t)v8, (uint64_t)(v1 + 6));
  sub_100B630A0(v6, (uint64_t)(v1 + 10));
  sub_100B5740C((uint64_t)v2, (uint64_t)(v1 + 3), (uint64_t)v8, (uint64_t)v6);
  if (v7) {
    sub_1008C2D48((uint64_t)v6);
  }
  sub_100060644(v8);
  sub_100B71D90((uint64_t *)&v5);
  return sub_100046B58((uint64_t *)&v4);
}

void sub_100B71D24(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
  if (LOBYTE(STACK[0x260])) {
    sub_1008C2D48((uint64_t)&a11);
  }
  sub_100060644((void *)(v11 - 72));
  sub_100B71D90(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_100B71D90(uint64_t *result)
{
  uint64_t v1 = *result;
  *uint64_t result = 0;
  if (v1)
  {
    if (*(unsigned char *)(v1 + 672)) {
      sub_1008C2D48(v1 + 80);
    }
    sub_100060644((void *)(v1 + 48));
    if (*(char *)(v1 + 47) < 0) {
      operator delete(*(void **)(v1 + 24));
    }
    CFIndex v2 = *(std::__shared_weak_count **)(v1 + 16);
    if (v2) {
      sub_10004D2C8(v2);
    }
    operator delete();
  }
  return result;
}

uint64_t sub_100B71E0C(uint64_t a1)
{
  *(void *)a1 = off_101A3F480;
  CFIndex v2 = *(std::__shared_weak_count **)(a1 + 96);
  if (v2) {
    sub_10004D2C8(v2);
  }
  sub_100060644((void *)(a1 + 40));
  if (*(char *)(a1 + 39) < 0) {
    operator delete(*(void **)(a1 + 16));
  }
  return a1;
}

void sub_100B71E70(uint64_t a1)
{
  *(void *)a1 = off_101A3F480;
  CFIndex v2 = *(std::__shared_weak_count **)(a1 + 96);
  if (v2) {
    sub_10004D2C8(v2);
  }
  sub_100060644((void *)(a1 + 40));
  if (*(char *)(a1 + 39) < 0) {
    operator delete(*(void **)(a1 + 16));
  }

  operator delete();
}

void *sub_100B71EF4(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  CFIndex v2 = operator new(0x68uLL);
  void *v2 = off_101A3F480;
  sub_100B72260((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_100B71F48(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100B71F5C(uint64_t a1, void *a2)
{
  *a2 = off_101A3F480;
  return sub_100B72260((uint64_t)(a2 + 1), a1 + 8);
}

void sub_100B71F88(uint64_t a1)
{
}

void sub_100B71F90(void *a1)
{
  sub_100B72310((uint64_t)a1 + 8);

  operator delete(a1);
}

uint64_t sub_100B71FCC(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  int v3 = *(_DWORD *)(a1 + 72);
  unsigned int v4 = *(NSObject **)(v2 + 40);
  BOOL v5 = os_log_type_enabled(v4, OS_LOG_TYPE_ERROR);
  if (v3 == 3)
  {
    if (v5)
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "TA request failed due to carrier error", buf, 2u);
    }
    if (*(unsigned char *)(v2 + 360))
    {
      *(void *)long long buf = v2 + 336;
      sub_100B6C578((uint64_t **)(v2 + 992), (void **)(v2 + 336), (long long **)buf)[83] = 1;
      *(void *)long long buf = v2 + 336;
      long long v6 = sub_100B6C578((uint64_t **)(v2 + 992), (void **)(v2 + 336), (long long **)buf);
      *((_DWORD *)v6 + 21) = 70010;
      v6[88] = 1;
    }
    unsigned __int8 v13 = 11;
    *(void *)long long buf = 0;
    char v12 = 52;
    uint64_t v11 = 0;
    int v9 = 70010;
    char v10 = 1;
    sub_100B3E598((void *)v2, (unsigned __int8 **)(a1 + 16), &v13, 0, (const void **)buf, &v12, &v11, 7u, 1, (uint64_t)&v9, (uint64_t *)(a1 + 80));
  }
  else
  {
    if (v5)
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "TA request failed due to internal error", buf, 2u);
    }
    if (*(unsigned char *)(v2 + 360))
    {
      *(void *)long long buf = v2 + 336;
      sub_100B6C578((uint64_t **)(v2 + 992), (void **)(v2 + 336), (long long **)buf)[83] = 1;
      *(void *)long long buf = v2 + 336;
      char v7 = sub_100B6C578((uint64_t **)(v2 + 992), (void **)(v2 + 336), (long long **)buf);
      *((_DWORD *)v7 + 21) = 70023;
      v7[88] = 1;
    }
    unsigned __int8 v13 = 11;
    *(void *)long long buf = 0;
    char v12 = 56;
    uint64_t v11 = 0;
    int v9 = 70023;
    char v10 = 1;
    sub_100B3E598((void *)v2, (unsigned __int8 **)(a1 + 16), &v13, 0, (const void **)buf, &v12, &v11, 0, 1, (uint64_t)&v9, (uint64_t *)(a1 + 80));
  }
  sub_100057D78(&v11);
  sub_1000558F4((const void **)buf);
  return sub_1000607A8(a1 + 40, 1);
}

void sub_100B721F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va1, a5);
  va_start(va, a5);
  long long v6 = va_arg(va1, const void *);
  uint64_t v8 = va_arg(va1, void);
  sub_100057D78((const void **)va);
  sub_1000558F4((const void **)va1);
  _Unwind_Resume(a1);
}

uint64_t sub_100B72214(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101A3F4E0)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_100B72254()
{
  return &off_101A3F4E0;
}

uint64_t sub_100B72260(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = *(void *)a2;
  if (*(char *)(a2 + 31) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 8), *(void **)(a2 + 8), *(void *)(a2 + 16));
  }
  else
  {
    long long v4 = *(_OWORD *)(a2 + 8);
    *(void *)(a1 + 24) = *(void *)(a2 + 24);
    *(_OWORD *)(a1 + 8) = v4;
  }
  sub_1000DFC90(a1 + 32, a2 + 32);
  *(_OWORD *)(a1 + 64) = *(_OWORD *)(a2 + 64);
  uint64_t v5 = *(void *)(a2 + 88);
  *(void *)(a1 + 80) = *(void *)(a2 + 80);
  *(void *)(a1 + 88) = v5;
  if (v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
  }
  return a1;
}

void sub_100B722F4(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 31) < 0) {
    operator delete(*v2);
  }
  _Unwind_Resume(exception_object);
}

void sub_100B72310(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 88);
  if (v2) {
    sub_10004D2C8(v2);
  }
  sub_100060644((void *)(a1 + 32));
  if (*(char *)(a1 + 31) < 0)
  {
    int v3 = *(void **)(a1 + 8);
    operator delete(v3);
  }
}

uint64_t sub_100B7236C(uint64_t a1)
{
  *(void *)a1 = off_101A3F500;
  sub_100060644((void *)(a1 + 56));
  if (*(char *)(a1 + 55) < 0) {
    operator delete(*(void **)(a1 + 32));
  }
  return a1;
}

void sub_100B723C0(uint64_t a1)
{
  *(void *)a1 = off_101A3F500;
  sub_100060644((void *)(a1 + 56));
  if (*(char *)(a1 + 55) < 0) {
    operator delete(*(void **)(a1 + 32));
  }

  operator delete();
}

void *sub_100B72434(uint64_t a1)
{
  uint64_t v1 = (long long *)(a1 + 8);
  uint64_t v2 = operator new(0x60uLL);
  void *v2 = off_101A3F500;
  sub_100B72838((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_100B72488(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100B7249C(uint64_t a1, void *a2)
{
  *a2 = off_101A3F500;
  return sub_100B72838((uint64_t)(a2 + 1), (long long *)(a1 + 8));
}

void sub_100B724C8(uint64_t a1)
{
}

void sub_100B724D0(void *a1)
{
  sub_100B728D8((uint64_t)a1 + 8);

  operator delete(a1);
}

const void **sub_100B7250C(uint64_t a1)
{
  int v2 = 70010;
  uint64_t v3 = *(void *)(a1 + 8);
  if (*(_DWORD *)(a1 + 16) == 3)
  {
    unsigned int v4 = *(_DWORD *)(a1 + 88) - 1;
    if (v4 <= 8) {
      int v2 = dword_10154B640[v4];
    }
    uint64_t v5 = *(NSObject **)(v3 + 40);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 136446210;
      *(void *)&uint8_t buf[4] = entitlements::asString();
      _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "TA webservice request [%{public}s] failed due to carrier error", buf, 0xCu);
    }
    if (*(unsigned char *)(v3 + 360))
    {
      if (!*(unsigned char *)(v3 + 1020))
      {
        *(_DWORD *)(v3 + 1016) = 5;
        *(unsigned char *)(v3 + 1020) = 1;
      }
      *(void *)long long buf = v3 + 336;
      long long v6 = sub_100B6C578((uint64_t **)(v3 + 992), (void **)(v3 + 336), (long long **)buf);
      *((_DWORD *)v6 + 21) = v2;
      v6[88] = 1;
    }
    unsigned __int8 v16 = 11;
    *(void *)long long buf = 0;
    char v15 = 52;
    uint64_t v14 = 0;
    int v12 = v2;
    char v13 = 1;
    sub_100B3E598((void *)v3, (unsigned __int8 **)(a1 + 32), &v16, 0, (const void **)buf, &v15, &v14, 7u, 1, (uint64_t)&v12, (uint64_t *)(a1 + 24));
  }
  else
  {
    char v7 = *(NSObject **)(v3 + 40);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 136446210;
      *(void *)&uint8_t buf[4] = entitlements::asString();
      _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "TA webservice request [%{public}s] failed due to internal error", buf, 0xCu);
    }
    unsigned int v8 = *(_DWORD *)(a1 + 88) - 1;
    if (v8 > 8) {
      int v9 = 70023;
    }
    else {
      int v9 = dword_10154B664[v8];
    }
    if (*(unsigned char *)(v3 + 360))
    {
      if (!*(unsigned char *)(v3 + 1020))
      {
        *(_DWORD *)(v3 + 1016) = 1;
        *(unsigned char *)(v3 + 1020) = 1;
      }
      *(void *)long long buf = v3 + 336;
      char v10 = sub_100B6C578((uint64_t **)(v3 + 992), (void **)(v3 + 336), (long long **)buf);
      *((_DWORD *)v10 + 21) = v9;
      v10[88] = 1;
    }
    unsigned __int8 v16 = 11;
    *(void *)long long buf = 0;
    char v15 = 56;
    uint64_t v14 = 0;
    int v12 = v9;
    char v13 = 1;
    sub_100B3E598((void *)v3, (unsigned __int8 **)(a1 + 32), &v16, 0, (const void **)buf, &v15, &v14, 0, 1, (uint64_t)&v12, (uint64_t *)(a1 + 24));
  }
  sub_100057D78(&v14);
  uint64_t result = sub_1000558F4((const void **)buf);
  if (*(void *)(a1 + 80)) {
    return (const void **)sub_1000607A8(a1 + 56, 1);
  }
  return result;
}

void sub_100B727C4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va1, a5);
  va_start(va, a5);
  long long v6 = va_arg(va1, const void *);
  uint64_t v8 = va_arg(va1, void);
  sub_100057D78((const void **)va);
  sub_1000558F4((const void **)va1);
  _Unwind_Resume(a1);
}

uint64_t sub_100B727EC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100B7282C()
{
}

uint64_t sub_100B72838(uint64_t a1, long long *a2)
{
  long long v4 = *a2;
  *(void *)(a1 + 16) = *((void *)a2 + 2);
  *(_OWORD *)a1 = v4;
  if (*((char *)a2 + 47) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 24), *((void **)a2 + 3), *((void *)a2 + 4));
  }
  else
  {
    long long v5 = *(long long *)((char *)a2 + 24);
    *(void *)(a1 + 40) = *((void *)a2 + 5);
    *(_OWORD *)(a1 + 24) = v5;
  }
  sub_1000DFC90(a1 + 48, (uint64_t)(a2 + 3));
  *(_DWORD *)(a1 + 80) = *((_DWORD *)a2 + 20);
  return a1;
}

void sub_100B728BC(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 47) < 0) {
    operator delete(*v2);
  }
  _Unwind_Resume(exception_object);
}

void sub_100B728D8(uint64_t a1)
{
  sub_100060644((void *)(a1 + 48));
  if (*(char *)(a1 + 47) < 0)
  {
    int v2 = *(void **)(a1 + 24);
    operator delete(v2);
  }
}

uint64_t sub_100B72928(uint64_t a1)
{
  *(void *)a1 = off_101A3F580;
  if (*(char *)(a1 + 679) < 0) {
    operator delete(*(void **)(a1 + 656));
  }
  sub_1008C2D48(a1 + 64);
  sub_100060644((void *)(a1 + 32));
  int v2 = *(std::__shared_weak_count **)(a1 + 24);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_100B72994(uint64_t a1)
{
  *(void *)a1 = off_101A3F580;
  if (*(char *)(a1 + 679) < 0) {
    operator delete(*(void **)(a1 + 656));
  }
  sub_1008C2D48(a1 + 64);
  sub_100060644((void *)(a1 + 32));
  int v2 = *(std::__shared_weak_count **)(a1 + 24);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete();
}

void *sub_100B72A20(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  int v2 = operator new(0x2B0uLL);
  void *v2 = off_101A3F580;
  sub_100B72EE8((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_100B72A74(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100B72A88(uint64_t a1, void *a2)
{
  *a2 = off_101A3F580;
  return sub_100B72EE8((uint64_t)(a2 + 1), a1 + 8);
}

void sub_100B72AB4(uint64_t a1)
{
}

void sub_100B72ABC(void *a1)
{
  sub_100B72FC8((uint64_t)a1 + 8);

  operator delete(a1);
}

uint64_t sub_100B72AF8(void *a1, uint64_t a2, int *a3)
{
  v14[0] = 0;
  char v15 = 0;
  if (*(unsigned char *)(a2 + 272))
  {
    sub_100B7302C((uint64_t)v14, a2);
    char v15 = 1;
  }
  uint64_t v5 = a1[1];
  long long v6 = (std::__shared_weak_count *)a1[3];
  if (v6)
  {
    int v7 = *a3;
    uint64_t v8 = std::__shared_weak_count::lock(v6);
    if (v8 && a1[2])
    {
      if (v15)
      {
        sub_100058DB0(__p, "TransferAuthWebServResponseTime");
        CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
        *(void *)long long buf = sub_100B71B34;
        sub_100B4A9E0((void *)v5, (uint64_t)(a1 + 82), (uint64_t)__p, (void (**)(void, void, void, void, void))buf);
        sub_100146540((uint64_t (**)(void, void, void, void, void))buf);
        if (v17 < 0) {
          operator delete(__p[0]);
        }
        sub_100778E10(__p, (uint64_t)v14);
        sub_100B5B630(v5, a1 + 82, (uint64_t)__p, (uint64_t)(a1 + 8));
        sub_100777C48((uint64_t)__p);
        sub_1000DFC90((uint64_t)&v23, (uint64_t)(a1 + 4));
        sub_100B63100((uint64_t)buf, (uint64_t)(a1 + 8));
        char v22 = 1;
        sub_100B5740C(v5, (uint64_t)(a1 + 82), (uint64_t)&v23, (uint64_t)buf);
        if (v22) {
          sub_1008C2D48((uint64_t)buf);
        }
        int v9 = (uint8_t *)&v23;
      }
      else
      {
        sub_1000DFC90((uint64_t)buf, (uint64_t)(a1 + 4));
        uint64_t v12 = (uint64_t)(a1 + 82);
        int v9 = buf;
        sub_100B56FFC(v5, v12, v7, 1, (uint64_t)buf);
      }
      sub_100060644(v9);
LABEL_23:
      sub_10004D2C8(v8);
      return sub_100777C48((uint64_t)v14);
    }
  }
  else
  {
    uint64_t v8 = 0;
  }
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)buf, kCtLoggingSystemName, "cp.tr.ctr");
  char v10 = *(NSObject **)&Current;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
  if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "invalid CellularPlanTransferFlowController (weak_ptr)", buf, 2u);
  }
  if (*(unsigned char *)(v5 + 360))
  {
    if (!*(unsigned char *)(v5 + 1020))
    {
      *(_DWORD *)(v5 + 1016) = 1;
      *(unsigned char *)(v5 + 1020) = 1;
    }
    *(void *)long long buf = v5 + 336;
    uint64_t v11 = sub_100B6C578((uint64_t **)(v5 + 992), (void **)(v5 + 336), (long long **)buf);
    *((_DWORD *)v11 + 21) = 70024;
    v11[88] = 1;
  }
  unsigned __int8 v19 = 11;
  *(void *)long long buf = 0;
  char v18 = 56;
  __p[0] = 0;
  int v23 = 70024;
  char v24 = 1;
  sub_100B3E598((void *)v5, (unsigned __int8 **)a1 + 82, &v19, 0, (const void **)buf, &v18, (const void **)__p, 0, 1, (uint64_t)&v23, a1 + 85);
  sub_100057D78((const void **)__p);
  sub_1000558F4((const void **)buf);
  sub_1000607A8((uint64_t)(a1 + 4), 1);
  if (v8) {
    goto LABEL_23;
  }
  return sub_100777C48((uint64_t)v14);
}

void sub_100B72DE4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  sub_100060644(&STACK[0x250]);
  sub_10004D2C8(v4);
  sub_100777C48((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100B72E9C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100B72EDC()
{
}

uint64_t sub_100B72EE8(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = *(_OWORD *)a2;
  uint64_t v4 = *(void *)(a2 + 16);
  *(void *)(a1 + 16) = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 16), 1uLL, memory_order_relaxed);
  }
  sub_1000DFC90(a1 + 24, a2 + 24);
  sub_100B63100(a1 + 56, a2 + 56);
  uint64_t v5 = (unsigned char *)(a1 + 648);
  if (*(char *)(a2 + 671) < 0)
  {
    sub_10004FC84(v5, *(void **)(a2 + 648), *(void *)(a2 + 656));
  }
  else
  {
    long long v6 = *(_OWORD *)(a2 + 648);
    *(void *)(a1 + 664) = *(void *)(a2 + 664);
    *(_OWORD *)uint64_t v5 = v6;
  }
  *(void *)(a1 + 672) = *(void *)(a2 + 672);
  return a1;
}

void sub_100B72F90(_Unwind_Exception *a1)
{
  sub_1008C2D48(v3);
  sub_100060644(v2);
  uint64_t v5 = *(std::__shared_weak_count **)(v1 + 16);
  if (v5) {
    std::__shared_weak_count::__release_weak(v5);
  }
  _Unwind_Resume(a1);
}

void sub_100B72FC8(uint64_t a1)
{
  if (*(char *)(a1 + 671) < 0) {
    operator delete(*(void **)(a1 + 648));
  }
  sub_1008C2D48(a1 + 56);
  sub_100060644((void *)(a1 + 24));
  int v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2)
  {
    std::__shared_weak_count::__release_weak(v2);
  }
}

__n128 sub_100B7302C(uint64_t a1, uint64_t a2)
{
  *(_WORD *)a1 = *(_WORD *)a2;
  *(unsigned char *)(a1 + 8) = 0;
  *(unsigned char *)(a1 + 32) = 0;
  if (*(unsigned char *)(a2 + 32))
  {
    __n128 result = *(__n128 *)(a2 + 8);
    *(void *)(a1 + 24) = *(void *)(a2 + 24);
    *(__n128 *)(a1 + 8) = result;
    *(void *)(a2 + 16) = 0;
    *(void *)(a2 + 24) = 0;
    *(void *)(a2 + 8) = 0;
    *(unsigned char *)(a1 + 32) = 1;
  }
  uint64_t v3 = *(void *)(a2 + 40);
  *(unsigned char *)(a1 + 48) = 0;
  *(void *)(a1 + 40) = v3;
  *(unsigned char *)(a1 + 72) = 0;
  if (*(unsigned char *)(a2 + 72))
  {
    __n128 result = *(__n128 *)(a2 + 48);
    *(void *)(a1 + 64) = *(void *)(a2 + 64);
    *(__n128 *)(a1 + 48) = result;
    *(void *)(a2 + 56) = 0;
    *(void *)(a2 + 64) = 0;
    *(void *)(a2 + 48) = 0;
    *(unsigned char *)(a1 + 72) = 1;
  }
  *(unsigned char *)(a1 + 80) = 0;
  *(unsigned char *)(a1 + 176) = 0;
  if (*(unsigned char *)(a2 + 176))
  {
    long long v4 = *(_OWORD *)(a2 + 80);
    *(void *)(a1 + 96) = *(void *)(a2 + 96);
    *(_OWORD *)(a1 + 80) = v4;
    *(void *)(a2 + 88) = 0;
    *(void *)(a2 + 96) = 0;
    *(void *)(a2 + 80) = 0;
    long long v5 = *(_OWORD *)(a2 + 104);
    *(void *)(a1 + 120) = *(void *)(a2 + 120);
    *(_OWORD *)(a1 + 104) = v5;
    *(void *)(a2 + 112) = 0;
    *(void *)(a2 + 120) = 0;
    *(void *)(a2 + 104) = 0;
    long long v6 = *(_OWORD *)(a2 + 128);
    *(void *)(a1 + 144) = *(void *)(a2 + 144);
    *(_OWORD *)(a1 + 128) = v6;
    *(void *)(a2 + 136) = 0;
    *(void *)(a2 + 144) = 0;
    *(void *)(a2 + 128) = 0;
    __n128 result = *(__n128 *)(a2 + 152);
    *(void *)(a1 + 168) = *(void *)(a2 + 168);
    *(__n128 *)(a1 + 152) = result;
    *(void *)(a2 + 152) = 0;
    *(void *)(a2 + 160) = 0;
    *(void *)(a2 + 168) = 0;
    *(unsigned char *)(a1 + 176) = 1;
  }
  *(unsigned char *)(a1 + 184) = 0;
  *(unsigned char *)(a1 + 264) = 0;
  if (*(unsigned char *)(a2 + 264))
  {
    long long v7 = *(_OWORD *)(a2 + 184);
    *(void *)(a1 + 200) = *(void *)(a2 + 200);
    *(_OWORD *)(a1 + 184) = v7;
    *(void *)(a2 + 192) = 0;
    *(void *)(a2 + 200) = 0;
    *(void *)(a2 + 184) = 0;
    long long v8 = *(_OWORD *)(a2 + 208);
    *(void *)(a1 + 224) = *(void *)(a2 + 224);
    *(_OWORD *)(a1 + 208) = v8;
    *(void *)(a2 + 216) = 0;
    *(void *)(a2 + 224) = 0;
    *(void *)(a2 + 208) = 0;
    __n128 result = *(__n128 *)(a2 + 232);
    *(void *)(a1 + 248) = *(void *)(a2 + 248);
    *(__n128 *)(a1 + 232) = result;
    *(void *)(a2 + 240) = 0;
    *(void *)(a2 + 248) = 0;
    *(void *)(a2 + 232) = 0;
    *(unsigned char *)(a1 + 256) = *(unsigned char *)(a2 + 256);
    *(unsigned char *)(a1 + 264) = 1;
  }
  return result;
}

_UNKNOWN **sub_100B73190(unsigned int a1, uint64_t a2, uint64_t a3, uint64_t a4, void *a5)
{
  uint64_t v5 = a1;
  switch(v5)
  {
    case 1:
      __n128 result = 0;
      *(unsigned char *)(a3 + 8) = *(unsigned char *)(a2 + 8);
      *(void *)a3 = sub_100B73190;
      break;
    case 2:
      __n128 result = 0;
      *(unsigned char *)(a3 + 8) = *(unsigned char *)(a2 + 8);
      *(void *)a3 = sub_100B73190;
      goto LABEL_5;
    case 3:
      if (a4) {
      else
      }
        BOOL v8 = a5 == &unk_101549E30;
      if (v8) {
        __n128 result = (_UNKNOWN **)(a2 + 8);
      }
      else {
        __n128 result = 0;
      }
      break;
    case 4:
      return result;
    default:
      __n128 result = 0;
LABEL_5:
      *(void *)a2 = 0;
      break;
  }
  return result;
}

uint64_t sub_100B73270(uint64_t a1)
{
  *(void *)a1 = off_101A3F620;
  sub_1000558F4((const void **)(a1 + 80));
  if (*(char *)(a1 + 71) < 0) {
    operator delete(*(void **)(a1 + 48));
  }
  sub_100060644((void *)(a1 + 16));
  return a1;
}

void sub_100B732CC(uint64_t a1)
{
  *(void *)a1 = off_101A3F620;
  sub_1000558F4((const void **)(a1 + 80));
  if (*(char *)(a1 + 71) < 0) {
    operator delete(*(void **)(a1 + 48));
  }
  sub_100060644((void *)(a1 + 16));

  operator delete();
}

void *sub_100B73348(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  int v2 = operator new(0x68uLL);
  void *v2 = off_101A3F620;
  sub_100B7350C((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_100B7339C(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100B733B0(uint64_t a1, void *a2)
{
  *a2 = off_101A3F620;
  return sub_100B7350C((uint64_t)(a2 + 1), a1 + 8);
}

void *sub_100B733DC(uint64_t a1)
{
  return sub_100B735B0(a1 + 8);
}

void sub_100B733E4(void *a1)
{
  sub_100B735B0((uint64_t)a1 + 8);

  operator delete(a1);
}

uint64_t sub_100B73420(uint64_t a1)
{
  int v2 = *(void **)(a1 + 8);
  unsigned __int8 v8 = 11;
  long long v7 = 0;
  unsigned __int8 v3 = *(unsigned char *)(a1 + 88);
  int v5 = *(_DWORD *)(a1 + 92);
  char v6 = 1;
  sub_100B3E598(v2, (unsigned __int8 **)(a1 + 48), &v8, 0, (const void **)(a1 + 80), (char *)(a1 + 72), &v7, v3, 1, (uint64_t)&v5, (uint64_t *)(a1 + 96));
  sub_100057D78(&v7);
  return sub_1000607A8(a1 + 16, 1);
}

void sub_100B734AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  sub_100057D78((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100B734C0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100B73500()
{
}

uint64_t sub_100B7350C(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = *(void *)a2;
  uint64_t v4 = a1 + 40;
  sub_1000DFC90(a1 + 8, a2 + 8);
  if (*(char *)(a2 + 63) < 0)
  {
    sub_10004FC84((unsigned char *)v4, *(void **)(a2 + 40), *(void *)(a2 + 48));
  }
  else
  {
    long long v5 = *(_OWORD *)(a2 + 40);
    *(void *)(v4 + 16) = *(void *)(a2 + 56);
    *(_OWORD *)uint64_t v4 = v5;
  }
  *(unsigned char *)(a1 + 64) = *(unsigned char *)(a2 + 64);
  sub_100083DA4((const void **)(a1 + 72), (const void **)(a2 + 72));
  *(_OWORD *)(a1 + 80) = *(_OWORD *)(a2 + 80);
  return a1;
}

void sub_100B7359C(_Unwind_Exception *a1)
{
  sub_100060644(v1);
  _Unwind_Resume(a1);
}

void *sub_100B735B0(uint64_t a1)
{
  sub_1000558F4((const void **)(a1 + 72));
  if (*(char *)(a1 + 63) < 0) {
    operator delete(*(void **)(a1 + 40));
  }

  return sub_100060644((void *)(a1 + 8));
}

uint64_t sub_100B735FC(uint64_t a1)
{
  *(void *)a1 = off_101A3F6A0;
  if (*(char *)(a1 + 55) < 0) {
    operator delete(*(void **)(a1 + 32));
  }
  int v2 = *(std::__shared_weak_count **)(a1 + 24);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_100B73658(uint64_t a1)
{
  *(void *)a1 = off_101A3F6A0;
  if (*(char *)(a1 + 55) < 0) {
    operator delete(*(void **)(a1 + 32));
  }
  int v2 = *(std::__shared_weak_count **)(a1 + 24);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete();
}

void *sub_100B736D4(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  int v2 = operator new(0x38uLL);
  void *v2 = off_101A3F6A0;
  sub_100B73BCC((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_100B73728(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100B7373C(uint64_t a1, void *a2)
{
  *a2 = off_101A3F6A0;
  return sub_100B73BCC((uint64_t)(a2 + 1), a1 + 8);
}

void sub_100B73768(uint64_t a1)
{
}

void sub_100B73770(void *a1)
{
  sub_10010FC80((uint64_t)a1 + 8);

  operator delete(a1);
}

const void **sub_100B737AC(uint64_t a1, const void **a2, char *a3)
{
  uint64_t v14 = *a2;
  *a2 = 0;
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 24);
  if (v4)
  {
    char v5 = *a3;
    uint64_t v6 = *(void *)(a1 + 8);
    long long v7 = std::__shared_weak_count::lock(v4);
    if (v7 && *(void *)(a1 + 16))
    {
      *(void *)&uint8_t buf[8] = 0;
      char v17 = 0;
      ctu::cf::assign();
      v15[0] = 0;
      *(_DWORD *)((char *)v15 + 3) = 0;
      *(void *)long long buf = v6;
      unsigned __int8 v8 = *(std::__shared_weak_count **)(v6 + 16);
      if (v8)
      {
        uint64_t v9 = *(void *)(v6 + 8);
        char v10 = std::__shared_weak_count::lock(v8);
        if (v10)
        {
          *(void *)&uint8_t buf[8] = v9;
          char v17 = v10;
          atomic_fetch_add_explicit(&v10->__shared_weak_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v10);
          if (*(char *)(a1 + 55) < 0)
          {
            sub_10004FC84(v18, *(void **)(a1 + 32), *(void *)(a1 + 40));
          }
          else
          {
            *(_OWORD *)char v18 = *(_OWORD *)(a1 + 32);
            void v18[2] = *(void **)(a1 + 48);
          }
          v18[3] = 0;
          void v18[4] = 0;
          *(_DWORD *)unsigned __int8 v19 = v15[0];
          *(_DWORD *)&v19[3] = *(_DWORD *)((char *)v15 + 3);
          char v20 = 0;
          char v21 = v5;
          uint64_t v12 = *(std::__shared_weak_count **)(v6 + 16);
          if (v12)
          {
            if (std::__shared_weak_count::lock(v12)) {
              operator new();
            }
          }
          sub_100088B9C();
        }
      }
      sub_100088B9C();
    }
  }
  else
  {
    long long v7 = 0;
  }
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)buf, kCtLoggingSystemName, "cp.tr.ctr");
  uint64_t v11 = *(NSObject **)&buf[8];
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
  if (!os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
  {
    if (!v7) {
      return sub_1000558F4(&v14);
    }
    goto LABEL_17;
  }
  *(_WORD *)long long buf = 0;
  _os_log_error_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "invalid CellularPlanTransferFlowController (weak_ptr)", buf, 2u);
  if (v7) {
LABEL_17:
  }
    sub_10004D2C8(v7);
  return sub_1000558F4(&v14);
}

void sub_100B73AD0(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, std::__shared_weak_count *a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19)
{
  if (*(char *)(v19 + 47) < 0) {
    operator delete(*v20);
  }
  char v22 = *(std::__shared_weak_count **)(v19 + 16);
  if (v22) {
    std::__shared_weak_count::__release_weak(v22);
  }
  sub_10006A6AC(a1);
}

void sub_100B73B60()
{
  if (v0) {
    JUMPOUT(0x100B73B68);
  }
  JUMPOUT(0x100B73B70);
}

uint64_t sub_100B73B80(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100B73BC0()
{
}

uint64_t sub_100B73BCC(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = *(_OWORD *)a2;
  uint64_t v3 = *(void *)(a2 + 16);
  *(void *)(a1 + 16) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  uint64_t v4 = (unsigned char *)(a1 + 24);
  if (*(char *)(a2 + 47) < 0)
  {
    sub_10004FC84(v4, *(void **)(a2 + 24), *(void *)(a2 + 32));
  }
  else
  {
    long long v5 = *(_OWORD *)(a2 + 24);
    *(void *)(a1 + 40) = *(void *)(a2 + 40);
    *(_OWORD *)uint64_t v4 = v5;
  }
  return a1;
}

void sub_100B73C40(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(std::__shared_weak_count **)(v1 + 16);
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100B73C58(uint64_t a1)
{
  *(void *)a1 = off_101A3F730;
  if (*(char *)(a1 + 95) < 0) {
    operator delete(*(void **)(a1 + 72));
  }
  if (*(char *)(a1 + 71) < 0) {
    operator delete(*(void **)(a1 + 48));
  }
  int v2 = *(std::__shared_weak_count **)(a1 + 40);
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 24);
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  return a1;
}

void sub_100B73CD0(uint64_t a1)
{
  *(void *)a1 = off_101A3F730;
  if (*(char *)(a1 + 95) < 0) {
    operator delete(*(void **)(a1 + 72));
  }
  if (*(char *)(a1 + 71) < 0) {
    operator delete(*(void **)(a1 + 48));
  }
  int v2 = *(std::__shared_weak_count **)(a1 + 40);
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 24);
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }

  operator delete();
}

void *sub_100B73D68(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  int v2 = operator new(0x60uLL);
  void *v2 = off_101A3F730;
  sub_100B73F9C((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_100B73DBC(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100B73DD0(uint64_t a1, void *a2)
{
  *a2 = off_101A3F730;
  return sub_100B73F9C((uint64_t)(a2 + 1), a1 + 8);
}

void sub_100B73DFC(uint64_t a1)
{
}

void sub_100B73E04(void *a1)
{
  sub_100B7409C((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_100B73E40(void *a1, unsigned __int8 *a2)
{
  uint64_t v3 = (std::__shared_weak_count *)a1[3];
  if (v3)
  {
    int v4 = *a2;
    uint64_t v5 = a1[1];
    uint64_t v6 = std::__shared_weak_count::lock(v3);
    if (v6)
    {
      long long v7 = v6;
      if (a1[2])
      {
        unsigned __int8 v8 = *(NSObject **)(v5 + 40);
        if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v11 = (void *)a1[6];
          char v10 = a1 + 6;
          uint64_t v9 = v11;
          uint64_t v12 = "true";
          if (*((char *)v10 + 23) >= 0) {
            uint64_t v9 = v10;
          }
          if (!v4) {
            uint64_t v12 = "false";
          }
          int v13 = 136315394;
          uint64_t v14 = v9;
          __int16 v15 = 2080;
          unsigned __int8 v16 = v12;
          _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I subscribe for push. iccid: [%s]. success ? %s", (uint8_t *)&v13, 0x16u);
        }
        *(unsigned char *)(v5 + 142) = v4;
      }
      sub_10004D2C8(v7);
    }
  }
}

uint64_t sub_100B73F50(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100B73F90()
{
}

uint64_t sub_100B73F9C(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = *(_OWORD *)a2;
  uint64_t v4 = *(void *)(a2 + 16);
  *(void *)(a1 + 16) = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 16), 1uLL, memory_order_relaxed);
  }
  uint64_t v5 = *(void *)(a2 + 32);
  *(void *)(a1 + 24) = *(void *)(a2 + 24);
  *(void *)(a1 + 32) = v5;
  if (v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
  }
  if (*(char *)(a2 + 63) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 40), *(void **)(a2 + 40), *(void *)(a2 + 48));
  }
  else
  {
    long long v6 = *(_OWORD *)(a2 + 40);
    *(void *)(a1 + 56) = *(void *)(a2 + 56);
    *(_OWORD *)(a1 + 40) = v6;
  }
  long long v7 = (unsigned char *)(a1 + 64);
  if (*(char *)(a2 + 87) < 0)
  {
    sub_10004FC84(v7, *(void **)(a2 + 64), *(void *)(a2 + 72));
  }
  else
  {
    long long v8 = *(_OWORD *)(a2 + 64);
    *(void *)(a1 + 80) = *(void *)(a2 + 80);
    *(_OWORD *)long long v7 = v8;
  }
  return a1;
}

void sub_100B74060(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 63) < 0) {
    operator delete(*v2);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(v1 + 32);
  if (v4) {
    sub_10004D2C8(v4);
  }
  uint64_t v5 = *(std::__shared_weak_count **)(v1 + 16);
  if (v5) {
    std::__shared_weak_count::__release_weak(v5);
  }
  _Unwind_Resume(exception_object);
}

void sub_100B7409C(uint64_t a1)
{
  if (*(char *)(a1 + 87) < 0) {
    operator delete(*(void **)(a1 + 64));
  }
  if (*(char *)(a1 + 63) < 0) {
    operator delete(*(void **)(a1 + 40));
  }
  int v2 = *(std::__shared_weak_count **)(a1 + 32);
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (v3)
  {
    std::__shared_weak_count::__release_weak(v3);
  }
}

uint64_t sub_100B7410C(uint64_t a1)
{
  *(void *)a1 = off_101A3F7B0;
  if (*(char *)(a1 + 55) < 0) {
    operator delete(*(void **)(a1 + 32));
  }
  int v2 = *(std::__shared_weak_count **)(a1 + 24);
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

void sub_100B74168(uint64_t a1)
{
  *(void *)a1 = off_101A3F7B0;
  if (*(char *)(a1 + 55) < 0) {
    operator delete(*(void **)(a1 + 32));
  }
  int v2 = *(std::__shared_weak_count **)(a1 + 24);
  if (v2) {
    sub_10004D2C8(v2);
  }

  operator delete();
}

void *sub_100B741E4(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  int v2 = operator new(0x40uLL);
  void *v2 = off_101A3F7B0;
  sub_100B745F4((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_100B74238(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100B7424C(uint64_t a1, void *a2)
{
  *a2 = off_101A3F7B0;
  return sub_100B745F4((uint64_t)(a2 + 1), a1 + 8);
}

void sub_100B74278(uint64_t a1)
{
}

void sub_100B74280(void *a1)
{
  sub_100B74688((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_100B742BC(uint64_t a1, unsigned char *a2)
{
  int v2 = *(void **)(a1 + 8);
  if (*a2)
  {
    sub_100B3F32C(*(void *)(a1 + 8));
    sub_100B3F548((uint64_t)v2);
  }
  else
  {
    uint64_t v4 = v2[5];
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      long long v7 = *(int **)(a1 + 16);
      if (v7) {
        long long v8 = "";
      }
      else {
        long long v8 = "No Response.";
      }
      unsigned int v9 = *(_DWORD *)(a1 + 56) - 1;
      if (v9 > 2) {
        char v10 = "RequestCanceled";
      }
      else {
        char v10 = off_101A3FE78[v9];
      }
      if (v7) {
        uint64_t v11 = sub_100FB56F4(*v7);
      }
      else {
        uint64_t v11 = "";
      }
      *(_DWORD *)long long buf = 136315650;
      *(void *)&uint8_t buf[4] = v8;
      __int16 v18 = 2080;
      uint64_t v19 = v10;
      __int16 v20 = 2080;
      char v21 = v11;
      _os_log_error_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "TSS request failed. %s EventCause: [%s], response status: [%s]", buf, 0x20u);
      uint64_t v4 = v2[5];
    }
    int v5 = *(_DWORD *)(a1 + 56);
    BOOL v6 = os_log_type_enabled(v4, OS_LOG_TYPE_ERROR);
    if (v5 == 3)
    {
      if (v6)
      {
        *(_WORD *)long long buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "TSS request failed due to carrier error", buf, 2u);
      }
      unsigned __int8 v16 = 11;
      *(void *)long long buf = 0;
      char v15 = 52;
      uint64_t v14 = 0;
      int v12 = 70011;
      char v13 = 1;
      sub_100B3E598(v2, (unsigned __int8 **)(a1 + 32), &v16, 0, (const void **)buf, &v15, &v14, 7u, 1, (uint64_t)&v12, v2 + 41);
    }
    else
    {
      if (v6)
      {
        *(_WORD *)long long buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "TSS request failed due to internal error", buf, 2u);
      }
      unsigned __int8 v16 = 11;
      *(void *)long long buf = 0;
      char v15 = 56;
      uint64_t v14 = 0;
      int v12 = 70025;
      char v13 = 1;
      sub_100B3E598(v2, (unsigned __int8 **)(a1 + 32), &v16, 0, (const void **)buf, &v15, &v14, 0, 1, (uint64_t)&v12, v2 + 41);
    }
    sub_100057D78(&v14);
    sub_1000558F4((const void **)buf);
  }
}

void sub_100B74588(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va1, a5);
  va_start(va, a5);
  BOOL v6 = va_arg(va1, const void *);
  uint64_t v8 = va_arg(va1, void);
  sub_100057D78((const void **)va);
  sub_1000558F4((const void **)va1);
  _Unwind_Resume(a1);
}

uint64_t sub_100B745A8(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_101A3F810)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_100B745E8()
{
  return &off_101A3F810;
}

uint64_t sub_100B745F4(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = *(_OWORD *)a2;
  uint64_t v4 = *(void *)(a2 + 16);
  *(void *)(a1 + 16) = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  int v5 = (unsigned char *)(a1 + 24);
  if (*(char *)(a2 + 47) < 0)
  {
    sub_10004FC84(v5, *(void **)(a2 + 24), *(void *)(a2 + 32));
  }
  else
  {
    long long v6 = *(_OWORD *)(a2 + 24);
    *(void *)(a1 + 40) = *(void *)(a2 + 40);
    *(_OWORD *)int v5 = v6;
  }
  *(_DWORD *)(a1 + 48) = *(_DWORD *)(a2 + 48);
  return a1;
}

void sub_100B74670(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(std::__shared_weak_count **)(v1 + 16);
  if (v3) {
    sub_10004D2C8(v3);
  }
  _Unwind_Resume(exception_object);
}

void sub_100B74688(uint64_t a1)
{
  if (*(char *)(a1 + 47) < 0) {
    operator delete(*(void **)(a1 + 24));
  }
  int v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2)
  {
    sub_10004D2C8(v2);
  }
}

uint64_t sub_100B746DC(uint64_t a1)
{
  *(void *)a1 = off_101A3F830;
  sub_10005717C((const void **)(a1 + 64));
  sub_1000558F4((const void **)(a1 + 48));
  if (*(char *)(a1 + 39) < 0) {
    operator delete(*(void **)(a1 + 16));
  }
  return a1;
}

void sub_100B74738(uint64_t a1)
{
  *(void *)a1 = off_101A3F830;
  sub_10005717C((const void **)(a1 + 64));
  sub_1000558F4((const void **)(a1 + 48));
  if (*(char *)(a1 + 39) < 0) {
    operator delete(*(void **)(a1 + 16));
  }

  operator delete();
}

void *sub_100B747B4(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  int v2 = operator new(0x50uLL);
  void *v2 = off_101A3F830;
  sub_100B749C4((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_100B74808(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100B7481C(uint64_t a1, void *a2)
{
  *a2 = off_101A3F830;
  return sub_100B749C4((uint64_t)(a2 + 1), a1 + 8);
}

void sub_100B74848(uint64_t a1)
{
}

void sub_100B74850(void *a1)
{
  sub_100B74A4C((uint64_t)a1 + 8);

  operator delete(a1);
}

const void **sub_100B7488C(uint64_t a1)
{
  int v2 = *(void **)(a1 + 8);
  unsigned __int8 v14 = 11;
  int v3 = *(unsigned __int8 *)(a1 + 40);
  sub_10004EFE4(&v13, (CFTypeRef *)(a1 + 64));
  int v4 = *(unsigned __int8 *)(a1 + 56);
  int v5 = 70042;
  int v6 = 70044;
  if (v4 != 55) {
    int v6 = 70040;
  }
  if (v4 != 54) {
    int v5 = v6;
  }
  int v7 = 70043;
  if (v4 == 53) {
    int v8 = 70041;
  }
  else {
    int v8 = 70040;
  }
  if (v4 != 37) {
    int v7 = v8;
  }
  if (*(unsigned __int8 *)(a1 + 56) <= 0x35u) {
    int v9 = v7;
  }
  else {
    int v9 = v5;
  }
  int v11 = v9;
  char v12 = 1;
  sub_100B3E598(v2, (unsigned __int8 **)(a1 + 16), &v14, v3 != 0, (const void **)(a1 + 48), (char *)(a1 + 56), &v13, 7u, 1, (uint64_t)&v11, (uint64_t *)(a1 + 72));
  return sub_100057D78(&v13);
}

void sub_100B74964(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  sub_100057D78((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100B74978(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100B749B8()
{
}

uint64_t sub_100B749C4(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = *(void *)a2;
  uint64_t v4 = a1 + 8;
  if (*(char *)(a2 + 31) < 0)
  {
    sub_10004FC84((unsigned char *)v4, *(void **)(a2 + 8), *(void *)(a2 + 16));
  }
  else
  {
    long long v5 = *(_OWORD *)(a2 + 8);
    *(void *)(v4 + 16) = *(void *)(a2 + 24);
    *(_OWORD *)uint64_t v4 = v5;
  }
  *(unsigned char *)(a1 + 32) = *(unsigned char *)(a2 + 32);
  sub_100083DA4((const void **)(a1 + 40), (const void **)(a2 + 40));
  *(unsigned char *)(a1 + 48) = *(unsigned char *)(a2 + 48);
  sub_100057240((const void **)(a1 + 56), (const void **)(a2 + 56));
  *(void *)(a1 + 64) = *(void *)(a2 + 64);
  return a1;
}

void sub_100B74A4C(uint64_t a1)
{
  sub_10005717C((const void **)(a1 + 56));
  sub_1000558F4((const void **)(a1 + 40));
  if (*(char *)(a1 + 31) < 0)
  {
    int v2 = *(void **)(a1 + 8);
    operator delete(v2);
  }
}

void sub_100B74AA4(uint64_t **a1)
{
  uint64_t v1 = **a1;
  int v2 = *(std::__shared_weak_count **)(v1 + 72);
  if (v2)
  {
    int v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      uint64_t v4 = v3;
      uint64_t v5 = *(void *)(v1 + 64);
      if (v5) {
        (*(void (**)(uint64_t, uint64_t))(*(void *)v5 + 112))(v5, v1 + 984);
      }
      sub_10004D2C8(v4);
    }
  }
  operator delete();
}

void sub_100B74B48()
{
  sub_10004D2C8(v0);
  operator delete();
}

void *sub_100B74B7C(void *a1)
{
  *a1 = off_101A3F8B0;
  int v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_100B74BC8(void *a1)
{
  *a1 = off_101A3F8B0;
  uint64_t v1 = (std::__shared_weak_count *)a1[3];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

char *sub_100B74C34(uint64_t a1)
{
  __n128 result = (char *)operator new(0x28uLL);
  *(void *)__n128 result = off_101A3F8B0;
  *(_OWORD *)(result + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 24);
  *((void *)result + 3) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  *((void *)result + 4) = *(void *)(a1 + 32);
  return result;
}

uint64_t sub_100B74CA0(uint64_t result, uint64_t a2)
{
  *(void *)a2 = off_101A3F8B0;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(result + 8);
  uint64_t v2 = *(void *)(result + 24);
  *(void *)(a2 + 24) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  *(void *)(a2 + 32) = *(void *)(result + 32);
  return result;
}

void sub_100B74CE8(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 24);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_100B74CF8(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete(__p);
}

void sub_100B74D38(void *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2)
  {
    uint64_t v3 = a1[1];
    uint64_t v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      uint64_t v5 = v4;
      if (a1[2])
      {
        int v6 = *(NSObject **)(v3 + 40);
        if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)int v8 = 0;
          _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Preflight recieved response for TA", v8, 2u);
        }
        uint64_t v7 = a1[4];
        sub_100B47BD0(v7);
        sub_100B47C9C(v7);
      }
      sub_10004D2C8(v5);
    }
  }
}

void sub_100B74DE0(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100B74DF4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100B74E34()
{
}

void *sub_100B74E40(void *a1)
{
  *a1 = off_101A3F930;
  sub_100777F50(a1 + 4);
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_100B74E90(void *a1)
{
  *a1 = off_101A3F930;
  sub_100777F50(a1 + 4);
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete();
}

void *sub_100B74F00(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t v2 = operator new(0x40uLL);
  void *v2 = off_101A3F930;
  sub_100B75218((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_100B74F54(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100B74F68(uint64_t a1, void *a2)
{
  *a2 = off_101A3F930;
  return sub_100B75218((uint64_t)(a2 + 1), a1 + 8);
}

void sub_100B74F94(uint64_t a1)
{
}

void sub_100B74F9C(void *a1)
{
  sub_100B75280((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_100B74FD8(void *a1, uint64_t a2, int *a3)
{
  uint64_t v4 = (std::__shared_weak_count *)a1[3];
  if (v4)
  {
    int v6 = *a3;
    uint64_t v7 = a1[1];
    int v8 = std::__shared_weak_count::lock(v4);
    if (v8)
    {
      if (a1[2])
      {
        sub_100778E10(v10, a2);
        sub_100777EB8((uint64_t)v11, (uint64_t)(a1 + 4));
        char v11[8] = v6;
        int v9 = *(std::__shared_weak_count **)(v7 + 16);
        if (v9)
        {
          if (std::__shared_weak_count::lock(v9)) {
            operator new();
          }
        }
        sub_100088B9C();
      }
      sub_10004D2C8(v8);
    }
  }
}

void sub_100B75190(_Unwind_Exception *exception_object, int a2)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

uint64_t sub_100B751CC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100B7520C()
{
}

uint64_t sub_100B75218(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = *(_OWORD *)a2;
  uint64_t v3 = *(void *)(a2 + 16);
  *(void *)(a1 + 16) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  sub_100777EB8(a1 + 24, a2 + 24);
  return a1;
}

void sub_100B75268(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(std::__shared_weak_count **)(v1 + 16);
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  _Unwind_Resume(exception_object);
}

void sub_100B75280(uint64_t a1)
{
  sub_100777F50((void *)(a1 + 24));
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2)
  {
    std::__shared_weak_count::__release_weak(v2);
  }
}

uint64_t *sub_100B752CC(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v3 = a1;
  uint64_t v4 = v1;
  sub_100B55694(*(void *)v1, 0);
  sub_100778E10(v5, v1 + 8);
  sub_100776E68(v1 + 288, (uint64_t)v5, *(_DWORD *)(v1 + 320));
  sub_100777C48((uint64_t)v5);
  sub_100B75364(&v4);
  return sub_100046B58((uint64_t *)&v3);
}

void sub_100B75338(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, void);
  va_copy(va2, va1);
  uint64_t v5 = va_arg(va2, void);
  sub_100777C48((uint64_t)va2);
  sub_100B75364((uint64_t *)va1);
  sub_100046B58((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t *sub_100B75364(uint64_t *result)
{
  uint64_t v1 = *result;
  *__n128 result = 0;
  if (v1)
  {
    sub_100777F50((void *)(v1 + 288));
    sub_100777C48(v1 + 8);
    operator delete();
  }
  return result;
}

uint64_t sub_100B753BC(uint64_t a1)
{
  *(void *)a1 = off_101A3F9B0;
  if (*(char *)(a1 + 55) < 0) {
    operator delete(*(void **)(a1 + 32));
  }
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 24);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_100B75418(uint64_t a1)
{
  *(void *)a1 = off_101A3F9B0;
  if (*(char *)(a1 + 55) < 0) {
    operator delete(*(void **)(a1 + 32));
  }
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 24);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete();
}

void *sub_100B75494(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t v2 = operator new(0x38uLL);
  void *v2 = off_101A3F9B0;
  sub_100B7580C((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_100B754E8(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100B754FC(uint64_t a1, void *a2)
{
  *a2 = off_101A3F9B0;
  return sub_100B7580C((uint64_t)(a2 + 1), a1 + 8);
}

void sub_100B75528(uint64_t a1)
{
}

void sub_100B75530(void *a1)
{
  sub_10010FC80((uint64_t)a1 + 8);

  operator delete(a1);
}

uint64_t sub_100B7556C(uint64_t a1, uint64_t a2, int *a3)
{
  v11[0] = 0;
  char v12 = 0;
  if (*(unsigned char *)(a2 + 160))
  {
    sub_1003113F8((uint64_t)v11, a2);
    char v12 = 1;
  }
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 24);
  if (v5)
  {
    int v6 = *a3;
    uint64_t v7 = *(void *)(a1 + 8);
    int v8 = std::__shared_weak_count::lock(v5);
    if (v8)
    {
      if (*(void *)(a1 + 16))
      {
        uint64_t v13 = v7;
        sub_10030E6AC(v14, (uint64_t)v11);
        if (*(char *)(a1 + 55) < 0)
        {
          sub_10004FC84(__p, *(void **)(a1 + 32), *(void *)(a1 + 40));
        }
        else
        {
          *(_OWORD *)std::string __p = *(_OWORD *)(a1 + 32);
          __p[2] = *(void **)(a1 + 48);
        }
        int v16 = v6;
        int v9 = *(std::__shared_weak_count **)(v7 + 16);
        if (v9)
        {
          if (std::__shared_weak_count::lock(v9)) {
            operator new();
          }
        }
        sub_100088B9C();
      }
      sub_10004D2C8(v8);
    }
  }
  return sub_10030D32C((uint64_t)v11);
}

void sub_100B75774(void *a1)
{
  sub_10030D32C(v1);
  sub_10006A6AC(a1);
}

uint64_t sub_100B757C0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100B75800()
{
}

uint64_t sub_100B7580C(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = *(_OWORD *)a2;
  uint64_t v3 = *(void *)(a2 + 16);
  *(void *)(a1 + 16) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  uint64_t v4 = (unsigned char *)(a1 + 24);
  if (*(char *)(a2 + 47) < 0)
  {
    sub_10004FC84(v4, *(void **)(a2 + 24), *(void *)(a2 + 32));
  }
  else
  {
    long long v5 = *(_OWORD *)(a2 + 24);
    *(void *)(a1 + 40) = *(void *)(a2 + 40);
    *(_OWORD *)uint64_t v4 = v5;
  }
  return a1;
}

void sub_100B75880(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(std::__shared_weak_count **)(v1 + 16);
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t *sub_100B75898(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v4 = a1;
  uint64_t v5 = v1;
  uint64_t v2 = *(void *)v1;
  sub_100B55694(*(void *)v1, 0);
  sub_10030E6AC(v6, v1 + 8);
  sub_100B5B9BC(v2, v1 + 176, (uint64_t)v6, *(_DWORD *)(v1 + 200));
  sub_10030D32C((uint64_t)v6);
  sub_100B75938(&v5);
  return sub_100046B58((uint64_t *)&v4);
}

void sub_100B7590C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, void);
  va_copy(va2, va1);
  uint64_t v5 = va_arg(va2, void);
  sub_10030D32C((uint64_t)va2);
  sub_100B75938((uint64_t *)va1);
  sub_100046B58((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t *sub_100B75938(uint64_t *result)
{
  uint64_t v1 = *result;
  *__n128 result = 0;
  if (v1)
  {
    if (*(char *)(v1 + 199) < 0) {
      operator delete(*(void **)(v1 + 176));
    }
    sub_10030D32C(v1 + 8);
    operator delete();
  }
  return result;
}

uint64_t sub_100B75998(uint64_t a1)
{
  *(void *)a1 = off_101A3FA40;
  if (*(char *)(a1 + 207) < 0) {
    operator delete(*(void **)(a1 + 184));
  }
  sub_10030D32C(a1 + 16);
  return a1;
}

void sub_100B759F0(uint64_t a1)
{
  *(void *)a1 = off_101A3FA40;
  if (*(char *)(a1 + 207) < 0) {
    operator delete(*(void **)(a1 + 184));
  }
  sub_10030D32C(a1 + 16);

  operator delete();
}

void *sub_100B75A68(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t v2 = operator new(0xE0uLL);
  void *v2 = off_101A3FA40;
  sub_100B760D4((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_100B75ABC(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100B75AD0(uint64_t a1, void *a2)
{
  *a2 = off_101A3FA40;
  return sub_100B760D4((uint64_t)(a2 + 1), a1 + 8);
}

uint64_t sub_100B75AFC(uint64_t a1)
{
  return sub_100B76164(a1 + 8);
}

void sub_100B75B04(void *a1)
{
  sub_100B76164((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_100B75B40(uint64_t a1, unsigned char *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (!*a2)
  {
    if (!*(unsigned char *)(a1 + 176))
    {
      char v10 = *(NSObject **)(v2 + 40);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
      {
        unsigned int v17 = *(_DWORD *)(a1 + 208) - 1;
        if (v17 > 2) {
          __int16 v18 = "RequestCanceled";
        }
        else {
          __int16 v18 = off_101A3FE78[v17];
        }
        *(_DWORD *)std::string __p = 136315650;
        *(void *)&__p[4] = "No Response.";
        __int16 v27 = 2080;
        long long v28 = v18;
        __int16 v29 = 1024;
        int v30 = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "TSS webservice request failed. %s EventCause: [%s], response success: [%d]", __p, 0x1Cu);
        char v10 = *(NSObject **)(v2 + 40);
      }
      int v11 = *(_DWORD *)(a1 + 208);
      BOOL v12 = os_log_type_enabled(v10, OS_LOG_TYPE_ERROR);
      if (v11 == 3)
      {
        if (v12)
        {
          *(_WORD *)std::string __p = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "TSS webservice request failed due to carrier error", __p, 2u);
        }
        unsigned __int8 v25 = 11;
        *(void *)std::string __p = 0;
        unsigned __int8 v24 = 52;
        CFStringRef v23 = 0;
        int v21 = 70012;
        char v22 = 1;
        sub_100B3E598((void *)v2, (unsigned __int8 **)(a1 + 184), &v25, 0, (const void **)__p, (char *)&v24, (const void **)&v23, 7u, 1, (uint64_t)&v21, (uint64_t *)(a1 + 216));
      }
      else
      {
        if (v12)
        {
          *(_WORD *)std::string __p = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "TSS webservice request failed due to internal error", __p, 2u);
        }
        unsigned __int8 v25 = 11;
        *(void *)std::string __p = 0;
        unsigned __int8 v24 = 56;
        CFStringRef v23 = 0;
        int v21 = 70060;
        char v22 = 1;
        sub_100B3E598((void *)v2, (unsigned __int8 **)(a1 + 184), &v25, 0, (const void **)__p, (char *)&v24, (const void **)&v23, 0, 1, (uint64_t)&v21, (uint64_t *)(a1 + 216));
      }
      sub_100057D78((const void **)&v23);
      uint64_t v13 = (const void **)__p;
      goto LABEL_42;
    }
    if (entitlements::TransferSIMViaWebServiceResponse::success((entitlements::TransferSIMViaWebServiceResponse *)(a1 + 16))) {
      return;
    }
    uint64_t v4 = *(NSObject **)(v2 + 40);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)std::string __p = 67109120;
      *(_DWORD *)&__p[4] = entitlements::TransferSIMViaWebServiceResponse::success((entitlements::TransferSIMViaWebServiceResponse *)(a1 + 16));
      _os_log_error_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "TSS webservice request response success: %d", __p, 8u);
    }
    int v5 = 52;
    unsigned __int8 v25 = 52;
    uint64_t v6 = *(unsigned __int8 *)(a1 + 151);
    int v7 = (char)v6;
    if ((v6 & 0x80u) != 0) {
      uint64_t v6 = *(void *)(a1 + 136);
    }
    if (v6)
    {
      int v8 = *(NSObject **)(v2 + 40);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
      {
        uint64_t v19 = (const char *)(a1 + 184);
        uint64_t v20 = *(void *)(a1 + 128);
        if (v7 >= 0) {
          uint64_t v20 = a1 + 128;
        }
        if (*(char *)(a1 + 207) < 0) {
          uint64_t v19 = *(const char **)(a1 + 184);
        }
        *(_DWORD *)std::string __p = 136315394;
        *(void *)&__p[4] = v20;
        __int16 v27 = 2080;
        long long v28 = v19;
        _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "Carrier error in TSS webservice response: %s for source iccid:%s", __p, 0x16u);
      }
      sub_100B5457C(__p, v2, a1 + 184, (unsigned __int8 **)(a1 + 128));
      int v5 = sub_100CDAF4C(__p);
      unsigned __int8 v25 = v5;
      if (SHIBYTE(v29) < 0) {
        operator delete(*(void **)__p);
      }
      sub_100093B44((std::string *)(*(void *)(a1 + 216) + 1480), (const std::string *)(a1 + 128));
    }
    CFStringRef v23 = 0;
    if (!*(unsigned char *)(v2 + 131))
    {
      int v9 = (const char *)(a1 + 152);
      if ((*(char *)(a1 + 175) & 0x80000000) == 0)
      {
        if (!*(unsigned char *)(a1 + 175)) {
          goto LABEL_32;
        }
        goto LABEL_31;
      }
      if (*(void *)(a1 + 160))
      {
        int v9 = *(const char **)v9;
LABEL_31:
        CFStringRef v14 = CFStringCreateWithCString(kCFAllocatorDefault, v9, 0x8000100u);
        CFStringRef v15 = v23;
        CFStringRef v23 = v14;
        *(void *)std::string __p = v15;
        sub_1000558F4((const void **)__p);
      }
    }
LABEL_32:
    unsigned __int8 v24 = 11;
    *(void *)std::string __p = 0;
    int v16 = 70040;
    if (v5 > 53)
    {
      if (v5 == 54)
      {
        int v16 = 70042;
      }
      else if (v5 == 55)
      {
        int v16 = 70044;
      }
    }
    else if (v5 == 37)
    {
      int v16 = 70043;
    }
    else if (v5 == 53)
    {
      int v16 = 70041;
    }
    int v21 = v16;
    char v22 = 1;
    sub_100B3E598((void *)v2, (unsigned __int8 **)(a1 + 184), &v24, 0, (const void **)&v23, (char *)&v25, (const void **)__p, 7u, 1, (uint64_t)&v21, (uint64_t *)(a1 + 216));
    sub_100057D78((const void **)__p);
    uint64_t v13 = (const void **)&v23;
LABEL_42:
    sub_1000558F4(v13);
    return;
  }
  sub_100B3F32C(*(void *)(a1 + 8));

  sub_100B3F548(v2);
}

void sub_100B7602C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, const void *a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
}

uint64_t sub_100B76088(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100B760C8()
{
}

uint64_t sub_100B760D4(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = *(void *)a2;
  uint64_t v4 = a1 + 176;
  sub_10030E6AC((unsigned char *)(a1 + 8), a2 + 8);
  if (*(char *)(a2 + 199) < 0)
  {
    sub_10004FC84((unsigned char *)v4, *(void **)(a2 + 176), *(void *)(a2 + 184));
  }
  else
  {
    long long v5 = *(_OWORD *)(a2 + 176);
    *(void *)(v4 + 16) = *(void *)(a2 + 192);
    *(_OWORD *)uint64_t v4 = v5;
  }
  *(_OWORD *)(a1 + 200) = *(_OWORD *)(a2 + 200);
  return a1;
}

void sub_100B76150(_Unwind_Exception *a1)
{
  sub_10030D32C(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100B76164(uint64_t a1)
{
  if (*(char *)(a1 + 199) < 0) {
    operator delete(*(void **)(a1 + 176));
  }

  return sub_10030D32C(a1 + 8);
}

_UNKNOWN **sub_100B761A8(unsigned int a1, void *a2, void *a3, uint64_t a4, void *a5)
{
  uint64_t v5 = a1;
  switch(v5)
  {
    case 1:
      uint64_t v11 = a2[1];
      BOOL v12 = operator new(0xA0uLL);
      sub_10030E704((uint64_t)v12, v11);
      __n128 result = 0;
      *a3 = sub_100B761A8;
      a3[1] = v12;
      break;
    case 2:
      __n128 result = 0;
      uint64_t v13 = a2[1];
      *a3 = sub_100B761A8;
      a3[1] = v13;
      goto LABEL_20;
    case 3:
      if (a4) {
      else
      }
        BOOL v10 = a5 == &unk_10154AE20;
      if (v10) {
        __n128 result = (_UNKNOWN **)a2[1];
      }
      else {
        __n128 result = 0;
      }
      break;
    case 4:
      return result;
    default:
      uint64_t v9 = a2[1];
      if (*(char *)(v9 + 159) < 0) {
        operator delete(*(void **)(v9 + 136));
      }
      if (*(char *)(v9 + 135) < 0) {
        operator delete(*(void **)(v9 + 112));
      }
      if (*(unsigned char *)(v9 + 96) && *(char *)(v9 + 95) < 0) {
        operator delete(*(void **)(v9 + 72));
      }
      if (*(unsigned char *)(v9 + 64) && *(char *)(v9 + 63) < 0) {
        operator delete(*(void **)(v9 + 40));
      }
      if (*(unsigned char *)(v9 + 32) && *(char *)(v9 + 31) < 0) {
        operator delete(*(void **)(v9 + 8));
      }
      operator delete((void *)v9);
      __n128 result = 0;
LABEL_20:
      *a2 = 0;
      break;
  }
  return result;
}

void sub_100B76300(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t *sub_100B76328(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v42 = a1;
  uint64_t v43 = v1;
  uint64_t v2 = *(std::__shared_weak_count **)(v1 + 16);
  if (!v2)
  {
    uint64_t v4 = 0;
    goto LABEL_19;
  }
  uint64_t v3 = *(void *)v1;
  uint64_t v4 = std::__shared_weak_count::lock(v2);
  if (!v4 || !*(void *)(v1 + 8))
  {
LABEL_19:
    ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)buf, kCtLoggingSystemName, "cp.tr.ctr");
    uint64_t v20 = *(NSObject **)&buf[8];
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, "invalid CellularPlanTransferFlowController (weak_ptr)", buf, 2u);
    }
    goto LABEL_21;
  }
  uint64_t v5 = *(NSObject **)(v3 + 40);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v6 = (void *)(v1 + 48);
    if (*(char *)(v1 + 71) < 0) {
      uint64_t v6 = (void *)*v6;
    }
    int v7 = (void *)(v1 + 24);
    if (*(char *)(v1 + 47) < 0) {
      int v7 = (void *)*v7;
    }
    int v8 = *(unsigned __int8 *)(v1 + 72);
    *(_DWORD *)long long buf = 136315650;
    *(void *)&uint8_t buf[4] = v6;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&unsigned char buf[14] = v7;
    *(_WORD *)&unsigned char buf[22] = 1024;
    int v50 = v8;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Push notification Topic: [%s] ICCID: [%s] esim-profile-released: [%d]", buf, 0x1Cu);
  }
  if (!*(unsigned char *)(v1 + 72))
  {
    char v22 = *(NSObject **)(v3 + 40);
    if (!os_log_type_enabled(v22, OS_LOG_TYPE_ERROR)) {
      goto LABEL_22;
    }
    *(_WORD *)long long buf = 0;
    CFStringRef v23 = "eSIM profile not released";
    goto LABEL_28;
  }
  *(unsigned char *)(v3 + 137) = 0;
  uint64_t v9 = *(void *)(v3 + 304);
  uint64_t v10 = *(void *)(v3 + 312);
  if (v9 == v10)
  {
    char v22 = *(NSObject **)(v3 + 40);
    if (!os_log_type_enabled(v22, OS_LOG_TYPE_ERROR)) {
      goto LABEL_22;
    }
    *(_WORD *)long long buf = 0;
    CFStringRef v23 = "No active plan to transfer";
LABEL_28:
    unsigned __int8 v24 = v22;
    uint32_t v25 = 2;
LABEL_29:
    _os_log_error_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, v23, buf, v25);
    goto LABEL_22;
  }
  uint64_t v11 = (void *)(v1 + 24);
  uint64_t v12 = sub_100B45F5C(v9, *(void *)(v3 + 312), (unsigned __int8 **)(v1 + 24));
  if (v10 == v12)
  {
    uint64_t v26 = *(NSObject **)(v3 + 40);
    if (!os_log_type_enabled(v26, OS_LOG_TYPE_ERROR)) {
      goto LABEL_22;
    }
    if (*(char *)(v1 + 47) < 0) {
      uint64_t v11 = (void *)*v11;
    }
    __int16 v27 = (void *)(v1 + 48);
    if (*(char *)(v1 + 71) < 0) {
      __int16 v27 = (void *)*v27;
    }
    *(_DWORD *)long long buf = 136315394;
    *(void *)&uint8_t buf[4] = v11;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&unsigned char buf[14] = v27;
    CFStringRef v23 = "No transfer data for iccid: %s, topic: %s";
    unsigned __int8 v24 = v26;
    uint32_t v25 = 22;
    goto LABEL_29;
  }
  uint64_t v13 = v12;
  memset(buf, 0, sizeof(buf));
  sub_100B49750((uint64_t)buf, v1 + 24);
  CFStringRef v14 = *(std::__shared_weak_count **)(v3 + 72);
  if (v14)
  {
    CFStringRef v15 = std::__shared_weak_count::lock(v14);
    if (v15)
    {
      int v16 = v15;
      uint64_t v17 = *(void *)(v3 + 64);
      if (v17)
      {
        (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v17 + 40))(v17, v1 + 24, v13 + 1296, 3);
        uint64_t v18 = *(void *)(v3 + 856);
        uint64_t v19 = *(void *)(v3 + 864);
        if (*(char *)(v1 + 47) < 0)
        {
          sub_10004FC84(__p, *(void **)(v1 + 24), *(void *)(v1 + 32));
        }
        else
        {
          *(_OWORD *)std::string __p = *(_OWORD *)v11;
          uint64_t v48 = *(void *)(v1 + 40);
        }
        uint64_t v28 = HIBYTE(v48);
        if (v18 == v19)
        {
          char v39 = 0;
        }
        else
        {
          long long v41 = v16;
          __int16 v29 = __p[0];
          int v30 = __p[1];
          if (v48 >= 0) {
            uint64_t v31 = (void *)HIBYTE(v48);
          }
          else {
            uint64_t v31 = __p[1];
          }
          do
          {
            long long v32 = (void *)*(unsigned __int8 *)(v18 + 455);
            int v33 = (char)v32;
            if ((char)v32 < 0) {
              long long v32 = *(void **)(v18 + 440);
            }
            if (v31 == v32)
            {
              if (v33 >= 0) {
                char v34 = (unsigned __int8 *)(v18 + 432);
              }
              else {
                char v34 = *(unsigned __int8 **)(v18 + 432);
              }
              if ((v28 & 0x80) != 0)
              {
                uint64_t v40 = v19;
                long long v37 = v29;
                int v38 = memcmp(v29, v34, (size_t)v30);
                __int16 v29 = v37;
                uint64_t v19 = v40;
                if (!v38)
                {
                  char v39 = 1;
                  int v16 = v41;
                  goto LABEL_59;
                }
              }
              else
              {
                if (!v28)
                {
                  char v39 = 1;
                  int v16 = v41;
                  goto LABEL_60;
                }
                long long v35 = __p;
                uint64_t v36 = v28;
                while (*(unsigned __int8 *)v35 == *v34)
                {
                  long long v35 = (void **)((char *)v35 + 1);
                  ++v34;
                  if (!--v36)
                  {
                    char v39 = 1;
                    goto LABEL_56;
                  }
                }
              }
            }
            v18 += 1248;
          }
          while (v18 != v19);
          char v39 = 0;
LABEL_56:
          int v16 = v41;
        }
        if ((v28 & 0x80) != 0) {
LABEL_59:
        }
          operator delete(__p[0]);
LABEL_60:
        LOBYTE(__dst[0]) = sub_100CDB2F8(*(unsigned __int8 *)(v13 + 1280));
        unsigned __int8 v46 = 8;
        sub_100B4B75C(v3, __dst, &v46, v13, v39, *(unsigned __int8 *)(v13 + 1284));
      }
      sub_10004D2C8(v16);
    }
  }
  if (*(char *)(v1 + 47) < 0)
  {
    sub_10004FC84(__dst, *(void **)(v1 + 24), *(void *)(v1 + 32));
  }
  else
  {
    *(_OWORD *)long long __dst = *(_OWORD *)v11;
    uint64_t v45 = *(void *)(v1 + 40);
  }
  sub_100B4A3B8(v3, (uint64_t)__dst);
  if (SHIBYTE(v45) < 0) {
    operator delete(__dst[0]);
  }
  if ((char)buf[23] < 0) {
    operator delete(*(void **)buf);
  }
LABEL_21:
  if (v4) {
LABEL_22:
  }
    sub_10004D2C8(v4);
  sub_100B76854(&v43);
  return sub_100046B58((uint64_t *)&v42);
}

void sub_100B767E0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,void *__p,uint64_t a25,int a26,__int16 a27,char a28,char a29)
{
  sub_10004D2C8(v30);
  if (a29 < 0) {
    operator delete(__p);
  }
  if (v29) {
    sub_10004D2C8(v29);
  }
  sub_100B76854(&a12);
  sub_100046B58(&a11);
  _Unwind_Resume(a1);
}

uint64_t *sub_100B76854(uint64_t *result)
{
  uint64_t v1 = *result;
  *__n128 result = 0;
  if (v1)
  {
    if (*(char *)(v1 + 71) < 0) {
      operator delete(*(void **)(v1 + 48));
    }
    if (*(char *)(v1 + 47) < 0) {
      operator delete(*(void **)(v1 + 24));
    }
    uint64_t v2 = *(std::__shared_weak_count **)(v1 + 16);
    if (v2) {
      std::__shared_weak_count::__release_weak(v2);
    }
    operator delete();
  }
  return result;
}

uint64_t *sub_100B768C8(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v4 = a1;
  uint64_t v5 = v1;
  uint64_t v2 = *(void *)v1;
  sub_100B63100((uint64_t)v6, v1 + 32);
  sub_100B5E588(v2, v1 + 8, (uint64_t)v6, *(_DWORD *)(v1 + 624), *(_DWORD *)(v1 + 628));
  sub_1008C2D48((uint64_t)v6);
  sub_100B76968(&v5);
  return sub_100046B58((uint64_t *)&v4);
}

void sub_100B7693C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
}

uint64_t *sub_100B76968(uint64_t *result)
{
  uint64_t v1 = *result;
  *__n128 result = 0;
  if (v1)
  {
    sub_1008C2D48(v1 + 32);
    if (*(char *)(v1 + 31) < 0) {
      operator delete(*(void **)(v1 + 8));
    }
    operator delete();
  }
  return result;
}

uint64_t sub_100B769C8(uint64_t a1)
{
  *(void *)a1 = off_101A3FAD0;
  if (*(char *)(a1 + 647) < 0) {
    operator delete(*(void **)(a1 + 624));
  }
  sub_1008C2D48(a1 + 32);
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 24);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_100B76A2C(uint64_t a1)
{
  *(void *)a1 = off_101A3FAD0;
  if (*(char *)(a1 + 647) < 0) {
    operator delete(*(void **)(a1 + 624));
  }
  sub_1008C2D48(a1 + 32);
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 24);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete();
}

void *sub_100B76AB0(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t v2 = operator new(0x298uLL);
  void *v2 = off_101A3FAD0;
  sub_100B76ECC((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_100B76B04(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100B76B18(uint64_t a1, void *a2)
{
  *a2 = off_101A3FAD0;
  return sub_100B76ECC((uint64_t)(a2 + 1), a1 + 8);
}

void sub_100B76B44(uint64_t a1)
{
}

void sub_100B76B4C(void *a1)
{
  sub_100B76F94((uint64_t)a1 + 8);

  operator delete(a1);
}

uint64_t sub_100B76B88(uint64_t a1, uint64_t a2, int *a3)
{
  v15[0] = 0;
  char v16 = 0;
  if (*(unsigned char *)(a2 + 272))
  {
    sub_100B7302C((uint64_t)v15, a2);
    char v16 = 1;
  }
  uint64_t v5 = *(void *)(a1 + 8);
  uint64_t v6 = *(std::__shared_weak_count **)(a1 + 24);
  if (v6)
  {
    int v7 = *a3;
    int v8 = std::__shared_weak_count::lock(v6);
    if (v8 && *(void *)(a1 + 16))
    {
      if (v16)
      {
        sub_100778E10(v17, (uint64_t)v15);
        sub_100B5B630(v5, (uint64_t *)(a1 + 624), (uint64_t)v17, a1 + 32);
        sub_100777C48((uint64_t)v17);
        sub_100B63100((uint64_t)buf, a1 + 32);
        sub_100B5E588(v5, a1 + 624, (uint64_t)buf, *(_DWORD *)(a1 + 656), 6000);
        sub_1008C2D48((uint64_t)buf);
      }
      else
      {
        int v14 = *(_DWORD *)(a1 + 656);
        uint64_t v24 = 0;
        sub_100B56FFC(v5, a1 + 624, v7, v14, (uint64_t)buf);
        sub_100060644(buf);
      }
LABEL_19:
      sub_10004D2C8(v8);
      return sub_100777C48((uint64_t)v15);
    }
  }
  else
  {
    int v8 = 0;
  }
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)buf, kCtLoggingSystemName, "cp.tr.ctr");
  uint64_t v9 = v23;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
  if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "invalid CellularPlanTransferFlowController (weak_ptr)", buf, 2u);
  }
  unsigned int v10 = *(_DWORD *)(a1 + 656) - 1;
  if (v10 > 8) {
    int v11 = 70023;
  }
  else {
    int v11 = dword_10154B664[v10];
  }
  if (*(unsigned char *)(v5 + 360))
  {
    if (!*(unsigned char *)(v5 + 1020))
    {
      *(_DWORD *)(v5 + 1016) = 1;
      *(unsigned char *)(v5 + 1020) = 1;
    }
    *(void *)long long buf = v5 + 336;
    uint64_t v12 = sub_100B6C578((uint64_t **)(v5 + 992), (void **)(v5 + 336), (long long **)buf);
    *((_DWORD *)v12 + 21) = v11;
    v12[88] = 1;
  }
  unsigned __int8 v21 = 11;
  *(void *)long long buf = 0;
  char v20 = 56;
  v17[0] = 0;
  int v18 = v11;
  char v19 = 1;
  sub_100B3E598((void *)v5, (unsigned __int8 **)(a1 + 624), &v21, 1, (const void **)buf, &v20, v17, 0, 1, (uint64_t)&v18, (uint64_t *)(a1 + 648));
  sub_100057D78(v17);
  sub_1000558F4((const void **)buf);
  if (v8) {
    goto LABEL_19;
  }
  return sub_100777C48((uint64_t)v15);
}

void sub_100B76E0C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  sub_100060644(&STACK[0x260]);
  sub_10004D2C8(v5);
  sub_100777C48((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100B76E80(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100B76EC0()
{
}

uint64_t sub_100B76ECC(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = *(_OWORD *)a2;
  uint64_t v4 = *(void *)(a2 + 16);
  *(void *)(a1 + 16) = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 16), 1uLL, memory_order_relaxed);
  }
  sub_100B63100(a1 + 24, a2 + 24);
  uint64_t v5 = (unsigned char *)(a1 + 616);
  if (*(char *)(a2 + 639) < 0)
  {
    sub_10004FC84(v5, *(void **)(a2 + 616), *(void *)(a2 + 624));
  }
  else
  {
    long long v6 = *(_OWORD *)(a2 + 616);
    *(void *)(a1 + 632) = *(void *)(a2 + 632);
    *(_OWORD *)uint64_t v5 = v6;
  }
  uint64_t v7 = *(void *)(a2 + 640);
  *(_DWORD *)(a1 + 648) = *(_DWORD *)(a2 + 648);
  *(void *)(a1 + 640) = v7;
  return a1;
}

void sub_100B76F6C(_Unwind_Exception *a1)
{
  sub_1008C2D48(v2);
  uint64_t v4 = *(std::__shared_weak_count **)(v1 + 16);
  if (v4) {
    std::__shared_weak_count::__release_weak(v4);
  }
  _Unwind_Resume(a1);
}

void sub_100B76F94(uint64_t a1)
{
  if (*(char *)(a1 + 639) < 0) {
    operator delete(*(void **)(a1 + 616));
  }
  sub_1008C2D48(a1 + 24);
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2)
  {
    std::__shared_weak_count::__release_weak(v2);
  }
}

void sub_100B76FF4()
{
}

void *sub_100B77008()
{
  __n128 result = operator new(0x10uLL);
  *__n128 result = off_101A3FB50;
  return result;
}

void sub_100B77040(uint64_t a1, void *a2)
{
  *a2 = off_101A3FB50;
}

uint64_t sub_100B7706C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100B770AC()
{
}

uint64_t sub_100B770B8(uint64_t a1)
{
  *(void *)a1 = off_101A3FBD0;
  if (*(char *)(a1 + 55) < 0) {
    operator delete(*(void **)(a1 + 32));
  }
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 24);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_100B77114(uint64_t a1)
{
  *(void *)a1 = off_101A3FBD0;
  if (*(char *)(a1 + 55) < 0) {
    operator delete(*(void **)(a1 + 32));
  }
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 24);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete();
}

void *sub_100B77190(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t v2 = operator new(0x48uLL);
  void *v2 = off_101A3FBD0;
  sub_100B77540((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_100B771E4(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100B771F8(uint64_t a1, void *a2)
{
  *a2 = off_101A3FBD0;
  return sub_100B77540((uint64_t)(a2 + 1), a1 + 8);
}

void sub_100B77224(uint64_t a1)
{
}

void sub_100B7722C(void *a1)
{
  sub_10010FC80((uint64_t)a1 + 8);

  operator delete(a1);
}

uint64_t sub_100B77268(uint64_t a1, uint64_t a2, int *a3)
{
  v11[0] = 0;
  char v12 = 0;
  if (*(unsigned char *)(a2 + 272))
  {
    sub_100B7302C((uint64_t)v11, a2);
    char v12 = 1;
  }
  uint64_t v5 = *(void **)(a1 + 8);
  if (*(unsigned char *)(a1 + 64))
  {
    long long v6 = *(std::__shared_weak_count **)(a1 + 24);
    if (v6)
    {
      int v7 = *a3;
      int v8 = std::__shared_weak_count::lock(v6);
      if (v8 && *(void *)(a1 + 16))
      {
        *(unsigned char *)(*(void *)(a1 + 56) + 1461) = 0;
        sub_100778E10(buf, (uint64_t)v11);
        sub_100B5F7E8((uint64_t)v5, a1 + 32, (uint64_t)buf, 4, v7);
        sub_100777C48((uint64_t)buf);
LABEL_13:
        sub_10004D2C8(v8);
        return sub_100777C48((uint64_t)v11);
      }
    }
    else
    {
      int v8 = 0;
    }
    ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)buf, kCtLoggingSystemName, "cp.tr.ctr");
    uint64_t v9 = v14;
    ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "invalid CellularPlanTransferFlowController (weak_ptr)", buf, 2u);
    }
    unsigned __int8 v19 = 11;
    *(void *)long long buf = 0;
    char v18 = 56;
    uint64_t v17 = 0;
    int v15 = 70056;
    char v16 = 1;
    sub_100B3E598(v5, (unsigned __int8 **)(a1 + 32), &v19, 1, (const void **)buf, &v18, &v17, 0, 1, (uint64_t)&v15, (uint64_t *)(a1 + 56));
    sub_100057D78(&v17);
    sub_1000558F4((const void **)buf);
    if (v8) {
      goto LABEL_13;
    }
  }
  else
  {
    unsigned __int8 v19 = 11;
    *(void *)long long buf = 0;
    char v18 = 45;
    uint64_t v17 = 0;
    int v15 = 70062;
    char v16 = 1;
    sub_100B3E598(v5, (unsigned __int8 **)(a1 + 32), &v19, 1, (const void **)buf, &v18, &v17, 4u, 1, (uint64_t)&v15, (uint64_t *)(a1 + 56));
    sub_100057D78(&v17);
    sub_1000558F4((const void **)buf);
  }
  return sub_100777C48((uint64_t)v11);
}

void sub_100B7748C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,char a47)
{
  sub_100777C48((uint64_t)&a47);
  sub_10004D2C8(v47);
  sub_100777C48((uint64_t)&a12);
  _Unwind_Resume(a1);
}

uint64_t sub_100B774F4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100B77534()
{
}

uint64_t sub_100B77540(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = *(_OWORD *)a2;
  uint64_t v4 = *(void *)(a2 + 16);
  *(void *)(a1 + 16) = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 16), 1uLL, memory_order_relaxed);
  }
  uint64_t v5 = (unsigned char *)(a1 + 24);
  if (*(char *)(a2 + 47) < 0)
  {
    sub_10004FC84(v5, *(void **)(a2 + 24), *(void *)(a2 + 32));
  }
  else
  {
    long long v6 = *(_OWORD *)(a2 + 24);
    *(void *)(a1 + 40) = *(void *)(a2 + 40);
    *(_OWORD *)uint64_t v5 = v6;
  }
  uint64_t v7 = *(void *)(a2 + 48);
  *(unsigned char *)(a1 + 56) = *(unsigned char *)(a2 + 56);
  *(void *)(a1 + 48) = v7;
  return a1;
}

void sub_100B775C4(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(std::__shared_weak_count **)(v1 + 16);
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100B775DC(uint64_t a1)
{
  *(void *)a1 = off_101A3FC50;
  if (*(char *)(a1 + 55) < 0) {
    operator delete(*(void **)(a1 + 32));
  }
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 24);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_100B77638(uint64_t a1)
{
  *(void *)a1 = off_101A3FC50;
  if (*(char *)(a1 + 55) < 0) {
    operator delete(*(void **)(a1 + 32));
  }
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 24);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete();
}

void *sub_100B776B4(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t v2 = operator new(0x40uLL);
  void *v2 = off_101A3FC50;
  sub_100B779C4((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_100B77708(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100B7771C(uint64_t a1, void *a2)
{
  *a2 = off_101A3FC50;
  return sub_100B779C4((uint64_t)(a2 + 1), a1 + 8);
}

void sub_100B77748(uint64_t a1)
{
}

void sub_100B77750(void *a1)
{
  sub_10010FC80((uint64_t)a1 + 8);

  operator delete(a1);
}

uint64_t sub_100B7778C(uint64_t a1, uint64_t a2, int *a3)
{
  v11[0] = 0;
  char v12 = 0;
  if (*(unsigned char *)(a2 + 272))
  {
    sub_100B7302C((uint64_t)v11, a2);
    char v12 = 1;
  }
  uint64_t v5 = *(void **)(a1 + 8);
  long long v6 = *(std::__shared_weak_count **)(a1 + 24);
  if (v6)
  {
    int v7 = *a3;
    int v8 = std::__shared_weak_count::lock(v6);
    if (v8 && *(void *)(a1 + 16))
    {
      sub_100778E10(buf, (uint64_t)v11);
      sub_100B5F7E8((uint64_t)v5, a1 + 32, (uint64_t)buf, 7, v7);
      sub_100777C48((uint64_t)buf);
LABEL_11:
      sub_10004D2C8(v8);
      return sub_100777C48((uint64_t)v11);
    }
  }
  else
  {
    int v8 = 0;
  }
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)buf, kCtLoggingSystemName, "cp.tr.ctr");
  uint64_t v9 = v14;
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)buf);
  if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "invalid CellularPlanTransferFlowController (weak_ptr)", buf, 2u);
  }
  unsigned __int8 v19 = 11;
  *(void *)long long buf = 0;
  char v18 = 56;
  uint64_t v17 = 0;
  int v15 = 70059;
  char v16 = 1;
  sub_100B3E598(v5, (unsigned __int8 **)(a1 + 32), &v19, 1, (const void **)buf, &v18, &v17, 0, 1, (uint64_t)&v15, (uint64_t *)(a1 + 56));
  sub_100057D78(&v17);
  sub_1000558F4((const void **)buf);
  if (v8) {
    goto LABEL_11;
  }
  return sub_100777C48((uint64_t)v11);
}

void sub_100B77928(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,char a47)
{
  sub_100777C48((uint64_t)&a47);
  sub_10004D2C8(v47);
  sub_100777C48((uint64_t)&a12);
  _Unwind_Resume(a1);
}

uint64_t sub_100B77978(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100B779B8()
{
}

uint64_t sub_100B779C4(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = *(_OWORD *)a2;
  uint64_t v4 = *(void *)(a2 + 16);
  *(void *)(a1 + 16) = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 16), 1uLL, memory_order_relaxed);
  }
  uint64_t v5 = (unsigned char *)(a1 + 24);
  if (*(char *)(a2 + 47) < 0)
  {
    sub_10004FC84(v5, *(void **)(a2 + 24), *(void *)(a2 + 32));
  }
  else
  {
    long long v6 = *(_OWORD *)(a2 + 24);
    *(void *)(a1 + 40) = *(void *)(a2 + 40);
    *(_OWORD *)uint64_t v5 = v6;
  }
  *(void *)(a1 + 48) = *(void *)(a2 + 48);
  return a1;
}

void sub_100B77A40(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(std::__shared_weak_count **)(v1 + 16);
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  _Unwind_Resume(exception_object);
}

void *sub_100B77A58(void *a1)
{
  *a1 = off_101A3FCD0;
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_100B77AA4(void *a1)
{
  *a1 = off_101A3FCD0;
  uint64_t v1 = (std::__shared_weak_count *)a1[3];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

char *sub_100B77B10(uint64_t a1)
{
  __n128 result = (char *)operator new(0x20uLL);
  *(void *)__n128 result = off_101A3FCD0;
  *(_OWORD *)(result + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 24);
  *((void *)result + 3) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_100B77B74(uint64_t result, uint64_t a2)
{
  *(void *)a2 = off_101A3FCD0;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(result + 8);
  uint64_t v2 = *(void *)(result + 24);
  *(void *)(a2 + 24) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100B77BB4(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 24);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_100B77BC4(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete(__p);
}

void sub_100B77C04(void *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2)
  {
    uint64_t v3 = a1[1];
    uint64_t v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      uint64_t v5 = v4;
      if (a1[2])
      {
        long long v6 = *(NSObject **)(v3 + 40);
        if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)int v7 = 0;
          _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I de-assert after 2min delay", v7, 2u);
        }
        sub_100B63EF8((uint64_t **)(v3 + 1032), 0);
      }
      sub_10004D2C8(v5);
    }
  }
}

uint64_t sub_100B77CA4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100B77CE4()
{
}

uint64_t *sub_100B77D00(uint64_t *result, uint64_t *a2, uint64_t *a3, uint64_t a4)
{
  uint64_t v4 = *a2;
  *__n128 result = *a2;
  *(uint64_t *)((char *)result + *(void *)(v4 - 320)) = a2[1];
  *(uint64_t *)((char *)result + *(void *)(*result - 56)) = a2[2];
  uint64_t v5 = a3[1];
  result[1] = *a3;
  result[2] = v5;
  if (v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
  }
  result[3] = a4;
  return result;
}

uint64_t *sub_100B77DF4(uint64_t *a1, uint64_t *a2)
{
  uint64_t v3 = *a2;
  *a1 = *a2;
  *(uint64_t *)((char *)a1 + *(void *)(v3 - 320)) = a2[1];
  *(uint64_t *)((char *)a1 + *(void *)(*a1 - 56)) = a2[2];
  uint64_t v4 = (std::__shared_weak_count *)a1[2];
  if (v4) {
    sub_10004D2C8(v4);
  }
  return a1;
}

uint64_t sub_100B77F08@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 240))();
  }
  *a2 = 0;
  a2[1] = 0;
  return result;
}

uint64_t sub_100B77F3C@<X0>(void *a1@<X0>, void *a2@<X8>)
{
  uint64_t result = *(void *)((char *)a1 + *(void *)(*a1 - 272) + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 240))();
  }
  *a2 = 0;
  a2[1] = 0;
  return result;
}

uint64_t sub_100B77F8C(char *a1)
{
  uint64_t result = *((void *)a1 + 3);
  if (result)
  {
    int v3 = (*(uint64_t (**)(uint64_t))(*(void *)result + 384))(result);
    return v3 == (*(unsigned int (**)(char *))(*(void *)&a1[*(void *)(*(void *)a1 - 56)] + 24))(&a1[*(void *)(*(void *)a1 - 56)]);
  }
  return result;
}

uint64_t sub_100B78028(char *a1)
{
  return sub_100B77F8C(&a1[*(void *)(*(void *)a1 - 296)]);
}

uint64_t sub_100B78048(char *a1)
{
  uint64_t result = *((void *)a1 + 3);
  if (result)
  {
    int v3 = (*(uint64_t (**)(uint64_t))(*(void *)result + 392))(result);
    return v3 == (*(unsigned int (**)(char *))(*(void *)&a1[*(void *)(*(void *)a1 - 56)] + 24))(&a1[*(void *)(*(void *)a1 - 56)]);
  }
  return result;
}

uint64_t sub_100B780E4(char *a1)
{
  return sub_100B78048(&a1[*(void *)(*(void *)a1 - 304)]);
}

uint64_t sub_100B78104(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 456))();
  }
  return result;
}

uint64_t sub_100B7813C(void *a1)
{
  uint64_t result = *(void *)((char *)a1 + *(void *)(*a1 - 312) + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 456))();
  }
  return result;
}

void sub_100B78190(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
}

void sub_100B781A0()
{
}

void sub_100B78214(capabilities::ct *a1, dispatch_object_t *a2)
{
  if (capabilities::ct::supportsGemini(a1))
  {
    if (*a2) {
      dispatch_retain(*a2);
    }
    NetworkListModel::create(&v3);
  }
  if (*a2) {
    dispatch_retain(*a2);
  }
  NetworkListModel::create(&v3);
}

void sub_100B783C0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16, uint64_t a17, char a18, uint64_t a19, uint64_t a20)
{
  uint64_t v24 = 40;
  while (1)
  {
    uint32_t v25 = *(std::__shared_weak_count **)(v22 + v24);
    if (v25) {
      sub_10004D2C8(v25);
    }
    v24 -= 24;
    if (v24 == -8)
    {
      if (a12) {
        sub_10004D2C8(a12);
      }
      if (v21) {
        dispatch_release(v21);
      }
      if (a16) {
        sub_10004D2C8(a16);
      }
      if (v20) {
        dispatch_release(v20);
      }
      _Unwind_Resume(exception_object);
    }
  }
}

void sub_100B784A0(uint64_t a1, dispatch_object_t *a2)
{
  if (*a2) {
    dispatch_retain(*a2);
  }
  sub_1010EAC5C();
}

void sub_100B78510(_Unwind_Exception *exception_object)
{
  if (v1) {
    dispatch_release(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100B78528(uint64_t a1, dispatch_object_t *a2)
{
  if (*a2) {
    dispatch_retain(*a2);
  }
  NetworkListEventHandler::create();
}

void sub_100B78598(_Unwind_Exception *exception_object)
{
  if (v1) {
    dispatch_release(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100B785B0(NetworkListFactoryInterface *this)
{
  *(void *)this = off_101A3FEF0;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }

  NetworkListFactoryInterface::~NetworkListFactoryInterface(this);
}

void sub_100B7860C(NetworkListFactoryInterface *this)
{
  *(void *)this = off_101A3FEF0;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  NetworkListFactoryInterface::~NetworkListFactoryInterface(this);

  operator delete();
}

uint64_t **sub_100B7867C(uint64_t **a1, int *a2, uint64_t a3)
{
  a1[1] = 0;
  uint64_t v4 = a1 + 1;
  a1[2] = 0;
  *a1 = (uint64_t *)(a1 + 1);
  if (a3)
  {
    uint64_t v5 = a2;
    long long v6 = 0;
    int v7 = &a2[6 * a3];
    int v8 = a1 + 1;
    while (1)
    {
      int v9 = *v5;
      unsigned int v10 = v4;
      if (v8 == v4) {
        break;
      }
      int v11 = v6;
      char v12 = v4;
      if (v6)
      {
        do
        {
          unsigned int v10 = (uint64_t **)v11;
          int v11 = (uint64_t *)v11[1];
        }
        while (v11);
      }
      else
      {
        do
        {
          unsigned int v10 = (uint64_t **)v12[2];
          BOOL v13 = *v10 == (uint64_t *)v12;
          char v12 = v10;
        }
        while (v13);
      }
      if (*((_DWORD *)v10 + 8) < v9) {
        break;
      }
      int v15 = v4;
      int v14 = v4;
      if (!v6) {
        goto LABEL_25;
      }
      char v16 = v6;
      while (1)
      {
        while (1)
        {
          int v14 = (uint64_t **)v16;
          int v17 = *((_DWORD *)v16 + 8);
          if (v17 <= v9) {
            break;
          }
          char v16 = *v14;
          int v15 = v14;
          if (!*v14) {
            goto LABEL_25;
          }
        }
        if (v17 >= v9) {
          break;
        }
        char v16 = v14[1];
        if (!v16)
        {
          int v15 = v14 + 1;
          goto LABEL_25;
        }
      }
LABEL_30:
      v5 += 6;
      if (v5 == v7) {
        return a1;
      }
      int v8 = (uint64_t **)*a1;
      long long v6 = a1[1];
    }
    if (v6) {
      int v14 = v10;
    }
    else {
      int v14 = v4;
    }
    if (v6) {
      int v15 = v10 + 1;
    }
    else {
      int v15 = v4;
    }
    if (*v15) {
      goto LABEL_30;
    }
LABEL_25:
    char v18 = (uint64_t *)operator new(0x38uLL);
    unsigned __int8 v19 = v18;
    *((_DWORD *)v18 + 8) = v9;
    uint64_t v20 = *((void *)v5 + 2);
    v18[5] = *((void *)v5 + 1);
    v18[6] = v20;
    if (v20) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v20 + 8), 1uLL, memory_order_relaxed);
    }
    *char v18 = 0;
    v18[1] = 0;
    void v18[2] = (uint64_t)v14;
    std::__shared_weak_count *v15 = v18;
    unsigned __int8 v21 = (uint64_t *)**a1;
    if (v21)
    {
      *a1 = v21;
      unsigned __int8 v19 = *v15;
    }
    sub_100046C90(a1[1], v19);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
    goto LABEL_30;
  }
  return a1;
}

void sub_100B78800(_Unwind_Exception *a1)
{
  sub_10005D0E4(v1, v2);
  _Unwind_Resume(a1);
}

void dormancy::DormancyController::create(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  operator new();
}

void sub_100B78D04(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, ctu::OsLogLogger *a9, uint64_t a10, std::__shared_weak_count *a11, dispatch_object_t a12, dispatch_object_t a13, dispatch_object_t object, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  uint32_t v25 = *(std::__shared_weak_count **)(v20 + 88);
  if (v25) {
    sub_10004D2C8(v25);
  }
  sub_100160A84(v24);
  ctu::OsLogLogger::~OsLogLogger(a9);
  sub_100087E88(v23);
  if (v22)
  {
    dispatch_release(v22);
    if (!v21) {
      goto LABEL_5;
    }
  }
  else if (!v21)
  {
    goto LABEL_5;
  }
  sub_10004D2C8(v21);
LABEL_5:
  operator delete();
}