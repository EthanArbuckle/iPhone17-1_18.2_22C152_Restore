void sub_10057C4C8(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

const void **sub_10057C72C(uint64_t a1, xpc *a2)
{
  if (xpc_get_type(*(xpc_object_t *)a2) == (xpc_type_t)&_xpc_type_null)
  {
    return (const void **)DevicePersistentSaveValue(@"ReportedSubscriberIdentity", 0);
  }
  else
  {
    xpc::bridge((uint64_t *)&v5, a2, v3);
    DevicePersistentSaveValue();
    return sub_1000577C4(&v5);
  }
}

void sub_10057C7BC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000577C4((const void **)va);
  _Unwind_Resume(a1);
}

void sub_10057C7D0(uint64_t a1)
{
  if (capabilities::ct::supportsGemini((capabilities::ct *)a1))
  {
    v2 = *(void **)(a1 + 224);
    if (v2 != (void *)(a1 + 232))
    {
      do
      {
        v3 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), *((unsigned int *)v2 + 8));
        if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
        {
          v4 = v2 + 9;
          if (*((char *)v2 + 95) < 0) {
            v4 = (void *)*v4;
          }
          *(_DWORD *)buf = 136315138;
          v11 = v4;
          _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Subscriber ID: %s", buf, 0xCu);
        }
        v5 = (void *)v2[1];
        if (v5)
        {
          do
          {
            v6 = v5;
            v5 = (void *)*v5;
          }
          while (v5);
        }
        else
        {
          do
          {
            v6 = (void *)v2[2];
            BOOL v7 = *v6 == (void)v2;
            v2 = v6;
          }
          while (!v7);
        }
        v2 = v6;
      }
      while (v6 != (void *)(a1 + 232));
    }
  }
  else
  {
    v8 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      v9 = (void *)(a1 + 200);
      if (*(char *)(a1 + 223) < 0) {
        v9 = (void *)*v9;
      }
      *(_DWORD *)buf = 136315138;
      v11 = v9;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Subscriber ID: %s", buf, 0xCu);
    }
  }
}

uint64_t sub_10057C978(uint64_t a1)
{
  *(void *)a1 = off_1019E4B60;
  v2 = *(std::__shared_weak_count **)(a1 + 280);
  if (v2) {
    sub_10004D2C8(v2);
  }
  sub_100088048(a1 + 248, *(void **)(a1 + 256));
  sub_1000881B0(a1 + 224, *(void **)(a1 + 232));
  if (*(char *)(a1 + 223) < 0) {
    operator delete(*(void **)(a1 + 200));
  }

  return sub_100A85CB8(a1);
}

void sub_10057C9FC(uint64_t a1)
{
  *(void *)a1 = off_1019E4B60;
  v2 = *(std::__shared_weak_count **)(a1 + 280);
  if (v2) {
    sub_10004D2C8(v2);
  }
  sub_100088048(a1 + 248, *(void **)(a1 + 256));
  sub_1000881B0(a1 + 224, *(void **)(a1 + 232));
  if (*(char *)(a1 + 223) < 0) {
    operator delete(*(void **)(a1 + 200));
  }
  sub_100A85CB8(a1);

  operator delete();
}

uint64_t sub_10057CA94(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 136))
  {
    if (*(char *)(a1 + 111) < 0) {
      operator delete(*(void **)(a1 + 88));
    }
    if (*(char *)(a1 + 87) < 0) {
      operator delete(*(void **)(a1 + 64));
    }
    if (*(char *)(a1 + 55) < 0) {
      operator delete(*(void **)(a1 + 32));
    }
    if (*(char *)(a1 + 31) < 0) {
      operator delete(*(void **)(a1 + 8));
    }
  }
  return a1;
}

void sub_10057CB00(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_10057CBCC(void *a1)
{
  __cxa_begin_catch(a1);
  dispatch_barrier_async_f(v1[3], v1, (dispatch_function_t)sub_10057CCA4);
  __cxa_rethrow();
}

void sub_10057CBF4(_Unwind_Exception *a1)
{
}

void sub_10057CC0C(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_10057CC44(uint64_t a1)
{
}

uint64_t sub_10057CC60(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_10057CCA4(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void sub_10057CCD4()
{
}

void *sub_10057CCE8(uint64_t a1)
{
  result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_1019E4C38;
  result[1] = v3;
  return result;
}

uint64_t sub_10057CD30(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019E4C38;
  a2[1] = v2;
  return result;
}

void sub_10057CD5C(uint64_t a1, xpc_object_t *a2)
{
}

uint64_t sub_10057CD64(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10057CDA4()
{
}

void sub_10057CDB0(uint64_t a1, xpc_object_t *a2)
{
  xpc_object_t v3 = *a2;
  if (*a2 && xpc_get_type(*a2) == (xpc_type_t)&_xpc_type_array) {
    xpc_retain(v3);
  }
  else {
    xpc_object_t v3 = xpc_null_create();
  }
  sub_1000881B0(a1, *(void **)(a1 + 8));
  *(void *)a1 = a1 + 8;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 8) = 0;
  if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_array)
  {
    object[0] = v3;
    if (v3) {
      xpc_retain(v3);
    }
    else {
      object[0] = xpc_null_create();
    }
    sub_100048BF4(&v14, object, 0);
    xpc_release(object[0]);
    object[0] = v3;
    if (v3) {
      xpc_retain(v3);
    }
    else {
      object[0] = xpc_null_create();
    }
    if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_array) {
      count = (void *)xpc_array_get_count(v3);
    }
    else {
      count = 0;
    }
    sub_100048BF4(v13, object, count);
    xpc_release(object[0]);
    for (i = v15; i != v13[1] || v14 != v13[0]; i = ++v15)
    {
      xpc_object_t v12 = 0;
      object[0] = &v14;
      object[1] = i;
      sub_10003FBDC((uint64_t)object, &v12);
      if (xpc_get_type(v12) == (xpc_type_t)&_xpc_type_dictionary)
      {
        uint64_t v11 = 0;
        *(_OWORD *)__p = 0u;
        long long v10 = 0u;
        *(_OWORD *)object = 0u;
        long long v8 = 0u;
        xpc_object_t v6 = v12;
        if (v12) {
          xpc_retain(v12);
        }
        else {
          xpc_object_t v6 = xpc_null_create();
        }
        sub_10057D068((int *)object, &v6);
        xpc_release(v6);
        sub_10057D21C(a1, (int *)object, (uint64_t)object);
        if (SHIBYTE(v10) < 0) {
          operator delete(__p[1]);
        }
        if (SHIBYTE(v8) < 0) {
          operator delete(object[1]);
        }
      }
      xpc_release(v12);
    }
    xpc_release(v14);
    xpc_release(v14);
  }
  xpc_release(v3);
}

void sub_10057CFCC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t a10, xpc_object_t object)
{
  xpc_release(object);
  xpc_release(*(xpc_object_t *)(v12 - 48));
  xpc_release(v11);
  _Unwind_Resume(a1);
}

void sub_10057D068(int *a1, xpc_object_t *a2)
{
  xpc_object_t v3 = *a2;
  xpc_object_t v9 = v3;
  if (v3 && xpc_get_type(v3) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v3);
  }
  else
  {
    xpc_object_t v3 = xpc_null_create();
    xpc_object_t v9 = v3;
  }
  if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_object_t v6 = &v9;
    BOOL v7 = "first";
    sub_100048BAC((uint64_t)&v6, &object);
    xpc_type_t type = xpc_get_type(object);
    if (type == (xpc_type_t)&_xpc_type_string)
    {
      int v10 = *a1;
      ctu::rest::detail::read_enum_string_value((ctu::rest::detail *)&v10, (int *)&object, v5);
      *a1 = v10;
    }
    else if (type == (xpc_type_t)&_xpc_type_BOOL {
           || type == (xpc_type_t)&_xpc_type_int64
    }
           || type == (xpc_type_t)&_xpc_type_uint64)
    {
      *a1 = xpc::dyn_cast_or_default((xpc *)&object, 0, (uint64_t)v5);
    }
    xpc_release(object);
    xpc_object_t v6 = &v9;
    BOOL v7 = "second";
    sub_100048BAC((uint64_t)&v6, &object);
    rest::read_rest_value();
    xpc_release(object);
    xpc_object_t v3 = v9;
  }
  xpc_release(v3);
}

void sub_10057D1C8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, xpc_object_t object, xpc_object_t a13)
{
}

uint64_t *sub_10057D21C(uint64_t a1, int *a2, uint64_t a3)
{
  v5 = (uint64_t **)(a1 + 8);
  uint64_t v4 = *(void *)(a1 + 8);
  if (v4)
  {
    int v6 = *a2;
    while (1)
    {
      while (1)
      {
        BOOL v7 = (uint64_t *)v4;
        int v8 = *(_DWORD *)(v4 + 32);
        if (v6 >= v8) {
          break;
        }
        uint64_t v4 = *v7;
        v5 = (uint64_t **)v7;
        if (!*v7) {
          goto LABEL_10;
        }
      }
      if (v8 >= v6) {
        break;
      }
      uint64_t v4 = v7[1];
      if (!v4)
      {
        v5 = (uint64_t **)(v7 + 1);
        goto LABEL_10;
      }
    }
  }
  else
  {
    BOOL v7 = (uint64_t *)(a1 + 8);
LABEL_10:
    memset(v10, 0, sizeof(v10));
    sub_10057D2E8(a1, a3, v10);
    sub_100046C38((uint64_t **)a1, (uint64_t)v7, v5, v10[0]);
    BOOL v7 = v10[0];
    v10[0] = 0;
    sub_10008CD68((uint64_t)v10, 0);
  }
  return v7;
}

uint64_t sub_10057D2E8@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  uint64_t v5 = a1 + 8;
  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  int v6 = operator new(0x68uLL);
  *a3 = v6;
  a3[1] = v5;
  *((unsigned char *)a3 + 16) = 0;
  uint64_t result = sub_10057D35C((uint64_t)v6 + 32, a2);
  *((unsigned char *)a3 + 16) = 1;
  return result;
}

void sub_10057D344(_Unwind_Exception *a1)
{
  sub_10008CD68(v1, 0);
  _Unwind_Resume(a1);
}

uint64_t sub_10057D35C(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)a1 = *(_DWORD *)a2;
  if (*(char *)(a2 + 31) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 8), *(void **)(a2 + 8), *(void *)(a2 + 16));
  }
  else
  {
    long long v4 = *(_OWORD *)(a2 + 8);
    *(void *)(a1 + 24) = *(void *)(a2 + 24);
    *(_OWORD *)(a1 + 8) = v4;
  }
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  uint64_t v5 = (unsigned char *)(a1 + 40);
  if (*(char *)(a2 + 63) < 0)
  {
    sub_10004FC84(v5, *(void **)(a2 + 40), *(void *)(a2 + 48));
  }
  else
  {
    long long v6 = *(_OWORD *)(a2 + 40);
    *(void *)(a1 + 56) = *(void *)(a2 + 56);
    *(_OWORD *)uint64_t v5 = v6;
  }
  *(void *)(a1 + 64) = *(void *)(a2 + 64);
  return a1;
}

void sub_10057D400(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 31) < 0) {
    operator delete(*v2);
  }
  _Unwind_Resume(exception_object);
}

void sub_10057D420()
{
}

void *sub_10057D434(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_1019E4CB8;
  result[1] = v3;
  return result;
}

uint64_t sub_10057D47C(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019E4CB8;
  a2[1] = v2;
  return result;
}

__n128 sub_10057D4A8(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  xpc::dyn_cast_or_default();
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  __n128 result = v3;
  *(void *)(v1 + 16) = v4;
  *(__n128 *)uint64_t v1 = v3;
  return result;
}

void sub_10057D51C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10057D538(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10057D578()
{
}

void *sub_10057D584(void *a1, void *a2, unsigned int a3, NSObject **a4, uint64_t a5)
{
  xpc_object_t v9 = *a4;
  dispatch_object_t object = v9;
  if (v9) {
    dispatch_retain(v9);
  }
  sub_1007C1200((uint64_t)a1, a2, a3, &object, a5);
  if (object) {
    dispatch_release(object);
  }
  *a1 = &off_1019E4D38;
  return a1;
}

void sub_10057D614(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object)
{
  if (object) {
    dispatch_release(object);
  }
  _Unwind_Resume(exception_object);
}

void sub_10057D630(uint64_t a1)
{
  sub_1007C13D8(a1);

  operator delete();
}

void sub_10057D668(uint64_t a1)
{
  uint64_t v1 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
  {
    int v2 = 136315138;
    __n128 v3 = "setProtocolAvailable";
    _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "#I %s: start", (uint8_t *)&v2, 0xCu);
  }
}

void sub_10057D708(uint64_t a1)
{
  uint64_t v1 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
  {
    int v2 = 136315138;
    __n128 v3 = "getStatistics";
    _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "#I %s: start", (uint8_t *)&v2, 0xCu);
  }
}

void sub_10057D7A8(uint64_t a1)
{
  uint64_t v1 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
  {
    int v2 = 136315138;
    __n128 v3 = "goOffline";
    _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "#I %s: start", (uint8_t *)&v2, 0xCu);
  }
}

uint64_t sub_10057D848(uint64_t a1, void *a2, int a3)
{
  long long v6 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    int v12 = 136315394;
    v13 = "goOnline";
    __int16 v14 = 1024;
    int v15 = a3;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I %s: IPv4v6ServiceUp to be fired ipFamily=%d", (uint8_t *)&v12, 0x12u);
  }
  if (a3 == 1)
  {
    uint64_t v9 = *(void *)(a1 + 88);
    uint64_t v10 = (*(uint64_t (**)(void, uint64_t))(*(void *)*a2 + 96))(*a2, 1);
    (*(void (**)(uint64_t, uint64_t))(*(void *)v9 + 104))(v9, v10);
  }
  else if (a3 == 2)
  {
    uint64_t v7 = *(void *)(a1 + 88);
    uint64_t v8 = (*(uint64_t (**)(void, uint64_t))(*(void *)*a2 + 96))(*a2, 2);
    (*(void (**)(uint64_t, uint64_t))(*(void *)v7 + 96))(v7, v8);
  }
  return 1;
}

uint64_t sub_10057D9D8(uint64_t a1)
{
  uint64_t v1 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
  {
    int v3 = 136315138;
    uint64_t v4 = "refreshDNS";
    _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "#I %s: start", (uint8_t *)&v3, 0xCu);
  }
  return 1;
}

uint64_t sub_10057DA7C@<X0>(void *a1@<X8>)
{
  uint64_t v16 = 0;
  long long v14 = 0u;
  long long v15 = 0u;
  long long v12 = 0u;
  long long v13 = 0u;
  long long v10 = 0u;
  long long v11 = 0u;
  long long v8 = 0u;
  long long v9 = 0u;
  long long v6 = 0u;
  long long v7 = 0u;
  *(_OWORD *)__p = 0u;
  long long v5 = 0u;
  memset(v3, 0, sizeof(v3));
  sub_10004DE24((uint64_t)v3);
  sub_10004B96C(v3, (uint64_t)"ipsec", 5);
  std::ostream::operator<<();
  sub_10004BC98((uint64_t)v3 + 8, a1);
  if (SHIBYTE(v5) < 0) {
    operator delete(__p[1]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return std::ios::~ios();
}

void sub_10057DBEC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_10057DC00(uint64_t a1@<X0>, CSIPacketAddress *a2@<X8>)
{
  int v3 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    int v4 = 136315138;
    long long v5 = "getContextAddress";
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I %s: start", (uint8_t *)&v4, 0xCu);
  }
  CSIPacketAddress::CSIPacketAddress(a2);
}

void sub_10057DCAC(uint64_t a1@<X0>, CSIPacketAddress *a2@<X8>)
{
  int v3 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    int v4 = 136315138;
    long long v5 = "getInterfaceAddress";
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I %s: start", (uint8_t *)&v4, 0xCu);
  }
  CSIPacketAddress::CSIPacketAddress(a2);
}

uint64_t sub_10057DD58(uint64_t a1)
{
  uint64_t v1 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
  {
    int v3 = 136315138;
    int v4 = "refreshIPv4";
    _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "#I %s: start", (uint8_t *)&v3, 0xCu);
  }
  return 1;
}

uint64_t sub_10057DDFC(uint64_t a1)
{
  uint64_t v1 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
  {
    int v3 = 136315138;
    int v4 = "refreshIPv6";
    _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "#I %s: start", (uint8_t *)&v3, 0xCu);
  }
  return 1;
}

const void **sub_10057DEAC@<X0>(uint64_t a1@<X0>, char *a2@<X8>)
{
  *(void *)a2 = 0;
  xpc_object_t v4 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v5 = v4;
  if (v4)
  {
    *(void *)a2 = v4;
  }
  else
  {
    xpc_object_t v5 = xpc_null_create();
    *(void *)a2 = v5;
    if (!v5)
    {
      xpc_object_t v6 = xpc_null_create();
      xpc_object_t v5 = 0;
      goto LABEL_8;
    }
  }
  if (xpc_get_type(v5) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v5);
    goto LABEL_9;
  }
  xpc_object_t v6 = xpc_null_create();
LABEL_8:
  *(void *)a2 = v6;
LABEL_9:
  xpc_release(v5);
  CFStringRef v98 = 0;
  CFStringRef v98 = CFUUIDCreateString(kCFAllocatorDefault, *(CFUUIDRef *)a1);
  __p[1] = 0;
  __p[0] = 0;
  uint64_t v97 = 0;
  ctu::cf::assign();
  xpc_object_t v94 = xpc_string_create((const char *)__p);
  if (!v94) {
    xpc_object_t v94 = xpc_null_create();
  }
  v101 = a2;
  v102 = "kUuid";
  sub_100035E70((uint64_t)&v101, &v94, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(v94);
  xpc_object_t v94 = 0;
  int StartTime = CallInfo::getStartTime((CallInfo *)a1);
  xpc_object_t v92 = xpc_int64_create(StartTime);
  if (!v92) {
    xpc_object_t v92 = xpc_null_create();
  }
  v101 = a2;
  v102 = "kCallStartTime";
  sub_100035E70((uint64_t)&v101, &v92, &v93);
  xpc_release(v93);
  xpc_object_t v93 = 0;
  xpc_release(v92);
  xpc_object_t v92 = 0;
  unsigned int Duration = CallInfo::getDuration((CallInfo *)a1);
  xpc_object_t v90 = xpc_int64_create(Duration);
  if (!v90) {
    xpc_object_t v90 = xpc_null_create();
  }
  v101 = a2;
  v102 = "kCallDuration";
  sub_100035E70((uint64_t)&v101, &v90, &v91);
  xpc_release(v91);
  xpc_object_t v91 = 0;
  xpc_release(v90);
  xpc_object_t v90 = 0;
  unsigned int LegacyFlags = CallInfo::getLegacyFlags((CallInfo *)a1);
  xpc_object_t v88 = xpc_int64_create(LegacyFlags);
  if (!v88) {
    xpc_object_t v88 = xpc_null_create();
  }
  v101 = a2;
  v102 = "kCallFlags";
  sub_100035E70((uint64_t)&v101, &v88, &v89);
  xpc_release(v89);
  xpc_object_t v89 = 0;
  xpc_release(v88);
  xpc_object_t v88 = 0;
  Sessionint StartTime = CallInfo::getSessionStartTime((CallInfo *)a1);
  xpc_object_t v86 = xpc_int64_create(SessionStartTime);
  if (!v86) {
    xpc_object_t v86 = xpc_null_create();
  }
  v101 = a2;
  v102 = "kCallSessionStart";
  sub_100035E70((uint64_t)&v101, &v86, &v87);
  xpc_release(v87);
  xpc_object_t v87 = 0;
  xpc_release(v86);
  xpc_object_t v86 = 0;
  xpc_object_t v84 = xpc_int64_create(*(unsigned __int16 *)(a1 + 116));
  if (!v84) {
    xpc_object_t v84 = xpc_null_create();
  }
  v101 = a2;
  v102 = "kBBCallDisconnectCause";
  sub_100035E70((uint64_t)&v101, &v84, &v85);
  xpc_release(v85);
  xpc_object_t v85 = 0;
  xpc_release(v84);
  xpc_object_t v84 = 0;
  if (*(char *)(a1 + 55) >= 0) {
    long long v11 = (const char *)(a1 + 32);
  }
  else {
    long long v11 = *(const char **)(a1 + 32);
  }
  xpc_object_t v82 = xpc_string_create(v11);
  if (!v82) {
    xpc_object_t v82 = xpc_null_create();
  }
  v101 = a2;
  v102 = "kPhoneNumber";
  sub_100035E70((uint64_t)&v101, &v82, &v83);
  xpc_release(v83);
  xpc_object_t v83 = 0;
  xpc_release(v82);
  xpc_object_t v82 = 0;
  if (*(char *)(a1 + 31) >= 0) {
    long long v12 = (const char *)(a1 + 8);
  }
  else {
    long long v12 = *(const char **)(a1 + 8);
  }
  xpc_object_t v80 = xpc_string_create(v12);
  if (!v80) {
    xpc_object_t v80 = xpc_null_create();
  }
  v101 = a2;
  v102 = "kCallName";
  sub_100035E70((uint64_t)&v101, &v80, &v81);
  xpc_release(v81);
  xpc_object_t v81 = 0;
  xpc_release(v80);
  xpc_object_t v80 = 0;
  if (*(char *)(a1 + 151) >= 0) {
    long long v13 = (const char *)(a1 + 128);
  }
  else {
    long long v13 = *(const char **)(a1 + 128);
  }
  xpc_object_t v78 = xpc_string_create(v13);
  if (!v78) {
    xpc_object_t v78 = xpc_null_create();
  }
  v101 = a2;
  v102 = "kSource";
  sub_100035E70((uint64_t)&v101, &v78, &v79);
  xpc_release(v79);
  xpc_object_t v79 = 0;
  xpc_release(v78);
  xpc_object_t v78 = 0;
  xpc_object_t v76 = xpc_int64_create(*(unsigned int *)(a1 + 184));
  if (!v76) {
    xpc_object_t v76 = xpc_null_create();
  }
  v101 = a2;
  v102 = "kCallSourceMode";
  sub_100035E70((uint64_t)&v101, &v76, &v77);
  xpc_release(v77);
  xpc_object_t v77 = 0;
  xpc_release(v76);
  xpc_object_t v76 = 0;
  xpc_object_t v74 = xpc_int64_create(*(int *)(a1 + 152));
  if (!v74) {
    xpc_object_t v74 = xpc_null_create();
  }
  v101 = a2;
  v102 = "kMobileCountryCode";
  sub_100035E70((uint64_t)&v101, &v74, &v75);
  xpc_release(v75);
  xpc_object_t v75 = 0;
  xpc_release(v74);
  xpc_object_t v74 = 0;
  if (*(char *)(a1 + 183) >= 0) {
    long long v14 = (const char *)(a1 + 160);
  }
  else {
    long long v14 = *(const char **)(a1 + 160);
  }
  xpc_object_t v72 = xpc_string_create(v14);
  if (!v72) {
    xpc_object_t v72 = xpc_null_create();
  }
  v101 = a2;
  v102 = "kISOCountryCode";
  sub_100035E70((uint64_t)&v101, &v72, &v73);
  xpc_release(v73);
  xpc_object_t v73 = 0;
  xpc_release(v72);
  xpc_object_t v72 = 0;
  xpc_object_t v70 = xpc_BOOL_create(*(unsigned char *)(a1 + 189) == 1);
  if (!v70) {
    xpc_object_t v70 = xpc_null_create();
  }
  v101 = a2;
  v102 = "kAudioToneRelayFlag";
  sub_100035E70((uint64_t)&v101, &v70, &v71);
  xpc_release(v71);
  xpc_object_t v71 = 0;
  xpc_release(v70);
  xpc_object_t v70 = 0;
  xpc_object_t v68 = xpc_int64_create(*(unsigned int *)(a1 + 192));
  if (!v68) {
    xpc_object_t v68 = xpc_null_create();
  }
  v101 = a2;
  v102 = "kAudioToneStandard";
  sub_100035E70((uint64_t)&v101, &v68, &v69);
  xpc_release(v69);
  xpc_object_t v69 = 0;
  xpc_release(v68);
  xpc_object_t v68 = 0;
  xpc_object_t v66 = xpc_BOOL_create(*(unsigned char *)(a1 + 196));
  if (!v66) {
    xpc_object_t v66 = xpc_null_create();
  }
  v101 = a2;
  v102 = "kMobileOriginatedCallEndFlag";
  sub_100035E70((uint64_t)&v101, &v66, &v67);
  xpc_release(v67);
  xpc_object_t v67 = 0;
  xpc_release(v66);
  xpc_object_t v66 = 0;
  xpc_object_t v64 = xpc_BOOL_create(*(unsigned char *)(a1 + 197));
  if (!v64) {
    xpc_object_t v64 = xpc_null_create();
  }
  v101 = a2;
  v102 = "kClientNeedsToSetupAudioInterruptions";
  sub_100035E70((uint64_t)&v101, &v64, &v65);
  xpc_release(v65);
  xpc_object_t v65 = 0;
  xpc_release(v64);
  xpc_object_t v64 = 0;
  char v15 = CallInfo::isProbablyOnlyCall((CallInfo *)a1);
  xpc_object_t v62 = xpc_BOOL_create(v15);
  if (!v62) {
    xpc_object_t v62 = xpc_null_create();
  }
  v101 = a2;
  v102 = "kIsTheOnlyCall";
  sub_100035E70((uint64_t)&v101, &v62, &v63);
  xpc_release(v63);
  xpc_object_t v63 = 0;
  xpc_release(v62);
  xpc_object_t v62 = 0;
  xpc_object_t v60 = xpc_int64_create(*(unsigned int *)(a1 + 200));
  if (!v60) {
    xpc_object_t v60 = xpc_null_create();
  }
  v101 = a2;
  v102 = "kIsTTY";
  sub_100035E70((uint64_t)&v101, &v60, &v61);
  xpc_release(v61);
  xpc_object_t v61 = 0;
  xpc_release(v60);
  xpc_object_t v60 = 0;
  xpc_object_t v58 = xpc_BOOL_create(*(unsigned char *)(a1 + 188));
  if (!v58) {
    xpc_object_t v58 = xpc_null_create();
  }
  v101 = a2;
  v102 = "kIsThumperCall";
  sub_100035E70((uint64_t)&v101, &v58, &v59);
  xpc_release(v59);
  xpc_object_t v59 = 0;
  xpc_release(v58);
  xpc_object_t v58 = 0;
  if (*(unsigned char *)(a1 + 85)) {
    BOOL v16 = *(_DWORD *)(a1 + 56) == 1;
  }
  else {
    BOOL v16 = 1;
  }
  BOOL v17 = !v16;
  xpc_object_t v56 = xpc_BOOL_create(v17);
  if (!v56) {
    xpc_object_t v56 = xpc_null_create();
  }
  v101 = a2;
  v102 = "kIsSplitAllowed";
  sub_100035E70((uint64_t)&v101, &v56, &v57);
  xpc_release(v57);
  xpc_object_t v57 = 0;
  xpc_release(v56);
  xpc_object_t v56 = 0;
  if (*(unsigned char *)(a1 + 240))
  {
    xpc_object_t v18 = xpc_array_create(0, 0);
    if (v18 || (xpc_object_t v18 = xpc_null_create()) != 0)
    {
      if (xpc_get_type(v18) == (xpc_type_t)&_xpc_type_array)
      {
        xpc_retain(v18);
        xpc_object_t v19 = v18;
      }
      else
      {
        xpc_object_t v19 = xpc_null_create();
      }
    }
    else
    {
      xpc_object_t v19 = xpc_null_create();
      xpc_object_t v18 = 0;
    }
    xpc_release(v18);
    v20 = *(unsigned int **)(a1 + 216);
    v21 = *(unsigned int **)(a1 + 224);
    while (v20 != v21)
    {
      xpc_object_t v22 = xpc_int64_create(*v20);
      if (!v22) {
        xpc_object_t v22 = xpc_null_create();
      }
      xpc_array_append_value(v19, v22);
      xpc_release(v22);
      ++v20;
    }
    xpc_object_t v54 = v19;
    if (v19) {
      xpc_retain(v19);
    }
    else {
      xpc_object_t v54 = xpc_null_create();
    }
    v101 = a2;
    v102 = "kAudioStreamTokens";
    sub_10017AC14((uint64_t)&v101, &v54, &v55);
    xpc_release(v55);
    xpc_object_t v55 = 0;
    xpc_release(v54);
    xpc_object_t v54 = 0;
    xpc_release(v19);
  }
  if (*(unsigned char *)(a1 + 208))
  {
    xpc_object_t v52 = xpc_int64_create(*(unsigned int *)(a1 + 204));
    if (!v52) {
      xpc_object_t v52 = xpc_null_create();
    }
    v101 = a2;
    v102 = "kTextStreamToken";
    sub_100035E70((uint64_t)&v101, &v52, &v53);
    xpc_release(v53);
    xpc_object_t v53 = 0;
    xpc_release(v52);
    xpc_object_t v52 = 0;
    xpc_object_t v50 = xpc_BOOL_create(0);
    if (!v50) {
      xpc_object_t v50 = xpc_null_create();
    }
    v101 = a2;
    v102 = "kIsTextHeldForRTTCall";
    sub_100035E70((uint64_t)&v101, &v50, &v51);
    xpc_release(v51);
    xpc_object_t v51 = 0;
    xpc_release(v50);
    xpc_object_t v50 = 0;
  }
  if (*(unsigned char *)(a1 + 249))
  {
    xpc_object_t v48 = xpc_BOOL_create(*(unsigned char *)(a1 + 248));
    if (!v48) {
      xpc_object_t v48 = xpc_null_create();
    }
    v101 = a2;
    v102 = "kIsTextHeldForRTTCall";
    sub_100035E70((uint64_t)&v101, &v48, &v49);
    xpc_release(v49);
    xpc_object_t v49 = 0;
    xpc_release(v48);
    xpc_object_t v48 = 0;
  }
  xpc_object_t v46 = xpc_BOOL_create(*(unsigned char *)(a1 + 256));
  if (!v46) {
    xpc_object_t v46 = xpc_null_create();
  }
  v101 = a2;
  v102 = "kVerstatEnabled";
  sub_100035E70((uint64_t)&v101, &v46, &v47);
  xpc_release(v47);
  xpc_object_t v47 = 0;
  xpc_release(v46);
  xpc_object_t v46 = 0;
  xpc_object_t v44 = xpc_int64_create(*(unsigned int *)(a1 + 260));
  if (!v44) {
    xpc_object_t v44 = xpc_null_create();
  }
  v101 = a2;
  v102 = "kVerstatLevel";
  sub_100035E70((uint64_t)&v101, &v44, &v45);
  xpc_release(v45);
  xpc_object_t v45 = 0;
  xpc_release(v44);
  xpc_object_t v44 = 0;
  if (*(char *)(a1 + 319) >= 0) {
    v23 = (const char *)(a1 + 296);
  }
  else {
    v23 = *(const char **)(a1 + 296);
  }
  xpc_object_t v42 = xpc_string_create(v23);
  if (!v42) {
    xpc_object_t v42 = xpc_null_create();
  }
  v101 = a2;
  v102 = "kImagePath";
  sub_100035E70((uint64_t)&v101, &v42, &v43);
  xpc_release(v43);
  xpc_object_t v43 = 0;
  xpc_release(v42);
  xpc_object_t v42 = 0;
  xpc_object_t v40 = xpc_BOOL_create(*(unsigned char *)(a1 + 332));
  if (!v40) {
    xpc_object_t v40 = xpc_null_create();
  }
  v101 = a2;
  v102 = "kPendingInfoInitialization";
  sub_100035E70((uint64_t)&v101, &v40, &v41);
  xpc_release(v41);
  xpc_object_t v41 = 0;
  xpc_release(v40);
  xpc_object_t v40 = 0;
  xpc_object_t v38 = xpc_int64_create(*(int *)(a1 + 320));
  if (!v38) {
    xpc_object_t v38 = xpc_null_create();
  }
  v101 = a2;
  v102 = "kSpamRisk";
  sub_100035E70((uint64_t)&v101, &v38, &v39);
  xpc_release(v39);
  xpc_object_t v39 = 0;
  xpc_release(v38);
  xpc_object_t v38 = 0;
  xpc_object_t v36 = xpc_int64_create(*(int *)(a1 + 324));
  if (!v36) {
    xpc_object_t v36 = xpc_null_create();
  }
  v101 = a2;
  v102 = "kSpamCategory";
  sub_100035E70((uint64_t)&v101, &v36, &v37);
  xpc_release(v37);
  xpc_object_t v37 = 0;
  xpc_release(v36);
  xpc_object_t v36 = 0;
  xpc_object_t v34 = xpc_int64_create(*(unsigned __int8 *)(a1 + 328));
  if (!v34) {
    xpc_object_t v34 = xpc_null_create();
  }
  v101 = a2;
  v102 = "CallLikelyToFail";
  sub_100035E70((uint64_t)&v101, &v34, &v35);
  xpc_release(v35);
  xpc_object_t v35 = 0;
  xpc_release(v34);
  xpc_object_t v34 = 0;
  xpc_object_t v32 = xpc_int64_create(*(unsigned __int8 *)(a1 + 329));
  if (!v32) {
    xpc_object_t v32 = xpc_null_create();
  }
  v101 = a2;
  v102 = "kSupportsEmergencyFallback";
  sub_100035E70((uint64_t)&v101, &v32, &v33);
  xpc_release(v33);
  xpc_object_t v33 = 0;
  xpc_release(v32);
  xpc_object_t v32 = 0;
  xpc_object_t v30 = xpc_int64_create(*(int *)(a1 + 252));
  if (!v30) {
    xpc_object_t v30 = xpc_null_create();
  }
  v101 = a2;
  v102 = "kCallSimSlot";
  sub_100035E70((uint64_t)&v101, &v30, &v31);
  xpc_release(v31);
  xpc_object_t v31 = 0;
  xpc_release(v30);
  xpc_object_t v30 = 0;
  xpc_object_t v120 = xpc_BOOL_create(*(_DWORD *)(a1 + 72) != 2);
  if (!v120) {
    xpc_object_t v120 = xpc_null_create();
  }
  v101 = a2;
  v102 = "kCallDirectionMobileOriginated";
  sub_100035E70((uint64_t)&v101, &v120, &v121);
  xpc_release(v121);
  xpc_object_t v121 = 0;
  xpc_release(v120);
  xpc_object_t v120 = 0;
  xpc_object_t v118 = xpc_int64_create(*(int *)(a1 + 56));
  if (!v118) {
    xpc_object_t v118 = xpc_null_create();
  }
  v101 = a2;
  v102 = "kCallStatus";
  sub_100035E70((uint64_t)&v101, &v118, &v119);
  xpc_release(v119);
  xpc_object_t v119 = 0;
  xpc_release(v118);
  xpc_object_t v118 = 0;
  xpc_object_t v116 = xpc_int64_create(*(unsigned int *)(a1 + 80));
  if (!v116) {
    xpc_object_t v116 = xpc_null_create();
  }
  v101 = a2;
  v102 = "kCallerIdAvailability";
  sub_100035E70((uint64_t)&v101, &v116, &v117);
  xpc_release(v117);
  xpc_object_t v117 = 0;
  xpc_release(v116);
  xpc_object_t v116 = 0;
  xpc_object_t v114 = xpc_BOOL_create(*(unsigned char *)(a1 + 85));
  if (!v114) {
    xpc_object_t v114 = xpc_null_create();
  }
  v101 = a2;
  v102 = "kIsInMultiParty";
  sub_100035E70((uint64_t)&v101, &v114, &v115);
  xpc_release(v115);
  xpc_object_t v115 = 0;
  xpc_release(v114);
  xpc_object_t v114 = 0;
  xpc_object_t v112 = xpc_int64_create(*(int *)(a1 + 64));
  if (!v112) {
    xpc_object_t v112 = xpc_null_create();
  }
  v101 = a2;
  v102 = "kCallType";
  sub_100035E70((uint64_t)&v101, &v112, &v113);
  xpc_release(v113);
  xpc_object_t v113 = 0;
  xpc_release(v112);
  xpc_object_t v112 = 0;
  xpc_object_t v110 = xpc_BOOL_create(*(unsigned char *)(a1 + 87));
  if (!v110) {
    xpc_object_t v110 = xpc_null_create();
  }
  v101 = a2;
  v102 = "kCallListedAsEmergency";
  sub_100035E70((uint64_t)&v101, &v110, &v111);
  xpc_release(v111);
  xpc_object_t v111 = 0;
  xpc_release(v110);
  xpc_object_t v110 = 0;
  char isSuspicious380Redirect = CallInfo::isSuspicious380Redirect((CallInfo *)a1);
  xpc_object_t v108 = xpc_BOOL_create(isSuspicious380Redirect);
  if (!v108) {
    xpc_object_t v108 = xpc_null_create();
  }
  v101 = a2;
  v102 = "kSuspicious380Redirect";
  sub_100035E70((uint64_t)&v101, &v108, &v109);
  xpc_release(v109);
  xpc_object_t v109 = 0;
  xpc_release(v108);
  xpc_object_t v108 = 0;
  int CCDisconnectErrorCode = CallInfo::getCCDisconnectErrorCode((CallInfo *)a1);
  xpc_object_t v106 = xpc_int64_create(CCDisconnectErrorCode);
  if (!v106) {
    xpc_object_t v106 = xpc_null_create();
  }
  v101 = a2;
  v102 = "kDisconnectCauseCode";
  sub_100035E70((uint64_t)&v101, &v106, &v107);
  xpc_release(v107);
  xpc_object_t v107 = 0;
  xpc_release(v106);
  xpc_object_t v106 = 0;
  asExternalCSIErrorString();
  if (v103 >= 0) {
    v26 = (const char *)&v101;
  }
  else {
    v26 = v101;
  }
  xpc_object_t v104 = xpc_string_create(v26);
  if (!v104) {
    xpc_object_t v104 = xpc_null_create();
  }
  v100[0] = a2;
  v100[1] = "kDisconnectCauseCodeString";
  sub_100035E70((uint64_t)v100, &v104, &v105);
  xpc_release(v105);
  xpc_object_t v105 = 0;
  xpc_release(v104);
  xpc_object_t v104 = 0;
  if (v103 < 0) {
    operator delete(v101);
  }
  xpc_object_t v99 = xpc_int64_create(*(unsigned __int8 *)(a1 + 68));
  if (!v99) {
    xpc_object_t v99 = xpc_null_create();
  }
  v101 = a2;
  v102 = "kCallSubType";
  sub_100035E70((uint64_t)&v101, &v99, v100);
  xpc_release(v100[0]);
  v100[0] = 0;
  xpc_release(v99);
  xpc_object_t v28 = xpc_BOOL_create(*(unsigned char *)(a1 + 331));
  if (!v28) {
    xpc_object_t v28 = xpc_null_create();
  }
  v101 = a2;
  v102 = "kEmSubSwitchAudioOverride";
  sub_100035E70((uint64_t)&v101, &v28, &v29);
  xpc_release(v29);
  xpc_object_t v29 = 0;
  xpc_release(v28);
  xpc_object_t v28 = 0;
  if (SHIBYTE(v97) < 0) {
    operator delete(__p[0]);
  }
  return sub_1000558F4((const void **)&v98);
}

void sub_10057F130(_Unwind_Exception *a1)
{
  sub_10017143C(v1);
  _Unwind_Resume(a1);
}

void sub_10057F1A4(uint64_t a1@<X0>, void *a2@<X8>)
{
  *a2 = 0;
  xpc_object_t v4 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v5 = v4;
  if (v4)
  {
    *a2 = v4;
  }
  else
  {
    xpc_object_t v5 = xpc_null_create();
    *a2 = v5;
    if (!v5)
    {
      xpc_object_t v6 = xpc_null_create();
      xpc_object_t v5 = 0;
      goto LABEL_8;
    }
  }
  if (xpc_get_type(v5) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v5);
    goto LABEL_9;
  }
  xpc_object_t v6 = xpc_null_create();
LABEL_8:
  *a2 = v6;
LABEL_9:
  xpc_release(v5);
  if (*(char *)(a1 + 23) >= 0) {
    long long v7 = (const char *)a1;
  }
  else {
    long long v7 = *(const char **)a1;
  }
  xpc_object_t v33 = xpc_string_create(v7);
  if (!v33) {
    xpc_object_t v33 = xpc_null_create();
  }
  xpc_object_t v31 = a2;
  xpc_object_t v32 = "kUuid";
  sub_100035E70((uint64_t)&v31, &v33, &v34);
  xpc_release(v34);
  xpc_object_t v34 = 0;
  xpc_release(v33);
  xpc_object_t v33 = 0;
  xpc_object_t v29 = xpc_BOOL_create(1);
  if (!v29) {
    xpc_object_t v29 = xpc_null_create();
  }
  xpc_object_t v31 = a2;
  xpc_object_t v32 = "kCallDirectionMobileOriginated";
  sub_100035E70((uint64_t)&v31, &v29, &v30);
  xpc_release(v30);
  xpc_object_t v30 = 0;
  xpc_release(v29);
  xpc_object_t v29 = 0;
  xpc_object_t v27 = xpc_int64_create(9);
  if (!v27) {
    xpc_object_t v27 = xpc_null_create();
  }
  xpc_object_t v31 = a2;
  xpc_object_t v32 = "kCallStatus";
  sub_100035E70((uint64_t)&v31, &v27, &v28);
  xpc_release(v28);
  xpc_object_t v28 = 0;
  xpc_release(v27);
  xpc_object_t v27 = 0;
  if (*(char *)(a1 + 47) >= 0) {
    long long v8 = (const char *)(a1 + 24);
  }
  else {
    long long v8 = *(const char **)(a1 + 24);
  }
  xpc_object_t v25 = xpc_string_create(v8);
  if (!v25) {
    xpc_object_t v25 = xpc_null_create();
  }
  xpc_object_t v31 = a2;
  xpc_object_t v32 = "kPhoneNumber";
  sub_100035E70((uint64_t)&v31, &v25, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(v25);
  xpc_object_t v25 = 0;
  if (*(unsigned char *)(a1 + 95)) {
    BOOL v9 = *(unsigned char *)(a1 + 92) == 0;
  }
  else {
    BOOL v9 = 1;
  }
  if (v9) {
    int64_t v10 = 1;
  }
  else {
    int64_t v10 = 2;
  }
  xpc_object_t v23 = xpc_int64_create(v10);
  if (!v23) {
    xpc_object_t v23 = xpc_null_create();
  }
  xpc_object_t v31 = a2;
  xpc_object_t v32 = "kCallType";
  sub_100035E70((uint64_t)&v31, &v23, &v24);
  xpc_release(v24);
  xpc_object_t v24 = 0;
  xpc_release(v23);
  xpc_object_t v23 = 0;
  if (*(unsigned char *)(a1 + 92)) {
    BOOL v11 = *(unsigned char *)(a1 + 95) == 0;
  }
  else {
    BOOL v11 = 0;
  }
  BOOL v12 = v11;
  xpc_object_t v21 = xpc_BOOL_create(v12);
  if (!v21) {
    xpc_object_t v21 = xpc_null_create();
  }
  xpc_object_t v31 = a2;
  xpc_object_t v32 = "kCallListedAsEmergency";
  sub_100035E70((uint64_t)&v31, &v21, &v22);
  xpc_release(v22);
  xpc_object_t v22 = 0;
  xpc_release(v21);
  xpc_object_t v21 = 0;
  xpc_object_t v19 = xpc_BOOL_create(*(unsigned char *)(a1 + 93));
  if (!v19) {
    xpc_object_t v19 = xpc_null_create();
  }
  xpc_object_t v31 = a2;
  xpc_object_t v32 = "CallLikelyToFail";
  sub_100035E70((uint64_t)&v31, &v19, &v20);
  xpc_release(v20);
  xpc_object_t v20 = 0;
  xpc_release(v19);
  xpc_object_t v19 = 0;
  xpc_object_t v17 = xpc_BOOL_create(*(unsigned char *)(a1 + 94));
  if (!v17) {
    xpc_object_t v17 = xpc_null_create();
  }
  xpc_object_t v31 = a2;
  xpc_object_t v32 = "kSupportsEmergencyFallback";
  sub_100035E70((uint64_t)&v31, &v17, &v18);
  xpc_release(v18);
  xpc_object_t v18 = 0;
  xpc_release(v17);
  xpc_object_t v17 = 0;
  xpc_object_t v15 = xpc_int64_create(*(int *)(a1 + 88));
  if (!v15) {
    xpc_object_t v15 = xpc_null_create();
  }
  xpc_object_t v31 = a2;
  xpc_object_t v32 = "kCallSimSlot";
  sub_100035E70((uint64_t)&v31, &v15, &v16);
  xpc_release(v16);
  xpc_object_t v16 = 0;
  xpc_release(v15);
  xpc_object_t v15 = 0;
  xpc_object_t v13 = xpc_int64_create(16);
  if (!v13) {
    xpc_object_t v13 = xpc_null_create();
  }
  xpc_object_t v31 = a2;
  xpc_object_t v32 = "kCallSubType";
  sub_100035E70((uint64_t)&v31, &v13, &v14);
  xpc_release(v14);
  xpc_object_t v14 = 0;
  xpc_release(v13);
}

uint64_t sub_10057F630(uint64_t a1)
{
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  sub_100058DB0((void *)(a1 + 32), kCallerIdDefaultValue);
  *(_DWORD *)(a1 + 56) = 9;
  *(unsigned char *)(a1 + 60) = 0;
  *(_DWORD *)(a1 + 64) = 1;
  *(unsigned char *)(a1 + 68) = 1;
  *(void *)(a1 + 72) = 0x400000001;
  *(void *)(a1 + 80) = 2;
  *(unsigned char *)(a1 + 88) = 0;
  *(_DWORD *)(a1 + 92) = CallInfo::kDefaultCallId;
  *(unsigned char *)(a1 + 120) = 0;
  *(unsigned char *)(a1 + 124) = 0;
  *(void *)(a1 + 96) = 0;
  *(void *)(a1 + 104) = 0;
  *(void *)(a1 + 110) = 0;
  sub_100058DB0((void *)(a1 + 128), "");
  *(_DWORD *)(a1 + 152) = 0;
  sub_100058DB0((void *)(a1 + 160), "");
  *(_DWORD *)(a1 + 184) = 0;
  *(_WORD *)(a1 + 188) = 0;
  *(_DWORD *)(a1 + 192) = 0;
  *(_WORD *)(a1 + 196) = 0;
  *(_DWORD *)(a1 + 200) = 0;
  *(unsigned char *)(a1 + 204) = 0;
  *(unsigned char *)(a1 + 208) = 0;
  *(unsigned char *)(a1 + 216) = 0;
  *(unsigned char *)(a1 + 240) = 0;
  *(_WORD *)(a1 + 248) = 0;
  *(_DWORD *)(a1 + 252) = 1;
  *(unsigned char *)(a1 + 256) = 0;
  *(_DWORD *)(a1 + 260) = 0;
  *(unsigned char *)(a1 + 264) = 0;
  *(unsigned char *)(a1 + 384) = 0;
  *(unsigned char *)(a1 + 392) = 0;
  *(unsigned char *)(a1 + 404) = 0;
  *(unsigned char *)(a1 + 336) = 0;
  *(_OWORD *)(a1 + 304) = 0u;
  *(_OWORD *)(a1 + 320) = 0u;
  *(_OWORD *)(a1 + 272) = 0u;
  *(_OWORD *)(a1 + 288) = 0u;
  return a1;
}

void sub_10057F74C(_Unwind_Exception *a1)
{
  if (*(char *)(v1 + 151) < 0) {
    operator delete(*v3);
  }
  if (*(char *)(v1 + 55) < 0) {
    operator delete(*v2);
  }
  if (*(char *)(v1 + 31) < 0) {
    operator delete(*(void **)(v1 + 8));
  }
  sub_10012577C((const void **)v1);
  _Unwind_Resume(a1);
}

uint64_t sub_10057F7A0(uint64_t a1, const char *a2)
{
  if (!a2) {
    return 0;
  }
  CFStringRef v2 = CFStringCreateWithCString(kCFAllocatorDefault, a2, 0x8000100u);
  if (!v2) {
    return 0;
  }
  CFStringRef v3 = v2;
  CFURLRef v4 = CFURLCreateWithFileSystemPath(kCFAllocatorDefault, v2, kCFURLPOSIXPathStyle, 1u);
  if (v4)
  {
    CFURLRef v5 = v4;
    uint64_t Unique = _CFBundleCreateUnique();
    CFRelease(v3);
    CFStringRef v3 = (const __CFString *)v5;
  }
  else
  {
    uint64_t Unique = 0;
  }
  CFRelease(v3);
  return Unique;
}

CFTypeRef sub_10057F840(uint64_t a1, const char *a2)
{
  if (!a2) {
    return 0;
  }
  CFStringRef v2 = (__CFBundle *)sub_10057F7A0(a1, a2);
  if (!v2) {
    return 0;
  }
  CFStringRef v3 = v2;
  CFTypeRef ValueForInfoDictionaryKey = CFBundleGetValueForInfoDictionaryKey(v2, kCFBundleIdentifierKey);
  if (ValueForInfoDictionaryKey)
  {
    CFTypeID TypeID = CFStringGetTypeID();
    if (TypeID == CFGetTypeID(ValueForInfoDictionaryKey)) {
      CFRetain(ValueForInfoDictionaryKey);
    }
    else {
      CFTypeRef ValueForInfoDictionaryKey = 0;
    }
  }
  CFRelease(v3);
  return ValueForInfoDictionaryKey;
}

CFTypeRef sub_10057F8C8(uint64_t a1, const char *a2)
{
  if (!a2) {
    return 0;
  }
  CFStringRef v2 = (__CFBundle *)sub_10057F7A0(a1, a2);
  if (!v2) {
    return 0;
  }
  CFStringRef v3 = v2;
  CFTypeRef ValueForInfoDictionaryKey = CFBundleGetValueForInfoDictionaryKey(v2, @"CFBundleDeviceFamily");
  if (ValueForInfoDictionaryKey)
  {
    CFTypeID TypeID = CFStringGetTypeID();
    if (TypeID == CFGetTypeID(ValueForInfoDictionaryKey)) {
      CFRetain(ValueForInfoDictionaryKey);
    }
    else {
      CFTypeRef ValueForInfoDictionaryKey = 0;
    }
  }
  CFRelease(v3);
  return ValueForInfoDictionaryKey;
}

CFTypeRef sub_10057F94C(uint64_t a1, const char *a2)
{
  int v3 = 5;
  while (1)
  {
    CFURLRef v4 = (__CFBundle *)sub_10057F7A0(a1, a2);
    if (!v4) {
      return 0;
    }
    CFURLRef v5 = v4;
    CFTypeRef ValueForInfoDictionaryKey = CFBundleGetValueForInfoDictionaryKey(v4, kCFBundleVersionKey);
    if (ValueForInfoDictionaryKey) {
      break;
    }
    CFRelease(v5);
    a1 = usleep(0x64u);
    if (!--v3) {
      return 0;
    }
  }
  CFTypeRef v7 = ValueForInfoDictionaryKey;
  CFRetain(ValueForInfoDictionaryKey);
  CFRelease(v5);
  return v7;
}

const void *sub_10057F9DC(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    for (int i = 5; i; --i)
    {
      uint64_t Unique = (__CFBundle *)_CFBundleCreateUnique();
      if (!Unique) {
        break;
      }
      CFURLRef v4 = Unique;
      CFTypeRef ValueForInfoDictionaryKey = CFBundleGetValueForInfoDictionaryKey(Unique, kCFBundleVersionKey);
      if (ValueForInfoDictionaryKey)
      {
        xpc_object_t v6 = ValueForInfoDictionaryKey;
        CFTypeID v7 = CFGetTypeID(ValueForInfoDictionaryKey);
        if (v7 == CFStringGetTypeID())
        {
          CFRetain(v6);
          CFRelease(v4);
          return v6;
        }
      }
      CFRelease(v4);
      usleep(0x64u);
    }
  }
  return 0;
}

const void **sub_10057FAA0@<X0>(const void **result@<X0>, const char *a2@<X1>, const void **a3@<X8>)
{
  *a3 = 0;
  if (a2)
  {
    __n128 result = (const void **)sub_10057F7A0((uint64_t)result, a2);
    CFURLRef v4 = result;
    if (result)
    {
      CFTypeRef ValueForInfoDictionaryKey = CFBundleGetValueForInfoDictionaryKey((CFBundleRef)result, @"CFBundleSettingsType");
      CFTypeRef cf = ValueForInfoDictionaryKey;
      if (ValueForInfoDictionaryKey)
      {
        xpc_object_t v6 = sub_100080934;
        CFRetain(ValueForInfoDictionaryKey);
      }
      else
      {
        xpc_object_t v6 = 0;
      }
      if (v6)
      {
        CFTypeID TypeID = CFStringGetTypeID();
        if (TypeID == CFGetTypeID(cf))
        {
          CFTypeRef v8 = cf;
          sub_100013168(a3, &v8);
        }
      }
      CFRelease(v4);
      return sub_1000577C4(&cf);
    }
  }
  return result;
}

void sub_10057FB68(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000577C4((const void **)va);
  sub_1000558F4(v2);
  _Unwind_Resume(a1);
}

const void **sub_10057FB98@<X0>(const void **result@<X0>, const char *a2@<X1>, const void **a3@<X8>)
{
  *a3 = 0;
  if (a2)
  {
    __n128 result = (const void **)sub_10057F7A0((uint64_t)result, a2);
    CFURLRef v4 = result;
    if (result)
    {
      CFTypeRef ValueForInfoDictionaryKey = CFBundleGetValueForInfoDictionaryKey((CFBundleRef)result, @"CFBundleCategory");
      CFTypeRef cf = ValueForInfoDictionaryKey;
      if (ValueForInfoDictionaryKey)
      {
        xpc_object_t v6 = sub_100080934;
        CFRetain(ValueForInfoDictionaryKey);
      }
      else
      {
        xpc_object_t v6 = 0;
      }
      if (v6)
      {
        CFTypeID TypeID = CFStringGetTypeID();
        if (TypeID == CFGetTypeID(cf))
        {
          CFTypeRef v8 = cf;
          sub_100013168(a3, &v8);
        }
      }
      CFRelease(v4);
      return sub_1000577C4(&cf);
    }
  }
  return result;
}

void sub_10057FC60(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000577C4((const void **)va);
  sub_1000558F4(v2);
  _Unwind_Resume(a1);
}

void sub_10057FC90(CFStringRef bundleID@<X1>, CFBundleRef *a2@<X8>)
{
  *a2 = 0;
  if (bundleID)
  {
    CFBundleRef BundleWithIdentifier = CFBundleGetBundleWithIdentifier(bundleID);
    CFBundleRef v4 = BundleWithIdentifier;
    if (BundleWithIdentifier) {
      CFRetain(BundleWithIdentifier);
    }
    *a2 = v4;
    CFURLRef v5 = 0;
    sub_100580138(&v5);
  }
}

void sub_10057FCEC(_Unwind_Exception *a1)
{
  sub_100580138(v1);
  _Unwind_Resume(a1);
}

void sub_10057FD00(CFBundleRef bundle@<X1>, CFURLRef *a2@<X8>)
{
  *a2 = 0;
  if (bundle)
  {
    *a2 = CFBundleCopyBundleURL(bundle);
    CFStringRef v2 = 0;
    sub_1000FE824(&v2);
  }
}

void sub_10057FD48(_Unwind_Exception *a1)
{
  sub_1000FE824(v1);
  _Unwind_Resume(a1);
}

void sub_10057FD5C(CFBundleRef bundle@<X2>, os_log_t *a2@<X1>, const __CFArray *a3@<X3>, const void **a4@<X8>)
{
  *a4 = 0;
  if (bundle)
  {
    CFStringRef Identifier = CFBundleGetIdentifier(bundle);
    CFArrayRef v9 = CFBundleCopyBundleLocalizations(bundle);
    CFArrayRef v23 = v9;
    if (v9) {
      int64_t v10 = sub_100083F10;
    }
    else {
      int64_t v10 = 0;
    }
    if (!v10)
    {
      xpc_object_t v18 = *a2;
      if (os_log_type_enabled(*a2, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 138543362;
        *(void *)&uint8_t buf[4] = Identifier;
        _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#E Failed to load the localizations present in bundle %{public}@", buf, 0xCu);
      }
      goto LABEL_32;
    }
    CFArrayRef v11 = CFBundleCopyLocalizationsForPreferences(v9, a3);
    CFArrayRef theArray = v11;
    if (v11) {
      BOOL v12 = sub_100083F10;
    }
    else {
      BOOL v12 = 0;
    }
    if (v12)
    {
      if (CFArrayGetCount(v11))
      {
        ValueAtIndex = CFArrayGetValueAtIndex(theArray, 0);
        xpc_object_t v14 = ValueAtIndex;
        if (ValueAtIndex)
        {
          CFTypeID v15 = CFGetTypeID(ValueAtIndex);
          if (v15 == CFStringGetTypeID()) {
            xpc_object_t v16 = v14;
          }
          else {
            xpc_object_t v16 = 0;
          }
        }
        else
        {
          xpc_object_t v16 = 0;
        }
        *(void *)buf = v16;
        sub_100013168(a4, (CFTypeRef *)buf);
        if (*a4) {
          xpc_object_t v21 = sub_1000810B8;
        }
        else {
          xpc_object_t v21 = 0;
        }
        if (v21) {
          goto LABEL_31;
        }
        xpc_object_t v19 = *a2;
        if (!os_log_type_enabled(*a2, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_31;
        }
        *(_DWORD *)buf = 138543362;
        *(void *)&uint8_t buf[4] = Identifier;
        xpc_object_t v20 = "#E First element in the preferred localization array for bundle %{public}@ is not a string";
        goto LABEL_30;
      }
      xpc_object_t v19 = *a2;
      if (os_log_type_enabled(*a2, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 138543362;
        *(void *)&uint8_t buf[4] = Identifier;
        xpc_object_t v20 = "#E Preferred localization array for bundle %{public}@ contains no elements";
        goto LABEL_30;
      }
    }
    else
    {
      xpc_object_t v19 = *a2;
      if (os_log_type_enabled(*a2, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 138543362;
        *(void *)&uint8_t buf[4] = Identifier;
        xpc_object_t v20 = "#E Failed to get the preferred localization bundle array in bundle %{public}@";
LABEL_30:
        _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, v20, buf, 0xCu);
      }
    }
LABEL_31:
    sub_100044D00((const void **)&theArray);
LABEL_32:
    sub_100044D00((const void **)&v23);
    return;
  }
  xpc_object_t v17 = *a2;
  if (os_log_type_enabled(*a2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#E No bundle provided", buf, 2u);
  }
}

void sub_10057FFF0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, const void *a10)
{
  sub_100044D00(&a9);
  sub_100044D00(&a10);
  sub_1000558F4(v10);
  _Unwind_Resume(a1);
}

void sub_10058002C(uint64_t a1@<X1>, uint64_t *a2@<X8>)
{
  *a2 = 0;
  if (a1)
  {
    *a2 = CFBundleCopyLocalizedStringForLocalization();
    CFStringRef v2 = 0;
    sub_1000558F4(&v2);
  }
}

void sub_100580084(_Unwind_Exception *a1)
{
  sub_1000558F4(v1);
  _Unwind_Resume(a1);
}

void sub_100580098(uint64_t a1@<X1>, uint64_t *a2@<X8>)
{
  *a2 = 0;
  if (a1)
  {
    *a2 = CFBundleCopyLocalizedStringTableForLocalization();
    CFStringRef v2 = 0;
    sub_100057D78(&v2);
  }
}

void sub_1005800E8(_Unwind_Exception *a1)
{
  sub_100057D78(v1);
  _Unwind_Resume(a1);
}

void sub_100580100(BundleUtilitiesInterface *a1)
{
  BundleUtilitiesInterface::~BundleUtilitiesInterface(a1);

  operator delete();
}

const void **sub_100580138(const void **a1)
{
  CFStringRef v2 = *a1;
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

void sub_10058016C(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_1005801D4(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100580210(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100580248(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_100580278(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

void sub_1005802BC(std::string *a1, int a2, uint64_t *a3, char *a4, uint64_t *a5)
{
  v18[0] = off_1019AF850;
  v18[1] = sub_100580730;
  v18[3] = v18;
  a1[8].__r_.__value_.__r.__words[2] = 0;
  if ((capabilities::ct::supportsGemini((capabilities::ct *)a1) & 1) == 0) {
    operator new();
  }
  if (!a1[8].__r_.__value_.__r.__words[2]) {
    operator new();
  }
  sub_10008863C(v18);
  uint64_t v10 = *a3;
  CFArrayRef v11 = (std::__shared_weak_count *)a3[1];
  v17[0] = v10;
  v17[1] = v11;
  if (v11) {
    atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  v16[0] = 0;
  v16[1] = 0;
  uint64_t v12 = *a5;
  xpc_object_t v13 = (std::__shared_weak_count *)a5[1];
  v15[0] = v12;
  v15[1] = v13;
  if (v13) {
    atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  sub_1005724C8((uint64_t)a1, a2, v17, v16, v15);
  if (v13) {
    sub_10004D2C8(v13);
  }
  if (v11) {
    sub_10004D2C8(v11);
  }
  a1->__r_.__value_.__r.__words[0] = (std::string::size_type)off_1019E5050;
  a1[9].__r_.__value_.__r.__words[0] = 0;
  a1->__r_.__value_.__l.__size_ = (std::string::size_type)off_1019E51B8;
  a1[9].__r_.__value_.__l.__size_ = 0;
  a1[9].__r_.__value_.__r.__words[2] = 0;
  xpc_object_t v14 = (std::__shared_weak_count *)a1[7].__r_.__value_.__r.__words[2];
  a1[7].__r_.__value_.__l.__size_ = 0;
  a1[7].__r_.__value_.__r.__words[2] = 0;
  if (v14) {
    sub_10004D2C8(v14);
  }
  sub_10003ED78(a1 + 9, a4);
  v18[4] = 0;
  v18[5] = 0;
  operator new();
}

void sub_100580634(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  sub_10008863C((uint64_t *)va);
  operator delete();
}

const char *sub_100580730(int a1)
{
  uint64_t v1 = "msg.mms.op.ack.?";
  if (a1 == 2) {
    uint64_t v1 = "msg.mms.op.ack.2";
  }
  if (a1 == 1) {
    return "msg.mms.op.ack.1";
  }
  else {
    return v1;
  }
}

uint64_t sub_10058075C(uint64_t a1)
{
  *(void *)a1 = off_1019E5050;
  *(void *)(a1 + 8) = off_1019E51B8;
  if (*(char *)(a1 + 239) < 0) {
    operator delete(*(void **)(a1 + 216));
  }
  sub_100572700(a1);
  uint64_t v2 = *(void *)(a1 + 208);
  *(void *)(a1 + 208) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  return a1;
}

uint64_t sub_100580808(uint64_t a1)
{
  return sub_10058075C(a1 - 8);
}

void sub_100580810(uint64_t a1)
{
  sub_10058075C(a1);

  operator delete();
}

void sub_100580848(uint64_t a1)
{
  sub_10058075C(a1 - 8);

  operator delete();
}

BOOL sub_100580884(uint64_t a1)
{
  if (!*(void *)(a1 + 144)) {
    return 0;
  }
  if (*(char *)(a1 + 239) < 0) {
    uint64_t v1 = *(void *)(a1 + 224);
  }
  else {
    uint64_t v1 = *(unsigned __int8 *)(a1 + 239);
  }
  return v1 != 0;
}

void sub_1005808B4(uint64_t a1)
{
  uint64_t v35 = 0;
  xpc_object_t v36 = 0;
  sub_1005725BC(a1, *(unsigned int *)(a1 + 48), &v35);
  if (!v35
    || !*(void *)(a1 + 160)
    || ((uint64_t v2 = (*(uint64_t (**)(uint64_t))(*(void *)v35 + 40))(v35),
         int v3 = *(char *)(v2 + 23),
         CFBundleRef v4 = *(const char **)v2,
         uint64_t v5 = (*(uint64_t (**)(void))(**(void **)(a1 + 160) + 40))(*(void *)(a1 + 160)),
         v3 >= 0)
      ? (xpc_object_t v6 = (const char *)v2)
      : (xpc_object_t v6 = v4),
        *(char *)(v5 + 23) >= 0 ? (CFTypeID v7 = (const char *)v5) : (CFTypeID v7 = *(const char **)v5),
        strcasecmp(v6, v7)))
  {
    uint64_t v8 = *(void *)(a1 + 128);
    sub_10003E168(v34, (void *)(a1 + 16));
    (*(void (**)(uint64_t, uint64_t, void *))(*(void *)v8 + 16))(v8, 1, v34);
    CFArrayRef v9 = (std::__shared_weak_count *)v34[1];
    goto LABEL_11;
  }
  uint64_t v10 = *(void *)(a1 + 144);
  CFArrayRef v9 = *(std::__shared_weak_count **)(a1 + 152);
  if (v9) {
    atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (!v10)
  {
    uint64_t v19 = *(void *)(a1 + 128);
    sub_10003E168(&v32, (void *)(a1 + 16));
    (*(void (**)(uint64_t, uint64_t, uint64_t *))(*(void *)v19 + 16))(v19, 1, &v32);
    xpc_object_t v18 = v33;
    if (!v33) {
      goto LABEL_11;
    }
    goto LABEL_42;
  }
  CFArrayRef v11 = *(std::__shared_weak_count **)(a1 + 168);
  uint64_t v30 = *(void *)(a1 + 160);
  xpc_object_t v31 = v11;
  if (v11) {
    atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  sub_100572C3C(a1, &v30);
  if (v31) {
    sub_10004D2C8(v31);
  }
  if (*(void *)(a1 + 176))
  {
    sub_100572E28(a1);
    uint64_t v12 = *(void *)(a1 + 176);
    uint64_t v26 = v10;
    xpc_object_t v27 = v9;
    if (v9) {
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    xpc_object_t v13 = (void *)(a1 + 216);
    if (*(char *)(a1 + 239) < 0) {
      xpc_object_t v13 = (void *)*v13;
    }
    char v14 = (*(uint64_t (**)(uint64_t, uint64_t *, void *))(*(void *)v12 + 24))(v12, &v26, v13);
    if (v27) {
      sub_10004D2C8(v27);
    }
    if (v14) {
      goto LABEL_11;
    }
    CFTypeID v15 = *(std::__shared_weak_count **)(a1 + 184);
    *(void *)(a1 + 176) = 0;
    *(void *)(a1 + 184) = 0;
    if (v15) {
      sub_10004D2C8(v15);
    }
    xpc_object_t v16 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 208) + 16))(*(void *)(a1 + 208), *(unsigned int *)(a1 + 48));
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
    {
      int v23 = *(_DWORD *)(a1 + 36);
      *(_DWORD *)buf = 67109120;
      int v38 = v23;
      _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "Send ack message failed. MsgId: %u", buf, 8u);
    }
    uint64_t v17 = *(void *)(a1 + 128);
    sub_10003E168(&v24, (void *)(a1 + 16));
    (*(void (**)(uint64_t, uint64_t, uint64_t *))(*(void *)v17 + 16))(v17, 1, &v24);
    xpc_object_t v18 = v25;
    if (!v25) {
      goto LABEL_11;
    }
LABEL_42:
    sub_10004D2C8(v18);
    goto LABEL_11;
  }
  xpc_object_t v20 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 208) + 16))(*(void *)(a1 + 208), *(unsigned int *)(a1 + 48));
  if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
  {
    int v22 = *(_DWORD *)(a1 + 36);
    *(_DWORD *)buf = 67109120;
    int v38 = v22;
    _os_log_error_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, "Unable to create connection object, MsgId: %u", buf, 8u);
  }
  uint64_t v21 = *(void *)(a1 + 128);
  sub_10003E168(&v28, (void *)(a1 + 16));
  (*(void (**)(uint64_t, uint64_t, uint64_t *))(*(void *)v21 + 16))(v21, 1, &v28);
  xpc_object_t v18 = v29;
  if (v29) {
    goto LABEL_42;
  }
LABEL_11:
  if (v9) {
    sub_10004D2C8(v9);
  }
  if (v36) {
    sub_10004D2C8(v36);
  }
}

void sub_100580CB4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  if (v20) {
    sub_10004D2C8(v20);
  }
  int v23 = *(std::__shared_weak_count **)(v21 - 56);
  if (v23) {
    sub_10004D2C8(v23);
  }
  _Unwind_Resume(exception_object);
}

void sub_100580D54(uint64_t a1, _DWORD **a2)
{
  CFBundleRef v4 = (NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 208) + 16))(*(void *)(a1 + 208), *(unsigned int *)(a1 + 48));
  unsigned int v5 = **a2 - 200;
  xpc_object_t v6 = *v4;
  CFTypeID v7 = *v4;
  if (v5 > 0x63)
  {
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      xpc_object_t v13 = (void *)(a1 + 216);
      if (*(char *)(a1 + 239) < 0) {
        xpc_object_t v13 = (void *)*v13;
      }
      int v14 = *(_DWORD *)(a1 + 36);
      *(_DWORD *)buf = 136315394;
      xpc_object_t v18 = v13;
      __int16 v19 = 1024;
      int v20 = v14;
      _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "ACK %s failed, MsgId: %u", buf, 0x12u);
    }
    uint64_t v8 = 1;
  }
  else
  {
    uint64_t v8 = 0;
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      CFArrayRef v9 = (void *)(a1 + 216);
      if (*(char *)(a1 + 239) < 0) {
        CFArrayRef v9 = (void *)*v9;
      }
      int v10 = *(_DWORD *)(a1 + 36);
      *(_DWORD *)buf = 136315394;
      xpc_object_t v18 = v9;
      __int16 v19 = 1024;
      int v20 = v10;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I ACK %s, MsgId: %u", buf, 0x12u);
      uint64_t v8 = 0;
    }
  }
  CFArrayRef v11 = *(std::__shared_weak_count **)(a1 + 184);
  *(void *)(a1 + 176) = 0;
  *(void *)(a1 + 184) = 0;
  if (v11) {
    sub_10004D2C8(v11);
  }
  uint64_t v12 = *(void *)(a1 + 128);
  sub_10003E168(&v15, (void *)(a1 + 16));
  (*(void (**)(uint64_t, uint64_t, uint64_t *))(*(void *)v12 + 16))(v12, v8, &v15);
  if (v16) {
    sub_10004D2C8(v16);
  }
}

void sub_100580F2C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

const char *sub_100580F4C()
{
  return "MMSAck";
}

void sub_100580F5C()
{
}

uint64_t sub_100580F70(uint64_t a1)
{
  return *(void *)(*(void *)(a1 + 8) + 192);
}

void sub_100580F7C(capabilities::ct *a1@<X0>, int a2@<W1>, void *a3@<X8>)
{
  int v6 = a2;
  int v5 = capabilities::ct::supportsBasebandVoiceLinkQualityNotification(a1);
  *a3 = 0;
  a3[1] = 0;
  if (v5) {
    sub_1005810F4((Registry **)a1, &v6, a3);
  }
}

void sub_100580FD0(uint64_t a1)
{
  *(void *)a1 = off_1019F9E38;
  uint64_t v2 = *(void **)(a1 + 136);
  if (v2)
  {
    *(void *)(a1 + 144) = v2;
    operator delete(v2);
  }
  std::mutex::~mutex((std::mutex *)(a1 + 64));
  int v3 = *(std::__shared_weak_count **)(a1 + 48);
  if (v3) {
    sub_10004D2C8(v3);
  }
  CFBundleRef v4 = *(std::__shared_weak_count **)(a1 + 24);
  if (v4) {
    std::__shared_weak_count::__release_weak(v4);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 8));

  LinkQualityMetricModelInterface::~LinkQualityMetricModelInterface((LinkQualityMetricModelInterface *)a1);
}

void sub_100581058(uint64_t a1)
{
  *(void *)a1 = off_1019F9E38;
  uint64_t v2 = *(void **)(a1 + 136);
  if (v2)
  {
    *(void *)(a1 + 144) = v2;
    operator delete(v2);
  }
  std::mutex::~mutex((std::mutex *)(a1 + 64));
  int v3 = *(std::__shared_weak_count **)(a1 + 48);
  if (v3) {
    sub_10004D2C8(v3);
  }
  CFBundleRef v4 = *(std::__shared_weak_count **)(a1 + 24);
  if (v4) {
    std::__shared_weak_count::__release_weak(v4);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 8));
  LinkQualityMetricModelInterface::~LinkQualityMetricModelInterface((LinkQualityMetricModelInterface *)a1);

  operator delete();
}

void sub_1005810F4(Registry **a1@<X1>, int *a2@<X2>, void *a3@<X8>)
{
  int v6 = operator new(0xC0uLL);
  sub_100581170(v6, a1, a2);
  *a3 = v6 + 3;
  a3[1] = v6;

  sub_1000B3BC8((uint64_t)a3, v6 + 5, (uint64_t)(v6 + 3));
}

void sub_10058115C(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_100581170(void *a1, Registry **a2, int *a3)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = off_1019E5310;
  uint64_t v4 = (uint64_t)(a1 + 3);
  int v5 = *a3;
  int v6 = "reg.elqm.voice.?";
  if (v5 == 2) {
    int v6 = "reg.elqm.voice.2";
  }
  if (v5 == 1) {
    CFTypeID v7 = "reg.elqm.voice.1";
  }
  else {
    CFTypeID v7 = (char *)v6;
  }
  sub_1006C172C(v4, a2, v5, v7, (uint64_t)"EnhancedVoiceLinkQualityMetricModel");
  a1[3] = off_1019E5278;
  return a1;
}

void sub_100581208(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void sub_10058121C(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1019E5310;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_10058123C(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1019E5310;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100581290(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

uint64_t sub_1005812B8(uint64_t a1, void *a2, long long *a3, int a4, long long *a5, long long *a6, uint64_t a7)
{
  *(void *)a1 = off_1019E5360;
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 72) = 0;
  *(_OWORD *)(a1 + 8) = xmmword_1014BDFF0;
  *(_DWORD *)(a1 + 24) = a4;
  *(_OWORD *)(a1 + 32) = xmmword_1014BD380;
  *(void *)(a1 + 48) = 3600;
  *(_DWORD *)(a1 + 80) = 0;
  uint64_t v11 = a2[1];
  *(void *)(a1 + 88) = *a2;
  *(void *)(a1 + 96) = v11;
  if (v11) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v11 + 8), 1uLL, memory_order_relaxed);
  }
  if (*((char *)a3 + 23) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 112), *(void **)a3, *((void *)a3 + 1));
  }
  else
  {
    long long v12 = *a3;
    *(void *)(a1 + 128) = *((void *)a3 + 2);
    *(_OWORD *)(a1 + 112) = v12;
  }
  if (*((char *)a5 + 23) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 136), *(void **)a5, *((void *)a5 + 1));
  }
  else
  {
    long long v13 = *a5;
    *(void *)(a1 + 152) = *((void *)a5 + 2);
    *(_OWORD *)(a1 + 136) = v13;
  }
  int v14 = (unsigned char *)(a1 + 160);
  if (*((char *)a6 + 23) < 0)
  {
    sub_10004FC84(v14, *(void **)a6, *((void *)a6 + 1));
  }
  else
  {
    long long v15 = *a6;
    *(void *)(a1 + 176) = *((void *)a6 + 2);
    *(_OWORD *)int v14 = v15;
  }
  *(void *)(a1 + 184) = 0;
  *(void *)(a1 + 192) = 0;
  *(void *)(a1 + 200) = 0;
  *(void *)(a1 + 208) = a7;
  *(_DWORD *)(a1 + 216) = 0;
  *(unsigned char *)(a1 + 220) = 0;
  return a1;
}

void sub_1005813F8(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 159) < 0) {
    operator delete(*v3);
  }
  if (*(char *)(v1 + 135) < 0) {
    operator delete(*v2);
  }
  int v6 = *(std::__shared_weak_count **)(v1 + 96);
  if (v6) {
    sub_10004D2C8(v6);
  }
  if (*(char *)(v1 + 79) < 0) {
    operator delete(*v4);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100581450(uint64_t a1, void *a2, long long *a3, int a4, long long *a5, long long *a6, long long *a7, uint64_t a8, char a9)
{
  *(void *)a1 = off_1019E5360;
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 72) = 0;
  *(_OWORD *)(a1 + 8) = xmmword_1014BDFF0;
  *(_DWORD *)(a1 + 24) = a4;
  *(_OWORD *)(a1 + 32) = xmmword_1014BD380;
  *(void *)(a1 + 48) = 3600;
  *(_DWORD *)(a1 + 80) = 0;
  uint64_t v14 = a2[1];
  *(void *)(a1 + 88) = *a2;
  *(void *)(a1 + 96) = v14;
  if (v14) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v14 + 8), 1uLL, memory_order_relaxed);
  }
  if (*((char *)a3 + 23) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 112), *(void **)a3, *((void *)a3 + 1));
  }
  else
  {
    long long v15 = *a3;
    *(void *)(a1 + 128) = *((void *)a3 + 2);
    *(_OWORD *)(a1 + 112) = v15;
  }
  if (*((char *)a5 + 23) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 136), *(void **)a5, *((void *)a5 + 1));
  }
  else
  {
    long long v16 = *a5;
    *(void *)(a1 + 152) = *((void *)a5 + 2);
    *(_OWORD *)(a1 + 136) = v16;
  }
  if (*((char *)a6 + 23) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 160), *(void **)a6, *((void *)a6 + 1));
  }
  else
  {
    long long v17 = *a6;
    *(void *)(a1 + 176) = *((void *)a6 + 2);
    *(_OWORD *)(a1 + 160) = v17;
  }
  xpc_object_t v18 = (unsigned char *)(a1 + 184);
  if (*((char *)a7 + 23) < 0)
  {
    sub_10004FC84(v18, *(void **)a7, *((void *)a7 + 1));
  }
  else
  {
    long long v19 = *a7;
    *(void *)(a1 + 200) = *((void *)a7 + 2);
    *(_OWORD *)xpc_object_t v18 = v19;
  }
  *(void *)(a1 + 208) = a8;
  *(_DWORD *)(a1 + 216) = 0;
  *(unsigned char *)(a1 + 220) = a9;
  return a1;
}

void sub_1005815C0(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 183) < 0) {
    operator delete(*v4);
  }
  if (*(char *)(v1 + 159) < 0) {
    operator delete(*v3);
  }
  if (*(char *)(v1 + 135) < 0) {
    operator delete(*v2);
  }
  CFTypeID v7 = *(std::__shared_weak_count **)(v1 + 96);
  if (v7) {
    sub_10004D2C8(v7);
  }
  if (*(char *)(v1 + 79) < 0) {
    operator delete(*v5);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100581630(uint64_t a1)
{
  return *(void *)(a1 + 104);
}

uint64_t sub_100581638(uint64_t result, uint64_t a2)
{
  *(void *)(result + 104) = a2;
  return result;
}

char *sub_100581640@<X0>(char *result@<X0>, uint64_t a2@<X8>)
{
  if (result[79] < 0) {
    return (char *)sub_10004FC84((unsigned char *)a2, *((void **)result + 7), *((void *)result + 8));
  }
  *(_OWORD *)a2 = *(_OWORD *)(result + 56);
  *(void *)(a2 + 16) = *((void *)result + 9);
  return result;
}

void sub_10058166C(uint64_t a1, uint64_t a2)
{
  if (*(char *)(a2 + 23) < 0) {
    sub_10004FC84(&__p, *(void **)a2, *(void *)(a2 + 8));
  }
  else {
    std::string __p = *(std::string *)a2;
  }
  std::string::operator=((std::string *)(a1 + 56), &__p);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
}

void sub_1005816DC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1005816F8(uint64_t a1)
{
  return *(unsigned int *)(a1 + 12);
}

uint64_t sub_100581700(uint64_t result, int a2)
{
  *(_DWORD *)(result + 12) = a2;
  return result;
}

uint64_t sub_100581708(uint64_t a1)
{
  return *(unsigned int *)(a1 + 8);
}

uint64_t sub_100581710(uint64_t a1)
{
  return *(unsigned int *)(a1 + 16);
}

uint64_t sub_100581718(uint64_t a1)
{
  Registry::getTimerService((uint64_t *)&v6, *(Registry **)(a1 + 88));
  uint64_t v2 = (**v6)(v6);
  int v3 = *(_DWORD *)(a1 + 16);
  uint64_t v4 = *(void *)(a1 + 40) << v3;
  if (v4 >= *(void *)(a1 + 48)) {
    uint64_t v4 = *(void *)(a1 + 48);
  }
  *(void *)(a1 + 32) = v2 + 1000000000 * v4;
  if (v7)
  {
    sub_10004D2C8(v7);
    int v3 = *(_DWORD *)(a1 + 16);
  }
  uint64_t result = (v3 + 1);
  *(_DWORD *)(a1 + 16) = result;
  return result;
}

void sub_1005817B0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1005817C8(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 40);
  if (v1 << *(_DWORD *)(a1 + 16) >= *(void *)(a1 + 48)) {
    return *(void *)(a1 + 48);
  }
  else {
    return v1 << *(_DWORD *)(a1 + 16);
  }
}

uint64_t sub_1005817E0(uint64_t a1)
{
  return *(unsigned int *)(a1 + 20);
}

BOOL sub_1005817E8(uint64_t a1)
{
  return *(_DWORD *)(a1 + 16) < *(_DWORD *)(a1 + 20);
}

uint64_t sub_1005817F8(uint64_t a1)
{
  return *(void *)(a1 + 40);
}

uint64_t sub_100581800(uint64_t a1)
{
  return *(void *)(a1 + 48);
}

uint64_t sub_100581808(uint64_t a1)
{
  return *(unsigned int *)(a1 + 24);
}

uint64_t sub_100581810(uint64_t a1)
{
  return *(void *)(a1 + 32);
}

uint64_t sub_100581818(uint64_t result, uint64_t a2)
{
  *(void *)(result + 32) = a2;
  return result;
}

BOOL sub_100581820(uint64_t a1)
{
  return sub_100581840(a1) < 1;
}

uint64_t sub_100581840(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  Registry::getTimerService((uint64_t *)&v4, *(Registry **)(a1 + 88));
  uint64_t v2 = (**v4)(v4);
  if (v5) {
    sub_10004D2C8(v5);
  }
  return (v1 - v2) / 1000000000;
}

void sub_1005818CC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

const char *sub_1005818E4()
{
  return "Sms";
}

void sub_1005818F0(_DWORD *a1@<X0>, uint64_t a2@<X8>)
{
  *(_OWORD *)std::string __p = 0u;
  long long v8 = 0u;
  LODWORD(__p[0]) = a1[6];
  uint64_t v9 = 0;
  __p[1] = 0;
  long long v8 = 0uLL;
  if ((*(uint64_t (**)(_DWORD *, void **, void))(*(void *)a1 + 200))(a1, __p, 0))
  {
    if (v8 >= 0) {
      int v3 = (char *)&__p[1];
    }
    else {
      int v3 = (char *)__p[1];
    }
    if (v8 >= 0) {
      size_t v4 = HIBYTE(v8);
    }
    else {
      size_t v4 = v8;
    }
    *(void *)(a2 + 8) = 0;
    *(void *)(a2 + 16) = 0;
    *(void *)a2 = 0;
    sub_10012C7D0((char *)a2, v3, &v3[v4], v4);
  }
  else
  {
    if (qword_101B14168 != -1) {
      dispatch_once(&qword_101B14168, &stru_101A84EE8);
    }
    int v5 = qword_101B14160;
    if (os_log_type_enabled((os_log_t)qword_101B14160, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)int v6 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "unable to encode message for spool", v6, 2u);
    }
    *(void *)a2 = 0;
    *(void *)(a2 + 8) = 0;
    *(void *)(a2 + 16) = 0;
  }
  if (SHIBYTE(v8) < 0) {
    operator delete(__p[1]);
  }
}

void sub_100581A20(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100581A40()
{
  return 0;
}

uint64_t sub_100581A48()
{
  return 0;
}

uint64_t sub_100581A50()
{
  return 0;
}

uint64_t sub_100581A58(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 220))
  {
    uint64_t v2 = operator new(0x10uLL);
    int v22 = v2 + 2;
    int v23 = v2 + 2;
    void *v2 = @"SMSSettings";
    v2[1] = @"EnableReplyToAlphanumericOriginator";
    std::string __p = v2;
    ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 88));
    size_t v4 = ServiceMap;
    if (v5 < 0)
    {
      int v6 = (unsigned __int8 *)(v5 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v7 = 5381;
      do
      {
        uint64_t v5 = v7;
        unsigned int v8 = *v6++;
        uint64_t v7 = (33 * v7) ^ v8;
      }
      while (v8);
    }
    std::mutex::lock(ServiceMap);
    *(void *)CFTypeRef cf = v5;
    uint64_t v9 = sub_10004D37C(&v4[1].__m_.__sig, (unint64_t *)cf);
    if (v9)
    {
      uint64_t v11 = v9[3];
      int v10 = (std::__shared_weak_count *)v9[4];
      if (v10)
      {
        atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v4);
        atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v10);
        char v12 = 0;
        if (!v11)
        {
LABEL_8:
          if (qword_101B14168 != -1) {
            dispatch_once(&qword_101B14168, &stru_101A84EE8);
          }
          long long v13 = qword_101B14160;
          if (os_log_type_enabled((os_log_t)qword_101B14160, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)CFTypeRef cf = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "Unable to get carrier bundle interface", cf, 2u);
          }
          uint64_t v14 = 1;
LABEL_30:
          if ((v12 & 1) == 0) {
            sub_10004D2C8(v10);
          }
          if (__p)
          {
            int v22 = __p;
            operator delete(__p);
          }
          return v14;
        }
LABEL_20:
        (*(void (**)(unsigned char *__return_ptr, uint64_t, void, uint64_t, void **, const CFBooleanRef, void))(*(void *)v11 + 104))(cf, v11, *(unsigned int *)(a1 + 24), 1, &__p, kCFBooleanTrue, 0);
        uint64_t v14 = *(void *)cf;
        char v24 = 0;
        if (*(void *)cf)
        {
          CFTypeID v16 = CFGetTypeID(*(CFTypeRef *)cf);
          if (v16 == CFBooleanGetTypeID())
          {
            ctu::cf::assign((ctu::cf *)&v24, (BOOL *)v14, v17);
            uint64_t v14 = v24 != 0;
          }
          else
          {
            uint64_t v14 = 0;
          }
        }
        sub_1000577C4((const void **)cf);
        if (qword_101B14168 != -1) {
          dispatch_once(&qword_101B14168, &stru_101A84EE8);
        }
        xpc_object_t v18 = qword_101B14160;
        if (os_log_type_enabled((os_log_t)qword_101B14160, OS_LOG_TYPE_INFO))
        {
          long long v19 = "false";
          if (v14) {
            long long v19 = "true";
          }
          *(_DWORD *)CFTypeRef cf = 136315138;
          *(void *)&cf[4] = v19;
          _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_INFO, "Reply to alphanumeric originator enabled = %s", cf, 0xCu);
        }
        goto LABEL_30;
      }
    }
    else
    {
      uint64_t v11 = 0;
    }
    std::mutex::unlock(v4);
    int v10 = 0;
    char v12 = 1;
    if (!v11) {
      goto LABEL_8;
    }
    goto LABEL_20;
  }
  if (qword_101B14168 != -1) {
    dispatch_once(&qword_101B14168, &stru_101A84EE8);
  }
  long long v15 = qword_101B14160;
  if (os_log_type_enabled((os_log_t)qword_101B14160, OS_LOG_TYPE_DEBUG))
  {
    LOWORD(__p) = 0;
    _os_log_debug_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEBUG, "Non alphanumeric sender", (uint8_t *)&__p, 2u);
  }
  return 1;
}

void sub_100581DB0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, uint64_t a12, char a13)
{
  if ((v14 & 1) == 0) {
    sub_10004D2C8(v13);
  }
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100581E04(uint64_t result, int a2)
{
  *(_DWORD *)(result + 80) = a2;
  return result;
}

uint64_t sub_100581E0C(uint64_t a1)
{
  return *(unsigned int *)(a1 + 80);
}

BOOL sub_100581E14(uint64_t a1)
{
  if (*(char *)(a1 + 159) < 0)
  {
    if (*(void *)(a1 + 144)) {
      goto LABEL_3;
    }
    return 0;
  }
  if (!*(unsigned char *)(a1 + 159)) {
    return 0;
  }
LABEL_3:
  if (*(char *)(a1 + 135) < 0) {
    uint64_t v1 = *(void *)(a1 + 120);
  }
  else {
    uint64_t v1 = *(unsigned __int8 *)(a1 + 135);
  }
  return v1 != 0;
}

uint64_t sub_100581E54()
{
  return 0;
}

uint64_t sub_100581E5C(uint64_t a1, uint64_t a2)
{
  size_t v4 = (unsigned char *)(a1 + 112);
  if (*(char *)(a1 + 135) < 0) {
    size_t v4 = *(unsigned char **)v4;
  }
  uint64_t v5 = (unsigned char *)(a1 + 136);
  if (*(char *)(a1 + 159) < 0) {
    uint64_t v5 = *(unsigned char **)v5;
  }
  int v6 = (unsigned char *)(a1 + 160);
  if (*(char *)(a1 + 183) < 0) {
    int v6 = *(unsigned char **)v6;
  }
  uint64_t v7 = (unsigned char *)(a1 + 184);
  if (*(char *)(a1 + 207) < 0) {
    uint64_t v7 = *(unsigned char **)v7;
  }
  uint64_t v8 = sub_10078F6E0(a2, *(void *)(a1 + 208), v4, v5, v6, v7);
  if (v8) {
    sub_10078E66C(a2, *(_DWORD *)(a1 + 216));
  }
  return v8;
}

uint64_t sub_100581EEC(uint64_t a1)
{
  *(void *)a1 = off_1019E5360;
  if (*(char *)(a1 + 207) < 0) {
    operator delete(*(void **)(a1 + 184));
  }
  if (*(char *)(a1 + 183) < 0) {
    operator delete(*(void **)(a1 + 160));
  }
  if (*(char *)(a1 + 159) < 0) {
    operator delete(*(void **)(a1 + 136));
  }
  if (*(char *)(a1 + 135) < 0) {
    operator delete(*(void **)(a1 + 112));
  }
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 96);
  if (v2) {
    sub_10004D2C8(v2);
  }
  if (*(char *)(a1 + 79) < 0) {
    operator delete(*(void **)(a1 + 56));
  }
  return a1;
}

void sub_100581F88(uint64_t a1)
{
  *(void *)a1 = off_1019E5360;
  if (*(char *)(a1 + 207) < 0) {
    operator delete(*(void **)(a1 + 184));
  }
  if (*(char *)(a1 + 183) < 0) {
    operator delete(*(void **)(a1 + 160));
  }
  if (*(char *)(a1 + 159) < 0) {
    operator delete(*(void **)(a1 + 136));
  }
  if (*(char *)(a1 + 135) < 0) {
    operator delete(*(void **)(a1 + 112));
  }
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 96);
  if (v2) {
    sub_10004D2C8(v2);
  }
  if (*(char *)(a1 + 79) < 0) {
    operator delete(*(void **)(a1 + 56));
  }

  operator delete();
}

void sub_1005821F0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, id location)
{
  objc_destroyWeak(v18);

  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_100582264(uint64_t a1, void *a2)
{
  uint64_t v2 = (id *)(a1 + 32);
  id v3 = a2;
  id WeakRetained = objc_loadWeakRetained(v2);
  [WeakRetained handleCLGDADict:v3];
}

void sub_1005822C0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_10058243C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void *sub_1005824C4(void *a1, id *a2, uint64_t a3)
{
  *a1 = off_1019E54B0;
  int v6 = [StewieCLGPSDisablementAssertion alloc];
  uint64_t v7 = sub_100200FB4(a2);
  a1[1] = [(StewieCLGPSDisablementAssertion *)v6 initWithQueue:v7 callback:a3];

  return a1;
}

void sub_10058254C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_10058255C(uint64_t a1)
{
  return a1;
}

void sub_100582588(uint64_t a1)
{
  operator delete();
}

double sub_1005825D4@<D0>(id *a1@<X0>, uint64_t a2@<X1>, _OWORD *a3@<X8>)
{
  if (!*a1) {
    __TUAssertTrigger();
  }
  sub_10058263C(a1, a2, v7);
  double result = v7[0];
  *a3 = *(_OWORD *)v7;
  return result;
}

void *sub_10058263C@<X0>(id *a1@<X1>, uint64_t a2@<X2>, void *a3@<X8>)
{
  int v6 = operator new(0x28uLL);
  double result = sub_1005826A0(v6, a1, a2);
  *a3 = v6 + 3;
  a3[1] = v6;
  return result;
}

void sub_10058268C(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_1005826A0(void *a1, id *a2, uint64_t a3)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = off_1019E54F8;
  sub_1005824C4(a1 + 3, a2, a3);
  return a1;
}

void sub_1005826E8(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void sub_1005826FC(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1019E54F8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_10058271C(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1019E54F8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100582770(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_100582798(uint64_t a1@<X0>, Registry **a2@<X1>, int a3@<W2>, uint64_t a4@<X3>, NSObject **a5@<X4>, uint64_t a6@<X8>)
{
  uint64_t v18 = 0;
  long long v19 = 0;
  (*(void (**)(uint64_t *__return_ptr))(*(void *)a1 + 24))(&v18);
  switch(a3)
  {
    case 1:
      int v21 = a4;
      sub_1011A3200(a2, &v21, a5, &v20);
      *(_OWORD *)a6 = v20;
      goto LABEL_15;
    case 2:
      long long v13 = *a5;
      dispatch_object_t v16 = v13;
      if (v13) {
        dispatch_retain(v13);
      }
      sub_1012A735C((uint64_t)a2, a4, &v16);
    case 3:
      char v14 = *a5;
      dispatch_object_t object = v14;
      if (v14) {
        dispatch_retain(v14);
      }
      sub_100C998F4(a2, a4, &object, &v20);
      *(_OWORD *)a6 = v20;
      long long v20 = 0uLL;
      char v12 = object;
      if (object) {
        goto LABEL_14;
      }
      goto LABEL_15;
    case 4:
    case 5:
      *(void *)a6 = 0;
      *(void *)(a6 + 8) = 0;
      goto LABEL_15;
    default:
      uint64_t v11 = *a5;
      dispatch_object_t v17 = v11;
      if (v11) {
        dispatch_retain(v11);
      }
      sub_100C99544(a2, a4, &v17, &v20);
      *(_OWORD *)a6 = v20;
      long long v20 = 0uLL;
      char v12 = v17;
      if (!v17) {
        goto LABEL_15;
      }
LABEL_14:
      dispatch_release(v12);
LABEL_15:
      if (v19) {
        sub_10004D2C8(v19);
      }
      return;
  }
}

void sub_10058292C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (object) {
    dispatch_release(object);
  }
  if (a14) {
    sub_10004D2C8(a14);
  }
  _Unwind_Resume(exception_object);
}

void sub_100582990(APNStorageFactoryInterface *this)
{
  *(void *)this = &off_1019E5548;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }

  APNStorageFactoryInterface::~APNStorageFactoryInterface(this);
}

void sub_1005829F0(APNStorageFactoryInterface *a1)
{
  sub_100582990(a1);

  operator delete();
}

uint64_t sub_100582A28@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(result + 16);
  *a2 = *(void *)(result + 8);
  a2[1] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100582A44(uint64_t a1@<X0>, NSObject **a2@<X1>, void *a3@<X8>)
{
  sub_10119F2A4(a1, a2, &v4);
  if (v5) {
    sub_10004D2C8(v5);
  }
  *a3 = 0;
  a3[1] = 0;
  operator new();
}

void sub_100582D74(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, dispatch_object_t object, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, dispatch_object_t a19)
{
  __cxa_free_exception(v19);
  sub_10004D2C8(v20);
  _Unwind_Resume(a1);
}

void sub_100582E94(uint64_t a1)
{
  *(void *)a1 = off_1019E5578;
  uint64_t v2 = (void *)(a1 + 80);
  sub_1000346F8(a1 + 112, *(void **)(a1 + 120));
  sub_10041A760(v2);
  sub_100584514(*(void **)(a1 + 64));
  id v3 = *(std::__shared_weak_count **)(a1 + 48);
  if (v3) {
    sub_10004D2C8(v3);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 32));
  size_t v4 = *(NSObject **)(a1 + 24);
  if (v4) {
    dispatch_release(v4);
  }
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 16);
  if (v5) {
    sub_10004D2C8(v5);
  }

  APN_StorageMgrInterface::~APN_StorageMgrInterface((APN_StorageMgrInterface *)a1);
}

void sub_100582F34(uint64_t a1)
{
  sub_100582E94(a1);

  operator delete();
}

void sub_100582F6C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v71[0] = 0;
  v71[1] = 0;
  xpc_object_t v69 = 0;
  xpc_object_t v70 = (uint64_t *)v71;
  uint64_t v6 = a1 + 8;
  uint64_t v7 = *(NSObject **)(a1 + 24);
  dispatch_object_t object = v7;
  xpc_object_t v68 = 0;
  if (v7) {
    dispatch_retain(v7);
  }
  (*(void (**)(uint64_t **__return_ptr, uint64_t, uint64_t, uint64_t, uint64_t, dispatch_object_t *))(*(void *)a2 + 16))(&v68, a2, v6, 3, a3, &object);
  if (object) {
    dispatch_release(object);
  }
  if (v68)
  {
    int v66 = 3;
    uint64_t v8 = sub_100584088(&v70, 3, &v66);
    int v10 = v68;
    uint64_t v9 = v69;
    if (v69) {
      atomic_fetch_add_explicit(&v69->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    uint64_t v11 = (std::__shared_weak_count *)v8[6];
    v8[5] = v10;
    v8[6] = (uint64_t *)v9;
    if (v11) {
      sub_10004D2C8(v11);
    }
  }
  if (v69) {
    sub_10004D2C8(v69);
  }
  xpc_object_t v68 = 0;
  xpc_object_t v69 = 0;
  char v12 = *(NSObject **)(a1 + 24);
  dispatch_object_t v65 = v12;
  if (v12) {
    dispatch_retain(v12);
  }
  (*(void (**)(uint64_t **__return_ptr, uint64_t, uint64_t, uint64_t, uint64_t, dispatch_object_t *))(*(void *)a2 + 16))(&v68, a2, v6, 1, a3, &v65);
  if (v65) {
    dispatch_release(v65);
  }
  if (v68)
  {
    int v66 = 1;
    long long v13 = sub_100584088(&v70, 1, &v66);
    long long v15 = v68;
    char v14 = v69;
    if (v69) {
      atomic_fetch_add_explicit(&v69->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    dispatch_object_t v16 = (std::__shared_weak_count *)v13[6];
    v13[5] = v15;
    v13[6] = (uint64_t *)v14;
    if (v16) {
      sub_10004D2C8(v16);
    }
  }
  if (v69) {
    sub_10004D2C8(v69);
  }
  xpc_object_t v68 = 0;
  xpc_object_t v69 = 0;
  dispatch_object_t v17 = *(NSObject **)(a1 + 24);
  dispatch_object_t v64 = v17;
  if (v17) {
    dispatch_retain(v17);
  }
  (*(void (**)(uint64_t **__return_ptr, uint64_t, uint64_t, void, uint64_t, dispatch_object_t *))(*(void *)a2 + 16))(&v68, a2, v6, 0, a3, &v64);
  if (v64) {
    dispatch_release(v64);
  }
  if (v68)
  {
    int v66 = 0;
    uint64_t v18 = sub_100584088(&v70, 0, &v66);
    long long v20 = v68;
    long long v19 = v69;
    if (v69) {
      atomic_fetch_add_explicit(&v69->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    int v21 = (std::__shared_weak_count *)v18[6];
    v18[5] = v20;
    v18[6] = (uint64_t *)v19;
    if (v21) {
      sub_10004D2C8(v21);
    }
  }
  if (v69) {
    sub_10004D2C8(v69);
  }
  xpc_object_t v68 = 0;
  xpc_object_t v69 = 0;
  int v22 = *(NSObject **)(a1 + 24);
  dispatch_object_t v63 = v22;
  if (v22) {
    dispatch_retain(v22);
  }
  (*(void (**)(uint64_t **__return_ptr, uint64_t, uint64_t, uint64_t, uint64_t, dispatch_object_t *))(*(void *)a2 + 16))(&v68, a2, v6, 2, a3, &v63);
  if (v63) {
    dispatch_release(v63);
  }
  if (v68)
  {
    int v66 = 2;
    int v23 = sub_100584088(&v70, 2, &v66);
    xpc_object_t v25 = v68;
    char v24 = v69;
    if (v69) {
      atomic_fetch_add_explicit(&v69->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    uint64_t v26 = (std::__shared_weak_count *)v23[6];
    v23[5] = v25;
    v23[6] = (uint64_t *)v24;
    if (v26) {
      sub_10004D2C8(v26);
    }
  }
  if (v69) {
    sub_10004D2C8(v69);
  }
  uint64_t v29 = *(void *)(a1 + 64);
  uint64_t v28 = (uint64_t **)(a1 + 64);
  uint64_t v27 = v29;
  if (v29)
  {
    while (1)
    {
      while (1)
      {
        uint64_t v30 = v27;
        int v31 = *(_DWORD *)(v27 + 32);
        if (v31 <= (int)a3) {
          break;
        }
        uint64_t v27 = *(void *)v30;
        uint64_t v32 = (uint64_t **)v30;
        if (!*(void *)v30) {
          goto LABEL_53;
        }
      }
      if (v31 >= (int)a3) {
        break;
      }
      uint64_t v27 = *(void *)(v30 + 8);
      if (!v27)
      {
        uint64_t v32 = (uint64_t **)(v30 + 8);
        goto LABEL_53;
      }
    }
  }
  else
  {
    uint64_t v32 = v28;
    uint64_t v30 = (uint64_t)v28;
LABEL_53:
    xpc_object_t v33 = operator new(0x40uLL);
    v33[8] = a3;
    *((void *)v33 + 7) = 0;
    *((void *)v33 + 6) = 0;
    *((void *)v33 + 5) = v33 + 12;
    sub_100046C38(v28 - 1, v30, v32, (uint64_t *)v33);
    uint64_t v30 = (uint64_t)v33;
  }
  if ((uint64_t **)(v30 + 40) != &v70)
  {
    xpc_object_t v34 = v70;
    if (*(void *)(v30 + 56))
    {
      xpc_object_t v36 = (uint64_t **)(v30 + 48);
      uint64_t v35 = *(void *)(v30 + 48);
      xpc_object_t v37 = *(void **)(v30 + 40);
      *(void *)(v30 + 40) = v30 + 48;
      *(void *)(v35 + 16) = 0;
      *(void *)(v30 + 48) = 0;
      *(void *)(v30 + 56) = 0;
      if (v37[1]) {
        int v38 = (void *)v37[1];
      }
      else {
        int v38 = v37;
      }
      if (v38)
      {
        xpc_object_t v39 = sub_1000EA590((uint64_t)v38);
        xpc_object_t v40 = v39;
        if (v34 == (uint64_t *)v71)
        {
          xpc_object_t v34 = (uint64_t *)v71;
        }
        else
        {
          xpc_object_t v41 = v39;
          xpc_object_t v42 = v38;
          xpc_object_t v43 = v34;
          do
          {
            int v38 = v41;
            *((_DWORD *)v42 + 8) = *((_DWORD *)v43 + 8);
            uint64_t v45 = v43[5];
            uint64_t v44 = v43[6];
            if (v44) {
              atomic_fetch_add_explicit((atomic_ullong *volatile)(v44 + 8), 1uLL, memory_order_relaxed);
            }
            xpc_object_t v46 = (std::__shared_weak_count *)v42[6];
            v42[5] = v45;
            v42[6] = v44;
            if (v46) {
              sub_10004D2C8(v46);
            }
            xpc_object_t v47 = *v36;
            xpc_object_t v48 = (uint64_t **)(v30 + 48);
            xpc_object_t v49 = (uint64_t **)(v30 + 48);
            if (*v36)
            {
              do
              {
                while (1)
                {
                  xpc_object_t v48 = (uint64_t **)v47;
                  if (*((_DWORD *)v42 + 8) >= *((_DWORD *)v47 + 8)) {
                    break;
                  }
                  xpc_object_t v47 = (uint64_t *)*v47;
                  xpc_object_t v49 = v48;
                  if (!*v48) {
                    goto LABEL_72;
                  }
                }
                xpc_object_t v47 = (uint64_t *)v47[1];
              }
              while (v47);
              xpc_object_t v49 = v48 + 1;
            }
LABEL_72:
            sub_100046C38((uint64_t **)(v30 + 40), (uint64_t)v48, v49, v42);
            if (v38)
            {
              xpc_object_t v40 = sub_1000EA590((uint64_t)v38);
              xpc_object_t v41 = v40;
            }
            else
            {
              xpc_object_t v41 = 0;
            }
            xpc_object_t v50 = (uint64_t *)v43[1];
            if (v50)
            {
              do
              {
                xpc_object_t v34 = v50;
                xpc_object_t v50 = (uint64_t *)*v50;
              }
              while (v50);
            }
            else
            {
              do
              {
                xpc_object_t v34 = (uint64_t *)v43[2];
                BOOL v51 = *v34 == (void)v43;
                xpc_object_t v43 = v34;
              }
              while (!v51);
            }
            if (!v38) {
              break;
            }
            xpc_object_t v42 = v38;
            xpc_object_t v43 = v34;
          }
          while (v34 != (uint64_t *)v71);
        }
        sub_100119D90(v38);
        if (!v40) {
          goto LABEL_90;
        }
        for (int i = (void *)v40[2]; i; int i = (void *)i[2])
          xpc_object_t v40 = i;
        xpc_object_t v52 = v40;
      }
      else
      {
        xpc_object_t v52 = 0;
      }
      sub_100119D90(v52);
    }
LABEL_90:
    if (v34 != (uint64_t *)v71)
    {
      xpc_object_t v54 = (uint64_t **)(v30 + 48);
      do
      {
        xpc_object_t v55 = operator new(0x38uLL);
        int v56 = *((_DWORD *)v34 + 8);
        v55[8] = v56;
        *((void *)v55 + 5) = v34[5];
        uint64_t v57 = v34[6];
        *((void *)v55 + 6) = v57;
        if (v57) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v57 + 8), 1uLL, memory_order_relaxed);
        }
        xpc_object_t v58 = *v54;
        xpc_object_t v59 = (uint64_t **)(v30 + 48);
        xpc_object_t v60 = (uint64_t **)(v30 + 48);
        if (*v54)
        {
          do
          {
            while (1)
            {
              xpc_object_t v59 = (uint64_t **)v58;
              if (v56 >= *((_DWORD *)v58 + 8)) {
                break;
              }
              xpc_object_t v58 = (uint64_t *)*v58;
              xpc_object_t v60 = v59;
              if (!*v59) {
                goto LABEL_100;
              }
            }
            xpc_object_t v58 = (uint64_t *)v58[1];
          }
          while (v58);
          xpc_object_t v60 = v59 + 1;
        }
LABEL_100:
        sub_100046C38((uint64_t **)(v30 + 40), (uint64_t)v59, v60, (uint64_t *)v55);
        xpc_object_t v61 = (uint64_t *)v34[1];
        if (v61)
        {
          do
          {
            xpc_object_t v62 = v61;
            xpc_object_t v61 = (uint64_t *)*v61;
          }
          while (v61);
        }
        else
        {
          do
          {
            xpc_object_t v62 = (uint64_t *)v34[2];
            BOOL v51 = *v62 == (void)v34;
            xpc_object_t v34 = v62;
          }
          while (!v51);
        }
        xpc_object_t v34 = v62;
      }
      while (v62 != (uint64_t *)v71);
    }
  }
  sub_100119D90(v71[0]);
}

void sub_10058353C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, dispatch_object_t object, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, std::__shared_weak_count *a15, uint64_t a16, void *a17)
{
  if (a15) {
    sub_10004D2C8(a15);
  }
  sub_100119D90(a17);
  _Unwind_Resume(a1);
}

void sub_1005835B8(uint64_t a1, NSObject **a2)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 8));
  uint64_t v5 = ServiceMap;
  if ((v6 & 0x8000000000000000) != 0)
  {
    uint64_t v7 = (unsigned __int8 *)(v6 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v8 = 5381;
    do
    {
      unint64_t v6 = v8;
      unsigned int v9 = *v7++;
      uint64_t v8 = (33 * v8) ^ v9;
    }
    while (v9);
  }
  std::mutex::lock(ServiceMap);
  v29[0] = v6;
  int v10 = sub_10004D37C(&v5[1].__m_.__sig, v29);
  if (v10)
  {
    char v12 = (GestaltUtilityInterface *)v10[3];
    uint64_t v11 = (std::__shared_weak_count *)v10[4];
    if (v11)
    {
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v5);
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v11);
      char v13 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    char v12 = 0;
  }
  std::mutex::unlock(v5);
  uint64_t v11 = 0;
  char v13 = 1;
LABEL_9:
  int isIPhone = GestaltUtilityInterface::isIPhone(v12);
  if ((v13 & 1) == 0) {
    sub_10004D2C8(v11);
  }
  if (isIPhone)
  {
    Registry::createRestModuleOneTimeUseConnection(&v27, *(Registry **)(a1 + 8));
    ctu::RestModule::connect();
    if (v28) {
      sub_10004D2C8(v28);
    }
    v29[0] = (unint64_t)off_1019E5690;
    v29[1] = a1 + 40;
    v29[3] = (unint64_t)v29;
    sub_10041CA0C(v29, (void *)(a1 + 80));
    sub_10041A760(v29);
    uint64_t v15 = *(void *)(a1 + 104);
    if (v15) {
      (*(void (**)(uint64_t, uint64_t))(*(void *)v15 + 48))(v15, a1 + 112);
    }
  }
  dispatch_object_t v16 = *(void **)(a1 + 56);
  dispatch_object_t v17 = (void *)(a1 + 64);
  if (v16 != (void *)(a1 + 64))
  {
    do
    {
      uint64_t v18 = (void *)v16[5];
      if (v18 != v16 + 6)
      {
        do
        {
          uint64_t v19 = v18[5];
          long long v20 = *a2;
          dispatch_group_t group = v20;
          if (v20)
          {
            dispatch_retain(v20);
            if (group) {
              dispatch_group_enter(group);
            }
          }
          (*(void (**)(uint64_t, dispatch_group_t *))(*(void *)v19 + 24))(v19, &group);
          if (group)
          {
            dispatch_group_leave(group);
            if (group) {
              dispatch_release(group);
            }
          }
          int v21 = (void *)v18[1];
          if (v21)
          {
            do
            {
              int v22 = v21;
              int v21 = (void *)*v21;
            }
            while (v21);
          }
          else
          {
            do
            {
              int v22 = (void *)v18[2];
              BOOL v23 = *v22 == (void)v18;
              uint64_t v18 = v22;
            }
            while (!v23);
          }
          uint64_t v18 = v22;
        }
        while (v22 != v16 + 6);
      }
      char v24 = (void *)v16[1];
      if (v24)
      {
        do
        {
          xpc_object_t v25 = v24;
          char v24 = (void *)*v24;
        }
        while (v24);
      }
      else
      {
        do
        {
          xpc_object_t v25 = (void *)v16[2];
          BOOL v23 = *v25 == (void)v16;
          dispatch_object_t v16 = v25;
        }
        while (!v23);
      }
      dispatch_object_t v16 = v25;
    }
    while (v25 != v17);
  }
}

void sub_100583860(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, dispatch_group_t group, uint64_t a10, std::__shared_weak_count *a11)
{
  if (a11) {
    sub_10004D2C8(a11);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1005838C0(uint64_t result)
{
  uint64_t v1 = *(void **)(result + 56);
  uint64_t v2 = (void *)(result + 64);
  if (v1 != (void *)(result + 64))
  {
    do
    {
      id v3 = (void *)v1[5];
      if (v3 != v1 + 6)
      {
        do
        {
          double result = (*(uint64_t (**)(void))(*(void *)v3[5] + 32))(v3[5]);
          size_t v4 = (void *)v3[1];
          if (v4)
          {
            do
            {
              uint64_t v5 = v4;
              size_t v4 = (void *)*v4;
            }
            while (v4);
          }
          else
          {
            do
            {
              uint64_t v5 = (void *)v3[2];
              BOOL v6 = *v5 == (void)v3;
              id v3 = v5;
            }
            while (!v6);
          }
          id v3 = v5;
        }
        while (v5 != v1 + 6);
      }
      uint64_t v7 = (void *)v1[1];
      if (v7)
      {
        do
        {
          uint64_t v8 = v7;
          uint64_t v7 = (void *)*v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          uint64_t v8 = (void *)v1[2];
          BOOL v6 = *v8 == (void)v1;
          uint64_t v1 = v8;
        }
        while (!v6);
      }
      uint64_t v1 = v8;
    }
    while (v8 != v2);
  }
  return result;
}

void sub_10058399C(void *a1, NSObject **a2)
{
  ctu::RestModule::disconnect((ctu::RestModule *)(a1 + 5));
  size_t v4 = (void *)a1[7];
  uint64_t v5 = a1 + 8;
  if (v4 != a1 + 8)
  {
    do
    {
      BOOL v6 = (void *)v4[5];
      if (v6 != v4 + 6)
      {
        do
        {
          uint64_t v7 = v6[5];
          uint64_t v8 = *a2;
          dispatch_group_t group = v8;
          if (v8)
          {
            dispatch_retain(v8);
            if (group) {
              dispatch_group_enter(group);
            }
          }
          (*(void (**)(uint64_t, dispatch_group_t *))(*(void *)v7 + 40))(v7, &group);
          if (group)
          {
            dispatch_group_leave(group);
            if (group) {
              dispatch_release(group);
            }
          }
          unsigned int v9 = (void *)v6[1];
          if (v9)
          {
            do
            {
              int v10 = v9;
              unsigned int v9 = (void *)*v9;
            }
            while (v9);
          }
          else
          {
            do
            {
              int v10 = (void *)v6[2];
              BOOL v11 = *v10 == (void)v6;
              BOOL v6 = v10;
            }
            while (!v11);
          }
          BOOL v6 = v10;
        }
        while (v10 != v4 + 6);
      }
      char v12 = (void *)v4[1];
      if (v12)
      {
        do
        {
          char v13 = v12;
          char v12 = (void *)*v12;
        }
        while (v12);
      }
      else
      {
        do
        {
          char v13 = (void *)v4[2];
          BOOL v11 = *v13 == (void)v4;
          size_t v4 = v13;
        }
        while (!v11);
      }
      size_t v4 = v13;
    }
    while (v13 != v5);
  }
}

void sub_100583AD4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_group_t group)
{
  if (group)
  {
    dispatch_group_leave(group);
    dispatch_release(group);
  }
  _Unwind_Resume(exception_object);
}

void sub_100583AF8(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 56);
  id v3 = (void *)(a1 + 64);
  if (v2 != (void *)(a1 + 64))
  {
    do
    {
      size_t v4 = (void *)v2[5];
      if (v4 != v2 + 6)
      {
        do
        {
          (*(void (**)(void))(*(void *)v4[5] + 56))(v4[5]);
          uint64_t v5 = (void *)v4[1];
          if (v5)
          {
            do
            {
              BOOL v6 = v5;
              uint64_t v5 = (void *)*v5;
            }
            while (v5);
          }
          else
          {
            do
            {
              BOOL v6 = (void *)v4[2];
              BOOL v7 = *v6 == (void)v4;
              size_t v4 = v6;
            }
            while (!v7);
          }
          size_t v4 = v6;
        }
        while (v6 != v2 + 6);
      }
      uint64_t v8 = (void *)v2[1];
      if (v8)
      {
        do
        {
          unsigned int v9 = v8;
          uint64_t v8 = (void *)*v8;
        }
        while (v8);
      }
      else
      {
        do
        {
          unsigned int v9 = (void *)v2[2];
          BOOL v7 = *v9 == (void)v2;
          uint64_t v2 = v9;
        }
        while (!v7);
      }
      uint64_t v2 = v9;
    }
    while (v9 != v3);
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 8));
  BOOL v11 = ServiceMap;
  char v12 = "16IPCU_CellProfile";
  if (((unint64_t)"16IPCU_CellProfile" & 0x8000000000000000) != 0)
  {
    char v13 = (unsigned __int8 *)((unint64_t)"16IPCU_CellProfile" & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v14 = 5381;
    do
    {
      char v12 = (const char *)v14;
      unsigned int v15 = *v13++;
      uint64_t v14 = (33 * v14) ^ v15;
    }
    while (v15);
  }
  std::mutex::lock(ServiceMap);
  long long v20 = v12;
  dispatch_object_t v16 = sub_10004D37C(&v11[1].__m_.__sig, (unint64_t *)&v20);
  if (!v16)
  {
    uint64_t v18 = 0;
LABEL_23:
    std::mutex::unlock(v11);
    dispatch_object_t v17 = 0;
    char v19 = 1;
    if (!v18) {
      goto LABEL_25;
    }
    goto LABEL_24;
  }
  uint64_t v18 = v16[3];
  dispatch_object_t v17 = (std::__shared_weak_count *)v16[4];
  if (!v17) {
    goto LABEL_23;
  }
  atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v11);
  atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v17);
  char v19 = 0;
  if (v18) {
LABEL_24:
  }
    (*(void (**)(uint64_t))(*(void *)v18 + 48))(v18);
LABEL_25:
  if ((v19 & 1) == 0) {
    sub_10004D2C8(v17);
  }
}

void sub_100583CB8(_Unwind_Exception *exception_object)
{
  if ((v2 & 1) == 0) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100583CD4(uint64_t a1@<X0>, int a2@<W1>, int a3@<W2>, void *a4@<X8>)
{
  uint64_t v6 = *(void *)(a1 + 64);
  if (!v6) {
    goto LABEL_11;
  }
  uint64_t v7 = a1 + 64;
  do
  {
    int v8 = *(_DWORD *)(v6 + 32);
    BOOL v9 = v8 < a2;
    if (v8 >= a2) {
      int v10 = (uint64_t *)v6;
    }
    else {
      int v10 = (uint64_t *)(v6 + 8);
    }
    if (!v9) {
      uint64_t v7 = v6;
    }
    uint64_t v6 = *v10;
  }
  while (*v10);
  if (v7 == a1 + 64 || *(_DWORD *)(v7 + 32) > a2)
  {
LABEL_11:
    BOOL v11 = *(NSObject **)(a1 + 32);
    if (!os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
LABEL_17:
      *a4 = 0;
      a4[1] = 0;
      return;
    }
    uint64_t v12 = subscriber::asString();
    if ((a3 - 1) > 4) {
      char v13 = "UI";
    }
    else {
      char v13 = off_1019E5700[a3 - 1];
    }
    int v24 = 136315394;
    uint64_t v25 = v12;
    __int16 v26 = 2080;
    uint64_t v27 = (uint64_t)v13;
    uint64_t v14 = "#E Failed to find sim %s for storage type %s";
LABEL_16:
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, v14, (uint8_t *)&v24, 0x16u);
    goto LABEL_17;
  }
  uint64_t v17 = *(void *)(v7 + 48);
  uint64_t v15 = v7 + 48;
  uint64_t v16 = v17;
  if (!v17) {
    goto LABEL_29;
  }
  uint64_t v18 = v15;
  do
  {
    int v19 = *(_DWORD *)(v16 + 32);
    BOOL v20 = v19 < a3;
    if (v19 >= a3) {
      int v21 = (uint64_t *)v16;
    }
    else {
      int v21 = (uint64_t *)(v16 + 8);
    }
    if (!v20) {
      uint64_t v18 = v16;
    }
    uint64_t v16 = *v21;
  }
  while (*v21);
  if (v18 == v15 || *(_DWORD *)(v18 + 32) > a3)
  {
LABEL_29:
    BOOL v11 = *(NSObject **)(a1 + 32);
    if (!os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_17;
    }
    if ((a3 - 1) > 4) {
      int v22 = "UI";
    }
    else {
      int v22 = off_1019E5700[a3 - 1];
    }
    int v24 = 136315394;
    uint64_t v25 = (uint64_t)v22;
    __int16 v26 = 2080;
    uint64_t v27 = subscriber::asString();
    uint64_t v14 = "#E Failed to find storage type %s for sim %s";
    goto LABEL_16;
  }
  *a4 = *(void *)(v18 + 40);
  uint64_t v23 = *(void *)(v18 + 48);
  a4[1] = v23;
  if (v23) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v23 + 8), 1uLL, memory_order_relaxed);
  }
}

double sub_100583ECC@<D0>(uint64_t a1@<X0>, int a2@<W1>, int a3@<W2>, _OWORD *a4@<X8>)
{
  sub_100583CD4(a1, a2, a3, &v6);
  double result = *(double *)&v6;
  *a4 = v6;
  return result;
}

void sub_100583F04(uint64_t a1, int a2, char a3, int a4)
{
  int v21 = a2;
  if (a4) {
    return;
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 8));
  uint64_t v7 = ServiceMap;
  if ((v8 & 0x8000000000000000) != 0)
  {
    BOOL v9 = (unsigned __int8 *)(v8 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v10 = 5381;
    do
    {
      unint64_t v8 = v10;
      unsigned int v11 = *v9++;
      uint64_t v10 = (33 * v10) ^ v11;
    }
    while (v11);
  }
  std::mutex::lock(ServiceMap);
  v18[0] = v8;
  uint64_t v12 = sub_10004D37C(&v7[1].__m_.__sig, v18);
  if (!v12)
  {
    uint64_t v14 = 0;
    goto LABEL_9;
  }
  uint64_t v14 = (GestaltUtilityInterface *)v12[3];
  char v13 = (std::__shared_weak_count *)v12[4];
  if (!v13)
  {
LABEL_9:
    std::mutex::unlock(v7);
    char v13 = 0;
    char v15 = 1;
    goto LABEL_10;
  }
  atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v7);
  atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v13);
  char v15 = 0;
LABEL_10:
  char isIPhone = GestaltUtilityInterface::isIPhone(v14);
  if ((v15 & 1) == 0) {
    sub_10004D2C8(v13);
  }
  if (isIPhone)
  {
    v18[0] = 1;
    long long v19 = 0u;
    uint64_t v20 = 0;
    v18[1] = a1 + 80;
    uint64_t v17 = sub_10005DF14((uint64_t *)&v19, a1 + 112);
    int v22 = &v21;
    *((unsigned char *)sub_10005CE78((uint64_t **)v17, &v21, (uint64_t)&unk_10144E20E, &v22) + 32) = a3;
    sub_100584728((uint64_t)v18);
  }
}

void sub_10058405C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t **sub_100584088(uint64_t **a1, int a2, _DWORD *a3)
{
  long long v6 = a1 + 1;
  uint64_t v5 = a1[1];
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        uint64_t v7 = (uint64_t **)v5;
        int v8 = *((_DWORD *)v5 + 8);
        if (v8 <= a2) {
          break;
        }
        uint64_t v5 = *v7;
        long long v6 = v7;
        if (!*v7) {
          goto LABEL_9;
        }
      }
      if (v8 >= a2) {
        break;
      }
      uint64_t v5 = v7[1];
      if (!v5)
      {
        long long v6 = v7 + 1;
        goto LABEL_9;
      }
    }
  }
  else
  {
    uint64_t v7 = a1 + 1;
LABEL_9:
    BOOL v9 = operator new(0x38uLL);
    v9[8] = *a3;
    *((void *)v9 + 5) = 0;
    *((void *)v9 + 6) = 0;
    sub_100046C38(a1, (uint64_t)v7, v6, (uint64_t *)v9);
    return (uint64_t **)v9;
  }
  return v7;
}

void sub_100584138(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100584170(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_1005841A0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t *sub_1005841E4(uint64_t *result)
{
  uint64_t v1 = *result;
  void *result = 0;
  if (v1)
  {
    uint64_t v2 = *(void *)(v1 + 16);
    *(void *)(v1 + 16) = 0;
    if (v2) {
      (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
    }
    id v3 = *(std::__shared_weak_count **)(v1 + 8);
    if (v3) {
      sub_10004D2C8(v3);
    }
    operator delete();
  }
  return result;
}

uint64_t *sub_100584268(uint64_t a1)
{
  uint64_t v14 = a1;
  uint64_t v1 = *(void **)a1;
  uint64_t v2 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = 0;
  if (!v2) {
    operator new();
  }
  sub_100582F6C((uint64_t)v1, v2, 1);
  if (capabilities::ct::supportsGemini(v3)) {
    sub_100582F6C((uint64_t)v1, v2, 2);
  }
  size_t v4 = v1[4];
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = (uint64_t *)v1[8];
    uint64_t v7 = v1[9];
    long long v6 = (uint64_t **)(v1 + 8);
    if (v5)
    {
      while (1)
      {
        while (1)
        {
          int v8 = (uint64_t **)v5;
          int v9 = *((_DWORD *)v5 + 8);
          if (v9 < 2) {
            break;
          }
          uint64_t v5 = *v8;
          uint64_t v10 = v8;
          if (!*v8) {
            goto LABEL_14;
          }
        }
        if (v9 == 1) {
          break;
        }
        uint64_t v5 = v8[1];
        if (!v5)
        {
          uint64_t v10 = v8 + 1;
          goto LABEL_14;
        }
      }
    }
    else
    {
      uint64_t v10 = v6;
      int v8 = v6;
LABEL_14:
      unsigned int v11 = operator new(0x40uLL);
      v11[8] = 1;
      *((void *)v11 + 7) = 0;
      *((void *)v11 + 6) = 0;
      *((void *)v11 + 5) = v11 + 12;
      sub_100046C38(v6 - 1, (uint64_t)v8, v10, (uint64_t *)v11);
      int v8 = (uint64_t **)v11;
    }
    uint64_t v12 = v8[7];
    buf[0] = 134218240;
    *(void *)&buf[1] = v7;
    LOWORD(buf[3]) = 2048;
    *(void *)((char *)&buf[3] + 2) = v12;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Created %zu set(s) of %zu storage instances", (uint8_t *)buf, 0x16u);
  }
  (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  return sub_1005841E4(&v14);
}

void sub_1005844A0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  sub_1005841E4((uint64_t *)va);
  _Unwind_Resume(a1);
}

void sub_100584514(void *a1)
{
  if (a1)
  {
    sub_100584514(*a1);
    sub_100584514(a1[1]);
    sub_100119D90((void *)a1[6]);
    operator delete(a1);
  }
}

void sub_10058456C()
{
}

void *sub_100584580(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_1019E5690;
  result[1] = v3;
  return result;
}

uint64_t sub_1005845C8(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019E5690;
  a2[1] = v2;
  return result;
}

void sub_1005845F4(uint64_t a1, void *a2)
{
  xpc_object_t v5 = 0;
  sub_100014264(a2, &v5);
  sub_100058DB0(&__p, "/cc/props/ui_apns_available");
  xpc_object_t object = v5;
  if (v5) {
    xpc_retain(v5);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(object);
  if (v4 < 0) {
    operator delete(__p);
  }
  xpc_release(v5);
}

void sub_100584698(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  xpc_release(object);
  if (a16 < 0) {
    operator delete(__p);
  }
  xpc_release(*(xpc_object_t *)(v16 - 24));
  _Unwind_Resume(a1);
}

uint64_t sub_1005846DC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10058471C()
{
}

uint64_t sub_100584728(uint64_t a1)
{
  if (*(unsigned char *)a1)
  {
    uint64_t v2 = *(void **)(a1 + 8);
    uint64_t v3 = (void *)(a1 + 16);
    if (v2[6] == *(void *)(a1 + 32))
    {
      char v4 = (void *)v2[4];
      if (v4 == v2 + 5) {
        goto LABEL_24;
      }
      xpc_object_t v5 = (void *)*v3;
      while (1)
      {
        BOOL v6 = *((_DWORD *)v4 + 7) == *((_DWORD *)v5 + 7)
          && *((unsigned __int8 *)v4 + 32) == *((unsigned __int8 *)v5 + 32);
        if (!v6) {
          break;
        }
        uint64_t v7 = (void *)v4[1];
        int v8 = v4;
        if (v7)
        {
          do
          {
            char v4 = v7;
            uint64_t v7 = (void *)*v7;
          }
          while (v7);
        }
        else
        {
          do
          {
            char v4 = (void *)v8[2];
            BOOL v6 = *v4 == (void)v8;
            int v8 = v4;
          }
          while (!v6);
        }
        int v9 = (void *)v5[1];
        if (v9)
        {
          do
          {
            uint64_t v10 = v9;
            int v9 = (void *)*v9;
          }
          while (v9);
        }
        else
        {
          do
          {
            uint64_t v10 = (void *)v5[2];
            BOOL v6 = *v10 == (void)v5;
            xpc_object_t v5 = v10;
          }
          while (!v6);
        }
        xpc_object_t v5 = v10;
        if (v4 == v2 + 5) {
          goto LABEL_24;
        }
      }
    }
    sub_10041F480((uint64_t)(v2 + 4), v3);
    uint64_t v11 = v2[3];
    if (v11) {
      (*(void (**)(uint64_t, void *))(*(void *)v11 + 48))(v11, v2 + 4);
    }
  }
LABEL_24:
  sub_1000346F8(a1 + 16, *(void **)(a1 + 24));
  return a1;
}

void sub_10058485C(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  operator new();
}

void *sub_1005848E8(uint64_t a1, int a2, char a3)
{
  int v7 = a2;
  char v6 = a3;
  uint64_t v3 = *(void ***)(a1 + 8);
  v8[0] = off_1019E5880;
  v8[1] = &v7;
  v8[2] = &v6;
  v8[3] = v8;
  sub_100043ED0((uint64_t)v8, *v3);
  return sub_100043E48(v8);
}

void sub_100584994(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100043E48((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *sub_1005849B0(uint64_t a1, int a2, int a3, char a4)
{
  int v9 = a3;
  int v10 = a2;
  char v8 = a4;
  char v4 = *(void ***)(a1 + 8);
  xpc_object_t v5 = operator new(0x20uLL);
  void *v5 = off_1019E5900;
  v5[1] = &v10;
  v5[2] = &v9;
  v5[3] = &v8;
  v11[3] = v5;
  sub_100043ED0((uint64_t)v11, *v4);
  return sub_100043E48(v11);
}

void sub_100584A68(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  sub_100043E48((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *sub_100584A84(uint64_t a1, int a2, int a3, uint64_t a4)
{
  int v9 = a3;
  int v10 = a2;
  xpc_object_t v5 = *(void ***)(a1 + 8);
  char v6 = operator new(0x20uLL);
  void *v6 = off_1019E5980;
  v6[1] = a4;
  v6[2] = &v10;
  v6[3] = &v9;
  v11[3] = v6;
  sub_100043ED0((uint64_t)v11, *v5);
  return sub_100043E48(v11);
}

void sub_100584B38(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100043E48((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *sub_100584B54(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void ***)(a1 + 8);
  v5[0] = off_1019E5A00;
  v5[1] = a2;
  v5[3] = v5;
  sub_100043ED0((uint64_t)v5, *v2);
  return sub_100043E48(v5);
}

void sub_100584BF0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100043E48((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *sub_100584C0C(uint64_t a1, int a2, int a3, int a4)
{
  int v9 = a3;
  int v10 = a2;
  int v8 = a4;
  char v4 = *(void ***)(a1 + 8);
  xpc_object_t v5 = operator new(0x20uLL);
  void *v5 = off_1019E5A80;
  v5[1] = &v10;
  v5[2] = &v9;
  v5[3] = &v8;
  v11[3] = v5;
  sub_100043ED0((uint64_t)v11, *v4);
  return sub_100043E48(v11);
}

void sub_100584CC4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  sub_100043E48((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *sub_100584CE0(uint64_t a1, int a2)
{
  int v5 = a2;
  uint64_t v2 = *(void ***)(a1 + 8);
  v6[0] = off_1019E5B00;
  v6[1] = &v5;
  v6[3] = v6;
  sub_100043ED0((uint64_t)v6, *v2);
  return sub_100043E48(v6);
}

void sub_100584D84(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100043E48((uint64_t *)va);
  _Unwind_Resume(a1);
}

void sub_100584DA0(uint64_t a1, int a2)
{
  int v10 = a2;
  uint64_t v3 = *(void ***)(a1 + 8);
  v12[0] = off_1019E5B80;
  v12[1] = &v10;
  v12[3] = v12;
  sub_100043ED0((uint64_t)v12, *v3);
  sub_100043E48(v12);
  if (v10 == 1) {
    uint64_t v5 = 1;
  }
  else {
    uint64_t v5 = 2 * (v10 == 2);
  }
  char v6 = +[NSNumber numberWithInteger:v5];
  id v9 = +[CTServiceDescriptor telephonyDescriptorWithInstance:v6];

  int v7 = *(void ***)(a1 + 8);
  v11[0] = off_1019E5C00;
  v11[1] = &v9;
  v11[3] = v11;
  sub_100043ED0((uint64_t)v11, *v7);
  sub_100043E48(v11);
}

void sub_100584EF4(_Unwind_Exception *a1, uint64_t a2, void *a3, uint64_t a4, ...)
{
  va_start(va, a4);
  sub_100043E48(va);

  _Unwind_Resume(a1);
}

void sub_100584F30(uint64_t a1, int a2)
{
  int v10 = a2;
  uint64_t v3 = *(void ***)(a1 + 8);
  v12[0] = off_1019E5C80;
  v12[1] = &v10;
  v12[3] = v12;
  sub_100043ED0((uint64_t)v12, *v3);
  sub_100043E48(v12);
  if (v10 == 1) {
    uint64_t v5 = 1;
  }
  else {
    uint64_t v5 = 2 * (v10 == 2);
  }
  char v6 = +[NSNumber numberWithInteger:v5];
  id v9 = +[CTServiceDescriptor telephonyDescriptorWithInstance:v6];

  int v7 = *(void ***)(a1 + 8);
  v11[0] = off_1019E5D00;
  v11[1] = &v9;
  v11[3] = v11;
  sub_100043ED0((uint64_t)v11, *v7);
  sub_100043E48(v11);
}

void sub_100585084(_Unwind_Exception *a1, uint64_t a2, void *a3, uint64_t a4, ...)
{
  va_start(va, a4);
  sub_100043E48(va);

  _Unwind_Resume(a1);
}

void *sub_1005850C0(uint64_t a1, int a2)
{
  int v5 = a2;
  uint64_t v2 = *(void ***)(a1 + 8);
  v6[0] = off_1019E5D80;
  v6[1] = &v5;
  v6[3] = v6;
  sub_100043ED0((uint64_t)v6, *v2);
  return sub_100043E48(v6);
}

void sub_100585164(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100043E48((uint64_t *)va);
  _Unwind_Resume(a1);
}

void sub_100585180(uint64_t a1, int a2, void *a3)
{
  int v12 = a2;
  id v5 = objc_alloc_init((Class)NSMutableArray);
  id v11 = v5;
  int v7 = (void *)*a3;
  char v6 = (void *)a3[1];
  if (v7 != v6)
  {
    int v8 = v5;
    do
      [v8 addObject:*v7++];
    while (v7 != v6);
  }
  id v9 = *(void ***)(a1 + 8);
  v13[0] = off_1019E5E00;
  v13[1] = &v12;
  v13[2] = &v11;
  v13[3] = v13;
  sub_100043ED0((uint64_t)v13, *v9);
  sub_100043E48(v13);
}

void sub_100585278(_Unwind_Exception *a1, uint64_t a2, void *a3, uint64_t a4, ...)
{
  va_start(va, a4);
  sub_100043E48((uint64_t *)va);

  _Unwind_Resume(a1);
}

void *sub_1005852A4(uint64_t a1, char a2)
{
  char v5 = a2;
  uint64_t v2 = *(void ***)(a1 + 8);
  v6[0] = off_1019E5E80;
  v6[1] = &v5;
  v6[3] = v6;
  sub_100043ED0((uint64_t)v6, *v2);
  return sub_100043E48(v6);
}

void sub_100585348(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100043E48((uint64_t *)va);
  _Unwind_Resume(a1);
}

void sub_100585364(uint64_t a1, int a2, unsigned __int8 *a3, int a4)
{
  int v11 = a2;
  sub_1005854BC(a3);
  id v10 = (id)objc_claimAutoreleasedReturnValue();
  char v6 = *(void ***)(a1 + 8);
  v13[0] = off_1019E5F00;
  v13[1] = &v11;
  v13[2] = &v10;
  v13[3] = v13;
  sub_100043ED0((uint64_t)v13, *v6);
  sub_100043E48(v13);
  if (a4)
  {
    int v8 = *(void ***)(a1 + 8);
    v12[0] = off_1019E5F80;
    v12[1] = &v11;
    v12[2] = &v10;
    v12[3] = v12;
    sub_100043ED0((uint64_t)v12, *v8);
    sub_100043E48(v12);
  }
}

void sub_10058548C(_Unwind_Exception *a1, uint64_t a2, void *a3, uint64_t a4, ...)
{
  va_start(va, a4);
  sub_100043E48(va);

  _Unwind_Resume(a1);
}

id sub_1005854BC(unsigned __int8 *a1)
{
  uint64_t v2 = objc_opt_new();
  [v2 setAttached:*a1];
  [v2 setDataSim:a1[1]];
  [v2 setIndicator:sub_100030A28(*((unsigned int *)a1 + 1))];
  [v2 setRoamAllowed:a1[8]];
  [v2 setRadioTechnology:sub_100030BD4(*((_DWORD *)a1 + 3))];
  [v2 setDataMode:*((unsigned int *)a1 + 4)];
  unsigned int v3 = *((_DWORD *)a1 + 5);
  if (v3 - 1 >= 6) {
    uint64_t v4 = 0;
  }
  else {
    uint64_t v4 = v3;
  }
  [v2 setDataBearerTechnology:v4];
  [v2 setDataBearerSoMask:*((unsigned int *)a1 + 6)];
  [v2 setDataPlanSignalingReductionOverride:a1[28]];
  [v2 setIndicatorOverride:sub_100030A28(*((unsigned int *)a1 + 8))];
  [v2 setCellularDataPossible:a1[36]];
  [v2 setActiveContexts:*((unsigned int *)a1 + 10)];
  [v2 setTotalActiveContexts:*((unsigned int *)a1 + 11)];
  [v2 setInHomeCountry:a1[48]];
  [v2 setReason:sub_100030BF8(*((_DWORD *)a1 + 13))];

  return v2;
}

void sub_1005855DC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1005855EC(uint64_t a1, unsigned __int8 *a2, unsigned __int8 *a3)
{
  sub_1005854BC(a2);
  id v20 = (id)objc_claimAutoreleasedReturnValue();
  int v7 = *(void ***)(a1 + 8);
  v22[0] = off_1019E6000;
  v22[1] = &v20;
  v22[3] = v22;
  sub_100043ED0((uint64_t)v22, *v7);
  sub_100043E48(v22);
  id v9 = [v20 copyBasic];
  id v19 = v9;
  id v10 = sub_1005854BC(a3);
  id v11 = [v10 copyBasic];

  LODWORD(v10) = [v9 attached];
  if (v10 != [v11 attached]
    || (unsigned int v12 = [v9 hasIndicator], v12 != objc_msgSend(v11, "hasIndicator"))
    || (unsigned int v13 = [v9 inHomeCountry], v13 != objc_msgSend(v11, "inHomeCountry"))
    || (unsigned int v14 = [v9 roamAllowed], v14 != objc_msgSend(v11, "roamAllowed"))
    || (unsigned int v15 = [v9 cellularDataPossible],
        v15 != [v11 cellularDataPossible])
    || (unsigned int v16 = [v9 newRadioCoverage],
        v16 != [v11 newRadioCoverage]))
  {
    uint64_t v17 = *(void ***)(a1 + 8);
    v21[0] = off_1019E6080;
    v21[1] = &v19;
    v21[3] = v21;
    sub_100043ED0((uint64_t)v21, *v17);
    sub_100043E48(v21);
  }
}

void sub_100585800(_Unwind_Exception *a1, uint64_t a2, void *a3, void *a4, ...)
{
  va_start(va, a4);
  sub_100043E48(va);

  _Unwind_Resume(a1);
}

void sub_100585864(uint64_t a1, int a2, uint64_t a3)
{
  int v30 = a2;
  id v29 = 0;
  char v6 = objc_opt_new();
  int v7 = +[NSNumber numberWithInteger:1];
  uint64_t v8 = +[NSNumber numberWithInteger:0];
  id v9 = (void *)v8;
  if (*(unsigned char *)(a3 + 1))
  {
    if (*(unsigned char *)a3) {
      id v10 = v7;
    }
    else {
      id v10 = (void *)v8;
    }
    [v6 setCarrierEnabled:v10];
  }
  if (*(unsigned char *)(a3 + 3))
  {
    if (*(unsigned char *)(a3 + 2)) {
      id v11 = v7;
    }
    else {
      id v11 = v9;
    }
    [v6 setUserAuthenticated:v11];
  }
  if (*(unsigned char *)(a3 + 12))
  {
    unsigned int v12 = +[NSNumber numberWithUnsignedInt:*(unsigned int *)(a3 + 8)];
    [v6 setMisPdpMaxHosts:v12];
  }
  if (*(unsigned char *)(a3 + 5))
  {
    if (*(unsigned char *)(a3 + 4)) {
      unsigned int v13 = v7;
    }
    else {
      unsigned int v13 = v9;
    }
    [v6 setAsserted:v13];
  }
  if (*(unsigned char *)(a3 + 7))
  {
    if (*(unsigned char *)(a3 + 6)) {
      unsigned int v14 = v7;
    }
    else {
      unsigned int v14 = v9;
    }
    [v6 setActivationFailure:v14];
  }
  if (*(_DWORD *)(a3 + 192))
  {
    id v15 = objc_alloc((Class)CTXPCServiceSubscriptionContext);
    int v16 = *(_DWORD *)(a3 + 192);
    if (v16 == 1) {
      uint64_t v17 = 1;
    }
    else {
      uint64_t v17 = 2 * (v16 == 2);
    }
    id v18 = [v15 initWithSlot:v17];
    [v6 setContext:v18];
  }
  if (*(unsigned char *)(a3 + 24))
  {
    id v19 = objc_opt_new();
    [v6 setConnectionAvailabilityStatus:v19];

    if (!*(unsigned char *)(a3 + 24)
      || (int v20 = *(unsigned __int8 *)(a3 + 16),
          [v6 connectionAvailabilityStatus],
          int v21 = objc_claimAutoreleasedReturnValue(),
          [v21 setAvailable:v20 != 0],
          v21,
          !*(unsigned char *)(a3 + 24)))
    {
      sub_10016C840();
    }
    uint64_t v22 = *(unsigned int *)(a3 + 20);
    uint64_t v23 = [v6 connectionAvailabilityStatus];
    [v23 setCsiError:v22];
  }
  if (*(unsigned char *)(a3 + 184))
  {
    int v24 = sub_100020AD0(a3 + 32);
    [v6 setConnectionStatus:v24];
  }
  id v29 = v6;
  if (a2 == 4)
  {
    uint64_t v25 = *(void ***)(a1 + 8);
    v32[0] = off_1019E6100;
    v32[1] = &v29;
    v32[3] = v32;
    sub_100043ED0((uint64_t)v32, *v25);
    sub_100043E48(v32);
  }
  uint64_t v27 = *(void ***)(a1 + 8);
  v31[0] = off_1019E6180;
  v31[1] = &v29;
  v31[2] = &v30;
  v31[3] = v31;
  sub_100043ED0((uint64_t)v31, *v27);
  sub_100043E48(v31);
}

void sub_100585B70(_Unwind_Exception *a1, uint64_t a2, void *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  sub_100043E48((uint64_t *)va);

  _Unwind_Resume(a1);
}

void sub_100585BEC(uint64_t a1, unsigned int *a2)
{
  uint64_t v4 = objc_opt_new();
  objc_msgSend(v4, "setActivationFailure:", *((unsigned __int8 *)a2 + 32), 0);
  [v4 setContextType:*a2];
  char v5 = a2 + 2;
  if (*((char *)a2 + 31) < 0)
  {
    if (!*((void *)a2 + 2)) {
      goto LABEL_7;
    }
    char v5 = (void *)*v5;
    goto LABEL_6;
  }
  if (*((unsigned char *)a2 + 31))
  {
LABEL_6:
    char v6 = +[NSString stringWithUTF8String:v5];
    [v4 setApnName:v6];
  }
LABEL_7:
  if (*((void *)a2 + 5))
  {
    int v7 = +[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:");
    [v4 setConnectionMask:v7];
  }
  [v4 setError:a2[12]];
  uint64_t v8 = +[NSNumber numberWithLongLong:*((void *)a2 + 7)];
  [v4 setRawCauseCode:v8];

  id v9 = +[NSNumber numberWithInt:a2[16]];
  [v4 setPdp:v9];

  id v10 = *(void ***)(a1 + 8);
  id v12 = v4;
  v13[0] = off_1019E6200;
  v13[1] = a2;
  v13[2] = &v12;
  v13[3] = v13;
  sub_100043ED0((uint64_t)v13, *v10);
  sub_100043E48(v13);
}

void sub_100585D9C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100585DE4(uint64_t a1, unsigned __int8 *a2)
{
  id v6 = (id)objc_opt_new();
  [v6 setCellularDataEnabled:*a2];
  [v6 setAirplaneModeEnabled:a2[1]];
  [v6 setCellularDataCapable:a2[2]];
  uint64_t v4 = *(void ***)(a1 + 8);
  v7[0] = off_1019E6280;
  v7[1] = &v6;
  double v7[3] = v7;
  sub_100043ED0((uint64_t)v7, *v4);
  sub_100043E48(v7);
}

void sub_100585ED0(_Unwind_Exception *a1, void *a2, ...)
{
  va_start(va, a2);
  sub_100043E48((uint64_t *)va);

  _Unwind_Resume(a1);
}

void sub_100585EFC(uint64_t a1, int a2, uint64_t a3)
{
  if (a2 == 1) {
    uint64_t v5 = 1;
  }
  else {
    uint64_t v5 = 2 * (a2 == 2);
  }
  id v6 = +[NSNumber numberWithInteger:v5];
  id v9 = +[CTServiceDescriptor telephonyDescriptorWithInstance:v6];

  int v7 = *(void ***)(a1 + 8);
  v10[0] = off_1019E6300;
  v10[1] = &v9;
  v10[2] = a3;
  v10[3] = v10;
  sub_100043ED0((uint64_t)v10, *v7);
  sub_100043E48(v10);
}

void sub_100585FFC(_Unwind_Exception *a1, void *a2, ...)
{
  va_start(va, a2);
  sub_100043E48((uint64_t *)va);

  _Unwind_Resume(a1);
}

void sub_10058602C(uint64_t a1, uint64_t *a2, char a3, void *a4)
{
  char v23 = a3;
  v22[0] = 0;
  v22[1] = 0;
  int v21 = (uint64_t *)v22;
  id v6 = a4 + 1;
  int v7 = (void *)*a4;
  if ((void *)*a4 != a4 + 1)
  {
    do
    {
      memset(v20, 0, sizeof(v20));
      long long v19 = 0u;
      TrafficDescriptor::TrafficDescriptor((TrafficDescriptor *)&v19, (const TrafficDescriptor *)(v7 + 4));
      LOBYTE(__p[0]) = 0;
      char v18 = 0;
      sub_100179CB0((uint64_t)v20, (__n128 *)__p);
      if (v18 && v17 < 0) {
        operator delete(__p[0]);
      }
      BYTE4(v19) = 0;
      BYTE8(v19) = 0;
      sub_1003816BC(&v21, (uint64_t)&v19, (const TrafficDescriptor *)&v19);
      TrafficDescriptor::~TrafficDescriptor((TrafficDescriptor *)&v19);
      uint64_t v8 = (void *)v7[1];
      if (v8)
      {
        do
        {
          id v9 = v8;
          uint64_t v8 = (void *)*v8;
        }
        while (v8);
      }
      else
      {
        do
        {
          id v9 = (void *)v7[2];
          BOOL v10 = *v9 == (void)v7;
          int v7 = v9;
        }
        while (!v10);
      }
      int v7 = v9;
    }
    while (v9 != v6);
  }
  id v11 = sub_100069448(&v21);
  *(void *)&long long v19 = objc_opt_new();
  [(id)v19 setTrafficDescriptors:v11];
  if (*((char *)a2 + 23) >= 0) {
    id v12 = a2;
  }
  else {
    id v12 = (uint64_t *)*a2;
  }
  __p[0] = +[NSString stringWithUTF8String:v12];
  unsigned int v13 = *(void ***)(a1 + 8);
  uint64_t v25 = 0;
  unsigned int v14 = operator new(0x20uLL);
  void *v14 = off_1019E6380;
  v14[1] = __p;
  v14[2] = &v23;
  v14[3] = &v19;
  uint64_t v25 = v14;
  sub_100043ED0((uint64_t)v24, *v13);
  sub_100043E48(v24);

  sub_10005D9E0((uint64_t)&v21, v22[0]);
}

void sub_100586254(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13)
{
  sub_100043E48((void *)(v14 - 88));

  sub_10005D9E0(v14 - 120, *(void **)(v14 - 112));
  _Unwind_Resume(a1);
}

void sub_1005862D8(uint64_t a1, uint64_t **a2)
{
  unsigned int v3 = sub_1005B0038(a2);
  id v6 = (id)objc_opt_new();
  [v6 setAppsInfo:v3];
  uint64_t v4 = *(void ***)(a1 + 8);
  v7[0] = off_1019E6400;
  v7[1] = &v6;
  double v7[3] = v7;
  sub_100043ED0((uint64_t)v7, *v4);
  sub_100043E48(v7);
}

void sub_1005863BC(_Unwind_Exception *a1, void *a2, ...)
{
  va_start(va, a2);
  sub_100043E48((uint64_t *)va);

  _Unwind_Resume(a1);
}

void sub_1005863F4(CTXPCDataNotificationInterface *this)
{
  *(void *)this = off_1019E5738;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }

  CTXPCDataNotificationInterface::~CTXPCDataNotificationInterface(this);
}

void sub_100586450(CTXPCDataNotificationInterface *this)
{
  *(void *)this = off_1019E5738;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  CTXPCDataNotificationInterface::~CTXPCDataNotificationInterface(this);

  operator delete();
}

void sub_1005864C0(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_100586528(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 160))(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100586564(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_10058659C(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 160))();
  }
  return result;
}

uint64_t sub_1005865CC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

void sub_100586614()
{
}

__n128 sub_100586628(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_1019E5880;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_100586674(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019E5880;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_1005866A4(uint64_t a1, id *a2)
{
  id v4 = *a2;
  unsigned int v3 = +[CTXPCPlaceholder simSlot:**(unsigned int **)(a1 + 8)];
  [v4 anbrActivationState:v3 enabled:**(unsigned __int8 **)(a1 + 16)];
}

void sub_100586720(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t sub_100586740(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100586780()
{
}

void sub_100586790()
{
}

__n128 sub_1005867A4(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_1019E5900;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_1005867F8(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019E5900;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100586830(uint64_t a1, id *a2)
{
  id v6 = *a2;
  unsigned int v3 = +[CTXPCPlaceholder simSlot:**(unsigned int **)(a1 + 8)];
  id v4 = [objc_alloc((Class)NSNumber) initWithUnsignedLong:**(unsigned int **)(a1 + 16)];
  if (**(unsigned char **)(a1 + 24)) {
    uint64_t v5 = 1;
  }
  else {
    uint64_t v5 = 2;
  }
  [v6 anbrBitrateRecommendation:v3 bitrate:v4 direction:v5];
}

void sub_1005868E4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t sub_100586910(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100586950()
{
}

void sub_100586960()
{
}

__n128 sub_100586974(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_1019E5980;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_1005869C8(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019E5980;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100586A00(uint64_t a1, id *a2)
{
  id v5 = *a2;
  unsigned int v3 = sub_100020AD0(*(void *)(a1 + 8));
  id v4 = +[CTXPCPlaceholder simSlot:**(unsigned int **)(a1 + 16)];
  [v5 connectionStateChanged:v4 connection:**(unsigned int **)(a1 + 24) dataConnectionStatusInfo:v3];
}

void sub_100586A9C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t sub_100586AC8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100586B08()
{
}

void sub_100586B18()
{
}

void *sub_100586B2C(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_1019E5A00;
  result[1] = v3;
  return result;
}

uint64_t sub_100586B74(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019E5A00;
  a2[1] = v2;
  return result;
}

void sub_100586BA0(uint64_t a1, id *a2)
{
  id v4 = *a2;
  uint64_t v3 = sub_100020AD0(*(void *)(a1 + 8));
  [v4 internetConnectionStateChanged:v3];
}

void sub_100586C08(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t sub_100586C28(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100586C68()
{
}

void sub_100586C78()
{
}

__n128 sub_100586C8C(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_1019E5A80;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_100586CE0(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019E5A80;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100586D18(unsigned int **a1, id *a2)
{
  id v4 = *a2;
  uint64_t v3 = +[CTXPCPlaceholder simSlot:*a1[1]];
  [v4 connectionActivationError:v3 connection:*a1[2] error:*a1[3]];
}

void sub_100586D98(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t sub_100586DB8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100586DF8()
{
}

void sub_100586E08()
{
}

void *sub_100586E1C(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_1019E5B00;
  result[1] = v3;
  return result;
}

uint64_t sub_100586E64(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019E5B00;
  a2[1] = v2;
  return result;
}

id sub_100586E90(uint64_t a1, id *a2)
{
  return [*a2 internetConnectionActivationError:**(unsigned int **)(a1 + 8)];
}

uint64_t sub_100586EA4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100586EE4()
{
}

void sub_100586EF4()
{
}

void *sub_100586F08(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_1019E5B80;
  result[1] = v3;
  return result;
}

uint64_t sub_100586F50(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019E5B80;
  a2[1] = v2;
  return result;
}

void sub_100586F7C(uint64_t a1, id *a2)
{
  id v4 = *a2;
  uint64_t v3 = +[CTXPCPlaceholder simSlot:**(unsigned int **)(a1 + 8)];
  [v4 preferredDataSimChanged:v3];
}

void sub_100586FF0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t sub_100587010(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100587050()
{
}

void sub_100587060()
{
}

void *sub_100587074(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_1019E5C00;
  result[1] = v3;
  return result;
}

uint64_t sub_1005870BC(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019E5C00;
  a2[1] = v2;
  return result;
}

id sub_1005870E8(uint64_t a1, id *a2)
{
  return [*a2 preferredDataServiceDescriptorChanged:**(void **)(a1 + 8)];
}

uint64_t sub_1005870FC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10058713C()
{
}

void sub_10058714C()
{
}

void *sub_100587160(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_1019E5C80;
  result[1] = v3;
  return result;
}

uint64_t sub_1005871A8(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019E5C80;
  a2[1] = v2;
  return result;
}

void sub_1005871D4(uint64_t a1, id *a2)
{
  id v4 = *a2;
  uint64_t v3 = +[CTXPCPlaceholder simSlot:**(unsigned int **)(a1 + 8)];
  [v4 currentDataSimChanged:v3];
}

void sub_100587248(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t sub_100587268(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1005872A8()
{
}

void sub_1005872B8()
{
}

void *sub_1005872CC(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_1019E5D00;
  result[1] = v3;
  return result;
}

uint64_t sub_100587314(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019E5D00;
  a2[1] = v2;
  return result;
}

id sub_100587340(uint64_t a1, id *a2)
{
  return [*a2 currentDataServiceDescriptorChanged:**(void **)(a1 + 8)];
}

uint64_t sub_100587354(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100587394()
{
}

void sub_1005873A4()
{
}

void *sub_1005873B8(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_1019E5D80;
  result[1] = v3;
  return result;
}

uint64_t sub_100587400(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019E5D80;
  a2[1] = v2;
  return result;
}

void sub_10058742C(uint64_t a1, id *a2)
{
  id v4 = *a2;
  uint64_t v3 = +[CTXPCPlaceholder simSlot:**(unsigned int **)(a1 + 8)];
  [v4 servingNetworkChanged:v3];
}

void sub_1005874A0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1005874C0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100587500()
{
}

void sub_100587510()
{
}

__n128 sub_100587524(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_1019E5E00;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_100587570(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019E5E00;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_1005875A0(uint64_t a1, id *a2)
{
  id v4 = *a2;
  uint64_t v3 = +[CTXPCPlaceholder simSlot:**(unsigned int **)(a1 + 8)];
  [v4 connectionAvailability:v3 availableConnections:**(void **)(a1 + 16)];
}

void sub_10058761C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t sub_10058763C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10058767C()
{
}

void sub_10058768C()
{
}

void *sub_1005876A0(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_1019E5E80;
  result[1] = v3;
  return result;
}

uint64_t sub_1005876E8(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019E5E80;
  a2[1] = v2;
  return result;
}

id sub_100587714(uint64_t a1, id *a2)
{
  return [*a2 internetConnectionAvailability:**(unsigned __int8 **)(a1 + 8)];
}

uint64_t sub_100587728(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100587768()
{
}

void sub_100587778()
{
}

__n128 sub_10058778C(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_1019E5F00;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_1005877D8(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019E5F00;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100587808(uint64_t a1, id *a2)
{
  id v4 = *a2;
  uint64_t v3 = +[CTXPCPlaceholder simSlot:**(unsigned int **)(a1 + 8)];
  [v4 dataStatus:v3 dataStatusInfo:**(void **)(a1 + 16)];
}

void sub_100587884(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1005878A4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1005878E4()
{
}

void sub_1005878F4()
{
}

__n128 sub_100587908(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_1019E5F80;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_100587954(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019E5F80;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100587984(uint64_t a1, id *a2)
{
  id v4 = *a2;
  uint64_t v3 = +[CTXPCPlaceholder simSlot:**(unsigned int **)(a1 + 8)];
  objc_msgSend(v4, "regDataModeChanged:dataMode:", v3, objc_msgSend(**(id **)(a1 + 16), "dataMode"));
}

void sub_100587A08(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t sub_100587A28(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100587A68()
{
}

void sub_100587A78()
{
}

void *sub_100587A8C(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_1019E6000;
  result[1] = v3;
  return result;
}

uint64_t sub_100587AD4(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019E6000;
  a2[1] = v2;
  return result;
}

id sub_100587B00(uint64_t a1, id *a2)
{
  return [*a2 internetDataStatus:**(void **)(a1 + 8)];
}

uint64_t sub_100587B14(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100587B54()
{
}

void sub_100587B64()
{
}

void *sub_100587B78(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_1019E6080;
  result[1] = v3;
  return result;
}

uint64_t sub_100587BC0(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019E6080;
  a2[1] = v2;
  return result;
}

id sub_100587BEC(uint64_t a1, id *a2)
{
  return [*a2 internetDataStatusBasic:**(void **)(a1 + 8)];
}

uint64_t sub_100587C00(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100587C40()
{
}

void sub_100587C50()
{
}

void *sub_100587C64(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_1019E6100;
  result[1] = v3;
  return result;
}

uint64_t sub_100587CAC(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019E6100;
  a2[1] = v2;
  return result;
}

id sub_100587CD8(uint64_t a1, id *a2)
{
  return [*a2 tetheringStatus:**(void **)(a1 + 8)];
}

uint64_t sub_100587CEC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100587D2C()
{
}

void sub_100587D3C()
{
}

__n128 sub_100587D50(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_1019E6180;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_100587D9C(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019E6180;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

id sub_100587DCC(uint64_t a1, id *a2)
{
  return [*a2 tetheringStatus:**(void **)(a1 + 8) connectionType:**(unsigned int **)(a1 + 16)];
}

uint64_t sub_100587DE4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100587E24()
{
}

void sub_100587E34()
{
}

__n128 sub_100587E48(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_1019E6200;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_100587E94(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019E6200;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100587EC4(uint64_t a1, id *a2)
{
  id v4 = *a2;
  uint64_t v3 = +[CTXPCPlaceholder simSlot:*(unsigned int *)(*(void *)(a1 + 8) + 68)];
  [v4 serviceDisconnection:v3 status:**(void **)(a1 + 16)];
}

void sub_100587F40(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t sub_100587F60(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100587FA0()
{
}

void sub_100587FB0()
{
}

void *sub_100587FC4(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_1019E6280;
  result[1] = v3;
  return result;
}

uint64_t sub_10058800C(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019E6280;
  a2[1] = v2;
  return result;
}

id sub_100588038(uint64_t a1, id *a2)
{
  return [*a2 dataSettingsChanged:**(void **)(a1 + 8)];
}

uint64_t sub_10058804C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10058808C()
{
}

void sub_10058809C()
{
}

__n128 sub_1005880B0(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = off_1019E6300;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_1005880FC(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019E6300;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

id sub_10058812C(uint64_t a1, id *a2)
{
  return [*a2 dataRoamingSettingsChanged:**(void **)(a1 + 8) status:**(unsigned __int8 **)(a1 + 16)];
}

uint64_t sub_100588144(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100588184()
{
}

void sub_100588194()
{
}

__n128 sub_1005881A8(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_1019E6380;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_1005881FC(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019E6380;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

id sub_100588234(uint64_t a1, id *a2)
{
  return [*a2 nrSliceAppStateChanged:**(void **)(a1 + 8) status:**(unsigned __int8 **)(a1 + 16) trafficDescriptors:**(void **)(a1 + 24)];
}

uint64_t sub_100588254(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100588294()
{
}

void sub_1005882A4()
{
}

void *sub_1005882B8(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_1019E6400;
  result[1] = v3;
  return result;
}

uint64_t sub_100588300(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019E6400;
  a2[1] = v2;
  return result;
}

id sub_10058832C(uint64_t a1, id *a2)
{
  return [*a2 nrSlicedRunningAppStateChanged:**(void **)(a1 + 8)];
}

uint64_t sub_100588340(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_100588380()
{
}

void sub_100588390(LazuliProvisioningWebHelper *a1)
{
  LazuliProvisioningWebHelper::~LazuliProvisioningWebHelper(a1);

  operator delete();
}

uint64_t sub_1005883C8()
{
  return 1;
}

void sub_1005883D0(uint64_t a1, uint64_t a2)
{
  unsigned int v4 = (*(uint64_t (**)(void))(**(void **)a2 + 24))();
  id v5 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), *(unsigned int *)(a1 + 76));
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 136315394;
    *(void *)&uint8_t buf[4] = "C";
    __int16 v23 = 1024;
    unsigned int v24 = v4;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I [%s] Response [%d] for OTP", buf, 0x12u);
  }
  int v19 = 4;
  id v6 = *(std::__shared_weak_count **)(a1 + 320);
  if (v6)
  {
    int v7 = std::__shared_weak_count::lock(v6);
    if (v7)
    {
      uint64_t v8 = *(void *)(a1 + 312);
      if (v8)
      {
        if (v4 == 511)
        {
          *(_DWORD *)buf = 10;
          LazuliProvisioningServerWrapper::submitMetricForPhase(v8, &v19, 0x1000001FFLL, buf, 0, 0);
          LOBYTE(v13) = 0;
          char v15 = 0;
          LazuliProvisioningServerWrapper::response511(v8, (uint64_t)&v13, 1, 0);
          if (!v15 || (v14 & 0x80000000) == 0) {
            goto LABEL_16;
          }
          id v9 = v13;
          goto LABEL_21;
        }
        if (v4 != 200)
        {
          unint64_t v11 = v4 | (unint64_t)&_mh_execute_header;
          if (v4 - 400 <= 0xC8)
          {
            *(_DWORD *)buf = 10;
            LazuliProvisioningServerWrapper::submitMetricForPhase(v8, &v19, v11, buf, 0, 0);
            *(_DWORD *)buf = 1;
            LazuliProvisioningServerWrapper::failedFatally(v8);
          }
          *(_DWORD *)buf = 10;
          LazuliProvisioningServerWrapper::submitMetricForPhase(v8, &v19, v11, buf, 0, 0);
          v12[0] = _NSConcreteStackBlock;
          v12[1] = 0x40000000;
          v12[2] = sub_100588824;
          v12[3] = &unk_1019E64B8;
          void v12[4] = a1;
          int v21 = 0;
          v20[0] = off_1019AD7A8;
          v20[1] = _Block_copy(v12);
          int v21 = v20;
          LazuliProvisioningWebHelper::responseUnknown(a1, a2, (uint64_t)v20);
          sub_1002364DC(v20);
          goto LABEL_16;
        }
        (*(void (**)(unsigned char *__return_ptr))(**(void **)a2 + 48))(buf);
        LOBYTE(__p) = 0;
        char v18 = 0;
        LazuliProvisioningServerWrapper::handleXml(v8, (uint64_t *)buf, (uint64_t)&__p, &v19);
        if (v18)
        {
          if (v17 < 0) {
            operator delete(__p);
          }
        }
        if (v25 < 0)
        {
          id v9 = *(void **)buf;
LABEL_21:
          operator delete(v9);
        }
LABEL_16:
        sub_10004D2C8(v7);
        return;
      }
    }
  }
  else
  {
    int v7 = 0;
  }
  BOOL v10 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), *(unsigned int *)(a1 + 76));
  if (!os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
  {
    if (!v7) {
      return;
    }
    goto LABEL_16;
  }
  *(_DWORD *)buf = 136315138;
  *(void *)&uint8_t buf[4] = "C";
  _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "[%s] Client has disappeared", buf, 0xCu);
  if (v7) {
    goto LABEL_16;
  }
}

void sub_100588794(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,char a27,uint64_t a28,uint64_t a29)
{
  sub_1002364DC(&a29);
  sub_10004D2C8(v29);
  _Unwind_Resume(a1);
}

uint64_t sub_100588824(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 32) + 40))();
}

void sub_10058884C(uint64_t a1, uint64_t a2)
{
  uint64_t v39 = 0;
  xpc_object_t v40 = 0;
  uint64_t v41 = 0;
  (*(void (**)(uint64_t *__return_ptr))(**(void **)a2 + 56))(&v39);
  int v4 = (*(uint64_t (**)(void))(**(void **)a2 + 24))();
  xpc_object_t v36 = 0;
  uint64_t v37 = 0;
  uint64_t v38 = 0;
  (*(void (**)(void **__return_ptr))(**(void **)a2 + 48))(&v36);
  long long __p = 0u;
  long long v35 = 0u;
  sub_100236560((uint64_t)v32, (uint64_t)&v39);
  LazuliProvisioningWebHelper::getCookie((uint64_t)v32, (uint64_t)&__p);
  sub_10010C0E0((uint64_t)v32, v33);
  int v31 = 1;
  id v5 = *(std::__shared_weak_count **)(a1 + 320);
  if (v5)
  {
    id v6 = std::__shared_weak_count::lock(v5);
    if (v6)
    {
      int v7 = *(LazuliProvisioningServerWrapper **)(a1 + 312);
      if (v7)
      {
        switch(v4)
        {
          case 511:
            id v12 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), *(unsigned int *)(a1 + 76));
            if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
            {
              unsigned int v13 = "YES";
              if (!BYTE8(v35)) {
                unsigned int v13 = "NO";
              }
              *(_DWORD *)buf = 136315394;
              uint64_t v45 = "C";
              __int16 v46 = 2080;
              xpc_object_t v47 = (void *)v13;
              _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I [%s] Received 511 redirect [cookie: %s]", buf, 0x16u);
            }
            *(_DWORD *)buf = 10;
            LazuliProvisioningServerWrapper::submitMetricForPhase((uint64_t)v7, &v31, 0x1000001FFLL, buf, 0, 0);
            int v14 = BYTE8(v35);
            sub_1000593FC((uint64_t)v23, &__p);
            LazuliProvisioningServerWrapper::response511((uint64_t)v7, (uint64_t)v23, 0, v14);
            if (!v25 || (v24 & 0x80000000) == 0) {
              goto LABEL_15;
            }
            char v15 = (void *)v23[0];
LABEL_50:
            operator delete(v15);
            goto LABEL_15;
          case 403:
            BOOL v16 = LazuliProvisioningWebHelper::requiresPSAccess(a1, (uint64_t)&v39);
            char v17 = *(uint64_t (**)(void))(**(void **)(a1 + 48) + 16);
            if (!v16)
            {
              int v19 = *(NSObject **)v17();
              if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)buf = 136315138;
                uint64_t v45 = "C";
                _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#I [%s] Received 403 forbidden response", buf, 0xCu);
              }
              *(_DWORD *)buf = 10;
              LazuliProvisioningServerWrapper::submitMetricForPhase((uint64_t)v7, &v31, 0x100000193, buf, 0, 0);
              LazuliProvisioningServerWrapper::handleForbiddenResponse(v7);
            }
            char v18 = *(NSObject **)v17();
            if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)buf = 136315138;
              uint64_t v45 = "C";
              _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#I [%s] Received 403 - Needs PS access response", buf, 0xCu);
            }
            *(_DWORD *)buf = 14;
            LazuliProvisioningServerWrapper::submitMetricForPhase((uint64_t)v7, &v31, 0x100000193, buf, 0, 0);
            *((unsigned char *)v7 + 208) = 1;
            LazuliProvisioningServerWrapper::resetRetryTimer(v7);
            goto LABEL_15;
          case 200:
            uint64_t v8 = HIBYTE(v38);
            if (v38 < 0) {
              uint64_t v8 = v37;
            }
            if (v8)
            {
              id v9 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), *(unsigned int *)(a1 + 76));
              if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
              {
                BOOL v10 = off_1019E66B8[v31];
                *(_DWORD *)buf = 136315394;
                uint64_t v45 = "C";
                __int16 v46 = 2080;
                xpc_object_t v47 = v10;
                _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I [%s] Received 200 OK with XML: %s", buf, 0x16u);
              }
              sub_1000593FC((uint64_t)v28, &__p);
              LazuliProvisioningServerWrapper::handleXml((uint64_t)v7, (uint64_t *)&v36, (uint64_t)v28, &v31);
              if (!v30 || (v29 & 0x80000000) == 0) {
                goto LABEL_15;
              }
              char v15 = v28[0];
              goto LABEL_50;
            }
            if (BYTE8(v35))
            {
              std::string::operator=((std::string *)(a1 + 232), (const std::string *)&__p);
              *(_DWORD *)buf = 10;
              LazuliProvisioningServerWrapper::submitMetricForPhase((uint64_t)v7, &v31, 0x1000000C8, buf, 0, 0);
              int v20 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), *(unsigned int *)(a1 + 76));
              if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
              {
                int v21 = "YES";
                if (!BYTE8(v35)) {
                  int v21 = "NO";
                }
                *(_DWORD *)buf = 136315394;
                uint64_t v45 = "C";
                __int16 v46 = 2080;
                xpc_object_t v47 = (void *)v21;
                _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#I [%s] Received 200 OK [cookie: %s]", buf, 0x16u);
              }
              sub_1000593FC((uint64_t)&v26, &__p);
              sub_1005890A8(a1, &v26);
              if (!v27 || (SHIBYTE(v26.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
                goto LABEL_15;
              }
              char v15 = (void *)v26.__r_.__value_.__r.__words[0];
              goto LABEL_50;
            }
            break;
        }
        aBlock[0] = _NSConcreteStackBlock;
        aBlock[1] = 0x40000000;
        aBlock[2] = sub_100589374;
        aBlock[3] = &unk_1019E64D8;
        aBlock[4] = a1;
        xpc_object_t v43 = 0;
        v42[0] = off_1019AD7A8;
        v42[1] = _Block_copy(aBlock);
        xpc_object_t v43 = v42;
        LazuliProvisioningWebHelper::responseUnknown(a1, a2, (uint64_t)v42);
        sub_1002364DC(v42);
LABEL_15:
        sub_10004D2C8(v6);
        goto LABEL_16;
      }
    }
  }
  else
  {
    id v6 = 0;
  }
  unint64_t v11 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), *(unsigned int *)(a1 + 76));
  if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 136315138;
    uint64_t v45 = "C";
    _os_log_error_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "[%s] Client has disappeared", buf, 0xCu);
    if (!v6) {
      goto LABEL_16;
    }
    goto LABEL_15;
  }
  if (v6) {
    goto LABEL_15;
  }
LABEL_16:
  if (BYTE8(v35) && SBYTE7(v35) < 0) {
    operator delete((void *)__p);
  }
  if (SHIBYTE(v38) < 0) {
    operator delete(v36);
  }
  sub_10010C0E0((uint64_t)&v39, v40);
}

void sub_100588F94(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,char a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27,char a28,uint64_t a29,uint64_t a30,int a31,__int16 a32,char a33,char a34,char a35,uint64_t a36,char a37,uint64_t a38,uint64_t a39,void *a40,uint64_t a41,int a42,__int16 a43,char a44,char a45,char a46)
{
  if (a28 && a27 < 0) {
    operator delete(__p);
  }
  sub_10004D2C8(v46);
  if (a46 && a45 < 0) {
    operator delete(a40);
  }
  if (*(char *)(v47 - 153) < 0) {
    operator delete(*(void **)(v47 - 176));
  }
  sub_10010C0E0(v47 - 152, *(void **)(v47 - 144));
  _Unwind_Resume(a1);
}

void sub_1005890A0()
{
}

void sub_1005890A8(uint64_t a1, const std::string *a2)
{
  int v4 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), *(unsigned int *)(a1 + 76));
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    id v5 = (void *)(a1 + 112);
    if (*(char *)(a1 + 135) < 0) {
      id v5 = (void *)*v5;
    }
    id v6 = "YES";
    int v7 = a2[1].__r_.__value_.__s.__data_[0];
    *(void *)&uint8_t buf[4] = "C";
    *(_DWORD *)buf = 136315650;
    *(_WORD *)&unsigned char buf[12] = 2080;
    if (!v7) {
      id v6 = "NO";
    }
    *(void *)&buf[14] = v5;
    *(_WORD *)&buf[22] = 2080;
    char v18 = v6;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I [%s] Starting access with parameters on URL: %s [cookie: %s]", buf, 0x20u);
  }
  *(_OWORD *)&buf[8] = 0uLL;
  *(void *)buf = &buf[8];
  if (a2[1].__r_.__value_.__s.__data_[0])
  {
    sub_100058DB0(&__p, "Cookie");
    __str.__r_.__value_.__r.__words[0] = (std::string::size_type)&__p;
    uint64_t v8 = sub_10014BECC((uint64_t **)buf, (uint64_t)&__p, (uint64_t)&unk_10144E20E, &__str);
    std::string::operator=((std::string *)((char *)v8 + 56), a2);
    if (SHIBYTE(v15) < 0) {
      operator delete(__p);
    }
  }
  long long __p = 0;
  int v14 = 0;
  uint64_t v15 = 0;
  LazuliProvisioningWebHelper::getHeaders((LazuliProvisioningWebHelper *)a1, 2047, (uint64_t)&__p);
  *(unsigned char *)(a1 + 72) = 1;
  int v12 = 2;
  sub_100564D6C(a1 + 112, &__p, (uint64_t *)&__str);
  v16[0] = off_1019E65A0;
  v16[1] = a1;
  v16[3] = v16;
  v9.__r_.__value_.__s.__data_[0] = 0;
  char v10 = 0;
  LazuliProvisioningWebHelper::runWithTimeout(a1, &v12, &__str, (uint64_t)buf, (uint64_t)v16, &v9);
  if (v10 && SHIBYTE(v9.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v9.__r_.__value_.__l.__data_);
  }
  sub_1002364DC(v16);
  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__str.__r_.__value_.__l.__data_);
  }
  sub_10010C0E0((uint64_t)&__p, v14);
  sub_10010C0E0((uint64_t)buf, *(void **)&buf[8]);
}

void sub_1005892F4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,void *a24,uint64_t a25,int a26,__int16 a27,char a28,char a29,char a30)
{
  sub_10010C0E0(v30 - 80, *(void **)(v30 - 72));
  _Unwind_Resume(a1);
}

uint64_t sub_100589374(uint64_t a1)
{
  return sub_10058884C(*(void *)(a1 + 32));
}

void sub_10058937C(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), *(unsigned int *)(a1 + 76));
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = (void *)(a1 + 112);
    if (*(char *)(a1 + 135) < 0) {
      uint64_t v3 = (void *)*v3;
    }
    uint64_t v4 = *(int *)(a1 + 504);
    if (v4 > 4) {
      id v5 = "kCellular";
    }
    else {
      id v5 = off_1019E6690[v4];
    }
    *(_DWORD *)buf = 136315650;
    *(void *)&uint8_t buf[4] = "C";
    *(_WORD *)&unsigned char buf[12] = 2082;
    *(void *)&buf[14] = v3;
    *(_WORD *)&buf[22] = 2082;
    char v17 = (char *)v5;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I [%s] Starting first access on: [%{public}s] with interface [%{public}s] ", buf, 0x20u);
  }
  if (*(_DWORD *)(a1 + 504) == 3)
  {
    v13.__r_.__value_.__s.__data_[0] = 0;
    char v14 = 0;
    sub_1005890A8(a1, &v13);
    if (v14 && SHIBYTE(v13.__r_.__value_.__r.__words[2]) < 0)
    {
      id v6 = (void *)v13.__r_.__value_.__r.__words[0];
LABEL_21:
      operator delete(v6);
    }
  }
  else
  {
    memset(&__str, 0, sizeof(__str));
    *(void *)&buf[8] = 0;
    *(void *)&buf[16] = 0;
    *(void *)buf = &buf[8];
    sub_1005649F0(a1 + 112, buf, (uint64_t *)&__str);
    sub_10010C0E0((uint64_t)buf, *(void **)&buf[8]);
    uint64_t v9 = 0;
    char v10 = 0;
    uint64_t v11 = 0;
    sub_100235804(buf, "User-Agent", "iPhoneOS");
    sub_1002369E0((uint64_t)&v9, (long long *)buf, 1);
    if (v18 < 0) {
      operator delete(v17);
    }
    if ((buf[23] & 0x80000000) != 0) {
      operator delete(*(void **)buf);
    }
    *(_DWORD *)buf = 1;
    v15[0] = off_1019E6520;
    v15[1] = a1;
    v15[3] = v15;
    __p.__r_.__value_.__s.__data_[0] = 0;
    char v8 = 0;
    LazuliProvisioningWebHelper::runWithTimeout(a1, buf, &__str, (uint64_t)&v9, (uint64_t)v15, &__p);
    if (v8 && SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    sub_1002364DC(v15);
    sub_10010C0E0((uint64_t)&v9, v10);
    if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
    {
      id v6 = (void *)__str.__r_.__value_.__r.__words[0];
      goto LABEL_21;
    }
  }
}

void sub_1005895EC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16, uint64_t a17, char a18, void *a19, uint64_t a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,uint64_t a27,uint64_t a28,int a29,__int16 a30,char a31,char a32,char a33,int a34,uint64_t a35)
{
  if (a16 && a15 < 0) {
    operator delete(__p);
  }
  sub_1002364DC(&a35);
  sub_10010C0E0((uint64_t)&a18, a19);
  if (a26 < 0) {
    operator delete(a21);
  }
  _Unwind_Resume(a1);
}

void sub_10058967C(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), *(unsigned int *)(a1 + 76));
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = (void *)(a1 + 112);
    if (*(char *)(a1 + 135) < 0) {
      uint64_t v3 = (void *)*v3;
    }
    *(_DWORD *)buf = 136315394;
    *(void *)&uint8_t buf[4] = "C";
    *(_WORD *)&unsigned char buf[12] = 2082;
    *(void *)&buf[14] = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I [%s] Starting refresh on: [%{public}s]", buf, 0x16u);
  }
  memset(buf, 0, sizeof(buf));
  LazuliProvisioningWebHelper::getHeaders((LazuliProvisioningWebHelper *)a1, 2047, (uint64_t)buf);
  memset(&__str, 0, sizeof(__str));
  sub_1005649F0(a1 + 112, buf, (uint64_t *)&__str);
  int v8 = 2;
  v7[0] = 0;
  v7[1] = 0;
  id v6 = v7;
  v10[0] = off_1019E6620;
  v10[1] = a1;
  v10[3] = v10;
  __p.__r_.__value_.__s.__data_[0] = 0;
  char v5 = 0;
  LazuliProvisioningWebHelper::runWithTimeout(a1, &v8, &__str, (uint64_t)&v6, (uint64_t)v10, &__p);
  if (v5 && SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  sub_1002364DC(v10);
  sub_10010C0E0((uint64_t)&v6, v7[0]);
  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__str.__r_.__value_.__l.__data_);
  }
  sub_10010C0E0((uint64_t)buf, *(void **)&buf[8]);
}

void sub_100589840(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,uint64_t a23,void *a24,uint64_t a25,int a26,__int16 a27,char a28,char a29)
{
  if (a16 && a15 < 0) {
    operator delete(__p);
  }
  sub_1002364DC((void *)(v29 - 80));
  sub_10010C0E0((uint64_t)&a18, a21);
  if (a29 < 0) {
    operator delete(a24);
  }
  sub_10010C0E0(v29 - 48, *(void **)(v29 - 40));
  _Unwind_Resume(a1);
}

void sub_1005898A8()
{
}

void *sub_1005898BC(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_1019E6520;
  result[1] = v3;
  return result;
}

uint64_t sub_100589904(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019E6520;
  a2[1] = v2;
  return result;
}

void sub_100589930(uint64_t a1, uint64_t a2)
{
}

uint64_t sub_100589938(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_100589978()
{
}

void sub_100589988()
{
}

void *sub_10058999C(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_1019E65A0;
  result[1] = v3;
  return result;
}

uint64_t sub_1005899E4(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019E65A0;
  a2[1] = v2;
  return result;
}

void sub_100589A10(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v29 = 0;
  uint64_t v30 = 0;
  uint64_t v31 = 0;
  (*(void (**)(uint64_t *__return_ptr))(**(void **)a2 + 56))(&v29);
  int v4 = (*(uint64_t (**)(void))(**(void **)a2 + 24))();
  std::string __p = 0;
  uint64_t v27 = 0;
  uint64_t v28 = 0;
  (*(void (**)(void **__return_ptr))(**(void **)a2 + 48))(&__p);
  memset(__str, 0, sizeof(__str));
  sub_100236560((uint64_t)v23, (uint64_t)&v29);
  LazuliProvisioningWebHelper::getCookie((uint64_t)v23, (uint64_t)__str);
  sub_10010C0E0((uint64_t)v23, v24);
  if (__str[24]) {
    std::string::operator=((std::string *)(v3 + 232), (const std::string *)__str);
  }
  int v22 = 2;
  char v5 = *(std::__shared_weak_count **)(v3 + 320);
  if (v5)
  {
    id v6 = std::__shared_weak_count::lock(v5);
    if (v6)
    {
      int v7 = *(LazuliProvisioningServerWrapper **)(v3 + 312);
      if (v7)
      {
        if (v4 != 511)
        {
          if (v4 == 403)
          {
            BOOL v15 = LazuliProvisioningWebHelper::requiresPSAccess(v3, (uint64_t)&v29);
            BOOL v16 = *(uint64_t (**)(void))(**(void **)(v3 + 48) + 16);
            if (!v15)
            {
              char v18 = *(NSObject **)v16();
              if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)buf = 136315138;
                *(void *)&uint8_t buf[4] = "C";
                _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#I [%s] Received 403 forbidden response", buf, 0xCu);
              }
              *(_DWORD *)buf = 10;
              LazuliProvisioningServerWrapper::submitMetricForPhase((uint64_t)v7, &v22, 0x100000193, buf, 0, 0);
              LazuliProvisioningServerWrapper::handleForbiddenResponse(v7);
            }
            char v17 = *(NSObject **)v16();
            if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)buf = 136315138;
              *(void *)&uint8_t buf[4] = "C";
              _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I [%s] Received 403 - Needs PS access response", buf, 0xCu);
            }
            *(_DWORD *)buf = 14;
            LazuliProvisioningServerWrapper::submitMetricForPhase((uint64_t)v7, &v22, 0x100000193, buf, 0, 0);
            *((unsigned char *)v7 + 208) = 1;
            LazuliProvisioningServerWrapper::resetRetryTimer(v7);
            goto LABEL_18;
          }
          if (v4 == 200)
          {
            uint64_t v8 = HIBYTE(v28);
            if (v28 < 0) {
              uint64_t v8 = v27;
            }
            if (v8)
            {
              uint64_t v9 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v3 + 48) + 16))(*(void *)(v3 + 48), *(unsigned int *)(v3 + 76));
              if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
              {
                char v10 = off_1019E66B8[v22];
                *(_DWORD *)buf = 136315394;
                *(void *)&uint8_t buf[4] = "C";
                *(_WORD *)&unsigned char buf[12] = 2080;
                *(void *)&buf[14] = v10;
                _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I [%s] Received 200 OK with XML: %s", buf, 0x16u);
              }
              if (*(char *)(v3 + 255) < 0)
              {
                sub_10004FC84(buf, *(void **)(v3 + 232), *(void *)(v3 + 240));
              }
              else
              {
                *(_OWORD *)buf = *(_OWORD *)(v3 + 232);
                *(void *)&buf[16] = *(void *)(v3 + 248);
              }
              char v33 = 1;
              LazuliProvisioningServerWrapper::handleXml((uint64_t)v7, (uint64_t *)&__p, (uint64_t)buf, &v22);
LABEL_49:
              if (v33 && (buf[23] & 0x80000000) != 0) {
                operator delete(*(void **)buf);
              }
LABEL_18:
              sub_10004D2C8(v6);
              goto LABEL_19;
            }
            if (__str[24])
            {
              int v19 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v3 + 48) + 16))(*(void *)(v3 + 48), *(unsigned int *)(v3 + 76));
              if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
              {
                int v20 = "YES";
                if (!__str[24]) {
                  int v20 = "NO";
                }
                *(_DWORD *)buf = 136315394;
                *(void *)&uint8_t buf[4] = "C";
                *(_WORD *)&unsigned char buf[12] = 2080;
                *(void *)&buf[14] = v20;
                _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#I [%s] Received 200 OK [cookie: %s] Now awaiting OTP", buf, 0x16u);
              }
              *(_DWORD *)buf = 10;
              LazuliProvisioningServerWrapper::submitMetricForPhase((uint64_t)v7, &v22, 0x1000000C8, buf, 0, 0);
              LazuliProvisioningWebHelper::startOtpReceptionTimer((LazuliProvisioningWebHelper *)v3);
              goto LABEL_18;
            }
          }
          int v21 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v3 + 48) + 16))(*(void *)(v3 + 48), *(unsigned int *)(v3 + 76));
          if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136315394;
            *(void *)&uint8_t buf[4] = "C";
            *(_WORD *)&unsigned char buf[12] = 1024;
            *(_DWORD *)&buf[14] = v4;
            _os_log_error_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "[%s] Unhandled response in secure response: %d", buf, 0x12u);
          }
          goto LABEL_18;
        }
        int v12 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v3 + 48) + 16))(*(void *)(v3 + 48), *(unsigned int *)(v3 + 76));
        if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
        {
          std::string v13 = "YES";
          if (!__str[24]) {
            std::string v13 = "NO";
          }
          *(_DWORD *)buf = 136315394;
          *(void *)&uint8_t buf[4] = "C";
          *(_WORD *)&unsigned char buf[12] = 2080;
          *(void *)&buf[14] = v13;
          _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I [%s] Received 511 redirect [cookie: %s]", buf, 0x16u);
        }
        int v14 = __str[24];
        *(_DWORD *)buf = 10;
        LazuliProvisioningServerWrapper::submitMetricForPhase((uint64_t)v7, &v22, 0x1000001FFLL, buf, 0, 0);
        sub_1000593FC((uint64_t)buf, (long long *)__str);
        LazuliProvisioningServerWrapper::response511((uint64_t)v7, (uint64_t)buf, 1, v14);
        goto LABEL_49;
      }
    }
  }
  else
  {
    id v6 = 0;
  }
  uint64_t v11 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v3 + 48) + 16))(*(void *)(v3 + 48), *(unsigned int *)(v3 + 76));
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 136315138;
    *(void *)&uint8_t buf[4] = "C";
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I [%s] Failed to get controller", buf, 0xCu);
  }
  if (v6) {
    goto LABEL_18;
  }
LABEL_19:
  if (__str[24] && (__str[23] & 0x80000000) != 0) {
    operator delete(*(void **)__str);
  }
  if (SHIBYTE(v28) < 0) {
    operator delete(__p);
  }
  sub_10010C0E0((uint64_t)&v29, v30);
}

void sub_10058A128(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, char a19, void *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25,char a26,void *a27)
{
  sub_10004D2C8(v27);
  if (a19 && a18 < 0) {
    operator delete(__p);
  }
  if (a25 < 0) {
    operator delete(a20);
  }
  sub_10010C0E0((uint64_t)&a26, a27);
  _Unwind_Resume(a1);
}

void sub_10058A1FC()
{
}

uint64_t sub_10058A204(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10058A244()
{
}

void sub_10058A254()
{
}

void *sub_10058A268(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_1019E6620;
  result[1] = v3;
  return result;
}

uint64_t sub_10058A2B0(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019E6620;
  a2[1] = v2;
  return result;
}

void sub_10058A2DC(uint64_t a1, uint64_t a2)
{
}

uint64_t sub_10058A2E4(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_10058A324()
{
}

void *sub_10058A330(void *a1, void *a2, const char *a3)
{
  id v6 = a1 + 1;
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v9, kCtLoggingSystemName, "TechKeepAlive");
  sub_10058A3F8(v6, a3, QOS_CLASS_UTILITY, &v9);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v9);
  *a1 = &off_1019E6708;
  a1[6] = *a2;
  uint64_t v7 = a2[1];
  a1[7] = v7;
  if (v7) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v7 + 8), 1uLL, memory_order_relaxed);
  }
  return a1;
}

void sub_10058A3E4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void *sub_10058A3F8(void *a1, const char *a2, dispatch_qos_class_t a3, const OsLogContext *a4)
{
  dispatch_object_t object = 0;
  sub_10058A678(a1, a2, a3, &object);
  if (object) {
    dispatch_release(object);
  }
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)&object, a4);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 4), (const ctu::OsLogLogger *)&object);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)&object);
  return a1;
}

void sub_10058A460(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object)
{
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)&object);
  sub_100087E88(v10);
  _Unwind_Resume(a1);
}

void *sub_10058A498(void *a1)
{
  *a1 = &off_1019E6708;
  uint64_t v2 = (std::__shared_weak_count *)a1[7];
  if (v2) {
    sub_10004D2C8(v2);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 5));
  sub_100087E88(a1 + 1);
  return a1;
}

void sub_10058A500(void *a1@<X1>, int *a2@<X2>, void *a3@<X8>)
{
  id v6 = operator new(0xB0uLL);
  sub_10058A57C(v6, a1, a2);
  *a3 = v6 + 3;
  a3[1] = v6;

  sub_1000B3BC8((uint64_t)a3, v6 + 4, (uint64_t)(v6 + 3));
}

void sub_10058A568(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_10058A57C(void *a1, void *a2, int *a3)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = off_1019E67D0;
  sub_1002C5428((uint64_t)(a1 + 3), a2, *a3);
  return a1;
}

void sub_10058A5C8(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void sub_10058A5DC(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1019E67D0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_10058A5FC(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1019E67D0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_10058A650(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 24) + 56))();
}

void *sub_10058A678(void *a1, const char *a2, dispatch_qos_class_t a3, dispatch_object_t *a4)
{
  uint64_t v8 = *a4;
  if (*a4) {
    dispatch_retain(*a4);
  }
  initially_inactive = dispatch_queue_attr_make_initially_inactive(0);
  char v10 = dispatch_queue_create_with_target_V2(a2, initially_inactive, v8);
  dispatch_set_qos_class_floor(v10, a3, 0);
  dispatch_activate(v10);
  *a1 = 0;
  a1[1] = 0;
  a1[2] = v10;
  if (v10) {
    dispatch_retain(v10);
  }
  uint64_t v11 = *a4;
  a1[3] = *a4;
  if (v11) {
    dispatch_retain(v11);
  }
  if (v10) {
    dispatch_release(v10);
  }
  if (v8) {
    dispatch_release(v8);
  }
  return a1;
}

BOOL sub_10058A734()
{
  return sub_10121F67C() != 0;
}

BOOL sub_10058A754()
{
  return sub_10121F6B4() != 0;
}

BOOL sub_10058A774()
{
  return sub_10121F6EC() != 0;
}

BOOL sub_10058A794()
{
  return sub_10121F74C() != 0;
}

BOOL sub_10058A7B4()
{
  return sub_10121F784() != 0;
}

void *sub_10058A7DC@<X0>(GestaltUtilityInterface *a1@<X0>, void *a2@<X8>)
{
  if (GestaltUtilityInterface::isIPhone(a1))
  {
    int v4 = "iPhone";
  }
  else if (GestaltUtilityInterface::isIPad(a1))
  {
    int v4 = "iPad";
  }
  else if (GestaltUtilityInterface::isWatch(a1))
  {
    int v4 = "Watch";
  }
  else if (GestaltUtilityInterface::isMac(a1))
  {
    int v4 = "Mac";
  }
  else
  {
    int v4 = "";
  }

  return sub_100058DB0(a2, v4);
}

void sub_10058A87C(GestaltUtilityInterface *a1)
{
  GestaltUtilityInterface::~GestaltUtilityInterface(a1);

  operator delete();
}

void sub_10058A8B4(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1019E6970;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_10058A8D4(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1019E6970;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_10058A928(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_10058A954()
{
}

uint64_t sub_10058A970(void *a1, uint64_t a2)
{
  if (a1[1]) {
    __TUAssertTrigger();
  }
  a1[1] = a2;
  int v4 = *(uint64_t (**)(void *))(*a1 + 88);

  return v4(a1);
}

uint64_t sub_10058A9E4(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 16))();
  }
  return result;
}

void MaxDataRateManager::submit5GSDMStatusToCA_sync(Registry **this@<X0>, uint64_t *a2@<X8>)
{
  uint64_t v3 = this + 7;
  ServiceMap = (std::mutex *)Registry::getServiceMap(a2, this[7]);
  char v5 = ServiceMap;
  if (v6 < 0)
  {
    uint64_t v7 = (unsigned __int8 *)(v6 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v8 = 5381;
    do
    {
      uint64_t v6 = v8;
      unsigned int v9 = *v7++;
      uint64_t v8 = (33 * v8) ^ v9;
    }
    while (v9);
  }
  std::mutex::lock(ServiceMap);
  *(void *)buf = v6;
  char v10 = sub_10004D37C(&v5[1].__m_.__sig, (unint64_t *)buf);
  if (!v10)
  {
    uint64_t v12 = 0;
LABEL_9:
    std::mutex::unlock(v5);
    uint64_t v11 = 0;
    char v14 = 1;
    if (!v12) {
      goto LABEL_78;
    }
    goto LABEL_10;
  }
  uint64_t v12 = v10[3];
  uint64_t v11 = (std::__shared_weak_count *)v10[4];
  if (!v11) {
    goto LABEL_9;
  }
  atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v5);
  atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v11);
  char v14 = 0;
  if (!v12) {
    goto LABEL_78;
  }
LABEL_10:
  BOOL v15 = (std::mutex *)Registry::getServiceMap(v13, *v3);
  BOOL v16 = v15;
  if (v17 < 0)
  {
    char v18 = (unsigned __int8 *)(v17 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v19 = 5381;
    do
    {
      uint64_t v17 = v19;
      unsigned int v20 = *v18++;
      uint64_t v19 = (33 * v19) ^ v20;
    }
    while (v20);
  }
  std::mutex::lock(v15);
  *(void *)buf = v17;
  int v21 = sub_10004D37C(&v16[1].__m_.__sig, (unint64_t *)buf);
  if (v21 && (int v22 = (std::__shared_weak_count *)v21[4]) != 0)
  {
    atomic_fetch_add_explicit(&v22->__shared_owners_, 1uLL, memory_order_relaxed);
    std::mutex::unlock(v16);
    atomic_fetch_add_explicit(&v22->__shared_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v22);
    char v24 = 0;
  }
  else
  {
    std::mutex::unlock(v16);
    int v22 = 0;
    char v24 = 1;
  }
  xpc_object_t v61 = v22;
  char v25 = (std::mutex *)Registry::getServiceMap(v23, *v3);
  std::string v26 = v25;
  if (v27 < 0)
  {
    uint64_t v28 = (unsigned __int8 *)(v27 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v29 = 5381;
    do
    {
      uint64_t v27 = v29;
      unsigned int v30 = *v28++;
      uint64_t v29 = (33 * v29) ^ v30;
    }
    while (v30);
  }
  std::mutex::lock(v25);
  *(void *)buf = v27;
  uint64_t v31 = sub_10004D37C(&v26[1].__m_.__sig, (unint64_t *)buf);
  if (v31)
  {
    uint64_t v32 = v11;
    uint64_t v34 = v31[3];
    char v33 = (std::__shared_weak_count *)v31[4];
    if (v33)
    {
      atomic_fetch_add_explicit(&v33->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v26);
      atomic_fetch_add_explicit(&v33->__shared_owners_, 1uLL, memory_order_relaxed);
      long long v35 = v33;
      sub_10004D2C8(v33);
      char v36 = 0;
      uint64_t v11 = v32;
      if (!v34) {
        goto LABEL_23;
      }
      goto LABEL_30;
    }
    uint64_t v11 = v32;
  }
  else
  {
    uint64_t v34 = 0;
  }
  std::mutex::unlock(v26);
  long long v35 = 0;
  char v36 = 1;
  if (!v34)
  {
LABEL_23:
    uint64_t v37 = this[5];
    if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEFAULT, "#N PersonalityShop is not ready", buf, 2u);
    }
    if (v36) {
      goto LABEL_76;
    }
    goto LABEL_75;
  }
LABEL_30:
  char v58 = v36;
  char v59 = v24;
  uint64_t v57 = v35;
  char v60 = v14;
  subscriber::makeSimSlotRange();
  uint64_t v38 = *(unsigned int **)buf;
  uint64_t v39 = v67;
  if (*(unsigned int **)buf != v67)
  {
    xpc_object_t v40 = v68;
    while ((v40(*v38) & 1) == 0)
    {
      if (++v38 == v39)
      {
        uint64_t v38 = v39;
        break;
      }
    }
    uint64_t v41 = v67;
    if (v38 != v67)
    {
      xpc_object_t v42 = (char **)(this + 21);
      int v56 = (char **)(this + 28);
      do
      {
        uint64_t v43 = *v38;
        uint64_t v64 = 0;
        dispatch_object_t v65 = 0;
        MaxDataRateManager::getModel_sync((uint64_t)this, v43, &v64);
        if (v64)
        {
          uint64_t v62 = 0;
          dispatch_object_t v63 = 0;
          (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(*(void *)v34 + 8))(&v62, v34, v43);
          if (v62)
          {
            if (*(unsigned char *)(v62 + 48))
            {
              uint64_t v44 = *v42;
              if (*v42)
              {
                uint64_t v45 = (char **)(this + 21);
                do
                {
                  int v46 = *((_DWORD *)v44 + 8);
                  BOOL v47 = v46 < (int)v43;
                  if (v46 >= (int)v43) {
                    xpc_object_t v48 = (char **)v44;
                  }
                  else {
                    xpc_object_t v48 = (char **)(v44 + 8);
                  }
                  if (!v47) {
                    uint64_t v45 = (char **)v44;
                  }
                  uint64_t v44 = *v48;
                }
                while (*v48);
                if (v45 != v42 && (int)v43 >= *((_DWORD *)v45 + 8))
                {
                  xpc_object_t v49 = (char **)(this + 28);
                  xpc_object_t v50 = *v56;
                  if (*v56)
                  {
                    do
                    {
                      int v51 = *((_DWORD *)v50 + 7);
                      BOOL v52 = v51 < (int)v43;
                      if (v51 >= (int)v43) {
                        xpc_object_t v53 = (char **)v50;
                      }
                      else {
                        xpc_object_t v53 = (char **)(v50 + 8);
                      }
                      if (!v52) {
                        xpc_object_t v49 = (char **)v50;
                      }
                      xpc_object_t v50 = *v53;
                    }
                    while (*v53);
                    if (v49 != v56 && (int)v43 >= *((_DWORD *)v49 + 7))
                    {
                      int v54 = *((unsigned __int8 *)v49 + 33);
                      if (*(_DWORD *)(v64 + 376) == 2 || !v54 && *(_DWORD *)(v64 + 496) == 2) {
                        operator new();
                      }
                    }
                  }
                }
              }
            }
          }
          if (v63) {
            sub_10004D2C8(v63);
          }
        }
        if (v65) {
          sub_10004D2C8(v65);
        }
        xpc_object_t v55 = v38 + 1;
        uint64_t v38 = v39;
        if (v55 != v39)
        {
          uint64_t v38 = v55;
          while ((v40(*v38) & 1) == 0)
          {
            if (++v38 == v39)
            {
              uint64_t v38 = v39;
              break;
            }
          }
        }
      }
      while (v38 != v41);
    }
  }
  char v24 = v59;
  char v14 = v60;
  int v22 = v61;
  long long v35 = v57;
  if (v58) {
    goto LABEL_76;
  }
LABEL_75:
  sub_10004D2C8(v35);
LABEL_76:
  if ((v24 & 1) == 0) {
    sub_10004D2C8(v22);
  }
LABEL_78:
  if ((v14 & 1) == 0) {
    sub_10004D2C8(v11);
  }
}

void sub_10058AFB0()
{
}

void MaxDataRateManager::submitSwitchStateToCA_sync(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a2)
  {
    uint64_t v3 = *(uint64_t **)(a3 + 24);
    if (v3)
    {
      char v5 = (Registry **)(a1 + 56);
      ServiceMap = (std::mutex *)Registry::getServiceMap(v3, *(Registry **)(a1 + 56));
      uint64_t v7 = ServiceMap;
      if (v8 < 0)
      {
        unsigned int v9 = (unsigned __int8 *)(v8 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v10 = 5381;
        do
        {
          uint64_t v8 = v10;
          unsigned int v11 = *v9++;
          uint64_t v10 = (33 * v10) ^ v11;
        }
        while (v11);
      }
      std::mutex::lock(ServiceMap);
      *(void *)buf = v8;
      uint64_t v12 = sub_10004D37C(&v7[1].__m_.__sig, (unint64_t *)buf);
      if (v12)
      {
        uint64_t v13 = v12[3];
        char v14 = (std::__shared_weak_count *)v12[4];
        if (v14)
        {
          atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v7);
          atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v14);
          char v16 = 0;
          if (!v13)
          {
LABEL_66:
            if ((v16 & 1) == 0) {
              sub_10004D2C8(v14);
            }
            return;
          }
LABEL_12:
          xpc_object_t v55 = v14;
          uint64_t v17 = (std::mutex *)Registry::getServiceMap(v15, *v5);
          char v18 = v17;
          if (v19 < 0)
          {
            unsigned int v20 = (unsigned __int8 *)(v19 & 0x7FFFFFFFFFFFFFFFLL);
            uint64_t v21 = 5381;
            do
            {
              uint64_t v19 = v21;
              unsigned int v22 = *v20++;
              uint64_t v21 = (33 * v21) ^ v22;
            }
            while (v22);
          }
          std::mutex::lock(v17);
          *(void *)buf = v19;
          __int16 v23 = sub_10004D37C(&v18[1].__m_.__sig, (unint64_t *)buf);
          if (v23 && (char v24 = (std::__shared_weak_count *)v23[4]) != 0)
          {
            atomic_fetch_add_explicit(&v24->__shared_owners_, 1uLL, memory_order_relaxed);
            std::mutex::unlock(v18);
            atomic_fetch_add_explicit(&v24->__shared_owners_, 1uLL, memory_order_relaxed);
            BOOL v52 = v24;
            sub_10004D2C8(v24);
            char v26 = 0;
          }
          else
          {
            std::mutex::unlock(v18);
            BOOL v52 = 0;
            char v26 = 1;
          }
          uint64_t v27 = (std::mutex *)Registry::getServiceMap(v25, *v5);
          uint64_t v28 = v27;
          if (v29 < 0)
          {
            unsigned int v30 = (unsigned __int8 *)(v29 & 0x7FFFFFFFFFFFFFFFLL);
            uint64_t v31 = 5381;
            do
            {
              uint64_t v29 = v31;
              unsigned int v32 = *v30++;
              uint64_t v31 = (33 * v31) ^ v32;
            }
            while (v32);
          }
          std::mutex::lock(v27);
          *(void *)buf = v29;
          char v33 = sub_10004D37C(&v28[1].__m_.__sig, (unint64_t *)buf);
          if (v33)
          {
            uint64_t v34 = v33[3];
            long long v35 = (std::__shared_weak_count *)v33[4];
            if (v35)
            {
              atomic_fetch_add_explicit(&v35->__shared_owners_, 1uLL, memory_order_relaxed);
              std::mutex::unlock(v28);
              atomic_fetch_add_explicit(&v35->__shared_owners_, 1uLL, memory_order_relaxed);
              char v36 = v35;
              sub_10004D2C8(v35);
              char v53 = 0;
LABEL_27:
              char v14 = v55;
              if (v34)
              {
                xpc_object_t v49 = v36;
                char v50 = v26;
                char v51 = v16;
                subscriber::makeSimSlotRange();
                uint64_t v38 = *(unsigned int **)buf;
                uint64_t v37 = v61;
                if (*(unsigned int **)buf != v61)
                {
                  uint64_t v39 = v62;
                  while ((v39(*v38) & 1) == 0)
                  {
                    if (++v38 == v37)
                    {
                      uint64_t v38 = v37;
                      break;
                    }
                  }
                  xpc_object_t v40 = v61;
                  if (v38 != v61)
                  {
                    int v54 = (uint64_t *)(a1 + 168);
                    do
                    {
                      uint64_t v41 = *v38;
                      uint64_t v58 = 0;
                      char v59 = 0;
                      MaxDataRateManager::getModel_sync(a1, v41, &v58);
                      if (v58)
                      {
                        uint64_t v56 = 0;
                        uint64_t v57 = 0;
                        (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(*(void *)v34 + 8))(&v56, v34, v41);
                        if (v56)
                        {
                          if (*(unsigned char *)(v56 + 48))
                          {
                            uint64_t v42 = a1 + 168;
                            uint64_t v43 = *v54;
                            if (*v54)
                            {
                              do
                              {
                                int v44 = *(_DWORD *)(v43 + 32);
                                BOOL v45 = v44 < (int)v41;
                                if (v44 >= (int)v41) {
                                  int v46 = (uint64_t *)v43;
                                }
                                else {
                                  int v46 = (uint64_t *)(v43 + 8);
                                }
                                if (!v45) {
                                  uint64_t v42 = v43;
                                }
                                uint64_t v43 = *v46;
                              }
                              while (*v46);
                              if ((uint64_t *)v42 != v54 && (int)v41 >= *(_DWORD *)(v42 + 32)) {
                                operator new();
                              }
                            }
                          }
                        }
                        if (v57) {
                          sub_10004D2C8(v57);
                        }
                      }
                      if (v59) {
                        sub_10004D2C8(v59);
                      }
                      BOOL v47 = v38 + 1;
                      uint64_t v38 = v37;
                      if (v47 != v37)
                      {
                        uint64_t v38 = v47;
                        while ((v39(*v38) & 1) == 0)
                        {
                          if (++v38 == v37)
                          {
                            uint64_t v38 = v37;
                            break;
                          }
                        }
                      }
                    }
                    while (v38 != v40);
                  }
                }
                char v14 = v55;
                char v26 = v50;
                char v16 = v51;
                char v36 = v49;
              }
              else
              {
                xpc_object_t v48 = *(NSObject **)(a1 + 40);
                if (os_log_type_enabled(v48, OS_LOG_TYPE_DEFAULT))
                {
                  *(_WORD *)buf = 0;
                  _os_log_impl((void *)&_mh_execute_header, v48, OS_LOG_TYPE_DEFAULT, "#N PersonalityShop is not ready", buf, 2u);
                }
              }
              if ((v53 & 1) == 0) {
                sub_10004D2C8(v36);
              }
              if ((v26 & 1) == 0) {
                sub_10004D2C8(v52);
              }
              goto LABEL_66;
            }
          }
          else
          {
            uint64_t v34 = 0;
          }
          std::mutex::unlock(v28);
          char v36 = 0;
          char v53 = 1;
          goto LABEL_27;
        }
      }
      else
      {
        uint64_t v13 = 0;
      }
      std::mutex::unlock(v7);
      char v14 = 0;
      char v16 = 1;
      if (!v13) {
        goto LABEL_66;
      }
      goto LABEL_12;
    }
  }
}

void sub_10058B5D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11, char a12, __int16 a13, char a14, std::__shared_weak_count *a15, int a16, char a17, uint64_t a18, std::__shared_weak_count *a19, uint64_t a20,std::__shared_weak_count *a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,std::__shared_weak_count *a29)
{
  if (a21) {
    sub_10004D2C8(a21);
  }
  (*(void (**)(uint64_t))(*(void *)v29 + 8))(v29);
  if (a29) {
    sub_10004D2C8(a29);
  }
  unsigned int v32 = *(std::__shared_weak_count **)(v30 - 120);
  if (v32) {
    sub_10004D2C8(v32);
  }
  if ((a17 & 1) == 0) {
    sub_10004D2C8(a11);
  }
  if ((a12 & 1) == 0) {
    sub_10004D2C8(a15);
  }
  if ((a14 & 1) == 0) {
    sub_10004D2C8(a19);
  }
  _Unwind_Resume(a1);
}

void *MaxDataRateManager::submit5GSwitchStateToCA_sync(MaxDataRateManager *this)
{
  v2[0] = off_1019E6AA0;
  v2[3] = v2;
  MaxDataRateManager::submitSwitchStateToCA_sync((uint64_t)this, (uint64_t)"CommCenterNrSwitch", (uint64_t)v2);
  return sub_10058BBFC(v2);
}

void sub_10058B760(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_10058BBFC((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *MaxDataRateManager::submit4GSwitchStateToCA_sync(MaxDataRateManager *this)
{
  v2[0] = off_1019E6B30;
  v2[3] = v2;
  MaxDataRateManager::submitSwitchStateToCA_sync((uint64_t)this, (uint64_t)"CommCenter4GSwitch", (uint64_t)v2);
  return sub_10058BBFC(v2);
}

void sub_10058B800(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_10058BBFC((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *MaxDataRateManager::submit3GSwitchStateToCA_sync(MaxDataRateManager *this)
{
  v2[0] = off_1019E6BB0;
  v2[3] = v2;
  MaxDataRateManager::submitSwitchStateToCA_sync((uint64_t)this, (uint64_t)"CommCenter3GSwitch", (uint64_t)v2);
  return sub_10058BBFC(v2);
}

void sub_10058B8A0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_10058BBFC((uint64_t *)va);
  _Unwind_Resume(a1);
}

void MaxDataRateManager::submit2GSwitchStateToCA_sync(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(a2, *(Registry **)(a1 + 56));
  uint64_t v3 = ServiceMap;
  if ((v4 & 0x8000000000000000) != 0)
  {
    char v5 = (unsigned __int8 *)(v4 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v6 = 5381;
    do
    {
      unint64_t v4 = v6;
      unsigned int v7 = *v5++;
      uint64_t v6 = (33 * v6) ^ v7;
    }
    while (v7);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v11 = v4;
  uint64_t v8 = sub_10004D37C(&v3[1].__m_.__sig, &v11);
  if (v8)
  {
    uint64_t v10 = v8[3];
    unsigned int v9 = (std::__shared_weak_count *)v8[4];
    if (v9)
    {
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v3);
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v9);
      if (!v10)
      {
        sub_10004D2C8(v9);
        return;
      }
LABEL_10:
      operator new();
    }
    std::mutex::unlock(v3);
    if (v10) {
      goto LABEL_10;
    }
  }
  else
  {
    std::mutex::unlock(v3);
  }
}

void sub_10058BA60()
{
}

void sub_10058BAD0()
{
}

void *sub_10058BAE4()
{
  uint64_t result = operator new(0x10uLL);
  void *result = off_1019E6AA0;
  return result;
}

void sub_10058BB1C(uint64_t a1, void *a2)
{
  *a2 = off_1019E6AA0;
}

uint64_t sub_10058BB44(uint64_t a1, uint64_t *a2, BOOL a3)
{
  uint64_t v3 = *a2;
  unint64_t v4 = (std::__shared_weak_count *)a2[1];
  *a2 = 0;
  a2[1] = 0;
  uint64_t SwitchStatus = analytics::getSwitchStatus((analytics *)(*(unsigned char *)(v3 + 136) == 2), *(_DWORD *)(v3 + 376) == 2, a3);
  if (v4) {
    sub_10004D2C8(v4);
  }
  return SwitchStatus;
}

void sub_10058BB98(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10058BBB0(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_10058BBF0()
{
}

void *sub_10058BBFC(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void sub_10058BC84()
{
}

void *sub_10058BC98()
{
  uint64_t result = operator new(0x10uLL);
  void *result = off_1019E6B30;
  return result;
}

void sub_10058BCD0(uint64_t a1, void *a2)
{
  *a2 = off_1019E6B30;
}

uint64_t sub_10058BCF8(uint64_t a1, uint64_t *a2, BOOL a3)
{
  uint64_t v3 = *a2;
  unint64_t v4 = (std::__shared_weak_count *)a2[1];
  *a2 = 0;
  a2[1] = 0;
  uint64_t SwitchStatus = analytics::getSwitchStatus((analytics *)(*(unsigned char *)(v3 + 16) == 2), *(_DWORD *)(v3 + 496) == 2, a3);
  if (v4) {
    sub_10004D2C8(v4);
  }
  return SwitchStatus;
}

void sub_10058BD4C(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10058BD64(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_10058BDA4()
{
}

void sub_10058BDB4()
{
}

void *sub_10058BDC8()
{
  uint64_t result = operator new(0x10uLL);
  void *result = off_1019E6BB0;
  return result;
}

void sub_10058BE00(uint64_t a1, void *a2)
{
  *a2 = off_1019E6BB0;
}

uint64_t sub_10058BE28(uint64_t a1, uint64_t *a2, BOOL a3)
{
  uint64_t v3 = *a2;
  unint64_t v4 = (std::__shared_weak_count *)a2[1];
  *a2 = 0;
  a2[1] = 0;
  uint64_t SwitchStatus = analytics::getSwitchStatus((analytics *)(*(unsigned char *)(v3 + 256) == 2), *(_DWORD *)(v3 + 616) == 2, a3);
  if (v4) {
    sub_10004D2C8(v4);
  }
  return SwitchStatus;
}

void sub_10058BE7C(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10058BE94(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_10058BED4()
{
}

void stewie::TargetData::create()
{
}

void sub_10058BFA4()
{
}

void sub_10058BFE4(uint64_t a1@<X0>, void *a2@<X8>)
{
  if (qword_101B13DD0 != -1) {
    dispatch_once(&qword_101B13DD0, &stru_1019E6C40);
  }
  unint64_t v4 = (void (*)(uint64_t))off_101B13DD8;
  if (off_101B13DD8)
  {
    v4(a1);
  }
  else
  {
    *a2 = 0;
    a2[1] = 0;
  }
}

void sub_10058C064(id a1)
{
  uint64_t v1 = dlopen("/System/Library/Frameworks/CoreTelephony.framework/Support/libCommCenterCNTargetData.dylib", 1);
  qword_101B0D188 = (uint64_t)v1;
  if (!v1)
  {
    sub_10058C1E8();
    uint64_t v4 = qword_101B0D190;
    if (!os_log_type_enabled((os_log_t)qword_101B0D190, OS_LOG_TYPE_FAULT)) {
      return;
    }
    int v8 = 136446210;
    unsigned int v9 = dlerror();
    char v5 = "Failed to load libCommCenterCNTargetData.dylib: %{public}s";
    uint64_t v6 = v4;
    uint32_t v7 = 12;
    goto LABEL_10;
  }
  uint64_t v2 = dlsym(v1, "createCoreNavigationTargetData");
  off_101B13DD8 = v2;
  sub_10058C1E8();
  uint64_t v3 = qword_101B0D190;
  if (!v2)
  {
    if (!os_log_type_enabled((os_log_t)qword_101B0D190, OS_LOG_TYPE_FAULT)) {
      return;
    }
    int v8 = 136315394;
    unsigned int v9 = "createCoreNavigationTargetData";
    __int16 v10 = 2082;
    unint64_t v11 = dlerror();
    char v5 = "Failed to lookup %s function: %{public}s";
    uint64_t v6 = v3;
    uint32_t v7 = 22;
LABEL_10:
    _os_log_fault_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_FAULT, v5, (uint8_t *)&v8, v7);
    return;
  }
  if (os_log_type_enabled((os_log_t)qword_101B0D190, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v8) = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I createCoreNavigationTargetData loaded successfully", (uint8_t *)&v8, 2u);
  }
}

void sub_10058C1E8()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_101B0D198, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_101B0D198))
  {
    ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)&qword_101B0D190, kCtLoggingSystemName, "stw.ca");
    __cxa_guard_release(&qword_101B0D198);
  }
}

void sub_10058C268(_Unwind_Exception *a1)
{
}

void sub_10058C280(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    uint64_t v2 = *(std::__shared_weak_count **)(a2 + 16);
    if (v2) {
      sub_10004D2C8(v2);
    }
    operator delete();
  }
}

void sub_10058C2D8(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_10058C348(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  a10 = 0;
  if (v10) {
    sub_10058C3F0((uint64_t)&a10, v10);
  }
  _Unwind_Resume(exception_object);
}

void sub_10058C36C(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_10058C3A4(uint64_t a1)
{
}

uint64_t sub_10058C3AC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

void sub_10058C3F0(uint64_t a1, uint64_t *a2)
{
  if (a2)
  {
    uint64_t v3 = *a2;
    *a2 = 0;
    if (v3) {
      sub_10058C280((uint64_t)a2, v3);
    }
    operator delete();
  }
}

void sub_10058C450(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  operator new();
}

void sub_10058C930(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object, uint64_t a11, dispatch_object_t a12, dispatch_object_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
}

const char *sub_10058CB6C(int a1)
{
  uint64_t v1 = "npp.?";
  if (a1 == 2) {
    uint64_t v1 = "npp.2";
  }
  if (a1 == 1) {
    return "npp.1";
  }
  else {
    return v1;
  }
}

void sub_10058CB98(uint64_t a1, dispatch_object_t object)
{
  if (object)
  {
    dispatch_retain(object);
    dispatch_group_enter(object);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

uint64_t sub_10058CC98(uint64_t a1, int a2)
{
  uint64_t v5 = a1;
  int v6 = a2;
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 0x40000000;
  v7[2] = sub_10058E98C;
  double v7[3] = &unk_1019E70F0;
  void v7[4] = a1 + 8;
  v7[5] = &v5;
  int v8 = v7;
  uint64_t v3 = a1 + 24;
  uint64_t v2 = *(NSObject **)(a1 + 24);
  if (*(void *)(v3 + 8))
  {
    unsigned __int16 v15 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v10 = 0x40000000;
    unint64_t v11 = sub_10058EA0C;
    uint64_t v12 = &unk_1019E7130;
    uint64_t v13 = &v15;
    char v14 = &v8;
    dispatch_async_and_wait(v2, &block);
  }
  else
  {
    unsigned __int16 v15 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v10 = 0x40000000;
    unint64_t v11 = sub_10058E9D0;
    uint64_t v12 = &unk_1019E7110;
    uint64_t v13 = &v15;
    char v14 = &v8;
    dispatch_sync(v2, &block);
  }
  return v15;
}

void sub_10058CDC8(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

uint64_t sub_10058CEC0(uint64_t a1, uint64_t a2)
{
  __dst[0] = 0;
  __dst[1] = 0;
  uint64_t v23 = 0;
  uint64_t v4 = (Registry **)(a1 + 56);
  PersonalityIdFromSlotId();
  if (SHIBYTE(v21) < 0)
  {
    sub_10004FC84(__dst, __p[0], (unint64_t)__p[1]);
    operator delete(__p[0]);
  }
  else
  {
    *(_OWORD *)__dst = *(_OWORD *)__p;
    uint64_t v23 = v21;
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(*v4);
  int v6 = ServiceMap;
  if (v7 < 0)
  {
    int v8 = (unsigned __int8 *)(v7 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v9 = 5381;
    do
    {
      uint64_t v7 = v9;
      unsigned int v10 = *v8++;
      uint64_t v9 = (33 * v9) ^ v10;
    }
    while (v10);
  }
  std::mutex::lock(ServiceMap);
  __p[0] = (void *)v7;
  unint64_t v11 = sub_10004D37C(&v6[1].__m_.__sig, (unint64_t *)__p);
  if (v11)
  {
    uint64_t v13 = v11[3];
    uint64_t v12 = (std::__shared_weak_count *)v11[4];
    if (v12)
    {
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v6);
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v12);
      char v14 = 0;
      if (!v13) {
        goto LABEL_10;
      }
LABEL_16:
      unsigned __int16 v17 = (*(uint64_t (**)(uint64_t, void **))(*(void *)v13 + 248))(v13, __dst);
      if ((_BYTE)v17) {
        BOOL v18 = 0;
      }
      else {
        BOOL v18 = v17 >= 0x100u;
      }
      uint64_t v16 = !v18;
      if (v14) {
        goto LABEL_24;
      }
      goto LABEL_23;
    }
  }
  else
  {
    uint64_t v13 = 0;
  }
  std::mutex::unlock(v6);
  uint64_t v12 = 0;
  char v14 = 1;
  if (v13) {
    goto LABEL_16;
  }
LABEL_10:
  unsigned __int16 v15 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
  if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
  {
    LOWORD(__p[0]) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "Could not get cellular usage store to get privacy proxy settings", (uint8_t *)__p, 2u);
  }
  uint64_t v16 = 1;
  if ((v14 & 1) == 0) {
LABEL_23:
  }
    sub_10004D2C8(v12);
LABEL_24:
  if (SHIBYTE(v23) < 0) {
    operator delete(__dst[0]);
  }
  return v16;
}

void sub_10058D0C8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if ((v22 & 1) == 0) {
    sub_10004D2C8(v21);
  }
  if (a21 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_10058D114(uint64_t a1, uint64_t a2)
{
  if (*(unsigned __int8 *)(a1 + 136) != a2)
  {
    *(unsigned char *)(a1 + 136) = a2;
    (*(void (**)(void, void, uint64_t))(**(void **)(a1 + 88) + 48))(*(void *)(a1 + 88), *(unsigned __int8 *)(a1 + 137), a2);
    sub_10058D1EC(a1);
  }
}

void sub_10058D194(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 104);
  if (v3 != a2)
  {
    uint64_t v5 = sub_10058CEC0(a1, v3);
    sub_10058D114(a1, v5);
  }
}

void sub_10058D1EC(uint64_t a1)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 56));
  uint64_t v3 = ServiceMap;
  if (v4 < 0)
  {
    uint64_t v5 = (unsigned __int8 *)(v4 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v6 = 5381;
    do
    {
      uint64_t v4 = v6;
      unsigned int v7 = *v5++;
      uint64_t v6 = (33 * v6) ^ v7;
    }
    while (v7);
  }
  std::mutex::lock(ServiceMap);
  *(void *)buf = v4;
  int v8 = sub_10004D37C(&v3[1].__m_.__sig, (unint64_t *)buf);
  if (v8)
  {
    uint64_t v10 = v8[3];
    uint64_t v9 = (std::__shared_weak_count *)v8[4];
    if (v9)
    {
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v3);
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v9);
      char v11 = 0;
      if (!v10) {
        goto LABEL_7;
      }
      goto LABEL_12;
    }
  }
  else
  {
    uint64_t v10 = 0;
  }
  std::mutex::unlock(v3);
  uint64_t v9 = 0;
  char v11 = 1;
  if (!v10)
  {
LABEL_7:
    uint64_t v12 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "Could not get personality shop", buf, 2u);
      if (v11) {
        return;
      }
      goto LABEL_26;
    }
LABEL_25:
    if (v11) {
      return;
    }
    goto LABEL_26;
  }
LABEL_12:
  v20[0] = 0;
  v20[1] = 0;
  uint64_t v21 = 0;
  PersonalityIdFromSlotId();
  uint64_t v19 = 0;
  (*(void (**)(const void **__return_ptr, uint64_t, void **))(*(void *)v10 + 200))(&v19, v10, v20);
  int v13 = *(unsigned __int8 *)(a1 + 136);
  if (v19) {
    char v14 = sub_1000810B8;
  }
  else {
    char v14 = 0;
  }
  if (v14)
  {
    memset(buf, 0, sizeof(buf));
    uint64_t v23 = 0;
    ctu::cf::assign();
    *(_OWORD *)std::string __p = *(_OWORD *)buf;
    uint64_t v18 = v23;
  }
  else
  {
    sub_100058DB0(__p, "unlabeled");
  }
  unsigned __int16 v15 = *(NSObject **)(a1 + 24);
  dispatch_object_t object = v15;
  if (v15) {
    dispatch_retain(v15);
  }
  notifyPrivacyProxyOfChangeByUser(v13 != 0, (uint64_t *)__p);
  if (object) {
    dispatch_release(object);
  }
  if (SHIBYTE(v18) < 0) {
    operator delete(__p[0]);
  }
  sub_1000558F4(&v19);
  if ((SHIBYTE(v21) & 0x80000000) == 0) {
    goto LABEL_25;
  }
  operator delete(v20[0]);
  if (v11) {
    return;
  }
LABEL_26:
  sub_10004D2C8(v9);
}

void sub_10058D420(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object, uint64_t a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, const void *a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24,void *a25,uint64_t a26,int a27,__int16 a28,char a29,char a30)
{
  sub_1000558F4(&a18);
  if (a24 < 0) {
    operator delete(__p);
  }
  if ((v31 & 1) == 0) {
    sub_10004D2C8(v30);
  }
  _Unwind_Resume(a1);
}

void sub_10058D49C(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = "true";
    if (*(unsigned char *)(a1 + 137)) {
      uint64_t v4 = "true";
    }
    else {
      uint64_t v4 = "false";
    }
    if (!*(unsigned char *)(a1 + 136)) {
      uint64_t v3 = "false";
    }
    int v5 = 136315394;
    uint64_t v6 = v4;
    __int16 v7 = 2080;
    int v8 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Privacy Proxy: feature enabled: %s, state: %s", (uint8_t *)&v5, 0x16u);
  }
}

void sub_10058D570(void *a1)
{
  sub_10058D5A8(a1);

  operator delete();
}

void sub_10058D5A8(void *a1)
{
  *a1 = off_1019E6CE8;
  NotifySubscription::~NotifySubscription((NotifySubscription *)(a1 + 14));
  uint64_t v2 = (std::__shared_weak_count *)a1[12];
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)a1[10];
  if (v3) {
    sub_10004D2C8(v3);
  }
  uint64_t v4 = (std::__shared_weak_count *)a1[8];
  if (v4) {
    sub_10004D2C8(v4);
  }
  uint64_t v5 = a1[6];
  a1[6] = 0;
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 5));
  sub_100087E88(a1 + 1);

  PrivacyProxyInterface::~PrivacyProxyInterface((PrivacyProxyInterface *)a1);
}

void sub_10058D668(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_10058D6A0(uint64_t a1)
{
}

uint64_t sub_10058D6BC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_10058D700(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void sub_10058D72C(ServiceManager::Service *this)
{
  *(void *)this = off_1019E6E40;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }

  ServiceManager::Service::~Service(this);
}

void sub_10058D788(ServiceManager::Service *this)
{
  *(void *)this = off_1019E6E40;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  ServiceManager::Service::~Service(this);

  operator delete();
}

void *sub_10058D7F8@<X0>(void *a1@<X8>)
{
  return sub_100058DB0(a1, "PrivacyProxyController");
}

unsigned char *sub_10058D808@<X0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  uint64_t v2 = operator new(1uLL);
  *a1 = v2;
  unsigned char *v2 = 2;
  uint64_t result = v2 + 1;
  a1[1] = result;
  a1[2] = result;
  return result;
}

void sub_10058D848(uint64_t a1, dispatch_object_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v3 = *a2;
  if (*a2)
  {
    dispatch_retain(*a2);
    dispatch_group_enter(v3);
    sub_10058CB98(v2, v3);
  }
  uint64_t v4 = *(void *)(a1 + 8);

  sub_10058CB98(v4, 0);
}

uint64_t sub_10058D8CC()
{
  return 0;
}

uint64_t sub_10058D8D4()
{
  return 1;
}

uint64_t sub_10058D8DC()
{
  return 0;
}

void sub_10058D8E8(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(*(void *)(a1 + 8) + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_10058D9C8(uint64_t a1, int a2, ServiceStage *this)
{
  uint64_t v3 = *(void *)(a1 + 8);
  ServiceStage::holdOffStage((uint64_t *)&group[1], this);
  uint64_t v4 = *(std::__shared_weak_count **)(v3 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_10058DAE0()
{
}

uint64_t sub_10058DAF4(uint64_t a1)
{
  return *(void *)(a1 + 8) + 40;
}

uint64_t *sub_10058DB00(uint64_t *a1)
{
  uint64_t v1 = *a1;
  char v14 = a1;
  uint64_t v15 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v3 = *(NSObject **)(*(void *)v1 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Bootstrapping...", buf, 2u);
  }
  Registry::createRestModuleOneTimeUseConnection(&v16, *(Registry **)(v2 + 56));
  ctu::RestModule::connect();
  if (v17) {
    sub_10004D2C8(v17);
  }
  sub_100058DB0(__p, "/cc/props/current_data_slot");
  uint64_t v4 = operator new(0x28uLL);
  void *v4 = off_1019E6F00;
  v4[1] = v2 + 104;
  v4[2] = v2;
  v4[3] = sub_10058D194;
  v4[4] = 0;
  uint64_t v23 = v4;
  ctu::RestModule::observeProperty();
  sub_10003F600(buf);
  if (v19 < 0) {
    operator delete(__p[0]);
  }
  sub_100058DB0(__p, "/cc/events/dump_state");
  uint64_t v5 = operator new(0x20uLL);
  void *v5 = off_1019E6F80;
  v5[1] = v2;
  v5[2] = sub_10058D49C;
  v5[3] = 0;
  uint64_t v23 = v5;
  ctu::RestModule::observeEvent();
  sub_10003F600(buf);
  if (v19 < 0) {
    operator delete(__p[0]);
  }
  uint64_t v6 = *(std::__shared_weak_count **)(v2 + 16);
  if (!v6 || (__int16 v7 = *(std::__shared_weak_count_vtbl **)(v2 + 8), (v8 = std::__shared_weak_count::lock(v6)) == 0)) {
    sub_100088B9C();
  }
  uint64_t v9 = v8;
  atomic_fetch_add_explicit(&v8->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v8);
  NotifySubscription::cancel((NotifySubscription *)(v2 + 112));
  uint64_t v10 = (std::__shared_weak_count *)operator new(0x28uLL);
  v10->__shared_weak_owners_ = 0;
  v10->__shared_owners_ = 0;
  v10->__vftable = (std::__shared_weak_count_vtbl *)off_1019E7030;
  v10[1].__vftable = v7;
  v10[1].__shared_owners_ = (uint64_t)v9;
  char v11 = *(const char **)(v2 + 112);
  uint64_t v12 = *(NSObject **)(v2 + 120);
  *(void *)buf = _NSConcreteStackBlock;
  uint64_t v21 = 1174405120;
  char v22 = sub_10058E164;
  uint64_t v23 = &unk_1019E6FF0;
  char v24 = v10 + 1;
  char v25 = v10;
  atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
  notify_register_dispatch(v11, (int *)(v2 + 128), v12, buf);
  if (v25) {
    sub_10004D2C8(v25);
  }
  sub_10004D2C8(v10);
  sub_100088C88(&v15);
  return sub_100046B58((uint64_t *)&v14);
}

void sub_10058DDB8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19, char a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,std::__shared_weak_count *a25)
{
  if (a25) {
    sub_10004D2C8(a25);
  }
  sub_10004D2C8(v25);
  sub_100088C88(&a11);
  sub_100046B58(&a10);
  _Unwind_Resume(a1);
}

void sub_10058DE48()
{
}

__n128 sub_10058DE5C(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_1019E6F00;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_10058DEB0(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019E6F00;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_10058DEE8(void *a1, xpc_object_t *a2)
{
  uint64_t v4 = (unsigned int *)a1[1];
  uint64_t v5 = *v4;
  xpc_type_t type = xpc_get_type(*a2);
  if (type == (xpc_type_t)&_xpc_type_string)
  {
    unsigned int v14 = *v4;
    ctu::rest::detail::read_enum_string_value((ctu::rest::detail *)&v14, (int *)a2, v7);
    unsigned int *v4 = v14;
  }
  else if (type == (xpc_type_t)&_xpc_type_BOOL {
         || type == (xpc_type_t)&_xpc_type_int64
  }
         || type == (xpc_type_t)&_xpc_type_uint64)
  {
    unsigned int *v4 = xpc::dyn_cast_or_default((xpc *)a2, 0, (uint64_t)v7);
  }
  uint64_t v10 = (uint64_t (*)(void *, uint64_t))a1[3];
  uint64_t v11 = a1[4];
  uint64_t v12 = (void *)(a1[2] + (v11 >> 1));
  if (v11) {
    uint64_t v10 = *(uint64_t (**)(void *, uint64_t))(*v12 + v10);
  }
  return v10(v12, v5);
}

uint64_t sub_10058DFE0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10058E020()
{
}

void sub_10058E030()
{
}

__n128 sub_10058E044(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_1019E6F80;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_10058E098(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019E6F80;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_10058E0D0(void *a1)
{
  uint64_t v1 = (uint64_t (*)(void *))a1[2];
  uint64_t v2 = a1[3];
  uint64_t v3 = (void *)(a1[1] + (v2 >> 1));
  if (v2) {
    return (*(uint64_t (**)(void))(*v3 + v1))();
  }
  else {
    return v1(v3);
  }
}

uint64_t sub_10058E118(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10058E158()
{
}

void sub_10058E164(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 32);
  uint64_t v2 = (std::__shared_weak_count *)v1[1];
  if (v2)
  {
    uint64_t v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      uint64_t v4 = v3;
      uint64_t v5 = (void *)*v1;
      if (*v1)
      {
        uint64_t v6 = v5[3];
        dispatch_object_t object = v6;
        if (v6) {
          dispatch_retain(v6);
        }
        __int16 v7 = (std::__shared_weak_count *)v5[2];
        if (!v7 || (uint64_t v8 = v5[1], (v9 = std::__shared_weak_count::lock(v7)) == 0)) {
          sub_100088B9C();
        }
        uint64_t v10 = v9;
        atomic_fetch_add_explicit(&v9->__shared_weak_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v9);
        uint64_t v11 = operator new(0x20uLL);
        void *v11 = off_1019E7160;
        v11[1] = v5;
        v11[2] = v8;
        v11[3] = v10;
        v13[3] = v11;
        getPrivacyProxyFeatureEnabled(&object, (uint64_t)v13);
        sub_100060644(v13);
        if (object) {
          dispatch_release(object);
        }
      }
      sub_10004D2C8(v4);
    }
  }
}

void sub_10058E2BC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, dispatch_object_t object, uint64_t a10)
{
  sub_100060644(&a10);
  if (object) {
    dispatch_release(object);
  }
  sub_10004D2C8(v10);
  _Unwind_Resume(a1);
}

uint64_t sub_10058E304(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_10058E320(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

void sub_10058E330(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1019E7030;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_10058E350(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1019E7030;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_10058E3A4(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 32);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_10058E3B8(void **a1)
{
  uint64_t v1 = (void *)**a1;
  uint64_t v2 = v1[5];
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Starting...", buf, 2u);
  }
  uint64_t v3 = v1[3];
  dispatch_object_t object = v3;
  if (v3) {
    dispatch_retain(v3);
  }
  uint64_t v4 = (std::__shared_weak_count *)v1[2];
  if (v4)
  {
    uint64_t v5 = v1[1];
    uint64_t v6 = std::__shared_weak_count::lock(v4);
    if (v6)
    {
      __int16 v7 = v6;
      atomic_fetch_add_explicit(&v6->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v6);
      uint64_t v11 = 0;
      uint64_t v8 = operator new(0x20uLL);
      void *v8 = off_1019E7080;
      v8[1] = v1;
      v8[2] = v5;
      v8[3] = v7;
      uint64_t v11 = v8;
      getPrivacyProxyFeatureEnabled(&object, (uint64_t)buf);
      sub_100060644(buf);
      if (object) {
        dispatch_release(object);
      }
      operator delete();
    }
  }
  sub_100088B9C();
}

void sub_10058E514(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object, uint64_t a11)
{
  if (object) {
    dispatch_release(object);
  }
  operator delete();
}

void *sub_10058E574(void *a1)
{
  *a1 = off_1019E7080;
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_10058E5C0(void *a1)
{
  *a1 = off_1019E7080;
  uint64_t v1 = (std::__shared_weak_count *)a1[3];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

char *sub_10058E62C(uint64_t a1)
{
  __n128 result = (char *)operator new(0x20uLL);
  *(void *)__n128 result = off_1019E7080;
  *(_OWORD *)(result + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 24);
  *((void *)result + 3) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_10058E690(uint64_t result, uint64_t a2)
{
  *(void *)a2 = off_1019E7080;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(result + 8);
  uint64_t v2 = *(void *)(result + 24);
  *(void *)(a2 + 24) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_10058E6D0(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 24);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_10058E6E0(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete(__p);
}

void sub_10058E720(void *a1, char *a2)
{
  uint64_t v3 = (std::__shared_weak_count *)a1[3];
  if (v3)
  {
    char v4 = *a2;
    uint64_t v5 = a1[1];
    uint64_t v6 = std::__shared_weak_count::lock(v3);
    if (v6)
    {
      __int16 v7 = v6;
      if (a1[2])
      {
        *(unsigned char *)(v5 + 137) = v4;
        uint64_t v8 = sub_10058CEC0(v5, *(unsigned int *)(v5 + 104));
        *(unsigned char *)(v5 + 136) = v8;
        uint64_t v9 = *(NSObject **)(v5 + 40);
        if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v10 = " ";
          uint64_t v11 = "disabled";
          if (!*(unsigned char *)(v5 + 137)) {
            uint64_t v10 = " not ";
          }
          if (v8) {
            uint64_t v11 = "enabled";
          }
          int v12 = 136315394;
          int v13 = v10;
          __int16 v14 = 2080;
          uint64_t v15 = v11;
          _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I Privacy Proxy feature is%senabled with user setting %s", (uint8_t *)&v12, 0x16u);
          uint64_t v8 = *(unsigned char *)(v5 + 136) != 0;
        }
        (*(void (**)(void, void, uint64_t))(**(void **)(v5 + 88) + 48))(*(void *)(v5 + 88), *(unsigned __int8 *)(v5 + 137), v8);
        sub_10058D1EC(v5);
      }
      sub_10004D2C8(v7);
    }
  }
}

void sub_10058E88C(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_10058E8A0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10058E8E0()
{
}

uint64_t *sub_10058E8EC(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v5 = a1;
  uint64_t v6 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v3 = *(NSObject **)(*(void *)v1 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Shutting down...", buf, 2u);
  }
  NotifySubscription::cancel((NotifySubscription *)(v2 + 112));
  sub_100088C88(&v6);
  return sub_100046B58((uint64_t *)&v5);
}

void sub_10058E970(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

uint64_t sub_10058E98C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 40);
  uint64_t v2 = *(void *)v1;
  if (sub_10058CEC0(*(void *)v1, *(unsigned int *)(v1 + 8))) {
    int v3 = 256;
  }
  else {
    int v3 = 0;
  }
  return v3 | *(unsigned __int8 *)(v2 + 137);
}

uint64_t sub_10058E9D0(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 40) + 16))();
  **(_WORD **)(a1 + 32) = result;
  return result;
}

uint64_t sub_10058EA0C(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 40) + 16))();
  **(_WORD **)(a1 + 32) = result;
  return result;
}

void sub_10058EA48(uint64_t **a1)
{
  uint64_t v1 = **a1;
  uint64_t v2 = *((unsigned int *)*a1 + 2);
  uint64_t v3 = *((unsigned __int8 *)*a1 + 12);
  __dst[0] = 0;
  __dst[1] = 0;
  uint64_t v18 = 0;
  PersonalityIdFromSlotId();
  if (SHIBYTE(v16) < 0)
  {
    sub_10004FC84(__dst, __p[0], (unint64_t)__p[1]);
    operator delete(__p[0]);
  }
  else
  {
    *(_OWORD *)__dst = *(_OWORD *)__p;
    uint64_t v18 = v16;
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(v1 + 56));
  uint64_t v5 = ServiceMap;
  if (v6 < 0)
  {
    __int16 v7 = (unsigned __int8 *)(v6 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v8 = 5381;
    do
    {
      uint64_t v6 = v8;
      unsigned int v9 = *v7++;
      uint64_t v8 = (33 * v8) ^ v9;
    }
    while (v9);
  }
  std::mutex::lock(ServiceMap);
  __p[0] = (void *)v6;
  uint64_t v10 = sub_10004D37C(&v5[1].__m_.__sig, (unint64_t *)__p);
  if (v10)
  {
    uint64_t v12 = v10[3];
    uint64_t v11 = (std::__shared_weak_count *)v10[4];
    if (v11)
    {
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v5);
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v11);
      char v13 = 0;
      if (!v12) {
        goto LABEL_10;
      }
      goto LABEL_14;
    }
  }
  else
  {
    uint64_t v12 = 0;
  }
  std::mutex::unlock(v5);
  uint64_t v11 = 0;
  char v13 = 1;
  if (!v12)
  {
LABEL_10:
    __int16 v14 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v1 + 48) + 16))(*(void *)(v1 + 48), v2);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      LOWORD(__p[0]) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "Could not get cellular usage store to set privacy proxy settings", (uint8_t *)__p, 2u);
    }
    goto LABEL_16;
  }
LABEL_14:
  (*(void (**)(uint64_t, void **, uint64_t))(*(void *)v12 + 256))(v12, __dst, v3 | 0x100);
  if (*(_DWORD *)(v1 + 104) == v2) {
    sub_10058D114(v1, v3 != 0);
  }
LABEL_16:
  if ((v13 & 1) == 0) {
    sub_10004D2C8(v11);
  }
  if (SHIBYTE(v18) < 0) {
    operator delete(__dst[0]);
  }
  operator delete();
}

void sub_10058EC8C(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  if ((v24 & 1) == 0) {
    sub_10004D2C8(v23);
  }
  if (a23 < 0) {
    operator delete(__p);
  }
  operator delete();
}

void *sub_10058ED00(void *a1)
{
  *a1 = off_1019E7160;
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_10058ED4C(void *a1)
{
  *a1 = off_1019E7160;
  uint64_t v1 = (std::__shared_weak_count *)a1[3];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

char *sub_10058EDB8(uint64_t a1)
{
  uint64_t result = (char *)operator new(0x20uLL);
  *(void *)uint64_t result = off_1019E7160;
  *(_OWORD *)(result + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 24);
  *((void *)result + 3) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_10058EE1C(uint64_t result, uint64_t a2)
{
  *(void *)a2 = off_1019E7160;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(result + 8);
  uint64_t v2 = *(void *)(result + 24);
  *(void *)(a2 + 24) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_10058EE5C(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 24);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_10058EE6C(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete(__p);
}

void sub_10058EEAC(void *a1, unsigned char *a2)
{
  int v3 = *a2;
  BOOL v4 = *a2 != 0;
  uint64_t v5 = (std::__shared_weak_count *)a1[3];
  if (v5)
  {
    uint64_t v6 = a1[1];
    __int16 v7 = std::__shared_weak_count::lock(v5);
    if (v7)
    {
      uint64_t v8 = v7;
      if (a1[2] && *(unsigned __int8 *)(v6 + 137) != v3)
      {
        *(unsigned char *)(v6 + 137) = v3;
        unsigned int v9 = *(NSObject **)(v6 + 40);
        if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v10 = " not ";
          if (v3) {
            uint64_t v10 = " ";
          }
          int v12 = 136315138;
          char v13 = v10;
          _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I Privacy Proxy feature is%senabled", (uint8_t *)&v12, 0xCu);
          BOOL v4 = *(unsigned char *)(v6 + 137) != 0;
        }
        (*(void (**)(void, BOOL, void))(**(void **)(v6 + 88) + 48))(*(void *)(v6 + 88), v4, *(unsigned __int8 *)(v6 + 136));
        uint64_t v11 = sub_10058CEC0(v6, *(unsigned int *)(v6 + 104));
        sub_10058D114(v6, v11);
      }
      sub_10004D2C8(v8);
    }
  }
}

void sub_10058F008(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_10058F01C(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_10058F05C()
{
}

std::string *sub_10058F068@<X0>(std::string *result@<X0>, std::string *a2@<X8>)
{
  a2->__r_.__value_.__r.__words[0] = 0;
  a2->__r_.__value_.__l.__size_ = 0;
  a2->__r_.__value_.__r.__words[2] = 0;
  if (!result)
  {
    BOOL v4 = "kCTCallClassNone";
    std::string::size_type v5 = 16;
    return std::string::append(a2, v4, v5);
  }
  char v3 = (char)result;
  if (result) {
    uint64_t result = std::string::append(a2, " + kCTCallClassVoice", 0x14uLL);
  }
  if ((v3 & 2) != 0) {
    uint64_t result = std::string::append(a2, " + kCTCallClassData", 0x13uLL);
  }
  if ((v3 & 4) != 0) {
    uint64_t result = std::string::append(a2, " + kCTCallClassFacsimileService", 0x1FuLL);
  }
  if ((v3 & 8) != 0) {
    uint64_t result = std::string::append(a2, " + kCTCallClassShortMessageService", 0x22uLL);
  }
  if ((v3 & 0x10) != 0) {
    uint64_t result = std::string::append(a2, " + kCTCallClassDataCircuitSync", 0x1EuLL);
  }
  if ((v3 & 0x20) != 0) {
    uint64_t result = std::string::append(a2, " + kCTCallClassDataCircuitAsync", 0x1FuLL);
  }
  if ((v3 & 0x40) != 0) {
    uint64_t result = std::string::append(a2, " + kCTCallClassDedicatedPacketAccess", 0x24uLL);
  }
  if (v3 < 0)
  {
    BOOL v4 = " + kCTCallClassDedicatedPADAccess";
    std::string::size_type v5 = 33;
    return std::string::append(a2, v4, v5);
  }
  return result;
}

void sub_10058F168(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10058F184(int a1)
{
  uint64_t v1 = &kCTSettingCallClassVoice;
  uint64_t v2 = &kCTSettingCallClassPacketAccess;
  char v3 = &kCTSettingCallClassPADAccess;
  if (a1 != 128) {
    char v3 = &kCTSettingCallClassVoice;
  }
  if (a1 != 64) {
    uint64_t v2 = v3;
  }
  BOOL v4 = &kCTSettingCallClassDataCircuitSync;
  std::string::size_type v5 = &kCTSettingCallClassDataCircuitAsync;
  if (a1 != 32) {
    std::string::size_type v5 = &kCTSettingCallClassVoice;
  }
  if (a1 != 16) {
    BOOL v4 = v5;
  }
  if (a1 <= 63) {
    uint64_t v2 = v4;
  }
  if (a1 == 8) {
    uint64_t v1 = &kCTSettingCallClassShortMessageSerice;
  }
  if (a1 == 4) {
    uint64_t v1 = &kCTSettingCallClassFax;
  }
  if (a1 == 2) {
    uint64_t v1 = &kCTSettingCallClassData;
  }
  if (a1 > 15) {
    uint64_t v1 = v2;
  }
  return *(void *)v1;
}

void sub_10058F214(void *a1@<X8>)
{
  *a1 = 0;
  operator new();
}

void sub_10058F2B8(_Unwind_Exception *a1)
{
  void *v2 = 0;
  (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_10058F310(uint64_t a1)
{
  uint64_t v2 = (capabilities::ipc *)TelephonyBasebandSupportsRadio();
  if (!v2)
  {
    __int16 v7 = *(NSObject **)(a1 + 16);
    BOOL v8 = os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT);
    uint64_t result = 0;
    if (!v8) {
      return result;
    }
    int v11 = 136315138;
    int v12 = "AppleBaseband";
    unsigned int v9 = "#N Could not find %s service";
    goto LABEL_12;
  }
  uint64_t v3 = capabilities::ipc::supportsPCI(v2);
  if ((v3 & 1) == 0)
  {
    uint64_t v3 = capabilities::ipc::supportsHSIC((capabilities::ipc *)v3);
    if (!v3) {
      __assert_rtn("init", "DarwinRadioLinkNotificationListener.cpp", 73, "false");
    }
  }
  uint64_t Instance = ApplePDPHelperInterface::getInstance((ApplePDPHelperInterface *)v3);
  uint64_t v5 = *(void *)(a1 + 24);
  *(void *)(a1 + 24) = Instance;
  if (v5)
  {
    (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
    uint64_t Instance = *(void *)(a1 + 24);
  }
  if (Instance) {
    return 1;
  }
  __int16 v7 = *(NSObject **)(a1 + 16);
  BOOL v10 = os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT);
  uint64_t result = 0;
  if (v10)
  {
    int v11 = 136315138;
    int v12 = "AppleIPAppender";
    unsigned int v9 = "#N Could not connect to %s service";
LABEL_12:
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, v9, (uint8_t *)&v11, 0xCu);
    return 0;
  }
  return result;
}

void *sub_10058F488(void *a1)
{
  *a1 = off_1019E69C0;
  a1[1] = 0;
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v3, kCtLoggingSystemName, "dor");
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v4, &v3);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 2), (const ctu::OsLogLogger *)v4);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v4);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v3);
  *a1 = off_1019E73F8;
  a1[3] = 0;
  return a1;
}

void sub_10058F534(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, void);
  uint64_t v5 = va_arg(va1, void);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)va1);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)va);
  _Unwind_Resume(a1);
}

void *sub_10058F558(void *a1)
{
  *a1 = off_1019E73F8;
  uint64_t v2 = a1[3];
  a1[3] = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 2));
  return a1;
}

void sub_10058F5D4(void *a1)
{
  sub_10058F558(a1);

  operator delete();
}

uint64_t sub_10058F60C(uint64_t a1)
{
  return sub_10058F614(a1, 0);
}

uint64_t sub_10058F614(uint64_t a1, uint32_t a2)
{
  io_connect_t connect = 0;
  CFDictionaryRef v4 = IOServiceMatching("AppleBaseband");
  io_service_t MatchingService = IOServiceGetMatchingService(kIOMainPortDefault, v4);
  io_object_t v6 = MatchingService;
  if (!MatchingService)
  {
    __int16 v7 = *(NSObject **)(a1 + 16);
    if (!os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_9;
    }
    *(_DWORD *)buf = 136315138;
    v15[0] = "AppleBaseband";
    BOOL v8 = "#N Could not find %s service";
    goto LABEL_7;
  }
  if (IOServiceOpen(MatchingService, mach_task_self_, 0, &connect))
  {
    __int16 v7 = *(NSObject **)(a1 + 16);
    if (!os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_9;
    }
    *(_DWORD *)buf = 136315138;
    v15[0] = "AppleBaseband";
    BOOL v8 = "#N Could not open %s service";
LABEL_7:
    unsigned int v9 = v7;
    uint32_t v10 = 12;
LABEL_8:
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, v8, buf, v10);
    goto LABEL_9;
  }
  if (IOConnectCallScalarMethod(connect, a2, 0, 0, 0, 0))
  {
    int v12 = *(NSObject **)(a1 + 16);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 67109378;
      LODWORD(v15[0]) = a2;
      WORD2(v15[0]) = 2080;
      *(void *)((char *)v15 + 6) = "AppleBaseband";
      BOOL v8 = "#N Could not call function %u in %s";
      unsigned int v9 = v12;
      uint32_t v10 = 18;
      goto LABEL_8;
    }
  }
LABEL_9:
  uint64_t result = connect;
  if (connect) {
    uint64_t result = IOServiceClose(connect);
  }
  if (v6) {
    return IOObjectRelease(v6);
  }
  return result;
}

uint64_t sub_10058F7D4(uint64_t a1)
{
  return sub_10058F614(a1, 6u);
}

uint64_t sub_10058F7DC(uint64_t a1)
{
  io_connect_t connect = 0;
  CFDictionaryRef v2 = IOServiceMatching("AppleBaseband");
  io_service_t MatchingService = IOServiceGetMatchingService(kIOMainPortDefault, v2);
  io_object_t v4 = MatchingService;
  if (!MatchingService)
  {
    uint64_t v5 = *(NSObject **)(a1 + 16);
    if (!os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_11;
    }
    *(_DWORD *)buf = 136315138;
    uint32_t v10 = "AppleBaseband";
    io_object_t v6 = "#N Could not find %s service";
    goto LABEL_10;
  }
  if (IOServiceOpen(MatchingService, mach_task_self_, 0, &connect))
  {
    uint64_t v5 = *(NSObject **)(a1 + 16);
    if (!os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_11;
    }
    *(_DWORD *)buf = 136315138;
    uint32_t v10 = "AppleBaseband";
    io_object_t v6 = "#N Could not open %s service";
    goto LABEL_10;
  }
  if (IOConnectCallScalarMethod(connect, 7u, 0, 0, 0, 0))
  {
    uint64_t v5 = *(NSObject **)(a1 + 16);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315138;
      uint32_t v10 = "AppleBaseband";
      io_object_t v6 = "#N Could not call function kAppleBasebandConnectMethodNotifyBasebandPoweringDown in %s";
LABEL_10:
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, v6, buf, 0xCu);
    }
  }
LABEL_11:
  uint64_t result = connect;
  if (connect) {
    uint64_t result = IOServiceClose(connect);
  }
  if (v4) {
    return IOObjectRelease(v4);
  }
  return result;
}

uint64_t sub_10058F97C(uint64_t a1)
{
  io_connect_t connect = 0;
  CFDictionaryRef v2 = IOServiceMatching("AppleBaseband");
  io_service_t MatchingService = IOServiceGetMatchingService(kIOMainPortDefault, v2);
  io_object_t v4 = MatchingService;
  if (!MatchingService)
  {
    uint64_t v5 = *(NSObject **)(a1 + 16);
    if (!os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_14;
    }
    *(_DWORD *)buf = 136315138;
    int v11 = "AppleBaseband";
    io_object_t v6 = "#N Could not find %s service";
    goto LABEL_13;
  }
  if (IOServiceOpen(MatchingService, mach_task_self_, 0, &connect))
  {
    uint64_t v5 = *(NSObject **)(a1 + 16);
    if (!os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_14;
    }
    *(_DWORD *)buf = 136315138;
    int v11 = "AppleBaseband";
    io_object_t v6 = "#N Could not open %s service";
    goto LABEL_13;
  }
  uint64_t v8 = 1;
  if (IOConnectCallScalarMethod(connect, 1u, &v8, 1u, 0, 0))
  {
    uint64_t v5 = *(NSObject **)(a1 + 16);
    if (!os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_14;
    }
    *(_DWORD *)buf = 136315138;
    int v11 = "AppleBaseband";
    io_object_t v6 = "#N Could not call function kAppleBasebandConnectMethodRadioOn in %s";
    goto LABEL_13;
  }
  CSISleep(10);
  uint64_t v8 = 0;
  if (IOConnectCallScalarMethod(connect, 1u, &v8, 1u, 0, 0))
  {
    uint64_t v5 = *(NSObject **)(a1 + 16);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315138;
      int v11 = "AppleBaseband";
      io_object_t v6 = "#N Could not call function kAppleBasebandConnectMethodRadioOn in %s";
LABEL_13:
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, v6, buf, 0xCu);
    }
  }
LABEL_14:
  uint64_t result = connect;
  if (connect) {
    uint64_t result = IOServiceClose(connect);
  }
  if (v4) {
    return IOObjectRelease(v4);
  }
  return result;
}

uint64_t sub_10058FB88(uint64_t a1)
{
  io_connect_t connect = 0;
  CFDictionaryRef v2 = IOServiceMatching("AppleBaseband");
  io_service_t MatchingService = IOServiceGetMatchingService(kIOMainPortDefault, v2);
  io_object_t v4 = MatchingService;
  if (!MatchingService)
  {
    uint64_t v5 = *(NSObject **)(a1 + 16);
    if (!os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_11;
    }
    *(_DWORD *)buf = 136315138;
    uint32_t v10 = "AppleBaseband";
    io_object_t v6 = "#N Could not find %s service";
    goto LABEL_10;
  }
  if (IOServiceOpen(MatchingService, mach_task_self_, 0, &connect))
  {
    uint64_t v5 = *(NSObject **)(a1 + 16);
    if (!os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_11;
    }
    *(_DWORD *)buf = 136315138;
    uint32_t v10 = "AppleBaseband";
    io_object_t v6 = "#N Could not open %s service";
    goto LABEL_10;
  }
  if (IOConnectCallScalarMethod(connect, 9u, 0, 0, 0, 0))
  {
    uint64_t v5 = *(NSObject **)(a1 + 16);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315138;
      uint32_t v10 = "AppleBaseband";
      io_object_t v6 = "#N Could not call function kAppleBasebandConnectMethodQuiesceBackpoweringPins in %s";
LABEL_10:
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, v6, buf, 0xCu);
    }
  }
LABEL_11:
  uint64_t result = connect;
  if (connect) {
    uint64_t result = IOServiceClose(connect);
  }
  if (v4) {
    return IOObjectRelease(v4);
  }
  return result;
}

uint64_t sub_10058FD28(uint64_t a1)
{
  return _ATCSThreadSpawn("CSI/Darwin Reset Listener", sub_10058FD4C, a1, 1);
}

uint64_t sub_10058FD4C(void *a1)
{
  kern_return_t v5;
  NSObject *v6;
  const char *v7;
  NSObject *v8;
  uint32_t v9;
  NSObject *v10;
  IONotificationPort *v11;
  IONotificationPort *v13;
  kern_return_t v14;
  NSObject *v15;
  const char *v16;
  NSObject *v17;
  uint32_t v18;
  NSObject *v19;
  __CFRunLoopSource *RunLoopSource;
  __CFRunLoop *Current;
  capabilities::ipc *v22;
  capabilities::ipc *v23;
  NSObject *v24;
  uint32_t outputCnt;
  uint64_t output;
  io_connect_t connect[2];
  _DWORD buf[6];

  output = 0;
  *(void *)io_connect_t connect = 0;
  outputCnt = 1;
  CFDictionaryRef v2 = IOServiceMatching("AppleBaseband");
  io_service_t MatchingService = IOServiceGetMatchingService(kIOMainPortDefault, v2);
  io_service_t v4 = MatchingService;
  if (!MatchingService)
  {
    uint32_t v10 = a1[2];
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      buf[0] = 136315138;
      *(void *)&buf[1] = "AppleBaseband";
      __int16 v7 = "#N Could not find %s service";
      uint64_t v8 = v10;
      unsigned int v9 = 12;
      goto LABEL_7;
    }
LABEL_8:
    int v11 = 0;
    goto LABEL_9;
  }
  uint64_t v5 = IOServiceOpen(MatchingService, mach_task_self_, 0, &connect[1]);
  if (v5)
  {
    io_object_t v6 = a1[2];
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      buf[0] = 67109120;
      buf[1] = v5;
      __int16 v7 = "#N Could not open service (%#x)";
      uint64_t v8 = v6;
      unsigned int v9 = 8;
LABEL_7:
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, v7, (uint8_t *)buf, v9);
      goto LABEL_8;
    }
    goto LABEL_8;
  }
  char v13 = IONotificationPortCreate(kIOMainPortDefault);
  int v11 = v13;
  if (!v13)
  {
    char v19 = a1[2];
    if (!os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_8;
    }
    LOWORD(buf[0]) = 0;
    __int16 v7 = "#N Could not create notification port";
    uint64_t v8 = v19;
    unsigned int v9 = 2;
    goto LABEL_7;
  }
  __int16 v14 = IOServiceAddInterestNotification(v13, v4, "IOGeneralInterest", (IOServiceInterestCallback)sub_100590114, a1, connect);
  if (v14)
  {
    uint64_t v15 = a1[2];
    if (!os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_9;
    }
    buf[0] = 67109120;
    buf[1] = v14;
    uint64_t v16 = "#N Could not add interest notification on service: %#x";
    unsigned __int16 v17 = v15;
    uint64_t v18 = 8;
    goto LABEL_22;
  }
  if (!IOConnectCallScalarMethod(connect[1], 3u, 0, 0, &output, &outputCnt) && !output) {
    (*(void (**)(void *, void))(*a1 + 96))(a1, 0);
  }
  RunLoopSource = IONotificationPortGetRunLoopSource(v11);
  if (RunLoopSource)
  {
    Current = CFRunLoopGetCurrent();
    CFRunLoopAddSource(Current, RunLoopSource, kCFRunLoopCommonModes);
    uint64_t v23 = (capabilities::ipc *)capabilities::ipc::supportsPCI(v22);
    if ((v23 & 1) != 0 || capabilities::ipc::supportsHSIC(v23)) {
      operator new();
    }
    qword_101B13DE0 = (uint64_t)CFRunLoopGetCurrent();
    CFRunLoopRun();
  }
  else
  {
    char v24 = a1[2];
    if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf[0]) = 0;
      uint64_t v16 = "#N Could not create run loop source";
      unsigned __int16 v17 = v24;
      uint64_t v18 = 2;
LABEL_22:
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, v16, (uint8_t *)buf, v18);
    }
  }
LABEL_9:
  if (connect[0]) {
    IOObjectRelease(connect[0]);
  }
  if (v11) {
    CFRelease(v11);
  }
  if (connect[1]) {
    IOServiceClose(connect[1]);
  }
  if (v4) {
    IOObjectRelease(v4);
  }
  return 0;
}

uint64_t sub_100590114(uint64_t result, uint64_t a2, int a3)
{
  if (a3 == -469794816)
  {
    uint64_t v3 = 1;
  }
  else
  {
    if (a3 != -469794815) {
      return result;
    }
    uint64_t v3 = 0;
  }
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)result + 96))(result, v3);
}

uint64_t sub_100590168(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 104))();
}

uint64_t sub_100590190(capabilities::ipc *a1, unsigned int a2, unsigned int a3)
{
  io_object_t v6 = (capabilities::ipc *)capabilities::ipc::supportsPCI(a1);
  if ((v6 & 1) != 0 || (uint64_t result = capabilities::ipc::supportsHSIC(v6), result))
  {
    uint64_t v8 = (ApplePDPHelperInterface *)*((void *)a1 + 3);
    return ApplePDPHelperInterface::setDormancyInterval(v8, a2, a3);
  }
  return result;
}

uint64_t sub_1005901FC(capabilities::ipc *a1)
{
  CFDictionaryRef v2 = (capabilities::ipc *)capabilities::ipc::supportsPCI(a1);
  if ((v2 & 1) != 0 || (uint64_t result = capabilities::ipc::supportsHSIC(v2), result))
  {
    io_service_t v4 = (ApplePDPHelperInterface *)*((void *)a1 + 3);
    return ApplePDPHelperInterface::restartDormancyCheck(v4);
  }
  return result;
}

uint64_t sub_10059024C(capabilities::ipc *a1, int a2)
{
  io_service_t v4 = (capabilities::ipc *)capabilities::ipc::supportsPCI(a1);
  if ((v4 & 1) != 0 || (uint64_t result = capabilities::ipc::supportsHSIC(v4), result))
  {
    io_object_t v6 = (ApplePDPHelperInterface *)*((void *)a1 + 3);
    return ApplePDPHelperInterface::setLinkQualityMetric(v6, a2);
  }
  return result;
}

void sub_1005902A8(ApplePDPHelperInterface::Handler *a1)
{
  ApplePDPHelperInterface::Handler::~Handler(a1);

  operator delete();
}

uint64_t sub_1005902E0(void *a1, uint64_t a2)
{
  CFDictionaryRef v2 = (uint64_t (*)(void *, void, uint64_t))a1[3];
  uint64_t v3 = a1[4];
  io_service_t v4 = (void *)(a1[2] + (v3 >> 1));
  if (v3) {
    CFDictionaryRef v2 = *(uint64_t (**)(void *, void, uint64_t))(*v4 + v2);
  }
  return v2(v4, a1[1], a2);
}

void *sub_100590334(void *result, uint64_t a2)
{
  unint64_t v2 = result[5];
  uint64_t v3 = result[6];
  if (v3) {
    BOOL v4 = (result[6] & 1 | v2) == 0;
  }
  else {
    BOOL v4 = 1;
  }
  int v5 = !v4;
  if (v2) {
    BOOL v6 = 0;
  }
  else {
    BOOL v6 = v5 == 0;
  }
  if (!v6)
  {
    __int16 v7 = (void *)(result[2] + (v3 >> 1));
    if (result[6]) {
      unint64_t v2 = *(void *)(*v7 + v2);
    }
    return (void *)((uint64_t (*)(void *, void, uint64_t))v2)(v7, result[1], a2);
  }
  return result;
}

void sub_1005903B4()
{
}

void sub_100590440(void *a1@<X0>, NSObject **a2@<X1>, uint64_t a3@<X2>, void *a4@<X8>)
{
  BOOL v6 = (std::__shared_weak_count *)a1[4];
  if (v6)
  {
    unsigned int v9 = std::__shared_weak_count::lock(v6);
    unsigned int v20 = v9;
    if (v9)
    {
      if (a1[3])
      {
        uint32_t v10 = (std::__shared_weak_count *)a1[2];
        if (v10)
        {
          uint64_t v11 = a1[1];
          int v12 = std::__shared_weak_count::lock(v10);
          if (v12)
          {
            uint64_t v16 = v11;
            unsigned __int16 v17 = v12;
            char v13 = *a2;
            dispatch_object_t object = v13;
            if (v13) {
              dispatch_retain(v13);
            }
            *(_OWORD *)__int16 v14 = *(_OWORD *)a3;
            *(void *)a3 = 0;
            *(void *)(a3 + 8) = 0;
            sub_100243A0C(v14, &v18);
          }
        }
        sub_100088B9C();
      }
      sub_10004D2C8(v9);
    }
  }
  *a4 = 0;
  a4[1] = 0;
}

void sub_100590544(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, dispatch_object_t object, uint64_t a13, std::__shared_weak_count *a14)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  if (object) {
    dispatch_release(object);
  }
  if (a14) {
    sub_10004D2C8(a14);
  }
  uint64_t v16 = *(std::__shared_weak_count **)(v14 - 40);
  if (v16) {
    sub_10004D2C8(v16);
  }
  _Unwind_Resume(exception_object);
}

void sub_100590588(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
}

void sub_100590590(uint64_t a1@<X0>, void *a2@<X8>)
{
  BOOL v4 = *(std::__shared_weak_count **)(a1 + 32);
  if (v4)
  {
    int v5 = std::__shared_weak_count::lock(v4);
    uint64_t v8 = v5;
    if (v5)
    {
      if (*(void *)(a1 + 24)) {
        sub_1008545C8(&v6);
      }
      sub_10004D2C8(v5);
    }
  }
  *a2 = 0;
  a2[1] = 0;
}

void sub_100590614(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

double sub_100590628@<D0>(_OWORD *a1@<X8>)
{
  sub_100BD482C((std::__shared_weak_count **)&v3);
  double result = *(double *)&v3;
  *a1 = v3;
  return result;
}

void sub_100590660(void *a1@<X0>, uint64_t a2@<X3>, void *a3@<X8>)
{
  int v5 = (std::__shared_weak_count *)a1[4];
  if (v5)
  {
    __int16 v7 = std::__shared_weak_count::lock(v5);
    int v12 = v7;
    if (v7)
    {
      if (a1[3])
      {
        uint64_t v8 = (std::__shared_weak_count *)a1[2];
        if (v8 && std::__shared_weak_count::lock(v8))
        {
          uint64_t v9 = *(void *)(a2 + 8);
          if (v9) {
            atomic_fetch_add_explicit((atomic_ullong *volatile)(v9 + 8), 1uLL, memory_order_relaxed);
          }
          sub_100243EF8(&v10);
        }
        sub_100088B9C();
      }
      sub_10004D2C8(v7);
    }
  }
  *a3 = 0;
  a3[1] = 0;
}

void sub_100590758(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, std::__shared_weak_count *a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  if (a12) {
    sub_10004D2C8(a12);
  }
  if (a16) {
    sub_10004D2C8(a16);
  }
  _Unwind_Resume(exception_object);
}

void sub_100590790(void *a1@<X0>, uint64_t a2@<X2>, void *a3@<X8>)
{
  int v5 = (std::__shared_weak_count *)a1[4];
  if (v5)
  {
    __int16 v7 = std::__shared_weak_count::lock(v5);
    int v12 = v7;
    if (v7)
    {
      if (a1[3])
      {
        uint64_t v8 = (std::__shared_weak_count *)a1[2];
        if (v8 && std::__shared_weak_count::lock(v8))
        {
          uint64_t v9 = *(void *)(a2 + 8);
          if (v9) {
            atomic_fetch_add_explicit((atomic_ullong *volatile)(v9 + 8), 1uLL, memory_order_relaxed);
          }
          sub_100244144(&v10);
        }
        sub_100088B9C();
      }
      sub_10004D2C8(v7);
    }
  }
  *a3 = 0;
  a3[1] = 0;
}

void sub_100590878(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, std::__shared_weak_count *a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  if (a12) {
    sub_10004D2C8(a12);
  }
  if (a16) {
    sub_10004D2C8(a16);
  }
  _Unwind_Resume(exception_object);
}

void sub_1005908B0(const void **a1@<X1>, void *a2@<X2>, int a3@<W3>, uint64_t a4@<X8>)
{
  __p[0] = 0;
  __p[1] = 0;
  uint64_t v11 = 0;
  sub_10012A394(&v9, a1);
  sub_101328F44((CFUUIDRef *)&v9, (uint64_t)__p);
  sub_10012577C(&v9);
  if (a3)
  {
    sub_100246DF4(&v8);
LABEL_5:
    *(_OWORD *)a4 = v8;
    goto LABEL_6;
  }
  if (*a2)
  {
    __int16 v7 = operator new(0x70uLL);
    v7[1] = 0;
    v7[2] = 0;
    *__int16 v7 = off_1019AEB08;
    ims::Call::Call();
    *(void *)&long long v8 = v7 + 3;
    *((void *)&v8 + 1) = v7;
    sub_1000B3BC8((uint64_t)&v8, v7 + 4, (uint64_t)(v7 + 3));
    goto LABEL_5;
  }
  *(void *)a4 = 0;
  *(void *)(a4 + 8) = 0;
LABEL_6:
  if (SHIBYTE(v11) < 0) {
    operator delete(__p[0]);
  }
}

void sub_1005909A0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  std::__shared_weak_count::~__shared_weak_count(v18);
  operator delete(v20);
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_1005909E4(void *a1@<X0>, uint64_t a2@<X2>, uint64_t a3@<X3>, dispatch_object_t *a4@<X4>, void *a5@<X8>)
{
  __int16 v7 = (std::__shared_weak_count *)a1[4];
  if (v7)
  {
    uint64_t v11 = std::__shared_weak_count::lock(v7);
    unsigned __int16 v17 = v11;
    if (v11)
    {
      if (a1[3])
      {
        uint64_t v12 = *(void *)(a2 + 8);
        if (v12) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v12 + 8), 1uLL, memory_order_relaxed);
        }
        uint64_t v13 = *(void *)(a3 + 8);
        if (v13) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v13 + 8), 1uLL, memory_order_relaxed);
        }
        if (*a4) {
          dispatch_retain(*a4);
        }
        uint64_t v14 = (std::__shared_weak_count *)a1[2];
        if (v14)
        {
          if (std::__shared_weak_count::lock(v14)) {
            sub_100244524(&v15);
          }
        }
        sub_100088B9C();
      }
      sub_10004D2C8(v11);
    }
  }
  *a5 = 0;
  a5[1] = 0;
}

void sub_100590B24(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11, dispatch_object_t object, uint64_t a13, std::__shared_weak_count *a14, uint64_t a15, std::__shared_weak_count *a16)
{
  if (a11) {
    sub_10004D2C8(a11);
  }
  if (object) {
    dispatch_release(object);
  }
  if (a14) {
    sub_10004D2C8(a14);
  }
  if (a16) {
    sub_10004D2C8(a16);
  }
  uint64_t v18 = *(std::__shared_weak_count **)(v16 - 56);
  if (v18) {
    sub_10004D2C8(v18);
  }
  _Unwind_Resume(exception_object);
}

double sub_100590B74@<D0>(_OWORD *a1@<X8>)
{
  sub_100248248(v3);
  double result = v3[0];
  *a1 = *(_OWORD *)v3;
  return result;
}

void sub_100590BB0(CallFactoryInterface *this)
{
  *(void *)this = off_1019E7550;
  unint64_t v2 = (std::__shared_weak_count *)*((void *)this + 4);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  long long v3 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }

  CallFactoryInterface::~CallFactoryInterface(this);
}

void sub_100590C18(CallFactoryInterface *this)
{
  *(void *)this = off_1019E7550;
  unint64_t v2 = (std::__shared_weak_count *)*((void *)this + 4);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  long long v3 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  CallFactoryInterface::~CallFactoryInterface(this);

  operator delete();
}

void sub_100590C94(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_100590D14(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100590D50(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100590D88(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_100590DB8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

void *sub_100590DFC(void *a1, uint64_t *a2, uint64_t a3, uint64_t a4, NSObject **a5, int a6)
{
  long long v10 = (std::__shared_weak_count *)a2[1];
  uint64_t v19 = *a2;
  unsigned int v20 = v10;
  if (v10) {
    atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v11 = *a5;
  dispatch_object_t object = v11;
  if (v11) {
    dispatch_retain(v11);
  }
  uint64_t v12 = "DATA.Connection.LLWirelessModemTraffic.X";
  int v13 = *(_DWORD *)(*(void *)a3 + 52);
  if (v13 == 2) {
    uint64_t v12 = "DATA.Connection.LLWirelessModemTraffic.2";
  }
  uint64_t v14 = "LLWirelessModemTraffic.X";
  if (v13 == 2) {
    uint64_t v14 = "LLWirelessModemTraffic.2";
  }
  if (v13 == 1) {
    long long v15 = "DATA.Connection.LLWirelessModemTraffic.1";
  }
  else {
    long long v15 = v12;
  }
  if (v13 == 1) {
    uint64_t v16 = "LLWirelessModemTraffic.1";
  }
  else {
    uint64_t v16 = v14;
  }
  sub_10129653C((uint64_t)a1, (uint64_t *)&off_1019E80D8, &v19, a3, a4, &object, v15, (uint64_t)v16, a6);
  if (object) {
    dispatch_release(object);
  }
  if (v20) {
    sub_10004D2C8(v20);
  }
  *a1 = off_1019E76A0;
  a1[8] = off_1019E7BF0;
  a1[9] = off_1019E7E80;
  a1[10] = off_1019E8070;
  return a1;
}

void sub_100590F88(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object, uint64_t a11, std::__shared_weak_count *a12)
{
  if (object) {
    dispatch_release(object);
  }
  if (a12) {
    sub_10004D2C8(a12);
  }
  PersonalitySpecific::~PersonalitySpecific(v12);
  _Unwind_Resume(a1);
}

void sub_100590FB4(uint64_t a1)
{
  sub_101296BD8(a1, (uint64_t *)&off_1019E80D8);

  PersonalitySpecific::~PersonalitySpecific(v1);
}

void sub_100590FE4(uint64_t a1)
{
  sub_101296BD8(a1 - 64, (uint64_t *)&off_1019E80D8);

  PersonalitySpecific::~PersonalitySpecific(v1);
}

void sub_100591018(uint64_t a1)
{
  sub_101296BD8(a1 - 72, (uint64_t *)&off_1019E80D8);

  PersonalitySpecific::~PersonalitySpecific(v1);
}

void sub_10059104C(uint64_t a1)
{
  sub_101296BD8(a1 - 80, (uint64_t *)&off_1019E80D8);

  PersonalitySpecific::~PersonalitySpecific(v1);
}

void sub_100591080(uint64_t a1)
{
  sub_101296BD8(a1, (uint64_t *)&off_1019E80D8);
  PersonalitySpecific::~PersonalitySpecific(v1);

  operator delete();
}

void sub_1005910C4(uint64_t a1)
{
}

void sub_1005910CC(uint64_t a1)
{
}

void sub_1005910D4(uint64_t a1)
{
}

uint64_t sub_1005910DC(uint64_t a1, unsigned char *a2)
{
  uint64_t v4 = sub_1012A32C8(a1);
  uint64_t v5 = v4 & ~sub_1012978BC(a1, 0);
  long long v6 = *(NSObject **)(a1 + 56);
  BOOL v7 = os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT);
  if (v5)
  {
    if (v7)
    {
      int v13 = 136315138;
      uint64_t v14 = "connectionAssertionUpdateTrigger";
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I %s: Tethering is not only connection in mask, not tearing down context if assertion is gone", (uint8_t *)&v13, 0xCu);
    }
    *a2 = 0;
  }
  else if (v7)
  {
    int v13 = 136315138;
    uint64_t v14 = "connectionAssertionUpdateTrigger";
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I %s: Tethering is only connection in mask, can tear down context if assertion is gone", (uint8_t *)&v13, 0xCu);
  }
  uint64_t v8 = (*(uint64_t (**)(void))(**(void **)(a1 + 216) + 456))(*(void *)(a1 + 216));
  if (v8)
  {
    uint64_t v9 = (void (***)(void, uint64_t, uint64_t, void))v8;
    uint64_t v10 = PersonalitySpecificImpl::simSlot((PersonalitySpecificImpl *)a1);
    uint64_t v11 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 760))(a1);
    (**v9)(v9, v10, v11, 0);
  }
  return 0;
}

uint64_t sub_1005912B0()
{
  return 16842752;
}

uint64_t sub_1005912BC()
{
  return 16842752;
}

uint64_t sub_1005912C8(PersonalitySpecificImpl *a1, uint64_t a2)
{
  sub_10129D220(a1, a2);
  uint64_t result = (*(uint64_t (**)(void))(**((void **)a1 + 27) + 456))();
  if (result)
  {
    uint64_t v4 = (uint64_t (***)(void, uint64_t, uint64_t, uint64_t))result;
    uint64_t v5 = PersonalitySpecificImpl::simSlot(a1);
    uint64_t v6 = (*(uint64_t (**)(PersonalitySpecificImpl *))(*(void *)a1 + 760))(a1);
    BOOL v7 = **v4;
    return v7(v4, v5, v6, 1);
  }
  return result;
}

uint64_t sub_1005913D8(uint64_t a1)
{
  sub_10129D2E0(a1);
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 216) + 456))(*(void *)(a1 + 216));
  if (result)
  {
    uint64_t v3 = result;
    uint64_t v4 = *(NSObject **)(a1 + 56);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)BOOL v7 = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I tethering: on connection state update", v7, 2u);
    }
    uint64_t v5 = PersonalitySpecificImpl::simSlot((PersonalitySpecificImpl *)a1);
    uint64_t v6 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 760))(a1);
    return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v3 + 8))(v3, v5, v6);
  }
  return result;
}

uint64_t sub_1005914EC(uint64_t a1)
{
  sub_10129EE18(a1);
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 216) + 456))(*(void *)(a1 + 216));
  if (result)
  {
    uint64_t v3 = result;
    uint64_t v4 = *(NSObject **)(a1 + 56);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)BOOL v7 = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I tethering: on new availability", v7, 2u);
    }
    uint64_t v5 = PersonalitySpecificImpl::simSlot((PersonalitySpecificImpl *)a1);
    uint64_t v6 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 760))(a1);
    return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v3 + 8))(v3, v5, v6);
  }
  return result;
}

uint64_t sub_100591600(uint64_t a1)
{
  return sub_1005914EC(a1 - 64);
}

BOOL sub_100591608(void *a1, void *a2)
{
  unint64_t v2 = (unsigned __int8 *)(a1 + 1);
  uint64_t v3 = (unsigned __int8 *)*a1;
  uint64_t v4 = (unsigned __int8 *)(a2 + 1);
  uint64_t v5 = (unsigned __int8 *)*a2;
  BOOL v6 = (void *)*a1 == a1 + 1 || v5 == v4;
  if (v6)
  {
    BOOL v7 = (unsigned __int8 *)*a2;
    uint64_t v8 = (unsigned __int8 *)*a1;
    return v8 == v2 && v7 == v4;
  }
  else
  {
    while (1)
    {
      BOOL v11 = sub_10001D294(v3 + 32, v5 + 32);
      BOOL result = 0;
      if (!v11 || v3[56] != v5[56]) {
        break;
      }
      uint64_t v12 = (unsigned __int8 *)*((void *)v3 + 1);
      if (v12)
      {
        do
        {
          uint64_t v8 = v12;
          uint64_t v12 = *(unsigned __int8 **)v12;
        }
        while (v12);
      }
      else
      {
        do
        {
          uint64_t v8 = (unsigned __int8 *)*((void *)v3 + 2);
          BOOL v6 = *(void *)v8 == (void)v3;
          uint64_t v3 = v8;
        }
        while (!v6);
      }
      int v13 = (unsigned __int8 *)*((void *)v5 + 1);
      if (v13)
      {
        do
        {
          BOOL v7 = v13;
          int v13 = *(unsigned __int8 **)v13;
        }
        while (v13);
      }
      else
      {
        do
        {
          BOOL v7 = (unsigned __int8 *)*((void *)v5 + 2);
          BOOL v6 = *(void *)v7 == (void)v5;
          uint64_t v5 = v7;
        }
        while (!v6);
      }
      if (v8 != v2)
      {
        uint64_t v3 = v8;
        uint64_t v5 = v7;
        if (v7 != v4) {
          continue;
        }
      }
      return v8 == v2 && v7 == v4;
    }
  }
  return result;
}

void sub_1005916F8(int *a1@<X0>, xpc_object_t *a2@<X8>)
{
  xpc_object_t v21 = 0;
  xpc_object_t v4 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v5 = v4;
  if (v4)
  {
    xpc_object_t v21 = v4;
  }
  else
  {
    xpc_object_t v5 = xpc_null_create();
    xpc_object_t v21 = v5;
    if (!v5)
    {
      xpc_object_t v6 = xpc_null_create();
      xpc_object_t v5 = 0;
      goto LABEL_8;
    }
  }
  if (xpc_get_type(v5) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v5);
    goto LABEL_9;
  }
  xpc_object_t v6 = xpc_null_create();
LABEL_8:
  xpc_object_t v21 = v6;
LABEL_9:
  xpc_release(v5);
  xpc_object_t v19 = xpc_int64_create(*a1);
  if (!v19) {
    xpc_object_t v19 = xpc_null_create();
  }
  unsigned __int16 v17 = &v21;
  uint64_t v18 = "state";
  sub_100035E70((uint64_t)&v17, &v19, &v20);
  xpc_release(v20);
  xpc_object_t v20 = 0;
  xpc_release(v19);
  xpc_object_t v19 = 0;
  unsigned int v7 = sd::imsServiceMaskToUint();
  xpc_object_t v15 = xpc_int64_create(v7);
  if (!v15) {
    xpc_object_t v15 = xpc_null_create();
  }
  unsigned __int16 v17 = &v21;
  uint64_t v18 = "serviceMask";
  sub_100035E70((uint64_t)&v17, &v15, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(v15);
  xpc_object_t v15 = 0;
  xpc_object_t v13 = xpc_BOOL_create(*((unsigned char *)a1 + 8));
  if (!v13) {
    xpc_object_t v13 = xpc_null_create();
  }
  unsigned __int16 v17 = &v21;
  uint64_t v18 = "isOnIWlan";
  sub_100035E70((uint64_t)&v17, &v13, &v14);
  xpc_release(v14);
  xpc_object_t v14 = 0;
  xpc_release(v13);
  xpc_object_t v13 = 0;
  xpc_object_t v11 = xpc_int64_create(a1[3]);
  if (!v11) {
    xpc_object_t v11 = xpc_null_create();
  }
  unsigned __int16 v17 = &v21;
  uint64_t v18 = "transportType";
  sub_100035E70((uint64_t)&v17, &v11, &v12);
  xpc_release(v12);
  xpc_object_t v12 = 0;
  xpc_release(v11);
  xpc_object_t v11 = 0;
  xpc_object_t v9 = xpc_int64_create(a1[4]);
  if (!v9) {
    xpc_object_t v9 = xpc_null_create();
  }
  unsigned __int16 v17 = &v21;
  uint64_t v18 = "dataMode";
  sub_100035E70((uint64_t)&v17, &v9, &v10);
  xpc_release(v10);
  xpc_object_t v10 = 0;
  xpc_release(v9);
  xpc_object_t v9 = 0;
  xpc_object_t v8 = v21;
  *a2 = v21;
  if (v8) {
    xpc_retain(v8);
  }
  else {
    *a2 = xpc_null_create();
  }
  xpc_release(v21);
}

void sub_1005919AC(_Unwind_Exception *a1)
{
  xpc_release(*(xpc_object_t *)(v1 - 40));
  _Unwind_Resume(a1);
}

void sub_1005919DC(int *a1, void **a2)
{
  uint64_t v3 = *a2;
  xpc_object_t object = v3;
  if (v3 && xpc_get_type(v3) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v3);
    xpc_object_t v4 = object;
  }
  else
  {
    xpc_object_t v4 = xpc_null_create();
    xpc_object_t object = v4;
  }
  if (xpc_get_type(v4) == (xpc_type_t)&_xpc_type_dictionary)
  {
    p_xpc_object_t object = &object;
    uint64_t v16 = "state";
    sub_100048BAC((uint64_t)&p_object, &v17);
    xpc_type_t type = xpc_get_type(v17);
    if (type == (xpc_type_t)&_xpc_type_string)
    {
      int v19 = *a1;
      ctu::rest::detail::read_enum_string_value((ctu::rest::detail *)&v19, (int *)&v17, v6);
      *a1 = v19;
    }
    else if (type == (xpc_type_t)&_xpc_type_BOOL {
           || type == (xpc_type_t)&_xpc_type_int64
    }
           || type == (xpc_type_t)&_xpc_type_uint64)
    {
      *a1 = xpc::dyn_cast_or_default((xpc *)&v17, 0, (uint64_t)v6);
    }
    xpc_release(v17);
    p_xpc_object_t object = &object;
    uint64_t v16 = "serviceMask";
    sub_100048BAC((uint64_t)&p_object, &v17);
    xpc_object_t v8 = (sd *)xpc::dyn_cast_or_default((xpc *)&v17, 0, v7);
    xpc_release(v17);
    a1[1] = sd::imsServiceMaskFromUint(v8, v9);
    p_xpc_object_t object = &object;
    uint64_t v16 = "isOnIWlan";
    sub_100048BAC((uint64_t)&p_object, &v17);
    *((unsigned char *)a1 + 8) = xpc::dyn_cast_or_default((xpc *)&v17, 0, v10);
    xpc_release(v17);
    p_xpc_object_t object = &object;
    uint64_t v16 = "transportType";
    sub_100048BAC((uint64_t)&p_object, &v17);
    xpc_type_t v11 = xpc_get_type(v17);
    if (v11 == (xpc_type_t)&_xpc_type_string)
    {
      int v19 = a1[3];
      ctu::rest::detail::read_enum_string_value((ctu::rest::detail *)&v19, (int *)&v17, v12);
      a1[3] = v19;
    }
    else if (v11 == (xpc_type_t)&_xpc_type_BOOL {
           || v11 == (xpc_type_t)&_xpc_type_int64
    }
           || v11 == (xpc_type_t)&_xpc_type_uint64)
    {
      a1[3] = xpc::dyn_cast_or_default((xpc *)&v17, 0, (uint64_t)v12);
    }
    xpc_release(v17);
    p_xpc_object_t object = &object;
    uint64_t v16 = "dataMode";
    sub_100048BAC((uint64_t)&p_object, &v17);
    xpc_type_t v13 = xpc_get_type(v17);
    if (v13 == (xpc_type_t)&_xpc_type_string)
    {
      int v19 = a1[4];
      ctu::rest::detail::read_enum_string_value((ctu::rest::detail *)&v19, (int *)&v17, v14);
      a1[4] = v19;
    }
    else if (v13 == (xpc_type_t)&_xpc_type_BOOL {
           || v13 == (xpc_type_t)&_xpc_type_int64
    }
           || v13 == (xpc_type_t)&_xpc_type_uint64)
    {
      a1[4] = xpc::dyn_cast_or_default((xpc *)&v17, 0, (uint64_t)v14);
    }
    xpc_release(v17);
  }
  else
  {
    *((unsigned char *)a1 + 8) = 0;
    *(void *)a1 = 0;
    *(void *)(a1 + 3) = 0xFFFFFFFF00000002;
  }
  xpc_release(object);
}

void sub_100591CA8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, xpc_object_t a12, xpc_object_t object)
{
}

void sub_100591D54(uint64_t a1@<X0>, xpc_object_t *a2@<X8>)
{
  xpc_object_t v4 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v5 = v4;
  if (v4)
  {
    xpc_object_t v15 = v4;
  }
  else
  {
    xpc_object_t v5 = xpc_null_create();
    xpc_object_t v15 = v5;
    if (!v5)
    {
      xpc_object_t v6 = xpc_null_create();
      xpc_object_t v5 = 0;
      goto LABEL_8;
    }
  }
  if (xpc_get_type(v5) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v5);
    goto LABEL_9;
  }
  xpc_object_t v6 = xpc_null_create();
LABEL_8:
  xpc_object_t v15 = v6;
LABEL_9:
  xpc_release(v5);
  if (*(char *)(a1 + 23) >= 0) {
    unsigned int v7 = (const char *)a1;
  }
  else {
    unsigned int v7 = *(const char **)a1;
  }
  xpc_object_t v13 = xpc_string_create(v7);
  if (!v13) {
    xpc_object_t v13 = xpc_null_create();
  }
  xpc_type_t v11 = &v15;
  xpc_object_t v12 = "identity";
  sub_100035E70((uint64_t)&v11, &v13, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(v13);
  xpc_object_t v13 = 0;
  xpc_object_t v9 = xpc_int64_create(*(int *)(a1 + 24));
  if (!v9) {
    xpc_object_t v9 = xpc_null_create();
  }
  xpc_type_t v11 = &v15;
  xpc_object_t v12 = "state";
  sub_100035E70((uint64_t)&v11, &v9, &v10);
  xpc_release(v10);
  xpc_object_t v10 = 0;
  xpc_release(v9);
  xpc_object_t v9 = 0;
  xpc_object_t v8 = v15;
  *a2 = v15;
  if (v8) {
    xpc_retain(v8);
  }
  else {
    *a2 = xpc_null_create();
  }
  xpc_release(v15);
}

void sub_100591F00(uint64_t a1, void **a2)
{
  uint64_t v3 = *a2;
  xpc_object_t object = v3;
  if (v3 && xpc_get_type(v3) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v3);
    xpc_object_t v4 = object;
  }
  else
  {
    xpc_object_t v4 = xpc_null_create();
    xpc_object_t object = v4;
  }
  if (xpc_get_type(v4) == (xpc_type_t)&_xpc_type_dictionary)
  {
    v7[0] = &object;
    v7[1] = "identity";
    sub_100048BAC((uint64_t)v7, &v8);
    std::string __p = 0;
    xpc_object_t v13 = 0;
    uint64_t v14 = 0;
    xpc::dyn_cast_or_default();
    if (SHIBYTE(v14) < 0) {
      operator delete(__p);
    }
    if (*(char *)(a1 + 23) < 0) {
      operator delete(*(void **)a1);
    }
    *(_OWORD *)a1 = *(_OWORD *)v10;
    *(void *)(a1 + 16) = v11;
    xpc_release(v8);
    std::string __p = &object;
    xpc_object_t v13 = "state";
    sub_100048BAC((uint64_t)&__p, v10);
    xpc_type_t type = xpc_get_type(v10[0]);
    if (type == (xpc_type_t)&_xpc_type_string)
    {
      LODWORD(v7[0]) = *(_DWORD *)(a1 + 24);
      ctu::rest::detail::read_enum_string_value((ctu::rest::detail *)v7, (int *)v10, v6);
      *(_DWORD *)(a1 + 24) = v7[0];
    }
    else if (type == (xpc_type_t)&_xpc_type_BOOL {
           || type == (xpc_type_t)&_xpc_type_int64
    }
           || type == (xpc_type_t)&_xpc_type_uint64)
    {
      *(_DWORD *)(a1 + 24) = xpc::dyn_cast_or_default((xpc *)v10, 0, (uint64_t)v6);
    }
    xpc_release(v10[0]);
  }
  else
  {
    if (*(char *)(a1 + 23) < 0) {
      operator delete(*(void **)a1);
    }
    *(void *)a1 = 0;
    *(void *)(a1 + 8) = 0;
    *(_DWORD *)(a1 + 24) = 0;
    *(void *)(a1 + 16) = 0;
  }
  xpc_release(object);
}

void sub_1005920B4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, xpc_object_t a11, xpc_object_t object, xpc_object_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
}

BOOL sub_100592118(unsigned __int8 *a1, unsigned __int8 *a2)
{
  unint64_t v2 = a2;
  uint64_t v4 = a1[23];
  if ((v4 & 0x80u) == 0) {
    uint64_t v5 = a1[23];
  }
  else {
    uint64_t v5 = *((void *)a1 + 1);
  }
  uint64_t v6 = a2[23];
  int v7 = (char)v6;
  if ((v6 & 0x80u) != 0) {
    uint64_t v6 = *((void *)a2 + 1);
  }
  if (v5 == v6)
  {
    if (v7 < 0) {
      a2 = *(unsigned __int8 **)a2;
    }
    if ((v4 & 0x80) != 0)
    {
      BOOL v17 = memcmp(*(const void **)a1, a2, *((void *)a1 + 1)) == 0;
    }
    else if (a1[23])
    {
      uint64_t v8 = v4 - 1;
      xpc_object_t v9 = a1;
      do
      {
        int v11 = *v9++;
        int v10 = v11;
        int v13 = *a2++;
        int v12 = v13;
        BOOL v15 = v8-- != 0;
        BOOL v16 = v10 == v12;
        BOOL v17 = v10 == v12;
      }
      while (v16 && v15);
    }
    else
    {
      BOOL v17 = 1;
    }
  }
  else
  {
    BOOL v17 = 0;
  }
  return *((_DWORD *)a1 + 6) == *((_DWORD *)v2 + 6) && v17;
}

void sub_1005921DC(uint64_t a1, void **a2)
{
  uint64_t v3 = *a2;
  xpc_object_t object = v3;
  if (v3 && xpc_get_type(v3) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v3);
    xpc_object_t v4 = object;
  }
  else
  {
    xpc_object_t v4 = xpc_null_create();
    xpc_object_t object = v4;
  }
  if (xpc_get_type(v4) == (xpc_type_t)&_xpc_type_dictionary)
  {
    p_xpc_object_t object = &object;
    int v13 = "cellServiceMask";
    sub_100048BAC((uint64_t)&p_object, &v14);
    uint64_t v6 = (sd *)xpc::dyn_cast_or_default((xpc *)&v14, 0, v5);
    xpc_release(v14);
    *(_DWORD *)a1 = sd::imsServiceMaskFromUint(v6, v7);
    p_xpc_object_t object = &object;
    int v13 = "wifiServiceMask";
    sub_100048BAC((uint64_t)&p_object, &v14);
    xpc_object_t v9 = (sd *)xpc::dyn_cast_or_default((xpc *)&v14, 0, v8);
    xpc_release(v14);
    *(_DWORD *)(a1 + 4) = sd::imsServiceMaskFromUint(v9, v10);
    p_xpc_object_t object = &object;
    int v13 = "voNREnabled";
    sub_100048BAC((uint64_t)&p_object, &v14);
    *(unsigned char *)(a1 + 8) = xpc::dyn_cast_or_default((xpc *)&v14, 0, v11);
    xpc_release(v14);
  }
  else
  {
    *(unsigned char *)(a1 + 8) = 0;
    *(void *)a1 = 0;
  }
  xpc_release(object);
}

void sub_100592328(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, xpc_object_t object, xpc_object_t a12)
{
}

void sub_1005923A0(uint64_t a1@<X0>, xpc_object_t *a2@<X8>)
{
  xpc_object_t v18 = 0;
  xpc_object_t v4 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v5 = v4;
  if (v4)
  {
    xpc_object_t v18 = v4;
  }
  else
  {
    xpc_object_t v5 = xpc_null_create();
    xpc_object_t v18 = v5;
    if (!v5)
    {
      xpc_object_t v6 = xpc_null_create();
      xpc_object_t v5 = 0;
      goto LABEL_8;
    }
  }
  if (xpc_get_type(v5) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v5);
    goto LABEL_9;
  }
  xpc_object_t v6 = xpc_null_create();
LABEL_8:
  xpc_object_t v18 = v6;
LABEL_9:
  xpc_release(v5);
  unsigned int v7 = sd::imsServiceMaskToUint();
  xpc_object_t object = xpc_int64_create(v7);
  if (!object) {
    xpc_object_t object = xpc_null_create();
  }
  xpc_object_t v14 = &v18;
  BOOL v15 = "cellServiceMask";
  sub_100035E70((uint64_t)&v14, &object, &v17);
  xpc_release(v17);
  xpc_object_t v17 = 0;
  xpc_release(object);
  xpc_object_t object = 0;
  unsigned int v8 = sd::imsServiceMaskToUint();
  xpc_object_t v12 = xpc_int64_create(v8);
  if (!v12) {
    xpc_object_t v12 = xpc_null_create();
  }
  xpc_object_t v14 = &v18;
  BOOL v15 = "wifiServiceMask";
  sub_100035E70((uint64_t)&v14, &v12, &v13);
  xpc_release(v13);
  xpc_object_t v13 = 0;
  xpc_release(v12);
  xpc_object_t v12 = 0;
  xpc_object_t v10 = xpc_BOOL_create(*(unsigned char *)(a1 + 8));
  if (!v10) {
    xpc_object_t v10 = xpc_null_create();
  }
  xpc_object_t v14 = &v18;
  BOOL v15 = "voNREnabled";
  sub_100035E70((uint64_t)&v14, &v10, &v11);
  xpc_release(v11);
  xpc_object_t v11 = 0;
  xpc_release(v10);
  xpc_object_t v10 = 0;
  xpc_object_t v9 = v18;
  *a2 = v18;
  if (v9) {
    xpc_retain(v9);
  }
  else {
    *a2 = xpc_null_create();
  }
  xpc_release(v18);
}

void sub_10059259C(_Unwind_Exception *a1)
{
  xpc_release(*(xpc_object_t *)(v1 - 40));
  _Unwind_Resume(a1);
}

uint64_t sub_1005925D0(unsigned __int8 **a1, uint64_t a2)
{
  unint64_t v2 = *a1;
  uint64_t v3 = a1[1];
  xpc_object_t v4 = *(unsigned __int8 **)a2;
  if (v3 - *a1 != *(void *)(a2 + 8) - *(void *)a2) {
    return 0;
  }
  if (v2 == v3) {
    return 1;
  }
  do
  {
    uint64_t result = sub_1000609C0((uint64_t)&v6, v2, v4);
    if (!result) {
      break;
    }
    v2 += 24;
    v4 += 24;
  }
  while (v2 != v3);
  return result;
}

void sub_100592650(uint64_t a1@<X0>, xpc_object_t *a2@<X8>)
{
  xpc_object_t v4 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v5 = v4;
  if (v4)
  {
    xpc_object_t v17 = v4;
  }
  else
  {
    xpc_object_t v5 = xpc_null_create();
    xpc_object_t v17 = v5;
    if (!v5)
    {
      xpc_object_t v6 = xpc_null_create();
      xpc_object_t v5 = 0;
      goto LABEL_8;
    }
  }
  if (xpc_get_type(v5) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v5);
    goto LABEL_9;
  }
  xpc_object_t v6 = xpc_null_create();
LABEL_8:
  xpc_object_t v17 = v6;
LABEL_9:
  xpc_release(v5);
  write_rest_value();
  xpc_object_t v13 = &v17;
  xpc_object_t v14 = "persona";
  sub_100035E70((uint64_t)&v13, &object, &v16);
  xpc_release(v16);
  xpc_object_t v16 = 0;
  xpc_release(object);
  xpc_object_t object = 0;
  if (*(char *)(a1 + 47) >= 0) {
    unsigned int v7 = (const char *)(a1 + 24);
  }
  else {
    unsigned int v7 = *(const char **)(a1 + 24);
  }
  xpc_object_t v11 = xpc_string_create(v7);
  if (!v11) {
    xpc_object_t v11 = xpc_null_create();
  }
  xpc_object_t v13 = &v17;
  xpc_object_t v14 = "p_associated_uri";
  sub_100035E70((uint64_t)&v13, &v11, &v12);
  xpc_release(v12);
  xpc_object_t v12 = 0;
  xpc_release(v11);
  xpc_object_t v11 = 0;
  sub_100029348((uint64_t *)(a1 + 48), &v9);
  xpc_object_t v13 = &v17;
  xpc_object_t v14 = "all_associated_uris";
  sub_100035E70((uint64_t)&v13, &v9, &v10);
  xpc_release(v10);
  xpc_object_t v10 = 0;
  xpc_release(v9);
  xpc_object_t v9 = 0;
  xpc_object_t v8 = v17;
  *a2 = v17;
  if (v8) {
    xpc_retain(v8);
  }
  else {
    *a2 = xpc_null_create();
  }
  xpc_release(v17);
}

void sub_100592838(_Unwind_Exception *a1)
{
  xpc_release(*(xpc_object_t *)(v1 - 40));
  _Unwind_Resume(a1);
}

void sub_100592850(uint64_t a1, xpc_object_t *a2)
{
  xpc_object_t v12 = *a2;
  if (v12 && xpc_get_type(v12) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v12);
    xpc_object_t v3 = v12;
  }
  else
  {
    xpc_object_t v3 = xpc_null_create();
    xpc_object_t v12 = v3;
  }
  if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_dictionary)
  {
    v6[0] = &v12;
    v6[1] = "persona";
    sub_100048BAC((uint64_t)v6, &v13);
    read_rest_value();
    xpc_release((xpc_object_t)v13);
    v10[0] = &v12;
    v10[1] = "p_associated_uri";
    sub_100048BAC((uint64_t)v10, &v11);
    v6[0] = 0;
    v6[1] = 0;
    __p[0] = 0;
    xpc::dyn_cast_or_default();
    if (SHIBYTE(__p[0]) < 0) {
      operator delete(v6[0]);
    }
    xpc_object_t v5 = (void **)(a1 + 24);
    if (*(char *)(a1 + 47) < 0) {
      operator delete(*v5);
    }
    *(_OWORD *)xpc_object_t v5 = v13;
    *(void *)(a1 + 40) = v14;
    xpc_release(v11);
    v6[0] = &v12;
    v6[1] = "all_associated_uris";
    sub_100048BAC((uint64_t)v6, &v13);
    sub_100033E28((uint64_t *)(a1 + 48), (xpc_object_t *)&v13);
    xpc_release((xpc_object_t)v13);
  }
  else
  {
    uint64_t v9 = 0;
    long long v8 = 0u;
    *(_OWORD *)xpc_object_t v6 = 0u;
    memset(__p, 0, sizeof(__p));
    std::string::operator=((std::string *)a1, (const std::string *)v6);
    xpc_object_t v4 = (void **)(a1 + 24);
    if (*(char *)(a1 + 47) < 0) {
      operator delete(*v4);
    }
    *(_OWORD *)xpc_object_t v4 = *(_OWORD *)&__p[1];
    *(void **)(a1 + 40) = __p[3];
    HIBYTE(__p[3]) = 0;
    LOBYTE(__p[1]) = 0;
    sub_10005CBB4((uint64_t *)(a1 + 48));
    *(_OWORD *)(a1 + 48) = v8;
    *(void *)(a1 + 64) = v9;
    uint64_t v9 = 0;
    long long v8 = 0uLL;
    *(void *)&long long v13 = &v8;
    sub_100047F64((void ***)&v13);
    if (SHIBYTE(__p[3]) < 0) {
      operator delete(__p[1]);
    }
    if (SHIBYTE(__p[0]) < 0) {
      operator delete(v6[0]);
    }
  }
  xpc_release(v12);
}

void sub_100592A50(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  xpc_release(*(xpc_object_t *)(v14 - 56));
  xpc_release(*(xpc_object_t *)(v14 - 64));
  _Unwind_Resume(a1);
}

uint64_t sub_100592AE0(uint64_t a1)
{
  xpc_object_t v3 = (void **)(a1 + 48);
  sub_100047F64(&v3);
  if (*(char *)(a1 + 47) < 0) {
    operator delete(*(void **)(a1 + 24));
  }
  if (*(char *)(a1 + 23) < 0) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t sub_100592B3C@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t v37 = 0;
  long long v35 = 0u;
  long long v36 = 0u;
  long long v33 = 0u;
  long long v34 = 0u;
  long long v31 = 0u;
  long long v32 = 0u;
  long long v29 = 0u;
  long long v30 = 0u;
  long long v27 = 0u;
  long long v28 = 0u;
  *(_OWORD *)std::string __p = 0u;
  long long v26 = 0u;
  memset(v24, 0, sizeof(v24));
  long long v23 = 0u;
  sub_10004BD84((uint64_t)&v23);
  uint64_t v4 = *(unsigned __int8 *)(a1 + 23);
  BOOL v5 = (v4 & 0x80u) != 0;
  if ((v4 & 0x80u) != 0) {
    uint64_t v4 = *(void *)(a1 + 8);
  }
  if (v5) {
    xpc_object_t v6 = *(const char **)a1;
  }
  else {
    xpc_object_t v6 = (const char *)a1;
  }
  if (v4) {
    unsigned int v7 = v6;
  }
  else {
    unsigned int v7 = "<invalid>";
  }
  size_t v8 = strlen(v7);
  uint64_t v9 = sub_10004B96C(v24, (uint64_t)v7, v8);
  xpc_object_t v10 = sub_10004B96C(v9, (uint64_t)": p_associated_uri=", 19);
  int v11 = *(char *)(a1 + 47);
  if (v11 >= 0) {
    uint64_t v12 = a1 + 24;
  }
  else {
    uint64_t v12 = *(void *)(a1 + 24);
  }
  if (v11 >= 0) {
    uint64_t v13 = *(unsigned __int8 *)(a1 + 47);
  }
  else {
    uint64_t v13 = *(void *)(a1 + 32);
  }
  uint64_t v14 = sub_10004B96C(v10, v12, v13);
  sub_10004B96C(v14, (uint64_t)", all=[", 7);
  uint64_t v15 = *(void *)(a1 + 48);
  uint64_t v16 = *(void *)(a1 + 56);
  if (v15 != v16)
  {
    char v17 = 1;
    do
    {
      if ((v17 & 1) == 0) {
        sub_10004B96C(v24, (uint64_t)", ", 2);
      }
      int v18 = *(char *)(v15 + 23);
      if (v18 >= 0) {
        uint64_t v19 = v15;
      }
      else {
        uint64_t v19 = *(void *)v15;
      }
      if (v18 >= 0) {
        uint64_t v20 = *(unsigned __int8 *)(v15 + 23);
      }
      else {
        uint64_t v20 = *(void *)(v15 + 8);
      }
      sub_10004B96C(v24, v19, v20);
      char v17 = 0;
      v15 += 24;
    }
    while (v15 != v16);
  }
  sub_10004B96C(v24, (uint64_t)"]", 1);
  sub_10004BC98((uint64_t)v24 + 8, a2);
  *(void *)((char *)&v24[-1]
  *(void *)&v24[0] = v21;
  if (SHIBYTE(v26) < 0) {
    operator delete(__p[1]);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return std::ios::~ios();
}

void sub_100592DC8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_100592DE4(unsigned __int8 *a1, unsigned __int8 *a2)
{
  uint64_t v2 = a1[23];
  if ((v2 & 0x80u) == 0) {
    uint64_t v3 = a1[23];
  }
  else {
    uint64_t v3 = *((void *)a1 + 1);
  }
  uint64_t v4 = a2[23];
  int v5 = (char)v4;
  if ((v4 & 0x80u) != 0) {
    uint64_t v4 = *((void *)a2 + 1);
  }
  if (v3 != v4) {
    return 0;
  }
  xpc_object_t v6 = a2;
  if (v5 < 0) {
    a2 = *(unsigned __int8 **)a2;
  }
  if ((v2 & 0x80) != 0)
  {
    if (memcmp(*(const void **)a1, a2, *((void *)a1 + 1))) {
      return 0;
    }
  }
  else if (a1[23])
  {
    size_t v8 = a1;
    while (*v8 == *a2)
    {
      ++v8;
      ++a2;
      if (!--v2) {
        goto LABEL_16;
      }
    }
    return 0;
  }
LABEL_16:
  uint64_t v9 = a1[47];
  if ((v9 & 0x80u) == 0) {
    uint64_t v10 = a1[47];
  }
  else {
    uint64_t v10 = *((void *)a1 + 4);
  }
  uint64_t v11 = v6[47];
  int v12 = (char)v11;
  if ((v11 & 0x80u) != 0) {
    uint64_t v11 = *((void *)v6 + 4);
  }
  if (v10 != v11) {
    return 0;
  }
  uint64_t v13 = (const void **)(a1 + 24);
  if (v12 >= 0) {
    uint64_t v14 = v6 + 24;
  }
  else {
    uint64_t v14 = (unsigned __int8 *)*((void *)v6 + 3);
  }
  if ((v9 & 0x80) != 0)
  {
    if (memcmp(*v13, v14, *((void *)a1 + 4))) {
      return 0;
    }
  }
  else if (a1[47])
  {
    while (*(unsigned __int8 *)v13 == *v14)
    {
      uint64_t v13 = (const void **)((char *)v13 + 1);
      ++v14;
      if (!--v9) {
        goto LABEL_31;
      }
    }
    return 0;
  }
LABEL_31:
  uint64_t v15 = a1[71];
  if ((v15 & 0x80u) == 0) {
    uint64_t v16 = a1[71];
  }
  else {
    uint64_t v16 = *((void *)a1 + 7);
  }
  uint64_t v17 = v6[71];
  int v18 = (char)v17;
  if ((v17 & 0x80u) != 0) {
    uint64_t v17 = *((void *)v6 + 7);
  }
  if (v16 != v17) {
    return 0;
  }
  uint64_t v19 = (const void **)(a1 + 48);
  if (v18 >= 0) {
    uint64_t v20 = v6 + 48;
  }
  else {
    uint64_t v20 = (unsigned __int8 *)*((void *)v6 + 6);
  }
  if ((v15 & 0x80) != 0)
  {
    if (memcmp(*v19, v20, *((void *)a1 + 7))) {
      return 0;
    }
  }
  else if (a1[71])
  {
    while (*(unsigned __int8 *)v19 == *v20)
    {
      uint64_t v19 = (const void **)((char *)v19 + 1);
      ++v20;
      if (!--v15) {
        goto LABEL_46;
      }
    }
    return 0;
  }
LABEL_46:
  uint64_t v21 = a1[95];
  if ((v21 & 0x80u) == 0) {
    uint64_t v22 = a1[95];
  }
  else {
    uint64_t v22 = *((void *)a1 + 10);
  }
  uint64_t v23 = v6[95];
  int v24 = (char)v23;
  if ((v23 & 0x80u) != 0) {
    uint64_t v23 = *((void *)v6 + 10);
  }
  if (v22 != v23) {
    return 0;
  }
  char v25 = (const void **)(a1 + 72);
  if (v24 >= 0) {
    long long v26 = v6 + 72;
  }
  else {
    long long v26 = (unsigned __int8 *)*((void *)v6 + 9);
  }
  if ((v21 & 0x80) != 0)
  {
    if (memcmp(*v25, v26, *((void *)a1 + 10))) {
      return 0;
    }
  }
  else if (a1[95])
  {
    while (*(unsigned __int8 *)v25 == *v26)
    {
      char v25 = (const void **)((char *)v25 + 1);
      ++v26;
      if (!--v21) {
        goto LABEL_61;
      }
    }
    return 0;
  }
LABEL_61:
  long long v27 = (unsigned __int8 *)*((void *)a1 + 15);
  long long v28 = (unsigned __int8 *)*((void *)a1 + 16);
  long long v29 = (unsigned __int8 *)*((void *)v6 + 15);
  if (v28 - v27 != *((void *)v6 + 16) - (void)v29) {
    return 0;
  }
  while (v27 != v28)
  {
    uint64_t result = sub_1000609C0((uint64_t)&v37, v27, v29);
    if (!result) {
      return result;
    }
    v27 += 24;
    v29 += 24;
  }
  uint64_t v31 = a1[167];
  if ((v31 & 0x80u) == 0) {
    uint64_t v32 = a1[167];
  }
  else {
    uint64_t v32 = *((void *)a1 + 19);
  }
  uint64_t v33 = v6[167];
  int v34 = (char)v33;
  if ((v33 & 0x80u) != 0) {
    uint64_t v33 = *((void *)v6 + 19);
  }
  if (v32 != v33) {
    return 0;
  }
  long long v35 = (const void **)(a1 + 144);
  if (v34 >= 0) {
    long long v36 = v6 + 144;
  }
  else {
    long long v36 = (unsigned __int8 *)*((void *)v6 + 18);
  }
  if ((v31 & 0x80) != 0)
  {
    if (!memcmp(*v35, v36, *((void *)a1 + 19))) {
      goto LABEL_82;
    }
    return 0;
  }
  if (a1[167])
  {
    while (*(unsigned __int8 *)v35 == *v36)
    {
      long long v35 = (const void **)((char *)v35 + 1);
      ++v36;
      if (!--v31) {
        goto LABEL_82;
      }
    }
    return 0;
  }
LABEL_82:
  uint64_t result = sub_1005925D0((unsigned __int8 **)a1 + 21, (uint64_t)(v6 + 168));
  if (result) {
    return *((_DWORD *)a1 + 48) == *((_DWORD *)v6 + 48);
  }
  return result;
}

void *sub_1005930F0(void *a1, uint64_t a2)
{
  uint64_t v50 = 0;
  long long v48 = 0u;
  long long v49 = 0u;
  long long v46 = 0u;
  long long v47 = 0u;
  long long v44 = 0u;
  long long v45 = 0u;
  long long v42 = 0u;
  long long v43 = 0u;
  long long v40 = 0u;
  long long v41 = 0u;
  *(_OWORD *)uint64_t v38 = 0u;
  long long v39 = 0u;
  memset(v37, 0, sizeof(v37));
  long long v36 = 0u;
  sub_10004BD84((uint64_t)&v36);
  uint64_t v4 = *(void *)(a2 + 120);
  for (uint64_t i = *(void *)(a2 + 128); v4 != i; v4 += 24)
  {
    xpc_object_t v6 = sub_10004B96C(v37, (uint64_t)", ", 2);
    int v7 = *(char *)(v4 + 23);
    if (v7 >= 0) {
      uint64_t v8 = v4;
    }
    else {
      uint64_t v8 = *(void *)v4;
    }
    if (v7 >= 0) {
      uint64_t v9 = *(unsigned __int8 *)(v4 + 23);
    }
    else {
      uint64_t v9 = *(void *)(v4 + 8);
    }
    sub_10004B96C(v6, v8, v9);
  }
  uint64_t v10 = sub_10004B96C(a1, (uint64_t)"t_ims_info(", 11);
  int v11 = *(char *)(a2 + 23);
  if (v11 >= 0) {
    uint64_t v12 = a2;
  }
  else {
    uint64_t v12 = *(void *)a2;
  }
  if (v11 >= 0) {
    uint64_t v13 = *(unsigned __int8 *)(a2 + 23);
  }
  else {
    uint64_t v13 = *(void *)(a2 + 8);
  }
  uint64_t v14 = sub_10004B96C(v10, v12, v13);
  uint64_t v15 = sub_10004B96C(v14, (uint64_t)", ", 2);
  int v16 = *(char *)(a2 + 95);
  if (v16 >= 0) {
    uint64_t v17 = a2 + 72;
  }
  else {
    uint64_t v17 = *(void *)(a2 + 72);
  }
  if (v16 >= 0) {
    uint64_t v18 = *(unsigned __int8 *)(a2 + 95);
  }
  else {
    uint64_t v18 = *(void *)(a2 + 80);
  }
  uint64_t v19 = sub_10004B96C(v15, v17, v18);
  sub_10004BC98((uint64_t)v37 + 8, __p);
  if ((v35 & 0x80u) == 0) {
    uint64_t v20 = __p;
  }
  else {
    uint64_t v20 = (void **)__p[0];
  }
  if ((v35 & 0x80u) == 0) {
    uint64_t v21 = v35;
  }
  else {
    uint64_t v21 = (uint64_t)__p[1];
  }
  uint64_t v22 = sub_10004B96C(v19, (uint64_t)v20, v21);
  uint64_t v23 = sub_10004B96C(v22, (uint64_t)", ", 2);
  uint64_t v26 = *(void *)(a2 + 144);
  uint64_t v25 = a2 + 144;
  uint64_t v24 = v26;
  int v27 = *(char *)(v25 + 23);
  if (v27 >= 0) {
    uint64_t v28 = v25;
  }
  else {
    uint64_t v28 = v24;
  }
  if (v27 >= 0) {
    uint64_t v29 = *(unsigned __int8 *)(v25 + 23);
  }
  else {
    uint64_t v29 = *(void *)(v25 + 8);
  }
  long long v30 = sub_10004B96C(v23, v28, v29);
  uint64_t v31 = sub_10004B96C(v30, (uint64_t)")", 1);
  if ((char)v35 < 0) {
    operator delete(__p[0]);
  }
  *(void *)((char *)&v37[-1]
  *(void *)&v37[0] = v32;
  if (SHIBYTE(v39) < 0) {
    operator delete(v38[1]);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  std::ios::~ios();
  return v31;
}

void sub_1005933C8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16)
{
}

uint64_t sub_1005933FC@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t v20 = 0;
  long long v18 = 0u;
  long long v19 = 0u;
  long long v16 = 0u;
  long long v17 = 0u;
  long long v14 = 0u;
  long long v15 = 0u;
  long long v12 = 0u;
  long long v13 = 0u;
  long long v10 = 0u;
  long long v11 = 0u;
  *(_OWORD *)std::string __p = 0u;
  long long v9 = 0u;
  memset(v7, 0, sizeof(v7));
  long long v6 = 0u;
  sub_10004BD84((uint64_t)&v6);
  sub_1005930F0(v7, a1);
  sub_10004BC98((uint64_t)v7 + 8, a2);
  *(void *)((char *)&v7[-1]
  *(void *)&v7[0] = v4;
  if (SHIBYTE(v9) < 0) {
    operator delete(__p[1]);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return std::ios::~ios();
}

void sub_10059359C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1005935B0(uint64_t a1@<X0>, xpc_object_t *a2@<X8>)
{
  xpc_object_t v29 = 0;
  xpc_object_t v4 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v5 = v4;
  if (v4)
  {
    xpc_object_t v29 = v4;
  }
  else
  {
    xpc_object_t v5 = xpc_null_create();
    xpc_object_t v29 = v5;
    if (!v5)
    {
      xpc_object_t v6 = xpc_null_create();
      xpc_object_t v5 = 0;
      goto LABEL_8;
    }
  }
  if (xpc_get_type(v5) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v5);
    goto LABEL_9;
  }
  xpc_object_t v6 = xpc_null_create();
LABEL_8:
  xpc_object_t v29 = v6;
LABEL_9:
  xpc_release(v5);
  if (*(char *)(a1 + 23) >= 0) {
    int v7 = (const char *)a1;
  }
  else {
    int v7 = *(const char **)a1;
  }
  xpc_object_t v27 = xpc_string_create(v7);
  if (!v27) {
    xpc_object_t v27 = xpc_null_create();
  }
  uint64_t v25 = &v29;
  uint64_t v26 = "imsi";
  sub_100035E70((uint64_t)&v25, &v27, &v28);
  xpc_release(v28);
  xpc_object_t v28 = 0;
  xpc_release(v27);
  xpc_object_t v27 = 0;
  if (*(char *)(a1 + 47) >= 0) {
    uint64_t v8 = (const char *)(a1 + 24);
  }
  else {
    uint64_t v8 = *(const char **)(a1 + 24);
  }
  xpc_object_t object = xpc_string_create(v8);
  if (!object) {
    xpc_object_t object = xpc_null_create();
  }
  uint64_t v25 = &v29;
  uint64_t v26 = "mcc";
  sub_100035E70((uint64_t)&v25, &object, &v24);
  xpc_release(v24);
  xpc_object_t v24 = 0;
  xpc_release(object);
  xpc_object_t object = 0;
  if (*(char *)(a1 + 71) >= 0) {
    long long v9 = (const char *)(a1 + 48);
  }
  else {
    long long v9 = *(const char **)(a1 + 48);
  }
  xpc_object_t v21 = xpc_string_create(v9);
  if (!v21) {
    xpc_object_t v21 = xpc_null_create();
  }
  uint64_t v25 = &v29;
  uint64_t v26 = "mnc";
  sub_100035E70((uint64_t)&v25, &v21, &v22);
  xpc_release(v22);
  xpc_object_t v22 = 0;
  xpc_release(v21);
  xpc_object_t v21 = 0;
  if (*(char *)(a1 + 95) >= 0) {
    long long v10 = (const char *)(a1 + 72);
  }
  else {
    long long v10 = *(const char **)(a1 + 72);
  }
  xpc_object_t v19 = xpc_string_create(v10);
  if (!v19) {
    xpc_object_t v19 = xpc_null_create();
  }
  uint64_t v25 = &v29;
  uint64_t v26 = "impi";
  sub_100035E70((uint64_t)&v25, &v19, &v20);
  xpc_release(v20);
  xpc_object_t v20 = 0;
  xpc_release(v19);
  xpc_object_t v19 = 0;
  sub_100029348((uint64_t *)(a1 + 120), &v17);
  uint64_t v25 = &v29;
  uint64_t v26 = "impu";
  sub_100035E70((uint64_t)&v25, &v17, &v18);
  xpc_release(v18);
  xpc_object_t v18 = 0;
  xpc_release(v17);
  xpc_object_t v17 = 0;
  if (*(char *)(a1 + 167) >= 0) {
    long long v11 = (const char *)(a1 + 144);
  }
  else {
    long long v11 = *(const char **)(a1 + 144);
  }
  xpc_object_t v15 = xpc_string_create(v11);
  if (!v15) {
    xpc_object_t v15 = xpc_null_create();
  }
  uint64_t v25 = &v29;
  uint64_t v26 = "domain";
  sub_100035E70((uint64_t)&v25, &v15, &v16);
  xpc_release(v16);
  xpc_object_t v16 = 0;
  xpc_release(v15);
  xpc_object_t v15 = 0;
  sub_100029348((uint64_t *)(a1 + 168), &v13);
  uint64_t v25 = &v29;
  uint64_t v26 = "pcscfs";
  sub_100035E70((uint64_t)&v25, &v13, &v14);
  xpc_release(v14);
  xpc_object_t v14 = 0;
  xpc_release(v13);
  xpc_object_t v13 = 0;
  xpc_object_t v12 = v29;
  *a2 = v29;
  if (v12) {
    xpc_retain(v12);
  }
  else {
    *a2 = xpc_null_create();
  }
  xpc_release(v29);
}

void sub_100593958(_Unwind_Exception *a1)
{
  xpc_release(*(xpc_object_t *)(v1 - 40));
  _Unwind_Resume(a1);
}

void sub_100593970(uint64_t a1, xpc_object_t *a2)
{
  xpc_object_t v27 = *a2;
  if (v27 && xpc_get_type(v27) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v27);
    xpc_object_t v3 = v27;
  }
  else
  {
    xpc_object_t v3 = xpc_null_create();
    xpc_object_t v27 = v3;
  }
  if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_object_t v24 = &v27;
    uint64_t v25 = "imsi";
    sub_100048BAC((uint64_t)&v24, &v26);
    __p[0] = 0;
    __p[1] = 0;
    *(void *)&v14[0] = 0;
    xpc::dyn_cast_or_default();
    if (*(char *)(a1 + 23) < 0) {
      operator delete(*(void **)a1);
    }
    *(_OWORD *)a1 = v28;
    *(void *)(a1 + 16) = v29;
    xpc_release(v26);
    xpc_object_t v24 = &v27;
    uint64_t v25 = "mcc";
    sub_100048BAC((uint64_t)&v24, &v26);
    __p[0] = 0;
    __p[1] = 0;
    *(void *)&v14[0] = 0;
    xpc::dyn_cast_or_default();
    long long v9 = (void **)(a1 + 24);
    if (*(char *)(a1 + 47) < 0) {
      operator delete(*v9);
    }
    *(_OWORD *)long long v9 = v28;
    *(void *)(a1 + 40) = v29;
    xpc_release(v26);
    xpc_object_t v24 = &v27;
    uint64_t v25 = "mnc";
    sub_100048BAC((uint64_t)&v24, &v26);
    __p[0] = 0;
    __p[1] = 0;
    *(void *)&v14[0] = 0;
    xpc::dyn_cast_or_default();
    long long v10 = (void **)(a1 + 48);
    if (*(char *)(a1 + 71) < 0) {
      operator delete(*v10);
    }
    *(_OWORD *)long long v10 = v28;
    *(void *)(a1 + 64) = v29;
    xpc_release(v26);
    xpc_object_t v24 = &v27;
    uint64_t v25 = "impi";
    sub_100048BAC((uint64_t)&v24, &v26);
    __p[0] = 0;
    __p[1] = 0;
    *(void *)&v14[0] = 0;
    xpc::dyn_cast_or_default();
    long long v11 = (void **)(a1 + 72);
    if (*(char *)(a1 + 95) < 0) {
      operator delete(*v11);
    }
    *(_OWORD *)long long v11 = v28;
    *(void *)(a1 + 88) = v29;
    xpc_release(v26);
    __p[0] = &v27;
    __p[1] = "impu";
    sub_100048BAC((uint64_t)__p, &v28);
    sub_100033E28((uint64_t *)(a1 + 120), (xpc_object_t *)&v28);
    xpc_release((xpc_object_t)v28);
    xpc_object_t v24 = &v27;
    uint64_t v25 = "domain";
    sub_100048BAC((uint64_t)&v24, &v26);
    __p[0] = 0;
    __p[1] = 0;
    *(void *)&v14[0] = 0;
    xpc::dyn_cast_or_default();
    if (SBYTE7(v14[0]) < 0) {
      operator delete(__p[0]);
    }
    xpc_object_t v12 = (void **)(a1 + 144);
    if (*(char *)(a1 + 167) < 0) {
      operator delete(*v12);
    }
    *(_OWORD *)xpc_object_t v12 = v28;
    *(void *)(a1 + 160) = v29;
    xpc_release(v26);
    __p[0] = &v27;
    __p[1] = "pcscfs";
    sub_100048BAC((uint64_t)__p, &v28);
    sub_100033E28((uint64_t *)(a1 + 168), (xpc_object_t *)&v28);
    xpc_release((xpc_object_t)v28);
  }
  else
  {
    int v23 = 0;
    long long v21 = 0u;
    long long v22 = 0u;
    long long v19 = 0u;
    long long v20 = 0u;
    long long v17 = 0u;
    long long v18 = 0u;
    memset(v16, 0, sizeof(v16));
    long long v15 = 0u;
    *(_OWORD *)std::string __p = 0u;
    memset(v14, 0, sizeof(v14));
    if (*(char *)(a1 + 23) < 0) {
      operator delete(*(void **)a1);
    }
    *(void *)a1 = 0;
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
    BYTE7(v14[0]) = 0;
    LOBYTE(__p[0]) = 0;
    xpc_object_t v4 = (void **)(a1 + 24);
    if (*(char *)(a1 + 47) < 0) {
      operator delete(*v4);
    }
    *(_OWORD *)xpc_object_t v4 = *(_OWORD *)((char *)v14 + 8);
    *(void *)(a1 + 40) = *((void *)&v14[1] + 1);
    HIBYTE(v14[1]) = 0;
    BYTE8(v14[0]) = 0;
    xpc_object_t v5 = (void **)(a1 + 48);
    if (*(char *)(a1 + 71) < 0) {
      operator delete(*v5);
    }
    *(_OWORD *)xpc_object_t v5 = v15;
    *(void *)(a1 + 64) = *(void *)&v16[0];
    BYTE7(v16[0]) = 0;
    LOBYTE(v15) = 0;
    xpc_object_t v6 = (void **)(a1 + 72);
    if (*(char *)(a1 + 95) < 0) {
      operator delete(*v6);
    }
    *(_OWORD *)xpc_object_t v6 = *(_OWORD *)((char *)v16 + 8);
    *(void *)(a1 + 88) = *((void *)&v16[1] + 1);
    HIBYTE(v16[1]) = 0;
    BYTE8(v16[0]) = 0;
    int v7 = (void **)(a1 + 96);
    if (*(char *)(a1 + 119) < 0) {
      operator delete(*v7);
    }
    *(_OWORD *)int v7 = v17;
    *(void *)(a1 + 112) = v18;
    BYTE7(v18) = 0;
    LOBYTE(v17) = 0;
    sub_10005CBB4((uint64_t *)(a1 + 120));
    *(void *)(a1 + 120) = 0;
    *(void *)(a1 + 128) = 0;
    *(void *)(a1 + 136) = 0;
    long long v19 = 0uLL;
    *((void *)&v18 + 1) = 0;
    uint64_t v8 = (void **)(a1 + 144);
    if (*(char *)(a1 + 167) < 0) {
      operator delete(*v8);
    }
    *(_OWORD *)uint64_t v8 = v20;
    *(void *)(a1 + 160) = v21;
    BYTE7(v21) = 0;
    LOBYTE(v20) = 0;
    sub_10005CBB4((uint64_t *)(a1 + 168));
    *(void *)(a1 + 168) = 0;
    *(void *)(a1 + 176) = 0;
    *(void *)(a1 + 184) = 0;
    long long v22 = 0uLL;
    *((void *)&v21 + 1) = 0;
    *(_DWORD *)(a1 + 192) = 0;
    sub_10019D50C((uint64_t)__p);
  }
  xpc_release(v27);
}

void sub_100593E08(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  xpc_release(*(xpc_object_t *)(v14 - 72));
  xpc_release(*(xpc_object_t *)(v14 - 80));
  _Unwind_Resume(a1);
}

const void *sub_100593F38(unsigned __int8 *a1, unsigned __int8 *a2)
{
  uint64_t v2 = a1[23];
  if ((v2 & 0x80u) == 0) {
    uint64_t v3 = a1[23];
  }
  else {
    uint64_t v3 = *((void *)a1 + 1);
  }
  uint64_t v4 = a2[23];
  int v5 = (char)v4;
  if ((v4 & 0x80u) != 0) {
    uint64_t v4 = *((void *)a2 + 1);
  }
  if (v3 != v4) {
    return 0;
  }
  xpc_object_t v6 = a2;
  if (v5 < 0) {
    a2 = *(unsigned __int8 **)a2;
  }
  if ((v2 & 0x80) != 0)
  {
    if (memcmp(*(const void **)a1, a2, *((void *)a1 + 1))) {
      return 0;
    }
  }
  else if (a1[23])
  {
    uint64_t v8 = a1;
    while (*v8 == *a2)
    {
      ++v8;
      ++a2;
      if (!--v2) {
        goto LABEL_16;
      }
    }
    return 0;
  }
LABEL_16:
  uint64_t v9 = a1[47];
  if ((v9 & 0x80u) == 0) {
    uint64_t v10 = a1[47];
  }
  else {
    uint64_t v10 = *((void *)a1 + 4);
  }
  uint64_t v11 = v6[47];
  int v12 = (char)v11;
  if ((v11 & 0x80u) != 0) {
    uint64_t v11 = *((void *)v6 + 4);
  }
  if (v10 != v11) {
    return 0;
  }
  xpc_object_t v13 = (const void **)(a1 + 24);
  if (v12 >= 0) {
    uint64_t v14 = v6 + 24;
  }
  else {
    uint64_t v14 = (unsigned __int8 *)*((void *)v6 + 3);
  }
  if ((v9 & 0x80) != 0)
  {
    if (memcmp(*v13, v14, *((void *)a1 + 4))) {
      return 0;
    }
  }
  else if (a1[47])
  {
    while (*(unsigned __int8 *)v13 == *v14)
    {
      xpc_object_t v13 = (const void **)((char *)v13 + 1);
      ++v14;
      if (!--v9) {
        goto LABEL_31;
      }
    }
    return 0;
  }
LABEL_31:
  uint64_t v15 = a1[71];
  if ((v15 & 0x80u) == 0) {
    uint64_t v16 = a1[71];
  }
  else {
    uint64_t v16 = *((void *)a1 + 7);
  }
  uint64_t v17 = v6[71];
  int v18 = (char)v17;
  if ((v17 & 0x80u) != 0) {
    uint64_t v17 = *((void *)v6 + 7);
  }
  if (v16 != v17) {
    return 0;
  }
  long long v19 = (const void **)(a1 + 48);
  if (v18 >= 0) {
    long long v20 = v6 + 48;
  }
  else {
    long long v20 = (unsigned __int8 *)*((void *)v6 + 6);
  }
  if ((v15 & 0x80) != 0)
  {
    if (memcmp(*v19, v20, *((void *)a1 + 7))) {
      return 0;
    }
  }
  else if (a1[71])
  {
    while (*(unsigned __int8 *)v19 == *v20)
    {
      long long v19 = (const void **)((char *)v19 + 1);
      ++v20;
      if (!--v15) {
        goto LABEL_46;
      }
    }
    return 0;
  }
LABEL_46:
  uint64_t v21 = a1[95];
  if ((v21 & 0x80u) == 0) {
    uint64_t v22 = a1[95];
  }
  else {
    uint64_t v22 = *((void *)a1 + 10);
  }
  uint64_t v23 = v6[95];
  int v24 = (char)v23;
  if ((v23 & 0x80u) != 0) {
    uint64_t v23 = *((void *)v6 + 10);
  }
  if (v22 != v23) {
    return 0;
  }
  uint64_t v25 = (const void **)(a1 + 72);
  if (v24 >= 0) {
    xpc_object_t v26 = v6 + 72;
  }
  else {
    xpc_object_t v26 = (unsigned __int8 *)*((void *)v6 + 9);
  }
  if ((v21 & 0x80) != 0)
  {
    if (!memcmp(*v25, v26, *((void *)a1 + 10))) {
      goto LABEL_61;
    }
    return 0;
  }
  if (a1[95])
  {
    while (*(unsigned __int8 *)v25 == *v26)
    {
      uint64_t v25 = (const void **)((char *)v25 + 1);
      ++v26;
      if (!--v21) {
        goto LABEL_61;
      }
    }
    return 0;
  }
LABEL_61:
  xpc_object_t v27 = (unsigned __int8 *)*((void *)a1 + 12);
  long long v28 = (unsigned __int8 *)*((void *)a1 + 13);
  uint64_t v29 = (unsigned __int8 *)*((void *)v6 + 12);
  if (v28 - v27 != *((void *)v6 + 13) - (void)v29) {
    return 0;
  }
  while (v27 != v28)
  {
    uint64_t result = (const void *)sub_1000609C0((uint64_t)&v35, v27, v29);
    if (!result) {
      return result;
    }
    v27 += 24;
    v29 += 24;
  }
  uint64_t v31 = (unsigned __int8 *)*((void *)a1 + 15);
  uint64_t v32 = (unsigned __int8 *)*((void *)a1 + 16);
  uint64_t v33 = (unsigned __int8 *)*((void *)v6 + 15);
  if (v32 - v31 != *((void *)v6 + 16) - (void)v33) {
    return 0;
  }
  while (v31 != v32)
  {
    uint64_t result = (const void *)sub_1000609C0((uint64_t)&v36, v31, v33);
    if (!result) {
      return result;
    }
    v31 += 24;
    v33 += 24;
  }
  uint64_t result = (const void *)*((void *)a1 + 19);
  if (result)
  {
    int v34 = (const void *)*((void *)v6 + 19);
    if (v34) {
      return (const void *)(CFEqual(result, v34) != 0);
    }
    return 0;
  }
  return result;
}

uint64_t sub_100594204@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t v26 = 0;
  long long v24 = 0u;
  long long v25 = 0u;
  long long v22 = 0u;
  long long v23 = 0u;
  long long v20 = 0u;
  long long v21 = 0u;
  long long v18 = 0u;
  long long v19 = 0u;
  long long v16 = 0u;
  long long v17 = 0u;
  *(_OWORD *)std::string __p = 0u;
  long long v15 = 0u;
  memset(v13, 0, sizeof(v13));
  long long v12 = 0u;
  sub_10004BD84((uint64_t)&v12);
  uint64_t v4 = *(void *)(a1 + 96);
  for (uint64_t i = *(void *)(a1 + 104); v4 != i; v4 += 24)
  {
    xpc_object_t v6 = sub_10004B96C(v13, (uint64_t)", ", 2);
    int v7 = *(char *)(v4 + 23);
    if (v7 >= 0) {
      uint64_t v8 = v4;
    }
    else {
      uint64_t v8 = *(void *)v4;
    }
    if (v7 >= 0) {
      uint64_t v9 = *(unsigned __int8 *)(v4 + 23);
    }
    else {
      uint64_t v9 = *(void *)(v4 + 8);
    }
    sub_10004B96C(v6, v8, v9);
  }
  sub_10004BC98((uint64_t)v13 + 8, a2);
  *(void *)((char *)&v13[-1]
  *(void *)&v13[0] = v10;
  if (SHIBYTE(v15) < 0) {
    operator delete(__p[1]);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return std::ios::~ios();
}

void sub_1005943F0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_100594408@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t v26 = 0;
  long long v24 = 0u;
  long long v25 = 0u;
  long long v22 = 0u;
  long long v23 = 0u;
  long long v20 = 0u;
  long long v21 = 0u;
  long long v18 = 0u;
  long long v19 = 0u;
  long long v16 = 0u;
  long long v17 = 0u;
  *(_OWORD *)std::string __p = 0u;
  long long v15 = 0u;
  memset(v13, 0, sizeof(v13));
  long long v12 = 0u;
  sub_10004BD84((uint64_t)&v12);
  uint64_t v4 = *(void *)(a1 + 120);
  for (uint64_t i = *(void *)(a1 + 128); v4 != i; v4 += 24)
  {
    xpc_object_t v6 = sub_10004B96C(v13, (uint64_t)", ", 2);
    int v7 = *(char *)(v4 + 23);
    if (v7 >= 0) {
      uint64_t v8 = v4;
    }
    else {
      uint64_t v8 = *(void *)v4;
    }
    if (v7 >= 0) {
      uint64_t v9 = *(unsigned __int8 *)(v4 + 23);
    }
    else {
      uint64_t v9 = *(void *)(v4 + 8);
    }
    sub_10004B96C(v6, v8, v9);
  }
  sub_10004BC98((uint64_t)v13 + 8, a2);
  *(void *)((char *)&v13[-1]
  *(void *)&v13[0] = v10;
  if (SHIBYTE(v15) < 0) {
    operator delete(__p[1]);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return std::ios::~ios();
}

void sub_1005945F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

BOOL sub_10059460C(uint64_t a1)
{
  if (*(char *)(a1 + 23) < 0)
  {
    if (!*(void *)(a1 + 8)) {
      return 0;
    }
  }
  else if (!*(unsigned char *)(a1 + 23))
  {
    return 0;
  }
  if (*(char *)(a1 + 47) < 0)
  {
    if (!*(void *)(a1 + 32)) {
      return 0;
    }
  }
  else if (!*(unsigned char *)(a1 + 47))
  {
    return 0;
  }
  if (*(void *)(a1 + 96) != *(void *)(a1 + 104)) {
    return *(void *)(a1 + 120) != *(void *)(a1 + 128);
  }
  return 0;
}

void sub_100594668(uint64_t a1@<X0>, xpc_object_t *a2@<X8>)
{
  xpc_object_t v33 = 0;
  xpc_object_t v4 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v5 = v4;
  if (v4)
  {
    xpc_object_t v33 = v4;
  }
  else
  {
    xpc_object_t v5 = xpc_null_create();
    xpc_object_t v33 = v5;
    if (!v5)
    {
      xpc_object_t v6 = xpc_null_create();
      xpc_object_t v5 = 0;
      goto LABEL_8;
    }
  }
  if (xpc_get_type(v5) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v5);
    goto LABEL_9;
  }
  xpc_object_t v6 = xpc_null_create();
LABEL_8:
  xpc_object_t v33 = v6;
LABEL_9:
  xpc_release(v5);
  if (*(char *)(a1 + 23) >= 0) {
    int v7 = (const char *)a1;
  }
  else {
    int v7 = *(const char **)a1;
  }
  xpc_object_t v31 = xpc_string_create(v7);
  if (!v31) {
    xpc_object_t v31 = xpc_null_create();
  }
  uint64_t v29 = &v33;
  long long v30 = "domain";
  sub_100035E70((uint64_t)&v29, &v31, &v32);
  xpc_release(v32);
  xpc_object_t v32 = 0;
  xpc_release(v31);
  xpc_object_t v31 = 0;
  if (*(char *)(a1 + 47) >= 0) {
    uint64_t v8 = (const char *)(a1 + 24);
  }
  else {
    uint64_t v8 = *(const char **)(a1 + 24);
  }
  xpc_object_t v27 = xpc_string_create(v8);
  if (!v27) {
    xpc_object_t v27 = xpc_null_create();
  }
  uint64_t v29 = &v33;
  long long v30 = "impi";
  sub_100035E70((uint64_t)&v29, &v27, &v28);
  xpc_release(v28);
  xpc_object_t v28 = 0;
  xpc_release(v27);
  xpc_object_t v27 = 0;
  if (*(char *)(a1 + 71) >= 0) {
    uint64_t v9 = (const char *)(a1 + 48);
  }
  else {
    uint64_t v9 = *(const char **)(a1 + 48);
  }
  xpc_object_t v25 = xpc_string_create(v9);
  if (!v25) {
    xpc_object_t v25 = xpc_null_create();
  }
  uint64_t v29 = &v33;
  long long v30 = "user";
  sub_100035E70((uint64_t)&v29, &v25, &object);
  xpc_release(object);
  xpc_object_t object = 0;
  xpc_release(v25);
  xpc_object_t v25 = 0;
  if (*(char *)(a1 + 95) >= 0) {
    xpc_object_t v10 = (const char *)(a1 + 72);
  }
  else {
    xpc_object_t v10 = *(const char **)(a1 + 72);
  }
  xpc_object_t v23 = xpc_string_create(v10);
  if (!v23) {
    xpc_object_t v23 = xpc_null_create();
  }
  uint64_t v29 = &v33;
  long long v30 = "pwd";
  sub_100035E70((uint64_t)&v29, &v23, &v24);
  xpc_release(v24);
  xpc_object_t v24 = 0;
  xpc_release(v23);
  xpc_object_t v23 = 0;
  sub_100029348((uint64_t *)(a1 + 96), &v21);
  uint64_t v29 = &v33;
  long long v30 = "impus";
  sub_100035E70((uint64_t)&v29, &v21, &v22);
  xpc_release(v22);
  xpc_object_t v22 = 0;
  xpc_release(v21);
  xpc_object_t v21 = 0;
  sub_100029348((uint64_t *)(a1 + 120), &v19);
  uint64_t v29 = &v33;
  long long v30 = "pcscfs";
  sub_100035E70((uint64_t)&v29, &v19, &v20);
  xpc_release(v20);
  xpc_object_t v20 = 0;
  xpc_release(v19);
  xpc_object_t v19 = 0;
  unsigned int v11 = sd::imsServiceMaskToUint();
  xpc_object_t v17 = xpc_int64_create(v11);
  if (!v17) {
    xpc_object_t v17 = xpc_null_create();
  }
  uint64_t v29 = &v33;
  long long v30 = "services";
  sub_100035E70((uint64_t)&v29, &v17, &v18);
  xpc_release(v18);
  xpc_object_t v18 = 0;
  xpc_release(v17);
  xpc_object_t v17 = 0;
  ctu::cf_to_xpc((uint64_t *)&v29, *(ctu **)(a1 + 152), v12);
  xpc_object_t v13 = v29;
  if (v29 && xpc_get_type(v29) == (xpc_type_t)&_xpc_type_dictionary) {
    xpc_retain(v13);
  }
  else {
    xpc_object_t v13 = xpc_null_create();
  }
  xpc_release(v29);
  xpc_object_t v15 = v13;
  if (v13) {
    xpc_retain(v13);
  }
  else {
    xpc_object_t v15 = xpc_null_create();
  }
  uint64_t v29 = &v33;
  long long v30 = "imsConfig";
  sub_100035E70((uint64_t)&v29, &v15, &v16);
  xpc_release(v16);
  xpc_object_t v16 = 0;
  xpc_release(v15);
  xpc_object_t v15 = 0;
  xpc_object_t v14 = v33;
  *a2 = v33;
  if (v14) {
    xpc_retain(v14);
  }
  else {
    *a2 = xpc_null_create();
  }
  xpc_release(v13);
  xpc_release(v33);
}

void sub_100594A60(_Unwind_Exception *a1)
{
  xpc_release(*(xpc_object_t *)(v1 - 40));
  _Unwind_Resume(a1);
}

void sub_100594AD8(uint64_t a1, xpc_object_t *a2)
{
  xpc_object_t v28 = *a2;
  if (v28 && xpc_get_type(v28) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v28);
    xpc_object_t v3 = v28;
  }
  else
  {
    xpc_object_t v3 = xpc_null_create();
    xpc_object_t v28 = v3;
  }
  if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_object_t v25 = &v28;
    uint64_t v26 = "domain";
    sub_100048BAC((uint64_t)&v25, &v27);
    v15[0] = 0;
    v15[1] = 0;
    v16[0] = 0;
    xpc::dyn_cast_or_default();
    if (*(char *)(a1 + 23) < 0) {
      operator delete(*(void **)a1);
    }
    *(_OWORD *)a1 = v29;
    *(void *)(a1 + 16) = v30;
    xpc_release(v27);
    xpc_object_t v25 = &v28;
    uint64_t v26 = "impi";
    sub_100048BAC((uint64_t)&v25, &v27);
    v15[0] = 0;
    v15[1] = 0;
    v16[0] = 0;
    xpc::dyn_cast_or_default();
    int v7 = (void **)(a1 + 24);
    if (*(char *)(a1 + 47) < 0) {
      operator delete(*v7);
    }
    *(_OWORD *)int v7 = v29;
    *(void *)(a1 + 40) = v30;
    xpc_release(v27);
    xpc_object_t v25 = &v28;
    uint64_t v26 = "user";
    sub_100048BAC((uint64_t)&v25, &v27);
    v15[0] = 0;
    v15[1] = 0;
    v16[0] = 0;
    xpc::dyn_cast_or_default();
    uint64_t v8 = (void **)(a1 + 48);
    if (*(char *)(a1 + 71) < 0) {
      operator delete(*v8);
    }
    *(_OWORD *)uint64_t v8 = v29;
    *(void *)(a1 + 64) = v30;
    xpc_release(v27);
    xpc_object_t v25 = &v28;
    uint64_t v26 = "pwd";
    sub_100048BAC((uint64_t)&v25, &v27);
    v15[0] = 0;
    v15[1] = 0;
    v16[0] = 0;
    xpc::dyn_cast_or_default();
    uint64_t v9 = (void **)(a1 + 72);
    if (*(char *)(a1 + 95) < 0) {
      operator delete(*v9);
    }
    *(_OWORD *)uint64_t v9 = v29;
    *(void *)(a1 + 88) = v30;
    xpc_release(v27);
    v15[0] = &v28;
    v15[1] = "impus";
    sub_100048BAC((uint64_t)v15, &v29);
    sub_100033E28((uint64_t *)(a1 + 96), (xpc_object_t *)&v29);
    xpc_release((xpc_object_t)v29);
    v15[0] = &v28;
    v15[1] = "pcscfs";
    sub_100048BAC((uint64_t)v15, &v29);
    sub_100033E28((uint64_t *)(a1 + 120), (xpc_object_t *)&v29);
    xpc_release((xpc_object_t)v29);
    v15[0] = &v28;
    v15[1] = "services";
    sub_100048BAC((uint64_t)v15, &v29);
    unsigned int v11 = (sd *)xpc::dyn_cast_or_default((xpc *)&v29, 0, v10);
    xpc_release((xpc_object_t)v29);
    *(_DWORD *)(a1 + 144) = sd::imsServiceMaskFromUint(v11, v12);
    *(void *)&long long v29 = 0;
    *(void *)&long long v29 = xpc_null_create();
    v15[0] = &v28;
    v15[1] = "imsConfig";
    sub_100048BAC((uint64_t)v15, &v25);
    sub_10014EF04((void **)&v29, (xpc_object_t *)&v25);
    xpc_release(v25);
    xpc_object_t v24 = (xpc_object_t)v29;
    if ((void)v29) {
      xpc_retain((xpc_object_t)v29);
    }
    else {
      xpc_object_t v24 = xpc_null_create();
    }
    xpc::bridge((uint64_t *)&v27, (xpc *)&v24, v13);
    sub_10004EFE4(&v25, (CFTypeRef *)&v27);
    xpc_object_t v14 = (void **)(a1 + 152);
    if ((xpc_object_t **)(a1 + 152) != &v25)
    {
      v15[0] = *v14;
      unsigned __int8 *v14 = v25;
      xpc_object_t v25 = 0;
      sub_100057D78((const void **)v15);
    }
    sub_100057D78((const void **)&v25);
    sub_1000577C4((const void **)&v27);
    xpc_release(v24);
    xpc_release((xpc_object_t)v29);
  }
  else
  {
    xpc_object_t v23 = 0;
    *(_OWORD *)xpc_object_t v15 = 0u;
    memset(v16, 0, sizeof(v16));
    *(_OWORD *)xpc_object_t v17 = 0u;
    memset(__p, 0, sizeof(__p));
    long long v19 = 0u;
    long long v20 = 0u;
    long long v21 = 0u;
    int v22 = 0;
    if (*(char *)(a1 + 23) < 0) {
      operator delete(*(void **)a1);
    }
    *(void *)a1 = 0;
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
    HIBYTE(v16[0]) = 0;
    LOBYTE(v15[0]) = 0;
    xpc_object_t v4 = (void **)(a1 + 24);
    if (*(char *)(a1 + 47) < 0) {
      operator delete(*v4);
    }
    *(_OWORD *)xpc_object_t v4 = *(_OWORD *)&v16[1];
    *(void **)(a1 + 40) = v16[3];
    HIBYTE(v16[3]) = 0;
    LOBYTE(v16[1]) = 0;
    xpc_object_t v5 = (void **)(a1 + 48);
    if (*(char *)(a1 + 71) < 0) {
      operator delete(*v5);
    }
    *(_OWORD *)xpc_object_t v5 = *(_OWORD *)v17;
    *(void **)(a1 + 64) = __p[0];
    HIBYTE(__p[0]) = 0;
    LOBYTE(v17[0]) = 0;
    xpc_object_t v6 = (void **)(a1 + 72);
    if (*(char *)(a1 + 95) < 0) {
      operator delete(*v6);
    }
    *(_OWORD *)xpc_object_t v6 = *(_OWORD *)&__p[1];
    *(void **)(a1 + 88) = __p[3];
    HIBYTE(__p[3]) = 0;
    LOBYTE(__p[1]) = 0;
    sub_10005CBB4((uint64_t *)(a1 + 96));
    *(void *)(a1 + 96) = 0;
    *(void *)(a1 + 104) = 0;
    *(void *)(a1 + 112) = 0;
    *(void *)&long long v20 = 0;
    long long v19 = 0uLL;
    sub_10005CBB4((uint64_t *)(a1 + 120));
    *(void *)(a1 + 120) = 0;
    *(void *)(a1 + 128) = 0;
    *(void *)(a1 + 136) = 0;
    long long v21 = 0uLL;
    *((void *)&v20 + 1) = 0;
    *(_DWORD *)(a1 + 144) = 0;
    if (v15 != (void **)a1)
    {
      *(void *)&long long v29 = *(void *)(a1 + 152);
      *(void *)(a1 + 152) = 0;
      xpc_object_t v23 = 0;
      sub_100057D78((const void **)&v29);
    }
    sub_100057D78(&v23);
    *(void *)&long long v29 = (char *)&v20 + 8;
    sub_100047F64((void ***)&v29);
    *(void *)&long long v29 = &v19;
    sub_100047F64((void ***)&v29);
    if (SHIBYTE(__p[3]) < 0) {
      operator delete(__p[1]);
    }
    if (SHIBYTE(__p[0]) < 0) {
      operator delete(v17[0]);
    }
    if (SHIBYTE(v16[3]) < 0) {
      operator delete(v16[1]);
    }
    if (SHIBYTE(v16[0]) < 0) {
      operator delete(v15[0]);
    }
  }
  xpc_release(v28);
}

void sub_100595030(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  sub_1000577C4((const void **)(v14 - 104));
  xpc_release(*(xpc_object_t *)(v14 - 128));
  xpc_release(*(xpc_object_t *)(v14 - 88));
  xpc_release(*(xpc_object_t *)(v14 - 96));
  _Unwind_Resume(a1);
}

const char *sub_1005951B0(int a1)
{
  uint64_t v1 = "msg.mms.op.ntfrsp.?";
  if (a1 == 2) {
    uint64_t v1 = "msg.mms.op.ntfrsp.2";
  }
  if (a1 == 1) {
    return "msg.mms.op.ntfrsp.1";
  }
  else {
    return v1;
  }
}

void sub_1005951DC(uint64_t a1, int a2, void *a3, char *a4, char *a5, void *a6)
{
  uint64_t v9 = (std::__shared_weak_count *)a3[1];
  v15[0] = *a3;
  v15[1] = v9;
  if (v9) {
    atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  v14[0] = 0;
  v14[1] = 0;
  unsigned int v10 = (std::__shared_weak_count *)a6[1];
  v13[0] = *a6;
  v13[1] = v10;
  if (v10) {
    atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  unsigned int v11 = (capabilities::ct *)sub_1005724C8(a1, a2, v15, v14, v13);
  if (v10) {
    sub_10004D2C8(v10);
  }
  if (v9) {
    sub_10004D2C8(v9);
  }
  v16[0] = off_1019AF850;
  v16[1] = sub_1005951B0;
  v16[3] = v16;
  *(void *)(a1 + 208) = 0;
  if ((capabilities::ct::supportsGemini(v11) & 1) == 0) {
    operator new();
  }
  if (!*(void *)(a1 + 208)) {
    operator new();
  }
  sub_10008863C(v16);
  *(void *)a1 = off_1019E8E68;
  *(_OWORD *)(a1 + 216) = 0u;
  *(void *)(a1 + 8) = off_1019E8FD0;
  *(_OWORD *)(a1 + 232) = 0u;
  *(_OWORD *)(a1 + 248) = 0u;
  unsigned int v12 = *(std::__shared_weak_count **)(a1 + 184);
  *(void *)(a1 + 176) = 0;
  *(void *)(a1 + 184) = 0;
  if (v12) {
    sub_10004D2C8(v12);
  }
  sub_10003ED78((std::string *)(a1 + 216), a5);
  sub_10003ED78((std::string *)(a1 + 240), a4);
  void v16[4] = 0;
  v16[5] = 0;
  operator new();
}

void sub_10059557C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  sub_10008863C((uint64_t *)va);
  operator delete();
}

uint64_t sub_100595688(uint64_t a1)
{
  *(void *)a1 = off_1019E8E68;
  *(void *)(a1 + 8) = off_1019E8FD0;
  if (*(char *)(a1 + 263) < 0) {
    operator delete(*(void **)(a1 + 240));
  }
  if (*(char *)(a1 + 239) < 0) {
    operator delete(*(void **)(a1 + 216));
  }
  uint64_t v2 = *(void *)(a1 + 208);
  *(void *)(a1 + 208) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }

  return sub_100572700(a1);
}

uint64_t sub_10059574C(uint64_t a1)
{
  return sub_100595688(a1 - 8);
}

void sub_100595754(uint64_t a1)
{
  sub_100595688(a1);

  operator delete();
}

void sub_10059578C(uint64_t a1)
{
  sub_100595688(a1 - 8);

  operator delete();
}

BOOL sub_1005957C8(uint64_t a1)
{
  if (!*(void *)(a1 + 144)) {
    return 0;
  }
  if (*(char *)(a1 + 239) < 0) {
    uint64_t v1 = *(void *)(a1 + 224);
  }
  else {
    uint64_t v1 = *(unsigned __int8 *)(a1 + 239);
  }
  return v1 != 0;
}

void sub_1005957F8(uint64_t a1)
{
  uint64_t v2 = (os_log_t *)(*(uint64_t (**)(void, void))(**(void **)(a1 + 208) + 16))(*(void *)(a1 + 208), *(unsigned int *)(a1 + 48));
  uint64_t v47 = 0;
  long long v48 = 0;
  sub_1005725BC(a1, *(unsigned int *)(a1 + 48), &v47);
  if (!v47
    || !*(void *)(a1 + 160)
    || ((uint64_t v3 = (*(uint64_t (**)(void))(*(void *)v47 + 40))(),
         int v4 = *(char *)(v3 + 23),
         xpc_object_t v5 = *(const char **)v3,
         uint64_t v6 = (*(uint64_t (**)(void))(**(void **)(a1 + 160) + 40))(*(void *)(a1 + 160)),
         v4 >= 0)
      ? (int v7 = (const char *)v3)
      : (int v7 = v5),
        *(char *)(v6 + 23) >= 0 ? (uint64_t v8 = (const char *)v6) : (uint64_t v8 = *(const char **)v6),
        strcasecmp(v7, v8)))
  {
    if ((*(unsigned int (**)(void))(**(void **)(a1 + 160) + 264))(*(void *)(a1 + 160)))
    {
      uint64_t v9 = *v2;
      if (os_log_type_enabled(*v2, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v10 = (*(uint64_t (**)(void))(**(void **)(a1 + 160) + 40))(*(void *)(a1 + 160));
        int v11 = *(_DWORD *)(a1 + 36);
        uint64_t v12 = *(void *)v10;
        if (*(char *)(v10 + 23) >= 0) {
          uint64_t v12 = v10;
        }
        *(_DWORD *)buf = 136315394;
        uint64_t v50 = v12;
        __int16 v51 = 1024;
        int v52 = v11;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I Sending m-notifyresp-ind to MMSC that hosted the message (%s), MsgId: %u", buf, 0x12u);
      }
      xpc_object_t v13 = *(std::__shared_weak_count **)(a1 + 168);
      uint64_t v45 = *(void *)(a1 + 160);
      long long v46 = v13;
      if (v13) {
        atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      sub_100572C3C(a1, &v45);
      if (v46) {
        sub_10004D2C8(v46);
      }
    }
  }
  if (*(void *)(a1 + 176)) {
    goto LABEL_29;
  }
  uint64_t v14 = *v2;
  if (os_log_type_enabled(*v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v15 = (*(uint64_t (**)(uint64_t))(*(void *)v47 + 40))(v47);
    int v16 = *(_DWORD *)(a1 + 36);
    uint64_t v17 = *(void *)v15;
    if (*(char *)(v15 + 23) >= 0) {
      uint64_t v17 = v15;
    }
    *(_DWORD *)buf = 136315394;
    uint64_t v50 = v17;
    __int16 v51 = 1024;
    int v52 = v16;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I Sending m-notifyresp-ind to our carrier configured MMSC (%s), MsgId: %u", buf, 0x12u);
  }
  uint64_t v43 = v47;
  long long v44 = v48;
  if (v48) {
    atomic_fetch_add_explicit(&v48->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  sub_100572C3C(a1, &v43);
  if (v44) {
    sub_10004D2C8(v44);
  }
  if (*(void *)(a1 + 176))
  {
LABEL_29:
    uint64_t v19 = *(void *)(a1 + 144);
    xpc_object_t v18 = *(std::__shared_weak_count **)(a1 + 152);
    if (v18) {
      atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    if (v19)
    {
      sub_100572E28(a1);
      uint64_t v20 = *(void *)(a1 + 176);
      uint64_t v37 = v19;
      uint64_t v38 = v18;
      if (v18) {
        atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      long long v21 = (void *)(a1 + 216);
      if (*(char *)(a1 + 239) < 0) {
        long long v21 = (void *)*v21;
      }
      char v22 = (*(uint64_t (**)(uint64_t, uint64_t *, void *))(*(void *)v20 + 24))(v20, &v37, v21);
      if (v38) {
        sub_10004D2C8(v38);
      }
      if (v22) {
        goto LABEL_51;
      }
      xpc_object_t v23 = *(std::__shared_weak_count **)(a1 + 184);
      *(void *)(a1 + 176) = 0;
      *(void *)(a1 + 184) = 0;
      if (v23) {
        sub_10004D2C8(v23);
      }
      xpc_object_t v24 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 208) + 16))(*(void *)(a1 + 208), *(unsigned int *)(a1 + 48));
      if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
      {
        int v33 = *(_DWORD *)(a1 + 36);
        *(_DWORD *)buf = 67109120;
        LODWORD(v50) = v33;
        _os_log_error_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "MMSNotifyResponseOperation send message failed, MsgId: %u", buf, 8u);
      }
      uint64_t v25 = *(void *)(a1 + 128);
      sub_10003E168(&v35, (void *)(a1 + 16));
      (*(void (**)(uint64_t, uint64_t, uint64_t *))(*(void *)v25 + 16))(v25, 1, &v35);
      uint64_t v26 = v36;
      if (!v36) {
        goto LABEL_51;
      }
    }
    else
    {
      xpc_object_t v27 = *(std::__shared_weak_count **)(a1 + 184);
      *(void *)(a1 + 176) = 0;
      *(void *)(a1 + 184) = 0;
      if (v27) {
        sub_10004D2C8(v27);
      }
      xpc_object_t v28 = *v2;
      if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
      {
        int v32 = *(_DWORD *)(a1 + 36);
        *(_DWORD *)buf = 67109120;
        LODWORD(v50) = v32;
        _os_log_error_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_ERROR, "MMSNotifyResponseOperation, message is null, MsgId: %u", buf, 8u);
      }
      uint64_t v29 = *(void *)(a1 + 128);
      sub_10003E168(&v39, (void *)(a1 + 16));
      (*(void (**)(uint64_t, uint64_t, uint64_t *))(*(void *)v29 + 16))(v29, 1, &v39);
      uint64_t v26 = v40;
      if (!v40)
      {
LABEL_51:
        if (!v18) {
          goto LABEL_53;
        }
        goto LABEL_52;
      }
    }
    sub_10004D2C8(v26);
    goto LABEL_51;
  }
  uint64_t v30 = *v2;
  if (os_log_type_enabled(*v2, OS_LOG_TYPE_ERROR))
  {
    int v34 = *(_DWORD *)(a1 + 36);
    *(_DWORD *)buf = 67109120;
    LODWORD(v50) = v34;
    _os_log_error_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_ERROR, "Failed to create server connection, MsgId: %u", buf, 8u);
  }
  uint64_t v31 = *(void *)(a1 + 128);
  sub_10003E168(&v41, (void *)(a1 + 16));
  (*(void (**)(uint64_t, uint64_t, uint64_t *))(*(void *)v31 + 16))(v31, 1, &v41);
  xpc_object_t v18 = v42;
  if (v42) {
LABEL_52:
  }
    sub_10004D2C8(v18);
LABEL_53:
  if (v48) {
    sub_10004D2C8(v48);
  }
}

void sub_100595DAC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,std::__shared_weak_count *a22)
{
  if (a16) {
    sub_10004D2C8(a16);
  }
  if (a22) {
    sub_10004D2C8(a22);
  }
  _Unwind_Resume(exception_object);
}

void sub_100595E50(uint64_t a1, _DWORD **a2)
{
  int v4 = (NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 208) + 16))(*(void *)(a1 + 208), *(unsigned int *)(a1 + 48));
  unsigned int v5 = **a2 - 200;
  uint64_t v6 = *v4;
  int v7 = *v4;
  if (v5 > 0x63)
  {
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      uint64_t v14 = (void *)(a1 + 216);
      if (*(char *)(a1 + 239) < 0) {
        uint64_t v14 = (void *)*v14;
      }
      uint64_t v15 = (void *)(a1 + 240);
      if (*(char *)(a1 + 263) < 0) {
        uint64_t v15 = (void *)*v15;
      }
      int v16 = *(_DWORD *)(a1 + 36);
      *(_DWORD *)buf = 136315650;
      uint64_t v20 = v14;
      __int16 v21 = 2080;
      char v22 = v15;
      __int16 v23 = 1024;
      int v24 = v16;
      _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "notifyresp %s %s failed, MsgId: %u", buf, 0x1Cu);
    }
    uint64_t v8 = 1;
  }
  else
  {
    uint64_t v8 = 0;
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v9 = (void *)(a1 + 216);
      if (*(char *)(a1 + 239) < 0) {
        uint64_t v9 = (void *)*v9;
      }
      uint64_t v10 = (void *)(a1 + 240);
      if (*(char *)(a1 + 263) < 0) {
        uint64_t v10 = (void *)*v10;
      }
      int v11 = *(_DWORD *)(a1 + 36);
      *(_DWORD *)buf = 136315650;
      uint64_t v20 = v9;
      __int16 v21 = 2080;
      char v22 = v10;
      __int16 v23 = 1024;
      int v24 = v11;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I notifyresp %s %s succeeded, MsgId: %u", buf, 0x1Cu);
      uint64_t v8 = 0;
    }
  }
  uint64_t v12 = *(std::__shared_weak_count **)(a1 + 184);
  *(void *)(a1 + 176) = 0;
  *(void *)(a1 + 184) = 0;
  if (v12) {
    sub_10004D2C8(v12);
  }
  uint64_t v13 = *(void *)(a1 + 128);
  sub_10003E168(&v17, (void *)(a1 + 16));
  (*(void (**)(uint64_t, uint64_t, uint64_t *))(*(void *)v13 + 16))(v13, v8, &v17);
  if (v18) {
    sub_10004D2C8(v18);
  }
}

void sub_100596060(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

const char *sub_100596080()
{
  return "MMSNotifyResp";
}

uint64_t sub_10059608C()
{
  return 1;
}

void sub_100596098()
{
}

uint64_t sub_1005960AC(uint64_t a1)
{
  return *(void *)(*(void *)(a1 + 8) + 192);
}

void sub_1005960B8(void *a1)
{
  *a1 = &off_1019E9090;
  a1[1] = 0;
  a1[2] = 0;
  a1[3] = 0;
  operator new();
}

void sub_100596144()
{
}

uint64_t sub_100596184(uint64_t a1)
{
  *(void *)a1 = &off_1019E9090;
  uint64_t v2 = *(NSObject **)(a1 + 40);
  if (v2)
  {
    nw_path_monitor_cancel(v2);
    *(void *)(a1 + 40) = 0;
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 56);
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  sub_100119D1C((ctu::OsLogLogger **)(a1 + 32), 0);
  if (*(char *)(a1 + 31) < 0) {
    operator delete(*(void **)(a1 + 8));
  }
  return a1;
}

void sub_100596204(uint64_t a1)
{
  sub_100596184(a1);

  operator delete();
}

void sub_10059623C(uint64_t a1, const std::string *a2)
{
  uint64_t v2 = a2;
  int v4 = (std::string *)(a1 + 8);
  char v5 = *(unsigned char *)(a1 + 31);
  if (v5 >= 0) {
    uint64_t v6 = *(unsigned __int8 *)(a1 + 31);
  }
  else {
    uint64_t v6 = *(void *)(a1 + 16);
  }
  std::string::size_type size = HIBYTE(a2->__r_.__value_.__r.__words[2]);
  int v8 = (char)size;
  if ((size & 0x80u) != 0) {
    std::string::size_type size = a2->__r_.__value_.__l.__size_;
  }
  if (v6 == size)
  {
    if (v8 < 0) {
      a2 = (const std::string *)a2->__r_.__value_.__r.__words[0];
    }
    if ((*(unsigned char *)(a1 + 31) & 0x80) != 0)
    {
      uint64_t v12 = (std::string *)v4->__r_.__value_.__r.__words[0];
      if (!memcmp(v4->__r_.__value_.__l.__data_, a2, *(void *)(a1 + 16))) {
        return;
      }
      int v11 = **(NSObject ***)(a1 + 32);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_22;
      }
      goto LABEL_25;
    }
    if (!*(unsigned char *)(a1 + 31)) {
      return;
    }
    uint64_t v9 = (unsigned __int8 *)(a1 + 8);
    uint64_t v10 = *(unsigned __int8 *)(a1 + 31);
    while (*v9 == a2->__r_.__value_.__s.__data_[0])
    {
      ++v9;
      a2 = (const std::string *)((char *)a2 + 1);
      if (!--v10) {
        return;
      }
    }
  }
  int v11 = **(NSObject ***)(a1 + 32);
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    if (v5 < 0) {
      uint64_t v12 = (std::string *)v4->__r_.__value_.__r.__words[0];
    }
    else {
      uint64_t v12 = v4;
    }
LABEL_22:
    uint64_t v13 = (const std::string *)v2->__r_.__value_.__r.__words[0];
    if (v8 >= 0) {
      uint64_t v13 = v2;
    }
    int v18 = 136315394;
    uint64_t v19 = v12;
    __int16 v20 = 2080;
    __int16 v21 = v13;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I handleIPAddressUpdated old (%s), new (%s)", (uint8_t *)&v18, 0x16u);
  }
LABEL_25:
  std::string::operator=(v4, v2);
  uint64_t v14 = *(std::__shared_weak_count **)(a1 + 56);
  if (v14)
  {
    uint64_t v15 = std::__shared_weak_count::lock(v14);
    if (v15)
    {
      int v16 = v15;
      uint64_t v17 = *(void *)(a1 + 48);
      if (v17) {
        (*(void (**)(uint64_t))(*(void *)v17 + 16))(v17);
      }
      sub_10004D2C8(v16);
    }
  }
}

void sub_10059640C(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_100596428(uint64_t a1, dispatch_queue_t *a2, uint64_t *a3)
{
  uint64_t v6 = **(NSObject ***)(a1 + 32);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(__p.__r_.__value_.__l.__data_) = 0;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I WifiIPAddressUpdateMonitor setup", (uint8_t *)&__p, 2u);
  }
  uint64_t v8 = *a3;
  uint64_t v7 = a3[1];
  if (v7) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v7 + 16), 1uLL, memory_order_relaxed);
  }
  uint64_t v9 = *(std::__shared_weak_count **)(a1 + 56);
  *(void *)(a1 + 48) = v8;
  *(void *)(a1 + 56) = v7;
  if (v9) {
    std::__shared_weak_count::__release_weak(v9);
  }
  uint64_t v10 = *(NSObject **)(a1 + 40);
  if (!v10)
  {
    uint64_t v10 = nw_path_monitor_create_with_type(nw_interface_type_wifi);
    *(void *)(a1 + 40) = v10;
  }
  nw_path_monitor_set_queue(v10, *a2);
  int v11 = *(NSObject **)(a1 + 40);
  update_handler[0] = _NSConcreteStackBlock;
  update_handler[1] = 0x40000000;
  update_handler[2] = sub_100596584;
  update_handler[3] = &unk_1019E90B0;
  update_handler[4] = a1;
  nw_path_monitor_set_update_handler(v11, update_handler);
  nw_path_monitor_start(*(nw_path_monitor_t *)(a1 + 40));
  memset(&__p, 0, sizeof(__p));
  sub_100596624(&__p);
  sub_10059623C(a1, &__p);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
}

void sub_100596568(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100596584(uint64_t a1, nw_path_t path)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (nw_path_has_ipv6(path))
  {
    memset(&__p, 0, sizeof(__p));
    sub_100596624(&__p);
  }
  else
  {
    sub_100058DB0(&__p, "");
  }
  sub_10059623C(v2, &__p);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
}

void sub_100596604(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100596624(std::string *a1)
{
  a1->__r_.__value_.__r.__words[0] = 0;
  a1->__r_.__value_.__l.__size_ = 0;
  a1->__r_.__value_.__r.__words[2] = 0;
  sub_100058DB0(a1, "");
  uint64_t v14 = 0;
  *(_OWORD *)__s = 0u;
  memset(v16, 0, sizeof(v16));
  int v2 = getifaddrs(&v14);
  uint64_t v3 = v14;
  if (!v2 && v14)
  {
    do
    {
      ifa_addr = v3->ifa_addr;
      if (ifa_addr->sa_family == 30 && !strcmp(v3->ifa_name, "en0"))
      {
        inet_ntop(30, &ifa_addr->sa_data[6], __s, 0x2Eu);
        memset(&__p, 0, sizeof(__p));
        sub_100058DB0(&__p, __s);
        int64_t size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
        char v6 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        {
          p_p = &__p;
        }
        else
        {
          int64_t size = __p.__r_.__value_.__l.__size_;
          p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
        }
        if (size >= 6)
        {
          uint64_t v8 = (std::string *)((char *)p_p + size);
          uint64_t v9 = p_p;
          do
          {
            uint64_t v10 = (std::string *)memchr(v9, 102, size - 5);
            if (!v10) {
              break;
            }
            if (LODWORD(v10->__r_.__value_.__l.__data_) == 809002342
              && WORD2(v10->__r_.__value_.__r.__words[0]) == 14906)
            {
              if (v10 == v8 || v10 != p_p) {
                break;
              }
              char v12 = 1;
              if ((v6 & 0x80) == 0) {
                goto LABEL_23;
              }
              goto LABEL_22;
            }
            uint64_t v9 = (std::string *)((char *)&v10->__r_.__value_.__l.__data_ + 1);
            int64_t size = (char *)v8 - (char *)v9;
          }
          while ((char *)v8 - (char *)v9 >= 6);
        }
        std::string::operator=(a1, &__p);
        char v12 = 0;
        if ((*((unsigned char *)&__p.__r_.__value_.__s + 23) & 0x80) != 0) {
LABEL_22:
        }
          operator delete(__p.__r_.__value_.__l.__data_);
LABEL_23:
        if ((v12 & 1) == 0) {
          break;
        }
      }
      uint64_t v3 = v3->ifa_next;
    }
    while (v3);
    uint64_t v3 = v14;
  }
  freeifaddrs(v3);
}

void sub_1005967E4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (*(char *)(v14 + 23) < 0) {
    operator delete(*(void **)v14);
  }
  _Unwind_Resume(exception_object);
}

char *sub_100596820@<X0>(char *result@<X0>, uint64_t a2@<X8>)
{
  if (result[31] < 0) {
    return (char *)sub_10004FC84((unsigned char *)a2, *((void **)result + 1), *((void *)result + 2));
  }
  *(_OWORD *)a2 = *(_OWORD *)(result + 8);
  *(void *)(a2 + 16) = *((void *)result + 3);
  return result;
}

void sub_100596858(void *a1@<X8>)
{
  *a1 = 0;
}

void sub_100596864()
{
}

void *sub_100596878(void *a1)
{
  int v2 = (ctu::OsLogLogger *)(a1 + 1);
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v4, kCtLoggingSystemName, "stk.alert.mgr");
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v5, &v4);
  ctu::OsLogLogger::OsLogLogger(v2, (const ctu::OsLogLogger *)v5);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v5);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v4);
  *a1 = off_101A74058;
  return a1;
}

void sub_100596924(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v4 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)va1);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)va);
  STKAlertSessionManagerInterface::~STKAlertSessionManagerInterface(v2);
  _Unwind_Resume(a1);
}

void sub_100596958()
{
}

void sub_1005969B0()
{
}

void sub_1005969D4(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_100596A3C(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100596A78(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100596AB0(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_100596AE0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

void sub_100596DE4(_Unwind_Exception *a1)
{
  if ((v5 & 1) == 0) {
    sub_10004D2C8(v3);
  }

  _Unwind_Resume(a1);
}

void sub_100597114(_Unwind_Exception *a1)
{
  if ((v5 & 1) == 0) {
    sub_10004D2C8(v3);
  }

  _Unwind_Resume(a1);
}

void sub_10059748C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if ((v19 & 1) == 0) {
    sub_10004D2C8(v17);
  }

  _Unwind_Resume(a1);
}

void sub_1005977C4(_Unwind_Exception *a1)
{
  if ((v5 & 1) == 0) {
    sub_10004D2C8(v3);
  }

  _Unwind_Resume(a1);
}

void sub_100597AE0(_Unwind_Exception *a1)
{
  if ((v5 & 1) == 0) {
    sub_10004D2C8(v3);
  }

  _Unwind_Resume(a1);
}

void sub_100597DF8(_Unwind_Exception *a1)
{
  if ((v5 & 1) == 0) {
    sub_10004D2C8(v3);
  }

  _Unwind_Resume(a1);
}

void sub_100598110(_Unwind_Exception *a1)
{
  if ((v5 & 1) == 0) {
    sub_10004D2C8(v3);
  }

  _Unwind_Resume(a1);
}

void sub_100598440(_Unwind_Exception *a1)
{
  if ((v5 & 1) == 0) {
    sub_10004D2C8(v3);
  }

  _Unwind_Resume(a1);
}

void sub_1005988EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10)
{
  if ((a10 & 1) == 0) {
    sub_10004D2C8(v14);
  }

  _Unwind_Resume(a1);
}

void sub_1005989C8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  if (!a12) {
    JUMPOUT(0x1005989B4);
  }
  JUMPOUT(0x1005989B0);
}

void sub_100598CF4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if ((v19 & 1) == 0) {
    sub_10004D2C8(v17);
  }

  _Unwind_Resume(a1);
}

void sub_100599034(_Unwind_Exception *a1)
{
  if ((v5 & 1) == 0) {
    sub_10004D2C8(v3);
  }

  _Unwind_Resume(a1);
}

void sub_1005993A4(_Unwind_Exception *a1)
{
  if ((v5 & 1) == 0) {
    sub_10004D2C8(v3);
  }

  _Unwind_Resume(a1);
}

uint64_t sub_10059942C(uint64_t a1)
{
  return a1;
}

void sub_100599458(uint64_t a1)
{
  operator delete();
}

void *sub_1005994A4(uint64_t a1)
{
  int v2 = operator new(0x10uLL);
  void *v2 = off_1019E91C0;
  v2[1] = objc_retainBlock(*(id *)(a1 + 8));
  return v2;
}

id sub_1005994FC(uint64_t a1, void *a2)
{
  *a2 = off_1019E91C0;
  id result = objc_retainBlock(*(id *)(a1 + 8));
  a2[1] = result;
  return result;
}

void sub_100599544(uint64_t a1)
{
}

void sub_10059954C(id *a1)
{
  operator delete(a1);
}

void sub_100599588(uint64_t a1, unsigned __int16 *a2)
{
  unsigned int v2 = *a2;
  uint64_t v3 = *(void *)(a1 + 8);
  if (v2 >= 0x100)
  {
    uint64_t v4 = *(void (**)(uint64_t, BOOL, void))(v3 + 16);
    uint64_t v5 = *(void *)(a1 + 8);
    v4(v5, v2 != 0, 0);
  }
  else
  {
    id v6 = [objc_alloc((Class)NSError) initWithDomain:NSPOSIXErrorDomain code:35 userInfo:0];
    (*(void (**)(uint64_t, void))(v3 + 16))(v3, 0);
  }
}

void sub_10059964C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, id a9)
{
  _Unwind_Resume(a1);
}

uint64_t sub_100599660(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_1019E9220)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_1005996A0()
{
  return &off_1019E9220;
}

void sub_1005996AC()
{
}

void *sub_100599720(void *a1)
{
  *a1 = off_1019E9240;
  unsigned int v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

void sub_10059976C(void *a1)
{
  *a1 = off_1019E9240;
  uint64_t v1 = (std::__shared_weak_count *)a1[2];
  if (v1) {
    sub_10004D2C8(v1);
  }

  operator delete();
}

void sub_1005997D8(uint64_t a1@<X0>, long long *a2@<X1>, void *a3@<X8>)
{
  uint64_t v6 = *(void *)(a1 + 8);
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 16);
  uint64_t v7 = operator new(0x60uLL);
  uint64_t v8 = v7;
  v7[1] = 0;
  void v7[2] = 0;
  *uint64_t v7 = off_1019E9288;
  uint64_t v9 = v7 + 3;
  v10[0] = v6;
  v10[1] = (uint64_t)v5;
  if (v5) {
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  sub_100CC5580(v7 + 3, v10, a2);
  if (v5) {
    sub_10004D2C8(v5);
  }
  *a3 = v9;
  a3[1] = v8;
}

void sub_10059987C(_Unwind_Exception *a1)
{
  if (v2) {
    sub_10004D2C8(v2);
  }
  std::__shared_weak_count::~__shared_weak_count(v1);
  operator delete(v4);
  _Unwind_Resume(a1);
}

void sub_1005998A0(uint64_t a1@<X0>, NSObject **a2@<X1>, long long *a3@<X2>, uint64_t *a4@<X8>)
{
  uint64_t v8 = *(void *)(a1 + 8);
  uint64_t v7 = *(std::__shared_weak_count **)(a1 + 16);
  uint64_t v9 = (std::__shared_weak_count *)operator new(0xB0uLL);
  v9->__shared_owners_ = 0;
  v9->__shared_weak_owners_ = 0;
  v9->__vftable = (std::__shared_weak_count_vtbl *)off_1019E92D8;
  uint64_t v10 = (uint64_t)&v9[1];
  v14[0] = v8;
  v14[1] = v7;
  if (v7) {
    atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  int v11 = *a2;
  dispatch_object_t object = v11;
  if (v11) {
    dispatch_retain(v11);
  }
  sub_100169768(v10, v14, &object, a3);
  if (object) {
    dispatch_release(object);
  }
  if (v7) {
    sub_10004D2C8(v7);
  }
  shared_weak_owners = (std::__shared_weak_count *)v9[1].__shared_weak_owners_;
  if (!shared_weak_owners)
  {
    atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit(&v9->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    v9[1].__shared_owners_ = v10;
    v9[1].__shared_weak_owners_ = (uint64_t)v9;
    goto LABEL_13;
  }
  if (shared_weak_owners->__shared_owners_ == -1)
  {
    atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit(&v9->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    v9[1].__shared_owners_ = v10;
    v9[1].__shared_weak_owners_ = (uint64_t)v9;
    std::__shared_weak_count::__release_weak(shared_weak_owners);
LABEL_13:
    sub_10004D2C8(v9);
  }
  *a4 = v10;
  a4[1] = (uint64_t)v9;
}

void sub_1005999C4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object)
{
  if (object) {
    dispatch_release(object);
  }
  if (v11) {
    sub_10004D2C8(v11);
  }
  std::__shared_weak_count::~__shared_weak_count(v10);
  operator delete(v13);
  _Unwind_Resume(a1);
}

void sub_1005999F4(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1019E9288;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100599A14(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1019E9288;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100599A68(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 24) + 56))();
}

void sub_100599A90(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1019E92D8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100599AB0(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1019E92D8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_100599B04(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 24) + 24))();
}

uint64_t sub_100599B2C(uint64_t a1, void *a2, _OWORD *a3)
{
  *(void *)a1 = off_101AB2248;
  uint64_t v5 = (void *)(a1 + 8);
  uint64_t v6 = (std::__shared_weak_count *)a2[1];
  v8[0] = *a2;
  v8[1] = v6;
  if (v6) {
    atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  sub_10132B1BC(v5, v8);
  if (v6) {
    sub_10004D2C8(v6);
  }
  *(void *)a1 = off_1019E9328;
  *(_OWORD *)(a1 + 32) = *a3;
  return a1;
}

void sub_100599BD0(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_100599BE8(uint64_t a1, os_log_t *a2)
{
  __p[0] = 0;
  __p[1] = 0;
  uint64_t v7 = 0;
  uint64_t v2 = *(void *)(a1 + 40);
  if (v2)
  {
    BOOL v3 = sub_10132B248(a1 + 8, v2, (uint64_t)__p);
    if (SHIBYTE(v7) < 0) {
      operator delete(__p[0]);
    }
  }
  else
  {
    uint64_t v4 = *a2;
    BOOL v3 = 0;
    if (os_log_type_enabled(*a2, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315138;
      uint64_t v9 = "Unauthorized.xml";
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Infinite validity of %s xml", buf, 0xCu);
      return 0;
    }
  }
  return v3;
}

void sub_100599CCC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100599CE8(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

void sub_100599D18(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1) {
    sub_10004D2C8(v1);
  }

  operator delete();
}

uint64_t sub_100599D68(uint64_t a1, uint64_t a2, NSObject **a3)
{
  uint64_t v6 = (void *)(a1 + 8);
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v17, kCtLoggingSystemName, "cu.data.billingcycle");
  void *v6 = 0;
  v6[1] = 0;
  uint64_t v7 = *a3;
  *(void *)(a1 + 24) = *a3;
  if (v7) {
    dispatch_retain(v7);
  }
  *(void *)(a1 + 32) = 0;
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v18, &v17);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 40), (const ctu::OsLogLogger *)v18);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v18);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v17);
  *(void *)a1 = off_1019E9388;
  *(_DWORD *)(a1 + 48) = -1;
  *(void *)(a1 + 144) = 0;
  *(void *)(a1 + 152) = 0;
  *(void *)(a1 + 136) = 0;
  *(void *)(a1 + 168) = 0;
  *(void *)(a1 + 160) = a1 + 168;
  *(void *)(a1 + 176) = 0;
  *(void *)(a1 + 184) = 0;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_DWORD *)(a1 + 128) = 0;
  sub_100058DB0(&__p, "DataUsageBillingCycleEvaluator");
  uint64_t v8 = *(NSObject **)(a1 + 24);
  uint64_t v14 = v8;
  if (v8) {
    dispatch_retain(v8);
  }
  uint64_t v9 = *(NSObject **)(a1 + 32);
  dispatch_object_t object = v9;
  if (v9) {
    dispatch_retain(v9);
  }
  ctu::RestModule::RestModule();
  if (object) {
    dispatch_release(object);
  }
  if (v14) {
    dispatch_release(v14);
  }
  if (v16 < 0) {
    operator delete(__p);
  }
  uint64_t v10 = *(Registry **)a2;
  *(void *)(a1 + 208) = *(void *)a2;
  uint64_t v11 = *(void *)(a2 + 8);
  *(void *)(a1 + 216) = v11;
  if (v11)
  {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v11 + 8), 1uLL, memory_order_relaxed);
    uint64_t v10 = *(Registry **)(a1 + 208);
  }
  Registry::getNotificationSenderFactory((uint64_t *)&v17, v10);
  (*(void (**)(char *))(*(void *)v17.var0 + 32))(v17.var0);
  if (v17.var1.fRef) {
    sub_10004D2C8((std::__shared_weak_count *)v17.var1.fRef);
  }
  return a1;
}

void sub_100599F58(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, dispatch_object_t object, dispatch_object_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17, std::__shared_weak_count *a18, char a19)
{
  if (a18) {
    sub_10004D2C8(a18);
  }
  uint64_t v25 = (std::__shared_weak_count *)*((void *)v19 + 27);
  if (v25) {
    sub_10004D2C8(v25);
  }
  uint64_t v26 = (std::__shared_weak_count *)*((void *)v19 + 25);
  if (v26) {
    sub_10004D2C8(v26);
  }
  uint64_t v27 = *((void *)v19 + 23);
  *((void *)v19 + 23) = 0;
  if (v27) {
    (*(void (**)(uint64_t))(*(void *)v27 + 8))(v27);
  }
  sub_100087F94(v22, *v23);
  sub_10059C254((void *)v19 + 7);
  ctu::OsLogLogger::~OsLogLogger(v21);
  sub_100087E88(v20);
  DataUsageBillingCycleEvaluatorInterface::~DataUsageBillingCycleEvaluatorInterface(v19);
  _Unwind_Resume(a1);
}

void sub_10059A058()
{
}

void sub_10059A120(_Unwind_Exception *exception_object)
{
  if (v1) {
    dispatch_release(v1);
  }
  if (v2) {
    operator delete();
  }
  _Unwind_Resume(exception_object);
}

void sub_10059A154(uint64_t a1)
{
  Registry::createRestModuleOneTimeUseConnection(&v8, *(Registry **)(a1 + 208));
  ctu::RestModule::connect();
  if (v9) {
    sub_10004D2C8(v9);
  }
  int v2 = (void *)(a1 + 56);
  v10[0] = off_1019E9510;
  v10[1] = a1 + 192;
  uint64_t v11 = v10;
  if (v10 != (void *)(a1 + 56))
  {
    BOOL v3 = *(void **)(a1 + 80);
    if (v3 == v2)
    {
      __p[1] = (void *)(a1 + 192);
      uint64_t v13 = 0;
      uint64_t v11 = 0;
      __p[0] = off_1019E9510;
      (*(void (**)(uint64_t, void *))(*v2 + 24))(a1 + 56, v10);
      (*(void (**)(void))(**(void **)(a1 + 80) + 32))(*(void *)(a1 + 80));
      *(void *)(a1 + 80) = 0;
      uint64_t v11 = v10;
      (*((void (**)(void **, uint64_t))__p[0] + 3))(__p, a1 + 56);
      (*((void (**)(void **))__p[0] + 4))(__p);
    }
    else
    {
      *(void *)(a1 + 56) = off_1019E9510;
      *(void *)(a1 + 64) = a1 + 192;
      uint64_t v11 = v3;
    }
    *(void *)(a1 + 80) = v2;
  }
  sub_10059C254(v10);
  uint64_t v4 = *(void *)(a1 + 80);
  if (v4) {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v4 + 48))(v4, a1 + 88);
  }
  sub_100058DB0(__p, "/cc/props/current_data_slot");
  uint64_t v5 = operator new(0x28uLL);
  void *v5 = off_1019E95A0;
  v5[1] = a1 + 128;
  v5[2] = a1;
  v5[3] = sub_10059A534;
  void v5[4] = 0;
  uint64_t v11 = v5;
  ctu::RestModule::observeProperty();
  sub_10003F600(v10);
  if (SHIBYTE(v13) < 0) {
    operator delete(__p[0]);
  }
  sub_100058DB0(__p, "/cc/props/carrier_space_info");
  uint64_t v6 = operator new(0x28uLL);
  void *v6 = off_1019E9620;
  v6[1] = a1 + 136;
  v6[2] = a1;
  v6[3] = sub_10059A57C;
  void v6[4] = 0;
  uint64_t v11 = v6;
  ctu::RestModule::observeProperty();
  sub_10003F600(v10);
  if (SHIBYTE(v13) < 0) {
    operator delete(__p[0]);
  }
  sub_100058DB0(__p, "/cc/props/carrier_bundles");
  uint64_t v7 = operator new(0x28uLL);
  *uint64_t v7 = off_1019E96A0;
  v7[1] = a1 + 160;
  void v7[2] = a1;
  double v7[3] = sub_10059A6F4;
  _OWORD v7[4] = 0;
  uint64_t v11 = v7;
  ctu::RestModule::observeProperty();
  sub_10003F600(v10);
  if (SHIBYTE(v13) < 0) {
    operator delete(__p[0]);
  }
}

void sub_10059A4CC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10059A534(uint64_t result, int a2)
{
  if (*(_DWORD *)(result + 128) != a2)
  {
    long long v2 = *(_OWORD *)(result + 104);
    v3[0] = *(_OWORD *)(result + 88);
    v3[1] = v2;
    uint64_t v4 = *(void *)(result + 120);
    return sub_10059A978(result, (uint64_t)v3, 1u);
  }
  return result;
}

void sub_10059A57C(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 136) == 2 && !*(unsigned char *)(a1 + 140))
  {
    uint64_t v6 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v9 = 0;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Carrier space information not available yet, skipping updating billing cycle", v9, 2u);
    }
  }
  else
  {
    long long v2 = *(_OWORD *)(a1 + 104);
    *(_OWORD *)uint64_t v9 = *(_OWORD *)(a1 + 88);
    long long v10 = v2;
    uint64_t v11 = *(void *)(a1 + 120);
    sub_10059A978(a1, (uint64_t)v9, 4u);
    BOOL v3 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Carrier space information updated", buf, 2u);
    }
    xpc_object_t v4 = xpc_null_create();
    *(void *)buf = v4;
    xpc_object_t v5 = xpc_null_create();
    xpc_object_t v7 = v5;
    sub_1000452AC(137, (xpc_object_t *)buf, &v7);
    xpc_release(v5);
    xpc_release(v4);
    (*(void (**)(void))(**(void **)(a1 + 224) + 16))(*(void *)(a1 + 224));
  }
}

void sub_10059A6C8(_Unwind_Exception *a1)
{
  xpc_release(v2);
  xpc_release(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_10059A6F4(uint64_t result, uint64_t a2)
{
  long long v2 = *(void **)(result + 160);
  BOOL v3 = (void *)(result + 168);
  if (v2 != (void *)(result + 168))
  {
    uint64_t v4 = result;
    xpc_object_t v5 = (void *)(a2 + 8);
    uint64_t v6 = result + 88;
    while (1)
    {
      uint64_t v7 = *v5;
      if (!*v5) {
        break;
      }
      int v8 = *((_DWORD *)v2 + 8);
      uint64_t v9 = v5;
      do
      {
        int v10 = *(_DWORD *)(v7 + 32);
        BOOL v11 = v10 < v8;
        if (v10 >= v8) {
          char v12 = (uint64_t *)v7;
        }
        else {
          char v12 = (uint64_t *)(v7 + 8);
        }
        if (!v11) {
          uint64_t v9 = (void *)v7;
        }
        uint64_t v7 = *v12;
      }
      while (*v12);
      if (v9 == v5 || v8 < *((_DWORD *)v9 + 8)) {
        goto LABEL_15;
      }
      id result = rest::operator==();
      if ((result & 1) == 0) {
        break;
      }
LABEL_17:
      uint64_t v14 = (void *)v2[1];
      if (v14)
      {
        do
        {
          uint64_t v15 = v14;
          uint64_t v14 = (void *)*v14;
        }
        while (v14);
      }
      else
      {
        do
        {
          uint64_t v15 = (void *)v2[2];
          BOOL v16 = *v15 == (void)v2;
          long long v2 = v15;
        }
        while (!v16);
      }
      long long v2 = v15;
      if (v15 == v3) {
        return result;
      }
    }
    int v8 = *((_DWORD *)v2 + 8);
LABEL_15:
    if (*(_DWORD *)(v4 + 128) == v8)
    {
      long long v13 = *(_OWORD *)(v6 + 16);
      v17[0] = *(_OWORD *)v6;
      v17[1] = v13;
      uint64_t v18 = *(void *)(v6 + 32);
      id result = sub_10059A978(v4, (uint64_t)v17, 1u);
    }
    goto LABEL_17;
  }
  return result;
}

double sub_10059A7FC(uint64_t a1)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 208));
  BOOL v3 = ServiceMap;
  if ((v4 & 0x8000000000000000) != 0)
  {
    xpc_object_t v5 = (unsigned __int8 *)(v4 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v6 = 5381;
    do
    {
      unint64_t v4 = v6;
      unsigned int v7 = *v5++;
      uint64_t v6 = (33 * v6) ^ v7;
    }
    while (v7);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v17 = v4;
  int v8 = sub_10004D37C(&v3[1].__m_.__sig, &v17);
  if (!v8)
  {
    uint64_t v10 = 0;
LABEL_11:
    std::mutex::unlock(v3);
    uint64_t v9 = 0;
    char v11 = 1;
    if (!v10) {
      goto LABEL_7;
    }
LABEL_12:
    double Current = (*(double (**)(uint64_t))(*(void *)v10 + 96))(v10);
    goto LABEL_13;
  }
  uint64_t v10 = v8[3];
  uint64_t v9 = (std::__shared_weak_count *)v8[4];
  if (!v9) {
    goto LABEL_11;
  }
  atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v3);
  atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v9);
  char v11 = 0;
  if (v10) {
    goto LABEL_12;
  }
LABEL_7:
  char v12 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)BOOL v16 = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "failed to get TimeHandlerInterface", v16, 2u);
  }
  double Current = CFAbsoluteTimeGetCurrent();
LABEL_13:
  double v14 = Current;
  if ((v11 & 1) == 0) {
    sub_10004D2C8(v9);
  }
  return v14;
}

void sub_10059A95C(_Unwind_Exception *exception_object)
{
  if ((v2 & 1) == 0) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10059A978(uint64_t a1, uint64_t a2, unsigned int a3)
{
  uint64_t v6 = (os_log_t *)(a1 + 40);
  unsigned int v7 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    if (a3 > 4) {
      int v8 = "???";
    }
    else {
      int v8 = off_1019E98D0[(char)a3];
    }
    LODWORD(buf) = 136315138;
    *(void *)((char *)&buf + 4) = v8;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Updating data usage billing cycle: %s", (uint8_t *)&buf, 0xCu);
  }
  int v9 = *(_DWORD *)(a1 + 136);
  if (!v9)
  {
    uint64_t v15 = *v6;
    if (!os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_103;
    }
    LOWORD(buf) = 0;
    BOOL v16 = "#I Carrier Space support is not known yet, skip the update";
    goto LABEL_19;
  }
  if (v9 == 2)
  {
    *(unsigned char *)(a2 + 2) = 0;
    if (sub_10059B4B0(a1, @"ShowBillingCycleBasedDataUsage", 1))
    {
      if (*(unsigned char *)(a1 + 152))
      {
        double v10 = *(double *)(a1 + 144);
        if (v10 > 0.0)
        {
          char v11 = (unint64_t *)(a2 + 8);
          int v12 = *(unsigned __int8 *)(a2 + 16);
          *(unsigned char *)a2 = 1;
          if (!v12)
          {
            unint64_t v14 = (unint64_t)v10;
LABEL_49:
            *(void *)(a2 + 24) = *v11;
            *(unsigned char *)(a2 + 32) = *(unsigned char *)(a2 + 16);
            *(void *)(a2 + 8) = v14;
            *(unsigned char *)(a2 + 16) = 1;
            goto LABEL_58;
          }
          if (*v11 >= (unint64_t)v10)
          {
            os_log_t v28 = *v6;
            if (!os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_58;
            }
            LOWORD(buf) = 0;
            uint64_t v29 = "#I New date is same/before currently configured date, so skip billing cycle update";
            uint64_t v30 = v28;
            uint32_t v31 = 2;
          }
          else
          {
            if (sub_1001D6F38(*v11, (unint64_t)v10) > 0x3F480)
            {
              int v13 = *(unsigned __int8 *)(a2 + 16);
              *(unsigned char *)a2 = 1;
              unint64_t v14 = (unint64_t)*(double *)(a1 + 144);
              if (!v13 || *(void *)(a2 + 8) != v14) {
                goto LABEL_49;
              }
LABEL_58:
              double v34 = sub_10059A7FC(a1);
              unint64_t v35 = sub_1001D6F38((unint64_t)v34, (unint64_t)*(double *)(a1 + 144));
              if (!v35) {
                goto LABEL_103;
              }
              ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 208));
              uint64_t v37 = ServiceMap;
              if (v38 < 0)
              {
                uint64_t v39 = (unsigned __int8 *)(v38 & 0x7FFFFFFFFFFFFFFFLL);
                uint64_t v40 = 5381;
                do
                {
                  uint64_t v38 = v40;
                  unsigned int v41 = *v39++;
                  uint64_t v40 = (33 * v40) ^ v41;
                }
                while (v41);
              }
              std::mutex::lock(ServiceMap);
              *(void *)&long long buf = v38;
              long long v42 = sub_10004D37C(&v37[1].__m_.__sig, (unint64_t *)&buf);
              if (v42)
              {
                uint64_t v44 = v42[3];
                uint64_t v43 = (std::__shared_weak_count *)v42[4];
                if (v43)
                {
                  atomic_fetch_add_explicit(&v43->__shared_owners_, 1uLL, memory_order_relaxed);
                  std::mutex::unlock(v37);
                  atomic_fetch_add_explicit(&v43->__shared_owners_, 1uLL, memory_order_relaxed);
                  sub_10004D2C8(v43);
                  int v45 = 0;
                  goto LABEL_67;
                }
              }
              else
              {
                uint64_t v44 = 0;
              }
              std::mutex::unlock(v37);
              uint64_t v43 = 0;
              int v45 = 1;
LABEL_67:
              if (v44)
              {
                long long v46 = operator new(0x10uLL);
                *((void *)&buf + 1) = v46 + 2;
                xpc_object_t v76 = v46 + 2;
                *long long v46 = @"CellularDataUsage";
                v46[1] = @"NumberOfDaysInBillingCycle";
                *(void *)&long long buf = v46;
                cf[0] = 0;
                (*(void (**)(CFTypeRef *__return_ptr, uint64_t, void, uint64_t, long long *, void, void))(*(void *)v44 + 104))(cf, v44, *(unsigned int *)(a1 + 128), 1, &buf, 0, 0);
                uint64_t v47 = (int *)cf[0];
                LODWORD(__p[0]) = 0;
                if (cf[0] && (CFTypeID v48 = CFGetTypeID(cf[0]), v48 == CFNumberGetTypeID()))
                {
                  ctu::cf::assign((ctu::cf *)__p, v47, v49);
                  int v50 = (int)__p[0];
                }
                else
                {
                  int v50 = 0;
                }
                sub_1000577C4(cf);
                if ((void)buf)
                {
                  *((void *)&buf + 1) = buf;
                  operator delete((void *)buf);
                }
                if (v45)
                {
LABEL_80:
                  __int16 v51 = *v6;
                  if (v50)
                  {
                    if (os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT))
                    {
                      LODWORD(buf) = 67109120;
                      DWORD1(buf) = v50;
                      _os_log_impl((void *)&_mh_execute_header, v51, OS_LOG_TYPE_DEFAULT, "#I Number of days in billing cycle: %d", (uint8_t *)&buf, 8u);
                    }
                    memset(cf, 0, 24);
                    int v52 = *(std::__shared_weak_count **)(a1 + 16);
                    if (!v52 || (uint64_t v53 = *(void *)(a1 + 8), (v54 = std::__shared_weak_count::lock(v52)) == 0)) {
                      sub_100088B9C();
                    }
                    xpc_object_t v55 = v54;
                    atomic_fetch_add_explicit(&v54->__shared_weak_owners_, 1uLL, memory_order_relaxed);
                    sub_10004D2C8(v54);
                    uint64_t v56 = operator new(0x28uLL);
                    *uint64_t v56 = off_1019E97A0;
                    v56[1] = a1;
                    *((_DWORD *)v56 + 4) = v50;
                    v56[3] = v53;
                    v56[4] = v55;
                    cf[3] = v56;
                    uint64_t v57 = *(void *)(a1 + 184);
                    if (v57) {
                      (*(void (**)(uint64_t))(*(void *)v57 + 16))(v57);
                    }
                    uint64_t v58 = *v6;
                    if (os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT))
                    {
                      LODWORD(buf) = 134217984;
                      *(void *)((char *)&buf + 4) = v35;
                      _os_log_impl((void *)&_mh_execute_header, v58, OS_LOG_TYPE_DEFAULT, "#I Scheduling a billing cycle date update in %lld secs", (uint8_t *)&buf, 0xCu);
                    }
                    Registry::getTimerService(&v69, *(Registry **)(a1 + 208));
                    uint64_t v59 = v69;
                    sub_100058DB0(v67, "Carrier Space Billing Cycle Update");
                    *(_OWORD *)std::string __p = *(_OWORD *)v67;
                    uint64_t v73 = v68;
                    v67[0] = 0;
                    v67[1] = 0;
                    uint64_t v68 = 0;
                    sub_1000DA470((uint64_t)&buf, (uint64_t)cf);
                    (*(void (**)(uint64_t *__return_ptr, uint64_t, void **, uint64_t, unint64_t, void, long long *))(*(void *)v59 + 40))(&v71, v59, __p, 1, 1000000 * v35, 0, &buf);
                    sub_10003B34C(&buf);
                    if (SHIBYTE(v73) < 0) {
                      operator delete(__p[0]);
                    }
                    uint64_t v60 = v71;
                    uint64_t v71 = 0;
                    uint64_t v61 = *(void *)(a1 + 184);
                    *(void *)(a1 + 184) = v60;
                    if (v61)
                    {
                      (*(void (**)(uint64_t))(*(void *)v61 + 8))(v61);
                      uint64_t v62 = v71;
                      uint64_t v71 = 0;
                      if (v62) {
                        (*(void (**)(uint64_t))(*(void *)v62 + 8))(v62);
                      }
                    }
                    if (SHIBYTE(v68) < 0) {
                      operator delete(v67[0]);
                    }
                    if (v70) {
                      sub_10004D2C8(v70);
                    }
                    sub_10003B34C(cf);
                    goto LABEL_103;
                  }
                  goto LABEL_101;
                }
LABEL_79:
                sub_10004D2C8(v43);
                goto LABEL_80;
              }
              __int16 v51 = *v6;
              if (os_log_type_enabled(*v6, OS_LOG_TYPE_ERROR))
              {
                LOWORD(buf) = 0;
                _os_log_error_impl((void *)&_mh_execute_header, v51, OS_LOG_TYPE_ERROR, "Could not get CarrierSettingsInterface", (uint8_t *)&buf, 2u);
                int v50 = 0;
                if (!v45) {
                  goto LABEL_79;
                }
                __int16 v51 = *v6;
              }
              else if ((v45 & 1) == 0)
              {
                int v50 = 0;
                goto LABEL_79;
              }
LABEL_101:
              if (os_log_type_enabled(v51, OS_LOG_TYPE_ERROR))
              {
                LOWORD(buf) = 0;
                _os_log_error_impl((void *)&_mh_execute_header, v51, OS_LOG_TYPE_ERROR, "Number of days in billing cycle is invalid or not available", (uint8_t *)&buf, 2u);
              }
              goto LABEL_103;
            }
            os_log_t v33 = *v6;
            if (!os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_58;
            }
            *(void *)&long long buf = 0x304000100;
            uint64_t v29 = "#I New date is within %d days of currently configured date, so skip billing cycle update";
            uint64_t v30 = v33;
            uint32_t v31 = 8;
          }
          _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, v29, (uint8_t *)&buf, v31);
          goto LABEL_58;
        }
        uint64_t v15 = *v6;
        if (!os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_103;
        }
        LOWORD(buf) = 0;
        BOOL v16 = "#N Billing cycle date is not valid";
      }
      else
      {
        uint64_t v15 = *v6;
        if (!os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_103;
        }
        LOWORD(buf) = 0;
        BOOL v16 = "#N Billing cycle date is not available";
      }
LABEL_19:
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, v16, (uint8_t *)&buf, 2u);
      goto LABEL_103;
    }
    uint64_t v18 = *v6;
    if (os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf) = 0;
      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#I ShowBillingCycleBasedDataUsage is disabled", (uint8_t *)&buf, 2u);
    }
    *(unsigned char *)a2 = 0;
    goto LABEL_37;
  }
  *(unsigned char *)a2 = 0;
  if (sub_10059B4B0(a1, @"ShowMonthlyDataUsage", 0))
  {
    unint64_t v17 = *v6;
    if (os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf) = 0;
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I Carrier bundle says billing cycle is end of month", (uint8_t *)&buf, 2u);
    }
    *(unsigned char *)(a2 + 2) = 1;
    sub_10059B6DC(a1, a2);
    goto LABEL_103;
  }
  unsigned int v19 = *(_DWORD *)(a1 + 48);
  if (v19 - 1 > 0x1E)
  {
    uint64_t v26 = *v6;
    if (os_log_type_enabled(*v6, OS_LOG_TYPE_ERROR))
    {
      LOWORD(buf) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_ERROR, "Could not determine the bill date", (uint8_t *)&buf, 2u);
    }
    *(_WORD *)(a2 + 1) = 0;
LABEL_37:
    if (*(unsigned char *)(a2 + 32)) {
      *(unsigned char *)(a2 + 32) = 0;
    }
    if (*(unsigned char *)(a2 + 16)) {
      *(unsigned char *)(a2 + 16) = 0;
    }
    goto LABEL_103;
  }
  *(_WORD *)(a2 + 1) = 1;
  if (v19 > 0x1C)
  {
    uint64_t v27 = *v6;
    if (os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf) = 0;
      _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "#I Default to end of the month", (uint8_t *)&buf, 2u);
    }
    goto LABEL_47;
  }
  double v20 = sub_10059A7FC(a1);
  unint64_t v21 = sub_1001D7268((unint64_t)v20, *(_DWORD *)(a1 + 48));
  unint64_t v22 = v21;
  if (!v21)
  {
    int v32 = *v6;
    if (os_log_type_enabled(*v6, OS_LOG_TYPE_ERROR))
    {
      LOWORD(buf) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_ERROR, "Could not determine the next bill day", (uint8_t *)&buf, 2u);
    }
LABEL_47:
    sub_10059B6DC(a1, a2);
    goto LABEL_103;
  }
  uint64_t v23 = *(void *)(a2 + 8);
  *(unsigned char *)(a2 + 1) = 1;
  if (!*(unsigned char *)(a2 + 16) || v21 != v23)
  {
    *(void *)(a2 + 24) = *(void *)(a2 + 8);
    *(unsigned char *)(a2 + 32) = *(unsigned char *)(a2 + 16);
    *(void *)(a2 + 8) = v21;
    *(unsigned char *)(a2 + 16) = 1;
  }
  *(void *)(a2 + 24) = sub_1001D7130(v21, 0);
  *(unsigned char *)(a2 + 32) = 1;
  double v24 = sub_10059A7FC(a1);
  unint64_t v25 = sub_1001D6F38((unint64_t)v24, v22 + 1);
  sub_10059B80C(a1, v25);
LABEL_103:
  DataUsageBillingCycle::dumpState((DataUsageBillingCycle *)(a1 + 88), (const ctu::OsLogLogger *)v6, "Old State");
  long long v63 = *(_OWORD *)a2;
  long long v64 = *(_OWORD *)(a2 + 16);
  *(void *)(a1 + 120) = *(void *)(a2 + 32);
  *(_OWORD *)(a1 + 88) = v63;
  *(_OWORD *)(a1 + 104) = v64;
  uint64_t v65 = *(void *)(a1 + 80);
  if (v65) {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v65 + 48))(v65, a1 + 88);
  }
  return DataUsageBillingCycle::dumpState((DataUsageBillingCycle *)(a1 + 88), (const ctu::OsLogLogger *)v6, "New State");
}

void sub_10059B38C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,void *a29,uint64_t a30)
{
}

uint64_t sub_10059B44C(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = 0;
  long long v5 = 0u;
  long long v6 = 0u;
  char v2 = *(void **)a2;
  unint64_t v3 = *(void *)(a2 + 8) - *(void *)a2;
  if (v3)
  {
    *((void *)&v5 + 1) = *v2;
    LOBYTE(v6) = 1;
    if (v3 >= 9)
    {
      *((void *)&v6 + 1) = v2[1];
      LOBYTE(v7) = 1;
    }
  }
  return sub_10059A978(a1, (uint64_t)&v5, 0);
}

BOOL sub_10059B4B0(uint64_t a1, uint64_t a2, BOOL a3)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 208));
  uint64_t v7 = ServiceMap;
  if (v8 < 0)
  {
    int v9 = (unsigned __int8 *)(v8 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v10 = 5381;
    do
    {
      uint64_t v8 = v10;
      unsigned int v11 = *v9++;
      uint64_t v10 = (33 * v10) ^ v11;
    }
    while (v11);
  }
  std::mutex::lock(ServiceMap);
  *(void *)long long buf = v8;
  int v12 = sub_10004D37C(&v7[1].__m_.__sig, (unint64_t *)buf);
  if (v12)
  {
    uint64_t v14 = v12[3];
    int v13 = (std::__shared_weak_count *)v12[4];
    if (v13)
    {
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v7);
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v13);
      char v15 = 0;
      if (!v14) {
        goto LABEL_7;
      }
      goto LABEL_11;
    }
  }
  else
  {
    uint64_t v14 = 0;
  }
  std::mutex::unlock(v7);
  int v13 = 0;
  char v15 = 1;
  if (!v14)
  {
LABEL_7:
    BOOL v16 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "Could not get CarrierSettingsInterface", buf, 2u);
    }
    goto LABEL_16;
  }
LABEL_11:
  unint64_t v17 = operator new(0x10uLL);
  double v24 = v17 + 2;
  unint64_t v25 = v17 + 2;
  *unint64_t v17 = @"CellularDataUsage";
  v17[1] = a2;
  CFTypeRef cf = 0;
  *(void *)long long buf = v17;
  (*(void (**)(CFTypeRef *__return_ptr, uint64_t, void, uint64_t, uint8_t *, void, void))(*(void *)v14 + 104))(&cf, v14, *(unsigned int *)(a1 + 128), 1, buf, 0, 0);
  uint64_t v18 = (BOOL *)cf;
  BOOL v26 = a3;
  if (cf)
  {
    CFTypeID v19 = CFGetTypeID(cf);
    if (v19 == CFBooleanGetTypeID())
    {
      ctu::cf::assign((ctu::cf *)&v26, v18, v20);
      a3 = v26;
    }
  }
  sub_1000577C4(&cf);
  if (*(void *)buf)
  {
    double v24 = *(void **)buf;
    operator delete(*(void **)buf);
  }
LABEL_16:
  if ((v15 & 1) == 0) {
    sub_10004D2C8(v13);
  }
  return a3;
}

void sub_10059B698(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, void *__p, uint64_t a12)
{
  if (__p) {
    operator delete(__p);
  }
  if ((v13 & 1) == 0) {
    sub_10004D2C8(v12);
  }
  _Unwind_Resume(exception_object);
}

void sub_10059B6DC(uint64_t a1, uint64_t a2)
{
  double v4 = sub_10059A7FC(a1);
  unint64_t v5 = sub_1001D6FE0((unint64_t)v4);
  if (v5)
  {
    unint64_t v6 = v5;
    if (*(unsigned char *)(a2 + 16)) {
      BOOL v7 = v5 == *(void *)(a2 + 8);
    }
    else {
      BOOL v7 = 0;
    }
    if (!v7)
    {
      *(void *)(a2 + 24) = *(void *)(a2 + 8);
      *(unsigned char *)(a2 + 32) = *(unsigned char *)(a2 + 16);
      *(void *)(a2 + 8) = v5;
      *(unsigned char *)(a2 + 16) = 1;
    }
    *(void *)(a2 + 24) = sub_1001D7130(v5, 1);
    *(unsigned char *)(a2 + 32) = 1;
    double v8 = sub_10059A7FC(a1);
    unint64_t v9 = sub_1001D6F38((unint64_t)v8, v6 + 1);
    sub_10059B80C(a1, v9);
  }
  else
  {
    uint64_t v10 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)unsigned int v11 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "Could not determine the last day of the month", v11, 2u);
    }
    *(_WORD *)(a2 + 1) = 0;
    if (*(unsigned char *)(a2 + 32)) {
      *(unsigned char *)(a2 + 32) = 0;
    }
    if (*(unsigned char *)(a2 + 16)) {
      *(unsigned char *)(a2 + 16) = 0;
    }
  }
}

void *sub_10059B80C(uint64_t a1, uint64_t a2)
{
  unint64_t v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (!v3 || (v5 = *(void *)(a1 + 8), (unint64_t v6 = std::__shared_weak_count::lock(v3)) == 0)) {
    sub_100088B9C();
  }
  BOOL v7 = v6;
  atomic_fetch_add_explicit(&v6->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v6);
  v21[0] = off_1019E9720;
  v21[1] = v5;
  v21[2] = v7;
  v21[3] = v21;
  uint64_t v8 = *(void *)(a1 + 184);
  if (v8)
  {
    *(void *)(a1 + 184) = 0;
    (*(void (**)(uint64_t))(*(void *)v8 + 8))(v8);
  }
  Registry::getTimerService(&v16, *(Registry **)(a1 + 208));
  uint64_t v9 = v16;
  sub_100058DB0(v14, "Monthly Billing Cycle Update");
  *(_OWORD *)std::string __p = *(_OWORD *)v14;
  uint64_t v20 = v15;
  v14[0] = 0;
  v14[1] = 0;
  uint64_t v15 = 0;
  sub_1000DA470((uint64_t)v22, (uint64_t)v21);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, void **, uint64_t, uint64_t, void, void *))(*(void *)v9 + 40))(&v18, v9, __p, 1, 1000000 * a2, 0, v22);
  sub_10003B34C(v22);
  if (SHIBYTE(v20) < 0) {
    operator delete(__p[0]);
  }
  uint64_t v10 = v18;
  uint64_t v18 = 0;
  uint64_t v11 = *(void *)(a1 + 184);
  *(void *)(a1 + 184) = v10;
  if (v11)
  {
    (*(void (**)(uint64_t))(*(void *)v11 + 8))(v11);
    uint64_t v12 = v18;
    uint64_t v18 = 0;
    if (v12) {
      (*(void (**)(uint64_t))(*(void *)v12 + 8))(v12);
    }
  }
  if (SHIBYTE(v15) < 0) {
    operator delete(v14[0]);
  }
  if (v17) {
    sub_10004D2C8(v17);
  }
  return sub_10003B34C(v21);
}

void sub_10059BA20(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, std::__shared_weak_count *a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24)
{
  sub_10003B34C((void *)(v24 - 72));
  if (a23 < 0) {
    operator delete(__p);
  }
  if (a14 < 0) {
    operator delete(a9);
  }
  if (a16) {
    sub_10004D2C8(a16);
  }
  sub_10003B34C(&a24);
  _Unwind_Resume(a1);
}

uint64_t sub_10059BA78(uint64_t a1)
{
  return *(void *)(a1 + 96);
}

uint64_t sub_10059BA84(uint64_t a1)
{
  return *(void *)(a1 + 112);
}

void sub_10059BA90(uint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t a3@<X8>)
{
  if (a2)
  {
    if (*(unsigned char *)(a1 + 104))
    {
      std::string __p = 0;
      uint64_t v10 = 0;
      uint64_t v11 = 0;
      sub_10059C2D8(&__p, a2);
      unint64_t v6 = __p;
      *(void *)std::string __p = *(void *)(a1 + 96);
      if (a2 == 1)
      {
        *(void *)a3 = 0;
        *(void *)(a3 + 8) = 0;
        *(void *)(a3 + 16) = 0;
        sub_10010556C((void *)a3, v6, (uint64_t)v10, v10 - v6);
      }
      else
      {
        BOOL v7 = v6;
        if (*(unsigned char *)(a1 + 120))
        {
          v6[1] = *(void *)(a1 + 112);
          BOOL v7 = v6 + 1;
        }
        uint64_t v8 = v7 + 1;
        if (v7 + 1 != v10)
        {
          do
          {
            unint64_t *v8 = sub_1001D7130(*(v8 - 1), 0);
            ++v8;
          }
          while (v8 != v10);
          unint64_t v6 = __p;
        }
        *(void *)a3 = 0;
        *(void *)(a3 + 8) = 0;
        *(void *)(a3 + 16) = 0;
        sub_10010556C((void *)a3, v6, (uint64_t)v8, v8 - v6);
      }
      *(unsigned char *)(a3 + 24) = 1;
      if (__p)
      {
        uint64_t v10 = (unint64_t *)__p;
        operator delete(__p);
      }
    }
    else
    {
      *(void *)a3 = 0;
      *(void *)(a3 + 8) = 0;
      *(void *)(a3 + 16) = 0;
      *(unsigned char *)(a3 + 24) = 1;
    }
  }
  else
  {
    *(unsigned char *)a3 = 0;
    *(unsigned char *)(a3 + 24) = 0;
  }
}

void sub_10059BBB4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10059BBD8(uint64_t a1)
{
  return ctu::RestModule::disconnect((ctu::RestModule *)(a1 + 192));
}

__n128 sub_10059BBE0@<Q0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  __n128 result = *(__n128 *)(a1 + 88);
  long long v3 = *(_OWORD *)(a1 + 104);
  *(__n128 *)a2 = result;
  *(_OWORD *)(a2 + 16) = v3;
  *(void *)(a2 + 32) = *(void *)(a1 + 120);
  return result;
}

uint64_t sub_10059BBF8(uint64_t a1)
{
  uint64_t v4 = a1;
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  v5[2] = sub_10059D5D8;
  v5[3] = &unk_1019E9810;
  void v5[4] = a1 + 8;
  v5[5] = &v4;
  unint64_t v6 = v5;
  uint64_t v2 = a1 + 24;
  uint64_t v1 = *(NSObject **)(a1 + 24);
  if (*(void *)(v2 + 8))
  {
    block = _NSConcreteStackBlock;
    uint64_t v8 = 0x40000000;
    uint64_t v9 = sub_10059D63C;
    uint64_t v10 = &unk_1019E9850;
    uint64_t v11 = &v13;
    uint64_t v12 = &v6;
    uint64_t v13 = 0;
    dispatch_async_and_wait(v1, &block);
  }
  else
  {
    block = _NSConcreteStackBlock;
    uint64_t v8 = 0x40000000;
    uint64_t v9 = sub_10059D5F8;
    uint64_t v10 = &unk_1019E9830;
    uint64_t v11 = &v13;
    uint64_t v12 = &v6;
    uint64_t v13 = 0;
    dispatch_sync(v1, &block);
  }
  return v13;
}

BOOL sub_10059BD20(uint64_t a1, int a2)
{
  uint64_t v5 = a1;
  int v6 = a2;
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 0x40000000;
  void v7[2] = sub_10059D680;
  double v7[3] = &unk_1019E9870;
  _OWORD v7[4] = a1 + 8;
  v7[5] = &v5;
  uint64_t v8 = v7;
  uint64_t v3 = a1 + 24;
  uint64_t v2 = *(NSObject **)(a1 + 24);
  if (*(void *)(v3 + 8))
  {
    char v15 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v10 = 0x40000000;
    uint64_t v11 = sub_10005AD98;
    uint64_t v12 = &unk_1019E98B0;
    uint64_t v13 = &v15;
    uint64_t v14 = &v8;
    dispatch_async_and_wait(v2, &block);
  }
  else
  {
    char v15 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v10 = 0x40000000;
    uint64_t v11 = sub_10005A034;
    uint64_t v12 = &unk_1019E9890;
    uint64_t v13 = &v15;
    uint64_t v14 = &v8;
    dispatch_sync(v2, &block);
  }
  return v15 != 0;
}

void sub_10059BE58(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

uint64_t sub_10059BF38(uint64_t a1)
{
  long long v1 = *(_OWORD *)(a1 + 104);
  v3[0] = *(_OWORD *)(a1 + 88);
  v3[1] = v1;
  uint64_t v4 = *(void *)(a1 + 120);
  return sub_10059A978(a1, (uint64_t)v3, 3u);
}

void sub_10059BF74(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 96);
  uint64_t v3 = *(void *)(a1 + 104);
  uint64_t v4 = *(void *)(a1 + 112);
  uint64_t v5 = *(void *)(a1 + 120);
  int v6 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    if (*(unsigned char *)(a1 + 88)) {
      BOOL v7 = "true";
    }
    else {
      BOOL v7 = "false";
    }
    *(_DWORD *)std::string __p = 136315138;
    *(void *)&__p[4] = v7;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Carrier space supported: %s", __p, 0xCu);
    int v6 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    if (*(unsigned char *)(a1 + 90)) {
      uint64_t v8 = "true";
    }
    else {
      uint64_t v8 = "false";
    }
    *(_DWORD *)std::string __p = 136315138;
    *(void *)&__p[4] = v8;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Billing cycle date derived from carrier bundle: %s", __p, 0xCu);
    int v6 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    if (*(unsigned char *)(a1 + 89)) {
      uint64_t v9 = "true";
    }
    else {
      uint64_t v9 = "false";
    }
    *(_DWORD *)std::string __p = 136315138;
    *(void *)&__p[4] = v9;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Billing cycle date derived from user: %s", __p, 0xCu);
    int v6 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    if ((_BYTE)v3) {
      uint64_t v10 = v2;
    }
    else {
      uint64_t v10 = 0;
    }
    billingCycleDateToString();
    if (v15 >= 0) {
      uint64_t v11 = __p;
    }
    else {
      uint64_t v11 = *(unsigned char **)__p;
    }
    *(_DWORD *)long long buf = 134218242;
    uint64_t v17 = v10;
    __int16 v18 = 2082;
    CFTypeID v19 = v11;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Current billing cycle date: (%lld) %{public}s", buf, 0x16u);
    if (v15 < 0) {
      operator delete(*(void **)__p);
    }
    int v6 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    if ((_BYTE)v5) {
      uint64_t v12 = v4;
    }
    else {
      uint64_t v12 = 0;
    }
    billingCycleDateToString();
    if (v15 >= 0) {
      uint64_t v13 = __p;
    }
    else {
      uint64_t v13 = *(unsigned char **)__p;
    }
    *(_DWORD *)long long buf = 134218242;
    uint64_t v17 = v12;
    __int16 v18 = 2082;
    CFTypeID v19 = v13;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Previous billing cycle date: (%lld) %{public}s", buf, 0x16u);
    if (v15 < 0) {
      operator delete(*(void **)__p);
    }
  }
}

void sub_10059C21C(uint64_t a1)
{
  sub_10059C350(a1);

  operator delete();
}

void *sub_10059C254(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *sub_10059C2D8(void *a1, unint64_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    sub_1001055E8(a1, a2);
    uint64_t v4 = (char *)a1[1];
    bzero(v4, 8 * a2);
    a1[1] = &v4[8 * a2];
  }
  return a1;
}

void sub_10059C334(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void sub_10059C350(uint64_t a1)
{
  *(void *)a1 = off_1019E9388;
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 232);
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 216);
  if (v3) {
    sub_10004D2C8(v3);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 200);
  if (v4) {
    sub_10004D2C8(v4);
  }
  uint64_t v5 = *(void *)(a1 + 184);
  *(void *)(a1 + 184) = 0;
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
  }
  sub_100087F94(a1 + 160, *(void **)(a1 + 168));
  sub_10059C254((void *)(a1 + 56));
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 40));
  sub_100087E88((void *)(a1 + 8));

  DataUsageBillingCycleEvaluatorInterface::~DataUsageBillingCycleEvaluatorInterface((DataUsageBillingCycleEvaluatorInterface *)a1);
}

void sub_10059C41C(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_10059C4E8(void *a1)
{
  __cxa_begin_catch(a1);
  dispatch_barrier_async_f(v1[3], v1, (dispatch_function_t)sub_10059C5C0);
  __cxa_rethrow();
}

void sub_10059C510(_Unwind_Exception *a1)
{
}

void sub_10059C528(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_10059C560(uint64_t a1)
{
}

uint64_t sub_10059C57C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_10059C5C0(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void sub_10059C5F0()
{
}

void *sub_10059C604(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_1019E9510;
  result[1] = v3;
  return result;
}

uint64_t sub_10059C64C(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019E9510;
  a2[1] = v2;
  return result;
}

void sub_10059C678(uint64_t a1, const DataUsageBillingCycle *a2)
{
  xpc_object_t v5 = 0;
  write_rest_value(a2);
  sub_100058DB0(&__p, "/cc/props/data_usage_billing_cycle");
  xpc_object_t object = v5;
  if (v5) {
    xpc_retain(v5);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(object);
  if (v4 < 0) {
    operator delete(__p);
  }
  xpc_release(v5);
}

void sub_10059C71C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  xpc_release(object);
  if (a16 < 0) {
    operator delete(__p);
  }
  xpc_release(*(xpc_object_t *)(v16 - 24));
  _Unwind_Resume(a1);
}

uint64_t sub_10059C760(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10059C7A0()
{
}

void sub_10059C7B0()
{
}

__n128 sub_10059C7C4(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_1019E95A0;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_10059C818(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019E95A0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_10059C850(void *a1, xpc_object_t *a2)
{
  char v4 = (unsigned int *)a1[1];
  uint64_t v5 = *v4;
  xpc_type_t type = xpc_get_type(*a2);
  if (type == (xpc_type_t)&_xpc_type_string)
  {
    unsigned int v14 = *v4;
    ctu::rest::detail::read_enum_string_value((ctu::rest::detail *)&v14, (int *)a2, v7);
    unsigned int *v4 = v14;
  }
  else if (type == (xpc_type_t)&_xpc_type_BOOL {
         || type == (xpc_type_t)&_xpc_type_int64
  }
         || type == (xpc_type_t)&_xpc_type_uint64)
  {
    unsigned int *v4 = xpc::dyn_cast_or_default((xpc *)a2, 0, (uint64_t)v7);
  }
  uint64_t v10 = (uint64_t (*)(void *, uint64_t))a1[3];
  uint64_t v11 = a1[4];
  uint64_t v12 = (void *)(a1[2] + (v11 >> 1));
  if (v11) {
    uint64_t v10 = *(uint64_t (**)(void *, uint64_t))(*v12 + v10);
  }
  return v10(v12, v5);
}

uint64_t sub_10059C948(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10059C988()
{
}

void sub_10059C998()
{
}

__n128 sub_10059C9AC(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_1019E9620;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_10059CA00(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019E9620;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_10059CA38(void *a1)
{
  rest::read_rest_value();
  uint64_t v2 = (uint64_t (*)(void *))a1[3];
  uint64_t v3 = a1[4];
  char v4 = (void *)(a1[2] + (v3 >> 1));
  if (v3) {
    uint64_t v2 = *(uint64_t (**)(void *))(*v4 + v2);
  }

  return v2(v4);
}

uint64_t sub_10059CAB4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10059CAF4()
{
}

void sub_10059CB04()
{
}

__n128 sub_10059CB18(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_1019E96A0;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_10059CB6C(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019E96A0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_10059CBA4(void *a1, xpc_object_t *a2)
{
  uint64_t v3 = (void *)a1[1];
  char v4 = v3 + 1;
  uint64_t v5 = (void *)v3[1];
  uint64_t v9 = (void **)*v3;
  uint64_t v10 = v5;
  if (v3[2])
  {
    v5[2] = &v10;
    void *v3 = v4;
    void *v4 = 0;
    _OWORD v3[2] = 0;
  }
  else
  {
    uint64_t v9 = &v10;
  }
  sub_10008AAD8((uint64_t)v3, a2);
  int v6 = (void (*)(void *, void ***))a1[3];
  uint64_t v7 = a1[4];
  uint64_t v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    int v6 = *(void (**)(void *, void ***))(*v8 + v6);
  }
  v6(v8, &v9);
  sub_100087F94((uint64_t)&v9, v10);
}

void sub_10059CC64(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11)
{
}

uint64_t sub_10059CC7C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10059CCBC()
{
}

void *sub_10059CCC8(void *a1)
{
  *a1 = off_1019E9720;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_10059CD14(void *a1)
{
  *a1 = off_1019E9720;
  uint64_t v1 = (std::__shared_weak_count *)a1[2];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

void *sub_10059CD80(uint64_t a1)
{
  __n128 result = operator new(0x18uLL);
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 16);
  void *result = off_1019E9720;
  result[1] = v4;
  result[2] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_10059CDDC(uint64_t result, void *a2)
{
  uint64_t v3 = *(void *)(result + 8);
  uint64_t v2 = *(void *)(result + 16);
  *a2 = off_1019E9720;
  a2[1] = v3;
  a2[2] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_10059CE14(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_10059CE24(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[2];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete(__p);
}

void sub_10059CE64(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2)
  {
    uint64_t v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      uint64_t v4 = *(void *)(a1 + 8);
      if (v4)
      {
        atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
        uint64_t v5 = *(std::__shared_weak_count **)(v4 + 16);
        if (v5)
        {
          if (std::__shared_weak_count::lock(v5)) {
            operator new();
          }
        }
        sub_100088B9C();
      }
      sub_10004D2C8(v3);
    }
  }
}

uint64_t sub_10059CF7C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10059CFBC()
{
}

uint64_t *sub_10059CFC8(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v5 = a1;
  uint64_t v6 = v1;
  uint64_t v2 = *(void *)v1;
  long long v3 = *(_OWORD *)(*(void *)v1 + 104);
  v7[0] = *(_OWORD *)(*(void *)v1 + 88);
  v7[1] = v3;
  uint64_t v8 = *(void *)(v2 + 120);
  sub_10059A978(v2, (uint64_t)v7, 2u);
  sub_1000E3958(&v6);
  return sub_100046B58((uint64_t *)&v5);
}

void sub_10059D028(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

void *sub_10059D044(void *a1)
{
  *a1 = off_1019E97A0;
  uint64_t v2 = (std::__shared_weak_count *)a1[4];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_10059D090(void *a1)
{
  *a1 = off_1019E97A0;
  uint64_t v1 = (std::__shared_weak_count *)a1[4];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

void *sub_10059D0FC(uint64_t a1)
{
  __n128 result = operator new(0x28uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_1019E97A0;
  result[1] = v3;
  *((_DWORD *)result + 4) = *(_DWORD *)(a1 + 16);
  uint64_t v4 = *(void *)(a1 + 32);
  result[3] = *(void *)(a1 + 24);
  result[4] = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_10059D164(uint64_t result, uint64_t a2)
{
  *(void *)a2 = off_1019E97A0;
  uint64_t v2 = *(void *)(result + 8);
  *(_DWORD *)(a2 + 16) = *(_DWORD *)(result + 16);
  *(void *)(a2 + 8) = v2;
  uint64_t v3 = *(void *)(result + 32);
  *(void *)(a2 + 24) = *(void *)(result + 24);
  *(void *)(a2 + 32) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_10059D1AC(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 32);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_10059D1BC(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[4];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete(__p);
}

void sub_10059D1FC(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 32);
  if (v2)
  {
    uint64_t v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      uint64_t v4 = *(void *)(a1 + 24);
      if (v4)
      {
        uint64_t v5 = *(std::__shared_weak_count **)(v4 + 16);
        if (v5)
        {
          if (std::__shared_weak_count::lock(v5)) {
            operator new();
          }
        }
        sub_100088B9C();
      }
      sub_10004D2C8(v3);
    }
  }
}

uint64_t sub_10059D31C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_10059D35C()
{
}

void sub_10059D368(uint64_t **a1)
{
  uint64_t v1 = **a1;
  if (*(_DWORD *)(v1 + 136) == 2)
  {
    int v2 = *((_DWORD *)*a1 + 2);
    *(_DWORD *)char v15 = *(_DWORD *)(v1 + 89);
    *(_DWORD *)&v15[3] = *(_DWORD *)(v1 + 92);
    unint64_t v3 = *(void *)(v1 + 96);
    int v4 = *(unsigned __int8 *)(v1 + 104);
    *(_DWORD *)unsigned int v14 = *(_DWORD *)(v1 + 105);
    *(_DWORD *)&uint64_t v14[3] = *(_DWORD *)(v1 + 108);
    unint64_t v11 = *(void *)(v1 + 112);
    char v10 = *(unsigned char *)(v1 + 120);
    *(_DWORD *)&v13[3] = *(_DWORD *)(v1 + 124);
    *(_DWORD *)uint64_t v13 = *(_DWORD *)(v1 + 121);
    uint64_t v12 = (DataUsageBillingCycle *)(v1 + 88);
    double v5 = sub_10059A7FC(v1) + (double)(unint64_t)(86400 * v2);
    uint64_t v6 = *(NSObject **)(v1 + 40);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 67109120;
      int v17 = v2;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Setting billing cycle end date to %d days in future", buf, 8u);
    }
    unint64_t v7 = (unint64_t)v5;
    if (v4 && v3 == v7)
    {
      unint64_t v7 = v3;
      char v8 = v4;
      LOBYTE(v4) = v10;
      unint64_t v3 = v11;
    }
    else
    {
      char v8 = 1;
    }
    DataUsageBillingCycle::dumpState(v12, (const ctu::OsLogLogger *)(v1 + 40), "Old state");
    *(unsigned char *)(v1 + 88) = 1;
    *(_DWORD *)(v1 + 89) = *(_DWORD *)v15;
    *(_DWORD *)(v1 + 92) = *(_DWORD *)&v15[3];
    *(void *)(v1 + 96) = v7;
    *(unsigned char *)(v1 + 104) = v8;
    *(_DWORD *)(v1 + 105) = *(_DWORD *)v14;
    *(_DWORD *)(v1 + 108) = *(_DWORD *)&v14[3];
    *(void *)(v1 + 112) = v3;
    *(unsigned char *)(v1 + 120) = v4;
    *(_DWORD *)(v1 + 121) = *(_DWORD *)v13;
    *(_DWORD *)(v1 + 124) = *(_DWORD *)&v13[3];
    uint64_t v9 = *(void *)(v1 + 80);
    if (v9) {
      (*(void (**)(uint64_t, DataUsageBillingCycle *))(*(void *)v9 + 48))(v9, v12);
    }
    DataUsageBillingCycle::dumpState(v12, (const ctu::OsLogLogger *)(v1 + 40), "New state");
  }
  operator delete();
}

void sub_10059D5AC()
{
}

unint64_t sub_10059D5D8(uint64_t a1)
{
  uint64_t v1 = *(unsigned int *)(**(void **)(a1 + 40) + 48);
  unsigned int v2 = v1 - 1;
  unint64_t v3 = v1 | (unint64_t)&_mh_execute_header;
  if (v2 >= 0x1F) {
    return 0;
  }
  else {
    return v3;
  }
}

uint64_t sub_10059D5F8(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 40) + 16))();
  uint64_t v3 = *(void *)(a1 + 32);
  *(_DWORD *)uint64_t v3 = result;
  *(unsigned char *)(v3 + 4) = BYTE4(result);
  return result;
}

uint64_t sub_10059D63C(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 40) + 16))();
  uint64_t v3 = *(void *)(a1 + 32);
  *(_DWORD *)uint64_t v3 = result;
  *(unsigned char *)(v3 + 4) = BYTE4(result);
  return result;
}

BOOL sub_10059D680(uint64_t a1)
{
  uint64_t v1 = *(_DWORD **)(a1 + 40);
  int v2 = v1[2];
  if ((v2 - 1) <= 0x1E) {
    *(_DWORD *)(*(void *)v1 + 48) = v2;
  }
  return (v2 - 1) < 0x1F;
}

void sub_10059D6A8(uint64_t a1)
{
  uint64_t v1 = a1;
  *(_DWORD *)(**(void **)a1 + 48) = -1;
  operator delete();
}

void sub_10059D6F4(uint64_t a1)
{
  *(void *)a1 = off_1019E9908;
  uint64_t v4 = *(void *)(a1 + 56);
  int v2 = (void *)(a1 + 56);
  uint64_t v3 = v4;
  void *v2 = 0;
  if (v4) {
    sub_100206334((uint64_t)v2, v3);
  }
  uint64_t v5 = *(void *)(a1 + 48);
  *(void *)(a1 + 48) = 0;
  if (v5) {
    sub_100206334(a1 + 48, v5);
  }
  uint64_t v6 = *(void *)(a1 + 40);
  *(void *)(a1 + 40) = 0;
  if (v6) {
    sub_100206334(a1 + 40, v6);
  }
  uint64_t v7 = *(void *)(a1 + 32);
  *(void *)(a1 + 32) = 0;
  if (v7) {
    sub_100206334(a1 + 32, v7);
  }
  sub_100110A40((void ***)(a1 + 24), 0);
  uint64_t v8 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = 0;
  if (v8) {
    sub_100206334(a1 + 16, v8);
  }
  sub_100110A40((void ***)(a1 + 8), 0);

  PB::Base::~Base((PB::Base *)a1);
}

void sub_10059D7C0(uint64_t a1)
{
  sub_10059D6F4(a1);

  operator delete();
}

uint64_t sub_10059D7F8(uint64_t result, uint64_t a2)
{
  *(void *)uint64_t result = off_1019E9908;
  *(_OWORD *)(result + 8) = 0u;
  *(_OWORD *)(result + 24) = 0u;
  *(_OWORD *)(result + 40) = 0u;
  *(void *)(result + 56) = 0;
  *(void *)(result + 64) = 1;
  if (*(void *)(a2 + 8)) {
    operator new();
  }
  if (*(void *)(a2 + 16)) {
    operator new();
  }
  if (*(void *)(a2 + 24)) {
    operator new();
  }
  if (*(void *)(a2 + 40)) {
    operator new();
  }
  if (*(void *)(a2 + 32)) {
    operator new();
  }
  if (*(unsigned char *)(a2 + 68))
  {
    int v2 = *(_DWORD *)(a2 + 64);
    *(unsigned char *)(result + 68) |= 1u;
    *(_DWORD *)(result + 64) = v2;
  }
  if (*(void *)(a2 + 56)) {
    operator new();
  }
  if (*(void *)(a2 + 48)) {
    operator new();
  }
  return result;
}

uint64_t sub_10059DB48(uint64_t a1, PB::TextFormatter *this, char *a3)
{
  PB::TextFormatter::beginObject(this, a3);
  if (*(unsigned char *)(a1 + 68)) {
    PB::TextFormatter::format(this, "consentType", *(_DWORD *)(a1 + 64));
  }
  uint64_t v5 = *(const PB::Data **)(a1 + 8);
  if (v5) {
    PB::TextFormatter::format(this, "csn", v5);
  }
  if (*(void *)(a1 + 16)) {
    PB::TextFormatter::format();
  }
  uint64_t v6 = *(const PB::Data **)(a1 + 24);
  if (v6) {
    PB::TextFormatter::format(this, "targetCsn", v6);
  }
  if (*(void *)(a1 + 32)) {
    PB::TextFormatter::format();
  }
  if (*(void *)(a1 + 40)) {
    PB::TextFormatter::format();
  }
  if (*(void *)(a1 + 48)) {
    PB::TextFormatter::format();
  }
  if (*(void *)(a1 + 56)) {
    PB::TextFormatter::format();
  }

  return PB::TextFormatter::endObject(this);
}

uint64_t sub_10059DC50(uint64_t a1, PB::Reader *this)
{
  unint64_t v2 = *((void *)this + 1);
  unint64_t v3 = *((void *)this + 2);
  int v4 = *((unsigned __int8 *)this + 24);
  if (v2 >= v3 || v4 != 0) {
    return v4 == 0;
  }
  while (1)
  {
    uint64_t v8 = *(void *)this;
    if (v2 <= 0xFFFFFFFFFFFFFFF5 && v2 + 10 <= v3) {
      break;
    }
    char v15 = 0;
    unsigned int v16 = 0;
    unint64_t v11 = 0;
    if (v2 > v3) {
      unint64_t v3 = v2;
    }
    do
    {
      if (v3 == v2)
      {
        int v4 = 1;
        *((unsigned char *)this + 24) = 1;
        return v4 == 0;
      }
      unint64_t v17 = v2 + 1;
      char v18 = *(unsigned char *)(v8 + v2);
      *((void *)this + 1) = v17;
      v11 |= (unint64_t)(v18 & 0x7F) << v15;
      if ((v18 & 0x80) == 0) {
        goto LABEL_22;
      }
      v15 += 7;
      unint64_t v2 = v17;
      BOOL v14 = v16++ > 8;
    }
    while (!v14);
LABEL_19:
    unsigned __int8 v19 = 0;
    LODWORD(v20) = 0;
LABEL_20:
    uint64_t result = PB::Reader::skip(this, v20, v19, 0);
    if (!result) {
      return result;
    }
LABEL_38:
    unint64_t v2 = *((void *)this + 1);
    unint64_t v3 = *((void *)this + 2);
    int v4 = *((unsigned __int8 *)this + 24);
    if (v2 >= v3 || v4 != 0) {
      return v4 == 0;
    }
  }
  char v9 = 0;
  unsigned int v10 = 0;
  unint64_t v11 = 0;
  while (1)
  {
    unint64_t v12 = v2 + 1;
    *((void *)this + 1) = v2 + 1;
    char v13 = *(unsigned char *)(v8 + v2);
    v11 |= (unint64_t)(v13 & 0x7F) << v9;
    if ((v13 & 0x80) == 0) {
      break;
    }
    v9 += 7;
    unint64_t v2 = v12;
    BOOL v14 = v10++ > 8;
    if (v14) {
      goto LABEL_19;
    }
  }
LABEL_22:
  unsigned __int8 v19 = v11 & 7;
  if ((v11 & 7) != 4)
  {
    unint64_t v20 = v11 >> 3;
    switch((v11 >> 3))
    {
      case 1u:
        operator new();
      case 2u:
        operator new();
      case 3u:
        operator new();
      case 4u:
        operator new();
      case 5u:
        operator new();
      case 6u:
        *(unsigned char *)(a1 + 68) |= 1u;
        unint64_t v22 = *((void *)this + 1);
        unint64_t v23 = *((void *)this + 2);
        uint64_t v24 = *(void *)this;
        if (v22 <= 0xFFFFFFFFFFFFFFF5 && v22 + 10 <= v23)
        {
          char v25 = 0;
          unsigned int v26 = 0;
          uint64_t v27 = 0;
          do
          {
            unint64_t v28 = v22 + 1;
            *((void *)this + 1) = v22 + 1;
            char v29 = *(unsigned char *)(v24 + v22);
            v27 |= (unint64_t)(v29 & 0x7F) << v25;
            if ((v29 & 0x80) == 0) {
              goto LABEL_53;
            }
            v25 += 7;
            unint64_t v22 = v28;
            BOOL v14 = v26++ > 8;
          }
          while (!v14);
LABEL_49:
          LODWORD(v27) = 0;
          goto LABEL_53;
        }
        char v31 = 0;
        unsigned int v32 = 0;
        uint64_t v27 = 0;
        if (v23 <= v22) {
          unint64_t v23 = *((void *)this + 1);
        }
        break;
      case 7u:
        operator new();
      case 8u:
        operator new();
      default:
        goto LABEL_20;
    }
    while (1)
    {
      if (v23 == v22)
      {
        LODWORD(v27) = 0;
        *((unsigned char *)this + 24) = 1;
        goto LABEL_53;
      }
      unint64_t v33 = v22 + 1;
      char v34 = *(unsigned char *)(v24 + v22);
      *((void *)this + 1) = v33;
      v27 |= (unint64_t)(v34 & 0x7F) << v31;
      if ((v34 & 0x80) == 0) {
        break;
      }
      v31 += 7;
      unint64_t v22 = v33;
      BOOL v14 = v32++ > 8;
      if (v14) {
        goto LABEL_49;
      }
    }
    if (*((unsigned char *)this + 24)) {
      LODWORD(v27) = 0;
    }
LABEL_53:
    *(_DWORD *)(a1 + 64) = v27;
    goto LABEL_38;
  }
  int v4 = 0;
  return v4 == 0;
}

uint64_t sub_10059E138(uint64_t result, PB::Writer *this)
{
  uint64_t v3 = result;
  int v4 = *(const PB::Data **)(result + 8);
  if (v4) {
    uint64_t result = PB::Writer::write(this, v4, 1u);
  }
  if (*(void *)(v3 + 16)) {
    uint64_t result = PB::Writer::write();
  }
  uint64_t v5 = *(const PB::Data **)(v3 + 24);
  if (v5) {
    uint64_t result = PB::Writer::write(this, v5, 3u);
  }
  if (*(void *)(v3 + 40)) {
    uint64_t result = PB::Writer::write();
  }
  if (*(void *)(v3 + 32)) {
    uint64_t result = PB::Writer::write();
  }
  if (*(unsigned char *)(v3 + 68)) {
    uint64_t result = PB::Writer::writeVarInt(this, *(_DWORD *)(v3 + 64), 6u);
  }
  if (*(void *)(v3 + 56)) {
    uint64_t result = PB::Writer::write();
  }
  if (*(void *)(v3 + 48))
  {
    return PB::Writer::write();
  }
  return result;
}

uint64_t sNetworkListPostMetric_SelectionChanged(unsigned int a1)
{
  switch(a1)
  {
    case 0u:
      uint64_t result = _WISPostSimpleMetric(524520, a1);
      break;
    default:
      uint64_t result = WISPostSimpleMetricWithUnsignedInteger();
      break;
  }
  return result;
}

uint64_t NetworkListController::getAwdSelectionTypeForSlot_sync(void **a1, uint64_t a2)
{
  uint64_t v11 = 0;
  unint64_t v12 = 0;
  NetworkListController::getModel_sync((uint64_t)a1, a2, &v11);
  if (v11)
  {
    int v4 = (*(uint64_t (**)(uint64_t))(*(void *)v11 + 280))(v11);
    int v5 = ((uint64_t (*)(void **, uint64_t))(*a1)[5])(a1, a2);
    if (v5)
    {
      if (v5 == 2) {
        unsigned int v6 = 4;
      }
      else {
        unsigned int v6 = 0;
      }
      if (v5 == 1) {
        uint64_t v7 = 2;
      }
      else {
        uint64_t v7 = v6;
      }
    }
    else if (v4)
    {
      uint64_t v7 = 1;
    }
    else
    {
      uint64_t v7 = 3;
    }
  }
  else
  {
    uint64_t v8 = *(NSObject **)(*(uint64_t (**)(void *, uint64_t))(*a1[6] + 16))(a1[6], a2);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)unsigned int v10 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "Unable to find model for AWD selection", v10, 2u);
    }
    uint64_t v7 = 0;
  }
  if (v12) {
    sub_10004D2C8(v12);
  }
  return v7;
}

void sub_10059E3E4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    sub_10004D2C8(a12);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10059E404(wis::MetricFactory *a1)
{
  unsigned int v1 = a1;
  SharedMetricFactory = (wis::MetricFactory *)wis::MetricFactory::getSharedMetricFactory(a1);
  uint64_t v3 = wis::MetricFactory::newMetricContainerWithIdentifier(SharedMetricFactory, v1);
  if (v3)
  {
    int v4 = (wis::MetricContainer *)v3;
    int v5 = sub_10001C8F4(8);
    uint64_t v7 = *v5;
    unsigned int v6 = (std::__shared_weak_count *)v5[1];
    if (v6) {
      atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    if (v7) {
      operator new();
    }
    if (v6) {
      sub_10004D2C8(v6);
    }
    wis::MetricContainer::~MetricContainer(v4);
    operator delete();
  }
  return 0;
}

void sub_10059E560(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  sub_100129880((wis::MetricContainer **)va, 0);
  _Unwind_Resume(a1);
}

uint64_t sub_10059E5E4(uint64_t result, int *a2)
{
  uint64_t v2 = *(void *)(result + 32);
  uint64_t v3 = *(void **)(v2 + 120);
  if (v3 != (void *)(v2 + 128))
  {
    int v5 = (wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(a2 + 4);
    do
    {
      int v6 = a2[7];
      uint64_t v7 = a2[6];
      if ((int)v7 >= v6)
      {
        if (v6 == a2[8])
        {
          wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve(v5, v6 + 1);
          int v6 = a2[7];
        }
        a2[7] = v6 + 1;
        operator new();
      }
      uint64_t v8 = *((void *)a2 + 2);
      a2[6] = v7 + 1;
      uint64_t v9 = *(void *)(v8 + 8 * v7);
      if (v9)
      {
        uint64_t result = NetworkListController::getAwdSelectionTypeForSlot_sync((void **)v2, *((unsigned int *)v3 + 8));
        if ((result - 1) >= 4) {
          int v10 = 0;
        }
        else {
          int v10 = result;
        }
        *(_DWORD *)(v9 + 28) |= 2u;
        *(_DWORD *)(v9 + 16) = v10;
      }
      uint64_t v11 = (void *)v3[1];
      if (v11)
      {
        do
        {
          unint64_t v12 = v11;
          uint64_t v11 = (void *)*v11;
        }
        while (v11);
      }
      else
      {
        do
        {
          unint64_t v12 = (void *)v3[2];
          BOOL v13 = *v12 == (void)v3;
          uint64_t v3 = v12;
        }
        while (!v13);
      }
      uint64_t v3 = v12;
    }
    while (v12 != (void *)(v2 + 128));
  }
  return result;
}

void sub_10059E70C()
{
}

void sub_10059E730(void ***a1)
{
  *a1 = (void **)off_1019E9978;
  sub_100110A40(a1 + 1, 0);

  PB::Base::~Base((PB::Base *)a1);
}

void sub_10059E788(void ***a1)
{
  *a1 = (void **)off_1019E9978;
  sub_100110A40(a1 + 1, 0);
  PB::Base::~Base((PB::Base *)a1);

  operator delete();
}

uint64_t sub_10059E7F4(uint64_t a1, PB::TextFormatter *this, char *a3)
{
  PB::TextFormatter::beginObject(this, a3);
  int v5 = *(const PB::Data **)(a1 + 8);
  if (v5) {
    PB::TextFormatter::format(this, "csn", v5);
  }
  char v6 = *(unsigned char *)(a1 + 24);
  if (v6)
  {
    PB::TextFormatter::format(this, "error", *(_DWORD *)(a1 + 16));
    char v6 = *(unsigned char *)(a1 + 24);
  }
  if ((v6 & 2) != 0) {
    PB::TextFormatter::format(this, "result", *(unsigned char *)(a1 + 20));
  }

  return PB::TextFormatter::endObject(this);
}

uint64_t sub_10059E888(uint64_t a1, PB::Reader *this)
{
  unint64_t v2 = *((void *)this + 1);
  unint64_t v3 = *((void *)this + 2);
  int v4 = *((unsigned __int8 *)this + 24);
  if (v2 < v3 && v4 == 0)
  {
    while (1)
    {
      uint64_t v8 = *(void *)this;
      if (v2 > 0xFFFFFFFFFFFFFFF5 || v2 + 10 > v3) {
        break;
      }
      char v9 = 0;
      unsigned int v10 = 0;
      unint64_t v11 = 0;
      while (1)
      {
        unint64_t v12 = v2 + 1;
        *((void *)this + 1) = v2 + 1;
        char v13 = *(unsigned char *)(v8 + v2);
        v11 |= (unint64_t)(v13 & 0x7F) << v9;
        if ((v13 & 0x80) == 0) {
          break;
        }
        v9 += 7;
        unint64_t v2 = v12;
        BOOL v14 = v10++ > 8;
        if (v14) {
          goto LABEL_19;
        }
      }
LABEL_20:
      unsigned __int8 v19 = v11 & 7;
      if ((v11 & 7) == 4)
      {
        int v4 = 0;
        return v4 == 0;
      }
      unint64_t v20 = v11 >> 3;
      if ((v11 >> 3) == 3)
      {
        *(unsigned char *)(a1 + 24) |= 1u;
        unint64_t v23 = *((void *)this + 1);
        unint64_t v24 = *((void *)this + 2);
        uint64_t v25 = *(void *)this;
        if (v23 > 0xFFFFFFFFFFFFFFF5 || v23 + 10 > v24)
        {
          char v35 = 0;
          unsigned int v36 = 0;
          uint64_t v28 = 0;
          if (v24 <= v23) {
            unint64_t v24 = *((void *)this + 1);
          }
          while (1)
          {
            if (v24 == v23)
            {
              LODWORD(v28) = 0;
              *((unsigned char *)this + 24) = 1;
              goto LABEL_52;
            }
            unint64_t v37 = v23 + 1;
            char v38 = *(unsigned char *)(v25 + v23);
            *((void *)this + 1) = v37;
            v28 |= (unint64_t)(v38 & 0x7F) << v35;
            if ((v38 & 0x80) == 0) {
              break;
            }
            v35 += 7;
            unint64_t v23 = v37;
            BOOL v14 = v36++ > 8;
            if (v14)
            {
LABEL_46:
              LODWORD(v28) = 0;
              goto LABEL_52;
            }
          }
          if (*((unsigned char *)this + 24)) {
            LODWORD(v28) = 0;
          }
        }
        else
        {
          char v26 = 0;
          unsigned int v27 = 0;
          uint64_t v28 = 0;
          while (1)
          {
            unint64_t v29 = v23 + 1;
            *((void *)this + 1) = v23 + 1;
            char v30 = *(unsigned char *)(v25 + v23);
            v28 |= (unint64_t)(v30 & 0x7F) << v26;
            if ((v30 & 0x80) == 0) {
              break;
            }
            v26 += 7;
            unint64_t v23 = v29;
            BOOL v14 = v27++ > 8;
            if (v14) {
              goto LABEL_46;
            }
          }
        }
LABEL_52:
        *(_DWORD *)(a1 + 16) = v28;
      }
      else if (v20 == 2)
      {
        *(unsigned char *)(a1 + 24) |= 2u;
        unint64_t v31 = *((void *)this + 1);
        if (v31 >= *((void *)this + 2))
        {
          BOOL v34 = 0;
          *((unsigned char *)this + 24) = 1;
        }
        else
        {
          unint64_t v32 = v31 + 1;
          int v33 = *(unsigned __int8 *)(*(void *)this + v31);
          *((void *)this + 1) = v32;
          BOOL v34 = v33 != 0;
        }
        *(unsigned char *)(a1 + 20) = v34;
      }
      else
      {
        if (v20 == 1) {
          operator new();
        }
LABEL_25:
        uint64_t result = PB::Reader::skip(this, v20, v19, 0);
        if (!result) {
          return result;
        }
      }
      unint64_t v2 = *((void *)this + 1);
      unint64_t v3 = *((void *)this + 2);
      int v4 = *((unsigned __int8 *)this + 24);
      if (v2 >= v3 || v4 != 0) {
        return v4 == 0;
      }
    }
    char v15 = 0;
    unsigned int v16 = 0;
    unint64_t v11 = 0;
    if (v2 > v3) {
      unint64_t v3 = v2;
    }
    while (v3 != v2)
    {
      unint64_t v17 = v2 + 1;
      char v18 = *(unsigned char *)(v8 + v2);
      *((void *)this + 1) = v17;
      v11 |= (unint64_t)(v18 & 0x7F) << v15;
      if ((v18 & 0x80) == 0) {
        goto LABEL_20;
      }
      v15 += 7;
      unint64_t v2 = v17;
      BOOL v14 = v16++ > 8;
      if (v14)
      {
LABEL_19:
        unsigned __int8 v19 = 0;
        LODWORD(v20) = 0;
        goto LABEL_25;
      }
    }
    int v4 = 1;
    *((unsigned char *)this + 24) = 1;
  }
  return v4 == 0;
}

uint64_t sub_10059EB68(uint64_t result, PB::Writer *this)
{
  uint64_t v3 = result;
  int v4 = *(const PB::Data **)(result + 8);
  if (v4) {
    uint64_t result = PB::Writer::write(this, v4, 1u);
  }
  char v5 = *(unsigned char *)(v3 + 24);
  if ((v5 & 2) != 0)
  {
    uint64_t result = PB::Writer::write(this, *(unsigned char *)(v3 + 20), 2u);
    char v5 = *(unsigned char *)(v3 + 24);
  }
  if (v5)
  {
    unsigned int v6 = *(_DWORD *)(v3 + 16);
    return PB::Writer::writeVarInt(this, v6, 3u);
  }
  return result;
}

void sub_10059EBE8(uint64_t a1@<X0>, NSObject **a2@<X1>, std::__shared_weak_count **a3@<X8>)
{
  unsigned int v6 = (std::__shared_weak_count *)operator new(0xA0uLL);
  v6->__shared_owners_ = 0;
  v6->__shared_weak_owners_ = 0;
  v6->__vftable = (std::__shared_weak_count_vtbl *)off_1019E9B00;
  uint64_t v7 = v6 + 1;
  sub_10059ECEC(&v6[1].__vftable, a1, a2);
  v6[1].__vftable = (std::__shared_weak_count_vtbl *)off_1019E9B50;
  shared_weak_owners = (std::__shared_weak_count *)v6[1].__shared_weak_owners_;
  if (!shared_weak_owners)
  {
    atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit(&v6->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    v6[1].__shared_owners_ = (uint64_t)v7;
    v6[1].__shared_weak_owners_ = (uint64_t)v6;
    goto LABEL_5;
  }
  if (shared_weak_owners->__shared_owners_ == -1)
  {
    atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit(&v6->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    v6[1].__shared_owners_ = (uint64_t)v7;
    v6[1].__shared_weak_owners_ = (uint64_t)v6;
    std::__shared_weak_count::__release_weak(shared_weak_owners);
LABEL_5:
    sub_10004D2C8(v6);
  }
  *a3 = v7;
  a3[1] = v6;
}

void sub_10059ECD4(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  operator delete(v3);
  _Unwind_Resume(a1);
}

void *sub_10059ECEC(void *a1, uint64_t a2, NSObject **a3)
{
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v22, kCtLoggingSystemName, "lazuli.settings");
  a1[1] = 0;
  a1[2] = 0;
  unsigned int v6 = *a3;
  a1[3] = *a3;
  if (v6) {
    dispatch_retain(v6);
  }
  a1[4] = 0;
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)&v20, &v22);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 5), (const ctu::OsLogLogger *)&v20);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)&v20);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v22);
  v21[0] = off_101999E18;
  v21[1] = sub_10059F0E4;
  v21[3] = v21;
  a1[6] = 0;
  if ((capabilities::ct::supportsGemini(v7) & 1) == 0) {
    operator new();
  }
  if (!a1[6]) {
    operator new();
  }
  sub_10008863C(v21);
  *a1 = off_1019E99C8;
  uint64_t v8 = *(Registry **)a2;
  a1[7] = *(void *)a2;
  add_explicit = *(uint64_t **)(a2 + 8);
  a1[8] = add_explicit;
  if (add_explicit)
  {
    add_explicit = (uint64_t *)atomic_fetch_add_explicit(add_explicit + 1, 1uLL, memory_order_relaxed);
    uint64_t v8 = (Registry *)a1[7];
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(add_explicit, v8);
  unint64_t v11 = ServiceMap;
  if (v12 < 0)
  {
    char v13 = (unsigned __int8 *)(v12 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v14 = 5381;
    do
    {
      uint64_t v12 = v14;
      unsigned int v15 = *v13++;
      uint64_t v14 = (33 * v14) ^ v15;
    }
    while (v15);
  }
  std::mutex::lock(ServiceMap);
  v22.var0 = (char *)v12;
  unsigned int v16 = sub_10004D37C(&v11[1].__m_.__sig, (unint64_t *)&v22);
  if (v16)
  {
    uint64_t v18 = v16[3];
    unint64_t v17 = (std::__shared_weak_count *)v16[4];
    if (v17) {
      atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
    }
  }
  else
  {
    uint64_t v18 = 0;
    unint64_t v17 = 0;
  }
  std::mutex::unlock(v11);
  a1[9] = v18;
  a1[10] = v17;
  if (v17)
  {
    atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v17);
  }
  a1[11] = a1 + 11;
  a1[12] = a1 + 11;
  a1[15] = 0;
  a1[16] = 0;
  a1[13] = 0;
  a1[14] = a1 + 15;
  return a1;
}

void sub_10059EFD4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  sub_10008863C((uint64_t *)va);
  operator delete();
}

const char *sub_10059F0E4(int a1)
{
  unsigned int v1 = "lazuli.settings.?";
  if (a1 == 2) {
    unsigned int v1 = "lazuli.settings.2";
  }
  if (a1 == 1) {
    return "lazuli.settings.1";
  }
  else {
    return v1;
  }
}

uint64_t sub_10059F110(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)std::string __p = 0u;
  long long v35 = 0u;
  sub_10059F61C(__p, a1, a2);
  int v4 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
  char v5 = v4;
  if (!BYTE8(v35))
  {
    unsigned __int8 v19 = *v4;
    if (!os_log_type_enabled(*v4, OS_LOG_TYPE_ERROR))
    {
      int v20 = 0;
      int v21 = 0;
      return v20 | (v21 << 8);
    }
    *(_WORD *)long long buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "No identifier for switch", buf, 2u);
    goto LABEL_32;
  }
  uint64_t v7 = *(Registry **)(a1 + 56);
  unsigned int v6 = (Registry **)(a1 + 56);
  ServiceMap = (std::mutex *)Registry::getServiceMap(v7);
  char v9 = ServiceMap;
  if (v10 < 0)
  {
    unint64_t v11 = (unsigned __int8 *)(v10 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v12 = 5381;
    do
    {
      uint64_t v10 = v12;
      unsigned int v13 = *v11++;
      uint64_t v12 = (33 * v12) ^ v13;
    }
    while (v13);
  }
  std::mutex::lock(ServiceMap);
  *(void *)long long buf = v10;
  uint64_t v14 = sub_10004D37C(&v9[1].__m_.__sig, (unint64_t *)buf);
  if (!v14)
  {
    uint64_t v16 = 0;
LABEL_13:
    std::mutex::unlock(v9);
    unsigned int v15 = 0;
    char v17 = 1;
    if (!v16)
    {
LABEL_8:
      uint64_t v18 = *v5;
      if (os_log_type_enabled(*v5, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "Could not get managed configuration", buf, 2u);
      }
LABEL_15:
      if ((v17 & 1) == 0) {
        sub_10004D2C8(v15);
      }
      uint64_t v32 = 0;
      int v33 = 0;
      Registry::getMobileHelper(&v32, *v6);
      if (v32)
      {
        if (MessageCenterModel::isMessagesInstalled(v6))
        {
          unint64_t v31 = 0;
          sub_10059F6B4(&v31);
          char v30 = 0;
          (*(void (**)(unsigned char *__return_ptr))(*(void *)v32 + 16))(buf);
          sub_1000057AC(&v30, (CFTypeRef *)buf);
          sub_1000577C4((const void **)buf);
          if (v30) {
            unint64_t v23 = sub_100084B4C;
          }
          else {
            unint64_t v23 = 0;
          }
          if (v23)
          {
            buf[0] = 0;
            ctu::cf::assign((ctu::cf *)buf, v30, v22);
            int v20 = buf[0];
            unint64_t v24 = *v5;
            if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v25 = "Enabled";
              if (!v20) {
                uint64_t v25 = "Disabled";
              }
              *(_DWORD *)long long buf = 138478083;
              *(void *)&uint8_t buf[4] = v31;
              __int16 v37 = 2080;
              char v38 = v25;
              _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "#I Retrieved switch state [%{private}@]: %s", buf, 0x16u);
            }
            int v21 = 1;
          }
          else
          {
            int v21 = 0;
            int v20 = 0;
          }
          sub_100062778((const void **)&v30);
          sub_1000558F4(&v31);
          goto LABEL_40;
        }
        uint64_t v28 = *v5;
        int v21 = 0;
        int v20 = 0;
        if (!os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
        {
LABEL_40:
          if (v33) {
            sub_10004D2C8(v33);
          }
          goto LABEL_42;
        }
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "#I Messages is not installed, RCS cannot be enabled.", buf, 2u);
      }
      else
      {
        unsigned int v27 = *v5;
        if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)long long buf = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_ERROR, "Failed to get MobileHelper", buf, 2u);
        }
      }
      int v21 = 0;
      int v20 = 0;
      goto LABEL_40;
    }
    goto LABEL_14;
  }
  uint64_t v16 = v14[3];
  unsigned int v15 = (std::__shared_weak_count *)v14[4];
  if (!v15) {
    goto LABEL_13;
  }
  atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v9);
  atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v15);
  char v17 = 0;
  if (!v16) {
    goto LABEL_8;
  }
LABEL_14:
  if ((*(uint64_t (**)(uint64_t))(*(void *)v16 + 80))(v16)) {
    goto LABEL_15;
  }
  char v26 = *v5;
  if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "#I Feature disabled by profile", buf, 2u);
  }
  if ((v17 & 1) == 0) {
    sub_10004D2C8(v15);
  }
LABEL_32:
  int v21 = 0;
  int v20 = 0;
LABEL_42:
  if (BYTE8(v35) && SBYTE7(v35) < 0) {
    operator delete(__p[0]);
  }
  return v20 | (v21 << 8);
}

void sub_10059F580(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, const void *a10, uint64_t a11, std::__shared_weak_count *a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, char a19, int a20,__int16 a21,char a22,char a23)
{
  if (a12) {
    sub_10004D2C8(a12);
  }
  if (a19)
  {
    if (a18 < 0) {
      operator delete(__p);
    }
  }
  _Unwind_Resume(a1);
}

_OWORD *sub_10059F61C(_OWORD *__dst, uint64_t a2, int a3)
{
  uint64_t v3 = __dst;
  uint64_t v6 = *(void *)(a2 + 120);
  uint64_t v4 = a2 + 120;
  uint64_t v5 = v6;
  if (!v6) {
    goto LABEL_11;
  }
  uint64_t v7 = v4;
  do
  {
    int v8 = *(_DWORD *)(v5 + 32);
    BOOL v9 = v8 < a3;
    if (v8 >= a3) {
      uint64_t v10 = (uint64_t *)v5;
    }
    else {
      uint64_t v10 = (uint64_t *)(v5 + 8);
    }
    if (!v9) {
      uint64_t v7 = v5;
    }
    uint64_t v5 = *v10;
  }
  while (*v10);
  if (v7 != v4 && *(_DWORD *)(v7 + 32) <= a3)
  {
    if (*(char *)(v7 + 63) < 0)
    {
      __dst = sub_10004FC84(__dst, *(void **)(v7 + 40), *(void *)(v7 + 48));
    }
    else
    {
      long long v12 = *(_OWORD *)(v7 + 40);
      *((void *)__dst + 2) = *(void *)(v7 + 56);
      *__dst = v12;
    }
    char v11 = 1;
  }
  else
  {
LABEL_11:
    char v11 = 0;
    *(unsigned char *)__dst = 0;
  }
  v3[24] = v11;
  return __dst;
}

void sub_10059F6B4(void *a1)
{
  std::operator+<char>();
  if (SHIBYTE(v4) < 0)
  {
    sub_10004FC84(__dst, v3[0], (unint64_t)v3[1]);
  }
  else
  {
    *(_OWORD *)__dst = *(_OWORD *)v3;
    uint64_t v7 = v4;
  }
  uint64_t v5 = 0;
  if (SHIBYTE(v7) < 0)
  {
    sub_10004FC84(__p, __dst[0], (unint64_t)__dst[1]);
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)__dst;
    uint64_t v9 = v7;
  }
  uint64_t v10 = 0;
  if (ctu::cf::convert_copy())
  {
    unint64_t v2 = v5;
    uint64_t v5 = v10;
    char v11 = v2;
    sub_1000558F4(&v11);
  }
  if (SHIBYTE(v9) < 0) {
    operator delete(__p[0]);
  }
  *a1 = v5;
  uint64_t v5 = 0;
  sub_1000558F4(&v5);
  if (SHIBYTE(v7) < 0) {
    operator delete(__dst[0]);
  }
  if (SHIBYTE(v4) < 0) {
    operator delete(v3[0]);
  }
}

void sub_10059F7C4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, const void *a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a14 < 0) {
    operator delete(a9);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_10059F818(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)std::string __p = 0u;
  long long v35 = 0u;
  sub_10059F61C(__p, a1, a2);
  uint64_t v4 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
  uint64_t v5 = v4;
  if (!BYTE8(v35))
  {
    unsigned __int8 v19 = *v4;
    if (!os_log_type_enabled(*v4, OS_LOG_TYPE_ERROR))
    {
      int v20 = 0;
      int v21 = 0;
      return v20 | (v21 << 8);
    }
    *(_WORD *)long long buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "No identifier for business messaging switch", buf, 2u);
    goto LABEL_32;
  }
  uint64_t v7 = *(Registry **)(a1 + 56);
  uint64_t v6 = (Registry **)(a1 + 56);
  ServiceMap = (std::mutex *)Registry::getServiceMap(v7);
  uint64_t v9 = ServiceMap;
  if (v10 < 0)
  {
    char v11 = (unsigned __int8 *)(v10 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v12 = 5381;
    do
    {
      uint64_t v10 = v12;
      unsigned int v13 = *v11++;
      uint64_t v12 = (33 * v12) ^ v13;
    }
    while (v13);
  }
  std::mutex::lock(ServiceMap);
  *(void *)long long buf = v10;
  uint64_t v14 = sub_10004D37C(&v9[1].__m_.__sig, (unint64_t *)buf);
  if (!v14)
  {
    uint64_t v16 = 0;
LABEL_13:
    std::mutex::unlock(v9);
    unsigned int v15 = 0;
    char v17 = 1;
    if (!v16)
    {
LABEL_8:
      uint64_t v18 = *v5;
      if (os_log_type_enabled(*v5, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "Could not get managed configuration", buf, 2u);
      }
LABEL_15:
      if ((v17 & 1) == 0) {
        sub_10004D2C8(v15);
      }
      uint64_t v32 = 0;
      int v33 = 0;
      Registry::getMobileHelper(&v32, *v6);
      if (v32)
      {
        if (MessageCenterModel::isMessagesInstalled(v6))
        {
          unint64_t v31 = 0;
          sub_10059FD24(&v31);
          char v30 = 0;
          (*(void (**)(unsigned char *__return_ptr))(*(void *)v32 + 16))(buf);
          sub_1000057AC(&v30, (CFTypeRef *)buf);
          sub_1000577C4((const void **)buf);
          if (v30) {
            unint64_t v23 = sub_100084B4C;
          }
          else {
            unint64_t v23 = 0;
          }
          if (v23)
          {
            buf[0] = 0;
            ctu::cf::assign((ctu::cf *)buf, v30, v22);
            int v20 = buf[0];
            unint64_t v24 = *v5;
            if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v25 = "Enabled";
              if (!v20) {
                uint64_t v25 = "Disabled";
              }
              *(_DWORD *)long long buf = 138478083;
              *(void *)&uint8_t buf[4] = v31;
              __int16 v37 = 2080;
              char v38 = v25;
              _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "#I Retrieved business messaging switch state [%{private}@]: %s", buf, 0x16u);
            }
            int v21 = 1;
          }
          else
          {
            int v21 = 0;
            int v20 = 0;
          }
          sub_100062778((const void **)&v30);
          sub_1000558F4(&v31);
          goto LABEL_40;
        }
        uint64_t v28 = *v5;
        int v21 = 0;
        int v20 = 0;
        if (!os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
        {
LABEL_40:
          if (v33) {
            sub_10004D2C8(v33);
          }
          goto LABEL_42;
        }
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "#I Messages is not installed, Business Messaging cannot be enabled.", buf, 2u);
      }
      else
      {
        unsigned int v27 = *v5;
        if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)long long buf = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_ERROR, "Failed to get MobileHelper", buf, 2u);
        }
      }
      int v21 = 0;
      int v20 = 0;
      goto LABEL_40;
    }
    goto LABEL_14;
  }
  uint64_t v16 = v14[3];
  unsigned int v15 = (std::__shared_weak_count *)v14[4];
  if (!v15) {
    goto LABEL_13;
  }
  atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v9);
  atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v15);
  char v17 = 0;
  if (!v16) {
    goto LABEL_8;
  }
LABEL_14:
  if ((*(uint64_t (**)(uint64_t))(*(void *)v16 + 80))(v16)) {
    goto LABEL_15;
  }
  char v26 = *v5;
  if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "#I Business messaging disabled by profile", buf, 2u);
  }
  if ((v17 & 1) == 0) {
    sub_10004D2C8(v15);
  }
LABEL_32:
  int v21 = 0;
  int v20 = 0;
LABEL_42:
  if (BYTE8(v35) && SBYTE7(v35) < 0) {
    operator delete(__p[0]);
  }
  return v20 | (v21 << 8);
}

void sub_10059FC88(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, const void *a10, uint64_t a11, std::__shared_weak_count *a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, char a19, int a20,__int16 a21,char a22,char a23)
{
  if (a12) {
    sub_10004D2C8(a12);
  }
  if (a19)
  {
    if (a18 < 0) {
      operator delete(__p);
    }
  }
  _Unwind_Resume(a1);
}

void sub_10059FD24(void *a1)
{
  std::operator+<char>();
  if (SHIBYTE(v4) < 0)
  {
    sub_10004FC84(__dst, v3[0], (unint64_t)v3[1]);
  }
  else
  {
    *(_OWORD *)__dst = *(_OWORD *)v3;
    uint64_t v7 = v4;
  }
  uint64_t v5 = 0;
  if (SHIBYTE(v7) < 0)
  {
    sub_10004FC84(__p, __dst[0], (unint64_t)__dst[1]);
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)__dst;
    uint64_t v9 = v7;
  }
  uint64_t v10 = 0;
  if (ctu::cf::convert_copy())
  {
    unint64_t v2 = v5;
    uint64_t v5 = v10;
    char v11 = v2;
    sub_1000558F4(&v11);
  }
  if (SHIBYTE(v9) < 0) {
    operator delete(__p[0]);
  }
  *a1 = v5;
  uint64_t v5 = 0;
  sub_1000558F4(&v5);
  if (SHIBYTE(v7) < 0) {
    operator delete(__dst[0]);
  }
  if (SHIBYTE(v4) < 0) {
    operator delete(v3[0]);
  }
}

void sub_10059FE34(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, const void *a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a14 < 0) {
    operator delete(a9);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_10059FE88(uint64_t a1, uint64_t a2, int a3, int a4)
{
  if ((a4 & 0xFFFFFFFE) != 2) {
    goto LABEL_41;
  }
  int v8 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
  *(_OWORD *)std::string __p = 0u;
  long long v35 = 0u;
  sub_10059F61C(__p, a1, a2);
  if (!BYTE8(v35))
  {
    unsigned __int8 v19 = *v8;
    if (!os_log_type_enabled(v19, OS_LOG_TYPE_ERROR)) {
      return 0;
    }
    *(_WORD *)long long buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Cannot save switch state because identifier is missing", buf, 2u);
    int v14 = 1;
    goto LABEL_36;
  }
  uint64_t v32 = 0;
  int v33 = 0;
  Registry::getMobileHelper(&v32, *(Registry **)(a1 + 56));
  if (!v32)
  {
    int v20 = *v8;
    if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, "Failed to get MobileHelper", buf, 2u);
    }
    int v14 = 1;
    goto LABEL_34;
  }
  unint64_t v31 = 0;
  sub_10059F6B4(&v31);
  uint64_t v9 = *v8;
  BOOL v10 = os_log_type_enabled(*v8, OS_LOG_TYPE_DEFAULT);
  if (a4 == 2)
  {
    if (v10)
    {
      char v11 = "kUnknown";
      if (a3 == 1) {
        char v11 = "kDisabled";
      }
      if (a3 == 2) {
        char v11 = "kEnabled";
      }
      *(_DWORD *)long long buf = 138478083;
      __int16 v37 = v31;
      __int16 v38 = 2080;
      uint64_t v39 = v11;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I Storing switch state [%{private}@]: %s", buf, 0x16u);
    }
    char v12 = (*(uint64_t (**)(void))(*(void *)v32 + 24))();
    unsigned int v13 = *v8;
    if (v12)
    {
      int v14 = 0;
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
      {
        unsigned int v15 = "kUnknown";
        if (a3 == 1) {
          unsigned int v15 = "kDisabled";
        }
        if (a3 == 2) {
          unsigned int v15 = "kEnabled";
        }
        *(_DWORD *)long long buf = 138478083;
        __int16 v37 = v31;
        __int16 v38 = 2080;
        uint64_t v39 = v15;
        uint64_t v16 = "#I Successfully stored switch state [%{private}@]: %s";
        char v17 = v13;
        uint32_t v18 = 22;
        goto LABEL_28;
      }
      goto LABEL_33;
    }
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      CFBooleanRef v22 = "Failed to store switch state";
LABEL_53:
      _os_log_error_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, v22, buf, 2u);
      goto LABEL_32;
    }
    goto LABEL_32;
  }
  if (v10)
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I Obliterating switch state", buf, 2u);
  }
  char v21 = (*(uint64_t (**)(uint64_t, void, const void *, void))(*(void *)v32 + 24))(v32, kCommCenterSharedSettingsBundleId, v31, 0);
  unsigned int v13 = *v8;
  if ((v21 & 1) == 0)
  {
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      CFBooleanRef v22 = "Failed to obliterate switch state";
      goto LABEL_53;
    }
LABEL_32:
    int v14 = 1;
    goto LABEL_33;
  }
  int v14 = 0;
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    uint64_t v16 = "#I Successfully obliterated switch state";
    char v17 = v13;
    uint32_t v18 = 2;
LABEL_28:
    _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, v16, buf, v18);
    int v14 = 0;
  }
LABEL_33:
  sub_1000558F4(&v31);
LABEL_34:
  if (v33) {
    sub_10004D2C8(v33);
  }
LABEL_36:
  if (BYTE8(v35) && SBYTE7(v35) < 0) {
    operator delete(__p[0]);
  }
  if (v14) {
    return 0;
  }
LABEL_41:
  uint64_t v24 = a1 + 88;
  uint64_t v25 = *(uint64_t **)(a1 + 96);
  if (v25 != (uint64_t *)v24)
  {
    uint64_t v26 = (a3 == 2) | 0x100;
    do
    {
      unsigned int v27 = (std::__shared_weak_count *)v25[3];
      if (v27 && (uint64_t v28 = std::__shared_weak_count::lock(v27)) != 0)
      {
        unint64_t v29 = v28;
        uint64_t v30 = v25[2];
        if (v30)
        {
          (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v30 + 16))(v30, a2, v26);
          sub_10004D2C8(v29);
          uint64_t v25 = (uint64_t *)v25[1];
        }
        else
        {
          uint64_t v25 = (uint64_t *)sub_1005A13E0(v24, v25);
          sub_10004D2C8(v29);
        }
      }
      else
      {
        uint64_t v25 = (uint64_t *)sub_1005A13E0(v24, v25);
      }
    }
    while (v25 != (uint64_t *)v24);
  }
  return 1;
}

void sub_1005A0368(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, const void *a10, uint64_t a11, std::__shared_weak_count *a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, char a19)
{
  if (a12) {
    sub_10004D2C8(a12);
  }
  if (a19)
  {
    if (a18 < 0) {
      operator delete(__p);
    }
  }
  _Unwind_Resume(a1);
}

uint64_t sub_1005A03C8(uint64_t a1, uint64_t a2, int a3, int a4)
{
  if ((a4 & 0xFFFFFFFE) != 2) {
    goto LABEL_41;
  }
  int v8 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
  *(_OWORD *)std::string __p = 0u;
  long long v35 = 0u;
  sub_10059F61C(__p, a1, a2);
  if (!BYTE8(v35))
  {
    unsigned __int8 v19 = *v8;
    if (!os_log_type_enabled(v19, OS_LOG_TYPE_ERROR)) {
      return 0;
    }
    *(_WORD *)long long buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Cannot save business messaging switch state because identifier is missing", buf, 2u);
    int v14 = 1;
    goto LABEL_36;
  }
  uint64_t v32 = 0;
  int v33 = 0;
  Registry::getMobileHelper(&v32, *(Registry **)(a1 + 56));
  if (!v32)
  {
    int v20 = *v8;
    if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, "Failed to get MobileHelper", buf, 2u);
    }
    int v14 = 1;
    goto LABEL_34;
  }
  unint64_t v31 = 0;
  sub_10059FD24(&v31);
  uint64_t v9 = *v8;
  BOOL v10 = os_log_type_enabled(*v8, OS_LOG_TYPE_DEFAULT);
  if (a4 == 2)
  {
    if (v10)
    {
      char v11 = "kUnknown";
      if (a3 == 1) {
        char v11 = "kDisabled";
      }
      if (a3 == 2) {
        char v11 = "kEnabled";
      }
      *(_DWORD *)long long buf = 138478083;
      __int16 v37 = v31;
      __int16 v38 = 2080;
      uint64_t v39 = v11;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I Storing business messaging switch state [%{private}@]: %s", buf, 0x16u);
    }
    char v12 = (*(uint64_t (**)(void))(*(void *)v32 + 24))();
    unsigned int v13 = *v8;
    if (v12)
    {
      int v14 = 0;
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
      {
        unsigned int v15 = "kUnknown";
        if (a3 == 1) {
          unsigned int v15 = "kDisabled";
        }
        if (a3 == 2) {
          unsigned int v15 = "kEnabled";
        }
        *(_DWORD *)long long buf = 138478083;
        __int16 v37 = v31;
        __int16 v38 = 2080;
        uint64_t v39 = v15;
        uint64_t v16 = "#I Successfully stored business messaging switch state [%{private}@]: %s";
        char v17 = v13;
        uint32_t v18 = 22;
        goto LABEL_28;
      }
      goto LABEL_33;
    }
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      CFBooleanRef v22 = "Failed to store business messaging switch state";
LABEL_53:
      _os_log_error_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, v22, buf, 2u);
      goto LABEL_32;
    }
    goto LABEL_32;
  }
  if (v10)
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I Obliterating business messaging switch state", buf, 2u);
  }
  char v21 = (*(uint64_t (**)(uint64_t, void, const void *, void))(*(void *)v32 + 24))(v32, kCommCenterSharedSettingsBundleId, v31, 0);
  unsigned int v13 = *v8;
  if ((v21 & 1) == 0)
  {
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      CFBooleanRef v22 = "Failed to obliterate business messaging switch state";
      goto LABEL_53;
    }
LABEL_32:
    int v14 = 1;
    goto LABEL_33;
  }
  int v14 = 0;
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    uint64_t v16 = "#I Successfully obliterated business messaging switch state";
    char v17 = v13;
    uint32_t v18 = 2;
LABEL_28:
    _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, v16, buf, v18);
    int v14 = 0;
  }
LABEL_33:
  sub_1000558F4(&v31);
LABEL_34:
  if (v33) {
    sub_10004D2C8(v33);
  }
LABEL_36:
  if (BYTE8(v35) && SBYTE7(v35) < 0) {
    operator delete(__p[0]);
  }
  if (v14) {
    return 0;
  }
LABEL_41:
  uint64_t v24 = a1 + 88;
  uint64_t v25 = *(uint64_t **)(a1 + 96);
  if (v25 != (uint64_t *)v24)
  {
    uint64_t v26 = (a3 == 2) | 0x100;
    do
    {
      unsigned int v27 = (std::__shared_weak_count *)v25[3];
      if (v27 && (uint64_t v28 = std::__shared_weak_count::lock(v27)) != 0)
      {
        unint64_t v29 = v28;
        uint64_t v30 = v25[2];
        if (v30)
        {
          (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v30 + 24))(v30, a2, v26);
          sub_10004D2C8(v29);
          uint64_t v25 = (uint64_t *)v25[1];
        }
        else
        {
          uint64_t v25 = (uint64_t *)sub_1005A13E0(v24, v25);
          sub_10004D2C8(v29);
        }
      }
      else
      {
        uint64_t v25 = (uint64_t *)sub_1005A13E0(v24, v25);
      }
    }
    while (v25 != (uint64_t *)v24);
  }
  return 1;
}

void sub_1005A08A8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, const void *a10, uint64_t a11, std::__shared_weak_count *a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, char a19)
{
  if (a12) {
    sub_10004D2C8(a12);
  }
  if (a19)
  {
    if (a18 < 0) {
      operator delete(__p);
    }
  }
  _Unwind_Resume(a1);
}

void sub_1005A0908(uint64_t a1, uint64_t a2, std::string *a3)
{
  unsigned int v22 = a2;
  *(_OWORD *)std::string __p = 0u;
  long long v21 = 0u;
  sub_10059F61C(__p, a1, a2);
  if ((sub_1005A0BB8((unsigned __int8 *)__p, (unsigned __int8 *)a3) & 1) == 0)
  {
    uint64_t v6 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
    int v7 = a3[1].__r_.__value_.__s.__data_[0];
    int v8 = *v6;
    BOOL v9 = os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT);
    if (v7)
    {
      if (v9)
      {
        if ((a3->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          BOOL v10 = a3;
        }
        else {
          BOOL v10 = (std::string *)a3->__r_.__value_.__r.__words[0];
        }
        *(_DWORD *)long long buf = 136380675;
        *(void *)&uint8_t buf[4] = v10;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Updating switch identifier to: [%{private}s]", buf, 0xCu);
      }
      *(void *)long long buf = &v22;
      char v11 = sub_10008CC40((uint64_t **)(a1 + 112), (int *)&v22, (uint64_t)&unk_10144E20E, (_DWORD **)buf);
      std::string::operator=((std::string *)(v11 + 5), a3);
    }
    else
    {
      if (v9)
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Clearing out switch identifier", buf, 2u);
      }
      sub_1003DE708(a1 + 112, (int *)&v22);
    }
    unsigned __int16 v12 = (*(uint64_t (**)(uint64_t, void))(*(void *)a1 + 16))(a1, v22);
    uint64_t v13 = a1 + 88;
    int v14 = *(uint64_t **)(a1 + 96);
    if (v14 != (uint64_t *)v13)
    {
      uint64_t v15 = v12;
      do
      {
        uint64_t v16 = (std::__shared_weak_count *)v14[3];
        if (v16 && (char v17 = std::__shared_weak_count::lock(v16)) != 0)
        {
          uint32_t v18 = v17;
          uint64_t v19 = v14[2];
          if (v19)
          {
            (*(void (**)(uint64_t, void, uint64_t))(*(void *)v19 + 16))(v19, v22, v15);
            sub_10004D2C8(v18);
            int v14 = (uint64_t *)v14[1];
          }
          else
          {
            int v14 = (uint64_t *)sub_1005A13E0(v13, v14);
            sub_10004D2C8(v18);
          }
        }
        else
        {
          int v14 = (uint64_t *)sub_1005A13E0(v13, v14);
        }
      }
      while (v14 != (uint64_t *)v13);
    }
  }
  if (BYTE8(v21))
  {
    if (SBYTE7(v21) < 0) {
      operator delete(__p[0]);
    }
  }
}

void sub_1005A0B78(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15)
{
  if (a15)
  {
    if (a14 < 0) {
      operator delete(__p);
    }
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1005A0BB8(unsigned __int8 *a1, unsigned __int8 *a2)
{
  if (a1[24]) {
    BOOL v2 = a2[24] == 0;
  }
  else {
    BOOL v2 = 1;
  }
  if (v2) {
    return (a1[24] != 0) == (a2[24] != 0);
  }
  uint64_t v4 = a1[23];
  if ((v4 & 0x80u) == 0) {
    uint64_t v5 = a1[23];
  }
  else {
    uint64_t v5 = *((void *)a1 + 1);
  }
  uint64_t v6 = a2[23];
  int v7 = (char)v6;
  if ((v6 & 0x80u) != 0) {
    uint64_t v6 = *((void *)a2 + 1);
  }
  if (v5 != v6) {
    return 0;
  }
  if (v7 < 0) {
    a2 = *(unsigned __int8 **)a2;
  }
  if ((v4 & 0x80) != 0) {
    return memcmp(*(const void **)a1, a2, *((void *)a1 + 1)) == 0;
  }
  if (!a1[23]) {
    return 1;
  }
  uint64_t v8 = v4 - 1;
  do
  {
    int v10 = *a1++;
    int v9 = v10;
    int v12 = *a2++;
    int v11 = v12;
    BOOL v14 = v8-- != 0;
    BOOL v2 = v9 == v11;
    BOOL v3 = v9 == v11;
  }
  while (v2 && v14);
  return v3;
}

BOOL sub_1005A0C8C(uint64_t a1)
{
  BOOL v2 = (os_log_t *)(*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
  uint64_t v3 = sub_100562D60(a1 + 72);
  os_log_t v4 = *v2;
  BOOL v5 = os_log_type_enabled(*v2, OS_LOG_TYPE_DEFAULT);
  if ((_BYTE)v3)
  {
    if (v5)
    {
      LOWORD(v12) = 0;
      uint64_t v6 = "#I Feature is supported";
      int v7 = v4;
      uint32_t v8 = 2;
LABEL_11:
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, v6, (uint8_t *)&v12, v8);
    }
  }
  else if (v5)
  {
    int v9 = "kInvalid";
    if (HIDWORD(v3) == 1) {
      int v9 = "kBundle";
    }
    if (HIDWORD(v3) == 2) {
      int v10 = "kBundleMissing";
    }
    else {
      int v10 = v9;
    }
    int v12 = 136446210;
    uint64_t v13 = v10;
    uint64_t v6 = "#I Feature disabled, reason: %{public}s";
    int v7 = v4;
    uint32_t v8 = 12;
    goto LABEL_11;
  }
  return v3 != 0;
}

BOOL sub_1005A0DD8(uint64_t a1)
{
  return sub_100562E28(a1 + 72);
}

BOOL sub_1005A0DE0(uint64_t a1)
{
  BOOL v2 = (os_log_t *)(*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
  uint64_t v3 = sub_100562EE8(a1 + 72);
  os_log_t v4 = *v2;
  BOOL v5 = os_log_type_enabled(*v2, OS_LOG_TYPE_DEFAULT);
  if ((_BYTE)v3)
  {
    if (v5)
    {
      LOWORD(v12) = 0;
      uint64_t v6 = "#I Business messaging is supported";
      int v7 = v4;
      uint32_t v8 = 2;
LABEL_11:
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, v6, (uint8_t *)&v12, v8);
    }
  }
  else if (v5)
  {
    int v9 = "kInvalid";
    if (HIDWORD(v3) == 1) {
      int v9 = "kBundle";
    }
    if (HIDWORD(v3) == 2) {
      int v10 = "kBundleMissing";
    }
    else {
      int v10 = v9;
    }
    int v12 = 136446210;
    uint64_t v13 = v10;
    uint64_t v6 = "#I Business messaging disabled, reason: %{public}s";
    int v7 = v4;
    uint32_t v8 = 12;
    goto LABEL_11;
  }
  return v3 != 0;
}

BOOL sub_1005A0F2C(uint64_t a1)
{
  return sub_100562FB0(a1 + 72);
}

void *sub_1005A0F34(uint64_t a1, uint64_t *a2)
{
  uint64_t v4 = *a2;
  uint64_t v3 = a2[1];
  uint64_t result = operator new(0x20uLL);
  result[2] = v4;
  result[3] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  uint64_t v7 = *(void *)(a1 + 88);
  uint64_t v6 = (void *)(a1 + 88);
  void *result = v7;
  result[1] = v6;
  *(void *)(v7 + 8) = result;
  void *v6 = result;
  ++v6[2];
  return result;
}

uint64_t sub_1005A0F98(uint64_t a1)
{
  *(void *)a1 = off_1019E99C8;
  sub_1000886C0(a1 + 112, *(char **)(a1 + 120));
  sub_1005A1120((uint64_t *)(a1 + 88));
  BOOL v2 = *(std::__shared_weak_count **)(a1 + 80);
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 64);
  if (v3) {
    sub_10004D2C8(v3);
  }
  LazuliFeatureSettingsModelInterface::~LazuliFeatureSettingsModelInterface((LazuliFeatureSettingsModelInterface *)a1);
  uint64_t v4 = *(void *)(a1 + 48);
  *(void *)(a1 + 48) = 0;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 40));
  sub_100087E88((void *)(a1 + 8));
  return a1;
}

void sub_1005A104C(uint64_t a1)
{
  *(void *)a1 = off_1019E99C8;
  sub_1000886C0(a1 + 112, *(char **)(a1 + 120));
  sub_1005A1120((uint64_t *)(a1 + 88));
  BOOL v2 = *(std::__shared_weak_count **)(a1 + 80);
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 64);
  if (v3) {
    sub_10004D2C8(v3);
  }
  LazuliFeatureSettingsModelInterface::~LazuliFeatureSettingsModelInterface((LazuliFeatureSettingsModelInterface *)a1);
  uint64_t v4 = *(void *)(a1 + 48);
  *(void *)(a1 + 48) = 0;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 40));
  sub_100087E88((void *)(a1 + 8));

  operator delete();
}

void sub_1005A1120(uint64_t *a1)
{
  if (a1[2])
  {
    uint64_t v2 = *a1;
    uint64_t v3 = (uint64_t *)a1[1];
    uint64_t v4 = *v3;
    *(void *)(v4 + 8) = *(void *)(*a1 + 8);
    **(void **)(v2 + 8) = v4;
    a1[2] = 0;
    if (v3 != a1)
    {
      do
      {
        BOOL v5 = (uint64_t *)v3[1];
        uint64_t v6 = (std::__shared_weak_count *)v3[3];
        if (v6) {
          std::__shared_weak_count::__release_weak(v6);
        }
        operator delete(v3);
        uint64_t v3 = v5;
      }
      while (v5 != a1);
    }
  }
}

void sub_1005A1198(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1019E9B00;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1005A11B8(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1019E9B00;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_1005A120C(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

uint64_t sub_1005A1234(uint64_t a1)
{
  *(void *)a1 = off_1019E99C8;
  sub_1000886C0(a1 + 112, *(char **)(a1 + 120));
  sub_1005A1120((uint64_t *)(a1 + 88));
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 80);
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 64);
  if (v3) {
    sub_10004D2C8(v3);
  }
  LazuliFeatureSettingsModelInterface::~LazuliFeatureSettingsModelInterface((LazuliFeatureSettingsModelInterface *)a1);
  uint64_t v4 = *(void *)(a1 + 48);
  *(void *)(a1 + 48) = 0;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 40));
  sub_100087E88((void *)(a1 + 8));
  return a1;
}

void sub_1005A12E8(uint64_t a1)
{
  *(void *)a1 = off_1019E99C8;
  sub_1000886C0(a1 + 112, *(char **)(a1 + 120));
  sub_1005A1120((uint64_t *)(a1 + 88));
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 80);
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 64);
  if (v3) {
    sub_10004D2C8(v3);
  }
  LazuliFeatureSettingsModelInterface::~LazuliFeatureSettingsModelInterface((LazuliFeatureSettingsModelInterface *)a1);
  uint64_t v4 = *(void *)(a1 + 48);
  *(void *)(a1 + 48) = 0;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 40));
  sub_100087E88((void *)(a1 + 8));

  operator delete();
}

void sub_1005A13C0()
{
}

uint64_t sub_1005A13D4(uint64_t a1)
{
  return *(void *)(a1 + 8) + 40;
}

uint64_t sub_1005A13E0(uint64_t a1, uint64_t *__p)
{
  uint64_t v3 = *__p;
  uint64_t v4 = __p[1];
  *(void *)(v3 + 8) = v4;
  *(void *)__p[1] = v3;
  --*(void *)(a1 + 16);
  BOOL v5 = (std::__shared_weak_count *)__p[3];
  if (v5) {
    std::__shared_weak_count::__release_weak(v5);
  }
  operator delete(__p);
  return v4;
}

void STK_Controller::getMenu(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t v3 = (void *)(a1 + 8);
  v4[4] = a1;
  int v5 = a2;
  sub_1005A533C((uint64_t)&v6, a3);
  v4[0] = 0;
  v4[1] = 0;
  sub_10003E168(v4, v3);
  operator new();
}

void sub_1005A157C(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

void STK_Controller::getMainMenu(uint64_t a1@<X0>, int a2@<W1>, uint64_t a3@<X8>)
{
  int v6 = a2;
  v5[0] = a1;
  v5[1] = &v6;
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 0x40000000;
  _OWORD v7[2] = sub_1005A54E4;
  double v7[3] = &unk_1019E9D18;
  _OWORD v7[4] = a1 + 8;
  v7[5] = v5;
  uint32_t v8 = v7;
  uint64_t v4 = a1 + 24;
  uint64_t v3 = *(NSObject **)(a1 + 24);
  if (*(void *)(v4 + 8))
  {
    *(void *)(a3 + 48) = 0;
    *(_OWORD *)(a3 + 16) = 0u;
    *(_OWORD *)(a3 + 32) = 0u;
    *(_OWORD *)a3 = 0u;
    block = _NSConcreteStackBlock;
    uint64_t v10 = 0x40000000;
    int v11 = sub_1005A561C;
    int v12 = &unk_1019E9D58;
    uint64_t v13 = a3;
    BOOL v14 = &v8;
    dispatch_async_and_wait(v3, &block);
  }
  else
  {
    *(void *)(a3 + 48) = 0;
    *(_OWORD *)(a3 + 16) = 0u;
    *(_OWORD *)(a3 + 32) = 0u;
    *(_OWORD *)a3 = 0u;
    block = _NSConcreteStackBlock;
    uint64_t v10 = 0x40000000;
    int v11 = sub_1005A54F8;
    int v12 = &unk_1019E9D38;
    uint64_t v13 = a3;
    BOOL v14 = &v8;
    dispatch_sync(v3, &block);
  }
}

void sub_1005A16CC(std::string *a1, uint64_t a2, uint64_t a3)
{
  int v3 = a3;
  int v6 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(a2 + 48) + 16))(*(void *)(a2 + 48), a3);
  uint64_t v19 = 0;
  int v20 = 0;
  STK_Controller::getStateModel_sync(a2, v3, &v19);
  if (v19)
  {
    long long v18 = 0u;
    long long v16 = 0u;
    memset(v17, 0, sizeof(v17));
    *(_OWORD *)BOOL v14 = 0u;
    long long v15 = 0u;
    (*(void (**)(uint8_t *__return_ptr))(*(void *)v19 + 56))(v14);
    if (BYTE8(v18))
    {
      if (STK_Controller::shouldAllowSTK_sync(a2, v3))
      {
        memset(v13, 0, sizeof(v13));
        std::string::operator=(v13, (const std::string *)((char *)v17 + 8));
        v13[1].__r_.__value_.__s.__data_[8] = DWORD2(v15) == 1;
        v13[1].__r_.__value_.__s.__data_[9] = DWORD1(v15) == 1;
        v13[1].__r_.__value_.__r.__words[2] = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*((void *)&v16 + 1) - v16) >> 3);
        uint64_t v7 = *v6;
        if (os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Returning values for Get Setup Menu", buf, 2u);
          uint64_t v7 = *v6;
        }
        if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
        {
          uint32_t v8 = v13;
          if ((v13[0].__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
            uint32_t v8 = (std::string *)v13[0].__r_.__value_.__r.__words[0];
          }
          *(_DWORD *)long long buf = 136315138;
          unsigned int v22 = v8;
          _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Title: '%s'", buf, 0xCu);
          uint64_t v7 = *v6;
        }
        if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
        {
          int v9 = "true";
          if (v13[1].__r_.__value_.__s.__data_[8]) {
            uint64_t v10 = "true";
          }
          else {
            uint64_t v10 = "false";
          }
          if (!v13[1].__r_.__value_.__s.__data_[9]) {
            int v9 = "false";
          }
          *(_DWORD *)long long buf = 136315394;
          unsigned int v22 = (std::string *)v10;
          __int16 v23 = 2080;
          uint64_t v24 = v9;
          _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Soft Key Selection: %s, Help Available: %s", buf, 0x16u);
          uint64_t v7 = *v6;
        }
        if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)long long buf = 134217984;
          unsigned int v22 = (std::string *)v13[1].__r_.__value_.__r.__words[2];
          _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Menu size: %zu", buf, 0xCu);
        }
        subscriber::simSlotAsInstance();
        WISPostSimpleMetricWithUnsignedInteger();
        *a1 = v13[0];
        a1[1] = v13[1];
        a1[2].__r_.__value_.__s.__data_[0] = 1;
        goto LABEL_26;
      }
    }
    else
    {
      int v12 = *v6;
      if (os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(v13[0].__r_.__value_.__l.__data_) = 0;
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I Setup Menu is invalid", (uint8_t *)v13, 2u);
      }
    }
    a1->__r_.__value_.__s.__data_[0] = 0;
    a1[2].__r_.__value_.__s.__data_[0] = 0;
LABEL_26:
    if (BYTE8(v18)) {
      SetupMenu::~SetupMenu((SetupMenu *)v14);
    }
    goto LABEL_28;
  }
  int v11 = *v6;
  if (os_log_type_enabled(*v6, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)BOOL v14 = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "Could not find state model when getting setup menu", v14, 2u);
  }
  a1->__r_.__value_.__s.__data_[0] = 0;
  a1[2].__r_.__value_.__s.__data_[0] = 0;
LABEL_28:
  if (v20) {
    sub_10004D2C8(v20);
  }
}

void sub_1005A1A8C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29)
{
  if (a29) {
    SetupMenu::~SetupMenu((SetupMenu *)&a18);
  }
  unint64_t v31 = *(std::__shared_weak_count **)(v29 - 104);
  if (v31) {
    sub_10004D2C8(v31);
  }
  _Unwind_Resume(exception_object);
}

BOOL STK_Controller::getMenuItem(uint64_t a1, int a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v12 = a3;
  int v13 = a2;
  v11[0] = a1;
  v11[1] = &v13;
  v11[2] = &v12;
  v11[3] = a4;
  void v11[4] = a5;
  v11[5] = a6;
  v11[6] = a7;
  v11[7] = a8;
  v14[0] = _NSConcreteStackBlock;
  v14[1] = 0x40000000;
  void v14[2] = sub_1005A5680;
  uint64_t v14[3] = &unk_1019E9D78;
  v14[4] = a1 + 8;
  v14[5] = v11;
  long long v15 = v14;
  uint64_t v9 = a1 + 24;
  uint32_t v8 = *(NSObject **)(a1 + 24);
  if (*(void *)(v9 + 8))
  {
    char v22 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v17 = 0x40000000;
    long long v18 = sub_10005ADD4;
    uint64_t v19 = &unk_1019E9DB8;
    int v20 = &v22;
    long long v21 = &v15;
    dispatch_async_and_wait(v8, &block);
  }
  else
  {
    char v22 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v17 = 0x40000000;
    long long v18 = sub_10005A070;
    uint64_t v19 = &unk_1019E9D98;
    int v20 = &v22;
    long long v21 = &v15;
    dispatch_sync(v8, &block);
  }
  return v22 != 0;
}

BOOL STK_Controller::getSelection(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  v13[0] = _NSConcreteStackBlock;
  v13[1] = 0x40000000;
  std::string v13[2] = sub_1005A1DB0;
  v13[3] = &unk_1019E9C08;
  int v14 = a2;
  _OWORD v13[4] = a1;
  v13[5] = a3;
  v13[6] = a4;
  unsigned char v13[7] = a5;
  v13[8] = a6;
  v13[9] = a7;
  v13[10] = a8;
  v13[11] = a9;
  v13[12] = a10;
  long long v15 = v13;
  v16[0] = _NSConcreteStackBlock;
  v16[1] = 0x40000000;
  _OWORD v16[2] = sub_1005A5AC0;
  v16[3] = &unk_1019E9DD8;
  void v16[4] = a1 + 8;
  v16[5] = &v15;
  uint64_t v17 = v16;
  uint64_t v11 = a1 + 24;
  uint64_t v10 = *(NSObject **)(a1 + 24);
  if (*(void *)(v11 + 8))
  {
    char v24 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v19 = 0x40000000;
    int v20 = sub_10005ADD4;
    long long v21 = &unk_1019E9DB8;
    char v22 = &v24;
    __int16 v23 = &v17;
    dispatch_async_and_wait(v10, &block);
  }
  else
  {
    char v24 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v19 = 0x40000000;
    int v20 = sub_10005A070;
    long long v21 = &unk_1019E9D98;
    char v22 = &v24;
    __int16 v23 = &v17;
    dispatch_sync(v10, &block);
  }
  return v24 != 0;
}

uint64_t sub_1005A1DB0(uint64_t a1)
{
  uint64_t v1 = *(unsigned int *)(a1 + 104);
  uint64_t v2 = *(void *)(a1 + 32);
  int v3 = *(BOOL **)(a1 + 40);
  uint64_t v4 = *(void *)(a1 + 48);
  int v5 = *(unsigned char **)(a1 + 56);
  int v6 = *(int **)(a1 + 64);
  uint64_t v7 = *(BOOL **)(a1 + 88);
  uint64_t v29 = *(BOOL **)(a1 + 72);
  uint64_t v30 = *(BOOL **)(a1 + 80);
  uint32_t v8 = *(BOOL **)(a1 + 96);
  uint64_t v9 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), v1);
  uint64_t v35 = 0;
  unsigned int v36 = 0;
  STK_Controller::getStateModel_sync(v2, v1, &v35);
  uint64_t v10 = v35;
  if (!v35)
  {
    long long v15 = *v9;
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "Could not find state model when getting selection", buf, 2u);
    }
    goto LABEL_8;
  }
  if ((STK_Controller::validateState(v2, v1, 6) & 1) == 0)
  {
LABEL_8:
    uint64_t v16 = 0;
    goto LABEL_42;
  }
  uint64_t v34 = 0;
  long long v32 = 0u;
  memset(v33, 0, sizeof(v33));
  long long v31 = 0u;
  (*(void (**)(uint8_t *__return_ptr, uint64_t))(*(void *)v10 + 152))(buf, v10);
  uint64_t v11 = sub_1005A5B0C(buf);
  int v12 = v11;
  if (!v11)
  {
    __int16 v37 = &off_1019E9EE0;
    sub_1005A5AD4();
  }
  uint64_t v13 = v11[1];
  LOWORD(v32) = *((_WORD *)v11 + 8);
  *((void *)&v31 + 1) = v13;
  LODWORD(v13) = *((_DWORD *)v11 + 7);
  *(void *)((char *)&v32 + 4) = *(void *)((char *)v11 + 20);
  HIDWORD(v32) = v13;
  memset(v33, 0, 24);
  sub_1000972F4(v33, v11[4], v11[5], 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v11[5] - v11[4]) >> 3));
  if (*((char *)v12 + 79) < 0)
  {
    sub_10004FC84(&v33[1], (void *)v12[7], v12[8]);
  }
  else
  {
    long long v14 = *(_OWORD *)(v12 + 7);
    v33[1].__r_.__value_.__r.__words[2] = v12[9];
    *(_OWORD *)&v33[1].__r_.__value_.__l.__data_ = v14;
  }
  LODWORD(v34) = *((_DWORD *)v12 + 20);
  sub_1000A3DCC(buf);
  std::string::size_type size = HIBYTE(v33[1].__r_.__value_.__r.__words[2]);
  if ((v33[1].__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
    std::string::size_type size = v33[1].__r_.__value_.__l.__size_;
  }
  BOOL *v3 = size != 0;
  std::string::operator=((std::string *)v4, &v33[1]);
  unsigned char *v5 = 0;
  int *v6 = 0;
  BOOL v18 = DWORD2(v32) == 2;
  *uint64_t v30 = DWORD2(v32) == 2;
  *uint64_t v29 = v18;
  *uint64_t v7 = HIDWORD(v32) == 1;
  BOOL *v8 = DWORD1(v32) == 1;
  uint64_t v19 = *v9;
  if (os_log_type_enabled(*v9, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#I Returning values for Get Selection", buf, 2u);
    uint64_t v19 = *v9;
  }
  if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
  {
    if (*v3) {
      int v20 = "true";
    }
    else {
      int v20 = "false";
    }
    if (*(char *)(v4 + 23) >= 0) {
      long long v21 = (const char *)v4;
    }
    else {
      long long v21 = *(const char **)v4;
    }
    *(_DWORD *)long long buf = 136315394;
    uint64_t v39 = v20;
    __int16 v40 = 2080;
    unsigned int v41 = v21;
    _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#I Title Present: %s, Title: %s", buf, 0x16u);
    uint64_t v19 = *v9;
  }
  if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
  {
    int v22 = *v6;
    if (*v5) {
      __int16 v23 = "true";
    }
    else {
      __int16 v23 = "false";
    }
    *(_DWORD *)long long buf = 136315394;
    uint64_t v39 = v23;
    __int16 v40 = 1024;
    LODWORD(v41) = v22;
    _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#I Icon Present: %s, Icon: %u", buf, 0x12u);
    uint64_t v19 = *v9;
  }
  if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
  {
    char v24 = "true";
    if (*v29) {
      uint64_t v25 = "true";
    }
    else {
      uint64_t v25 = "false";
    }
    if (!*v30) {
      char v24 = "false";
    }
    *(_DWORD *)long long buf = 136315394;
    uint64_t v39 = v25;
    __int16 v40 = 2080;
    unsigned int v41 = v24;
    _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#I Navigation Present: %s, Navigation: %s", buf, 0x16u);
    uint64_t v19 = *v9;
  }
  if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v26 = "true";
    if (*v7) {
      unsigned int v27 = "true";
    }
    else {
      unsigned int v27 = "false";
    }
    if (!*v8) {
      uint64_t v26 = "false";
    }
    *(_DWORD *)long long buf = 136315394;
    uint64_t v39 = v27;
    __int16 v40 = 2080;
    unsigned int v41 = v26;
    _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#I Soft Key: %s, Help Available: %s", buf, 0x16u);
  }
  SelectItem::~SelectItem((SelectItem *)&v31);
  uint64_t v16 = 1;
LABEL_42:
  if (v36) {
    sub_10004D2C8(v36);
  }
  return v16;
}

void sub_1005A22BC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,std::__shared_weak_count *a23,std::exception a24,int a25)
{
  if (a23) {
    sub_10004D2C8(a23);
  }
  _Unwind_Resume(a1);
}

uint64_t STK_Controller::getSelectionSize(uint64_t a1, int a2)
{
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  void v5[2] = sub_1005A24A4;
  v5[3] = &unk_1019E9C28;
  void v5[4] = a1;
  int v6 = a2;
  uint64_t v7 = v5;
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 0x40000000;
  void v8[2] = sub_1005A62F0;
  v8[3] = &unk_1019E9EF8;
  void v8[4] = a1 + 8;
  v8[5] = &v7;
  uint64_t v9 = v8;
  uint64_t v3 = a1 + 24;
  uint64_t v2 = *(NSObject **)(a1 + 24);
  if (*(void *)(v3 + 8))
  {
    unsigned int v16 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v11 = 0x40000000;
    int v12 = sub_1005A6340;
    uint64_t v13 = &unk_1019E9F38;
    long long v14 = &v16;
    long long v15 = &v9;
    dispatch_async_and_wait(v2, &block);
  }
  else
  {
    unsigned int v16 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v11 = 0x40000000;
    int v12 = sub_1005A6304;
    uint64_t v13 = &unk_1019E9F18;
    long long v14 = &v16;
    long long v15 = &v9;
    dispatch_sync(v2, &block);
  }
  return v16;
}

unint64_t sub_1005A24A4(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t v2 = *(unsigned int *)(a1 + 40);
  uint64_t v3 = (NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(v1 + 48) + 16))(*(void *)(v1 + 48), v2);
  uint64_t v17 = 0;
  BOOL v18 = 0;
  STK_Controller::getStateModel_sync(v1, v2, &v17);
  uint64_t v4 = v17;
  if (!v17)
  {
    uint64_t v9 = *v3;
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "Could not find state model when getting selection size", buf, 2u);
    }
    goto LABEL_8;
  }
  if ((STK_Controller::validateState(v1, v2, 6) & 1) == 0)
  {
LABEL_8:
    unint64_t v10 = 0;
    goto LABEL_13;
  }
  uint64_t v16 = 0;
  long long v14 = 0u;
  memset(v15, 0, sizeof(v15));
  long long v13 = 0u;
  (*(void (**)(uint8_t *__return_ptr, uint64_t))(*(void *)v4 + 152))(buf, v4);
  int v5 = sub_1005A5B0C(buf);
  int v6 = v5;
  if (!v5)
  {
    uint64_t v19 = &off_1019E9EE0;
    sub_1005A5AD4();
  }
  uint64_t v7 = v5[1];
  LOWORD(v14) = *((_WORD *)v5 + 8);
  *((void *)&v13 + 1) = v7;
  LODWORD(v7) = *((_DWORD *)v5 + 7);
  *(void *)((char *)&v14 + 4) = *(void *)((char *)v5 + 20);
  HIDWORD(v14) = v7;
  memset(v15, 0, 24);
  sub_1000972F4(v15, v5[4], v5[5], 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v5[5] - v5[4]) >> 3));
  if (*((char *)v6 + 79) < 0)
  {
    sub_10004FC84((unsigned char *)&v15[1] + 8, (void *)v6[7], v6[8]);
  }
  else
  {
    long long v8 = *(_OWORD *)(v6 + 7);
    *((void *)&v15[2] + 1) = v6[9];
    *(_OWORD *)((char *)&v15[1] + 8) = v8;
  }
  LODWORD(v16) = *((_DWORD *)v6 + 20);
  sub_1000A3DCC(buf);
  unint64_t v10 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*((void *)&v15[0] + 1) - *(void *)&v15[0]) >> 3);
  uint64_t v11 = *v3;
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 134217984;
    unint64_t v21 = v10;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I Returning selection size: %zu", buf, 0xCu);
  }
  SelectItem::~SelectItem((SelectItem *)&v13);
LABEL_13:
  if (v18) {
    sub_10004D2C8(v18);
  }
  return v10;
}

void sub_1005A2748(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,std::__shared_weak_count *a21,std::exception a22,int a23)
{
  if (a21) {
    sub_10004D2C8(a21);
  }
  _Unwind_Resume(a1);
}

BOOL STK_Controller::getSelectionItem(uint64_t a1, int a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  v12[0] = _NSConcreteStackBlock;
  v12[1] = 0x40000000;
  v12[2] = sub_1005A2934;
  v12[3] = &unk_1019E9C48;
  int v13 = a2;
  int v14 = a3;
  void v12[4] = a1;
  void v12[5] = a4;
  v12[6] = a5;
  v12[7] = a6;
  v12[8] = a7;
  v12[9] = a8;
  v12[10] = a9;
  long long v15 = v12;
  v16[0] = _NSConcreteStackBlock;
  v16[1] = 0x40000000;
  _OWORD v16[2] = sub_1005A5AC0;
  v16[3] = &unk_1019E9DD8;
  void v16[4] = a1 + 8;
  v16[5] = &v15;
  uint64_t v17 = v16;
  uint64_t v10 = a1 + 24;
  uint64_t v9 = *(NSObject **)(a1 + 24);
  if (*(void *)(v10 + 8))
  {
    char v24 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v19 = 0x40000000;
    int v20 = sub_10005ADD4;
    unint64_t v21 = &unk_1019E9DB8;
    int v22 = &v24;
    __int16 v23 = &v17;
    dispatch_async_and_wait(v9, &block);
  }
  else
  {
    char v24 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v19 = 0x40000000;
    int v20 = sub_10005A070;
    unint64_t v21 = &unk_1019E9D98;
    int v22 = &v24;
    __int16 v23 = &v17;
    dispatch_sync(v9, &block);
  }
  return v24 != 0;
}

BOOL sub_1005A2934(uint64_t a1)
{
  uint64_t v1 = *(unsigned int *)(a1 + 88);
  unint64_t v2 = *(unsigned int *)(a1 + 92);
  uint64_t v4 = *(void *)(a1 + 32);
  uint64_t v3 = *(std::string **)(a1 + 40);
  int v6 = *(unsigned char **)(a1 + 48);
  int v5 = *(int **)(a1 + 56);
  uint64_t v7 = *(BOOL **)(a1 + 64);
  long long v8 = *(_DWORD **)(a1 + 72);
  int v33 = *(BOOL **)(a1 + 80);
  uint64_t v9 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(v4 + 48) + 16))(*(void *)(v4 + 48), v1);
  uint64_t v38 = 0;
  uint64_t v39 = 0;
  STK_Controller::getStateModel_sync(v4, v1, &v38);
  uint64_t v10 = v38;
  if (!v38)
  {
    long long v15 = *v9;
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "Could not find state model when getting selection item", buf, 2u);
    }
    goto LABEL_8;
  }
  if ((STK_Controller::validateState(v4, v1, 6) & 1) == 0)
  {
LABEL_8:
    BOOL v16 = 0;
    goto LABEL_37;
  }
  uint64_t v37 = 0;
  long long v35 = 0u;
  memset(v36, 0, sizeof(v36));
  long long v34 = 0u;
  (*(void (**)(uint8_t *__return_ptr, uint64_t))(*(void *)v10 + 152))(buf, v10);
  uint64_t v11 = sub_1005A5B0C(buf);
  int v12 = v11;
  if (!v11)
  {
    __int16 v40 = &off_1019E9EE0;
    sub_1005A5AD4();
  }
  uint64_t v13 = v11[1];
  LOWORD(v35) = *((_WORD *)v11 + 8);
  *((void *)&v34 + 1) = v13;
  LODWORD(v13) = *((_DWORD *)v11 + 7);
  *(void *)((char *)&v35 + 4) = *(void *)((char *)v11 + 20);
  HIDWORD(v35) = v13;
  memset(v36, 0, 24);
  sub_1000972F4(v36, v11[4], v11[5], 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v11[5] - v11[4]) >> 3));
  if (*((char *)v12 + 79) < 0)
  {
    sub_10004FC84((unsigned char *)&v36[1] + 8, (void *)v12[7], v12[8]);
  }
  else
  {
    long long v14 = *(_OWORD *)(v12 + 7);
    *((void *)&v36[2] + 1) = v12[9];
    *(_OWORD *)((char *)&v36[1] + 8) = v14;
  }
  LODWORD(v37) = *((_DWORD *)v12 + 20);
  sub_1000A3DCC(buf);
  unint64_t v17 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*((void *)&v36[0] + 1) - *(void *)&v36[0]) >> 3);
  BOOL v16 = v17 > v2;
  if (v17 > v2)
  {
    std::string::operator=(v3, (const std::string *)(*(void *)&v36[0] + 40 * v2 + 8));
    unsigned char *v6 = 0;
    int *v5 = 0;
    int v18 = *(_DWORD *)(*(void *)&v36[0] + 40 * v2 + 32);
    *uint64_t v7 = v18 != 0;
    _DWORD *v8 = v18;
    *int v33 = v37 == v2;
    uint64_t v19 = *v9;
    if (os_log_type_enabled(*v9, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 67109120;
      *(_DWORD *)long long v42 = v2;
      _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#I Returning values for Get Selection Item for index: %u", buf, 8u);
      uint64_t v19 = *v9;
    }
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
    {
      if ((v3->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        int v20 = v3;
      }
      else {
        int v20 = (std::string *)v3->__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)long long buf = 136315138;
      *(void *)long long v42 = v20;
      _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#I Text %s", buf, 0xCu);
      uint64_t v19 = *v9;
    }
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
    {
      int v21 = *v5;
      if (*v6) {
        int v22 = "true";
      }
      else {
        int v22 = "false";
      }
      *(_DWORD *)long long buf = 136315394;
      *(void *)long long v42 = v22;
      *(_WORD *)&v42[8] = 1024;
      *(_DWORD *)&v42[10] = v21;
      _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#I Icon Present %s, Icon: %u", buf, 0x12u);
      uint64_t v19 = *v9;
    }
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
    {
      BOOL v23 = *v7;
      uint64_t v24 = asString();
      uint64_t v25 = "true";
      if (!v23) {
        uint64_t v25 = "false";
      }
      *(_DWORD *)long long buf = 136315394;
      *(void *)long long v42 = v25;
      *(_WORD *)&v42[8] = 2080;
      *(void *)&v42[10] = v24;
      _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#I Next Action Present %s, Next Action: %s", buf, 0x16u);
      uint64_t v19 = *v9;
    }
    if (!os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_36;
    }
    if (*v33) {
      uint64_t v26 = "true";
    }
    else {
      uint64_t v26 = "false";
    }
    *(_DWORD *)long long buf = 136315138;
    *(void *)long long v42 = v26;
    unsigned int v27 = "#I Is Default: %s";
    uint64_t v28 = v19;
    uint32_t v29 = 12;
  }
  else
  {
    uint64_t v30 = *v9;
    if (!os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_36;
    }
    *(_DWORD *)long long buf = 67109376;
    *(_DWORD *)long long v42 = v2;
    *(_WORD *)&v42[4] = 2048;
    *(void *)&v42[6] = v17;
    unsigned int v27 = "#I Requested index %u is invalid, there are only %zu elements in Select Item";
    uint64_t v28 = v30;
    uint32_t v29 = 18;
  }
  _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, v27, buf, v29);
LABEL_36:
  SelectItem::~SelectItem((SelectItem *)&v34);
LABEL_37:
  if (v39) {
    sub_10004D2C8(v39);
  }
  return v16;
}

void sub_1005A2E54(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,std::__shared_weak_count *a23,std::exception a24,char a25)
{
  if (a23) {
    sub_10004D2C8(a23);
  }
  _Unwind_Resume(a1);
}

void STK_Controller::setFullFunctionEventReport(uint64_t a1, int a2, char a3, char a4, uint64_t a5)
{
  int v5 = (void *)(a1 + 8);
  void v6[4] = a1;
  int v7 = a2;
  char v8 = a3;
  char v9 = a4;
  sub_100323910((uint64_t)&v10, a5);
  v6[0] = 0;
  v6[1] = 0;
  sub_10003E168(v6, v5);
  operator new();
}

void sub_1005A3020(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

BOOL STK_Controller::notificationResponse(uint64_t a1, int a2, int a3, int a4)
{
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 0x40000000;
  _OWORD v7[2] = sub_1005A31AC;
  double v7[3] = &unk_1019E9C68;
  _OWORD v7[4] = a1;
  int v8 = a2;
  int v9 = a3;
  int v10 = a4;
  uint64_t v11 = v7;
  v12[0] = _NSConcreteStackBlock;
  v12[1] = 0x40000000;
  v12[2] = sub_1005A5AC0;
  v12[3] = &unk_1019E9DD8;
  void v12[4] = a1 + 8;
  void v12[5] = &v11;
  uint64_t v13 = v12;
  uint64_t v5 = a1 + 24;
  uint64_t v4 = *(NSObject **)(a1 + 24);
  if (*(void *)(v5 + 8))
  {
    char v20 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v15 = 0x40000000;
    BOOL v16 = sub_10005ADD4;
    unint64_t v17 = &unk_1019E9DB8;
    int v18 = &v20;
    uint64_t v19 = &v13;
    dispatch_async_and_wait(v4, &block);
  }
  else
  {
    char v20 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v15 = 0x40000000;
    BOOL v16 = sub_10005A070;
    unint64_t v17 = &unk_1019E9D98;
    int v18 = &v20;
    uint64_t v19 = &v13;
    dispatch_sync(v4, &block);
  }
  return v20 != 0;
}

uint64_t sub_1005A31AC(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  uint64_t v2 = *(unsigned int *)(a1 + 44);
  uint64_t v4 = *(unsigned int *)(a1 + 48);
  uint64_t v5 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(v1 + 48) + 16))(*(void *)(v1 + 48), v3);
  uint64_t v9 = 0;
  int v10 = 0;
  STK_Controller::getStateModel_sync(v1, v3, &v9);
  if (v9)
  {
    uint64_t v6 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v9 + 88))(v9, v2, v4);
  }
  else
  {
    int v7 = *v5;
    if (os_log_type_enabled(*v5, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 67109120;
      int v12 = v2;
      _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "Could not find state model for sending notification response for session %u", buf, 8u);
    }
    uint64_t v6 = 0;
  }
  if (v10) {
    sub_10004D2C8(v10);
  }
  return v6;
}

void sub_1005A32F8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

BOOL STK_Controller::notificationResponse(uint64_t a1, int a2, int a3, int a4, int a5)
{
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 0x40000000;
  void v8[2] = sub_1005A348C;
  v8[3] = &unk_1019E9C88;
  void v8[4] = a1;
  int v9 = a2;
  int v10 = a3;
  int v11 = a4;
  int v12 = a5;
  uint64_t v13 = v8;
  v14[0] = _NSConcreteStackBlock;
  v14[1] = 0x40000000;
  void v14[2] = sub_1005A5AC0;
  uint64_t v14[3] = &unk_1019E9DD8;
  v14[4] = a1 + 8;
  v14[5] = &v13;
  uint64_t v15 = v14;
  uint64_t v6 = a1 + 24;
  uint64_t v5 = *(NSObject **)(a1 + 24);
  if (*(void *)(v6 + 8))
  {
    char v22 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v17 = 0x40000000;
    int v18 = sub_10005ADD4;
    uint64_t v19 = &unk_1019E9DB8;
    char v20 = &v22;
    int v21 = &v15;
    dispatch_async_and_wait(v5, &block);
  }
  else
  {
    char v22 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v17 = 0x40000000;
    int v18 = sub_10005A070;
    uint64_t v19 = &unk_1019E9D98;
    char v20 = &v22;
    int v21 = &v15;
    dispatch_sync(v5, &block);
  }
  return v22 != 0;
}

{
  NSObject *v5;
  uint64_t v6;
  void v8[5];
  int v9;
  int v10;
  int v11;
  int v12;
  void *v13;
  void v14[6];
  void *v15;
  void **block;
  uint64_t v17;
  uint64_t (*v18)(uint64_t);
  void *v19;
  char *v20;
  void *v21;
  char v22;

  v8[0] = _NSConcreteStackBlock;
  v8[1] = 0x40000000;
  void v8[2] = sub_1005A3770;
  v8[3] = &unk_1019E9CA8;
  void v8[4] = a1;
  int v9 = a2;
  int v10 = a3;
  int v11 = a4;
  int v12 = a5;
  uint64_t v13 = v8;
  v14[0] = _NSConcreteStackBlock;
  v14[1] = 0x40000000;
  void v14[2] = sub_1005A5AC0;
  uint64_t v14[3] = &unk_1019E9DD8;
  v14[4] = a1 + 8;
  v14[5] = &v13;
  uint64_t v15 = v14;
  uint64_t v6 = a1 + 24;
  uint64_t v5 = *(NSObject **)(a1 + 24);
  if (*(void *)(v6 + 8))
  {
    char v22 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v17 = 0x40000000;
    int v18 = sub_10005ADD4;
    uint64_t v19 = &unk_1019E9DB8;
    char v20 = &v22;
    int v21 = &v15;
    dispatch_async_and_wait(v5, &block);
  }
  else
  {
    char v22 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v17 = 0x40000000;
    int v18 = sub_10005A070;
    uint64_t v19 = &unk_1019E9D98;
    char v20 = &v22;
    int v21 = &v15;
    dispatch_sync(v5, &block);
  }
  return v22 != 0;
}

{
  NSObject *v5;
  uint64_t v6;
  void v8[5];
  int v9;
  int v10;
  int v11;
  int v12;
  void *v13;
  void v14[6];
  void *v15;
  void **block;
  uint64_t v17;
  uint64_t (*v18)(uint64_t);
  void *v19;
  char *v20;
  void *v21;
  char v22;

  v8[0] = _NSConcreteStackBlock;
  v8[1] = 0x40000000;
  void v8[2] = sub_1005A3E1C;
  v8[3] = &unk_1019E9CF8;
  void v8[4] = a1;
  int v9 = a2;
  int v10 = a3;
  int v11 = a4;
  int v12 = a5;
  uint64_t v13 = v8;
  v14[0] = _NSConcreteStackBlock;
  v14[1] = 0x40000000;
  void v14[2] = sub_1005A5AC0;
  uint64_t v14[3] = &unk_1019E9DD8;
  v14[4] = a1 + 8;
  v14[5] = &v13;
  uint64_t v15 = v14;
  uint64_t v6 = a1 + 24;
  uint64_t v5 = *(NSObject **)(a1 + 24);
  if (*(void *)(v6 + 8))
  {
    char v22 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v17 = 0x40000000;
    int v18 = sub_10005ADD4;
    uint64_t v19 = &unk_1019E9DB8;
    char v20 = &v22;
    int v21 = &v15;
    dispatch_async_and_wait(v5, &block);
  }
  else
  {
    char v22 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v17 = 0x40000000;
    int v18 = sub_10005A070;
    uint64_t v19 = &unk_1019E9D98;
    char v20 = &v22;
    int v21 = &v15;
    dispatch_sync(v5, &block);
  }
  return v22 != 0;
}

uint64_t sub_1005A348C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  uint64_t v2 = *(unsigned int *)(a1 + 44);
  uint64_t v4 = *(unsigned int *)(a1 + 48);
  uint64_t v5 = *(unsigned int *)(a1 + 52);
  uint64_t v6 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(v1 + 48) + 16))(*(void *)(v1 + 48), v3);
  uint64_t v10 = 0;
  int v11 = 0;
  STK_Controller::getStateModel_sync(v1, v3, &v10);
  if (v10)
  {
    uint64_t v7 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v10 + 96))(v10, v2, v4, v5);
  }
  else
  {
    int v8 = *v6;
    if (os_log_type_enabled(*v6, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 67109120;
      int v13 = v2;
      _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "Could not find state model for sending notification response for session %u", buf, 8u);
    }
    uint64_t v7 = 0;
  }
  if (v11) {
    sub_10004D2C8(v11);
  }
  return v7;
}

void sub_1005A35DC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1005A3770(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  uint64_t v2 = *(unsigned int *)(a1 + 44);
  uint64_t v4 = *(unsigned int *)(a1 + 48);
  uint64_t v5 = *(unsigned int *)(a1 + 52);
  uint64_t v6 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(v1 + 48) + 16))(*(void *)(v1 + 48), v3);
  uint64_t v10 = 0;
  int v11 = 0;
  STK_Controller::getStateModel_sync(v1, v3, &v10);
  if (v10)
  {
    uint64_t v7 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v10 + 104))(v10, v2, v4, v5);
  }
  else
  {
    int v8 = *v6;
    if (os_log_type_enabled(*v6, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 67109120;
      int v13 = v2;
      _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "Could not find state model for sending notification response with index for session %u", buf, 8u);
    }
    uint64_t v7 = 0;
  }
  if (v11) {
    sub_10004D2C8(v11);
  }
  return v7;
}

void sub_1005A38C0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

BOOL STK_Controller::notificationResponse(uint64_t a1, int a2, int a3, int a4, long long *a5)
{
  uint64_t v6 = a1 + 8;
  v10[0] = _NSConcreteStackBlock;
  v10[1] = 1174405120;
  uint64_t v10[2] = sub_1005A3AA4;
  void v10[3] = &unk_1019E9CC8;
  void v10[4] = a1;
  int v13 = a2;
  int v14 = a3;
  int v15 = a4;
  if (*((char *)a5 + 23) < 0)
  {
    sub_10004FC84(&__p, *(void **)a5, *((void *)a5 + 1));
  }
  else
  {
    long long __p = *a5;
    uint64_t v12 = *((void *)a5 + 2);
  }
  BOOL v16 = v10;
  v17[0] = _NSConcreteStackBlock;
  v17[1] = 0x40000000;
  _OWORD v17[2] = sub_1005A5AC0;
  v17[3] = &unk_1019E9DD8;
  v17[4] = v6;
  v17[5] = &v16;
  int v18 = v17;
  uint64_t v7 = *(NSObject **)(a1 + 24);
  if (*(void *)(a1 + 32))
  {
    unsigned __int8 v25 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v20 = 0x40000000;
    int v21 = sub_10005ADD4;
    char v22 = &unk_1019E9DB8;
    BOOL v23 = &v25;
    uint64_t v24 = &v18;
    dispatch_async_and_wait(v7, &block);
  }
  else
  {
    unsigned __int8 v25 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v20 = 0x40000000;
    int v21 = sub_10005A070;
    char v22 = &unk_1019E9D98;
    BOOL v23 = &v25;
    uint64_t v24 = &v18;
    dispatch_sync(v7, &block);
  }
  int v8 = v25;
  if (SHIBYTE(v12) < 0) {
    operator delete((void *)__p);
  }
  return v8 != 0;
}

uint64_t sub_1005A3AA4(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 64);
  uint64_t v2 = *(unsigned int *)(a1 + 68);
  uint64_t v4 = *(unsigned int *)(a1 + 72);
  if (*(char *)(a1 + 63) < 0)
  {
    sub_10004FC84(v9, *(void **)(a1 + 40), *(void *)(a1 + 48));
  }
  else
  {
    *(_OWORD *)int v9 = *(_OWORD *)(a1 + 40);
    uint64_t v10 = *(void *)(a1 + 56);
  }
  uint64_t v5 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(v1 + 48) + 16))(*(void *)(v1 + 48), v3);
  uint64_t v11 = 0;
  uint64_t v12 = 0;
  STK_Controller::getStateModel_sync(v1, v3, &v11);
  if (v11)
  {
    *(_OWORD *)long long __p = *(_OWORD *)v9;
    uint64_t v14 = v10;
    v9[1] = 0;
    uint64_t v10 = 0;
    v9[0] = 0;
    uint64_t v6 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, void **))(*(void *)v11 + 112))(v11, v2, v4, __p);
    if (SHIBYTE(v14) < 0) {
      operator delete(__p[0]);
    }
  }
  else
  {
    uint64_t v7 = *v5;
    if (os_log_type_enabled(*v5, OS_LOG_TYPE_ERROR))
    {
      LODWORD(__p[0]) = 67109120;
      HIDWORD(__p[0]) = v2;
      _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "Could not find state model for sending notification response with text for session %u", (uint8_t *)__p, 8u);
    }
    uint64_t v6 = 0;
  }
  if (v12) {
    sub_10004D2C8(v12);
  }
  if (SHIBYTE(v10) < 0) {
    operator delete(v9[0]);
  }
  return v6;
}

void sub_1005A3C58(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
}

uint64_t sub_1005A3E1C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  uint64_t v2 = *(unsigned int *)(a1 + 44);
  uint64_t v4 = *(unsigned int *)(a1 + 48);
  uint64_t v5 = *(unsigned int *)(a1 + 52);
  uint64_t v6 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(v1 + 48) + 16))(*(void *)(v1 + 48), v3);
  uint64_t v10 = 0;
  uint64_t v11 = 0;
  STK_Controller::getStateModel_sync(v1, v3, &v10);
  if (v10)
  {
    uint64_t v7 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v10 + 120))(v10, v2, v4, v5);
  }
  else
  {
    int v8 = *v6;
    if (os_log_type_enabled(*v6, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 67109120;
      int v13 = v2;
      _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "Could not find state model for sending notification response with BOOLean for session %u", buf, 8u);
    }
    uint64_t v7 = 0;
  }
  if (v11) {
    sub_10004D2C8(v11);
  }
  return v7;
}

void sub_1005A3F6C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

BOOL STK_Controller::selectMenuItem(uint64_t a1, int a2, int a3, char a4)
{
  int v9 = a3;
  int v10 = a2;
  char v8 = a4;
  v7[0] = a1;
  v7[1] = &v10;
  _OWORD v7[2] = &v9;
  double v7[3] = &v8;
  v11[0] = _NSConcreteStackBlock;
  v11[1] = 0x40000000;
  v11[2] = sub_1005A64E0;
  v11[3] = &unk_1019E9F58;
  void v11[4] = a1 + 8;
  v11[5] = v7;
  uint64_t v12 = v11;
  uint64_t v5 = a1 + 24;
  uint64_t v4 = *(NSObject **)(a1 + 24);
  if (*(void *)(v5 + 8))
  {
    char v19 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v14 = 0x40000000;
    int v15 = sub_10005ADD4;
    BOOL v16 = &unk_1019E9DB8;
    uint64_t v17 = &v19;
    int v18 = &v12;
    dispatch_async_and_wait(v4, &block);
  }
  else
  {
    char v19 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v14 = 0x40000000;
    int v15 = sub_10005A070;
    BOOL v16 = &unk_1019E9D98;
    uint64_t v17 = &v19;
    int v18 = &v12;
    dispatch_sync(v4, &block);
  }
  return v19 != 0;
}

void STK_Controller::eventLanguageSelection(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = (void *)(a1 + 8);
  if (*(char *)(a2 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)long long __p = *(_OWORD *)a2;
    id __p[2] = *(void **)(a2 + 16);
  }
  v4[0] = 0;
  v4[1] = 0;
  sub_10003E168(v4, v2);
  operator new();
}

void STK_Controller::eventUserActivity(STK_Controller *this)
{
  v1[0] = 0;
  v1[1] = 0;
  sub_10003E168(v1, (void *)this + 1);
  operator new();
}

void STK_Controller::eventIMSRegistration(uint64_t a1, uint64_t a2, long long **a3, int a4, char a5)
{
  uint64_t v7 = (void *)(a1 + 8);
  memset(v8, 0, sizeof(v8));
  sub_1000302C0((char *)v8, *a3, a3[1], 0xAAAAAAAAAAAAAAABLL * (((char *)a3[1] - (char *)*a3) >> 3));
  int v9 = a4;
  char v10 = a5;
  v11[0] = 0;
  v11[1] = 0;
  sub_10003E168(v11, v7);
  operator new();
}

void STK_Controller::smsPPDataDownload(uint64_t a1, int a2, uint64_t a3, uint64_t a4, char a5, uint64_t a6)
{
  void v10[4] = a1;
  int v11 = a2;
  if (*(char *)(a3 + 23) < 0)
  {
    sub_10004FC84(v12, *(void **)a3, *(void *)(a3 + 8));
  }
  else
  {
    *(_OWORD *)uint64_t v12 = *(_OWORD *)a3;
    v12[2] = *(void **)(a3 + 16);
  }
  if (*(char *)(a4 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a4, *(void *)(a4 + 8));
  }
  else
  {
    *(_OWORD *)long long __p = *(_OWORD *)a4;
    id __p[2] = *(void **)(a4 + 16);
  }
  char v14 = a5;
  sub_10033F0E0((uint64_t)&v15, a6);
  v10[0] = 0;
  v10[1] = 0;
  sub_10003E168(v10, (void *)(a1 + 8));
  operator new();
}

void sub_1005A46B0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a2)
  {
    if (*(char *)(v20 + 39) < 0) {
      operator delete(*v21);
    }
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void STK_Controller::sendCallControlSms(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  void v8[4] = a1;
  int v9 = a2;
  sub_10009DB3C((uint64_t)&v10, a3);
  sub_10009DB3C((uint64_t)&v11, a4);
  sub_1005A7040((uint64_t)&v12, a5);
  v8[0] = 0;
  v8[1] = 0;
  sub_10003E168(v8, (void *)(a1 + 8));
  operator new();
}

void sub_1005A4968(_Unwind_Exception *exception_object, int a2)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

uint64_t sub_1005A499C(uint64_t a1)
{
  if (*(char *)(a1 + 263) < 0) {
    operator delete(*(void **)(a1 + 240));
  }
  if (*(char *)(a1 + 239) < 0) {
    operator delete(*(void **)(a1 + 216));
  }
  if (*(char *)(a1 + 207) < 0) {
    operator delete(*(void **)(a1 + 184));
  }
  if (*(char *)(a1 + 183) < 0) {
    operator delete(*(void **)(a1 + 160));
  }
  if (*(char *)(a1 + 127) < 0) {
    operator delete(*(void **)(a1 + 104));
  }
  if (*(char *)(a1 + 103) < 0) {
    operator delete(*(void **)(a1 + 80));
  }
  if (*(char *)(a1 + 71) < 0) {
    operator delete(*(void **)(a1 + 48));
  }
  if (*(char *)(a1 + 47) < 0) {
    operator delete(*(void **)(a1 + 24));
  }
  return a1;
}

void STK_Controller::sendCallControlVoice(uint64_t a1, int a2, uint64_t a3, char a4, uint64_t a5)
{
  void v8[4] = a1;
  int v9 = a2;
  sub_10009DB3C((uint64_t)&v10, a3);
  char v11 = a4;
  sub_1005A728C((uint64_t)&v12, a5);
  v8[0] = 0;
  v8[1] = 0;
  sub_10003E168(v8, (void *)(a1 + 8));
  operator new();
}

void sub_1005A4C60(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_10006A6AC(a1);
}

void STK_Controller::eventMTCall(uint64_t a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5)
{
  if (*(char *)(a3 + 23) < 0)
  {
    sub_10004FC84(v8, *(void **)a3, *(void *)(a3 + 8));
  }
  else
  {
    *(_OWORD *)char v8 = *(_OWORD *)a3;
    void v8[2] = *(void **)(a3 + 16);
  }
  int v9 = a4;
  sub_10009DB3C((uint64_t)&v10, a5);
  v11[0] = 0;
  v11[1] = 0;
  sub_10003E168(v11, (void *)(a1 + 8));
  operator new();
}

void sub_1005A4E98(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void STK_Controller::eventCallConnected(uint64_t a1, uint64_t a2, uint64_t a3, int a4, char a5)
{
  uint64_t v7 = (void *)(a1 + 8);
  if (*(char *)(a3 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a3, *(void *)(a3 + 8));
  }
  else
  {
    *(_OWORD *)long long __p = *(_OWORD *)a3;
    id __p[2] = *(void **)(a3 + 16);
  }
  int v9 = a4;
  char v10 = a5;
  v11[0] = 0;
  v11[1] = 0;
  sub_10003E168(v11, v7);
  operator new();
}

void STK_Controller::eventCallDisconnected(uint64_t a1, uint64_t a2, uint64_t a3, int a4, char a5)
{
  uint64_t v7 = (void *)(a1 + 8);
  if (*(char *)(a3 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a3, *(void *)(a3 + 8));
  }
  else
  {
    *(_OWORD *)long long __p = *(_OWORD *)a3;
    id __p[2] = *(void **)(a3 + 16);
  }
  int v9 = a4;
  char v10 = a5;
  v11[0] = 0;
  v11[1] = 0;
  sub_10003E168(v11, v7);
  operator new();
}

void *sub_1005A51B0(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *sub_1005A5234(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *sub_1005A52B8(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t sub_1005A533C(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (void *)(a2 + 24);
  uint64_t v4 = *(void *)(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(*(void *)*v3 + 24))(*v3, a1);
      return a1;
    }
    *(void *)(a1 + 24) = v4;
  }
  else
  {
    uint64_t v3 = (void *)(a1 + 24);
  }
  void *v3 = 0;
  return a1;
}

uint64_t *sub_1005A53BC(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v4 = a1;
  uint64_t v5 = v1;
  sub_1005A16CC(__p, *(void *)v1, *(unsigned int *)(v1 + 8));
  uint64_t v2 = *(void *)(v1 + 40);
  if (!v2) {
    sub_10007B600();
  }
  (*(void (**)(uint64_t, std::string *))(*(void *)v2 + 48))(v2, __p);
  if (v7 && SHIBYTE(__p[0].__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p[0].__r_.__value_.__l.__data_);
  }
  sub_1005A5494(&v5);
  return sub_100046B58((uint64_t *)&v4);
}

void sub_1005A5458(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21)
{
}

uint64_t *sub_1005A5494(uint64_t *result)
{
  uint64_t v1 = *result;
  void *result = 0;
  if (v1)
  {
    sub_1005A51B0((void *)(v1 + 16));
    operator delete();
  }
  return result;
}

void sub_1005A54E4(uint64_t a1@<X0>, std::string *a2@<X8>)
{
}

void sub_1005A54F8(uint64_t a1)
{
  (*(void (**)(void **__return_ptr))(**(void **)(a1 + 40) + 16))(__p);
  sub_1005A555C(*(void *)(a1 + 32), (long long *)__p);
  if (v4)
  {
    if (v3 < 0) {
      operator delete(__p[0]);
    }
  }
}

__n128 sub_1005A555C(uint64_t a1, long long *a2)
{
  if (*(unsigned __int8 *)(a1 + 48) == *((unsigned __int8 *)a2 + 48))
  {
    if (*(unsigned char *)(a1 + 48))
    {
      if (*(char *)(a1 + 23) < 0) {
        operator delete(*(void **)a1);
      }
      long long v4 = *a2;
      *(void *)(a1 + 16) = *((void *)a2 + 2);
      *(_OWORD *)a1 = v4;
      *((unsigned char *)a2 + 23) = 0;
      *(unsigned char *)a2 = 0;
      __n128 result = *(__n128 *)((char *)a2 + 24);
      *(void *)(a1 + 40) = *((void *)a2 + 5);
      *(__n128 *)(a1 + 24) = result;
    }
  }
  else if (*(unsigned char *)(a1 + 48))
  {
    if (*(char *)(a1 + 23) < 0) {
      operator delete(*(void **)a1);
    }
    *(unsigned char *)(a1 + 48) = 0;
  }
  else
  {
    long long v6 = *a2;
    *(void *)(a1 + 16) = *((void *)a2 + 2);
    *(_OWORD *)a1 = v6;
    *((void *)a2 + 1) = 0;
    *((void *)a2 + 2) = 0;
    *(void *)a2 = 0;
    __n128 result = *(__n128 *)((char *)a2 + 24);
    *(void *)(a1 + 40) = *((void *)a2 + 5);
    *(__n128 *)(a1 + 24) = result;
    *(unsigned char *)(a1 + 48) = 1;
  }
  return result;
}

void sub_1005A561C(uint64_t a1)
{
  (*(void (**)(void **__return_ptr))(**(void **)(a1 + 40) + 16))(__p);
  sub_1005A555C(*(void *)(a1 + 32), (long long *)__p);
  if (v4)
  {
    if (v3 < 0) {
      operator delete(__p[0]);
    }
  }
}

uint64_t sub_1005A5680(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 40);
  uint64_t v2 = *(void *)v1;
  uint64_t v3 = **(unsigned int **)(v1 + 8);
  char v4 = *(std::string **)(v1 + 24);
  unint64_t v5 = **(unsigned int **)(v1 + 16);
  char v7 = *(unsigned char **)(v1 + 32);
  long long v6 = *(int **)(v1 + 40);
  char v8 = *(BOOL **)(v1 + 48);
  int v9 = *(_DWORD **)(v1 + 56);
  char v10 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(*(void *)v1 + 48) + 16))(*(void *)(*(void *)v1 + 48), v3);
  uint64_t v30 = 0;
  long long v31 = 0;
  STK_Controller::getStateModel_sync(v2, v3, &v30);
  if (v30)
  {
    long long v38 = 0u;
    long long v39 = 0u;
    long long v36 = 0u;
    long long v37 = 0u;
    *(_OWORD *)long long v34 = 0u;
    long long v35 = 0u;
    (*(void (**)(uint8_t *__return_ptr))(*(void *)v30 + 56))(v34);
    if (BYTE8(v39))
    {
      unint64_t v11 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*((void *)&v36 + 1) - v36) >> 3);
      if (v11 > v5)
      {
        std::string::operator=(v4, (const std::string *)(v36 + 40 * v5 + 8));
        *char v7 = 0;
        int *v6 = 0;
        int v12 = *(_DWORD *)(v36 + 40 * v5 + 32);
        BOOL *v8 = v12 != 0;
        _DWORD *v9 = v12;
        int v13 = *v10;
        if (os_log_type_enabled(*v10, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I Returning values for Get Setup Menu Item", buf, 2u);
          int v13 = *v10;
        }
        if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
        {
          if ((v4->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            char v14 = v4;
          }
          else {
            char v14 = (std::string *)v4->__r_.__value_.__r.__words[0];
          }
          *(_DWORD *)long long buf = 136315138;
          *(void *)int v33 = v14;
          _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I Text: %s", buf, 0xCu);
          int v13 = *v10;
        }
        if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
        {
          int v15 = *v6;
          if (*v7) {
            BOOL v16 = "true";
          }
          else {
            BOOL v16 = "false";
          }
          *(_DWORD *)long long buf = 136315394;
          *(void *)int v33 = v16;
          *(_WORD *)&v33[8] = 1024;
          *(_DWORD *)&v33[10] = v15;
          _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I Icon Present: %s, Icon: %u", buf, 0x12u);
          int v13 = *v10;
        }
        if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
        {
          BOOL v17 = *v8;
          uint64_t v18 = asString();
          char v19 = "true";
          if (!v17) {
            char v19 = "false";
          }
          *(_DWORD *)long long buf = 136315394;
          *(void *)int v33 = v19;
          *(_WORD *)&v33[8] = 2080;
          *(void *)&v33[10] = v18;
          _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I Next Action Present: %s, Next Action: %s", buf, 0x16u);
        }
        uint64_t v20 = 1;
        goto LABEL_29;
      }
      os_log_t v27 = *v10;
      BOOL v28 = os_log_type_enabled(*v10, OS_LOG_TYPE_DEFAULT);
      uint64_t v20 = 0;
      if (!v28)
      {
LABEL_29:
        if (BYTE8(v39)) {
          SetupMenu::~SetupMenu((SetupMenu *)v34);
        }
        goto LABEL_31;
      }
      *(_DWORD *)long long buf = 67109376;
      *(_DWORD *)int v33 = v5;
      *(_WORD *)&v33[4] = 2048;
      *(void *)&v33[6] = v11;
      uint64_t v24 = "#N Requested index %u is invalid, menu size: %zu";
      unsigned __int8 v25 = v27;
      uint32_t v26 = 18;
    }
    else
    {
      os_log_t v22 = *v10;
      BOOL v23 = os_log_type_enabled(*v10, OS_LOG_TYPE_DEFAULT);
      uint64_t v20 = 0;
      if (!v23) {
        goto LABEL_31;
      }
      *(_WORD *)long long buf = 0;
      uint64_t v24 = "#I Setup Menu is invalid";
      unsigned __int8 v25 = v22;
      uint32_t v26 = 2;
    }
    _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, v24, buf, v26);
    uint64_t v20 = 0;
    goto LABEL_29;
  }
  int v21 = *v10;
  if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)long long v34 = 67109120;
    *(_DWORD *)&v34[4] = v5;
    _os_log_error_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "Could not find state model when getting setup menu item %u", v34, 8u);
  }
  uint64_t v20 = 0;
LABEL_31:
  if (v31) {
    sub_10004D2C8(v31);
  }
  return v20;
}

void sub_1005A5A8C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  if (a26) {
    SetupMenu::~SetupMenu((SetupMenu *)&a15);
  }
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

void *sub_1005A5AC0(uint64_t a1)
{
  return (*(void *(**)(void *__return_ptr))(**(void **)(a1 + 40) + 16))(*(void **)(a1 + 40));
}

void sub_1005A5AD4()
{
  exception = __cxa_allocate_exception(0x38uLL);
  uint64_t v1 = (void *)sub_1005A5C10((uint64_t)exception);
}

void *sub_1005A5B0C(_DWORD *a1)
{
  int v3 = *a1;
  uint64_t v1 = a1 + 2;
  int v2 = v3;
  char v4 = 0;
  switch(v3 ^ (v3 >> 31))
  {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 0xA:
    case 0xC:
    case 0xD:
    case 0xE:
    case 0xF:
    case 0x10:
    case 0x11:
    case 0x12:
    case 0x13:
    case 0x14:
    case 0x15:
    case 0x16:
    case 0x17:
    case 0x18:
    case 0x19:
    case 0x1A:
    case 0x1B:
    case 0x1C:
    case 0x1D:
      return v4;
    case 0xB:
      if (v2 < 0) {
        char v4 = (void *)*v1;
      }
      else {
        char v4 = v1;
      }
      break;
    default:
      sub_1000971B8();
  }
  return v4;
}

uint64_t sub_1005A5C10(uint64_t result)
{
  *(void *)(result + 24) = 0;
  *(void *)(result + 32) = 0;
  *(void *)(result + 40) = 0;
  *(_DWORD *)(result + 48) = -1;
  *(void *)__n128 result = &off_1019E9E68;
  *(void *)(result + 8) = off_1019E9E98;
  *(void *)(result + 16) = off_1019E9EC0;
  return result;
}

uint64_t sub_1005A5C80(uint64_t a1)
{
  *(void *)(a1 + 16) = &off_10199A8F0;
  sub_100098B6C((uint64_t *)(a1 + 24));
  std::exception::~exception((std::exception *)(a1 + 8));
  return a1;
}

void sub_1005A5CD4()
{
}

void sub_1005A5E94(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  sub_100098B6C(&a9);
  sub_100098B6C(&a10);
  (*(void (**)(uint64_t))(*(void *)v10 + 24))(v10);
  _Unwind_Resume(a1);
}

void sub_1005A5F0C(uint64_t a1)
{
  exception = __cxa_allocate_exception(0x38uLL);
  sub_1005A61C0((uint64_t)exception, a1);
}

void sub_1005A5F54(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void sub_1005A5F68(uint64_t a1)
{
  *(void *)(a1 + 16) = &off_10199A8F0;
  sub_100098B6C((uint64_t *)(a1 + 24));
  std::exception::~exception((std::exception *)(a1 + 8));

  operator delete();
}

void sub_1005A5FDC(uint64_t a1)
{
  *(void *)(a1 + 8) = &off_10199A8F0;
  sub_100098B6C((uint64_t *)(a1 + 16));

  std::exception::~exception((std::exception *)a1);
}

void sub_1005A6038(uint64_t a1)
{
  *(void *)(a1 + 8) = &off_10199A8F0;
  sub_100098B6C((uint64_t *)(a1 + 16));
  std::exception::~exception((std::exception *)a1);

  operator delete();
}

const char *sub_1005A60B0()
{
  return "boost::bad_get: failed value get using boost::get";
}

void sub_1005A60BC(void *a1)
{
  *a1 = &off_10199A8F0;
  sub_100098B6C(a1 + 1);

  std::exception::~exception((std::exception *)a1 - 1);
}

void sub_1005A6114(void *a1)
{
  *a1 = &off_10199A8F0;
  sub_100098B6C(a1 + 1);
  std::exception::~exception((std::exception *)a1 - 1);

  operator delete();
}

void sub_1005A6188(std::exception *a1)
{
  std::exception::~exception(a1);

  operator delete();
}

uint64_t sub_1005A61C0(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = &off_10199A898;
  *(void *)(a1 + 8) = &off_1019E9EE0;
  uint64_t v4 = *(void *)(a2 + 24);
  *(void *)(a1 + 16) = &off_10199A8F0;
  *(void *)(a1 + 24) = v4;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 24))(v4);
  }
  long long v5 = *(_OWORD *)(a2 + 32);
  *(_DWORD *)(a1 + 48) = *(_DWORD *)(a2 + 48);
  *(_OWORD *)(a1 + 32) = v5;
  *(void *)a1 = &off_1019E9E68;
  *(void *)(a1 + 8) = off_1019E9E98;
  *(void *)(a1 + 16) = off_1019E9EC0;
  return a1;
}

void sub_1005A62DC(_Unwind_Exception *a1)
{
  std::exception::~exception(v1);
  _Unwind_Resume(a1);
}

void *sub_1005A62F0(uint64_t a1)
{
  return (*(void *(**)(void *__return_ptr))(**(void **)(a1 + 40) + 16))(*(void **)(a1 + 40));
}

uint64_t sub_1005A6304(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 40) + 16))();
  **(_DWORD **)(a1 + 32) = result;
  return result;
}

uint64_t sub_1005A6340(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 40) + 16))();
  **(_DWORD **)(a1 + 32) = result;
  return result;
}

uint64_t *sub_1005A637C(uint64_t *a1)
{
  uint64_t v1 = *a1;
  char v7 = a1;
  uint64_t v8 = v1;
  uint64_t v2 = *(void *)(*(void *)v1 + 88);
  uint64_t STKSimSlotInfo_sync = STK_Controller::createSTKSimSlotInfo_sync(*(void *)v1, *(unsigned int *)(v1 + 8));
  int v4 = *(unsigned __int8 *)(v1 + 12);
  int v5 = *(unsigned __int8 *)(v1 + 13);
  sub_100323990((uint64_t)v9, v1 + 16);
  (*(void (**)(uint64_t, uint64_t, BOOL, BOOL, void *))(*(void *)v2 + 168))(v2, STKSimSlotInfo_sync, v4 != 0, v5 != 0, v9);
  sub_1000605C0(v9);
  sub_1005A6490(&v8);
  return sub_100046B58((uint64_t *)&v7);
}

void sub_1005A6464(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, void);
  va_copy(va2, va1);
  uint64_t v5 = va_arg(va2, void);
  sub_1000605C0((uint64_t *)va2);
  sub_1005A6490((uint64_t *)va1);
  sub_100046B58((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t *sub_1005A6490(uint64_t *result)
{
  uint64_t v1 = *result;
  void *result = 0;
  if (v1)
  {
    sub_1000605C0((void *)(v1 + 16));
    operator delete();
  }
  return result;
}

uint64_t sub_1005A64E0(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 40);
  uint64_t v2 = *(void *)v1;
  uint64_t v3 = (os_log_t *)(*(uint64_t (**)(void, void))(**(void **)(*(void *)v1 + 48) + 16))(*(void *)(*(void *)v1 + 48), **(unsigned int **)(v1 + 8));
  uint64_t v12 = 0;
  int v13 = 0;
  STK_Controller::getStateModel_sync(v2, **(_DWORD **)(v1 + 8), &v12);
  uint64_t v4 = v12;
  if (!v12)
  {
    uint64_t v8 = *v3;
    if (os_log_type_enabled(*v3, OS_LOG_TYPE_ERROR))
    {
      int v10 = **(_DWORD **)(v1 + 16);
      *(_DWORD *)long long buf = 67109120;
      *(_DWORD *)&uint8_t buf[4] = v10;
      _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "Could not find state model for item selection with index %u", buf, 8u);
    }
    goto LABEL_13;
  }
  if (((*(uint64_t (**)(uint64_t, void, void))(*(void *)v12 + 48))(v12, **(unsigned int **)(v1 + 16), **(unsigned __int8 **)(v1 + 24)) & 1) == 0)
  {
LABEL_13:
    uint64_t v7 = 0;
    goto LABEL_14;
  }
  memset(&v11, 0, sizeof(v11));
  long long v18 = 0u;
  long long v19 = 0u;
  long long v16 = 0u;
  long long v17 = 0u;
  *(_OWORD *)long long buf = 0u;
  long long v15 = 0u;
  (*(void (**)(uint8_t *__return_ptr, uint64_t))(*(void *)v4 + 56))(buf, v4);
  uint64_t v5 = *(int **)(v1 + 16);
  if (BYTE8(v19))
  {
    unint64_t v6 = *v5;
    if (0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*((void *)&v16 + 1) - v16) >> 3) > v6)
    {
      std::string::operator=(&v11, (const std::string *)(v16 + 40 * v6 + 8));
      uint64_t v5 = *(int **)(v1 + 16);
    }
  }
  sub_100BCA280(**(unsigned int **)(v1 + 8), 1, *v5, &v11);
  if (BYTE8(v19)) {
    SetupMenu::~SetupMenu((SetupMenu *)buf);
  }
  if (SHIBYTE(v11.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v11.__r_.__value_.__l.__data_);
  }
  uint64_t v7 = 1;
LABEL_14:
  if (v13) {
    sub_10004D2C8(v13);
  }
  return v7;
}

void sub_1005A66FC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, std::__shared_weak_count *a17, char a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  if (a17) {
    sub_10004D2C8(a17);
  }
  _Unwind_Resume(exception_object);
}

uint64_t *sub_1005A6744(uint64_t *a1)
{
  uint64_t v1 = *a1;
  long long v18 = a1;
  uint64_t v19 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v3 = *(void **)(*(void *)v1 + 104);
  uint64_t v4 = *(void *)v1 + 112;
  if (v3 != (void *)v4)
  {
    uint64_t v5 = v1 + 8;
    do
    {
      uint64_t v6 = *((unsigned int *)v3 + 8);
      uint64_t v8 = v3[5];
      uint64_t v7 = (std::__shared_weak_count *)v3[6];
      if (v7) {
        atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      int v9 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), v6);
      char v10 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v8 + 72))(v8, 2);
      std::string v11 = *v9;
      BOOL v12 = os_log_type_enabled(*v9, OS_LOG_TYPE_DEFAULT);
      if (v10)
      {
        if (v12)
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I There is a registered request for language selection notification, notifying the SIM", buf, 2u);
        }
        uint64_t STKSimSlotInfo_sync = STK_Controller::createSTKSimSlotInfo_sync(v2, v6);
        (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v2 + 88) + 80))(*(void *)(v2 + 88), STKSimSlotInfo_sync, v5);
      }
      else if (v12)
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I SIM has not requested to be notified on language selection, not processing", buf, 2u);
      }
      if (v7) {
        sub_10004D2C8(v7);
      }
      char v14 = (void *)v3[1];
      if (v14)
      {
        do
        {
          long long v15 = v14;
          char v14 = (void *)*v14;
        }
        while (v14);
      }
      else
      {
        do
        {
          long long v15 = (void *)v3[2];
          BOOL v16 = *v15 == (void)v3;
          uint64_t v3 = v15;
        }
        while (!v16);
      }
      uint64_t v3 = v15;
    }
    while (v15 != (void *)v4);
  }
  sub_1001102C4(&v19);
  return sub_100046B58((uint64_t *)&v18);
}

void sub_1005A6920(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  if (v10) {
    sub_10004D2C8(v10);
  }
  sub_1001102C4(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

void sub_1005A6948(uint64_t **a1)
{
  uint64_t v1 = **a1;
  uint64_t v2 = *(void **)(v1 + 104);
  if (v2 != (void *)(v1 + 112))
  {
    do
    {
      uint64_t v3 = *((unsigned int *)v2 + 8);
      uint64_t v5 = v2[5];
      uint64_t v4 = (std::__shared_weak_count *)v2[6];
      if (v4) {
        atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      uint64_t v6 = (os_log_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(v1 + 48) + 16))(*(void *)(v1 + 48), v3);
      char v7 = (*(uint64_t (**)(uint64_t, void))(*(void *)v5 + 72))(v5, 0);
      uint64_t v8 = *v6;
      BOOL v9 = os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT);
      if (v7)
      {
        if (v9)
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I There is a registered request for user activity notification, notifying the SIM", buf, 2u);
        }
        uint64_t STKSimSlotInfo_sync = STK_Controller::createSTKSimSlotInfo_sync(v1, v3);
        (*(void (**)(void, uint64_t))(**(void **)(v1 + 88) + 88))(*(void *)(v1 + 88), STKSimSlotInfo_sync);
      }
      else if (v9)
      {
        *(_WORD *)long long v15 = 0;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I SIM has not requested to be notified on user activity, not processing", v15, 2u);
      }
      if (v4) {
        sub_10004D2C8(v4);
      }
      std::string v11 = (void *)v2[1];
      if (v11)
      {
        do
        {
          BOOL v12 = v11;
          std::string v11 = (void *)*v11;
        }
        while (v11);
      }
      else
      {
        do
        {
          BOOL v12 = (void *)v2[2];
          BOOL v13 = *v12 == (void)v2;
          uint64_t v2 = v12;
        }
        while (!v13);
      }
      uint64_t v2 = v12;
    }
    while (v12 != (void *)(v1 + 112));
  }
  operator delete();
}

void sub_1005A6B2C()
{
  if (v0) {
    sub_10004D2C8(v0);
  }
  operator delete();
}

uint64_t *sub_1005A6B64(uint64_t *a1)
{
  uint64_t v1 = *a1;
  char v10 = a1;
  uint64_t v11 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v3 = (os_log_t *)(*(uint64_t (**)(void, void))(**(void **)(*(void *)v1 + 48) + 16))(*(void *)(*(void *)v1 + 48), *(unsigned int *)(v1 + 8));
  uint64_t v13 = 0;
  char v14 = 0;
  STK_Controller::getStateModel_sync(v2, *(_DWORD *)(v1 + 8), &v13);
  if (v13)
  {
    if (((*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v13 + 72))(v13, 3) & 1) == 0)
    {
      uint64_t v4 = *v3;
      if (!os_log_type_enabled(*v3, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_15;
      }
      *(_WORD *)long long buf = 0;
      uint64_t v5 = "#I SIM has not requested to be notified on IMS Registration, not processing";
      goto LABEL_11;
    }
    if (*(unsigned char *)(v1 + 44) && *(_DWORD *)(v1 + 40) == 200)
    {
      uint64_t v4 = *v3;
      if (!os_log_type_enabled(*v3, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_15;
      }
      *(_WORD *)long long buf = 0;
      uint64_t v5 = "#I Skipping IMS Registration event notification";
LABEL_11:
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, v5, buf, 2u);
      goto LABEL_15;
    }
    char v7 = *v3;
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Notifying the SIM of the IMS Registration event", buf, 2u);
    }
    uint64_t STKSimSlotInfo_sync = STK_Controller::createSTKSimSlotInfo_sync(v2, *(unsigned int *)(v1 + 8));
    (*(void (**)(void, uint64_t, uint64_t, void))(**(void **)(v2 + 88) + 152))(*(void *)(v2 + 88), STKSimSlotInfo_sync, v1 + 16, *(unsigned int *)(v1 + 40));
  }
  else
  {
    uint64_t v6 = *v3;
    if (os_log_type_enabled(*v3, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "State model not found when attempting to evaluate for IMS Reg notif.", buf, 2u);
    }
  }
LABEL_15:
  if (v14) {
    sub_10004D2C8(v14);
  }
  sub_1005A6DA0(&v11);
  return sub_100046B58((uint64_t *)&v10);
}

void sub_1005A6D6C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (a14) {
    sub_10004D2C8(a14);
  }
  sub_1005A6DA0(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_1005A6DA0(uint64_t *result)
{
  uint64_t v1 = *result;
  void *result = 0;
  if (v1)
  {
    uint64_t v2 = (void **)(v1 + 16);
    sub_100047F64(&v2);
    operator delete();
  }
  return result;
}

uint64_t *sub_1005A6E00(uint64_t *a1)
{
  uint64_t v1 = *a1;
  BOOL v9 = a1;
  uint64_t v10 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v3 = (os_log_t *)(*(uint64_t (**)(void, void))(**(void **)(*(void *)v1 + 48) + 16))(*(void *)(*(void *)v1 + 48), *(unsigned int *)(v1 + 8));
  if (STK_Controller::validateState(v2, *(_DWORD *)(v1 + 8), 0))
  {
    uint64_t v4 = *(void *)(v2 + 88);
    uint64_t STKSimSlotInfo_sync = STK_Controller::createSTKSimSlotInfo_sync(v2, *(unsigned int *)(v1 + 8));
    int v6 = *(unsigned __int8 *)(v1 + 64);
    sub_10033ECA0((uint64_t)buf, v1 + 72);
    (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, BOOL, uint8_t *))(*(void *)v4 + 104))(v4, STKSimSlotInfo_sync, v1 + 16, v1 + 40, v6 != 0, buf);
    sub_1000DBADC(buf);
  }
  else
  {
    char v7 = *v3;
    if (os_log_type_enabled(*v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I failed to send SMS-PP data download", buf, 2u);
    }
    *(void *)long long buf = 0;
    uint64_t v12 = 0;
    uint64_t v13 = 0;
    sub_10033F214(v1 + 72, 0);
    if (SHIBYTE(v13) < 0) {
      operator delete(*(void **)buf);
    }
  }
  sub_1005A6FD0(&v10);
  return sub_100046B58((uint64_t *)&v9);
}

void sub_1005A6F8C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
}

uint64_t *sub_1005A6FD0(uint64_t *result)
{
  uint64_t v1 = *result;
  void *result = 0;
  if (v1)
  {
    sub_1000DBADC((void *)(v1 + 72));
    if (*(char *)(v1 + 63) < 0) {
      operator delete(*(void **)(v1 + 40));
    }
    if (*(char *)(v1 + 39) < 0) {
      operator delete(*(void **)(v1 + 16));
    }
    operator delete();
  }
  return result;
}

uint64_t sub_1005A7040(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (void *)(a2 + 24);
  uint64_t v4 = *(void *)(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(*(void *)*v3 + 24))(*v3, a1);
      return a1;
    }
    *(void *)(a1 + 24) = v4;
  }
  else
  {
    uint64_t v3 = (void *)(a1 + 24);
  }
  void *v3 = 0;
  return a1;
}

uint64_t *sub_1005A70C0(uint64_t **a1)
{
  uint64_t v1 = *a1;
  uint64_t v8 = a1;
  BOOL v9 = v1;
  uint64_t v2 = *v1;
  uint64_t v3 = *(void *)(*v1 + 88);
  unsigned int v4 = *((_DWORD *)v1 + 2);
  uint64_t STKSimSlotInfo_sync = STK_Controller::createSTKSimSlotInfo_sync(*v1, v4);
  int CurrentAccessTechnology_sync = STK_Controller::getCurrentAccessTechnology_sync(v2, v4);
  uint64_t v6 = v1[39];
  if (v6)
  {
    if ((uint64_t *)v6 == v1 + 36)
    {
      uint64_t v12 = v11;
      (*(void (**)(uint64_t, void *))(*(void *)v6 + 24))(v6, v11);
      goto LABEL_6;
    }
    uint64_t v6 = (*(uint64_t (**)(uint64_t))(*(void *)v6 + 16))(v6);
  }
  uint64_t v12 = (void *)v6;
LABEL_6:
  (*(void (**)(uint64_t, uint64_t, int *, uint64_t *, uint64_t *, void *))(*(void *)v3 + 112))(v3, STKSimSlotInfo_sync, &CurrentAccessTechnology_sync, v1 + 2, v1 + 19, v11);
  sub_1005A5234(v11);
  sub_1005A7244((uint64_t *)&v9);
  return sub_100046B58((uint64_t *)&v8);
}

void sub_1005A7218(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

uint64_t *sub_1005A7244(uint64_t *a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    sub_1005A499C(v2);
    operator delete();
  }
  return a1;
}

uint64_t sub_1005A728C(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (void *)(a2 + 24);
  uint64_t v4 = *(void *)(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(*(void *)*v3 + 24))(*v3, a1);
      return a1;
    }
    *(void *)(a1 + 24) = v4;
  }
  else
  {
    uint64_t v3 = (void *)(a1 + 24);
  }
  void *v3 = 0;
  return a1;
}

uint64_t *sub_1005A730C(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v8 = a1;
  uint64_t v9 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v3 = *(unsigned int *)(v1 + 8);
  int CurrentAccessTechnology_sync = STK_Controller::getCurrentAccessTechnology_sync(*(void *)v1, *(_DWORD *)(v1 + 8));
  if (!CurrentAccessTechnology_sync && *(unsigned char *)(v1 + 152) == 2) {
    int CurrentAccessTechnology_sync = 5;
  }
  uint64_t v4 = *(void *)(v2 + 88);
  uint64_t STKSimSlotInfo_sync = STK_Controller::createSTKSimSlotInfo_sync(v2, v3);
  uint64_t v6 = *(void *)(v1 + 184);
  if (v6)
  {
    if (v6 == v1 + 160)
    {
      uint64_t v12 = v11;
      (*(void (**)(uint64_t, void *))(*(void *)v6 + 24))(v6, v11);
      goto LABEL_9;
    }
    uint64_t v6 = (*(uint64_t (**)(uint64_t))(*(void *)v6 + 16))(v6);
  }
  uint64_t v12 = (void *)v6;
LABEL_9:
  (*(void (**)(uint64_t, uint64_t, int *, uint64_t, void *))(*(void *)v4 + 120))(v4, STKSimSlotInfo_sync, &CurrentAccessTechnology_sync, v1 + 16, v11);
  sub_1005A52B8(v11);
  sub_1005A749C(&v9);
  return sub_100046B58((uint64_t *)&v8);
}

void sub_1005A7470(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

uint64_t *sub_1005A749C(uint64_t *result)
{
  uint64_t v1 = *result;
  void *result = 0;
  if (v1)
  {
    sub_1005A52B8((void *)(v1 + 160));
    if (*(char *)(v1 + 127) < 0) {
      operator delete(*(void **)(v1 + 104));
    }
    if (*(char *)(v1 + 103) < 0) {
      operator delete(*(void **)(v1 + 80));
    }
    if (*(char *)(v1 + 71) < 0) {
      operator delete(*(void **)(v1 + 48));
    }
    if (*(char *)(v1 + 47) < 0) {
      operator delete(*(void **)(v1 + 24));
    }
    operator delete();
  }
  return result;
}

uint64_t *sub_1005A752C(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v5 = a1;
  uint64_t v6 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t STKSimSlotInfo_sync = STK_Controller::createSTKSimSlotInfo_sync(*(void *)v1, *(unsigned int *)(v1 + 8));
  (*(void (**)(void, uint64_t, uint64_t, void, uint64_t))(**(void **)(v2 + 88) + 128))(*(void *)(v2 + 88), STKSimSlotInfo_sync, v1 + 16, *(unsigned int *)(v1 + 40), v1 + 48);
  sub_1005A75CC(&v6);
  return sub_100046B58((uint64_t *)&v5);
}

void sub_1005A75B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

uint64_t *sub_1005A75CC(uint64_t *result)
{
  uint64_t v1 = *result;
  void *result = 0;
  if (v1)
  {
    if (*(char *)(v1 + 159) < 0) {
      operator delete(*(void **)(v1 + 136));
    }
    if (*(char *)(v1 + 135) < 0) {
      operator delete(*(void **)(v1 + 112));
    }
    if (*(char *)(v1 + 103) < 0) {
      operator delete(*(void **)(v1 + 80));
    }
    if (*(char *)(v1 + 79) < 0) {
      operator delete(*(void **)(v1 + 56));
    }
    if (*(char *)(v1 + 39) < 0) {
      operator delete(*(void **)(v1 + 16));
    }
    operator delete();
  }
  return result;
}

uint64_t *sub_1005A7664(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v5 = a1;
  uint64_t v6 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t STKSimSlotInfo_sync = STK_Controller::createSTKSimSlotInfo_sync(*(void *)v1, *(unsigned int *)(v1 + 8));
  (*(void (**)(void, uint64_t, uint64_t, void, void))(**(void **)(v2 + 88) + 136))(*(void *)(v2 + 88), STKSimSlotInfo_sync, v1 + 16, *(unsigned int *)(v1 + 40), *(unsigned __int8 *)(v1 + 44));
  sub_1005A7704(&v6);
  return sub_100046B58((uint64_t *)&v5);
}

void sub_1005A76E8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

uint64_t *sub_1005A7704(uint64_t *result)
{
  uint64_t v1 = *result;
  void *result = 0;
  if (v1)
  {
    if (*(char *)(v1 + 39) < 0) {
      operator delete(*(void **)(v1 + 16));
    }
    operator delete();
  }
  return result;
}

uint64_t *sub_1005A775C(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v5 = a1;
  uint64_t v6 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t STKSimSlotInfo_sync = STK_Controller::createSTKSimSlotInfo_sync(*(void *)v1, *(unsigned int *)(v1 + 8));
  (*(void (**)(void, uint64_t, uint64_t, void, void))(**(void **)(v2 + 88) + 144))(*(void *)(v2 + 88), STKSimSlotInfo_sync, v1 + 16, *(unsigned int *)(v1 + 40), *(unsigned __int8 *)(v1 + 44));
  sub_1005A7704(&v6);
  return sub_100046B58((uint64_t *)&v5);
}

void sub_1005A77E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

uint64_t stewie::ServiceWindow::ServiceWindow(uint64_t a1, void *a2, void *a3, char a4, void *a5, void *a6)
{
  *(void *)a1 = *a2;
  *(void *)(a1 + 8) = *a3;
  *(unsigned char *)(a1 + 16) = a4;
  *(void *)(a1 + 24) = *a5;
  *(void *)(a1 + 32) = *a6;
  if (!stewie::ServiceWindow::debugCheck((stewie::ServiceWindow *)a1)) {
    __assert_rtn("ServiceWindow", "ConnectionAssistantServiceWindow_ios.cpp", 31, "debugCheck()");
  }
  return a1;
}

BOOL stewie::ServiceWindow::debugCheck(stewie::ServiceWindow *this)
{
  if (!*(void *)this || !*((void *)this + 1)) {
    return 0;
  }
  unint64_t v1 = *((void *)this + 3);
  unint64_t v2 = *((void *)this + 4);
  if (*((unsigned char *)this + 16))
  {
    BOOL v3 = v2 == 0;
    BOOL v4 = v2 - 1 >= v1;
  }
  else
  {
    BOOL v3 = 1;
    if (v2) {
      BOOL v6 = v2 >= v1;
    }
    else {
      BOOL v6 = 1;
    }
    BOOL v4 = !v6;
  }
  if (v1) {
    return v4;
  }
  else {
    return v3;
  }
}

uint64_t sub_1005A78C4(uint64_t a1, void *a2)
{
  BOOL v4 = (ctu::OsLogLogger *)(a1 + 8);
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v7, kCtLoggingSystemName, "sub.eval");
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v8, &v7);
  ctu::OsLogLogger::OsLogLogger(v4, (const ctu::OsLogLogger *)v8);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v8);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v7);
  *(void *)a1 = off_1019E9F88;
  *(void *)(a1 + 16) = *a2;
  uint64_t v5 = a2[1];
  *(void *)(a1 + 24) = v5;
  if (v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
  }
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 32) = a1 + 40;
  *(void *)(a1 + 112) = 0;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(void *)(a1 + 104) = a1 + 112;
  *(void *)(a1 + 144) = 0;
  *(void *)(a1 + 136) = 0;
  *(void *)(a1 + 120) = 0;
  *(void *)(a1 + 128) = a1 + 136;
  return a1;
}

void sub_1005A79D8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v4 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)va1);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)va);
  SubscriptionConfigurationEvaluatorInterface::~SubscriptionConfigurationEvaluatorInterface(v2);
  _Unwind_Resume(a1);
}

uint64_t **sub_1005A7A0C(uint64_t a1, uint64_t **a2)
{
  uint64_t result = (uint64_t **)(a1 + 32);
  if (result != a2) {
    return sub_100429B2C(result, *a2, a2 + 1);
  }
  return result;
}

void sub_1005A7A28(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *a2;
  uint64_t v4 = a2[1];
  if (*a2 != v4)
  {
    do
    {
      if (subscriber::isEsimCapable()) {
        goto LABEL_122;
      }
      uint64_t v5 = *(void *)(a1 + 56);
      uint64_t v6 = *(void *)(a1 + 64);
      sub_10002E664((uint64_t)v44, v3);
      if (v5 != v6)
      {
        if ((v49 & 0x80u) == 0) {
          unint64_t v7 = v49;
        }
        else {
          unint64_t v7 = (unint64_t)v48[1];
        }
        if ((v49 & 0x80u) == 0) {
          uint64_t v8 = v48;
        }
        else {
          uint64_t v8 = (void **)v48[0];
        }
        do
        {
          uint64_t v9 = *(unsigned __int8 *)(v5 + 95);
          if ((v9 & 0x80u) == 0) {
            uint64_t v10 = (void *)*(unsigned __int8 *)(v5 + 95);
          }
          else {
            uint64_t v10 = *(void **)(v5 + 80);
          }
          if (v10 == (void *)v7)
          {
            if ((v9 & 0x80) != 0)
            {
              if (!memcmp(*(const void **)(v5 + 72), v8, *(void *)(v5 + 80))) {
                goto LABEL_23;
              }
            }
            else
            {
              if (!*(unsigned char *)(v5 + 95)) {
                goto LABEL_23;
              }
              uint64_t v11 = 0;
              while (*(unsigned __int8 *)(v5 + v11 + 72) == *((unsigned __int8 *)v8 + v11))
              {
                if (v9 == ++v11) {
                  goto LABEL_23;
                }
              }
            }
          }
          v5 += 168;
        }
        while (v5 != v6);
        uint64_t v5 = v6;
      }
LABEL_23:
      if (v55 < 0) {
        operator delete(__p);
      }
      if (v53 < 0) {
        operator delete(v52);
      }
      if (v51 < 0) {
        operator delete(v50);
      }
      if ((char)v49 < 0) {
        operator delete(v48[0]);
      }
      *(void *)long long buf = &v47;
      sub_10002E39C((void ***)buf);
      if (v45)
      {
        long long v46 = v45;
        operator delete(v45);
      }
      if (v5 != *(void *)(a1 + 64) && (BasicSimInfo::operator==() & 1) != 0
        || !subscriber::isSimReady())
      {
        goto LABEL_122;
      }
      ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 16));
      uint64_t v13 = ServiceMap;
      if (v14 < 0)
      {
        long long v15 = (unsigned __int8 *)(v14 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v16 = 5381;
        do
        {
          uint64_t v14 = v16;
          unsigned int v17 = *v15++;
          uint64_t v16 = (33 * v16) ^ v17;
        }
        while (v17);
      }
      std::mutex::lock(ServiceMap);
      *(void *)long long buf = v14;
      long long v18 = sub_10004D37C(&v13[1].__m_.__sig, (unint64_t *)buf);
      if (v18)
      {
        uint64_t v19 = v18[3];
        uint64_t v20 = (std::__shared_weak_count *)v18[4];
        if (v20)
        {
          atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v13);
          atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v20);
          char v21 = 0;
          if (v19) {
            goto LABEL_46;
          }
          goto LABEL_42;
        }
      }
      else
      {
        uint64_t v19 = 0;
      }
      std::mutex::unlock(v13);
      uint64_t v20 = 0;
      char v21 = 1;
      if (v19)
      {
LABEL_46:
        long long __dst = 0uLL;
        uint64_t v66 = 0;
        char v43 = v21;
        if (*(char *)(v3 + 95) < 0)
        {
          sub_10004FC84(&__dst, *(void **)(v3 + 72), *(void *)(v3 + 80));
        }
        else
        {
          long long __dst = *(_OWORD *)(v3 + 72);
          uint64_t v66 = *(void *)(v3 + 88);
        }
        BOOL v23 = *(NSObject **)(a1 + 8);
        if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v24 = *(void *)(v3 + 96);
          if (*(char *)(v3 + 95) >= 0) {
            uint64_t v25 = v3 + 72;
          }
          else {
            uint64_t v25 = *(void *)(v3 + 72);
          }
          if (*(char *)(v3 + 119) >= 0) {
            uint64_t v24 = v3 + 96;
          }
          if (*(char *)(v3 + 143) >= 0) {
            uint64_t v26 = v3 + 120;
          }
          else {
            uint64_t v26 = *(void *)(v3 + 120);
          }
          uint64_t v27 = v3 + 144;
          if (*(char *)(v3 + 167) < 0) {
            uint64_t v27 = *(void *)(v3 + 144);
          }
          *(_DWORD *)long long buf = 136315906;
          *(void *)&uint8_t buf[4] = v25;
          *(_WORD *)&unsigned char buf[12] = 2080;
          *(void *)&buf[14] = v24;
          *(_WORD *)&buf[22] = 2080;
          uint64_t v73 = v26;
          __int16 v74 = 2080;
          uint64_t v75 = v27;
          _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "#I SIM (%s) : Storing last known IMSI (%s) GID1 (%s) GID2 (%s)", buf, 0x2Au);
        }
        long long v64 = 0;
        if (*(char *)(v3 + 119) < 0)
        {
          sub_10004FC84(&v62, *(void **)(v3 + 96), *(void *)(v3 + 104));
        }
        else
        {
          long long v62 = *(_OWORD *)(v3 + 96);
          uint64_t v63 = *(void *)(v3 + 112);
        }
        if (SHIBYTE(v63) < 0)
        {
          sub_10004FC84(&v68, (void *)v62, *((unint64_t *)&v62 + 1));
        }
        else
        {
          long long v68 = v62;
          uint64_t v69 = v63;
        }
        uint64_t v71 = 0;
        if (SHIBYTE(v69) < 0)
        {
          sub_10004FC84(buf, (void *)v68, *((unint64_t *)&v68 + 1));
        }
        else
        {
          *(_OWORD *)long long buf = v68;
          *(void *)&uint8_t buf[16] = v69;
        }
        *(void *)&long long v56 = 0;
        if (ctu::cf::convert_copy())
        {
          BOOL v28 = v71;
          uint64_t v71 = (const void *)v56;
          *(void *)&long long v59 = v28;
          sub_1000558F4((const void **)&v59);
        }
        if ((buf[23] & 0x80000000) != 0) {
          operator delete(*(void **)buf);
        }
        long long v64 = v71;
        uint64_t v71 = 0;
        sub_1000558F4(&v71);
        if (SHIBYTE(v69) < 0) {
          operator delete((void *)v68);
        }
        if (SHIBYTE(v63) < 0) {
          operator delete((void *)v62);
        }
        if ((*(unsigned int (**)(uint64_t, long long *, const __CFString *, const void *, const __CFString *, void, uint64_t, void))(*(void *)v19 + 16))(v19, &__dst, @"IMSI", v64, @"SubscriptionConfiguration", 0, 1, 0))
        {
          uint32_t v29 = *(NSObject **)(a1 + 8);
          if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
          {
            if (*(char *)(v3 + 119) >= 0) {
              uint64_t v36 = v3 + 96;
            }
            else {
              uint64_t v36 = *(void *)(v3 + 96);
            }
            if (*(char *)(v3 + 95) >= 0) {
              uint64_t v37 = v3 + 72;
            }
            else {
              uint64_t v37 = *(void *)(v3 + 72);
            }
            *(_DWORD *)long long buf = 136315394;
            *(void *)&uint8_t buf[4] = v36;
            *(_WORD *)&unsigned char buf[12] = 2080;
            *(void *)&buf[14] = v37;
            _os_log_error_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_ERROR, "Failed to store IMSI (%s) for SIM (%s)", buf, 0x16u);
          }
        }
        uint64_t v61 = 0;
        if (*(char *)(v3 + 143) < 0)
        {
          sub_10004FC84(&v59, *(void **)(v3 + 120), *(void *)(v3 + 128));
        }
        else
        {
          long long v59 = *(_OWORD *)(v3 + 120);
          uint64_t v60 = *(void *)(v3 + 136);
        }
        if (SHIBYTE(v60) < 0)
        {
          sub_10004FC84(&v68, (void *)v59, *((unint64_t *)&v59 + 1));
        }
        else
        {
          long long v68 = v59;
          uint64_t v69 = v60;
        }
        xpc_object_t v70 = 0;
        if (SHIBYTE(v69) < 0)
        {
          sub_10004FC84(buf, (void *)v68, *((unint64_t *)&v68 + 1));
        }
        else
        {
          *(_OWORD *)long long buf = v68;
          *(void *)&uint8_t buf[16] = v69;
        }
        uint64_t v71 = 0;
        if (ctu::cf::convert_copy())
        {
          uint64_t v30 = v70;
          xpc_object_t v70 = v71;
          *(void *)&long long v56 = v30;
          sub_1000558F4((const void **)&v56);
        }
        if ((buf[23] & 0x80000000) != 0) {
          operator delete(*(void **)buf);
        }
        uint64_t v61 = v70;
        xpc_object_t v70 = 0;
        sub_1000558F4(&v70);
        if (SHIBYTE(v69) < 0) {
          operator delete((void *)v68);
        }
        if (SHIBYTE(v60) < 0) {
          operator delete((void *)v59);
        }
        if ((*(unsigned int (**)(uint64_t, long long *, const __CFString *, const void *, const __CFString *, void, uint64_t, void))(*(void *)v19 + 16))(v19, &__dst, @"GID1", v61, @"SubscriptionConfiguration", 0, 1, 0))
        {
          long long v31 = *(NSObject **)(a1 + 8);
          if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
          {
            if (*(char *)(v3 + 143) >= 0) {
              uint64_t v38 = v3 + 120;
            }
            else {
              uint64_t v38 = *(void *)(v3 + 120);
            }
            if (*(char *)(v3 + 95) >= 0) {
              uint64_t v39 = v3 + 72;
            }
            else {
              uint64_t v39 = *(void *)(v3 + 72);
            }
            *(_DWORD *)long long buf = 136315394;
            *(void *)&uint8_t buf[4] = v38;
            *(_WORD *)&unsigned char buf[12] = 2080;
            *(void *)&buf[14] = v39;
            _os_log_error_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_ERROR, "Failed to store GID1 (%s) for SIM (%s)", buf, 0x16u);
          }
        }
        if (*(char *)(v3 + 167) < 0)
        {
          sub_10004FC84(&v56, *(void **)(v3 + 144), *(void *)(v3 + 152));
        }
        else
        {
          long long v56 = *(_OWORD *)(v3 + 144);
          uint64_t v57 = *(void *)(v3 + 160);
        }
        if (SHIBYTE(v57) < 0)
        {
          sub_10004FC84(&v68, (void *)v56, *((unint64_t *)&v56 + 1));
        }
        else
        {
          long long v68 = v56;
          uint64_t v69 = v57;
        }
        xpc_object_t v67 = 0;
        if (SHIBYTE(v69) < 0)
        {
          sub_10004FC84(buf, (void *)v68, *((unint64_t *)&v68 + 1));
        }
        else
        {
          *(_OWORD *)long long buf = v68;
          *(void *)&uint8_t buf[16] = v69;
        }
        xpc_object_t v70 = 0;
        if (ctu::cf::convert_copy())
        {
          long long v32 = v67;
          xpc_object_t v67 = v70;
          uint64_t v71 = v32;
          sub_1000558F4(&v71);
        }
        if ((buf[23] & 0x80000000) != 0) {
          operator delete(*(void **)buf);
        }
        int v33 = v67;
        uint64_t v58 = v67;
        xpc_object_t v67 = 0;
        sub_1000558F4(&v67);
        if (SHIBYTE(v69) < 0) {
          operator delete((void *)v68);
        }
        if (SHIBYTE(v57) < 0) {
          operator delete((void *)v56);
        }
        int v34 = (*(uint64_t (**)(uint64_t, long long *, const __CFString *, const void *, const __CFString *, void, uint64_t, void))(*(void *)v19 + 16))(v19, &__dst, @"GID2", v33, @"SubscriptionConfiguration", 0, 1, 0);
        char v21 = v43;
        if (v34)
        {
          long long v35 = *(NSObject **)(a1 + 8);
          if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
          {
            if (*(char *)(v3 + 167) >= 0) {
              uint64_t v40 = v3 + 144;
            }
            else {
              uint64_t v40 = *(void *)(v3 + 144);
            }
            if (*(char *)(v3 + 95) >= 0) {
              uint64_t v41 = v3 + 72;
            }
            else {
              uint64_t v41 = *(void *)(v3 + 72);
            }
            *(_DWORD *)long long buf = 136315394;
            *(void *)&uint8_t buf[4] = v40;
            *(_WORD *)&unsigned char buf[12] = 2080;
            *(void *)&buf[14] = v41;
            _os_log_error_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_ERROR, "Failed to store GID2 (%s) for SIM (%s)", buf, 0x16u);
          }
        }
        sub_1000558F4(&v58);
        sub_1000558F4(&v61);
        sub_1000558F4(&v64);
        if (SHIBYTE(v66) < 0) {
          operator delete((void *)__dst);
        }
        goto LABEL_120;
      }
LABEL_42:
      os_log_t v22 = *(NSObject **)(a1 + 8);
      if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_ERROR, "PersonalWallet interface not available", buf, 2u);
      }
LABEL_120:
      if ((v21 & 1) == 0) {
        sub_10004D2C8(v20);
      }
LABEL_122:
      v3 += 168;
    }
    while (v3 != v4);
  }
  if ((uint64_t *)(a1 + 56) != a2) {
    sub_1003DB990(a1 + 56, *a2, a2[1], 0xCF3CF3CF3CF3CF3DLL * ((a2[1] - *a2) >> 3));
  }
}

void sub_1005A8398(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, int a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,void *__p,uint64_t a41,int a42,__int16 a43,char a44,char a45,char a46,void *a47,uint64_t a48,int a49,__int16 a50,char a51,char a52,const void *a53,void *a54,uint64_t a55,int a56,__int16 a57,char a58,char a59)
{
  sub_1000558F4((const void **)(v60 - 216));
  if (*(char *)(v60 - 185) < 0) {
    operator delete(*(void **)(v60 - 208));
  }
  if (a45 < 0) {
    operator delete(__p);
  }
  sub_1000558F4(&a53);
  sub_1000558F4((const void **)(v60 - 248));
  if (*(char *)(v60 - 217) < 0) {
    operator delete(*(void **)(v60 - 240));
  }
  if ((a17 & 1) == 0) {
    sub_10004D2C8(v59);
  }
  _Unwind_Resume(a1);
}

void sub_1005A850C(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = a1 + 80;
  if ((uint64_t *)v2 != a2) {
    sub_1003DB294(v2, *a2, a2[1], 0x2E8BA2E8BA2E8BA3 * ((a2[1] - *a2) >> 3));
  }
}

uint64_t sub_1005A8544(uint64_t a1, uint64_t a2)
{
  long long v37 = 0u;
  long long v38 = 0u;
  long long v35 = 0u;
  long long v36 = 0u;
  long long v33 = 0u;
  long long v34 = 0u;
  long long v32 = 0u;
  memset(v31, 0, sizeof(v31));
  sub_1005A88B8(v31, *(_DWORD **)(a1 + 56), *(_DWORD **)(a1 + 64), a2);
  if (BYTE8(v38))
  {
    uint64_t v4 = HIBYTE(v33);
    if (v33 < 0) {
      uint64_t v4 = v33;
    }
    if (v4 && (subscriber::isSimReady() & 1) != 0)
    {
      *(void *)uint64_t v30 = 0;
      CFMutableArrayRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
      if (Mutable)
      {
        uint64_t v6 = *(__CFArray **)v30;
        *(void *)uint64_t v30 = Mutable;
        *(void *)long long buf = v6;
        sub_1000440D4((const void **)buf);
      }
      sub_1001C6B94(*(__CFArray **)v30, @"PreferLastUsedImei");
      CFTypeRef cf = 0;
      ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 16));
      uint64_t v8 = ServiceMap;
      if (v9 < 0)
      {
        uint64_t v10 = (unsigned __int8 *)(v9 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v11 = 5381;
        do
        {
          uint64_t v9 = v11;
          unsigned int v12 = *v10++;
          uint64_t v11 = (33 * v11) ^ v12;
        }
        while (v12);
      }
      std::mutex::lock(ServiceMap);
      *(void *)long long buf = v9;
      uint64_t v13 = sub_10004D37C(&v8[1].__m_.__sig, (unint64_t *)buf);
      if (v13)
      {
        uint64_t v15 = v13[3];
        uint64_t v14 = (std::__shared_weak_count *)v13[4];
        if (v14)
        {
          atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v8);
          atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v14);
          char v16 = 0;
LABEL_16:
          (*(void (**)(CFTypeRef *__return_ptr, uint64_t, uint64_t, uint64_t, const __CFString *, const CFBooleanRef, void))(*(void *)v15 + 80))(&cf, v15, a2, 1, @"PreferLastUsedImei", kCFBooleanFalse, 0);
          if ((v16 & 1) == 0) {
            sub_10004D2C8(v14);
          }
          unsigned int v17 = (BOOL *)cf;
          buf[0] = 0;
          if (cf && (CFTypeID v18 = CFGetTypeID(cf), v18 == CFBooleanGetTypeID()))
          {
            ctu::cf::assign((ctu::cf *)buf, v17, v19);
            char v20 = buf[0];
          }
          else
          {
            char v20 = 0;
          }
          char v28 = v20;
          char v21 = *(NSObject **)(a1 + 8);
          if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
          {
            int v23 = SHIBYTE(v33);
            uint64_t v24 = (char *)*((void *)&v32 + 1);
            uint64_t v25 = printers::asString((printers *)&v28, v22);
            if (v23 >= 0) {
              uint64_t v26 = (char *)&v32 + 8;
            }
            else {
              uint64_t v26 = v24;
            }
            *(_DWORD *)long long buf = 136315394;
            *(void *)&uint8_t buf[4] = v26;
            __int16 v40 = 2080;
            uint64_t v41 = v25;
            _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "#I Bundle update : PreferLastUsedImei: %s : %s", buf, 0x16u);
            char v20 = v28;
          }
          *(void *)long long buf = (char *)&v32 + 8;
          *((unsigned char *)sub_1000ED870((uint64_t **)(a1 + 128), (void **)&v32 + 1, (uint64_t)&unk_10144E20E, (long long **)buf)
          + 56) = v20;
          sub_1000577C4(&cf);
          sub_1000440D4((const void **)v30);
          return sub_100397998((uint64_t)v31);
        }
      }
      else
      {
        uint64_t v15 = 0;
      }
      std::mutex::unlock(v8);
      uint64_t v14 = 0;
      char v16 = 1;
      goto LABEL_16;
    }
  }
  return sub_100397998((uint64_t)v31);
}

void sub_1005A8850(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va2, a3);
  va_start(va1, a3);
  va_start(va, a3);
  uint64_t v4 = va_arg(va1, const void *);
  va_copy(va2, va1);
  uint64_t v6 = va_arg(va2, const void *);
  sub_1000577C4((const void **)va);
  sub_1000440D4((const void **)va1);
  sub_100397998((uint64_t)va2);
  _Unwind_Resume(a1);
}

unsigned char *sub_1005A88B8(unsigned char *result, _DWORD *a2, _DWORD *a3, int a4)
{
  if (!a4) {
    goto LABEL_8;
  }
  if (a2 != a3)
  {
    while (*a2 != a4)
    {
      a2 += 42;
      if (a2 == a3) {
        goto LABEL_8;
      }
    }
  }
  if (a2 == a3)
  {
LABEL_8:
    char v4 = 0;
    void *result = 0;
  }
  else
  {
    uint64_t result = (unsigned char *)sub_10002E664((uint64_t)result, (uint64_t)a2);
    char v4 = 1;
  }
  result[168] = v4;
  return result;
}

unint64_t sub_1005A8914(uint64_t a1, std::string ***a2)
{
  char v4 = *(NSObject **)(a1 + 8);
  v260 = (os_log_t *)(a1 + 8);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    sub_1000E8F34((std::string *)*a2, (std::string *)(a2 + 1), ", ", 2uLL, (std::string *)__p);
    uint64_t v5 = __p[23] >= 0 ? __p : *(unsigned char **)__p;
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Evaluating configuration for (%s)", buf, 0xCu);
    if ((__p[23] & 0x80000000) != 0) {
      operator delete(*(void **)__p);
    }
  }
  unint64_t v6 = *(void *)(a1 + 48);
  if (!v6 || (unint64_t)a2[2] > v6)
  {
    os_log_t v7 = *v260;
    if (!os_log_type_enabled(*v260, OS_LOG_TYPE_ERROR))
    {
LABEL_10:
      unsigned __int8 v8 = 0;
      unint64_t v9 = 0;
      return v9 & 0xFFFFFFFFFFFFFF00 | v8;
    }
    long long v38 = a2[2];
    *(_DWORD *)long long __p = 134218240;
    *(void *)&__p[4] = v38;
    *(_WORD *)&unsigned char __p[12] = 2048;
    *(void *)&__p[14] = v6;
    char v16 = "Evaluator does not support (%ld) SIMs, num of IMEIs (%ld)";
    unsigned int v17 = v7;
    goto LABEL_51;
  }
  uint64_t v12 = *(void *)(a1 + 56);
  uint64_t v11 = *(void *)(a1 + 64);
  if (v12 != v11)
  {
    while (1)
    {
      sub_10002E664((uint64_t)__p, v12);
      int v13 = (int)v323[0];
      if (SBYTE7(v327[0]) < 0) {
        operator delete(v326[0]);
      }
      if (SHIBYTE(v325[1]) < 0) {
        operator delete(*((void **)&v325[0] + 1));
      }
      if (SBYTE7(v325[0]) < 0) {
        operator delete(v324[0]);
      }
      if (SHIBYTE(v323[3]) < 0) {
        operator delete(v323[1]);
      }
      *(void *)long long buf = (char *)&v321 + 8;
      sub_10002E39C((void ***)buf);
      if (*(void *)&__p[16])
      {
        *(void *)&__p[24] = *(void *)&__p[16];
        operator delete(*(void **)&__p[16]);
      }
      if (!v13) {
        break;
      }
      v12 += 168;
      if (v12 == v11) {
        goto LABEL_25;
      }
    }
    os_log_t v15 = *v260;
    if (!os_log_type_enabled(*v260, OS_LOG_TYPE_ERROR)) {
      goto LABEL_10;
    }
    *(_WORD *)long long __p = 0;
    char v16 = "VinylCapability is kUnknown";
    unsigned int v17 = v15;
    uint32_t v18 = 2;
    goto LABEL_52;
  }
LABEL_25:
  uint64_t v264 = 0;
  SubscriptionSlotConfiguration::SubscriptionSlotConfiguration((SubscriptionSlotConfiguration *)&v264);
  if (*(void *)(a1 + 48) == 1)
  {
    if (capabilities::ct::supportsGemini(v14))
    {
      LODWORD(v264) = 1;
      unsigned __int8 v8 = 1;
      unint64_t v9 = v264 & 0xFFFFFFFFFFFFFF00;
      return v9 & 0xFFFFFFFFFFFFFF00 | v8;
    }
    if (!a2[2])
    {
      sub_1005ABCB0(*(Registry **)(a1 + 16), __p);
      uint64_t v39 = (capabilities::ct *)(*(uint64_t (**)(void))(**(void **)__p + 72))(*(void *)__p);
      if (v39)
      {
        int v40 = capabilities::ct::supportsRegulatoryRestriction(v39);
        if (*(void *)&__p[8]) {
          sub_10004D2C8(*(std::__shared_weak_count **)&__p[8]);
        }
        if (v40)
        {
          unsigned __int8 v8 = v264;
          unint64_t v9 = v264 & 0xFFFFFFFFFFFFFF00;
          return v9 & 0xFFFFFFFFFFFFFF00 | v8;
        }
      }
      else if (*(void *)&__p[8])
      {
        sub_10004D2C8(*(std::__shared_weak_count **)&__p[8]);
      }
      os_log_t v58 = *v260;
      if (!os_log_type_enabled(*v260, OS_LOG_TYPE_ERROR)) {
        goto LABEL_10;
      }
      long long v59 = a2[2];
      uint64_t v60 = *(void *)(a1 + 48);
      *(_DWORD *)long long __p = 134218240;
      *(void *)&__p[4] = v59;
      *(_WORD *)&unsigned char __p[12] = 2048;
      *(void *)&__p[14] = v60;
      char v16 = "Evaluator does not support (%ld) SIMs, num of IMEIs (%ld)";
      unsigned int v17 = v58;
LABEL_51:
      uint32_t v18 = 22;
LABEL_52:
      _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, v16, __p, v18);
      goto LABEL_10;
    }
  }
  char v20 = (std::string **)(a2 + 1);
  CFBooleanRef v19 = (std::string *)*a2;
  if (*a2 != (std::string **)(a2 + 1))
  {
    while (1)
    {
      p_std::string::size_type size = &v19[1].__r_.__value_.__l.__size_;
      sub_1005ABD78(__p, (uint64_t *)(a1 + 56), (uint64_t)&v19[1].__r_.__value_.__l.__size_);
      int v22 = BYTE8(v327[0]);
      sub_100397998((uint64_t)__p);
      if (!v22) {
        break;
      }
      std::string::size_type size = (std::string *)v19->__r_.__value_.__l.__size_;
      if (size)
      {
        do
        {
          uint64_t v24 = (std::string **)size;
          std::string::size_type size = (std::string *)size->__r_.__value_.__r.__words[0];
        }
        while (size);
      }
      else
      {
        do
        {
          uint64_t v24 = (std::string **)v19->__r_.__value_.__r.__words[2];
          BOOL v25 = *v24 == v19;
          CFBooleanRef v19 = (std::string *)v24;
        }
        while (!v25);
      }
      CFBooleanRef v19 = (std::string *)v24;
      if (v24 == v20) {
        goto LABEL_39;
      }
    }
    os_log_t v37 = *v260;
    if (!os_log_type_enabled(*v260, OS_LOG_TYPE_ERROR)) {
      goto LABEL_10;
    }
    if (v19[2].__r_.__value_.__s.__data_[7] < 0) {
      p_std::string::size_type size = (std::string::size_type *)*p_size;
    }
    *(_DWORD *)long long __p = 136315138;
    *(void *)&__p[4] = p_size;
    char v16 = "SIM (%s) not found, leaving with no assignment";
    unsigned int v17 = v37;
    uint32_t v18 = 12;
    goto LABEL_52;
  }
LABEL_39:
  v261 = 0;
  v262 = 0;
  uint64_t v263 = 0;
  v259 = (uint64_t **)(a1 + 104);
  uint64_t v26 = sub_10008CF3C((uint64_t *)&v261, a1 + 104);
  v253 = a2;
  if (capabilities::ct::supportsHydra((capabilities::ct *)v26))
  {
    ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 16));
    char v28 = ServiceMap;
    if (v29 < 0)
    {
      uint64_t v30 = (unsigned __int8 *)(v29 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v31 = 5381;
      do
      {
        uint64_t v29 = v31;
        unsigned int v32 = *v30++;
        uint64_t v31 = (33 * v31) ^ v32;
      }
      while (v32);
    }
    std::mutex::lock(ServiceMap);
    *(void *)long long __p = v29;
    long long v33 = sub_10004D37C(&v28[1].__m_.__sig, (unint64_t *)__p);
    if (v33)
    {
      uint64_t v34 = v33[3];
      long long v35 = (std::__shared_weak_count *)v33[4];
      if (v35)
      {
        atomic_fetch_add_explicit(&v35->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v28);
        atomic_fetch_add_explicit(&v35->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v35);
        char v36 = 0;
LABEL_60:
        if (v34
          && (unint64_t v41 = (*(uint64_t (**)(uint64_t))(*(void *)v34 + 128))(v34), (v41 & 0xFF00000000) != 0))
        {
          uint64_t v42 = (v41 >> 4) & 1;
        }
        else
        {
          LOBYTE(v42) = 0;
        }
        if ((v36 & 1) == 0) {
          sub_10004D2C8(v35);
        }
        a2 = v253;
        if (v42) {
          goto LABEL_67;
        }
        uint64_t v56 = *(void *)(a1 + 56);
        uint64_t v57 = *(void *)(a1 + 64);
        while (1)
        {
          if (v56 == v57) {
            goto LABEL_67;
          }
          if (subscriber::isEsimCapable() && !subscriber::isVirtualEsim()) {
            break;
          }
          v56 += 168;
        }
        uint64_t v61 = *(void *)(a1 + 104);
        v257 = (uint64_t *)(a1 + 112);
        if (v61 != a1 + 112)
        {
          do
          {
            long long v62 = (void *)(v61 + 40);
            if (sub_10010E128((uint64_t)v253, (void **)(v61 + 40)))
            {
              uint64_t v63 = *(uint64_t **)(v61 + 8);
              if (v63)
              {
                do
                {
                  long long v64 = v63;
                  uint64_t v63 = (uint64_t *)*v63;
                }
                while (v63);
              }
              else
              {
                do
                {
                  long long v64 = *(uint64_t **)(v61 + 16);
                  BOOL v25 = *v64 == v61;
                  uint64_t v61 = (uint64_t)v64;
                }
                while (!v25);
              }
            }
            else
            {
              uint64_t v65 = *v260;
              if (os_log_type_enabled(*v260, OS_LOG_TYPE_DEFAULT))
              {
                if (*(char *)(v61 + 63) < 0) {
                  long long v62 = (void *)*v62;
                }
                *(_DWORD *)long long __p = 136315138;
                *(void *)&__p[4] = v62;
                _os_log_impl((void *)&_mh_execute_header, v65, OS_LOG_TYPE_DEFAULT, "#I SIM (%s) is no longer enabled", __p, 0xCu);
              }
              long long v64 = sub_1003DE770(v259, v61);
            }
            uint64_t v61 = (uint64_t)v64;
          }
          while (v64 != v257);
        }
        subscriber::makeSimSlotRange();
        uint64_t v66 = *(unsigned int **)__p;
        xpc_object_t v67 = *(unsigned int **)&__p[8];
        if (*(void *)__p != *(void *)&__p[8])
        {
          long long v68 = *(uint64_t (**)(void))&__p[16];
          do
          {
            if (v68(*v66)) {
              goto LABEL_120;
            }
            ++v66;
          }
          while (v66 != v67);
          uint64_t v66 = v67;
LABEL_120:
          uint64_t v69 = *(unsigned int **)&__p[8];
LABEL_121:
          while (v66 != v69)
          {
            signed int v70 = *v66;
            uint64_t v71 = (uint64_t **)(a1 + 112);
            while (1)
            {
              xpc_object_t v72 = *v71;
              uint64_t v73 = v71;
              if (!*v71) {
                break;
              }
              while (1)
              {
                uint64_t v71 = (uint64_t **)v72;
                signed int v74 = *((_DWORD *)v72 + 8);
                if (v74 > v70) {
                  break;
                }
                if (v74 >= v70) {
                  goto LABEL_129;
                }
                xpc_object_t v72 = v71[1];
                if (!v72)
                {
                  uint64_t v73 = v71 + 1;
                  goto LABEL_128;
                }
              }
            }
LABEL_128:
            uint64_t v75 = operator new(0x40uLL);
            v75[8] = v70;
            *((void *)v75 + 6) = 0;
            *((void *)v75 + 7) = 0;
            *((void *)v75 + 5) = 0;
            sub_100046C38(v259, (uint64_t)v71, v73, (uint64_t *)v75);
LABEL_129:
            xpc_object_t v76 = v66 + 1;
            uint64_t v66 = v67;
            if (v76 != v67)
            {
              uint64_t v66 = v76;
              while ((v68(*v66) & 1) == 0)
              {
                if (++v66 == v67)
                {
                  uint64_t v66 = v67;
                  goto LABEL_121;
                }
              }
            }
          }
        }
        v295[1] = 0;
        v295[0] = 0;
        uint64_t v296 = 0;
        sub_1000F0A50(v295, *v253, v20);
        xpc_object_t v77 = (__n128 *)v295[0];
        xpc_object_t v78 = (__n128 *)v295[1];
        *(void *)long long __p = a1;
        unint64_t v79 = 0xAAAAAAAAAAAAAAABLL * (((char *)v295[1] - (char *)v295[0]) >> 3);
        if ((char *)v295[1] - (char *)v295[0] < 1)
        {
LABEL_138:
          xpc_object_t v82 = 0;
          unint64_t v80 = 0;
        }
        else
        {
          unint64_t v80 = 0xAAAAAAAAAAAAAAABLL * (((char *)v295[1] - (char *)v295[0]) >> 3);
          while (1)
          {
            xpc_object_t v81 = operator new(24 * v80, &std::nothrow);
            if (v81) {
              break;
            }
            BOOL v130 = v80 > 1;
            v80 >>= 1;
            if (!v130) {
              goto LABEL_138;
            }
          }
          xpc_object_t v82 = v81;
        }
        sub_1005ADCBC(v77, v78, (uint64_t *)__p, v79, (uint64_t)v82, v80);
        if (v82) {
          operator delete(v82);
        }
        uint64_t v294 = 0;
        v293[1] = 0;
        v293[0] = &v293[1];
        uint64_t v291 = 0;
        v290[1] = 0;
        v290[0] = (size_t)&v290[1];
        xpc_object_t v83 = (std::string *)v295[0];
        xpc_object_t v84 = (std::string *)v295[1];
        if (v295[0] == v295[1]) {
          goto LABEL_364;
        }
        v255 = (void *)(a1 + 40);
        v252 = (std::string *)v295[1];
LABEL_144:
        xpc_object_t v85 = (CCPreferences *)sub_1005ABED0(a1, (uint64_t)v83);
        if (v85)
        {
          *(void *)long long __p = v83;
          *((_DWORD *)sub_1005AEC40((uint64_t **)v293, (void **)&v83->__r_.__value_.__l.__data_, (long long **)__p) + 14) = v85;
          goto LABEL_268;
        }
        cf[0] = 0;
        CCPreferences::create((uint64_t *)buf, v85);
        *(_OWORD *)long long __p = *(_OWORD *)buf;
        *(void *)&uint8_t buf[8] = 0;
        *(void *)long long buf = 0;
        CFPreferencesCopyValueForCurrentUserAnyHost();
        if (*(void *)&__p[8]) {
          sub_10004D2C8(*(std::__shared_weak_count **)&__p[8]);
        }
        if (*(void *)&buf[8]) {
          sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
        }
        *(void *)v267 = 0;
        v265[0] = cf[0];
        if (cf[0])
        {
          CFRetain(cf[0]);
          *(CFTypeRef *)long long buf = v265[0];
          if (v265[0]) {
            CFRetain(v265[0]);
          }
        }
        else
        {
          *(void *)long long buf = 0;
        }
        __dst[0] = 0;
        *(void *)long long __p = 0;
        sub_1000057AC(__p, (CFTypeRef *)buf);
        if (*(void *)__p) {
          xpc_object_t v86 = sub_100084B4C;
        }
        else {
          xpc_object_t v86 = 0;
        }
        if (v86) {
          sub_1005AED68((const void **)__dst, (const void **)__p);
        }
        sub_100062778((const void **)__p);
        *(void **)v267 = __dst[0];
        __dst[0] = 0;
        sub_100062778((const void **)__dst);
        sub_1000577C4((const void **)buf);
        sub_1000577C4(v265);
        if (*(void *)v267) {
          xpc_object_t v87 = sub_100084B4C;
        }
        else {
          xpc_object_t v87 = 0;
        }
        if (v87 && *(const CFBooleanRef *)v267 == kCFBooleanTrue)
        {
          xpc_object_t v88 = *v260;
          int v89 = 0;
          if (os_log_type_enabled(*v260, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)long long __p = 0;
            _os_log_impl((void *)&_mh_execute_header, v88, OS_LOG_TYPE_DEFAULT, "#I IMEI binding is disabled", __p, 2u);
            int v89 = 0;
          }
          goto LABEL_267;
        }
        memset(__dst, 0, 24);
        uint64_t v90 = *(void *)(a1 + 56);
        uint64_t v91 = *(void *)(a1 + 64);
        if (SHIBYTE(v83->__r_.__value_.__r.__words[2]) < 0)
        {
          sub_10004FC84(buf, v83->__r_.__value_.__l.__data_, v83->__r_.__value_.__l.__size_);
        }
        else
        {
          long long v92 = *(_OWORD *)&v83->__r_.__value_.__l.__data_;
          *(void *)&uint8_t buf[16] = *((void *)&v83->__r_.__value_.__l + 2);
          *(_OWORD *)long long buf = v92;
        }
        uint8_t v93 = buf[23];
        if (v90 != v91)
        {
          if ((buf[23] & 0x80u) == 0) {
            uint64_t v94 = buf[23];
          }
          else {
            uint64_t v94 = *(void *)&buf[8];
          }
          if ((buf[23] & 0x80u) == 0) {
            v95 = buf;
          }
          else {
            v95 = *(uint8_t **)buf;
          }
          do
          {
            uint64_t v96 = *(unsigned __int8 *)(v90 + 95);
            if ((v96 & 0x80u) == 0) {
              uint64_t v97 = *(unsigned __int8 *)(v90 + 95);
            }
            else {
              uint64_t v97 = *(void *)(v90 + 80);
            }
            if (v97 == v94)
            {
              if ((v96 & 0x80) != 0)
              {
                if (!memcmp(*(const void **)(v90 + 72), v95, *(void *)(v90 + 80))) {
                  goto LABEL_189;
                }
              }
              else
              {
                if (!*(unsigned char *)(v90 + 95)) {
                  goto LABEL_189;
                }
                uint64_t v98 = 0;
                while (*(unsigned __int8 *)(v90 + v98 + 72) == v95[v98])
                {
                  if (v96 == ++v98) {
                    goto LABEL_189;
                  }
                }
              }
            }
            v90 += 168;
          }
          while (v90 != v91);
          uint64_t v90 = v91;
LABEL_189:
          xpc_object_t v84 = v252;
        }
        if ((v93 & 0x80) != 0) {
          operator delete(*(void **)buf);
        }
        if (v90 == *(void *)(a1 + 64)) {
          goto LABEL_197;
        }
        if (subscriber::isEsimCapable())
        {
          long long v329 = 0u;
          *(_OWORD *)v328 = 0u;
          memset(v327, 0, sizeof(v327));
          *(_OWORD *)v326 = 0u;
          memset(v325, 0, sizeof(v325));
          *(_OWORD *)v324 = 0u;
          memset(v323, 0, sizeof(v323));
          long long v322 = 0u;
          long long v321 = 0u;
          memset(__p, 0, sizeof(__p));
          sGetProfileDetails();
          if (BYTE8(v329))
          {
            if ((SBYTE7(v329) & 0x80000000) == 0)
            {
              *(_OWORD *)long long __dst = *(_OWORD *)v328;
              __dst[2] = (void *)v329;
LABEL_215:
              sub_1000C584C((uint64_t)__p);
              goto LABEL_216;
            }
            sub_10004FC84(__dst, v328[0], (unint64_t)v328[1]);
            if (BYTE8(v329)) {
              goto LABEL_215;
            }
LABEL_216:
            if (SHIBYTE(__dst[2]) < 0)
            {
              if (!__dst[1])
              {
LABEL_246:
                xpc_object_t v120 = *v260;
                int v89 = 0;
                if (os_log_type_enabled(*v260, OS_LOG_TYPE_DEFAULT))
                {
                  if ((v83->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                    xpc_object_t v121 = v83;
                  }
                  else {
                    xpc_object_t v121 = (std::string *)v83->__r_.__value_.__r.__words[0];
                  }
                  *(_DWORD *)long long __p = 136315138;
                  *(void *)&__p[4] = v121;
                  _os_log_impl((void *)&_mh_execute_header, v120, OS_LOG_TYPE_DEFAULT, "#I Last used IMEI is unknown for SIM (%s)", __p, 0xCu);
                  int v89 = 0;
                }
                goto LABEL_265;
              }
              xpc_object_t v110 = *(void **)(a1 + 32);
              sub_10004FC84(__p, __dst[0], (unint64_t)__dst[1]);
            }
            else
            {
              if (!HIBYTE(__dst[2])) {
                goto LABEL_246;
              }
              xpc_object_t v110 = *(void **)(a1 + 32);
              *(_OWORD *)long long __p = *(_OWORD *)__dst;
              *(void **)&__p[16] = __dst[2];
            }
            char v111 = __p[23];
            uint64_t v112 = a1 + 40;
            if (v110 == v255) {
              goto LABEL_253;
            }
            if (__p[23] >= 0) {
              uint64_t v113 = __p[23];
            }
            else {
              uint64_t v113 = *(void *)&__p[8];
            }
            if (__p[23] >= 0) {
              xpc_object_t v114 = __p;
            }
            else {
              xpc_object_t v114 = *(unsigned char **)__p;
            }
            while (1)
            {
              uint64_t v115 = *((unsigned __int8 *)v110 + 63);
              if ((v115 & 0x80u) == 0) {
                uint64_t v116 = *((unsigned __int8 *)v110 + 63);
              }
              else {
                uint64_t v116 = v110[6];
              }
              if (v116 == v113)
              {
                if ((v115 & 0x80) != 0)
                {
                  if (!memcmp((const void *)v110[5], v114, v110[6]))
                  {
LABEL_251:
                    uint64_t v112 = (uint64_t)v110;
LABEL_252:
                    xpc_object_t v84 = v252;
LABEL_253:
                    if (v111 < 0) {
                      operator delete(*(void **)__p);
                    }
                    if ((void *)v112 == v255) {
                      int v89 = 0;
                    }
                    else {
                      int v89 = *(_DWORD *)(v112 + 32);
                    }
                    v122 = *v260;
                    if (os_log_type_enabled(*v260, OS_LOG_TYPE_DEFAULT))
                    {
                      int v123 = SHIBYTE(v83->__r_.__value_.__r.__words[2]);
                      v124 = (char *)v83->__r_.__value_.__r.__words[0];
                      uint64_t v125 = subscriber::asString();
                      if (v123 >= 0) {
                        v126 = v83;
                      }
                      else {
                        v126 = (std::string *)v124;
                      }
                      v127 = __dst;
                      if (SHIBYTE(__dst[2]) < 0) {
                        v127 = (void **)__dst[0];
                      }
                      *(_DWORD *)long long __p = 136315650;
                      *(void *)&__p[4] = v126;
                      *(_WORD *)&unsigned char __p[12] = 2080;
                      *(void *)&__p[14] = v125;
                      *(_WORD *)&__p[22] = 2080;
                      *(void *)&__p[24] = v127;
                      _os_log_impl((void *)&_mh_execute_header, v122, OS_LOG_TYPE_DEFAULT, "#I Last used instance (IMEI) for SIM (%s): %s (%s)", __p, 0x20u);
                    }
LABEL_265:
                    if (SHIBYTE(__dst[2]) < 0) {
                      operator delete(__dst[0]);
                    }
LABEL_267:
                    sub_100062778((const void **)v267);
                    sub_1000577C4(cf);
                    *(void *)long long __p = v83;
                    *((_DWORD *)sub_1005AEC40((uint64_t **)v293, (void **)&v83->__r_.__value_.__l.__data_, (long long **)__p)+ 14) = v89;
LABEL_268:
                    *(void *)long long __p = v83;
                    *(void *)long long __p = sub_1005AEC40((uint64_t **)v293, (void **)&v83->__r_.__value_.__l.__data_, (long long **)__p)+ 7;
                    v128 = sub_100200564((uint64_t **)v290, *(int **)__p, (uint64_t)&unk_10144E20E, (_DWORD **)__p);
                    sub_100046BAC(v128 + 5, (void **)&v83->__r_.__value_.__l.__data_, (uint64_t)v83);
                    if (++v83 == v84)
                    {
                      size_t v129 = v290[0];
                      if ((size_t *)v290[0] != &v290[1])
                      {
                        while (1)
                        {
                          BOOL v130 = *(_DWORD *)(v129 + 32) && *(void *)(v129 + 56) > 1uLL;
                          if (v130) {
                            break;
                          }
                          v131 = *(size_t **)(v129 + 8);
                          if (v131)
                          {
                            do
                            {
                              v132 = v131;
                              v131 = (size_t *)*v131;
                            }
                            while (v131);
                          }
                          else
                          {
                            do
                            {
                              v132 = *(size_t **)(v129 + 16);
                              BOOL v25 = *v132 == v129;
                              size_t v129 = (size_t)v132;
                            }
                            while (!v25);
                          }
                          size_t v129 = (size_t)v132;
                          if (v132 == &v290[1]) {
                            goto LABEL_364;
                          }
                        }
                        memset(v267, 0, sizeof(v267));
                        v133 = (std::string *)v295[0];
                        v134 = (std::string *)v295[1];
                        cf[0] = 0;
                        cf[1] = 0;
                        CFTypeRef v269 = 0;
                        if (v295[0] == v295[1])
                        {
                          v142 = 0;
                          v143 = 0;
                        }
                        else
                        {
                          v135 = (void **)(a1 + 136);
                          do
                          {
                            if (v135 == sub_100046F68(a1 + 128, (void **)&v133->__r_.__value_.__l.__data_))
                            {
                              long long v329 = 0u;
                              *(_OWORD *)v328 = 0u;
                              memset(v327, 0, sizeof(v327));
                              *(_OWORD *)v326 = 0u;
                              memset(v325, 0, sizeof(v325));
                              *(_OWORD *)v324 = 0u;
                              memset(v323, 0, sizeof(v323));
                              long long v322 = 0u;
                              long long v321 = 0u;
                              memset(__p, 0, sizeof(__p));
                              sGetProfileDetails();
                              if (BYTE8(v329))
                              {
                                BOOL v136 = sub_1005AC130(a1, (uint64_t)v324, (uint64_t)v325 + 8, (uint64_t)v326, (uint64_t)v327 + 8, (uint64_t)&__p[16]);
                                *(void *)long long buf = v133;
                                *((unsigned char *)sub_1000ED870((uint64_t **)(a1 + 128), (void **)&v133->__r_.__value_.__l.__data_, (uint64_t)&unk_10144E20E, (long long **)buf)+ 56) = v136;
                              }
                              else
                              {
                                long long v283 = 0u;
                                memset(&v284, 0, sizeof(v284));
                                *(_OWORD *)v281 = 0u;
                                *(_OWORD *)v282 = 0u;
                                *(_OWORD *)v279 = 0u;
                                long long v280 = 0u;
                                *(_OWORD *)v277 = 0u;
                                long long v278 = 0u;
                                memset(__dst, 0, sizeof(__dst));
                                memset(v317, 0, 32);
                                long long v316 = 0u;
                                long long v315 = 0u;
                                long long v314 = 0u;
                                long long v313 = 0u;
                                long long v311 = 0u;
                                long long v312 = 0u;
                                long long v310 = 0u;
                                memset(buf, 0, sizeof(buf));
                                sub_1005ABD78(buf, (uint64_t *)(a1 + 56), (uint64_t)v133);
                                if (v317[1].__r_.__value_.__s.__data_[0] && subscriber::isSimReady())
                                {
                                  *(_OWORD *)long long __dst = *(_OWORD *)buf;
                                  sub_10008A534((char *)&__dst[2], *(char **)&buf[16], *(uint64_t *)&buf[24], (uint64_t)(*(void *)&buf[24] - *(void *)&buf[16]) >> 2);
                                  sub_10008A640((uint64_t *)&v277[1], *((uint64_t *)&v310 + 1), v311, 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v311 - *((void *)&v310 + 1)) >> 3));
                                  LODWORD(v279[0]) = v312;
                                  WORD2(v279[0]) = WORD2(v312);
                                  std::string::operator=((std::string *)&v279[1], (const std::string *)((char *)&v312 + 8));
                                  std::string::operator=((std::string *)v281, (const std::string *)&v314);
                                  std::string::operator=((std::string *)&v282[1], (const std::string *)((char *)&v315 + 8));
                                  std::string::operator=(&v284, v317);
                                }
                                else
                                {
                                  sub_1005ACED0((uint64_t)v300, a1, v133);
                                  sub_10032FAFC((uint64_t)__dst, (uint64_t)v300);
                                  if (v308 < 0) {
                                    operator delete(v307);
                                  }
                                  if (v306 < 0) {
                                    operator delete(v305);
                                  }
                                  if (v304 < 0) {
                                    operator delete(v303);
                                  }
                                  if (SHIBYTE(v302[3]) < 0) {
                                    operator delete(v302[1]);
                                  }
                                  v265[0] = (char *)&v300[2] + 8;
                                  sub_10002E39C((void ***)v265);
                                  if (*(void *)&v300[1])
                                  {
                                    *((void *)&v300[1] + 1) = *(void *)&v300[1];
                                    operator delete(*(void **)&v300[1]);
                                  }
                                }
                                sub_100397998((uint64_t)buf);
                                v137 = (void *)HIBYTE(v282[0]);
                                if (SHIBYTE(v282[0]) < 0) {
                                  v137 = v281[1];
                                }
                                if (v137)
                                {
                                  long long v310 = 0u;
                                  memset(buf, 0, sizeof(buf));
                                  sub_100E63EA4((uint64_t)buf);
                                  BOOL v138 = sub_1005AC130(a1, (uint64_t)buf, (uint64_t)&buf[24], (uint64_t)&v282[1], (uint64_t)&v284, (uint64_t)&v279[1]);
                                  *(void *)&v300[0] = v133;
                                  *((unsigned char *)sub_1000ED870((uint64_t **)(a1 + 128), (void **)&v133->__r_.__value_.__l.__data_, (uint64_t)&unk_10144E20E, (long long **)v300)+ 56) = v138;
                                  if (SHIBYTE(v310) < 0) {
                                    operator delete(*(void **)&buf[24]);
                                  }
                                  if ((char)buf[23] < 0) {
                                    operator delete(*(void **)buf);
                                  }
                                }
                                if (SHIBYTE(v284.__r_.__value_.__r.__words[2]) < 0) {
                                  operator delete(v284.__r_.__value_.__l.__data_);
                                }
                                if (SHIBYTE(v283) < 0) {
                                  operator delete(v282[1]);
                                }
                                if (SHIBYTE(v282[0]) < 0) {
                                  operator delete(v281[0]);
                                }
                                if (SHIBYTE(v280) < 0) {
                                  operator delete(v279[1]);
                                }
                                *(void *)long long buf = &v277[1];
                                sub_10002E39C((void ***)buf);
                                if (__dst[2])
                                {
                                  __dst[3] = __dst[2];
                                  operator delete(__dst[2]);
                                }
                              }
                              if (BYTE8(v329)) {
                                sub_1000C584C((uint64_t)__p);
                              }
                            }
                            if (v135 != sub_100046F68(a1 + 128, (void **)&v133->__r_.__value_.__l.__data_))
                            {
                              *(void *)long long buf = v133;
                              if (*((unsigned char *)sub_1000ED870((uint64_t **)(a1 + 128), (void **)&v133->__r_.__value_.__l.__data_, (uint64_t)&unk_10144E20E, (long long **)buf)+ 56))
                              {
                                v139 = cf[1];
                                if (cf[1] >= v269)
                                {
                                  v141 = (const void *)sub_10030E9EC((uint64_t *)cf, (long long *)v133);
                                }
                                else
                                {
                                  if (SHIBYTE(v133->__r_.__value_.__r.__words[2]) < 0)
                                  {
                                    sub_10004FC84((unsigned char *)cf[1], v133->__r_.__value_.__l.__data_, v133->__r_.__value_.__l.__size_);
                                  }
                                  else
                                  {
                                    long long v140 = *(_OWORD *)&v133->__r_.__value_.__l.__data_;
                                    *((void *)cf[1] + 2) = *((void *)&v133->__r_.__value_.__l + 2);
                                    _OWORD *v139 = v140;
                                  }
                                  v141 = (char *)v139 + 24;
                                }
                                cf[1] = v141;
                              }
                            }
                            ++v133;
                          }
                          while (v133 != v134);
                          v142 = (char *)cf[0];
                          v143 = cf[1];
                        }
                        if (v143 - v142 == 24)
                        {
                          if (v142[23] < 0)
                          {
                            sub_10004FC84(v267, *(void **)v142, *((void *)v142 + 1));
                          }
                          else
                          {
                            long long v144 = *(_OWORD *)v142;
                            *(void *)&v267[16] = *((void *)v142 + 2);
                            *(_OWORD *)v267 = v144;
                          }
                          char v145 = 1;
                        }
                        else
                        {
                          char v145 = 0;
                          v267[0] = 0;
                        }
                        v267[24] = v145;
                        *(void *)long long __p = cf;
                        sub_100047F64((void ***)__p);
                        if (v267[24])
                        {
                          *(void *)long long __p = v267;
                          LODWORD(v288) = *((_DWORD *)sub_1005AEC40((uint64_t **)v293, (void **)v267, (long long **)__p)
                                          + 14);
                          *(_OWORD *)v265 = 0u;
                          long long v266 = 0u;
                          v327[0] = 0u;
                          *(_OWORD *)v326 = 0u;
                          memset(v325, 0, sizeof(v325));
                          *(_OWORD *)v324 = 0u;
                          memset(v323, 0, sizeof(v323));
                          long long v322 = 0u;
                          long long v321 = 0u;
                          memset(__p, 0, sizeof(__p));
                          sub_1005A88B8(__p, *(_DWORD **)(a1 + 56), *(_DWORD **)(a1 + 64), v288);
                          if (BYTE8(v327[0])
                            && *(_DWORD *)__p
                            && (*(_DWORD *)&__p[8] > 8u || ((1 << __p[8]) & 0x103) == 0))
                          {
                            if (SHIBYTE(v323[3]) < 0)
                            {
                              if (!v323[2]) {
                                goto LABEL_341;
                              }
                              sub_10004FC84(v265, v323[1], (unint64_t)v323[2]);
                            }
                            else
                            {
                              if (!HIBYTE(v323[3])) {
                                goto LABEL_341;
                              }
                              *(_OWORD *)v265 = *(_OWORD *)&v323[1];
                              *(void **)&long long v266 = v323[3];
                            }
                            char v146 = 1;
                          }
                          else
                          {
LABEL_341:
                            char v146 = 0;
                            LOBYTE(v265[0]) = 0;
                          }
                          BYTE8(v266) = v146;
                          sub_100397998((uint64_t)__p);
                          if (BYTE8(v266) && sub_1005AD5C4((unsigned __int8 *)v265, v267))
                          {
                            v147 = *v260;
                            if (os_log_type_enabled(*v260, OS_LOG_TYPE_DEFAULT))
                            {
                              uint64_t v148 = subscriber::asString();
                              v149 = v267;
                              if (v267[23] < 0) {
                                v149 = *(unsigned char **)v267;
                              }
                              v150 = v265;
                              if (SBYTE7(v266) < 0) {
                                v150 = (CFTypeRef *)v265[0];
                              }
                              *(_DWORD *)long long __p = 136315650;
                              *(void *)&__p[4] = v148;
                              *(_WORD *)&unsigned char __p[12] = 2080;
                              *(void *)&__p[14] = v149;
                              *(_WORD *)&__p[22] = 2080;
                              *(void *)&__p[24] = v150;
                              _os_log_impl((void *)&_mh_execute_header, v147, OS_LOG_TYPE_DEFAULT, "#I Need to assign instance (%s) to SIM (%s) based on CB preference by replacing SIM (%s)", __p, 0x20u);
                            }
                            v303 = 0;
                            memset(v302, 0, sizeof(v302));
                            long long v301 = 0u;
                            memset(v300, 0, sizeof(v300));
                            sub_1005ACED0((uint64_t)__dst, a1, (const std::string *)v265);
                            memset(v317, 0, 32);
                            long long v316 = 0u;
                            long long v315 = 0u;
                            long long v314 = 0u;
                            long long v313 = 0u;
                            long long v311 = 0u;
                            long long v312 = 0u;
                            long long v310 = 0u;
                            memset(buf, 0, sizeof(buf));
                            sub_1005ABD78(buf, (uint64_t *)(a1 + 56), (uint64_t)v265);
                            if (v317[1].__r_.__value_.__s.__data_[0])
                            {
                              if (subscriber::isEsimCapable())
                              {
                                long long v329 = 0u;
                                *(_OWORD *)v328 = 0u;
                                memset(v327, 0, sizeof(v327));
                                *(_OWORD *)v326 = 0u;
                                memset(v325, 0, sizeof(v325));
                                *(_OWORD *)v324 = 0u;
                                memset(v323, 0, sizeof(v323));
                                long long v322 = 0u;
                                long long v321 = 0u;
                                memset(__p, 0, sizeof(__p));
                                sGetProfileDetails();
                                if (SBYTE7(v325[0]) < 0)
                                {
                                  sub_10004FC84(cf, v324[0], (unint64_t)v324[1]);
                                }
                                else
                                {
                                  *(_OWORD *)CFTypeRef cf = *(_OWORD *)v324;
                                  CFTypeRef v269 = *(CFTypeRef *)&v325[0];
                                }
                                if (SHIBYTE(v325[1]) < 0)
                                {
                                  sub_10004FC84(&v270, *((void **)&v325[0] + 1), *(unint64_t *)&v325[1]);
                                }
                                else
                                {
                                  long long v270 = *(_OWORD *)((char *)v325 + 8);
                                  uint64_t v271 = *((void *)&v325[1] + 1);
                                }
                                if (SBYTE7(v327[0]) < 0)
                                {
                                  sub_10004FC84(&v272, v326[0], (unint64_t)v326[1]);
                                }
                                else
                                {
                                  long long v272 = *(_OWORD *)v326;
                                  v273 = *(void **)&v327[0];
                                }
                                if (SHIBYTE(v327[1]) < 0)
                                {
                                  sub_10004FC84(&v274, *((void **)&v327[0] + 1), *(unint64_t *)&v327[1]);
                                }
                                else
                                {
                                  long long v274 = *(_OWORD *)((char *)v327 + 8);
                                  v275 = (void *)*((void *)&v327[1] + 1);
                                }
                                v300[0] = *(_OWORD *)cf;
                                *(_OWORD *)((char *)&v300[1] + 8) = v270;
                                *(void *)&v300[1] = v269;
                                *((void *)&v300[2] + 1) = v271;
                                long long v301 = v272;
                                v302[0] = v273;
                                v302[3] = v275;
                                *(_OWORD *)&v302[1] = v274;
                                LOBYTE(v303) = 1;
                                if (BYTE8(v329)) {
                                  sub_1000C584C((uint64_t)__p);
                                }
                              }
                              else
                              {
                                *(void *)&v327[0] = 0;
                                *(_OWORD *)v326 = 0u;
                                memset(v325, 0, sizeof(v325));
                                *(_OWORD *)v324 = 0u;
                                memset(v323, 0, sizeof(v323));
                                long long v322 = 0u;
                                long long v321 = 0u;
                                memset(__p, 0, sizeof(__p));
                                if (subscriber::isSimReady()) {
                                  v170 = buf;
                                }
                                else {
                                  v170 = __dst;
                                }
                                sub_10002E664((uint64_t)__p, (uint64_t)v170);
                                sub_1005AD688((uint64_t)v300, (uint64_t)__p);
                                if (SBYTE7(v327[0]) < 0) {
                                  operator delete(v326[0]);
                                }
                                if (SHIBYTE(v325[1]) < 0) {
                                  operator delete(*((void **)&v325[0] + 1));
                                }
                                if (SBYTE7(v325[0]) < 0) {
                                  operator delete(v324[0]);
                                }
                                if (SHIBYTE(v323[3]) < 0) {
                                  operator delete(v323[1]);
                                }
                                cf[0] = (char *)&v321 + 8;
                                sub_10002E39C((void ***)cf);
                                if (*(void *)&__p[16])
                                {
                                  *(void *)&__p[24] = *(void *)&__p[16];
                                  operator delete(*(void **)&__p[16]);
                                }
                              }
                            }
                            else
                            {
                              LOBYTE(v300[0]) = 0;
                              LOBYTE(v303) = 0;
                            }
                            sub_100397998((uint64_t)buf);
                            if (SHIBYTE(v284.__r_.__value_.__r.__words[2]) < 0) {
                              operator delete(v284.__r_.__value_.__l.__data_);
                            }
                            if (SHIBYTE(v283) < 0) {
                              operator delete(v282[1]);
                            }
                            if (SHIBYTE(v282[0]) < 0) {
                              operator delete(v281[0]);
                            }
                            if (SHIBYTE(v280) < 0) {
                              operator delete(v279[1]);
                            }
                            *(void *)long long __p = &v277[1];
                            sub_10002E39C((void ***)__p);
                            if (__dst[2])
                            {
                              __dst[3] = __dst[2];
                              operator delete(__dst[2]);
                            }
                            if ((_BYTE)v303)
                            {
                              __p[0] = 1;
                              sub_100495C3C();
                            }
                            sub_1000886C0((uint64_t)v259, *(char **)(a1 + 112));
                            *(void *)(a1 + 112) = 0;
                            *(void *)(a1 + 120) = 0;
                            *(void *)(a1 + 104) = v257;
                            sub_1005ADA04((uint64_t)v300);
                            if (BYTE8(v266) && SBYTE7(v266) < 0) {
                              operator delete((void *)v265[0]);
                            }
                            if (v267[24] && (v267[23] & 0x80000000) != 0) {
                              operator delete(*(void **)v267);
                            }
                            goto LABEL_445;
                          }
                          v151 = *v260;
                          if (os_log_type_enabled(*v260, OS_LOG_TYPE_DEFAULT))
                          {
                            uint64_t v152 = subscriber::asString();
                            v153 = v267;
                            if (v267[23] < 0) {
                              v153 = *(unsigned char **)v267;
                            }
                            *(_DWORD *)long long __p = 136315394;
                            *(void *)&__p[4] = v152;
                            *(_WORD *)&unsigned char __p[12] = 2080;
                            *(void *)&__p[14] = v153;
                            _os_log_impl((void *)&_mh_execute_header, v151, OS_LOG_TYPE_DEFAULT, "#I Assigning instance (%s) to SIM (%s) based on CB preference", __p, 0x16u);
                          }
                          *(void *)long long __p = &v288;
                          v154 = sub_10008CC40(v259, (int *)&v288, (uint64_t)&unk_10144E20E, (_DWORD **)__p);
                          std::string::operator=((std::string *)(v154 + 5), (const std::string *)v267);
                          if (BYTE8(v266) && SBYTE7(v266) < 0) {
                            operator delete((void *)v265[0]);
                          }
                          if (v267[24] && (v267[23] & 0x80000000) != 0) {
                            operator delete(*(void **)v267);
                          }
                        }
                      }
LABEL_364:
                      v155 = (std::string *)v295[0];
                      v156 = (std::string *)v295[1];
                      if (v295[0] == v295[1]) {
                        goto LABEL_445;
                      }
                      while (2)
                      {
                        *(_DWORD *)long long buf = 0;
                        *(void *)long long __p = v155;
                        *(_DWORD *)long long buf = *((_DWORD *)sub_1005AEC40((uint64_t **)v293, (void **)&v155->__r_.__value_.__l.__data_, (long long **)__p)+ 14);
                        if (*(_DWORD *)buf)
                        {
                          *(void *)long long __p = buf;
                          v157 = sub_10008CC40(v259, (int *)buf, (uint64_t)&unk_10144E20E, (_DWORD **)__p);
                          if (*((char *)v157 + 63) < 0)
                          {
                            if (!v157[6])
                            {
LABEL_370:
                              *(void *)long long __p = buf;
                              v158 = sub_10008CC40(v259, (int *)buf, (uint64_t)&unk_10144E20E, (_DWORD **)__p);
                              std::string::operator=((std::string *)(v158 + 5), v155);
                              v159 = *v260;
                              if (os_log_type_enabled(*v260, OS_LOG_TYPE_DEFAULT))
                              {
                                v160 = v155;
                                if (SHIBYTE(v155->__r_.__value_.__r.__words[2]) < 0) {
                                  v160 = (std::string *)v155->__r_.__value_.__r.__words[0];
                                }
                                uint64_t v161 = subscriber::asString();
                                *(_DWORD *)long long __p = 136315394;
                                *(void *)&__p[4] = v160;
                                *(_WORD *)&unsigned char __p[12] = 2080;
                                *(void *)&__p[14] = v161;
                                _os_log_impl((void *)&_mh_execute_header, v159, OS_LOG_TYPE_DEFAULT, "#I Assigning cached instance for SIM (%s) : %s", __p, 0x16u);
                              }
                            }
                          }
                          else if (!*((unsigned char *)v157 + 63))
                          {
                            goto LABEL_370;
                          }
                        }
                        if (++v155 != v156) {
                          continue;
                        }
                        break;
                      }
                      v162 = (const std::string *)v295[0];
                      v163 = (const std::string *)v295[1];
                      if (v295[0] == v295[1]) {
                        goto LABEL_445;
                      }
LABEL_376:
                      if (sub_1005ABED0(a1, (uint64_t)v162)) {
                        goto LABEL_377;
                      }
                      v164 = *v259;
                      if (*v259 == v257) {
                        goto LABEL_377;
                      }
                      while (1)
                      {
                        if (*((char *)v164 + 63) < 0)
                        {
                          if (!v164[6])
                          {
LABEL_391:
                            v167 = v164 + 5;
                            std::string::operator=((std::string *)(v164 + 5), v162);
                            v168 = *v260;
                            if (os_log_type_enabled(*v260, OS_LOG_TYPE_DEFAULT))
                            {
                              if (*((char *)v164 + 63) < 0) {
                                v167 = (void *)*v167;
                              }
                              uint64_t v169 = subscriber::asString();
                              *(_DWORD *)long long __p = 136315394;
                              *(void *)&__p[4] = v167;
                              *(_WORD *)&unsigned char __p[12] = 2080;
                              *(void *)&__p[14] = v169;
                              _os_log_impl((void *)&_mh_execute_header, v168, OS_LOG_TYPE_DEFAULT, "#I Assigning new instance to SIM (%s) : %s", __p, 0x16u);
                            }
LABEL_377:
                            if (++v162 == v163)
                            {
LABEL_445:
                              sub_1001FEB64((uint64_t)v290, (void *)v290[1]);
                              sub_1000DA2E4((char *)v293[1]);
                              *(void *)long long __p = v295;
                              sub_100047F64((void ***)__p);
                              goto LABEL_446;
                            }
                            goto LABEL_376;
                          }
                        }
                        else if (!*((unsigned char *)v164 + 63))
                        {
                          goto LABEL_391;
                        }
                        v165 = (uint64_t *)v164[1];
                        if (v165)
                        {
                          do
                          {
                            v166 = v165;
                            v165 = (uint64_t *)*v165;
                          }
                          while (v165);
                        }
                        else
                        {
                          do
                          {
                            v166 = (uint64_t *)v164[2];
                            BOOL v25 = *v166 == (void)v164;
                            v164 = v166;
                          }
                          while (!v25);
                        }
                        v164 = v166;
                        if (v166 == v257) {
                          goto LABEL_377;
                        }
                      }
                    }
                    goto LABEL_144;
                  }
                }
                else
                {
                  if (!*((unsigned char *)v110 + 63)) {
                    goto LABEL_251;
                  }
                  uint64_t v117 = 0;
                  while (*((unsigned __int8 *)v110 + v117 + 40) == v114[v117])
                  {
                    if (v115 == ++v117) {
                      goto LABEL_251;
                    }
                  }
                }
              }
              xpc_object_t v118 = (void *)v110[1];
              if (v118)
              {
                do
                {
                  xpc_object_t v119 = v118;
                  xpc_object_t v118 = (void *)*v118;
                }
                while (v118);
              }
              else
              {
                do
                {
                  xpc_object_t v119 = (void *)v110[2];
                  BOOL v25 = *v119 == (void)v110;
                  xpc_object_t v110 = v119;
                }
                while (!v25);
              }
              xpc_object_t v110 = v119;
              if (v119 == v255)
              {
                uint64_t v112 = a1 + 40;
                goto LABEL_252;
              }
            }
          }
LABEL_197:
          memset(__dst, 0, 24);
          goto LABEL_216;
        }
        *(void *)&v300[0] = 0;
        xpc_object_t v99 = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 16));
        v100 = v99;
        if (v101 < 0)
        {
          v102 = (unsigned __int8 *)(v101 & 0x7FFFFFFFFFFFFFFFLL);
          uint64_t v103 = 5381;
          do
          {
            uint64_t v101 = v103;
            unsigned int v104 = *v102++;
            uint64_t v103 = (33 * v103) ^ v104;
          }
          while (v104);
        }
        std::mutex::lock(v99);
        *(void *)long long __p = v101;
        xpc_object_t v105 = sub_10004D37C(&v100[1].__m_.__sig, (unint64_t *)__p);
        if (v105)
        {
          uint64_t v106 = v105[3];
          xpc_object_t v107 = (std::__shared_weak_count *)v105[4];
          if (v107)
          {
            atomic_fetch_add_explicit(&v107->__shared_owners_, 1uLL, memory_order_relaxed);
            std::mutex::unlock(v100);
            atomic_fetch_add_explicit(&v107->__shared_owners_, 1uLL, memory_order_relaxed);
            sub_10004D2C8(v107);
            char v108 = 0;
LABEL_206:
            if (SHIBYTE(v83->__r_.__value_.__r.__words[2]) < 0)
            {
              sub_10004FC84(__p, v83->__r_.__value_.__l.__data_, v83->__r_.__value_.__l.__size_);
            }
            else
            {
              long long v109 = *(_OWORD *)&v83->__r_.__value_.__l.__data_;
              *(void *)&__p[16] = *((void *)&v83->__r_.__value_.__l + 2);
              *(_OWORD *)long long __p = v109;
            }
            (*(void (**)(_OWORD *__return_ptr, uint64_t, unsigned char *, const __CFString *, const __CFString *, void, uint64_t))(*(void *)v106 + 24))(v300, v106, __p, @"LastUsedImei", @"SubscriptionConfiguration", 0, 1);
            xpc_object_t v84 = v252;
            if ((__p[23] & 0x80000000) != 0) {
              operator delete(*(void **)__p);
            }
            if ((v108 & 1) == 0) {
              sub_10004D2C8(v107);
            }
            memset(__p, 0, 24);
            ctu::cf::assign();
            *(_OWORD *)long long __dst = *(_OWORD *)__p;
            __dst[2] = *(void **)&__p[16];
            memset(__p, 0, 24);
            sub_1000577C4((const void **)v300);
            goto LABEL_216;
          }
        }
        else
        {
          uint64_t v106 = 0;
        }
        std::mutex::unlock(v100);
        xpc_object_t v107 = 0;
        char v108 = 1;
        goto LABEL_206;
      }
    }
    else
    {
      uint64_t v34 = 0;
    }
    std::mutex::unlock(v28);
    long long v35 = 0;
    char v36 = 1;
    goto LABEL_60;
  }
LABEL_67:
  sub_1000886C0((uint64_t)v259, *(char **)(a1 + 112));
  *(void *)(a1 + 104) = a1 + 112;
  *(void *)(a1 + 112) = 0;
  *(void *)(a1 + 120) = 0;
  if (a2[2] && (char v43 = (capabilities::ct *)capabilities::ct::supportsDynamicSID(v43), v43))
  {
    uint64_t v44 = (std::string *)*a2;
    *(_DWORD *)long long buf = 1;
    *(void *)long long __p = buf;
    int v45 = sub_10008CC40(v259, (int *)buf, (uint64_t)&unk_10144E20E, (_DWORD **)__p);
    char v43 = (capabilities::ct *)std::string::operator=((std::string *)(v45 + 5), (std::string *)((char *)v44 + 32));
  }
  else
  {
    long long v46 = (std::string *)*a2;
    if (*a2 != v20)
    {
      do
      {
        uint64_t v47 = &v46[1].__r_.__value_.__l.__size_;
        v327[0] = 0u;
        *(_OWORD *)v326 = 0u;
        memset(v325, 0, sizeof(v325));
        *(_OWORD *)v324 = 0u;
        memset(v323, 0, sizeof(v323));
        long long v322 = 0u;
        long long v321 = 0u;
        memset(__p, 0, sizeof(__p));
        sub_1005ABD78(__p, (uint64_t *)(a1 + 56), (uint64_t)&v46[1].__r_.__value_.__l.__size_);
        if (BYTE8(v327[0]))
        {
          int v48 = *(_DWORD *)&__p[4];
          if (*(_DWORD *)&__p[4])
          {
            if (*(_DWORD *)&__p[4] == 3)
            {
              int v48 = 2;
            }
            else if (*(_DWORD *)&__p[4] != 2)
            {
              int v48 = 1;
            }
            LODWORD(__dst[0]) = v48;
            *(void *)long long buf = __dst;
            unsigned __int8 v49 = sub_10008CC40(v259, (int *)__dst, (uint64_t)&unk_10144E20E, (_DWORD **)buf);
            std::string::operator=((std::string *)(v49 + 5), (std::string *)((char *)v46 + 32));
            int v50 = *v260;
            if (os_log_type_enabled(*v260, OS_LOG_TYPE_DEFAULT))
            {
              if (v46[2].__r_.__value_.__s.__data_[7] < 0) {
                uint64_t v47 = (std::string::size_type *)*v47;
              }
              uint64_t v51 = subscriber::asString();
              *(_DWORD *)long long buf = 136315394;
              *(void *)&uint8_t buf[4] = v47;
              *(_WORD *)&unsigned char buf[12] = 2080;
              *(void *)&buf[14] = v51;
              _os_log_impl((void *)&_mh_execute_header, v50, OS_LOG_TYPE_DEFAULT, "#I Assigning straight-mapped instance to SIM (%s) : %s", buf, 0x16u);
            }
          }
          else
          {
            LODWORD(__dst[0]) = 0;
            int v52 = *v260;
            if (os_log_type_enabled(*v260, OS_LOG_TYPE_ERROR))
            {
              uint64_t v55 = subscriber::asString();
              if (v46[2].__r_.__value_.__s.__data_[7] < 0) {
                uint64_t v47 = (std::string::size_type *)*v47;
              }
              *(_DWORD *)long long buf = 136315394;
              *(void *)&uint8_t buf[4] = v55;
              *(_WORD *)&unsigned char buf[12] = 2080;
              *(void *)&buf[14] = v47;
              _os_log_error_impl((void *)&_mh_execute_header, v52, OS_LOG_TYPE_ERROR, "Unexpected phy slot (%s) for SIM (%s)", buf, 0x16u);
            }
          }
        }
        char v43 = (capabilities::ct *)sub_100397998((uint64_t)__p);
        char v53 = (std::string *)v46->__r_.__value_.__l.__size_;
        if (v53)
        {
          do
          {
            int v54 = (std::string **)v53;
            char v53 = (std::string *)v53->__r_.__value_.__r.__words[0];
          }
          while (v53);
        }
        else
        {
          do
          {
            int v54 = (std::string **)v46->__r_.__value_.__r.__words[2];
            BOOL v25 = *v54 == v46;
            long long v46 = (std::string *)v54;
          }
          while (!v25);
        }
        long long v46 = (std::string *)v54;
      }
      while (v54 != v20);
    }
  }
LABEL_446:
  if (v263 != *(void *)(a1 + 120))
  {
    char v174 = 0;
LABEL_464:
    v173 = v253;
    goto LABEL_465;
  }
  v171 = v261;
  if (v261 == &v262)
  {
    char v174 = 1;
    goto LABEL_464;
  }
  v172 = *v259;
  v173 = v253;
  do
  {
    char v43 = (capabilities::ct *)sub_10008D2E0((uint64_t)__p, (uint64_t)(v171 + 4), (uint64_t)(v172 + 4));
    char v174 = (char)v43;
    if (!v43) {
      break;
    }
    v175 = v171[1];
    v176 = v171;
    if (v175)
    {
      do
      {
        v171 = (char **)v175;
        v175 = *(char **)v175;
      }
      while (v175);
    }
    else
    {
      do
      {
        v171 = (char **)v176[2];
        BOOL v25 = *v171 == (char *)v176;
        v176 = v171;
      }
      while (!v25);
    }
    v177 = (uint64_t *)v172[1];
    if (v177)
    {
      do
      {
        v178 = v177;
        v177 = (uint64_t *)*v177;
      }
      while (v177);
    }
    else
    {
      do
      {
        v178 = (uint64_t *)v172[2];
        BOOL v25 = *v178 == (void)v172;
        v172 = v178;
      }
      while (!v25);
    }
    v172 = v178;
  }
  while (v171 != &v262);
LABEL_465:
  if (!capabilities::ct::supportsHydra(v43)) {
    goto LABEL_660;
  }
  v179 = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 16));
  v180 = v179;
  if (v181 < 0)
  {
    v182 = (unsigned __int8 *)(v181 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v183 = 5381;
    do
    {
      uint64_t v181 = v183;
      unsigned int v184 = *v182++;
      uint64_t v183 = (33 * v183) ^ v184;
    }
    while (v184);
  }
  std::mutex::lock(v179);
  *(void *)long long __p = v181;
  v185 = sub_10004D37C(&v180[1].__m_.__sig, (unint64_t *)__p);
  if (v185)
  {
    v186 = (std::__shared_weak_count *)v185[4];
    uint64_t v254 = v185[3];
    if (v186)
    {
      atomic_fetch_add_explicit(&v186->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v180);
      atomic_fetch_add_explicit(&v186->__shared_owners_, 1uLL, memory_order_relaxed);
      v249 = v186;
      sub_10004D2C8(v186);
      char v187 = 0;
      goto LABEL_474;
    }
  }
  else
  {
    uint64_t v254 = 0;
  }
  std::mutex::unlock(v180);
  v249 = 0;
  char v187 = 1;
LABEL_474:
  v188 = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 16));
  v189 = v188;
  if (v190 < 0)
  {
    v191 = (unsigned __int8 *)(v190 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v192 = 5381;
    do
    {
      uint64_t v190 = v192;
      unsigned int v193 = *v191++;
      uint64_t v192 = (33 * v192) ^ v193;
    }
    while (v193);
  }
  std::mutex::lock(v188);
  *(void *)long long __p = v190;
  v194 = sub_10004D37C(&v189[1].__m_.__sig, (unint64_t *)__p);
  char v251 = v187;
  if (!v194)
  {
    uint64_t v258 = 0;
    goto LABEL_481;
  }
  v195 = (std::__shared_weak_count *)v194[4];
  uint64_t v258 = v194[3];
  if (!v195)
  {
LABEL_481:
    std::mutex::unlock(v189);
    std::string __str = 0;
    char v250 = 1;
    goto LABEL_482;
  }
  atomic_fetch_add_explicit(&v195->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v189);
  atomic_fetch_add_explicit(&v195->__shared_owners_, 1uLL, memory_order_relaxed);
  std::string __str = v195;
  sub_10004D2C8(v195);
  char v250 = 0;
LABEL_482:
  v196 = *(void **)(a1 + 104);
  if (v196 != (void *)(a1 + 112))
  {
    v256 = (uint64_t **)(a1 + 32);
    do
    {
      v197 = v196 + 5;
      uint64_t v198 = *(void *)(a1 + 56);
      uint64_t v199 = *(void *)(a1 + 64);
      if (*((char *)v196 + 63) < 0)
      {
        sub_10004FC84(cf, (void *)v196[5], v196[6]);
      }
      else
      {
        *(_OWORD *)CFTypeRef cf = *v197;
        CFTypeRef v269 = (CFTypeRef)v196[7];
      }
      char v200 = HIBYTE(v269);
      if (v198 != v199)
      {
        if (SHIBYTE(v269) >= 0) {
          CFTypeRef v201 = (CFTypeRef)HIBYTE(v269);
        }
        else {
          CFTypeRef v201 = cf[1];
        }
        if (SHIBYTE(v269) >= 0) {
          v202 = cf;
        }
        else {
          v202 = (CFTypeRef *)cf[0];
        }
        do
        {
          uint64_t v203 = *(unsigned __int8 *)(v198 + 95);
          if ((v203 & 0x80u) == 0) {
            CFTypeRef v204 = (CFTypeRef)*(unsigned __int8 *)(v198 + 95);
          }
          else {
            CFTypeRef v204 = *(CFTypeRef *)(v198 + 80);
          }
          if (v204 == v201)
          {
            if ((v203 & 0x80) != 0)
            {
              if (!memcmp(*(const void **)(v198 + 72), v202, *(void *)(v198 + 80))) {
                goto LABEL_507;
              }
            }
            else
            {
              if (!*(unsigned char *)(v198 + 95)) {
                goto LABEL_507;
              }
              uint64_t v205 = 0;
              while (*(unsigned __int8 *)(v198 + v205 + 72) == *((unsigned __int8 *)v202 + v205))
              {
                if (v203 == ++v205) {
                  goto LABEL_507;
                }
              }
            }
          }
          v198 += 168;
        }
        while (v198 != v199);
        uint64_t v198 = v199;
      }
LABEL_507:
      if (v200 < 0) {
        operator delete((void *)cf[0]);
      }
      if (*((char *)v196 + 63) < 0)
      {
        if (!v196[6]) {
          goto LABEL_650;
        }
      }
      else if (!*((unsigned char *)v196 + 63))
      {
        goto LABEL_650;
      }
      if (v198 != *(void *)(a1 + 64))
      {
        memset(v267, 0, 24);
        *(void *)long long __p = v196 + 4;
        v206 = sub_10008CC40(v256, (int *)v196 + 8, (uint64_t)&unk_10144E20E, (_DWORD **)__p);
        if (*((char *)v206 + 63) < 0)
        {
          sub_10004FC84(v267, v206[5], (unint64_t)v206[6]);
        }
        else
        {
          *(_OWORD *)v267 = *(_OWORD *)(v206 + 5);
          *(void *)&v267[16] = v206[7];
        }
        int isEsimCapable = subscriber::isEsimCapable();
        if (v258) {
          int v208 = isEsimCapable;
        }
        else {
          int v208 = 0;
        }
        if (v208 == 1)
        {
          long long v319 = 0u;
          *(_OWORD *)__n = 0u;
          memset(v317, 0, sizeof(v317));
          long long v316 = 0u;
          long long v315 = 0u;
          long long v314 = 0u;
          long long v313 = 0u;
          long long v311 = 0u;
          long long v312 = 0u;
          long long v310 = 0u;
          memset(buf, 0, sizeof(buf));
          sGetProfileDetails();
          uint64_t v209 = BYTE7(v319);
          size_t v210 = __n[1];
          if ((SBYTE7(v319) & 0x80u) == 0) {
            size_t v211 = BYTE7(v319);
          }
          else {
            size_t v211 = __n[1];
          }
          uint64_t v212 = v267[23];
          if (v267[23] < 0) {
            uint64_t v212 = *(void *)&v267[8];
          }
          if (v211 != v212) {
            goto LABEL_558;
          }
          if (v267[23] >= 0) {
            v213 = v267;
          }
          else {
            v213 = *(unsigned __int8 **)v267;
          }
          if ((BYTE7(v319) & 0x80) != 0)
          {
            int v223 = memcmp((const void *)__n[0], v213, __n[1]);
            size_t v211 = v210;
            if (v223) {
              goto LABEL_558;
            }
          }
          else if (BYTE7(v319))
          {
            v214 = __n;
            while (*(unsigned __int8 *)v214 == *v213)
            {
              v214 = (size_t *)((char *)v214 + 1);
              ++v213;
              if (!--v209) {
                goto LABEL_595;
              }
            }
LABEL_558:
            if (v211) {
              char v224 = v174;
            }
            else {
              char v224 = 1;
            }
            if ((v224 & 1) == 0)
            {
              LOBYTE(v293[0]) = 0;
              *(void *)long long __p = _NSConcreteStackBlock;
              *(void *)&__p[8] = 0x40000000;
              *(void *)&__p[16] = sub_100495E98;
              *(void *)&__p[24] = &unk_1019D22B0;
              *(void *)&long long v321 = &v314;
              *((void *)&v321 + 1) = (char *)&v315 + 8;
              *(void *)&long long v322 = v317;
              *((void *)&v322 + 1) = &v317[1];
              v323[0] = v293;
              sub_100495CB8((wis::MetricFactory *)0x80141);
            }
            uint64_t v226 = *(void *)(a1 + 80);
            uint64_t v225 = *(void *)(a1 + 88);
            while (1)
            {
              if (v226 == v225)
              {
                uint64_t v227 = 0;
                uint64_t v228 = 0;
                goto LABEL_569;
              }
              long long v329 = 0u;
              *(_OWORD *)v328 = 0u;
              memset(v327, 0, sizeof(v327));
              *(_OWORD *)v326 = 0u;
              memset(v325, 0, sizeof(v325));
              *(_OWORD *)v324 = 0u;
              memset(v323, 0, sizeof(v323));
              long long v322 = 0u;
              long long v321 = 0u;
              memset(__p, 0, sizeof(__p));
              VinylInfo::findProfile();
              if (BYTE8(v329)) {
                break;
              }
              v226 += 88;
            }
            uint64_t v227 = *(void *)(v226 + 16);
            uint64_t v228 = *(void *)(v226 + 24);
            sub_1000C584C((uint64_t)__p);
LABEL_569:
            if (*((char *)v196 + 63) < 0)
            {
              sub_10004FC84(v265, (void *)v196[5], v196[6]);
            }
            else
            {
              *(_OWORD *)v265 = *v197;
              *(void *)&long long v266 = v196[7];
            }
            if ((v267[23] & 0x80000000) != 0)
            {
              sub_10004FC84(v295, *(void **)v267, *(unint64_t *)&v267[8]);
            }
            else
            {
              *(_OWORD *)v295 = *(_OWORD *)v267;
              uint64_t v296 = *(void *)&v267[16];
            }
            __dst[0] = (void *)a1;
            if (*((char *)v196 + 63) < 0)
            {
              sub_10004FC84(&__dst[1], (void *)v196[5], v196[6]);
            }
            else
            {
              *(_OWORD *)&__dst[1] = *v197;
              __dst[3] = *((void **)v196 + 7);
            }
            if ((v267[23] & 0x80000000) != 0)
            {
              sub_10004FC84(v277, *(void **)v267, *(unint64_t *)&v267[8]);
            }
            else
            {
              *(_OWORD *)v277 = *(_OWORD *)v267;
              *(void *)&long long v278 = *(void *)&v267[16];
            }
            *((void *)&v300[1] + 1) = 0;
            v229 = operator new(0x40uLL);
            v230 = v229;
            v231 = __dst[0];
            void *v229 = off_1019EA0F8;
            v229[1] = v231;
            if (SHIBYTE(__dst[3]) < 0)
            {
              sub_10004FC84((unsigned char *)v229 + 16, __dst[1], (unint64_t)__dst[2]);
            }
            else
            {
              *((_OWORD *)v229 + 1) = *(_OWORD *)&__dst[1];
              v229[4] = __dst[3];
            }
            v232 = v230 + 5;
            if (SBYTE7(v278) < 0)
            {
              sub_10004FC84(v232, v277[0], (unint64_t)v277[1]);
            }
            else
            {
              *(_OWORD *)v232 = *(_OWORD *)v277;
              v230[7] = v278;
            }
            *((void *)&v300[1] + 1) = v230;
            (*(void (**)(uint64_t, uint64_t, uint64_t, CFTypeRef *, void **, _OWORD *))(*(void *)v258 + 152))(v258, v227, v228, v265, v295, v300);
            sub_1000C752C(v300);
            if (SBYTE7(v278) < 0) {
              operator delete(v277[0]);
            }
            if (SHIBYTE(__dst[3]) < 0) {
              operator delete(__dst[1]);
            }
            if (SHIBYTE(v296) < 0) {
              operator delete(v295[0]);
            }
            if (SBYTE7(v266) < 0) {
              operator delete((void *)v265[0]);
            }
          }
LABEL_595:
          if (BYTE8(v319)) {
            sub_1000C584C((uint64_t)buf);
          }
LABEL_648:
          if ((v267[23] & 0x80000000) != 0) {
            operator delete(*(void **)v267);
          }
          goto LABEL_650;
        }
        if (!v254)
        {
          v215 = *v260;
          if (os_log_type_enabled(*v260, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)long long __p = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v215, OS_LOG_TYPE_ERROR, "PersonalWallet interface not available", __p, 2u);
          }
          goto LABEL_648;
        }
        v293[1] = 0;
        v293[0] = 0;
        uint64_t v294 = 0;
        if (*((char *)v196 + 63) < 0)
        {
          sub_10004FC84(v293, (void *)v196[5], v196[6]);
        }
        else
        {
          *(_OWORD *)v293 = *v197;
          uint64_t v294 = v196[7];
        }
        v292 = 0;
        (*(void (**)(const void **__return_ptr))(*(void *)v254 + 24))(&v292);
        uint64_t v289 = 0;
        long long v288 = 0uLL;
        ctu::cf::assign();
        uint64_t v291 = v289;
        *(_OWORD *)v290 = v288;
        uint64_t v289 = 0;
        long long v288 = 0uLL;
        uint64_t v216 = *(void *)&v267[8];
        uint64_t v217 = HIBYTE(v291);
        char v218 = HIBYTE(v291);
        size_t v219 = v290[1];
        if (v291 >= 0) {
          size_t v220 = HIBYTE(v291);
        }
        else {
          size_t v220 = v290[1];
        }
        if (v267[23] >= 0) {
          uint64_t v216 = v267[23];
        }
        if (v220 == v216)
        {
          if (v267[23] >= 0) {
            v221 = v267;
          }
          else {
            v221 = *(unsigned __int8 **)v267;
          }
          if ((SHIBYTE(v291) & 0x80000000) == 0)
          {
            if (HIBYTE(v291))
            {
              v222 = v290;
              while (*(unsigned __int8 *)v222 == *v221)
              {
                v222 = (size_t *)((char *)v222 + 1);
                ++v221;
                if (!--v217) {
                  goto LABEL_643;
                }
              }
              goto LABEL_598;
            }
LABEL_646:
            sub_1000577C4(&v292);
            if (SHIBYTE(v294) < 0) {
              operator delete(v293[0]);
            }
            goto LABEL_648;
          }
          v233 = (void *)v290[0];
          int v234 = memcmp((const void *)v290[0], v221, v290[1]);
          size_t v220 = v219;
          if (v234) {
            goto LABEL_598;
          }
        }
        else
        {
LABEL_598:
          if (v220)
          {
            *(void *)&long long v314 = 0;
            long long v313 = 0u;
            long long v311 = 0u;
            long long v312 = 0u;
            long long v310 = 0u;
            memset(buf, 0, sizeof(buf));
            sub_1005ACED0((uint64_t)__p, a1, (const std::string *)(v196 + 5));
            sub_1005AD688((uint64_t)buf, (uint64_t)__p);
            if (SBYTE7(v327[0]) < 0) {
              operator delete(v326[0]);
            }
            if (SHIBYTE(v325[1]) < 0) {
              operator delete(*((void **)&v325[0] + 1));
            }
            if (SBYTE7(v325[0]) < 0) {
              operator delete(v324[0]);
            }
            if (SHIBYTE(v323[3]) < 0) {
              operator delete(v323[1]);
            }
            v299 = (void **)&v321 + 1;
            sub_10002E39C(&v299);
            if (*(void *)&__p[16])
            {
              *(void *)&__p[24] = *(void *)&__p[16];
              operator delete(*(void **)&__p[16]);
            }
            if ((_BYTE)v314)
            {
              LOBYTE(v299) = 0;
              *(void *)long long __p = _NSConcreteStackBlock;
              *(void *)&__p[8] = 0x40000000;
              *(void *)&__p[16] = sub_100495E98;
              *(void *)&__p[24] = &unk_1019D22B0;
              *(void *)&long long v321 = buf;
              *((void *)&v321 + 1) = &buf[24];
              *(void *)&long long v322 = &v311;
              *((void *)&v322 + 1) = (char *)&v312 + 8;
              v323[0] = &v299;
              sub_100495CB8((wis::MetricFactory *)0x80141);
            }
            sub_1005ADA04((uint64_t)buf);
          }
          v287 = 0;
          *(void *)long long __p = v196 + 4;
          v235 = sub_10008CC40(v256, (int *)v196 + 8, (uint64_t)&unk_10144E20E, (_DWORD **)__p);
          if (*((char *)v235 + 63) < 0)
          {
            sub_10004FC84(v285, v235[5], (unint64_t)v235[6]);
          }
          else
          {
            *(_OWORD *)v285 = *(_OWORD *)(v235 + 5);
            v286 = v235[7];
          }
          if (SHIBYTE(v286) < 0)
          {
            sub_10004FC84(buf, v285[0], (unint64_t)v285[1]);
          }
          else
          {
            *(_OWORD *)long long buf = *(_OWORD *)v285;
            *(void *)&uint8_t buf[16] = v286;
          }
          v297 = 0;
          if ((char)buf[23] < 0)
          {
            sub_10004FC84(__p, *(void **)buf, *(unint64_t *)&buf[8]);
          }
          else
          {
            *(_OWORD *)long long __p = *(_OWORD *)buf;
            *(void *)&__p[16] = *(void *)&buf[16];
          }
          v298 = 0;
          if (ctu::cf::convert_copy())
          {
            v236 = v297;
            v297 = v298;
            v299 = v236;
            sub_1000558F4((const void **)&v299);
          }
          if ((__p[23] & 0x80000000) != 0) {
            operator delete(*(void **)__p);
          }
          v287 = v297;
          v297 = 0;
          sub_1000558F4((const void **)&v297);
          if ((char)buf[23] < 0) {
            operator delete(*(void **)buf);
          }
          if (SHIBYTE(v286) < 0) {
            operator delete(v285[0]);
          }
          int v237 = (*(uint64_t (**)(uint64_t, void **, const __CFString *, void **, const __CFString *, void, uint64_t, void))(*(void *)v254 + 16))(v254, v293, @"LastUsedImei", v287, @"SubscriptionConfiguration", 0, 1, 0);
          v238 = *v260;
          if (v237)
          {
            if (os_log_type_enabled(*v260, OS_LOG_TYPE_FAULT))
            {
              v239 = v267;
              if (v267[23] < 0) {
                v239 = *(unsigned char **)v267;
              }
              if (*((char *)v196 + 63) < 0) {
                v197 = *(_OWORD **)v197;
              }
              *(_DWORD *)long long __p = 136315394;
              *(void *)&__p[4] = v239;
              *(_WORD *)&unsigned char __p[12] = 2080;
              *(void *)&__p[14] = v197;
              _os_log_fault_impl((void *)&_mh_execute_header, v238, OS_LOG_TYPE_FAULT, "Failed to store last used IMEI (%s) for SIM (%s)", __p, 0x16u);
            }
          }
          else if (os_log_type_enabled(*v260, OS_LOG_TYPE_DEFAULT))
          {
            *(void *)long long buf = v196 + 4;
            v240 = sub_10008CC40(v256, (int *)v196 + 8, (uint64_t)&unk_10144E20E, (_DWORD **)buf);
            v241 = v240 + 5;
            if (*((char *)v240 + 63) < 0) {
              v241 = (void *)*v241;
            }
            if (*((char *)v196 + 63) < 0) {
              v197 = *(_OWORD **)v197;
            }
            *(_DWORD *)long long __p = 136315394;
            *(void *)&__p[4] = v241;
            *(_WORD *)&unsigned char __p[12] = 2080;
            *(void *)&__p[14] = v197;
            _os_log_impl((void *)&_mh_execute_header, v238, OS_LOG_TYPE_DEFAULT, "#I Stored last used IMEI (%s) for SIM (%s)", __p, 0x16u);
          }
          sub_1000558F4((const void **)&v287);
          char v218 = HIBYTE(v291);
LABEL_643:
          if ((v218 & 0x80) == 0) {
            goto LABEL_646;
          }
          v233 = (void *)v290[0];
        }
        operator delete(v233);
        goto LABEL_646;
      }
LABEL_650:
      v242 = (void *)v196[1];
      if (v242)
      {
        do
        {
          v243 = v242;
          v242 = (void *)*v242;
        }
        while (v242);
      }
      else
      {
        do
        {
          v243 = (void *)v196[2];
          BOOL v25 = *v243 == (void)v196;
          v196 = v243;
        }
        while (!v25);
      }
      v196 = v243;
    }
    while (v243 != (void *)(a1 + 112));
  }
  if ((v250 & 1) == 0) {
    sub_10004D2C8(__str);
  }
  v173 = v253;
  if ((v251 & 1) == 0) {
    sub_10004D2C8(v249);
  }
LABEL_660:
  v244 = *v173;
  if (*v173 != v20)
  {
    do
    {
      int v245 = sub_1005ABED0(a1, (uint64_t)(v244 + 4));
      if (v245 == 2)
      {
        HIDWORD(v264) = sub_1005AC014(a1, (uint64_t)(v244 + 4));
      }
      else if (v245 == 1)
      {
        LODWORD(v264) = sub_1005AC014(a1, (uint64_t)(v244 + 4));
      }
      v246 = v244[1];
      if (v246)
      {
        do
        {
          v247 = (std::string **)v246;
          v246 = (std::string *)v246->__r_.__value_.__r.__words[0];
        }
        while (v246);
      }
      else
      {
        do
        {
          v247 = (std::string **)v244[2];
          BOOL v25 = *v247 == (std::string *)v244;
          v244 = v247;
        }
        while (!v25);
      }
      v244 = v247;
    }
    while (v247 != v20);
  }
  SubscriptionSlotConfiguration::log((SubscriptionSlotConfiguration *)&v264, (const ctu::OsLogLogger *)v260, "Result configuration");
  unsigned __int8 v8 = v264;
  unint64_t v9 = v264 & 0xFFFFFFFFFFFFFF00;
  sub_1000886C0((uint64_t)&v261, v262);
  return v9 & 0xFFFFFFFFFFFFFF00 | v8;
}

void sub_1005AB778(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,char a39,uint64_t a40,uint64_t a41,uint64_t a42,void *a43,uint64_t a44,uint64_t a45,uint64_t a46,void *__p,uint64_t a48,int a49,__int16 a50,char a51,char a52,char a53)
{
  if (a53)
  {
    if (a52 < 0) {
      operator delete(__p);
    }
  }
  sub_1001FEB64((uint64_t)&STACK[0x2A0], (void *)STACK[0x2A8]);
  sub_1000DA2E4((char *)STACK[0x2C8]);
  long long __p = &STACK[0x2E0];
  sub_100047F64((void ***)&__p);
  sub_1000886C0((uint64_t)&a39, (char *)a40);
  _Unwind_Resume(a1);
}

void sub_1005ABCB0(Registry *a1@<X0>, void *a2@<X8>)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(a1);
  char v4 = ServiceMap;
  if ((v5 & 0x8000000000000000) != 0)
  {
    unint64_t v6 = (unsigned __int8 *)(v5 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v7 = 5381;
    do
    {
      unint64_t v5 = v7;
      unsigned int v8 = *v6++;
      uint64_t v7 = (33 * v7) ^ v8;
    }
    while (v8);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v12 = v5;
  unint64_t v9 = sub_10004D37C(&v4[1].__m_.__sig, &v12);
  if (v9)
  {
    uint64_t v11 = v9[3];
    uint64_t v10 = (std::__shared_weak_count *)v9[4];
    if (v10) {
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
    }
  }
  else
  {
    uint64_t v11 = 0;
    uint64_t v10 = 0;
  }
  std::mutex::unlock(v4);
  *a2 = v11;
  a2[1] = v10;
  if (v10)
  {
    atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v10);
  }
}

void sub_1005ABD78(unsigned char *a1, uint64_t *a2, uint64_t a3)
{
  if (*(char *)(a3 + 23) < 0)
  {
    if (!*(void *)(a3 + 8)) {
      goto LABEL_31;
    }
    uint64_t v4 = *a2;
    unint64_t v5 = a2 + 1;
    uint64_t v6 = a2[1];
    sub_10004FC84(__p, *(void **)a3, *(void *)(a3 + 8));
  }
  else
  {
    if (!*(unsigned char *)(a3 + 23)) {
      goto LABEL_31;
    }
    uint64_t v4 = *a2;
    unint64_t v5 = a2 + 1;
    uint64_t v6 = a2[1];
    *(_OWORD *)long long __p = *(_OWORD *)a3;
    uint64_t v14 = *(void *)(a3 + 16);
  }
  char v7 = HIBYTE(v14);
  if (v4 == v6) {
    goto LABEL_27;
  }
  if (v14 >= 0) {
    unsigned int v8 = (void *)HIBYTE(v14);
  }
  else {
    unsigned int v8 = __p[1];
  }
  if (v14 >= 0) {
    unint64_t v9 = __p;
  }
  else {
    unint64_t v9 = (void **)__p[0];
  }
  while (1)
  {
    uint64_t v10 = *(unsigned __int8 *)(v4 + 95);
    if ((v10 & 0x80u) == 0) {
      uint64_t v11 = (void *)*(unsigned __int8 *)(v4 + 95);
    }
    else {
      uint64_t v11 = *(void **)(v4 + 80);
    }
    if (v11 != v8) {
      goto LABEL_24;
    }
    if ((v10 & 0x80) != 0) {
      break;
    }
    if (!*(unsigned char *)(v4 + 95)) {
      goto LABEL_26;
    }
    uint64_t v12 = 0;
    while (*(unsigned __int8 *)(v4 + v12 + 72) == *((unsigned __int8 *)v9 + v12))
    {
      if (v10 == ++v12) {
        goto LABEL_26;
      }
    }
LABEL_24:
    v4 += 168;
    if (v4 == v6) {
      goto LABEL_27;
    }
  }
  if (memcmp(*(const void **)(v4 + 72), v9, *(void *)(v4 + 80))) {
    goto LABEL_24;
  }
LABEL_26:
  uint64_t v6 = v4;
LABEL_27:
  if (v7 < 0) {
    operator delete(__p[0]);
  }
  if (v6 != *v5)
  {
    sub_10002E664((uint64_t)a1, v6);
    a1[168] = 1;
    return;
  }
LABEL_31:
  *a1 = 0;
  a1[168] = 0;
}

uint64_t sub_1005ABED0(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void **)(a1 + 104);
  uint64_t v3 = (void *)(a1 + 112);
  if (*(char *)(a2 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)long long __p = *(_OWORD *)a2;
    uint64_t v15 = *(void *)(a2 + 16);
  }
  char v4 = HIBYTE(v15);
  if (v2 != v3)
  {
    if (v15 >= 0) {
      unint64_t v5 = (void *)HIBYTE(v15);
    }
    else {
      unint64_t v5 = __p[1];
    }
    if (v15 >= 0) {
      uint64_t v6 = __p;
    }
    else {
      uint64_t v6 = (void **)__p[0];
    }
    do
    {
      uint64_t v7 = *((unsigned __int8 *)v2 + 63);
      if ((v7 & 0x80u) == 0) {
        unsigned int v8 = (void *)*((unsigned __int8 *)v2 + 63);
      }
      else {
        unsigned int v8 = (void *)v2[6];
      }
      if (v8 == v5)
      {
        if ((v7 & 0x80) != 0)
        {
          if (!memcmp((const void *)v2[5], v6, v2[6])) {
            goto LABEL_29;
          }
        }
        else
        {
          if (!*((unsigned char *)v2 + 63)) {
            goto LABEL_29;
          }
          uint64_t v9 = 0;
          while (*((unsigned __int8 *)v2 + v9 + 40) == *((unsigned __int8 *)v6 + v9))
          {
            if (v7 == ++v9) {
              goto LABEL_29;
            }
          }
        }
      }
      uint64_t v10 = (void *)v2[1];
      if (v10)
      {
        do
        {
          uint64_t v11 = v10;
          uint64_t v10 = (void *)*v10;
        }
        while (v10);
      }
      else
      {
        do
        {
          uint64_t v11 = (void *)v2[2];
          BOOL v12 = *v11 == (void)v2;
          uint64_t v2 = v11;
        }
        while (!v12);
      }
      uint64_t v2 = v11;
    }
    while (v11 != v3);
    uint64_t v2 = v3;
  }
LABEL_29:
  if (v4 < 0) {
    operator delete(__p[0]);
  }
  if (v2 == v3) {
    return 0;
  }
  else {
    return *((unsigned int *)v2 + 8);
  }
}

uint64_t sub_1005AC014(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 56);
  uint64_t v4 = *(void *)(a1 + 64);
  if (*(char *)(a2 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)long long __p = *(_OWORD *)a2;
    uint64_t v13 = *(void *)(a2 + 16);
  }
  char v5 = HIBYTE(v13);
  if (v3 != v4)
  {
    if (v13 >= 0) {
      uint64_t v6 = (void *)HIBYTE(v13);
    }
    else {
      uint64_t v6 = __p[1];
    }
    if (v13 >= 0) {
      uint64_t v7 = __p;
    }
    else {
      uint64_t v7 = (void **)__p[0];
    }
    do
    {
      uint64_t v8 = *(unsigned __int8 *)(v3 + 95);
      if ((v8 & 0x80u) == 0) {
        uint64_t v9 = (void *)*(unsigned __int8 *)(v3 + 95);
      }
      else {
        uint64_t v9 = *(void **)(v3 + 80);
      }
      if (v9 == v6)
      {
        if ((v8 & 0x80) != 0)
        {
          if (!memcmp(*(const void **)(v3 + 72), v7, *(void *)(v3 + 80))) {
            goto LABEL_24;
          }
        }
        else
        {
          if (!*(unsigned char *)(v3 + 95)) {
            goto LABEL_24;
          }
          uint64_t v10 = 0;
          while (*(unsigned __int8 *)(v3 + v10 + 72) == *((unsigned __int8 *)v7 + v10))
          {
            if (v8 == ++v10) {
              goto LABEL_24;
            }
          }
        }
      }
      v3 += 168;
    }
    while (v3 != v4);
    uint64_t v3 = v4;
  }
LABEL_24:
  if (v5 < 0) {
    operator delete(__p[0]);
  }
  if (v3 == *(void *)(a1 + 64)) {
    return 0;
  }
  else {
    return *(unsigned int *)(v3 + 4);
  }
}

BOOL sub_1005AC130(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  *(void *)uint64_t v61 = 0;
  CFMutableArrayRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  if (Mutable)
  {
    uint64_t v13 = *(__CFArray **)v61;
    *(void *)uint64_t v61 = Mutable;
    *(void *)long long buf = v13;
    sub_1000440D4((const void **)buf);
  }
  sub_1001C6B94(*(__CFArray **)v61, @"PreferLastUsedImei");
  CFDictionaryRef v60 = 0;
  sub_100044D6C(&theArray, (CFTypeRef *)v61);
  uint64_t v14 = *(unsigned __int8 *)(a2 + 23);
  if ((v14 & 0x80u) != 0) {
    uint64_t v14 = *(void *)(a2 + 8);
  }
  if (!v14) {
    goto LABEL_13;
  }
  uint64_t v15 = *(unsigned __int8 *)(a3 + 23);
  if ((v15 & 0x80u) != 0) {
    uint64_t v15 = *(void *)(a3 + 8);
  }
  if (!v15)
  {
LABEL_13:
    CFDictionaryRef v60 = 0;
    goto LABEL_145;
  }
  long long v78 = 0u;
  long long v79 = 0u;
  MCC::MCC();
  long long v76 = 0u;
  long long v77 = 0u;
  MNC::MNC();
  v74[0] = 0;
  v74[1] = 0;
  uint64_t v75 = 0;
  formPLMN((const MCC *)&v78, (const MNC *)&v76);
  *(void *)uint64_t v73 = 0;
  CFMutableDictionaryRef v16 = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (v16)
  {
    unsigned int v17 = *(__CFDictionary **)v73;
    *(void *)uint64_t v73 = v16;
    *(void *)long long buf = v17;
    sub_10005717C((const void **)buf);
  }
  if (SHIBYTE(v75) < 0)
  {
    sub_10004FC84(&__dst, v74[0], (unint64_t)v74[1]);
  }
  else
  {
    long long __dst = *(_OWORD *)v74;
    uint64_t v72 = v75;
  }
  if (SHIBYTE(v72) < 0)
  {
    sub_10004FC84(&__p, (void *)__dst, *((unint64_t *)&__dst + 1));
  }
  else
  {
    long long __p = __dst;
    uint64_t v82 = v72;
  }
  v64[0] = 0;
  if (SHIBYTE(v82) < 0)
  {
    sub_10004FC84(buf, (void *)__p, *((unint64_t *)&__p + 1));
  }
  else
  {
    *(_OWORD *)long long buf = __p;
    *(void *)&uint8_t buf[16] = v82;
  }
  v67[0] = 0;
  if (ctu::cf::convert_copy())
  {
    uint32_t v18 = v64[0];
    v64[0] = v67[0];
    v69[0] = v18;
    sub_1000558F4((const void **)v69);
  }
  if ((char)buf[23] < 0) {
    operator delete(*(void **)buf);
  }
  CFTypeRef v62 = v64[0];
  v64[0] = 0;
  sub_1000558F4((const void **)v64);
  if (SHIBYTE(v82) < 0) {
    operator delete((void *)__p);
  }
  sub_10010F3F0(*(__CFDictionary **)v73, (void *)qword_101B13EC0, (uint64_t)v62);
  sub_1000558F4(&v62);
  if (SHIBYTE(v72) < 0) {
    operator delete((void *)__dst);
  }
  if (*(char *)(a4 + 23) < 0)
  {
    sub_10004FC84(v69, *(void **)a4, *(void *)(a4 + 8));
  }
  else
  {
    *(_OWORD *)uint64_t v69 = *(_OWORD *)a4;
    uint64_t v70 = *(void *)(a4 + 16);
  }
  if (SHIBYTE(v70) < 0)
  {
    sub_10004FC84(&__p, v69[0], (unint64_t)v69[1]);
  }
  else
  {
    long long __p = *(_OWORD *)v69;
    uint64_t v82 = v70;
  }
  CFTypeRef v62 = 0;
  if (SHIBYTE(v82) < 0)
  {
    sub_10004FC84(buf, (void *)__p, *((unint64_t *)&__p + 1));
  }
  else
  {
    *(_OWORD *)long long buf = __p;
    *(void *)&uint8_t buf[16] = v82;
  }
  v64[0] = 0;
  if (ctu::cf::convert_copy())
  {
    CFTypeRef v19 = v62;
    CFTypeRef v62 = v64[0];
    v67[0] = (void *)v19;
    sub_1000558F4((const void **)v67);
  }
  if ((char)buf[23] < 0) {
    operator delete(*(void **)buf);
  }
  CFDictionaryRef v83 = (const __CFDictionary *)v62;
  CFTypeRef v62 = 0;
  sub_1000558F4(&v62);
  if (SHIBYTE(v82) < 0) {
    operator delete((void *)__p);
  }
  sub_10010F3F0(*(__CFDictionary **)v73, @"GID1", (uint64_t)v83);
  sub_1000558F4((const void **)&v83);
  if (SHIBYTE(v70) < 0) {
    operator delete(v69[0]);
  }
  if (*(char *)(a5 + 23) < 0)
  {
    sub_10004FC84(v67, *(void **)a5, *(void *)(a5 + 8));
  }
  else
  {
    *(_OWORD *)xpc_object_t v67 = *(_OWORD *)a5;
    uint64_t v68 = *(void *)(a5 + 16);
  }
  if (SHIBYTE(v68) < 0)
  {
    sub_10004FC84(&__p, v67[0], (unint64_t)v67[1]);
  }
  else
  {
    long long __p = *(_OWORD *)v67;
    uint64_t v82 = v68;
  }
  CFDictionaryRef v83 = 0;
  if (SHIBYTE(v82) < 0)
  {
    sub_10004FC84(buf, (void *)__p, *((unint64_t *)&__p + 1));
  }
  else
  {
    *(_OWORD *)long long buf = __p;
    *(void *)&uint8_t buf[16] = v82;
  }
  CFTypeRef v62 = 0;
  if (ctu::cf::convert_copy())
  {
    CFDictionaryRef v20 = v83;
    CFDictionaryRef v83 = (const __CFDictionary *)v62;
    v64[0] = v20;
    sub_1000558F4((const void **)v64);
  }
  if ((char)buf[23] < 0) {
    operator delete(*(void **)buf);
  }
  CFDictionaryRef theDict = v83;
  CFDictionaryRef v83 = 0;
  sub_1000558F4((const void **)&v83);
  if (SHIBYTE(v82) < 0) {
    operator delete((void *)__p);
  }
  sub_10010F3F0(*(__CFDictionary **)v73, @"GID2", (uint64_t)theDict);
  sub_1000558F4((const void **)&theDict);
  if (SHIBYTE(v68) < 0) {
    operator delete(v67[0]);
  }
  if (*(char *)(a6 + 23) < 0)
  {
    unint64_t v21 = *(void *)(a6 + 8);
    if (!v21) {
      goto LABEL_82;
    }
    sub_10004FC84(v64, *(void **)a6, v21);
  }
  else
  {
    if (!*(unsigned char *)(a6 + 23)) {
      goto LABEL_82;
    }
    *(_OWORD *)long long v64 = *(_OWORD *)a6;
    uint64_t v65 = *(void *)(a6 + 16);
  }
  if (SHIBYTE(v65) < 0)
  {
    sub_10004FC84(&__p, v64[0], (unint64_t)v64[1]);
  }
  else
  {
    long long __p = *(_OWORD *)v64;
    uint64_t v82 = v65;
  }
  CFDictionaryRef theDict = 0;
  if (SHIBYTE(v82) < 0)
  {
    sub_10004FC84(buf, (void *)__p, *((unint64_t *)&__p + 1));
  }
  else
  {
    *(_OWORD *)long long buf = __p;
    *(void *)&uint8_t buf[16] = v82;
  }
  CFDictionaryRef v83 = 0;
  if (ctu::cf::convert_copy())
  {
    CFDictionaryRef v22 = theDict;
    CFDictionaryRef theDict = v83;
    CFTypeRef v62 = v22;
    sub_1000558F4(&v62);
  }
  if ((char)buf[23] < 0) {
    operator delete(*(void **)buf);
  }
  CFDictionaryRef v66 = theDict;
  CFDictionaryRef theDict = 0;
  sub_1000558F4((const void **)&theDict);
  if (SHIBYTE(v82) < 0) {
    operator delete((void *)__p);
  }
  sub_10010F3F0(*(__CFDictionary **)v73, (void *)qword_101B13EB8, (uint64_t)v66);
  sub_1000558F4((const void **)&v66);
  if (SHIBYTE(v65) < 0) {
    operator delete(v64[0]);
  }
LABEL_82:
  uint64_t v92 = 0;
  long long v90 = 0u;
  long long v91 = 0u;
  long long v88 = 0u;
  long long v89 = 0u;
  long long v86 = 0u;
  long long v87 = 0u;
  long long v85 = 0u;
  memset(buf, 0, sizeof(buf));
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 16));
  uint64_t v24 = ServiceMap;
  if (v25 < 0)
  {
    uint64_t v26 = (unsigned __int8 *)(v25 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v27 = 5381;
    do
    {
      uint64_t v25 = v27;
      unsigned int v28 = *v26++;
      uint64_t v27 = (33 * v27) ^ v28;
    }
    while (v28);
  }
  std::mutex::lock(ServiceMap);
  *(void *)&long long __p = v25;
  uint64_t v29 = sub_10004D37C(&v24[1].__m_.__sig, (unint64_t *)&__p);
  if (v29)
  {
    uint64_t v31 = v29[3];
    uint64_t v30 = (std::__shared_weak_count *)v29[4];
    if (v30)
    {
      atomic_fetch_add_explicit(&v30->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v24);
      atomic_fetch_add_explicit(&v30->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v30);
      char v32 = 0;
      goto LABEL_90;
    }
  }
  else
  {
    uint64_t v31 = 0;
  }
  std::mutex::unlock(v24);
  uint64_t v30 = 0;
  char v32 = 1;
LABEL_90:
  sub_10004EFE4(&v83, (CFTypeRef *)v73);
  (*(void (**)(uint8_t *__return_ptr, uint64_t, const __CFDictionary **))(*(void *)v31 + 32))(buf, v31, &v83);
  sub_100057D78((const void **)&v83);
  if ((v32 & 1) == 0) {
    sub_10004D2C8(v30);
  }
  long long __p = 0uLL;
  uint64_t v82 = 0;
  if (SHIBYTE(v92) < 0)
  {
    sub_10004FC84(&__p, (void *)v91, *((unint64_t *)&v91 + 1));
  }
  else
  {
    long long __p = v91;
    uint64_t v82 = v92;
  }
  uint64_t v33 = HIBYTE(v82);
  if (v82 < 0) {
    uint64_t v33 = *((void *)&__p + 1);
  }
  if (v33)
  {
    CFDictionaryRef theDict = 0;
    Registry::getFileSystemInterface((uint64_t *)&v62, *(Registry **)(a1 + 16));
    (*(void (**)(CFDictionaryRef *__return_ptr))(*(void *)v62 + 152))(&theDict);
    if (v63) {
      sub_10004D2C8(v63);
    }
    if (theDict) {
      uint64_t v34 = sub_100080778;
    }
    else {
      uint64_t v34 = 0;
    }
    if (v34 && (theArray ? (long long v35 = sub_100083F10) : (long long v35 = 0), v35))
    {
      CFDictionaryRef v66 = 0;
      CFDictionaryRef v36 = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
      if (v36)
      {
        CFDictionaryRef v37 = v66;
        CFDictionaryRef v66 = v36;
        CFTypeRef v62 = v37;
        sub_10005717C(&v62);
      }
      CFIndex Count = CFArrayGetCount(theArray);
      if (Count >= 1)
      {
        for (CFIndex i = 0; i != Count; ++i)
        {
          ValueAtIndex = (void *)CFArrayGetValueAtIndex(theArray, i);
          unint64_t v41 = ValueAtIndex;
          if (ValueAtIndex)
          {
            CFTypeID v42 = CFGetTypeID(ValueAtIndex);
            if (v42 != CFStringGetTypeID()) {
              unint64_t v41 = 0;
            }
          }
          Value = CFDictionaryGetValue(theDict, v41);
          if (Value) {
            sub_1004486E0(v66, v41, (uint64_t)Value);
          }
        }
      }
      if (CFDictionaryGetCount(v66)) {
        sub_10004EFE4(&v60, (CFTypeRef *)&v66);
      }
      else {
        CFDictionaryRef v60 = 0;
      }
      sub_10005717C((const void **)&v66);
    }
    else
    {
      CFDictionaryRef v60 = 0;
    }
    sub_100057D78((const void **)&theDict);
    if ((v82 & 0x8000000000000000) == 0) {
      goto LABEL_127;
    }
    goto LABEL_126;
  }
  CFDictionaryRef v60 = 0;
  if (v82 < 0) {
LABEL_126:
  }
    operator delete((void *)__p);
LABEL_127:
  if (SHIBYTE(v92) < 0) {
    operator delete((void *)v91);
  }
  if (SBYTE7(v90) < 0) {
    operator delete((void *)v89);
  }
  if (SHIBYTE(v88) < 0) {
    operator delete(*((void **)&v87 + 1));
  }
  if (SBYTE7(v87) < 0) {
    operator delete((void *)v86);
  }
  if (SHIBYTE(v85) < 0) {
    operator delete(*(void **)&buf[24]);
  }
  if ((char)buf[23] < 0) {
    operator delete(*(void **)buf);
  }
  sub_10005717C((const void **)v73);
  if (SHIBYTE(v75) < 0) {
    operator delete(v74[0]);
  }
  if (SHIBYTE(v77) < 0) {
    operator delete(*((void **)&v76 + 1));
  }
  if (SHIBYTE(v79) < 0) {
    operator delete(*((void **)&v78 + 1));
  }
LABEL_145:
  sub_100044D00((const void **)&theArray);
  if (v60) {
    uint64_t v44 = sub_100080778;
  }
  else {
    uint64_t v44 = 0;
  }
  if (v44 && CFDictionaryContainsKey(v60, @"PreferLastUsedImei"))
  {
    int v45 = (BOOL *)CFDictionaryGetValue(v60, @"PreferLastUsedImei");
    long long v46 = v45;
    buf[0] = 0;
    if (v45)
    {
      CFTypeID v47 = CFGetTypeID(v45);
      if (v47 == CFBooleanGetTypeID())
      {
        ctu::cf::assign((ctu::cf *)buf, v46, v48);
        LODWORD(v46) = buf[0];
      }
      else
      {
        LODWORD(v46) = 0;
      }
    }
    LOBYTE(v78) = (_BYTE)v46;
    int v52 = *(NSObject **)(a1 + 8);
    if (os_log_type_enabled(v52, OS_LOG_TYPE_DEFAULT))
    {
      int v54 = *(char *)(a6 + 23);
      uint64_t v55 = *(void **)a6;
      uint64_t v56 = printers::asString((printers *)&v78, v53);
      if (v54 >= 0) {
        uint64_t v57 = (void *)a6;
      }
      else {
        uint64_t v57 = v55;
      }
      *(_DWORD *)long long buf = 136315394;
      *(void *)&uint8_t buf[4] = v57;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = v56;
      _os_log_impl((void *)&_mh_execute_header, v52, OS_LOG_TYPE_DEFAULT, "#I PreferLastUsedImei: %s : %s", buf, 0x16u);
      LODWORD(v46) = v78;
    }
    BOOL v50 = v46 != 0;
  }
  else
  {
    unsigned __int8 v49 = *(NSObject **)(a1 + 8);
    BOOL v50 = 0;
    if (os_log_type_enabled(v49, OS_LOG_TYPE_DEFAULT))
    {
      if (*(char *)(a6 + 23) >= 0) {
        uint64_t v51 = (void *)a6;
      }
      else {
        uint64_t v51 = *(void **)a6;
      }
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = v51;
      _os_log_impl((void *)&_mh_execute_header, v49, OS_LOG_TYPE_DEFAULT, "#I PreferLastUsedImei key not found for %s", buf, 0xCu);
      BOOL v50 = 0;
    }
  }
  sub_100057D78((const void **)&v60);
  sub_1000440D4((const void **)v61);
  return v50;
}

void sub_1005ACC24(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, const void *a10, uint64_t a11, const void *a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,const void *a34,void *a35,uint64_t a36,int a37,__int16 a38,char a39,char a40,uint64_t a41,void *a42,uint64_t a43,int a44,__int16 a45,char a46,char a47,uint64_t a48,void *a49,uint64_t a50,int a51,__int16 a52,char a53,char a54,uint64_t a55,const void *a56,void *__p,uint64_t a58,int a59,__int16 a60,char a61,char a62)
{
  if (a62 < 0) {
    operator delete(__p);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  sub_10005717C(&a34);
  if (a40 < 0) {
    operator delete(a35);
  }
  if (a47 < 0) {
    operator delete(a42);
  }
  if (a54 < 0) {
    operator delete(a49);
  }
  sub_100044D00(&a10);
  sub_1000440D4(&a12);
  _Unwind_Resume(a1);
}

void sub_1005ACED0(uint64_t a1, uint64_t a2, const std::string *a3)
{
  *(void *)(a1 + 160) = 0;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a2 + 16));
  uint64_t v7 = ServiceMap;
  if (v8 < 0)
  {
    uint64_t v9 = (unsigned __int8 *)(v8 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v10 = 5381;
    do
    {
      uint64_t v8 = v10;
      unsigned int v11 = *v9++;
      uint64_t v10 = (33 * v10) ^ v11;
    }
    while (v11);
  }
  std::mutex::lock(ServiceMap);
  *(void *)long long buf = v8;
  BOOL v12 = sub_10004D37C(&v7[1].__m_.__sig, (unint64_t *)buf);
  if (v12)
  {
    uint64_t v14 = v12[3];
    uint64_t v13 = (std::__shared_weak_count *)v12[4];
    if (v13)
    {
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v7);
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v13);
      char v15 = 0;
      if (!v14) {
        goto LABEL_7;
      }
      goto LABEL_12;
    }
  }
  else
  {
    uint64_t v14 = 0;
  }
  std::mutex::unlock(v7);
  uint64_t v13 = 0;
  char v15 = 1;
  if (!v14)
  {
LABEL_7:
    CFMutableDictionaryRef v16 = *(NSObject **)(a2 + 8);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "PersonalWallet interface not available", buf, 2u);
      if (v15) {
        return;
      }
      goto LABEL_50;
    }
LABEL_49:
    if (v15) {
      return;
    }
    goto LABEL_50;
  }
LABEL_12:
  std::string::operator=((std::string *)(a1 + 72), a3);
  memset(buf, 0, sizeof(buf));
  uint64_t v33 = 0;
  if (*(char *)(a1 + 95) < 0)
  {
    sub_10004FC84(buf, *(void **)(a1 + 72), *(void *)(a1 + 80));
  }
  else
  {
    *(_OWORD *)long long buf = *(_OWORD *)(a1 + 72);
    uint64_t v33 = *(void *)(a1 + 88);
  }
  uint64_t v31 = 0;
  (*(void (**)(CFTypeRef *__return_ptr, uint64_t, uint8_t *, const __CFString *, const __CFString *, void, uint64_t))(*(void *)v14 + 24))(&cf, v14, buf, @"IMSI", @"SubscriptionConfiguration", 0, 1);
  CFTypeRef v35 = cf;
  if (cf) {
    CFRetain(cf);
  }
  uint64_t v34 = 0;
  v36[0] = 0;
  sub_100056248(v36, &v35);
  if (v36[0]) {
    unsigned int v17 = sub_1000810B8;
  }
  else {
    unsigned int v17 = 0;
  }
  if (v17) {
    sub_100083EB8(&v34, v36);
  }
  sub_1000558F4(v36);
  uint64_t v31 = v34;
  uint64_t v34 = 0;
  sub_1000558F4(&v34);
  sub_1000577C4(&v35);
  sub_1000577C4(&cf);
  ctu::cf::assign();
  memset(v36, 0, 15);
  memset(&v29[1], 0, 24);
  if (*(char *)(a1 + 119) < 0)
  {
    operator delete(*(void **)(a1 + 96));
    CFTypeRef v19 = v36[0];
    *(void *)(a1 + 96) = 0;
    *(void *)(a1 + 104) = v19;
  }
  else
  {
    uint32_t v18 = v36[0];
    *(void *)(a1 + 96) = 0;
    *(void *)(a1 + 104) = v18;
  }
  *(const void **)(a1 + 111) = *(const void **)((char *)v36 + 7);
  *(unsigned char *)(a1 + 119) = 0;
  v29[0] = 0;
  (*(void (**)(CFTypeRef *__return_ptr, uint64_t, uint8_t *, const __CFString *, const __CFString *, void, uint64_t))(*(void *)v14 + 24))(&v28, v14, buf, @"GID1", @"SubscriptionConfiguration", 0, 1);
  CFTypeRef v35 = v28;
  if (v28) {
    CFRetain(v28);
  }
  uint64_t v34 = 0;
  v36[0] = 0;
  sub_100056248(v36, &v35);
  if (v36[0]) {
    CFDictionaryRef v20 = sub_1000810B8;
  }
  else {
    CFDictionaryRef v20 = 0;
  }
  if (v20) {
    sub_100083EB8(&v34, v36);
  }
  sub_1000558F4(v36);
  v29[0] = v34;
  uint64_t v34 = 0;
  sub_1000558F4(&v34);
  sub_1000577C4(&v35);
  sub_1000577C4(&v28);
  ctu::cf::assign();
  memset(v36, 0, 15);
  memset(&v27[1], 0, 24);
  if (*(char *)(a1 + 143) < 0)
  {
    operator delete(*(void **)(a1 + 120));
    CFDictionaryRef v22 = v36[0];
    *(void *)(a1 + 120) = 0;
    *(void *)(a1 + 128) = v22;
  }
  else
  {
    unint64_t v21 = v36[0];
    *(void *)(a1 + 120) = 0;
    *(void *)(a1 + 128) = v21;
  }
  *(const void **)(a1 + 135) = *(const void **)((char *)v36 + 7);
  *(unsigned char *)(a1 + 143) = 0;
  v27[0] = 0;
  (*(void (**)(CFTypeRef *__return_ptr, uint64_t, uint8_t *, const __CFString *, const __CFString *, void, uint64_t))(*(void *)v14 + 24))(&v26, v14, buf, @"GID2", @"SubscriptionConfiguration", 0, 1);
  CFTypeRef v35 = v26;
  if (v26) {
    CFRetain(v26);
  }
  uint64_t v34 = 0;
  v36[0] = 0;
  sub_100056248(v36, &v35);
  if (v36[0]) {
    int v23 = sub_1000810B8;
  }
  else {
    int v23 = 0;
  }
  if (v23) {
    sub_100083EB8(&v34, v36);
  }
  sub_1000558F4(v36);
  v27[0] = v34;
  uint64_t v34 = 0;
  sub_1000558F4(&v34);
  sub_1000577C4(&v35);
  sub_1000577C4(&v26);
  ctu::cf::assign();
  memset(v36, 0, 15);
  if (*(char *)(a1 + 167) < 0)
  {
    operator delete(*(void **)(a1 + 144));
    uint64_t v25 = v36[0];
    *(void *)(a1 + 144) = 0;
    *(void *)(a1 + 152) = v25;
  }
  else
  {
    uint64_t v24 = v36[0];
    *(void *)(a1 + 144) = 0;
    *(void *)(a1 + 152) = v24;
  }
  *(const void **)(a1 + 159) = *(const void **)((char *)v36 + 7);
  *(unsigned char *)(a1 + 167) = 0;
  sub_1000558F4(v27);
  sub_1000558F4(v29);
  sub_1000558F4(&v31);
  if ((SHIBYTE(v33) & 0x80000000) == 0) {
    goto LABEL_49;
  }
  operator delete(*(void **)buf);
  if (v15) {
    return;
  }
LABEL_50:
  sub_10004D2C8(v13);
}

void sub_1005AD494(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,char a27,int a28,__int16 a29,char a30,char a31,void *a32,uint64_t a33,int a34,__int16 a35,char a36,char a37,char a38,int a39,__int16 a40,char a41,char a42,void *a43,uint64_t a44,int a45,__int16 a46,char a47,char a48)
{
  if ((v50 & 1) == 0) {
    sub_10004D2C8(v49);
  }
  sub_100086B34(v48);
  _Unwind_Resume(a1);
}

BOOL sub_1005AD5C4(unsigned __int8 *a1, unsigned __int8 *a2)
{
  if (a1[24]) {
    BOOL v2 = a2[24] == 0;
  }
  else {
    BOOL v2 = 1;
  }
  if (v2) {
    return (a1[24] != 0) ^ (a2[24] != 0);
  }
  uint64_t v3 = a1[23];
  if ((v3 & 0x80u) == 0) {
    uint64_t v4 = a1[23];
  }
  else {
    uint64_t v4 = *((void *)a1 + 1);
  }
  uint64_t v5 = a2[23];
  int v6 = (char)v5;
  if ((v5 & 0x80u) != 0) {
    uint64_t v5 = *((void *)a2 + 1);
  }
  if (v4 != v5) {
    return 1;
  }
  if (v6 < 0) {
    a2 = *(unsigned __int8 **)a2;
  }
  if ((v3 & 0x80) != 0) {
    return memcmp(*(const void **)a1, a2, *((void *)a1 + 1)) != 0;
  }
  if (a1[23])
  {
    uint64_t v7 = v3 - 1;
    do
    {
      int v9 = *a1++;
      int v8 = v9;
      int v10 = *a2++;
      BOOL v2 = v8 == v10;
      uint64_t v3 = v8 != v10;
    }
    while (v2 && v7-- != 0);
  }
  return v3;
}

void sub_1005AD688(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(unsigned __int8 *)(a2 + 119);
  if ((v3 & 0x80u) != 0) {
    uint64_t v3 = *(void *)(a2 + 104);
  }
  if (!v3)
  {
    *(unsigned char *)a1 = 0;
    *(unsigned char *)(a1 + 96) = 0;
    return;
  }
  memset(__p, 0, sizeof(__p));
  *(_OWORD *)char v15 = 0u;
  sub_100E63EA4((uint64_t)v15);
  int v5 = SHIBYTE(__p[0]);
  if (SHIBYTE(__p[0]) < 0)
  {
    sub_10004FC84(&v7, v15[0], (unint64_t)v15[1]);
  }
  else
  {
    long long v7 = *(_OWORD *)v15;
    int v8 = __p[0];
  }
  int v6 = SHIBYTE(__p[3]);
  if (SHIBYTE(__p[3]) < 0)
  {
    sub_10004FC84(&v9, __p[1], (unint64_t)__p[2]);
  }
  else
  {
    long long v9 = *(_OWORD *)&__p[1];
    int v10 = __p[3];
  }
  if (*(char *)(a2 + 143) < 0)
  {
    sub_10004FC84(&v11, *(void **)(a2 + 120), *(void *)(a2 + 128));
  }
  else
  {
    long long v11 = *(_OWORD *)(a2 + 120);
    uint64_t v12 = *(void *)(a2 + 136);
  }
  if (*(char *)(a2 + 167) < 0)
  {
    sub_10004FC84(&v13, *(void **)(a2 + 144), *(void *)(a2 + 152));
  }
  else
  {
    long long v13 = *(_OWORD *)(a2 + 144);
    uint64_t v14 = *(void *)(a2 + 160);
  }
  *(_OWORD *)a1 = v7;
  *(void *)(a1 + 16) = v8;
  *(_OWORD *)(a1 + 24) = v9;
  *(void *)(a1 + 40) = v10;
  *(_OWORD *)(a1 + 48) = v11;
  *(void *)(a1 + 64) = v12;
  *(void *)(a1 + 88) = v14;
  *(_OWORD *)(a1 + 72) = v13;
  *(unsigned char *)(a1 + 96) = 1;
  if ((v6 & 0x80000000) == 0)
  {
    if ((v5 & 0x80000000) == 0) {
      return;
    }
LABEL_21:
    operator delete(v15[0]);
    return;
  }
  operator delete(__p[1]);
  if (v5 < 0) {
    goto LABEL_21;
  }
}

void sub_1005AD838(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *__p,uint64_t a22,int a23,__int16 a24,char a25,char a26,uint64_t a27,uint64_t a28,uint64_t a29,char a30)
{
  if (a26 < 0) {
    operator delete(__p);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  if (a14 < 0) {
    operator delete(a9);
  }
  sub_1001085D8((uint64_t)&a30);
  _Unwind_Resume(a1);
}

void sub_1005AD894(uint64_t a1)
{
  unint64_t v1 = *(void **)(a1 + 104);
  BOOL v2 = (void *)(a1 + 112);
  if (v1 != (void *)(a1 + 112))
  {
    do
    {
      uint64_t v4 = *(NSObject **)(a1 + 8);
      if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
      {
        int v5 = v1 + 5;
        if (*((char *)v1 + 63) < 0) {
          int v5 = (void *)*v5;
        }
        uint64_t v6 = subscriber::asString();
        *(_DWORD *)long long buf = 136315394;
        long long v11 = v5;
        __int16 v12 = 2080;
        uint64_t v13 = v6;
        _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Instance assigned to SIM (%s): %s", buf, 0x16u);
      }
      long long v7 = (void *)v1[1];
      if (v7)
      {
        do
        {
          int v8 = v7;
          long long v7 = (void *)*v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          int v8 = (void *)v1[2];
          BOOL v9 = *v8 == (void)v1;
          unint64_t v1 = v8;
        }
        while (!v9);
      }
      unint64_t v1 = v8;
    }
    while (v8 != v2);
  }
}

void sub_1005AD9CC(uint64_t a1)
{
  sub_1005ADA70(a1);

  operator delete();
}

uint64_t sub_1005ADA04(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 96))
  {
    if (*(char *)(a1 + 95) < 0) {
      operator delete(*(void **)(a1 + 72));
    }
    if (*(char *)(a1 + 71) < 0) {
      operator delete(*(void **)(a1 + 48));
    }
    if (*(char *)(a1 + 47) < 0) {
      operator delete(*(void **)(a1 + 24));
    }
    if (*(char *)(a1 + 23) < 0) {
      operator delete(*(void **)a1);
    }
  }
  return a1;
}

void sub_1005ADA70(uint64_t a1)
{
  *(void *)a1 = off_1019E9F88;
  sub_10005CD2C(a1 + 128, *(char **)(a1 + 136));
  sub_1000886C0(a1 + 104, *(char **)(a1 + 112));
  uint64_t v3 = (void **)(a1 + 80);
  sub_1000C56F4(&v3);
  uint64_t v3 = (void **)(a1 + 56);
  sub_10008A88C(&v3);
  sub_1000886C0(a1 + 32, *(char **)(a1 + 40));
  BOOL v2 = *(std::__shared_weak_count **)(a1 + 24);
  if (v2) {
    sub_10004D2C8(v2);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 8));
  SubscriptionConfigurationEvaluatorInterface::~SubscriptionConfigurationEvaluatorInterface((SubscriptionConfigurationEvaluatorInterface *)a1);
}

void *sub_1005ADB10@<X0>(void *a1@<X1>, void *a2@<X8>)
{
  uint64_t v4 = operator new(0xB0uLL);
  uint64_t result = sub_1005ADB6C(v4, a1);
  *a2 = v4 + 3;
  a2[1] = v4;
  return result;
}

void sub_1005ADB58(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_1005ADB6C(void *a1, void *a2)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = off_1019EA040;
  sub_1005A78C4((uint64_t)(a1 + 3), a2);
  a1[3] = off_1019EA090;
  return a1;
}

void sub_1005ADBD0(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void sub_1005ADBE4(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1019EA040;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1005ADC04(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1019EA040;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_1005ADC58(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_1005ADC84(uint64_t a1)
{
  sub_1005ADA70(a1);

  operator delete();
}

void sub_1005ADCBC(__n128 *a1, __n128 *a2, uint64_t *a3, unint64_t a4, uint64_t a5, uint64_t a6)
{
  if (a4 >= 2)
  {
    uint64_t v8 = (uint64_t)a1;
    if (a4 == 2)
    {
      BOOL v9 = &a2[-2].n128_i8[8];
      uint64_t v10 = *a3;
      int v11 = sub_1005AC014(*a3, (uint64_t)&a2[-2].n128_i64[1]);
      if (v11 < (int)sub_1005AC014(v10, v8))
      {
        unint64_t v12 = *(void *)(v8 + 16);
        long long v13 = *(_OWORD *)v8;
        unint64_t v14 = a2[-1].n128_u64[1];
        *(_OWORD *)uint64_t v8 = *(_OWORD *)v9;
        *(void *)(v8 + 16) = v14;
        *(_OWORD *)BOOL v9 = v13;
        a2[-1].n128_u64[1] = v12;
      }
    }
    else if ((uint64_t)a4 <= 0)
    {
      if (a1 != a2)
      {
        uint64_t v21 = (uint64_t)&a1[1].n128_i64[1];
        if (&a1[1].n128_i8[8] != (__int8 *)a2)
        {
          uint64_t v22 = 0;
          uint64_t v23 = (uint64_t)a1;
          do
          {
            uint64_t v24 = v23;
            uint64_t v23 = v21;
            uint64_t v25 = *a3;
            int v26 = sub_1005AC014(*a3, v21);
            if (v26 < (int)sub_1005AC014(v25, v24))
            {
              long long v55 = *(_OWORD *)v23;
              uint64_t v56 = *(void *)(v23 + 16);
              *(void *)(v23 + 8) = 0;
              *(void *)(v23 + 16) = 0;
              *(void *)uint64_t v23 = 0;
              uint64_t v27 = v22;
              do
              {
                uint64_t v28 = v8 + v27;
                uint64_t v29 = (void **)(v8 + v27 + 24);
                if (*(char *)(v8 + v27 + 47) < 0) {
                  operator delete(*v29);
                }
                *(_OWORD *)uint64_t v29 = *(_OWORD *)v28;
                *(void *)(v8 + v27 + 40) = *(void *)(v28 + 16);
                *(unsigned char *)(v28 + 23) = 0;
                *(unsigned char *)uint64_t v28 = 0;
                if (!v27)
                {
                  uint64_t v33 = v8;
                  goto LABEL_22;
                }
                uint64_t v30 = *a3;
                int v31 = sub_1005AC014(*a3, (uint64_t)&v55);
                int v32 = sub_1005AC014(v30, v8 + v27 - 24);
                v27 -= 24;
              }
              while (v31 < v32);
              uint64_t v33 = v8 + v27 + 24;
              if (*(char *)(v8 + v27 + 47) < 0) {
                operator delete(*(void **)v33);
              }
LABEL_22:
              *(_OWORD *)uint64_t v33 = v55;
              *(void *)(v33 + 16) = v56;
            }
            uint64_t v21 = v23 + 24;
            v22 += 24;
          }
          while ((__n128 *)(v23 + 24) != a2);
        }
      }
    }
    else
    {
      uint64_t v17 = a5;
      uint64_t v18 = a4 >> 1;
      uint64_t v19 = (uint64_t)a1 + 24 * (a4 >> 1);
      if ((uint64_t)a4 <= a6)
      {
        sub_1005AE120(a1, (__n128 *)((char *)a1 + 24 * (a4 >> 1)), a3, a4 >> 1, a5);
        uint64_t v34 = v17 + 24 * v18;
        sub_1005AE120((__n128 *)(v8 + 24 * (a4 >> 1)), a2, a3, a4 - v18, v34);
        unint64_t v35 = v17 + 24 * a4;
        uint64_t v36 = v34;
        uint64_t v37 = v17;
        while (v36 != v35)
        {
          uint64_t v38 = *a3;
          int v39 = sub_1005AC014(*a3, v36);
          int v40 = sub_1005AC014(v38, v37);
          int v41 = *(char *)(v8 + 23);
          if (v39 >= v40)
          {
            if (v41 < 0) {
              operator delete(*(void **)v8);
            }
            long long v43 = *(_OWORD *)v37;
            *(void *)(v8 + 16) = *(void *)(v37 + 16);
            *(_OWORD *)uint64_t v8 = v43;
            *(unsigned char *)(v37 + 23) = 0;
            *(unsigned char *)uint64_t v37 = 0;
            v37 += 24;
          }
          else
          {
            if (v41 < 0) {
              operator delete(*(void **)v8);
            }
            long long v42 = *(_OWORD *)v36;
            *(void *)(v8 + 16) = *(void *)(v36 + 16);
            *(_OWORD *)uint64_t v8 = v42;
            *(unsigned char *)(v36 + 23) = 0;
            *(unsigned char *)uint64_t v36 = 0;
            v36 += 24;
          }
          v8 += 24;
          if (v37 == v34)
          {
            if (v36 != v35)
            {
              uint64_t v44 = 0;
              do
              {
                uint64_t v45 = v8 + v44;
                if (*(char *)(v8 + v44 + 23) < 0) {
                  operator delete(*(void **)(v8 + v44));
                }
                long long v46 = (unsigned char *)(v36 + v44);
                long long v47 = *(_OWORD *)(v36 + v44);
                *(void *)(v45 + 16) = *(void *)(v36 + v44 + 16);
                *(_OWORD *)uint64_t v45 = v47;
                v46[23] = 0;
                *long long v46 = 0;
                uint64_t v48 = v36 + v44 + 24;
                v44 += 24;
              }
              while (v48 != v35);
            }
            goto LABEL_46;
          }
        }
        if (v37 != v34)
        {
          uint64_t v49 = 0;
          do
          {
            uint64_t v50 = v8 + v49;
            if (*(char *)(v8 + v49 + 23) < 0) {
              operator delete(*(void **)v50);
            }
            uint64_t v51 = (unsigned char *)(v37 + v49);
            long long v52 = *(_OWORD *)(v37 + v49);
            *(void *)(v50 + 16) = *(void *)(v37 + v49 + 16);
            *(_OWORD *)uint64_t v50 = v52;
            v51[23] = 0;
            *uint64_t v51 = 0;
            uint64_t v53 = v37 + v49 + 24;
            v49 += 24;
          }
          while (v53 != v34);
        }
LABEL_46:
        if (v17)
        {
          unint64_t v54 = a4;
          do
          {
            if (*(char *)(v17 + 23) < 0) {
              operator delete(*(void **)v17);
            }
            v17 += 24;
            --v54;
          }
          while (v54);
        }
      }
      else
      {
        sub_1005ADCBC(a1, (char *)a1 + 24 * (a4 >> 1), a3, a4 >> 1, a5, a6);
        uint64_t v20 = a4 - v18;
        sub_1005ADCBC(v19, a2, a3, v20, v17, a6);
        sub_1005AE544(v8, v19, (uint64_t)a2, a3, v18, v20, v17, a6);
      }
    }
  }
}

void sub_1005AE0C4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (v18 && v19)
  {
    for (unint64_t i = 0; i < v19; ++i)
    {
      if (*(char *)(v18 + 23) < 0) {
        operator delete(*(void **)v18);
      }
      v18 += 24;
    }
  }
  _Unwind_Resume(exception_object);
}

__n128 sub_1005AE120(__n128 *a1, __n128 *a2, uint64_t *a3, unint64_t a4, uint64_t a5)
{
  if (a4)
  {
    long long v7 = a2;
    uint64_t v8 = a1;
    if (a4 == 2)
    {
      uint64_t v10 = *a3;
      int v11 = sub_1005AC014(*a3, (uint64_t)&a2[-2].n128_i64[1]);
      int v12 = sub_1005AC014(v10, (uint64_t)v8);
      if (v11 >= v12) {
        long long v13 = v8;
      }
      else {
        long long v13 = (__n128 *)((char *)v7 - 24);
      }
      if (v11 >= v12) {
        uint64_t v8 = (__n128 *)((char *)v7 - 24);
      }
      unint64_t v14 = v13[1].n128_u64[0];
      *(__n128 *)a5 = *v13;
      *(void *)(a5 + 16) = v14;
      v13->n128_u64[1] = 0;
      v13[1].n128_u64[0] = 0;
      v13->n128_u64[0] = 0;
      __n128 result = *v8;
      *(void *)(a5 + 40) = v8[1].n128_u64[0];
      *(__n128 *)(a5 + 24) = result;
      goto LABEL_11;
    }
    if (a4 == 1)
    {
      __n128 result = *a1;
      *(void *)(a5 + 16) = a1[1].n128_u64[0];
      *(__n128 *)a5 = result;
LABEL_11:
      v8->n128_u64[0] = 0;
      v8->n128_u64[1] = 0;
      v8[1].n128_u64[0] = 0;
      return result;
    }
    if ((uint64_t)a4 > 8)
    {
      uint64_t v29 = (__n128 *)((char *)a1 + 24 * (a4 >> 1));
      sub_1005ADCBC(a1, v29, a3, a4 >> 1, a5, a4 >> 1);
      sub_1005ADCBC((char *)v8 + 24 * (a4 >> 1), v7, a3, a4 - (a4 >> 1), a5 + 24 * (a4 >> 1), a4 - (a4 >> 1));
      uint64_t v30 = 0;
      int v31 = (__n128 *)a5;
      int v32 = (__n128 *)((char *)v8 + 24 * (a4 >> 1));
      while (v32 != v7)
      {
        uint64_t v33 = *a3;
        int v34 = sub_1005AC014(*a3, (uint64_t)v32);
        if (v34 >= (int)sub_1005AC014(v33, (uint64_t)v8))
        {
          __n128 result = *v8;
          v31[1].n128_u64[0] = v8[1].n128_u64[0];
          *int v31 = result;
          v8->n128_u64[1] = 0;
          v8[1].n128_u64[0] = 0;
          v8->n128_u64[0] = 0;
          uint64_t v8 = (__n128 *)((char *)v8 + 24);
        }
        else
        {
          __n128 result = *v32;
          v31[1].n128_u64[0] = v32[1].n128_u64[0];
          *int v31 = result;
          v32->n128_u64[1] = 0;
          v32[1].n128_u64[0] = 0;
          v32->n128_u64[0] = 0;
          int v32 = (__n128 *)((char *)v32 + 24);
        }
        ++v30;
        int v31 = (__n128 *)((char *)v31 + 24);
        if (v8 == v29)
        {
          if (v32 != v7)
          {
            uint64_t v35 = 0;
            do
            {
              uint64_t v36 = &v32->n128_u64[v35];
              uint64_t v37 = (__n128 *)((char *)v31 + v35 * 8);
              __n128 result = *(__n128 *)((char *)v32 + v35 * 8);
              v37[1].n128_u64[0] = v32[1].n128_u64[v35];
              *uint64_t v37 = result;
              v36[1] = 0;
              v36[2] = 0;
              *uint64_t v36 = 0;
              v35 += 3;
            }
            while ((__n128 *)((char *)v32 + v35 * 8) != v7);
          }
          return result;
        }
      }
      if (v8 != v29)
      {
        uint64_t v38 = 0;
        do
        {
          int v39 = (__n128 *)((char *)v31 + v38 * 8);
          int v40 = &v8->n128_u64[v38];
          __n128 result = *(__n128 *)((char *)v8 + v38 * 8);
          v39[1].n128_u64[0] = v8[1].n128_u64[v38];
          *int v39 = result;
          v40[1] = 0;
          v40[2] = 0;
          *int v40 = 0;
          v38 += 3;
        }
        while ((__n128 *)((char *)v8 + v38 * 8) != v29);
      }
    }
    else if (a1 != a2)
    {
      __n128 result = *a1;
      *(void *)(a5 + 16) = a1[1].n128_u64[0];
      *(__n128 *)a5 = result;
      a1->n128_u64[1] = 0;
      a1[1].n128_u64[0] = 0;
      a1->n128_u64[0] = 0;
      uint64_t v15 = (uint64_t)&a1[1].n128_i64[1];
      if (&a1[1].n128_i8[8] != (__int8 *)a2)
      {
        uint64_t v16 = 0;
        uint64_t v17 = 1;
        uint64_t v18 = a5;
        do
        {
          unint64_t v19 = (__n128 *)v15;
          uint64_t v20 = *a3;
          int v21 = sub_1005AC014(*a3, v15);
          int v22 = sub_1005AC014(v20, v18);
          uint64_t v23 = (__n128 *)(v18 + 24);
          ++v17;
          if (v21 >= v22)
          {
            __n128 result = *v19;
            *(void *)(v18 + 40) = v19[1].n128_u64[0];
            __n128 *v23 = result;
            v19->n128_u64[1] = 0;
            v19[1].n128_u64[0] = 0;
            v19->n128_u64[0] = 0;
          }
          else
          {
            __n128 *v23 = *(__n128 *)v18;
            *(void *)(v18 + 40) = *(void *)(v18 + 16);
            *(void *)(v18 + 8) = 0;
            *(void *)(v18 + 16) = 0;
            *(void *)uint64_t v18 = 0;
            uint64_t v24 = a5;
            if (v18 != a5)
            {
              uint64_t v25 = v16;
              while (1)
              {
                uint64_t v26 = *a3;
                int v27 = sub_1005AC014(*a3, (uint64_t)v19);
                uint64_t v28 = a5 + v25;
                if (v27 >= (int)sub_1005AC014(v26, a5 + v25 - 24)) {
                  break;
                }
                if (*(char *)(a5 + v25 + 23) < 0) {
                  operator delete(*(void **)v28);
                }
                *(_OWORD *)uint64_t v28 = *(_OWORD *)(a5 + v25 - 24);
                *(void *)(v28 + 16) = *(void *)(a5 + v25 - 8);
                *(unsigned char *)(a5 + v25 - 1) = 0;
                *(unsigned char *)(v28 - 24) = 0;
                v25 -= 24;
                if (!v25)
                {
                  uint64_t v24 = a5;
                  goto LABEL_27;
                }
              }
              uint64_t v24 = a5 + v25;
LABEL_27:
              long long v7 = a2;
            }
            if (*(char *)(v24 + 23) < 0) {
              operator delete(*(void **)v24);
            }
            __n128 result = *v19;
            *(void *)(v24 + 16) = v19[1].n128_u64[0];
            *(__n128 *)uint64_t v24 = result;
            v8[2].n128_u8[15] = 0;
            v19->n128_u8[0] = 0;
            uint64_t v23 = (__n128 *)(v18 + 24);
          }
          uint64_t v15 = (uint64_t)&v19[1].n128_i64[1];
          v16 += 24;
          uint64_t v18 = (uint64_t)v23;
          uint64_t v8 = v19;
        }
        while (&v19[1].n128_i8[8] != (__int8 *)v7);
      }
    }
  }
  return result;
}

void sub_1005AE4D4(_Unwind_Exception *exception_object)
{
  if (v1 && v2)
  {
    for (unint64_t i = 0; i < v2; ++i)
    {
      if (*(char *)(v1 + 23) < 0) {
        operator delete(*(void **)v1);
      }
      v1 += 24;
    }
  }
  _Unwind_Resume(exception_object);
}

void sub_1005AE544(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v94 = a6;
  if (a6)
  {
    while (a5 > a8 && v94 > a8)
    {
      if (!a5) {
        return;
      }
      uint64_t v14 = 0;
      uint64_t v15 = -a5;
      while (1)
      {
        uint64_t v16 = a1 + v14;
        uint64_t v17 = *a4;
        int v18 = sub_1005AC014(*a4, a2);
        if (v18 < (int)sub_1005AC014(v17, a1 + v14)) {
          break;
        }
        v14 += 24;
        if (__CFADD__(v15++, 1)) {
          return;
        }
      }
      uint64_t v20 = -v15;
      uint64_t v21 = v94;
      uint64_t v90 = a3;
      uint64_t v91 = a1;
      if (-v15 >= v94)
      {
        if (v15 == -1)
        {
          uint64_t v82 = a1 + v14;
          long long v83 = *(_OWORD *)(a1 + v14);
          uint64_t v99 = *(void *)(a1 + v14 + 16);
          long long v98 = v83;
          long long v84 = *(_OWORD *)a2;
          *(void *)(v82 + 16) = *(void *)(a2 + 16);
          *(_OWORD *)uint64_t v82 = v84;
          *(_OWORD *)a2 = v98;
          *(void *)(a2 + 16) = v99;
          return;
        }
        if (v15 > 0) {
          uint64_t v20 = 1 - v15;
        }
        uint64_t v30 = v20 >> 1;
        uint64_t v31 = a2;
        a2 = a1 + 24 * (v20 >> 1) + v14;
        uint64_t v25 = v31;
        if (v31 != a3)
        {
          uint64_t v87 = v20 >> 1;
          uint64_t v96 = a4;
          uint64_t v32 = *a4;
          unint64_t v33 = 0xAAAAAAAAAAAAAAABLL * ((a3 - v31) >> 3);
          uint64_t v89 = v31;
          uint64_t v25 = v31;
          do
          {
            uint64_t v34 = v25 + 24 * (v33 >> 1);
            int v35 = sub_1005AC014(v32, v34);
            int v36 = sub_1005AC014(v32, a2);
            if (v35 >= v36) {
              v33 >>= 1;
            }
            else {
              v33 += ~(v33 >> 1);
            }
            if (v35 < v36) {
              uint64_t v25 = v34 + 24;
            }
          }
          while (v33);
          uint64_t v31 = v89;
          uint64_t v21 = v94;
          a4 = v96;
          uint64_t v30 = v87;
        }
        uint64_t v23 = 0xAAAAAAAAAAAAAAABLL * ((v25 - v31) >> 3);
      }
      else
      {
        if (v94 >= 0) {
          uint64_t v22 = v94;
        }
        else {
          uint64_t v22 = v94 + 1;
        }
        uint64_t v23 = v22 >> 1;
        uint64_t v24 = a1;
        uint64_t v25 = a2 + 24 * v23;
        uint64_t v88 = a2;
        uint64_t v26 = a2 - v24 - v14;
        if (v26)
        {
          uint64_t v86 = v23;
          v95 = a4;
          unint64_t v27 = 0xAAAAAAAAAAAAAAABLL * (v26 >> 3);
          a2 = v16;
          do
          {
            uint64_t v28 = *v95;
            int v29 = sub_1005AC014(*v95, v25);
            if (v29 < (int)sub_1005AC014(v28, a2 + 24 * (v27 >> 1)))
            {
              v27 >>= 1;
            }
            else
            {
              a2 += 24 * (v27 >> 1) + 24;
              v27 += ~(v27 >> 1);
            }
          }
          while (v27);
          uint64_t v23 = v86;
          uint64_t v21 = v94;
          a4 = v95;
        }
        uint64_t v30 = 0xAAAAAAAAAAAAAAABLL * ((a2 - v91 - v14) >> 3);
        uint64_t v31 = v88;
      }
      if (a2 == v31)
      {
        a3 = v25;
      }
      else if (v25 == v31)
      {
        a3 = a2;
      }
      else
      {
        long long v37 = *(_OWORD *)a2;
        uint64_t v99 = *(void *)(a2 + 16);
        long long v98 = v37;
        long long v38 = *(_OWORD *)v31;
        *(void *)(a2 + 16) = *(void *)(v31 + 16);
        *(_OWORD *)a2 = v38;
        *(_OWORD *)uint64_t v31 = v98;
        *(void *)(v31 + 16) = v99;
        a3 = a2 + 24;
        uint64_t v39 = v31;
        for (uint64_t i = v31 + 24; i != v25; i += 24)
        {
          if (a3 == v39) {
            uint64_t v39 = i;
          }
          long long v41 = *(_OWORD *)a3;
          uint64_t v99 = *(void *)(a3 + 16);
          long long v98 = v41;
          long long v42 = *(_OWORD *)i;
          *(void *)(a3 + 16) = *(void *)(i + 16);
          *(_OWORD *)a3 = v42;
          a3 += 24;
          *(_OWORD *)uint64_t i = v98;
          *(void *)(i + 16) = v99;
        }
        if (a3 != v39)
        {
          long long v43 = (long long *)v39;
          uint64_t v44 = a3;
          uint64_t v45 = (long long *)v39;
          do
          {
            while (1)
            {
              long long v46 = *(_OWORD *)v44;
              uint64_t v99 = *(void *)(v44 + 16);
              long long v98 = v46;
              long long v47 = *v45;
              *(void *)(v44 + 16) = *((void *)v45 + 2);
              *(_OWORD *)uint64_t v44 = v47;
              v44 += 24;
              long long v48 = v98;
              *((void *)v45 + 2) = v99;
              *uint64_t v45 = v48;
              uint64_t v45 = (long long *)((char *)v45 + 24);
              if (v45 == (long long *)v25) {
                break;
              }
              if ((long long *)v44 == v43) {
                long long v43 = v45;
              }
            }
            uint64_t v45 = v43;
          }
          while ((long long *)v44 != v43);
        }
      }
      a5 = -(v30 + v15);
      uint64_t v49 = v21 - v23;
      if (v30 + v23 >= v21 - (v30 + v23) - v15)
      {
        uint64_t v50 = v30;
        uint64_t v51 = a5;
        uint64_t v52 = v23;
        sub_1005AE544(a3, v25, v90, a4, v51, v21 - v23, a7, a8);
        uint64_t v49 = v52;
        a5 = v50;
      }
      else
      {
        sub_1005AE544(v91 + v14, a2, a3, a4, v30, v23, a7, a8);
        uint64_t v16 = a3;
        a2 = v25;
        a3 = v90;
      }
      uint64_t v94 = v49;
      a1 = v16;
      if (!v49) {
        return;
      }
    }
    if (a5 <= v94)
    {
      if (a1 == a2) {
        return;
      }
      uint64_t v69 = 0;
      uint64_t v70 = a2;
      unint64_t v55 = 0;
      do
      {
        uint64_t v71 = a7 + v69;
        uint64_t v72 = (void *)(a1 + v69);
        long long v73 = *(_OWORD *)(a1 + v69);
        *(void *)(v71 + 16) = *(void *)(a1 + v69 + 16);
        *(_OWORD *)uint64_t v71 = v73;
        v72[1] = 0;
        v72[2] = 0;
        *uint64_t v72 = 0;
        ++v55;
        v69 += 24;
      }
      while (a1 + v69 != v70);
      if (v69)
      {
        signed int v74 = (long long *)(a7 + v69);
        uint64_t v75 = a7;
        while (v70 != a3)
        {
          uint64_t v76 = *a4;
          int v77 = sub_1005AC014(*a4, v70);
          int v78 = sub_1005AC014(v76, v75);
          int v79 = *(char *)(a1 + 23);
          if (v77 >= v78)
          {
            if (v79 < 0) {
              operator delete(*(void **)a1);
            }
            long long v81 = *(_OWORD *)v75;
            *(void *)(a1 + 16) = *(void *)(v75 + 16);
            *(_OWORD *)a1 = v81;
            *(unsigned char *)(v75 + 23) = 0;
            *(unsigned char *)uint64_t v75 = 0;
            v75 += 24;
          }
          else
          {
            if (v79 < 0) {
              operator delete(*(void **)a1);
            }
            long long v80 = *(_OWORD *)v70;
            *(void *)(a1 + 16) = *(void *)(v70 + 16);
            *(_OWORD *)a1 = v80;
            *(unsigned char *)(v70 + 23) = 0;
            *(unsigned char *)uint64_t v70 = 0;
            v70 += 24;
          }
          a1 += 24;
          if (v74 == (long long *)v75) {
            goto LABEL_95;
          }
        }
        sub_1000D935C((uint64_t)&v98, (long long *)v75, v74, a1);
      }
    }
    else
    {
      if (a3 == a2) {
        return;
      }
      uint64_t v53 = 0;
      uint64_t v54 = a2;
      unint64_t v55 = 0;
      do
      {
        uint64_t v56 = a7 + v53;
        uint64_t v57 = (void *)(v54 + v53);
        long long v58 = *(_OWORD *)(v54 + v53);
        *(void *)(v56 + 16) = *(void *)(v54 + v53 + 16);
        *(_OWORD *)uint64_t v56 = v58;
        v57[1] = 0;
        v57[2] = 0;
        *uint64_t v57 = 0;
        ++v55;
        v53 += 24;
      }
      while (v54 + v53 != a3);
      if (v53)
      {
        uint64_t v59 = a7 + v53;
        uint64_t v60 = a3 - 24;
        uint64_t v97 = a4;
        uint64_t v92 = a1;
        while (v54 != a1)
        {
          uint64_t v61 = a3;
          uint64_t v62 = *a4;
          int v63 = sub_1005AC014(*a4, v59 - 24);
          int v64 = sub_1005AC014(v62, v54 - 24);
          BOOL v65 = v63 < v64;
          if (v63 >= v64) {
            uint64_t v66 = v59;
          }
          else {
            uint64_t v66 = v54;
          }
          if (v63 >= v64) {
            uint64_t v67 = v59 - 24;
          }
          else {
            uint64_t v67 = v54 - 24;
          }
          if (v65) {
            v54 -= 24;
          }
          else {
            v59 -= 24;
          }
          if (*(char *)(v60 + 23) < 0) {
            operator delete(*(void **)v60);
          }
          long long v68 = *(_OWORD *)v67;
          *(void *)(v60 + 16) = *(void *)(v67 + 16);
          *(_OWORD *)uint64_t v60 = v68;
          v60 -= 24;
          *(unsigned char *)(v66 - 1) = 0;
          *(unsigned char *)uint64_t v67 = 0;
          a3 = v61 - 24;
          a4 = v97;
          a1 = v92;
          if (v59 == a7) {
            goto LABEL_95;
          }
        }
        sub_1005AEBCC(v59, a7, a3);
      }
    }
LABEL_95:
    if (a7)
    {
      unint64_t v85 = 0;
      do
      {
        if (*(char *)(a7 + 23) < 0) {
          operator delete(*(void **)a7);
        }
        ++v85;
        a7 += 24;
      }
      while (v85 < v55);
    }
  }
}

void sub_1005AEB8C(_Unwind_Exception *exception_object)
{
  uint64_t v3 = v1;
  if (v1)
  {
    unint64_t v5 = 0;
    do
    {
      if (*(char *)(v3 + 23) < 0) {
        operator delete(*(void **)v3);
      }
      ++v5;
      v3 += 24;
    }
    while (v5 < v2);
  }
  _Unwind_Resume(exception_object);
}

__n128 sub_1005AEBCC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a1 != a2)
  {
    uint64_t v4 = a1;
    uint64_t v5 = a3 - 24;
    do
    {
      if (*(char *)(v5 + 23) < 0) {
        operator delete(*(void **)v5);
      }
      __n128 result = *(__n128 *)(v4 - 24);
      *(void *)(v5 + 16) = *(void *)(v4 - 8);
      *(__n128 *)uint64_t v5 = result;
      v5 -= 24;
      *(unsigned char *)(v4 - 1) = 0;
      *(unsigned char *)(v4 - 24) = 0;
      v4 -= 24;
    }
    while (v4 != a2);
  }
  return result;
}

uint64_t *sub_1005AEC40(uint64_t **a1, void **a2, long long **a3)
{
  uint64_t v6 = a1 + 1;
  uint64_t v5 = a1[1];
  if (!v5)
  {
    uint64_t v8 = a1 + 1;
LABEL_9:
    uint64_t v10 = *a3;
    int v11 = (uint64_t *)operator new(0x40uLL);
    int v12 = v11 + 4;
    if (*((char *)v10 + 23) < 0)
    {
      sub_10004FC84(v12, *(void **)v10, *((void *)v10 + 1));
    }
    else
    {
      long long v13 = *v10;
      void v11[6] = *((void *)v10 + 2);
      *(_OWORD *)int v12 = v13;
    }
    *((_DWORD *)v11 + 14) = 0;
    uint64_t *v11 = 0;
    v11[1] = 0;
    void v11[2] = (uint64_t)v8;
    void *v6 = v11;
    uint64_t v14 = (uint64_t *)**a1;
    uint64_t v15 = v11;
    if (v14)
    {
      *a1 = v14;
      uint64_t v15 = *v6;
    }
    sub_100046C90(a1[1], v15);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
    return v11;
  }
  while (1)
  {
    while (1)
    {
      uint64_t v8 = (uint64_t **)v5;
      BOOL v9 = v5 + 4;
      if ((sub_100046FE8(a2, (void **)v5 + 4) & 0x80) == 0) {
        break;
      }
      uint64_t v5 = *v8;
      uint64_t v6 = v8;
      if (!*v8) {
        goto LABEL_9;
      }
    }
    if ((sub_100046FE8(v9, a2) & 0x80) == 0) {
      break;
    }
    uint64_t v6 = v8 + 1;
    uint64_t v5 = v8[1];
    if (!v5) {
      goto LABEL_9;
    }
  }
  int v11 = *v6;
  if (!*v6) {
    goto LABEL_9;
  }
  return v11;
}

void sub_1005AED54(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

const void **sub_1005AED68(const void **a1, const void **a2)
{
  if (a1 != a2)
  {
    uint64_t v5 = 0;
    sub_1005AEDC0(&v5, a2);
    uint64_t v3 = *a1;
    *a1 = v5;
    uint64_t v5 = v3;
    sub_100062778(&v5);
  }
  return a1;
}

const void **sub_1005AEDC0(const void **a1, const void **a2)
{
  uint64_t v3 = *a2;
  *a1 = *a2;
  if (v3) {
    CFRetain(v3);
  }
  return a1;
}

uint64_t sub_1005AEDF8(uint64_t a1)
{
  *(void *)a1 = off_1019EA0F8;
  if (*(char *)(a1 + 63) < 0) {
    operator delete(*(void **)(a1 + 40));
  }
  if (*(char *)(a1 + 39) < 0) {
    operator delete(*(void **)(a1 + 16));
  }
  return a1;
}

void sub_1005AEE58(uint64_t a1)
{
  *(void *)a1 = off_1019EA0F8;
  if (*(char *)(a1 + 63) < 0) {
    operator delete(*(void **)(a1 + 40));
  }
  if (*(char *)(a1 + 39) < 0) {
    operator delete(*(void **)(a1 + 16));
  }

  operator delete();
}

void *sub_1005AEED8(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  unint64_t v2 = operator new(0x40uLL);
  void *v2 = off_1019EA0F8;
  sub_1005AF104((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_1005AEF2C(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1005AEF40(uint64_t a1, void *a2)
{
  *a2 = off_1019EA0F8;
  return sub_1005AF104((uint64_t)(a2 + 1), a1 + 8);
}

void sub_1005AEF6C(uint64_t a1)
{
}

void sub_1005AEF74(void *a1)
{
  sub_10016B57C((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_1005AEFB0(uint64_t a1, unsigned __int8 *a2)
{
  int v2 = *a2;
  if ((v2 - 1) <= 1 && v2 == 2)
  {
    uint64_t v4 = *(NSObject **)(*(void *)(a1 + 8) + 8);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT))
    {
      uint64_t v7 = *(void *)(a1 + 16);
      uint64_t v6 = a1 + 16;
      uint64_t v5 = v7;
      if (*(char *)(v6 + 47) >= 0) {
        uint64_t v8 = v6 + 24;
      }
      else {
        uint64_t v8 = *(void *)(v6 + 24);
      }
      if (*(char *)(v6 + 23) < 0) {
        uint64_t v6 = v5;
      }
      int v9 = 136315650;
      uint64_t v10 = v8;
      __int16 v11 = 2080;
      uint64_t v12 = v6;
      __int16 v13 = 2080;
      uint64_t v14 = asString();
      _os_log_fault_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_FAULT, "Failed to store last used IMEI (%s) for eSIM (%s), error: %s", (uint8_t *)&v9, 0x20u);
    }
  }
}

uint64_t sub_1005AF0B8(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_1005AF0F8()
{
}

uint64_t sub_1005AF104(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = *(void *)a2;
  if (*(char *)(a2 + 31) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 8), *(void **)(a2 + 8), *(void *)(a2 + 16));
  }
  else
  {
    long long v4 = *(_OWORD *)(a2 + 8);
    *(void *)(a1 + 24) = *(void *)(a2 + 24);
    *(_OWORD *)(a1 + 8) = v4;
  }
  uint64_t v5 = (unsigned char *)(a1 + 32);
  if (*(char *)(a2 + 55) < 0)
  {
    sub_10004FC84(v5, *(void **)(a2 + 32), *(void *)(a2 + 40));
  }
  else
  {
    long long v6 = *(_OWORD *)(a2 + 32);
    *(void *)(a1 + 48) = *(void *)(a2 + 48);
    *(_OWORD *)uint64_t v5 = v6;
  }
  return a1;
}

void sub_1005AF198(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 31) < 0) {
    operator delete(*v2);
  }
  _Unwind_Resume(exception_object);
}

id sub_1005AF1B4(uint64_t a1)
{
  id v2 = objc_alloc((Class)NSUUID);
  if (*(char *)(a1 + 135) >= 0) {
    uint64_t v3 = a1 + 112;
  }
  else {
    uint64_t v3 = *(void *)(a1 + 112);
  }
  long long v4 = +[NSString stringWithUTF8String:v3];
  id v5 = [v2 initWithUUIDString:v4];

  id v6 = objc_alloc((Class)CTXPCServiceSubscriptionContext);
  if (*(_DWORD *)a1 == 1) {
    uint64_t v7 = 1;
  }
  else {
    uint64_t v7 = 2 * (*(_DWORD *)a1 == 2);
  }
  id v8 = [v6 initWithUUID:v5 andSlot:v7];
  [v8 setIsSimPresent:*(unsigned __int8 *)(a1 + 168)];
  [v8 setIsSimGood:*(unsigned __int8 *)(a1 + 169)];
  [v8 setIsSimHidden:*(unsigned __int8 *)(a1 + 170)];
  [v8 setIsSimDataOnly:*(unsigned __int8 *)(a1 + 171)];
  int v9 = (void *)(a1 + 56);
  if (*(char *)(a1 + 79) < 0)
  {
    if (!*(void *)(a1 + 64)) {
      goto LABEL_13;
    }
    int v9 = (void *)*v9;
    goto LABEL_12;
  }
  if (*(unsigned char *)(a1 + 79))
  {
LABEL_12:
    uint64_t v10 = +[NSString stringWithUTF8String:v9];
    [v8 setLabelID:v10];
  }
LABEL_13:
  __int16 v11 = (void *)(a1 + 8);
  if (*(char *)(a1 + 31) < 0)
  {
    if (!*(void *)(a1 + 16)) {
      goto LABEL_19;
    }
    __int16 v11 = (void *)*v11;
    goto LABEL_18;
  }
  if (*(unsigned char *)(a1 + 31))
  {
LABEL_18:
    uint64_t v12 = +[NSString stringWithUTF8String:v11];
    [v8 setLabel:v12];
  }
LABEL_19:
  __int16 v13 = (void *)(a1 + 88);
  if (*(char *)(a1 + 111) < 0)
  {
    if (!*(void *)(a1 + 96)) {
      goto LABEL_25;
    }
    __int16 v13 = (void *)*v13;
    goto LABEL_24;
  }
  if (*(unsigned char *)(a1 + 111))
  {
LABEL_24:
    uint64_t v14 = +[NSString stringWithUTF8String:v13];
    [v8 setPhoneNumber:v14];
  }
LABEL_25:
  int v15 = *(_DWORD *)(a1 + 136);
  if (v15)
  {
    uint64_t v16 = +[NSNumber numberWithBool:v15 == 2];
    [v8 setUserDataPreferred:v16];
  }
  int v17 = *(_DWORD *)(a1 + 140);
  if (v17)
  {
    int v18 = +[NSNumber numberWithBool:v17 == 2];
    [v8 setUserDefaultVoice:v18];
  }

  return v8;
}

void sub_1005AF3C8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id sub_1005AF40C(uint64_t a1)
{
  id v2 = objc_alloc((Class)NSUUID);
  if (*(char *)(a1 + 135) >= 0) {
    uint64_t v3 = a1 + 112;
  }
  else {
    uint64_t v3 = *(void *)(a1 + 112);
  }
  long long v4 = +[NSString stringWithUTF8String:v3];
  id v5 = [v2 initWithUUIDString:v4];

  if (*(char *)(a1 + 167) >= 0) {
    uint64_t v6 = a1 + 144;
  }
  else {
    uint64_t v6 = *(void *)(a1 + 144);
  }
  uint64_t v7 = +[NSString stringWithUTF8String:v6];
  if (*(_DWORD *)a1 == 1) {
    uint64_t v8 = 1;
  }
  else {
    uint64_t v8 = 2 * (*(_DWORD *)a1 == 2);
  }
  int v9 = +[CTXPCContextInfo contextWithUUID:v5 andAccountID:v7 andSlot:v8];

  uint64_t v10 = (void *)(a1 + 56);
  if (*(char *)(a1 + 79) < 0)
  {
    if (!*(void *)(a1 + 64)) {
      goto LABEL_16;
    }
    uint64_t v10 = (void *)*v10;
    goto LABEL_15;
  }
  if (*(unsigned char *)(a1 + 79))
  {
LABEL_15:
    __int16 v11 = +[NSString stringWithUTF8String:v10];
    [v9 setLabelID:v11];
  }
LABEL_16:
  uint64_t v12 = (void *)(a1 + 8);
  if (*(char *)(a1 + 31) < 0)
  {
    if (!*(void *)(a1 + 16)) {
      goto LABEL_22;
    }
    uint64_t v12 = (void *)*v12;
    goto LABEL_21;
  }
  if (*(unsigned char *)(a1 + 31))
  {
LABEL_21:
    __int16 v13 = +[NSString stringWithUTF8String:v12];
    [v9 setLabel:v13];
  }
LABEL_22:
  uint64_t v14 = (void *)(a1 + 88);
  if (*(char *)(a1 + 111) < 0)
  {
    if (!*(void *)(a1 + 96)) {
      goto LABEL_28;
    }
    uint64_t v14 = (void *)*v14;
    goto LABEL_27;
  }
  if (*(unsigned char *)(a1 + 111))
  {
LABEL_27:
    int v15 = +[NSString stringWithUTF8String:v14];
    [v9 setPhoneNumber:v15];
  }
LABEL_28:

  return v9;
}

void sub_1005AF5C0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id sub_1005AF608(void *a1)
{
  id v1 = a1;
  id v2 = v1;
  if (v1)
  {
    uint64_t v3 = [v1 subscriptions];
    long long v4 = +[NSMutableArray arrayWithCapacity:](NSMutableArray, "arrayWithCapacity:", [v3 count]);

    long long v14 = 0u;
    long long v15 = 0u;
    long long v12 = 0u;
    long long v13 = 0u;
    id v5 = objc_msgSend(v2, "subscriptions", 0);
    id v6 = [v5 countByEnumeratingWithState:&v12 objects:v16 count:16];
    if (v6)
    {
      uint64_t v7 = *(void *)v13;
      do
      {
        for (uint64_t i = 0; i != v6; uint64_t i = (char *)i + 1)
        {
          if (*(void *)v13 != v7) {
            objc_enumerationMutation(v5);
          }
          int v9 = +[CTServiceDescriptor descriptorWithSubscriptionContext:*(void *)(*((void *)&v12 + 1) + 8 * i)];
          [v4 addObject:v9];
        }
        id v6 = [v5 countByEnumeratingWithState:&v12 objects:v16 count:16];
      }
      while (v6);
    }

    id v10 = [objc_alloc((Class)CTServiceDescriptorContainer) initWithDescriptors:v4];
  }
  else
  {
    id v10 = 0;
  }

  return v10;
}

void sub_1005AF7A4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id sub_1005AF7F8(int a1)
{
  if (a1 == 1) {
    uint64_t v1 = 1;
  }
  else {
    uint64_t v1 = 2 * (a1 == 2);
  }
  id v2 = +[NSNumber numberWithInteger:v1];
  uint64_t v3 = +[CTServiceDescriptor telephonyDescriptorWithInstance:v2];

  return v3;
}

void sub_1005AF874(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1005AF884(void *a1, uint64_t a2)
{
  id v3 = a1;
  long long v4 = v3;
  if (v3)
  {
    id v5 = [v3 addr];

    if (v5)
    {
      id v6 = [v4 addr];
      long long v13 = (char *)[v6 UTF8String];
      sub_1000791C0((std::string *)a2, &v13);
    }
    uint64_t v7 = [v4 maskLen];

    if (v7)
    {
      uint64_t v8 = [v4 maskLen];
      *(_WORD *)(a2 + 32) = (unsigned __int16)[v8 unsignedCharValue] | 0x100;
    }
    int v9 = [v4 port];

    if (v9)
    {
      id v10 = [v4 port];
      *(_WORD *)(a2 + 34) = (unsigned __int16)[v10 unsignedShortValue];
      *(unsigned char *)(a2 + 36) = 1;
    }
    __int16 v11 = [v4 portRange];

    if (v11)
    {
      long long v12 = [v4 portRange];
      *(_WORD *)(a2 + 38) = (unsigned __int16)[v12 unsignedShortValue];
      *(unsigned char *)(a2 + 40) = 1;
    }
  }
}

void sub_1005AF9B8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1005AF9F0(void *a1, uint64_t a2)
{
  id v3 = a1;
  long long v4 = v3;
  if (v3)
  {
    *(_DWORD *)a2 = [v3 filterId];
    *(_DWORD *)(a2 + 24) = [v4 ipProtocol];
    *(_DWORD *)(a2 + 28) = [v4 ipFamilyProtocol];
    *(_DWORD *)(a2 + 20) = [v4 precedence];
    id v5 = [v4 tos];

    if (v5)
    {
      id v6 = [v4 tos];
      *(_WORD *)(a2 + 144) = (unsigned __int16)[v6 unsignedCharValue] | 0x100;
    }
    uint64_t v7 = [v4 tosMask];

    if (v7)
    {
      uint64_t v8 = [v4 tosMask];
      *(_WORD *)(a2 + 146) = (unsigned __int16)[v8 unsignedCharValue] | 0x100;
    }
    int v9 = [v4 flowLabel];

    if (v9)
    {
      id v10 = [v4 flowLabel];
      *(_DWORD *)(a2 + 148) = [v10 unsignedLongValue];
      *(unsigned char *)(a2 + 152) = 1;
    }
    __int16 v11 = [v4 src];

    if (v11)
    {
      long long v16 = 0u;
      long long v17 = 0u;
      *(_OWORD *)long long __p = 0u;
      long long v12 = [v4 src];
      sub_1005AF884(v12, (uint64_t)__p);

      sub_1005AFC38((std::string *)(a2 + 32), (std::string *)__p);
      if (BYTE8(v16))
      {
        if (SBYTE7(v16) < 0) {
          operator delete(__p[0]);
        }
      }
    }
    long long v13 = [v4 dst];

    if (v13)
    {
      long long v16 = 0u;
      long long v17 = 0u;
      *(_OWORD *)long long __p = 0u;
      long long v14 = [v4 dst];
      sub_1005AF884(v14, (uint64_t)__p);

      sub_1005AFC38((std::string *)(a2 + 88), (std::string *)__p);
      if (BYTE8(v16))
      {
        if (SBYTE7(v16) < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }
}

void sub_1005AFBD4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15)
{
  if (a15)
  {
    if (a14 < 0) {
      operator delete(__p);
    }
  }

  _Unwind_Resume(a1);
}

std::string *sub_1005AFC38(std::string *a1, std::string *a2)
{
  id v3 = &a1[1].__r_.__value_.__s.__data_[8];
  long long v4 = &a2[1].__r_.__value_.__s.__data_[8];
  if (a1[2].__r_.__value_.__s.__data_[0])
  {
    sub_100179AF8(a1, a2);
    uint64_t v5 = *(void *)v4;
    v3[8] = v4[8];
    *(void *)id v3 = v5;
  }
  else
  {
    sub_1000593FC((uint64_t)a1, (long long *)a2);
    uint64_t v6 = *(void *)v4;
    v3[8] = v4[8];
    *(void *)id v3 = v6;
    a1[2].__r_.__value_.__s.__data_[0] = 1;
  }
  return a1;
}

id sub_1005AFCA8(uint64_t a1)
{
  if (TrafficDescriptor::empty((TrafficDescriptor *)a1))
  {
    id v2 = 0;
    goto LABEL_47;
  }
  id v2 = objc_opt_new();
  if (*(unsigned char *)(a1 + 208))
  {
    CSIPacketAddress::operator std::string();
    id v3 = v23 >= 0 ? &__p : (void **)__p;
    long long v4 = +[NSString stringWithUTF8String:v3];
    [v2 setAddress:v4];

    if (v23 < 0) {
      operator delete(__p);
    }
  }
  if (*(unsigned char *)(a1 + 176))
  {
    if (*(char *)(a1 + 175) >= 0) {
      uint64_t v5 = a1 + 152;
    }
    else {
      uint64_t v5 = *(void *)(a1 + 152);
    }
    uint64_t v6 = +[NSString stringWithUTF8String:v5];
    [v2 setHost:v6];
  }
  if (*(unsigned char *)(a1 + 214))
  {
    uint64_t v7 = +[NSNumber numberWithUnsignedShort:*(unsigned __int16 *)(a1 + 212)];
    [v2 setPort:v7];
  }
  if (TrafficDescriptor::hasBundleInfo((TrafficDescriptor *)a1))
  {
    if (!*(unsigned char *)(a1 + 72)) {
      goto LABEL_50;
    }
    if (*(char *)(a1 + 71) >= 0) {
      uint64_t v8 = a1 + 48;
    }
    else {
      uint64_t v8 = *(void *)(a1 + 48);
    }
    int v9 = +[NSString stringWithUTF8String:v8];
    [v2 setBundleId:v9];
  }
  if (*(unsigned char *)(a1 + 104))
  {
    if (*(char *)(a1 + 103) >= 0) {
      uint64_t v10 = a1 + 80;
    }
    else {
      uint64_t v10 = *(void *)(a1 + 80);
    }
    __int16 v11 = +[NSString stringWithUTF8String:v10];
    [v2 setAppCategory:v11];
  }
  if (TrafficDescriptor::hasAccountInfo((TrafficDescriptor *)a1))
  {
    if (!*(unsigned char *)(a1 + 136)) {
      goto LABEL_50;
    }
    if (*(char *)(a1 + 135) >= 0) {
      uint64_t v12 = a1 + 112;
    }
    else {
      uint64_t v12 = *(void *)(a1 + 112);
    }
    long long v13 = +[NSString stringWithUTF8String:v12];
    [v2 setAccountId:v13];
  }
  if (*(unsigned char *)(a1 + 145))
  {
    long long v14 = +[NSNumber numberWithBool:*(unsigned __int8 *)(a1 + 144)];
    [v2 setLlphs:v14];
  }
  if (*(unsigned char *)(a1 + 264))
  {
    if (*(char *)(a1 + 263) >= 0) {
      uint64_t v15 = a1 + 240;
    }
    else {
      uint64_t v15 = *(void *)(a1 + 240);
    }
    long long v16 = +[NSString stringWithUTF8String:v15];
    [v2 setDnn:v16];
  }
  if (*(unsigned char *)(a1 + 224))
  {
    long long v17 = +[NSNumber numberWithUnsignedShort:*(unsigned __int16 *)(a1 + 222)];
    [v2 setIpProtocol:v17];
  }
  if (!*(unsigned char *)(a1 + 220)) {
    goto LABEL_45;
  }
  int v18 = +[NSNumber numberWithUnsignedShort:*(unsigned __int16 *)(a1 + 216)];
  [v2 setPortRangeLow:v18];

  if (!*(unsigned char *)(a1 + 220)) {
LABEL_50:
  }
    sub_10016C840();
  unint64_t v19 = +[NSNumber numberWithUnsignedShort:*(unsigned __int16 *)(a1 + 218)];
  [v2 setPortRangeUpper:v19];

LABEL_45:
  if (*(unsigned char *)(a1 + 232))
  {
    uint64_t v20 = +[NSNumber numberWithUnsignedLong:*(unsigned int *)(a1 + 228)];
    [v2 setTrafficClass:v20];
  }
LABEL_47:

  return v2;
}

void sub_1005AFFCC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  _Unwind_Resume(a1);
}

id sub_1005B0038(uint64_t **a1)
{
  if (*a1 == a1[1])
  {
    unint64_t v19 = 0;
  }
  else
  {
    uint64_t v2 = objc_opt_new();
    id v3 = *a1;
    uint64_t v21 = (void *)v2;
    uint64_t v22 = a1[1];
    if (*a1 != v22)
    {
      do
      {
        char v23 = objc_opt_new();
        if (*((char *)v3 + 23) >= 0) {
          long long v4 = v3;
        }
        else {
          long long v4 = (uint64_t *)*v3;
        }
        uint64_t v5 = +[NSString stringWithUTF8String:v4];
        [v23 setBundleId:v5];

        uint64_t v6 = +[NSNumber numberWithBool:*((unsigned __int8 *)v3 + 24)];
        [v23 setForeground:v6];

        uint64_t v7 = objc_opt_new();
        int v9 = (uint64_t *)v3[4];
        uint64_t v8 = (uint64_t *)v3[5];
        while (v9 != v8)
        {
          uint64_t v10 = objc_opt_new();
          if (*((char *)v9 + 23) >= 0) {
            __int16 v11 = v9;
          }
          else {
            __int16 v11 = (uint64_t *)*v9;
          }
          uint64_t v12 = +[NSString stringWithUTF8String:v11];
          [v10 setInterface:v12];

          long long v13 = objc_opt_new();
          long long v14 = (uint64_t *)v9[3];
          if (v14 != v9 + 4)
          {
            do
            {
              uint64_t v15 = sub_1005AFCA8((uint64_t)(v14 + 4));
              if (v15) {
                [v13 addObject:v15];
              }

              long long v16 = (uint64_t *)v14[1];
              if (v16)
              {
                do
                {
                  long long v17 = v16;
                  long long v16 = (uint64_t *)*v16;
                }
                while (v16);
              }
              else
              {
                do
                {
                  long long v17 = (uint64_t *)v14[2];
                  BOOL v18 = *v17 == (void)v14;
                  long long v14 = v17;
                }
                while (!v18);
              }
              long long v14 = v17;
            }
            while (v17 != v9 + 4);
          }
          [v10 setTrafficDescriptors:v13];

          if (v10) {
            [v7 addObject:v10];
          }

          v9 += 6;
        }
        [v23 setInterfaces:v7];

        if (v23) {
          [v21 addObject:v23];
        }

        v3 += 7;
      }
      while (v3 != v22);
    }
    unint64_t v19 = v21;
  }

  return v19;
}

void sub_1005B026C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

id sub_1005B02EC(unsigned int *a1)
{
  if (sub_1005B0478((uint64_t)a1))
  {
    uint64_t v2 = 0;
  }
  else
  {
    uint64_t v2 = objc_opt_new();
    [v2 setFilterId:*a1];
    [v2 setIpProtocol:a1[6]];
    [v2 setIpFamilyProtocol:a1[7]];
    [v2 setPrecedence:a1[5]];
    if (*((unsigned char *)a1 + 145))
    {
      id v3 = +[NSNumber numberWithUnsignedChar:*((unsigned __int8 *)a1 + 144)];
      [v2 setTos:v3];
    }
    if (*((unsigned char *)a1 + 147))
    {
      long long v4 = +[NSNumber numberWithUnsignedChar:*((unsigned __int8 *)a1 + 146)];
      [v2 setTosMask:v4];
    }
    if (*((unsigned char *)a1 + 152))
    {
      uint64_t v5 = +[NSNumber numberWithUnsignedLong:a1[37]];
      [v2 setFlowLabel:v5];
    }
    if (*((unsigned char *)a1 + 80))
    {
      uint64_t v6 = sub_1005B0518((uint64_t *)a1 + 4);
      [v2 setSrc:v6];
    }
    if (*((unsigned char *)a1 + 136))
    {
      uint64_t v7 = sub_1005B0518((uint64_t *)a1 + 11);
      [v2 setDst:v7];
    }
  }

  return v2;
}

void sub_1005B044C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL sub_1005B0478(uint64_t a1)
{
  BOOL result = 0;
  if (!*(_DWORD *)(a1 + 24) && !*(_DWORD *)(a1 + 28) && !*(unsigned char *)(a1 + 145) && !*(unsigned char *)(a1 + 152))
  {
    if (!*(unsigned char *)(a1 + 80)
      || (!*(unsigned char *)(a1 + 56)
       || (*(char *)(a1 + 55) < 0 ? (uint64_t v2 = *(void *)(a1 + 40)) : (uint64_t v2 = *(unsigned __int8 *)(a1 + 55)), !v2))
      && (!*(unsigned char *)(a1 + 68) || !*(_WORD *)(a1 + 66)))
    {
      if (!*(unsigned char *)(a1 + 136)) {
        return 1;
      }
      if (!*(unsigned char *)(a1 + 112)
        || (*(char *)(a1 + 111) < 0 ? (uint64_t v3 = *(void *)(a1 + 96)) : (uint64_t v3 = *(unsigned __int8 *)(a1 + 111)), !v3))
      {
        if (!*(unsigned char *)(a1 + 124) || !*(_WORD *)(a1 + 122)) {
          return 1;
        }
      }
    }
  }
  return result;
}

id sub_1005B0518(uint64_t *a1)
{
  if (!*((unsigned char *)a1 + 24)) {
    goto LABEL_8;
  }
  uint64_t v2 = *((unsigned __int8 *)a1 + 23);
  if ((v2 & 0x80u) != 0) {
    uint64_t v2 = a1[1];
  }
  if (!v2)
  {
LABEL_8:
    if (!*((unsigned char *)a1 + 36) || *((_WORD *)a1 + 17) == 0)
    {
      long long v4 = 0;
      goto LABEL_24;
    }
  }
  long long v4 = objc_opt_new();
  if (*((unsigned char *)a1 + 24))
  {
    if ((*((char *)a1 + 23) & 0x80000000) == 0)
    {
      uint64_t v5 = a1;
      if (!*((unsigned char *)a1 + 23)) {
        goto LABEL_18;
      }
      goto LABEL_17;
    }
    if (a1[1])
    {
      uint64_t v5 = (uint64_t *)*a1;
LABEL_17:
      uint64_t v6 = +[NSString stringWithUTF8String:v5];
      [v4 setAddr:v6];
    }
  }
LABEL_18:
  if (*((unsigned char *)a1 + 33))
  {
    uint64_t v7 = +[NSNumber numberWithUnsignedChar:*((unsigned __int8 *)a1 + 32)];
    [v4 setMaskLen:v7];
  }
  if (*((unsigned char *)a1 + 36))
  {
    uint64_t v8 = +[NSNumber numberWithUnsignedShort:*((unsigned __int16 *)a1 + 17)];
    [v4 setPort:v8];
  }
  if (*((unsigned char *)a1 + 40))
  {
    int v9 = +[NSNumber numberWithUnsignedShort:*((unsigned __int16 *)a1 + 19)];
    [v4 setPortRange:v9];
  }
LABEL_24:

  return v4;
}

void sub_1005B0674(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id sub_1005B069C(uint64_t *a1, void *a2)
{
  if (!a2[2])
  {
    id v8 = 0;
    goto LABEL_34;
  }
  v22[0] = 0;
  v22[1] = 0;
  uint64_t v21 = (uint64_t *)v22;
  uint64_t v3 = a2 + 1;
  long long v4 = (void *)*a2;
  if ((void *)*a2 != a2 + 1)
  {
    do
    {
      memset(v20, 0, sizeof(v20));
      *(_OWORD *)unint64_t v19 = 0u;
      TrafficDescriptor::TrafficDescriptor((TrafficDescriptor *)v19, (const TrafficDescriptor *)(v4 + 4));
      if (TrafficDescriptor::hasBundleInfo((TrafficDescriptor *)v19))
      {
        __p.n128_u8[0] = 0;
        char v18 = 0;
        sub_100179CB0((uint64_t)v20, &__p);
        if (v18 && v17 < 0) {
          operator delete((void *)__p.n128_u64[0]);
        }
        BYTE4(v19[0]) = 0;
        LOBYTE(v19[1]) = 0;
      }
      LODWORD(v19[0]) = 0;
      sub_1003816BC(&v21, (uint64_t)v19, (const TrafficDescriptor *)v19);
      TrafficDescriptor::~TrafficDescriptor((TrafficDescriptor *)v19);
      uint64_t v5 = (void *)v4[1];
      if (v5)
      {
        do
        {
          uint64_t v6 = v5;
          uint64_t v5 = (void *)*v5;
        }
        while (v5);
      }
      else
      {
        do
        {
          uint64_t v6 = (void *)v4[2];
          BOOL v7 = *v6 == (void)v4;
          long long v4 = v6;
        }
        while (!v7);
      }
      long long v4 = v6;
    }
    while (v6 != v3);
  }
  id v8 = objc_alloc_init((Class)NSMutableArray);
  if ((*((char *)a1 + 23) & 0x80000000) == 0)
  {
    if (!*((unsigned char *)a1 + 23)) {
      goto LABEL_21;
    }
    goto LABEL_20;
  }
  if (a1[1])
  {
    a1 = (uint64_t *)*a1;
LABEL_20:
    int v9 = +[NSString stringWithUTF8String:a1];
    [v8 addObject:v9];
  }
LABEL_21:
  uint64_t v10 = v21;
  if (v21 != (uint64_t *)v22)
  {
    do
    {
      TrafficDescriptor::toString((uint64_t *)v19, (TrafficDescriptor *)(v10 + 4));
      if ((SBYTE7(v20[0]) & 0x80u) == 0) {
        __int16 v11 = v19;
      }
      else {
        __int16 v11 = (void **)v19[0];
      }
      uint64_t v12 = +[NSString stringWithUTF8String:v11];
      [v8 addObject:v12];

      if (SBYTE7(v20[0]) < 0) {
        operator delete(v19[0]);
      }
      long long v13 = (uint64_t *)v10[1];
      if (v13)
      {
        do
        {
          long long v14 = v13;
          long long v13 = (uint64_t *)*v13;
        }
        while (v13);
      }
      else
      {
        do
        {
          long long v14 = (uint64_t *)v10[2];
          BOOL v7 = *v14 == (void)v10;
          uint64_t v10 = v14;
        }
        while (!v7);
      }
      uint64_t v10 = v14;
    }
    while (v14 != (uint64_t *)v22);
  }
  sub_10005D9E0((uint64_t)&v21, v22[0]);
LABEL_34:

  return v8;
}

void sub_1005B08F0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  sub_10005D9E0(v20 - 88, *(void **)(v20 - 80));
  _Unwind_Resume(a1);
}

id sub_1005B0960(int *a1)
{
  if (*a1 && (uint64_t v2 = (const std::error_category *)*((void *)a1 + 1), v2 == std::generic_category()))
  {
    uint64_t v3 = +[NSError errorWithDomain:NSPOSIXErrorDomain code:*a1 userInfo:0];
  }
  else
  {
    uint64_t v3 = 0;
  }

  return v3;
}

void sub_1005B09D4(void *a1@<X0>, CFUUIDRef *a2@<X8>)
{
  CFUUIDRef v3 = a1;
  CFUUIDRef v4 = v3;
  if (v3)
  {
    CFUUIDRef v5 = v3;
    CFUUIDRef v3 = CFUUIDCreateFromString(0, (CFStringRef)[(__CFUUID *)v3 UUIDString]);
    CFUUIDRef v4 = v5;
  }
  *a2 = v3;
}

void sub_1005B0A38(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

id sub_1005B0A4C(CFUUIDRef uuid)
{
  if (uuid)
  {
    CFStringRef v3 = CFUUIDCreateString(0, uuid);
    id v1 = [objc_alloc((Class)NSUUID) initWithUUIDString:v3];
    sub_1000558F4((const void **)&v3);
  }
  else
  {
    id v1 = 0;
  }

  return v1;
}

void sub_1005B0AC0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000558F4((const void **)va);
  _Unwind_Resume(a1);
}

id sub_1005B0AD4(uint64_t **a1)
{
  uint64_t v2 = objc_opt_new();
  if (*((char *)a1 + 23) < 0)
  {
    if (!a1[1]) {
      goto LABEL_7;
    }
    CFStringRef v3 = *a1;
    goto LABEL_6;
  }
  CFStringRef v3 = (uint64_t *)a1;
  if (*((unsigned char *)a1 + 23))
  {
LABEL_6:
    CFUUIDRef v4 = +[NSString stringWithUTF8String:v3];
    [v2 setHomePlmn:v4];
  }
LABEL_7:
  CFUUIDRef v5 = +[NSMutableArray arrayWithCapacity:0x8E38E38E38E38E39 * (a1[4] - a1[3])];
  uint64_t v6 = a1[3];
  BOOL v7 = a1[4];
  if (v6 != v7)
  {
    while (1)
    {
      id v8 = objc_opt_new();
      if (*((char *)v6 + 23) < 0) {
        break;
      }
      int v9 = v6;
      if (*((unsigned char *)v6 + 23)) {
        goto LABEL_13;
      }
LABEL_14:
      int v11 = *((_DWORD *)v6 + 7);
      if (v11 != 11) {
        [v8 setRat:sub_10006941C(v11)];
      }
      uint64_t v12 = v6 + 5;
      if ((*((char *)v6 + 63) & 0x80000000) == 0)
      {
        if (!*((unsigned char *)v6 + 63)) {
          goto LABEL_22;
        }
        goto LABEL_21;
      }
      if (v6[6])
      {
        uint64_t v12 = (void *)*v12;
LABEL_21:
        long long v13 = +[NSString stringWithUTF8String:v12];
        [v8 setReasonCode:v13];
      }
LABEL_22:
      [v8 setIsRoaming:*((unsigned __int8 *)v6 + 24)];
      int v14 = *((_DWORD *)v6 + 8);
      if (v14 == 2) {
        uint64_t v15 = 2;
      }
      else {
        uint64_t v15 = v14 == 1;
      }
      [v8 setSourceType:v15];
      [v8 setIsNetworkInitiated:*((unsigned __int8 *)v6 + 25)];
      [v8 setTimeOfEvent:v6[8]];
      [v5 addObject:v8];

      v6 += 9;
      if (v6 == v7) {
        goto LABEL_26;
      }
    }
    if (!v6[1]) {
      goto LABEL_14;
    }
    int v9 = (uint64_t *)*v6;
LABEL_13:
    uint64_t v10 = +[NSString stringWithUTF8String:v9];
    [v8 setNetworkPlmn:v10];

    goto LABEL_14;
  }
LABEL_26:
  [v2 setEvents:v5];

  return v2;
}

void sub_1005B0CDC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL sub_1005B0D28(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 72) || (BOOL result = sub_1005B0F0C(a1 + 16)))
  {
    if (!*(unsigned char *)(a1 + 136)) {
      return 1;
    }
    BOOL result = sub_1005B0F0C(a1 + 80);
    if (result) {
      return 1;
    }
  }
  return result;
}

id sub_1005B0D74(unsigned int *a1)
{
  if (sub_1005B0F0C((uint64_t)a1))
  {
    uint64_t v2 = 0;
  }
  else
  {
    uint64_t v2 = objc_opt_new();
    if (*((unsigned char *)a1 + 4))
    {
      CFStringRef v3 = +[NSNumber numberWithUnsignedInt:*a1];
      [v2 setQci:v3];
    }
    if (*((unsigned char *)a1 + 12))
    {
      CFUUIDRef v4 = +[NSNumber numberWithUnsignedInt:a1[2]];
      [v2 setBitRateMax:v4];
    }
    if (*((unsigned char *)a1 + 20))
    {
      CFUUIDRef v5 = +[NSNumber numberWithUnsignedInt:a1[4]];
      [v2 setBitRateMin:v5];
    }
    if (*((unsigned char *)a1 + 48))
    {
      if (*((void *)a1 + 3) == *((void *)a1 + 4))
      {
        uint64_t v6 = 0;
      }
      else
      {
        uint64_t v6 = objc_opt_new();
        BOOL v7 = (unsigned int *)*((void *)a1 + 3);
        id v8 = (unsigned int *)*((void *)a1 + 4);
        while (v7 != v8)
        {
          int v9 = sub_1005B02EC(v7);
          if (v9) {
            [v6 addObject:v9];
          }

          v7 += 40;
        }
      }
      [v2 setFilters:v6];
    }
  }

  return v2;
}

void sub_1005B0ED0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL sub_1005B0F0C(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 4) && *(_DWORD *)a1
    || *(unsigned char *)(a1 + 12) && *(_DWORD *)(a1 + 8)
    || *(unsigned char *)(a1 + 20) && *(_DWORD *)(a1 + 16))
  {
    return 0;
  }
  if (!*(unsigned char *)(a1 + 48)) {
    return 1;
  }
  uint64_t v2 = *(void *)(a1 + 24);
  uint64_t v3 = *(void *)(a1 + 32);
  if (v2 == v3) {
    return 1;
  }
  do
  {
    BOOL result = sub_1005B0478(v2);
    if (!result) {
      break;
    }
    v2 += 160;
  }
  while (v2 != v3);
  return result;
}

void sub_1005B122C(_Unwind_Exception *a1)
{
  if ((v4 & 1) == 0) {
    sub_10004D2C8(v2);
  }

  _Unwind_Resume(a1);
}

void sub_1005B1568(_Unwind_Exception *a1)
{
  if ((v4 & 1) == 0) {
    sub_10004D2C8(v2);
  }

  _Unwind_Resume(a1);
}

uint64_t sub_1005B15E4(uint64_t a1)
{
  return a1;
}

void sub_1005B1618(uint64_t a1)
{
  operator delete();
}

void *sub_1005B166C(uint64_t a1)
{
  uint64_t v2 = operator new(0x18uLL);
  void *v2 = off_1019EA178;
  v2[1] = *(id *)(a1 + 8);
  v2[2] = objc_retainBlock(*(id *)(a1 + 16));
  return v2;
}

id sub_1005B16D0(uint64_t a1, void *a2)
{
  *a2 = off_1019EA178;
  a2[1] = *(id *)(a1 + 8);
  id result = objc_retainBlock(*(id *)(a1 + 16));
  a2[2] = result;
  return result;
}

void sub_1005B1728(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 8);
}

void sub_1005B1764(id *a1)
{
  operator delete(a1);
}

void sub_1005B17A8(uint64_t a1, long long *a2)
{
  long long v7 = *a2;
  int v8 = *((_DWORD *)a2 + 4);
  uint64_t v3 = +[CTEmergencyMode convertFromEmergencyMode:&v7];
  uint64_t v4 = *(void *)(a1 + 16);
  CFUUIDRef v5 = [*(id *)(a1 + 8) dataProviderDelegate];
  uint64_t v6 = [v5 contextForSlot:DWORD1(v7)];
  (*(void (**)(uint64_t, void *, void *, void))(v4 + 16))(v4, v6, v3, 0);

  EmergencyMode::~EmergencyMode((EmergencyMode *)&v7);
}

void sub_1005B1850(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  EmergencyMode::~EmergencyMode((EmergencyMode *)&a9);
  _Unwind_Resume(a1);
}

uint64_t sub_1005B1888(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_1019EA1E8)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_1005B18C8()
{
  return &off_1019EA1E8;
}

uint64_t sub_1005B18D4(uint64_t a1)
{
  return a1;
}

void sub_1005B1900(uint64_t a1)
{
  operator delete();
}

void *sub_1005B194C(uint64_t a1)
{
  uint64_t v2 = operator new(0x10uLL);
  void *v2 = off_1019EA208;
  v2[1] = objc_retainBlock(*(id *)(a1 + 8));
  return v2;
}

id sub_1005B19A4(uint64_t a1, void *a2)
{
  *a2 = off_1019EA208;
  id result = objc_retainBlock(*(id *)(a1 + 8));
  a2[1] = result;
  return result;
}

void sub_1005B19EC(uint64_t a1)
{
}

void sub_1005B19F4(id *a1)
{
  operator delete(a1);
}

void sub_1005B1A30(uint64_t a1, void *a2)
{
  id v12 = objc_alloc_init((Class)NSMutableArray);
  uint64_t v6 = (void *)*a2;
  uint64_t v4 = a2 + 1;
  CFUUIDRef v5 = v6;
  if (v6 != v4)
  {
    do
    {
      long long v7 = v5 + 4;
      if (*((char *)v5 + 55) < 0) {
        long long v7 = (void *)*v7;
      }
      int v8 = +[NSString stringWithCString:encoding:](NSString, "stringWithCString:encoding:", v7, +[NSString defaultCStringEncoding]);
      [v12 addObject:v8];

      int v9 = (void *)v5[1];
      if (v9)
      {
        do
        {
          uint64_t v10 = v9;
          int v9 = (void *)*v9;
        }
        while (v9);
      }
      else
      {
        do
        {
          uint64_t v10 = (void *)v5[2];
          BOOL v11 = *v10 == (void)v5;
          CFUUIDRef v5 = v10;
        }
        while (!v11);
      }
      CFUUIDRef v5 = v10;
    }
    while (v10 != v4);
  }
  (*(void (**)(void))(*(void *)(a1 + 8) + 16))();
}

void sub_1005B1B34(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1005B1B58(uint64_t a1, uint64_t a2)
{
  if (sub_10006C624(a2, (uint64_t)&off_1019EA278)) {
    return a1 + 8;
  }
  else {
    return 0;
  }
}

_UNKNOWN **sub_1005B1B98()
{
  return &off_1019EA278;
}

void *sub_1005B1BA4(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void sub_1005B1C28(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  operator new();
}

void sub_1005B1FD0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, dispatch_object_t object, dispatch_object_t a16, void *a17, std::__shared_weak_count *a18, int a19, __int16 a20,char a21,char a22)
{
  if (__p) {
    (*(void (**)(void *))(*(void *)__p + 8))(__p);
  }
  if (a18) {
    sub_10004D2C8(a18);
  }
  sub_10004D2C8(v22);
  _Unwind_Resume(a1);
}

void *sub_1005B2160(uint64_t a1)
{
  sub_1005B25E0(a1 + 32, *(void **)(a1 + 40));

  return sub_1005B263C((void *)a1);
}

void sub_1005B21A0(uint64_t a1, dispatch_object_t object)
{
  if (object)
  {
    dispatch_retain(object);
    dispatch_group_enter(object);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 8);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_1005B22A0(unint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 336);
  v3[0] = a1;
  v3[1] = 0uLL;
  sub_1005B26C0((void *)v3 + 1, *(void **)v2, *(void **)(v2 + 8), (uint64_t)(*(void *)(v2 + 8) - *(void *)v2) >> 4);
  char v4 = *(unsigned char *)(v2 + 24);
  sub_1005B3B3C((uint64_t)&v5, (void *)(a1 + 160));
  operator new();
}

void sub_1005B23C8(_Unwind_Exception *a1)
{
  *(void *)(v2 - 40) = v1;
  sub_10005CBF0((void ***)(v2 - 40));
  _Unwind_Resume(a1);
}

uint64_t sub_1005B23E0(uint64_t result, uint64_t a2)
{
  unint64_t v3 = result;
  unsigned int v4 = *(unsigned __int8 *)(a2 + 24);
  if (v4 - 6 < 2)
  {
    uint64_t v10 = *(NSObject **)(result + 32);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v11 = *(unsigned __int8 *)(a2 + 23);
      BOOL v12 = (v11 & 0x80u) != 0;
      if ((v11 & 0x80u) != 0) {
        uint64_t v11 = *(void *)(a2 + 8);
      }
      if (v12) {
        long long v13 = *(const char **)a2;
      }
      else {
        long long v13 = (const char *)a2;
      }
      if (v11) {
        int v14 = v13;
      }
      else {
        int v14 = "<invalid>";
      }
      LODWORD(v23) = 136315138;
      *(void *)((char *)&v23 + 4) = v14;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I Personality is removed: %s", (uint8_t *)&v23, 0xCu);
    }
    *(void *)&long long v23 = 1;
    *((void *)&v23 + 1) = v3 + 128;
    uint64_t v15 = (void ***)(v3 + 160);
    long long v16 = sub_100046F68(v3 + 160, (void **)a2);
    if ((void **)(v3 + 168) != v16)
    {
      char v17 = (uint64_t *)v16;
      char v18 = (void **)v16[1];
      if (v18)
      {
        do
        {
          unint64_t v19 = v18;
          char v18 = (void **)*v18;
        }
        while (v18);
      }
      else
      {
        uint64_t v20 = v16;
        do
        {
          unint64_t v19 = (void **)v20[2];
          BOOL v21 = *v19 == v20;
          uint64_t v20 = v19;
        }
        while (!v21);
      }
      if (*v15 == v16) {
        void *v15 = v19;
      }
      uint64_t v22 = *(uint64_t **)(v3 + 168);
      --*(void *)(v3 + 176);
      sub_10005EE6C(v22, v17);
      sub_1002B2A44((uint64_t)(v17 + 4));
      operator delete(v17);
    }
    return sub_1005B4890((uint64_t)&v23);
  }
  else if (v4 <= 1)
  {
    uint64_t v5 = *(NSObject **)(result + 32);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v6 = *(unsigned __int8 *)(a2 + 23);
      BOOL v7 = (v6 & 0x80u) != 0;
      if ((v6 & 0x80u) != 0) {
        uint64_t v6 = *(void *)(a2 + 8);
      }
      if (v7) {
        int v8 = *(const char **)a2;
      }
      else {
        int v8 = (const char *)a2;
      }
      if (v6) {
        int v9 = v8;
      }
      else {
        int v9 = "<invalid>";
      }
      LODWORD(v23) = 136315138;
      *(void *)((char *)&v23 + 4) = v9;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Personality is enabled/added: %s", (uint8_t *)&v23, 0xCu);
    }
    sub_1005B22A0(v3);
  }
  return result;
}

void sub_1005B25E0(uint64_t a1, void *a2)
{
  if (a2)
  {
    sub_1005B25E0(a1, *a2);
    sub_1005B25E0(a1, a2[1]);
    sub_1002B2A44((uint64_t)(a2 + 4));
    operator delete(a2);
  }
}

void *sub_1005B263C(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *sub_1005B26C0(void *result, void *a2, void *a3, unint64_t a4)
{
  if (a4)
  {
    uint64_t v6 = result;
    sub_1001577CC(result, a4);
    id result = sub_1005B2748((uint64_t)(v6 + 2), a2, a3, (void *)v6[1]);
    v6[1] = result;
  }
  return result;
}

void sub_1005B2728(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  *(void *)(v9 + 8) = v10;
  sub_10005CBF0(&a9);
  _Unwind_Resume(a1);
}

void *sub_1005B2748(uint64_t a1, void *a2, void *a3, void *a4)
{
  unsigned int v4 = a4;
  uint64_t v9 = a4;
  v7[0] = a1;
  v7[1] = &v8;
  double v7[3] = 1;
  int v8 = a4;
  _OWORD v7[2] = &v9;
  if (a2 != a3)
  {
    do
    {
      void *v4 = *a2;
      uint64_t v5 = a2[1];
      v4[1] = v5;
      if (v5) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
      }
      v4 += 2;
      a2 += 2;
    }
    while (a2 != a3);
    uint64_t v9 = v4;
  }
  sub_1005B27D4((uint64_t)v7);
  return v4;
}

uint64_t sub_1005B27D4(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    sub_10037AA1C(a1);
  }
  return a1;
}

void sub_1005B2810(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_1005B2848(uint64_t a1)
{
}

uint64_t sub_1005B2864(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_1005B28A8(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = result;
    uint64_t v2 = *(NSObject **)(result + 352);
    if (v2) {
      dispatch_release(v2);
    }
    PersonalitiesTracker::~PersonalitiesTracker((PersonalitiesTracker *)(v1 + 184));
    sub_1005B25E0(v1 + 160, *(void **)(v1 + 168));
    sub_1005B263C((void *)(v1 + 128));
    sub_100F012E8(v1 + 88);
    unint64_t v3 = *(std::__shared_weak_count **)(v1 + 80);
    if (v3) {
      sub_10004D2C8(v3);
    }
    unsigned int v4 = *(std::__shared_weak_count **)(v1 + 64);
    if (v4) {
      sub_10004D2C8(v4);
    }
    uint64_t v5 = *(std::__shared_weak_count **)(v1 + 48);
    if (v5) {
      sub_10004D2C8(v5);
    }
    ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(v1 + 32));
    sub_100087E88((void *)v1);
    operator delete();
  }
  return result;
}

void sub_1005B2958(ServiceManager::Service *this)
{
  *(void *)this = off_1019EA2F8;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }

  ServiceManager::Service::~Service(this);
}

void sub_1005B29B4(ServiceManager::Service *this)
{
  *(void *)this = off_1019EA2F8;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  ServiceManager::Service::~Service(this);

  operator delete();
}

void *sub_1005B2A24@<X0>(void *a1@<X8>)
{
  return sub_100058DB0(a1, "TTYSettingsManager");
}

unsigned char *sub_1005B2A34@<X0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  uint64_t v2 = operator new(1uLL);
  *a1 = v2;
  unsigned char *v2 = 2;
  id result = v2 + 1;
  a1[1] = result;
  a1[2] = result;
  return result;
}

void sub_1005B2A74(uint64_t a1, dispatch_object_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  unint64_t v3 = *a2;
  if (*a2)
  {
    dispatch_retain(*a2);
    dispatch_group_enter(v3);
    sub_1005B21A0(v2, v3);
  }
  uint64_t v4 = *(void *)(a1 + 8);

  sub_1005B21A0(v4, 0);
}

uint64_t sub_1005B2AF8()
{
  return 0;
}

uint64_t sub_1005B2B00()
{
  return 1;
}

uint64_t sub_1005B2B08()
{
  return 0;
}

uint64_t sub_1005B2B18(uint64_t result, int a2, ServiceStage *this)
{
  if (a2 == 2)
  {
    uint64_t v3 = *(void *)(result + 8);
    ServiceStage::holdOffStage((uint64_t *)&group[1], this);
    uint64_t v4 = *(std::__shared_weak_count **)(v3 + 8);
    if (v4)
    {
      if (std::__shared_weak_count::lock(v4)) {
        operator new();
      }
    }
    sub_100088B9C();
  }
  return result;
}

void sub_1005B2C38()
{
}

void *sub_1005B2C4C(uint64_t a1)
{
  id result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_1019EA378;
  result[1] = v3;
  return result;
}

uint64_t sub_1005B2C94(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019EA378;
  a2[1] = v2;
  return result;
}

void sub_1005B2CC0(uint64_t a1, xpc_object_t *a2)
{
  *a2 = xpc_null_create();
  unint64_t v3 = *(void *)(a1 + 8);
  uint64_t v4 = *(NSObject **)(v3 + 32);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v5 = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Incoming TTY calls switch changed, evaluating state", v5, 2u);
  }
  sub_1005B22A0(v3);
}

void sub_1005B2D54(_Unwind_Exception *a1)
{
  xpc_release(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1005B2D70(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_1005B2DB0()
{
}

void *sub_1005B2DBC(void *a1)
{
  *a1 = off_1019EA3F8;
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_1005B2E08(void *a1)
{
  *a1 = off_1019EA3F8;
  uint64_t v1 = (std::__shared_weak_count *)a1[3];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

char *sub_1005B2E74(uint64_t a1)
{
  id result = (char *)operator new(0x20uLL);
  *(void *)id result = off_1019EA3F8;
  *(_OWORD *)(result + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 24);
  *((void *)result + 3) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_1005B2ED8(uint64_t result, uint64_t a2)
{
  *(void *)a2 = off_1019EA3F8;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(result + 8);
  uint64_t v2 = *(void *)(result + 24);
  *(void *)(a2 + 24) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_1005B2F18(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 24);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_1005B2F28(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete(__p);
}

void sub_1005B2F68(void *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2)
  {
    unint64_t v3 = a1[1];
    uint64_t v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      if (a1[2])
      {
        uint64_t v5 = *(NSObject **)(v3 + 32);
        if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)uint64_t v6 = 0;
          _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Transport method changed, evaluating state", v6, 2u);
        }
        sub_1005B22A0(v3);
      }
      sub_10004D2C8(v4);
    }
  }
}

void sub_1005B3004(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1005B3018(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_1005B3058()
{
}

uint64_t *sub_1005B3064(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v5 = a1;
  uint64_t v6 = v1;
  uint64_t v2 = *(void *)v1;
  unint64_t v3 = *(NSObject **)(*(void *)v1 + 32);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Shutting down", buf, 2u);
  }
  ctu::RestModule::disconnect((ctu::RestModule *)(v2 + 72));
  (*(void (**)(void))(**(void **)(v2 + 56) + 40))(*(void *)(v2 + 56));
  sub_100F018AC(v2 + 88);
  sub_100088C88(&v6);
  return sub_100046B58((uint64_t *)&v5);
}

void sub_1005B311C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

uint64_t *sub_1005B3138(uint64_t *a1)
{
  uint64_t v1 = *a1;
  char v17 = a1;
  uint64_t v18 = v1;
  uint64_t v2 = *(uint64_t **)v1;
  unint64_t v3 = *(NSObject **)(*(void *)v1 + 32);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Bootstrapping", buf, 2u);
  }
  uint64_t v4 = (uint8_t *)(v2 + 16);
  *(void *)long long buf = off_1019EA478;
  uint64_t v26 = v2 + 9;
  unint64_t v27 = buf;
  if (buf != (uint8_t *)(v2 + 16))
  {
    uint64_t v5 = (uint8_t *)v2[19];
    if (v5 == v4)
    {
      v23[1] = v2 + 9;
      void v23[2] = 0;
      v23[0] = off_1019EA478;
      unint64_t v27 = 0;
      (*(void (**)(uint64_t *, uint8_t *))(*(void *)v4 + 24))(v2 + 16, buf);
      (*(void (**)(uint64_t))(*(void *)v2[19] + 32))(v2[19]);
      v2[19] = 0;
      unint64_t v27 = buf;
      (*(void (**)(void *, uint64_t *))(v23[0] + 24))(v23, v2 + 16);
      (*(void (**)(void *))(v23[0] + 32))(v23);
    }
    else
    {
      v2[16] = (uint64_t)off_1019EA478;
      v2[17] = (uint64_t)(v2 + 9);
      unint64_t v27 = v5;
    }
    v2[19] = (uint64_t)v4;
  }
  sub_1005B263C(buf);
  uint64_t v6 = v2[19];
  if (v6) {
    (*(void (**)(uint64_t, uint64_t *))(*(void *)v6 + 48))(v6, v2 + 20);
  }
  BOOL v7 = (uint8_t *)operator new(0x20uLL);
  *(void *)BOOL v7 = off_1019EA508;
  *((void *)v7 + 1) = v2;
  *((void *)v7 + 2) = sub_1005B23E0;
  *((void *)v7 + 3) = 0;
  unint64_t v27 = v7;
  uint64_t v24 = 0;
  uint64_t v22 = 0;
  PersonalitiesTracker::bind();
  sub_100100490(&v20);
  sub_10010040C(v23);
  sub_100100388(buf);
  Registry::createRestModuleOneTimeUseConnection(&v20, (Registry *)v2[5]);
  ctu::RestModule::connect();
  if (v21) {
    sub_10004D2C8(v21);
  }
  uint64_t v8 = (*(uint64_t (**)(uint64_t))(*(void *)v2[7] + 40))(v2[7]);
  *(void *)long long buf = off_1019EA378;
  uint64_t v26 = v2;
  unint64_t v27 = buf;
  sub_100F017C8(v2 + 11, v8, (uint64_t)buf);
  sub_1001472DC(buf);
  uint64_t v9 = v2[7];
  uint64_t v10 = v2[2];
  dispatch_object_t object = v10;
  if (v10) {
    dispatch_retain(v10);
  }
  uint64_t v11 = (std::__shared_weak_count *)v2[1];
  if (!v11 || (uint64_t v12 = *v2, (v13 = std::__shared_weak_count::lock(v11)) == 0)) {
    sub_100088B9C();
  }
  int v14 = v13;
  atomic_fetch_add_explicit(&v13->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v13);
  uint64_t v24 = 0;
  uint64_t v15 = operator new(0x20uLL);
  void *v15 = off_1019EA3F8;
  v15[1] = v2;
  void v15[2] = v12;
  _OWORD v15[3] = v14;
  uint64_t v24 = v15;
  (*(void (**)(uint64_t, dispatch_object_t *, void *))(*(void *)v9 + 16))(v9, &object, v23);
  sub_10003B34C(v23);
  if (object) {
    dispatch_release(object);
  }
  sub_100088C88(&v18);
  return sub_100046B58((uint64_t *)&v17);
}

void sub_1005B3530(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, int a11, __int16 a12, char a13, char a14, dispatch_object_t object, char a16, uint64_t a17, uint64_t a18, uint64_t a19, char a20,uint64_t a21,uint64_t a22,uint64_t a23,char a24)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_1005B35DC()
{
}

void *sub_1005B35F0(uint64_t a1)
{
  id result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_1019EA478;
  result[1] = v3;
  return result;
}

uint64_t sub_1005B3638(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019EA478;
  a2[1] = v2;
  return result;
}

void sub_1005B3664(uint64_t a1, void *a2)
{
  xpc_object_t v3 = xpc_array_create(0, 0);
  if (v3 || (xpc_object_t v3 = xpc_null_create()) != 0)
  {
    if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_array)
    {
      xpc_retain(v3);
      xpc_object_t v4 = v3;
    }
    else
    {
      xpc_object_t v4 = xpc_null_create();
    }
  }
  else
  {
    xpc_object_t v4 = xpc_null_create();
    xpc_object_t v3 = 0;
  }
  xpc_release(v3);
  BOOL v7 = (void *)*a2;
  uint64_t v5 = a2 + 1;
  uint64_t v6 = v7;
  if (v7 != v5)
  {
    do
    {
      xpc_object_t v8 = xpc_dictionary_create(0, 0, 0);
      xpc_object_t v9 = v8;
      if (v8)
      {
        xpc_object_t v23 = v8;
      }
      else
      {
        xpc_object_t v9 = xpc_null_create();
        xpc_object_t v23 = v9;
        if (!v9)
        {
          xpc_object_t v10 = xpc_null_create();
          xpc_object_t v9 = 0;
          goto LABEL_15;
        }
      }
      if (xpc_get_type(v9) != (xpc_type_t)&_xpc_type_dictionary)
      {
        xpc_object_t v10 = xpc_null_create();
LABEL_15:
        xpc_object_t v23 = v10;
        goto LABEL_16;
      }
      xpc_retain(v9);
LABEL_16:
      xpc_release(v9);
      write_rest_value();
      __n128 __p = &v23;
      char v17 = "first";
      sub_100035E70((uint64_t)&__p, &v21, &object);
      xpc_release(object);
      xpc_object_t object = 0;
      xpc_release(v21);
      xpc_object_t v21 = 0;
      write_rest_value();
      __n128 __p = &v23;
      char v17 = "second";
      sub_100035E70((uint64_t)&__p, &v19, &v20);
      xpc_release(v20);
      xpc_object_t v20 = 0;
      xpc_release(v19);
      xpc_object_t v19 = 0;
      xpc_object_t v11 = v23;
      if (v23) {
        xpc_retain(v23);
      }
      else {
        xpc_object_t v11 = xpc_null_create();
      }
      xpc_release(v23);
      xpc_array_append_value(v4, v11);
      xpc_release(v11);
      uint64_t v12 = (void *)v6[1];
      if (v12)
      {
        do
        {
          long long v13 = v12;
          uint64_t v12 = (void *)*v12;
        }
        while (v12);
      }
      else
      {
        do
        {
          long long v13 = (void *)v6[2];
          BOOL v14 = *v13 == (void)v6;
          uint64_t v6 = v13;
        }
        while (!v14);
      }
      uint64_t v6 = v13;
    }
    while (v13 != v5);
  }
  if (v4)
  {
    xpc_retain(v4);
    xpc_object_t v15 = v4;
  }
  else
  {
    xpc_object_t v15 = xpc_null_create();
  }
  xpc_release(v4);
  sub_100058DB0(&__p, "/cc/props/tty_settings");
  xpc_object_t v23 = v15;
  if (v15) {
    xpc_retain(v15);
  }
  else {
    xpc_object_t v23 = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(v23);
  xpc_object_t v23 = 0;
  if (v18 < 0) {
    operator delete(__p);
  }
  xpc_release(v15);
}

void sub_1005B391C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, xpc_object_t object)
{
  xpc_release(object);
  if (a14 < 0) {
    operator delete(__p);
  }
  xpc_release(v19);
  _Unwind_Resume(a1);
}

uint64_t sub_1005B39D4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1005B3A14()
{
}

void sub_1005B3A24()
{
}

__n128 sub_1005B3A38(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_1019EA508;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_1005B3A8C(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019EA508;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_1005B3AC4(void *a1, uint64_t a2, uint64_t a3)
{
  xpc_object_t v4 = (uint64_t (*)(void *, uint64_t))a1[2];
  uint64_t v5 = a1[3];
  uint64_t v6 = (void *)(a1[1] + (v5 >> 1));
  if (v5) {
    return (*(uint64_t (**)(void))(*v6 + v4))();
  }
  else {
    return v4(v6, a3);
  }
}

uint64_t sub_1005B3AF0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1005B3B30()
{
}

uint64_t sub_1005B3B3C(uint64_t a1, void *a2)
{
  *(void *)(a1 + 8) = 0;
  xpc_object_t v3 = (void *)(a1 + 8);
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = a1 + 8;
  xpc_object_t v4 = (void **)(a2 + 1);
  uint64_t v5 = (void **)*a2;
  if ((void *)*a2 != a2 + 1)
  {
    do
    {
      xpc_object_t v15 = 0;
      uint64_t v6 = *(void **)(a1 + 8);
      if (*(void **)a1 == v3)
      {
        xpc_object_t v8 = v3;
        if (!v6) {
          goto LABEL_14;
        }
      }
      else
      {
        BOOL v7 = v3;
        if (v6)
        {
          do
          {
            xpc_object_t v8 = v6;
            uint64_t v6 = (void *)v6[1];
          }
          while (v6);
        }
        else
        {
          do
          {
            xpc_object_t v8 = (void *)v7[2];
            BOOL v9 = *v8 == (void)v7;
            BOOL v7 = v8;
          }
          while (v9);
        }
        if ((sub_100046FE8(v8 + 4, v5 + 4) & 0x80) == 0)
        {
          xpc_object_t v10 = (uint64_t **)sub_100046ED4(a1, &v15, v5 + 4);
          goto LABEL_11;
        }
        if (!*v3)
        {
LABEL_14:
          xpc_object_t v15 = v3;
          xpc_object_t v10 = (uint64_t **)v3;
LABEL_15:
          memset(v14, 0, sizeof(v14));
          sub_1005B3CB8(v14, a1, (uint64_t)(v5 + 4));
          sub_100046C38((uint64_t **)a1, (uint64_t)v15, v10, v14[0]);
          v14[0] = 0;
          sub_1005B3D9C((uint64_t)v14, 0);
          goto LABEL_16;
        }
      }
      xpc_object_t v15 = v8;
      xpc_object_t v10 = (uint64_t **)(v8 + 1);
LABEL_11:
      if (!*v10) {
        goto LABEL_15;
      }
LABEL_16:
      xpc_object_t v11 = (void **)v5[1];
      if (v11)
      {
        do
        {
          uint64_t v12 = v11;
          xpc_object_t v11 = (void **)*v11;
        }
        while (v11);
      }
      else
      {
        do
        {
          uint64_t v12 = (void **)v5[2];
          BOOL v9 = *v12 == v5;
          uint64_t v5 = v12;
        }
        while (!v9);
      }
      uint64_t v5 = v12;
    }
    while (v12 != v4);
  }
  return a1;
}

void sub_1005B3CA0(_Unwind_Exception *a1)
{
  sub_1005B25E0(v1, *(void **)(v1 + 8));
  _Unwind_Resume(a1);
}

unsigned char *sub_1005B3CB8(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = a2 + 8;
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  uint64_t v6 = operator new(0x58uLL);
  BOOL v7 = v6;
  *a1 = v6;
  a1[1] = v5;
  *((unsigned char *)a1 + 16) = 0;
  if (*(char *)(a3 + 23) < 0)
  {
    sub_10004FC84(v6 + 32, *(void **)a3, *(void *)(a3 + 8));
  }
  else
  {
    *((_OWORD *)v6 + 2) = *(_OWORD *)a3;
    *((void *)v6 + 6) = *(void *)(a3 + 16);
  }
  *((_WORD *)v7 + 28) = *(_WORD *)(a3 + 24);
  __n128 result = v7 + 64;
  if (*(char *)(a3 + 55) < 0)
  {
    __n128 result = sub_10004FC84(result, *(void **)(a3 + 32), *(void *)(a3 + 40));
  }
  else
  {
    *(_OWORD *)__n128 result = *(_OWORD *)(a3 + 32);
    *((void *)v7 + 10) = *(void *)(a3 + 48);
  }
  *((unsigned char *)a1 + 16) = 1;
  return result;
}

void sub_1005B3D6C(_Unwind_Exception *a1)
{
  if (*(char *)(v2 + 55) < 0) {
    operator delete(*v3);
  }
  sub_1005B3D9C(v1, 0);
  _Unwind_Resume(a1);
}

void sub_1005B3D9C(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void **)a1;
  *(void *)a1 = a2;
  if (v2)
  {
    if (*(unsigned char *)(a1 + 16)) {
      sub_1002B2A44((uint64_t)v2 + 32);
    }
    operator delete(v2);
  }
}

uint64_t *sub_1005B3DF4(uint64_t *result)
{
  uint64_t v1 = *result;
  unsigned char *result = 0;
  if (v1)
  {
    sub_1005B25E0(v1 + 40, *(void **)(v1 + 48));
    uint64_t v2 = (void **)(v1 + 8);
    sub_10005CBF0(&v2);
    operator delete();
  }
  return result;
}

uint64_t *sub_1005B3E60(void *a1)
{
  long long v41 = a1;
  uint64_t v2 = (void *)*a1;
  uint64_t v45 = 0;
  long long v46 = 0;
  uint64_t v47 = 0;
  sub_1005B3B3C((uint64_t)&v45, a1 + 5);
  xpc_object_t v4 = (PersonalityInfo **)a1[1];
  xpc_object_t v3 = (PersonalityInfo **)a1[2];
  if (v4 == v3) {
    goto LABEL_61;
  }
  char v5 = 0;
  do
  {
    uint64_t v6 = *v4;
    if (*((unsigned __int8 *)*v4 + 49) <= 1u && *((unsigned char *)v6 + 48))
    {
      BOOL v7 = v2[4];
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
      {
        xpc_object_t v10 = (const char *)*((void *)v6 + 3);
        BOOL v9 = (char *)v6 + 24;
        xpc_object_t v8 = v10;
        uint64_t v11 = v9[23];
        int v12 = (char)v11;
        if ((v11 & 0x80u) != 0) {
          uint64_t v11 = *((void *)v9 + 1);
        }
        if (v12 >= 0) {
          xpc_object_t v8 = v9;
        }
        if (!v11) {
          xpc_object_t v8 = "<invalid>";
        }
        LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
        *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v8;
        _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Found active Personality: %s", (uint8_t *)&buf, 0xCu);
        uint64_t v6 = *v4;
      }
      long long v13 = sub_100046F68((uint64_t)&v45, (void **)v6 + 3);
      if (&v46 == (uint64_t **)v13)
      {
        BOOL v14 = *v4;
        uint64_t v15 = (uint64_t)*v4 + 24;
        *(void *)long long v48 = 0;
        long long v16 = (void ***)sub_100046ED4((uint64_t)&v45, v48, (void **)v15);
        long long v13 = *v16;
        if (!*v16)
        {
          buf.__r_.__value_.__r.__words[2] = 0;
          char v17 = (char *)operator new(0x58uLL);
          buf.__r_.__value_.__r.__words[0] = (std::string::size_type)v17;
          buf.__r_.__value_.__l.__size_ = (std::string::size_type)&v46;
          buf.__r_.__value_.__s.__data_[16] = 0;
          char v18 = v17 + 32;
          if (*((char *)v14 + 47) < 0)
          {
            sub_10004FC84(v18, *((void **)v14 + 3), *((void *)v14 + 4));
            xpc_object_t v20 = (uint64_t *)buf.__r_.__value_.__r.__words[0];
          }
          else
          {
            long long v19 = *(_OWORD *)v15;
            *((void *)v17 + 6) = *(void *)(v15 + 16);
            *(_OWORD *)char v18 = v19;
            xpc_object_t v20 = (uint64_t *)v17;
          }
          *((_WORD *)v17 + 28) = 0;
          *((void *)v17 + 9) = 0;
          *((void *)v17 + 10) = 0;
          *((void *)v17 + 8) = 0;
          buf.__r_.__value_.__s.__data_[16] = 1;
          uint64_t v21 = *(void *)v48;
          uint64_t *v20 = 0;
          v20[1] = 0;
          v20[2] = v21;
          *long long v16 = (void **)v20;
          if (*v45)
          {
            uint64_t v45 = (void *)*v45;
            xpc_object_t v20 = (uint64_t *)*v16;
          }
          sub_100046C90(v46, v20);
          ++v47;
          long long v13 = (void **)buf.__r_.__value_.__r.__words[0];
          buf.__r_.__value_.__r.__words[0] = 0;
          sub_1005B3D9C((uint64_t)&buf, 0);
        }
        char v5 = 1;
      }
      uint64_t v22 = v2[7];
      PersonalityInfo::uuid((uint64_t *)&v44, *v4);
      int v23 = (*(uint64_t (**)(uint64_t, const void **))(*(void *)v22 + 24))(v22, &v44);
      sub_10012577C(&v44);
      if (*((unsigned __int8 *)v13 + 56) != v23)
      {
        *((unsigned char *)v13 + 56) = v23;
        uint64_t v24 = v2[4];
        if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v25 = asString();
          LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
          *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = v25;
          _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "#I Transport method changed to %s", (uint8_t *)&buf, 0xCu);
        }
        char v5 = 1;
      }
      uint64_t v26 = v2[7];
      PersonalityInfo::uuid((uint64_t *)&v43, *v4);
      int v27 = (*(uint64_t (**)(uint64_t, const void **))(*(void *)v26 + 48))(v26, &v43);
      sub_10012577C(&v43);
      if (*((unsigned __int8 *)v13 + 57) != v27)
      {
        *((unsigned char *)v13 + 57) = v27;
        uint64_t v28 = v2[4];
        if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
        {
          int v29 = "false";
          if (v27) {
            int v29 = "true";
          }
          LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
          *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v29;
          _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "#I Incoming TTY calls switch enabled: %s", (uint8_t *)&buf, 0xCu);
        }
        char v5 = 1;
      }
      memset(&buf, 0, sizeof(buf));
      uint64_t v30 = v2[7];
      PersonalityInfo::uuid((uint64_t *)&v42, *v4);
      (*(void (**)(std::string *__return_ptr, uint64_t, const void **))(*(void *)v30 + 32))(&buf, v30, &v42);
      sub_10012577C(&v42);
      uint64_t v31 = *((unsigned __int8 *)v13 + 87);
      if ((v31 & 0x80u) == 0) {
        uint64_t v32 = (void *)*((unsigned __int8 *)v13 + 87);
      }
      else {
        uint64_t v32 = v13[9];
      }
      std::string::size_type size = HIBYTE(buf.__r_.__value_.__r.__words[2]);
      char v34 = HIBYTE(buf.__r_.__value_.__r.__words[2]);
      if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        std::string::size_type size = buf.__r_.__value_.__l.__size_;
      }
      if (v32 == (void *)size)
      {
        if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          p_std::string buf = &buf;
        }
        else {
          p_std::string buf = (std::string *)buf.__r_.__value_.__r.__words[0];
        }
        if ((v31 & 0x80) != 0)
        {
          if (!memcmp(v13[8], p_buf, (size_t)v13[9])) {
            goto LABEL_52;
          }
        }
        else
        {
          if (!*((unsigned char *)v13 + 87)) {
            goto LABEL_52;
          }
          int v36 = (unsigned __int8 *)(v13 + 8);
          while (*v36 == p_buf->__r_.__value_.__s.__data_[0])
          {
            ++v36;
            p_std::string buf = (std::string *)((char *)p_buf + 1);
            if (!--v31) {
              goto LABEL_52;
            }
          }
        }
      }
      std::string::operator=((std::string *)(v13 + 8), &buf);
      long long v37 = v2[4];
      if (!os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
      {
        char v5 = 1;
        if ((*((unsigned char *)&buf.__r_.__value_.__s + 23) & 0x80) == 0) {
          goto LABEL_53;
        }
        goto LABEL_56;
      }
      long long v38 = (std::string *)buf.__r_.__value_.__r.__words[0];
      if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        long long v38 = &buf;
      }
      *(_DWORD *)long long v48 = 136315138;
      *(void *)&v48[4] = v38;
      _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEFAULT, "#I Relay number changed to %s", v48, 0xCu);
      char v5 = 1;
      char v34 = HIBYTE(buf.__r_.__value_.__r.__words[2]);
LABEL_52:
      if ((v34 & 0x80) == 0) {
        goto LABEL_53;
      }
LABEL_56:
      operator delete(buf.__r_.__value_.__l.__data_);
    }
LABEL_53:
    v4 += 2;
  }
  while (v4 != v3);
  if (v5)
  {
    buf.__r_.__value_.__r.__words[0] = (std::string::size_type)v2;
    sub_1005B3B3C((uint64_t)&buf.__r_.__value_.__l.__size_, &v45);
    uint64_t v39 = (std::__shared_weak_count *)v2[1];
    if (v39)
    {
      if (std::__shared_weak_count::lock(v39)) {
        operator new();
      }
    }
    sub_100088B9C();
  }
LABEL_61:
  sub_1005B25E0((uint64_t)&v45, v46);
  return sub_1005B3DF4((uint64_t *)&v41);
}

void sub_1005B4434(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, int a12, __int16 a13, char a14, char a15, int a16, __int16 a17, char a18, char a19, int a20,__int16 a21,char a22,char a23,int a24,__int16 a25,char a26,char a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,void *__p,uint64_t a34,int a35,__int16 a36,char a37,char a38)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t *sub_1005B44D8(void **a1)
{
  uint64_t v1 = *a1;
  uint64_t v25 = a1;
  uint64_t v26 = v1;
  uint64_t v2 = (void *)*v1;
  xpc_object_t v3 = (unsigned __int8 **)(v1 + 1);
  if (*(void *)(*v1 + 176) == v1[3])
  {
    xpc_object_t v4 = (unsigned __int8 *)v2[20];
    if (v4 == (unsigned __int8 *)(v2 + 21)) {
      goto LABEL_46;
    }
    char v5 = *v3;
    while (sub_10001D294(v4 + 32, v5 + 32) && operator==())
    {
      uint64_t v6 = (unsigned __int8 *)*((void *)v4 + 1);
      BOOL v7 = v4;
      if (v6)
      {
        do
        {
          xpc_object_t v4 = v6;
          uint64_t v6 = *(unsigned __int8 **)v6;
        }
        while (v6);
      }
      else
      {
        do
        {
          xpc_object_t v4 = (unsigned __int8 *)*((void *)v7 + 2);
          BOOL v8 = *(void *)v4 == (void)v7;
          BOOL v7 = v4;
        }
        while (!v8);
      }
      BOOL v9 = (unsigned __int8 *)*((void *)v5 + 1);
      if (v9)
      {
        do
        {
          xpc_object_t v10 = v9;
          BOOL v9 = *(unsigned __int8 **)v9;
        }
        while (v9);
      }
      else
      {
        do
        {
          xpc_object_t v10 = (unsigned __int8 *)*((void *)v5 + 2);
          BOOL v8 = *(void *)v10 == (void)v5;
          char v5 = v10;
        }
        while (!v8);
      }
      char v5 = v10;
      if (v4 == (unsigned __int8 *)(v2 + 21)) {
        goto LABEL_46;
      }
    }
  }
  if (v2 + 20 != v3)
  {
    uint64_t v11 = (void *)v1[1];
    int v12 = v1 + 2;
    if (v2[22])
    {
      uint64_t v13 = v2[21];
      BOOL v14 = (void *)v2[20];
      v2[20] = v2 + 21;
      *(void *)(v13 + 16) = 0;
      v2[21] = 0;
      v2[22] = 0;
      if (v14[1]) {
        uint64_t v15 = (void *)v14[1];
      }
      else {
        uint64_t v15 = v14;
      }
      uint64_t v28 = v2 + 20;
      int v29 = v15;
      uint64_t v30 = v15;
      if (!v15 || (int v29 = sub_1000EA590((uint64_t)v15), v11 == v12))
      {
        long long v19 = v11;
      }
      else
      {
        do
        {
          std::string::operator=((std::string *)(v15 + 4), (const std::string *)(v11 + 4));
          *((_WORD *)v15 + 28) = *((_WORD *)v11 + 28);
          std::string::operator=((std::string *)(v15 + 8), (const std::string *)(v11 + 8));
          long long v16 = v30;
          uint64_t v27 = 0;
          char v17 = (uint64_t **)sub_1000EA518((uint64_t)(v2 + 20), &v27, v30 + 4);
          sub_100046C38((uint64_t **)v2 + 20, v27, v17, v16);
          uint64_t v15 = v29;
          uint64_t v30 = v29;
          if (v29) {
            int v29 = sub_1000EA590((uint64_t)v29);
          }
          char v18 = (void *)v11[1];
          if (v18)
          {
            do
            {
              long long v19 = v18;
              char v18 = (void *)*v18;
            }
            while (v18);
          }
          else
          {
            do
            {
              long long v19 = (void *)v11[2];
              BOOL v8 = *v19 == (void)v11;
              uint64_t v11 = v19;
            }
            while (!v8);
          }
          if (!v15) {
            break;
          }
          uint64_t v11 = v19;
        }
        while (v19 != v12);
      }
      sub_1005B4838((uint64_t)&v28);
      uint64_t v11 = v19;
    }
    if (v11 != v12)
    {
      do
      {
        uint64_t v28 = 0;
        int v29 = 0;
        uint64_t v30 = 0;
        sub_1005B3CB8(&v28, (uint64_t)(v2 + 20), (uint64_t)(v11 + 4));
        uint64_t v27 = 0;
        xpc_object_t v20 = (uint64_t **)sub_1000EA518((uint64_t)(v2 + 20), &v27, v28 + 4);
        sub_100046C38((uint64_t **)v2 + 20, v27, v20, v28);
        uint64_t v28 = 0;
        sub_1005B3D9C((uint64_t)&v28, 0);
        uint64_t v21 = (void *)v11[1];
        if (v21)
        {
          do
          {
            uint64_t v22 = v21;
            uint64_t v21 = (void *)*v21;
          }
          while (v21);
        }
        else
        {
          do
          {
            uint64_t v22 = (void *)v11[2];
            BOOL v8 = *v22 == (void)v11;
            uint64_t v11 = v22;
          }
          while (!v8);
        }
        uint64_t v11 = v22;
      }
      while (v22 != v12);
    }
  }
  uint64_t v23 = v2[19];
  if (v23) {
    (*(void (**)(uint64_t, void *))(*(void *)v23 + 48))(v23, v2 + 20);
  }
LABEL_46:
  sub_1005B47E4((uint64_t *)&v26);
  return sub_100046B58((uint64_t *)&v25);
}

void sub_1005B47B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

uint64_t *sub_1005B47E4(uint64_t *result)
{
  uint64_t v1 = *result;
  unsigned char *result = 0;
  if (v1)
  {
    sub_1005B25E0(v1 + 8, *(void **)(v1 + 16));
    operator delete();
  }
  return result;
}

uint64_t sub_1005B4838(uint64_t a1)
{
  sub_1005B25E0(*(void *)a1, *(void **)(a1 + 16));
  uint64_t v2 = *(void **)(a1 + 8);
  if (v2)
  {
    xpc_object_t v3 = (void *)v2[2];
    if (v3)
    {
      do
      {
        uint64_t v2 = v3;
        xpc_object_t v3 = (void *)v3[2];
      }
      while (v3);
      *(void *)(a1 + 8) = v2;
    }
    sub_1005B25E0(*(void *)a1, v2);
  }
  return a1;
}

uint64_t sub_1005B4890(uint64_t a1)
{
  if (*(unsigned char *)a1)
  {
    uint64_t v2 = *(void *)(a1 + 8);
    uint64_t v3 = *(void *)(v2 + 24);
    if (v3) {
      (*(void (**)(uint64_t, uint64_t))(*(void *)v3 + 48))(v3, v2 + 32);
    }
  }
  return a1;
}

void sub_1005B48F4()
{
}

void sub_1005B495C()
{
}

uint64_t sub_1005B4980(uint64_t a1, void *a2)
{
  xpc_object_t v4 = (ctu::OsLogLogger *)(a1 + 8);
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v7, kCtLoggingSystemName, "pp.push.mdl");
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v8, &v7);
  ctu::OsLogLogger::OsLogLogger(v4, (const ctu::OsLogLogger *)v8);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v8);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v7);
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  *(void *)a1 = off_1019EA5A0;
  *(void *)(a1 + 32) = *a2;
  uint64_t v5 = a2[1];
  *(void *)(a1 + 40) = v5;
  if (v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
  }
  *(void *)(a1 + 104) = 0;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 76) = 0u;
  *(void *)(a1 + 96) = a1 + 104;
  *(void *)(a1 + 112) = 0;
  *(void *)(a1 + 120) = 0;
  *(void *)(a1 + 128) = 0;
  *(void *)(a1 + 136) = 0;
  return a1;
}

void sub_1005B4A7C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v4 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)va1);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)va);
  ActivationPushModelInterface::~ActivationPushModelInterface(v2);
  _Unwind_Resume(a1);
}

void sub_1005B4AB0(uint64_t a1)
{
  *(void *)a1 = off_1019EA5A0;
  if (*(char *)(a1 + 143) < 0) {
    operator delete(*(void **)(a1 + 120));
  }
  sub_1000886C0(a1 + 96, *(char **)(a1 + 104));
  if (*(char *)(a1 + 87) < 0) {
    operator delete(*(void **)(a1 + 64));
  }
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 56);
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 40);
  if (v3) {
    sub_10004D2C8(v3);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 24);
  if (v4) {
    std::__shared_weak_count::__release_weak(v4);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 8));

  ActivationPushModelInterface::~ActivationPushModelInterface((ActivationPushModelInterface *)a1);
}

void sub_1005B4B5C(uint64_t a1)
{
  sub_1005B4AB0(a1);

  operator delete();
}

void sub_1005B4B94(uint64_t a1)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 32));
  uint64_t v3 = ServiceMap;
  if ((v4 & 0x8000000000000000) != 0)
  {
    uint64_t v5 = (unsigned __int8 *)(v4 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v6 = 5381;
    do
    {
      unint64_t v4 = v6;
      unsigned int v7 = *v5++;
      uint64_t v6 = (33 * v6) ^ v7;
    }
    while (v7);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v12 = v4;
  BOOL v8 = sub_10004D37C(&v3[1].__m_.__sig, &v12);
  if (v8)
  {
    uint64_t v10 = v8[3];
    BOOL v9 = (std::__shared_weak_count *)v8[4];
    if (v9)
    {
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v3);
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v9);
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v10 = 0;
  }
  std::mutex::unlock(v3);
  BOOL v9 = 0;
LABEL_9:
  uint64_t v11 = *(std::__shared_weak_count **)(a1 + 56);
  *(void *)(a1 + 48) = v10;
  *(void *)(a1 + 56) = v9;
  if (v11) {
    sub_10004D2C8(v11);
  }
}

BOOL sub_1005B4C70(uint64_t a1)
{
  return *(_DWORD *)(a1 + 88) == 2;
}

uint64_t sub_1005B4C80(uint64_t a1, uint64_t a2)
{
  CFStringRef v18 = 0;
  (*(void (**)(uint8_t *__return_ptr))(**(void **)(a1 + 48) + 40))(buf);
  sub_100056248(&v18, (CFTypeRef *)buf);
  sub_1000577C4((const void **)buf);
  CFStringRef v4 = v18;
  if (v18) {
    uint64_t v5 = sub_1000810B8;
  }
  else {
    uint64_t v5 = 0;
  }
  if (!v5)
  {
    uint64_t v6 = *(NSObject **)(a1 + 8);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Persisted token not found", buf, 2u);
    }
    goto LABEL_24;
  }
  if (*(char *)(a2 + 23) < 0)
  {
    sub_10004FC84(v15, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)uint64_t v15 = *(_OWORD *)a2;
    uint64_t v16 = *(void *)(a2 + 16);
  }
  if (SHIBYTE(v16) < 0)
  {
    sub_10004FC84(__p, v15[0], (unint64_t)v15[1]);
  }
  else
  {
    *(_OWORD *)__n128 __p = *(_OWORD *)v15;
    uint64_t v21 = v16;
  }
  CFStringRef v19 = 0;
  if (SHIBYTE(v21) < 0)
  {
    sub_10004FC84(buf, __p[0], (unint64_t)__p[1]);
  }
  else
  {
    *(_OWORD *)std::string buf = *(_OWORD *)__p;
    uint64_t v23 = v21;
  }
  CFStringRef v24 = 0;
  if (ctu::cf::convert_copy())
  {
    CFStringRef v7 = v19;
    CFStringRef v19 = v24;
    CFStringRef v25 = v7;
    sub_1000558F4((const void **)&v25);
  }
  if (SHIBYTE(v23) < 0) {
    operator delete(*(void **)buf);
  }
  CFStringRef v8 = v19;
  CFStringRef v17 = v19;
  CFStringRef v19 = 0;
  sub_1000558F4((const void **)&v19);
  if (SHIBYTE(v21) < 0) {
    operator delete(__p[0]);
  }
  CFComparisonResult v9 = CFStringCompare(v4, v8, 1uLL);
  sub_1000558F4((const void **)&v17);
  if (SHIBYTE(v16) < 0)
  {
    operator delete(v15[0]);
    if (v9) {
      goto LABEL_24;
    }
  }
  else if (v9)
  {
LABEL_24:
    sub_1000558F4((const void **)&v18);
    if (*(_DWORD *)(a1 + 88) != 1)
    {
      std::string::operator=((std::string *)(a1 + 64), (const std::string *)a2);
      uint64_t result = 1;
      *(_DWORD *)(a1 + 88) = 1;
      return result;
    }
    uint64_t v10 = *(NSObject **)(a1 + 8);
    BOOL v11 = os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT);
    uint64_t result = 0;
    if (!v11) {
      return result;
    }
    *(_WORD *)std::string buf = 0;
    uint64_t v13 = "#I Push Token registration ongoing. ignore";
    goto LABEL_31;
  }
  *(_DWORD *)(a1 + 88) = 2;
  std::string::operator=((std::string *)(a1 + 64), (const std::string *)a2);
  sub_1000558F4((const void **)&v18);
  uint64_t v10 = *(NSObject **)(a1 + 8);
  BOOL v14 = os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT);
  uint64_t result = 0;
  if (!v14) {
    return result;
  }
  *(_WORD *)std::string buf = 0;
  uint64_t v13 = "#I Token has not changed, aborting";
LABEL_31:
  _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, v13, buf, 2u);
  return 0;
}

void sub_1005B4F6C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15, int a16, const void *a17, __int16 a18, char a19, char a20,void *__p,uint64_t a22,int a23,__int16 a24,char a25,char a26,uint64_t a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33)
{
}

const void **sub_1005B4FF4(uint64_t a1)
{
  (*(void (**)(void, const __CFString *, void, void, const CFStringRef, const CFStringRef))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), @"kPostponementActivationPushTokenRegFailedTimeStamp", 0, kCommCenterPreferencesNoBackupAppID, kCFPreferencesCurrentUser, kCFPreferencesAnyHost);

  return sub_1005B5084(a1, 0);
}

const void **sub_1005B5084(uint64_t a1, int a2)
{
  int valuePtr = a2;
  CFNumberRef v4 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, &valuePtr);
  (*(void (**)(void, const __CFString *, CFNumberRef, void, const CFStringRef, const CFStringRef))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), @"kPostponementActivationPushTokenRegRetryCount", v4, kCommCenterPreferencesNoBackupAppID, kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
  return sub_1000570E8((const void **)&v4);
}

void sub_1005B512C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9)
{
}

uint64_t sub_1005B5140(uint64_t a1)
{
  uint64_t v6 = 0;
  (*(void (**)(const void **__return_ptr))(**(void **)(a1 + 48) + 40))(&v5);
  sub_1000842D0(&v6, &v5);
  sub_1000577C4(&v5);
  if (v6) {
    uint64_t v2 = sub_100081E58;
  }
  else {
    uint64_t v2 = 0;
  }
  if (v2)
  {
    LODWORD(v5) = 0;
    ctu::cf::assign((ctu::cf *)&v5, v6, v1);
    uint64_t v3 = v5;
  }
  else
  {
    uint64_t v3 = 0;
  }
  sub_1000570E8((const void **)&v6);
  return v3;
}

void sub_1005B5218(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000570E8((const void **)va);
  _Unwind_Resume(a1);
}

const void **sub_1005B523C(void **a1)
{
  CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
  CFDateRef date = CFDateCreate(kCFAllocatorDefault, Current);
  CFLocaleRef v7 = CFLocaleCopyCurrent();
  uint64_t v6 = CFDateFormatterCreate(kCFAllocatorDefault, v7, kCFDateFormatterFullStyle, kCFDateFormatterFullStyle);
  CFStringRef StringWithDate = CFDateFormatterCreateStringWithDate(kCFAllocatorDefault, v6, date);
  (*(void (**)(void *, const __CFString *, CFStringRef, void, const CFStringRef, const CFStringRef))(*a1[6] + 16))(a1[6], @"kPostponementActivationPushTokenRegFailedTimeStamp", StringWithDate, kCommCenterPreferencesNoBackupAppID, kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
  int v3 = ((uint64_t (*)(void **))(*a1)[6])(a1);
  sub_1005B5084((uint64_t)a1, v3 + 1);
  sub_1000558F4((const void **)&StringWithDate);
  sub_100201E7C((const void **)&v6);
  sub_100201EB0((const void **)&v7);
  return sub_10007CA64((const void **)&date);
}

void sub_1005B5360(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, const void *a10, const void *a11, const void *a12)
{
}

uint64_t sub_1005B53A8(uint64_t a1)
{
  CFLocaleRef v11 = CFLocaleCopyCurrent();
  CFStringRef string = 0;
  CFDateFormatterRef formatter = CFDateFormatterCreate(kCFAllocatorDefault, v11, kCFDateFormatterFullStyle, kCFDateFormatterFullStyle);
  (*(void (**)(const void **__return_ptr))(**(void **)(a1 + 48) + 40))(&v7);
  sub_100056248(&v8, &v7);
  CFDateRef DateFromString = (const __CFDate *)string;
  CFStringRef v2 = (const __CFString *)v8;
  CFDateRef v8 = 0;
  CFStringRef string = v2;
  sub_1000558F4((const void **)&DateFromString);
  sub_1000558F4((const void **)&v8);
  sub_1000577C4(&v7);
  if (string) {
    int v3 = sub_1000810B8;
  }
  else {
    int v3 = 0;
  }
  if (v3)
  {
    CFDateRef DateFromString = CFDateFormatterCreateDateFromString(kCFAllocatorDefault, formatter, string, 0);
    CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
    CFDateRef v8 = CFDateCreate(kCFAllocatorDefault, Current);
    uint64_t TimeIntervalSinceDate = (uint64_t)CFDateGetTimeIntervalSinceDate(v8, DateFromString);
    sub_10007CA64((const void **)&v8);
    sub_10007CA64((const void **)&DateFromString);
  }
  else
  {
    uint64_t TimeIntervalSinceDate = 0;
  }
  sub_1000558F4((const void **)&string);
  sub_100201E7C((const void **)&formatter);
  sub_100201EB0((const void **)&v11);
  return TimeIntervalSinceDate;
}

void sub_1005B5510(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va3, a2);
  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  CFNumberRef v4 = va_arg(va1, const void *);
  va_copy(va2, va1);
  uint64_t v6 = va_arg(va2, const void *);
  va_copy(va3, va2);
  CFDateRef v8 = va_arg(va3, const void *);
  sub_10007CA64((const void **)va);
  sub_10007CA64((const void **)(v2 - 24));
  sub_1000558F4((const void **)va1);
  sub_100201E7C((const void **)va2);
  sub_100201EB0((const void **)va3);
  _Unwind_Resume(a1);
}

void sub_1005B5570(uint64_t a1, char a2)
{
  if (*(char *)(a1 + 87) < 0)
  {
    if (*(void *)(a1 + 72))
    {
LABEL_3:
      if (a2)
      {
        int v3 = (const char *)(a1 + 64);
        if ((*(unsigned char *)(a1 + 87) & 0x80) != 0) {
          int v3 = *(const char **)v3;
        }
        CFStringRef v8 = CFStringCreateWithCString(kCFAllocatorDefault, v3, 0x8000100u);
        (*(void (**)(void, const __CFString *, CFStringRef, void, const CFStringRef, const CFStringRef))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), @"kPostponementActivationPushToken", v8, kCommCenterPreferencesNoBackupAppID, kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
        *(_DWORD *)(a1 + 88) = 2;
        CFNumberRef v4 = *(NSObject **)(a1 + 8);
        if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)CFLocaleRef v7 = 0;
          _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Activation push token registration completed. Push token saved", v7, 2u);
        }
        sub_1000558F4((const void **)&v8);
      }
      else
      {
        *(_DWORD *)(a1 + 88) = 3;
        uint64_t v6 = *(NSObject **)(a1 + 8);
        if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)CFComparisonResult v9 = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "Push token registration failed", v9, 2u);
        }
      }
      return;
    }
  }
  else if (*(unsigned char *)(a1 + 87))
  {
    goto LABEL_3;
  }
  uint64_t v5 = *(NSObject **)(a1 + 8);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Empty push token, skip saving", buf, 2u);
  }
}

void sub_1005B5710(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000558F4((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t **sub_1005B5724(uint64_t a1, uint64_t **a2)
{
  uint64_t result = (uint64_t **)(a1 + 96);
  if (result != a2) {
    return sub_100429B2C(result, *a2, a2 + 1);
  }
  return result;
}

std::string *sub_1005B5740(std::string *a1, const std::string *a2)
{
  return std::string::operator=(a1 + 5, a2);
}

BOOL sub_1005B5748(uint64_t a1, CFDictionaryRef *a2, uint64_t a3)
{
  if (*a2) {
    CFNumberRef v4 = sub_100080778;
  }
  else {
    CFNumberRef v4 = 0;
  }
  if (!v4) {
    return 0;
  }
  Value = CFDictionaryGetValue(*a2, @"PushTokenRegistration");
  if (Value && (CFLocaleRef v7 = Value, v8 = CFGetTypeID(Value), v8 == CFDictionaryGetTypeID()))
  {
    xpc_object_t v20 = v7;
    CFRetain(v7);
  }
  else
  {
    CFLocaleRef v7 = 0;
    xpc_object_t v20 = 0;
  }
  if (v7) {
    CFComparisonResult v9 = sub_100080778;
  }
  else {
    CFComparisonResult v9 = 0;
  }
  if (v9)
  {
    uint64_t v10 = CFDictionaryGetValue((CFDictionaryRef)v7, @"errorKey");
    CFLocaleRef v11 = v10;
    if (v10 && (CFTypeID v12 = CFGetTypeID(v10), v12 == CFStringGetTypeID()))
    {
      CFStringRef v19 = v11;
      CFRetain(v11);
    }
    else
    {
      CFLocaleRef v11 = 0;
      CFStringRef v19 = 0;
    }
    if (v11) {
      BOOL v14 = sub_1000810B8;
    }
    else {
      BOOL v14 = 0;
    }
    BOOL v13 = v14 != 0;
    if (v14)
    {
      *(void *)std::string buf = 0;
      uint64_t v22 = 0;
      uint64_t v23 = 0;
      ctu::cf::assign();
      v24[0] = 0;
      *(void *)((char *)v24 + 7) = 0;
      if (*(char *)(a3 + 23) < 0) {
        operator delete(*(void **)a3);
      }
      uint64_t v15 = v24[0];
      *(void *)a3 = 0;
      *(void *)(a3 + 8) = v15;
      *(void *)(a3 + 15) = *(void *)((char *)v24 + 7);
      *(unsigned char *)(a3 + 23) = 0;
    }
    else
    {
      CFStringRef v17 = *(NSObject **)(a1 + 8);
      if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I errorKey not found in activation push token registration response", buf, 2u);
      }
    }
    sub_1000558F4(&v19);
  }
  else
  {
    uint64_t v16 = *(NSObject **)(a1 + 8);
    BOOL v13 = 0;
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I null response during activation push token registration", buf, 2u);
      BOOL v13 = 0;
    }
  }
  sub_100057D78(&v20);
  return v13;
}

void sub_1005B5980(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_1005B59C8(uint64_t a1@<X0>, void *a2@<X8>)
{
  long long __dst = 0uLL;
  uint64_t v80 = 0;
  if (*(char *)(a1 + 87) < 0)
  {
    sub_10004FC84(&__dst, *(void **)(a1 + 64), *(void *)(a1 + 72));
  }
  else
  {
    long long __dst = *(_OWORD *)(a1 + 64);
    uint64_t v80 = *(void *)(a1 + 80);
  }
  uint64_t v4 = HIBYTE(v80);
  char v5 = HIBYTE(v80);
  if (v80 < 0) {
    uint64_t v4 = *((void *)&__dst + 1);
  }
  if (v4)
  {
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    int v78 = Mutable;
    if (SHIBYTE(v80) < 0)
    {
      sub_10004FC84(&v76, (void *)__dst, *((unint64_t *)&__dst + 1));
    }
    else
    {
      long long v76 = __dst;
      uint64_t v77 = v80;
    }
    if (SHIBYTE(v77) < 0)
    {
      sub_10004FC84(buf, (void *)v76, *((unint64_t *)&v76 + 1));
    }
    else
    {
      *(_OWORD *)std::string buf = v76;
      uint64_t v83 = v77;
    }
    v60[0] = 0;
    if (SHIBYTE(v83) < 0)
    {
      sub_10004FC84(v84, *(void **)buf, *(unint64_t *)&buf[8]);
    }
    else
    {
      *(_OWORD *)long long v84 = *(_OWORD *)buf;
      uint64_t v85 = v83;
    }
    v64[0] = 0;
    if (ctu::cf::convert_copy())
    {
      CFLocaleRef v7 = v60[0];
      v60[0] = v64[0];
      __src[0] = v7;
      sub_1000558F4((const void **)__src);
    }
    if (SHIBYTE(v85) < 0) {
      operator delete(*(void **)v84);
    }
    uint64_t v87 = v60[0];
    v60[0] = 0;
    sub_1000558F4((const void **)v60);
    if (SHIBYTE(v83) < 0) {
      operator delete(*(void **)buf);
    }
    CFDictionarySetValue(Mutable, @"PushToken", v87);
    sub_1000558F4(&v87);
    if (SHIBYTE(v77) < 0) {
      operator delete((void *)v76);
    }
    ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 32));
    CFComparisonResult v9 = ServiceMap;
    if (v10 < 0)
    {
      CFLocaleRef v11 = (unsigned __int8 *)(v10 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v12 = 5381;
      do
      {
        uint64_t v10 = v12;
        unsigned int v13 = *v11++;
        uint64_t v12 = (33 * v12) ^ v13;
      }
      while (v13);
    }
    std::mutex::lock(ServiceMap);
    *(void *)long long v84 = v10;
    BOOL v14 = sub_10004D37C(&v9[1].__m_.__sig, (unint64_t *)v84);
    if (v14)
    {
      uint64_t v16 = v14[3];
      uint64_t v15 = (std::__shared_weak_count *)v14[4];
      if (v15)
      {
        atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v9);
        atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v15);
        char v17 = 0;
        goto LABEL_34;
      }
    }
    else
    {
      uint64_t v16 = 0;
    }
    std::mutex::unlock(v9);
    uint64_t v15 = 0;
    char v17 = 1;
LABEL_34:
    *(void *)long long v84 = 0;
    (*(void (**)(uint8_t *__return_ptr, uint64_t))(*(void *)v16 + 96))(v84, v16);
    if (*(void *)v84) {
      CFStringRef v18 = sub_1000810B8;
    }
    else {
      CFStringRef v18 = 0;
    }
    if (v18)
    {
      CFDictionarySetValue(v78, @"SerialNumber", *(const void **)v84);
    }
    else
    {
      CFStringRef v19 = *(NSObject **)(a1 + 8);
      if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#E Serial Number read failure during generating activation push token registration request", buf, 2u);
      }
    }
    sub_1000558F4((const void **)v84);
    uint64_t v21 = (uint64_t *)(a1 + 104);
    uint64_t v20 = *(void *)(a1 + 104);
    if (v20)
    {
      uint64_t v22 = a1 + 104;
      uint64_t v23 = *(void *)(a1 + 104);
      do
      {
        int v24 = *(_DWORD *)(v23 + 32);
        BOOL v25 = v24 < 1;
        if (v24 >= 1) {
          uint64_t v26 = (uint64_t *)v23;
        }
        else {
          uint64_t v26 = (uint64_t *)(v23 + 8);
        }
        if (!v25) {
          uint64_t v22 = v23;
        }
        uint64_t v23 = *v26;
      }
      while (*v26);
      if ((uint64_t *)v22 != v21 && *(int *)(v22 + 32) <= 1)
      {
        uint64_t v27 = v78;
        if (*(char *)(v22 + 63) < 0)
        {
          sub_10004FC84(__p, *(void **)(v22 + 40), *(void *)(v22 + 48));
        }
        else
        {
          *(_OWORD *)__n128 __p = *(_OWORD *)(v22 + 40);
          uint64_t v75 = *(void *)(v22 + 56);
        }
        if (SHIBYTE(v75) < 0)
        {
          sub_10004FC84(buf, __p[0], (unint64_t)__p[1]);
        }
        else
        {
          *(_OWORD *)std::string buf = *(_OWORD *)__p;
          uint64_t v83 = v75;
        }
        v60[0] = 0;
        if (SHIBYTE(v83) < 0)
        {
          sub_10004FC84(v84, *(void **)buf, *(unint64_t *)&buf[8]);
        }
        else
        {
          *(_OWORD *)long long v84 = *(_OWORD *)buf;
          uint64_t v85 = v83;
        }
        v64[0] = 0;
        if (ctu::cf::convert_copy())
        {
          uint64_t v28 = v60[0];
          v60[0] = v64[0];
          __src[0] = v28;
          sub_1000558F4((const void **)__src);
        }
        int v29 = (const void *)kCTPostponementInfoIMEI;
        if (SHIBYTE(v85) < 0) {
          operator delete(*(void **)v84);
        }
        uint64_t v87 = v60[0];
        v60[0] = 0;
        sub_1000558F4((const void **)v60);
        if (SHIBYTE(v83) < 0) {
          operator delete(*(void **)buf);
        }
        CFDictionarySetValue(v27, v29, v87);
        sub_1000558F4(&v87);
        if (SHIBYTE(v75) < 0) {
          operator delete(__p[0]);
        }
        uint64_t v20 = *v21;
      }
      if (v20)
      {
        uint64_t v30 = a1 + 104;
        do
        {
          int v31 = *(_DWORD *)(v20 + 32);
          BOOL v32 = v31 < 2;
          if (v31 >= 2) {
            unint64_t v33 = (uint64_t *)v20;
          }
          else {
            unint64_t v33 = (uint64_t *)(v20 + 8);
          }
          if (!v32) {
            uint64_t v30 = v20;
          }
          uint64_t v20 = *v33;
        }
        while (*v33);
        if ((uint64_t *)v30 != v21 && *(int *)(v30 + 32) <= 2)
        {
          char v34 = v78;
          if (*(char *)(v30 + 63) < 0)
          {
            sub_10004FC84(v72, *(void **)(v30 + 40), *(void *)(v30 + 48));
          }
          else
          {
            *(_OWORD *)uint64_t v72 = *(_OWORD *)(v30 + 40);
            uint64_t v73 = *(void *)(v30 + 56);
          }
          if (SHIBYTE(v73) < 0)
          {
            sub_10004FC84(buf, v72[0], (unint64_t)v72[1]);
          }
          else
          {
            *(_OWORD *)std::string buf = *(_OWORD *)v72;
            uint64_t v83 = v73;
          }
          v60[0] = 0;
          if (SHIBYTE(v83) < 0)
          {
            sub_10004FC84(v84, *(void **)buf, *(unint64_t *)&buf[8]);
          }
          else
          {
            *(_OWORD *)long long v84 = *(_OWORD *)buf;
            uint64_t v85 = v83;
          }
          v64[0] = 0;
          if (ctu::cf::convert_copy())
          {
            int v35 = v60[0];
            v60[0] = v64[0];
            __src[0] = v35;
            sub_1000558F4((const void **)__src);
          }
          int v36 = (const void *)kCTPostponementInfoSim2IMEI;
          if (SHIBYTE(v85) < 0) {
            operator delete(*(void **)v84);
          }
          uint64_t v87 = v60[0];
          v60[0] = 0;
          sub_1000558F4((const void **)v60);
          if (SHIBYTE(v83) < 0) {
            operator delete(*(void **)buf);
          }
          CFDictionarySetValue(v34, v36, v87);
          sub_1000558F4(&v87);
          if (SHIBYTE(v73) < 0) {
            operator delete(v72[0]);
          }
        }
      }
    }
    long long v37 = (void **)(a1 + 120);
    if (*(char *)(a1 + 143) < 0)
    {
      unint64_t v40 = *(void *)(a1 + 128);
      if (v40)
      {
        long long v38 = v78;
        sub_10004FC84(v70, *v37, v40);
        uint64_t v39 = (const void *)kCTPostponementInfoMEID;
        goto LABEL_101;
      }
    }
    else if (*(unsigned char *)(a1 + 143))
    {
      long long v38 = v78;
      uint64_t v39 = (const void *)kCTPostponementInfoMEID;
      *(_OWORD *)uint64_t v70 = *(_OWORD *)v37;
      uint64_t v71 = *(void *)(a1 + 136);
LABEL_101:
      if (SHIBYTE(v71) < 0)
      {
        sub_10004FC84(buf, v70[0], (unint64_t)v70[1]);
      }
      else
      {
        *(_OWORD *)std::string buf = *(_OWORD *)v70;
        uint64_t v83 = v71;
      }
      v60[0] = 0;
      if (SHIBYTE(v83) < 0)
      {
        sub_10004FC84(v84, *(void **)buf, *(unint64_t *)&buf[8]);
      }
      else
      {
        *(_OWORD *)long long v84 = *(_OWORD *)buf;
        uint64_t v85 = v83;
      }
      v64[0] = 0;
      if (ctu::cf::convert_copy())
      {
        long long v42 = v60[0];
        v60[0] = v64[0];
        __src[0] = v42;
        sub_1000558F4((const void **)__src);
      }
      if (SHIBYTE(v85) < 0) {
        operator delete(*(void **)v84);
      }
      uint64_t v87 = v60[0];
      v60[0] = 0;
      sub_1000558F4((const void **)v60);
      if (SHIBYTE(v83) < 0) {
        operator delete(*(void **)buf);
      }
      CFDictionarySetValue(v38, v39, v87);
      sub_1000558F4(&v87);
      if (SHIBYTE(v71) < 0) {
        operator delete(v70[0]);
      }
      goto LABEL_117;
    }
    long long v41 = *(NSObject **)(a1 + 8);
    if (os_log_type_enabled(v41, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long v84 = 0;
      _os_log_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_DEFAULT, "#E MEID not valid during generating activation push token registration request", v84, 2u);
    }
LABEL_117:
    *(void *)long long v84 = 0;
    (*(void (**)(uint8_t *__return_ptr, uint64_t))(*(void *)v16 + 104))(v84, v16);
    if (*(void *)v84) {
      long long v43 = sub_1000810B8;
    }
    else {
      long long v43 = 0;
    }
    if (v43)
    {
      CFDictionarySetValue(v78, @"UniqueDeviceID", *(const void **)v84);
    }
    else
    {
      uint64_t v44 = *(NSObject **)(a1 + 8);
      if (os_log_type_enabled(v44, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_DEFAULT, "#E UniqueDeviceID (UDID) not valid during generating activation push token registration request", buf, 2u);
      }
    }
    sub_1000558F4((const void **)v84);
    __src[0] = 0;
    __src[1] = 0;
    uint64_t v69 = 0;
    (*(void (**)(void **__return_ptr, uint64_t))(*(void *)v16 + 200))(__src, v16);
    if (SHIBYTE(v69) < 0)
    {
      if (__src[1])
      {
        uint64_t v45 = v78;
        sub_10004FC84(v66, __src[0], (unint64_t)__src[1]);
        goto LABEL_129;
      }
    }
    else if (HIBYTE(v69))
    {
      uint64_t v45 = v78;
      *(_OWORD *)uint64_t v66 = *(_OWORD *)__src;
      uint64_t v67 = v69;
LABEL_129:
      if (SHIBYTE(v67) < 0)
      {
        sub_10004FC84(buf, v66[0], (unint64_t)v66[1]);
      }
      else
      {
        *(_OWORD *)std::string buf = *(_OWORD *)v66;
        uint64_t v83 = v67;
      }
      uint64_t v87 = 0;
      if (SHIBYTE(v83) < 0)
      {
        sub_10004FC84(v84, *(void **)buf, *(unint64_t *)&buf[8]);
      }
      else
      {
        *(_OWORD *)long long v84 = *(_OWORD *)buf;
        uint64_t v85 = v83;
      }
      v60[0] = 0;
      if (ctu::cf::convert_copy())
      {
        uint64_t v47 = (void *)v87;
        uint64_t v87 = v60[0];
        v64[0] = v47;
        sub_1000558F4((const void **)v64);
      }
      if (SHIBYTE(v85) < 0) {
        operator delete(*(void **)v84);
      }
      uint64_t v86 = v87;
      uint64_t v87 = 0;
      sub_1000558F4(&v87);
      if (SHIBYTE(v83) < 0) {
        operator delete(*(void **)buf);
      }
      CFDictionarySetValue(v45, @"ProductType", v86);
      sub_1000558F4(&v86);
      if (SHIBYTE(v67) < 0) {
        operator delete(v66[0]);
      }
      goto LABEL_145;
    }
    long long v46 = *(NSObject **)(a1 + 8);
    if (os_log_type_enabled(v46, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long v84 = 0;
      _os_log_impl((void *)&_mh_execute_header, v46, OS_LOG_TYPE_DEFAULT, "#E ProductType not valid, skipping during generating activation push token registration request", v84, 2u);
    }
LABEL_145:
    v64[0] = 0;
    v64[1] = 0;
    uint64_t v65 = 0;
    (*(void (**)(void **__return_ptr, uint64_t))(*(void *)v16 + 208))(v64, v16);
    if (SHIBYTE(v65) < 0)
    {
      if (v64[1])
      {
        long long v48 = v78;
        sub_10004FC84(v62, v64[0], (unint64_t)v64[1]);
        goto LABEL_150;
      }
    }
    else if (HIBYTE(v65))
    {
      long long v48 = v78;
      *(_OWORD *)uint64_t v62 = *(_OWORD *)v64;
      uint64_t v63 = v65;
LABEL_150:
      if (SHIBYTE(v63) < 0)
      {
        sub_10004FC84(buf, v62[0], (unint64_t)v62[1]);
      }
      else
      {
        *(_OWORD *)std::string buf = *(_OWORD *)v62;
        uint64_t v83 = v63;
      }
      uint64_t v86 = 0;
      if (SHIBYTE(v83) < 0)
      {
        sub_10004FC84(v84, *(void **)buf, *(unint64_t *)&buf[8]);
      }
      else
      {
        *(_OWORD *)long long v84 = *(_OWORD *)buf;
        uint64_t v85 = v83;
      }
      uint64_t v87 = 0;
      if (ctu::cf::convert_copy())
      {
        uint64_t v50 = (void *)v86;
        uint64_t v86 = v87;
        v60[0] = v50;
        sub_1000558F4((const void **)v60);
      }
      if (SHIBYTE(v85) < 0) {
        operator delete(*(void **)v84);
      }
      long long v81 = (void *)v86;
      uint64_t v86 = 0;
      sub_1000558F4(&v86);
      if (SHIBYTE(v83) < 0) {
        operator delete(*(void **)buf);
      }
      CFDictionarySetValue(v48, @"BuildVersion", v81);
      sub_1000558F4((const void **)&v81);
      if (SHIBYTE(v63) < 0) {
        operator delete(v62[0]);
      }
      goto LABEL_166;
    }
    uint64_t v49 = *(NSObject **)(a1 + 8);
    if (os_log_type_enabled(v49, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long v84 = 0;
      _os_log_impl((void *)&_mh_execute_header, v49, OS_LOG_TYPE_DEFAULT, "#E BuildVersion not valid during generating activation push token registration request", v84, 2u);
    }
LABEL_166:
    v60[0] = 0;
    v60[1] = 0;
    uint64_t v61 = 0;
    (*(void (**)(void **__return_ptr, uint64_t))(*(void *)v16 + 216))(v60, v16);
    if (SHIBYTE(v61) < 0)
    {
      if (v60[1])
      {
        uint64_t v51 = v78;
        sub_10004FC84(v57, v60[0], (unint64_t)v60[1]);
        goto LABEL_171;
      }
    }
    else if (HIBYTE(v61))
    {
      uint64_t v51 = v78;
      *(_OWORD *)uint64_t v57 = *(_OWORD *)v60;
      uint64_t v58 = v61;
LABEL_171:
      if (SHIBYTE(v58) < 0)
      {
        sub_10004FC84(buf, v57[0], (unint64_t)v57[1]);
      }
      else
      {
        *(_OWORD *)std::string buf = *(_OWORD *)v57;
        uint64_t v83 = v58;
      }
      long long v81 = 0;
      if (SHIBYTE(v83) < 0)
      {
        sub_10004FC84(v84, *(void **)buf, *(unint64_t *)&buf[8]);
      }
      else
      {
        *(_OWORD *)long long v84 = *(_OWORD *)buf;
        uint64_t v85 = v83;
      }
      uint64_t v86 = 0;
      if (ctu::cf::convert_copy())
      {
        uint64_t v53 = v81;
        long long v81 = (void *)v86;
        uint64_t v87 = v53;
        sub_1000558F4(&v87);
      }
      if (SHIBYTE(v85) < 0) {
        operator delete(*(void **)v84);
      }
      value = v81;
      long long v81 = 0;
      sub_1000558F4((const void **)&v81);
      if (SHIBYTE(v83) < 0) {
        operator delete(*(void **)buf);
      }
      CFDictionarySetValue(v51, @"ProductVersion", value);
      sub_1000558F4((const void **)&value);
      if (SHIBYTE(v58) < 0) {
        operator delete(v57[0]);
      }
      goto LABEL_187;
    }
    uint64_t v52 = *(NSObject **)(a1 + 8);
    if (os_log_type_enabled(v52, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long v84 = 0;
      _os_log_impl((void *)&_mh_execute_header, v52, OS_LOG_TYPE_DEFAULT, "#E ProductVersion not valid during generating activation push token registration request", v84, 2u);
    }
LABEL_187:
    *(void *)long long v84 = 0;
    *(void *)long long v84 = CFPropertyListCreateData(0, v78, kCFPropertyListXMLFormat_v1_0, 0, 0);
    BytePtr = CFDataGetBytePtr(*(CFDataRef *)v84);
    size_t Length = CFDataGetLength(*(CFDataRef *)v84);
    uint64_t v56 = operator new(0x30uLL);
    v56[1] = 0;
    v56[2] = 0;
    *uint64_t v56 = off_1019B47B8;
    v56[3] = 0;
    v56[4] = 0;
    v56[5] = 0;
    sub_1001E7940(v56 + 3, BytePtr, (uint64_t)&BytePtr[Length], Length);
    *a2 = v56 + 3;
    a2[1] = v56;
    sub_100030068((const void **)v84);
    if (SHIBYTE(v61) < 0) {
      operator delete(v60[0]);
    }
    if (SHIBYTE(v65) < 0) {
      operator delete(v64[0]);
    }
    if (SHIBYTE(v69) < 0)
    {
      operator delete(__src[0]);
      if (v17)
      {
LABEL_194:
        sub_10005717C((const void **)&v78);
        if ((v80 & 0x8000000000000000) == 0) {
          return;
        }
        goto LABEL_195;
      }
    }
    else if (v17)
    {
      goto LABEL_194;
    }
    sub_10004D2C8(v15);
    goto LABEL_194;
  }
  *a2 = 0;
  a2[1] = 0;
  if ((v5 & 0x80) == 0) {
    return;
  }
LABEL_195:
  operator delete((void *)__dst);
}

void sub_1005B6798(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,void *a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,void *__p,uint64_t a34,int a35,__int16 a36,char a37,char a38)
{
  sub_1000558F4((const void **)&a14);
  if (*(char *)(v40 - 137) < 0) {
    operator delete(*(void **)(v40 - 160));
  }
  if (a38 < 0) {
    operator delete(__p);
  }
  if ((v39 & 1) == 0) {
    sub_10004D2C8(v38);
  }
  sub_10005717C((const void **)(v40 - 200));
  if (*(char *)(v40 - 169) < 0) {
    operator delete(*(void **)(v40 - 192));
  }
  _Unwind_Resume(a1);
}

void sub_1005B6B10(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 8);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    int v3 = (const char *)(a1 + 120);
    if (*(char *)(a1 + 143) < 0) {
      int v3 = *(const char **)v3;
    }
    int v7 = 136315138;
    CFTypeID v8 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I MEID: %s", (uint8_t *)&v7, 0xCu);
    uint64_t v2 = *(NSObject **)(a1 + 8);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v4 = (const char *)(a1 + 64);
    if (*(char *)(a1 + 87) < 0) {
      uint64_t v4 = *(const char **)v4;
    }
    int v7 = 136315138;
    CFTypeID v8 = v4;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Token: %s", (uint8_t *)&v7, 0xCu);
    uint64_t v2 = *(NSObject **)(a1 + 8);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = *(int *)(a1 + 88);
    if (v5 > 3) {
      uint64_t v6 = "???";
    }
    else {
      uint64_t v6 = off_1019EA6F8[v5];
    }
    int v7 = 136315138;
    CFTypeID v8 = v6;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I State: %s", (uint8_t *)&v7, 0xCu);
  }
}

void sub_1005B6C80(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_1005B6D00(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_1005B6D3C(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_1005B6D74(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_1005B6DA4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

BOOL sub_1005B6DE8()
{
  CFStringRef v3 = @"VerifyBundles";
  CFRetain(@"VerifyBundles");
  CFStringRef v2 = @"VerifyBundles";
  CFRetain(@"VerifyBundles");
  BOOL v0 = sub_1005B6E70(&v2);
  sub_1000558F4((const void **)&v2);
  sub_1000558F4((const void **)&v3);
  return v0;
}

void sub_1005B6E4C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, const void *a10)
{
}

BOOL sub_1005B6E70(CFStringRef *a1)
{
  if (*a1) {
    uint64_t v1 = sub_1000810B8;
  }
  else {
    uint64_t v1 = 0;
  }
  if (!v1 || !sub_10121F67C() && !sub_10121F6B4()) {
    return 0;
  }
  CFBooleanRef BOOLean = 0;
  CFTypeRef v6 = CFPreferencesCopyValue(*a1, @"com.apple.commcenter", kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
  sub_1000BE34C(&BOOLean, &v6);
  if (BOOLean) {
    CFStringRef v3 = sub_100084B4C;
  }
  else {
    CFStringRef v3 = 0;
  }
  if (v3) {
    BOOL v4 = CFBooleanGetValue(BOOLean) == 0;
  }
  else {
    BOOL v4 = 0;
  }
  sub_100062778((const void **)&BOOLean);
  return v4;
}

void sub_1005B6F4C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100062778((const void **)va);
  _Unwind_Resume(a1);
}

BOOL sub_1005B6F60()
{
  CFStringRef v3 = @"VerifyAPN";
  CFRetain(@"VerifyAPN");
  CFStringRef v2 = @"VerifyAPN";
  CFRetain(@"VerifyAPN");
  BOOL v0 = sub_1005B6E70(&v2);
  sub_1000558F4((const void **)&v2);
  sub_1000558F4((const void **)&v3);
  return v0;
}

void sub_1005B6FC4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, const void *a10)
{
}

const char *sub_1005B6FF8(int a1)
{
  if ((a1 - 1) > 2) {
    return "msg.mms.mdc.?";
  }
  else {
    return off_1019EB820[a1 - 1];
  }
}

void mms::MMSDataCache::create(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  operator new();
}

void sub_1005B7998(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, ctu::OsLogLogger *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27)
{
}

void sub_1005B79C8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,std::__shared_weak_count *a28)
{
  if (a23) {
    (*(void (**)(uint64_t))(*(void *)a23 + 8))(a23);
  }
  if (a28) {
    sub_10004D2C8(a28);
  }
  sub_10004D2C8(v28);
  JUMPOUT(0x1005B7DF8);
}

void sub_1005B7A50(_Unwind_Exception *a1, int a2)
{
  if (a2)
  {
    __cxa_begin_catch(a1);
    dispatch_barrier_async_f(v2[3], v2, (dispatch_function_t)sub_1005BD478);
    __cxa_rethrow();
  }
  _Unwind_Resume(a1);
}

void sub_1005B7A84()
{
}

void sub_1005B7A94(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

void sub_1005B7AA4(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, NotifySubscription *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, dispatch_object_t object,dispatch_object_t a21,dispatch_object_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,void *__p,uint64_t a28,int a29,__int16 a30,char a31,char a32)
{
  NotifySubscription::~NotifySubscription(a12);
  sub_10026CF54(v32 + 640, *(void **)(v32 + 648));
  sub_1000346F8(v32 + 616, *(void **)(v32 + 624));
  sub_1000346F8(v34, *(void **)(v32 + 600));
  sub_100087ED0(v32 + 568, *v33);
  sub_10005CD2C(v32 + 544, *v35);
  EmergencyMode::~EmergencyMode(v37);
  sub_10024D10C(v32 + 496, *(void **)(v32 + 504));
  sub_1000346F8(v32 + 472, *(void **)(v32 + 480));
  sub_100087F94(v32 + 440, *(void **)(v32 + 448));
  sub_100417F2C(v32 + 376);
  long long v38 = *(std::__shared_weak_count **)(v32 + 368);
  if (v38) {
    sub_10004D2C8(v38);
  }
  sub_1000346F8(a18, *(void **)(v32 + 344));
  sub_10005D144(*(void **)(v32 + 320));
  sub_1000346F8(a13, *(void **)(v32 + 296));
  sub_1000346F8(a14, *(void **)(v32 + 272));
  sub_1000346F8(v36, *(void **)(v32 + 248));
  sub_1000346F8(a15, *(void **)(v32 + 224));
  sub_1000346F8(a16, *(void **)(v32 + 200));
  sub_1000346F8(a17, *(void **)(v32 + 176));
  sub_10005D144(*(void **)(v32 + 152));
  sub_100119D90(*(void **)(v32 + 120));
  uint64_t v39 = *(void *)(v32 + 104);
  *(void *)(v32 + 104) = 0;
  if (v39) {
    (*(void (**)(uint64_t))(*(void *)v39 + 8))(v39);
  }
  uint64_t v40 = *(void *)(v32 + 96);
  *(void *)(v32 + 96) = 0;
  if (v40) {
    (*(void (**)(uint64_t))(*(void *)v40 + 8))(v40);
  }
  sub_10005D144(*(void **)(v32 + 80));
  long long v41 = *(std::__shared_weak_count **)(v32 + 64);
  if (v41) {
    sub_10004D2C8(v41);
  }
  uint64_t v42 = *(void *)(v32 + 48);
  *(void *)(v32 + 48) = 0;
  if (v42) {
    (*(void (**)(uint64_t))(*(void *)v42 + 8))(v42);
  }
  JUMPOUT(0x1005B7CF4);
}

void sub_1005B7D94(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27)
{
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)&a23);
  sub_100087E88(v28);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&a27);
  if (v27) {
    dispatch_release(v27);
  }
  JUMPOUT(0x1005B7D04);
}

void sub_1005B7DD0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11)
{
  std::__shared_weak_count::__release_weak(v11);
  sub_10004D2C8(a11);
  JUMPOUT(0x1005B7DF8);
}

void sub_1005B7DE0()
{
}

uint64_t sub_1005B7E00(uint64_t a1, int a2, uint64_t *a3)
{
  v17[0] = a1 + 136;
  v17[1] = 1;
  ctu::UnfairLock::lock((ctu::UnfairLock *)(a1 + 136));
  int v7 = (uint64_t **)(a1 + 120);
  CFTypeRef v6 = *(uint64_t **)(a1 + 120);
  if (v6)
  {
    do
    {
      while (1)
      {
        CFTypeID v8 = (uint64_t **)v6;
        int v9 = *((_DWORD *)v6 + 8);
        if (v9 <= a2) {
          break;
        }
        CFTypeRef v6 = *v8;
        int v7 = v8;
        if (!*v8) {
          goto LABEL_10;
        }
      }
      if (v9 >= a2)
      {
        uint64_t v12 = v8;
        goto LABEL_13;
      }
      CFTypeRef v6 = v8[1];
    }
    while (v6);
    int v7 = v8 + 1;
  }
  else
  {
    CFTypeID v8 = (uint64_t **)(a1 + 120);
  }
LABEL_10:
  uint64_t v12 = operator new(0x38uLL);
  *((_DWORD *)v12 + 8) = a2;
  *((void *)v12 + 5) = 0;
  *((void *)v12 + 6) = 0;
  *(void *)uint64_t v12 = 0;
  *((void *)v12 + 1) = 0;
  *((void *)v12 + 2) = v8;
  *int v7 = (uint64_t *)v12;
  uint64_t v10 = **(void **)(a1 + 112);
  CFLocaleRef v11 = (uint64_t *)v12;
  if (v10)
  {
    *(void *)(a1 + 112) = v10;
    CFLocaleRef v11 = *v7;
  }
  sub_100046C90(*(uint64_t **)(a1 + 120), v11);
  ++*(void *)(a1 + 128);
LABEL_13:
  uint64_t v14 = *a3;
  uint64_t v13 = a3[1];
  if (v13) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v13 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v15 = (std::__shared_weak_count *)*((void *)v12 + 6);
  *((void *)v12 + 5) = v14;
  *((void *)v12 + 6) = v13;
  if (v15) {
    sub_10004D2C8(v15);
  }
  return sub_100056724((uint64_t)v17);
}

void sub_1005B7F14(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1005B7F28(uint64_t a1, dispatch_object_t object)
{
  if (object)
  {
    dispatch_retain(object);
    dispatch_group_enter(object);
  }
  BOOL v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_1005B8028(uint64_t a1, int a2)
{
  unsigned int v24 = a2;
  BOOL v4 = (NSObject **)(*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
  *(_OWORD *)std::string buf = 0uLL;
  sub_1005B7E00(a1, a2, (uint64_t *)buf);
  *(_OWORD *)(sub_1005C0D54((uint64_t **)(a1 + 72), a2, &v24) + 40) = xmmword_1014C33B0;
  *(void *)std::string buf = &v24;
  if (*((unsigned char *)sub_10005CE78((uint64_t **)(a1 + 288), (int *)&v24, (uint64_t)&unk_10144E20E, (_DWORD **)buf) + 32))
  {
    *(_OWORD *)std::string buf = 0uLL;
    uint64_t v5 = *(void *)(a1 + 96);
    uint64_t v6 = v24;
    int v7 = sub_1005C0D54((uint64_t **)(a1 + 72), v24, &v24);
    (*(void (**)(uint8_t *__return_ptr, uint64_t, uint64_t, char *))(*(void *)v5 + 16))(buf, v5, v6, v7 + 40);
    sub_1005B7E00(a1, v24, (uint64_t *)buf);
    if (*(void *)&buf[8]) {
      sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
    }
  }
  uint64_t v8 = v24;
  *(_DWORD *)std::string buf = v24;
  int v9 = (uint64_t *)*((void *)sub_1005C0D54((uint64_t **)(a1 + 72), v24, buf) + 6);
  sub_1005BD854((uint64_t **)(a1 + 312), v8, buf)[6] = v9;
  (*(void (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), v8);
  sub_1005B83D8(a1, v24);
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 56));
  CFLocaleRef v11 = ServiceMap;
  uint64_t v12 = "27MessageCenterModelInterface";
  if (((unint64_t)"27MessageCenterModelInterface" & 0x8000000000000000) != 0)
  {
    uint64_t v13 = (unsigned __int8 *)((unint64_t)"27MessageCenterModelInterface" & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v14 = 5381;
    do
    {
      uint64_t v12 = (const char *)v14;
      unsigned int v15 = *v13++;
      uint64_t v14 = (33 * v14) ^ v15;
    }
    while (v15);
  }
  std::mutex::lock(ServiceMap);
  *(void *)std::string buf = v12;
  uint64_t v16 = sub_10004D37C(&v11[1].__m_.__sig, (unint64_t *)buf);
  if (v16)
  {
    uint64_t v18 = v16[3];
    char v17 = (std::__shared_weak_count *)v16[4];
    if (v17)
    {
      atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v11);
      atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v17);
      char v19 = 0;
      if (!v18) {
        goto LABEL_10;
      }
      goto LABEL_14;
    }
  }
  else
  {
    uint64_t v18 = 0;
  }
  std::mutex::unlock(v11);
  char v17 = 0;
  char v19 = 1;
  if (!v18)
  {
LABEL_10:
    uint64_t v20 = *v4;
    if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, "Failed to get MessageCenterModel.", buf, 2u);
    }
    goto LABEL_21;
  }
LABEL_14:
  sub_10005666C(a1, v24, buf);
  uint64_t v21 = *(void *)buf;
  if (*(void *)&buf[8]) {
    sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
  }
  uint64_t v22 = *v4;
  if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v23 = "false";
    if (v21) {
      uint64_t v23 = "true";
    }
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = v23;
    _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "#I Posting MMS configuration changed [%s]", buf, 0xCu);
  }
  (*(void (**)(uint64_t, void, BOOL))(*(void *)v18 + 64))(v18, v24, v21 != 0);
LABEL_21:
  if ((v19 & 1) == 0) {
    sub_10004D2C8(v17);
  }
}

void sub_1005B8394(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  if ((v13 & 1) == 0) {
    sub_10004D2C8(v12);
  }
  _Unwind_Resume(exception_object);
}

void sub_1005B83D8(uint64_t a1, int a2)
{
  unsigned int v22 = a2;
  sub_10005666C(a1, a2, buf);
  uint64_t v3 = *(void *)buf;
  if (*(void *)&buf[8]) {
    sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
  }
  if (v3)
  {
    *(void *)std::string buf = &v22;
    BOOL v4 = *((unsigned char *)sub_10005CE78((uint64_t **)(a1 + 240), (int *)&v22, (uint64_t)&unk_10144E20E, (_DWORD **)buf) + 32) != 0;
  }
  else
  {
    BOOL v4 = 0;
  }
  *(void *)std::string buf = &v22;
  *((unsigned char *)sub_10005CE78((uint64_t **)(a1 + 264), (int *)&v22, (uint64_t)&unk_10144E20E, (_DWORD **)buf) + 32) = v4;
  *(void *)std::string buf = 1;
  *(void *)&uint8_t buf[8] = a1 + 376;
  uint64_t v23 = &v22;
  char v5 = *((unsigned char *)sub_10005CE78((uint64_t **)(a1 + 264), (int *)&v22, (uint64_t)&unk_10144E20E, &v23) + 32);
  uint64_t v23 = &v22;
  *((unsigned char *)sub_10005CE78((uint64_t **)(*(void *)&buf[8] + 32), (int *)&v22, (uint64_t)&unk_10144E20E, &v23) + 32) = v5;
  sub_1005C0FE8((uint64_t)buf);
  uint64_t v6 = (os_log_t *)(*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), v22);
  int v7 = *v6;
  if (os_log_type_enabled(*v6, OS_LOG_TYPE_DEFAULT))
  {
    *(void *)std::string buf = &v22;
    if (*((unsigned char *)sub_10005CE78((uint64_t **)(a1 + 264), (int *)&v22, (uint64_t)&unk_10144E20E, (_DWORD **)buf) + 32)) {
      uint64_t v8 = "true";
    }
    else {
      uint64_t v8 = "false";
    }
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = v8;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I MMS operation allowed: %s", buf, 0xCu);
  }
  *(void *)std::string buf = &v22;
  if (!*((unsigned char *)sub_10005CE78((uint64_t **)(a1 + 264), (int *)&v22, (uint64_t)&unk_10144E20E, (_DWORD **)buf) + 32))
  {
    int v9 = *v6;
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      if (v3) {
        uint64_t v10 = "true";
      }
      else {
        uint64_t v10 = "false";
      }
      *(void *)std::string buf = &v22;
      if (*((unsigned char *)sub_10005CE78((uint64_t **)(a1 + 264), (int *)&v22, (uint64_t)&unk_10144E20E, (_DWORD **)buf) + 32)) {
        CFLocaleRef v11 = "true";
      }
      else {
        CFLocaleRef v11 = "false";
      }
      *(_DWORD *)std::string buf = 136315394;
      *(void *)&uint8_t buf[4] = v10;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = v11;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I MMS configured: %s User enabled: %s", buf, 0x16u);
    }
  }
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 56));
  char v13 = ServiceMap;
  if (v14 < 0)
  {
    unsigned int v15 = (unsigned __int8 *)(v14 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v16 = 5381;
    do
    {
      uint64_t v14 = v16;
      unsigned int v17 = *v15++;
      uint64_t v16 = (33 * v16) ^ v17;
    }
    while (v17);
  }
  std::mutex::lock(ServiceMap);
  *(void *)std::string buf = v14;
  uint64_t v18 = sub_10004D37C(&v13[1].__m_.__sig, (unint64_t *)buf);
  if (v18)
  {
    uint64_t v20 = v18[3];
    char v19 = (std::__shared_weak_count *)v18[4];
    if (v19)
    {
      atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v13);
      atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v19);
      char v21 = 0;
      goto LABEL_28;
    }
  }
  else
  {
    uint64_t v20 = 0;
  }
  std::mutex::unlock(v13);
  char v19 = 0;
  char v21 = 1;
LABEL_28:
  (*(void (**)(uint64_t, void))(*(void *)v20 + 72))(v20, v22);
  if ((v21 & 1) == 0) {
    sub_10004D2C8(v19);
  }
}

void sub_1005B8778(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
  if ((v12 & 1) == 0) {
    sub_10004D2C8(v11);
  }
  _Unwind_Resume(exception_object);
}

void sub_1005B87B8(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_1005B88A8(uint64_t a1, dispatch_object_t *a2)
{
  if (*a2) {
    dispatch_retain(*a2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (v3)
  {
    if (std::__shared_weak_count::lock(v3)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_1005B89A0(uint64_t a1, uint64_t a2)
{
  unsigned int v9 = a2;
  int v3 = sub_100795740(a2, (Registry **)(a1 + 56));
  if (v3 == 2368 || v3 == 1058)
  {
    *(void *)std::string buf = &v9;
    BOOL v4 = sub_10030B04C((uint64_t **)(a1 + 336), (int *)&v9, (uint64_t)&unk_10144E20E, (unsigned int **)buf);
    int v5 = 36;
  }
  else
  {
    *(void *)std::string buf = &v9;
    BOOL v4 = sub_10030B04C((uint64_t **)(a1 + 336), (int *)&v9, (uint64_t)&unk_10144E20E, (unsigned int **)buf);
    int v5 = 106;
  }
  *((_DWORD *)v4 + 8) = v5;
  uint64_t v6 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), v9);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    *(void *)std::string buf = &v9;
    int v7 = sub_10030B04C((uint64_t **)(a1 + 336), (int *)&v9, (uint64_t)&unk_10144E20E, (unsigned int **)buf);
    uint64_t v8 = sub_100F5EA6C(*((_DWORD *)v7 + 8));
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = v8;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Default Text Encoding: %s", buf, 0xCu);
  }
}

void sub_1005B8B10(uint64_t a1, uint64_t a2)
{
  CFStringRef v2 = *(void **)(a1 + 440);
  int v3 = (void *)(a1 + 448);
  if (v2 != (void *)(a1 + 448))
  {
    int v5 = (void *)(a2 + 8);
    do
    {
      uint64_t v6 = *v5;
      if (*v5)
      {
        uint64_t v7 = *((unsigned int *)v2 + 8);
        uint64_t v8 = v5;
        do
        {
          int v9 = *(_DWORD *)(v6 + 32);
          BOOL v10 = v9 < (int)v7;
          if (v9 >= (int)v7) {
            CFLocaleRef v11 = (uint64_t *)v6;
          }
          else {
            CFLocaleRef v11 = (uint64_t *)(v6 + 8);
          }
          if (!v10) {
            uint64_t v8 = (void *)v6;
          }
          uint64_t v6 = *v11;
        }
        while (*v11);
        if (v8 != v5 && (int)v7 >= *((_DWORD *)v8 + 8))
        {
          if ((rest::operator==() & 1) == 0)
          {
            uint64_t v7 = *((unsigned int *)v2 + 8);
            uint64_t v12 = (*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), v7);
            if (*((unsigned char *)v2 + 40))
            {
              char v13 = (NSObject **)v12;
              if (*((unsigned char *)v2 + 40) == 2) {
                (*(void (**)(void))(**(void **)(a1 + 96) + 24))(*(void *)(a1 + 96));
              }
              uint64_t v14 = *v13;
              if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
              {
                __int16 v22 = 0;
                unsigned int v15 = (uint8_t *)&v22;
                goto LABEL_25;
              }
              goto LABEL_26;
            }
          }
          goto LABEL_27;
        }
      }
      else
      {
        uint64_t v7 = *((unsigned int *)v2 + 8);
      }
      uint64_t v16 = (*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), v7);
      if (*((unsigned char *)v2 + 40))
      {
        unsigned int v17 = (NSObject **)v16;
        if (*((unsigned char *)v2 + 40) == 2) {
          (*(void (**)(void))(**(void **)(a1 + 96) + 24))(*(void *)(a1 + 96));
        }
        uint64_t v14 = *v17;
        if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
        {
          __int16 v21 = 0;
          unsigned int v15 = (uint8_t *)&v21;
LABEL_25:
          _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I Carrier bundle changed, setting up MMSC Server", v15, 2u);
        }
LABEL_26:
        sub_1005B8028(a1, v7);
        sub_1005B89A0(a1, v7);
      }
LABEL_27:
      uint64_t v18 = (void *)v2[1];
      if (v18)
      {
        do
        {
          char v19 = v18;
          uint64_t v18 = (void *)*v18;
        }
        while (v18);
      }
      else
      {
        do
        {
          char v19 = (void *)v2[2];
          BOOL v20 = *v19 == (void)v2;
          CFStringRef v2 = v19;
        }
        while (!v20);
      }
      CFStringRef v2 = v19;
    }
    while (v19 != v3);
  }
}

void sub_1005B8D40(uint64_t a1, uint64_t a2)
{
  unsigned int v3 = *(_DWORD *)a2;
  uint64_t v4 = a2 + 4;
  if (v3) {
    BOOL v5 = 0;
  }
  else {
    BOOL v5 = *(_DWORD *)(a2 + 4) == 0;
  }
  if (!v5 || *(void *)(a2 + 8) != 0)
  {
    unsigned int v20 = v3;
    uint64_t v8 = (os_log_t *)(*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
    if ((*(unsigned char *)(a2 + 8) & 4) != 0)
    {
      int v9 = *v8;
      if (os_log_type_enabled(*v8, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)std::string buf = 136315138;
        *(void *)&uint8_t buf[4] = asString();
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I Data context activation failed with error:%s", buf, 0xCu);
      }
      *(void *)std::string buf = &v20;
      *((unsigned char *)sub_10005CE78((uint64_t **)(a1 + 168), (int *)&v20, (uint64_t)&unk_10144E20E, (_DWORD **)buf) + 32) = 0;
      ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 56));
      CFLocaleRef v11 = ServiceMap;
      if (v12 < 0)
      {
        char v13 = (unsigned __int8 *)(v12 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v14 = 5381;
        do
        {
          uint64_t v12 = v14;
          unsigned int v15 = *v13++;
          uint64_t v14 = (33 * v14) ^ v15;
        }
        while (v15);
      }
      std::mutex::lock(ServiceMap);
      *(void *)std::string buf = v12;
      uint64_t v16 = sub_10004D37C(&v11[1].__m_.__sig, (unint64_t *)buf);
      if (v16)
      {
        uint64_t v18 = v16[3];
        unsigned int v17 = (std::__shared_weak_count *)v16[4];
        if (v17)
        {
          atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v11);
          atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v17);
          char v19 = 0;
          goto LABEL_19;
        }
      }
      else
      {
        uint64_t v18 = 0;
      }
      std::mutex::unlock(v11);
      unsigned int v17 = 0;
      char v19 = 1;
LABEL_19:
      (*(void (**)(uint64_t, void, uint64_t))(*(void *)v18 + 40))(v18, v20, v4);
      if ((v19 & 1) == 0) {
        sub_10004D2C8(v17);
      }
    }
  }
}

void sub_1005B8F48(_Unwind_Exception *exception_object)
{
  if ((v1 & 1) == 0) {
    sub_10004D2C8(v2);
  }
  _Unwind_Resume(exception_object);
}

void sub_1005B8F78(uint64_t a1, uint64_t a2)
{
  CFStringRef v2 = *(void **)(a1 + 472);
  unsigned int v3 = (void *)(a1 + 480);
  if (v2 != (void *)(a1 + 480))
  {
    BOOL v5 = (void *)(a2 + 8);
    do
    {
      uint64_t v6 = *v5;
      int v7 = *((_DWORD *)v2 + 7);
      if (!*v5) {
        goto LABEL_13;
      }
      uint64_t v8 = v5;
      do
      {
        int v9 = *(_DWORD *)(v6 + 28);
        BOOL v10 = v9 < v7;
        if (v9 >= v7) {
          CFLocaleRef v11 = (uint64_t *)v6;
        }
        else {
          CFLocaleRef v11 = (uint64_t *)(v6 + 8);
        }
        if (!v10) {
          uint64_t v8 = (void *)v6;
        }
        uint64_t v6 = *v11;
      }
      while (*v11);
      if (v8 != v5 && v7 >= *((_DWORD *)v8 + 7))
      {
        if (operator==()) {
          goto LABEL_15;
        }
        int v7 = *((_DWORD *)v2 + 7);
        uint64_t v12 = a1;
      }
      else
      {
LABEL_13:
        uint64_t v12 = a1;
      }
      sub_1005C1174(v12, v7);
LABEL_15:
      char v13 = (void *)v2[1];
      if (v13)
      {
        do
        {
          uint64_t v14 = v13;
          char v13 = (void *)*v13;
        }
        while (v13);
      }
      else
      {
        do
        {
          uint64_t v14 = (void *)v2[2];
          BOOL v15 = *v14 == (void)v2;
          CFStringRef v2 = v14;
        }
        while (!v15);
      }
      CFStringRef v2 = v14;
    }
    while (v14 != v3);
  }
}

void sub_1005B9068(uint64_t a1, uint64_t a2)
{
  CFStringRef v2 = *(void **)(a1 + 696);
  unsigned int v3 = (void *)(a1 + 704);
  if (v2 != (void *)(a1 + 704))
  {
    BOOL v5 = (void *)(a2 + 8);
    while (1)
    {
      uint64_t v6 = *v5;
      if (!*v5) {
        break;
      }
      signed int v7 = *((_DWORD *)v2 + 8);
      uint64_t v8 = v5;
      do
      {
        signed int v9 = *(_DWORD *)(v6 + 32);
        BOOL v10 = v9 < v7;
        if (v9 >= v7) {
          CFLocaleRef v11 = (uint64_t *)v6;
        }
        else {
          CFLocaleRef v11 = (uint64_t *)(v6 + 8);
        }
        if (!v10) {
          uint64_t v8 = (void *)v6;
        }
        uint64_t v6 = *v11;
      }
      while (*v11);
      if (v8 == v5 || v7 < *((_DWORD *)v8 + 8)) {
        goto LABEL_16;
      }
      if ((rest::operator==() & 1) == 0)
      {
        signed int v7 = *((_DWORD *)v2 + 8);
        uint64_t v12 = a1;
        uint64_t v13 = (uint64_t)(v2 + 5);
        goto LABEL_17;
      }
LABEL_18:
      uint64_t v14 = (void *)v2[1];
      if (v14)
      {
        do
        {
          BOOL v15 = v14;
          uint64_t v14 = (void *)*v14;
        }
        while (v14);
      }
      else
      {
        do
        {
          BOOL v15 = (void *)v2[2];
          BOOL v16 = *v15 == (void)v2;
          CFStringRef v2 = v15;
        }
        while (!v16);
      }
      CFStringRef v2 = v15;
      if (v15 == v3) {
        return;
      }
    }
    signed int v7 = *((_DWORD *)v2 + 8);
LABEL_16:
    uint64_t v13 = (uint64_t)(v2 + 5);
    uint64_t v12 = a1;
LABEL_17:
    sub_1005C1440(v12, v7, v13);
    goto LABEL_18;
  }
}

void sub_1005B9158(uint64_t a1, uint64_t a2)
{
  CFStringRef v2 = *(void **)(a1 + 496);
  unsigned int v3 = (void *)(a1 + 504);
  if (v2 != (void *)(a1 + 504))
  {
    BOOL v5 = (void *)(a2 + 8);
    while (1)
    {
      uint64_t v6 = *v5;
      if (!*v5) {
        break;
      }
      signed int v7 = *((_DWORD *)v2 + 8);
      uint64_t v8 = v5;
      do
      {
        signed int v9 = *(_DWORD *)(v6 + 32);
        BOOL v10 = v9 < v7;
        if (v9 >= v7) {
          CFLocaleRef v11 = (uint64_t *)v6;
        }
        else {
          CFLocaleRef v11 = (uint64_t *)(v6 + 8);
        }
        if (!v10) {
          uint64_t v8 = (void *)v6;
        }
        uint64_t v6 = *v11;
      }
      while (*v11);
      if (v8 == v5 || v7 < *((_DWORD *)v8 + 8)) {
        goto LABEL_30;
      }
      if (v8[7] != v2[7]) {
        goto LABEL_40;
      }
      uint64_t v12 = (void *)v8[5];
      uint64_t v13 = v8 + 6;
      if (v12 != v8 + 6)
      {
        uint64_t v14 = (void *)v2[5];
        while (sub_1005C18C4((uint64_t)&v24, (uint64_t)(v12 + 4), (uint64_t)(v14 + 4)))
        {
          BOOL v15 = (void *)v12[1];
          BOOL v16 = v12;
          if (v15)
          {
            do
            {
              uint64_t v12 = v15;
              BOOL v15 = (void *)*v15;
            }
            while (v15);
          }
          else
          {
            do
            {
              uint64_t v12 = (void *)v16[2];
              BOOL v17 = *v12 == (void)v16;
              BOOL v16 = v12;
            }
            while (!v17);
          }
          uint64_t v18 = (void *)v14[1];
          if (v18)
          {
            do
            {
              char v19 = v18;
              uint64_t v18 = (void *)*v18;
            }
            while (v18);
          }
          else
          {
            do
            {
              char v19 = (void *)v14[2];
              BOOL v17 = *v19 == (void)v14;
              uint64_t v14 = v19;
            }
            while (!v17);
          }
          uint64_t v14 = v19;
          if (v12 == v13) {
            goto LABEL_32;
          }
        }
        signed int v7 = *((_DWORD *)v2 + 8);
LABEL_40:
        uint64_t v21 = a1;
        uint64_t v20 = (uint64_t)(v2 + 5);
        goto LABEL_31;
      }
LABEL_32:
      __int16 v22 = (void *)v2[1];
      if (v22)
      {
        do
        {
          uint64_t v23 = v22;
          __int16 v22 = (void *)*v22;
        }
        while (v22);
      }
      else
      {
        do
        {
          uint64_t v23 = (void *)v2[2];
          BOOL v17 = *v23 == (void)v2;
          CFStringRef v2 = v23;
        }
        while (!v17);
      }
      CFStringRef v2 = v23;
      if (v23 == v3) {
        return;
      }
    }
    signed int v7 = *((_DWORD *)v2 + 8);
LABEL_30:
    uint64_t v20 = (uint64_t)(v2 + 5);
    uint64_t v21 = a1;
LABEL_31:
    sub_1005C16C4(v21, v7, v20);
    goto LABEL_32;
  }
}

void sub_1005B92F0(uint64_t a1, int a2)
{
  uint64_t v4 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v18 = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Handling user preferred data slot change", v18, 2u);
  }
  int v5 = *(_DWORD *)(a1 + 520);
  if (v5 != a2)
  {
    if (v5)
    {
      ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 56));
      signed int v7 = ServiceMap;
      if (v8 < 0)
      {
        signed int v9 = (unsigned __int8 *)(v8 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v10 = 5381;
        do
        {
          uint64_t v8 = v10;
          unsigned int v11 = *v9++;
          uint64_t v10 = (33 * v10) ^ v11;
        }
        while (v11);
      }
      std::mutex::lock(ServiceMap);
      *(void *)uint64_t v18 = v8;
      uint64_t v12 = sub_10004D37C(&v7[1].__m_.__sig, (unint64_t *)v18);
      if (v12)
      {
        uint64_t v14 = v12[3];
        uint64_t v13 = (std::__shared_weak_count *)v12[4];
        if (v13)
        {
          atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v7);
          atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v13);
          char v15 = 0;
          goto LABEL_15;
        }
      }
      else
      {
        uint64_t v14 = 0;
      }
      std::mutex::unlock(v7);
      uint64_t v13 = 0;
      char v15 = 1;
LABEL_15:
      (*(void (**)(uint64_t, void, uint64_t))(*(void *)v14 + 96))(v14, *(unsigned int *)(a1 + 520), 1);
      if ((v15 & 1) == 0) {
        sub_10004D2C8(v13);
      }
      return;
    }
    BOOL v16 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
    {
      uint64_t v17 = subscriber::asString();
      *(_DWORD *)uint64_t v18 = 136315138;
      *(void *)&v18[4] = v17;
      _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "User data SIM: %s, skip further actions", v18, 0xCu);
    }
  }
}

void sub_1005B94CC(_Unwind_Exception *exception_object)
{
  if ((v1 & 1) == 0) {
    sub_10004D2C8(v2);
  }
  _Unwind_Resume(exception_object);
}

void sub_1005B94FC(uint64_t a1, uint64_t a2)
{
  CFStringRef v2 = *(void **)(a1 + 640);
  unsigned int v3 = (void *)(a1 + 648);
  if (v2 != (void *)(a1 + 648))
  {
    int v5 = (void *)(a2 + 8);
    uint64_t v6 = (uint64_t **)(a1 + 288);
    while (1)
    {
      uint64_t v7 = *v5;
      if (!*v5) {
        break;
      }
      int v8 = *((_DWORD *)v2 + 8);
      signed int v9 = v5;
      do
      {
        int v10 = *(_DWORD *)(v7 + 32);
        BOOL v11 = v10 < v8;
        if (v10 >= v8) {
          uint64_t v12 = (uint64_t *)v7;
        }
        else {
          uint64_t v12 = (uint64_t *)(v7 + 8);
        }
        if (!v11) {
          signed int v9 = (void *)v7;
        }
        uint64_t v7 = *v12;
      }
      while (*v12);
      if (v9 == v5 || v8 < *((_DWORD *)v9 + 8)) {
        goto LABEL_18;
      }
      char v15 = v9 + 5;
      uint64_t v14 = (char *)v9[5];
      uint64_t v13 = (char *)v15[1];
      BOOL v16 = (_DWORD *)v2[5];
      if (v13 - v14 == v2[6] - (void)v16)
      {
        while (v14 != v13)
        {
          if (*(_DWORD *)v14 != *v16) {
            goto LABEL_32;
          }
          v14 += 4;
          ++v16;
        }
        goto LABEL_25;
      }
LABEL_32:
      int v24 = *((_DWORD *)v2 + 8);
      uint64_t v23 = *(NSObject **)(*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
      if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "#I Setting up MMS upon message mode changed...", buf, 2u);
      }
      uint64_t v18 = (_DWORD *)v2[5];
      char v19 = (_DWORD *)v2[6];
      if (v18 != v19)
      {
        while (*v18 != 3)
        {
          if (++v18 == v19) {
            goto LABEL_23;
          }
        }
      }
LABEL_24:
      *(void *)std::string buf = &v24;
      *((unsigned char *)sub_10005CE78(v6, &v24, (uint64_t)&unk_10144E20E, (_DWORD **)buf) + 32) = v18 != v19;
      sub_1005B8028(a1, v24);
LABEL_25:
      uint64_t v20 = (void *)v2[1];
      if (v20)
      {
        do
        {
          uint64_t v21 = v20;
          uint64_t v20 = (void *)*v20;
        }
        while (v20);
      }
      else
      {
        do
        {
          uint64_t v21 = (void *)v2[2];
          BOOL v22 = *v21 == (void)v2;
          CFStringRef v2 = v21;
        }
        while (!v22);
      }
      CFStringRef v2 = v21;
      if (v21 == v3) {
        return;
      }
    }
    int v8 = *((_DWORD *)v2 + 8);
LABEL_18:
    int v24 = v8;
    uint64_t v17 = *(NSObject **)(*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I Setting up MMS upon message mode changed...", buf, 2u);
    }
    uint64_t v18 = (_DWORD *)v2[5];
    char v19 = (_DWORD *)v2[6];
    if (v18 != v19)
    {
      while (*v18 != 3)
      {
        if (++v18 == v19)
        {
LABEL_23:
          uint64_t v18 = v19;
          goto LABEL_24;
        }
      }
    }
    goto LABEL_24;
  }
}

void sub_1005B9778(uint64_t a1)
{
  subscriber::makeSimSlotRange();
  unsigned int v3 = v67;
  CFStringRef v2 = v68;
  if (v67 != v68)
  {
    uint64_t v4 = v69;
    while ((v69(*v3) & 1) == 0)
    {
      if (++v3 == v68)
      {
        unsigned int v3 = v68;
        break;
      }
    }
    uint64_t v62 = v68;
    if (v3 != v68)
    {
      uint64_t v61 = (uint64_t *)(a1 + 152);
      uint64_t v63 = a1 + 192;
      int v64 = (uint64_t *)(a1 + 600);
      int v5 = (uint64_t *)(a1 + 576);
      uint64_t v6 = (uint64_t *)(a1 + 80);
      while (1)
      {
        int v66 = 0;
        int v66 = *v3;
        uint64_t v7 = (os_log_t *)(*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
        long long v70 = 0uLL;
        sub_10005666C(a1, v66, &v70);
        if ((void)v70)
        {
          (*(void (**)(void))(*(void *)v70 + 360))(v70);
        }
        else
        {
          int v8 = *v7;
          if (os_log_type_enabled(*v7, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)std::string buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Missing MMS server address", buf, 2u);
          }
        }
        if (*((void *)&v70 + 1)) {
          sub_10004D2C8(*((std::__shared_weak_count **)&v70 + 1));
        }
        signed int v9 = *v7;
        if (os_log_type_enabled(*v7, OS_LOG_TYPE_DEFAULT))
        {
          int v10 = sub_10012EF5C(v63, &v66);
          BOOL v11 = "true";
          if (!*(unsigned char *)v10) {
            BOOL v11 = "false";
          }
          LODWORD(v70) = 136315138;
          *(void *)((char *)&v70 + 4) = v11;
          _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I Connection Available: %s", (uint8_t *)&v70, 0xCu);
        }
        if (!*(unsigned char *)sub_10012EF5C(v63, &v66))
        {
          uint64_t v49 = *v61;
          if (*v61)
          {
            uint64_t v50 = a1 + 152;
            do
            {
              int v51 = *(_DWORD *)(v49 + 28);
              BOOL v52 = v51 < v66;
              if (v51 >= v66) {
                uint64_t v53 = (uint64_t *)v49;
              }
              else {
                uint64_t v53 = (uint64_t *)(v49 + 8);
              }
              if (!v52) {
                uint64_t v50 = v49;
              }
              uint64_t v49 = *v53;
            }
            while (*v53);
            if ((uint64_t *)v50 != v61 && v66 >= *(_DWORD *)(v50 + 28))
            {
              uint64_t v54 = *v7;
              if (os_log_type_enabled(*v7, OS_LOG_TYPE_DEFAULT))
              {
                uint64_t v55 = CSIErrorString();
                LODWORD(v70) = 136315138;
                *(void *)((char *)&v70 + 4) = v55;
                _os_log_impl((void *)&_mh_execute_header, v54, OS_LOG_TYPE_DEFAULT, "#I Connection unavailable reason: %s", (uint8_t *)&v70, 0xCu);
              }
            }
          }
        }
        uint64_t v12 = *v7;
        if (os_log_type_enabled(*v7, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v13 = sub_10012EF5C(a1 + 168, &v66);
          uint64_t v14 = "true";
          if (!*(unsigned char *)v13) {
            uint64_t v14 = "false";
          }
          LODWORD(v70) = 136315138;
          *(void *)((char *)&v70 + 4) = v14;
          _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I Connection Active: %s", (uint8_t *)&v70, 0xCu);
          uint64_t v12 = *v7;
        }
        if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
        {
          char v15 = sub_10012EF5C(a1 + 240, &v66);
          BOOL v16 = "true";
          if (!*(unsigned char *)v15) {
            BOOL v16 = "false";
          }
          LODWORD(v70) = 136315138;
          *(void *)((char *)&v70 + 4) = v16;
          _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I MMS Enabled by User: %s", (uint8_t *)&v70, 0xCu);
          uint64_t v12 = *v7;
        }
        if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v17 = sub_10012EF5C(a1 + 264, &v66);
          uint64_t v18 = "true";
          if (!*(unsigned char *)v17) {
            uint64_t v18 = "false";
          }
          LODWORD(v70) = 136315138;
          *(void *)((char *)&v70 + 4) = v18;
          _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I MMS Operation Ready: %s", (uint8_t *)&v70, 0xCu);
          uint64_t v12 = *v7;
        }
        if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
        {
          char v19 = sub_10012EF5C(a1 + 288, &v66);
          uint64_t v20 = "true";
          if (!*(unsigned char *)v19) {
            uint64_t v20 = "false";
          }
          LODWORD(v70) = 136315138;
          *(void *)((char *)&v70 + 4) = v20;
          _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I MMS Supported: %s", (uint8_t *)&v70, 0xCu);
        }
        uint64_t v21 = *v64;
        if (*v64)
        {
          uint64_t v22 = a1 + 600;
          do
          {
            int v23 = *(_DWORD *)(v21 + 28);
            BOOL v24 = v23 < v66;
            if (v23 >= v66) {
              BOOL v25 = (uint64_t *)v21;
            }
            else {
              BOOL v25 = (uint64_t *)(v21 + 8);
            }
            if (!v24) {
              uint64_t v22 = v21;
            }
            uint64_t v21 = *v25;
          }
          while (*v25);
          if ((uint64_t *)v22 != v64 && v66 >= *(_DWORD *)(v22 + 28))
          {
            uint64_t v26 = *v7;
            if (os_log_type_enabled(*v7, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v27 = "true";
              if (!*(unsigned char *)(v22 + 32)) {
                uint64_t v27 = "false";
              }
              LODWORD(v70) = 136315138;
              *(void *)((char *)&v70 + 4) = v27;
              _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "#I PS Attached: %s", (uint8_t *)&v70, 0xCu);
            }
          }
        }
        uint64_t v28 = *v5;
        if (*v5)
        {
          uint64_t v29 = a1 + 576;
          do
          {
            int v30 = *(_DWORD *)(v28 + 32);
            BOOL v31 = v30 < v66;
            if (v30 >= v66) {
              uint64_t v32 = (uint64_t *)v28;
            }
            else {
              uint64_t v32 = (uint64_t *)(v28 + 8);
            }
            if (!v31) {
              uint64_t v29 = v28;
            }
            uint64_t v28 = *v32;
          }
          while (*v32);
          if ((uint64_t *)v29 != v5 && v66 >= *(_DWORD *)(v29 + 32))
          {
            unint64_t v33 = *v7;
            if (os_log_type_enabled(*v7, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v34 = (void *)(v29 + 40);
              if (*(char *)(v29 + 63) < 0) {
                uint64_t v34 = (void *)*v34;
              }
              LODWORD(v70) = 136315138;
              *(void *)((char *)&v70 + 4) = v34;
              _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "#I Phone Number: %s", (uint8_t *)&v70, 0xCu);
            }
          }
        }
        int v35 = *v7;
        if (os_log_type_enabled(*v7, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v36 = sub_1000389F8(*(uint64_t **)(a1 + 320), v66);
          long long v37 = "true";
          if (!*(unsigned char *)v36) {
            long long v37 = "false";
          }
          LODWORD(v70) = 136315138;
          *(void *)((char *)&v70 + 4) = v37;
          _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_DEFAULT, "#I Is Call Active: %s", (uint8_t *)&v70, 0xCu);
          int v35 = *v7;
        }
        if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT))
        {
          long long v38 = "true";
          if (!*(unsigned char *)(a1 + 432)) {
            long long v38 = "false";
          }
          LODWORD(v70) = 136315138;
          *(void *)((char *)&v70 + 4) = v38;
          _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_DEFAULT, "#I Airplane Mode %s", (uint8_t *)&v70, 0xCu);
        }
        uint64_t v39 = *v6;
        if (*v6)
        {
          uint64_t v40 = a1 + 80;
          do
          {
            int v41 = *(_DWORD *)(v39 + 32);
            BOOL v42 = v41 < v66;
            if (v41 >= v66) {
              long long v43 = (uint64_t *)v39;
            }
            else {
              long long v43 = (uint64_t *)(v39 + 8);
            }
            if (!v42) {
              uint64_t v40 = v39;
            }
            uint64_t v39 = *v43;
          }
          while (*v43);
          if ((uint64_t *)v40 != v6 && v66 >= *(_DWORD *)(v40 + 32)) {
            break;
          }
        }
        os_log_t v44 = *v7;
        if (os_log_type_enabled(*v7, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(v70) = 0;
          uint64_t v45 = v44;
          long long v46 = "#I Empty fControllerSettings for this slot";
          uint32_t v47 = 2;
LABEL_83:
          _os_log_impl((void *)&_mh_execute_header, v45, OS_LOG_TYPE_DEFAULT, v46, (uint8_t *)&v70, v47);
        }
LABEL_84:
        long long v48 = v3 + 1;
        unsigned int v3 = v2;
        if (v48 != v2)
        {
          unsigned int v3 = v48;
          while ((v4(*v3) & 1) == 0)
          {
            if (++v3 == v2)
            {
              unsigned int v3 = v2;
              break;
            }
          }
        }
        if (v3 == v62) {
          return;
        }
      }
      uint64_t v56 = *v7;
      if (os_log_type_enabled(*v7, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v57 = "true";
        if (!*(unsigned char *)(v40 + 40)) {
          uint64_t v57 = "false";
        }
        LODWORD(v70) = 136315138;
        *(void *)((char *)&v70 + 4) = v57;
        _os_log_impl((void *)&_mh_execute_header, v56, OS_LOG_TYPE_DEFAULT, "#I MMS allowed while data roaming: %s", (uint8_t *)&v70, 0xCu);
        uint64_t v56 = *v7;
      }
      if (os_log_type_enabled(v56, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v58 = "true";
        if (!*(unsigned char *)(v40 + 41)) {
          uint64_t v58 = "false";
        }
        LODWORD(v70) = 136315138;
        *(void *)((char *)&v70 + 4) = v58;
        _os_log_impl((void *)&_mh_execute_header, v56, OS_LOG_TYPE_DEFAULT, "#I MMS allowed while data off: %s", (uint8_t *)&v70, 0xCu);
        uint64_t v56 = *v7;
      }
      if (os_log_type_enabled(v56, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v59 = "true";
        if (!*(unsigned char *)(v40 + 42)) {
          uint64_t v59 = "false";
        }
        LODWORD(v70) = 136315138;
        *(void *)((char *)&v70 + 4) = v59;
        _os_log_impl((void *)&_mh_execute_header, v56, OS_LOG_TYPE_DEFAULT, "#I MMS allowed on internet: %s", (uint8_t *)&v70, 0xCu);
        uint64_t v56 = *v7;
      }
      if (!os_log_type_enabled(v56, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_84;
      }
      uint64_t v60 = *(void *)(v40 + 48);
      LODWORD(v70) = 134217984;
      *(void *)((char *)&v70 + 4) = v60;
      uint64_t v45 = v56;
      long long v46 = "#I MMS max voice call wait period: %ld";
      uint32_t v47 = 12;
      goto LABEL_83;
    }
  }
}

void sub_1005BA00C(_Unwind_Exception *exception_object)
{
  unsigned int v3 = *(std::__shared_weak_count **)(v1 - 104);
  if (v3) {
    sub_10004D2C8(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1005BA02C(uint64_t a1, uint64_t a2, unsigned __int8 a3)
{
  uint64_t v9 = a2;
  unsigned __int8 v8 = a3;
  v7[0] = a1;
  v7[1] = &v9;
  _OWORD v7[2] = &v8;
  if (*(void *)(a1 + 32))
  {
    if (dispatch_workloop_is_current()) {
      return (*(uint64_t (**)(void, uint64_t, void))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v9, v8);
    }
    BOOL v5 = *(void *)(a1 + 32) == 0;
  }
  else
  {
    BOOL v5 = 1;
  }
  v10[0] = _NSConcreteStackBlock;
  v10[1] = 0x40000000;
  uint64_t v10[2] = sub_1005C1960;
  void v10[3] = &unk_1019EB2F0;
  void v10[4] = a1 + 8;
  void v10[5] = v7;
  BOOL v11 = v10;
  uint64_t v6 = *(NSObject **)(a1 + 24);
  char v17 = 0;
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  if (v5)
  {
    uint64_t v13 = sub_10005A0AC;
    uint64_t v14 = &unk_1019EB310;
    char v15 = &v17;
    BOOL v16 = &v11;
    dispatch_sync(v6, block);
  }
  else
  {
    uint64_t v13 = sub_10005AE10;
    uint64_t v14 = &unk_1019EB330;
    char v15 = &v17;
    BOOL v16 = &v11;
    dispatch_async_and_wait(v6, block);
  }
  return v17 != 0;
}

uint64_t sub_1005BA1DC(uint64_t a1, int a2)
{
  int v7 = a2;
  v6[0] = a1;
  v6[1] = &v7;
  if (*(void *)(a1 + 32))
  {
    if (dispatch_workloop_is_current()) {
      return *(unsigned int *)sub_1000FA5F4(*(uint64_t **)(a1 + 152), v7);
    }
    BOOL v4 = *(void *)(a1 + 32) == 0;
  }
  else
  {
    BOOL v4 = 1;
  }
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 0x40000000;
  void v8[2] = sub_1005C199C;
  void v8[3] = &unk_1019EB350;
  void v8[4] = a1 + 8;
  void v8[5] = v6;
  uint64_t v9 = v8;
  BOOL v5 = *(NSObject **)(a1 + 24);
  unsigned int v15 = 0;
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  if (v4)
  {
    BOOL v11 = sub_1005C19C8;
    uint64_t v12 = &unk_1019EB370;
    uint64_t v13 = &v15;
    uint64_t v14 = &v9;
    dispatch_sync(v5, block);
  }
  else
  {
    BOOL v11 = sub_1005C1A04;
    uint64_t v12 = &unk_1019EB390;
    uint64_t v13 = &v15;
    uint64_t v14 = &v9;
    dispatch_async_and_wait(v5, block);
  }
  return v15;
}

uint64_t sub_1005BA358(uint64_t a1)
{
  uint64_t v5 = a1;
  if (*(void *)(a1 + 32))
  {
    if (dispatch_workloop_is_current()) {
      return *(unsigned int *)(a1 + 520);
    }
    BOOL v3 = *(void *)(a1 + 32) == 0;
  }
  else
  {
    BOOL v3 = 1;
  }
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 0x40000000;
  void v6[2] = sub_1005C1A40;
  v6[3] = &unk_1019EB3B0;
  void v6[4] = a1 + 8;
  void v6[5] = &v5;
  int v7 = v6;
  BOOL v4 = *(NSObject **)(a1 + 24);
  unsigned int v13 = 0;
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  if (v3)
  {
    uint64_t v9 = sub_1005C1A50;
    int v10 = &unk_1019EB3D0;
    BOOL v11 = &v13;
    uint64_t v12 = &v7;
    dispatch_sync(v4, block);
  }
  else
  {
    uint64_t v9 = sub_1005C1A8C;
    int v10 = &unk_1019EB3F0;
    BOOL v11 = &v13;
    uint64_t v12 = &v7;
    dispatch_async_and_wait(v4, block);
  }
  return v13;
}

BOOL sub_1005BA4BC(uint64_t a1, int a2)
{
  int v8 = a2;
  v7[0] = a1;
  v7[1] = &v8;
  if (*(void *)(a1 + 32))
  {
    if (dispatch_workloop_is_current())
    {
      int v3 = *(unsigned __int8 *)sub_10012EF5C(a1 + 168, &v8);
      return v3 != 0;
    }
    BOOL v4 = *(void *)(a1 + 32) == 0;
  }
  else
  {
    BOOL v4 = 1;
  }
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 0x40000000;
  v9[2] = sub_1005C1AC8;
  v9[3] = &unk_1019EB410;
  void v9[4] = a1 + 8;
  v9[5] = v7;
  int v10 = v9;
  uint64_t v5 = *(NSObject **)(a1 + 24);
  unsigned __int8 v16 = 0;
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  if (v4)
  {
    uint64_t v12 = sub_10005A0AC;
    unsigned int v13 = &unk_1019EB310;
    uint64_t v14 = &v16;
    unsigned int v15 = &v10;
    dispatch_sync(v5, block);
  }
  else
  {
    uint64_t v12 = sub_10005AE10;
    unsigned int v13 = &unk_1019EB330;
    uint64_t v14 = &v16;
    unsigned int v15 = &v10;
    dispatch_async_and_wait(v5, block);
  }
  int v3 = v16;
  return v3 != 0;
}

BOOL sub_1005BA640(uint64_t a1, int a2)
{
  int v8 = a2;
  v7[0] = a1;
  v7[1] = &v8;
  if (*(void *)(a1 + 32))
  {
    if (dispatch_workloop_is_current())
    {
      int v3 = *(unsigned __int8 *)sub_10012EF5C(a1 + 192, &v8);
      return v3 != 0;
    }
    BOOL v4 = *(void *)(a1 + 32) == 0;
  }
  else
  {
    BOOL v4 = 1;
  }
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 0x40000000;
  v9[2] = sub_1005C1AF0;
  v9[3] = &unk_1019EB430;
  void v9[4] = a1 + 8;
  v9[5] = v7;
  int v10 = v9;
  uint64_t v5 = *(NSObject **)(a1 + 24);
  unsigned __int8 v16 = 0;
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  if (v4)
  {
    uint64_t v12 = sub_10005A0AC;
    unsigned int v13 = &unk_1019EB310;
    uint64_t v14 = &v16;
    unsigned int v15 = &v10;
    dispatch_sync(v5, block);
  }
  else
  {
    uint64_t v12 = sub_10005AE10;
    unsigned int v13 = &unk_1019EB330;
    uint64_t v14 = &v16;
    unsigned int v15 = &v10;
    dispatch_async_and_wait(v5, block);
  }
  int v3 = v16;
  return v3 != 0;
}

BOOL sub_1005BA7C4(uint64_t a1, int a2)
{
  int v8 = a2;
  v7[0] = a1;
  v7[1] = &v8;
  if (*(void *)(a1 + 32))
  {
    if (dispatch_workloop_is_current())
    {
      int v3 = *(unsigned __int8 *)sub_10012EF5C(a1 + 216, &v8);
      return v3 != 0;
    }
    BOOL v4 = *(void *)(a1 + 32) == 0;
  }
  else
  {
    BOOL v4 = 1;
  }
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 0x40000000;
  v9[2] = sub_1005C1B18;
  v9[3] = &unk_1019EB450;
  void v9[4] = a1 + 8;
  v9[5] = v7;
  int v10 = v9;
  uint64_t v5 = *(NSObject **)(a1 + 24);
  unsigned __int8 v16 = 0;
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  if (v4)
  {
    uint64_t v12 = sub_10005A0AC;
    unsigned int v13 = &unk_1019EB310;
    uint64_t v14 = &v16;
    unsigned int v15 = &v10;
    dispatch_sync(v5, block);
  }
  else
  {
    uint64_t v12 = sub_10005AE10;
    unsigned int v13 = &unk_1019EB330;
    uint64_t v14 = &v16;
    unsigned int v15 = &v10;
    dispatch_async_and_wait(v5, block);
  }
  int v3 = v16;
  return v3 != 0;
}

BOOL sub_1005BA948(uint64_t a1, int a2)
{
  int v7 = a2;
  v6[0] = (int *)a1;
  v6[1] = &v7;
  if (*(void *)(a1 + 32))
  {
    if (dispatch_workloop_is_current()) {
      return sub_1005C1B40(v6);
    }
    BOOL v4 = *(void *)(a1 + 32) == 0;
  }
  else
  {
    BOOL v4 = 1;
  }
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 0x40000000;
  void v8[2] = sub_1005C2008;
  void v8[3] = &unk_1019EB470;
  void v8[4] = a1 + 8;
  void v8[5] = v6;
  uint64_t v9 = v8;
  uint64_t v5 = *(NSObject **)(a1 + 24);
  char v15 = 0;
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  if (v4)
  {
    BOOL v11 = sub_10005A0AC;
    uint64_t v12 = &unk_1019EB310;
    unsigned int v13 = &v15;
    uint64_t v14 = &v9;
    dispatch_sync(v5, block);
  }
  else
  {
    BOOL v11 = sub_10005AE10;
    uint64_t v12 = &unk_1019EB330;
    unsigned int v13 = &v15;
    uint64_t v14 = &v9;
    dispatch_async_and_wait(v5, block);
  }
  return v15 != 0;
}

BOOL sub_1005BAAC4(uint64_t a1, int a2)
{
  int v11 = a2;
  v10[0] = a1;
  v10[1] = &v11;
  if (!*(void *)(a1 + 32))
  {
    BOOL v7 = 1;
LABEL_8:
    v12[0] = _NSConcreteStackBlock;
    v12[1] = 0x40000000;
    v12[2] = sub_1005C2010;
    v12[3] = &unk_1019EB490;
    void v12[4] = a1 + 8;
    void v12[5] = v10;
    unsigned int v13 = v12;
    int v8 = *(NSObject **)(a1 + 24);
    char v20 = 0;
    block = _NSConcreteStackBlock;
    uint64_t v15 = 0x40000000;
    if (v7)
    {
      unsigned __int8 v16 = sub_10005A0AC;
      char v17 = &unk_1019EB310;
      uint64_t v18 = &v20;
      char v19 = &v13;
      dispatch_sync(v8, &block);
    }
    else
    {
      unsigned __int8 v16 = sub_10005AE10;
      char v17 = &unk_1019EB330;
      uint64_t v18 = &v20;
      char v19 = &v13;
      dispatch_async_and_wait(v8, &block);
    }
    return v20 != 0;
  }
  if ((dispatch_workloop_is_current() & 1) == 0)
  {
    BOOL v7 = *(void *)(a1 + 32) == 0;
    goto LABEL_8;
  }
  block = 0;
  uint64_t v15 = 0;
  unsigned __int8 v16 = 0;
  PersonalityIdFromSlotIdEx();
  BOOL v4 = sub_100046F68(a1 + 544, (void **)&block);
  uint64_t v5 = v4;
  uint64_t v6 = (void **)(a1 + 552);
  if (v6 != v4) {
    BOOL v2 = *((_DWORD *)v4 + 14) == 1 && *((unsigned char *)v4 + 64) != 0;
  }
  if (SHIBYTE(v16) < 0) {
    operator delete(block);
  }
  return v6 != v5 && v2;
}

void sub_1005BACB0(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25)
{
  if (a25 < 0) {
    operator delete(__p);
  }
  sub_10006A6AC(a1);
}

BOOL sub_1005BACD4(uint64_t a1, int a2)
{
  signed int v14 = a2;
  v13[0] = a1;
  v13[1] = &v14;
  if (!*(void *)(a1 + 32))
  {
    BOOL v10 = 1;
LABEL_17:
    v15[0] = _NSConcreteStackBlock;
    v15[1] = 0x40000000;
    void v15[2] = sub_1005C20D8;
    _OWORD v15[3] = &unk_1019EB4B0;
    void v15[4] = a1 + 8;
    v15[5] = v13;
    unsigned __int8 v16 = v15;
    int v11 = *(NSObject **)(a1 + 24);
    unsigned __int8 v23 = 0;
    *(void *)std::string buf = _NSConcreteStackBlock;
    uint64_t v18 = 0x40000000;
    if (v10)
    {
      char v19 = sub_10005A0AC;
      char v20 = &unk_1019EB310;
      uint64_t v21 = &v23;
      uint64_t v22 = &v16;
      dispatch_sync(v11, buf);
    }
    else
    {
      char v19 = sub_10005AE10;
      char v20 = &unk_1019EB330;
      uint64_t v21 = &v23;
      uint64_t v22 = &v16;
      dispatch_async_and_wait(v11, buf);
    }
    int v12 = v23;
    return v12 != 0;
  }
  if ((dispatch_workloop_is_current() & 1) == 0)
  {
    BOOL v10 = *(void *)(a1 + 32) == 0;
    goto LABEL_17;
  }
  uint64_t v3 = *(void *)(a1 + 80);
  if (v3)
  {
    uint64_t v4 = a1 + 80;
    do
    {
      int v5 = *(_DWORD *)(v3 + 32);
      BOOL v6 = v5 < v14;
      if (v5 >= v14) {
        BOOL v7 = (uint64_t *)v3;
      }
      else {
        BOOL v7 = (uint64_t *)(v3 + 8);
      }
      if (!v6) {
        uint64_t v4 = v3;
      }
      uint64_t v3 = *v7;
    }
    while (*v7);
    if (v4 != a1 + 80 && v14 >= *(_DWORD *)(v4 + 32))
    {
      int v12 = *(unsigned __int8 *)(v4 + 41);
      return v12 != 0;
    }
  }
  int v8 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), v14);
  BOOL result = os_log_type_enabled(v8, OS_LOG_TYPE_ERROR);
  if (result)
  {
    *(_WORD *)std::string buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "fControllerSettings context invalid.", buf, 2u);
    return 0;
  }
  return result;
}

BOOL sub_1005BAEFC(uint64_t a1, int a2)
{
  signed int v14 = a2;
  v13[0] = a1;
  v13[1] = &v14;
  if (!*(void *)(a1 + 32))
  {
    BOOL v10 = 1;
LABEL_17:
    v15[0] = _NSConcreteStackBlock;
    v15[1] = 0x40000000;
    void v15[2] = sub_1005C21C0;
    _OWORD v15[3] = &unk_1019EB4D0;
    void v15[4] = a1 + 8;
    v15[5] = v13;
    unsigned __int8 v16 = v15;
    int v11 = *(NSObject **)(a1 + 24);
    unsigned __int8 v23 = 0;
    *(void *)std::string buf = _NSConcreteStackBlock;
    uint64_t v18 = 0x40000000;
    if (v10)
    {
      char v19 = sub_10005A0AC;
      char v20 = &unk_1019EB310;
      uint64_t v21 = &v23;
      uint64_t v22 = &v16;
      dispatch_sync(v11, buf);
    }
    else
    {
      char v19 = sub_10005AE10;
      char v20 = &unk_1019EB330;
      uint64_t v21 = &v23;
      uint64_t v22 = &v16;
      dispatch_async_and_wait(v11, buf);
    }
    int v12 = v23;
    return v12 != 0;
  }
  if ((dispatch_workloop_is_current() & 1) == 0)
  {
    BOOL v10 = *(void *)(a1 + 32) == 0;
    goto LABEL_17;
  }
  uint64_t v3 = *(void *)(a1 + 80);
  if (v3)
  {
    uint64_t v4 = a1 + 80;
    do
    {
      int v5 = *(_DWORD *)(v3 + 32);
      BOOL v6 = v5 < v14;
      if (v5 >= v14) {
        BOOL v7 = (uint64_t *)v3;
      }
      else {
        BOOL v7 = (uint64_t *)(v3 + 8);
      }
      if (!v6) {
        uint64_t v4 = v3;
      }
      uint64_t v3 = *v7;
    }
    while (*v7);
    if (v4 != a1 + 80 && v14 >= *(_DWORD *)(v4 + 32))
    {
      int v12 = *(unsigned __int8 *)(v4 + 40);
      return v12 != 0;
    }
  }
  int v8 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), v14);
  BOOL result = os_log_type_enabled(v8, OS_LOG_TYPE_ERROR);
  if (result)
  {
    *(_WORD *)std::string buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "fControllerSettings context invalid.", buf, 2u);
    return 0;
  }
  return result;
}

BOOL sub_1005BB124(uint64_t a1, int a2)
{
  int v8 = a2;
  v7[0] = a1;
  v7[1] = &v8;
  if (*(void *)(a1 + 32))
  {
    if (dispatch_workloop_is_current())
    {
      int v3 = *(unsigned __int8 *)sub_10012EF5C(a1 + 240, &v8);
      return v3 != 0;
    }
    BOOL v4 = *(void *)(a1 + 32) == 0;
  }
  else
  {
    BOOL v4 = 1;
  }
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 0x40000000;
  v9[2] = sub_1005C22A8;
  v9[3] = &unk_1019EB4F0;
  void v9[4] = a1 + 8;
  v9[5] = v7;
  BOOL v10 = v9;
  int v5 = *(NSObject **)(a1 + 24);
  unsigned __int8 v16 = 0;
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  if (v4)
  {
    int v12 = sub_10005A0AC;
    unsigned int v13 = &unk_1019EB310;
    signed int v14 = &v16;
    uint64_t v15 = &v10;
    dispatch_sync(v5, block);
  }
  else
  {
    int v12 = sub_10005AE10;
    unsigned int v13 = &unk_1019EB330;
    signed int v14 = &v16;
    uint64_t v15 = &v10;
    dispatch_async_and_wait(v5, block);
  }
  int v3 = v16;
  return v3 != 0;
}

BOOL sub_1005BB2A8(uint64_t a1, int a2)
{
  int v8 = a2;
  v7[0] = a1;
  v7[1] = &v8;
  if (*(void *)(a1 + 32))
  {
    if (dispatch_workloop_is_current())
    {
      int v3 = *(unsigned __int8 *)sub_10012EF5C(a1 + 264, &v8);
      return v3 != 0;
    }
    BOOL v4 = *(void *)(a1 + 32) == 0;
  }
  else
  {
    BOOL v4 = 1;
  }
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 0x40000000;
  v9[2] = sub_1005C22D0;
  v9[3] = &unk_1019EB510;
  void v9[4] = a1 + 8;
  v9[5] = v7;
  BOOL v10 = v9;
  int v5 = *(NSObject **)(a1 + 24);
  unsigned __int8 v16 = 0;
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  if (v4)
  {
    int v12 = sub_10005A0AC;
    unsigned int v13 = &unk_1019EB310;
    signed int v14 = &v16;
    uint64_t v15 = &v10;
    dispatch_sync(v5, block);
  }
  else
  {
    int v12 = sub_10005AE10;
    unsigned int v13 = &unk_1019EB330;
    signed int v14 = &v16;
    uint64_t v15 = &v10;
    dispatch_async_and_wait(v5, block);
  }
  int v3 = v16;
  return v3 != 0;
}

BOOL sub_1005BB42C(uint64_t a1, int a2)
{
  int v8 = a2;
  v7[0] = a1;
  v7[1] = &v8;
  if (*(void *)(a1 + 32))
  {
    if (dispatch_workloop_is_current())
    {
      int v3 = *(unsigned __int8 *)sub_10012EF5C(a1 + 288, &v8);
      return v3 != 0;
    }
    BOOL v4 = *(void *)(a1 + 32) == 0;
  }
  else
  {
    BOOL v4 = 1;
  }
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 0x40000000;
  v9[2] = sub_1005C22F8;
  v9[3] = &unk_1019EB530;
  void v9[4] = a1 + 8;
  v9[5] = v7;
  BOOL v10 = v9;
  int v5 = *(NSObject **)(a1 + 24);
  unsigned __int8 v16 = 0;
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  if (v4)
  {
    int v12 = sub_10005A0AC;
    unsigned int v13 = &unk_1019EB310;
    signed int v14 = &v16;
    uint64_t v15 = &v10;
    dispatch_sync(v5, block);
  }
  else
  {
    int v12 = sub_10005AE10;
    unsigned int v13 = &unk_1019EB330;
    signed int v14 = &v16;
    uint64_t v15 = &v10;
    dispatch_async_and_wait(v5, block);
  }
  int v3 = v16;
  return v3 != 0;
}

BOOL sub_1005BB5B0(void *a1, int a2)
{
  int v13 = a2;
  v12[0] = a1;
  v12[1] = &v13;
  if (!a1[4])
  {
    BOOL v9 = 1;
LABEL_16:
    v14[0] = _NSConcreteStackBlock;
    v14[1] = 0x40000000;
    void v14[2] = sub_1005C2320;
    uint64_t v14[3] = &unk_1019EB550;
    v14[4] = a1 + 1;
    v14[5] = v12;
    uint64_t v15 = v14;
    BOOL v10 = a1[3];
    unsigned __int8 v21 = 0;
    block[0] = _NSConcreteStackBlock;
    block[1] = 0x40000000;
    if (v9)
    {
      char v17 = sub_10005A0AC;
      uint64_t v18 = &unk_1019EB310;
      char v19 = &v21;
      char v20 = &v15;
      dispatch_sync(v10, block);
    }
    else
    {
      char v17 = sub_10005AE10;
      uint64_t v18 = &unk_1019EB330;
      char v19 = &v21;
      char v20 = &v15;
      dispatch_async_and_wait(v10, block);
    }
    int v11 = v21;
    return v11 != 0;
  }
  if ((dispatch_workloop_is_current() & 1) == 0)
  {
    BOOL v9 = a1[4] == 0;
    goto LABEL_16;
  }
  uint64_t v3 = a1[75];
  if (!v3) {
    return 0;
  }
  BOOL v4 = a1 + 75;
  do
  {
    int v5 = *(_DWORD *)(v3 + 28);
    BOOL v6 = v5 < v13;
    if (v5 >= v13) {
      BOOL v7 = (uint64_t *)v3;
    }
    else {
      BOOL v7 = (uint64_t *)(v3 + 8);
    }
    if (!v6) {
      BOOL v4 = (void *)v3;
    }
    uint64_t v3 = *v7;
  }
  while (*v7);
  if (v4 == a1 + 75 || v13 < *((_DWORD *)v4 + 7)) {
    return 0;
  }
  int v11 = *((unsigned __int8 *)v4 + 32);
  return v11 != 0;
}

void sub_1005BB770(void *a1@<X0>, int a2@<W1>, uint64_t a3@<X8>)
{
  int v14 = a2;
  v13[0] = a1;
  v13[1] = &v14;
  if (!a1[4])
  {
    BOOL v10 = 1;
    goto LABEL_16;
  }
  if ((dispatch_workloop_is_current() & 1) == 0)
  {
    BOOL v10 = a1[4] == 0;
LABEL_16:
    v15[0] = _NSConcreteStackBlock;
    v15[1] = 0x40000000;
    void v15[2] = sub_1005C2388;
    _OWORD v15[3] = &unk_1019EB570;
    void v15[4] = a1 + 1;
    v15[5] = v13;
    unsigned __int8 v16 = v15;
    int v11 = a1[3];
    *(void *)a3 = 0;
    *(void *)(a3 + 8) = 0;
    *(void *)(a3 + 16) = 0;
    block[0] = _NSConcreteStackBlock;
    block[1] = 0x40000000;
    if (v10)
    {
      uint64_t v18 = sub_100003DFC;
      char v19 = &unk_1019EB590;
      uint64_t v20 = a3;
      unsigned __int8 v21 = &v16;
      dispatch_sync(v11, block);
    }
    else
    {
      uint64_t v18 = sub_1005C240C;
      char v19 = &unk_1019EB5B0;
      uint64_t v20 = a3;
      unsigned __int8 v21 = &v16;
      dispatch_async_and_wait(v11, block);
    }
    return;
  }
  uint64_t v5 = a1[72];
  if (!v5) {
    goto LABEL_13;
  }
  BOOL v6 = a1 + 72;
  do
  {
    int v7 = *(_DWORD *)(v5 + 32);
    BOOL v8 = v7 < v14;
    if (v7 >= v14) {
      BOOL v9 = (uint64_t *)v5;
    }
    else {
      BOOL v9 = (uint64_t *)(v5 + 8);
    }
    if (!v8) {
      BOOL v6 = (void *)v5;
    }
    uint64_t v5 = *v9;
  }
  while (*v9);
  if (v6 != a1 + 72 && v14 >= *((_DWORD *)v6 + 8))
  {
    if (*((char *)v6 + 63) < 0)
    {
      sub_10004FC84((unsigned char *)a3, (void *)v6[5], v6[6]);
    }
    else
    {
      long long v12 = *(_OWORD *)(v6 + 5);
      *(void *)(a3 + 16) = v6[7];
      *(_OWORD *)a3 = v12;
    }
  }
  else
  {
LABEL_13:
    *(void *)a3 = 0;
    *(void *)(a3 + 8) = 0;
    *(void *)(a3 + 16) = 0;
  }
}

BOOL sub_1005BB954(uint64_t a1, int a2)
{
  int v7 = a2;
  v6[0] = (int *)a1;
  v6[1] = &v7;
  if (*(void *)(a1 + 32))
  {
    if (dispatch_workloop_is_current()) {
      return sub_1005C2470(v6);
    }
    BOOL v4 = *(void *)(a1 + 32) == 0;
  }
  else
  {
    BOOL v4 = 1;
  }
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 0x40000000;
  void v8[2] = sub_1005C26A8;
  void v8[3] = &unk_1019EB5D0;
  void v8[4] = a1 + 8;
  void v8[5] = v6;
  BOOL v9 = v8;
  uint64_t v5 = *(NSObject **)(a1 + 24);
  char v15 = 0;
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  if (v4)
  {
    int v11 = sub_10005A0AC;
    long long v12 = &unk_1019EB310;
    int v13 = &v15;
    int v14 = &v9;
    dispatch_sync(v5, block);
  }
  else
  {
    int v11 = sub_10005AE10;
    long long v12 = &unk_1019EB330;
    int v13 = &v15;
    int v14 = &v9;
    dispatch_async_and_wait(v5, block);
  }
  return v15 != 0;
}

BOOL sub_1005BBAD0(uint64_t a1)
{
  uint64_t v5 = a1;
  if (*(void *)(a1 + 32))
  {
    if (dispatch_workloop_is_current()) {
      return sub_1005C26B0(a1);
    }
    BOOL v3 = *(void *)(a1 + 32) == 0;
  }
  else
  {
    BOOL v3 = 1;
  }
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 0x40000000;
  void v6[2] = sub_1005C27EC;
  v6[3] = &unk_1019EB5F0;
  void v6[4] = a1 + 8;
  void v6[5] = &v5;
  int v7 = v6;
  BOOL v4 = *(NSObject **)(a1 + 24);
  char v13 = 0;
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  if (v3)
  {
    BOOL v9 = sub_10005A0AC;
    BOOL v10 = &unk_1019EB310;
    int v11 = &v13;
    long long v12 = &v7;
    dispatch_sync(v4, block);
  }
  else
  {
    BOOL v9 = sub_10005AE10;
    BOOL v10 = &unk_1019EB330;
    int v11 = &v13;
    long long v12 = &v7;
    dispatch_async_and_wait(v4, block);
  }
  return v13 != 0;
}

uint64_t sub_1005BBC44(uint64_t a1, int a2)
{
  int v7 = a2;
  v6[0] = (int *)a1;
  v6[1] = &v7;
  if (*(void *)(a1 + 32))
  {
    if (dispatch_workloop_is_current()) {
      return sub_1005C27F8(v6);
    }
    BOOL v4 = *(void *)(a1 + 32) == 0;
  }
  else
  {
    BOOL v4 = 1;
  }
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 0x40000000;
  void v8[2] = sub_1005C2900;
  void v8[3] = &unk_1019EB610;
  void v8[4] = a1 + 8;
  void v8[5] = v6;
  BOOL v9 = v8;
  uint64_t v5 = *(NSObject **)(a1 + 24);
  char v15 = 0;
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  if (v4)
  {
    int v11 = sub_10005A0AC;
    long long v12 = &unk_1019EB310;
    char v13 = &v15;
    int v14 = &v9;
    dispatch_sync(v5, block);
  }
  else
  {
    int v11 = sub_10005AE10;
    long long v12 = &unk_1019EB330;
    char v13 = &v15;
    int v14 = &v9;
    dispatch_async_and_wait(v5, block);
  }
  return v15 != 0;
}

uint64_t sub_1005BBDC0(uint64_t a1, uint64_t a2, unsigned __int8 a3)
{
  uint64_t v9 = a2;
  unsigned __int8 v8 = a3;
  v7[0] = a1;
  v7[1] = &v9;
  void v7[2] = &v8;
  if (*(void *)(a1 + 32))
  {
    if (dispatch_workloop_is_current()) {
      return (*(uint64_t (**)(void, uint64_t, void))(**(void **)(a1 + 96) + 32))(*(void *)(a1 + 96), v9, v8);
    }
    BOOL v5 = *(void *)(a1 + 32) == 0;
  }
  else
  {
    BOOL v5 = 1;
  }
  v10[0] = _NSConcreteStackBlock;
  v10[1] = 0x40000000;
  void v10[2] = sub_1005C2908;
  void v10[3] = &unk_1019EB630;
  void v10[4] = a1 + 8;
  void v10[5] = v7;
  int v11 = v10;
  BOOL v6 = *(NSObject **)(a1 + 24);
  char v17 = 0;
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  if (v5)
  {
    char v13 = sub_10005A0AC;
    int v14 = &unk_1019EB310;
    char v15 = &v17;
    unsigned __int8 v16 = &v11;
    dispatch_sync(v6, block);
  }
  else
  {
    char v13 = sub_10005AE10;
    int v14 = &unk_1019EB330;
    char v15 = &v17;
    unsigned __int8 v16 = &v11;
    dispatch_async_and_wait(v6, block);
  }
  return v17 != 0;
}

uint64_t sub_1005BBF70(uint64_t a1, int a2)
{
  sub_10005666C(a1, a2, &v8);
  if (v8)
  {
    sub_10005666C(a1, a2, &v6);
    uint64_t v4 = (*(uint64_t (**)(uint64_t))(*(void *)v6 + 136))(v6);
    if (v7) {
      sub_10004D2C8(v7);
    }
  }
  else
  {
    uint64_t v4 = 0xFFFFFFFFLL;
  }
  if (v9) {
    sub_10004D2C8(v9);
  }
  return v4;
}

void sub_1005BC00C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  if (a12) {
    sub_10004D2C8(a12);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1005BC038(uint64_t a1, int a2)
{
  sub_10005666C(a1, a2, &v8);
  if (v8)
  {
    sub_10005666C(a1, a2, &v6);
    uint64_t v4 = (*(uint64_t (**)(uint64_t))(*(void *)v6 + 152))(v6);
    if (v7) {
      sub_10004D2C8(v7);
    }
  }
  else
  {
    uint64_t v4 = 0xFFFFFFFFLL;
  }
  if (v9) {
    sub_10004D2C8(v9);
  }
  return v4;
}

void sub_1005BC0D4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  if (a12) {
    sub_10004D2C8(a12);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_1005BC100(uint64_t a1, int a2)
{
  int v8 = a2;
  v7[0] = a1;
  v7[1] = &v8;
  if (*(void *)(a1 + 32))
  {
    if (dispatch_workloop_is_current())
    {
      int v3 = *(unsigned __int8 *)sub_1000389F8(*(uint64_t **)(a1 + 320), v8);
      return v3 != 0;
    }
    BOOL v4 = *(void *)(a1 + 32) == 0;
  }
  else
  {
    BOOL v4 = 1;
  }
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 0x40000000;
  v9[2] = sub_1005C2944;
  v9[3] = &unk_1019EB650;
  void v9[4] = a1 + 8;
  v9[5] = v7;
  BOOL v10 = v9;
  BOOL v5 = *(NSObject **)(a1 + 24);
  unsigned __int8 v16 = 0;
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  if (v4)
  {
    long long v12 = sub_10005A0AC;
    char v13 = &unk_1019EB310;
    int v14 = &v16;
    char v15 = &v10;
    dispatch_sync(v5, block);
  }
  else
  {
    long long v12 = sub_10005AE10;
    char v13 = &unk_1019EB330;
    int v14 = &v16;
    char v15 = &v10;
    dispatch_async_and_wait(v5, block);
  }
  int v3 = v16;
  return v3 != 0;
}

uint64_t sub_1005BC284(uint64_t a1, int a2)
{
  int v7 = a2;
  v6[0] = a1;
  v6[1] = &v7;
  if (*(void *)(a1 + 32))
  {
    if (dispatch_workloop_is_current()) {
      return sub_1000389F8(*(uint64_t **)(a1 + 320), v7)[1];
    }
    BOOL v4 = *(void *)(a1 + 32) == 0;
  }
  else
  {
    BOOL v4 = 1;
  }
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 0x40000000;
  void v8[2] = sub_1005C2970;
  void v8[3] = &unk_1019EB670;
  void v8[4] = a1 + 8;
  void v8[5] = v6;
  uint64_t v9 = v8;
  BOOL v5 = *(NSObject **)(a1 + 24);
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  if (v4)
  {
    int v11 = sub_1005C299C;
    long long v12 = &unk_1019EB690;
    char v13 = &v15;
    int v14 = &v9;
    uint64_t v15 = 0;
    dispatch_sync(v5, block);
  }
  else
  {
    int v11 = sub_1005C29D8;
    long long v12 = &unk_1019EB6B0;
    char v13 = &v15;
    int v14 = &v9;
    uint64_t v15 = 0;
    dispatch_async_and_wait(v5, block);
  }
  return v15;
}

BOOL sub_1005BC400(uint64_t a1, int a2)
{
  int v9 = a2;
  v8[0] = a1;
  v8[1] = &v9;
  if (*(void *)(a1 + 32))
  {
    if (dispatch_workloop_is_current())
    {
      int v3 = sub_1000389F8(*(uint64_t **)(a1 + 320), v9);
      if (*(unsigned char *)v3) {
        BOOL v4 = v3[1] < 0;
      }
      else {
        BOOL v4 = 1;
      }
      return !v4;
    }
    BOOL v6 = *(void *)(a1 + 32) == 0;
  }
  else
  {
    BOOL v6 = 1;
  }
  v10[0] = _NSConcreteStackBlock;
  v10[1] = 0x40000000;
  void v10[2] = sub_1005C2A14;
  void v10[3] = &unk_1019EB6D0;
  void v10[4] = a1 + 8;
  void v10[5] = v8;
  int v11 = v10;
  int v7 = *(NSObject **)(a1 + 24);
  char v17 = 0;
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  if (v6)
  {
    char v13 = sub_10005A0AC;
    int v14 = &unk_1019EB310;
    uint64_t v15 = &v17;
    unsigned __int8 v16 = &v11;
    dispatch_sync(v7, block);
  }
  else
  {
    char v13 = sub_10005AE10;
    int v14 = &unk_1019EB330;
    uint64_t v15 = &v17;
    unsigned __int8 v16 = &v11;
    dispatch_async_and_wait(v7, block);
  }
  return v17 != 0;
}

uint64_t sub_1005BC594(uint64_t a1, int a2)
{
  int v7 = a2;
  v6[0] = a1;
  v6[1] = &v7;
  if (*(void *)(a1 + 32))
  {
    if (dispatch_workloop_is_current()) {
      return *(unsigned int *)sub_1000FA5F4(*(uint64_t **)(a1 + 344), v7);
    }
    BOOL v4 = *(void *)(a1 + 32) == 0;
  }
  else
  {
    BOOL v4 = 1;
  }
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 0x40000000;
  void v8[2] = sub_1005C2A50;
  void v8[3] = &unk_1019EB6F0;
  void v8[4] = a1 + 8;
  void v8[5] = v6;
  int v9 = v8;
  BOOL v5 = *(NSObject **)(a1 + 24);
  unsigned int v15 = 0;
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  if (v4)
  {
    int v11 = sub_1005C2A7C;
    long long v12 = &unk_1019EB710;
    char v13 = &v15;
    int v14 = &v9;
    dispatch_sync(v5, block);
  }
  else
  {
    int v11 = sub_1005C2AB8;
    long long v12 = &unk_1019EB730;
    char v13 = &v15;
    int v14 = &v9;
    dispatch_async_and_wait(v5, block);
  }
  return v15;
}

uint64_t sub_1005BC710(uint64_t a1, int a2)
{
  int v7 = a2;
  v6[0] = (_DWORD *)a1;
  v6[1] = &v7;
  if (*(void *)(a1 + 32))
  {
    if (dispatch_workloop_is_current()) {
      return sub_1005C2AF4(v6);
    }
    BOOL v4 = *(void *)(a1 + 32) == 0;
  }
  else
  {
    BOOL v4 = 1;
  }
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 0x40000000;
  void v8[2] = sub_1005C2BEC;
  void v8[3] = &unk_1019EB750;
  void v8[4] = a1 + 8;
  void v8[5] = v6;
  int v9 = v8;
  BOOL v5 = *(NSObject **)(a1 + 24);
  unsigned int v15 = 0;
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  if (v4)
  {
    int v11 = sub_1005C2BF4;
    long long v12 = &unk_1019EB770;
    char v13 = &v15;
    int v14 = &v9;
    dispatch_sync(v5, block);
  }
  else
  {
    int v11 = sub_1005C2C30;
    long long v12 = &unk_1019EB790;
    char v13 = &v15;
    int v14 = &v9;
    dispatch_async_and_wait(v5, block);
  }
  return v15;
}

void sub_1005BC884(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X2>, std::__shared_weak_count **a4@<X8>)
{
  void (***v16)(std::string **__return_ptr, void, std::string *);
  char v17;
  NSObject *v18;
  std::mutex *v19;
  std::mutex *v20;
  std::string::size_type v21;
  unsigned __int8 *v22;
  uint64_t v23;
  unsigned int v24;
  void *v25;
  std::__shared_weak_count *v26;
  uint64_t v27;
  char v28;
  uint64_t v29;
  std::__shared_weak_count *v30;
  std::__shared_weak_count *v31;
  uint64_t v32;
  std::__shared_weak_count *v33;
  std::__shared_weak_count *shared_weak_owners;
  uint64_t v35;
  void *v36[2];
  uint64_t v37;
  std::string v38;
  std::string *__str[2];
  uint64_t v40;
  void v41[2];
  void v42[2];
  std::string __p;

  memset(&v38, 0, sizeof(v38));
  sub_100058DB0(&v38, "");
  __str[0] = 0;
  __str[1] = 0;
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 56));
  int v9 = ServiceMap;
  if ((v10 & 0x8000000000000000) != 0)
  {
    int v11 = (unsigned __int8 *)(v10 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v12 = 5381;
    do
    {
      std::string::size_type v10 = v12;
      unsigned int v13 = *v11++;
      uint64_t v12 = (33 * v12) ^ v13;
    }
    while (v13);
  }
  std::mutex::lock(ServiceMap);
  __p.__r_.__value_.__r.__words[0] = v10;
  int v14 = sub_10004D37C(&v9[1].__m_.__sig, (unint64_t *)&__p);
  if (v14)
  {
    unsigned __int8 v16 = (void (***)(std::string **__return_ptr, void, std::string *))v14[3];
    unsigned int v15 = (std::__shared_weak_count *)v14[4];
    if (v15)
    {
      atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v9);
      atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v15);
      char v17 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    unsigned __int8 v16 = 0;
  }
  std::mutex::unlock(v9);
  unsigned int v15 = 0;
  char v17 = 1;
LABEL_9:
  PersonalityIdFromSlotId();
  (**v16)(__str, v16, &__p);
  if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    if (v17) {
      goto LABEL_12;
    }
    goto LABEL_11;
  }
  operator delete(__p.__r_.__value_.__l.__data_);
  if ((v17 & 1) == 0) {
LABEL_11:
  }
    sub_10004D2C8(v15);
LABEL_12:
  if (__str[0])
  {
    std::string::operator=(&v38, __str[0]);
  }
  else
  {
    uint64_t v18 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      int v35 = subscriber::asString();
      LODWORD(__p.__r_.__value_.__l.__data_) = 136315138;
      *(std::string::size_type *)((char *)__p.__r_.__value_.__r.__words + 4) = v35;
      _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "SIM slot %s has no associated personality UUID.", (uint8_t *)&__p, 0xCu);
    }
  }
  if (__str[1]) {
    sub_10004D2C8((std::__shared_weak_count *)__str[1]);
  }
  char v19 = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 56));
  uint64_t v20 = v19;
  if ((v21 & 0x8000000000000000) != 0)
  {
    uint64_t v22 = (unsigned __int8 *)(v21 & 0x7FFFFFFFFFFFFFFFLL);
    unsigned __int8 v23 = 5381;
    do
    {
      unsigned __int8 v21 = v23;
      BOOL v24 = *v22++;
      unsigned __int8 v23 = (33 * v23) ^ v24;
    }
    while (v24);
  }
  std::mutex::lock(v19);
  __p.__r_.__value_.__r.__words[0] = v21;
  BOOL v25 = sub_10004D37C(&v20[1].__m_.__sig, (unint64_t *)&__p);
  if (v25)
  {
    uint64_t v27 = v25[3];
    uint64_t v26 = (std::__shared_weak_count *)v25[4];
    if (v26)
    {
      atomic_fetch_add_explicit(&v26->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v20);
      atomic_fetch_add_explicit(&v26->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v26);
      uint64_t v28 = 0;
      goto LABEL_28;
    }
  }
  else
  {
    uint64_t v27 = 0;
  }
  std::mutex::unlock(v20);
  uint64_t v26 = 0;
  uint64_t v28 = 1;
LABEL_28:
  uint64_t v29 = (*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), a2);
  sub_1005BB770((void *)a1, a2, (uint64_t)v36);
  int v30 = (std::__shared_weak_count *)operator new(0x120uLL);
  v30->__shared_owners_ = 0;
  v30->__shared_weak_owners_ = 0;
  v30->__vftable = (std::__shared_weak_count_vtbl *)off_1019EB7C0;
  v42[0] = v27;
  v42[1] = v26;
  if ((v28 & 1) == 0) {
    atomic_fetch_add_explicit(&v26->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (SHIBYTE(v38.__r_.__value_.__r.__words[2]) < 0) {
    sub_10004FC84(&__p, v38.__r_.__value_.__l.__data_, v38.__r_.__value_.__l.__size_);
  }
  else {
    __n128 __p = v38;
  }
  BOOL v31 = v30 + 1;
  uint64_t v32 = *a3;
  unint64_t v33 = (std::__shared_weak_count *)a3[1];
  v41[0] = v32;
  v41[1] = v33;
  if (v33) {
    atomic_fetch_add_explicit(&v33->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  *(_OWORD *)std::string __str = *(_OWORD *)v36;
  uint64_t v40 = v37;
  v36[1] = 0;
  long long v37 = 0;
  v36[0] = 0;
  MMSServerConnection::MMSServerConnection((uint64_t)&v30[1], a2, v42, (long long *)&__p, v41, v29, (long long *)__str);
  if (SHIBYTE(v40) < 0) {
    operator delete(__str[0]);
  }
  if (v33) {
    sub_10004D2C8(v33);
  }
  if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    if (v28) {
      goto LABEL_42;
    }
    goto LABEL_41;
  }
  operator delete(__p.__r_.__value_.__l.__data_);
  if ((v28 & 1) == 0) {
LABEL_41:
  }
    sub_10004D2C8(v26);
LABEL_42:
  shared_weak_owners = (std::__shared_weak_count *)v30[1].__shared_weak_owners_;
  if (shared_weak_owners)
  {
    if (shared_weak_owners->__shared_owners_ != -1) {
      goto LABEL_49;
    }
    atomic_fetch_add_explicit(&v30->__shared_owners_, 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit(&v30->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    v30[1].__shared_owners_ = (uint64_t)v31;
    v30[1].__shared_weak_owners_ = (uint64_t)v30;
    std::__shared_weak_count::__release_weak(shared_weak_owners);
  }
  else
  {
    atomic_fetch_add_explicit(&v30->__shared_owners_, 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit(&v30->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    v30[1].__shared_owners_ = (uint64_t)v31;
    v30[1].__shared_weak_owners_ = (uint64_t)v30;
  }
  sub_10004D2C8(v30);
LABEL_49:
  *a4 = v31;
  a4[1] = v30;
  if ((SHIBYTE(v37) & 0x80000000) == 0)
  {
    if (v28) {
      goto LABEL_52;
    }
    goto LABEL_51;
  }
  operator delete(v36[0]);
  if ((v28 & 1) == 0) {
LABEL_51:
  }
    sub_10004D2C8(v26);
LABEL_52:
  if (SHIBYTE(v38.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v38.__r_.__value_.__l.__data_);
  }
}

void sub_1005BCD20(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,std::__shared_weak_count *a22,int a23,__int16 a24,char a25,char a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,void *a32,uint64_t a33,int a34,__int16 a35,char a36,char a37)
{
  if (a22) {
    sub_10004D2C8(a22);
  }
  if (a20 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1005BCE1C(uint64_t a1, char a2)
{
  char v6 = a2;
  v5[0] = a1;
  v5[1] = &v6;
  if (*(void *)(a1 + 32))
  {
    if (dispatch_workloop_is_current())
    {
      *(unsigned char *)(a1 + 720) = v6;
      return;
    }
    BOOL v3 = *(void *)(a1 + 32) == 0;
  }
  else
  {
    BOOL v3 = 1;
  }
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  void block[2] = sub_1005C2D08;
  block[3] = &unk_1019EB800;
  block[4] = a1 + 8;
  block[5] = v5;
  BOOL v4 = *(NSObject **)(a1 + 24);
  if (v3) {
    dispatch_sync(v4, block);
  }
  else {
    dispatch_async_and_wait(v4, block);
  }
}

void sub_1005BCEEC(uint64_t a1)
{
  sub_1005BCF24(a1);

  operator delete();
}

void sub_1005BCF24(uint64_t a1)
{
  *(void *)a1 = off_1019EA8F8;
  sub_10003FB28(a1 + 696, *(void **)(a1 + 704));
  NotifySubscription::~NotifySubscription((NotifySubscription *)(a1 + 672));
  sub_10026CF54(a1 + 640, *(void **)(a1 + 648));
  sub_1000346F8(a1 + 616, *(void **)(a1 + 624));
  sub_1000346F8(a1 + 592, *(void **)(a1 + 600));
  sub_100087ED0(a1 + 568, *(void **)(a1 + 576));
  sub_10005CD2C(a1 + 544, *(char **)(a1 + 552));
  EmergencyMode::~EmergencyMode((EmergencyMode *)(a1 + 524));
  sub_10024D10C(a1 + 496, *(void **)(a1 + 504));
  sub_1000346F8(a1 + 472, *(void **)(a1 + 480));
  sub_100087F94(a1 + 440, *(void **)(a1 + 448));
  sub_1000346F8(a1 + 408, *(void **)(a1 + 416));
  sub_10041A760((void *)(a1 + 376));
  BOOL v2 = *(std::__shared_weak_count **)(a1 + 368);
  if (v2) {
    sub_10004D2C8(v2);
  }
  sub_1000346F8(a1 + 336, *(void **)(a1 + 344));
  sub_10005D144(*(void **)(a1 + 320));
  sub_1000346F8(a1 + 288, *(void **)(a1 + 296));
  sub_1000346F8(a1 + 264, *(void **)(a1 + 272));
  sub_1000346F8(a1 + 240, *(void **)(a1 + 248));
  sub_1000346F8(a1 + 216, *(void **)(a1 + 224));
  sub_1000346F8(a1 + 192, *(void **)(a1 + 200));
  sub_1000346F8(a1 + 168, *(void **)(a1 + 176));
  sub_10005D144(*(void **)(a1 + 152));
  sub_100119D90(*(void **)(a1 + 120));
  uint64_t v3 = *(void *)(a1 + 104);
  *(void *)(a1 + 104) = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  uint64_t v4 = *(void *)(a1 + 96);
  *(void *)(a1 + 96) = 0;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
  }
  sub_10005D144(*(void **)(a1 + 80));
  BOOL v5 = *(std::__shared_weak_count **)(a1 + 64);
  if (v5) {
    sub_10004D2C8(v5);
  }
  uint64_t v6 = *(void *)(a1 + 48);
  *(void *)(a1 + 48) = 0;
  if (v6) {
    (*(void (**)(uint64_t))(*(void *)v6 + 8))(v6);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 40));
  sub_100087E88((void *)(a1 + 8));

  MMSDataCacheInterface::~MMSDataCacheInterface((MMSDataCacheInterface *)a1);
}

void sub_1005BD13C()
{
}

uint64_t sub_1005BD150(uint64_t a1)
{
  return *(void *)(a1 + 8) + 40;
}

uint64_t *sub_1005BD15C(uint64_t *a1, uint64_t a2)
{
  a1[2] = 0;
  a1[1] = 0;
  *a1 = (uint64_t)(a1 + 1);
  sub_1005BD1B4(a1, *(int **)a2, (int *)(a2 + 8));
  return a1;
}

void sub_1005BD19C(_Unwind_Exception *a1)
{
  sub_10003FB28(v1, *(void **)(v1 + 8));
  _Unwind_Resume(a1);
}

uint64_t *sub_1005BD1B4(uint64_t *result, int *a2, int *a3)
{
  if (a2 != a3)
  {
    uint64_t v4 = a2;
    BOOL v5 = (uint64_t **)result;
    uint64_t v6 = result + 1;
    do
    {
      BOOL result = sub_1005BD240(v5, v6, v4 + 8, (uint64_t)(v4 + 8));
      int v7 = (int *)*((void *)v4 + 1);
      if (v7)
      {
        do
        {
          int v8 = v7;
          int v7 = *(int **)v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          int v8 = (int *)*((void *)v4 + 2);
          BOOL v9 = *(void *)v8 == (void)v4;
          uint64_t v4 = v8;
        }
        while (!v9);
      }
      uint64_t v4 = v8;
    }
    while (v8 != a3);
  }
  return result;
}

uint64_t *sub_1005BD240(uint64_t **a1, uint64_t *a2, int *a3, uint64_t a4)
{
  uint64_t v11 = 0;
  uint64_t v12 = 0;
  uint64_t v6 = sub_1000262C0(a1, a2, &v12, &v11, a3);
  int v7 = (uint64_t *)*v6;
  if (!*v6)
  {
    int v8 = (uint64_t **)v6;
    memset(v10, 0, sizeof(v10));
    sub_1005BD2E4((uint64_t)a1, a4, v10);
    sub_100046C38(a1, (uint64_t)v12, v8, v10[0]);
    int v7 = v10[0];
    v10[0] = 0;
    sub_10003FD44((uint64_t)v10, 0);
  }
  return v7;
}

uint64_t sub_1005BD2E4@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  uint64_t v5 = a1 + 8;
  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  uint64_t v6 = operator new(0x70uLL);
  *a3 = v6;
  a3[1] = v5;
  *((unsigned char *)a3 + 16) = 0;
  uint64_t result = sub_1005BD358((uint64_t)v6 + 32, a2);
  *((unsigned char *)a3 + 16) = 1;
  return result;
}

void sub_1005BD340(_Unwind_Exception *a1)
{
  sub_10003FD44(v1, 0);
  _Unwind_Resume(a1);
}

uint64_t sub_1005BD358(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (const MCC *)(a2 + 40);
  *(_DWORD *)a1 = *(_DWORD *)a2;
  uint64_t v5 = (MCC *)(a1 + 40);
  MCC::MCC((MCC *)(a1 + 8), (const MCC *)(a2 + 8));
  MCC::MCC(v5, v4);
  int v6 = *(_DWORD *)(a2 + 72);
  *(_WORD *)(a1 + 76) = *(_WORD *)(a2 + 76);
  *(_DWORD *)(a1 + 72) = v6;
  return a1;
}

void sub_1005BD3C0(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 39) < 0) {
    operator delete(*(void **)(v1 + 16));
  }
  _Unwind_Resume(exception_object);
}

void sub_1005BD3E0(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_1005BD418(uint64_t a1)
{
}

uint64_t sub_1005BD434(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_1005BD478(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void sub_1005BD4A4(ServiceManager::Service *this)
{
  *(void *)this = off_1019EAB80;
  BOOL v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }

  ServiceManager::Service::~Service(this);
}

void sub_1005BD500(ServiceManager::Service *this)
{
  *(void *)this = off_1019EAB80;
  BOOL v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    sub_10004D2C8(v2);
  }
  ServiceManager::Service::~Service(this);

  operator delete();
}

void *sub_1005BD570@<X0>(void *a1@<X8>)
{
  return sub_100058DB0(a1, "msg.mms.mdc");
}

unsigned char *sub_1005BD580@<X0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  BOOL v2 = operator new(1uLL);
  *a1 = v2;
  unsigned char *v2 = 2;
  uint64_t result = v2 + 1;
  a1[1] = result;
  a1[2] = result;
  return result;
}

void sub_1005BD5C0(uint64_t a1, dispatch_object_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v3 = *a2;
  if (*a2)
  {
    dispatch_retain(*a2);
    dispatch_group_enter(v3);
    sub_1005B7F28(v2, v3);
  }
  uint64_t v4 = *(void *)(a1 + 8);

  sub_1005B7F28(v4, 0);
}

uint64_t sub_1005BD644()
{
  return 0;
}

uint64_t sub_1005BD64C()
{
  return 1;
}

uint64_t sub_1005BD654()
{
  return 0;
}

void sub_1005BD660(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(*(void *)(a1 + 8) + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_1005BD740(uint64_t a1, int a2, ServiceStage *this)
{
  uint64_t v3 = *(void *)(a1 + 8);
  ServiceStage::holdOffStage((uint64_t *)&group[1], this);
  uint64_t v4 = *(std::__shared_weak_count **)(v3 + 16);
  if (v4)
  {
    if (std::__shared_weak_count::lock(v4)) {
      operator new();
    }
  }
  sub_100088B9C();
}

uint64_t **sub_1005BD854(uint64_t **a1, int a2, _DWORD *a3)
{
  int v6 = a1 + 1;
  uint64_t v5 = a1[1];
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        int v7 = (uint64_t **)v5;
        int v8 = *((_DWORD *)v5 + 8);
        if (v8 <= a2) {
          break;
        }
        uint64_t v5 = *v7;
        int v6 = v7;
        if (!*v7) {
          goto LABEL_9;
        }
      }
      if (v8 >= a2) {
        break;
      }
      uint64_t v5 = v7[1];
      if (!v5)
      {
        int v6 = v7 + 1;
        goto LABEL_9;
      }
    }
  }
  else
  {
    int v7 = a1 + 1;
LABEL_9:
    BOOL v9 = (uint64_t *)v7;
    int v7 = (uint64_t **)operator new(0x38uLL);
    *((_DWORD *)v7 + 8) = *a3;
    *((unsigned char *)v7 + 40) = 0;
    void v7[6] = (uint64_t *)-1;
    *int v7 = 0;
    v7[1] = 0;
    void v7[2] = v9;
    void *v6 = (uint64_t *)v7;
    std::string::size_type v10 = (uint64_t *)**a1;
    uint64_t v11 = (uint64_t *)v7;
    if (v10)
    {
      *a1 = v10;
      uint64_t v11 = *v6;
    }
    sub_100046C90(a1[1], v11);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
  }
  return v7;
}

uint64_t **sub_1005BD92C(uint64_t **a1, int a2, _DWORD *a3)
{
  int v6 = a1 + 1;
  uint64_t v5 = a1[1];
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        int v7 = (uint64_t **)v5;
        int v8 = *((_DWORD *)v5 + 7);
        if (v8 <= a2) {
          break;
        }
        uint64_t v5 = *v7;
        int v6 = v7;
        if (!*v7) {
          goto LABEL_9;
        }
      }
      if (v8 >= a2) {
        break;
      }
      uint64_t v5 = v7[1];
      if (!v5)
      {
        int v6 = v7 + 1;
        goto LABEL_9;
      }
    }
  }
  else
  {
    int v7 = a1 + 1;
LABEL_9:
    BOOL v9 = (uint64_t *)v7;
    int v7 = (uint64_t **)operator new(0x28uLL);
    *((_DWORD *)v7 + 7) = *a3;
    *((_DWORD *)v7 + 8) = 0;
    *int v7 = 0;
    v7[1] = 0;
    void v7[2] = v9;
    void *v6 = (uint64_t *)v7;
    std::string::size_type v10 = (uint64_t *)**a1;
    uint64_t v11 = (uint64_t *)v7;
    if (v10)
    {
      *a1 = v10;
      uint64_t v11 = *v6;
    }
    sub_100046C90(a1[1], v11);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
  }
  return v7;
}

void sub_1005BD9F8(uint64_t a1)
{
  uint64_t v1 = *(uint64_t **)(a1 + 32);
  uint64_t v2 = (std::__shared_weak_count *)v1[2];
  if (v2)
  {
    uint64_t v3 = *v1;
    uint64_t v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      uint64_t v5 = v4;
      if (v1[1])
      {
        subscriber::makeSimSlotRange();
        int v6 = v7;
        if (v7 != v8)
        {
          while ((v9(*v6) & 1) == 0)
          {
            if (++v6 == v8)
            {
              int v6 = v8;
              break;
            }
          }
          if (v6 != v8) {
            sub_1005B87B8(v3);
          }
        }
      }
      sub_10004D2C8(v5);
    }
  }
}

void sub_1005BDAE8(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1005BDB04(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_1005BDB20(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

void sub_1005BDB30(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1019EAC30;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1005BDB50(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1019EAC30;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_1005BDBA4(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

uint64_t *sub_1005BDBB8(void **a1)
{
  uint64_t v1 = *a1;
  int v14 = a1;
  unsigned int v15 = v1;
  uint64_t v2 = *v1;
  sub_100058DB0(__p, "/cc/events/dump_state");
  uint64_t v3 = (uint64_t (***)())operator new(0x20uLL);
  NSObject *v3 = off_1019EAC80;
  v3[1] = (uint64_t (**)())v2;
  _OWORD v3[2] = (uint64_t (**)())sub_1005B9778;
  double v3[3] = 0;
  uint64_t v20 = v3;
  ctu::RestModule::observeEvent();
  sub_10003F600(&v18);
  if (v17 < 0) {
    operator delete(__p[0]);
  }
  sub_100058DB0(__p, "/cc/props/carrier_bundles");
  uint64_t v4 = (uint64_t (***)())operator new(0x28uLL);
  std::__shared_weak_count *v4 = off_1019EAD00;
  v4[1] = (uint64_t (**)())(v2 + 440);
  void v4[2] = (uint64_t (**)())v2;
  v4[3] = (uint64_t (**)())sub_1005B8B10;
  v4[4] = 0;
  uint64_t v20 = v4;
  ctu::RestModule::observeProperty();
  sub_10003F600(&v18);
  if (v17 < 0) {
    operator delete(__p[0]);
  }
  sub_100058DB0(__p, "/cc/events/connection_activate_error");
  uint64_t v5 = (uint64_t (***)())operator new(0x20uLL);
  std::__shared_weak_count *v5 = off_1019EAD80;
  v5[1] = (uint64_t (**)())v2;
  void v5[2] = (uint64_t (**)())sub_1005B8D40;
  v5[3] = 0;
  uint64_t v20 = v5;
  ctu::RestModule::observeEvent();
  sub_10003F600(&v18);
  if (v17 < 0) {
    operator delete(__p[0]);
  }
  sub_100058DB0(__p, "/cc/props/connection_availability");
  int v6 = (uint64_t (***)())operator new(0x28uLL);
  unsigned int *v6 = off_1019EAE00;
  v6[1] = (uint64_t (**)())(v2 + 472);
  void v6[2] = (uint64_t (**)())v2;
  v6[3] = (uint64_t (**)())sub_1005B8F78;
  void v6[4] = 0;
  uint64_t v20 = v6;
  ctu::RestModule::observeProperty();
  sub_10003F600(&v18);
  if (v17 < 0) {
    operator delete(__p[0]);
  }
  sub_100058DB0(__p, "/cc/props/connection_state");
  int v7 = (uint64_t (***)())operator new(0x28uLL);
  *int v7 = off_1019EAE80;
  v7[1] = (uint64_t (**)())(v2 + 496);
  void v7[2] = (uint64_t (**)())v2;
  void v7[3] = (uint64_t (**)())sub_1005B9158;
  void v7[4] = 0;
  uint64_t v20 = v7;
  ctu::RestModule::observeProperty();
  sub_10003F600(&v18);
  if (v17 < 0) {
    operator delete(__p[0]);
  }
  sub_100058DB0(__p, "/cc/props/current_data_slot");
  int v8 = (uint64_t (***)())operator new(0x28uLL);
  unsigned int *v8 = off_1019EAF00;
  v8[1] = (uint64_t (**)())(v2 + 520);
  void v8[2] = (uint64_t (**)())v2;
  void v8[3] = (uint64_t (**)())sub_1005B92F0;
  void v8[4] = 0;
  uint64_t v20 = v8;
  ctu::RestModule::observeProperty();
  sub_10003F600(&v18);
  if (v17 < 0) {
    operator delete(__p[0]);
  }
  sub_1002D7B1C(v2 + 524);
  sub_100058DB0(__p, "/cc/props/ims_registration_state");
  uint64_t v18 = off_1019EAF80;
  char v19 = (std::__shared_weak_count *)(v2 + 544);
  uint64_t v20 = &v18;
  ctu::RestModule::observeProperty();
  sub_10003F600(&v18);
  if (v17 < 0) {
    operator delete(__p[0]);
  }
  sub_1005BE214(v2 + 568);
  sub_1005BE2F4(v2 + 592);
  sub_100058DB0(__p, "/cc/props/reg_serving_network");
  BOOL v9 = (uint64_t (***)())operator new(0x28uLL);
  uint64_t *v9 = off_1019EB100;
  v9[1] = (uint64_t (**)())(v2 + 696);
  v9[2] = (uint64_t (**)())v2;
  v9[3] = (uint64_t (**)())sub_1005B9068;
  void v9[4] = 0;
  uint64_t v20 = v9;
  ctu::RestModule::observeProperty();
  sub_10003F600(&v18);
  if (v17 < 0) {
    operator delete(__p[0]);
  }
  sub_100058DB0(__p, "/cc/props/supported_message_modes");
  std::string::size_type v10 = (uint64_t (***)())operator new(0x28uLL);
  *std::string::size_type v10 = off_1019EB180;
  v10[1] = (uint64_t (**)())(v2 + 640);
  void v10[2] = (uint64_t (**)())v2;
  void v10[3] = (uint64_t (**)())sub_1005B94FC;
  void v10[4] = 0;
  uint64_t v20 = v10;
  ctu::RestModule::observeProperty();
  uint64_t v11 = (capabilities::ct *)sub_10003F600(&v18);
  if (v17 < 0) {
    operator delete(__p[0]);
  }
  if (capabilities::ct::supportsWidgetMode(v11))
  {
    sub_100058DB0(__p, "/cc/props/widget_state");
    uint64_t v18 = off_1019EB200;
    char v19 = (std::__shared_weak_count *)(v2 + 664);
    uint64_t v20 = &v18;
    ctu::RestModule::observeProperty();
    sub_10003F600(&v18);
    if (v17 < 0) {
      operator delete(__p[0]);
    }
    sub_1002D80F0(v2 + 432);
  }
  uint64_t v18 = off_1019EB280;
  char v19 = (std::__shared_weak_count *)(v2 + 360);
  uint64_t v20 = &v18;
  sub_10041CA0C(&v18, (void *)(v2 + 376));
  sub_10041A760(&v18);
  uint64_t v12 = *(void *)(v2 + 400);
  if (v12) {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v12 + 48))(v12, v2 + 408);
  }
  Registry::createRestModuleOneTimeUseConnection((uint64_t *)&v18, *(Registry **)(v2 + 56));
  ctu::RestModule::connect();
  if (v19) {
    sub_10004D2C8(v19);
  }
  sub_100088C88((uint64_t *)&v15);
  return sub_100046B58((uint64_t *)&v14);
}

void sub_1005BE17C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  sub_100088C88(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

void sub_1005BE214(uint64_t a1)
{
  sub_100058DB0(&__p, "/cc/props/phone_numbers");
  v4[0] = off_1019EB000;
  v4[1] = a1;
  v4[3] = v4;
  ctu::RestModule::observeProperty();
  sub_10003F600(v4);
  if (v3 < 0) {
    operator delete(__p);
  }
}

void sub_1005BE2C8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_1005BE2F4(uint64_t a1)
{
  sub_100058DB0(&__p, "/cc/props/reg_ps_attached");
  v4[0] = off_1019EB080;
  v4[1] = a1;
  v4[3] = v4;
  ctu::RestModule::observeProperty();
  sub_10003F600(v4);
  if (v3 < 0) {
    operator delete(__p);
  }
}

void sub_1005BE3A8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_1005BE3D8()
{
}

__n128 sub_1005BE3EC(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_1019EAC80;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_1005BE440(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019EAC80;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_1005BE478(void *a1)
{
  uint64_t v1 = (uint64_t (*)(void *))a1[2];
  uint64_t v2 = a1[3];
  char v3 = (void *)(a1[1] + (v2 >> 1));
  if (v2) {
    return (*(uint64_t (**)(void))(*v3 + v1))();
  }
  else {
    return v1(v3);
  }
}

uint64_t sub_1005BE4C0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1005BE500()
{
}

void sub_1005BE510()
{
}

__n128 sub_1005BE524(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_1019EAD00;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_1005BE578(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019EAD00;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_1005BE5B0(void *a1, xpc_object_t *a2)
{
  char v3 = (void *)a1[1];
  uint64_t v4 = v3 + 1;
  uint64_t v5 = (void *)v3[1];
  BOOL v9 = (void **)*v3;
  std::string::size_type v10 = v5;
  if (v3[2])
  {
    void v5[2] = &v10;
    void *v3 = v4;
    void *v4 = 0;
    _OWORD v3[2] = 0;
  }
  else
  {
    BOOL v9 = &v10;
  }
  sub_10008AAD8((uint64_t)v3, a2);
  int v6 = (void (*)(void *, void ***))a1[3];
  uint64_t v7 = a1[4];
  int v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    int v6 = *(void (**)(void *, void ***))(*v8 + v6);
  }
  v6(v8, &v9);
  sub_100087F94((uint64_t)&v9, v10);
}

void sub_1005BE670(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11)
{
}

uint64_t sub_1005BE688(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1005BE6C8()
{
}

void sub_1005BE6D8()
{
}

__n128 sub_1005BE6EC(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_1019EAD80;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_1005BE740(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019EAD80;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_1005BE778(void *a1)
{
  v6[0] = 0;
  v6[1] = 0;
  read_rest_value();
  uint64_t v2 = (uint64_t (*)(void *, void *))a1[2];
  uint64_t v3 = a1[3];
  uint64_t v4 = (void *)(a1[1] + (v3 >> 1));
  if (v3) {
    uint64_t v2 = *(uint64_t (**)(void *, void *))(*v4 + v2);
  }
  return v2(v4, v6);
}

uint64_t sub_1005BE7F8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1005BE838()
{
}

void sub_1005BE848()
{
}

__n128 sub_1005BE85C(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_1019EAE00;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_1005BE8B0(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019EAE00;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_1005BE8E8(void *a1, xpc_object_t *a2)
{
  uint64_t v3 = (void *)a1[1];
  uint64_t v4 = v3 + 1;
  uint64_t v5 = (void *)v3[1];
  BOOL v9 = (void **)*v3;
  std::string::size_type v10 = v5;
  if (v3[2])
  {
    void v5[2] = &v10;
    void *v3 = v4;
    void *v4 = 0;
    _OWORD v3[2] = 0;
  }
  else
  {
    BOOL v9 = &v10;
  }
  sub_1005BEA0C((uint64_t)v3, a2);
  int v6 = (void (*)(void *, void ***))a1[3];
  uint64_t v7 = a1[4];
  int v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    int v6 = *(void (**)(void *, void ***))(*v8 + v6);
  }
  v6(v8, &v9);
  sub_1000346F8((uint64_t)&v9, v10);
}

void sub_1005BE9A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11)
{
}

uint64_t sub_1005BE9C0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1005BEA00()
{
}

void sub_1005BEA0C(uint64_t a1, xpc_object_t *a2)
{
  xpc_object_t v3 = *a2;
  if (*a2 && xpc_get_type(*a2) == (xpc_type_t)&_xpc_type_array) {
    xpc_retain(v3);
  }
  else {
    xpc_object_t v3 = xpc_null_create();
  }
  sub_1000346F8(a1, *(void **)(a1 + 8));
  *(void *)a1 = a1 + 8;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 8) = 0;
  if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_array)
  {
    object[0] = v3;
    if (v3) {
      xpc_retain(v3);
    }
    else {
      object[0] = xpc_null_create();
    }
    sub_100048BF4(&v28, object, 0);
    xpc_release(object[0]);
    object[0] = v3;
    if (v3) {
      xpc_retain(v3);
    }
    else {
      object[0] = xpc_null_create();
    }
    if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_array) {
      count = (void *)xpc_array_get_count(v3);
    }
    else {
      count = 0;
    }
    sub_100048BF4(v27, object, count);
    xpc_release(object[0]);
    for (uint64_t i = v29; i != v27[1] || v28 != v27[0]; uint64_t i = ++v29)
    {
      xpc_object_t v26 = 0;
      object[0] = &v28;
      object[1] = i;
      sub_10003FBDC((uint64_t)object, &v26);
      if (xpc_get_type(v26) == (xpc_type_t)&_xpc_type_dictionary)
      {
        int v25 = 0;
        long long v23 = 0u;
        long long v24 = 0u;
        long long v21 = 0u;
        long long v22 = 0u;
        long long v19 = 0u;
        long long v20 = 0u;
        long long v17 = 0u;
        long long v18 = 0u;
        long long v15 = 0u;
        long long v16 = 0u;
        long long v13 = 0u;
        long long v14 = 0u;
        long long v11 = 0u;
        long long v12 = 0u;
        long long v9 = 0u;
        long long v10 = 0u;
        *(_OWORD *)xpc_object_t object = 0u;
        long long v8 = 0u;
        ConnectionAvailabilityContainer::ConnectionAvailabilityContainer((ConnectionAvailabilityContainer *)((char *)object + 4));
        xpc_object_t v6 = v26;
        if (v26) {
          xpc_retain(v26);
        }
        else {
          xpc_object_t v6 = xpc_null_create();
        }
        sub_1005BECD8((int *)object, &v6);
        xpc_release(v6);
        sub_1005BEE8C((uint64_t **)a1, (int *)object, object);
      }
      xpc_release(v26);
    }
    xpc_release(v28);
    xpc_release(v28);
  }
  xpc_release(v3);
}

void sub_1005BEC48(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t a10, xpc_object_t object)
{
  xpc_release(object);
  xpc_release(*(xpc_object_t *)(v12 - 80));
  xpc_release(v11);
  _Unwind_Resume(a1);
}

void sub_1005BECD8(int *a1, xpc_object_t *a2)
{
  xpc_object_t v3 = *a2;
  xpc_object_t v9 = v3;
  if (v3 && xpc_get_type(v3) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v3);
  }
  else
  {
    xpc_object_t v3 = xpc_null_create();
    xpc_object_t v9 = v3;
  }
  if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_object_t v6 = &v9;
    uint64_t v7 = "first";
    sub_100048BAC((uint64_t)&v6, &object);
    xpc_type_t type = xpc_get_type(object);
    if (type == (xpc_type_t)&_xpc_type_string)
    {
      int v10 = *a1;
      ctu::rest::detail::read_enum_string_value((ctu::rest::detail *)&v10, (int *)&object, v5);
      *a1 = v10;
    }
    else if (type == (xpc_type_t)&_xpc_type_BOOL {
           || type == (xpc_type_t)&_xpc_type_int64
    }
           || type == (xpc_type_t)&_xpc_type_uint64)
    {
      *a1 = xpc::dyn_cast_or_default((xpc *)&object, 0, (uint64_t)v5);
    }
    xpc_release(object);
    xpc_object_t v6 = &v9;
    uint64_t v7 = "second";
    sub_100048BAC((uint64_t)&v6, &object);
    read_rest_value((ConnectionAvailabilityContainer *)(a1 + 1), (const xpc::object *)&object);
    xpc_release(object);
    xpc_object_t v3 = v9;
  }
  xpc_release(v3);
}

void sub_1005BEE38(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, xpc_object_t object, xpc_object_t a13)
{
}

uint64_t **sub_1005BEE8C(uint64_t **a1, int *a2, _DWORD *a3)
{
  xpc_object_t v6 = a1 + 1;
  uint64_t v5 = a1[1];
  if (v5)
  {
    int v7 = *a2;
    while (1)
    {
      while (1)
      {
        long long v8 = (uint64_t **)v5;
        int v9 = *((_DWORD *)v5 + 7);
        if (v7 >= v9) {
          break;
        }
        uint64_t v5 = *v8;
        xpc_object_t v6 = v8;
        if (!*v8) {
          goto LABEL_10;
        }
      }
      if (v9 >= v7) {
        break;
      }
      uint64_t v5 = v8[1];
      if (!v5)
      {
        xpc_object_t v6 = v8 + 1;
        goto LABEL_10;
      }
    }
  }
  else
  {
    long long v8 = a1 + 1;
LABEL_10:
    int v10 = (uint64_t *)operator new(0x140uLL);
    *((_DWORD *)v10 + 7) = *a3;
    memcpy(v10 + 4, a3 + 1, 0x120uLL);
    sub_100046C38(a1, (uint64_t)v8, v6, v10);
    return (uint64_t **)v10;
  }
  return v8;
}

void sub_1005BEF5C()
{
}

__n128 sub_1005BEF70(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_1019EAE80;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_1005BEFC4(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019EAE80;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_1005BEFFC(void *a1, xpc_object_t *a2)
{
  xpc_object_t v3 = (void *)a1[1];
  uint64_t v4 = v3 + 1;
  uint64_t v5 = (void *)v3[1];
  int v9 = (void **)*v3;
  int v10 = v5;
  if (v3[2])
  {
    void v5[2] = &v10;
    void *v3 = v4;
    void *v4 = 0;
    _OWORD v3[2] = 0;
  }
  else
  {
    int v9 = &v10;
  }
  sub_100318E34((uint64_t)v3, a2);
  xpc_object_t v6 = (void (*)(void *, void ***))a1[3];
  uint64_t v7 = a1[4];
  long long v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    xpc_object_t v6 = *(void (**)(void *, void ***))(*v8 + v6);
  }
  v6(v8, &v9);
  sub_10024D10C((uint64_t)&v9, v10);
}

void sub_1005BF0BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11)
{
}

uint64_t sub_1005BF0D4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1005BF114()
{
}

void sub_1005BF124()
{
}

__n128 sub_1005BF138(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_1019EAF00;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_1005BF18C(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019EAF00;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_1005BF1C4(void *a1, xpc_object_t *a2)
{
  uint64_t v4 = (unsigned int *)a1[1];
  uint64_t v5 = *v4;
  xpc_type_t type = xpc_get_type(*a2);
  if (type == (xpc_type_t)&_xpc_type_string)
  {
    unsigned int v14 = *v4;
    ctu::rest::detail::read_enum_string_value((ctu::rest::detail *)&v14, (int *)a2, v7);
    unsigned int *v4 = v14;
  }
  else if (type == (xpc_type_t)&_xpc_type_BOOL {
         || type == (xpc_type_t)&_xpc_type_int64
  }
         || type == (xpc_type_t)&_xpc_type_uint64)
  {
    unsigned int *v4 = xpc::dyn_cast_or_default((xpc *)a2, 0, (uint64_t)v7);
  }
  int v10 = (uint64_t (*)(void *, uint64_t))a1[3];
  uint64_t v11 = a1[4];
  uint64_t v12 = (void *)(a1[2] + (v11 >> 1));
  if (v11) {
    int v10 = *(uint64_t (**)(void *, uint64_t))(*v12 + v10);
  }
  return v10(v12, v5);
}

uint64_t sub_1005BF2BC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1005BF2FC()
{
}

void sub_1005BF30C()
{
}

void *sub_1005BF320(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_1019EAF80;
  result[1] = v3;
  return result;
}

uint64_t sub_1005BF368(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019EAF80;
  a2[1] = v2;
  return result;
}

void sub_1005BF394(uint64_t a1, xpc_object_t *a2)
{
}

uint64_t sub_1005BF39C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1005BF3DC()
{
}

void sub_1005BF3EC()
{
}

void *sub_1005BF400(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_1019EB000;
  result[1] = v3;
  return result;
}

uint64_t sub_1005BF448(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019EB000;
  a2[1] = v2;
  return result;
}

void sub_1005BF474(uint64_t a1, xpc_object_t *a2)
{
}

uint64_t sub_1005BF47C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1005BF4BC()
{
}

void sub_1005BF4CC()
{
}

void *sub_1005BF4E0(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_1019EB080;
  result[1] = v3;
  return result;
}

uint64_t sub_1005BF528(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019EB080;
  a2[1] = v2;
  return result;
}

void sub_1005BF554(uint64_t a1, xpc_object_t *a2)
{
}

uint64_t sub_1005BF55C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1005BF59C()
{
}

void sub_1005BF5AC()
{
}

__n128 sub_1005BF5C0(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_1019EB100;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_1005BF614(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019EB100;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_1005BF64C(void *a1, xpc_object_t *a2)
{
  uint64_t v3 = (void *)a1[1];
  uint64_t v4 = v3 + 1;
  uint64_t v5 = (void *)v3[1];
  int v9 = (void **)*v3;
  int v10 = v5;
  if (v3[2])
  {
    void v5[2] = &v10;
    void *v3 = v4;
    void *v4 = 0;
    _OWORD v3[2] = 0;
  }
  else
  {
    int v9 = &v10;
  }
  sub_1005BF770((uint64_t)v3, a2);
  xpc_object_t v6 = (void (*)(void *, void ***))a1[3];
  uint64_t v7 = a1[4];
  long long v8 = (void *)(a1[2] + (v7 >> 1));
  if (v7) {
    xpc_object_t v6 = *(void (**)(void *, void ***))(*v8 + v6);
  }
  v6(v8, &v9);
  sub_10003FB28((uint64_t)&v9, v10);
}

void sub_1005BF70C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11)
{
}

uint64_t sub_1005BF724(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1005BF764()
{
}

void sub_1005BF770(uint64_t a1, xpc_object_t *a2)
{
  xpc_object_t v3 = *a2;
  if (*a2 && xpc_get_type(*a2) == (xpc_type_t)&_xpc_type_array) {
    xpc_retain(v3);
  }
  else {
    xpc_object_t v3 = xpc_null_create();
  }
  sub_10003FB28(a1, *(void **)(a1 + 8));
  *(void *)a1 = a1 + 8;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 8) = 0;
  if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_array)
  {
    object[0] = v3;
    if (v3) {
      xpc_retain(v3);
    }
    else {
      object[0] = xpc_null_create();
    }
    sub_100048BF4(&v14, object, 0);
    xpc_release(object[0]);
    object[0] = v3;
    if (v3) {
      xpc_retain(v3);
    }
    else {
      object[0] = xpc_null_create();
    }
    if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_array) {
      count = (void *)xpc_array_get_count(v3);
    }
    else {
      count = 0;
    }
    sub_100048BF4(v13, object, count);
    xpc_release(object[0]);
    for (uint64_t i = v15; i != v13[1] || v14 != v13[0]; uint64_t i = ++v15)
    {
      xpc_object_t v12 = 0;
      object[0] = &v14;
      object[1] = i;
      sub_10003FBDC((uint64_t)object, &v12);
      if (xpc_get_type(v12) == (xpc_type_t)&_xpc_type_dictionary)
      {
        *(_OWORD *)__n128 __p = 0u;
        long long v11 = 0u;
        *(_OWORD *)long long v8 = 0u;
        long long v9 = 0u;
        *(_OWORD *)xpc_object_t object = 0u;
        MCCAndMNC::MCCAndMNC((MCCAndMNC *)&object[1]);
        DWORD2(v11) = 11;
        WORD6(v11) = 0;
        xpc_object_t v6 = v12;
        if (v12) {
          xpc_retain(v12);
        }
        else {
          xpc_object_t v6 = xpc_null_create();
        }
        sub_1005BFA50((int *)object, &v6);
        xpc_release(v6);
        sub_1005BFC04(a1, (int *)object, (uint64_t)object);
        if (SBYTE7(v11) < 0) {
          operator delete(__p[0]);
        }
        if (SBYTE7(v9) < 0) {
          operator delete(v8[0]);
        }
      }
      xpc_release(v12);
    }
    xpc_release(v14);
    xpc_release(v14);
  }
  xpc_release(v3);
}

void sub_1005BF9B0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t a10, xpc_object_t object)
{
  xpc_release(object);
  xpc_release(*(xpc_object_t *)(v12 - 64));
  xpc_release(v11);
  _Unwind_Resume(a1);
}

void sub_1005BFA50(int *a1, xpc_object_t *a2)
{
  xpc_object_t v3 = *a2;
  xpc_object_t v9 = v3;
  if (v3 && xpc_get_type(v3) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_retain(v3);
  }
  else
  {
    xpc_object_t v3 = xpc_null_create();
    xpc_object_t v9 = v3;
  }
  if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_object_t v6 = &v9;
    uint64_t v7 = "first";
    sub_100048BAC((uint64_t)&v6, &object);
    xpc_type_t type = xpc_get_type(object);
    if (type == (xpc_type_t)&_xpc_type_string)
    {
      int v10 = *a1;
      ctu::rest::detail::read_enum_string_value((ctu::rest::detail *)&v10, (int *)&object, v5);
      *a1 = v10;
    }
    else if (type == (xpc_type_t)&_xpc_type_BOOL {
           || type == (xpc_type_t)&_xpc_type_int64
    }
           || type == (xpc_type_t)&_xpc_type_uint64)
    {
      *a1 = xpc::dyn_cast_or_default((xpc *)&object, 0, (uint64_t)v5);
    }
    xpc_release(object);
    xpc_object_t v6 = &v9;
    uint64_t v7 = "second";
    sub_100048BAC((uint64_t)&v6, &object);
    rest::read_rest_value();
    xpc_release(object);
    xpc_object_t v3 = v9;
  }
  xpc_release(v3);
}

void sub_1005BFBB0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, xpc_object_t object, xpc_object_t a13)
{
}

uint64_t *sub_1005BFC04(uint64_t a1, int *a2, uint64_t a3)
{
  uint64_t v5 = (uint64_t **)(a1 + 8);
  uint64_t v4 = *(void *)(a1 + 8);
  if (v4)
  {
    int v6 = *a2;
    while (1)
    {
      while (1)
      {
        uint64_t v7 = (uint64_t *)v4;
        int v8 = *(_DWORD *)(v4 + 32);
        if (v6 >= v8) {
          break;
        }
        uint64_t v4 = *v7;
        uint64_t v5 = (uint64_t **)v7;
        if (!*v7) {
          goto LABEL_10;
        }
      }
      if (v8 >= v6) {
        break;
      }
      uint64_t v4 = v7[1];
      if (!v4)
      {
        uint64_t v5 = (uint64_t **)(v7 + 1);
        goto LABEL_10;
      }
    }
  }
  else
  {
    uint64_t v7 = (uint64_t *)(a1 + 8);
LABEL_10:
    memset(v10, 0, sizeof(v10));
    sub_1005BFCD0(a1, a3, v10);
    sub_100046C38((uint64_t **)a1, (uint64_t)v7, v5, v10[0]);
    uint64_t v7 = v10[0];
    v10[0] = 0;
    sub_10003FD44((uint64_t)v10, 0);
  }
  return v7;
}

uint64_t sub_1005BFCD0@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  uint64_t v5 = a1 + 8;
  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  int v6 = operator new(0x70uLL);
  *a3 = v6;
  a3[1] = v5;
  *((unsigned char *)a3 + 16) = 0;
  uint64_t result = sub_1005BFD44((uint64_t)v6 + 32, a2);
  *((unsigned char *)a3 + 16) = 1;
  return result;
}

void sub_1005BFD2C(_Unwind_Exception *a1)
{
  sub_10003FD44(v1, 0);
  _Unwind_Resume(a1);
}

uint64_t sub_1005BFD44(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (const MCC *)(a2 + 40);
  *(_DWORD *)a1 = *(_DWORD *)a2;
  uint64_t v5 = (MCC *)(a1 + 40);
  MCC::MCC((MCC *)(a1 + 8), (const MCC *)(a2 + 8));
  MCC::MCC(v5, v4);
  int v6 = *(_DWORD *)(a2 + 72);
  *(_WORD *)(a1 + 76) = *(_WORD *)(a2 + 76);
  *(_DWORD *)(a1 + 72) = v6;
  return a1;
}

void sub_1005BFDAC(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 39) < 0) {
    operator delete(*(void **)(v1 + 16));
  }
  _Unwind_Resume(exception_object);
}

void sub_1005BFDCC()
{
}

__n128 sub_1005BFDE0(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_1019EB180;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_1005BFE34(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019EB180;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_1005BFE6C(void *a1, xpc_object_t *a2)
{
  xpc_object_t v3 = (uint64_t **)a1[1];
  uint64_t v5 = v3 + 1;
  uint64_t v4 = v3[1];
  long long v38 = *v3;
  uint64_t v39 = v4;
  if (v3[2])
  {
    void v4[2] = (uint64_t)&v39;
    void *v3 = (uint64_t *)v5;
    MCC *v5 = 0;
    _OWORD v3[2] = 0;
  }
  else
  {
    long long v38 = (uint64_t *)&v39;
  }
  xpc_object_t v6 = *a2;
  if (*a2 && xpc_get_type(*a2) == (xpc_type_t)&_xpc_type_array) {
    xpc_retain(v6);
  }
  else {
    xpc_object_t v6 = xpc_null_create();
  }
  sub_10026CF54((uint64_t)v3, v3[1]);
  v3[1] = 0;
  _OWORD v3[2] = 0;
  void *v3 = (uint64_t *)v5;
  if (xpc_get_type(v6) == (xpc_type_t)&_xpc_type_array)
  {
    object[0] = v6;
    if (v6) {
      xpc_retain(v6);
    }
    else {
      object[0] = xpc_null_create();
    }
    sub_100048BF4(&v44, object, 0);
    xpc_release(object[0]);
    object[0] = v6;
    if (v6) {
      xpc_retain(v6);
    }
    else {
      object[0] = xpc_null_create();
    }
    if (xpc_get_type(v6) == (xpc_type_t)&_xpc_type_array) {
      count = (void *)xpc_array_get_count(v6);
    }
    else {
      count = 0;
    }
    long long v37 = v3;
    sub_100048BF4(v43, object, count);
    xpc_release(object[0]);
    for (uint64_t i = v45; ; uint64_t i = ++v45)
    {
      if (i == v43[1] && v44 == v43[0])
      {
        xpc_release(v44);
        xpc_release(v44);
        goto LABEL_91;
      }
      xpc_object_t v42 = 0;
      object[0] = &v44;
      object[1] = i;
      sub_10003FBDC((uint64_t)object, &v42);
      if (xpc_get_type(v42) == (xpc_type_t)&_xpc_type_dictionary) {
        break;
      }
LABEL_89:
      xpc_release(v42);
    }
    memset(object, 0, sizeof(object));
    xpc_object_t v9 = v42;
    if (v42)
    {
      xpc_retain(v42);
      xpc_object_t v48 = v9;
    }
    else
    {
      xpc_object_t v9 = xpc_null_create();
      xpc_object_t v48 = v9;
      if (!v9)
      {
        xpc_object_t v10 = xpc_null_create();
        xpc_object_t v9 = 0;
        goto LABEL_29;
      }
    }
    if (xpc_get_type(v9) == (xpc_type_t)&_xpc_type_dictionary)
    {
      xpc_retain(v9);
      xpc_object_t v10 = v9;
LABEL_30:
      if (xpc_get_type(v10) == (xpc_type_t)&_xpc_type_dictionary)
      {
        uint64_t v53 = &v48;
        uint64_t v54 = "first";
        sub_100048BAC((uint64_t)&v53, v51);
        xpc_type_t type = xpc_get_type(*(xpc_object_t *)v51);
        if (type == (xpc_type_t)&_xpc_type_string)
        {
          LODWORD(v50[0]) = object[0];
          ctu::rest::detail::read_enum_string_value((ctu::rest::detail *)v50, v51, v12);
          LODWORD(object[0]) = v50[0];
        }
        else if (type == (xpc_type_t)&_xpc_type_BOOL {
               || type == (xpc_type_t)&_xpc_type_int64
        }
               || type == (xpc_type_t)&_xpc_type_uint64)
        {
          LODWORD(object[0]) = xpc::dyn_cast_or_default((xpc *)v51, 0, (uint64_t)v12);
        }
        xpc_release(*(xpc_object_t *)v51);
        v46[0] = &v48;
        v46[1] = "second";
        sub_100048BAC((uint64_t)v46, &v47);
        xpc_object_t v13 = v47;
        if (v47 && xpc_get_type(v47) == (xpc_type_t)&_xpc_type_array) {
          xpc_retain(v13);
        }
        else {
          xpc_object_t v13 = xpc_null_create();
        }
        xpc_object_t object[2] = object[1];
        if (xpc_get_type(v13) == (xpc_type_t)&_xpc_type_array)
        {
          *(void *)int v51 = v13;
          if (v13) {
            xpc_retain(v13);
          }
          else {
            *(void *)int v51 = xpc_null_create();
          }
          sub_100048BF4((void **)&v53, (void **)v51, 0);
          xpc_release(*(xpc_object_t *)v51);
          v50[0] = v13;
          if (v13) {
            xpc_retain(v13);
          }
          else {
            v50[0] = xpc_null_create();
          }
          if (xpc_get_type(v13) == (xpc_type_t)&_xpc_type_array) {
            unsigned int v14 = (void *)xpc_array_get_count(v13);
          }
          else {
            unsigned int v14 = 0;
          }
          sub_100048BF4((void **)v51, v50, v14);
          xpc_release(v50[0]);
          for (j = v54; j != v52 || v53 != *(xpc_object_t **)v51; j = ++v54)
          {
            v50[0] = &v53;
            v50[1] = (void *)j;
            long long v16 = (char *)object[2];
            if (object[2] >= object[3])
            {
              long long v18 = (char *)object[1];
              int64_t v19 = ((char *)object[2] - (char *)object[1]) >> 2;
              unint64_t v20 = v19 + 1;
              if ((unint64_t)(v19 + 1) >> 62) {
                sub_10006A748();
              }
              int64_t v21 = (char *)object[3] - (char *)object[1];
              if (((char *)object[3] - (char *)object[1]) >> 1 > v20) {
                unint64_t v20 = v21 >> 1;
              }
              if ((unint64_t)v21 >= 0x7FFFFFFFFFFFFFFCLL) {
                unint64_t v22 = 0x3FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v22 = v20;
              }
              if (v22)
              {
                long long v23 = (char *)sub_10005ECD8((uint64_t)&object[3], v22);
                long long v18 = (char *)object[1];
                long long v16 = (char *)object[2];
              }
              else
              {
                long long v23 = 0;
              }
              long long v24 = &v23[4 * v19];
              *(_DWORD *)long long v24 = 0;
              long long v17 = v24 + 4;
              while (v16 != v18)
              {
                int v25 = *((_DWORD *)v16 - 1);
                v16 -= 4;
                *((_DWORD *)v24 - 1) = v25;
                v24 -= 4;
              }
              object[1] = v24;
              xpc_object_t object[2] = v17;
              object[3] = &v23[4 * v22];
              if (v18) {
                operator delete(v18);
              }
            }
            else
            {
              *(_DWORD *)xpc_object_t object[2] = 0;
              long long v17 = v16 + 4;
            }
            xpc_object_t object[2] = v17;
            sub_1000492E0((uint64_t)v50, &v49);
            xpc_type_t v26 = xpc_get_type(v49);
            if (v26 == (xpc_type_t)&_xpc_type_string)
            {
              v55[0] = *((_DWORD *)v17 - 1);
              ctu::rest::detail::read_enum_string_value((ctu::rest::detail *)v55, (int *)&v49, v27);
              *((_DWORD *)v17 - 1) = v55[0];
            }
            else if (v26 == (xpc_type_t)&_xpc_type_BOOL {
                   || v26 == (xpc_type_t)&_xpc_type_int64
            }
                   || v26 == (xpc_type_t)&_xpc_type_uint64)
            {
              *((_DWORD *)v17 - 1) = xpc::dyn_cast_or_default((xpc *)&v49, 0, (uint64_t)v27);
            }
            xpc_release(v49);
          }
          xpc_release(v53);
          xpc_release(v53);
        }
        xpc_release(v13);
        xpc_release(v47);
        xpc_object_t v10 = v48;
      }
      xpc_release(v10);
      xpc_release(v9);
      int v28 = (int)object[0];
      uint64_t v29 = *v5;
      int v30 = v5;
      BOOL v31 = v5;
      if (*v5)
      {
        while (1)
        {
          while (1)
          {
            BOOL v31 = (uint64_t **)v29;
            int v32 = *((_DWORD *)v29 + 8);
            if (v32 <= SLODWORD(object[0])) {
              break;
            }
            uint64_t v29 = *v31;
            int v30 = v31;
            if (!*v31) {
              goto LABEL_86;
            }
          }
          if (v32 >= SLODWORD(object[0])) {
            break;
          }
          uint64_t v29 = v31[1];
          if (!v29)
          {
            int v30 = v31 + 1;
            goto LABEL_86;
          }
        }
      }
      else
      {
LABEL_86:
        unint64_t v33 = (char *)operator new(0x40uLL);
        *((_DWORD *)v33 + 8) = v28;
        *(_OWORD *)(v33 + 40) = *(_OWORD *)&object[1];
        *((xpc_object_t *)v33 + 7) = object[3];
        memset(&object[1], 0, 24);
        sub_100046C38(v37, (uint64_t)v31, v30, (uint64_t *)v33);
      }
      if (object[1])
      {
        xpc_object_t object[2] = object[1];
        operator delete(object[1]);
      }
      goto LABEL_89;
    }
    xpc_object_t v10 = xpc_null_create();
LABEL_29:
    xpc_object_t v48 = v10;
    goto LABEL_30;
  }
LABEL_91:
  xpc_release(v6);
  uint64_t v34 = (void (*)(void *, uint64_t **))a1[3];
  uint64_t v35 = a1[4];
  uint64_t v36 = (void *)(a1[2] + (v35 >> 1));
  if (v35) {
    uint64_t v34 = *(void (**)(void *, uint64_t **))(*v36 + v34);
  }
  v34(v36, &v38);
  sub_10026CF54((uint64_t)&v38, v39);
}

void sub_1005C051C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t a10, uint64_t a11, char a12, void *a13, uint64_t a14, xpc_object_t object, void *__p, uint64_t a17, uint64_t a18, xpc_object_t a19, xpc_object_t a20,uint64_t a21,xpc_object_t a22,uint64_t a23,uint64_t a24,uint64_t a25,xpc_object_t a26,xpc_object_t a27,xpc_object_t a28)
{
  xpc_object_t object = 0;
  xpc_release(a22);
  xpc_release(a10);
  sub_10026CF54((uint64_t)&a12, a13);
  _Unwind_Resume(a1);
}

uint64_t sub_1005C06A8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1005C06E8()
{
}

void sub_1005C06F8()
{
}

void *sub_1005C070C(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_1019EB200;
  result[1] = v3;
  return result;
}

uint64_t sub_1005C0754(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019EB200;
  a2[1] = v2;
  return result;
}

uint64_t sub_1005C0780()
{
  return rest::read_rest_value();
}

uint64_t sub_1005C0788(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1005C07C8()
{
}

void sub_1005C07D8()
{
}

void *sub_1005C07EC(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_1019EB280;
  result[1] = v3;
  return result;
}

uint64_t sub_1005C0834(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019EB280;
  a2[1] = v2;
  return result;
}

void sub_1005C0860(uint64_t a1, void *a2)
{
  xpc_object_t v5 = 0;
  sub_100014264(a2, &v5);
  sub_100058DB0(&__p, "/cc/props/mms_ready");
  xpc_object_t object = v5;
  if (v5) {
    xpc_retain(v5);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(object);
  if (v4 < 0) {
    operator delete(__p);
  }
  xpc_release(v5);
}

void sub_1005C0904(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  xpc_release(object);
  if (a16 < 0) {
    operator delete(__p);
  }
  xpc_release(*(xpc_object_t *)(v16 - 24));
  _Unwind_Resume(a1);
}

uint64_t sub_1005C0948(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1005C0988()
{
}

void sub_1005C0994(uint64_t **a1)
{
  uint64_t v1 = **a1;
  subscriber::makeSimSlotRange();
  uint64_t v3 = v21;
  uint64_t v2 = (unsigned int *)__p;
  if (v21 == (unsigned int *)__p) {
    goto LABEL_25;
  }
  char v4 = (uint64_t (*)(void))*((void *)&__p + 1);
  do
  {
    if ((*((uint64_t (**)(void))&__p + 1))(*v3)) {
      goto LABEL_6;
    }
    ++v3;
  }
  while (v3 != (unsigned int *)__p);
  uint64_t v3 = (unsigned int *)__p;
LABEL_6:
  xpc_object_t v5 = (unsigned int *)__p;
  if (v3 == (unsigned int *)__p)
  {
LABEL_25:
    sub_100058DB0(v19, "MMS Data Context");
    LODWORD(v21) = 3;
    BYTE4(v21) = 1;
    if (SHIBYTE(v20) < 0)
    {
      sub_10004FC84(&__p, v19[0], (unint64_t)v19[1]);
    }
    else
    {
      long long __p = *(_OWORD *)v19;
      uint64_t v23 = v20;
    }
    sub_10011AE40();
    if (SHIBYTE(v23) < 0) {
      operator delete((void *)__p);
    }
    if (SHIBYTE(v20) < 0) {
      operator delete(v19[0]);
    }
    operator delete();
  }
  while (1)
  {
    unsigned int v24 = 0;
    uint64_t v6 = *v3;
    unsigned int v24 = *v3;
    ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(v1 + 56));
    int v8 = ServiceMap;
    if (v9 < 0)
    {
      xpc_object_t v10 = (unsigned __int8 *)(v9 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v11 = 5381;
      do
      {
        uint64_t v9 = v11;
        unsigned int v12 = *v10++;
        uint64_t v11 = (33 * v11) ^ v12;
      }
      while (v12);
    }
    std::mutex::lock(ServiceMap);
    v19[0] = (void *)v9;
    xpc_object_t v13 = sub_10004D37C(&v8[1].__m_.__sig, (unint64_t *)v19);
    if (v13)
    {
      uint64_t v15 = v13[3];
      unsigned int v14 = (std::__shared_weak_count *)v13[4];
      if (v14)
      {
        atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v8);
        atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v14);
        char v16 = 0;
        if (!v15) {
          goto LABEL_17;
        }
LABEL_16:
        char v17 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v15 + 72))(v15, 31);
        uint64_t v6 = v24;
        *((unsigned char *)sub_1005BD854((uint64_t **)(v1 + 312), v24, &v24) + 40) = v17;
        goto LABEL_17;
      }
    }
    else
    {
      uint64_t v15 = 0;
    }
    std::mutex::unlock(v8);
    unsigned int v14 = 0;
    char v16 = 1;
    if (v15) {
      goto LABEL_16;
    }
LABEL_17:
    if ((v16 & 1) == 0) {
      sub_10004D2C8(v14);
    }
    sub_1005B89A0(v1, v6);
    sub_1005B8028(v1, v6);
    long long v18 = v3 + 1;
    uint64_t v3 = v2;
    if (v18 != v2)
    {
      uint64_t v3 = v18;
      do
      {
        if (v4(*v3)) {
          goto LABEL_24;
        }
        ++v3;
      }
      while (v3 != v2);
      uint64_t v3 = v2;
    }
LABEL_24:
    if (v3 == v5) {
      goto LABEL_25;
    }
  }
}

void sub_1005C0C2C(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, void *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  operator delete();
}

uint64_t *sub_1005C0CAC(uint64_t *a1)
{
  uint64_t v1 = *a1;
  xpc_object_t v5 = a1;
  uint64_t v6 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v3 = *(NSObject **)(*(void *)v1 + 40);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I Shutting down", buf, 2u);
  }
  ctu::RestModule::disconnect((ctu::RestModule *)(v2 + 360));
  NotifySubscription::cancel((NotifySubscription *)(v2 + 672));
  sub_100088C88(&v6);
  return sub_100046B58((uint64_t *)&v5);
}

void sub_1005C0D38(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

char *sub_1005C0D54(uint64_t **a1, int a2, _DWORD *a3)
{
  uint64_t v6 = a1 + 1;
  xpc_object_t v5 = (char *)a1[1];
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        uint64_t v7 = v5;
        int v8 = *((_DWORD *)v5 + 8);
        if (v8 <= a2) {
          break;
        }
        xpc_object_t v5 = *(char **)v7;
        uint64_t v6 = (uint64_t **)v7;
        if (!*(void *)v7) {
          goto LABEL_9;
        }
      }
      if (v8 >= a2) {
        break;
      }
      xpc_object_t v5 = (char *)*((void *)v7 + 1);
      if (!v5)
      {
        uint64_t v6 = (uint64_t **)(v7 + 8);
        goto LABEL_9;
      }
    }
  }
  else
  {
    uint64_t v7 = (char *)(a1 + 1);
LABEL_9:
    uint64_t v9 = v7;
    uint64_t v7 = (char *)operator new(0x38uLL);
    *((_DWORD *)v7 + 8) = *a3;
    *(_OWORD *)(v7 + 40) = xmmword_1014C33B0;
    *(void *)uint64_t v7 = 0;
    *((void *)v7 + 1) = 0;
    *((void *)v7 + 2) = v9;
    void *v6 = (uint64_t *)v7;
    xpc_object_t v10 = (uint64_t *)**a1;
    uint64_t v11 = (uint64_t *)v7;
    if (v10)
    {
      *a1 = v10;
      uint64_t v11 = *v6;
    }
    sub_100046C90(a1[1], v11);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
  }
  return v7;
}

void sub_1005C0E2C(int **a1)
{
  int v8 = a1;
  uint64_t v1 = *a1;
  uint64_t v2 = (void **)*((void *)*a1 + 1);
  uint64_t v3 = (NSObject **)(*(uint64_t (**)(void *, void))(*v2[6] + 16))(v2[6], **a1);
  if (*v1 == 1) {
    CFStringRef v4 = @"MMSEnabled";
  }
  else {
    CFStringRef v4 = @"MMS2Enabled";
  }
  int v5 = (*(uint64_t (**)(void *, const __CFString *, uint64_t))(*v2[12] + 32))(v2[12], v4, 1);
  uint64_t v6 = *v3;
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v7 = "false";
    if (v5) {
      uint64_t v7 = "true";
    }
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = v7;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I MMS switch is enabled by user : %s", buf, 0xCu);
  }
  *(void *)std::string buf = v1;
  *((unsigned char *)sub_10005CE78(v2 + 30, v1, (uint64_t)&unk_10144E20E, (_DWORD **)buf) + 32) = v5;
  sub_1005B83D8((uint64_t)v2, *v1);
  operator delete();
}

void sub_1005C0FBC()
{
}

uint64_t sub_1005C0FE8(uint64_t a1)
{
  if (*(unsigned char *)a1)
  {
    uint64_t v2 = *(void *)(a1 + 8);
    uint64_t v3 = *(void *)(v2 + 24);
    if (v3) {
      (*(void (**)(uint64_t, uint64_t))(*(void *)v3 + 48))(v3, v2 + 32);
    }
  }
  return a1;
}

uint64_t *sub_1005C104C(void *a1)
{
  uint64_t v1 = *a1;
  uint64_t v6 = a1;
  uint64_t v7 = (dispatch_object_t *)v1;
  uint64_t v2 = *(void *)(v1 + 8);
  (*(void (**)(void))(**(void **)(v2 + 96) + 24))(*(void *)(v2 + 96));
  subscriber::makeSimSlotRange();
  uint64_t v3 = v8;
  if (v8 != v9)
  {
    while ((v10(*v3) & 1) == 0)
    {
      if (++v3 == v9)
      {
        uint64_t v3 = v9;
        break;
      }
    }
LABEL_5:
    while (v3 != v9)
    {
      sub_1005B8028(v2, *v3);
      CFStringRef v4 = v3 + 1;
      uint64_t v3 = v9;
      if (v4 != v9)
      {
        uint64_t v3 = v4;
        while ((v10(*v3) & 1) == 0)
        {
          if (++v3 == v9)
          {
            uint64_t v3 = v9;
            goto LABEL_5;
          }
        }
      }
    }
  }
  sub_10048F648(&v7);
  return sub_100046B58((uint64_t *)&v6);
}

void sub_1005C114C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, void);
  sub_10048F648((dispatch_object_t **)va1);
  sub_100046B58((uint64_t *)va);
  _Unwind_Resume(a1);
}

void sub_1005C1174(uint64_t a1, int a2)
{
  unsigned int v20 = a2;
  CFStringRef v4 = (NSObject **)(*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
  int v5 = ConnectionAvailabilityContainer::error();
  *((_DWORD *)sub_1005BD92C((uint64_t **)(a1 + 144), a2, &v20) + 8) = v5;
  LOBYTE(v5) = *((_DWORD *)sub_1005BD92C((uint64_t **)(a1 + 144), a2, &v20) + 8) == -7;
  *((unsigned char *)sub_1005BD854((uint64_t **)(a1 + 312), a2, &v20) + 40) = v5;
  int v6 = *((_DWORD *)sub_1005BD92C((uint64_t **)(a1 + 144), a2, &v20) + 8);
  int v7 = v6 == 0;
  *(void *)std::string buf = &v20;
  if (*((unsigned __int8 *)sub_10005CE78((uint64_t **)(a1 + 192), (int *)&v20, (uint64_t)&unk_10144E20E, (_DWORD **)buf)
       + 32) != v7)
  {
    int v8 = *v4;
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v9 = "NOT available";
      if (!v6) {
        uint64_t v9 = "available";
      }
      *(_DWORD *)std::string buf = 136315138;
      *(void *)&uint8_t buf[4] = v9;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I MMS connection availability: %s", buf, 0xCu);
    }
    *(void *)std::string buf = &v20;
    *((unsigned char *)sub_10005CE78((uint64_t **)(a1 + 192), (int *)&v20, (uint64_t)&unk_10144E20E, (_DWORD **)buf) + 32) = v7;
    ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 56));
    uint64_t v11 = ServiceMap;
    if (v12 < 0)
    {
      xpc_object_t v13 = (unsigned __int8 *)(v12 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v14 = 5381;
      do
      {
        uint64_t v12 = v14;
        unsigned int v15 = *v13++;
        uint64_t v14 = (33 * v14) ^ v15;
      }
      while (v15);
    }
    std::mutex::lock(ServiceMap);
    *(void *)std::string buf = v12;
    char v16 = sub_10004D37C(&v11[1].__m_.__sig, (unint64_t *)buf);
    if (v16)
    {
      uint64_t v18 = v16[3];
      char v17 = (std::__shared_weak_count *)v16[4];
      if (v17)
      {
        atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v11);
        atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v17);
        char v19 = 0;
        goto LABEL_14;
      }
    }
    else
    {
      uint64_t v18 = 0;
    }
    std::mutex::unlock(v11);
    char v17 = 0;
    char v19 = 1;
LABEL_14:
    (*(void (**)(uint64_t, void))(*(void *)v18 + 72))(v18, v20);
    if ((v19 & 1) == 0) {
      sub_10004D2C8(v17);
    }
  }
}

void sub_1005C1410(_Unwind_Exception *exception_object)
{
  if ((v2 & 1) == 0) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_1005C1440(uint64_t a1, unsigned int a2, uint64_t a3)
{
  unsigned int v20 = a2;
  int v5 = (uint64_t **)(a1 + 216);
  *(void *)std::string buf = &v20;
  int v6 = sub_10005CE78((uint64_t **)(a1 + 216), (int *)&v20, (uint64_t)&unk_10144E20E, (_DWORD **)buf);
  int v7 = *(unsigned __int8 *)(a3 + 69);
  if (*((unsigned __int8 *)v6 + 32) != v7)
  {
    *(void *)std::string buf = &v20;
    *((unsigned char *)sub_10005CE78(v5, (int *)&v20, (uint64_t)&unk_10144E20E, (_DWORD **)buf) + 32) = v7;
    int v8 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48), v20);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      *(void *)std::string buf = &v20;
      if (*((unsigned char *)sub_10005CE78(v5, (int *)&v20, (uint64_t)&unk_10144E20E, (_DWORD **)buf) + 32)) {
        uint64_t v9 = "true";
      }
      else {
        uint64_t v9 = "false";
      }
      *(_DWORD *)std::string buf = 136315138;
      *(void *)&uint8_t buf[4] = v9;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Is serving network satellite system changed to: %s", buf, 0xCu);
    }
    ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 56));
    uint64_t v11 = ServiceMap;
    if (v12 < 0)
    {
      xpc_object_t v13 = (unsigned __int8 *)(v12 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v14 = 5381;
      do
      {
        uint64_t v12 = v14;
        unsigned int v15 = *v13++;
        uint64_t v14 = (33 * v14) ^ v15;
      }
      while (v15);
    }
    std::mutex::lock(ServiceMap);
    *(void *)std::string buf = v12;
    char v16 = sub_10004D37C(&v11[1].__m_.__sig, (unint64_t *)buf);
    if (v16)
    {
      uint64_t v18 = v16[3];
      char v17 = (std::__shared_weak_count *)v16[4];
      if (v17)
      {
        atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v11);
        atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v17);
        char v19 = 0;
        goto LABEL_15;
      }
    }
    else
    {
      uint64_t v18 = 0;
    }
    std::mutex::unlock(v11);
    char v17 = 0;
    char v19 = 1;
LABEL_15:
    (*(void (**)(uint64_t, void))(*(void *)v18 + 72))(v18, v20);
    if ((v19 & 1) == 0) {
      sub_10004D2C8(v17);
    }
  }
}

void sub_1005C1690(_Unwind_Exception *exception_object)
{
  char v3 = v1;
  if ((v3 & 1) == 0) {
    sub_10004D2C8(v2);
  }
  _Unwind_Resume(exception_object);
}

void sub_1005C16C4(uint64_t a1, unsigned int a2, uint64_t a3)
{
  unsigned int v25 = a2;
  (*(void (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48));
  int v7 = *(uint64_t **)(a3 + 8);
  int v6 = (uint64_t *)(a3 + 8);
  int v5 = v7;
  if (v7)
  {
    int v8 = (int *)v6;
    uint64_t v9 = v5;
    do
    {
      int v10 = *((_DWORD *)v9 + 8);
      BOOL v11 = v10 < 2;
      if (v10 >= 2) {
        uint64_t v12 = (uint64_t **)v9;
      }
      else {
        uint64_t v12 = (uint64_t **)(v9 + 1);
      }
      if (!v11) {
        int v8 = (int *)v9;
      }
      uint64_t v9 = *v12;
    }
    while (*v12);
    if (v8 != (int *)v6 && v8[8] <= 2)
    {
      while (1)
      {
        while (1)
        {
          int v13 = *((_DWORD *)v5 + 8);
          if (v13 < 3) {
            break;
          }
          int v5 = (uint64_t *)*v5;
          if (!v5) {
            goto LABEL_16;
          }
        }
        if (v13 == 2) {
          break;
        }
        int v5 = (uint64_t *)v5[1];
        if (!v5) {
LABEL_16:
        }
          sub_1000C14F0("map::at:  key not found");
      }
      uint64_t v14 = *((unsigned int *)v5 + 11);
      xpc_type_t v26 = &v25;
      *((unsigned char *)sub_10005CE78((uint64_t **)(a1 + 168), (int *)&v25, (uint64_t)&unk_10144E20E, &v26) + 32) = v14 == 2;
      ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 56));
      char v16 = ServiceMap;
      if (v17 < 0)
      {
        uint64_t v18 = (unsigned __int8 *)(v17 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v19 = 5381;
        do
        {
          uint64_t v17 = v19;
          unsigned int v20 = *v18++;
          uint64_t v19 = (33 * v19) ^ v20;
        }
        while (v20);
      }
      std::mutex::lock(ServiceMap);
      xpc_type_t v26 = (unsigned int *)v17;
      int64_t v21 = sub_10004D37C(&v16[1].__m_.__sig, (unint64_t *)&v26);
      if (v21)
      {
        uint64_t v23 = v21[3];
        unint64_t v22 = (std::__shared_weak_count *)v21[4];
        if (v22)
        {
          atomic_fetch_add_explicit(&v22->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v16);
          atomic_fetch_add_explicit(&v22->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v22);
          char v24 = 0;
          goto LABEL_25;
        }
      }
      else
      {
        uint64_t v23 = 0;
      }
      std::mutex::unlock(v16);
      unint64_t v22 = 0;
      char v24 = 1;
LABEL_25:
      (*(void (**)(uint64_t, void, uint64_t))(*(void *)v23 + 48))(v23, v25, v14);
      if ((v24 & 1) == 0) {
        sub_10004D2C8(v22);
      }
    }
  }
}

void sub_1005C18A8(_Unwind_Exception *exception_object)
{
  if ((v1 & 1) == 0) {
    sub_10004D2C8(v2);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_1005C18C4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_DWORD *)a2 != *(_DWORD *)a3
    || *(_DWORD *)(a2 + 8) != *(_DWORD *)(a3 + 8)
    || *(_DWORD *)(a2 + 12) != *(_DWORD *)(a3 + 12))
  {
    return 0;
  }
  uint64_t v3 = 0;
  uint64_t v4 = a3 + 16;
  do
  {
    BOOL v6 = *(_DWORD *)(a2 + v3 + 16) == *(_DWORD *)(v4 + v3) && *(void *)(a2 + v3 + 24) == *(void *)(v4 + v3 + 8);
    BOOL v7 = !v6 || v3 == 16;
    v3 += 16;
  }
  while (!v7);
  return v6
      && *(unsigned __int8 *)(a2 + 48) == *(unsigned __int8 *)(a3 + 48)
      && *(_DWORD *)(a2 + 52) == *(_DWORD *)(a3 + 52);
}

uint64_t sub_1005C1960(uint64_t a1)
{
  return (*(uint64_t (**)(void, void, void))(**(void **)(**(void **)(a1 + 40) + 96) + 40))(*(void *)(**(void **)(a1 + 40) + 96), **(void **)(*(void *)(a1 + 40) + 8), **(unsigned __int8 **)(*(void *)(a1 + 40) + 16));
}

uint64_t sub_1005C199C(uint64_t a1)
{
  return *(unsigned int *)sub_1000FA5F4(*(uint64_t **)(**(void **)(a1 + 40) + 152), **(_DWORD **)(*(void *)(a1 + 40) + 8));
}

uint64_t sub_1005C19C8(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 40) + 16))();
  **(_DWORD **)(a1 + 32) = result;
  return result;
}

uint64_t sub_1005C1A04(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 40) + 16))();
  **(_DWORD **)(a1 + 32) = result;
  return result;
}

uint64_t sub_1005C1A40(uint64_t a1)
{
  return *(unsigned int *)(**(void **)(a1 + 40) + 520);
}

uint64_t sub_1005C1A50(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 40) + 16))();
  **(_DWORD **)(a1 + 32) = result;
  return result;
}

uint64_t sub_1005C1A8C(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 40) + 16))();
  **(_DWORD **)(a1 + 32) = result;
  return result;
}

uint64_t sub_1005C1AC8(uint64_t a1)
{
  return *(unsigned __int8 *)sub_10012EF5C(**(void **)(a1 + 40) + 168, *(int **)(*(void *)(a1 + 40) + 8));
}

uint64_t sub_1005C1AF0(uint64_t a1)
{
  return *(unsigned __int8 *)sub_10012EF5C(**(void **)(a1 + 40) + 192, *(int **)(*(void *)(a1 + 40) + 8));
}

uint64_t sub_1005C1B18(uint64_t a1)
{
  return *(unsigned __int8 *)sub_10012EF5C(**(void **)(a1 + 40) + 216, *(int **)(*(void *)(a1 + 40) + 8));
}

BOOL sub_1005C1B40(int **a1)
{
  uint64_t v2 = (uint64_t)*a1;
  if (*(_DWORD *)sub_1000FA5F4(*((uint64_t **)*a1 + 19), *a1[1]) == -2)
  {
    uint64_t v3 = *(std::__shared_weak_count **)(v2 + 16);
    if (v3)
    {
      if (std::__shared_weak_count::lock(v3)) {
        operator new();
      }
    }
    sub_100088B9C();
  }
  int v4 = sub_1005BBC44(v2, *a1[1]);
  int v5 = a1[1];
  if (!v4) {
    return *(unsigned char *)sub_10012EF5C(v2 + 192, v5) != 0;
  }
  BOOL v6 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), *v5);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Device to be brought up online", buf, 2u);
  }
  return 1;
}

void sub_1005C1CF8(uint64_t **a1)
{
  char v1 = *a1;
  uint64_t v2 = **a1;
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(v2 + 56));
  int v4 = ServiceMap;
  if (v5 < 0)
  {
    BOOL v6 = (unsigned __int8 *)(v5 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v7 = 5381;
    do
    {
      uint64_t v5 = v7;
      unsigned int v8 = *v6++;
      uint64_t v7 = (33 * v7) ^ v8;
    }
    while (v8);
  }
  std::mutex::lock(ServiceMap);
  *(void *)std::string buf = v5;
  uint64_t v9 = sub_10004D37C(&v4[1].__m_.__sig, (unint64_t *)buf);
  if (v9)
  {
    uint64_t v11 = v9[3];
    int v10 = (std::__shared_weak_count *)v9[4];
    if (v10)
    {
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v4);
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v10);
      char v12 = 0;
      if (!v11) {
        goto LABEL_7;
      }
      goto LABEL_11;
    }
  }
  else
  {
    uint64_t v11 = 0;
  }
  std::mutex::unlock(v4);
  int v10 = 0;
  char v12 = 1;
  if (!v11)
  {
LABEL_7:
    int v13 = -1;
    if (v12)
    {
LABEL_13:
      uint64_t v14 = (std::mutex *)Registry::getServiceMap(*(Registry **)(v2 + 56));
      unsigned int v15 = v14;
      char v16 = "27MessageCenterModelInterface";
      if (((unint64_t)"27MessageCenterModelInterface" & 0x8000000000000000) != 0)
      {
        uint64_t v17 = (unsigned __int8 *)((unint64_t)"27MessageCenterModelInterface" & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v18 = 5381;
        do
        {
          char v16 = (const char *)v18;
          unsigned int v19 = *v17++;
          uint64_t v18 = (33 * v18) ^ v19;
        }
        while (v19);
      }
      std::mutex::lock(v14);
      *(void *)std::string buf = v16;
      unsigned int v20 = sub_10004D37C(&v15[1].__m_.__sig, (unint64_t *)buf);
      if (v20)
      {
        uint64_t v22 = v20[3];
        int64_t v21 = (std::__shared_weak_count *)v20[4];
        if (v21)
        {
          atomic_fetch_add_explicit(&v21->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v15);
          atomic_fetch_add_explicit(&v21->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v21);
          char v23 = 0;
          if (!v22) {
            goto LABEL_19;
          }
          goto LABEL_23;
        }
      }
      else
      {
        uint64_t v22 = 0;
      }
      std::mutex::unlock(v15);
      int64_t v21 = 0;
      char v23 = 1;
      if (!v22)
      {
LABEL_19:
        char v24 = *(NSObject **)(*(uint64_t (**)(void, void))(**(void **)(v2 + 48) + 16))(*(void *)(v2 + 48), *((unsigned int *)v1 + 2));
        if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)std::string buf = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "Unable to retrieve MessageCenterModel. Not posting notification", buf, 2u);
        }
        goto LABEL_25;
      }
LABEL_23:
      if (v13 == -1)
      {
        uint64_t v25 = *((unsigned int *)v1 + 2);
        BOOL v26 = sub_1005BB5B0((void *)v2, *((_DWORD *)v1 + 2));
        (*(void (**)(uint64_t, uint64_t, uint64_t, BOOL))(*(void *)v22 + 152))(v22, v25, 0xFFFFFFFFLL, v26);
      }
LABEL_25:
      if ((v23 & 1) == 0) {
        sub_10004D2C8(v21);
      }
      operator delete();
    }
LABEL_12:
    sub_10004D2C8(v10);
    goto LABEL_13;
  }
LABEL_11:
  int v13 = (*(uint64_t (**)(uint64_t, void, uint64_t))(*(void *)v11 + 256))(v11, *((unsigned int *)v1 + 2), 4);
  if (v12) {
    goto LABEL_13;
  }
  goto LABEL_12;
}

void sub_1005C1FB0()
{
  if ((v1 & 1) == 0) {
    sub_10004D2C8(v0);
  }
  operator delete();
}

BOOL sub_1005C2008(uint64_t a1)
{
  return sub_1005C1B40(*(int ***)(a1 + 40));
}

uint64_t sub_1005C2010(uint64_t a1)
{
  uint64_t v2 = **(void **)(a1 + 40);
  __p[1] = 0;
  uint64_t v8 = 0;
  __p[0] = 0;
  PersonalityIdFromSlotIdEx();
  uint64_t v3 = sub_100046F68(v2 + 544, __p);
  int v4 = v3;
  uint64_t v5 = (void **)(v2 + 552);
  if (v5 != v3) {
    BOOL v1 = *((_DWORD *)v3 + 14) == 1 && *((unsigned char *)v3 + 64) != 0;
  }
  if (SHIBYTE(v8) < 0) {
    operator delete(__p[0]);
  }
  return (v5 != v4) & v1;
}

void sub_1005C20BC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_1005C20D8(uint64_t a1)
{
  BOOL v1 = *(unsigned int ***)(a1 + 40);
  uint64_t v2 = *v1;
  uint64_t v3 = (uint64_t *)(*v1 + 20);
  uint64_t v4 = *v3;
  uint64_t v5 = *v1[1];
  if (*v3)
  {
    uint64_t v6 = (uint64_t)(*v1 + 20);
    do
    {
      int v7 = *(_DWORD *)(v4 + 32);
      BOOL v8 = v7 < (int)v5;
      if (v7 >= (int)v5) {
        uint64_t v9 = (uint64_t *)v4;
      }
      else {
        uint64_t v9 = (uint64_t *)(v4 + 8);
      }
      if (!v8) {
        uint64_t v6 = v4;
      }
      uint64_t v4 = *v9;
    }
    while (*v9);
    if ((uint64_t *)v6 != v3 && (int)v5 >= *(_DWORD *)(v6 + 32)) {
      return *(unsigned char *)(v6 + 41) != 0;
    }
  }
  int v10 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**((void **)v2 + 6) + 16))(*((void *)v2 + 6), v5);
  BOOL result = os_log_type_enabled(v10, OS_LOG_TYPE_ERROR);
  if (result)
  {
    v12[0] = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "fControllerSettings context invalid.", (uint8_t *)v12, 2u);
    return 0;
  }
  return result;
}

BOOL sub_1005C21C0(uint64_t a1)
{
  BOOL v1 = *(unsigned int ***)(a1 + 40);
  uint64_t v2 = *v1;
  uint64_t v3 = (uint64_t *)(*v1 + 20);
  uint64_t v4 = *v3;
  uint64_t v5 = *v1[1];
  if (*v3)
  {
    uint64_t v6 = (uint64_t)(*v1 + 20);
    do
    {
      int v7 = *(_DWORD *)(v4 + 32);
      BOOL v8 = v7 < (int)v5;
      if (v7 >= (int)v5) {
        uint64_t v9 = (uint64_t *)v4;
      }
      else {
        uint64_t v9 = (uint64_t *)(v4 + 8);
      }
      if (!v8) {
        uint64_t v6 = v4;
      }
      uint64_t v4 = *v9;
    }
    while (*v9);
    if ((uint64_t *)v6 != v3 && (int)v5 >= *(_DWORD *)(v6 + 32)) {
      return *(unsigned char *)(v6 + 40) != 0;
    }
  }
  int v10 = *(NSObject **)(*(uint64_t (**)(void, uint64_t))(**((void **)v2 + 6) + 16))(*((void *)v2 + 6), v5);
  BOOL result = os_log_type_enabled(v10, OS_LOG_TYPE_ERROR);
  if (result)
  {
    v12[0] = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "fControllerSettings context invalid.", (uint8_t *)v12, 2u);
    return 0;
  }
  return result;
}

uint64_t sub_1005C22A8(uint64_t a1)
{
  return *(unsigned __int8 *)sub_10012EF5C(**(void **)(a1 + 40) + 240, *(int **)(*(void *)(a1 + 40) + 8));
}

uint64_t sub_1005C22D0(uint64_t a1)
{
  return *(unsigned __int8 *)sub_10012EF5C(**(void **)(a1 + 40) + 264, *(int **)(*(void *)(a1 + 40) + 8));
}

uint64_t sub_1005C22F8(uint64_t a1)
{
  return *(unsigned __int8 *)sub_10012EF5C(**(void **)(a1 + 40) + 288, *(int **)(*(void *)(a1 + 40) + 8));
}

BOOL sub_1005C2320(uint64_t a1)
{
  BOOL v1 = *(_DWORD ***)(a1 + 40);
  uint64_t v2 = *((void *)*v1 + 75);
  if (!v2) {
    return 0;
  }
  uint64_t v3 = (uint64_t)(*v1 + 150);
  int v4 = *v1[1];
  uint64_t v5 = v3;
  do
  {
    int v6 = *(_DWORD *)(v2 + 28);
    BOOL v7 = v6 < v4;
    if (v6 >= v4) {
      BOOL v8 = (uint64_t *)v2;
    }
    else {
      BOOL v8 = (uint64_t *)(v2 + 8);
    }
    if (!v7) {
      uint64_t v5 = v2;
    }
    uint64_t v2 = *v8;
  }
  while (*v8);
  return v5 != v3 && v4 >= *(_DWORD *)(v5 + 28) && *(unsigned char *)(v5 + 32) != 0;
}

void *sub_1005C2388@<X0>(void *result@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2 = (_DWORD **)result[5];
  uint64_t v3 = *((void *)*v2 + 72);
  if (!v3) {
    goto LABEL_11;
  }
  uint64_t v4 = (uint64_t)(*v2 + 144);
  int v5 = *v2[1];
  uint64_t v6 = v4;
  do
  {
    int v7 = *(_DWORD *)(v3 + 32);
    BOOL v8 = v7 < v5;
    if (v7 >= v5) {
      uint64_t v9 = (uint64_t *)v3;
    }
    else {
      uint64_t v9 = (uint64_t *)(v3 + 8);
    }
    if (!v8) {
      uint64_t v6 = v3;
    }
    uint64_t v3 = *v9;
  }
  while (*v9);
  if (v6 != v4 && v5 >= *(_DWORD *)(v6 + 32))
  {
    if (*(char *)(v6 + 63) < 0)
    {
      return sub_10004FC84((unsigned char *)a2, *(void **)(v6 + 40), *(void *)(v6 + 48));
    }
    else
    {
      long long v10 = *(_OWORD *)(v6 + 40);
      *(void *)(a2 + 16) = *(void *)(v6 + 56);
      *(_OWORD *)a2 = v10;
    }
  }
  else
  {
LABEL_11:
    *(void *)a2 = 0;
    *(void *)(a2 + 8) = 0;
    *(void *)(a2 + 16) = 0;
  }
  return result;
}

__n128 sub_1005C240C(uint64_t a1)
{
  (*(void (**)(__n128 *__return_ptr))(**(void **)(a1 + 40) + 16))(&v4);
  uint64_t v2 = *(void *)(a1 + 32);
  if (*(char *)(v2 + 23) < 0) {
    operator delete(*(void **)v2);
  }
  __n128 result = v4;
  *(void *)(v2 + 16) = v5;
  *(__n128 *)uint64_t v2 = result;
  return result;
}

BOOL sub_1005C2470(int **a1)
{
  uint64_t v2 = (uint64_t)*a1;
  uint64_t v3 = (capabilities::ct *)(*(uint64_t (**)(void, void))(**((void **)*a1 + 6) + 16))(*((void *)*a1 + 6), *a1[1]);
  int v4 = capabilities::ct::supportsWidgetMode(v3);
  int v5 = *(_DWORD *)(v2 + 664);
  int v6 = *(unsigned __int8 *)(v2 + 432);
  BOOL v7 = sub_1005BAAC4(v2, *a1[1]);
  BOOL v8 = *(NSObject **)v3;
  if (os_log_type_enabled(*(os_log_t *)v3, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v9 = "false";
    if (v4) {
      long long v10 = "true";
    }
    else {
      long long v10 = "false";
    }
    if (v5 == 1) {
      uint64_t v11 = "true";
    }
    else {
      uint64_t v11 = "false";
    }
    int v17 = 136315906;
    uint64_t v18 = v10;
    if (v6) {
      char v12 = "true";
    }
    else {
      char v12 = "false";
    }
    __int16 v19 = 2080;
    unsigned int v20 = v11;
    __int16 v21 = 2080;
    uint64_t v22 = v12;
    if (v7) {
      uint64_t v9 = "true";
    }
    __int16 v23 = 2080;
    char v24 = v9;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Should we check for SIM state? Supports Tinker mode: %s, is in Tinker mode: %s, is in airplane mode: %s, is IMS registered over wifi: %s", (uint8_t *)&v17, 0x2Au);
  }
  if ((v4 & 1) == 0)
  {
    uint64_t v14 = *(NSObject **)v3;
    if (!os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT)) {
      return 1;
    }
    LOWORD(v17) = 0;
    char v16 = "#I Device does not support Tinker mode, check SIM state";
LABEL_28:
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, v16, (uint8_t *)&v17, 2u);
    return 1;
  }
  if (v5 != 1)
  {
    uint64_t v14 = *(NSObject **)v3;
    if (!os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT)) {
      return 1;
    }
    LOWORD(v17) = 0;
    char v16 = "#I Device not in Tinker mode, check SIM state";
    goto LABEL_28;
  }
  if (v6) {
    BOOL v13 = v7;
  }
  else {
    BOOL v13 = 0;
  }
  uint64_t v14 = *(NSObject **)v3;
  BOOL result = os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT);
  if (!v13)
  {
    if (result)
    {
      LOWORD(v17) = 0;
      char v16 = "#I SIM check required";
      goto LABEL_28;
    }
    return 1;
  }
  if (result)
  {
    LOWORD(v17) = 0;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I Device in Tinker mode, Airplane mode, and IMS registered over WiFi: SIM state check not required", (uint8_t *)&v17, 2u);
    return 0;
  }
  return result;
}

BOOL sub_1005C26A8(uint64_t a1)
{
  return sub_1005C2470(*(int ***)(a1 + 40));
}

BOOL sub_1005C26B0(uint64_t a1)
{
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 56));
  uint64_t v3 = ServiceMap;
  if ((v4 & 0x8000000000000000) != 0)
  {
    int v5 = (unsigned __int8 *)(v4 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v6 = 5381;
    do
    {
      unint64_t v4 = v6;
      unsigned int v7 = *v5++;
      uint64_t v6 = (33 * v6) ^ v7;
    }
    while (v7);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v14 = v4;
  BOOL v8 = sub_10004D37C(&v3[1].__m_.__sig, &v14);
  if (v8)
  {
    uint64_t v10 = v8[3];
    uint64_t v9 = (std::__shared_weak_count *)v8[4];
    if (v9)
    {
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v3);
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v9);
      char v11 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v10 = 0;
  }
  std::mutex::unlock(v3);
  uint64_t v9 = 0;
  char v11 = 1;
LABEL_9:
  int v12 = (*(uint64_t (**)(uint64_t))(*(void *)v10 + 16))(v10);
  if ((v11 & 1) == 0) {
    sub_10004D2C8(v9);
  }
  return v12 && *(unsigned char *)(a1 + 720) != 0;
}

void sub_1005C27D0(_Unwind_Exception *exception_object)
{
  if ((v2 & 1) == 0) {
    sub_10004D2C8(v1);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_1005C27EC(uint64_t a1)
{
  return sub_1005C26B0(**(void **)(a1 + 40));
}

uint64_t sub_1005C27F8(int **a1)
{
  uint64_t v2 = (uint64_t)*a1;
  uint64_t v3 = (capabilities::ct *)(*(uint64_t (**)(void, void))(**((void **)*a1 + 6) + 16))(*((void *)*a1 + 6), *a1[1]);
  uint64_t result = capabilities::ct::supportsWidgetMode(v3);
  if (result)
  {
    if (*(_DWORD *)(v2 + 664) != 1
      || sub_1005BC400(v2, *a1[1])
      || (isActive() & 1) != 0
      || *(unsigned char *)sub_10012EF5C(v2 + 192, a1[1]))
    {
      return 0;
    }
    else
    {
      uint64_t result = sub_1005BAAC4(v2, *a1[1]);
      if (result)
      {
        int v5 = *(NSObject **)v3;
        if (os_log_type_enabled(*(os_log_t *)v3, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)uint64_t v6 = 0;
          _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Baseband assertion required", v6, 2u);
        }
        return 1;
      }
    }
  }
  return result;
}

uint64_t sub_1005C2900(uint64_t a1)
{
  return sub_1005C27F8(*(int ***)(a1 + 40));
}

uint64_t sub_1005C2908(uint64_t a1)
{
  return (*(uint64_t (**)(void, void, void))(**(void **)(**(void **)(a1 + 40) + 96) + 32))(*(void *)(**(void **)(a1 + 40) + 96), **(void **)(*(void *)(a1 + 40) + 8), **(unsigned __int8 **)(*(void *)(a1 + 40) + 16));
}

uint64_t sub_1005C2944(uint64_t a1)
{
  return *(unsigned __int8 *)sub_1000389F8(*(uint64_t **)(**(void **)(a1 + 40) + 320), **(_DWORD **)(*(void *)(a1 + 40) + 8));
}

uint64_t sub_1005C2970(uint64_t a1)
{
  return sub_1000389F8(*(uint64_t **)(**(void **)(a1 + 40) + 320), **(_DWORD **)(*(void *)(a1 + 40) + 8))[1];
}

uint64_t sub_1005C299C(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 40) + 16))();
  **(void **)(a1 + 32) = result;
  return result;
}

uint64_t sub_1005C29D8(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 40) + 16))();
  **(void **)(a1 + 32) = result;
  return result;
}

BOOL sub_1005C2A14(uint64_t a1)
{
  BOOL v1 = sub_1000389F8(*(uint64_t **)(**(void **)(a1 + 40) + 320), **(_DWORD **)(*(void *)(a1 + 40) + 8));
  if (*(unsigned char *)v1) {
    BOOL v2 = v1[1] < 0;
  }
  else {
    BOOL v2 = 1;
  }
  return !v2;
}

uint64_t sub_1005C2A50(uint64_t a1)
{
  return *(unsigned int *)sub_1000FA5F4(*(uint64_t **)(**(void **)(a1 + 40) + 344), **(_DWORD **)(*(void *)(a1 + 40) + 8));
}

uint64_t sub_1005C2A7C(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 40) + 16))();
  **(_DWORD **)(a1 + 32) = result;
  return result;
}

uint64_t sub_1005C2AB8(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 40) + 16))();
  **(_DWORD **)(a1 + 32) = result;
  return result;
}

uint64_t sub_1005C2AF4(_DWORD **a1)
{
  BOOL v1 = *a1;
  uint64_t v2 = *((void *)*a1 + 88);
  if (!v2) {
    goto LABEL_11;
  }
  uint64_t v3 = v1 + 88;
  int v4 = *a1[1];
  int v5 = v1 + 88;
  do
  {
    int v6 = *(_DWORD *)(v2 + 32);
    BOOL v7 = v6 < v4;
    if (v6 >= v4) {
      BOOL v8 = (uint64_t *)v2;
    }
    else {
      BOOL v8 = (uint64_t *)(v2 + 8);
    }
    if (!v7) {
      int v5 = (void *)v2;
    }
    uint64_t v2 = *v8;
  }
  while (*v8);
  if (v5 != v3 && v4 >= *((_DWORD *)v5 + 8))
  {
    int v12 = (MCCAndMNC *)(v5 + 5);
    MCCAndMNC::getMcc(&v14, (MCCAndMNC *)(v5 + 5));
    int IntValue = MCC::getIntValue((MCC *)&v14);
    if (v16 < 0) {
      operator delete(__p);
    }
    MCCAndMNC::getMnc(&v14, v12);
    int v13 = MCC::getIntValue((MCC *)&v14);
    if (v16 < 0) {
      operator delete(__p);
    }
    int v9 = v13 << 16;
  }
  else
  {
LABEL_11:
    int v9 = -65536;
    int IntValue = 0xFFFF;
  }
  return v9 | IntValue;
}

void sub_1005C2BCC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1005C2BEC(uint64_t a1)
{
  return sub_1005C2AF4(*(_DWORD ***)(a1 + 40));
}

uint64_t sub_1005C2BF4(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 40) + 16))();
  **(_DWORD **)(a1 + 32) = result;
  return result;
}

uint64_t sub_1005C2C30(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 40) + 16))();
  **(_DWORD **)(a1 + 32) = result;
  return result;
}

void sub_1005C2C6C(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1019EB7C0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1005C2C8C(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1019EB7C0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_1005C2CE0(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

uint64_t sub_1005C2D08(uint64_t result)
{
  *(unsigned char *)(**(void **)(result + 40) + 720) = **(unsigned char **)(*(void *)(result + 40) + 8);
  return result;
}

void sub_1005C2D1C()
{
}

void sub_1005C2D90()
{
}

void sub_1005C2DB4(uint64_t a1, uint64_t a2, NSObject **a3)
{
  *(void *)a1 = &off_1019EA828;
  int v6 = (void *)(a1 + 8);
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&__p, kCtLoggingSystemName, "stw.bb.ctr");
  void *v6 = 0;
  v6[1] = 0;
  BOOL v7 = *a3;
  *(void *)(a1 + 24) = *a3;
  if (v7) {
    dispatch_retain(v7);
  }
  *(void *)(a1 + 32) = 0;
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)&v9, &__p);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 40), (const ctu::OsLogLogger *)&v9);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)&v9);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&__p);
  *(void *)a1 = off_1019EB848;
  *(void *)(a1 + 48) = off_1019EB9A8;
  *(void *)(a1 + 56) = off_1019EBA30;
  *(void *)(a1 + 72) = 0;
  *(void *)(a1 + 80) = 0;
  *(void *)(a1 + 96) = 0;
  *(void *)(a1 + 88) = a1 + 96;
  *(void *)(a1 + 104) = 0;
  *(_DWORD *)(a1 + 64) = 0;
  *(unsigned char *)(a1 + 68) = 0;
  *(unsigned char *)(a1 + 284) = 0;
  *(unsigned char *)(a1 + 312) = 0;
  *(unsigned char *)(a1 + 316) = 0;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(unsigned char *)(a1 + 144) = 0;
  *(_OWORD *)(a1 + 244) = 0u;
  *(_OWORD *)(a1 + 228) = 0u;
  *(_OWORD *)(a1 + 212) = 0u;
  *(_OWORD *)(a1 + 196) = 0u;
  *(_OWORD *)(a1 + 180) = 0u;
  *(_OWORD *)(a1 + 164) = 0u;
  *(_OWORD *)(a1 + 148) = 0u;
  *(void *)(a1 + 264) = 0;
  *(void *)(a1 + 272) = 0;
  *(_DWORD *)(a1 + 279) = 0;
  *(_OWORD *)(a1 + 320) = 0u;
  *(_OWORD *)(a1 + 336) = 0u;
  *(unsigned char *)(a1 + 352) = 0;
  *(_OWORD *)(a1 + 360) = *(_OWORD *)a2;
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = 0;
  *(void *)(a1 + 376) = 0;
  *(void *)(a1 + 384) = 0;
  BOOL v8 = (char *)operator new(8uLL);
  __p.var0 = v8;
  *(void *)BOOL v8 = @"Stewie";
  __p.var1.fRef = (os_log_s *)(v8 + 8);
  char v11 = v8 + 8;
  sub_1005CBE24((void *)(a1 + 392));
}

void sub_1005C31D0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, const void *a13, void *a14, uint64_t a15)
{
  if (__p)
  {
    a11 = (uint64_t)__p;
    operator delete(__p);
  }
  sub_100030068(&a13);
  OsLogContext __p = (void *)(v16 + 648);
  sub_1005CB95C((void ***)&__p);
  uint64_t v22 = *(std::__shared_weak_count **)(v16 + 632);
  if (v22) {
    sub_10004D2C8(v22);
  }
  uint64_t v23 = *(void *)(v16 + 616);
  *(void *)(v16 + 616) = 0;
  if (v23) {
    (*(void (**)(uint64_t))(*(void *)v23 + 32))(v23);
  }
  uint64_t v24 = *(void *)(v16 + 600);
  *(void *)(v16 + 600) = 0;
  if (v24) {
    (*(void (**)(uint64_t))(*(void *)v24 + 32))(v24);
  }
  if (*(unsigned char *)(v16 + 584))
  {
    uint64_t v25 = *v20;
    if (*v20)
    {
      *(void *)(v16 + 568) = v25;
      operator delete(v25);
    }
  }
  uint64_t v26 = *(void *)(v16 + 536);
  *(void *)(v16 + 536) = 0;
  if (v26) {
    sub_10026CD9C(v16 + 536, v26);
  }
  uint64_t v27 = *(std::__shared_weak_count **)(v16 + 512);
  if (v27) {
    sub_10004D2C8(v27);
  }
  int v28 = *(std::__shared_weak_count **)(v16 + 496);
  if (v28) {
    sub_10004D2C8(v28);
  }
  uint64_t v29 = *(std::__shared_weak_count **)(v16 + 472);
  if (v29) {
    sub_10004D2C8(v29);
  }
  int v30 = *(std::__shared_weak_count **)(v16 + 456);
  if (v30) {
    sub_10004D2C8(v30);
  }
  BOOL v31 = (uint64_t *)(v16 + 424);
  uint64_t v32 = *(void *)(v16 + 432);
  *(void *)(v16 + 432) = 0;
  if (v32) {
    (*(void (**)(uint64_t))(*(void *)v32 + 40))(v32);
  }
  uint64_t v33 = *v31;
  *BOOL v31 = 0;
  if (v33) {
    (*(void (**)(uint64_t))(*(void *)v33 + 8))(v33);
  }
  uint64_t v34 = *(void *)(v16 + 400);
  *(void *)(v16 + 400) = 0;
  if (v34) {
    sub_10026CD9C(v16 + 400, v34);
  }
  uint64_t v35 = *(std::__shared_weak_count **)(v16 + 384);
  if (v35) {
    std::__shared_weak_count::__release_weak(v35);
  }
  uint64_t v36 = *(std::__shared_weak_count **)(v16 + 368);
  if (v36) {
    sub_10004D2C8(v36);
  }
  long long v37 = *(std::__shared_weak_count **)(v16 + 344);
  if (v37) {
    sub_10004D2C8(v37);
  }
  long long v38 = *(std::__shared_weak_count **)(v16 + 328);
  if (v38) {
    sub_10004D2C8(v38);
  }
  uint64_t v39 = *(std::__shared_weak_count **)(v16 + 272);
  if (v39) {
    sub_10004D2C8(v39);
  }
  uint64_t v40 = *(std::__shared_weak_count **)(v16 + 200);
  if (v40) {
    sub_10004D2C8(v40);
  }
  int v41 = *(std::__shared_weak_count **)(v16 + 184);
  if (v41) {
    sub_10004D2C8(v41);
  }
  xpc_object_t v42 = *(std::__shared_weak_count **)(v16 + 168);
  if (v42) {
    sub_10004D2C8(v42);
  }
  long long v43 = *(std::__shared_weak_count **)(v16 + 136);
  if (v43) {
    sub_10004D2C8(v43);
  }
  sub_1000346F8(v19, *(void **)(v16 + 96));
  xpc_object_t v44 = *(std::__shared_weak_count **)(v16 + 80);
  if (v44) {
    sub_10004D2C8(v44);
  }
  StewieCommandDriverDelegate::~StewieCommandDriverDelegate(v18);
  ctu::OsLogLogger::~OsLogLogger(v17);
  sub_100087E88(v15);
  _Unwind_Resume(a1);
}

uint64_t sub_1005C34B0(uint64_t a1)
{
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v2 = (void *)(a1 + 8);
  uint64_t v3 = v4;
  void *v2 = 0;
  if (v4) {
    sub_10026CD9C((uint64_t)v2, v3);
  }
  return a1;
}

void sub_1005C34E4(uint64_t a1, long long *a2)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 24));
  uint64_t v4 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Bootstrap", buf, 2u);
  }
  long long v5 = *a2;
  *(void *)a2 = 0;
  *((void *)a2 + 1) = 0;
  int v6 = *(std::__shared_weak_count **)(a1 + 384);
  *(_OWORD *)(a1 + 376) = v5;
  if (v6) {
    std::__shared_weak_count::__release_weak(v6);
  }
  operator new();
}

void sub_1005C3754(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (a14) {
    std::__shared_weak_count::__release_weak(a14);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1005C37AC(uint64_t a1)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 24));
  if (!*(void *)(a1 + 320)) {
    __TUAssertTrigger();
  }
  uint64_t v2 = *(NSObject **)(a1 + 40);
  BOOL v3 = os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT);
  if (v3)
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Start", buf, 2u);
  }
  if (capabilities::ct::supportsSARAveraging((capabilities::ct *)v3))
  {
    CFDateRef theDate = 0;
    (*(void (**)(unsigned char *__return_ptr))(**(void **)(a1 + 616) + 8))(buf);
    sub_100201EE4(&theDate, (CFTypeRef *)buf);
    sub_1000577C4((const void **)buf);
    if (theDate) {
      uint64_t v4 = sub_1001908E4;
    }
    else {
      uint64_t v4 = 0;
    }
    if (v4)
    {
      CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
      CFDateRef v10 = CFDateCreate(kCFAllocatorDefault, Current);
      double TimeIntervalSinceDate = CFDateGetTimeIntervalSinceDate(theDate, v10);
      BOOL v7 = *(NSObject **)(a1 + 40);
      BOOL v8 = os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT);
      if (TimeIntervalSinceDate >= 0.0)
      {
        if (v8)
        {
          *(_DWORD *)std::string buf = 134217984;
          *(double *)&uint8_t buf[4] = TimeIntervalSinceDate;
          _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I (Start) Unblock Cellular Tx after remaining defer time: %f seconds", buf, 0xCu);
        }
        *(void *)std::string buf = (uint64_t)(TimeIntervalSinceDate * 1000.0);
        sub_1005C3A20(a1, (uint64_t *)buf);
      }
      else
      {
        if (v8)
        {
          *(_WORD *)std::string buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I (Start) Unblock Cellular Tx immediately as defer time has expired", buf, 2u);
        }
        *(void *)std::string buf = 0;
        sub_1005C3A20(a1, (uint64_t *)buf);
      }
      sub_10007CA64((const void **)&v10);
    }
    sub_10007CA64((const void **)&theDate);
  }
  return (*(uint64_t (**)(void))(**(void **)(a1 + 320) + 8))(*(void *)(a1 + 320));
}

void sub_1005C39DC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, const void *a10)
{
}

void sub_1005C3A20(uint64_t a1, uint64_t *a2)
{
  uint64_t v4 = (dispatch_queue_t *)(a1 + 24);
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 24));
  if (capabilities::ct::supportsSARAveraging(v5) && sub_10025B63C(a1 + 528, 0) == 1)
  {
    if (*a2)
    {
      if (!*(void *)(a1 + 624))
      {
        double v6 = (double)*a2 / 1000.0;
        CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
        CFDateRef v16 = CFDateCreate(kCFAllocatorDefault, v6 + Current);
        (***(void (****)(void))(a1 + 616))();
        BOOL v8 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
        {
          LODWORD(buf) = 134217984;
          *(double *)((char *)&buf + 4) = v6;
          _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I [CellularTx] Started timer to unblock in %f seconds", (uint8_t *)&buf, 0xCu);
        }
        sub_100058DB0(&__p, "UnblockCellularTx");
        dispatch_assert_queue_V2(*v4);
        Registry::getTimerService(&v11, *(Registry **)(a1 + 360));
        *(void *)&long long buf = off_1019EBC88;
        *((void *)&buf + 1) = a1;
        p_long long buf = &buf;
        AutoStartTimer::create();
        long long v9 = v15;
        long long v15 = 0uLL;
        CFDateRef v10 = *(std::__shared_weak_count **)(a1 + 632);
        *(_OWORD *)(a1 + 624) = v9;
        if (v10)
        {
          sub_10004D2C8(v10);
          if (*((void *)&v15 + 1)) {
            sub_10004D2C8(*((std::__shared_weak_count **)&v15 + 1));
          }
        }
        sub_10003B34C(&buf);
        if (v12) {
          sub_10004D2C8(v12);
        }
        if (v14 < 0) {
          operator delete(__p);
        }
        sub_10007CA64((const void **)&v16);
      }
    }
    else
    {
      sub_1005C4A14(a1);
    }
  }
}

void sub_1005C3C70(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,const void *a21,uint64_t a22)
{
  if (a11) {
    sub_10004D2C8(a11);
  }
  if (a17 < 0) {
    operator delete(__p);
  }
  sub_10007CA64(&a21);
  _Unwind_Resume(a1);
}

uint64_t sub_1005C3CBC(uint64_t a1)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 24));
  if (!*(void *)(a1 + 320)) {
    __TUAssertTrigger();
  }
  uint64_t v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long v5 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Stop", v5, 2u);
  }
  sub_1005C3D84(a1, 0, 63);
  BOOL v3 = *(std::__shared_weak_count **)(a1 + 384);
  *(void *)(a1 + 376) = 0;
  *(void *)(a1 + 384) = 0;
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  return (*(uint64_t (**)(void))(**(void **)(a1 + 320) + 16))(*(void *)(a1 + 320));
}

void sub_1005C3D84(uint64_t a1, uint64_t a2, __int16 a3)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 24));
  if (*(unsigned char *)(a1 + 64))
  {
    unsigned __int16 v6 = *(_WORD *)(a1 + 646) & ~a3;
    *(_WORD *)(a1 + 646) = v6;
    if (v6)
    {
      BOOL v7 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
      {
        sub_100BC897C(v6, &__p);
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          p_p = &__p;
        }
        else {
          p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
        }
        *(_DWORD *)long long buf = 136446210;
        int v28 = p_p;
        _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Postponed disablement as following services are still running: %{public}s", buf, 0xCu);
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__p.__r_.__value_.__l.__data_);
        }
      }
    }
    else
    {
      *(unsigned char *)(a1 + 64) = 0;
      *(void *)(a1 + 112) = 0;
      if ((a2 & 0xFF00000000) != 0) {
        int v9 = a2;
      }
      else {
        int v9 = 0;
      }
      *(_DWORD *)(a1 + 120) = v9;
      CFDateRef v10 = *(std::__shared_weak_count **)(a1 + 512);
      *(void *)(a1 + 504) = 0;
      *(void *)(a1 + 512) = 0;
      if (v10) {
        sub_10004D2C8(v10);
      }
      if (*(unsigned char *)(a1 + 312)) {
        *(unsigned char *)(a1 + 312) = 0;
      }
      uint64_t v11 = *(std::__shared_weak_count **)(a1 + 272);
      *(void *)(a1 + 264) = 0;
      *(void *)(a1 + 272) = 0;
      if (v11) {
        sub_10004D2C8(v11);
      }
      int v12 = *(const void ***)(a1 + 656);
      int v13 = *(const void ***)(a1 + 648);
      while (v12 != v13)
        int v12 = sub_10012577C(v12 - 1);
      *(void *)(a1 + 656) = v13;
      if (*(unsigned char *)(a1 + 520))
      {
        char v14 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(__p.__r_.__value_.__l.__data_) = 0;
          _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I Stop simulating service info", (uint8_t *)&__p, 2u);
        }
        *(unsigned char *)(a1 + 520) = 0;
      }
      long long v15 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
      {
        CFDateRef v16 = sub_100BC8B90(*(_DWORD *)(a1 + 120));
        LODWORD(__p.__r_.__value_.__l.__data_) = 136315138;
        *(std::string::size_type *)((char *)__p.__r_.__value_.__r.__words + 4) = (std::string::size_type)v16;
        _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I Received request to disable transport. Reason: %s", (uint8_t *)&__p, 0xCu);
      }
      sub_1005C5910(a1);
      dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 24));
      if (*(unsigned char *)(a1 + 441))
      {
        int v17 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(__p.__r_.__value_.__l.__data_) = 0;
          _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I Stop tracking target data", (uint8_t *)&__p, 2u);
        }
        *(unsigned char *)(a1 + 441) = 0;
        uint64_t v18 = *(std::__shared_weak_count **)(a1 + 384);
        if (v18)
        {
          uint64_t v19 = std::__shared_weak_count::lock(v18);
          if (v19)
          {
            unsigned int v20 = v19;
            uint64_t v21 = *(void *)(a1 + 376);
            if (v21) {
              (*(void (**)(uint64_t))(*(void *)v21 + 160))(v21);
            }
            sub_10004D2C8(v20);
          }
        }
      }
      dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 24));
      if (*(void *)(a1 + 448))
      {
        uint64_t v22 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(__p.__r_.__value_.__l.__data_) = 0;
          _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "#I Stopping GPS data updates", (uint8_t *)&__p, 2u);
        }
        uint64_t v23 = *(std::__shared_weak_count **)(a1 + 456);
        *(void *)(a1 + 448) = 0;
        *(void *)(a1 + 456) = 0;
        if (v23) {
          sub_10004D2C8(v23);
        }
      }
      sub_1005C5AD0(a1);
      dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 24));
      if (*(void *)(a1 + 336))
      {
        uint64_t v24 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(__p.__r_.__value_.__l.__data_) = 0;
          _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "#I [PreventNvmSync] Assertion released", (uint8_t *)&__p, 2u);
        }
        uint64_t v25 = *(std::__shared_weak_count **)(a1 + 344);
        *(void *)(a1 + 336) = 0;
        *(void *)(a1 + 344) = 0;
        if (v25) {
          sub_10004D2C8(v25);
        }
      }
      (*(void (**)(void, void))(**(void **)(a1 + 424) + 24))(*(void *)(a1 + 424), 0);
    }
  }
}

void sub_1005C4110(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_1005C412C(uint64_t a1, int a2)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 24));
  if (*(unsigned __int8 *)(a1 + 282) != a2)
  {
    *(unsigned char *)(a1 + 282) = a2;
    uint64_t v4 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      long long v5 = "false";
      if (a2) {
        long long v5 = "true";
      }
      int v6 = 136315138;
      BOOL v7 = v5;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Attempt cellular recovery: %s", (uint8_t *)&v6, 0xCu);
    }
    (*(void (**)(void, void))(**(void **)(a1 + 424) + 24))(*(void *)(a1 + 424), 0);
  }
}

uint64_t sub_1005C4230(uint64_t a1)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 24));
  uint64_t v2 = *(uint64_t (**)(void))(**(void **)(a1 + 432) + 16);

  return v2();
}

void sub_1005C4294(uint64_t a1, int a2)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 24));
  if (*(unsigned __int8 *)(a1 + 440) != a2)
  {
    *(unsigned char *)(a1 + 440) = a2;
    sub_1005C42F0(a1);
  }
}

void *sub_1005C42F0(uint64_t a1)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 24));
  uint64_t v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    if (*(unsigned char *)(a1 + 440)) {
      BOOL v3 = "yes";
    }
    else {
      BOOL v3 = "no";
    }
    int v12 = 136315138;
    int v13 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Sending current provisioning state, isProvisioned: %s, to BB", (uint8_t *)&v12, 0xCu);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (!v4
    || (uint64_t v5 = *(void *)(a1 + 320),
        int v6 = *(unsigned __int8 *)(a1 + 440),
        uint64_t v7 = *(void *)(a1 + 8),
        (BOOL v8 = std::__shared_weak_count::lock(v4)) == 0))
  {
    sub_100088B9C();
  }
  int v9 = v8;
  atomic_fetch_add_explicit(&v8->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v8);
  CFDateRef v10 = operator new(0x20uLL);
  *CFDateRef v10 = off_1019EC218;
  v10[1] = a1;
  void v10[2] = v7;
  void v10[3] = v9;
  char v14 = v10;
  (*(void (**)(uint64_t, BOOL, int *))(*(void *)v5 + 56))(v5, v6 != 0, &v12);
  return sub_100060644(&v12);
}

void sub_1005C4460(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1005C448C(uint64_t a1)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 24));
  if (*(unsigned char *)(a1 + 64))
  {
    if (!*(unsigned char *)(a1 + 68))
    {
      uint64_t v2 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t v4 = 0;
        _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Target data update is due", v4, 2u);
      }
      *(unsigned char *)(a1 + 68) = 1;
      (*(void (**)(void, void))(**(void **)(a1 + 424) + 24))(*(void *)(a1 + 424), 0);
    }
  }
  else
  {
    BOOL v3 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "Transport is not requested", buf, 2u);
    }
  }
}

void sub_1005C457C(uint64_t a1)
{
  uint64_t v2 = a1 + 24;
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 24));
  uint64_t v3 = *(void *)(v2 + 464);
  if (!v3 || *(void *)(a1 + 248) <= *(void *)(a1 + 216))
  {
    uint64_t v4 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v5 = "Re-";
      if (!v3) {
        uint64_t v5 = "";
      }
      *(_DWORD *)long long buf = 136315394;
      *(void *)&uint8_t buf[4] = v5;
      *(_WORD *)&unsigned char buf[12] = 2048;
      *(void *)&buf[14] = 15;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Going to perform regulatory location check. %sScheduled failsafe timer to guarantee regulatory check after %ld minutes", buf, 0x16u);
    }
    Registry::getTimerService((uint64_t *)buf, *(Registry **)(a1 + 360));
    *(void *)(a1 + 248) = (***(uint64_t (****)(void))buf)(*(void *)buf);
    if (*(void *)&buf[8]) {
      sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
    }
    sub_100058DB0(&__p, "StewieRegulatoryLocationCheck");
    Registry::getTimerService(&v8, *(Registry **)(a1 + 360));
    *(void *)long long buf = off_1019EBC08;
    *(void *)&uint8_t buf[8] = a1;
    char v14 = buf;
    AutoStartTimer::create();
    long long v6 = v12;
    long long v12 = 0uLL;
    uint64_t v7 = *(std::__shared_weak_count **)(a1 + 496);
    *(_OWORD *)(v2 + 464) = v6;
    if (v7)
    {
      sub_10004D2C8(v7);
      if (*((void *)&v12 + 1)) {
        sub_10004D2C8(*((std::__shared_weak_count **)&v12 + 1));
      }
    }
    sub_10003B34C(buf);
    if (v9) {
      sub_10004D2C8(v9);
    }
    if (v11 < 0) {
      operator delete(__p);
    }
  }
}

void sub_1005C475C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21)
{
  if (a11) {
    sub_10004D2C8(a11);
  }
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_1005C47B0(uint64_t a1)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 24));
  *(unsigned char *)(a1 + 280) = 0;
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 496);
  *(void *)(a1 + 488) = 0;
  *(void *)(a1 + 496) = 0;
  if (v2)
  {
    sub_10004D2C8(v2);
  }
}

BOOL sub_1005C4804(uint64_t a1)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 24));
  if (*(unsigned char *)(a1 + 280)) {
    return 1;
  }
  if (!*(void *)(a1 + 488)) {
    return 0;
  }
  Registry::getTimerService((uint64_t *)&v4, *(Registry **)(a1 + 360));
  uint64_t v3 = (**v4)(v4) + 120000000000;
  if (v5) {
    sub_10004D2C8(v5);
  }
  return v3 >= AutoStartTimer::getExpiryTime(*(AutoStartTimer **)(a1 + 488));
}

void sub_1005C48B4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_1005C48CC(uint64_t a1)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 24));
  if (capabilities::ct::supportsSARAveraging(v2))
  {
    if (!*(unsigned char *)(a1 + 584)) {
      __TUAssertTrigger();
    }
    uint64_t v3 = *(std::__shared_weak_count **)(a1 + 632);
    *(_OWORD *)(a1 + 624) = 0u;
    if (v3) {
      sub_10004D2C8(v3);
    }
    (*(void (**)(void))(**(void **)(a1 + 616) + 16))(*(void *)(a1 + 616));
    if (sub_10025B63C(a1 + 528, 0) != 1)
    {
      sub_10025CAD8(a1 + 528, 1u);
      uint64_t v4 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)int v9 = 0;
        _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I [CellularTx] Blocking", v9, 2u);
      }
      uint64_t v5 = *(std::__shared_weak_count **)(a1 + 384);
      if (v5)
      {
        long long v6 = std::__shared_weak_count::lock(v5);
        if (v6)
        {
          uint64_t v7 = v6;
          uint64_t v8 = *(void *)(a1 + 376);
          if (v8) {
            (*(void (**)(uint64_t, uint64_t))(*(void *)v8 + 184))(v8, 1);
          }
          sub_10004D2C8(v7);
        }
      }
    }
  }
}

void sub_1005C4A00(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_1005C4A14(uint64_t a1)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 24));
  if (capabilities::ct::supportsSARAveraging(v2) && sub_10025B63C(a1 + 528, 0) == 1)
  {
    sub_10025CAD8(a1 + 528, 0);
    (*(void (**)(void))(**(void **)(a1 + 616) + 16))(*(void *)(a1 + 616));
    uint64_t v3 = *(std::__shared_weak_count **)(a1 + 632);
    *(_OWORD *)(a1 + 624) = 0u;
    if (v3) {
      sub_10004D2C8(v3);
    }
    uint64_t v4 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)int v9 = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I [CellularTx] Unblocking", v9, 2u);
    }
    uint64_t v5 = *(std::__shared_weak_count **)(a1 + 384);
    if (v5)
    {
      long long v6 = std::__shared_weak_count::lock(v5);
      if (v6)
      {
        uint64_t v7 = v6;
        uint64_t v8 = *(void *)(a1 + 376);
        if (v8) {
          (*(void (**)(uint64_t, void))(*(void *)v8 + 184))(v8, 0);
        }
        sub_10004D2C8(v7);
      }
    }
  }
}

void sub_1005C4B34(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t *sub_1005C4B48@<X0>(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 24));
  uint64_t v4 = *(Registry **)(a1 + 360);

  return Registry::getTimerService(a2, v4);
}

void sub_1005C4B8C(uint64_t a1, double **a2)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 24));
  if (*(unsigned char *)(a1 + 64))
  {
    uint64_t v4 = *a2;
    if (*a2)
    {
      int v5 = (*(_WORD *)(a1 + 646) & 1) == 0 && v4[9] >= 89.408;
      if (*(unsigned __int8 *)(a1 + 352) != v5)
      {
        *(unsigned char *)(a1 + 352) = v5;
        long long v6 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v7 = "NOT ";
          uint64_t v8 = *((void *)v4 + 9);
          *(_DWORD *)CFDateRef v16 = 136315650;
          if (v5) {
            uint64_t v7 = "";
          }
          *(void *)&void v16[4] = v7;
          *(_WORD *)&v16[12] = 2048;
          *(void *)&v16[14] = v8;
          __int16 v17 = 2048;
          uint64_t v18 = 0x40565A1CAC083127;
          _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Device is %sin high speed non-emergency environment environment, current speed: %f, threshold speed: %f", v16, 0x20u);
        }
        (*(void (**)(void, void))(**(void **)(a1 + 424) + 24))(*(void *)(a1 + 424), 0);
      }
      if ((v5 & 1) == 0)
      {
        if (!*(void *)(a1 + 176))
        {
          int v9 = *(NSObject **)(a1 + 40);
          if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v10 = *(void *)*a2;
            uint64_t v11 = *((void *)*a2 + 5);
            *(_DWORD *)CFDateRef v16 = 134218240;
            *(void *)&void v16[4] = v10;
            *(_WORD *)&v16[12] = 2048;
            *(void *)&v16[14] = v11;
            _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I Got acceptable location data for regulatory, location timestamp: %lld, horizontal accuracy: %f", v16, 0x16u);
          }
        }
        int v13 = *a2;
        long long v12 = a2[1];
        if (v12) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)v12 + 1, 1uLL, memory_order_relaxed);
        }
        char v14 = *(std::__shared_weak_count **)(a1 + 184);
        *(void *)(a1 + 176) = v13;
        *(void *)(a1 + 184) = v12;
        if (v14) {
          sub_10004D2C8(v14);
        }
        Registry::getTimerService((uint64_t *)v16, *(Registry **)(a1 + 360));
        *(void *)(a1 + 216) = (***(uint64_t (****)(void))v16)(*(void *)v16);
        if (*(void *)&v16[8]) {
          sub_10004D2C8(*(std::__shared_weak_count **)&v16[8]);
        }
        sub_1005C4E30(a1);
      }
    }
    else
    {
      long long v15 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)CFDateRef v16 = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "Location data is nil", v16, 2u);
      }
    }
  }
}

void sub_1005C4E10(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_1005C4E30(uint64_t a1)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 24));
  if (*(void *)(a1 + 160)) {
    int v2 = *(void *)(a1 + 176) != 0;
  }
  else {
    int v2 = 0;
  }
  if (*(unsigned __int8 *)(a1 + 144) != v2)
  {
    uint64_t v3 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v4 = "not ";
      if (v2) {
        uint64_t v4 = "";
      }
      int v5 = 136315138;
      long long v6 = v4;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I GPS data is now %savailable", (uint8_t *)&v5, 0xCu);
    }
    *(unsigned char *)(a1 + 144) = v2;
    sub_1005C5910(a1);
    (*(void (**)(void, void))(**(void **)(a1 + 424) + 24))(*(void *)(a1 + 424), 0);
  }
}

uint64_t sub_1005C4F54(uint64_t a1)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 24));
  int v2 = *(uint64_t (**)(void))(**(void **)(a1 + 432) + 8);

  return v2();
}

uint64_t sub_1005C4FB8(uint64_t a1, uint64_t *a2)
{
  uint64_t v5 = *a2;
  uint64_t v4 = a2[1];
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  long long v6 = *(std::__shared_weak_count **)(a1 + 80);
  *(void *)(a1 + 72) = v5;
  *(void *)(a1 + 80) = v4;
  if (v6) {
    sub_10004D2C8(v6);
  }
  uint64_t v7 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    unsigned int v8 = (*(uint64_t (**)(void))(**(void **)(a1 + 424) + 16))(*(void *)(a1 + 424));
    if (v8 > 6) {
      int v9 = "???";
    }
    else {
      int v9 = off_1019EC928[v8];
    }
    uint64_t v10 = *a2;
    if (*a2) {
      uint64_t v10 = *(void *)(v10 + 16);
    }
    int v12 = 136315394;
    int v13 = v9;
    __int16 v14 = 2048;
    uint64_t v15 = v10;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I %s Number of active SIMs = %zu", (uint8_t *)&v12, 0x16u);
  }
  return (*(uint64_t (**)(void, void))(**(void **)(a1 + 424) + 24))(*(void *)(a1 + 424), 0);
}

void sub_1005C5110(uint64_t a1, uint64_t a2)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 24));
  if (*(unsigned char *)(a1 + 64))
  {
    uint64_t v4 = *(void *)(a1 + 320);
    v5[0] = off_1019EBD08;
    v5[1] = a1;
    v5[3] = v5;
    (*(void (**)(uint64_t, uint64_t, void *))(*(void *)v4 + 104))(v4, a2, v5);
    sub_100060644(v5);
  }
}

void sub_1005C51D4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100060644((uint64_t *)va);
  _Unwind_Resume(a1);
}

void sub_1005C51E8(uint64_t a1, unsigned int a2)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 24));
  if (*(_DWORD *)(a1 + 640) != a2)
  {
    *(_DWORD *)(a1 + 640) = a2;
    uint64_t v4 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      if (a2 > 5) {
        uint64_t v5 = "???";
      }
      else {
        uint64_t v5 = off_1019EC818[a2];
      }
      int v6 = 136315138;
      uint64_t v7 = v5;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Max congestion allowed for registration: %s", (uint8_t *)&v6, 0xCu);
    }
    (*(void (**)(void, void))(**(void **)(a1 + 424) + 24))(*(void *)(a1 + 424), 0);
  }
}

uint64_t sub_1005C52F4(uint64_t a1, uint64_t a2)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 24));
  char v4 = *(unsigned char *)(a2 + 4);
  *(void *)long long buf = a2;
  *((unsigned char *)sub_10005CE78((uint64_t **)(a1 + 88), (int *)a2, (uint64_t)&unk_10144E20E, (_DWORD **)buf) + 32) = v4;
  uint64_t v5 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    unsigned int v6 = (*(uint64_t (**)(void))(**(void **)(a1 + 424) + 16))(*(void *)(a1 + 424));
    if (v6 > 6) {
      uint64_t v7 = "???";
    }
    else {
      uint64_t v7 = off_1019EC928[v6];
    }
    if (*(unsigned char *)(a2 + 4)) {
      unsigned int v8 = "succeeded";
    }
    else {
      unsigned int v8 = "failed";
    }
    uint64_t v9 = subscriber::asString();
    *(_DWORD *)long long buf = 136315650;
    *(void *)&uint8_t buf[4] = v7;
    __int16 v12 = 2080;
    int v13 = v8;
    __int16 v14 = 2080;
    uint64_t v15 = v9;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I %s Scan %s for slot: %s", buf, 0x20u);
  }
  return (*(uint64_t (**)(void, void))(**(void **)(a1 + 424) + 24))(*(void *)(a1 + 424), 0);
}

void sub_1005C5480(uint64_t a1, uint64_t a2, unsigned int a3, int a4)
{
  unsigned int v8 = (id *)(a1 + 24);
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 24));
  if (a3)
  {
    int v9 = *(unsigned __int16 *)(a1 + 646);
    if ((a3 & ~v9) != 0)
    {
      uint64_t v10 = v9 | a3;
      *(_WORD *)(a1 + 646) = v10;
      if (*(unsigned char *)(a1 + 64))
      {
        uint64_t v11 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
        {
          sub_100BC897C(v10, &__p);
          if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            p_p = &__p;
          }
          else {
            p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
          }
          LODWORD(v32) = 136446210;
          *(void *)((char *)&v32 + 4) = p_p;
          _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I Updated list of services that need transport to: %{public}s", (uint8_t *)&v32, 0xCu);
          if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(__p.__r_.__value_.__l.__data_);
          }
        }
      }
      else
      {
        *(unsigned char *)(a1 + 64) = 1;
        if ((a2 & 0xFF00000000) == 0) {
          LODWORD(a2) = 0;
        }
        *(_DWORD *)(a1 + 112) = a2;
        *(_DWORD *)(a1 + 116) = a4;
        *(_DWORD *)(a1 + 120) = 0;
        int v13 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
        {
          sub_100BC897C(v10, &__p);
          if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            __int16 v14 = &__p;
          }
          else {
            __int16 v14 = (std::string *)__p.__r_.__value_.__r.__words[0];
          }
          LODWORD(v32) = 136446210;
          *(void *)((char *)&v32 + 4) = v14;
          _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I Received request to enable transport for services: %{public}s", (uint8_t *)&v32, 0xCu);
          if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(__p.__r_.__value_.__l.__data_);
          }
          LODWORD(a2) = *(_DWORD *)(a1 + 112);
        }
        if (a2 == 5)
        {
          *(unsigned char *)(a1 + 520) = 1;
          uint64_t v15 = *(NSObject **)(a1 + 40);
          if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
          {
            LOWORD(__p.__r_.__value_.__l.__data_) = 0;
            _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I Start simulating connected in service info", (uint8_t *)&__p, 2u);
          }
        }
        sub_1005C5910(a1);
        dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 24));
        if (!*(void *)(a1 + 448) && *(unsigned char *)(a1 + 64))
        {
          CFDateRef v16 = *(NSObject **)(a1 + 40);
          if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
          {
            LOWORD(__p.__r_.__value_.__l.__data_) = 0;
            _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I Starting GPS data updates", (uint8_t *)&__p, 2u);
          }
          __int16 v17 = *(std::__shared_weak_count **)(a1 + 16);
          if (!v17 || (uint64_t v18 = *(void *)(a1 + 8), (v19 = std::__shared_weak_count::lock(v17)) == 0)) {
            sub_100088B9C();
          }
          unsigned int v20 = v19;
          atomic_fetch_add_explicit(&v19->__shared_weak_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v19);
          uint64_t v21 = operator new(0x20uLL);
          void *v21 = off_1019EC298;
          v21[1] = a1;
          v21[2] = v18;
          v21[3] = v20;
          uint64_t v34 = v21;
          sub_1004F31F0(v8, (uint64_t)&__p, &v32);
          uint64_t v22 = *(std::__shared_weak_count **)(a1 + 456);
          *(_OWORD *)(a1 + 448) = v32;
          if (v22) {
            sub_10004D2C8(v22);
          }
          sub_1004F33D8(&__p);
        }
        sub_1005C5AD0(a1);
        dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 24));
        if (!*(void *)(a1 + 336))
        {
          uint64_t v23 = *(std::__shared_weak_count **)(a1 + 384);
          if (v23)
          {
            uint64_t v24 = std::__shared_weak_count::lock(v23);
            if (v24)
            {
              uint64_t v25 = v24;
              uint64_t v26 = *(void *)(a1 + 376);
              if (v26)
              {
                (*(void (**)(std::string *__return_ptr))(*(void *)v26 + 128))(&__p);
                long long v27 = *(_OWORD *)&__p.__r_.__value_.__l.__data_;
                *(_OWORD *)&__p.__r_.__value_.__l.__data_ = 0uLL;
                int v28 = *(std::__shared_weak_count **)(a1 + 344);
                *(_OWORD *)(a1 + 336) = v27;
                if (v28)
                {
                  sub_10004D2C8(v28);
                  if (__p.__r_.__value_.__l.__size_) {
                    sub_10004D2C8((std::__shared_weak_count *)__p.__r_.__value_.__l.__size_);
                  }
                  uint64_t v29 = *(void *)(a1 + 336);
                }
                else
                {
                  uint64_t v29 = v27;
                }
                if (v29)
                {
                  int v30 = *(std::__shared_weak_count **)(a1 + 344);
                  if (v30)
                  {
                    atomic_fetch_add_explicit(&v30->__shared_weak_owners_, 1uLL, memory_order_relaxed);
                    atomic_fetch_add_explicit(&v30->__shared_weak_owners_, 1uLL, memory_order_relaxed);
                  }
                  BOOL v31 = operator new(0x20uLL);
                  *BOOL v31 = off_1019EC7A8;
                  v31[1] = a1;
                  v31[2] = v29;
                  v31[3] = v30;
                  uint64_t v34 = v31;
                  ctu::rest::AssertionHandle::setHandler_impl();
                  sub_100060644(&__p);
                  if (v30) {
                    std::__shared_weak_count::__release_weak(v30);
                  }
                }
                else
                {
                  sub_1005C8848(a1);
                }
              }
              sub_10004D2C8(v25);
            }
          }
        }
        (*(void (**)(void, void))(**(void **)(a1 + 424) + 24))(*(void *)(a1 + 424), 0);
      }
    }
  }
}

void sub_1005C58A0(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_1005C5910(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 64))
  {
    if (*(unsigned char *)(a1 + 144)) {
      uint64_t v2 = 2;
    }
    else {
      uint64_t v2 = 1;
    }
  }
  else
  {
    uint64_t v2 = 0;
  }
  if (*(_DWORD *)(a1 + 148) != v2)
  {
    *(_DWORD *)(a1 + 148) = v2;
    uint64_t v3 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      char v4 = off_1019EC8E0[v2];
      uint64_t v5 = "true";
      if (!*(unsigned char *)(a1 + 644)) {
        uint64_t v5 = "false";
      }
      int v11 = 136315394;
      __int16 v12 = v4;
      __int16 v13 = 2080;
      __int16 v14 = v5;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I GPS data acquisition status: %s, report: %s", (uint8_t *)&v11, 0x16u);
    }
    unsigned int v6 = *(std::__shared_weak_count **)(a1 + 384);
    if (v6)
    {
      uint64_t v7 = std::__shared_weak_count::lock(v6);
      if (v7)
      {
        unsigned int v8 = v7;
        uint64_t v9 = *(void *)(a1 + 376);
        if (v9)
        {
          (*(void (**)(uint64_t, uint64_t, void))(*(void *)v9 + 96))(v9, v2, *(unsigned __int8 *)(a1 + 644));
          if (*(unsigned char *)(a1 + 644))
          {
            if (*(_DWORD *)(a1 + 148) == 2)
            {
              uint64_t v10 = *(NSObject **)(a1 + 40);
              if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
              {
                LOWORD(v11) = 0;
                _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I Stop reporting acquistion status", (uint8_t *)&v11, 2u);
              }
              *(unsigned char *)(a1 + 644) = 0;
            }
          }
        }
        sub_10004D2C8(v8);
      }
    }
  }
}

void sub_1005C5ABC(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_1005C5AD0(uint64_t a1)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 24));
  if (*(unsigned char *)(a1 + 66))
  {
    uint64_t v2 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v3 = 0;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Resetting failures", v3, 2u);
    }
    *(unsigned char *)(a1 + 66) = 0;
    (*(void (**)(void))(**(void **)(a1 + 432) + 24))(*(void *)(a1 + 432));
  }
}

uint64_t sub_1005C5B70(uint64_t a1)
{
  return 1;
}

uint64_t sub_1005C5B90(uint64_t a1)
{
  return 1;
}

void sub_1005C5BB0(uint64_t a1, const void **a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 24));
  if (((*(uint64_t (**)(void))(**(void **)(a1 + 424) + 64))(*(void *)(a1 + 424)) & 1) == 0)
  {
    uint64_t v15 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
    {
      unsigned int v16 = (*(uint64_t (**)(void))(**(void **)(a1 + 424) + 16))(*(void *)(a1 + 424));
      if (v16 > 6) {
        __int16 v17 = "???";
      }
      else {
        __int16 v17 = off_1019EC928[v16];
      }
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = v17;
      _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "%s Send is not allowed", buf, 0xCu);
    }
    *(void *)long long buf = a1;
    sub_10012A394((const void **)&buf[8], a2);
    sub_1005C5E28(a1 + 8);
  }
  uint64_t v9 = *(void *)(a1 + 320);
  *(void *)&long long v18 = a1;
  uint64_t v10 = *(std::__shared_weak_count **)(a1 + 16);
  if (!v10 || (uint64_t v11 = *(void *)(a1 + 8), (v12 = std::__shared_weak_count::lock(v10)) == 0)) {
    sub_100088B9C();
  }
  *((void *)&v18 + 1) = v11;
  uint64_t v19 = v12;
  atomic_fetch_add_explicit(&v12->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v12);
  sub_10012A394(&v20, a2);
  uint64_t v22 = 0;
  __int16 v13 = (char *)operator new(0x28uLL);
  *(void *)__int16 v13 = off_1019EBD88;
  *(_OWORD *)(v13 + 8) = v18;
  __int16 v14 = v20;
  *((void *)v13 + 3) = v19;
  *((void *)v13 + 4) = v14;
  unsigned int v20 = 0;
  uint64_t v22 = v13;
  (*(void (**)(uint64_t, const void **, uint64_t, uint64_t, unsigned char *))(*(void *)v9 + 112))(v9, a2, a4, a5, buf);
  sub_100060644(buf);
  sub_10012577C(&v20);
}

void sub_1005C5E04(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13)
{
}

void sub_1005C5E28(uint64_t a1)
{
  BOOL v1 = *(std::__shared_weak_count **)(a1 + 8);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_1005C5F1C(uint64_t a1, CFUUIDRef *a2)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 24));
  if (*(unsigned char *)(a1 + 64))
  {
    char v4 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      sub_100BC8FAC(a2, __p);
      uint64_t v5 = v22 >= 0 ? __p : (void **)__p[0];
      *(_DWORD *)long long buf = 136446210;
      uint64_t v24 = v5;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Queuing cancel for messageID: %{public}s", buf, 0xCu);
      if (v22 < 0) {
        operator delete(__p[0]);
      }
    }
    unsigned int v6 = *(const void ***)(a1 + 656);
    unint64_t v7 = *(void *)(a1 + 664);
    if ((unint64_t)v6 >= v7)
    {
      uint64_t v9 = *(void *)(a1 + 648);
      uint64_t v10 = ((uint64_t)v6 - v9) >> 3;
      if ((unint64_t)(v10 + 1) >> 61) {
        sub_10006A748();
      }
      uint64_t v11 = v7 - v9;
      uint64_t v12 = v11 >> 2;
      if (v11 >> 2 <= (unint64_t)(v10 + 1)) {
        uint64_t v12 = v10 + 1;
      }
      if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v13 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v13 = v12;
      }
      if (v13)
      {
        if (v13 >> 61) {
          sub_10006A7CC();
        }
        __int16 v14 = (const void **)operator new(8 * v13);
      }
      else
      {
        __int16 v14 = 0;
      }
      uint64_t v15 = &v14[v13];
      unsigned int v16 = sub_10012A394(&v14[v10], (const void **)a2);
      unsigned int v8 = v16 + 1;
      __int16 v17 = *(const void ***)(a1 + 656);
      long long v18 = *(const void ***)(a1 + 648);
      if (v17 == v18)
      {
        *(void *)(a1 + 648) = v16;
        *(void *)(a1 + 656) = v8;
        *(void *)(a1 + 664) = v15;
      }
      else
      {
        do
        {
          *--unsigned int v16 = 0;
          uint64_t v19 = *--v17;
          *unsigned int v16 = v19;
          *__int16 v17 = 0;
        }
        while (v17 != v18);
        __int16 v17 = *(const void ***)(a1 + 648);
        unsigned int v20 = *(const void ***)(a1 + 656);
        *(void *)(a1 + 648) = v16;
        *(void *)(a1 + 656) = v8;
        *(void *)(a1 + 664) = v15;
        while (v20 != v17)
          sub_10012577C(--v20);
      }
      if (v17) {
        operator delete(v17);
      }
    }
    else
    {
      unsigned int v8 = sub_10012A394(v6, (const void **)a2) + 1;
    }
    *(void *)(a1 + 656) = v8;
    (*(void (**)(void, void))(**(void **)(a1 + 424) + 24))(*(void *)(a1 + 424), 0);
  }
}

void sub_1005C6148(uint64_t a1, uint64_t a2)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 24));
  if (*(void *)(a1 + 152) != a2)
  {
    *(void *)(a1 + 152) = a2;
    char v4 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      int v5 = 134217984;
      uint64_t v6 = a2;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Updated test GPS time adjustment to: %llu ns", (uint8_t *)&v5, 0xCu);
    }
  }
}

void sub_1005C6200(uint64_t a1)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 24));
  if (*(void *)(a1 + 648) != *(void *)(a1 + 656)
    && (*(unsigned int (**)(void))(**(void **)(a1 + 424) + 64))(*(void *)(a1 + 424)))
  {
    uint64_t v2 = *(CFUUIDRef **)(a1 + 648);
    uint64_t v3 = *(CFUUIDRef **)(a1 + 656);
    if (v2 != v3)
    {
      do
      {
        char v4 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
        {
          sub_100BC8FAC(v2, __p);
          int v5 = v9 >= 0 ? __p : (void **)__p[0];
          *(_DWORD *)long long buf = 136446210;
          uint64_t v12 = v5;
          _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Sending cancel for messageID: %{public}s", buf, 0xCu);
          if (v9 < 0) {
            operator delete(__p[0]);
          }
        }
        uint64_t v6 = *(void *)(a1 + 320);
        __p[0] = off_1019EBE08;
        uint64_t v10 = __p;
        (*(void (**)(uint64_t, CFUUIDRef *, void **))(*(void *)v6 + 120))(v6, v2, __p);
        sub_100060644(__p);
        ++v2;
      }
      while (v2 != v3);
      uint64_t v2 = *(CFUUIDRef **)(a1 + 656);
      unint64_t v7 = *(CFUUIDRef **)(a1 + 648);
      if (v2 != v7)
      {
        do
          sub_10012577C((const void **)--v2);
        while (v2 != v7);
        uint64_t v2 = v7;
      }
    }
    *(void *)(a1 + 656) = v2;
  }
}

void sub_1005C63D8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
}

void sub_1005C63F4(uint64_t a1, char **a2)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 24));
  if (a2[1] - *a2 != 2)
  {
    unsigned int v8 = *(NSObject **)(a1 + 40);
    if (!os_log_type_enabled(v8, OS_LOG_TYPE_ERROR)) {
      return;
    }
    *(_WORD *)__int16 v14 = 0;
    char v9 = "Invalid context provided. Cannot ack for this context";
    uint64_t v10 = v8;
    uint32_t v11 = 2;
    goto LABEL_9;
  }
  uint64_t v4 = *(unsigned __int16 *)*a2;
  char v5 = (*(uint64_t (**)(void))(**(void **)(a1 + 424) + 72))(*(void *)(a1 + 424));
  uint64_t v6 = *(NSObject **)(a1 + 40);
  if ((v5 & 1) == 0)
  {
    if (!os_log_type_enabled(*(os_log_t *)(a1 + 40), OS_LOG_TYPE_ERROR)) {
      return;
    }
    unsigned int v12 = (*(uint64_t (**)(void))(**(void **)(a1 + 424) + 16))(*(void *)(a1 + 424));
    if (v12 > 6) {
      unint64_t v13 = "???";
    }
    else {
      unint64_t v13 = off_1019EC928[v12];
    }
    *(_DWORD *)__int16 v14 = 136315394;
    *(void *)&v14[4] = v13;
    __int16 v15 = 1024;
    int v16 = v4;
    char v9 = "%s Ack is not allowed. Failed to ack for BB messageId: %hu";
    uint64_t v10 = v6;
    uint32_t v11 = 18;
LABEL_9:
    _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, v9, v14, v11);
    return;
  }
  if (os_log_type_enabled(*(os_log_t *)(a1 + 40), OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__int16 v14 = 67109120;
    *(_DWORD *)&v14[4] = v4;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Sending ack for BB messageId: %hu", v14, 8u);
  }
  uint64_t v7 = *(void *)(a1 + 320);
  *(void *)__int16 v14 = off_1019EBE88;
  __int16 v17 = v14;
  (*(void (**)(uint64_t, uint64_t, unsigned char *))(*(void *)v7 + 128))(v7, v4, v14);
  sub_100060644(v14);
}

void sub_1005C661C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1005C6630(uint64_t a1, int a2)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 24));
  if (*(unsigned __int8 *)(a1 + 65) != a2)
  {
    uint64_t v4 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      char v5 = "not ";
      if (a2) {
        char v5 = "";
      }
      LODWORD(v12) = 136315138;
      *(void *)((char *)&v12 + 4) = v5;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Driver is %sready", (uint8_t *)&v12, 0xCu);
    }
    *(unsigned char *)(a1 + 65) = a2;
    if (a2)
    {
      if (*(unsigned char *)(a1 + 440)) {
        sub_1005C42F0(a1);
      }
      if (sub_1005C6840(a1 + 392, 0) == 2)
      {
        uint64_t v6 = *(std::__shared_weak_count **)(a1 + 16);
        if (!v6
          || (uint64_t v7 = *(void *)(a1 + 320), v8 = *(void *)(a1 + 8), (v9 = std::__shared_weak_count::lock(v6)) == 0))
        {
          sub_100088B9C();
        }
        uint64_t v10 = v9;
        atomic_fetch_add_explicit(&v9->__shared_weak_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v9);
        *(void *)&long long v12 = off_1019EBF08;
        *((void *)&v12 + 1) = v8;
        unint64_t v13 = v10;
        __int16 v14 = &v12;
        (*(void (**)(uint64_t, long long *))(*(void *)v7 + 24))(v7, &v12);
        sub_1005CCDB4(&v12);
      }
      (*(void (**)(void, void))(**(void **)(a1 + 424) + 24))(*(void *)(a1 + 424), 0);
    }
    else
    {
      uint32_t v11 = *(std::__shared_weak_count **)(a1 + 472);
      *(void *)(a1 + 464) = 0;
      *(void *)(a1 + 472) = 0;
      if (v11) {
        sub_10004D2C8(v11);
      }
      (*(void (**)(void))(**(void **)(a1 + 424) + 48))(*(void *)(a1 + 424));
    }
  }
}

void sub_1005C6824(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_1005C6840(uint64_t a1, char a2)
{
  if (*(unsigned char *)(a1 + 24) && (a2 & 1) == 0) {
    return *(unsigned int *)(a1 + 20);
  }
  *(unsigned char *)(a1 + 24) = 1;
  uint64_t v8 = 0;
  (*(void (**)(const void **__return_ptr))(**(void **)(*(void *)(a1 + 8) + 8) + 8))(&v7);
  sub_1000842D0(&v8, &v7);
  sub_1000577C4(&v7);
  if (v8) {
    char v5 = sub_100081E58;
  }
  else {
    char v5 = 0;
  }
  if (v5)
  {
    LODWORD(v7) = 0;
    ctu::cf::assign((ctu::cf *)&v7, v8, v4);
    uint64_t v3 = v7;
  }
  else
  {
    uint64_t v3 = *(unsigned int *)(a1 + 16);
  }
  *(_DWORD *)(a1 + 20) = v3;
  sub_1000570E8((const void **)&v8);
  return v3;
}

void sub_1005C6914(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000570E8((const void **)va);
  _Unwind_Resume(a1);
}

void sub_1005C6938(uint64_t a1, int a2)
{
}

void sub_1005C6940(uint64_t a1)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 24));
  if (*(unsigned char *)(a1 + 64))
  {
    if (*(unsigned char *)(a1 + 67))
    {
      uint64_t v2 = *(void *)(a1 + 320);
      v3[0] = off_1019EBF98;
      double v3[3] = v3;
      (*(void (**)(uint64_t, void *))(*(void *)v2 + 88))(v2, v3);
      sub_100060644(v3);
    }
  }
}

void sub_1005C6A04(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100060644((uint64_t *)va);
  _Unwind_Resume(a1);
}

void sub_1005C6A18(uint64_t a1)
{
}

void sub_1005C6A20(uint64_t a1, long long *a2)
{
  uint64_t v4 = a1 + 24;
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 24));
  if (*(unsigned char *)(v4 + 40))
  {
    if (!*((unsigned char *)a2 + 20) && *(unsigned char *)(a1 + 312))
    {
      int v5 = *(_DWORD *)(a1 + 300);
      *((unsigned char *)a2 + 20) = *(unsigned char *)(a1 + 304);
      *((_DWORD *)a2 + 4) = v5;
    }
    dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 24));
    if (*(unsigned char *)(a1 + 520))
    {
      *((unsigned char *)a2 + 26) = 1;
      *((_DWORD *)a2 + 4) = 1;
      *((unsigned char *)a2 + 20) = 1;
      if (*((unsigned char *)a2 + 12)) {
        *((unsigned char *)a2 + 12) = 0;
      }
      uint64_t v6 = (AutoStartTimer **)(a1 + 504);
      if (*(_DWORD *)a2 == 2)
      {
        if (*v6)
        {
          if (AutoStartTimer::isExpired(*v6))
          {
            *(void *)a2 = 0x200000003;
            goto LABEL_22;
          }
        }
        else
        {
          sub_100058DB0(&__p, "SimulateStewieConnected");
          dispatch_assert_queue_V2(*(dispatch_queue_t *)v4);
          Registry::getTimerService(&v19, *(Registry **)(a1 + 360));
          *(void *)long long buf = off_1019EC018;
          uint64_t v25 = a1;
          uint64_t v26 = buf;
          AutoStartTimer::create();
          long long v8 = v23;
          long long v23 = 0uLL;
          char v9 = *(std::__shared_weak_count **)(a1 + 512);
          *(_OWORD *)uint64_t v6 = v8;
          if (v9)
          {
            sub_10004D2C8(v9);
            if (*((void *)&v23 + 1)) {
              sub_10004D2C8(*((std::__shared_weak_count **)&v23 + 1));
            }
          }
          sub_10003B34C(buf);
          if (v20) {
            sub_10004D2C8(v20);
          }
          if (v22 < 0) {
            operator delete(__p);
          }
        }
      }
      else
      {
        uint64_t v7 = *(std::__shared_weak_count **)(a1 + 512);
        std::__shared_weak_count *v6 = 0;
        *(void *)(a1 + 512) = 0;
        if (v7) {
          sub_10004D2C8(v7);
        }
      }
    }
    if (*(_DWORD *)a2 != 3)
    {
      int v11 = 0;
LABEL_25:
      sub_1005C6DB0(a1, *(_DWORD *)(a1 + 480), v11);
      long long v12 = (_OWORD *)(a1 + 284);
      long long v13 = *a2;
      if (*(unsigned char *)(a1 + 312))
      {
        *(_OWORD *)(a1 + 295) = *(long long *)((char *)a2 + 11);
        *long long v12 = v13;
      }
      else
      {
        *(_OWORD *)(a1 + 296) = *(long long *)((char *)a2 + 12);
        *long long v12 = v13;
        *(unsigned char *)(a1 + 312) = 1;
      }
      (*(void (**)(void, void))(**(void **)(a1 + 424) + 24))(*(void *)(a1 + 424), 0);
      __int16 v14 = *(std::__shared_weak_count **)(a1 + 384);
      if (v14)
      {
        __int16 v15 = std::__shared_weak_count::lock(v14);
        if (v15)
        {
          int v16 = v15;
          uint64_t v17 = *(void *)(a1 + 376);
          if (v17) {
            (*(void (**)(uint64_t, long long *))(*(void *)v17 + 72))(v17, a2);
          }
          sub_10004D2C8(v16);
        }
      }
      return;
    }
LABEL_22:
    uint64_t v10 = *(void (****)(void, uint64_t))(a1 + 128);
    int v11 = 1;
    if (v10) {
      (**v10)(v10, 1);
    }
    goto LABEL_25;
  }
  long long v18 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "Transport is not requested", buf, 2u);
  }
}

void sub_1005C6D60(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20)
{
  if (a11) {
    sub_10004D2C8(a11);
  }
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_1005C6DB0(uint64_t a1, int a2, int a3)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 24));
  if (!*(unsigned char *)(a1 + 66))
  {
    int v6 = *(_DWORD *)(a1 + 480);
    if (v6 == a2)
    {
      if (*(unsigned __int8 *)(a1 + 484) == a3) {
        return;
      }
    }
    else if (v6 == 2)
    {
      sub_1004B3878(a1);
    }
    *(_DWORD *)(a1 + 480) = a2;
    *(unsigned char *)(a1 + 484) = a3;
    uint64_t v7 = *(std::__shared_weak_count **)(a1 + 16);
    if (v7)
    {
      if (std::__shared_weak_count::lock(v7)) {
        operator new();
      }
    }
    sub_100088B9C();
  }
}

void sub_1005C6EEC(uint64_t a1, long long *a2)
{
}

void sub_1005C6EF4(uint64_t a1, uint64_t a2)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 24));
  if (*(unsigned char *)(a1 + 64))
  {
    uint64_t v4 = *(std::__shared_weak_count **)(a1 + 384);
    if (v4)
    {
      int v5 = std::__shared_weak_count::lock(v4);
      if (v5)
      {
        int v6 = v5;
        uint64_t v7 = *(void *)(a1 + 376);
        if (v7) {
          (*(void (**)(uint64_t, uint64_t))(*(void *)v7 + 80))(v7, a2);
        }
        sub_10004D2C8(v6);
      }
    }
  }
  else
  {
    long long v8 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)char v9 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "Transport is not requested", v9, 2u);
    }
  }
}

void sub_1005C6FE4(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_1005C6FF8(uint64_t a1, uint64_t a2)
{
}

void sub_1005C7000(uint64_t a1)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 24));
  v1[0] = 0;
  v1[1] = 0;
  *(void *)long long buf = 0;
  long long v3 = 0uLL;
  sub_100076564(v1);
}

void sub_1005C7254(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13, const void *a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18)
{
  sub_100060644(&a17);
  if (__p) {
    operator delete(__p);
  }
  sub_100030068(&a14);
  uint64_t v19 = a16;
  a16 = 0;
  if (v19) {
    (*(void (**)(uint64_t))(*(void *)v19 + 32))(v19);
  }
  _Unwind_Resume(a1);
}

void sub_1005C72E4(uint64_t a1)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 24));
  v1[0] = 0;
  v1[1] = 0;
  *(void *)long long buf = 0;
  uint64_t v3 = 0;
  uint64_t v4 = 0;
  sub_100076564(v1);
}

void sub_1005C74C0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
  if (a10) {
    (*(void (**)(uint64_t))(*(void *)a10 + 32))(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_1005C7518(uint64_t a1)
{
}

void sub_1005C7520(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 24));
  sub_1005C3A20(a1, a5);
  (*(void (**)(void))(**(void **)(a1 + 424) + 40))(*(void *)(a1 + 424));
  if (*(unsigned char *)(a3 + 1))
  {
    if (*(unsigned char *)(a4 + 24))
    {
      sub_1005C7610(a1, a4);
    }
    else
    {
      char v9 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t v10 = 0;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I EPKI that was used was not provided", v10, 2u);
      }
    }
  }
}

void sub_1005C7610(uint64_t a1, uint64_t a2)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 24));
  uint64_t v4 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)char v9 = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Invalidating used key", v9, 2u);
  }
  int v5 = *(std::__shared_weak_count **)(a1 + 384);
  if (v5)
  {
    int v6 = std::__shared_weak_count::lock(v5);
    if (v6)
    {
      uint64_t v7 = v6;
      uint64_t v8 = *(void *)(a1 + 376);
      if (v8) {
        (*(void (**)(uint64_t, uint64_t))(*(void *)v8 + 176))(v8, a2);
      }
      sub_10004D2C8(v7);
    }
  }
}

void sub_1005C76D4(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_1005C76E8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5)
{
}

void sub_1005C76F0(uint64_t a1, uint64_t a2)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 24));
  uint64_t v4 = *(NSObject **)(a1 + 40);
  if (*(unsigned char *)(a1 + 64))
  {
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      int v9 = 136315138;
      uint64_t v10 = sub_100BC8B90(a2);
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I BB requested deactivation. Reason: %s", (uint8_t *)&v9, 0xCu);
    }
    int v5 = *(std::__shared_weak_count **)(a1 + 384);
    if (v5)
    {
      int v6 = std::__shared_weak_count::lock(v5);
      if (v6)
      {
        uint64_t v7 = v6;
        uint64_t v8 = *(void *)(a1 + 376);
        if (v8) {
          (*(void (**)(uint64_t, uint64_t))(*(void *)v8 + 64))(v8, a2);
        }
        sub_10004D2C8(v7);
      }
    }
  }
  else if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
  {
    LOWORD(v9) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "Transport is not requested", (uint8_t *)&v9, 2u);
  }
}

void sub_1005C7834(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_1005C7848(uint64_t a1, uint64_t a2)
{
}

void sub_1005C7850(uint64_t a1, int a2)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 24));
  if (a2 != 2)
  {
LABEL_6:
    *(_DWORD *)(a1 + 124) = a2;
    int v5 = *(void (**)(void))(**(void **)(a1 + 424) + 32);
    v5();
    return;
  }
  if (*(unsigned char *)(a1 + 282))
  {
    if (*(unsigned char *)(a1 + 520))
    {
      uint64_t v4 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)uint64_t v7 = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "Reject suspension request for cell scan as we are simulating service info", v7, 2u);
      }
      return;
    }
    goto LABEL_6;
  }
  int v6 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Ignore BB request for cell scan", buf, 2u);
  }
}

void sub_1005C7960(uint64_t a1, int a2)
{
}

void sub_1005C7968(uint64_t a1)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 24));
  uint64_t v2 = *(NSObject **)(a1 + 40);
  if (*(unsigned char *)(a1 + 64))
  {
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v3[0]) = 0;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I BB requested security config update", (uint8_t *)v3, 2u);
    }
    v3[0] = off_1019EC118;
    v3[1] = a1;
    double v3[3] = v3;
    sub_1005C7A8C(a1, (uint64_t)v3);
    sub_100388CB8(v3);
  }
  else if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
  {
    LOWORD(v3[0]) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_ERROR, "Transport is not requested", (uint8_t *)v3, 2u);
  }
}

void sub_1005C7A78(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1005C7A8C(uint64_t a1, uint64_t a2)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 24));
  uint64_t v4 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I Fetching security credentials", buf, 2u);
  }
  int v5 = *(std::__shared_weak_count **)(a1 + 384);
  if (!v5 || (v6 = std::__shared_weak_count::lock(v5)) == 0 || (uint64_t v7 = *(void *)(a1 + 376)) == 0)
  {
    long long v13 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "No delegate to get credentials", buf, 2u);
    }
    sub_1005CED70((uint64_t)buf, a2);
    __int16 v14 = *(std::__shared_weak_count **)(a1 + 16);
    if (v14 && std::__shared_weak_count::lock(v14)) {
      operator new();
    }
    sub_100088B9C();
  }
  uint64_t v8 = *(std::__shared_weak_count **)(a1 + 16);
  if (!v8 || (v9 = *(std::__shared_weak_count **)(a1 + 8), (uint64_t v10 = std::__shared_weak_count::lock(v8)) == 0)) {
    sub_100088B9C();
  }
  int v11 = v10;
  atomic_fetch_add_explicit(&v10->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v10);
  v15[0] = v9;
  v15[1] = v11;
  sub_1005CED70((uint64_t)v16, a2);
  long long v18 = 0;
  long long v12 = (char *)operator new(0x38uLL);
  *(void *)long long v12 = off_1019EC448;
  *(_OWORD *)(v12 + 8) = *(_OWORD *)v15;
  sub_1005CED70((uint64_t)(v12 + 24), (uint64_t)v16);
  long long v18 = v12;
  (*(void (**)(uint64_t, uint8_t *))(*(void *)v7 + 144))(v7, buf);
  sub_100388CB8(buf);
  sub_100388CB8(v16);
  sub_10004D2C8(v6);
}

void sub_1005C7D40(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va1, a3);
  va_start(va, a3);
  uint64_t v5 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v11 = va_arg(va1, void);
  sub_100388CB8((uint64_t *)va1);
  sub_1005C8EB0((uint64_t)va);
  sub_10004D2C8(v3);
  _Unwind_Resume(a1);
}

void sub_1005C7D8C(uint64_t a1)
{
}

void sub_1005C7D94(uint64_t a1, char a2, uint64_t a3, uint64_t a4)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 24));
  if (a2)
  {
    sub_1005C7610(a1, a3);
    if (*(unsigned char *)(a4 + 24))
    {
      if (*(unsigned char *)(a1 + 64))
      {
        uint64_t v8 = *(std::__shared_weak_count **)(a1 + 384);
        if (v8)
        {
          uint64_t v9 = std::__shared_weak_count::lock(v8);
          if (v9)
          {
            uint64_t v10 = v9;
            uint64_t v11 = *(void *)(a1 + 376);
            if (v11)
            {
              if (!*(unsigned char *)(a4 + 24)) {
                sub_10016C840();
              }
              (*(void (**)(uint64_t, uint64_t))(*(void *)v11 + 88))(v11, a4);
            }
            sub_10004D2C8(v10);
          }
        }
        return;
      }
      long long v13 = *(NSObject **)(a1 + 40);
      if (!os_log_type_enabled(v13, OS_LOG_TYPE_ERROR)) {
        return;
      }
      __int16 v16 = 0;
      __int16 v14 = "Transport is not requested";
      __int16 v15 = (uint8_t *)&v16;
    }
    else
    {
      long long v13 = *(NSObject **)(a1 + 40);
      if (!os_log_type_enabled(v13, OS_LOG_TYPE_ERROR)) {
        return;
      }
      *(_WORD *)uint64_t v17 = 0;
      __int16 v14 = "BB didn't provide an app key";
      __int16 v15 = v17;
    }
    _os_log_error_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, v14, v15, 2u);
    return;
  }
  long long v12 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I EPKI was not used", buf, 2u);
  }
}

void sub_1005C7F24(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_1005C7F38(uint64_t a1, char a2, uint64_t a3, uint64_t a4)
{
}

void sub_1005C7F40(uint64_t a1, uint64_t a2, uint64_t a3)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 24));
  int v6 = *(std::__shared_weak_count **)(a1 + 384);
  if (v6)
  {
    uint64_t v7 = std::__shared_weak_count::lock(v6);
    if (v7)
    {
      uint64_t v8 = v7;
      uint64_t v9 = *(void *)(a1 + 376);
      if (v9) {
        (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v9 + 16))(v9, 1, a2, a3);
      }
      sub_10004D2C8(v8);
    }
  }
}

void sub_1005C7FE8(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_1005C7FFC(uint64_t a1, uint64_t a2, uint64_t a3)
{
}

void sub_1005C8004(uint64_t a1, int a2, uint64_t a3)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 24));
  int v6 = *(NSObject **)(a1 + 40);
  if (*(unsigned char *)(a1 + 64))
  {
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(__p) = 67109120;
      HIDWORD(__p) = a2;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Received message with BB messageId: %hu", (uint8_t *)&__p, 8u);
    }
    uint64_t v7 = *(std::__shared_weak_count **)(a1 + 384);
    if (v7)
    {
      uint64_t v8 = std::__shared_weak_count::lock(v7);
      if (v8)
      {
        uint64_t v9 = v8;
        uint64_t v10 = *(void *)(a1 + 376);
        if (v10)
        {
          uint64_t v11 = operator new(2uLL);
          std::string __p = v11;
          _WORD *v11 = a2;
          long long v13 = v11 + 1;
          __int16 v14 = v11 + 1;
          (*(void (**)(uint64_t, uint64_t, uint64_t, void **))(*(void *)v10 + 24))(v10, 1, a3, &__p);
          if (__p)
          {
            long long v13 = __p;
            operator delete(__p);
          }
        }
        sub_10004D2C8(v9);
      }
    }
  }
  else if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
  {
    LOWORD(__p) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "Transport is not requested", (uint8_t *)&__p, 2u);
  }
}

void sub_1005C8174(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10)
{
  if (__p) {
    operator delete(__p);
  }
  sub_10004D2C8(v10);
  _Unwind_Resume(a1);
}

void sub_1005C81A0(uint64_t a1, int a2, uint64_t a3)
{
}

void sub_1005C81A8(uint64_t a1, unsigned int a2, int a3)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 24));
  int v6 = *(unsigned __int8 **)(a1 + 464);
  if (v6)
  {
    int v7 = *v6;
    uint64_t v8 = *(NSObject **)(a1 + 40);
    if (v7 == a2)
    {
      if (a3)
      {
        if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
        {
          if (a2 > 2) {
            uint64_t v9 = "???";
          }
          else {
            uint64_t v9 = off_1019EC910[(char)a2];
          }
          *(_DWORD *)__int16 v15 = 136315138;
          *(void *)&void v15[4] = v9;
          _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I File transfer for file type: %s succeeded", v15, 0xCu);
        }
      }
      else if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
      {
        if (a2 > 2) {
          uint64_t v11 = "???";
        }
        else {
          uint64_t v11 = off_1019EC910[(char)a2];
        }
        *(_DWORD *)__int16 v15 = 136315138;
        *(void *)&void v15[4] = v11;
        _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "File transfer for file type: %s failed", v15, 0xCu);
      }
      uint64_t v12 = *(void *)(a1 + 464);
      long long v13 = *(void **)(v12 + 8);
      *(void *)(v12 + 8) = 0;
      *(void *)__int16 v15 = v13;
      if (!v13) {
        __TUAssertTrigger();
      }
      sub_1000607A8((uint64_t)v13, a3);
      if (v13)
      {
        sub_100060644(v13);
        operator delete();
      }
    }
    else if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      if ((char)v7 > 2) {
        uint64_t v10 = "???";
      }
      else {
        uint64_t v10 = off_1019EC910[(char)v7];
      }
      if (a2 > 2) {
        __int16 v14 = "???";
      }
      else {
        __int16 v14 = off_1019EC910[(char)a2];
      }
      *(_DWORD *)__int16 v15 = 136315394;
      *(void *)&void v15[4] = v10;
      __int16 v16 = 2080;
      uint64_t v17 = v14;
      _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "Expected file type: %s, got: %s", v15, 0x16u);
    }
  }
}

void sub_1005C83E4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9)
{
}

void sub_1005C83F8(uint64_t a1, unsigned int a2, int a3)
{
}

uint64_t sub_1005C8400(uint64_t a1)
{
  uint64_t v1 = a1 + 24;
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 24));
  return v1;
}

uint64_t sub_1005C842C(uint64_t a1)
{
  uint64_t v1 = a1 - 32;
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 - 32));
  return v1;
}

uint64_t *sub_1005C8458@<X0>(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 - 32));
  uint64_t v4 = *(Registry **)(a1 + 304);

  return Registry::getTimerService(a2, v4);
}

void sub_1005C849C(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_1005C858C(uint64_t a1)
{
}

void sub_1005C8594(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_1005C8674(uint64_t a1)
{
}

void sub_1005C867C(uint64_t a1@<X0>, void *a2@<X8>)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 24));
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 384);
  if (v4)
  {
    uint64_t v5 = std::__shared_weak_count::lock(v4);
    if (v5)
    {
      uint64_t v6 = *(void *)(a1 + 376);
      if (v6)
      {
        (*(void (**)(uint64_t))(*(void *)v6 + 120))(v6);
LABEL_9:
        sub_10004D2C8(v5);
        return;
      }
    }
  }
  else
  {
    uint64_t v5 = 0;
  }
  int v7 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)uint64_t v8 = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "No delegate to create assertion", v8, 2u);
  }
  *a2 = 0;
  a2[1] = 0;
  if (v5) {
    goto LABEL_9;
  }
}

void sub_1005C8754(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_1005C8768(uint64_t a1@<X0>, void *a2@<X8>)
{
}

uint64_t sub_1005C8770(uint64_t a1, unsigned int a2)
{
  *(unsigned char *)(a1 + 24) = 1;
  *(_DWORD *)(a1 + 20) = a2;
  uint64_t v2 = *(void *)(a1 + 8);
  CFNumberRef v9 = 0;
  unint64_t valuePtr = a2;
  CFNumberRef v3 = CFNumberCreate(kCFAllocatorDefault, kCFNumberLongLongType, &valuePtr);
  if (v3)
  {
    unint64_t v4 = (unint64_t)v9;
    CFNumberRef v9 = v3;
    unint64_t valuePtr = v4;
    sub_1000570E8((const void **)&valuePtr);
  }
  CFNumberRef v5 = v9;
  CFNumberRef v8 = v9;
  CFNumberRef v9 = 0;
  sub_1000570E8((const void **)&v9);
  uint64_t v6 = (***(uint64_t (****)(void, const void *))(v2 + 8))(*(void *)(v2 + 8), v5);
  sub_1000570E8((const void **)&v8);
  return v6;
}

void sub_1005C8828(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1000570E8((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1005C8848(uint64_t result)
{
  if (!*(unsigned char *)(result + 66))
  {
    uint64_t v1 = result;
    *(unsigned char *)(result + 66) = 1;
    *(_DWORD *)(result + 480) = 0;
    *(unsigned char *)(result + 484) = 0;
    uint64_t v2 = *(NSObject **)(result + 40);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
    {
      unsigned int v4 = (*(uint64_t (**)(void))(**(void **)(v1 + 424) + 16))(*(void *)(v1 + 424));
      if (v4 > 6) {
        CFNumberRef v5 = "???";
      }
      else {
        CFNumberRef v5 = off_1019EC928[v4];
      }
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = v5;
      _os_log_error_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_ERROR, "%s Notifying delegate of failure", buf, 0xCu);
    }
    CFNumberRef v3 = *(std::__shared_weak_count **)(v1 + 16);
    if (v3)
    {
      if (std::__shared_weak_count::lock(v3)) {
        operator new();
      }
    }
    sub_100088B9C();
  }
  return result;
}

void sub_1005C8A08(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

void sub_1005C8A18(uint64_t a1)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 24));
  if (*(unsigned char *)(a1 + 144))
  {
    uint64_t v2 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v6 = 0;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Clearing cached gps data", v6, 2u);
    }
    CFNumberRef v3 = *(std::__shared_weak_count **)(a1 + 184);
    *(void *)(a1 + 176) = 0;
    *(void *)(a1 + 184) = 0;
    if (v3) {
      sub_10004D2C8(v3);
    }
    unsigned int v4 = *(std::__shared_weak_count **)(a1 + 168);
    *(void *)(a1 + 160) = 0;
    *(void *)(a1 + 168) = 0;
    if (v4) {
      sub_10004D2C8(v4);
    }
    CFNumberRef v5 = *(std::__shared_weak_count **)(a1 + 200);
    *(void *)(a1 + 192) = 0;
    *(void *)(a1 + 200) = 0;
    if (v5) {
      sub_10004D2C8(v5);
    }
    *(unsigned char *)(a1 + 144) = 0;
    sub_1005C5910(a1);
  }
}

uint64_t sub_1005C8AC8(uint64_t a1, char **a2)
{
  if (*(unsigned char *)(a1 + 24))
  {
    if ((char **)a1 != a2) {
      sub_10006E4A8((void *)a1, *a2, a2[1], a2[1] - *a2);
    }
  }
  else
  {
    *(void *)a1 = 0;
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
    sub_10005C928((void *)a1, *a2, (uint64_t)a2[1], a2[1] - *a2);
    *(unsigned char *)(a1 + 24) = 1;
  }
  return a1;
}

void sub_1005C8B38(uint64_t a1, uint64_t a2, uint64_t a3)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 24));
  uint64_t v6 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v7 = *(void *)(*(void *)a2 + 8);
    uint64_t v8 = *(void *)(*(void *)a2 + 16);
    *(_DWORD *)long long buf = 134283777;
    uint64_t v22 = v8;
    __int16 v23 = 2049;
    uint64_t v24 = v7;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Fetching provisioning data for (lat: %{private}f, long: %{private}f)", buf, 0x16u);
  }
  CFNumberRef v9 = *(std::__shared_weak_count **)(a1 + 384);
  if (!v9 || (uint64_t v10 = std::__shared_weak_count::lock(v9)) == 0 || (v11 = *(void *)(a1 + 376)) == 0)
  {
    uint64_t v17 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "No delegate to get credentials", buf, 2u);
    }
    sub_1005CE444((uint64_t)buf, a3);
    long long v18 = *(std::__shared_weak_count **)(a1 + 16);
    if (v18 && std::__shared_weak_count::lock(v18)) {
      operator new();
    }
    sub_100088B9C();
  }
  uint64_t v12 = *(std::__shared_weak_count **)(a1 + 16);
  if (!v12 || (v13 = *(void *)(a1 + 8), (__int16 v14 = std::__shared_weak_count::lock(v12)) == 0)) {
    sub_100088B9C();
  }
  __int16 v15 = v14;
  atomic_fetch_add_explicit(&v14->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v14);
  *(void *)&long long v19 = a1;
  *((void *)&v19 + 1) = v13;
  sub_1005CE444((uint64_t)v20, a3);
  uint64_t v25 = 0;
  __int16 v16 = (char *)operator new(0x40uLL);
  *(void *)__int16 v16 = off_1019EC3C8;
  *(_OWORD *)(v16 + 8) = v19;
  *((void *)v16 + 3) = v15;
  sub_1005CE444((uint64_t)(v16 + 32), (uint64_t)v20);
  uint64_t v25 = v16;
  (*(void (**)(uint64_t, uint64_t, uint8_t *))(*(void *)v11 + 136))(v11, a2, buf);
  sub_1003891A4(buf);
  sub_1003891A4(v20);
  sub_10004D2C8(v10);
}

void sub_1005C8E2C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va1, a3);
  va_start(va, a3);
  uint64_t v5 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v11 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  sub_1003891A4((uint64_t *)va1);
  sub_1005C8E78((uint64_t)va);
  sub_10004D2C8(v3);
  _Unwind_Resume(a1);
}

uint64_t sub_1005C8E78(uint64_t a1)
{
  sub_1003891A4((void *)(a1 + 24));
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

uint64_t sub_1005C8EB0(uint64_t a1)
{
  sub_100388CB8((void *)(a1 + 16));
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 8);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_1005C8EE8(uint64_t a1, int a2, uint64_t a3, uint64_t a4)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 24));
  if (!a2) {
    __TUAssertTrigger();
  }
  uint64_t v8 = *(unsigned __int8 *)(a3 + 23);
  if ((v8 & 0x80u) != 0) {
    uint64_t v8 = *(void *)(a3 + 8);
  }
  if (!v8) {
    __TUAssertTrigger();
  }
  if (!*(void *)(a1 + 464)) {
    operator new();
  }
  uint64_t v9 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)uint64_t v10 = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "Already in process of sending a file.", v10, 2u);
  }
  *(void *)uint64_t v10 = a1;
  sub_100023950((uint64_t)&v11, a4);
  sub_1005C96E8(a1 + 8);
}

void sub_1005C9618(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

void sub_1005C96E8(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 8);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_1005C97E0(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 8);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_1005C98D8(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 8);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

uint64_t sub_1005C99D0(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 40);
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  sub_1005CD3C0((void **)(a1 + 8));
  return a1;
}

void sub_1005C9A38(uint64_t a1)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 24));
  uint64_t v2 = *(char **)(a1 + 464);
  if (v2)
  {
    uint64_t v24 = 0;
    uint64_t v25 = 0;
    std::string __p = 0;
    if (*(_DWORD *)(*((void *)v2 + 2) + *(void *)(**((void **)v2 + 2) - 24) + 32)) {
      goto LABEL_16;
    }
    sub_10011FDF0((unint64_t *)&__p, 0x400uLL);
    std::istream::read();
    unint64_t v3 = *(void *)(*((void *)v2 + 2) + 8);
    unsigned int v4 = (char *)__p;
    uint64_t v5 = v24;
    if (v3 <= v24 - (unsigned char *)__p)
    {
      if (v3 < v24 - (unsigned char *)__p)
      {
        uint64_t v5 = (char *)__p + v3;
        uint64_t v24 = (char *)__p + v3;
      }
    }
    else
    {
      sub_10011FDF0((unint64_t *)&__p, v3 - (v24 - (unsigned char *)__p));
      unsigned int v4 = (char *)__p;
      uint64_t v5 = v24;
    }
    uint64_t v2 = *(char **)(a1 + 464);
    if (v4 == v5)
    {
LABEL_16:
      uint64_t v17 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
      {
        unint64_t v19 = *v2;
        if (v19 > 2) {
          unsigned int v20 = "???";
        }
        else {
          unsigned int v20 = off_1019EC910[v19];
        }
        int v21 = *((unsigned __int16 *)v2 + 12);
        int v22 = *((unsigned __int16 *)v2 + 13) - 1;
        *(_DWORD *)long long buf = 136315650;
        *(void *)&uint8_t buf[4] = v20;
        __int16 v27 = 1024;
        int v28 = v21;
        __int16 v29 = 1024;
        int v30 = v22;
        _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "Failed to send file: %s. Couldn't read (%d/%d)", buf, 0x18u);
        uint64_t v2 = *(char **)(a1 + 464);
      }
      uint64_t v18 = *((void *)v2 + 1);
      *((void *)v2 + 1) = 0;
      *(void *)long long buf = v18;
      if (!v18) {
        __TUAssertTrigger();
      }
      sub_1000607A8(v18, 0);
      sub_1005CD3C0((void **)buf);
    }
    else
    {
      uint64_t v6 = *(void *)(a1 + 472);
      uint64_t v7 = *(unsigned __int8 **)(a1 + 464);
      if (v6)
      {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v6 + 16), 1uLL, memory_order_relaxed);
        uint64_t v7 = *(unsigned __int8 **)(a1 + 464);
      }
      uint64_t v8 = *(void *)(a1 + 320);
      uint64_t v9 = *v7;
      uint64_t v10 = *((unsigned __int16 *)v7 + 12);
      uint64_t v11 = *((unsigned __int16 *)v7 + 13);
      uint64_t v12 = *(std::__shared_weak_count **)(a1 + 16);
      if (!v12 || (v13 = *(void *)(a1 + 8), (__int16 v14 = std::__shared_weak_count::lock(v12)) == 0)) {
        sub_100088B9C();
      }
      __int16 v15 = v14;
      atomic_fetch_add_explicit(&v14->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v14);
      BOOL v31 = 0;
      __int16 v16 = operator new(0x30uLL);
      *__int16 v16 = off_1019EC598;
      v16[1] = a1;
      _OWORD v16[2] = v13;
      v16[3] = v15;
      void v16[4] = v2;
      v16[5] = v6;
      BOOL v31 = v16;
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, void **, unsigned char *))(*(void *)v8 + 136))(v8, v9, v10, v11, &__p, buf);
      sub_1005D0358(buf);
    }
    if (__p)
    {
      uint64_t v24 = (char *)__p;
      operator delete(__p);
    }
  }
}

void sub_1005C9D0C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, uint64_t a16, void *a17)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_1005C9D70(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 32);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  unint64_t v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  return a1;
}

void sub_1005C9DAC(uint64_t a1@<X0>, void *a2@<X8>)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 24));
  unsigned int v4 = *(std::__shared_weak_count **)(a1 + 384);
  if (v4)
  {
    uint64_t v5 = std::__shared_weak_count::lock(v4);
    if (v5)
    {
      uint64_t v6 = *(void *)(a1 + 376);
      if (v6)
      {
        (*(void (**)(uint64_t))(*(void *)v6 + 168))(v6);
LABEL_9:
        sub_10004D2C8(v5);
        return;
      }
    }
  }
  else
  {
    uint64_t v5 = 0;
  }
  uint64_t v7 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)uint64_t v8 = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "No delegate to target data", v8, 2u);
  }
  *a2 = 0;
  a2[1] = 0;
  if (v5) {
    goto LABEL_9;
  }
}

void sub_1005C9E84(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_1005C9E98(void *a1, uint64_t *a2, uint64_t *a3, uint64_t a4)
{
  if (!*a3) {
    __TUAssertTrigger();
  }
  uint64_t v8 = (std::__shared_weak_count *)a2[1];
  if (v8)
  {
    uint64_t v9 = std::__shared_weak_count::lock(v8);
    if (v9)
    {
      uint64_t v10 = v9;
      if (*a2)
      {
        unint64_t v11 = 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(*a3 + 16) - *(void *)(*a3 + 8)) >> 3);
        if ((v11 & 0x1F) != 0) {
          uint64_t v12 = (v11 >> 5) + 1;
        }
        else {
          uint64_t v12 = v11 >> 5;
        }
        uint64_t v13 = a1[5];
        if ((unint64_t)(v12 - 0x10000) <= 0xFFFFFFFFFFFF0000)
        {
          if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)__int16 v15 = 134217984;
            *(void *)&void v15[4] = v12;
            _os_log_error_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "Can't configure S4. Total number of segments: %zu", v15, 0xCu);
          }
          *(void *)__int16 v15 = a1;
          sub_100023950((uint64_t)&v15[8], a4);
          uint64_t v14 = a2[1];
          uint64_t v18 = *a2;
          uint64_t v19 = v14;
          if (v14) {
            atomic_fetch_add_explicit((atomic_ullong *volatile)(v14 + 16), 1uLL, memory_order_relaxed);
          }
          sub_1005CA094((uint64_t)(a1 + 1));
        }
        if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)__int16 v15 = 134218240;
          *(void *)&void v15[4] = v11;
          __int16 v16 = 2048;
          uint64_t v17 = v12;
          _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I Configuring S4... Num of line sets: %zu, total segments: %zu", v15, 0x16u);
        }
        sub_1005CA1DC(a1, a2, a3, 0, (unsigned __int16)v12, a4);
      }
      sub_10004D2C8(v10);
    }
  }
}

void sub_1005CA080(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_1005CA094(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 8);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

uint64_t sub_1005CA1A4(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 48);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  sub_100060644((void *)(a1 + 8));
  return a1;
}

void *sub_1005CA1DC(void *a1, uint64_t *a2, uint64_t *a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v12 = *a3;
  if (!*a3)
  {
    __TUAssertTrigger();
    uint64_t v12 = *a3;
  }
  uint64_t v13 = 32 * a4;
  if (v13 + 32 >= (unint64_t)(0x6DB6DB6DB6DB6DB7
                                    * ((uint64_t)(*(void *)(v12 + 16) - *(void *)(v12 + 8)) >> 3)))
    uint64_t v14 = 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(v12 + 16) - *(void *)(v12 + 8)) >> 3);
  else {
    uint64_t v14 = v13 + 32;
  }
  uint64_t v15 = a1[40];
  sub_100023950((uint64_t)v27, a6);
  LOWORD(v28) = a4;
  HIWORD(v28) = a5;
  __int16 v16 = (std::__shared_weak_count *)a3[1];
  uint64_t v29 = *a3;
  int v30 = v16;
  if (v16) {
    atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  *(void *)&long long v31 = a1;
  uint64_t v17 = (std::__shared_weak_count *)a1[2];
  if (!v17 || (uint64_t v18 = a1[1], (v19 = std::__shared_weak_count::lock(v17)) == 0)) {
    sub_100088B9C();
  }
  *((void *)&v31 + 1) = v18;
  long long v32 = v19;
  atomic_fetch_add_explicit(&v19->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v19);
  unsigned int v20 = (std::__shared_weak_count *)a2[1];
  uint64_t v33 = *a2;
  uint64_t v34 = v20;
  if (v20) {
    atomic_fetch_add_explicit(&v20->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v36 = 0;
  int v21 = operator new(0x68uLL);
  *(void *)int v21 = off_1019EC6A8;
  sub_100023950((uint64_t)(v21 + 2), (uint64_t)v27);
  v21[10] = v28;
  int v22 = v30;
  *((void *)v21 + 6) = v29;
  *((void *)v21 + 7) = v22;
  if (v22) {
    atomic_fetch_add_explicit(&v22->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  *((_OWORD *)v21 + 4) = v31;
  __int16 v23 = v32;
  uint64_t v24 = v33;
  *((void *)&v31 + 1) = 0;
  long long v32 = 0;
  *((void *)v21 + 10) = v23;
  *((void *)v21 + 11) = v24;
  uint64_t v25 = v34;
  *((void *)v21 + 12) = v34;
  if (v25) {
    atomic_fetch_add_explicit(&v25->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v36 = v21;
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, void *))(*(void *)v15 + 32))(v15, v12, 32 * a4, v14, a4, a5, v35);
  sub_100060644(v35);
  if (v34) {
    std::__shared_weak_count::__release_weak(v34);
  }
  if (v32) {
    std::__shared_weak_count::__release_weak(v32);
  }
  if (v30) {
    sub_10004D2C8(v30);
  }
  return sub_100060644(v27);
}

void sub_1005CA428(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, void);
  uint64_t v5 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v11 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  uint64_t v15 = va_arg(va1, void);
  sub_100060644((uint64_t *)va1);
  sub_1005CA468((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *sub_1005CA468(void *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[11];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)a1[9];
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  unsigned int v4 = (std::__shared_weak_count *)a1[6];
  if (v4) {
    sub_10004D2C8(v4);
  }

  return sub_100060644(a1);
}

void sub_1005CA4C0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 24));
  uint64_t v6 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v11 = 0;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Sending selected time and freq data", v11, 2u);
  }
  uint64_t v7 = *(std::__shared_weak_count **)(a1 + 384);
  if (v7)
  {
    uint64_t v8 = std::__shared_weak_count::lock(v7);
    if (v8)
    {
      uint64_t v9 = v8;
      uint64_t v10 = *(void *)(a1 + 376);
      if (v10) {
        (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v10 + 56))(v10, a2, a3);
      }
      sub_10004D2C8(v9);
    }
  }
}

void sub_1005CA58C(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_1005CA5A0(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 384);
  if (v3)
  {
    uint64_t v5 = std::__shared_weak_count::lock(v3);
    if (v5)
    {
      uint64_t v6 = v5;
      uint64_t v7 = *(void *)(a1 + 376);
      if (v7) {
        (*(void (**)(uint64_t, uint64_t))(*(void *)v7 + 112))(v7, a2);
      }
      sub_10004D2C8(v6);
    }
  }
}

void sub_1005CA634(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_1005CA648(uint64_t a1)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 24));
  if (capabilities::ct::supportsSARAveraging(v2)
    && *(unsigned char *)(a1 + 65)
    && sub_10025B63C(a1 + 528, 0) == 1
    && !*(void *)(a1 + 624)
    && !*(unsigned char *)(a1 + 281))
  {
    if (*(unsigned char *)(a1 + 584))
    {
      *(unsigned char *)(a1 + 281) = 1;
      uint64_t v3 = *(void *)(a1 + 320);
      *(void *)&long long v6 = a1;
      sub_1002598D0((void *)&v6 + 1, *(void *)(a1 + 8), *(std::__shared_weak_count **)(a1 + 16));
      unsigned int v4 = (char *)operator new(0x20uLL);
      *(void *)unsigned int v4 = off_1019EC728;
      *(_OWORD *)(v4 + 8) = v6;
      *((void *)v4 + 3) = v7;
      uint64_t v9 = v4;
      (*(void (**)(uint64_t, uint64_t, uint8_t *))(*(void *)v3 + 152))(v3, a1 + 560, buf);
      sub_10038A13C(buf);
    }
    else
    {
      uint64_t v5 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "[CellularTx] Could not retrieve last known ISO, will unlock using max time", buf, 2u);
      }
      sub_1005C3A20(a1, &qword_1014C4EF8);
    }
  }
}

void sub_1005CA7C4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11, uint64_t a12, uint64_t a13)
{
}

BOOL sub_1005CA7F4(uint64_t a1)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 24));
  if (*(unsigned char *)(a1 + 316)) {
    return 0;
  }
  int v3 = *(_DWORD *)(a1 + 640);
  if (v3) {
    BOOL v4 = v3 == 5;
  }
  else {
    BOOL v4 = 1;
  }
  if (v4) {
    return 1;
  }
  if (!*(unsigned char *)(a1 + 312) || !*(unsigned char *)(a1 + 304)) {
    return 0;
  }
  return *(_DWORD *)(a1 + 300) <= v3;
}

void sub_1005CA860(uint64_t a1, uint64_t a2)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 24));
  BOOL v4 = *(std::__shared_weak_count **)(a1 + 384);
  if (v4)
  {
    uint64_t v5 = std::__shared_weak_count::lock(v4);
    if (v5)
    {
      long long v6 = v5;
      uint64_t v7 = *(void *)(a1 + 376);
      if (v7) {
        (*(void (**)(uint64_t, uint64_t))(*(void *)v7 + 104))(v7, a2);
      }
      sub_10004D2C8(v6);
    }
  }
}

void sub_1005CA8FC(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_1005CA910(uint64_t a1)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 24));
  if (!*(unsigned char *)(a1 + 644))
  {
    uint64_t v2 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)int v3 = 0;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Report next GPS acquisition status", v3, 2u);
    }
    *(unsigned char *)(a1 + 644) = 1;
  }
}

uint64_t sub_1005CA98C(uint64_t a1)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 24));
  uint64_t v2 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(buf.__r_.__value_.__l.__data_) = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I [d] ****************************", (uint8_t *)&buf, 2u);
    uint64_t v2 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(buf.__r_.__value_.__l.__data_) = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I [d] * StewieBBController state *", (uint8_t *)&buf, 2u);
    uint64_t v2 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(buf.__r_.__value_.__l.__data_) = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I [d] ****************************", (uint8_t *)&buf, 2u);
    uint64_t v2 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    if (*(unsigned char *)(a1 + 64)) {
      int v3 = "true";
    }
    else {
      int v3 = "false";
    }
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I [d] Transport Requested: %s", (uint8_t *)&buf, 0xCu);
    uint64_t v2 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    if (*(unsigned char *)(a1 + 65)) {
      BOOL v4 = "true";
    }
    else {
      BOOL v4 = "false";
    }
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v4;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I [d] Driver Ready: %s", (uint8_t *)&buf, 0xCu);
    uint64_t v2 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    if (*(unsigned char *)(a1 + 66)) {
      uint64_t v5 = "true";
    }
    else {
      uint64_t v5 = "false";
    }
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v5;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I [d] Did Fail: %s", (uint8_t *)&buf, 0xCu);
    uint64_t v2 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    if (*(unsigned char *)(a1 + 67)) {
      long long v6 = "true";
    }
    else {
      long long v6 = "false";
    }
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v6;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I [d] Stewie mode active: %s", (uint8_t *)&buf, 0xCu);
    uint64_t v2 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    if (*(unsigned char *)(a1 + 68)) {
      uint64_t v7 = "true";
    }
    else {
      uint64_t v7 = "false";
    }
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v7;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I [d] Target update due: %s", (uint8_t *)&buf, 0xCu);
    uint64_t v2 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    std::string::size_type v8 = *(void *)(a1 + 72);
    if (v8) {
      std::string::size_type v8 = *(void *)(v8 + 16);
    }
    LODWORD(buf.__r_.__value_.__l.__data_) = 134217984;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = v8;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I [d] Active SIMs: %lu", (uint8_t *)&buf, 0xCu);
    uint64_t v2 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    std::string::size_type v9 = *(void *)(a1 + 104);
    LODWORD(buf.__r_.__value_.__l.__data_) = 134217984;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = v9;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I [d] Scan completed for slots: %lu", (uint8_t *)&buf, 0xCu);
    uint64_t v2 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v10 = *(int *)(a1 + 112);
    if (v10 > 0xA) {
      uint64_t v11 = "???";
    }
    else {
      uint64_t v11 = off_1019EC848[v10];
    }
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v11;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I [d] Request Reason: %s", (uint8_t *)&buf, 0xCu);
    uint64_t v2 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v12 = *(int *)(a1 + 116);
    if (v12 > 3) {
      uint64_t v13 = "???";
    }
    else {
      uint64_t v13 = off_1019EC8A0[v12];
    }
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v13;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I [d] SPS Env: %s", (uint8_t *)&buf, 0xCu);
    uint64_t v2 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v14 = sub_100BC8B90(*(_DWORD *)(a1 + 120));
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v14;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I [d] Exit Reason: %s", (uint8_t *)&buf, 0xCu);
    uint64_t v2 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v15 = *(int *)(a1 + 124);
    if (v15 > 3) {
      __int16 v16 = "???";
    }
    else {
      __int16 v16 = off_1019EC8C0[v15];
    }
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v16;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I [d] Suspend Reason: %s", (uint8_t *)&buf, 0xCu);
    uint64_t v2 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    if (*(unsigned char *)(a1 + 144)) {
      uint64_t v17 = "true";
    }
    else {
      uint64_t v17 = "false";
    }
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v17;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I [d] GPS data available: %s", (uint8_t *)&buf, 0xCu);
    uint64_t v2 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    if (*(void *)(a1 + 160)) {
      uint64_t v18 = "true";
    }
    else {
      uint64_t v18 = "false";
    }
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v18;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I [d] Has TimeFreq data: %s", (uint8_t *)&buf, 0xCu);
    uint64_t v2 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    if (*(void *)(a1 + 176)) {
      uint64_t v19 = "true";
    }
    else {
      uint64_t v19 = "false";
    }
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v19;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I [d] Has location data: %s", (uint8_t *)&buf, 0xCu);
    uint64_t v2 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    if (*(void *)(a1 + 192)) {
      unsigned int v20 = "true";
    }
    else {
      unsigned int v20 = "false";
    }
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v20;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I [d] Has heat map data: %s", (uint8_t *)&buf, 0xCu);
    uint64_t v2 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v21 = *(int *)(a1 + 256);
    if (v21 > 3) {
      int v22 = "???";
    }
    else {
      int v22 = off_1019EC8C0[v21];
    }
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v22;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I [d] Last Suspend Reason: %s", (uint8_t *)&buf, 0xCu);
    uint64_t v2 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    if (*(unsigned char *)(a1 + 280)) {
      __int16 v23 = "true";
    }
    else {
      __int16 v23 = "false";
    }
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v23;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I [d] Regulatory check due: %s", (uint8_t *)&buf, 0xCu);
    uint64_t v2 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    if (*(unsigned char *)(a1 + 282)) {
      uint64_t v24 = "true";
    }
    else {
      uint64_t v24 = "false";
    }
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v24;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I [d] Attempt cellular recovery: %s", (uint8_t *)&buf, 0xCu);
    uint64_t v2 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    if (*(void *)(a1 + 488)) {
      uint64_t v25 = "true";
    }
    else {
      uint64_t v25 = "false";
    }
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v25;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I [d] Regulatory check timer running: %s", (uint8_t *)&buf, 0xCu);
    uint64_t v2 = *(NSObject **)(a1 + 40);
  }
  uint64_t v26 = *(void *)(a1 + 424);
  if (v26 && os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    unsigned int v27 = (*(uint64_t (**)(uint64_t))(*(void *)v26 + 16))(v26);
    if (v27 > 6) {
      int v28 = "???";
    }
    else {
      int v28 = off_1019EC928[v27];
    }
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v28;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I [d] BBState: %s", (uint8_t *)&buf, 0xCu);
    uint64_t v2 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    if (*(unsigned char *)(a1 + 440)) {
      uint64_t v29 = "true";
    }
    else {
      uint64_t v29 = "false";
    }
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v29;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I [d] Provisioned: %s", (uint8_t *)&buf, 0xCu);
    uint64_t v2 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    if (*(unsigned char *)(a1 + 441)) {
      int v30 = "true";
    }
    else {
      int v30 = "false";
    }
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v30;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I [d] Tracking target data: %s", (uint8_t *)&buf, 0xCu);
    uint64_t v2 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    if (*(void *)(a1 + 448)) {
      long long v31 = "true";
    }
    else {
      long long v31 = "false";
    }
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v31;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I [d] Has GPS data provider: %s", (uint8_t *)&buf, 0xCu);
    uint64_t v2 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    if (*(void *)(a1 + 464)) {
      long long v32 = "true";
    }
    else {
      long long v32 = "false";
    }
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v32;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I [d] File transfer in progress: %s", (uint8_t *)&buf, 0xCu);
    uint64_t v2 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v33 = *(int *)(a1 + 480);
    if (v33 > 2) {
      uint64_t v34 = "???";
    }
    else {
      uint64_t v34 = off_1019EC8F8[v33];
    }
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v34;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I [d] Previously reported status: %s", (uint8_t *)&buf, 0xCu);
    uint64_t v2 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    if (*(unsigned char *)(a1 + 484)) {
      uint64_t v35 = "true";
    }
    else {
      uint64_t v35 = "false";
    }
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v35;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I [d] Previously reported connected: %s", (uint8_t *)&buf, 0xCu);
    uint64_t v2 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    if (*(unsigned char *)(a1 + 520)) {
      uint64_t v36 = "true";
    }
    else {
      uint64_t v36 = "false";
    }
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v36;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I [d] Simulate service info: %s", (uint8_t *)&buf, 0xCu);
    uint64_t v2 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v37 = *(int *)(a1 + 148);
    if (v37 > 2) {
      long long v38 = "???";
    }
    else {
      long long v38 = off_1019EC8E0[v37];
    }
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v38;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I [d] GPS acquisition status: %s", (uint8_t *)&buf, 0xCu);
    uint64_t v2 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    if (*(unsigned char *)(a1 + 644)) {
      uint64_t v39 = "true";
    }
    else {
      uint64_t v39 = "false";
    }
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v39;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I [d] Report next acquisition status: %s", (uint8_t *)&buf, 0xCu);
    uint64_t v2 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    sub_100BC897C(*(unsigned __int16 *)(a1 + 646), &buf);
    if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      p_std::string buf = &buf;
    }
    else {
      p_std::string buf = (std::string *)buf.__r_.__value_.__r.__words[0];
    }
    *(_DWORD *)BOOL v52 = 136315138;
    uint64_t v53 = p_buf;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I [d] Transport up for services: %s", v52, 0xCu);
    if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(buf.__r_.__value_.__l.__data_);
    }
    uint64_t v2 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    std::string::size_type v41 = *(void *)(a1 + 152);
    LODWORD(buf.__r_.__value_.__l.__data_) = 134217984;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = v41;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I [d] Test GPS time adjustment: %llu ns", (uint8_t *)&buf, 0xCu);
  }
  xpc_object_t v42 = *(CFUUIDRef **)(a1 + 648);
  for (uint64_t i = *(CFUUIDRef **)(a1 + 656); v42 != i; ++v42)
  {
    xpc_object_t v44 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v44, OS_LOG_TYPE_DEFAULT))
    {
      sub_100BC8FAC(v42, &buf);
      uint64_t v45 = (buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
          ? &buf
          : (std::string *)buf.__r_.__value_.__r.__words[0];
      *(_DWORD *)BOOL v52 = 136446210;
      uint64_t v53 = v45;
      _os_log_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_DEFAULT, "#I [d] Pending to cancel messageID: %{public}s", v52, 0xCu);
      if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(buf.__r_.__value_.__l.__data_);
      }
    }
  }
  long long v46 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v46, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v47 = *(void *)(a1 + 336);
    xpc_object_t v48 = "not ";
    if (v47 && *(_DWORD *)(v47 + 68) == 2) {
      xpc_object_t v48 = "";
    }
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v48;
    _os_log_impl((void *)&_mh_execute_header, v46, OS_LOG_TYPE_DEFAULT, "#I [d] PreventNvmSync Assertion: %sacquired", (uint8_t *)&buf, 0xCu);
    long long v46 = *(NSObject **)(a1 + 40);
  }
  if (os_log_type_enabled(v46, OS_LOG_TYPE_DEFAULT))
  {
    if (*(unsigned char *)(a1 + 352)) {
      xpc_object_t v49 = "";
    }
    else {
      xpc_object_t v49 = "NOT ";
    }
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v49;
    _os_log_impl((void *)&_mh_execute_header, v46, OS_LOG_TYPE_DEFAULT, "#I [d] Device is %sin high speed non-emergency environment environment", (uint8_t *)&buf, 0xCu);
  }
  uint64_t result = *(void *)(a1 + 320);
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 168))(result);
  }
  return result;
}

void sub_1005CB89C(uint64_t a1)
{
  sub_1005CB9E0(a1);

  operator delete();
}

uint64_t sub_1005CB8D4(uint64_t a1)
{
  return sub_1005CB9E0(a1 - 48);
}

void sub_1005CB8DC(uint64_t a1)
{
  sub_1005CB9E0(a1 - 48);

  operator delete();
}

uint64_t sub_1005CB918(uint64_t a1)
{
  return sub_1005CB9E0(a1 - 56);
}

void sub_1005CB920(uint64_t a1)
{
  sub_1005CB9E0(a1 - 56);

  operator delete();
}

void sub_1005CB95C(void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (const void **)**a1;
  if (v2)
  {
    BOOL v4 = (const void **)v1[1];
    uint64_t v5 = v2;
    if (v4 != v2)
    {
      do
        BOOL v4 = sub_10012577C(v4 - 1);
      while (v4 != v2);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t sub_1005CB9E0(uint64_t a1)
{
  *(void *)a1 = off_1019EB848;
  uint64_t v2 = (StewieCommandDriverDelegate *)(a1 + 48);
  *(void *)(a1 + 48) = off_1019EB9A8;
  *(void *)(a1 + 56) = off_1019EBA30;
  uint64_t v26 = (void **)(a1 + 648);
  sub_1005CB95C(&v26);
  int v3 = *(std::__shared_weak_count **)(a1 + 632);
  if (v3) {
    sub_10004D2C8(v3);
  }
  uint64_t v4 = *(void *)(a1 + 616);
  *(void *)(a1 + 616) = 0;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 32))(v4);
  }
  uint64_t v5 = *(void *)(a1 + 600);
  *(void *)(a1 + 600) = 0;
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 32))(v5);
  }
  if (*(unsigned char *)(a1 + 584))
  {
    long long v6 = *(void **)(a1 + 560);
    if (v6)
    {
      *(void *)(a1 + 568) = v6;
      operator delete(v6);
    }
  }
  uint64_t v7 = *(void *)(a1 + 536);
  *(void *)(a1 + 536) = 0;
  if (v7) {
    sub_10026CD9C(a1 + 536, v7);
  }
  std::string::size_type v8 = *(std::__shared_weak_count **)(a1 + 512);
  if (v8) {
    sub_10004D2C8(v8);
  }
  std::string::size_type v9 = *(std::__shared_weak_count **)(a1 + 496);
  if (v9) {
    sub_10004D2C8(v9);
  }
  uint64_t v10 = *(std::__shared_weak_count **)(a1 + 472);
  if (v10) {
    sub_10004D2C8(v10);
  }
  uint64_t v11 = *(std::__shared_weak_count **)(a1 + 456);
  if (v11) {
    sub_10004D2C8(v11);
  }
  uint64_t v12 = *(void *)(a1 + 432);
  *(void *)(a1 + 432) = 0;
  if (v12) {
    (*(void (**)(uint64_t))(*(void *)v12 + 40))(v12);
  }
  uint64_t v13 = *(void *)(a1 + 424);
  *(void *)(a1 + 424) = 0;
  if (v13) {
    (*(void (**)(uint64_t))(*(void *)v13 + 8))(v13);
  }
  uint64_t v14 = *(void *)(a1 + 400);
  *(void *)(a1 + 400) = 0;
  if (v14) {
    sub_10026CD9C(a1 + 400, v14);
  }
  uint64_t v15 = *(std::__shared_weak_count **)(a1 + 384);
  if (v15) {
    std::__shared_weak_count::__release_weak(v15);
  }
  __int16 v16 = *(std::__shared_weak_count **)(a1 + 368);
  if (v16) {
    sub_10004D2C8(v16);
  }
  uint64_t v17 = *(std::__shared_weak_count **)(a1 + 344);
  if (v17) {
    sub_10004D2C8(v17);
  }
  uint64_t v18 = *(std::__shared_weak_count **)(a1 + 328);
  if (v18) {
    sub_10004D2C8(v18);
  }
  uint64_t v19 = *(std::__shared_weak_count **)(a1 + 272);
  if (v19) {
    sub_10004D2C8(v19);
  }
  unsigned int v20 = *(std::__shared_weak_count **)(a1 + 200);
  if (v20) {
    sub_10004D2C8(v20);
  }
  uint64_t v21 = *(std::__shared_weak_count **)(a1 + 184);
  if (v21) {
    sub_10004D2C8(v21);
  }
  int v22 = *(std::__shared_weak_count **)(a1 + 168);
  if (v22) {
    sub_10004D2C8(v22);
  }
  __int16 v23 = *(std::__shared_weak_count **)(a1 + 136);
  if (v23) {
    sub_10004D2C8(v23);
  }
  sub_1000346F8(a1 + 88, *(void **)(a1 + 96));
  uint64_t v24 = *(std::__shared_weak_count **)(a1 + 80);
  if (v24) {
    sub_10004D2C8(v24);
  }
  StewieCommandDriverDelegate::~StewieCommandDriverDelegate(v2);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 40));
  sub_100087E88((void *)(a1 + 8));
  return a1;
}

void sub_1005CBC54(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_1005CBD20(void *a1)
{
  __cxa_begin_catch(a1);
  dispatch_barrier_async_f(v1[3], v1, (dispatch_function_t)sub_1005CBDF8);
  __cxa_rethrow();
}

void sub_1005CBD48(_Unwind_Exception *a1)
{
}

void sub_1005CBD60(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_1005CBD98(uint64_t a1)
{
}

uint64_t sub_1005CBDB4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_1005CBDF8(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 64))();
  }
  return result;
}

void sub_1005CBE24(void *a1)
{
  *a1 = off_1019EBBA0;
  operator new();
}

void sub_1005CBECC()
{
}

uint64_t sub_1005CBEF0(uint64_t a1)
{
  *(unsigned char *)(a1 + 24) = 0;
  return (*(uint64_t (**)(void))(**(void **)(*(void *)(a1 + 8) + 8) + 16))();
}

uint64_t sub_1005CBF20(uint64_t a1)
{
  return sub_1005C6840(a1, 1);
}

void sub_1005CBF28(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v1 = (void *)(a1 + 8);
  uint64_t v2 = v3;
  void *v1 = 0;
  if (v3) {
    sub_10026CD9C((uint64_t)v1, v2);
  }

  operator delete();
}

void sub_1005CBF80()
{
}

void *sub_1005CBF94(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_1019EBC08;
  result[1] = v3;
  return result;
}

uint64_t sub_1005CBFDC(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019EBC08;
  a2[1] = v2;
  return result;
}

uint64_t sub_1005CC008(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 8);
  if (*(unsigned char *)(v1 + 64))
  {
    uint64_t v2 = *(NSObject **)(v1 + 40);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      int v4 = 134217984;
      uint64_t v5 = 15;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I [Failsafe] Regulatory location check timer expired after %ld minutes", (uint8_t *)&v4, 0xCu);
    }
    uint64_t v3 = *(std::__shared_weak_count **)(v1 + 496);
    *(void *)(v1 + 488) = 0;
    *(void *)(v1 + 496) = 0;
    if (v3) {
      sub_10004D2C8(v3);
    }
    *(unsigned char *)(v1 + 280) = 1;
    return (*(uint64_t (**)(void, void))(**(void **)(v1 + 424) + 24))(*(void *)(v1 + 424), 0);
  }
  return result;
}

uint64_t sub_1005CC0F4(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_1005CC134()
{
}

void sub_1005CC144()
{
}

void *sub_1005CC158(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_1019EBC88;
  result[1] = v3;
  return result;
}

uint64_t sub_1005CC1A0(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019EBC88;
  a2[1] = v2;
  return result;
}

void sub_1005CC1CC(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  uint64_t v2 = *(std::__shared_weak_count **)(v1 + 632);
  *(_OWORD *)(v1 + 624) = 0u;
  if (v2) {
    sub_10004D2C8(v2);
  }

  sub_1005C4A14(v1);
}

uint64_t sub_1005CC214(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1005CC254()
{
}

void sub_1005CC264()
{
}

void *sub_1005CC278(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_1019EBD08;
  result[1] = v3;
  return result;
}

uint64_t sub_1005CC2C0(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019EBD08;
  a2[1] = v2;
  return result;
}

void sub_1005CC2EC(uint64_t a1, unsigned char *a2)
{
  if (!*a2)
  {
    uint64_t v2 = *(NSObject **)(*(void *)(a1 + 8) + 40);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t v3 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_ERROR, "BB rejected orientation update", v3, 2u);
    }
  }
}

uint64_t sub_1005CC35C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1005CC39C()
{
}

uint64_t *sub_1005CC3A8(uint64_t **a1)
{
  uint64_t v1 = *a1;
  uint64_t v3 = a1;
  int v4 = v1;
  sub_1005C7F40(*v1, (uint64_t)(v1 + 1), 0);
  sub_100556354((uint64_t *)&v4);
  return sub_100046B58((uint64_t *)&v3);
}

void sub_1005CC3F0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

uint64_t sub_1005CC40C(uint64_t a1)
{
  *(void *)a1 = off_1019EBD88;
  sub_10012577C((const void **)(a1 + 32));
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 24);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_1005CC45C(uint64_t a1)
{
  *(void *)a1 = off_1019EBD88;
  sub_10012577C((const void **)(a1 + 32));
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 24);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete();
}

char *sub_1005CC4CC(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  uint64_t v3 = v2;
  *(void *)uint64_t v2 = off_1019EBD88;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v4 = *(void *)(a1 + 24);
  *((void *)v2 + 3) = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 16), 1uLL, memory_order_relaxed);
  }
  sub_10012A394((const void **)v2 + 4, (const void **)(a1 + 32));
  return v3;
}

const void **sub_1005CC544(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019EBD88;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v2 = *(void *)(a1 + 24);
  *(void *)(a2 + 24) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return sub_10012A394((const void **)(a2 + 32), (const void **)(a1 + 32));
}

void sub_1005CC590(uint64_t a1)
{
}

void sub_1005CC598(void *a1)
{
  sub_10026E570((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_1005CC5D4(void *a1, unsigned __int8 *a2)
{
  uint64_t v3 = (std::__shared_weak_count *)a1[3];
  if (v3)
  {
    int v4 = *a2;
    uint64_t v5 = a1[1];
    long long v6 = std::__shared_weak_count::lock(v3);
    if (v6)
    {
      uint64_t v7 = v6;
      if (a1[2])
      {
        CFUUIDRef v9 = (const __CFUUID *)a1[4];
        uint64_t v8 = (uint64_t)(a1 + 4);
        CFStringRef v13 = CFUUIDCreateString(kCFAllocatorDefault, v9);
        uint64_t v10 = *(NSObject **)(v5 + 40);
        if (v4)
        {
          if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
          {
            long long v14 = 0uLL;
            uint64_t v15 = 0;
            ctu::cf::assign();
            *(_OWORD *)std::string __p = 0uLL;
            uint64_t v12 = 0;
            *(_DWORD *)std::string buf = 136315138;
            uint64_t v17 = __p;
            _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I Message accepted by BB (id: %s)", buf, 0xCu);
            if (SHIBYTE(v12) < 0) {
              operator delete(__p[0]);
            }
          }
        }
        else
        {
          if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
          {
            long long v14 = 0uLL;
            uint64_t v15 = 0;
            ctu::cf::assign();
            *(_OWORD *)std::string __p = 0uLL;
            uint64_t v12 = 0;
            *(_DWORD *)std::string buf = 136315138;
            uint64_t v17 = __p;
            _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "BB rejected message (id: %s)", buf, 0xCu);
            if (SHIBYTE(v12) < 0) {
              operator delete(__p[0]);
            }
          }
          sub_1005C7F40(v5, v8, 0);
        }
        sub_1000558F4((const void **)&v13);
      }
      sub_10004D2C8(v7);
    }
  }
}

void sub_1005CC7BC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, const void *a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19)
{
  if (a19 < 0) {
    operator delete(__p);
  }
  sub_1000558F4(&a13);
  sub_10004D2C8(v19);
  _Unwind_Resume(a1);
}

uint64_t sub_1005CC7FC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1005CC83C()
{
}

void sub_1005CC84C()
{
}

void *sub_1005CC860()
{
  uint64_t result = operator new(0x10uLL);
  void *result = off_1019EBE08;
  return result;
}

void sub_1005CC898(uint64_t a1, void *a2)
{
  *a2 = off_1019EBE08;
}

uint64_t sub_1005CC8C4(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_1005CC904()
{
}

void sub_1005CC914()
{
}

void *sub_1005CC928()
{
  uint64_t result = operator new(0x10uLL);
  void *result = off_1019EBE88;
  return result;
}

void sub_1005CC960(uint64_t a1, void *a2)
{
  *a2 = off_1019EBE88;
}

uint64_t sub_1005CC98C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1005CC9CC()
{
}

void *sub_1005CC9D8(void *a1)
{
  *a1 = off_1019EBF08;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_1005CCA24(void *a1)
{
  *a1 = off_1019EBF08;
  uint64_t v1 = (std::__shared_weak_count *)a1[2];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

void *sub_1005CCA90(uint64_t a1)
{
  uint64_t result = operator new(0x18uLL);
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 16);
  void *result = off_1019EBF08;
  result[1] = v4;
  result[2] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_1005CCAEC(uint64_t result, void *a2)
{
  uint64_t v3 = *(void *)(result + 8);
  uint64_t v2 = *(void *)(result + 16);
  *a2 = off_1019EBF08;
  a2[1] = v3;
  a2[2] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_1005CCB24(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_1005CCB34(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[2];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete(__p);
}

void sub_1005CCB74(uint64_t a1, uint64_t a2, unsigned int *a3)
{
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4)
  {
    unsigned int v5 = *a3;
    long long v6 = std::__shared_weak_count::lock(v4);
    if (v6)
    {
      uint64_t v7 = v6;
      uint64_t v8 = *(void *)(a1 + 8);
      if (v8)
      {
        dispatch_assert_queue_V2(*(dispatch_queue_t *)(v8 + 24));
        CFUUIDRef v9 = *(NSObject **)(v8 + 40);
        if (v5 == 2)
        {
          if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
          {
            LOWORD(v15) = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "Failed to fetch HWSupport from BB", (uint8_t *)&v15, 2u);
          }
        }
        else
        {
          if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v10 = "???";
            if (v5 == 1) {
              uint64_t v10 = "kSupported";
            }
            if (!v5) {
              uint64_t v10 = "kNotSupported";
            }
            int v15 = 136315138;
            __int16 v16 = v10;
            _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I Caching hardware capability result: %s", (uint8_t *)&v15, 0xCu);
          }
          sub_1005C8770(v8 + 392, v5);
          uint64_t v11 = *(std::__shared_weak_count **)(v8 + 384);
          if (v11)
          {
            uint64_t v12 = std::__shared_weak_count::lock(v11);
            if (v12)
            {
              CFStringRef v13 = v12;
              uint64_t v14 = *(void *)(v8 + 376);
              if (v14) {
                (*(void (**)(uint64_t, BOOL))(*(void *)v14 + 48))(v14, v5 == 1);
              }
              sub_10004D2C8(v13);
            }
          }
        }
      }
      sub_10004D2C8(v7);
    }
  }
}

void sub_1005CCD44(_Unwind_Exception *a1)
{
  sub_10004D2C8(v2);
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1005CCD68(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_1005CCDA8()
{
}

void *sub_1005CCDB4(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void sub_1005CCE3C()
{
}

void *sub_1005CCE50()
{
  uint64_t result = operator new(0x10uLL);
  void *result = off_1019EBF98;
  return result;
}

void sub_1005CCE88(uint64_t a1, void *a2)
{
  *a2 = off_1019EBF98;
}

uint64_t sub_1005CCEB4(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_1005CCEF4()
{
}

void sub_1005CCF04()
{
}

void *sub_1005CCF18(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_1019EC018;
  result[1] = v3;
  return result;
}

uint64_t sub_1005CCF60(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019EC018;
  a2[1] = v2;
  return result;
}

void sub_1005CCF8C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(v1 + 24));
  if (*(unsigned char *)(v1 + 64) && *(unsigned char *)(v1 + 520))
  {
    if (*(unsigned char *)(v1 + 312))
    {
      v2[0] = *(_OWORD *)(v1 + 284);
      *(long long *)((char *)v2 + 12) = *(_OWORD *)(v1 + 296);
      sub_1005C6A20(v1, v2);
    }
  }
}

uint64_t sub_1005CCFF4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1005CD034()
{
}

void sub_1005CD044()
{
}

void *sub_1005CD058()
{
  uint64_t result = operator new(0x10uLL);
  void *result = off_1019EC098;
  return result;
}

void sub_1005CD090(uint64_t a1, void *a2)
{
  *a2 = off_1019EC098;
}

uint64_t sub_1005CD0BC(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_1005CD0FC()
{
}

void sub_1005CD10C()
{
}

void *sub_1005CD120(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_1019EC118;
  result[1] = v3;
  return result;
}

uint64_t sub_1005CD168(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019EC118;
  a2[1] = v2;
  return result;
}

void *sub_1005CD194(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v4 = *a2;
  if (!v4)
  {
    unsigned int v5 = *(NSObject **)(v3 + 40);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v8[0]) = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Failed to send security config update - no credentials available", (uint8_t *)v8, 2u);
      uint64_t v4 = *a2;
    }
    else
    {
      uint64_t v4 = 0;
    }
  }
  uint64_t v6 = *(void *)(v3 + 320);
  v8[0] = off_1019EC188;
  void v8[3] = v8;
  (*(void (**)(uint64_t, uint64_t, void *))(*(void *)v6 + 96))(v6, v4, v8);
  return sub_100060644(v8);
}

void sub_1005CD298(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_1005CD2AC(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_1005CD2EC()
{
}

void sub_1005CD2FC()
{
}

void *sub_1005CD310()
{
  uint64_t result = operator new(0x10uLL);
  void *result = off_1019EC188;
  return result;
}

void sub_1005CD348(uint64_t a1, void *a2)
{
  *a2 = off_1019EC188;
}

uint64_t sub_1005CD374(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1005CD3B4()
{
}

void *sub_1005CD3C0(void **a1)
{
  uint64_t result = *a1;
  *a1 = 0;
  if (result)
  {
    sub_100060644(result);
    operator delete();
  }
  return result;
}

void sub_1005CD410(uint64_t **a1)
{
  uint64_t v1 = **a1;
  int v2 = *((unsigned __int8 *)*a1 + 8);
  if (*(unsigned __int8 *)(v1 + 67) != v2)
  {
    *(unsigned char *)(v1 + 67) = v2;
    (*(void (**)(void, void))(**(void **)(v1 + 424) + 24))(*(void *)(v1 + 424), 0);
  }
  operator delete();
}

void sub_1005CD4A0()
{
}

void sub_1005CD4CC(uint64_t **a1)
{
  int v2 = a1;
  uint64_t v1 = **a1;
  *(unsigned char *)(v1 + 67) = 0;
  (*(void (**)(void))(**(void **)(v1 + 424) + 56))(*(void *)(v1 + 424));
  operator delete();
}

void sub_1005CD548()
{
}

void *sub_1005CD574(void *a1)
{
  *a1 = off_1019EC218;
  int v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_1005CD5C0(void *a1)
{
  *a1 = off_1019EC218;
  uint64_t v1 = (std::__shared_weak_count *)a1[3];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

char *sub_1005CD62C(uint64_t a1)
{
  uint64_t result = (char *)operator new(0x20uLL);
  *(void *)uint64_t result = off_1019EC218;
  *(_OWORD *)(result + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 24);
  *((void *)result + 3) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_1005CD690(uint64_t result, uint64_t a2)
{
  *(void *)a2 = off_1019EC218;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(result + 8);
  uint64_t v2 = *(void *)(result + 24);
  *(void *)(a2 + 24) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_1005CD6D0(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 24);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_1005CD6E0(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete(__p);
}

void sub_1005CD720(void *a1, unsigned __int8 *a2)
{
  uint64_t v3 = (std::__shared_weak_count *)a1[3];
  if (v3)
  {
    int v4 = *a2;
    uint64_t v5 = a1[1];
    uint64_t v6 = std::__shared_weak_count::lock(v3);
    if (v6)
    {
      uint64_t v7 = v6;
      if (a1[2])
      {
        uint64_t v8 = *(NSObject **)(v5 + 40);
        if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
        {
          CFUUIDRef v9 = "Succeeded";
          if (!v4) {
            CFUUIDRef v9 = "Failed";
          }
          uint64_t v10 = "";
          if (!v4) {
            uint64_t v10 = " Will try again later";
          }
          int v11 = 136315394;
          uint64_t v12 = v9;
          __int16 v13 = 2080;
          uint64_t v14 = v10;
          _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I %s to send provisioning state.%s", (uint8_t *)&v11, 0x16u);
        }
      }
      sub_10004D2C8(v7);
    }
  }
}

uint64_t sub_1005CD828(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_1005CD868()
{
}

void sub_1005CD874(uint64_t **a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  uint64_t v3 = *(std::__shared_weak_count **)(v2 + 384);
  if (v3)
  {
    int v4 = std::__shared_weak_count::lock(v3);
    if (v4)
    {
      uint64_t v5 = v4;
      uint64_t v6 = *(void *)(v2 + 376);
      if (v6) {
        (*(void (**)(uint64_t, uint64_t, void))(*(void *)v6 + 8))(v6, 1, *((unsigned int *)v1 + 2));
      }
      sub_10004D2C8(v5);
    }
  }
  operator delete();
}

void sub_1005CD91C()
{
  sub_10004D2C8(v0);
  operator delete();
}

void sub_1005CD950(void **a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (void *)**a1;
  uint64_t v3 = (std::__shared_weak_count *)v2[48];
  if (v3)
  {
    int v4 = std::__shared_weak_count::lock(v3);
    if (v4)
    {
      uint64_t v5 = v4;
      uint64_t v6 = (void (***)(void, uint64_t, void, void))v2[47];
      if (v6)
      {
        uint64_t v7 = v2[5];
        if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v8 = *((int *)v1 + 2);
          if (v8 > 2) {
            CFUUIDRef v9 = "???";
          }
          else {
            CFUUIDRef v9 = off_1019EC8F8[v8];
          }
          uint64_t v10 = "";
          if (!*((unsigned char *)v1 + 12)) {
            uint64_t v10 = "not ";
          }
          *(_DWORD *)std::string buf = 136315394;
          uint64_t v12 = v9;
          __int16 v13 = 2080;
          uint64_t v14 = v10;
          _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I BB transport status changed: (%s, %sconnected)", buf, 0x16u);
        }
        (**v6)(v6, 1, *((unsigned int *)v1 + 2), *((unsigned __int8 *)v1 + 12));
      }
      sub_10004D2C8(v5);
    }
  }
  operator delete();
}

void sub_1005CDAC0()
{
  sub_10004D2C8(v0);
  operator delete();
}

void *sub_1005CDAF4(void *a1)
{
  *a1 = off_1019EC298;
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_1005CDB40(void *a1)
{
  *a1 = off_1019EC298;
  uint64_t v1 = (std::__shared_weak_count *)a1[3];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

char *sub_1005CDBAC(uint64_t a1)
{
  uint64_t result = (char *)operator new(0x20uLL);
  *(void *)uint64_t result = off_1019EC298;
  *(_OWORD *)(result + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 24);
  *((void *)result + 3) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_1005CDC10(uint64_t result, uint64_t a2)
{
  *(void *)a2 = off_1019EC298;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(result + 8);
  uint64_t v2 = *(void *)(result + 24);
  *(void *)(a2 + 24) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_1005CDC50(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 24);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_1005CDC60(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete(__p);
}

void sub_1005CDCA0(void *a1, uint64_t a2, uint64_t a3)
{
  int v4 = (std::__shared_weak_count *)a1[3];
  if (v4)
  {
    uint64_t v7 = a1[1];
    uint64_t v8 = std::__shared_weak_count::lock(v4);
    if (v8)
    {
      CFUUIDRef v9 = v8;
      if (!a1[2])
      {
LABEL_44:
        sub_10004D2C8(v9);
        return;
      }
      if (!*(unsigned char *)(v7 + 64))
      {
        long long v46 = *(NSObject **)(v7 + 40);
        if (os_log_type_enabled(v46, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)uint64_t v47 = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v46, OS_LOG_TYPE_ERROR, "Transport is not requested", v47, 2u);
        }
        goto LABEL_44;
      }
      if (*(unsigned char *)(a3 + 64))
      {
        uint64_t v10 = operator new(0x58uLL);
        v10[1] = 0;
        void v10[2] = 0;
        *uint64_t v10 = off_1019EC318;
        void v10[3] = *(void *)a3;
        *((_OWORD *)v10 + 2) = *(_OWORD *)(a3 + 8);
        void v10[6] = *(void *)(a3 + 24);
        *(void *)(a3 + 8) = 0;
        *(void *)(a3 + 16) = 0;
        *(void *)(a3 + 24) = 0;
        *((_DWORD *)v10 + 14) = *(_DWORD *)(a3 + 32);
        int v11 = (void *)(a3 + 48);
        uint64_t v12 = *(void *)(a3 + 48);
        uint8_t v10[8] = *(void *)(a3 + 40);
        v10[9] = v12;
        __int16 v13 = (char *)(v10 + 9);
        uint64_t v14 = *(void *)(a3 + 56);
        v10[10] = v14;
        if (v14)
        {
          *(void *)(v12 + 16) = v13;
          *(void *)(a3 + 40) = v11;
          void *v11 = 0;
          *(void *)(a3 + 56) = 0;
        }
        else
        {
          uint8_t v10[8] = v13;
        }
        int v15 = *(std::__shared_weak_count **)(v7 + 200);
        *(void *)(v7 + 192) = v10 + 3;
        *(void *)(v7 + 200) = v10;
        if (v15) {
          sub_10004D2C8(v15);
        }
        Registry::getTimerService((uint64_t *)v47, *(Registry **)(v7 + 360));
        *(void *)(v7 + 224) = (***(uint64_t (****)(void))v47)(*(void *)v47);
        if (*(void *)&v47[8]) {
          sub_10004D2C8(*(std::__shared_weak_count **)&v47[8]);
        }
      }
      if (!*(unsigned char *)(a2 + 112)
        || (dispatch_assert_queue_V2(*(dispatch_queue_t *)(v7 + 24)), float v16 = *(float *)(a2 + 40), fabsf(v16) > 100000.0))
      {
LABEL_43:
        (*(void (**)(void, void))(**(void **)(v7 + 424) + 24))(*(void *)(v7 + 424), 0);
        goto LABEL_44;
      }
      if (!*(void *)(v7 + 160))
      {
        uint64_t v17 = *(NSObject **)(v7 + 40);
        if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v18 = *(void *)(a2 + 32);
          *(_DWORD *)uint64_t v47 = 134218240;
          *(void *)&v47[4] = v18;
          *(_WORD *)&v47[12] = 2048;
          *(double *)&v47[14] = v16;
          _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I Got acceptable time freq data, GPS time: %llu, uncertainity: %f ns", v47, 0x16u);
        }
      }
      ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(v7 + 360));
      unsigned int v20 = ServiceMap;
      if (v21 < 0)
      {
        int v22 = (unsigned __int8 *)(v21 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v23 = 5381;
        do
        {
          uint64_t v21 = v23;
          unsigned int v24 = *v22++;
          uint64_t v23 = (33 * v23) ^ v24;
        }
        while (v24);
      }
      std::mutex::lock(ServiceMap);
      *(void *)uint64_t v47 = v21;
      uint64_t v25 = sub_10004D37C(&v20[1].__m_.__sig, (unint64_t *)v47);
      if (v25)
      {
        uint64_t v27 = v25[3];
        uint64_t v26 = (std::__shared_weak_count *)v25[4];
        if (v26)
        {
          atomic_fetch_add_explicit(&v26->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v20);
          atomic_fetch_add_explicit(&v26->__shared_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v26);
          char v28 = 0;
LABEL_26:
          if ((*(unsigned int (**)(uint64_t))(*(void *)v27 + 16))(v27))
          {
            uint64_t v29 = *(void *)(v7 + 152);
            if ((v28 & 1) == 0) {
              sub_10004D2C8(v26);
            }
            if (v29)
            {
              unint64_t v30 = *(void *)(v7 + 152);
              unint64_t v31 = *(void *)(a2 + 32);
              unint64_t v32 = v31 - v30;
              if (v31 <= v30)
              {
                uint64_t v34 = *(NSObject **)(v7 + 40);
                if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
                {
                  *(_DWORD *)uint64_t v47 = 134217984;
                  *(void *)&v47[4] = v30;
                  _os_log_error_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_ERROR, "[Invalid configuration] Time adjustment of: %llu ns cannot be applied", v47, 0xCu);
                }
              }
              else
              {
                *(void *)(a2 + 32) = v32;
                uint64_t v33 = *(NSObject **)(v7 + 40);
                if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
                {
                  *(_DWORD *)uint64_t v47 = 134218240;
                  *(void *)&v47[4] = v30;
                  *(_WORD *)&v47[12] = 2048;
                  *(void *)&v47[14] = v32;
                  _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "#I Applying time adjustment of: %llu ns, new GPS time: %llu", v47, 0x16u);
                }
              }
            }
          }
          else if ((v28 & 1) == 0)
          {
            sub_10004D2C8(v26);
          }
          unint64_t v35 = *(void *)(a2 + 32);
          dispatch_assert_queue_V2(*(dispatch_queue_t *)(v7 + 24));
          if (!*(unsigned char *)(v7 + 441) && *(unsigned char *)(v7 + 64))
          {
            std::string::size_type v41 = *(NSObject **)(v7 + 40);
            if (os_log_type_enabled(v41, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)uint64_t v47 = 0;
              _os_log_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_DEFAULT, "#I Starting tracking target data", v47, 2u);
            }
            *(unsigned char *)(v7 + 441) = 1;
            xpc_object_t v42 = *(std::__shared_weak_count **)(v7 + 384);
            if (v42)
            {
              long long v43 = std::__shared_weak_count::lock(v42);
              if (v43)
              {
                xpc_object_t v44 = v43;
                uint64_t v45 = *(void *)(v7 + 376);
                if (v45) {
                  (*(void (**)(uint64_t, unint64_t))(*(void *)v45 + 152))(v45, v35 / 0x3B9ACA00);
                }
                sub_10004D2C8(v44);
              }
            }
          }
          uint64_t v36 = (char *)operator new(0x88uLL);
          long long v37 = *(_OWORD *)(a2 + 16);
          *(_OWORD *)(v36 + 24) = *(_OWORD *)a2;
          *(_OWORD *)(v36 + 40) = v37;
          long long v38 = *(_OWORD *)(a2 + 48);
          *(_OWORD *)(v36 + 56) = *(_OWORD *)(a2 + 32);
          *(_OWORD *)(v36 + 120) = *(_OWORD *)(a2 + 96);
          long long v39 = *(_OWORD *)(a2 + 64);
          *(_OWORD *)(v36 + 104) = *(_OWORD *)(a2 + 80);
          *(_OWORD *)(v36 + 88) = v39;
          *((void *)v36 + 1) = 0;
          *((void *)v36 + 2) = 0;
          *(void *)uint64_t v36 = off_1019EC378;
          *(_OWORD *)(v36 + 72) = v38;
          uint64_t v40 = *(std::__shared_weak_count **)(v7 + 168);
          *(void *)(v7 + 160) = v36 + 24;
          *(void *)(v7 + 168) = v36;
          if (v40) {
            sub_10004D2C8(v40);
          }
          Registry::getTimerService((uint64_t *)v47, *(Registry **)(v7 + 360));
          *(void *)(v7 + 208) = (***(uint64_t (****)(void))v47)(*(void *)v47);
          if (*(void *)&v47[8]) {
            sub_10004D2C8(*(std::__shared_weak_count **)&v47[8]);
          }
          sub_1005C4E30(v7);
          goto LABEL_43;
        }
      }
      else
      {
        uint64_t v27 = 0;
      }
      std::mutex::unlock(v20);
      uint64_t v26 = 0;
      char v28 = 1;
      goto LABEL_26;
    }
  }
}

void sub_1005CE250(_Unwind_Exception *a1)
{
  sub_10004D2C8(v2);
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1005CE2B0(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_1005CE2F0()
{
}

void sub_1005CE2FC(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1019EC318;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1005CE31C(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1019EC318;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_1005CE370(uint64_t a1)
{
  sub_10024D10C(a1 + 64, *(void **)(a1 + 72));
  uint64_t v2 = *(void **)(a1 + 32);
  if (v2)
  {
    *(void *)(a1 + 40) = v2;
    operator delete(v2);
  }
}

void sub_1005CE3C8(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1019EC378;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1005CE3E8(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1019EC378;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

uint64_t sub_1005CE444(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (void *)(a2 + 24);
  uint64_t v4 = *(void *)(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(*(void *)*v3 + 24))(*v3, a1);
      return a1;
    }
    *(void *)(a1 + 24) = v4;
  }
  else
  {
    uint64_t v3 = (void *)(a1 + 24);
  }
  void *v3 = 0;
  return a1;
}

uint64_t *sub_1005CE4C4(void **a1)
{
  uint64_t v1 = *a1;
  uint64_t v4 = a1;
  uint64_t v5 = v1;
  uint64_t v6 = 0;
  uint64_t v7 = 0;
  uint64_t v2 = v1[3];
  if (!v2) {
    sub_10007B600();
  }
  (*(void (**)(uint64_t, uint64_t *))(*(void *)v2 + 48))(v2, &v6);
  if (v7) {
    sub_10004D2C8(v7);
  }
  sub_1005CE570(&v5);
  return sub_100046B58((uint64_t *)&v4);
}

void sub_1005CE548(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    sub_10004D2C8(a12);
  }
  sub_1005CE570(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

void **sub_1005CE570(void **a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    sub_1003891A4(v2);
    operator delete();
  }
  return a1;
}

void *sub_1005CE5B8(void *a1)
{
  *a1 = off_1019EC3C8;
  sub_1003891A4(a1 + 4);
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_1005CE608(void *a1)
{
  *a1 = off_1019EC3C8;
  sub_1003891A4(a1 + 4);
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete();
}

void *sub_1005CE678(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t v2 = operator new(0x40uLL);
  void *v2 = off_1019EC3C8;
  sub_1005CE978((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_1005CE6CC(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1005CE6E0(uint64_t a1, void *a2)
{
  *a2 = off_1019EC3C8;
  return sub_1005CE978((uint64_t)(a2 + 1), a1 + 8);
}

void sub_1005CE70C(uint64_t a1)
{
}

void sub_1005CE714(void *a1)
{
  sub_1005CEA78((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_1005CE750(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 24);
  if (v3)
  {
    uint64_t v5 = std::__shared_weak_count::lock(v3);
    if (v5)
    {
      uint64_t v6 = *(void *)(a1 + 16);
      if (v6)
      {
        uint64_t v7 = *(void *)(a2 + 8);
        if (v7) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v7 + 8), 1uLL, memory_order_relaxed);
        }
        sub_1005CE9E0((uint64_t)&v9, a1 + 32);
        uint64_t v8 = *(std::__shared_weak_count **)(v6 + 16);
        if (v8)
        {
          if (std::__shared_weak_count::lock(v8)) {
            operator new();
          }
        }
        sub_100088B9C();
      }
      sub_10004D2C8(v5);
    }
  }
}

void sub_1005CE8F4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

uint64_t sub_1005CE92C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1005CE96C()
{
}

uint64_t sub_1005CE978(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = *(_OWORD *)a2;
  uint64_t v3 = *(void *)(a2 + 16);
  *(void *)(a1 + 16) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  sub_1005CE9E0(a1 + 24, a2 + 24);
  return a1;
}

void sub_1005CE9C8(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(std::__shared_weak_count **)(v1 + 16);
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1005CE9E0(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

void sub_1005CEA78(uint64_t a1)
{
  sub_1003891A4((void *)(a1 + 24));
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2)
  {
    std::__shared_weak_count::__release_weak(v2);
  }
}

uint64_t *sub_1005CEAC4(capabilities::ct *a1)
{
  uint64_t v1 = *(void **)a1;
  uint64_t v12 = a1;
  __int16 v13 = v1;
  uint64_t v2 = v1[1];
  if (v2)
  {
    uint64_t v3 = *v1;
    if (capabilities::ct::supportsSARAveraging(a1))
    {
      uint64_t v4 = *(unsigned char **)(v2 + 72);
      uint64_t v5 = *(unsigned char **)(v2 + 80);
      if (v4 != v5)
      {
        if (!*(unsigned char *)(v3 + 584)
          || (v6 = *(const void **)(v3 + 560), size_t v7 = *(void *)(v3 + 568) - (void)v6, v7 != v5 - v4)
          || memcmp(v6, v4, v7))
        {
          sub_1005C8AC8(v3 + 560, (char **)(v2 + 72));
          if (!*(unsigned char *)(v3 + 584)) {
            sub_10016C840();
          }
          uint64_t v14 = 0;
          int v15 = 0;
          uint64_t v16 = 0;
          sub_10005C928(&v14, *(const void **)(v3 + 560), *(void *)(v3 + 568), *(void *)(v3 + 568) - *(void *)(v3 + 560));
          unsigned int v20 = 0;
          uint64_t v21 = 0;
          std::string __p = 0;
          sub_10005C928(&__p, v14, (uint64_t)v15, v15 - (unsigned char *)v14);
          uint64_t v18 = 0;
          int v22 = 0;
          uint64_t v23 = 0;
          uint64_t v24 = 0;
          sub_10005C928(&v22, __p, (uint64_t)v20, v20 - (unsigned char *)__p);
          uint64_t v25 = 0;
          if (ctu::cf::convert_copy())
          {
            uint64_t v8 = v18;
            uint64_t v18 = v25;
            uint64_t v26 = v8;
            sub_100030068(&v26);
          }
          if (v22)
          {
            uint64_t v23 = v22;
            operator delete(v22);
          }
          uint64_t v9 = v18;
          uint64_t v17 = v18;
          uint64_t v18 = 0;
          sub_100030068(&v18);
          if (__p)
          {
            unsigned int v20 = __p;
            operator delete(__p);
          }
          (***(void (****)(void, const void *))(v3 + 600))(*(void *)(v3 + 600), v9);
          sub_100030068(&v17);
          if (v14)
          {
            int v15 = v14;
            operator delete(v14);
          }
        }
      }
    }
  }
  uint64_t v10 = v1[6];
  if (!v10) {
    sub_10007B600();
  }
  (*(void (**)(uint64_t, void *))(*(void *)v10 + 48))(v10, v1 + 1);
  sub_1005CED14((uint64_t *)&v13);
  return sub_100046B58((uint64_t *)&v12);
}

void sub_1005CEC98(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, uint64_t a14, const void *a15, __int16 a16, char a17, char a18, void *a19, uint64_t a20)
{
  if (__p)
  {
    a13 = (uint64_t)__p;
    operator delete(__p);
  }
  sub_1005CED14(&a11);
  sub_100046B58(&a10);
  _Unwind_Resume(a1);
}

uint64_t *sub_1005CED14(uint64_t *result)
{
  uint64_t v1 = *result;
  char *result = 0;
  if (v1)
  {
    sub_1003891A4((void *)(v1 + 24));
    uint64_t v2 = *(std::__shared_weak_count **)(v1 + 16);
    if (v2) {
      sub_10004D2C8(v2);
    }
    operator delete();
  }
  return result;
}

uint64_t sub_1005CED70(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (void *)(a2 + 24);
  uint64_t v4 = *(void *)(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(*(void *)*v3 + 24))(*v3, a1);
      return a1;
    }
    *(void *)(a1 + 24) = v4;
  }
  else
  {
    uint64_t v3 = (void *)(a1 + 24);
  }
  void *v3 = 0;
  return a1;
}

uint64_t *sub_1005CEDF0(void **a1)
{
  uint64_t v1 = *a1;
  uint64_t v4 = a1;
  uint64_t v5 = v1;
  uint64_t v6 = 0;
  size_t v7 = 0;
  uint64_t v2 = v1[3];
  if (!v2) {
    sub_10007B600();
  }
  (*(void (**)(uint64_t, uint64_t *))(*(void *)v2 + 48))(v2, &v6);
  if (v7) {
    sub_10004D2C8(v7);
  }
  sub_1005CEE9C(&v5);
  return sub_100046B58((uint64_t *)&v4);
}

void sub_1005CEE74(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    sub_10004D2C8(a12);
  }
  sub_1005CEE9C(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

void **sub_1005CEE9C(void **a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    sub_100388CB8(v2);
    operator delete();
  }
  return a1;
}

void *sub_1005CEEE4(void *a1)
{
  *a1 = off_1019EC448;
  sub_100388CB8(a1 + 3);
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_1005CEF34(void *a1)
{
  *a1 = off_1019EC448;
  sub_100388CB8(a1 + 3);
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete();
}

void *sub_1005CEFA4(uint64_t a1)
{
  uint64_t v1 = (void *)(a1 + 8);
  uint64_t v2 = operator new(0x38uLL);
  void *v2 = off_1019EC448;
  sub_1005CF294(v2 + 1, v1);
  return v2;
}

void sub_1005CEFF8(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_1005CF00C(uint64_t a1, void *a2)
{
  *a2 = off_1019EC448;
  return sub_1005CF294(a2 + 1, (void *)(a1 + 8));
}

void sub_1005CF038(uint64_t a1)
{
}

void sub_1005CF040(void *a1)
{
  sub_1005CF38C((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_1005CF07C(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (v3)
  {
    uint64_t v5 = std::__shared_weak_count::lock(v3);
    if (v5)
    {
      uint64_t v6 = *(void *)(a1 + 8);
      if (v6)
      {
        uint64_t v7 = *(void *)(a2 + 8);
        if (v7) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v7 + 8), 1uLL, memory_order_relaxed);
        }
        sub_1005CF2F4((uint64_t)&v9, a1 + 24);
        uint64_t v8 = *(std::__shared_weak_count **)(v6 + 16);
        if (v8)
        {
          if (std::__shared_weak_count::lock(v8)) {
            operator new();
          }
        }
        sub_100088B9C();
      }
      sub_10004D2C8(v5);
    }
  }
}

void sub_1005CF210(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_10006A6AC(exception_object);
}

uint64_t sub_1005CF248(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1005CF288()
{
}

void *sub_1005CF294(void *a1, void *a2)
{
  uint64_t v3 = a2[1];
  *a1 = *a2;
  a1[1] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  sub_1005CF2F4((uint64_t)(a1 + 2), (uint64_t)(a2 + 2));
  return a1;
}

void sub_1005CF2DC(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(std::__shared_weak_count **)(v1 + 8);
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1005CF2F4(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

void sub_1005CF38C(uint64_t a1)
{
  sub_100388CB8((void *)(a1 + 16));
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 8);
  if (v2)
  {
    std::__shared_weak_count::__release_weak(v2);
  }
}

uint64_t *sub_1005CF3D8(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v4 = a1;
  uint64_t v5 = v1;
  uint64_t v2 = *(void *)(v1 + 40);
  if (!v2) {
    sub_10007B600();
  }
  (*(void (**)(uint64_t))(*(void *)v2 + 48))(v2);
  sub_1005CF464(&v5);
  return sub_100046B58((uint64_t *)&v4);
}

void sub_1005CF448(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

uint64_t *sub_1005CF464(uint64_t *result)
{
  uint64_t v1 = *result;
  char *result = 0;
  if (v1)
  {
    sub_100388CB8((void *)(v1 + 16));
    uint64_t v2 = *(std::__shared_weak_count **)(v1 + 8);
    if (v2) {
      sub_10004D2C8(v2);
    }
    operator delete();
  }
  return result;
}

uint64_t *sub_1005CF4C0(uint64_t *a1)
{
  uint64_t v3 = a1;
  uint64_t v4 = (uint64_t *)*a1;
  uint64_t v1 = *v4;
  sub_1000607A8((uint64_t)(v4 + 1), 0);
  (*(void (**)(void, void))(**(void **)(v1 + 424) + 24))(*(void *)(v1 + 424), 0);
  sub_10031EA88((uint64_t *)&v4);
  return sub_100046B58((uint64_t *)&v3);
}

void sub_1005CF538(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

uint64_t *sub_1005CF554(uint64_t *a1)
{
  uint64_t v3 = a1;
  uint64_t v4 = (uint64_t *)*a1;
  uint64_t v1 = *v4;
  sub_1000607A8((uint64_t)(v4 + 1), 0);
  (*(void (**)(void, void))(**(void **)(v1 + 424) + 24))(*(void *)(v1 + 424), 0);
  sub_10031EA88((uint64_t *)&v4);
  return sub_100046B58((uint64_t *)&v3);
}

void sub_1005CF5CC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

uint64_t *sub_1005CF5E8(uint64_t *a1)
{
  uint64_t v3 = a1;
  uint64_t v4 = (uint64_t *)*a1;
  uint64_t v1 = *v4;
  sub_1000607A8((uint64_t)(v4 + 1), 0);
  (*(void (**)(void, void))(**(void **)(v1 + 424) + 24))(*(void *)(v1 + 424), 0);
  sub_10031EA88((uint64_t *)&v4);
  return sub_100046B58((uint64_t *)&v3);
}

void sub_1005CF660(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

void *sub_1005CF67C(void *a1)
{
  *a1 = off_1019EC4C8;
  sub_100060644(a1 + 2);
  return a1;
}

void sub_1005CF6C0(void *a1)
{
  *a1 = off_1019EC4C8;
  sub_100060644(a1 + 2);

  operator delete();
}

void *sub_1005CF724(uint64_t a1)
{
  uint64_t v2 = operator new(0x30uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *v2 = off_1019EC4C8;
  v2[1] = v3;
  sub_1000DFC90((uint64_t)(v2 + 2), a1 + 16);
  return v2;
}

void sub_1005CF77C(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1005CF790(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  *a2 = off_1019EC4C8;
  a2[1] = v2;
  return sub_1000DFC90((uint64_t)(a2 + 2), a1 + 16);
}

void *sub_1005CF7C0(uint64_t a1)
{
  return sub_100060644((void *)(a1 + 16));
}

void sub_1005CF7C8(void *a1)
{
  sub_100060644(a1 + 2);

  operator delete(a1);
}

uint64_t sub_1005CF804(uint64_t a1, unsigned __int8 *a2)
{
  int v3 = *a2;
  uint64_t v4 = *(void *)(a1 + 8);
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(v4 + 24));
  uint64_t v5 = *(std::__shared_weak_count **)(v4 + 472);
  *(void *)(v4 + 464) = 0;
  *(void *)(v4 + 472) = 0;
  if (v5) {
    sub_10004D2C8(v5);
  }
  sub_1000607A8(a1 + 16, v3 != 0);
  uint64_t v6 = *(uint64_t (**)(void))(**(void **)(v4 + 424) + 24);

  return v6();
}

uint64_t sub_1005CF894(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1005CF8D4()
{
}

void sub_1005CF8E0(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1019EC548;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1005CF900(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1019EC548;
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void *sub_1005CF954(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 64);
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = *(void *)(a1 + 40);
  *(void *)(a1 + 40) = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }

  return sub_1005CD3C0((void **)(a1 + 32));
}

void sub_1005CF9C8(uint64_t **a1)
{
  uint64_t v1 = a1;
  sub_1005C9A38(**a1);
  operator delete();
}

void sub_1005CFA1C()
{
}

void *sub_1005CFA48(void *a1)
{
  *a1 = off_1019EC598;
  uint64_t v2 = (std::__shared_weak_count *)a1[5];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)a1[3];
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  return a1;
}

void sub_1005CFAA0(void *a1)
{
  *a1 = off_1019EC598;
  uint64_t v2 = (std::__shared_weak_count *)a1[5];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)a1[3];
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }

  operator delete();
}

char *sub_1005CFB18(uint64_t a1)
{
  uint64_t result = (char *)operator new(0x30uLL);
  *(void *)uint64_t result = off_1019EC598;
  *(_OWORD *)(result + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 24);
  *((void *)result + 3) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  uint64_t v4 = *(void *)(a1 + 40);
  *((void *)result + 4) = *(void *)(a1 + 32);
  *((void *)result + 5) = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_1005CFB94(uint64_t result, uint64_t a2)
{
  *(void *)a2 = off_1019EC598;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(result + 8);
  uint64_t v2 = *(void *)(result + 24);
  *(void *)(a2 + 24) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  uint64_t v3 = *(void *)(result + 40);
  *(void *)(a2 + 32) = *(void *)(result + 32);
  *(void *)(a2 + 40) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_1005CFBEC(uint64_t a1)
{
}

void sub_1005CFBF4(void *a1)
{
  sub_1005D00D0((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_1005CFC30(void *a1, unsigned __int8 *a2, unsigned __int16 *a3)
{
  uint64_t v4 = (std::__shared_weak_count *)a1[3];
  if (v4)
  {
    int v5 = *a2;
    int v6 = *a3;
    uint64_t v7 = a1[1];
    uint64_t v8 = std::__shared_weak_count::lock(v4);
    if (v8)
    {
      uint64_t v9 = v8;
      if (!a1[2]) {
        goto LABEL_34;
      }
      uint64_t v10 = (std::__shared_weak_count *)a1[5];
      if (!v10) {
        goto LABEL_34;
      }
      int v11 = std::__shared_weak_count::lock(v10);
      if (!v11) {
        goto LABEL_34;
      }
      uint64_t v12 = v11;
      if (a1[4])
      {
        if (v5)
        {
          __int16 v13 = *(char **)(v7 + 464);
          int v14 = *((unsigned __int16 *)v13 + 12) + 1;
          if (v14 == *((unsigned __int16 *)v13 + 13))
          {
            int v15 = *(NSObject **)(v7 + 40);
            if (*((void *)v13 + 4))
            {
              if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
              {
                *(_WORD *)std::string buf = 0;
                _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "Timer to wait for receipt confirmation from BB is already running", buf, 2u);
              }
            }
            else
            {
              if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
              {
                unint64_t v16 = *v13;
                if (v16 > 2) {
                  uint64_t v17 = "???";
                }
                else {
                  uint64_t v17 = off_1019EC910[v16];
                }
                *(_DWORD *)std::string buf = 136315394;
                *(void *)&uint8_t buf[4] = v17;
                *(_WORD *)&unsigned char buf[12] = 2048;
                *(void *)&buf[14] = 5;
                _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I Waiting for BB to confirm receipt of file: %s. Will wait for %lld seconds", buf, 0x16u);
              }
              sub_100058DB0(&__p, "WaitForFileTransferStatus");
              Registry::getTimerService(&v29, *(Registry **)(v7 + 360));
              *(void *)std::string buf = off_1019EC618;
              *(void *)&uint8_t buf[8] = v7;
              unint64_t v35 = buf;
              AutoStartTimer::create();
              uint64_t v22 = *(void *)(v7 + 464);
              long long v23 = v33;
              long long v33 = 0uLL;
              uint64_t v24 = *(std::__shared_weak_count **)(v22 + 40);
              *(_OWORD *)(v22 + 32) = v23;
              if (v24)
              {
                sub_10004D2C8(v24);
                if (*((void *)&v33 + 1)) {
                  sub_10004D2C8(*((std::__shared_weak_count **)&v33 + 1));
                }
              }
              sub_10003B34C(buf);
              if (v30) {
                sub_10004D2C8(v30);
              }
              if (v32 < 0) {
                operator delete(__p);
              }
            }
            goto LABEL_33;
          }
          if (v14 == v6)
          {
            *((_WORD *)v13 + 12) = v14;
            sub_1005C9A38(v7);
            goto LABEL_33;
          }
          uint64_t v21 = *(NSObject **)(v7 + 40);
          if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
          {
            unint64_t v27 = *v13;
            if (v27 > 2) {
              char v28 = "???";
            }
            else {
              char v28 = off_1019EC910[v27];
            }
            *(_DWORD *)std::string buf = 136315650;
            *(void *)&uint8_t buf[4] = v28;
            *(_WORD *)&unsigned char buf[12] = 1024;
            *(_DWORD *)&buf[14] = v14;
            *(_WORD *)&buf[18] = 1024;
            *(_DWORD *)&buf[20] = v6;
            _os_log_error_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "Failed to send file: %s. Next segment number: %d, but BB expects: %d", buf, 0x18u);
            __int16 v13 = *(char **)(v7 + 464);
          }
          unsigned int v20 = (void *)*((void *)v13 + 1);
          *((void *)v13 + 1) = 0;
          if (!v20) {
            __TUAssertTrigger();
          }
        }
        else
        {
          uint64_t v18 = *(NSObject **)(v7 + 40);
          if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
          {
            unint64_t v25 = **(char **)(v7 + 464);
            if (v25 > 2) {
              uint64_t v26 = "???";
            }
            else {
              uint64_t v26 = off_1019EC910[v25];
            }
            *(_DWORD *)std::string buf = 136315138;
            *(void *)&uint8_t buf[4] = v26;
            _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "Failed to send file: %s", buf, 0xCu);
          }
          uint64_t v19 = *(void *)(v7 + 464);
          unsigned int v20 = *(void **)(v19 + 8);
          *(void *)(v19 + 8) = 0;
          if (!v20) {
            __TUAssertTrigger();
          }
        }
        sub_1000607A8((uint64_t)v20, 0);
        if (v20)
        {
          sub_100060644(v20);
          operator delete();
        }
      }
LABEL_33:
      sub_10004D2C8(v12);
LABEL_34:
      sub_10004D2C8(v9);
    }
  }
}

void sub_1005CFFFC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, uint64_t a18, uint64_t a19, char a20)
{
  sub_10004D2C8(v21);
  sub_10004D2C8(v20);
  _Unwind_Resume(a1);
}

uint64_t sub_1005D0084(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1005D00C4()
{
}

void sub_1005D00D0(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 32);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (v3)
  {
    std::__shared_weak_count::__release_weak(v3);
  }
}

void sub_1005D0124()
{
}

void *sub_1005D0138(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_1019EC618;
  result[1] = v3;
  return result;
}

uint64_t sub_1005D0180(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019EC618;
  a2[1] = v2;
  return result;
}

uint64_t sub_1005D01AC(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 8);
  uint64_t v2 = *(char **)(v1 + 464);
  if (v2)
  {
    uint64_t v3 = *(NSObject **)(v1 + 40);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      unint64_t v5 = *v2;
      if (v5 > 2) {
        int v6 = "???";
      }
      else {
        int v6 = off_1019EC910[v5];
      }
      int v7 = 136315394;
      uint64_t v8 = v6;
      __int16 v9 = 2048;
      uint64_t v10 = 5;
      _os_log_error_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "File transfer failed for: %s. Timer expired after %lld seconds. Will not wait for BB anymore", (uint8_t *)&v7, 0x16u);
      uint64_t v2 = *(char **)(v1 + 464);
    }
    uint64_t v4 = (void *)*((void *)v2 + 1);
    *((void *)v2 + 1) = 0;
    if (!v4) {
      __TUAssertTrigger();
    }
    uint64_t result = sub_1000607A8((uint64_t)v4, 0);
    if (v4)
    {
      sub_100060644(v4);
      operator delete();
    }
  }
  return result;
}

void sub_1005D02D8(_Unwind_Exception *exception_object)
{
}

uint64_t sub_1005D030C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1005D034C()
{
}

void *sub_1005D0358(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t *sub_1005D03DC(void **a1)
{
  uint64_t v1 = *a1;
  int v7 = a1;
  uint64_t v8 = v1;
  uint64_t v2 = (std::__shared_weak_count *)v1[6];
  if (v2)
  {
    uint64_t v3 = *v1;
    uint64_t v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      unint64_t v5 = v4;
      if (v1[5])
      {
        sub_1000607A8((uint64_t)(v1 + 1), 0);
        (*(void (**)(void, void))(**(void **)(v3 + 424) + 24))(*(void *)(v3 + 424), 0);
      }
      sub_10004D2C8(v5);
    }
  }
  sub_1005D04A4((uint64_t *)&v8);
  return sub_100046B58((uint64_t *)&v7);
}

void sub_1005D0480(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  sub_10004D2C8(v10);
  sub_1005D04A4(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_1005D04A4(uint64_t *result)
{
  uint64_t v1 = *result;
  void *result = 0;
  if (v1)
  {
    uint64_t v2 = *(std::__shared_weak_count **)(v1 + 48);
    if (v2) {
      std::__shared_weak_count::__release_weak(v2);
    }
    sub_100060644((void *)(v1 + 8));
    operator delete();
  }
  return result;
}

void *sub_1005D0500(void *a1)
{
  *a1 = off_1019EC6A8;
  uint64_t v2 = (std::__shared_weak_count *)a1[12];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)a1[10];
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  uint64_t v4 = (std::__shared_weak_count *)a1[7];
  if (v4) {
    sub_10004D2C8(v4);
  }
  sub_100060644(a1 + 1);
  return a1;
}

void sub_1005D056C(void *a1)
{
  *a1 = off_1019EC6A8;
  uint64_t v2 = (std::__shared_weak_count *)a1[12];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)a1[10];
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  uint64_t v4 = (std::__shared_weak_count *)a1[7];
  if (v4) {
    sub_10004D2C8(v4);
  }
  sub_100060644(a1 + 1);

  operator delete();
}

void *sub_1005D05F8(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t v2 = operator new(0x68uLL);
  void *v2 = off_1019EC6A8;
  sub_1005D08AC((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_1005D064C(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1005D0660(uint64_t a1, void *a2)
{
  *a2 = off_1019EC6A8;
  return sub_1005D08AC((uint64_t)(a2 + 1), a1 + 8);
}

void *sub_1005D068C(uint64_t a1)
{
  return sub_1005CA468((void *)(a1 + 8));
}

void sub_1005D0694(void *a1)
{
  sub_1005CA468(a1 + 1);

  operator delete(a1);
}

void sub_1005D06D0(uint64_t a1, unsigned __int8 *a2)
{
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 80);
  if (v3)
  {
    int v4 = *a2;
    uint64_t v5 = *(void *)(a1 + 64);
    int v6 = std::__shared_weak_count::lock(v3);
    if (v6)
    {
      int v7 = v6;
      if (*(void *)(a1 + 72))
      {
        uint64_t v8 = *(std::__shared_weak_count **)(a1 + 96);
        if (v8)
        {
          __int16 v9 = std::__shared_weak_count::lock(v8);
          if (v9)
          {
            uint64_t v10 = v9;
            if (*(void *)(a1 + 88))
            {
              uint64_t v11 = a1 + 8;
              if (v4)
              {
                uint64_t v12 = *(unsigned __int16 *)(a1 + 42);
                if (*(unsigned __int16 *)(a1 + 40) + 1 == v12)
                {
                  __int16 v13 = *(NSObject **)(v5 + 40);
                  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
                  {
                    *(_WORD *)int v14 = 0;
                    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I Configured S4 successfully", v14, 2u);
                  }
                  sub_1000607A8(v11, 1);
                  (*(void (**)(void, void))(**(void **)(v5 + 424) + 24))(*(void *)(v5 + 424), 0);
                }
                else
                {
                  sub_1005CA1DC((void *)v5, (uint64_t *)(a1 + 88), (uint64_t *)(a1 + 48), (unsigned __int16)(*(_WORD *)(a1 + 40) + 1), v12, a1 + 8);
                }
              }
              else
              {
                sub_1000607A8(a1 + 8, 0);
                (*(void (**)(void, void))(**(void **)(v5 + 424) + 24))(*(void *)(v5 + 424), 0);
              }
            }
            sub_10004D2C8(v10);
          }
        }
      }
      sub_10004D2C8(v7);
    }
  }
}

void sub_1005D0840(_Unwind_Exception *a1)
{
  sub_10004D2C8(v2);
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1005D0860(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1005D08A0()
{
}

uint64_t sub_1005D08AC(uint64_t a1, uint64_t a2)
{
  uint64_t result = sub_1000DFC90(a1, a2);
  *(_DWORD *)(result + 32) = *(_DWORD *)(a2 + 32);
  uint64_t v4 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  *(_OWORD *)(result + 56) = *(_OWORD *)(a2 + 56);
  uint64_t v5 = *(void *)(a2 + 72);
  *(void *)(result + 72) = v5;
  if (v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 16), 1uLL, memory_order_relaxed);
  }
  uint64_t v6 = *(void *)(a2 + 88);
  *(void *)(result + 80) = *(void *)(a2 + 80);
  *(void *)(result + 88) = v6;
  if (v6) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v6 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void *sub_1005D0928(void *a1)
{
  *a1 = off_1019EC728;
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_1005D0974(void *a1)
{
  *a1 = off_1019EC728;
  uint64_t v1 = (std::__shared_weak_count *)a1[3];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

char *sub_1005D09E0(uint64_t a1)
{
  uint64_t result = (char *)operator new(0x20uLL);
  *(void *)uint64_t result = off_1019EC728;
  *(_OWORD *)(result + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 24);
  *((void *)result + 3) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_1005D0A44(uint64_t result, uint64_t a2)
{
  *(void *)a2 = off_1019EC728;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(result + 8);
  uint64_t v2 = *(void *)(result + 24);
  *(void *)(a2 + 24) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_1005D0A84(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 24);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_1005D0A94(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete(__p);
}

void sub_1005D0AD4(void *a1, unsigned __int8 *a2, uint64_t a3)
{
  uint64_t v4 = (std::__shared_weak_count *)a1[3];
  if (v4)
  {
    int v6 = *a2;
    uint64_t v7 = a1[1];
    uint64_t v8 = std::__shared_weak_count::lock(v4);
    if (v8)
    {
      __int16 v9 = v8;
      if (a1[2])
      {
        *(unsigned char *)(v7 + 281) = 0;
        if (v6 && *(unsigned char *)(a3 + 8))
        {
          sub_1005C3A20(v7, (uint64_t *)a3);
          (*(void (**)(void, void))(**(void **)(v7 + 424) + 24))(*(void *)(v7 + 424), 0);
        }
        else
        {
          uint64_t v10 = *(NSObject **)(v7 + 40);
          if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)uint64_t v11 = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "[CellularTx] BB did not return valid defer time, will unlock using max time", v11, 2u);
          }
          sub_1005C3A20(v7, &qword_1014C4EF8);
        }
      }
      sub_10004D2C8(v9);
    }
  }
}

void sub_1005D0BD8(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1005D0BEC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1005D0C2C()
{
}

void *sub_1005D0C38(void *a1)
{
  *a1 = off_1019EC7A8;
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_1005D0C84(void *a1)
{
  *a1 = off_1019EC7A8;
  uint64_t v1 = (std::__shared_weak_count *)a1[3];
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }

  operator delete();
}

char *sub_1005D0CF0(uint64_t a1)
{
  uint64_t result = (char *)operator new(0x20uLL);
  *(void *)uint64_t result = off_1019EC7A8;
  *(_OWORD *)(result + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 24);
  *((void *)result + 3) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_1005D0D54(uint64_t result, uint64_t a2)
{
  *(void *)a2 = off_1019EC7A8;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(result + 8);
  uint64_t v2 = *(void *)(result + 24);
  *(void *)(a2 + 24) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_1005D0D94(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 24);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_1005D0DA4(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[3];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete(__p);
}

void sub_1005D0DE4(void *a1, unsigned __int8 *a2)
{
  int v3 = *a2;
  uint64_t v4 = a1[1];
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(v4 + 24));
  uint64_t v5 = (std::__shared_weak_count *)a1[3];
  if (v5)
  {
    int v6 = std::__shared_weak_count::lock(v5);
    if (v6)
    {
      uint64_t v7 = v6;
      if (a1[2])
      {
        uint64_t v8 = *(NSObject **)(v4 + 40);
        if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
        {
          unsigned int v9 = (*(uint64_t (**)(void))(**(void **)(v4 + 424) + 16))(*(void *)(v4 + 424));
          if (v9 > 6) {
            uint64_t v10 = "???";
          }
          else {
            uint64_t v10 = off_1019EC928[v9];
          }
          uint64_t v11 = "";
          if (!v3) {
            uint64_t v11 = "not ";
          }
          int v12 = 136315394;
          __int16 v13 = v10;
          __int16 v14 = 2080;
          int v15 = v11;
          _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I %s [PreventNvmSync] Assertion: %sgranted", (uint8_t *)&v12, 0x16u);
        }
        if (v3) {
          (*(void (**)(void, void))(**(void **)(v4 + 424) + 24))(*(void *)(v4 + 424), 0);
        }
        else {
          sub_1005C8848(v4);
        }
      }
      sub_10004D2C8(v7);
    }
  }
}

void sub_1005D0F68(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1005D0F80(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

_UNKNOWN **sub_1005D0FC0()
{
}

uint64_t sub_1005D0FD4(uint64_t a1, NSObject **a2, void *a3, void *a4, char a5)
{
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v20, kCtLoggingSystemName, "cp.r.rx");
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  uint64_t v10 = *a2;
  *(void *)(a1 + 24) = *a2;
  if (v10) {
    dispatch_retain(v10);
  }
  *(void *)(a1 + 32) = 0;
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)v21, &v20);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 40), (const ctu::OsLogLogger *)v21);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)v21);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v20);
  *(void *)a1 = off_1019ECA30;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(void *)(a1 + 96) = *a3;
  uint64_t v11 = a3[1];
  *(void *)(a1 + 104) = v11;
  if (v11) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v11 + 8), 1uLL, memory_order_relaxed);
  }
  *(void *)(a1 + 112) = *a4;
  uint64_t v12 = a4[1];
  *(void *)(a1 + 120) = v12;
  if (v12) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v12 + 16), 1uLL, memory_order_relaxed);
  }
  *(void *)(a1 + 136) = 0;
  *(unsigned char *)(a1 + 128) = a5;
  *(void *)(a1 + 144) = 0;
  *(void *)(a1 + 152) = 0;
  *(void *)(a1 + 168) = 0;
  *(void *)(a1 + 160) = a1 + 168;
  *(void *)(a1 + 176) = 0;
  sub_100058DB0(&__p, "CellularPlanRemoteCommandReceiver");
  __int16 v13 = *(NSObject **)(a1 + 24);
  uint64_t v17 = v13;
  if (v13) {
    dispatch_retain(v13);
  }
  __int16 v14 = *(NSObject **)(a1 + 32);
  xpc_object_t object = v14;
  if (v14) {
    dispatch_retain(v14);
  }
  ctu::RestModule::RestModule();
  if (object) {
    dispatch_release(object);
  }
  if (v17) {
    dispatch_release(v17);
  }
  if (v19 < 0) {
    operator delete(__p);
  }
  *(unsigned char *)(a1 + 256) = 0;
  *(_OWORD *)(a1 + 224) = 0u;
  *(_OWORD *)(a1 + 240) = 0u;
  return a1;
}

void sub_1005D118C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, dispatch_object_t object, dispatch_object_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, char a19)
{
  if (object) {
    dispatch_release(object);
  }
  if (a10) {
    dispatch_release(a10);
  }
  if (a16 < 0) {
    operator delete(__p);
  }
  sub_100030EE0(v22, *(char **)(v19 + 168));
  sub_1002B2AEC((void ***)&a17);
  uint64_t v24 = *(std::__shared_weak_count **)(v19 + 120);
  if (v24) {
    std::__shared_weak_count::__release_weak(v24);
  }
  unint64_t v25 = *(std::__shared_weak_count **)(v19 + 104);
  if (v25) {
    sub_10004D2C8(v25);
  }
  uint64_t v26 = *(std::__shared_weak_count **)(v19 + 88);
  if (v26) {
    sub_10004D2C8(v26);
  }
  unint64_t v27 = *(std::__shared_weak_count **)(v19 + 72);
  if (v27) {
    sub_10004D2C8(v27);
  }
  char v28 = *(std::__shared_weak_count **)(v19 + 56);
  if (v28) {
    sub_10004D2C8(v28);
  }
  ctu::OsLogLogger::~OsLogLogger(v21);
  sub_100087E88(v20);
  _Unwind_Resume(a1);
}

uint64_t sub_1005D1254(uint64_t a1)
{
  *(void *)a1 = off_1019ECA30;
  ctu::RestModule::disconnect((ctu::RestModule *)(a1 + 184));
  if (*(char *)(a1 + 255) < 0) {
    operator delete(*(void **)(a1 + 232));
  }
  sub_10012C330((void *)(a1 + 200));
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 192);
  if (v2) {
    sub_10004D2C8(v2);
  }
  sub_100030EE0(a1 + 160, *(char **)(a1 + 168));
  unsigned int v9 = (void **)(a1 + 136);
  sub_1002B2AEC(&v9);
  int v3 = *(std::__shared_weak_count **)(a1 + 120);
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 104);
  if (v4) {
    sub_10004D2C8(v4);
  }
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 88);
  if (v5) {
    sub_10004D2C8(v5);
  }
  int v6 = *(std::__shared_weak_count **)(a1 + 72);
  if (v6) {
    sub_10004D2C8(v6);
  }
  uint64_t v7 = *(std::__shared_weak_count **)(a1 + 56);
  if (v7) {
    sub_10004D2C8(v7);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 40));
  sub_100087E88((void *)(a1 + 8));
  return a1;
}

void sub_1005D133C(uint64_t a1)
{
  sub_1005D1254(a1);

  operator delete();
}

void sub_1005D1374(uint64_t a1)
{
  int v2 = *(unsigned __int8 *)(a1 + 128);
  if (v2 == 2)
  {
    ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 96));
    uint64_t v24 = ServiceMap;
    unint64_t v25 = "38CellularPlanIDSServiceManagerInterface";
    uint64_t v26 = "38CellularPlanIDSServiceManagerInterface";
    if (((unint64_t)"38CellularPlanIDSServiceManagerInterface" & 0x8000000000000000) != 0)
    {
      unint64_t v27 = (unsigned __int8 *)((unint64_t)"38CellularPlanIDSServiceManagerInterface" & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v28 = 5381;
      do
      {
        uint64_t v26 = (const char *)v28;
        unsigned int v29 = *v27++;
        uint64_t v28 = (33 * v28) ^ v29;
      }
      while (v29);
    }
    std::mutex::lock(ServiceMap);
    v67[0] = (unint64_t)v26;
    unint64_t v30 = sub_10004D37C(&v24[1].__m_.__sig, v67);
    if (v30)
    {
      uint64_t v32 = v30[3];
      unint64_t v31 = (std::__shared_weak_count *)v30[4];
      if (v31)
      {
        atomic_fetch_add_explicit(&v31->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v24);
        atomic_fetch_add_explicit(&v31->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v31);
        char v33 = 0;
LABEL_32:
        (*(void (**)(long long *__return_ptr, uint64_t))(*(void *)v32 + 16))(&v69, v32);
        long long v36 = v69;
        long long v69 = 0uLL;
        long long v37 = *(std::__shared_weak_count **)(a1 + 72);
        *(_OWORD *)(a1 + 64) = v36;
        if (v37)
        {
          sub_10004D2C8(v37);
          if (*((void *)&v69 + 1)) {
            sub_10004D2C8(*((std::__shared_weak_count **)&v69 + 1));
          }
        }
        if ((v33 & 1) == 0) {
          sub_10004D2C8(v31);
        }
        long long v38 = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 96));
        long long v39 = v38;
        if ((uint64_t)"38CellularPlanIDSServiceManagerInterface" < 0)
        {
          uint64_t v40 = (unsigned __int8 *)((unint64_t)"38CellularPlanIDSServiceManagerInterface" & 0x7FFFFFFFFFFFFFFFLL);
          uint64_t v41 = 5381;
          do
          {
            unint64_t v25 = (const char *)v41;
            unsigned int v42 = *v40++;
            uint64_t v41 = (33 * v41) ^ v42;
          }
          while (v42);
        }
        std::mutex::lock(v38);
        v67[0] = (unint64_t)v25;
        long long v43 = sub_10004D37C(&v39[1].__m_.__sig, v67);
        if (v43)
        {
          uint64_t v45 = v43[3];
          xpc_object_t v44 = (std::__shared_weak_count *)v43[4];
          if (v44)
          {
            atomic_fetch_add_explicit(&v44->__shared_owners_, 1uLL, memory_order_relaxed);
            std::mutex::unlock(v39);
            atomic_fetch_add_explicit(&v44->__shared_owners_, 1uLL, memory_order_relaxed);
            sub_10004D2C8(v44);
            char v46 = 0;
            goto LABEL_53;
          }
        }
        else
        {
          uint64_t v45 = 0;
        }
        std::mutex::unlock(v39);
        xpc_object_t v44 = 0;
        char v46 = 1;
LABEL_53:
        (*(void (**)(long long *__return_ptr, uint64_t))(*(void *)v45 + 32))(&v69, v45);
        long long v49 = v69;
        long long v69 = 0uLL;
        uint64_t v50 = *(std::__shared_weak_count **)(a1 + 88);
        *(_OWORD *)(a1 + 80) = v49;
        if (v50)
        {
          sub_10004D2C8(v50);
          if (*((void *)&v69 + 1)) {
            sub_10004D2C8(*((std::__shared_weak_count **)&v69 + 1));
          }
        }
        if ((v46 & 1) == 0) {
          sub_10004D2C8(v44);
        }
        int v51 = *(std::__shared_weak_count **)(a1 + 16);
        if (!v51 || (unint64_t v52 = *(void *)(a1 + 8), (v53 = std::__shared_weak_count::lock(v51)) == 0)) {
          sub_100088B9C();
        }
        uint64_t v54 = v53;
        p_shared_weak_owners = &v53->__shared_weak_owners_;
        atomic_fetch_add_explicit(&v53->__shared_weak_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v53);
        v75[4] = a1;
        uint64_t v76 = 256;
        uint64_t v56 = *(void *)(a1 + 64);
        v75[0] = _NSConcreteStackBlock;
        v75[1] = 0x40000000;
        v75[2] = sub_1005D5020;
        v75[3] = &unk_1019ECB60;
        *(void *)&long long v69 = _NSConcreteStackBlock;
        *((void *)&v69 + 1) = 1174405120;
        long long v70 = sub_1005D5028;
        uint64_t v71 = &unk_1019ECBB0;
        uint64_t v72 = a1;
        unint64_t v73 = v52;
        signed int v74 = v54;
        atomic_fetch_add_explicit(p_shared_weak_owners, 1uLL, memory_order_relaxed);
        v67[0] = (unint64_t)_NSConcreteStackBlock;
        v67[1] = 1174405120;
        v67[2] = (unint64_t)sub_1005D5270;
        v67[3] = (unint64_t)&unk_1019ECC10;
        v67[4] = a1;
        v67[5] = v52;
        long long v68 = v54;
        atomic_fetch_add_explicit(p_shared_weak_owners, 1uLL, memory_order_relaxed);
        int v57 = (*(uint64_t (**)(uint64_t, const char *, uint64_t *, void *, long long *, unint64_t *))(*(void *)v56 + 24))(v56, "CellularPlanRemoteCommandReceiver", &v76, v75, &v69, v67);
        uint64_t v58 = *(void *)(a1 + 80);
        uint64_t v65 = v54;
        v66[0] = _NSConcreteStackBlock;
        v66[1] = 0x40000000;
        v66[2] = sub_1005D5634;
        v66[3] = &unk_1019ECC40;
        v66[4] = a1;
        v64[0] = _NSConcreteStackBlock;
        v64[1] = 1174405120;
        v64[2] = sub_1005D563C;
        v64[3] = &unk_1019ECC90;
        v64[4] = a1;
        v64[5] = v52;
        atomic_fetch_add_explicit(p_shared_weak_owners, 1uLL, memory_order_relaxed);
        v62[0] = _NSConcreteStackBlock;
        v62[1] = 1174405120;
        v62[2] = sub_1005D58E4;
        v62[3] = &unk_1019ECCF0;
        v62[4] = a1;
        v62[5] = v52;
        uint64_t v63 = v54;
        atomic_fetch_add_explicit(p_shared_weak_owners, 1uLL, memory_order_relaxed);
        int v59 = (*(uint64_t (**)(uint64_t, const char *, uint64_t *, void *, void *, void *))(*(void *)v58 + 24))(v58, "CellularPlanRemoteCommandReceiver", &v76, v66, v64, v62);
        if ((v57 & v59 & 1) == 0)
        {
          uint64_t v60 = *(NSObject **)(a1 + 40);
          if (os_log_type_enabled(v60, OS_LOG_TYPE_ERROR))
          {
            LODWORD(buf) = 67109376;
            HIDWORD(buf) = v57;
            LOWORD(v78) = 1024;
            *(_DWORD *)((char *)&v78 + 2) = v59;
            _os_log_error_impl((void *)&_mh_execute_header, v60, OS_LOG_TYPE_ERROR, "Cannot register callbacks: local [%d]; internet [%d]",
              (uint8_t *)&buf,
              0xEu);
          }
        }
        if ((v57 | v59) == 1)
        {
          Registry::createRestModuleOneTimeUseConnection(&buf, *(Registry **)(a1 + 96));
          ctu::RestModule::connect();
          if (v78) {
            sub_10004D2C8(v78);
          }
          v61[0] = (uint64_t)sub_1005D4FA0;
          v61[1] = 0;
          sub_1005E502C(a1 + 256, a1 + 184, a1, v61);
        }
        if (v63) {
          std::__shared_weak_count::__release_weak(v63);
        }
        if (v65) {
          std::__shared_weak_count::__release_weak(v65);
        }
        if (v68) {
          std::__shared_weak_count::__release_weak(v68);
        }
        if (v74) {
          std::__shared_weak_count::__release_weak(v74);
        }
        std::__shared_weak_count::__release_weak(v54);
        return;
      }
    }
    else
    {
      uint64_t v32 = 0;
    }
    std::mutex::unlock(v24);
    unint64_t v31 = 0;
    char v33 = 1;
    goto LABEL_32;
  }
  if (v2 == 1)
  {
    __int16 v13 = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 96));
    __int16 v14 = v13;
    int v15 = "38CellularPlanIDSServiceManagerInterface";
    if (((unint64_t)"38CellularPlanIDSServiceManagerInterface" & 0x8000000000000000) != 0)
    {
      unint64_t v16 = (unsigned __int8 *)((unint64_t)"38CellularPlanIDSServiceManagerInterface" & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v17 = 5381;
      do
      {
        int v15 = (const char *)v17;
        unsigned int v18 = *v16++;
        uint64_t v17 = (33 * v17) ^ v18;
      }
      while (v18);
    }
    std::mutex::lock(v13);
    v67[0] = (unint64_t)v15;
    uint64_t v19 = sub_10004D37C(&v14[1].__m_.__sig, v67);
    if (v19)
    {
      uint64_t v21 = v19[3];
      OsLogContext v20 = (std::__shared_weak_count *)v19[4];
      if (v20)
      {
        atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v14);
        atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v20);
        char v22 = 0;
        goto LABEL_24;
      }
    }
    else
    {
      uint64_t v21 = 0;
    }
    std::mutex::unlock(v14);
    OsLogContext v20 = 0;
    char v22 = 1;
LABEL_24:
    (*(void (**)(long long *__return_ptr, uint64_t))(*(void *)v21 + 24))(&v69, v21);
    long long v34 = v69;
    long long v69 = 0uLL;
    unint64_t v35 = *(std::__shared_weak_count **)(a1 + 56);
    *(_OWORD *)(a1 + 48) = v34;
    if (v35)
    {
      sub_10004D2C8(v35);
      if (*((void *)&v69 + 1)) {
        sub_10004D2C8(*((std::__shared_weak_count **)&v69 + 1));
      }
    }
    if ((v22 & 1) == 0) {
      sub_10004D2C8(v20);
    }
    goto LABEL_29;
  }
  if (!*(unsigned char *)(a1 + 128))
  {
    int v3 = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 96));
    uint64_t v4 = v3;
    uint64_t v5 = "38CellularPlanIDSServiceManagerInterface";
    if (((unint64_t)"38CellularPlanIDSServiceManagerInterface" & 0x8000000000000000) != 0)
    {
      int v6 = (unsigned __int8 *)((unint64_t)"38CellularPlanIDSServiceManagerInterface" & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v7 = 5381;
      do
      {
        uint64_t v5 = (const char *)v7;
        unsigned int v8 = *v6++;
        uint64_t v7 = (33 * v7) ^ v8;
      }
      while (v8);
    }
    std::mutex::lock(v3);
    v67[0] = (unint64_t)v5;
    unsigned int v9 = sub_10004D37C(&v4[1].__m_.__sig, v67);
    if (v9)
    {
      uint64_t v11 = v9[3];
      uint64_t v10 = (std::__shared_weak_count *)v9[4];
      if (v10)
      {
        atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
        std::mutex::unlock(v4);
        atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
        sub_10004D2C8(v10);
        char v12 = 0;
        goto LABEL_45;
      }
    }
    else
    {
      uint64_t v11 = 0;
    }
    std::mutex::unlock(v4);
    uint64_t v10 = 0;
    char v12 = 1;
LABEL_45:
    (*(void (**)(long long *__return_ptr, uint64_t))(*(void *)v11 + 16))(&v69, v11);
    long long v47 = v69;
    long long v69 = 0uLL;
    xpc_object_t v48 = *(std::__shared_weak_count **)(a1 + 56);
    *(_OWORD *)(a1 + 48) = v47;
    if (v48)
    {
      sub_10004D2C8(v48);
      if (*((void *)&v69 + 1)) {
        sub_10004D2C8(*((std::__shared_weak_count **)&v69 + 1));
      }
    }
    if ((v12 & 1) == 0) {
      sub_10004D2C8(v10);
    }
LABEL_29:
    sub_1005D1BE8(a1);
  }
}

void sub_1005D1B3C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, std::__shared_weak_count *a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,std::__shared_weak_count *a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,std::__shared_weak_count *a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,std::__shared_weak_count *a43)
{
  if (a17) {
    std::__shared_weak_count::__release_weak(a17);
  }
  if (a24) {
    std::__shared_weak_count::__release_weak(a24);
  }
  if (a36) {
    std::__shared_weak_count::__release_weak(a36);
  }
  if (a43) {
    std::__shared_weak_count::__release_weak(a43);
  }
  std::__shared_weak_count::__release_weak(v43);
  _Unwind_Resume(a1);
}

void sub_1005D1BE8(uint64_t a1)
{
  int v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (!v2 || (uint64_t v3 = *(void *)(a1 + 8), (v4 = std::__shared_weak_count::lock(v2)) == 0)) {
    sub_100088B9C();
  }
  uint64_t v5 = v4;
  p_shared_weak_owners = &v4->__shared_weak_owners_;
  atomic_fetch_add_explicit(&v4->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v4);
  uint64_t v17 = 16;
  uint64_t v7 = *(void *)(a1 + 48);
  v16[0] = _NSConcreteStackBlock;
  v16[1] = 0x40000000;
  _OWORD v16[2] = sub_1005D1F08;
  v16[3] = &unk_1019ECA80;
  void v16[4] = a1;
  v14[0] = _NSConcreteStackBlock;
  v14[1] = 1174405120;
  void v14[2] = sub_1005D1FD8;
  uint64_t v14[3] = &unk_1019ECAD0;
  v14[4] = a1;
  v14[5] = v3;
  int v15 = v5;
  atomic_fetch_add_explicit(p_shared_weak_owners, 1uLL, memory_order_relaxed);
  v12[0] = _NSConcreteStackBlock;
  v12[1] = 1174405120;
  void v12[2] = sub_1005D269C;
  v12[3] = &unk_1019ECB30;
  void v12[4] = a1;
  void v12[5] = v3;
  __int16 v13 = v5;
  atomic_fetch_add_explicit(p_shared_weak_owners, 1uLL, memory_order_relaxed);
  if ((*(uint64_t (**)(uint64_t, const char *, uint64_t *, void *, void *, void *))(*(void *)v7 + 24))(v7, "CellularPlanRemoteCommandReceiver", &v17, v16, v14, v12))
  {
    Registry::createRestModuleOneTimeUseConnection(&v10, *(Registry **)(a1 + 96));
    ctu::RestModule::connect();
    if (v11) {
      sub_10004D2C8(v11);
    }
    *(void *)uint64_t buf = off_1019ED100;
    uint64_t v19 = a1 + 184;
    OsLogContext v20 = buf;
    sub_1005E4DB8(buf, (void *)(a1 + 200));
    sub_10012C330(buf);
    uint64_t v8 = *(void *)(a1 + 224);
    if (v8) {
      (*(void (**)(uint64_t, uint64_t))(*(void *)v8 + 48))(v8, a1 + 232);
    }
    *(void *)uint64_t buf = sub_1005D4FA0;
    uint64_t v19 = 0;
    sub_1005E502C(a1 + 256, a1 + 184, a1, (uint64_t *)buf);
  }
  else
  {
    unsigned int v9 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "Cannot register callbacks", buf, 2u);
    }
  }
  if (v13) {
    std::__shared_weak_count::__release_weak(v13);
  }
  if (v15) {
    std::__shared_weak_count::__release_weak(v15);
  }
  std::__shared_weak_count::__release_weak(v5);
}

void sub_1005D1EC0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, std::__shared_weak_count *a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,std::__shared_weak_count *a24)
{
  if (a17) {
    std::__shared_weak_count::__release_weak(a17);
  }
  if (a24) {
    std::__shared_weak_count::__release_weak(a24);
  }
  std::__shared_weak_count::__release_weak(v24);
  _Unwind_Resume(a1);
}

BOOL sub_1005D1F08(uint64_t a1, uint64_t a2)
{
  return sub_1005D1F10(a2);
}

BOOL sub_1005D1F10(uint64_t a1)
{
  uint64_t v1 = *(unsigned __int8 *)(a1 + 55);
  int v2 = (char)v1;
  if ((v1 & 0x80u) != 0) {
    uint64_t v1 = *(void *)(a1 + 40);
  }
  if (v2 >= 0) {
    uint64_t v3 = (char *)(a1 + 32);
  }
  else {
    uint64_t v3 = *(char **)(a1 + 32);
  }
  if (v1 >= 5)
  {
    uint64_t v5 = &v3[v1];
    int v6 = v3;
    do
    {
      uint64_t v7 = (char *)memchr(v6, 80, v1 - 4);
      if (!v7) {
        break;
      }
      if (*(_DWORD *)v7 == 1852794960 && v7[4] == 101)
      {
        if (v7 != v5)
        {
          unsigned int v9 = (char *)(v7 - v3);
          BOOL result = *(unsigned __int16 *)(a1 + 58) > 0xAu;
          if (v9 != (char *)-1) {
            return result;
          }
        }
        return 0;
      }
      int v6 = v7 + 1;
      uint64_t v1 = v5 - (unsigned char *)v6;
    }
    while (v5 - (unsigned char *)v6 >= 5);
  }
  return 0;
}

void sub_1005D1FD8(uint64_t a1, uint64_t *a2)
{
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 1174405120;
  v9[2] = sub_1005D2168;
  v9[3] = &unk_1019ECAA0;
  long long v8 = *(_OWORD *)(a1 + 32);
  long long v10 = v8;
  int v2 = *(std::__shared_weak_count **)(a1 + 48);
  uint64_t v11 = v2;
  if (v2) {
    atomic_fetch_add_explicit(&v2->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  }
  memset(v12, 0, sizeof(v12));
  sub_1003C1BB8(v12, *a2, a2[1], (a2[1] - *a2) >> 6);
  uint64_t v3 = *(std::__shared_weak_count **)(v8 + 16);
  if (!v3 || (uint64_t v4 = *(void ***)(v8 + 8), (v5 = std::__shared_weak_count::lock(v3)) == 0)) {
    sub_100088B9C();
  }
  int v6 = v5;
  uint64_t v7 = *(NSObject **)(v8 + 24);
  block[0] = _NSConcreteStackBlock;
  block[1] = (void **)1174405120;
  void block[2] = (void **)sub_1005E4BA0;
  block[3] = (void **)&unk_1019ED0C0;
  block[5] = v4;
  __int16 v14 = v6;
  atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
  block[4] = (void **)v9;
  dispatch_async(v7, block);
  if (v14) {
    sub_10004D2C8(v14);
  }
  sub_10004D2C8(v6);
  block[0] = (void **)v12;
  sub_1002B2AEC(block);
  if (v11) {
    std::__shared_weak_count::__release_weak(v11);
  }
}

void sub_1005D214C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, std::__shared_weak_count *a18)
{
  if (a18) {
    std::__shared_weak_count::__release_weak(a18);
  }
  _Unwind_Resume(exception_object);
}

void sub_1005D2168(void *a1)
{
  int v2 = (std::__shared_weak_count *)a1[6];
  if (v2)
  {
    uint64_t v3 = a1[4];
    uint64_t v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      uint64_t v5 = v4;
      if (!a1[5])
      {
LABEL_19:
        sub_10004D2C8(v5);
        return;
      }
      if (*(unsigned char *)(v3 + 128) == 1)
      {
        if (*(char *)(v3 + 255) < 0)
        {
          if (!*(void *)(v3 + 240))
          {
LABEL_9:
            (*(void (**)(void **__return_ptr))(**(void **)(v3 + 48) + 56))(__p);
            int v6 = (void **)(v3 + 232);
            if (*(char *)(v3 + 255) < 0) {
              operator delete(*v6);
            }
            *(_OWORD *)int v6 = *(_OWORD *)__p;
            *(void *)(v3 + 248) = v11;
            HIBYTE(v11) = 0;
            LOBYTE(__p[0]) = 0;
            uint64_t v7 = *(void *)(v3 + 224);
            if (v7)
            {
              (*(void (**)(uint64_t, uint64_t))(*(void *)v7 + 48))(v7, v3 + 232);
              if (SHIBYTE(v11) < 0) {
                operator delete(__p[0]);
              }
            }
            long long v8 = *(NSObject **)(v3 + 40);
            if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
            {
              if (*(char *)(v3 + 255) < 0) {
                int v6 = (void **)*v6;
              }
              LODWORD(__p[0]) = 136315138;
              *(void **)((char *)__p + 4) = v6;
              _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Local IDS device Id: [%s]", (uint8_t *)__p, 0xCu);
            }
          }
        }
        else if (!*(unsigned char *)(v3 + 255))
        {
          goto LABEL_9;
        }
      }
      memset(v9, 0, sizeof(v9));
      sub_1003C1BB8(v9, a1[7], a1[8], (uint64_t)(a1[8] - a1[7]) >> 6);
      sub_1005D2384(v3, v9);
      __p[0] = v9;
      sub_1002B2AEC((void ***)__p);
      goto LABEL_19;
    }
  }
}

void sub_1005D2340(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  sub_10004D2C8(v18);
  _Unwind_Resume(a1);
}

void sub_1005D2384(uint64_t a1, std::string **a2)
{
  uint64_t v4 = a1 + 136;
  if ((std::string **)v4 != a2) {
    sub_1005E459C(v4, *a2, a2[1], ((char *)a2[1] - (char *)*a2) >> 6);
  }
  if (!*(unsigned char *)(a1 + 256))
  {
    uint64_t v11 = *(NSObject **)(a1 + 40);
    if (!os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    *(_WORD *)uint64_t buf = 0;
    char v12 = "#I Device not first unlocked yet, can't send IDS message";
LABEL_20:
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, v12, buf, 2u);
    return;
  }
  uint64_t v5 = *a2;
  int v6 = a2[1];
  if (*a2 != v6)
  {
    while (!v5[1].__r_.__value_.__s.__data_[0])
    {
      uint64_t v5 = (std::string *)((char *)v5 + 64);
      if (v5 == v6) {
        goto LABEL_18;
      }
    }
  }
  if (v5 == v6)
  {
LABEL_18:
    uint64_t v11 = *(NSObject **)(a1 + 40);
    if (!os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    *(_WORD *)uint64_t buf = 0;
    char v12 = "#I No Devices in proximity";
    goto LABEL_20;
  }
  uint64_t v7 = *(std::__shared_weak_count **)(a1 + 120);
  if (v7)
  {
    long long v8 = std::__shared_weak_count::lock(v7);
    if (v8)
    {
      unsigned int v9 = v8;
      uint64_t v10 = *(void *)(a1 + 112);
      if (v10)
      {
        *(void *)uint64_t buf = 0;
        uint64_t v16 = 0;
        uint64_t v17 = 0;
        __int16 v14 = 0;
        v19[0] = 0;
        (*(void (**)(uint64_t, unsigned char *, uint8_t *, __int16 *))(*(void *)v10 + 104))(v10, v19, buf, &v14);
        if (v19[0]) {
          v19[0] = 0;
        }
        memset(v13, 0, sizeof(v13));
        sub_100311ED8(v13, *(uint64_t *)buf, v16, 0x2E8BA2E8BA2E8BA3 * ((v16 - *(void *)buf) >> 3));
        sub_1005D5CA8(a1, v13, &v14);
        unsigned int v18 = (uint8_t *)v13;
        sub_1000C56F4((void ***)&v18);
        unsigned int v18 = buf;
        sub_1000C56F4((void ***)&v18);
      }
      sub_10004D2C8(v9);
    }
  }
}

void sub_1005D2570(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, void **a16)
{
  sub_1000C56F4(&a16);
  a16 = (void **)&a13;
  sub_1000C56F4(&a16);
  sub_10004D2C8(v16);
  _Unwind_Resume(a1);
}

void *sub_1005D25BC(void *a1, void *a2)
{
  uint64_t v2 = a2[6];
  a1[5] = a2[5];
  a1[6] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  a1[7] = 0;
  a1[8] = 0;
  a1[9] = 0;
  return sub_1003C1BB8(a1 + 7, a2[7], a2[8], (uint64_t)(a2[8] - a2[7]) >> 6);
}

void sub_1005D2614(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(std::__shared_weak_count **)(v1 + 48);
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  _Unwind_Resume(exception_object);
}

void sub_1005D262C(uint64_t a1)
{
  uint64_t v3 = (void **)(a1 + 56);
  sub_1002B2AEC(&v3);
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 48);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
}

uint64_t sub_1005D2670(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_1005D268C(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_1005D269C(uint64_t a1, long long *a2)
{
  v10[0] = _NSConcreteStackBlock;
  v10[1] = 1174405120;
  void v10[2] = sub_1005D28E4;
  void v10[3] = &unk_1019ECB00;
  long long v9 = *(_OWORD *)(a1 + 32);
  long long v11 = v9;
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 48);
  char v12 = v3;
  if (v3) {
    atomic_fetch_add_explicit(&v3->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  }
  if (*((char *)a2 + 23) < 0)
  {
    sub_10004FC84(&v13, *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v13 = *a2;
    uint64_t v14 = *((void *)a2 + 2);
  }
  if (*((char *)a2 + 47) < 0)
  {
    sub_10004FC84(&__p, *((void **)a2 + 3), *((void *)a2 + 4));
  }
  else
  {
    long long __p = *(long long *)((char *)a2 + 24);
    uint64_t v16 = *((void *)a2 + 5);
  }
  __int16 v17 = *((_WORD *)a2 + 24);
  sub_10002FD9C(&v18, (const void **)a2 + 7);
  sub_100119B5C(&v19, (const void **)a2 + 8);
  v20[0] = *((void *)a2 + 9);
  *(void *)((char *)v20 + 6) = *(void *)((char *)a2 + 78);
  uint64_t v4 = *(std::__shared_weak_count **)(v9 + 16);
  if (!v4 || (v5 = *(void *)(v9 + 8), (int v6 = std::__shared_weak_count::lock(v4)) == 0)) {
    sub_100088B9C();
  }
  uint64_t v7 = v6;
  long long v8 = *(NSObject **)(v9 + 24);
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  void block[2] = sub_1005E4BA0;
  block[3] = &unk_1019ED0C0;
  block[5] = v5;
  char v22 = v7;
  atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
  block[4] = v10;
  dispatch_async(v8, block);
  if (v22) {
    sub_10004D2C8(v22);
  }
  sub_10004D2C8(v7);
  sub_1000FE824(&v19);
  sub_100030068(&v18);
  if (SHIBYTE(v16) < 0) {
    operator delete((void *)__p);
  }
  if (SHIBYTE(v14) < 0) {
    operator delete((void *)v13);
  }
  if (v12) {
    std::__shared_weak_count::__release_weak(v12);
  }
}

void sub_1005D28B0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, std::__shared_weak_count *a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24)
{
  if (a24 < 0) {
    operator delete(__p);
  }
  if (a18) {
    std::__shared_weak_count::__release_weak(a18);
  }
  _Unwind_Resume(exception_object);
}

void sub_1005D28E4(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 48);
  if (v2)
  {
    uint64_t v3 = *(void **)(a1 + 32);
    uint64_t v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      uint64_t v5 = v4;
      if (*(void *)(a1 + 40))
      {
        if (*(char *)(a1 + 79) < 0)
        {
          sub_10004FC84(v6, *(void **)(a1 + 56), *(void *)(a1 + 64));
        }
        else
        {
          *(_OWORD *)int v6 = *(_OWORD *)(a1 + 56);
          uint64_t v7 = *(void *)(a1 + 72);
        }
        if (*(char *)(a1 + 103) < 0)
        {
          sub_10004FC84(&__p, *(void **)(a1 + 80), *(void *)(a1 + 88));
        }
        else
        {
          long long __p = *(_OWORD *)(a1 + 80);
          uint64_t v9 = *(void *)(a1 + 96);
        }
        __int16 v10 = *(_WORD *)(a1 + 104);
        sub_10002FD9C(&v11, (const void **)(a1 + 112));
        sub_100119B5C(&v12, (const void **)(a1 + 120));
        v13[0] = *(void *)(a1 + 128);
        *(void *)((char *)v13 + 6) = *(void *)(a1 + 134);
        sub_1005D2A54(v3, (long long *)v6);
        sub_1000FE824(&v12);
        sub_100030068(&v11);
        if (SHIBYTE(v9) < 0) {
          operator delete((void *)__p);
        }
        if (SHIBYTE(v7) < 0) {
          operator delete(v6[0]);
        }
      }
      sub_10004D2C8(v5);
    }
  }
}

void sub_1005D2A18(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  sub_10004D2C8(v14);
  _Unwind_Resume(a1);
}

void sub_1005D2A54(void *a1, long long *a2)
{
  long long v143 = 0u;
  long long v144 = 0u;
  long long v145 = 0u;
  long long v146 = 0u;
  long long v147 = 0u;
  long long v148 = 0u;
  long long v149 = 0u;
  v142 = &off_101A2DEB8;
  uint64_t v150 = 0;
  memset(v141, 0, sizeof(v141));
  uint64_t v4 = (CFDataRef *)a2 + 7;
  BytePtr = CFDataGetBytePtr(*((CFDataRef *)a2 + 7));
  CFIndex Length = CFDataGetLength(*v4);
  PB::Reader::Reader((PB::Reader *)v141, BytePtr, Length);
  if (sub_100A2A194((int)&v142, (PB::Reader *)v141))
  {
    if ((void)v144)
    {
      if (*((char *)a2 + 23) < 0)
      {
        sub_10004FC84(&__src, *(void **)a2, *((void *)a2 + 1));
      }
      else
      {
        long long __src = *a2;
        uint64_t v126 = *((void *)a2 + 2);
      }
      if (*((char *)a2 + 47) < 0)
      {
        sub_10004FC84(&v127, *((void **)a2 + 3), *((void *)a2 + 4));
      }
      else
      {
        long long v127 = *(long long *)((char *)a2 + 24);
        uint64_t v128 = *((void *)a2 + 5);
      }
      __int16 v129 = *((_WORD *)a2 + 24);
      sub_10002FD9C(&cf, (const void **)v4);
      sub_100119B5C(&v131, (const void **)a2 + 8);
      v132[0] = *((void *)a2 + 9);
      *(void *)((char *)v132 + 6) = *(void *)((char *)a2 + 78);
      uint64_t v9 = a1[5];
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I [DeviceInfoReq]", buf, 2u);
      }
      __int16 v10 = (std::__shared_weak_count *)a1[15];
      if (v10)
      {
        long long v11 = std::__shared_weak_count::lock(v10);
        if (v11)
        {
          uint64_t v12 = a1[14];
          if (v12)
          {
            long long v167 = 0uLL;
            uint64_t v168 = 0;
            uint64_t v163 = 0;
            memset(v162, 0, sizeof(v162));
            long long v160 = 0u;
            long long v161 = 0u;
            long long v158 = 0u;
            long long v159 = 0u;
            LOWORD(v151) = 0;
            LOBYTE(v164) = 0;
            uint64_t v87 = v11;
            (*(void (**)(uint64_t, long long *, long long *, unsigned int *))(*(void *)v12 + 104))(v12, &v164, &v167, &v151);
            if ((_BYTE)v164) {
              LOBYTE(v164) = 0;
            }
            long long v13 = (std::__shared_weak_count *)a1[2];
            if (!v13 || (uint64_t v14 = a1[1], (v15 = std::__shared_weak_count::lock(v13)) == 0)) {
              sub_100088B9C();
            }
            uint64_t v16 = v15;
            p_shared_weak_owners = &v15->__shared_weak_owners_;
            atomic_fetch_add_explicit(&v15->__shared_weak_owners_, 1uLL, memory_order_relaxed);
            sub_10004D2C8(v15);
            *(void *)uint64_t buf = _NSConcreteStackBlock;
            *(void *)&uint8_t buf[8] = 1174405120;
            *(void *)&uint8_t buf[16] = sub_1005E1808;
            *(void *)&unsigned char buf[24] = &unk_1019ECFC0;
            *(void *)&uint8_t buf[32] = a1;
            *(void *)&buf[40] = v14;
            *(void *)&buf[48] = v16;
            atomic_fetch_add_explicit(p_shared_weak_owners, 1uLL, memory_order_relaxed);
            memset(&buf[56], 0, 24);
            sub_100311ED8(&buf[56], v167, *((uint64_t *)&v167 + 1), 0x2E8BA2E8BA2E8BA3 * ((uint64_t)(*((void *)&v167 + 1) - v167) >> 3));
            __int16 v157 = v151;
            if (SHIBYTE(v126) < 0)
            {
              long long v11 = v87;
              sub_10004FC84(&buf[80], (void *)__src, *((unint64_t *)&__src + 1));
            }
            else
            {
              *(_OWORD *)&buf[80] = __src;
              *(void *)&buf[96] = v126;
              long long v11 = v87;
            }
            if (SHIBYTE(v128) < 0)
            {
              sub_10004FC84(v154, (void *)v127, *((unint64_t *)&v127 + 1));
            }
            else
            {
              *(_OWORD *)v154 = v127;
              *(void *)&v154[16] = v128;
            }
            *(_WORD *)&v154[24] = v129;
            *(void *)&v154[32] = cf;
            if (cf) {
              CFRetain(cf);
            }
            CFTypeRef v155 = v131;
            if (v131) {
              CFRetain(v131);
            }
            v156[0] = v132[0];
            *(void *)((char *)v156 + 6) = *(void *)((char *)v132 + 6);
            (*(void (**)(uint64_t, unsigned char *))(*(void *)v12 + 96))(v12, buf);
            sub_1000FE824(&v155);
            sub_100030068((const void **)&v154[32]);
            if ((v154[23] & 0x80000000) != 0) {
              operator delete(*(void **)v154);
            }
            if ((buf[103] & 0x80000000) != 0) {
              operator delete(*(void **)&buf[80]);
            }
            uint64_t v152 = (void **)&buf[56];
            sub_1000C56F4(&v152);
            if (*(void *)&buf[48]) {
              std::__shared_weak_count::__release_weak(*(std::__shared_weak_count **)&buf[48]);
            }
            std::__shared_weak_count::__release_weak(v16);
            *(void *)&long long v158 = &v167;
            sub_1000C56F4((void ***)&v158);
            goto LABEL_113;
          }
        }
      }
      else
      {
        long long v11 = 0;
      }
      *(void *)uint64_t buf = &off_101A1A658;
      memset(&buf[8], 0, 96);
      memset(v154, 0, 32);
      long long v161 = 0u;
      v162[0] = 0u;
      DWORD1(v162[1]) = 0;
      long long v159 = 0u;
      long long v160 = 0u;
      long long v158 = 0u;
      BYTE8(v162[0]) = 2;
      *(void *)((char *)v162 + 12) = 0x50000003CLL;
      sub_100918ACC((uint64_t)buf);
      uint64_t v18 = *(void *)&buf[24];
      *(unsigned char *)(*(void *)&buf[24] + 68) |= 1u;
      *(_DWORD *)(v18 + 48) = 18;
      uint64_t v19 = a1[5];
      if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
      {
        uint64_t v47 = asString();
        LODWORD(v167) = 136315138;
        *(void *)((char *)&v167 + 4) = v47;
        _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Sending Error [%s]", (uint8_t *)&v167, 0xCu);
      }
      if (SHIBYTE(v126) < 0)
      {
        sub_10004FC84(&v167, (void *)__src, *((unint64_t *)&__src + 1));
      }
      else
      {
        long long v167 = __src;
        uint64_t v168 = v126;
      }
      if (SHIBYTE(v128) < 0)
      {
        sub_10004FC84(&v169, (void *)v127, *((unint64_t *)&v127 + 1));
      }
      else
      {
        long long v169 = v127;
        uint64_t v170 = v128;
      }
      __int16 v171 = v129;
      CFTypeRef v172 = cf;
      if (cf) {
        CFRetain(cf);
      }
      CFTypeRef v173 = v131;
      if (v131) {
        CFRetain(v131);
      }
      v174[0] = v132[0];
      *(void *)((char *)v174 + 6) = *(void *)((char *)v132 + 6);
      sub_1005D66F8((uint64_t)a1, (uint64_t)&v167, (uint64_t)buf);
      sub_1000FE824(&v173);
      sub_100030068(&v172);
      if (SHIBYTE(v170) < 0) {
        operator delete((void *)v169);
      }
      if (SHIBYTE(v168) < 0) {
        operator delete((void *)v167);
      }
      sub_1000FE824((const void **)v162);
      sub_100030068((const void **)&v161 + 1);
      if (SHIBYTE(v160) < 0) {
        operator delete(*((void **)&v159 + 1));
      }
      if (SBYTE7(v159) < 0) {
        operator delete((void *)v158);
      }
      sub_100917304((PB::Base *)buf);
      if (!v11)
      {
LABEL_114:
        sub_1000FE824(&v131);
        sub_100030068(&cf);
        if (SHIBYTE(v128) < 0) {
          operator delete((void *)v127);
        }
        if (SHIBYTE(v126) < 0)
        {
          long long v8 = (void *)__src;
          goto LABEL_191;
        }
        goto LABEL_192;
      }
LABEL_113:
      sub_10004D2C8(v11);
      goto LABEL_114;
    }
    if ((void)v143)
    {
      if (*((char *)a2 + 23) < 0)
      {
        sub_10004FC84(&v117, *(void **)a2, *((void *)a2 + 1));
      }
      else
      {
        long long v117 = *a2;
        uint64_t v118 = *((void *)a2 + 2);
      }
      if (*((char *)a2 + 47) < 0)
      {
        sub_10004FC84(&v119, *((void **)a2 + 3), *((void *)a2 + 4));
      }
      else
      {
        long long v119 = *(long long *)((char *)a2 + 24);
        uint64_t v120 = *((void *)a2 + 5);
      }
      __int16 v121 = *((_WORD *)a2 + 24);
      sub_10002FD9C(&v122, (const void **)v4);
      sub_100119B5C(&v123, (const void **)a2 + 8);
      v124[0] = *((void *)a2 + 9);
      *(void *)((char *)v124 + 6) = *(void *)((char *)a2 + 78);
      OsLogContext v20 = a1[5];
      if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "#I [ActivateProfileReq]", buf, 2u);
      }
      uint64_t v21 = (std::__shared_weak_count *)a1[15];
      if (v21)
      {
        char v22 = std::__shared_weak_count::lock(v21);
        if (v22)
        {
          uint64_t v23 = a1[14];
          if (v23)
          {
            long long v165 = 0u;
            long long v166 = 0u;
            long long v164 = 0u;
            sub_1005DE3DC((uint64_t)&v164);
            uint64_t v24 = *(void *)(v143 + 8);
            if (v24 && *(void *)(v24 + 8) == 16)
            {
              unint64_t v25 = *(long long **)(v143 + 16);
              if (v25)
              {
                uint64_t v26 = *(uint64_t **)v24;
                uint64_t v27 = *v26;
                uint64_t v88 = v26[1];
                if (*((char *)v25 + 23) < 0)
                {
                  sub_10004FC84(&v159, *(void **)v25, *((void *)v25 + 1));
                }
                else
                {
                  long long v28 = *v25;
                  *(void *)&long long v160 = *((void *)v25 + 2);
                  long long v159 = v28;
                }
                BYTE8(v160) = 1;
                *(void *)uint64_t buf = _NSConcreteStackBlock;
                *(void *)&uint8_t buf[8] = 1174405120;
                *(void *)&uint8_t buf[16] = sub_1005DE478;
                *(void *)&unsigned char buf[24] = &unk_1019ECD20;
                *(void *)&uint8_t buf[32] = a1;
                *(void *)&v154[24] = v27;
                *(void *)&v154[32] = v88;
                if (SHIBYTE(v118) < 0)
                {
                  sub_10004FC84(&buf[40], (void *)v117, *((unint64_t *)&v117 + 1));
                }
                else
                {
                  *(_OWORD *)&buf[40] = v117;
                  *(void *)&buf[56] = v118;
                }
                if (SHIBYTE(v120) < 0)
                {
                  sub_10004FC84(&buf[64], (void *)v119, *((unint64_t *)&v119 + 1));
                }
                else
                {
                  *(_OWORD *)&buf[64] = v119;
                  *(void *)&buf[80] = v120;
                }
                *(_WORD *)&buf[88] = v121;
                sub_10002FD9C((const void **)&buf[96], &v122);
                sub_100119B5C((const void **)v154, &v123);
                *(void *)&v154[8] = v124[0];
                *(void *)&v154[14] = *(void *)((char *)v124 + 6);
                (*(void (**)(uint64_t, uint64_t, uint64_t, long long *, unsigned char *))(*(void *)v23 + 16))(v23, v27, v88, &v158, buf);
                if (SBYTE7(v160) < 0) {
                  operator delete((void *)v159);
                }
                sub_1000FE824((const void **)v154);
                sub_100030068((const void **)&buf[96]);
                if ((buf[87] & 0x80000000) != 0) {
                  operator delete(*(void **)&buf[64]);
                }
                if ((buf[63] & 0x80000000) != 0) {
                  operator delete(*(void **)&buf[40]);
                }
LABEL_184:
                if (SBYTE7(v166) < 0) {
                  operator delete((void *)v165);
                }
                goto LABEL_186;
              }
              *(void *)uint64_t buf = &off_101A1A658;
              memset(&buf[8], 0, 96);
              memset(v154, 0, 32);
              long long v161 = 0u;
              v162[0] = 0u;
              DWORD1(v162[1]) = 0;
              long long v159 = 0u;
              long long v160 = 0u;
              long long v158 = 0u;
              BYTE8(v162[0]) = 2;
              *(void *)((char *)v162 + 12) = 0x50000003CLL;
              sub_100918770((uint64_t)buf);
              uint64_t v50 = *(void *)&buf[8];
              *(unsigned char *)(*(void *)&buf[8] + 24) |= 1u;
              *(_DWORD *)(v50 + 16) = 1;
              int v51 = a1[5];
              if (os_log_type_enabled(v51, OS_LOG_TYPE_ERROR))
              {
                uint64_t v81 = asString();
                LODWORD(v167) = 136315138;
                *(void *)((char *)&v167 + 4) = v81;
                _os_log_error_impl((void *)&_mh_execute_header, v51, OS_LOG_TYPE_ERROR, "Sending Error [%s]", (uint8_t *)&v167, 0xCu);
              }
              if (SHIBYTE(v118) < 0)
              {
                sub_10004FC84(&v167, (void *)v117, *((unint64_t *)&v117 + 1));
              }
              else
              {
                long long v167 = v117;
                uint64_t v168 = v118;
              }
              if ((SHIBYTE(v120) & 0x80000000) == 0)
              {
                long long v169 = v119;
                uint64_t v170 = v120;
                goto LABEL_175;
              }
            }
            else
            {
              *(void *)uint64_t buf = &off_101A1A658;
              memset(&buf[8], 0, 96);
              memset(v154, 0, 32);
              long long v161 = 0u;
              v162[0] = 0u;
              DWORD1(v162[1]) = 0;
              long long v159 = 0u;
              long long v160 = 0u;
              long long v158 = 0u;
              BYTE8(v162[0]) = 2;
              *(void *)((char *)v162 + 12) = 0x50000003CLL;
              sub_100918770((uint64_t)buf);
              uint64_t v31 = *(void *)&buf[8];
              *(unsigned char *)(*(void *)&buf[8] + 24) |= 1u;
              *(_DWORD *)(v31 + 16) = 13;
              uint64_t v32 = a1[5];
              if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
              {
                uint64_t v53 = asString();
                LODWORD(v167) = 136315138;
                *(void *)((char *)&v167 + 4) = v53;
                _os_log_error_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_ERROR, "Sending Error [%s]", (uint8_t *)&v167, 0xCu);
              }
              if (SHIBYTE(v118) < 0)
              {
                sub_10004FC84(&v167, (void *)v117, *((unint64_t *)&v117 + 1));
              }
              else
              {
                long long v167 = v117;
                uint64_t v168 = v118;
              }
              if ((SHIBYTE(v120) & 0x80000000) == 0)
              {
                long long v169 = v119;
                uint64_t v170 = v120;
LABEL_175:
                __int16 v171 = v121;
                sub_10002FD9C(&v172, &v122);
                sub_100119B5C(&v173, &v123);
                v174[0] = v124[0];
                *(void *)((char *)v174 + 6) = *(void *)((char *)v124 + 6);
                sub_1005D66F8((uint64_t)a1, (uint64_t)&v167, (uint64_t)buf);
                sub_1000FE824(&v173);
                sub_100030068(&v172);
                if (SHIBYTE(v170) < 0) {
                  operator delete((void *)v169);
                }
                if (SHIBYTE(v168) < 0) {
                  operator delete((void *)v167);
                }
                sub_1000FE824((const void **)v162);
                sub_100030068((const void **)&v161 + 1);
                if (SHIBYTE(v160) < 0) {
                  operator delete(*((void **)&v159 + 1));
                }
                if (SBYTE7(v159) < 0) {
                  operator delete((void *)v158);
                }
                sub_100917304((PB::Base *)buf);
                goto LABEL_184;
              }
            }
            sub_10004FC84(&v169, (void *)v119, *((unint64_t *)&v119 + 1));
            goto LABEL_175;
          }
        }
      }
      else
      {
        char v22 = 0;
      }
      *(void *)uint64_t buf = &off_101A1A658;
      memset(&buf[8], 0, 96);
      memset(v154, 0, 32);
      long long v161 = 0u;
      v162[0] = 0u;
      DWORD1(v162[1]) = 0;
      long long v159 = 0u;
      long long v160 = 0u;
      long long v158 = 0u;
      BYTE8(v162[0]) = 2;
      *(void *)((char *)v162 + 12) = 0x50000003CLL;
      sub_100918770((uint64_t)buf);
      uint64_t v29 = *(void *)&buf[8];
      *(unsigned char *)(*(void *)&buf[8] + 24) |= 1u;
      *(_DWORD *)(v29 + 16) = 18;
      unint64_t v30 = a1[5];
      if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
      {
        uint64_t v49 = asString();
        LODWORD(v167) = 136315138;
        *(void *)((char *)&v167 + 4) = v49;
        _os_log_error_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_ERROR, "Sending Error [%s]", (uint8_t *)&v167, 0xCu);
      }
      if (SHIBYTE(v118) < 0)
      {
        sub_10004FC84(&v167, (void *)v117, *((unint64_t *)&v117 + 1));
      }
      else
      {
        long long v167 = v117;
        uint64_t v168 = v118;
      }
      if (SHIBYTE(v120) < 0)
      {
        sub_10004FC84(&v169, (void *)v119, *((unint64_t *)&v119 + 1));
      }
      else
      {
        long long v169 = v119;
        uint64_t v170 = v120;
      }
      __int16 v171 = v121;
      CFTypeRef v172 = v122;
      if (v122) {
        CFRetain(v122);
      }
      CFTypeRef v173 = v123;
      if (v123) {
        CFRetain(v123);
      }
      v174[0] = v124[0];
      *(void *)((char *)v174 + 6) = *(void *)((char *)v124 + 6);
      sub_1005D66F8((uint64_t)a1, (uint64_t)&v167, (uint64_t)buf);
      sub_1000FE824(&v173);
      sub_100030068(&v172);
      if (SHIBYTE(v170) < 0) {
        operator delete((void *)v169);
      }
      if (SHIBYTE(v168) < 0) {
        operator delete((void *)v167);
      }
      sub_1000FE824((const void **)v162);
      sub_100030068((const void **)&v161 + 1);
      if (SHIBYTE(v160) < 0) {
        operator delete(*((void **)&v159 + 1));
      }
      if (SBYTE7(v159) < 0) {
        operator delete((void *)v158);
      }
      sub_100917304((PB::Base *)buf);
      if (!v22)
      {
LABEL_187:
        sub_1000FE824(&v123);
        sub_100030068(&v122);
        if (SHIBYTE(v120) < 0) {
          operator delete((void *)v119);
        }
        if (SHIBYTE(v118) < 0)
        {
          long long v8 = (void *)v117;
          goto LABEL_191;
        }
        goto LABEL_192;
      }
LABEL_186:
      sub_10004D2C8(v22);
      goto LABEL_187;
    }
    if (!(void)v149)
    {
      if (*((void *)&v143 + 1))
      {
        if (*((char *)a2 + 23) < 0)
        {
          sub_10004FC84(&v101, *(void **)a2, *((void *)a2 + 1));
        }
        else
        {
          long long v101 = *a2;
          uint64_t v102 = *((void *)a2 + 2);
        }
        if (*((char *)a2 + 47) < 0)
        {
          sub_10004FC84(&v103, *((void **)a2 + 3), *((void *)a2 + 4));
        }
        else
        {
          long long v103 = *(long long *)((char *)a2 + 24);
          uint64_t v104 = *((void *)a2 + 5);
        }
        __int16 v105 = *((_WORD *)a2 + 24);
        sub_10002FD9C(&v106, (const void **)v4);
        sub_100119B5C(&v107, (const void **)a2 + 8);
        v108[0] = *((void *)a2 + 9);
        *(void *)((char *)v108 + 6) = *(void *)((char *)a2 + 78);
        sub_1005D6A18(a1, &v101, (uint64_t)&v142);
        sub_1000FE824(&v107);
        sub_100030068(&v106);
        if (SHIBYTE(v104) < 0) {
          operator delete((void *)v103);
        }
        if (SHIBYTE(v102) < 0)
        {
          long long v8 = (void *)v101;
          goto LABEL_191;
        }
      }
      else
      {
        if (*((void *)&v148 + 1))
        {
          sub_1005D4D64(v100, a2);
          sub_1005D7304((uint64_t)a1, (uint64_t)v100, (uint64_t)&v142);
          xpc_object_t v48 = (long long *)v100;
        }
        else if ((void)v146)
        {
          sub_1005D4D64((char *)v99, a2);
          sub_1005D8314((uint64_t)a1, v99, (uint64_t)&v142);
          xpc_object_t v48 = v99;
        }
        else if ((void)v145)
        {
          sub_1005D4D64((char *)v98, a2);
          sub_1005D9118(a1, v98, (uint64_t)&v142);
          xpc_object_t v48 = v98;
        }
        else if (*((void *)&v147 + 1))
        {
          sub_1005D4D64((char *)v97, a2);
          sub_1005D9FC0(a1, v97, (uint64_t)&v142);
          xpc_object_t v48 = v97;
        }
        else if (*((void *)&v144 + 1))
        {
          sub_1005D4D64((char *)v96, a2);
          sub_1005DA764(a1, v96, (uint64_t)&v142);
          xpc_object_t v48 = v96;
        }
        else if ((void)v148)
        {
          sub_1005D4D64((char *)v95, a2);
          sub_1005DAF0C(a1, v95, (uint64_t)&v142);
          xpc_object_t v48 = v95;
        }
        else if (*((void *)&v149 + 1))
        {
          sub_1005D4D64((char *)v94, a2);
          sub_1005DB6B4(a1, v94, (uint64_t)&v142);
          xpc_object_t v48 = v94;
        }
        else if (*((void *)&v145 + 1))
        {
          sub_1005D4D64((char *)v93, a2);
          sub_1005DC0D0(a1, v93, (uint64_t)&v142);
          xpc_object_t v48 = v93;
        }
        else if (*((void *)&v146 + 1))
        {
          sub_1005D4D64((char *)v92, a2);
          sub_1005DCB18(a1, v92, (uint64_t)&v142);
          xpc_object_t v48 = v92;
        }
        else if ((void)v147)
        {
          sub_1005D4D64((char *)v91, a2);
          sub_1005DD3B8((uint64_t)a1, v91, (uint64_t)&v142);
          xpc_object_t v48 = v91;
        }
        else
        {
          uint64_t v82 = a1[5];
          if (os_log_type_enabled(v82, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)uint64_t buf = 0;
            _os_log_error_impl((void *)&_mh_execute_header, v82, OS_LOG_TYPE_ERROR, "Unknown message type", buf, 2u);
          }
          sub_1005D4D64(v90, a2);
          *(void *)uint64_t buf = &off_101A1A658;
          memset(&buf[8], 0, 96);
          memset(v154, 0, 32);
          sub_1005D66F8((uint64_t)a1, (uint64_t)v90, (uint64_t)buf);
          sub_100917304((PB::Base *)buf);
          xpc_object_t v48 = (long long *)v90;
        }
        sub_1003C1D74((uint64_t)v48);
      }
      goto LABEL_192;
    }
    if (*((char *)a2 + 23) < 0)
    {
      sub_10004FC84(&v109, *(void **)a2, *((void *)a2 + 1));
    }
    else
    {
      long long v109 = *a2;
      uint64_t v110 = *((void *)a2 + 2);
    }
    char v33 = &v111;
    if (*((char *)a2 + 47) < 0)
    {
      sub_10004FC84(&v111, *((void **)a2 + 3), *((void *)a2 + 4));
    }
    else
    {
      long long v111 = *(long long *)((char *)a2 + 24);
      uint64_t v112 = *((void *)a2 + 5);
    }
    __int16 v113 = *((_WORD *)a2 + 24);
    long long v34 = &v114;
    sub_10002FD9C(&v114, (const void **)v4);
    unint64_t v35 = &v115;
    sub_100119B5C(&v115, (const void **)a2 + 8);
    v116[0] = *((void *)a2 + 9);
    *(void *)((char *)v116 + 6) = *(void *)((char *)a2 + 78);
    long long v36 = a1[5];
    if (os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_DEFAULT, "#I [UpdateProfileReq]", buf, 2u);
    }
    long long v37 = v116;
    long long v38 = (std::__shared_weak_count *)a1[15];
    if (v38)
    {
      long long v39 = std::__shared_weak_count::lock(v38);
      uint64_t v40 = v39;
      if (v39)
      {
        uint64_t v41 = a1[14];
        if (v41)
        {
          unsigned int v151 = 0;
          *(void *)&long long v165 = 0;
          long long v164 = 0uLL;
          unsigned int v42 = *(uint64_t **)(v149 + 8);
          uint64_t v89 = v39;
          if (v42 && v42[1] == 16 && *(void *)(v149 + 16) && (*(unsigned char *)(v149 + 60) & 1) != 0)
          {
            uint64_t v54 = *v42;
            uint64_t v85 = *(void *)(v54 + 8);
            uint64_t v86 = *(const void **)v54;
            uint64_t v84 = v41;
            if ((cellplan::deserializeRemotePlanSimSubscriptionStatus() & 1) == 0)
            {
              uint64_t v55 = a1[5];
              if (os_log_type_enabled(v55, OS_LOG_TYPE_ERROR))
              {
                *(_WORD *)uint64_t buf = 0;
                _os_log_error_impl((void *)&_mh_execute_header, v55, OS_LOG_TYPE_ERROR, "Bad status, assuming 'Unknown'", buf, 2u);
              }
            }
            int v57 = *(uint64_t **)(v149 + 32);
            for (uint64_t i = *(uint64_t **)(v149 + 40); v57 != i; ++v57)
            {
              uint64_t v58 = *v57;
              memset(buf, 0, 88);
              if (sub_1008794D8(v58, (std::string *)buf))
              {
                int v59 = v33;
                uint64_t v60 = v37;
                uint64_t v61 = v35;
                uint64_t v62 = v34;
                uint64_t v63 = i;
                unint64_t v64 = *((void *)&v164 + 1);
                unint64_t v65 = v164;
                if ((void)v164 == *((void *)&v164 + 1))
                {
                  unint64_t v66 = v164;
                }
                else
                {
                  while ((cellplan::operator==() & 1) == 0)
                  {
                    v65 += 88;
                    if (v65 == v64)
                    {
                      unint64_t v65 = v64;
                      break;
                    }
                  }
                  unint64_t v66 = v65;
                  unint64_t v65 = *((void *)&v164 + 1);
                }
                uint64_t i = v63;
                long long v34 = v62;
                unint64_t v35 = v61;
                long long v37 = v60;
                char v33 = v59;
                if (v66 == v65)
                {
                  if (v65 >= (unint64_t)v165)
                  {
                    uint64_t v68 = sub_1003DBFB0((uint64_t *)&v164, (long long *)buf);
                  }
                  else
                  {
                    if ((buf[23] & 0x80000000) != 0)
                    {
                      sub_10004FC84((unsigned char *)v65, *(void **)buf, *(unint64_t *)&buf[8]);
                    }
                    else
                    {
                      long long v67 = *(_OWORD *)buf;
                      *(void *)(v65 + 16) = *(void *)&buf[16];
                      *(_OWORD *)unint64_t v65 = v67;
                    }
                    *(_DWORD *)(v65 + 24) = *(_DWORD *)&buf[24];
                    long long v69 = (unsigned char *)(v65 + 32);
                    if ((buf[55] & 0x80000000) != 0)
                    {
                      sub_10004FC84(v69, *(void **)&buf[32], *(unint64_t *)&buf[40]);
                    }
                    else
                    {
                      long long v70 = *(_OWORD *)&buf[32];
                      *(void *)(v65 + 48) = *(void *)&buf[48];
                      *(_OWORD *)long long v69 = v70;
                    }
                    uint64_t v71 = (unsigned char *)(v65 + 56);
                    if ((buf[79] & 0x80000000) != 0)
                    {
                      sub_10004FC84(v71, *(void **)&buf[56], *(unint64_t *)&buf[64]);
                    }
                    else
                    {
                      long long v72 = *(_OWORD *)&buf[56];
                      *(void *)(v65 + 72) = *(void *)&buf[72];
                      *(_OWORD *)uint64_t v71 = v72;
                    }
                    *(_DWORD *)(v65 + 80) = *(_DWORD *)&buf[80];
                    uint64_t v68 = v65 + 88;
                  }
                  *((void *)&v164 + 1) = v68;
                }
              }
              if ((buf[79] & 0x80000000) != 0) {
                operator delete(*(void **)&buf[56]);
              }
              if ((buf[55] & 0x80000000) != 0) {
                operator delete(*(void **)&buf[32]);
              }
              if ((buf[23] & 0x80000000) != 0) {
                operator delete(*(void **)buf);
              }
            }
            unint64_t v73 = (std::__shared_weak_count *)a1[2];
            if (!v73 || (uint64_t v74 = a1[1], (v75 = std::__shared_weak_count::lock(v73)) == 0)) {
              sub_100088B9C();
            }
            uint64_t v76 = v75;
            atomic_fetch_add_explicit(&v75->__shared_weak_owners_, 1uLL, memory_order_relaxed);
            sub_10004D2C8(v75);
            uint64_t v77 = *(long long **)(v149 + 16);
            uint64_t v83 = v76;
            if (*((char *)v77 + 23) < 0)
            {
              sub_10004FC84(&v159, *(void **)v77, *((void *)v77 + 1));
            }
            else
            {
              long long v78 = *v77;
              *(void *)&long long v160 = *((void *)v77 + 2);
              long long v159 = v78;
            }
            BYTE8(v160) = 1;
            uint64_t v80 = v151;
            uint64_t v168 = 0;
            long long v167 = 0uLL;
            sub_10037C544(&v167, v164, *((uint64_t *)&v164 + 1), 0x2E8BA2E8BA2E8BA3 * ((uint64_t)(*((void *)&v164 + 1) - v164) >> 3));
            *(void *)uint64_t buf = _NSConcreteStackBlock;
            *(void *)&uint8_t buf[8] = 1174405120;
            *(void *)&uint8_t buf[16] = sub_1005DE878;
            *(void *)&unsigned char buf[24] = &unk_1019ECD80;
            *(void *)&uint8_t buf[32] = a1;
            *(void *)&buf[40] = v74;
            *(void *)&buf[48] = v76;
            atomic_fetch_add_explicit(&v76->__shared_weak_owners_, 1uLL, memory_order_relaxed);
            CFTypeRef v155 = v86;
            v156[0] = v85;
            if (SHIBYTE(v110) < 0)
            {
              sub_10004FC84(&buf[56], (void *)v109, *((unint64_t *)&v109 + 1));
            }
            else
            {
              *(_OWORD *)&buf[56] = v109;
              *(void *)&buf[72] = v110;
            }
            if (SHIBYTE(v112) < 0)
            {
              sub_10004FC84(&buf[80], (void *)v111, *((unint64_t *)&v111 + 1));
            }
            else
            {
              *(_OWORD *)&buf[80] = *v33;
              *(void *)&buf[96] = *((void *)v33 + 2);
            }
            *(_WORD *)v154 = v113;
            sub_10002FD9C((const void **)&v154[8], v34);
            sub_100119B5C((const void **)&v154[16], v35);
            *(void *)&v154[24] = *v37;
            *(void *)&v154[30] = *(void *)((char *)v37 + 6);
            (*(void (**)(uint64_t, const void *, uint64_t, long long *, uint64_t, long long *, unsigned char *))(*(void *)v84 + 32))(v84, v86, v85, &v158, v80, &v167, buf);
            uint64_t v152 = (void **)&v167;
            sub_10037AB58(&v152);
            if (SBYTE7(v160) < 0) {
              operator delete((void *)v159);
            }
            sub_1000FE824((const void **)&v154[16]);
            sub_100030068((const void **)&v154[8]);
            uint64_t v40 = v89;
            if ((buf[103] & 0x80000000) != 0) {
              operator delete(*(void **)&buf[80]);
            }
            if ((buf[79] & 0x80000000) != 0) {
              operator delete(*(void **)&buf[56]);
            }
            if (*(void *)&buf[48]) {
              std::__shared_weak_count::__release_weak(*(std::__shared_weak_count **)&buf[48]);
            }
            std::__shared_weak_count::__release_weak(v83);
          }
          else
          {
            *(void *)uint64_t buf = &off_101A1A658;
            memset(&buf[8], 0, 96);
            memset(v154, 0, 32);
            long long v161 = 0u;
            v162[0] = 0u;
            DWORD1(v162[1]) = 0;
            long long v159 = 0u;
            long long v160 = 0u;
            long long v158 = 0u;
            BYTE8(v162[0]) = 2;
            *(void *)((char *)v162 + 12) = 0x50000003CLL;
            sub_100918A20((uint64_t)buf);
            uint64_t v43 = *(void *)&v154[8];
            *(unsigned char *)(*(void *)&v154[8] + 24) |= 1u;
            *(_DWORD *)(v43 + 16) = 13;
            xpc_object_t v44 = a1[5];
            if (os_log_type_enabled(v44, OS_LOG_TYPE_ERROR))
            {
              uint64_t v79 = asString();
              LODWORD(v167) = 136315138;
              *(void *)((char *)&v167 + 4) = v79;
              _os_log_error_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_ERROR, "Sending Error [%s]", (uint8_t *)&v167, 0xCu);
            }
            if (SHIBYTE(v110) < 0)
            {
              sub_10004FC84(&v167, (void *)v109, *((unint64_t *)&v109 + 1));
            }
            else
            {
              long long v167 = v109;
              uint64_t v168 = v110;
            }
            if (SHIBYTE(v112) < 0)
            {
              sub_10004FC84(&v169, (void *)v111, *((unint64_t *)&v111 + 1));
            }
            else
            {
              long long v169 = v111;
              uint64_t v170 = v112;
            }
            __int16 v171 = v113;
            sub_10002FD9C(&v172, &v114);
            sub_100119B5C(&v173, &v115);
            v174[0] = v116[0];
            *(void *)((char *)v174 + 6) = *(void *)((char *)v116 + 6);
            sub_1005D66F8((uint64_t)a1, (uint64_t)&v167, (uint64_t)buf);
            sub_1000FE824(&v173);
            sub_100030068(&v172);
            uint64_t v40 = v89;
            if (SHIBYTE(v170) < 0) {
              operator delete((void *)v169);
            }
            if (SHIBYTE(v168) < 0) {
              operator delete((void *)v167);
            }
            sub_1000FE824((const void **)v162);
            sub_100030068((const void **)&v161 + 1);
            if (SHIBYTE(v160) < 0) {
              operator delete(*((void **)&v159 + 1));
            }
            if (SBYTE7(v159) < 0) {
              operator delete((void *)v158);
            }
            sub_100917304((PB::Base *)buf);
          }
          uint64_t v152 = (void **)&v164;
          sub_10037AB58(&v152);
          goto LABEL_164;
        }
      }
    }
    else
    {
      uint64_t v40 = 0;
    }
    *(void *)uint64_t buf = &off_101A1A658;
    memset(&buf[8], 0, 96);
    memset(v154, 0, 32);
    long long v161 = 0u;
    v162[0] = 0u;
    DWORD1(v162[1]) = 0;
    long long v159 = 0u;
    long long v160 = 0u;
    long long v158 = 0u;
    BYTE8(v162[0]) = 2;
    *(void *)((char *)v162 + 12) = 0x50000003CLL;
    sub_100918A20((uint64_t)buf);
    uint64_t v45 = *(void *)&v154[8];
    *(unsigned char *)(*(void *)&v154[8] + 24) |= 1u;
    *(_DWORD *)(v45 + 16) = 18;
    char v46 = a1[5];
    if (os_log_type_enabled(v46, OS_LOG_TYPE_ERROR))
    {
      uint64_t v52 = asString();
      LODWORD(v167) = 136315138;
      *(void *)((char *)&v167 + 4) = v52;
      _os_log_error_impl((void *)&_mh_execute_header, v46, OS_LOG_TYPE_ERROR, "Sending Error [%s]", (uint8_t *)&v167, 0xCu);
    }
    if (SHIBYTE(v110) < 0)
    {
      sub_10004FC84(&v167, (void *)v109, *((unint64_t *)&v109 + 1));
    }
    else
    {
      long long v167 = v109;
      uint64_t v168 = v110;
    }
    if (SHIBYTE(v112) < 0)
    {
      sub_10004FC84(&v169, (void *)v111, *((unint64_t *)&v111 + 1));
    }
    else
    {
      long long v169 = v111;
      uint64_t v170 = v112;
    }
    __int16 v171 = v113;
    CFTypeRef v172 = v114;
    if (v114) {
      CFRetain(v114);
    }
    CFTypeRef v173 = v115;
    if (v115) {
      CFRetain(v115);
    }
    v174[0] = v116[0];
    *(void *)((char *)v174 + 6) = *(void *)((char *)v116 + 6);
    sub_1005D66F8((uint64_t)a1, (uint64_t)&v167, (uint64_t)buf);
    sub_1000FE824(&v173);
    sub_100030068(&v172);
    if (SHIBYTE(v170) < 0) {
      operator delete((void *)v169);
    }
    if (SHIBYTE(v168) < 0) {
      operator delete((void *)v167);
    }
    sub_1000FE824((const void **)v162);
    sub_100030068((const void **)&v161 + 1);
    if (SHIBYTE(v160) < 0) {
      operator delete(*((void **)&v159 + 1));
    }
    if (SBYTE7(v159) < 0) {
      operator delete((void *)v158);
    }
    sub_100917304((PB::Base *)buf);
    if (!v40)
    {
LABEL_165:
      sub_1000FE824(v35);
      sub_100030068(v34);
      if (SHIBYTE(v112) < 0) {
        operator delete((void *)v111);
      }
      if (SHIBYTE(v110) < 0)
      {
        long long v8 = (void *)v109;
        goto LABEL_191;
      }
      goto LABEL_192;
    }
LABEL_164:
    sub_10004D2C8(v40);
    goto LABEL_165;
  }
  uint64_t v7 = a1[5];
  if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)uint64_t buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "Invalid request message format", buf, 2u);
  }
  if (*((char *)a2 + 23) < 0)
  {
    sub_10004FC84(&__dst, *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long __dst = *a2;
    uint64_t v134 = *((void *)a2 + 2);
  }
  if (*((char *)a2 + 47) < 0)
  {
    sub_10004FC84(&__p, *((void **)a2 + 3), *((void *)a2 + 4));
  }
  else
  {
    long long __p = *(long long *)((char *)a2 + 24);
    uint64_t v136 = *((void *)a2 + 5);
  }
  __int16 v137 = *((_WORD *)a2 + 24);
  sub_10002FD9C(&v138, (const void **)v4);
  sub_100119B5C(&v139, (const void **)a2 + 8);
  v140[0] = *((void *)a2 + 9);
  *(void *)((char *)v140 + 6) = *(void *)((char *)a2 + 78);
  *(void *)uint64_t buf = &off_101A1A658;
  memset(&buf[8], 0, 96);
  memset(v154, 0, 32);
  sub_1005D66F8((uint64_t)a1, (uint64_t)&__dst, (uint64_t)buf);
  sub_100917304((PB::Base *)buf);
  sub_1000FE824(&v139);
  sub_100030068(&v138);
  if (SHIBYTE(v136) < 0) {
    operator delete((void *)__p);
  }
  if (SHIBYTE(v134) < 0)
  {
    long long v8 = (void *)__dst;
LABEL_191:
    operator delete(v8);
  }
LABEL_192:
  sub_100A29100((PB::Base *)&v142);
}

void sub_1005D4880(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, std::__shared_weak_count *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  sub_100917304((PB::Base *)&STACK[0x690]);
  sub_1003C1D74((uint64_t)va);
  sub_100A29100((PB::Base *)&STACK[0x600]);
  _Unwind_Resume(a1);
}

char *sub_1005D4D64(char *__dst, long long *a2)
{
  if (*((char *)a2 + 23) < 0)
  {
    sub_10004FC84(__dst, *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v4 = *a2;
    *((void *)__dst + 2) = *((void *)a2 + 2);
    *(_OWORD *)long long __dst = v4;
  }
  uint64_t v5 = __dst + 24;
  if (*((char *)a2 + 47) < 0)
  {
    sub_10004FC84(v5, *((void **)a2 + 3), *((void *)a2 + 4));
  }
  else
  {
    long long v6 = *(long long *)((char *)a2 + 24);
    *((void *)__dst + 5) = *((void *)a2 + 5);
    *(_OWORD *)uint64_t v5 = v6;
  }
  *((_WORD *)__dst + 24) = *((_WORD *)a2 + 24);
  sub_10002FD9C((const void **)__dst + 7, (const void **)a2 + 7);
  sub_100119B5C((const void **)__dst + 8, (const void **)a2 + 8);
  uint64_t v7 = *((void *)a2 + 9);
  *(void *)(__dst + 78) = *(void *)((char *)a2 + 78);
  *((void *)__dst + 9) = v7;
  return __dst;
}

void sub_1005D4E10(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

const void **sub_1005D4E2C(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 48);
  *(void *)(a1 + 40) = *(void *)(a2 + 40);
  *(void *)(a1 + 48) = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 16), 1uLL, memory_order_relaxed);
  }
  if (*(char *)(a2 + 79) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 56), *(void **)(a2 + 56), *(void *)(a2 + 64));
  }
  else
  {
    long long v5 = *(_OWORD *)(a2 + 56);
    *(void *)(a1 + 72) = *(void *)(a2 + 72);
    *(_OWORD *)(a1 + 56) = v5;
  }
  long long v6 = (unsigned char *)(a1 + 80);
  if (*(char *)(a2 + 103) < 0)
  {
    sub_10004FC84(v6, *(void **)(a2 + 80), *(void *)(a2 + 88));
  }
  else
  {
    long long v7 = *(_OWORD *)(a2 + 80);
    *(void *)(a1 + 96) = *(void *)(a2 + 96);
    *(_OWORD *)long long v6 = v7;
  }
  *(_WORD *)(a1 + 104) = *(_WORD *)(a2 + 104);
  sub_10002FD9C((const void **)(a1 + 112), (const void **)(a2 + 112));
  BOOL result = sub_100119B5C((const void **)(a1 + 120), (const void **)(a2 + 120));
  uint64_t v9 = *(void *)(a2 + 128);
  *(void *)(a1 + 134) = *(void *)(a2 + 134);
  *(void *)(a1 + 128) = v9;
  return result;
}

void sub_1005D4EFC(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 79) < 0) {
    operator delete(*v2);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(v1 + 48);
  if (v4) {
    std::__shared_weak_count::__release_weak(v4);
  }
  _Unwind_Resume(exception_object);
}

void sub_1005D4F2C(uint64_t a1)
{
  sub_1000FE824((const void **)(a1 + 120));
  sub_100030068((const void **)(a1 + 112));
  if (*(char *)(a1 + 103) < 0) {
    operator delete(*(void **)(a1 + 80));
  }
  if (*(char *)(a1 + 79) < 0) {
    operator delete(*(void **)(a1 + 56));
  }
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 48);
  if (v2)
  {
    std::__shared_weak_count::__release_weak(v2);
  }
}

void sub_1005D4FA0(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 256))
  {
    memset(v2, 0, sizeof(v2));
    sub_1003C1BB8(v2, *(void *)(a1 + 136), *(void *)(a1 + 144), (uint64_t)(*(void *)(a1 + 144) - *(void *)(a1 + 136)) >> 6);
    sub_1005D2384(a1, v2);
    uint64_t v3 = v2;
    sub_1002B2AEC((void ***)&v3);
  }
}

void sub_1005D5008(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  sub_1002B2AEC((void ***)va);
  _Unwind_Resume(a1);
}

BOOL sub_1005D5020(uint64_t a1, uint64_t a2)
{
  return sub_1005D1F10(a2);
}

void sub_1005D5028(uint64_t a1, uint64_t *a2)
{
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 1174405120;
  v9[2] = sub_1005D51B8;
  v9[3] = &unk_1019ECB80;
  long long v8 = *(_OWORD *)(a1 + 32);
  long long v10 = v8;
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 48);
  long long v11 = v2;
  if (v2) {
    atomic_fetch_add_explicit(&v2->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  }
  memset(v12, 0, sizeof(v12));
  sub_1003C1BB8(v12, *a2, a2[1], (a2[1] - *a2) >> 6);
  uint64_t v3 = *(std::__shared_weak_count **)(v8 + 16);
  if (!v3 || (uint64_t v4 = *(void ***)(v8 + 8), (v5 = std::__shared_weak_count::lock(v3)) == 0)) {
    sub_100088B9C();
  }
  long long v6 = v5;
  long long v7 = *(NSObject **)(v8 + 24);
  block[0] = _NSConcreteStackBlock;
  block[1] = (void **)1174405120;
  void block[2] = (void **)sub_1005E4BA0;
  block[3] = (void **)&unk_1019ED0C0;
  block[5] = v4;
  uint64_t v14 = v6;
  atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
  block[4] = (void **)v9;
  dispatch_async(v7, block);
  if (v14) {
    sub_10004D2C8(v14);
  }
  sub_10004D2C8(v6);
  block[0] = (void **)v12;
  sub_1002B2AEC(block);
  if (v11) {
    std::__shared_weak_count::__release_weak(v11);
  }
}

void sub_1005D519C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, std::__shared_weak_count *a18)
{
  if (a18) {
    std::__shared_weak_count::__release_weak(a18);
  }
  _Unwind_Resume(exception_object);
}

void sub_1005D51B8(void *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[6];
  if (v2)
  {
    uint64_t v3 = a1[4];
    uint64_t v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      long long v5 = v4;
      if (a1[5])
      {
        memset(v6, 0, sizeof(v6));
        sub_1003C1BB8(v6, a1[7], a1[8], (uint64_t)(a1[8] - a1[7]) >> 6);
        sub_1005D2384(v3, v6);
        long long v7 = v6;
        sub_1002B2AEC((void ***)&v7);
      }
      sub_10004D2C8(v5);
    }
  }
}

void sub_1005D5248(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  sub_1002B2AEC((void ***)va);
  sub_10004D2C8(v4);
  _Unwind_Resume(a1);
}

void sub_1005D5270(uint64_t a1, long long *a2)
{
  long long v3 = *(_OWORD *)(a1 + 32);
  *((unsigned char *)a2 + 72) = 2;
  uint64_t v4 = (void *)a2 + 9;
  v12[0] = _NSConcreteStackBlock;
  v12[1] = 1174405120;
  void v12[2] = sub_1005D54C4;
  void v12[3] = &unk_1019ECBE0;
  long long v11 = (void *)v3;
  long long v13 = v3;
  long long v5 = *(std::__shared_weak_count **)(a1 + 48);
  uint64_t v14 = v5;
  if (v5) {
    atomic_fetch_add_explicit(&v5->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  }
  if (*((char *)a2 + 23) < 0)
  {
    sub_10004FC84(&v15, *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v15 = *a2;
    uint64_t v16 = *((void *)a2 + 2);
  }
  if (*((char *)a2 + 47) < 0)
  {
    sub_10004FC84(&__p, *((void **)a2 + 3), *((void *)a2 + 4));
  }
  else
  {
    long long __p = *(long long *)((char *)a2 + 24);
    uint64_t v18 = *((void *)a2 + 5);
  }
  __int16 v19 = *((_WORD *)a2 + 24);
  sub_10002FD9C(&v20, (const void **)a2 + 7);
  sub_100119B5C(&v21, (const void **)a2 + 8);
  v22[0] = *v4;
  *(void *)((char *)v22 + 6) = *(void *)((char *)v4 + 6);
  long long v6 = (std::__shared_weak_count *)v11[2];
  if (!v6 || (uint64_t v7 = v11[1], (v8 = std::__shared_weak_count::lock(v6)) == 0)) {
    sub_100088B9C();
  }
  uint64_t v9 = v8;
  long long v10 = v11[3];
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  void block[2] = sub_1005E4BA0;
  block[3] = &unk_1019ED0C0;
  block[5] = v7;
  uint64_t v24 = v9;
  atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  block[4] = v12;
  dispatch_async(v10, block);
  if (v24) {
    sub_10004D2C8(v24);
  }
  sub_10004D2C8(v9);
  sub_1000FE824(&v21);
  sub_100030068(&v20);
  if (SHIBYTE(v18) < 0) {
    operator delete((void *)__p);
  }
  if (SHIBYTE(v16) < 0) {
    operator delete((void *)v15);
  }
  if (v14) {
    std::__shared_weak_count::__release_weak(v14);
  }
}

void sub_1005D5490(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, std::__shared_weak_count *a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24)
{
  if (a24 < 0) {
    operator delete(__p);
  }
  if (a18) {
    std::__shared_weak_count::__release_weak(a18);
  }
  _Unwind_Resume(exception_object);
}

void sub_1005D54C4(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 48);
  if (v2)
  {
    long long v3 = *(void **)(a1 + 32);
    uint64_t v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      long long v5 = v4;
      if (*(void *)(a1 + 40))
      {
        if (*(char *)(a1 + 79) < 0)
        {
          sub_10004FC84(v6, *(void **)(a1 + 56), *(void *)(a1 + 64));
        }
        else
        {
          *(_OWORD *)long long v6 = *(_OWORD *)(a1 + 56);
          uint64_t v7 = *(void *)(a1 + 72);
        }
        if (*(char *)(a1 + 103) < 0)
        {
          sub_10004FC84(&__p, *(void **)(a1 + 80), *(void *)(a1 + 88));
        }
        else
        {
          long long __p = *(_OWORD *)(a1 + 80);
          uint64_t v9 = *(void *)(a1 + 96);
        }
        __int16 v10 = *(_WORD *)(a1 + 104);
        sub_10002FD9C(&v11, (const void **)(a1 + 112));
        sub_100119B5C(&v12, (const void **)(a1 + 120));
        v13[0] = *(void *)(a1 + 128);
        *(void *)((char *)v13 + 6) = *(void *)(a1 + 134);
        sub_1005D2A54(v3, (long long *)v6);
        sub_1000FE824(&v12);
        sub_100030068(&v11);
        if (SHIBYTE(v9) < 0) {
          operator delete((void *)__p);
        }
        if (SHIBYTE(v7) < 0) {
          operator delete(v6[0]);
        }
      }
      sub_10004D2C8(v5);
    }
  }
}

void sub_1005D55F8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  sub_10004D2C8(v14);
  _Unwind_Resume(a1);
}

BOOL sub_1005D5634(uint64_t a1, uint64_t a2)
{
  return sub_1005D1F10(a2);
}

void sub_1005D563C(uint64_t a1, uint64_t *a2)
{
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 1174405120;
  v9[2] = sub_1005D57CC;
  v9[3] = &unk_1019ECC60;
  long long v8 = *(_OWORD *)(a1 + 32);
  long long v10 = v8;
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 48);
  long long v11 = v2;
  if (v2) {
    atomic_fetch_add_explicit(&v2->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  }
  memset(v12, 0, sizeof(v12));
  sub_1003C1BB8(v12, *a2, a2[1], (a2[1] - *a2) >> 6);
  long long v3 = *(std::__shared_weak_count **)(v8 + 16);
  if (!v3 || (uint64_t v4 = *(void ***)(v8 + 8), (v5 = std::__shared_weak_count::lock(v3)) == 0)) {
    sub_100088B9C();
  }
  long long v6 = v5;
  uint64_t v7 = *(NSObject **)(v8 + 24);
  block[0] = _NSConcreteStackBlock;
  block[1] = (void **)1174405120;
  void block[2] = (void **)sub_1005E4BA0;
  block[3] = (void **)&unk_1019ED0C0;
  block[5] = v4;
  uint64_t v14 = v6;
  atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
  block[4] = (void **)v9;
  dispatch_async(v7, block);
  if (v14) {
    sub_10004D2C8(v14);
  }
  sub_10004D2C8(v6);
  block[0] = (void **)v12;
  sub_1002B2AEC(block);
  if (v11) {
    std::__shared_weak_count::__release_weak(v11);
  }
}

void sub_1005D57B0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, std::__shared_weak_count *a18)
{
  if (a18) {
    std::__shared_weak_count::__release_weak(a18);
  }
  _Unwind_Resume(exception_object);
}

void sub_1005D57CC(void *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[6];
  if (v2)
  {
    uint64_t v3 = a1[4];
    uint64_t v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      long long v5 = v4;
      if (a1[5])
      {
        uint64_t v7 = 0;
        uint64_t v8 = 0;
        uint64_t v9 = 0;
        sub_1003C1BB8(&v7, a1[7], a1[8], (uint64_t)(a1[8] - a1[7]) >> 6);
        long long v6 = *(NSObject **)(v3 + 40);
        if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)uint64_t buf = 134217984;
          *(void *)&uint8_t buf[4] = (v8 - v7) >> 6;
          _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Number of linked devices: %lu", buf, 0xCu);
        }
        *(void *)uint64_t buf = &v7;
        sub_1002B2AEC((void ***)buf);
      }
      sub_10004D2C8(v5);
    }
  }
}

void sub_1005D58D0(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_1005D58E4(uint64_t a1, long long *a2)
{
  long long v3 = *(_OWORD *)(a1 + 32);
  *((unsigned char *)a2 + 72) = 1;
  uint64_t v4 = (void *)a2 + 9;
  v12[0] = _NSConcreteStackBlock;
  v12[1] = 1174405120;
  void v12[2] = sub_1005D5B38;
  void v12[3] = &unk_1019ECCC0;
  long long v11 = (void *)v3;
  long long v13 = v3;
  long long v5 = *(std::__shared_weak_count **)(a1 + 48);
  uint64_t v14 = v5;
  if (v5) {
    atomic_fetch_add_explicit(&v5->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  }
  if (*((char *)a2 + 23) < 0)
  {
    sub_10004FC84(&v15, *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v15 = *a2;
    uint64_t v16 = *((void *)a2 + 2);
  }
  if (*((char *)a2 + 47) < 0)
  {
    sub_10004FC84(&__p, *((void **)a2 + 3), *((void *)a2 + 4));
  }
  else
  {
    long long __p = *(long long *)((char *)a2 + 24);
    uint64_t v18 = *((void *)a2 + 5);
  }
  __int16 v19 = *((_WORD *)a2 + 24);
  sub_10002FD9C(&v20, (const void **)a2 + 7);
  sub_100119B5C(&v21, (const void **)a2 + 8);
  v22[0] = *v4;
  *(void *)((char *)v22 + 6) = *(void *)((char *)v4 + 6);
  long long v6 = (std::__shared_weak_count *)v11[2];
  if (!v6 || (uint64_t v7 = v11[1], (v8 = std::__shared_weak_count::lock(v6)) == 0)) {
    sub_100088B9C();
  }
  uint64_t v9 = v8;
  long long v10 = v11[3];
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  void block[2] = sub_1005E4BA0;
  block[3] = &unk_1019ED0C0;
  block[5] = v7;
  uint64_t v24 = v9;
  atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  block[4] = v12;
  dispatch_async(v10, block);
  if (v24) {
    sub_10004D2C8(v24);
  }
  sub_10004D2C8(v9);
  sub_1000FE824(&v21);
  sub_100030068(&v20);
  if (SHIBYTE(v18) < 0) {
    operator delete((void *)__p);
  }
  if (SHIBYTE(v16) < 0) {
    operator delete((void *)v15);
  }
  if (v14) {
    std::__shared_weak_count::__release_weak(v14);
  }
}

void sub_1005D5B04(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, std::__shared_weak_count *a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24)
{
  if (a24 < 0) {
    operator delete(__p);
  }
  if (a18) {
    std::__shared_weak_count::__release_weak(a18);
  }
  _Unwind_Resume(exception_object);
}

void sub_1005D5B38(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 48);
  if (v2)
  {
    long long v3 = *(void **)(a1 + 32);
    uint64_t v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      long long v5 = v4;
      if (*(void *)(a1 + 40))
      {
        if (*(char *)(a1 + 79) < 0)
        {
          sub_10004FC84(v6, *(void **)(a1 + 56), *(void *)(a1 + 64));
        }
        else
        {
          *(_OWORD *)long long v6 = *(_OWORD *)(a1 + 56);
          uint64_t v7 = *(void *)(a1 + 72);
        }
        if (*(char *)(a1 + 103) < 0)
        {
          sub_10004FC84(&__p, *(void **)(a1 + 80), *(void *)(a1 + 88));
        }
        else
        {
          long long __p = *(_OWORD *)(a1 + 80);
          uint64_t v9 = *(void *)(a1 + 96);
        }
        __int16 v10 = *(_WORD *)(a1 + 104);
        sub_10002FD9C(&v11, (const void **)(a1 + 112));
        sub_100119B5C(&v12, (const void **)(a1 + 120));
        v13[0] = *(void *)(a1 + 128);
        *(void *)((char *)v13 + 6) = *(void *)(a1 + 134);
        sub_1005D2A54(v3, (long long *)v6);
        sub_1000FE824(&v12);
        sub_100030068(&v11);
        if (SHIBYTE(v9) < 0) {
          operator delete((void *)__p);
        }
        if (SHIBYTE(v7) < 0) {
          operator delete(v6[0]);
        }
      }
      sub_10004D2C8(v5);
    }
  }
}

void sub_1005D5C6C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  sub_10004D2C8(v14);
  _Unwind_Resume(a1);
}

void sub_1005D5CA8(uint64_t a1, uint64_t *a2, unsigned char *a3)
{
  void (***v25)(CFStringRef *__return_ptr, void, long long *);
  char v26;
  NSObject *v27;
  const std::string *v28;
  CFDictionaryRef v29;
  int v30;
  uint64_t (*v31)(uint64_t);
  CFDictionaryRef Value;
  CFDictionaryRef v33;
  CFTypeID v34;
  unint64_t v35;
  unint64_t v36;
  unint64_t v37;
  char *v38;
  char *v39;
  unint64_t v40;
  char v41;
  char *v42;
  uint64_t v43;
  CFDataRef v44;
  CFDataRef v45;
  CFTypeID v46;
  unint64_t v47;
  char v48;
  char *v49;
  uint64_t v50;
  uint64_t v51;
  int v52;
  NSObject *v53;
  NSObject *v54;
  unint64_t v55;
  char *v56;
  void *v57;
  void *v58;
  void *key;
  unsigned char *v60;
  char v61;
  std::__shared_weak_count *v62;
  char *v63;
  char *v64;
  char *v65;
  uint8_t buf[8];
  long long v67;
  long long v68;
  long long v69;
  uint64_t v70;
  long long v71;
  long long v72;
  uint64_t (**v73)(PB::Base *);
  long long v74;
  long long v75;
  long long v76;
  uint64_t v77;
  long long __dst;
  long long v79;
  long long __p;
  long long v81;
  CFStringRef v82;
  std::__shared_weak_count *v83;
  CFDictionaryRef v84;
  CFDictionaryRef v85;
  unint64_t v86;
  long long v87;
  long long v88;
  uint64_t v89;

  uint64_t v4 = *(long long **)(a1 + 136);
  if (v4 != *(long long **)(a1 + 144))
  {
    long long __p = 0u;
    uint64_t v81 = 0u;
    long long __dst = 0u;
    uint64_t v79 = 0u;
    if (*((char *)v4 + 23) < 0)
    {
      sub_10004FC84(&__dst, *(void **)v4, *((void *)v4 + 1));
    }
    else
    {
      long long v7 = *v4;
      *(void *)&uint64_t v79 = *((void *)v4 + 2);
      long long __dst = v7;
    }
    LOWORD(v9) = *((_WORD *)v4 + 12);
    WORD4(v79) = v9;
    if (*((char *)v4 + 55) < 0)
    {
      sub_10004FC84(&__p, *((void **)v4 + 4), *((void *)v4 + 5));
      int v9 = BYTE8(v79);
    }
    else
    {
      int v9 = v9;
      long long v10 = v4[2];
      *(void *)&uint64_t v81 = *((void *)v4 + 6);
      long long __p = v10;
    }
    int v11 = *((_DWORD *)v4 + 14);
    BYTE12(v81) = *((unsigned char *)v4 + 60);
    DWORD2(v81) = v11;
    if (!v9 && *(unsigned char *)(a1 + 128) != 2)
    {
      uint64_t v12 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "Device cannot send message", buf, 2u);
      }
LABEL_83:
      if (SBYTE7(v81) < 0) {
        operator delete((void *)__p);
      }
      if (SBYTE7(v79) < 0) {
        operator delete((void *)__dst);
      }
      return;
    }
    uint64_t v60 = a3;
    uint64_t v74 = 0u;
    uint64_t v75 = 0u;
    uint64_t v76 = 0u;
    unint64_t v73 = &off_101A71018;
    uint64_t v77 = 0;
    sub_100F37C3C((uint64_t)&v73);
    uint64_t v13 = *a2;
    uint64_t v14 = a2[1];
    if (v13 == v14)
    {
LABEL_74:
      int v51 = v77;
      if (*(void *)(v77 + 8) == *(void *)(v77 + 16))
      {
        uint64_t v54 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v54, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)uint64_t buf = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v54, OS_LOG_TYPE_ERROR, "No valid card found, skip sending VinylInfoInd", buf, 2u);
        }
      }
      else
      {
        if (*v60)
        {
          uint64_t v52 = v60[1];
          *(unsigned char *)(v77 + 36) |= 1u;
          *(_DWORD *)(v51 + 32) = v52;
        }
        uint64_t v53 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v53, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)uint64_t buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v53, OS_LOG_TYPE_DEFAULT, "#I [VinylInfoInd]", buf, 2u);
        }
        sub_1005E2798(a1, (const std::string *)&__dst, (uint64_t)&v73);
      }
      sub_100F37268((PB::Base *)&v73);
      goto LABEL_83;
    }
    key = (void *)kCTProvisioningURL;
    uint64_t v58 = (void *)kCTWebSheetURL;
    int v57 = (void *)kCTWebSheetPostData;
    while (!*(_DWORD *)v13)
    {
      uint64_t v27 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "#I Invalid card type - not sending", buf, 2u);
      }
      v13 += 88;
      if (v13 == v14) {
        goto LABEL_74;
      }
    }
    uint64_t v71 = 0u;
    long long v72 = 0u;
    unint64_t v65 = 0;
    *(void *)uint64_t buf = off_1019ED3F0;
    long long v67 = 0u;
    uint64_t v68 = 0u;
    long long v69 = 0u;
    long long v70 = 0;
    uint64_t v63 = 0;
    unint64_t v64 = 0;
    if (*(unsigned char *)(a1 + 128) == 2 && *(unsigned char *)(v13 + 80))
    {
      uint64_t v16 = *(void *)(v13 + 56);
      uint64_t v15 = *(void *)(v13 + 64);
      if (v16 != v15)
      {
        do
        {
          if (*(unsigned char *)(v16 + 89)) {
            goto LABEL_23;
          }
          v16 += 216;
        }
        while (v16 != v15);
        uint64_t v16 = *(void *)(v13 + 64);
      }
LABEL_23:
      ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)(a1 + 96));
      uint64_t v18 = ServiceMap;
      if ((v19 & 0x8000000000000000) != 0)
      {
        OsLogContext v20 = (unsigned __int8 *)(v19 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v21 = 5381;
        do
        {
          unint64_t v19 = v21;
          unsigned int v22 = *v20++;
          uint64_t v21 = (33 * v21) ^ v22;
        }
        while (v22);
      }
      std::mutex::lock(ServiceMap);
      uint64_t v86 = v19;
      uint64_t v23 = sub_10004D37C(&v18[1].__m_.__sig, &v86);
      if (v23)
      {
        unint64_t v25 = (void (***)(CFStringRef *__return_ptr, void, long long *))v23[3];
        uint64_t v24 = (std::__shared_weak_count *)v23[4];
        if (v24)
        {
          atomic_fetch_add_explicit(&v24->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v18);
          atomic_fetch_add_explicit(&v24->__shared_owners_, 1uLL, memory_order_relaxed);
          uint64_t v62 = v24;
          sub_10004D2C8(v24);
          if (v16 == *(void *)(v13 + 64) || !v25)
          {
LABEL_71:
            sub_10004D2C8(v62);
            goto LABEL_72;
          }
          uint64_t v26 = 0;
LABEL_37:
          uint64_t v61 = v26;
          uint64_t v84 = 0;
          long long v28 = (const std::string *)(v16 + 16);
          if (*(char *)(v16 + 39) < 0)
          {
            sub_10004FC84(&v88, *(void **)(v16 + 16), *(void *)(v16 + 24));
          }
          else
          {
            uint64_t v88 = *(_OWORD *)&v28->__r_.__value_.__l.__data_;
            uint64_t v89 = *(void *)(v16 + 32);
          }
          (**v25)(&v82, v25, &v88);
          (*((void (**)(unint64_t *__return_ptr))v82->isa + 5))(&v86);
          uint64_t v29 = v84;
          uint64_t v84 = (const __CFDictionary *)v87;
          uint64_t v85 = v29;
          *(void *)&uint64_t v87 = 0;
          sub_100057D78((const void **)&v85);
          unint64_t v30 = BYTE8(v87);
          sub_100057D78((const void **)&v87);
          if (v83) {
            sub_10004D2C8(v83);
          }
          if (SHIBYTE(v89) < 0)
          {
            operator delete((void *)v88);
            if (!v30) {
              goto LABEL_70;
            }
          }
          else if (!v30)
          {
            goto LABEL_70;
          }
          if (v84) {
            uint64_t v31 = sub_100080778;
          }
          else {
            uint64_t v31 = 0;
          }
          if (v31)
          {
            Value = (const __CFDictionary *)CFDictionaryGetValue(v84, key);
            char v33 = Value;
            if (Value)
            {
              long long v34 = CFGetTypeID(Value);
              if (v34 == CFDictionaryGetTypeID())
              {
                unint64_t v35 = 0xCCCCCCCCCCCCCCCDLL * ((v64 - v63) >> 4);
                long long v36 = v35 + 1;
                if (v35 + 1 > 0x333333333333333) {
                  sub_10006A748();
                }
                if (0x999999999999999ALL * ((v65 - v63) >> 4) > v36) {
                  long long v36 = 0x999999999999999ALL * ((v65 - v63) >> 4);
                }
                if (0xCCCCCCCCCCCCCCCDLL * ((v65 - v63) >> 4) >= 0x199999999999999) {
                  long long v37 = 0x333333333333333;
                }
                else {
                  long long v37 = v36;
                }
                if (v37)
                {
                  if (v37 > 0x333333333333333) {
                    sub_10006A7CC();
                  }
                  uint64_t v55 = v37;
                  long long v38 = (char *)operator new(80 * v37);
                  long long v37 = v55;
                  unint64_t v35 = 0xCCCCCCCCCCCCCCCDLL * ((v64 - v63) >> 4);
                }
                else
                {
                  long long v38 = 0;
                }
                long long v39 = &v38[80 * v35];
                *((_OWORD *)v39 + 3) = 0u;
                *((_OWORD *)v39 + 4) = 0u;
                *((_OWORD *)v39 + 1) = 0u;
                *((_OWORD *)v39 + 2) = 0u;
                *(_OWORD *)long long v39 = 0u;
                uint64_t v63 = v39;
                unint64_t v65 = &v38[80 * v37];
                unint64_t v64 = v39 + 80;
                uint64_t v56 = v64;
                std::string::operator=((std::string *)v39, v28);
                CFDictionaryGetValue(v33, v58);
                uint64_t v86 = 0;
                uint64_t v87 = 0uLL;
                ctu::cf::assign();
                uint64_t v40 = v86;
                *(void *)&uint64_t v88 = v87;
                *(void *)((char *)&v88 + 7) = *(void *)((char *)&v87 + 7);
                uint64_t v41 = HIBYTE(v87);
                unsigned int v42 = v64;
                if (*(v64 - 33) < 0)
                {
                  operator delete(*((void **)v64 - 7));
                  unsigned int v42 = v64;
                }
                *((void *)v42 - 7) = v40;
                uint64_t v43 = v88;
                *(void *)(v42 - 41) = *(void *)((char *)&v88 + 7);
                *((void *)v42 - 6) = v43;
                *(v42 - 33) = v41;
                xpc_object_t v44 = (const __CFData *)CFDictionaryGetValue(v33, v57);
                uint64_t v45 = v44;
                if (v44)
                {
                  char v46 = CFGetTypeID(v44);
                  if (v46 == CFDataGetTypeID())
                  {
                    uint64_t v82 = CFStringCreateFromExternalRepresentation(0, v45, 0x600u);
                    uint64_t v86 = 0;
                    uint64_t v87 = 0uLL;
                    ctu::cf::assign();
                    uint64_t v47 = v86;
                    *(void *)&uint64_t v88 = v87;
                    *(void *)((char *)&v88 + 7) = *(void *)((char *)&v87 + 7);
                    xpc_object_t v48 = HIBYTE(v87);
                    uint64_t v49 = v56;
                    if (*(v56 - 9) < 0)
                    {
                      operator delete(*((void **)v56 - 4));
                      uint64_t v49 = v56;
                    }
                    *((void *)v49 - 4) = v47;
                    uint64_t v50 = v88;
                    *(void *)(v49 - 17) = *(void *)((char *)&v88 + 7);
                    *((void *)v49 - 3) = v50;
                    *(v49 - 9) = v48;
                    sub_1000558F4((const void **)&v82);
                  }
                }
              }
            }
          }
LABEL_70:
          sub_100057D78((const void **)&v84);
          if (v61) {
            goto LABEL_72;
          }
          goto LABEL_71;
        }
      }
      else
      {
        unint64_t v25 = 0;
      }
      std::mutex::unlock(v18);
      if (v16 != *(void *)(v13 + 64) && v25)
      {
        uint64_t v62 = 0;
        uint64_t v26 = 1;
        goto LABEL_37;
      }
    }
LABEL_72:
    LOBYTE(v86) = 0;
    sub_100878924((int *)v13, (uint64_t)&v63, (uint64_t)&v86, (uint64_t)buf);
    sub_1005E47DC(&v86);
    sub_1005E1110();
  }
  uint64_t v8 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)uint64_t buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "No devices found", buf, 2u);
  }
}

void sub_1005D65E4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, int a16, char a17, std::__shared_weak_count *a18, char a19, uint64_t a20,uint64_t a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,char a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,void *__p,uint64_t a43,int a44,__int16 a45,char a46,char a47)
{
  if (*(char *)(v47 - 193) < 0) {
    operator delete(*(void **)(v47 - 216));
  }
  sub_1000558F4((const void **)(v47 - 248));
  sub_100057D78((const void **)(v47 - 232));
  if ((a17 & 1) == 0) {
    sub_10004D2C8(a18);
  }
  *(void *)(v47 - 128) = &a19;
  sub_1005E4864((void ***)(v47 - 128));
  sub_1005EA108((uint64_t)&a22);
  sub_100F37268((PB::Base *)&a34);
  sub_100087740((uint64_t)&__p);
  _Unwind_Resume(a1);
}

void sub_1005D66F8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(_OWORD *)CFTypeRef cf = 0u;
  *(_OWORD *)uint64_t v23 = 0u;
  *(_DWORD *)&v23[20] = 0;
  memset(v21, 0, sizeof(v21));
  unsigned char v23[8] = 2;
  *(void *)&v23[12] = 0x50000003CLL;
  std::string::operator=(v21, (const std::string *)a2);
  std::string::operator=(&v21[1], (const std::string *)(a2 + 24));
  LOWORD(cf[0]) = *(_WORD *)(a2 + 48);
  int v6 = *(unsigned __int8 *)(a1 + 128);
  if (v6 == 2)
  {
    char v7 = *(unsigned char *)(a2 + 72);
  }
  else if (v6 == 1)
  {
    char v7 = 0;
  }
  else
  {
    char v7 = 2;
  }
  unsigned char v23[8] = v7;
  uint64_t v24 = 0;
  unint64_t v25 = 0;
  uint64_t v26 = 0;
  PB::Writer::Writer((PB::Writer *)&v24);
  (*(void (**)(uint64_t, const UInt8 **))(*(void *)a3 + 24))(a3, &v24);
  if (v24 == v25) {
    CFDataRef v8 = 0;
  }
  else {
    CFDataRef v8 = CFDataCreate(kCFAllocatorDefault, v25, v24 - v25);
  }
  CFDataRef v20 = v8;
  PB::Writer::~Writer((PB::Writer *)&v24);
  uint64_t v24 = (const UInt8 *)cf[1];
  cf[1] = v20;
  CFDataRef v20 = 0;
  sub_100030068(v9);
  sub_100030068((const void **)&v20);
  if (*(unsigned char *)(a1 + 128) != 2) {
    goto LABEL_17;
  }
  if (v23[8] != 1)
  {
    uint64_t v11 = *(void *)(a1 + 64);
    uint64_t v10 = *(void *)(a1 + 72);
    if (!v10) {
      goto LABEL_15;
    }
    goto LABEL_14;
  }
  uint64_t v11 = *(void *)(a1 + 80);
  uint64_t v10 = *(void *)(a1 + 88);
  if (v10) {
LABEL_14:
  }
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v10 + 8), 1uLL, memory_order_relaxed);
LABEL_15:
  uint64_t v12 = *(std::__shared_weak_count **)(a1 + 56);
  *(void *)(a1 + 48) = v11;
  *(void *)(a1 + 56) = v10;
  if (v12) {
    sub_10004D2C8(v12);
  }
LABEL_17:
  uint64_t v13 = *(void *)(a1 + 48);
  if (SHIBYTE(v21[0].__r_.__value_.__r.__words[2]) < 0) {
    sub_10004FC84(&v14, v21[0].__r_.__value_.__l.__data_, v21[0].__r_.__value_.__l.__size_);
  }
  else {
    std::string v14 = v21[0];
  }
  if (SHIBYTE(v21[1].__r_.__value_.__r.__words[2]) < 0) {
    sub_10004FC84(&__p, v21[1].__r_.__value_.__l.__data_, v21[1].__r_.__value_.__l.__size_);
  }
  else {
    std::string __p = v21[1];
  }
  __int16 v16 = (__int16)cf[0];
  CFTypeRef v17 = cf[1];
  if (cf[1]) {
    CFRetain(cf[1]);
  }
  uint64_t v18 = *(const void **)v23;
  if (*(void *)v23) {
    CFRetain(*(CFTypeRef *)v23);
  }
  v19[0] = *(void *)&v23[8];
  *(void *)((char *)v19 + 6) = *(void *)&v23[14];
  (*(void (**)(uint64_t, std::string *, void))(*(void *)v13 + 32))(v13, &v14, 0);
  sub_1000FE824(&v18);
  sub_100030068(&v17);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v14.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v14.__r_.__value_.__l.__data_);
  }
  sub_1000FE824((const void **)v23);
  sub_100030068(&cf[1]);
  if (SHIBYTE(v21[1].__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v21[1].__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v21[0].__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v21[0].__r_.__value_.__l.__data_);
  }
}

void sub_1005D69BC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,char a24)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  sub_1003C1D74((uint64_t)&a24);
  _Unwind_Resume(a1);
}

void sub_1005D6A18(void *a1, long long *a2, uint64_t a3)
{
  int v6 = a1[5];
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I [DeleteProfileReq]", buf, 2u);
  }
  char v7 = (std::__shared_weak_count *)a1[15];
  if (v7)
  {
    CFDataRef v8 = std::__shared_weak_count::lock(v7);
    if (v8)
    {
      uint64_t v9 = a1[14];
      if (v9)
      {
        *(_OWORD *)long long __src = 0u;
        long long v66 = 0u;
        *(_OWORD *)unint64_t v64 = 0u;
        sub_1005DE3DC((uint64_t)v64);
        uint64_t v10 = *(void *)(a3 + 16);
        uint64_t v11 = *(void *)(v10 + 8);
        if (v11 && *(void *)(v11 + 8) == 16)
        {
          uint64_t v12 = *(uint64_t **)v11;
          uint64_t v13 = *v12;
          uint64_t v14 = v12[1];
          uint64_t v15 = *(long long **)(v10 + 16);
          if (v15)
          {
            if (*((char *)v15 + 23) < 0)
            {
              sub_10004FC84(&buf[16], *(void **)v15, *((void *)v15 + 1));
            }
            else
            {
              long long v16 = *v15;
              *(void *)&uint8_t buf[32] = *((void *)v15 + 2);
              *(_OWORD *)&uint8_t buf[16] = v16;
            }
            char v21 = 1;
            LOBYTE(v68) = 1;
            *(_OWORD *)unint64_t v64 = *(_OWORD *)buf;
            if (SBYTE7(v66) < 0)
            {
              operator delete(__src[0]);
              char v21 = v68;
            }
            *(_OWORD *)long long __src = *(_OWORD *)&buf[16];
            *(void *)&long long v66 = *(void *)&buf[32];
          }
          else
          {
            sub_1002EF958((uint64_t)buf);
            *(_OWORD *)unint64_t v64 = *(_OWORD *)buf;
            if (SBYTE7(v66) < 0) {
              operator delete(__src[0]);
            }
            *(_OWORD *)long long __src = *(_OWORD *)&buf[16];
            *(void *)&long long v66 = *(void *)&buf[32];
            char v21 = v68;
          }
          BYTE8(v66) = v21;
          unsigned int v22 = (std::__shared_weak_count *)a1[2];
          if (!v22 || (uint64_t v23 = a1[1], (v24 = std::__shared_weak_count::lock(v22)) == 0)) {
            sub_100088B9C();
          }
          unint64_t v25 = v24;
          atomic_fetch_add_explicit(&v24->__shared_weak_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v24);
          long long v58 = *(_OWORD *)v64;
          if (SBYTE7(v66) < 0)
          {
            sub_10004FC84(&v59, __src[0], (unint64_t)__src[1]);
          }
          else
          {
            long long v59 = *(_OWORD *)__src;
            uint64_t v60 = v66;
          }
          char v61 = BYTE8(v66);
          v48[0] = _NSConcreteStackBlock;
          v48[1] = 1174405120;
          v48[2] = sub_1005DEF00;
          v48[3] = &unk_1019ECDE0;
          v48[4] = a1;
          v48[5] = v23;
          uint64_t v49 = v25;
          atomic_fetch_add_explicit(&v25->__shared_weak_owners_, 1uLL, memory_order_relaxed);
          v57[2] = v13;
          v57[3] = v14;
          if (*((char *)a2 + 23) < 0)
          {
            sub_10004FC84(&v50, *(void **)a2, *((void *)a2 + 1));
          }
          else
          {
            long long v50 = *a2;
            uint64_t v51 = *((void *)a2 + 2);
          }
          if (*((char *)a2 + 47) < 0)
          {
            sub_10004FC84(&v52, *((void **)a2 + 3), *((void *)a2 + 4));
          }
          else
          {
            long long v52 = *(long long *)((char *)a2 + 24);
            uint64_t v53 = *((void *)a2 + 5);
          }
          __int16 v54 = *((_WORD *)a2 + 24);
          sub_10002FD9C(&v55, (const void **)a2 + 7);
          sub_100119B5C(&v56, (const void **)a2 + 8);
          v57[0] = *((void *)a2 + 9);
          *(void *)((char *)v57 + 6) = *(void *)((char *)a2 + 78);
          (*(void (**)(uint64_t, uint64_t, uint64_t, long long *, void *))(*(void *)v9 + 24))(v9, v13, v14, &v58, v48);
          if (SHIBYTE(v60) < 0) {
            operator delete((void *)v59);
          }
          sub_1000FE824(&v56);
          sub_100030068(&v55);
          if (SHIBYTE(v53) < 0) {
            operator delete((void *)v52);
          }
          if (SHIBYTE(v51) < 0) {
            operator delete((void *)v50);
          }
          if (v49) {
            std::__shared_weak_count::__release_weak(v49);
          }
          std::__shared_weak_count::__release_weak(v25);
        }
        else
        {
          *(void *)uint64_t buf = &off_101A1A658;
          memset(&buf[8], 0, 32);
          long long v68 = 0u;
          long long v69 = 0u;
          long long v70 = 0u;
          long long v71 = 0u;
          long long v72 = 0u;
          long long v73 = 0u;
          long long v45 = 0u;
          *(_OWORD *)char v46 = 0u;
          int v47 = 0;
          *(_OWORD *)uint64_t v43 = 0u;
          long long v44 = 0u;
          *(_OWORD *)unsigned int v42 = 0u;
          v46[8] = 2;
          *(void *)&v46[12] = 0x50000003CLL;
          sub_10091881C((uint64_t)buf);
          uint64_t v19 = *(void *)&buf[16];
          *(unsigned char *)(*(void *)&buf[16] + 24) |= 1u;
          *(_DWORD *)(v19 + 16) = 13;
          CFDataRef v20 = a1[5];
          if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)uint64_t v62 = 136315138;
            uint64_t v63 = asString();
            _os_log_error_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, "Sending Error [%s]", v62, 0xCu);
          }
          if (*((char *)a2 + 23) < 0)
          {
            sub_10004FC84(v26, *(void **)a2, *((void *)a2 + 1));
          }
          else
          {
            *(_OWORD *)uint64_t v26 = *a2;
            uint64_t v27 = *((void *)a2 + 2);
          }
          if (*((char *)a2 + 47) < 0)
          {
            sub_10004FC84(&v28, *((void **)a2 + 3), *((void *)a2 + 4));
          }
          else
          {
            long long v28 = *(long long *)((char *)a2 + 24);
            uint64_t v29 = *((void *)a2 + 5);
          }
          __int16 v30 = *((_WORD *)a2 + 24);
          sub_10002FD9C(&v31, (const void **)a2 + 7);
          sub_100119B5C(&v32, (const void **)a2 + 8);
          v33[0] = *((void *)a2 + 9);
          *(void *)((char *)v33 + 6) = *(void *)((char *)a2 + 78);
          sub_1005D66F8((uint64_t)a1, (uint64_t)v26, (uint64_t)buf);
          sub_1000FE824(&v32);
          sub_100030068(&v31);
          if (SHIBYTE(v29) < 0) {
            operator delete((void *)v28);
          }
          if (SHIBYTE(v27) < 0) {
            operator delete(v26[0]);
          }
          sub_1000FE824((const void **)v46);
          sub_100030068((const void **)&v45 + 1);
          if (SHIBYTE(v44) < 0) {
            operator delete(v43[1]);
          }
          if (SHIBYTE(v43[0]) < 0) {
            operator delete(v42[0]);
          }
          sub_100917304((PB::Base *)buf);
        }
        if (SBYTE7(v66) < 0) {
          operator delete(__src[0]);
        }
LABEL_76:
        sub_10004D2C8(v8);
        return;
      }
    }
  }
  else
  {
    CFDataRef v8 = 0;
  }
  *(void *)uint64_t buf = &off_101A1A658;
  memset(&buf[8], 0, 32);
  long long v68 = 0u;
  long long v69 = 0u;
  long long v70 = 0u;
  long long v71 = 0u;
  long long v72 = 0u;
  long long v73 = 0u;
  long long v45 = 0u;
  *(_OWORD *)char v46 = 0u;
  int v47 = 0;
  *(_OWORD *)uint64_t v43 = 0u;
  long long v44 = 0u;
  *(_OWORD *)unsigned int v42 = 0u;
  v46[8] = 2;
  *(void *)&v46[12] = 0x50000003CLL;
  sub_10091881C((uint64_t)buf);
  uint64_t v17 = *(void *)&buf[16];
  *(unsigned char *)(*(void *)&buf[16] + 24) |= 1u;
  *(_DWORD *)(v17 + 16) = 18;
  uint64_t v18 = a1[5];
  if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)unint64_t v64 = 136315138;
    *(void *)&v64[4] = asString();
    _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "Sending Error [%s]", v64, 0xCu);
  }
  if (*((char *)a2 + 23) < 0)
  {
    sub_10004FC84(__dst, *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    *(_OWORD *)long long __dst = *a2;
    uint64_t v35 = *((void *)a2 + 2);
  }
  if (*((char *)a2 + 47) < 0)
  {
    sub_10004FC84(&__p, *((void **)a2 + 3), *((void *)a2 + 4));
  }
  else
  {
    long long __p = *(long long *)((char *)a2 + 24);
    uint64_t v37 = *((void *)a2 + 5);
  }
  __int16 v38 = *((_WORD *)a2 + 24);
  sub_10002FD9C(&v39, (const void **)a2 + 7);
  sub_100119B5C(&v40, (const void **)a2 + 8);
  v41[0] = *((void *)a2 + 9);
  *(void *)((char *)v41 + 6) = *(void *)((char *)a2 + 78);
  sub_1005D66F8((uint64_t)a1, (uint64_t)__dst, (uint64_t)buf);
  sub_1000FE824(&v40);
  sub_100030068(&v39);
  if (SHIBYTE(v37) < 0) {
    operator delete((void *)__p);
  }
  if (SHIBYTE(v35) < 0) {
    operator delete(__dst[0]);
  }
  sub_1000FE824((const void **)v46);
  sub_100030068((const void **)&v45 + 1);
  if (SHIBYTE(v44) < 0) {
    operator delete(v43[1]);
  }
  if (SHIBYTE(v43[0]) < 0) {
    operator delete(v42[0]);
  }
  sub_100917304((PB::Base *)buf);
  if (v8) {
    goto LABEL_76;
  }
}

void sub_1005D71E8(_Unwind_Exception *a1)
{
  if (SLOBYTE(STACK[0x227]) < 0) {
    operator delete((void *)STACK[0x210]);
  }
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_1005D7304(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v6 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I [TransferProfileReq]", buf, 2u);
  }
  char v7 = *(std::__shared_weak_count **)(a1 + 120);
  if (v7)
  {
    CFDataRef v8 = std::__shared_weak_count::lock(v7);
    if (v8)
    {
      uint64_t v9 = *(void *)(a1 + 112);
      if (v9)
      {
        uint64_t v10 = *(void *)(a3 + 96);
        uint64_t v11 = *(void *)(v10 + 16);
        if (v11)
        {
          if (*(char *)(v11 + 23) < 0)
          {
            if (*(void *)(v11 + 8))
            {
LABEL_9:
              uint64_t v99 = 0;
              memset(v98, 0, sizeof(v98));
              uint64_t v12 = *(long long **)(v10 + 16);
              if (*((char *)v12 + 23) < 0)
              {
                sub_10004FC84(v98, *(void **)v12, *((void *)v12 + 1));
              }
              else
              {
                long long v13 = *v12;
                uint64_t v99 = *((void *)v12 + 2);
                *(_OWORD *)long long v98 = v13;
              }
              long long v96 = 0uLL;
              uint64_t v19 = *(long long ***)(v10 + 8);
              if (v19 && v19[1] == (long long *)16)
              {
                long long v97 = **v19;
                CFDataRef v20 = *(long long ***)(v10 + 24);
                if (v20 && v20[1] == (long long *)16)
                {
                  long long v96 = **v20;
                  if (*(unsigned char *)(v10 + 68))
                  {
                    int v30 = *(_DWORD *)(v10 + 64);
                    if ((v30 & 0xFFFFFFFE) == 2)
                    {
                      if (SHIBYTE(v99) < 0)
                      {
                        sub_10004FC84((unsigned char *)v86 + 8, *(void **)v98, *(unint64_t *)&v98[8]);
                        int v30 = *(_DWORD *)(v10 + 64);
                      }
                      else
                      {
                        *(_OWORD *)((char *)v86 + 8) = *(_OWORD *)v98;
                        *((void *)&v86[1] + 1) = v99;
                      }
                      LOBYTE(v87[0]) = 1;
                      if (v30 == 3) {
                        unsigned int v40 = 2;
                      }
                      else {
                        unsigned int v40 = 4;
                      }
                      if (v30 == 2) {
                        uint64_t v41 = 3;
                      }
                      else {
                        uint64_t v41 = v40;
                      }
                      (*(void (**)(uint64_t, long long *, uint8_t *, uint64_t))(*(void *)v9 + 40))(v9, &v96, buf, v41);
                      if (SHIBYTE(v86[1]) < 0) {
                        operator delete(*((void **)&v86[0] + 1));
                      }
                      *(void *)uint64_t buf = a1;
                      sub_1005D4D64((char *)v86, (long long *)a2);
                      *(_OWORD *)((char *)v89 + 8) = *(_OWORD *)v98;
                      *((void *)&v89[1] + 1) = v99;
                      uint64_t v99 = 0;
                      memset(v98, 0, sizeof(v98));
                      sub_1005DF648(a1 + 8);
                    }
                    uint64_t v32 = *(long long **)(v10 + 40);
                    if (v32)
                    {
                      char v33 = *(long long **)(v10 + 32);
                      if (v33)
                      {
                        memset(v80, 0, 24);
                        memset(&v95, 0, sizeof(v95));
                        long long v34 = *(const std::string **)(v10 + 56);
                        if (v34) {
                          std::string::operator=((std::string *)v80, v34);
                        }
                        uint64_t v35 = *(const std::string **)(v10 + 48);
                        if (v35) {
                          std::string::operator=(&v95, v35);
                        }
                        *(void *)uint64_t buf = &v96;
                        long long v36 = (std::string *)sub_1003DE940((uint64_t **)(a1 + 160), (uint64_t)&v96, (uint64_t)&unk_10144E20E, (_OWORD **)buf);
                        std::string::operator=(v36 + 2, (const std::string *)a2);
                        *(void *)uint64_t buf = a1;
                        if (SHIBYTE(v99) < 0)
                        {
                          sub_10004FC84(v86, *(void **)v98, *(unint64_t *)&v98[8]);
                        }
                        else
                        {
                          v86[0] = *(_OWORD *)v98;
                          *(void *)&v86[1] = v99;
                        }
                        *((void *)&v86[1] + 1) = v9;
                        v87[0] = v8;
                        atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
                        if ((v80[23] & 0x80000000) != 0)
                        {
                          sub_10004FC84(&v87[1], *(void **)v80, *(unint64_t *)&v80[8]);
                        }
                        else
                        {
                          *(_OWORD *)&v87[1] = *(_OWORD *)v80;
                          v87[3] = *(void *)&v80[16];
                        }
                        long long v88 = v97;
                        v89[0] = v96;
                        if (SHIBYTE(v95.__r_.__value_.__r.__words[2]) < 0)
                        {
                          sub_10004FC84(&v89[1], v95.__r_.__value_.__l.__data_, v95.__r_.__value_.__l.__size_);
                        }
                        else
                        {
                          v89[1] = *(_OWORD *)&v95.__r_.__value_.__l.__data_;
                          *(void *)uint64_t v90 = *((void *)&v95.__r_.__value_.__l + 2);
                        }
                        if (*((char *)v32 + 23) < 0)
                        {
                          sub_10004FC84(&v90[8], *(void **)v32, *((void *)v32 + 1));
                        }
                        else
                        {
                          long long v42 = *v32;
                          uint64_t v91 = *((void *)v32 + 2);
                          *(_OWORD *)&v90[8] = v42;
                        }
                        if (*((char *)v33 + 23) < 0)
                        {
                          sub_10004FC84(&v92, *(void **)v33, *((void *)v33 + 1));
                        }
                        else
                        {
                          long long v43 = *v33;
                          uint64_t v93 = *((void *)v33 + 2);
                          long long v92 = v43;
                        }
                        sub_1005D4D64(v94, (long long *)a2);
                        sub_1005DF80C(a1 + 8);
                      }
                    }
                    *(void *)uint64_t buf = &off_101A1A658;
                    memset(v86, 0, sizeof(v86));
                    memset(v87, 0, sizeof(v87));
                    long long v88 = 0u;
                    memset(v89, 0, sizeof(v89));
                    *(_OWORD *)uint64_t v90 = 0u;
                    long long v82 = 0u;
                    *(_OWORD *)uint64_t v83 = 0u;
                    int v84 = 0;
                    long long v81 = 0u;
                    memset(v80, 0, sizeof(v80));
                    v83[8] = 2;
                    *(void *)&v83[12] = 0x50000003CLL;
                    sub_100918B88((uint64_t)buf);
                    uint64_t v37 = *(void *)&v89[1];
                    *(unsigned char *)(*(void *)&v89[1] + 28) |= 1u;
                    *(_DWORD *)(v37 + 24) = 13;
                    __int16 v38 = *(NSObject **)(a1 + 40);
                    if (os_log_type_enabled(v38, OS_LOG_TYPE_ERROR))
                    {
                      uint64_t v45 = asString();
                      LODWORD(v95.__r_.__value_.__l.__data_) = 136315138;
                      *(std::string::size_type *)((char *)v95.__r_.__value_.__r.__words + 4) = v45;
                      _os_log_error_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_ERROR, "Sending Error [%s]", (uint8_t *)&v95, 0xCu);
                    }
                    sub_1005D4D64(v46, (long long *)a2);
                    sub_1005D66F8(a1, (uint64_t)v46, (uint64_t)buf);
                    uint64_t v23 = v46;
                  }
                  else
                  {
                    *(void *)uint64_t buf = &off_101A1A658;
                    memset(v86, 0, sizeof(v86));
                    memset(v87, 0, sizeof(v87));
                    long long v88 = 0u;
                    memset(v89, 0, sizeof(v89));
                    *(_OWORD *)uint64_t v90 = 0u;
                    long long v82 = 0u;
                    *(_OWORD *)uint64_t v83 = 0u;
                    int v84 = 0;
                    long long v81 = 0u;
                    memset(v80, 0, sizeof(v80));
                    v83[8] = 2;
                    *(void *)&v83[12] = 0x50000003CLL;
                    sub_100918B88((uint64_t)buf);
                    uint64_t v21 = *(void *)&v89[1];
                    *(unsigned char *)(*(void *)&v89[1] + 28) |= 1u;
                    *(_DWORD *)(v21 + 24) = 13;
                    unsigned int v22 = *(NSObject **)(a1 + 40);
                    if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
                    {
                      uint64_t v44 = asString();
                      LODWORD(v95.__r_.__value_.__l.__data_) = 136315138;
                      *(std::string::size_type *)((char *)v95.__r_.__value_.__r.__words + 4) = v44;
                      _os_log_error_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_ERROR, "Sending Error [%s]", (uint8_t *)&v95, 0xCu);
                    }
                    sub_1005D4D64(v47, (long long *)a2);
                    sub_1005D66F8(a1, (uint64_t)v47, (uint64_t)buf);
                    uint64_t v23 = v47;
                  }
                  sub_1003C1D74((uint64_t)v23);
                  sub_1003C1D74((uint64_t)v80);
LABEL_86:
                  sub_100917304((PB::Base *)buf);
                  if (SHIBYTE(v99) < 0) {
                    operator delete(*(void **)v98);
                  }
LABEL_88:
                  sub_10004D2C8(v8);
                  return;
                }
                *(void *)uint64_t buf = &off_101A1A658;
                memset(v86, 0, sizeof(v86));
                memset(v87, 0, sizeof(v87));
                long long v88 = 0u;
                memset(v89, 0, sizeof(v89));
                *(_OWORD *)uint64_t v90 = 0u;
                long long v82 = 0u;
                *(_OWORD *)uint64_t v83 = 0u;
                int v84 = 0;
                long long v81 = 0u;
                memset(v80, 0, sizeof(v80));
                v83[8] = 2;
                *(void *)&v83[12] = 0x50000003CLL;
                sub_100918B88((uint64_t)buf);
                uint64_t v27 = *(void *)&v89[1];
                *(unsigned char *)(*(void *)&v89[1] + 28) |= 1u;
                *(_DWORD *)(v27 + 24) = 13;
                long long v28 = *(NSObject **)(a1 + 40);
                if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
                {
                  uint64_t v39 = asString();
                  LODWORD(v95.__r_.__value_.__l.__data_) = 136315138;
                  *(std::string::size_type *)((char *)v95.__r_.__value_.__r.__words + 4) = v39;
                  _os_log_error_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_ERROR, "Sending Error [%s]", (uint8_t *)&v95, 0xCu);
                }
                if (*(char *)(a2 + 23) < 0)
                {
                  sub_10004FC84(v48, *(void **)a2, *(void *)(a2 + 8));
                }
                else
                {
                  *(_OWORD *)xpc_object_t v48 = *(_OWORD *)a2;
                  uint64_t v49 = *(void *)(a2 + 16);
                }
                if (*(char *)(a2 + 47) < 0)
                {
                  sub_10004FC84(&v50, *(void **)(a2 + 24), *(void *)(a2 + 32));
                }
                else
                {
                  long long v50 = *(_OWORD *)(a2 + 24);
                  uint64_t v51 = *(void *)(a2 + 40);
                }
                __int16 v52 = *(_WORD *)(a2 + 48);
                sub_10002FD9C(&v53, (const void **)(a2 + 56));
                sub_100119B5C(&v54, (const void **)(a2 + 64));
                v55[0] = *(void *)(a2 + 72);
                *(void *)((char *)v55 + 6) = *(void *)(a2 + 78);
                sub_1005D66F8(a1, (uint64_t)v48, (uint64_t)buf);
                sub_1000FE824(&v54);
                sub_100030068(&v53);
                if (SHIBYTE(v51) < 0) {
                  operator delete((void *)v50);
                }
                if ((SHIBYTE(v49) & 0x80000000) == 0)
                {
LABEL_82:
                  sub_1000FE824((const void **)v83);
                  sub_100030068((const void **)&v82 + 1);
                  if (SHIBYTE(v81) < 0) {
                    operator delete(*(void **)&v80[24]);
                  }
                  if ((v80[23] & 0x80000000) != 0) {
                    operator delete(*(void **)v80);
                  }
                  goto LABEL_86;
                }
                uint64_t v26 = v48[0];
              }
              else
              {
                *(void *)uint64_t buf = &off_101A1A658;
                memset(v86, 0, sizeof(v86));
                memset(v87, 0, sizeof(v87));
                long long v88 = 0u;
                memset(v89, 0, sizeof(v89));
                *(_OWORD *)uint64_t v90 = 0u;
                long long v82 = 0u;
                *(_OWORD *)uint64_t v83 = 0u;
                int v84 = 0;
                long long v81 = 0u;
                memset(v80, 0, sizeof(v80));
                v83[8] = 2;
                *(void *)&v83[12] = 0x50000003CLL;
                sub_100918B88((uint64_t)buf);
                uint64_t v24 = *(void *)&v89[1];
                *(unsigned char *)(*(void *)&v89[1] + 28) |= 1u;
                *(_DWORD *)(v24 + 24) = 13;
                unint64_t v25 = *(NSObject **)(a1 + 40);
                if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
                {
                  uint64_t v31 = asString();
                  LODWORD(v95.__r_.__value_.__l.__data_) = 136315138;
                  *(std::string::size_type *)((char *)v95.__r_.__value_.__r.__words + 4) = v31;
                  _os_log_error_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_ERROR, "Sending Error [%s]", (uint8_t *)&v95, 0xCu);
                }
                if (*(char *)(a2 + 23) < 0)
                {
                  sub_10004FC84(&v56, *(void **)a2, *(void *)(a2 + 8));
                }
                else
                {
                  long long v56 = *(_OWORD *)a2;
                  uint64_t v57 = *(void *)(a2 + 16);
                }
                if (*(char *)(a2 + 47) < 0)
                {
                  sub_10004FC84(&v58, *(void **)(a2 + 24), *(void *)(a2 + 32));
                }
                else
                {
                  long long v58 = *(_OWORD *)(a2 + 24);
                  uint64_t v59 = *(void *)(a2 + 40);
                }
                __int16 v60 = *(_WORD *)(a2 + 48);
                sub_10002FD9C(&v61, (const void **)(a2 + 56));
                sub_100119B5C(&v62, (const void **)(a2 + 64));
                v63[0] = *(void *)(a2 + 72);
                *(void *)((char *)v63 + 6) = *(void *)(a2 + 78);
                sub_1005D66F8(a1, (uint64_t)&v56, (uint64_t)buf);
                sub_1000FE824(&v62);
                sub_100030068(&v61);
                if (SHIBYTE(v59) < 0) {
                  operator delete((void *)v58);
                }
                if ((SHIBYTE(v57) & 0x80000000) == 0) {
                  goto LABEL_82;
                }
                uint64_t v26 = (void *)v56;
              }
              operator delete(v26);
              goto LABEL_82;
            }
          }
          else if (*(unsigned char *)(v11 + 23))
          {
            goto LABEL_9;
          }
        }
        *(void *)uint64_t buf = &off_101A1A658;
        memset(v86, 0, sizeof(v86));
        memset(v87, 0, sizeof(v87));
        long long v88 = 0u;
        memset(v89, 0, sizeof(v89));
        *(_OWORD *)uint64_t v90 = 0u;
        long long v82 = 0u;
        *(_OWORD *)uint64_t v83 = 0u;
        int v84 = 0;
        long long v81 = 0u;
        memset(v80, 0, sizeof(v80));
        v83[8] = 2;
        *(void *)&v83[12] = 0x50000003CLL;
        sub_100918B88((uint64_t)buf);
        uint64_t v16 = *(void *)&v89[1];
        *(unsigned char *)(*(void *)&v89[1] + 28) |= 1u;
        *(_DWORD *)(v16 + 24) = 13;
        uint64_t v17 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
        {
          uint64_t v29 = asString();
          *(_DWORD *)long long v98 = 136315138;
          *(void *)&v98[4] = v29;
          _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "Sending Error [%s]", v98, 0xCu);
        }
        if (*(char *)(a2 + 23) < 0)
        {
          sub_10004FC84(v64, *(void **)a2, *(void *)(a2 + 8));
        }
        else
        {
          *(_OWORD *)unint64_t v64 = *(_OWORD *)a2;
          uint64_t v65 = *(void *)(a2 + 16);
        }
        if (*(char *)(a2 + 47) < 0)
        {
          sub_10004FC84(&v66, *(void **)(a2 + 24), *(void *)(a2 + 32));
        }
        else
        {
          long long v66 = *(_OWORD *)(a2 + 24);
          uint64_t v67 = *(void *)(a2 + 40);
        }
        __int16 v68 = *(_WORD *)(a2 + 48);
        sub_10002FD9C(&v69, (const void **)(a2 + 56));
        sub_100119B5C(&v70, (const void **)(a2 + 64));
        v71[0] = *(void *)(a2 + 72);
        *(void *)((char *)v71 + 6) = *(void *)(a2 + 78);
        sub_1005D66F8(a1, (uint64_t)v64, (uint64_t)buf);
        sub_1000FE824(&v70);
        sub_100030068(&v69);
        if (SHIBYTE(v67) < 0) {
          operator delete((void *)v66);
        }
        if (SHIBYTE(v65) < 0) {
          operator delete(v64[0]);
        }
        sub_1000FE824((const void **)v83);
        sub_100030068((const void **)&v82 + 1);
        if (SHIBYTE(v81) < 0) {
          operator delete(*(void **)&v80[24]);
        }
        if ((v80[23] & 0x80000000) != 0) {
          operator delete(*(void **)v80);
        }
        sub_100917304((PB::Base *)buf);
        goto LABEL_88;
      }
    }
  }
  else
  {
    CFDataRef v8 = 0;
  }
  *(void *)uint64_t buf = &off_101A1A658;
  memset(v86, 0, sizeof(v86));
  memset(v87, 0, sizeof(v87));
  long long v88 = 0u;
  memset(v89, 0, sizeof(v89));
  *(_OWORD *)uint64_t v90 = 0u;
  long long v82 = 0u;
  *(_OWORD *)uint64_t v83 = 0u;
  int v84 = 0;
  long long v81 = 0u;
  memset(v80, 0, sizeof(v80));
  v83[8] = 2;
  *(void *)&v83[12] = 0x50000003CLL;
  sub_100918B88((uint64_t)buf);
  uint64_t v14 = *(void *)&v89[1];
  *(unsigned char *)(*(void *)&v89[1] + 28) |= 1u;
  *(_DWORD *)(v14 + 24) = 18;
  uint64_t v15 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
  {
    uint64_t v18 = asString();
    *(_DWORD *)long long v98 = 136315138;
    *(void *)&v98[4] = v18;
    _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "Sending Error [%s]", v98, 0xCu);
  }
  if (*(char *)(a2 + 23) < 0)
  {
    sub_10004FC84(__dst, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)long long __dst = *(_OWORD *)a2;
    uint64_t v73 = *(void *)(a2 + 16);
  }
  if (*(char *)(a2 + 47) < 0)
  {
    sub_10004FC84(&__p, *(void **)(a2 + 24), *(void *)(a2 + 32));
  }
  else
  {
    long long __p = *(_OWORD *)(a2 + 24);
    uint64_t v75 = *(void *)(a2 + 40);
  }
  __int16 v76 = *(_WORD *)(a2 + 48);
  sub_10002FD9C(&v77, (const void **)(a2 + 56));
  sub_100119B5C(&v78, (const void **)(a2 + 64));
  v79[0] = *(void *)(a2 + 72);
  *(void *)((char *)v79 + 6) = *(void *)(a2 + 78);
  sub_1005D66F8(a1, (uint64_t)__dst, (uint64_t)buf);
  sub_1000FE824(&v78);
  sub_100030068(&v77);
  if (SHIBYTE(v75) < 0) {
    operator delete((void *)__p);
  }
  if (SHIBYTE(v73) < 0) {
    operator delete(__dst[0]);
  }
  sub_1000FE824((const void **)v83);
  sub_100030068((const void **)&v82 + 1);
  if (SHIBYTE(v81) < 0) {
    operator delete(*(void **)&v80[24]);
  }
  if ((v80[23] & 0x80000000) != 0) {
    operator delete(*(void **)v80);
  }
  sub_100917304((PB::Base *)buf);
  if (v8) {
    goto LABEL_88;
  }
}

void sub_1005D8100(_Unwind_Exception *a1)
{
  if (SLOBYTE(STACK[0x327]) < 0) {
    operator delete((void *)STACK[0x310]);
  }
  if (SLOBYTE(STACK[0x30F]) < 0) {
    operator delete((void *)STACK[0x2F8]);
  }
  if (SLOBYTE(STACK[0x2D7]) < 0) {
    operator delete((void *)STACK[0x2C0]);
  }
  if (STACK[0x2B8]) {
    sub_10004D2C8((std::__shared_weak_count *)STACK[0x2B8]);
  }
  if (SLOBYTE(STACK[0x2AF]) < 0) {
    operator delete((void *)STACK[0x298]);
  }
  if (*(char *)(v2 - 153) < 0) {
    operator delete(*(void **)(v2 - 176));
  }
  if (SLOBYTE(STACK[0x247]) < 0) {
    operator delete((void *)STACK[0x230]);
  }
  if (*(char *)(v2 - 89) < 0) {
    operator delete(*(void **)(v2 - 112));
  }
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_1005D8314(uint64_t a1, long long *a2, uint64_t a3)
{
  int v6 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I [GenericTransferPayloadReq]", buf, 2u);
  }
  char v7 = *(std::__shared_weak_count **)(a1 + 120);
  if (v7)
  {
    CFDataRef v8 = std::__shared_weak_count::lock(v7);
    if (v8)
    {
      uint64_t v9 = *(void *)(a1 + 112);
      if (v9)
      {
        uint64_t v10 = *(void *)(a3 + 56);
        uint64_t v11 = *(long long **)(v10 + 40);
        if (v11)
        {
          if (*((char *)v11 + 23) < 0)
          {
            if (*((void *)v11 + 1))
            {
LABEL_9:
              uint64_t v12 = *(void *)(v10 + 8);
              if (v12)
              {
                if (*(char *)(v12 + 23) < 0)
                {
                  if (*(void *)(v12 + 8))
                  {
LABEL_12:
                    uint64_t v13 = *(void *)(v10 + 32);
                    if (v13)
                    {
                      if (*(char *)(v13 + 23) < 0 ? *(void *)(v13 + 8) : *(unsigned __int8 *)(v13 + 23))
                      {
                        uint64_t v96 = 0;
                        long long v95 = 0uLL;
                        if (*((char *)v11 + 23) < 0)
                        {
                          sub_10004FC84(&v95, *(void **)v11, *((void *)v11 + 1));
                        }
                        else
                        {
                          long long v24 = *v11;
                          uint64_t v96 = *((void *)v11 + 2);
                          long long v95 = v24;
                        }
                        v43[1] = 0;
                        uint64_t v44 = 0;
                        v43[0] = 0;
                        uint64_t v27 = *(long long **)(v10 + 8);
                        if (*((char *)v27 + 23) < 0)
                        {
                          sub_10004FC84(v43, *(void **)v27, *((void *)v27 + 1));
                        }
                        else
                        {
                          long long v28 = *v27;
                          uint64_t v44 = *((void *)v27 + 2);
                          *(_OWORD *)long long v43 = v28;
                        }
                        v41[1] = 0;
                        uint64_t v42 = 0;
                        v41[0] = 0;
                        uint64_t v29 = *(long long **)(v10 + 32);
                        if (*((char *)v29 + 23) < 0)
                        {
                          sub_10004FC84(v41, *(void **)v29, *((void *)v29 + 1));
                        }
                        else
                        {
                          long long v30 = *v29;
                          uint64_t v42 = *((void *)v29 + 2);
                          *(_OWORD *)uint64_t v41 = v30;
                        }
                        long long v94 = 0uLL;
                        uint64_t v31 = *(long long ***)(v10 + 24);
                        if (v31 && v31[1] == (long long *)16)
                        {
                          long long v94 = **v31;
                          if (*(void *)(v10 + 16))
                          {
                            long long v84 = 0uLL;
                            *(void *)uint64_t buf = 0;
                            sub_1001E7940(buf, **(const void ***)(v10 + 16), **(void **)(v10 + 16) + *(void *)(*(void *)(v10 + 16) + 8), *(void *)(*(void *)(v10 + 16) + 8));
                            uint64_t v32 = *(const void **)buf;
                            uint64_t v33 = v84;
                          }
                          else
                          {
                            uint64_t v32 = 0;
                            uint64_t v33 = 0;
                          }
                          *(void *)uint64_t buf = &v94;
                          uint64_t v37 = (std::string *)sub_1003DE940((uint64_t **)(a1 + 160), (uint64_t)&v94, (uint64_t)&unk_10144E20E, (_OWORD **)buf);
                          std::string::operator=(v37 + 2, (const std::string *)a2);
                          *(void *)uint64_t buf = a1;
                          *(void *)&long long v84 = v9;
                          *((void *)&v84 + 1) = v8;
                          atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
                          if (SHIBYTE(v96) < 0)
                          {
                            sub_10004FC84(&v85, (void *)v95, *((unint64_t *)&v95 + 1));
                          }
                          else
                          {
                            long long v85 = v95;
                            v86[0] = v96;
                          }
                          if (SHIBYTE(v44) < 0)
                          {
                            sub_10004FC84(&v86[1], v43[0], (unint64_t)v43[1]);
                          }
                          else
                          {
                            *(_OWORD *)&v86[1] = *(_OWORD *)v43;
                            v86[3] = v44;
                          }
                          long long v87 = v94;
                          if (SHIBYTE(v42) < 0)
                          {
                            sub_10004FC84(&v88, v41[0], (unint64_t)v41[1]);
                          }
                          else
                          {
                            long long v88 = *(_OWORD *)v41;
                            *(void *)&long long v89 = v42;
                          }
                          long long v90 = 0uLL;
                          *((void *)&v89 + 1) = 0;
                          sub_10005C928((void *)&v89 + 1, v32, v33, v33 - (void)v32);
                          sub_1005D4D64(v91, a2);
                          sub_1005DFB98(a1 + 8);
                        }
                        *(void *)uint64_t buf = &off_101A1A658;
                        long long v84 = 0u;
                        long long v85 = 0u;
                        memset(v86, 0, sizeof(v86));
                        long long v87 = 0u;
                        long long v88 = 0u;
                        long long v89 = 0u;
                        long long v90 = 0u;
                        long long v80 = 0u;
                        *(_OWORD *)long long v81 = 0u;
                        int v82 = 0;
                        long long v78 = 0u;
                        long long v79 = 0u;
                        long long v77 = 0u;
                        v81[8] = 2;
                        *(void *)&v81[12] = 0x50000003CLL;
                        sub_100918F04((uint64_t)buf);
                        uint64_t v34 = v86[3];
                        *(unsigned char *)(v86[3] + 52) |= 1u;
                        *(_DWORD *)(v34 + 48) = 13;
                        uint64_t v35 = *(NSObject **)(a1 + 40);
                        if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
                        {
                          uint64_t v39 = asString();
                          *(_DWORD *)long long v92 = 136315138;
                          uint64_t v93 = v39;
                          _os_log_error_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_ERROR, "Sending Error [%s]", v92, 0xCu);
                        }
                        sub_1005D4D64(v40, a2);
                        sub_1005D66F8(a1, (uint64_t)v40, (uint64_t)buf);
                        sub_1003C1D74((uint64_t)v40);
                        sub_1003C1D74((uint64_t)&v77);
                        sub_100917304((PB::Base *)buf);
                        if (SHIBYTE(v42) < 0) {
                          operator delete(v41[0]);
                        }
                        if (SHIBYTE(v44) < 0) {
                          operator delete(v43[0]);
                        }
                        if (SHIBYTE(v96) < 0) {
                          operator delete((void *)v95);
                        }
LABEL_82:
                        sub_10004D2C8(v8);
                        return;
                      }
                    }
                    *(void *)uint64_t buf = &off_101A1A658;
                    long long v84 = 0u;
                    long long v85 = 0u;
                    memset(v86, 0, sizeof(v86));
                    long long v87 = 0u;
                    long long v88 = 0u;
                    long long v89 = 0u;
                    long long v90 = 0u;
                    long long v80 = 0u;
                    *(_OWORD *)long long v81 = 0u;
                    int v82 = 0;
                    long long v78 = 0u;
                    long long v79 = 0u;
                    long long v77 = 0u;
                    v81[8] = 2;
                    *(void *)&v81[12] = 0x50000003CLL;
                    sub_100918F04((uint64_t)buf);
                    uint64_t v25 = v86[3];
                    *(unsigned char *)(v86[3] + 52) |= 1u;
                    *(_DWORD *)(v25 + 48) = 13;
                    uint64_t v26 = *(NSObject **)(a1 + 40);
                    if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
                    {
                      uint64_t v38 = asString();
                      LODWORD(v95) = 136315138;
                      *(void *)((char *)&v95 + 4) = v38;
                      _os_log_error_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_ERROR, "Sending Error [%s]", (uint8_t *)&v95, 0xCu);
                    }
                    if (*((char *)a2 + 23) < 0)
                    {
                      sub_10004FC84(&v45, *(void **)a2, *((void *)a2 + 1));
                    }
                    else
                    {
                      long long v45 = *a2;
                      uint64_t v46 = *((void *)a2 + 2);
                    }
                    if (*((char *)a2 + 47) < 0)
                    {
                      sub_10004FC84(&v47, *((void **)a2 + 3), *((void *)a2 + 4));
                    }
                    else
                    {
                      long long v47 = *(long long *)((char *)a2 + 24);
                      uint64_t v48 = *((void *)a2 + 5);
                    }
                    __int16 v49 = *((_WORD *)a2 + 24);
                    sub_10002FD9C(&v50, (const void **)a2 + 7);
                    sub_100119B5C(&v51, (const void **)a2 + 8);
                    v52[0] = *((void *)a2 + 9);
                    *(void *)((char *)v52 + 6) = *(void *)((char *)a2 + 78);
                    sub_1005D66F8(a1, (uint64_t)&v45, (uint64_t)buf);
                    sub_1000FE824(&v51);
                    sub_100030068(&v50);
                    if (SHIBYTE(v48) < 0) {
                      operator delete((void *)v47);
                    }
                    if ((SHIBYTE(v46) & 0x80000000) == 0)
                    {
LABEL_77:
                      sub_1000FE824((const void **)v81);
                      sub_100030068((const void **)&v80 + 1);
                      if (SHIBYTE(v79) < 0) {
                        operator delete(*((void **)&v78 + 1));
                      }
                      if (SBYTE7(v78) < 0) {
                        operator delete((void *)v77);
                      }
                      sub_100917304((PB::Base *)buf);
                      goto LABEL_82;
                    }
                    uint64_t v19 = (void *)v45;
LABEL_76:
                    operator delete(v19);
                    goto LABEL_77;
                  }
                }
                else if (*(unsigned char *)(v12 + 23))
                {
                  goto LABEL_12;
                }
              }
              *(void *)uint64_t buf = &off_101A1A658;
              long long v84 = 0u;
              long long v85 = 0u;
              memset(v86, 0, sizeof(v86));
              long long v87 = 0u;
              long long v88 = 0u;
              long long v89 = 0u;
              long long v90 = 0u;
              long long v80 = 0u;
              *(_OWORD *)long long v81 = 0u;
              int v82 = 0;
              long long v78 = 0u;
              long long v79 = 0u;
              long long v77 = 0u;
              v81[8] = 2;
              *(void *)&v81[12] = 0x50000003CLL;
              sub_100918F04((uint64_t)buf);
              uint64_t v21 = v86[3];
              *(unsigned char *)(v86[3] + 52) |= 1u;
              *(_DWORD *)(v21 + 48) = 13;
              unsigned int v22 = *(NSObject **)(a1 + 40);
              if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
              {
                uint64_t v36 = asString();
                LODWORD(v95) = 136315138;
                *(void *)((char *)&v95 + 4) = v36;
                _os_log_error_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_ERROR, "Sending Error [%s]", (uint8_t *)&v95, 0xCu);
              }
              if (*((char *)a2 + 23) < 0)
              {
                sub_10004FC84(&v53, *(void **)a2, *((void *)a2 + 1));
              }
              else
              {
                long long v53 = *a2;
                uint64_t v54 = *((void *)a2 + 2);
              }
              if (*((char *)a2 + 47) < 0)
              {
                sub_10004FC84(&v55, *((void **)a2 + 3), *((void *)a2 + 4));
              }
              else
              {
                long long v55 = *(long long *)((char *)a2 + 24);
                uint64_t v56 = *((void *)a2 + 5);
              }
              __int16 v57 = *((_WORD *)a2 + 24);
              sub_10002FD9C(&v58, (const void **)a2 + 7);
              sub_100119B5C(&v59, (const void **)a2 + 8);
              v60[0] = *((void *)a2 + 9);
              *(void *)((char *)v60 + 6) = *(void *)((char *)a2 + 78);
              sub_1005D66F8(a1, (uint64_t)&v53, (uint64_t)buf);
              sub_1000FE824(&v59);
              sub_100030068(&v58);
              if (SHIBYTE(v56) < 0) {
                operator delete((void *)v55);
              }
              if ((SHIBYTE(v54) & 0x80000000) == 0) {
                goto LABEL_77;
              }
              uint64_t v19 = (void *)v53;
              goto LABEL_76;
            }
          }
          else if (*((unsigned char *)v11 + 23))
          {
            goto LABEL_9;
          }
        }
        *(void *)uint64_t buf = &off_101A1A658;
        long long v84 = 0u;
        long long v85 = 0u;
        memset(v86, 0, sizeof(v86));
        long long v87 = 0u;
        long long v88 = 0u;
        long long v89 = 0u;
        long long v90 = 0u;
        long long v80 = 0u;
        *(_OWORD *)long long v81 = 0u;
        int v82 = 0;
        long long v78 = 0u;
        long long v79 = 0u;
        long long v77 = 0u;
        v81[8] = 2;
        *(void *)&v81[12] = 0x50000003CLL;
        sub_100918F04((uint64_t)buf);
        uint64_t v17 = v86[3];
        *(unsigned char *)(v86[3] + 52) |= 1u;
        *(_DWORD *)(v17 + 48) = 13;
        uint64_t v18 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
        {
          uint64_t v23 = asString();
          LODWORD(v95) = 136315138;
          *(void *)((char *)&v95 + 4) = v23;
          _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "Sending Error [%s]", (uint8_t *)&v95, 0xCu);
        }
        if (*((char *)a2 + 23) < 0)
        {
          sub_10004FC84(&v61, *(void **)a2, *((void *)a2 + 1));
        }
        else
        {
          long long v61 = *a2;
          uint64_t v62 = *((void *)a2 + 2);
        }
        if (*((char *)a2 + 47) < 0)
        {
          sub_10004FC84(&v63, *((void **)a2 + 3), *((void *)a2 + 4));
        }
        else
        {
          long long v63 = *(long long *)((char *)a2 + 24);
          uint64_t v64 = *((void *)a2 + 5);
        }
        __int16 v65 = *((_WORD *)a2 + 24);
        sub_10002FD9C(&v66, (const void **)a2 + 7);
        sub_100119B5C(&v67, (const void **)a2 + 8);
        v68[0] = *((void *)a2 + 9);
        *(void *)((char *)v68 + 6) = *(void *)((char *)a2 + 78);
        sub_1005D66F8(a1, (uint64_t)&v61, (uint64_t)buf);
        sub_1000FE824(&v67);
        sub_100030068(&v66);
        if (SHIBYTE(v64) < 0) {
          operator delete((void *)v63);
        }
        if ((SHIBYTE(v62) & 0x80000000) == 0) {
          goto LABEL_77;
        }
        uint64_t v19 = (void *)v61;
        goto LABEL_76;
      }
    }
  }
  else
  {
    CFDataRef v8 = 0;
  }
  *(void *)uint64_t buf = &off_101A1A658;
  long long v84 = 0u;
  long long v85 = 0u;
  memset(v86, 0, sizeof(v86));
  long long v87 = 0u;
  long long v88 = 0u;
  long long v89 = 0u;
  long long v90 = 0u;
  long long v80 = 0u;
  *(_OWORD *)long long v81 = 0u;
  int v82 = 0;
  long long v78 = 0u;
  long long v79 = 0u;
  long long v77 = 0u;
  v81[8] = 2;
  *(void *)&v81[12] = 0x50000003CLL;
  sub_100918F04((uint64_t)buf);
  uint64_t v15 = v86[3];
  *(unsigned char *)(v86[3] + 52) |= 1u;
  *(_DWORD *)(v15 + 48) = 18;
  uint64_t v16 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
  {
    uint64_t v20 = asString();
    LODWORD(v95) = 136315138;
    *(void *)((char *)&v95 + 4) = v20;
    _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "Sending Error [%s]", (uint8_t *)&v95, 0xCu);
  }
  if (*((char *)a2 + 23) < 0)
  {
    sub_10004FC84(&__dst, *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long __dst = *a2;
    uint64_t v70 = *((void *)a2 + 2);
  }
  if (*((char *)a2 + 47) < 0)
  {
    sub_10004FC84(&__p, *((void **)a2 + 3), *((void *)a2 + 4));
  }
  else
  {
    long long __p = *(long long *)((char *)a2 + 24);
    uint64_t v72 = *((void *)a2 + 5);
  }
  __int16 v73 = *((_WORD *)a2 + 24);
  sub_10002FD9C(&v74, (const void **)a2 + 7);
  sub_100119B5C(&v75, (const void **)a2 + 8);
  v76[0] = *((void *)a2 + 9);
  *(void *)((char *)v76 + 6) = *(void *)((char *)a2 + 78);
  sub_1005D66F8(a1, (uint64_t)&__dst, (uint64_t)buf);
  sub_1000FE824(&v75);
  sub_100030068(&v74);
  if (SHIBYTE(v72) < 0) {
    operator delete((void *)__p);
  }
  if (SHIBYTE(v70) < 0) {
    operator delete((void *)__dst);
  }
  sub_1000FE824((const void **)v81);
  sub_100030068((const void **)&v80 + 1);
  if (SHIBYTE(v79) < 0) {
    operator delete(*((void **)&v78 + 1));
  }
  if (SBYTE7(v78) < 0) {
    operator delete((void *)v77);
  }
  sub_100917304((PB::Base *)buf);
  if (v8) {
    goto LABEL_82;
  }
}

void sub_1005D8F2C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,uint64_t a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33)
{
  if (SLOBYTE(STACK[0x2C7]) < 0) {
    operator delete((void *)STACK[0x2B0]);
  }
  if (SLOBYTE(STACK[0x2AF]) < 0) {
    operator delete((void *)STACK[0x298]);
  }
  if (STACK[0x290]) {
    sub_10004D2C8((std::__shared_weak_count *)STACK[0x290]);
  }
  if (v34) {
    operator delete(v34);
  }
  if (a26 < 0) {
    operator delete(a21);
  }
  if (a33 < 0) {
    operator delete(a28);
  }
  if (*(char *)(v35 - 105) < 0) {
    operator delete(*(void **)(v35 - 128));
  }
  sub_10004D2C8(v33);
  _Unwind_Resume(a1);
}

void sub_1005D9118(void *a1, long long *a2, uint64_t a3)
{
  int v6 = a1[5];
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I [FetchProfileReq]", buf, 2u);
  }
  char v7 = (std::__shared_weak_count *)a1[15];
  if (v7)
  {
    CFDataRef v8 = std::__shared_weak_count::lock(v7);
    if (v8)
    {
      uint64_t v9 = a1[14];
      if (v9)
      {
        *(_OWORD *)v124 = 0uLL;
        sub_100324590(v124);
        uint64_t v10 = *(void *)(a3 + 40);
        uint64_t v11 = *(void *)(v10 + 16);
        if (!v11 || *(void *)(v11 + 8) != 16)
        {
          *(void *)uint64_t buf = &off_101A1A658;
          long long v102 = 0u;
          long long v103 = 0u;
          long long v104 = 0u;
          long long v105 = 0u;
          long long v106 = 0u;
          long long v107 = 0u;
          long long v108 = 0u;
          long long v109 = 0u;
          long long v98 = 0u;
          *(_OWORD *)uint64_t v99 = 0u;
          int v100 = 0;
          *(_OWORD *)uint64_t v96 = 0u;
          long long v97 = 0u;
          *(_OWORD *)long long v95 = 0u;
          v99[8] = 2;
          *(void *)&v99[12] = 0x50000003CLL;
          sub_100918614((uint64_t)buf);
          uint64_t v26 = *((void *)&v104 + 1);
          *(unsigned char *)(*((void *)&v104 + 1) + 40) |= 1u;
          *(_DWORD *)(v26 + 32) = 13;
          uint64_t v27 = a1[5];
          if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
          {
            uint64_t v44 = asString();
            *(_DWORD *)CFTypeRef v122 = 136315138;
            uint64_t v123 = v44;
            _os_log_error_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_ERROR, "Sending Error [%s]", v122, 0xCu);
          }
          if (*((char *)a2 + 23) < 0)
          {
            sub_10004FC84(v79, *(void **)a2, *((void *)a2 + 1));
          }
          else
          {
            *(_OWORD *)long long v79 = *a2;
            uint64_t v80 = *((void *)a2 + 2);
          }
          if (*((char *)a2 + 47) < 0)
          {
            sub_10004FC84(&v81, *((void **)a2 + 3), *((void *)a2 + 4));
          }
          else
          {
            long long v81 = *(long long *)((char *)a2 + 24);
            uint64_t v82 = *((void *)a2 + 5);
          }
          __int16 v83 = *((_WORD *)a2 + 24);
          sub_10002FD9C(&v84, (const void **)a2 + 7);
          sub_100119B5C(&v85, (const void **)a2 + 8);
          v86[0] = *((void *)a2 + 9);
          *(void *)((char *)v86 + 6) = *(void *)((char *)a2 + 78);
          sub_1005D66F8((uint64_t)a1, (uint64_t)v79, (uint64_t)buf);
          sub_1000FE824(&v85);
          sub_100030068(&v84);
          if (SHIBYTE(v82) < 0) {
            operator delete((void *)v81);
          }
          if ((SHIBYTE(v80) & 0x80000000) == 0) {
            goto LABEL_57;
          }
          long long v28 = v79[0];
          goto LABEL_56;
        }
        uint64_t v12 = *(uint64_t **)v11;
        uint64_t v50 = v12[1];
        uint64_t v51 = *v12;
        uint64_t v13 = *(const std::string **)(v10 + 8);
        __int16 v49 = v8;
        if (v13)
        {
          uint64_t v14 = *(std::string **)v124;
          *(unsigned char *)(*(void *)v124 + 120) = 1;
          std::string::operator=(v14 + 3, v13);
          uint64_t v10 = *(void *)(a3 + 40);
        }
        uint64_t v15 = *(const std::string **)(v10 + 48);
        if (v15)
        {
          std::string::operator=((std::string *)(*(void *)v124 + 48), v15);
          uint64_t v10 = *(void *)(a3 + 40);
        }
        uint64_t v16 = *(const std::string **)(v10 + 56);
        if (v16)
        {
          std::string::operator=((std::string *)(*(void *)v124 + 24), v16);
          uint64_t v10 = *(void *)(a3 + 40);
        }
        uint64_t v17 = *(long long **)(v10 + 24);
        uint64_t v18 = *(long long **)(v10 + 32);
        if (v17 != v18)
        {
          do
          {
            uint64_t v19 = *(void *)v124;
            uint64_t v20 = (uint64_t *)(*(void *)v124 + 96);
            unint64_t v21 = *(void *)(*(void *)v124 + 104);
            if (v21 >= *(void *)(*(void *)v124 + 112))
            {
              uint64_t v22 = sub_10030E9EC(v20, v17);
            }
            else
            {
              sub_1000D87F8(v20, v17);
              uint64_t v22 = v21 + 24;
            }
            *(void *)(v19 + 104) = v22;
            uint64_t v17 = (long long *)((char *)v17 + 24);
          }
          while (v17 != v18);
          uint64_t v10 = *(void *)(a3 + 40);
          CFDataRef v8 = v49;
        }
        if ((*(unsigned char *)(v10 + 76) & 2) != 0)
        {
          int v30 = *(unsigned __int8 *)(v10 + 73);
          uint64_t v31 = *(std::string **)v124;
          *(unsigned char *)(*(void *)v124 + 121) = v30;
          if (v30) {
            goto LABEL_65;
          }
          uint64_t v32 = *(const std::string **)(v10 + 64);
          if (v32)
          {
            std::string::operator=(v31, v32);
            goto LABEL_65;
          }
          *(void *)uint64_t buf = &off_101A1A658;
          long long v102 = 0u;
          long long v103 = 0u;
          long long v104 = 0u;
          long long v105 = 0u;
          long long v106 = 0u;
          long long v107 = 0u;
          long long v108 = 0u;
          long long v109 = 0u;
          long long v98 = 0u;
          *(_OWORD *)uint64_t v99 = 0u;
          int v100 = 0;
          *(_OWORD *)uint64_t v96 = 0u;
          long long v97 = 0u;
          *(_OWORD *)long long v95 = 0u;
          v99[8] = 2;
          *(void *)&v99[12] = 0x50000003CLL;
          sub_100918614((uint64_t)buf);
          uint64_t v45 = *((void *)&v104 + 1);
          *(unsigned char *)(*((void *)&v104 + 1) + 40) |= 1u;
          *(_DWORD *)(v45 + 32) = 13;
          uint64_t v46 = a1[5];
          if (os_log_type_enabled(v46, OS_LOG_TYPE_ERROR))
          {
            uint64_t v48 = asString();
            *(_DWORD *)CFTypeRef v122 = 136315138;
            uint64_t v123 = v48;
            _os_log_error_impl((void *)&_mh_execute_header, v46, OS_LOG_TYPE_ERROR, "Sending Error [%s]", v122, 0xCu);
          }
          if (*((char *)a2 + 23) < 0)
          {
            sub_10004FC84(&v71, *(void **)a2, *((void *)a2 + 1));
          }
          else
          {
            long long v71 = *a2;
            uint64_t v72 = *((void *)a2 + 2);
          }
          if (*((char *)a2 + 47) < 0)
          {
            sub_10004FC84(&v73, *((void **)a2 + 3), *((void *)a2 + 4));
          }
          else
          {
            long long v73 = *(long long *)((char *)a2 + 24);
            uint64_t v74 = *((void *)a2 + 5);
          }
          __int16 v75 = *((_WORD *)a2 + 24);
          sub_10002FD9C(&v76, (const void **)a2 + 7);
          sub_100119B5C(&v77, (const void **)a2 + 8);
          v78[0] = *((void *)a2 + 9);
          *(void *)((char *)v78 + 6) = *(void *)((char *)a2 + 78);
          sub_1005D66F8((uint64_t)a1, (uint64_t)&v71, (uint64_t)buf);
          sub_1000FE824(&v77);
          sub_100030068(&v76);
          if (SHIBYTE(v74) < 0) {
            operator delete((void *)v73);
          }
          if (SHIBYTE(v72) < 0)
          {
            long long v28 = (void *)v71;
            goto LABEL_56;
          }
        }
        else
        {
          uint64_t v23 = *(const std::string **)(v10 + 64);
          if (v23)
          {
            std::string::operator=(*(std::string **)v124, v23);
LABEL_65:
            uint64_t v33 = *(void *)(a3 + 40);
            if (*(unsigned char *)(v33 + 76)) {
              *(unsigned char *)(*(void *)v124 + 122) = *(unsigned char *)(v33 + 72);
            }
            uint64_t v34 = (std::__shared_weak_count *)a1[2];
            if (!v34 || (uint64_t v35 = a1[1], (v36 = std::__shared_weak_count::lock(v34)) == 0)) {
              sub_100088B9C();
            }
            uint64_t v37 = v36;
            p_shared_weak_owners = &v36->__shared_weak_owners_;
            atomic_fetch_add_explicit(&v36->__shared_weak_owners_, 1uLL, memory_order_relaxed);
            sub_10004D2C8(v36);
            unsigned int v40 = *(std::__shared_weak_count **)&v124[8];
            uint64_t v39 = *(void *)v124;
            long long v62 = *(_OWORD *)v124;
            if (*(void *)&v124[8])
            {
              atomic_fetch_add_explicit((atomic_ullong *volatile)(*(void *)&v124[8] + 8), 1uLL, memory_order_relaxed);
              unsigned int v40 = *(std::__shared_weak_count **)&v124[8];
            }
            v110[0] = _NSConcreteStackBlock;
            v110[1] = 1174405120;
            v110[2] = sub_1005E08C8;
            v110[3] = &unk_1019ECED0;
            v110[4] = a1;
            v110[5] = v35;
            long long v111 = v37;
            atomic_fetch_add_explicit(p_shared_weak_owners, 1uLL, memory_order_relaxed);
            v121[2] = v51;
            v121[3] = v50;
            uint64_t v112 = v39;
            __int16 v113 = v40;
            if (v40) {
              atomic_fetch_add_explicit(&v40->__shared_owners_, 1uLL, memory_order_relaxed);
            }
            if (*((char *)a2 + 23) < 0)
            {
              sub_10004FC84(&v114, *(void **)a2, *((void *)a2 + 1));
            }
            else
            {
              long long v114 = *a2;
              uint64_t v115 = *((void *)a2 + 2);
            }
            uint64_t v41 = (long long *)((char *)a2 + 24);
            if (*((char *)a2 + 47) < 0)
            {
              sub_10004FC84(&v116, *((void **)a2 + 3), *((void *)a2 + 4));
            }
            else
            {
              long long v116 = *v41;
              uint64_t v117 = *((void *)a2 + 5);
            }
            __int16 v118 = *((_WORD *)a2 + 24);
            sub_10002FD9C(&v119, (const void **)a2 + 7);
            sub_100119B5C(&v120, (const void **)a2 + 8);
            v121[0] = *((void *)a2 + 9);
            *(void *)((char *)v121 + 6) = *(void *)((char *)a2 + 78);
            v52[0] = _NSConcreteStackBlock;
            v52[1] = 1174405120;
            v52[2] = sub_1005E0D80;
            void v52[3] = &unk_1019ECF00;
            uint8_t v52[4] = a1;
            v52[5] = v35;
            long long v53 = v37;
            atomic_fetch_add_explicit(&v37->__shared_weak_owners_, 1uLL, memory_order_relaxed);
            if (*((char *)a2 + 23) < 0)
            {
              sub_10004FC84(&v54, *(void **)a2, *((void *)a2 + 1));
            }
            else
            {
              long long v54 = *a2;
              uint64_t v55 = *((void *)a2 + 2);
            }
            if (*((char *)a2 + 47) < 0)
            {
              sub_10004FC84(&v56, *((void **)a2 + 3), *((void *)a2 + 4));
            }
            else
            {
              long long v56 = *v41;
              uint64_t v57 = *((void *)a2 + 5);
            }
            __int16 v58 = *((_WORD *)a2 + 24);
            sub_10002FD9C(&v59, (const void **)a2 + 7);
            sub_100119B5C(&v60, (const void **)a2 + 8);
            v61[0] = *((void *)a2 + 9);
            *(void *)((char *)v61 + 6) = *(void *)((char *)a2 + 78);
            (*(void (**)(uint64_t, uint64_t, uint64_t, long long *, void *, void *))(*(void *)v9 + 64))(v9, v51, v50, &v62, v110, v52);
            CFDataRef v8 = v49;
            if (*((void *)&v62 + 1)) {
              sub_10004D2C8(*((std::__shared_weak_count **)&v62 + 1));
            }
            sub_1000FE824(&v60);
            sub_100030068(&v59);
            if (SHIBYTE(v57) < 0) {
              operator delete((void *)v56);
            }
            if (SHIBYTE(v55) < 0) {
              operator delete((void *)v54);
            }
            if (v53) {
              std::__shared_weak_count::__release_weak(v53);
            }
            sub_1000FE824(&v120);
            sub_100030068(&v119);
            if (SHIBYTE(v117) < 0) {
              operator delete((void *)v116);
            }
            if (SHIBYTE(v115) < 0) {
              operator delete((void *)v114);
            }
            if (v113) {
              sub_10004D2C8(v113);
            }
            if (v111) {
              std::__shared_weak_count::__release_weak(v111);
            }
            std::__shared_weak_count::__release_weak(v37);
LABEL_102:
            if (*(void *)&v124[8]) {
              sub_10004D2C8(*(std::__shared_weak_count **)&v124[8]);
            }
            goto LABEL_41;
          }
          *(void *)uint64_t buf = &off_101A1A658;
          long long v102 = 0u;
          long long v103 = 0u;
          long long v104 = 0u;
          long long v105 = 0u;
          long long v106 = 0u;
          long long v107 = 0u;
          long long v108 = 0u;
          long long v109 = 0u;
          long long v98 = 0u;
          *(_OWORD *)uint64_t v99 = 0u;
          int v100 = 0;
          *(_OWORD *)uint64_t v96 = 0u;
          long long v97 = 0u;
          *(_OWORD *)long long v95 = 0u;
          v99[8] = 2;
          *(void *)&v99[12] = 0x50000003CLL;
          sub_100918614((uint64_t)buf);
          uint64_t v42 = *((void *)&v104 + 1);
          *(unsigned char *)(*((void *)&v104 + 1) + 40) |= 1u;
          *(_DWORD *)(v42 + 32) = 13;
          long long v43 = a1[5];
          if (os_log_type_enabled(v43, OS_LOG_TYPE_ERROR))
          {
            uint64_t v47 = asString();
            *(_DWORD *)CFTypeRef v122 = 136315138;
            uint64_t v123 = v47;
            _os_log_error_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_ERROR, "Sending Error [%s]", v122, 0xCu);
          }
          if (*((char *)a2 + 23) < 0)
          {
            sub_10004FC84(&v63, *(void **)a2, *((void *)a2 + 1));
          }
          else
          {
            long long v63 = *a2;
            uint64_t v64 = *((void *)a2 + 2);
          }
          if (*((char *)a2 + 47) < 0)
          {
            sub_10004FC84(&v65, *((void **)a2 + 3), *((void *)a2 + 4));
          }
          else
          {
            long long v65 = *(long long *)((char *)a2 + 24);
            uint64_t v66 = *((void *)a2 + 5);
          }
          __int16 v67 = *((_WORD *)a2 + 24);
          sub_10002FD9C(&v68, (const void **)a2 + 7);
          sub_100119B5C(&v69, (const void **)a2 + 8);
          v70[0] = *((void *)a2 + 9);
          *(void *)((char *)v70 + 6) = *(void *)((char *)a2 + 78);
          sub_1005D66F8((uint64_t)a1, (uint64_t)&v63, (uint64_t)buf);
          sub_1000FE824(&v69);
          sub_100030068(&v68);
          if (SHIBYTE(v66) < 0) {
            operator delete((void *)v65);
          }
          if (SHIBYTE(v64) < 0)
          {
            long long v28 = (void *)v63;
LABEL_56:
            operator delete(v28);
          }
        }
LABEL_57:
        sub_1000FE824((const void **)v99);
        sub_100030068((const void **)&v98 + 1);
        if (SHIBYTE(v97) < 0) {
          operator delete(v96[1]);
        }
        if (SHIBYTE(v96[0]) < 0) {
          operator delete(v95[0]);
        }
        sub_100917304((PB::Base *)buf);
        goto LABEL_102;
      }
    }
  }
  else
  {
    CFDataRef v8 = 0;
  }
  *(void *)uint64_t buf = &off_101A1A658;
  long long v102 = 0u;
  long long v103 = 0u;
  long long v104 = 0u;
  long long v105 = 0u;
  long long v106 = 0u;
  long long v107 = 0u;
  long long v108 = 0u;
  long long v109 = 0u;
  long long v98 = 0u;
  *(_OWORD *)uint64_t v99 = 0u;
  int v100 = 0;
  *(_OWORD *)uint64_t v96 = 0u;
  long long v97 = 0u;
  *(_OWORD *)long long v95 = 0u;
  v99[8] = 2;
  *(void *)&v99[12] = 0x50000003CLL;
  sub_100918614((uint64_t)buf);
  uint64_t v24 = *((void *)&v104 + 1);
  *(unsigned char *)(*((void *)&v104 + 1) + 40) |= 1u;
  *(_DWORD *)(v24 + 32) = 18;
  uint64_t v25 = a1[5];
  if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
  {
    uint64_t v29 = asString();
    *(_DWORD *)v124 = 136315138;
    *(void *)&v124[4] = v29;
    _os_log_error_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_ERROR, "Sending Error [%s]", v124, 0xCu);
  }
  if (*((char *)a2 + 23) < 0)
  {
    sub_10004FC84(__dst, *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    *(_OWORD *)long long __dst = *a2;
    uint64_t v88 = *((void *)a2 + 2);
  }
  if (*((char *)a2 + 47) < 0)
  {
    sub_10004FC84(&__p, *((void **)a2 + 3), *((void *)a2 + 4));
  }
  else
  {
    long long __p = *(long long *)((char *)a2 + 24);
    uint64_t v90 = *((void *)a2 + 5);
  }
  __int16 v91 = *((_WORD *)a2 + 24);
  sub_10002FD9C(&v92, (const void **)a2 + 7);
  sub_100119B5C(&v93, (const void **)a2 + 8);
  v94[0] = *((void *)a2 + 9);
  *(void *)((char *)v94 + 6) = *(void *)((char *)a2 + 78);
  sub_1005D66F8((uint64_t)a1, (uint64_t)__dst, (uint64_t)buf);
  sub_1000FE824(&v93);
  sub_100030068(&v92);
  if (SHIBYTE(v90) < 0) {
    operator delete((void *)__p);
  }
  if (SHIBYTE(v88) < 0) {
    operator delete(__dst[0]);
  }
  sub_1000FE824((const void **)v99);
  sub_100030068((const void **)&v98 + 1);
  if (SHIBYTE(v97) < 0) {
    operator delete(v96[1]);
  }
  if (SHIBYTE(v96[0]) < 0) {
    operator delete(v95[0]);
  }
  sub_100917304((PB::Base *)buf);
LABEL_41:
  if (v8) {
    sub_10004D2C8(v8);
  }
}

void sub_1005D9E04(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11, std::__shared_weak_count *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,std::__shared_weak_count *a21,void *a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,void *__p,uint64_t a48,int a49,__int16 a50,char a51,char a52)
{
  if (a52 < 0) {
    operator delete(__p);
  }
  sub_1003C1D74((uint64_t)&STACK[0x250]);
  sub_100917304((PB::Base *)&STACK[0x2B0]);
  long long v54 = *(std::__shared_weak_count **)(v52 - 136);
  if (v54) {
    sub_10004D2C8(v54);
  }
  if (a12) {
    sub_10004D2C8(a12);
  }
  _Unwind_Resume(a1);
}

void sub_1005D9FC0(void *a1, long long *a2, uint64_t a3)
{
  int v6 = a1[5];
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I [SendUserConsentReq]", buf, 2u);
  }
  char v7 = (std::__shared_weak_count *)a1[15];
  if (v7)
  {
    CFDataRef v8 = std::__shared_weak_count::lock(v7);
    if (v8)
    {
      uint64_t v9 = a1[14];
      if (v9)
      {
        uint64_t v10 = *(void *)(a3 + 80);
        uint64_t v11 = *(void *)(v10 + 8);
        if (v11 && *(void *)(v11 + 8) == 16)
        {
          char v12 = 2;
          if (*(unsigned char *)(v10 + 20))
          {
            unsigned int v13 = *(_DWORD *)(v10 + 16);
            if (v13 >= 3) {
              char v12 = 2;
            }
            else {
              char v12 = v13;
            }
          }
          unsigned __int8 v28 = v12;
          uint64_t v14 = (std::__shared_weak_count *)a1[2];
          if (!v14
            || (uint64_t v15 = *(uint64_t **)v11,
                uint64_t v16 = *v15,
                uint64_t v17 = v15[1],
                uint64_t v18 = a1[1],
                (uint64_t v19 = std::__shared_weak_count::lock(v14)) == 0))
          {
            sub_100088B9C();
          }
          uint64_t v20 = v19;
          p_shared_weak_owners = &v19->__shared_weak_owners_;
          atomic_fetch_add_explicit(&v19->__shared_weak_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v19);
          v60[0] = _NSConcreteStackBlock;
          v60[1] = 1174405120;
          v60[2] = sub_1005E1258;
          void v60[3] = &unk_1019ECF60;
          v60[4] = a1;
          v60[5] = v18;
          long long v61 = v20;
          atomic_fetch_add_explicit(p_shared_weak_owners, 1uLL, memory_order_relaxed);
          v69[2] = v16;
          v69[3] = v17;
          if (*((char *)a2 + 23) < 0)
          {
            sub_10004FC84(&v62, *(void **)a2, *((void *)a2 + 1));
          }
          else
          {
            long long v62 = *a2;
            uint64_t v63 = *((void *)a2 + 2);
          }
          if (*((char *)a2 + 47) < 0)
          {
            sub_10004FC84(&v64, *((void **)a2 + 3), *((void *)a2 + 4));
          }
          else
          {
            long long v64 = *(long long *)((char *)a2 + 24);
            uint64_t v65 = *((void *)a2 + 5);
          }
          __int16 v66 = *((_WORD *)a2 + 24);
          sub_10002FD9C(&v67, (const void **)a2 + 7);
          sub_100119B5C(&v68, (const void **)a2 + 8);
          v69[0] = *((void *)a2 + 9);
          *(void *)((char *)v69 + 6) = *(void *)((char *)a2 + 78);
          (*(void (**)(uint64_t, uint64_t, uint64_t, void, void *))(*(void *)v9 + 72))(v9, v16, v17, v28, v60);
          sub_1000FE824(&v68);
          sub_100030068(&v67);
          if (SHIBYTE(v65) < 0) {
            operator delete((void *)v64);
          }
          if (SHIBYTE(v63) < 0) {
            operator delete((void *)v62);
          }
          if (v61) {
            std::__shared_weak_count::__release_weak(v61);
          }
          std::__shared_weak_count::__release_weak(v20);
        }
        else
        {
          *(void *)uint64_t buf = &off_101A1A658;
          long long v52 = 0u;
          long long v53 = 0u;
          long long v54 = 0u;
          long long v55 = 0u;
          long long v56 = 0u;
          long long v57 = 0u;
          long long v58 = 0u;
          long long v59 = 0u;
          long long v48 = 0u;
          *(_OWORD *)__int16 v49 = 0u;
          int v50 = 0;
          *(_OWORD *)uint64_t v46 = 0u;
          long long v47 = 0u;
          *(_OWORD *)uint64_t v45 = 0u;
          v49[8] = 2;
          *(void *)&v49[12] = 0x50000003CLL;
          sub_1009186C4((uint64_t)buf);
          uint64_t v24 = v57;
          *(unsigned char *)(v57 + 24) |= 1u;
          *(_DWORD *)(v24 + 16) = 13;
          uint64_t v25 = a1[5];
          if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
          {
            uint64_t v27 = asString();
            *(_DWORD *)uint64_t v70 = 136315138;
            uint64_t v71 = v27;
            _os_log_error_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_ERROR, "Sending Error [%s]", v70, 0xCu);
          }
          if (*((char *)a2 + 23) < 0)
          {
            sub_10004FC84(v29, *(void **)a2, *((void *)a2 + 1));
          }
          else
          {
            *(_OWORD *)uint64_t v29 = *a2;
            uint64_t v30 = *((void *)a2 + 2);
          }
          if (*((char *)a2 + 47) < 0)
          {
            sub_10004FC84(&v31, *((void **)a2 + 3), *((void *)a2 + 4));
          }
          else
          {
            long long v31 = *(long long *)((char *)a2 + 24);
            uint64_t v32 = *((void *)a2 + 5);
          }
          __int16 v33 = *((_WORD *)a2 + 24);
          sub_10002FD9C(&v34, (const void **)a2 + 7);
          sub_100119B5C(&v35, (const void **)a2 + 8);
          v36[0] = *((void *)a2 + 9);
          *(void *)((char *)v36 + 6) = *(void *)((char *)a2 + 78);
          sub_1005D66F8((uint64_t)a1, (uint64_t)v29, (uint64_t)buf);
          sub_1000FE824(&v35);
          sub_100030068(&v34);
          if (SHIBYTE(v32) < 0) {
            operator delete((void *)v31);
          }
          if (SHIBYTE(v30) < 0) {
            operator delete(v29[0]);
          }
          sub_1000FE824((const void **)v49);
          sub_100030068((const void **)&v48 + 1);
          if (SHIBYTE(v47) < 0) {
            operator delete(v46[1]);
          }
          if (SHIBYTE(v46[0]) < 0) {
            operator delete(v45[0]);
          }
          sub_100917304((PB::Base *)buf);
        }
LABEL_63:
        sub_10004D2C8(v8);
        return;
      }
    }
  }
  else
  {
    CFDataRef v8 = 0;
  }
  *(void *)uint64_t buf = &off_101A1A658;
  long long v52 = 0u;
  long long v53 = 0u;
  long long v54 = 0u;
  long long v55 = 0u;
  long long v56 = 0u;
  long long v57 = 0u;
  long long v58 = 0u;
  long long v59 = 0u;
  long long v48 = 0u;
  *(_OWORD *)__int16 v49 = 0u;
  int v50 = 0;
  *(_OWORD *)uint64_t v46 = 0u;
  long long v47 = 0u;
  *(_OWORD *)uint64_t v45 = 0u;
  v49[8] = 2;
  *(void *)&v49[12] = 0x50000003CLL;
  sub_1009186C4((uint64_t)buf);
  uint64_t v22 = v57;
  *(unsigned char *)(v57 + 24) |= 1u;
  *(_DWORD *)(v22 + 16) = 18;
  uint64_t v23 = a1[5];
  if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
  {
    uint64_t v26 = asString();
    *(_DWORD *)uint64_t v70 = 136315138;
    uint64_t v71 = v26;
    _os_log_error_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_ERROR, "Sending Error [%s]", v70, 0xCu);
  }
  if (*((char *)a2 + 23) < 0)
  {
    sub_10004FC84(__dst, *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    *(_OWORD *)long long __dst = *a2;
    uint64_t v38 = *((void *)a2 + 2);
  }
  if (*((char *)a2 + 47) < 0)
  {
    sub_10004FC84(&__p, *((void **)a2 + 3), *((void *)a2 + 4));
  }
  else
  {
    long long __p = *(long long *)((char *)a2 + 24);
    uint64_t v40 = *((void *)a2 + 5);
  }
  __int16 v41 = *((_WORD *)a2 + 24);
  sub_10002FD9C(&v42, (const void **)a2 + 7);
  sub_100119B5C(&v43, (const void **)a2 + 8);
  v44[0] = *((void *)a2 + 9);
  *(void *)((char *)v44 + 6) = *(void *)((char *)a2 + 78);
  sub_1005D66F8((uint64_t)a1, (uint64_t)__dst, (uint64_t)buf);
  sub_1000FE824(&v43);
  sub_100030068(&v42);
  if (SHIBYTE(v40) < 0) {
    operator delete((void *)__p);
  }
  if (SHIBYTE(v38) < 0) {
    operator delete(__dst[0]);
  }
  sub_1000FE824((const void **)v49);
  sub_100030068((const void **)&v48 + 1);
  if (SHIBYTE(v47) < 0) {
    operator delete(v46[1]);
  }
  if (SHIBYTE(v46[0]) < 0) {
    operator delete(v45[0]);
  }
  sub_100917304((PB::Base *)buf);
  if (v8) {
    goto LABEL_63;
  }
}

void sub_1005DA680(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  if (SLOBYTE(STACK[0x20F]) < 0) {
    operator delete(__p);
  }
  if (a71) {
    std::__shared_weak_count::__release_weak(a71);
  }
  std::__shared_weak_count::__release_weak(v73);
  sub_10004D2C8(v72);
  _Unwind_Resume(a1);
}

void sub_1005DA764(void *a1, long long *a2, uint64_t a3)
{
  int v6 = a1[5];
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I [EndSessionReq]", buf, 2u);
  }
  char v7 = (std::__shared_weak_count *)a1[15];
  if (v7)
  {
    CFDataRef v8 = std::__shared_weak_count::lock(v7);
    if (v8)
    {
      uint64_t v9 = a1[14];
      if (v9)
      {
        uint64_t v10 = *(void *)(a3 + 32);
        uint64_t v11 = *(void *)(v10 + 8);
        if (v11 && *(void *)(v11 + 8) == 16)
        {
          if (*(unsigned char *)(v10 + 20))
          {
            unsigned int v17 = *(_DWORD *)(v10 + 16);
            if (v17 - 1 >= 3) {
              unsigned int v17 = 0;
            }
            unsigned int v27 = v17;
          }
          else
          {
            unsigned int v27 = 0;
          }
          uint64_t v18 = (std::__shared_weak_count *)a1[2];
          if (!v18
            || (uint64_t v19 = *(uint64_t **)v11,
                uint64_t v21 = *v19,
                uint64_t v20 = v19[1],
                uint64_t v22 = a1[1],
                (uint64_t v23 = std::__shared_weak_count::lock(v18)) == 0))
          {
            sub_100088B9C();
          }
          uint64_t v24 = v23;
          p_shared_weak_owners = &v23->__shared_weak_owners_;
          atomic_fetch_add_explicit(&v23->__shared_weak_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v23);
          v59[0] = _NSConcreteStackBlock;
          v59[1] = 1174405120;
          v59[2] = sub_1005E03B4;
          v59[3] = &unk_1019ECEA0;
          v59[4] = a1;
          v59[5] = v22;
          __int16 v60 = v24;
          atomic_fetch_add_explicit(p_shared_weak_owners, 1uLL, memory_order_relaxed);
          v68[2] = v21;
          void v68[3] = v20;
          if (*((char *)a2 + 23) < 0)
          {
            sub_10004FC84(&v61, *(void **)a2, *((void *)a2 + 1));
          }
          else
          {
            long long v61 = *a2;
            uint64_t v62 = *((void *)a2 + 2);
          }
          if (*((char *)a2 + 47) < 0)
          {
            sub_10004FC84(&v63, *((void **)a2 + 3), *((void *)a2 + 4));
          }
          else
          {
            long long v63 = *(long long *)((char *)a2 + 24);
            uint64_t v64 = *((void *)a2 + 5);
          }
          __int16 v65 = *((_WORD *)a2 + 24);
          sub_10002FD9C(&v66, (const void **)a2 + 7);
          sub_100119B5C(&v67, (const void **)a2 + 8);
          v68[0] = *((void *)a2 + 9);
          *(void *)((char *)v68 + 6) = *(void *)((char *)a2 + 78);
          (*(void (**)(uint64_t, uint64_t, uint64_t, void, void *))(*(void *)v9 + 88))(v9, v21, v20, v27, v59);
          sub_1000FE824(&v67);
          sub_100030068(&v66);
          if (SHIBYTE(v64) < 0) {
            operator delete((void *)v63);
          }
          if (SHIBYTE(v62) < 0) {
            operator delete((void *)v61);
          }
          if (v60) {
            std::__shared_weak_count::__release_weak(v60);
          }
          std::__shared_weak_count::__release_weak(v24);
        }
        else
        {
          *(void *)uint64_t buf = &off_101A1A658;
          long long v51 = 0u;
          long long v52 = 0u;
          long long v53 = 0u;
          long long v54 = 0u;
          long long v55 = 0u;
          long long v56 = 0u;
          long long v57 = 0u;
          long long v58 = 0u;
          long long v47 = 0u;
          *(_OWORD *)long long v48 = 0u;
          int v49 = 0;
          *(_OWORD *)uint64_t v45 = 0u;
          long long v46 = 0u;
          *(_OWORD *)uint64_t v44 = 0u;
          v48[8] = 2;
          *(void *)&v48[12] = 0x50000003CLL;
          sub_100918974((uint64_t)buf);
          uint64_t v14 = *((void *)&v52 + 1);
          *(unsigned char *)(*((void *)&v52 + 1) + 24) |= 1u;
          *(_DWORD *)(v14 + 16) = 13;
          uint64_t v15 = a1[5];
          if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
          {
            uint64_t v26 = asString();
            *(_DWORD *)long long v69 = 136315138;
            uint64_t v70 = v26;
            _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "Sending Error [%s]", v69, 0xCu);
          }
          if (*((char *)a2 + 23) < 0)
          {
            sub_10004FC84(v28, *(void **)a2, *((void *)a2 + 1));
          }
          else
          {
            *(_OWORD *)unsigned __int8 v28 = *a2;
            uint64_t v29 = *((void *)a2 + 2);
          }
          if (*((char *)a2 + 47) < 0)
          {
            sub_10004FC84(&v30, *((void **)a2 + 3), *((void *)a2 + 4));
          }
          else
          {
            long long v30 = *(long long *)((char *)a2 + 24);
            uint64_t v31 = *((void *)a2 + 5);
          }
          __int16 v32 = *((_WORD *)a2 + 24);
          sub_10002FD9C(&v33, (const void **)a2 + 7);
          sub_100119B5C(&v34, (const void **)a2 + 8);
          v35[0] = *((void *)a2 + 9);
          *(void *)((char *)v35 + 6) = *(void *)((char *)a2 + 78);
          sub_1005D66F8((uint64_t)a1, (uint64_t)v28, (uint64_t)buf);
          sub_1000FE824(&v34);
          sub_100030068(&v33);
          if (SHIBYTE(v31) < 0) {
            operator delete((void *)v30);
          }
          if (SHIBYTE(v29) < 0) {
            operator delete(v28[0]);
          }
          sub_1000FE824((const void **)v48);
          sub_100030068((const void **)&v47 + 1);
          if (SHIBYTE(v46) < 0) {
            operator delete(v45[1]);
          }
          if (SHIBYTE(v45[0]) < 0) {
            operator delete(v44[0]);
          }
          sub_100917304((PB::Base *)buf);
        }
LABEL_64:
        sub_10004D2C8(v8);
        return;
      }
    }
  }
  else
  {
    CFDataRef v8 = 0;
  }
  *(void *)uint64_t buf = &off_101A1A658;
  long long v51 = 0u;
  long long v52 = 0u;
  long long v53 = 0u;
  long long v54 = 0u;
  long long v55 = 0u;
  long long v56 = 0u;
  long long v57 = 0u;
  long long v58 = 0u;
  long long v47 = 0u;
  *(_OWORD *)long long v48 = 0u;
  int v49 = 0;
  *(_OWORD *)uint64_t v45 = 0u;
  long long v46 = 0u;
  *(_OWORD *)uint64_t v44 = 0u;
  v48[8] = 2;
  *(void *)&v48[12] = 0x50000003CLL;
  sub_100918974((uint64_t)buf);
  uint64_t v12 = *((void *)&v52 + 1);
  *(unsigned char *)(*((void *)&v52 + 1) + 24) |= 1u;
  *(_DWORD *)(v12 + 16) = 18;
  unsigned int v13 = a1[5];
  if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
  {
    uint64_t v16 = asString();
    *(_DWORD *)long long v69 = 136315138;
    uint64_t v70 = v16;
    _os_log_error_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "Sending Error [%s]", v69, 0xCu);
  }
  if (*((char *)a2 + 23) < 0)
  {
    sub_10004FC84(__dst, *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    *(_OWORD *)long long __dst = *a2;
    uint64_t v37 = *((void *)a2 + 2);
  }
  if (*((char *)a2 + 47) < 0)
  {
    sub_10004FC84(&__p, *((void **)a2 + 3), *((void *)a2 + 4));
  }
  else
  {
    long long __p = *(long long *)((char *)a2 + 24);
    uint64_t v39 = *((void *)a2 + 5);
  }
  __int16 v40 = *((_WORD *)a2 + 24);
  sub_10002FD9C(&v41, (const void **)a2 + 7);
  sub_100119B5C(&v42, (const void **)a2 + 8);
  v43[0] = *((void *)a2 + 9);
  *(void *)((char *)v43 + 6) = *(void *)((char *)a2 + 78);
  sub_1005D66F8((uint64_t)a1, (uint64_t)__dst, (uint64_t)buf);
  sub_1000FE824(&v42);
  sub_100030068(&v41);
  if (SHIBYTE(v39) < 0) {
    operator delete((void *)__p);
  }
  if (SHIBYTE(v37) < 0) {
    operator delete(__dst[0]);
  }
  sub_1000FE824((const void **)v48);
  sub_100030068((const void **)&v47 + 1);
  if (SHIBYTE(v46) < 0) {
    operator delete(v45[1]);
  }
  if (SHIBYTE(v45[0]) < 0) {
    operator delete(v44[0]);
  }
  sub_100917304((PB::Base *)buf);
  if (v8) {
    goto LABEL_64;
  }
}

void sub_1005DAE28(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  if (SLOBYTE(STACK[0x20F]) < 0) {
    operator delete(__p);
  }
  if (a71) {
    std::__shared_weak_count::__release_weak(a71);
  }
  std::__shared_weak_count::__release_weak(v73);
  sub_10004D2C8(v72);
  _Unwind_Resume(a1);
}

void sub_1005DAF0C(void *a1, long long *a2, uint64_t a3)
{
  int v6 = a1[5];
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I [StartSessionReq]", buf, 2u);
  }
  char v7 = (std::__shared_weak_count *)a1[15];
  if (v7)
  {
    CFDataRef v8 = std::__shared_weak_count::lock(v7);
    if (v8)
    {
      uint64_t v9 = a1[14];
      if (v9)
      {
        uint64_t v10 = *(void *)(a3 + 88);
        uint64_t v11 = *(void *)(v10 + 8);
        if (v11 && *(void *)(v11 + 8) == 16)
        {
          if (*(unsigned char *)(v10 + 20))
          {
            unsigned int v17 = *(_DWORD *)(v10 + 16);
            if (v17 - 1 >= 3) {
              unsigned int v17 = 0;
            }
            unsigned int v27 = v17;
          }
          else
          {
            unsigned int v27 = 0;
          }
          uint64_t v18 = (std::__shared_weak_count *)a1[2];
          if (!v18
            || (uint64_t v19 = *(uint64_t **)v11,
                uint64_t v21 = *v19,
                uint64_t v20 = v19[1],
                uint64_t v22 = a1[1],
                (uint64_t v23 = std::__shared_weak_count::lock(v18)) == 0))
          {
            sub_100088B9C();
          }
          uint64_t v24 = v23;
          p_shared_weak_owners = &v23->__shared_weak_owners_;
          atomic_fetch_add_explicit(&v23->__shared_weak_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v23);
          v59[0] = _NSConcreteStackBlock;
          v59[1] = 1174405120;
          v59[2] = sub_1005DFEA0;
          v59[3] = &unk_1019ECE40;
          v59[4] = a1;
          v59[5] = v22;
          __int16 v60 = v24;
          atomic_fetch_add_explicit(p_shared_weak_owners, 1uLL, memory_order_relaxed);
          v68[2] = v21;
          void v68[3] = v20;
          if (*((char *)a2 + 23) < 0)
          {
            sub_10004FC84(&v61, *(void **)a2, *((void *)a2 + 1));
          }
          else
          {
            long long v61 = *a2;
            uint64_t v62 = *((void *)a2 + 2);
          }
          if (*((char *)a2 + 47) < 0)
          {
            sub_10004FC84(&v63, *((void **)a2 + 3), *((void *)a2 + 4));
          }
          else
          {
            long long v63 = *(long long *)((char *)a2 + 24);
            uint64_t v64 = *((void *)a2 + 5);
          }
          __int16 v65 = *((_WORD *)a2 + 24);
          sub_10002FD9C(&v66, (const void **)a2 + 7);
          sub_100119B5C(&v67, (const void **)a2 + 8);
          v68[0] = *((void *)a2 + 9);
          *(void *)((char *)v68 + 6) = *(void *)((char *)a2 + 78);
          (*(void (**)(uint64_t, uint64_t, uint64_t, void, void *))(*(void *)v9 + 80))(v9, v21, v20, v27, v59);
          sub_1000FE824(&v67);
          sub_100030068(&v66);
          if (SHIBYTE(v64) < 0) {
            operator delete((void *)v63);
          }
          if (SHIBYTE(v62) < 0) {
            operator delete((void *)v61);
          }
          if (v60) {
            std::__shared_weak_count::__release_weak(v60);
          }
          std::__shared_weak_count::__release_weak(v24);
        }
        else
        {
          *(void *)uint64_t buf = &off_101A1A658;
          long long v51 = 0u;
          long long v52 = 0u;
          long long v53 = 0u;
          long long v54 = 0u;
          long long v55 = 0u;
          long long v56 = 0u;
          long long v57 = 0u;
          long long v58 = 0u;
          long long v47 = 0u;
          *(_OWORD *)long long v48 = 0u;
          int v49 = 0;
          *(_OWORD *)uint64_t v45 = 0u;
          long long v46 = 0u;
          *(_OWORD *)uint64_t v44 = 0u;
          v48[8] = 2;
          *(void *)&v48[12] = 0x50000003CLL;
          sub_1009188C8((uint64_t)buf);
          uint64_t v14 = *((void *)&v56 + 1);
          *(unsigned char *)(*((void *)&v56 + 1) + 24) |= 1u;
          *(_DWORD *)(v14 + 16) = 13;
          uint64_t v15 = a1[5];
          if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
          {
            uint64_t v26 = asString();
            *(_DWORD *)long long v69 = 136315138;
            uint64_t v70 = v26;
            _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "Sending Error [%s]", v69, 0xCu);
          }
          if (*((char *)a2 + 23) < 0)
          {
            sub_10004FC84(v28, *(void **)a2, *((void *)a2 + 1));
          }
          else
          {
            *(_OWORD *)unsigned __int8 v28 = *a2;
            uint64_t v29 = *((void *)a2 + 2);
          }
          if (*((char *)a2 + 47) < 0)
          {
            sub_10004FC84(&v30, *((void **)a2 + 3), *((void *)a2 + 4));
          }
          else
          {
            long long v30 = *(long long *)((char *)a2 + 24);
            uint64_t v31 = *((void *)a2 + 5);
          }
          __int16 v32 = *((_WORD *)a2 + 24);
          sub_10002FD9C(&v33, (const void **)a2 + 7);
          sub_100119B5C(&v34, (const void **)a2 + 8);
          v35[0] = *((void *)a2 + 9);
          *(void *)((char *)v35 + 6) = *(void *)((char *)a2 + 78);
          sub_1005D66F8((uint64_t)a1, (uint64_t)v28, (uint64_t)buf);
          sub_1000FE824(&v34);
          sub_100030068(&v33);
          if (SHIBYTE(v31) < 0) {
            operator delete((void *)v30);
          }
          if (SHIBYTE(v29) < 0) {
            operator delete(v28[0]);
          }
          sub_1000FE824((const void **)v48);
          sub_100030068((const void **)&v47 + 1);
          if (SHIBYTE(v46) < 0) {
            operator delete(v45[1]);
          }
          if (SHIBYTE(v45[0]) < 0) {
            operator delete(v44[0]);
          }
          sub_100917304((PB::Base *)buf);
        }
LABEL_64:
        sub_10004D2C8(v8);
        return;
      }
    }
  }
  else
  {
    CFDataRef v8 = 0;
  }
  *(void *)uint64_t buf = &off_101A1A658;
  long long v51 = 0u;
  long long v52 = 0u;
  long long v53 = 0u;
  long long v54 = 0u;
  long long v55 = 0u;
  long long v56 = 0u;
  long long v57 = 0u;
  long long v58 = 0u;
  long long v47 = 0u;
  *(_OWORD *)long long v48 = 0u;
  int v49 = 0;
  *(_OWORD *)uint64_t v45 = 0u;
  long long v46 = 0u;
  *(_OWORD *)uint64_t v44 = 0u;
  v48[8] = 2;
  *(void *)&v48[12] = 0x50000003CLL;
  sub_1009188C8((uint64_t)buf);
  uint64_t v12 = *((void *)&v56 + 1);
  *(unsigned char *)(*((void *)&v56 + 1) + 24) |= 1u;
  *(_DWORD *)(v12 + 16) = 18;
  unsigned int v13 = a1[5];
  if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
  {
    uint64_t v16 = asString();
    *(_DWORD *)long long v69 = 136315138;
    uint64_t v70 = v16;
    _os_log_error_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "Sending Error [%s]", v69, 0xCu);
  }
  if (*((char *)a2 + 23) < 0)
  {
    sub_10004FC84(__dst, *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    *(_OWORD *)long long __dst = *a2;
    uint64_t v37 = *((void *)a2 + 2);
  }
  if (*((char *)a2 + 47) < 0)
  {
    sub_10004FC84(&__p, *((void **)a2 + 3), *((void *)a2 + 4));
  }
  else
  {
    long long __p = *(long long *)((char *)a2 + 24);
    uint64_t v39 = *((void *)a2 + 5);
  }
  __int16 v40 = *((_WORD *)a2 + 24);
  sub_10002FD9C(&v41, (const void **)a2 + 7);
  sub_100119B5C(&v42, (const void **)a2 + 8);
  v43[0] = *((void *)a2 + 9);
  *(void *)((char *)v43 + 6) = *(void *)((char *)a2 + 78);
  sub_1005D66F8((uint64_t)a1, (uint64_t)__dst, (uint64_t)buf);
  sub_1000FE824(&v42);
  sub_100030068(&v41);
  if (SHIBYTE(v39) < 0) {
    operator delete((void *)__p);
  }
  if (SHIBYTE(v37) < 0) {
    operator delete(__dst[0]);
  }
  sub_1000FE824((const void **)v48);
  sub_100030068((const void **)&v47 + 1);
  if (SHIBYTE(v46) < 0) {
    operator delete(v45[1]);
  }
  if (SHIBYTE(v45[0]) < 0) {
    operator delete(v44[0]);
  }
  sub_100917304((PB::Base *)buf);
  if (v8) {
    goto LABEL_64;
  }
}

void sub_1005DB5D0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  if (SLOBYTE(STACK[0x20F]) < 0) {
    operator delete(__p);
  }
  if (a71) {
    std::__shared_weak_count::__release_weak(a71);
  }
  std::__shared_weak_count::__release_weak(v73);
  sub_10004D2C8(v72);
  _Unwind_Resume(a1);
}

void sub_1005DB6B4(void *a1, long long *a2, uint64_t a3)
{
  int v6 = a1[5];
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I [UpdateSubscriptionInfoReq]", buf, 2u);
  }
  char v7 = (std::__shared_weak_count *)a1[15];
  if (!v7)
  {
    uint64_t v10 = 0;
LABEL_23:
    *(void *)uint64_t buf = &off_101A1A658;
    long long v63 = 0u;
    long long v64 = 0u;
    long long v65 = 0u;
    long long v66 = 0u;
    long long v67 = 0u;
    long long v68 = 0u;
    long long v69 = 0u;
    long long v70 = 0u;
    long long v59 = 0u;
    *(_OWORD *)__int16 v60 = 0u;
    int v61 = 0;
    long long v58 = 0u;
    memset(__str, 0, sizeof(__str));
    v60[8] = 2;
    *(void *)&v60[12] = 0x50000003CLL;
    sub_100918C38((uint64_t)buf);
    uint64_t v26 = v70;
    *(unsigned char *)(v70 + 48) |= 1u;
    *(_DWORD *)(v26 + 40) = 18;
    unsigned int v27 = a1[5];
    if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
    {
      uint64_t v31 = asString();
      LODWORD(v84) = 136315138;
      *(void *)((char *)&v84 + 4) = v31;
      _os_log_error_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_ERROR, "Sending Error [%s]", (uint8_t *)&v84, 0xCu);
    }
    if (*((char *)a2 + 23) < 0)
    {
      sub_10004FC84(__dst, *(void **)a2, *((void *)a2 + 1));
    }
    else
    {
      *(_OWORD *)long long __dst = *a2;
      uint64_t v50 = *((void *)a2 + 2);
    }
    if (*((char *)a2 + 47) < 0)
    {
      sub_10004FC84(&__p, *((void **)a2 + 3), *((void *)a2 + 4));
    }
    else
    {
      long long __p = *(long long *)((char *)a2 + 24);
      uint64_t v52 = *((void *)a2 + 5);
    }
    __int16 v53 = *((_WORD *)a2 + 24);
    sub_10002FD9C(&v54, (const void **)a2 + 7);
    sub_100119B5C(&v55, (const void **)a2 + 8);
    v56[0] = *((void *)a2 + 9);
    *(void *)((char *)v56 + 6) = *(void *)((char *)a2 + 78);
    sub_1005D66F8((uint64_t)a1, (uint64_t)__dst, (uint64_t)buf);
    sub_1000FE824(&v55);
    sub_100030068(&v54);
    if (SHIBYTE(v52) < 0) {
      operator delete((void *)__p);
    }
    if ((SHIBYTE(v50) & 0x80000000) == 0) {
      goto LABEL_47;
    }
    unsigned __int8 v28 = __dst[0];
    goto LABEL_35;
  }
  CFDataRef v8 = std::__shared_weak_count::lock(v7);
  uint64_t v10 = v8;
  if (!v8) {
    goto LABEL_23;
  }
  uint64_t v11 = a1[14];
  if (!v11) {
    goto LABEL_23;
  }
  long long v86 = 0uLL;
  uint64_t v12 = *(long long ***)(*(void *)(a3 + 112) + 8);
  if (v12 && v12[1] == (long long *)16)
  {
    uint64_t v39 = v11;
    __int16 v40 = v8;
    long long v86 = **v12;
    memset(__str, 0, 24);
    ctu::hex((uint64_t *)__str, (ctu *)&v86, (const void *)0x10, v9);
    v85[0] = 0;
    long long v84 = 0uLL;
    uint64_t v13 = *(void *)(a3 + 112);
    uint64_t v14 = *(uint64_t **)(v13 + 16);
    uint64_t v15 = *(uint64_t **)(v13 + 24);
    if (v14 != v15)
    {
      do
      {
        uint64_t v16 = *v14;
        uint64_t v17 = *((void *)&v84 + 1);
        if (*((void *)&v84 + 1) >= v85[0])
        {
          unint64_t v19 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((void *)&v84 + 1) - v84) >> 6);
          unint64_t v20 = v19 + 1;
          if (v19 + 1 > 0x155555555555555) {
            sub_10006A748();
          }
          if (0x5555555555555556 * ((uint64_t)(v85[0] - v84) >> 6) > v20) {
            unint64_t v20 = 0x5555555555555556 * ((uint64_t)(v85[0] - v84) >> 6);
          }
          if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v85[0] - v84) >> 6) >= 0xAAAAAAAAAAAAAALL) {
            unint64_t v21 = 0x155555555555555;
          }
          else {
            unint64_t v21 = v20;
          }
          *((void *)&v64 + 1) = v85;
          uint64_t v22 = (char *)sub_10034036C((uint64_t)v85, v21);
          uint64_t v23 = &v22[192 * v19];
          *(void *)uint64_t buf = v22;
          *(void *)&long long v63 = v23;
          *(void *)&long long v64 = &v22[192 * v24];
          *(_OWORD *)uint64_t v23 = 0u;
          *((_OWORD *)v23 + 1) = 0u;
          *((_OWORD *)v23 + 2) = 0u;
          *((_OWORD *)v23 + 3) = 0u;
          *((_OWORD *)v23 + 4) = 0u;
          *((_OWORD *)v23 + 5) = 0u;
          *((_OWORD *)v23 + 6) = 0u;
          *((_OWORD *)v23 + 7) = 0u;
          *((_OWORD *)v23 + 8) = 0u;
          *((_OWORD *)v23 + 9) = 0u;
          *((_OWORD *)v23 + 10) = 0u;
          *((_OWORD *)v23 + 11) = 0u;
          v23[185] = 1;
          *((void *)&v63 + 1) = v23 + 192;
          sub_1003DBD8C((uint64_t *)&v84, buf);
          uint64_t v18 = *((void *)&v84 + 1);
          sub_1003DBEF8((uint64_t)buf);
        }
        else
        {
          *(_OWORD *)(*((void *)&v84 + 1) + 160) = 0u;
          *(_OWORD *)(v17 + 176) = 0u;
          *(_OWORD *)(v17 + 128) = 0u;
          *(_OWORD *)(v17 + 144) = 0u;
          *(_OWORD *)(v17 + 96) = 0u;
          *(_OWORD *)(v17 + 112) = 0u;
          *(_OWORD *)(v17 + 64) = 0u;
          *(_OWORD *)(v17 + 80) = 0u;
          *(_OWORD *)(v17 + 32) = 0u;
          *(_OWORD *)(v17 + 48) = 0u;
          *(_OWORD *)uint64_t v17 = 0u;
          *(_OWORD *)(v17 + 16) = 0u;
          uint64_t v18 = v17 + 192;
          *(unsigned char *)(v17 + 185) = 1;
        }
        *((void *)&v84 + 1) = v18;
        std::string::operator=((std::string *)(v18 - 184), (const std::string *)__str);
        sub_100879BA0(v16, v18 - 192);
        ++v14;
      }
      while (v14 != v15);
      uint64_t v13 = *(void *)(a3 + 112);
    }
    BOOL v25 = (*(unsigned char *)(v13 + 44) & 1) != 0 && *(unsigned __int8 *)(v13 + 40) != 0;
    *(void *)&long long v71 = a1;
    __int16 v32 = (std::__shared_weak_count *)a1[2];
    if (!v32 || (uint64_t v33 = a1[1], (v34 = std::__shared_weak_count::lock(v32)) == 0)) {
      sub_100088B9C();
    }
    *((void *)&v71 + 1) = v33;
    uint64_t v72 = v34;
    atomic_fetch_add_explicit(&v34->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v34);
    long long v73 = v86;
    if (*((char *)a2 + 23) < 0)
    {
      sub_10004FC84(&v74, *(void **)a2, *((void *)a2 + 1));
    }
    else
    {
      long long v74 = *a2;
      uint64_t v75 = *((void *)a2 + 2);
    }
    if (*((char *)a2 + 47) < 0)
    {
      sub_10004FC84(&__src, *((void **)a2 + 3), *((void *)a2 + 4));
    }
    else
    {
      long long __src = *(long long *)((char *)a2 + 24);
      uint64_t v77 = *((void *)a2 + 5);
    }
    __int16 v78 = *((_WORD *)a2 + 24);
    sub_10002FD9C(&v79, (const void **)a2 + 7);
    sub_100119B5C(&v80, (const void **)a2 + 8);
    v81[0] = *((void *)a2 + 9);
    *(void *)((char *)v81 + 6) = *(void *)((char *)a2 + 78);
    __int16 v83 = 0;
    uint64_t v35 = (char *)operator new(0x88uLL);
    uint64_t v36 = v35;
    *(void *)uint64_t v35 = off_1019ED200;
    *(_OWORD *)(v35 + 8) = v71;
    *((void *)v35 + 3) = v72;
    *((void *)&v71 + 1) = 0;
    uint64_t v72 = 0;
    *((_OWORD *)v35 + 2) = v73;
    if (SHIBYTE(v75) < 0)
    {
      sub_10004FC84(v35 + 48, (void *)v74, *((unint64_t *)&v74 + 1));
    }
    else
    {
      *((_OWORD *)v35 + 3) = v74;
      *((void *)v35 + 8) = v75;
    }
    uint64_t v37 = v36 + 72;
    if (SHIBYTE(v77) < 0)
    {
      uint64_t v10 = v40;
      sub_10004FC84(v37, (void *)__src, *((unint64_t *)&__src + 1));
    }
    else
    {
      *(_OWORD *)uint64_t v37 = __src;
      *((void *)v36 + 11) = v77;
      uint64_t v10 = v40;
    }
    *((_WORD *)v36 + 48) = v78;
    sub_10002FD9C((const void **)v36 + 13, &v79);
    sub_100119B5C((const void **)v36 + 14, &v80);
    *((void *)v36 + 15) = v81[0];
    *(void *)(v36 + 126) = *(void *)((char *)v81 + 6);
    __int16 v83 = v36;
    (*(void (**)(uint64_t, long long *, BOOL, void *))(*(void *)v39 + 112))(v39, &v84, v25, v82);
    sub_1005E6B5C(v82);
    sub_1000FE824(&v80);
    sub_100030068(&v79);
    if (SHIBYTE(v77) < 0) {
      operator delete((void *)__src);
    }
    if (SHIBYTE(v75) < 0) {
      operator delete((void *)v74);
    }
    if (v72) {
      std::__shared_weak_count::__release_weak(v72);
    }
    *(void *)uint64_t buf = &v84;
    sub_10023FDC8((void ***)buf);
    if ((__str[23] & 0x80000000) != 0) {
      operator delete(*(void **)__str);
    }
    goto LABEL_52;
  }
  *(void *)uint64_t buf = &off_101A1A658;
  long long v63 = 0u;
  long long v64 = 0u;
  long long v65 = 0u;
  long long v66 = 0u;
  long long v67 = 0u;
  long long v68 = 0u;
  long long v69 = 0u;
  long long v70 = 0u;
  long long v59 = 0u;
  *(_OWORD *)__int16 v60 = 0u;
  int v61 = 0;
  long long v58 = 0u;
  memset(__str, 0, sizeof(__str));
  v60[8] = 2;
  *(void *)&v60[12] = 0x50000003CLL;
  sub_100918C38((uint64_t)buf);
  uint64_t v29 = v70;
  *(unsigned char *)(v70 + 48) |= 1u;
  *(_DWORD *)(v29 + 40) = 18;
  long long v30 = a1[5];
  if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
  {
    uint64_t v38 = asString();
    LODWORD(v84) = 136315138;
    *(void *)((char *)&v84 + 4) = v38;
    _os_log_error_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_ERROR, "Sending Error [%s]", (uint8_t *)&v84, 0xCu);
  }
  if (*((char *)a2 + 23) < 0)
  {
    sub_10004FC84(&v41, *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v41 = *a2;
    uint64_t v42 = *((void *)a2 + 2);
  }
  if (*((char *)a2 + 47) < 0)
  {
    sub_10004FC84(&v43, *((void **)a2 + 3), *((void *)a2 + 4));
  }
  else
  {
    long long v43 = *(long long *)((char *)a2 + 24);
    uint64_t v44 = *((void *)a2 + 5);
  }
  __int16 v45 = *((_WORD *)a2 + 24);
  sub_10002FD9C(&v46, (const void **)a2 + 7);
  sub_100119B5C(&v47, (const void **)a2 + 8);
  v48[0] = *((void *)a2 + 9);
  *(void *)((char *)v48 + 6) = *(void *)((char *)a2 + 78);
  sub_1005D66F8((uint64_t)a1, (uint64_t)&v41, (uint64_t)buf);
  sub_1000FE824(&v47);
  sub_100030068(&v46);
  if (SHIBYTE(v44) < 0) {
    operator delete((void *)v43);
  }
  if (SHIBYTE(v42) < 0)
  {
    unsigned __int8 v28 = (void *)v41;
LABEL_35:
    operator delete(v28);
  }
LABEL_47:
  sub_1000FE824((const void **)v60);
  sub_100030068((const void **)&v59 + 1);
  if (SHIBYTE(v58) < 0) {
    operator delete(*(void **)&__str[24]);
  }
  if ((__str[23] & 0x80000000) != 0) {
    operator delete(*(void **)__str);
  }
  sub_100917304((PB::Base *)buf);
LABEL_52:
  if (v10) {
    sub_10004D2C8(v10);
  }
}

void sub_1005DBF74(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, std::__shared_weak_count *a10, void *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,void *__p,uint64_t a36,int a37,__int16 a38,char a39,char a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  if (*(char *)(v68 + 71) < 0) {
    operator delete(*v69);
  }
  uint64_t v72 = *(std::__shared_weak_count **)(v68 + 24);
  if (v72) {
    std::__shared_weak_count::__release_weak(v72);
  }
  operator delete((void *)v68);
  sub_1005E2400((uint64_t)&a68);
  a67 = v70 - 160;
  sub_10023FDC8((void ***)&a67);
  if (a40 < 0) {
    operator delete(__p);
  }
  if (a10) {
    sub_10004D2C8(a10);
  }
  _Unwind_Resume(a1);
}

void sub_1005DC0D0(void *a1, long long *a2, uint64_t a3)
{
  int v6 = a1[5];
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I [FetchSubscriptionInfoReq]", buf, 2u);
  }
  char v7 = (std::__shared_weak_count *)a1[15];
  if (v7)
  {
    CFDataRef v8 = std::__shared_weak_count::lock(v7);
    if (v8)
    {
      uint64_t v9 = a1[14];
      if (v9)
      {
        uint64_t v10 = *(void *)(a3 + 48);
        uint64_t v11 = *(void *)(v10 + 8);
        if (v11 && *(void *)(v11 + 8) == 16)
        {
          *(_OWORD *)__int16 v83 = *(_OWORD *)*(void *)v11;
          uint64_t v12 = *(void *)(v10 + 16);
          if (v12)
          {
            uint64_t v13 = (std::__shared_weak_count *)a1[2];
            if (!v13 || (uint64_t v14 = (std::__shared_weak_count *)a1[1], (v15 = std::__shared_weak_count::lock(v13)) == 0)) {
              sub_100088B9C();
            }
            v68[0] = v14;
            v68[1] = v15;
            atomic_fetch_add_explicit(&v15->__shared_weak_owners_, 1uLL, memory_order_relaxed);
            sub_10004D2C8(v15);
            long long v69 = a1;
            if (*((char *)a2 + 23) < 0)
            {
              sub_10004FC84(&__src, *(void **)a2, *((void *)a2 + 1));
            }
            else
            {
              long long __src = *a2;
              uint64_t v71 = *((void *)a2 + 2);
            }
            if (*((char *)a2 + 47) < 0)
            {
              sub_10004FC84(&v72, *((void **)a2 + 3), *((void *)a2 + 4));
            }
            else
            {
              long long v72 = *(long long *)((char *)a2 + 24);
              uint64_t v73 = *((void *)a2 + 5);
            }
            __int16 v74 = *((_WORD *)a2 + 24);
            sub_10002FD9C(&v75, (const void **)a2 + 7);
            sub_100119B5C(&v76, (const void **)a2 + 8);
            v77[0] = *((void *)a2 + 9);
            *(void *)((char *)v77 + 6) = *(void *)((char *)a2 + 78);
            long long v78 = *(_OWORD *)v83;
            uint64_t v80 = 0;
            uint64_t v24 = (char *)operator new(0x88uLL);
            BOOL v25 = v24;
            *(void *)uint64_t v24 = off_1019ED290;
            *(_OWORD *)(v24 + 8) = *(_OWORD *)v68;
            v68[0] = 0;
            v68[1] = 0;
            *((void *)v24 + 3) = v69;
            if (SHIBYTE(v71) < 0)
            {
              sub_10004FC84(v24 + 32, (void *)__src, *((unint64_t *)&__src + 1));
            }
            else
            {
              *((_OWORD *)v24 + 2) = __src;
              *((void *)v24 + 6) = v71;
            }
            uint64_t v26 = v25 + 56;
            if (SHIBYTE(v73) < 0)
            {
              sub_10004FC84(v26, (void *)v72, *((unint64_t *)&v72 + 1));
            }
            else
            {
              *(_OWORD *)uint64_t v26 = v72;
              *((void *)v25 + 9) = v73;
            }
            *((_WORD *)v25 + 40) = v74;
            sub_10002FD9C((const void **)v25 + 11, &v75);
            sub_100119B5C((const void **)v25 + 12, &v76);
            *((void *)v25 + 13) = v77[0];
            *(void *)(v25 + 110) = *(void *)((char *)v77 + 6);
            *(_OWORD *)(v25 + 120) = v78;
            uint64_t v80 = v25;
            (*(void (**)(uint64_t, uint8_t *, uint64_t, void *))(*(void *)v9 + 120))(v9, v83, v12, v79);
            sub_10037DCD8(v79);
            sub_1000FE824(&v76);
            sub_100030068(&v75);
            if (SHIBYTE(v73) < 0) {
              operator delete((void *)v72);
            }
            if (SHIBYTE(v71) < 0) {
              operator delete((void *)__src);
            }
            if (v68[1]) {
              std::__shared_weak_count::__release_weak(v68[1]);
            }
LABEL_50:
            sub_10004D2C8(v8);
            return;
          }
          *(void *)uint64_t buf = &off_101A1A658;
          long long v60 = 0u;
          long long v61 = 0u;
          long long v62 = 0u;
          long long v63 = 0u;
          long long v64 = 0u;
          long long v65 = 0u;
          long long v66 = 0u;
          long long v67 = 0u;
          long long v56 = 0u;
          *(_OWORD *)long long v57 = 0u;
          int v58 = 0;
          *(_OWORD *)long long v54 = 0u;
          long long v55 = 0u;
          *(_OWORD *)__int16 v53 = 0u;
          v57[8] = 2;
          *(void *)&v57[12] = 0x50000003CLL;
          sub_100918CF0((uint64_t)buf);
          uint64_t v22 = v63;
          *(unsigned char *)(v63 + 32) |= 1u;
          *(_DWORD *)(v22 + 24) = 1;
          uint64_t v23 = a1[5];
          if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
          {
            uint64_t v28 = asString();
            *(_DWORD *)long long v81 = 136315138;
            uint64_t v82 = v28;
            _os_log_error_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_ERROR, "Sending Error [%s]", v81, 0xCu);
          }
          if (*((char *)a2 + 23) < 0)
          {
            sub_10004FC84(&v29, *(void **)a2, *((void *)a2 + 1));
          }
          else
          {
            long long v29 = *a2;
            uint64_t v30 = *((void *)a2 + 2);
          }
          if (*((char *)a2 + 47) < 0)
          {
            sub_10004FC84(&v31, *((void **)a2 + 3), *((void *)a2 + 4));
          }
          else
          {
            long long v31 = *(long long *)((char *)a2 + 24);
            uint64_t v32 = *((void *)a2 + 5);
          }
          __int16 v33 = *((_WORD *)a2 + 24);
          sub_10002FD9C(&v34, (const void **)a2 + 7);
          sub_100119B5C(&v35, (const void **)a2 + 8);
          v36[0] = *((void *)a2 + 9);
          *(void *)((char *)v36 + 6) = *(void *)((char *)a2 + 78);
          sub_1005D66F8((uint64_t)a1, (uint64_t)&v29, (uint64_t)buf);
          sub_1000FE824(&v35);
          sub_100030068(&v34);
          if (SHIBYTE(v32) < 0) {
            operator delete((void *)v31);
          }
          if ((SHIBYTE(v30) & 0x80000000) == 0)
          {
LABEL_45:
            sub_1000FE824((const void **)v57);
            sub_100030068((const void **)&v56 + 1);
            if (SHIBYTE(v55) < 0) {
              operator delete(v54[1]);
            }
            if (SHIBYTE(v54[0]) < 0) {
              operator delete(v53[0]);
            }
            sub_100917304((PB::Base *)buf);
            goto LABEL_50;
          }
          unint64_t v20 = (void *)v29;
        }
        else
        {
          *(void *)uint64_t buf = &off_101A1A658;
          long long v60 = 0u;
          long long v61 = 0u;
          long long v62 = 0u;
          long long v63 = 0u;
          long long v64 = 0u;
          long long v65 = 0u;
          long long v66 = 0u;
          long long v67 = 0u;
          long long v56 = 0u;
          *(_OWORD *)long long v57 = 0u;
          int v58 = 0;
          *(_OWORD *)long long v54 = 0u;
          long long v55 = 0u;
          *(_OWORD *)__int16 v53 = 0u;
          v57[8] = 2;
          *(void *)&v57[12] = 0x50000003CLL;
          sub_100918CF0((uint64_t)buf);
          uint64_t v18 = v63;
          *(unsigned char *)(v63 + 32) |= 1u;
          *(_DWORD *)(v18 + 24) = 1;
          unint64_t v19 = a1[5];
          if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
          {
            uint64_t v27 = asString();
            *(_DWORD *)long long v81 = 136315138;
            uint64_t v82 = v27;
            _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Sending Error [%s]", v81, 0xCu);
          }
          if (*((char *)a2 + 23) < 0)
          {
            sub_10004FC84(v37, *(void **)a2, *((void *)a2 + 1));
          }
          else
          {
            *(_OWORD *)uint64_t v37 = *a2;
            uint64_t v38 = *((void *)a2 + 2);
          }
          if (*((char *)a2 + 47) < 0)
          {
            sub_10004FC84(&v39, *((void **)a2 + 3), *((void *)a2 + 4));
          }
          else
          {
            long long v39 = *(long long *)((char *)a2 + 24);
            uint64_t v40 = *((void *)a2 + 5);
          }
          __int16 v41 = *((_WORD *)a2 + 24);
          sub_10002FD9C(&v42, (const void **)a2 + 7);
          sub_100119B5C(&v43, (const void **)a2 + 8);
          v44[0] = *((void *)a2 + 9);
          *(void *)((char *)v44 + 6) = *(void *)((char *)a2 + 78);
          sub_1005D66F8((uint64_t)a1, (uint64_t)v37, (uint64_t)buf);
          sub_1000FE824(&v43);
          sub_100030068(&v42);
          if (SHIBYTE(v40) < 0) {
            operator delete((void *)v39);
          }
          if ((SHIBYTE(v38) & 0x80000000) == 0) {
            goto LABEL_45;
          }
          unint64_t v20 = v37[0];
        }
        operator delete(v20);
        goto LABEL_45;
      }
    }
  }
  else
  {
    CFDataRef v8 = 0;
  }
  *(void *)uint64_t buf = &off_101A1A658;
  long long v60 = 0u;
  long long v61 = 0u;
  long long v62 = 0u;
  long long v63 = 0u;
  long long v64 = 0u;
  long long v65 = 0u;
  long long v66 = 0u;
  long long v67 = 0u;
  long long v56 = 0u;
  *(_OWORD *)long long v57 = 0u;
  int v58 = 0;
  *(_OWORD *)long long v54 = 0u;
  long long v55 = 0u;
  *(_OWORD *)__int16 v53 = 0u;
  v57[8] = 2;
  *(void *)&v57[12] = 0x50000003CLL;
  sub_100918CF0((uint64_t)buf);
  uint64_t v16 = v63;
  *(unsigned char *)(v63 + 32) |= 1u;
  *(_DWORD *)(v16 + 24) = 18;
  uint64_t v17 = a1[5];
  if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
  {
    uint64_t v21 = asString();
    *(_DWORD *)__int16 v83 = 136315138;
    *(void *)&v83[4] = v21;
    _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "Sending Error [%s]", v83, 0xCu);
  }
  if (*((char *)a2 + 23) < 0)
  {
    sub_10004FC84(__dst, *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    *(_OWORD *)long long __dst = *a2;
    uint64_t v46 = *((void *)a2 + 2);
  }
  if (*((char *)a2 + 47) < 0)
  {
    sub_10004FC84(&__p, *((void **)a2 + 3), *((void *)a2 + 4));
  }
  else
  {
    long long __p = *(long long *)((char *)a2 + 24);
    uint64_t v48 = *((void *)a2 + 5);
  }
  __int16 v49 = *((_WORD *)a2 + 24);
  sub_10002FD9C(&v50, (const void **)a2 + 7);
  sub_100119B5C(&v51, (const void **)a2 + 8);
  v52[0] = *((void *)a2 + 9);
  *(void *)((char *)v52 + 6) = *(void *)((char *)a2 + 78);
  sub_1005D66F8((uint64_t)a1, (uint64_t)__dst, (uint64_t)buf);
  sub_1000FE824(&v51);
  sub_100030068(&v50);
  if (SHIBYTE(v48) < 0) {
    operator delete((void *)__p);
  }
  if (SHIBYTE(v46) < 0) {
    operator delete(__dst[0]);
  }
  sub_1000FE824((const void **)v57);
  sub_100030068((const void **)&v56 + 1);
  if (SHIBYTE(v55) < 0) {
    operator delete(v54[1]);
  }
  if (SHIBYTE(v54[0]) < 0) {
    operator delete(v53[0]);
  }
  sub_100917304((PB::Base *)buf);
  if (v8) {
    goto LABEL_50;
  }
}

void sub_1005DC9D0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,void *a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,char a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,char a62)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  sub_1003C1D74((uint64_t)&a50);
  sub_100917304((PB::Base *)&a62);
  sub_10004D2C8(v62);
  _Unwind_Resume(a1);
}

void sub_1005DCB18(void *a1, long long *a2, uint64_t a3)
{
  int v6 = a1[5];
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I [PendingProfilesReq]", buf, 2u);
  }
  char v7 = (std::__shared_weak_count *)a1[15];
  if (v7)
  {
    CFDataRef v8 = std::__shared_weak_count::lock(v7);
    if (v8)
    {
      uint64_t v9 = a1[14];
      if (v9)
      {
        uint64_t v10 = *(void *)(*(void *)(a3 + 64) + 8);
        if (v10 && *(void *)(v10 + 8) == 16)
        {
          *(_OWORD *)long long v72 = *(_OWORD *)*(void *)v10;
          uint64_t v11 = (std::__shared_weak_count *)a1[2];
          if (!v11 || (uint64_t v12 = std::__shared_weak_count::lock(v11)) == 0) {
            sub_100088B9C();
          }
          uint64_t v13 = v12;
          atomic_fetch_add_explicit(&v12->__shared_weak_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v12);
          *(void *)&long long v57 = a1;
          uint64_t v14 = (std::__shared_weak_count *)a1[2];
          if (!v14 || (uint64_t v15 = a1[1], (v16 = std::__shared_weak_count::lock(v14)) == 0)) {
            sub_100088B9C();
          }
          *((void *)&v57 + 1) = v15;
          int v58 = v16;
          atomic_fetch_add_explicit(&v16->__shared_weak_owners_, 1uLL, memory_order_relaxed);
          sub_10004D2C8(v16);
          long long v59 = *(_OWORD *)v72;
          if (*((char *)a2 + 23) < 0)
          {
            sub_10004FC84(&v60, *(void **)a2, *((void *)a2 + 1));
          }
          else
          {
            long long v60 = *a2;
            uint64_t v61 = *((void *)a2 + 2);
          }
          if (*((char *)a2 + 47) < 0)
          {
            sub_10004FC84(&__src, *((void **)a2 + 3), *((void *)a2 + 4));
          }
          else
          {
            long long __src = *(long long *)((char *)a2 + 24);
            uint64_t v63 = *((void *)a2 + 5);
          }
          __int16 v64 = *((_WORD *)a2 + 24);
          sub_10002FD9C(&v65, (const void **)a2 + 7);
          sub_100119B5C(&v66, (const void **)a2 + 8);
          v67[0] = *((void *)a2 + 9);
          *(void *)((char *)v67 + 6) = *(void *)((char *)a2 + 78);
          long long v69 = 0;
          uint64_t v22 = (char *)operator new(0x88uLL);
          uint64_t v23 = v22;
          *(void *)uint64_t v22 = off_1019ED310;
          *(_OWORD *)(v22 + 8) = v57;
          *((void *)v22 + 3) = v58;
          *((void *)&v57 + 1) = 0;
          int v58 = 0;
          *((_OWORD *)v22 + 2) = v59;
          if (SHIBYTE(v61) < 0)
          {
            sub_10004FC84(v22 + 48, (void *)v60, *((unint64_t *)&v60 + 1));
          }
          else
          {
            *((_OWORD *)v22 + 3) = v60;
            *((void *)v22 + 8) = v61;
          }
          uint64_t v24 = v23 + 72;
          if (SHIBYTE(v63) < 0)
          {
            sub_10004FC84(v24, (void *)__src, *((unint64_t *)&__src + 1));
          }
          else
          {
            *(_OWORD *)uint64_t v24 = __src;
            *((void *)v23 + 11) = v63;
          }
          *((_WORD *)v23 + 48) = v64;
          sub_10002FD9C((const void **)v23 + 13, &v65);
          sub_100119B5C((const void **)v23 + 14, &v66);
          *((void *)v23 + 15) = v67[0];
          *(void *)(v23 + 126) = *(void *)((char *)v67 + 6);
          long long v69 = v23;
          (*(void (**)(uint64_t, void *))(*(void *)v9 + 128))(v9, v68);
          sub_1005E862C(v68);
          sub_1000FE824(&v66);
          sub_100030068(&v65);
          if (SHIBYTE(v63) < 0) {
            operator delete((void *)__src);
          }
          if (SHIBYTE(v61) < 0) {
            operator delete((void *)v60);
          }
          if (v58) {
            std::__shared_weak_count::__release_weak(v58);
          }
          std::__shared_weak_count::__release_weak(v13);
        }
        else
        {
          *(void *)uint64_t buf = &off_101A1A658;
          long long v49 = 0u;
          long long v50 = 0u;
          long long v51 = 0u;
          long long v52 = 0u;
          long long v53 = 0u;
          long long v54 = 0u;
          long long v55 = 0u;
          long long v56 = 0u;
          long long v45 = 0u;
          *(_OWORD *)uint64_t v46 = 0u;
          int v47 = 0;
          *(_OWORD *)long long v43 = 0u;
          long long v44 = 0u;
          *(_OWORD *)uint64_t v42 = 0u;
          v46[8] = 2;
          *(void *)&v46[12] = 0x50000003CLL;
          sub_100918DA0((uint64_t)buf);
          uint64_t v19 = v53;
          *(unsigned char *)(v53 + 48) |= 1u;
          *(_DWORD *)(v19 + 40) = 13;
          unint64_t v20 = a1[5];
          if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
          {
            uint64_t v25 = asString();
            *(_DWORD *)uint64_t v70 = 136315138;
            uint64_t v71 = v25;
            _os_log_error_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, "Sending Error [%s]", v70, 0xCu);
          }
          if (*((char *)a2 + 23) < 0)
          {
            sub_10004FC84(v26, *(void **)a2, *((void *)a2 + 1));
          }
          else
          {
            *(_OWORD *)uint64_t v26 = *a2;
            uint64_t v27 = *((void *)a2 + 2);
          }
          if (*((char *)a2 + 47) < 0)
          {
            sub_10004FC84(&v28, *((void **)a2 + 3), *((void *)a2 + 4));
          }
          else
          {
            long long v28 = *(long long *)((char *)a2 + 24);
            uint64_t v29 = *((void *)a2 + 5);
          }
          __int16 v30 = *((_WORD *)a2 + 24);
          sub_10002FD9C(&v31, (const void **)a2 + 7);
          sub_100119B5C(&v32, (const void **)a2 + 8);
          v33[0] = *((void *)a2 + 9);
          *(void *)((char *)v33 + 6) = *(void *)((char *)a2 + 78);
          sub_1005D66F8((uint64_t)a1, (uint64_t)v26, (uint64_t)buf);
          sub_1000FE824(&v32);
          sub_100030068(&v31);
          if (SHIBYTE(v29) < 0) {
            operator delete((void *)v28);
          }
          if (SHIBYTE(v27) < 0) {
            operator delete(v26[0]);
          }
          sub_1000FE824((const void **)v46);
          sub_100030068((const void **)&v45 + 1);
          if (SHIBYTE(v44) < 0) {
            operator delete(v43[1]);
          }
          if (SHIBYTE(v43[0]) < 0) {
            operator delete(v42[0]);
          }
          sub_100917304((PB::Base *)buf);
        }
LABEL_67:
        sub_10004D2C8(v8);
        return;
      }
    }
  }
  else
  {
    CFDataRef v8 = 0;
  }
  *(void *)uint64_t buf = &off_101A1A658;
  long long v49 = 0u;
  long long v50 = 0u;
  long long v51 = 0u;
  long long v52 = 0u;
  long long v53 = 0u;
  long long v54 = 0u;
  long long v55 = 0u;
  long long v56 = 0u;
  long long v45 = 0u;
  *(_OWORD *)uint64_t v46 = 0u;
  int v47 = 0;
  *(_OWORD *)long long v43 = 0u;
  long long v44 = 0u;
  *(_OWORD *)uint64_t v42 = 0u;
  v46[8] = 2;
  *(void *)&v46[12] = 0x50000003CLL;
  sub_100918DA0((uint64_t)buf);
  uint64_t v17 = v53;
  *(unsigned char *)(v53 + 48) |= 1u;
  *(_DWORD *)(v17 + 40) = 18;
  uint64_t v18 = a1[5];
  if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
  {
    uint64_t v21 = asString();
    *(_DWORD *)long long v72 = 136315138;
    *(void *)&v72[4] = v21;
    _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "Sending Error [%s]", v72, 0xCu);
  }
  if (*((char *)a2 + 23) < 0)
  {
    sub_10004FC84(__dst, *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    *(_OWORD *)long long __dst = *a2;
    uint64_t v35 = *((void *)a2 + 2);
  }
  if (*((char *)a2 + 47) < 0)
  {
    sub_10004FC84(&__p, *((void **)a2 + 3), *((void *)a2 + 4));
  }
  else
  {
    long long __p = *(long long *)((char *)a2 + 24);
    uint64_t v37 = *((void *)a2 + 5);
  }
  __int16 v38 = *((_WORD *)a2 + 24);
  sub_10002FD9C(&v39, (const void **)a2 + 7);
  sub_100119B5C(&v40, (const void **)a2 + 8);
  v41[0] = *((void *)a2 + 9);
  *(void *)((char *)v41 + 6) = *(void *)((char *)a2 + 78);
  sub_1005D66F8((uint64_t)a1, (uint64_t)__dst, (uint64_t)buf);
  sub_1000FE824(&v40);
  sub_100030068(&v39);
  if (SHIBYTE(v37) < 0) {
    operator delete((void *)__p);
  }
  if (SHIBYTE(v35) < 0) {
    operator delete(__dst[0]);
  }
  sub_1000FE824((const void **)v46);
  sub_100030068((const void **)&v45 + 1);
  if (SHIBYTE(v44) < 0) {
    operator delete(v43[1]);
  }
  if (SHIBYTE(v43[0]) < 0) {
    operator delete(v42[0]);
  }
  sub_100917304((PB::Base *)buf);
  if (v8) {
    goto LABEL_67;
  }
}

void sub_1005DD288(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, std::__shared_weak_count *a10, void *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  if (*(char *)(v66 + 71) < 0) {
    operator delete(*v67);
  }
  long long v69 = *(std::__shared_weak_count **)(v66 + 24);
  if (v69) {
    std::__shared_weak_count::__release_weak(v69);
  }
  operator delete((void *)v66);
  sub_1005E2400((uint64_t)&a65);
  std::__shared_weak_count::__release_weak(a10);
  sub_10004D2C8(v65);
  _Unwind_Resume(a1);
}

void sub_1005DD3B8(uint64_t a1, long long *a2, uint64_t a3)
{
  int v6 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I [PurchaseAddOnPlanReq]", buf, 2u);
  }
  char v7 = *(std::__shared_weak_count **)(a1 + 120);
  if (v7)
  {
    CFDataRef v8 = std::__shared_weak_count::lock(v7);
    if (v8)
    {
      uint64_t v9 = *(void *)(a1 + 112);
      if (v9)
      {
        long long v113 = 0u;
        long long v114 = 0u;
        long long v111 = 0u;
        long long v112 = 0u;
        long long v109 = 0u;
        long long v110 = 0u;
        memset(v108, 0, sizeof(v108));
        long long v106 = 0u;
        long long v107 = 0u;
        long long v104 = 0u;
        long long v105 = 0u;
        uint64_t v10 = *(void *)(*(void *)(a3 + 72) + 8);
        if (v10)
        {
          if (*(char *)(v10 + 23) < 0)
          {
            if (*(void *)(v10 + 8)) {
              goto LABEL_9;
            }
          }
          else if (*(unsigned char *)(v10 + 23))
          {
LABEL_9:
            std::string::operator=((std::string *)&v104, (const std::string *)v10);
            long long v97 = 0uLL;
            uint64_t v11 = *(long long ***)(*(void *)(a3 + 72) + 16);
            if (v11 && v11[1] == (long long *)16)
            {
              long long v97 = **v11;
              long long v107 = v97;
              *(void *)uint64_t buf = &v97;
              uint64_t v12 = (std::string *)sub_1003DE940((uint64_t **)(a1 + 160), (uint64_t)&v97, (uint64_t)&unk_10144E20E, (_OWORD **)buf);
              std::string::operator=(v12 + 2, (const std::string *)a2);
              uint64_t v13 = *(void *)(a3 + 72);
              if ((long long *)((char *)&v105 + 8) != (long long *)(v13 + 48))
              {
                sub_10005CA3C((uint64_t)&v105 + 8, *(std::string **)(v13 + 48), *(long long **)(v13 + 56), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(v13 + 56) - *(void *)(v13 + 48)) >> 3));
                uint64_t v13 = *(void *)(a3 + 72);
              }
              uint64_t v14 = *(const std::string **)(v13 + 72);
              if (v14)
              {
                std::string::operator=((std::string *)v108, v14);
                uint64_t v15 = *(void **)(a3 + 72);
                uint64_t v16 = (const std::string *)v15[10];
                if (v16)
                {
                  std::string::operator=((std::string *)&v108[24], v16);
                  uint64_t v15 = *(void **)(a3 + 72);
                }
                if (v15[5])
                {
                  uint64_t v17 = (const std::string *)v15[3];
                  if (v17)
                  {
                    std::string::operator=((std::string *)((char *)&v111 + 8), v17);
                    std::string::operator=((std::string *)&v110, *(const std::string **)(*(void *)(a3 + 72) + 40));
                    std::string::operator=((std::string *)&v113, *(const std::string **)(*(void *)(a3 + 72) + 88));
                    uint64_t v18 = *(int32x2_t **)(a3 + 72);
                    if ((~v18[13].u8[0] & 3) == 0)
                    {
                      *((int32x2_t *)&v114 + 1) = vrev64_s32(v18[12]);
                      *(void *)uint64_t buf = a1;
                      *(void *)&long long v86 = v9;
                      *((void *)&v86 + 1) = v8;
                      atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
                      sub_10032A144((char *)&v87, &v104);
                      sub_1005D4D64(v94, a2);
                      sub_1005E24C0(a1 + 8);
                    }
                    __int16 v38 = *(NSObject **)(a1 + 40);
                    if (os_log_type_enabled(v38, OS_LOG_TYPE_ERROR))
                    {
                      *(_WORD *)uint64_t buf = 0;
                      _os_log_error_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_ERROR, "No Gsma version or Sim alliance profile version", buf, 2u);
                    }
                    *(void *)uint64_t buf = &off_101A1A658;
                    long long v86 = 0u;
                    long long v87 = 0u;
                    long long v88 = 0u;
                    long long v89 = 0u;
                    long long v90 = 0u;
                    long long v91 = 0u;
                    long long v92 = 0u;
                    long long v93 = 0u;
                    long long v101 = 0u;
                    *(_OWORD *)long long v102 = 0u;
                    int v103 = 0;
                    long long v99 = 0u;
                    long long v100 = 0u;
                    long long v98 = 0u;
                    v102[8] = 2;
                    *(void *)&v102[12] = 0x50000003CLL;
                    sub_100918E58((uint64_t)buf);
                    uint64_t v39 = *((void *)&v90 + 1);
                    *(unsigned char *)(*((void *)&v90 + 1) + 12) |= 1u;
                    *(_DWORD *)(v39 + 8) = 6;
                    uint64_t v40 = *(NSObject **)(a1 + 40);
                    if (os_log_type_enabled(v40, OS_LOG_TYPE_ERROR))
                    {
                      uint64_t v43 = asString();
                      *(_DWORD *)long long v95 = 136315138;
                      uint64_t v96 = v43;
                      _os_log_error_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_ERROR, "Sending Error [%s]", v95, 0xCu);
                    }
                    sub_1005D4D64(v44, a2);
                    sub_1005D66F8(a1, (uint64_t)v44, (uint64_t)buf);
                    sub_1003C1D74((uint64_t)v44);
                    sub_1003C1D74((uint64_t)&v98);
LABEL_75:
                    sub_100917304((PB::Base *)buf);
                    if (SBYTE7(v114) < 0) {
                      operator delete((void *)v113);
                    }
                    if (SHIBYTE(v112) < 0) {
                      operator delete(*((void **)&v111 + 1));
                    }
                    if (SBYTE7(v111) < 0) {
                      operator delete((void *)v110);
                    }
                    if (SHIBYTE(v109) < 0) {
                      operator delete(*(void **)&v108[24]);
                    }
                    if ((v108[23] & 0x80000000) != 0) {
                      operator delete(*(void **)v108);
                    }
                    *(void *)uint64_t buf = (char *)&v105 + 8;
                    sub_100047F64((void ***)buf);
                    if (SBYTE7(v105) < 0) {
                      operator delete((void *)v104);
                    }
LABEL_87:
                    sub_10004D2C8(v8);
                    return;
                  }
                }
                __int16 v30 = *(NSObject **)(a1 + 40);
                if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
                {
                  *(_WORD *)uint64_t buf = 0;
                  _os_log_error_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_ERROR, "No device name or device type found.", buf, 2u);
                }
                *(void *)uint64_t buf = &off_101A1A658;
                long long v86 = 0u;
                long long v87 = 0u;
                long long v88 = 0u;
                long long v89 = 0u;
                long long v90 = 0u;
                long long v91 = 0u;
                long long v92 = 0u;
                long long v93 = 0u;
                long long v101 = 0u;
                *(_OWORD *)long long v102 = 0u;
                int v103 = 0;
                long long v99 = 0u;
                long long v100 = 0u;
                long long v98 = 0u;
                v102[8] = 2;
                *(void *)&v102[12] = 0x50000003CLL;
                sub_100918E58((uint64_t)buf);
                uint64_t v31 = *((void *)&v90 + 1);
                *(unsigned char *)(*((void *)&v90 + 1) + 12) |= 1u;
                *(_DWORD *)(v31 + 8) = 6;
                uint64_t v32 = *(NSObject **)(a1 + 40);
                if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
                {
                  uint64_t v41 = asString();
                  *(_DWORD *)long long v95 = 136315138;
                  uint64_t v96 = v41;
                  _os_log_error_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_ERROR, "Sending Error [%s]", v95, 0xCu);
                }
                if (*((char *)a2 + 23) < 0)
                {
                  sub_10004FC84(&v45, *(void **)a2, *((void *)a2 + 1));
                }
                else
                {
                  long long v45 = *a2;
                  uint64_t v46 = *((void *)a2 + 2);
                }
                if (*((char *)a2 + 47) < 0)
                {
                  sub_10004FC84(&v47, *((void **)a2 + 3), *((void *)a2 + 4));
                }
                else
                {
                  long long v47 = *(long long *)((char *)a2 + 24);
                  uint64_t v48 = *((void *)a2 + 5);
                }
                __int16 v49 = *((_WORD *)a2 + 24);
                sub_10002FD9C(&v50, (const void **)a2 + 7);
                sub_100119B5C(&v51, (const void **)a2 + 8);
                v52[0] = *((void *)a2 + 9);
                *(void *)((char *)v52 + 6) = *(void *)((char *)a2 + 78);
                sub_1005D66F8(a1, (uint64_t)&v45, (uint64_t)buf);
                sub_1000FE824(&v51);
                sub_100030068(&v50);
                if (SHIBYTE(v48) < 0) {
                  operator delete((void *)v47);
                }
                if ((SHIBYTE(v46) & 0x80000000) == 0)
                {
LABEL_71:
                  sub_1000FE824((const void **)v102);
                  sub_100030068((const void **)&v101 + 1);
                  if (SHIBYTE(v100) < 0) {
                    operator delete(*((void **)&v99 + 1));
                  }
                  if (SBYTE7(v99) < 0) {
                    operator delete((void *)v98);
                  }
                  goto LABEL_75;
                }
                long long v28 = (void *)v45;
              }
              else
              {
                __int16 v33 = *(NSObject **)(a1 + 40);
                if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
                {
                  *(_WORD *)uint64_t buf = 0;
                  _os_log_error_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_ERROR, "No device Imei", buf, 2u);
                }
                *(void *)uint64_t buf = &off_101A1A658;
                long long v86 = 0u;
                long long v87 = 0u;
                long long v88 = 0u;
                long long v89 = 0u;
                long long v90 = 0u;
                long long v91 = 0u;
                long long v92 = 0u;
                long long v93 = 0u;
                long long v101 = 0u;
                *(_OWORD *)long long v102 = 0u;
                int v103 = 0;
                long long v99 = 0u;
                long long v100 = 0u;
                long long v98 = 0u;
                v102[8] = 2;
                *(void *)&v102[12] = 0x50000003CLL;
                sub_100918E58((uint64_t)buf);
                uint64_t v34 = *((void *)&v90 + 1);
                *(unsigned char *)(*((void *)&v90 + 1) + 12) |= 1u;
                *(_DWORD *)(v34 + 8) = 6;
                uint64_t v35 = *(NSObject **)(a1 + 40);
                if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
                {
                  uint64_t v42 = asString();
                  *(_DWORD *)long long v95 = 136315138;
                  uint64_t v96 = v42;
                  _os_log_error_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_ERROR, "Sending Error [%s]", v95, 0xCu);
                }
                if (*((char *)a2 + 23) < 0)
                {
                  sub_10004FC84(&v53, *(void **)a2, *((void *)a2 + 1));
                }
                else
                {
                  long long v53 = *a2;
                  uint64_t v54 = *((void *)a2 + 2);
                }
                if (*((char *)a2 + 47) < 0)
                {
                  sub_10004FC84(&v55, *((void **)a2 + 3), *((void *)a2 + 4));
                }
                else
                {
                  long long v55 = *(long long *)((char *)a2 + 24);
                  uint64_t v56 = *((void *)a2 + 5);
                }
                __int16 v57 = *((_WORD *)a2 + 24);
                sub_10002FD9C(&v58, (const void **)a2 + 7);
                sub_100119B5C(&v59, (const void **)a2 + 8);
                v60[0] = *((void *)a2 + 9);
                *(void *)((char *)v60 + 6) = *(void *)((char *)a2 + 78);
                sub_1005D66F8(a1, (uint64_t)&v53, (uint64_t)buf);
                sub_1000FE824(&v59);
                sub_100030068(&v58);
                if (SHIBYTE(v56) < 0) {
                  operator delete((void *)v55);
                }
                if ((SHIBYTE(v54) & 0x80000000) == 0) {
                  goto LABEL_71;
                }
                long long v28 = (void *)v53;
              }
            }
            else
            {
              uint64_t v22 = *(NSObject **)(a1 + 40);
              if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
              {
                *(_WORD *)uint64_t buf = 0;
                _os_log_error_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_ERROR, "No target csn found.", buf, 2u);
              }
              *(void *)uint64_t buf = &off_101A1A658;
              long long v86 = 0u;
              long long v87 = 0u;
              long long v88 = 0u;
              long long v89 = 0u;
              long long v90 = 0u;
              long long v91 = 0u;
              long long v92 = 0u;
              long long v93 = 0u;
              long long v101 = 0u;
              *(_OWORD *)long long v102 = 0u;
              int v103 = 0;
              long long v99 = 0u;
              long long v100 = 0u;
              long long v98 = 0u;
              v102[8] = 2;
              *(void *)&v102[12] = 0x50000003CLL;
              sub_100918E58((uint64_t)buf);
              uint64_t v23 = *((void *)&v90 + 1);
              *(unsigned char *)(*((void *)&v90 + 1) + 12) |= 1u;
              *(_DWORD *)(v23 + 8) = 6;
              uint64_t v24 = *(NSObject **)(a1 + 40);
              if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
              {
                uint64_t v37 = asString();
                *(_DWORD *)long long v95 = 136315138;
                uint64_t v96 = v37;
                _os_log_error_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "Sending Error [%s]", v95, 0xCu);
              }
              if (*((char *)a2 + 23) < 0)
              {
                sub_10004FC84(&v61, *(void **)a2, *((void *)a2 + 1));
              }
              else
              {
                long long v61 = *a2;
                uint64_t v62 = *((void *)a2 + 2);
              }
              if (*((char *)a2 + 47) < 0)
              {
                sub_10004FC84(&v63, *((void **)a2 + 3), *((void *)a2 + 4));
              }
              else
              {
                long long v63 = *(long long *)((char *)a2 + 24);
                uint64_t v64 = *((void *)a2 + 5);
              }
              __int16 v65 = *((_WORD *)a2 + 24);
              sub_10002FD9C(&v66, (const void **)a2 + 7);
              sub_100119B5C(&v67, (const void **)a2 + 8);
              v68[0] = *((void *)a2 + 9);
              *(void *)((char *)v68 + 6) = *(void *)((char *)a2 + 78);
              sub_1005D66F8(a1, (uint64_t)&v61, (uint64_t)buf);
              sub_1000FE824(&v67);
              sub_100030068(&v66);
              if (SHIBYTE(v64) < 0) {
                operator delete((void *)v63);
              }
              if ((SHIBYTE(v62) & 0x80000000) == 0) {
                goto LABEL_71;
              }
              long long v28 = (void *)v61;
            }
LABEL_70:
            operator delete(v28);
            goto LABEL_71;
          }
        }
        uint64_t v25 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)uint64_t buf = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_ERROR, "No iccid found.", buf, 2u);
        }
        *(void *)uint64_t buf = &off_101A1A658;
        long long v86 = 0u;
        long long v87 = 0u;
        long long v88 = 0u;
        long long v89 = 0u;
        long long v90 = 0u;
        long long v91 = 0u;
        long long v92 = 0u;
        long long v93 = 0u;
        long long v101 = 0u;
        *(_OWORD *)long long v102 = 0u;
        int v103 = 0;
        long long v99 = 0u;
        long long v100 = 0u;
        long long v98 = 0u;
        v102[8] = 2;
        *(void *)&v102[12] = 0x50000003CLL;
        sub_100918E58((uint64_t)buf);
        uint64_t v26 = *((void *)&v90 + 1);
        *(unsigned char *)(*((void *)&v90 + 1) + 12) |= 1u;
        *(_DWORD *)(v26 + 8) = 6;
        uint64_t v27 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
        {
          uint64_t v36 = asString();
          LODWORD(v97) = 136315138;
          *(void *)((char *)&v97 + 4) = v36;
          _os_log_error_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_ERROR, "Sending Error [%s]", (uint8_t *)&v97, 0xCu);
        }
        if (*((char *)a2 + 23) < 0)
        {
          sub_10004FC84(&v69, *(void **)a2, *((void *)a2 + 1));
        }
        else
        {
          long long v69 = *a2;
          uint64_t v70 = *((void *)a2 + 2);
        }
        if (*((char *)a2 + 47) < 0)
        {
          sub_10004FC84(&v71, *((void **)a2 + 3), *((void *)a2 + 4));
        }
        else
        {
          long long v71 = *(long long *)((char *)a2 + 24);
          uint64_t v72 = *((void *)a2 + 5);
        }
        __int16 v73 = *((_WORD *)a2 + 24);
        sub_10002FD9C(&v74, (const void **)a2 + 7);
        sub_100119B5C(&v75, (const void **)a2 + 8);
        v76[0] = *((void *)a2 + 9);
        *(void *)((char *)v76 + 6) = *(void *)((char *)a2 + 78);
        sub_1005D66F8(a1, (uint64_t)&v69, (uint64_t)buf);
        sub_1000FE824(&v75);
        sub_100030068(&v74);
        if (SHIBYTE(v72) < 0) {
          operator delete((void *)v71);
        }
        if ((SHIBYTE(v70) & 0x80000000) == 0) {
          goto LABEL_71;
        }
        long long v28 = (void *)v69;
        goto LABEL_70;
      }
    }
  }
  else
  {
    CFDataRef v8 = 0;
  }
  uint64_t v19 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)uint64_t buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "No controller found.", buf, 2u);
  }
  *(void *)uint64_t buf = &off_101A1A658;
  long long v86 = 0u;
  long long v87 = 0u;
  long long v88 = 0u;
  long long v89 = 0u;
  long long v90 = 0u;
  long long v91 = 0u;
  long long v92 = 0u;
  long long v93 = 0u;
  long long v107 = 0u;
  *(_OWORD *)long long v108 = 0u;
  *(_DWORD *)&v108[20] = 0;
  long long v105 = 0u;
  long long v106 = 0u;
  long long v104 = 0u;
  v108[8] = 2;
  *(void *)&v108[12] = 0x50000003CLL;
  sub_100918E58((uint64_t)buf);
  uint64_t v20 = *((void *)&v90 + 1);
  *(unsigned char *)(*((void *)&v90 + 1) + 12) |= 1u;
  *(_DWORD *)(v20 + 8) = 1;
  uint64_t v21 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
  {
    uint64_t v29 = asString();
    LODWORD(v98) = 136315138;
    *(void *)((char *)&v98 + 4) = v29;
    _os_log_error_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "Sending Error [%s]", (uint8_t *)&v98, 0xCu);
  }
  if (*((char *)a2 + 23) < 0)
  {
    sub_10004FC84(&__dst, *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long __dst = *a2;
    uint64_t v78 = *((void *)a2 + 2);
  }
  if (*((char *)a2 + 47) < 0)
  {
    sub_10004FC84(&__p, *((void **)a2 + 3), *((void *)a2 + 4));
  }
  else
  {
    long long __p = *(long long *)((char *)a2 + 24);
    uint64_t v80 = *((void *)a2 + 5);
  }
  __int16 v81 = *((_WORD *)a2 + 24);
  sub_10002FD9C(&v82, (const void **)a2 + 7);
  sub_100119B5C(&v83, (const void **)a2 + 8);
  v84[0] = *((void *)a2 + 9);
  *(void *)((char *)v84 + 6) = *(void *)((char *)a2 + 78);
  sub_1005D66F8(a1, (uint64_t)&__dst, (uint64_t)buf);
  sub_1000FE824(&v83);
  sub_100030068(&v82);
  if (SHIBYTE(v80) < 0) {
    operator delete((void *)__p);
  }
  if (SHIBYTE(v78) < 0) {
    operator delete((void *)__dst);
  }
  sub_1000FE824((const void **)v108);
  sub_100030068((const void **)&v107 + 1);
  if (SHIBYTE(v106) < 0) {
    operator delete(*((void **)&v105 + 1));
  }
  if (SBYTE7(v105) < 0) {
    operator delete((void *)v104);
  }
  sub_100917304((PB::Base *)buf);
  if (v8) {
    goto LABEL_87;
  }
}

void sub_1005DE280(_Unwind_Exception *a1)
{
  sub_1003C1D74((uint64_t)&STACK[0x390]);
  sub_100917304((PB::Base *)&STACK[0x240]);
  sub_10032A36C((uint64_t)&STACK[0x3F0]);
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void sub_1005DE3DC(uint64_t a1@<X8>)
{
  sub_100058DB0(__p, "");
  uint64_t v2 = (unsigned char *)(a1 + 16);
  if (SHIBYTE(v5) < 0)
  {
    sub_10004FC84(v2, __p[0], (unint64_t)__p[1]);
    int v3 = SHIBYTE(v5);
    *(unsigned char *)(a1 + 40) = 1;
    if (v3 < 0) {
      operator delete(__p[0]);
    }
  }
  else
  {
    *(_OWORD *)uint64_t v2 = *(_OWORD *)__p;
    *(void *)(a1 + 32) = v5;
    *(unsigned char *)(a1 + 40) = 1;
  }
}

void sub_1005DE45C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1005DE478(uint64_t a1, unsigned __int8 *a2)
{
  uint64_t v4 = *(void *)(a1 + 32);
  uint64_t v21 = &off_101A1A658;
  long long v22 = 0u;
  long long v23 = 0u;
  long long v24 = 0u;
  long long v25 = 0u;
  long long v26 = 0u;
  long long v27 = 0u;
  long long v28 = 0u;
  long long v29 = 0u;
  sub_100918770((uint64_t)&v21);
  uint64_t v5 = *(PB::Data **)(v22 + 8);
  if (!v5) {
    operator new();
  }
  PB::Data::assign(v5, (const unsigned __int8 *)(a1 + 128), (const unsigned __int8 *)(a1 + 144));
  int v6 = *a2;
  if (v6 == 1)
  {
    uint64_t v9 = v22;
    unsigned __int8 v10 = a2[1];
    *(unsigned char *)(v22 + 24) |= 2u;
    *(unsigned char *)(v9 + 20) = v10;
  }
  else
  {
    if (v6 != 2)
    {
      exception = (ctu::ResultIsEmptyError *)__cxa_allocate_exception(0x10uLL);
      ctu::ResultIsEmptyError::ResultIsEmptyError(exception);
    }
    uint64_t v7 = v22;
    int v8 = a2[1];
    *(unsigned char *)(v22 + 24) |= 1u;
    *(_DWORD *)(v7 + 16) = v8;
  }
  uint64_t v11 = *(NSObject **)(v4 + 40);
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I [ActivateProfileRsp]", buf, 2u);
  }
  if (*(char *)(a1 + 63) < 0)
  {
    sub_10004FC84(v13, *(void **)(a1 + 40), *(void *)(a1 + 48));
  }
  else
  {
    *(_OWORD *)uint64_t v13 = *(_OWORD *)(a1 + 40);
    uint64_t v14 = *(void *)(a1 + 56);
  }
  if (*(char *)(a1 + 87) < 0)
  {
    sub_10004FC84(&__p, *(void **)(a1 + 64), *(void *)(a1 + 72));
  }
  else
  {
    long long __p = *(_OWORD *)(a1 + 64);
    uint64_t v16 = *(void *)(a1 + 80);
  }
  __int16 v17 = *(_WORD *)(a1 + 88);
  sub_10002FD9C(&v18, (const void **)(a1 + 96));
  sub_100119B5C(&v19, (const void **)(a1 + 104));
  v20[0] = *(void *)(a1 + 112);
  *(void *)((char *)v20 + 6) = *(void *)(a1 + 118);
  sub_1005D66F8(v4, (uint64_t)v13, (uint64_t)&v21);
  sub_1000FE824(&v19);
  sub_100030068(&v18);
  if (SHIBYTE(v16) < 0) {
    operator delete((void *)__p);
  }
  if (SHIBYTE(v14) < 0) {
    operator delete(v13[0]);
  }
  sub_100917304((PB::Base *)&v21);
}

void sub_1005DE6F0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23)
{
  __cxa_free_exception(v23);
  sub_100917304((PB::Base *)&a23);
  _Unwind_Resume(a1);
}

const void **sub_1005DE73C(uint64_t a1, uint64_t a2)
{
  if (*(char *)(a2 + 63) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 40), *(void **)(a2 + 40), *(void *)(a2 + 48));
  }
  else
  {
    long long v4 = *(_OWORD *)(a2 + 40);
    *(void *)(a1 + 56) = *(void *)(a2 + 56);
    *(_OWORD *)(a1 + 40) = v4;
  }
  uint64_t v5 = (unsigned char *)(a1 + 64);
  if (*(char *)(a2 + 87) < 0)
  {
    sub_10004FC84(v5, *(void **)(a2 + 64), *(void *)(a2 + 72));
  }
  else
  {
    long long v6 = *(_OWORD *)(a2 + 64);
    *(void *)(a1 + 80) = *(void *)(a2 + 80);
    *(_OWORD *)uint64_t v5 = v6;
  }
  *(_WORD *)(a1 + 88) = *(_WORD *)(a2 + 88);
  sub_10002FD9C((const void **)(a1 + 96), (const void **)(a2 + 96));
  BOOL result = sub_100119B5C((const void **)(a1 + 104), (const void **)(a2 + 104));
  uint64_t v8 = *(void *)(a2 + 112);
  *(void *)(a1 + 118) = *(void *)(a2 + 118);
  *(void *)(a1 + 112) = v8;
  return result;
}

void sub_1005DE7F4(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 63) < 0) {
    operator delete(*v2);
  }
  _Unwind_Resume(exception_object);
}

void sub_1005DE810(uint64_t a1)
{
  sub_1000FE824((const void **)(a1 + 104));
  sub_100030068((const void **)(a1 + 96));
  if (*(char *)(a1 + 87) < 0) {
    operator delete(*(void **)(a1 + 64));
  }
  if (*(char *)(a1 + 63) < 0)
  {
    uint64_t v2 = *(void **)(a1 + 40);
    operator delete(v2);
  }
}

void sub_1005DE878(uint64_t a1, char a2)
{
  v12[0] = _NSConcreteStackBlock;
  v12[1] = 1174405120;
  void v12[2] = sub_1005DEB0C;
  void v12[3] = &unk_1019ECD50;
  long long v9 = *(_OWORD *)(a1 + 32);
  long long v13 = v9;
  int v3 = *(std::__shared_weak_count **)(a1 + 48);
  uint64_t v14 = v3;
  if (v3) {
    atomic_fetch_add_explicit(&v3->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  }
  long long v23 = *(_OWORD *)(a1 + 144);
  char v24 = a2;
  if (*(char *)(a1 + 79) < 0)
  {
    sub_10004FC84(&v15, *(void **)(a1 + 56), *(void *)(a1 + 64));
  }
  else
  {
    long long v15 = *(_OWORD *)(a1 + 56);
    uint64_t v16 = *(void *)(a1 + 72);
  }
  if (*(char *)(a1 + 103) < 0)
  {
    sub_10004FC84(&__p, *(void **)(a1 + 80), *(void *)(a1 + 88));
  }
  else
  {
    long long __p = *(_OWORD *)(a1 + 80);
    uint64_t v18 = *(void *)(a1 + 96);
  }
  __int16 v19 = *(_WORD *)(a1 + 104);
  sub_10002FD9C(&v20, (const void **)(a1 + 112));
  sub_100119B5C(&v21, (const void **)(a1 + 120));
  v22[0] = *(void *)(a1 + 128);
  *(void *)((char *)v22 + 6) = *(void *)(a1 + 134);
  long long v4 = *(std::__shared_weak_count **)(v9 + 16);
  if (!v4 || (v5 = *(void *)(v9 + 8), (long long v6 = std::__shared_weak_count::lock(v4)) == 0)) {
    sub_100088B9C();
  }
  uint64_t v7 = v6;
  uint64_t v8 = *(NSObject **)(v9 + 24);
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  void block[2] = sub_1005E4BA0;
  block[3] = &unk_1019ED0C0;
  block[5] = v5;
  uint64_t v11 = v7;
  atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
  block[4] = v12;
  dispatch_async(v8, block);
  if (v11) {
    sub_10004D2C8(v11);
  }
  sub_10004D2C8(v7);
  sub_1000FE824(&v21);
  sub_100030068(&v20);
  if (SHIBYTE(v18) < 0) {
    operator delete((void *)__p);
  }
  if (SHIBYTE(v16) < 0) {
    operator delete((void *)v15);
  }
  if (v14) {
    std::__shared_weak_count::__release_weak(v14);
  }
}

void sub_1005DEAC8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,std::__shared_weak_count *a25,void *__p,uint64_t a27,int a28,__int16 a29,char a30,char a31)
{
  if (a31 < 0) {
    operator delete(__p);
  }
  if (a25) {
    std::__shared_weak_count::__release_weak(a25);
  }
  _Unwind_Resume(exception_object);
}

void sub_1005DEB0C(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 48);
  if (v2)
  {
    uint64_t v3 = *(void *)(a1 + 32);
    long long v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      uint64_t v5 = v4;
      if (*(void *)(a1 + 40))
      {
        uint64_t v18 = &off_101A1A658;
        long long v19 = 0u;
        long long v20 = 0u;
        long long v21 = 0u;
        long long v22 = 0u;
        long long v23 = 0u;
        long long v24 = 0u;
        long long v25 = 0u;
        long long v26 = 0u;
        sub_100918A20((uint64_t)&v18);
        long long v6 = *(PB::Data **)(*((void *)&v25 + 1) + 8);
        if (!v6) {
          operator new();
        }
        PB::Data::assign(v6, (const unsigned __int8 *)(a1 + 144), (const unsigned __int8 *)(a1 + 160));
        uint64_t v7 = *((void *)&v25 + 1);
        char v8 = *(unsigned char *)(a1 + 160);
        *(unsigned char *)(*((void *)&v25 + 1) + 24) |= 2u;
        *(unsigned char *)(v7 + 20) = v8;
        long long v9 = *(NSObject **)(v3 + 40);
        if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)uint64_t buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I [UpdateProfileRsp]", buf, 2u);
        }
        if (*(char *)(a1 + 79) < 0)
        {
          sub_10004FC84(v10, *(void **)(a1 + 56), *(void *)(a1 + 64));
        }
        else
        {
          *(_OWORD *)unsigned __int8 v10 = *(_OWORD *)(a1 + 56);
          uint64_t v11 = *(void *)(a1 + 72);
        }
        if (*(char *)(a1 + 103) < 0)
        {
          sub_10004FC84(&__p, *(void **)(a1 + 80), *(void *)(a1 + 88));
        }
        else
        {
          long long __p = *(_OWORD *)(a1 + 80);
          uint64_t v13 = *(void *)(a1 + 96);
        }
        __int16 v14 = *(_WORD *)(a1 + 104);
        sub_10002FD9C(&v15, (const void **)(a1 + 112));
        sub_100119B5C(&v16, (const void **)(a1 + 120));
        v17[0] = *(void *)(a1 + 128);
        *(void *)((char *)v17 + 6) = *(void *)(a1 + 134);
        sub_1005D66F8(v3, (uint64_t)v10, (uint64_t)&v18);
        sub_1000FE824(&v16);
        sub_100030068(&v15);
        if (SHIBYTE(v13) < 0) {
          operator delete((void *)__p);
        }
        if (SHIBYTE(v11) < 0) {
          operator delete(v10[0]);
        }
        sub_100917304((PB::Base *)&v18);
      }
      sub_10004D2C8(v5);
    }
  }
}

void sub_1005DED48(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  sub_100917304((PB::Base *)&a23);
  sub_10004D2C8(v23);
  _Unwind_Resume(a1);
}

const void **sub_1005DED8C(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 48);
  *(void *)(a1 + 40) = *(void *)(a2 + 40);
  *(void *)(a1 + 48) = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 16), 1uLL, memory_order_relaxed);
  }
  if (*(char *)(a2 + 79) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 56), *(void **)(a2 + 56), *(void *)(a2 + 64));
  }
  else
  {
    long long v5 = *(_OWORD *)(a2 + 56);
    *(void *)(a1 + 72) = *(void *)(a2 + 72);
    *(_OWORD *)(a1 + 56) = v5;
  }
  long long v6 = (unsigned char *)(a1 + 80);
  if (*(char *)(a2 + 103) < 0)
  {
    sub_10004FC84(v6, *(void **)(a2 + 80), *(void *)(a2 + 88));
  }
  else
  {
    long long v7 = *(_OWORD *)(a2 + 80);
    *(void *)(a1 + 96) = *(void *)(a2 + 96);
    *(_OWORD *)long long v6 = v7;
  }
  *(_WORD *)(a1 + 104) = *(_WORD *)(a2 + 104);
  sub_10002FD9C((const void **)(a1 + 112), (const void **)(a2 + 112));
  BOOL result = sub_100119B5C((const void **)(a1 + 120), (const void **)(a2 + 120));
  uint64_t v9 = *(void *)(a2 + 128);
  *(void *)(a1 + 134) = *(void *)(a2 + 134);
  *(void *)(a1 + 128) = v9;
  return result;
}

void sub_1005DEE5C(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 79) < 0) {
    operator delete(*v2);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(v1 + 48);
  if (v4) {
    std::__shared_weak_count::__release_weak(v4);
  }
  _Unwind_Resume(exception_object);
}

void sub_1005DEE8C(uint64_t a1)
{
  sub_1000FE824((const void **)(a1 + 120));
  sub_100030068((const void **)(a1 + 112));
  if (*(char *)(a1 + 103) < 0) {
    operator delete(*(void **)(a1 + 80));
  }
  if (*(char *)(a1 + 79) < 0) {
    operator delete(*(void **)(a1 + 56));
  }
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 48);
  if (v2)
  {
    std::__shared_weak_count::__release_weak(v2);
  }
}

void sub_1005DEF00(uint64_t a1, unsigned __int8 *a2)
{
  v12[0] = _NSConcreteStackBlock;
  v12[1] = 1174405120;
  void v12[2] = sub_1005DF1BC;
  void v12[3] = &unk_1019ECDB0;
  long long v9 = *(_OWORD *)(a1 + 32);
  long long v13 = v9;
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 48);
  __int16 v14 = v3;
  if (v3) {
    atomic_fetch_add_explicit(&v3->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  }
  long long v23 = *(_OWORD *)(a1 + 144);
  __int16 v24 = 0;
  if (*a2 - 1 <= 1) {
    __int16 v24 = *(_WORD *)a2;
  }
  if (*(char *)(a1 + 79) < 0)
  {
    sub_10004FC84(&v15, *(void **)(a1 + 56), *(void *)(a1 + 64));
  }
  else
  {
    long long v15 = *(_OWORD *)(a1 + 56);
    uint64_t v16 = *(void *)(a1 + 72);
  }
  if (*(char *)(a1 + 103) < 0)
  {
    sub_10004FC84(&__p, *(void **)(a1 + 80), *(void *)(a1 + 88));
  }
  else
  {
    long long __p = *(_OWORD *)(a1 + 80);
    uint64_t v18 = *(void *)(a1 + 96);
  }
  __int16 v19 = *(_WORD *)(a1 + 104);
  sub_10002FD9C(&v20, (const void **)(a1 + 112));
  sub_100119B5C(&v21, (const void **)(a1 + 120));
  v22[0] = *(void *)(a1 + 128);
  *(void *)((char *)v22 + 6) = *(void *)(a1 + 134);
  uint64_t v4 = *(std::__shared_weak_count **)(v9 + 16);
  if (!v4 || (v5 = *(void *)(v9 + 8), (long long v6 = std::__shared_weak_count::lock(v4)) == 0)) {
    sub_100088B9C();
  }
  long long v7 = v6;
  char v8 = *(NSObject **)(v9 + 24);
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  void block[2] = sub_1005E4BA0;
  block[3] = &unk_1019ED0C0;
  block[5] = v5;
  uint64_t v11 = v7;
  atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
  block[4] = v12;
  dispatch_async(v8, block);
  if (v11) {
    sub_10004D2C8(v11);
  }
  sub_10004D2C8(v7);
  sub_1000FE824(&v21);
  sub_100030068(&v20);
  if (SHIBYTE(v18) < 0) {
    operator delete((void *)__p);
  }
  if (SHIBYTE(v16) < 0) {
    operator delete((void *)v15);
  }
  LOBYTE(v24) = 0;
  if (v14) {
    std::__shared_weak_count::__release_weak(v14);
  }
}

void sub_1005DF174(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,std::__shared_weak_count *a25,void *__p,uint64_t a27,int a28,__int16 a29,char a30,char a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,char a42)
{
  if (a31 < 0) {
    operator delete(__p);
  }
  if (a25) {
    std::__shared_weak_count::__release_weak(a25);
  }
  _Unwind_Resume(exception_object);
}

void sub_1005DF1BC(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 48);
  if (v2)
  {
    uint64_t v3 = *(void *)(a1 + 32);
    uint64_t v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      uint64_t v5 = v4;
      if (*(void *)(a1 + 40))
      {
        long long v22 = &off_101A1A658;
        long long v23 = 0u;
        long long v24 = 0u;
        long long v25 = 0u;
        long long v26 = 0u;
        long long v27 = 0u;
        long long v28 = 0u;
        long long v29 = 0u;
        long long v30 = 0u;
        sub_10091881C((uint64_t)&v22);
        long long v6 = *(PB::Data **)(*((void *)&v23 + 1) + 8);
        if (!v6) {
          operator new();
        }
        PB::Data::assign(v6, (const unsigned __int8 *)(a1 + 144), (const unsigned __int8 *)(a1 + 160));
        int v7 = *(unsigned __int8 *)(a1 + 160);
        if (v7 == 1)
        {
          uint64_t v10 = *((void *)&v23 + 1);
          char v11 = *(unsigned char *)(a1 + 161);
          *(unsigned char *)(*((void *)&v23 + 1) + 24) |= 2u;
          *(unsigned char *)(v10 + 20) = v11;
        }
        else
        {
          if (v7 != 2)
          {
            exception = (ctu::ResultIsEmptyError *)__cxa_allocate_exception(0x10uLL);
            ctu::ResultIsEmptyError::ResultIsEmptyError(exception);
          }
          uint64_t v8 = *((void *)&v23 + 1);
          int v9 = *(unsigned __int8 *)(a1 + 161);
          *(unsigned char *)(*((void *)&v23 + 1) + 24) |= 1u;
          *(_DWORD *)(v8 + 16) = v9;
        }
        uint64_t v12 = *(NSObject **)(v3 + 40);
        if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)uint64_t buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I [DeleteProfileRsp]", buf, 2u);
        }
        if (*(char *)(a1 + 79) < 0)
        {
          sub_10004FC84(v14, *(void **)(a1 + 56), *(void *)(a1 + 64));
        }
        else
        {
          *(_OWORD *)__int16 v14 = *(_OWORD *)(a1 + 56);
          uint64_t v15 = *(void *)(a1 + 72);
        }
        if (*(char *)(a1 + 103) < 0)
        {
          sub_10004FC84(&__p, *(void **)(a1 + 80), *(void *)(a1 + 88));
        }
        else
        {
          long long __p = *(_OWORD *)(a1 + 80);
          uint64_t v17 = *(void *)(a1 + 96);
        }
        __int16 v18 = *(_WORD *)(a1 + 104);
        sub_10002FD9C(&v19, (const void **)(a1 + 112));
        sub_100119B5C(&v20, (const void **)(a1 + 120));
        v21[0] = *(void *)(a1 + 128);
        *(void *)((char *)v21 + 6) = *(void *)(a1 + 134);
        sub_1005D66F8(v3, (uint64_t)v14, (uint64_t)&v22);
        sub_1000FE824(&v20);
        sub_100030068(&v19);
        if (SHIBYTE(v17) < 0) {
          operator delete((void *)__p);
        }
        if (SHIBYTE(v15) < 0) {
          operator delete(v14[0]);
        }
        sub_100917304((PB::Base *)&v22);
      }
      sub_10004D2C8(v5);
    }
  }
}

void sub_1005DF45C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23)
{
  __cxa_free_exception(v24);
  sub_100917304((PB::Base *)&a23);
  sub_10004D2C8(v23);
  _Unwind_Resume(a1);
}

const void **sub_1005DF4B0(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 48);
  *(void *)(a1 + 40) = *(void *)(a2 + 40);
  *(void *)(a1 + 48) = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 16), 1uLL, memory_order_relaxed);
  }
  if (*(char *)(a2 + 79) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 56), *(void **)(a2 + 56), *(void *)(a2 + 64));
  }
  else
  {
    long long v5 = *(_OWORD *)(a2 + 56);
    *(void *)(a1 + 72) = *(void *)(a2 + 72);
    *(_OWORD *)(a1 + 56) = v5;
  }
  long long v6 = (unsigned char *)(a1 + 80);
  if (*(char *)(a2 + 103) < 0)
  {
    sub_10004FC84(v6, *(void **)(a2 + 80), *(void *)(a2 + 88));
  }
  else
  {
    long long v7 = *(_OWORD *)(a2 + 80);
    *(void *)(a1 + 96) = *(void *)(a2 + 96);
    *(_OWORD *)long long v6 = v7;
  }
  *(_WORD *)(a1 + 104) = *(_WORD *)(a2 + 104);
  sub_10002FD9C((const void **)(a1 + 112), (const void **)(a2 + 112));
  BOOL result = sub_100119B5C((const void **)(a1 + 120), (const void **)(a2 + 120));
  uint64_t v9 = *(void *)(a2 + 128);
  *(void *)(a1 + 134) = *(void *)(a2 + 134);
  *(void *)(a1 + 128) = v9;
  *(_WORD *)(a1 + 160) = 0;
  int v10 = *(unsigned __int8 *)(a2 + 160);
  if ((v10 - 1) <= 1)
  {
    *(unsigned char *)(a1 + 160) = v10;
    *(unsigned char *)(a1 + 161) = *(unsigned char *)(a2 + 161);
  }
  return result;
}

void sub_1005DF5A0(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 79) < 0) {
    operator delete(*v2);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(v1 + 48);
  if (v4) {
    std::__shared_weak_count::__release_weak(v4);
  }
  _Unwind_Resume(exception_object);
}

void sub_1005DF5D0(uint64_t a1)
{
  *(unsigned char *)(a1 + 160) = 0;
  sub_1000FE824((const void **)(a1 + 120));
  sub_100030068((const void **)(a1 + 112));
  if (*(char *)(a1 + 103) < 0) {
    operator delete(*(void **)(a1 + 80));
  }
  if (*(char *)(a1 + 79) < 0) {
    operator delete(*(void **)(a1 + 56));
  }
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 48);
  if (v2)
  {
    std::__shared_weak_count::__release_weak(v2);
  }
}

void sub_1005DF648(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 8);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

uint64_t sub_1005DF7A8(uint64_t a1)
{
  if (*(char *)(a1 + 119) < 0) {
    operator delete(*(void **)(a1 + 96));
  }
  sub_1000FE824((const void **)(a1 + 72));
  sub_100030068((const void **)(a1 + 64));
  if (*(char *)(a1 + 55) < 0) {
    operator delete(*(void **)(a1 + 32));
  }
  if (*(char *)(a1 + 31) < 0) {
    operator delete(*(void **)(a1 + 8));
  }
  return a1;
}

void sub_1005DF80C(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 8);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_1005DFA40(void *a1)
{
  if (*(char *)(v1 + 199) < 0) {
    operator delete(*v4);
  }
  if (*(char *)(v1 + 175) < 0) {
    operator delete(*v3);
  }
  if (*(char *)(v1 + 151) < 0) {
    operator delete(*v2);
  }
  if (*(char *)(v1 + 127) < 0) {
    operator delete(*(void **)(v1 + 104));
  }
  if (*(char *)(v1 + 71) < 0) {
    operator delete(*(void **)(v1 + 48));
  }
  long long v6 = *(std::__shared_weak_count **)(v1 + 40);
  if (v6) {
    sub_10004D2C8(v6);
  }
  if (*(char *)(v1 + 31) < 0) {
    operator delete(*(void **)(v1 + 8));
  }
  sub_10006A6AC(a1);
}

uint64_t sub_1005DFAE8(uint64_t a1)
{
  sub_1000FE824((const void **)(a1 + 240));
  sub_100030068((const void **)(a1 + 232));
  if (*(char *)(a1 + 223) < 0) {
    operator delete(*(void **)(a1 + 200));
  }
  if (*(char *)(a1 + 199) < 0) {
    operator delete(*(void **)(a1 + 176));
  }
  if (*(char *)(a1 + 175) < 0) {
    operator delete(*(void **)(a1 + 152));
  }
  if (*(char *)(a1 + 151) < 0) {
    operator delete(*(void **)(a1 + 128));
  }
  if (*(char *)(a1 + 127) < 0) {
    operator delete(*(void **)(a1 + 104));
  }
  if (*(char *)(a1 + 71) < 0) {
    operator delete(*(void **)(a1 + 48));
  }
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 40);
  if (v2) {
    sub_10004D2C8(v2);
  }
  if (*(char *)(a1 + 31) < 0) {
    operator delete(*(void **)(a1 + 8));
  }
  return a1;
}

void sub_1005DFB98(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 8);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_1005DFD78(void *a1)
{
  if (*(char *)(v1 + 159) < 0) {
    operator delete(*v2);
  }
  uint64_t v4 = *(void **)(v1 + 112);
  if (v4)
  {
    *(void *)(v1 + 120) = v4;
    operator delete(v4);
  }
  if (*(char *)(v1 + 111) < 0) {
    operator delete(*(void **)(v1 + 88));
  }
  if (*(char *)(v1 + 71) < 0) {
    operator delete(*(void **)(v1 + 48));
  }
  if (*(char *)(v1 + 47) < 0) {
    operator delete(*(void **)(v1 + 24));
  }
  long long v5 = *(std::__shared_weak_count **)(v1 + 16);
  if (v5) {
    sub_10004D2C8(v5);
  }
  sub_10006A6AC(a1);
}

uint64_t sub_1005DFE00(uint64_t a1)
{
  sub_1000FE824((const void **)(a1 + 200));
  sub_100030068((const void **)(a1 + 192));
  if (*(char *)(a1 + 183) < 0) {
    operator delete(*(void **)(a1 + 160));
  }
  if (*(char *)(a1 + 159) < 0) {
    operator delete(*(void **)(a1 + 136));
  }
  uint64_t v2 = *(void **)(a1 + 112);
  if (v2)
  {
    *(void *)(a1 + 120) = v2;
    operator delete(v2);
  }
  if (*(char *)(a1 + 111) < 0) {
    operator delete(*(void **)(a1 + 88));
  }
  if (*(char *)(a1 + 71) < 0) {
    operator delete(*(void **)(a1 + 48));
  }
  if (*(char *)(a1 + 47) < 0) {
    operator delete(*(void **)(a1 + 24));
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (v3) {
    sub_10004D2C8(v3);
  }
  return a1;
}

void sub_1005DFEA0(uint64_t a1, char a2)
{
  v12[0] = _NSConcreteStackBlock;
  v12[1] = 1174405120;
  void v12[2] = sub_1005E0134;
  void v12[3] = &unk_1019ECE10;
  long long v9 = *(_OWORD *)(a1 + 32);
  long long v13 = v9;
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 48);
  __int16 v14 = v3;
  if (v3) {
    atomic_fetch_add_explicit(&v3->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  }
  long long v23 = *(_OWORD *)(a1 + 144);
  char v24 = a2;
  if (*(char *)(a1 + 79) < 0)
  {
    sub_10004FC84(&v15, *(void **)(a1 + 56), *(void *)(a1 + 64));
  }
  else
  {
    long long v15 = *(_OWORD *)(a1 + 56);
    uint64_t v16 = *(void *)(a1 + 72);
  }
  if (*(char *)(a1 + 103) < 0)
  {
    sub_10004FC84(&__p, *(void **)(a1 + 80), *(void *)(a1 + 88));
  }
  else
  {
    long long __p = *(_OWORD *)(a1 + 80);
    uint64_t v18 = *(void *)(a1 + 96);
  }
  __int16 v19 = *(_WORD *)(a1 + 104);
  sub_10002FD9C(&v20, (const void **)(a1 + 112));
  sub_100119B5C(&v21, (const void **)(a1 + 120));
  v22[0] = *(void *)(a1 + 128);
  *(void *)((char *)v22 + 6) = *(void *)(a1 + 134);
  uint64_t v4 = *(std::__shared_weak_count **)(v9 + 16);
  if (!v4 || (v5 = *(void *)(v9 + 8), (long long v6 = std::__shared_weak_count::lock(v4)) == 0)) {
    sub_100088B9C();
  }
  long long v7 = v6;
  uint64_t v8 = *(NSObject **)(v9 + 24);
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  void block[2] = sub_1005E4BA0;
  block[3] = &unk_1019ED0C0;
  block[5] = v5;
  char v11 = v7;
  atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
  block[4] = v12;
  dispatch_async(v8, block);
  if (v11) {
    sub_10004D2C8(v11);
  }
  sub_10004D2C8(v7);
  sub_1000FE824(&v21);
  sub_100030068(&v20);
  if (SHIBYTE(v18) < 0) {
    operator delete((void *)__p);
  }
  if (SHIBYTE(v16) < 0) {
    operator delete((void *)v15);
  }
  if (v14) {
    std::__shared_weak_count::__release_weak(v14);
  }
}

void sub_1005E00F0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,std::__shared_weak_count *a25,void *__p,uint64_t a27,int a28,__int16 a29,char a30,char a31)
{
  if (a31 < 0) {
    operator delete(__p);
  }
  if (a25) {
    std::__shared_weak_count::__release_weak(a25);
  }
  _Unwind_Resume(exception_object);
}

void sub_1005E0134(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 48);
  if (v2)
  {
    uint64_t v3 = *(void *)(a1 + 32);
    uint64_t v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      uint64_t v5 = v4;
      if (*(void *)(a1 + 40))
      {
        uint64_t v18 = &off_101A1A658;
        long long v19 = 0u;
        long long v20 = 0u;
        long long v21 = 0u;
        long long v22 = 0u;
        long long v23 = 0u;
        long long v24 = 0u;
        long long v25 = 0u;
        long long v26 = 0u;
        sub_1009188C8((uint64_t)&v18);
        long long v6 = *(PB::Data **)(*((void *)&v24 + 1) + 8);
        if (!v6) {
          operator new();
        }
        PB::Data::assign(v6, (const unsigned __int8 *)(a1 + 144), (const unsigned __int8 *)(a1 + 160));
        uint64_t v7 = *((void *)&v24 + 1);
        char v8 = *(unsigned char *)(a1 + 160);
        *(unsigned char *)(*((void *)&v24 + 1) + 24) |= 2u;
        *(unsigned char *)(v7 + 20) = v8;
        long long v9 = *(NSObject **)(v3 + 40);
        if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)uint64_t buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I [StartSessionRsp]", buf, 2u);
        }
        if (*(char *)(a1 + 79) < 0)
        {
          sub_10004FC84(v10, *(void **)(a1 + 56), *(void *)(a1 + 64));
        }
        else
        {
          *(_OWORD *)int v10 = *(_OWORD *)(a1 + 56);
          uint64_t v11 = *(void *)(a1 + 72);
        }
        if (*(char *)(a1 + 103) < 0)
        {
          sub_10004FC84(&__p, *(void **)(a1 + 80), *(void *)(a1 + 88));
        }
        else
        {
          long long __p = *(_OWORD *)(a1 + 80);
          uint64_t v13 = *(void *)(a1 + 96);
        }
        __int16 v14 = *(_WORD *)(a1 + 104);
        sub_10002FD9C(&v15, (const void **)(a1 + 112));
        sub_100119B5C(&v16, (const void **)(a1 + 120));
        v17[0] = *(void *)(a1 + 128);
        *(void *)((char *)v17 + 6) = *(void *)(a1 + 134);
        sub_1005D66F8(v3, (uint64_t)v10, (uint64_t)&v18);
        sub_1000FE824(&v16);
        sub_100030068(&v15);
        if (SHIBYTE(v13) < 0) {
          operator delete((void *)__p);
        }
        if (SHIBYTE(v11) < 0) {
          operator delete(v10[0]);
        }
        sub_100917304((PB::Base *)&v18);
      }
      sub_10004D2C8(v5);
    }
  }
}

void sub_1005E0370(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  sub_100917304((PB::Base *)&a23);
  sub_10004D2C8(v23);
  _Unwind_Resume(a1);
}

void sub_1005E03B4(uint64_t a1, char a2)
{
  v12[0] = _NSConcreteStackBlock;
  v12[1] = 1174405120;
  void v12[2] = sub_1005E0648;
  void v12[3] = &unk_1019ECE70;
  long long v9 = *(_OWORD *)(a1 + 32);
  long long v13 = v9;
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 48);
  __int16 v14 = v3;
  if (v3) {
    atomic_fetch_add_explicit(&v3->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  }
  long long v23 = *(_OWORD *)(a1 + 144);
  char v24 = a2;
  if (*(char *)(a1 + 79) < 0)
  {
    sub_10004FC84(&v15, *(void **)(a1 + 56), *(void *)(a1 + 64));
  }
  else
  {
    long long v15 = *(_OWORD *)(a1 + 56);
    uint64_t v16 = *(void *)(a1 + 72);
  }
  if (*(char *)(a1 + 103) < 0)
  {
    sub_10004FC84(&__p, *(void **)(a1 + 80), *(void *)(a1 + 88));
  }
  else
  {
    long long __p = *(_OWORD *)(a1 + 80);
    uint64_t v18 = *(void *)(a1 + 96);
  }
  __int16 v19 = *(_WORD *)(a1 + 104);
  sub_10002FD9C(&v20, (const void **)(a1 + 112));
  sub_100119B5C(&v21, (const void **)(a1 + 120));
  v22[0] = *(void *)(a1 + 128);
  *(void *)((char *)v22 + 6) = *(void *)(a1 + 134);
  uint64_t v4 = *(std::__shared_weak_count **)(v9 + 16);
  if (!v4 || (v5 = *(void *)(v9 + 8), (long long v6 = std::__shared_weak_count::lock(v4)) == 0)) {
    sub_100088B9C();
  }
  uint64_t v7 = v6;
  char v8 = *(NSObject **)(v9 + 24);
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  void block[2] = sub_1005E4BA0;
  block[3] = &unk_1019ED0C0;
  block[5] = v5;
  uint64_t v11 = v7;
  atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
  block[4] = v12;
  dispatch_async(v8, block);
  if (v11) {
    sub_10004D2C8(v11);
  }
  sub_10004D2C8(v7);
  sub_1000FE824(&v21);
  sub_100030068(&v20);
  if (SHIBYTE(v18) < 0) {
    operator delete((void *)__p);
  }
  if (SHIBYTE(v16) < 0) {
    operator delete((void *)v15);
  }
  if (v14) {
    std::__shared_weak_count::__release_weak(v14);
  }
}

void sub_1005E0604(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,std::__shared_weak_count *a25,void *__p,uint64_t a27,int a28,__int16 a29,char a30,char a31)
{
  if (a31 < 0) {
    operator delete(__p);
  }
  if (a25) {
    std::__shared_weak_count::__release_weak(a25);
  }
  _Unwind_Resume(exception_object);
}

void sub_1005E0648(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 48);
  if (v2)
  {
    uint64_t v3 = *(void *)(a1 + 32);
    uint64_t v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      uint64_t v5 = v4;
      if (*(void *)(a1 + 40))
      {
        uint64_t v18 = &off_101A1A658;
        long long v19 = 0u;
        long long v20 = 0u;
        long long v21 = 0u;
        long long v22 = 0u;
        long long v23 = 0u;
        long long v24 = 0u;
        long long v25 = 0u;
        long long v26 = 0u;
        sub_100918974((uint64_t)&v18);
        long long v6 = *(PB::Data **)(*((void *)&v20 + 1) + 8);
        if (!v6) {
          operator new();
        }
        PB::Data::assign(v6, (const unsigned __int8 *)(a1 + 144), (const unsigned __int8 *)(a1 + 160));
        uint64_t v7 = *((void *)&v20 + 1);
        char v8 = *(unsigned char *)(a1 + 160);
        *(unsigned char *)(*((void *)&v20 + 1) + 24) |= 2u;
        *(unsigned char *)(v7 + 20) = v8;
        long long v9 = *(NSObject **)(v3 + 40);
        if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)uint64_t buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I [EndSessionRsp]", buf, 2u);
        }
        if (*(char *)(a1 + 79) < 0)
        {
          sub_10004FC84(v10, *(void **)(a1 + 56), *(void *)(a1 + 64));
        }
        else
        {
          *(_OWORD *)int v10 = *(_OWORD *)(a1 + 56);
          uint64_t v11 = *(void *)(a1 + 72);
        }
        if (*(char *)(a1 + 103) < 0)
        {
          sub_10004FC84(&__p, *(void **)(a1 + 80), *(void *)(a1 + 88));
        }
        else
        {
          long long __p = *(_OWORD *)(a1 + 80);
          uint64_t v13 = *(void *)(a1 + 96);
        }
        __int16 v14 = *(_WORD *)(a1 + 104);
        sub_10002FD9C(&v15, (const void **)(a1 + 112));
        sub_100119B5C(&v16, (const void **)(a1 + 120));
        v17[0] = *(void *)(a1 + 128);
        *(void *)((char *)v17 + 6) = *(void *)(a1 + 134);
        sub_1005D66F8(v3, (uint64_t)v10, (uint64_t)&v18);
        sub_1000FE824(&v16);
        sub_100030068(&v15);
        if (SHIBYTE(v13) < 0) {
          operator delete((void *)__p);
        }
        if (SHIBYTE(v11) < 0) {
          operator delete(v10[0]);
        }
        sub_100917304((PB::Base *)&v18);
      }
      sub_10004D2C8(v5);
    }
  }
}

void sub_1005E0884(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  sub_100917304((PB::Base *)&a23);
  sub_10004D2C8(v23);
  _Unwind_Resume(a1);
}

void sub_1005E08C8(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 48);
  if (v3)
  {
    uint64_t v5 = *(void *)(a1 + 32);
    long long v6 = std::__shared_weak_count::lock(v3);
    if (v6)
    {
      uint64_t v7 = v6;
      if (*(void *)(a1 + 40))
      {
        long long v21 = &off_101A1A658;
        long long v22 = 0u;
        long long v23 = 0u;
        long long v24 = 0u;
        long long v25 = 0u;
        long long v26 = 0u;
        long long v27 = 0u;
        long long v28 = 0u;
        long long v29 = 0u;
        sub_100918568((uint64_t)&v21);
        char v8 = *(PB::Data **)(v24 + 8);
        if (!v8) {
          operator new();
        }
        PB::Data::assign(v8, (const unsigned __int8 *)(a1 + 160), (const unsigned __int8 *)(a1 + 176));
        sub_100BE0838(v24);
        uint64_t v9 = *(void *)(a1 + 56);
        if (*(unsigned char *)(v9 + 120))
        {
          if (*(char *)(v9 + 95) < 0) {
            uint64_t v10 = *(void *)(v9 + 80);
          }
          else {
            uint64_t v10 = *(unsigned __int8 *)(v9 + 95);
          }
          BOOL v11 = v10 == 0;
        }
        else
        {
          BOOL v11 = 0;
        }
        buf[0] = 0;
        sub_10087807C(a2, v11, (uint64_t)buf, *(void *)(v24 + 16));
        if (buf[0]) {
          sub_1000C54EC((uint64_t)&v31);
        }
        uint64_t v12 = *(NSObject **)(v5 + 40);
        if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)uint64_t buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I [FetchProfileUserConsentRsp]", buf, 2u);
        }
        if (*(char *)(a1 + 95) < 0)
        {
          sub_10004FC84(v13, *(void **)(a1 + 72), *(void *)(a1 + 80));
        }
        else
        {
          *(_OWORD *)uint64_t v13 = *(_OWORD *)(a1 + 72);
          uint64_t v14 = *(void *)(a1 + 88);
        }
        if (*(char *)(a1 + 119) < 0)
        {
          sub_10004FC84(&__p, *(void **)(a1 + 96), *(void *)(a1 + 104));
        }
        else
        {
          long long __p = *(_OWORD *)(a1 + 96);
          uint64_t v16 = *(void *)(a1 + 112);
        }
        __int16 v17 = *(_WORD *)(a1 + 120);
        sub_10002FD9C(&v18, (const void **)(a1 + 128));
        sub_100119B5C(&v19, (const void **)(a1 + 136));
        v20[0] = *(void *)(a1 + 144);
        *(void *)((char *)v20 + 6) = *(void *)(a1 + 150);
        sub_1005D66F8(v5, (uint64_t)v13, (uint64_t)&v21);
        sub_1000FE824(&v19);
        sub_100030068(&v18);
        if (SHIBYTE(v16) < 0) {
          operator delete((void *)__p);
        }
        if (SHIBYTE(v14) < 0) {
          operator delete(v13[0]);
        }
        sub_100917304((PB::Base *)&v21);
      }
      sub_10004D2C8(v7);
    }
  }
}

void sub_1005E0B7C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,char a40)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  sub_100917304((PB::Base *)&a23);
  sub_10004D2C8(v40);
  _Unwind_Resume(a1);
}

const void **sub_1005E0BDC(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 48);
  *(void *)(a1 + 40) = *(void *)(a2 + 40);
  *(void *)(a1 + 48) = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 16), 1uLL, memory_order_relaxed);
  }
  uint64_t v5 = *(void *)(a2 + 64);
  *(void *)(a1 + 56) = *(void *)(a2 + 56);
  *(void *)(a1 + 64) = v5;
  if (v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
  }
  if (*(char *)(a2 + 95) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 72), *(void **)(a2 + 72), *(void *)(a2 + 80));
  }
  else
  {
    long long v6 = *(_OWORD *)(a2 + 72);
    *(void *)(a1 + 88) = *(void *)(a2 + 88);
    *(_OWORD *)(a1 + 72) = v6;
  }
  uint64_t v7 = (unsigned char *)(a1 + 96);
  if (*(char *)(a2 + 119) < 0)
  {
    sub_10004FC84(v7, *(void **)(a2 + 96), *(void *)(a2 + 104));
  }
  else
  {
    long long v8 = *(_OWORD *)(a2 + 96);
    *(void *)(a1 + 112) = *(void *)(a2 + 112);
    *(_OWORD *)uint64_t v7 = v8;
  }
  *(_WORD *)(a1 + 120) = *(_WORD *)(a2 + 120);
  sub_10002FD9C((const void **)(a1 + 128), (const void **)(a2 + 128));
  BOOL result = sub_100119B5C((const void **)(a1 + 136), (const void **)(a2 + 136));
  uint64_t v10 = *(void *)(a2 + 144);
  *(void *)(a1 + 150) = *(void *)(a2 + 150);
  *(void *)(a1 + 144) = v10;
  return result;
}

void sub_1005E0CC4(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 95) < 0) {
    operator delete(*v2);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(v1 + 64);
  if (v4) {
    sub_10004D2C8(v4);
  }
  uint64_t v5 = *(std::__shared_weak_count **)(v1 + 48);
  if (v5) {
    std::__shared_weak_count::__release_weak(v5);
  }
  _Unwind_Resume(exception_object);
}

void sub_1005E0D00(uint64_t a1)
{
  sub_1000FE824((const void **)(a1 + 136));
  sub_100030068((const void **)(a1 + 128));
  if (*(char *)(a1 + 119) < 0) {
    operator delete(*(void **)(a1 + 96));
  }
  if (*(char *)(a1 + 95) < 0) {
    operator delete(*(void **)(a1 + 72));
  }
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 64);
  if (v2) {
    sub_10004D2C8(v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 48);
  if (v3)
  {
    std::__shared_weak_count::__release_weak(v3);
  }
}

void sub_1005E0D80(uint64_t a1, unsigned __int8 *a2, uint64_t a3)
{
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 48);
  if (v4)
  {
    uint64_t v7 = *(void *)(a1 + 32);
    long long v8 = std::__shared_weak_count::lock(v4);
    if (v8)
    {
      uint64_t v9 = v8;
      if (*(void *)(a1 + 40))
      {
        __int16 v33 = &off_101A1A658;
        long long v34 = 0u;
        long long v35 = 0u;
        long long v36 = 0u;
        long long v37 = 0u;
        long long v38 = 0u;
        long long v39 = 0u;
        long long v40 = 0u;
        long long v41 = 0u;
        sub_100918614((uint64_t)&v33);
        int v10 = *a2;
        if (v10 == 1)
        {
          uint64_t v13 = *((void *)&v36 + 1);
          unsigned __int8 v14 = a2[1];
          *(unsigned char *)(*((void *)&v36 + 1) + 40) |= 2u;
          *(unsigned char *)(v13 + 36) = v14;
          if (*a2 == 1 && *(unsigned char *)a3)
          {
            long long v31 = 0u;
            long long v32 = 0u;
            *(void *)uint64_t buf = off_1019ED3F0;
            long long v27 = 0u;
            long long v28 = 0u;
            long long v29 = 0u;
            uint64_t v30 = 0;
            memset(v25, 0, sizeof(v25));
            v42[0] = 0;
            sub_100878924((int *)(a3 + 8), (uint64_t)v25, (uint64_t)v42, (uint64_t)buf);
            sub_1005E47DC(v42);
            sub_1005E1110();
          }
        }
        else
        {
          if (v10 != 2)
          {
            exception = (ctu::ResultIsEmptyError *)__cxa_allocate_exception(0x10uLL);
            ctu::ResultIsEmptyError::ResultIsEmptyError(exception);
          }
          uint64_t v11 = *((void *)&v36 + 1);
          int v12 = a2[1];
          *(unsigned char *)(*((void *)&v36 + 1) + 40) |= 1u;
          *(_DWORD *)(v11 + 32) = v12;
        }
        long long v15 = *(NSObject **)(v7 + 40);
        if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)uint64_t buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I [FetchProfileResultRsp]", buf, 2u);
        }
        if (*(char *)(a1 + 79) < 0)
        {
          sub_10004FC84(v17, *(void **)(a1 + 56), *(void *)(a1 + 64));
        }
        else
        {
          *(_OWORD *)__int16 v17 = *(_OWORD *)(a1 + 56);
          uint64_t v18 = *(void *)(a1 + 72);
        }
        if (*(char *)(a1 + 103) < 0)
        {
          sub_10004FC84(&__p, *(void **)(a1 + 80), *(void *)(a1 + 88));
        }
        else
        {
          long long __p = *(_OWORD *)(a1 + 80);
          uint64_t v20 = *(void *)(a1 + 96);
        }
        __int16 v21 = *(_WORD *)(a1 + 104);
        sub_10002FD9C(&v22, (const void **)(a1 + 112));
        sub_100119B5C(&v23, (const void **)(a1 + 120));
        v24[0] = *(void *)(a1 + 128);
        *(void *)((char *)v24 + 6) = *(void *)(a1 + 134);
        sub_1005D66F8(v7, (uint64_t)v17, (uint64_t)&v33);
        sub_1000FE824(&v23);
        sub_100030068(&v22);
        if (SHIBYTE(v20) < 0) {
          operator delete((void *)__p);
        }
        if (SHIBYTE(v18) < 0) {
          operator delete(v17[0]);
        }
        sub_100917304((PB::Base *)&v33);
      }
      sub_10004D2C8(v9);
    }
  }
}

void sub_1005E108C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23,uint64_t a24,uint64_t a25,char a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,char a39)
{
  *(void *)(v40 - 160) = &a23;
  sub_1005E4864((void ***)(v40 - 160));
  sub_1005EA108((uint64_t)&a26);
  sub_100917304((PB::Base *)&a39);
  sub_10004D2C8(v39);
  _Unwind_Resume(a1);
}

void sub_1005E1110()
{
}

void sub_1005E1214(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1004660D8((void **)va);
  _Unwind_Resume(a1);
}

void sub_1005E1258(uint64_t a1, unsigned __int8 *a2)
{
  v12[0] = _NSConcreteStackBlock;
  v12[1] = 1174405120;
  void v12[2] = sub_1005E1514;
  void v12[3] = &unk_1019ECF30;
  long long v9 = *(_OWORD *)(a1 + 32);
  long long v13 = v9;
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 48);
  unsigned __int8 v14 = v3;
  if (v3) {
    atomic_fetch_add_explicit(&v3->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  }
  long long v23 = *(_OWORD *)(a1 + 144);
  __int16 v24 = 0;
  if (*a2 - 1 <= 1) {
    __int16 v24 = *(_WORD *)a2;
  }
  if (*(char *)(a1 + 79) < 0)
  {
    sub_10004FC84(&v15, *(void **)(a1 + 56), *(void *)(a1 + 64));
  }
  else
  {
    long long v15 = *(_OWORD *)(a1 + 56);
    uint64_t v16 = *(void *)(a1 + 72);
  }
  if (*(char *)(a1 + 103) < 0)
  {
    sub_10004FC84(&__p, *(void **)(a1 + 80), *(void *)(a1 + 88));
  }
  else
  {
    long long __p = *(_OWORD *)(a1 + 80);
    uint64_t v18 = *(void *)(a1 + 96);
  }
  __int16 v19 = *(_WORD *)(a1 + 104);
  sub_10002FD9C(&v20, (const void **)(a1 + 112));
  sub_100119B5C(&v21, (const void **)(a1 + 120));
  v22[0] = *(void *)(a1 + 128);
  *(void *)((char *)v22 + 6) = *(void *)(a1 + 134);
  uint64_t v4 = *(std::__shared_weak_count **)(v9 + 16);
  if (!v4 || (v5 = *(void *)(v9 + 8), (long long v6 = std::__shared_weak_count::lock(v4)) == 0)) {
    sub_100088B9C();
  }
  uint64_t v7 = v6;
  long long v8 = *(NSObject **)(v9 + 24);
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120;
  void block[2] = sub_1005E4BA0;
  block[3] = &unk_1019ED0C0;
  block[5] = v5;
  uint64_t v11 = v7;
  atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
  block[4] = v12;
  dispatch_async(v8, block);
  if (v11) {
    sub_10004D2C8(v11);
  }
  sub_10004D2C8(v7);
  sub_1000FE824(&v21);
  sub_100030068(&v20);
  if (SHIBYTE(v18) < 0) {
    operator delete((void *)__p);
  }
  if (SHIBYTE(v16) < 0) {
    operator delete((void *)v15);
  }
  LOBYTE(v24) = 0;
  if (v14) {
    std::__shared_weak_count::__release_weak(v14);
  }
}

void sub_1005E14CC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,std::__shared_weak_count *a25,void *__p,uint64_t a27,int a28,__int16 a29,char a30,char a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,char a42)
{
  if (a31 < 0) {
    operator delete(__p);
  }
  if (a25) {
    std::__shared_weak_count::__release_weak(a25);
  }
  _Unwind_Resume(exception_object);
}

void sub_1005E1514(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 48);
  if (v2)
  {
    uint64_t v3 = *(void *)(a1 + 32);
    uint64_t v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      uint64_t v5 = v4;
      if (*(void *)(a1 + 40))
      {
        long long v22 = &off_101A1A658;
        long long v23 = 0u;
        long long v24 = 0u;
        long long v25 = 0u;
        long long v26 = 0u;
        long long v27 = 0u;
        long long v28 = 0u;
        long long v29 = 0u;
        long long v30 = 0u;
        sub_1009186C4((uint64_t)&v22);
        long long v6 = *(PB::Data **)(v28 + 8);
        if (!v6) {
          operator new();
        }
        PB::Data::assign(v6, (const unsigned __int8 *)(a1 + 144), (const unsigned __int8 *)(a1 + 160));
        int v7 = *(unsigned __int8 *)(a1 + 160);
        if (v7 == 1)
        {
          uint64_t v10 = v28;
          char v11 = *(unsigned char *)(a1 + 161);
          *(unsigned char *)(v28 + 24) |= 2u;
          *(unsigned char *)(v10 + 20) = v11;
        }
        else
        {
          if (v7 != 2)
          {
            exception = (ctu::ResultIsEmptyError *)__cxa_allocate_exception(0x10uLL);
            ctu::ResultIsEmptyError::ResultIsEmptyError(exception);
          }
          uint64_t v8 = v28;
          int v9 = *(unsigned __int8 *)(a1 + 161);
          *(unsigned char *)(v28 + 24) |= 1u;
          *(_DWORD *)(v8 + 16) = v9;
        }
        int v12 = *(NSObject **)(v3 + 40);
        if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)uint64_t buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I [SendUserConsentRsp]", buf, 2u);
        }
        if (*(char *)(a1 + 79) < 0)
        {
          sub_10004FC84(v14, *(void **)(a1 + 56), *(void *)(a1 + 64));
        }
        else
        {
          *(_OWORD *)unsigned __int8 v14 = *(_OWORD *)(a1 + 56);
          uint64_t v15 = *(void *)(a1 + 72);
        }
        if (*(char *)(a1 + 103) < 0)
        {
          sub_10004FC84(&__p, *(void **)(a1 + 80), *(void *)(a1 + 88));
        }
        else
        {
          long long __p = *(_OWORD *)(a1 + 80);
          uint64_t v17 = *(void *)(a1 + 96);
        }
        __int16 v18 = *(_WORD *)(a1 + 104);
        sub_10002FD9C(&v19, (const void **)(a1 + 112));
        sub_100119B5C(&v20, (const void **)(a1 + 120));
        v21[0] = *(void *)(a1 + 128);
        *(void *)((char *)v21 + 6) = *(void *)(a1 + 134);
        sub_1005D66F8(v3, (uint64_t)v14, (uint64_t)&v22);
        sub_1000FE824(&v20);
        sub_100030068(&v19);
        if (SHIBYTE(v17) < 0) {
          operator delete((void *)__p);
        }
        if (SHIBYTE(v15) < 0) {
          operator delete(v14[0]);
        }
        sub_100917304((PB::Base *)&v22);
      }
      sub_10004D2C8(v5);
    }
  }
}

void sub_1005E17B4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23)
{
  __cxa_free_exception(v24);
  sub_100917304((PB::Base *)&a23);
  sub_10004D2C8(v23);
  _Unwind_Resume(a1);
}

void sub_1005E1808(uint64_t a1, long long *a2)
{
  v12[0] = _NSConcreteStackBlock;
  v12[1] = 1174405120;
  void v12[2] = sub_1005E1B70;
  void v12[3] = &unk_1019ECF90;
  long long v9 = *(_OWORD *)(a1 + 32);
  long long v13 = v9;
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 48);
  unsigned __int8 v14 = v3;
  if (v3) {
    atomic_fetch_add_explicit(&v3->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  }
  sub_100313228((char *)&v15, a2);
  memset(v25, 0, sizeof(v25));
  sub_100311ED8(v25, *(void *)(a1 + 56), *(void *)(a1 + 64), 0x2E8BA2E8BA2E8BA3 * ((uint64_t)(*(void *)(a1 + 64) - *(void *)(a1 + 56)) >> 3));
  __int16 v34 = *(_WORD *)(a1 + 168);
  if (*(char *)(a1 + 103) < 0)
  {
    sub_10004FC84(&v26, *(void **)(a1 + 80), *(void *)(a1 + 88));
  }
  else
  {
    long long v26 = *(_OWORD *)(a1 + 80);
    uint64_t v27 = *(void *)(a1 + 96);
  }
  if (*(char *)(a1 + 127) < 0)
  {
    sub_10004FC84(&__p, *(void **)(a1 + 104), *(void *)(a1 + 112));
  }
  else
  {
    long long __p = *(_OWORD *)(a1 + 104);
    uint64_t v29 = *(void *)(a1 + 120);
  }
  __int16 v30 = *(_WORD *)(a1 + 128);
  sub_10002FD9C(&v31, (const void **)(a1 + 136));
  sub_100119B5C(&v32, (const void **)(a1 + 144));
  *(void *)((char *)v33 + 6) = *(void *)(a1 + 158);
  v33[0] = *(void *)(a1 + 152);
  uint64_t v4 = *(std::__shared_weak_count **)(v9 + 16);
  if (!v4 || (v5 = *(void ***)(v9 + 8), (long long v6 = std::__shared_weak_count::lock(v4)) == 0)) {
    sub_100088B9C();
  }
  int v7 = v6;
  uint64_t v8 = *(NSObject **)(v9 + 24);
  block[0] = _NSConcreteStackBlock;
  block[1] = (void **)1174405120;
  void block[2] = (void **)sub_1005E4BA0;
  block[3] = (void **)&unk_1019ED0C0;
  block[5] = v5;
  char v11 = v7;
  atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
  block[4] = (void **)v12;
  dispatch_async(v8, block);
  if (v11) {
    sub_10004D2C8(v11);
  }
  sub_10004D2C8(v7);
  sub_1000FE824(&v32);
  sub_100030068(&v31);
  if (SHIBYTE(v29) < 0) {
    operator delete((void *)__p);
  }
  if (SHIBYTE(v27) < 0) {
    operator delete((void *)v26);
  }
  block[0] = (void **)v25;
  sub_1000C56F4(block);
  if (v24 < 0) {
    operator delete(v23);
  }
  if (v20)
  {
    if (v22 < 0) {
      operator delete(v21);
    }
    char v20 = 0;
  }
  if (v17)
  {
    if (v19 < 0) {
      operator delete(v18);
    }
    char v17 = 0;
  }
  if (v16 < 0) {
    operator delete(v15);
  }
  if (v14) {
    std::__shared_weak_count::__release_weak(v14);
  }
}

void sub_1005E1B08(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,std::__shared_weak_count *a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,void *__p,uint64_t a47,int a48,__int16 a49,char a50,char a51)
{
  if (a51 < 0) {
    operator delete(__p);
  }
  sub_1000C56F4((void ***)&a12);
  sub_100309AC4(v51);
  if (a25) {
    std::__shared_weak_count::__release_weak(a25);
  }
  _Unwind_Resume(a1);
}

void sub_1005E1B70(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 48);
  if (v2)
  {
    uint64_t v3 = *(void *)(a1 + 32);
    uint64_t v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      uint64_t v5 = v4;
      if (!*(void *)(a1 + 40))
      {
LABEL_43:
        sub_10004D2C8(v5);
        return;
      }
      __int16 v34 = &off_101A1A658;
      long long v35 = 0u;
      long long v36 = 0u;
      long long v37 = 0u;
      long long v38 = 0u;
      long long v39 = 0u;
      long long v40 = 0u;
      long long v41 = 0u;
      long long v42 = 0u;
      sub_100918ACC((uint64_t)&v34);
      if (*(unsigned char *)(a1 + 80))
      {
        if (*(char *)(a1 + 111) < 0)
        {
          if (!*(void *)(a1 + 96)) {
            goto LABEL_12;
          }
        }
        else if (!*(unsigned char *)(a1 + 111))
        {
          goto LABEL_12;
        }
        long long v6 = *(std::string **)(v36 + 8);
        if (!v6) {
          operator new();
        }
        std::string::operator=(v6, (const std::string *)(a1 + 88));
      }
LABEL_12:
      if (*(unsigned char *)(a1 + 112))
      {
        if ((*(char *)(a1 + 143) & 0x80000000) == 0)
        {
          if (!*(unsigned char *)(a1 + 143)) {
            goto LABEL_20;
          }
LABEL_17:
          int v7 = *(std::string **)(v36 + 16);
          if (!v7) {
            operator new();
          }
          std::string::operator=(v7, (const std::string *)(a1 + 120));
          goto LABEL_20;
        }
        if (*(void *)(a1 + 128)) {
          goto LABEL_17;
        }
      }
LABEL_20:
      int v8 = *(unsigned __int8 *)(a1 + 144);
      if (*(unsigned char *)(a1 + 144))
      {
        uint64_t v9 = v36;
        *(unsigned char *)(v36 + 68) |= 8u;
        *(_DWORD *)(v9 + 60) = v8;
      }
      if (*(unsigned char *)(a1 + 176))
      {
        uint64_t v10 = v36;
        int v11 = *(_DWORD *)(a1 + 180);
        *(unsigned char *)(v36 + 68) |= 2u;
        *(_DWORD *)(v10 + 52) = v11;
      }
      if (*(unsigned char *)(a1 + 184))
      {
        uint64_t v12 = v36;
        int v13 = *(_DWORD *)(a1 + 188);
        *(unsigned char *)(v36 + 68) |= 0x10u;
        *(_DWORD *)(v12 + 64) = v13;
      }
      unsigned __int8 v14 = *(int **)(a1 + 192);
      if (v14 != *(int **)(a1 + 200))
      {
        long long v32 = 0u;
        long long v33 = 0u;
        *(void *)uint64_t buf = off_1019ED3F0;
        long long v28 = 0u;
        long long v29 = 0u;
        long long v30 = 0u;
        uint64_t v31 = 0;
        memset(v26, 0, sizeof(v26));
        v43[0] = 0;
        sub_100878924(v14, (uint64_t)v26, (uint64_t)v43, (uint64_t)buf);
        sub_1005E47DC(v43);
        sub_1005E1110();
      }
      if (*(unsigned char *)(a1 + 304))
      {
        uint64_t v15 = v36;
        int v16 = *(unsigned __int8 *)(a1 + 305);
        *(unsigned char *)(v36 + 68) |= 4u;
        *(_DWORD *)(v15 + 56) = v16;
      }
      char v17 = *(NSObject **)(v3 + 40);
      if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I [DeviceInfoRsp]", buf, 2u);
      }
      if (*(char *)(a1 + 239) < 0)
      {
        sub_10004FC84(v18, *(void **)(a1 + 216), *(void *)(a1 + 224));
      }
      else
      {
        *(_OWORD *)__int16 v18 = *(_OWORD *)(a1 + 216);
        uint64_t v19 = *(void *)(a1 + 232);
      }
      if (*(char *)(a1 + 263) < 0)
      {
        sub_10004FC84(&__p, *(void **)(a1 + 240), *(void *)(a1 + 248));
      }
      else
      {
        long long __p = *(_OWORD *)(a1 + 240);
        uint64_t v21 = *(void *)(a1 + 256);
      }
      __int16 v22 = *(_WORD *)(a1 + 264);
      sub_10002FD9C(&v23, (const void **)(a1 + 272));
      sub_100119B5C(&v24, (const void **)(a1 + 280));
      v25[0] = *(void *)(a1 + 288);
      *(void *)((char *)v25 + 6) = *(void *)(a1 + 294);
      sub_1005D66F8(v3, (uint64_t)v18, (uint64_t)&v34);
      sub_1000FE824(&v24);
      sub_100030068(&v23);
      if (SHIBYTE(v21) < 0) {
        operator delete((void *)__p);
      }
      if (SHIBYTE(v19) < 0) {
        operator delete(v18[0]);
      }
      sub_100917304((PB::Base *)&v34);
      goto LABEL_43;
    }
  }
}

void sub_1005E1F7C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23,uint64_t a24,uint64_t a25,char a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,char a39)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  sub_100917304((PB::Base *)&a39);
  sub_10004D2C8(v39);
  _Unwind_Resume(a1);
}

const void **sub_1005E1FF0(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 48);
  *(void *)(a1 + 40) = *(void *)(a2 + 40);
  *(void *)(a1 + 48) = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 16), 1uLL, memory_order_relaxed);
  }
  sub_100313228((char *)(a1 + 56), (long long *)(a2 + 56));
  *(void *)(a1 + 192) = 0;
  *(void *)(a1 + 200) = 0;
  *(void *)(a1 + 208) = 0;
  sub_100311ED8((void *)(a1 + 192), *(void *)(a2 + 192), *(void *)(a2 + 200), 0x2E8BA2E8BA2E8BA3 * ((uint64_t)(*(void *)(a2 + 200) - *(void *)(a2 + 192)) >> 3));
  if (*(char *)(a2 + 239) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 216), *(void **)(a2 + 216), *(void *)(a2 + 224));
  }
  else
  {
    long long v5 = *(_OWORD *)(a2 + 216);
    *(void *)(a1 + 232) = *(void *)(a2 + 232);
    *(_OWORD *)(a1 + 216) = v5;
  }
  long long v6 = (unsigned char *)(a1 + 240);
  if (*(char *)(a2 + 263) < 0)
  {
    sub_10004FC84(v6, *(void **)(a2 + 240), *(void *)(a2 + 248));
  }
  else
  {
    long long v7 = *(_OWORD *)(a2 + 240);
    *(void *)(a1 + 256) = *(void *)(a2 + 256);
    *(_OWORD *)long long v6 = v7;
  }
  *(_WORD *)(a1 + 264) = *(_WORD *)(a2 + 264);
  sub_10002FD9C((const void **)(a1 + 272), (const void **)(a2 + 272));
  BOOL result = sub_100119B5C((const void **)(a1 + 280), (const void **)(a2 + 280));
  uint64_t v9 = *(void *)(a2 + 288);
  *(void *)(a1 + 294) = *(void *)(a2 + 294);
  *(void *)(a1 + 288) = v9;
  return result;
}

void sub_1005E211C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  if (*(char *)(v2 + 239) < 0) {
    operator delete(*v4);
  }
  sub_1000C56F4((void ***)va);
  sub_100309AC4(v3);
  long long v6 = *(std::__shared_weak_count **)(v2 + 48);
  if (v6) {
    std::__shared_weak_count::__release_weak(v6);
  }
  _Unwind_Resume(a1);
}

void sub_1005E2170(uint64_t a1)
{
  uint64_t v2 = (void **)(a1 + 192);
  sub_1000FE824((const void **)(a1 + 280));
  sub_100030068((const void **)(a1 + 272));
  if (*(char *)(a1 + 263) < 0) {
    operator delete(*(void **)(a1 + 240));
  }
  if (*(char *)(a1 + 239) < 0) {
    operator delete(*(void **)(a1 + 216));
  }
  uint64_t v4 = v2;
  sub_1000C56F4(&v4);
  if (*(char *)(a1 + 175) < 0) {
    operator delete(*(void **)(a1 + 152));
  }
  if (*(unsigned char *)(a1 + 112))
  {
    if (*(char *)(a1 + 143) < 0) {
      operator delete(*(void **)(a1 + 120));
    }
    *(unsigned char *)(a1 + 112) = 0;
  }
  if (*(unsigned char *)(a1 + 80))
  {
    if (*(char *)(a1 + 111) < 0) {
      operator delete(*(void **)(a1 + 88));
    }
    *(unsigned char *)(a1 + 80) = 0;
  }
  if (*(char *)(a1 + 79) < 0) {
    operator delete(*(void **)(a1 + 56));
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 48);
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
}

const void **sub_1005E223C(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 48);
  *(void *)(a1 + 40) = *(void *)(a2 + 40);
  *(void *)(a1 + 48) = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 16), 1uLL, memory_order_relaxed);
  }
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 72) = 0;
  sub_100311ED8((void *)(a1 + 56), *(void *)(a2 + 56), *(void *)(a2 + 64), 0x2E8BA2E8BA2E8BA3 * ((uint64_t)(*(void *)(a2 + 64) - *(void *)(a2 + 56)) >> 3));
  if (*(char *)(a2 + 103) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 80), *(void **)(a2 + 80), *(void *)(a2 + 88));
  }
  else
  {
    long long v5 = *(_OWORD *)(a2 + 80);
    *(void *)(a1 + 96) = *(void *)(a2 + 96);
    *(_OWORD *)(a1 + 80) = v5;
  }
  long long v6 = (unsigned char *)(a1 + 104);
  if (*(char *)(a2 + 127) < 0)
  {
    sub_10004FC84(v6, *(void **)(a2 + 104), *(void *)(a2 + 112));
  }
  else
  {
    long long v7 = *(_OWORD *)(a2 + 104);
    *(void *)(a1 + 120) = *(void *)(a2 + 120);
    *(_OWORD *)long long v6 = v7;
  }
  *(_WORD *)(a1 + 128) = *(_WORD *)(a2 + 128);
  sub_10002FD9C((const void **)(a1 + 136), (const void **)(a2 + 136));
  BOOL result = sub_100119B5C((const void **)(a1 + 144), (const void **)(a2 + 144));
  uint64_t v9 = *(void *)(a2 + 152);
  *(void *)(a1 + 158) = *(void *)(a2 + 158);
  *(void *)(a1 + 152) = v9;
  return result;
}

void sub_1005E2348(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  if (*(char *)(v2 + 103) < 0) {
    operator delete(*v3);
  }
  sub_1000C56F4((void ***)va);
  long long v5 = *(std::__shared_weak_count **)(v2 + 48);
  if (v5) {
    std::__shared_weak_count::__release_weak(v5);
  }
  _Unwind_Resume(a1);
}

void sub_1005E238C(uint64_t a1)
{
  uint64_t v2 = (void **)(a1 + 56);
  sub_1000FE824((const void **)(a1 + 144));
  sub_100030068((const void **)(a1 + 136));
  if (*(char *)(a1 + 127) < 0) {
    operator delete(*(void **)(a1 + 104));
  }
  if (*(char *)(a1 + 103) < 0) {
    operator delete(*(void **)(a1 + 80));
  }
  uint64_t v4 = v2;
  sub_1000C56F4(&v4);
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 48);
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
}

uint64_t sub_1005E2400(uint64_t a1)
{
  sub_1000FE824((const void **)(a1 + 104));
  sub_100030068((const void **)(a1 + 96));
  if (*(char *)(a1 + 87) < 0) {
    operator delete(*(void **)(a1 + 64));
  }
  if (*(char *)(a1 + 63) < 0) {
    operator delete(*(void **)(a1 + 40));
  }
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

uint64_t sub_1005E2460(uint64_t a1)
{
  sub_1000FE824((const void **)(a1 + 88));
  sub_100030068((const void **)(a1 + 80));
  if (*(char *)(a1 + 71) < 0) {
    operator delete(*(void **)(a1 + 48));
  }
  if (*(char *)(a1 + 47) < 0) {
    operator delete(*(void **)(a1 + 24));
  }
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 8);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_1005E24C0(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 8);
  if (v1)
  {
    if (std::__shared_weak_count::lock(v1)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_1005E26EC(void *a1)
{
  if (*(char *)(v1 + 239) < 0) {
    operator delete(*v2);
  }
  sub_10032A36C(v1 + 24);
  uint64_t v4 = *(std::__shared_weak_count **)(v1 + 16);
  if (v4) {
    sub_10004D2C8(v4);
  }
  sub_10006A6AC(a1);
}

uint64_t sub_1005E2730(uint64_t a1)
{
  sub_1000FE824((const void **)(a1 + 280));
  sub_100030068((const void **)(a1 + 272));
  if (*(char *)(a1 + 263) < 0) {
    operator delete(*(void **)(a1 + 240));
  }
  if (*(char *)(a1 + 239) < 0) {
    operator delete(*(void **)(a1 + 216));
  }
  sub_10032A36C(a1 + 24);
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2) {
    sub_10004D2C8(v2);
  }
  return a1;
}

void sub_1005E2798(uint64_t a1, const std::string *a2, uint64_t a3)
{
  *(_OWORD *)CFTypeRef cf = 0u;
  *(_OWORD *)long long v37 = 0u;
  *(_DWORD *)&v37[20] = 0;
  memset(v35, 0, sizeof(v35));
  v37[8] = 2;
  *(void *)&v37[12] = 0x50000003CLL;
  std::string::operator=(v35, a2);
  int v6 = *(unsigned __int8 *)(a1 + 128);
  if (v6 == 2)
  {
    long long v41 = 0u;
    long long v42 = 0u;
    memset(v40, 0, sizeof(v40));
    int v8 = *(unsigned __int8 **)(a1 + 136);
    uint64_t v9 = *(unsigned __int8 **)(a1 + 144);
    if (SHIBYTE(a2->__r_.__value_.__r.__words[2]) < 0)
    {
      sub_10004FC84(&__dst, a2->__r_.__value_.__l.__data_, a2->__r_.__value_.__l.__size_);
    }
    else
    {
      long long __dst = *(_OWORD *)&a2->__r_.__value_.__l.__data_;
      uint64_t v39 = a2->__r_.__value_.__r.__words[2];
    }
    uint64_t v10 = HIBYTE(v39);
    if (v8 != v9)
    {
      long long v11 = __dst;
      if (v39 >= 0) {
        uint64_t v12 = HIBYTE(v39);
      }
      else {
        uint64_t v12 = *((void *)&__dst + 1);
      }
      do
      {
        uint64_t v13 = v8[23];
        int v14 = (char)v13;
        if ((v13 & 0x80u) != 0) {
          uint64_t v13 = *((void *)v8 + 1);
        }
        if (v12 == v13)
        {
          if (v14 >= 0) {
            uint64_t v15 = v8;
          }
          else {
            uint64_t v15 = *(unsigned __int8 **)v8;
          }
          if ((v10 & 0x80) != 0)
          {
            if (!memcmp((const void *)v11, v15, *((size_t *)&v11 + 1))) {
              goto LABEL_28;
            }
          }
          else
          {
            if (!v10) {
              goto LABEL_29;
            }
            p_dst = (unsigned __int8 *)&__dst;
            uint64_t v17 = v10;
            while (*p_dst == *v15)
            {
              ++p_dst;
              ++v15;
              if (!--v17) {
                goto LABEL_27;
              }
            }
          }
        }
        v8 += 64;
      }
      while (v8 != v9);
      int v8 = v9;
    }
LABEL_27:
    if ((v10 & 0x80) != 0) {
LABEL_28:
    }
      operator delete((void *)__dst);
LABEL_29:
    if (v8 != *(unsigned __int8 **)(a1 + 144))
    {
      std::string::operator=((std::string *)v40, (const std::string *)v8);
      *(_WORD *)&v40[24] = *((_WORD *)v8 + 12);
      std::string::operator=((std::string *)&v41, (const std::string *)(v8 + 32));
      int v18 = *((_DWORD *)v8 + 14);
      BYTE12(v42) = v8[60];
      DWORD2(v42) = v18;
    }
    if (v40[24]) {
      BOOL v19 = v40[25] == 0;
    }
    else {
      BOOL v19 = 1;
    }
    if (v19) {
      char v7 = 1;
    }
    else {
      char v7 = 2;
    }
    if (SBYTE7(v42) < 0) {
      operator delete((void *)v41);
    }
    if ((v40[23] & 0x80000000) != 0) {
      operator delete(*(void **)v40);
    }
  }
  else if (v6 == 1)
  {
    char v7 = 0;
  }
  else
  {
    char v7 = 2;
  }
  v37[8] = v7;
  memset(v40, 0, 24);
  PB::Writer::Writer((PB::Writer *)v40);
  (*(void (**)(uint64_t, unsigned char *))(*(void *)a3 + 24))(a3, v40);
  if (*(void *)v40 == *(void *)&v40[8]) {
    CFDataRef v20 = 0;
  }
  else {
    CFDataRef v20 = CFDataCreate(kCFAllocatorDefault, *(const UInt8 **)&v40[8], *(void *)v40 - *(void *)&v40[8]);
  }
  *(void *)&long long __dst = v20;
  PB::Writer::~Writer((PB::Writer *)v40);
  *(CFTypeRef *)long long v40 = cf[1];
  cf[1] = (CFTypeRef)__dst;
  *(void *)&long long __dst = 0;
  sub_100030068(v21);
  sub_100030068((const void **)&__dst);
  int v22 = *(unsigned __int8 *)(a1 + 128);
  BOOL v23 = v22 == 2;
  if (v22 == 2) {
    __int16 v24 = 9;
  }
  else {
    __int16 v24 = 5;
  }
  LOWORD(cf[0]) = v24;
  if (v23)
  {
    if (v37[8] == 1)
    {
      uint64_t v26 = *(void *)(a1 + 80);
      uint64_t v25 = *(void *)(a1 + 88);
      if (!v25)
      {
LABEL_54:
        uint64_t v27 = *(std::__shared_weak_count **)(a1 + 56);
        *(void *)(a1 + 48) = v26;
        *(void *)(a1 + 56) = v25;
        if (v27) {
          sub_10004D2C8(v27);
        }
        goto LABEL_56;
      }
    }
    else
    {
      uint64_t v26 = *(void *)(a1 + 64);
      uint64_t v25 = *(void *)(a1 + 72);
      if (!v25) {
        goto LABEL_54;
      }
    }
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v25 + 8), 1uLL, memory_order_relaxed);
    goto LABEL_54;
  }
LABEL_56:
  uint64_t v28 = *(void *)(a1 + 48);
  if (SHIBYTE(v35[0].__r_.__value_.__r.__words[2]) < 0) {
    sub_10004FC84(&v29, v35[0].__r_.__value_.__l.__data_, v35[0].__r_.__value_.__l.__size_);
  }
  else {
    std::string v29 = v35[0];
  }
  if (SHIBYTE(v35[1].__r_.__value_.__r.__words[2]) < 0) {
    sub_10004FC84(&__p, v35[1].__r_.__value_.__l.__data_, v35[1].__r_.__value_.__l.__size_);
  }
  else {
    std::string __p = v35[1];
  }
  __int16 v31 = (__int16)cf[0];
  CFTypeRef v32 = cf[1];
  if (cf[1]) {
    CFRetain(cf[1]);
  }
  long long v33 = *(const void **)v37;
  if (*(void *)v37) {
    CFRetain(*(CFTypeRef *)v37);
  }
  v34[0] = *(void *)&v37[8];
  *(void *)((char *)v34 + 6) = *(void *)&v37[14];
  (*(void (**)(uint64_t, std::string *, void))(*(void *)v28 + 32))(v28, &v29, 0);
  sub_1000FE824(&v33);
  sub_100030068(&v32);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v29.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v29.__r_.__value_.__l.__data_);
  }
  sub_1000FE824((const void **)v37);
  sub_100030068(&cf[1]);
  if (SHIBYTE(v35[1].__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v35[1].__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v35[0].__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v35[0].__r_.__value_.__l.__data_);
  }
}

void sub_1005E2BB0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,char a24)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  sub_1003C1D74((uint64_t)&a24);
  _Unwind_Resume(a1);
}

void sub_1005E2C1C(uint64_t a1, const std::string *a2, uint64_t a3, uint64_t a4, const unsigned __int8 *a5, unsigned char *a6)
{
  uint64_t v12 = (uint64_t **)(a1 + 160);
  if (sub_1005E896C(a1 + 160, a4))
  {
    memset(&buf, 0, sizeof(buf));
    uint64_t v26 = (uint64_t (**)(PB::Base *))a4;
    uint64_t v13 = sub_1003DE940(v12, a4, (uint64_t)&unk_10144E20E, (_OWORD **)&v26);
    if (*((char *)v13 + 71) < 0) {
      sub_10004FC84(&buf, *((void **)v13 + 6), *((void *)v13 + 7));
    }
    else {
      std::string buf = *(std::string *)((unsigned char *)v13 + 2);
    }
    uint64_t v26 = &off_101A71018;
    long long v27 = 0u;
    long long v28 = 0u;
    long long v29 = 0u;
    uint64_t v30 = 0;
    sub_100F37FC8((uint64_t)&v26);
    uint64_t v18 = *((void *)&v28 + 1);
    BOOL v19 = *(std::string **)(*((void *)&v28 + 1) + 32);
    if (!v19) {
      operator new();
    }
    std::string::operator=(v19, a2);
    CFDataRef v20 = *(std::string **)(v18 + 8);
    if (!v20) {
      operator new();
    }
    std::string::operator=(v20, (const std::string *)a3);
    uint64_t v21 = *(PB::Data **)(v18 + 16);
    if (!v21) {
      operator new();
    }
    PB::Data::assign(v21, a5, a5 + 16);
    int v22 = *(PB::Data **)(v18 + 24);
    if (!v22) {
      operator new();
    }
    PB::Data::assign(v22, (const unsigned __int8 *)a4, (const unsigned __int8 *)(a4 + 16));
    int v23 = *a6;
    switch(*a6)
    {
      case 1:
        goto LABEL_25;
      case 2:
        int v23 = 0;
        goto LABEL_25;
      case 3:
        int v23 = 2;
LABEL_25:
        *(unsigned char *)(v18 + 44) |= 1u;
        *(_DWORD *)(v18 + 40) = v23;
        goto LABEL_26;
      case 4:
        uint64_t v25 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)__int16 v31 = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_ERROR, "consent state is unknown", v31, 2u);
        }
        goto LABEL_29;
      default:
LABEL_26:
        __int16 v24 = *(NSObject **)(a1 + 40);
        if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)__int16 v31 = 0;
          _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "#I [TransferConsentInd]", v31, 2u);
        }
        sub_1005E2798(a1, &buf, (uint64_t)&v26);
LABEL_29:
        sub_100F37268((PB::Base *)&v26);
        if ((SHIBYTE(buf.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
          return;
        }
        uint64_t v17 = (uint64_t (**)(PB::Base *))buf.__r_.__value_.__r.__words[0];
        break;
    }
    goto LABEL_31;
  }
  int v14 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
  {
    sCardSerialNumberAsString();
    uint64_t v15 = v27 >= 0 ? &v26 : (uint64_t (***)(PB::Base *))v26;
    std::string::size_type v16 = *(char *)(a3 + 23) >= 0 ? a3 : *(void *)a3;
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315394;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v15;
    WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
    *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = v16;
    _os_log_error_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "no device id find for target eid: %s when sending transfer profile response for iccid:%s", (uint8_t *)&buf, 0x16u);
    if (SHIBYTE(v27) < 0)
    {
      uint64_t v17 = v26;
LABEL_31:
      operator delete(v17);
    }
  }
}

void sub_1005E3008(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24)
{
  if (a24 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_1005E3048(uint64_t a1, const std::string *a2, uint64_t a3, uint64_t a4, const unsigned __int8 *a5, unsigned __int8 *a6, uint64_t a7)
{
  int v14 = (uint64_t **)(a1 + 160);
  if (sub_1005E896C(a1 + 160, a3))
  {
    memset(&buf, 0, sizeof(buf));
    long long v38 = (uint64_t (**)(PB::Base *))a3;
    uint64_t v15 = sub_1003DE940(v14, a3, (uint64_t)&unk_10144E20E, (_OWORD **)&v38);
    if (*((char *)v15 + 71) < 0) {
      sub_10004FC84(&buf, *((void **)v15 + 6), *((void *)v15 + 7));
    }
    else {
      std::string buf = *(std::string *)((unsigned char *)v15 + 2);
    }
    long long v38 = &off_101A71018;
    long long v39 = 0u;
    long long v40 = 0u;
    long long v41 = 0u;
    uint64_t v42 = 0;
    sub_100F37CEC((uint64_t)&v38);
    uint64_t v20 = v41;
    uint64_t v21 = *(std::string **)(v41 + 48);
    if (!v21) {
      operator new();
    }
    std::string::operator=(v21, a2);
    int v22 = *(std::string **)(v20 + 32);
    if (!v22) {
      operator new();
    }
    std::string::operator=(v22, (const std::string *)a4);
    int v23 = *(PB::Data **)(v20 + 8);
    if (!v23) {
      operator new();
    }
    PB::Data::assign(v23, a5, a5 + 16);
    __int16 v24 = *(PB::Data **)(v20 + 40);
    if (!v24) {
      operator new();
    }
    PB::Data::assign(v24, (const unsigned __int8 *)a3, (const unsigned __int8 *)(a3 + 16));
    int v25 = *a6;
    if (v25 == 1)
    {
      unsigned __int8 v27 = a6[1];
      *(unsigned char *)(v20 + 68) |= 4u;
      *(unsigned char *)(v20 + 64) = v27;
      if (*(unsigned char *)(a7 + 25)
        || *(unsigned char *)(a7 + 56)
        || *(unsigned char *)(a7 + 88)
        || *(unsigned char *)(a7 + 120)
        || *(unsigned char *)(a7 + 152))
      {
        goto LABEL_34;
      }
      uint64_t v28 = *(unsigned __int8 *)(a7 + 191);
      if ((v28 & 0x80u) != 0) {
        uint64_t v28 = *(void *)(a7 + 176);
      }
      if (v28 || *(unsigned char *)(a7 + 224))
      {
LABEL_34:
        sub_100A193EC(v20);
        uint64_t v29 = *(void *)(v20 + 16);
        if (*(unsigned char *)(a7 + 25))
        {
          int v30 = *(unsigned __int8 *)(a7 + 24);
          *(unsigned char *)(v29 + 88) |= 8u;
          *(_DWORD *)(v29 + 80) = v30;
        }
        if (*(unsigned char *)(a7 + 56))
        {
          sub_1005E48E8(v29);
          std::string::operator=(*(std::string **)(v29 + 64), (const std::string *)(a7 + 32));
        }
        if (*(unsigned char *)(a7 + 88))
        {
          sub_1005E495C(v29);
          std::string::operator=(*(std::string **)(v29 + 40), (const std::string *)(a7 + 64));
        }
        if (*(unsigned char *)(a7 + 120))
        {
          sub_1005E49D0(v29);
          std::string::operator=(*(std::string **)(v29 + 32), (const std::string *)(a7 + 96));
        }
        if (*(unsigned char *)(a7 + 152))
        {
          sub_1005E4A44(v29);
          std::string::operator=(*(std::string **)(v29 + 56), (const std::string *)(a7 + 128));
        }
        int v31 = *(unsigned __int8 *)(a7 + 194);
        *(unsigned char *)(v29 + 88) |= 4u;
        *(_DWORD *)(v29 + 76) = v31;
        uint64_t v32 = *(unsigned __int8 *)(a7 + 191);
        if ((v32 & 0x80u) != 0) {
          uint64_t v32 = *(void *)(a7 + 176);
        }
        if (v32)
        {
          sub_1005E4AB8(v29);
          std::string::operator=(*(std::string **)(v29 + 48), (const std::string *)(a7 + 168));
        }
        if (*(unsigned char *)(a7 + 224))
        {
          sub_1005E4B2C(v29);
          std::string::operator=(*(std::string **)(v29 + 16), (const std::string *)(a7 + 200));
        }
        if (*(unsigned char *)(a7 + 240))
        {
          uint64_t v33 = *(void *)(a7 + 232);
          *(unsigned char *)(v29 + 88) |= 1u;
          *(void *)(v29 + 8) = v33;
        }
      }
      if (*(unsigned char *)(a7 + 161))
      {
        unsigned int v34 = *(unsigned __int8 *)(a7 + 160) - 2;
        if (v34 > 2) {
          int v35 = 1;
        }
        else {
          int v35 = dword_1014C71A4[(char)v34];
        }
        *(unsigned char *)(v20 + 68) |= 1u;
        *(_DWORD *)(v20 + 56) = v35;
      }
    }
    else
    {
      if (v25 != 2)
      {
        exception = (ctu::ResultIsEmptyError *)__cxa_allocate_exception(0x10uLL);
        ctu::ResultIsEmptyError::ResultIsEmptyError(exception);
      }
      int v26 = a6[1];
      *(unsigned char *)(v20 + 68) |= 2u;
      *(_DWORD *)(v20 + 60) = v26;
    }
    long long v36 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v43 = 0;
      _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_DEFAULT, "#I [TransferProfileInd]", v43, 2u);
    }
    sub_1005E2798(a1, &buf, (uint64_t)&v38);
    sub_100F37268((PB::Base *)&v38);
    if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0)
    {
      BOOL v19 = (uint64_t (**)(PB::Base *))buf.__r_.__value_.__r.__words[0];
      goto LABEL_61;
    }
  }
  else
  {
    std::string::size_type v16 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
    {
      sCardSerialNumberAsString();
      uint64_t v17 = v39 >= 0 ? &v38 : (uint64_t (***)(PB::Base *))v38;
      std::string::size_type v18 = *(char *)(a4 + 23) >= 0 ? a4 : *(void *)a4;
      LODWORD(buf.__r_.__value_.__l.__data_) = 136315394;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v17;
      WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
      *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = v18;
      _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "no device id find for target eid: %s when sending transfer profile response for iccid:%s", (uint8_t *)&buf, 0x16u);
      if (SHIBYTE(v39) < 0)
      {
        BOOL v19 = v38;
LABEL_61:
        operator delete(v19);
      }
    }
  }
}

void sub_1005E35C0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24)
{
  __cxa_free_exception(v24);
  sub_100F37268((PB::Base *)&a9);
  if (a24 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_1005E3604(uint64_t a1, uint64_t a2, uint64_t a3, unsigned __int8 *a4)
{
  v23[0] = a2;
  v23[1] = a3;
  int v6 = (uint64_t **)(a1 + 160);
  if (sub_1005E896C(a1 + 160, (uint64_t)v23))
  {
    memset(&buf, 0, sizeof(buf));
    uint64_t v17 = (uint64_t (**)(PB::Base *))v23;
    char v7 = sub_1003DE940(v6, (uint64_t)v23, (uint64_t)&unk_10144E20E, (_OWORD **)&v17);
    if (*((char *)v7 + 71) < 0) {
      sub_10004FC84(&buf, *((void **)v7 + 6), *((void *)v7 + 7));
    }
    else {
      std::string buf = *(std::string *)((unsigned char *)v7 + 2);
    }
    uint64_t v17 = &off_101A71018;
    long long v18 = 0u;
    long long v19 = 0u;
    long long v20 = 0u;
    uint64_t v21 = 0;
    sub_100F37F18((uint64_t)&v17);
    uint64_t v11 = v19;
    if ((char)a4[31] < 0)
    {
      if (!*((void *)a4 + 2)) {
        goto LABEL_18;
      }
    }
    else if (!a4[31])
    {
      goto LABEL_18;
    }
    uint64_t v12 = *(std::string **)(v19 + 8);
    if (!v12) {
      operator new();
    }
    std::string::operator=(v12, (const std::string *)(a4 + 8));
LABEL_18:
    if ((char)a4[55] < 0)
    {
      if (!*((void *)a4 + 5)) {
        goto LABEL_25;
      }
    }
    else if (!a4[55])
    {
      goto LABEL_25;
    }
    uint64_t v13 = *(std::string **)(v11 + 16);
    if (!v13) {
      operator new();
    }
    std::string::operator=(v13, (const std::string *)(a4 + 32));
LABEL_25:
    int v14 = *a4;
    *(unsigned char *)(v11 + 28) |= 1u;
    *(_DWORD *)(v11 + 24) = v14;
    uint64_t v15 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string::size_type v16 = 0;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I [PurchasePlanInd]", v16, 2u);
    }
    sub_1005E2798(a1, &buf, (uint64_t)&v17);
    sub_100F37268((PB::Base *)&v17);
    if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0)
    {
      uint64_t v10 = (uint64_t (**)(PB::Base *))buf.__r_.__value_.__r.__words[0];
      goto LABEL_29;
    }
    return;
  }
  int v8 = *(NSObject **)(a1 + 40);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
  {
    sCardSerialNumberAsString();
    uint64_t v9 = v18 >= 0 ? &v17 : (uint64_t (***)(PB::Base *))v17;
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v9;
    _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "No device id find for target eid: %s when sending remote plan sign up purchase info", (uint8_t *)&buf, 0xCu);
    if (SHIBYTE(v18) < 0)
    {
      uint64_t v10 = v17;
LABEL_29:
      operator delete(v10);
    }
  }
}

void sub_1005E38D4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24)
{
  if (a24 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_1005E3904(uint64_t a1, const unsigned __int8 *a2, uint64_t a3)
{
  uint64_t v4 = *(long long **)(a1 + 136);
  if (v4 == *(long long **)(a1 + 144))
  {
    int v8 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v17) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "No devices found", (uint8_t *)&v17, 2u);
    }
  }
  else if (*(void *)a3 == *(void *)(a3 + 8))
  {
    uint64_t v9 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v17) = 0;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I No subscription details to send, aborting", (uint8_t *)&v17, 2u);
    }
  }
  else
  {
    long long v33 = 0u;
    long long v34 = 0u;
    long long __dst = 0u;
    long long v32 = 0u;
    if (*((char *)v4 + 23) < 0)
    {
      sub_10004FC84(&__dst, *(void **)v4, *((void *)v4 + 1));
    }
    else
    {
      long long v7 = *v4;
      *(void *)&long long v32 = *((void *)v4 + 2);
      long long __dst = v7;
    }
    LOWORD(v10) = *((_WORD *)v4 + 12);
    WORD4(v32) = v10;
    if (*((char *)v4 + 55) < 0)
    {
      sub_10004FC84(&v33, *((void **)v4 + 4), *((void *)v4 + 5));
      int v10 = BYTE8(v32);
    }
    else
    {
      int v10 = v10;
      long long v11 = v4[2];
      *(void *)&long long v34 = *((void *)v4 + 6);
      long long v33 = v11;
    }
    int v12 = *((_DWORD *)v4 + 14);
    BYTE12(v34) = *((unsigned char *)v4 + 60);
    DWORD2(v34) = v12;
    if (v10 || *(unsigned char *)(a1 + 128) == 2)
    {
      int v26 = &off_101A71018;
      long long v27 = 0u;
      long long v28 = 0u;
      long long v29 = 0u;
      uint64_t v30 = 0;
      sub_100F37DAC((uint64_t)&v26);
      int v14 = *(PB::Data **)(*((void *)&v29 + 1) + 8);
      if (!v14) {
        operator new();
      }
      PB::Data::assign(v14, a2, a2 + 16);
      uint64_t v15 = *(std::string **)a3;
      if (*(void *)a3 != *(void *)(a3 + 8))
      {
        int v23 = 0;
        uint64_t v25 = 0;
        uint64_t v22 = 0;
        uint64_t v17 = &off_1019ED3A0;
        int v24 = 0;
        long long v18 = 0u;
        long long v19 = 0u;
        long long v20 = 0u;
        uint64_t v21 = 0;
        sub_100879964(v15, (uint64_t)&v17);
        sub_1005E3C88();
      }
      std::string::size_type v16 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(v17) = 0;
        _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I [UpdateSubscriptionInd]", (uint8_t *)&v17, 2u);
      }
      sub_1005E2798(a1, (const std::string *)&__dst, (uint64_t)&v26);
      sub_100F37268((PB::Base *)&v26);
    }
    else
    {
      uint64_t v13 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
      {
        LOWORD(v17) = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "Device cannot send message", (uint8_t *)&v17, 2u);
      }
    }
    if (SBYTE7(v34) < 0) {
      operator delete((void *)v33);
    }
    if (SBYTE7(v32) < 0) {
      operator delete((void *)__dst);
    }
  }
}

void sub_1005E3C44(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21)
{
  if (*(char *)(v21 - 105) < 0) {
    operator delete(*(void **)(v21 - 128));
  }
  _Unwind_Resume(exception_object);
}

void sub_1005E3C88()
{
}

void sub_1005E3D8C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1004660D8((void **)va);
  _Unwind_Resume(a1);
}

void sub_1005E3DD0(uint64_t a1, const unsigned __int8 *a2, uint64_t a3)
{
  uint64_t v4 = *(long long **)(a1 + 136);
  if (v4 == *(long long **)(a1 + 144))
  {
    int v8 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "No devices found", buf, 2u);
    }
  }
  else if (*(void *)a3 == *(void *)(a3 + 8))
  {
    uint64_t v9 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I No pending plans to send, aborting", buf, 2u);
    }
  }
  else
  {
    *(_OWORD *)std::string __p = 0u;
    long long v28 = 0u;
    *(_OWORD *)std::string buf = 0u;
    long long v26 = 0u;
    if (*((char *)v4 + 23) < 0)
    {
      sub_10004FC84(buf, *(void **)v4, *((void *)v4 + 1));
    }
    else
    {
      long long v7 = *v4;
      *(void *)&long long v26 = *((void *)v4 + 2);
      *(_OWORD *)std::string buf = v7;
    }
    LOWORD(v10) = *((_WORD *)v4 + 12);
    WORD4(v26) = v10;
    if (*((char *)v4 + 55) < 0)
    {
      sub_10004FC84(__p, *((void **)v4 + 4), *((void *)v4 + 5));
      int v10 = BYTE8(v26);
    }
    else
    {
      int v10 = v10;
      long long v11 = v4[2];
      *(void *)&long long v28 = *((void *)v4 + 6);
      *(_OWORD *)std::string __p = v11;
    }
    int v12 = *((_DWORD *)v4 + 14);
    BYTE12(v28) = *((unsigned char *)v4 + 60);
    DWORD2(v28) = v12;
    if (v10 || *(unsigned char *)(a1 + 128) == 2)
    {
      *(void *)long long v20 = &off_101A71018;
      long long v21 = 0u;
      long long v22 = 0u;
      long long v23 = 0u;
      uint64_t v24 = 0;
      sub_100F37E60((uint64_t)v20);
      sub_1005E4110(*((uint64_t *)&v21 + 1));
      PB::Data::assign(*(PB::Data **)(*((void *)&v21 + 1) + 8), a2, a2 + 16);
      uint64_t v14 = *((void *)&v21 + 1);
      *(unsigned char *)(*((void *)&v21 + 1) + 52) |= 1u;
      *(_DWORD *)(v14 + 48) = 2;
      uint64_t v15 = *(std::string **)a3;
      if (*(void *)a3 != *(void *)(a3 + 8))
      {
        uint64_t v17 = &off_101A2B478;
        long long v18 = 0u;
        long long v19 = 0u;
        sub_1008797E4(v15, (uint64_t)&v17);
        sub_1005E4178();
      }
      std::string::size_type v16 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(v17) = 0;
        _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#I [ProfileStatusInd]", (uint8_t *)&v17, 2u);
      }
      sub_1005E2798(a1, (const std::string *)buf, (uint64_t)v20);
      sub_100F37268((PB::Base *)v20);
    }
    else
    {
      uint64_t v13 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long v20 = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "Device cannot send message", v20, 2u);
      }
    }
    if (SBYTE7(v28) < 0) {
      operator delete(__p[0]);
    }
    if (SBYTE7(v26) < 0) {
      operator delete(*(void **)buf);
    }
  }
}

void sub_1005E40CC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  if (a28 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1005E4110(uint64_t result)
{
  if (!*(void *)(result + 8)) {
    operator new();
  }
  return result;
}

void sub_1005E4178()
{
}

void sub_1005E427C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1004660D8((void **)va);
  _Unwind_Resume(a1);
}

void sub_1005E42C0(uint64_t a1, const unsigned __int8 *a2, uint64_t a3, int a4)
{
  long long v5 = *(long long **)(a1 + 136);
  if (v5 == *(long long **)(a1 + 144))
  {
    int v10 = *(NSObject **)(a1 + 40);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "No devices found", buf, 2u);
    }
  }
  else
  {
    *(_OWORD *)std::string __p = 0u;
    long long v28 = 0u;
    *(_OWORD *)std::string buf = 0u;
    long long v26 = 0u;
    if (*((char *)v5 + 23) < 0)
    {
      sub_10004FC84(buf, *(void **)v5, *((void *)v5 + 1));
    }
    else
    {
      long long v9 = *v5;
      *(void *)&long long v26 = *((void *)v5 + 2);
      *(_OWORD *)std::string buf = v9;
    }
    LOWORD(v11) = *((_WORD *)v5 + 12);
    WORD4(v26) = v11;
    if (*((char *)v5 + 55) < 0)
    {
      sub_10004FC84(__p, *((void **)v5 + 4), *((void *)v5 + 5));
      int v11 = BYTE8(v26);
    }
    else
    {
      int v11 = v11;
      long long v12 = v5[2];
      *(void *)&long long v28 = *((void *)v5 + 6);
      *(_OWORD *)std::string __p = v12;
    }
    int v13 = *((_DWORD *)v5 + 14);
    BYTE12(v28) = *((unsigned char *)v5 + 60);
    DWORD2(v28) = v13;
    if (v11 || *(unsigned char *)(a1 + 128) == 2)
    {
      *(void *)long long v20 = &off_101A71018;
      long long v21 = 0u;
      long long v22 = 0u;
      long long v23 = 0u;
      uint64_t v24 = 0;
      sub_100F37E60((uint64_t)v20);
      sub_1005E4110(*((uint64_t *)&v21 + 1));
      PB::Data::assign(*(PB::Data **)(*((void *)&v21 + 1) + 8), a2, a2 + 16);
      uint64_t v15 = *((void *)&v21 + 1);
      *(unsigned char *)(*((void *)&v21 + 1) + 52) |= 1u;
      *(_DWORD *)(v15 + 48) = a4 ^ 1;
      uint64_t v16 = *(unsigned __int8 *)(a3 + 23);
      if ((v16 & 0x80u) != 0) {
        uint64_t v16 = *(void *)(a3 + 8);
      }
      if (v16)
      {
        uint64_t v17 = *(std::string **)(v15 + 16);
        if (!v17) {
          operator new();
        }
        std::string::operator=(v17, (const std::string *)a3);
      }
      long long v18 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long v19 = 0;
        _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#I [ProfileStatusInd]", v19, 2u);
      }
      sub_1005E2798(a1, (const std::string *)buf, (uint64_t)v20);
      sub_100F37268((PB::Base *)v20);
    }
    else
    {
      uint64_t v14 = *(NSObject **)(a1 + 40);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long v20 = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "Device cannot send message", v20, 2u);
      }
    }
    if (SBYTE7(v28) < 0) {
      operator delete(__p[0]);
    }
    if (SBYTE7(v26) < 0) {
      operator delete(*(void **)buf);
    }
  }
}

void sub_1005E4568(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24)
{
  if (a24 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1005E459C(uint64_t a1, std::string *__str, std::string *a3, unint64_t a4)
{
  uint64_t v8 = a1 + 16;
  long long v9 = *(std::string **)a1;
  if (a4 > (uint64_t)(*(void *)(a1 + 16) - *(void *)a1) >> 6)
  {
    sub_1005E46EC((void **)a1);
    if (a4 >> 58) {
      sub_10006A748();
    }
    uint64_t v10 = *(void *)(a1 + 16) - *(void *)a1;
    uint64_t v11 = v10 >> 5;
    if (v10 >> 5 <= a4) {
      uint64_t v11 = a4;
    }
    if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFC0) {
      unint64_t v12 = 0x3FFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v12 = v11;
    }
    sub_1001A1088((void *)a1, v12);
    uint64_t v13 = sub_1003C1C40(v8, (uint64_t)__str, (uint64_t)a3, *(void *)(a1 + 8));
    goto LABEL_11;
  }
  unint64_t v14 = (uint64_t)(*(void *)(a1 + 8) - (void)v9) >> 6;
  if (v14 < a4)
  {
    uint64_t v15 = (std::string *)((char *)__str + 64 * v14);
    sub_1005E4754((int)&v19, __str, v15, v9);
    uint64_t v13 = sub_1003C1C40(v8, (uint64_t)v15, (uint64_t)a3, *(void *)(a1 + 8));
LABEL_11:
    *(void *)(a1 + 8) = v13;
    return;
  }
  sub_1005E4754((int)&v20, __str, a3, v9);
  uint64_t v17 = v16;
  uint64_t v18 = *(void *)(a1 + 8);
  if (v18 != v16)
  {
    do
    {
      v18 -= 64;
      sub_1002B2A44(v18);
    }
    while (v18 != v17);
  }
  *(void *)(a1 + 8) = v17;
}

void sub_1005E46DC(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

void sub_1005E46E4(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

void sub_1005E46EC(void **a1)
{
  uint64_t v1 = *a1;
  if (*a1)
  {
    uint64_t v3 = (uint64_t)a1[1];
    uint64_t v4 = *a1;
    if ((void *)v3 != v1)
    {
      do
      {
        v3 -= 64;
        sub_1002B2A44(v3);
      }
      while ((void *)v3 != v1);
      uint64_t v4 = *a1;
    }
    a1[1] = v1;
    operator delete(v4);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

std::string *sub_1005E4754(int a1, std::string *__str, std::string *a3, std::string *this)
{
  long long v5 = __str;
  if (__str == a3) {
    return __str;
  }
  int v6 = a3;
  do
  {
    std::string::operator=(this, v5);
    LOWORD(this[1].__r_.__value_.__l.__data_) = v5[1].__r_.__value_.__l.__data_;
    std::string::operator=((std::string *)((char *)this + 32), (std::string *)((char *)v5 + 32));
    std::string::value_type v7 = v5[2].__r_.__value_.__s.__data_[12];
    LODWORD(this[2].__r_.__value_.__r.__words[1]) = v5[2].__r_.__value_.__r.__words[1];
    this[2].__r_.__value_.__s.__data_[12] = v7;
    this = (std::string *)((char *)this + 64);
    long long v5 = (std::string *)((char *)v5 + 64);
  }
  while (v5 != v6);
  return v6;
}

unsigned char *sub_1005E47DC(unsigned char *a1)
{
  if (*a1) {
    sub_1005E4814((uint64_t)a1);
  }
  return a1;
}

void sub_1005E4814(uint64_t a1)
{
  if (*(char *)(a1 + 63) < 0) {
    operator delete(*(void **)(a1 + 40));
  }
  if (*(char *)(a1 + 39) < 0) {
    operator delete(*(void **)(a1 + 16));
  }
  *(unsigned char *)a1 = 0;
}

void sub_1005E4864(void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  if (v2)
  {
    uint64_t v4 = (uint64_t)v1[1];
    long long v5 = **a1;
    if ((void *)v4 != v2)
    {
      do
      {
        v4 -= 80;
        sub_10010C078(v4);
      }
      while ((void *)v4 != v2);
      long long v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t sub_1005E48E8(uint64_t result)
{
  if (!*(void *)(result + 64)) {
    operator new();
  }
  return result;
}

uint64_t sub_1005E495C(uint64_t result)
{
  if (!*(void *)(result + 40)) {
    operator new();
  }
  return result;
}

uint64_t sub_1005E49D0(uint64_t result)
{
  if (!*(void *)(result + 32)) {
    operator new();
  }
  return result;
}

uint64_t sub_1005E4A44(uint64_t result)
{
  if (!*(void *)(result + 56)) {
    operator new();
  }
  return result;
}

uint64_t sub_1005E4AB8(uint64_t result)
{
  if (!*(void *)(result + 48)) {
    operator new();
  }
  return result;
}

uint64_t sub_1005E4B2C(uint64_t result)
{
  if (!*(void *)(result + 16)) {
    operator new();
  }
  return result;
}

uint64_t sub_1005E4BA0(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

uint64_t sub_1005E4BB0(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_1005E4BCC(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    sub_10004D2C8(v1);
  }
}

void sub_1005E4BE0()
{
}

void *sub_1005E4BF4(uint64_t a1)
{
  BOOL result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = off_1019ED100;
  result[1] = v3;
  return result;
}

uint64_t sub_1005E4C3C(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_1019ED100;
  a2[1] = v2;
  return result;
}

void sub_1005E4C68(uint64_t a1, uint64_t a2)
{
  if (*(char *)(a2 + 23) >= 0) {
    uint64_t v2 = (const char *)a2;
  }
  else {
    uint64_t v2 = *(const char **)a2;
  }
  xpc_object_t v3 = xpc_string_create(v2);
  if (!v3) {
    xpc_object_t v3 = xpc_null_create();
  }
  sub_100058DB0(&__p, "/cc/props/local_ids_device_id");
  xpc_object_t object = v3;
  if (v3) {
    xpc_retain(v3);
  }
  else {
    xpc_object_t object = xpc_null_create();
  }
  ctu::RestModule::setProperty();
  xpc_release(object);
  if (v6 < 0) {
    operator delete(__p);
  }
  xpc_release(v3);
}

void sub_1005E4D24(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t object, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  xpc_release(object);
  if (a15 < 0) {
    operator delete(__p);
  }
  xpc_release(v15);
  _Unwind_Resume(a1);
}

uint64_t sub_1005E4D6C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1005E4DAC()
{
}

void *sub_1005E4DB8(void *result, void *a2)
{
  if (a2 != result)
  {
    xpc_object_t v3 = result;
    uint64_t v4 = (void *)result[3];
    long long v5 = (void *)a2[3];
    if (v4 == result)
    {
      if (v5 == a2)
      {
        memset(v6, 0, sizeof(v6));
        (*(void (**)(void *, void *))(*result + 24))(result, v6);
        (*(void (**)(void))(*(void *)v3[3] + 32))(v3[3]);
        double v3[3] = 0;
        (*(void (**)(void, void *))(*(void *)a2[3] + 24))(a2[3], v3);
        (*(void (**)(void))(*(void *)a2[3] + 32))(a2[3]);
        a2[3] = 0;
        double v3[3] = v3;
        (*(void (**)(void *, void *))(v6[0] + 24))(v6, a2);
        BOOL result = (void *)(*(uint64_t (**)(void *))(v6[0] + 32))(v6);
      }
      else
      {
        (*(void (**)(void *, void *))(*result + 24))(result, a2);
        BOOL result = (void *)(*(uint64_t (**)(void))(*(void *)v3[3] + 32))(v3[3]);
        double v3[3] = a2[3];
      }
      a2[3] = a2;
    }
    else if (v5 == a2)
    {
      (*(void (**)(void *, void *))(*a2 + 24))(a2, result);
      BOOL result = (void *)(*(uint64_t (**)(void))(*(void *)a2[3] + 32))(a2[3]);
      a2[3] = v3[3];
      double v3[3] = v3;
    }
    else
    {
      result[3] = v5;
      a2[3] = v4;
    }
  }
  return result;
}

void sub_1005E5020(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_10006A6AC(a1);
}

void sub_1005E502C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  sub_100058DB0(&__p, "/cc/props/first_unlock_since_boot");
  uint64_t v8 = *a4;
  uint64_t v7 = a4[1];
  long long v9 = operator new(0x28uLL);
  void *v9 = off_1019ED180;
  v9[1] = a1;
  v9[2] = a3;
  v9[3] = v8;
  void v9[4] = v7;
  void v12[3] = v9;
  ctu::RestModule::observeProperty();
  sub_10003F600(v12);
  if (v11 < 0) {
    operator delete(__p);
  }
}

void sub_1005E5108(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_1005E5140()
{
}

__n128 sub_1005E5154(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_1019ED180;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_1005E51A8(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_1019ED180;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_1005E51E0(void *a1, xpc *this, BOOL a3)
{
  uint64_t v4 = (unsigned char *)a1[1];
  unsigned char *v4 = xpc::dyn_cast_or_default(this, 0, a3);
  long long v5 = (uint64_t (*)(void *))a1[3];
  uint64_t v6 = a1[4];
  uint64_t v7 = (void *)(a1[2] + (v6 >> 1));
  if (v6) {
    long long v5 = *(uint64_t (**)(void *))(*v7 + v5);
  }

  return v5(v7);
}

uint64_t sub_1005E5268(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1005E52A8()
{
}

uint64_t *sub_1005E52B4(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v7 = a1;
  uint64_t v8 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v17 = &off_101A1A658;
  long long v18 = 0u;
  long long v19 = 0u;
  long long v20 = 0u;
  long long v21 = 0u;
  long long v22 = 0u;
  long long v23 = 0u;
  long long v24 = 0u;
  long long v25 = 0u;
  sub_100918B88((uint64_t)&v17);
  uint64_t v3 = v24;
  sub_1005E5534(v24);
  std::string::operator=(*(std::string **)(v3 + 8), (const std::string *)(v1 + 96));
  if (*(char *)(v1 + 31) < 0)
  {
    sub_10004FC84(__dst, *(void **)(v1 + 8), *(void *)(v1 + 16));
  }
  else
  {
    long long v4 = *(_OWORD *)(v1 + 8);
    uint64_t v10 = *(void *)(v1 + 24);
    *(_OWORD *)long long __dst = v4;
  }
  if (*(char *)(v1 + 55) < 0)
  {
    sub_10004FC84(&__p, *(void **)(v1 + 32), *(void *)(v1 + 40));
  }
  else
  {
    long long v5 = *(_OWORD *)(v1 + 32);
    uint64_t v12 = *(void *)(v1 + 48);
    long long __p = v5;
  }
  __int16 v13 = *(_WORD *)(v1 + 56);
  sub_10002FD9C(&v14, (const void **)(v1 + 64));
  sub_100119B5C(&v15, (const void **)(v1 + 72));
  v16[0] = *(void *)(v1 + 80);
  *(void *)((char *)v16 + 6) = *(void *)(v1 + 86);
  sub_1005D66F8(v2, (uint64_t)__dst, (uint64_t)&v17);
  sub_1000FE824(&v15);
  sub_100030068(&v14);
  if (SHIBYTE(v12) < 0) {
    operator delete((void *)__p);
  }
  if (SHIBYTE(v10) < 0) {
    operator delete(__dst[0]);
  }
  sub_100917304((PB::Base *)&v17);
  sub_1005E54AC(&v8);
  return sub_100046B58((uint64_t *)&v7);
}

void sub_1005E5448(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,char a28)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  sub_100917304((PB::Base *)&a28);
  sub_1005E54AC(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_1005E54AC(uint64_t *result)
{
  uint64_t v1 = *result;
  void *result = 0;
  if (v1)
  {
    if (*(char *)(v1 + 119) < 0) {
      operator delete(*(void **)(v1 + 96));
    }
    sub_1000FE824((const void **)(v1 + 72));
    sub_100030068((const void **)(v1 + 64));
    if (*(char *)(v1 + 55) < 0) {
      operator delete(*(void **)(v1 + 32));
    }
    if (*(char *)(v1 + 31) < 0) {
      operator delete(*(void **)(v1 + 8));
    }
    operator delete();
  }
  return result;
}

uint64_t sub_1005E5534(uint64_t result)
{
  if (!*(void *)(result + 8)) {
    operator new();
  }
  return result;
}

uint64_t *sub_1005E55A8(uint64_t *a1)
{
  uint64_t v1 = *a1;
  long long v9 = a1;
  uint64_t v10 = v1;
  uint64_t v2 = *(void *)v1;
  long long v29 = 0u;
  long long v30 = 0u;
  long long v28 = 0u;
  if (*(char *)(v1 + 31) < 0)
  {
    sub_10004FC84(&v29, *(void **)(v1 + 8), *(void *)(v1 + 16));
  }
  else
  {
    long long v3 = *(_OWORD *)(v1 + 8);
    *(void *)&long long v30 = *(void *)(v1 + 24);
    long long v29 = v3;
  }
  BYTE8(v30) = 1;
  char v4 = (*(uint64_t (**)(void, uint64_t, uint64_t, long long *, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t *, uint64_t))(**(void **)(v1 + 32) + 48))(*(void *)(v1 + 32), v1 + 48, v1 + 72, &v28, v1 + 88, v1 + 104, v1 + 128, v1 + 152, v9, v10);
  long long v19 = &off_101A1A658;
  long long v20 = 0u;
  long long v21 = 0u;
  long long v22 = 0u;
  long long v23 = 0u;
  long long v24 = 0u;
  long long v25 = 0u;
  long long v26 = 0u;
  long long v27 = 0u;
  sub_100918B88((uint64_t)&v19);
  uint64_t v5 = v26;
  sub_1005E5534(v26);
  std::string::operator=(*(std::string **)(v5 + 8), (const std::string *)(v1 + 8));
  uint64_t v6 = *(std::string **)(v26 + 16);
  if (!v6) {
    operator new();
  }
  std::string::operator=(v6, (const std::string *)(v1 + 48));
  if ((v4 & 1) == 0)
  {
    uint64_t v7 = v26;
    *(unsigned char *)(v26 + 28) |= 1u;
    *(_DWORD *)(v7 + 24) = 3;
  }
  if (*(char *)(v1 + 199) < 0)
  {
    sub_10004FC84(__dst, *(void **)(v1 + 176), *(void *)(v1 + 184));
  }
  else
  {
    *(_OWORD *)long long __dst = *(_OWORD *)(v1 + 176);
    uint64_t v12 = *(void *)(v1 + 192);
  }
  if (*(char *)(v1 + 223) < 0)
  {
    sub_10004FC84(&__p, *(void **)(v1 + 200), *(void *)(v1 + 208));
  }
  else
  {
    long long __p = *(_OWORD *)(v1 + 200);
    uint64_t v14 = *(void *)(v1 + 216);
  }
  __int16 v15 = *(_WORD *)(v1 + 224);
  sub_10002FD9C(&v16, (const void **)(v1 + 232));
  sub_100119B5C(&v17, (const void **)(v1 + 240));
  v18[0] = *(void *)(v1 + 248);
  *(void *)((char *)v18 + 6) = *(void *)(v1 + 254);
  sub_1005D66F8(v2, (uint64_t)__dst, (uint64_t)&v19);
  sub_1000FE824(&v17);
  sub_100030068(&v16);
  if (SHIBYTE(v14) < 0) {
    operator delete((void *)__p);
  }
  if (SHIBYTE(v12) < 0) {
    operator delete(__dst[0]);
  }
  sub_100917304((PB::Base *)&v19);
  if (SBYTE7(v30) < 0) {
    operator delete((void *)v29);
  }
  sub_1005E5900(&v10);
  return sub_100046B58((uint64_t *)&v9);
}

void sub_1005E587C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,char a28)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  sub_100917304((PB::Base *)&a28);
  if (*(char *)(v28 - 89) < 0) {
    operator delete(*(void **)(v28 - 112));
  }
  sub_1005E5900(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_1005E5900(uint64_t *a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    sub_1005DFAE8(v2);
    operator delete();
  }
  return a1;
}

uint64_t *sub_1005E5948(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v10 = a1;
  uint64_t v11 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v3 = *(void *)(v1 + 8);
  if (*(char *)(v1 + 47) < 0)
  {
    sub_10004FC84(&__dst, *(void **)(v1 + 24), *(void *)(v1 + 32));
  }
  else
  {
    long long __dst = *(_OWORD *)(v1 + 24);
    uint64_t v37 = *(void *)(v1 + 40);
  }
  if (*(char *)(v1 + 71) < 0)
  {
    sub_10004FC84(&v34, *(void **)(v1 + 48), *(void *)(v1 + 56));
  }
  else
  {
    long long v34 = *(_OWORD *)(v1 + 48);
    uint64_t v35 = *(void *)(v1 + 64);
  }
  uint64_t v4 = *(void *)(v1 + 72);
  uint64_t v5 = *(void *)(v1 + 80);
  if (*(char *)(v1 + 111) < 0)
  {
    sub_10004FC84(&v32, *(void **)(v1 + 88), *(void *)(v1 + 96));
  }
  else
  {
    long long v32 = *(_OWORD *)(v1 + 88);
    uint64_t v33 = *(void *)(v1 + 104);
  }
  long long v29 = 0;
  long long v30 = 0;
  uint64_t v31 = 0;
  sub_10005C928(&v29, *(const void **)(v1 + 112), *(void *)(v1 + 120), *(void *)(v1 + 120) - *(void *)(v1 + 112));
  (*(void (**)(uint64_t, long long *, long long *, uint64_t, uint64_t, long long *, void **))(*(void *)v3 + 56))(v3, &__dst, &v34, v4, v5, &v32, &v29);
  if (v29)
  {
    long long v30 = v29;
    operator delete(v29);
  }
  if (SHIBYTE(v33) < 0) {
    operator delete((void *)v32);
  }
  if (SHIBYTE(v35) < 0) {
    operator delete((void *)v34);
  }
  if (SHIBYTE(v37) < 0) {
    operator delete((void *)__dst);
  }
  long long v20 = &off_101A1A658;
  long long v21 = 0u;
  long long v22 = 0u;
  long long v23 = 0u;
  long long v24 = 0u;
  long long v25 = 0u;
  long long v26 = 0u;
  long long v27 = 0u;
  long long v28 = 0u;
  sub_100918F04((uint64_t)&v20);
  uint64_t v6 = *((void *)&v24 + 1);
  sub_1005E495C(*((uint64_t *)&v24 + 1));
  std::string::operator=(*(std::string **)(v6 + 40), (const std::string *)(v1 + 24));
  uint64_t v7 = *((void *)&v24 + 1);
  sub_1005E5534(*((uint64_t *)&v24 + 1));
  std::string::operator=(*(std::string **)(v7 + 8), (const std::string *)(v1 + 48));
  uint64_t v8 = *((void *)&v24 + 1);
  sub_1005E49D0(*((uint64_t *)&v24 + 1));
  std::string::operator=(*(std::string **)(v8 + 32), (const std::string *)(v1 + 88));
  if (*(char *)(v1 + 159) < 0)
  {
    sub_10004FC84(v12, *(void **)(v1 + 136), *(void *)(v1 + 144));
  }
  else
  {
    *(_OWORD *)uint64_t v12 = *(_OWORD *)(v1 + 136);
    uint64_t v13 = *(void *)(v1 + 152);
  }
  if (*(char *)(v1 + 183) < 0)
  {
    sub_10004FC84(&__p, *(void **)(v1 + 160), *(void *)(v1 + 168));
  }
  else
  {
    long long __p = *(_OWORD *)(v1 + 160);
    uint64_t v15 = *(void *)(v1 + 176);
  }
  __int16 v16 = *(_WORD *)(v1 + 184);
  sub_10002FD9C(&v17, (const void **)(v1 + 192));
  sub_100119B5C(&v18, (const void **)(v1 + 200));
  v19[0] = *(void *)(v1 + 208);
  *(void *)((char *)v19 + 6) = *(void *)(v1 + 214);
  sub_1005D66F8(v2, (uint64_t)v12, (uint64_t)&v20);
  sub_1000FE824(&v18);
  sub_100030068(&v17);
  if (SHIBYTE(v15) < 0) {
    operator delete((void *)__p);
  }
  if (SHIBYTE(v13) < 0) {
    operator delete(v12[0]);
  }
  sub_100917304((PB::Base *)&v20);
  sub_1005E5D0C(&v11);
  return sub_100046B58((uint64_t *)&v10);
}

void sub_1005E5C40(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  sub_100917304((PB::Base *)&a29);
  sub_1005E5D0C(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_1005E5D0C(uint64_t *a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    sub_1005DFE00(v2);
    operator delete();
  }
  return a1;
}

uint64_t sub_1005E5D54(uint64_t *a1, void *a2)
{
  uint64_t result = sub_1005E5DCC((uint64_t)(a1 + 2), a1[1], (void *)a1[1], *a1, (void *)*a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t sub_1005E5DCC(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, void *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&long long v15 = a6;
  *((void *)&v15 + 1) = a7;
  long long v14 = v15;
  v13[0] = a1;
  v13[1] = &v14;
  void v13[2] = &v15;
  void v13[3] = 1;
  if (a3 == a5)
  {
    uint64_t v11 = a6;
  }
  else
  {
    uint64_t v8 = (void *)(a7 - 8);
    long long v9 = (void *)(a7 - 8);
    do
    {
      uint64_t v10 = *--a3;
      *a3 = 0;
      *v9-- = v10;
      *((void *)&v15 + 1) = v8;
      v7 -= 8;
      uint64_t v8 = v9;
    }
    while (a3 != a5);
    uint64_t v11 = v15;
  }
  sub_1005E5E60((uint64_t)v13);
  return v11;
}

uint64_t sub_1005E5E60(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    sub_100466070((void *)a1);
  }
  return a1;
}

uint64_t sub_1005E5E98(uint64_t a1)
{
  *(void *)a1 = off_1019ED200;
  sub_1000FE824((const void **)(a1 + 112));
  sub_100030068((const void **)(a1 + 104));
  if (*(char *)(a1 + 95) < 0) {
    operator delete(*(void **)(a1 + 72));
  }
  if (*(char *)(a1 + 71) < 0) {
    operator delete(*(void **)(a1 + 48));
  }
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 24);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_1005E5F10(uint64_t a1)
{
  *(void *)a1 = off_1019ED200;
  sub_1000FE824((const void **)(a1 + 112));
  sub_100030068((const void **)(a1 + 104));
  if (*(char *)(a1 + 95) < 0) {
    operator delete(*(void **)(a1 + 72));
  }
  if (*(char *)(a1 + 71) < 0) {
    operator delete(*(void **)(a1 + 48));
  }
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 24);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete();
}

void *sub_1005E5FA8(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t v2 = operator new(0x88uLL);
  void *v2 = off_1019ED200;
  sub_1005E64E4((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_1005E5FFC(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1005E6010(uint64_t a1, void *a2)
{
  *a2 = off_1019ED200;
  return sub_1005E64E4((uint64_t)(a2 + 1), a1 + 8);
}

void sub_1005E603C(uint64_t a1)
{
}

void sub_1005E6044(void *a1)
{
  sub_1005E65F8((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_1005E6080(uint64_t a1, uint64_t *a2)
{
  long long v7 = *(_OWORD *)(a1 + 8);
  uint64_t v4 = *(void *)(a1 + 24);
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 16), 1uLL, memory_order_relaxed);
  }
  if (*(char *)(a1 + 71) < 0)
  {
    sub_10004FC84(v8, *(void **)(a1 + 48), *(void *)(a1 + 56));
  }
  else
  {
    *(_OWORD *)uint64_t v8 = *(_OWORD *)(a1 + 48);
    void v8[2] = *(void **)(a1 + 64);
  }
  if (*(char *)(a1 + 95) < 0)
  {
    sub_10004FC84(__p, *(void **)(a1 + 72), *(void *)(a1 + 80));
  }
  else
  {
    *(_OWORD *)long long __p = *(_OWORD *)(a1 + 72);
    std::string __p[2] = *(void **)(a1 + 88);
  }
  __int16 v10 = *(_WORD *)(a1 + 96);
  sub_10002FD9C(&v11, (const void **)(a1 + 104));
  sub_100119B5C(&v12, (const void **)(a1 + 112));
  uint64_t v5 = *(void *)(a1 + 126);
  v13[0] = *(void *)(a1 + 120);
  *(void *)((char *)v13 + 6) = v5;
  memset(v14, 0, 24);
  sub_1005E6A50(v14, *a2, a2[1], 0xAAAAAAAAAAAAAAABLL * ((a2[1] - *a2) >> 6));
  uint64_t v6 = *(std::__shared_weak_count **)(v7 + 16);
  if (v6)
  {
    if (std::__shared_weak_count::lock(v6)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_1005E63C8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, std::__shared_weak_count *a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25,void *a26,uint64_t a27,int a28,__int16 a29,char a30,char a31)
{
  if (a2)
  {
    if (*(char *)(v31 + 63) < 0) {
      operator delete(*v32);
    }
    long long v34 = *(std::__shared_weak_count **)(v31 + 16);
    if (v34) {
      std::__shared_weak_count::__release_weak(v34);
    }
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1005E6498(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1005E64D8()
{
}

uint64_t sub_1005E64E4(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = *(_OWORD *)a2;
  uint64_t v4 = *(void *)(a2 + 16);
  *(void *)(a1 + 16) = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 16), 1uLL, memory_order_relaxed);
  }
  *(_OWORD *)(a1 + 24) = *(_OWORD *)(a2 + 24);
  if (*(char *)(a2 + 63) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 40), *(void **)(a2 + 40), *(void *)(a2 + 48));
  }
  else
  {
    long long v5 = *(_OWORD *)(a2 + 40);
    *(void *)(a1 + 56) = *(void *)(a2 + 56);
    *(_OWORD *)(a1 + 40) = v5;
  }
  uint64_t v6 = (unsigned char *)(a1 + 64);
  if (*(char *)(a2 + 87) < 0)
  {
    sub_10004FC84(v6, *(void **)(a2 + 64), *(void *)(a2 + 72));
  }
  else
  {
    long long v7 = *(_OWORD *)(a2 + 64);
    *(void *)(a1 + 80) = *(void *)(a2 + 80);
    *(_OWORD *)uint64_t v6 = v7;
  }
  *(_WORD *)(a1 + 88) = *(_WORD *)(a2 + 88);
  sub_10002FD9C((const void **)(a1 + 96), (const void **)(a2 + 96));
  sub_100119B5C((const void **)(a1 + 104), (const void **)(a2 + 104));
  uint64_t v8 = *(void *)(a2 + 112);
  *(void *)(a1 + 118) = *(void *)(a2 + 118);
  *(void *)(a1 + 112) = v8;
  return a1;
}

void sub_1005E65C8(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 63) < 0) {
    operator delete(*v2);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(v1 + 16);
  if (v4) {
    std::__shared_weak_count::__release_weak(v4);
  }
  _Unwind_Resume(exception_object);
}

void sub_1005E65F8(uint64_t a1)
{
  sub_1000FE824((const void **)(a1 + 104));
  sub_100030068((const void **)(a1 + 96));
  if (*(char *)(a1 + 87) < 0) {
    operator delete(*(void **)(a1 + 64));
  }
  if (*(char *)(a1 + 63) < 0) {
    operator delete(*(void **)(a1 + 40));
  }
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2)
  {
    std::__shared_weak_count::__release_weak(v2);
  }
}

uint64_t *sub_1005E666C(uint64_t *a1)
{
  uint64_t v1 = *a1;
  __int16 v10 = a1;
  uint64_t v11 = v1;
  uint64_t v2 = *(std::__shared_weak_count **)(v1 + 16);
  if (v2)
  {
    uint64_t v3 = *(void *)v1;
    uint64_t v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      long long v5 = v4;
      if (*(void *)(v1 + 8))
      {
        long long v18 = &off_101A1A658;
        long long v19 = 0u;
        long long v20 = 0u;
        long long v21 = 0u;
        long long v22 = 0u;
        long long v23 = 0u;
        long long v24 = 0u;
        long long v25 = 0u;
        long long v26 = 0u;
        sub_100918C38((uint64_t)&v18);
        uint64_t v6 = *(PB::Data **)(v26 + 8);
        if (!v6) {
          operator new();
        }
        PB::Data::assign(v6, (const unsigned __int8 *)(v1 + 24), (const unsigned __int8 *)(v1 + 40));
        long long v7 = *(std::string **)(v1 + 128);
        if (v7 != *(std::string **)(v1 + 136))
        {
          long long v17 = 0uLL;
          __int16 v16 = 0;
          *(void *)std::string buf = &off_1019ED3A0;
          *(_OWORD *)&uint8_t buf[8] = 0u;
          long long __p = 0u;
          long long v14 = 0u;
          long long v15 = 0;
          sub_100879964(v7, (uint64_t)buf);
          sub_1005E3C88();
        }
        uint64_t v8 = *(NSObject **)(v3 + 40);
        if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)std::string buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I [UpdateSubscriptionInfoRsp]", buf, 2u);
        }
        if (*(char *)(v1 + 63) < 0)
        {
          sub_10004FC84(buf, *(void **)(v1 + 40), *(void *)(v1 + 48));
        }
        else
        {
          *(_OWORD *)std::string buf = *(_OWORD *)(v1 + 40);
          *(void *)&uint8_t buf[16] = *(void *)(v1 + 56);
        }
        if (*(char *)(v1 + 87) < 0)
        {
          sub_10004FC84(&__p, *(void **)(v1 + 64), *(void *)(v1 + 72));
        }
        else
        {
          long long __p = *(_OWORD *)(v1 + 64);
          *(void *)&long long v14 = *(void *)(v1 + 80);
        }
        WORD4(v14) = *(_WORD *)(v1 + 88);
        sub_10002FD9C(&v15, (const void **)(v1 + 96));
        sub_100119B5C(&v16, (const void **)(v1 + 104));
        *(void *)&long long v17 = *(void *)(v1 + 112);
        *(void *)((char *)&v17 + 6) = *(void *)(v1 + 118);
        sub_1005D66F8(v3, (uint64_t)buf, (uint64_t)&v18);
        sub_1000FE824(&v16);
        sub_100030068(&v15);
        if (SBYTE7(v14) < 0) {
          operator delete((void *)__p);
        }
        if ((buf[23] & 0x80000000) != 0) {
          operator delete(*(void **)buf);
        }
        sub_100917304((PB::Base *)&v18);
      }
      sub_10004D2C8(v5);
    }
  }
  sub_1005E69B4(&v11);
  return sub_100046B58((uint64_t *)&v10);
}

void sub_1005E6938(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,char a28)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  sub_100917304((PB::Base *)&a28);
  sub_10004D2C8(v28);
  sub_1005E69B4(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_1005E69B4(uint64_t *result)
{
  uint64_t v1 = *result;
  void *result = 0;
  if (v1)
  {
    uint64_t v3 = (void **)(v1 + 128);
    sub_10023FDC8(&v3);
    sub_1000FE824((const void **)(v1 + 104));
    sub_100030068((const void **)(v1 + 96));
    if (*(char *)(v1 + 87) < 0) {
      operator delete(*(void **)(v1 + 64));
    }
    if (*(char *)(v1 + 63) < 0) {
      operator delete(*(void **)(v1 + 40));
    }
    uint64_t v2 = *(std::__shared_weak_count **)(v1 + 16);
    if (v2) {
      std::__shared_weak_count::__release_weak(v2);
    }
    operator delete();
  }
  return result;
}

void *sub_1005E6A50(void *result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    uint64_t v6 = result;
    sub_10033FF88(result, a4);
    uint64_t result = (void *)sub_1005E6AD8((uint64_t)(v6 + 2), a2, a3, v6[1]);
    v6[1] = result;
  }
  return result;
}

void sub_1005E6AB8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  *(void *)(v9 + 8) = v10;
  sub_10023FDC8(&a9);
  _Unwind_Resume(a1);
}

uint64_t sub_1005E6AD8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a2 != a3)
  {
    uint64_t v7 = 0;
    do
    {
      sub_10023FB90(a4 + v7, a2 + v7);
      v7 += 192;
    }
    while (a2 + v7 != a3);
    a4 += v7;
  }
  return a4;
}

void sub_1005E6B38(_Unwind_Exception *exception_object)
{
  if (v2)
  {
    uint64_t v4 = v1 - 192;
    do
    {
      sub_1000C62D8(v4 + v2);
      v2 -= 192;
    }
    while (v2);
  }
  _Unwind_Resume(exception_object);
}

void *sub_1005E6B5C(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t sub_1005E6BE0(uint64_t a1)
{
  *(void *)a1 = off_1019ED290;
  sub_1000FE824((const void **)(a1 + 96));
  sub_100030068((const void **)(a1 + 88));
  if (*(char *)(a1 + 79) < 0) {
    operator delete(*(void **)(a1 + 56));
  }
  if (*(char *)(a1 + 55) < 0) {
    operator delete(*(void **)(a1 + 32));
  }
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_1005E6C58(uint64_t a1)
{
  *(void *)a1 = off_1019ED290;
  sub_1000FE824((const void **)(a1 + 96));
  sub_100030068((const void **)(a1 + 88));
  if (*(char *)(a1 + 79) < 0) {
    operator delete(*(void **)(a1 + 56));
  }
  if (*(char *)(a1 + 55) < 0) {
    operator delete(*(void **)(a1 + 32));
  }
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete();
}

void *sub_1005E6CF0(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t v2 = operator new(0x88uLL);
  void *v2 = off_1019ED290;
  sub_1005E736C((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_1005E6D44(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1005E6D58(uint64_t a1, void *a2)
{
  *a2 = off_1019ED290;
  return sub_1005E736C((uint64_t)(a2 + 1), a1 + 8);
}

void sub_1005E6D84(uint64_t a1)
{
}

void sub_1005E6D8C(void *a1)
{
  sub_1005E7480((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_1005E6DC8(uint64_t a1, unsigned __int8 *a2)
{
  uint64_t v18 = 0;
  *(_OWORD *)__int16 v16 = 0u;
  long long v17 = 0u;
  long long v14 = 0u;
  *(_OWORD *)long long v15 = 0u;
  *(_OWORD *)uint64_t v12 = 0u;
  *(_OWORD *)uint64_t v13 = 0u;
  *(_OWORD *)uint64_t v10 = 0u;
  long long v11 = 0u;
  *(_OWORD *)uint64_t v8 = 0u;
  long long v9 = 0u;
  long long v6 = 0u;
  *(_OWORD *)uint64_t v7 = 0u;
  sub_10037E570((unsigned __int8 *)&v6, a2);
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 16);
  uint64_t v4 = *(void *)(a1 + 24);
  v19[0] = *(std::__shared_weak_count **)(a1 + 8);
  v19[1] = v3;
  if (v3) {
    atomic_fetch_add_explicit(&v3->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v20 = v4;
  if (*(char *)(a1 + 55) < 0)
  {
    sub_10004FC84(v21, *(void **)(a1 + 32), *(void *)(a1 + 40));
  }
  else
  {
    *(_OWORD *)long long v21 = *(_OWORD *)(a1 + 32);
    void v21[2] = *(void **)(a1 + 48);
  }
  if (*(char *)(a1 + 79) < 0)
  {
    sub_10004FC84(v22, *(void **)(a1 + 56), *(void *)(a1 + 64));
  }
  else
  {
    *(_OWORD *)long long v22 = *(_OWORD *)(a1 + 56);
    void v22[2] = *(void **)(a1 + 72);
  }
  __int16 v23 = *(_WORD *)(a1 + 80);
  sub_10002FD9C(&v24, (const void **)(a1 + 88));
  sub_100119B5C(&v25, (const void **)(a1 + 96));
  v26[0] = *(void *)(a1 + 104);
  *(void *)((char *)v26 + 6) = *(void *)(a1 + 110);
  long long v27 = *(_OWORD *)(a1 + 120);
  sub_10037E3E8((uint64_t)v28, (unsigned __int8 *)&v6);
  long long v5 = *(std::__shared_weak_count **)(v4 + 16);
  if (v5)
  {
    if (std::__shared_weak_count::lock(v5)) {
      operator new();
    }
  }
  sub_100088B9C();
}

void sub_1005E7200(_Unwind_Exception *a1, int a2)
{
  if (a2)
  {
    if (*(char *)(v2 + 47) < 0) {
      operator delete(*v3);
    }
    long long v5 = *(std::__shared_weak_count **)(v2 + 8);
    if (v5) {
      std::__shared_weak_count::__release_weak(v5);
    }
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_1005E7320(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1005E7360()
{
}

uint64_t sub_1005E736C(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 8);
  *(void *)a1 = *(void *)a2;
  *(void *)(a1 + 8) = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 16), 1uLL, memory_order_relaxed);
  }
  *(void *)(a1 + 16) = *(void *)(a2 + 16);
  if (*(char *)(a2 + 47) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 24), *(void **)(a2 + 24), *(void *)(a2 + 32));
  }
  else
  {
    long long v5 = *(_OWORD *)(a2 + 24);
    *(void *)(a1 + 40) = *(void *)(a2 + 40);
    *(_OWORD *)(a1 + 24) = v5;
  }
  long long v6 = (unsigned char *)(a1 + 48);
  if (*(char *)(a2 + 71) < 0)
  {
    sub_10004FC84(v6, *(void **)(a2 + 48), *(void *)(a2 + 56));
  }
  else
  {
    long long v7 = *(_OWORD *)(a2 + 48);
    *(void *)(a1 + 64) = *(void *)(a2 + 64);
    *(_OWORD *)long long v6 = v7;
  }
  *(_WORD *)(a1 + 72) = *(_WORD *)(a2 + 72);
  sub_10002FD9C((const void **)(a1 + 80), (const void **)(a2 + 80));
  sub_100119B5C((const void **)(a1 + 88), (const void **)(a2 + 88));
  uint64_t v8 = *(void *)(a2 + 96);
  *(void *)(a1 + 102) = *(void *)(a2 + 102);
  *(void *)(a1 + 96) = v8;
  *(_OWORD *)(a1 + 112) = *(_OWORD *)(a2 + 112);
  return a1;
}

void sub_1005E7450(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 47) < 0) {
    operator delete(*v2);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(v1 + 8);
  if (v4) {
    std::__shared_weak_count::__release_weak(v4);
  }
  _Unwind_Resume(exception_object);
}

void sub_1005E7480(uint64_t a1)
{
  sub_1000FE824((const void **)(a1 + 88));
  sub_100030068((const void **)(a1 + 80));
  if (*(char *)(a1 + 71) < 0) {
    operator delete(*(void **)(a1 + 48));
  }
  if (*(char *)(a1 + 47) < 0) {
    operator delete(*(void **)(a1 + 24));
  }
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 8);
  if (v2)
  {
    std::__shared_weak_count::__release_weak(v2);
  }
}

uint64_t *sub_1005E74F4(uint64_t *a1)
{
  uint64_t v1 = *a1;
  long long v19 = a1;
  uint64_t v20 = v1;
  uint64_t v2 = *(std::__shared_weak_count **)(v1 + 8);
  if (v2)
  {
    uint64_t v3 = *(void *)(v1 + 16);
    uint64_t v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      long long v5 = v4;
      if (!*(void *)v1)
      {
LABEL_24:
        sub_10004D2C8(v5);
        goto LABEL_25;
      }
      long long v29 = &off_101A1A658;
      long long v30 = 0u;
      long long v31 = 0u;
      long long v32 = 0u;
      long long v33 = 0u;
      long long v34 = 0u;
      long long v35 = 0u;
      long long v36 = 0u;
      long long v37 = 0u;
      sub_100918CF0((uint64_t)&v29);
      long long v6 = *(PB::Data **)(v33 + 8);
      if (!v6) {
        operator new();
      }
      long long v7 = (unsigned __int8 *)(v1 + 128);
      PB::Data::assign(v6, (const unsigned __int8 *)(v1 + 112), (const unsigned __int8 *)(v1 + 128));
      int v8 = *(unsigned __int8 *)(v1 + 128);
      uint64_t v9 = v33;
      *(unsigned char *)(v33 + 32) |= 2u;
      if (v8 == 2)
      {
        *(unsigned char *)(v9 + 28) = 0;
        int v10 = *v7;
        if (v10 == 2)
        {
          uint64_t v11 = v33;
          int v12 = *(unsigned __int8 *)(v1 + 136);
          *(unsigned char *)(v33 + 32) |= 1u;
          *(_DWORD *)(v11 + 24) = v12;
LABEL_11:
          long long v14 = *(NSObject **)(v3 + 40);
          if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)std::string buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#I [FetchSubscriptionInfoRsp]", buf, 2u);
          }
          if (*(char *)(v1 + 47) < 0)
          {
            sub_10004FC84(buf, *(void **)(v1 + 24), *(void *)(v1 + 32));
          }
          else
          {
            *(_OWORD *)std::string buf = *(_OWORD *)(v1 + 24);
            uint64_t v22 = *(void *)(v1 + 40);
          }
          if (*(char *)(v1 + 71) < 0)
          {
            sub_10004FC84(&__p, *(void **)(v1 + 48), *(void *)(v1 + 56));
          }
          else
          {
            long long __p = *(_OWORD *)(v1 + 48);
            uint64_t v24 = *(void *)(v1 + 64);
          }
          __int16 v25 = *(_WORD *)(v1 + 72);
          sub_10002FD9C(&v26, (const void **)(v1 + 80));
          sub_100119B5C(&v27, (const void **)(v1 + 88));
          v28[0] = *(void *)(v1 + 96);
          *(void *)((char *)v28 + 6) = *(void *)(v1 + 102);
          sub_1005D66F8(v3, (uint64_t)buf, (uint64_t)&v29);
          sub_1000FE824(&v27);
          sub_100030068(&v26);
          if (SHIBYTE(v24) < 0) {
            operator delete((void *)__p);
          }
          if (SHIBYTE(v22) < 0) {
            operator delete(*(void **)buf);
          }
          sub_100917304((PB::Base *)&v29);
          goto LABEL_24;
        }
        if (v10 == 1)
        {
          exception = (ctu::ResultIsNotError *)__cxa_allocate_exception(0x10uLL);
          long long v17 = &ctu::ResultIsNotError::~ResultIsNotError;
          ctu::ResultIsNotError::ResultIsNotError(exception);
          goto LABEL_31;
        }
      }
      else
      {
        *(unsigned char *)(v9 + 28) = 1;
        sub_1013F4F54(v33);
        int v13 = *v7;
        if (v13 == 1)
        {
          sub_100879964((std::string *)(v1 + 136), *(void *)(v33 + 16));
          goto LABEL_11;
        }
        if (v13 == 2)
        {
          exception = (ctu::ResultIsNotError *)__cxa_allocate_exception(0x10uLL);
          long long v17 = &ctu::ResultIsError::~ResultIsError;
          ctu::ResultIsError::ResultIsError(exception);
          goto LABEL_31;
        }
      }
      exception = (ctu::ResultIsNotError *)__cxa_allocate_exception(0x10uLL);
      long long v17 = &ctu::ResultIsEmptyError::~ResultIsEmptyError;
      ctu::ResultIsEmptyError::ResultIsEmptyError(exception);
LABEL_31:
      __cxa_throw(exception, v18, (void (*)(void *))v17);
    }
  }
LABEL_25:
  sub_1005E78EC(&v20);
  return sub_100046B58((uint64_t *)&v19);
}

void sub_1005E7860(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,char a28)
{
  __cxa_free_exception(v29);
  sub_100917304((PB::Base *)&a28);
  sub_10004D2C8(v28);
  sub_1005E78EC(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_1005E78EC(uint64_t *result)
{
  uint64_t v1 = *result;
  void *result = 0;
  if (v1)
  {
    if (*(unsigned char *)(v1 + 128) == 1) {
      sub_1000C62D8(v1 + 136);
    }
    *(unsigned char *)(v1 + 128) = 0;
    sub_1000FE824((const void **)(v1 + 88));
    sub_100030068((const void **)(v1 + 80));
    if (*(char *)(v1 + 71) < 0) {
      operator delete(*(void **)(v1 + 48));
    }
    if (*(char *)(v1 + 47) < 0) {
      operator delete(*(void **)(v1 + 24));
    }
    uint64_t v2 = *(std::__shared_weak_count **)(v1 + 8);
    if (v2) {
      std::__shared_weak_count::__release_weak(v2);
    }
    operator delete();
  }
  return result;
}

uint64_t sub_1005E7988(uint64_t *a1, void *a2)
{
  uint64_t result = sub_1005E7A00((uint64_t)(a1 + 2), a1[1], (void *)a1[1], *a1, (void *)*a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t sub_1005E7A00(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, void *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&long long v15 = a6;
  *((void *)&v15 + 1) = a7;
  long long v14 = v15;
  v13[0] = a1;
  v13[1] = &v14;
  void v13[2] = &v15;
  void v13[3] = 1;
  if (a3 == a5)
  {
    uint64_t v11 = a6;
  }
  else
  {
    uint64_t v8 = (void *)(a7 - 8);
    uint64_t v9 = (void *)(a7 - 8);
    do
    {
      uint64_t v10 = *--a3;
      *a3 = 0;
      *v9-- = v10;
      *((void *)&v15 + 1) = v8;
      v7 -= 8;
      uint64_t v8 = v9;
    }
    while (a3 != a5);
    uint64_t v11 = v15;
  }
  sub_1005E7A94((uint64_t)v13);
  return v11;
}

uint64_t sub_1005E7A94(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    sub_100466070((void *)a1);
  }
  return a1;
}

uint64_t sub_1005E7ACC(uint64_t a1)
{
  *(void *)a1 = off_1019ED310;
  sub_1000FE824((const void **)(a1 + 112));
  sub_100030068((const void **)(a1 + 104));
  if (*(char *)(a1 + 95) < 0) {
    operator delete(*(void **)(a1 + 72));
  }
  if (*(char *)(a1 + 71) < 0) {
    operator delete(*(void **)(a1 + 48));
  }
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 24);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_1005E7B44(uint64_t a1)
{
  *(void *)a1 = off_1019ED310;
  sub_1000FE824((const void **)(a1 + 112));
  sub_100030068((const void **)(a1 + 104));
  if (*(char *)(a1 + 95) < 0) {
    operator delete(*(void **)(a1 + 72));
  }
  if (*(char *)(a1 + 71) < 0) {
    operator delete(*(void **)(a1 + 48));
  }
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 24);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }

  operator delete();
}

void *sub_1005E7BDC(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t v2 = operator new(0x88uLL);
  void *v2 = off_1019ED310;
  sub_1005E8134((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_1005E7C30(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1005E7C44(uint64_t a1, void *a2)
{
  *a2 = off_1019ED310;
  return sub_1005E8134((uint64_t)(a2 + 1), a1 + 8);
}

void sub_1005E7C70(uint64_t a1)
{
}

void sub_1005E7C78(void *a1)
{
  sub_1005E65F8((uint64_t)a1 + 8);

  operator delete(a1);
}

void sub_1005E7CB4(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v4 = *(std::__shared_weak_count **)(v3 + 16);
  if (v4)
  {
    uint64_t v6 = std::__shared_weak_count::lock(v4);
    if (v6)
    {
      atomic_fetch_add_explicit(&v6->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v6);
      if (*(char *)(a1 + 71) < 0)
      {
        sub_10004FC84(v9, *(void **)(a1 + 48), *(void *)(a1 + 56));
      }
      else
      {
        *(_OWORD *)uint64_t v9 = *(_OWORD *)(a1 + 48);
        v9[2] = *(void **)(a1 + 64);
      }
      if (*(char *)(a1 + 95) < 0)
      {
        sub_10004FC84(__p, *(void **)(a1 + 72), *(void *)(a1 + 80));
      }
      else
      {
        *(_OWORD *)long long __p = *(_OWORD *)(a1 + 72);
        std::string __p[2] = *(void **)(a1 + 88);
      }
      __int16 v11 = *(_WORD *)(a1 + 96);
      sub_10002FD9C(&v12, (const void **)(a1 + 104));
      sub_100119B5C(&v13, (const void **)(a1 + 112));
      uint64_t v7 = *(void *)(a1 + 126);
      v14[0] = *(void *)(a1 + 120);
      *(void *)((char *)v14 + 6) = v7;
      memset(v15, 0, 24);
      sub_10030C19C(v15, *a2, a2[1], 0x6F96F96F96F96F97 * ((a2[1] - *a2) >> 3));
      uint64_t v8 = *(std::__shared_weak_count **)(v3 + 16);
      if (v8)
      {
        if (std::__shared_weak_count::lock(v8)) {
          operator new();
        }
      }
      sub_100088B9C();
    }
  }
  sub_100088B9C();
}

void sub_1005E8018(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, std::__shared_weak_count *a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23,void *a24,uint64_t a25,int a26,__int16 a27,char a28,char a29)
{
  if (a2)
  {
    if (*(char *)(v29 + 63) < 0) {
      operator delete(*v30);
    }
    long long v32 = *(std::__shared_weak_count **)(v29 + 16);
    if (v32) {
      std::__shared_weak_count::__release_weak(v32);
    }
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1005E80E8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

_UNKNOWN **sub_1005E8128()
{
}

uint64_t sub_1005E8134(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = *(_OWORD *)a2;
  uint64_t v4 = *(void *)(a2 + 16);
  *(void *)(a1 + 16) = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 16), 1uLL, memory_order_relaxed);
  }
  *(_OWORD *)(a1 + 24) = *(_OWORD *)(a2 + 24);
  if (*(char *)(a2 + 63) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 40), *(void **)(a2 + 40), *(void *)(a2 + 48));
  }
  else
  {
    long long v5 = *(_OWORD *)(a2 + 40);
    *(void *)(a1 + 56) = *(void *)(a2 + 56);
    *(_OWORD *)(a1 + 40) = v5;
  }
  uint64_t v6 = (unsigned char *)(a1 + 64);
  if (*(char *)(a2 + 87) < 0)
  {
    sub_10004FC84(v6, *(void **)(a2 + 64), *(void *)(a2 + 72));
  }
  else
  {
    long long v7 = *(_OWORD *)(a2 + 64);
    *(void *)(a1 + 80) = *(void *)(a2 + 80);
    *(_OWORD *)uint64_t v6 = v7;
  }
  *(_WORD *)(a1 + 88) = *(_WORD *)(a2 + 88);
  sub_10002FD9C((const void **)(a1 + 96), (const void **)(a2 + 96));
  sub_100119B5C((const void **)(a1 + 104), (const void **)(a2 + 104));
  uint64_t v8 = *(void *)(a2 + 112);
  *(void *)(a1 + 118) = *(void *)(a2 + 118);
  *(void *)(a1 + 112) = v8;
  return a1;
}

void sub_1005E8218(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 63) < 0) {
    operator delete(*v2);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(v1 + 16);
  if (v4) {
    std::__shared_weak_count::__release_weak(v4);
  }
  _Unwind_Resume(exception_object);
}

uint64_t *sub_1005E8248(uint64_t *a1)
{
  uint64_t v1 = *a1;
  __int16 v11 = a1;
  uint64_t v12 = v1;
  uint64_t v2 = *(std::__shared_weak_count **)(v1 + 16);
  if (v2)
  {
    uint64_t v3 = *(void *)v1;
    uint64_t v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      long long v5 = v4;
      if (*(void *)(v1 + 8))
      {
        uint64_t v6 = *(NSObject **)(v3 + 40);
        if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)std::string buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I [PendingProfilesRsp]", buf, 2u);
        }
        *(void *)std::string buf = &off_101A1A658;
        long long v21 = 0u;
        long long v22 = 0u;
        long long v23 = 0u;
        long long v24 = 0u;
        long long v25 = 0u;
        long long v26 = 0u;
        long long v27 = 0u;
        long long v28 = 0u;
        sub_100918DA0((uint64_t)buf);
        long long v7 = *(PB::Data **)(v25 + 8);
        if (!v7) {
          operator new();
        }
        PB::Data::assign(v7, (const unsigned __int8 *)(v1 + 24), (const unsigned __int8 *)(v1 + 40));
        uint64_t v8 = *(std::string **)(v1 + 128);
        if (v8 != *(std::string **)(v1 + 136))
        {
          *(void *)long long __dst = &off_101A2B478;
          *(_OWORD *)&__dst[8] = 0u;
          long long __p = 0u;
          sub_1008797E4(v8, (uint64_t)__dst);
          sub_1005E4178();
        }
        uint64_t v9 = v25;
        *(unsigned char *)(v25 + 48) |= 2u;
        *(unsigned char *)(v9 + 44) = 1;
        if (*(char *)(v1 + 63) < 0)
        {
          sub_10004FC84(__dst, *(void **)(v1 + 40), *(void *)(v1 + 48));
        }
        else
        {
          *(_OWORD *)long long __dst = *(_OWORD *)(v1 + 40);
          *(void *)&__dst[16] = *(void *)(v1 + 56);
        }
        if (*(char *)(v1 + 87) < 0)
        {
          sub_10004FC84(&__p, *(void **)(v1 + 64), *(void *)(v1 + 72));
        }
        else
        {
          long long __p = *(_OWORD *)(v1 + 64);
          uint64_t v15 = *(void *)(v1 + 80);
        }
        __int16 v16 = *(_WORD *)(v1 + 88);
        sub_10002FD9C(&v17, (const void **)(v1 + 96));
        sub_100119B5C(&v18, (const void **)(v1 + 104));
        v19[0] = *(void *)(v1 + 112);
        *(void *)((char *)v19 + 6) = *(void *)(v1 + 118);
        sub_1005D66F8(v3, (uint64_t)__dst, (uint64_t)buf);
        sub_1000FE824(&v18);
        sub_100030068(&v17);
        if (SHIBYTE(v15) < 0) {
          operator delete((void *)__p);
        }
        if ((__dst[23] & 0x80000000) != 0) {
          operator delete(*(void **)__dst);
        }
        sub_100917304((PB::Base *)buf);
      }
      sub_10004D2C8(v5);
    }
  }
  sub_1005E8590(&v12);
  return sub_100046B58((uint64_t *)&v11);
}

void sub_1005E8514(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  sub_100917304((PB::Base *)&a29);
  sub_10004D2C8(v29);
  sub_1005E8590(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_1005E8590(uint64_t *result)
{
  uint64_t v1 = *result;
  void *result = 0;
  if (v1)
  {
    uint64_t v3 = (void **)(v1 + 128);
    sub_1000C63B8(&v3);
    sub_1000FE824((const void **)(v1 + 104));
    sub_100030068((const void **)(v1 + 96));
    if (*(char *)(v1 + 87) < 0) {
      operator delete(*(void **)(v1 + 64));
    }
    if (*(char *)(v1 + 63) < 0) {
      operator delete(*(void **)(v1 + 40));
    }
    uint64_t v2 = *(std::__shared_weak_count **)(v1 + 16);
    if (v2) {
      std::__shared_weak_count::__release_weak(v2);
    }
    operator delete();
  }
  return result;
}

void *sub_1005E862C(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t *sub_1005E86B0(uint64_t *a1)
{
  uint64_t v1 = *a1;
  long long v5 = a1;
  uint64_t v6 = v1;
  uint64_t v2 = *(void *)v1;
  uint64_t v15 = &off_101A1A658;
  long long v16 = 0u;
  long long v17 = 0u;
  long long v18 = 0u;
  long long v19 = 0u;
  long long v20 = 0u;
  long long v21 = 0u;
  long long v22 = 0u;
  long long v23 = 0u;
  sub_100918E58((uint64_t)&v15);
  if (((*(uint64_t (**)(void, uint64_t))(**(void **)(v1 + 8) + 136))(*(void *)(v1 + 8), v1 + 24) & 1) == 0)
  {
    uint64_t v3 = *((void *)&v20 + 1);
    *(unsigned char *)(*((void *)&v20 + 1) + 12) |= 1u;
    *(_DWORD *)(v3 + 8) = 5;
  }
  if (*(char *)(v1 + 239) < 0)
  {
    sub_10004FC84(__dst, *(void **)(v1 + 216), *(void *)(v1 + 224));
  }
  else
  {
    *(_OWORD *)long long __dst = *(_OWORD *)(v1 + 216);
    uint64_t v8 = *(void *)(v1 + 232);
  }
  if (*(char *)(v1 + 263) < 0)
  {
    sub_10004FC84(&__p, *(void **)(v1 + 240), *(void *)(v1 + 248));
  }
  else
  {
    long long __p = *(_OWORD *)(v1 + 240);
    uint64_t v10 = *(void *)(v1 + 256);
  }
  __int16 v11 = *(_WORD *)(v1 + 264);
  sub_10002FD9C(&v12, (const void **)(v1 + 272));
  sub_100119B5C(&v13, (const void **)(v1 + 280));
  v14[0] = *(void *)(v1 + 288);
  *(void *)((char *)v14 + 6) = *(void *)(v1 + 294);
  sub_1005D66F8(v2, (uint64_t)__dst, (uint64_t)&v15);
  sub_1000FE824(&v13);
  sub_100030068(&v12);
  if (SHIBYTE(v10) < 0) {
    operator delete((void *)__p);
  }
  if (SHIBYTE(v8) < 0) {
    operator delete(__dst[0]);
  }
  sub_100917304((PB::Base *)&v15);
  sub_1005E88E0(&v6);
  return sub_100046B58((uint64_t *)&v5);
}

void sub_1005E8878(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,char a28)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  sub_100917304((PB::Base *)&a28);
  sub_1005E88E0(&a10);
  sub_100046B58(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_1005E88E0(uint64_t *result)
{
  uint64_t v1 = *result;
  void *result = 0;
  if (v1)
  {
    sub_1000FE824((const void **)(v1 + 280));
    sub_100030068((const void **)(v1 + 272));
    if (*(char *)(v1 + 263) < 0) {
      operator delete(*(void **)(v1 + 240));
    }
    if (*(char *)(v1 + 239) < 0) {
      operator delete(*(void **)(v1 + 216));
    }
    sub_10032A36C(v1 + 24);
    uint64_t v2 = *(std::__shared_weak_count **)(v1 + 16);
    if (v2) {
      sub_10004D2C8(v2);
    }
    operator delete();
  }
  return result;
}

uint64_t sub_1005E896C(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void **)(a1 + 8);
  if (v2)
  {
    uint64_t result = 1;
    do
    {
      uint64_t v4 = 0;
      do
      {
        unsigned int v5 = *(unsigned __int8 *)(a2 + v4);
        unsigned int v6 = *((unsigned __int8 *)v2 + v4 + 32);
      }
      while (v5 == v6 && v4++ != 15);
      if (v5 >= v6)
      {
        uint64_t v8 = 0;
        do
        {
          unsigned int v9 = *((unsigned __int8 *)v2 + v8 + 32);
          unsigned int v10 = *(unsigned __int8 *)(a2 + v8);
        }
        while (v9 == v10 && v8++ != 15);
        if (v9 >= v10) {
          return result;
        }
        ++v2;
      }
      uint64_t v2 = (void *)*v2;
    }
    while (v2);
  }
  return 0;
}

void sub_1005E8D7C(_Unwind_Exception *a1)
{
  if ((v4 & 1) == 0) {
    sub_10004D2C8(v2);
  }

  _Unwind_Resume(a1);
}

void sub_1005E917C(_Unwind_Exception *a1)
{
  if ((v4 & 1) == 0) {
    sub_10004D2C8(v2);
  }

  _Unwind_Resume(a1);
}

void sub_1005E944C(_Unwind_Exception *a1)
{
  if ((v4 & 1) == 0) {
    sub_10004D2C8(v2);
  }

  _Unwind_Resume(a1);
}

void sub_1005E94A4()
{
}

void sub_1005E94CC(PB::Base *this)
{
  *(void *)this = &off_1019ED3A0;
  uint64_t v4 = *((void *)this + 7);
  uint64_t v2 = (void *)((char *)this + 56);
  uint64_t v3 = v4;
  void *v2 = 0;
  if (v4) {
    sub_100206334((uint64_t)v2, v3);
  }
  uint64_t v5 = *((void *)this + 6);
  *((void *)this + 6) = 0;
  if (v5) {
    sub_100206334((uint64_t)this + 48, v5);
  }
  uint64_t v6 = *((void *)this + 5);
  *((void *)this + 5) = 0;
  if (v6) {
    sub_100206334((uint64_t)this + 40, v6);
  }
  uint64_t v7 = *((void *)this + 4);
  *((void *)this + 4) = 0;
  if (v7) {
    (*(void (**)(uint64_t))(*(void *)v7 + 8))(v7);
  }
  if (*((char *)this + 31) < 0) {
    operator delete(*((void **)this + 1));
  }

  PB::Base::~Base(this);
}

void sub_1005E9598(PB::Base *a1)
{
  sub_1005E94CC(a1);

  operator delete();
}

uint64_t sub_1005E95D0(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)(a1 + 40) = 0u;
  *(void *)a1 = &off_1019ED3A0;
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 72) = 0;
  *(_DWORD *)(a1 + 84) = 0;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 8) = 0u;
  std::string::operator=((std::string *)(a1 + 8), (const std::string *)(a2 + 8));
  *(void *)(a1 + 64) = *(void *)(a2 + 64);
  char v4 = *(unsigned char *)(a2 + 84);
  if (v4)
  {
    int v5 = *(_DWORD *)(a2 + 72);
    *(unsigned char *)(a1 + 84) |= 1u;
    *(_DWORD *)(a1 + 72) = v5;
    char v4 = *(unsigned char *)(a2 + 84);
  }
  if ((v4 & 2) != 0)
  {
    int v6 = *(_DWORD *)(a2 + 76);
    *(unsigned char *)(a1 + 84) |= 2u;
    *(_DWORD *)(a1 + 76) = v6;
  }
  if (*(void *)(a2 + 48)) {
    operator new();
  }
  if (*(void *)(a2 + 56)) {
    operator new();
  }
  if (*(void *)(a2 + 32)) {
    operator new();
  }
  if ((*(unsigned char *)(a2 + 84) & 4) != 0)
  {
    char v7 = *(unsigned char *)(a2 + 80);
    *(unsigned char *)(a1 + 84) |= 4u;
    *(unsigned char *)(a1 + 80) = v7;
  }
  if (*(void *)(a2 + 40)) {
    operator new();
  }
  return a1;
}

uint64_t sub_1005E9838(uint64_t a1, PB::TextFormatter *this, char *a3)
{
  PB::TextFormatter::beginObject(this, a3);
  PB::TextFormatter::format();
  if ((*(unsigned char *)(a1 + 84) & 4) != 0) {
    PB::TextFormatter::format(this, "isPresentInResponse", *(unsigned char *)(a1 + 80));
  }
  uint64_t v5 = *(void *)(a1 + 32);
  if (v5) {
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(void *)v5 + 32))(v5, this, "manageAccountInfo");
  }
  if (*(void *)(a1 + 40)) {
    PB::TextFormatter::format();
  }
  if (*(void *)(a1 + 48)) {
    PB::TextFormatter::format();
  }
  if (*(void *)(a1 + 56)) {
    PB::TextFormatter::format();
  }
  if (*(unsigned char *)(a1 + 84)) {
    PB::TextFormatter::format(this, "status", *(_DWORD *)(a1 + 72));
  }
  PB::TextFormatter::format(this, "timestamp", *(double *)(a1 + 64));
  if ((*(unsigned char *)(a1 + 84) & 2) != 0) {
    PB::TextFormatter::format(this, "type", *(_DWORD *)(a1 + 76));
  }

  return PB::TextFormatter::endObject(this);
}

uint64_t sub_1005E9978(uint64_t a1, PB::Reader *this)
{
  unint64_t v3 = *((void *)this + 1);
  unint64_t v2 = *((void *)this + 2);
  int v4 = *((unsigned __int8 *)this + 24);
  if (v3 >= v2 || v4 != 0) {
    return v4 == 0;
  }
  while (1)
  {
    uint64_t v8 = *(void *)this;
    if (v3 <= 0xFFFFFFFFFFFFFFF5 && v3 + 10 <= v2) {
      break;
    }
    char v15 = 0;
    unsigned int v16 = 0;
    unint64_t v11 = 0;
    if (v3 <= v2) {
      unint64_t v17 = v2;
    }
    else {
      unint64_t v17 = v3;
    }
    do
    {
      if (v17 == v3)
      {
        int v4 = 1;
        *((unsigned char *)this + 24) = 1;
        return v4 == 0;
      }
      char v18 = *(unsigned char *)(v8 + v3);
      *((void *)this + 1) = v3 + 1;
      v11 |= (unint64_t)(v18 & 0x7F) << v15;
      if ((v18 & 0x80) == 0)
      {
        unint64_t v12 = v3 + 1;
        goto LABEL_24;
      }
      v15 += 7;
      ++v3;
      BOOL v14 = v16++ > 8;
    }
    while (!v14);
LABEL_20:
    unsigned __int8 v19 = 0;
    LODWORD(v20) = 0;
LABEL_21:
    uint64_t result = PB::Reader::skip(this, v20, v19, 0);
    if (!result) {
      return result;
    }
LABEL_50:
    unint64_t v3 = *((void *)this + 1);
    unint64_t v2 = *((void *)this + 2);
    int v4 = *((unsigned __int8 *)this + 24);
    if (v3 >= v2 || v4 != 0) {
      return v4 == 0;
    }
  }
  char v9 = 0;
  unsigned int v10 = 0;
  unint64_t v11 = 0;
  while (1)
  {
    unint64_t v12 = v3 + 1;
    *((void *)this + 1) = v3 + 1;
    char v13 = *(unsigned char *)(v8 + v3);
    v11 |= (unint64_t)(v13 & 0x7F) << v9;
    if ((v13 & 0x80) == 0) {
      break;
    }
    v9 += 7;
    unint64_t v3 = v12;
    BOOL v14 = v10++ > 8;
    if (v14) {
      goto LABEL_20;
    }
  }
LABEL_24:
  unsigned __int8 v19 = v11 & 7;
  if ((v11 & 7) != 4)
  {
    unint64_t v20 = v11 >> 3;
    switch((v11 >> 3))
    {
      case 1u:
        PB::Reader::read();
        goto LABEL_50;
      case 2u:
        if (v12 > 0xFFFFFFFFFFFFFFF7 || v12 + 8 > v2)
        {
          *((unsigned char *)this + 24) = 1;
        }
        else
        {
          *(void *)(a1 + 64) = *(void *)(v8 + v12);
          *((void *)this + 1) += 8;
        }
        goto LABEL_50;
      case 3u:
        *(unsigned char *)(a1 + 84) |= 1u;
        unint64_t v22 = *((void *)this + 1);
        unint64_t v23 = *((void *)this + 2);
        uint64_t v24 = *(void *)this;
        if (v22 <= 0xFFFFFFFFFFFFFFF5 && v22 + 10 <= v23)
        {
          char v25 = 0;
          unsigned int v26 = 0;
          uint64_t v27 = 0;
          do
          {
            unint64_t v28 = v22 + 1;
            *((void *)this + 1) = v22 + 1;
            char v29 = *(unsigned char *)(v24 + v22);
            v27 |= (unint64_t)(v29 & 0x7F) << v25;
            if ((v29 & 0x80) == 0) {
              goto LABEL_76;
            }
            v25 += 7;
            unint64_t v22 = v28;
            BOOL v14 = v26++ > 8;
          }
          while (!v14);
LABEL_62:
          LODWORD(v27) = 0;
          goto LABEL_76;
        }
        char v43 = 0;
        unsigned int v44 = 0;
        uint64_t v27 = 0;
        if (v23 <= v22) {
          unint64_t v23 = *((void *)this + 1);
        }
        while (2)
        {
          if (v23 == v22)
          {
            LODWORD(v27) = 0;
            *((unsigned char *)this + 24) = 1;
          }
          else
          {
            unint64_t v45 = v22 + 1;
            char v46 = *(unsigned char *)(v24 + v22);
            *((void *)this + 1) = v45;
            v27 |= (unint64_t)(v46 & 0x7F) << v43;
            if (v46 < 0)
            {
              v43 += 7;
              unint64_t v22 = v45;
              BOOL v14 = v44++ > 8;
              if (v14) {
                goto LABEL_62;
              }
              continue;
            }
            if (*((unsigned char *)this + 24)) {
              LODWORD(v27) = 0;
            }
          }
          break;
        }
LABEL_76:
        *(_DWORD *)(a1 + 72) = v27;
        goto LABEL_50;
      case 4u:
        *(unsigned char *)(a1 + 84) |= 2u;
        unint64_t v30 = *((void *)this + 1);
        unint64_t v31 = *((void *)this + 2);
        uint64_t v32 = *(void *)this;
        if (v30 <= 0xFFFFFFFFFFFFFFF5 && v30 + 10 <= v31)
        {
          char v33 = 0;
          unsigned int v34 = 0;
          uint64_t v35 = 0;
          do
          {
            unint64_t v36 = v30 + 1;
            *((void *)this + 1) = v30 + 1;
            char v37 = *(unsigned char *)(v32 + v30);
            v35 |= (unint64_t)(v37 & 0x7F) << v33;
            if ((v37 & 0x80) == 0) {
              goto LABEL_79;
            }
            v33 += 7;
            unint64_t v30 = v36;
            BOOL v14 = v34++ > 8;
          }
          while (!v14);
LABEL_69:
          LODWORD(v35) = 0;
          goto LABEL_79;
        }
        char v47 = 0;
        unsigned int v48 = 0;
        uint64_t v35 = 0;
        if (v31 <= v30) {
          unint64_t v31 = *((void *)this + 1);
        }
        break;
      case 5u:
        operator new();
      case 6u:
        operator new();
      case 7u:
        operator new();
      case 8u:
        *(unsigned char *)(a1 + 84) |= 4u;
        unint64_t v38 = *((void *)this + 1);
        if (v38 >= *((void *)this + 2))
        {
          BOOL v41 = 0;
          *((unsigned char *)this + 24) = 1;
        }
        else
        {
          unint64_t v39 = v38 + 1;
          int v40 = *(unsigned __int8 *)(*(void *)this + v38);
          *((void *)this + 1) = v39;
          BOOL v41 = v40 != 0;
        }
        *(unsigned char *)(a1 + 80) = v41;
        goto LABEL_50;
      case 9u:
        operator new();
      default:
        goto LABEL_21;
    }
    while (1)
    {
      if (v31 == v30)
      {
        LODWORD(v35) = 0;
        *((unsigned char *)this + 24) = 1;
        goto LABEL_79;
      }
      unint64_t v49 = v30 + 1;
      char v50 = *(unsigned char *)(v32 + v30);
      *((void *)this + 1) = v49;
      v35 |= (unint64_t)(v50 & 0x7F) << v47;
      if ((v50 & 0x80) == 0) {
        break;
      }
      v47 += 7;
      unint64_t v30 = v49;
      BOOL v14 = v48++ > 8;
      if (v14) {
        goto LABEL_69;
      }
    }
    if (*((unsigned char *)this + 24)) {
      LODWORD(v35) = 0;
    }
LABEL_79:
    *(_DWORD *)(a1 + 76) = v35;
    goto LABEL_50;
  }
  int v4 = 0;
  return v4 == 0;
}

uint64_t sub_1005E9F60(uint64_t a1, PB::Writer *a2)
{
  PB::Writer::write();
  uint64_t result = PB::Writer::write(a2, *(double *)(a1 + 64), 2u);
  char v5 = *(unsigned char *)(a1 + 84);
  if (v5)
  {
    uint64_t result = PB::Writer::writeVarInt(a2, *(_DWORD *)(a1 + 72), 3u);
    char v5 = *(unsigned char *)(a1 + 84);
  }
  if ((v5 & 2) != 0) {
    uint64_t result = PB::Writer::writeVarInt(a2, *(_DWORD *)(a1 + 76), 4u);
  }
  if (*(void *)(a1 + 48)) {
    uint64_t result = PB::Writer::write();
  }
  if (*(void *)(a1 + 56)) {
    uint64_t result = PB::Writer::write();
  }
  int v6 = *(const PB::Base **)(a1 + 32);
  if (v6) {
    uint64_t result = PB::Writer::writeSubmessage(a2, v6, 7u);
  }
  if ((*(unsigned char *)(a1 + 84) & 4) != 0) {
    uint64_t result = PB::Writer::write(a2, *(unsigned char *)(a1 + 80), 8u);
  }
  if (*(void *)(a1 + 40))
  {
    return PB::Writer::write();
  }
  return result;
}

uint64_t sub_1005EA054(uint64_t result)
{
  if (!*(void *)(result + 32)) {
    operator new();
  }
  return result;
}

void sub_1005EA108(uint64_t a1)
{
  *(void *)a1 = off_1019ED3F0;
  uint64_t v4 = *(void *)(a1 + 56);
  unint64_t v2 = (void *)(a1 + 56);
  uint64_t v3 = v4;
  void *v2 = 0;
  if (v4) {
    sub_100206334((uint64_t)v2, v3);
  }
  uint64_t v5 = *(void *)(a1 + 48);
  *(void *)(a1 + 48) = 0;
  if (v5) {
    sub_100206334(a1 + 48, v5);
  }
  uint64_t v6 = *(void *)(a1 + 40);
  *(void *)(a1 + 40) = 0;
  if (v6) {
    sub_100206334(a1 + 40, v6);
  }
  char v7 = (void **)(a1 + 16);
  sub_100465E6C(&v7);
  sub_100110A40((void ***)(a1 + 8), 0);
  PB::Base::~Base((PB::Base *)a1);
}

void sub_1005EA1AC(uint64_t a1)
{
  sub_1005EA108(a1);

  operator delete();
}

uint64_t sub_1005EA1E4(uint64_t result, uint64_t a2)
{
  *(void *)uint64_t result = off_1019ED3F0;
  *(_OWORD *)(result + 8) = 0u;
  *(_OWORD *)(result + 40) = 0u;
  *(void *)(result + 56) = 0;
  *(_DWORD *)(result + 88) = 0;
  *(_OWORD *)(result + 24) = 0u;
  char v2 = *(unsigned char *)(a2 + 88);
  if ((v2 & 8) != 0)
  {
    int v4 = *(_DWORD *)(a2 + 76);
    *(unsigned char *)(result + 88) = 8;
    *(_DWORD *)(result + 76) = v4;
    char v2 = *(unsigned char *)(a2 + 88);
    char v3 = 40;
  }
  else
  {
    char v3 = 32;
  }
  if ((v2 & 0x20) != 0)
  {
    char v5 = *(unsigned char *)(a2 + 84);
    *(unsigned char *)(result + 88) = v3;
    *(unsigned char *)(result + 84) = v5;
  }
  if (*(void *)(a2 + 16) != *(void *)(a2 + 24)) {
    operator new();
  }
  if ((*(unsigned char *)(a2 + 88) & 2) != 0)
  {
    int v6 = *(_DWORD *)(a2 + 68);
    *(unsigned char *)(result + 88) |= 2u;
    *(_DWORD *)(result + 68) = v6;
  }
  if (*(void *)(a2 + 8)) {
    operator new();
  }
  if ((*(unsigned char *)(a2 + 88) & 0x10) != 0)
  {
    int v7 = *(_DWORD *)(a2 + 80);
    *(unsigned char *)(result + 88) |= 0x10u;
    *(_DWORD *)(result + 80) = v7;
  }
  if (*(void *)(a2 + 40)) {
    operator new();
  }
  if (*(void *)(a2 + 48)) {
    operator new();
  }
  if (*(void *)(a2 + 56)) {
    operator new();
  }
  char v8 = *(unsigned char *)(a2 + 88);
  if ((v8 & 4) != 0)
  {
    int v9 = *(_DWORD *)(a2 + 72);
    *(unsigned char *)(result + 88) |= 4u;
    *(_DWORD *)(result + 72) = v9;
    char v8 = *(unsigned char *)(a2 + 88);
  }
  if (v8)
  {
    int v10 = *(_DWORD *)(a2 + 64);
    *(unsigned char *)(result + 88) |= 1u;
    *(_DWORD *)(result + 64) = v10;
  }
  return result;
}

void sub_1005EA58C(void *a1)
{
}

uint64_t sub_1005EA5E0(uint64_t a1, PB::TextFormatter *this, char *a3)
{
  PB::TextFormatter::beginObject(this, a3);
  char v5 = *(unsigned char *)(a1 + 88);
  if (v5)
  {
    PB::TextFormatter::format(this, "availability", *(_DWORD *)(a1 + 64));
    char v5 = *(unsigned char *)(a1 + 88);
  }
  if ((v5 & 0x20) != 0) {
    PB::TextFormatter::format(this, "available", *(unsigned char *)(a1 + 84));
  }
  int v6 = *(const PB::Data **)(a1 + 8);
  if (v6) {
    PB::TextFormatter::format(this, "csn", v6);
  }
  int v7 = *(uint64_t **)(a1 + 16);
  char v8 = *(uint64_t **)(a1 + 24);
  while (v7 != v8)
  {
    uint64_t v9 = *v7++;
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(void *)v9 + 32))(v9, this, "details");
  }
  if ((*(unsigned char *)(a1 + 88) & 2) != 0) {
    PB::TextFormatter::format(this, "error", *(_DWORD *)(a1 + 68));
  }
  if (*(void *)(a1 + 40)) {
    PB::TextFormatter::format();
  }
  if (*(void *)(a1 + 48)) {
    PB::TextFormatter::format();
  }
  char v10 = *(unsigned char *)(a1 + 88);
  if ((v10 & 4) != 0)
  {
    PB::TextFormatter::format(this, "pairedState", *(_DWORD *)(a1 + 72));
    char v10 = *(unsigned char *)(a1 + 88);
    if ((v10 & 8) == 0)
    {
LABEL_17:
      if ((v10 & 0x10) == 0) {
        goto LABEL_19;
      }
      goto LABEL_18;
    }
  }
  else if ((*(unsigned char *)(a1 + 88) & 8) == 0)
  {
    goto LABEL_17;
  }
  PB::TextFormatter::format(this, "slot", *(_DWORD *)(a1 + 76));
  if ((*(unsigned char *)(a1 + 88) & 0x10) != 0) {
LABEL_18:
  }
    PB::TextFormatter::format(this, "type", *(_DWORD *)(a1 + 80));
LABEL_19:
  if (*(void *)(a1 + 56)) {
    PB::TextFormatter::format();
  }

  return PB::TextFormatter::endObject(this);
}

uint64_t sub_1005EA794(uint64_t a1, PB::Reader *this)
{
  unint64_t v2 = *((void *)this + 1);
  unint64_t v3 = *((void *)this + 2);
  int v4 = *((unsigned __int8 *)this + 24);
  if (v2 >= v3 || v4 != 0) {
    return v4 == 0;
  }
  while (1)
  {
    uint64_t v8 = *(void *)this;
    if (v2 <= 0xFFFFFFFFFFFFFFF5 && v2 + 10 <= v3) {
      break;
    }
    char v15 = 0;
    unsigned int v16 = 0;
    unint64_t v11 = 0;
    if (v2 > v3) {
      unint64_t v3 = v2;
    }
    do
    {
      if (v3 == v2)
      {
        int v4 = 1;
        *((unsigned char *)this + 24) = 1;
        return v4 == 0;
      }
      unint64_t v17 = v2 + 1;
      char v18 = *(unsigned char *)(v8 + v2);
      *((void *)this + 1) = v17;
      v11 |= (unint64_t)(v18 & 0x7F) << v15;
      if ((v18 & 0x80) == 0) {
        goto LABEL_26;
      }
      v15 += 7;
      unint64_t v2 = v17;
      BOOL v14 = v16++ > 8;
    }
    while (!v14);
LABEL_19:
    unsigned __int8 v19 = 0;
    LODWORD(v20) = 0;
LABEL_20:
    uint64_t result = PB::Reader::skip(this, v20, v19, 0);
    if (!result) {
      return result;
    }
LABEL_21:
    unint64_t v2 = *((void *)this + 1);
    unint64_t v3 = *((void *)this + 2);
    int v4 = *((unsigned __int8 *)this + 24);
    if (v2 >= v3 || v4 != 0) {
      return v4 == 0;
    }
  }
  char v9 = 0;
  unsigned int v10 = 0;
  unint64_t v11 = 0;
  while (1)
  {
    unint64_t v12 = v2 + 1;
    *((void *)this + 1) = v2 + 1;
    char v13 = *(unsigned char *)(v8 + v2);
    v11 |= (unint64_t)(v13 & 0x7F) << v9;
    if ((v13 & 0x80) == 0) {
      break;
    }
    v9 += 7;
    unint64_t v2 = v12;
    BOOL v14 = v10++ > 8;
    if (v14) {
      goto LABEL_19;
    }
  }
LABEL_26:
  unsigned __int8 v19 = v11 & 7;
  if ((v11 & 7) != 4)
  {
    unint64_t v20 = v11 >> 3;
    switch((v11 >> 3))
    {
      case 1u:
        *(unsigned char *)(a1 + 88) |= 8u;
        unint64_t v23 = *((void *)this + 1);
        unint64_t v24 = *((void *)this + 2);
        uint64_t v25 = *(void *)this;
        if (v23 <= 0xFFFFFFFFFFFFFFF5 && v23 + 10 <= v24)
        {
          char v26 = 0;
          unsigned int v27 = 0;
          uint64_t v28 = 0;
          do
          {
            unint64_t v29 = v23 + 1;
            *((void *)this + 1) = v23 + 1;
            char v30 = *(unsigned char *)(v25 + v23);
            v28 |= (unint64_t)(v30 & 0x7F) << v26;
            if ((v30 & 0x80) == 0) {
              goto LABEL_114;
            }
            v26 += 7;
            unint64_t v23 = v29;
            BOOL v14 = v27++ > 8;
          }
          while (!v14);
LABEL_76:
          LODWORD(v28) = 0;
          goto LABEL_114;
        }
        char v67 = 0;
        unsigned int v68 = 0;
        uint64_t v28 = 0;
        if (v24 <= v23) {
          unint64_t v24 = *((void *)this + 1);
        }
        while (2)
        {
          if (v24 == v23)
          {
            LODWORD(v28) = 0;
            *((unsigned char *)this + 24) = 1;
          }
          else
          {
            unint64_t v69 = v23 + 1;
            char v70 = *(unsigned char *)(v25 + v23);
            *((void *)this + 1) = v69;
            v28 |= (unint64_t)(v70 & 0x7F) << v67;
            if (v70 < 0)
            {
              v67 += 7;
              unint64_t v23 = v69;
              BOOL v14 = v68++ > 8;
              if (v14) {
                goto LABEL_76;
              }
              continue;
            }
            if (*((unsigned char *)this + 24)) {
              LODWORD(v28) = 0;
            }
          }
          break;
        }
LABEL_114:
        *(_DWORD *)(a1 + 76) = v28;
        goto LABEL_21;
      case 2u:
        *(unsigned char *)(a1 + 88) |= 0x20u;
        unint64_t v31 = *((void *)this + 1);
        if (v31 >= *((void *)this + 2))
        {
          BOOL v34 = 0;
          *((unsigned char *)this + 24) = 1;
        }
        else
        {
          unint64_t v32 = v31 + 1;
          int v33 = *(unsigned __int8 *)(*(void *)this + v31);
          *((void *)this + 1) = v32;
          BOOL v34 = v33 != 0;
        }
        *(unsigned char *)(a1 + 84) = v34;
        goto LABEL_21;
      case 3u:
        sub_1005EAFD8();
      case 4u:
        *(unsigned char *)(a1 + 88) |= 2u;
        unint64_t v35 = *((void *)this + 1);
        unint64_t v36 = *((void *)this + 2);
        uint64_t v37 = *(void *)this;
        if (v35 <= 0xFFFFFFFFFFFFFFF5 && v35 + 10 <= v36)
        {
          char v38 = 0;
          unsigned int v39 = 0;
          uint64_t v40 = 0;
          do
          {
            unint64_t v41 = v35 + 1;
            *((void *)this + 1) = v35 + 1;
            char v42 = *(unsigned char *)(v37 + v35);
            v40 |= (unint64_t)(v42 & 0x7F) << v38;
            if ((v42 & 0x80) == 0) {
              goto LABEL_117;
            }
            v38 += 7;
            unint64_t v35 = v41;
            BOOL v14 = v39++ > 8;
          }
          while (!v14);
LABEL_85:
          LODWORD(v40) = 0;
          goto LABEL_117;
        }
        char v71 = 0;
        unsigned int v72 = 0;
        uint64_t v40 = 0;
        if (v36 <= v35) {
          unint64_t v36 = *((void *)this + 1);
        }
        while (2)
        {
          if (v36 == v35)
          {
            LODWORD(v40) = 0;
            *((unsigned char *)this + 24) = 1;
          }
          else
          {
            unint64_t v73 = v35 + 1;
            char v74 = *(unsigned char *)(v37 + v35);
            *((void *)this + 1) = v73;
            v40 |= (unint64_t)(v74 & 0x7F) << v71;
            if (v74 < 0)
            {
              v71 += 7;
              unint64_t v35 = v73;
              BOOL v14 = v72++ > 8;
              if (v14) {
                goto LABEL_85;
              }
              continue;
            }
            if (*((unsigned char *)this + 24)) {
              LODWORD(v40) = 0;
            }
          }
          break;
        }
LABEL_117:
        *(_DWORD *)(a1 + 68) = v40;
        goto LABEL_21;
      case 5u:
        operator new();
      case 6u:
        *(unsigned char *)(a1 + 88) |= 0x10u;
        unint64_t v43 = *((void *)this + 1);
        unint64_t v44 = *((void *)this + 2);
        uint64_t v45 = *(void *)this;
        if (v43 <= 0xFFFFFFFFFFFFFFF5 && v43 + 10 <= v44)
        {
          char v46 = 0;
          unsigned int v47 = 0;
          uint64_t v48 = 0;
          do
          {
            unint64_t v49 = v43 + 1;
            *((void *)this + 1) = v43 + 1;
            char v50 = *(unsigned char *)(v45 + v43);
            v48 |= (unint64_t)(v50 & 0x7F) << v46;
            if ((v50 & 0x80) == 0) {
              goto LABEL_120;
            }
            v46 += 7;
            unint64_t v43 = v49;
            BOOL v14 = v47++ > 8;
          }
          while (!v14);
LABEL_92:
          LODWORD(v48) = 0;
          goto LABEL_120;
        }
        char v75 = 0;
        unsigned int v76 = 0;
        uint64_t v48 = 0;
        if (v44 <= v43) {
          unint64_t v44 = *((void *)this + 1);
        }
        while (2)
        {
          if (v44 == v43)
          {
            LODWORD(v48) = 0;
            *((unsigned char *)this + 24) = 1;
          }
          else
          {
            unint64_t v77 = v43 + 1;
            char v78 = *(unsigned char *)(v45 + v43);
            *((void *)this + 1) = v77;
            v48 |= (unint64_t)(v78 & 0x7F) << v75;
            if (v78 < 0)
            {
              v75 += 7;
              unint64_t v43 = v77;
              BOOL v14 = v76++ > 8;
              if (v14) {
                goto LABEL_92;
              }
              continue;
            }
            if (*((unsigned char *)this + 24)) {
              LODWORD(v48) = 0;
            }
          }
          break;
        }
LABEL_120:
        *(_DWORD *)(a1 + 80) = v48;
        goto LABEL_21;
      case 7u:
        operator new();
      case 8u:
        operator new();
      case 9u:
        operator new();
      case 0xAu:
        *(unsigned char *)(a1 + 88) |= 4u;
        unint64_t v51 = *((void *)this + 1);
        unint64_t v52 = *((void *)this + 2);
        uint64_t v53 = *(void *)this;
        if (v51 <= 0xFFFFFFFFFFFFFFF5 && v51 + 10 <= v52)
        {
          char v54 = 0;
          unsigned int v55 = 0;
          uint64_t v56 = 0;
          do
          {
            unint64_t v57 = v51 + 1;
            *((void *)this + 1) = v51 + 1;
            char v58 = *(unsigned char *)(v53 + v51);
            v56 |= (unint64_t)(v58 & 0x7F) << v54;
            if ((v58 & 0x80) == 0) {
              goto LABEL_123;
            }
            v54 += 7;
            unint64_t v51 = v57;
            BOOL v14 = v55++ > 8;
          }
          while (!v14);
LABEL_99:
          LODWORD(v56) = 0;
          goto LABEL_123;
        }
        char v79 = 0;
        unsigned int v80 = 0;
        uint64_t v56 = 0;
        if (v52 <= v51) {
          unint64_t v52 = *((void *)this + 1);
        }
        while (2)
        {
          if (v52 == v51)
          {
            LODWORD(v56) = 0;
            *((unsigned char *)this + 24) = 1;
          }
          else
          {
            unint64_t v81 = v51 + 1;
            char v82 = *(unsigned char *)(v53 + v51);
            *((void *)this + 1) = v81;
            v56 |= (unint64_t)(v82 & 0x7F) << v79;
            if (v82 < 0)
            {
              v79 += 7;
              unint64_t v51 = v81;
              BOOL v14 = v80++ > 8;
              if (v14) {
                goto LABEL_99;
              }
              continue;
            }
            if (*((unsigned char *)this + 24)) {
              LODWORD(v56) = 0;
            }
          }
          break;
        }
LABEL_123:
        *(_DWORD *)(a1 + 72) = v56;
        goto LABEL_21;
      case 0xBu:
        *(unsigned char *)(a1 + 88) |= 1u;
        unint64_t v59 = *((void *)this + 1);
        unint64_t v60 = *((void *)this + 2);
        uint64_t v61 = *(void *)this;
        if (v59 <= 0xFFFFFFFFFFFFFFF5 && v59 + 10 <= v60)
        {
          char v62 = 0;
          unsigned int v63 = 0;
          uint64_t v64 = 0;
          do
          {
            unint64_t v65 = v59 + 1;
            *((void *)this + 1) = v59 + 1;
            char v66 = *(unsigned char *)(v61 + v59);
            v64 |= (unint64_t)(v66 & 0x7F) << v62;
            if ((v66 & 0x80) == 0) {
              goto LABEL_126;
            }
            v62 += 7;
            unint64_t v59 = v65;
            BOOL v14 = v63++ > 8;
          }
          while (!v14);
LABEL_106:
          LODWORD(v64) = 0;
          goto LABEL_126;
        }
        char v83 = 0;
        unsigned int v84 = 0;
        uint64_t v64 = 0;
        if (v60 <= v59) {
          unint64_t v60 = *((void *)this + 1);
        }
        break;
      default:
        goto LABEL_20;
    }
    while (1)
    {
      if (v60 == v59)
      {
        LODWORD(v64) = 0;
        *((unsigned char *)this + 24) = 1;
        goto LABEL_126;
      }
      unint64_t v85 = v59 + 1;
      char v86 = *(unsigned char *)(v61 + v59);
      *((void *)this + 1) = v85;
      v64 |= (unint64_t)(v86 & 0x7F) << v83;
      if ((v86 & 0x80) == 0) {
        break;
      }
      v83 += 7;
      unint64_t v59 = v85;
      BOOL v14 = v84++ > 8;
      if (v14) {
        goto LABEL_106;
      }
    }
    if (*((unsigned char *)this + 24)) {
      LODWORD(v64) = 0;
    }
LABEL_126:
    *(_DWORD *)(a1 + 64) = v64;
    goto LABEL_21;
  }
  int v4 = 0;
  return v4 == 0;
}

void sub_1005EAFD8()
{
}

void sub_1005EB110(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1004660D8((void **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1005EB154(uint64_t result, PB::Writer *this)
{
  uint64_t v3 = result;
  char v4 = *(unsigned char *)(result + 88);
  if ((v4 & 8) != 0)
  {
    uint64_t result = PB::Writer::writeVarInt(this, *(_DWORD *)(result + 76), 1u);
    char v4 = *(unsigned char *)(v3 + 88);
  }
  if ((v4 & 0x20) != 0) {
    uint64_t result = PB::Writer::write(this, *(unsigned char *)(v3 + 84), 2u);
  }
  char v5 = *(const PB::Base ***)(v3 + 16);
  int v6 = *(const PB::Base ***)(v3 + 24);
  while (v5 != v6)
  {
    int v7 = *v5++;
    uint64_t result = PB::Writer::writeSubmessage(this, v7, 3u);
  }
  if ((*(unsigned char *)(v3 + 88) & 2) != 0) {
    uint64_t result = PB::Writer::writeVarInt(this, *(_DWORD *)(v3 + 68), 4u);
  }
  uint64_t v8 = *(const PB::Data **)(v3 + 8);
  if (v8) {
    uint64_t result = PB::Writer::write(this, v8, 5u);
  }
  if ((*(unsigned char *)(v3 + 88) & 0x10) != 0) {
    uint64_t result = PB::Writer::writeVarInt(this, *(_DWORD *)(v3 + 80), 6u);
  }
  if (*(void *)(v3 + 40)) {
    uint64_t result = PB::Writer::write();
  }
  if (*(void *)(v3 + 48)) {
    uint64_t result = PB::Writer::write();
  }
  if (*(void *)(v3 + 56)) {
    uint64_t result = PB::Writer::write();
  }
  char v9 = *(unsigned char *)(v3 + 88);
  if ((v9 & 4) != 0)
  {
    uint64_t result = PB::Writer::writeVarInt(this, *(_DWORD *)(v3 + 72), 0xAu);
    char v9 = *(unsigned char *)(v3 + 88);
  }
  if (v9)
  {
    unsigned int v10 = *(_DWORD *)(v3 + 64);
    return PB::Writer::writeVarInt(this, v10, 0xBu);
  }
  return result;
}

uint64_t sub_1005EB29C(uint64_t *a1, void *a2)
{
  uint64_t result = sub_1005EB314((uint64_t)(a1 + 2), a1[1], (void *)a1[1], *a1, (void *)*a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t sub_1005EB314(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, void *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&long long v15 = a6;
  *((void *)&v15 + 1) = a7;
  long long v14 = v15;
  v13[0] = a1;
  v13[1] = &v14;
  void v13[2] = &v15;
  void v13[3] = 1;
  if (a3 == a5)
  {
    uint64_t v11 = a6;
  }
  else
  {
    uint64_t v8 = (void *)(a7 - 8);
    char v9 = (void *)(a7 - 8);
    do
    {
      uint64_t v10 = *--a3;
      *a3 = 0;
      *v9-- = v10;
      *((void *)&v15 + 1) = v8;
      v7 -= 8;
      uint64_t v8 = v9;
    }
    while (a3 != a5);
    uint64_t v11 = v15;
  }
  sub_1005EB3A8((uint64_t)v13);
  return v11;
}

uint64_t sub_1005EB3A8(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    sub_100466070((void *)a1);
  }
  return a1;
}

void CellularPlanPrivateNetworksController::create()
{
}

void sub_1005EB530(_Unwind_Exception *exception_object)
{
  if (v4)
  {
    sub_10004D2C8(v4);
    if (!v3)
    {
LABEL_3:
      if (!v2) {
        goto LABEL_4;
      }
      goto LABEL_10;
    }
  }
  else if (!v3)
  {
    goto LABEL_3;
  }
  sub_10004D2C8(v3);
  if (!v2)
  {
LABEL_4:
    if (!v1) {
      goto LABEL_5;
    }
    goto LABEL_11;
  }
LABEL_10:
  sub_10004D2C8(v2);
  if (!v1)
  {
LABEL_5:
    if (v5) {
      goto LABEL_6;
    }
    goto LABEL_7;
  }
LABEL_11:
  dispatch_release(v1);
  if (v5) {
LABEL_6:
  }
    operator delete();
LABEL_7:
  _Unwind_Resume(exception_object);
}

void sub_1005EB59C(uint64_t a1)
{
  *(void *)a1 = off_1019ED450;
  unint64_t v2 = (GeofenceControllerDelegateInterface *)(a1 + 8);
  *(void *)(a1 + 8) = off_1019ED5A0;
  uint64_t v3 = (CellularPlanProvisioningMonitorModeDelegate *)(a1 + 16);
  *(void *)(a1 + 16) = off_1019ED608;
  *(void *)(a1 + 24) = off_1019ED638;
  char v18 = (void **)(a1 + 2496);
  sub_10008A88C(&v18);
  sub_10030A970(a1 + 1680);
  sub_10030A970(a1 + 872);
  sub_1000886C0(a1 + 848, *(char **)(a1 + 856));
  sub_10030AAD0(a1 + 816, *(void **)(a1 + 824));
  char v18 = (void **)(a1 + 792);
  sub_1001F1FAC(&v18);
  sub_100600F40((void *)(a1 + 744));
  sub_1000346F8(a1 + 720, *(void **)(a1 + 728));
  sub_100600FC4((void *)(a1 + 688));
  sub_10030AB98((void *)(a1 + 648));
  sub_100601048((void *)(a1 + 608));
  sub_10010C0E0(a1 + 584, *(void **)(a1 + 592));
  sub_1006010CC((void *)(a1 + 552));
  char v18 = (void **)(a1 + 528);
  sub_1000C56F4(&v18);
  char v18 = (void **)(a1 + 504);
  sub_10008A88C(&v18);
  char v4 = *(std::__shared_weak_count **)(a1 + 496);
  if (v4) {
    sub_10004D2C8(v4);
  }
  int v5 = *(void **)(a1 + 464);
  if (v5)
  {
    *(void *)(a1 + 472) = v5;
    operator delete(v5);
  }
  if (*(char *)(a1 + 463) < 0) {
    operator delete(*(void **)(a1 + 440));
  }
  uint64_t v6 = *(void *)(a1 + 432);
  *(void *)(a1 + 432) = 0;
  if (v6) {
    (*(void (**)(uint64_t))(*(void *)v6 + 8))(v6);
  }
  sub_10007CA64((const void **)(a1 + 392));
  if (*(char *)(a1 + 383) < 0) {
    operator delete(*(void **)(a1 + 360));
  }
  if (*(char *)(a1 + 359) < 0) {
    operator delete(*(void **)(a1 + 336));
  }
  uint64_t v7 = *(void *)(a1 + 296);
  *(void *)(a1 + 296) = 0;
  if (v7) {
    (*(void (**)(uint64_t))(*(void *)v7 + 8))(v7);
  }
  uint64_t v8 = *(void *)(a1 + 288);
  *(void *)(a1 + 288) = 0;
  if (v8) {
    (*(void (**)(uint64_t))(*(void *)v8 + 8))(v8);
  }
  sub_10005CD2C(a1 + 264, *(char **)(a1 + 272));
  sub_100602520(a1 + 240, *(void **)(a1 + 248));
  sub_100602474(a1 + 216, *(void **)(a1 + 224));
  char v9 = *(std::__shared_weak_count **)(a1 + 208);
  if (v9) {
    sub_10004D2C8(v9);
  }
  uint64_t v10 = *(std::__shared_weak_count **)(a1 + 192);
  if (v10) {
    sub_10004D2C8(v10);
  }
  uint64_t v11 = *(std::__shared_weak_count **)(a1 + 176);
  if (v11) {
    sub_10004D2C8(v11);
  }
  unint64_t v12 = *(std::__shared_weak_count **)(a1 + 160);
  if (v12) {
    sub_10004D2C8(v12);
  }
  char v13 = *(std::__shared_weak_count **)(a1 + 144);
  if (v13) {
    sub_10004D2C8(v13);
  }
  long long v14 = *(std::__shared_weak_count **)(a1 + 128);
  if (v14) {
    sub_10004D2C8(v14);
  }
  long long v15 = *(std::__shared_weak_count **)(a1 + 112);
  if (v15) {
    sub_10004D2C8(v15);
  }
  unsigned int v16 = *(std::__shared_weak_count **)(a1 + 96);
  if (v16) {
    std::__shared_weak_count::__release_weak(v16);
  }
  unint64_t v17 = *(std::__shared_weak_count **)(a1 + 80);
  if (v17) {
    sub_10004D2C8(v17);
  }
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)(a1 + 64));
  sub_100087E88((void *)(a1 + 32));
  CellularPlanProvisioningMonitorModeDelegate::~CellularPlanProvisioningMonitorModeDelegate(v3);
  GeofenceControllerDelegateInterface::~GeofenceControllerDelegateInterface(v2);
  CellularPlanPrivateNetworksInterface::~CellularPlanPrivateNetworksInterface((CellularPlanPrivateNetworksInterface *)a1);
}

void *sub_1005EB898(uint64_t a1)
{
  sub_1000346F8(a1 + 32, *(void **)(a1 + 40));

  return sub_100600FC4((void *)a1);
}

void *sub_1005EB8D8(uint64_t a1)
{
  sub_10010C0E0(a1 + 32, *(void **)(a1 + 40));

  return sub_1006010CC((void *)a1);
}

uint64_t sub_1005EB918(uint64_t a1)
{
  if (*(char *)(a1 + 71) < 0) {
    operator delete(*(void **)(a1 + 48));
  }
  if (*(char *)(a1 + 47) < 0) {
    operator delete(*(void **)(a1 + 24));
  }
  return a1;
}

void sub_1005EB960(uint64_t a1)
{
}

void sub_1005EB968(uint64_t a1)
{
}

void sub_1005EB970(uint64_t a1)
{
}

void sub_1005EB978(uint64_t a1)
{
  sub_1005EB59C(a1);

  operator delete();
}

void sub_1005EB9B0(uint64_t a1)
{
  sub_1005EB59C(a1 - 8);

  operator delete();
}

void sub_1005EB9EC(uint64_t a1)
{
  sub_1005EB59C(a1 - 16);

  operator delete();
}

void sub_1005EBA28(uint64_t a1)
{
  sub_1005EB59C(a1 - 24);

  operator delete();
}

uint64_t CellularPlanPrivateNetworksController::CellularPlanPrivateNetworksController(uint64_t a1, NSObject **a2, void *a3, void *a4, void *a5)
{
  *(void *)(a1 + 16) = off_101AB94D8;
  *(void *)(a1 + 24) = &off_1019E3568;
  ctu::OsLogContext::OsLogContext((ctu::OsLogContext *)&v21, kCtLoggingSystemName, "cp.pnw.ctr");
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  uint64_t v10 = *a2;
  *(void *)(a1 + 48) = *a2;
  if (v10) {
    dispatch_retain(v10);
  }
  *(void *)(a1 + 56) = 0;
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)&v19, &v21);
  ctu::OsLogLogger::OsLogLogger((ctu::OsLogLogger *)(a1 + 64), (const ctu::OsLogLogger *)&v19);
  ctu::OsLogLogger::~OsLogLogger((ctu::OsLogLogger *)&v19);
  ctu::OsLogContext::~OsLogContext((ctu::OsLogContext *)&v21);
  *(void *)a1 = off_1019ED450;
  *(void *)(a1 + 8) = off_1019ED5A0;
  *(void *)(a1 + 16) = off_1019ED608;
  *(void *)(a1 + 24) = off_1019ED638;
  *(void *)(a1 + 72) = *a5;
  uint64_t v11 = a5[1];
  *(void *)(a1 + 80) = v11;
  if (v11) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v11 + 8), 1uLL, memory_order_relaxed);
  }
  *(void *)(a1 + 88) = *a3;
  uint64_t v12 = a3[1];
  *(void *)(a1 + 96) = v12;
  if (v12) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v12 + 16), 1uLL, memory_order_relaxed);
  }
  *(_OWORD *)(a1 + 120) = 0u;
  *(_OWORD *)(a1 + 104) = 0u;
  *(void *)(a1 + 136) = *a4;
  uint64_t v13 = a4[1];
  *(void *)(a1 + 144) = v13;
  if (v13) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v13 + 8), 1uLL, memory_order_relaxed);
  }
  *(void *)(a1 + 152) = 0;
  *(void *)(a1 + 160) = 0;
  (***(void (****)(Registry **__return_ptr))(a1 + 72))(&v19);
  Registry::getNotificationSenderFactory((uint64_t *)&v21, v19);
  (*(void (**)(char *))(*(void *)v21.var0 + 176))(v21.var0);
  if (v21.var1.fRef) {
    sub_10004D2C8((std::__shared_weak_count *)v21.var1.fRef);
  }
  if (v20) {
    sub_10004D2C8(v20);
  }
  *(void *)(a1 + 224) = 0;
  *(void *)(a1 + 216) = a1 + 224;
  *(void *)(a1 + 232) = 0;
  *(void *)(a1 + 248) = 0;
  *(void *)(a1 + 240) = a1 + 248;
  *(_OWORD *)(a1 + 184) = 0u;
  *(_OWORD *)(a1 + 200) = 0u;
  *(void *)(a1 + 256) = 0;
  *(void *)(a1 + 272) = 0;
  *(void *)(a1 + 264) = a1 + 272;
  *(void *)(a1 + 280) = 0;
  *(void *)(a1 + 288) = 0;
  *(void *)(a1 + 392) = 0;
  *(_DWORD *)(a1 + 400) = 0;
  *(void *)(a1 + 296) = 0;
  *(_DWORD *)(a1 + 304) = 0;
  *(_OWORD *)(a1 + 336) = 0u;
  *(_OWORD *)(a1 + 352) = 0u;
  *(_OWORD *)(a1 + 368) = 0u;
  *(_WORD *)(a1 + 384) = 0;
  *(void *)(a1 + 408) = 0;
  *(void *)(a1 + 416) = 0;
  *(_DWORD *)(a1 + 424) = 0x10000;
  *(_OWORD *)(a1 + 432) = 0u;
  *(_OWORD *)(a1 + 448) = 0u;
  *(_OWORD *)(a1 + 464) = 0u;
  *(void *)(a1 + 480) = 0;
  sub_100058DB0(&__p, "CellularPlanPrivateNetworksController");
  long long v14 = *(NSObject **)(a1 + 48);
  unsigned int v16 = v14;
  if (v14) {
    dispatch_retain(v14);
  }
  ctu::RestModule::RestModule();
  if (v16) {
    dispatch_release(v16);
  }
  if (v18 < 0) {
    operator delete(__p);
  }
  *(void *)(a1 + 576) = 0;
  *(_OWORD *)(a1 + 592) = 0u;
  *(_OWORD *)(a1 + 504) = 0u;
  *(_OWORD *)(a1 + 520) = 0u;
  *(_OWORD *)(a1 + 536) = 0u;
  *(void *)(a1 + 584) = a1 + 592;
  *(void *)(a1 + 672) = 0;
  *(unsigned char *)(a1 + 680) = 0;
  *(_OWORD *)(a1 + 632) = 0u;
  *(_OWORD *)(a1 + 704) = 0u;
  *(_OWORD *)(a1 + 720) = 0u;
  *(_OWORD *)(a1 + 688) = 0u;
  *(void *)(a1 + 736) = 0;
  *(void *)(a1 + 720) = a1 + 728;
  *(void *)(a1 + 768) = 0;
  *(_DWORD *)(a1 + 776) = 0;
  *(void *)(a1 + 808) = 0;
  *(_OWORD *)(a1 + 792) = 0u;
  *(void *)(a1 + 832) = 0;
  *(void *)(a1 + 824) = 0;
  *(void *)(a1 + 816) = a1 + 824;
  *(unsigned char *)(a1 + 840) = 0;
  *(void *)(a1 + 856) = 0;
  *(void *)(a1 + 864) = 0;
  *(void *)(a1 + 848) = a1 + 856;
  *(void *)(a1 + 872) = 0;
  RegisteredNetworkInfo::RegisteredNetworkInfo((RegisteredNetworkInfo *)(a1 + 880));
  *(void *)(a1 + 1680) = 0;
  RegisteredNetworkInfo::RegisteredNetworkInfo((RegisteredNetworkInfo *)(a1 + 1688));
  *(void *)(a1 + 2528) = 0;
  *(_OWORD *)(a1 + 2512) = 0u;
  *(_OWORD *)(a1 + 2496) = 0u;
  return a1;
}

void sub_1005EBEA0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, _Unwind_Exception *exception_object, ctu::OsLogLogger *a15, void *a16, CellularPlanProvisioningMonitorModeDelegate *a17, GeofenceControllerDelegateInterface *a18, dispatch_object_t object, dispatch_object_t a20,void *__p,uint64_t a22,int a23,__int16 a24,char a25,char a26,char a27,uint64_t a28)
{
  sub_10030A970(v32);
  sub_1000886C0(v28 + 848, *(char **)(v28 + 856));
  sub_10030AAD0(v28 + 816, *(void **)(v28 + 824));
  *(void *)(v38 - 104) = v31;
  sub_1001F1FAC((void ***)(v38 - 104));
  sub_100600F40((void *)(v28 + 744));
  sub_1005EB898(v28 + 688);
  sub_10030AB98((void *)(v28 + 648));
  sub_100601048(v33);
  sub_1005EB8D8(v28 + 552);
  *(void *)(v38 - 104) = v28 + 528;
  sub_1000C56F4((void ***)(v38 - 104));
  *(void *)(v38 - 104) = v30;
  sub_10008A88C((void ***)(v38 - 104));
  unsigned int v39 = *(std::__shared_weak_count **)(v28 + 496);
  if (v39) {
    sub_10004D2C8(v39);
  }
  uint64_t v40 = *(void **)(v28 + 464);
  if (v40)
  {
    *(void *)(v28 + 472) = v40;
    operator delete(v40);
  }
  unint64_t v41 = (uint64_t *)(v34 + 216);
  if (*(char *)(v28 + 463) < 0) {
    operator delete(*(void **)(v28 + 440));
  }
  uint64_t v42 = *v41;
  *unint64_t v41 = 0;
  if (v42) {
    (*(void (**)(uint64_t))(*(void *)v42 + 8))(v42);
  }
  sub_10007CA64(v37);
  sub_1005EB918(v34 + 96);
  uint64_t v43 = *(void *)(v28 + 296);
  *(void *)(v28 + 296) = 0;
  if (v43) {
    (*(void (**)(uint64_t))(*(void *)v43 + 8))(v43);
  }
  uint64_t v44 = *v29;
  *unint64_t v29 = 0;
  if (v44) {
    (*(void (**)(uint64_t))(*(void *)v44 + 8))(v44);
  }
  sub_10005CD2C(v36, *(char **)(v28 + 272));
  sub_100602520(v35, *(void **)(v28 + 248));
  sub_100602474(v34, *(void **)(v28 + 224));
  uint64_t v45 = *(std::__shared_weak_count **)(v28 + 208);
  if (v45) {
    sub_10004D2C8(v45);
  }
  char v46 = *(std::__shared_weak_count **)(v28 + 192);
  if (v46) {
    sub_10004D2C8(v46);
  }
  unsigned int v47 = *(std::__shared_weak_count **)(v28 + 176);
  if (v47) {
    sub_10004D2C8(v47);
  }
  uint64_t v48 = *(std::__shared_weak_count **)(v28 + 160);
  if (v48) {
    sub_10004D2C8(v48);
  }
  unint64_t v49 = *(std::__shared_weak_count **)(v28 + 144);
  if (v49) {
    sub_10004D2C8(v49);
  }
  char v50 = *(std::__shared_weak_count **)(v28 + 128);
  if (v50) {
    sub_10004D2C8(v50);
  }
  unint64_t v51 = *(std::__shared_weak_count **)(v28 + 112);
  if (v51) {
    sub_10004D2C8(v51);
  }
  unint64_t v52 = *(std::__shared_weak_count **)(v28 + 96);
  if (v52) {
    std::__shared_weak_count::__release_weak(v52);
  }
  uint64_t v53 = *(std::__shared_weak_count **)(v28 + 80);
  if (v53) {
    sub_10004D2C8(v53);
  }
  ctu::OsLogLogger::~OsLogLogger(a15);
  sub_100087E88(a16);
  CellularPlanProvisioningMonitorModeDelegate::~CellularPlanProvisioningMonitorModeDelegate(a17);
  GeofenceControllerDelegateInterface::~GeofenceControllerDelegateInterface(a18);
  CellularPlanPrivateNetworksInterface::~CellularPlanPrivateNetworksInterface((CellularPlanPrivateNetworksInterface *)v28);
  _Unwind_Resume(a1);
}

void sub_1005EC168(void *a1, int a2, uint64_t a3)
{
  if (sub_1005EC568((uint64_t)a1, a2))
  {
    memset(&__p, 0, sizeof(__p));
    sub_1000631F4(&__p, a1[63], a1[64], a2);
    std::string::size_type size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      std::string::size_type size = __p.__r_.__value_.__l.__size_;
    }
    if (size)
    {
      uint64_t v7 = (const std::string *)sub_100046F68((uint64_t)(a1 + 27), (void **)&__p.__r_.__value_.__l.__data_);
      if (a1 + 28 != (void *)v7)
      {
        uint64_t v8 = v7;
        long long v26 = 0u;
        long long v27 = 0u;
        long long buf = 0u;
        long long v25 = 0u;
        if (v7[9].__r_.__value_.__s.__data_[0]) {
          sub_100093B44((std::string *)&buf, v7 + 8);
        }
        if (v8[10].__r_.__value_.__s.__data_[8]) {
          sub_100093B44((std::string *)&v26, (const std::string *)((char *)v8 + 224));
        }
        sub_1000593FC((uint64_t)v18, &buf);
        sub_1000593FC((uint64_t)v19, &v26);
        v19[32] = 1;
        uint64_t v9 = *(void *)(a3 + 24);
        if (!v9) {
          sub_10007B600();
        }
        (*(void (**)(uint64_t, unsigned char *))(*(void *)v9 + 48))(v9, v18);
        sub_100335E2C((uint64_t)v18);
        if (BYTE8(v27) && SBYTE7(v27) < 0) {
          operator delete((void *)v26);
        }
        if (BYTE8(v25) && SBYTE7(v25) < 0) {
          operator delete((void *)buf);
        }
        goto LABEL_29;
      }
      long long v15 = a1[8];
      if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
      {
        p_p = &__p;
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
          p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
        }
        LODWORD(buf) = 136315138;
        *(void *)((char *)&buf + 4) = p_p;
        _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "SIM matching to iccid [%s] not found for getSimFileInfoForSlot", (uint8_t *)&buf, 0xCu);
      }
      v20[0] = 0;
      v20[64] = 0;
      uint64_t v16 = *(void *)(a3 + 24);
      if (!v16) {
        sub_10007B600();
      }
      (*(void (**)(uint64_t, unsigned char *))(*(void *)v16 + 48))(v16, v20);
      long long v14 = v20;
    }
    else
    {
      uint64_t v12 = a1[8];
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
      {
        LODWORD(buf) = 67109120;
        DWORD1(buf) = a2;
        _os_log_error_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "Cannot get pnw sim file info, iccid missing for slot [%d]", (uint8_t *)&buf, 8u);
      }
      v21[0] = 0;
      v21[64] = 0;
      uint64_t v13 = *(void *)(a3 + 24);
      if (!v13) {
        sub_10007B600();
      }
      (*(void (**)(uint64_t, unsigned char *))(*(void *)v13 + 48))(v13, v21);
      long long v14 = v21;
    }
    sub_100335E2C((uint64_t)v14);
LABEL_29:
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    return;
  }
  uint64_t v10 = a1[8];
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(buf) = 67109120;
    DWORD1(buf) = a2;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I Cannot get pnw sim file info, slot [%d] is either not state ready or PNW", (uint8_t *)&buf, 8u);
  }
  v23[0] = 0;
  v23[64] = 0;
  uint64_t v11 = *(void *)(a3 + 24);
  if (!v11) {
    sub_10007B600();
  }
  (*(void (**)(uint64_t, unsigned char *))(*(void *)v11 + 48))(v11, v23);
  sub_100335E2C((uint64_t)v23);
}

void sub_1005EC4E0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,void *a40,uint64_t a41,int a42,__int16 a43,char a44,char a45)
{
  if (a16 && a15 < 0) {
    operator delete(__p);
  }
  sub_1005EC5F8(v45 - 128);
  if (a45 < 0) {
    operator delete(a40);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_1005EC568(uint64_t a1, int a2)
{
  uint64_t v2 = *(void *)(a1 + 504);
  uint64_t v3 = *(void *)(a1 + 512);
  if (v2 == v3) {
    return 0;
  }
  uint64_t v5 = a1 + 216;
  uint64_t v6 = (void **)(a1 + 224);
  while (1)
  {
    if (*(_DWORD *)v2 == a2)
    {
      if (subscriber::isSimReady())
      {
        uint64_t v7 = sub_100046F68(v5, (void **)(v2 + 72));
        if (v6 != v7)
        {
          if (*((unsigned char *)v7 + 256)) {
            break;
          }
        }
      }
    }
    v2 += 168;
    if (v2 == v3) {
      return 0;
    }
  }
  return 1;
}

uint64_t sub_1005EC5F8(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 56) && *(char *)(a1 + 55) < 0) {
    operator delete(*(void **)(a1 + 32));
  }
  if (*(unsigned char *)(a1 + 24) && *(char *)(a1 + 23) < 0) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t *sub_1005EC64C(uint64_t *result, uint64_t **a2)
{
  uint64_t v3 = (uint64_t *)(a2 + 1);
  uint64_t v2 = *a2;
  if (*a2 != (uint64_t *)(a2 + 1))
  {
    uint64_t v5 = (uint64_t)result;
    do
    {
      if (sub_1005EC6E4(v5, (uint64_t)(v2 + 4)) < 2)
      {
        uint64_t v6 = (uint64_t *)v2[1];
        if (v6)
        {
          do
          {
            uint64_t result = v6;
            uint64_t v6 = (uint64_t *)*v6;
          }
          while (v6);
        }
        else
        {
          do
          {
            uint64_t result = (uint64_t *)v2[2];
            BOOL v7 = *result == (void)v2;
            uint64_t v2 = result;
          }
          while (!v7);
        }
      }
      else
      {
        uint64_t result = sub_1000E1C44(a2, (uint64_t)v2);
      }
      uint64_t v2 = result;
    }
    while (result != v3);
  }
  return result;
}

uint64_t sub_1005EC6E4(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = a1 + 216;
  uint64_t v5 = (void **)(a1 + 224);
  if ((void **)(a1 + 224) != sub_100046F68(a1 + 216, (void **)a2)) {
    goto LABEL_25;
  }
  CFBooleanRef BOOLean = 0;
  (***(void (****)(Registry **__return_ptr))(a1 + 72))(&v24);
  ServiceMap = (std::mutex *)Registry::getServiceMap(v24);
  BOOL v7 = ServiceMap;
  if (v8 < 0)
  {
    uint64_t v9 = (unsigned __int8 *)(v8 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v10 = 5381;
    do
    {
      uint64_t v8 = v10;
      unsigned int v11 = *v9++;
      uint64_t v10 = (33 * v10) ^ v11;
    }
    while (v11);
  }
  std::mutex::lock(ServiceMap);
  __p[0] = (void *)v8;
  uint64_t v12 = sub_10004D37C(&v7[1].__m_.__sig, (unint64_t *)__p);
  if (v12)
  {
    uint64_t v14 = v12[3];
    uint64_t v13 = (std::__shared_weak_count *)v12[4];
    if (v13)
    {
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v7);
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v13);
      char v15 = 0;
      goto LABEL_10;
    }
  }
  else
  {
    uint64_t v14 = 0;
  }
  std::mutex::unlock(v7);
  uint64_t v13 = 0;
  char v15 = 1;
LABEL_10:
  if (*(char *)(a2 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)a2;
    uint64_t v29 = *(void *)(a2 + 16);
  }
  (*(void (**)(const void **__return_ptr, uint64_t, void **, const __CFString *, const __CFString *, void, uint64_t))(*(void *)v14 + 24))(&v26, v14, __p, @"isPnwSim", @"PrivateNetwork", 0, 2);
  sub_1000057AC(&BOOLean, &v26);
  sub_1000577C4(&v26);
  if (SHIBYTE(v29) < 0)
  {
    operator delete(__p[0]);
    if (v15) {
      goto LABEL_16;
    }
    goto LABEL_15;
  }
  if ((v15 & 1) == 0) {
LABEL_15:
  }
    sub_10004D2C8(v13);
LABEL_16:
  if (v25) {
    sub_10004D2C8(v25);
  }
  if (BOOLean) {
    uint64_t v16 = sub_100084B4C;
  }
  else {
    uint64_t v16 = 0;
  }
  if (v16 && CFBooleanGetValue(BOOLean))
  {
    sub_100062778((const void **)&BOOLean);
    return 0;
  }
  sub_100062778((const void **)&BOOLean);
LABEL_25:
  if (v5 == sub_100046F68(v4, (void **)a2))
  {
    unsigned __int8 v19 = *(NSObject **)(a1 + 64);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
    {
      if (*(char *)(a2 + 23) >= 0) {
        OsLogContext v21 = (void *)a2;
      }
      else {
        OsLogContext v21 = *(void **)a2;
      }
      LODWORD(__p[0]) = 136315138;
      *(void **)((char *)__p + 4) = v21;
      _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "unexpected iccid [%s] for getting settings mode", (uint8_t *)__p, 0xCu);
    }
    return 2;
  }
  __p[0] = (void *)a2;
  unint64_t v17 = sub_100602C14(v4, (void **)a2, (long long **)__p);
  if (!*((unsigned char *)v17 + 256)) {
    return 2;
  }
  uint64_t result = 0;
  if (*(unsigned char *)(a1 + 680) && *((unsigned char *)v17 + 257))
  {
    if (*(char *)(a2 + 23) < 0)
    {
      sub_10004FC84(v22, *(void **)a2, *(void *)(a2 + 8));
    }
    else
    {
      *(_OWORD *)unint64_t v22 = *(_OWORD *)a2;
      uint64_t v23 = *(void *)(a2 + 16);
    }
    int v20 = sub_1005F06B8(a1, v22);
    if (SHIBYTE(v23) < 0) {
      operator delete(v22[0]);
    }
    return v20 == 1;
  }
  return result;
}

void sub_1005ECA34(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, std::__shared_weak_count *a17, char a18, int a19, __int16 a20,char a21,char a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  if ((v29 & 1) == 0) {
    sub_10004D2C8(v28);
  }
  if (a17) {
    sub_10004D2C8(a17);
  }
  _Unwind_Resume(exception_object);
}

void sub_1005ECAC8(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  if (a3)
  {
    sub_10006891C((uint64_t)v15, a2);
    sub_100336AB8((uint64_t)v24, a4);
    sub_1005ECC70(a1, (uint64_t)v15, (uint64_t)v24);
    sub_10030D830(v24);
    sub_10005CD90((uint64_t)v22, v22[1]);
    if (v21 < 0) {
      operator delete(__p);
    }
    if (v19 < 0) {
      operator delete(v18);
    }
    if (v17 < 0) {
      operator delete(v16);
    }
    if ((v15[31] & 0x80000000) != 0)
    {
      uint64_t v6 = (void **)v15;
LABEL_18:
      operator delete(v6[1]);
    }
  }
  else
  {
    sub_10006891C((uint64_t)v7, a2);
    sub_100336AB8((uint64_t)v23, a4);
    sub_1005ED61C(a1, (uint64_t)v7, (uint64_t)v23);
    sub_10030D830(v23);
    sub_10005CD90((uint64_t)v14, v14[1]);
    if (v13 < 0) {
      operator delete(v12);
    }
    if (v11 < 0) {
      operator delete(v10);
    }
    if (v9 < 0) {
      operator delete(v8);
    }
    if ((v7[31] & 0x80000000) != 0)
    {
      uint64_t v6 = (void **)v7;
      goto LABEL_18;
    }
  }
}

void sub_1005ECC28(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_10030D830((void *)(v2 - 104));
  sub_1002F1208((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1005ECC70(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_DWORD *)a2 != 1 || !sub_1005EDDAC(a1)) {
    goto LABEL_16;
  }
  (***(void (****)(unsigned char *__return_ptr))(a1 + 72))(buf);
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)buf);
  BOOL v7 = ServiceMap;
  if (v8 < 0)
  {
    char v9 = (unsigned __int8 *)(v8 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v10 = 5381;
    do
    {
      uint64_t v8 = v10;
      unsigned int v11 = *v9++;
      uint64_t v10 = (33 * v10) ^ v11;
    }
    while (v11);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v73 = (void *)v8;
  uint64_t v12 = sub_10004D37C(&v7[1].__m_.__sig, (unint64_t *)&v73);
  if (v12)
  {
    uint64_t v14 = v12[3];
    char v13 = (std::__shared_weak_count *)v12[4];
    if (v13)
    {
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v7);
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v13);
      goto LABEL_11;
    }
  }
  else
  {
    uint64_t v14 = 0;
  }
  std::mutex::unlock(v7);
  char v13 = 0;
LABEL_11:
  char v15 = (*(uint64_t (**)(uint64_t))(*(void *)v14 + 32))(v14);
  if (v13) {
    sub_10004D2C8(v13);
  }
  if (*(void *)&buf[8]) {
    sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
  }
  if ((v15 & 1) == 0)
  {
    char v54 = *(NSObject **)(a1 + 64);
    if (os_log_type_enabled(v54, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v54, OS_LOG_TYPE_ERROR, "Offload SIM present on device, do not install MDM configuration profile.", buf, 2u);
    }
    sub_100336E2C(a3, 0x100000003);
    return;
  }
LABEL_16:
  char v17 = (uint64_t **)(a1 + 240);
  uint64_t v16 = *(void ***)(a1 + 240);
  char v18 = (void **)(a1 + 248);
  if (v16 == (void **)(a1 + 248)) {
    goto LABEL_43;
  }
  int v19 = 0;
  do
  {
    if (!*((unsigned char *)v16 + 160))
    {
      int v20 = (void *)*((unsigned __int8 *)v16 + 55);
      int v21 = (char)v20;
      if ((char)v20 < 0) {
        int v20 = v16[5];
      }
      if (v20 == (void *)21)
      {
        unint64_t v22 = (unint64_t *)(v16 + 4);
        if (v21 < 0) {
          unint64_t v22 = (unint64_t *)v16[4];
        }
        unint64_t v23 = bswap64(*v22);
        unint64_t v24 = 0x54656D7055706772;
        if (v23 == 0x54656D7055706772
          && (unint64_t v23 = bswap64(v22[1]), v24 = 0x6164654964656E74, v23 == 0x6164654964656E74)
          && (unint64_t v23 = bswap64(*(unint64_t *)((char *)v22 + 13)),
              unint64_t v24 = 0x656E746966696572,
              v23 == 0x656E746966696572))
        {
          int v25 = 0;
        }
        else if (v23 < v24)
        {
          int v25 = -1;
        }
        else
        {
          int v25 = 1;
        }
        if (v25) {
          ++v19;
        }
      }
      else
      {
        ++v19;
      }
    }
    long long v26 = (void **)v16[1];
    if (v26)
    {
      do
      {
        long long v27 = v26;
        long long v26 = (void **)*v26;
      }
      while (v26);
    }
    else
    {
      do
      {
        long long v27 = (void **)v16[2];
        BOOL v38 = *v27 == v16;
        uint64_t v16 = v27;
      }
      while (!v38);
    }
    uint64_t v16 = v27;
  }
  while (v27 != v18);
  int v28 = v19;
  if (v19 <= 4u)
  {
LABEL_43:
    unint64_t v73 = 0;
    uint64_t v74 = 0;
    uint64_t v75 = 0;
    sub_10006891C((uint64_t)v63, a2);
    sub_1005EDEA4(&v73, (uint64_t)v63);
    sub_10005CD90((uint64_t)v72, v72[1]);
    if (v71 < 0) {
      operator delete(__p);
    }
    if (v69 < 0) {
      operator delete(v68);
    }
    if (v67 < 0) {
      operator delete(v66);
    }
    if (v65 < 0) {
      operator delete(v64);
    }
    uint64_t v30 = *v17;
    if (*v17 == (uint64_t *)v18)
    {
LABEL_59:
      uint64_t v33 = HIBYTE(v75);
      if (v75 < 0) {
        uint64_t v33 = v74;
      }
      if (v33 == 17)
      {
        uint64_t v34 = (uint64_t *)&v73;
        if (v75 < 0) {
          uint64_t v34 = (uint64_t *)v73;
        }
        uint64_t v35 = *v34;
        uint64_t v36 = v34[1];
        int v37 = *((unsigned __int8 *)v34 + 16);
        BOOL v38 = v35 == 0x4964616F6C66664FLL && v36 == 0x65696669746E6564;
        if (v38 && v37 == 114) {
          goto LABEL_74;
        }
      }
      if (v18 == sub_100046F68(a1 + 240, &v73))
      {
LABEL_74:
        unint64_t v41 = *(NSObject **)(a1 + 64);
        if (os_log_type_enabled(v41, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v42 = (void *)(a2 + 8);
          if (*(char *)(a2 + 31) < 0) {
            uint64_t v42 = (void *)*v42;
          }
          uint64_t v43 = (void *)(a2 + 32);
          if (*(char *)(a2 + 55) < 0) {
            uint64_t v43 = (void *)*v43;
          }
          uint64_t v44 = &v73;
          if (v75 < 0) {
            uint64_t v44 = v73;
          }
          *(_DWORD *)long long buf = 136315650;
          *(void *)&uint8_t buf[4] = v42;
          *(_WORD *)&unsigned char buf[12] = 2080;
          *(void *)&buf[14] = v43;
          __int16 v78 = 2080;
          char v79 = v44;
          _os_log_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_DEFAULT, "#I Installing profile [%s, %s] with identifier [%s]", buf, 0x20u);
        }
        *(void *)long long buf = &v73;
        uint64_t v45 = sub_1006028B8(a1 + 240, &v73, (long long **)buf);
        *((_DWORD *)v45 + 14) = *(_DWORD *)a2;
        std::string::operator=((std::string *)(v45 + 8), (const std::string *)(a2 + 8));
        std::string::operator=((std::string *)(v45 + 11), (const std::string *)(a2 + 32));
        std::string::operator=((std::string *)(v45 + 14), (const std::string *)(a2 + 56));
        std::string::operator=((std::string *)(v45 + 17), (const std::string *)(a2 + 80));
        v45[20] = *(void *)(a2 + 104);
        if (v45 + 7 != (uint64_t *)a2) {
          sub_100601150((uint64_t **)v45 + 21, *(long long **)(a2 + 112), (long long *)(a2 + 120));
        }
        sub_1005EDF84(a1);
        sub_1005EE984(a1);
        (*(void (**)(void))(**(void **)(a1 + 168) + 16))(*(void *)(a1 + 168));
        sub_1005EECFC(a1);
        sub_1005EEEF0(a1);
        sub_100058DB0(v58, "EvaluateAllIccids");
        if (SHIBYTE(v59) < 0)
        {
          sub_10004FC84(__dst, v58[0], (unint64_t)v58[1]);
        }
        else
        {
          *(_OWORD *)long long __dst = *(_OWORD *)v58;
          uint64_t v61 = v59;
        }
        int v62 = 8;
        sub_100007714(a1, (uint64_t *)__dst);
        if (SHIBYTE(v61) < 0) {
          operator delete(__dst[0]);
        }
        if (SHIBYTE(v59) < 0) {
          operator delete(v58[0]);
        }
        sub_100336E2C(a3, 0);
        sub_1005EF3A4(a1);
      }
      else
      {
        uint64_t v40 = *(NSObject **)(a1 + 64);
        if (os_log_type_enabled(v40, OS_LOG_TYPE_ERROR))
        {
          uint64_t v56 = v73;
          if (v75 >= 0) {
            uint64_t v56 = &v73;
          }
          unint64_t v57 = (void *)(a2 + 8);
          if (*(char *)(a2 + 31) < 0) {
            unint64_t v57 = (void *)*v57;
          }
          *(_DWORD *)long long buf = 136315394;
          *(void *)&uint8_t buf[4] = v56;
          *(_WORD *)&unsigned char buf[12] = 2080;
          *(void *)&buf[14] = v57;
          _os_log_error_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_ERROR, "Identifier [%s] already exists on device, do not install MDM configuration profile [%s]", buf, 0x16u);
        }
        sub_100336E2C(a3, 0x100000002);
      }
    }
    else
    {
      while (!*((unsigned char *)v30 + 160))
      {
        uint64_t v31 = (uint64_t *)v30[1];
        if (v31)
        {
          do
          {
            uint64_t v32 = v31;
            uint64_t v31 = (uint64_t *)*v31;
          }
          while (v31);
        }
        else
        {
          do
          {
            uint64_t v32 = (uint64_t *)v30[2];
            BOOL v38 = *v32 == (void)v30;
            uint64_t v30 = v32;
          }
          while (!v38);
        }
        uint64_t v30 = v32;
        if (v32 == (uint64_t *)v18) {
          goto LABEL_59;
        }
      }
      char v46 = *(NSObject **)(a1 + 64);
      if (os_log_type_enabled(v46, OS_LOG_TYPE_DEFAULT))
      {
        unsigned int v47 = v30 + 8;
        if (*((char *)v30 + 87) < 0) {
          unsigned int v47 = (void *)*v47;
        }
        uint64_t v48 = v30 + 11;
        if (*((char *)v30 + 111) < 0) {
          uint64_t v48 = (void *)*v48;
        }
        unint64_t v49 = v30 + 4;
        if (*((char *)v30 + 55) < 0) {
          unint64_t v49 = (void *)*v49;
        }
        char v50 = (void *)(a2 + 8);
        if (*(char *)(a2 + 31) < 0) {
          char v50 = (void *)*v50;
        }
        unint64_t v51 = (void *)(a2 + 32);
        if (*(char *)(a2 + 55) < 0) {
          unint64_t v51 = (void *)*v51;
        }
        unint64_t v52 = &v73;
        if (v75 < 0) {
          unint64_t v52 = v73;
        }
        *(_DWORD *)long long buf = 136316418;
        *(void *)&uint8_t buf[4] = v47;
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = v48;
        __int16 v78 = 2080;
        char v79 = v49;
        __int16 v80 = 2080;
        unint64_t v81 = v50;
        __int16 v82 = 2080;
        char v83 = v51;
        __int16 v84 = 2080;
        unint64_t v85 = v52;
        _os_log_impl((void *)&_mh_execute_header, v46, OS_LOG_TYPE_DEFAULT, "#I Getting ready to upgrade profile [%s, %s, %s] to [%s, %s, %s] (name, version, identifier)", buf, 0x3Eu);
      }
      sub_100058DB0(buf, "TempUpgradeIdentifier");
      unsigned int v76 = (long long *)buf;
      uint64_t v53 = sub_100602610(v17, (void **)buf, (uint64_t)&unk_10144E20E, &v76);
      *((_DWORD *)v53 + 14) = *(_DWORD *)a2;
      std::string::operator=((std::string *)(v53 + 64), (const std::string *)(a2 + 8));
      std::string::operator=((std::string *)(v53 + 88), (const std::string *)(a2 + 32));
      std::string::operator=((std::string *)(v53 + 112), (const std::string *)(a2 + 56));
      std::string::operator=((std::string *)(v53 + 136), (const std::string *)(a2 + 80));
      *((void *)v53 + 20) = *(void *)(a2 + 104);
      if (v53 + 56 != (char *)a2) {
        sub_100601150((uint64_t **)v53 + 21, *(long long **)(a2 + 112), (long long *)(a2 + 120));
      }
      if (SHIBYTE(v78) < 0) {
        operator delete(*(void **)buf);
      }
      sub_100336E2C(a3, 0);
    }
    if (SHIBYTE(v75) < 0) {
      operator delete(v73);
    }
  }
  else
  {
    char v29 = *(NSObject **)(a1 + 64);
    if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
    {
      unsigned int v55 = (void *)(a2 + 8);
      if (*(char *)(a2 + 31) < 0) {
        unsigned int v55 = (void *)*v55;
      }
      *(_DWORD *)long long buf = 67109378;
      *(_DWORD *)&uint8_t buf[4] = v28;
      *(_WORD *)&uint8_t buf[8] = 2080;
      *(void *)&buf[10] = v55;
      _os_log_error_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_ERROR, "Too many profiles already on device [%d], do not install MDM configuration profile [%s]", buf, 0x12u);
    }
    sub_100336E2C(a3, 0x100000005);
  }
}

void sub_1005ED560(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,void *a40,uint64_t a41,int a42,__int16 a43,char a44,char a45)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  if (a45 < 0) {
    operator delete(a40);
  }
  _Unwind_Resume(exception_object);
}

void sub_1005ED61C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v67[0] = 0;
  v67[1] = 0;
  uint64_t v68 = 0;
  sub_10006891C((uint64_t)v57, a2);
  sub_1005EDEA4(v67, (uint64_t)v57);
  sub_10005CD90((uint64_t)v66, v66[1]);
  if (v65 < 0) {
    operator delete(__p);
  }
  if (v63 < 0) {
    operator delete(v62);
  }
  if (v61 < 0) {
    operator delete(v60);
  }
  if (v59 < 0) {
    operator delete(v58);
  }
  if ((void **)(a1 + 248) == sub_100046F68(a1 + 240, v67))
  {
    char v29 = *(NSObject **)(a1 + 64);
    if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
    {
      int v37 = (void **)v67[0];
      if (v68 >= 0) {
        int v37 = v67;
      }
      BOOL v38 = (void *)(a2 + 8);
      if (*(char *)(a2 + 31) < 0) {
        BOOL v38 = (void *)*v38;
      }
      unsigned int v39 = (void **)(a2 + 32);
      if (*(char *)(a2 + 55) < 0) {
        unsigned int v39 = (void **)*v39;
      }
      *(_DWORD *)long long buf = 136315650;
      *(void *)&uint8_t buf[4] = v37;
      __int16 v70 = 2080;
      char v71 = v38;
      __int16 v72 = 2080;
      unint64_t v73 = v39;
      _os_log_error_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_ERROR, "Profile not found for identifier [%s], removal failed for profile [%s, %s]", buf, 0x20u);
    }
    sub_100336E2C(a3, 0x100000001);
  }
  else
  {
    *(void *)long long buf = v67;
    if (*((unsigned char *)sub_1006028B8(a1 + 240, v67, (long long **)buf) + 160))
    {
      sub_100602A58((void ***)(a1 + 240), v67);
      sub_100058DB0(buf, "TempUpgradeIdentifier");
      uint64_t v6 = sub_100046F68(a1 + 240, (void **)buf);
      if (SHIBYTE(v72) < 0) {
        operator delete(*(void **)buf);
      }
      if ((void **)(a1 + 248) == v6)
      {
        uint64_t v34 = *(NSObject **)(a1 + 64);
        if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
        {
          uint64_t v35 = (void *)(a2 + 8);
          if (*(char *)(a2 + 31) < 0) {
            uint64_t v35 = (void *)*v35;
          }
          uint64_t v36 = (void *)(a2 + 32);
          if (*(char *)(a2 + 55) < 0) {
            uint64_t v36 = (void *)*v36;
          }
          *(_DWORD *)long long buf = 136315394;
          *(void *)&uint8_t buf[4] = v35;
          __int16 v70 = 2080;
          char v71 = v36;
          _os_log_error_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_ERROR, "Upgraded profile not found, upgrade failed for profile [%s, %s]. Removing this profile.", buf, 0x16u);
        }
      }
      else
      {
        sub_100058DB0(buf, "TempUpgradeIdentifier");
        uint64_t v7 = sub_10005DDEC(a1 + 240, (void **)buf);
        if (SHIBYTE(v72) < 0) {
          operator delete(*(void **)buf);
        }
        v55[0] = 0;
        v55[1] = 0;
        uint64_t v56 = 0;
        sub_10006891C((uint64_t)v45, v7);
        sub_1005EDEA4(v55, (uint64_t)v45);
        sub_10005CD90((uint64_t)v54, v54[1]);
        if (v53 < 0) {
          operator delete(v52);
        }
        if (v51 < 0) {
          operator delete(v50);
        }
        if (v49 < 0) {
          operator delete(v48);
        }
        if (v47 < 0) {
          operator delete(v46);
        }
        uint64_t v8 = *(NSObject **)(a1 + 64);
        if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
        {
          char v9 = (void *)(a2 + 8);
          if (*(char *)(a2 + 31) < 0) {
            char v9 = (void *)*v9;
          }
          uint64_t v10 = (void *)(a2 + 32);
          if (*(char *)(a2 + 55) < 0) {
            uint64_t v10 = (void *)*v10;
          }
          unsigned int v11 = v67;
          if (v68 < 0) {
            unsigned int v11 = (void **)v67[0];
          }
          uint64_t v12 = *(void *)(v7 + 8);
          if (*(char *)(v7 + 31) >= 0) {
            uint64_t v12 = v7 + 8;
          }
          uint64_t v13 = v7 + 32;
          if (*(char *)(v7 + 55) < 0) {
            uint64_t v13 = *(void *)(v7 + 32);
          }
          uint64_t v14 = v55;
          if (v56 < 0) {
            uint64_t v14 = (void **)v55[0];
          }
          *(_DWORD *)long long buf = 136316418;
          *(void *)&uint8_t buf[4] = v9;
          __int16 v70 = 2080;
          char v71 = v10;
          __int16 v72 = 2080;
          unint64_t v73 = v11;
          __int16 v74 = 2080;
          uint64_t v75 = v12;
          __int16 v76 = 2080;
          uint64_t v77 = v13;
          __int16 v78 = 2080;
          char v79 = v14;
          _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Upgrade profile [%s, %s, %s] to [%s, %s, %s] (name, version, identifier)", buf, 0x3Eu);
        }
        *(void *)long long buf = v55;
        char v15 = sub_1006028B8(a1 + 240, v55, (long long **)buf);
        *((_DWORD *)v15 + 14) = *(_DWORD *)v7;
        uint64_t v16 = (void **)(v15 + 8);
        if (*((char *)v15 + 87) < 0) {
          operator delete(*v16);
        }
        long long v17 = *(_OWORD *)(v7 + 8);
        v15[10] = *(void *)(v7 + 24);
        *(_OWORD *)uint64_t v16 = v17;
        *(unsigned char *)(v7 + 31) = 0;
        *(unsigned char *)(v7 + 8) = 0;
        char v18 = (void **)(v15 + 11);
        if (*((char *)v15 + 111) < 0) {
          operator delete(*v18);
        }
        long long v19 = *(_OWORD *)(v7 + 32);
        v15[13] = *(void *)(v7 + 48);
        *(_OWORD *)char v18 = v19;
        *(unsigned char *)(v7 + 55) = 0;
        *(unsigned char *)(v7 + 32) = 0;
        int v20 = (void **)(v15 + 14);
        if (*((char *)v15 + 135) < 0) {
          operator delete(*v20);
        }
        long long v21 = *(_OWORD *)(v7 + 56);
        uint8_t v15[16] = *(void *)(v7 + 72);
        *(_OWORD *)int v20 = v21;
        *(unsigned char *)(v7 + 79) = 0;
        *(unsigned char *)(v7 + 56) = 0;
        unint64_t v22 = (void **)(v15 + 17);
        if (*((char *)v15 + 159) < 0) {
          operator delete(*v22);
        }
        long long v23 = *(_OWORD *)(v7 + 80);
        v15[19] = *(void *)(v7 + 96);
        *(_OWORD *)unint64_t v22 = v23;
        *(unsigned char *)(v7 + 103) = 0;
        *(unsigned char *)(v7 + 80) = 0;
        int v25 = (void *)v15[22];
        unint64_t v24 = v15 + 22;
        *(v24 - 2) = *(void *)(v7 + 104);
        sub_10005CD90((uint64_t)(v24 - 1), v25);
        *(v24 - 1) = *(void *)(v7 + 112);
        long long v26 = (void *)(v7 + 120);
        uint64_t v27 = *(void *)(v7 + 120);
        *unint64_t v24 = v27;
        uint64_t v28 = *(void *)(v7 + 128);
        v24[1] = v28;
        if (v28)
        {
          *(void *)(v27 + 16) = v24;
          *(void *)(v7 + 112) = v26;
          void *v26 = 0;
          *(void *)(v7 + 128) = 0;
        }
        else
        {
          *(v24 - 1) = v24;
        }
        sub_100058DB0(buf, "TempUpgradeIdentifier");
        sub_100602A58((void ***)(a1 + 240), (void **)buf);
        if (SHIBYTE(v72) < 0) {
          operator delete(*(void **)buf);
        }
        if (SHIBYTE(v56) < 0) {
          operator delete(v55[0]);
        }
      }
    }
    else
    {
      uint64_t v30 = *(NSObject **)(a1 + 64);
      if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v31 = (void *)(a2 + 8);
        if (*(char *)(a2 + 31) < 0) {
          uint64_t v31 = (void *)*v31;
        }
        uint64_t v32 = (void *)(a2 + 32);
        if (*(char *)(a2 + 55) < 0) {
          uint64_t v32 = (void *)*v32;
        }
        uint64_t v33 = v67;
        if (v68 < 0) {
          uint64_t v33 = (void **)v67[0];
        }
        *(_DWORD *)long long buf = 136315650;
        *(void *)&uint8_t buf[4] = v31;
        __int16 v70 = 2080;
        char v71 = v32;
        __int16 v72 = 2080;
        unint64_t v73 = v33;
        _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "#I Removing profile [%s, %s] with identifier [%s]", buf, 0x20u);
      }
      sub_100602A58((void ***)(a1 + 240), v67);
    }
    sub_1005EDF84(a1);
    sub_1005EE984(a1);
    (*(void (**)(void))(**(void **)(a1 + 168) + 16))(*(void *)(a1 + 168));
    sub_1005EECFC(a1);
    sub_1005EEEF0(a1);
    sub_100058DB0(v40, "EvaluateAllIccids");
    if (SHIBYTE(v41) < 0)
    {
      sub_10004FC84(__dst, v40[0], (unint64_t)v40[1]);
    }
    else
    {
      *(_OWORD *)long long __dst = *(_OWORD *)v40;
      uint64_t v43 = v41;
    }
    int v44 = 9;
    sub_100007714(a1, (uint64_t *)__dst);
    if (SHIBYTE(v43) < 0) {
      operator delete(__dst[0]);
    }
    if (SHIBYTE(v41) < 0) {
      operator delete(v40[0]);
    }
    sub_100336E2C(a3, 0);
    sub_1005EF3A4(a1);
  }
  if (SHIBYTE(v68) < 0) {
    operator delete(v67[0]);
  }
}

void sub_1005EDCFC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,int a42,__int16 a43,char a44,char a45,char a46)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  if (*(char *)(v46 - 145) < 0) {
    operator delete(*(void **)(v46 - 168));
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1005EDDAC(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 216);
  uint64_t v2 = (void *)(a1 + 224);
  if (v1 == (void *)(a1 + 224)) {
    return 0;
  }
  while (1)
  {
    if (*((char *)v1 + 55) < 0)
    {
      sub_10004FC84(__p, (void *)v1[4], v1[5]);
    }
    else
    {
      *(_OWORD *)std::string __p = *((_OWORD *)v1 + 2);
      uint64_t v10 = v1[6];
    }
    uint64_t v4 = sub_1005F1348(a1, (long long *)__p);
    if (SHIBYTE(v10) < 0) {
      operator delete(__p[0]);
    }
    if (v4) {
      break;
    }
    uint64_t v5 = (void *)v1[1];
    if (v5)
    {
      do
      {
        uint64_t v6 = v5;
        uint64_t v5 = (void *)*v5;
      }
      while (v5);
    }
    else
    {
      do
      {
        uint64_t v6 = (void *)v1[2];
        BOOL v7 = *v6 == (void)v1;
        uint64_t v1 = v6;
      }
      while (!v7);
    }
    uint64_t v1 = v6;
    if (v6 == v2) {
      return v4;
    }
  }
  return 1;
}

void sub_1005EDE88(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1005EDEA4(void *a1, uint64_t a2)
{
  if (*(_DWORD *)a2 == 2)
  {
    sub_100058DB0(a1, "OffloadIdentifier");
  }
  else
  {
    __p[0] = 0;
    __p[1] = 0;
    uint64_t v5 = 0;
    sub_1002055B4((const void **)(a2 + 56), (const void **)(a2 + 80), __p);
    uint64_t v3 = (void *)HIBYTE(v5);
    if (v5 < 0) {
      uint64_t v3 = __p[1];
    }
    if (v3)
    {
      *(_OWORD *)a1 = *(_OWORD *)__p;
      a1[2] = v5;
    }
    else
    {
      sub_100058DB0(a1, "NoPnwIdentifier");
      if (SHIBYTE(v5) < 0) {
        operator delete(__p[0]);
      }
    }
  }
}

void sub_1005EDF68(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1005EDF84(uint64_t a1)
{
  int v49 = *(_DWORD *)(a1 + 304);
  *(_DWORD *)(a1 + 304) = 1;
  memset(&v57, 0, sizeof(v57));
  uint64_t isSimReady = (uint64_t)sub_100058DB0(&v57, "");
  uint64_t v3 = *(const std::string **)(a1 + 504);
  uint64_t v4 = *(const std::string **)(a1 + 512);
  if (v3 != v4)
  {
    unsigned int v5 = 0;
    do
    {
      uint64_t isSimReady = subscriber::isSimReady();
      if (isSimReady)
      {
        uint64_t isSimReady = (uint64_t)sub_100046F68(a1 + 216, (void **)&v3[3].__r_.__value_.__l.__data_);
        if (a1 + 224 != isSimReady)
        {
          *(void *)char v66 = v3 + 3;
          uint64_t isSimReady = (uint64_t)sub_100602C14(a1 + 216, (void **)&v3[3].__r_.__value_.__l.__data_, (long long **)v66);
          if (!*(unsigned char *)(isSimReady + 256))
          {
            uint64_t isSimReady = (uint64_t)std::string::operator=(&v57, v3 + 3);
            ++v5;
          }
        }
      }
      v3 += 7;
    }
    while (v3 != v4);
    if (v5 > 1)
    {
      *(_DWORD *)(a1 + 304) = 5;
      uint64_t v6 = *(NSObject **)(a1 + 64);
      uint64_t isSimReady = os_log_type_enabled(v6, OS_LOG_TYPE_ERROR);
      if (isSimReady)
      {
        *(_DWORD *)char v66 = 67109120;
        *(_DWORD *)&v66[4] = v5;
        _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "invalid macro SIMs count %d", v66, 8u);
      }
    }
  }
  BOOL v7 = (void ***)(a1 + 216);
  uint64_t v8 = *(void ***)(a1 + 216);
  char v9 = (void **)(a1 + 224);
  if (v8 == (void **)(a1 + 224)) {
    goto LABEL_90;
  }
  do
  {
    if (!*((unsigned char *)v8 + 256)) {
      goto LABEL_66;
    }
    *((_DWORD *)v8 + 15) = 1;
    long long v62 = 0uLL;
    uint64_t v63 = 0;
    if (*((char *)v8 + 55) < 0)
    {
      sub_10004FC84(__p, v8[4], (unint64_t)v8[5]);
    }
    else
    {
      *(_OWORD *)std::string __p = *((_OWORD *)v8 + 2);
      char v61 = v8[6];
    }
    sub_1005F0F5C((char **)&v62, a1, __p);
    if (SHIBYTE(v61) < 0) {
      operator delete(__p[0]);
    }
    if (SHIBYTE(v63) < 0)
    {
      sub_10004FC84(__s1, (void *)v62, *((unint64_t *)&v62 + 1));
    }
    else
    {
      *(_OWORD *)__s1 = v62;
      uint64_t v59 = v63;
    }
    uint64_t v10 = *v7;
    if (*v7 == v9)
    {
LABEL_57:
      int v22 = 0;
      goto LABEL_59;
    }
    int v11 = 0;
    while (!*((unsigned char *)v10 + 256))
    {
LABEL_51:
      long long v19 = (void **)v10[1];
      if (v19)
      {
        do
        {
          int v20 = v19;
          long long v19 = (void **)*v19;
        }
        while (v19);
      }
      else
      {
        do
        {
          int v20 = (void **)v10[2];
          BOOL v21 = *v20 == v10;
          uint64_t v10 = v20;
        }
        while (!v21);
      }
      uint64_t v10 = v20;
      if (v20 == v9) {
        goto LABEL_57;
      }
    }
    memset(v66, 0, sizeof(v66));
    uint64_t v67 = 0;
    if (*((char *)v10 + 55) < 0)
    {
      sub_10004FC84(buf, v10[4], (unint64_t)v10[5]);
    }
    else
    {
      *(_OWORD *)long long buf = *((_OWORD *)v10 + 2);
      char v65 = v10[6];
    }
    sub_1005F0F5C((char **)v66, a1, (void **)buf);
    if (SHIBYTE(v65) < 0) {
      operator delete(*(void **)buf);
    }
    uint64_t v12 = HIBYTE(v59);
    if (v59 >= 0) {
      uint64_t v13 = (void *)HIBYTE(v59);
    }
    else {
      uint64_t v13 = __s1[1];
    }
    uint64_t v14 = (void *)HIBYTE(v67);
    int v15 = SHIBYTE(v67);
    if (v67 < 0) {
      uint64_t v14 = *(void **)&v66[8];
    }
    if (v13 != v14) {
      goto LABEL_48;
    }
    if (v67 >= 0) {
      uint64_t v16 = v66;
    }
    else {
      uint64_t v16 = *(uint8_t **)v66;
    }
    if (v59 < 0)
    {
      if (memcmp(__s1[0], v16, (size_t)__s1[1])) {
        goto LABEL_48;
      }
    }
    else if (HIBYTE(v59))
    {
      long long v17 = __s1;
      while (*(unsigned __int8 *)v17 == *v16)
      {
        long long v17 = (void **)((char *)v17 + 1);
        ++v16;
        if (!--v12) {
          goto LABEL_45;
        }
      }
LABEL_48:
      int v18 = 1;
      if ((v15 & 0x80000000) == 0) {
        goto LABEL_50;
      }
      goto LABEL_49;
    }
LABEL_45:
    if (++v11 <= 1u) {
      goto LABEL_48;
    }
    int v18 = 0;
    if ((v15 & 0x80000000) == 0) {
      goto LABEL_50;
    }
LABEL_49:
    operator delete(*(void **)v66);
LABEL_50:
    if (v18) {
      goto LABEL_51;
    }
    int v22 = 1;
LABEL_59:
    if (SHIBYTE(v59) < 0)
    {
      operator delete(__s1[0]);
      if (v22) {
LABEL_61:
      }
        *((_DWORD *)v8 + 15) = 10;
    }
    else if (v22)
    {
      goto LABEL_61;
    }
    uint64_t isSimReady = (uint64_t)sub_100046F68(a1 + 240, (void **)&v62);
    if (a1 + 248 == isSimReady) {
      *((_DWORD *)v8 + 15) = 9;
    }
    if (SHIBYTE(v63) < 0) {
      operator delete((void *)v62);
    }
LABEL_66:
    long long v23 = (void **)v8[1];
    if (v23)
    {
      do
      {
        unint64_t v24 = v23;
        long long v23 = (void **)*v23;
      }
      while (v23);
    }
    else
    {
      do
      {
        unint64_t v24 = (void **)v8[2];
        BOOL v21 = *v24 == v8;
        uint64_t v8 = v24;
      }
      while (!v21);
    }
    uint64_t v8 = v24;
  }
  while (v24 != v9);
  int v25 = *v7;
  if (*v7 == v9)
  {
LABEL_90:
    *(_DWORD *)(a1 + 304) = 9;
    goto LABEL_91;
  }
  char v26 = 0;
  while (1)
  {
    if (*((char *)v25 + 55) < 0)
    {
      sub_10004FC84(__dst, v25[4], (unint64_t)v25[5]);
    }
    else
    {
      *(_OWORD *)long long __dst = *((_OWORD *)v25 + 2);
      uint64_t v56 = v25[6];
    }
    uint64_t isSimReady = sub_1005F06B8(a1, __dst);
    int v27 = isSimReady;
    if (SHIBYTE(v56) < 0) {
      operator delete(__dst[0]);
    }
    if (v27 == 1) {
      break;
    }
    uint64_t v28 = (void **)v25[1];
    if (v28)
    {
      do
      {
        char v29 = v28;
        uint64_t v28 = (void **)*v28;
      }
      while (v28);
    }
    else
    {
      do
      {
        char v29 = (void **)v25[2];
        BOOL v21 = *v29 == v25;
        int v25 = v29;
      }
      while (!v21);
    }
    v26 |= v27 == 1;
    int v25 = v29;
    if (v29 == v9)
    {
      if (v26) {
        break;
      }
      goto LABEL_90;
    }
  }
LABEL_91:
  if (!*(unsigned char *)(a1 + 385))
  {
    uint64_t v30 = *(NSObject **)(a1 + 64);
    if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)char v66 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_ERROR, "location services status unknown", v66, 2u);
    }
    int v31 = 7;
    goto LABEL_101;
  }
  if (!*(unsigned char *)(a1 + 384))
  {
    uint64_t v32 = *(NSObject **)(a1 + 64);
    if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)char v66 = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_ERROR, "location services are turned off", v66, 2u);
    }
    int v31 = 6;
LABEL_101:
    *(_DWORD *)(a1 + 304) = v31;
    goto LABEL_102;
  }
  if (*(_DWORD *)(a1 + 304) == 1) {
    goto LABEL_127;
  }
LABEL_102:
  memset(v66, 0, sizeof(v66));
  uint64_t v67 = 0;
  if (SHIBYTE(v57.__r_.__value_.__r.__words[2]) < 0) {
    sub_10004FC84(&v54, v57.__r_.__value_.__l.__data_, v57.__r_.__value_.__l.__size_);
  }
  else {
    std::string v54 = v57;
  }
  uint64_t isSimReady = (uint64_t)sub_1005F07F4((uint64_t)v66, a1, (void **)&v54.__r_.__value_.__l.__data_);
  if (SHIBYTE(v54.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v54.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v67) < 0)
  {
    if (!*(void *)&v66[8]) {
      goto LABEL_125;
    }
    sub_10004FC84(v52, *(void **)v66, *(unint64_t *)&v66[8]);
LABEL_112:
    uint64_t isSimReady = sub_1005F08AC(*(void *)(a1 + 504), *(void *)(a1 + 512), (uint64_t)v52);
    char v33 = isSimReady;
    if (SHIBYTE(v53) < 0)
    {
      operator delete(v52[0]);
      if ((v33 & 1) == 0) {
        goto LABEL_125;
      }
    }
    else if (!isSimReady)
    {
LABEL_125:
      if (SHIBYTE(v67) < 0) {
        operator delete(*(void **)v66);
      }
      goto LABEL_127;
    }
    uint64_t v34 = *(NSObject **)(a1 + 64);
    if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v35 = v66;
      if (v67 < 0) {
        uint64_t v35 = *(uint8_t **)v66;
      }
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = v35;
      _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "#I fDormantReason is not kNotDormant and not Invalid MacroCount but offload %s is active, turn it off", buf, 0xCu);
    }
    if (SHIBYTE(v67) < 0)
    {
      sub_10004FC84(v50, *(void **)v66, *(unint64_t *)&v66[8]);
    }
    else
    {
      *(_OWORD *)char v50 = *(_OWORD *)v66;
      uint64_t v51 = v67;
    }
    sub_1005F09D4(a1, (long long *)v50, 0);
    if (SHIBYTE(v51) < 0) {
      operator delete(v50[0]);
    }
    goto LABEL_125;
  }
  if (HIBYTE(v67))
  {
    *(_OWORD *)unint64_t v52 = *(_OWORD *)v66;
    uint64_t v53 = v67;
    goto LABEL_112;
  }
LABEL_127:
  if (capabilities::ct::supportsHydra((capabilities::ct *)isSimReady)) {
    goto LABEL_150;
  }
  uint64_t v36 = *(void *)(a1 + 528);
  uint64_t v37 = *(void *)(a1 + 536);
  if (v36 == v37)
  {
    int v38 = 0;
  }
  else
  {
    int v38 = 0;
    do
    {
      if (*(_DWORD *)v36 == 2 && *(unsigned char *)(v36 + 80))
      {
        uint64_t v39 = *(void *)(v36 + 56);
        uint64_t v40 = *(void *)(v36 + 64);
        while (v39 != v40)
        {
          if (v9 != sub_100046F68(a1 + 216, (void **)(v39 + 16)))
          {
            *(void *)char v66 = v39 + 16;
            v38 |= *((unsigned char *)sub_100602C14(a1 + 216, (void **)(v39 + 16), (long long **)v66) + 256) != 0;
          }
          v39 += 216;
        }
      }
      v36 += 88;
    }
    while (v36 != v37);
  }
  uint64_t v41 = *(void *)(a1 + 504);
  uint64_t v42 = *(void *)(a1 + 512);
  if (v41 == v42) {
    goto LABEL_150;
  }
  int v43 = 0;
  do
  {
    if (v9 != sub_100046F68(a1 + 216, (void **)(v41 + 72)))
    {
      *(void *)char v66 = v41 + 72;
      if (!*((unsigned char *)sub_100602C14(a1 + 216, (void **)(v41 + 72), (long long **)v66) + 256))
      {
        if (subscriber::isEsimCapable()) {
          v43 |= subscriber::isSimReady();
        }
      }
    }
    v41 += 168;
  }
  while (v41 != v42);
  if ((v38 & v43 & 1) == 0)
  {
LABEL_150:
    BOOL v45 = *(_DWORD *)(a1 + 304) == 1;
    *(unsigned char *)(a1 + 426) = v45;
    int v46 = !v45;
    if ((((v49 == 1) ^ v46) & 1) == 0)
    {
      uint64_t v44 = **(void **)(a1 + 104);
      if (v49 == 1)
      {
LABEL_155:
        (*(void (**)(void))(v44 + 48))();
        *(void *)(a1 + 312) = 0;
        *(void *)(a1 + 320) = 0;
        *(void *)(a1 + 328) = 0;
        char v47 = (void **)(a1 + 336);
        if (*(char *)(a1 + 359) < 0) {
          operator delete(*v47);
        }
        uint64_t v48 = (void **)(a1 + 360);
        *char v47 = 0;
        *(void *)(a1 + 344) = 0;
        *(void *)(a1 + 352) = 0;
        if (*(char *)(a1 + 383) < 0) {
          operator delete(*v48);
        }
        *uint64_t v48 = 0;
        *(void *)(a1 + 368) = 0;
        *(void *)(a1 + 376) = 0;
      }
      else
      {
        (*(void (**)(void))(**(void **)(a1 + 104) + 72))();
      }
    }
  }
  else
  {
    *(_DWORD *)(a1 + 304) = 8;
    *(unsigned char *)(a1 + 426) = 0;
    if (v49 == 1)
    {
      uint64_t v44 = **(void **)(a1 + 104);
      goto LABEL_155;
    }
  }
  sub_1005F0CCC(a1);
  if (SHIBYTE(v57.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v57.__r_.__value_.__l.__data_);
  }
}

void sub_1005EE87C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,int a27,__int16 a28,char a29,char a30,uint64_t a31,uint64_t a32,uint64_t a33,int a34,__int16 a35,char a36,char a37,void *a38,uint64_t a39,int a40,__int16 a41,char a42,char a43,void *a44,uint64_t a45,int a46,__int16 a47,char a48,char a49,uint64_t a50,char a51,uint64_t a52,int a53,__int16 a54,char a55,char a56)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  if (*(char *)(v56 - 105) < 0) {
    operator delete(*(void **)(v56 - 128));
  }
  if (a43 < 0) {
    operator delete(a38);
  }
  _Unwind_Resume(exception_object);
}

void sub_1005EE984(uint64_t a1)
{
  v22[0] = 0;
  v22[1] = 0;
  BOOL v21 = v22;
  v20[0] = 0;
  v20[1] = 0;
  long long v19 = v20;
  uint64_t v2 = *(void **)(a1 + 216);
  uint64_t v3 = (void *)(a1 + 224);
  if (v2 != (void *)(a1 + 224))
  {
    do
    {
      if (*((unsigned char *)v2 + 256))
      {
        long long v17 = 0uLL;
        uint64_t v18 = 0;
        if (*((char *)v2 + 55) < 0)
        {
          sub_10004FC84(__p, (void *)v2[4], v2[5]);
        }
        else
        {
          *(_OWORD *)std::string __p = *((_OWORD *)v2 + 2);
          uint64_t v16 = v2[6];
        }
        sub_1005F0F5C((char **)&v17, a1, __p);
        if (SHIBYTE(v16) < 0) {
          operator delete(__p[0]);
        }
        if (v22 == (char **)sub_100046F68((uint64_t)&v21, (void **)&v17)) {
          uint64_t v4 = &v21;
        }
        else {
          uint64_t v4 = &v19;
        }
        sub_100604120((uint64_t **)v4, (void **)&v17, (uint64_t)&v17);
        if (SHIBYTE(v18) < 0) {
          operator delete((void *)v17);
        }
      }
      unsigned int v5 = (void *)v2[1];
      if (v5)
      {
        do
        {
          uint64_t v6 = v5;
          unsigned int v5 = (void *)*v5;
        }
        while (v5);
      }
      else
      {
        do
        {
          uint64_t v6 = (void *)v2[2];
          BOOL v7 = *v6 == (void)v2;
          uint64_t v2 = v6;
        }
        while (!v7);
      }
      uint64_t v2 = v6;
    }
    while (v6 != v3);
    uint64_t v2 = *(void **)(a1 + 216);
  }
  if (v2 != v3)
  {
    char v8 = 0;
    do
    {
      if (*((unsigned char *)v2 + 256))
      {
        if (*((unsigned char *)v2 + 92)) {
          *((unsigned char *)v2 + 92) = 0;
        }
        sub_10005CD2C((uint64_t)(v2 + 8), (char *)v2[9]);
        v2[8] = v2 + 9;
        v2[9] = 0;
        v2[10] = 0;
        long long v17 = 0uLL;
        uint64_t v18 = 0;
        if (*((char *)v2 + 55) < 0)
        {
          sub_10004FC84(__dst, (void *)v2[4], v2[5]);
        }
        else
        {
          *(_OWORD *)long long __dst = *((_OWORD *)v2 + 2);
          uint64_t v14 = v2[6];
        }
        sub_1005F0F5C((char **)&v17, a1, __dst);
        if (SHIBYTE(v14) < 0) {
          operator delete(__dst[0]);
        }
        if ((void **)(a1 + 248) != sub_100046F68(a1 + 240, (void **)&v17)
          && v20 == (char **)sub_100046F68((uint64_t)&v19, (void **)&v17))
        {
          char v8 = 1;
          sub_1005F16E0(a1, (const std::string *)(v2 + 4), 1, &v17);
        }
        else
        {
          sub_100058DB0(v11, "");
          sub_1005F16E0(a1, (const std::string *)(v2 + 4), 0, (long long *)v11);
          if (v12 < 0) {
            operator delete(v11[0]);
          }
        }
        if (SHIBYTE(v18) < 0) {
          operator delete((void *)v17);
        }
      }
      char v9 = (void *)v2[1];
      if (v9)
      {
        do
        {
          uint64_t v10 = v9;
          char v9 = (void *)*v9;
        }
        while (v9);
      }
      else
      {
        do
        {
          uint64_t v10 = (void *)v2[2];
          BOOL v7 = *v10 == (void)v2;
          uint64_t v2 = v10;
        }
        while (!v7);
      }
      uint64_t v2 = v10;
    }
    while (v10 != v3);
    if (((*(_DWORD *)(a1 + 304) == 1) & v8) != 0) {
      (*(void (**)(void))(**(void **)(a1 + 104) + 72))(*(void *)(a1 + 104));
    }
  }
  sub_10005CD2C((uint64_t)&v19, v20[0]);
  sub_10005CD2C((uint64_t)&v21, v22[0]);
}

void sub_1005EEC70(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,uint64_t a29,void *__p,uint64_t a31,int a32,__int16 a33,char a34,char a35,char a36,char *a37)
{
  sub_10005CD2C((uint64_t)&a36, a37);
  sub_10005CD2C(v37 - 112, *(char **)(v37 - 104));
  _Unwind_Resume(a1);
}

void sub_1005EECFC(uint64_t a1)
{
  memset(&v14, 0, sizeof(v14));
  sub_1005F1284(&v14, a1);
  std::string::size_type size = HIBYTE(v14.__r_.__value_.__r.__words[2]);
  if ((v14.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
    std::string::size_type size = v14.__r_.__value_.__l.__size_;
  }
  if (!size)
  {
    LODWORD(v11) = 0;
    BYTE4(v11) = 0;
    sub_1005F2000(a1 + 608, (int *)&v11);
    goto LABEL_26;
  }
  if ((void **)(a1 + 224) == sub_100046F68(a1 + 216, (void **)&v14.__r_.__value_.__l.__data_)) {
    goto LABEL_26;
  }
  uint64_t v3 = (int *)sub_10005DDEC(a1 + 216, (void **)&v14.__r_.__value_.__l.__data_);
  int v11 = 0;
  uint64_t v12 = 0;
  uint64_t v13 = 0;
  if (SHIBYTE(v14.__r_.__value_.__r.__words[2]) < 0) {
    sub_10004FC84(&__p, v14.__r_.__value_.__l.__data_, v14.__r_.__value_.__l.__size_);
  }
  else {
    std::string __p = v14;
  }
  sub_1005F0F5C((char **)&v11, a1, (void **)&__p.__r_.__value_.__l.__data_);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  uint64_t v4 = HIBYTE(v13);
  if (v13 < 0) {
    uint64_t v4 = v12;
  }
  if (v4)
  {
    if ((void **)(a1 + 248) == sub_100046F68(a1 + 240, &v11))
    {
      int v6 = 0;
    }
    else
    {
      unsigned int v5 = (_DWORD *)sub_10005DDEC(a1 + 240, &v11);
      if (*v5 != 1) {
        goto LABEL_24;
      }
      int v6 = *v3;
      if (*v3)
      {
        int v7 = v5[27];
        LOBYTE(v4) = v7 == 2;
        if (!v7) {
          int v6 = 0;
        }
        goto LABEL_23;
      }
    }
    LOBYTE(v4) = 0;
  }
  else
  {
    int v6 = 0;
  }
LABEL_23:
  int v8 = v6;
  char v9 = v4;
  sub_1005F2000(a1 + 608, &v8);
LABEL_24:
  if (SHIBYTE(v13) < 0) {
    operator delete(v11);
  }
LABEL_26:
  if (SHIBYTE(v14.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v14.__r_.__value_.__l.__data_);
  }
}

void sub_1005EEE9C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  if (a23 < 0) {
    operator delete(__p);
  }
  if (*(char *)(v23 - 33) < 0) {
    operator delete(*(void **)(v23 - 56));
  }
  _Unwind_Resume(exception_object);
}

void sub_1005EEEF0(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 426) && *(_DWORD *)(a1 + 304) == 1 && !*(void *)(a1 + 288))
  {
    uint64_t v2 = *(std::__shared_weak_count **)(a1 + 96);
    if (v2)
    {
      uint64_t v3 = std::__shared_weak_count::lock(v2);
      if (v3)
      {
        uint64_t v4 = *(void *)(a1 + 88);
        if (v4)
        {
          memset(&v21, 0, sizeof(v21));
          sub_1005F1284(&v21, a1);
          if (SHIBYTE(v21.__r_.__value_.__r.__words[2]) < 0)
          {
            if (!v21.__r_.__value_.__l.__size_) {
              goto LABEL_52;
            }
            sub_10004FC84(&__p, v21.__r_.__value_.__l.__data_, v21.__r_.__value_.__l.__size_);
LABEL_17:
            int v6 = sub_1005F06B8(a1, (void **)&__p.__r_.__value_.__l.__data_);
            if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(__p.__r_.__value_.__l.__data_);
            }
            if (v6 != 1) {
              goto LABEL_52;
            }
            (*(void (**)(unsigned char *__return_ptr, uint64_t))(*(void *)v4 + 64))(buf, v4);
            BOOL v7 = sub_10001D294((unsigned __int8 *)&v21, buf);
            BOOL v8 = v7;
            if (v25 < 0) {
              operator delete(*(void **)buf);
            }
            if (v8)
            {
              *(unsigned char *)(a1 + 426) = 0;
              char v9 = *(NSObject **)(a1 + 64);
              if (!os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT)) {
                goto LABEL_52;
              }
              uint64_t v10 = &v21;
              if ((v21.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
                uint64_t v10 = (std::string *)v21.__r_.__value_.__r.__words[0];
              }
              *(_DWORD *)long long buf = 136315138;
              *(void *)&uint8_t buf[4] = v10;
              int v11 = "#I Permanent data switch already set to %s";
              goto LABEL_27;
            }
            if (capabilities::ct::supportsSimultaneousNRStandaloneInDualSIMMode((capabilities::ct *)v7))
            {
              if ((rest::WRMRecommendation::unknownSlot((rest::WRMRecommendation *)(a1 + 2524)) & 1) != 0
                || !sub_1005EC568(a1, *(_DWORD *)(a1 + 2524)))
              {
                goto LABEL_52;
              }
              if (rest::WRMRecommendation::activeCall((rest::WRMRecommendation *)(a1 + 2524))
                && ((sub_1005EDDAC(a1) & 1) != 0
                 || rest::WRMRecommendation::currentDataSlotQualityGood((rest::WRMRecommendation *)(a1 + 2524))))
              {
                char v9 = *(NSObject **)(a1 + 64);
                if (!os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
                {
LABEL_52:
                  if (SHIBYTE(v21.__r_.__value_.__r.__words[2]) < 0) {
                    operator delete(v21.__r_.__value_.__l.__data_);
                  }
                  goto LABEL_13;
                }
                uint64_t v12 = &v21;
                if ((v21.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
                  uint64_t v12 = (std::string *)v21.__r_.__value_.__r.__words[0];
                }
                *(_DWORD *)long long buf = 136315138;
                *(void *)&uint8_t buf[4] = v12;
                int v11 = "#I Call active, ignore data switch private network SIM %s";
LABEL_27:
                _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, v11, buf, 0xCu);
                goto LABEL_52;
              }
            }
            *(unsigned char *)(a1 + 426) = 0;
            uint64_t v13 = *(NSObject **)(a1 + 64);
            if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
            {
              std::string v14 = &v21;
              if ((v21.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
                std::string v14 = (std::string *)v21.__r_.__value_.__r.__words[0];
              }
              *(_DWORD *)long long buf = 136315138;
              *(void *)&uint8_t buf[4] = v14;
              _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I Initial permanent DDS to %s", buf, 0xCu);
            }
            if (SHIBYTE(v21.__r_.__value_.__r.__words[2]) < 0)
            {
              sub_10004FC84(&__dst, v21.__r_.__value_.__l.__data_, v21.__r_.__value_.__l.__size_);
              uint64_t v17 = a1;
              if (SHIBYTE(v21.__r_.__value_.__r.__words[2]) < 0)
              {
                sub_10004FC84(&v18, v21.__r_.__value_.__l.__data_, v21.__r_.__value_.__l.__size_);
                goto LABEL_48;
              }
            }
            else
            {
              std::string __dst = v21;
              uint64_t v17 = a1;
            }
            std::string v18 = v21;
LABEL_48:
            uint64_t v23 = 0;
            int v15 = operator new(0x28uLL);
            void *v15 = off_1019EE728;
            v15[1] = v17;
            long long v16 = *(_OWORD *)&v18.__r_.__value_.__l.__data_;
            void v15[4] = *((void *)&v18.__r_.__value_.__l + 2);
            *((_OWORD *)v15 + 1) = v16;
            memset(&v18, 0, sizeof(v18));
            uint64_t v23 = v15;
            (*(void (**)(uint64_t, std::string *, void, void *))(*(void *)v4 + 32))(v4, &__dst, 0, v22);
            sub_10023D374(v22);
            if (SHIBYTE(v18.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(v18.__r_.__value_.__l.__data_);
            }
            if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(__dst.__r_.__value_.__l.__data_);
            }
            goto LABEL_52;
          }
          if (*((unsigned char *)&v21.__r_.__value_.__s + 23))
          {
            std::string __p = v21;
            goto LABEL_17;
          }
LABEL_13:
          sub_10004D2C8(v3);
          return;
        }
      }
    }
    else
    {
      uint64_t v3 = 0;
    }
    unsigned int v5 = *(NSObject **)(a1 + 64);
    if (!os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      if (!v3) {
        return;
      }
      goto LABEL_13;
    }
    LOWORD(v21.__r_.__value_.__l.__data_) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "Invalid delegate in PrivateNetworkController", (uint8_t *)&v21, 2u);
    if (v3) {
      goto LABEL_13;
    }
  }
}

void sub_1005EF320(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,uint64_t a29,void *a30,uint64_t a31,int a32,__int16 a33,char a34,char a35)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a35 < 0) {
    operator delete(a30);
  }
  sub_10004D2C8(v35);
  _Unwind_Resume(a1);
}

void sub_1005EF3A4(uint64_t a1)
{
  v19[0] = 0;
  v19[1] = 0;
  std::string v18 = v19;
  uint64_t v2 = *(long long **)(a1 + 240);
  uint64_t v3 = (long long *)(a1 + 248);
  if (v2 != (long long *)(a1 + 248))
  {
    do
    {
      sub_100601430(__dst, v2 + 2, (uint64_t)v2 + 56);
      sub_100604CA0((uint64_t)&v18, __dst, (uint64_t)__dst);
      sub_10005CD90((uint64_t)v17, v17[1]);
      if (v16 < 0) {
        operator delete(__p);
      }
      if (v14 < 0) {
        operator delete(v13);
      }
      if (v12 < 0) {
        operator delete(v11);
      }
      if (v10 < 0) {
        operator delete(v9);
      }
      if (v8 < 0) {
        operator delete(__dst[0]);
      }
      uint64_t v4 = (long long *)*((void *)v2 + 1);
      if (v4)
      {
        do
        {
          unsigned int v5 = v4;
          uint64_t v4 = *(long long **)v4;
        }
        while (v4);
      }
      else
      {
        do
        {
          unsigned int v5 = (long long *)*((void *)v2 + 2);
          BOOL v6 = *(void *)v5 == (void)v2;
          uint64_t v2 = v5;
        }
        while (!v6);
      }
      uint64_t v2 = v5;
    }
    while (v5 != v3);
  }
  (*(void (**)(void, void ***))(**(void **)(a1 + 136) + 328))(*(void *)(a1 + 136), &v18);
  sub_100602520((uint64_t)&v18, v19[0]);
}

void sub_1005EF4F0(_Unwind_Exception *a1)
{
  sub_100602520(v1 - 56, *(void **)(v1 - 48));
  _Unwind_Resume(a1);
}

void sub_1005EF51C(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  v31[0] = 0;
  v31[1] = 0;
  uint64_t v32 = 0;
  sub_10006891C((uint64_t)&v21, a2);
  sub_1005EDEA4(v31, (uint64_t)&v21);
  sub_10005CD90((uint64_t)v30, v30[1]);
  if (v29 < 0) {
    operator delete(__p);
  }
  if (v27 < 0) {
    operator delete(v26);
  }
  if (v25 < 0) {
    operator delete(v24);
  }
  if (v23 < 0) {
    operator delete(v22);
  }
  char v8 = (void ***)(a1 + 240);
  char v9 = sub_100046F68(a1 + 240, v31);
  char v10 = (void **)(a1 + 248);
  int v11 = *(NSObject **)(a1 + 64);
  if (v10 == v9)
  {
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      uint64_t v17 = (void **)v31[0];
      if (v32 >= 0) {
        uint64_t v17 = v31;
      }
      std::string v18 = "True";
      if (!a3) {
        std::string v18 = "False";
      }
      long long v19 = (void *)(a2 + 8);
      if (*(char *)(a2 + 31) < 0) {
        long long v19 = (void *)*v19;
      }
      int v20 = (void **)(a2 + 32);
      if (*(char *)(a2 + 55) < 0) {
        int v20 = (void **)*v20;
      }
      *(_DWORD *)long long buf = 136315906;
      *(void *)&uint8_t buf[4] = v17;
      __int16 v34 = 2080;
      uint64_t v35 = v18;
      __int16 v36 = 2080;
      uint64_t v37 = v19;
      __int16 v38 = 2080;
      uint64_t v39 = v20;
      _os_log_error_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "Profile not found for identifier [%s], profile setAside [%s] failed for profile [%s, %s]", buf, 0x2Au);
    }
    sub_100336E2C(a4, 0x100000001);
  }
  else
  {
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      char v12 = "S";
      if (!a3) {
        char v12 = "Uns";
      }
      uint64_t v13 = (const char *)(a2 + 8);
      if (*(char *)(a2 + 31) < 0) {
        uint64_t v13 = *(const char **)v13;
      }
      char v14 = (void *)(a2 + 32);
      if (*(char *)(a2 + 55) < 0) {
        char v14 = (void *)*v14;
      }
      int v15 = v31;
      if (v32 < 0) {
        int v15 = (void **)v31[0];
      }
      *(_DWORD *)long long buf = 136315906;
      *(void *)&uint8_t buf[4] = v12;
      __int16 v34 = 2080;
      uint64_t v35 = v13;
      __int16 v36 = 2080;
      uint64_t v37 = v14;
      __int16 v38 = 2080;
      uint64_t v39 = v15;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I %setting aside profile [%s] version [%s] with identifier [%s]", buf, 0x2Au);
    }
    *(void *)long long buf = v31;
    *((unsigned char *)sub_1006028B8((uint64_t)v8, v31, (long long **)buf) + 160) = a3;
    if ((a3 & 1) == 0)
    {
      sub_100058DB0(buf, "TempUpgradeIdentifier");
      char v16 = sub_100046F68((uint64_t)v8, (void **)buf);
      if (SHIBYTE(v36) < 0) {
        operator delete(*(void **)buf);
      }
      if (v10 != v16)
      {
        sub_100058DB0(buf, "TempUpgradeIdentifier");
        sub_100602A58(v8, (void **)buf);
        if (SHIBYTE(v36) < 0) {
          operator delete(*(void **)buf);
        }
      }
    }
    sub_100336E2C(a4, 0);
  }
  if (SHIBYTE(v32) < 0) {
    operator delete(v31[0]);
  }
}

void sub_1005EF830(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,void *__p,uint64_t a27,int a28,__int16 a29,char a30,char a31)
{
  if (a31 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1005EF870(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unsigned int v5 = (std::string *)(a3 + 136);
  sub_1005EFFE8((void *)(a3 + 136));
  BOOL v6 = *(unsigned __int8 **)a2;
  unint64_t v7 = *(void *)(a2 + 8) - *(void *)a2;
  if (v7)
  {
    unsigned int v8 = (v7 - 1);
    if (v8 > 2)
    {
      int v12 = *v6;
      if (v12 == 160)
      {
        unsigned int v13 = v6[1];
        if (v7 >= (v13 + 1))
        {
          int v14 = v6[2];
          if (v14 == 128)
          {
            int v15 = v6[3];
            unsigned __int8 v16 = v15 + 5;
            uint64_t v17 = (v15 + 5) + 6;
            if (v8 < (v15 + 4) || v17 > v8)
            {
              char v9 = *(NSObject **)(a1 + 64);
              if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)long long buf = 67109120;
                *(_DWORD *)&uint8_t buf[4] = v8;
                char v10 = "Unexpected value file length [%d] when reading CSG file";
                goto LABEL_31;
              }
            }
            else
            {
              int v19 = v6[(v15 + 4)];
              if (v19 == 129)
              {
                unsigned int v20 = v6[(v15 + 5)];
                unsigned int v21 = v15 + v20 + 4;
                if (v20 <= 6 && v21 >= v13)
                {
                  *(void *)long long buf = 0;
                  uint64_t v56 = 0;
                  uint64_t v57 = 0;
                  char v23 = &v6[v16];
                  __str.__r_.__value_.__s.__data_[0] = v23[3];
                  *(_WORD *)((char *)&__str.__r_.__value_.__l.__data_ + 1) = *((_WORD *)v23 + 2);
                  __str.__r_.__value_.__s.__data_[3] = v6[v17];
                  sub_1003699B0(buf, &__str, 4uLL);
                  memset(&__str, 0, sizeof(__str));
                  sub_100058DB0(&__str, "");
                  unint64_t v24 = *(unsigned __int8 **)buf;
                  for (uint64_t i = v56; v24 != i; ++v24)
                  {
                    uint64_t v26 = 0;
                    unint64_t v27 = *v24;
                    char v50 = 0;
                    uint64_t v51 = 0x800000000000000;
                    uint64_t v28 = 7;
                    std::string __p = (void *)0x3030303030303030;
                    do
                    {
                      if ((v27 >> v26))
                      {
                        if (v51 >= 0) {
                          p_p = &__p;
                        }
                        else {
                          p_p = __p;
                        }
                        p_p[v28] = 49;
                      }
                      ++v26;
                      --v28;
                    }
                    while (v26 != 8);
                    if (v51 >= 0) {
                      uint64_t v30 = (const std::string::value_type *)&__p;
                    }
                    else {
                      uint64_t v30 = (const std::string::value_type *)__p;
                    }
                    if (v51 >= 0) {
                      std::string::size_type v31 = HIBYTE(v51);
                    }
                    else {
                      std::string::size_type v31 = (std::string::size_type)v50;
                    }
                    std::string::append(&__str, v30, v31);
                    if (SHIBYTE(v51) < 0) {
                      operator delete(__p);
                    }
                  }
                  std::string::size_type size = HIBYTE(__str.__r_.__value_.__r.__words[2]);
                  if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
                    std::string::size_type size = __str.__r_.__value_.__l.__size_;
                  }
                  std::string::erase(&__str, size - 5, 0xFFFFFFFFFFFFFFFFLL);
                  std::string::size_type v33 = HIBYTE(__str.__r_.__value_.__r.__words[2]);
                  if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
                    std::string::size_type v33 = __str.__r_.__value_.__l.__size_;
                  }
                  if (v33 == 27)
                  {
                    std::string __p = 0;
                    char v50 = 0;
                    uint64_t v51 = 0;
                    std::string::basic_string(&v48, &__str, 0, 3uLL, (std::allocator<char> *)v53);
                    char v34 = std::stoull(&v48, 0, 2);
                    sub_1005F003C((unint64_t *)&__p, v34);
                    if (SHIBYTE(v48.__r_.__value_.__r.__words[2]) < 0) {
                      operator delete(v48.__r_.__value_.__l.__data_);
                    }
                    std::string::basic_string(&v48, &__str, 3uLL, 8uLL, (std::allocator<char> *)v53);
                    char v35 = std::stoull(&v48, 0, 2);
                    sub_1005F003C((unint64_t *)&__p, v35);
                    if (SHIBYTE(v48.__r_.__value_.__r.__words[2]) < 0) {
                      operator delete(v48.__r_.__value_.__l.__data_);
                    }
                    std::string::basic_string(&v48, &__str, 0xBuLL, 8uLL, (std::allocator<char> *)v53);
                    char v36 = std::stoull(&v48, 0, 2);
                    sub_1005F003C((unint64_t *)&__p, v36);
                    if (SHIBYTE(v48.__r_.__value_.__r.__words[2]) < 0) {
                      operator delete(v48.__r_.__value_.__l.__data_);
                    }
                    std::string::basic_string(&v48, &__str, 0x13uLL, 8uLL, (std::allocator<char> *)v53);
                    char v37 = std::stoull(&v48, 0, 2);
                    sub_1005F003C((unint64_t *)&__p, v37);
                    if (SHIBYTE(v48.__r_.__value_.__r.__words[2]) < 0) {
                      operator delete(v48.__r_.__value_.__l.__data_);
                    }
                    memset(&v48, 0, sizeof(v48));
                    sub_100058DB0(&v48, "");
                    __int16 v38 = (char *)__p;
                    uint64_t v39 = v50;
                    if (__p != v50)
                    {
                      do
                      {
                        sub_1005F012C((uint64_t)v53);
                        if ((v54 & 0x80u) == 0) {
                          uint64_t v40 = v53;
                        }
                        else {
                          uint64_t v40 = *(const std::string::value_type **)v53;
                        }
                        if ((v54 & 0x80u) == 0) {
                          std::string::size_type v41 = v54;
                        }
                        else {
                          std::string::size_type v41 = *(void *)&v53[8];
                        }
                        std::string::append(&v48, v40, v41);
                        if ((char)v54 < 0) {
                          operator delete(*(void **)v53);
                        }
                        ++v38;
                      }
                      while (v38 != v39);
                    }
                    sub_100093B44(v5, &v48);
                    uint64_t v42 = *(NSObject **)(a1 + 64);
                    if (os_log_type_enabled(v42, OS_LOG_TYPE_DEFAULT))
                    {
                      int v43 = SHIBYTE(v48.__r_.__value_.__r.__words[2]);
                      std::string::size_type v44 = v48.__r_.__value_.__r.__words[0];
                      uint64_t v45 = subscriber::asString();
                      int v46 = &v48;
                      if (v43 < 0) {
                        int v46 = (std::string *)v44;
                      }
                      *(_DWORD *)uint64_t v53 = 136315394;
                      *(void *)&v53[4] = v46;
                      *(_WORD *)&v53[12] = 2080;
                      *(void *)&v53[14] = v45;
                      _os_log_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_DEFAULT, "#I Updated csg identifier [%s] for slot [%s]", v53, 0x16u);
                    }
                    if (SHIBYTE(v48.__r_.__value_.__r.__words[2]) < 0) {
                      operator delete(v48.__r_.__value_.__l.__data_);
                    }
                    if (__p)
                    {
                      char v50 = (char *)__p;
                      operator delete(__p);
                    }
                  }
                  else
                  {
                    char v47 = *(NSObject **)(a1 + 64);
                    if (os_log_type_enabled(v47, OS_LOG_TYPE_ERROR))
                    {
                      LOWORD(__p) = 0;
                      _os_log_error_impl((void *)&_mh_execute_header, v47, OS_LOG_TYPE_ERROR, "ACSGL conversion failed, csg length error", (uint8_t *)&__p, 2u);
                    }
                  }
                  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
                    operator delete(__str.__r_.__value_.__l.__data_);
                  }
                  if (*(void *)buf)
                  {
                    uint64_t v56 = *(unsigned __int8 **)buf;
                    operator delete(*(void **)buf);
                  }
                }
                else
                {
                  char v9 = *(NSObject **)(a1 + 64);
                  if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
                  {
                    *(_DWORD *)long long buf = 67109120;
                    *(_DWORD *)&uint8_t buf[4] = v20;
                    char v10 = "Unexpected value for CSG Information Length [%hhu]. File seems to contain more than 1 ACSGL entry.";
                    goto LABEL_31;
                  }
                }
              }
              else
              {
                char v9 = *(NSObject **)(a1 + 64);
                if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
                {
                  *(_DWORD *)long long buf = 67109120;
                  *(_DWORD *)&uint8_t buf[4] = v19;
                  char v10 = "Unexpected value for CSG Information Tag [%hhu]";
                  goto LABEL_31;
                }
              }
            }
          }
          else
          {
            char v9 = *(NSObject **)(a1 + 64);
            if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)long long buf = 67109120;
              *(_DWORD *)&uint8_t buf[4] = v14;
              char v10 = "Unexpected value for CSG PLMN Tag [%hhu]";
              goto LABEL_31;
            }
          }
        }
        else
        {
          char v9 = *(NSObject **)(a1 + 64);
          if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)long long buf = 67109120;
            *(_DWORD *)&uint8_t buf[4] = v13;
            char v10 = "Unexpected value for CSG Data Length [%hhu]";
            goto LABEL_31;
          }
        }
      }
      else
      {
        char v9 = *(NSObject **)(a1 + 64);
        if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)long long buf = 67109120;
          *(_DWORD *)&uint8_t buf[4] = v12;
          char v10 = "Unexpected value for CSG List Tag [%hhu]";
          goto LABEL_31;
        }
      }
    }
    else
    {
      char v9 = *(NSObject **)(a1 + 64);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 67109120;
        *(_DWORD *)&uint8_t buf[4] = v8;
        char v10 = "Unexpected value file length [%d] when reading CSG file";
LABEL_31:
        _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, v10, buf, 8u);
      }
    }
  }
  else
  {
    int v11 = *(NSObject **)(a1 + 64);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I Csg not populated on this sim", buf, 2u);
    }
  }
}

void sub_1005EFF28(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33,uint64_t a34,void *a35,uint64_t a36)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  if (a16) {
    operator delete(a16);
  }
  if (a27 < 0) {
    operator delete(a22);
  }
  if (a35) {
    operator delete(a35);
  }
  _Unwind_Resume(exception_object);
}

void *sub_1005EFFE8(void *result)
{
  if (*((unsigned char *)result + 24))
  {
    if (*((char *)result + 23) < 0)
    {
      result[1] = 0;
      uint64_t v1 = (unsigned char *)*result;
    }
    else
    {
      *((unsigned char *)result + 23) = 0;
      uint64_t v1 = result;
    }
    unsigned char *v1 = 0;
  }
  else
  {
    uint64_t result = sub_100058DB0(result, "");
    *((unsigned char *)result + 24) = 1;
  }
  return result;
}

void sub_1005F003C(unint64_t *a1, char a2)
{
  unsigned int v5 = (unsigned char *)a1[1];
  unint64_t v4 = a1[2];
  if ((unint64_t)v5 >= v4)
  {
    unint64_t v7 = *a1;
    unsigned int v8 = &v5[-*a1];
    unint64_t v9 = (unint64_t)(v8 + 1);
    if ((uint64_t)(v8 + 1) < 0) {
      sub_10006A748();
    }
    unint64_t v10 = v4 - v7;
    if (2 * v10 > v9) {
      unint64_t v9 = 2 * v10;
    }
    if (v10 >= 0x3FFFFFFFFFFFFFFFLL) {
      size_t v11 = 0x7FFFFFFFFFFFFFFFLL;
    }
    else {
      size_t v11 = v9;
    }
    if (v11) {
      unint64_t v12 = (unint64_t)operator new(v11);
    }
    else {
      unint64_t v12 = 0;
    }
    unsigned int v13 = (char *)(v12 + v11);
    v8[v12] = a2;
    uint64_t v6 = (uint64_t)&v8[v12 + 1];
    if (v5 == (unsigned char *)v7)
    {
      v12 += (unint64_t)v8;
    }
    else
    {
      int v14 = &v5[~v7];
      do
      {
        char v15 = *--v5;
        (v14--)[v12] = v15;
      }
      while (v5 != (unsigned char *)v7);
      unsigned int v5 = (unsigned char *)*a1;
    }
    *a1 = v12;
    a1[1] = v6;
    a1[2] = (unint64_t)v13;
    if (v5) {
      operator delete(v5);
    }
  }
  else
  {
    unsigned char *v5 = a2;
    uint64_t v6 = (uint64_t)(v5 + 1);
  }
  a1[1] = v6;
}

uint64_t sub_1005F012C(uint64_t a1)
{
  uint64_t v25 = 0;
  long long v23 = 0u;
  long long v24 = 0u;
  long long v21 = 0u;
  long long v22 = 0u;
  long long v19 = 0u;
  long long v20 = 0u;
  long long v17 = 0u;
  long long v18 = 0u;
  long long v16 = 0u;
  long long v14 = 0u;
  long long v15 = 0u;
  *(_OWORD *)std::string __p = 0u;
  long long v11 = 0u;
  memset(v12, 0, sizeof(v12));
  sub_10004BD84((uint64_t)&v11);
  *(_DWORD *)((char *)v12 + *(void *)(*(void *)&v12[0] - 24) + 8) = *(_DWORD *)((unsigned char *)v12
                                                                                    + *(void *)(*(void *)&v12[0]
                                                                                                - 24)
                                                                                    + 8) & 0xFFFFFFB5 | 8;
  LOBYTE(v10.__locale_) = 48;
  uint64_t v2 = sub_1004DC904(v12, (char *)&v10);
  *(void *)((char *)v2 + *(void *)(*v2 - 24) + 24) = 2;
  std::ostream::operator<<();
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  sub_10004BC98((uint64_t)v12 + 8, (void *)a1);
  std::locale::locale(&v10);
  int v3 = *(char *)(a1 + 23);
  if (v3 >= 0) {
    unint64_t v4 = (char *)a1;
  }
  else {
    unint64_t v4 = *(char **)a1;
  }
  if (v3 >= 0) {
    uint64_t v5 = *(unsigned __int8 *)(a1 + 23);
  }
  else {
    uint64_t v5 = *(void *)(a1 + 8);
  }
  for (; v5; --v5)
  {
    char v6 = *v4;
    unint64_t v7 = std::locale::use_facet(&v10, &std::ctype<char>::id);
    *v4++ = ((uint64_t (*)(const std::locale::facet *, void))v7->__vftable[1].~facet)(v7, v6);
  }
  std::locale::~locale(&v10);
  *(void *)((char *)&v12[-1]
  *(void *)&v12[0] = v8;
  if (SHIBYTE(v14) < 0) {
    operator delete(__p[1]);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return std::ios::~ios();
}

void sub_1005F03B4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::locale a10, char a11)
{
}

void sub_1005F03F0(uint64_t a1, unsigned __int8 **a2, std::string *a3)
{
  uint64_t v5 = a3 + 7;
  sub_1005EFFE8(a3[7].__r_.__value_.__r.__words);
  char v6 = a2[1];
  std::string::size_type v7 = v6 - *a2;
  if (v6 != *a2)
  {
    unsigned int v8 = **a2;
    if (v8 >= 3)
    {
      long long v18 = *(NSObject **)(a1 + 64);
      if (!os_log_type_enabled(v18, OS_LOG_TYPE_ERROR)) {
        return;
      }
      LODWORD(v25.__r_.__value_.__l.__data_) = 67109120;
      HIDWORD(v25.__r_.__value_.__r.__words[0]) = v8;
      long long v19 = "NID data error, unknown assignment mode [%d]";
      long long v20 = v18;
      uint32_t v21 = 8;
    }
    else
    {
      if (v7 == 6)
      {
        memset(&v25, 0, sizeof(v25));
        sub_100058DB0(&v25, "");
        if ((unint64_t)(a2[1] - *a2) >= 2)
        {
          int v9 = 1;
          do
          {
            sub_1005F012C((uint64_t)__p);
            if ((v24 & 0x80u) == 0) {
              std::locale v10 = __p;
            }
            else {
              std::locale v10 = *(const std::string::value_type **)__p;
            }
            if ((v24 & 0x80u) == 0) {
              std::string::size_type v11 = v24;
            }
            else {
              std::string::size_type v11 = *(void *)&__p[8];
            }
            std::string::append(&v25, v10, v11);
            if ((char)v24 < 0) {
              operator delete(*(void **)__p);
            }
            ++v9;
          }
          while (a2[1] - *a2 > (unint64_t)v9);
        }
        sub_100093B44(v5, &v25);
        unint64_t v12 = *(NSObject **)(a1 + 64);
        if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
        {
          int v13 = SHIBYTE(v25.__r_.__value_.__r.__words[2]);
          std::string::size_type v14 = v25.__r_.__value_.__r.__words[0];
          uint64_t v15 = subscriber::asString();
          long long v16 = &v25;
          if (v13 < 0) {
            long long v16 = (std::string *)v14;
          }
          *(_DWORD *)std::string __p = 136315394;
          *(void *)&__p[4] = v16;
          *(_WORD *)&unsigned char __p[12] = 2080;
          *(void *)&__p[14] = v15;
          _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I Updated nid identifier [%s] for slot [%s]", __p, 0x16u);
        }
        if (SHIBYTE(v25.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v25.__r_.__value_.__l.__data_);
        }
        return;
      }
      long long v22 = *(NSObject **)(a1 + 64);
      if (!os_log_type_enabled(v22, OS_LOG_TYPE_ERROR)) {
        return;
      }
      LODWORD(v25.__r_.__value_.__l.__data_) = 134217984;
      *(std::string::size_type *)((char *)v25.__r_.__value_.__r.__words + 4) = v7;
      long long v19 = "NID data error, data length does not match spec [%lu]";
      long long v20 = v22;
      uint32_t v21 = 12;
    }
    _os_log_error_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, v19, (uint8_t *)&v25, v21);
    return;
  }
  long long v17 = *(NSObject **)(a1 + 64);
  if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v25.__r_.__value_.__l.__data_) = 0;
    _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I Nid not populated on this sim", (uint8_t *)&v25, 2u);
  }
}

void sub_1005F0674(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1005F06B8(uint64_t a1, void **a2)
{
  uint64_t v2 = *(unsigned int *)(a1 + 304);
  if (v2 == 1)
  {
    int v3 = a2;
    uint64_t v5 = a1 + 216;
    if ((void **)(a1 + 224) == sub_100046F68(a1 + 216, a2))
    {
      std::string::size_type v7 = *(NSObject **)(a1 + 64);
      if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
      {
        if (*((char *)v3 + 23) < 0) {
          int v3 = (void **)*v3;
        }
        LODWORD(v9[0]) = 136315138;
        *(void *)((char *)v9 + 4) = v3;
        _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "Unexpected iccid [%s]", (uint8_t *)v9, 0xCu);
      }
      return 0;
    }
    else
    {
      memset(v9, 0, sizeof(v9));
      uint64_t v6 = sub_10005DDEC(v5, v3);
      sub_100059120((uint64_t)v9, v6);
      uint64_t v2 = DWORD1(v9[0]);
      sub_10006544C((uint64_t)v9);
    }
  }
  return v2;
}

void **sub_1005F07F4(uint64_t a1, uint64_t a2, void **a3)
{
  uint64_t v5 = a2 + 584;
  if (sub_10010E128(a2 + 584, a3))
  {
    uint64_t result = (void **)sub_10005DDEC(v5, a3);
    if (*((char *)result + 23) < 0)
    {
      unsigned int v8 = *result;
      unint64_t v9 = (unint64_t)result[1];
      return (void **)sub_10004FC84((unsigned char *)a1, v8, v9);
    }
    else
    {
      long long v7 = *(_OWORD *)result;
      *(void *)(a1 + 16) = result[2];
      *(_OWORD *)a1 = v7;
    }
  }
  else
  {
    return (void **)sub_100058DB0((void *)a1, "");
  }
  return result;
}

uint64_t sub_1005F08AC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(char *)(a3 + 23) < 0)
  {
    sub_10004FC84(__s1, *(void **)a3, *(void *)(a3 + 8));
  }
  else
  {
    *(_OWORD *)__s1 = *(_OWORD *)a3;
    uint64_t v14 = *(void *)(a3 + 16);
  }
  while (1)
  {
    if (a1 == a2)
    {
      uint64_t v11 = 0;
      goto LABEL_24;
    }
    uint64_t v5 = HIBYTE(v14);
    if (v14 >= 0) {
      uint64_t v6 = (void *)HIBYTE(v14);
    }
    else {
      uint64_t v6 = __s1[1];
    }
    long long v7 = (void *)*(unsigned __int8 *)(a1 + 95);
    int v8 = (char)v7;
    if ((char)v7 < 0) {
      long long v7 = *(void **)(a1 + 80);
    }
    if (v6 != v7) {
      goto LABEL_21;
    }
    unint64_t v9 = v8 >= 0 ? (unsigned __int8 *)(a1 + 72) : *(unsigned __int8 **)(a1 + 72);
    if (v14 < 0) {
      break;
    }
    if (!HIBYTE(v14)) {
      goto LABEL_20;
    }
    std::locale v10 = __s1;
    while (*(unsigned __int8 *)v10 == *v9)
    {
      std::locale v10 = (void **)((char *)v10 + 1);
      ++v9;
      if (!--v5) {
        goto LABEL_20;
      }
    }
LABEL_21:
    a1 += 168;
  }
  if (memcmp(__s1[0], v9, (size_t)__s1[1])) {
    goto LABEL_21;
  }
LABEL_20:
  if ((subscriber::isSimReady() & 1) == 0) {
    goto LABEL_21;
  }
  uint64_t v11 = 1;
LABEL_24:
  if (SHIBYTE(v14) < 0) {
    operator delete(__s1[0]);
  }
  return v11;
}

void sub_1005F09B8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1005F09D4(uint64_t a1, long long *a2, uint64_t a3)
{
  unint64_t v4 = *(std::__shared_weak_count **)(a1 + 96);
  if (v4)
  {
    long long v7 = std::__shared_weak_count::lock(v4);
    if (v7)
    {
      int v8 = v7;
      uint64_t v9 = *(void *)(a1 + 88);
      if (v9)
      {
        if (*(unsigned char *)(a1 + 427))
        {
          std::locale v10 = *(NSObject **)(a1 + 64);
          if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v11 = "disable";
            if (a3) {
              uint64_t v11 = "enable";
            }
            if (*((char *)a2 + 23) < 0) {
              a2 = *(long long **)a2;
            }
            *(_DWORD *)long long buf = 136315394;
            *(void *)&uint8_t buf[4] = v11;
            __int16 v27 = 2080;
            uint64_t v28 = a2;
            _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I in purchase flow. delay %s %s", buf, 0x16u);
          }
          goto LABEL_13;
        }
        *(unsigned char *)(a1 + 426) = a3;
        if ((*(unsigned int (**)(uint64_t, long long *, uint64_t))(*(void *)v9 + 40))(v9, a2, a3))
        {
          unint64_t v12 = *(NSObject **)(a1 + 64);
          if (!os_log_type_enabled(v12, OS_LOG_TYPE_ERROR)) {
            goto LABEL_13;
          }
          if (*((char *)a2 + 23) < 0) {
            a2 = *(long long **)a2;
          }
          uint64_t v21 = asString();
          long long v22 = "disable";
          *(_DWORD *)long long buf = 136315650;
          if (a3) {
            long long v22 = "enable";
          }
          *(void *)&uint8_t buf[4] = v22;
          __int16 v27 = 2080;
          uint64_t v28 = a2;
          __int16 v29 = 2080;
          uint64_t v30 = v21;
          long long v18 = "Private network %s iccid %s failed with error %s";
          long long v19 = v12;
          uint32_t v20 = 32;
LABEL_28:
          _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, v18, buf, v20);
          goto LABEL_13;
        }
        uint64_t v13 = a1 + 216;
        if ((void **)(a1 + 224) != sub_100046F68(a1 + 216, (void **)a2))
        {
          uint64_t v14 = *(void *)(a1 + 152);
          sub_100058DB0(buf, "");
          uint64_t v24 = 0;
          std::string v25 = a2;
          char v23 = 0;
          uint64_t v15 = sub_100602C14(v13, (void **)a2, &v25);
          (*(void (**)(uint64_t, void, unsigned char *, uint64_t *, char *, void))(*(void *)v14 + 40))(v14, a3 ^ 1, buf, &v24, &v23, *((unsigned int *)v15 + 14));
          if (SHIBYTE(v29) < 0) {
            operator delete(*(void **)buf);
          }
          goto LABEL_13;
        }
        long long v16 = *(NSObject **)(a1 + 64);
        if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
        {
          if (*((char *)a2 + 23) >= 0) {
            long long v17 = a2;
          }
          else {
            long long v17 = *(long long **)a2;
          }
          *(_DWORD *)long long buf = 136315138;
          *(void *)&uint8_t buf[4] = v17;
          long long v18 = "SIM matching to iccid %s not found";
          long long v19 = v16;
          uint32_t v20 = 12;
          goto LABEL_28;
        }
      }
LABEL_13:
      sub_10004D2C8(v8);
    }
  }
}

void sub_1005F0C9C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  sub_10004D2C8(v18);
  _Unwind_Resume(a1);
}

void sub_1005F0CCC(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 216);
  if (v2 == (void *)(a1 + 224))
  {
    unsigned int v4 = 0;
  }
  else
  {
    do
    {
      if (*((unsigned char *)v2 + 256)) {
        BOOL v3 = *((unsigned char *)v2 + 257) == 0;
      }
      else {
        BOOL v3 = 1;
      }
      unsigned int v4 = !v3;
      if (!v3) {
        break;
      }
      uint64_t v5 = (void *)v2[1];
      if (v5)
      {
        do
        {
          uint64_t v6 = v5;
          uint64_t v5 = (void *)*v5;
        }
        while (v5);
      }
      else
      {
        do
        {
          uint64_t v6 = (void *)v2[2];
          BOOL v3 = *v6 == (void)v2;
          uint64_t v2 = v6;
        }
        while (!v3);
      }
      uint64_t v2 = v6;
    }
    while (v6 != (void *)(a1 + 224));
  }
  uint64_t v7 = *(int *)(a1 + 304);
  if (v7 == 1)
  {
    if (*(void *)(a1 + 288)) {
      uint64_t v8 = 0;
    }
    else {
      uint64_t v8 = v4;
    }
  }
  else
  {
    uint64_t v8 = 0;
  }
  uint64_t v9 = *(NSObject **)(a1 + 64);
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    std::locale v10 = "False";
    if (v8) {
      uint64_t v11 = "True";
    }
    else {
      uint64_t v11 = "False";
    }
    if (*(unsigned char *)(a1 + 680)) {
      unint64_t v12 = "True";
    }
    else {
      unint64_t v12 = "False";
    }
    if (v7 > 0xA) {
      uint64_t v13 = "???";
    }
    else {
      uint64_t v13 = off_1019EE958[v7];
    }
    uint64_t v14 = *(void *)(a1 + 288);
    int v21 = 136316162;
    if (v14) {
      uint64_t v15 = "yes";
    }
    else {
      uint64_t v15 = "no";
    }
    long long v22 = v11;
    __int16 v23 = 2080;
    if (v4) {
      std::locale v10 = "True";
    }
    uint64_t v24 = v12;
    __int16 v25 = 2080;
    uint64_t v26 = v13;
    __int16 v27 = 2080;
    uint64_t v28 = v15;
    __int16 v29 = 2080;
    uint64_t v30 = v10;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I private network mode current, previous (%s, %s), dormantReason %s, dynamicDataSwitchWait %s, automaticToggle %s", (uint8_t *)&v21, 0x34u);
  }
  if (*(unsigned __int8 *)(a1 + 680) != v8)
  {
    *(unsigned char *)(a1 + 680) = v8;
    uint64_t v16 = *(void *)(a1 + 672);
    if (v16) {
      (*(void (**)(uint64_t, uint64_t))(*(void *)v16 + 48))(v16, a1 + 680);
    }
    (*(void (**)(void, uint64_t))(**(void **)(a1 + 168) + 32))(*(void *)(a1 + 168), v8);
    long long v17 = *(std::__shared_weak_count **)(a1 + 96);
    if (v17)
    {
      long long v18 = std::__shared_weak_count::lock(v17);
      if (v18)
      {
        long long v19 = v18;
        uint64_t v20 = *(void *)(a1 + 88);
        if (v20) {
          (*(void (**)(uint64_t))(*(void *)v20 + 48))(v20);
        }
        sub_10004D2C8(v19);
      }
    }
  }
}

void sub_1005F0F40(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

void *sub_1005F0F5C(char **a1, uint64_t a2, void **a3)
{
  BOOL v3 = a3;
  uint64_t v6 = a2 + 216;
  if ((void **)(a2 + 224) == sub_100046F68(a2 + 216, a3))
  {
    return sub_100058DB0(a1, "");
  }
  else
  {
    long long v39 = 0u;
    long long v40 = 0u;
    long long v37 = 0u;
    long long v38 = 0u;
    long long v35 = 0u;
    long long v36 = 0u;
    long long v33 = 0u;
    long long v34 = 0u;
    long long v31 = 0u;
    long long v32 = 0u;
    memset(v30, 0, sizeof(v30));
    uint64_t v7 = sub_10005DDEC(v6, v3);
    sub_100059120((uint64_t)v30, v7);
    if (BYTE8(v31))
    {
      *a1 = 0;
      a1[1] = 0;
      a1[2] = 0;
      sub_100464AE4((void *)&v30[8] + 1, "", &v29);
      sub_100464AE4((void *)&v30[10] + 1, "", __p);
      if ((v28 & 0x80u) == 0) {
        uint64_t v8 = __p;
      }
      else {
        uint64_t v8 = (void **)__p[0];
      }
      if ((v28 & 0x80u) == 0) {
        std::string::size_type v9 = v28;
      }
      else {
        std::string::size_type v9 = (std::string::size_type)__p[1];
      }
      std::locale v10 = std::string::append(&v29, (const std::string::value_type *)v8, v9);
      long long v11 = *(_OWORD *)&v10->__r_.__value_.__l.__data_;
      a1[2] = (char *)v10->__r_.__value_.__r.__words[2];
      *(_OWORD *)a1 = v11;
      v10->__r_.__value_.__l.__size_ = 0;
      v10->__r_.__value_.__r.__words[2] = 0;
      v10->__r_.__value_.__r.__words[0] = 0;
      if ((char)v28 < 0) {
        operator delete(__p[0]);
      }
      if (SHIBYTE(v29.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v29.__r_.__value_.__l.__data_);
      }
      unint64_t v12 = *(void **)(a2 + 584);
      uint64_t v13 = (void *)(a2 + 592);
      if (v12 != v13)
      {
        char v14 = *((unsigned char *)v3 + 23);
        if (v14 >= 0) {
          uint64_t v15 = (void *)*((unsigned __int8 *)v3 + 23);
        }
        else {
          uint64_t v15 = v3[1];
        }
        if (v14 < 0) {
          BOOL v3 = (void **)*v3;
        }
        do
        {
          uint64_t v16 = *((unsigned __int8 *)v12 + 79);
          if ((v16 & 0x80u) == 0) {
            long long v17 = (void *)*((unsigned __int8 *)v12 + 79);
          }
          else {
            long long v17 = (void *)v12[8];
          }
          if (v17 == v15)
          {
            long long v18 = (const void **)(v12 + 7);
            if ((v16 & 0x80) != 0)
            {
              if (!memcmp(*v18, v3, v12[8]))
              {
LABEL_41:
                if (*((char *)a1 + 23) < 0)
                {
                  a1[1] = (char *)17;
                  uint64_t v24 = *a1;
                }
                else
                {
                  *((unsigned char *)a1 + 23) = 17;
                  uint64_t v24 = (char *)a1;
                }
                strcpy(v24, "OffloadIdentifier");
                break;
              }
            }
            else
            {
              if (!*((unsigned char *)v12 + 79)) {
                goto LABEL_41;
              }
              long long v19 = v3;
              while (*(unsigned __int8 *)v18 == *(unsigned __int8 *)v19)
              {
                long long v18 = (const void **)((char *)v18 + 1);
                long long v19 = (void **)((char *)v19 + 1);
                if (!--v16) {
                  goto LABEL_41;
                }
              }
            }
          }
          uint64_t v20 = (void *)v12[1];
          if (v20)
          {
            do
            {
              int v21 = v20;
              uint64_t v20 = (void *)*v20;
            }
            while (v20);
          }
          else
          {
            do
            {
              int v21 = (void *)v12[2];
              BOOL v22 = *v21 == (void)v12;
              unint64_t v12 = v21;
            }
            while (!v22);
          }
          unint64_t v12 = v21;
        }
        while (v21 != v13);
      }
      __int16 v25 = (char *)*((unsigned __int8 *)a1 + 23);
      int v26 = (char)v25;
      if ((char)v25 < 0) {
        __int16 v25 = a1[1];
      }
      if (!v25)
      {
        if (v26 < 0)
        {
          a1[1] = (char *)15;
          a1 = (char **)*a1;
        }
        else
        {
          *((unsigned char *)a1 + 23) = 15;
        }
        strcpy((char *)a1, "NoPnwIdentifier");
      }
    }
    else
    {
      sub_100058DB0(a1, "");
    }
    return (void *)sub_10006544C((uint64_t)v30);
  }
}

void sub_1005F123C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,char a21)
{
}

std::string *sub_1005F1284(std::string *a1, uint64_t a2)
{
  a1->__r_.__value_.__r.__words[0] = 0;
  a1->__r_.__value_.__l.__size_ = 0;
  a1->__r_.__value_.__r.__words[2] = 0;
  uint64_t result = (std::string *)sub_100058DB0(a1, "");
  uint64_t v5 = *(const std::string **)(a2 + 504);
  uint64_t v6 = *(const std::string **)(a2 + 512);
  if (v5 != v6)
  {
    uint64_t v7 = a2 + 216;
    uint64_t v8 = (std::string *)(a2 + 224);
    while (1)
    {
      uint64_t result = (std::string *)subscriber::isSimReady();
      if (result)
      {
        uint64_t result = (std::string *)sub_100046F68(v7, (void **)&v5[3].__r_.__value_.__l.__data_);
        if (v8 != result)
        {
          if (result[10].__r_.__value_.__s.__data_[16]) {
            break;
          }
        }
      }
      v5 += 7;
      if (v5 == v6) {
        return result;
      }
    }
    return std::string::operator=(a1, v5 + 3);
  }
  return result;
}

void sub_1005F1324(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1005F1348(uint64_t a1, long long *a2)
{
  uint64_t v2 = *(void **)(a1 + 584);
  BOOL v3 = (void *)(a1 + 592);
  if (*((char *)a2 + 23) < 0)
  {
    sub_10004FC84(&__p, *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long __p = *a2;
    uint64_t v16 = *((void *)a2 + 2);
  }
  if (v2 == v3)
  {
LABEL_27:
    uint64_t v12 = 0;
    goto LABEL_28;
  }
  while (1)
  {
    uint64_t v4 = *((unsigned __int8 *)v2 + 79);
    if ((v4 & 0x80u) == 0) {
      uint64_t v5 = *((unsigned __int8 *)v2 + 79);
    }
    else {
      uint64_t v5 = v2[8];
    }
    uint64_t v6 = HIBYTE(v16);
    if (v16 < 0) {
      uint64_t v6 = *((void *)&__p + 1);
    }
    if (v5 != v6) {
      goto LABEL_21;
    }
    uint64_t v7 = (const void **)(v2 + 7);
    uint64_t v8 = v16 >= 0 ? (unsigned __int8 *)&__p : (unsigned __int8 *)__p;
    if ((v4 & 0x80) == 0) {
      break;
    }
    if (!memcmp(*v7, v8, v2[8])) {
      goto LABEL_20;
    }
LABEL_21:
    std::string::size_type v9 = (void *)v2[1];
    if (v9)
    {
      do
      {
        std::locale v10 = v9;
        std::string::size_type v9 = (void *)*v9;
      }
      while (v9);
    }
    else
    {
      do
      {
        std::locale v10 = (void *)v2[2];
        BOOL v11 = *v10 == (void)v2;
        uint64_t v2 = v10;
      }
      while (!v11);
    }
    uint64_t v2 = v10;
    if (v10 == v3) {
      goto LABEL_27;
    }
  }
  if (*((unsigned char *)v2 + 79))
  {
    while (*(unsigned __int8 *)v7 == *v8)
    {
      uint64_t v7 = (const void **)((char *)v7 + 1);
      ++v8;
      if (!--v4) {
        goto LABEL_20;
      }
    }
    goto LABEL_21;
  }
LABEL_20:
  if ((sub_1005FB4A8(a1, (uint64_t)(v2 + 4)) & 1) == 0) {
    goto LABEL_21;
  }
  uint64_t v12 = 1;
LABEL_28:
  if (SHIBYTE(v16) < 0) {
    operator delete((void *)__p);
  }
  return v12;
}

void sub_1005F149C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

std::string *sub_1005F14B8(std::string *this, uint64_t a2, unsigned __int8 *a3)
{
  *(_OWORD *)&this->__r_.__value_.__l.__data_ = 0uLL;
  this->__r_.__value_.__r.__words[2] = 0;
  BOOL v3 = *(void **)(a2 + 584);
  uint64_t v4 = (void *)(a2 + 592);
  if (v3 != (void *)(a2 + 592))
  {
    uint64_t v6 = this;
    int v7 = (char)a3[23];
    if (v7 >= 0) {
      uint64_t v8 = a3[23];
    }
    else {
      uint64_t v8 = *((void *)a3 + 1);
    }
    do
    {
      uint64_t v9 = *((unsigned __int8 *)v3 + 79);
      if ((v9 & 0x80u) == 0) {
        uint64_t v10 = *((unsigned __int8 *)v3 + 79);
      }
      else {
        uint64_t v10 = v3[8];
      }
      if (v10 == v8)
      {
        BOOL v11 = (const void **)(v3 + 7);
        if (v7 >= 0) {
          uint64_t v12 = a3;
        }
        else {
          uint64_t v12 = *(unsigned __int8 **)a3;
        }
        if ((v9 & 0x80) != 0)
        {
          this = (std::string *)memcmp(*v11, v12, v3[8]);
          if (!this) {
            return std::string::operator=(v6, (const std::string *)(v3 + 4));
          }
        }
        else
        {
          if (!*((unsigned char *)v3 + 79)) {
            return std::string::operator=(v6, (const std::string *)(v3 + 4));
          }
          while (*(unsigned __int8 *)v11 == *v12)
          {
            BOOL v11 = (const void **)((char *)v11 + 1);
            ++v12;
            if (!--v9) {
              return std::string::operator=(v6, (const std::string *)(v3 + 4));
            }
          }
        }
      }
      uint64_t v13 = (void *)v3[1];
      if (v13)
      {
        do
        {
          char v14 = v13;
          uint64_t v13 = (void *)*v13;
        }
        while (v13);
      }
      else
      {
        do
        {
          char v14 = (void *)v3[2];
          BOOL v15 = *v14 == (void)v3;
          BOOL v3 = v14;
        }
        while (!v15);
      }
      BOOL v3 = v14;
    }
    while (v14 != v4);
  }
  return this;
}

void sub_1005F15C4(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_1005F15E0(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 504);
  uint64_t v3 = *(void *)(a1 + 512);
  if (v2 == v3) {
    return 0;
  }
  while (1)
  {
    uint64_t v6 = *(unsigned __int8 *)(v2 + 95);
    if ((v6 & 0x80u) == 0) {
      uint64_t v7 = *(unsigned __int8 *)(v2 + 95);
    }
    else {
      uint64_t v7 = *(void *)(v2 + 80);
    }
    uint64_t v8 = *(unsigned __int8 *)(a2 + 23);
    int v9 = (char)v8;
    if ((v8 & 0x80u) != 0) {
      uint64_t v8 = *(void *)(a2 + 8);
    }
    if (v7 != v8) {
      goto LABEL_19;
    }
    uint64_t v10 = v9 >= 0 ? (unsigned __int8 *)a2 : *(unsigned __int8 **)a2;
    if ((v6 & 0x80) == 0) {
      break;
    }
    if (!memcmp(*(const void **)(v2 + 72), v10, *(void *)(v2 + 80))) {
      goto LABEL_18;
    }
LABEL_19:
    v2 += 168;
    if (v2 == v3) {
      return 0;
    }
  }
  if (*(unsigned char *)(v2 + 95))
  {
    uint64_t v11 = 0;
    while (*(unsigned __int8 *)(v2 + v11 + 72) == v10[v11])
    {
      if (v6 == ++v11) {
        goto LABEL_18;
      }
    }
    goto LABEL_19;
  }
LABEL_18:
  if (!subscriber::isSimReady()) {
    goto LABEL_19;
  }
  if (*(_DWORD *)v2 == 2)
  {
    uint64_t v13 = (_DWORD *)(a1 + 1696);
    return (*v13 & 0xFFFFFFFE) == 4;
  }
  else
  {
    if (*(_DWORD *)v2 == 1)
    {
      uint64_t v13 = (_DWORD *)(a1 + 888);
      return (*v13 & 0xFFFFFFFE) == 4;
    }
    return 0;
  }
}

void sub_1005F16E0(uint64_t a1, const std::string *a2, char a3, long long *a4)
{
  if (a3)
  {
    if ((void **)(a1 + 248) != sub_100046F68(a1 + 240, (void **)a4))
    {
      *(void *)&long long buf = a4;
      uint64_t v7 = sub_1006028B8(a1 + 240, (void **)a4, (long long **)&buf);
      uint64_t v8 = (uint64_t *)v7[21];
      int v9 = v7 + 22;
      if (v8 != v7 + 22)
      {
        do
        {
          std::string::operator=((std::string *)(v8 + 13), a2);
          uint64_t v10 = (uint64_t *)v8[1];
          if (v10)
          {
            do
            {
              uint64_t v11 = v10;
              uint64_t v10 = (uint64_t *)*v10;
            }
            while (v10);
          }
          else
          {
            do
            {
              uint64_t v11 = (uint64_t *)v8[2];
              BOOL v12 = *v11 == (void)v8;
              uint64_t v8 = v11;
            }
            while (!v12);
          }
          uint64_t v8 = v11;
        }
        while (v11 != v9);
      }
      long long buf = 0uLL;
      uint64_t v35 = 0;
      long long v31 = a4;
      uint64_t v13 = sub_1006028B8(a1 + 240, (void **)a4, &v31);
      sub_10005DE30((uint64_t)&buf, (uint64_t)(v13 + 21));
      uint64_t v14 = *(void *)(a1 + 120);
      if (SHIBYTE(a2->__r_.__value_.__r.__words[2]) < 0)
      {
        sub_10004FC84(__dst, a2->__r_.__value_.__l.__data_, a2->__r_.__value_.__l.__size_);
        uint64_t v22 = a1;
        if (SHIBYTE(a2->__r_.__value_.__r.__words[2]) < 0)
        {
          sub_10004FC84(&v23, a2->__r_.__value_.__l.__data_, a2->__r_.__value_.__l.__size_);
          goto LABEL_24;
        }
      }
      else
      {
        *(_OWORD *)std::string __dst = *(_OWORD *)&a2->__r_.__value_.__l.__data_;
        std::string::size_type v28 = a2->__r_.__value_.__r.__words[2];
        uint64_t v22 = a1;
      }
      long long v23 = *(_OWORD *)&a2->__r_.__value_.__l.__data_;
      std::string::size_type v24 = a2->__r_.__value_.__r.__words[2];
LABEL_24:
      if (*((char *)a4 + 23) < 0)
      {
        sub_10004FC84(&v25, *(void **)a4, *((void *)a4 + 1));
      }
      else
      {
        long long v25 = *a4;
        uint64_t v26 = *((void *)a4 + 2);
      }
      long long v33 = 0;
      long long v18 = operator new(0x40uLL);
      long long v19 = v18;
      *long long v18 = off_1019EDA38;
      v18[1] = v22;
      if (SHIBYTE(v24) < 0)
      {
        sub_10004FC84((unsigned char *)v18 + 16, (void *)v23, *((unint64_t *)&v23 + 1));
      }
      else
      {
        long long v20 = v23;
        v18[4] = v24;
        *((_OWORD *)v18 + 1) = v20;
      }
      int v21 = v19 + 5;
      if (SHIBYTE(v26) < 0)
      {
        sub_10004FC84(v21, (void *)v25, *((unint64_t *)&v25 + 1));
      }
      else
      {
        *(_OWORD *)int v21 = v25;
        v19[7] = v26;
      }
      long long v33 = v19;
      (*(void (**)(uint64_t, void **, long long *, void *))(*(void *)v14 + 24))(v14, __dst, &buf, v32);
      sub_100060644(v32);
      if (SHIBYTE(v26) < 0) {
        operator delete((void *)v25);
      }
      if (SHIBYTE(v24) < 0) {
        operator delete((void *)v23);
      }
      if (SHIBYTE(v28) < 0) {
        operator delete(__dst[0]);
      }
      sub_10005CD90((uint64_t)&buf, *((void **)&buf + 1));
      return;
    }
    uint64_t v16 = *(NSObject **)(a1 + 64);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
    {
      if (*((char *)a4 + 23) >= 0) {
        long long v17 = a4;
      }
      else {
        long long v17 = *(void **)a4;
      }
      LODWORD(buf) = 136315138;
      *(void *)((char *)&buf + 4) = v17;
      _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "Could not find identifier [%s] in fProfilesOnDevice", (uint8_t *)&buf, 0xCu);
    }
  }
  else
  {
    uint64_t v15 = *(void *)(a1 + 120);
    if (SHIBYTE(a2->__r_.__value_.__r.__words[2]) < 0)
    {
      sub_10004FC84(__p, a2->__r_.__value_.__l.__data_, a2->__r_.__value_.__l.__size_);
    }
    else
    {
      *(_OWORD *)long long __p = *(_OWORD *)&a2->__r_.__value_.__l.__data_;
      std::string::size_type v30 = a2->__r_.__value_.__r.__words[2];
    }
    (*(void (**)(uint64_t, void **))(*(void *)v15 + 32))(v15, __p);
    if (SHIBYTE(v30) < 0) {
      operator delete(__p[0]);
    }
  }
}

void sub_1005F1A68(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, void *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,void *a24,uint64_t a25,int a26,__int16 a27,char a28,char a29,uint64_t a30,char a31)
{
  if (a22 < 0) {
    operator delete(__p);
  }
  sub_10005CD90(v31 - 96, *(void **)(v31 - 88));
  _Unwind_Resume(a1);
}

uint64_t sub_1005F1B18(uint64_t a1)
{
  if (*(char *)(a1 + 127) < 0) {
    operator delete(*(void **)(a1 + 104));
  }
  if (*(char *)(a1 + 103) < 0) {
    operator delete(*(void **)(a1 + 80));
  }
  if (*(char *)(a1 + 79) < 0) {
    operator delete(*(void **)(a1 + 56));
  }
  if (*(char *)(a1 + 55) < 0) {
    operator delete(*(void **)(a1 + 32));
  }
  if (*(char *)(a1 + 23) < 0) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void sub_1005F1B98(uint64_t a1, uint64_t a2)
{
  if ((*(_DWORD *)(a2 + 4) - 37) <= 1)
  {
    int v4 = *(_DWORD *)a2;
    if (*(_DWORD *)a2)
    {
      memset(&__p, 0, sizeof(__p));
      sub_1000631F4(&__p, *(void *)(a1 + 504), *(void *)(a1 + 512), v4);
      std::string::size_type size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        std::string::size_type size = __p.__r_.__value_.__l.__size_;
      }
      if (size)
      {
        if ((void **)(a1 + 224) == sub_100046F68(a1 + 216, (void **)&__p.__r_.__value_.__l.__data_))
        {
          uint64_t v14 = *(NSObject **)(a1 + 64);
          if (!os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)) {
            goto LABEL_28;
          }
          p_p = &__p;
          if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
            p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
          }
          *(_DWORD *)long long buf = 136315138;
          uint64_t v21 = (uint64_t)p_p;
          uint64_t v11 = "iccid [%s] not found in fIccidsOnDevice";
          BOOL v12 = v14;
          uint32_t v13 = 12;
        }
        else
        {
          uint64_t v6 = (std::string *)sub_10005DDEC(a1 + 216, (void **)&__p.__r_.__value_.__l.__data_);
          if (v6[8].__r_.__value_.__s.__data_[8])
          {
            int v7 = *(_DWORD *)(a2 + 4);
            if (v7 == 38)
            {
              if (v6[8].__r_.__value_.__s.__data_[0]) {
                goto LABEL_28;
              }
              sub_1005F03F0(a1, (unsigned __int8 **)(a2 + 8), v6);
            }
            else
            {
              if (v7 != 37 || v6[6].__r_.__value_.__s.__data_[16]) {
                goto LABEL_28;
              }
              sub_1005EF870(a1, a2 + 8, (uint64_t)v6);
            }
            sub_1005EDF84(a1);
            sub_1005EE984(a1);
            sub_1005F1E60(a1);
LABEL_28:
            if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(__p.__r_.__value_.__l.__data_);
            }
            return;
          }
          uint64_t v16 = *(NSObject **)(a1 + 64);
          if (!os_log_type_enabled(v16, OS_LOG_TYPE_ERROR)) {
            goto LABEL_28;
          }
          uint64_t v17 = subscriber::asString();
          long long v18 = &__p;
          if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
            long long v18 = (std::string *)__p.__r_.__value_.__r.__words[0];
          }
          *(_DWORD *)long long buf = 136315394;
          uint64_t v21 = v17;
          __int16 v22 = 2080;
          long long v23 = v18;
          uint64_t v11 = "called [%s] sim file read on a non-private network with iccid [%s]";
          BOOL v12 = v16;
          uint32_t v13 = 22;
        }
      }
      else
      {
        int v9 = *(NSObject **)(a1 + 64);
        if (!os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
          goto LABEL_28;
        }
        int v10 = *(_DWORD *)a2;
        *(_DWORD *)long long buf = 67109120;
        LODWORD(v21) = v10;
        uint64_t v11 = "iccid not found from sim file event for slot [%d]";
        BOOL v12 = v9;
        uint32_t v13 = 8;
      }
      _os_log_error_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, v11, buf, v13);
      goto LABEL_28;
    }
    uint64_t v8 = *(NSObject **)(a1 + 64);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      LOWORD(__p.__r_.__value_.__l.__data_) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "slot not found from sim file event", (uint8_t *)&__p, 2u);
    }
  }
}

void sub_1005F1E34(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1005F1E60(uint64_t a1)
{
  memset(v13, 0, sizeof(v13));
  long long v12 = 0u;
  uint64_t v11 = &v12;
  uint64_t v2 = a1 + 216;
  uint64_t v3 = *(long long **)(a1 + 216);
  int v4 = (long long *)(a1 + 224);
  if (v3 != (long long *)(a1 + 224))
  {
    do
    {
      sub_1006021B0(__p, v3 + 2, (uint64_t)v3 + 56);
      sub_1006053BC((uint64_t)&v11, __p, (uint64_t)__p);
      sub_10006544C((uint64_t)&v10);
      if (v9 < 0) {
        operator delete(__p[0]);
      }
      uint64_t v5 = (long long *)*((void *)v3 + 1);
      if (v5)
      {
        do
        {
          uint64_t v6 = v5;
          uint64_t v5 = *(long long **)v5;
        }
        while (v5);
      }
      else
      {
        do
        {
          uint64_t v6 = (long long *)*((void *)v3 + 2);
          BOOL v7 = *(void *)v6 == (void)v3;
          uint64_t v3 = v6;
        }
        while (!v7);
      }
      uint64_t v3 = v6;
    }
    while (v6 != v4);
  }
  (*(void (**)(void, long long **))(**(void **)(a1 + 136) + 312))(*(void *)(a1 + 136), &v11);
  (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 152) + 32))(*(void *)(a1 + 152), v2, a1 + 504);
  sub_10060222C((uint64_t)v13);
  sub_100602474((uint64_t)&v11, (void *)v12);
}

void sub_1005F1FD8(_Unwind_Exception *a1)
{
  sub_100600500(v1 - 216);
  _Unwind_Resume(a1);
}

uint64_t sub_1005F2000(uint64_t result, int *a2)
{
  if (*(_DWORD *)(result + 32) != *a2 || *(unsigned __int8 *)(result + 36) != *((unsigned __int8 *)a2 + 4))
  {
    int v2 = *a2;
    *(unsigned char *)(result + 36) = *((unsigned char *)a2 + 4);
    *(_DWORD *)(result + 32) = v2;
    uint64_t result = *(void *)(result + 24);
    if (result) {
      return (*(uint64_t (**)(void))(*(void *)result + 48))();
    }
  }
  return result;
}

uint64_t sub_1005F2068(uint64_t a1)
{
  uint64_t v1 = (uint64_t *)(a1 + 24);
  uint64_t v2 = *(unsigned __int8 *)(a1 + 47);
  int v3 = (char)v2;
  if ((v2 & 0x80u) != 0) {
    uint64_t v2 = *(void *)(a1 + 32);
  }
  if (v2 == 10)
  {
    if (v3 < 0) {
      uint64_t v1 = (uint64_t *)*v1;
    }
    char v9 = (uint64_t *)*v1;
    int v10 = *((unsigned __int16 *)v1 + 4);
    BOOL v12 = v9 == (uint64_t *)0x6F4D657669746341 && v10 == 25956;
    return (2 * v12);
  }
  else if (v2 == 12)
  {
    uint64_t v4 = *v1;
    if (v3 >= 0) {
      uint64_t v4 = a1 + 24;
    }
    if (*(void *)v4 == 0x676E69646E756F42 && *(_DWORD *)(v4 + 8) == 1701080909)
    {
      return 1;
    }
    else
    {
      unint64_t v6 = 0x496E616374697665;
      unint64_t v7 = bswap64(*(void *)v4);
      if (v7 == 0x496E616374697665
        && (v6 = 1299145829, unint64_t v7 = bswap32(*(_DWORD *)(v4 + 8)), v7 == 1299145829))
      {
        int v8 = 0;
      }
      else if (v7 < v6)
      {
        int v8 = -1;
      }
      else
      {
        int v8 = 1;
      }
      if (v8) {
        return 0;
      }
      else {
        return 3;
      }
    }
  }
  else
  {
    return 0;
  }
}

void sub_1005F2170(std::string::size_type a1)
{
  (***(void (****)(std::string *__return_ptr))(a1 + 72))(&__p);
  ServiceMap = (std::mutex *)Registry::getServiceMap((Registry *)__p.__r_.__value_.__l.__data_);
  int v3 = ServiceMap;
  if (v4 < 0)
  {
    uint64_t v5 = (unsigned __int8 *)(v4 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v6 = 5381;
    do
    {
      uint64_t v4 = v6;
      unsigned int v7 = *v5++;
      uint64_t v6 = (33 * v6) ^ v7;
    }
    while (v7);
  }
  std::mutex::lock(ServiceMap);
  *(void *)&long long valuePtr = v4;
  int v8 = sub_10004D37C(&v3[1].__m_.__sig, (unint64_t *)&valuePtr);
  if (v8)
  {
    int v10 = (GestaltUtilityInterface *)v8[3];
    char v9 = (std::__shared_weak_count *)v8[4];
    if (v9)
    {
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v3);
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v9);
      char v11 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    int v10 = 0;
  }
  std::mutex::unlock(v3);
  char v9 = 0;
  char v11 = 1;
LABEL_9:
  *(unsigned char *)(a1 + 425) = GestaltUtilityInterface::isIPad(v10);
  if ((v11 & 1) == 0) {
    sub_10004D2C8(v9);
  }
  if (__p.__r_.__value_.__l.__size_) {
    sub_10004D2C8((std::__shared_weak_count *)__p.__r_.__value_.__l.__size_);
  }
  BOOL v12 = dispatch_queue_attr_make_with_qos_class(0, QOS_CLASS_UTILITY, 0);
  uint32_t v13 = dispatch_queue_create("PrivateNetworkController", v12);
  uint64_t v14 = *(void *)(a1 + 72);
  uint64_t v15 = *(NSObject **)(a1 + 48);
  dispatch_object_t object = v15;
  if (v15) {
    dispatch_retain(v15);
  }
  uint64_t v16 = *(std::__shared_weak_count **)(a1 + 40);
  if (!v16 || (uint64_t v17 = *(void *)(a1 + 32), (v18 = std::__shared_weak_count::lock(v16)) == 0)) {
    sub_100088B9C();
  }
  uint64_t v19 = v17 + 8;
  if (!v17) {
    uint64_t v19 = 0;
  }
  uint64_t v101 = v19;
  long long v102 = v18;
  (*(void (**)(std::string *__return_ptr, uint64_t, dispatch_object_t *, uint64_t *))(*(void *)v14 + 688))(&__p, v14, &object, &v101);
  long long v20 = *(_OWORD *)&__p.__r_.__value_.__l.__data_;
  *(_OWORD *)&__p.__r_.__value_.__l.__data_ = 0uLL;
  uint64_t v21 = *(std::__shared_weak_count **)(a1 + 112);
  *(_OWORD *)(a1 + 104) = v20;
  if (v21)
  {
    sub_10004D2C8(v21);
    if (__p.__r_.__value_.__l.__size_) {
      sub_10004D2C8((std::__shared_weak_count *)__p.__r_.__value_.__l.__size_);
    }
  }
  if (v102) {
    sub_10004D2C8(v102);
  }
  if (object) {
    dispatch_release(object);
  }
  uint64_t v22 = *(void *)(a1 + 104);
  sub_100058DB0(&__p, "com.apple.CoreTelephony");
  LODWORD(valuePtr) = 0;
  LODWORD(theArray) = 2;
  (*(void (**)(uint64_t, NSObject *, std::string *, long long *, CFArrayRef *))(*(void *)v22 + 56))(v22, v13, &__p, &valuePtr, &theArray);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  uint64_t v23 = *(void *)(a1 + 72);
  std::string::size_type v24 = *(NSObject **)(a1 + 48);
  dispatch_object_t v100 = v24;
  if (v24) {
    dispatch_retain(v24);
  }
  (*(void (**)(std::string *__return_ptr, uint64_t, dispatch_object_t *))(*(void *)v23 + 680))(&__p, v23, &v100);
  long long v25 = *(_OWORD *)&__p.__r_.__value_.__l.__data_;
  *(_OWORD *)&__p.__r_.__value_.__l.__data_ = 0uLL;
  uint64_t v26 = *(std::__shared_weak_count **)(a1 + 160);
  *(_OWORD *)(a1 + 152) = v25;
  if (v26)
  {
    sub_10004D2C8(v26);
    if (__p.__r_.__value_.__l.__size_) {
      sub_10004D2C8((std::__shared_weak_count *)__p.__r_.__value_.__l.__size_);
    }
  }
  if (v100) {
    dispatch_release(v100);
  }
  (*(void (**)(void))(**(void **)(a1 + 152) + 16))(*(void *)(a1 + 152));
  (*(void (**)(std::string *__return_ptr))(**(void **)(a1 + 72) + 712))(&__p);
  long long v27 = *(_OWORD *)&__p.__r_.__value_.__l.__data_;
  *(_OWORD *)&__p.__r_.__value_.__l.__data_ = 0uLL;
  std::string::size_type v28 = *(std::__shared_weak_count **)(a1 + 128);
  *(_OWORD *)(a1 + 120) = v27;
  if (v28)
  {
    sub_10004D2C8(v28);
    if (__p.__r_.__value_.__l.__size_) {
      sub_10004D2C8((std::__shared_weak_count *)__p.__r_.__value_.__l.__size_);
    }
  }
  (***(void (****)(std::string *__return_ptr))(a1 + 72))(&__p);
  Registry::createRestModuleOneTimeUseConnection((uint64_t *)&theArray, (Registry *)__p.__r_.__value_.__l.__data_);
  std::string::size_type v29 = a1 + 488;
  ctu::RestModule::connect();
  if (v105) {
    sub_10004D2C8(v105);
  }
  if (__p.__r_.__value_.__l.__size_) {
    sub_10004D2C8((std::__shared_weak_count *)__p.__r_.__value_.__l.__size_);
  }
  sub_100058DB0(&valuePtr, "/cc/events/carrier_bundle_event");
  __p.__r_.__value_.__r.__words[0] = (std::string::size_type)off_1019EDEE8;
  __p.__r_.__value_.__l.__size_ = a1;
  p_p = &__p;
  ctu::RestModule::observeEvent();
  sub_10003F600(&__p);
  if (SHIBYTE(v107) < 0) {
    operator delete((void *)valuePtr);
  }
  sub_100058DB0(&valuePtr, "/cc/props/current_calls");
  std::string::size_type v30 = (std::string *)operator new(0x28uLL);
  v30->__r_.__value_.__r.__words[0] = (std::string::size_type)off_1019EDF68;
  v30->__r_.__value_.__l.__size_ = a1 + 792;
  v30->__r_.__value_.__r.__words[2] = a1;
  v30[1].__r_.__value_.__r.__words[0] = (std::string::size_type)sub_1005FE298;
  v30[1].__r_.__value_.__l.__size_ = 0;
  p_p = v30;
  ctu::RestModule::observeProperty();
  sub_10003F600(&__p);
  if (SHIBYTE(v107) < 0) {
    operator delete((void *)valuePtr);
  }
  std::string::size_type v31 = a1 + 688;
  __p.__r_.__value_.__r.__words[0] = (std::string::size_type)off_1019EDFE8;
  __p.__r_.__value_.__l.__size_ = a1 + 488;
  p_p = &__p;
  if (&__p != (std::string *)(a1 + 688))
  {
    long long v32 = *(std::string **)(a1 + 712);
    if (v32 == (std::string *)v31)
    {
      *((void *)&valuePtr + 1) = a1 + 488;
      uint64_t v107 = 0;
      *(void *)&long long valuePtr = off_1019EDFE8;
      p_p = 0;
      (*(void (**)(std::string::size_type, std::string *))(*(void *)v31 + 24))(a1 + 688, &__p);
      (*(void (**)(void))(**(void **)(a1 + 712) + 32))(*(void *)(a1 + 712));
      *(void *)(a1 + 712) = 0;
      p_p = &__p;
      (*(void (**)(long long *, std::string::size_type))(valuePtr + 24))(&valuePtr, a1 + 688);
      (*(void (**)(long long *))(valuePtr + 32))(&valuePtr);
    }
    else
    {
      *(void *)(a1 + 688) = off_1019EDFE8;
      *(void *)(a1 + 696) = v29;
      p_p = v32;
    }
    *(void *)(a1 + 712) = v31;
  }
  sub_100600FC4(&__p);
  uint64_t v33 = *(void *)(a1 + 712);
  if (v33) {
    (*(void (**)(uint64_t, std::string::size_type))(*(void *)v33 + 48))(v33, a1 + 720);
  }
  __p.__r_.__value_.__r.__words[0] = (std::string::size_type)off_1019EE078;
  __p.__r_.__value_.__l.__size_ = a1 + 488;
  p_p = &__p;
  sub_100318874(&__p, (void *)(a1 + 648));
  sub_10030AB98(&__p);
  uint64_t v34 = *(void *)(a1 + 672);
  if (v34) {
    (*(void (**)(uint64_t, std::string::size_type))(*(void *)v34 + 48))(v34, a1 + 680);
  }
  *(void *)(a1 + 872) = "/cc/props/reg_net_info1";
  __p.__r_.__value_.__r.__words[0] = (std::string::size_type)sub_1005FE528;
  __p.__r_.__value_.__l.__size_ = 0;
  sub_1006081E4((char **)(a1 + 872), a1 + 488, a1, (uint64_t *)&__p);
  *(void *)(a1 + 1680) = "/cc/props/reg_net_info2";
  __p.__r_.__value_.__r.__words[0] = (std::string::size_type)sub_1005FE534;
  __p.__r_.__value_.__l.__size_ = 0;
  sub_1006081E4((char **)(a1 + 1680), a1 + 488, a1, (uint64_t *)&__p);
  sub_100058DB0(&valuePtr, "/cc/props/carrier_entitlements_info");
  uint64_t v35 = (std::string *)operator new(0x28uLL);
  v35->__r_.__value_.__r.__words[0] = (std::string::size_type)off_1019EE178;
  v35->__r_.__value_.__l.__size_ = a1 + 816;
  v35->__r_.__value_.__r.__words[2] = a1;
  v35[1].__r_.__value_.__r.__words[0] = (std::string::size_type)sub_1005FE540;
  v35[1].__r_.__value_.__l.__size_ = 0;
  p_p = v35;
  ctu::RestModule::observeProperty();
  sub_10003F600(&__p);
  if (SHIBYTE(v107) < 0) {
    operator delete((void *)valuePtr);
  }
  std::string::size_type v36 = a1 + 552;
  __p.__r_.__value_.__r.__words[0] = (std::string::size_type)off_1019EE1F8;
  __p.__r_.__value_.__l.__size_ = a1 + 488;
  p_p = &__p;
  if (&__p != (std::string *)(a1 + 552))
  {
    long long v37 = *(std::string **)(a1 + 576);
    if (v37 == (std::string *)v36)
    {
      *((void *)&valuePtr + 1) = a1 + 488;
      uint64_t v107 = 0;
      *(void *)&long long valuePtr = off_1019EE1F8;
      p_p = 0;
      (*(void (**)(std::string::size_type, std::string *))(*(void *)v36 + 24))(a1 + 552, &__p);
      (*(void (**)(void))(**(void **)(a1 + 576) + 32))(*(void *)(a1 + 576));
      *(void *)(a1 + 576) = 0;
      p_p = &__p;
      (*(void (**)(long long *, std::string::size_type))(valuePtr + 24))(&valuePtr, a1 + 552);
      (*(void (**)(long long *))(valuePtr + 32))(&valuePtr);
    }
    else
    {
      *(void *)(a1 + 552) = off_1019EE1F8;
      *(void *)(a1 + 560) = v29;
      p_p = v37;
    }
    *(void *)(a1 + 576) = v36;
  }
  sub_1006010CC(&__p);
  uint64_t v38 = *(void *)(a1 + 576);
  if (v38) {
    (*(void (**)(uint64_t, std::string::size_type))(*(void *)v38 + 48))(v38, a1 + 584);
  }
  sub_100058DB0(&valuePtr, "/cc/props/airplane_mode_user_preference");
  long long v39 = (std::string *)operator new(0x28uLL);
  v39->__r_.__value_.__r.__words[0] = (std::string::size_type)off_1019EE288;
  v39->__r_.__value_.__l.__size_ = a1 + 2520;
  v39->__r_.__value_.__r.__words[2] = a1;
  v39[1].__r_.__value_.__r.__words[0] = (std::string::size_type)sub_1005FE88C;
  v39[1].__r_.__value_.__l.__size_ = 0;
  p_p = v39;
  ctu::RestModule::observeProperty();
  sub_10003F600(&__p);
  if (SHIBYTE(v107) < 0) {
    operator delete((void *)valuePtr);
  }
  sub_1005FE9F4(a1 + 848);
  std::string::size_type v40 = a1 + 608;
  __p.__r_.__value_.__r.__words[0] = (std::string::size_type)off_1019EE388;
  __p.__r_.__value_.__l.__size_ = a1 + 488;
  p_p = &__p;
  if (&__p != (std::string *)(a1 + 608))
  {
    std::string::size_type v41 = *(std::string **)(a1 + 632);
    if (v41 == (std::string *)v40)
    {
      *((void *)&valuePtr + 1) = a1 + 488;
      uint64_t v107 = 0;
      *(void *)&long long valuePtr = off_1019EE388;
      p_p = 0;
      (*(void (**)(std::string::size_type, std::string *))(*(void *)v40 + 24))(a1 + 608, &__p);
      (*(void (**)(void))(**(void **)(a1 + 632) + 32))(*(void *)(a1 + 632));
      *(void *)(a1 + 632) = 0;
      p_p = &__p;
      (*(void (**)(long long *, std::string::size_type))(valuePtr + 24))(&valuePtr, a1 + 608);
      (*(void (**)(long long *))(valuePtr + 32))(&valuePtr);
    }
    else
    {
      *(void *)(a1 + 608) = off_1019EE388;
      *(void *)(a1 + 616) = v29;
      p_p = v41;
    }
    *(void *)(a1 + 632) = v40;
  }
  sub_100601048(&__p);
  uint64_t v42 = *(void *)(a1 + 632);
  if (v42) {
    (*(void (**)(uint64_t, std::string::size_type))(*(void *)v42 + 48))(v42, a1 + 640);
  }
  int v43 = *(std::__shared_weak_count **)(a1 + 40);
  if (!v43 || (std::string::size_type v44 = *(void *)(a1 + 32), (v45 = std::__shared_weak_count::lock(v43)) == 0)) {
    sub_100088B9C();
  }
  int v46 = v45;
  atomic_fetch_add_explicit(&v45->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v45);
  sub_100058DB0(&valuePtr, "/cc/events/geo_mcc_fetch");
  char v47 = (std::string *)operator new(0x20uLL);
  v47->__r_.__value_.__r.__words[0] = (std::string::size_type)off_1019EE418;
  v47->__r_.__value_.__l.__size_ = v44;
  v47->__r_.__value_.__r.__words[2] = (std::string::size_type)v46;
  v47[1].__r_.__value_.__r.__words[0] = a1;
  p_p = v47;
  ctu::RestModule::observeEvent();
  sub_10003F600(&__p);
  if (SHIBYTE(v107) < 0) {
    operator delete((void *)valuePtr);
  }
  sub_100058DB0(&valuePtr, "/cc/props/first_unlock_since_boot");
  std::string v48 = (std::string *)operator new(0x28uLL);
  v48->__r_.__value_.__r.__words[0] = (std::string::size_type)off_1019EE498;
  v48->__r_.__value_.__l.__size_ = a1 + 840;
  v48->__r_.__value_.__r.__words[2] = a1;
  v48[1].__r_.__value_.__r.__words[0] = (std::string::size_type)sub_1005FEAD4;
  v48[1].__r_.__value_.__l.__size_ = 0;
  p_p = v48;
  ctu::RestModule::observeProperty();
  sub_10003F600(&__p);
  if (SHIBYTE(v107) < 0) {
    operator delete((void *)valuePtr);
  }
  sub_100058DB0(&valuePtr, "/cc/props/wrm_sub_preference");
  int v49 = (std::string *)operator new(0x28uLL);
  v49->__r_.__value_.__r.__words[0] = (std::string::size_type)off_1019EE518;
  v49->__r_.__value_.__l.__size_ = a1 + 2524;
  v49->__r_.__value_.__r.__words[2] = a1;
  v49[1].__r_.__value_.__r.__words[0] = (std::string::size_type)sub_1005FEF44;
  v49[1].__r_.__value_.__l.__size_ = 0;
  p_p = v49;
  ctu::RestModule::observeProperty();
  sub_10003F600(&__p);
  if (SHIBYTE(v107) < 0) {
    operator delete((void *)valuePtr);
  }
  __p.__r_.__value_.__r.__words[0] = (std::string::size_type)off_1019EE598;
  __p.__r_.__value_.__l.__size_ = a1 + 488;
  p_p = &__p;
  sub_100609368(&__p, (void *)(a1 + 744));
  sub_100600F40(&__p);
  uint64_t v50 = *(void *)(a1 + 768);
  if (v50) {
    (*(void (**)(uint64_t, std::string::size_type))(*(void *)v50 + 48))(v50, a1 + 776);
  }
  sub_100058DB0(&valuePtr, "/cc/events/subscriber_sim_file_event");
  uint64_t v51 = (std::string *)operator new(0x20uLL);
  v51->__r_.__value_.__r.__words[0] = (std::string::size_type)off_1019EE628;
  v51->__r_.__value_.__l.__size_ = a1;
  v51->__r_.__value_.__r.__words[2] = (std::string::size_type)sub_1005F1B98;
  v51[1].__r_.__value_.__r.__words[0] = 0;
  p_p = v51;
  ctu::RestModule::observeEvent();
  sub_10003F600(&__p);
  if (SHIBYTE(v107) < 0) {
    operator delete((void *)valuePtr);
  }
  uint64_t v52 = *(void *)(a1 + 136);
  __p.__r_.__value_.__r.__words[0] = (std::string::size_type)off_1019EE8B8;
  __p.__r_.__value_.__l.__size_ = a1;
  p_p = &__p;
  (*(void (**)(uint64_t, std::string *))(*(void *)v52 + 320))(v52, &__p);
  sub_10060B0E0(&__p);
  double v53 = (*(double (**)(void))(**(void **)(a1 + 136) + 368))(*(void *)(a1 + 136));
  if (v53 != 0.0)
  {
    CFDateRef v54 = CFDateCreate(kCFAllocatorDefault, v53);
    uint64_t v55 = *(void *)(a1 + 392);
    *(void *)(a1 + 392) = v54;
    *(void *)&long long valuePtr = v55;
    sub_10007CA64((const void **)&valuePtr);
    sub_1005FB968(a1);
  }
  (*(void (**)(void, std::string::size_type, std::string::size_type))(**(void **)(a1 + 152) + 32))(*(void *)(a1 + 152), a1 + 216, a1 + 504);
  uint64_t v56 = *(void *)(a1 + 136);
  __p.__r_.__value_.__r.__words[0] = (std::string::size_type)off_1019EDAB8;
  __p.__r_.__value_.__l.__size_ = a1;
  p_p = &__p;
  (*(void (**)(uint64_t, std::string *))(*(void *)v56 + 336))(v56, &__p);
  sub_100605338(&__p);
  sub_1005EDF84(a1);
  sub_1005EE984(a1);
  uint64_t v57 = *(void *)(a1 + 72);
  char v58 = *(NSObject **)(a1 + 48);
  dispatch_object_t v99 = v58;
  if (v58) {
    dispatch_retain(v58);
  }
  uint64_t v59 = *(std::__shared_weak_count **)(a1 + 40);
  if (!v59 || (uint64_t v60 = *(void *)(a1 + 32), (v61 = std::__shared_weak_count::lock(v59)) == 0)) {
    sub_100088B9C();
  }
  uint64_t v62 = v60 + 24;
  if (!v60) {
    uint64_t v62 = 0;
  }
  uint64_t v97 = v62;
  long long v98 = v61;
  (*(void (**)(std::string *__return_ptr, uint64_t, dispatch_object_t *, uint64_t *))(*(void *)v57 + 696))(&__p, v57, &v99, &v97);
  long long v63 = *(_OWORD *)&__p.__r_.__value_.__l.__data_;
  *(_OWORD *)&__p.__r_.__value_.__l.__data_ = 0uLL;
  uint64_t v64 = *(std::__shared_weak_count **)(a1 + 192);
  *(_OWORD *)(a1 + 184) = v63;
  if (v64)
  {
    sub_10004D2C8(v64);
    if (__p.__r_.__value_.__l.__size_) {
      sub_10004D2C8((std::__shared_weak_count *)__p.__r_.__value_.__l.__size_);
    }
  }
  if (v98) {
    sub_10004D2C8(v98);
  }
  if (v99) {
    dispatch_release(v99);
  }
  (*(void (**)(void))(**(void **)(a1 + 184) + 32))(*(void *)(a1 + 184));
  (***(void (****)(std::string *__return_ptr))(a1 + 72))(&__p);
  char v65 = (std::mutex *)Registry::getServiceMap((Registry *)__p.__r_.__value_.__l.__data_);
  char v66 = v65;
  if (v67 < 0)
  {
    uint64_t v68 = (unsigned __int8 *)(v67 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v69 = 5381;
    do
    {
      uint64_t v67 = v69;
      unsigned int v70 = *v68++;
      uint64_t v69 = (33 * v69) ^ v70;
    }
    while (v70);
  }
  std::mutex::lock(v65);
  *(void *)&long long valuePtr = v67;
  char v71 = sub_10004D37C(&v66[1].__m_.__sig, (unint64_t *)&valuePtr);
  if (v71)
  {
    uint64_t v73 = v71[3];
    __int16 v72 = (std::__shared_weak_count *)v71[4];
    if (v72)
    {
      atomic_fetch_add_explicit(&v72->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v66);
      atomic_fetch_add_explicit(&v72->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v72);
      char v74 = 0;
      goto LABEL_108;
    }
  }
  else
  {
    uint64_t v73 = 0;
  }
  std::mutex::unlock(v66);
  __int16 v72 = 0;
  char v74 = 1;
LABEL_108:
  if (__p.__r_.__value_.__l.__size_) {
    sub_10004D2C8((std::__shared_weak_count *)__p.__r_.__value_.__l.__size_);
  }
  if (!v73)
  {
    long long v94 = *(NSObject **)(a1 + 64);
    if (os_log_type_enabled(v94, OS_LOG_TYPE_ERROR))
    {
      LOWORD(__p.__r_.__value_.__l.__data_) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v94, OS_LOG_TYPE_ERROR, "Cannot get Preference", (uint8_t *)&__p, 2u);
      if ((v74 & 1) == 0) {
        goto LABEL_153;
      }
    }
    else if ((v74 & 1) == 0)
    {
      goto LABEL_153;
    }
LABEL_147:
    if (!v13) {
      return;
    }
    goto LABEL_148;
  }
  CFArrayRef theArray = 0;
  (*(void (**)(std::string *__return_ptr, uint64_t, const __CFString *, void, const CFStringRef, const CFStringRef))(*(void *)v73 + 40))(&__p, v73, @"RetrieveGeofenceDataRecords", kCommCenterPreferencesNoBackupAppID, kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
  sub_100044D6C(&theArray, (CFTypeRef *)&__p.__r_.__value_.__l.__data_);
  sub_1000577C4((const void **)&__p.__r_.__value_.__l.__data_);
  if (theArray) {
    uint64_t v75 = sub_100083F10;
  }
  else {
    uint64_t v75 = 0;
  }
  if (v75)
  {
    char v96 = v74;
    CFIndex Count = CFArrayGetCount(theArray);
    if (Count >= 1)
    {
      CFIndex v77 = 0;
      __int16 v78 = (void **)(a1 + 464);
      do
      {
        __p.__r_.__value_.__r.__words[0] = 0;
        *(void *)&long long valuePtr = CFArrayGetValueAtIndex(theArray, v77);
        sub_1000842D0(&__p, (CFTypeRef *)&valuePtr);
        if (__p.__r_.__value_.__r.__words[0]) {
          char v79 = sub_100081E58;
        }
        else {
          char v79 = 0;
        }
        if (v79)
        {
          *(void *)&long long valuePtr = 0;
          CFNumberGetValue((CFNumberRef)__p.__r_.__value_.__l.__data_, kCFNumberLongLongType, &valuePtr);
          uint64_t v80 = valuePtr;
          __int16 v82 = *(char **)(a1 + 472);
          unint64_t v81 = *(void *)(a1 + 480);
          if ((unint64_t)v82 >= v81)
          {
            __int16 v84 = (char *)*v78;
            uint64_t v85 = (v82 - (unsigned char *)*v78) >> 3;
            unint64_t v86 = v85 + 1;
            if ((unint64_t)(v85 + 1) >> 61) {
              sub_10006A748();
            }
            uint64_t v87 = v81 - (void)v84;
            if (v87 >> 2 > v86) {
              unint64_t v86 = v87 >> 2;
            }
            if ((unint64_t)v87 >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v88 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v88 = v86;
            }
            if (v88)
            {
              long long v89 = (char *)sub_10004EF74(a1 + 480, v88);
              __int16 v84 = *(char **)(a1 + 464);
              __int16 v82 = *(char **)(a1 + 472);
            }
            else
            {
              long long v89 = 0;
            }
            long long v90 = &v89[8 * v85];
            *(void *)long long v90 = v80;
            char v83 = v90 + 8;
            while (v82 != v84)
            {
              uint64_t v91 = *((void *)v82 - 1);
              v82 -= 8;
              *((void *)v90 - 1) = v91;
              v90 -= 8;
            }
            *(void *)(a1 + 464) = v90;
            *(void *)(a1 + 472) = v83;
            *(void *)(a1 + 480) = &v89[8 * v88];
            if (v84) {
              operator delete(v84);
            }
          }
          else
          {
            *(void *)__int16 v82 = valuePtr;
            char v83 = v82 + 8;
          }
          *(void *)(a1 + 472) = v83;
        }
        sub_1000570E8((const void **)&__p.__r_.__value_.__l.__data_);
        ++v77;
      }
      while (v77 != Count);
    }
    long long v92 = *(NSObject **)(a1 + 64);
    char v74 = v96;
    if (os_log_type_enabled(v92, OS_LOG_TYPE_DEFAULT))
    {
      sub_1005F796C(&__p, *(uint64_t **)(a1 + 464), *(uint64_t **)(a1 + 472));
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        long long v93 = &__p;
      }
      else {
        long long v93 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      LODWORD(valuePtr) = 136315138;
      *(void *)((char *)&valuePtr + 4) = v93;
      _os_log_impl((void *)&_mh_execute_header, v92, OS_LOG_TYPE_DEFAULT, "#I fetch Geofence data history: %s", (uint8_t *)&valuePtr, 0xCu);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
    }
  }
  else
  {
    long long v95 = *(NSObject **)(a1 + 64);
    if (os_log_type_enabled(v95, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(__p.__r_.__value_.__l.__data_) = 0;
      _os_log_impl((void *)&_mh_execute_header, v95, OS_LOG_TYPE_DEFAULT, "#I kRetrieveGeofenceDataRecords doesn't have record", (uint8_t *)&__p, 2u);
    }
  }
  sub_100044D00((const void **)&theArray);
  if (v74) {
    goto LABEL_147;
  }
LABEL_153:
  sub_10004D2C8(v72);
  if (v13) {
LABEL_148:
  }
    dispatch_release(v13);
}

void sub_1005F351C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, int a10, int a11, dispatch_object_t object, uint64_t a13, uint64_t a14, dispatch_object_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, const void *a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27,uint64_t a28,uint64_t a29,uint64_t a30,int a31,__int16 a32,char a33,char a34)
{
  sub_100044D00(&a20);
  if ((v35 & 1) == 0) {
    sub_10004D2C8(v34);
  }
  if (object) {
    dispatch_release(object);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_1005F3764(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 184) + 40))();
}

uint64_t sub_1005F378C(uint64_t a1, int a2, uint64_t a3)
{
  __int16 v4 = sub_1005EC568(a1, a2) | 0x100;

  return sub_100335978(a3, v4);
}

void sub_1005F37CC(uint64_t a1, int a2, uint64_t a3)
{
  if (sub_1005EC568(a1, a2))
  {
    memset(&v17, 0, sizeof(v17));
    sub_1000631F4(&v17, *(void *)(a1 + 504), *(void *)(a1 + 512), a2);
    std::string::size_type size = HIBYTE(v17.__r_.__value_.__r.__words[2]);
    if ((v17.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      std::string::size_type size = v17.__r_.__value_.__l.__size_;
    }
    if (size)
    {
      unsigned int v7 = sub_100046F68(a1 + 216, (void **)&v17.__r_.__value_.__l.__data_);
      if ((void **)(a1 + 224) != v7)
      {
        int v8 = v7;
        long long buf = 0uLL;
        uint64_t v20 = 0;
        if (SHIBYTE(v17.__r_.__value_.__r.__words[2]) < 0) {
          sub_10004FC84(&__p, v17.__r_.__value_.__l.__data_, v17.__r_.__value_.__l.__size_);
        }
        else {
          std::string __p = v17;
        }
        sub_1005F0F5C((char **)&buf, a1, (void **)&__p.__r_.__value_.__l.__data_);
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__p.__r_.__value_.__l.__data_);
        }
        if ((void **)(a1 + 248) == sub_100046F68(a1 + 240, (void **)&buf))
        {
          unint64_t v11 = (unint64_t)&_mh_execute_header;
        }
        else
        {
          p_long long buf = &buf;
          unint64_t v11 = (unint64_t)&_mh_execute_header | ((unint64_t)*((unsigned __int8 *)sub_1006028B8(a1 + 240, (void **)&buf, &p_buf)+ 161) << 8);
        }
        uint64_t v12 = *((unsigned __int8 *)v8 + 256);
        if (SHIBYTE(v17.__r_.__value_.__r.__words[2]) < 0) {
          sub_10004FC84(&v15, v17.__r_.__value_.__l.__data_, v17.__r_.__value_.__l.__size_);
        }
        else {
          std::string v15 = v17;
        }
        int v13 = sub_1005F06B8(a1, (void **)&v15.__r_.__value_.__l.__data_);
        if (SHIBYTE(v15.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v15.__r_.__value_.__l.__data_);
        }
        sub_100335BA8(a3, v11 | v12 | ((unint64_t)(v13 == 1) << 16));
        if (SHIBYTE(v20) < 0) {
          operator delete((void *)buf);
        }
        goto LABEL_29;
      }
      int v10 = *(NSObject **)(a1 + 64);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
      {
        uint64_t v14 = &v17;
        if ((v17.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
          uint64_t v14 = (std::string *)v17.__r_.__value_.__r.__words[0];
        }
        LODWORD(buf) = 136315138;
        *(void *)((char *)&buf + 4) = v14;
        _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "SIM matching to iccid [%s] not found to get private network capabilities", (uint8_t *)&buf, 0xCu);
      }
    }
    else
    {
      char v9 = *(NSObject **)(a1 + 64);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
      {
        LODWORD(buf) = 67109120;
        DWORD1(buf) = a2;
        _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "iccid missing for slot [%d]", (uint8_t *)&buf, 8u);
      }
    }
    sub_100335BA8(a3, 0);
LABEL_29:
    if (SHIBYTE(v17.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v17.__r_.__value_.__l.__data_);
    }
    return;
  }

  sub_100335BA8(a3, 0);
}

void sub_1005F3ABC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  if (a28 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1005F3B30(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  if ((uint64_t *)(a1 + 528) != a3) {
    sub_1003DB294(a1 + 528, *a3, a3[1], 0x2E8BA2E8BA2E8BA3 * ((a3[1] - *a3) >> 3));
  }
  if ((uint64_t *)(a1 + 504) != a2) {
    sub_1003DB990(a1 + 504, *a2, a2[1], 0xCF3CF3CF3CF3CF3DLL * ((a2[1] - *a2) >> 3));
  }
  v177[0] = 0;
  v177[1] = 0;
  v176 = (void **)v177;
  memset(v175, 0, sizeof(v175));
  v174[0] = 0;
  v174[1] = 0;
  CFTypeRef v173 = v174;
  v156 = (void *)(a1 + 584);
  if (!*(void *)(a1 + 600))
  {
    uint64_t v5 = *(void *)(a1 + 528);
    uint64_t v6 = *(void *)(a1 + 536);
    *(_OWORD *)&__str[8] = 0uLL;
    *(void *)std::string __str = &__str[8];
    uint64_t v154 = v6;
    if (v5 != v6)
    {
      while (!*(unsigned char *)(v5 + 80))
      {
LABEL_89:
        v5 += 88;
        if (v5 == v154) {
          goto LABEL_90;
        }
      }
      uint64_t v8 = *(void *)(v5 + 56);
      uint64_t v7 = *(void *)(v5 + 64);
      while (1)
      {
        if (v8 == v7) {
          goto LABEL_89;
        }
        if (!*(unsigned char *)(v8 + 88)) {
          break;
        }
LABEL_72:
        v8 += 216;
      }
      *(void *)values = @"GeofenceOptimizations";
      CFArrayRef v9 = CFArrayCreate(kCFAllocatorDefault, (const void **)values, 1, &kCFTypeArrayCallBacks);
      *(void *)long long buf = v9;
      theDict[0] = 0;
      uint64_t v10 = *(void *)(a1 + 72);
      CFArrayRef v178 = v9;
      if (v9) {
        CFRetain(v9);
      }
      (*(void (**)(const void **__return_ptr, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, CFArrayRef *))(*(void *)v10 + 152))(&v179, v10, v8 + 96, v8 + 120, v8 + 144, v8 + 168, v8 + 16, &v178);
      sub_10004EFE4(theDict, &v179);
      sub_10005717C(&v179);
      sub_100044D00((const void **)&v178);
      if (theDict[0]) {
        unint64_t v11 = sub_100080778;
      }
      else {
        unint64_t v11 = 0;
      }
      if (!v11
        || (CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(theDict[0], @"GeofenceOptimizations"),
            (CFDictionaryRef v13 = Value) == 0)
        || (CFTypeID v14 = CFGetTypeID(Value), v14 != CFDictionaryGetTypeID())
        || !CFDictionaryContainsKey(v13, @"SupportsOnlyOffloadSim")
        || (std::string v15 = (BOOL *)CFDictionaryGetValue(v13, @"SupportsOnlyOffloadSim"), v16 = v15, LOBYTE(v179) = 0, !v15)
        || (CFTypeID v17 = CFGetTypeID(v15), v17 != CFBooleanGetTypeID()))
      {
        sub_100057D78((const void **)theDict);
        sub_100044D00((const void **)buf);
        goto LABEL_72;
      }
      ctu::cf::assign((ctu::cf *)&v179, v16, v18);
      int v19 = v179;
      sub_100057D78((const void **)theDict);
      sub_100044D00((const void **)buf);
      if (!v19) {
        goto LABEL_72;
      }
      uint64_t v20 = *(std::__shared_weak_count **)(a1 + 96);
      if (v20)
      {
        uint64_t v21 = std::__shared_weak_count::lock(v20);
        uint64_t v22 = v21;
        if (v21)
        {
          uint64_t v152 = *(void *)(a1 + 88);
          if (v152)
          {
            long long v149 = v21;
            uint64_t v23 = *(void *)(a1 + 504);
            uint64_t v153 = *(void *)(a1 + 512);
            if (v23 != v153)
            {
              while (1)
              {
                uint64_t v210 = 0;
                long long v208 = 0u;
                *(_OWORD *)std::string __p = 0u;
                *(_OWORD *)v206 = 0u;
                *(_OWORD *)v207 = 0u;
                *(_OWORD *)__s1 = 0u;
                *(_OWORD *)__n = 0u;
                memset(values, 0, sizeof(values));
                sub_10002E664((uint64_t)values, v23);
                if (!subscriber::isSimReady()) {
                  goto LABEL_59;
                }
                uint64_t v24 = HIBYTE(__n[1]);
                if ((__n[1] & 0x8000000000000000) == 0) {
                  size_t v25 = HIBYTE(__n[1]);
                }
                else {
                  size_t v25 = __n[0];
                }
                uint64_t v26 = *(unsigned __int8 *)(v8 + 39);
                int v27 = (char)v26;
                if ((v26 & 0x80u) != 0) {
                  uint64_t v26 = *(void *)(v8 + 24);
                }
                if (v25 != v26) {
                  goto LABEL_59;
                }
                std::string::size_type v28 = v27 >= 0 ? (unsigned __int8 *)(v8 + 16) : *(unsigned __int8 **)(v8 + 16);
                if ((__n[1] & 0x8000000000000000) == 0) {
                  break;
                }
                std::string::size_type v30 = (void **)__s1[1];
                if (!memcmp(__s1[1], v28, __n[0]))
                {
                  log = *(NSObject **)(a1 + 64);
                  if (!os_log_type_enabled(log, OS_LOG_TYPE_DEFAULT))
                  {
LABEL_50:
                    if ((*(unsigned int (**)(uint64_t, void **, void))(*(void *)v152 + 40))(v152, &__s1[1], 0))
                    {
                      loga = *(NSObject **)(a1 + 64);
                      if (os_log_type_enabled(loga, OS_LOG_TYPE_ERROR))
                      {
                        int v147 = SHIBYTE(__n[1]);
                        long long v148 = (void **)__s1[1];
                        uint64_t v31 = asString();
                        *(_DWORD *)long long buf = 136315394;
                        long long v32 = &__s1[1];
                        if (v147 < 0) {
                          long long v32 = v148;
                        }
                        *(void *)&uint8_t buf[4] = v32;
                        *(_WORD *)&unsigned char buf[12] = 2080;
                        *(void *)&buf[14] = v31;
                        _os_log_error_impl((void *)&_mh_execute_header, loga, OS_LOG_TYPE_ERROR, "unbound offload sim %s disable failed with error %s", buf, 0x16u);
                      }
                    }
                    else
                    {
                      uint64_t v33 = *(NSObject **)(a1 + 64);
                      if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
                      {
                        uint64_t v34 = &__s1[1];
                        if ((__n[1] & 0x8000000000000000) != 0) {
                          uint64_t v34 = (void **)__s1[1];
                        }
                        *(_DWORD *)long long buf = 136315138;
                        *(void *)&uint8_t buf[4] = v34;
                        _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "#I turn off unbound offload sim %s success", buf, 0xCu);
                      }
                    }
                    goto LABEL_59;
                  }
LABEL_49:
                  *(_DWORD *)long long buf = 136315138;
                  *(void *)&uint8_t buf[4] = v30;
                  _os_log_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_DEFAULT, "#I found unbound offload sim %s which is active, turn it off", buf, 0xCu);
                  goto LABEL_50;
                }
LABEL_59:
                if (SHIBYTE(v210) < 0) {
                  operator delete(__p[0]);
                }
                if (SHIBYTE(v208) < 0) {
                  operator delete(v207[1]);
                }
                if (SHIBYTE(v207[0]) < 0) {
                  operator delete(v206[0]);
                }
                if (SHIBYTE(__n[1]) < 0) {
                  operator delete(__s1[1]);
                }
                *(void *)long long buf = &values[40];
                sub_10002E39C((void ***)buf);
                if (*(void *)&values[16])
                {
                  *(void *)&values[24] = *(void *)&values[16];
                  operator delete(*(void **)&values[16]);
                }
                v23 += 168;
                if (v23 == v153)
                {
                  uint64_t v22 = v149;
                  goto LABEL_76;
                }
              }
              if (HIBYTE(__n[1]))
              {
                std::string::size_type v29 = &__s1[1];
                while (*(unsigned __int8 *)v29 == *v28)
                {
                  std::string::size_type v29 = (void **)((char *)v29 + 1);
                  ++v28;
                  if (!--v24)
                  {
                    log = *(NSObject **)(a1 + 64);
                    if (os_log_type_enabled(log, OS_LOG_TYPE_DEFAULT)) {
                      goto LABEL_48;
                    }
                    goto LABEL_50;
                  }
                }
                goto LABEL_59;
              }
              log = *(NSObject **)(a1 + 64);
              if (!os_log_type_enabled(log, OS_LOG_TYPE_DEFAULT)) {
                goto LABEL_50;
              }
LABEL_48:
              std::string::size_type v30 = &__s1[1];
              goto LABEL_49;
            }
            uint64_t v22 = v21;
            goto LABEL_76;
          }
        }
      }
      else
      {
        uint64_t v22 = 0;
      }
      char v35 = *(NSObject **)(a1 + 64);
      if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
      {
        if (*(char *)(v8 + 39) >= 0) {
          uint64_t v36 = v8 + 16;
        }
        else {
          uint64_t v36 = *(void *)(v8 + 16);
        }
        *(_DWORD *)values = 136315138;
        *(void *)&values[4] = v36;
        _os_log_error_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_ERROR, "invalid delegate to disable unbound offload sim %s", values, 0xCu);
        if (!v22) {
          goto LABEL_77;
        }
      }
      else if (!v22)
      {
LABEL_77:
        std::operator+<char>();
        sub_100601A5C((uint64_t)values, (long long *)buf, (long long *)(v8 + 16));
        sub_1006063F0((uint64_t **)__str, (void **)values, (uint64_t)values);
        if ((values[47] & 0x80000000) != 0) {
          operator delete(*(void **)&values[24]);
        }
        if ((values[23] & 0x80000000) != 0) {
          operator delete(*(void **)values);
        }
        if ((buf[23] & 0x80000000) != 0) {
          operator delete(*(void **)buf);
        }
        goto LABEL_72;
      }
LABEL_76:
      sub_10004D2C8(v22);
      goto LABEL_77;
    }
LABEL_90:
    long long v37 = *(NSObject **)(a1 + 64);
    if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)values = 134217984;
      *(void *)&values[4] = *(void *)&__str[16];
      _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEFAULT, "#I There is (%lu) unbounded offload sim", values, 0xCu);
    }
    if (*(void *)&__str[16])
    {
      *(void *)values = 1;
      memset(&values[16], 0, 24);
      *(void *)&values[8] = a1 + 552;
      uint64_t v38 = (uint64_t **)sub_100346B40((uint64_t)&values[16], (uint64_t)v156);
      sub_100328AC0(v38, *(long long **)__str, (long long *)&__str[8]);
      sub_100606180((uint64_t)values);
    }
    sub_10010C0E0((uint64_t)__str, *(void **)&__str[8]);
  }
  long long v39 = (void **)(a1 + 440);
  if (*(char *)(a1 + 463) < 0)
  {
    unint64_t v40 = *(void *)(a1 + 448);
    if (!v40) {
      goto LABEL_119;
    }
    memset(buf, 0, 24);
    sub_10004FC84(__str, *v39, v40);
  }
  else
  {
    if (!*(unsigned char *)(a1 + 463)) {
      goto LABEL_119;
    }
    memset(buf, 0, 24);
    *(_OWORD *)std::string __str = *(_OWORD *)v39;
    *(void *)&__str[16] = *(void *)(a1 + 456);
  }
  sub_1005F14B8((std::string *)buf, a1, __str);
  if ((__str[23] & 0x80000000) != 0) {
    operator delete(*(void **)__str);
  }
  if ((sIsProfileInstalled() & 1) == 0)
  {
    std::string::size_type v41 = *(std::__shared_weak_count **)(a1 + 96);
    if (v41)
    {
      uint64_t v42 = std::__shared_weak_count::lock(v41);
      if (v42)
      {
        int v43 = v42;
        uint64_t v44 = *(void *)(a1 + 88);
        if (v44)
        {
          if (*(char *)(a1 + 463) < 0)
          {
            sub_10004FC84(theDict, *(void **)(a1 + 440), *(void *)(a1 + 448));
          }
          else
          {
            *(_OWORD *)CFDictionaryRef theDict = *(_OWORD *)v39;
            uint64_t v202 = *(void *)(a1 + 456);
          }
          *(void *)values = _NSConcreteStackBlock;
          *(void *)&values[8] = 1174405120;
          *(void *)&values[16] = sub_1005F6A20;
          *(void *)&values[24] = &unk_1019ED670;
          *(void *)&values[32] = a1;
          if ((buf[23] & 0x80000000) != 0)
          {
            sub_10004FC84(&values[40], *(void **)buf, *(unint64_t *)&buf[8]);
          }
          else
          {
            *(_OWORD *)&values[40] = *(_OWORD *)buf;
            *(void *)&values[56] = *(void *)&buf[16];
          }
          (*(void (**)(uint64_t, CFDictionaryRef *, unsigned char *))(*(void *)v44 + 16))(v44, theDict, values);
          if (SHIBYTE(v202) < 0) {
            operator delete(theDict[0]);
          }
          if ((values[63] & 0x80000000) != 0) {
            operator delete(*(void **)&values[40]);
          }
        }
        sub_10004D2C8(v43);
      }
    }
  }
  if ((buf[23] & 0x80000000) != 0) {
    operator delete(*(void **)buf);
  }
LABEL_119:
  if (sub_1005F5A04(a1)) {
    sub_1005F5BD0(a1);
  }
  uint64_t v45 = *(void *)(a1 + 528);
  for (uint64_t i = *(void *)(a1 + 536); v45 != i; v45 += 88)
  {
    if (*(_DWORD *)v45 == 2 && *(unsigned char *)(v45 + 80))
    {
      uint64_t v47 = *(void *)(v45 + 56);
      uint64_t v48 = *(void *)(v45 + 64);
      while (v47 != v48)
      {
        if (!*(unsigned char *)(v47 + 88))
        {
          long long v199 = 0u;
          long long v200 = 0u;
          long long v197 = 0u;
          long long v198 = 0u;
          long long v195 = 0u;
          long long v196 = 0u;
          long long v193 = 0u;
          long long v194 = 0u;
          long long v191 = 0u;
          long long v192 = 0u;
          long long v189 = 0u;
          long long v190 = 0u;
          long long v187 = 0u;
          long long v188 = 0u;
          long long v185 = 0u;
          long long v186 = 0u;
          long long v183 = 0u;
          long long v184 = 0u;
          long long v181 = 0u;
          long long v182 = 0u;
          memset(buf, 0, sizeof(buf));
          sub_1006015F0((uint64_t)buf);
          *(_DWORD *)long long buf = 0;
          std::string::operator=((std::string *)((char *)&v181 + 8), (const std::string *)(v47 + 96));
          std::string::operator=((std::string *)&v183, (const std::string *)(v47 + 120));
          std::string::operator=((std::string *)((char *)&v184 + 8), (const std::string *)(v47 + 144));
          std::string::operator=((std::string *)&v186, (const std::string *)(v47 + 168));
          sub_1006017E8(values, (long long *)(v47 + 16), (uint64_t)buf);
          sub_1006053BC((uint64_t)&v176, (void **)values, (uint64_t)values);
          sub_10006544C((uint64_t)&values[24]);
          if ((values[23] & 0x80000000) != 0) {
            operator delete(*(void **)values);
          }
          sub_10006544C((uint64_t)buf);
        }
        v47 += 216;
      }
    }
  }
  uint64_t v50 = *(const std::string **)(a1 + 504);
  for (j = *(int **)(a1 + 512); v50 != (const std::string *)j; v50 += 7)
  {
    if ((subscriber::isSimSettled() & 1) == 0) {
      goto LABEL_369;
    }
    if (subscriber::isEsimCapable())
    {
      if (v177 != (void **)sub_100046F68((uint64_t)&v176, (void **)&v50[3].__r_.__value_.__l.__data_))
      {
        int data = (int)v50->__r_.__value_.__l.__data_;
        *(void *)values = v50 + 3;
        *((_DWORD *)sub_100602C14((uint64_t)&v176, (void **)&v50[3].__r_.__value_.__l.__data_, (long long **)values) + 14) = data;
      }
    }
    else
    {
      if (subscriber::isPhySimDisabled()) {
        sub_100604120((uint64_t **)&v173, (void **)&v50[3].__r_.__value_.__l.__data_, (uint64_t)&v50[3]);
      }
      long long v172 = 0u;
      memset(__str, 0, sizeof(__str));
      sub_100E63EA4((uint64_t)__str);
      long long v199 = 0u;
      long long v200 = 0u;
      long long v197 = 0u;
      long long v198 = 0u;
      long long v195 = 0u;
      long long v196 = 0u;
      long long v193 = 0u;
      long long v194 = 0u;
      long long v191 = 0u;
      long long v192 = 0u;
      long long v189 = 0u;
      long long v190 = 0u;
      long long v187 = 0u;
      long long v188 = 0u;
      long long v185 = 0u;
      long long v186 = 0u;
      long long v183 = 0u;
      long long v184 = 0u;
      long long v181 = 0u;
      long long v182 = 0u;
      memset(buf, 0, sizeof(buf));
      sub_1006015F0((uint64_t)buf);
      *(_DWORD *)long long buf = v50->__r_.__value_.__l.__data_;
      std::string::operator=((std::string *)((char *)&v181 + 8), (const std::string *)__str);
      std::string::operator=((std::string *)&v183, (const std::string *)&__str[24]);
      std::string::operator=((std::string *)((char *)&v184 + 8), v50 + 5);
      std::string::operator=((std::string *)&v186, v50 + 6);
      sub_1006017E8(values, (long long *)&v50[3], (uint64_t)buf);
      sub_1006053BC((uint64_t)&v176, (void **)values, (uint64_t)values);
      sub_10006544C((uint64_t)&values[24]);
      if ((values[23] & 0x80000000) != 0) {
        operator delete(*(void **)values);
      }
      sub_10006544C((uint64_t)buf);
      if (SHIBYTE(v172) < 0) {
        operator delete(*(void **)&__str[24]);
      }
      if ((__str[23] & 0x80000000) != 0) {
        operator delete(*(void **)__str);
      }
    }
  }
  uint64_t v52 = *(void ***)(a1 + 216);
  double v53 = (void **)(a1 + 224);
  if (v52 != (void **)(a1 + 224))
  {
    do
    {
      CFDateRef v54 = (long long *)(v52 + 4);
      if (v177 == (void **)sub_100046F68((uint64_t)&v176, v52 + 4))
      {
        uint64_t v56 = *(_OWORD **)&v175[8];
        if (*(void *)&v175[8] >= *(void *)&v175[16])
        {
          unint64_t v58 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)&v175[8] - *(void *)v175) >> 3);
          unint64_t v59 = v58 + 1;
          if (v58 + 1 > 0xAAAAAAAAAAAAAAALL) {
            sub_10006A748();
          }
          if (0x5555555555555556 * ((uint64_t)(*(void *)&v175[16] - *(void *)v175) >> 3) > v59) {
            unint64_t v59 = 0x5555555555555556 * ((uint64_t)(*(void *)&v175[16] - *(void *)v175) >> 3);
          }
          if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)&v175[16] - *(void *)v175) >> 3) >= 0x555555555555555) {
            unint64_t v60 = 0xAAAAAAAAAAAAAAALL;
          }
          else {
            unint64_t v60 = v59;
          }
          *(void *)&values[32] = &v175[16];
          if (v60) {
            unint64_t v60 = (unint64_t)sub_100601864(v60);
          }
          else {
            uint64_t v61 = 0;
          }
          unint64_t v63 = v60 + 24 * v58;
          *(void *)values = v60;
          *(void *)&values[8] = v63;
          *(void *)&values[16] = v63;
          *(void *)&values[24] = v60 + 24 * v61;
          if (*((char *)v52 + 55) < 0)
          {
            sub_10004FC84((unsigned char *)(v60 + 24 * v58), v52[4], (unint64_t)v52[5]);
            unint64_t v65 = *(void *)&values[16];
            unint64_t v63 = *(void *)&values[8];
          }
          else
          {
            long long v64 = *v54;
            *(void *)(v63 + 16) = v52[6];
            *(_OWORD *)unint64_t v63 = v64;
            unint64_t v65 = v60 + 24 * v58;
          }
          *(void *)&values[16] = v65 + 24;
          char v66 = *(void ***)&v175[8];
          uint64_t v67 = *(void ***)v175;
          *(void *)std::string __str = v63;
          *(void *)&__str[8] = v63;
          *(_OWORD *)CFDictionaryRef theDict = *(_OWORD *)__str;
          *(void *)long long buf = &v175[16];
          *(void *)&uint8_t buf[8] = theDict;
          *(void *)&uint8_t buf[16] = __str;
          *(void *)&unsigned char buf[24] = 0;
          if (*(void *)&v175[8] != *(void *)v175)
          {
            do
            {
              uint64_t v68 = (unsigned char *)(v63 - 24);
              uint64_t v69 = v66 - 3;
              if (*((char *)v66 - 1) < 0)
              {
                sub_10004FC84(v68, *(v66 - 3), (unint64_t)*(v66 - 2));
                unint64_t v63 = *(void *)&__str[8];
              }
              else
              {
                long long v70 = *(_OWORD *)v69;
                *(void *)(v63 - 8) = *(v66 - 1);
                *(_OWORD *)uint64_t v68 = v70;
              }
              v63 -= 24;
              *(void *)&__str[8] = v63;
              char v66 = v69;
            }
            while (v69 != v67);
          }
          unsigned char buf[24] = 1;
          sub_1006018AC((uint64_t)buf);
          uint64_t v71 = *(void *)&v175[16];
          long long v72 = *(_OWORD *)&values[16];
          CFTypeRef v155 = *(char **)&values[16];
          long long v73 = *(_OWORD *)v175;
          *(void *)v175 = v63;
          *(_OWORD *)&values[8] = v73;
          *(_OWORD *)&v175[8] = v72;
          *(void *)&values[24] = v71;
          *(void *)values = v73;
          sub_10060190C((uint64_t)values);
          uint64_t v62 = v155;
        }
        else
        {
          if (*((char *)v52 + 55) < 0)
          {
            sub_10004FC84(*(unsigned char **)&v175[8], v52[4], (unint64_t)v52[5]);
          }
          else
          {
            long long v57 = *v54;
            *(void *)(*(void *)&v175[8] + 16) = v52[6];
            *uint64_t v56 = v57;
          }
          uint64_t v62 = (char *)v56 + 24;
        }
        *(void *)&v175[8] = v62;
      }
      else
      {
        *(void *)values = v52 + 4;
        int v55 = *((_DWORD *)sub_100602C14((uint64_t)&v176, v52 + 4, (long long **)values) + 14);
        if (v53 != sub_100046F68(a1 + 216, v52 + 4))
        {
          *(void *)values = v52 + 4;
          if (*((_DWORD *)sub_100602C14(a1 + 216, v52 + 4, (long long **)values) + 14) != v55)
          {
            *(void *)values = v52 + 4;
            *((_DWORD *)sub_100602C14(a1 + 216, v52 + 4, (long long **)values) + 14) = v55;
          }
        }
        sub_10060564C(&v176, v52 + 4);
      }
      char v74 = (void **)v52[1];
      if (v74)
      {
        do
        {
          uint64_t v75 = v74;
          char v74 = (void **)*v74;
        }
        while (v74);
      }
      else
      {
        do
        {
          uint64_t v75 = (void **)v52[2];
          BOOL v115 = *v75 == v52;
          uint64_t v52 = v75;
        }
        while (!v115);
      }
      uint64_t v52 = v75;
    }
    while (v75 != v53);
  }
  __int16 v76 = v176;
  if (v176 != (void **)v177)
  {
    do
    {
      memset(values, 0, 24);
      if (*((char *)v76 + 55) < 0)
      {
        sub_10004FC84(buf, v76[4], (unint64_t)v76[5]);
      }
      else
      {
        *(_OWORD *)long long buf = *((_OWORD *)v76 + 2);
        *(void *)&uint8_t buf[16] = v76[6];
      }
      sub_1005F14B8((std::string *)values, a1, buf);
      if ((buf[23] & 0x80000000) != 0) {
        operator delete(*(void **)buf);
      }
      if (!sub_1005FB4A8(a1, (uint64_t)values)) {
        goto LABEL_223;
      }
      if ((values[23] & 0x80000000) != 0)
      {
        sub_10004FC84(__str, *(void **)values, *(unint64_t *)&values[8]);
      }
      else
      {
        *(_OWORD *)std::string __str = *(_OWORD *)values;
        *(void *)&__str[16] = *(void *)&values[16];
      }
      int v77 = sub_1005F08AC(*(void *)(a1 + 504), *(void *)(a1 + 512), (uint64_t)__str);
      char v78 = v77;
      if ((__str[23] & 0x80000000) != 0)
      {
        operator delete(*(void **)__str);
        if ((v78 & 1) == 0) {
          goto LABEL_223;
        }
      }
      else if (!v77)
      {
        goto LABEL_223;
      }
      if ((values[23] & 0x80000000) != 0)
      {
        sub_10004FC84(theDict, *(void **)values, *(unint64_t *)&values[8]);
      }
      else
      {
        *(_OWORD *)CFDictionaryRef theDict = *(_OWORD *)values;
        uint64_t v202 = *(void *)&values[16];
      }
      uint64_t v79 = sub_10010E194(*(void ***)(a1 + 824), (void **)theDict);
      uint64_t v80 = v79;
      if (SHIBYTE(v202) < 0)
      {
        operator delete(theDict[0]);
        if (!v80)
        {
LABEL_204:
          unint64_t v81 = *(NSObject **)(a1 + 64);
          if (os_log_type_enabled(v81, OS_LOG_TYPE_DEFAULT))
          {
            CFDictionaryRef v82 = (const __CFDictionary *)values;
            if (values[23] < 0) {
              CFDictionaryRef v82 = *(const __CFDictionary **)values;
            }
            LODWORD(theDict[0]) = 136315138;
            *(CFDictionaryRef *)((char *)theDict + 4) = v82;
            _os_log_impl((void *)&_mh_execute_header, v81, OS_LOG_TYPE_DEFAULT, "#I %s doesn't have entitlement info", (uint8_t *)theDict, 0xCu);
          }
          goto LABEL_223;
        }
      }
      else if (!v79)
      {
        goto LABEL_204;
      }
      if ((values[23] & 0x80000000) != 0)
      {
        sub_10004FC84(theDict, *(void **)values, *(unint64_t *)&values[8]);
      }
      else
      {
        *(_OWORD *)CFDictionaryRef theDict = *(_OWORD *)values;
        uint64_t v202 = *(void *)&values[16];
      }
      uint64_t v83 = sub_10005DDEC(a1 + 816, (void **)theDict);
      if (SHIBYTE(v202) < 0) {
        operator delete(theDict[0]);
      }
      __int16 v84 = *(NSObject **)(a1 + 64);
      if (os_log_type_enabled(v84, OS_LOG_TYPE_DEFAULT))
      {
        if (*((char *)v76 + 55) >= 0) {
          CFDictionaryRef v85 = (const __CFDictionary *)(v76 + 4);
        }
        else {
          CFDictionaryRef v85 = (const __CFDictionary *)v76[4];
        }
        LODWORD(theDict[0]) = 136315138;
        *(CFDictionaryRef *)((char *)theDict + 4) = v85;
        _os_log_impl((void *)&_mh_execute_header, v84, OS_LOG_TYPE_DEFAULT, "#I %s is offload sim, try to fetchGeofence", (uint8_t *)theDict, 0xCu);
      }
      if ((*(unsigned char *)(v83 + 81) & 4) != 0)
      {
        if ((values[23] & 0x80000000) != 0)
        {
          sub_10004FC84(theDict, *(void **)values, *(unint64_t *)&values[8]);
        }
        else
        {
          *(_OWORD *)CFDictionaryRef theDict = *(_OWORD *)values;
          uint64_t v202 = *(void *)&values[16];
        }
        sub_1005F72F4(a1, (long long *)theDict, 1, 0);
        if (SHIBYTE(v202) < 0) {
          operator delete(theDict[0]);
        }
        sub_1005F8D2C(a1, (uint64_t)values);
      }
LABEL_223:
      if ((values[23] & 0x80000000) != 0) {
        operator delete(*(void **)values);
      }
      unint64_t v86 = (void **)v76[1];
      if (v86)
      {
        do
        {
          uint64_t v87 = v86;
          unint64_t v86 = (void **)*v86;
        }
        while (v86);
      }
      else
      {
        do
        {
          uint64_t v87 = (void **)v76[2];
          BOOL v115 = *v87 == v76;
          __int16 v76 = v87;
        }
        while (!v115);
      }
      __int16 v76 = v87;
    }
    while (v87 != (void **)v177);
  }
  sub_1006056FC((uint64_t *)&v169, (uint64_t)&v176);
  v168[0] = 0;
  v168[1] = 0;
  long long v167 = v168;
  unint64_t v88 = (uint64_t *)v173;
  if (v173 != v174)
  {
    do
    {
      sub_1004AD97C((uint64_t **)&v167, (uint64_t)v168, (void **)v88 + 4, (uint64_t)(v88 + 4));
      long long v89 = (char *)v88[1];
      if (v89)
      {
        do
        {
          long long v90 = (char **)v89;
          long long v89 = *(char **)v89;
        }
        while (v89);
      }
      else
      {
        do
        {
          long long v90 = (char **)v88[2];
          BOOL v115 = *v90 == (char *)v88;
          unint64_t v88 = (uint64_t *)v90;
        }
        while (!v115);
      }
      unint64_t v88 = (uint64_t *)v90;
    }
    while (v90 != v174);
  }
  CFDictionaryRef v164 = 0;
  CFDictionaryRef v165 = 0;
  long long v166 = 0;
  long long v92 = *(long long **)&v175[8];
  uint64_t v91 = *(long long **)v175;
  *(void *)long long buf = &v164;
  if (*(void *)&v175[8] != *(void *)v175)
  {
    unint64_t v93 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)&v175[8] - *(void *)v175) >> 3);
    *(void *)&uint8_t buf[8] = 0;
    if (v93 > 0xAAAAAAAAAAAAAAALL) {
      sub_10006A748();
    }
    CFDictionaryRef v164 = (const __CFDictionary *)sub_100601864(v93);
    CFDictionaryRef v165 = v164;
    long long v166 = (char *)v164 + 24 * v94;
    *(void *)std::string __str = v164;
    theDict[0] = v164;
    *(void *)values = &v166;
    *(void *)&values[8] = theDict;
    *(void *)&values[24] = 0;
    *(void *)&values[16] = __str;
    CFDictionaryRef v95 = v164;
    do
    {
      if (*((char *)v91 + 23) < 0)
      {
        sub_10004FC84(v95, *(void **)v91, *((void *)v91 + 1));
        CFDictionaryRef v95 = *(const __CFDictionary **)__str;
      }
      else
      {
        long long v96 = *v91;
        *((void *)v95 + 2) = *((void *)v91 + 2);
        *(_OWORD *)CFDictionaryRef v95 = v96;
      }
      uint64_t v91 = (long long *)((char *)v91 + 24);
      CFDictionaryRef v95 = (const __CFDictionary *)((char *)v95 + 24);
      *(void *)std::string __str = v95;
    }
    while (v91 != v92);
    values[24] = 1;
    sub_100601970((uint64_t)values);
    CFDictionaryRef v165 = v95;
    for (k = (void **)v164; k != (void **)v95; k += 3)
      sub_10060564C((void ***)(a1 + 216), k);
  }
  long long v98 = v169;
  if (v169 != v170)
  {
    do
    {
      dispatch_object_t v99 = (void **)(v98 + 4);
      if (v168 == (char **)sub_100046F68((uint64_t)&v167, (void **)v98 + 4))
      {
        if (*((char *)v98 + 55) < 0)
        {
          unint64_t v102 = (unint64_t)v98[5];
          if (v102)
          {
            sub_10004FC84(buf, *v99, v102);
            goto LABEL_262;
          }
        }
        else if (*((unsigned char *)v98 + 55))
        {
          *(_OWORD *)long long buf = *(_OWORD *)v99;
          *(void *)&uint8_t buf[16] = v98[6];
LABEL_262:
          sub_1006000E4(a1, (uint64_t)buf, (uint64_t)(v98 + 7));
          if ((buf[23] & 0x80000000) != 0) {
            operator delete(*(void **)buf);
          }
          if (*(unsigned char *)(a1 + 425)) {
            *((unsigned char *)v98 + 257) = 0;
          }
          sub_1006017E8(values, (long long *)v98 + 2, (uint64_t)(v98 + 7));
          sub_1006053BC(a1 + 216, (void **)values, (uint64_t)values);
          sub_10006544C((uint64_t)&values[24]);
          if ((values[23] & 0x80000000) != 0) {
            operator delete(*(void **)values);
          }
        }
      }
      dispatch_object_t v100 = v98[1];
      if (v100)
      {
        do
        {
          uint64_t v101 = (void **)v100;
          dispatch_object_t v100 = (void *)*v100;
        }
        while (v100);
      }
      else
      {
        do
        {
          uint64_t v101 = (void **)v98[2];
          BOOL v115 = *v101 == v98;
          long long v98 = v101;
        }
        while (!v115);
      }
      long long v98 = v101;
    }
    while (v101 != v170);
  }
  if (v170[1])
  {
    sub_1005EE984(a1);
    sub_1005F1E60(a1);
  }
  *(void *)values = &v164;
  sub_1006019D0((void ***)values);
  sub_10005CD2C((uint64_t)&v167, v168[0]);
  sub_100602474((uint64_t)&v169, v170[0]);
  sub_1005EECFC(a1);
  (***(void (****)(unsigned char *__return_ptr))(a1 + 72))(values);
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)values);
  long long v104 = ServiceMap;
  if (v105 < 0)
  {
    long long v106 = (unsigned __int8 *)(v105 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v107 = 5381;
    do
    {
      uint64_t v105 = v107;
      unsigned int v108 = *v106++;
      uint64_t v107 = (33 * v107) ^ v108;
    }
    while (v108);
  }
  std::mutex::lock(ServiceMap);
  *(void *)long long buf = v105;
  long long v109 = sub_10004D37C(&v104[1].__m_.__sig, (unint64_t *)buf);
  if (!v109)
  {
    uint64_t v111 = 0;
    goto LABEL_277;
  }
  uint64_t v111 = v109[3];
  long long v110 = (std::__shared_weak_count *)v109[4];
  if (!v110)
  {
LABEL_277:
    std::mutex::unlock(v104);
    long long v110 = 0;
    char v112 = 1;
    goto LABEL_278;
  }
  atomic_fetch_add_explicit(&v110->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v104);
  atomic_fetch_add_explicit(&v110->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v110);
  char v112 = 0;
LABEL_278:
  if (*(void *)&values[8]) {
    sub_10004D2C8(*(std::__shared_weak_count **)&values[8]);
  }
  if (v111)
  {
    long long v113 = *(void ***)(a1 + 216);
    if (v113 != v53)
    {
      do
      {
        uint64_t v114 = *((unsigned int *)v113 + 14);
        if (*((unsigned char *)v113 + 256)) {
          BOOL v115 = v114 == 0;
        }
        else {
          BOOL v115 = 1;
        }
        if (!v115)
        {
          if (!*((unsigned char *)v113 + 216))
          {
            *(_DWORD *)long long buf = 37;
            sub_100602B08((uint64_t)values, (int *)buf, 1);
            (*(void (**)(uint64_t, uint64_t, unsigned char *))(*(void *)v111 + 168))(v111, v114, values);
            sub_1000346F8((uint64_t)values, *(void **)&values[8]);
          }
          if (!*((unsigned char *)v113 + 248))
          {
            uint64_t v116 = *((unsigned int *)v113 + 14);
            *(_DWORD *)long long buf = 38;
            sub_100602B08((uint64_t)values, (int *)buf, 1);
            (*(void (**)(uint64_t, uint64_t, unsigned char *))(*(void *)v111 + 168))(v111, v116, values);
            sub_1000346F8((uint64_t)values, *(void **)&values[8]);
          }
        }
        uint64_t v117 = (void **)v113[1];
        if (v117)
        {
          do
          {
            __int16 v118 = v117;
            uint64_t v117 = (void **)*v117;
          }
          while (v117);
        }
        else
        {
          do
          {
            __int16 v118 = (void **)v113[2];
            BOOL v115 = *v118 == v113;
            long long v113 = v118;
          }
          while (!v115);
        }
        long long v113 = v118;
      }
      while (v118 != v53);
    }
  }
  else
  {
    long long v119 = *(NSObject **)(a1 + 64);
    if (os_log_type_enabled(v119, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)values = 0;
      _os_log_impl((void *)&_mh_execute_header, v119, OS_LOG_TYPE_DEFAULT, "#E subscriber sim controller not found", values, 2u);
    }
  }
  if ((v112 & 1) == 0) {
    sub_10004D2C8(v110);
  }
  sub_1005EDF84(a1);
  sub_1005F64A0((void *)a1);
  sub_1005EEEF0(a1);
  sub_100058DB0(v159, "EvaluateAllIccids");
  if (SHIBYTE(v160) < 0)
  {
    sub_10004FC84(__dst, v159[0], (unint64_t)v159[1]);
  }
  else
  {
    *(_OWORD *)std::string __dst = *(_OWORD *)v159;
    uint64_t v162 = v160;
  }
  int v163 = 10;
  sub_100007714(a1, (uint64_t *)__dst);
  if (SHIBYTE(v162) < 0) {
    operator delete(__dst[0]);
  }
  if (SHIBYTE(v160) < 0) {
    operator delete(v159[0]);
  }
  __int16 v121 = *(unsigned __int8 ***)&v175[8];
  uint64_t v120 = *(unsigned __int8 ***)v175;
  if (*(void *)v175 == *(void *)&v175[8]) {
    goto LABEL_346;
  }
  CFTypeRef v122 = (void *)(a1 + 592);
  do
  {
    if (*((char *)v120 + 23) < 0)
    {
      if (!v120[1]) {
        goto LABEL_345;
      }
    }
    else if (!*((unsigned char *)v120 + 23))
    {
      goto LABEL_345;
    }
    memset(buf, 0, 24);
    uint64_t v123 = (void *)*v156;
    if ((void *)*v156 == v122) {
      goto LABEL_345;
    }
    char v124 = *((unsigned char *)v120 + 23);
    if (v124 >= 0) {
      uint64_t v125 = (unsigned __int8 *)*((unsigned __int8 *)v120 + 23);
    }
    else {
      uint64_t v125 = v120[1];
    }
    if (v124 >= 0) {
      uint64_t v126 = (unsigned __int8 *)v120;
    }
    else {
      uint64_t v126 = *v120;
    }
    while (1)
    {
      uint64_t v127 = *((unsigned __int8 *)v123 + 79);
      if ((v127 & 0x80u) == 0) {
        uint64_t v128 = (unsigned __int8 *)*((unsigned __int8 *)v123 + 79);
      }
      else {
        uint64_t v128 = (unsigned __int8 *)v123[8];
      }
      if (v128 != v125) {
        goto LABEL_332;
      }
      __int16 v129 = (const void **)(v123 + 7);
      if ((v127 & 0x80) != 0) {
        break;
      }
      if (!*((unsigned char *)v123 + 79)) {
        goto LABEL_339;
      }
      BOOL v130 = v126;
      while (*(unsigned __int8 *)v129 == *v130)
      {
        __int16 v129 = (const void **)((char *)v129 + 1);
        ++v130;
        if (!--v127) {
          goto LABEL_339;
        }
      }
LABEL_332:
      CFTypeRef v131 = (void *)v123[1];
      if (v131)
      {
        do
        {
          v132 = v131;
          CFTypeRef v131 = (void *)*v131;
        }
        while (v131);
      }
      else
      {
        do
        {
          v132 = (void *)v123[2];
          BOOL v115 = *v132 == (void)v123;
          uint64_t v123 = v132;
        }
        while (!v115);
      }
      uint64_t v123 = v132;
      if (v132 == v122) {
        goto LABEL_345;
      }
    }
    if (memcmp(*v129, v126, v123[8])) {
      goto LABEL_332;
    }
LABEL_339:
    std::string::operator=((std::string *)buf, (const std::string *)(v123 + 4));
    char v133 = buf[23];
    uint64_t v134 = buf[23];
    if (buf[23] < 0) {
      uint64_t v134 = *(void *)&buf[8];
    }
    if (v134)
    {
      memset(&values[16], 0, 24);
      *(void *)values = 1;
      *(void *)&values[8] = a1 + 552;
      sub_100346B40((uint64_t)&values[16], (uint64_t)v156);
      sub_10010F808((uint64_t **)&values[16], (void **)buf);
      sub_100606180((uint64_t)values);
      char v133 = buf[23];
    }
    if (v133 < 0) {
      operator delete(*(void **)buf);
    }
LABEL_345:
    v120 += 3;
  }
  while (v120 != v121);
LABEL_346:
  v135 = *(void **)(a1 + 584);
  if (v135 != (void *)(a1 + 592))
  {
    while ((sub_1005FB4A8(a1, (uint64_t)(v135 + 4)) & 1) != 0 || (sub_1005FB4A8(a1, (uint64_t)(v135 + 7)) & 1) == 0)
    {
      uint64_t v136 = (void *)v135[1];
      if (v136)
      {
        do
        {
          __int16 v137 = v136;
          uint64_t v136 = (void *)*v136;
        }
        while (v136);
      }
      else
      {
        do
        {
          __int16 v137 = (void *)v135[2];
          BOOL v115 = *v137 == (void)v135;
          v135 = v137;
        }
        while (!v115);
      }
      v135 = v137;
      if (v137 == (void *)(a1 + 592)) {
        goto LABEL_369;
      }
    }
    (***(void (****)(CFDictionaryRef *__return_ptr))(a1 + 72))(theDict);
    Registry::getTimerService((uint64_t *)__str, (Registry *)theDict[0]);
    uint64_t v138 = *(void *)__str;
    sub_100058DB0(v157, "eval.mso");
    v139 = *(std::__shared_weak_count **)(a1 + 40);
    if (!v139 || (uint64_t v140 = *(void *)(a1 + 32), (v141 = std::__shared_weak_count::lock(v139)) == 0)) {
      sub_100088B9C();
    }
    v142 = v141;
    atomic_fetch_add_explicit(&v141->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v141);
    *(_OWORD *)long long buf = *(_OWORD *)v157;
    *(void *)&uint8_t buf[16] = v158;
    v157[0] = 0;
    v157[1] = 0;
    uint64_t v158 = 0;
    *(void *)&values[24] = 0;
    long long v143 = operator new(0x20uLL);
    void *v143 = off_1019EDB48;
    v143[1] = a1;
    v143[2] = v140;
    v143[3] = v142;
    *(void *)&values[24] = v143;
    (*(void (**)(const void **__return_ptr, uint64_t, unsigned char *, uint64_t, uint64_t, void, unsigned char *))(*(void *)v138 + 40))(&v179, v138, buf, 2, 1800000000, 0, values);
    sub_10003B34C(values);
    if ((buf[23] & 0x80000000) != 0) {
      operator delete(*(void **)buf);
    }
    long long v144 = v179;
    v179 = 0;
    uint64_t v145 = *(void *)(a1 + 432);
    *(void *)(a1 + 432) = v144;
    if (v145)
    {
      (*(void (**)(uint64_t))(*(void *)v145 + 8))(v145);
      long long v146 = v179;
      v179 = 0;
      if (v146) {
        (*(void (**)(const void *))(*(void *)v146 + 8))(v146);
      }
    }
    if (SHIBYTE(v158) < 0) {
      operator delete(v157[0]);
    }
    if (*(void *)&__str[8]) {
      sub_10004D2C8(*(std::__shared_weak_count **)&__str[8]);
    }
    if (theDict[1]) {
      sub_10004D2C8((std::__shared_weak_count *)theDict[1]);
    }
  }
LABEL_369:
  sub_10005CD2C((uint64_t)&v173, v174[0]);
  *(void *)values = v175;
  sub_1006019D0((void ***)values);
  sub_100602474((uint64_t)&v176, v177[0]);
}

void sub_1005F5608(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,void *a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,void *a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,char a59,uint64_t a60,uint64_t a61,char a62,uint64_t a63)
{
  if (SLOBYTE(STACK[0x347]) < 0) {
    operator delete((void *)STACK[0x330]);
  }
  sub_10004D2C8(v72);
  if (a72 < 0) {
    operator delete(a67);
  }
  sub_10005CD2C((uint64_t)&a56, (char *)a57);
  a56 = (uint64_t)&a59;
  sub_1006019D0((void ***)&a56);
  sub_100602474((uint64_t)&a62, (void *)a63);
  _Unwind_Resume(a1);
}

BOOL sub_1005F5A04(uint64_t a1)
{
  if ((*(uint64_t (**)(void))(**(void **)(a1 + 72) + 840))(*(void *)(a1 + 72)))
  {
    *(void *)long long buf = 0;
    uint64_t v14 = 0;
    uint64_t v15 = 0;
    (*(void (**)(uint8_t *__return_ptr))(**(void **)(a1 + 72) + 856))(buf);
    BOOL v2 = buf[0] != 0;
    if (buf[0])
    {
      uint64_t v4 = v14;
      uint64_t v3 = v15;
      *(void *)(a1 + 408) = v14;
      *(void *)(a1 + 416) = v3;
      uint64_t v5 = *(NSObject **)(a1 + 64);
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
      {
        int v9 = 134283777;
        uint64_t v10 = v4;
        __int16 v11 = 2049;
        uint64_t v12 = v3;
        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I Location acquired: lat, long = (%{private}f, %{private}f)", (uint8_t *)&v9, 0x16u);
      }
    }
    else
    {
      uint64_t v7 = *(NSObject **)(a1 + 64);
      if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
      {
        LOWORD(v9) = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "Latitude/Longitude are not available", (uint8_t *)&v9, 2u);
      }
    }
  }
  else
  {
    uint64_t v6 = *(NSObject **)(a1 + 64);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "Location is not available", buf, 2u);
    }
    return 0;
  }
  return v2;
}

void *sub_1005F5BD0(uint64_t a1)
{
  v39[0] = off_1019EE7A8;
  v39[1] = a1;
  unint64_t v40 = v39;
  long long v41 = 0uLL;
  uint64_t v42 = 0;
  uint64_t v2 = *(void *)(a1 + 504);
  uint64_t v3 = *(void *)(a1 + 512);
  while (v2 != v3)
  {
    if (subscriber::isSimSettled())
    {
      long long v47 = 0u;
      long long v48 = 0u;
      *(_OWORD *)long long buf = 0u;
      sub_100E63EA4((uint64_t)buf);
      uint64_t v4 = (_OWORD *)*((void *)&v41 + 1);
      if (*((void *)&v41 + 1) >= (unint64_t)v42)
      {
        uint64_t v6 = sub_1000D8CE8((uint64_t *)&v41, (long long *)buf);
      }
      else
      {
        if (SBYTE7(v47) < 0)
        {
          sub_10004FC84(*((unsigned char **)&v41 + 1), *(void **)buf, *(unint64_t *)&buf[8]);
        }
        else
        {
          long long v5 = *(_OWORD *)buf;
          *(void *)(*((void *)&v41 + 1) + 16) = v47;
          _OWORD *v4 = v5;
        }
        uint64_t v6 = (uint64_t)v4 + 24;
      }
      *((void *)&v41 + 1) = v6;
      if (SHIBYTE(v48) < 0) {
        operator delete(*((void **)&v47 + 1));
      }
      if (SBYTE7(v47) < 0) {
        operator delete(*(void **)buf);
      }
    }
    v2 += 168;
  }
  memset(buf, 0, sizeof(buf));
  *(void *)&long long v47 = 0;
  uint64_t v7 = *(void *)(a1 + 72);
  sub_100058DB0(v51, "315");
  sub_100058DB0(v37, "010");
  sub_100058DB0(&v34, "");
  sub_100058DB0(&v31, "");
  sub_100058DB0(__p, "");
  (*(void (**)(uint8_t *__return_ptr, uint64_t, void **, void **, void **, void **, void **))(*(void *)v7 + 1000))(buf, v7, v51, v37, &v34, &v31, __p);
  if (v30 < 0) {
    operator delete(__p[0]);
  }
  if (v33 < 0) {
    operator delete(v31);
  }
  if (v36 < 0) {
    operator delete(v34);
  }
  if (v38 < 0) {
    operator delete(v37[0]);
  }
  if (v52 < 0) {
    operator delete(v51[0]);
  }
  int v9 = (void **)*((void *)&v41 + 1);
  uint64_t v8 = (void **)v41;
  sub_1000C6BDC((uint64_t *)v51, (uint64_t)buf);
  if (v8 == v9)
  {
    BOOL v11 = 0;
  }
  else
  {
    do
    {
      uint64_t v10 = sub_10010E128((uint64_t)v51, v8);
      BOOL v11 = v10 != 0;
      if (v10) {
        break;
      }
      v8 += 3;
    }
    while (v8 != v9);
  }
  sub_10005CD2C((uint64_t)v51, (char *)v51[1]);
  sub_10005CD2C((uint64_t)buf, *(char **)&buf[8]);
  *(void *)long long buf = &v41;
  sub_100047F64((void ***)buf);
  if (!v11)
  {
    memset(buf, 0, sizeof(buf));
    *(void *)&long long v47 = 0;
    if (!v40) {
      sub_10007B600();
    }
    (*(void (**)(void *, uint8_t *))(*v40 + 48))(v40, buf);
    if (*(void *)buf)
    {
      *(void *)&uint8_t buf[8] = *(void *)buf;
      operator delete(*(void **)buf);
    }
    return sub_10041A970(v39);
  }
  (***(void (****)(uint8_t *__return_ptr))(a1 + 72))(buf);
  ServiceMap = (std::mutex *)Registry::getServiceMap(*(Registry **)buf);
  CFDictionaryRef v13 = ServiceMap;
  if (v14 < 0)
  {
    uint64_t v15 = (unsigned __int8 *)(v14 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v16 = 5381;
    do
    {
      uint64_t v14 = v16;
      unsigned int v17 = *v15++;
      uint64_t v16 = (33 * v16) ^ v17;
    }
    while (v17);
  }
  std::mutex::lock(ServiceMap);
  *(void *)&long long v41 = v14;
  CFBooleanRef v18 = sub_10004D37C(&v13[1].__m_.__sig, (unint64_t *)&v41);
  if (!v18)
  {
    uint64_t v20 = 0;
    goto LABEL_41;
  }
  uint64_t v20 = v18[3];
  int v19 = (std::__shared_weak_count *)v18[4];
  if (!v19)
  {
LABEL_41:
    std::mutex::unlock(v13);
    int v19 = 0;
    goto LABEL_42;
  }
  atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
  std::mutex::unlock(v13);
  atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v19);
LABEL_42:
  if (*(void *)&buf[8]) {
    sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
  }
  if (v20)
  {
    uint64_t v34 = 0;
    char v35 = 0;
    *(void *)long long buf = "CellularPlanPrivateNetworksController";
    sub_1002BFAE4((char **)buf, (dispatch_object_t *)(a1 + 48), &v34);
    (***(void (****)(uint8_t *__return_ptr))(a1 + 72))(buf);
    Registry::createRestModuleOneTimeUseMobileHelperConnection((uint64_t *)&v31, *(Registry **)buf);
    ctu::RestModule::connect();
    if (v32) {
      sub_10004D2C8(v32);
    }
    if (*(void *)&buf[8]) {
      sub_10004D2C8(*(std::__shared_weak_count **)&buf[8]);
    }
    rest::LocationCoordinate::LocationCoordinate((rest::LocationCoordinate *)__p, *(double *)(a1 + 408), *(double *)(a1 + 416));
    *(void *)&long long v41 = a1;
    *((void *)&v41 + 1) = v34;
    uint64_t v42 = v35;
    if (v35) {
      atomic_fetch_add_explicit(&v35->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    sub_10041F74C((uint64_t)v43, (uint64_t)v39);
    *(void *)&long long v44 = v20;
    *((void *)&v44 + 1) = v19;
    long long v45 = *(_OWORD *)(a1 + 408);
    rest::write_rest_value((rest *)__p, v21);
    sub_100058DB0(v37, "/helper/requests/get_iso_for_location");
    xpc_object_t v28 = xpc_null_create();
    *(_OWORD *)long long buf = v41;
    *(void *)&long long v47 = v42;
    *((void *)&v41 + 1) = 0;
    uint64_t v42 = 0;
    sub_10041F74C((uint64_t)&v47 + 8, (uint64_t)v43);
    long long v49 = v44;
    long long v44 = 0uLL;
    long long v50 = v45;
    double v53 = 0;
    uint64_t v22 = (char *)operator new(0x60uLL);
    *(void *)uint64_t v22 = off_1019EE838;
    *(_OWORD *)(v22 + 8) = *(_OWORD *)buf;
    *((void *)v22 + 3) = v47;
    *(void *)&uint8_t buf[8] = 0;
    *(void *)&long long v47 = 0;
    sub_10041F74C((uint64_t)(v22 + 32), (uint64_t)&v47 + 8);
    long long v23 = v49;
    long long v49 = 0uLL;
    long long v24 = v50;
    *((_OWORD *)v22 + 4) = v23;
    *((_OWORD *)v22 + 5) = v24;
    double v53 = v22;
    ctu::RestModule::sendRequest();
    sub_10003F600(v51);
    if (*((void *)&v49 + 1)) {
      sub_10004D2C8(*((std::__shared_weak_count **)&v49 + 1));
    }
    sub_10041A970((void *)&v47 + 1);
    if ((void)v47) {
      sub_10004D2C8((std::__shared_weak_count *)v47);
    }
    xpc_release(0);
    if (v38 < 0) {
      operator delete(v37[0]);
    }
    xpc_release(v28);
    if (*((void *)&v44 + 1)) {
      sub_10004D2C8(*((std::__shared_weak_count **)&v44 + 1));
    }
    sub_10041A970(v43);
    if (v42) {
      sub_10004D2C8(v42);
    }
    size_t v25 = v35;
    if (!v35) {
      return sub_10041A970(v39);
    }
LABEL_70:
    sub_10004D2C8(v25);
    return sub_10041A970(v39);
  }
  uint64_t v26 = *(NSObject **)(a1 + 64);
  if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_ERROR, "IsoMccCache is not available", buf, 2u);
  }
  memset(buf, 0, sizeof(buf));
  *(void *)&long long v47 = 0;
  if (!v40) {
    sub_10007B600();
  }
  (*(void (**)(void *, uint8_t *))(*v40 + 48))(v40, buf);
  if (*(void *)buf)
  {
    *(void *)&uint8_t buf[8] = *(void *)buf;
    operator delete(*(void **)buf);
  }
  if (v19)
  {
    size_t v25 = v19;
    goto LABEL_70;
  }
  return sub_10041A970(v39);
}

void sub_1005F6270(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t object, xpc_object_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,void *__p,uint64_t a30,int a31,__int16 a32,char a33,char a34,char a35,uint64_t a36,uint64_t a37,uint64_t a38,char a39,uint64_t a40)
{
  if (a2) {
    sub_10006A6AC(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1005F6464(uint64_t a1)
{
  if (*(char *)(a1 + 23) < 0) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void sub_1005F64A0(void *a1)
{
  uint64_t v2 = 0;
  *(_DWORD *)long long buf = 1;
  *(_WORD *)&uint8_t buf[4] = 0;
  *(_DWORD *)&uint8_t buf[8] = 2;
  *(_WORD *)&unsigned char buf[12] = 0;
  v21[0] = 0;
  v21[1] = 0;
  uint64_t v20 = (uint64_t *)v21;
  do
  {
    sub_10060B164((uint64_t *)&v20, (uint64_t *)v21, *(_DWORD *)&buf[v2], (uint64_t *)&buf[v2]);
    v2 += 8;
  }
  while (v2 != 16);
  uint64_t v3 = (long long *)a1[63];
  uint64_t v4 = (long long *)a1[64];
  if (v3 != v4)
  {
    long long v5 = (long long *)((char *)v3 + 72);
    do
    {
      if (subscriber::isSimReady())
      {
        *(void *)long long buf = v5;
        if (*((unsigned char *)sub_100602C14((uint64_t)(a1 + 27), (void **)v5, (long long **)buf) + 256))
        {
          *((unsigned char *)sub_10060B338(&v20, *((_DWORD *)v5 - 18), (_DWORD *)v5 - 18) + 32) = 1;
          if (*((char *)v5 + 23) < 0)
          {
            sub_10004FC84(__p, *(void **)v5, *((void *)v5 + 1));
          }
          else
          {
            long long v6 = *v5;
            uint64_t v19 = *((void *)v5 + 2);
            *(_OWORD *)std::string __p = v6;
          }
          char v7 = sub_1005F1348((uint64_t)a1, (long long *)__p);
          *((unsigned char *)sub_10060B338(&v20, *((_DWORD *)v5 - 18), (_DWORD *)v5 - 18) + 33) = v7 ^ 1;
          if (SHIBYTE(v19) < 0) {
            operator delete(__p[0]);
          }
          uint64_t v8 = a1[8];
          if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
          {
            int v9 = v5;
            if (*((char *)v5 + 23) < 0) {
              int v9 = *(void **)v5;
            }
            uint64_t v10 = sub_10060B338(&v20, *((_DWORD *)v5 - 18), (_DWORD *)v5 - 18);
            BOOL v11 = "";
            if (!*((unsigned char *)v10 + 33)) {
              BOOL v11 = "not ";
            }
            *(_DWORD *)long long buf = 136315394;
            *(void *)&uint8_t buf[4] = v9;
            *(_WORD *)&unsigned char buf[12] = 2080;
            *(void *)&buf[14] = v11;
            _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I %s is active PNW SIM, data usage is %sfree", buf, 0x16u);
          }
        }
      }
      uint64_t v12 = v5 + 6;
      long long v5 = (long long *)((char *)v5 + 168);
    }
    while (v12 != v4);
  }
  *(void *)&uint8_t buf[8] = a1 + 86;
  *(void *)long long buf = 1;
  v23[0] = 0;
  v23[1] = 0;
  *(void *)&uint8_t buf[16] = v23;
  CFDictionaryRef v13 = (void *)a1[90];
  uint64_t v14 = a1 + 91;
  if (v13 != v14)
  {
    do
    {
      sub_10060B164((uint64_t *)&buf[16], v23, *((_DWORD *)v13 + 7), (void *)((char *)v13 + 28));
      uint64_t v15 = (void *)v13[1];
      if (v15)
      {
        do
        {
          uint64_t v16 = v15;
          uint64_t v15 = (void *)*v15;
        }
        while (v15);
      }
      else
      {
        do
        {
          uint64_t v16 = (void *)v13[2];
          BOOL v17 = *v16 == (void)v13;
          CFDictionaryRef v13 = v16;
        }
        while (!v17);
      }
      CFDictionaryRef v13 = v16;
    }
    while (v16 != v14);
  }
  sub_10060B564((uint64_t **)&buf[16], v20, v21);
  sub_10060B3E4((uint64_t)buf);
  sub_1000346F8((uint64_t)&v20, v21[0]);
}

void sub_1005F676C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17, void *a18, uint64_t a19, char a20,uint64_t a21,uint64_t a22,uint64_t a23)
{
}

void sub_1005F67C8(uint64_t a1)
{
  v23[0] = 0;
  v23[1] = 0;
  uint64_t v24 = 0;
  sub_100058DB0(v23, "OffloadIdentifier");
  if ((void **)(a1 + 248) == sub_100046F68(a1 + 240, v23))
  {
    uint64_t v3 = *(NSObject **)(a1 + 64);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      LOWORD(buf) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "no offload profile present on device", (uint8_t *)&buf, 2u);
    }
  }
  else
  {
    uint64_t v22 = 0;
    long long v20 = 0u;
    long long v21 = 0u;
    long long v18 = 0u;
    long long v19 = 0u;
    long long v16 = 0u;
    long long v17 = 0u;
    long long buf = 0u;
    long long v15 = 0u;
    size_t v25 = v23;
    uint64_t v2 = sub_1006028B8(a1 + 240, v23, (long long **)&v25);
    sub_10006891C((uint64_t)&buf, (uint64_t)(v2 + 7));
    sub_10006891C((uint64_t)v4, (uint64_t)&buf);
    v26[0] = off_1019EDBC8;
    v26[1] = a1;
    void v26[3] = v26;
    sub_1005ED61C(a1, (uint64_t)v4, (uint64_t)v26);
    sub_10030D830(v26);
    sub_10005CD90((uint64_t)v13, v13[1]);
    if (v12 < 0) {
      operator delete(__p);
    }
    if (v10 < 0) {
      operator delete(v9);
    }
    if (v8 < 0) {
      operator delete(v7);
    }
    if (v6 < 0) {
      operator delete(v5);
    }
    sub_10005CD90((uint64_t)&v21, *((void **)&v21 + 1));
    if (SBYTE7(v20) < 0) {
      operator delete((void *)v19);
    }
    if (SHIBYTE(v18) < 0) {
      operator delete(*((void **)&v17 + 1));
    }
    if (SBYTE7(v17) < 0) {
      operator delete((void *)v16);
    }
    if (SHIBYTE(v15) < 0) {
      operator delete(*((void **)&buf + 1));
    }
  }
  if (SHIBYTE(v24) < 0) {
    operator delete(v23[0]);
  }
}

void sub_1005F69D4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27)
{
  sub_10030D830((void *)(v27 - 72));
  sub_1002F1208((uint64_t)&a10);
  sub_1002F1208((uint64_t)&a27);
  if (*(char *)(v27 - 81) < 0) {
    operator delete(*(void **)(v27 - 104));
  }
  _Unwind_Resume(a1);
}

void sub_1005F6A20(uint64_t a1, int a2)
{
  uint64_t v4 = *(void *)(a1 + 32);
  long long v5 = *(NSObject **)(v4 + 64);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    char v6 = (void *)(v4 + 440);
    if (*(char *)(v4 + 463) < 0) {
      char v6 = (void *)*v6;
    }
    char v7 = "False";
    if (a2) {
      char v7 = "True";
    }
    *(_DWORD *)int v9 = 136315394;
    *(void *)&void v9[4] = v6;
    *(_WORD *)&v9[12] = 2080;
    *(void *)&v9[14] = v7;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I fOffloadNeedTobeDeleted iccid %s delete success =? %s", v9, 0x16u);
  }
  if (a2)
  {
    *(void *)int v9 = 1;
    *(_OWORD *)&uint8_t v9[16] = 0u;
    uint64_t v10 = 0;
    *(void *)&v9[8] = v4 + 552;
    char v8 = (uint64_t **)sub_100346B40((uint64_t)&v9[16], v4 + 584);
    sub_10010F808(v8, (void **)(a1 + 40));
    if (*(char *)(v4 + 463) < 0)
    {
      **(unsigned char **)(v4 + 440) = 0;
      *(void *)(v4 + 448) = 0;
    }
    else
    {
      *(unsigned char *)(v4 + 440) = 0;
      *(unsigned char *)(v4 + 463) = 0;
    }
    sub_1005F67C8(v4);
    sub_100606180((uint64_t)v9);
  }
}

void sub_1005F6B68(_Unwind_Exception *exception_object)
{
}

uint64_t sub_1005F6B84(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 184) + 56))();
}

void sub_1005F6BAC(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 504);
  uint64_t v5 = *(void *)(a1 + 512);
  if (v4 != v5)
  {
    unint64_t v6 = 0;
    do
    {
      v6 += subscriber::isSimReady();
      v4 += 168;
    }
    while (v4 != v5);
    if (v6 >= 2)
    {
      char v7 = *(NSObject **)(a1 + 64);
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(__p[0]) = 0;
        char v8 = "#I Wont' trigger signUpForSIMService due to device is in DualSIM mode";
        int v9 = v7;
        uint32_t v10 = 2;
LABEL_20:
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, v8, (uint8_t *)__p, v10);
        return;
      }
      return;
    }
  }
  if (!*(void *)(a1 + 256)) {
    goto LABEL_11;
  }
  sub_100058DB0(__p, "OffloadIdentifier");
  BOOL v11 = sub_100046F68(a1 + 240, __p);
  if (SBYTE7(v54) < 0) {
    operator delete(__p[0]);
  }
  if ((void **)(a1 + 248) == v11)
  {
    long long v18 = *(NSObject **)(a1 + 64);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
    {
      long long v19 = *(void **)(a1 + 256);
      LODWORD(__p[0]) = 134217984;
      *(void **)((char *)__p + 4) = v19;
      char v8 = "#I Prevent offload install if private network profiles exists on device, current # of profiles [%zu]";
      int v9 = v18;
      uint32_t v10 = 12;
      goto LABEL_20;
    }
  }
  else
  {
LABEL_11:
    char v12 = *(std::__shared_weak_count **)(a1 + 96);
    if (v12)
    {
      CFDictionaryRef v13 = std::__shared_weak_count::lock(v12);
      if (v13)
      {
        uint64_t v14 = v13;
        uint64_t v15 = *(void *)(a1 + 88);
        if (v15)
        {
          LOBYTE(__p[0]) = 0;
          char v55 = 0;
          char v16 = (*(uint64_t (**)(uint64_t, void **))(*(void *)v15 + 56))(v15, __p);
          sub_10010B788((uint64_t)__p);
          if ((v16 & 2) == 0)
          {
            long long v17 = *(NSObject **)(a1 + 64);
            if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
            {
              LOWORD(buf.__r_.__value_.__l.__data_) = 0;
              _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I flow not supported for offload service", (uint8_t *)&buf, 2u);
            }
            sub_10004D2C8(v14);
            return;
          }
        }
        sub_10004D2C8(v14);
      }
    }
    uint64_t v20 = *(void *)(a1 + 504);
    uint64_t v21 = *(void *)(a1 + 512);
    if (*(char *)(a2 + 23) < 0) {
      sub_10004FC84(&__dst, *(void **)a2, *(void *)(a2 + 8));
    }
    else {
      std::string __dst = *(std::string *)a2;
    }
    if (v20 != v21)
    {
      while (1)
      {
        uint64_t v22 = *(unsigned __int8 *)(v20 + 95);
        if ((v22 & 0x80u) == 0) {
          uint64_t v23 = *(unsigned __int8 *)(v20 + 95);
        }
        else {
          uint64_t v23 = *(void *)(v20 + 80);
        }
        std::string::size_type size = HIBYTE(__dst.__r_.__value_.__r.__words[2]);
        if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
          std::string::size_type size = __dst.__r_.__value_.__l.__size_;
        }
        if (v23 == size)
        {
          if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            p_dst = &__dst;
          }
          else {
            p_dst = (std::string *)__dst.__r_.__value_.__r.__words[0];
          }
          if ((v22 & 0x80) != 0)
          {
            if (!memcmp(*(const void **)(v20 + 72), p_dst, *(void *)(v20 + 80)))
            {
LABEL_42:
              if (!subscriber::isEsimCapable()) {
                break;
              }
            }
          }
          else
          {
            if (!*(unsigned char *)(v20 + 95)) {
              goto LABEL_42;
            }
            uint64_t v26 = 0;
            while (*(unsigned __int8 *)(v20 + v26 + 72) == p_dst->__r_.__value_.__s.__data_[v26])
            {
              if (v22 == ++v26) {
                goto LABEL_42;
              }
            }
          }
        }
        v20 += 168;
        if (v20 == v21)
        {
          uint64_t v20 = v21;
          break;
        }
      }
    }
    uint64_t v27 = *(void *)(a1 + 512);
    if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__dst.__r_.__value_.__l.__data_);
    }
    BOOL v28 = v20 != v27;
    long long v52 = 0u;
    *(_OWORD *)&buf.__r_.__value_.__r.__words[1] = 0u;
    buf.__r_.__value_.__r.__words[0] = a1;
    if (*(char *)(a2 + 23) < 0)
    {
      sub_10004FC84(&buf.__r_.__value_.__s.__data_[8], *(void **)a2, *(void *)(a2 + 8));
    }
    else
    {
      *(_OWORD *)&buf.__r_.__value_.__r.__words[1] = *(_OWORD *)a2;
      *(void *)&long long v52 = *(void *)(a2 + 16);
    }
    BYTE8(v52) = v28;
    std::string::size_type v29 = *(void **)(a1 + 584);
    if (v29 == (void *)(a1 + 592)) {
      goto LABEL_62;
    }
    uint64_t v30 = 0;
    do
    {
      if (sub_1005FB4A8(a1, (uint64_t)(v29 + 4))) {
        v30 += sub_1005FB4A8(a1, (uint64_t)(v29 + 7));
      }
      long long v32 = (void *)v29[1];
      if (v32)
      {
        do
        {
          char v33 = v32;
          long long v32 = (void *)*v32;
        }
        while (v32);
      }
      else
      {
        do
        {
          char v33 = (void *)v29[2];
          BOOL v34 = *v33 == (void)v29;
          std::string::size_type v29 = v33;
        }
        while (!v34);
      }
      std::string::size_type v29 = v33;
    }
    while (v33 != (void *)(a1 + 592));
    if (v30 <= 2) {
LABEL_62:
    }
      BOOL v35 = ((*(uint64_t (**)(void))(**(void **)(buf.__r_.__value_.__r.__words[0] + 72) + 32))(*(void *)(buf.__r_.__value_.__r.__words[0] + 72)) & 1) != 0
         || BYTE8(v52) != 0;
    else {
      BOOL v35 = 0;
    }
    if (SBYTE7(v52) < 0)
    {
      operator delete((void *)buf.__r_.__value_.__l.__size_);
      if (!v35) {
        return;
      }
    }
    else if (!v35)
    {
      return;
    }
    *(_OWORD *)std::string __p = 0u;
    long long v54 = 0u;
    char v36 = *(_DWORD **)(a1 + 528);
    long long v37 = *(_DWORD **)(a1 + 536);
    if (v36 == v37)
    {
LABEL_72:
      char v38 = *(NSObject **)(a1 + 64);
      if (os_log_type_enabled(v38, OS_LOG_TYPE_ERROR))
      {
        if (*(char *)(a2 + 23) >= 0) {
          long long v41 = (void *)a2;
        }
        else {
          long long v41 = *(void **)a2;
        }
        LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
        *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v41;
        _os_log_error_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_ERROR, "Cannot getCSN for %s, skip signupForSIMService", (uint8_t *)&buf, 0xCu);
      }
    }
    else
    {
      while (*v36 != 2)
      {
        v36 += 22;
        if (v36 == v37) {
          goto LABEL_72;
        }
      }
      ctu::hex((uint64_t *)&buf, (ctu *)(v36 + 4), (const void *)0x10, v31);
      if (BYTE8(v54))
      {
        if (SBYTE7(v54) < 0) {
          operator delete(__p[0]);
        }
        *(_OWORD *)std::string __p = *(_OWORD *)&buf.__r_.__value_.__l.__data_;
        *(void *)&long long v54 = *((void *)&buf.__r_.__value_.__l + 2);
      }
      else
      {
        *(_OWORD *)std::string __p = *(_OWORD *)&buf.__r_.__value_.__l.__data_;
        *(void *)&long long v54 = *((void *)&buf.__r_.__value_.__l + 2);
        BYTE8(v54) = 1;
      }
      *(void *)&long long v52 = 1;
      char v39 = (*(uint64_t (**)(void))(**(void **)(a1 + 72) + 32))(*(void *)(a1 + 72));
      sub_100CDA4C8((void *)(a1 + 848), (uint64_t *)(a1 + 504), (uint64_t *)(a1 + 528), 0, v39, 0, &__dst);
      std::string buf = __dst;
      uint64_t v40 = *(void *)(a1 + 184);
      if (*(char *)(a2 + 23) < 0)
      {
        sub_10004FC84(v48, *(void **)a2, *(void *)(a2 + 8));
      }
      else
      {
        *(_OWORD *)long long v48 = *(_OWORD *)a2;
        uint64_t v49 = *(void *)(a2 + 16);
      }
      sub_1000593FC((uint64_t)v45, (long long *)__p);
      sub_1000593FC((uint64_t)v42, (long long *)&buf);
      (*(void (**)(uint64_t, void **, void **, void **, uint64_t))(*(void *)v40 + 48))(v40, v48, v45, v42, 1);
      if (v44 && v43 < 0) {
        operator delete(v42[0]);
      }
      if (v47 && v46 < 0) {
        operator delete(v45[0]);
      }
      if (SHIBYTE(v49) < 0) {
        operator delete(v48[0]);
      }
      if ((_BYTE)v52 && SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(buf.__r_.__value_.__l.__data_);
      }
      if (BYTE8(v54) && SBYTE7(v54) < 0) {
        operator delete(__p[0]);
      }
    }
  }
}

void sub_1005F7208(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,char a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,uint64_t a29,uint64_t a30,uint64_t a31,int a32,__int16 a33,char a34,char a35,uint64_t a36,void *__p,uint64_t a38,int a39,__int16 a40,char a41,char a42,char a43,int a44,__int16 a45,char a46,uint64_t a47,void *a48,void *a49,uint64_t a50,char a51,__int16 a52,char a53,char a54,char a55)
{
  if (a43 && a42 < 0) {
    operator delete(__p);
  }
  if (a51)
  {
    if (SHIBYTE(a50) < 0) {
      operator delete(a48);
    }
  }
  _Unwind_Resume(exception_object);
}

void sub_1005F72F4(uint64_t a1, long long *a2, char a3, int a4)
{
  void (***v23)(uint64_t *__return_ptr, void, long long *);
  char v24;
  uint64_t v25;
  uint64_t v26;
  void *v27;
  std::__shared_weak_count *v28;
  uint64_t v29;
  std::__shared_weak_count *v30;
  std::__shared_weak_count *v31;
  atomic_ullong *p_shared_weak_owners;
  NSObject *v33;
  uint64_t v34;
  void v35[6];
  std::__shared_weak_count *v36;
  long long v37;
  uint64_t v38;
  char v39;
  char v40;
  Registry *v41[2];
  long long v42;
  long long v43;
  long long v44;
  long long v45;
  uint64_t v46;
  long long v47;
  uint64_t v48;
  void *__p[2];
  char v50;
  uint64_t v51;
  std::__shared_weak_count *v52;
  long long __dst;
  uint64_t v54;
  Registry **v55;
  long long buf;
  long long v57;

  char v4 = a4;
  if (a4)
  {
    uint64_t v8 = sub_1005F9108(*(void (****)(Registry **__return_ptr))(a1 + 72));
    int v9 = *(uint64_t **)(a1 + 464);
    uint32_t v10 = *(uint64_t **)(a1 + 472);
    if ((unint64_t)((char *)v10 - (char *)v9) >= 0x28)
    {
      if (v8 - *v9 < 86401)
      {
        BOOL v11 = *(NSObject **)(a1 + 64);
        if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
        {
          sub_1005F796C((std::string *)v41, v9, v10);
          char v12 = (SBYTE7(v42) & 0x80u) == 0 ? v41 : (Registry **)v41[0];
          LODWORD(buf) = 136315138;
          *(void *)((char *)&buf + 4) = v12;
          _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I Max fetch geofence data reached: %s", (uint8_t *)&buf, 0xCu);
          if (SBYTE7(v42) < 0)
          {
            CFDictionaryRef v13 = v41[0];
LABEL_66:
            operator delete(v13);
            return;
          }
        }
        return;
      }
      size_t v14 = (char *)v10 - (char *)(v9 + 1);
      if (v14) {
        memmove(*(void **)(a1 + 464), v9 + 1, v14);
      }
      *(void *)(a1 + 472) = (char *)v9 + v14;
    }
  }
  std::string __dst = 0uLL;
  long long v54 = 0;
  if (*((char *)a2 + 23) < 0)
  {
    sub_10004FC84(&__dst, *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    std::string __dst = *a2;
    long long v54 = *((void *)a2 + 2);
  }
  uint64_t v51 = 0;
  long long v52 = 0;
  (***(void (****)(Registry **__return_ptr))(a1 + 72))(v41);
  ServiceMap = (std::mutex *)Registry::getServiceMap(v41[0]);
  char v16 = ServiceMap;
  if (v17 < 0)
  {
    long long v18 = (unsigned __int8 *)(v17 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v19 = 5381;
    do
    {
      uint64_t v17 = v19;
      unsigned int v20 = *v18++;
      uint64_t v19 = (33 * v19) ^ v20;
    }
    while (v20);
  }
  std::mutex::lock(ServiceMap);
  *(void *)&std::string buf = v17;
  uint64_t v21 = sub_10004D37C(&v16[1].__m_.__sig, (unint64_t *)&buf);
  if (v21)
  {
    uint64_t v23 = (void (***)(uint64_t *__return_ptr, void, long long *))v21[3];
    uint64_t v22 = (std::__shared_weak_count *)v21[4];
    if (v22)
    {
      atomic_fetch_add_explicit(&v22->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v16);
      atomic_fetch_add_explicit(&v22->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v22);
      uint64_t v24 = 0;
      goto LABEL_24;
    }
  }
  else
  {
    uint64_t v23 = 0;
  }
  std::mutex::unlock(v16);
  uint64_t v22 = 0;
  uint64_t v24 = 1;
LABEL_24:
  (**v23)(&v51, v23, &__dst);
  if ((v24 & 1) == 0) {
    sub_10004D2C8(v22);
  }
  if (v41[1]) {
    sub_10004D2C8((std::__shared_weak_count *)v41[1]);
  }
  std::string buf = 0u;
  long long v57 = 0u;
  if (*((char *)a2 + 23) < 0)
  {
    sub_10004FC84(&v47, *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    char v47 = *a2;
    long long v48 = *((void *)a2 + 2);
  }
  sub_1005F07F4((uint64_t)__p, a1, (void **)&v47);
  sub_1005F7A9C((uint64_t)v41, a1, __p);
  if (BYTE8(v57))
  {
    size_t v25 = buf;
    if ((void)buf)
    {
      uint64_t v26 = *((void *)&buf + 1);
      uint64_t v27 = (void *)buf;
      if (*((void *)&buf + 1) != (void)buf)
      {
        do
        {
          v26 -= 72;
          sub_10019F864(v26);
        }
        while (v26 != v25);
        uint64_t v27 = (void *)buf;
      }
      *((void *)&buf + 1) = v25;
      operator delete(v27);
    }
    std::string buf = *(_OWORD *)v41;
    *(void *)&long long v57 = v42;
    v41[1] = 0;
    *(void *)&uint64_t v42 = 0;
    v41[0] = 0;
  }
  else
  {
    std::string buf = *(_OWORD *)v41;
    *(void *)&long long v57 = v42;
    v41[1] = 0;
    *(void *)&uint64_t v42 = 0;
    v41[0] = 0;
    BYTE8(v57) = 1;
  }
  char v55 = v41;
  sub_10019F8BC((void ***)&v55);
  if (v50 < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v48) < 0) {
    operator delete((void *)v47);
  }
  *(_OWORD *)long long v41 = 0u;
  uint64_t v42 = 0u;
  char v46 = 0;
  char v44 = 0u;
  long long v45 = 0u;
  char v43 = 0u;
  HIDWORD(v41[0]) = 15;
  LOBYTE(v41[1]) = 1;
  HIDWORD(v41[1]) = 1;
  LOBYTE(v42) = 1;
  BOOL v28 = *(std::__shared_weak_count **)(a1 + 40);
  if (!v28 || (std::string::size_type v29 = *(void *)(a1 + 32), (v30 = std::__shared_weak_count::lock(v28)) == 0)) {
    sub_100088B9C();
  }
  unint64_t v31 = v30;
  p_shared_weak_owners = &v30->__shared_weak_owners_;
  atomic_fetch_add_explicit(&v30->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  sub_10004D2C8(v30);
  char v33 = *(NSObject **)(a1 + 64);
  if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(__p[0]) = 0;
    _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "#I send fetchGeofenceData request", (uint8_t *)__p, 2u);
  }
  BOOL v34 = v51;
  v35[0] = _NSConcreteStackBlock;
  v35[1] = 1174405120;
  std::string v35[2] = sub_1005F7DE4;
  void v35[3] = &unk_1019ED6A0;
  v35[4] = a1;
  v35[5] = v29;
  char v36 = v31;
  atomic_fetch_add_explicit(p_shared_weak_owners, 1uLL, memory_order_relaxed);
  char v39 = v4;
  uint64_t v40 = a3;
  if (*((char *)a2 + 23) < 0)
  {
    sub_10004FC84(&v37, *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v37 = *a2;
    char v38 = *((void *)a2 + 2);
  }
  __p[0] = v35;
  (*(void (**)(uint64_t, uint64_t, Registry **, long long *, uint64_t, void **))(*(void *)v34 + 208))(v34, 10, v41, &buf, a1 + 48, __p);
  if (SHIBYTE(v38) < 0) {
    operator delete((void *)v37);
  }
  if (v36) {
    std::__shared_weak_count::__release_weak(v36);
  }
  std::__shared_weak_count::__release_weak(v31);
  if ((_BYTE)v46 && SHIBYTE(v45) < 0) {
    operator delete(*((void **)&v44 + 1));
  }
  if ((_BYTE)v44 && SHIBYTE(v43) < 0) {
    operator delete(*((void **)&v42 + 1));
  }
  if (BYTE8(v57))
  {
    v41[0] = (Registry *)&buf;
    sub_10019F8BC((void ***)v41);
  }
  if (v52) {
    sub_10004D2C8(v52);
  }
  if (SHIBYTE(v54) < 0)
  {
    CFDictionaryRef v13 = (Registry *)__dst;
    goto LABEL_66;
  }
}

void sub_1005F7874(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,void *a36,uint64_t a37,int a38,__int16 a39,char a40,char a41,uint64_t a42,void *a43,uint64_t a44,int a45,__int16 a46,char a47,char a48)
{
  if (a16) {
    std::__shared_weak_count::__release_weak(a16);
  }
  std::__shared_weak_count::__release_weak(v48);
  sub_10016A3E8((uint64_t)&a24);
  if (*(unsigned char *)(v49 - 120))
  {
    a24 = v49 - 144;
    sub_10019F8BC((void ***)&a24);
  }
  uint64_t v51 = *(std::__shared_weak_count **)(v49 - 184);
  if (v51) {
    sub_10004D2C8(v51);
  }
  if (*(char *)(v49 - 153) < 0) {
    operator delete(*(void **)(v49 - 176));
  }
  _Unwind_Resume(a1);
}

void sub_1005F796C(std::string *a1, uint64_t *a2, uint64_t *a3)
{
  a1->__r_.__value_.__r.__words[0] = 0;
  a1->__r_.__value_.__l.__size_ = 0;
  a1->__r_.__value_.__r.__words[2] = 0;
  if (a2 != a3)
  {
    std::to_string(&v9, *a2);
    *a1 = v9;
    for (uint64_t i = a2 + 1; i != a3; ++i)
    {
      *((unsigned char *)&v9.__r_.__value_.__s + 23) = 1;
      LOWORD(v9.__r_.__value_.__l.__data_) = 44;
      std::string::append(a1, (const std::string::value_type *)&v9, 1uLL);
      if (SHIBYTE(v9.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v9.__r_.__value_.__l.__data_);
      }
      std::to_string(&v9, *i);
      if ((v9.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        char v7 = &v9;
      }
      else {
        char v7 = (std::string *)v9.__r_.__value_.__r.__words[0];
      }
      if ((v9.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string::size_type size = HIBYTE(v9.__r_.__value_.__r.__words[2]);
      }
      else {
        std::string::size_type size = v9.__r_.__value_.__l.__size_;
      }
      std::string::append(a1, (const std::string::value_type *)v7, size);
      if (SHIBYTE(v9.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v9.__r_.__value_.__l.__data_);
      }
    }
  }
}

void sub_1005F7A60(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (*(char *)(v15 + 23) < 0) {
    operator delete(*(void **)v15);
  }
  _Unwind_Resume(exception_object);
}

void sub_1005F7A9C(uint64_t a1, uint64_t a2, void **a3)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  uint64_t v6 = a2 + 216;
  uint64_t v27 = 0;
  long long v25 = 0u;
  long long v26 = 0u;
  memset(v24, 0, sizeof(v24));
  if ((void **)(a2 + 224) != sub_100046F68(a2 + 216, a3))
  {
    __p[0] = 0;
    __p[1] = 0;
    uint64_t v23 = 0;
    sub_100058DB0(__p, "OffloadIdentifier");
    if ((void **)(a2 + 248) != sub_100046F68(a2 + 240, __p))
    {
      uint64_t v7 = sub_10005DDEC(v6, a3);
      uint64_t v8 = sub_10005DDEC(a2 + 240, __p);
      if (*(unsigned char *)(v7 + 200))
      {
        uint64_t v9 = v8;
        uint64_t v10 = *(unsigned __int8 *)(v8 + 31);
        if ((v10 & 0x80u) != 0) {
          uint64_t v10 = *(void *)(v8 + 16);
        }
        if (v10)
        {
          std::string::operator=((std::string *)v24, (const std::string *)(v8 + 8));
          std::string::operator=((std::string *)&v24[24], (const std::string *)(v9 + 32));
          unint64_t v11 = *(void *)(a1 + 16);
          unint64_t v12 = *(void *)(a1 + 8);
          if (v12 >= v11)
          {
            unint64_t v14 = 0x8E38E38E38E38E39 * ((uint64_t)(v12 - *(void *)a1) >> 3);
            if (v14 + 1 > 0x38E38E38E38E38ELL) {
              sub_10006A748();
            }
            unint64_t v15 = 0x8E38E38E38E38E39 * ((uint64_t)(v11 - *(void *)a1) >> 3);
            uint64_t v16 = 2 * v15;
            if (2 * v15 <= v14 + 1) {
              uint64_t v16 = v14 + 1;
            }
            if (v15 >= 0x1C71C71C71C71C7) {
              unint64_t v17 = 0x38E38E38E38E38ELL;
            }
            else {
              unint64_t v17 = v16;
            }
            uint64_t v30 = a1 + 16;
            if (v17) {
              long long v18 = (char *)sub_10016ACDC(a1 + 16, v17);
            }
            else {
              long long v18 = 0;
            }
            *(void *)std::string buf = v18;
            *(void *)&uint8_t buf[8] = &v18[72 * v14];
            *(void *)&uint8_t buf[16] = *(void *)&buf[8];
            std::string::size_type v29 = &v18[72 * v17];
            sub_10019F464(*(char **)&buf[8], (long long *)v24);
            *(void *)&buf[16] += 72;
            sub_100601AD8((uint64_t *)a1, buf);
            unint64_t v13 = *(void *)(a1 + 8);
            sub_100601B94((uint64_t)buf);
          }
          else
          {
            sub_10019F464(*(char **)(a1 + 8), (long long *)v24);
            unint64_t v13 = v12 + 72;
            *(void *)(a1 + 8) = v13;
          }
          *(void *)(a1 + 8) = v13;
          uint64_t v19 = *(NSObject **)(a2 + 64);
          if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
          {
            unsigned int v20 = v24;
            if (v24[23] < 0) {
              unsigned int v20 = *(unsigned char **)v24;
            }
            if (v25 >= 0) {
              uint64_t v21 = &v24[24];
            }
            else {
              uint64_t v21 = *(unsigned char **)&v24[24];
            }
            *(_DWORD *)std::string buf = 136315394;
            *(void *)&uint8_t buf[4] = v20;
            *(_WORD *)&unsigned char buf[12] = 2080;
            *(void *)&buf[14] = v21;
            _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#I Found current config profile with profile name and version: %s %s", buf, 0x16u);
          }
        }
      }
    }
    if (SHIBYTE(v23) < 0) {
      operator delete(__p[0]);
    }
  }
  *(void *)std::string buf = &v26;
  sub_10019F7C0((void ***)buf);
  if (SHIBYTE(v25) < 0) {
    operator delete(*(void **)&v24[24]);
  }
  if ((v24[23] & 0x80000000) != 0) {
    operator delete(*(void **)v24);
  }
}

void sub_1005F7D8C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16)
{
  *(void *)(v16 + 8) = v17;
  if (a15 < 0) {
    operator delete(__p);
  }
  sub_1005F927C((uint64_t)&a16);
  a16 = v16;
  sub_10019F8BC((void ***)&a16);
  _Unwind_Resume(a1);
}

void sub_1005F7DE4(uint64_t a1, uint64_t a2, int a3)
{
  void (***v52)(std::string *__return_ptr);
  NSObject *v53;
  void (***v54)(std::string *__return_ptr);
  std::__shared_weak_count *v55;
  uint64_t v56;
  std::__shared_weak_count *v57;
  const void *v58;
  long long v59;
  std::__shared_weak_count *v60;
  _OWORD *v61;
  uint64_t v62;
  NSObject *v63;
  long long v64;
  uint64_t v65;
  uint64_t v66;
  NSObject *v67;
  uint64_t v68;
  char v69;
  std::__shared_weak_count *v70;
  std::__shared_weak_count *v71;
  std::__shared_weak_count *v72;
  dispatch_object_t object;
  uint64_t v74;
  uint64_t v75;
  std::string __str[2];
  long long v77;
  uint64_t v78;
  CFTypeRef cf;
  std::__shared_weak_count *v80;
  CFTypeRef *p_cf;
  unsigned char v82[32];
  long long v83;
  long long __p;
  uint64_t v85;
  char v86;
  void *v87;
  char v88;
  void *v89[4];
  long long buf;
  long long v91;
  long long v92;
  long long v93;
  long long v94;
  long long v95;
  long long v96;
  long long v97;
  uint64_t v98;

  char v4 = *(std::__shared_weak_count **)(a1 + 48);
  if (v4)
  {
    uint64_t v7 = *(void *)(a1 + 32);
    uint64_t v8 = std::__shared_weak_count::lock(v4);
    if (v8)
    {
      uint64_t v9 = v8;
      uint64_t v10 = *(std::__shared_weak_count **)(a1 + 40);
      if (!v10)
      {
LABEL_122:
        sub_10004D2C8(v9);
        return;
      }
      if (!*(unsigned char *)(a1 + 80))
      {
LABEL_46:
        char v43 = *(NSObject **)(v7 + 64);
        if (os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT))
        {
          char v44 = "False";
          if (a3) {
            char v44 = "True";
          }
          LODWORD(buf) = 136315138;
          *(void *)((char *)&buf + 4) = v44;
          _os_log_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_DEFAULT, "#I getGeofenceDataWithCallback isSuccess %s", (uint8_t *)&buf, 0xCu);
        }
        if (a3 && (long long v45 = *(uint64_t **)(*(void *)a2 + 8)) != 0)
        {
          dispatch_object_t object = 0;
          char v74 = 0;
          uint64_t v75 = 0;
          sub_10019F358(&object, *v45, v45[1], 0x8E38E38E38E38E39 * ((v45[1] - *v45) >> 3));
          shared_weak_owners = v10[2].__shared_weak_owners_;
          if (os_log_type_enabled(shared_weak_owners, OS_LOG_TYPE_DEFAULT))
          {
            LODWORD(buf) = 134217984;
            *(void *)((char *)&buf + 4) = 0x8E38E38E38E38E39 * ((v74 - (uint64_t)object) >> 3);
            _os_log_impl((void *)&_mh_execute_header, shared_weak_owners, OS_LOG_TYPE_DEFAULT, "#I getGeofenceData profiles size= %lu", (uint8_t *)&buf, 0xCu);
          }
          dispatch_object_t v47 = object;
          if (v74 - (void)object == 72)
          {
            char v78 = 0;
            int v77 = 0u;
            memset(__str, 0, sizeof(__str));
            if (SHIBYTE(object[2].isa) < 0)
            {
              sub_10004FC84(__str, object->isa, (unint64_t)object[1].isa);
            }
            else
            {
              long long v48 = *(_OWORD *)&object->isa;
              __str[0].__r_.__value_.__r.__words[2] = (std::string::size_type)object[2].isa;
              *(_OWORD *)&__str[0].__r_.__value_.__l.__data_ = v48;
            }
            if (SHIBYTE(v47[5].isa) < 0)
            {
              sub_10004FC84(&__str[1], v47[3].isa, (unint64_t)v47[4].isa);
            }
            else
            {
              long long v64 = *(_OWORD *)&v47[3].isa;
              __str[1].__r_.__value_.__r.__words[2] = (std::string::size_type)v47[5].isa;
              *(_OWORD *)&__str[1].__r_.__value_.__l.__data_ = v64;
            }
            int v77 = 0uLL;
            char v78 = 0;
            sub_10019F548(&v77, (uint64_t)v47[6].isa, (uint64_t)v47[7].isa, 0xAAAAAAAAAAAAAAABLL * ((v47[7].isa - v47[6].isa) >> 4));
            long long v98 = 0;
            long long v96 = 0u;
            uint64_t v97 = 0u;
            uint64_t v94 = 0u;
            CFDictionaryRef v95 = 0u;
            long long v92 = 0u;
            unint64_t v93 = 0u;
            std::string buf = 0u;
            uint64_t v91 = 0u;
            sub_100058DB0((void *)&v93 + 1, "");
            sub_100058DB0(&v95, "");
            WORD4(v96) = 0;
            HIDWORD(v96) = 0;
            *((void *)&v97 + 1) = 0;
            long long v98 = 0;
            *(void *)&uint64_t v97 = (char *)&v97 + 8;
            std::string::operator=((std::string *)((char *)&buf + 8), __str);
            std::string::operator=((std::string *)&v92, &__str[1]);
            LODWORD(buf) = 2;
            unint64_t v65 = *((void *)&v77 + 1);
            char v66 = v77;
            if (*((void *)&v77 + 1) != (void)v77
              && 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((void *)&v77 + 1) - v77) >> 4) <= 0x3E80)
            {
              do
              {
                CFDictionaryRef v85 = 0;
                uint64_t v83 = 0u;
                std::string __p = 0u;
                memset(v82, 0, sizeof(v82));
                *(void *)&v82[16] = *(void *)(v66 + 16);
                *(_OWORD *)CFDictionaryRef v82 = *(_OWORD *)v66;
                std::string::operator=((std::string *)&v82[24], (const std::string *)(v66 + 24));
                sub_100606AD8((uint64_t **)&v97, (void **)&v82[24], (long long *)&v82[24], (long long *)v82);
                if (SHIBYTE(v85) < 0) {
                  operator delete((void *)__p);
                }
                if (SHIBYTE(v83) < 0) {
                  operator delete(*(void **)&v82[24]);
                }
                v66 += 48;
              }
              while (v66 != v65);
            }
            uint64_t v67 = v10[2].__shared_weak_owners_;
            if (os_log_type_enabled(v67, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)CFDictionaryRef v82 = 134218240;
              *(void *)&v82[4] = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((void *)&v77 + 1) - v77) >> 4);
              *(_WORD *)&v82[12] = 2048;
              *(void *)&v82[14] = 16000;
              _os_log_impl((void *)&_mh_execute_header, v67, OS_LOG_TYPE_DEFAULT, "#I Received Geofence list size=%lu, upper limit of geofence size is %lu", v82, 0x16u);
            }
            sub_10006891C((uint64_t)v82, (uint64_t)&buf);
            CFTypeRef cf = off_1019EDD68;
            uint64_t v80 = v10;
            p_CFTypeRef cf = &cf;
            sub_1005ECC70((uint64_t)v10, (uint64_t)v82, (uint64_t)&cf);
            sub_10030D830(&cf);
            sub_10005CD90((uint64_t)v89, v89[1]);
            if (v88 < 0) {
              operator delete(v87);
            }
            if (v86 < 0) {
              operator delete(*((void **)&__p + 1));
            }
            if (SBYTE7(__p) < 0) {
              operator delete((void *)v83);
            }
            if ((v82[31] & 0x80000000) != 0) {
              operator delete(*(void **)&v82[8]);
            }
            sub_10005CD90((uint64_t)&v97, *((void **)&v97 + 1));
            if (SBYTE7(v96) < 0) {
              operator delete((void *)v95);
            }
            if (SHIBYTE(v94) < 0) {
              operator delete(*((void **)&v93 + 1));
            }
            if (SBYTE7(v93) < 0) {
              operator delete((void *)v92);
            }
            if (SHIBYTE(v91) < 0) {
              operator delete(*((void **)&buf + 1));
            }
            *(void *)&std::string buf = &v77;
            sub_10019F7C0((void ***)&buf);
            if (SHIBYTE(__str[1].__r_.__value_.__r.__words[2]) < 0) {
              operator delete(__str[1].__r_.__value_.__l.__data_);
            }
            if (SHIBYTE(__str[0].__r_.__value_.__r.__words[2]) < 0) {
              operator delete(__str[0].__r_.__value_.__l.__data_);
            }
          }
          else
          {
            unint64_t v63 = v10[2].__shared_weak_owners_;
            if (os_log_type_enabled(v63, OS_LOG_TYPE_ERROR))
            {
              LOWORD(buf) = 0;
              _os_log_error_impl((void *)&_mh_execute_header, v63, OS_LOG_TYPE_ERROR, "No change in geofence profiles from carrier entitlement", (uint8_t *)&buf, 2u);
            }
          }
          uint64_t v68 = *(void *)(v7 + 200);
          if (v68) {
            (*(void (**)(uint64_t, uint64_t))(*(void *)v68 + 40))(v68, 257);
          }
          *(void *)&std::string buf = &object;
          sub_10019F8BC((void ***)&buf);
        }
        else if (*(unsigned char *)(a1 + 81) && !*(void *)(v7 + 200))
        {
          uint64_t v49 = a1 + 56;
          long long v50 = *(NSObject **)(v7 + 64);
          if (os_log_type_enabled(v50, OS_LOG_TYPE_DEFAULT))
          {
            if (*(char *)(a1 + 79) >= 0) {
              uint64_t v51 = a1 + 56;
            }
            else {
              uint64_t v51 = *(void *)(a1 + 56);
            }
            LODWORD(buf) = 136315138;
            *(void *)((char *)&buf + 4) = v51;
            _os_log_impl((void *)&_mh_execute_header, v50, OS_LOG_TYPE_DEFAULT, "#I scheduleRetry for %s", (uint8_t *)&buf, 0xCu);
          }
          long long v52 = *(void (****)(std::string *__return_ptr))(v7 + 72);
          double v53 = *(NSObject **)(v7 + 48);
          dispatch_object_t object = v53;
          long long v54 = v52;
          if (v53)
          {
            dispatch_retain(v53);
            long long v54 = *(void (****)(std::string *__return_ptr))(v7 + 72);
          }
          (**v54)(__str);
          *(_OWORD *)CFDictionaryRef v82 = *(_OWORD *)&__str[0].__r_.__value_.__l.__data_;
          *(_OWORD *)&__str[0].__r_.__value_.__l.__data_ = 0uLL;
          char v55 = *(std::__shared_weak_count **)(v7 + 40);
          if (!v55 || (uint64_t v56 = *(void *)(v7 + 32), (v57 = std::__shared_weak_count::lock(v55)) == 0)) {
            sub_100088B9C();
          }
          unint64_t v58 = (const void *)(v56 + 16);
          if (!v56) {
            unint64_t v58 = 0;
          }
          CFTypeRef cf = v58;
          uint64_t v80 = v57;
          ((void (*)(long long *__return_ptr, void (***)(std::string *__return_ptr), dispatch_object_t *, unsigned char *, CFTypeRef *, uint64_t, uint64_t))(*v52)[88])(&buf, v52, &object, v82, &cf, v49, 10);
          unint64_t v59 = buf;
          std::string buf = 0uLL;
          unint64_t v60 = *(std::__shared_weak_count **)(v7 + 208);
          *(_OWORD *)(v7 + 200) = v59;
          if (v60)
          {
            sub_10004D2C8(v60);
            if (*((void *)&buf + 1)) {
              sub_10004D2C8(*((std::__shared_weak_count **)&buf + 1));
            }
          }
          if (v80) {
            sub_10004D2C8(v80);
          }
          if (*(void *)&v82[8]) {
            sub_10004D2C8(*(std::__shared_weak_count **)&v82[8]);
          }
          if (__str[0].__r_.__value_.__l.__size_) {
            sub_10004D2C8((std::__shared_weak_count *)__str[0].__r_.__value_.__l.__size_);
          }
          if (object) {
            dispatch_release(object);
          }
          uint64_t v61 = operator new(0x28uLL);
          *uint64_t v61 = *(_OWORD *)"<";
          v61[1] = unk_1014C7220;
          *((void *)v61 + 4) = 1800;
          uint64_t v62 = *(void *)(v7 + 200);
          *(void *)&uint64_t v91 = 0;
          std::string buf = 0uLL;
          sub_10015C7D4(&buf, v61, (uint64_t)v61 + 40, 5uLL);
          (*(void (**)(uint64_t, long long *))(*(void *)v62 + 16))(v62, &buf);
          if ((void)buf)
          {
            *((void *)&buf + 1) = buf;
            operator delete((void *)buf);
          }
          (*(void (**)(void))(**(void **)(v7 + 200) + 24))(*(void *)(v7 + 200));
          operator delete(v61);
        }
        goto LABEL_122;
      }
      long long v72 = *(std::__shared_weak_count **)(a1 + 40);
      (***(void (****)(long long *__return_ptr))(v7 + 72))(&buf);
      ServiceMap = (std::mutex *)Registry::getServiceMap((Registry *)buf);
      unint64_t v12 = ServiceMap;
      if (v13 < 0)
      {
        unint64_t v14 = (unsigned __int8 *)(v13 & 0x7FFFFFFFFFFFFFFFLL);
        uint64_t v15 = 5381;
        do
        {
          uint64_t v13 = v15;
          unsigned int v16 = *v14++;
          uint64_t v15 = (33 * v15) ^ v16;
        }
        while (v16);
      }
      std::mutex::lock(ServiceMap);
      *(void *)CFDictionaryRef v82 = v13;
      uint64_t v17 = sub_10004D37C(&v12[1].__m_.__sig, (unint64_t *)v82);
      if (v17)
      {
        uint64_t v18 = v17[3];
        uint64_t v19 = (std::__shared_weak_count *)v17[4];
        if (v19)
        {
          atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
          std::mutex::unlock(v12);
          atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
          uint64_t v71 = v19;
          sub_10004D2C8(v19);
          char v20 = 0;
LABEL_13:
          uint64_t v10 = v72;
          if (*((void *)&buf + 1)) {
            sub_10004D2C8(*((std::__shared_weak_count **)&buf + 1));
          }
          if (v18)
          {
            __str[0].__r_.__value_.__r.__words[0] = 0;
            long long v70 = v9;
            CFMutableArrayRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
            if (Mutable)
            {
              std::string::size_type v22 = __str[0].__r_.__value_.__r.__words[0];
              __str[0].__r_.__value_.__r.__words[0] = (std::string::size_type)Mutable;
              *(void *)&std::string buf = v22;
              sub_1000440D4((const void **)&buf);
            }
            uint64_t v23 = sub_1005F9108(*(void (****)(Registry **__return_ptr))(v7 + 72));
            uint64_t v24 = v23;
            long long v25 = *(uint64_t **)(v7 + 472);
            unint64_t v26 = *(void *)(v7 + 480);
            uint64_t v69 = v20;
            if ((unint64_t)v25 >= v26)
            {
              std::string::size_type v29 = *(uint64_t **)(v7 + 464);
              uint64_t v30 = v25 - v29;
              if ((unint64_t)(v30 + 1) >> 61) {
                sub_10006A748();
              }
              unint64_t v31 = v26 - (void)v29;
              unint64_t v32 = (uint64_t)(v26 - (void)v29) >> 2;
              if (v32 <= v30 + 1) {
                unint64_t v32 = v30 + 1;
              }
              if (v31 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v33 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v33 = v32;
              }
              if (v33)
              {
                BOOL v34 = (char *)sub_10004EF74(v7 + 480, v33);
                std::string::size_type v29 = *(uint64_t **)(v7 + 464);
                long long v25 = *(uint64_t **)(v7 + 472);
              }
              else
              {
                BOOL v34 = 0;
              }
              BOOL v35 = (uint64_t *)&v34[8 * v30];
              char v36 = &v34[8 * v33];
              *BOOL v35 = v24;
              uint64_t v27 = v35 + 1;
              while (v25 != v29)
              {
                uint64_t v37 = *--v25;
                *--BOOL v35 = v37;
              }
              *(void *)(v7 + 464) = v35;
              *(void *)(v7 + 472) = v27;
              *(void *)(v7 + 480) = v36;
              if (v29) {
                operator delete(v29);
              }
            }
            else
            {
              *long long v25 = v23;
              uint64_t v27 = v25 + 1;
            }
            *(void *)(v7 + 472) = v27;
            for (uint64_t i = *(uint64_t **)(v7 + 464); i != v27; ++i)
            {
              uint64_t v39 = *i;
              *(void *)CFDictionaryRef v82 = 0;
              *(void *)&std::string buf = v39;
              CFNumberRef v40 = CFNumberCreate(kCFAllocatorDefault, kCFNumberLongLongType, &buf);
              if (v40)
              {
                uint64_t v41 = *(void *)v82;
                *(void *)CFDictionaryRef v82 = v40;
                *(void *)&std::string buf = v41;
                sub_1000570E8((const void **)&buf);
              }
              CFTypeRef cf = *(CFTypeRef *)v82;
              *(void *)CFDictionaryRef v82 = 0;
              sub_1000570E8((const void **)v82);
              CFTypeRef v42 = cf;
              *(void *)&std::string buf = cf;
              if (cf)
              {
                CFRetain(cf);
                CFArrayAppendValue((CFMutableArrayRef)__str[0].__r_.__value_.__l.__data_, v42);
              }
              sub_10010F494((const void **)&buf);
              sub_1000570E8(&cf);
            }
            char v20 = v69;
            (*(void (**)(uint64_t, const __CFString *, std::string::size_type, void, const CFStringRef, const CFStringRef))(*(void *)v18 + 16))(v18, @"RetrieveGeofenceDataRecords", __str[0].__r_.__value_.__r.__words[0], kCommCenterPreferencesNoBackupAppID, kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
            sub_1000440D4((const void **)&__str[0].__r_.__value_.__l.__data_);
            uint64_t v9 = v70;
            uint64_t v10 = v72;
          }
          else
          {
            BOOL v28 = *(NSObject **)(v7 + 64);
            if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
            {
              LOWORD(buf) = 0;
              _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "#I Cannot get Preference", (uint8_t *)&buf, 2u);
            }
          }
          if ((v20 & 1) == 0) {
            sub_10004D2C8(v71);
          }
          goto LABEL_46;
        }
      }
      else
      {
        uint64_t v18 = 0;
      }
      std::mutex::unlock(v12);
      uint64_t v71 = 0;
      char v20 = 1;
      goto LABEL_13;
    }
  }
}

void sub_1005F88C8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, int a10, int a11, uint64_t a12, uint64_t a13, uint64_t a14, dispatch_object_t object, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23,void *a24,uint64_t a25,int a26,__int16 a27,char a28,char a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,char a34,uint64_t a35,uint64_t a36,uint64_t a37,char a38,uint64_t a39)
{
  if (a23 < 0) {
    operator delete(__p);
  }
  *(void *)(v40 - 240) = &object;
  sub_10019F8BC((void ***)(v40 - 240));
  sub_10004D2C8(v39);
  _Unwind_Resume(a1);
}

unsigned char *sub_1005F8AD0(void *a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 48);
  a1[5] = *(void *)(a2 + 40);
  a1[6] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  uint64_t result = a1 + 7;
  if (*(char *)(a2 + 79) < 0) {
    return sub_10004FC84(result, *(void **)(a2 + 56), *(void *)(a2 + 64));
  }
  long long v5 = *(_OWORD *)(a2 + 56);
  a1[9] = *(void *)(a2 + 72);
  *(_OWORD *)uint64_t result = v5;
  return result;
}

void sub_1005F8B38(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(std::__shared_weak_count **)(v1 + 48);
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  _Unwind_Resume(exception_object);
}

void sub_1005F8B50(uint64_t a1)
{
  if (*(char *)(a1 + 79) < 0) {
    operator delete(*(void **)(a1 + 56));
  }
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 48);
  if (v2)
  {
    std::__shared_weak_count::__release_weak(v2);
  }
}

void sub_1005F8BA4(void *a1, uint64_t a2, uint64_t *a3)
{
  long long v5 = a1[8];
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v6 = printers::asString();
    if (*((char *)a3 + 23) >= 0) {
      uint64_t v7 = a3;
    }
    else {
      uint64_t v7 = (uint64_t *)*a3;
    }
    *(_DWORD *)std::string buf = 136315394;
    uint64_t v10 = v6;
    __int16 v11 = 2080;
    unint64_t v12 = v7;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I offloadRecovery end with Success?=%s for %s", buf, 0x16u);
  }
  uint64_t v8 = (std::__shared_weak_count *)a1[26];
  a1[25] = 0;
  a1[26] = 0;
  if (v8) {
    sub_10004D2C8(v8);
  }
}

void sub_1005F8C84(uint64_t a1, unsigned __int16 a2, uint64_t *a3)
{
}

void sub_1005F8C90(uint64_t a1, uint64_t a2)
{
  if (*(char *)(a2 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)a2;
    uint64_t v4 = *(void *)(a2 + 16);
  }
  sub_1005F72F4(a1, (long long *)__p, 0, 0);
  if (SHIBYTE(v4) < 0) {
    operator delete(__p[0]);
  }
}

void sub_1005F8D08(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1005F8D24(uint64_t a1, uint64_t a2)
{
}

void sub_1005F8D2C(uint64_t a1, uint64_t a2)
{
  void (***v12)(uint64_t *__return_ptr, void, void **);
  char v13;
  uint64_t v14;
  std::__shared_weak_count *v15;
  uint64_t v16;
  std::__shared_weak_count *v17;
  std::__shared_weak_count *v18;
  void *v19;
  NSObject *v20;
  void *v21;
  uint64_t v22;
  std::__shared_weak_count *v23;
  void *__p[2];
  uint64_t v25;
  unint64_t v26;
  long long buf;
  long long *p_buf;
  void v29[3];
  void *v30;

  __p[0] = 0;
  __p[1] = 0;
  long long v25 = 0;
  if (*(char *)(a2 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)a2;
    long long v25 = *(void *)(a2 + 16);
  }
  std::string::size_type v22 = 0;
  uint64_t v23 = 0;
  (***(void (****)(long long *__return_ptr))(a1 + 72))(&buf);
  ServiceMap = (std::mutex *)Registry::getServiceMap((Registry *)buf);
  long long v5 = ServiceMap;
  if ((v6 & 0x8000000000000000) != 0)
  {
    uint64_t v7 = (unsigned __int8 *)(v6 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v8 = 5381;
    do
    {
      unint64_t v6 = v8;
      unsigned int v9 = *v7++;
      uint64_t v8 = (33 * v8) ^ v9;
    }
    while (v9);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v26 = v6;
  uint64_t v10 = sub_10004D37C(&v5[1].__m_.__sig, &v26);
  if (v10)
  {
    unint64_t v12 = (void (***)(uint64_t *__return_ptr, void, void **))v10[3];
    __int16 v11 = (std::__shared_weak_count *)v10[4];
    if (v11)
    {
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v5);
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v11);
      uint64_t v13 = 0;
      goto LABEL_12;
    }
  }
  else
  {
    unint64_t v12 = 0;
  }
  std::mutex::unlock(v5);
  __int16 v11 = 0;
  uint64_t v13 = 1;
LABEL_12:
  (**v12)(&v22, v12, __p);
  if ((v13 & 1) == 0) {
    sub_10004D2C8(v11);
  }
  if (*((void *)&buf + 1)) {
    sub_10004D2C8(*((std::__shared_weak_count **)&buf + 1));
  }
  unint64_t v14 = v22;
  if (v22)
  {
    uint64_t v15 = *(std::__shared_weak_count **)(a1 + 40);
    if (!v15 || (unsigned int v16 = *(void *)(a1 + 32), (v17 = std::__shared_weak_count::lock(v15)) == 0)) {
      sub_100088B9C();
    }
    uint64_t v18 = v17;
    atomic_fetch_add_explicit(&v17->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v17);
    uint64_t v30 = 0;
    uint64_t v19 = operator new(0x20uLL);
    *uint64_t v19 = off_1019EDC58;
    v19[1] = a1;
    void v19[2] = v16;
    void v19[3] = v18;
    uint64_t v30 = v19;
    (*(void (**)(uint64_t, void *))(*(void *)v14 + 528))(v14, v29);
    sub_1001A2C70(v29);
    *(void *)&std::string buf = off_1019EDCE8;
    *((void *)&buf + 1) = a1;
    p_std::string buf = &buf;
    (*(void (**)(uint64_t, uint64_t, long long *))(*(void *)v22 + 328))(v22, 9, &buf);
    sub_100060644(&buf);
  }
  else
  {
    char v20 = *(NSObject **)(a1 + 64);
    if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
    {
      if (*(char *)(a2 + 23) >= 0) {
        uint64_t v21 = (void *)a2;
      }
      else {
        uint64_t v21 = *(void **)a2;
      }
      LODWORD(buf) = 136315138;
      *(void *)((char *)&buf + 4) = v21;
      _os_log_error_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, "invalid entitlement controller for %s", (uint8_t *)&buf, 0xCu);
    }
  }
  if (v23) {
    sub_10004D2C8(v23);
  }
  if (SHIBYTE(v25) < 0) {
    operator delete(__p[0]);
  }
}

void sub_1005F906C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, char a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23)
{
}

uint64_t sub_1005F9108(void (***a1)(Registry **__return_ptr))
{
  (**a1)(&v13);
  ServiceMap = (std::mutex *)Registry::getServiceMap(v13);
  uint64_t v2 = ServiceMap;
  if ((v3 & 0x8000000000000000) != 0)
  {
    uint64_t v4 = (unsigned __int8 *)(v3 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v5 = 5381;
    do
    {
      unint64_t v3 = v5;
      unsigned int v6 = *v4++;
      uint64_t v5 = (33 * v5) ^ v6;
    }
    while (v6);
  }
  std::mutex::lock(ServiceMap);
  unint64_t v15 = v3;
  uint64_t v7 = sub_10004D37C(&v2[1].__m_.__sig, &v15);
  if (v7)
  {
    uint64_t v9 = v7[3];
    uint64_t v8 = (std::__shared_weak_count *)v7[4];
    if (v8)
    {
      atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
      std::mutex::unlock(v2);
      atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_10004D2C8(v8);
      char v10 = 0;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v9 = 0;
  }
  std::mutex::unlock(v2);
  uint64_t v8 = 0;
  char v10 = 1;
LABEL_9:
  if (v14) {
    sub_10004D2C8(v14);
  }
  double v11 = (*(double (**)(uint64_t))(*(void *)v9 + 96))(v9);
  if ((v10 & 1) == 0) {
    sub_10004D2C8(v8);
  }
  return (uint64_t)v11;
}

void sub_1005F924C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  char v13 = v11;
  if ((v13 & 1) == 0) {
    sub_10004D2C8(v12);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1005F927C(uint64_t a1)
{
  unint64_t v3 = (void **)(a1 + 48);
  sub_10019F7C0(&v3);
  if (*(char *)(a1 + 47) < 0) {
    operator delete(*(void **)(a1 + 24));
  }
  if (*(char *)(a1 + 23) < 0) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void sub_1005F92D8(uint64_t a1, int a2)
{
  uint64_t v4 = *(void *)(a1 + 32);
  uint64_t v5 = *(NSObject **)(v4 + 64);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    unsigned int v6 = (void *)(a1 + 40);
    if (*(char *)(a1 + 63) < 0) {
      unsigned int v6 = (void *)*v6;
    }
    uint64_t v7 = "False";
    if (a2) {
      uint64_t v7 = "True";
    }
    *(_DWORD *)std::string buf = 136315394;
    *(void *)&uint8_t buf[4] = v6;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = v7;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I outdated mso iccid %s delete success =? %s", buf, 0x16u);
  }
  if (a2)
  {
    *(void *)std::string buf = v4;
    if (*(char *)(a1 + 63) < 0)
    {
      sub_10004FC84(&buf[8], *(void **)(a1 + 40), *(void *)(a1 + 48));
    }
    else
    {
      *(_OWORD *)&uint8_t buf[8] = *(_OWORD *)(a1 + 40);
      uint64_t v10 = *(void *)(a1 + 56);
    }
    uint64_t v8 = *(std::__shared_weak_count **)(v4 + 40);
    if (v8)
    {
      if (std::__shared_weak_count::lock(v8)) {
        operator new();
      }
    }
    sub_100088B9C();
  }
}

void sub_1005F94E0(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10006A6AC(a1);
  }
  _Unwind_Resume(a1);
}

void sub_1005F94F0(void *a1, void **a2, std::string *a3)
{
  unsigned int v6 = a1[8];
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    if (*((char *)a2 + 23) >= 0) {
      uint64_t v7 = (unsigned __int8 *)a2;
    }
    else {
      uint64_t v7 = (unsigned __int8 *)*a2;
    }
    if ((a3->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      uint64_t v8 = a3;
    }
    else {
      uint64_t v8 = (std::string *)a3->__r_.__value_.__r.__words[0];
    }
    *(_DWORD *)std::string buf = 136315394;
    *(void *)&uint8_t buf[4] = v7;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = v8;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I update binding info %s => %s", buf, 0x16u);
  }
  if (!sub_10010E128((uint64_t)(a1 + 73), a2)) {
    goto LABEL_26;
  }
  uint64_t v9 = (unsigned __int8 *)sub_10005DDEC((uint64_t)(a1 + 73), a2);
  uint64_t v10 = v9[23];
  if ((v10 & 0x80u) == 0) {
    uint64_t v11 = v9[23];
  }
  else {
    uint64_t v11 = *((void *)v9 + 1);
  }
  std::string::size_type size = HIBYTE(a3->__r_.__value_.__r.__words[2]);
  int v13 = (char)size;
  if ((size & 0x80u) != 0) {
    std::string::size_type size = a3->__r_.__value_.__l.__size_;
  }
  if (v11 != size) {
    goto LABEL_26;
  }
  if (v13 >= 0) {
    unint64_t v14 = a3;
  }
  else {
    unint64_t v14 = (std::string *)a3->__r_.__value_.__r.__words[0];
  }
  if ((v10 & 0x80) != 0)
  {
    if (memcmp(*(const void **)v9, v14, *((void *)v9 + 1))) {
      goto LABEL_26;
    }
LABEL_50:
    long long v25 = a1[8];
    if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
    {
      if (*((char *)a2 + 23) >= 0) {
        unint64_t v26 = (unsigned __int8 *)a2;
      }
      else {
        unint64_t v26 = (unsigned __int8 *)*a2;
      }
      *(_DWORD *)std::string buf = 136315394;
      *(void *)&uint8_t buf[4] = v26;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = v14;
      _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "#I binding already exist %s => %s", buf, 0x16u);
    }
    return;
  }
  if (!v9[23]) {
    goto LABEL_50;
  }
  unint64_t v15 = v14;
  while (*v9 == v15->__r_.__value_.__s.__data_[0])
  {
    ++v9;
    unint64_t v15 = (std::string *)((char *)v15 + 1);
    if (!--v10) {
      goto LABEL_50;
    }
  }
LABEL_26:
  unsigned int v16 = sub_100046F68((uint64_t)(a1 + 73), a2);
  if (a1 + 74 != v16)
  {
    uint64_t v17 = a1[8];
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v18 = v16 + 4;
      if (*((char *)v16 + 55) < 0) {
        uint64_t v18 = (void *)*v18;
      }
      uint64_t v19 = v16 + 7;
      if (*((char *)v16 + 79) < 0) {
        uint64_t v19 = (void *)*v19;
      }
      *(_DWORD *)std::string buf = 136315394;
      *(void *)&uint8_t buf[4] = v18;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = v19;
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "#I deleting outdated mso: binding info is %s => %s", buf, 0x16u);
    }
    __dst[0] = 0;
    __dst[1] = 0;
    long long v70 = 0;
    if (*((char *)v16 + 79) < 0)
    {
      sub_10004FC84(__dst, v16[7], (unint64_t)v16[8]);
    }
    else
    {
      *(_OWORD *)std::string __dst = *(_OWORD *)(v16 + 7);
      long long v70 = v16[9];
    }
    v66[0] = (void *)1;
    long long v67 = 0u;
    uint64_t v68 = 0;
    v66[1] = a1 + 69;
    sub_100346B40((uint64_t)&v67, (uint64_t)(a1 + 73));
    std::operator+<char>();
    *(_OWORD *)std::string buf = *(_OWORD *)v64;
    *(void *)&uint8_t buf[16] = v65;
    v64[1] = 0;
    uint64_t v65 = 0;
    v64[0] = 0;
    if (SHIBYTE(v70) < 0)
    {
      sub_10004FC84(__p, __dst[0], (unint64_t)__dst[1]);
    }
    else
    {
      *(_OWORD *)std::string __p = *(_OWORD *)__dst;
      *(void *)&__p[16] = v70;
    }
    sub_1006063F0((uint64_t **)&v67, (void **)buf, (uint64_t)buf);
    if ((__p[23] & 0x80000000) != 0) {
      operator delete(*(void **)__p);
    }
    if ((char)buf[23] < 0) {
      operator delete(*(void **)buf);
    }
    if (SHIBYTE(v65) < 0) {
      operator delete(v64[0]);
    }
    sub_100606180((uint64_t)v66);
    char v20 = (std::__shared_weak_count *)a1[12];
    if (v20)
    {
      uint64_t v21 = std::__shared_weak_count::lock(v20);
      if (v21)
      {
        std::string::size_type v22 = v21;
        uint64_t v23 = a1[11];
        if (v23)
        {
          if (SHIBYTE(v70) < 0)
          {
            sub_10004FC84(v66, __dst[0], (unint64_t)__dst[1]);
            BOOL v24 = SHIBYTE(v70) < 0;
          }
          else
          {
            BOOL v24 = 0;
            *(_OWORD *)char v66 = *(_OWORD *)__dst;
            *(void *)&long long v67 = v70;
          }
          *(void *)std::string buf = _NSConcreteStackBlock;
          *(void *)&uint8_t buf[8] = 1174405120;
          *(void *)&uint8_t buf[16] = sub_1005F92D8;
          *(void *)std::string __p = &unk_1019ED6D0;
          *(void *)&__p[8] = a1;
          if (v24)
          {
            sub_10004FC84(&__p[16], __dst[0], (unint64_t)__dst[1]);
          }
          else
          {
            *(_OWORD *)&__p[16] = *(_OWORD *)__dst;
            long long v73 = v70;
          }
          (*(void (**)(uint64_t, void **, uint8_t *))(*(void *)v23 + 16))(v23, v66, buf);
          if (SBYTE7(v67) < 0) {
            operator delete(v66[0]);
          }
          if (SHIBYTE(v73) < 0) {
            operator delete(*(void **)&__p[16]);
          }
        }
        sub_10004D2C8(v22);
      }
    }
    if (SHIBYTE(v70) < 0) {
      operator delete(__dst[0]);
    }
  }
  v66[0] = (void *)1;
  long long v67 = 0u;
  uint64_t v68 = 0;
  v66[1] = a1 + 69;
  sub_100346B40((uint64_t)&v67, (uint64_t)(a1 + 73));
  uint64_t v27 = *((void *)&v67 + 1);
  if (!*((void *)&v67 + 1))
  {
    BOOL v34 = (char *)&v67 + 8;
LABEL_81:
    __dst[0] = 0;
    v64[0] = 0;
    char v38 = sub_1000C6D50(&v67, (uint64_t)v34, (void ***)__dst, (uint64_t *)v64, a2);
    if (!*v38)
    {
      memset(buf, 0, sizeof(buf));
      sub_10010E650((uint64_t)&v67, (long long *)a2, (long long *)a3, (char **)buf);
      uint64_t v39 = __dst[0];
      uint64_t v40 = *(uint64_t **)buf;
      **(void **)std::string buf = 0;
      v40[1] = 0;
      v40[2] = (uint64_t)v39;
      *char v38 = v40;
      if (*(void *)v67)
      {
        *(void *)&long long v67 = *(void *)v67;
        uint64_t v40 = (uint64_t *)*v38;
      }
      sub_100046C90(*((uint64_t **)&v67 + 1), v40);
      ++v68;
      *(void *)std::string buf = 0;
      sub_10010E764((uint64_t)buf, 0);
    }
    goto LABEL_85;
  }
  BOOL v28 = (long long *)((char *)&v67 + 8);
  do
  {
    uint64_t v29 = v27;
    uint64_t v30 = v28;
    unint64_t v31 = (_OWORD *)(v27 + 32);
    int v32 = (char)sub_100046FE8((void *)(v27 + 32), a2);
    unint64_t v33 = (uint64_t *)(v29 + 8);
    if (v32 >= 0)
    {
      unint64_t v33 = (uint64_t *)v29;
      BOOL v28 = (_OWORD *)v29;
    }
    uint64_t v27 = *v33;
  }
  while (v27);
  BOOL v34 = (char *)&v67 + 8;
  if (v28 == (long long *)((char *)&v67 + 8)) {
    goto LABEL_81;
  }
  BOOL v35 = (void **)(v32 >= 0 ? v31 : v30 + 2);
  char v36 = sub_100046FE8(a2, v35);
  BOOL v34 = (char *)v28;
  if (v36 < 0) {
    goto LABEL_81;
  }
  if (v32 >= 0) {
    uint64_t v37 = (std::string *)(v29 + 56);
  }
  else {
    uint64_t v37 = (std::string *)((char *)v30 + 56);
  }
  std::string::operator=(v37, a3);
LABEL_85:
  uint64_t v41 = (_OWORD *)v67;
  if ((long long *)v67 == (long long *)((char *)&v67 + 8)) {
    goto LABEL_138;
  }
  char v42 = *((unsigned char *)a2 + 23);
  if (v42 >= 0) {
    char v43 = (void *)*((unsigned __int8 *)a2 + 23);
  }
  else {
    char v43 = a2[1];
  }
  if (v42 >= 0) {
    char v44 = (unsigned __int8 *)a2;
  }
  else {
    char v44 = (unsigned __int8 *)*a2;
  }
  unsigned __int8 v45 = HIBYTE(a3->__r_.__value_.__r.__words[2]);
  if ((v45 & 0x80u) == 0) {
    std::string::size_type v46 = HIBYTE(a3->__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type v46 = a3->__r_.__value_.__l.__size_;
  }
  if ((v45 & 0x80u) == 0) {
    dispatch_object_t v47 = a3;
  }
  else {
    dispatch_object_t v47 = (std::string *)a3->__r_.__value_.__r.__words[0];
  }
  while (1)
  {
    long long v48 = (const void **)(v41 + 2);
    uint64_t v49 = *((unsigned __int8 *)v41 + 55);
    if ((v49 & 0x80u) == 0) {
      long long v50 = (void *)*((unsigned __int8 *)v41 + 55);
    }
    else {
      long long v50 = (void *)*((void *)v41 + 5);
    }
    if (v50 == v43)
    {
      if ((v49 & 0x80) != 0)
      {
        if (!memcmp(*v48, v44, *((void *)v41 + 5))) {
          goto LABEL_120;
        }
      }
      else
      {
        if (!*((unsigned char *)v41 + 55)) {
          goto LABEL_120;
        }
        uint64_t v51 = v44;
        long long v52 = (unsigned __int8 *)(v41 + 2);
        while (*v52 == *v51)
        {
          ++v52;
          ++v51;
          if (!--v49) {
            goto LABEL_120;
          }
        }
      }
    }
    uint64_t v53 = *((unsigned __int8 *)v41 + 79);
    if ((v53 & 0x80u) == 0) {
      uint64_t v54 = *((unsigned __int8 *)v41 + 79);
    }
    else {
      uint64_t v54 = *((void *)v41 + 8);
    }
    if (v54 != v46) {
      goto LABEL_120;
    }
    char v55 = (const void **)v41 + 7;
    if ((v53 & 0x80) != 0) {
      break;
    }
    if (!*((unsigned char *)v41 + 79)) {
      goto LABEL_127;
    }
    uint64_t v56 = v47;
    long long v57 = (unsigned __int8 *)v41 + 56;
    while (*v57 == v56->__r_.__value_.__s.__data_[0])
    {
      ++v57;
      uint64_t v56 = (std::string *)((char *)v56 + 1);
      if (!--v53) {
        goto LABEL_127;
      }
    }
LABEL_120:
    unint64_t v58 = (void *)*((void *)v41 + 1);
    if (v58)
    {
      do
      {
        unint64_t v59 = v58;
        unint64_t v58 = (void *)*v58;
      }
      while (v58);
    }
    else
    {
      do
      {
        unint64_t v59 = (_OWORD *)*((void *)v41 + 2);
        BOOL v60 = *(void *)v59 == (void)v41;
        uint64_t v41 = v59;
      }
      while (!v60);
    }
    uint64_t v41 = v59;
    if (v59 == (long long *)((char *)&v67 + 8)) {
      goto LABEL_138;
    }
  }
  if (memcmp(*v55, v47, *((void *)v41 + 8))) {
    goto LABEL_120;
  }
LABEL_127:
  if (v41 != (long long *)((char *)&v67 + 8))
  {
    uint64_t v61 = a1[8];
    if (os_log_type_enabled(v61, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v62 = v41 + 2;
      if (*((char *)v41 + 55) < 0) {
        uint64_t v62 = *v48;
      }
      if (*((char *)v41 + 79) < 0) {
        char v55 = (const void **)*v55;
      }
      if (*((char *)a2 + 23) >= 0) {
        unint64_t v63 = (unsigned __int8 *)a2;
      }
      else {
        unint64_t v63 = (unsigned __int8 *)*a2;
      }
      *(_DWORD *)std::string buf = 136315906;
      *(void *)&uint8_t buf[4] = v62;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = v55;
      *(_WORD *)&unsigned char buf[22] = 2080;
      *(void *)std::string __p = v63;
      *(_WORD *)&__p[8] = 2080;
      *(void *)&__p[10] = v55;
      _os_log_impl((void *)&_mh_execute_header, v61, OS_LOG_TYPE_DEFAULT, "#I delete binding info %s => %s, create new binding %s => %s", buf, 0x2Au);
    }
    sub_10006C514((uint64_t **)&v67, (uint64_t *)v41);
    sub_1000FECD4((uint64_t)(v41 + 2));
    operator delete(v41);
  }
LABEL_138:
  sub_100606180((uint64_t)v66);
}

void sub_1005F9CEC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,void *__p,uint64_t a26,int a27,__int16 a28,char a29,char a30,uint64_t a31,void *a32,uint64_t a33,int a34,__int16 a35,char a36,char a37,uint64_t a38,uint64_t a39,void *a40,uint64_t a41,int a42,__int16 a43,char a44,char a45)
{
  sub_10004D2C8(v45);
  if (a30 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_1005F9DA8(uint64_t a1, void **a2, std::string *a3)
{
}

uint64_t sub_1005F9DB0(uint64_t a1, long long **a2)
{
  uint64_t v4 = *(NSObject **)(a1 + 64);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    unsigned int v6 = a2 + 1;
    uint64_t v5 = *a2;
    memset(&__p, 0, sizeof(__p));
    if (v5 == (long long *)(a2 + 1))
    {
      p_p = &__p;
    }
    else
    {
      if (*((char *)v5 + 55) >= 0) {
        size_t v7 = *((unsigned __int8 *)v5 + 55);
      }
      else {
        size_t v7 = *((void *)v5 + 5);
      }
      memset(v35, 0, 24);
      sub_1000C140C((uint64_t)v35, v7 + 4);
      if (v35[23] >= 0) {
        uint64_t v8 = v35;
      }
      else {
        uint64_t v8 = *(unsigned char **)v35;
      }
      if (v7)
      {
        if (*((char *)v5 + 55) >= 0) {
          uint64_t v9 = v5 + 2;
        }
        else {
          uint64_t v9 = (const void *)*((void *)v5 + 4);
        }
        memmove(v8, v9, v7);
      }
      strcpy(&v8[v7], " -> ");
      int v10 = *((char *)v5 + 79);
      if (v10 >= 0) {
        uint64_t v11 = (char *)v5 + 56;
      }
      else {
        uint64_t v11 = (const std::string::value_type *)*((void *)v5 + 7);
      }
      if (v10 >= 0) {
        std::string::size_type v12 = *((unsigned __int8 *)v5 + 79);
      }
      else {
        std::string::size_type v12 = *((void *)v5 + 8);
      }
      int v13 = std::string::append((std::string *)v35, v11, v12);
      std::string::size_type v14 = v13->__r_.__value_.__r.__words[0];
      v37[0] = (void *)v13->__r_.__value_.__l.__size_;
      *(void **)((char *)v37 + 7) = *(void **)((char *)&v13->__r_.__value_.__r.__words[1] + 7);
      char v15 = HIBYTE(v13->__r_.__value_.__r.__words[2]);
      v13->__r_.__value_.__l.__size_ = 0;
      v13->__r_.__value_.__r.__words[2] = 0;
      v13->__r_.__value_.__r.__words[0] = 0;
      if ((v35[23] & 0x80000000) != 0) {
        operator delete(*(void **)v35);
      }
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      __p.__r_.__value_.__r.__words[0] = v14;
      __p.__r_.__value_.__l.__size_ = (std::string::size_type)v37[0];
      *(std::string::size_type *)((char *)&__p.__r_.__value_.__r.__words[1] + 7) = *(std::string::size_type *)((char *)v37 + 7);
      *((unsigned char *)&__p.__r_.__value_.__s + 23) = v15;
      unsigned int v16 = (long long *)*((void *)v5 + 1);
      if (v16)
      {
        do
        {
          uint64_t v17 = (long long **)v16;
          unsigned int v16 = *(long long **)v16;
        }
        while (v16);
      }
      else
      {
        do
        {
          uint64_t v17 = (long long **)*((void *)v5 + 2);
          BOOL v18 = *v17 == v5;
          uint64_t v5 = (long long *)v17;
        }
        while (!v18);
      }
      if (v17 != v6)
      {
        do
        {
          v35[23] = 1;
          strcpy(v35, ",");
          std::string::append(&__p, v35, 1uLL);
          if ((v35[23] & 0x80000000) != 0) {
            operator delete(*(void **)v35);
          }
          if (*((char *)v17 + 55) >= 0) {
            size_t v19 = *((unsigned __int8 *)v17 + 55);
          }
          else {
            size_t v19 = (size_t)v17[5];
          }
          memset(v35, 0, 24);
          sub_1000C140C((uint64_t)v35, v19 + 4);
          if (v35[23] >= 0) {
            char v20 = v35;
          }
          else {
            char v20 = *(unsigned char **)v35;
          }
          if (v19)
          {
            if (*((char *)v17 + 55) >= 0) {
              uint64_t v21 = (long long *)(v17 + 4);
            }
            else {
              uint64_t v21 = v17[4];
            }
            memmove(v20, v21, v19);
          }
          strcpy(&v20[v19], " -> ");
          int v22 = *((char *)v17 + 79);
          if (v22 >= 0) {
            uint64_t v23 = (const std::string::value_type *)(v17 + 7);
          }
          else {
            uint64_t v23 = (const std::string::value_type *)v17[7];
          }
          if (v22 >= 0) {
            std::string::size_type v24 = *((unsigned __int8 *)v17 + 79);
          }
          else {
            std::string::size_type v24 = (std::string::size_type)v17[8];
          }
          long long v25 = std::string::append((std::string *)v35, v23, v24);
          long long v26 = *(_OWORD *)&v25->__r_.__value_.__l.__data_;
          int64_t v38 = v25->__r_.__value_.__r.__words[2];
          *(_OWORD *)uint64_t v37 = v26;
          v25->__r_.__value_.__l.__size_ = 0;
          v25->__r_.__value_.__r.__words[2] = 0;
          v25->__r_.__value_.__r.__words[0] = 0;
          if ((v35[23] & 0x80000000) != 0) {
            operator delete(*(void **)v35);
          }
          if (v38 >= 0) {
            uint64_t v27 = v37;
          }
          else {
            uint64_t v27 = (void **)v37[0];
          }
          if (v38 >= 0) {
            std::string::size_type v28 = HIBYTE(v38);
          }
          else {
            std::string::size_type v28 = (std::string::size_type)v37[1];
          }
          std::string::append(&__p, (const std::string::value_type *)v27, v28);
          if (SHIBYTE(v38) < 0) {
            operator delete(v37[0]);
          }
          uint64_t v29 = v17[1];
          if (v29)
          {
            do
            {
              uint64_t v30 = (long long **)v29;
              uint64_t v29 = *(long long **)v29;
            }
            while (v29);
          }
          else
          {
            do
            {
              uint64_t v30 = (long long **)v17[2];
              BOOL v18 = *v30 == (long long *)v17;
              uint64_t v17 = v30;
            }
            while (!v18);
          }
          uint64_t v17 = v30;
        }
        while (v30 != v6);
        char v15 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
        std::string::size_type v14 = __p.__r_.__value_.__r.__words[0];
      }
      p_p = &__p;
      if (v15 < 0) {
        p_p = (std::string *)v14;
      }
    }
    *(_DWORD *)BOOL v35 = 136315138;
    *(void *)&v35[4] = p_p;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I update binding map info %s", v35, 0xCu);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
  }
  *(void *)BOOL v35 = 1;
  *(_OWORD *)&v35[16] = 0u;
  uint64_t v36 = 0;
  *(void *)&v35[8] = a1 + 552;
  int v32 = (uint64_t **)sub_100346B40((uint64_t)&v35[16], a1 + 584);
  if (v32 != (uint64_t **)a2) {
    sub_100328AC0(v32, *a2, (long long *)(a2 + 1));
  }
  return sub_100606180((uint64_t)v35);
}

void sub_1005FA188(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,int a29,__int16 a30,char a31,char a32)
{
  if (a23 < 0) {
    operator delete(__p);
  }
  if (a16 < 0) {
    operator delete(a11);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1005FA1F4(uint64_t a1, long long **a2)
{
  return sub_1005F9DB0(a1 - 24, a2);
}

void sub_1005FA1FC(uint64_t a1, int a2, uint64_t a3)
{
  int v4 = *(_DWORD *)(a1 + 304);
  if (v4 != 1 && v4 != 8)
  {
    sub_1000607A8(a3, 0);
    return;
  }
  memset(&v21, 0, sizeof(v21));
  sub_1000631F4(&v21, *(void *)(a1 + 504), *(void *)(a1 + 512), a2);
  if ((void **)(a1 + 224) == sub_100046F68(a1 + 216, (void **)&v21.__r_.__value_.__l.__data_))
  {
    size_t v7 = *(NSObject **)(a1 + 64);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      uint64_t v8 = &v21;
      if ((v21.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        uint64_t v8 = (std::string *)v21.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)std::string buf = 136315138;
      *(void *)&uint8_t buf[4] = v8;
      _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "SIM matching to iccid %s not found", buf, 0xCu);
    }
  }
  else
  {
    if (SHIBYTE(v21.__r_.__value_.__r.__words[2]) < 0) {
      sub_10004FC84(&__p, v21.__r_.__value_.__l.__data_, v21.__r_.__value_.__l.__size_);
    }
    else {
      std::string __p = v21;
    }
    int v9 = sub_1005F06B8(a1, (void **)&__p.__r_.__value_.__l.__data_);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    if (v9 == 1)
    {
      uint64_t v17 = 0;
      uint64_t v18 = 0;
      uint64_t v19 = 0;
      if (SHIBYTE(v21.__r_.__value_.__r.__words[2]) < 0) {
        sub_10004FC84(&v16, v21.__r_.__value_.__l.__data_, v21.__r_.__value_.__l.__size_);
      }
      else {
        std::string v16 = v21;
      }
      sub_1005F0F5C((char **)&v17, a1, (void **)&v16.__r_.__value_.__l.__data_);
      if (SHIBYTE(v16.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v16.__r_.__value_.__l.__data_);
      }
      uint64_t v10 = HIBYTE(v19);
      if (v19 < 0) {
        uint64_t v10 = v18;
      }
      if (!v10 || (void **)(a1 + 248) == sub_100046F68(a1 + 240, &v17))
      {
        BOOL v11 = 0;
      }
      else
      {
        *(void *)std::string buf = &v17;
        BOOL v11 = *((unsigned char *)sub_1006028B8(a1 + 240, &v17, (long long **)buf) + 161) != 0;
      }
      std::string::size_type v12 = *(NSObject **)(a1 + 64);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v13 = subscriber::asString();
        std::string::size_type v14 = "False";
        if (v11) {
          std::string::size_type v14 = "True";
        }
        *(_DWORD *)std::string buf = 136315650;
        *(void *)&uint8_t buf[4] = v14;
        if ((v21.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          char v15 = &v21;
        }
        else {
          char v15 = (std::string *)v21.__r_.__value_.__r.__words[0];
        }
        __int16 v23 = 2080;
        uint64_t v24 = v13;
        __int16 v25 = 2080;
        long long v26 = v15;
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I Prefer private network over wifi %s on slot %s for iccid %s", buf, 0x20u);
      }
      sub_1000607A8(a3, v11);
      if (SHIBYTE(v19) < 0) {
        operator delete(v17);
      }
      goto LABEL_41;
    }
  }
  sub_1000607A8(a3, 0);
LABEL_41:
  if (SHIBYTE(v21.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v21.__r_.__value_.__l.__data_);
  }
}

void sub_1005FA51C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,void *__p,uint64_t a28,int a29,__int16 a30,char a31,char a32)
{
  if (a32 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1005FA588(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 304) != 1) {
    return 0;
  }
  uint64_t v2 = *(long long **)(a1 + 216);
  unint64_t v3 = (long long *)(a1 + 224);
  if (v2 != (long long *)(a1 + 224))
  {
    do
    {
      uint64_t v41 = 0;
      long long v39 = 0u;
      long long v40 = 0u;
      long long v37 = 0u;
      long long v38 = 0u;
      long long v35 = 0u;
      long long v36 = 0u;
      long long v33 = 0u;
      long long v34 = 0u;
      long long v31 = 0u;
      long long v32 = 0u;
      long long v29 = 0u;
      long long v30 = 0u;
      long long v27 = 0u;
      long long v28 = 0u;
      long long v25 = 0u;
      long long v26 = 0u;
      long long v23 = 0u;
      long long v24 = 0u;
      long long v21 = 0u;
      long long v22 = 0u;
      memset(v20, 0, sizeof(v20));
      *(_OWORD *)uint64_t v19 = 0u;
      sub_100601BE4(v19, v2 + 2);
      if (!(_BYTE)v32) {
        goto LABEL_14;
      }
      if (SBYTE7(v20[0]) < 0)
      {
        sub_10004FC84(__p, *(void **)v19, *(unint64_t *)&v19[8]);
      }
      else
      {
        *(_OWORD *)std::string __p = *(_OWORD *)v19;
        uint64_t v18 = *(void *)&v20[0];
      }
      int v4 = sub_1005F06B8(a1, __p);
      if (SHIBYTE(v18) < 0) {
        operator delete(__p[0]);
      }
      if (v4 != 1)
      {
LABEL_14:
        int v5 = 3;
        goto LABEL_26;
      }
      if (!BYTE12(v21) || SDWORD2(v21) <= 0)
      {
        if (SBYTE7(v20[0]) < 0)
        {
          sub_10004FC84(__dst, *(void **)v19, *(unint64_t *)&v19[8]);
        }
        else
        {
          *(_OWORD *)std::string __dst = *(_OWORD *)v19;
          uint64_t v16 = *(void *)&v20[0];
        }
        BOOL v6 = sub_1005F15E0(a1, (uint64_t)__dst);
        int v5 = v6;
        if (SHIBYTE(v16) < 0)
        {
          operator delete(__dst[0]);
          if ((v5 & 1) == 0)
          {
            int v5 = 0;
            goto LABEL_26;
          }
        }
        else if (!v6)
        {
          goto LABEL_26;
        }
      }
      size_t v7 = *(NSObject **)(a1 + 64);
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
      {
        if ((SBYTE7(v20[0]) & 0x80u) == 0) {
          uint64_t v8 = v19;
        }
        else {
          uint64_t v8 = *(uint8_t **)v19;
        }
        *(_DWORD *)std::string buf = 136315138;
        char v43 = v8;
        _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Private network evaluation needed for iccid %s", buf, 0xCu);
      }
      int v5 = 1;
LABEL_26:
      sub_10006544C((uint64_t)v20 + 8);
      if (SBYTE7(v20[0]) < 0) {
        operator delete(*(void **)v19);
      }
      if (v5 != 3 && v5) {
        return 1;
      }
      int v9 = (long long *)*((void *)v2 + 1);
      if (v9)
      {
        do
        {
          uint64_t v10 = v9;
          int v9 = *(long long **)v9;
        }
        while (v9);
      }
      else
      {
        do
        {
          uint64_t v10 = (long long *)*((void *)v2 + 2);
          BOOL v11 = *(void *)v10 == (void)v2;
          uint64_t v2 = v10;
        }
        while (!v11);
      }
      uint64_t v2 = v10;
    }
    while (v10 != v3);
  }
  std::string::size_type v12 = *(NSObject **)(a1 + 64);
  BOOL v13 = os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT);
  uint64_t result = 0;
  if (v13)
  {
    *(_WORD *)uint64_t v19 = 0;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "#I Private network evaluation not needed", v19, 2u);
    return 0;
  }
  return result;
}

void sub_1005FA850(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,char a25)
{
}

void sub_1005FA89C(uint64_t a1, int a2, uint64_t a3)
{
  if (*(_DWORD *)(a1 + 304) == 1)
  {
    memset(&v16, 0, sizeof(v16));
    sub_1000631F4(&v16, *(void *)(a1 + 504), *(void *)(a1 + 512), a2);
    int v5 = sub_100046F68(a1 + 216, (void **)&v16.__r_.__value_.__l.__data_);
    if ((void **)(a1 + 224) == v5)
    {
      size_t v7 = *(NSObject **)(a1 + 64);
      if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
      {
        uint64_t v8 = &v16;
        if ((v16.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
          uint64_t v8 = (std::string *)v16.__r_.__value_.__r.__words[0];
        }
        *(_DWORD *)std::string buf = 136315138;
        uint64_t v18 = v8;
        _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "SIM matching to iccid %s not found", buf, 0xCu);
      }
    }
    else
    {
      BOOL v6 = v5;
      if (SHIBYTE(v16.__r_.__value_.__r.__words[2]) < 0) {
        sub_10004FC84(&__p, v16.__r_.__value_.__l.__data_, v16.__r_.__value_.__l.__size_);
      }
      else {
        std::string __p = v16;
      }
      int v9 = sub_1005F06B8(a1, (void **)&__p.__r_.__value_.__l.__data_);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      if (v9 == 1)
      {
        int v10 = *((unsigned __int8 *)v6 + 256);
        BOOL v11 = *(NSObject **)(a1 + 64);
        if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v12 = subscriber::asString();
          BOOL v13 = "True";
          if (!v10) {
            BOOL v13 = "False";
          }
          *(_DWORD *)std::string buf = 136315650;
          uint64_t v18 = (std::string *)v13;
          if ((v16.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            std::string::size_type v14 = &v16;
          }
          else {
            std::string::size_type v14 = (std::string *)v16.__r_.__value_.__r.__words[0];
          }
          __int16 v19 = 2080;
          uint64_t v20 = v12;
          __int16 v21 = 2080;
          long long v22 = v14;
          _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I Private network supported %s on slot %s for iccid %s", buf, 0x20u);
        }
        sub_1000607A8(a3, v10 != 0);
        goto LABEL_25;
      }
    }
    sub_1000607A8(a3, 0);
LABEL_25:
    if (SHIBYTE(v16.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v16.__r_.__value_.__l.__data_);
    }
    return;
  }

  sub_1000607A8(a3, 0);
}

void sub_1005FAB04(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1005FAB48(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return sub_1000607A8(a3, 0);
}

void sub_1005FAB54(uint64_t a1, int a2)
{
  if (*(unsigned __int8 *)(a1 + 427) != a2)
  {
    *(unsigned char *)(a1 + 427) = a2;
    if ((a2 & 1) == 0)
    {
      sub_100058DB0(v3, "EvaluateAllIccids");
      if (SHIBYTE(v4) < 0)
      {
        sub_10004FC84(__p, v3[0], (unint64_t)v3[1]);
      }
      else
      {
        *(_OWORD *)std::string __p = *(_OWORD *)v3;
        uint64_t v6 = v4;
      }
      int v7 = 11;
      sub_100007714(a1, (uint64_t *)__p);
      if (SHIBYTE(v6) < 0) {
        operator delete(__p[0]);
      }
      if (SHIBYTE(v4) < 0) {
        operator delete(v3[0]);
      }
    }
  }
}

void sub_1005FABFC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1005FAC30(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v4 = *(void **)(a1 + 216);
  int v5 = (void *)(a1 + 224);
  if (v4 != (void *)(a1 + 224))
  {
    while (1)
    {
      uint64_t v8 = *((unsigned __int8 *)v4 + 55);
      if ((v8 & 0x80u) == 0) {
        uint64_t v9 = *((unsigned __int8 *)v4 + 55);
      }
      else {
        uint64_t v9 = v4[5];
      }
      uint64_t v10 = *(unsigned __int8 *)(a2 + 23);
      int v11 = (char)v10;
      if ((v10 & 0x80u) != 0) {
        uint64_t v10 = *(void *)(a2 + 8);
      }
      if (v9 != v10) {
        goto LABEL_22;
      }
      uint64_t v12 = (const void **)(v4 + 4);
      BOOL v13 = v11 >= 0 ? (unsigned __int8 *)a2 : *(unsigned __int8 **)a2;
      if ((v8 & 0x80) == 0) {
        break;
      }
      if (!memcmp(*v12, v13, v4[5])) {
        goto LABEL_17;
      }
LABEL_22:
      std::string v16 = (void *)v4[1];
      if (v16)
      {
        do
        {
          uint64_t v17 = v16;
          std::string v16 = (void *)*v16;
        }
        while (v16);
      }
      else
      {
        do
        {
          uint64_t v17 = (void *)v4[2];
          BOOL v18 = *v17 == (void)v4;
          uint64_t v4 = v17;
        }
        while (!v18);
      }
      uint64_t v4 = v17;
      if (v17 == v5) {
        goto LABEL_28;
      }
    }
    std::string::size_type v14 = v13;
    if (*((unsigned char *)v4 + 55))
    {
      while (*(unsigned __int8 *)v12 == *v14)
      {
        uint64_t v12 = (const void **)((char *)v12 + 1);
        ++v14;
        if (!--v8) {
          goto LABEL_17;
        }
      }
      goto LABEL_22;
    }
LABEL_17:
    if (*((unsigned char *)v4 + 256) && !*(unsigned char *)(a1 + 425))
    {
      char v15 = *(NSObject **)(a1 + 64);
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)std::string buf = 136315394;
        uint64_t v20 = v13;
        __int16 v21 = 1024;
        int v22 = a3;
        _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "#I User manually selected plan with iccid %s with value %d", buf, 0x12u);
      }
      *(unsigned char *)(a1 + 426) = a3;
      *((unsigned char *)v4 + 257) = a3;
    }
    goto LABEL_22;
  }
LABEL_28:
  sub_1005F1E60(a1);
}

void sub_1005FAE08(uint64_t a1, long long *a2)
{
  uint64_t v4 = sub_100046F68(a1 + 584, (void **)a2);
  if ((void **)(a1 + 592) != v4)
  {
    long long __dst = 0uLL;
    BOOL v18 = 0;
    if (*((char *)v4 + 79) < 0)
    {
      sub_10004FC84(&__dst, v4[7], (unint64_t)v4[8]);
    }
    else
    {
      long long __dst = *(_OWORD *)(v4 + 7);
      BOOL v18 = v4[9];
    }
    int v5 = *(std::__shared_weak_count **)(a1 + 96);
    if (v5)
    {
      uint64_t v6 = std::__shared_weak_count::lock(v5);
      if (v6)
      {
        int v7 = v6;
        uint64_t v8 = *(void *)(a1 + 88);
        if (v8)
        {
          if (SHIBYTE(v18) < 0)
          {
            sub_10004FC84(__p, (void *)__dst, *((unint64_t *)&__dst + 1));
            BOOL v9 = SHIBYTE(v18) < 0;
          }
          else
          {
            BOOL v9 = 0;
            *(_OWORD *)std::string __p = __dst;
            std::string v16 = v18;
          }
          v10[0] = _NSConcreteStackBlock;
          v10[1] = 1174405120;
          void v10[2] = sub_1005FB054;
          void v10[3] = &unk_1019ED700;
          void v10[4] = a1;
          if (v9)
          {
            sub_10004FC84(&v11, (void *)__dst, *((unint64_t *)&__dst + 1));
          }
          else
          {
            long long v11 = __dst;
            uint64_t v12 = v18;
          }
          if (*((char *)a2 + 23) < 0)
          {
            sub_10004FC84(&v13, *(void **)a2, *((void *)a2 + 1));
          }
          else
          {
            long long v13 = *a2;
            uint64_t v14 = *((void *)a2 + 2);
          }
          (*(void (**)(uint64_t, void **, void *))(*(void *)v8 + 16))(v8, __p, v10);
          if (SHIBYTE(v16) < 0) {
            operator delete(__p[0]);
          }
          if (SHIBYTE(v14) < 0) {
            operator delete((void *)v13);
          }
          if (SHIBYTE(v12) < 0) {
            operator delete((void *)v11);
          }
        }
        sub_10004D2C8(v7);
      }
    }
    if (SHIBYTE(v18) < 0) {
      operator delete((void *)__dst);
    }
  }
}

void sub_1005FAFE8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,void *a27,uint64_t a28,int a29,__int16 a30,char a31,char a32)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  if (a32 < 0) {
    operator delete(a27);
  }
  sub_10004D2C8(v32);
  if (*(char *)(v33 - 41) < 0) {
    operator delete(*(void **)(v33 - 64));
  }
  _Unwind_Resume(a1);
}

std::string *sub_1005FB054(uint64_t a1, int a2)
{
  uint64_t v4 = *(void *)(a1 + 32);
  int v5 = *(NSObject **)(v4 + 64);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v6 = (void *)(a1 + 40);
    if (*(char *)(a1 + 63) < 0) {
      uint64_t v6 = (void *)*v6;
    }
    int v7 = "False";
    if (a2) {
      int v7 = "True";
    }
    *(_DWORD *)uint64_t v10 = 136315394;
    *(void *)&void v10[4] = v6;
    *(_WORD *)&v10[12] = 2080;
    *(void *)&v10[14] = v7;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I mso iccid %s delete success =? %s", v10, 0x16u);
  }
  if (!a2) {
    return std::string::operator=((std::string *)(v4 + 440), (const std::string *)(a1 + 40));
  }
  *(void *)uint64_t v10 = 1;
  *(_OWORD *)&uint8_t v10[16] = 0u;
  uint64_t v11 = 0;
  *(void *)&uint8_t v10[8] = v4 + 552;
  uint64_t v8 = (uint64_t **)sub_100346B40((uint64_t)&v10[16], v4 + 584);
  sub_10010F808(v8, (void **)(a1 + 64));
  if (!v11) {
    sub_1005F67C8(v4);
  }
  return (std::string *)sub_100606180((uint64_t)v10);
}

void sub_1005FB194(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

unsigned char *sub_1005FB1B0(uint64_t a1, uint64_t a2)
{
  if (*(char *)(a2 + 63) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 40), *(void **)(a2 + 40), *(void *)(a2 + 48));
  }
  else
  {
    long long v4 = *(_OWORD *)(a2 + 40);
    *(void *)(a1 + 56) = *(void *)(a2 + 56);
    *(_OWORD *)(a1 + 40) = v4;
  }
  uint64_t result = (unsigned char *)(a1 + 64);
  if (*(char *)(a2 + 87) < 0) {
    return sub_10004FC84(result, *(void **)(a2 + 64), *(void *)(a2 + 72));
  }
  long long v6 = *(_OWORD *)(a2 + 64);
  *(void *)(a1 + 80) = *(void *)(a2 + 80);
  *(_OWORD *)uint64_t result = v6;
  return result;
}

void sub_1005FB238(_Unwind_Exception *exception_object)
{
  if (*(char *)(v2 + 63) < 0) {
    operator delete(*v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_1005FB254(uint64_t a1)
{
  if (*(char *)(a1 + 87) < 0) {
    operator delete(*(void **)(a1 + 64));
  }
  if (*(char *)(a1 + 63) < 0)
  {
    uint64_t v2 = *(void **)(a1 + 40);
    operator delete(v2);
  }
}

void sub_1005FB2AC(void *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[12];
  if (!v2)
  {
    unint64_t v3 = 0;
LABEL_19:
    BOOL v9 = a1[8];
    if (!os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
      goto LABEL_20;
    }
    *(_WORD *)std::string buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "invalid delegate to delete hidden sims", buf, 2u);
    if (!v3) {
      return;
    }
    goto LABEL_21;
  }
  unint64_t v3 = std::__shared_weak_count::lock(v2);
  if (!v3) {
    goto LABEL_19;
  }
  uint64_t v4 = a1[11];
  if (!v4) {
    goto LABEL_19;
  }
  int v5 = (void *)a1[73];
  if (v5 != a1 + 74)
  {
    do
    {
      if (sub_1005FB4A8((uint64_t)a1, (uint64_t)(v5 + 7)))
      {
        if (*((char *)v5 + 79) < 0)
        {
          sub_10004FC84(__p, (void *)v5[7], v5[8]);
        }
        else
        {
          *(_OWORD *)std::string __p = *(_OWORD *)(v5 + 7);
          uint64_t v12 = v5[9];
        }
        v10[0] = _NSConcreteStackBlock;
        v10[1] = 0x40000000;
        void v10[2] = sub_1005FB604;
        void v10[3] = &unk_1019ED730;
        void v10[4] = a1;
        (*(void (**)(uint64_t, void **, void *))(*(void *)v4 + 16))(v4, __p, v10);
        if (SHIBYTE(v12) < 0) {
          operator delete(__p[0]);
        }
      }
      long long v6 = (void *)v5[1];
      if (v6)
      {
        do
        {
          int v7 = v6;
          long long v6 = (void *)*v6;
        }
        while (v6);
      }
      else
      {
        do
        {
          int v7 = (void *)v5[2];
          BOOL v8 = *v7 == (void)v5;
          int v5 = v7;
        }
        while (!v8);
      }
      int v5 = v7;
    }
    while (v7 != a1 + 74);
LABEL_20:
    if (!v3) {
      return;
    }
  }
LABEL_21:
  sub_10004D2C8(v3);
}

void sub_1005FB47C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  sub_10004D2C8(v20);
  _Unwind_Resume(a1);
}

uint64_t sub_1005FB4A8(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(unsigned __int8 *)(a2 + 23);
  if ((v2 & 0x80u) != 0) {
    uint64_t v2 = *(void *)(a2 + 8);
  }
  if (!v2) {
    return 0;
  }
  if (sIsProfileInstalled()) {
    return 1;
  }
  uint64_t v6 = *(void *)(a1 + 504);
  uint64_t v7 = *(void *)(a1 + 512);
  if (*(char *)(a2 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)a2;
    uint64_t v19 = *(void *)(a2 + 16);
  }
  uint64_t v8 = HIBYTE(v19);
  if (v6 != v7)
  {
    uint64_t v10 = __p[0];
    BOOL v9 = __p[1];
    if (v19 >= 0) {
      uint64_t v11 = (void *)HIBYTE(v19);
    }
    else {
      uint64_t v11 = __p[1];
    }
    do
    {
      uint64_t v12 = (void *)*(unsigned __int8 *)(v6 + 95);
      int v13 = (char)v12;
      if ((char)v12 < 0) {
        uint64_t v12 = *(void **)(v6 + 80);
      }
      if (v11 == v12)
      {
        if (v13 >= 0) {
          uint64_t v14 = (unsigned __int8 *)(v6 + 72);
        }
        else {
          uint64_t v14 = *(unsigned __int8 **)(v6 + 72);
        }
        if ((v8 & 0x80) != 0)
        {
          if (!memcmp(v10, v14, (size_t)v9))
          {
            uint64_t v5 = 1;
            goto LABEL_31;
          }
        }
        else
        {
          if (!v8) {
            return 1;
          }
          char v15 = __p;
          uint64_t v16 = v8;
          while (*(unsigned __int8 *)v15 == *v14)
          {
            char v15 = (void **)((char *)v15 + 1);
            ++v14;
            if (!--v16)
            {
              uint64_t v5 = 1;
              if ((v8 & 0x80) == 0) {
                return v5;
              }
              goto LABEL_31;
            }
          }
        }
      }
      v6 += 168;
    }
    while (v6 != v7);
  }
  uint64_t v5 = 0;
  if ((v8 & 0x80) != 0) {
LABEL_31:
  }
    operator delete(__p[0]);
  return v5;
}

void sub_1005FB604(uint64_t a1, int a2)
{
  unint64_t v3 = *(NSObject **)(*(void *)(a1 + 32) + 64);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v4 = "False";
    if (a2) {
      uint64_t v4 = "True";
    }
    int v5 = 136315138;
    uint64_t v6 = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#I deleteAllOffloadSims_sync result %s", (uint8_t *)&v5, 0xCu);
  }
}

uint64_t sub_1005FB6BC(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 32);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  unint64_t v3 = *(std::__shared_weak_count **)(a1 + 8);
  if (v3) {
    sub_10004D2C8(v3);
  }
  return a1;
}

const void **sub_1005FB6F8(const void **result, uint64_t **a2, int a3)
{
  if (a3)
  {
    uint64_t v3 = (uint64_t)result;
    if (*((_DWORD *)result + 76) == 1 && !result[36])
    {
      *(void *)std::string buf = CFCalendarCopyCurrent();
      CFAbsoluteTime at = CFAbsoluteTimeGetCurrent();
      CFCalendarAddComponents(*(CFCalendarRef *)buf, &at, 0, "d", 1);
      uint64_t v11 = 0;
      unsigned int v10 = 0;
      CFCalendarDecomposeAbsoluteTime(*(CFCalendarRef *)buf, at, "yMd", (char *)&v11 + 4, &v11, &v10);
      CFCalendarComposeAbsoluteTime(*(CFCalendarRef *)buf, &at, "yMdHms", HIDWORD(v11), v11, v10, 5, 0, 0);
      CFDateRef theDate = CFDateCreate(kCFAllocatorDefault, at);
      sub_1006020EC((const void **)buf);
      if (theDate) {
        int v5 = sub_1001908E4;
      }
      else {
        int v5 = 0;
      }
      uint64_t v6 = *(NSObject **)(v3 + 64);
      if (v5)
      {
        if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
        {
          if (*((char *)a2 + 23) < 0) {
            a2 = (uint64_t **)*a2;
          }
          *(_DWORD *)std::string buf = 136315138;
          *(void *)&uint8_t buf[4] = a2;
          _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I User data selected iccid: %s", buf, 0xCu);
        }
        sub_100602120((const void **)(v3 + 392), (const void **)&theDate);
        sub_1005FB968(v3);
        uint64_t v7 = *(void *)(v3 + 136);
        CFAbsoluteTime AbsoluteTime = CFDateGetAbsoluteTime(theDate);
        (*(void (**)(uint64_t, CFAbsoluteTime))(*(void *)v7 + 360))(v7, AbsoluteTime);
      }
      else if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
      {
        if (*((char *)a2 + 23) < 0) {
          a2 = (uint64_t **)*a2;
        }
        *(_DWORD *)std::string buf = 136315138;
        *(void *)&uint8_t buf[4] = a2;
        _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "Failed to start dynamic data switch delay for user selected iccid %s", buf, 0xCu);
      }
      return sub_10007CA64((const void **)&theDate);
    }
  }
  return result;
}

void sub_1005FB93C(_Unwind_Exception *a1)
{
  sub_1006020EC((const void **)(v1 - 64));
  _Unwind_Resume(a1);
}

void sub_1005FB968(uint64_t a1)
{
  CFDateRef v2 = *(const __CFDate **)(a1 + 392);
  if (v2) {
    uint64_t v3 = sub_1001908E4;
  }
  else {
    uint64_t v3 = 0;
  }
  if (v3)
  {
    double AbsoluteTime = CFDateGetAbsoluteTime(v2);
    if (AbsoluteTime > CFAbsoluteTimeGetCurrent())
    {
      uint64_t v5 = (uint64_t)(AbsoluteTime - CFAbsoluteTimeGetCurrent());
      uint64_t v6 = *(NSObject **)(a1 + 64);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        sub_100602178(&v19, (const void **)(a1 + 392));
        sub_1005FBC98(__p, (CFDateRef *)&v19);
        if (v21 >= 0) {
          uint64_t v7 = __p;
        }
        else {
          uint64_t v7 = (void **)__p[0];
        }
        *(_DWORD *)std::string buf = 134218242;
        *(void *)&uint8_t buf[4] = v5;
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = v7;
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Dynamic data switch delayed for %lld sec, ie until %s", buf, 0x16u);
        if (v21 < 0) {
          operator delete(__p[0]);
        }
        sub_10007CA64(&v19);
      }
      (***(void (****)(Registry **__return_ptr))(a1 + 72))(&v14);
      Registry::getTimerService(&v16, v14);
      uint64_t v8 = v16;
      sub_100058DB0(v12, "Dynamic Data Switch Wait Timer");
      *(_OWORD *)std::string buf = *(_OWORD *)v12;
      *(void *)&uint8_t buf[16] = v13;
      v12[0] = 0;
      v12[1] = 0;
      uint64_t v13 = 0;
      __p[0] = off_1019EDDE8;
      __p[1] = (void *)a1;
      int v22 = __p;
      (*(void (**)(uint64_t *__return_ptr, uint64_t, unsigned char *, uint64_t, uint64_t, void, void **))(*(void *)v8 + 40))(&v18, v8, buf, 1, 1000000 * v5, 0, __p);
      sub_10003B34C(__p);
      if ((buf[23] & 0x80000000) != 0) {
        operator delete(*(void **)buf);
      }
      uint64_t v9 = v18;
      uint64_t v18 = 0;
      uint64_t v10 = *(void *)(a1 + 288);
      *(void *)(a1 + 288) = v9;
      if (v10)
      {
        (*(void (**)(uint64_t))(*(void *)v10 + 8))(v10);
        uint64_t v11 = v18;
        uint64_t v18 = 0;
        if (v11) {
          (*(void (**)(uint64_t))(*(void *)v11 + 8))(v11);
        }
      }
      if (SHIBYTE(v13) < 0) {
        operator delete(v12[0]);
      }
      if (v17) {
        sub_10004D2C8(v17);
      }
      if (v15) {
        sub_10004D2C8(v15);
      }
      sub_1005F0CCC(a1);
    }
  }
}

void sub_1005FBC24(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,const void *a21,__int16 a22,char a23,char a24)
{
}

const void **sub_1005FBC98(void *a1, CFDateRef *a2)
{
  if (*a2) {
    uint64_t v3 = sub_1001908E4;
  }
  else {
    uint64_t v3 = 0;
  }
  if (v3)
  {
    CFLocaleRef v9 = CFLocaleCopyCurrent();
    uint64_t v8 = CFDateFormatterCreate(kCFAllocatorDefault, v9, kCFDateFormatterFullStyle, kCFDateFormatterFullStyle);
    CFStringRef StringWithDate = CFDateFormatterCreateStringWithDate(kCFAllocatorDefault, v8, *a2);
    if (StringWithDate) {
      uint64_t v5 = sub_1000810B8;
    }
    else {
      uint64_t v5 = 0;
    }
    if (v5)
    {
      long long v10 = 0uLL;
      uint64_t v11 = 0;
      ctu::cf::assign();
      *(_OWORD *)a1 = 0uLL;
      a1[2] = v11;
    }
    else
    {
      sub_100058DB0(a1, "nil");
    }
    sub_1000558F4((const void **)&StringWithDate);
    sub_100201E7C((const void **)&v8);
    return sub_100201EB0((const void **)&v9);
  }
  else
  {
    return (const void **)sub_100058DB0(a1, "nil");
  }
}

void sub_1005FBDC8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, const void *a10, const void *a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
}

uint64_t sub_1005FBE14(uint64_t a1)
{
  CFDateRef v2 = *(NSObject **)(a1 + 64);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = *(int *)(a1 + 304);
    if (v3 > 0xA) {
      uint64_t v4 = "???";
    }
    else {
      uint64_t v4 = off_1019EE958[v3];
    }
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = v4;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Controller Dormant state reason [%s]", buf, 0xCu);
    CFDateRef v2 = *(NSObject **)(a1 + 64);
  }
  int v5 = *(unsigned __int8 *)(a1 + 385);
  BOOL v6 = os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT);
  if (v5)
  {
    if (!v6) {
      goto LABEL_15;
    }
    if (*(unsigned char *)(a1 + 384)) {
      uint64_t v7 = "True";
    }
    else {
      uint64_t v7 = "False";
    }
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = v7;
    uint64_t v8 = "#I Location services status [%s]";
    CFLocaleRef v9 = v2;
    uint32_t v10 = 12;
  }
  else
  {
    if (!v6) {
      goto LABEL_15;
    }
    *(_WORD *)std::string buf = 0;
    uint64_t v8 = "#I Location services status unknown";
    CFLocaleRef v9 = v2;
    uint32_t v10 = 2;
  }
  _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, v8, buf, v10);
LABEL_15:
  uint64_t v11 = *(NSObject **)(a1 + 64);
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    if (*(unsigned char *)(a1 + 680)) {
      uint64_t v12 = "True";
    }
    else {
      uint64_t v12 = "False";
    }
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = v12;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I Private network mode source [%s]", buf, 0xCu);
    uint64_t v11 = *(NSObject **)(a1 + 64);
  }
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    if (*(unsigned char *)(a1 + 426)) {
      uint64_t v13 = "True";
    }
    else {
      uint64_t v13 = "False";
    }
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = v13;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I Pending permanent DDS switch [%s]", buf, 0xCu);
    uint64_t v11 = *(NSObject **)(a1 + 64);
  }
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    int v14 = *(_DWORD *)(a1 + 400);
    *(_DWORD *)std::string buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v14;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I Location retry count [%d]", buf, 8u);
    uint64_t v11 = *(NSObject **)(a1 + 64);
  }
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v15 = *(void *)(a1 + 408);
    uint64_t v16 = *(void *)(a1 + 416);
    *(_DWORD *)std::string buf = 134283777;
    *(void *)&uint8_t buf[4] = v15;
    *(_WORD *)&unsigned char buf[12] = 2049;
    *(void *)&buf[14] = v16;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I Last known (lat, long) : (%{private}f, %{private}f)", buf, 0x16u);
  }
  char v17 = *(unsigned char *)(a1 + 359);
  if (v17 < 0)
  {
    if (!*(void *)(a1 + 344)) {
      goto LABEL_47;
    }
  }
  else if (!*(unsigned char *)(a1 + 359))
  {
    goto LABEL_47;
  }
  uint64_t v18 = *(NSObject **)(a1 + 64);
  if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
  {
    long long v106 = *(_OWORD *)(a1 + 312);
    uint64_t v107 = *(void *)(a1 + 328);
    if (v17 < 0)
    {
      sub_10004FC84(&v108, *(void **)(a1 + 336), *(void *)(a1 + 344));
    }
    else
    {
      long long v108 = *(_OWORD *)(a1 + 336);
      uint64_t v109 = *(void *)(a1 + 352);
    }
    if (*(char *)(a1 + 383) < 0)
    {
      sub_10004FC84(&__p, *(void **)(a1 + 360), *(void *)(a1 + 368));
    }
    else
    {
      long long __p = *(_OWORD *)(a1 + 360);
      uint64_t v111 = *(void *)(a1 + 376);
    }
    unsigned int v19 = sub_1005F2068((uint64_t)&v106);
    if (v19 > 3) {
      uint64_t v20 = "???";
    }
    else {
      uint64_t v20 = off_1019EE938[v19];
    }
    uint64_t v22 = *(void *)(a1 + 320);
    uint64_t v21 = *(void *)(a1 + 328);
    uint64_t v23 = *(void *)(a1 + 312);
    *(_DWORD *)std::string buf = 136315906;
    *(void *)&uint8_t buf[4] = v20;
    *(_WORD *)&unsigned char buf[12] = 2048;
    *(void *)&buf[14] = v21;
    *(_WORD *)&unsigned char buf[22] = 2048;
    *(void *)&unsigned char buf[24] = v22;
    *(_WORD *)&unsigned char buf[32] = 2048;
    *(void *)&buf[34] = v23;
    _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "#I Private network bounding geofence [%s, (%f, %f), %f meters]", buf, 0x2Au);
    if (SHIBYTE(v111) < 0) {
      operator delete((void *)__p);
    }
    if (SHIBYTE(v109) < 0) {
      operator delete((void *)v108);
    }
  }
LABEL_47:
  long long v24 = *(void **)(a1 + 216);
  if (v24 != (void *)(a1 + 224))
  {
    do
    {
      if (*((unsigned char *)v24 + 256))
      {
        long long v25 = v24 + 4;
        long long v119 = 0uLL;
        uint64_t v120 = 0;
        if (*((char *)v24 + 55) < 0)
        {
          sub_10004FC84(__dst, (void *)v24[4], v24[5]);
        }
        else
        {
          *(_OWORD *)long long __dst = *v25;
          uint64_t v105 = v24[6];
        }
        sub_1005F0F5C((char **)&v119, a1, __dst);
        if (SHIBYTE(v105) < 0) {
          operator delete(__dst[0]);
        }
        long long v26 = *(NSObject **)(a1 + 64);
        if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
        {
          if (*((char *)v24 + 55) < 0) {
            long long v25 = *(_OWORD **)v25;
          }
          *(_DWORD *)std::string buf = 136315138;
          *(void *)&uint8_t buf[4] = v25;
          _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "#I Private network iccid [%s]", buf, 0xCu);
          long long v26 = *(NSObject **)(a1 + 64);
        }
        if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v27 = *((int *)v24 + 15);
          long long v28 = "???";
          if (v27 <= 0xA) {
            long long v28 = off_1019EE958[v27];
          }
          *(_DWORD *)std::string buf = 136315138;
          *(void *)&uint8_t buf[4] = v28;
          _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "#I Private network sim dormant reason [%s]", buf, 0xCu);
          long long v26 = *(NSObject **)(a1 + 64);
        }
        if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v29 = subscriber::asString();
          *(_DWORD *)std::string buf = 136315138;
          *(void *)&uint8_t buf[4] = v29;
          _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "#I Private network slot [%s]", buf, 0xCu);
          long long v26 = *(NSObject **)(a1 + 64);
        }
        if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
        {
          long long v30 = &v119;
          if (v120 < 0) {
            long long v30 = (long long *)v119;
          }
          *(_DWORD *)std::string buf = 136315138;
          *(void *)&uint8_t buf[4] = v30;
          _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "#I Private network SIM identifier [%s]", buf, 0xCu);
          long long v26 = *(NSObject **)(a1 + 64);
        }
        if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
        {
          long long v31 = "True";
          if (!*((unsigned char *)v24 + 257)) {
            long long v31 = "False";
          }
          *(_DWORD *)std::string buf = 136315138;
          *(void *)&uint8_t buf[4] = v31;
          _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "#I Private network allows automatic toggling [%s]", buf, 0xCu);
          long long v26 = *(NSObject **)(a1 + 64);
        }
        if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
        {
          if (*((unsigned char *)v24 + 92)) {
            int v32 = *((_DWORD *)v24 + 22);
          }
          else {
            int v32 = -1;
          }
          *(_DWORD *)std::string buf = 67109120;
          *(_DWORD *)&uint8_t buf[4] = v32;
          _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "#I Private network geofence entry count [%d]", buf, 8u);
        }
        uint64_t v33 = (void *)v24[8];
        if (v33 != v24 + 9)
        {
          do
          {
            long long v34 = *(NSObject **)(a1 + 64);
            if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
            {
              long long v35 = "inside";
              if (!*((unsigned char *)v33 + 56)) {
                long long v35 = "not inside";
              }
              long long v36 = v33 + 4;
              if (*((char *)v33 + 55) < 0) {
                long long v36 = (void *)v33[4];
              }
              *(_DWORD *)std::string buf = 136315394;
              *(void *)&uint8_t buf[4] = v35;
              *(_WORD *)&unsigned char buf[12] = 2080;
              *(void *)&buf[14] = v36;
              _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "#I Private network profile %s region [%s]", buf, 0x16u);
            }
            memset(&v103, 0, sizeof(v103));
            if (*((char *)v33 + 55) < 0)
            {
              long long v38 = (char *)v33[4];
              int64_t v37 = v33[5];
            }
            else
            {
              int64_t v37 = *((unsigned __int8 *)v33 + 55);
              long long v38 = (char *)(v33 + 4);
            }
            long long v39 = &v38[v37];
            if (v37 >= 1)
            {
              long long v40 = v38;
              do
              {
                uint64_t v41 = (char *)memchr(v40, 32, v37);
                if (!v41) {
                  break;
                }
                if (*v41 == 32) {
                  goto LABEL_93;
                }
                long long v40 = v41 + 1;
                int64_t v37 = v39 - (unsigned char *)v40;
              }
              while (v39 - (unsigned char *)v40 > 0);
            }
            uint64_t v41 = v39;
LABEL_93:
            if (v41 == v39) {
              std::string::size_type v42 = 0;
            }
            else {
              std::string::size_type v42 = v41 - v38 + 1;
            }
            std::string::basic_string(&v103, (const std::string *)(v33 + 4), v42, 0xFFFFFFFFFFFFFFFFLL, (std::allocator<char> *)buf);
            if ((void **)(a1 + 248) != sub_100046F68(a1 + 240, (void **)&v119))
            {
              uint64_t v43 = sub_10005DDEC(a1 + 240, (void **)&v119);
              uint64_t v44 = v43 + 120;
              unsigned __int8 v45 = *(void **)(v43 + 120);
              if (!v45) {
                goto LABEL_107;
              }
              uint64_t v46 = v43 + 120;
              do
              {
                char v47 = sub_100046FE8(v45 + 4, (void **)&v103.__r_.__value_.__l.__data_);
                if (v47 >= 0) {
                  long long v48 = v45;
                }
                else {
                  long long v48 = v45 + 1;
                }
                if (v47 >= 0) {
                  uint64_t v46 = (uint64_t)v45;
                }
                unsigned __int8 v45 = (void *)*v48;
              }
              while (*v48);
              if (v46 == v44 || (sub_100046FE8(&v103, (void **)(v46 + 32)) & 0x80) != 0) {
LABEL_107:
              }
                uint64_t v46 = v44;
              if (sub_10005DDEC(a1 + 240, (void **)&v119) + 120 != v46)
              {
                uint64_t v49 = *(NSObject **)(a1 + 64);
                if (os_log_type_enabled(v49, OS_LOG_TYPE_DEFAULT))
                {
                  long long v50 = (void *)(v46 + 80);
                  if (*(char *)(v46 + 103) < 0) {
                    long long v50 = (void *)*v50;
                  }
                  uint64_t v52 = *(void *)(v46 + 64);
                  uint64_t v51 = *(void *)(v46 + 72);
                  uint64_t v53 = *(void *)(v46 + 56);
                  *(_DWORD *)std::string buf = 136315906;
                  *(void *)&uint8_t buf[4] = v50;
                  *(_WORD *)&unsigned char buf[12] = 2048;
                  *(void *)&buf[14] = v51;
                  *(_WORD *)&unsigned char buf[22] = 2048;
                  *(void *)&unsigned char buf[24] = v52;
                  *(_WORD *)&unsigned char buf[32] = 2048;
                  *(void *)&buf[34] = v53;
                  _os_log_impl((void *)&_mh_execute_header, v49, OS_LOG_TYPE_DEFAULT, "#I Private network profile geofence [%s, (%f, %f), %f meters]", buf, 0x2Au);
                }
              }
            }
            if (SHIBYTE(v103.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(v103.__r_.__value_.__l.__data_);
            }
            uint64_t v54 = (void *)v33[1];
            if (v54)
            {
              do
              {
                char v55 = v54;
                uint64_t v54 = (void *)*v54;
              }
              while (v54);
            }
            else
            {
              do
              {
                char v55 = (void *)v33[2];
                BOOL v56 = *v55 == (void)v33;
                uint64_t v33 = v55;
              }
              while (!v56);
            }
            uint64_t v33 = v55;
          }
          while (v55 != v24 + 9);
        }
        if (SHIBYTE(v120) < 0) {
          operator delete((void *)v119);
        }
      }
      long long v57 = (void *)v24[1];
      if (v57)
      {
        do
        {
          unint64_t v58 = v57;
          long long v57 = (void *)*v57;
        }
        while (v57);
      }
      else
      {
        do
        {
          unint64_t v58 = (void *)v24[2];
          BOOL v56 = *v58 == (void)v24;
          long long v24 = v58;
        }
        while (!v56);
      }
      long long v24 = v58;
    }
    while (v58 != (void *)(a1 + 224));
  }
  unint64_t v59 = *(void **)(a1 + 240);
  BOOL v60 = (void *)(a1 + 248);
  if (v59 != (void *)(a1 + 248))
  {
    do
    {
      uint64_t v61 = *(NSObject **)(a1 + 64);
      if (os_log_type_enabled(v61, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v62 = v59 + 8;
        if (*((char *)v59 + 87) < 0) {
          uint64_t v62 = (void *)*v62;
        }
        unint64_t v63 = v59 + 11;
        if (*((char *)v59 + 111) < 0) {
          unint64_t v63 = (void *)*v63;
        }
        long long v64 = v59 + 4;
        if (*((char *)v59 + 55) < 0) {
          long long v64 = (void *)*v64;
        }
        int v65 = *((_DWORD *)v59 + 14);
        if (*((unsigned char *)v59 + 160)) {
          char v66 = "True";
        }
        else {
          char v66 = "False";
        }
        if (*((unsigned char *)v59 + 161)) {
          long long v67 = "True";
        }
        else {
          long long v67 = "False";
        }
        uint64_t v68 = asString();
        uint64_t v69 = v59[23];
        *(_DWORD *)std::string buf = 67110914;
        *(_DWORD *)&uint8_t buf[4] = v65;
        *(_WORD *)&uint8_t buf[8] = 2080;
        *(void *)&buf[10] = v62;
        *(_WORD *)&buf[18] = 2080;
        *(void *)&buf[20] = v63;
        *(_WORD *)&buf[28] = 2080;
        *(void *)&buf[30] = v64;
        *(_WORD *)&buf[38] = 2080;
        *(void *)&unsigned char buf[40] = v66;
        __int16 v113 = 2080;
        uint64_t v114 = v67;
        __int16 v115 = 2080;
        uint64_t v116 = v68;
        __int16 v117 = 2048;
        uint64_t v118 = v69;
        _os_log_impl((void *)&_mh_execute_header, v61, OS_LOG_TYPE_DEFAULT, "#I Private network profile type [%d], name [%s], version [%s], identifier [%s], setAside [%s] supportsCellOverWifi [%s], 5GStandaloneEnabled [%s], geofenceListSize [%lu]", buf, 0x4Eu);
        BOOL v60 = (void *)(a1 + 248);
      }
      long long v70 = (void *)v59[1];
      if (v70)
      {
        do
        {
          uint64_t v71 = v70;
          long long v70 = (void *)*v70;
        }
        while (v70);
      }
      else
      {
        do
        {
          uint64_t v71 = (void *)v59[2];
          BOOL v56 = *v71 == (void)v59;
          unint64_t v59 = v71;
        }
        while (!v56);
      }
      unint64_t v59 = v71;
    }
    while (v71 != v60);
  }
  long long v72 = *(void **)(a1 + 584);
  if (v72 != (void *)(a1 + 592))
  {
    do
    {
      long long v73 = *(NSObject **)(a1 + 64);
      if (os_log_type_enabled(v73, OS_LOG_TYPE_DEFAULT))
      {
        char v74 = v72 + 4;
        if (*((char *)v72 + 55) < 0) {
          char v74 = (void *)*v74;
        }
        uint64_t v75 = v72 + 7;
        if (*((char *)v72 + 79) < 0) {
          uint64_t v75 = (void *)*v75;
        }
        *(_DWORD *)std::string buf = 136315394;
        *(void *)&uint8_t buf[4] = v74;
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = v75;
        _os_log_impl((void *)&_mh_execute_header, v73, OS_LOG_TYPE_DEFAULT, "#I Private network Offload sim binding (mno -> mso) : (%s -> %s)", buf, 0x16u);
      }
      __int16 v76 = (void *)v72[1];
      if (v76)
      {
        do
        {
          int v77 = v76;
          __int16 v76 = (void *)*v76;
        }
        while (v76);
      }
      else
      {
        do
        {
          int v77 = (void *)v72[2];
          BOOL v56 = *v77 == (void)v72;
          long long v72 = v77;
        }
        while (!v56);
      }
      long long v72 = v77;
    }
    while (v77 != (void *)(a1 + 592));
  }
  if (*(void *)(a1 + 736))
  {
    char v78 = *(int **)(a1 + 504);
    for (uint64_t i = *(int **)(a1 + 512); v78 != i; v78 += 42)
    {
      uint64_t v80 = *(uint64_t **)(a1 + 728);
      if (v80)
      {
        int v81 = *v78;
        do
        {
          int v82 = *((_DWORD *)v80 + 7);
          if (v81 >= v82)
          {
            if (v82 >= v81)
            {
              if (subscriber::isSimReady())
              {
                unint64_t v88 = *(NSObject **)(a1 + 64);
                if (os_log_type_enabled(v88, OS_LOG_TYPE_DEFAULT))
                {
                  uint64_t v89 = subscriber::asString();
                  if (*(unsigned char *)sub_10012EF5C(a1 + 720, v78)) {
                    long long v90 = "True";
                  }
                  else {
                    long long v90 = "False";
                  }
                  uint64_t v91 = sub_10012EF5C(a1 + 720, v78);
                  long long v92 = "True";
                  if (!*((unsigned char *)v91 + 1)) {
                    long long v92 = "False";
                  }
                  *(_DWORD *)std::string buf = 136315650;
                  *(void *)&uint8_t buf[4] = v89;
                  *(_WORD *)&unsigned char buf[12] = 2080;
                  *(void *)&buf[14] = v90;
                  *(_WORD *)&unsigned char buf[22] = 2080;
                  *(void *)&unsigned char buf[24] = v92;
                  CFDictionaryRef v85 = v88;
                  unint64_t v86 = "#I Private network active sim map [%s] -> Active: [%s] DataUsageFree: [%s]";
                  uint32_t v87 = 32;
LABEL_173:
                  _os_log_impl((void *)&_mh_execute_header, v85, OS_LOG_TYPE_DEFAULT, v86, buf, v87);
                }
              }
              goto LABEL_174;
            }
            ++v80;
          }
          uint64_t v80 = (uint64_t *)*v80;
        }
        while (v80);
      }
      uint64_t v83 = *(NSObject **)(a1 + 64);
      if (os_log_type_enabled(v83, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v84 = subscriber::asString();
        *(_DWORD *)std::string buf = 136315138;
        *(void *)&uint8_t buf[4] = v84;
        CFDictionaryRef v85 = v83;
        unint64_t v86 = "#I Private network active sim map [%s] missing";
        uint32_t v87 = 12;
        goto LABEL_173;
      }
LABEL_174:
      ;
    }
  }
  else
  {
    unint64_t v93 = *(NSObject **)(a1 + 64);
    if (os_log_type_enabled(v93, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v93, OS_LOG_TYPE_DEFAULT, "#I Private network active sim map empty", buf, 2u);
    }
  }
  uint64_t v94 = *(NSObject **)(a1 + 64);
  if (os_log_type_enabled(v94, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v95 = subscriber::asString();
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = v95;
    _os_log_impl((void *)&_mh_execute_header, v94, OS_LOG_TYPE_DEFAULT, "#I WRM recommended slot %s", buf, 0xCu);
    uint64_t v94 = *(NSObject **)(a1 + 64);
  }
  if (os_log_type_enabled(v94, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v96 = rest::asString();
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = v96;
    _os_log_impl((void *)&_mh_execute_header, v94, OS_LOG_TYPE_DEFAULT, "#I WRM current data sub quality %s", buf, 0xCu);
    uint64_t v94 = *(NSObject **)(a1 + 64);
  }
  if (os_log_type_enabled(v94, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v97 = rest::asString();
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = v97;
    _os_log_impl((void *)&_mh_execute_header, v94, OS_LOG_TYPE_DEFAULT, "#I WRM any call state %s", buf, 0xCu);
    uint64_t v94 = *(NSObject **)(a1 + 64);
  }
  if (os_log_type_enabled(v94, OS_LOG_TYPE_DEFAULT))
  {
    sub_100602178(&v102, (const void **)(a1 + 392));
    sub_1005FBC98(buf, (CFDateRef *)&v102);
    if (buf[23] >= 0) {
      long long v98 = buf;
    }
    else {
      long long v98 = *(unsigned char **)buf;
    }
    LODWORD(v119) = 136315138;
    *(void *)((char *)&v119 + 4) = v98;
    _os_log_impl((void *)&_mh_execute_header, v94, OS_LOG_TYPE_DEFAULT, "#I Dynamic data switch delayed until %s", (uint8_t *)&v119, 0xCu);
    if ((buf[23] & 0x80000000) != 0) {
      operator delete(*(void **)buf);
    }
    sub_10007CA64(&v102);
    uint64_t v94 = *(NSObject **)(a1 + 64);
  }
  if (os_log_type_enabled(v94, OS_LOG_TYPE_DEFAULT))
  {
    if (*(unsigned char *)(a1 + 644)) {
      dispatch_object_t v99 = "enabled";
    }
    else {
      dispatch_object_t v99 = "disabled";
    }
    uint64_t v100 = subscriber::asString();
    *(_DWORD *)std::string buf = 136315394;
    *(void *)&uint8_t buf[4] = v99;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = v100;
    _os_log_impl((void *)&_mh_execute_header, v94, OS_LOG_TYPE_DEFAULT, "#I 5G Standalone %s by MDM for slot: %s", buf, 0x16u);
  }
  return (*(uint64_t (**)(void))(**(void **)(a1 + 120) + 40))(*(void *)(a1 + 120));
}

void sub_1005FCDB4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, void *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25,char a26,uint64_t a27,int a28,__int16 a29,char a30,char a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,void *__p,uint64_t a37,int a38,__int16 a39,char a40,char a41)
{
  if (a41 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1005FCE34(uint64_t a1, long long *a2)
{
  long long v4 = *a2;
  *(void *)(a1 + 16) = *((void *)a2 + 2);
  *(_OWORD *)a1 = v4;
  if (*((char *)a2 + 47) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 24), *((void **)a2 + 3), *((void *)a2 + 4));
  }
  else
  {
    long long v5 = *(long long *)((char *)a2 + 24);
    *(void *)(a1 + 40) = *((void *)a2 + 5);
    *(_OWORD *)(a1 + 24) = v5;
  }
  BOOL v6 = (unsigned char *)(a1 + 48);
  if (*((char *)a2 + 71) < 0)
  {
    sub_10004FC84(v6, *((void **)a2 + 6), *((void *)a2 + 7));
  }
  else
  {
    long long v7 = a2[3];
    *(void *)(a1 + 64) = *((void *)a2 + 8);
    *(_OWORD *)BOOL v6 = v7;
  }
  return a1;
}

void sub_1005FCED0(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 47) < 0) {
    operator delete(*v2);
  }
  _Unwind_Resume(exception_object);
}

void sub_1005FCEEC(uint64_t a1, std::string *a2, int *a3)
{
  if (*(_DWORD *)(a1 + 304) == 1)
  {
    uint64_t v7 = a1 + 216;
    BOOL v6 = *(void ***)(a1 + 216);
    uint64_t v8 = (void **)(a1 + 224);
    if (v6 != (void **)(a1 + 224))
    {
      do
      {
        if (!*((unsigned char *)v6 + 92))
        {
          *((_DWORD *)v6 + 22) = 0;
          *((unsigned char *)v6 + 92) = 1;
        }
        CFLocaleRef v9 = (void **)v6[1];
        if (v9)
        {
          do
          {
            uint32_t v10 = v9;
            CFLocaleRef v9 = (void **)*v9;
          }
          while (v9);
        }
        else
        {
          do
          {
            uint32_t v10 = (void **)v6[2];
            BOOL v20 = *v10 == v6;
            BOOL v6 = v10;
          }
          while (!v20);
        }
        BOOL v6 = v10;
      }
      while (v10 != v8);
    }
    memset(&v66, 0, sizeof(v66));
    char v11 = HIBYTE(a2->__r_.__value_.__r.__words[2]);
    if (v11 >= 0) {
      int64_t size = HIBYTE(a2->__r_.__value_.__r.__words[2]);
    }
    else {
      int64_t size = a2->__r_.__value_.__l.__size_;
    }
    if (v11 >= 0) {
      uint64_t v13 = a2;
    }
    else {
      uint64_t v13 = (std::string *)a2->__r_.__value_.__r.__words[0];
    }
    int v14 = (char *)v13 + size;
    if (size >= 1)
    {
      uint64_t v15 = v13;
      do
      {
        uint64_t v16 = (char *)memchr(v15, 32, size);
        if (!v16) {
          break;
        }
        if (*v16 == 32) {
          goto LABEL_23;
        }
        uint64_t v15 = (std::string *)(v16 + 1);
        int64_t size = v14 - (char *)v15;
      }
      while (v14 - (char *)v15 > 0);
    }
    uint64_t v16 = v14;
LABEL_23:
    if (v16 == v14) {
      std::string::size_type v17 = 0;
    }
    else {
      std::string::size_type v17 = v16 - (char *)v13 + 1;
    }
    std::string::basic_string(&v66, a2, v17, 0xFFFFFFFFFFFFFFFFLL, (std::allocator<char> *)&v65);
    std::string::size_type v18 = HIBYTE(v66.__r_.__value_.__r.__words[2]);
    if ((v66.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      std::string::size_type v18 = v66.__r_.__value_.__l.__size_;
    }
    if (v18 == 10)
    {
      long long v24 = (std::string *)v66.__r_.__value_.__r.__words[0];
      if ((v66.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        long long v24 = &v66;
      }
      std::string::size_type v25 = v24->__r_.__value_.__r.__words[0];
      int v26 = LOWORD(v24->__r_.__value_.__r.__words[1]);
      if (v25 != 0x6F4D657669746341 || v26 != 25956)
      {
LABEL_49:
        memset(&v65, 0, sizeof(v65));
        char v28 = HIBYTE(a2->__r_.__value_.__r.__words[2]);
        if (v28 >= 0) {
          int64_t v29 = HIBYTE(a2->__r_.__value_.__r.__words[2]);
        }
        else {
          int64_t v29 = a2->__r_.__value_.__l.__size_;
        }
        if (v28 >= 0) {
          long long v30 = a2;
        }
        else {
          long long v30 = (std::string *)a2->__r_.__value_.__r.__words[0];
        }
        long long v31 = (char *)v30 + v29;
        if (v29 >= 1)
        {
          int v32 = v30;
          do
          {
            uint64_t v33 = (char *)memchr(v32, 32, v29);
            if (!v33) {
              break;
            }
            if (*v33 == 32) {
              goto LABEL_61;
            }
            int v32 = (std::string *)(v33 + 1);
            int64_t v29 = v31 - (char *)v32;
          }
          while (v31 - (char *)v32 > 0);
        }
        uint64_t v33 = v31;
LABEL_61:
        if (v33 == v31) {
          std::string::size_type v34 = -1;
        }
        else {
          std::string::size_type v34 = v33 - (char *)v30;
        }
        std::string::basic_string(&v65, a2, 0, v34, (std::allocator<char> *)&buf);
        if (v8 == sub_100046F68(v7, (void **)&v65.__r_.__value_.__l.__data_))
        {
          uint64_t v44 = *(NSObject **)(a1 + 64);
          if (os_log_type_enabled(v44, OS_LOG_TYPE_ERROR))
          {
            unsigned __int8 v45 = &v65;
            if ((v65.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
              unsigned __int8 v45 = (std::string *)v65.__r_.__value_.__r.__words[0];
            }
            LODWORD(buf) = 136315138;
            *(void *)((char *)&buf + 4) = v45;
            _os_log_error_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_ERROR, "didDetermineState failed, supported SIM iccid %s not found", (uint8_t *)&buf, 0xCu);
          }
          goto LABEL_139;
        }
        *(void *)&long long buf = &v65;
        long long v35 = sub_100602C14(v7, (void **)&v65.__r_.__value_.__l.__data_, (long long **)&buf);
        long long v36 = v35;
        if (!*((unsigned char *)v35 + 257) || !*((unsigned char *)v35 + 256))
        {
LABEL_139:
          if (SHIBYTE(v65.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v65.__r_.__value_.__l.__data_);
          }
LABEL_141:
          if (SHIBYTE(v66.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v66.__r_.__value_.__l.__data_);
          }
          return;
        }
        uint64_t v37 = v35[11];
        *((_DWORD *)v35 + 22) = 0;
        *((unsigned char *)v35 + 92) = 1;
        int v38 = *a3;
        *(void *)&long long buf = a2;
        *((unsigned char *)sub_1000ED870((uint64_t **)v35 + 8, (void **)&a2->__r_.__value_.__l.__data_, (uint64_t)&unk_10144E20E, (long long **)&buf)+ 56) = v38 == 2;
        long long v39 = (uint64_t *)v36[8];
        if (v39 != v36 + 9)
        {
          do
          {
            if (*((unsigned char *)v39 + 56))
            {
              if (!*((unsigned char *)v36 + 92)) {
                sub_10016C840();
              }
              ++*((_DWORD *)v36 + 22);
            }
            long long v40 = (uint64_t *)v39[1];
            if (v40)
            {
              do
              {
                uint64_t v41 = v40;
                long long v40 = (uint64_t *)*v40;
              }
              while (v40);
            }
            else
            {
              do
              {
                uint64_t v41 = (uint64_t *)v39[2];
                BOOL v20 = *v41 == (void)v39;
                long long v39 = v41;
              }
              while (!v20);
            }
            long long v39 = v41;
          }
          while (v41 != v36 + 9);
        }
        if (*((unsigned char *)v36 + 92))
        {
          if (*((int *)v36 + 22) < 1)
          {
            uint64_t v46 = *(NSObject **)(a1 + 64);
            if (os_log_type_enabled(v46, OS_LOG_TYPE_DEFAULT))
            {
              char v47 = &v65;
              if ((v65.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
                char v47 = (std::string *)v65.__r_.__value_.__r.__words[0];
              }
              LODWORD(buf) = 136315138;
              *(void *)((char *)&buf + 4) = v47;
              _os_log_impl((void *)&_mh_execute_header, v46, OS_LOG_TYPE_DEFAULT, "#I didDetermineState: exited all geofences for iccid %s", (uint8_t *)&buf, 0xCu);
            }
            sub_1005FD798(a1);
            if (SHIBYTE(v65.__r_.__value_.__r.__words[2]) < 0) {
              sub_10004FC84(&__dst, v65.__r_.__value_.__l.__data_, v65.__r_.__value_.__l.__size_);
            }
            else {
              std::string __dst = v65;
            }
            if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
              sub_10004FC84(&__p, __dst.__r_.__value_.__l.__data_, __dst.__r_.__value_.__l.__size_);
            }
            else {
              std::string __p = __dst;
            }
            int v61 = 2;
            sub_100007714(a1, (uint64_t *)&__p);
            if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(__p.__r_.__value_.__l.__data_);
            }
            if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
              goto LABEL_114;
            }
            p_dst = &__dst;
            goto LABEL_113;
          }
          if ((v37 & 0xFF00000000) != 0)
          {
            if (v37) {
              goto LABEL_114;
            }
            std::string::size_type v42 = *(NSObject **)(a1 + 64);
            if (os_log_type_enabled(v42, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v43 = &v65;
              if ((v65.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
                uint64_t v43 = (std::string *)v65.__r_.__value_.__r.__words[0];
              }
              LODWORD(buf) = 136315138;
              *(void *)((char *)&buf + 4) = v43;
              _os_log_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_DEFAULT, "#I didDetermineState: entered geofence for the first time for iccid %s", (uint8_t *)&buf, 0xCu);
            }
            (*(void (**)(void, uint64_t))(**(void **)(a1 + 168) + 32))(*(void *)(a1 + 168), 1);
            if (SHIBYTE(v65.__r_.__value_.__r.__words[2]) < 0) {
              sub_10004FC84(&v62, v65.__r_.__value_.__l.__data_, v65.__r_.__value_.__l.__size_);
            }
            else {
              std::string v62 = v65;
            }
            if (SHIBYTE(v62.__r_.__value_.__r.__words[2]) < 0) {
              sub_10004FC84(&v63, v62.__r_.__value_.__l.__data_, v62.__r_.__value_.__l.__size_);
            }
            else {
              std::string v63 = v62;
            }
            int v64 = 1;
            sub_100007714(a1, (uint64_t *)&v63);
            if (SHIBYTE(v63.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(v63.__r_.__value_.__l.__data_);
            }
            if ((SHIBYTE(v62.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
              goto LABEL_114;
            }
            p_dst = &v62;
LABEL_113:
            operator delete(p_dst->__r_.__value_.__l.__data_);
LABEL_114:
            uint64_t v58 = 0;
            long long buf = 0uLL;
            uint64_t v69 = 0;
            if (SHIBYTE(v65.__r_.__value_.__r.__words[2]) < 0) {
              sub_10004FC84(&v57, v65.__r_.__value_.__l.__data_, v65.__r_.__value_.__l.__size_);
            }
            else {
              std::string v57 = v65;
            }
            sub_1005F0F5C((char **)&buf, a1, (void **)&v57.__r_.__value_.__l.__data_);
            if (SHIBYTE(v57.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(v57.__r_.__value_.__l.__data_);
            }
            if ((void **)(a1 + 248) != sub_100046F68(a1 + 240, (void **)&buf))
            {
              p_long long buf = &buf;
              uint64_t v49 = sub_1006028B8(a1 + 240, (void **)&buf, &p_buf);
              long long v50 = v49 + 22;
              uint64_t v51 = (void *)v49[22];
              if (!v51) {
                goto LABEL_130;
              }
              uint64_t v52 = v49 + 22;
              do
              {
                char v53 = sub_100046FE8(v51 + 4, (void **)&v66.__r_.__value_.__l.__data_);
                if (v53 >= 0) {
                  uint64_t v54 = v51;
                }
                else {
                  uint64_t v54 = v51 + 1;
                }
                if (v53 >= 0) {
                  uint64_t v52 = v51;
                }
                uint64_t v51 = (void *)*v54;
              }
              while (*v54);
              if (v52 == v50 || (sub_100046FE8(&v66, (void **)v52 + 4) & 0x80) != 0) {
LABEL_130:
              }
                uint64_t v52 = v50;
              p_long long buf = &buf;
              if (sub_1006028B8(a1 + 240, (void **)&buf, &p_buf) + 22 != v52) {
                uint64_t v58 = v52[7];
              }
            }
            if (!*((unsigned char *)v36 + 92)) {
              sub_10016C840();
            }
            uint64_t v55 = *(void *)(a1 + 152);
            if (*a3 == 2) {
              uint64_t v56 = 6;
            }
            else {
              uint64_t v56 = 7;
            }
            LOBYTE(p_buf) = *((_DWORD *)v36 + 22);
            (*(void (**)(uint64_t, uint64_t, std::string *, uint64_t *, long long **, void))(*(void *)v55 + 40))(v55, v56, &v66, &v58, &p_buf, *((unsigned int *)v36 + 14));
            if (SHIBYTE(v69) < 0) {
              operator delete((void *)buf);
            }
            goto LABEL_139;
          }
        }
        sub_10016C840();
      }
    }
    else
    {
      if (v18 != 12) {
        goto LABEL_49;
      }
      unsigned int v19 = &v66;
      if ((v66.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        unsigned int v19 = (std::string *)v66.__r_.__value_.__r.__words[0];
      }
      BOOL v20 = v19->__r_.__value_.__r.__words[0] == 0x676E69646E756F42
         && LODWORD(v19->__r_.__value_.__r.__words[1]) == 1701080909;
      if (!v20)
      {
        std::string::size_type v21 = v19->__r_.__value_.__r.__words[0];
        uint64_t v22 = LODWORD(v19->__r_.__value_.__r.__words[1]);
        if (v21 != 0x6576697463616E49 || v22 != 1701080909) {
          goto LABEL_49;
        }
      }
    }
    if (*a3 == 3) {
      (*(void (**)(void))(**(void **)(a1 + 104) + 72))(*(void *)(a1 + 104));
    }
    goto LABEL_141;
  }
}

void sub_1005FD6C0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,uint64_t a29,void *__p,uint64_t a31,int a32,__int16 a33,char a34,char a35,uint64_t a36,void *a37,uint64_t a38,int a39,__int16 a40,char a41,char a42)
{
  if (a35 < 0) {
    operator delete(__p);
  }
  if (*(char *)(v42 - 129) < 0) {
    operator delete(*(void **)(v42 - 152));
  }
  if (*(char *)(v42 - 105) < 0) {
    operator delete(*(void **)(v42 - 128));
  }
  _Unwind_Resume(exception_object);
}

void sub_1005FD798(uint64_t a1)
{
  if (rest::WRMRecommendation::activeCall((rest::WRMRecommendation *)(a1 + 2524)))
  {
    CFDateRef v2 = *(NSObject **)(a1 + 64);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I Active call is ongoing", buf, 2u);
    }
    return;
  }
  memset(&v39, 0, sizeof(v39));
  sub_1005F1284(&v39, a1);
  std::string::size_type size = HIBYTE(v39.__r_.__value_.__r.__words[2]);
  if ((v39.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
    std::string::size_type size = v39.__r_.__value_.__l.__size_;
  }
  if (!size)
  {
    if (*(_DWORD *)(a1 + 304) == 1)
    {
      char v11 = *(NSObject **)(a1 + 64);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I SIM turned off already, notify WRM privateNetworkInfo changed with false", buf, 2u);
      }
      (*(void (**)(void, void))(**(void **)(a1 + 168) + 32))(*(void *)(a1 + 168), 0);
    }
    goto LABEL_34;
  }
  long long v37 = 0u;
  long long v38 = 0u;
  long long v35 = 0u;
  long long v36 = 0u;
  long long v33 = 0u;
  long long v34 = 0u;
  long long v31 = 0u;
  long long v32 = 0u;
  long long v29 = 0u;
  long long v30 = 0u;
  long long v27 = 0u;
  long long v28 = 0u;
  long long v25 = 0u;
  long long v26 = 0u;
  long long v23 = 0u;
  long long v24 = 0u;
  long long v21 = 0u;
  long long v22 = 0u;
  long long v19 = 0u;
  long long v20 = 0u;
  *(_OWORD *)long long buf = 0u;
  long long v18 = 0u;
  uint64_t v4 = sub_10005DDEC(a1 + 216, (void **)&v39.__r_.__value_.__l.__data_);
  sub_100059120((uint64_t)buf, v4);
  if (BYTE4(v19)) {
    int v5 = v19;
  }
  else {
    int v5 = 0;
  }
  if (v5 < 1)
  {
    if (SHIBYTE(v39.__r_.__value_.__r.__words[2]) < 0) {
      sub_10004FC84(&__p, v39.__r_.__value_.__l.__data_, v39.__r_.__value_.__l.__size_);
    }
    else {
      std::string __p = v39;
    }
    BOOL v12 = sub_1005F15E0(a1, (uint64_t)&__p);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    uint64_t v13 = *(NSObject **)(a1 + 64);
    BOOL v14 = os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT);
    if (!v12)
    {
      if (v14)
      {
        *(_WORD *)long long v40 = 0;
        _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I notify WRM privateNetworkInfo changed with false", v40, 2u);
      }
      (*(void (**)(void, void))(**(void **)(a1 + 168) + 32))(*(void *)(a1 + 168), 0);
      goto LABEL_33;
    }
    if (v14)
    {
      uint64_t v15 = &v39;
      if ((v39.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        uint64_t v15 = (std::string *)v39.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)long long v40 = 136315138;
      uint64_t v41 = v15;
      uint64_t v8 = "#I Private network SIM %s in service";
      CFLocaleRef v9 = v13;
      uint32_t v10 = 12;
      goto LABEL_29;
    }
  }
  else
  {
    BOOL v6 = *(NSObject **)(a1 + 64);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v7 = &v39;
      if ((v39.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        uint64_t v7 = (std::string *)v39.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)long long v40 = 136315394;
      uint64_t v41 = v7;
      __int16 v42 = 1024;
      int v43 = v5;
      uint64_t v8 = "#I Private network SIM %s is in geofence with entry count %d";
      CFLocaleRef v9 = v6;
      uint32_t v10 = 18;
LABEL_29:
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, v8, v40, v10);
    }
  }
LABEL_33:
  sub_10006544C((uint64_t)buf);
LABEL_34:
  if (SHIBYTE(v39.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v39.__r_.__value_.__l.__data_);
  }
}

void sub_1005FDAD4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, char a16)
{
  if (*(char *)(v16 - 81) < 0) {
    operator delete(*(void **)(v16 - 104));
  }
  _Unwind_Resume(exception_object);
}

void sub_1005FDB24(uint64_t a1, std::string *a2, int *a3)
{
}

void sub_1005FDB2C(uint64_t a1, int a2)
{
  uint64_t v4 = *(NSObject **)(a1 + 64);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(buf.__r_.__value_.__l.__data_) = 67109120;
    HIDWORD(buf.__r_.__value_.__r.__words[0]) = a2;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I location services status set to %d", (uint8_t *)&buf, 8u);
  }
  *(_WORD *)(a1 + 384) = a2 | 0x100;
  if (a2) {
    goto LABEL_35;
  }
  memset(&buf, 0, sizeof(buf));
  sub_1005F1284(&buf, a1);
  if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0)
  {
    if (!buf.__r_.__value_.__l.__size_)
    {
      char v6 = 0;
      goto LABEL_31;
    }
    sub_10004FC84(&__dst, buf.__r_.__value_.__l.__data_, buf.__r_.__value_.__l.__size_);
  }
  else
  {
    if (!*((unsigned char *)&buf.__r_.__value_.__s + 23)) {
      return;
    }
    std::string __dst = buf;
  }
  if (sub_1005F1348(a1, (long long *)&__dst))
  {
    if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
      sub_10004FC84(&__p, buf.__r_.__value_.__l.__data_, buf.__r_.__value_.__l.__size_);
    }
    else {
      std::string __p = buf;
    }
    int v5 = sub_1005F08AC(*(void *)(a1 + 504), *(void *)(a1 + 512), (uint64_t)&__p);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
  }
  else
  {
    int v5 = 0;
  }
  if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    if (!v5) {
      goto LABEL_30;
    }
LABEL_21:
    uint64_t v7 = *(NSObject **)(a1 + 64);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      p_std::string buf = &buf;
      if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        p_std::string buf = (std::string *)buf.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)BOOL v12 = 136315138;
      uint64_t v13 = p_buf;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "#I Disabling MSO iccid [%s] reason: location turned off", v12, 0xCu);
    }
    if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
      sub_10004FC84(&v9, buf.__r_.__value_.__l.__data_, buf.__r_.__value_.__l.__size_);
    }
    else {
      std::string v9 = buf;
    }
    sub_1005F09D4(a1, (long long *)&v9, 0);
    if (SHIBYTE(v9.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v9.__r_.__value_.__l.__data_);
    }
    goto LABEL_30;
  }
  operator delete(__dst.__r_.__value_.__l.__data_);
  if (v5) {
    goto LABEL_21;
  }
LABEL_30:
  char v6 = 1;
LABEL_31:
  if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(buf.__r_.__value_.__l.__data_);
    if ((v6 & 1) == 0) {
      return;
    }
    goto LABEL_35;
  }
  if (v6) {
LABEL_35:
  }
    sub_1005EDF84(a1);
}

void sub_1005FDD78(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (*(char *)(v28 - 41) < 0) {
    operator delete(*(void **)(v28 - 64));
  }
  _Unwind_Resume(exception_object);
}

void sub_1005FDDE0(uint64_t a1, int a2)
{
}

void sub_1005FDDE8(uint64_t a1, double a2, double a3)
{
  *(_DWORD *)(a1 + 400) = 0;
  char v6 = *(NSObject **)(a1 + 64);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)BOOL v12 = 134283777;
    *(double *)&uint8_t v12[4] = a2;
    *(_WORD *)&v12[12] = 2049;
    *(double *)&v12[14] = a3;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Current Location lat, long = (%{private}f, %{private}f)", v12, 0x16u);
  }
  if (*(_DWORD *)(a1 + 304) == 1)
  {
    (*(void (**)(void))(**(void **)(a1 + 104) + 48))(*(void *)(a1 + 104));
    *(void *)(a1 + 312) = 0;
    *(void *)(a1 + 320) = 0;
    *(void *)(a1 + 328) = 0;
    uint64_t v7 = (void **)(a1 + 336);
    if (*(char *)(a1 + 359) < 0) {
      operator delete(*v7);
    }
    uint64_t v8 = (void **)(a1 + 360);
    *uint64_t v7 = 0;
    *(void *)(a1 + 344) = 0;
    *(void *)(a1 + 352) = 0;
    if (*(char *)(a1 + 383) < 0) {
      operator delete(*v8);
    }
    const char *v8 = 0;
    *(void *)(a1 + 368) = 0;
    *(void *)(a1 + 376) = 0;
    if (*(_DWORD *)(a1 + 304) == 1)
    {
      char v9 = (*(uint64_t (**)(void))(**(void **)(a1 + 104) + 8))(*(void *)(a1 + 104));
      uint32_t v10 = *(NSObject **)(a1 + 64);
      if (v9)
      {
        if (os_log_type_enabled(*(os_log_t *)(a1 + 64), OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)BOOL v12 = 0;
          _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#I grabbing new geofences to monitor from geofence manager...", v12, 2u);
        }
        uint64_t v11 = *(void *)(a1 + 120);
        *(void *)BOOL v12 = off_1019ED9A8;
        *(void *)&__int16 v12[8] = a1;
        uint64_t v13 = v12;
        (*(void (**)(uint64_t, unsigned char *, double, double))(*(void *)v11 + 16))(v11, v12, a2, a3);
        sub_10060486C(v12);
      }
      else if (os_log_type_enabled(*(os_log_t *)(a1 + 64), OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)BOOL v12 = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "setupGeofences failed, circular geofences not supported", v12, 2u);
      }
    }
  }
}

void sub_1005FE034(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1005FE050(uint64_t a1, double a2, double a3)
{
}

void sub_1005FE058(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 840))
  {
    CFDateRef v2 = *(NSObject **)(a1 + 64);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      int v3 = *(_DWORD *)(a1 + 400);
      *(_DWORD *)std::string buf = 67109120;
      *(_DWORD *)&uint8_t buf[4] = v3;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#I retrying to requestion for location in 5 minutes, currently %d retries", buf, 8u);
    }
    (***(void (****)(Registry **__return_ptr))(a1 + 72))(&v7);
    Registry::getTimerService(&v9, v7);
    uint64_t v4 = v9;
    sub_100058DB0(v5, "Location retry");
    *(_OWORD *)std::string __p = *(_OWORD *)v5;
    uint64_t v12 = v6;
    v5[0] = 0;
    v5[1] = 0;
    uint64_t v6 = 0;
    *(void *)std::string buf = off_1019EDE68;
    uint64_t v14 = a1;
    uint64_t v15 = buf;
    (*(void (**)(uint64_t, void **, uint64_t, uint64_t, uint8_t *))(*(void *)v4 + 32))(v4, __p, 2, 300000000, buf);
    sub_10003B34C(buf);
    if (SHIBYTE(v12) < 0) {
      operator delete(__p[0]);
    }
    if (SHIBYTE(v6) < 0) {
      operator delete(v5[0]);
    }
    if (v10) {
      sub_10004D2C8(v10);
    }
    if (v8) {
      sub_10004D2C8(v8);
    }
  }
}

void sub_1005FE204(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, std::__shared_weak_count *a17, uint64_t a18, std::__shared_weak_count *a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25)
{
  sub_10003B34C((void *)(v25 - 64));
  if (a25 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  if (a19) {
    sub_10004D2C8(a19);
  }
  if (a17) {
    sub_10004D2C8(a17);
  }
  _Unwind_Resume(a1);
}

void sub_1005FE268(uint64_t a1)
{
}

void sub_1005FE298(void *a1)
{
  uint64_t v1 = a1[99];
  uint64_t v2 = a1[100];
  if (v1 != v2)
  {
    uint64_t v4 = a1[99];
    do
    {
      *(void *)std::string buf = v1;
      *(void *)&uint8_t buf[8] = "kCallStatus";
      sub_100048BAC((uint64_t)buf, &object);
      int v6 = xpc::dyn_cast_or_default((xpc *)&object, (const object *)9, v5);
      xpc_release(object);
      *(void *)std::string buf = v1;
      *(void *)&uint8_t buf[8] = "kCallSimSlot";
      sub_100048BAC((uint64_t)buf, &object);
      int v8 = xpc::dyn_cast_or_default((xpc *)&object, 0, v7);
      xpc_release(object);
      uint64_t v9 = a1[8];
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v10 = subscriber::asString();
        uint64_t v11 = asString();
        *(_DWORD *)std::string buf = 136315394;
        *(void *)&uint8_t buf[4] = v10;
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = v11;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#I slot %s call status %s", buf, 0x16u);
      }
      if (v6 != 9)
      {
        if (v6 == 6)
        {
          sub_1000631F4(&v13, a1[63], a1[64], v8);
          if (SHIBYTE(v13.__r_.__value_.__r.__words[2]) < 0) {
            sub_10004FC84(&__p, v13.__r_.__value_.__l.__data_, v13.__r_.__value_.__l.__size_);
          }
          else {
            std::string __p = v13;
          }
          int v15 = 4;
          sub_100007714((uint64_t)a1, (uint64_t *)&__p);
          if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(__p.__r_.__value_.__l.__data_);
          }
          if (SHIBYTE(v13.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v13.__r_.__value_.__l.__data_);
          }
        }
        else
        {
          uint64_t v12 = a1[37];
          a1[37] = 0;
          if (v12) {
            (*(void (**)(uint64_t))(*(void *)v12 + 8))(v12);
          }
        }
      }
      v4 += 8;
      v1 += 8;
    }
    while (v4 != v2);
  }
}

void sub_1005FE4B0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,uint64_t a25,xpc_object_t object)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1005FE528(uint64_t a1)
{
}

void sub_1005FE534(uint64_t a1)
{
}

void sub_1005FE540(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void **)(a1 + 816);
  int v3 = (void *)(a1 + 824);
  if (v2 != (void *)(a1 + 824))
  {
    do
    {
      int v6 = v2 + 4;
      if (sub_100600DB4((uint64_t)(v2 + 7)))
      {
        if (!sub_10010E194(*(void ***)(a2 + 8), (void **)v2 + 4)
          || (uint64_t v7 = sub_10005DDEC(a2, (void **)v2 + 4), !sub_100600DB4(v7)))
        {
          int v8 = *(NSObject **)(a1 + 64);
          if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v9 = *((unsigned __int8 *)v2 + 55);
            BOOL v10 = (v9 & 0x80u) != 0;
            if ((v9 & 0x80u) != 0) {
              uint64_t v9 = v2[5];
            }
            if (v10) {
              uint64_t v11 = (const char *)v2[4];
            }
            else {
              uint64_t v11 = (const char *)(v2 + 4);
            }
            if (v9) {
              uint64_t v12 = v11;
            }
            else {
              uint64_t v12 = "<invalid>";
            }
            *(_DWORD *)std::string buf = 136315394;
            *(void *)&uint8_t buf[4] = v12;
            *(_WORD *)&unsigned char buf[12] = 2080;
            *(void *)&buf[14] = "OffloadSIMService";
            _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I Persona %s supports %s", buf, 0x16u);
          }
          sub_1005F6BAC(a1, (uint64_t)(v2 + 4));
        }
      }
      if ((*((unsigned char *)v2 + 137) & 4) != 0
        && (!sub_10010E194(*(void ***)(a2 + 8), (void **)v2 + 4)
         || (*(unsigned char *)(sub_10005DDEC(a2, (void **)v2 + 4) + 81) & 4) == 0))
      {
        std::string v13 = *(NSObject **)(a1 + 64);
        if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v14 = *((unsigned __int8 *)v2 + 55);
          BOOL v15 = (v14 & 0x80u) != 0;
          if ((v14 & 0x80u) != 0) {
            uint64_t v14 = v2[5];
          }
          if (v15) {
            uint64_t v16 = (const char *)v2[4];
          }
          else {
            uint64_t v16 = (const char *)(v2 + 4);
          }
          if (v14) {
            std::string::size_type v17 = v16;
          }
          else {
            std::string::size_type v17 = "<invalid>";
          }
          *(_DWORD *)std::string buf = 136315394;
          *(void *)&uint8_t buf[4] = v17;
          *(_WORD *)&unsigned char buf[12] = 2080;
          *(void *)&buf[14] = "GetGeofenceData";
          _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I Persona %s supports %s", buf, 0x16u);
        }
        memset(buf, 0, sizeof(buf));
        if (*((char *)v2 + 55) < 0)
        {
          sub_10004FC84(__p, (void *)v2[4], v2[5]);
        }
        else
        {
          *(_OWORD *)std::string __p = *v6;
          uint64_t v24 = v2[6];
        }
        sub_1005F07F4((uint64_t)buf, a1, __p);
        if (SHIBYTE(v24) < 0) {
          operator delete(__p[0]);
        }
        if (sub_1005FB4A8(a1, (uint64_t)buf))
        {
          sub_1005F8D2C(a1, (uint64_t)(v2 + 4));
          if (*((char *)v2 + 55) < 0)
          {
            sub_10004FC84(__dst, (void *)v2[4], v2[5]);
          }
          else
          {
            *(_OWORD *)std::string __dst = *v6;
            uint64_t v22 = v2[6];
          }
          sub_1005F72F4(a1, (long long *)__dst, 1, 0);
          if (SHIBYTE(v22) < 0) {
            operator delete(__dst[0]);
          }
        }
        if ((char)buf[23] < 0) {
          operator delete(*(void **)buf);
        }
      }
      long long v18 = (void *)v2[1];
      if (v18)
      {
        do
        {
          long long v19 = v18;
          long long v18 = (void *)*v18;
        }
        while (v18);
      }
      else
      {
        do
        {
          long long v19 = (void *)v2[2];
          BOOL v20 = *v19 == (void)v2;
          uint64_t v2 = v19;
        }
        while (!v20);
      }
      uint64_t v2 = v19;
    }
    while (v19 != v3);
  }
}

void sub_1005FE838(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, char a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,void *a25,uint64_t a26,int a27,__int16 a28,char a29,char a30)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  if (a30 < 0) {
    operator delete(a25);
  }
  _Unwind_Resume(exception_object);
}

void sub_1005FE88C(uint64_t a1, int a2)
{
  int v2 = *(_DWORD *)(a1 + 2520);
  if (v2 != a2)
  {
    uint64_t v4 = *(void *)(a1 + 296);
    *(void *)(a1 + 296) = 0;
    if (v4)
    {
      (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
      int v2 = *(_DWORD *)(a1 + 2520);
    }
    if (v2 == 1)
    {
      if (sub_1005F5A04(a1)) {
        sub_1005F5BD0(a1);
      }
      sub_100058DB0(v7, "EvaluateAllIccids");
      if (SHIBYTE(v8) < 0)
      {
        sub_10004FC84(__p, v7[0], (unint64_t)v7[1]);
      }
      else
      {
        *(_OWORD *)std::string __p = *(_OWORD *)v7;
        uint64_t v10 = v8;
      }
      int v11 = 12;
      sub_100007714(a1, (uint64_t *)__p);
      if (SHIBYTE(v10) < 0) {
        operator delete(__p[0]);
      }
      if (SHIBYTE(v8) < 0) {
        operator delete(v7[0]);
      }
      uint64_t v5 = *(NSObject **)(a1 + 64);
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)int v6 = 0;
        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I APM Toggle off, maybeTriggerSignUpForSIMService", v6, 2u);
      }
      sub_1005FFCC8(a1);
    }
  }
}

void sub_1005FE9C0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1005FE9F4(uint64_t a1)
{
  sub_100058DB0(&__p, "/cc/prefs-nb/imeis");
  v4[0] = off_1019EE308;
  v4[1] = a1;
  v4[3] = v4;
  ctu::RestModule::observeProperty();
  sub_10003F600(v4);
  if (v3 < 0) {
    operator delete(__p);
  }
}

void sub_1005FEAA8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_1005FEAD4(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 840))
  {
    int v2 = *(void **)(a1 + 216);
    char v3 = (void *)(a1 + 224);
    if (v2 != (void *)(a1 + 224))
    {
      do
      {
        if (!*((unsigned char *)v2 + 256))
        {
          uint64_t v4 = v2 + 4;
          uint64_t v5 = *(NSObject **)(a1 + 64);
          if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
          {
            int v6 = v2 + 4;
            if (*((char *)v2 + 55) < 0) {
              int v6 = (void *)*v4;
            }
            LODWORD(buf) = 136315138;
            *(void *)((char *)&buf + 4) = v6;
            _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I re-evaluating carrier bundle for %s", (uint8_t *)&buf, 0xCu);
          }
          if (*((char *)v2 + 55) < 0)
          {
            sub_10004FC84(__p, (void *)v2[4], v2[5]);
          }
          else
          {
            *(_OWORD *)std::string __p = *(_OWORD *)v4;
            uint64_t v25 = v2[6];
          }
          sub_1006000E4(a1, (uint64_t)__p, (uint64_t)(v2 + 7));
          if (SHIBYTE(v25) < 0) {
            operator delete(__p[0]);
          }
        }
        uint64_t v7 = (void *)v2[1];
        if (v7)
        {
          do
          {
            uint64_t v8 = v7;
            uint64_t v7 = (void *)*v7;
          }
          while (v7);
        }
        else
        {
          do
          {
            uint64_t v8 = (void *)v2[2];
            BOOL v9 = *v8 == (void)v2;
            int v2 = v8;
          }
          while (!v9);
        }
        int v2 = v8;
      }
      while (v8 != v3);
    }
    sub_1005EDF84(a1);
    sub_1005EE984(a1);
    sub_1005F64A0((void *)a1);
    sub_1005EEEF0(a1);
    sub_100058DB0(v22, "EvaluateAllIccids");
    if (SHIBYTE(v23) < 0)
    {
      sub_10004FC84(&buf, v22[0], (unint64_t)v22[1]);
    }
    else
    {
      long long buf = *(_OWORD *)v22;
      uint64_t v27 = v23;
    }
    int v28 = 5;
    sub_100007714(a1, (uint64_t *)&buf);
    if (SHIBYTE(v27) < 0) {
      operator delete((void *)buf);
    }
    if (SHIBYTE(v23) < 0) {
      operator delete(v22[0]);
    }
    sub_1005F1E60(a1);
    uint64_t v10 = *(std::__shared_weak_count **)(a1 + 40);
    if (!v10 || (uint64_t v11 = *(void *)(a1 + 32), (v12 = std::__shared_weak_count::lock(v10)) == 0)) {
      sub_100088B9C();
    }
    std::string v13 = v12;
    atomic_fetch_add_explicit(&v12->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    sub_10004D2C8(v12);
    (***(void (****)(void **__return_ptr))(a1 + 72))(__p);
    Registry::getTimerService((uint64_t *)&buf, (Registry *)__p[0]);
    uint64_t v14 = buf;
    sub_100058DB0(v20, "Setup Geofence Wait Timer");
    BOOL v15 = *(NSObject **)(a1 + 48);
    dispatch_object_t object = v15;
    if (v15) {
      dispatch_retain(v15);
    }
    aBlock[0] = _NSConcreteStackBlock;
    aBlock[1] = 1174405120;
    aBlock[2] = sub_100600E38;
    aBlock[3] = &unk_1019ED780;
    aBlock[4] = a1;
    void aBlock[5] = v11;
    std::string::size_type v17 = v13;
    atomic_fetch_add_explicit(&v13->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    long long v18 = _Block_copy(aBlock);
    sub_10027A2C0(v14, (uint64_t)v20, 2, 60000000, &object, &v18);
    if (v18) {
      _Block_release(v18);
    }
    if (object) {
      dispatch_release(object);
    }
    if (v21 < 0) {
      operator delete(v20[0]);
    }
    if (*((void *)&buf + 1)) {
      sub_10004D2C8(*((std::__shared_weak_count **)&buf + 1));
    }
    if (__p[1]) {
      sub_10004D2C8((std::__shared_weak_count *)__p[1]);
    }
    if (v17) {
      std::__shared_weak_count::__release_weak(v17);
    }
    std::__shared_weak_count::__release_weak(v13);
  }
}

void sub_1005FEE64(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, std::__shared_weak_count *a18, void *aBlock, dispatch_object_t object,void *__p,uint64_t a22,int a23,__int16 a24,char a25,char a26,void *a27,uint64_t a28,int a29,__int16 a30,char a31,char a32,char a33,uint64_t a34,int a35,__int16 a36,char a37,char a38)
{
  if (a32 < 0) {
    operator delete(a27);
  }
  _Unwind_Resume(exception_object);
}

void sub_1005FEF44(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(NSObject **)(a1 + 64);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    rest::asString((rest *)(a1 + 2524), v5);
    int v6 = v76.__r_.__value_.__s.__data_[15] >= 0 ? &__p : (void **)__p;
    uint64_t v7 = *(unsigned char *)(a1 + 680) ? "True" : "False";
    uint64_t v8 = *(unsigned char *)(a1 + 426) ? "True" : "False";
    *(_DWORD *)long long buf = 136315650;
    *(void *)&uint8_t buf[4] = v6;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = v7;
    __int16 v80 = 2080;
    int v81 = v8;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I WRM notification: [%s]. Currently, PNWMode is [%s], pendingPermanentDDS is [%s]", buf, 0x20u);
    if (v76.__r_.__value_.__s.__data_[15] < 0) {
      operator delete(__p);
    }
  }
  if (*(_DWORD *)(a2 + 8) == 1 && *(_DWORD *)(a1 + 2532) == 2)
  {
    sub_100058DB0(&v70, "EvaluateAllIccids");
    if (SHIBYTE(v71) < 0)
    {
      sub_10004FC84(__dst, (void *)v70, *((unint64_t *)&v70 + 1));
    }
    else
    {
      *(_OWORD *)std::string __dst = v70;
      uint64_t v73 = v71;
    }
    int v74 = 4;
    sub_100007714(a1, (uint64_t *)__dst);
    if (SHIBYTE(v73) < 0) {
      operator delete(__dst[0]);
    }
    if (SHIBYTE(v71) < 0) {
      operator delete((void *)v70);
    }
    sub_1005FD798(a1);
  }
  memset(&__src, 0, sizeof(__src));
  sub_1005F1284(&__src, a1);
  if (SHIBYTE(__src.__r_.__value_.__r.__words[2]) < 0)
  {
    if (__src.__r_.__value_.__l.__size_)
    {
      sub_10004FC84(&v62, __src.__r_.__value_.__l.__data_, __src.__r_.__value_.__l.__size_);
      goto LABEL_28;
    }
LABEL_39:
    std::string v13 = *(NSObject **)(a1 + 64);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "#I Cannot get Private Network SIM", buf, 2u);
    }
    if (rest::WRMRecommendation::activeCall((rest::WRMRecommendation *)(a1 + 2524)))
    {
      if (rest::WRMRecommendation::currentDataSlotQualityBad((rest::WRMRecommendation *)(a1 + 2524)))
      {
        if ((sub_1005EDDAC(a1) & 1) == 0)
        {
          uint64_t v14 = *(void ***)(a1 + 216);
          BOOL v15 = (void **)(a1 + 224);
          if (v14 != (void **)(a1 + 224))
          {
            while (1)
            {
              uint64_t v16 = v14 + 4;
              if (*((char *)v14 + 55) < 0)
              {
                sub_10004FC84(v67, v14[4], (unint64_t)v14[5]);
              }
              else
              {
                *(_OWORD *)long long v67 = *v16;
                uint64_t v68 = v14[6];
              }
              if (v15 == sub_100046F68(a1 + 216, v67))
              {
                long long v19 = *(NSObject **)(a1 + 64);
                if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
                {
                  if (SHIBYTE(v68) >= 0) {
                    uint64_t v23 = v67;
                  }
                  else {
                    uint64_t v23 = (void **)v67[0];
                  }
                  *(_DWORD *)long long buf = 136315138;
                  *(void *)&uint8_t buf[4] = v23;
                  _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "iccid [%s] not found in fIccidsOnDevice", buf, 0xCu);
                }
                BOOL v18 = 0;
              }
              else
              {
                uint64_t v17 = sub_10005DDEC(a1 + 216, v67);
                BOOL v18 = 0;
                if (*(unsigned char *)(v17 + 36) && *(int *)(v17 + 32) >= 1)
                {
                  if (*((char *)v14 + 55) < 0)
                  {
                    sub_10004FC84(v65, v14[4], (unint64_t)v14[5]);
                  }
                  else
                  {
                    *(_OWORD *)std::string v65 = *v16;
                    std::string v66 = v14[6];
                  }
                  BOOL v18 = sub_1005F06B8(a1, v65) == 1;
                  if (SHIBYTE(v66) < 0) {
                    operator delete(v65[0]);
                  }
                }
              }
              if (SHIBYTE(v68) < 0) {
                operator delete(v67[0]);
              }
              if (v18) {
                break;
              }
              BOOL v20 = (void **)v14[1];
              if (v20)
              {
                do
                {
                  char v21 = v20;
                  BOOL v20 = (void **)*v20;
                }
                while (v20);
              }
              else
              {
                do
                {
                  char v21 = (void **)v14[2];
                  BOOL v22 = *v21 == v14;
                  uint64_t v14 = v21;
                }
                while (!v22);
              }
              uint64_t v14 = v21;
              if (v21 == v15) {
                goto LABEL_73;
              }
            }
            if (*((char *)v14 + 55) < 0)
            {
              sub_10004FC84(v63, v14[4], (unint64_t)v14[5]);
            }
            else
            {
              *(_OWORD *)std::string v63 = *v16;
              int v64 = v14[6];
            }
            sub_1005F09D4(a1, (long long *)v63, 1);
            if (SHIBYTE(v64) < 0) {
              operator delete(v63[0]);
            }
          }
        }
      }
    }
    goto LABEL_73;
  }
  if (!*((unsigned char *)&__src.__r_.__value_.__s + 23)) {
    goto LABEL_39;
  }
  std::string v62 = __src;
LABEL_28:
  unsigned int v9 = sub_1005F06B8(a1, (void **)&v62.__r_.__value_.__l.__data_);
  if (SHIBYTE(v62.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v62.__r_.__value_.__l.__data_);
  }
  if (v9 == 1)
  {
    if (!*(unsigned char *)(a1 + 680)
      || (rest::WRMRecommendation::unknownSlot((rest::WRMRecommendation *)(a1 + 2524)) & 1) != 0)
    {
      goto LABEL_73;
    }
    uint64_t v10 = (capabilities::ct *)sub_1005EC568(a1, *(_DWORD *)(a1 + 2524));
    if (v10)
    {
      uint64_t v10 = (capabilities::ct *)rest::WRMRecommendation::activeCall((rest::WRMRecommendation *)(a1 + 2524));
      if (v10)
      {
        if ((sub_1005EDDAC(a1) & 1) != 0
          || (uint64_t v10 = (capabilities::ct *)rest::WRMRecommendation::currentDataSlotQualityGood((rest::WRMRecommendation *)(a1 + 2524)),
              v10))
        {
          uint64_t v11 = *(NSObject **)(a1 + 64);
          if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v12 = subscriber::asString();
            *(_DWORD *)long long buf = 136315138;
            *(void *)&uint8_t buf[4] = v12;
            _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "#I Call active, ignore data switch to slot %s", buf, 0xCu);
          }
          goto LABEL_73;
        }
      }
      if (*(unsigned char *)(a1 + 426))
      {
        sub_1005EEEF0(a1);
        goto LABEL_73;
      }
    }
    if (!capabilities::ct::supportsSimultaneousNRStandaloneInDualSIMMode(v10))
    {
      __int16 v42 = *(NSObject **)(a1 + 64);
      if (os_log_type_enabled(v42, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v43 = subscriber::asString();
        *(_DWORD *)long long buf = 136315138;
        *(void *)&uint8_t buf[4] = v43;
        _os_log_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_DEFAULT, "#I Temporary data switch to slot %s", buf, 0xCu);
      }
      *(_DWORD *)(a1 + 776) = *(_DWORD *)(a1 + 2524);
      uint64_t v44 = *(void *)(a1 + 768);
      if (v44) {
        (*(void (**)(uint64_t, uint64_t))(*(void *)v44 + 48))(v44, a1 + 776);
      }
      goto LABEL_114;
    }
    uint64_t v25 = *(std::__shared_weak_count **)(a1 + 96);
    if (v25)
    {
      int v26 = *(_DWORD *)(a1 + 2524);
      uint64_t v27 = std::__shared_weak_count::lock(v25);
      if (v27)
      {
        uint64_t v28 = *(void *)(a1 + 88);
        if (v28)
        {
          memset(&v78, 0, sizeof(v78));
          sub_1000631F4(&v78, *(void *)(a1 + 504), *(void *)(a1 + 512), v26);
          (*(void (**)(unsigned char *__return_ptr, uint64_t))(*(void *)v28 + 64))(buf, v28);
          if ((v78.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            std::string::size_type size = HIBYTE(v78.__r_.__value_.__r.__words[2]);
          }
          else {
            std::string::size_type size = v78.__r_.__value_.__l.__size_;
          }
          uint64_t v30 = HIBYTE(v80);
          int v31 = SHIBYTE(v80);
          if (v80 < 0) {
            uint64_t v30 = *(void *)&buf[8];
          }
          if (size == v30)
          {
            if (v80 >= 0) {
              long long v32 = buf;
            }
            else {
              long long v32 = *(unsigned __int8 **)buf;
            }
            if ((*((unsigned char *)&v78.__r_.__value_.__s + 23) & 0x80) != 0)
            {
              BOOL v41 = memcmp(v78.__r_.__value_.__l.__data_, v32, v78.__r_.__value_.__l.__size_) == 0;
            }
            else if (*((unsigned char *)&v78.__r_.__value_.__s + 23))
            {
              uint64_t v33 = HIBYTE(v78.__r_.__value_.__r.__words[2]) - 1;
              long long v34 = &v78;
              do
              {
                int v36 = v34->__r_.__value_.__s.__data_[0];
                long long v34 = (std::string *)((char *)v34 + 1);
                int v35 = v36;
                int v38 = *v32++;
                int v37 = v38;
                BOOL v40 = v33-- != 0;
                BOOL v41 = v35 == v37;
              }
              while (v35 == v37 && v40);
            }
            else
            {
              BOOL v41 = 1;
            }
          }
          else
          {
            BOOL v41 = 0;
          }
          if (v31 < 0) {
            operator delete(*(void **)buf);
          }
          uint64_t v54 = *(NSObject **)(a1 + 64);
          BOOL v55 = os_log_type_enabled(v54, OS_LOG_TYPE_DEFAULT);
          if (v41)
          {
            if (v55)
            {
              uint64_t v56 = &v78;
              if ((v78.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
                uint64_t v56 = (std::string *)v78.__r_.__value_.__r.__words[0];
              }
              *(_DWORD *)long long buf = 136315138;
              *(void *)&uint8_t buf[4] = v56;
              _os_log_impl((void *)&_mh_execute_header, v54, OS_LOG_TYPE_DEFAULT, "#I Permanent data switch already set to %s", buf, 0xCu);
            }
LABEL_153:
            if (SHIBYTE(v78.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(v78.__r_.__value_.__l.__data_);
            }
LABEL_112:
            if (v27) {
              sub_10004D2C8(v27);
            }
LABEL_114:
            long long v48 = *(void **)(a1 + 216);
            if (v48 != (void *)(a1 + 224))
            {
              do
              {
                if (*((_DWORD *)v48 + 14) == *(_DWORD *)(a1 + 2524))
                {
                  int v49 = *((unsigned __int8 *)v48 + 256);
                  uint64_t v50 = *(void *)(a1 + 152);
                  sub_100058DB0(buf, "");
                  uint64_t v51 = v49 ? 3 : 4;
                  std::string __p = 0;
                  v78.__r_.__value_.__s.__data_[0] = 0;
                  (*(void (**)(uint64_t, uint64_t, unsigned char *, void **, std::string *, void))(*(void *)v50 + 40))(v50, v51, buf, &__p, &v78, *((unsigned int *)v48 + 14));
                  if (SHIBYTE(v80) < 0) {
                    operator delete(*(void **)buf);
                  }
                }
                uint64_t v52 = (void *)v48[1];
                if (v52)
                {
                  do
                  {
                    char v53 = v52;
                    uint64_t v52 = (void *)*v52;
                  }
                  while (v52);
                }
                else
                {
                  do
                  {
                    char v53 = (void *)v48[2];
                    BOOL v22 = *v53 == (void)v48;
                    long long v48 = v53;
                  }
                  while (!v22);
                }
                long long v48 = v53;
              }
              while (v53 != (void *)(a1 + 224));
            }
            goto LABEL_73;
          }
          char v57 = HIBYTE(v78.__r_.__value_.__r.__words[2]);
          if (v55)
          {
            uint64_t v58 = &v78;
            if ((v78.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
              uint64_t v58 = (std::string *)v78.__r_.__value_.__r.__words[0];
            }
            *(_DWORD *)long long buf = 136315138;
            *(void *)&uint8_t buf[4] = v58;
            _os_log_impl((void *)&_mh_execute_header, v54, OS_LOG_TYPE_DEFAULT, "#I Permanent DDS to %s", buf, 0xCu);
            char v57 = HIBYTE(v78.__r_.__value_.__r.__words[2]);
          }
          if (v57 < 0)
          {
            sub_10004FC84(&v77, v78.__r_.__value_.__l.__data_, v78.__r_.__value_.__l.__size_);
            std::string __p = (void *)a1;
            if (SHIBYTE(v78.__r_.__value_.__r.__words[2]) < 0)
            {
              sub_10004FC84(&v76, v78.__r_.__value_.__l.__data_, v78.__r_.__value_.__l.__size_);
              goto LABEL_149;
            }
          }
          else
          {
            std::string v77 = v78;
            std::string __p = (void *)a1;
          }
          std::string v76 = v78;
LABEL_149:
          int v81 = 0;
          unint64_t v59 = operator new(0x28uLL);
          BOOL v60 = __p;
          *unint64_t v59 = off_1019EE6A8;
          v59[1] = v60;
          long long v61 = *(_OWORD *)&v76.__r_.__value_.__l.__data_;
          v59[4] = *((void *)&v76.__r_.__value_.__l + 2);
          *((_OWORD *)v59 + 1) = v61;
          memset(&v76, 0, sizeof(v76));
          int v81 = (char *)v59;
          (*(void (**)(uint64_t, std::string *, void, unsigned char *))(*(void *)v28 + 32))(v28, &v77, 0, buf);
          sub_10023D374(buf);
          if (SHIBYTE(v76.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v76.__r_.__value_.__l.__data_);
          }
          if (SHIBYTE(v77.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v77.__r_.__value_.__l.__data_);
          }
          goto LABEL_153;
        }
      }
    }
    else
    {
      uint64_t v27 = 0;
    }
    char v47 = *(NSObject **)(a1 + 64);
    if (os_log_type_enabled(v47, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v47, OS_LOG_TYPE_ERROR, "Invalid delegate in PrivateNetworkController", buf, 2u);
    }
    goto LABEL_112;
  }
  uint64_t v24 = *(NSObject **)(a1 + 64);
  if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
  {
    unsigned __int8 v45 = sub_1009219BC(v9);
    p_src = (std::string *)__src.__r_.__value_.__r.__words[0];
    if ((__src.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      p_src = &__src;
    }
    *(_DWORD *)long long buf = 136315394;
    *(void *)&uint8_t buf[4] = p_src;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = v45;
    _os_log_error_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "wrm preference sent on dormant sim [%s] with dormant reason [%s]", buf, 0x16u);
  }
LABEL_73:
  if (SHIBYTE(__src.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__src.__r_.__value_.__l.__data_);
  }
}

void sub_1005FF970(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,void *__p,uint64_t a28,int a29,__int16 a30,char a31,char a32)
{
  if (*(char *)(v33 - 169) < 0) {
    operator delete(*(void **)(v33 - 192));
  }
  if (*(char *)(v33 - 145) < 0) {
    operator delete(*(void **)(v33 - 168));
  }
  sub_10004D2C8(v32);
  if (a32 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_1005FFAB4(uint64_t a1, uint64_t a2)
{
  __s1[0] = 0;
  __s1[1] = 0;
  uint64_t v24 = 0;
  if (*(char *)(a2 + 23) < 0)
  {
    sub_10004FC84(__s1, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)__s1 = *(_OWORD *)a2;
    uint64_t v24 = *(void *)(a2 + 16);
  }
  sub_1005F1284(&__p, a1);
  if (v24 >= 0) {
    uint64_t v4 = (void *)HIBYTE(v24);
  }
  else {
    uint64_t v4 = __s1[1];
  }
  std::string::size_type size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  int v6 = SHIBYTE(__p.__r_.__value_.__r.__words[2]);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
    std::string::size_type size = __p.__r_.__value_.__l.__size_;
  }
  if (v4 != (void *)size)
  {
    BOOL v16 = 0;
    if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_26;
    }
    goto LABEL_29;
  }
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    p_p = &__p;
  }
  else {
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  if (v24 < 0)
  {
    BOOL v16 = memcmp(__s1[0], p_p, (size_t)__s1[1]) == 0;
    goto LABEL_25;
  }
  if (HIBYTE(v24))
  {
    uint64_t v8 = HIBYTE(v24) - 1;
    unsigned int v9 = __s1;
    do
    {
      int v11 = *(unsigned __int8 *)v9;
      unsigned int v9 = (void **)((char *)v9 + 1);
      int v10 = v11;
      int v13 = p_p->__r_.__value_.__s.__data_[0];
      p_p = (std::string *)((char *)p_p + 1);
      int v12 = v13;
      BOOL v15 = v8-- != 0;
      BOOL v16 = v10 == v12;
    }
    while (v10 == v12 && v15);
LABEL_25:
    if ((v6 & 0x80000000) == 0) {
      goto LABEL_26;
    }
LABEL_29:
    operator delete(__p.__r_.__value_.__l.__data_);
    if (!v16) {
      goto LABEL_31;
    }
    goto LABEL_30;
  }
  BOOL v16 = 1;
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    goto LABEL_29;
  }
LABEL_26:
  if (v16) {
LABEL_30:
  }
    sub_1005EECFC(a1);
LABEL_31:
  if (*(unsigned char *)(a2 + 24) != 2) {
    goto LABEL_42;
  }
  if (SHIBYTE(v24) < 0)
  {
    sub_10004FC84(v20, __s1[0], (unint64_t)__s1[1]);
  }
  else
  {
    *(_OWORD *)BOOL v20 = *(_OWORD *)__s1;
    uint64_t v21 = v24;
  }
  char v17 = sub_1005F1348(a1, (long long *)v20);
  char v18 = v17;
  if (SHIBYTE(v21) < 0)
  {
    operator delete(v20[0]);
    if (v18) {
      goto LABEL_42;
    }
  }
  else if (v17)
  {
    goto LABEL_42;
  }
  long long v19 = *(NSObject **)(a1 + 64);
  if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(__p.__r_.__value_.__l.__data_) = 0;
    _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#I There is sim disabled, maybe trigger signUpForSIMService or fetchGeofence data", (uint8_t *)&__p, 2u);
  }
  sub_1005FFCC8(a1);
LABEL_42:
  if (SHIBYTE(v24) < 0) {
    operator delete(__s1[0]);
  }
}

void sub_1005FFC90(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a25 < 0) {
    operator delete(a20);
  }
  _Unwind_Resume(exception_object);
}

void sub_1005FFCC8(uint64_t a1)
{
  memset(&v23, 0, sizeof(v23));
  int v2 = *(const std::string **)(a1 + 504);
  char v3 = *(uint64_t **)(a1 + 512);
  if (v2 != (const std::string *)v3)
  {
    uint64_t v4 = v2 + 3;
    do
    {
      if (subscriber::isSimReady())
      {
        uint64_t v5 = *(NSObject **)(a1 + 64);
        if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
        {
          int v6 = v4;
          if (SHIBYTE(v4->__r_.__value_.__r.__words[2]) < 0) {
            int v6 = (const std::string *)v4->__r_.__value_.__r.__words[0];
          }
          LODWORD(buf) = 136315138;
          *(void *)((char *)&buf + 4) = v6;
          _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#I enabled sim %s", (uint8_t *)&buf, 0xCu);
        }
        std::string::size_type size = HIBYTE(v23.__r_.__value_.__r.__words[2]);
        if ((v23.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
          std::string::size_type size = v23.__r_.__value_.__l.__size_;
        }
        if (size)
        {
          unsigned int v9 = *(NSObject **)(a1 + 64);
          if (!os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_52;
          }
          LOWORD(buf) = 0;
          int v10 = "#I DualSIM mode, do nothing";
LABEL_31:
          _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, v10, (uint8_t *)&buf, 2u);
          goto LABEL_52;
        }
        std::string::operator=(&v23, v4);
      }
      uint64_t v8 = (uint64_t *)&v4[4];
      v4 += 7;
    }
    while (v8 != v3);
    if (SHIBYTE(v23.__r_.__value_.__r.__words[2]) < 0)
    {
      if (!v23.__r_.__value_.__l.__size_) {
        goto LABEL_29;
      }
      long long buf = 0uLL;
      uint64_t v26 = 0;
      sub_10004FC84(&__p, v23.__r_.__value_.__l.__data_, v23.__r_.__value_.__l.__size_);
    }
    else
    {
      if (!*((unsigned char *)&v23.__r_.__value_.__s + 23)) {
        goto LABEL_29;
      }
      long long buf = 0uLL;
      uint64_t v26 = 0;
      std::string __p = v23;
    }
    sub_1005F07F4((uint64_t)&buf, a1, (void **)&__p.__r_.__value_.__l.__data_);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    if (sub_1005FB4A8(a1, (uint64_t)&buf))
    {
      int v11 = *(NSObject **)(a1 + 64);
      if (!os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_50;
      }
      int v12 = &v23;
      if ((v23.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        int v12 = (std::string *)v23.__r_.__value_.__r.__words[0];
      }
      p_long long buf = &buf;
      if (v26 < 0) {
        p_long long buf = (long long *)buf;
      }
      LODWORD(__dst.__r_.__value_.__l.__data_) = 136315394;
      *(std::string::size_type *)((char *)__dst.__r_.__value_.__r.__words + 4) = (std::string::size_type)v12;
      WORD2(__dst.__r_.__value_.__r.__words[1]) = 2080;
      *(std::string::size_type *)((char *)&__dst.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)p_buf;
      uint64_t v14 = "#I offload exist and binding info exist %s => %s, do nothing";
      BOOL v15 = v11;
      uint32_t v16 = 22;
      goto LABEL_44;
    }
    if (SHIBYTE(v23.__r_.__value_.__r.__words[2]) < 0) {
      sub_10004FC84(&__dst, v23.__r_.__value_.__l.__data_, v23.__r_.__value_.__l.__size_);
    }
    else {
      std::string __dst = v23;
    }
    uint64_t v17 = sub_10010E194(*(void ***)(a1 + 824), (void **)&__dst.__r_.__value_.__l.__data_);
    uint64_t v18 = v17;
    if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(__dst.__r_.__value_.__l.__data_);
      if (v18) {
        goto LABEL_37;
      }
    }
    else if (v17)
    {
LABEL_37:
      if (SHIBYTE(v23.__r_.__value_.__r.__words[2]) < 0) {
        sub_10004FC84(&__dst, v23.__r_.__value_.__l.__data_, v23.__r_.__value_.__l.__size_);
      }
      else {
        std::string __dst = v23;
      }
      uint64_t v21 = sub_10005DDEC(a1 + 816, (void **)&__dst.__r_.__value_.__l.__data_);
      if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__dst.__r_.__value_.__l.__data_);
      }
      if (sub_100600DB4(v21)) {
        sub_1005F6BAC(a1, (uint64_t)&v23);
      }
      goto LABEL_50;
    }
    long long v19 = *(NSObject **)(a1 + 64);
    if (!os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_50;
    }
    BOOL v20 = &v23;
    if ((v23.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      BOOL v20 = (std::string *)v23.__r_.__value_.__r.__words[0];
    }
    LODWORD(__dst.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)__dst.__r_.__value_.__r.__words + 4) = (std::string::size_type)v20;
    uint64_t v14 = "#I entitlement doesn't have info for %s";
    BOOL v15 = v19;
    uint32_t v16 = 12;
LABEL_44:
    _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, v14, (uint8_t *)&__dst, v16);
LABEL_50:
    if (SHIBYTE(v26) < 0) {
      operator delete((void *)buf);
    }
    goto LABEL_52;
  }
LABEL_29:
  unsigned int v9 = *(NSObject **)(a1 + 64);
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(buf) = 0;
    int v10 = "#I No SIM is active, skip signup or fetch geofence";
    goto LABEL_31;
  }
LABEL_52:
  if (SHIBYTE(v23.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v23.__r_.__value_.__l.__data_);
  }
}

void sub_100600074(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  if (*(char *)(v28 - 57) < 0) {
    operator delete(*(void **)(v28 - 80));
  }
  if (a22 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

const void **sub_1006000E4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  values = @"GeofenceOptimizations";
  CFArrayRef v6 = CFArrayCreate(kCFAllocatorDefault, (const void **)&values, 1, &kCFTypeArrayCallBacks);
  CFDictionaryRef theDict = 0;
  CFArrayRef v34 = v6;
  uint64_t v7 = *(void *)(a1 + 72);
  CFArrayRef v32 = v6;
  if (v6) {
    CFRetain(v6);
  }
  (*(void (**)(void **__return_ptr, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, CFArrayRef *))(*(void *)v7 + 152))(__p, v7, a3 + 40, a3 + 64, a3 + 88, a3 + 112, a2, &v32);
  sub_10004EFE4(&theDict, (CFTypeRef *)__p);
  sub_10005717C((const void **)__p);
  sub_100044D00((const void **)&v32);
  if (theDict) {
    uint64_t v8 = sub_100080778;
  }
  else {
    uint64_t v8 = 0;
  }
  if (v8)
  {
    CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(theDict, @"GeofenceOptimizations");
    CFDictionaryRef v10 = Value;
    if (Value)
    {
      CFTypeID v11 = CFGetTypeID(Value);
      if (v11 == CFDictionaryGetTypeID())
      {
        if (CFDictionaryContainsKey(v10, @"Enabled"))
        {
          int v12 = (BOOL *)CFDictionaryGetValue(v10, @"Enabled");
          int v13 = v12;
          LOBYTE(__p[0]) = 0;
          if (v12)
          {
            CFTypeID v14 = CFGetTypeID(v12);
            if (v14 == CFBooleanGetTypeID()) {
              ctu::cf::assign((ctu::cf *)__p, v13, v15);
            }
          }
          int v16 = LOBYTE(__p[0]);
          *(unsigned char *)(a3 + 200) = __p[0];
          if (!v16) {
            goto LABEL_33;
          }
        }
        else if (!*(unsigned char *)(a3 + 200))
        {
          goto LABEL_33;
        }
        (***(void (****)(Registry **__return_ptr))(a1 + 72))(&v30);
        ServiceMap = (std::mutex *)Registry::getServiceMap(v30);
        uint64_t v18 = ServiceMap;
        if (v19 < 0)
        {
          BOOL v20 = (unsigned __int8 *)(v19 & 0x7FFFFFFFFFFFFFFFLL);
          uint64_t v21 = 5381;
          do
          {
            uint64_t v19 = v21;
            unsigned int v22 = *v20++;
            uint64_t v21 = (33 * v21) ^ v22;
          }
          while (v22);
        }
        std::mutex::lock(ServiceMap);
        __p[0] = (void *)v19;
        std::string v23 = sub_10004D37C(&v18[1].__m_.__sig, (unint64_t *)__p);
        if (v23)
        {
          uint64_t v25 = v23[3];
          uint64_t v24 = (std::__shared_weak_count *)v23[4];
          if (v24)
          {
            atomic_fetch_add_explicit(&v24->__shared_owners_, 1uLL, memory_order_relaxed);
            std::mutex::unlock(v18);
            atomic_fetch_add_explicit(&v24->__shared_owners_, 1uLL, memory_order_relaxed);
            sub_10004D2C8(v24);
            char v26 = 0;
LABEL_24:
            if (*(char *)(a2 + 23) < 0)
            {
              sub_10004FC84(__p, *(void **)a2, *(void *)(a2 + 8));
            }
            else
            {
              *(_OWORD *)std::string __p = *(_OWORD *)a2;
              uint64_t v29 = *(void *)(a2 + 16);
            }
            (*(void (**)(uint64_t, void **, const __CFString *, const CFBooleanRef, const __CFString *, void, uint64_t, void))(*(void *)v25 + 16))(v25, __p, @"isPnwSim", kCFBooleanTrue, @"PrivateNetwork", 0, 2, 0);
            if (SHIBYTE(v29) < 0) {
              operator delete(__p[0]);
            }
            if ((v26 & 1) == 0) {
              sub_10004D2C8(v24);
            }
            if (v31) {
              sub_10004D2C8(v31);
            }
            goto LABEL_33;
          }
        }
        else
        {
          uint64_t v25 = 0;
        }
        std::mutex::unlock(v18);
        uint64_t v24 = 0;
        char v26 = 1;
        goto LABEL_24;
      }
    }
  }
LABEL_33:
  sub_100057D78((const void **)&theDict);
  return sub_100044D00((const void **)&v34);
}

void sub_100600420(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, std::__shared_weak_count *a16, char a17, int a18, const void *a19, const void *a20)
{
  if ((v21 & 1) == 0) {
    sub_10004D2C8(v20);
  }
  if (a16) {
    sub_10004D2C8(a16);
  }
  sub_100057D78(&a19);
  sub_100044D00(&a20);
  _Unwind_Resume(a1);
}

void *sub_1006004BC(void *a1)
{
  int v2 = (std::__shared_weak_count *)a1[8];
  if (v2) {
    sub_10004D2C8(v2);
  }
  sub_10041A970(a1 + 3);
  char v3 = (std::__shared_weak_count *)a1[2];
  if (v3) {
    sub_10004D2C8(v3);
  }
  return a1;
}

uint64_t sub_100600500(uint64_t a1)
{
  return a1;
}

uint64_t sub_100600538(uint64_t a1, uint64_t a2)
{
  return sub_1005FB4A8(a1 - 24, a2);
}

void sub_100600540(void *a1, uint64_t a2)
{
  uint64_t v4 = (std::__shared_weak_count *)a1[12];
  if (v4)
  {
    uint64_t v5 = std::__shared_weak_count::lock(v4);
    if (v5 && a1[11]) {
      goto LABEL_8;
    }
  }
  else
  {
    uint64_t v5 = 0;
  }
  CFArrayRef v6 = a1[8];
  if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
  {
    LOWORD(buf.__r_.__value_.__l.__data_) = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "delegate is null", (uint8_t *)&buf, 2u);
  }
LABEL_8:
  sub_1005F7A9C((uint64_t)&buf, (uint64_t)a1, (void **)a2);
  long long v7 = *(_OWORD *)&buf.__r_.__value_.__l.__data_;
  p_std::string buf = &buf;
  sub_10019F8BC((void ***)&p_buf);
  if (*((void *)&v7 + 1) != (void)v7) {
    goto LABEL_33;
  }
  uint64_t v8 = a1[8];
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    if (*(char *)(a2 + 23) >= 0) {
      unsigned int v9 = (void *)a2;
    }
    else {
      unsigned int v9 = *(void **)a2;
    }
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v9;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#I There is no profile for %s, try to fetch profile", (uint8_t *)&buf, 0xCu);
  }
  memset(&buf, 0, sizeof(buf));
  if (*(char *)(a2 + 23) < 0)
  {
    sub_10004FC84(__p, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)a2;
    uint64_t v15 = *(void *)(a2 + 16);
  }
  sub_1005F14B8(&buf, (uint64_t)a1, (unsigned __int8 *)__p);
  if (SHIBYTE(v15) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
    sub_10004FC84(&__dst, buf.__r_.__value_.__l.__data_, buf.__r_.__value_.__l.__size_);
  }
  else {
    std::string __dst = buf;
  }
  int v10 = sub_1005F08AC(a1[63], a1[64], (uint64_t)&__dst);
  int v11 = v10;
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__dst.__r_.__value_.__l.__data_);
    if (!v11) {
      goto LABEL_31;
    }
LABEL_26:
    sub_1005F8D2C((uint64_t)a1, (uint64_t)&buf);
    if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
      sub_10004FC84(&v12, buf.__r_.__value_.__l.__data_, buf.__r_.__value_.__l.__size_);
    }
    else {
      std::string v12 = buf;
    }
    sub_1005F72F4((uint64_t)a1, (long long *)&v12, 1, 0);
    if (SHIBYTE(v12.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v12.__r_.__value_.__l.__data_);
    }
    goto LABEL_31;
  }
  if (v10) {
    goto LABEL_26;
  }
LABEL_31:
  if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(buf.__r_.__value_.__l.__data_);
  }
LABEL_33:
  if (v5) {
    sub_10004D2C8(v5);
  }
}

void sub_1006007A8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  if (v28) {
    sub_10004D2C8(v28);
  }
  _Unwind_Resume(exception_object);
}

void sub_10060081C(uint64_t a1, uint64_t a2)
{
}

void sub_100600824(void *a1, uint64_t a2)
{
  memset(&v33, 0, sizeof(v33));
  sub_100058DB0(&v33, "");
  if (a1[75] < 3uLL) {
    goto LABEL_45;
  }
  uint64_t v29 = a2;
  uint64_t v4 = a1[8];
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)std::string buf = 134217984;
    uint64_t v35 = 3;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I There are already %zu or more offload sim installed, will delete one", buf, 0xCu);
  }
  uint64_t v5 = (void *)a1[73];
  if (v5 == a1 + 74) {
    goto LABEL_38;
  }
  while (1)
  {
    if (sIsProfileInstalled()) {
      goto LABEL_26;
    }
    uint64_t v6 = a1[63];
    uint64_t v7 = a1[64];
    if (v6 != v7) {
      break;
    }
LABEL_25:
    if (v6 == v7) {
      goto LABEL_33;
    }
LABEL_26:
    int v16 = (void *)v5[1];
    if (v16)
    {
      do
      {
        uint64_t v17 = v16;
        int v16 = (void *)*v16;
      }
      while (v16);
    }
    else
    {
      do
      {
        uint64_t v17 = (void *)v5[2];
        BOOL v18 = *v17 == (void)v5;
        uint64_t v5 = v17;
      }
      while (!v18);
    }
    uint64_t v5 = v17;
    if (v17 == a1 + 74) {
      goto LABEL_38;
    }
  }
  uint64_t v8 = *((unsigned __int8 *)v5 + 55);
  size_t v9 = v5[5];
  if ((v8 & 0x80u) == 0) {
    uint64_t v10 = *((unsigned __int8 *)v5 + 55);
  }
  else {
    uint64_t v10 = v5[5];
  }
  do
  {
    uint64_t v11 = *(unsigned __int8 *)(v6 + 95);
    int v12 = (char)v11;
    if ((v11 & 0x80u) != 0) {
      uint64_t v11 = *(void *)(v6 + 80);
    }
    if (v10 == v11)
    {
      if (v12 >= 0) {
        int v13 = (unsigned __int8 *)(v6 + 72);
      }
      else {
        int v13 = *(unsigned __int8 **)(v6 + 72);
      }
      if ((v8 & 0x80) != 0)
      {
        if (!memcmp((const void *)v5[4], v13, v9)) {
          goto LABEL_25;
        }
      }
      else
      {
        if (!v8) {
          goto LABEL_25;
        }
        CFTypeID v14 = (unsigned __int8 *)(v5 + 4);
        uint64_t v15 = v8;
        while (*v14 == *v13)
        {
          ++v14;
          ++v13;
          if (!--v15) {
            goto LABEL_25;
          }
        }
      }
    }
    v6 += 168;
  }
  while (v6 != v7);
LABEL_33:
  uint64_t v19 = a1[8];
  if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v20 = (uint64_t)(v5 + 7);
    if (*((char *)v5 + 79) < 0) {
      uint64_t v20 = v5[7];
    }
    *(_DWORD *)std::string buf = 136315138;
    uint64_t v35 = v20;
    _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "#I find one off load sim to delete, iccid is (%s)", buf, 0xCu);
  }
  std::string::operator=(&v33, (const std::string *)(v5 + 7));
LABEL_38:
  std::string::size_type size = HIBYTE(v33.__r_.__value_.__r.__words[2]);
  if ((v33.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
    std::string::size_type size = v33.__r_.__value_.__l.__size_;
  }
  a2 = v29;
  if (!size)
  {
    std::string::operator=(&v33, (const std::string *)(a1[73] + 56));
    unsigned int v22 = a1[8];
    if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
    {
      std::string v23 = &v33;
      if ((v33.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        std::string v23 = (std::string *)v33.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)std::string buf = 136315138;
      uint64_t v35 = (uint64_t)v23;
      _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "#I all offload sim's mno is on device, so just pick (%s) to delete", buf, 0xCu);
    }
  }
LABEL_45:
  uint64_t v24 = (std::__shared_weak_count *)a1[12];
  if (v24)
  {
    uint64_t v25 = std::__shared_weak_count::lock(v24);
    if (v25)
    {
      char v26 = v25;
      uint64_t v27 = a1[11];
      if (v27)
      {
        char v28 = HIBYTE(v33.__r_.__value_.__r.__words[2]);
        if (SHIBYTE(v33.__r_.__value_.__r.__words[2]) < 0)
        {
          if (v33.__r_.__value_.__l.__size_)
          {
            sub_10004FC84(&__p, v33.__r_.__value_.__l.__data_, v33.__r_.__value_.__l.__size_);
            char v28 = HIBYTE(v33.__r_.__value_.__r.__words[2]);
LABEL_53:
            v30[0] = _NSConcreteStackBlock;
            v30[1] = 1174405120;
            int v30[2] = sub_100600CCC;
            v30[3] = &unk_1019ED750;
            v30[4] = a1;
            if (v28 < 0) {
              sub_10004FC84(&v31, v33.__r_.__value_.__l.__data_, v33.__r_.__value_.__l.__size_);
            }
            else {
              std::string v31 = v33;
            }
            (*(void (**)(uint64_t, std::string *, void *))(*(void *)v27 + 16))(v27, &__p, v30);
            if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(__p.__r_.__value_.__l.__data_);
            }
            if (SHIBYTE(v31.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(v31.__r_.__value_.__l.__data_);
            }
          }
        }
        else if (*((unsigned char *)&v33.__r_.__value_.__s + 23))
        {
          std::string __p = v33;
          goto LABEL_53;
        }
        (*(void (**)(uint64_t, uint64_t))(*(void *)v27 + 24))(v27, a2);
      }
      sub_10004D2C8(v26);
    }
  }
  if (SHIBYTE(v33.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v33.__r_.__value_.__l.__data_);
  }
}

void sub_100600C60(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33)
{
  if (a27 < 0) {
    operator delete(__p);
  }
  sub_10004D2C8(v33);
  if (a33 < 0) {
    operator delete(a28);
  }
  _Unwind_Resume(a1);
}

void sub_100600CCC(uint64_t a1, int a2)
{
  uint64_t v4 = *(NSObject **)(*(void *)(a1 + 32) + 64);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = (void *)(a1 + 40);
    if (*(char *)(a1 + 63) < 0) {
      uint64_t v5 = (void *)*v5;
    }
    uint64_t v6 = "False";
    if (a2) {
      uint64_t v6 = "True";
    }
    int v7 = 136315394;
    uint64_t v8 = v5;
    __int16 v9 = 2080;
    uint64_t v10 = v6;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#I mso iccid %s delete success =? %s", (uint8_t *)&v7, 0x16u);
  }
}

void sub_100600DAC(uint64_t a1, uint64_t a2)
{
}

BOOL sub_100600DB4(uint64_t a1)
{
  if ((*(unsigned char *)(a1 + 81) & 2) == 0) {
    return 0;
  }
  int v5 = 18;
  if ((*(unsigned char *)(a1 + 2) & 4) == 0) {
    return 1;
  }
  int v2 = *(uint64_t **)(a1 + 16);
  if (!v2) {
    return 0;
  }
  uint64_t v3 = a1 + 8;
  while (1)
  {
    int v4 = *((_DWORD *)v2 + 7);
    if (v4 <= 18) {
      break;
    }
LABEL_10:
    int v2 = (uint64_t *)*v2;
    if (!v2) {
      return 0;
    }
  }
  if (v4 != 18)
  {
    ++v2;
    goto LABEL_10;
  }
  return *(_DWORD *)sub_10012EF5C(v3, &v5) == 2;
}

void sub_100600E38(void *a1)
{
  int v2 = (std::__shared_weak_count *)a1[6];
  if (v2)
  {
    uint64_t v3 = a1[4];
    int v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      int v5 = v4;
      if (a1[5])
      {
        uint64_t v6 = *(NSObject **)(v3 + 64);
        if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)int v7 = 0;
          _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#I Attempt to setup geofences at first unlock after boot", v7, 2u);
        }
        if (*(_DWORD *)(v3 + 304) == 1) {
          (*(void (**)(void))(**(void **)(v3 + 104) + 72))(*(void *)(v3 + 104));
        }
      }
      sub_10004D2C8(v5);
    }
  }
}

void sub_100600F00(_Unwind_Exception *a1)
{
  sub_10004D2C8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100600F14(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_100600F30(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void *sub_100600F40(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *sub_100600FC4(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *sub_100601048(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *sub_1006010CC(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t **sub_100601150(uint64_t **result, long long *a2, long long *a3)
{
  int v5 = result;
  if (result[2])
  {
    uint64_t v6 = *result;
    int v7 = result[1];
    unsigned char *result = (uint64_t *)(result + 1);
    void v7[2] = 0;
    result[1] = 0;
    result[2] = 0;
    if (v6[1]) {
      uint64_t v8 = (uint64_t *)v6[1];
    }
    else {
      uint64_t v8 = v6;
    }
    uint64_t v15 = result;
    int v16 = v8;
    uint64_t v17 = v8;
    if (v8)
    {
      int v16 = sub_1000EA590((uint64_t)v8);
      if (a2 != a3)
      {
        __int16 v9 = a2;
        do
        {
          v18[0] = (uint64_t)(v8 + 4);
          v18[1] = (uint64_t)(v8 + 7);
          sub_1006012E4((uint64_t)v18, (uint64_t)(v9 + 2));
          v18[0] = 0;
          uint64_t v10 = (uint64_t **)sub_1000EA518((uint64_t)v5, v18, v17 + 4);
          sub_100046C38(v5, v18[0], v10, v17);
          uint64_t v17 = v16;
          if (v16) {
            int v16 = sub_1000EA590((uint64_t)v16);
          }
          uint64_t v11 = (long long *)*((void *)v9 + 1);
          if (v11)
          {
            do
            {
              a2 = v11;
              uint64_t v11 = *(long long **)v11;
            }
            while (v11);
          }
          else
          {
            do
            {
              a2 = (long long *)*((void *)v9 + 2);
              BOOL v12 = *(void *)a2 == (void)v9;
              __int16 v9 = a2;
            }
            while (!v12);
          }
          uint64_t v8 = v17;
          if (v17) {
            BOOL v12 = a2 == a3;
          }
          else {
            BOOL v12 = 1;
          }
          __int16 v9 = a2;
        }
        while (!v12);
      }
    }
    uint64_t result = (uint64_t **)sub_100601348((uint64_t)&v15);
  }
  if (a2 != a3)
  {
    do
    {
      uint64_t result = (uint64_t **)sub_1006013A0(v5, a2 + 2);
      int v13 = (long long *)*((void *)a2 + 1);
      if (v13)
      {
        do
        {
          CFTypeID v14 = v13;
          int v13 = *(long long **)v13;
        }
        while (v13);
      }
      else
      {
        do
        {
          CFTypeID v14 = (long long *)*((void *)a2 + 2);
          BOOL v12 = *(void *)v14 == (void)a2;
          a2 = v14;
        }
        while (!v12);
      }
      a2 = v14;
    }
    while (v14 != a3);
  }
  return result;
}

void sub_1006012D0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_100601348((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1006012E4(uint64_t a1, uint64_t a2)
{
  std::string::operator=(*(std::string **)a1, (const std::string *)a2);
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v5 = *(void *)(a2 + 40);
  *(_OWORD *)uint64_t v4 = *(_OWORD *)(a2 + 24);
  *(void *)(v4 + 16) = v5;
  std::string::operator=((std::string *)(v4 + 24), (const std::string *)(a2 + 48));
  std::string::operator=((std::string *)(v4 + 48), (const std::string *)(a2 + 72));
  return a1;
}

uint64_t sub_100601348(uint64_t a1)
{
  sub_10005CD90(*(void *)a1, *(void **)(a1 + 16));
  uint64_t v2 = *(void **)(a1 + 8);
  if (v2)
  {
    uint64_t v3 = (void *)v2[2];
    if (v3)
    {
      do
      {
        uint64_t v2 = v3;
        uint64_t v3 = (void *)v3[2];
      }
      while (v3);
      *(void *)(a1 + 8) = v2;
    }
    sub_10005CD90(*(void *)a1, v2);
  }
  return a1;
}

char *sub_1006013A0(uint64_t **a1, long long *a2)
{
  memset(v7, 0, sizeof(v7));
  sub_10030D604((uint64_t)a1, a2, v7);
  uint64_t v6 = 0;
  uint64_t v3 = (uint64_t **)sub_1000EA518((uint64_t)a1, &v6, (void *)v7[0] + 4);
  sub_100046C38(a1, v6, v3, (uint64_t *)v7[0]);
  uint64_t v4 = v7[0];
  v7[0] = 0;
  sub_10030D770((uint64_t)v7, 0);
  return v4;
}

void sub_100601418(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_10030D770((uint64_t)va, 0);
  _Unwind_Resume(a1);
}

void *sub_100601430(void *__dst, long long *a2, uint64_t a3)
{
  if (*((char *)a2 + 23) < 0)
  {
    sub_10004FC84(__dst, *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v5 = *a2;
    __dst[2] = *((void *)a2 + 2);
    *(_OWORD *)std::string __dst = v5;
  }
  sub_10006891C((uint64_t)(__dst + 3), a3);
  return __dst;
}

void sub_100601490(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t *sub_1006014AC(uint64_t **a1, uint64_t a2, void **a3, uint64_t a4)
{
  uint64_t v9 = 0;
  uint64_t v10 = 0;
  uint64_t v6 = (uint64_t **)sub_1000C6D50(a1, a2, &v10, &v9, a3);
  uint64_t result = *v6;
  if (!*v6)
  {
    memset(v8, 0, sizeof(v8));
    sub_10060153C((uint64_t)a1, a4, v8);
    sub_100046C38(a1, (uint64_t)v10, v6, v8[0]);
    return v8[0];
  }
  return result;
}

unsigned char *sub_10060153C@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  uint64_t v5 = a1 + 8;
  *a3 = 0;
  a3[2] = 0;
  a3[1] = 0;
  uint64_t v6 = a3 + 1;
  int v7 = (char *)operator new(0x40uLL);
  *a3 = v7;
  void *v6 = v5;
  *((unsigned char *)a3 + 16) = 0;
  uint64_t result = v7 + 32;
  if (*(char *)(a2 + 23) < 0)
  {
    uint64_t result = sub_10004FC84(result, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)uint64_t result = *(_OWORD *)a2;
    *((void *)v7 + 6) = *(void *)(a2 + 16);
  }
  v7[56] = *(unsigned char *)(a2 + 24);
  *((unsigned char *)a3 + 16) = 1;
  return result;
}

void sub_1006015D4(_Unwind_Exception *a1)
{
  void *v1 = 0;
  sub_1000C6EE8(v3, v2);
  _Unwind_Resume(a1);
}

uint64_t sub_1006015F0(uint64_t a1)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 8) = a1 + 16;
  *(void *)(a1 + 24) = 0;
  *(unsigned char *)(a1 + 32) = 0;
  *(unsigned char *)(a1 + 36) = 0;
  sub_100058DB0((void *)(a1 + 40), "");
  sub_100058DB0((void *)(a1 + 64), "");
  sub_100058DB0((void *)(a1 + 88), "");
  sub_100058DB0((void *)(a1 + 112), "");
  *(_OWORD *)(a1 + 216) = 0u;
  *(unsigned char *)(a1 + 136) = 0;
  *(unsigned char *)(a1 + 160) = 0;
  *(unsigned char *)(a1 + 168) = 0;
  *(unsigned char *)(a1 + 192) = 0;
  *(_WORD *)(a1 + 200) = 256;
  *(_DWORD *)(a1 + 208) = 0;
  *(_OWORD *)(a1 + 232) = 0u;
  *(_OWORD *)(a1 + 248) = 0u;
  sub_100058DB0((void *)(a1 + 264), "");
  sub_100058DB0((void *)(a1 + 288), "");
  *(_WORD *)(a1 + 312) = 0;
  *(_DWORD *)(a1 + 316) = 0;
  *(void *)(a1 + 336) = 0;
  *(void *)(a1 + 344) = 0;
  *(void *)(a1 + 320) = a1 + 328;
  *(void *)(a1 + 328) = 0;
  return a1;
}

void sub_100601708(_Unwind_Exception *a1)
{
  if (*(char *)(v2 + 287) < 0) {
    operator delete(*v7);
  }
  if (*(char *)(v2 + 263) < 0) {
    operator delete(*(void **)(v2 + 240));
  }
  if (*(char *)(v2 + 239) < 0) {
    operator delete(*v9);
  }
  if (*(unsigned char *)(v2 + 192) && *(char *)(v2 + 191) < 0) {
    operator delete(*(void **)(v2 + 168));
  }
  if (*(unsigned char *)(v2 + 160) && *(char *)(v2 + 159) < 0) {
    operator delete(*(void **)(v2 + 136));
  }
  if (*(char *)(v2 + 135) < 0) {
    operator delete(*v6);
  }
  if (*(char *)(v2 + 111) < 0) {
    operator delete(*v5);
  }
  if (*(char *)(v2 + 87) < 0) {
    operator delete(*v4);
  }
  if (*(char *)(v2 + 63) < 0) {
    operator delete(*v3);
  }
  sub_10005CD2C(v1, *v8);
  _Unwind_Resume(a1);
}

void *sub_1006017E8(void *__dst, long long *a2, uint64_t a3)
{
  if (*((char *)a2 + 23) < 0)
  {
    sub_10004FC84(__dst, *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v5 = *a2;
    __dst[2] = *((void *)a2 + 2);
    *(_OWORD *)std::string __dst = v5;
  }
  sub_100059120((uint64_t)(__dst + 3), a3);
  return __dst;
}

void sub_100601848(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

void *sub_100601864(unint64_t a1)
{
  if (a1 >= 0xAAAAAAAAAAAAAABLL) {
    sub_10006A7CC();
  }
  return operator new(24 * a1);
}

uint64_t sub_1006018AC(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24))
  {
    uint64_t v3 = *(void *)(*(void *)(a1 + 8) + 8);
    for (uint64_t i = *(void *)(*(void *)(a1 + 16) + 8); i != v3; i += 24)
    {
      if (*(char *)(i + 23) < 0) {
        operator delete(*(void **)i);
      }
    }
  }
  return a1;
}

uint64_t sub_10060190C(uint64_t a1)
{
  uint64_t v3 = *(void ***)(a1 + 8);
  uint64_t v2 = *(void ***)(a1 + 16);
  if (v2 != v3)
  {
    do
    {
      uint64_t v4 = v2 - 3;
      *(void *)(a1 + 16) = v2 - 3;
      if (*((char *)v2 - 1) < 0)
      {
        operator delete(*v4);
        uint64_t v4 = *(void ***)(a1 + 16);
      }
      uint64_t v2 = v4;
    }
    while (v4 != v3);
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t sub_100601970(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24))
  {
    uint64_t v3 = **(void **)(a1 + 8);
    for (uint64_t i = **(void **)(a1 + 16); i != v3; i -= 24)
    {
      if (*(char *)(i - 1) < 0) {
        operator delete(*(void **)(i - 24));
      }
    }
  }
  return a1;
}

void sub_1006019D0(void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (void **)**a1;
  if (v2)
  {
    uint64_t v4 = (void **)v1[1];
    long long v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        if (*((char *)v4 - 1) < 0) {
          operator delete(*(v4 - 3));
        }
        v4 -= 3;
      }
      while (v4 != v2);
      long long v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t sub_100601A5C(uint64_t a1, long long *a2, long long *a3)
{
  long long v4 = *a2;
  *(void *)(a1 + 16) = *((void *)a2 + 2);
  *(_OWORD *)a1 = v4;
  uint64_t v5 = a1 + 24;
  *((void *)a2 + 1) = 0;
  *((void *)a2 + 2) = 0;
  *(void *)a2 = 0;
  if (*((char *)a3 + 23) < 0)
  {
    sub_10004FC84((unsigned char *)v5, *(void **)a3, *((void *)a3 + 1));
  }
  else
  {
    long long v6 = *a3;
    *(void *)(v5 + 16) = *((void *)a3 + 2);
    *(_OWORD *)uint64_t v5 = v6;
  }
  return a1;
}

void sub_100601ABC(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t *sub_100601AD8(uint64_t *result, void *a2)
{
  uint64_t v2 = *result;
  uint64_t v3 = result[1];
  uint64_t v4 = a2[1];
  if (v3 == *result)
  {
    uint64_t v5 = a2[1];
  }
  else
  {
    do
    {
      uint64_t v5 = v4 - 72;
      long long v6 = *(_OWORD *)(v3 - 72);
      *(void *)(v4 - 56) = *(void *)(v3 - 56);
      *(_OWORD *)(v4 - 72) = v6;
      *(void *)(v3 - 64) = 0;
      *(void *)(v3 - 56) = 0;
      *(void *)(v3 - 72) = 0;
      long long v7 = *(_OWORD *)(v3 - 48);
      *(void *)(v4 - 32) = *(void *)(v3 - 32);
      *(_OWORD *)(v4 - 48) = v7;
      *(void *)(v3 - 40) = 0;
      *(void *)(v3 - 32) = 0;
      *(void *)(v3 - 48) = 0;
      *(void *)(v4 - 24) = 0;
      *(void *)(v4 - 16) = 0;
      *(void *)(v4 - 8) = 0;
      *(_OWORD *)(v4 - 24) = *(_OWORD *)(v3 - 24);
      *(void *)(v4 - 8) = *(void *)(v3 - 8);
      *(void *)(v3 - 24) = 0;
      *(void *)(v3 - 16) = 0;
      *(void *)(v3 - 8) = 0;
      v3 -= 72;
      v4 -= 72;
    }
    while (v3 != v2);
  }
  a2[1] = v5;
  uint64_t v8 = *result;
  unsigned char *result = v5;
  a2[1] = v8;
  uint64_t v9 = result[1];
  result[1] = a2[2];
  a2[2] = v9;
  uint64_t v10 = result[2];
  result[2] = a2[3];
  a2[3] = v10;
  *a2 = a2[1];
  return result;
}

uint64_t sub_100601B94(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 72;
    sub_10019F864(i - 72);
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void *sub_100601BE4(void *__dst, long long *a2)
{
  if (*((char *)a2 + 23) < 0)
  {
    sub_10004FC84(__dst, *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v4 = *a2;
    __dst[2] = *((void *)a2 + 2);
    *(_OWORD *)std::string __dst = v4;
  }
  sub_100059120((uint64_t)(__dst + 3), (uint64_t)a2 + 24);
  return __dst;
}

void sub_100601C40(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100601C5C(uint64_t a1, int a2)
{
  if (a2)
  {
    if (*(char *)(a1 + 79) < 0)
    {
      sub_10004FC84(__p, *(void **)(a1 + 56), *(void *)(a1 + 64));
    }
    else
    {
      *(_OWORD *)std::string __p = *(_OWORD *)(a1 + 56);
      uint64_t v9 = *(void *)(a1 + 72);
    }
    long long v4 = *(std::__shared_weak_count **)(a1 + 48);
    if (v4)
    {
      uint64_t v5 = *(void *)(a1 + 32);
      long long v6 = std::__shared_weak_count::lock(v4);
      if (v6)
      {
        if (*(void *)(a1 + 40))
        {
          *(void *)std::string buf = v5;
          if (SHIBYTE(v9) < 0)
          {
            sub_10004FC84(&buf[8], __p[0], (unint64_t)__p[1]);
          }
          else
          {
            *(_OWORD *)&uint8_t buf[8] = *(_OWORD *)__p;
            *(void *)&uint8_t buf[24] = v9;
          }
          long long v7 = *(std::__shared_weak_count **)(v5 + 40);
          if (v7)
          {
            if (std::__shared_weak_count::lock(v7)) {
              operator new();
            }
          }
          sub_100088B9C();
        }
        sub_10004D2C8(v6);
      }
    }
    if (SHIBYTE(v9) < 0) {
      operator delete(__p[0]);
    }
  }
  else if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR))
  {
    uint64_t v3 = (void *)(a1 + 80);
    if (*(char *)(a1 + 103) < 0) {
      uint64_t v3 = (void *)*v3;
    }
    *(_DWORD *)std::string buf = 136315650;
    *(void *)&uint8_t buf[4] = v3;
    *(_WORD *)&unsigned char buf[12] = 1024;
    *(_DWORD *)&buf[14] = 0;
    *(_WORD *)&buf[18] = 2080;
    *(void *)&buf[20] = asString();
    _os_log_error_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_ERROR, "delete %s return %{BOOL}d, error : %s", buf, 0x1Cu);
  }
}

void sub_100601EB4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  sub_10004D2C8(v14);
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

unsigned char *sub_100601EF8(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)(a1 + 32) = *(_OWORD *)(a2 + 32);
  uint64_t v4 = *(void *)(a2 + 48);
  *(void *)(a1 + 48) = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 16), 1uLL, memory_order_relaxed);
  }
  if (*(char *)(a2 + 79) < 0)
  {
    sub_10004FC84((unsigned char *)(a1 + 56), *(void **)(a2 + 56), *(void *)(a2 + 64));
  }
  else
  {
    long long v5 = *(_OWORD *)(a2 + 56);
    *(void *)(a1 + 72) = *(void *)(a2 + 72);
    *(_OWORD *)(a1 + 56) = v5;
  }
  uint64_t result = (unsigned char *)(a1 + 80);
  if (*(char *)(a2 + 103) < 0) {
    return sub_10004FC84(result, *(void **)(a2 + 80), *(void *)(a2 + 88));
  }
  long long v7 = *(_OWORD *)(a2 + 80);
  *(void *)(a1 + 96) = *(void *)(a2 + 96);
  *(_OWORD *)uint64_t result = v7;
  return result;
}

void sub_100601FA0(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 79) < 0) {
    operator delete(*v2);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(v1 + 48);
  if (v4) {
    std::__shared_weak_count::__release_weak(v4);
  }
  _Unwind_Resume(exception_object);
}

void sub_100601FD0(uint64_t a1)
{
  if (*(char *)(a1 + 103) < 0) {
    operator delete(*(void **)(a1 + 80));
  }
  if (*(char *)(a1 + 79) < 0) {
    operator delete(*(void **)(a1 + 56));
  }
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 48);
  if (v2)
  {
    std::__shared_weak_count::__release_weak(v2);
  }
}

uint64_t *sub_100602034(uint64_t *a1)
{
  uint64_t v1 = *a1;
  long long v5 = a1;
  uint64_t v6 = v1;
  uint64_t v2 = *(void *)v1;
  v7[0] = 1;
  long long v8 = 0u;
  uint64_t v9 = 0;
  v7[1] = v2 + 552;
  uint64_t v3 = (uint64_t **)sub_100346B40((uint64_t)&v8, v2 + 584);
  sub_10010F808(v3, (void **)(v1 + 8));
  if (!v9) {
    sub_1005F67C8(v2);
  }
  sub_100606180((uint64_t)v7);
  sub_1001102C4(&v6);
  return sub_100046B58((uint64_t *)&v5);
}

void sub_1006020C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

const void **sub_1006020EC(const void **a1)
{
  uint64_t v2 = *a1;
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

const void **sub_100602120(const void **a1, const void **a2)
{
  if (a1 != a2)
  {
    long long v5 = 0;
    sub_100602178(&v5, a2);
    uint64_t v3 = *a1;
    *a1 = v5;
    long long v5 = v3;
    sub_10007CA64(&v5);
  }
  return a1;
}

const void **sub_100602178(const void **a1, const void **a2)
{
  uint64_t v3 = *a2;
  *a1 = *a2;
  if (v3) {
    CFRetain(v3);
  }
  return a1;
}

void *sub_1006021B0(void *__dst, long long *a2, uint64_t a3)
{
  if (*((char *)a2 + 23) < 0)
  {
    sub_10004FC84(__dst, *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v5 = *a2;
    __dst[2] = *((void *)a2 + 2);
    *(_OWORD *)std::string __dst = v5;
  }
  sub_100059120((uint64_t)(__dst + 3), a3);
  return __dst;
}

void sub_100602210(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10060222C(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 136))
  {
    sub_10005CD90(a1 + 112, *(void **)(a1 + 120));
    if (*(char *)(a1 + 103) < 0) {
      operator delete(*(void **)(a1 + 80));
    }
    if (*(char *)(a1 + 79) < 0) {
      operator delete(*(void **)(a1 + 56));
    }
    if (*(char *)(a1 + 55) < 0) {
      operator delete(*(void **)(a1 + 32));
    }
    if (*(char *)(a1 + 31) < 0) {
      operator delete(*(void **)(a1 + 8));
    }
  }
  return a1;
}

void sub_1006022A4(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_100602370(void *a1)
{
  __cxa_begin_catch(a1);
  dispatch_barrier_async_f(v1[6], v1, (dispatch_function_t)sub_100602448);
  __cxa_rethrow();
}

void sub_100602398(_Unwind_Exception *a1)
{
}

void sub_1006023B0(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete();
}

void sub_1006023E8(uint64_t a1)
{
}

uint64_t sub_100602404(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_100602448(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void sub_100602474(uint64_t a1, void *a2)
{
  if (a2)
  {
    sub_100602474(a1, *a2);
    sub_100602474(a1, a2[1]);
    sub_1006024D0((uint64_t)(a2 + 4));
    operator delete(a2);
  }
}

void sub_1006024D0(uint64_t a1)
{
  sub_10006544C(a1 + 24);
  if (*(char *)(a1 + 23) < 0)
  {
    uint64_t v2 = *(void **)a1;
    operator delete(v2);
  }
}

void sub_100602520(uint64_t a1, void *a2)
{
  if (a2)
  {
    sub_100602520(a1, *a2);
    sub_100602520(a1, a2[1]);
    sub_10060257C((uint64_t)(a2 + 4));
    operator delete(a2);
  }
}

void sub_10060257C(uint64_t a1)
{
  sub_10005CD90(a1 + 136, *(void **)(a1 + 144));
  if (*(char *)(a1 + 127) < 0) {
    operator delete(*(void **)(a1 + 104));
  }
  if (*(char *)(a1 + 103) < 0) {
    operator delete(*(void **)(a1 + 80));
  }
  if (*(char *)(a1 + 79) < 0) {
    operator delete(*(void **)(a1 + 56));
  }
  if (*(char *)(a1 + 55) < 0) {
    operator delete(*(void **)(a1 + 32));
  }
  if (*(char *)(a1 + 23) < 0)
  {
    uint64_t v2 = *(void **)a1;
    operator delete(v2);
  }
}

char *sub_100602610(uint64_t **a1, void **a2, uint64_t a3, long long **a4)
{
  uint64_t v11 = 0;
  uint64_t v6 = (char **)sub_100046ED4((uint64_t)a1, &v11, a2);
  long long v7 = *v6;
  if (!*v6)
  {
    long long v8 = (uint64_t **)v6;
    memset(v10, 0, sizeof(v10));
    sub_1006026C8((uint64_t)a1, a4, v10);
    sub_100046C38(a1, v11, v8, (uint64_t *)v10[0]);
    long long v7 = v10[0];
    v10[0] = 0;
    sub_100602860((uint64_t)v10, 0);
  }
  return v7;
}

char *sub_1006026C8@<X0>(uint64_t a1@<X0>, long long **a2@<X2>, char **a3@<X8>)
{
  long long v5 = (char *)(a1 + 8);
  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  uint64_t v6 = (char *)operator new(0xC0uLL);
  *a3 = v6;
  a3[1] = v5;
  *((unsigned char *)a3 + 16) = 0;
  long long v8 = *a2;
  uint64_t result = sub_100602750(v6 + 32, &v8);
  *((unsigned char *)a3 + 16) = 1;
  return result;
}

void sub_100602738(_Unwind_Exception *a1)
{
  sub_100602860(v1, 0);
  _Unwind_Resume(a1);
}

char *sub_100602750(char *__dst, long long **a2)
{
  uint64_t v3 = *a2;
  if (*((char *)*a2 + 23) < 0)
  {
    sub_10004FC84(__dst, *(void **)v3, *((void *)v3 + 1));
  }
  else
  {
    long long v4 = *v3;
    *((void *)__dst + 2) = *((void *)v3 + 2);
    *(_OWORD *)std::string __dst = v4;
  }
  *((void *)__dst + 19) = 0;
  *(_OWORD *)(__dst + 136) = 0u;
  *(_OWORD *)(__dst + 120) = 0u;
  *(_OWORD *)(__dst + 104) = 0u;
  *(_OWORD *)(__dst + 88) = 0u;
  *(_OWORD *)(__dst + 72) = 0u;
  *(_OWORD *)(__dst + 56) = 0u;
  *(_OWORD *)(__dst + 40) = 0u;
  *(_OWORD *)(__dst + 24) = 0u;
  sub_100058DB0((void *)__dst + 10, "");
  sub_100058DB0((void *)__dst + 13, "");
  *((_WORD *)__dst + 64) = 0;
  *((_DWORD *)__dst + 33) = 0;
  *((void *)__dst + 19) = 0;
  *((void *)__dst + 18) = 0;
  *((void *)__dst + 17) = __dst + 144;
  return __dst;
}

void sub_10060280C(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 103) < 0) {
    operator delete(*v2);
  }
  if (*(char *)(v1 + 79) < 0) {
    operator delete(*(void **)(v1 + 56));
  }
  if (*(char *)(v1 + 55) < 0) {
    operator delete(*(void **)(v1 + 32));
  }
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100602860(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void **)a1;
  *(void *)a1 = a2;
  if (v2)
  {
    if (*(unsigned char *)(a1 + 16)) {
      sub_10060257C((uint64_t)v2 + 32);
    }
    operator delete(v2);
  }
}

uint64_t *sub_1006028B8(uint64_t a1, void **a2, long long **a3)
{
  uint64_t v16 = 0;
  long long v5 = (uint64_t **)sub_100046ED4(a1, &v16, a2);
  uint64_t v6 = *v5;
  if (!*v5)
  {
    long long v7 = v5;
    long long v8 = *a3;
    uint64_t v15 = 0;
    uint64_t v9 = (uint64_t *)operator new(0xC0uLL);
    uint64_t v10 = v9;
    v14[0] = v9;
    v14[1] = (uint64_t *)(a1 + 8);
    if (*((char *)v8 + 23) < 0)
    {
      sub_10004FC84((unsigned char *)v9 + 32, *(void **)v8, *((void *)v8 + 1));
    }
    else
    {
      long long v11 = *v8;
      void v9[6] = *((void *)v8 + 2);
      *((_OWORD *)v9 + 2) = v11;
    }
    v10[23] = 0;
    *(_OWORD *)(v10 + 21) = 0u;
    *(_OWORD *)(v10 + 19) = 0u;
    *(_OWORD *)(v10 + 17) = 0u;
    *(_OWORD *)(v10 + 15) = 0u;
    *(_OWORD *)(v10 + 13) = 0u;
    *(_OWORD *)(v10 + 11) = 0u;
    *(_OWORD *)(v10 + 9) = 0u;
    *(_OWORD *)(v10 + 7) = 0u;
    sub_100058DB0(v10 + 14, "");
    sub_100058DB0(v10 + 17, "");
    v10[22] = 0;
    BOOL v12 = v10 + 22;
    *((_WORD *)v12 - 8) = 0;
    *((_DWORD *)v12 - 3) = 0;
    v12[1] = 0;
    *(v12 - 1) = (uint64_t)v12;
    LOBYTE(v15) = 1;
    sub_100046C38((uint64_t **)a1, v16, v7, v14[0]);
    uint64_t v6 = v14[0];
    v14[0] = 0;
    sub_100602860((uint64_t)v14, 0);
  }
  return v6;
}

void sub_1006029F0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_100602A58(void ***a1, void **a2)
{
  uint64_t v3 = sub_100046F68((uint64_t)a1, a2);
  if (a1 + 1 != (void ***)v3)
  {
    long long v4 = (uint64_t *)v3;
    long long v5 = (void **)v3[1];
    if (v5)
    {
      do
      {
        uint64_t v6 = v5;
        long long v5 = (void **)*v5;
      }
      while (v5);
    }
    else
    {
      long long v7 = v3;
      do
      {
        uint64_t v6 = (void **)v7[2];
        BOOL v8 = *v6 == v7;
        long long v7 = v6;
      }
      while (!v8);
    }
    if (*a1 == v3) {
      *a1 = v6;
    }
    uint64_t v9 = (uint64_t *)a1[1];
    a1[2] = (void **)((char *)a1[2] - 1);
    sub_10005EE6C(v9, v4);
    sub_10060257C((uint64_t)(v4 + 4));
    operator delete(v4);
  }
}

uint64_t sub_100602B08(uint64_t a1, int *a2, uint64_t a3)
{
  *(void *)(a1 + 8) = 0;
  long long v4 = (uint64_t *)(a1 + 8);
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = a1 + 8;
  if (a3)
  {
    uint64_t v6 = 4 * a3;
    do
    {
      sub_100602B88((uint64_t **)a1, v4, a2, a2);
      ++a2;
      v6 -= 4;
    }
    while (v6);
  }
  return a1;
}

void sub_100602B70(_Unwind_Exception *a1)
{
  sub_1000346F8(v1, *(void **)(v1 + 8));
  _Unwind_Resume(a1);
}

uint64_t *sub_100602B88(uint64_t **a1, uint64_t *a2, int *a3, _DWORD *a4)
{
  uint64_t v10 = 0;
  long long v11 = 0;
  uint64_t v6 = sub_10005CF3C(a1, a2, &v11, &v10, a3);
  long long v7 = (uint64_t *)*v6;
  if (!*v6)
  {
    BOOL v8 = (uint64_t **)v6;
    long long v7 = (uint64_t *)operator new(0x20uLL);
    *((_DWORD *)v7 + 7) = *a4;
    sub_100046C38(a1, (uint64_t)v11, v8, v7);
  }
  return v7;
}