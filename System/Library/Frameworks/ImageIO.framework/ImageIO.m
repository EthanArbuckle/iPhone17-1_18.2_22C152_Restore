uint64_t CGImageMetadataTagKeyHash(const void **a1)
{
  const void *v2;

  if (!a1) {
    return -1;
  }
  v2 = *a1;
  if (!v2 || !a1[1]) {
    return -1;
  }
  CFHash(v2);
  CFHash(a1[1]);
  return os_simple_hash();
}

void AdobeXMPCore_Int::NameSpacePrefixMapImpl::~NameSpacePrefixMapImpl(AdobeXMPCore_Int::NameSpacePrefixMapImpl *this, uint64_t *a2)
{
  uint64_t v3 = *a2;
  *(void *)this = *a2;
  *(void *)((char *)this + *(void *)(v3 - 176)) = a2[1];
  *(void *)((char *)this + *(void *)(*(void *)this - 48)) = a2[2];
  *(void *)((char *)this + *(void *)(*(void *)this - 56)) = a2[3];
  *(void *)((char *)this + *(void *)(*(void *)this - 64)) = a2[4];
  *(void *)((char *)this + *(void *)(*(void *)this - 72)) = a2[5];
  *(void *)((char *)this + *(void *)(*(void *)this - 80)) = a2[6];
  *(void *)((char *)this + *(void *)(*(void *)this - 88)) = a2[7];
  *(void *)((char *)this + *(void *)(*(void *)this - 184)) = a2[8];
  *(void *)((char *)this + *(void *)(*(void *)this - 200)) = a2[9];
  std::__tree<std::__value_type<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>,std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>>,std::__map_value_compare<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>,std::__value_type<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>,std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>>,AdobeXMPCore_Int::IUTF8StringComparator,true>,AdobeXMPCore_Int::TAllocator<std::__value_type<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>,std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>>>>::destroy((uint64_t)this + 32, *((void **)this + 5));
  std::__tree<std::__value_type<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>,std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>>,std::__map_value_compare<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>,std::__value_type<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>,std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>>,AdobeXMPCore_Int::IUTF8StringComparator,true>,AdobeXMPCore_Int::TAllocator<std::__value_type<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>,std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>>>>::destroy((uint64_t)this + 8, *((void **)this + 2));
}

uint64_t std::__tree<std::__value_type<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>,std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>>,std::__map_value_compare<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>,std::__value_type<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>,std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>>,AdobeXMPCore_Int::IUTF8StringComparator,true>,AdobeXMPCore_Int::TAllocator<std::__value_type<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>,std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>>>>::destroy(uint64_t result, void *a2)
{
  if (a2)
  {
    uint64_t v3 = result;
    std::__tree<std::__value_type<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>,std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>>,std::__map_value_compare<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>,std::__value_type<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>,std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>>,AdobeXMPCore_Int::IUTF8StringComparator,true>,AdobeXMPCore_Int::TAllocator<std::__value_type<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>,std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>>>>::destroy(result, *a2);
    std::__tree<std::__value_type<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>,std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>>,std::__map_value_compare<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>,std::__value_type<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>,std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>>,AdobeXMPCore_Int::IUTF8StringComparator,true>,AdobeXMPCore_Int::TAllocator<std::__value_type<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>,std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>>>>::destroy(v3, a2[1]);
    std::__destroy_at[abi:ne180100]<std::pair<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const> const,std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>>,0>((uint64_t)(a2 + 4));
    v5 = *(uint64_t (**)(void))(*(void *)AdobeXMPCore_Int::IMemoryAllocator_I::GetMemoryAllocator(v4) + 8);
    return v5();
  }
  return result;
}

void std::__destroy_at[abi:ne180100]<std::pair<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const> const,std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>>,0>(uint64_t a1)
{
  v2 = *(std::__shared_weak_count **)(a1 + 24);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 8);
  if (v3)
  {
    std::__shared_weak_count::__release_shared[abi:ne180100](v3);
  }
}

uint64_t AdobeXMPCore_Int::NameSpacePrefixMapImpl::Insert(AdobeXMPCore_Int::NameSpacePrefixMapImpl *this, char *a2, const char *a3, const char *a4, uint64_t a5)
{
  int64_t v7 = (int64_t)a3;
  uint64_t v9 = AdobeXMPCore_Int::VerifyParameters((AdobeXMPCore_Int *)1, 1, a2, a4, a3, a5);
  if (v9)
  {
    if (a2 && v7 == -1) {
      int64_t v7 = strlen(a2);
    }
    if (a4 && a5 == -1) {
      strlen(a4);
    }
    if (v7 <= 0)
    {
      exception = __cxa_allocate_exception(0x18uLL);
      v13 = "Empty XML name";
LABEL_66:
      *(_DWORD *)exception = 102;
      exception[1] = v13;
      *((unsigned char *)exception + 16) = 0;
    }
    if (*a2 < 0)
    {
      v24[0] = 0;
      v22[0] = 0;
      CodePoint_from_UTF8(a2, 4uLL, v24, v22);
      v11 = &a2[v22[0]];
      if (v24[0] - 192 >= 0x17
        && v24[0] - 216 >= 0x1F
        && v24[0] - 248 >= 0x208
        && v24[0] - 880 >= 0xE
        && v24[0] - 895 >= 0x1C81
        && (v24[0] & 0xFFFFFFFE) != 0x200C
        && v24[0] - 8304 >= 0x120
        && v24[0] - 11264 >= 0x3F0
        && v24[0] - 12289 >= 0xA7FF
        && v24[0] - 63744 >= 0x4D0
        && v24[0] - 65008 >= 0x20E
        && (v24[0] - 0x10000) >> 17 > 6)
      {
        goto LABEL_13;
      }
    }
    else
    {
      int v10 = *a2;
      v11 = a2 + 1;
      if ((v10 - 97) >= 0x1A && v10 != 95 && (v10 - 65) >= 0x1A)
      {
LABEL_13:
        exception = __cxa_allocate_exception(0x18uLL);
        v13 = "Bad XML name";
        goto LABEL_66;
      }
    }
    if (v11 >= &a2[v7])
    {
LABEL_63:
      long long v23 = 0uLL;
      AdobeXMPCore_Int::IUTF8String_I::CreateUTF8String((AdobeXMPCore_Int::IUTF8String_I *)a2, (const char *)v7);
    }
    while (1)
    {
      if (*v11 < 0)
      {
        v24[0] = 0;
        v22[0] = 0;
        CodePoint_from_UTF8(v11, 4uLL, v24, v22);
        v11 += v22[0];
        if (v24[0] - 192 >= 0x17 && v24[0] - 216 >= 0x1F)
        {
          BOOL v20 = v24[0] - 248 >= 0x208 && v24[0] - 880 >= 0xE;
          if (v20
            && v24[0] - 895 >= 0x1C81
            && (v24[0] & 0xFFFFFFFE) != 0x200C
            && v24[0] - 8304 >= 0x120
            && v24[0] - 11264 >= 0x3F0
            && v24[0] - 12289 >= 0xA7FF
            && v24[0] - 63744 >= 0x4D0
            && v24[0] - 768 >= 0x70
            && v24[0] - 65008 >= 0x20E
            && v24[0] - 0x10000 >= 0xE0000
            && v24[0] - 8255 >= 2
            && v24[0] != 183)
          {
            goto LABEL_13;
          }
        }
      }
      else
      {
        int v14 = *v11++;
        if ((v14 - 97) >= 0x1A && v14 != 95 && (v14 - 65) >= 0x1A)
        {
          unsigned int v16 = v14 - 48;
          unsigned int v17 = v14 - 45;
          if (v16 >= 0xA && v17 >= 2) {
            goto LABEL_13;
          }
        }
      }
      if (v11 >= &a2[v7]) {
        goto LABEL_63;
      }
    }
  }
  return v9;
}

void sub_18858B3C0()
{
}

void sub_18858B5C4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16, uint64_t a17, std::__shared_weak_count *a18)
{
  if (a16) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a16);
  }
  if (a18) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a18);
  }
  __cxa_end_catch();
  JUMPOUT(0x18858B5ECLL);
}

void std::__shared_weak_count::__release_shared[abi:ne180100](std::__shared_weak_count *a1)
{
  if (!atomic_fetch_add(&a1->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))a1->__on_zero_shared)(a1);
    std::__shared_weak_count::__release_weak(a1);
  }
}

void *std::__tree<std::__value_type<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>,std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>>,std::__map_value_compare<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>,std::__value_type<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>,std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>>,AdobeXMPCore_Int::IUTF8StringComparator,true>,AdobeXMPCore_Int::TAllocator<std::__value_type<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>,std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>>>>::find<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>>(uint64_t a1, uint64_t a2)
{
  v2 = (void *)(a1 + 8);
  uint64_t v3 = *(void **)(a1 + 8);
  if (!v3) {
    return v2;
  }
  uint64_t v5 = a1 + 16;
  v6 = (void *)(a1 + 8);
  do
  {
    BOOL v7 = AdobeXMPCore_Int::IUTF8StringComparator::operator()(v5, (uint64_t)(v3 + 4), a2);
    v8 = v3 + 1;
    if (!v7)
    {
      v8 = v3;
      v6 = v3;
    }
    uint64_t v3 = (void *)*v8;
  }
  while (*v8);
  if (v6 == v2 || AdobeXMPCore_Int::IUTF8StringComparator::operator()(v5, a2, (uint64_t)(v6 + 4))) {
    return v2;
  }
  return v6;
}

uint64_t *std::__tree<std::__value_type<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>,std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>>,std::__map_value_compare<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>,std::__value_type<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>,std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>>,AdobeXMPCore_Int::IUTF8StringComparator,true>,AdobeXMPCore_Int::TAllocator<std::__value_type<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>,std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>>>>::__emplace_unique_key_args<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>,std::piecewise_construct_t const&,std::tuple<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const> const&>,std::tuple<>>(AdobeXMPCore_Int::IMemoryAllocator_I *a1, uint64_t a2, uint64_t a3, void **a4)
{
  uint64_t v9 = 0;
  v6 = (uint64_t **)std::__tree<std::__value_type<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>,std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>>,std::__map_value_compare<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>,std::__value_type<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>,std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>>,AdobeXMPCore_Int::IUTF8StringComparator,true>,AdobeXMPCore_Int::TAllocator<std::__value_type<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>,std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>>>>::__find_equal<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>>((uint64_t)a1, &v9, a2);
  result = *v6;
  if (!*v6)
  {
    memset(v8, 0, sizeof(v8));
    std::__tree<std::__value_type<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>,std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>>,std::__map_value_compare<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>,std::__value_type<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>,std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>>,AdobeXMPCore_Int::IUTF8StringComparator,true>,AdobeXMPCore_Int::TAllocator<std::__value_type<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>,std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>>>>::__construct_node<std::piecewise_construct_t const&,std::tuple<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const> const&>,std::tuple<>>(a1, a4, v8);
    std::__tree<std::__value_type<unsigned long,unsigned long>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,unsigned long>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,unsigned long>>>::__insert_node_at((uint64_t **)a1, v9, v6, v8[0]);
    return v8[0];
  }
  return result;
}

uint64_t *std::__tree<std::__value_type<unsigned long,unsigned long>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,unsigned long>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,unsigned long>>>::__insert_node_at(uint64_t **a1, uint64_t a2, uint64_t **a3, uint64_t *a4)
{
  *a4 = 0;
  a4[1] = 0;
  a4[2] = a2;
  *a3 = a4;
  uint64_t v5 = (uint64_t *)**a1;
  if (v5)
  {
    *a1 = v5;
    a4 = *a3;
  }
  result = std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(a1[1], a4);
  a1[2] = (uint64_t *)((char *)a1[2] + 1);
  return result;
}

uint64_t *std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(uint64_t *result, uint64_t *a2)
{
  *((unsigned char *)a2 + 24) = a2 == result;
  if (a2 != result)
  {
    do
    {
      v2 = (uint64_t *)a2[2];
      if (*((unsigned char *)v2 + 24)) {
        return result;
      }
      uint64_t v3 = (uint64_t *)v2[2];
      v4 = (uint64_t *)*v3;
      if ((uint64_t *)*v3 == v2)
      {
        uint64_t v7 = v3[1];
        if (!v7 || (v8 = *(unsigned __int8 *)(v7 + 24), uint64_t v5 = (unsigned char *)(v7 + 24), v8))
        {
          if ((uint64_t *)*v2 == a2)
          {
            uint64_t v9 = (uint64_t **)a2[2];
          }
          else
          {
            uint64_t v9 = (uint64_t **)v2[1];
            int v10 = *v9;
            v2[1] = (uint64_t)*v9;
            if (v10)
            {
              v10[2] = (uint64_t)v2;
              uint64_t v3 = (uint64_t *)v2[2];
            }
            v9[2] = v3;
            *(void *)(v2[2] + 8 * (*(void *)v2[2] != (void)v2)) = v9;
            *uint64_t v9 = v2;
            v2[2] = (uint64_t)v9;
            uint64_t v3 = v9[2];
            v2 = (uint64_t *)*v3;
          }
          *((unsigned char *)v9 + 24) = 1;
          *((unsigned char *)v3 + 24) = 0;
          uint64_t v13 = v2[1];
          *uint64_t v3 = v13;
          if (v13) {
            *(void *)(v13 + 16) = v3;
          }
          v2[2] = v3[2];
          *(void *)(v3[2] + 8 * (*(void *)v3[2] != (void)v3)) = v2;
          v2[1] = (uint64_t)v3;
          goto LABEL_27;
        }
      }
      else if (!v4 || (v6 = *((unsigned __int8 *)v4 + 24), uint64_t v5 = v4 + 3, v6))
      {
        if ((uint64_t *)*v2 == a2)
        {
          uint64_t v11 = a2[1];
          uint64_t *v2 = v11;
          if (v11)
          {
            *(void *)(v11 + 16) = v2;
            uint64_t v3 = (uint64_t *)v2[2];
          }
          a2[2] = (uint64_t)v3;
          *(void *)(v2[2] + 8 * (*(void *)v2[2] != (void)v2)) = a2;
          a2[1] = (uint64_t)v2;
          v2[2] = (uint64_t)a2;
          uint64_t v3 = (uint64_t *)a2[2];
        }
        else
        {
          a2 = (uint64_t *)a2[2];
        }
        *((unsigned char *)a2 + 24) = 1;
        *((unsigned char *)v3 + 24) = 0;
        v2 = (uint64_t *)v3[1];
        uint64_t v12 = *v2;
        v3[1] = *v2;
        if (v12) {
          *(void *)(v12 + 16) = v3;
        }
        v2[2] = v3[2];
        *(void *)(v3[2] + 8 * (*(void *)v3[2] != (void)v3)) = v2;
        uint64_t *v2 = (uint64_t)v3;
LABEL_27:
        v3[2] = (uint64_t)v2;
        return result;
      }
      *((unsigned char *)v2 + 24) = 1;
      a2 = v3;
      *((unsigned char *)v3 + 24) = v3 == result;
      *uint64_t v5 = 1;
    }
    while (v3 != result);
  }
  return result;
}

void AdobeXMPCore_Int::IUTF8String_I::CreateUTF8String(AdobeXMPCore_Int::IUTF8String_I *this, const char *a2)
{
  v3[0] = 0;
  v3[1] = 0;
  v2 = (char *)AdobeXMPCore_Int::MemoryManagedObject::operator new((AdobeXMPCore_Int::MemoryManagedObject *)0x50);
  AdobeXMPCore_Int::UTF8StringImpl::UTF8StringImpl(v2);
  AdobeXMPCore_Int::MakeUncheckedSharedPointer<AdobeXMPCore_Int::UTF8StringImpl>(v2, 1, v3);
}

void sub_18858BA64(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a12);
  }
  _Unwind_Resume(exception_object);
}

void *AdobeXMPCore_Int::UTF8StringImpl::assign@<X0>(AdobeXMPCore_Int::UTF8StringImpl *this@<X0>, char *a2@<X1>, size_t a3@<X2>, void *a4@<X8>)
{
  if (a2 && a3)
  {
    int v6 = (void **)((char *)this + 24);
    if (a3 == -1) {
      std::basic_string<char,std::char_traits<char>,AdobeXMPCore_Int::TAllocator<char>>::__assign_external(v6, a2);
    }
    else {
      std::basic_string<char,std::char_traits<char>,AdobeXMPCore_Int::TAllocator<char>>::__assign_external(v6, a2, a3);
    }
  }
  else if (*((char *)this + 47) < 0)
  {
    **((unsigned char **)this + 3) = 0;
    *((void *)this + 4) = 0;
  }
  else
  {
    *((unsigned char *)this + 24) = 0;
    *((unsigned char *)this + 47) = 0;
  }

  return AdobeXMPCore_Int::UTF8StringImpl::returnSelfSharedPointer(this, a4);
}

void *std::__tree<std::__value_type<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>,std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>>,std::__map_value_compare<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>,std::__value_type<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>,std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>>,AdobeXMPCore_Int::IUTF8StringComparator,true>,AdobeXMPCore_Int::TAllocator<std::__value_type<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>,std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>>>>::__construct_node<std::piecewise_construct_t const&,std::tuple<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const> const&>,std::tuple<>>@<X0>(AdobeXMPCore_Int::IMemoryAllocator_I *a1@<X0>, void **a2@<X2>, void *a3@<X8>)
{
  uint64_t v5 = (char *)a1 + 8;
  a3[2] = 0;
  MemoryAllocator = (uint64_t (***)(void, uint64_t))AdobeXMPCore_Int::IMemoryAllocator_I::GetMemoryAllocator(a1);
  result = (void *)(**MemoryAllocator)(MemoryAllocator, 64);
  *a3 = result;
  a3[1] = v5;
  uint64_t v8 = (*a2)[1];
  result[4] = **a2;
  result[5] = v8;
  if (v8) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v8 + 8), 1uLL, memory_order_relaxed);
  }
  result[6] = 0;
  result[7] = 0;
  *((unsigned char *)a3 + 16) = 1;
  return result;
}

uint64_t AdobeXMPCore_Int::MemoryManagedObject::operator new(AdobeXMPCore_Int::MemoryManagedObject *this)
{
  MemoryAllocator = (uint64_t (***)(void, AdobeXMPCore_Int::MemoryManagedObject *))AdobeXMPCore_Int::IMemoryAllocator_I::GetMemoryAllocator(this);
  uint64_t result = (**MemoryAllocator)(MemoryAllocator, this);
  if (!result)
  {
    exception = (std::bad_alloc *)__cxa_allocate_exception(8uLL);
    uint64_t v5 = std::bad_alloc::bad_alloc(exception);
    __cxa_throw(v5, MEMORY[0x1E4FBA360], MEMORY[0x1E4FBA2C0]);
  }
  return result;
}

uint64_t AdobeXMPCore_Int::IMemoryAllocator_I::GetMemoryAllocator(AdobeXMPCore_Int::IMemoryAllocator_I *this)
{
  if (AdobeXMPCore_Int::sDefaultMemoryAllocator(void)::onceToken != -1) {
    dispatch_once(&AdobeXMPCore_Int::sDefaultMemoryAllocator(void)::onceToken, &__block_literal_global_43);
  }
  if (AdobeXMPCore_Int::gDefaultMemoryAllocator) {
    return AdobeXMPCore_Int::gDefaultMemoryAllocator
  }
         + *(void *)(*(void *)AdobeXMPCore_Int::gDefaultMemoryAllocator - 56);
  else {
    return 0;
  }
}

void *AdobeXMPCore_Int::MemoryAllocatorWrapperImpl::allocate(AdobeXMPCore_Int::MemoryAllocatorWrapperImpl *this, uint64_t a2)
{
  size_t v3 = a2 + 8;
  v4 = (uint64_t (***)(void, size_t))*((void *)this + 1);
  if (v4) {
    uint64_t result = (void *)(**v4)(v4, v3);
  }
  else {
    uint64_t result = malloc_type_malloc(v3, 0x88C6C06BuLL);
  }
  if (result) {
    *result++ = *((void *)this + 1);
  }
  return result;
}

void **std::basic_string<char,std::char_traits<char>,AdobeXMPCore_Int::TAllocator<char>>::__assign_external(void **__dst, void *__src, size_t __len)
{
  LODWORD(v6) = *((char *)__dst + 23);
  if ((v6 & 0x80000000) != 0)
  {
    unint64_t v10 = (unint64_t)__dst[2];
    unint64_t v9 = (v10 & 0x7FFFFFFFFFFFFFFFLL) - 1;
    if (v9 < __len)
    {
      uint64_t v8 = (uint64_t)__dst[1];
      goto LABEL_6;
    }
    unint64_t v6 = HIBYTE(v10);
    uint64_t v7 = *__dst;
  }
  else
  {
    uint64_t v7 = __dst;
    if (__len > 0x16)
    {
      uint64_t v8 = *((unsigned __int8 *)__dst + 23);
      unint64_t v9 = 22;
LABEL_6:
      std::basic_string<char,std::char_traits<char>,AdobeXMPCore_Int::TAllocator<char>>::__grow_by_and_replace((AdobeXMPCore_Int::IMemoryAllocator_I *)__dst, v9, __len - v9, v8, 0, v8, __len, __src);
      return __dst;
    }
  }
  if (__len)
  {
    memmove(v7, __src, __len);
    LOBYTE(v6) = *((unsigned char *)__dst + 23);
  }
  if ((v6 & 0x80) != 0) {
    __dst[1] = (void *)__len;
  }
  else {
    *((unsigned char *)__dst + 23) = __len & 0x7F;
  }
  *((unsigned char *)v7 + __len) = 0;
  return __dst;
}

void std::shared_ptr<AdobeXMPCore_Int::UTF8StringImpl>::shared_ptr[abi:ne180100]<AdobeXMPCore_Int::UTF8StringImpl,std::__mem_fn<void (AdobeXMPCore_Int::SharedObjectImpl::*)(void)const>,void>(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_18858BE40(void *a1)
{
  __cxa_begin_catch(a1);
  v4 = (void *)((char *)v2 + *(void *)(*v2 - 448) + (v3 >> 1));
  if (v3) {
    v1 = *(void (**)(void *))(*v4 + v1);
  }
  v1(v4);
  __cxa_rethrow();
}

void sub_18858BEA8(_Unwind_Exception *a1)
{
}

void std::shared_ptr<AdobeXMPCommon::IUTF8StringProxy>::__enable_weak_this[abi:ne180100]<AdobeXMPCommon::IUTF8StringProxy,AdobeXMPCommon::IUTF8StringProxy,void>(uint64_t a1, void *a2, uint64_t a3)
{
  if (a2)
  {
    v4 = (std::__shared_weak_count *)a2[1];
    if (!v4 || v4->__shared_owners_ == -1)
    {
      uint64_t v5 = *(std::__shared_weak_count **)(a1 + 8);
      if (v5)
      {
        atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
        atomic_fetch_add_explicit(&v5->__shared_weak_owners_, 1uLL, memory_order_relaxed);
        v4 = (std::__shared_weak_count *)a2[1];
      }
      *a2 = a3;
      a2[1] = v5;
      if (v4) {
        std::__shared_weak_count::__release_weak(v4);
      }
      if (v5)
      {
        std::__shared_weak_count::__release_shared[abi:ne180100](v5);
      }
    }
  }
}

void AdobeXMPCore_Int::MakeUncheckedSharedPointer<AdobeXMPCore_Int::UTF8StringImpl>(char *a1@<X0>, int a2@<W3>, void *a3@<X8>)
{
  if (a1 || !a2)
  {
    (**(void (***)(char *))&a1[*(void *)(*(void *)a1 - 448)])(&a1[*(void *)(*(void *)a1 - 448)]);
    std::shared_ptr<AdobeXMPCore_Int::UTF8StringImpl>::shared_ptr[abi:ne180100]<AdobeXMPCore_Int::UTF8StringImpl,std::__mem_fn<void (AdobeXMPCore_Int::SharedObjectImpl::*)(void)const>,void>(a3, (uint64_t)a1);
  }
  AdobeXMPCore_Int::IError_I::CreateError(1, 6, 2);
}

void sub_18858C0D8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t AdobeXMPCore_Int::SharedObjectImpl::Acquire(uint64_t this)
{
  v1 = (atomic_ullong *)(this + 16);
  if (atomic_load((unint64_t *)(this + 16)))
  {
    unint64_t v3 = -1;
  }
  else
  {
    v1 = (atomic_ullong *)(this + 8);
    unint64_t v3 = 1;
  }
  atomic_fetch_add(v1, v3);
  return this;
}

void *AdobeXMPCore_Int::UTF8StringImpl::UTF8StringImpl(void *this)
{
  this[7] = &unk_1ED4CA190;
  *this = &unk_1ED4C9F10;
  this[6] = &unk_1ED4CA0C0;
  *(void *)((char *)this + unk_1ED4C9D70) = &unk_1ED4CA120;
  this[8] = 0;
  this[9] = 0;
  this[2] = 0;
  this[3] = 0;
  *this = off_1ED4EA3E0;
  this[1] = 0;
  this[5] = 0;
  this[6] = off_1ED4EA590;
  this[7] = off_1ED4EA5F8;
  this[4] = 0;
  return this;
}

void *AdobeXMPCore_Int::UTF8StringImpl::returnSelfSharedPointer@<X0>(AdobeXMPCore_Int::UTF8StringImpl *this@<X0>, void *a2@<X8>)
{
  uint64_t result = std::shared_ptr<AdobeXMPCommon::IUTF8StringProxy>::shared_ptr[abi:ne180100]<AdobeXMPCommon::IUTF8StringProxy,void>(v6, (void *)this + 1);
  uint64_t v4 = v6[0];
  if (v6[0]) {
    uint64_t v4 = v6[0] + *(void *)(*(void *)v6[0] - 408);
  }
  uint64_t v5 = v6[1];
  *a2 = v4;
  a2[1] = v5;
  return result;
}

void *std::shared_ptr<AdobeXMPCommon::IUTF8StringProxy>::shared_ptr[abi:ne180100]<AdobeXMPCommon::IUTF8StringProxy,void>(void *a1, void *a2)
{
  unint64_t v3 = (std::__shared_weak_count *)a2[1];
  *a1 = *a2;
  if (!v3)
  {
    a1[1] = 0;
LABEL_5:
    std::__throw_bad_weak_ptr[abi:ne180100]();
  }
  uint64_t v4 = std::__shared_weak_count::lock(v3);
  a1[1] = v4;
  if (!v4) {
    goto LABEL_5;
  }
  return a1;
}

uint64_t std::__shared_ptr_pointer<AdobeXMPCore_Int::UTF8StringImpl *,std::__mem_fn<void (AdobeXMPCore_Int::SharedObjectImpl::*)(void)const>,std::allocator<AdobeXMPCore_Int::UTF8StringImpl>>::__on_zero_shared(uint64_t a1)
{
  return std::__mem_fn<void (AdobeXMPCore_Int::SharedObjectImpl::*)(void)const>::operator()[abi:ne180100]<AdobeXMPCore_Int::UTF8StringImpl *&>(a1 + 32, (void *)(a1 + 24));
}

void AdobeXMPCore_Int::MemoryAllocatorWrapperImpl::deallocate(AdobeXMPCore_Int::MemoryAllocatorWrapperImpl *this, void *a2)
{
  uint64_t v4 = *(a2 - 1);
  unint64_t v3 = (char *)(a2 - 1);
  uint64_t v2 = v4;
  if (v4) {
    (*(void (**)(uint64_t, char *))(*(void *)v2 + 8))(v2, v3);
  }
  else {
    free(v3);
  }
}

void AdobeXMPCore_Int::MemoryManagedObject::operator delete(AdobeXMPCore_Int::IMemoryAllocator_I *a1)
{
  v1 = *(void (**)(void))(*(void *)AdobeXMPCore_Int::IMemoryAllocator_I::GetMemoryAllocator(a1) + 8);

  v1();
}

unint64_t *AdobeXMPCore_Int::SharedObjectImpl::Release(unint64_t *this)
{
  unint64_t v1 = atomic_load(this + 1);
  if (!v1 || atomic_fetch_add((atomic_ullong *volatile)this + 1, 0xFFFFFFFFFFFFFFFFLL) == 1) {
    return (unint64_t *)(*(uint64_t (**)(void))(*this + 32))();
  }
  return this;
}

uint64_t AdobeXMPCommon::ISharedObject::Release(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 8))();
}

void virtual thunk to'AdobeXMPCore_Int::UTF8StringImpl::~UTF8StringImpl(void *a1)
{
  AdobeXMPCore_Int::UTF8StringImpl::~UTF8StringImpl((AdobeXMPCore_Int::UTF8StringImpl *)((char *)a1
                                                                                       + *(void *)(*a1 - 48)));
}

{
  uint64_t v1;
  AdobeXMPCore_Int::SharedObjectImpl *v2;
  uint64_t vars8;

  uint64_t v2 = (AdobeXMPCore_Int::SharedObjectImpl *)(v1 + 56);

  AdobeXMPCore_Int::SharedObjectImpl::~SharedObjectImpl(v2, (uint64_t *)&off_1ED4DD478);
}

uint64_t std::__mem_fn<void (AdobeXMPCore_Int::SharedObjectImpl::*)(void)const>::operator()[abi:ne180100]<AdobeXMPCore_Int::UTF8StringImpl *&>(uint64_t a1, void *a2)
{
  uint64_t v2 = *a2 + *(void *)(*(void *)*a2 - 448);
  unint64_t v3 = *(uint64_t (**)(void *))a1;
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v5 = (void *)(v2 + (v4 >> 1));
  if (v4) {
    return (*(uint64_t (**)(void))(*v5 + v3))();
  }
  else {
    return v3(v5);
  }
}

void AdobeXMPCore_Int::UTF8StringImpl::~UTF8StringImpl(AdobeXMPCore_Int::UTF8StringImpl *this)
{
  AdobeXMPCore_Int::SharedObjectImpl::~SharedObjectImpl((AdobeXMPCore_Int::SharedObjectImpl *)(v2 + 56), (uint64_t *)&off_1ED4DD478);

  AdobeXMPCore_Int::MemoryManagedObject::operator delete(this);
}

{
  uint64_t v1;

  AdobeXMPCore_Int::SharedObjectImpl::~SharedObjectImpl((AdobeXMPCore_Int::SharedObjectImpl *)(v1 + 56), (uint64_t *)&off_1ED4DD478);
}

void AdobeXMPCore_Int::SharedObjectImpl::~SharedObjectImpl(AdobeXMPCore_Int::SharedObjectImpl *this, uint64_t *a2)
{
  uint64_t v2 = *a2;
  *(void *)this = *a2;
  *(void *)((char *)this + *(void *)(v2 - 72)) = a2[1];
  *(void *)((char *)this + *(void *)(*(void *)this - 56)) = a2[2];
  if (atomic_load((unint64_t *)this + 1)) {
    __assert_rtn("~SharedObjectImpl", "SharedObjectImpl.cpp", 32, "mRefCount == 0");
  }
}

void AdobeXMPCore_Int::UTF8StringImpl::~UTF8StringImpl(AdobeXMPCore_Int::UTF8StringImpl *this, uint64_t *a2)
{
  uint64_t v3 = *a2;
  *(void *)this = *a2;
  *(void *)((char *)this + *(void *)(v3 - 440)) = a2[1];
  *(void *)((char *)this + *(void *)(*(void *)this - 408)) = a2[2];
  *(void *)((char *)this + *(void *)(*(void *)this - 56)) = a2[3];
  *(void *)((char *)this + *(void *)(*(void *)this - 64)) = a2[4];
  *(void *)((char *)this + *(void *)(*(void *)this - 416)) = a2[5];
  uint64_t v4 = (AdobeXMPCore_Int::IMemoryAllocator_I *)a2[6];
  *(void *)((char *)this + *(void *)(*(void *)this - 448)) = v4;
  if (*((char *)this + 47) < 0)
  {
    uint64_t v5 = *((void *)this + 3);
    uint64_t MemoryAllocator = AdobeXMPCore_Int::IMemoryAllocator_I::GetMemoryAllocator(v4);
    (*(void (**)(uint64_t, uint64_t))(*(void *)MemoryAllocator + 8))(MemoryAllocator, v5);
  }
  uint64_t v7 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v7) {
    std::__shared_weak_count::__release_weak(v7);
  }
}

void AdobeXMPCore_Int::AutoSharedLock::~AutoSharedLock(uint64_t **this)
{
  AdobeXMPCore_Int::AutoSharedLock::Release(this);
  uint64_t v2 = (std::__shared_weak_count *)this[1];
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v2);
  }
}

uint64_t AdobeXMPCore_Int::VerifyParameters(AdobeXMPCore_Int *this, int a2, char *__s, const char *a4, const char *a5, uint64_t a6)
{
  if (this)
  {
    if (!__s) {
      AdobeXMPCore_Int::IError_I::CreateError(1, 1, 1);
    }
    if (a5 != (const char *)-1)
    {
      if (a5) {
        goto LABEL_5;
      }
LABEL_9:
      AdobeXMPCore_Int::IError_I::CreateError(1, 1, 1);
    }
    if (!strlen(__s)) {
      goto LABEL_9;
    }
  }
LABEL_5:
  if (!a2) {
    return 1;
  }
  if (!a4) {
    AdobeXMPCore_Int::IError_I::CreateError(1, 1, 1);
  }
  if (a6 == -1)
  {
    if (!strlen(a4)) {
      goto LABEL_16;
    }
  }
  else if (!a6)
  {
LABEL_16:
    AdobeXMPCore_Int::IError_I::CreateError(1, 1, 1);
  }
  return 1;
}

void sub_18858D000(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a10);
  }
  if (a12) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a12);
  }
  _Unwind_Resume(exception_object);
}

uint64_t AdobeXMPCore_Int::AutoSharedLock::AutoSharedLock(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v4 = *(uint64_t **)a2;
  *(void *)a1 = *(void *)a2;
  uint64_t v5 = *(void *)(a2 + 8);
  *(void *)(a1 + 8) = v5;
  if (v5)
  {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
    uint64_t v4 = *(uint64_t **)a1;
  }
  *(unsigned char *)(a1 + 16) = a3;
  if (v4)
  {
    uint64_t v6 = *v4;
    if (a3) {
      int v7 = (*(uint64_t (**)(void))(v6 + 40))();
    }
    else {
      int v7 = (*(uint64_t (**)(void))(v6 + 64))();
    }
    if (v7) {
      AdobeXMPCore_Int::IError_I::CreateError(4, v7, 4);
    }
  }
  return a1;
}

void sub_18858D23C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a10);
  }
  if (a12) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a12);
  }
  int v14 = *(std::__shared_weak_count **)(v12 + 8);
  if (v14) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v14);
  }
  _Unwind_Resume(exception_object);
}

uint64_t AdobeXMPCore_Int::SharedMutexImpl::Lock(AdobeXMPCore_Int::SharedMutexImpl *this)
{
  return 0;
}

uint64_t *AdobeXMPCore_Int::AutoSharedLock::Release(uint64_t **this)
{
  uint64_t result = *this;
  if (result)
  {
    uint64_t v3 = *result;
    if (*((unsigned char *)this + 16)) {
      uint64_t result = (uint64_t *)(*(uint64_t (**)(void))(v3 + 56))();
    }
    else {
      uint64_t result = (uint64_t *)(*(uint64_t (**)(void))(v3 + 80))();
    }
    if (result) {
      AdobeXMPCore_Int::IError_I::CreateError(4, (int)result, 4);
    }
  }
  return result;
}

void sub_18858D460(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a10);
  }
  if (a12) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a12);
  }
  _Unwind_Resume(exception_object);
}

BOOL XMP_NamespaceTable::Define(XMP_NamespaceTable *this, char *a2, char *a3, const char **a4, unsigned int *a5)
{
  uint64_t v61 = *MEMORY[0x1E4F143B8];
  v58 = (XMP_NamespaceTable *)((char *)this + 8);
  XMP_ReadWriteLock::Acquire((pthread_rwlock_t *)((char *)this + 8), 1);
  if (!a2 || !a3 || !*a2 || !*a3) {
    __assert_rtn("Define", "XMP_LibUtils.cpp", 451, "(_uri != 0) && (*_uri != 0) && (_suggPrefix != 0) && (*_suggPrefix != 0)");
  }
  long long v56 = 0uLL;
  uint64_t v57 = 0;
  std::string::basic_string[abi:ne180100]<0>(&v56, a2);
  memset(&v55, 0, sizeof(v55));
  std::string::basic_string[abi:ne180100]<0>(&v55, a3);
  std::string::size_type v10 = HIBYTE(v55.__r_.__value_.__r.__words[2]);
  char v11 = HIBYTE(v55.__r_.__value_.__r.__words[2]);
  std::string::size_type size = v55.__r_.__value_.__l.__size_;
  uint64_t v13 = (std::string *)v55.__r_.__value_.__r.__words[0];
  if ((v55.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type v14 = HIBYTE(v55.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type v14 = v55.__r_.__value_.__l.__size_;
  }
  if ((v55.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    uint64_t v13 = &v55;
  }
  if (v13->__r_.__value_.__s.__data_[v14 - 1] != 58)
  {
    std::string::push_back(&v55, 58);
    std::string::size_type v10 = HIBYTE(v55.__r_.__value_.__r.__words[2]);
    std::string::size_type size = v55.__r_.__value_.__l.__size_;
    char v11 = HIBYTE(v55.__r_.__value_.__r.__words[2]);
  }
  if (v11 < 0) {
    std::string::size_type v10 = size;
  }
  v15 = &a3[v10 - 1];
  if (v15 <= a3)
  {
    v18 = "Empty XML name";
    goto LABEL_123;
  }
  if (*a3 < 0)
  {
    *(_DWORD *)__str = 0;
    v53[0].__r_.__value_.__r.__words[0] = 0;
    CodePoint_from_UTF8(a3, 4uLL, (unsigned int *)__str, (unint64_t *)v53);
    unsigned int v17 = &a3[v53[0].__r_.__value_.__r.__words[0]];
    if ((*(_DWORD *)__str - 192) >= 0x17
      && (*(_DWORD *)__str - 216) >= 0x1F
      && (*(_DWORD *)__str - 248) >= 0x208
      && (*(_DWORD *)__str - 880) >= 0xE
      && (*(_DWORD *)__str - 895) >= 0x1C81
      && (*(_DWORD *)__str & 0xFFFFFFFE) != 0x200C
      && (*(_DWORD *)__str - 8304) >= 0x120
      && (*(_DWORD *)__str - 11264) >= 0x3F0
      && (*(_DWORD *)__str - 12289) >= 0xA7FF
      && (*(_DWORD *)__str - 63744) >= 0x4D0
      && (*(_DWORD *)__str - 65008) >= 0x20E
      && (*(_DWORD *)__str - 0x10000) >> 17 > 6)
    {
      goto LABEL_19;
    }
  }
  else
  {
    int v16 = *a3;
    unsigned int v17 = a3 + 1;
    if ((v16 - 97) >= 0x1A && v16 != 95 && (v16 - 65) >= 0x1A)
    {
LABEL_19:
      v18 = "Bad XML name";
LABEL_123:
      v52 = v18;
LABEL_124:
      exception = __cxa_allocate_exception(0x18uLL);
      *(_DWORD *)exception = 102;
      exception[1] = v52;
      *((unsigned char *)exception + 16) = 0;
    }
  }
  if (v17 < v15)
  {
    v52 = "Bad XML name";
    do
    {
      if (*v17 < 0)
      {
        *(_DWORD *)__str = 0;
        v53[0].__r_.__value_.__r.__words[0] = 0;
        CodePoint_from_UTF8(v17, 4uLL, (unsigned int *)__str, (unint64_t *)v53);
        v17 += v53[0].__r_.__value_.__r.__words[0];
        if ((*(_DWORD *)__str - 192) >= 0x17 && (*(_DWORD *)__str - 216) >= 0x1F)
        {
          BOOL v25 = (*(_DWORD *)__str - 248) >= 0x208 && (*(_DWORD *)__str - 880) >= 0xE;
          if (v25
            && (*(_DWORD *)__str - 895) >= 0x1C81
            && (*(_DWORD *)__str & 0xFFFFFFFE) != 0x200C
            && (*(_DWORD *)__str - 8304) >= 0x120
            && (*(_DWORD *)__str - 11264) >= 0x3F0
            && (*(_DWORD *)__str - 12289) >= 0xA7FF
            && (*(_DWORD *)__str - 63744) >= 0x4D0
            && (*(_DWORD *)__str - 768) >= 0x70
            && (*(_DWORD *)__str - 65008) >= 0x20E
            && (*(_DWORD *)__str - 0x10000) >= 0xE0000
            && (*(_DWORD *)__str - 8255) >= 2
            && *(_DWORD *)__str != 183)
          {
            goto LABEL_124;
          }
        }
      }
      else
      {
        int v19 = *v17++;
        if ((v19 - 97) >= 0x1A)
        {
          BOOL v20 = v19 != 95 && (v19 - 65) >= 0x1A;
          if (v20)
          {
            unsigned int v21 = v19 - 48;
            unsigned int v22 = v19 - 45;
            if (v21 >= 0xA && v22 >= 2) {
              goto LABEL_124;
            }
          }
        }
      }
    }
    while (v17 < v15);
  }
  v26 = (uint64_t **)((char *)this + 216);
  uint64_t v27 = std::__tree<std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>>>::find<std::string>((uint64_t)this + 216, (const void **)&v56);
  v28 = (uint64_t *)((char *)this + 224);
  if ((XMP_NamespaceTable *)((char *)this + 224) == (XMP_NamespaceTable *)v27)
  {
    memset(&v54, 0, sizeof(v54));
    if (SHIBYTE(v55.__r_.__value_.__r.__words[2]) < 0) {
      std::string::__init_copy_ctor_external(&v54, v55.__r_.__value_.__l.__data_, v55.__r_.__value_.__l.__size_);
    }
    else {
      std::string v54 = v55;
    }
    *(_OWORD *)__str = 0u;
    long long v60 = 0u;
    v29 = (uint64_t **)((char *)this + 240);
    v30 = (uint64_t *)((char *)this + 248);
    int v31 = 1;
    while (v30 != (uint64_t *)std::__tree<std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>>>::find<std::string>((uint64_t)v29, (const void **)&v54.__r_.__value_.__l.__data_))
    {
      snprintf(__str, 0x20uLL, "_%d_:", v31);
      std::string::operator=(&v54, &v55);
      std::string::size_type v32 = HIBYTE(v54.__r_.__value_.__r.__words[2]);
      if ((v54.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        std::string::size_type v32 = v54.__r_.__value_.__l.__size_;
      }
      std::string::erase(&v54, v32 - 1, 0xFFFFFFFFFFFFFFFFLL);
      ++v31;
      std::string::append(&v54, __str);
    }
    memset(v53, 0, sizeof(v53));
    std::pair<std::string,std::string>::pair[abi:ne180100]<std::string&,std::string&,0>(v53, &v56, (long long *)&v54);
    uint64_t v27 = (uint64_t)std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__emplace_hint_unique_key_args<std::string,std::pair<std::string,std::string> &>(v26, v28, (const void **)&v53[0].__r_.__value_.__l.__data_, (long long *)v53);
    std::string::size_type v33 = v53[0].__r_.__value_.__r.__words[2];
    long long v34 = *(_OWORD *)&v53[0].__r_.__value_.__l.__data_;
    v53[0] = v53[1];
    *(_OWORD *)&v53[1].__r_.__value_.__l.__data_ = v34;
    v53[1].__r_.__value_.__r.__words[2] = v33;
    std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__emplace_hint_unique_key_args<std::string,std::pair<std::string,std::string> &>(v29, v30, (const void **)&v53[0].__r_.__value_.__l.__data_, (long long *)v53);
    if (SHIBYTE(v53[1].__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v53[1].__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v53[0].__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v53[0].__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v54.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v54.__r_.__value_.__l.__data_);
    }
  }
  if (a4)
  {
    v35 = (const char *)(v27 + 56);
    if (*(char *)(v27 + 79) < 0) {
      v35 = *(const char **)v35;
    }
    *a4 = v35;
  }
  if (a5)
  {
    if (*(char *)(v27 + 79) < 0) {
      uint64_t v36 = *(void *)(v27 + 64);
    }
    else {
      LODWORD(v36) = *(unsigned __int8 *)(v27 + 79);
    }
    *a5 = v36;
  }
  uint64_t v37 = *(unsigned __int8 *)(v27 + 79);
  if ((v37 & 0x80u) == 0) {
    uint64_t v38 = *(unsigned __int8 *)(v27 + 79);
  }
  else {
    uint64_t v38 = *(void *)(v27 + 64);
  }
  std::string::size_type v39 = HIBYTE(v55.__r_.__value_.__r.__words[2]);
  int v40 = SHIBYTE(v55.__r_.__value_.__r.__words[2]);
  if ((v55.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
    std::string::size_type v39 = v55.__r_.__value_.__l.__size_;
  }
  if (v38 != v39)
  {
    BOOL v49 = 0;
    if ((SHIBYTE(v55.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_112;
    }
    goto LABEL_116;
  }
  v41 = (const void **)(v27 + 56);
  if ((v55.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    v42 = &v55;
  }
  else {
    v42 = (std::string *)v55.__r_.__value_.__r.__words[0];
  }
  if ((v37 & 0x80) != 0)
  {
    BOOL v49 = memcmp(*v41, v42, *(void *)(v27 + 64)) == 0;
    if (v40 < 0) {
      goto LABEL_116;
    }
  }
  else
  {
    if (*(unsigned char *)(v27 + 79))
    {
      uint64_t v43 = v37 - 1;
      do
      {
        int v45 = *(unsigned __int8 *)v41;
        v41 = (const void **)((char *)v41 + 1);
        int v44 = v45;
        int v47 = v42->__r_.__value_.__s.__data_[0];
        v42 = (std::string *)((char *)v42 + 1);
        int v46 = v47;
        BOOL v20 = v43-- != 0;
        char v48 = v20;
        BOOL v49 = v44 == v46;
      }
      while (v44 == v46 && (v48 & 1) != 0);
      if ((SHIBYTE(v55.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
        goto LABEL_112;
      }
      goto LABEL_116;
    }
    BOOL v49 = 1;
    if (SHIBYTE(v55.__r_.__value_.__r.__words[2]) < 0) {
LABEL_116:
    }
      operator delete(v55.__r_.__value_.__l.__data_);
  }
LABEL_112:
  if (SHIBYTE(v57) < 0) {
    operator delete((void *)v56);
  }
  XMP_AutoLock::~XMP_AutoLock(&v58);
  return v49;
}

void sub_18858DAF8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28,void *a29,uint64_t a30,int a31,__int16 a32,char a33,char a34,XMP_ReadWriteLock *a35)
{
  if (a28 < 0) {
    operator delete(__p);
  }
  if (a34 < 0) {
    operator delete(a29);
  }
  XMP_AutoLock::~XMP_AutoLock(&a35);
  _Unwind_Resume(a1);
}

BOOL XMP_NamespaceTable::GetPrefix(XMP_NamespaceTable *this, char *a2, const char **a3, unsigned int *a4)
{
  int v16 = (XMP_NamespaceTable *)((char *)this + 8);
  XMP_ReadWriteLock::Acquire((pthread_rwlock_t *)((char *)this + 8), 0);
  if (!a2 || !*a2) {
    __assert_rtn("GetPrefix", "XMP_LibUtils.cpp", 504, "(_uri != 0) && (*_uri != 0)");
  }
  __p[0] = 0;
  __p[1] = 0;
  uint64_t v15 = 0;
  std::string::basic_string[abi:ne180100]<0>(__p, a2);
  uint64_t v8 = std::__tree<std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>>>::find<std::string>((uint64_t)this + 216, (const void **)__p);
  unint64_t v9 = (char *)v8;
  std::string::size_type v10 = (char *)this + 224;
  if (v10 != (char *)v8)
  {
    if (a3)
    {
      char v11 = (const char *)(v8 + 56);
      if (*(char *)(v8 + 79) < 0) {
        char v11 = *(const char **)v11;
      }
      *a3 = v11;
    }
    if (a4)
    {
      if (*(char *)(v8 + 79) < 0) {
        uint64_t v12 = *(void *)(v8 + 64);
      }
      else {
        LODWORD(v12) = *(unsigned __int8 *)(v8 + 79);
      }
      *a4 = v12;
    }
  }
  if (SHIBYTE(v15) < 0) {
    operator delete(__p[0]);
  }
  XMP_AutoLock::~XMP_AutoLock(&v16);
  return v10 != v9;
}

void sub_18858DC84(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, XMP_ReadWriteLock *a15)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  XMP_AutoLock::~XMP_AutoLock(&a15);
  _Unwind_Resume(a1);
}

void *std::string::basic_string[abi:ne180100]<0>(void *a1, char *__s)
{
  size_t v4 = strlen(__s);
  if (v4 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  size_t v5 = v4;
  if (v4 >= 0x17)
  {
    uint64_t v7 = (v4 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v4 | 7) != 0x17) {
      uint64_t v7 = v4 | 7;
    }
    uint64_t v8 = v7 + 1;
    uint64_t v6 = operator new(v7 + 1);
    a1[1] = v5;
    a1[2] = v8 | 0x8000000000000000;
    *a1 = v6;
  }
  else
  {
    *((unsigned char *)a1 + 23) = v4;
    uint64_t v6 = a1;
    if (!v4) {
      goto LABEL_9;
    }
  }
  memmove(v6, __s, v5);
LABEL_9:
  *((unsigned char *)v6 + v5) = 0;
  return a1;
}

void XMP_AutoLock::~XMP_AutoLock(XMP_ReadWriteLock **this)
{
  uint64_t v2 = *this;
  if (v2) {
    XMP_ReadWriteLock::Release(v2);
  }
  *this = 0;
}

uint64_t XMP_ReadWriteLock::Acquire(pthread_rwlock_t *this, int a2)
{
  if (a2)
  {
    char v3 = a2;
    uint64_t result = pthread_rwlock_wrlock(this);
    if (!result)
    {
      BYTE4(this[1].__sig) = v3;
      if (atomic_load((unsigned int *)&this[1])) {
        XMP_ReadWriteLock::Acquire();
      }
      goto LABEL_7;
    }
    exception = __cxa_allocate_exception(0x18uLL);
    *(_DWORD *)exception = 11;
    uint64_t v7 = "Acquire pthread write lock failed";
LABEL_11:
    exception[1] = v7;
    *((unsigned char *)exception + 16) = 0;
  }
  uint64_t result = pthread_rwlock_rdlock(this);
  if (result)
  {
    exception = __cxa_allocate_exception(0x18uLL);
    *(_DWORD *)exception = 11;
    uint64_t v7 = "Acquire pthread read lock failed";
    goto LABEL_11;
  }
  if (BYTE4(this[1].__sig)) {
    XMP_ReadWriteLock::Acquire();
  }
LABEL_7:
  atomic_fetch_add((atomic_uint *volatile)&this[1], 1u);
  return result;
}

uint64_t XMP_ReadWriteLock::Release(XMP_ReadWriteLock *this)
{
  int v1 = atomic_load((unsigned int *)this + 50);
  if (v1 <= 0) {
    XMP_ReadWriteLock::Release();
  }
  atomic_fetch_add((atomic_uint *volatile)this + 50, 0xFFFFFFFF);
  if (*((unsigned char *)this + 204))
  {
    *((unsigned char *)this + 204) = 0;
    uint64_t result = pthread_rwlock_unlock((pthread_rwlock_t *)this);
    if (result)
    {
      exception = __cxa_allocate_exception(0x18uLL);
      *(_DWORD *)exception = 11;
      size_t v4 = "Release pthread write lock failed";
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t result = pthread_rwlock_unlock((pthread_rwlock_t *)this);
    if (result)
    {
      exception = __cxa_allocate_exception(0x18uLL);
      *(_DWORD *)exception = 11;
      size_t v4 = "Release pthread read lock failed";
LABEL_9:
      exception[1] = v4;
      *((unsigned char *)exception + 16) = 0;
    }
  }
  return result;
}

void *std::__tree<std::__value_type<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>,std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>>,std::__map_value_compare<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>,std::__value_type<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>,std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>>,AdobeXMPCore_Int::IUTF8StringComparator,true>,AdobeXMPCore_Int::TAllocator<std::__value_type<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>,std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>>>>::__find_equal<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>>(uint64_t a1, void *a2, uint64_t a3)
{
  size_t v5 = (void *)(a1 + 8);
  size_t v4 = *(void **)(a1 + 8);
  if (v4)
  {
    uint64_t v7 = a1 + 16;
    do
    {
      while (1)
      {
        uint64_t v8 = v4;
        uint64_t v9 = (uint64_t)(v4 + 4);
        if (!AdobeXMPCore_Int::IUTF8StringComparator::operator()(v7, a3, (uint64_t)(v4 + 4))) {
          break;
        }
        size_t v4 = (void *)*v8;
        size_t v5 = v8;
        if (!*v8) {
          goto LABEL_10;
        }
      }
      if (!AdobeXMPCore_Int::IUTF8StringComparator::operator()(v7, v9, a3)) {
        break;
      }
      size_t v5 = v8 + 1;
      size_t v4 = (void *)v8[1];
    }
    while (v4);
  }
  else
  {
    uint64_t v8 = (void *)(a1 + 8);
  }
LABEL_10:
  *a2 = v8;
  return v5;
}

BOOL AdobeXMPCore_Int::IUTF8StringComparator::operator()(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v5 = (*(uint64_t (**)(void))(**(void **)a2 + 208))();
  unint64_t v6 = (*(uint64_t (**)(void))(**(void **)a3 + 208))();
  uint64_t v7 = (const char *)(*(uint64_t (**)(void))(**(void **)a2 + 192))();
  uint64_t v8 = (const char *)(*(uint64_t (**)(void))(**(void **)a3 + 192))();
  if (v6 >= v5) {
    size_t v9 = v5;
  }
  else {
    size_t v9 = v6;
  }
  unsigned int v10 = strncmp(v7, v8, v9);
  if (v10) {
    BOOL v11 = 1;
  }
  else {
    BOOL v11 = v5 == v6;
  }
  if (v11) {
    return v10 >> 31;
  }
  else {
    return v5 < v6;
  }
}

uint64_t AdobeXMPCore_Int::UTF8StringImpl::c_str(AdobeXMPCore_Int::UTF8StringImpl *this)
{
  uint64_t result = (uint64_t)this + 24;
  if (*((char *)this + 47) < 0) {
    return *(void *)result;
  }
  return result;
}

uint64_t AdobeXMPCore_Int::UTF8StringImpl::size(AdobeXMPCore_Int::UTF8StringImpl *this)
{
  if (*((char *)this + 47) < 0) {
    return *((void *)this + 4);
  }
  else {
    return *((unsigned __int8 *)this + 47);
  }
}

uint64_t std::__tree<std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>>>::find<std::string>(uint64_t a1, const void **a2)
{
  uint64_t v2 = a1 + 8;
  uint64_t v3 = *(void *)(a1 + 8);
  if (!v3) {
    return v2;
  }
  uint64_t v5 = a1 + 16;
  uint64_t v6 = a1 + 8;
  do
  {
    BOOL v7 = std::less<std::string>::operator()[abi:ne180100](v5, (const void **)(v3 + 32), a2);
    uint64_t v8 = (uint64_t *)(v3 + 8);
    if (!v7)
    {
      uint64_t v8 = (uint64_t *)v3;
      uint64_t v6 = v3;
    }
    uint64_t v3 = *v8;
  }
  while (*v8);
  if (v6 == v2 || std::less<std::string>::operator()[abi:ne180100](v5, a2, (const void **)(v6 + 32))) {
    return v2;
  }
  return v6;
}

BOOL std::less<std::string>::operator()[abi:ne180100](uint64_t a1, const void **a2, const void **a3)
{
  int v3 = *((char *)a3 + 23);
  int v4 = *((char *)a2 + 23);
  if (v4 >= 0) {
    size_t v5 = *((unsigned __int8 *)a2 + 23);
  }
  else {
    size_t v5 = (size_t)a2[1];
  }
  if (v4 >= 0) {
    uint64_t v6 = a2;
  }
  else {
    uint64_t v6 = *a2;
  }
  if (v3 >= 0) {
    size_t v7 = *((unsigned __int8 *)a3 + 23);
  }
  else {
    size_t v7 = (size_t)a3[1];
  }
  if (v3 >= 0) {
    uint64_t v8 = a3;
  }
  else {
    uint64_t v8 = *a3;
  }
  if (v7 >= v5) {
    size_t v9 = v5;
  }
  else {
    size_t v9 = v7;
  }
  int v10 = memcmp(v6, v8, v9);
  if (v10) {
    return v10 < 0;
  }
  else {
    return v5 < v7;
  }
}

uint64_t *std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__emplace_hint_unique_key_args<std::string,std::pair<std::string,std::string> &>(uint64_t **a1, uint64_t *a2, const void **a3, long long *a4)
{
  uint64_t v11 = 0;
  uint64_t v12 = 0;
  uint64_t v6 = std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__find_equal<std::string>(a1, a2, &v12, &v11, a3);
  size_t v7 = (uint64_t *)*v6;
  if (!*v6)
  {
    uint64_t v8 = (uint64_t **)v6;
    memset(v10, 0, sizeof(v10));
    std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__construct_node<std::pair<std::string,std::string> &>((uint64_t)a1, a4, v10);
    std::__tree<std::__value_type<unsigned long,unsigned long>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,unsigned long>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,unsigned long>>>::__insert_node_at(a1, (uint64_t)v12, v8, v10[0]);
    size_t v7 = v10[0];
    v10[0] = 0;
    std::unique_ptr<std::__tree_node<std::__value_type<std::string,std::string>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::string,std::string>,void *>>>>::reset[abi:ne180100]((uint64_t)v10, 0);
  }
  return v7;
}

void *std::__tree<std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>>>::__find_equal<std::string>(uint64_t a1, void *a2, const void **a3)
{
  size_t v5 = (void *)(a1 + 8);
  uint64_t v4 = *(void *)(a1 + 8);
  if (v4)
  {
    uint64_t v7 = a1 + 16;
    do
    {
      while (1)
      {
        uint64_t v8 = (void *)v4;
        size_t v9 = (const void **)(v4 + 32);
        if (!std::less<std::string>::operator()[abi:ne180100](v7, a3, (const void **)(v4 + 32))) {
          break;
        }
        uint64_t v4 = *v8;
        size_t v5 = v8;
        if (!*v8) {
          goto LABEL_10;
        }
      }
      if (!std::less<std::string>::operator()[abi:ne180100](v7, v9, a3)) {
        break;
      }
      size_t v5 = v8 + 1;
      uint64_t v4 = v8[1];
    }
    while (v4);
  }
  else
  {
    uint64_t v8 = (void *)(a1 + 8);
  }
LABEL_10:
  *a2 = v8;
  return v5;
}

std::string *std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__construct_node<std::pair<std::string,std::string> &>@<X0>(uint64_t a1@<X0>, long long *a2@<X1>, void *a3@<X8>)
{
  uint64_t v5 = a1 + 8;
  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  uint64_t v6 = (char *)operator new(0x50uLL);
  *a3 = v6;
  a3[1] = v5;
  *((unsigned char *)a3 + 16) = 0;
  uint64_t result = std::pair<std::string const,std::string>::pair[abi:ne180100]<std::string,std::string,0>((std::string *)(v6 + 32), a2);
  *((unsigned char *)a3 + 16) = 1;
  return result;
}

void sub_18858E364(_Unwind_Exception *a1)
{
  std::unique_ptr<std::__tree_node<std::__value_type<std::string,std::string>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::string,std::string>,void *>>>>::reset[abi:ne180100](v1, 0);
  _Unwind_Resume(a1);
}

std::string *std::pair<std::string const,std::string>::pair[abi:ne180100]<std::string,std::string,0>(std::string *this, long long *a2)
{
  if (*((char *)a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(this, *(const std::string::value_type **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v4 = *a2;
    this->__r_.__value_.__r.__words[2] = *((void *)a2 + 2);
    *(_OWORD *)&this->__r_.__value_.__l.__data_ = v4;
  }
  uint64_t v5 = this + 1;
  if (*((char *)a2 + 47) < 0)
  {
    std::string::__init_copy_ctor_external(v5, *((const std::string::value_type **)a2 + 3), *((void *)a2 + 4));
  }
  else
  {
    long long v6 = *(long long *)((char *)a2 + 24);
    this[1].__r_.__value_.__r.__words[2] = *((void *)a2 + 5);
    *(_OWORD *)&v5->__r_.__value_.__l.__data_ = v6;
  }
  return this;
}

void sub_18858E3F8(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

void std::string::__init_copy_ctor_external(std::string *this, const std::string::value_type *__s, std::string::size_type __sz)
{
  uint64_t v5 = this;
  if (__sz > 0x16)
  {
    if (__sz >= 0x7FFFFFFFFFFFFFF8) {
      std::string::__throw_length_error[abi:ne180100]();
    }
    std::string::size_type v6 = (__sz & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((__sz | 7) != 0x17) {
      std::string::size_type v6 = __sz | 7;
    }
    std::string::size_type v7 = v6 + 1;
    uint64_t v8 = (std::string *)operator new(v6 + 1);
    v5->__r_.__value_.__l.__size_ = __sz;
    v5->__r_.__value_.__r.__words[2] = v7 | 0x8000000000000000;
    v5->__r_.__value_.__r.__words[0] = (std::string::size_type)v8;
    uint64_t v5 = v8;
  }
  else
  {
    *((unsigned char *)&this->__r_.__value_.__s + 23) = __sz;
  }

  memmove(v5, __s, __sz + 1);
}

void std::unique_ptr<std::__tree_node<std::__value_type<std::string,std::string>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::string,std::string>,void *>>>>::reset[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void **)a1;
  *(void *)a1 = a2;
  if (v2)
  {
    if (*(unsigned char *)(a1 + 16)) {
      std::__destroy_at[abi:ne180100]<std::pair<std::string const,std::string>,0>((uint64_t)v2 + 32);
    }
    operator delete(v2);
  }
}

const void **std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__find_equal<std::string>(void *a1, uint64_t *a2, const void ***a3, uint64_t *a4, const void **a5)
{
  size_t v9 = (const void **)(a1 + 1);
  if (a1 + 1 != a2 && !std::less<std::string>::operator()[abi:ne180100]((uint64_t)(a1 + 2), a5, (const void **)a2 + 4))
  {
    if (!std::less<std::string>::operator()[abi:ne180100]((uint64_t)(a1 + 2), (const void **)a2 + 4, a5))
    {
      *a3 = (const void **)a2;
      *a4 = (uint64_t)a2;
      return (const void **)a4;
    }
    a4 = a2 + 1;
    uint64_t v13 = a2[1];
    if (v13)
    {
      std::string::size_type v14 = (const void **)a2[1];
      do
      {
        uint64_t v15 = v14;
        std::string::size_type v14 = (const void **)*v14;
      }
      while (v14);
    }
    else
    {
      v18 = (const void **)a2;
      do
      {
        uint64_t v15 = (const void **)v18[2];
        BOOL v17 = *v15 == v18;
        v18 = v15;
      }
      while (!v17);
    }
    if (v15 != v9)
    {
      if (!std::less<std::string>::operator()[abi:ne180100]((uint64_t)(a1 + 2), a5, v15 + 4)) {
        goto LABEL_28;
      }
      uint64_t v13 = *a4;
    }
    if (v13)
    {
      *a3 = v15;
      return v15;
    }
    else
    {
      *a3 = (const void **)a2;
    }
    return (const void **)a4;
  }
  if ((uint64_t *)*a1 == a2)
  {
    uint64_t v12 = (const void **)a2;
LABEL_16:
    if (*a2)
    {
      *a3 = v12;
      return v12 + 1;
    }
    else
    {
      *a3 = (const void **)a2;
      return (const void **)a2;
    }
  }
  uint64_t v11 = (const void **)*a2;
  if (*a2)
  {
    do
    {
      uint64_t v12 = v11;
      uint64_t v11 = (const void **)v11[1];
    }
    while (v11);
  }
  else
  {
    int v16 = a2;
    do
    {
      uint64_t v12 = (const void **)v16[2];
      BOOL v17 = *v12 == v16;
      int v16 = (uint64_t *)v12;
    }
    while (v17);
  }
  if (std::less<std::string>::operator()[abi:ne180100]((uint64_t)(a1 + 2), v12 + 4, a5)) {
    goto LABEL_16;
  }
LABEL_28:

  return (const void **)std::__tree<std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>>>::__find_equal<std::string>((uint64_t)a1, a3, a5);
}

uint64_t AdobeXMPCore_Int::SharedMutexImpl::Unlock(AdobeXMPCore_Int::SharedMutexImpl *this)
{
  return 0;
}

unsigned char *std::basic_string<char,std::char_traits<char>,AdobeXMPCore_Int::TAllocator<char>>::__grow_by_and_replace(AdobeXMPCore_Int::IMemoryAllocator_I *a1, unint64_t a2, unint64_t a3, uint64_t a4, size_t a5, uint64_t a6, size_t a7, const void *a8)
{
  if (0x7FFFFFFFFFFFFFF6 - a2 < a3) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  uint64_t v15 = (char *)a1;
  if (*((char *)a1 + 23) < 0) {
    uint64_t v15 = *(char **)a1;
  }
  unint64_t v16 = a3 + a2;
  if (a3 + a2 <= 2 * a2) {
    unint64_t v16 = 2 * a2;
  }
  uint64_t v17 = (v16 & 0xFFFFFFFFFFFFFFF8) + 8;
  if ((v16 | 7) != 0x17) {
    uint64_t v17 = v16 | 7;
  }
  if (v16 >= 0x17) {
    uint64_t v18 = v17 + 1;
  }
  else {
    uint64_t v18 = 23;
  }
  if (a2 > 0x3FFFFFFFFFFFFFF2) {
    uint64_t v19 = 0x7FFFFFFFFFFFFFF7;
  }
  else {
    uint64_t v19 = v18;
  }
  uint64_t MemoryAllocator = (uint64_t (***)(void, uint64_t))AdobeXMPCore_Int::IMemoryAllocator_I::GetMemoryAllocator(a1);
  uint64_t result = (unsigned char *)(**MemoryAllocator)(MemoryAllocator, v19);
  unsigned int v22 = result;
  if (a5) {
    uint64_t result = memmove(result, v15, a5);
  }
  if (a7) {
    uint64_t result = memmove(&v22[a5], a8, a7);
  }
  size_t v23 = a4 - (a6 + a5);
  if (v23) {
    uint64_t result = memmove(&v22[a5 + a7], &v15[a5 + a6], v23);
  }
  if (a2 != 22)
  {
    uint64_t v24 = AdobeXMPCore_Int::IMemoryAllocator_I::GetMemoryAllocator((AdobeXMPCore_Int::IMemoryAllocator_I *)result);
    uint64_t result = (unsigned char *)(*(uint64_t (**)(uint64_t, char *))(*(void *)v24 + 8))(v24, v15);
  }
  size_t v25 = a7 + a5 + v23;
  *(void *)a1 = v22;
  *((void *)a1 + 1) = v25;
  *((void *)a1 + 2) = v19 | 0x8000000000000000;
  v22[v25] = 0;
  return result;
}

std::string *std::pair<std::string,std::string>::pair[abi:ne180100]<std::string&,std::string&,0>(std::string *this, long long *a2, long long *a3)
{
  if (*((char *)a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(this, *(const std::string::value_type **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v5 = *a2;
    this->__r_.__value_.__r.__words[2] = *((void *)a2 + 2);
    *(_OWORD *)&this->__r_.__value_.__l.__data_ = v5;
  }
  std::string::size_type v6 = this + 1;
  if (*((char *)a3 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v6, *(const std::string::value_type **)a3, *((void *)a3 + 1));
  }
  else
  {
    long long v7 = *a3;
    this[1].__r_.__value_.__r.__words[2] = *((void *)a3 + 2);
    *(_OWORD *)&v6->__r_.__value_.__l.__data_ = v7;
  }
  return this;
}

void sub_18858E8C8(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::__shared_ptr_pointer<AdobeXMPCore_Int::NameSpacePrefixMapImpl *,std::__mem_fn<void (AdobeXMPCore_Int::SharedObjectImpl::*)(void)const>,std::allocator<AdobeXMPCore_Int::NameSpacePrefixMapImpl>>::__on_zero_shared(uint64_t a1)
{
  return std::__mem_fn<void (AdobeXMPCore_Int::SharedObjectImpl::*)(void)const>::operator()[abi:ne180100]<AdobeXMPCore_Int::NameSpacePrefixMapImpl *&>(a1 + 32, (void *)(a1 + 24));
}

void virtual thunk to'AdobeXMPCore_Int::NameSpacePrefixMapImpl::~NameSpacePrefixMapImpl(AdobeXMPCore_Int::NameSpacePrefixMapImpl *this)
{
  AdobeXMPCore_Int::NameSpacePrefixMapImpl::~NameSpacePrefixMapImpl((AdobeXMPCore_Int::NameSpacePrefixMapImpl *)((char *)this + *(void *)(*(void *)this - 48)));

  AdobeXMPCore_Int::MemoryManagedObject::operator delete(v1);
}

{
  AdobeXMPCore_Int::NameSpacePrefixMapImpl::~NameSpacePrefixMapImpl((AdobeXMPCore_Int::NameSpacePrefixMapImpl *)((char *)this + *(void *)(*(void *)this - 48)));
}

{
  AdobeXMPCore_Int::NameSpacePrefixMapImpl::~NameSpacePrefixMapImpl((AdobeXMPCore_Int::NameSpacePrefixMapImpl *)((char *)this + *(void *)(*(void *)this - 56)));
}

{
  AdobeXMPCore_Int::IMemoryAllocator_I *v1;
  uint64_t vars8;

  AdobeXMPCore_Int::NameSpacePrefixMapImpl::~NameSpacePrefixMapImpl((AdobeXMPCore_Int::NameSpacePrefixMapImpl *)((char *)this + *(void *)(*(void *)this - 56)));

  AdobeXMPCore_Int::MemoryManagedObject::operator delete(v1);
}

uint64_t std::__shared_ptr_pointer<AdobeXMPCore_Int::SharedMutexImpl *,std::__mem_fn<void (AdobeXMPCore_Int::SharedObjectImpl::*)(void)const>,std::allocator<AdobeXMPCore_Int::SharedMutexImpl>>::__on_zero_shared(uint64_t a1)
{
  return std::__mem_fn<void (AdobeXMPCore_Int::SharedObjectImpl::*)(void)const>::operator()[abi:ne180100]<AdobeXMPCore_Int::SharedMutexImpl *&>(a1 + 32, (void *)(a1 + 24));
}

void virtual thunk to'AdobeXMPCore_Int::SharedMutexImpl::~SharedMutexImpl(AdobeXMPCore_Int::SharedMutexImpl *this)
{
  uint64_t v1 = (char *)this + *(void *)(*(void *)this - 48);
  AdobeXMPCore_Int::SharedObjectImpl::~SharedObjectImpl((AdobeXMPCore_Int::SharedObjectImpl *)(v1 + 8), (uint64_t *)&off_1ED4DD568);

  AdobeXMPCore_Int::MemoryManagedObject::operator delete((AdobeXMPCore_Int::IMemoryAllocator_I *)v1);
}

{
  AdobeXMPCore_Int::SharedObjectImpl::~SharedObjectImpl((AdobeXMPCore_Int::SharedMutexImpl *)((char *)this + *(void *)(*(void *)this - 48) + 8), (uint64_t *)&off_1ED4DD568);
}

uint64_t std::__mem_fn<void (AdobeXMPCore_Int::SharedObjectImpl::*)(void)const>::operator()[abi:ne180100]<AdobeXMPCore_Int::NameSpacePrefixMapImpl *&>(uint64_t a1, void *a2)
{
  uint64_t v2 = *a2 + *(void *)(*(void *)*a2 - 184);
  int v3 = *(uint64_t (**)(void *))a1;
  uint64_t v4 = *(void *)(a1 + 8);
  long long v5 = (void *)(v2 + (v4 >> 1));
  if (v4) {
    return (*(uint64_t (**)(void))(*v5 + v3))();
  }
  else {
    return v3(v5);
  }
}

uint64_t std::__mem_fn<void (AdobeXMPCore_Int::SharedObjectImpl::*)(void)const>::operator()[abi:ne180100]<AdobeXMPCore_Int::SharedMutexImpl *&>(uint64_t a1, void *a2)
{
  uint64_t v2 = *a2 + *(void *)(*(void *)*a2 - 120);
  int v3 = *(uint64_t (**)(void *))a1;
  uint64_t v4 = *(void *)(a1 + 8);
  long long v5 = (void *)(v2 + (v4 >> 1));
  if (v4) {
    return (*(uint64_t (**)(void))(*v5 + v3))();
  }
  else {
    return v3(v5);
  }
}

void AdobeXMPCore_Int::NameSpacePrefixMapImpl::~NameSpacePrefixMapImpl(AdobeXMPCore_Int::NameSpacePrefixMapImpl *this)
{
  AdobeXMPCore_Int::ThreadSafeImpl::~ThreadSafeImpl((AdobeXMPCore_Int::ThreadSafeImpl *)(v2 + 96), (uint64_t *)&off_1ED4DDD50);
  AdobeXMPCore_Int::SharedObjectImpl::~SharedObjectImpl((AdobeXMPCore_Int::NameSpacePrefixMapImpl *)((char *)this + 72), (uint64_t *)&off_1ED4DDD38);
}

{
  AdobeXMPCore_Int::IMemoryAllocator_I *v1;
  uint64_t vars8;

  AdobeXMPCore_Int::NameSpacePrefixMapImpl::~NameSpacePrefixMapImpl(this);

  AdobeXMPCore_Int::MemoryManagedObject::operator delete(v1);
}

void AdobeXMPCore_Int::ThreadSafeImpl::~ThreadSafeImpl(AdobeXMPCore_Int::ThreadSafeImpl *this, uint64_t *a2)
{
  uint64_t v2 = *a2;
  *(void *)this = *a2;
  *(void *)((char *)this + *(void *)(v2 - 96)) = a2[1];
  *(void *)((char *)this + *(void *)(*(void *)this - 72)) = a2[2];
  int v3 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v3) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v3);
  }
}

void std::string::__throw_length_error[abi:ne180100]()
{
}

void ASTCTextureImp::~ASTCTextureImp(ASTCTextureImp *this)
{
  *(void *)this = &unk_1ED4E0FD8;
  uint64_t v2 = (void *)*((void *)this + 7);
  if (v2 && !*((unsigned char *)this + 43)) {
    free(v2);
  }
  *((void *)this + 7) = 0;
  int v3 = (void *)*((void *)this + 9);
  if (v3) {
    free(v3);
  }
  *((void *)this + 9) = 0;
  if (*((void *)this + 16))
  {
    uint64_t v4 = *((void *)this + 17);
    if (v4)
    {
      Source = (IIOImageRead **)CGImageSourceGetSource(v4);
      if (Source) {
        IIOImageReadSession::releaseBytePointer(Source, *((void **)this + 16));
      }
    }
    *((void *)this + 16) = 0;
  }
  uint64_t v6 = *((void *)this + 30);
  if (v6) {
    (*(void (**)(uint64_t))(*(void *)v6 + 8))(v6);
  }
  *((void *)this + 30) = 0;
  long long v7 = (const void *)*((void *)this + 17);
  if (v7) {
    CFRelease(v7);
  }
  *((void *)this + 17) = 0;
  pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 168));

  _cg_jpeg_mem_term(this, v8, v9);
}

{
  uint64_t vars8;

  ASTCTextureImp::~ASTCTextureImp(this);

  JUMPOUT(0x18C11C0E0);
}

uint64_t std::__shared_ptr_emplace<ASTCTextureImp>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void XMP_ReadWriteLock::Acquire()
{
}

{
  __assert_rtn("Acquire", "XMP_LibUtils.cpp", 88, "this->lockCount == 0");
}

void CGImageMetadataTagKeyReleaseCallback(int a1, void *a2)
{
}

uint64_t CGImageMetadataTagKeyRetainCallback(uint64_t a1, uint64_t a2)
{
  uint64_t result = a2;
  atomic_fetch_add((atomic_uint *volatile)(a2 + 16), 1u);
  return result;
}

uint64_t imageio_key_hash(void *a1, void *a2)
{
  return os_simple_hash();
}

void *png_zalloc(void *result, unsigned int a2, unsigned int a3)
{
  if (result) {
    return png_malloc_warn(result, a3 * (unint64_t)a2);
  }
  return result;
}

const char *ASTCTwiddler::ASTCTwiddlerImpl::copyFromLinearDataImp(ASTCTwiddler::ASTCTwiddlerImpl *this, const void *a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6)
{
  if (*((void *)this + 1) >> a6 <= 1uLL) {
    uint64_t v11 = 1;
  }
  else {
    uint64_t v11 = *((void *)this + 1) >> a6;
  }
  if (*((void *)this + 2) >> a6 <= 1uLL) {
    uint64_t v12 = 1;
  }
  else {
    uint64_t v12 = *((void *)this + 2) >> a6;
  }
  *gCrashMessage = 0;
  snprintf(gCrashMessage, 0x200uLL, "ASTC-copyFromLinear: %p    offset: %ld    fileSize: %ld    levelRB: %d    dst: %p   (%dx%d)\n[", a2, a3, a4, a5, *((const void **)this + 5), v11, v12);
  qword_1EB2BF498 = gCrashMessage;
  [*((id *)this + 7) initializeTextureMemory:*((void *)this + 5)];
  uint64_t v13 = (void *)*((void *)this + 7);
  uint64_t v14 = *((void *)this + 5);
  memset(v16, 0, 24);
  v16[3] = v11;
  v16[4] = v12;
  v16[5] = 1;
  [v13 copyFromLinearBytes:a2 linearOffset:a3 linearBytesPerRow:a5 linearBytesPerImage:0 toTextureMemory:v14 textureSlice:0 textureLevel:a6 textureRegion:v16];
  qword_1EB2BF498 = 0;
  return ASTCTwiddler::ASTCTwiddlerImpl::finalizeTwiddlingImp((const char *)this);
}

void ASTCTwiddler::ASTCTwiddlerImpl::decodeAndCopyFromLinearDataImp(ASTCTwiddler::ASTCTwiddlerImpl *this, unsigned __int8 *a2, size_t a3, size_t size, int a5)
{
  if (*((void *)this + 1) >> a5 <= 1uLL) {
    uint64_t v6 = 1;
  }
  else {
    uint64_t v6 = *((void *)this + 1) >> a5;
  }
  if (size)
  {
    memset(&stream, 0, sizeof(stream));
    uint64_t v11 = (uint8_t *)malloc_type_malloc(size, 0x3323123uLL);
    *gCrashMessage = 0;
    snprintf(gCrashMessage, 0x200uLL, "LZFSE->TW_ASTC:  src: %p (%ld)   tmp: %p (%ld)   dst: %p (%ld)   (%ldx%ld)  rb: %ld\n", a2, a3, v11, size, *((const void **)this + 5), *((void *)this + 6), *((void *)this + 1), *((void *)this + 2), size);
    qword_1EB2BF498 = gCrashMessage;
    CHECK_FIRST_BYTE_OF_IMAGEBLOCK(a2);
    CHECK_LAST_BYTE_OF_IMAGEBLOCK(a2);
    if (compression_stream_init(&stream, COMPRESSION_STREAM_DECODE, COMPRESSION_LZFSE) == COMPRESSION_STATUS_OK)
    {
      stream.src_ptr = a2;
      stream.src_std::string::size_type size = a3;
      [*((id *)this + 7) initializeTextureMemory:*((void *)this + 5)];
      uint64_t v12 = 0;
      uint64_t v13 = a5;
      do
      {
        stream.dst_ptr = v11;
        stream.dst_std::string::size_type size = size;
        compression_status v14 = compression_stream_process(&stream, 0);
        if (v14 == COMPRESSION_STATUS_ERROR) {
          break;
        }
        compression_status v15 = v14;
        unint64_t v16 = (void *)*((void *)this + 7);
        uint64_t v17 = *((void *)this + 5);
        uint64_t v18 = *((void *)this + 3);
        v19[0] = 0;
        v19[1] = v12;
        v19[2] = 0;
        v19[3] = v6;
        v19[4] = v18;
        v19[5] = 1;
        [v16 copyFromLinearBytes:v11 linearOffset:0 linearBytesPerRow:size linearBytesPerImage:0 toTextureMemory:v17 textureSlice:0 textureLevel:v13 textureRegion:v19];
        v12 += *((void *)this + 3);
      }
      while (v15 != COMPRESSION_STATUS_END);
      compression_stream_destroy(&stream);
    }
    qword_1EB2BF498 = 0;
    free(v11);
  }
}

void *iio_jpeg_Malloc(size_t a1, void *a2)
{
  return malloc_type_malloc(a1, 0xD7A2A118uLL);
}

void iio_jpeg_Free(void *a1, void *a2)
{
  if (a1) {
    free(a1);
  }
}

uint64_t IIOImagePlus::setISR(uint64_t this, unint64_t a2)
{
  *(void *)(this + 16) = ~a2;
  return this;
}

uint64_t PNGReadPlugin::Read_user_chunk_callback2(void (**a1)(void), _DWORD *a2)
{
  uint64_t user_chunk_ptr = _cg_png_get_user_chunk_ptr((uint64_t)a1);
  if (*a2 != 1229088579) {
    return 0;
  }

  return PNGReadPlugin::Read_user_chunkCgBI(user_chunk_ptr, a1, (uint64_t)a2);
}

uint64_t iioReadCallback(unsigned char *a1, int a2, IIOImageReadSession **a3)
{
  if (!a2) {
    return 0;
  }
  LODWORD(result) = IIOImageReadSession::getBytes(*a3, a1, a2);
  if (result) {
    return result;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

_DWORD *AppleJPEGReadPlugin::readICCData(IIOImageReadSession **this, unint64_t a2, uint64_t a3, unint64_t *a4, unsigned int *a5)
{
  unint64_t v8 = a3 + 2;
  *a4 = 0;
  if (a2)
  {
    size_t v9 = 0;
    if (v8 > a2) {
      return v9;
    }
  }
  unint64_t v10 = 0;
  size_t v9 = 0;
  int v25 = 0;
  while (IIOImageReadSession::getBytesAtOffset(this[3], &v25, v8, 4uLL) == 4)
  {
    unsigned int v11 = bswap32((unsigned __int16)v25) >> 16;
    size_t v12 = bswap32(HIWORD(v25)) >> 16;
    if ((unsigned __int16)(v11 + 64) > 2u)
    {
      if (v11 != 65506)
      {
        if (v11 == 65498) {
          break;
        }
        goto LABEL_31;
      }
      if (v12 < 0x10) {
        break;
      }
      compression_status v14 = malloc_type_malloc(v12, 0xDAFC35B8uLL);
      if (IIOImageReadSession::getBytesAtOffset(this[3], v14, v8 + 4, v12) != v12)
      {
        if (!v14) {
          break;
        }
LABEL_35:
        free(v14);
        break;
      }
      if (*v14 == 0x464F52505F434349 && *(void *)((char *)v14 + 3) == 0x454C49464F52505FLL)
      {
        uint64_t v18 = a5;
        size_t v19 = v12 - 16;
        if (v9)
        {
          unint64_t v20 = v19 + v10;
          size_t v9 = reallocf(v9, v19 + v10);
        }
        else
        {
          size_t v9 = malloc_type_malloc(v12 - 16, 0xD9E69E15uLL);
          unint64_t v20 = v19 + v10;
        }
        memcpy((char *)v9 + v10, (char *)v14 + 14, v12 - 16);
        unint64_t v10 = v20;
        a5 = v18;
      }
      goto LABEL_30;
    }
    if (v12 < 6) {
      goto LABEL_31;
    }
    uint64_t v13 = malloc_type_malloc(v12, 0x735B48ADuLL);
    if (!v13) {
      break;
    }
    compression_status v14 = v13;
    if (IIOImageReadSession::getBytesAtOffset(this[3], v13, v8 + 4, v12) != v12) {
      goto LABEL_35;
    }
    int v15 = *((unsigned __int8 *)v14 + 5);
    switch(v15)
    {
      case 1:
        unsigned int v16 = 1196573017;
        goto LABEL_27;
      case 4:
        unsigned int v16 = 1129142603;
        goto LABEL_27;
      case 3:
        unsigned int v16 = 1380401696;
LABEL_27:
        *a5 = v16;
        break;
    }
LABEL_30:
    free(v14);
LABEL_31:
    v8 += v12 + 2;
    if (a2 && v8 > a2) {
      break;
    }
  }
  if (v9)
  {
    *a4 = v10;
    if (v10 >= 0x80)
    {
      int v21 = v9[9];
      unint64_t v22 = bswap32(*v9);
      if (v10 < v22) {
        LogError("readICCData", 1270, "Embedded profile header length is greater than data length.\n");
      }
      if (v21 == 1886610273)
      {
        if (*a4 >= v22) {
          return v9;
        }
      }
      else
      {
        LogError("readICCData", 1272, "Embedded profile signature is not valid.\n");
      }
    }
    free(v9);
    size_t v9 = 0;
    *a4 = 0;
  }
  return v9;
}

void png_handle_eXIf(uint64_t a1, uint64_t a2, size_t size)
{
  if ((*(unsigned char *)(a1 + 76) & 1) == 0) {
    png_chunk_error((void (**)(void))a1, "missing IHDR");
  }
  if (size <= 1)
  {
    png_crc_finish(a1, size);
    long long v5 = "too short";
LABEL_15:
    png_chunk_benign_error(a1, v5);
    return;
  }
  if (!a2 || (*(unsigned char *)(a2 + 10) & 1) != 0)
  {
    png_crc_finish(a1, size);
    long long v5 = "duplicate";
    goto LABEL_15;
  }
  *(_DWORD *)(a2 + 300) |= 0x8000u;
  long long v7 = png_malloc_warn((void *)a1, size);
  *(void *)(a2 + 248) = v7;
  if (!v7)
  {
    png_crc_finish(a1, size);
    long long v5 = "out of memory";
    goto LABEL_15;
  }
  uint64_t v8 = 0;
  do
  {
    Bytef v9 = 0;
    png_crc_read(a1, &v9, 1u);
    *(unsigned char *)(*(void *)(a2 + 248) + v8) = v9;
    if (v8 == 1 && ((v9 & 0xFB) != 0x49 || **(unsigned __int8 **)(a2 + 248) != v9))
    {
      png_crc_finish(a1, (size - 2));
      png_chunk_benign_error(a1, "incorrect byte-order specifier");
      goto LABEL_20;
    }
    ++v8;
  }
  while (size != v8);
  if (!png_crc_finish(a1, 0)) {
    _cg_png_set_eXIf_1(a1, a2, size, *(const void **)(a2 + 248));
  }
LABEL_20:
  png_free(a1, *(void **)(a2 + 248));
  *(void *)(a2 + 248) = 0;
}

uint64_t png_calculate_crc(uint64_t result, Bytef *buf, uint64_t a3)
{
  if ((*(unsigned char *)(result + 315) & 0x20) != 0) {
    BOOL v3 = (~*(_DWORD *)(result + 80) & 0x300) != 0;
  }
  else {
    BOOL v3 = (*(_DWORD *)(result + 80) & 0x800) == 0;
  }
  if (a3 && v3)
  {
    uint64_t v4 = a3;
    uint64_t v6 = result;
    uint64_t result = *(unsigned int *)(result + 364);
    do
    {
      if (v4) {
        uint64_t v7 = v4;
      }
      else {
        uint64_t v7 = 0xFFFFFFFFLL;
      }
      uint64_t result = crc32(result, buf, v7);
      buf += v7;
      v4 -= v7;
    }
    while (v4);
    *(_DWORD *)(v6 + 364) = result;
  }
  return result;
}

uint64_t png_crc_read(uint64_t result, Bytef *a2, unsigned int a3)
{
  if (result && a3)
  {
    uint64_t v4 = result;
    uint64_t v5 = a3;
    png_read_data(result);
    return png_calculate_crc(v4, a2, v5);
  }
  return result;
}

uint64_t png_read_data(uint64_t a1)
{
  uint64_t v1 = *(uint64_t (**)(void))(a1 + 32);
  if (!v1) {
    _cg_png_error((void (**)(void))a1, "Call to NULL read function");
  }

  return v1();
}

unint64_t read_fn2(uint64_t a1, unsigned char *a2, unint64_t a3)
{
  uint64_t io_ptr = _cg_png_get_io_ptr(a1);
  uint64_t v6 = io_ptr;
  uint64_t v8 = *(IIOImageRead ***)io_ptr;
  int64_t v7 = *(void *)(io_ptr + 8);
  uint64_t v9 = *(void *)(io_ptr + 16);
  if (v7 > v9 - 0x8000)
  {
    if (v9) {
      size_t v10 = 0x20000;
    }
    else {
      size_t v10 = 0x10000;
    }
    IIOImageReadSession::willNeed(*(IIOImageRead ***)io_ptr, v9, v10);
    *(void *)(v6 + 16) = v10 + v9;
    int64_t v7 = *(void *)(v6 + 8);
  }
  unint64_t result = IIOImageReadSession::getBytesAtOffset((IIOImageReadSession *)v8, a2, v7, a3);
  *(void *)(v6 + 8) += result;
  return result;
}

unint64_t IIOImageReadSession::getBytesAtOffset(IIOImageReadSession *this, unsigned char *a2, unint64_t a3, unint64_t a4)
{
  uint64_t v4 = (IIOImageRead *)*((void *)this + 4);
  if (v4)
  {
    return IIOImageRead::getBytesAtOffset(v4, a2, a3, a4);
  }
  else
  {
    LogError("getBytesAtOffset", 261, "*** ERROR: IIOImageReadSession::getBytesAtOffset: _iRead is NULL\n");
    return 0;
  }
}

unint64_t pngReadCallback(void (**a1)(void), unsigned char *a2, unint64_t a3)
{
  uint64_t io_ptr = (IIOImageReadSession *)_cg_png_get_io_ptr((uint64_t)a1);
  unint64_t result = IIOImageReadSession::getBytes(io_ptr, a2, a3);
  if (result != a3) {
    _cg_png_error(a1, "PNG read error");
  }
  return result;
}

uint64_t _cg_png_get_io_ptr(uint64_t result)
{
  if (result) {
    return *(void *)(result + 40);
  }
  return result;
}

unint64_t IIOImageReadSession::getBytes(IIOImageReadSession *this, unsigned char *a2, unint64_t a3)
{
  uint64_t v4 = (IIOImageRead *)*((void *)this + 4);
  if (v4)
  {
    unint64_t result = IIOImageRead::getBytesAtOffset(v4, a2, *((void *)this + 5), a3);
  }
  else
  {
    LogError("getBytes", 244, "*** ERROR: IIOImageReadSession::getBytes: _iRead is NULL\n");
    unint64_t result = 0;
  }
  *((void *)this + 5) += result;
  return result;
}

unint64_t IIOImageRead::getBytesAtOffset(IIOImageRead *this, unsigned char *a2, unint64_t a3, unint64_t a4)
{
  unint64_t v4 = 0;
  if (a2)
  {
    unint64_t v5 = a4;
    if (a4)
    {
      uint64_t v9 = (pthread_mutex_t *)((char *)this + 376);
      pthread_mutex_lock((pthread_mutex_t *)((char *)this + 376));
      int v16 = 0;
      ERROR_ImageIO_DestinationBufferIsNotWritable(a2);
      ERROR_ImageIO_DestinationBufferIsNotBigEnough((uint64_t)a2, v5 - 1);
      if ((*((_DWORD *)this + 6) & 0x80000000) != 0
        && !*((void *)this + 4)
        && !*((void *)this + 5)
        && *((unsigned char *)this + 67))
      {
        if ((gIIODebugFlags & 0x100000000000) == 0
          || (ImageIOLog("    %s:   <IIOImageRead: %p> mmapping data   count: %d\n", "getBytesAtOffset", this, *((_DWORD *)this + 110) + 1), !*((void *)this + 4)))
        {
          BOOL v15 = 0;
          CFDataRef v10 = IIOImageRead::createDataWithMappedFile(this, &v15, &v16);
          *((void *)this + 4) = v10;
          if ((gIIODebugFlags & 0x80000000000) != 0) {
            ImageIOLog("D   %s:%d createDataWithMappedFile %p\n", "getBytesAtOffset", 1514, v10);
          }
        }
        ++*((_DWORD *)this + 110);
      }
      unint64_t v11 = *((void *)this + 10);
      if (v11 != -1)
      {
        if (v11 < a3)
        {
          _cg_jpeg_mem_term("getBytesAtOffset", 1524, "*** ERROR: offset > _length (%ld > %ld)\n", a3, v11);
          unint64_t v11 = *((void *)this + 10);
        }
        uint64_t v12 = v11 - a3;
        if (v11 <= a3) {
          goto LABEL_25;
        }
        if (v12 >= v5) {
          uint64_t v12 = v5;
        }
        if (v12 <= 0)
        {
          _cg_jpeg_mem_term("getBytesAtOffset", 1536, " inCount = %ld   count = %ld   _length = %ld   offset = %ld \n", v5, v12, v11, a3);
          goto LABEL_25;
        }
        unint64_t v5 = v12;
      }
      if (*((void *)this + 5))
      {
        unint64_t CGDataProviderBytesAtOffset = IIOImageRead::getCGDataProviderBytesAtOffset(this, a2);
LABEL_28:
        unint64_t v4 = CGDataProviderBytesAtOffset;
        goto LABEL_29;
      }
      if (*((void *)this + 4))
      {
        unint64_t CGDataProviderBytesAtOffset = IIOImageRead::getCFDataBytesAtOffset(this, a2, a3, v5);
        goto LABEL_28;
      }
      if ((*((_DWORD *)this + 6) & 0x80000000) == 0)
      {
        unint64_t CGDataProviderBytesAtOffset = IIOImageRead::getFileBytesAtOffset(this, a2, a3, v5);
        goto LABEL_28;
      }
LABEL_25:
      unint64_t v4 = 0;
LABEL_29:
      pthread_mutex_unlock(v9);
    }
  }
  return v4;
}

uint64_t ERROR_ImageIO_DestinationBufferIsNotBigEnough(uint64_t result, uint64_t a2)
{
  *(unsigned char *)(result + a2) = 0;
  return result;
}

unsigned char *ERROR_ImageIO_DestinationBufferIsNotWritable(unsigned char *result)
{
  unsigned char *result = 0;
  return result;
}

unint64_t IIOImageRead::getCFDataBytesAtOffset(IIOImageRead *this, UInt8 *a2, CFIndex a3, unint64_t a4)
{
  if ((gIIODebugFlags & 0x800000) != 0)
  {
    CFDataRef v8 = (const __CFData *)*((void *)this + 4);
    CFIndex Length = CFDataGetLength(v8);
    ImageIOLog("    %s:%d:  data: %p  [%8ld]  offset: 0x%08lX   size: %8ld\n", "getCFDataBytesAtOffset", 1347, v8, Length, a3, a4);
  }
  CFDataRef v10 = (const void *)*((void *)this + 4);
  if (!v10) {
    return 0;
  }
  CFTypeID v11 = CFGetTypeID(v10);
  if (v11 != CFDataGetTypeID()) {
    return 0;
  }
  unint64_t v12 = CFDataGetLength(*((CFDataRef *)this + 4));
  if (v12 < *((void *)this + 10) && !*((unsigned char *)this + 69))
  {
    LogFault("getCFDataBytesAtOffset", 1357, ": *** ERROR *** CGImageSource was created with data size: %ld - current size is only: %ld\n", *((void *)this + 10), v12);
    *((unsigned char *)this + 69) = 1;
  }
  if (a4 + a3 > v12)
  {
    LogError("getCFDataBytesAtOffset", 1365, ": *** ERROR *** requested range: %ld-%lld - is outside input CFData range (0-%ld)\n", a3, a4 + a3, v12);
    return 0;
  }
  if (v12 - a3 < a4) {
    a4 = v12 - a3;
  }
  if (a4)
  {
    BytePtr = CFDataGetBytePtr(*((CFDataRef *)this + 4));
    BOOL v15 = BytePtr;
    if (a3) {
      CHECK_FIRST_BYTE_OF_IMAGEBLOCK((unsigned __int8 *)&BytePtr[a3 - 1]);
    }
    CHECK_LAST_BYTE_OF_IMAGEBLOCK((unsigned __int8 *)&v15[a3]);
    v16.location = a3;
    v16.length = a4;
    CFDataGetBytes(*((CFDataRef *)this + 4), v16, a2);
  }
  return a4;
}

unint64_t read_fn(void (**a1)(void), unsigned char *a2, unint64_t a3)
{
  uint64_t io_ptr = (IIOImageReadSession *)_cg_png_get_io_ptr((uint64_t)a1);
  unint64_t result = IIOImageReadSession::getBytes(io_ptr, a2, a3);
  if (result != a3) {
    _cg_png_error(a1, "");
  }
  return result;
}

uint64_t png_cache_unknown_chunk(uint64_t a1, uint64_t size)
{
  unint64_t v4 = (void *)(a1 + 904);
  unint64_t v5 = *(void **)(a1 + 904);
  if (v5)
  {
    png_free(a1, v5);
    void *v4 = 0;
    v4[1] = 0;
  }
  unint64_t v6 = *(void *)(a1 + 888);
  if (v6 + 1 > 1 && v6 < size)
  {
    int64_t v7 = 0;
    if (!size)
    {
LABEL_11:
      if (size) {
        png_crc_read(a1, v7, size);
      }
      goto LABEL_14;
    }
LABEL_9:
    if (!v7)
    {
      png_crc_finish(a1, size);
      png_chunk_benign_error(a1, "unknown chunk exceeds memory limits");
      return 0;
    }
    goto LABEL_11;
  }
  int v8 = *(_DWORD *)(a1 + 312);
  *(unsigned char *)(a1 + 896) = HIBYTE(v8);
  *(unsigned char *)(a1 + 897) = BYTE2(v8);
  *(unsigned char *)(a1 + 898) = BYTE1(v8);
  *(unsigned char *)(a1 + 899) = v8;
  *(unsigned char *)(a1 + 900) = 0;
  *(unsigned char *)(a1 + 920) = *(_DWORD *)(a1 + 76);
  if (size)
  {
    int64_t v7 = (Bytef *)png_malloc_warn((void *)a1, size);
    *(void *)(a1 + 904) = v7;
    *(void *)(a1 + 912) = size;
    goto LABEL_9;
  }
  void *v4 = 0;
  v4[1] = 0;
LABEL_14:
  png_crc_finish(a1, 0);
  return 1;
}

void _cg_png_read_info(uLong a1, _DWORD *a2)
{
  if (!a1 || !a2) {
    return;
  }
  png_read_sig(a1, (uint64_t)a2);
  uint64_t chunk_header = _cg_png_read_chunk_header(a1);
  for (int i = *(_DWORD *)(a1 + 312); i != 1229209940; int i = *(_DWORD *)(a1 + 312))
  {
    int v8 = *(_DWORD *)(a1 + 76);
    if ((v8 & 4) != 0) {
      *(_DWORD *)(a1 + 76) = v8 | 0x2008;
    }
    if (i == 1229278788)
    {
      png_handle_IEND(a1, (uint64_t)a2, chunk_header);
    }
    else if (i == 1229472850)
    {
      png_handle_IHDR(a1, (uint64_t)a2, chunk_header);
    }
    else
    {
      int v9 = png_chunk_unknown_handling(a1, i);
      if (v9)
      {
        png_handle_unknown(a1, (uint64_t)a2, chunk_header, v9);
        if (i == 1347179589) {
          *(_DWORD *)(a1 + 76) |= 2u;
        }
        goto LABEL_20;
      }
      if (i > 1866876530)
      {
        if (i <= 1934642259)
        {
          if (i <= 1883789682)
          {
            if (i == 1866876531)
            {
              png_handle_oFFs(a1, (uint64_t)a2, chunk_header);
            }
            else
            {
              if (i != 1883455820) {
                goto LABEL_74;
              }
              png_handle_pCAL(a1, (uint64_t)a2, chunk_header);
            }
          }
          else
          {
            switch(i)
            {
              case 1883789683:
                png_handle_pHYs(a1, (uint64_t)a2, chunk_header);
                break;
              case 1933723988:
                png_handle_sBIT(a1, (uint64_t)a2, chunk_header);
                break;
              case 1933787468:
                png_handle_sCAL(a1, (uint64_t)a2, chunk_header);
                break;
              default:
                goto LABEL_74;
            }
          }
        }
        else if (i > 1950960964)
        {
          switch(i)
          {
            case 1950960965:
              png_handle_tIME(a1, (uint64_t)a2, chunk_header);
              break;
            case 1951551059:
              png_handle_tRNS(a1, (uint64_t)a2, chunk_header);
              break;
            case 2052348020:
              png_handle_zTXt(a1, (uint64_t)a2, chunk_header);
              break;
            default:
              goto LABEL_74;
          }
        }
        else
        {
          switch(i)
          {
            case 1934642260:
              png_handle_sPLT(a1, (uint64_t)a2, chunk_header);
              break;
            case 1934772034:
              png_handle_sRGB(a1, (uint64_t)a2, chunk_header);
              break;
            case 1950701684:
              png_handle_tEXt(a1, (uint64_t)a2, chunk_header);
              break;
            default:
              goto LABEL_74;
          }
        }
      }
      else if (i <= 1717785675)
      {
        if (i <= 1649100611)
        {
          if (i == 1347179589)
          {
            png_handle_PLTE(a1, (uint64_t)a2, chunk_header);
          }
          else
          {
            if (i != 1633899596) {
              goto LABEL_74;
            }
            png_handle_acTL(a1, a2, chunk_header);
          }
        }
        else
        {
          switch(i)
          {
            case 1649100612:
              png_handle_bKGD(a1, (uint64_t)a2, chunk_header);
              break;
            case 1665684045:
              png_handle_cHRM(a1, (uint64_t)a2, chunk_header);
              break;
            case 1700284774:
              png_handle_eXIf(a1, (uint64_t)a2, chunk_header);
              break;
            default:
              goto LABEL_74;
          }
        }
      }
      else if (i > 1749635923)
      {
        switch(i)
        {
          case 1749635924:
            png_handle_hIST(a1, (uint64_t)a2, chunk_header);
            break;
          case 1766015824:
            if ((*(unsigned char *)(a1 + 84) & 4) != 0) {
              png_crc_finish(a1, chunk_header);
            }
            else {
              png_handle_iCCP(a1, (uint64_t)a2);
            }
            break;
          case 1767135348:
            png_handle_iTXt(a1, (uint64_t)a2, chunk_header);
            break;
          default:
LABEL_74:
            png_handle_unknown(a1, (uint64_t)a2, chunk_header, 0);
            break;
        }
      }
      else
      {
        switch(i)
        {
          case 1717785676:
            png_handle_fcTL(a1, a2, chunk_header);
            break;
          case 1717846356:
            png_handle_fdAT(a1, (uint64_t)a2, chunk_header);
            break;
          case 1732332865:
            png_handle_gAMA(a1, (uint64_t)a2, chunk_header);
            break;
          default:
            goto LABEL_74;
        }
      }
    }
LABEL_20:
    uint64_t chunk_header = _cg_png_read_chunk_header(a1);
  }
  int v6 = *(_DWORD *)(a1 + 76);
  if ((v6 & 1) == 0)
  {
    CFDataRef v10 = "Missing IHDR before IDAT";
    goto LABEL_81;
  }
  if ((v6 & 2) == 0 && *(unsigned char *)(a1 + 391) == 3)
  {
    CFDataRef v10 = "Missing PLTE before IDAT";
LABEL_81:
    png_chunk_error((void (**)(void))a1, v10);
  }
  if ((v6 & 8) != 0)
  {
    png_chunk_benign_error(a1, "Too many IDATs found");
    int v6 = *(_DWORD *)(a1 + 76);
  }
  *(_DWORD *)(a1 + 76) = v6 | 4;
  int v7 = png_chunk_unknown_handling(a1, 1229209940);
  if (v7)
  {
    png_handle_unknown(a1, (uint64_t)a2, chunk_header, v7);
    LODWORD(chunk_header) = 0;
  }
  else
  {
    png_have_info(a1, (uint64_t)a2);
  }
  *(_DWORD *)(a1 + 360) = chunk_header;
}

uint64_t _cg_png_read_chunk_header(uLong a1)
{
  v4[1] = *MEMORY[0x1E4F143B8];
  v4[0] = 0;
  *(_DWORD *)(a1 + 956) = 33;
  png_read_data(a1);
  uint64_t v2 = bswap32(LOBYTE(v4[0]));
  if ((v2 & 0x80000000) != 0) {
    _cg_png_error((void (**)(void))a1, "PNG unsigned integer out of range");
  }
  *(_DWORD *)(a1 + 312) = bswap32(HIDWORD(v4[0]));
  png_reset_crc(a1);
  png_calculate_crc(a1, (Bytef *)v4 + 4, 4);
  png_check_chunk_name((void (**)(void))a1, *(_DWORD *)(a1 + 312));
  png_check_chunk_length(a1, v2);
  *(_DWORD *)(a1 + 956) = 65;
  return v2;
}

uLong png_reset_crc(uLong result)
{
  if ((~*(_DWORD *)(result + 80) & 0x300) != 0 && (*(_DWORD *)(result + 80) & 0x800) == 0)
  {
    uLong v2 = result;
    unint64_t result = crc32(0, 0, 0);
    *(_DWORD *)(v2 + 364) = result;
  }
  return result;
}

void (**png_check_chunk_name(void (**result)(void), unsigned int a2))(void)
{
  int v2 = 4;
  do
  {
    if (a2 - 123 < 0xFFFFFFC6 || a2 - 91 <= 5) {
      png_chunk_error(result, "invalid chunk type");
    }
    a2 >>= 8;
    --v2;
  }
  while (v2);
  return result;
}

uint64_t png_check_chunk_length(uint64_t result, unsigned int a2)
{
  unint64_t v2 = *(void *)(result + 888);
  if (v2 - 1 >= 0x7FFFFFFE) {
    unint64_t v2 = 0x7FFFFFFFLL;
  }
  if (*(_DWORD *)(result + 312) == 1229209940)
  {
    uint64_t v3 = 6;
    if (!*(unsigned char *)(result + 388)) {
      uint64_t v3 = 0;
    }
    unint64_t v4 = ((*(unsigned __int8 *)(result + 395) * (unint64_t)*(unsigned int *)(result + 280)) << (*(unsigned __int8 *)(result + 392) > 8u))
       + v3;
    unint64_t v5 = *(unsigned int *)(result + 284);
    if (0xFFFFFFFF / (v4 + 1) >= v5) {
      unint64_t v6 = (v4 + 1) * v5;
    }
    else {
      unint64_t v6 = 0x7FFFFFFFLL;
    }
    if (v4 + 1 < 0x7F36) {
      unint64_t v7 = v4 + 1;
    }
    else {
      unint64_t v7 = 32566;
    }
    unint64_t v8 = 5 * (v6 / v7) + v6 + 11;
    if (v8 >= 0x7FFFFFFF) {
      unint64_t v8 = 0x7FFFFFFFLL;
    }
    if (v2 <= v8) {
      unint64_t v2 = v8;
    }
  }
  if (v2 < a2) {
    return png_benign_error(result, "chunk data is too large");
  }
  return result;
}

uint64_t png_chunk_unknown_handling(uint64_t a1, int a2)
{
  LOBYTE(v3) = HIBYTE(a2);
  BYTE1(v3) = BYTE2(a2);
  BYTE2(v3) = BYTE1(a2);
  HIBYTE(v3) = a2;
  char v4 = 0;
  return png_handle_as_unknown(a1, &v3);
}

uint64_t png_handle_as_unknown(uint64_t a1, _DWORD *a2)
{
  uint64_t result = 0;
  if (a1 && a2)
  {
    int v4 = *(_DWORD *)(a1 + 740);
    if (v4)
    {
      unint64_t v5 = *(void *)(a1 + 744);
      unint64_t v6 = v5 + (5 * v4);
      unint64_t v7 = v6;
      while (1)
      {
        int v8 = *(_DWORD *)(v7 - 5);
        v7 -= 5;
        if (*a2 == v8) {
          break;
        }
        unint64_t v6 = v7;
        if (v7 <= v5) {
          return 0;
        }
      }
      return *(unsigned __int8 *)(v6 - 1);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t png_read_sig(uint64_t result, uint64_t a2)
{
  unint64_t v2 = *(unsigned __int8 *)(result + 397);
  if (v2 <= 7)
  {
    uint64_t v3 = result;
    *(_DWORD *)(result + 956) = 17;
    uint64_t v4 = a2 + 44;
    png_read_data(result);
    *(unsigned char *)(v3 + 397) = 8;
    uint64_t result = png_sig_cmp(v4, v2, 8 - v2);
    if (result)
    {
      if (v2 <= 3 && png_sig_cmp(v4, v2, 4 - v2)) {
        unint64_t v5 = "Not a PNG file";
      }
      else {
        unint64_t v5 = "PNG file corrupted by ASCII conversion";
      }
      _cg_png_error((void (**)(void))v3, v5);
    }
    if (v2 <= 2) {
      *(_DWORD *)(v3 + 76) |= 0x1000u;
    }
  }
  return result;
}

uint64_t png_sig_cmp(uint64_t a1, unint64_t a2, size_t a3)
{
  if (a3 <= 8)
  {
    if (!a3) {
      return 0xFFFFFFFFLL;
    }
  }
  else
  {
    a3 = 8;
  }
  if (a2 > 7) {
    return 0xFFFFFFFFLL;
  }
  if (a3 + a2 > 8) {
    a3 = 8 - a2;
  }
  return memcmp((const void *)(a1 + a2), (char *)&png_sig_cmp_png_signature + a2, a3);
}

uint64_t png_have_info(uint64_t result, uint64_t a2)
{
  if ((*(_DWORD *)(a2 + 8) & 0x60000) == 0x20000)
  {
    *(_DWORD *)(result + 768) |= 1u;
    ++*(_DWORD *)(a2 + 360);
  }
  return result;
}

uint64_t png_handle_IHDR(uint64_t a1, uint64_t a2, int a3)
{
  v20[2] = *MEMORY[0x1E4F143B8];
  int v4 = *(_DWORD *)(a1 + 76);
  if (v4)
  {
    size_t v19 = "out of place";
    goto LABEL_13;
  }
  if (a3 != 13)
  {
    size_t v19 = "invalid";
LABEL_13:
    png_chunk_error((void (**)(void))a1, v19);
  }
  *(void *)((char *)v20 + 5) = 0;
  v20[0] = 0;
  *(_DWORD *)(a1 + 76) = v4 | 1;
  png_crc_read(a1, (Bytef *)v20, 0xDu);
  png_crc_finish(a1, 0);
  unsigned int v6 = bswap32(v20[0]);
  if ((v6 & 0x80000000) != 0 || (unsigned int v7 = bswap32(HIDWORD(v20[0])), (v7 & 0x80000000) != 0)) {
    _cg_png_error((void (**)(void))a1, "PNG unsigned integer out of range");
  }
  unsigned __int8 v8 = v20[1];
  unint64_t v9 = BYTE1(v20[1]);
  unsigned __int8 v10 = BYTE2(v20[1]);
  unsigned __int8 v11 = BYTE3(v20[1]);
  unsigned __int8 v12 = BYTE4(v20[1]);
  *(_DWORD *)(a1 + 776) = v6;
  *(_DWORD *)(a1 + 780) = v7;
  *(_DWORD *)(a1 + 280) = v6;
  *(_DWORD *)(a1 + 284) = v7;
  *(unsigned char *)(a1 + 392) = v8;
  *(unsigned char *)(a1 + 388) = v12;
  *(unsigned char *)(a1 + 391) = v9;
  *(unsigned char *)(a1 + 764) = v11;
  *(unsigned char *)(a1 + 872) = v10;
  unint64_t v13 = 0x4010201030101uLL >> (8 * v9);
  if (v9 >= 7) {
    LOBYTE(v13) = 1;
  }
  *(unsigned char *)(a1 + 395) = v13;
  unsigned __int8 v14 = v13 * v8;
  *(unsigned char *)(a1 + 394) = v14;
  BOOL v15 = v14 >= 8u;
  unint64_t v16 = (v14 * (unint64_t)v6 + 7) >> 3;
  unint64_t v17 = v6 * (unint64_t)(v14 >> 3);
  if (!v15) {
    unint64_t v17 = v16;
  }
  *(void *)(a1 + 296) = v17;
  return _cg_png_set_IHDR(a1, a2, v6, v7, v8, v9, v12, v10, v11);
}

BOOL png_crc_finish(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = MEMORY[0x1F4188790](a1, a2);
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  if (v2)
  {
    unsigned int v4 = v2;
    do
    {
      bzero(v8, 0x1000uLL);
      if (v4 >= 0x1000) {
        unsigned int v5 = 4096;
      }
      else {
        unsigned int v5 = v4;
      }
      v4 -= v5;
      png_crc_read(v3, v8, v5);
    }
    while (v4);
  }
  BOOL result = png_crc_error((_DWORD *)v3);
  if (result)
  {
    int v7 = *(_DWORD *)(v3 + 80);
    if ((*(unsigned char *)(v3 + 315) & 0x20) != 0)
    {
      if ((v7 & 0x200) == 0) {
        goto LABEL_10;
      }
    }
    else if ((v7 & 0x400) != 0)
    {
LABEL_10:
      png_chunk_warning(v3, "CRC error");
      return 1;
    }
    png_chunk_error((void (**)(void))v3, "CRC error");
  }
  return result;
}

BOOL png_crc_error(_DWORD *a1)
{
  int v2 = a1[78];
  int v3 = a1[20];
  a1[239] = 129;
  png_read_data((uint64_t)a1);
  if ((v2 & 0x20000000) != 0)
  {
    if ((~v3 & 0x300) == 0) {
      return 0;
    }
  }
  else if ((v3 & 0x800) != 0)
  {
    return 0;
  }
  return bswap32(0) != a1[91];
}

uint64_t _cg_png_set_IHDR(uint64_t result, uint64_t a2, unsigned int a3, unsigned int a4, unsigned __int8 a5, unsigned __int8 a6, unsigned __int8 a7, unsigned __int8 a8, unsigned __int8 a9)
{
  if (!result || !a2) {
    return result;
  }
  *(_DWORD *)a2 = a3;
  *(_DWORD *)(a2 + 4) = a4;
  *(unsigned char *)(a2 + 36) = a5;
  *(unsigned char *)(a2 + 37) = a6;
  *(unsigned char *)(a2 + 38) = a8;
  *(unsigned char *)(a2 + 39) = a9;
  *(unsigned char *)(a2 + 40) = a7;
  BOOL result = png_check_IHDR(result, a3, a4, a5, a6, a7, a8, a9);
  int v11 = *(unsigned __int8 *)(a2 + 37);
  if (v11 == 3)
  {
    char v12 = 1;
LABEL_7:
    *(unsigned char *)(a2 + 41) = v12;
    goto LABEL_8;
  }
  char v12 = v11 & 2 | 1;
  *(unsigned char *)(a2 + 41) = v12;
  if ((v11 & 4) != 0)
  {
    char v12 = (v11 & 2) + 2;
    goto LABEL_7;
  }
LABEL_8:
  unsigned __int8 v13 = *(unsigned char *)(a2 + 36) * v12;
  *(unsigned char *)(a2 + 42) = v13;
  BOOL v14 = v13 >= 8u;
  unint64_t v15 = (v13 * (unint64_t)a3 + 7) >> 3;
  unint64_t v16 = a3 * (unint64_t)(v13 >> 3);
  if (!v14) {
    unint64_t v16 = v15;
  }
  *(void *)(a2 + 16) = v16;
  *(_DWORD *)(a2 + 360) = 1;
  return result;
}

uint64_t png_check_IHDR(uint64_t result, unsigned int a2, unsigned int a3, int a4, unsigned int a5, int a6, int a7, int a8)
{
  uint64_t v15 = result;
  if (a2)
  {
    if ((a2 & 0x80000000) == 0)
    {
      int v16 = 0;
      goto LABEL_7;
    }
    unint64_t v17 = "Invalid image width in IHDR";
  }
  else
  {
    unint64_t v17 = "Image width is zero in IHDR";
  }
  BOOL result = png_warning(result, v17);
  int v16 = 1;
LABEL_7:
  if (*(_DWORD *)(v15 + 876) < a2)
  {
    BOOL result = png_warning(v15, "Image width exceeds user limit in IHDR");
    int v16 = 1;
  }
  if (a3)
  {
    if ((a3 & 0x80000000) == 0) {
      goto LABEL_14;
    }
    uint64_t v18 = "Invalid image height in IHDR";
  }
  else
  {
    uint64_t v18 = "Image height is zero in IHDR";
  }
  BOOL result = png_warning(v15, v18);
  int v16 = 1;
LABEL_14:
  if (*(_DWORD *)(v15 + 880) < a3)
  {
    BOOL result = png_warning(v15, "Image height exceeds user limit in IHDR");
    int v16 = 1;
  }
  if (a4 > 0x10 || ((1 << a4) & 0x10116) == 0)
  {
    BOOL result = png_warning(v15, "Invalid bit depth in IHDR");
    int v16 = 1;
  }
  unsigned int v19 = a5 & 0xFFFFFFFB;
  if (a5 > 6 || v19 == 1)
  {
    BOOL result = png_warning(v15, "Invalid color type in IHDR");
    int v16 = 1;
  }
  if (a4 > 8 && a5 == 3 || (a5 != 4 ? (BOOL v20 = v19 == 2) : (BOOL v20 = 1), !v20 ? (v21 = 0) : (v21 = 1), a4 < 8 && v21))
  {
    BOOL result = png_warning(v15, "Invalid color type/bit depth combination in IHDR");
    int v16 = 1;
  }
  if (a6 >= 2)
  {
    BOOL result = png_warning(v15, "Unknown interlace method in IHDR");
    int v16 = 1;
  }
  if (a7)
  {
    BOOL result = png_warning(v15, "Unknown compression method in IHDR");
    int v16 = 1;
  }
  if ((*(unsigned char *)(v15 + 77) & 0x10) != 0 && *(_DWORD *)(v15 + 760)) {
    BOOL result = png_warning(v15, "MNG features are not allowed in a PNG datastream");
  }
  if (a8 && (a8 != 64 || (*(_DWORD *)(v15 + 760) & 4) == 0 || v19 != 2 || (*(_DWORD *)(v15 + 76) & 0x1000) != 0))
  {
    png_warning(v15, "Unknown filter method in IHDR");
    if ((*(unsigned char *)(v15 + 77) & 0x10) != 0) {
      png_warning(v15, "Invalid filter method in IHDR");
    }
LABEL_49:
    _cg_png_error((void (**)(void))v15, "Invalid IHDR data");
  }
  if (v16) {
    goto LABEL_49;
  }
  return result;
}

void png_handle_unknown(uint64_t a1, uint64_t a2, uint64_t size, int a4)
{
  int v4 = a4;
  if (*(void *)(a1 + 728))
  {
    if (!png_cache_unknown_chunk(a1, size)) {
      goto LABEL_22;
    }
    int v7 = (*(uint64_t (**)(uint64_t, uint64_t))(a1 + 728))(a1, a1 + 896);
    if (v7 < 0)
    {
      int v11 = "error in user chunk";
LABEL_33:
      png_chunk_error((void (**)(void))a1, v11);
    }
    if (v7) {
      goto LABEL_25;
    }
    if (v4 <= 1)
    {
      if (*(int *)(a1 + 736) <= 1)
      {
        png_chunk_warning(a1, "Saving unknown chunk:");
        png_app_warning(a1, "forcing save of an unhandled chunk; please call png_set_keep_unknown_chunks");
      }
      goto LABEL_17;
    }
  }
  else
  {
    if (!a4) {
      int v4 = *(_DWORD *)(a1 + 736);
    }
    if (v4 == 3 || v4 == 2 && (*(unsigned char *)(a1 + 315) & 0x20) != 0)
    {
      if (!png_cache_unknown_chunk(a1, size)) {
        goto LABEL_22;
      }
    }
    else
    {
      png_crc_finish(a1, size);
    }
  }
  if (v4 == 3) {
    goto LABEL_18;
  }
  if (v4 != 2) {
    goto LABEL_22;
  }
LABEL_17:
  if ((*(unsigned char *)(a1 + 315) & 0x20) == 0) {
    goto LABEL_22;
  }
LABEL_18:
  int v8 = *(_DWORD *)(a1 + 884);
  if (v8)
  {
    if (v8 != 1)
    {
      if (v8 == 2)
      {
        int v9 = 1;
        *(_DWORD *)(a1 + 884) = 1;
        png_chunk_benign_error(a1, "no space in chunk cache");
        goto LABEL_26;
      }
      *(_DWORD *)(a1 + 884) = v8 - 1;
      goto LABEL_24;
    }
LABEL_22:
    int v9 = 1;
    goto LABEL_26;
  }
LABEL_24:
  _cg_png_set_unknown_chunks((void (**)(void))a1, a2, a1 + 896, 1);
LABEL_25:
  int v9 = 0;
LABEL_26:
  unsigned __int8 v10 = *(void **)(a1 + 904);
  if (v10) {
    png_free(a1, v10);
  }
  *(void *)(a1 + 904) = 0;
  *(void *)(a1 + 912) = 0;
  if (v9 && (*(unsigned char *)(a1 + 315) & 0x20) == 0)
  {
    int v11 = "unhandled critical chunk";
    goto LABEL_33;
  }
}

uint64_t _cg_png_read_update_info(uint64_t result, unsigned int *a2)
{
  if (result)
  {
    uint64_t v2 = result;
    if ((*(unsigned char *)(result + 80) & 0x40) != 0)
    {
      return png_app_error(result, "png_read_update_info/png_start_read_image: duplicate call");
    }
    else
    {
      png_read_start_row(result);
      return png_read_transform_info(v2, a2);
    }
  }
  return result;
}

void _cg_png_set_keep_unknown_chunks_sized(uint64_t a1, unsigned int a2, const char *a3, int a4)
{
  if (!a1) {
    return;
  }
  if (a2 >= 4)
  {
    unsigned int v6 = "png_set_keep_unknown_chunks: invalid keep";
LABEL_14:
    png_app_error(a1, v6);
    return;
  }
  int v7 = a4;
  if (a4 <= 0)
  {
    *(_DWORD *)(a1 + 736) = a2;
    if (!a4) {
      return;
    }
    int v7 = 18;
    int v8 = "bKGD";
  }
  else
  {
    int v8 = a3;
    if (!a3)
    {
      unsigned int v6 = "png_set_keep_unknown_chunks: no chunk list";
      goto LABEL_14;
    }
  }
  int v9 = *(void (***)(void))(a1 + 744);
  if (v9) {
    int v10 = *(_DWORD *)(a1 + 740);
  }
  else {
    int v10 = 0;
  }
  if ((v10 + v7) >= 0x33333334)
  {
    unsigned int v6 = "png_set_keep_unknown_chunks: too many chunks";
    goto LABEL_14;
  }
  if (a2)
  {
    int v11 = png_malloc((void (**)(void))a1, (5 * (v10 + v7)));
    int v9 = v11;
    if (v10) {
      memcpy(v11, *(const void **)(a1 + 744), (5 * v10));
    }
  }
  else if (!v10)
  {
    goto LABEL_42;
  }
  if (!v9)
  {
LABEL_43:
    int v17 = 0;
LABEL_44:
    int v21 = v9;
    int v9 = *(void (***)(void))(a1 + 744);
    goto LABEL_45;
  }
  uint64_t v12 = 0;
  do
  {
    unsigned __int8 v13 = &v8[5 * v12];
    uint64_t v14 = (uint64_t)v9;
    if (v10)
    {
      uint64_t v14 = (uint64_t)v9 + 5 * (v10 - 1) + 5;
      int v15 = v10;
      int v16 = v9;
      while (*(_DWORD *)v16 != *(_DWORD *)v13)
      {
        int v16 = (void (**)(void))((char *)v16 + 5);
        if (!--v15) {
          goto LABEL_27;
        }
      }
      uint64_t v14 = (uint64_t)v16;
    }
    else
    {
LABEL_27:
      if (!a2) {
        goto LABEL_31;
      }
      ++v10;
      *(_DWORD *)uint64_t v14 = *(_DWORD *)v13;
    }
    *(unsigned char *)(v14 + 4) = a2;
LABEL_31:
    ++v12;
  }
  while (v12 != v7);
  if (v10)
  {
    int v17 = 0;
    uint64_t v18 = v9;
    unsigned int v19 = v9;
    do
    {
      if (*((unsigned char *)v19 + 4))
      {
        if (v19 != v18)
        {
          int v20 = *(_DWORD *)v19;
          *((unsigned char *)v18 + 4) = *((unsigned char *)v19 + 4);
          *(_DWORD *)uint64_t v18 = v20;
        }
        uint64_t v18 = (void (**)(void))((char *)v18 + 5);
        ++v17;
      }
      unsigned int v19 = (void (**)(void))((char *)v19 + 5);
      --v10;
    }
    while (v10);
    if (v17) {
      goto LABEL_44;
    }
  }
  if (*(void (***)(void))(a1 + 744) != v9)
  {
    png_free(a1, v9);
LABEL_42:
    int v9 = 0;
    goto LABEL_43;
  }
  int v21 = 0;
  int v17 = 0;
LABEL_45:
  *(_DWORD *)(a1 + 740) = v17;
  if (v9 != v21)
  {
    if (v9) {
      png_free(a1, v9);
    }
    *(void *)(a1 + 744) = v21;
  }
}

uint64_t png_read_start_row(uint64_t a1)
{
  png_init_read_transformations(a1);
  if (*(unsigned char *)(a1 + 388))
  {
    int v2 = *(_DWORD *)(a1 + 88);
    unsigned int v3 = *(_DWORD *)(a1 + 284);
    if ((v2 & 2) == 0) {
      unsigned int v3 = (v3 + 7) >> 3;
    }
    *(_DWORD *)(a1 + 288) = v3;
    int v4 = *(_DWORD *)(a1 + 280);
    *(_DWORD *)(a1 + 304) = (v4
                           + png_read_start_row_png_pass_inc[*(unsigned __int8 *)(a1 + 389)]
                           + ~png_read_start_row_png_pass_start[*(unsigned __int8 *)(a1 + 389)])
                          / png_read_start_row_png_pass_inc[*(unsigned __int8 *)(a1 + 389)];
  }
  else
  {
    *(_DWORD *)(a1 + 288) = *(_DWORD *)(a1 + 284);
    int v4 = *(_DWORD *)(a1 + 280);
    *(_DWORD *)(a1 + 304) = v4;
    int v2 = *(_DWORD *)(a1 + 88);
  }
  unsigned int v5 = *(unsigned __int8 *)(a1 + 394);
  if ((v2 & 4) != 0 && *(unsigned __int8 *)(a1 + 392) < 8u) {
    unsigned int v5 = 8;
  }
  if ((v2 & 0x1000) == 0)
  {
    if ((v2 & 0x200) != 0) {
      *(_DWORD *)(a1 + 88) = v2 & 0xFFFFFDFF;
    }
    goto LABEL_25;
  }
  int v6 = *(unsigned __int8 *)(a1 + 391);
  if (!*(unsigned char *)(a1 + 391))
  {
    if (v5 <= 8) {
      unsigned int v5 = 8;
    }
    v5 <<= *(_WORD *)(a1 + 384) != 0;
    goto LABEL_23;
  }
  if (v6 != 2)
  {
    if (v6 == 3)
    {
      if (*(_WORD *)(a1 + 384)) {
        unsigned int v5 = 32;
      }
      else {
        unsigned int v5 = 24;
      }
      if ((v2 & 0x200) == 0) {
        goto LABEL_25;
      }
LABEL_24:
      v5 <<= *(unsigned __int8 *)(a1 + 392) < 0x10u;
      goto LABEL_25;
    }
LABEL_23:
    if ((v2 & 0x200) == 0) {
      goto LABEL_25;
    }
    goto LABEL_24;
  }
  if (*(_WORD *)(a1 + 384)) {
    unsigned int v5 = (87384 * v5) >> 16;
  }
  if ((v2 & 0x200) != 0) {
    goto LABEL_24;
  }
LABEL_25:
  unsigned int v7 = *(_DWORD *)(a1 + 88);
  if ((v7 & 0x8000) == 0)
  {
    if ((v7 & 0x4000) != 0) {
      goto LABEL_37;
    }
LABEL_46:
    if ((v7 & 0x100000) == 0) {
      goto LABEL_49;
    }
    goto LABEL_47;
  }
  if (v5 <= 0x20) {
    int v8 = 32;
  }
  else {
    int v8 = 64;
  }
  if (v5 >= 9) {
    int v9 = 32;
  }
  else {
    int v9 = 16;
  }
  if (!*(unsigned char *)(a1 + 391)) {
    unsigned int v5 = v9;
  }
  if (*(unsigned __int8 *)(a1 + 391) - 2 < 2) {
    unsigned int v5 = v8;
  }
  if ((v7 & 0x4000) == 0) {
    goto LABEL_46;
  }
LABEL_37:
  if ((v7 & 0x8000) != 0
    || ((*(_WORD *)(a1 + 384) != 0) & (v7 >> 12)) != 0
    || (int v10 = *(unsigned __int8 *)(a1 + 391), v10 == 4))
  {
    if (v5 >= 0x11) {
      unsigned int v5 = 64;
    }
    else {
      unsigned int v5 = 32;
    }
    if ((v7 & 0x100000) == 0) {
      goto LABEL_49;
    }
  }
  else
  {
    BOOL v21 = v10 == 6;
    if (v10 == 6) {
      int v22 = 64;
    }
    else {
      int v22 = 48;
    }
    if (v21) {
      int v23 = 32;
    }
    else {
      int v23 = 24;
    }
    if (v5 <= 8) {
      unsigned int v5 = v23;
    }
    else {
      unsigned int v5 = v22;
    }
    if ((v7 & 0x100000) == 0) {
      goto LABEL_49;
    }
  }
LABEL_47:
  if (*(unsigned __int8 *)(a1 + 73) * *(unsigned __int8 *)(a1 + 72) > v5) {
    unsigned int v5 = *(unsigned __int8 *)(a1 + 73) * *(unsigned __int8 *)(a1 + 72);
  }
LABEL_49:
  *(unsigned char *)(a1 + 398) = v5;
  *(unsigned char *)(a1 + 399) = 0;
  unsigned int v11 = (v4 + 7) & 0xFFFFFFF8;
  unint64_t v12 = v11 * (unint64_t)(v5 >> 3);
  unint64_t v13 = (v11 * (unint64_t)v5) >> 3;
  if (v5 > 7) {
    unint64_t v13 = v12;
  }
  size_t v14 = v13 + ((v5 + 7) >> 3) + 49;
  if (v14 > *(void *)(a1 + 928))
  {
    png_free(a1, *(void **)(a1 + 840));
    png_free(a1, *(void **)(a1 + 960));
    if (*(unsigned char *)(a1 + 388)) {
      int v15 = png_calloc((void (**)(void))a1, v14);
    }
    else {
      int v15 = png_malloc((void (**)(void))a1, v14);
    }
    *(void *)(a1 + 840) = v15;
    int v16 = png_malloc((void (**)(void))a1, v14);
    *(void *)(a1 + 960) = v16;
    unint64_t v17 = ((*(void *)(a1 + 840) + 32) & 0xFFFFFFFFFFFFFFF0) - 1;
    *(void *)(a1 + 320) = ((unint64_t)(v16 + 4) & 0xFFFFFFFFFFFFFFF0) - 1;
    *(void *)(a1 + 328) = v17;
    *(void *)(a1 + 928) = v14;
  }
  uint64_t v18 = *(void *)(a1 + 296);
  if (v18 == -1)
  {
    uint64_t v24 = "Row has too many bytes to allocate in memory";
    goto LABEL_78;
  }
  bzero(*(void **)(a1 + 320), v18 + 1);
  unsigned int v19 = *(void **)(a1 + 936);
  if (v19)
  {
    *(void *)(a1 + 936) = 0;
    *(void *)(a1 + 944) = 0;
    png_free(a1, v19);
  }
  uint64_t result = png_inflate_claim(a1, 1229209940);
  if (result)
  {
    uint64_t v24 = *(const char **)(a1 + 144);
LABEL_78:
    _cg_png_error((void (**)(void))a1, v24);
  }
  *(_DWORD *)(a1 + 80) |= 0x40u;
  return result;
}

void (**png_malloc(void (**result)(void), size_t size))(void)
{
  if (result)
  {
    int v2 = result;
    if (!size) {
      goto LABEL_7;
    }
    unsigned int v3 = result[103];
    if (v3)
    {
      uint64_t result = (void (**)(void))((uint64_t (*)(void (**)(void)))v3)(result);
      if (result) {
        return result;
      }
LABEL_7:
      _cg_png_error(v2, "Out of memory");
    }
    uint64_t result = (void (**)(void))malloc_type_malloc(size, 0xB622AF59uLL);
    if (!result) {
      goto LABEL_7;
    }
  }
  return result;
}

uint64_t png_inflate_claim(uint64_t a1, int a2)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  unsigned int v4 = *(_DWORD *)(a1 + 92);
  if (v4)
  {
    memset(v13, 0, sizeof(v13));
    long long v12 = 0u;
    long long v11 = 0u;
    unsigned int v10 = bswap32(v4);
    png_safecat((uint64_t)&v10, 0x40uLL, 4uLL, " using zstream");
    png_chunk_warning(a1, (const char *)&v10);
    *(_DWORD *)(a1 + 92) = 0;
  }
  *(void *)(a1 + 96) = 0;
  unsigned int v5 = (z_stream *)(a1 + 96);
  if ((*(_DWORD *)(a1 + 680) & 0xC) == 0xC) {
    int v6 = 15;
  }
  else {
    int v6 = 0;
  }
  *(unsigned char *)(a1 + 400) = (*(_DWORD *)(a1 + 680) & 0xC) != 12;
  if ((*(_DWORD *)(a1 + 84) & 0x11) != 0) {
    int v7 = -15;
  }
  else {
    int v7 = v6;
  }
  *(_DWORD *)(a1 + 104) = 0;
  *(void *)(a1 + 120) = 0;
  *(_DWORD *)(a1 + 128) = 0;
  if ((*(unsigned char *)(a1 + 80) & 2) != 0)
  {
    uint64_t v8 = inflateReset2(v5, v7);
    if (!v8) {
      goto LABEL_14;
    }
  }
  else
  {
    uint64_t v8 = inflateInit2_(v5, v7, "1.2.12", 112);
    if (!v8)
    {
      *(_DWORD *)(a1 + 80) |= 2u;
LABEL_14:
      uint64_t v8 = 0;
      *(_DWORD *)(a1 + 92) = a2;
      return v8;
    }
  }
  png_zstream_error(a1, v8);
  return v8;
}

void png_init_read_transformations(uint64_t a1)
{
  int v2 = *(_DWORD *)(a1 + 1000);
  int v3 = *(_DWORD *)(a1 + 452);
  if (v2)
  {
    if (v3)
    {
      int v88 = 0;
      if (png_muldiv(&v88, v2, v3, 100000))
      {
        BOOL v4 = png_gamma_significant(v88);
        *(_WORD *)(a1 + 1074) |= 1u;
        if (!v4) {
          goto LABEL_13;
        }
      }
      else
      {
        *(_WORD *)(a1 + 1074) |= 1u;
      }
      unsigned int v5 = *(_DWORD *)(a1 + 88) | 0x2000;
      goto LABEL_14;
    }
    *(_DWORD *)(a1 + 452) = png_reciprocal(*(_DWORD *)(a1 + 1000));
  }
  else if (v3)
  {
    *(_DWORD *)(a1 + 1000) = png_reciprocal(*(_DWORD *)(a1 + 452));
  }
  else
  {
    *(_DWORD *)(a1 + 1000) = 100000;
    *(_DWORD *)(a1 + 452) = 100000;
  }
  *(_WORD *)(a1 + 1074) |= 1u;
LABEL_13:
  unsigned int v5 = *(_DWORD *)(a1 + 88) & 0xFFFFDFFF;
LABEL_14:
  *(_DWORD *)(a1 + 88) = v5;
  if ((v5 & 0x40080) == 0x40000)
  {
    *(_DWORD *)(a1 + 88) = v5 & 0xFD7FFEFF;
    *(_DWORD *)(a1 + 80) &= ~0x2000u;
    *(_WORD *)(a1 + 384) = 0;
  }
  BOOL v6 = png_gamma_significant(*(_DWORD *)(a1 + 452));
  unsigned int v7 = *(_DWORD *)(a1 + 88);
  if (!v6)
  {
    v7 &= ~0x800000u;
    *(_DWORD *)(a1 + 88) = v7;
    *(_DWORD *)(a1 + 80) &= ~0x2000u;
  }
  if ((v7 & 0x600000) != 0)
  {
    png_colorspace_set_rgb_coefficients(a1);
    unsigned int v7 = *(_DWORD *)(a1 + 88);
  }
  if ((v7 & 0x100) != 0)
  {
    if ((*(unsigned char *)(a1 + 391) & 2) == 0) {
      *(_DWORD *)(a1 + 76) |= 0x800u;
    }
  }
  else if ((~v7 & 0x4080) == 0)
  {
    int v8 = *(unsigned __int16 *)(a1 + 414);
    if (v8 == *(unsigned __int16 *)(a1 + 416) && v8 == *(unsigned __int16 *)(a1 + 418))
    {
      *(_DWORD *)(a1 + 76) |= 0x800u;
      *(_WORD *)(a1 + 420) = v8;
    }
  }
  int v9 = *(unsigned __int8 *)(a1 + 391);
  if (v9 == 3)
  {
    uint64_t v10 = *(unsigned __int16 *)(a1 + 384);
    if (*(_WORD *)(a1 + 384))
    {
      int v11 = 0;
      long long v12 = *(unsigned __int8 **)(a1 + 520);
      uint64_t v13 = *(unsigned __int16 *)(a1 + 384);
      do
      {
        int v15 = *v12++;
        int v14 = v15;
        if (v15 != 255)
        {
          if (v14)
          {
            unsigned int v16 = v7;
            goto LABEL_49;
          }
          int v11 = 1;
        }
        --v13;
      }
      while (v13);
      unsigned int v16 = v7 & 0xFF7FFFFF;
      *(_DWORD *)(a1 + 88) = v7 & 0xFF7FFFFF;
      *(_DWORD *)(a1 + 80) &= ~0x2000u;
      if (v11) {
        goto LABEL_49;
      }
    }
    else
    {
      *(_DWORD *)(a1 + 80) &= ~0x2000u;
    }
    unsigned int v16 = v7 & 0xFF7FFE7F;
    *(_DWORD *)(a1 + 88) = v7 & 0xFF7FFE7F;
LABEL_49:
    if ((~v16 & 0x1100) == 0)
    {
      BOOL v21 = (unsigned __int8 *)(*(void *)(a1 + 368) + 3 * *(unsigned __int8 *)(a1 + 412));
      *(_WORD *)(a1 + 414) = *v21;
      *(_WORD *)(a1 + 416) = v21[1];
      *(_WORD *)(a1 + 418) = v21[2];
      if (v10)
      {
        if ((v16 & 0x2080000) == 0x80000)
        {
          int v22 = *(unsigned char **)(a1 + 520);
          do
          {
            *int v22 = ~*v22;
            ++v22;
            --v10;
          }
          while (v10);
          unsigned int v16 = *(_DWORD *)(a1 + 88);
        }
      }
    }
  }
  else
  {
    if ((v9 & 4) != 0)
    {
      unsigned int v16 = v7;
    }
    else
    {
      int v17 = *(unsigned __int16 *)(a1 + 384);
      unsigned int v16 = v7 & 0xFF7FFFFF;
      *(_DWORD *)(a1 + 88) = v7 & 0xFF7FFFFF;
      *(_DWORD *)(a1 + 80) &= ~0x2000u;
      if (!v17)
      {
        unsigned int v16 = v7 & 0xFF7FFE7F;
        *(_DWORD *)(a1 + 88) = v7 & 0xFF7FFE7F;
      }
    }
    if ((v9 & 2) == 0 && (v16 & 0x1100) == 0x1100)
    {
      __int16 v18 = *(_WORD *)(a1 + 420);
      __int16 v19 = *(_WORD *)(a1 + 536);
      int v20 = *(unsigned __int8 *)(a1 + 392);
      switch(v20)
      {
        case 4:
          v18 *= 17;
          v19 *= 17;
          break;
        case 2:
          v18 *= 85;
          v19 *= 85;
          break;
        case 1:
          v18 *= 255;
          v19 *= 255;
          break;
      }
      *(_WORD *)(a1 + 418) = v18;
      *(_WORD *)(a1 + 416) = v18;
      *(_WORD *)(a1 + 414) = v18;
      if ((v16 & 0x2000000) == 0)
      {
        *(_WORD *)(a1 + 534) = v19;
        *(_WORD *)(a1 + 532) = v19;
        *(_WORD *)(a1 + 530) = v19;
      }
    }
  }
  if ((v16 & 0x380) == 0x280 && *(unsigned char *)(a1 + 392) != 16) {
    *(int16x4_t *)(a1 + 414) = vaddhn_s32((int32x4_t)vmull_u16(*(uint16x4_t *)(a1 + 414), (uint16x4_t)0xFF00FF00FF00FFLL), vdupq_n_s32(0x807Fu));
  }
  if ((v16 & 0x4000400) != 0 && (v16 & 0x180) == 0x80 && *(unsigned char *)(a1 + 392) == 16) {
    *(int16x4_t *)(a1 + 414) = vmul_s16(*(int16x4_t *)(a1 + 414), (int16x4_t)0x101010101010101);
  }
  *(_WORD *)(a1 + 430) = *(_WORD *)(a1 + 420);
  *(void *)(a1 + 422) = *(void *)(a1 + 412);
  if ((v16 & 0x2000) != 0) {
    goto LABEL_88;
  }
  if ((v16 & 0x600000) != 0)
  {
    if (png_gamma_significant(*(_DWORD *)(a1 + 1000)) || png_gamma_significant(*(_DWORD *)(a1 + 452))) {
      goto LABEL_88;
    }
    unsigned int v16 = *(_DWORD *)(a1 + 88);
  }
  if ((v16 & 0x80) != 0
    && (png_gamma_significant(*(_DWORD *)(a1 + 1000))
     || png_gamma_significant(*(_DWORD *)(a1 + 452))
     || *(unsigned char *)(a1 + 404) == 3 && png_gamma_significant(*(_DWORD *)(a1 + 408))))
  {
    goto LABEL_88;
  }
  unsigned int v23 = *(_DWORD *)(a1 + 88);
  if ((v23 & 0x800000) != 0)
  {
    if (!png_gamma_significant(*(_DWORD *)(a1 + 452)))
    {
      unsigned int v23 = *(_DWORD *)(a1 + 88);
      goto LABEL_75;
    }
LABEL_88:
    png_build_gamma_table(a1, *(unsigned __int8 *)(a1 + 392));
    unsigned int v23 = *(_DWORD *)(a1 + 88);
    if ((v23 & 0x80) == 0)
    {
      if (*(unsigned char *)(a1 + 391) == 3 && ((v23 & 0x1000) == 0 || (v23 & 0x600000) == 0))
      {
        uint64_t v34 = *(unsigned __int16 *)(a1 + 376);
        if (*(_WORD *)(a1 + 376))
        {
          uint64_t v35 = *(void *)(a1 + 456);
          uint64_t v36 = (unsigned char *)(*(void *)(a1 + 368) + 2);
          do
          {
            *(v36 - 2) = *(unsigned char *)(v35 + *(v36 - 2));
            *(v36 - 1) = *(unsigned char *)(v35 + *(v36 - 1));
            *uint64_t v36 = *(unsigned char *)(v35 + *v36);
            v36 += 3;
            --v34;
          }
          while (v34);
        }
        v23 &= ~0x2000u;
        goto LABEL_144;
      }
      goto LABEL_145;
    }
    if ((v23 & 0x600000) != 0) {
      png_warning(a1, "libpng does not support gamma+background+rgb_to_gray");
    }
    if (*(unsigned char *)(a1 + 391) == 3)
    {
      unsigned int v37 = 100000;
      uint64_t v38 = *(void *)(a1 + 368);
      uint64_t v39 = *(unsigned __int16 *)(a1 + 376);
      int v40 = *(unsigned __int8 *)(a1 + 404);
      if (v40 == 1)
      {
        int v41 = *(_DWORD *)(a1 + 452);
      }
      else if (v40 == 3)
      {
        int v41 = png_reciprocal(*(_DWORD *)(a1 + 408));
        unsigned int v37 = png_reciprocal2(*(_DWORD *)(a1 + 408), *(_DWORD *)(a1 + 452));
      }
      else
      {
        int v41 = 100000;
        if (v40 == 2)
        {
          uint64_t v42 = *(void *)(a1 + 456);
          uint64_t v43 = *(unsigned __int16 *)(a1 + 414);
          LOBYTE(v44) = *(unsigned char *)(v42 + v43);
          uint64_t v45 = *(unsigned __int16 *)(a1 + 416);
          char v46 = *(unsigned char *)(v42 + v45);
          uint64_t v47 = *(unsigned __int16 *)(a1 + 418);
          char v48 = *(unsigned char *)(v42 + v47);
          uint64_t v49 = *(void *)(a1 + 480);
          LOBYTE(v50) = *(unsigned char *)(v49 + v43);
          unsigned __int8 v51 = *(unsigned char *)(v49 + v45);
          unsigned __int8 v52 = *(unsigned char *)(v49 + v47);
          if (!*(_WORD *)(a1 + 376)) {
            goto LABEL_143;
          }
LABEL_133:
          unint64_t v63 = 0;
          v64 = (unsigned char *)(v38 + 2);
          while (v63 < *(unsigned __int16 *)(a1 + 384))
          {
            uint64_t v65 = *(void *)(a1 + 520);
            int v66 = *(unsigned __int8 *)(v65 + v63);
            if (v66 == 255) {
              break;
            }
            if (*(unsigned char *)(v65 + v63))
            {
              uint64_t v70 = *(void *)(a1 + 472);
              uint64_t v69 = *(void *)(a1 + 480);
              __int16 v71 = *(unsigned __int8 *)(v69 + *(v64 - 2)) * (_WORD)v66
                  + (v66 ^ 0xFF) * v50
                  + 128;
              *(v64 - 2) = *(unsigned char *)(v70 + ((unsigned __int16)(v71 + HIBYTE(v71)) >> 8));
              __int16 v72 = *(unsigned __int8 *)(v65 + v63) * *(unsigned __int8 *)(v69 + *(v64 - 1))
                  + (*(unsigned __int8 *)(v65 + v63) ^ 0xFF) * v51
                  + 128;
              *(v64 - 1) = *(unsigned char *)(v70 + ((unsigned __int16)(v72 + HIBYTE(v72)) >> 8));
              __int16 v73 = *(unsigned __int8 *)(v65 + v63) * *(unsigned __int8 *)(v69 + *v64)
                  + (*(unsigned __int8 *)(v65 + v63) ^ 0xFF) * v52
                  + 128;
              char v68 = *(unsigned char *)(v70 + ((unsigned __int16)(v73 + HIBYTE(v73)) >> 8));
              goto LABEL_139;
            }
            *(v64 - 2) = v44;
            *(v64 - 1) = v46;
            unsigned char *v64 = v48;
LABEL_140:
            ++v63;
            v64 += 3;
            if (v39 == v63) {
              goto LABEL_143;
            }
          }
          uint64_t v67 = *(void *)(a1 + 456);
          *(v64 - 2) = *(unsigned char *)(v67 + *(v64 - 2));
          *(v64 - 1) = *(unsigned char *)(v67 + *(v64 - 1));
          char v68 = *(unsigned char *)(v67 + *v64);
LABEL_139:
          unsigned char *v64 = v68;
          goto LABEL_140;
        }
      }
      BOOL v61 = png_gamma_significant(v37);
      __int16 v44 = *(_WORD *)(a1 + 414);
      if (v61)
      {
        LOBYTE(v44) = png_gamma_8bit_correct(*(unsigned __int16 *)(a1 + 414), v37);
        char v46 = png_gamma_8bit_correct(*(unsigned __int16 *)(a1 + 416), v37);
        char v48 = png_gamma_8bit_correct(*(unsigned __int16 *)(a1 + 418), v37);
      }
      else
      {
        char v46 = *(unsigned char *)(a1 + 416);
        char v48 = *(unsigned char *)(a1 + 418);
      }
      BOOL v62 = png_gamma_significant(v41);
      __int16 v50 = *(_WORD *)(a1 + 414);
      if (v62)
      {
        LOBYTE(v50) = png_gamma_8bit_correct(*(unsigned __int16 *)(a1 + 414), v41);
        unsigned __int8 v51 = png_gamma_8bit_correct(*(unsigned __int16 *)(a1 + 416), v41);
        unsigned __int8 v52 = png_gamma_8bit_correct(*(unsigned __int16 *)(a1 + 418), v41);
        if (!v39) {
          goto LABEL_143;
        }
      }
      else
      {
        unsigned __int8 v51 = *(unsigned char *)(a1 + 416);
        unsigned __int8 v52 = *(unsigned char *)(a1 + 418);
        if (!v39)
        {
LABEL_143:
          unsigned int v23 = *(_DWORD *)(a1 + 88) & 0xFFFFDF7F;
LABEL_144:
          *(_DWORD *)(a1 + 88) = v23;
          goto LABEL_145;
        }
      }
      goto LABEL_133;
    }
    int v53 = *(unsigned __int8 *)(a1 + 404);
    switch(v53)
    {
      case 3:
        int v55 = png_reciprocal(*(_DWORD *)(a1 + 408));
        int v56 = *(_DWORD *)(a1 + 408);
        break;
      case 2:
        int v55 = png_reciprocal(*(_DWORD *)(a1 + 1000));
        int v56 = *(_DWORD *)(a1 + 1000);
        break;
      case 1:
        unsigned int v54 = 100000;
        int v55 = *(_DWORD *)(a1 + 452);
        goto LABEL_111;
      default:
        _cg_png_error((void (**)(void))a1, "invalid background gamma type");
    }
    unsigned int v54 = png_reciprocal2(v56, *(_DWORD *)(a1 + 452));
LABEL_111:
    BOOL v57 = png_gamma_significant(v55);
    BOOL v58 = png_gamma_significant(v54);
    if (v57) {
      *(_WORD *)(a1 + 430) = png_gamma_correct(a1, *(unsigned __int16 *)(a1 + 420), v55);
    }
    if (v58) {
      *(_WORD *)(a1 + 420) = png_gamma_correct(a1, *(unsigned __int16 *)(a1 + 420), v54);
    }
    int v59 = *(unsigned __int16 *)(a1 + 414);
    if (v59 == *(unsigned __int16 *)(a1 + 416)
      && v59 == *(unsigned __int16 *)(a1 + 418)
      && v59 == *(unsigned __int16 *)(a1 + 420))
    {
      __int16 v60 = *(_WORD *)(a1 + 430);
      *(_WORD *)(a1 + 428) = v60;
      *(_WORD *)(a1 + 426) = v60;
      *(_WORD *)(a1 + 424) = v60;
      *(_WORD *)(a1 + 418) = v59;
      *(_WORD *)(a1 + 416) = v59;
      *(_WORD *)(a1 + 414) = v59;
    }
    else
    {
      if (v57)
      {
        *(_WORD *)(a1 + 424) = png_gamma_correct(a1, v59, v55);
        *(_WORD *)(a1 + 426) = png_gamma_correct(a1, *(unsigned __int16 *)(a1 + 416), v55);
        *(_WORD *)(a1 + 428) = png_gamma_correct(a1, *(unsigned __int16 *)(a1 + 418), v55);
      }
      if (v58)
      {
        *(_WORD *)(a1 + 414) = png_gamma_correct(a1, *(unsigned __int16 *)(a1 + 414), v54);
        *(_WORD *)(a1 + 416) = png_gamma_correct(a1, *(unsigned __int16 *)(a1 + 416), v54);
        *(_WORD *)(a1 + 418) = png_gamma_correct(a1, *(unsigned __int16 *)(a1 + 418), v54);
      }
    }
    *(unsigned char *)(a1 + 404) = 1;
    unsigned int v23 = *(_DWORD *)(a1 + 88);
    goto LABEL_145;
  }
LABEL_75:
  if ((v23 & 0x80) != 0 && *(unsigned char *)(a1 + 391) == 3)
  {
    uint64_t v24 = *(unsigned __int16 *)(a1 + 384);
    if (*(_WORD *)(a1 + 384))
    {
      uint64_t v25 = 0;
      __int16 v26 = *(unsigned __int8 *)(a1 + 414);
      __int16 v27 = *(unsigned __int8 *)(a1 + 416);
      __int16 v28 = *(unsigned __int8 *)(a1 + 418);
      v29 = (unsigned char *)(*(void *)(a1 + 368) + 2);
      do
      {
        uint64_t v30 = *(void *)(a1 + 520);
        int v31 = *(unsigned __int8 *)(v30 + v25);
        if (v31 != 255)
        {
          if (*(unsigned char *)(v30 + v25))
          {
            __int16 v32 = *(v29 - 2) * (_WORD)v31 + v26 * (v31 ^ 0xFF) + 128;
            *(v29 - 2) = (unsigned __int16)(v32 + ((unsigned __int16)(v32 & 0xFF00) >> 8)) >> 8;
            *(v29 - 1) = (unsigned __int16)(*(unsigned __int8 *)(v30 + v25) * *(v29 - 1)
                                          + v27 * (*(unsigned __int8 *)(v30 + v25) ^ 0xFF)
                                          + 128
                                          + ((unsigned __int16)((*(unsigned __int8 *)(v30 + v25)
                                                               * *(v29 - 1)
                                                               + v27 * (*(unsigned __int8 *)(v30 + v25) ^ 0xFF)
                                                               + 128) & 0xFF00) >> 8)) >> 8;
            __int16 v33 = *(unsigned __int8 *)(v30 + v25) * *v29
                + v28 * (*(unsigned __int8 *)(v30 + v25) ^ 0xFF)
                + 128;
            unsigned char *v29 = (unsigned __int16)(v33 + ((unsigned __int16)(v33 & 0xFF00) >> 8)) >> 8;
          }
          else
          {
            *(v29 - 2) = v26;
            *(v29 - 1) = v27;
            unsigned char *v29 = v28;
          }
        }
        ++v25;
        v29 += 3;
      }
      while (v24 != v25);
      unsigned int v23 = *(_DWORD *)(a1 + 88);
    }
    v23 &= ~0x80u;
    goto LABEL_144;
  }
LABEL_145:
  if ((v23 & 0x1008) == 8 && *(unsigned char *)(a1 + 391) == 3)
  {
    uint64_t v74 = *(unsigned __int16 *)(a1 + 376);
    int v75 = *(unsigned __int8 *)(a1 + 504);
    *(_DWORD *)(a1 + 88) = v23 & 0xFFFFFFF7;
    if ((v75 - 1) <= 6 && v74)
    {
      char v76 = 8 - v75;
      v77 = *(unsigned char **)(a1 + 368);
      uint64_t v78 = v74;
      do
      {
        unsigned char *v77 = *v77 >> v76;
        v77 += 3;
        --v78;
      }
      while (v78);
    }
    int v79 = *(unsigned __int8 *)(a1 + 505);
    if ((v79 - 1) <= 6 && v74 != 0)
    {
      char v81 = 8 - v79;
      v82 = (unsigned char *)(*(void *)(a1 + 368) + 1);
      uint64_t v83 = v74;
      do
      {
        unsigned char *v82 = *v82 >> v81;
        v82 += 3;
        --v83;
      }
      while (v83);
    }
    int v84 = *(unsigned __int8 *)(a1 + 506);
    if ((v84 - 1) <= 6 && v74 != 0)
    {
      char v86 = 8 - v84;
      v87 = (unsigned char *)(*(void *)(a1 + 368) + 2);
      do
      {
        unsigned char *v87 = *v87 >> v86;
        v87 += 3;
        --v74;
      }
      while (v74);
    }
  }
}

BOOL png_gamma_significant(int a1)
{
  return (a1 - 105001) < 0xFFFFD8EF;
}

void _cg_png_destroy_read_struct(uint64_t *a1, void **a2, void **a3)
{
  if (a1)
  {
    uint64_t v4 = *a1;
    if (*a1)
    {
      _cg_png_destroy_info_struct(*a1, a3);
      _cg_png_destroy_info_struct(v4, a2);
      *a1 = 0;
      png_destroy_gamma_table(v4);
      png_free(v4, *(void **)(v4 + 840));
      *(void *)(v4 + 840) = 0;
      png_free(v4, *(void **)(v4 + 960));
      *(void *)(v4 + 960) = 0;
      png_free(v4, *(void **)(v4 + 936));
      *(void *)(v4 + 936) = 0;
      png_free(v4, *(void **)(v4 + 664));
      *(void *)(v4 + 664) = 0;
      png_free(v4, *(void **)(v4 + 672));
      *(void *)(v4 + 672) = 0;
      int v6 = *(_DWORD *)(v4 + 716);
      if ((v6 & 0x1000) != 0)
      {
        png_zfree(v4, *(void *)(v4 + 368));
        *(void *)(v4 + 368) = 0;
        int v6 = *(_DWORD *)(v4 + 716);
      }
      unsigned int v7 = v6 & 0xFFFFEFFF;
      *(_DWORD *)(v4 + 716) = v6 & 0xFFFFEFFF;
      if ((v6 & 0x2000) != 0)
      {
        png_free(v4, *(void **)(v4 + 520));
        *(void *)(v4 + 520) = 0;
        unsigned int v7 = *(_DWORD *)(v4 + 716);
      }
      *(_DWORD *)(v4 + 716) = v7 & 0xFFFFDFFF;
      inflateEnd((z_streamp)(v4 + 96));
      png_free(v4, *(void **)(v4 + 592));
      *(void *)(v4 + 592) = 0;
      png_free(v4, *(void **)(v4 + 904));
      *(void *)(v4 + 912) = 0;
      *(void *)(v4 + 904) = 0;
      png_free(v4, *(void **)(v4 + 744));
      *(void *)(v4 + 744) = 0;
      png_destroy_png_struct((void *)v4);
    }
  }
}

void png_free(uint64_t a1, void *a2)
{
  if (a1 && a2)
  {
    int v2 = *(void (**)(void))(a1 + 832);
    if (v2) {
      v2();
    }
    else {
      free(a2);
    }
  }
}

void _cg_png_destroy_info_struct(uint64_t a1, void **a2)
{
  if (a1)
  {
    if (a2)
    {
      int v2 = *a2;
      if (*a2)
      {
        *a2 = 0;
        png_free_data(a1, (uint64_t)v2, 0xFFFFu, -1);
        v2[48] = 0;
        *((_OWORD *)v2 + 22) = 0u;
        *((_OWORD *)v2 + 23) = 0u;
        *((_OWORD *)v2 + 20) = 0u;
        *((_OWORD *)v2 + 21) = 0u;
        *((_OWORD *)v2 + 18) = 0u;
        *((_OWORD *)v2 + 19) = 0u;
        *((_OWORD *)v2 + 16) = 0u;
        *((_OWORD *)v2 + 17) = 0u;
        *((_OWORD *)v2 + 14) = 0u;
        *((_OWORD *)v2 + 15) = 0u;
        *((_OWORD *)v2 + 12) = 0u;
        *((_OWORD *)v2 + 13) = 0u;
        *((_OWORD *)v2 + 10) = 0u;
        *((_OWORD *)v2 + 11) = 0u;
        *((_OWORD *)v2 + 8) = 0u;
        *((_OWORD *)v2 + 9) = 0u;
        *((_OWORD *)v2 + 6) = 0u;
        *((_OWORD *)v2 + 7) = 0u;
        *((_OWORD *)v2 + 4) = 0u;
        *((_OWORD *)v2 + 5) = 0u;
        *((_OWORD *)v2 + 2) = 0u;
        *((_OWORD *)v2 + 3) = 0u;
        *(_OWORD *)int v2 = 0u;
        *((_OWORD *)v2 + 1) = 0u;
        png_free(a1, v2);
      }
    }
  }
}

void png_free_data(uint64_t a1, uint64_t a2, unsigned int a3, int a4)
{
  if (a1 && a2)
  {
    int v8 = *(void **)(a2 + 160);
    if (v8 && (a3 & *(_DWORD *)(a2 + 300) & 0x4000) != 0)
    {
      if (a4 == -1)
      {
        if (*(int *)(a2 + 148) >= 1)
        {
          uint64_t v9 = 0;
          uint64_t v10 = 8;
          do
          {
            png_free(a1, *(void **)(*(void *)(a2 + 160) + v10));
            ++v9;
            v10 += 56;
          }
          while (v9 < *(int *)(a2 + 148));
          int v8 = *(void **)(a2 + 160);
        }
        png_free(a1, v8);
        *(void *)(a2 + 160) = 0;
        *(_DWORD *)(a2 + 148) = 0;
        *(_DWORD *)(a2 + 152) = 0;
      }
      else
      {
        png_free(a1, *((void **)v8 + 7 * a4 + 1));
        *(void *)(*(void *)(a2 + 160) + 56 * a4 + 8) = 0;
      }
    }
    int v11 = *(_DWORD *)(a2 + 300);
    if ((a3 & v11 & 0x2000) != 0)
    {
      *(_DWORD *)(a2 + 8) &= ~0x10u;
      png_free(a1, *(void **)(a2 + 184));
      *(void *)(a2 + 184) = 0;
      *(_WORD *)(a2 + 34) = 0;
      int v11 = *(_DWORD *)(a2 + 300);
    }
    if ((a3 & v11 & 0x100) != 0)
    {
      png_free(a1, *(void **)(a2 + 336));
      png_free(a1, *(void **)(a2 + 344));
      *(void *)(a2 + 336) = 0;
      *(void *)(a2 + 344) = 0;
      *(_DWORD *)(a2 + 8) &= ~0x4000u;
      int v11 = *(_DWORD *)(a2 + 300);
    }
    if ((a3 & v11 & 0x80) != 0)
    {
      png_free(a1, *(void **)(a2 + 264));
      png_free(a1, *(void **)(a2 + 280));
      *(void *)(a2 + 264) = 0;
      *(void *)(a2 + 280) = 0;
      long long v12 = *(void **)(a2 + 288);
      if (v12)
      {
        if (*(unsigned char *)(a2 + 297))
        {
          unint64_t v13 = 0;
          do
            png_free(a1, *(void **)(*(void *)(a2 + 288) + 8 * v13++));
          while (v13 < *(unsigned __int8 *)(a2 + 297));
          long long v12 = *(void **)(a2 + 288);
        }
        png_free(a1, v12);
        *(void *)(a2 + 288) = 0;
        *(unsigned char *)(a2 + 297) = 0;
      }
      *(_DWORD *)(a2 + 8) &= ~0x400u;
      int v11 = *(_DWORD *)(a2 + 300);
    }
    if ((a3 & v11 & 0x10) != 0)
    {
      png_free(a1, *(void **)(a2 + 128));
      png_free(a1, *(void **)(a2 + 136));
      *(void *)(a2 + 128) = 0;
      *(void *)(a2 + 136) = 0;
      *(_DWORD *)(a2 + 144) = 0;
      *(_DWORD *)(a2 + 8) &= ~0x1000u;
    }
    int v14 = *(void **)(a2 + 320);
    if (v14 && (a3 & *(_DWORD *)(a2 + 300) & 0x20) != 0)
    {
      if (a4 == -1)
      {
        if (*(int *)(a2 + 328) >= 1)
        {
          uint64_t v16 = 0;
          uint64_t v17 = 0;
          do
          {
            png_free(a1, *(void **)(*(void *)(a2 + 320) + v16));
            png_free(a1, *(void **)(*(void *)(a2 + 320) + v16 + 24));
            ++v17;
            v16 += 40;
          }
          while (v17 < *(int *)(a2 + 328));
          int v14 = *(void **)(a2 + 320);
        }
        png_free(a1, v14);
        *(void *)(a2 + 320) = 0;
        *(_DWORD *)(a2 + 328) = 0;
        *(_DWORD *)(a2 + 8) &= ~0x2000u;
      }
      else
      {
        png_free(a1, *((void **)v14 + 5 * a4));
        png_free(a1, *(void **)(*(void *)(a2 + 320) + 40 * a4 + 24));
        uint64_t v15 = *(void *)(a2 + 320) + 40 * a4;
        *(void *)(v15 + 24) = 0;
        *(_DWORD *)(v15 + 32) = 0;
        *(void *)uint64_t v15 = 0;
        *(void *)(v15 + 8) = 0;
      }
    }
    __int16 v18 = *(void **)(a2 + 304);
    if (v18 && (a3 & *(_DWORD *)(a2 + 300) & 0x200) != 0)
    {
      if (a4 == -1)
      {
        if (*(int *)(a2 + 312) >= 1)
        {
          uint64_t v20 = 0;
          uint64_t v21 = 8;
          do
          {
            png_free(a1, *(void **)(*(void *)(a2 + 304) + v21));
            ++v20;
            v21 += 32;
          }
          while (v20 < *(int *)(a2 + 312));
          __int16 v18 = *(void **)(a2 + 304);
        }
        png_free(a1, v18);
        *(void *)(a2 + 304) = 0;
        *(_DWORD *)(a2 + 312) = 0;
      }
      else
      {
        png_free(a1, *((void **)v18 + 4 * a4 + 1));
        uint64_t v19 = *(void *)(a2 + 304) + 32 * a4;
        *(void *)(v19 + 8) = 0;
        *(void *)(v19 + 16) = 0;
      }
    }
    int v22 = *(_DWORD *)(a2 + 300);
    if ((a3 & v22 & 0x8000) != 0)
    {
      unsigned int v23 = *(void **)(a2 + 248);
      if (v23)
      {
        png_free(a1, v23);
        *(void *)(a2 + 248) = 0;
      }
      uint64_t v24 = *(void **)(a2 + 240);
      if (v24)
      {
        png_free(a1, v24);
        *(void *)(a2 + 240) = 0;
        *(_DWORD *)(a2 + 236) = 0;
      }
      *(_DWORD *)(a2 + 8) &= ~0x10000u;
      int v22 = *(_DWORD *)(a2 + 300);
    }
    if ((a3 & v22 & 8) != 0)
    {
      png_free(a1, *(void **)(a2 + 256));
      *(void *)(a2 + 256) = 0;
      *(_DWORD *)(a2 + 8) &= ~0x40u;
      int v22 = *(_DWORD *)(a2 + 300);
    }
    if ((a3 & v22 & 0x1000) != 0)
    {
      png_free(a1, *(void **)(a2 + 24));
      *(void *)(a2 + 24) = 0;
      *(_DWORD *)(a2 + 8) &= ~8u;
      *(_WORD *)(a2 + 32) = 0;
      int v22 = *(_DWORD *)(a2 + 300);
    }
    if ((a3 & v22 & 0x40) != 0)
    {
      uint64_t v25 = *(void **)(a2 + 352);
      if (v25)
      {
        if (*(_DWORD *)(a2 + 4))
        {
          unint64_t v26 = 0;
          do
            png_free(a1, *(void **)(*(void *)(a2 + 352) + 8 * v26++));
          while (v26 < *(unsigned int *)(a2 + 4));
          uint64_t v25 = *(void **)(a2 + 352);
        }
        png_free(a1, v25);
        *(void *)(a2 + 352) = 0;
        int v22 = *(_DWORD *)(a2 + 300);
      }
      *(_DWORD *)(a2 + 8) &= ~0x8000u;
    }
    unsigned int v27 = a3 & 0xFFFFBDDF;
    if (a4 == -1) {
      unsigned int v27 = a3;
    }
    *(_DWORD *)(a2 + 300) = v22 & ~v27;
  }
}

void png_destroy_gamma_table(uint64_t a1)
{
  png_free(a1, *(void **)(a1 + 456));
  *(void *)(a1 + 456) = 0;
  int v2 = *(void **)(a1 + 464);
  if (v2)
  {
    int v3 = *(_DWORD *)(a1 + 448);
    if (v3 != -23)
    {
      uint64_t v4 = 0;
      int v5 = 1 << (8 - v3);
      if (v5 <= 1) {
        int v5 = 1;
      }
      uint64_t v6 = 8 * v5;
      do
      {
        png_free(a1, *(void **)(*(void *)(a1 + 464) + v4));
        v4 += 8;
      }
      while (v6 != v4);
      int v2 = *(void **)(a1 + 464);
    }
    png_free(a1, v2);
    *(void *)(a1 + 464) = 0;
  }
  png_free(a1, *(void **)(a1 + 472));
  *(void *)(a1 + 472) = 0;
  png_free(a1, *(void **)(a1 + 480));
  *(void *)(a1 + 480) = 0;
  unsigned int v7 = *(void **)(a1 + 488);
  if (v7)
  {
    int v8 = *(_DWORD *)(a1 + 448);
    if (v8 != -23)
    {
      uint64_t v9 = 0;
      int v10 = 1 << (8 - v8);
      if (v10 <= 1) {
        int v10 = 1;
      }
      uint64_t v11 = 8 * v10;
      do
      {
        png_free(a1, *(void **)(*(void *)(a1 + 488) + v9));
        v9 += 8;
      }
      while (v11 != v9);
      unsigned int v7 = *(void **)(a1 + 488);
    }
    png_free(a1, v7);
    *(void *)(a1 + 488) = 0;
  }
  long long v12 = *(void **)(a1 + 496);
  if (v12)
  {
    int v13 = *(_DWORD *)(a1 + 448);
    if (v13 != -23)
    {
      uint64_t v14 = 0;
      int v15 = 1 << (8 - v13);
      if (v15 <= 1) {
        int v15 = 1;
      }
      uint64_t v16 = 8 * v15;
      do
      {
        png_free(a1, *(void **)(*(void *)(a1 + 496) + v14));
        v14 += 8;
      }
      while (v16 != v14);
      long long v12 = *(void **)(a1 + 496);
    }
    png_free(a1, v12);
    *(void *)(a1 + 496) = 0;
  }
}

BOOL IIOImageReadSession::willNeed(IIOImageRead **this, uint64_t a2, size_t a3)
{
  return IIOImageRead::willNeed(this[4], a2, a3);
}

BOOL IIOImageRead::willNeed(IIOImageRead *this, uint64_t a2, size_t a3)
{
  CFDataRef v3 = (const __CFData *)*((void *)this + 4);
  if (!v3) {
    return 0;
  }
  uint64_t v6 = (pthread_mutex_t *)((char *)this + 376);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 376));
  BytePtr = CFDataGetBytePtr(v3);
  if (BytePtr && (int v8 = BytePtr, (Length = CFDataGetLength(v3)) != 0))
  {
    BOOL v10 = __CFADD__(a2, a3);
    if (a2 + a3 <= Length || v10) {
      size_t v12 = a3;
    }
    else {
      size_t v12 = Length - a2;
    }
    BOOL v13 = madvise((void *)&v8[a2], v12, 3) == 0;
  }
  else
  {
    BOOL v13 = 0;
  }
  pthread_mutex_unlock(v6);
  return v13;
}

uint64_t png_reciprocal(int a1)
{
  double v1 = 1.0e10 / (double)a1 + 0.5;
  double v2 = floor(v1);
  BOOL v3 = v2 < -2147483650.0 || v2 > 2147483650.0;
  unsigned int v4 = vcvtmd_s64_f64(v1);
  if (v3) {
    return 0;
  }
  else {
    return v4;
  }
}

void png_handle_sRGB(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v4 = *(_DWORD *)(a1 + 76);
  if ((v4 & 1) == 0) {
    png_chunk_error((void (**)(void))a1, "missing IHDR");
  }
  if ((v4 & 6) != 0)
  {
    png_crc_finish(a1, a3);
    int v5 = "out of place";
LABEL_8:
    png_chunk_benign_error(a1, v5);
    return;
  }
  if (a3 != 1)
  {
    png_crc_finish(a1, a3);
    int v5 = "invalid";
    goto LABEL_8;
  }
  Bytef v8 = 0;
  png_crc_read(a1, &v8, 1u);
  if (!png_crc_finish(a1, 0))
  {
    int v7 = *(__int16 *)(a1 + 1074);
    if ((v7 & 0x80000000) == 0)
    {
      if ((v7 & 4) != 0)
      {
        *(_WORD *)(a1 + 1074) = v7 | 0x8000;
        png_colorspace_sync(a1, a2);
        png_chunk_benign_error(a1, "too many profiles");
      }
      else
      {
        png_colorspace_set_sRGB(a1, a1 + 1000, v8);
        png_colorspace_sync(a1, a2);
      }
    }
  }
}

void png_colorspace_sync_info(uint64_t a1, uint64_t a2)
{
  int v2 = *(_DWORD *)(a2 + 8);
  if (*(__int16 *)(a2 + 126) < 0)
  {
    *(_DWORD *)(a2 + 8) = v2 & 0xFFFFE7FA;
    png_free_data(a1, a2, 0x10u, -1);
  }
  else
  {
    unsigned int v3 = *(unsigned __int16 *)(a2 + 126);
    unsigned int v4 = v2 & 0xFFFFF7FB | (((v3 >> 7) & 1) << 11) | (4 * ((v3 >> 1) & 1));
    if (v3) {
      unsigned int v5 = v4 | 1;
    }
    else {
      unsigned int v5 = v4 & 0xFFFFFFFE;
    }
    *(_DWORD *)(a2 + 8) = v5;
  }
}

void png_colorspace_sync(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    long long v2 = *(_OWORD *)(a1 + 1000);
    *(_OWORD *)(a2 + 68) = *(_OWORD *)(a1 + 1016);
    long long v3 = *(_OWORD *)(a1 + 1048);
    *(_OWORD *)(a2 + 84) = *(_OWORD *)(a1 + 1032);
    *(_OWORD *)(a2 + 100) = v3;
    *(_OWORD *)(a2 + 112) = *(_OWORD *)(a1 + 1060);
    *(_OWORD *)(a2 + 52) = v2;
    png_colorspace_sync_info(a1, a2);
  }
}

uint64_t png_colorspace_set_sRGB(uint64_t a1, uint64_t a2, unsigned int a3)
{
  int v3 = *(__int16 *)(a2 + 74);
  if (v3 < 0) {
    return 0;
  }
  __int16 v4 = a3;
  if (a3 >= 4)
  {
    unint64_t v7 = (int)a3;
    Bytef v8 = "invalid sRGB rendering intent";
LABEL_13:
    png_icc_profile_error(a1, a2, "sRGB", v7, v8);
    return 0;
  }
  if ((v3 & 4) != 0 && *(unsigned __int16 *)(a2 + 72) != a3)
  {
    unint64_t v7 = a3;
    Bytef v8 = "inconsistent rendering intents";
    goto LABEL_13;
  }
  if ((v3 & 0x20) != 0)
  {
    png_benign_error(a1, "duplicate sRGB information ignored");
    return 0;
  }
  if ((v3 & 2) != 0 && !png_colorspace_endpoints_match((int *)&sRGB_xy, (_DWORD *)(a2 + 4), 100)) {
    png_chunk_report(a1, "cHRM chunk does not match sRGB", 2);
  }
  png_colorspace_check_gamma(a1, a2, 45455, 2);
  *(_OWORD *)(a2 + 4) = sRGB_xy;
  *(_OWORD *)(a2 + 20) = unk_1889AA72C;
  *(_OWORD *)(a2 + 36) = png_colorspace_set_sRGB_sRGB_XYZ;
  *(_WORD *)(a2 + 72) = v4;
  __int16 v9 = *(_WORD *)(a2 + 74);
  *(_DWORD *)(a2 + 68) = 95053;
  *(_OWORD *)(a2 + 52) = unk_1889AA708;
  *(_DWORD *)a2 = 45455;
  *(_WORD *)(a2 + 74) = v9 | 0xE7;
  return 1;
}

uint64_t png_colorspace_check_gamma(uint64_t a1, uint64_t a2, int a3, int a4)
{
  __int16 v4 = *(_WORD *)(a2 + 74);
  if (v4)
  {
    if (!a3
      || !*(_DWORD *)a2
      || ((double v5 = floor((double)*(int *)a2 * 100000.0 / (double)a3 + 0.5), v5 <= 2147483650.0)
        ? (BOOL v6 = v5 < -2147483650.0)
        : (BOOL v6 = 1),
          !v6 ? (BOOL v7 = ((int)v5 - 95000) >= 0x2711) : (BOOL v7 = 1),
          v7))
    {
      if (a4 == 2 || (v4 & 0x20) != 0)
      {
        BOOL v8 = a4 == 2;
        png_chunk_report(a1, "gamma value does not match sRGB", 2);
        return v8;
      }
      png_chunk_report(a1, "gamma value does not match libpng estimate", 0);
    }
  }
  return 1;
}

void _cg_png_set_eXIf_1(uint64_t a1, uint64_t a2, size_t size, const void *a4)
{
  if (a1 && a2 && (*(unsigned char *)(a1 + 77) & 0x40) == 0)
  {
    int v7 = size;
    size_t v8 = size;
    __int16 v9 = png_malloc_warn((void *)a1, size);
    if (v9)
    {
      BOOL v10 = v9;
      memcpy(v9, a4, v8);
      png_free_data(a1, a2, 0x8000u, 0);
      *(_DWORD *)(a2 + 236) = v7;
      *(void *)(a2 + 240) = v10;
      *(_DWORD *)(a2 + 300) |= 0x8000u;
      *(_DWORD *)(a2 + 8) |= 0x10000u;
    }
    else
    {
      *(_DWORD *)(a2 + 236) = 0;
      png_warning(a1, "Insufficient memory for eXIf chunk data");
    }
  }
}

uint64_t png_handle_pHYs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  int v4 = *(_DWORD *)(a1 + 76);
  if ((v4 & 1) == 0) {
    png_chunk_error((void (**)(void))a1, "missing IHDR");
  }
  if ((v4 & 4) != 0)
  {
    png_crc_finish(a1, a3);
    int v7 = "out of place";
  }
  else if (a2 && (*(unsigned char *)(a2 + 8) & 0x80) != 0)
  {
    png_crc_finish(a1, a3);
    int v7 = "duplicate";
  }
  else
  {
    if (a3 == 9)
    {
      char v9 = 0;
      uint64_t v8 = 0;
      png_crc_read(a1, (Bytef *)&v8, 9u);
      uint64_t result = png_crc_finish(a1, 0);
      if (!result) {
        return _cg_png_set_pHYs(a1, a2, bswap32(v8), bswap32(HIDWORD(v8)), v9);
      }
      return result;
    }
    png_crc_finish(a1, a3);
    int v7 = "invalid";
  }

  return png_chunk_benign_error(a1, v7);
}

uint64_t _cg_png_set_pHYs(uint64_t result, uint64_t a2, int a3, int a4, char a5)
{
  if (result)
  {
    if (a2)
    {
      *(_DWORD *)(a2 + 224) = a3;
      *(_DWORD *)(a2 + 228) = a4;
      *(unsigned char *)(a2 + 232) = a5;
      *(_DWORD *)(a2 + 8) |= 0x80u;
    }
  }
  return result;
}

uint64_t PNGReadPlugin::Read_user_chunk_callback(void (**a1)(void), uint64_t a2)
{
  uint64_t user_chunk_ptr = _cg_png_get_user_chunk_ptr((uint64_t)a1);
  if (*(_DWORD *)a2 != 1229088579)
  {
    switch(*(_DWORD *)a2)
    {
      case 0x544F4469:
        PNGReadPlugin::Read_user_chunkIDOT(user_chunk_ptr, (uint64_t)a1, a2);
        break;
      case 0x44507061:
        PNGReadPlugin::Read_user_chunkapPD(user_chunk_ptr, v5, a2);
        break;
      case 0x50434963:
        if (!*(unsigned char *)(user_chunk_ptr + 25))
        {
          if (*(void *)(a2 + 16) == 4)
          {
            for (uint64_t i = 0; i != 4; ++i)
              *(unsigned char *)(user_chunk_ptr + 21 + i) = *(unsigned char *)(*(void *)(a2 + 8) + i);
            uint64_t v6 = 1;
            *(unsigned char *)(user_chunk_ptr + 25) = 1;
            return v6;
          }
          return 0;
        }
        break;
      default:
        return 0;
    }
    return 1;
  }

  return PNGReadPlugin::Read_user_chunkCgBI(user_chunk_ptr, a1, a2);
}

uint64_t _cg_png_get_user_chunk_ptr(uint64_t result)
{
  if (result) {
    return *(void *)(result + 720);
  }
  return result;
}

uint64_t PNGReadPlugin::Read_user_chunkIDOT(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v35 = *MEMORY[0x1E4F143B8];
  if (*(unsigned char *)(a1 + 56) || *(void *)(a1 + 48)) {
    return 1;
  }
  uint64_t io_ptr = _cg_png_get_io_ptr(a2);
  *(unsigned char *)(a1 + 57) = 0;
  int v7 = *(unsigned int **)(a3 + 8);
  if (!v7 || *(void *)(a3 + 16) <= 7uLL)
  {
    *(unsigned char *)(a1 + 57) = 1;
LABEL_6:
    LogError("Read_user_chunkIDOT", 985, "invalid 'iDOT' chunk (count = %d)\n");
    goto LABEL_7;
  }
  uint64_t v10 = bswap32(*v7);
  if ((v10 - 2) > 0xE) {
    goto LABEL_6;
  }
  uint64_t v11 = (IIO_Reader *)io_ptr;
  uint64_t v12 = 12 * v10;
  BOOL v13 = malloc_type_malloc(v12 + 4, 0xBD87507CuLL);
  *(void *)(a1 + 48) = v13;
  _DWORD *v13 = v10;
  if (*(void *)(a3 + 16) < (unint64_t)(v12 + 4)) {
    *(unsigned char *)(a1 + 57) = 1;
  }
  uint64_t v14 = IIO_Reader::minimumFileSize(v11);
  if (*(unsigned char *)(a1 + 57)) {
    goto LABEL_8;
  }
  uint64_t v15 = v14;
  unsigned int height = _cg_png_get_height(a2);
  uint64_t v17 = (char *)v7 + 7;
  __int16 v18 = v13 + 3;
  uint64_t v19 = v10;
  while (1)
  {
    unsigned int v20 = bswap32(*(_DWORD *)(v17 - 3));
    if (v20 > height) {
      break;
    }
    *(v18 - 2) = v20;
    unsigned int v21 = bswap32(*(_DWORD *)(v17 + 1));
    unsigned int v22 = v21 + v20;
    if (v21 > height || v22 > height) {
      break;
    }
    *(v18 - 1) = v21;
    unsigned int v24 = *(_DWORD *)(v17 + 5);
    v17 += 12;
    _DWORD *v18 = v15 - 12 * v10 - 12 + bswap32(v24);
    v18 += 3;
    if (!--v19)
    {
      if (*(unsigned char *)(a1 + 57)) {
        goto LABEL_8;
      }
      LODWORD(v31) = 0;
      if (IIOImageReadSession::getBytesAtOffset(v11, &v31, v15 + 4, 4uLL) == 4)
      {
        if (v31 == 1413563465)
        {
          if (*(unsigned char *)(a1 + 57)) {
            goto LABEL_8;
          }
          Size = IIOImageReadSession::getSize(v11);
          int v34 = 0;
          uint64_t v33 = 0;
          unint64_t v26 = (unint64_t)Size;
          IIOImageReadSession::getBytesAtOffset(v11, &v33, (unint64_t)Size - 12, 0xCuLL);
          if (v33 != 0x444E454900000000 || v34 != -2107620690)
          {
            LogError("Read_user_chunkIDOT", 935, "invalid PNG file: no valid iEnd chunk\n");
            *(unsigned char *)(a1 + 57) = 1;
            return 1;
          }
          uint64_t v28 = 0;
          uint64_t v31 = 0;
          uint64_t v32 = 0;
          v29 = v13 + 3;
          while (1)
          {
            uint64_t v30 = v29[v28];
            if (v30 < 0xC) {
              break;
            }
            IIOImageReadSession::getBytesAtOffset(v11, &v31, v30 - 12, 0x10uLL);
            if (HIDWORD(v32) != 1413563465)
            {
              LogWarning("Read_user_chunkIDOT", 958, "*** ERROR: invalid PNG file: iDOT doesn't point to valid IDAT chunk\n");
              goto LABEL_7;
            }
            if (v26 < bswap32(v32) + v30)
            {
              LogWarning("Read_user_chunkIDOT", 965, "*** ERROR: invalid PNG file: bad IDAT size\n");
              goto LABEL_7;
            }
            if (v28 * 4 && v31 != -65536)
            {
              _cg_jpeg_mem_term("Read_user_chunkIDOT", 975, "*** ERROR: hacked PNG file\n");
              goto LABEL_7;
            }
            v28 += 3;
            if (!--v10)
            {
              if (*(unsigned char *)(a1 + 57)) {
                goto LABEL_8;
              }
              return 1;
            }
          }
        }
        else
        {
          LogError("Read_user_chunkIDOT", 918, "invalid PNG file: extra chunks between iDOT and IDAT\n");
        }
      }
      break;
    }
  }
LABEL_7:
  *(unsigned char *)(a1 + 57) = 1;
LABEL_8:
  *(unsigned char *)(a1 + 56) = 1;
  uint64_t v8 = *(void **)(a1 + 48);
  if (v8)
  {
    free(v8);
    *(void *)(a1 + 48) = 0;
    _cg_jpeg_mem_term("Read_user_chunkIDOT", 996, "PNG: invalid 'iDOT' chunk\n");
  }
  return 1;
}

uint64_t _cg_png_get_height(uint64_t a1)
{
  return *(unsigned int *)(a1 + 284);
}

void png_handle_gAMA(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v4 = *(_DWORD *)(a1 + 76);
  if ((v4 & 1) == 0) {
    png_chunk_error((void (**)(void))a1, "missing IHDR");
  }
  if ((v4 & 6) != 0)
  {
    png_crc_finish(a1, a3);
    uint64_t v5 = "out of place";
LABEL_12:
    png_chunk_benign_error(a1, v5);
    return;
  }
  if (a3 != 4)
  {
    png_crc_finish(a1, a3);
    uint64_t v5 = "invalid";
    goto LABEL_12;
  }
  unsigned int v9 = 0;
  png_crc_read(a1, (Bytef *)&v9, 4u);
  if (!png_crc_finish(a1, 0))
  {
    int v7 = bswap32(v9);
    if (v7 < 0) {
      int v8 = -1;
    }
    else {
      int v8 = v7;
    }
    png_colorspace_set_gamma(a1, a1 + 1000, v8);
    png_colorspace_sync(a1, a2);
  }
}

uint64_t png_colorspace_set_gamma(uint64_t result, uint64_t a2, int a3)
{
  if ((a3 - 625000001) < 0xDABF41CF)
  {
    __int16 v4 = *(_WORD *)(a2 + 74);
    uint64_t v5 = "gamma value out of range";
LABEL_6:
    *(_WORD *)(a2 + 74) = v4 | 0x8000;
    return png_chunk_report(result, v5, 1);
  }
  __int16 v4 = *(_WORD *)(a2 + 74);
  if ((*(unsigned char *)(result + 77) & 0x80) != 0 && (v4 & 8) != 0)
  {
    uint64_t v5 = "duplicate";
    goto LABEL_6;
  }
  if ((*(_WORD *)(a2 + 74) & 0x8000) == 0)
  {
    uint64_t result = png_colorspace_check_gamma(result, a2, a3, 1);
    if (result)
    {
      *(_DWORD *)a2 = a3;
      *(_WORD *)(a2 + 74) = v4 | 9;
    }
  }
  return result;
}

void png_handle_cHRM(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  int v4 = *(_DWORD *)(a1 + 76);
  if ((v4 & 1) == 0) {
    png_chunk_error((void (**)(void))a1, "missing IHDR");
  }
  if ((v4 & 6) != 0)
  {
    png_crc_finish(a1, a3);
    uint64_t v5 = "out of place";
LABEL_42:
    png_chunk_benign_error(a1, v5);
    return;
  }
  if (a3 != 32)
  {
    png_crc_finish(a1, a3);
    uint64_t v5 = "invalid";
    goto LABEL_42;
  }
  long long v26 = 0u;
  long long v27 = 0u;
  png_crc_read(a1, (Bytef *)&v26, 0x20u);
  if (png_crc_finish(a1, 0)) {
    return;
  }
  int v7 = bswap32(v26);
  if (v7 < 0) {
    int v8 = -1;
  }
  else {
    int v8 = v7;
  }
  int v9 = bswap32(DWORD1(v26));
  if (v9 < 0) {
    int v10 = -1;
  }
  else {
    int v10 = v9;
  }
  v25[6] = v8;
  v25[7] = v10;
  int v11 = bswap32(DWORD2(v26));
  if (v11 < 0) {
    int v12 = -1;
  }
  else {
    int v12 = v11;
  }
  int v13 = bswap32(HIDWORD(v26));
  if (v13 < 0) {
    int v14 = -1;
  }
  else {
    int v14 = v13;
  }
  v25[0] = v12;
  v25[1] = v14;
  int v15 = bswap32(v27);
  if (v15 < 0) {
    int v16 = -1;
  }
  else {
    int v16 = v15;
  }
  int v17 = bswap32(DWORD1(v27));
  if (v17 < 0) {
    int v18 = -1;
  }
  else {
    int v18 = v17;
  }
  v25[2] = v16;
  v25[3] = v18;
  int v19 = bswap32(DWORD2(v27));
  if (v19 < 0) {
    int v20 = -1;
  }
  else {
    int v20 = v19;
  }
  int v21 = bswap32(HIDWORD(v27));
  if (v21 < 0) {
    int v22 = -1;
  }
  else {
    int v22 = v21;
  }
  v25[4] = v20;
  v25[5] = v22;
  if (v7 < 0 || v9 < 0 || v11 < 0 || v13 < 0 || v15 < 0 || v17 < 0 || v19 < 0 || v21 < 0)
  {
    unsigned int v24 = "invalid values";
  }
  else
  {
    int v23 = *(__int16 *)(a1 + 1074);
    if (v23 < 0) {
      return;
    }
    if ((v23 & 0x10) == 0)
    {
      *(_WORD *)(a1 + 1074) = v23 | 0x10;
      png_colorspace_set_chromaticities((void (**)(void))a1, a1 + 1000, v25, 1);
      png_colorspace_sync(a1, a2);
      return;
    }
    *(_WORD *)(a1 + 1074) = v23 | 0x8000;
    png_colorspace_sync(a1, a2);
    unsigned int v24 = "duplicate";
  }
  png_chunk_benign_error(a1, v24);
}

void (**png_calloc(void (**a1)(void), size_t a2))(void)
{
  int v3 = png_malloc(a1, a2);
  int v4 = v3;
  if (v3) {
    bzero(v3, a2);
  }
  return v4;
}

uint64_t png_handle_zTXt(uint64_t a1, uint64_t a2, uint64_t size)
{
  int v6 = *(_DWORD *)(a1 + 884);
  if (!v6) {
    goto LABEL_8;
  }
  int v7 = v6 - 1;
  if (!v7)
  {
    return png_crc_finish(a1, size);
  }
  *(_DWORD *)(a1 + 884) = v7;
  if (v7 == 1)
  {
    png_crc_finish(a1, size);
    int v9 = "no space in chunk cache";
  }
  else
  {
LABEL_8:
    int v10 = *(_DWORD *)(a1 + 76);
    if ((v10 & 1) == 0) {
      png_chunk_error((void (**)(void))a1, "missing IHDR");
    }
    if ((v10 & 4) != 0) {
      *(_DWORD *)(a1 + 76) = v10 | 8;
    }
    buffer = (Bytef *)png_read_buffer(a1, size, 2);
    if (buffer)
    {
      int v12 = buffer;
      png_crc_read(a1, buffer, size);
      uint64_t result = png_crc_finish(a1, 0);
      if (result) {
        return result;
      }
      if (!size) {
        goto LABEL_19;
      }
      uint64_t v13 = 0;
      while (v12[v13])
      {
        if (size == ++v13)
        {
          LODWORD(v13) = size;
          break;
        }
      }
      if ((v13 - 80) >= 0xFFFFFFB1)
      {
        if ((int)v13 + 3 <= size)
        {
          if (v12[v13 + 1])
          {
            int v14 = "unknown compression type";
          }
          else
          {
            unint64_t v18 = -1;
            uint64_t result = png_decompress_chunk(a1, size, (int)v13 + 2, &v18);
            if (result == 1)
            {
              v17[0] = 0;
              uint64_t v15 = *(void *)(a1 + 936);
              if (v15)
              {
                unint64_t v16 = v18;
                *(unsigned char *)(v15 + v18 + (v13 + 2)) = 0;
                v17[1] = v15;
                v17[2] = v15 + v13 + 2;
                v17[3] = v16;
                memset(&v17[4], 0, 24);
                uint64_t result = png_set_text_2((void (**)(void))a1, a2, (uint64_t)v17, 1);
                if (result) {
                  int v14 = "insufficient memory";
                }
                else {
                  int v14 = 0;
                }
              }
              else
              {
                int v14 = "Read failure in png_handle_zTXt";
              }
            }
            else
            {
              int v14 = *(const char **)(a1 + 144);
            }
            if (!v14) {
              return result;
            }
          }
        }
        else
        {
          int v14 = "truncated";
        }
      }
      else
      {
LABEL_19:
        int v14 = "bad keyword";
      }
      return png_chunk_benign_error(a1, v14);
    }
    png_crc_finish(a1, size);
    int v9 = "out of memory";
  }

  return png_chunk_benign_error(a1, v9);
}

uint64_t IIOImageRead::getCGDataProviderBytesAtOffset(IIOImageRead *this, void *a2)
{
  uint64_t v2 = MEMORY[0x1F4188790](this, a2);
  uint64_t v4 = v3;
  uint64_t v6 = v5;
  uint64_t v7 = v2;
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  uint64_t v8 = CGAccessSessionCreate();
  if (v6)
  {
    if ((gIIODebugFlags & 0x800000) != 0) {
      ImageIOLog("    %s:%d:  dataProvider %p skip offset: 0x%08lX\n", "getCGDataProviderBytesAtOffset", 1305, *(const void **)(v7 + 40), v6);
    }
    if (*(void *)(v7 + 80) == -1)
    {
      bzero(v14, 0x2000uLL);
      uint64_t v11 = v6;
      do
      {
        uint64_t Bytes = CGAccessSessionGetBytes();
        v11 -= Bytes;
        if (Bytes) {
          BOOL v13 = v11 == 0;
        }
        else {
          BOOL v13 = 1;
        }
      }
      while (!v13);
      if (v11)
      {
        uint64_t v9 = 0;
        if (!v8) {
          return v9;
        }
        goto LABEL_9;
      }
    }
    else
    {
      CGAccessSessionSkipForward();
    }
  }
  if ((gIIODebugFlags & 0x800000) != 0) {
    ImageIOLog("    %s:%d:  dataProvider %p read offset: 0x%08lX   size: %8ld\n", "getCGDataProviderBytesAtOffset", 1328, *(const void **)(v7 + 40), v6, v4);
  }
  uint64_t v9 = CGAccessSessionGetBytes();
  if (v8) {
LABEL_9:
  }
    CGAccessSessionRelease();
  return v9;
}

uint64_t png_handle_tIME(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v4 = *(_DWORD *)(a1 + 76);
  if ((v4 & 1) == 0) {
    png_chunk_error((void (**)(void))a1, "missing IHDR");
  }
  if (a2 && (*(unsigned char *)(a2 + 9) & 2) != 0)
  {
    png_crc_finish(a1, a3);
    uint64_t v7 = "duplicate";
  }
  else
  {
    if ((v4 & 4) != 0) {
      *(_DWORD *)(a1 + 76) = v4 | 8;
    }
    if (a3 == 7)
    {
      *(_DWORD *)((char *)v9 + 3) = 0;
      v9[0] = 0;
      uint64_t v8 = 0;
      png_crc_read(a1, (Bytef *)v9, 7u);
      uint64_t result = png_crc_finish(a1, 0);
      if (!result)
      {
        BYTE6(v8) = BYTE2(v9[1]);
        *(_DWORD *)((char *)&v8 + 2) = *(_DWORD *)((char *)v9 + 2);
        LOWORD(v8) = bswap32(LOWORD(v9[0])) >> 16;
        return png_set_tIME(a1, a2, (uint64_t)&v8);
      }
      return result;
    }
    png_crc_finish(a1, a3);
    uint64_t v7 = "invalid";
  }

  return png_chunk_benign_error(a1, v7);
}

void _cg_png_error(void (**a1)(void), const char *a2)
{
  if (a1)
  {
    if (*a1) {
      (*a1)();
    }
  }
  png_default_error(a2);
}

uint64_t png_set_tIME(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (result && a2 && a3 && (*(unsigned char *)(result + 77) & 2) == 0)
  {
    if (*(unsigned __int8 *)(a3 + 2) - 13 >= 0xFFFFFFF4
      && *(unsigned __int8 *)(a3 + 3) - 32 >= 0xFFFFFFE1
      && *(unsigned __int8 *)(a3 + 4) <= 0x17u
      && *(unsigned __int8 *)(a3 + 5) <= 0x3Bu
      && *(unsigned __int8 *)(a3 + 6) < 0x3Du)
    {
      *(void *)(a2 + 168) = *(void *)a3;
      *(_DWORD *)(a2 + 8) |= 0x200u;
    }
    else
    {
      return png_warning(result, "Ignoring invalid time value");
    }
  }
  return result;
}

uint64_t EndElementHandler(uint64_t result, const char *a2)
{
  *(void *)(result + 168) -= 8;
  return result;
}

uint64_t CGImageSourceSetAllowableTypes(const void *a1)
{
  IIOInitDebugFlags();
  if ((unsigned __int16)gIIODebugFlags >> 14) {
    ImageIODebugOptions((unsigned __int16)gIIODebugFlags >> 14, "S", "CGImageSourceSetAllowableTypes", 0, 0, -1, 0);
  }

  return IIODecodingSetAllowableTypes(a1);
}

CFStringRef CGImageMetadataTagCopyPrefix(CGImageMetadataTagRef tag)
{
  IIOInitDebugFlags();
  if ((~(_WORD)gIIODebugFlags & 0x3000) == 0) {
    ImageIODebugOptions(3, "A", "CGImageMetadataTagCopyPrefix", 0, 0, -1, 0);
  }
  if (!tag) {
    return 0;
  }
  uint64_t v2 = *((void *)tag + 3);
  if (!v2) {
    return 0;
  }
  CFAllocatorRef v3 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFStringRef v4 = *(const __CFString **)(v2 + 24);

  return CFStringCreateCopy(v3, v4);
}

CFTypeRef CGImageMetadataTagCopyValue(CGImageMetadataTagRef tag)
{
  IIOInitDebugFlags();
  if ((~(_WORD)gIIODebugFlags & 0x3000) == 0) {
    ImageIODebugOptions(3, "A", "CGImageMetadataTagCopyValue", 0, 0, -1, 0);
  }
  if (!tag) {
    return 0;
  }
  uint64_t v2 = (IIOMetadata_Tag *)*((void *)tag + 3);
  if (!v2) {
    return 0;
  }

  return IIOMetadata_Tag::copyValue(v2);
}

IIO_Reader *CGImageSourceGetTypeWithData(const __CFData *a1, __CFString *a2, unsigned char *a3)
{
  IIOInitDebugFlags();
  uint64_t v6 = (IIO_ReaderHandler *)((unsigned __int16)gIIODebugFlags >> 14);
  if ((unsigned __int16)gIIODebugFlags >> 14) {
    ImageIODebugOptions((int)v6, "S", "CGImageSourceGetTypeWithData", 0, 0, -1, 0);
  }
  memset(v9, 0, sizeof(v9));
  ReaderHandler = (IIO_Reader ***)IIO_ReaderHandler::GetReaderHandler(v6);
  return IIO_ReaderHandler::typeForData(ReaderHandler, a1, a2, (uint64_t)v9, a3);
}

CFStringRef CGImageMetadataTagCopyName(CGImageMetadataTagRef tag)
{
  IIOInitDebugFlags();
  if ((~(_WORD)gIIODebugFlags & 0x3000) == 0) {
    ImageIODebugOptions(3, "A", "CGImageMetadataTagCopyName", 0, 0, -1, 0);
  }
  if (!tag) {
    return 0;
  }
  uint64_t v2 = *((void *)tag + 3);
  if (!v2) {
    return 0;
  }
  CFAllocatorRef v3 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFStringRef v4 = *(const __CFString **)(v2 + 32);

  return CFStringCreateCopy(v3, v4);
}

size_t CGImageSourceGetCount(CGImageSourceRef isrc)
{
  kdebug_trace();
  IIOInitDebugFlags();
  unsigned int v2 = (gIIODebugFlags >> 12) & 3;
  if (v2) {
    ImageIODebugOptions(v2, "A", "CGImageSourceGetCount", isrc, 0, -1, 0);
  }
  if (!isrc)
  {
    LogError("CGImageSourceGetCount", 4889, "*** ERROR: CGImageSourceGetCount: source is nil\n");
    goto LABEL_16;
  }
  CFTypeID v3 = CFGetTypeID(isrc);
  if (CGImageSourceGetTypeID::once != -1) {
    dispatch_once(&CGImageSourceGetTypeID::once, &__block_literal_global_164);
  }
  if (v3 != CGImageSourceGetTypeID::id)
  {
    LogError("CGImageSourceGetCount", 4890, "*** ERROR: CGImageSourceGetCount: source is not a CGImageSourceRef\n");
LABEL_20:
    isrc = 0;
    goto LABEL_16;
  }
  uint64_t v4 = *((void *)isrc + 3);
  if (!v4)
  {
    isrc = 0;
    goto LABEL_16;
  }
  if (*(unsigned char *)(v4 + 89))
  {
    LogError("CGImageSourceGetCount", 4895, "*** ERROR: invalid CGImageSourceRef (non-matching hint)\n");
    goto LABEL_20;
  }
  pthread_mutex_lock((pthread_mutex_t *)(v4 + 224));
  if (IIOImageSource::isProxy((IIOImageSource *)v4)) {
    Count = (CGImageSource *)IIOImageSource::proxyGetCount((IIODictionary **)v4);
  }
  else {
    Count = (CGImageSource *)IIOImageSource::updatedCount((IIOImageSource *)v4);
  }
  isrc = Count;
  uint64_t v6 = *(IIO_Reader **)(v4 + 104);
  if (v6) {
    IIO_Reader::osType(v6);
  }
  pthread_mutex_unlock((pthread_mutex_t *)(v4 + 224));
LABEL_16:
  kdebug_trace();
  return (size_t)isrc;
}

CFStringRef CGImageMetadataTagCopyNamespace(CGImageMetadataTagRef tag)
{
  IIOInitDebugFlags();
  if ((~(_WORD)gIIODebugFlags & 0x3000) == 0) {
    ImageIODebugOptions(3, "A", "CGImageMetadataTagCopyNamespace", 0, 0, -1, 0);
  }
  if (!tag) {
    return 0;
  }
  uint64_t v2 = *((void *)tag + 3);
  if (!v2) {
    return 0;
  }
  CFAllocatorRef v3 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFStringRef v4 = *(const __CFString **)(v2 + 16);

  return CFStringCreateCopy(v3, v4);
}

CFDictionaryRef CGImageSourceCopyPropertiesAtIndex(CGImageSourceRef isrc, size_t index, CFDictionaryRef options)
{
  kdebug_trace();
  IIOInitDebugFlags();
  unsigned int v6 = (gIIODebugFlags >> 12) & 3;
  if (v6) {
    ImageIODebugOptions(v6, "A", "CGImageSourceCopyPropertiesAtIndex", isrc, 0, index, options);
  }
  if (isrc)
  {
    CFTypeID v7 = CFGetTypeID(isrc);
    if (CGImageSourceGetTypeID::once != -1) {
      dispatch_once(&CGImageSourceGetTypeID::once, &__block_literal_global_164);
    }
    if (v7 == CGImageSourceGetTypeID::id)
    {
      if (options)
      {
        CFTypeID v8 = CFGetTypeID(options);
        if (v8 != CFDictionaryGetTypeID())
        {
          LogError("CGImageSourceCopyPropertiesAtIndex", 5295, "*** ERROR: CGImageSourceCopyPropertiesAtIndex: options parameter is not a CFDictionaryRef - ignoring\n");
          options = 0;
        }
      }
      uint64_t v9 = *((void *)isrc + 3);
      if (v9)
      {
        if (*(unsigned char *)(v9 + 89))
        {
          LogError("CGImageSourceCopyPropertiesAtIndex", 5302, "*** ERROR: invalid CGImageSourceRef (non-matching hint)\n");
        }
        else
        {
          CFDictionaryRef v15 = 0;
          uint64_t v16 = 0;
          uint64_t v17 = 0;
          IIODictionary::IIODictionary((IIODictionary *)&v15, options);
          int v10 = (pthread_mutex_t *)(v9 + 224);
          pthread_mutex_lock((pthread_mutex_t *)(v9 + 224));
          uint64_t v11 = *(IIO_Reader **)(v9 + 104);
          if (v11) {
            IIO_Reader::osType(v11);
          }
          if (IIOImageSource::isProxy((IIOImageSource *)v9)) {
            CFDictionaryRef v12 = (const __CFDictionary *)IIOImageSource::proxyCopyPropertiesAtIndex((IIOImageSource *)v9, index, (IIODictionary *)&v15);
          }
          else {
            CFDictionaryRef v12 = (const __CFDictionary *)IIOImageSource::copyPropertiesAtIndex((IIOImageSource *)v9, index, &v15);
          }
          CFDictionaryRef v13 = v12;
          pthread_mutex_unlock(v10);
          IIODictionary::~IIODictionary((IIODictionary *)&v15);
          if (v13)
          {
            CFDictionaryRef v15 = 0;
            uint64_t v16 = 0;
            uint64_t v17 = 0;
            IIODictionary::IIODictionary((IIODictionary *)&v15, v13);
            IIOPackSrcInputInfo((IIODictionary *)&v15, index);
            IIODictionary::getCount((IIODictionary *)&v15);
            IIODictionary::~IIODictionary((IIODictionary *)&v15);
            goto LABEL_25;
          }
        }
      }
    }
    else
    {
      LogError("CGImageSourceCopyPropertiesAtIndex", 5292, "*** ERROR: CGImageSourceCopyPropertiesAtIndex: source is not a CGImageSourceRef\n");
    }
  }
  else
  {
    LogError("CGImageSourceCopyPropertiesAtIndex", 5291, "*** ERROR: CGImageSourceCopyPropertiesAtIndex: source is nil\n");
  }
  if ((gIIODebugFlags & 0x800000000000) != 0) {
    ImageIOLog(" ISSUE: %s:%d:  %s\n", "CGImageSourceCopyPropertiesAtIndex", 5324, "could not create CFDictionaryRef");
  }
  CFDictionaryRef v13 = 0;
LABEL_25:
  kdebug_trace();
  return v13;
}

void sub_188594564(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  IIODictionary::~IIODictionary((IIODictionary *)va);
  _Unwind_Resume(a1);
}

uint64_t IIOArrayEnumerateUsingBlock(uint64_t result, uint64_t a2)
{
  if (result)
  {
    CFArrayRef v3 = (const __CFArray *)result;
    CFTypeID v4 = CFGetTypeID((CFTypeRef)result);
    uint64_t result = CFArrayGetTypeID();
    if (v4 == result)
    {
      uint64_t result = CFArrayGetCount(v3);
      char v9 = 0;
      uint64_t v5 = result - 1;
      if (result >= 1)
      {
        CFIndex v6 = 0;
        do
        {
          ValueAtIndex = CFArrayGetValueAtIndex(v3, v6);
          uint64_t result = (*(uint64_t (**)(uint64_t, const void *, CFIndex, char *))(a2 + 16))(a2, ValueAtIndex, v6, &v9);
          if (v9) {
            BOOL v8 = 1;
          }
          else {
            BOOL v8 = v5 == v6;
          }
          ++v6;
        }
        while (!v8);
      }
    }
  }
  return result;
}

void ___ZN17IIO_ReaderHandler15buildPluginListEv_block_invoke(uint64_t a1, const __CFDictionary *a2)
{
  memset(v2, 0, sizeof(v2));
  IIODictionary::IIODictionary((IIODictionary *)v2, a2);
  if (IIODictionary::getBoolForKey((IIODictionary *)v2, @"IsPreTiff")) {
    operator new();
  }
  IIODictionary::~IIODictionary((IIODictionary *)v2);
}

void sub_188594780(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12)
{
}

void ___ZN17IIO_ReaderHandler15buildPluginListEv_block_invoke_2(uint64_t a1, const __CFDictionary *a2)
{
  memset(v2, 0, sizeof(v2));
  IIODictionary::IIODictionary((IIODictionary *)v2, a2);
  if (!IIODictionary::getBoolForKey((IIODictionary *)v2, @"IsPreTiff")) {
    operator new();
  }
  IIODictionary::~IIODictionary((IIODictionary *)v2);
}

void sub_18859491C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12)
{
}

void IIODictionary::IIODictionary(IIODictionary *this, CFTypeRef cf)
{
  *(void *)this = &unk_1ED4DFD78;
  if (cf)
  {
    CFTypeID v4 = CFGetTypeID(cf);
    if (v4 == CFDictionaryGetTypeID())
    {
      CFTypeRef v5 = CFRetain(cf);
      char v6 = 0;
      *((void *)this + 1) = v5;
    }
    else
    {
      IIOLogTypeMismatch(cf, "IIODictionary", "CFDictionaryRef");
      char v6 = 0;
      *((void *)this + 1) = 0;
    }
  }
  else
  {
    *((void *)this + 1) = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    char v6 = 1;
  }
  *((unsigned char *)this + 16) = v6;
}

{
  CFTypeID v4;
  void *Mutable;
  char v6;

  *(void *)this = &unk_1ED4DFD78;
  if (cf)
  {
    CFTypeID v4 = CFGetTypeID(cf);
    if (v4 != CFDictionaryGetTypeID())
    {
      IIOLogTypeMismatch(cf, "IIODictionary", "CFDictionaryRef");
      char v6 = 0;
      *((void *)this + 1) = 0;
      goto LABEL_7;
    }
    Mutable = (void *)CFRetain(cf);
  }
  else
  {
    Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  }
  *((void *)this + 1) = Mutable;
  char v6 = 1;
LABEL_7:
  *((unsigned char *)this + 16) = v6;
}

void IIOReader_RawCamera::IIOReader_RawCamera(IIOReader_RawCamera *this, IIODictionary *a2)
{
  IIO_Reader::IIO_Reader(this);
  void *v4 = &unk_1ED4E4C60;
  if (a2)
  {
    *((unsigned char *)this + 48) = 1;
    CFDictionaryRef ObjectForKey = IIODictionary::getObjectForKey(a2, @"UTType");
    *((void *)this + 7) = ObjectForKey;
    CFRetain(ObjectForKey);
    *((void *)this + 1) = (char *)this + 56;
    CFDictionaryRef v6 = IIODictionary::getObjectForKey(a2, @"Extensions");
    *((void *)this + 8) = v6;
    CFRetain(v6);
    *((void *)this + 2) = CFStringGetCStringPtr(*((CFStringRef *)this + 8), 0x8000100u);
    *((_DWORD *)this + 6) = 1380013856;
    *((void *)this + 4) = IIODictionary::getUint32ForKey(a2, @"TestHeaderSize");
    *((void *)this + 5) = IIODictionary::getUint32ForKey(a2, @"MinimumFileSize");
    *((void *)this + 9) = IIODictionary::getUint64ForKey(a2, @"TestHeaderProc");
    *((void *)this + 10) = IIODictionary::getUint64ForKey(a2, @"AddSourcePropsProc");
    *((void *)this + 11) = IIODictionary::getUint64ForKey(a2, @"ImageCountProc");
    *((void *)this + 12) = IIODictionary::getUint64ForKey(a2, @"CompareOptsProc");
    *((void *)this + 13) = IIODictionary::getUint64ForKey(a2, @"InitImageProc");
    *((void *)this + 14) = IIODictionary::getUint64ForKey(a2, @"InitThumbnailProc");
    *((void *)this + 15) = IIODictionary::getUint64ForKey(a2, @"CopyAuxiliaryDataProc");
    IIOReader_RawCamera::createRAWOSType((uint64_t)this);
  }
}

void sub_188594BD4(_Unwind_Exception *a1, uint64_t a2, const char *a3)
{
  _cg_jpeg_mem_term(v3, a2, a3);
  _Unwind_Resume(a1);
}

uint64_t IIODictionary::getUint64FromValue(IIODictionary *this, const __CFString *cf)
{
  uint64_t valuePtr = 0;
  if (!cf) {
    return 0;
  }
  CFTypeID v3 = CFGetTypeID(cf);
  if (v3 == CFNumberGetTypeID())
  {
    CFNumberGetValue((CFNumberRef)cf, kCFNumberSInt64Type, &valuePtr);
    return valuePtr;
  }
  CFTypeID v5 = CFGetTypeID(cf);
  if (v5 == CFStringGetTypeID()) {
    return CFStringGetIntValue(cf);
  }
  else {
    return 0;
  }
}

const __CFDictionary *IIODictionary::getUint64ForKey(IIODictionary *this, const __CFString *a2)
{
  CFDictionaryRef result = (const __CFDictionary *)*((void *)this + 1);
  if (result)
  {
    Value = (IIODictionary *)CFDictionaryGetValue(result, a2);
    return (const __CFDictionary *)IIODictionary::getUint64FromValue(Value, (const __CFString *)Value);
  }
  return result;
}

uint64_t IIOReader_RawCamera::createRAWOSType(uint64_t this)
{
  int v1 = 1380003888;
  int v2 = gRawIndex;
  unsigned int v3 = gRawIndex % 0x5Au;
  if (gRawIndex % 0x5Au >= 0xA)
  {
    unsigned int v4 = gRawIndex - v3;
    unsigned int v5 = (gRawIndex - 10 - v4) / 0xA;
    int v1 = (v5 << 8) + 1380004144;
    unsigned int v3 = gRawIndex - 10 - 10 * v5 - v4;
  }
  *(_DWORD *)(this + 24) = v1 + v3;
  gRawIndex = v2 + 1;
  return this;
}

void IIO_Reader::IIO_Reader(IIO_Reader *this)
{
  *((void *)this + 1) = 0;
  *((void *)this + 2) = 0;
  *(void *)this = &unk_1ED4DE470;
  *((_DWORD *)this + 6) = 538976288;
  *((void *)this + 4) = 0;
  *((void *)this + 5) = 0;
  *((unsigned char *)this + 48) = 0;
}

void IIOImageSource::getCacheValues(IIOImageSource *this, IIODictionary *a2, BOOL *a3, BOOL *a4)
{
  unsigned __int8 v7 = IIODictionary::containsKey(a2, @"kCGImageSourceShouldCache");
  unsigned __int8 v8 = IIODictionary::containsKey(a2, @"kCGImageSourceShouldCacheImmediately");
  BOOL BoolForKey = IIODictionary::getBoolForKey(a2, @"kCGImageSourceShouldCache");
  BOOL v10 = IIODictionary::getBoolForKey(a2, @"kCGImageSourceShouldCacheImmediately");
  if ((gIIODebugFlags & 0x20000000) != 0)
  {
    if (IIOImageSource::getCacheValues(IIODictionary *,BOOL *,BOOL *)::__onceToken != -1) {
      dispatch_once(&IIOImageSource::getCacheValues(IIODictionary *,BOOL *,BOOL *)::__onceToken, &__block_literal_global_3);
    }
    unsigned int v11 = (gIIODebugFlags >> 30) & 1;
  }
  else
  {
    LOBYTE(v11) = v7 ^ 1 | BoolForKey;
  }
  *a3 = v11;
  *a4 = v8 & v10;
}

uint64_t IIOSkipMetadata(IIODictionary *a1)
{
  uint64_t v2 = IIOMetadataParsingEnabledFlag() ^ 1;
  if (a1 && IIODictionary::getBoolForKey(a1, @"kCGImageSourceSkipMetadata"))
  {
    if ((gIIODebugFlags & 0x4000000000000) != 0 && IIO_OSAppleInternalBuild()) {
      ImageIOLog("   kCGImageSourceSkipMetadata --> handle minimum metadata only\n");
    }
    return 1;
  }
  return v2;
}

BOOL IIODictionary::getBoolFromValue(IIODictionary *this, const __CFString *cf)
{
  if (!cf) {
    return 0;
  }
  CFTypeID v3 = CFGetTypeID(cf);
  if (v3 == CFBooleanGetTypeID()) {
    return *MEMORY[0x1E4F1CFD0] == (void)cf;
  }
  CFTypeID v5 = CFGetTypeID(cf);
  if (v5 == CFNumberGetTypeID())
  {
    char valuePtr = 0;
    CFNumberGetValue((CFNumberRef)cf, kCFNumberSInt8Type, &valuePtr);
    BOOL v6 = valuePtr == 0;
    return !v6;
  }
  CFTypeID v7 = CFGetTypeID(cf);
  if (v7 != CFStringGetTypeID()) {
    return 0;
  }
  uint64_t v4 = 1;
  if (CFStringCompare(cf, @"true", 1uLL) == kCFCompareEqualTo) {
    return v4;
  }
  if (CFStringCompare(cf, @"false", 1uLL) == kCFCompareEqualTo) {
    return 0;
  }
  BOOL v6 = CFStringGetIntValue(cf) == 0;
  return !v6;
}

BOOL IIODictionary::getBoolForKey(IIODictionary *this, const __CFString *a2)
{
  if (!a2) {
    return 0;
  }
  CFDictionaryRef v2 = (const __CFDictionary *)*((void *)this + 1);
  if (!v2) {
    return 0;
  }
  Value = (IIODictionary *)CFDictionaryGetValue(v2, a2);

  return IIODictionary::getBoolFromValue(Value, (const __CFString *)Value);
}

uint64_t IIOMetadataParsingEnabledFlag()
{
  return (gPermissions >> 2) & 1;
}

uint64_t IIOPackSrcInputInfo(IIODictionary *a1, unsigned __int16 a2)
{
  if (a1)
  {
    if (IIODictionary::containsKey(a1, @"kCGImageSourceCreateThumbnailFromImageAlways"))
    {
      if (IIODictionary::getBoolForKey(a1, @"kCGImageSourceCreateThumbnailFromImageAlways")) {
        unint64_t v4 = 0x4000000000000000;
      }
      else {
        unint64_t v4 = 0;
      }
    }
    else
    {
      unint64_t v4 = 0x8000000000000000;
    }
    if (IIODictionary::containsKey(a1, @"kCGImageSourceCreateThumbnailFromImageIfAbsent"))
    {
      if (IIODictionary::getBoolForKey(a1, @"kCGImageSourceCreateThumbnailFromImageIfAbsent")) {
        v4 |= 0x1000000000000000uLL;
      }
    }
    else
    {
      v4 |= 0x2000000000000000uLL;
    }
    if (IIODictionary::containsKey(a1, @"kCGImageSourceCreateThumbnailWithTransform"))
    {
      if (IIODictionary::getBoolForKey(a1, @"kCGImageSourceCreateThumbnailWithTransform")) {
        v4 |= 0x400000000000000uLL;
      }
    }
    else
    {
      v4 |= 0x800000000000000uLL;
    }
    unint64_t v6 = v4 | (((unint64_t)IIODictionary::getUint32ForKey(a1, @"Orientation") & 0xF) << 54);
    unint64_t v7 = v6 | (((unint64_t)IIODictionary::getUint32ForKeyGroup(a1, @"Orientation", @"{TIFF}") & 0xF) << 50);
    if (IIODictionary::containsKey(a1, @"kCGImageSourceSubsampleFactor")) {
      unint64_t v8 = ((unint64_t)IIODictionary::getUint32ForKey(a1, @"kCGImageSourceSubsampleFactor") & 0x3F) << 44;
    }
    else {
      unint64_t v8 = 0x3F00000000000;
    }
    unint64_t v9 = v7 | v8;
    if (IIODictionary::containsKey(a1, @"kCGImageSourceDecodeRequest"))
    {
      CFStringRef ObjectForKey = (const __CFString *)IIODictionary::getObjectForKey(a1, @"kCGImageSourceDecodeRequest");
      if (CFStringCompare(ObjectForKey, @"kCGImageSourceDecodeToHDR", 0)) {
        unint64_t v11 = (unint64_t)(CFEqual(ObjectForKey, @"kCGImageSourceDecodeToSDR")) << 41;
      }
      else {
        unint64_t v11 = 0x10000000000;
      }
      unint64_t v13 = v11 | v9;
      if (IIODictionary::containsKeyGroup(a1, @"kCGGenerateFlexGTC", @"kCGImageSourceDecodeRequestOptions"))
      {
        if (IIODictionary::getBoolForKeyGroup(a1, @"kCGGenerateFlexGTC", @"kCGImageSourceDecodeRequestOptions"))uint64_t v12 = v13 | 0x4000000000; {
        else
        }
          uint64_t v12 = v13;
      }
      else
      {
        uint64_t v12 = v13 | 0x8000000000;
      }
    }
    else
    {
      uint64_t v12 = v9 | 0xF8000000000;
    }
    unsigned int Uint32ForKey = IIODictionary::getUint32ForKey(a1, @"kCGImageSourceThumbnailMaxPixelSize");
    if (!Uint32ForKey) {
      unsigned int Uint32ForKey = IIODictionary::getUint32ForKey(a1, @"kCGImageDestinationImageMaxPixelSize");
    }
    uint64_t v5 = v12 | (Uint32ForKey << 16);
  }
  else
  {
    uint64_t v5 = 0;
  }
  return v5 | a2;
}

uint64_t IIODictionary::getUint32FromValue(IIODictionary *this, const __CFString *cf)
{
  unsigned int valuePtr = 0;
  if (!cf) {
    return 0;
  }
  CFTypeID v3 = CFGetTypeID(cf);
  if (v3 == CFNumberGetTypeID())
  {
    CFNumberGetValue((CFNumberRef)cf, kCFNumberSInt32Type, &valuePtr);
    return valuePtr;
  }
  CFTypeID v5 = CFGetTypeID(cf);
  if (v5 != CFStringGetTypeID()) {
    return 0;
  }

  return CFStringGetIntValue(cf);
}

const __CFDictionary *IIODictionary::getUint32ForKey(IIODictionary *this, const __CFString *a2)
{
  CFDictionaryRef result = (const __CFDictionary *)*((void *)this + 1);
  if (result)
  {
    Value = (IIODictionary *)CFDictionaryGetValue(result, a2);
    return (const __CFDictionary *)IIODictionary::getUint32FromValue(Value, (const __CFString *)Value);
  }
  return result;
}

CFDictionaryRef XMPMappingIteratePropertiesUsingBlock(IIODictionary *this, uint64_t a2)
{
  char v13 = 0;
  if (this && !IIODictionary::containsKey(this, @"{Exif}"))
  {
LABEL_7:
    CFDictionaryRef result = IIODictionary::containsKey(this, @"{ExifAux}");
    if (result)
    {
LABEL_8:
      uint64_t v6 = 0;
      while (1)
      {
        CFDictionaryRef result = (const __CFDictionary *)(*(uint64_t (**)(uint64_t, __CFString ***, char *))(a2 + 16))(a2, &legacyToXMPArrayExifAux[v6], &v13);
        if (v13) {
          break;
        }
        v6 += 5;
        if (v6 == 50)
        {
          if (this) {
            goto LABEL_14;
          }
          goto LABEL_15;
        }
      }
    }
    else if (!v13)
    {
LABEL_14:
      CFDictionaryRef result = IIODictionary::containsKey(this, @"{GPS}");
      if (result)
      {
LABEL_15:
        uint64_t v7 = 0;
        while (1)
        {
          CFDictionaryRef result = (const __CFDictionary *)(*(uint64_t (**)(uint64_t, __CFString ***, char *))(a2 + 16))(a2, &legacyToXMPArrayGPS[v7], &v13);
          if (v13) {
            break;
          }
          v7 += 5;
          if (v7 == 160)
          {
            if (this) {
              goto LABEL_21;
            }
            goto LABEL_22;
          }
        }
      }
      else if (!v13)
      {
LABEL_21:
        CFDictionaryRef result = IIODictionary::containsKey(this, @"{TIFF}");
        if (result)
        {
LABEL_22:
          uint64_t v8 = 0;
          while (1)
          {
            CFDictionaryRef result = (const __CFDictionary *)(*(uint64_t (**)(uint64_t, __CFString ***, char *))(a2 + 16))(a2, &legacyToXMPArrayTIFF[v8], &v13);
            if (v13) {
              break;
            }
            v8 += 5;
            if (v8 == 110)
            {
              if (this) {
                goto LABEL_28;
              }
              goto LABEL_29;
            }
          }
        }
        else if (!v13)
        {
LABEL_28:
          CFDictionaryRef result = IIODictionary::containsKey(this, @"{PNG}");
          if (result)
          {
LABEL_29:
            uint64_t v9 = 0;
            while (1)
            {
              CFDictionaryRef result = (const __CFDictionary *)(*(uint64_t (**)(uint64_t, __CFString ***, char *))(a2 + 16))(a2, &legacyToXMPArrayPNG[v9], &v13);
              if (v13) {
                break;
              }
              v9 += 5;
              if (v9 == 30)
              {
                if (this) {
                  goto LABEL_35;
                }
                goto LABEL_36;
              }
            }
          }
          else if (!v13)
          {
LABEL_35:
            CFDictionaryRef result = IIODictionary::containsKey(this, @"{IPTC}");
            if (result)
            {
LABEL_36:
              BOOL v10 = legacyToXMPArrayIPTC;
              uint64_t v11 = 212;
              do
              {
                CFDictionaryRef result = (const __CFDictionary *)(*(uint64_t (**)(uint64_t, __CFString ***, char *))(a2 + 16))(a2, v10, &v13);
                if (v13) {
                  BOOL v12 = 1;
                }
                else {
                  BOOL v12 = v11 == 0;
                }
                --v11;
                v10 += 5;
              }
              while (!v12);
            }
          }
        }
      }
    }
  }
  else
  {
    uint64_t v4 = 0;
    while (1)
    {
      CFDictionaryRef result = (const __CFDictionary *)(*(uint64_t (**)(uint64_t, __CFString ***, char *))(a2 + 16))(a2, &legacyToXMPArrayExif[v4], &v13);
      if (v13) {
        break;
      }
      v4 += 5;
      if (v4 == 400)
      {
        if (!this) {
          goto LABEL_8;
        }
        goto LABEL_7;
      }
    }
  }
  return result;
}

void __CGImagePropertiesCreateFromMetadata_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v145 = 0;
  uint64_t v146 = 0;
  double v144 = 0.0;
  CFDictionaryRef TopLevelTag = CGImageMetadataGetTopLevelTag(*(const __CFDictionary **)(a1 + 40), **(void **)(a2 + 24), **(void **)(a2 + 32));
  if (!TopLevelTag)
  {
    int v11 = *(unsigned __int16 *)(a2 + 16);
    if (v11 == 16)
    {
      CFDictionaryRef TopLevelTag = CGImageMetadataGetTopLevelTag(*(const __CFDictionary **)(a1 + 40), **(void **)(a2 + 24), @"GPSTime");
      if (TopLevelTag) {
        goto LABEL_2;
      }
      int v11 = *(unsigned __int16 *)(a2 + 16);
    }
    if (v11 != 15) {
      return;
    }
    CFDictionaryRef TopLevelTag = CGImageMetadataGetTopLevelTag(*(const __CFDictionary **)(a1 + 40), **(void **)(a2 + 24), @"GPSDate");
    if (!TopLevelTag) {
      return;
    }
  }
LABEL_2:
  uint64_t Source = CGImageSourceGetSource((uint64_t)TopLevelTag);
  if (Source)
  {
    uint64_t v6 = *(__CFString **)(Source + 48);
    if (!v6)
    {
      CFStringGetCStringPtr(**(CFStringRef **)(a2 + 24), 0);
      CFStringGetCStringPtr(**(CFStringRef **)(a2 + 32), 0);
      LogMetadata("CGImagePropertiesCreateFromMetadata_block_invoke", 1589, "Tag with namespace = %s, name = %s, has a NULL value\n");
      return;
    }
    int v7 = *(unsigned __int16 *)(a2 + 16);
    CFStringRef v8 = **(const __CFString ***)(a2 + 8);
    switch(*(_WORD *)(a2 + 16))
    {
      case 0:
        if (GetIntegerFromPropertyValue(*(const __CFString **)(Source + 48), (SInt32 *)&v146 + 1))
        {
          uint64_t v9 = *(IIODictionary **)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
          IIONumber::IIONumber((IIONumber *)v143, SHIDWORD(v146));
          IIODictionary::setObjectForKeyGroup(v9, (uint64_t)v143, v8, **(const __CFString ***)a2);
          BOOL v10 = (IIONumber *)v143;
          goto LABEL_120;
        }
        return;
      case 1:
        if (GetDoubleFromPropertyValue(*(const __CFString **)(Source + 48), &v144))
        {
          uint64_t v32 = *(IIODictionary **)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
          IIONumber::IIONumber((IIONumber *)v141, v144);
          IIODictionary::setObjectForKeyGroup(v32, (uint64_t)v141, v8, **(const __CFString ***)a2);
          BOOL v10 = (IIONumber *)v141;
          goto LABEL_120;
        }
        return;
      case 2:
        DefaultString = CGImageMetadataGetDefaultString(*(const void **)(Source + 48));
        if (DefaultString)
        {
          int v34 = DefaultString;
          IIODictionary::setObjectForKeyGroup(*(IIODictionary **)(*(void *)(*(void *)(a1 + 32) + 8) + 24), DefaultString, v8, **(const __CFString ***)a2);
          if (CFEqual(**(CFStringRef **)(a2 + 24), @"http://purl.org/dc/elements/1.1/")
            && CFEqual(**(CFStringRef **)(a2 + 32), @"rights"))
          {
            uint64_t v35 = *(IIODictionary **)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
            IIODictionary::setObjectForKeyGroup(v35, v34, @"Copyright", @"{TIFF}");
          }
        }
        return;
      case 3:
        CFStringRef EXIFDataTimeStringWithXMPDateTimeString = CreateEXIFDataTimeStringWithXMPDateTimeString(*(const __CFString **)(Source + 48));
        if (EXIFDataTimeStringWithXMPDateTimeString) {
          goto LABEL_106;
        }
        return;
      case 4:
        CFMutableArrayRef v138 = 0;
        v139 = 0;
        v140 = 0;
        IIOArray::IIOArray((IIOArray *)&v138);
        CFTypeID v15 = CFGetTypeID(v6);
        if (v15 == CFArrayGetTypeID())
        {
          *(void *)v135 = 0;
          v136 = 0;
          uint64_t v137 = 0;
          uint64_t v16 = IIOArray::IIOArray((IIOArray *)v135, (const __CFArray *)v6);
          unsigned int Count = IIOArray::getCount(v16);
          if (Count)
          {
            CFIndex v18 = 0;
            uint64_t v19 = Count;
            do
            {
              CFArrayRef ObjectAtIndex = IIOArray::getObjectAtIndex((IIOArray *)v135, v18);
              CFStringRef v21 = (const __CFString *)CGImageMetadataGetDefaultString(ObjectAtIndex);
              if (v21)
              {
                HIDWORD(v146) = CFStringGetIntValue(v21);
                IIONumber::IIONumber((IIONumber *)v134, SHIDWORD(v146));
                IIOArray::addObject(&v138, (uint64_t)v134);
                IIONumber::~IIONumber((IIONumber *)v134);
              }
              ++v18;
            }
            while (v19 != v18);
          }
          IIOArray::~IIOArray((IIOArray *)v135);
        }
        else
        {
          CFTypeID v83 = CFGetTypeID(v6);
          if (v83 == CFStringGetTypeID())
          {
            *(void *)v135 = 0;
            v136 = 0;
            uint64_t v137 = 0;
            int v84 = IIOString::IIOString((IIOString *)v135, v6);
            v85 = (const char *)IIOString::utf8String(v84);
            char v86 = strdup(v85);
            for (uint64_t i = strtok(v86, ";"); i; uint64_t i = strtok(0, ";"))
            {
              sscanf(i, "%d", (char *)&v146 + 4);
              IIONumber::IIONumber((IIONumber *)v133, SHIDWORD(v146));
              IIOArray::addObject(&v138, (uint64_t)v133);
              IIONumber::~IIONumber((IIONumber *)v133);
            }
            free(v86);
            IIOString::~IIOString((IIOString *)v135);
          }
        }
        IIODictionary::setObjectForKeyGroup(*(IIODictionary **)(*(void *)(*(void *)(a1 + 32) + 8) + 24), v139, v8, **(const __CFString ***)a2);
        goto LABEL_152;
      case 5:
        CFMutableArrayRef v138 = 0;
        v139 = 0;
        v140 = 0;
        IIOArray::IIOArray((IIOArray *)&v138);
        CFTypeID v37 = CFGetTypeID(v6);
        if (v37 == CFArrayGetTypeID())
        {
          *(void *)v135 = 0;
          v136 = 0;
          uint64_t v137 = 0;
          uint64_t v38 = IIOArray::IIOArray((IIOArray *)v135, (const __CFArray *)v6);
          unsigned int v39 = IIOArray::getCount(v38);
          if (v39)
          {
            CFIndex v40 = 0;
            uint64_t v41 = v39;
            do
            {
              CFArrayRef v42 = IIOArray::getObjectAtIndex((IIOArray *)v135, v40);
              CFStringRef v43 = (const __CFString *)CGImageMetadataGetDefaultString(v42);
              if (v43 && GetDoubleFromPropertyValue(v43, &v144))
              {
                float v44 = v144;
                IIONumber::IIONumber((IIONumber *)v132, v44);
                IIOArray::addObject(&v138, (uint64_t)v132);
                IIONumber::~IIONumber((IIONumber *)v132);
              }
              ++v40;
            }
            while (v41 != v40);
            IIODictionary::setObjectForKeyGroup(*(IIODictionary **)(*(void *)(*(void *)(a1 + 32) + 8) + 24), v139, v8, **(const __CFString ***)a2);
          }
          IIOArray::~IIOArray((IIOArray *)v135);
        }
        else
        {
          CFTypeID v88 = CFGetTypeID(v6);
          if (v88 == CFStringGetTypeID())
          {
            *(void *)v135 = 0;
            v136 = 0;
            uint64_t v137 = 0;
            v89 = IIOString::IIOString((IIOString *)v135, v6);
            v90 = (const char *)IIOString::utf8String(v89);
            v91 = strdup(v90);
            for (j = strtok(v91, ";"); j; j = strtok(0, ";"))
            {
              if (sscanf(j, "%d/%d", (char *)&v146 + 4, &v146) == 1)
              {
                IIONumber::IIONumber((IIONumber *)v131, SHIDWORD(v146));
                v93 = (IIONumber *)v131;
                IIOArray::addObject(&v138, (uint64_t)v131);
              }
              else
              {
                if (v146) {
                  double v94 = (double)SHIDWORD(v146) / (double)(int)v146;
                }
                else {
                  double v94 = 0.0;
                }
                double v144 = v94;
                IIONumber::IIONumber((IIONumber *)v130, v94);
                v93 = (IIONumber *)v130;
                IIOArray::addObject(&v138, (uint64_t)v130);
              }
              IIONumber::~IIONumber(v93);
            }
            free(v91);
            IIODictionary::setObjectForKeyGroup(*(IIODictionary **)(*(void *)(*(void *)(a1 + 32) + 8) + 24), v139, v8, **(const __CFString ***)a2);
            IIOString::~IIOString((IIOString *)v135);
          }
        }
        goto LABEL_152;
      case 6:
        if (!GetMajorVersionFromPropertyValue(*(const __CFString **)(Source + 48), (SInt32 *)&v146 + 1)) {
          return;
        }
        CFMutableArrayRef v138 = 0;
        v139 = 0;
        v140 = 0;
        IIOArray::IIOArray((IIOArray *)&v138);
        IIONumber::IIONumber((IIONumber *)v129, SHIDWORD(v146));
        IIOArray::addObject(&v138, (uint64_t)v129);
        IIONumber::~IIONumber((IIONumber *)v129);
        IIODictionary::setObjectForKeyGroup(*(IIODictionary **)(*(void *)(*(void *)(a1 + 32) + 8) + 24), v139, v8, **(const __CFString ***)a2);
        if (GetMinorVersionFromPropertyValue(v6, (SInt32 *)&v146 + 1))
        {
          IIONumber::IIONumber((IIONumber *)v128, SHIDWORD(v146));
          IIOArray::addObject(&v138, (uint64_t)v128);
          IIONumber::~IIONumber((IIONumber *)v128);
          if (GetRevisionVersionFromPropertyValue(v6, (SInt32 *)&v146 + 1))
          {
            if (HIDWORD(v146))
            {
              IIONumber::IIONumber((IIONumber *)v127, SHIDWORD(v146));
              IIOArray::addObject(&v138, (uint64_t)v127);
              IIONumber::~IIONumber((IIONumber *)v127);
            }
          }
        }
        goto LABEL_152;
      case 7:
        CFMutableArrayRef v138 = 0;
        v139 = 0;
        v140 = 0;
        IIOArray::IIOArray((IIOArray *)&v138);
        CFTypeID v45 = CFGetTypeID(v6);
        if (v45 == CFArrayGetTypeID())
        {
          *(void *)v135 = 0;
          v136 = 0;
          uint64_t v137 = 0;
          char v46 = IIOArray::IIOArray((IIOArray *)v135, (const __CFArray *)v6);
          unsigned int v47 = IIOArray::getCount(v46);
          if (v47)
          {
            CFIndex v48 = 0;
            uint64_t v49 = v47;
            do
            {
              CFArrayRef v50 = IIOArray::getObjectAtIndex((IIOArray *)v135, v48);
              unsigned __int8 v51 = CGImageMetadataGetDefaultString(v50);
              IIOArray::addObject(&v138, v51);
              ++v48;
            }
            while (v49 != v48);
          }
LABEL_145:
          IIOArray::~IIOArray((IIOArray *)v135);
          goto LABEL_150;
        }
        CFTypeID v95 = CFGetTypeID(v6);
        if (v95 == CFStringGetTypeID())
        {
          CFArrayRef ArrayBySeparatingStrings = CFStringCreateArrayBySeparatingStrings((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v6, @"; ");
          if (!ArrayBySeparatingStrings) {
            goto LABEL_150;
          }
          *(void *)v135 = 0;
          v136 = 0;
          uint64_t v137 = 0;
          v97 = IIOArray::IIOArray((IIOArray *)v135, ArrayBySeparatingStrings);
          unsigned int v98 = IIOArray::getCount(v97);
          if (v98)
          {
            CFIndex v99 = 0;
            uint64_t v100 = v98;
            do
            {
              CFArrayRef v101 = IIOArray::getObjectAtIndex((IIOArray *)v135, v99);
              IIOArray::addObject(&v138, v101);
              ++v99;
            }
            while (v100 != v99);
          }
          CFRelease(ArrayBySeparatingStrings);
          goto LABEL_145;
        }
        CStringPtr = CFStringGetCStringPtr(**(CFStringRef **)(a2 + 24), 0);
        v104 = CFStringGetCStringPtr(**(CFStringRef **)(a2 + 32), 0);
        LogMetadata("CGImagePropertiesCreateFromMetadata_block_invoke", 1791, " Unexpected CFType found for schema = %s, property = %s\n", CStringPtr, v104);
LABEL_150:
        if (IIOArray::getCount((IIOArray *)&v138)) {
          IIODictionary::setObjectForKeyGroup(*(IIODictionary **)(*(void *)(*(void *)(a1 + 32) + 8) + 24), v139, v8, **(const __CFString ***)a2);
        }
LABEL_152:
        IIOArray::~IIOArray((IIOArray *)&v138);
        return;
      case 8:
        CFStringRef EXIFDataTimeStringWithXMPDateTimeString = CreateIPTCDateStringWithXMPDateTimeString(*(const __CFString **)(Source + 48));
        if (!EXIFDataTimeStringWithXMPDateTimeString) {
          return;
        }
        goto LABEL_106;
      case 9:
        CFStringRef EXIFDataTimeStringWithXMPDateTimeString = CreateIPTCTimeStringWithXMPDateTimeString(*(const __CFString **)(Source + 48));
        if (!EXIFDataTimeStringWithXMPDateTimeString) {
          return;
        }
        goto LABEL_106;
      case 0xA:
        CFTypeID v52 = CFGetTypeID(*(CFTypeRef *)(Source + 48));
        if (v52 != CFStringGetTypeID()) {
          return;
        }
        CFArrayRef v53 = CFStringCreateArrayBySeparatingStrings((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v6, @" ");
        if (!v53) {
          return;
        }
        CFArrayRef v54 = v53;
        CFMutableArrayRef v138 = 0;
        v139 = 0;
        v140 = 0;
        int v55 = IIOArray::IIOArray((IIOArray *)&v138, v53);
        LODWORD(v56) = IIOArray::getCount(v55);
        if (v56)
        {
          *(void *)v135 = 0;
          v136 = 0;
          uint64_t v137 = 0;
          IIOArray::IIOArray((IIOArray *)v135);
          CFIndex v57 = 0;
          if (v56 >= 4) {
            uint64_t v56 = 4;
          }
          else {
            uint64_t v56 = v56;
          }
          do
          {
            CFStringRef v58 = (const __CFString *)IIOArray::getObjectAtIndex((IIOArray *)&v138, v57);
            if (GetDoubleFromPropertyValue(v58, &v144))
            {
              IIONumber::IIONumber((IIONumber *)v125, v144);
              IIOArray::addObject((CFMutableArrayRef *)v135, v126);
              IIONumber::~IIONumber((IIONumber *)v125);
            }
            ++v57;
          }
          while (v56 != v57);
          IIODictionary::setObjectForKeyGroup(*(IIODictionary **)(*(void *)(*(void *)(a1 + 32) + 8) + 24), v136, v8, **(const __CFString ***)a2);
          IIOArray::~IIOArray((IIOArray *)v135);
        }
        CFRelease(v54);
        goto LABEL_152;
      case 0xB:
        CFTypeID v22 = CFGetTypeID(*(CFTypeRef *)(Source + 48));
        if (v22 == CFDictionaryGetTypeID())
        {
          CFMutableArrayRef v138 = 0;
          v139 = 0;
          v140 = 0;
          IIODictionary::IIODictionary((IIODictionary *)&v138);
          *(void *)v135 = 0;
          v136 = 0;
          uint64_t v137 = 0;
          IIODictionary::IIODictionary((IIODictionary *)v135, (const __CFDictionary *)v6);
          if ((atomic_load_explicit((atomic_uchar *volatile)&_ZGVZZ35CGImagePropertiesCreateFromMetadataEUb_E4keys, memory_order_acquire) & 1) == 0&& __cxa_guard_acquire(&_ZGVZZ35CGImagePropertiesCreateFromMetadataEUb_E4keys))
          {
            _ZZZ35CGImagePropertiesCreateFromMetadataEUb_E4keys = @"CiAdrCity";
            *(void *)algn_1E90FF598 = @"CiAdrCity";
            qword_1E90FF5A0 = @"CiAdrCtry";
            unk_1E90FF5A8 = @"CiAdrCtry";
            qword_1E90FF5B0 = @"CiAdrExtadr";
            unk_1E90FF5B8 = @"CiAdrExtadr";
            qword_1E90FF5C0 = @"CiAdrPcode";
            unk_1E90FF5C8 = @"CiAdrPcode";
            qword_1E90FF5D0 = @"CiAdrRegion";
            unk_1E90FF5D8 = @"CiAdrRegion";
            qword_1E90FF5E0 = @"CiEmailWork";
            unk_1E90FF5E8 = @"CiEmailWork";
            qword_1E90FF5F0 = @"CiTelWork";
            unk_1E90FF5F8 = @"CiTelWork";
            qword_1E90FF600 = @"CiUrlWork";
            unk_1E90FF608 = @"CiUrlWork";
            qword_1E90FF610 = 0;
            unk_1E90FF618 = 0;
            __cxa_guard_release(&_ZGVZZ35CGImagePropertiesCreateFromMetadataEUb_E4keys);
          }
          CFStringRef v23 = (const __CFString *)_ZZZ35CGImagePropertiesCreateFromMetadataEUb_E4keys;
          if (_ZZZ35CGImagePropertiesCreateFromMetadataEUb_E4keys)
          {
            unsigned int v24 = &qword_1E90FF5A0;
            do
            {
              CFDictionaryRef ObjectForKey = IIODictionary::getObjectForKey((IIODictionary *)v135, v23);
              CFDictionaryRef v26 = ObjectForKey;
              if (ObjectForKey && CGImageMetadataGetDefaultString(ObjectForKey))
              {
                long long v27 = CGImageMetadataGetDefaultString(v26);
                IIODictionary::setObjectForKey((IIODictionary *)&v138, v27, (const __CFString *)*(v24 - 1));
              }
              CFStringRef v28 = (const __CFString *)*v24;
              v24 += 2;
              CFStringRef v23 = v28;
            }
            while (v28);
          }
          IIODictionary::setObjectForKeyGroup(*(IIODictionary **)(*(void *)(*(void *)(a1 + 32) + 8) + 24), v139, v8, **(const __CFString ***)a2);
          IIODictionary::~IIODictionary((IIODictionary *)v135);
          IIODictionary::~IIODictionary((IIODictionary *)&v138);
        }
        return;
      case 0xC:
        CFStringRef EXIFDataTimeStringWithXMPDateTimeString = (const __CFString *)CreateRegionFromPropertyValue(*(const void **)(Source + 48));
        if (!EXIFDataTimeStringWithXMPDateTimeString) {
          return;
        }
        goto LABEL_106;
      case 0xD:
        CFTypeID v59 = CFGetTypeID(*(CFTypeRef *)(Source + 48));
        if (v59 == CFArrayGetTypeID())
        {
          CFAllocatorRef v60 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
          CFIndex v61 = CFArrayGetCount((CFArrayRef)v6);
          CFMutableArrayRef Mutable = CFArrayCreateMutable(v60, v61, MEMORY[0x1E4F1D510]);
          if (Mutable)
          {
            unint64_t v63 = Mutable;
            if (CFArrayGetCount((CFArrayRef)v6) >= 1)
            {
              CFIndex v64 = 0;
              do
              {
                ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)v6, v64);
                int v66 = CGImageMetadataGetDefaultString(ValueAtIndex);
                if (v66) {
                  CFArrayAppendValue(v63, v66);
                }
                ++v64;
              }
              while (v64 < CFArrayGetCount((CFArrayRef)v6));
            }
            CFStringRef v67 = CFStringCreateByCombiningStrings(v60, v63, @"; ");
            if (v67)
            {
              CFStringRef v68 = v67;
              IIODictionary::setObjectForKeyGroup(*(IIODictionary **)(*(void *)(*(void *)(a1 + 32) + 8) + 24), v67, v8, **(const __CFString ***)a2);
              CFRelease(v68);
            }
            uint64_t v69 = v63;
LABEL_108:
            CFRelease(v69);
          }
        }
        else
        {
          CFStringGetCStringPtr(**(CFStringRef **)a2, 0);
          CFStringGetCStringPtr(v8, 0);
          LogMetadata("CGImagePropertiesCreateFromMetadata_block_invoke", 1940, "{%s}:%s has type kLegacyTypeSemicolonString, expected a CFArray as its XMP value, but got %d\n");
        }
        return;
      case 0xE:
        int IntFromXMPFlashStruct = CreateIntFromXMPFlashStruct(*(const void **)(Source + 48));
        uint64_t v30 = *(IIODictionary **)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
        IIONumber::IIONumber((IIONumber *)v124, IntFromXMPFlashStruct);
        IIODictionary::setObjectForKeyGroup(v30, (uint64_t)v124, v8, **(const __CFString ***)a2);
        BOOL v10 = (IIONumber *)v124;
        goto LABEL_120;
      case 0xF:
        CFStringRef EXIFDataTimeStringWithXMPDateTimeString = CreateGPSDateStringWithXMPDateTimeString(*(const __CFString **)(Source + 48));
        if (!EXIFDataTimeStringWithXMPDateTimeString) {
          return;
        }
        goto LABEL_106;
      case 0x10:
        CFStringRef GPSTimeStringWithXMPDateTimeString = CreateGPSTimeStringWithXMPDateTimeString(*(const __CFString **)(Source + 48));
        if (!GPSTimeStringWithXMPDateTimeString)
        {
          CFStringRef GPSTimeStringWithXMPDateTimeString = CGImageMetadataCopyStringValueWithPath(*(CGImageMetadataRef *)(a1 + 40), 0, @"exif:GPSTime");
          if (!GPSTimeStringWithXMPDateTimeString) {
            return;
          }
        }
        goto LABEL_107;
      case 0x11:
        *(_WORD *)v135 = 0;
        if (!GetLegacyGPSFromXMPGPSCoordinate(v6, &v144, v135)) {
          return;
        }
        uint64_t v70 = *(IIODictionary **)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
        IIONumber::IIONumber((IIONumber *)v123, v144);
        IIODictionary::setObjectForKeyGroup(v70, (uint64_t)v123, v8, **(const __CFString ***)a2);
        IIONumber::~IIONumber((IIONumber *)v123);
        v135[1] = 0;
        __int16 v71 = **(__CFString ***)(a2 + 8);
        if (v71 == @"Latitude")
        {
          if (!v135[0])
          {
            v105 = CGImageMetadataCopyTagWithPath(*(CGImageMetadataRef *)(a1 + 40), 0, @"exif:GPSLatitudeRef");
            if (v105)
            {
              v106 = v105;
              CFTypeRef v107 = CGImageMetadataTagCopyValue(v105);
              if (v107)
              {
                v108 = v107;
                CFTypeID TypeID = CFStringGetTypeID();
                if (TypeID == CFGetTypeID(v108))
                {
                  v110 = *(IIODictionary **)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
                  v111 = (const __CFString **)&kCGImagePropertyGPSLatitudeRef;
LABEL_164:
                  IIODictionary::setObjectForKeyGroup(v110, v108, *v111, @"{GPS}");
                  CFRelease(v108);
                  CFRelease(v106);
                  return;
                }
                CFRelease(v108);
              }
              CFRelease(v106);
            }
            if (v144 < 0.0) {
              char v117 = 83;
            }
            else {
              char v117 = 78;
            }
            v135[0] = v117;
          }
          v118 = *(IIODictionary **)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
          IIOString::IIOString((IIOString *)&v138, v135);
          IIODictionary::setObjectForKeyGroup(v118, v140, @"LatitudeRef", @"{GPS}");
        }
        else
        {
          if (v71 != @"Longitude")
          {
            if (v71 == @"DestLatitude")
            {
              if (!v135[0])
              {
                if (v144 < 0.0) {
                  char v115 = 83;
                }
                else {
                  char v115 = 78;
                }
                v135[0] = v115;
              }
              v116 = *(IIODictionary **)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
              IIOString::IIOString((IIOString *)&v138, v135);
              IIODictionary::setObjectForKeyGroup(v116, v140, @"DestLatitudeRef", @"{GPS}");
            }
            else
            {
              if (v71 != @"DestLongitude") {
                return;
              }
              if (!v135[0])
              {
                if (v144 < 0.0) {
                  char v72 = 87;
                }
                else {
                  char v72 = 69;
                }
                v135[0] = v72;
              }
              __int16 v73 = *(IIODictionary **)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
              IIOString::IIOString((IIOString *)&v138, v135);
              IIODictionary::setObjectForKeyGroup(v73, v140, @"DestLongitudeRef", @"{GPS}");
            }
            goto LABEL_185;
          }
          if (!v135[0])
          {
            v112 = CGImageMetadataCopyTagWithPath(*(CGImageMetadataRef *)(a1 + 40), 0, @"exif:GPSLongitudeRef");
            if (v112)
            {
              v106 = v112;
              CFTypeRef v113 = CGImageMetadataTagCopyValue(v112);
              if (v113)
              {
                v108 = v113;
                CFTypeID v114 = CFStringGetTypeID();
                if (v114 == CFGetTypeID(v108))
                {
                  v110 = *(IIODictionary **)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
                  v111 = (const __CFString **)&kCGImagePropertyGPSLongitudeRef;
                  goto LABEL_164;
                }
                CFRelease(v108);
              }
              CFRelease(v106);
            }
            if (v144 < 0.0) {
              char v119 = 87;
            }
            else {
              char v119 = 69;
            }
            v135[0] = v119;
          }
          v120 = *(IIODictionary **)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
          IIOString::IIOString((IIOString *)&v138, v135);
          IIODictionary::setObjectForKeyGroup(v120, v140, @"LongitudeRef", @"{GPS}");
        }
LABEL_185:
        IIOString::~IIOString((IIOString *)&v138);
        return;
      case 0x12:
        CFStringRef EXIFDataTimeStringWithXMPDateTimeString = (const __CFString *)CreateGPSVersionArrayFromString(*(const __CFString **)(Source + 48));
        if (!EXIFDataTimeStringWithXMPDateTimeString) {
          return;
        }
LABEL_106:
        CFStringRef GPSTimeStringWithXMPDateTimeString = EXIFDataTimeStringWithXMPDateTimeString;
LABEL_107:
        IIODictionary::setObjectForKeyGroup(*(IIODictionary **)(*(void *)(*(void *)(a1 + 32) + 8) + 24), GPSTimeStringWithXMPDateTimeString, v8, **(const __CFString ***)a2);
        uint64_t v69 = GPSTimeStringWithXMPDateTimeString;
        goto LABEL_108;
      case 0x13:
        IIODictionary::removeObjectForKeyGroup(*(IIODictionary **)(*(void *)(*(void *)(a1 + 32) + 8) + 24), @"ISOSpeedRatings", @"{Exif}");
        CFMutableArrayRef v138 = 0;
        v139 = 0;
        v140 = 0;
        IIOArray::IIOArray((IIOArray *)&v138);
        CFTypeID v74 = CFGetTypeID(v6);
        if (v74 == CFArrayGetTypeID())
        {
          *(void *)v135 = 0;
          v136 = 0;
          uint64_t v137 = 0;
          int v75 = IIOArray::IIOArray((IIOArray *)v135, (const __CFArray *)v6);
          unsigned int v76 = IIOArray::getCount(v75);
          if (v76)
          {
            CFIndex v77 = 0;
            uint64_t v78 = v76;
            do
            {
              CFArrayRef v79 = IIOArray::getObjectAtIndex((IIOArray *)v135, v77);
              CFStringRef v80 = (const __CFString *)CGImageMetadataGetDefaultString(v79);
              if (v80)
              {
                HIDWORD(v146) = CFStringGetIntValue(v80);
                IIONumber::IIONumber((IIONumber *)v122, SHIDWORD(v146));
                IIOArray::addObject(&v138, (uint64_t)v122);
                IIONumber::~IIONumber((IIONumber *)v122);
              }
              ++v77;
            }
            while (v78 != v77);
          }
          IIOArray::~IIOArray((IIOArray *)v135);
        }
        else
        {
          CFTypeID v102 = CFGetTypeID(v6);
          if (v102 == CFStringGetTypeID())
          {
            HIDWORD(v146) = CFStringGetIntValue(v6);
            IIONumber::IIONumber((IIONumber *)v121, SHIDWORD(v146));
            IIOArray::addObject(&v138, (uint64_t)v121);
            IIONumber::~IIONumber((IIONumber *)v121);
          }
        }
        IIODictionary::setObjectForKeyGroup(*(IIODictionary **)(*(void *)(*(void *)(a1 + 32) + 8) + 24), v139, v8, **(const __CFString ***)a2);
        goto LABEL_152;
      case 0x14:
        if (GetLongLongFromPropertyValue(*(const __CFString **)(Source + 48), &v145))
        {
          char v81 = *(IIODictionary **)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
          IIONumber::IIONumber((IIONumber *)v142, v145);
          IIODictionary::setObjectForKeyGroup(v81, (uint64_t)v142, v8, **(const __CFString ***)a2);
          BOOL v10 = (IIONumber *)v142;
LABEL_120:
          IIONumber::~IIONumber(v10);
        }
        return;
      case 0x15:
        CFTypeID v82 = CFGetTypeID(*(CFTypeRef *)(Source + 48));
        if (v82 == CFArrayGetTypeID()) {
          operator new();
        }
        return;
      default:
        if (v7 != 98)
        {
          int v12 = *(unsigned __int16 *)(a2 + 18);
          char v13 = CFStringGetCStringPtr(**(CFStringRef **)a2, 0);
          int v14 = CFStringGetCStringPtr(**(CFStringRef **)(a2 + 8), 0);
          _cg_jpeg_mem_term("CGImagePropertiesCreateFromMetadata_block_invoke", 2156, "Unhandled conversion from tag type (%d) to property type (%d) for {%s}:%s\n", v12, v7, v13, v14);
        }
        return;
    }
  }
}

void sub_188596978(_Unwind_Exception *a1)
{
  IIOString::~IIOString((IIOString *)(v1 - 200));
  _Unwind_Resume(a1);
}

CFDictionaryRef CGImageMetadataGetTopLevelTag(const __CFDictionary *result, uint64_t a2, uint64_t a3)
{
  if (result)
  {
    CFDictionaryRef result = (const __CFDictionary *)*((void *)result + 3);
    if (result)
    {
      key[1] = a3;
      key[2] = 0;
      key[0] = a2;
      return (const __CFDictionary *)CFDictionaryGetValue(result, key);
    }
  }
  return result;
}

const __CFDictionary *IIODictionary::containsKey(IIODictionary *this, const __CFString *a2)
{
  CFDictionaryRef result = (const __CFDictionary *)*((void *)this + 1);
  if (result) {
    return (const __CFDictionary *)(CFDictionaryContainsKey(result, a2) != 0);
  }
  return result;
}

void __CGImageMetadataCreateFromLegacyProps_block_invoke(uint64_t a1, uint64_t a2)
{
  values[3] = *(void **)MEMORY[0x1E4F143B8];
  CFIndex v64 = 0;
  uint64_t v4 = **(const void ***)(a2 + 8);
  CFDictionaryRef ObjectForKey = IIODictionary::getObjectForKey(*(IIODictionary **)(a1 + 40), **(const __CFString ***)a2);
  if (!ObjectForKey) {
    return;
  }
  CFDictionaryRef v6 = ObjectForKey;
  CFTypeID v7 = CFGetTypeID(ObjectForKey);
  if (v7 != CFDictionaryGetTypeID())
  {
    CFTypeID v8 = CFGetTypeID(v6);
    if (v8 != CFNullGetTypeID()) {
      return;
    }
  }
  if (!*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24))
  {
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = CGImageMetadataCreateMutable();
    if (!*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24))
    {
      exception = __cxa_allocate_exception(4uLL);
      _DWORD *exception = -1;
      __cxa_throw(exception, MEMORY[0x1E4FBA3A8], 0);
    }
  }
  CFTypeID v9 = CFGetTypeID(v6);
  if (v9 == CFNullGetTypeID())
  {
    CGImageMetadataType v10 = kCGImageMetadataTypeDefault;
    CFStringRef ArrayFromCFValue = (const __CFString *)*MEMORY[0x1E4F1D260];
LABEL_66:
    if (ArrayFromCFValue)
    {
      CFArrayRef v50 = CGImageMetadataDefaultPrefixForNamespace(**(const __CFString ***)(a2 + 24));
      CGImageMetadataTagRef v51 = CGImageMetadataTagCreate(**(CFStringRef **)(a2 + 24), v50, **(CFStringRef **)(a2 + 32), v10, ArrayFromCFValue);
      if (v51)
      {
        if (CFStringCompare(**(CFStringRef **)a2, @"{IPTC}", 0)) {
          int v52 = 2;
        }
        else {
          int v52 = 4;
        }
        CGImageMetadataTagSetSource((uint64_t)v51, v52);
        CGImageMetadataAddTag(*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24), v51);
        CFRelease(v51);
      }
      CFRelease(ArrayFromCFValue);
      return;
    }
  }
  else
  {
    Value = (__CFString *)CFDictionaryGetValue(v6, v4);
    if (Value)
    {
      int v13 = *(unsigned __int16 *)(a2 + 18);
      CFStringRef v14 = Value;
      switch(*(_WORD *)(a2 + 18))
      {
        case 0:
          uint64_t v15 = 4;
          goto LABEL_24;
        case 1:
          uint64_t v15 = 3;
LABEL_24:
          CFStringRef SimpleStringFromCFValue = CGImageMetadataCreateSimpleStringFromCFValue(Value, v15);
          goto LABEL_64;
        case 2:
          CFStringRef ArrayFromCFValue = (const __CFString *)CreateArrayFromCFValue(Value, *(unsigned __int16 *)(a2 + 16));
          CGImageMetadataType v10 = kCGImageMetadataTypeArrayUnordered;
          goto LABEL_66;
        case 3:
          CFStringRef ArrayFromCFValue = (const __CFString *)CreateArrayFromCFValue(Value, *(unsigned __int16 *)(a2 + 16));
          CGImageMetadataType v10 = kCGImageMetadataTypeArrayOrdered;
          goto LABEL_66;
        case 4:
          StructureFromCFValue = CreateStructureFromCFValue(Value);
          goto LABEL_13;
        case 5:
          CFAllocatorRef v28 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
          v29 = CGImageMetadataDefaultPrefixForNamespace(**(const __CFString ***)(a2 + 24));
          CFStringRef ArrayFromCFValue = CFStringCreateWithFormat(v28, 0, @"%@:%@[x-default]", v29, **(void **)(a2 + 32));
          if (!ArrayFromCFValue) {
            break;
          }
          CGImageMetadataSetValueWithPath(*(CGMutableImageMetadataRef *)(*(void *)(*(void *)(a1 + 32) + 8) + 24), 0, ArrayFromCFValue, v14);
          CFRelease(ArrayFromCFValue);
          goto LABEL_35;
        case 6:
          CFStringRef SimpleStringFromCFValue = CreateShortXMPDateFromIPTCDate(Value);
          goto LABEL_64;
        case 7:
          CFStringRef SimpleStringFromCFValue = CreateMetadataVersionStringFromArray(Value);
          goto LABEL_64;
        case 8:
          CFArrayRef v30 = CreateMetadataLensInfoFromCFValue((const __CFArray *)Value, &v64);
          CFStringRef ArrayFromCFValue = (const __CFString *)v30;
          CGImageMetadataType v10 = kCGImageMetadataTypeString;
          if (v64 == 4 || !v30) {
            goto LABEL_66;
          }
          CFRelease(v30);
          goto LABEL_41;
        case 9:
          memset(values, 0, 24);
          IIODictionary::IIODictionary((IIODictionary *)values, (const __CFDictionary *)Value);
          AddMWGRegionsFromExifAuxRegions(*(CGImageMetadata **)(*(void *)(*(void *)(a1 + 32) + 8) + 24), (IIODictionary *)values);
          IIODictionary::~IIODictionary((IIODictionary *)values);
LABEL_35:
          LOBYTE(ArrayFromCFValue) = 1;
          break;
        case 0xA:
          CFAllocatorRef v31 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
          uint64_t v32 = CGImageMetadataDefaultPrefixForNamespace(**(const __CFString ***)(a2 + 24));
          CFStringRef v33 = CFStringCreateWithFormat(v31, 0, @"%@:%@", v32, **(void **)(a2 + 32));
          if (!v33) {
            goto LABEL_41;
          }
          CFStringRef v34 = v33;
          CGImageMetadataTagRef v35 = CGImageMetadataCopyTagWithPath(*(CGImageMetadataRef *)(*(void *)(*(void *)(a1 + 32) + 8) + 24), 0, v33);
          if (v35)
          {
            CGImageMetadataTagRef v36 = v35;
            CFStringRef v37 = (const __CFString *)CGImageMetadataTagGetValue((uint64_t)v35);
            CFStringRef ArrayFromCFValue = 0;
            uint64_t v38 = (__CFString *)v37;
            switch(*(_WORD *)(a2 + 16))
            {
              case 8:
                XMPDateFromIPTCDateAndTime = CreateXMPDateFromIPTCDateAndTime(v14, 0);
                if (!XMPDateFromIPTCDateAndTime) {
                  goto LABEL_91;
                }
                CFIndex v40 = XMPDateFromIPTCDateAndTime;
                CFStringRef v41 = v38;
                goto LABEL_85;
              case 9:
                CFTypeID v59 = CreateXMPDateFromIPTCDateAndTime(0, v14);
                if (v59)
                {
                  CFIndex v40 = v59;
                  XMPDateFromIPTCDateAndTime = v38;
                  CFStringRef v41 = v40;
LABEL_85:
                  CFStringRef ArrayFromCFValue = CreateMergedXMPDateWithXMPTime(XMPDateFromIPTCDateAndTime, v41);
                  CFRelease(v40);
                }
                else
                {
LABEL_91:
                  CFStringRef ArrayFromCFValue = 0;
                }
                break;
              case 0xF:
                CFStringRef v37 = v14;
                CFStringRef v60 = v38;
                goto LABEL_88;
              case 0x10:
                CFStringRef v60 = v14;
LABEL_88:
                CFStringRef ArrayFromCFValue = CreateMergedXMPDateWithXMPTime(v37, v60);
                break;
              default:
                break;
            }
            CFRelease(v36);
          }
          else
          {
            CFStringRef ArrayFromCFValue = 0;
            switch(*(_WORD *)(a2 + 16))
            {
              case 8:
                CFStringRef v61 = v14;
                CFStringRef v62 = 0;
                goto LABEL_95;
              case 9:
                CFStringRef v61 = 0;
                CFStringRef v62 = v14;
LABEL_95:
                CFStringRef XMPDateTimeFromEXIFDateTime = CreateXMPDateFromIPTCDateAndTime(v61, v62);
                goto LABEL_96;
              case 0xA:
              case 0xB:
              case 0xC:
              case 0xD:
              case 0xE:
                break;
              case 0xF:
              case 0x10:
                CFStringRef XMPDateTimeFromEXIFDateTime = (const __CFString *)CFRetain(v14);
                goto LABEL_96;
              default:
                if (*(_WORD *)(a2 + 16) != 3) {
                  break;
                }
                CFStringRef XMPDateTimeFromEXIFDateTime = CreateXMPDateTimeFromEXIFDateTime(v14);
LABEL_96:
                CFStringRef ArrayFromCFValue = XMPDateTimeFromEXIFDateTime;
                break;
            }
          }
          CFRelease(v34);
          goto LABEL_65;
        case 0xB:
          StructureFromCFValue = CreateXMPFlashStructFromCFValue((__CFDictionary *)Value);
LABEL_13:
          CFStringRef ArrayFromCFValue = (const __CFString *)StructureFromCFValue;
          CGImageMetadataType v10 = kCGImageMetadataTypeStructure;
          goto LABEL_66;
        case 0xC:
          uint64_t v17 = **(__CFString ***)(a2 + 8);
          if (v17 == @"Longitude")
          {
            int v18 = 0;
            CFTypeID v45 = (const __CFString **)&kCGImagePropertyGPSLongitudeRef;
          }
          else if (v17 == @"DestLongitude")
          {
            int v18 = 0;
            CFTypeID v45 = (const __CFString **)&kCGImagePropertyGPSDestLongitudeRef;
          }
          else if (v17 == @"Latitude")
          {
            int v18 = 1;
            CFTypeID v45 = (const __CFString **)&kCGImagePropertyGPSLatitudeRef;
          }
          else
          {
            int v18 = 1;
            if (v17 != @"DestLatitude")
            {
              CFStringRef ObjectForKeyGroup = 0;
              goto LABEL_63;
            }
            CFTypeID v45 = (const __CFString **)&kCGImagePropertyGPSDestLatitudeRef;
          }
          CFStringRef ObjectForKeyGroup = (const __CFString *)IIODictionary::getObjectForKeyGroup(*(IIODictionary **)(a1 + 40), *v45, @"{GPS}");
LABEL_63:
          CFStringRef SimpleStringFromCFValue = CreateXMPGPSCoordinateFromCFValue(v14, ObjectForKeyGroup, v18);
LABEL_64:
          CFStringRef ArrayFromCFValue = SimpleStringFromCFValue;
LABEL_65:
          CGImageMetadataType v10 = kCGImageMetadataTypeString;
          goto LABEL_66;
        case 0xD:
          CFStringRef SimpleStringFromCFValue = (const __CFString *)CreateGPSVersionStringFromArray((const __CFArray *)Value);
          goto LABEL_64;
        case 0xE:
          CFTypeID v20 = CFGetTypeID(Value);
          if (v20 == CFArrayGetTypeID() && CFArrayGetCount((CFArrayRef)v14) >= 1)
          {
            CGImageMetadataTagRef v21 = CGImageMetadataTagCreate(@"http://ns.adobe.com/exif/1.0/", @"exif", @"ISOSpeedRatings", kCGImageMetadataTypeArrayOrdered, v14);
            ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)v14, 0);
            CGImageMetadataTagRef v23 = CGImageMetadataTagCreate(@"http://cipa.jp/exif/1.0/", @"exifEX", @"PhotographicSensitivity", kCGImageMetadataTypeString, ValueAtIndex);
          }
          else
          {
            CFTypeID v42 = CFGetTypeID(v14);
            if (v42 != CFStringGetTypeID())
            {
              CFTypeID v43 = CFGetTypeID(v14);
              if (v43 != CFNumberGetTypeID())
              {
                char v49 = 0;
                BOOL v48 = 0;
                goto LABEL_59;
              }
            }
            values[0] = (void *)v14;
            CFArrayRef v44 = CFArrayCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const void **)values, 1, MEMORY[0x1E4F1D510]);
            if (v44)
            {
              CGImageMetadataTagRef v21 = CGImageMetadataTagCreate(@"http://ns.adobe.com/exif/1.0/", @"exif", @"ISOSpeedRatings", kCGImageMetadataTypeArrayOrdered, v44);
              CFRelease(v44);
            }
            else
            {
              CGImageMetadataTagRef v21 = 0;
            }
            CGImageMetadataTagRef v23 = CGImageMetadataTagCreate(@"http://cipa.jp/exif/1.0/", @"exifEX", @"PhotographicSensitivity", kCGImageMetadataTypeString, v14);
          }
          CGImageMetadataTagRef v47 = v23;
          BOOL v48 = v21 != 0;
          if (v21)
          {
            CGImageMetadataTagSetSource((uint64_t)v21, 2);
            CGImageMetadataAddTag(*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24), v21);
            CFRelease(v21);
          }
          if (v47)
          {
            CGImageMetadataTagSetSource((uint64_t)v47, 2);
            CGImageMetadataAddTag(*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24), v47);
            CFRelease(v47);
            char v49 = 1;
          }
          else
          {
            char v49 = 0;
          }
LABEL_59:
          LOBYTE(ArrayFromCFValue) = v49 & v48;
          break;
        default:
          int v24 = *(unsigned __int16 *)(a2 + 16);
          CStringPtr = CFStringGetCStringPtr(**(CFStringRef **)a2, 0);
          CFDictionaryRef v26 = CFStringGetCStringPtr(**(CFStringRef **)(a2 + 8), 0);
          LogMetadata("CGImageMetadataCreateFromLegacyProps_block_invoke", 1182, "Unhandled conversion from property type (%d) to tag type (%d) for {%s}:%s\n", v24, v13, CStringPtr, v26);
          goto LABEL_41;
      }
    }
    else
    {
LABEL_41:
      LOBYTE(ArrayFromCFValue) = 0;
    }
  }
  CFArrayRef v53 = CGImageMetadataDefaultPrefixForNamespace(**(const __CFString ***)(a2 + 24));
  CFStringRef v54 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"%@:%@", v53, **(void **)(a2 + 32));
  if (v54)
  {
    TagWithPath = CGImageMetadataGetTagWithPath(*(void **)(*(void *)(*(void *)(a1 + 32) + 8) + 24), 0, v54);
    if (TagWithPath)
    {
      if (CFStringCompare(**(CFStringRef **)a2, @"{IPTC}", 0)) {
        int v56 = 2;
      }
      else {
        int v56 = 4;
      }
      CGImageMetadataTagSetSource((uint64_t)TagWithPath, v56);
    }
    CFRelease(v54);
  }
  if ((ArrayFromCFValue & 1) == 0)
  {
    CFIndex v57 = CFStringGetCStringPtr(**(CFStringRef **)(a2 + 24), 0);
    CFStringRef v58 = CFStringGetCStringPtr(**(CFStringRef **)(a2 + 32), 0);
    LogMetadata("CGImageMetadataCreateFromLegacyProps_block_invoke", 1246, "Unable to create a tag for schema = %s, property = %s\n", v57, v58);
  }
}

void sub_1885974C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  IIODictionary::~IIODictionary((IIODictionary *)va);
  _Unwind_Resume(a1);
}

const __CFDictionary *IIODictionary::getObjectForKey(IIODictionary *this, const __CFString *a2)
{
  CFDictionaryRef result = (const __CFDictionary *)*((void *)this + 1);
  if (result) {
    return (const __CFDictionary *)CFDictionaryGetValue(result, a2);
  }
  return result;
}

__CFString *CGImageMetadataDefaultPrefixForNamespace(const __CFString *a1)
{
  if (CFEqual(a1, @"http://ns.adobe.com/exif/1.0/"))
  {
    CFDictionaryRef v2 = (__CFString **)&kCGImageMetadataPrefixExif;
    goto LABEL_27;
  }
  if (CFEqual(a1, @"http://ns.adobe.com/tiff/1.0/"))
  {
    CFDictionaryRef v2 = (__CFString **)&kCGImageMetadataPrefixTIFF;
    goto LABEL_27;
  }
  if (CFEqual(a1, @"http://ns.adobe.com/xap/1.0/"))
  {
    CFDictionaryRef v2 = (__CFString **)&kCGImageMetadataPrefixXMPBasic;
    goto LABEL_27;
  }
  if (CFEqual(a1, @"http://purl.org/dc/elements/1.1/"))
  {
    CFDictionaryRef v2 = (__CFString **)&kCGImageMetadataPrefixDublinCore;
    goto LABEL_27;
  }
  if (CFEqual(a1, @"http://ns.adobe.com/photoshop/1.0/"))
  {
    CFDictionaryRef v2 = (__CFString **)&kCGImageMetadataPrefixPhotoshop;
    goto LABEL_27;
  }
  if (CFEqual(a1, @"http://cipa.jp/exif/1.0/"))
  {
    CFDictionaryRef v2 = (__CFString **)&kCGImageMetadataPrefixExifEX;
    goto LABEL_27;
  }
  if (CFEqual(a1, @"http://iptc.org/std/Iptc4xmpCore/1.0/xmlns/"))
  {
    CFDictionaryRef v2 = (__CFString **)&kCGImageMetadataPrefixIPTCCore;
    goto LABEL_27;
  }
  if (CFEqual(a1, @"http://iptc.org/std/Iptc4xmpExt/2008-02-29/"))
  {
    CFDictionaryRef v2 = (__CFString **)&kCGImageMetadataPrefixIPTCExtension;
    goto LABEL_27;
  }
  if (CFEqual(a1, @"http://ns.apple.com/ImageIO/1.0/"))
  {
    CFDictionaryRef v2 = xmpImageIOPrefix;
    goto LABEL_27;
  }
  if (CFEqual(a1, @"http://www.metadataworkinggroup.com/schemas/regions/"))
  {
    CFDictionaryRef v2 = xmpMWGRegionsPrefix;
    goto LABEL_27;
  }
  if (CFEqual(a1, @"http://ns.adobe.com/camera-raw-settings/1.0/"))
  {
    CFDictionaryRef v2 = xmpCRSPrefix;
    goto LABEL_27;
  }
  if (CFEqual(a1, @"http://ns.adobe.com/exif/1.0/aux/"))
  {
    CFDictionaryRef v2 = (__CFString **)&kCGImageMetadataPrefixExifAux;
LABEL_27:
    CFDictionaryRef result = *v2;
    if (*v2) {
      return result;
    }
    goto LABEL_28;
  }
  if (CFEqual(a1, @"http://ns.adobe.com/xap/1.0/rights/"))
  {
    CFDictionaryRef v2 = (__CFString **)&kCGImageMetadataPrefixXMPRights;
    goto LABEL_27;
  }
LABEL_28:
  IIOString::IIOString((IIOString *)v5, a1);
  uint64_t v4 = (const char *)IIOString::utf8String((IIOString *)v5);
  _cg_jpeg_mem_term("CGImageMetadataDefaultPrefixForNamespace", 2480, "*** unknown schema '%s'\n", v4);
  IIOString::~IIOString((IIOString *)v5);
  return 0;
}

void sub_18859775C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  IIOString::~IIOString((IIOString *)va);
  _Unwind_Resume(a1);
}

void LogMetadata(const char *a1, int a2, const char *a3, ...)
{
  va_start(va, a3);
  IIOInitDebugFlags();
  if ((gIIODebugFlags & 0x1000000) != 0) {
    gImageIOLogProc(2, "ImageIO <Metadata>: ", a1, a2, a3, va);
  }
}

CGImage *CGImageGetImageSource(CGImage *a1)
{
  IIOInitDebugFlags();
  if ((~gIIODebugFlags & 0xC000) == 0) {
    ImageIODebugOptions(3, "S", "CGImageGetImageSource", 0, 0, -1, 0);
  }
  if (!a1)
  {
    _cg_jpeg_mem_term("CGImageGetImageSource", 5789, "*** ERROR: CGImageGetImageSource - image is NULL\n");
    return a1;
  }
  if (ERROR_CGImageCopyImageSource_WAS_CALLED_WITH_INVALID_CGIMAGE(a1)) {
    return 0;
  }
  CFDataRef Property = (const __CFData *)CGImageGetProperty();
  if (!Property) {
    return 0;
  }
  *(void *)buffer = 0;
  v7.location = 0;
  v7.length = 8;
  CFDataGetBytes(Property, v7, buffer);
  uint64_t Source = (IIOImageRead *)CGImageSourceGetSource(*(uint64_t *)buffer);
  if (!Source) {
    return 0;
  }
  uint64_t v4 = Source;
  IIOImageRead::lock(Source);
  a1 = (CGImage *)IIOImagePlus::isr(v4);
  if (!CGTrackImageSource((unint64_t)a1, 0))
  {
    IIOImageRead::unlock(v4);
    return 0;
  }
  CFRetain(a1);
  IIOImageRead::unlock(v4);
  if (a1) {
    CFAutorelease(a1);
  }
  return a1;
}

void IIOInitDebugFlags()
{
  if (IIOInitDebugFlags::onceToken != -1) {
    dispatch_once(&IIOInitDebugFlags::onceToken, &__block_literal_global_20);
  }
}

BOOL ERROR_CGImageCopyImageSource_WAS_CALLED_WITH_INVALID_CGIMAGE(CGImage *a1)
{
  if (a1)
  {
    CFTypeID v1 = CFGetTypeID(a1);
    return v1 != CGImageGetTypeID();
  }
  else
  {
    return 1;
  }
}

const __CFDictionary *IIODictionary::getUint32ForKeyGroup(IIODictionary *this, const __CFString *a2, const __CFString *a3)
{
  CFDictionaryRef result = IIODictionary::getGroupForKey(this, a3, 0);
  if (result)
  {
    Value = (IIODictionary *)CFDictionaryGetValue(result, a2);
    return (const __CFDictionary *)IIODictionary::getUint32FromValue(Value, (const __CFString *)Value);
  }
  return result;
}

uint64_t GetIntegerFromPropertyValue(const __CFString *cf, SInt32 *a2)
{
  uint64_t result = 0;
  if (cf && a2)
  {
    *a2 = 0;
    CFTypeID v5 = CFGetTypeID(cf);
    if ((v5 != CGImageMetadataTagGetTypeID()
       || (cf = *(const __CFString **)(CGImageSourceGetSource((uint64_t)cf) + 48)) != 0)
      && (CFTypeID v6 = CFGetTypeID(cf), v6 == CFStringGetTypeID()))
    {
      *a2 = CFStringGetIntValue(cf);
      return 1;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t GetDoubleFromPropertyValue(const __CFString *cf, double *a2)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  if (!a2) {
    return 0;
  }
  CFStringRef v3 = cf;
  *a2 = 0.0;
  if (!cf) {
    return 0;
  }
  CFTypeID v4 = CFGetTypeID(cf);
  if (v4 == CGImageMetadataTagGetTypeID())
  {
    CFStringRef v3 = *(const __CFString **)(CGImageSourceGetSource((uint64_t)v3) + 48);
    if (!v3) {
      return 0;
    }
  }
  CFTypeID v5 = CFGetTypeID(v3);
  if (v5 != CFStringGetTypeID()) {
    return 0;
  }
  memset(v10, 0, sizeof(v10));
  uint64_t result = CFStringGetCString(v3, (char *)v10, 32, 0x8000100u);
  if (result)
  {
    double v7 = (double)atol((const char *)v10);
    CFTypeID v8 = strchr((char *)v10, 47);
    if (v8)
    {
      char *v8 = 0;
      uint64_t v9 = atol(v8 + 1);
      if (v9)
      {
        if (v9 != 1) {
          double v7 = v7 / (double)v9;
        }
      }
      else
      {
        double v7 = 0.0;
      }
    }
    *a2 = v7;
    return 1;
  }
  return result;
}

void ___ZN17IIO_ReaderHandler17setAllowableTypesEPK9__CFArray_block_invoke(uint64_t a1, const void *a2)
{
  CFArrayRef v4 = *(const __CFArray **)(a1 + 40);
  v7.length = CFArrayGetCount(v4);
  v7.location = 0;
  if (CFArrayContainsValue(v4, v7, a2))
  {
    ++*(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  }
  else
  {
    memset(v6, 0, sizeof(v6));
    IIOString::IIOString((IIOString *)v6, a2);
    CFTypeID v5 = (const char *)IIOString::utf8String((IIOString *)v6);
    LogError("setAllowableTypes_block_invoke", 1224, "*** CGImageSourceSetAllowableTypes - ignoring unknown: '%s'\n", v5);
    IIOString::~IIOString((IIOString *)v6);
  }
}

void sub_188597C74(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  IIOString::~IIOString((IIOString *)va);
  _Unwind_Resume(a1);
}

uint64_t CGImageMetadataTagSetSource(uint64_t result, int a2)
{
  if (result)
  {
    uint64_t v2 = *(void *)(result + 24);
    if (v2) {
      *(_DWORD *)(v2 + 68) = a2;
    }
  }
  return result;
}

CFStringRef CreateIPTCTimeStringWithXMPDateTimeString(const __CFString *a1)
{
  memset(&v5, 0, sizeof(v5));
  *(_WORD *)CFArrayRef v4 = 0;
  int DateTimeStructFromXMPDateTimeString = GetDateTimeStructFromXMPDateTimeString(a1, &v5, &v4[1], v4);
  CFStringRef result = 0;
  if (DateTimeStructFromXMPDateTimeString && v4[1])
  {
    if (v4[0])
    {
      LODWORD(v3) = v5.tm_gmtoff % 3600 / 60;
      if ((int)v3 >= 0) {
        uint64_t v3 = v3;
      }
      else {
        uint64_t v3 = (v5.tm_gmtoff % 3600 / -60);
      }
      return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"%02d%02d%02d%+03d%02d", v5.tm_hour, v5.tm_min, v5.tm_sec, v5.tm_gmtoff / 3600, v3);
    }
    else
    {
      return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"%02d%02d%02d", v5.tm_hour, v5.tm_min, v5.tm_sec);
    }
  }
  return result;
}

void ___ZN13PNGReadPlugin19DecodeFrameStandardEP19IIOImageReadSessionRK14ReadPluginDataRK13PNGPluginDataR20IIODecodeFrameParams_block_invoke(void *a1, uint64_t a2)
{
  CFArrayRef v44 = 0;
  CFTypeID v45 = 0;
  uint64_t v4 = *(void *)(a1[7] + 48);
  uint64_t v5 = v4 + 12 * a2;
  memset(v43, 0, sizeof(v43));
  unint64_t v6 = *(unsigned int *)(v5 + 4);
  uint64_t v7 = *(unsigned int *)(v5 + 8);
  CFTypeID v8 = _cg_png_create_read_struct("1.6.43", 0, (uint64_t)handle_error_idot, (uint64_t)handle_warning);
  CFTypeID v45 = v8;
  _cg_png_create_info_struct((uint64_t)v8);
  CGImageMetadataType v10 = v9;
  CFArrayRef v44 = v9;
  _cg_png_set_option((uint64_t)v8, 2u, 3);
  _cg_png_set_benign_errors((uint64_t)v8, 1);
  uint64_t v11 = (IIOImageReadSession *)a1[8];
  uint64_t v41 = 0;
  uint64_t v42 = 0;
  CFIndex v40 = v11;
  _cg_png_set_read_fn(v8, (uint64_t)&v40, (size_t (*)(size_t, void *, size_t))read_fn2);
  _cg_png_set_keep_unknown_chunks_sized((uint64_t)v8, 3u, "CgBI", 4);
  int appleflags = _cg_png_get_appleflags((uint64_t)v8);
  _cg_png_set_appleflags((uint64_t)v8, appleflags | 0xC);
  _cg_png_set_read_user_chunk_fn((uint64_t)v8, (uint64_t)v43, (uint64_t)PNGReadPlugin::Read_user_chunk_callback2);
  _cg_png_read_info((uLong)v8, v10);
  if (*(unsigned char *)(a1[9] + 63) == 1) {
    _cg_png_set_swap((uint64_t)v8);
  }
  if (*(unsigned char *)(a1[7] + 27))
  {
    _cg_png_set_add_alpha((uint64_t)v8, 255, 1);
    if ((gIIODebugFlags & 0x20000) != 0)
    {
      uint64_t v13 = a1[9];
      int v14 = *(_DWORD *)(v13 + 20);
      unsigned int v15 = v14 >> 24;
      uint64_t v16 = MEMORY[0x1E4F14390];
      if (v14 < 0)
      {
        int v17 = __maskrune(v15, 0x40000uLL);
        uint64_t v13 = a1[9];
      }
      else
      {
        int v17 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v15 + 60) & 0x40000;
      }
      int v18 = *(_DWORD *)(v13 + 20);
      if (v17) {
        uint64_t v19 = (v18 >> 24);
      }
      else {
        uint64_t v19 = 46;
      }
      unsigned int v20 = v18 << 8 >> 24;
      if (v18 << 8 < 0)
      {
        int v21 = __maskrune(v20, 0x40000uLL);
        uint64_t v13 = a1[9];
      }
      else
      {
        int v21 = *(_DWORD *)(v16 + 4 * v20 + 60) & 0x40000;
      }
      int v22 = *(_DWORD *)(v13 + 20);
      if (v21) {
        uint64_t v23 = (v22 << 8 >> 24);
      }
      else {
        uint64_t v23 = 46;
      }
      unsigned int v24 = (__int16)v22 >> 8;
      if (v22 << 16 < 0)
      {
        int v26 = __maskrune(v24, 0x40000uLL);
        uint64_t v25 = v16;
        uint64_t v13 = a1[9];
      }
      else
      {
        uint64_t v25 = v16;
        int v26 = *(_DWORD *)(v16 + 4 * v24 + 60) & 0x40000;
      }
      int v27 = *(_DWORD *)(v13 + 20);
      if (v26) {
        uint64_t v28 = ((__int16)v27 >> 8);
      }
      else {
        uint64_t v28 = 46;
      }
      if ((v27 << 24) <= 0x7F000000)
      {
        if ((*(_DWORD *)(v25 + 4 * (char)v27 + 60) & 0x40000) != 0) {
          goto LABEL_25;
        }
      }
      else if (__maskrune((char)v27, 0x40000uLL))
      {
LABEL_25:
        int v29 = *(_DWORD *)(a1[9] + 20);
LABEL_28:
        ImageIOLog("  '%c%c%c%c' %d: png_set_add_alpha: PNG_FILLER_AFTER\n", v19, v23, v28, (char)v29, 4274);
        goto LABEL_29;
      }
      LOBYTE(v29) = 46;
      goto LABEL_28;
    }
  }
LABEL_29:
  if (a2)
  {
    int v30 = _cg_png_get_appleflags((uint64_t)v8);
    _cg_png_set_appleflags((uint64_t)v8, v30 | 0x10);
  }
  if (*(unsigned char *)(a1[7] + 28) && _cg_png_get_valid((uint64_t)v8, (uint64_t)v10, 0x10u))
  {
    _cg_png_set_palette_to_rgb((uint64_t)v8);
    _cg_png_read_update_info((uint64_t)v8, v10);
  }
  uint64_t v31 = (*(_DWORD *)(v4 + 12 * a2 + 12) - 4);
  uint64_t v41 = v31;
  uint64_t v42 = 0;
  IIOImageReadSession::willNeed((IIOImageRead **)v40, v31, 0x10000uLL);
  uint64_t v42 = v31 + 0x10000;
  _cg_png_set_row_number((uint64_t)v8, v6);
  int chunk_header = _cg_png_read_chunk_header((uLong)v8);
  _cg_png_set_idat_size((uint64_t)v8, chunk_header);
  _cg_png_read_update_info((uint64_t)v8, v10);
  size_t rowbytes = _cg_png_get_rowbytes((uint64_t)v8, (uint64_t)v10);
  int v34 = rowbytes;
  if (rowbytes >= *(unsigned int *)(a1[9] + 116)) {
    size_t v35 = *(unsigned int *)(a1[9] + 116);
  }
  else {
    size_t v35 = rowbytes;
  }
  CGImageMetadataTagRef v36 = (char *)malloc_type_malloc(rowbytes, 0x8AF7BE66uLL);
  if (!v36)
  {
    exception = __cxa_allocate_exception(4uLL);
    _DWORD *exception = -1;
    __cxa_throw(exception, MEMORY[0x1E4FBA3A8], 0);
  }
  if (v7)
  {
    unint64_t v37 = v7 + v6;
    do
    {
      _cg_png_read_row_sized((uLong)v8, v36, v34, 0);
      memmove((void *)(a1[10] + v6 * *(unsigned int *)(a1[9] + 116)), v36, v35);
      if (a2) {
        uint64_t v38 = a1[5];
      }
      else {
        uint64_t v38 = a1[4];
      }
      atomic_fetch_add_explicit((atomic_uint *volatile)(*(void *)(v38 + 8) + 24), 1u, memory_order_relaxed);
      ++v6;
    }
    while (v6 < v37);
  }
  _cg_png_destroy_read_struct((uint64_t *)&v45, (void **)&v44, 0);
  CFArrayRef v44 = 0;
  CFTypeID v45 = 0;
  free(v36);
}

void sub_1885981D4(void *a1)
{
  __cxa_begin_catch(a1);
  imagePNG_error_break(*(void *)(v2 - 96));
  *(_DWORD *)(*(void *)(*(void *)(v1 + 48) + 8) + 24) = -50;
  __cxa_end_catch();
  JUMPOUT(0x188598170);
}

void sub_188598210(_Unwind_Exception *a1)
{
}

void png_read_row_indexed(uLong a1, char *a2, char *__dst)
{
  if (a1)
  {
    if ((*(unsigned char *)(a1 + 80) & 0x40) == 0) {
      png_read_start_row(a1);
    }
    uint64_t v32 = 0;
    unint64_t v33 = 0;
    LODWORD(v32) = *(_DWORD *)(a1 + 304);
    unint64_t v6 = *(unsigned __int8 *)(a1 + 394);
    if (v6 >= 8) {
      unint64_t v7 = (v6 >> 3) * (unint64_t)v32;
    }
    else {
      unint64_t v7 = (*(unsigned __int8 *)(a1 + 394) * (unint64_t)v32 + 7) >> 3;
    }
    unsigned __int16 v8 = *(_WORD *)(a1 + 391);
    unint64_t v33 = v7;
    uint64_t v34 = v8;
    BYTE2(v34) = *(unsigned char *)(a1 + 395);
    BYTE3(v34) = v6;
    if (!*(unsigned char *)(a1 + 388) || (*(unsigned char *)(a1 + 88) & 2) == 0)
    {
LABEL_9:
      if ((*(unsigned char *)(a1 + 76) & 4) == 0)
      {
        uint64_t v25 = "Invalid attempt to read row data";
        goto LABEL_98;
      }
      if (*(unsigned char *)(a1 + 84))
      {
        png_read_IDAT_dataApple(a1);
      }
      else
      {
        **(unsigned char **)(a1 + 328) = -1;
        unint64_t v7 = v33;
        png_read_IDAT_data(a1, *(void *)(a1 + 328));
      }
      BYTE4(v34) = 0;
      uint64_t v9 = *(unsigned char **)(a1 + 328);
      int v10 = *v9;
      if (!*v9) {
        goto LABEL_22;
      }
      if (!*(void *)(a1 + 968)) {
        png_init_filter_functions(a1);
      }
      if ((*(unsigned char *)(a1 + 81) & 8) != 0 && (*(unsigned char *)(a1 + 84) & 2) != 0)
      {
        uint64_t v11 = (uint64_t)a2;
        BYTE4(v34) = *(void *)(a1 + 968) == (void)png_read_filter_row_sub_apple_neon;
        if (BYTE4(v34)) {
          goto LABEL_20;
        }
      }
      else
      {
        BYTE4(v34) = 0;
      }
      uint64_t v11 = *(void *)(a1 + 320) + 1;
LABEL_20:
      png_read_filter_row(a1, (uint64_t)&v32, *(void *)(a1 + 328) + 1, v11, v10);
      if (BYTE4(v34))
      {
LABEL_23:
        if ((*(unsigned char *)(a1 + 760) & 4) == 0 || *(unsigned char *)(a1 + 764) != 64 || (v34 & 2) == 0) {
          goto LABEL_72;
        }
        uint64_t v13 = *(void *)(a1 + 328);
        int v14 = v32;
        if (BYTE1(v34) != 16)
        {
          if (BYTE1(v34) == 8)
          {
            if (v34 == 2)
            {
              uint64_t v15 = 3;
LABEL_64:
              if (v32)
              {
                int v18 = (unsigned char *)(v13 + 3);
                do
                {
                  char v19 = *(v18 - 1);
                  *(v18 - 2) += v19;
                  *v18 += v19;
                  v18 += v15;
                  --v14;
                }
                while (v14);
              }
              goto LABEL_72;
            }
            if (v34 == 6)
            {
              uint64_t v15 = 4;
              goto LABEL_64;
            }
          }
LABEL_72:
          if (*(_DWORD *)(a1 + 88) || (*(_DWORD *)(a1 + 380) & 0x80000000) == 0) {
            png_do_read_transformations(a1, (unsigned int *)&v32, v12);
          }
          unsigned int v24 = BYTE3(v34);
          if (*(unsigned char *)(a1 + 399))
          {
            if (*(unsigned __int8 *)(a1 + 399) != BYTE3(v34))
            {
              uint64_t v25 = "internal sequential row size calculation error";
              goto LABEL_98;
            }
LABEL_79:
            if (*(unsigned char *)(a1 + 388) && (int v26 = *(_DWORD *)(a1 + 88), (v26 & 2) != 0))
            {
              unsigned int v30 = *(unsigned __int8 *)(a1 + 389);
              if (v30 <= 5) {
                png_do_read_interlace((uint64_t)&v32, *(void *)(a1 + 328) + 1, v30, v26);
              }
              if (__dst) {
                png_combine_row((char *)a1, __dst, 1);
              }
              if (!a2) {
                goto LABEL_93;
              }
              int v27 = (char *)a1;
              uint64_t v28 = a2;
              int v29 = 0;
            }
            else
            {
              if (a2 && !BYTE4(v34)) {
                png_combine_row((char *)a1, a2, -1);
              }
              if (!__dst) {
                goto LABEL_93;
              }
              int v27 = (char *)a1;
              uint64_t v28 = __dst;
              int v29 = -1;
            }
            png_combine_row(v27, v28, v29);
LABEL_93:
            png_read_finish_row(a1);
            uint64_t v31 = *(void (**)(uLong, void, void))(a1 + 544);
            if (v31) {
              v31(a1, *(unsigned int *)(a1 + 308), *(unsigned __int8 *)(a1 + 389));
            }
            return;
          }
          *(unsigned char *)(a1 + 399) = BYTE3(v34);
          if (v24 <= *(unsigned __int8 *)(a1 + 398)) {
            goto LABEL_79;
          }
          uint64_t v25 = "sequential row overflow";
LABEL_98:
          _cg_png_error((void (**)(void))a1, v25);
        }
        if (v34 == 2)
        {
          uint64_t v17 = 6;
        }
        else
        {
          if (v34 != 6) {
            goto LABEL_72;
          }
          uint64_t v17 = 8;
        }
        if (v32)
        {
          unsigned int v20 = (unsigned __int16 *)(v13 + 3);
          do
          {
            unsigned int v21 = *v20;
            unsigned int v22 = __rev16(v21) + (bswap32(*(v20 - 1)) >> 16);
            unsigned int v23 = __rev16(v20[1]) + (bswap32(v21) >> 16);
            *((unsigned char *)v20 - 2) = BYTE1(v22);
            *((unsigned char *)v20 - 1) = v22;
            *((unsigned char *)v20 + 2) = BYTE1(v23);
            *((unsigned char *)v20 + 3) = v23;
            unsigned int v20 = (unsigned __int16 *)((char *)v20 + v17);
            --v14;
          }
          while (v14);
        }
        goto LABEL_72;
      }
      uint64_t v9 = *(unsigned char **)(a1 + 328);
      unint64_t v7 = v33;
LABEL_22:
      memcpy(*(void **)(a1 + 320), v9, v7 + 1);
      goto LABEL_23;
    }
    int v16 = *(_DWORD *)(a1 + 308);
    switch(*(unsigned char *)(a1 + 389))
    {
      case 0:
        if ((v16 & 7) == 0) {
          goto LABEL_9;
        }
        goto LABEL_55;
      case 1:
        if ((v16 & 7) != 0 || *(_DWORD *)(a1 + 280) <= 4u) {
          goto LABEL_55;
        }
        goto LABEL_9;
      case 2:
        if ((*(_DWORD *)(a1 + 308) & 7) == 4) {
          goto LABEL_9;
        }
        if (!__dst || (v16 & 4) == 0) {
          goto LABEL_57;
        }
        goto LABEL_56;
      case 3:
        if ((v16 & 3) != 0 || *(_DWORD *)(a1 + 280) <= 2u) {
          goto LABEL_55;
        }
        goto LABEL_9;
      case 4:
        if ((*(_DWORD *)(a1 + 308) & 3) == 2) {
          goto LABEL_9;
        }
        if (!__dst || (v16 & 2) == 0) {
          goto LABEL_57;
        }
        goto LABEL_56;
      case 5:
        if ((v16 & 1) == 0 && *(_DWORD *)(a1 + 280) > 1u) {
          goto LABEL_9;
        }
LABEL_55:
        if (__dst) {
LABEL_56:
        }
          png_combine_row((char *)a1, __dst, 1);
LABEL_57:
        png_read_finish_row(a1);
        break;
      default:
        if ((v16 & 1) == 0) {
          goto LABEL_57;
        }
        goto LABEL_9;
    }
  }
}

void png_read_finish_row(uint64_t a1)
{
  unsigned int v1 = *(_DWORD *)(a1 + 308) + 1;
  *(_DWORD *)(a1 + 308) = v1;
  if (v1 >= *(_DWORD *)(a1 + 288))
  {
    if (*(unsigned char *)(a1 + 388))
    {
      *(_DWORD *)(a1 + 308) = 0;
      bzero(*(void **)(a1 + 320), *(void *)(a1 + 296) + 1);
      unsigned __int8 v3 = *(unsigned char *)(a1 + 389);
      while (++v3 <= 6u)
      {
        unsigned int v4 = png_read_start_row_png_pass_inc[v3];
        unsigned int v5 = *(_DWORD *)(a1 + 280) + v4 + ~png_read_start_row_png_pass_start[v3];
        *(_DWORD *)(a1 + 304) = v5 / v4;
        if ((*(unsigned char *)(a1 + 88) & 2) == 0)
        {
          unsigned int v6 = png_read_finish_row_png_pass_yinc[v3];
          unsigned int v7 = *(_DWORD *)(a1 + 284) + v6 + ~png_read_finish_row_png_pass_ystart[v3];
          *(_DWORD *)(a1 + 288) = v7 / v6;
          if (v7 < v6 || v5 < v4) {
            continue;
          }
        }
        *(unsigned char *)(a1 + 389) = v3;
        return;
      }
      *(unsigned char *)(a1 + 389) = v3;
    }
    if (*(unsigned char *)(a1 + 84)) {
      *(_DWORD *)(a1 + 80) |= 8u;
    }
    png_read_finish_IDAT(a1);
  }
}

void _cg_png_read_row_sized(uLong a1, char *a2, int a3, char *__dst)
{
}

uint64_t png_do_read_transformations(uint64_t result, unsigned int *a2, uint8x8_t a3)
{
  uint64_t v3 = result;
  uint64_t v384 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *(void *)(result + 328);
  if (!v4)
  {
    v380 = "NULL row buffer";
    goto LABEL_663;
  }
  if ((*(_DWORD *)(result + 80) & 0x4040) == 0x4000)
  {
    v380 = "Uninitialized row";
    goto LABEL_663;
  }
  int v6 = *(_DWORD *)(result + 88);
  if ((v6 & 0x1000) != 0)
  {
    if (*((unsigned char *)a2 + 16) == 3)
    {
      uint64_t v7 = v4 + 1;
      uint64_t v8 = *(void *)(result + 368);
      uint64_t v9 = *(void *)(result + 520);
      unsigned int v10 = *(unsigned __int16 *)(result + 384);
      uint64_t v11 = *a2;
      unsigned int v12 = *((unsigned __int8 *)a2 + 17);
      if (v12 <= 7)
      {
        if (v12 == 1)
        {
          if (v11)
          {
            int v29 = -(int)v11 & 7;
            unsigned int v30 = (unsigned __int8 *)(v7 + ((v11 - 1) >> 3));
            uint64_t v31 = (unsigned char *)(v4 + v11);
            unsigned int v32 = *a2;
            do
            {
              *v31-- = (*v30 >> v29) & 1;
              CFStringRef result = v29 == 7;
              if (v29 == 7) {
                int v29 = 0;
              }
              else {
                ++v29;
              }
              v30 -= result;
              --v32;
            }
            while (v32);
LABEL_41:
            uint64_t v13 = v11;
            goto LABEL_43;
          }
        }
        else if (v12 == 2)
        {
          if (v11)
          {
            int v33 = ~(2 * v11 + 6) & 6;
            uint64_t v34 = (unsigned __int8 *)(v7 + ((v11 - 1) >> 2));
            size_t v35 = (unsigned char *)(v4 + v11);
            unsigned int v36 = *a2;
            do
            {
              *v35-- = (*v34 >> v33) & 3;
              BOOL v54 = v33 == 6;
              CFStringRef result = v33 == 6;
              v33 += 2;
              if (v54) {
                int v33 = 0;
              }
              v34 -= result;
              --v36;
            }
            while (v36);
            goto LABEL_41;
          }
        }
        else
        {
          uint64_t v13 = *a2;
          if (v12 != 4) {
            goto LABEL_43;
          }
          if (v11)
          {
            int v14 = 4 * (*a2 & 1);
            uint64_t v15 = (unsigned __int8 *)(v7 + ((v11 - 1) >> 1));
            int v16 = (unsigned char *)(v4 + v11);
            unsigned int v17 = *a2;
            do
            {
              *v16-- = (*v15 >> v14) & 0xF;
              BOOL v54 = v14 == 4;
              CFStringRef result = v14 == 4;
              v14 += 4;
              if (v54) {
                int v14 = 0;
              }
              v15 -= result;
              --v17;
            }
            while (v17);
            goto LABEL_41;
          }
        }
        uint64_t v13 = 0;
LABEL_43:
        *((unsigned char *)a2 + 17) = 8;
        *((unsigned char *)a2 + 19) = 8;
        *((void *)a2 + 1) = v13;
        if (!v10) {
          goto LABEL_44;
        }
        goto LABEL_20;
      }
      if (v12 == 8)
      {
        if (!*(_WORD *)(result + 384))
        {
LABEL_44:
          uint64_t v26 = (3 * v11);
          if (v11)
          {
            unint64_t v37 = (unsigned char *)(v4 + v26);
            uint64_t v38 = (unsigned __int8 *)(v4 + v11);
            do
            {
              *unint64_t v37 = *(unsigned char *)(v8 + 3 * *v38 + 2);
              *(v37 - 1) = *(unsigned char *)(v8 + 3 * *v38 + 1);
              unsigned int v39 = *v38--;
              *(v37 - 2) = *(unsigned char *)(v8 + 3 * v39);
              v37 -= 3;
              LODWORD(v11) = v11 - 1;
            }
            while (v11);
          }
          *((unsigned char *)a2 + 17) = 8;
          *((unsigned char *)a2 + 19) = 24;
          char v27 = 3;
          char v28 = 2;
LABEL_48:
          *((void *)a2 + 1) = v26;
          *((unsigned char *)a2 + 16) = v28;
          *((unsigned char *)a2 + 18) = v27;
          goto LABEL_49;
        }
LABEL_20:
        if (v11)
        {
          unsigned int v20 = (char *)(v4 + 4 * v11);
          unsigned int v21 = (unsigned __int8 *)(v4 + v11);
          int v22 = v11;
          do
          {
            uint64_t v23 = *v21;
            if (v10 <= v23) {
              char v24 = -1;
            }
            else {
              char v24 = *(unsigned char *)(v9 + v23);
            }
            *unsigned int v20 = v24;
            *(v20 - 1) = *(unsigned char *)(v8 + 3 * *v21 + 2);
            *(v20 - 2) = *(unsigned char *)(v8 + 3 * *v21 + 1);
            unsigned int v25 = *v21--;
            *(v20 - 3) = *(unsigned char *)(v8 + 3 * v25);
            v20 -= 4;
            --v22;
          }
          while (v22);
        }
        *((unsigned char *)a2 + 17) = 8;
        *((unsigned char *)a2 + 19) = 32;
        uint64_t v26 = (4 * v11);
        char v27 = 4;
        char v28 = 6;
        goto LABEL_48;
      }
    }
    else
    {
      if ((v6 & 0x2000000) != 0 && *(_WORD *)(result + 384))
      {
        int v18 = (unsigned __int16 *)(result + 528);
        char v19 = a2;
      }
      else
      {
        char v19 = a2;
        int v18 = 0;
      }
      CFStringRef result = (uint64_t)png_do_expand(v19, v4 + 1, v18);
    }
  }
LABEL_49:
  int v40 = *(_DWORD *)(v3 + 88);
  if ((v40 & 0x40080) == 0x40000 && (*((unsigned __int8 *)a2 + 16) | 2) == 6)
  {
    CFStringRef result = png_do_strip_channel((uint64_t)a2, (unsigned char *)(*(void *)(v3 + 328) + 1), 0);
    int v40 = *(_DWORD *)(v3 + 88);
  }
  if ((v40 & 0x600000) == 0) {
    goto LABEL_119;
  }
  char v41 = *((unsigned char *)a2 + 16);
  if ((v41 & 3) != 2) {
    goto LABEL_119;
  }
  uint64_t v42 = (unsigned __int8 *)(*(void *)(v3 + 328) + 1);
  int v43 = *(unsigned __int16 *)(v3 + 754);
  int v44 = *(unsigned __int16 *)(v3 + 756);
  int v45 = 0x8000 - (v43 + v44);
  unsigned int v46 = *a2;
  unsigned int v47 = *a2;
  if (*((unsigned char *)a2 + 17) == 8)
  {
    uint64_t v48 = *(void *)(v3 + 472);
    if (v48)
    {
      uint64_t v49 = *(void *)(v3 + 480);
      if (v49)
      {
        if (v47)
        {
          int v50 = 0;
          CFStringRef result = *(void *)(v3 + 328) + 1;
          while (1)
          {
            CGImageMetadataTagRef v51 = (unsigned char *)*v42;
            uint64_t v52 = v42[1];
            uint64_t v53 = v42[2];
            BOOL v54 = v51 == v52 && v51 == v53;
            if (!v54) {
              break;
            }
            uint64_t v55 = *(void *)(v3 + 456);
            if (v55)
            {
              v51 += v55;
              goto LABEL_66;
            }
LABEL_67:
            *(unsigned char *)CFStringRef result = (_BYTE)v51;
            if ((v41 & 4) != 0)
            {
              unsigned __int8 v56 = v42[3];
              v42 += 4;
              *(unsigned char *)(result + 1) = v56;
              result += 2;
            }
            else
            {
              v42 += 3;
              ++result;
            }
            if (!--v47) {
              goto LABEL_113;
            }
          }
          CGImageMetadataTagRef v51 = (unsigned char *)(v48
                        + ((*(unsigned __int8 *)(v49 + v52) * v44
                          + v51[v49] * v43
                          + v45 * *(unsigned __int8 *)(v49 + v53)
                          + 0x4000) >> 15));
          int v50 = 1;
LABEL_66:
          LOBYTE(v51) = *v51;
          goto LABEL_67;
        }
        goto LABEL_112;
      }
    }
    if (v47)
    {
      int v50 = 0;
      __int16 v71 = (unsigned __int8 *)(*(void *)(v3 + 328) + 1);
      do
      {
        int v72 = *v71;
        int v73 = v71[1];
        int v74 = v71[2];
        if (v72 != v73 || v72 != v74)
        {
          LOBYTE(v72) = (v72 * v43 + v73 * v44 + v45 * v74) >> 15;
          int v50 = 1;
        }
        unsigned __int8 *v42 = v72;
        CFStringRef result = (uint64_t)(v42 + 1);
        if ((v41 & 4) != 0)
        {
          unsigned __int8 v76 = v71[3];
          v71 += 4;
          v42[1] = v76;
          v42 += 2;
        }
        else
        {
          v71 += 3;
          ++v42;
        }
        --v47;
      }
      while (v47);
      goto LABEL_113;
    }
LABEL_112:
    int v50 = 0;
    goto LABEL_113;
  }
  uint64_t v57 = *(void *)(v3 + 496);
  if (v57 && (uint64_t v58 = *(void *)(v3 + 488)) != 0)
  {
    if (!v47) {
      goto LABEL_112;
    }
    int v50 = 0;
    CFStringRef result = *(void *)(v3 + 328) + 1;
    do
    {
      int v59 = *(unsigned __int8 *)result;
      int v60 = *(unsigned __int8 *)(result + 1);
      unsigned int v61 = v60 | (v59 << 8);
      uint64_t v62 = *(unsigned __int8 *)(result + 2);
      unsigned int v63 = *(unsigned __int8 *)(result + 3);
      unsigned int v64 = __rev16(*(unsigned __int16 *)(result + 4));
      if ((v63 | (v62 << 8)) == v61 && v61 == v64)
      {
        uint64_t v69 = *(void *)(v3 + 464);
        if (v69)
        {
          LOBYTE(v60) = *(_WORD *)(*(void *)(v69 + 8 * (v63 >> *(_DWORD *)(v3 + 448))) + 2 * v62);
          int v59 = HIBYTE(*(unsigned __int16 *)(*(void *)(v69 + 8 * (v63 >> *(_DWORD *)(v3 + 448))) + 2 * v62));
        }
      }
      else
      {
        char v66 = *(_DWORD *)(v3 + 448);
        unsigned int v67 = *(unsigned __int16 *)(*(void *)(v57 + 8 * (v63 >> v66)) + 2 * v62) * v44
            + *(unsigned __int16 *)(*(void *)(v57 + 8 * (v61 >> v66)) + 2 * (v61 >> 8)) * v43
            + v45 * *(unsigned __int16 *)(*(void *)(v57 + 8 * (v64 >> v66)) + 2 * (v64 >> 8))
            + 0x4000;
        unsigned int v68 = *(unsigned __int16 *)(*(void *)(v58 + 8 * ((v67 >> 15) >> v66))
                                  + 2 * (v67 >> 23));
        LOBYTE(v60) = v68;
        int v59 = v68 >> 8;
        int v50 = 1;
      }
      unsigned __int8 *v42 = v59;
      v42[1] = v60;
      if ((v41 & 4) != 0)
      {
        v42[2] = *(unsigned char *)(result + 6);
        unsigned __int8 v70 = *(unsigned char *)(result + 7);
        result += 8;
        v42[3] = v70;
        v42 += 4;
      }
      else
      {
        result += 6;
        v42 += 2;
      }
      --v47;
    }
    while (v47);
  }
  else
  {
    if (!v47) {
      goto LABEL_112;
    }
    int v50 = 0;
    CFIndex v77 = (unsigned __int16 *)(*(void *)(v3 + 328) + 1);
    do
    {
      unsigned int v78 = __rev16(*v77);
      unsigned int v79 = __rev16(v77[1]);
      unsigned int v80 = v77[2];
      unsigned int v81 = __rev16(v80);
      if (v78 != bswap32(v80) >> 16 || v78 != v79) {
        int v50 = 1;
      }
      unsigned int v83 = v79 * v44 + v78 * v43 + v81 * v45 + 0x4000;
      CFStringRef result = v83 >> 15;
      unsigned __int8 *v42 = v83 >> 23;
      v42[1] = result;
      if ((v41 & 4) != 0)
      {
        v42[2] = *((unsigned char *)v77 + 6);
        unsigned __int8 v84 = *((unsigned char *)v77 + 7);
        v77 += 4;
        v42[3] = v84;
        v42 += 4;
      }
      else
      {
        v77 += 3;
        v42 += 2;
      }
      --v47;
    }
    while (v47);
  }
LABEL_113:
  char v85 = *((unsigned char *)a2 + 18) - 2;
  *((unsigned char *)a2 + 18) = v85;
  *((unsigned char *)a2 + 16) &= ~2u;
  unsigned __int8 v86 = *((unsigned char *)a2 + 17) * v85;
  *((unsigned char *)a2 + 19) = v86;
  unint64_t v87 = (v86 * (unint64_t)v46 + 7) >> 3;
  unint64_t v88 = v46 * (unint64_t)(v86 >> 3);
  if (v86 < 8u) {
    unint64_t v88 = v87;
  }
  *((void *)a2 + 1) = v88;
  int v40 = *(_DWORD *)(v3 + 88);
  if (v50)
  {
    *(unsigned char *)(v3 + 752) = 1;
    if ((v40 & 0x600000) == 0x400000)
    {
      CFStringRef result = png_warning(v3, "png_do_rgb_to_gray found nongray pixel");
      int v40 = *(_DWORD *)(v3 + 88);
    }
    if ((v40 & 0x600000) == 0x200000)
    {
      v380 = "png_do_rgb_to_gray found nongray pixel";
      goto LABEL_663;
    }
  }
LABEL_119:
  if ((v40 & 0x4000) != 0 && (*(unsigned char *)(v3 + 77) & 8) == 0)
  {
    CFStringRef result = (uint64_t)png_do_gray_to_rgb(a2, *(void *)(v3 + 328) + 1);
    int v40 = *(_DWORD *)(v3 + 88);
  }
  if ((v40 & 0x80) != 0)
  {
    v104 = *(unsigned __int8 **)(v3 + 328);
    v105 = v104 + 1;
    CFStringRef result = *(void *)(v3 + 472);
    uint64_t v106 = *(void *)(v3 + 480);
    uint64_t v107 = *(void *)(v3 + 456);
    uint64_t v108 = *(void *)(v3 + 464);
    uint64_t v109 = *(void *)(v3 + 488);
    uint64_t v110 = *(void *)(v3 + 496);
    int v111 = *(_DWORD *)(v3 + 448);
    int v112 = *(_DWORD *)(v3 + 80);
    unsigned int v113 = *a2;
    switch(*((unsigned char *)a2 + 16))
    {
      case 0:
        switch(*((unsigned char *)a2 + 17))
        {
          case 1:
            if (v113)
            {
              int v114 = *(unsigned __int16 *)(v3 + 536);
              int v115 = 7;
              do
              {
                unsigned int v116 = *v105;
                if (((v116 >> v115) & 1) == v114) {
                  unsigned __int8 *v105 = (*(unsigned __int16 *)(v3 + 420) << v115) | (0x7F7Fu >> (7 - v115)) & v116;
                }
                BOOL v117 = v115 == 0;
                if (v115) {
                  --v115;
                }
                else {
                  int v115 = 7;
                }
                if (v117) {
                  ++v105;
                }
                --v113;
              }
              while (v113);
            }
            break;
          case 2:
            if (v107)
            {
              if (v113)
              {
                int v349 = *(unsigned __int16 *)(v3 + 536);
                int v350 = 6;
                do
                {
                  unsigned int v351 = *v105;
                  unsigned int v352 = (v351 >> v350) & 3;
                  if (v352 == v349)
                  {
                    v351 &= 0x3F3Fu >> (6 - v350);
                    LOBYTE(v353) = *(unsigned __int16 *)(v3 + 420) << v350;
                  }
                  else
                  {
                    CFStringRef result = 0x3F3Fu >> (6 - v350);
                    LOBYTE(v351) = result & v351;
                    int v353 = *(unsigned __int8 *)(v107 + 85 * v352) >> 6 << v350;
                  }
                  unsigned __int8 *v105 = v353 | v351;
                  BOOL v354 = v350 == 0;
                  if (v350) {
                    v350 -= 2;
                  }
                  else {
                    int v350 = 6;
                  }
                  if (v354) {
                    ++v105;
                  }
                  --v113;
                }
                while (v113);
              }
            }
            else if (v113)
            {
              int v368 = *(unsigned __int16 *)(v3 + 536);
              int v369 = 6;
              do
              {
                unsigned int v370 = *v105;
                if (((v370 >> v369) & 3) == v368) {
                  unsigned __int8 *v105 = (*(unsigned __int16 *)(v3 + 420) << v369) | (0x3F3Fu >> (6 - v369)) & v370;
                }
                BOOL v371 = v369 == 0;
                if (v369) {
                  v369 -= 2;
                }
                else {
                  int v369 = 6;
                }
                if (v371) {
                  ++v105;
                }
                --v113;
              }
              while (v113);
            }
            break;
          case 3:
          case 5:
          case 6:
          case 7:
            goto LABEL_123;
          case 4:
            if (v107)
            {
              if (v113)
              {
                int v355 = *(unsigned __int16 *)(v3 + 536);
                int v356 = 4;
                do
                {
                  unsigned int v357 = *v105;
                  uint64_t v358 = (v357 >> v356) & 0xF;
                  unsigned int v359 = (0xF0Fu >> (4 - v356)) & v357;
                  if (v358 == v355) {
                    LOBYTE(v360) = *(unsigned __int16 *)(v3 + 420) << v356;
                  }
                  else {
                    int v360 = *(unsigned __int8 *)(v107 + (v358 | (16 * v358))) >> 4 << v356;
                  }
                  unsigned __int8 *v105 = v360 | v359;
                  BOOL v361 = v356 == 0;
                  if (v356) {
                    v356 -= 4;
                  }
                  else {
                    int v356 = 4;
                  }
                  if (v361) {
                    ++v105;
                  }
                  --v113;
                }
                while (v113);
              }
            }
            else if (v113)
            {
              int v372 = *(unsigned __int16 *)(v3 + 536);
              int v373 = 4;
              do
              {
                unsigned int v374 = *v105;
                if (((v374 >> v373) & 0xF) == v372) {
                  unsigned __int8 *v105 = (*(unsigned __int16 *)(v3 + 420) << v373) | (0xF0Fu >> (4 - v373)) & v374;
                }
                BOOL v375 = v373 == 0;
                if (v373) {
                  v373 -= 4;
                }
                else {
                  int v373 = 4;
                }
                if (v375) {
                  ++v105;
                }
                --v113;
              }
              while (v113);
            }
            break;
          case 8:
            if (v107)
            {
              if (v113)
              {
                int v362 = *(unsigned __int16 *)(v3 + 536);
                do
                {
                  uint64_t v363 = *v105;
                  if (v362 == v363) {
                    unsigned __int8 v364 = *(unsigned char *)(v3 + 420);
                  }
                  else {
                    unsigned __int8 v364 = *(unsigned char *)(v107 + v363);
                  }
                  *v105++ = v364;
                  --v113;
                }
                while (v113);
              }
            }
            else if (v113)
            {
              int v376 = *(unsigned __int16 *)(v3 + 536);
              do
              {
                if (v376 == *v105) {
                  unsigned __int8 *v105 = *(unsigned char *)(v3 + 420);
                }
                ++v105;
                --v113;
              }
              while (v113);
            }
            break;
          default:
            if (*((unsigned char *)a2 + 17) == 16)
            {
              if (v108)
              {
                if (v113)
                {
                  int v318 = *(unsigned __int16 *)(v3 + 536);
                  do
                  {
                    uint64_t v319 = *v105;
                    unsigned int v320 = v105[1];
                    v321 = (unsigned __int16 *)(v3 + 420);
                    if ((v320 | (v319 << 8)) != v318) {
                      v321 = (unsigned __int16 *)(*(void *)(v108 + 8 * (v320 >> v111)) + 2 * v319);
                    }
                    *(_WORD *)v105 = bswap32(*v321) >> 16;
                    v105 += 2;
                    --v113;
                  }
                  while (v113);
                }
              }
              else if (v113)
              {
                int v378 = *(unsigned __int16 *)(v3 + 536);
                v379 = v104 + 2;
                do
                {
                  if (v378 == bswap32(*(unsigned __int16 *)(v379 - 1)) >> 16) {
                    *(_WORD *)(v379 - 1) = bswap32(*(unsigned __int16 *)(v3 + 420)) >> 16;
                  }
                  v379 += 2;
                  --v113;
                }
                while (v113);
              }
            }
            break;
        }
        goto LABEL_123;
      case 2:
        if (*((unsigned char *)a2 + 17) == 8)
        {
          if (v107)
          {
            if (v113)
            {
              unsigned int v126 = *(unsigned __int16 *)(v3 + 530);
              v127 = v104 + 3;
              do
              {
                uint64_t v128 = *(v127 - 2);
                uint64_t v129 = *(v127 - 1);
                if (__PAIR64__(*(unsigned __int16 *)(v3 + 532), v126) == __PAIR64__(v129, v128)
                  && *(_WORD *)(v3 + 534) == *v127)
                {
                  *(v127 - 2) = *(unsigned char *)(v3 + 414);
                  *(v127 - 1) = *(unsigned char *)(v3 + 416);
                  char v130 = *(unsigned char *)(v3 + 418);
                }
                else
                {
                  *(v127 - 2) = *(unsigned char *)(v107 + v128);
                  *(v127 - 1) = *(unsigned char *)(v107 + v129);
                  char v130 = *(unsigned char *)(v107 + *v127);
                }
                unsigned char *v127 = v130;
                v127 += 3;
                --v113;
              }
              while (v113);
            }
          }
          else if (v113)
          {
            int v345 = *(unsigned __int16 *)(v3 + 530);
            v346 = v104 + 3;
            do
            {
              if (v345 == *(v346 - 2)
                && *(_WORD *)(v3 + 532) == *(v346 - 1)
                && *(_WORD *)(v3 + 534) == *v346)
              {
                *(v346 - 2) = *(unsigned char *)(v3 + 414);
                *(v346 - 1) = *(unsigned char *)(v3 + 416);
                unsigned char *v346 = *(unsigned char *)(v3 + 418);
              }
              v346 += 3;
              --v113;
            }
            while (v113);
          }
        }
        else if (v108)
        {
          if (v113)
          {
            int v143 = *(unsigned __int16 *)(v3 + 530);
            double v144 = v104 + 3;
            do
            {
              uint64_t v145 = *(v144 - 2);
              unsigned int v146 = *(v144 - 1);
              uint64_t v147 = v144[2];
              unsigned int v148 = v144[3];
              CFStringRef result = v144[1];
              unsigned int v149 = *v144;
              if ((v146 | (v145 << 8)) == v143
                && (result | (v149 << 8)) == *(unsigned __int16 *)(v3 + 532)
                && (v148 | (v147 << 8)) == *(unsigned __int16 *)(v3 + 534))
              {
                *((_WORD *)v144 - 1) = bswap32(*(unsigned __int16 *)(v3 + 414)) >> 16;
                *(_WORD *)double v144 = bswap32(*(unsigned __int16 *)(v3 + 416)) >> 16;
                v150 = (unsigned __int16 *)(v3 + 418);
              }
              else
              {
                *((_WORD *)v144 - 1) = bswap32(*(unsigned __int16 *)(*(void *)(v108 + 8 * (v146 >> v111)) + 2 * v145)) >> 16;
                *(_WORD *)double v144 = bswap32(*(unsigned __int16 *)(*(void *)(v108 + 8 * (result >> v111))
                                                             + 2 * v149)) >> 16;
                v150 = (unsigned __int16 *)(*(void *)(v108 + 8 * (v148 >> v111)) + 2 * v147);
              }
              *((_WORD *)v144 + 1) = bswap32(*v150) >> 16;
              v144 += 6;
              --v113;
            }
            while (v113);
          }
        }
        else if (v113)
        {
          int v347 = *(unsigned __int16 *)(v3 + 530);
          v348 = (unsigned __int16 *)(v104 + 3);
          do
          {
            if (v347 == bswap32(*(v348 - 1)) >> 16
              && *(unsigned __int16 *)(v3 + 532) == bswap32(*v348) >> 16
              && __rev16(v348[1]) == *(unsigned __int16 *)(v3 + 534))
            {
              *(v348 - 1) = bswap32(*(unsigned __int16 *)(v3 + 414)) >> 16;
              unsigned __int16 *v348 = bswap32(*(unsigned __int16 *)(v3 + 416)) >> 16;
              v348[1] = bswap32(*(unsigned __int16 *)(v3 + 418)) >> 16;
            }
            v348 += 3;
            --v113;
          }
          while (v113);
        }
        goto LABEL_123;
      case 4:
        if (*((unsigned char *)a2 + 17) == 8)
        {
          if (v106 && result && v107)
          {
            for (; v113; --v113)
            {
              int v131 = v105[1];
              if (v105[1])
              {
                if (v131 == 255)
                {
                  LOBYTE(v132) = *(unsigned char *)(v107 + *v105);
                }
                else
                {
                  unsigned __int16 v133 = *(unsigned __int8 *)(v106 + *v105) * (_WORD)v131 + *(_WORD *)(v3 + 430) * (v131 ^ 0xFF) + 128;
                  unsigned int v132 = HIBYTE(v133) + v133;
                  if ((v112 & 0x2000) != 0) {
                    v132 >>= 8;
                  }
                  else {
                    LOBYTE(v132) = *(unsigned char *)(result + BYTE1(v132));
                  }
                }
              }
              else
              {
                LOBYTE(v132) = *(unsigned char *)(v3 + 420);
              }
              unsigned __int8 *v105 = v132;
              v105 += 2;
            }
          }
          else
          {
            for (; v113; --v113)
            {
              int v322 = v105[1];
              if (v322 != 255)
              {
                if (v105[1])
                {
                  unsigned __int16 v324 = *v105 * (_WORD)v322 + *(_WORD *)(v3 + 420) * (v322 ^ 0xFF) + 128;
                  unsigned int v323 = (HIBYTE(v324) + v324) >> 8;
                }
                else
                {
                  LOBYTE(v323) = *(unsigned char *)(v3 + 420);
                }
                unsigned __int8 *v105 = v323;
              }
              v105 += 2;
            }
          }
          goto LABEL_123;
        }
        if (!v108 || !v109 || !v110)
        {
          if (v113)
          {
            v331 = v104 + 2;
            do
            {
              unsigned int v332 = __rev16(*(unsigned __int16 *)(v331 + 1));
              if (v332 != 0xFFFF)
              {
                if (v332)
                {
                  unsigned int v333 = __rev16(*(unsigned __int16 *)(v331 - 1)) * v332
                       + (v332 ^ 0xFFFF) * *(unsigned __int16 *)(v3 + 420)
                       + 0x8000;
                  unsigned int v334 = v333 + HIWORD(v333);
                  *(v331 - 1) = HIBYTE(v334);
                  unsigned __int8 *v331 = BYTE2(v334);
                }
                else
                {
                  *(_WORD *)(v331 - 1) = bswap32(*(unsigned __int16 *)(v3 + 420)) >> 16;
                }
              }
              v331 += 4;
              --v113;
            }
            while (v113);
          }
          goto LABEL_123;
        }
        if (!v113) {
          goto LABEL_123;
        }
        v151 = v104 + 2;
        while (1)
        {
          unsigned int v152 = __rev16(*(unsigned __int16 *)(v151 + 1));
          if (v152)
          {
            if (v152 != 0xFFFF)
            {
              CFStringRef result = (v152 ^ 0xFFFF) * *(unsigned __int16 *)(v3 + 430);
              unsigned int v154 = result
                   + v152 * *(unsigned __int16 *)(*(void *)(v110 + 8 * (*v151 >> v111)) + 2 * *(v151 - 1))
                   + 0x8000;
              unsigned int v155 = v154 + HIWORD(v154);
              if ((v112 & 0x2000) != 0)
              {
                unsigned int v156 = HIWORD(v155);
                unsigned int v157 = HIBYTE(v155);
              }
              else
              {
                unsigned int v156 = *(unsigned __int16 *)(*(void *)(v109 + 8 * (BYTE2(v155) >> v111)) + 2 * HIBYTE(v155));
                unsigned int v157 = v156 >> 8;
              }
              *(v151 - 1) = v157;
              unsigned __int8 *v151 = v156;
              goto LABEL_243;
            }
            unsigned int v153 = *(unsigned __int16 *)(*(void *)(v108 + 8 * (*v151 >> v111)) + 2 * *(v151 - 1));
          }
          else
          {
            unsigned int v153 = *(unsigned __int16 *)(v3 + 420);
          }
          *(_WORD *)(v151 - 1) = bswap32(v153) >> 16;
LABEL_243:
          v151 += 4;
          if (!--v113) {
            goto LABEL_123;
          }
        }
      case 6:
        if (*((unsigned char *)a2 + 17) == 8)
        {
          if (v106 && result && v107)
          {
            if (v113)
            {
              v134 = v104 + 2;
              do
              {
                int v135 = v134[2];
                if (v134[2])
                {
                  if (v135 == 255)
                  {
                    *(v134 - 1) = *(unsigned char *)(v107 + *(v134 - 1));
                    unsigned __int8 *v134 = *(unsigned char *)(v107 + *v134);
                    LOBYTE(v136) = *(unsigned char *)(v107 + v134[1]);
                  }
                  else
                  {
                    int v137 = v135 ^ 0xFF;
                    int v138 = *(unsigned __int16 *)(v3 + 424) * (v135 ^ 0xFF)
                         + *(unsigned __int8 *)(v106 + *(v134 - 1)) * v135
                         + 128;
                    unsigned int v139 = v138 + BYTE1(v138);
                    if ((v112 & 0x2000) != 0) {
                      v139 >>= 8;
                    }
                    else {
                      LOBYTE(v139) = *(unsigned char *)(result + BYTE1(v139));
                    }
                    *(v134 - 1) = v139;
                    int v140 = *(unsigned __int16 *)(v3 + 426) * v137 + *(unsigned __int8 *)(v106 + *v134) * v135 + 128;
                    unsigned int v141 = v140 + BYTE1(v140);
                    if ((v112 & 0x2000) != 0) {
                      v141 >>= 8;
                    }
                    else {
                      LOBYTE(v141) = *(unsigned char *)(result + BYTE1(v141));
                    }
                    unsigned __int8 *v134 = v141;
                    int v142 = *(unsigned __int16 *)(v3 + 428) * v137 + *(unsigned __int8 *)(v106 + v134[1]) * v135 + 128;
                    unsigned int v136 = v142 + BYTE1(v142);
                    if ((v112 & 0x2000) != 0) {
                      v136 >>= 8;
                    }
                    else {
                      LOBYTE(v136) = *(unsigned char *)(result + BYTE1(v136));
                    }
                  }
                }
                else
                {
                  *(v134 - 1) = *(unsigned char *)(v3 + 414);
                  unsigned __int8 *v134 = *(unsigned char *)(v3 + 416);
                  LOBYTE(v136) = *(unsigned char *)(v3 + 418);
                }
                v134[1] = v136;
                v134 += 4;
                --v113;
              }
              while (v113);
            }
          }
          else if (v113)
          {
            v325 = v104 + 2;
            do
            {
              int v326 = v325[2];
              if (v326 != 255)
              {
                if (v325[2])
                {
                  __int16 v328 = *(_WORD *)(v3 + 414) * (v326 ^ 0xFF) + *(v325 - 1) * (_WORD)v326 + 128;
                  *(v325 - 1) = (unsigned __int16)(v328 + HIBYTE(v328)) >> 8;
                  __int16 v329 = *(_WORD *)(v3 + 416) * (v326 ^ 0xFF) + *v325 * (_WORD)v326 + 128;
                  unsigned __int8 *v325 = (unsigned __int16)(v329 + HIBYTE(v329)) >> 8;
                  int v330 = *(unsigned __int16 *)(v3 + 418) * (v326 ^ 0xFF) + v325[1] * v326 + 128;
                  unsigned int v327 = (v330 + BYTE1(v330)) >> 8;
                }
                else
                {
                  *(v325 - 1) = *(unsigned char *)(v3 + 414);
                  unsigned __int8 *v325 = *(unsigned char *)(v3 + 416);
                  LOBYTE(v327) = *(unsigned char *)(v3 + 418);
                }
                v325[1] = v327;
              }
              v325 += 4;
              --v113;
            }
            while (v113);
          }
          goto LABEL_123;
        }
        if (!v108 || !v109 || !v110)
        {
          if (v113)
          {
            v335 = v104 + 4;
            do
            {
              unsigned int v336 = __rev16(*(unsigned __int16 *)(v335 + 3));
              if (v336 != 0xFFFF)
              {
                if (v336)
                {
                  unsigned int v337 = __rev16(*(unsigned __int16 *)(v335 - 1));
                  unsigned int v338 = __rev16(*(unsigned __int16 *)(v335 + 1));
                  unsigned int v339 = (v336 ^ 0xFFFF) * *(unsigned __int16 *)(v3 + 414)
                       + __rev16(*(unsigned __int16 *)(v335 - 3)) * v336
                       + 0x8000;
                  unsigned int v340 = v339 + HIWORD(v339);
                  *(v335 - 3) = HIBYTE(v340);
                  *(v335 - 2) = BYTE2(v340);
                  unsigned int v341 = (v336 ^ 0xFFFF) * *(unsigned __int16 *)(v3 + 416) + v337 * v336 + 0x8000;
                  unsigned int v342 = v341 + HIWORD(v341);
                  *(v335 - 1) = HIBYTE(v342);
                  unsigned __int8 *v335 = BYTE2(v342);
                  unsigned int v343 = (v336 ^ 0xFFFF) * *(unsigned __int16 *)(v3 + 418) + v338 * v336 + 0x8000;
                  unsigned int v344 = v343 + HIWORD(v343);
                  v335[1] = HIBYTE(v344);
                  v335[2] = BYTE2(v344);
                }
                else
                {
                  *(_WORD *)(v335 - 3) = bswap32(*(unsigned __int16 *)(v3 + 414)) >> 16;
                  *(_WORD *)(v335 - 1) = bswap32(*(unsigned __int16 *)(v3 + 416)) >> 16;
                  *(_WORD *)(v335 + 1) = bswap32(*(unsigned __int16 *)(v3 + 418)) >> 16;
                }
              }
              v335 += 8;
              --v113;
            }
            while (v113);
          }
          goto LABEL_123;
        }
        if (!v113) {
          goto LABEL_123;
        }
        v158 = v104 + 4;
        break;
      default:
        goto LABEL_123;
    }
    do
    {
      unsigned int v159 = __rev16(*(unsigned __int16 *)(v158 + 3));
      if (v159)
      {
        if (v159 != 0xFFFF)
        {
          int v161 = v159 ^ 0xFFFF;
          unsigned int v162 = (v159 ^ 0xFFFF) * *(unsigned __int16 *)(v3 + 424)
               + v159 * *(unsigned __int16 *)(*(void *)(v110 + 8 * (*(v158 - 2) >> v111)) + 2 * *(v158 - 3))
               + 0x8000;
          unsigned int v163 = v162 + HIWORD(v162);
          unsigned int v164 = HIBYTE(v163);
          if ((v112 & 0x2000) != 0)
          {
            unsigned int v165 = HIWORD(v163);
          }
          else
          {
            unsigned int v165 = *(unsigned __int16 *)(*(void *)(v109 + 8 * (BYTE2(v163) >> v111)) + 2 * v164);
            unsigned int v164 = v165 >> 8;
          }
          *(v158 - 3) = v164;
          *(v158 - 2) = v165;
          unsigned int v166 = v161 * *(unsigned __int16 *)(v3 + 426)
               + v159 * *(unsigned __int16 *)(*(void *)(v110 + 8 * (*v158 >> v111)) + 2 * *(v158 - 1))
               + 0x8000;
          unsigned int v167 = v166 + HIWORD(v166);
          unsigned int v168 = HIBYTE(v167);
          if ((v112 & 0x2000) != 0)
          {
            unsigned int v169 = HIWORD(v167);
          }
          else
          {
            unsigned int v169 = *(unsigned __int16 *)(*(void *)(v109 + 8 * (BYTE2(v167) >> v111)) + 2 * v168);
            unsigned int v168 = v169 >> 8;
          }
          *(v158 - 1) = v168;
          unsigned __int8 *v158 = v169;
          CFStringRef result = *(unsigned __int16 *)(*(void *)(v110 + 8 * (v158[2] >> v111)) + 2 * v158[1]);
          unsigned int v170 = v161 * *(unsigned __int16 *)(v3 + 428)
               + v159 * result
               + 0x8000
               + ((v161 * *(unsigned __int16 *)(v3 + 428) + v159 * result + 0x8000) >> 16);
          unsigned int v171 = HIBYTE(v170);
          if ((v112 & 0x2000) != 0)
          {
            unsigned int v172 = HIWORD(v170);
          }
          else
          {
            unsigned int v172 = *(unsigned __int16 *)(*(void *)(v109 + 8 * (BYTE2(v170) >> v111)) + 2 * v171);
            unsigned int v171 = v172 >> 8;
          }
          v158[1] = v171;
          v158[2] = v172;
          goto LABEL_265;
        }
        *(_WORD *)(v158 - 3) = bswap32(*(unsigned __int16 *)(*(void *)(v108 + 8 * (*(v158 - 2) >> v111))
                                                           + 2 * *(v158 - 3))) >> 16;
        *(_WORD *)(v158 - 1) = bswap32(*(unsigned __int16 *)(*(void *)(v108 + 8 * (*v158 >> v111))
                                                           + 2 * *(v158 - 1))) >> 16;
        unsigned int v160 = *(unsigned __int16 *)(*(void *)(v108 + 8 * (v158[2] >> v111)) + 2 * v158[1]);
      }
      else
      {
        *(_WORD *)(v158 - 3) = bswap32(*(unsigned __int16 *)(v3 + 414)) >> 16;
        *(_WORD *)(v158 - 1) = bswap32(*(unsigned __int16 *)(v3 + 416)) >> 16;
        unsigned int v160 = *(unsigned __int16 *)(v3 + 418);
      }
      *(_WORD *)(v158 + 1) = bswap32(v160) >> 16;
LABEL_265:
      v158 += 8;
      --v113;
    }
    while (v113);
  }
LABEL_123:
  int v89 = *(_DWORD *)(v3 + 88);
  if ((v89 & 0x602000) != 0x2000) {
    goto LABEL_159;
  }
  if ((v89 & 0x80) != 0)
  {
    if (*(_WORD *)(v3 + 384)) {
      goto LABEL_159;
    }
    int v90 = *(unsigned __int8 *)(v3 + 391);
    if ((v90 & 4) != 0) {
      goto LABEL_159;
    }
  }
  else
  {
    int v90 = *(unsigned __int8 *)(v3 + 391);
  }
  if (v90 != 3)
  {
    if ((v91 = *(unsigned __int8 **)(v3 + 328),
          uint64_t v93 = *(void *)(v3 + 456),
          uint64_t v92 = *(void *)(v3 + 464),
          int v94 = *(_DWORD *)(v3 + 448),
          unsigned int v95 = *a2,
          unsigned int v96 = *((unsigned __int8 *)a2 + 17),
          v96 <= 8)
      && v93
      || v96 == 16 && v92)
    {
      v97 = v91 + 1;
      switch(*((unsigned char *)a2 + 16))
      {
        case 0:
          if (v96 == 2 && v95)
          {
            unsigned int v98 = 0;
            CFIndex v99 = v91 + 1;
            do
            {
              unsigned int v100 = *v99;
              unint64_t v101 = v100 & 0xC;
              int v102 = (v100 & 0xC) >> 2;
              CFStringRef result = (*(unsigned __int8 *)(v93
                                           + ((4 * v101) & 0xFFFFFF3F | ((v102 & 3) << 6) | (v101 >> 2) | v101)) >> 4) & 0xC;
              *v99++ = (*(unsigned char *)(v93
                                 + (((v100 & 0x30) >> 2) & 0xFFFFFF3F | ((((v100 & 0x30) >> 4) & 3) << 6) | ((v100 & 0x30) >> 4) | (unint64_t)(v100 & 0x30))) >> 2) & 0x30 | *(unsigned char *)(v93 + ((v100 >> 6) | ((v100 & 0xC0) >> 4) | ((v100 & 0xC0) >> 2) | (unint64_t)(v100 & 0xC0))) & 0xC0 | (*(unsigned char *)(v93 + ((4 * v101) & 0xFFFFFF3F | ((v102 & 3) << 6) | (v101 >> 2) | v101)) >> 4) & 0xC | (*(unsigned char *)(v93 + 85 * (v100 & 3)) >> 6);
              v98 += 4;
            }
            while (v98 < v95);
            unsigned int v96 = *((unsigned __int8 *)a2 + 17);
          }
          if (v96 == 4)
          {
            if (v95)
            {
              for (unsigned int i = 0; i < v95; i += 2)
              {
                unsigned __int8 *v97 = *(unsigned char *)(v93 + (*v97 & 0xF0 | ((unint64_t)*v97 >> 4))) & 0xF0 | (*(unsigned char *)(v93 + (*v97 & 0xF | (16 * (*v97 & 0xF)))) >> 4);
                ++v97;
              }
            }
          }
          else if (v96 == 8)
          {
            for (; v95; --v95)
            {
              unsigned __int8 *v97 = *(unsigned char *)(v93 + *v97);
              ++v97;
            }
          }
          else if (v96 == 16 && v95)
          {
            v103 = v91 + 2;
            do
            {
              *(_WORD *)(v103 - 1) = bswap32(*(unsigned __int16 *)(*(void *)(v92 + 8 * (*v103 >> v94))
                                                                 + 2 * *(v103 - 1))) >> 16;
              v103 += 2;
              --v95;
            }
            while (v95);
          }
          break;
        case 2:
          if (v96 == 8)
          {
            for (; v95; --v95)
            {
              unsigned __int8 *v97 = *(unsigned char *)(v93 + *v97);
              v97[1] = *(unsigned char *)(v93 + v97[1]);
              v97[2] = *(unsigned char *)(v93 + v97[2]);
              v97 += 3;
            }
          }
          else if (v95)
          {
            v365 = v91 + 3;
            do
            {
              *((_WORD *)v365 - 1) = bswap32(*(unsigned __int16 *)(*(void *)(v92 + 8 * (*(v365 - 1) >> v94))
                                                                 + 2 * *(v365 - 2))) >> 16;
              *(_WORD *)v365 = bswap32(*(unsigned __int16 *)(*(void *)(v92 + 8 * (v365[1] >> v94)) + 2 * *v365)) >> 16;
              *((_WORD *)v365 + 1) = bswap32(*(unsigned __int16 *)(*(void *)(v92 + 8 * (v365[3] >> v94))
                                                                 + 2 * v365[2])) >> 16;
              v365 += 6;
              --v95;
            }
            while (v95);
          }
          break;
        case 4:
          if (v96 == 8)
          {
            for (; v95; --v95)
            {
              unsigned __int8 *v97 = *(unsigned char *)(v93 + *v97);
              v97 += 2;
            }
          }
          else if (v95)
          {
            v366 = v91 + 2;
            do
            {
              *(_WORD *)(v366 - 1) = bswap32(*(unsigned __int16 *)(*(void *)(v92 + 8 * (*v366 >> v94))
                                                                 + 2 * *(v366 - 1))) >> 16;
              v366 += 4;
              --v95;
            }
            while (v95);
          }
          break;
        case 6:
          if (v96 == 8)
          {
            for (; v95; --v95)
            {
              unsigned __int8 *v97 = *(unsigned char *)(v93 + *v97);
              v97[1] = *(unsigned char *)(v93 + v97[1]);
              v97[2] = *(unsigned char *)(v93 + v97[2]);
              v97 += 4;
            }
          }
          else if (v95)
          {
            v367 = v91 + 3;
            do
            {
              *((_WORD *)v367 - 1) = bswap32(*(unsigned __int16 *)(*(void *)(v92 + 8 * (*(v367 - 1) >> v94))
                                                                 + 2 * *(v367 - 2))) >> 16;
              *(_WORD *)v367 = bswap32(*(unsigned __int16 *)(*(void *)(v92 + 8 * (v367[1] >> v94)) + 2 * *v367)) >> 16;
              *((_WORD *)v367 + 1) = bswap32(*(unsigned __int16 *)(*(void *)(v92 + 8 * (v367[3] >> v94))
                                                                 + 2 * v367[2])) >> 16;
              v367 += 8;
              --v95;
            }
            while (v95);
          }
          break;
        default:
          break;
      }
    }
  }
LABEL_159:
  int v118 = *(_DWORD *)(v3 + 88);
  if ((~v118 & 0x40080) == 0 && (*((unsigned __int8 *)a2 + 16) | 2) == 6)
  {
    CFStringRef result = png_do_strip_channel((uint64_t)a2, (unsigned char *)(*(void *)(v3 + 328) + 1), 0);
    int v118 = *(_DWORD *)(v3 + 88);
  }
  if ((v118 & 0x800000) != 0 && (a2[4] & 4) != 0)
  {
    uint64_t v119 = *(void *)(v3 + 328);
    unsigned int v120 = *a2;
    int v121 = *((unsigned __int8 *)a2 + 17);
    if (v121 != 16)
    {
      if (v121 == 8)
      {
        uint64_t v122 = *(void *)(v3 + 472);
        if (v122)
        {
          if (v120)
          {
            uint64_t v123 = v119 + 1;
            if ((a2[4] & 2) != 0) {
              uint64_t v124 = 4;
            }
            else {
              uint64_t v124 = 2;
            }
            v125 = (unsigned char *)(v123 + (v124 - 1));
            do
            {
              unsigned char *v125 = *(unsigned char *)(v122 + *v125);
              v125 += v124;
              --v120;
            }
            while (v120);
          }
          goto LABEL_276;
        }
      }
LABEL_275:
      CFStringRef result = png_warning(v3, "png_do_encode_alpha: unexpected call");
      goto LABEL_276;
    }
    uint64_t v173 = *(void *)(v3 + 488);
    if (!v173) {
      goto LABEL_275;
    }
    if (v120)
    {
      int v174 = *(_DWORD *)(v3 + 448);
      if ((a2[4] & 2) != 0) {
        uint64_t v175 = 8;
      }
      else {
        uint64_t v175 = 4;
      }
      v176 = (unsigned __int8 *)((v175 - 4) + v119 + 4);
      do
      {
        *(_WORD *)(v176 - 1) = bswap32(*(unsigned __int16 *)(*(void *)(v173 + 8 * (*v176 >> v174))
                                                           + 2 * *(v176 - 1))) >> 16;
        v176 += v175;
        --v120;
      }
      while (v120);
    }
  }
LABEL_276:
  int v177 = *(_DWORD *)(v3 + 88);
  if ((v177 & 0x4000000) != 0 && *((unsigned char *)a2 + 17) == 16)
  {
    uint64_t v178 = *((void *)a2 + 1);
    if (v178 >= 1)
    {
      v179 = (unsigned __int8 *)(*(void *)(v3 + 328) + 1);
      v180 = &v179[v178];
      v181 = v179;
      do
      {
        *v181++ = *v179 + ((0xFFFF * (v179[1] - *v179) + 8388480) >> 24);
        v179 += 2;
      }
      while (v179 < v180);
      int v177 = *(_DWORD *)(v3 + 88);
    }
    *((unsigned char *)a2 + 17) = 8;
    int v182 = *((unsigned __int8 *)a2 + 18);
    *((unsigned char *)a2 + 19) = 8 * v182;
    *((void *)a2 + 1) = *a2 * v182;
  }
  if ((v177 & 0x400) != 0 && *((unsigned char *)a2 + 17) == 16)
  {
    uint64_t v183 = *((void *)a2 + 1);
    if (v183 >= 1)
    {
      v184 = (char *)(*(void *)(v3 + 328) + 1);
      v185 = &v184[v183];
      v186 = v184;
      do
      {
        char v187 = *v186;
        v186 += 2;
        *v184++ = v187;
      }
      while (v186 < v185);
      int v177 = *(_DWORD *)(v3 + 88);
    }
    *((unsigned char *)a2 + 17) = 8;
    int v188 = *((unsigned __int8 *)a2 + 18);
    *((unsigned char *)a2 + 19) = 8 * v188;
    *((void *)a2 + 1) = *a2 * v188;
  }
  if ((v177 & 0x40) != 0)
  {
    if (*((unsigned char *)a2 + 17) != 8)
    {
LABEL_308:
      if (*((void *)a2 + 1))
      {
        int v177 = *(_DWORD *)(v3 + 88);
        goto LABEL_310;
      }
      v380 = "png_do_quantize returned rowbytes=0";
LABEL_663:
      _cg_png_error((void (**)(void))v3, v380);
    }
    v189 = (unsigned char *)(*(void *)(v3 + 328) + 1);
    uint64_t v190 = *(void *)(v3 + 664);
    uint64_t v191 = *(void *)(v3 + 672);
    unsigned int v192 = *a2;
    unsigned int v193 = *a2;
    int v194 = *((unsigned __int8 *)a2 + 16);
    if (v190 && v194 == 2)
    {
      if (v193)
      {
        v195 = (unsigned __int8 *)(*(void *)(v3 + 328) + 1);
        do
        {
          *v189++ = *(unsigned char *)(v190
                             + ((*v195 << 7) & 0x7C00 | (32 * (((unint64_t)v195[1] >> 3) & 0x1F)) | ((unint64_t)v195[2] >> 3)));
          v195 += 3;
          --v193;
        }
        while (v193);
        goto LABEL_303;
      }
    }
    else
    {
      if (!v190 || v194 != 6)
      {
        if (v191 && v194 == 3 && v193)
        {
          do
          {
            unsigned char *v189 = *(unsigned char *)(v191 + *v189);
            ++v189;
            --v193;
          }
          while (v193);
        }
        goto LABEL_308;
      }
      if (v193)
      {
        v196 = (unsigned __int8 *)(*(void *)(v3 + 328) + 1);
        do
        {
          *v189++ = *(unsigned char *)(v190
                             + ((*v196 << 7) & 0x7C00 | (32 * (((unint64_t)v196[1] >> 3) & 0x1F)) | ((unint64_t)v196[2] >> 3)));
          v196 += 4;
          --v193;
        }
        while (v193);
LABEL_303:
        unsigned int v197 = *((unsigned __int8 *)a2 + 17);
        *((unsigned char *)a2 + 16) = 3;
        *((unsigned char *)a2 + 18) = 1;
        *((unsigned char *)a2 + 19) = v197;
        if (v197 < 8)
        {
          unint64_t v198 = (v197 * (unint64_t)v192 + 7) >> 3;
LABEL_307:
          *((void *)a2 + 1) = v198;
          goto LABEL_308;
        }
LABEL_306:
        unint64_t v198 = v192 * (unint64_t)(v197 >> 3);
        goto LABEL_307;
      }
    }
    *((unsigned char *)a2 + 16) = 3;
    *((_WORD *)a2 + 9) = 2049;
    unsigned int v197 = 8;
    goto LABEL_306;
  }
LABEL_310:
  if ((v177 & 0x200) != 0 && *((unsigned char *)a2 + 17) == 8 && *((unsigned char *)a2 + 16) != 3)
  {
    uint64_t v199 = *((void *)a2 + 1);
    if (v199 >= 1)
    {
      uint64_t v200 = *(void *)(v3 + 328);
      unint64_t v201 = v200 + 1 + v199 + v199;
      v202 = (char *)(v200 + v199);
      v203 = v202;
      do
      {
        char v204 = *v203--;
        *(unsigned char *)(v201 - 2) = v204;
        v201 -= 2;
        *(unsigned char *)(v201 + 1) = v204;
        BOOL v205 = v201 > (unint64_t)v202;
        v202 = v203;
      }
      while (v205);
      uint64_t v199 = *((void *)a2 + 1);
      int v177 = *(_DWORD *)(v3 + 88);
    }
    *((void *)a2 + 1) = 2 * v199;
    *((unsigned char *)a2 + 17) = 16;
    *((unsigned char *)a2 + 19) = 16 * *((unsigned char *)a2 + 18);
  }
  if ((v177 & 0x4000) != 0 && (*(unsigned char *)(v3 + 77) & 8) != 0)
  {
    CFStringRef result = (uint64_t)png_do_gray_to_rgb(a2, *(void *)(v3 + 328) + 1);
    int v177 = *(_DWORD *)(v3 + 88);
  }
  if ((v177 & 0x20) != 0)
  {
    CFStringRef result = png_do_invert((uint64_t)a2, (unsigned char *)(*(void *)(v3 + 328) + 1));
    int v177 = *(_DWORD *)(v3 + 88);
  }
  if ((v177 & 0x80000) != 0)
  {
    uint64_t v206 = *(void *)(v3 + 328);
    unsigned int v207 = *a2;
    int v208 = *((unsigned __int8 *)a2 + 16);
    if (v208 == 4)
    {
      if (*((unsigned char *)a2 + 17) == 8)
      {
        if (v207)
        {
          v210 = (unsigned char *)(v206 + *((void *)a2 + 1));
          do
          {
            unsigned char *v210 = ~*v210;
            v210 -= 2;
            --v207;
          }
          while (v207);
        }
      }
      else if (v207)
      {
        v212 = (unsigned char *)(v206 + *((void *)a2 + 1));
        do
        {
          unsigned char *v212 = ~*v212;
          *(v212 - 1) = ~*(v212 - 1);
          v212 -= 4;
          --v207;
        }
        while (v207);
      }
    }
    else if (v208 == 6)
    {
      if (*((unsigned char *)a2 + 17) == 8)
      {
        if (v207)
        {
          v209 = (unsigned char *)(v206 + *((void *)a2 + 1));
          do
          {
            unsigned char *v209 = ~*v209;
            v209 -= 4;
            --v207;
          }
          while (v207);
        }
      }
      else if (v207)
      {
        v211 = (unsigned char *)(v206 + *((void *)a2 + 1));
        do
        {
          unsigned char *v211 = ~*v211;
          *(v211 - 1) = ~*(v211 - 1);
          v211 -= 8;
          --v207;
        }
        while (v207);
      }
    }
  }
  int v213 = *(_DWORD *)(v3 + 88);
  if ((v213 & 8) != 0)
  {
    int v214 = *((unsigned __int8 *)a2 + 16);
    if (v214 != 3)
    {
      uint64_t v215 = *(void *)(v3 + 328);
      int v383 = 0;
      uint64_t v382 = 0;
      int v216 = *((unsigned __int8 *)a2 + 17);
      if ((v214 & 2) != 0)
      {
        int v217 = *(unsigned __int8 *)(v3 + 509);
        int v219 = v216 - *(unsigned __int8 *)(v3 + 511);
        LODWORD(v382) = v216 - *(unsigned __int8 *)(v3 + 510);
        HIDWORD(v382) = v219;
        int v218 = 3;
      }
      else
      {
        int v217 = *(unsigned __int8 *)(v3 + 512);
        int v218 = 1;
      }
      v220 = (unsigned char *)(v215 + 1);
      int v381 = v216 - v217;
      if ((v214 & 4) != 0) {
        *(&v381 + v218++) = v216 - *(unsigned __int8 *)(v3 + 513);
      }
      uint64_t v221 = 0;
      int v222 = 0;
      do
      {
        int v223 = *(int *)((char *)&v381 + v221);
        BOOL v224 = v223 > 0;
        CFStringRef result = v223 < v216;
        if ((v224 & result) == 0) {
          int v223 = 0;
        }
        *(int *)((char *)&v381 + v221) = v223;
        if ((v224 & result) != 0) {
          int v222 = 1;
        }
        v221 += 4;
      }
      while (4 * v218 != v221);
      if (v222)
      {
        HIDWORD(v225) = v216;
        LODWORD(v225) = v216 - 2;
        switch((v225 >> 1))
        {
          case 0u:
            uint64_t v226 = *((void *)a2 + 1);
            if (v226 >= 1)
            {
              v227 = &v220[v226];
              do
              {
                unsigned char *v220 = (*v220 >> 1) & 0x55;
                ++v220;
              }
              while (v220 < v227);
            }
            break;
          case 1u:
            uint64_t v228 = *((void *)a2 + 1);
            if (v228 >= 1)
            {
              v229 = &v220[v228];
              char v230 = v381;
              unsigned int v231 = (0xFu >> v381) | (16 * (0xFu >> v381));
              do
              {
                unsigned char *v220 = (*v220 >> v230) & v231;
                ++v220;
              }
              while (v220 < v229);
            }
            break;
          case 3u:
            uint64_t v232 = *((void *)a2 + 1);
            if (v232 >= 1)
            {
              int v233 = 0;
              v234 = &v220[v232];
              do
              {
                int v235 = *v220 >> *(&v381 + v233);
                if (v233 + 1 < v218) {
                  ++v233;
                }
                else {
                  int v233 = 0;
                }
                *v220++ = v235;
              }
              while (v220 < v234);
            }
            break;
          case 7u:
            uint64_t v236 = *((void *)a2 + 1);
            if (v236 >= 1)
            {
              int v237 = 0;
              v238 = &v220[v236];
              do
              {
                unsigned int v239 = __rev16(*(unsigned __int16 *)v220) >> *(&v381 + v237);
                if (v237 + 1 < v218) {
                  ++v237;
                }
                else {
                  int v237 = 0;
                }
                *(_WORD *)v220 = __rev16(v239);
                v220 += 2;
              }
              while (v220 < v238);
            }
            break;
          default:
            break;
        }
        int v213 = *(_DWORD *)(v3 + 88);
      }
    }
  }
  if ((v213 & 4) != 0)
  {
    unsigned int v240 = *((unsigned __int8 *)a2 + 17);
    if (v240 <= 7)
    {
      uint64_t v241 = *(void *)(v3 + 328);
      uint64_t v242 = v241 + 1;
      uint64_t v243 = *a2;
      if (v240 == 4)
      {
        if (v243)
        {
          v249 = (unsigned char *)(v241 + v243);
          v250 = (unsigned __int8 *)(v242 + ((v243 - 1) >> 1));
          int v251 = 4 * (*a2 & 1);
          unsigned int v252 = *a2;
          do
          {
            int v253 = *v250 >> v251;
            BOOL v54 = v251 == 0;
            BOOL v254 = v251 == 0;
            *v249-- = v253 & 0xF;
            uint64_t v255 = !v54;
            v250 -= v255;
            int v251 = 4 * v254;
            --v252;
          }
          while (v252);
        }
      }
      else if (v240 == 2)
      {
        if (v243)
        {
          v256 = (unsigned char *)(v241 + v243);
          v257 = (unsigned __int8 *)(v242 + ((v243 - 1) >> 2));
          int v258 = ~(2 * v243 + 6) & 6;
          unsigned int v259 = *a2;
          do
          {
            *v256-- = (*v257 >> v258) & 3;
            BOOL v54 = v258 == 6;
            uint64_t v260 = v258 == 6;
            v258 += 2;
            if (v54) {
              int v258 = 0;
            }
            v257 -= v260;
            --v259;
          }
          while (v259);
        }
      }
      else if (v240 == 1 && v243)
      {
        int v244 = -(int)v243 & 7;
        v245 = (unsigned char *)(v241 + v243);
        v246 = (unsigned __int8 *)(v242 + ((v243 - 1) >> 3));
        unsigned int v247 = *a2;
        do
        {
          *v245-- = (*v246 >> v244) & 1;
          uint64_t v248 = v244 == 7;
          if (v244 == 7) {
            int v244 = 0;
          }
          else {
            ++v244;
          }
          v246 -= v248;
          --v247;
        }
        while (v247);
      }
      *((unsigned char *)a2 + 17) = 8;
      int v261 = *((unsigned __int8 *)a2 + 18);
      *((unsigned char *)a2 + 19) = 8 * v261;
      *((void *)a2 + 1) = (v243 * v261);
    }
  }
  if (*((unsigned char *)a2 + 16) == 3 && (*(_DWORD *)(v3 + 380) & 0x80000000) == 0) {
    CFStringRef result = png_do_check_palette_indexes(v3, (uint64_t)a2);
  }
  int v262 = *(_DWORD *)(v3 + 88);
  if (v262)
  {
    CFStringRef result = (uint64_t)png_do_bgr((int *)a2, (__int16 *)(*(void *)(v3 + 328) + 1));
    int v262 = *(_DWORD *)(v3 + 88);
    if ((v262 & 0x10000) == 0)
    {
LABEL_415:
      if ((v262 & 0x8000) == 0) {
        goto LABEL_467;
      }
      goto LABEL_419;
    }
  }
  else if ((v262 & 0x10000) == 0)
  {
    goto LABEL_415;
  }
  CFStringRef result = png_do_packswap((uint64_t)a2, (unsigned char *)(*(void *)(v3 + 328) + 1));
  int v262 = *(_DWORD *)(v3 + 88);
  if ((v262 & 0x8000) == 0) {
    goto LABEL_467;
  }
LABEL_419:
  uint64_t v263 = *(void *)(v3 + 328);
  uint64_t v264 = v263 + 1;
  unsigned int v265 = *(unsigned __int16 *)(v3 + 402);
  int v266 = *(_DWORD *)(v3 + 80);
  uint64_t v267 = *a2;
  if (*((unsigned char *)a2 + 16) == 2)
  {
    int v273 = *((unsigned __int8 *)a2 + 17);
    if (v273 == 16)
    {
      if ((v266 & 0x80) != 0)
      {
        uint64_t v297 = v264 + 6 * v267 + 2 * v267;
        if (v267 >= 2)
        {
          int v298 = v267 - 1;
          v299 = (unsigned char *)(6 * v267 + v263 - 2);
          __int16 v300 = __rev16(v265);
          do
          {
            *(_WORD *)(v297 - 2) = v300;
            *(unsigned char *)(v297 - 3) = v299[2];
            *(unsigned char *)(v297 - 4) = v299[1];
            *(unsigned char *)(v297 - 5) = *v299;
            *(unsigned char *)(v297 - 6) = *(v299 - 1);
            *(unsigned char *)(v297 - 7) = *(v299 - 2);
            *(unsigned char *)(v297 - 8) = *(v299 - 3);
            v297 -= 8;
            v299 -= 6;
            --v298;
          }
          while (v298);
        }
        *(_WORD *)(v297 - 2) = __rev16(v265);
      }
      else if (v267)
      {
        v280 = (unsigned char *)(v263 + 6 * v267 - 2);
        v281 = (unsigned char *)(v263 + 8 * v267 - 3);
        unsigned int v282 = *a2;
        do
        {
          v281[3] = v280[2];
          v281[2] = v280[1];
          v281[1] = *v280;
          unsigned char *v281 = *(v280 - 1);
          *(v281 - 1) = *(v280 - 2);
          *(v281 - 2) = *(v280 - 3);
          *(v281 - 3) = v265;
          *(v281 - 4) = BYTE1(v265);
          v280 -= 6;
          v281 -= 8;
          --v282;
        }
        while (v282);
      }
      char v287 = 3;
      char v288 = 64;
    }
    else
    {
      if (v273 != 8) {
        goto LABEL_467;
      }
      if ((v266 & 0x80) != 0)
      {
        uint64_t v290 = v264 + v267 + 3 * v267;
        if (v267 >= 2)
        {
          int v291 = v267 - 1;
          v292 = (unsigned char *)(v263 + 3 * v267);
          do
          {
            *(unsigned char *)(v290 - 1) = v265;
            *(unsigned char *)(v290 - 2) = *v292;
            *(unsigned char *)(v290 - 3) = *(v292 - 1);
            *(unsigned char *)(v290 - 4) = *(v292 - 2);
            v290 -= 4;
            v292 -= 3;
            --v291;
          }
          while (v291);
        }
        *(unsigned char *)(v290 - 1) = v265;
      }
      else if (v267)
      {
        v274 = (unsigned char *)(v263 + 3 * v267);
        v275 = (unsigned char *)(v263 + 4 * v267 - 1);
        unsigned int v276 = *a2;
        do
        {
          v275[1] = *v274;
          unsigned char *v275 = *(v274 - 1);
          *(v275 - 1) = *(v274 - 2);
          *(v275 - 2) = v265;
          v274 -= 3;
          v275 -= 4;
          --v276;
        }
        while (v276);
      }
      char v287 = 2;
      char v288 = 32;
    }
    char v289 = 4;
  }
  else
  {
    if (*((unsigned char *)a2 + 16)) {
      goto LABEL_467;
    }
    int v268 = *((unsigned __int8 *)a2 + 17);
    if (v268 == 16)
    {
      if ((v266 & 0x80) != 0)
      {
        uint64_t v293 = v264 + 2 * v267 + 2 * v267;
        __int16 v294 = __rev16(v265);
        if (v267 >= 2)
        {
          int v295 = v267 - 1;
          v296 = (unsigned char *)(v263 + 2 * v267);
          do
          {
            *(_WORD *)(v293 - 2) = v294;
            *(unsigned char *)(v293 - 3) = *v296;
            *(unsigned char *)(v293 - 4) = *(v296 - 1);
            v293 -= 4;
            v296 -= 2;
            --v295;
          }
          while (v295);
        }
        *(_WORD *)(v293 - 2) = v294;
      }
      else if (v267)
      {
        v277 = (unsigned char *)(v263 + 2 * v267);
        v278 = (unsigned char *)(v263 + 4 * v267 - 1);
        unsigned int v279 = *a2;
        do
        {
          v278[1] = *v277;
          unsigned char *v278 = *(v277 - 1);
          *(v278 - 1) = v265;
          *(v278 - 2) = BYTE1(v265);
          v277 -= 2;
          v278 -= 4;
          --v279;
        }
        while (v279);
      }
      char v289 = 2;
      char v288 = 32;
      char v287 = 2;
    }
    else
    {
      if (v268 != 8) {
        goto LABEL_467;
      }
      if ((v266 & 0x80) != 0)
      {
        uint64_t v283 = v264 + v267 + v267;
        if (v267 >= 2)
        {
          v284 = (char *)(v263 + v267);
          int v285 = v267 - 1;
          do
          {
            *(unsigned char *)(v283 - 1) = v265;
            char v286 = *v284--;
            *(unsigned char *)(v283 - 2) = v286;
            v283 -= 2;
            --v285;
          }
          while (v285);
        }
        *(unsigned char *)(v283 - 1) = v265;
      }
      else if (v267)
      {
        v269 = (unsigned char *)(v263 + 2 * v267);
        v270 = (char *)(v263 + v267);
        unsigned int v271 = *a2;
        do
        {
          char v272 = *v270--;
          unsigned char *v269 = v272;
          *(v269 - 1) = v265;
          v269 -= 2;
          --v271;
        }
        while (v271);
      }
      char v287 = 1;
      char v288 = 16;
      char v289 = 2;
    }
  }
  *((unsigned char *)a2 + 18) = v289;
  *((unsigned char *)a2 + 19) = v288;
  *((void *)a2 + 1) = (v267 << v287);
  int v262 = *(_DWORD *)(v3 + 88);
LABEL_467:
  if ((v262 & 0x20000) != 0)
  {
    uint64_t v301 = *(void *)(v3 + 328);
    unsigned int v302 = *a2;
    int v303 = *((unsigned __int8 *)a2 + 16);
    if (v303 == 4)
    {
      if (*((unsigned char *)a2 + 17) == 8)
      {
        if (v302)
        {
          v306 = (char *)(v301 + *((void *)a2 + 1));
          do
          {
            char v307 = *v306;
            char *v306 = *(v306 - 1);
            *(v306 - 1) = v307;
            v306 -= 2;
            --v302;
          }
          while (v302);
        }
      }
      else if (v302)
      {
        v309 = (__int32 *)(*((void *)a2 + 1) + v301 - 3);
        do
        {
          a3.i32[0] = *v309;
          int16x8_t v310 = (int16x8_t)vmovl_u8(a3);
          *(int8x8_t *)v310.i8 = vext_s8(*(int8x8_t *)v310.i8, *(int8x8_t *)v310.i8, 4uLL);
          a3 = (uint8x8_t)vmovn_s16(v310);
          *v309-- = a3.i32[0];
          --v302;
        }
        while (v302);
      }
    }
    else if (v303 == 6)
    {
      if (*((unsigned char *)a2 + 17) == 8)
      {
        if (v302)
        {
          v304 = (__int32 *)(*((void *)a2 + 1) + v301 - 3);
          do
          {
            a3.i32[0] = *v304;
            int16x8_t v305 = (int16x8_t)vmovl_u8(a3);
            *(int8x8_t *)v305.i8 = vext_s8(*(int8x8_t *)v305.i8, *(int8x8_t *)v305.i8, 6uLL);
            a3 = (uint8x8_t)vmovn_s16(v305);
            *v304-- = a3.i32[0];
            --v302;
          }
          while (v302);
        }
      }
      else if (v302)
      {
        v308 = (int8x8_t *)(*((void *)a2 + 1) + v301 - 7);
        do
        {
          int8x8_t *v308 = vext_s8(*v308, *v308, 6uLL);
          --v308;
          --v302;
        }
        while (v302);
      }
    }
  }
  int v311 = *(_DWORD *)(v3 + 88);
  if ((v311 & 0x10) != 0)
  {
    CFStringRef result = png_do_swap((uint64_t)a2, (char *)(*(void *)(v3 + 328) + 1));
    int v311 = *(_DWORD *)(v3 + 88);
  }
  if ((v311 & 0x100000) != 0)
  {
    v312 = *(uint64_t (**)(uint64_t, unsigned int *, uint64_t))(v3 + 48);
    if (v312) {
      CFStringRef result = v312(v3, a2, *(void *)(v3 + 328) + 1);
    }
    if (*(unsigned char *)(v3 + 72)) {
      *((unsigned char *)a2 + 17) = *(unsigned char *)(v3 + 72);
    }
    char v313 = *(unsigned char *)(v3 + 73);
    if (v313) {
      *((unsigned char *)a2 + 18) = v313;
    }
    else {
      char v313 = *((unsigned char *)a2 + 18);
    }
    unsigned __int8 v314 = v313 * *((unsigned char *)a2 + 17);
    *((unsigned char *)a2 + 19) = v314;
    BOOL v315 = v314 >= 8u;
    unint64_t v316 = (*a2 * (unint64_t)v314 + 7) >> 3;
    unint64_t v317 = *a2 * (unint64_t)(v314 >> 3);
    if (!v315) {
      unint64_t v317 = v316;
    }
    *((void *)a2 + 1) = v317;
  }
  return result;
}

char *png_combine_row(char *result, char *__dst, int a3)
{
  unint64_t v3 = result[399];
  if (!result[399]) {
    _cg_png_error((void (**)(void))result, "internal row logic error");
  }
  uint64_t v4 = __dst;
  uint64_t v5 = *((void *)result + 41);
  unint64_t v6 = *((unsigned int *)result + 70);
  uint64_t v7 = result[389];
  uint64_t v8 = *((void *)result + 44);
  if (v8)
  {
    unint64_t v9 = (v6 * (unint64_t)result[399] + 7) >> 3;
    if (v3 >= 8) {
      unint64_t v9 = v6 * (unint64_t)(v3 >> 3);
    }
    if (v8 != v9) {
      _cg_png_error((void (**)(void))result, "internal row size calculation error");
    }
  }
  if (!v6) {
    _cg_png_error((void (**)(void))result, "internal row width error");
  }
  unsigned int v10 = (char *)(v5 + 1);
  unint64_t v11 = v6 * (unint64_t)result[399];
  unint64_t v12 = v3 >> 3;
  char v13 = v11 & 7;
  if ((v11 & 7) != 0)
  {
    unint64_t v14 = v12 * (unint64_t)v6;
    if (v3 <= 7) {
      unint64_t v14 = (v11 + 7) >> 3;
    }
    uint64_t v15 = &__dst[v14 - 1];
    char v16 = *v15;
    unsigned int v17 = 0xFFu >> v13;
    int v18 = 255 << v13;
    if (result[90]) {
      char v19 = v18;
    }
    else {
      char v19 = v17;
    }
  }
  else
  {
    uint64_t v15 = 0;
    char v16 = 0;
    char v19 = 0;
  }
  if (!result[388]) {
    goto LABEL_21;
  }
  int v20 = *((_DWORD *)result + 22);
  if ((v20 & 2) == 0 || v7 > 5) {
    goto LABEL_21;
  }
  if (a3 != 1)
  {
    if (!a3)
    {
      int v21 = v7 & 1;
      goto LABEL_29;
    }
LABEL_21:
    if (v3 <= 7) {
      size_t v22 = (v11 + 7) >> 3;
    }
    else {
      size_t v22 = v12 * (unint64_t)v6;
    }
    CFStringRef result = (char *)memcpy(__dst, v10, v22);
LABEL_25:
    if (v15) {
      char *v15 = *v15 & ~v19 | v19 & v16;
    }
    return result;
  }
  if ((v7 & 1) == 0) {
    goto LABEL_21;
  }
  int v21 = 1;
LABEL_29:
  unsigned int v23 = (v21 << (3 - ((v7 + 1) >> 1))) & 7;
  if (v6 <= v23) {
    return result;
  }
  if (v3 <= 7)
  {
    unint64_t v24 = 8 / v3;
    uint64_t v25 = 1;
    if (v3 != 2) {
      uint64_t v25 = 2;
    }
    if (v3 == 1) {
      uint64_t v26 = 0;
    }
    else {
      uint64_t v26 = v25;
    }
    char v27 = (char *)&png_combine_row_row_mask + 24 * v26 + 4 * v7 + 72;
    if (a3) {
      char v27 = (char *)&png_combine_row_display_mask + 12 * v26 + ((2 * (int)v7) & 0x1FCLL) + 36;
    }
    char v28 = (char *)&png_combine_row_display_mask + 12 * v26 + ((2 * (int)v7) & 0x1FCLL);
    if (!a3) {
      char v28 = (char *)&png_combine_row_row_mask + 24 * v26 + 4 * result[389];
    }
    if ((v20 & 0x10000) == 0) {
      char v28 = v27;
    }
    int v29 = *(_DWORD *)v28;
    while (1)
    {
      if ((_BYTE)v29)
      {
        if (v29 == 255) {
          char v30 = *v10;
        }
        else {
          char v30 = v29 & *v10 | *v4 & ~(_BYTE)v29;
        }
        unsigned char *v4 = v30;
      }
      BOOL v31 = v6 > v24;
      v6 -= v24;
      if (!v31) {
        break;
      }
      HIDWORD(v32) = v29;
      LODWORD(v32) = v29;
      int v29 = v32 >> 8;
      ++v4;
      ++v10;
    }
    goto LABEL_25;
  }
  if ((v3 & 7) != 0) {
    _cg_png_error((void (**)(void))result, "invalid user transform pixel depth");
  }
  uint64_t v33 = v23 * v12;
  unint64_t v34 = v6 * (unint64_t)v12 - v33;
  CFStringRef result = &__dst[v33];
  size_t v35 = &v10[v33];
  unint64_t v36 = (v12 << ((6 - v7) >> 1));
  if (v34 < v36) {
    LODWORD(v36) = v6 * v12 - v33;
  }
  if (a3) {
    size_t v37 = v36;
  }
  else {
    size_t v37 = v12;
  }
  unint64_t v38 = (v12 << ((7 - v7) >> 1));
  switch(v37)
  {
    case 1:
      __CFString *result = *v35;
      if (v34 > v38)
      {
        uint64_t v43 = v38 + v33;
        do
        {
          v34 -= v38;
          v4[v43] = v10[v43];
          v43 += v38;
        }
        while (v34 > v38);
      }
      break;
    case 2:
      while (1)
      {
        uint64_t v42 = &v4[v33];
        unsigned char *v42 = *(unsigned char *)(v5 + v33 + 1);
        v42[1] = *(unsigned char *)(v5 + v33 + 2);
        BOOL v31 = v34 > v38;
        v34 -= v38;
        if (!v31) {
          break;
        }
        v33 += v38;
        if (v34 <= 1)
        {
          v4[v33] = *(unsigned char *)(v5 + v33 + 1);
          return result;
        }
      }
      break;
    case 3:
      __CFString *result = *v35;
      result[1] = v35[1];
      result[2] = v35[2];
      if (v34 > v38)
      {
        uint64_t v39 = v5 + 3;
        uint64_t v40 = v38 + v33;
        do
        {
          char v41 = &v4[v40];
          v34 -= v38;
          *char v41 = *(unsigned char *)(v39 + v40 - 2);
          v41[1] = *(unsigned char *)(v39 + v40 - 1);
          v41[2] = *(unsigned char *)(v39 + v40);
          v40 += v38;
        }
        while (v34 > v38);
      }
      break;
    default:
      if (v37 > 0xF
        || (result & 1) != 0
        || (v35 & 1) != 0
        || (v37 & 1) != 0
        || (v38 & 1) != 0)
      {
        CFStringRef result = (char *)memcpy(result, v35, v37);
        if (v34 > v38)
        {
          uint64_t v53 = v38 + v33;
          unsigned int v54 = v6 * v12 - v33 - v38;
          do
          {
            unint64_t v55 = v34 - v38;
            if (v34 - v38 >= v37) {
              size_t v37 = v37;
            }
            else {
              size_t v37 = v54;
            }
            CFStringRef result = (char *)memcpy(&v4[v53], &v10[v53], v37);
            v53 += v38;
            v54 -= v38;
            v34 -= v38;
          }
          while (v55 > v38);
        }
      }
      else
      {
        unsigned int v44 = v38 - v37;
        if ((((v35 | v38) | (result | v37)) & 3) != 0)
        {
          uint64_t v45 = v44 >> 1;
          uint64_t v46 = v45;
          while (1)
          {
            unsigned int v47 = result;
            uint64_t v48 = v35;
            size_t v49 = v37;
            do
            {
              __int16 v50 = *(_WORD *)v48;
              v48 += 2;
              *v47++ = v50;
              v49 -= 2;
            }
            while (v49);
            BOOL v31 = v34 > v38;
            v34 -= v38;
            if (!v31) {
              break;
            }
            size_t v35 = &v48[v46 * 2];
            CFStringRef result = (char *)&v47[v46];
            if (v34 < v37)
            {
              uint64_t v51 = 0;
              uint64_t v52 = v45;
              do
              {
                *((unsigned char *)&v47[v52] + v51) = v48[v52 * 2 + v51];
                ++v51;
              }
              while (v34 != v51);
              return result;
            }
          }
        }
        else
        {
          uint64_t v56 = v44 >> 2;
          uint64_t v57 = v56;
          while (1)
          {
            uint64_t v58 = result;
            int v59 = v35;
            size_t v60 = v37;
            do
            {
              int v61 = *(_DWORD *)v59;
              v59 += 4;
              *v58++ = v61;
              v60 -= 4;
            }
            while (v60);
            BOOL v31 = v34 > v38;
            v34 -= v38;
            if (!v31) {
              break;
            }
            size_t v35 = &v59[v57 * 4];
            CFStringRef result = (char *)&v58[v57];
            if (v34 < v37)
            {
              uint64_t v62 = 0;
              uint64_t v63 = v56;
              do
              {
                *((unsigned char *)&v58[v63] + v62) = v59[v63 * 4 + v62];
                ++v62;
              }
              while (v34 != v62);
              return result;
            }
          }
        }
      }
      break;
  }
  return result;
}

uint64_t png_read_IDAT_data(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = MEMORY[0x1F4188790](a1, a2);
  uint64_t v5 = v3;
  uLong v6 = v2;
  int v7 = 0;
  v23[512] = *MEMORY[0x1E4F143B8];
  if (v3) {
    unint64_t v8 = v4;
  }
  else {
    unint64_t v8 = 0;
  }
  *(void *)(v2 + 120) = v3;
  *(_DWORD *)(v2 + 128) = 0;
  while (1)
  {
    bzero(v23, 0x1000uLL);
    if (*(_DWORD *)(v6 + 104))
    {
      if (!v5) {
        goto LABEL_26;
      }
      goto LABEL_7;
    }
    LODWORD(v13) = *(_DWORD *)(v6 + 360);
    if (!v13)
    {
      uint64_t v14 = 0;
      while (1)
      {
        while (1)
        {
          while (1)
          {
            png_crc_finish(v6, v14);
            unsigned int chunk_header = _cg_png_read_chunk_header(v6);
            LODWORD(v13) = chunk_header;
            *(_DWORD *)(v6 + 360) = chunk_header;
            int v16 = *(_DWORD *)(v6 + 312);
            if (*(_DWORD *)(v6 + 784)) {
              break;
            }
            if (v16 != 1229209940) {
              goto LABEL_45;
            }
            uint64_t v14 = 0;
            if (chunk_header) {
              goto LABEL_21;
            }
          }
          if (v16 == 1717846356) {
            break;
          }
          if (v16 == 1229278788) {
            goto LABEL_45;
          }
          png_warning(v6, "Skipped (ignored) a chunk between APNG chunks");
          uint64_t v13 = *(unsigned int *)(v6 + 360);
          uint64_t v14 = v13;
          if (v13) {
            goto LABEL_21;
          }
        }
        png_ensure_sequence_number(v6, chunk_header);
        uint64_t v14 = 0;
        LODWORD(v13) = *(_DWORD *)(v6 + 360) - 4;
        *(_DWORD *)(v6 + 360) = v13;
        if (v13)
        {
LABEL_21:
          if (!v14) {
            break;
          }
        }
      }
    }
    unsigned int v17 = *(_DWORD *)(v6 + 952);
    if (v17 >= v13) {
      size_t v18 = v13;
    }
    else {
      size_t v18 = v17;
    }
    buffer = (Bytef *)png_read_buffer(v6, v18, 0);
    png_crc_read(v6, buffer, v18);
    *(_DWORD *)(v6 + 360) -= v18;
    *(void *)(v6 + 96) = buffer;
    *(_DWORD *)(v6 + 104) = v18;
    if (!v5)
    {
LABEL_26:
      *(void *)(v6 + 120) = v23;
      *(_DWORD *)(v6 + 128) = 4096;
      uint64_t result = png_zlib_inflate(v6, 0);
      int v12 = result;
      unint64_t v8 = v8 - *(unsigned int *)(v6 + 128) + 4096;
      goto LABEL_27;
    }
LABEL_7:
    uint64_t v9 = 0xFFFFFFFFLL;
    if (v8 < 0xFFFFFFFF) {
      uint64_t v9 = v8;
    }
    unint64_t v10 = v8 - v9;
    *(_DWORD *)(v6 + 128) = v9;
    uint64_t result = png_zlib_inflate(v6, 0);
    int v12 = result;
    unint64_t v8 = v10 + *(unsigned int *)(v6 + 128);
LABEL_27:
    *(_DWORD *)(v6 + 128) = 0;
    if (!v12) {
      goto LABEL_33;
    }
    if (v12 == 1) {
      break;
    }
    png_zstream_error(v6, v12);
    int v20 = *(const char **)(v6 + 144);
    if (!v5)
    {
      uint64_t v22 = v6;
      int v21 = *(const char **)(v6 + 144);
      return png_chunk_benign_error(v22, v21);
    }
    if (strncmp(*(const char **)(v6 + 144), "incorrect data check", 0x14uLL)) {
      png_chunk_error((void (**)(void))v6, v20);
    }
    uint64_t result = png_chunk_benign_error(v6, "ADLER32 checksum mismatch");
    if (v7 > 99) {
      return result;
    }
    ++v7;
LABEL_33:
    if (!v8) {
      return result;
    }
  }
  *(void *)(v6 + 120) = 0;
  *(void *)(v6 + 76) |= 0x800000008uLL;
  ++*(_DWORD *)(v6 + 784);
  if ((*(_DWORD *)(v6 + 104) || *(_DWORD *)(v6 + 360)) && (*(unsigned char *)(v6 + 84) & 0x10) == 0) {
    uint64_t result = png_chunk_benign_error(v6, "Extra compressed data");
  }
  if (v8)
  {
    if (v5) {
LABEL_45:
    }
      _cg_png_error((void (**)(void))v6, "Not enough image data");
    int v21 = "Too much image data";
    uint64_t v22 = v6;
    return png_chunk_benign_error(v22, v21);
  }
  return result;
}

uint64_t png_zlib_inflate(uint64_t a1, int a2)
{
  if (!*(unsigned char *)(a1 + 400) || !*(_DWORD *)(a1 + 104)) {
    return inflate((z_streamp)(a1 + 96), a2);
  }
  if ((**(char **)(a1 + 96) & 0x80000000) == 0)
  {
    *(unsigned char *)(a1 + 400) = 0;
    return inflate((z_streamp)(a1 + 96), a2);
  }
  *(void *)(a1 + 144) = "invalid window size (libpng)";
  return 4294967293;
}

uint64_t png_read_filter_row(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  unsigned int v5 = a5 - 1;
  if ((a5 - 1) <= 3)
  {
    uint64_t v9 = result;
    if (!*(void *)(result + 968))
    {
      unsigned int v10 = (*(unsigned __int8 *)(result + 394) + 7) >> 3;
      *(void *)(result + 968) = png_read_filter_row_sub;
      *(void *)(result + 976) = png_read_filter_row_up;
      *(void *)(result + 984) = png_read_filter_row_avg;
      unint64_t v11 = png_read_filter_row_paeth_multibyte_pixel;
      if (v10 == 1) {
        unint64_t v11 = png_read_filter_row_paeth_1byte_pixel;
      }
      *(void *)(result + 992) = v11;
      png_init_filter_functions_apple((void *)result, v10);
    }
    int v12 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v9 + 8 * v5 + 968);
    return v12(a2, a3, a4);
  }
  return result;
}

double png_read_filter_row_up_4bpp_neon(uint64_t a1, int8x16_t *a2, int8x16_t *a3, int8x16_t a4, int8x16_t a5)
{
  unint64_t v5 = *(void *)(a1 + 8);
  if (v5 >= 0x80)
  {
    do
    {
      uLong v6 = a2 + 8;
      int8x16_t v7 = *a3;
      int8x16_t v8 = a3[1];
      int8x16_t v9 = a3[2];
      int8x16_t v10 = a3[3];
      int8x16_t v11 = a3[4];
      int8x16_t v12 = a3[5];
      int8x16_t v13 = a3[6];
      int8x16_t v14 = a3[7];
      a3 += 8;
      a4 = vaddq_s8(v7, *a2);
      a5 = vaddq_s8(v8, a2[1]);
      int8x16_t v15 = vaddq_s8(v9, a2[2]);
      int8x16_t v16 = vaddq_s8(v10, a2[3]);
      int8x16_t v17 = vaddq_s8(v11, a2[4]);
      int8x16_t v18 = vaddq_s8(v12, a2[5]);
      int8x16_t v19 = vaddq_s8(v13, a2[6]);
      int8x16_t v20 = vaddq_s8(v14, a2[7]);
      *a2 = a4;
      a2[1] = a5;
      a2[2] = v15;
      a2[3] = v16;
      a2[4] = v17;
      a2[5] = v18;
      v5 -= 128;
      a2[6] = v19;
      a2[7] = v20;
      a2 += 8;
    }
    while (v5 > 0x7F);
    a2 = v6;
  }
  if (v5 >= 0x40)
  {
    do
    {
      int v21 = a2 + 4;
      int8x16_t v22 = *a3;
      int8x16_t v23 = a3[1];
      int8x16_t v24 = a3[2];
      int8x16_t v25 = a3[3];
      a3 += 4;
      a4 = vaddq_s8(v22, *a2);
      a5 = vaddq_s8(v23, a2[1]);
      int8x16_t v26 = vaddq_s8(v24, a2[2]);
      int8x16_t v27 = vaddq_s8(v25, a2[3]);
      *a2 = a4;
      a2[1] = a5;
      a2[2] = v26;
      a2[3] = v27;
      v5 -= 64;
      a2 += 4;
    }
    while (v5 > 0x3F);
    a2 = v21;
  }
  char v28 = (__n128 *)a2;
  if (v5 >= 0x10)
  {
    do
    {
      int8x16_t v29 = *a2++;
      int8x16_t v30 = v29;
      int8x16_t v31 = *a3++;
      a5.i32[1] = v31.i32[1];
      a4 = vaddq_s8(v31, v30);
      *v28++ = (__n128)a4;
      v5 -= 16;
    }
    while (v5 > 0xF);
  }
  if (v5 >= 4)
  {
    do
    {
      unsigned __int32 v32 = a2->i32[0];
      a2 = (int8x16_t *)((char *)a2 + 4);
      a4.i32[0] = v32;
      unsigned __int32 v33 = a3->i32[0];
      a3 = (int8x16_t *)((char *)a3 + 4);
      a5.i32[0] = v33;
      *(int8x8_t *)a4.i8 = vmovn_s16((int16x8_t)vaddl_u8(*(uint8x8_t *)a5.i8, *(uint8x8_t *)a4.i8));
      v28->n128_u32[0] = a4.i32[0];
      char v28 = (__n128 *)((char *)v28 + 4);
      v5 -= 4;
    }
    while (v5 > 3);
  }
  return *(double *)a4.i64;
}

uint64_t png_read_IDAT_dataApple(uLong a1)
{
  *(void *)(a1 + 120) = *(void *)(a1 + 328);
  unint64_t v4 = *(unsigned __int8 *)(a1 + 394);
  unsigned int v2 = *(_DWORD *)(a1 + 304);
  BOOL v3 = v4 >= 8;
  LODWORD(v4) = v2 * (v4 >> 3);
  if (!v3) {
    unint64_t v4 = (v2 * (unint64_t)*(unsigned __int8 *)(a1 + 394) + 7) >> 3;
  }
  *(_DWORD *)(a1 + 128) = v4 + 1;
  while (1)
  {
    uint64_t result = png_read_zstream(a1);
    if (result != -5)
    {
      if (result) {
        break;
      }
    }
    if (*(_DWORD *)(a1 + 128))
    {
      if (*(_DWORD *)(a1 + 104)) {
        continue;
      }
      unsigned int chunk_header = *(_DWORD *)(a1 + 360);
      while (!chunk_header)
      {
        png_crc_finish(a1, 0);
        unsigned int chunk_header = _cg_png_read_chunk_header(a1);
        *(_DWORD *)(a1 + 360) = chunk_header;
        if (*(_DWORD *)(a1 + 312) != 1229209940)
        {
          int8x16_t v11 = "Not enough image data";
          goto LABEL_26;
        }
      }
      unsigned int v7 = *(_DWORD *)(a1 + 952);
      size_t v8 = v7 >= chunk_header ? chunk_header : v7;
      buffer = (Bytef *)png_read_buffer(a1, v8, 0);
      *(_DWORD *)(a1 + 104) = v8;
      *(void *)(a1 + 96) = buffer;
      unsigned int v10 = *(_DWORD *)(a1 + 360);
      if (v8 > v10)
      {
        *(_DWORD *)(a1 + 104) = v10;
        LODWORD(v8) = v10;
      }
      uint64_t result = png_crc_read(a1, buffer, v8);
      *(_DWORD *)(a1 + 360) -= *(_DWORD *)(a1 + 104);
      if (*(_DWORD *)(a1 + 128)) {
        continue;
      }
    }
    return result;
  }
  if (result != 1)
  {
    if (*(void *)(a1 + 144)) {
      int8x16_t v11 = *(const char **)(a1 + 144);
    }
    else {
      int8x16_t v11 = "Decompression error";
    }
LABEL_26:
    _cg_png_error((void (**)(void))a1, v11);
  }
  if ((*(_DWORD *)(a1 + 128) || *(_DWORD *)(a1 + 104) || *(_DWORD *)(a1 + 360)) && (*(unsigned char *)(a1 + 84) & 8) == 0)
  {
    int8x16_t v11 = "Extra compressed data";
    goto LABEL_26;
  }
  *(_DWORD *)(a1 + 76) |= 8u;
  return result;
}

uint64_t png_read_zstream(uint64_t a1)
{
  unsigned int v1 = (z_stream *)(a1 + 96);
  if (!*(void *)(a1 + 152))
  {
    int v3 = (*(unsigned char *)(a1 + 84) & 1) != 0
       ? inflateInit2_((z_streamp)(a1 + 96), -15, "1.2.12", 112)
       : inflateInit_((z_streamp)(a1 + 96), "1.2.12", 112);
    if (v3)
    {
      if (v3 == -6)
      {
        unint64_t v5 = "zlib version error";
      }
      else if (v3 == -2 || v3 == -4)
      {
        unint64_t v5 = "zlib memory error";
      }
      else
      {
        unint64_t v5 = "Unknown zlib error";
      }
      _cg_png_error((void (**)(void))a1, v5);
    }
  }

  return inflate(v1, 1);
}

uint64_t png_read_filter_row_paeth3_apple(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = 0;
  uint64_t v4 = *(void *)(result + 8);
  do
  {
    LOBYTE(v5) = *(unsigned char *)(a3 + v3) + *(unsigned char *)(a2 + v3);
    *(unsigned char *)(a2 + v3++) = v5;
  }
  while (v3 != 3);
  if ((int)v4 >= 4)
  {
    uint64_t v6 = 0;
    int v5 = v5;
    int v7 = *(unsigned __int8 *)(a3 + v3 - 1);
    v8.i32[0] = *(unsigned __int8 *)(a2 + v3 - 3);
    v8.i32[1] = *(unsigned __int8 *)(a2 + v3 - 2);
    v9.i32[0] = *(unsigned __int8 *)(a3 + v3 - 3);
    v9.i32[1] = *(unsigned __int8 *)(a3 + v3 - 2);
    do
    {
      unsigned int v10 = (unsigned __int8 *)(a3 + v6 + v3);
      int8x16_t v11 = (unsigned __int8 *)(a2 + v6 + v3);
      int v12 = v10[2];
      int32x2_t v13 = vsub_s32(v8, v9);
      unsigned int v14 = v12 - v7;
      int v15 = v5 - v7;
      if (v12 - v7 >= 0) {
        uint64_t result = v14;
      }
      else {
        uint64_t result = (v7 - v12);
      }
      if (v15 >= 0) {
        unsigned int v16 = v5 - v7;
      }
      else {
        unsigned int v16 = v7 - v5;
      }
      int v17 = v14 + v15;
      if (v17 < 0) {
        int v17 = -v17;
      }
      if (v16 >= result)
      {
        unsigned int v18 = result;
      }
      else
      {
        LOBYTE(v5) = v10[2];
        unsigned int v18 = v16;
      }
      if (v17 < v18) {
        LOBYTE(v5) = v7;
      }
      v19.i32[0] = *v10;
      v19.i32[1] = v10[1];
      uint32x2_t v20 = (uint32x2_t)vabd_s32(v19, v9);
      uint32x2_t v21 = (uint32x2_t)vabd_s32(v8, v9);
      int32x2_t v22 = (int32x2_t)vbsl_s8((int8x8_t)vcgt_u32(vmin_u32(v21, v20), (uint32x2_t)vabs_s32(vadd_s32(vsub_s32(v19, v9), v13))), (int8x8_t)v9, vbsl_s8((int8x8_t)vcgt_u32(v20, v21), (int8x8_t)v19, (int8x8_t)v8));
      v23.i32[0] = *v11;
      v23.i32[1] = v11[1];
      int8x8_t v24 = (int8x8_t)vadd_s32(v22, v23);
      LOBYTE(v5) = v5 + v11[2];
      int32x2_t v8 = (int32x2_t)vand_s8(v24, (int8x8_t)0xFF000000FFLL);
      unsigned __int8 *v11 = v24.i8[0];
      v11[1] = v24.u8[4];
      v11[2] = v5;
      int v5 = v5;
      v6 += 3;
      int v7 = v12;
      int32x2_t v9 = v19;
    }
    while ((int)v6 + 3 < (int)v4);
  }
  return result;
}

uint64_t png_read_filter_row_up_apple_vector(uint64_t result, int8x16_t *a2, int8x16_t *a3)
{
  unsigned int v3 = *(_DWORD *)(result + 8);
  if (v3 < 0x40)
  {
    int v5 = a2;
    uint64_t v4 = a3;
  }
  else
  {
    do
    {
      uint64_t v4 = a3 + 4;
      int v5 = a2 + 4;
      int8x16_t v6 = vaddq_s8(a2[1], a3[1]);
      int8x16_t v7 = vaddq_s8(*a2, *a3);
      int8x16_t v8 = vaddq_s8(a2[3], a3[3]);
      a2[2] = vaddq_s8(a2[2], a3[2]);
      a2[3] = v8;
      *a2 = v7;
      a2[1] = v6;
      v3 -= 64;
      a3 += 4;
      a2 += 4;
    }
    while (v3 > 0x3F);
  }
  if (v3 >= 0x20)
  {
    int8x16_t v9 = *v4;
    int8x16_t v10 = v4[1];
    v4 += 2;
    int8x16_t v11 = vaddq_s8(v5[1], v10);
    *int v5 = vaddq_s8(*v5, v9);
    v5[1] = v11;
    v5 += 2;
    v3 -= 32;
  }
  if (v3 >= 0x10)
  {
    int8x16_t v12 = *v4++;
    *int v5 = vaddq_s8(*v5, v12);
    ++v5;
    v3 -= 16;
  }
  for (; v3; --v3)
  {
    __int8 v13 = v4->i8[0];
    uint64_t v4 = (int8x16_t *)((char *)v4 + 1);
    v5->i8[0] += v13;
    int v5 = (int8x16_t *)((char *)v5 + 1);
  }
  return result;
}

uint64_t png_read_filter_row_paeth_1byte_pixel(uint64_t result, unsigned __int8 *a2, unsigned __int8 *a3)
{
  uint64_t v3 = *(void *)(result + 8);
  int v4 = *a3;
  unsigned __int8 v5 = *a2 + v4;
  *a2 = v5;
  if (v3 >= 2)
  {
    int8x16_t v6 = &a2[v3];
    int8x16_t v7 = a2 + 1;
    int8x16_t v8 = a3 + 1;
    do
    {
      int v10 = *v8++;
      int v9 = v10;
      unsigned int v11 = v10 - v4;
      int v12 = v5 - v4;
      if (v10 - v4 >= 0) {
        unsigned int v13 = v11;
      }
      else {
        unsigned int v13 = -v11;
      }
      if (v12 >= 0) {
        unsigned int v14 = v5 - v4;
      }
      else {
        unsigned int v14 = v4 - v5;
      }
      int v15 = v11 + v12;
      if (v15 < 0) {
        int v15 = -v15;
      }
      if (v14 >= v13)
      {
        unsigned int v16 = v13;
      }
      else
      {
        unsigned __int8 v5 = v9;
        unsigned int v16 = v14;
      }
      if (v15 >= v16) {
        LOBYTE(v4) = v5;
      }
      unsigned __int8 v5 = v4 + *v7;
      *v7++ = v5;
      int v4 = v9;
    }
    while (v7 < v6);
  }
  return result;
}

uint8x8_t png_read_filter_row_paeth_neon(uint64_t a1, unsigned char *a2, unsigned char *a3, uint8x8_t result, uint16x8_t a5, int32x2_t a6, int8x16_t a7, int32x2_t a8)
{
  uint64_t v8 = *(void *)(a1 + 8);
  *a2 += *a3;
  a2[1] += a3[1];
  a2[2] += a3[2];
  a2[3] += a3[3];
  int v9 = (int32x2_t *)(a2 + 4);
  int v10 = (int32x4_t *)(a3 + 4);
  uint64_t v11 = v8 - 4;
  if ((unint64_t)(v8 - 4) < 0x10)
  {
    unint64_t v12 = v8 - 4;
  }
  else
  {
    a8.i32[0] = *(_DWORD *)a3;
    a6.i32[0] = *(_DWORD *)a2;
    uint64_t result = (uint8x8_t)0x101010101010101;
    a5 = 0uLL;
    unint64_t v12 = v8 - 4;
    do
    {
      int32x4_t v13 = *v10++;
      int8x8_t v14 = (int8x8_t)vdup_lane_s32(*(int32x2_t *)v13.i8, 0);
      int8x8_t v15 = (int8x8_t)vdup_lane_s32(a8, 0);
      int8x8_t v16 = (int8x8_t)vdup_lane_s32(a6, 0);
      uint16x8_t v17 = vabdq_u16(vaddl_u8((uint8x8_t)v14, (uint8x8_t)v16), vshll_n_u8((uint8x8_t)v15, 1uLL));
      *(int8x8_t *)v18.i8 = vand_s8(vmovn_s16((int16x8_t)vcgeq_u16(v17, vabdl_u8((uint8x8_t)v14, (uint8x8_t)v15))), vand_s8((int8x8_t)vcge_u8(vabd_u8((uint8x8_t)v16, (uint8x8_t)v15), vabd_u8((uint8x8_t)v14, (uint8x8_t)v15)), (int8x8_t)0x101010101010101));
      v18.i64[1] = v18.i64[0];
      *(int8x8_t *)v19.i8 = vand_s8(vmovn_s16((int16x8_t)vcgeq_u16(v17, vabdl_u8((uint8x8_t)v16, (uint8x8_t)v15))), (int8x8_t)0x101010101010101);
      v19.i64[1] = v19.i64[0];
      int8x8_t v20 = (int8x8_t)vcltzq_s8(vshlq_n_s8(v18, 7uLL)).u64[0];
      *(int32x2_t *)v18.i8 = vdup_lane_s32(*(int32x2_t *)v13.i8, 1);
      *(int8x8_t *)v21.i8 = vadd_s8(vbsl_s8(v20, v16, vbsl_s8((int8x8_t)*(_OWORD *)&vcltzq_s8(vshlq_n_s8(v19, 7uLL)), v14, v15)), (int8x8_t)vdup_lane_s32(*v9, 0));
      int8x16_t v22 = (int8x16_t)vabdq_u16(vaddl_u8(*(uint8x8_t *)v21.i8, *(uint8x8_t *)v18.i8), vshll_n_u8((uint8x8_t)v14, 1uLL));
      *(int8x8_t *)v23.i8 = vand_s8(vmovn_s16((int16x8_t)vcgeq_u16((uint16x8_t)v22, vabdl_u8(*(uint8x8_t *)v18.i8, (uint8x8_t)v14))), vand_s8((int8x8_t)vcge_u8(vabd_u8(*(uint8x8_t *)v21.i8, (uint8x8_t)v14), vabd_u8(*(uint8x8_t *)v18.i8, (uint8x8_t)v14)), (int8x8_t)0x101010101010101));
      v23.i64[1] = v23.i64[0];
      *(int8x8_t *)v19.i8 = vand_s8(vmovn_s16((int16x8_t)vcgeq_u16((uint16x8_t)v22, vabdl_u8(*(uint8x8_t *)v21.i8, (uint8x8_t)v14))), (int8x8_t)0x101010101010101);
      v19.i64[1] = v19.i64[0];
      v22.i64[0] = vcltzq_s8(vshlq_n_s8(v23, 7uLL)).u64[0];
      v23.i64[0] = vdupq_laneq_s32(v13, 2).u64[0];
      int8x8_t v24 = vadd_s8(vbsl_s8(*(int8x8_t *)v22.i8, *(int8x8_t *)v21.i8, vbsl_s8((int8x8_t)*(_OWORD *)&vcltzq_s8(vshlq_n_s8(v19, 7uLL)), *(int8x8_t *)v18.i8, v14)), (int8x8_t)vdup_lane_s32(*v9, 1));
      uint16x8_t v25 = vabdq_u16(vaddl_u8((uint8x8_t)v24, *(uint8x8_t *)v23.i8), vshll_n_u8(*(uint8x8_t *)v18.i8, 1uLL));
      *(int8x8_t *)v19.i8 = vand_s8(vmovn_s16((int16x8_t)vcgeq_u16(v25, vabdl_u8(*(uint8x8_t *)v23.i8, *(uint8x8_t *)v18.i8))), vand_s8((int8x8_t)vcge_u8(vabd_u8((uint8x8_t)v24, *(uint8x8_t *)v18.i8), vabd_u8(*(uint8x8_t *)v23.i8, *(uint8x8_t *)v18.i8)), (int8x8_t)0x101010101010101));
      v19.i64[1] = v19.i64[0];
      *(int8x8_t *)v22.i8 = vand_s8(vmovn_s16((int16x8_t)vcgeq_u16(v25, vabdl_u8((uint8x8_t)v24, *(uint8x8_t *)v18.i8))), (int8x8_t)0x101010101010101);
      v22.i64[1] = v22.i64[0];
      int8x16_t v26 = vcltzq_s8(vshlq_n_s8(v19, 7uLL));
      a7 = (int8x16_t)vdupq_laneq_s32(v13, 3);
      *(int8x8_t *)v18.i8 = vadd_s8(vbsl_s8(*(int8x8_t *)v26.i8, v24, vbsl_s8((int8x8_t)*(_OWORD *)&vcltzq_s8(vshlq_n_s8(v22, 7uLL)), *(int8x8_t *)v23.i8, *(int8x8_t *)v18.i8)), (int8x8_t)*(_OWORD *)&vdupq_laneq_s32(*(int32x4_t *)v9->i8, 2));
      uint16x8_t v27 = vabdq_u16(vaddl_u8(*(uint8x8_t *)v18.i8, *(uint8x8_t *)a7.i8), vshll_n_u8(*(uint8x8_t *)v23.i8, 1uLL));
      int16x8_t v28 = (int16x8_t)vcgeq_u16(v27, vabdl_u8(*(uint8x8_t *)v18.i8, *(uint8x8_t *)v23.i8));
      *(int8x8_t *)v28.i8 = vmovn_s16(v28);
      *(int8x8_t *)v26.i8 = vand_s8(vmovn_s16((int16x8_t)vcgeq_u16(v27, vabdl_u8(*(uint8x8_t *)a7.i8, *(uint8x8_t *)v23.i8))), (int8x8_t)vcge_u8(vabd_u8(*(uint8x8_t *)v18.i8, *(uint8x8_t *)v23.i8), vabd_u8(*(uint8x8_t *)a7.i8, *(uint8x8_t *)v23.i8)));
      v21.i32[1] = v24.i32[1];
      v18.i32[1] = vadd_s8(vbsl_s8((int8x8_t)vcltzq_s8(vshlq_n_s8(v26, 7uLL)), *(int8x8_t *)&v18, vbsl_s8((int8x8_t)vcltzq_s8(vshlq_n_s8(*(int8x16_t *)&v28, 7uLL)), *(int8x8_t *)&a7, *(int8x8_t *)&v23)), (int8x8_t)vextq_s8(*(int8x16_t *)v9, *(int8x16_t *)v9, 8uLL)).i32[1];
      v21.i64[1] = v18.i64[0];
      *(int8x16_t *)v9->i8 = v21;
      v9 += 2;
      a6 = (int32x2_t)vextq_s8(v21, (int8x16_t)0, 0xCuLL).u64[0];
      a8 = (int32x2_t)vextq_s8(a7, (int8x16_t)0, 0xCuLL).u64[0];
      v12 -= 16;
    }
    while (v12 > 0xF);
  }
  if (v12 >= 4)
  {
    unint64_t v29 = v11 & 0xFFFFFFFFFFFFFFF0;
    int8x16_t v30 = (unsigned __int32 *)&a2[v11 & 0xFFFFFFFFFFFFFFF0];
    int8x16_t v31 = (unsigned __int32 *)&a3[v29];
    do
    {
      result.i32[0] = v9->i32[0];
      unsigned __int32 v32 = *v30++;
      a5.i32[0] = v32;
      a5 = vmovl_u8(*(uint8x8_t *)a5.i8);
      __int32 v33 = v10->i32[0];
      int v10 = (int32x4_t *)((char *)v10 + 4);
      a6.i32[0] = v33;
      int8x8_t v34 = (int8x8_t)vmovl_u8((uint8x8_t)a6).u64[0];
      unsigned __int32 v35 = *v31++;
      a7.i32[0] = v35;
      a7.i64[0] = vmovl_u8(*(uint8x8_t *)a7.i8).u64[0];
      uint32x4_t v36 = vmovl_u16(*(uint16x4_t *)a7.i8);
      uint32x4_t v37 = vabdq_u32(vmovl_u16((uint16x4_t)v34), v36);
      uint32x4_t v38 = vabdq_u32(vmovl_u16(*(uint16x4_t *)a5.i8), v36);
      uint32x4_t v39 = (uint32x4_t)vabsq_s32(vaddq_s32((int32x4_t)vsubl_u16((uint16x4_t)v34, *(uint16x4_t *)a7.i8), (int32x4_t)vsubl_u16(*(uint16x4_t *)a5.i8, *(uint16x4_t *)a7.i8)));
      a6 = (int32x2_t)vbsl_s8((int8x8_t)vmovn_s32((int32x4_t)vcgtq_u32(v38, v39)), *(int8x8_t *)a7.i8, v34);
      *(int8x8_t *)a5.i8 = vbsl_s8((int8x8_t)vmovn_s32((int32x4_t)vcgtq_u32(v37, vminq_u32(v38, v39))), (int8x8_t)a6, *(int8x8_t *)a5.i8);
      uint64_t result = (uint8x8_t)vmovn_s16((int16x8_t)vaddw_u8(a5, result));
      v9->i32[0] = result.i32[0];
      int v9 = (int32x2_t *)((char *)v9 + 4);
      v12 -= 4;
    }
    while (v12 > 3);
  }
  return result;
}

uint8x8_t png_read_filter_row_sub_neon(uint64_t a1, unsigned __int32 *a2, uint8x8_t result, uint8x8_t a4, double a5, double a6, int8x16_t a7)
{
  uint64_t v7 = *(void *)(a1 + 8);
  uint64_t v8 = (int8x16_t *)(a2 + 1);
  uint64_t v9 = v7 - 4;
  if ((unint64_t)(v7 - 4) < 0x10)
  {
    unint64_t v10 = v7 - 4;
  }
  else
  {
    a7.i32[0] = *a2;
    uint64_t result = (uint8x8_t)0x706050480808080;
    a4.i32[1] = -2139062144;
    unint64_t v10 = v7 - 4;
    do
    {
      int8x16_t v11 = vaddq_s8(*v8, a7);
      int8x16_t v12 = vaddq_s8(vaddq_s8(vaddq_s8(vqtbl1q_s8(v11, (int8x16_t)xmmword_1889AD4F0), vqtbl1q_s8(v11, (int8x16_t)xmmword_1889AD4E0)), vqtbl1q_s8(v11, (int8x16_t)xmmword_1889AD500)), (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v11.i8, 0));
      *v8++ = v12;
      a7 = vextq_s8(v12, (int8x16_t)0, 0xCuLL);
      v10 -= 16;
    }
    while (v10 > 0xF);
  }
  if (v10 >= 4)
  {
    int32x4_t v13 = (__int32 *)((char *)a2 + (v9 & 0xFFFFFFFFFFFFFFF0));
    do
    {
      result.i32[0] = v8->i32[0];
      __int32 v14 = *v13++;
      a4.i32[0] = v14;
      uint64_t result = (uint8x8_t)vmovn_s16((int16x8_t)vaddl_u8(a4, result));
      v8->i32[0] = result.i32[0];
      uint64_t v8 = (int8x16_t *)((char *)v8 + 4);
      v10 -= 4;
    }
    while (v10 > 3);
  }
  return result;
}

uint64_t png_read_filter_row_avg3_apple(uint64_t result, unsigned char *a2, unsigned __int8 *a3)
{
  uint64_t v3 = *(unsigned __int8 *)(result + 19);
  unint64_t v4 = v3 + 7;
  unint64_t v5 = (unint64_t)(v3 + 7) >> 3;
  uint64_t v6 = *(void *)(result + 8);
  if (*(unsigned char *)(result + 19))
  {
    if (v5 <= 1) {
      unint64_t v7 = 1;
    }
    else {
      unint64_t v7 = (unint64_t)(v3 + 7) >> 3;
    }
    do
    {
      unsigned int v8 = *a3++;
      *a2++ += v8 >> 1;
      --v7;
    }
    while (v7);
  }
  if (v6 != v5)
  {
    unint64_t v9 = 0;
    unint64_t v10 = v6 - (v4 >> 3);
    int v11 = *(a2 - 1);
    int v12 = *(a2 - 2);
    int v13 = *(a2 - 3);
    do
    {
      __int32 v14 = &a2[v9];
      uint64_t result = a2[v9 + 1];
      LOBYTE(v13) = a2[v9] + ((v13 + a3[v9]) >> 1);
      LOBYTE(v12) = result + ((v12 + a3[v9 + 1]) >> 1);
      LOBYTE(v11) = a2[v9 + 2] + ((v11 + a3[v9 + 2]) >> 1);
      *__int32 v14 = v13;
      v14[1] = v12;
      v14[2] = v11;
      int v13 = v13;
      int v12 = v12;
      int v11 = v11;
      v9 += 3;
    }
    while (v9 < v10);
  }
  return result;
}

uint64_t png_do_swap(uint64_t result, char *a2)
{
  if (*(unsigned char *)(result + 17) == 16)
  {
    for (int i = *(_DWORD *)result * *(unsigned __int8 *)(result + 18); i; --i)
    {
      char v3 = *a2;
      *a2 = a2[1];
      a2[1] = v3;
      a2 += 2;
    }
  }
  return result;
}

uint64_t png_read_filter_row_avg(uint64_t result, unsigned char *a2, unsigned __int8 *a3)
{
  uint64_t v3 = *(unsigned __int8 *)(result + 19);
  unint64_t v4 = (unint64_t)(v3 + 7) >> 3;
  uint64_t v5 = *(void *)(result + 8);
  if (*(unsigned char *)(result + 19))
  {
    if (v4 <= 1) {
      unint64_t v6 = 1;
    }
    else {
      unint64_t v6 = (unint64_t)(v3 + 7) >> 3;
    }
    do
    {
      unsigned int v7 = *a3++;
      *a2++ += v7 >> 1;
      --v6;
    }
    while (v6);
  }
  if (v5 != v4)
  {
    uint64_t v8 = -(uint64_t)v4;
    uint64_t v9 = -v5;
    do
    {
      int v10 = *a3++;
      *a2 += (a2[v8] + v10) >> 1;
      ++a2;
      ++v9;
    }
    while (v8 != v9);
  }
  return result;
}

uint64_t png_read_filter_row_paeth_multibyte_pixel(uint64_t result, unsigned char *a2, char *a3)
{
  uint64_t v3 = *(unsigned __int8 *)(result + 19);
  unint64_t v4 = (unint64_t)(v3 + 7) >> 3;
  if (*(unsigned char *)(result + 19))
  {
    unint64_t v5 = (unint64_t)&a2[(unint64_t)(v3 + 7) >> 3];
    if (&a2[v4] <= a2 + 1) {
      unint64_t v6 = a2 + 1;
    }
    else {
      unint64_t v6 = &a2[v4];
    }
    unsigned int v7 = a2;
    do
    {
      char v8 = *a3++;
      *v7++ += v8;
    }
    while ((unint64_t)v7 < v5);
  }
  else
  {
    unint64_t v6 = a2;
    unsigned int v7 = a2;
  }
  uint64_t v9 = *(void *)(result + 8);
  if (v7 < &a2[v9])
  {
    uint64_t v10 = -(uint64_t)v4;
    int v11 = (unsigned char *)(&a2[v9] - v6);
    do
    {
      int v12 = a3[v10];
      int v13 = v7[v10];
      int v15 = *a3++;
      char v14 = v15;
      unsigned int v16 = v15 - v12;
      int v17 = v13 - v12;
      if (v15 - v12 >= 0) {
        unsigned int v18 = v16;
      }
      else {
        unsigned int v18 = -v16;
      }
      if (v17 >= 0) {
        unsigned int v19 = v13 - v12;
      }
      else {
        unsigned int v19 = v12 - v13;
      }
      int v20 = v16 + v17;
      if (v20 < 0) {
        int v20 = -v20;
      }
      if (v19 >= v18)
      {
        unsigned int v21 = v18;
      }
      else
      {
        LOBYTE(v13) = v14;
        unsigned int v21 = v19;
      }
      if (v20 >= v21) {
        LOBYTE(v12) = v13;
      }
      *v7++ += v12;
      --v11;
    }
    while (v11);
  }
  return result;
}

uint64_t png_read_filter_row_sub_apple_neon(uint64_t result, int8x16_t *a2, __int32 *a3)
{
  uint64_t v3 = *(unsigned __int8 *)(result + 19);
  unint64_t v4 = (unint64_t)(v3 + 7) >> 3;
  uint64_t v5 = *(void *)(result + 8);
  unint64_t v6 = v5 - v4;
  BOOL v7 = v4 == 3 && v6 >= 0x1D;
  if (v7)
  {
    int8x16_t v13 = a2[1];
    int8x16_t v14 = vaddq_s8(vaddq_s8(vaddq_s8(vextq_s8((int8x16_t)0, *a2, 0xAuLL), *a2), vaddq_s8(vextq_s8((int8x16_t)0, *a2, 0xDuLL), vextq_s8((int8x16_t)0, *a2, 7uLL))), vaddq_s8(vextq_s8((int8x16_t)0, *a2, 4uLL), vextq_s8((int8x16_t)0, *a2, 1uLL)));
    int8x16_t v15 = vaddq_s8(vaddq_s8(vaddq_s8(vaddq_s8(vextq_s8(*a2, v13, 0xAuLL), v13), vaddq_s8(vextq_s8(*a2, v13, 0xDuLL), vextq_s8(*a2, v13, 7uLL))), vaddq_s8(vextq_s8(*a2, v13, 4uLL), vextq_s8(*a2, v13, 1uLL))), vextq_s8((int8x16_t)0, v14, 0xEuLL));
    *a2 = v14;
    a2[1] = v15;
    unsigned int v16 = a2 + 2;
    unint64_t v17 = v6 - 29;
    if (v17 >= 0x10)
    {
      do
      {
        int8x16_t v18 = *v16;
        int8x16_t v19 = vaddq_s8(vaddq_s8(vaddq_s8(*v16, vextq_s8(v14, v15, 0xEuLL)), vextq_s8(v13, *v16, 0xAuLL)), vaddq_s8(vextq_s8(v13, *v16, 0xDuLL), vextq_s8(v13, *v16, 7uLL)));
        int8x16_t v14 = v15;
        int8x16_t v15 = vaddq_s8(v19, vaddq_s8(vextq_s8(v13, *v16, 4uLL), vextq_s8(v13, *v16, 1uLL)));
        *v16++ = v15;
        v17 -= 16;
        int8x16_t v13 = v18;
      }
      while (v17 > 0xF);
    }
    if (v17)
    {
      uint64_t v20 = -(uint64_t)v4;
      do
      {
        v16->i8[0] += v16->i8[v20];
        unsigned int v16 = (int8x16_t *)((char *)v16 + 1);
        --v17;
      }
      while (v17);
    }
  }
  else
  {
    char v8 = &a2->i8[v4];
    if (v3 == 32)
    {
      unsigned int v9 = v5 - 3;
      __int32 v10 = a2->i32[0];
      int v11 = (__int32 *)((char *)a2->i32 + v4);
      if (*(unsigned char *)(result + 20))
      {
        *a3 = v10;
        int v11 = a3 + 1;
      }
      if (v4 >= v9)
      {
        a3 = v11;
      }
      else
      {
        unint64_t v12 = 0;
        do
        {
          uint64_t result = v10 & 0x7F7F7F7F;
          __int32 v10 = ((*(__int32 *)((unsigned char *)a2->i32 + v4 + v12) & 0x7F7F7F7F) + result) ^ (*(__int32 *)((char *)a2->i32
                                                                                                  + v4
                                                                                                  + v12) ^ v10) & 0x80808080;
          v11[v12 / 4] = v10;
          v12 += 4;
        }
        while ((int)v4 + (int)v12 < v9);
        a2 = (int8x16_t *)((char *)a2 + v12);
        a3 = &v11[v12 / 4];
        char v8 = &a2->i8[v4];
        LODWORD(v4) = v4 + v12;
      }
    }
    else if (*(unsigned char *)(result + 20))
    {
      if (*(unsigned char *)(result + 19))
      {
        uint64_t v21 = 0;
        if (v4 <= 1) {
          uint64_t v22 = 1;
        }
        else {
          uint64_t v22 = v4;
        }
        LODWORD(v4) = v22;
        do
        {
          *((unsigned char *)a3 + v21) = a2->i8[v21];
          ++v21;
        }
        while (v22 != v21);
        a3 = (__int32 *)((char *)a3 + v21);
      }
      else
      {
        LODWORD(v4) = 0;
      }
    }
    else
    {
      a3 = (__int32 *)((char *)a2->i32 + v4);
    }
    BOOL v7 = v5 >= v4;
    int v23 = v5 - v4;
    if (v23 != 0 && v7)
    {
      do
      {
        char v25 = *v8++;
        char v24 = v25;
        __int8 v26 = a2->i8[0];
        a2 = (int8x16_t *)((char *)a2 + 1);
        *(unsigned char *)a3 = v26 + v24;
        a3 = (__int32 *)((char *)a3 + 1);
        --v23;
      }
      while (v23);
    }
  }
  return result;
}

unsigned int *png_do_expand(unsigned int *result, uint64_t a2, unsigned __int16 *a3)
{
  uint64_t v3 = *result;
  if (!*((unsigned char *)result + 16))
  {
    if (a3) {
      unsigned int v13 = a3[4];
    }
    else {
      unsigned int v13 = 0;
    }
    unsigned int v14 = *((unsigned __int8 *)result + 17);
    if (v14 > 7) {
      goto LABEL_59;
    }
    switch(v14)
    {
      case 1u:
        unsigned int v13 = ((int)(v13 << 31) >> 31);
        if (v3)
        {
          int v32 = -(int)v3 & 7;
          __int32 v33 = (unsigned __int8 *)(a2 + ((v3 - 1) >> 3));
          int8x8_t v34 = (char *)(v3 + a2 - 1);
          int v35 = *result;
          do
          {
            if ((*v33 >> v32)) {
              char v36 = -1;
            }
            else {
              char v36 = 0;
            }
            *v34-- = v36;
            uint64_t v37 = v32 == 7;
            if (v32 == 7) {
              int v32 = 0;
            }
            else {
              ++v32;
            }
            v33 -= v37;
            --v35;
          }
          while (v35);
          goto LABEL_56;
        }
        break;
      case 2u:
        unsigned int v13 = 85 * (v13 & 3);
        if (v3)
        {
          int v38 = ~(2 * v3 + 6) & 6;
          uint32x4_t v39 = (unsigned __int8 *)(a2 + ((v3 - 1) >> 2));
          uint64_t v40 = (unsigned char *)(v3 + a2 - 1);
          int v41 = *result;
          do
          {
            *v40-- = 85 * ((*v39 >> v38) & 3);
            BOOL v20 = v38 == 6;
            uint64_t v42 = v38 == 6;
            v38 += 2;
            if (v20) {
              int v38 = 0;
            }
            v39 -= v42;
            --v41;
          }
          while (v41);
          goto LABEL_56;
        }
        break;
      case 4u:
        unsigned int v13 = v13 & 0xF | (16 * (v13 & 0xF));
        if (v3)
        {
          int v15 = 4 * (*result & 1);
          unsigned int v16 = (unsigned __int8 *)(a2 + ((v3 - 1) >> 1));
          unint64_t v17 = (unsigned char *)(v3 + a2 - 1);
          int v18 = *result;
          do
          {
            int v19 = *v16 >> v15;
            BOOL v20 = v15 == 0;
            BOOL v21 = v15 == 0;
            *v17-- = v19 & 0xF | (16 * v19);
            uint64_t v22 = !v20;
            int v15 = 4 * v21;
            v16 -= v22;
            --v18;
          }
          while (v18);
          goto LABEL_56;
        }
        break;
      default:
LABEL_56:
        uint64_t v43 = v3;
LABEL_58:
        unsigned int v14 = 8;
        *((unsigned char *)result + 17) = 8;
        *((unsigned char *)result + 19) = 8;
        *((void *)result + 1) = v43;
LABEL_59:
        if (!a3) {
          return result;
        }
        if (v14 == 16)
        {
          if (v3)
          {
            uint64_t v49 = *((void *)result + 1);
            __int16 v50 = (char *)(a2 + 2 * v49 - 1);
            uint64_t v51 = (char *)(a2 + v49 - 1);
            int v52 = v3;
            do
            {
              if (*(v51 - 1) == v13 >> 8 && *v51 == v13) {
                char v53 = 0;
              }
              else {
                char v53 = -1;
              }
              *__int16 v50 = v53;
              *(v50 - 1) = v53;
              *(v50 - 2) = *v51;
              char v54 = *(v51 - 1);
              v51 -= 2;
              *(v50 - 3) = v54;
              v50 -= 4;
              --v52;
            }
            while (v52);
          }
        }
        else if (v14 == 8 && v3)
        {
          unsigned int v44 = (char *)(a2 + 2 * v3 - 1);
          uint64_t v45 = (char *)(v3 + a2 - 1);
          int v46 = v3;
          do
          {
            if (*v45 == v13) {
              char v47 = 0;
            }
            else {
              char v47 = -1;
            }
            *unsigned int v44 = v47;
            char v48 = *v45--;
            *(v44 - 1) = v48;
            v44 -= 2;
            --v46;
          }
          while (v46);
        }
        *((unsigned char *)result + 16) = 4;
        *((unsigned char *)result + 18) = 2;
        unsigned __int8 v30 = 2 * *((unsigned char *)result + 17);
        unsigned int v31 = v30;
        goto LABEL_77;
    }
    uint64_t v43 = 0;
    goto LABEL_58;
  }
  if (!a3 || *((unsigned char *)result + 16) != 2) {
    return result;
  }
  int v4 = *((unsigned __int8 *)result + 17);
  if (v4 == 16)
  {
    if (v3)
    {
      unsigned int v23 = a3[1];
      unsigned int v24 = a3[2];
      unsigned int v25 = a3[3];
      __int8 v26 = (char *)(a2 + 8 * v3 - 1);
      uint16x8_t v27 = (char *)(*((void *)result + 1) + a2 - 3);
      int v28 = *result;
      do
      {
        if (v23 >> 8 == *(v27 - 3)
          && *(v27 - 2) == v23
          && v24 >> 8 == *(v27 - 1)
          && *v27 == v24
          && v25 >> 8 == v27[1]
          && v27[2] == v25)
        {
          char v29 = 0;
        }
        else
        {
          char v29 = -1;
        }
        *__int8 v26 = v29;
        *(v26 - 1) = v29;
        *(v26 - 2) = v27[2];
        *(v26 - 3) = v27[1];
        *(v26 - 4) = *v27;
        *(v26 - 5) = *(v27 - 1);
        *(v26 - 6) = *(v27 - 2);
        *(v26 - 7) = *(v27 - 3);
        v26 -= 8;
        v27 -= 6;
        --v28;
      }
      while (v28);
    }
  }
  else if (v4 == 8 && v3)
  {
    uint64_t v5 = (char *)(a2 + 4 * v3 - 1);
    unint64_t v6 = (char *)(a2 + *((void *)result + 1) - 1);
    int v7 = *((unsigned __int8 *)a3 + 6);
    int v8 = *((unsigned __int8 *)a3 + 4);
    int v9 = *((unsigned __int8 *)a3 + 2);
    int v10 = *result;
    do
    {
      if (*(v6 - 2) == v9 && *(v6 - 1) == v8 && *v6 == v7) {
        char v11 = 0;
      }
      else {
        char v11 = -1;
      }
      *uint64_t v5 = v11;
      *(v5 - 1) = *v6;
      *(v5 - 2) = *(v6 - 1);
      char v12 = *(v6 - 2);
      v6 -= 3;
      *(v5 - 3) = v12;
      v5 -= 4;
      --v10;
    }
    while (v10);
  }
  *((unsigned char *)result + 16) = 6;
  *((unsigned char *)result + 18) = 4;
  unsigned __int8 v30 = 4 * *((unsigned char *)result + 17);
  unsigned int v31 = v30;
LABEL_77:
  *((unsigned char *)result + 19) = v30;
  BOOL v55 = v31 >= 8;
  unint64_t v56 = (v30 * (unint64_t)v3 + 7) >> 3;
  unint64_t v57 = v3 * (unint64_t)(v30 >> 3);
  if (!v55) {
    unint64_t v57 = v56;
  }
  *((void *)result + 1) = v57;
  return result;
}

uint64_t png_do_read_interlace(uint64_t result, uint64_t a2, int a3, int a4)
{
  v57[1] = *MEMORY[0x1E4F143B8];
  if (!result || !a2) {
    return result;
  }
  uint64_t v4 = result;
  int v5 = *(_DWORD *)result;
  int v6 = dword_1889AD248[a3];
  unsigned int v7 = v6 * *(_DWORD *)result;
  unint64_t v8 = *(unsigned __int8 *)(result + 19);
  switch(v8)
  {
    case 4:
      int v36 = (4 * (*(_DWORD *)result & 1)) ^ 4;
      int v37 = ~(4 * v7) & 4;
      if ((a4 & 0x10000) != 0)
      {
        int v38 = 4;
      }
      else
      {
        int v36 = 4 * (*(_DWORD *)result & 1);
        int v37 = 4 * (v7 & 1);
        int v38 = 0;
      }
      if ((a4 & 0x10000) != 0) {
        int v39 = 0;
      }
      else {
        int v39 = 4;
      }
      if ((a4 & 0x10000) != 0) {
        int v40 = -4;
      }
      else {
        int v40 = 4;
      }
      if (v5)
      {
        unsigned int v41 = 0;
        uint64_t v42 = (unsigned __int8 *)(a2 + ((v5 - 1) >> 1));
        uint64_t v43 = (unsigned char *)(a2 + ((v7 - 1) >> 1));
        if (v6 <= 1) {
          int v6 = 1;
        }
        uint64_t result = 3855;
        do
        {
          int v44 = (*v42 >> v36) & 0xF;
          int v45 = v6;
          do
          {
            *uint64_t v43 = (0xF0Fu >> (4 - v37)) & *v43 | (v44 << v37);
            BOOL v20 = v37 == v39;
            uint64_t v46 = v37 == v39;
            v37 += v40;
            if (v20) {
              int v37 = v38;
            }
            v43 -= v46;
            --v45;
          }
          while (v45);
          BOOL v20 = v36 == v39;
          uint64_t v47 = v36 == v39;
          v36 += v40;
          if (v20) {
            int v36 = v38;
          }
          v42 -= v47;
          ++v41;
        }
        while (v41 < *(_DWORD *)v4);
      }
      goto LABEL_79;
    case 2:
      int v23 = (2 * (_BYTE)v5 + 6) & 6 ^ 6;
      int v24 = 2 * v7 + 6;
      int v25 = ~v24 & 6;
      if ((a4 & 0x10000) != 0)
      {
        int v23 = (2 * (_BYTE)v5 + 6) & 6;
        int v25 = v24 & 6;
        int v26 = 6;
      }
      else
      {
        int v26 = 0;
      }
      if ((a4 & 0x10000) != 0) {
        int v27 = 0;
      }
      else {
        int v27 = 6;
      }
      if ((a4 & 0x10000) != 0) {
        int v28 = -2;
      }
      else {
        int v28 = 2;
      }
      if (v5)
      {
        unsigned int v29 = 0;
        unsigned __int8 v30 = (unsigned __int8 *)(a2 + ((v5 - 1) >> 2));
        unsigned int v31 = (unsigned char *)(a2 + ((v7 - 1) >> 2));
        if (v6 <= 1) {
          int v6 = 1;
        }
        uint64_t result = 16191;
        do
        {
          int v32 = (*v30 >> v23) & 3;
          int v33 = v6;
          do
          {
            *unsigned int v31 = (0x3F3Fu >> (6 - v25)) & *v31 | (v32 << v25);
            BOOL v20 = v25 == v27;
            uint64_t v34 = v25 == v27;
            v25 += v28;
            if (v20) {
              int v25 = v26;
            }
            v31 -= v34;
            --v33;
          }
          while (v33);
          BOOL v20 = v23 == v27;
          uint64_t v35 = v23 == v27;
          v23 += v28;
          if (v20) {
            int v23 = v26;
          }
          v30 -= v35;
          ++v29;
        }
        while (v29 < *(_DWORD *)v4);
      }
      goto LABEL_79;
    case 1:
      unsigned int v9 = v5 - 1;
      int v10 = (v5 - 1) & 7;
      int v11 = -v7 & 7;
      uint64_t result = (v7 - 1) & 7;
      if ((a4 & 0x10000) != 0) {
        int v11 = (v7 - 1) & 7;
      }
      else {
        v10 ^= 7u;
      }
      if ((a4 & 0x10000) != 0) {
        int v12 = 7;
      }
      else {
        int v12 = 0;
      }
      if ((a4 & 0x10000) != 0) {
        int v13 = 0;
      }
      else {
        int v13 = 7;
      }
      if ((a4 & 0x10000) != 0) {
        int v14 = -1;
      }
      else {
        int v14 = 1;
      }
      if (v5)
      {
        unsigned int v15 = 0;
        unsigned int v16 = (unsigned __int8 *)(a2 + (v9 >> 3));
        unint64_t v17 = (unsigned char *)(a2 + ((v7 - 1) >> 3));
        if (v6 <= 1) {
          int v6 = 1;
        }
        uint64_t result = 32639;
        do
        {
          int v18 = (*v16 >> v10) & 1;
          int v19 = v6;
          do
          {
            *unint64_t v17 = (0x7F7Fu >> (7 - v11)) & *v17 | (v18 << v11);
            BOOL v20 = v11 == v13;
            uint64_t v21 = v11 == v13;
            v11 += v14;
            if (v20) {
              int v11 = v12;
            }
            v17 -= v21;
            --v19;
          }
          while (v19);
          BOOL v20 = v10 == v13;
          uint64_t v22 = v10 == v13;
          v10 += v14;
          if (v20) {
            int v10 = v12;
          }
          v16 -= v22;
          ++v15;
        }
        while (v15 < *(_DWORD *)v4);
      }
      goto LABEL_79;
  }
  if (v5)
  {
    unsigned int v48 = 0;
    size_t v49 = v8 >> 3;
    __int16 v50 = (char *)(a2 + (v8 >> 3) * (unint64_t)(v7 - 1));
    uint64_t v51 = a2 + (v8 >> 3) * (unint64_t)(v5 - 1);
    if (v6 <= 1) {
      int v52 = 1;
    }
    else {
      int v52 = dword_1889AD248[a3];
    }
    do
    {
      v57[0] = 0;
      __memcpy_chk();
      int v53 = v52;
      do
      {
        uint64_t result = (uint64_t)memcpy(v50, v57, v49);
        v50 -= v49;
        --v53;
      }
      while (v53);
      v51 -= v49;
      ++v48;
    }
    while (v48 < *(_DWORD *)v4);
LABEL_79:
    LODWORD(v8) = *(unsigned __int8 *)(v4 + 19);
  }
  *(_DWORD *)uint64_t v4 = v7;
  BOOL v54 = v8 >= 8;
  unint64_t v55 = (v7 * (unint64_t)v8 + 7) >> 3;
  unint64_t v56 = v7 * (unint64_t)(v8 >> 3);
  if (v54) {
    unint64_t v55 = v56;
  }
  *(void *)(v4 + 8) = v55;
  return result;
}

uint64_t _cg_png_set_row_number(uint64_t result, int a2)
{
  *(_DWORD *)(result + 308) = a2;
  return result;
}

uint64_t _cg_png_set_idat_size(uint64_t result, int a2)
{
  *(_DWORD *)(result + 360) = a2;
  return result;
}

uint64_t png_read_finish_IDAT(uint64_t result)
{
  uint64_t v1 = result;
  if ((*(unsigned char *)(result + 80) & 8) == 0)
  {
    uint64_t result = png_read_IDAT_data(result, 0);
    *(void *)(v1 + 120) = 0;
    int v2 = *(_DWORD *)(v1 + 80);
    if ((v2 & 8) == 0)
    {
      *(_DWORD *)(v1 + 76) |= 8u;
      *(_DWORD *)(v1 + 80) = v2 | 8;
    }
  }
  if (*(_DWORD *)(v1 + 92) == 1229209940)
  {
    *(void *)(v1 + 92) = 0;
    *(void *)(v1 + 100) = 0;
    uint64_t v3 = *(unsigned int *)(v1 + 360);
    return png_crc_finish(v1, v3);
  }
  return result;
}

uint8x8_t png_read_filter_row_avg_neon(uint64_t a1, unsigned char *a2, unsigned char *a3, uint8x8_t result, uint16x8_t a5, uint8x8_t a6, double a7, int32x2_t a8)
{
  uint64_t v8 = *(void *)(a1 + 8);
  *a2 += *a3 >> 1;
  a2[1] += a3[1] >> 1;
  a2[2] += a3[2] >> 1;
  a2[3] += a3[3] >> 1;
  unsigned int v9 = (int32x2_t *)(a2 + 4);
  int v10 = (int32x4_t *)(a3 + 4);
  uint64_t v11 = v8 - 4;
  if ((unint64_t)(v8 - 4) < 0x10)
  {
    unint64_t v12 = v8 - 4;
  }
  else
  {
    a8.i32[0] = *(_DWORD *)a2;
    uint64_t result = (uint8x8_t)0x706050480808080;
    a5.i32[1] = -2139062144;
    a6.i32[1] = -2139062144;
    unint64_t v12 = v8 - 4;
    do
    {
      int32x4_t v13 = *v10++;
      uint8x16_t v14 = (uint8x16_t)vaddq_s8((int8x16_t)vhaddq_u8((uint8x16_t)vdupq_lane_s32(*(int32x2_t *)v13.i8, 0), (uint8x16_t)vdupq_lane_s32(a8, 0)), (int8x16_t)vdupq_lane_s32(*v9, 0));
      uint8x16_t v15 = (uint8x16_t)vdupq_lane_s32(*(int32x2_t *)v13.i8, 1);
      v15.i32[0] = v14.i32[0];
      uint8x16_t v16 = (uint8x16_t)vaddq_s8(vqtbl1q_s8(*(int8x16_t *)v9->i8, (int8x16_t)xmmword_1889AD4E0), (int8x16_t)vhaddq_u8(v14, v15));
      v15.i64[0] = v16.i64[0];
      v15.i64[1] = vdupq_laneq_s32(v13, 2).i64[1];
      uint8x16_t v17 = (uint8x16_t)vaddq_s8(vqtbl1q_s8(*(int8x16_t *)v9->i8, (int8x16_t)xmmword_1889AD4F0), (int8x16_t)vhaddq_u8(v16, v15));
      uint8x16_t v18 = v17;
      v18.i32[3] = v13.i32[3];
      int8x16_t v19 = vaddq_s8(vqtbl1q_s8(*(int8x16_t *)v9->i8, (int8x16_t)xmmword_1889AD500), (int8x16_t)vhaddq_u8(v17, v18));
      *(int8x16_t *)v9->i8 = v19;
      v9 += 2;
      a8 = (int32x2_t)vextq_s8(v19, (int8x16_t)0, 0xCuLL).u64[0];
      v12 -= 16;
    }
    while (v12 > 0xF);
  }
  if (v12 >= 4)
  {
    BOOL v20 = (unsigned __int32 *)&a2[v11 & 0xFFFFFFFFFFFFFFF0];
    do
    {
      result.i32[0] = v9->i32[0];
      unsigned __int32 v21 = *v20++;
      a5.i32[0] = v21;
      a5 = vmovl_u8(*(uint8x8_t *)a5.i8);
      __int32 v22 = v10->i32[0];
      int v10 = (int32x4_t *)((char *)v10 + 4);
      a6.i32[0] = v22;
      a6 = (uint8x8_t)vmovl_u8(a6).u64[0];
      *(uint16x4_t *)a5.i8 = vhadd_u16((uint16x4_t)a6, *(uint16x4_t *)a5.i8);
      uint64_t result = (uint8x8_t)vmovn_s16((int16x8_t)vaddw_u8(a5, result));
      v9->i32[0] = result.i32[0];
      unsigned int v9 = (int32x2_t *)((char *)v9 + 4);
      v12 -= 4;
    }
    while (v12 > 3);
  }
  return result;
}

uint64_t png_init_filter_functions_apple(void *a1, int a2)
{
  a1[122] = png_read_filter_row_up_apple_vector;
  a1[121] = png_read_filter_row_sub_apple_neon;
  if (a2 == 4)
  {
    a1[124] = png_read_filter_row_paeth4_apple;
    a1[121] = png_read_filter_row_sub4_a64;
    uint64_t v4 = png_read_filter_row_avg4_a64;
  }
  else
  {
    if (a2 != 3) {
      goto LABEL_6;
    }
    a1[124] = png_read_filter_row_paeth3_apple;
    uint64_t v4 = png_read_filter_row_avg3_apple;
  }
  a1[123] = v4;
LABEL_6:
  uint64_t result = AppleGetCPUCapabilities();
  if (a2 == 4 && (result & 0x100) != 0)
  {
    a1[121] = png_read_filter_row_sub_neon;
    a1[122] = png_read_filter_row_up_4bpp_neon;
    a1[123] = png_read_filter_row_avg_neon;
    a1[124] = png_read_filter_row_paeth_neon;
  }
  return result;
}

uint64_t png_init_filter_functions(uint64_t a1)
{
  unsigned int v1 = (*(unsigned __int8 *)(a1 + 394) + 7) >> 3;
  *(void *)(a1 + 968) = png_read_filter_row_sub;
  *(void *)(a1 + 976) = png_read_filter_row_up;
  *(void *)(a1 + 984) = png_read_filter_row_avg;
  int v2 = png_read_filter_row_paeth_multibyte_pixel;
  if (v1 == 1) {
    int v2 = png_read_filter_row_paeth_1byte_pixel;
  }
  *(void *)(a1 + 992) = v2;
  return png_init_filter_functions_apple((void *)a1, v1);
}

uint64_t AppleGetCPUCapabilities()
{
  if (AppleGetCPUCapabilities::onceToken != -1) {
    dispatch_once(&AppleGetCPUCapabilities::onceToken, &__block_literal_global_30);
  }
  return AppleGetCPUCapabilities::gImageIO_cpu_capabilities;
}

uint64_t png_app_error(uint64_t a1, char *a2)
{
  if ((*(unsigned char *)(a1 + 82) & 0x40) == 0) {
    _cg_png_error((void (**)(void))a1, a2);
  }

  return png_warning(a1, a2);
}

uint64_t _CGImageReadSessionFinalize(void *a1)
{
  atomic_fetch_add_explicit(&gReadSessionCount, 0xFFFFFFFFFFFFFFFFLL, memory_order_relaxed);
  uint64_t result = a1[3];
  if (result) {
    uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
  }
  a1[2] = 0;
  a1[3] = 0;
  return result;
}

void IIOImageReadSession::~IIOImageReadSession(IIOImageReadSession *this)
{
  IIOImageReadSession::~IIOImageReadSession(this);

  JUMPOUT(0x18C11C0E0);
}

{
  const void *v1;
  void *v2;

  *((void *)this + 5) = 0;
  *(void *)this = &unk_1ED4E4C40;
  *((void *)this + 1) = 0;
  int v2 = (void *)((char *)this + 24);
  unsigned int v1 = (const void *)*((void *)this + 3);
  if (v1) {
    CFRelease(v1);
  }
  void *v2 = 0;
  v2[1] = 0;
}

CGImageSourceRef CGImageSourceCreateWithDataProvider(CGDataProviderRef provider, CFDictionaryRef options)
{
  kdebug_trace();
  IIOInitDebugFlags();
  if (provider)
  {
    CFTypeID v4 = CFGetTypeID(provider);
    if (v4 == CGDataProviderGetTypeID())
    {
      if (options)
      {
        CFTypeID v5 = CFGetTypeID(options);
        if (v5 != CFDictionaryGetTypeID())
        {
          LogError("CGImageSourceCreateWithDataProvider", 4490, "*** ERROR: CGImageSourceCreateWithDataProvider: options parameter is not a CFDictionaryRef - ignoring\n");
          options = 0;
        }
      }
      memset(v9, 0, sizeof(v9));
      IIODictionary::IIODictionary((IIODictionary *)v9, options);
      operator new();
    }
    LogError("CGImageSourceCreateWithDataProvider", 4487, "*** ERROR: CGImageSourceCreateWithDataProvider: dataConsumer is not a CGDataProviderRef\n");
  }
  else
  {
    LogError("CGImageSourceCreateWithDataProvider", 4486, "*** ERROR: CGImageSourceCreateWithDataProvider: dataProvider is nil\n");
  }
  unsigned int v6 = gIIODebugFlags;
  if ((gIIODebugFlags & 0x800000000000) != 0)
  {
    ImageIOLog(" ISSUE: %s:%d:  %s\n", "CGImageSourceCreateWithDataProvider", 4509, "could not create CGImageSourceRef");
    unsigned int v6 = gIIODebugFlags;
  }
  int v7 = (v6 >> 12) & 3;
  if (v7) {
    ImageIODebugOptions(v7, "A", "CGImageSourceCreateWithDataProvider", 0, 0, -1, options);
  }
  kdebug_trace();
  kdebug_trace();
  return 0;
}

void sub_18859D114(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  MEMORY[0x18C11C0E0](v4, 0x10E1C40A1B1CD90);
  IIODictionary::~IIODictionary((IIODictionary *)va);
  _Unwind_Resume(a1);
}

void metadataSetSource(uint64_t a1, int a2)
{
  if (a1)
  {
    CFDictionaryRef v3 = *(const __CFDictionary **)(a1 + 24);
    if (v3)
    {
      int64_t Count = CFDictionaryGetCount(v3);
      unsigned int v6 = (const void **)malloc_type_calloc(8uLL, Count, 0xBF61FE04uLL);
      int v7 = (const void **)malloc_type_calloc(8uLL, Count, 0x19865A04uLL);
      CFDictionaryGetKeysAndValues(*(CFDictionaryRef *)(a1 + 24), v6, v7);
      if (Count >= 1)
      {
        uint64_t v8 = (uint64_t *)v7;
        do
        {
          uint64_t v9 = *v8++;
          *(_DWORD *)(CGImageSourceGetSource(v9) + 68) = a2;
          --Count;
        }
        while (Count);
      }
      if (v6) {
        free(v6);
      }
      if (v7)
      {
        free(v7);
      }
    }
  }
}

uint64_t IIOMemoryHash::remove(uint64_t **this, unint64_t a2)
{
  unint64_t v5 = ~a2;
  int v2 = (char *)(this + 1);
  unsigned int v6 = &v5;
  uint64_t v3 = std::__tree<std::__value_type<unsigned long,unsigned long>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,unsigned long>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,unsigned long>>>::__emplace_unique_key_args<unsigned long,std::piecewise_construct_t const&,std::tuple<unsigned long const&>,std::tuple<>>(this + 1, &v5, (uint64_t)&std::piecewise_construct, (uint64_t **)&v6)[5];
  std::__tree<std::__value_type<unsigned long,unsigned long>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,unsigned long>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,unsigned long>>>::__erase_unique<unsigned long>((uint64_t)v2, &v5);
  return v3;
}

void metadataSetUnspecifiedSource(uint64_t a1, int a2)
{
  int64_t Count = CFDictionaryGetCount(*(CFDictionaryRef *)(a1 + 24));
  unint64_t v5 = (const void **)malloc_type_calloc(8uLL, Count, 0xCA0516E0uLL);
  unsigned int v6 = (const void **)malloc_type_calloc(8uLL, Count, 0x1765CA0CuLL);
  CFDictionaryGetKeysAndValues(*(CFDictionaryRef *)(a1 + 24), v5, v6);
  if (Count >= 1)
  {
    int v7 = (uint64_t *)v6;
    do
    {
      uint64_t Source = CGImageSourceGetSource(*v7);
      if (*(_DWORD *)(Source + 68) <= 1u) {
        *(_DWORD *)(Source + 68) = a2;
      }
      ++v7;
      --Count;
    }
    while (Count);
  }
  if (v5) {
    free(v5);
  }
  if (v6)
  {
    free(v6);
  }
}

uint64_t _CGImageSourceFinalize(CGImageSource *a1)
{
  atomic_fetch_add_explicit(&gISRCount, 0xFFFFFFFFFFFFFFFFLL, memory_order_relaxed);
  unsigned int v2 = (gIIODebugFlags >> 12) & 3;
  if (v2) {
    ImageIODebugOptions(v2, "A", "_CGImageSourceFinalize", a1, 0, -1, 0);
  }
  uint64_t result = CGTrackImageSource((unint64_t)a1, -1);
  uint64_t v4 = *((void *)a1 + 3);
  if (v4)
  {
    unint64_t v5 = *(IIO_Reader **)(v4 + 104);
    if (v5) {
      IIO_Reader::osType(v5);
    }
    kdebug_trace();
    uint64_t Source = (IIOImageRead *)CGImageSourceGetSource(*(void *)(*((void *)a1 + 3) + 16));
    if (Source)
    {
      int v7 = Source;
      IIOImageRead::lock(Source);
      IIOImageRead::setISR(v7, 0);
      IIOImageRead::unlock(v7);
    }
    uint64_t result = *((void *)a1 + 3);
    if (result) {
      uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
    }
  }
  *((void *)a1 + 2) = 0;
  *((void *)a1 + 3) = 0;
  return result;
}

uint64_t CGImageSourceRefCreateWith_ImageSource(uint64_t a1)
{
  if (CGImageSourceGetTypeID::once != -1) {
    dispatch_once(&CGImageSourceGetTypeID::once, &__block_literal_global_164);
  }
  uint64_t Instance = _CFRuntimeCreateInstance();
  *(_DWORD *)(Instance + 16) = 1;
  atomic_fetch_add_explicit(&gISRCount, 1uLL, memory_order_relaxed);
  CGTrackImageSource(Instance, 1);
  *(void *)(Instance + 24) = a1;
  *(void *)(a1 + 8) = Instance;
  uint64_t Source = (IIOImageRead *)CGImageSourceGetSource(*(void *)(a1 + 16));
  if (Source)
  {
    uint64_t v4 = Source;
    IIOImageRead::lock(Source);
    IIOImageRead::setISR(v4, Instance);
    IIOImageRead::unlock(v4);
  }
  return Instance;
}

IIOImageSource *IIOImageRead::setISR(IIOImageRead *this, uint64_t a2)
{
  uint64_t result = (IIOImageSource *)CGImageSourceGetSource(a2);
  if (result)
  {
    uint64_t result = (IIOImageSource *)IIOImageSource::forceUseServer(result);
    *((unsigned char *)this + 456) = (_BYTE)result;
  }
  *((void *)this + 2) = ~a2;
  return result;
}

uint64_t IIOImageRead::unlock(IIOImageRead *this)
{
  return pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 376));
}

uint64_t IIOImageRead::lock(IIOImageRead *this)
{
  return pthread_mutex_lock((pthread_mutex_t *)((char *)this + 376));
}

BOOL CGTrackImageSource(unint64_t a1, int a2)
{
  os_unfair_lock_lock((os_unfair_lock_t)&CGTrackImageSource(CGImageSource *,int)::mutex);
  if (!CGTrackImageSource(CGImageSource *,int)::gImageSources) {
    operator new();
  }
  unint64_t v4 = ~a1;
  unint64_t v19 = ~a1;
  if (a2 == -1)
  {
    uint64_t v6 = CGTrackImageSource(CGImageSource *,int)::gImageSources + 8;
    int v7 = *(void **)(CGTrackImageSource(CGImageSource *,int)::gImageSources + 8);
    if (!v7) {
      goto LABEL_18;
    }
    uint64_t v8 = CGTrackImageSource(CGImageSource *,int)::gImageSources + 8;
    do
    {
      unint64_t v9 = v7[4];
      BOOL v10 = v9 >= v4;
      if (v9 >= v4) {
        uint64_t v11 = v7;
      }
      else {
        uint64_t v11 = v7 + 1;
      }
      if (v10) {
        uint64_t v8 = (uint64_t)v7;
      }
      int v7 = (void *)*v11;
    }
    while (*v11);
    if (v8 == v6 || *(void *)(v8 + 32) > v4) {
LABEL_18:
    }
      uint64_t v8 = CGTrackImageSource(CGImageSource *,int)::gImageSources + 8;
    BOOL v5 = v8 != v6;
    std::__tree<std::__value_type<unsigned long,unsigned long>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,unsigned long>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,unsigned long>>>::__erase_unique<unsigned long>(CGTrackImageSource(CGImageSource *,int)::gImageSources, &v19);
  }
  else if (a2)
  {
    if (a2 == 1)
    {
      BOOL v20 = &v19;
      BOOL v5 = 1;
      std::__tree<std::__value_type<unsigned long,unsigned long>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,unsigned long>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,unsigned long>>>::__emplace_unique_key_args<unsigned long,std::piecewise_construct_t const&,std::tuple<unsigned long const&>,std::tuple<>>((uint64_t **)CGTrackImageSource(CGImageSource *,int)::gImageSources, &v19, (uint64_t)&std::piecewise_construct, (uint64_t **)&v20)[5] = 1;
    }
    else
    {
      BOOL v5 = 0;
    }
  }
  else
  {
    uint64_t v12 = CGTrackImageSource(CGImageSource *,int)::gImageSources + 8;
    int32x4_t v13 = *(void **)(CGTrackImageSource(CGImageSource *,int)::gImageSources + 8);
    if (!v13) {
      goto LABEL_31;
    }
    uint64_t v14 = CGTrackImageSource(CGImageSource *,int)::gImageSources + 8;
    do
    {
      unint64_t v15 = v13[4];
      BOOL v16 = v15 >= v4;
      if (v15 >= v4) {
        uint8x16_t v17 = v13;
      }
      else {
        uint8x16_t v17 = v13 + 1;
      }
      if (v16) {
        uint64_t v14 = (uint64_t)v13;
      }
      int32x4_t v13 = (void *)*v17;
    }
    while (*v17);
    if (v14 == v12 || *(void *)(v14 + 32) > v4) {
LABEL_31:
    }
      uint64_t v14 = CGTrackImageSource(CGImageSource *,int)::gImageSources + 8;
    BOOL v5 = v14 != v12;
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&CGTrackImageSource(CGImageSource *,int)::mutex);
  return v5;
}

uint64_t *std::__tree<std::__value_type<unsigned long,unsigned long>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,unsigned long>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,unsigned long>>>::__emplace_unique_key_args<unsigned long,std::piecewise_construct_t const&,std::tuple<unsigned long const&>,std::tuple<>>(uint64_t **a1, unint64_t *a2, uint64_t a3, uint64_t **a4)
{
  int v7 = a1 + 1;
  uint64_t v6 = a1[1];
  if (v6)
  {
    unint64_t v8 = *a2;
    while (1)
    {
      while (1)
      {
        unint64_t v9 = (uint64_t **)v6;
        unint64_t v10 = v6[4];
        if (v8 >= v10) {
          break;
        }
        uint64_t v6 = *v9;
        int v7 = v9;
        if (!*v9) {
          goto LABEL_10;
        }
      }
      if (v10 >= v8) {
        break;
      }
      uint64_t v6 = v9[1];
      if (!v6)
      {
        int v7 = v9 + 1;
        goto LABEL_10;
      }
    }
  }
  else
  {
    unint64_t v9 = a1 + 1;
LABEL_10:
    uint64_t v11 = (uint64_t *)operator new(0x30uLL);
    v11[4] = **a4;
    v11[5] = 0;
    std::__tree<std::__value_type<unsigned long,unsigned long>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,unsigned long>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,unsigned long>>>::__insert_node_at(a1, (uint64_t)v9, v7, v11);
    return v11;
  }
  return (uint64_t *)v9;
}

void CGImageMetadataMerge(uint64_t a1, uint64_t a2, IIODictionary *a3)
{
  if (a1)
  {
    CFTypeID v6 = CFGetTypeID((CFTypeRef)a1);
    CFTypeID TypeID = CGImageMetadataGetTypeID();
    if (a2)
    {
      if (v6 == TypeID)
      {
        CFTypeID v8 = CFGetTypeID((CFTypeRef)a2);
        if (v8 == CGImageMetadataGetTypeID())
        {
          CFIndex Count = CFDictionaryGetCount(*(CFDictionaryRef *)(a2 + 24));
          CFDictionaryGetCount(*(CFDictionaryRef *)(a1 + 24));
          if (Count < 1)
          {
            uint64_t v11 = 0;
            uint64_t v12 = 0;
LABEL_86:
            CFDictionaryRef v45 = *(const __CFDictionary **)(a2 + 32);
            if (v45 && CFDictionaryGetCount(v45))
            {
              if (*(void *)(a1 + 32))
              {
                if ((IIODictionaryIsMutable() & 1) == 0)
                {
                  _cg_jpeg_mem_term("CGImageMetadataMerge", 871, "*** ERROR: metadata->_NStoPrefix is immutable???\n");
                  CFDictionaryRef v46 = *(const __CFDictionary **)(a1 + 32);
                  *(void *)(a1 + 32) = CFDictionaryCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, v46);
                  CFRelease(v46);
                }
              }
              else
              {
                *(void *)(a1 + 32) = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
              }
              size_t v60 = 0;
              int v61 = 0;
              uint64_t v62 = 0;
              uint64_t v47 = IIODictionary::IIODictionary((IIODictionary *)&v60, *(__CFDictionary **)(a1 + 32));
              IIODictionary::appendDictionary(v47, *(const __CFDictionary **)(a2 + 32));
              IIODictionary::~IIODictionary((IIODictionary *)&v60);
            }
            CFDictionaryRef v48 = *(const __CFDictionary **)(a2 + 40);
            if (v48 && CFDictionaryGetCount(v48))
            {
              CFMutableArrayRef Mutable = *(__CFDictionary **)(a1 + 40);
              if (!Mutable)
              {
                CFMutableArrayRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
                *(void *)(a1 + 40) = Mutable;
              }
              size_t v60 = 0;
              int v61 = 0;
              uint64_t v62 = 0;
              __int16 v50 = IIODictionary::IIODictionary((IIODictionary *)&v60, Mutable);
              IIODictionary::appendDictionary(v50, *(const __CFDictionary **)(a2 + 40));
              IIODictionary::~IIODictionary((IIODictionary *)&v60);
            }
            if (*(void *)(a2 + 48))
            {
              uint64_t v51 = *(__CFDictionary **)(a1 + 48);
              if (!v51)
              {
                uint64_t v51 = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
                *(void *)(a1 + 48) = v51;
              }
              size_t v60 = 0;
              int v61 = 0;
              uint64_t v62 = 0;
              int v52 = IIODictionary::IIODictionary((IIODictionary *)&v60, v51);
              IIODictionary::appendDictionary(v52, *(const __CFDictionary **)(a2 + 48));
              IIODictionary::~IIODictionary((IIODictionary *)&v60);
            }
            if (!v11) {
              goto LABEL_104;
            }
          }
          else
          {
            unint64_t v10 = (const void **)malloc_type_malloc(8 * Count, 0x2004093837F09uLL);
            if (!v10) {
              return;
            }
            uint64_t v11 = v10;
            uint64_t v12 = (const void **)malloc_type_malloc(8 * Count, 0x2004093837F09uLL);
            if (v12)
            {
              CFDictionaryGetKeysAndValues(*(CFDictionaryRef *)(a2 + 24), v11, v12);
              CFStringRef v13 = *(const __CFString **)(a2 + 56);
              if (v13)
              {
                uint64_t v14 = *(const void **)(a1 + 56);
                if (v14)
                {
                  CFRelease(v14);
                  CFStringRef v13 = *(const __CFString **)(a2 + 56);
                }
                *(void *)(a1 + 56) = CFStringCreateCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v13);
              }
              CFStringRef v15 = *(const __CFString **)(a2 + 64);
              if (v15)
              {
                BOOL v16 = *(const void **)(a1 + 64);
                if (v16)
                {
                  CFRelease(v16);
                  CFStringRef v15 = *(const __CFString **)(a2 + 64);
                }
                *(void *)(a1 + 64) = CFStringCreateCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v15);
              }
              BOOL v57 = CGImageIIMDigestsMatchOrMissing(a1);
              uint64_t v54 = a2;
              if (a3)
              {
                unsigned int v56 = IIODictionary::containsKey(a3, @"kCGImageMetadataMergeOverwrite");
                BOOL BoolForKey = IIODictionary::getBoolForKey(a3, @"kCGImageSourceShouldPreferIPTCToEXIF");
              }
              else
              {
                unsigned int v56 = 0;
                BOOL BoolForKey = 0;
              }
              uint64_t v18 = 0;
              int v53 = !v57 || BoolForKey;
              uint64_t v55 = *MEMORY[0x1E4F1D260];
              while (1)
              {
                unint64_t v19 = v12[v18];
                if (!v19) {
                  goto LABEL_81;
                }
                CFTypeID v20 = CFGetTypeID(v12[v18]);
                if (v20 != CGImageMetadataTagGetTypeID()) {
                  goto LABEL_81;
                }
                uint64_t Source = CGImageSourceGetSource((uint64_t)v19);
                value = 0;
                int ValueIfPresent = CFDictionaryGetValueIfPresent(*(CFDictionaryRef *)(a1 + 24), v11[v18], (const void **)&value);
                uint64_t v23 = CGImageSourceGetSource((uint64_t)value);
                int v24 = CGImageMetadataTagGetSource((uint64_t)v19);
                char v25 = v24;
                if (!ValueIfPresent)
                {
                  char v29 = v57;
                  if (v24 != 8) {
                    char v29 = 1;
                  }
                  if ((v29 & 1) == 0)
                  {
                    CGMutableImageMetadataRef v30 = CGImageMetadataCreateMutable();
                    if (v30)
                    {
                      unsigned int v31 = v30;
                      CGImageMetadataAddTag((uint64_t)v30, v19);
                      int v32 = (IIODictionary *)CGImagePropertiesCreateFromMetadata(v31);
                      if (v32)
                      {
                        int v33 = v32;
                        CFDictionaryRef ObjectForKey = IIODictionary::getObjectForKey(v32, @"{IPTC}");
                        if (ObjectForKey)
                        {
                          size_t v60 = 0;
                          int v61 = 0;
                          uint64_t v62 = 0;
                          uint64_t v35 = IIODictionary::IIODictionary((IIODictionary *)&v60, ObjectForKey);
                          BOOL v36 = SizeOfIPTCData(v35) != 0;
                          IIODictionary::~IIODictionary((IIODictionary *)&v60);
                        }
                        else
                        {
                          BOOL v36 = 0;
                        }
                        (*(void (**)(IIODictionary *))(*(void *)v33 + 8))(v33);
                        CFRelease(v31);
                        if (v36) {
                          goto LABEL_81;
                        }
                      }
                      else
                      {
                        CFRelease(v31);
                      }
                    }
                  }
                  goto LABEL_80;
                }
                char v26 = CGImageMetadataTagGetSource((uint64_t)value);
                size_t v60 = @"http://ns.adobe.com/photoshop/1.0/";
                int v61 = @"DateCreated";
                uint64_t v62 = 0;
                v58[2] = 0;
                v59[0] = @"http://ns.adobe.com/xap/1.0/";
                v59[1] = @"CreateDate";
                v59[2] = 0;
                v58[0] = @"http://ns.adobe.com/xap/1.0/";
                v58[1] = @"ModifyDate";
                if (CGImageMetadataTagKeyEqual((CFTypeRef *)v11[v18], (CFTypeRef *)&v60)
                  || CGImageMetadataTagKeyEqual((CFTypeRef *)v11[v18], v59)
                  || CGImageMetadataTagKeyEqual((CFTypeRef *)v11[v18], v58))
                {
                  break;
                }
LABEL_52:
                if (v56)
                {
                  if (CGImageMetadataTagGetValue((uint64_t)v19) == v55)
                  {
                    CGImageMetadataRemoveTag(a1, (uint64_t)v19);
                  }
                  else
                  {
                    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 24), v11[v18], v19);
                    CGImageMetadataTagGetSource((uint64_t)v19);
                  }
                  goto LABEL_81;
                }
                int v42 = CGImageMetadataTagGetSource((uint64_t)v19);
                unsigned int v43 = CGImageMetadataTagGetSource((uint64_t)value);
                if ((v42 & 2) != 0)
                {
                  if (v43 == 4)
                  {
                    if (v53) {
                      goto LABEL_81;
                    }
                  }
                  else if (v43 != 8 && (~v43 & 0x22) != 0)
                  {
                    goto LABEL_81;
                  }
                }
                else if (v42 == 16)
                {
                  if (v43 != 4 && v43 != 8 && (v43 & 2) == 0) {
                    goto LABEL_81;
                  }
                }
                else
                {
                  if (v42 == 8)
                  {
                    int v44 = v57;
                    if (v43 != 4) {
                      int v44 = 0;
                    }
                  }
                  else
                  {
                    if (v42 != 4 || v43 == 4) {
                      goto LABEL_81;
                    }
                    if (v43 == 8)
                    {
                      if (v57) {
                        goto LABEL_81;
                      }
                      goto LABEL_80;
                    }
                    int v44 = v53 & (v43 >> 1);
                  }
                  if (v44 != 1) {
                    goto LABEL_81;
                  }
                }
LABEL_80:
                CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 24), v11[v18], v19);
LABEL_81:
                if (Count == ++v18)
                {
                  a2 = v54;
                  goto LABEL_86;
                }
              }
              uint64_t v27 = v23;
              if ((v26 & 0xC) != 0 || (uint64_t v27 = Source, (v25 & 0xC) != 0))
              {
                CFStringRef v28 = *(const __CFString **)(v27 + 48);
                if ((v26 & 2) != 0) {
                  goto LABEL_40;
                }
              }
              else
              {
                CFStringRef v28 = 0;
                if ((v26 & 2) != 0) {
                  goto LABEL_40;
                }
              }
              uint64_t v23 = Source;
              if ((v25 & 2) == 0) {
                goto LABEL_52;
              }
LABEL_40:
              CFStringRef v37 = *(const __CFString **)(v23 + 48);
              if (!v37 || !v28) {
                goto LABEL_52;
              }
              CFStringRef EXIFDataTimeStringWithXMPDateTimeString = CreateEXIFDataTimeStringWithXMPDateTimeString(v28);
              CFStringRef v39 = CreateEXIFDataTimeStringWithXMPDateTimeString(v37);
              CFStringRef v40 = v39;
              if (EXIFDataTimeStringWithXMPDateTimeString && v39)
              {
                char v41 = 0;
                if (CFEqual(EXIFDataTimeStringWithXMPDateTimeString, v39)
                  && (v25 & 0xC) != 0)
                {
                  CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 24), v11[v18], v19);
                  char v41 = 1;
                }
              }
              else
              {
                char v41 = 0;
                if (!EXIFDataTimeStringWithXMPDateTimeString) {
                  goto LABEL_49;
                }
              }
              CFRelease(EXIFDataTimeStringWithXMPDateTimeString);
LABEL_49:
              if (v40) {
                CFRelease(v40);
              }
              if (v41) {
                goto LABEL_81;
              }
              goto LABEL_52;
            }
          }
          free(v11);
LABEL_104:
          if (v12) {
            free(v12);
          }
        }
      }
    }
  }
}

void sub_18859DEB8(_Unwind_Exception *a1)
{
  IIODictionary::~IIODictionary((IIODictionary *)(v1 - 120));
  _Unwind_Resume(a1);
}

uint64_t CGImageMetadataTagKeyEqual(CFTypeRef *a1, CFTypeRef *a2)
{
  uint64_t result = CFEqual(a1[1], a2[1]);
  if (result) {
    return CFEqual(*a1, *a2) != 0;
  }
  return result;
}

void *CGImageMetadataGetTagWithPath(void *a1, void *Value, const __CFString *a3)
{
  uint64_t v3 = 0;
  unint64_t v4 = 0;
  uint64_t v58 = 0;
  int v59 = &v58;
  uint64_t v60 = 0x2000000000;
  uint64_t v61 = 0;
  if (a1)
  {
    CFTypeID v8 = CFGetTypeID(a1);
    if (CGImageMetadataGetTypeID::once != -1) {
      dispatch_once(&CGImageMetadataGetTypeID::once, &__block_literal_global_21);
    }
    uint64_t v3 = 0;
    if (!a3)
    {
      unint64_t v4 = 0;
      goto LABEL_89;
    }
    unint64_t v4 = 0;
    if (v8 == CGImageMetadataGetTypeID::id)
    {
      CFTypeID v9 = CFGetTypeID(a3);
      if (v9 == CFStringGetTypeID())
      {
        uint64_t Source = CGImageSourceGetSource((uint64_t)Value);
        if (!Value)
        {
          CFAllocatorRef v13 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
          CFStringRef cf = CFStringCreateCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a3);
          int v17 = 0;
          uint64_t v18 = parse_metadata_pathString(cf);
          goto LABEL_21;
        }
        uint64_t v11 = (IIOMetadata_Tag *)Source;
        CFTypeID v12 = CFGetTypeID(Value);
        if (v12 == CGImageMetadataTagGetTypeID())
        {
          CFAllocatorRef v13 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
          CFStringRef v14 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"%@:%@", *((void *)v11 + 3), *((void *)v11 + 4));
          if (v14)
          {
            CFStringRef cf = IIOMetadata_Tag::createPathWithChildPath(v11, a3);
            CFStringRef v15 = parse_metadata_pathString(v14);
            if (v15)
            {
              uint64_t v16 = *((void *)v15 + 5);
              if (v16)
              {
                int v17 = 0;
                do
                {
                  if ((*(_DWORD *)v16 & 0xFFFFFFFE) != 2) {
                    break;
                  }
                  ++v17;
                  uint64_t v16 = *(void *)(v16 + 40);
                }
                while (v16);
              }
              else
              {
                int v17 = 0;
              }
              freeNodes(v15);
            }
            else
            {
              int v17 = 0;
            }
            CFRelease(v14);
            uint64_t v18 = parse_metadata_pathString(cf);
LABEL_21:
            uint64_t v3 = v18;
            if (v18 && (unint64_t v19 = (char *)*((void *)v18 + 1)) != 0 && *((void *)v3 + 2))
            {
              if (Value)
              {
                uint64_t v20 = CGImageSourceGetSource((uint64_t)Value);
                int v21 = v17 + 1;
                __int32 v22 = v3;
                do
                {
                  __int32 v22 = (char *)*((void *)v22 + 5);
                  --v21;
                }
                while (v21);
                CFStringRef PropertyPrefixFromCStrPrefix = 0;
                CFStringRef v50 = 0;
                goto LABEL_34;
              }
              CFStringRef PropertyPrefixFromCStrPrefix = createPropertyPrefixFromCStrPrefix(v19);
              CFStringRef v50 = CFStringCreateWithCString(v13, *((const char **)v3 + 2), 0x8000100u);
              if (v50)
              {
                uint64_t v23 = CGImageMetadataNamespaceForPrefix(a1, PropertyPrefixFromCStrPrefix);
                if (v23)
                {
                  CFDictionaryRef v24 = (const __CFDictionary *)a1[3];
                  if (v24)
                  {
                    key = v23;
                    p_isa = &v50->isa;
                    uint64_t v56 = 0;
                    Value = (void *)CFDictionaryGetValue(v24, &key);
                  }
                  else
                  {
                    Value = 0;
                  }
                  uint64_t v20 = CGImageSourceGetSource((uint64_t)Value);
                  __int32 v22 = (char *)*((void *)v3 + 5);
LABEL_34:
                  CFStringRef v25 = 0;
                  if (!Value || !v22)
                  {
                    unint64_t v4 = Value;
                    CFStringRef v29 = 0;
                    goto LABEL_79;
                  }
                  while (1)
                  {
                    CFTypeID v26 = CFGetTypeID(Value);
                    if (v26 != CGImageMetadataTagGetTypeID()) {
                      break;
                    }
                    uint64_t v27 = (char *)*((void *)v22 + 1);
                    if (v27) {
                      CFStringRef v25 = createPropertyPrefixFromCStrPrefix(v27);
                    }
                    else {
                      CFStringRef v25 = 0;
                    }
                    CFStringRef v28 = (const char *)*((void *)v22 + 2);
                    if (v28) {
                      CFStringRef v29 = CFStringCreateWithCString(v13, v28, 0x8000100u);
                    }
                    else {
                      CFStringRef v29 = 0;
                    }
                    switch(*(_DWORD *)v22)
                    {
                      case 2:
                        if (CGImageMetadataTagGetType((CGImageMetadataTagRef)Value) != kCGImageMetadataTypeArrayOrdered
                          && CGImageMetadataTagGetType((CGImageMetadataTagRef)Value) != kCGImageMetadataTypeArrayUnordered
                          && CGImageMetadataTagGetType((CGImageMetadataTagRef)Value) != kCGImageMetadataTypeAlternateArray)
                        {
                          goto LABEL_90;
                        }
                        CGMutableImageMetadataRef v30 = (const void *)CGImageMetadataTagGetValue((uint64_t)Value);
                        CFTypeID v31 = CFGetTypeID(v30);
                        if (v31 != CFArrayGetTypeID()) {
                          goto LABEL_90;
                        }
                        CFIndex v32 = *((int *)v22 + 6);
                        if (CFArrayGetCount((CFArrayRef)v30) <= v32) {
                          goto LABEL_90;
                        }
                        ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)v30, *((int *)v22 + 6));
                        uint64_t v34 = (uint64_t)ValueAtIndex;
                        if (!ValueAtIndex) {
                          goto LABEL_90;
                        }
                        CFTypeID v35 = CFGetTypeID(ValueAtIndex);
                        CFTypeID TypeID = CGImageMetadataTagGetTypeID();
                        CFStringRef v37 = v59;
                        if (v35 == TypeID) {
                          goto LABEL_63;
                        }
                        CFTypeRef v59[3] = 0;
                        LogMetadata("CGImageMetadataGetTagWithPath", 740, "Error: Array element's value was not a CGImageMetadataTagRef\n");
                        goto LABEL_67;
                      case 3:
                        if (CGImageMetadataTagGetType((CGImageMetadataTagRef)Value) != kCGImageMetadataTypeAlternateText) {
                          goto LABEL_90;
                        }
                        int v38 = (const void *)CGImageMetadataTagGetValue((uint64_t)Value);
                        CFTypeID v39 = CFGetTypeID(v38);
                        if (v39 != CFArrayGetTypeID()) {
                          goto LABEL_90;
                        }
                        CFStringRef v40 = CFStringCreateWithCString(v13, *((const char **)v22 + 4), 0x8000100u);
                        CFStringRef v41 = v40;
                        if (!v40) {
                          goto LABEL_90;
                        }
                        key = 0;
                        p_isa = &key;
                        uint64_t v56 = 0x2000000000;
                        char v57 = 0;
                        v53[0] = MEMORY[0x1E4F143A8];
                        v53[1] = 0x40000000;
                        std::string v53[2] = __CGImageMetadataGetTagWithPath_block_invoke;
                        v53[3] = &unk_1E53C7278;
                        v53[5] = &key;
                        v53[6] = v40;
                        v53[4] = &v58;
                        IIOArrayEnumerateUsingBlock((uint64_t)v38, (uint64_t)v53);
                        if (!*((unsigned char *)p_isa + 24)) {
                          CFTypeRef v59[3] = 0;
                        }
                        CFRelease(v41);
                        _Block_object_dispose(&key, 8);
                        goto LABEL_67;
                      case 4:
                        if (CGImageMetadataTagGetType((CGImageMetadataTagRef)Value) != kCGImageMetadataTypeStructure
                          || (int v42 = (const void *)CGImageMetadataTagGetValue((uint64_t)Value),
                              CFTypeID v43 = CFGetTypeID(v42),
                              v43 != CFDictionaryGetTypeID())
                          || !v29
                          || (v44 = CFDictionaryGetValue((CFDictionaryRef)v42, v29), (uint64_t v34 = (uint64_t)v44) == 0))
                        {
LABEL_90:
                          unint64_t v4 = 0;
                          goto LABEL_79;
                        }
                        CFTypeID v45 = CFGetTypeID(v44);
                        CFTypeID v46 = CGImageMetadataTagGetTypeID();
                        CFStringRef v37 = v59;
                        if (v45 == v46)
                        {
LABEL_63:
                          v37[3] = v34;
                        }
                        else
                        {
                          CFTypeRef v59[3] = 0;
                          LogMetadata("CGImageMetadataGetTagWithPath", 717, "Error: Structure field's value was not a CGImageMetadataTagRef\n");
                        }
LABEL_67:
                        __int32 v22 = (char *)*((void *)v22 + 5);
                        Value = (void *)v59[3];
                        if (v22 && !Value)
                        {
                          uint64_t v20 = 0;
                          if (!v25) {
                            goto LABEL_73;
                          }
LABEL_72:
                          CFRelease(v25);
                          goto LABEL_73;
                        }
                        uint64_t v20 = CGImageSourceGetSource(v59[3]);
                        CFTypeRef v59[3] = 0;
                        if (v25) {
                          goto LABEL_72;
                        }
LABEL_73:
                        if (v29) {
                          CFRelease(v29);
                        }
                        if (!Value || !v22)
                        {
                          CFStringRef v25 = 0;
                          CFStringRef v29 = 0;
                          unint64_t v4 = Value;
                          goto LABEL_79;
                        }
                        break;
                      case 5:
                        uint64_t v47 = *(void *)(v20 + 56);
                        if (v47)
                        {
                          v52[0] = MEMORY[0x1E4F143A8];
                          v52[1] = 0x40000000;
                          v52[2] = __CGImageMetadataGetTagWithPath_block_invoke_2;
                          v52[3] = &unk_1E53C72A0;
                          v52[5] = v25;
                          v52[6] = v29;
                          v52[4] = &v58;
                          IIOArrayEnumerateUsingBlock(v47, (uint64_t)v52);
                        }
                        goto LABEL_67;
                      default:
                        goto LABEL_67;
                    }
                  }
                }
                unint64_t v4 = 0;
                goto LABEL_92;
              }
              unint64_t v4 = 0;
            }
            else
            {
              unint64_t v4 = 0;
              CFStringRef PropertyPrefixFromCStrPrefix = 0;
            }
            CFStringRef v50 = 0;
LABEL_92:
            CFStringRef v25 = 0;
            CFStringRef v29 = 0;
LABEL_79:
            if (cf) {
              CFRelease(cf);
            }
            if (PropertyPrefixFromCStrPrefix) {
              CFRelease(PropertyPrefixFromCStrPrefix);
            }
            if (v50) {
              CFRelease(v50);
            }
            if (v25) {
              CFRelease(v25);
            }
            if (v29) {
              CFRelease(v29);
            }
            goto LABEL_89;
          }
        }
      }
      uint64_t v3 = 0;
      unint64_t v4 = 0;
    }
  }
LABEL_89:
  freeNodes(v3);
  _Block_object_dispose(&v58, 8);
  return v4;
}

void sub_18859E5C4(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 136), 8);
  _Unwind_Resume(a1);
}

uint64_t CGImageSourceGetSource(uint64_t result)
{
  if (result) {
    return *(void *)(result + 24);
  }
  return result;
}

void freeNodes(void *a1)
{
  if (a1)
  {
    uint64_t v1 = a1;
    do
    {
      unsigned int v2 = (void *)v1[5];
      uint64_t v3 = (void *)v1[1];
      if (v3) {
        free(v3);
      }
      unint64_t v4 = (void *)v1[2];
      if (v4) {
        free(v4);
      }
      BOOL v5 = (void *)v1[4];
      if (v5) {
        free(v5);
      }
      free(v1);
      uint64_t v1 = v2;
    }
    while (v2);
  }
}

char *parse_metadata_pathString(const __CFString *a1)
{
  pthread_mutex_lock(&parse_metadata_pathString::mutex);
  CStringPtr = (char *)CFStringGetCStringPtr(a1, 0);
  if (CStringPtr)
  {
    uint64_t v3 = parse_metadata_path(CStringPtr);
  }
  else
  {
    CFIndex Length = CFStringGetLength(a1);
    CFIndex v5 = CFStringGetMaximumSizeForEncoding(Length, 0) + 1;
    CFTypeID v6 = (char *)malloc_type_calloc(1uLL, v5, 0x1419E70BuLL);
    if (v6)
    {
      int v7 = v6;
      if (CFStringGetCString(a1, v6, v5, 0)) {
        uint64_t v3 = parse_metadata_path(v7);
      }
      else {
        uint64_t v3 = 0;
      }
      free(v7);
    }
    else
    {
      uint64_t v3 = 0;
    }
  }
  pthread_mutex_unlock(&parse_metadata_pathString::mutex);
  return v3;
}

char *parse_metadata_path(char *result)
{
  if (result)
  {
    uint64_t v1 = result;
    uint64_t v7 = 0;
    uint64_t v8 = 0;
    CFTypeID v9 = malloc_type_calloc(0x18uLL, 1uLL, 0x2CD795DAuLL);
    yylex_init_extra((uint64_t)v9, &v7);
    uint64_t v8 = 0;
    unsigned int v2 = (void **)yy_scan_string(v1, v7);
    if (yyparse(&v7))
    {
      if (v9)
      {
        int v3 = *((_DWORD *)v9 + 2) - *((_DWORD *)v9 + 1);
        size_t v4 = v3 & ~(v3 >> 31);
        uint64_t result = (char *)malloc_type_malloc((v4 + 1), 0x4AD4B78FuLL);
        if (!result) {
          return result;
        }
        CFIndex v5 = result;
        memset(result, 126, v4);
        v5[v4] = 0;
        LogMetadata("parse_metadata_path", 72, "Error occured '%s' at columns: %d:%d while parsing metadata path.\n%s\n%*s%s\n", *((const char **)v9 + 2), *((_DWORD *)v9 + 1), *((_DWORD *)v9 + 2), v1, *((_DWORD *)v9 + 1) + 1, "^", v5);
        free(v5);
      }
      else
      {
        LogMetadata("parse_metadata_path", 77, "Error occured while parsing metadata path: '%s'", v1);
      }
      return 0;
    }
    else
    {
      yy_delete_buffer(v2, v7);
      CFTypeID v6 = v9;
      if (v9)
      {
        if (*((void *)v9 + 2))
        {
          free(*((void **)v9 + 2));
          CFTypeID v6 = v9;
        }
        free(v6);
      }
      yylex_destroy(v7);
      return (char *)v8;
    }
  }
  return result;
}

uint64_t yylex_destroy(uint64_t a1)
{
  for (int i = *(void **)(a1 + 40); i; int i = *(void **)(a1 + 40))
  {
    if (!i[*(void *)(a1 + 24)]) {
      break;
    }
    yy_delete_buffer((void **)i[*(void *)(a1 + 24)], a1);
    *(void *)(*(void *)(a1 + 40) + 8 * *(void *)(a1 + 24)) = 0;
    yypop_buffer_state(a1);
  }
  free(i);
  *(void *)(a1 + 40) = 0;
  free(*(void **)(a1 + 96));
  free((void *)a1);
  return 0;
}

uint64_t yylex_init_extra(uint64_t a1, void *a2)
{
  if (a2)
  {
    size_t v4 = malloc_type_malloc(0x98uLL, 0xB53DB697uLL);
    *a2 = v4;
    if (v4)
    {
      CFIndex v5 = v4;
      uint64_t result = 0;
      v5[18] = 0;
      *((_OWORD *)v5 + 7) = 0u;
      *((_OWORD *)v5 + 8) = 0u;
      *((_OWORD *)v5 + 5) = 0u;
      *((_OWORD *)v5 + 6) = 0u;
      *((_OWORD *)v5 + 3) = 0u;
      *((_OWORD *)v5 + 4) = 0u;
      *((_OWORD *)v5 + 1) = 0u;
      *((_OWORD *)v5 + 2) = 0u;
      *(_OWORD *)CFIndex v5 = 0u;
      *(void *)*a2 = a1;
      uint64_t v7 = (void *)*a2;
      *((_DWORD *)v7 + 21) = 0;
      *((_DWORD *)v7 + 22) = 0;
      v7[12] = 0;
      *(_OWORD *)(v7 + 1) = 0u;
      *(_OWORD *)(v7 + 3) = 0u;
      v7[5] = 0;
      v7[8] = 0;
      v7[9] = 0;
      return result;
    }
    uint64_t v8 = __error();
    int v9 = 12;
  }
  else
  {
    uint64_t v8 = __error();
    int v9 = 22;
  }
  int *v8 = v9;
  return 1;
}

void *yy_scan_bytes(char *a1, int a2, uint64_t a3)
{
  size_t v6 = a2 + 2;
  uint64_t v7 = malloc_type_malloc(v6, 0xB53DB697uLL);
  if (!v7)
  {
    CFTypeID v12 = (FILE *)*MEMORY[0x1E4F143C8];
    CFAllocatorRef v13 = "out of dynamic memory in yy_scan_bytes()";
    goto LABEL_9;
  }
  if (a2 >= 1)
  {
    uint64_t v8 = a2;
    int v9 = v7;
    do
    {
      char v10 = *a1++;
      *v9++ = v10;
      --v8;
    }
    while (v8);
  }
  *(_WORD *)&v7[a2] = 0;
  uint64_t result = yy_scan_buffer((uint64_t)v7, v6, a3);
  if (!result)
  {
    CFTypeID v12 = (FILE *)*MEMORY[0x1E4F143C8];
    CFAllocatorRef v13 = "bad buffer in yy_scan_bytes()";
LABEL_9:
    fprintf(v12, "%s\n", v13);
    exit(2);
  }
  *((_DWORD *)result + 9) = 1;
  return result;
}

void *yy_scan_buffer(uint64_t a1, unint64_t a2, uint64_t a3)
{
  unint64_t v3 = a2 - 2;
  if (a2 < 2 || *(unsigned char *)(a1 + v3) || *(unsigned char *)(a2 + a1 - 1)) {
    return 0;
  }
  uint64_t v8 = malloc_type_malloc(0x40uLL, 0xB53DB697uLL);
  if (!v8)
  {
    fprintf((FILE *)*MEMORY[0x1E4F143C8], "%s\n", "out of dynamic memory in yy_scan_buffer()");
    exit(2);
  }
  CFIndex v5 = v8;
  v8[2] = a1;
  v8[3] = v3;
  void *v8 = 0;
  v8[1] = a1;
  *((_DWORD *)v8 + 8) = v3;
  *(void *)((char *)v8 + 36) = 0;
  *((_DWORD *)v8 + 11) = 1;
  v8[7] = 0;
  yy_switch_to_buffer((uint64_t)v8, a3);
  return v5;
}

uint64_t yyparse(uint64_t *a1)
{
  uint64_t v38 = 0;
  yynerrs = 0;
  long long v35 = 0u;
  long long v36 = 0u;
  long long v37 = 0u;
  if (!yygrowstack((uint64_t)&v35))
  {
    uint64_t v8 = 0;
    int v9 = -1;
    *(void *)&long long v36 = *((void *)&v35 + 1);
    *((void *)&v37 + 1) = v37;
    **((_WORD **)&v35 + 1) = 0;
    while (((0x1FC3C3BuLL >> v8) & 1) != 0)
    {
      if (v9 < 0)
      {
        int v11 = yylex((uint64_t)&v38, *a1, v2, v3, v4, v5, v6, v7);
        int v9 = v11 & ~(v11 >> 31);
      }
      if (((0x603C3CCuLL >> v8) & 1) != 0
        || (uint64_t v12 = (v9 + yysindex[v8]), v12 > 0x111)
        || v9 != (__int16)yycheck[v12])
      {
        if (((0x783DBCFuLL >> v8) & 1) != 0
          || (uint64_t v14 = (v9 + yyrindex[v8]), v14 > 0x111)
          || v9 != (__int16)yycheck[v14])
        {
          yyerror((uint64_t)a1, "syntax error", v2, v3, v4, v5, v6, v7, v35);
          ++yynerrs;
          unint64_t v31 = v36;
          uint64_t v32 = *((void *)&v37 + 1);
          while (v31 > *((void *)&v35 + 1))
          {
            v31 -= 2;
            v32 -= 8;
          }
          *(void *)&long long v36 = v31;
          *((void *)&v37 + 1) = v32;
          goto LABEL_62;
        }
        char v10 = (char *)&yytable[v14];
LABEL_19:
        uint64_t v15 = *(__int16 *)v10;
        uint64_t v16 = yylen[v15];
        int v17 = (uint64_t *)*((void *)&v37 + 1);
        uint64_t v18 = *(void *)(*((void *)&v37 + 1) + 8 * (1 - v16));
        switch((int)v15)
        {
          case 1:
            uint64_t v18 = **((void **)&v37 + 1);
            goto LABEL_25;
          case 2:
            uint64_t v18 = *(void *)(*((void *)&v37 + 1) - 16);
            unint64_t v19 = (int *)**((void **)&v37 + 1);
            int v20 = 4;
            goto LABEL_24;
          case 3:
            uint64_t v18 = *(void *)(*((void *)&v37 + 1) - 16);
            unint64_t v19 = (int *)**((void **)&v37 + 1);
            int v20 = 5;
LABEL_24:
            *unint64_t v19 = v20;
            appendNode(v18, *v17);
            fixPrefixes((char *)v18);
LABEL_25:
            a1[1] = v18;
            break;
          case 5:
          case 10:
          case 11:
          case 15:
          case 17:
            uint64_t v18 = **((void **)&v37 + 1);
            break;
          case 6:
            uint64_t v18 = *(void *)(*((void *)&v37 + 1) - 16);
            int v21 = (int *)**((void **)&v37 + 1);
            int v22 = 4;
            goto LABEL_28;
          case 7:
            uint64_t v18 = *(void *)(*((void *)&v37 + 1) - 16);
            int v21 = (int *)**((void **)&v37 + 1);
            int v22 = 5;
LABEL_28:
            *int v21 = v22;
            goto LABEL_37;
          case 8:
            uint64_t v18 = **((void **)&v37 + 1);
            goto LABEL_35;
          case 9:
            uint64_t v18 = *(void *)(*((void *)&v37 + 1) - 8);
            *(_DWORD *)uint64_t v18 = 1;
            goto LABEL_37;
          case 12:
            uint64_t v18 = **((void **)&v37 + 1);
            ***((_DWORD ***)&v37 + 1) = 0;
            break;
          case 13:
            uint64_t v18 = *(void *)(*((void *)&v37 + 1) - 8);
            *(_DWORD *)uint64_t v18 = 0;
            goto LABEL_37;
          case 14:
            uint64_t v18 = **((void **)&v37 + 1);
            *(void *)(**((void **)&v37 + 1) + 8) = *(void *)(*(void *)(*((void *)&v37 + 1) - 8) + 8);
            free((void *)*(v17 - 1));
            break;
          case 16:
            uint64_t v18 = *(void *)(*((void *)&v37 + 1) - 8);
            *(void *)(v18 + 16) = *(void *)(**((void **)&v37 + 1) + 16);
            free((void *)*v17);
LABEL_35:
            *(_DWORD *)uint64_t v18 = 1;
            break;
          case 18:
            uint64_t v18 = *(void *)(*((void *)&v37 + 1) - 8);
LABEL_37:
            appendNode(v18, *v17);
            break;
          case 19:
            uint64_t v18 = **((void **)&v37 + 1);
            ***((_DWORD ***)&v37 + 1) = 3;
            break;
          case 20:
            uint64_t v18 = **((void **)&v37 + 1);
            ***((_DWORD ***)&v37 + 1) = 2;
            break;
          default:
            break;
        }
        uint64_t v23 = (__int16 *)(v36 - 2 * v16);
        *(void *)&long long v36 = v23;
        int v24 = *v23;
        uint64_t v25 = *((void *)&v37 + 1) - 8 * v16;
        *((void *)&v37 + 1) = v25;
        if (v24) {
          BOOL v26 = 1;
        }
        else {
          BOOL v26 = (unint64_t)(v15 - 1) > 3;
        }
        if (v26)
        {
          uint64_t v27 = yylhs[v15];
          if (((0x19uLL >> v27) & 1) != 0
            || (uint64_t v28 = (yygindex[v27] + v24), v28 > 0x111)
            || yycheck[v28] != (unsigned __int16)v24)
          {
            CFStringRef v29 = (char *)&yydgoto + 2 * v27;
          }
          else
          {
            CFStringRef v29 = (char *)&yytable[v28];
          }
          uint64_t v8 = *(__int16 *)v29;
          if ((unint64_t)v23 >= *((void *)&v36 + 1))
          {
            if (yygrowstack((uint64_t)&v35)) {
              goto LABEL_2;
            }
            uint64_t v23 = (__int16 *)v36;
            uint64_t v25 = *((void *)&v37 + 1);
          }
          v23[1] = v8;
          *(void *)&long long v36 = v23 + 1;
          *((void *)&v37 + 1) = v25 + 8;
          *(void *)(v25 + 8) = v18;
        }
        else
        {
          v23[1] = 3;
          *(void *)&long long v36 = v23 + 1;
          *((void *)&v37 + 1) = v25 + 8;
          *(void *)(v25 + 8) = v18;
          if (v9 < 0)
          {
            int v30 = yylex((uint64_t)&v38, *a1, v2, v3, v4, v5, v6, v7);
            int v9 = v30 & ~(v30 >> 31);
          }
          uint64_t v8 = 3;
          if (!v9)
          {
            uint64_t v34 = 0;
            goto LABEL_63;
          }
        }
      }
      else
      {
        uint64_t v13 = v36;
        if ((unint64_t)v36 >= *((void *)&v36 + 1))
        {
          if (yygrowstack((uint64_t)&v35)) {
            goto LABEL_2;
          }
          uint64_t v13 = v36;
        }
        uint64_t v8 = yytable[v12];
        *(_WORD *)(v13 + 2) = v8;
        *(void *)&long long v36 = v13 + 2;
        *((void *)&v37 + 1) += 8;
        **((void **)&v37 + 1) = v38;
        int v9 = -1;
      }
    }
    char v10 = (char *)&yydefred + 2 * v8;
    goto LABEL_19;
  }
LABEL_2:
  yyerror((uint64_t)a1, "yacc stack overflow", v2, v3, v4, v5, v6, v7, v35);
LABEL_62:
  uint64_t v34 = 1;
LABEL_63:
  yyfreestack((uint64_t)&v35);
  return v34;
}

uint64_t yylex(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  *(void *)(a2 + 144) = a1;
  if (!*(_DWORD *)(a2 + 72))
  {
    *(_DWORD *)(a2 + 72) = 1;
    int v9 = *(int **)a2;
    if (*(void *)a2)
    {
      _DWORD v9[2] = 0;
      *(void *)int v9 = 0;
      *((void *)v9 + 2) = 0;
    }
    if (!*(_DWORD *)(a2 + 76)) {
      *(_DWORD *)(a2 + 76) = 1;
    }
    if (!*(void *)(a2 + 8)) {
      *(void *)(a2 + 8) = *MEMORY[0x1E4F143D0];
    }
    if (!*(void *)(a2 + 16)) {
      *(void *)(a2 + 16) = *MEMORY[0x1E4F143D8];
    }
    uint64_t v10 = *(void *)(a2 + 40);
    if (!v10 || (uint64_t v11 = *(void *)(a2 + 24), (v12 = *(void *)(v10 + 8 * v11)) == 0))
    {
      yyensure_buffer_stack((void *)a2);
      uint64_t buffer = yy_create_buffer(*(void *)(a2 + 8), 0x4000, a2);
      uint64_t v11 = *(void *)(a2 + 24);
      *(void *)(*(void *)(a2 + 40) + 8 * v11) = buffer;
      uint64_t v10 = *(void *)(a2 + 40);
      uint64_t v12 = *(void *)(v10 + 8 * v11);
    }
    *(_DWORD *)(a2 + 52) = *(_DWORD *)(v12 + 32);
    uint64_t v14 = *(unsigned char **)(v12 + 16);
    *(void *)(a2 + 64) = v14;
    *(void *)(a2 + 128) = v14;
    *(void *)(a2 + 8) = **(void **)(v10 + 8 * v11);
    *(unsigned char *)(a2 + 48) = *v14;
  }
  unsigned int v96 = (unint64_t *)(a2 + 64);
LABEL_15:
  uint64_t v15 = *(unsigned char **)(a2 + 64);
  unsigned char *v15 = *(unsigned char *)(a2 + 48);
  int v16 = *(_DWORD *)(a2 + 76);
  int v94 = v15;
  do
  {
LABEL_16:
    uint64_t v17 = yy_ec[4 * *v15];
    if (((0xD84007uLL >> v16) & 1) == 0)
    {
      *(_DWORD *)(a2 + 104) = v16;
      *(void *)(a2 + 112) = v15;
    }
    int v18 = v17 + yy_base[v16];
    if (v16 != (__int16)yy_chk[v18])
    {
      uint64_t v19 = v16;
      do
      {
        if ((0x104500uLL >> v19)) {
          LOBYTE(v17) = yy_meta[4 * v17];
        }
        uint64_t v19 = yy_def[v19];
        int v18 = yy_base[v19] + v17;
      }
      while (yy_chk[v18] != (unsigned __int16)v19);
    }
    int v16 = yy_nxt[v18];
    ++v15;
  }
  while (v16 != 23);
LABEL_24:
  while (2)
  {
    int v20 = *(_DWORD *)(a2 + 104);
    int v21 = (unsigned char **)(a2 + 112);
LABEL_25:
    int v22 = *v21;
    int v23 = yy_accept[v20];
    *(void *)(a2 + 128) = v94;
    *(_DWORD *)(a2 + 56) = v22 - v94;
    *(unsigned char *)(a2 + 48) = *v22;
    *int v22 = 0;
    v97 = v22;
    *(void *)(a2 + 64) = v22;
    while (v23 == 9)
    {
      uint64_t v24 = *(void *)(a2 + 128);
      unsigned char *v97 = *(unsigned char *)(a2 + 48);
      uint64_t v25 = *(void *)(a2 + 40);
      uint64_t v26 = *(void *)(a2 + 24);
      uint64_t v27 = *(void *)(v25 + 8 * v26);
      if (*(_DWORD *)(v27 + 60))
      {
        int v28 = *(_DWORD *)(a2 + 52);
      }
      else
      {
        int v28 = *(_DWORD *)(v27 + 32);
        *(_DWORD *)(a2 + 52) = v28;
        *(void *)uint64_t v27 = *(void *)(a2 + 8);
        uint64_t v27 = *(void *)(v25 + 8 * v26);
        *(_DWORD *)(v27 + 60) = 1;
      }
      unint64_t v29 = *v96;
      int v30 = *(unsigned char **)(v27 + 8);
      if (*v96 <= (unint64_t)&v30[v28])
      {
        *(void *)(a2 + 64) = *(void *)(a2 + 128) + ~v24 + (int)v97;
        int previous_state = yy_get_previous_state(a2);
        if (((0xD84007uLL >> previous_state) & 1) == 0)
        {
          uint64_t v61 = *(void *)(a2 + 64);
          *(_DWORD *)(a2 + 104) = previous_state;
          *(void *)(a2 + 112) = v61;
        }
        uint64_t v62 = yy_base[previous_state] + 1;
        if (previous_state != (__int16)yy_chk[v62])
        {
          uint64_t v63 = previous_state;
          do
          {
            int v64 = (unsigned __int16)yy_def[v63];
            uint64_t v63 = (__int16)v64;
          }
          while (v64 != yy_chk[yy_base[(__int16)v64] + 1]);
          LODWORD(v62) = yy_base[(__int16)v64] + 1;
        }
        int v65 = (unsigned __int16)yy_nxt[v62];
        int v94 = *(unsigned char **)(a2 + 128);
        if (v62) {
          BOOL v66 = v65 == 23;
        }
        else {
          BOOL v66 = 1;
        }
        if (!v66)
        {
          int v16 = (__int16)v65;
          uint64_t v15 = (unsigned char *)(*v96 + 1);
          *unsigned int v96 = (unint64_t)v15;
          goto LABEL_16;
        }
        goto LABEL_24;
      }
      uint64_t v31 = v28;
      if (v29 > (unint64_t)&v30[v28 + 1])
      {
        int v90 = (FILE *)*MEMORY[0x1E4F143C8];
        v91 = "fatal flex scanner internal error--end of buffer missed";
        goto LABEL_128;
      }
      uint64_t v32 = *(char **)(a2 + 128);
      unint64_t v33 = v29 - (void)v32;
      if (!*(_DWORD *)(v27 + 56))
      {
        if (v33 != 1) {
          goto LABEL_86;
        }
        goto LABEL_80;
      }
      int v34 = v33 - 1;
      if ((int)v33 >= 2)
      {
        int v35 = v33 - 1;
        do
        {
          char v36 = *v32++;
          *v30++ = v36;
          --v35;
        }
        while (v35);
        uint64_t v27 = *(void *)(*(void *)(a2 + 40) + 8 * *(void *)(a2 + 24));
      }
      int v95 = v33 - 1;
      int v93 = v24;
      if (*(_DWORD *)(v27 + 60) == 2)
      {
        *(_DWORD *)(a2 + 52) = 0;
LABEL_39:
        *(_DWORD *)(v27 + 32) = 0;
        if (!v34) {
          goto LABEL_74;
        }
        goto LABEL_40;
      }
      uint64_t v92 = v34;
      int v39 = ~v34;
      unint64_t v40 = *(void *)(v27 + 24);
      int v41 = v40 - v33;
      if ((int)v40 - (int)v33 <= 0)
      {
        int v42 = (char *)*v96;
        while (*(_DWORD *)(v27 + 36))
        {
          CFTypeID v43 = *(void **)(v27 + 8);
          uint64_t v44 = 2 * v40;
          uint64_t v45 = v40 + (v40 >> 3);
          if ((int)v44 >= 1) {
            uint64_t v45 = v44;
          }
          *(void *)(v27 + 24) = v45;
          CFTypeID v46 = (char *)malloc_type_realloc(v43, v45 + 2, 0xFAA2C7D0uLL);
          *(void *)(v27 + 8) = v46;
          if (!v46) {
            goto LABEL_127;
          }
          int v42 = &v46[(int)v42 - (int)v43];
          *(void *)(a2 + 64) = v42;
          uint64_t v27 = *(void *)(*(void *)(a2 + 40) + 8 * *(void *)(a2 + 24));
          unint64_t v40 = *(void *)(v27 + 24);
          int v41 = v40 + v39;
          if ((int)v40 + v39 >= 1) {
            goto LABEL_50;
          }
        }
        *(void *)(v27 + 8) = 0;
LABEL_127:
        int v90 = (FILE *)*MEMORY[0x1E4F143C8];
        v91 = "fatal error - scanner input buffer overflow";
LABEL_128:
        fprintf(v90, "%s\n", v91);
        exit(2);
      }
LABEL_50:
      if (v41 >= 0x2000) {
        size_t v47 = 0x2000;
      }
      else {
        size_t v47 = v41;
      }
      if (!*(_DWORD *)(v27 + 40))
      {
        *__error() = 0;
        int v50 = fread((void *)(*(void *)(*(void *)(*(void *)(a2 + 40) + 8 * *(void *)(a2 + 24)) + 8) + v92), 1uLL, v47, *(FILE **)(a2 + 8));
        *(_DWORD *)(a2 + 52) = v50;
        if (v50)
        {
LABEL_68:
          int v38 = 0;
          uint64_t v27 = *(void *)(*(void *)(a2 + 40) + 8 * *(void *)(a2 + 24));
          *(_DWORD *)(v27 + 32) = v50;
          LODWORD(v37) = v50;
LABEL_72:
          int v34 = v95;
          goto LABEL_75;
        }
        while (ferror(*(FILE **)(a2 + 8)))
        {
          if (*__error() != 4) {
            goto LABEL_131;
          }
          *__error() = 0;
          clearerr(*(FILE **)(a2 + 8));
          int v50 = fread((void *)(*(void *)(*(void *)(*(void *)(a2 + 40) + 8 * *(void *)(a2 + 24)) + 8) + v92), 1uLL, v47, *(FILE **)(a2 + 8));
          *(_DWORD *)(a2 + 52) = v50;
          if (v50) {
            goto LABEL_68;
          }
        }
        uint64_t v27 = *(void *)(*(void *)(a2 + 40) + 8 * *(void *)(a2 + 24));
        int v34 = v95;
        goto LABEL_39;
      }
      size_t v37 = 0;
      while (1)
      {
        int v48 = getc(*(FILE **)(a2 + 8));
        if (v48 == -1 || v48 == 10) {
          break;
        }
        *(unsigned char *)(*(void *)(*(void *)(*(void *)(a2 + 40) + 8 * *(void *)(a2 + 24)) + 8) + v92 + v37++) = v48;
        if (v47 == v37)
        {
          size_t v37 = v47;
          break;
        }
      }
      if (v48 == -1)
      {
        if (ferror(*(FILE **)(a2 + 8)))
        {
LABEL_131:
          int v90 = (FILE *)*MEMORY[0x1E4F143C8];
          v91 = "input in flex scanner failed";
          goto LABEL_128;
        }
      }
      else if (v48 == 10)
      {
        *(unsigned char *)(*(void *)(*(void *)(*(void *)(a2 + 40) + 8 * *(void *)(a2 + 24)) + 8) + v92 + v37) = 10;
        LODWORD(v37) = v37 + 1;
      }
      *(_DWORD *)(a2 + 52) = v37;
      uint64_t v27 = *(void *)(*(void *)(a2 + 40) + 8 * *(void *)(a2 + 24));
      *(_DWORD *)(v27 + 32) = v37;
      if (v37)
      {
        int v38 = 0;
        goto LABEL_72;
      }
      int v34 = v95;
      if (!v95)
      {
LABEL_74:
        yyrestart(*(void *)(a2 + 8), a2);
        int v34 = v95;
        LODWORD(v37) = *(_DWORD *)(a2 + 52);
        uint64_t v27 = *(void *)(*(void *)(a2 + 40) + 8 * *(void *)(a2 + 24));
        int v38 = 1;
        goto LABEL_75;
      }
LABEL_40:
      LODWORD(v37) = 0;
      int v38 = 2;
      *(_DWORD *)(v27 + 60) = 2;
LABEL_75:
      int v51 = v37 + v34;
      if (*(void *)(v27 + 24) >= (unint64_t)((int)v37 + v34))
      {
        uint64_t v56 = v51;
        uint64_t v55 = *(void *)(v27 + 8);
      }
      else
      {
        int v52 = malloc_type_realloc(*(void **)(v27 + 8), v51 + ((int)v37 >> 1), 0xFAA2C7D0uLL);
        uint64_t v53 = *(void *)(a2 + 40);
        uint64_t v54 = *(void *)(a2 + 24);
        *(void *)(*(void *)(v53 + 8 * v54) + 8) = v52;
        uint64_t v55 = *(void *)(*(void *)(v53 + 8 * v54) + 8);
        if (!v55)
        {
          int v90 = (FILE *)*MEMORY[0x1E4F143C8];
          v91 = "out of dynamic memory in yy_get_next_buffer()";
          goto LABEL_128;
        }
        uint64_t v56 = *(int *)(a2 + 52) + (uint64_t)v95;
        int v51 = *(_DWORD *)(a2 + 52) + v95;
      }
      *(_DWORD *)(a2 + 52) = v51;
      *(unsigned char *)(v55 + v56) = 0;
      *(unsigned char *)(*(int *)(a2 + 52)
               + *(void *)(*(void *)(*(void *)(a2 + 40) + 8 * *(void *)(a2 + 24)) + 8)
               + 1) = 0;
      uint64_t v57 = *(void *)(a2 + 40);
      uint64_t v58 = *(void *)(a2 + 24);
      uint64_t v32 = *(char **)(*(void *)(v57 + 8 * v58) + 8);
      *(void *)(a2 + 128) = v32;
      if (v38 != 1)
      {
        if (!v38)
        {
          *(void *)(a2 + 64) = &v32[~v93 + (int)v97];
          int v16 = yy_get_previous_state(a2);
          uint64_t v15 = *(unsigned char **)(a2 + 64);
          int v94 = *(unsigned char **)(a2 + 128);
          goto LABEL_16;
        }
        int v30 = *(unsigned char **)(*(void *)(v57 + 8 * v58) + 8);
        uint64_t v31 = *(int *)(a2 + 52);
LABEL_86:
        *(void *)(a2 + 64) = &v30[v31];
        int v20 = yy_get_previous_state(a2);
        int v94 = *(unsigned char **)(a2 + 128);
        int v21 = (unsigned char **)(a2 + 64);
        goto LABEL_25;
      }
LABEL_80:
      *(_DWORD *)(a2 + 80) = 0;
      *(void *)(a2 + 64) = v32;
      int v59 = *(_DWORD *)(a2 + 76);
      if (v59 >= 1) {
        --v59;
      }
      int v23 = (v59 >> 1) + 10;
    }
    switch(v23)
    {
      case 0:
        unsigned char *v97 = *(unsigned char *)(a2 + 48);
        continue;
      case 1:
        unsigned __int8 v70 = *(int **)a2;
        if (*(void *)a2)
        {
          int v71 = *v70 + *(_DWORD *)(a2 + 56);
          v70[1] = *v70;
          v70[2] = v71 - 1;
          *unsigned __int8 v70 = v71;
        }
        **(void **)(a2 + 144) = malloc_type_calloc(1uLL, 0x30uLL, 0x103004087E73D75uLL);
        *(void *)(**(void **)(a2 + 144) + 8) = strdup(*(const char **)(a2 + 128));
        return 257;
      case 2:
        int v73 = *(int **)a2;
        if (*(void *)a2)
        {
          int v74 = *v73 + *(_DWORD *)(a2 + 56);
          v73[1] = *v73;
          v73[2] = v74 - 1;
          *int v73 = v74;
        }
        **(void **)(a2 + 144) = malloc_type_calloc(1uLL, 0x30uLL, 0x103004087E73D75uLL);
        *(void *)(**(void **)(a2 + 144) + 16) = strdup(*(const char **)(a2 + 128));
        return 258;
      case 3:
        int v75 = *(int **)a2;
        if (*(void *)a2)
        {
          int v76 = *v75 + *(_DWORD *)(a2 + 56);
          v75[1] = *v75;
          v75[2] = v76 - 1;
          *int v75 = v76;
        }
        **(void **)(a2 + 144) = malloc_type_calloc(1uLL, 0x30uLL, 0x103004087E73D75uLL);
        int v77 = strtol((const char *)(*(void *)(a2 + 128) + 1), 0, 10);
        uint64_t v78 = *(void *)(a2 + 144);
        *(_DWORD *)(*(void *)v78 + 24) = v77;
        *(void *)(*(void *)v78 + 16) = strdup(*(const char **)(a2 + 128));
        return 259;
      case 4:
        unsigned int v79 = *(int **)a2;
        if (*(void *)a2)
        {
          int v80 = *v79 + *(_DWORD *)(a2 + 56);
          v79[1] = *v79;
          v79[2] = v80 - 1;
          *unsigned int v79 = v80;
        }
        **(void **)(a2 + 144) = malloc_type_calloc(1uLL, 0x30uLL, 0x103004087E73D75uLL);
        unsigned int v81 = *(const char **)(a2 + 128);
        CFTypeID v82 = strdup(v81 + 1);
        uint64_t v83 = *(void *)(a2 + 144);
        *(void *)(*(void *)v83 + 32) = v82;
        *(unsigned char *)(strlen(v81) + *(void *)(*(void *)v83 + 32) - 2) = 0;
        *(void *)(**(void **)(a2 + 144) + 16) = strdup(*(const char **)(a2 + 128));
        return 260;
      case 5:
        unsigned __int8 v84 = *(int **)a2;
        if (*(void *)a2)
        {
          int v85 = *v84 + *(_DWORD *)(a2 + 56);
          v84[1] = *v84;
          v84[2] = v85 - 1;
          *unsigned __int8 v84 = v85;
        }
        return 261;
      case 6:
        unsigned __int8 v86 = *(int **)a2;
        if (*(void *)a2)
        {
          int v87 = *v86 + *(_DWORD *)(a2 + 56);
          v86[1] = *v86;
          v86[2] = v87 - 1;
          *unsigned __int8 v86 = v87;
        }
        return 262;
      case 7:
        unint64_t v88 = *(int **)a2;
        if (*(void *)a2)
        {
          int v89 = *v88 + *(_DWORD *)(a2 + 56);
          v88[1] = *v88;
          v88[2] = v89 - 1;
          *unint64_t v88 = v89;
        }
        lexerror((uint64_t)v88, "Unrecognized input: '%s'", a3, a4, a5, a6, a7, a8, *(void *)(a2 + 128));
        return 263;
      case 8:
        unsigned int v67 = *(int **)a2;
        size_t v68 = *(int *)(a2 + 56);
        if (*(void *)a2)
        {
          int v69 = *v67 + v68;
          v67[1] = *v67;
          v67[2] = v69 - 1;
          *unsigned int v67 = v69;
        }
        fwrite(*(const void **)(a2 + 128), v68, 1uLL, *(FILE **)(a2 + 16));
        goto LABEL_15;
      case 10:
        return 0;
      default:
        int v90 = (FILE *)*MEMORY[0x1E4F143C8];
        v91 = "fatal flex scanner internal error--no action found";
        break;
    }
    goto LABEL_128;
  }
}

double yyfreestack(uint64_t a1)
{
  free(*(void **)(a1 + 8));
  free(*(void **)(a1 + 32));
  double result = 0.0;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)a1 = 0u;
  return result;
}

uint64_t yy_get_previous_state(uint64_t a1)
{
  uint64_t v1 = *(unsigned int *)(a1 + 76);
  uint64_t v2 = *(unsigned char **)(a1 + 128);
  uint64_t v3 = *(unsigned char **)(a1 + 64);
  if (v2 < v3)
  {
    do
    {
      if (*v2) {
        LODWORD(v4) = yy_ec[4 * *v2];
      }
      else {
        LODWORD(v4) = 1;
      }
      if (((0xD84007uLL >> v1) & 1) == 0)
      {
        *(_DWORD *)(a1 + 104) = v1;
        *(void *)(a1 + 112) = v2;
      }
      int v5 = v4 + yy_base[(int)v1];
      if (v1 != (__int16)yy_chk[v5])
      {
        uint64_t v4 = v4;
        uint64_t v1 = (int)v1;
        do
        {
          if ((0x104500uLL >> v1)) {
            LOBYTE(v4) = yy_meta[4 * v4];
          }
          uint64_t v1 = yy_def[v1];
          int v5 = yy_base[v1] + v4;
        }
        while (yy_chk[v5] != (unsigned __int16)v1);
      }
      uint64_t v1 = yy_nxt[v5];
      ++v2;
    }
    while (v2 != v3);
  }
  return v1;
}

uint64_t yygrowstack(uint64_t a1)
{
  unsigned int v2 = *(_DWORD *)a1;
  if (*(_DWORD *)a1)
  {
    if (v2 > 0x1F3) {
      return 0xFFFFFFFFLL;
    }
    unsigned int v3 = 2 * v2;
    if (v3 >= 0x1F4) {
      unsigned int v4 = 500;
    }
    else {
      unsigned int v4 = v3;
    }
  }
  else
  {
    unsigned int v4 = 500;
  }
  int v5 = *(void **)(a1 + 8);
  uint64_t v6 = *(void *)(a1 + 16);
  uint64_t v7 = (char *)malloc_type_realloc(v5, 2 * v4, 0x1000040BDFB0063uLL);
  if (v7)
  {
    uint64_t v8 = (v6 - (uint64_t)v5) >> 1;
    *(void *)(a1 + 8) = v7;
    *(void *)(a1 + 16) = &v7[2 * v8];
    int v9 = (char *)malloc_type_realloc(*(void **)(a1 + 32), 8 * v4, 0x1032040A1E07149uLL);
    if (v9)
    {
      uint64_t v10 = v9;
      uint64_t result = 0;
      *(void *)(a1 + 32) = v10;
      *(void *)(a1 + 40) = &v10[8 * v8];
      *(_DWORD *)a1 = v4;
      *(void *)(a1 + 24) = *(void *)(a1 + 8) + 2 * v4 - 2;
      return result;
    }
  }
  return 0xFFFFFFFFLL;
}

void yy_switch_to_buffer(uint64_t a1, uint64_t a2)
{
  yyensure_buffer_stack((void *)a2);
  uint64_t v4 = *(void *)(a2 + 40);
  if (v4)
  {
    uint64_t v5 = *(void *)(a2 + 24);
    uint64_t v6 = *(void *)(v4 + 8 * v5);
    if (v6 != a1)
    {
      if (v6)
      {
        **(unsigned char **)(a2 + 64) = *(unsigned char *)(a2 + 48);
        uint64_t v4 = *(void *)(a2 + 40);
        uint64_t v5 = *(void *)(a2 + 24);
        *(void *)(*(void *)(v4 + 8 * v5) + 16) = *(void *)(a2 + 64);
        *(_DWORD *)(*(void *)(v4 + 8 * v5) + 32) = *(_DWORD *)(a2 + 52);
      }
      *(void *)(v4 + 8 * v5) = a1;
      uint64_t v7 = *(void *)(a2 + 40);
      uint64_t v8 = *(void *)(v7 + 8 * v5);
      *(_DWORD *)(a2 + 52) = *(_DWORD *)(v8 + 32);
      int v9 = *(unsigned char **)(v8 + 16);
      *(void *)(a2 + 64) = v9;
      *(void *)(a2 + 128) = v9;
      *(void *)(a2 + 8) = **(void **)(v7 + 8 * v5);
      *(unsigned char *)(a2 + 48) = *v9;
      *(_DWORD *)(a2 + 80) = 1;
    }
  }
}

double yyensure_buffer_stack(void *a1)
{
  unsigned int v2 = (void *)a1[5];
  if (v2)
  {
    uint64_t v3 = a1[4];
    if (a1[3] >= (unint64_t)(v3 - 1))
    {
      uint64_t v4 = (v3 << 32) + 0x800000000;
      uint64_t v5 = (char *)malloc_type_realloc(v2, v4 >> 29, 0xFAA2C7D0uLL);
      a1[5] = v5;
      if (v5)
      {
        uint64_t v6 = &v5[8 * a1[4]];
        double result = 0.0;
        *((_OWORD *)v6 + 2) = 0u;
        *((_OWORD *)v6 + 3) = 0u;
        *(_OWORD *)uint64_t v6 = 0u;
        *((_OWORD *)v6 + 1) = 0u;
        a1[4] = v4 >> 32;
        return result;
      }
LABEL_8:
      fprintf((FILE *)*MEMORY[0x1E4F143C8], "%s\n", "out of dynamic memory in yyensure_buffer_stack()");
      exit(2);
    }
  }
  else
  {
    uint64_t v8 = malloc_type_malloc(8uLL, 0xB53DB697uLL);
    a1[5] = v8;
    if (!v8) {
      goto LABEL_8;
    }
    void *v8 = 0;
    double result = 0.0;
    *(_OWORD *)(a1 + 3) = xmmword_18898C840;
  }
  return result;
}

void *yy_scan_string(char *a1, uint64_t a2)
{
  int v4 = strlen(a1);

  return yy_scan_bytes(a1, v4, a2);
}

void yy_delete_buffer(void **a1, uint64_t a2)
{
  if (a1)
  {
    uint64_t v3 = *(void *)(a2 + 40);
    if (v3) {
      int v4 = *(void ***)(v3 + 8 * *(void *)(a2 + 24));
    }
    else {
      int v4 = 0;
    }
    if (v4 == a1) {
      *(void *)(v3 + 8 * *(void *)(a2 + 24)) = 0;
    }
    if (*((_DWORD *)a1 + 9)) {
      free(a1[1]);
    }
    free(a1);
  }
}

const void *CGImageMetadataNamespaceForPrefix(const void *result, const __CFString *a2)
{
  if (result)
  {
    uint64_t v3 = result;
    CFTypeID v4 = CFGetTypeID(result);
    CFTypeID TypeID = CGImageMetadataGetTypeID();
    double result = 0;
    if (a2)
    {
      if (v4 == TypeID)
      {
        CFTypeID v6 = CFGetTypeID(a2);
        if (v6 != CFStringGetTypeID()) {
          return 0;
        }
        double result = CGImageMetadataNamespaceForDefaultPrefix(a2);
        if (result) {
          return result;
        }
        CFDictionaryRef v7 = (const __CFDictionary *)*((void *)v3 + 5);
        if (v7 && (CFTypeID v8 = CFGetTypeID(v7), v8 == CFDictionaryGetTypeID()))
        {
          double result = CFDictionaryGetValue(v7, a2);
          if (result)
          {
            int v9 = result;
            CFTypeID v10 = CFGetTypeID(result);
            if (v10 == CFStringGetTypeID()) {
              return v9;
            }
            else {
              return 0;
            }
          }
        }
        else
        {
          return 0;
        }
      }
    }
  }
  return result;
}

CFTypeID CGImageMetadataGetTypeID(void)
{
  if (CGImageMetadataGetTypeID::once != -1) {
    dispatch_once(&CGImageMetadataGetTypeID::once, &__block_literal_global_21);
  }
  return CGImageMetadataGetTypeID::id;
}

__CFString *CGImageMetadataNamespaceForDefaultPrefix(const __CFString *a1)
{
  if (CFEqual(a1, @"exif"))
  {
    unsigned int v2 = (__CFString **)&kCGImageMetadataNamespaceExif;
    goto LABEL_27;
  }
  if (CFEqual(a1, @"tiff"))
  {
    unsigned int v2 = (__CFString **)&kCGImageMetadataNamespaceTIFF;
    goto LABEL_27;
  }
  if (CFEqual(a1, @"xmp"))
  {
    unsigned int v2 = (__CFString **)&kCGImageMetadataNamespaceXMPBasic;
    goto LABEL_27;
  }
  if (CFEqual(a1, @"dc"))
  {
    unsigned int v2 = (__CFString **)&kCGImageMetadataNamespaceDublinCore;
    goto LABEL_27;
  }
  if (CFEqual(a1, @"photoshop"))
  {
    unsigned int v2 = (__CFString **)&kCGImageMetadataNamespacePhotoshop;
    goto LABEL_27;
  }
  if (CFEqual(a1, @"exifEX"))
  {
    unsigned int v2 = (__CFString **)&kCGImageMetadataNamespaceExifEX;
    goto LABEL_27;
  }
  if (CFEqual(a1, @"Iptc4xmpCore"))
  {
    unsigned int v2 = (__CFString **)&kCGImageMetadataNamespaceIPTCCore;
    goto LABEL_27;
  }
  if (CFEqual(a1, @"Iptc4xmpExt"))
  {
    unsigned int v2 = (__CFString **)&kCGImageMetadataNamespaceIPTCExtension;
    goto LABEL_27;
  }
  if (CFEqual(a1, @"iio"))
  {
    unsigned int v2 = kCGImageMetadataNamespaceImageIO;
    goto LABEL_27;
  }
  if (CFEqual(a1, @"mwg-rs"))
  {
    unsigned int v2 = kCGImageMetadataNamespaceMWGRegions;
    goto LABEL_27;
  }
  if (CFEqual(a1, @"crs"))
  {
    unsigned int v2 = kCGImageMetadataNamespaceCameraRawSettings;
    goto LABEL_27;
  }
  if (CFEqual(a1, @"aux"))
  {
    unsigned int v2 = (__CFString **)&kCGImageMetadataNamespaceExifAux;
LABEL_27:
    double result = *v2;
    if (*v2) {
      return result;
    }
    goto LABEL_28;
  }
  if (CFEqual(a1, @"xmpRights"))
  {
    unsigned int v2 = (__CFString **)&kCGImageMetadataNamespaceXMPRights;
    goto LABEL_27;
  }
LABEL_28:
  CFSetRef Mutable = (const __CFSet *)CGImageMetadataNamespaceForDefaultPrefix::unknownPrefixSet;
  if (!CGImageMetadataNamespaceForDefaultPrefix::unknownPrefixSet)
  {
    CFSetRef Mutable = CFSetCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 1, MEMORY[0x1E4F1D548]);
    CGImageMetadataNamespaceForDefaultPrefix::unknownPrefixSet = (uint64_t)Mutable;
  }
  if (!CFSetContainsValue(Mutable, a1))
  {
    IIOString::IIOString((IIOString *)v6, a1);
    uint64_t v5 = (const char *)IIOString::utf8String((IIOString *)v6);
    _cg_jpeg_mem_term("CGImageMetadataNamespaceForDefaultPrefix", 2530, "*** unknown prefix '%s'\n", v5);
    IIOString::~IIOString((IIOString *)v6);
    CFSetAddValue((CFMutableSetRef)CGImageMetadataNamespaceForDefaultPrefix::unknownPrefixSet, a1);
  }
  return 0;
}

void sub_1885A0220(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  IIOString::~IIOString((IIOString *)va);
  _Unwind_Resume(a1);
}

CFStringRef createPropertyPrefixFromCStrPrefix(char *cStr)
{
  if (!cStr) {
    return 0;
  }
  CFAllocatorRef v1 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFStringRef v2 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], cStr, 0x8000100u);
  if (!v2) {
    return 0;
  }
  CFStringRef v3 = v2;
  v6.length = CFStringGetLength(v2) - 1;
  v6.location = 0;
  CFStringRef v4 = CFStringCreateWithSubstring(v1, v3, v6);
  CFRelease(v3);
  return v4;
}

CFTypeID CGImageMetadataTagGetTypeID(void)
{
  if (CGImageMetadataTagGetTypeID::once != -1) {
    dispatch_once(&CGImageMetadataTagGetTypeID::once, &__block_literal_global_34);
  }
  return CGImageMetadataTagGetTypeID::id;
}

uint64_t CGImageMetadataTagGetSource(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = *(void *)(result + 24);
    if (v1) {
      return *(unsigned int *)(v1 + 68);
    }
    else {
      return 0;
    }
  }
  return result;
}

uint64_t std::__tree<std::__value_type<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>,std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>>,std::__map_value_compare<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>,std::__value_type<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>,std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>>,AdobeXMPCore_Int::IUTF8StringComparator,true>,AdobeXMPCore_Int::TAllocator<std::__value_type<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>,std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>>>>::__erase_unique<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>>(uint64_t **a1, uint64_t a2)
{
  CFStringRef v3 = std::__tree<std::__value_type<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>,std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>>,std::__map_value_compare<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>,std::__value_type<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>,std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>>,AdobeXMPCore_Int::IUTF8StringComparator,true>,AdobeXMPCore_Int::TAllocator<std::__value_type<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>,std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>>>>::find<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>>((uint64_t)a1, a2);
  if (a1 + 1 == (uint64_t **)v3) {
    return 0;
  }
  std::__tree<std::__value_type<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>,std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>>,std::__map_value_compare<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>,std::__value_type<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>,std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>>,AdobeXMPCore_Int::IUTF8StringComparator,true>,AdobeXMPCore_Int::TAllocator<std::__value_type<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>,std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>>>>::erase(a1, v3);
  return 1;
}

uint64_t *std::__tree<std::__value_type<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>,std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>>,std::__map_value_compare<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>,std::__value_type<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>,std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>>,AdobeXMPCore_Int::IUTF8StringComparator,true>,AdobeXMPCore_Int::TAllocator<std::__value_type<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>,std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>>>>::erase(uint64_t **a1, uint64_t *a2)
{
  CFStringRef v3 = std::__tree<std::__value_type<unsigned long,unsigned long>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,unsigned long>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,unsigned long>>>::__remove_node_pointer(a1, a2);
  std::__destroy_at[abi:ne180100]<std::pair<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const> const,std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>>,0>((uint64_t)(a2 + 4));
  uint64_t MemoryAllocator = AdobeXMPCore_Int::IMemoryAllocator_I::GetMemoryAllocator(v4);
  (*(void (**)(uint64_t, uint64_t *))(*(void *)MemoryAllocator + 8))(MemoryAllocator, a2);
  return v3;
}

uint64_t std::__tree<std::__value_type<unsigned long,unsigned long>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,unsigned long>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,unsigned long>>>::__erase_unique<unsigned long>(uint64_t a1, unint64_t *a2)
{
  CFStringRef v2 = *(void **)(a1 + 8);
  if (!v2) {
    return 0;
  }
  unint64_t v3 = *a2;
  CFStringRef v4 = (uint64_t *)(a1 + 8);
  do
  {
    unint64_t v5 = v2[4];
    BOOL v6 = v5 >= v3;
    if (v5 >= v3) {
      CFDictionaryRef v7 = v2;
    }
    else {
      CFDictionaryRef v7 = v2 + 1;
    }
    if (v6) {
      CFStringRef v4 = v2;
    }
    CFStringRef v2 = (void *)*v7;
  }
  while (*v7);
  if (v4 == (uint64_t *)(a1 + 8) || v3 < v4[4]) {
    return 0;
  }
  std::__tree<std::__value_type<unsigned long,unsigned long>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,unsigned long>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,unsigned long>>>::__remove_node_pointer((uint64_t **)a1, v4);
  operator delete(v4);
  return 1;
}

uint64_t *std::__tree<std::__value_type<unsigned long,unsigned long>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,unsigned long>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,unsigned long>>>::__remove_node_pointer(uint64_t **a1, uint64_t *a2)
{
  CFStringRef v2 = (uint64_t *)a2[1];
  if (v2)
  {
    do
    {
      unint64_t v3 = v2;
      CFStringRef v2 = (uint64_t *)*v2;
    }
    while (v2);
  }
  else
  {
    CFStringRef v4 = a2;
    do
    {
      unint64_t v3 = (uint64_t *)v4[2];
      BOOL v5 = *v3 == (void)v4;
      CFStringRef v4 = v3;
    }
    while (!v5);
  }
  if (*a1 == a2) {
    *a1 = v3;
  }
  BOOL v6 = a1[1];
  a1[2] = (uint64_t *)((char *)a1[2] - 1);
  std::__tree_remove[abi:ne180100]<std::__tree_node_base<void *> *>(v6, a2);
  return v3;
}

uint64_t *std::__tree_remove[abi:ne180100]<std::__tree_node_base<void *> *>(uint64_t *result, uint64_t *a2)
{
  uint64_t v2 = *a2;
  unint64_t v3 = a2;
  if (*a2)
  {
    CFStringRef v4 = (uint64_t *)a2[1];
    if (!v4)
    {
      unint64_t v3 = a2;
      goto LABEL_7;
    }
    do
    {
      unint64_t v3 = v4;
      CFStringRef v4 = (uint64_t *)*v4;
    }
    while (v4);
  }
  uint64_t v2 = v3[1];
  if (v2)
  {
LABEL_7:
    int v5 = 0;
    *(void *)(v2 + 16) = v3[2];
    goto LABEL_8;
  }
  int v5 = 1;
LABEL_8:
  BOOL v6 = (uint64_t **)v3[2];
  CFDictionaryRef v7 = *v6;
  if (*v6 == v3)
  {
    uint64_t *v6 = (uint64_t *)v2;
    if (v3 == result)
    {
      CFDictionaryRef v7 = 0;
      double result = (uint64_t *)v2;
    }
    else
    {
      CFDictionaryRef v7 = v6[1];
    }
  }
  else
  {
    v6[1] = (uint64_t *)v2;
  }
  int v8 = *((unsigned __int8 *)v3 + 24);
  if (v3 != a2)
  {
    uint64_t v9 = a2[2];
    void v3[2] = v9;
    *(void *)(v9 + 8 * (*(void *)a2[2] != (void)a2)) = v3;
    uint64_t v11 = *a2;
    uint64_t v10 = a2[1];
    *(void *)(v11 + 16) = v3;
    *unint64_t v3 = v11;
    v3[1] = v10;
    if (v10) {
      *(void *)(v10 + 16) = v3;
    }
    *((unsigned char *)v3 + 24) = *((unsigned char *)a2 + 24);
    if (result == a2) {
      double result = v3;
    }
  }
  if (!v8 || !result) {
    return result;
  }
  if (!v5)
  {
    *(unsigned char *)(v2 + 24) = 1;
    return result;
  }
  while (1)
  {
    uint64_t v12 = v7[2];
    if (*(uint64_t **)v12 == v7) {
      break;
    }
    if (!*((unsigned char *)v7 + 24))
    {
      *((unsigned char *)v7 + 24) = 1;
      *(unsigned char *)(v12 + 24) = 0;
      uint64_t v13 = *(uint64_t **)(v12 + 8);
      uint64_t v14 = *v13;
      *(void *)(v12 + 8) = *v13;
      if (v14) {
        *(void *)(v14 + 16) = v12;
      }
      v13[2] = *(void *)(v12 + 16);
      *(void *)(*(void *)(v12 + 16) + 8 * (**(void **)(v12 + 16) != v12)) = v13;
      uint64_t *v13 = v12;
      *(void *)(v12 + 16) = v13;
      if (result == (uint64_t *)*v7) {
        double result = v7;
      }
      CFDictionaryRef v7 = *(uint64_t **)(*v7 + 8);
    }
    uint64_t v15 = (void *)*v7;
    if (*v7 && !*((unsigned char *)v15 + 24))
    {
      int v16 = (uint64_t *)v7[1];
      if (!v16) {
        goto LABEL_56;
      }
LABEL_55:
      if (*((unsigned char *)v16 + 24))
      {
LABEL_56:
        *((unsigned char *)v15 + 24) = 1;
        *((unsigned char *)v7 + 24) = 0;
        uint64_t v22 = v15[1];
        *CFDictionaryRef v7 = v22;
        if (v22) {
          *(void *)(v22 + 16) = v7;
        }
        v15[2] = v7[2];
        *(void *)(v7[2] + 8 * (*(void *)v7[2] != (void)v7)) = v15;
        v15[1] = v7;
        v7[2] = (uint64_t)v15;
        int v16 = v7;
      }
      else
      {
        uint64_t v15 = v7;
      }
      uint64_t v23 = v15[2];
      *((unsigned char *)v15 + 24) = *(unsigned char *)(v23 + 24);
      *(unsigned char *)(v23 + 24) = 1;
      *((unsigned char *)v16 + 24) = 1;
      uint64_t v24 = *(uint64_t **)(v23 + 8);
      uint64_t v25 = *v24;
      *(void *)(v23 + 8) = *v24;
      if (v25) {
        *(void *)(v25 + 16) = v23;
      }
      unsigned int v24[2] = *(void *)(v23 + 16);
      *(void *)(*(void *)(v23 + 16) + 8 * (**(void **)(v23 + 16) != v23)) = v24;
      *uint64_t v24 = v23;
      goto LABEL_72;
    }
    int v16 = (uint64_t *)v7[1];
    if (v16 && !*((unsigned char *)v16 + 24)) {
      goto LABEL_55;
    }
    *((unsigned char *)v7 + 24) = 0;
    uint64_t v17 = (uint64_t *)v7[2];
    if (v17 == result)
    {
      uint64_t v17 = result;
LABEL_53:
      *((unsigned char *)v17 + 24) = 1;
      return result;
    }
    if (!*((unsigned char *)v17 + 24)) {
      goto LABEL_53;
    }
LABEL_49:
    CFDictionaryRef v7 = *(uint64_t **)(v17[2] + 8 * (*(void *)v17[2] == (void)v17));
  }
  if (!*((unsigned char *)v7 + 24))
  {
    *((unsigned char *)v7 + 24) = 1;
    *(unsigned char *)(v12 + 24) = 0;
    uint64_t v18 = v7[1];
    *(void *)uint64_t v12 = v18;
    if (v18) {
      *(void *)(v18 + 16) = v12;
    }
    v7[2] = *(void *)(v12 + 16);
    *(void *)(*(void *)(v12 + 16) + 8 * (**(void **)(v12 + 16) != v12)) = v7;
    v7[1] = v12;
    *(void *)(v12 + 16) = v7;
    if (result == (uint64_t *)v12) {
      double result = v7;
    }
    CFDictionaryRef v7 = *(uint64_t **)v12;
  }
  uint64_t v19 = (void *)*v7;
  if (*v7 && !*((unsigned char *)v19 + 24)) {
    goto LABEL_68;
  }
  int v20 = (uint64_t *)v7[1];
  if (!v20 || *((unsigned char *)v20 + 24))
  {
    *((unsigned char *)v7 + 24) = 0;
    uint64_t v17 = (uint64_t *)v7[2];
    if (*((unsigned char *)v17 + 24)) {
      BOOL v21 = v17 == result;
    }
    else {
      BOOL v21 = 1;
    }
    if (v21) {
      goto LABEL_53;
    }
    goto LABEL_49;
  }
  if (v19 && !*((unsigned char *)v19 + 24))
  {
LABEL_68:
    int v20 = v7;
  }
  else
  {
    *((unsigned char *)v20 + 24) = 1;
    *((unsigned char *)v7 + 24) = 0;
    uint64_t v26 = *v20;
    v7[1] = *v20;
    if (v26) {
      *(void *)(v26 + 16) = v7;
    }
    v20[2] = v7[2];
    *(void *)(v7[2] + 8 * (*(void *)v7[2] != (void)v7)) = v20;
    *int v20 = (uint64_t)v7;
    v7[2] = (uint64_t)v20;
    uint64_t v19 = v7;
  }
  uint64_t v23 = v20[2];
  *((unsigned char *)v20 + 24) = *(unsigned char *)(v23 + 24);
  *(unsigned char *)(v23 + 24) = 1;
  *((unsigned char *)v19 + 24) = 1;
  uint64_t v24 = *(uint64_t **)v23;
  uint64_t v27 = *(void *)(*(void *)v23 + 8);
  *(void *)uint64_t v23 = v27;
  if (v27) {
    *(void *)(v27 + 16) = v23;
  }
  unsigned int v24[2] = *(void *)(v23 + 16);
  *(void *)(*(void *)(v23 + 16) + 8 * (**(void **)(v23 + 16) != v23)) = v24;
  v24[1] = v23;
LABEL_72:
  *(void *)(v23 + 16) = v24;
  return result;
}

uint64_t IIOImageSource::forceUseServer(IIOImageSource *this)
{
  return *((char *)this + 53);
}

void IIOImageSource::~IIOImageSource(IIOImageSource *this)
{
  IIOImageSource::~IIOImageSource(this);

  JUMPOUT(0x18C11C0E0);
}

{
  uint64_t v2;
  IIOImageRead *Source;
  CFArrayRef v4;
  CFArrayRef v5;
  const void *v6;
  const void *v7;
  const void *v8;
  const void *v9;
  uint64_t v10;
  uint64_t v11;
  const void *v12;
  const void *v13;
  void *v14;
  void *v15;
  CFRange v16;

  *(void *)this = &unk_1ED4E1420;
  if (*((void *)this + 2))
  {
    IIOImageSource::unmapData(this);
    uint64_t v2 = *((void *)this + 2);
    if (v2 != *MEMORY[0x1E4F1D260])
    {
      uint64_t Source = (IIOImageRead *)CGImageSourceGetSource(v2);
      IIOImageRead::lock(Source);
      IIOImageRead::setISR(Source, 0);
      IIOImageRead::unlock(Source);
      CFRelease(*((CFTypeRef *)this + 2));
    }
    *((void *)this + 2) = 0;
  }
  CFStringRef v4 = (const __CFArray *)*((void *)this + 21);
  if (v4 && CFArrayGetCount(v4))
  {
    int v5 = (const __CFArray *)*((void *)this + 21);
    v16.length = CFArrayGetCount(v5);
    v16.location = 0;
    CFArrayApplyFunction(v5, v16, (CFArrayApplierFunction)releaseUnusedImageProvider, 0);
  }
  BOOL v6 = (const void *)*((void *)this + 23);
  if (v6)
  {
    CFRelease(v6);
    *((void *)this + 23) = 0;
  }
  CFDictionaryRef v7 = (const void *)*((void *)this + 24);
  if (v7)
  {
    CFRelease(v7);
    *((void *)this + 24) = 0;
  }
  int v8 = (const void *)*((void *)this + 21);
  if (v8)
  {
    CFRelease(v8);
    *((void *)this + 21) = 0;
  }
  uint64_t v9 = (const void *)*((void *)this + 7);
  if (v9)
  {
    CFRelease(v9);
    *((void *)this + 7) = 0;
  }
  uint64_t v10 = *((void *)this + 15);
  if (v10)
  {
    (*(void (**)(uint64_t))(*(void *)v10 + 8))(v10);
    *((void *)this + 15) = 0;
  }
  uint64_t v11 = *((void *)this + 16);
  if (v11)
  {
    (*(void (**)(uint64_t))(*(void *)v11 + 8))(v11);
    *((void *)this + 16) = 0;
  }
  uint64_t v12 = (const void *)*((void *)this + 17);
  if (v12)
  {
    CFRelease(v12);
    *((void *)this + 17) = 0;
  }
  uint64_t v13 = (const void *)*((void *)this + 22);
  if (v13)
  {
    CFRelease(v13);
    *((void *)this + 22) = 0;
  }
  pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 224));
  pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 288));
  uint64_t v14 = (void *)*((void *)this + 25);
  if (v14)
  {
    *((void *)this + 26) = v14;
    operator delete(v14);
  }
  uint64_t v15 = (void *)*((void *)this + 18);
  if (v15)
  {
    *((void *)this + 19) = v15;
    operator delete(v15);
  }
}

const char *IIOImageRead::unmapData(const char *this)
{
  uint64_t v1 = this;
  if ((gIIODebugFlags & 0x100000000000) != 0) {
    this = ImageIOLog("    %s: <IIOImageRead: %p> un-mmapping data <CFData:%p>  count: %d\n", "unmapData", this, *((const void **)this + 4), *((_DWORD *)this + 110));
  }
  if (*((void *)v1 + 4) && v1[67])
  {
    pthread_mutex_lock((pthread_mutex_t *)(v1 + 376));
    if (v1[67])
    {
      int v2 = *((_DWORD *)v1 + 110) - 1;
      *((_DWORD *)v1 + 110) = v2;
      if ((gIIODebugFlags & 0x100000000000) != 0)
      {
        CFIndex v3 = CFGetRetainCount(*((CFTypeRef *)v1 + 4));
        ImageIOLog("    %s:                  new count: %d   (rc=%ld)\n", "unmapData", v2, v3);
        int v2 = *((_DWORD *)v1 + 110);
      }
      if (v2 <= 0)
      {
        CFStringRef v4 = (const void *)*((void *)v1 + 4);
        if (v4)
        {
          uint64_t v5 = gIIODebugFlags;
          if ((gIIODebugFlags & 0x100000000000) != 0)
          {
            ImageIOLog("    %s:                  CFRelease: <CFData:%p>\n", "unmapData", v4);
            uint64_t v5 = gIIODebugFlags;
            CFStringRef v4 = (const void *)*((void *)v1 + 4);
          }
          if ((v5 & 0x80000000000) != 0)
          {
            ImageIOLog("D   %s:%d CFRelease %p\n", "unmapData", 994, v4);
            CFStringRef v4 = (const void *)*((void *)v1 + 4);
          }
          CFRelease(v4);
          *((void *)v1 + 4) = 0;
        }
      }
    }
    return (const char *)pthread_mutex_unlock((pthread_mutex_t *)(v1 + 376));
  }
  return this;
}

const char *IIOImageSource::unmapData(IIOImageSource *this)
{
  double result = (const char *)CGImageSourceGetSource(*((void *)this + 2));
  if (result)
  {
    return IIOImageRead::unmapData(result);
  }
  return result;
}

BOOL CGImageIIMDigestsMatchOrMissing(uint64_t a1)
{
  CFStringRef v2 = *(const __CFString **)(a1 + 56);
  CFStringRef v3 = *(const __CFString **)(a1 + 64);
  if (v2) {
    BOOL v4 = v3 == 0;
  }
  else {
    BOOL v4 = 1;
  }
  return v4 || CFStringCompare(v2, v3, 1uLL) == kCFCompareEqualTo;
}

void IIODictionaryAppendDictionary(__CFDictionary *a1, const __CFDictionary *a2, BOOL a3)
{
  if (a1 && a2)
  {
    if ((IIODictionaryIsMutable() & 1) == 0) {
      _cg_jpeg_mem_term("IIODictionaryAppendDictionary", 1436, "*** ERROR:  IIODictionaryAppendDictionary called with immutable dictionary!  [%p]\n", a1);
    }
    CFIndex Count = CFDictionaryGetCount(a2);
    CFDictionaryRef v7 = (const void **)malloc_type_malloc(8 * Count, 0x80040B8603338uLL);
    if (v7)
    {
      int v8 = v7;
      uint64_t v9 = (const void **)malloc_type_malloc(8 * Count, 0x80040B8603338uLL);
      if (v9)
      {
        uint64_t v10 = v9;
        CFDictionaryGetKeysAndValues(a2, v8, v9);
        if (Count >= 1)
        {
          CFAllocatorRef v11 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
          uint64_t v12 = v10;
          uint64_t v13 = v8;
          do
          {
            if (a3 || !CFDictionaryContainsKey(a1, *v13))
            {
              CFTypeID v14 = CFGetTypeID(*v12);
              CFTypeID TypeID = CFDictionaryGetTypeID();
              int v16 = *v13;
              if (v14 == TypeID)
              {
                CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(a1, v16);
                if (Value)
                {
                  CFDictionaryRef v18 = Value;
                  CFTypeID v19 = CFGetTypeID(Value);
                  if (v19 == CFDictionaryGetTypeID())
                  {
                    MutableCopy = CFDictionaryCreateMutableCopy(v11, 0, v18);
                    if (!MutableCopy) {
                      break;
                    }
                    BOOL v21 = MutableCopy;
                    IIODictionaryAppendDictionary(MutableCopy, (const __CFDictionary *)*v12, a3);
                    CFDictionarySetValue(a1, *v13, v21);
                    CFRelease(v21);
                    goto LABEL_18;
                  }
                }
                int v16 = *v13;
              }
              CFDictionarySetValue(a1, v16, *v12);
            }
LABEL_18:
            ++v13;
            ++v12;
            --Count;
          }
          while (Count);
        }
        free(v8);
      }
      else
      {
        uint64_t v10 = v8;
      }
      free(v10);
    }
  }
}

uint64_t IIODictionaryIsMutable()
{
  v0 = (objc_class *)objc_opt_class();
  uint64_t v1 = NSStringFromClass(v0);
  if ([(NSString *)v1 isEqualToString:@"__NSDictionaryI"]) {
    return 0;
  }
  if (![(NSString *)v1 isEqualToString:@"__NSDictionaryM"])
  {
    objc_opt_class();
    objc_opt_class();
    if ((objc_opt_isKindOfClass() & 1) == 0)
    {
      objc_opt_class();
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) == 0) {
        abort();
      }
      return 0;
    }
  }
  return 1;
}

void IIODictionary::appendDictionary(IIODictionary *this, const __CFDictionary *a2)
{
  CFStringRef v2 = (__CFDictionary *)*((void *)this + 1);
  if (v2) {
    IIODictionaryAppendDictionary(v2, a2, 1);
  }
}

uint64_t appendNode(uint64_t result, uint64_t a2)
{
  do
  {
    uint64_t v2 = result;
    double result = *(void *)(result + 40);
  }
  while (result);
  *(void *)(v2 + 40) = a2;
  return result;
}

void VerifyQualName(char *a1, char *a2)
{
  if (a1 >= a2)
  {
    exception = __cxa_allocate_exception(0x18uLL);
    *(_DWORD *)exception = 102;
    BOOL v6 = "Empty qualified name";
LABEL_6:
    exception[1] = v6;
    *((unsigned char *)exception + 16) = 0;
  }
  uint64_t v4 = 0;
  while (a1[v4] != 58)
  {
    if (a2 - a1 == ++v4) {
      goto LABEL_5;
    }
  }
  if (!v4)
  {
LABEL_5:
    exception = __cxa_allocate_exception(0x18uLL);
    *(_DWORD *)exception = 102;
    BOOL v6 = "Ill-formed qualified name";
    goto LABEL_6;
  }
  VerifySimpleXMLName(a1, &a1[v4]);
  size_t v7 = v4 + 1;
  VerifySimpleXMLName(&a1[v7], a2);
  __p[0] = 0;
  __p[1] = 0;
  uint64_t v11 = 0;
  std::string::basic_string[abi:ne180100](__p, a1, v7);
  if (v11 >= 0) {
    int v8 = (char *)__p;
  }
  else {
    int v8 = (char *)__p[0];
  }
  if (!XMP_NamespaceTable::GetURI((XMP_NamespaceTable *)sRegisteredNamespaces, v8, 0, 0))
  {
    uint64_t v9 = __cxa_allocate_exception(0x18uLL);
    *(_DWORD *)uint64_t v9 = 102;
    v9[1] = "Unknown namespace prefix for qualified name";
    *((unsigned char *)v9 + 16) = 0;
  }
  if (SHIBYTE(v11) < 0) {
    operator delete(__p[0]);
  }
}

void sub_1885A1018(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void XMPFiles::Terminate(XMPFiles *this)
{
  if (!--sXMPFilesInitCount)
  {
    uint64_t v1 = Common::HandlerRegistry::terminate(this);
    uint64_t v2 = (ID3_Support *)TXMPMeta<std::string>::Terminate(v1);
    CFStringRef v3 = (ISOMedia *)ID3_Support::TerminateGlobals(v2);
    ISOMedia::TerminateGlobals(v3);
    _cg_jpeg_mem_term(v4, v5, v6);
    if (_MergedGlobals != -1) {
      dispatch_once(&_MergedGlobals, &__block_literal_global_42);
    }
    uint64_t v7 = qword_1EB2C0378;
    *(void *)(qword_1EB2C0378 + 32) = 0;
    *(void *)(v7 + 40) = 0;
    *(void *)(v7 + 24) = 0;
    *(void *)(v7 + 8) = 1;
    *(unsigned char *)(v7 + 16) = 0;
    if (sProgressDefault(void)::onceToken != -1) {
      dispatch_once(&sProgressDefault(void)::onceToken, &__block_literal_global_24);
    }
    uint64_t v8 = gProgressDefault;
    *(void *)(gProgressDefault + 8) = 0;
    *(void *)(v8 + 16) = 0;
    *(void *)uint64_t v8 = 0;
    *(_DWORD *)(v8 + 24) = 1065353216;
    *(unsigned char *)(v8 + 28) = 0;
  }
}

double WXMPMeta_Terminate_1(XMPMeta *a1)
{
  {
    if (a1) {
  }
    }
  return XMPMeta::Terminate(a1);
}

void sub_1885A11D8(void *a1)
{
  __cxa_begin_catch(a1);
  __cxa_end_catch();
}

void XMPMeta::XMPMeta(XMPMeta *this)
{
  *(void *)this = &unk_1ED4E5A58;
  *((_DWORD *)this + 2) = 0;
  XMP_ReadWriteLock::XMP_ReadWriteLock((XMPMeta *)((char *)this + 16));
  XMP_Node::XMP_Node((XMPMeta *)((char *)this + 224), 0, "", 0);
  *((void *)this + 45) = 1;
  *((unsigned char *)this + 368) = 0;
  *((void *)this + 43) = 0;
  *((void *)this + 44) = &unk_1ED4EF070;
  *((void *)this + 48) = 0;
  *((void *)this + 49) = 0;
  *((void *)this + 47) = 0;
  if (sDefaultErrorCallback(void)::onceToken != -1) {
    dispatch_once(&sDefaultErrorCallback(void)::onceToken, &__block_literal_global_46);
  }
  if (*(void *)(gDefaultErrorCallback + 32))
  {
    *((void *)this + 47) = *(void *)(gDefaultErrorCallback + 24);
    *((void *)this + 48) = *(void *)(gDefaultErrorCallback + 32);
    *((void *)this + 49) = *(void *)(gDefaultErrorCallback + 40);
    *((_DWORD *)this + 90) = *(_DWORD *)(gDefaultErrorCallback + 8);
  }
}

void sub_1885A12FC(_Unwind_Exception *a1)
{
  XMP_ReadWriteLock::~XMP_ReadWriteLock(v1);
  _Unwind_Resume(a1);
}

double XMPMeta::Terminate(XMPMeta *this)
{
  if (!--sXMP_InitCount)
  {
    uint64_t v1 = (XMPIterator *)kdebug_trace();
    uint64_t v2 = (XMPUtils *)XMPIterator::Terminate(v1);
    CFStringRef v3 = (AdobeXMPCore_Int::INameSpacePrefixMap_I *)XMPUtils::Terminate(v2);
    AdobeXMPCore_Int::INameSpacePrefixMap_I::DestroyDefaultNameSapcePrefixMap(v3);
    AdobeXMPCore_Int::IDOMImplementationRegistry_I::DestoryDOMImplementationRegistry(v4);
    BOOL v6 = (AdobeXMPCore_Int::ICoreConfigurationManager_I *)AdobeXMPCore::ICoreObjectFactory_v1::DestroyCoreObjectFactory(v5);
    AdobeXMPCore_Int::ICoreConfigurationManager_I::DestroyCoreConfigurationManager(v6);
    AdobeXMPCore_Int::InitializeXMPCommonFramework(v7);
    if (sDefaultNamespacePrefixMapLock)
    {
      XMP_ReadWriteLock::~XMP_ReadWriteLock((XMP_ReadWriteLock *)sDefaultNamespacePrefixMapLock);
      MEMORY[0x18C11C0E0]();
    }
    sDefaultNamespacePrefixMapLock = 0;
    sUseNewCoreAPIs = 0;
    uint64_t v10 = sRegisteredNamespaces;
    if (sRegisteredNamespaces) {
      uint64_t v10 = (*(uint64_t (**)(uint64_t))(*(void *)sRegisteredNamespaces + 8))(sRegisteredNamespaces);
    }
    sRegisteredNamespaces = 0;
    uint64_t v11 = sRegisteredAliasMap;
    if (sRegisteredAliasMap)
    {
      std::__tree<std::__value_type<std::string,std::vector<XPathStepInfo>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<XPathStepInfo>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<XPathStepInfo>>>>::destroy(sRegisteredAliasMap, *(void **)(sRegisteredAliasMap + 8));
      uint64_t v10 = MEMORY[0x18C11C0E0](v11, 0x1020C4062D53EE8);
    }
    sRegisteredAliasMap = 0;
    uint64_t v12 = xdefaultName;
    if (xdefaultName)
    {
      if (*(char *)(xdefaultName + 23) < 0) {
        operator delete(*(void **)xdefaultName);
      }
      uint64_t v10 = MEMORY[0x18C11C0E0](v12, 0x1012C40EC159624);
    }
    xdefaultName = 0;
    _cg_jpeg_mem_term(v10, v8, v9);
    if (sDefaultErrorCallback(void)::onceToken != -1) {
      dispatch_once(&sDefaultErrorCallback(void)::onceToken, &__block_literal_global_46);
    }
    uint64_t v13 = gDefaultErrorCallback;
    *(void *)(gDefaultErrorCallback + 32) = 0;
    *(void *)(v13 + 40) = 0;
    *(void *)(v13 + 24) = 0;
    *(void *)&double result = 1;
    *(void *)(v13 + 8) = 1;
    *(unsigned char *)(v13 + 16) = 0;
  }
  return result;
}

void std::__tree<std::__value_type<std::string,std::vector<XPathStepInfo>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<XPathStepInfo>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<XPathStepInfo>>>>::destroy(uint64_t a1, void *a2)
{
  if (a2)
  {
    std::__tree<std::__value_type<std::string,std::vector<XPathStepInfo>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<XPathStepInfo>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<XPathStepInfo>>>>::destroy(a1, *a2);
    std::__tree<std::__value_type<std::string,std::vector<XPathStepInfo>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<XPathStepInfo>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<XPathStepInfo>>>>::destroy(a1, a2[1]);
    std::__destroy_at[abi:ne180100]<std::pair<std::string const,std::vector<XPathStepInfo>>,0>((uint64_t)(a2 + 4));
    operator delete(a2);
  }
}

void std::__destroy_at[abi:ne180100]<std::pair<std::string const,std::vector<XPathStepInfo>>,0>(uint64_t a1)
{
  uint64_t v2 = (void **)(a1 + 24);
  std::vector<XPathStepInfo>::__destroy_vector::operator()[abi:ne180100](&v2);
  if (*(char *)(a1 + 23) < 0) {
    operator delete(*(void **)a1);
  }
}

uint64_t XMPMeta::Initialize(XMPMeta *this)
{
  int v1 = sXMP_InitCount++;
  if (v1 > 0) {
    return 1;
  }
  kdebug_trace();
  uint64_t result = ImageIOShouldAllowFullsizeDecode();
  if (result)
  {
    CFStringRef v3 = (AdobeXMPCore_Int::INameSpacePrefixMap_I *)AdobeXMPCore_Int::InitializeXMPCommonFramework((AdobeXMPCore_Int *)result);
    AdobeXMPCore_Int::INameSpacePrefixMap_I::CreateDefaultNameSpacePrefixMap(v3);
    operator new();
  }
  return result;
}

BOOL XMPMeta::RegisterNamespace(XMPMeta *this, char *a2, const char **a3, const char **a4, unsigned int *a5)
{
  BOOL v6 = XMP_NamespaceTable::Define((XMP_NamespaceTable *)sRegisteredNamespaces, (char *)this, a2, a3, (unsigned int *)a4);
  __src = 0;
  unsigned int v14 = 0;
  XMP_NamespaceTable::GetPrefix((XMP_NamespaceTable *)sRegisteredNamespaces, (char *)this, (const char **)&__src, &v14);
  __p = 0;
  uint64_t v12 = 0;
  uint64_t v13 = 0;
  std::string::basic_string[abi:ne180100](&__p, __src, v14 - 1);
  uint64_t v10 = (XMP_ReadWriteLock *)sDefaultNamespacePrefixMapLock;
  XMP_ReadWriteLock::Acquire((pthread_rwlock_t *)sDefaultNamespacePrefixMapLock, 1);
  if (v13 >= 0) {
    p_p = (AdobeXMPCore_Int::INameSpacePrefixMap_I *)&__p;
  }
  else {
    p_p = (AdobeXMPCore_Int::INameSpacePrefixMap_I *)__p;
  }
  if (v13 >= 0) {
    uint64_t v8 = (const char *)HIBYTE(v13);
  }
  else {
    uint64_t v8 = v12;
  }
  AdobeXMPCore_Int::INameSpacePrefixMap_I::InsertInDefaultNameSpacePrefixMap(p_p, v8, (uint64_t)this, (const char *)0xFFFFFFFFFFFFFFFFLL);
  XMP_AutoLock::~XMP_AutoLock(&v10);
  if (SHIBYTE(v13) < 0) {
    operator delete(__p);
  }
  return v6;
}

void sub_1885A232C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void *std::string::basic_string[abi:ne180100](void *__dst, void *__src, size_t __len)
{
  if (__len >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  if (__len >= 0x17)
  {
    size_t v7 = (__len & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((__len | 7) != 0x17) {
      size_t v7 = __len | 7;
    }
    size_t v8 = v7 + 1;
    BOOL v6 = operator new(v7 + 1);
    __dst[1] = __len;
    __dst[2] = v8 | 0x8000000000000000;
    *__dst = v6;
  }
  else
  {
    *((unsigned char *)__dst + 23) = __len;
    BOOL v6 = __dst;
    if (!__len) {
      goto LABEL_9;
    }
  }
  memmove(v6, __src, __len);
LABEL_9:
  *((unsigned char *)v6 + __len) = 0;
  return __dst;
}

uint64_t AdobeXMPCore_Int::INameSpacePrefixMap_I::InsertInDefaultNameSpacePrefixMap(AdobeXMPCore_Int::INameSpacePrefixMap_I *this, const char *a2, uint64_t a3, const char *a4)
{
  AdobeXMPCore_Int::ManageDefaultNameSpacePrefixMap(0, &v10);
  uint64_t v8 = (*(uint64_t (**)(uint64_t, AdobeXMPCore_Int::INameSpacePrefixMap_I *, const char *, uint64_t, const char *))(*(void *)v10 + 40))(v10, this, a2, a3, a4);
  if (v11) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v11);
  }
  return v8;
}

void sub_1885A2498(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a10);
  }
  _Unwind_Resume(exception_object);
}

void AdobeXMPCore_Int::ManageDefaultNameSpacePrefixMap(AdobeXMPCore_Int *this@<X0>, void *a2@<X8>)
{
  uint64_t v3 = AdobeXMPCore_Int::ManageDefaultNameSpacePrefixMap(BOOL)::sDefaultNameSpacePrefixMap;
  if (this)
  {
    uint64_t v4 = *(std::__shared_weak_count **)(AdobeXMPCore_Int::ManageDefaultNameSpacePrefixMap(BOOL)::sDefaultNameSpacePrefixMap
                                      + 8);
    *(void *)AdobeXMPCore_Int::ManageDefaultNameSpacePrefixMap(BOOL)::sDefaultNameSpacePrefixMap = 0;
    *(void *)(v3 + 8) = 0;
    if (!v4
      || (std::__shared_weak_count::__release_shared[abi:ne180100](v4),
          (uint64_t v3 = AdobeXMPCore_Int::ManageDefaultNameSpacePrefixMap(BOOL)::sDefaultNameSpacePrefixMap) != 0))
    {
      uint64_t v5 = *(std::__shared_weak_count **)(v3 + 8);
      if (v5) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v5);
      }
      MEMORY[0x18C11C0E0](v3, 0x20C40A4A59CD2);
    }
    AdobeXMPCore_Int::ManageDefaultNameSpacePrefixMap(BOOL)::sDefaultNameSpacePrefixMap = 0;
    *a2 = 0;
    a2[1] = 0;
  }
  else
  {
    if (!AdobeXMPCore_Int::ManageDefaultNameSpacePrefixMap(BOOL)::sDefaultNameSpacePrefixMap) {
      AdobeXMPCore::INameSpacePrefixMap_v1::CreateNameSpacePrefixMap(this);
    }
    uint64_t v6 = *(void *)(AdobeXMPCore_Int::ManageDefaultNameSpacePrefixMap(BOOL)::sDefaultNameSpacePrefixMap + 8);
    *a2 = *(void *)AdobeXMPCore_Int::ManageDefaultNameSpacePrefixMap(BOOL)::sDefaultNameSpacePrefixMap;
    a2[1] = v6;
    if (v6) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v6 + 8), 1uLL, memory_order_relaxed);
    }
  }
}

void sub_1885A25C8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t virtual thunk to'AdobeXMPCore_Int::NameSpacePrefixMapImpl::Insert(AdobeXMPCore_Int::NameSpacePrefixMapImpl *this, char *a2, const char *a3, const char *a4, uint64_t a5)
{
  return AdobeXMPCore_Int::NameSpacePrefixMapImpl::Insert((AdobeXMPCore_Int::NameSpacePrefixMapImpl *)((char *)this + *(void *)(*(void *)this - 80)), a2, a3, a4, a5);
}

void RegisterAlias(char *a1, char *a2, char *a3, char *a4, unsigned int a5)
{
  uint64_t v83 = 0;
  uint64_t v84 = 0;
  uint64_t v85 = 0;
  __str = 0;
  unsigned int v81 = 0;
  unint64_t v82 = 0;
  if (!a1 || !a2 || !a3 || !a4) {
    __assert_rtn("RegisterAlias", "XMPMeta.cpp", 546, "(aliasNS != 0) && (aliasProp != 0) && (actualNS != 0) && (actualProp != 0)");
  }
  ExpandXPath(a1, a2, &v83);
  ExpandXPath(a3, a4, (uint64_t *)&__str);
  if (v84 - v83 != 64 || v81 - (char *)__str != 64)
  {
    exception = __cxa_allocate_exception(0x18uLL);
    *(_DWORD *)exception = 102;
    int v74 = "Alias and actual property names must be simple";
    goto LABEL_129;
  }
  int v8 = VerifySetOptions(a5, 0);
  int v9 = v8;
  if (v8)
  {
    if ((v8 & 0xFFFFE1FF) != 0)
    {
      exception = __cxa_allocate_exception(0x18uLL);
      *(_DWORD *)exception = 103;
      int v74 = "Only array form flags are allowed";
      goto LABEL_129;
    }
    LODWORD(__str[2].__r_.__value_.__r.__words[1]) |= v8;
    if ((v8 & 0x1000) != 0)
    {
      std::string::basic_string[abi:ne180100]<0>(__p, "[?xml:lang=\"x-default\"]");
      int v79 = 5;
      uint64_t v10 = v81;
      if ((unint64_t)v81 >= v82)
      {
        int64_t v11 = (v81 - (char *)__str) >> 5;
        unint64_t v16 = v11 + 1;
        if ((unint64_t)(v11 + 1) >> 59) {
          std::vector<IIOTag *>::__throw_length_error[abi:ne180100]();
        }
        uint64_t v17 = v82 - (void)__str;
        if ((uint64_t)(v82 - (void)__str) >> 4 > v16) {
          unint64_t v16 = v17 >> 4;
        }
        if ((unint64_t)v17 >= 0x7FFFFFFFFFFFFFE0) {
          unint64_t v14 = 0x7FFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v14 = v16;
        }
        goto LABEL_25;
      }
    }
    else
    {
      std::string::basic_string[abi:ne180100]<0>(__p, "[1]");
      int v79 = 3;
      uint64_t v10 = v81;
      if ((unint64_t)v81 >= v82)
      {
        int64_t v11 = (v81 - (char *)__str) >> 5;
        unint64_t v12 = v11 + 1;
        if ((unint64_t)(v11 + 1) >> 59) {
          std::vector<IIOTag *>::__throw_length_error[abi:ne180100]();
        }
        uint64_t v13 = v82 - (void)__str;
        if ((uint64_t)(v82 - (void)__str) >> 4 > v12) {
          unint64_t v12 = v13 >> 4;
        }
        if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFE0) {
          unint64_t v14 = 0x7FFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v14 = v12;
        }
LABEL_25:
        v76[1] = &v82;
        CFDictionaryRef v18 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<XPathStepInfo>>((uint64_t)&v82, v14);
        std::string::size_type v19 = (std::string::size_type)&v18[32 * v11];
        v75.__r_.__value_.__r.__words[0] = (std::string::size_type)v18;
        v75.__r_.__value_.__l.__size_ = v19;
        v76[0] = &v18[32 * v20];
        long long v21 = *(_OWORD *)__p;
        *(void *)(v19 + 16) = v78;
        *(_OWORD *)std::string::size_type v19 = v21;
        __p[1] = 0;
        uint64_t v78 = 0;
        __p[0] = 0;
        *(_DWORD *)(v19 + 24) = v79;
        v75.__r_.__value_.__r.__words[2] = v19 + 32;
        std::vector<XPathStepInfo>::__swap_out_circular_buffer((uint64_t *)&__str, &v75);
        uint64_t v22 = (long long *)v81;
        std::__split_buffer<XPathStepInfo>::~__split_buffer((uint64_t)&v75);
        unsigned int v81 = (char *)v22;
        if (SHIBYTE(v78) < 0) {
          operator delete(__p[0]);
        }
        goto LABEL_27;
      }
    }
    long long v15 = *(_OWORD *)__p;
    *((void *)v10 + 2) = v78;
    *(_OWORD *)uint64_t v10 = v15;
    __p[1] = 0;
    uint64_t v78 = 0;
    __p[0] = 0;
    *((_DWORD *)v10 + 6) = v79;
    unsigned int v81 = v10 + 32;
  }
LABEL_27:
  uint64_t v23 = std::__tree<std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>>>::find<std::string>(sRegisteredAliasMap, (const void **)(v83 + 32));
  if (sRegisteredAliasMap + 8 == v23)
  {
    uint64_t v33 = std::__tree<std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>>>::find<std::string>(sRegisteredAliasMap, (const void **)&__str[1].__r_.__value_.__l.__size_);
    if (sRegisteredAliasMap + 8 != v33)
    {
      int v34 = (std::string **)(v33 + 56);
      if (v81 - (char *)__str == 64)
      {
        if (&__str != v34) {
          std::vector<XPathStepInfo>::__assign_with_size[abi:ne180100]<XPathStepInfo*,XPathStepInfo*>((uint64_t)&__str, *(std::string **)(v33 + 56), *(long long **)(v33 + 64), (uint64_t)(*(void *)(v33 + 64) - *(void *)(v33 + 56)) >> 5);
        }
      }
      else
      {
        uint64_t v44 = *(const std::string **)(v33 + 56);
        if (*(void *)(v33 + 64) - (void)v44 != 64)
        {
LABEL_124:
          exception = __cxa_allocate_exception(0x18uLL);
          *(_DWORD *)exception = 4;
          int v74 = "Can't alias an array item to an array item";
          goto LABEL_129;
        }
        std::string::operator=(__str, v44);
        std::string::operator=((std::string *)((char *)__str + 32), (std::string *)((char *)*v34 + 32));
      }
    }
    uint64_t v45 = (uint64_t **)sRegisteredAliasMap;
    uint64_t v46 = sRegisteredAliasMap + 8;
    size_t v47 = *(void **)sRegisteredAliasMap;
    if (*(void *)sRegisteredAliasMap == sRegisteredAliasMap + 8)
    {
LABEL_117:
      std::pair<std::string const,std::vector<XPathStepInfo>>::pair[abi:ne180100]<std::string&,std::vector<XPathStepInfo>&,0>(&v75, (long long *)(v83 + 32), (long long **)&__str);
      std::__tree<std::__value_type<std::string,std::vector<XPathStepInfo>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<XPathStepInfo>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<XPathStepInfo>>>>::__emplace_unique_key_args<std::string,std::pair<std::string const,std::vector<XPathStepInfo>>>(v45, (const void **)&v75.__r_.__value_.__l.__data_, (long long *)&v75);
      __p[0] = v76;
      std::vector<XPathStepInfo>::__destroy_vector::operator()[abi:ne180100]((void ***)__p);
      if (SHIBYTE(v75.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v75.__r_.__value_.__l.__data_);
      }
      goto LABEL_120;
    }
    int v48 = (const void **)(v83 + 32);
    uint64_t v49 = *(unsigned __int8 *)(v83 + 55);
    size_t v50 = *(void *)(v83 + 40);
    if ((v49 & 0x80u) == 0) {
      uint64_t v51 = *(unsigned __int8 *)(v83 + 55);
    }
    else {
      uint64_t v51 = *(void *)(v83 + 40);
    }
    uint64_t v52 = v84 - v83;
    uint64_t v53 = *(void **)sRegisteredAliasMap;
    while (1)
    {
      uint64_t v54 = v53[7];
      uint64_t v55 = *(unsigned __int8 *)(v54 + 55);
      int v56 = (char)v55;
      if ((v55 & 0x80u) != 0) {
        uint64_t v55 = *(void *)(v54 + 40);
      }
      if (v51 == v55)
      {
        if (v56 >= 0) {
          uint64_t v57 = (unsigned __int8 *)(v54 + 32);
        }
        else {
          uint64_t v57 = *(unsigned __int8 **)(v54 + 32);
        }
        if ((v49 & 0x80) != 0)
        {
          if (!memcmp(*v48, v57, v50))
          {
LABEL_84:
            if (v53[8] - v54 == 64 && v52 == 64) {
              goto LABEL_124;
            }
          }
        }
        else
        {
          if (!v49) {
            goto LABEL_84;
          }
          uint64_t v58 = v48;
          uint64_t v59 = v49;
          while (*(unsigned __int8 *)v58 == *v57)
          {
            uint64_t v58 = (const void **)((char *)v58 + 1);
            ++v57;
            if (!--v59) {
              goto LABEL_84;
            }
          }
        }
      }
      uint64_t v60 = (void *)v53[1];
      if (v60)
      {
        do
        {
          uint64_t v61 = v60;
          uint64_t v60 = (void *)*v60;
        }
        while (v60);
      }
      else
      {
        do
        {
          uint64_t v61 = (void *)v53[2];
          BOOL v62 = *v61 == (void)v53;
          uint64_t v53 = v61;
        }
        while (!v62);
      }
      uint64_t v53 = v61;
      if (v61 == (void *)v46)
      {
        while (1)
        {
          uint64_t v63 = (std::string **)(v47 + 7);
          int v64 = (std::string *)v47[7];
          uint64_t v65 = *(unsigned __int8 *)(v83 + 55);
          if ((v65 & 0x80u) == 0) {
            uint64_t v66 = *(unsigned __int8 *)(v83 + 55);
          }
          else {
            uint64_t v66 = *(void *)(v83 + 40);
          }
          std::string::size_type v67 = v64[2].__r_.__value_.__s.__data_[7];
          int v68 = (char)v67;
          if ((v67 & 0x80u) != 0) {
            std::string::size_type v67 = v64[1].__r_.__value_.__r.__words[2];
          }
          if (v66 != v67) {
            goto LABEL_111;
          }
          int v69 = (const void **)(v83 + 32);
          unsigned __int8 v70 = v68 >= 0
              ? &v64[1].__r_.__value_.__r.__words[1]
              : (std::string::size_type *)v64[1].__r_.__value_.__l.__size_;
          if ((v65 & 0x80) == 0) {
            break;
          }
          if (!memcmp(*v69, v70, *(void *)(v83 + 40))) {
            goto LABEL_107;
          }
LABEL_111:
          int v71 = (void *)v47[1];
          if (v71)
          {
            do
            {
              int v72 = v71;
              int v71 = (void *)*v71;
            }
            while (v71);
          }
          else
          {
            do
            {
              int v72 = (void *)v47[2];
              BOOL v62 = *v72 == (void)v47;
              size_t v47 = v72;
            }
            while (!v62);
          }
          uint64_t v45 = (uint64_t **)sRegisteredAliasMap;
          size_t v47 = v72;
          if (v72 == (void *)(sRegisteredAliasMap + 8)) {
            goto LABEL_117;
          }
        }
        if (*(unsigned char *)(v83 + 55))
        {
          while (*(unsigned __int8 *)v69 == *(unsigned __int8 *)v70)
          {
            int v69 = (const void **)((char *)v69 + 1);
            unsigned __int8 v70 = (std::string::size_type *)((char *)v70 + 1);
            if (!--v65) {
              goto LABEL_107;
            }
          }
          goto LABEL_111;
        }
LABEL_107:
        if (v47[8] - (void)v64 == 32)
        {
          if (v63 != &__str) {
            std::vector<XPathStepInfo>::__assign_with_size[abi:ne180100]<XPathStepInfo*,XPathStepInfo*>((uint64_t)(v47 + 7), __str, (long long *)v81, (v81 - (char *)__str) >> 5);
          }
        }
        else
        {
          std::string::operator=(v64, __str);
          std::string::operator=((std::string *)((char *)*v63 + 32), (std::string *)((char *)__str + 32));
        }
        goto LABEL_111;
      }
    }
  }
  uint64_t v24 = *(void *)(v23 + 56);
  if (v9 != (*(_DWORD *)(v24 + 56) & 0x1E00))
  {
    exception = __cxa_allocate_exception(0x18uLL);
    *(_DWORD *)exception = 4;
    int v74 = "Mismatch with existing alias array form";
    goto LABEL_129;
  }
  uint64_t v25 = __str;
  int64_t v26 = v81 - (char *)__str;
  if (v81 - (char *)__str != *(void *)(v23 + 64) - v24)
  {
    exception = __cxa_allocate_exception(0x18uLL);
    *(_DWORD *)exception = 4;
    int v74 = "Mismatch with existing actual path";
LABEL_129:
    exception[1] = v74;
    *((unsigned char *)exception + 16) = 0;
  }
  uint64_t v27 = __str[2].__r_.__value_.__s.__data_[7];
  if ((v27 & 0x80u) == 0) {
    std::string::size_type v28 = __str[2].__r_.__value_.__s.__data_[7];
  }
  else {
    std::string::size_type v28 = __str[1].__r_.__value_.__r.__words[2];
  }
  uint64_t v29 = *(unsigned __int8 *)(v24 + 55);
  int v30 = (char)v29;
  if ((v29 & 0x80u) != 0) {
    uint64_t v29 = *(void *)(v24 + 40);
  }
  if (v28 != v29) {
    goto LABEL_122;
  }
  p_std::string::size_type size = (const void **)&__str[1].__r_.__value_.__l.__size_;
  if (v30 >= 0) {
    uint64_t v32 = (unsigned __int8 *)(v24 + 32);
  }
  else {
    uint64_t v32 = *(unsigned __int8 **)(v24 + 32);
  }
  if ((v27 & 0x80) != 0)
  {
    if (!memcmp(*p_size, v32, __str[1].__r_.__value_.__r.__words[2])) {
      goto LABEL_49;
    }
LABEL_122:
    exception = __cxa_allocate_exception(0x18uLL);
    *(_DWORD *)exception = 4;
    int v74 = "Mismatch with existing actual name";
    goto LABEL_129;
  }
  if (__str[2].__r_.__value_.__s.__data_[7])
  {
    while (*(unsigned __int8 *)p_size == *v32)
    {
      p_std::string::size_type size = (const void **)((char *)p_size + 1);
      ++v32;
      if (!--v27) {
        goto LABEL_49;
      }
    }
    goto LABEL_122;
  }
LABEL_49:
  if (v26 != 96) {
    goto LABEL_120;
  }
  uint64_t v35 = v25[3].__r_.__value_.__s.__data_[15];
  if ((v35 & 0x80u) == 0) {
    std::string::pointer data = (std::string::pointer)v25[3].__r_.__value_.__s.__data_[15];
  }
  else {
    std::string::pointer data = v25[3].__r_.__value_.__l.__data_;
  }
  size_t v37 = (char *)*(unsigned __int8 *)(v24 + 87);
  int v38 = (char)v37;
  if ((char)v37 < 0) {
    size_t v37 = *(char **)(v24 + 72);
  }
  if (data != v37)
  {
LABEL_123:
    exception = __cxa_allocate_exception(0x18uLL);
    *(_DWORD *)exception = 4;
    int v74 = "Mismatch with existing actual array item";
    goto LABEL_129;
  }
  int v39 = (const void **)&v25[2].__r_.__value_.__r.__words[2];
  int v42 = *(unsigned __int8 **)(v24 + 64);
  int v41 = (unsigned __int8 *)(v24 + 64);
  unint64_t v40 = v42;
  if (v38 >= 0) {
    CFTypeID v43 = v41;
  }
  else {
    CFTypeID v43 = v40;
  }
  if ((v35 & 0x80) != 0)
  {
    if (!memcmp(*v39, v43, v25[3].__r_.__value_.__r.__words[0])) {
      goto LABEL_120;
    }
    goto LABEL_123;
  }
  if (v25[3].__r_.__value_.__s.__data_[15])
  {
    while (*(unsigned __int8 *)v39 == *v43)
    {
      int v39 = (const void **)((char *)v39 + 1);
      ++v43;
      if (!--v35) {
        goto LABEL_120;
      }
    }
    goto LABEL_123;
  }
LABEL_120:
  v75.__r_.__value_.__r.__words[0] = (std::string::size_type)&__str;
  std::vector<XPathStepInfo>::__destroy_vector::operator()[abi:ne180100]((void ***)&v75);
  v75.__r_.__value_.__r.__words[0] = (std::string::size_type)&v83;
  std::vector<XPathStepInfo>::__destroy_vector::operator()[abi:ne180100]((void ***)&v75);
}

void sub_1885A2DF4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,char a22,uint64_t a23,uint64_t a24,char a25)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  __p = &a22;
  std::vector<XPathStepInfo>::__destroy_vector::operator()[abi:ne180100]((void ***)&__p);
  __p = &a25;
  std::vector<XPathStepInfo>::__destroy_vector::operator()[abi:ne180100]((void ***)&__p);
  _Unwind_Resume(a1);
}

void std::vector<XPathStepInfo>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  uint64_t v2 = *a1;
  if (*v2)
  {
    std::vector<XPathStepInfo>::__clear[abi:ne180100]((uint64_t *)v2);
    uint64_t v3 = **a1;
    operator delete(v3);
  }
}

void std::vector<XPathStepInfo>::__clear[abi:ne180100](uint64_t *a1)
{
  uint64_t v2 = *a1;
  for (uint64_t i = a1[1]; i != v2; i -= 32)
  {
    if (*(char *)(i - 9) < 0) {
      operator delete(*(void **)(i - 32));
    }
  }
  a1[1] = v2;
}

void ExpandXPath(char *a1, unsigned char *a2, uint64_t *a3)
{
  if (!a1 || !a2 || !a3 || (int v5 = *a2, !*a2)) {
    ExpandXPath();
  }
  memset(&v133, 0, sizeof(v133));
  unint64_t v7 = 2;
  uint64_t v8 = 1;
  while (v5 == 47 || v5 == 91)
  {
    ++v7;
LABEL_11:
    int v5 = a2[v8++];
  }
  if (v5) {
    goto LABEL_11;
  }
  std::vector<XPathStepInfo>::__clear[abi:ne180100](a3);
  std::vector<XPathStepInfo>::reserve(a3, v7);
  for (uint64_t i = 0; ; ++i)
  {
    int v10 = a2[i];
    BOOL v11 = (v10 - 42) > 0x31 || ((1 << (v10 - 42)) & 0x2000000000021) == 0;
    if (!v11 || v10 == 0) {
      break;
    }
  }
  if (!i)
  {
    exception = __cxa_allocate_exception(0x18uLL);
    *(_DWORD *)exception = 102;
    char v130 = "Empty initial XPath step";
    goto LABEL_199;
  }
  MEMORY[0x18C11BE20](&v133, a2, i);
  if ((SHIBYTE(v133.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    uint64_t v13 = &v133;
    goto LABEL_24;
  }
  uint64_t v13 = (std::string *)v133.__r_.__value_.__r.__words[0];
  if (!v133.__r_.__value_.__r.__words[0]) {
    goto LABEL_191;
  }
LABEL_24:
  int v14 = v13->__r_.__value_.__s.__data_[0];
  if (!v13->__r_.__value_.__s.__data_[0])
  {
LABEL_191:
    uint64_t v123 = "(schemaURI != 0) && (propName != 0) && (*propName != 0)";
    int v124 = 170;
    goto LABEL_195;
  }
  if (*a3 != a3[1])
  {
    uint64_t v123 = "(expandedXPath != 0) && (expandedXPath->empty())";
    int v124 = 171;
LABEL_195:
    __assert_rtn("VerifyXPathRoot", "XMPCore_Impl.cpp", v124, v123);
  }
  if (!*a1)
  {
    exception = __cxa_allocate_exception(0x18uLL);
    *(_DWORD *)exception = 101;
    char v130 = "Schema namespace URI is required";
    goto LABEL_199;
  }
  if ((v14 - 63) < 2)
  {
    exception = __cxa_allocate_exception(0x18uLL);
    *(_DWORD *)exception = 102;
    char v130 = "Top level name must not be a qualifier";
    goto LABEL_199;
  }
  long long v15 = &a2[i];
  uint64_t v16 = 1;
  if (v13->__r_.__value_.__s.__data_[0])
  {
    while (v14 != 47 && v14 != 91)
    {
      int v14 = v13->__r_.__value_.__s.__data_[v16++];
      if (!v14) {
        goto LABEL_32;
      }
    }
    exception = __cxa_allocate_exception(0x18uLL);
    *(_DWORD *)exception = 102;
    char v130 = "Top level name must be simple";
LABEL_199:
    exception[1] = v130;
    *((unsigned char *)exception + 16) = 0;
  }
LABEL_32:
  __s = 0;
  if (!XMP_NamespaceTable::GetPrefix((XMP_NamespaceTable *)sRegisteredNamespaces, a1, (const char **)&__s, 0))
  {
    exception = __cxa_allocate_exception(0x18uLL);
    *(_DWORD *)exception = 101;
    char v130 = "Unregistered schema namespace URI";
    goto LABEL_199;
  }
  for (uint64_t j = 0; v13->__r_.__value_.__s.__data_[j] && v13->__r_.__value_.__s.__data_[j] != 58; ++j)
    ;
  VerifySimpleXMLName((char *)v13, (char *)v13 + j);
  if (v13->__r_.__value_.__s.__data_[j])
  {
    size_t v18 = strlen((const char *)v13 + j);
    VerifySimpleXMLName(&v13->__r_.__value_.__s.__data_[j + 1], (char *)v13 + j + v18);
    __s1 = 0;
    uint64_t v135 = 0;
    uint64_t v136 = 0;
    std::string::basic_string[abi:ne180100](&__s1, v13, j + 1);
    size_t v19 = strlen(__s);
    size_t v20 = v19;
    if ((SHIBYTE(v136) & 0x80000000) == 0)
    {
      if (v19 == HIBYTE(v136))
      {
        if (v19 != -1)
        {
          p_s1 = &__s1;
          goto LABEL_47;
        }
LABEL_213:
        std::string::__throw_out_of_range[abi:ne180100]();
      }
LABEL_208:
      int v131 = __cxa_allocate_exception(0x18uLL);
      *(_DWORD *)int v131 = 101;
      v131[1] = "Schema namespace URI and prefix mismatch";
      *((unsigned char *)v131 + 16) = 0;
    }
    if (v19 != v135) {
      goto LABEL_208;
    }
    if (v19 == -1) {
      goto LABEL_213;
    }
    p_s1 = __s1;
LABEL_47:
    if (memcmp(p_s1, __s, v20)) {
      goto LABEL_208;
    }
    std::string::basic_string[abi:ne180100]<0>(&__p, a1);
    unsigned int v138 = 0x80000000;
    unint64_t v25 = a3[2];
    unint64_t v26 = a3[1];
    if (v26 >= v25)
    {
      uint64_t v28 = (uint64_t)(v26 - *a3) >> 5;
      unint64_t v29 = v28 + 1;
      if ((unint64_t)(v28 + 1) >> 59) {
        std::vector<IIOTag *>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v30 = v25 - *a3;
      if (v30 >> 4 > v29) {
        unint64_t v29 = v30 >> 4;
      }
      if ((unint64_t)v30 >= 0x7FFFFFFFFFFFFFE0) {
        unint64_t v31 = 0x7FFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v31 = v29;
      }
      double v144 = a3 + 2;
      uint64_t v32 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<XPathStepInfo>>((uint64_t)(a3 + 2), v31);
      uint64_t v33 = &v32[32 * v28];
      int v140 = v32;
      unsigned int v141 = v33;
      int v143 = &v32[32 * v34];
      long long v35 = *(_OWORD *)&__p.__r_.__value_.__l.__data_;
      *((void *)v33 + 2) = *((void *)&__p.__r_.__value_.__l + 2);
      *(_OWORD *)uint64_t v33 = v35;
      memset(&__p, 0, sizeof(__p));
      *((_DWORD *)v33 + 6) = v138;
      int v142 = v33 + 32;
      std::vector<XPathStepInfo>::__swap_out_circular_buffer(a3, &v140);
      uint64_t v36 = a3[1];
      std::__split_buffer<XPathStepInfo>::~__split_buffer((uint64_t)&v140);
      int v37 = SHIBYTE(__p.__r_.__value_.__r.__words[2]);
      a3[1] = v36;
      if (v37 < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
    }
    else
    {
      long long v27 = *(_OWORD *)&__p.__r_.__value_.__l.__data_;
      *(void *)(v26 + 16) = *((void *)&__p.__r_.__value_.__l + 2);
      *(_OWORD *)unint64_t v26 = v27;
      memset(&__p, 0, sizeof(__p));
      *(_DWORD *)(v26 + 24) = v138;
      a3[1] = v26 + 32;
    }
    std::string::basic_string[abi:ne180100]<0>(&__p, (char *)v13);
    unsigned int v138 = 0;
    unint64_t v38 = a3[1];
    unint64_t v39 = a3[2];
    if (v38 >= v39)
    {
      uint64_t v41 = (uint64_t)(v38 - *a3) >> 5;
      unint64_t v42 = v41 + 1;
      if ((unint64_t)(v41 + 1) >> 59) {
        std::vector<IIOTag *>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v43 = v39 - *a3;
      if (v43 >> 4 > v42) {
        unint64_t v42 = v43 >> 4;
      }
      if ((unint64_t)v43 >= 0x7FFFFFFFFFFFFFE0) {
        unint64_t v44 = 0x7FFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v44 = v42;
      }
      double v144 = a3 + 2;
      uint64_t v45 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<XPathStepInfo>>((uint64_t)(a3 + 2), v44);
      uint64_t v46 = &v45[32 * v41];
      int v140 = v45;
      unsigned int v141 = v46;
      int v143 = &v45[32 * v47];
      long long v48 = *(_OWORD *)&__p.__r_.__value_.__l.__data_;
      *((void *)v46 + 2) = *((void *)&__p.__r_.__value_.__l + 2);
      *(_OWORD *)uint64_t v46 = v48;
      memset(&__p, 0, sizeof(__p));
      *((_DWORD *)v46 + 6) = v138;
      int v142 = v46 + 32;
      std::vector<XPathStepInfo>::__swap_out_circular_buffer(a3, &v140);
      uint64_t v49 = a3[1];
      std::__split_buffer<XPathStepInfo>::~__split_buffer((uint64_t)&v140);
      int v50 = SHIBYTE(__p.__r_.__value_.__r.__words[2]);
      a3[1] = v49;
      if (v50 < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
    }
    else
    {
      long long v40 = *(_OWORD *)&__p.__r_.__value_.__l.__data_;
      *(void *)(v38 + 16) = *((void *)&__p.__r_.__value_.__l + 2);
      *(_OWORD *)unint64_t v38 = v40;
      memset(&__p, 0, sizeof(__p));
      *(_DWORD *)(v38 + 24) = v138;
      a3[1] = v38 + 32;
    }
    if (SHIBYTE(v136) < 0) {
      operator delete(__s1);
    }
  }
  else
  {
    std::string::basic_string[abi:ne180100]<0>(&__p, a1);
    unsigned int v138 = 0x80000000;
    unint64_t v22 = a3[2];
    unint64_t v23 = a3[1];
    if (v23 >= v22)
    {
      uint64_t v51 = (uint64_t)(v23 - *a3) >> 5;
      unint64_t v52 = v51 + 1;
      if ((unint64_t)(v51 + 1) >> 59) {
        std::vector<IIOTag *>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v53 = v22 - *a3;
      if (v53 >> 4 > v52) {
        unint64_t v52 = v53 >> 4;
      }
      if ((unint64_t)v53 >= 0x7FFFFFFFFFFFFFE0) {
        unint64_t v54 = 0x7FFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v54 = v52;
      }
      double v144 = a3 + 2;
      uint64_t v55 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<XPathStepInfo>>((uint64_t)(a3 + 2), v54);
      int v56 = &v55[32 * v51];
      int v140 = v55;
      unsigned int v141 = v56;
      int v143 = &v55[32 * v57];
      long long v58 = *(_OWORD *)&__p.__r_.__value_.__l.__data_;
      *((void *)v56 + 2) = *((void *)&__p.__r_.__value_.__l + 2);
      *(_OWORD *)int v56 = v58;
      memset(&__p, 0, sizeof(__p));
      *((_DWORD *)v56 + 6) = v138;
      int v142 = v56 + 32;
      std::vector<XPathStepInfo>::__swap_out_circular_buffer(a3, &v140);
      uint64_t v59 = a3[1];
      std::__split_buffer<XPathStepInfo>::~__split_buffer((uint64_t)&v140);
      int v60 = SHIBYTE(__p.__r_.__value_.__r.__words[2]);
      a3[1] = v59;
      if (v60 < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
    }
    else
    {
      long long v24 = *(_OWORD *)&__p.__r_.__value_.__l.__data_;
      *(void *)(v23 + 16) = *((void *)&__p.__r_.__value_.__l + 2);
      *(_OWORD *)unint64_t v23 = v24;
      memset(&__p, 0, sizeof(__p));
      *(_DWORD *)(v23 + 24) = v138;
      a3[1] = v23 + 32;
    }
    std::string::basic_string[abi:ne180100]<0>(&__p, __s);
    unsigned int v138 = 0;
    unint64_t v61 = a3[1];
    unint64_t v62 = a3[2];
    if (v61 >= v62)
    {
      uint64_t v64 = (uint64_t)(v61 - *a3) >> 5;
      unint64_t v65 = v64 + 1;
      if ((unint64_t)(v64 + 1) >> 59) {
        std::vector<IIOTag *>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v66 = v62 - *a3;
      if (v66 >> 4 > v65) {
        unint64_t v65 = v66 >> 4;
      }
      if ((unint64_t)v66 >= 0x7FFFFFFFFFFFFFE0) {
        unint64_t v67 = 0x7FFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v67 = v65;
      }
      double v144 = a3 + 2;
      int v68 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<XPathStepInfo>>((uint64_t)(a3 + 2), v67);
      int v69 = &v68[32 * v64];
      int v140 = v68;
      unsigned int v141 = v69;
      int v143 = &v68[32 * v70];
      long long v71 = *(_OWORD *)&__p.__r_.__value_.__l.__data_;
      *((void *)v69 + 2) = *((void *)&__p.__r_.__value_.__l + 2);
      *(_OWORD *)int v69 = v71;
      memset(&__p, 0, sizeof(__p));
      *((_DWORD *)v69 + 6) = v138;
      int v142 = v69 + 32;
      std::vector<XPathStepInfo>::__swap_out_circular_buffer(a3, &v140);
      uint64_t v72 = a3[1];
      std::__split_buffer<XPathStepInfo>::~__split_buffer((uint64_t)&v140);
      int v73 = SHIBYTE(__p.__r_.__value_.__r.__words[2]);
      a3[1] = v72;
      if (v73 < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
    }
    else
    {
      long long v63 = *(_OWORD *)&__p.__r_.__value_.__l.__data_;
      *(void *)(v61 + 16) = *((void *)&__p.__r_.__value_.__l + 2);
      *(_OWORD *)unint64_t v61 = v63;
      memset(&__p, 0, sizeof(__p));
      *(_DWORD *)(v61 + 24) = v138;
      a3[1] = v61 + 32;
    }
    std::string::append((std::string *)(*a3 + 32), (const std::string::value_type *)v13);
  }
  int v74 = 0;
  std::string v75 = 0;
  if (sRegisteredAliasMap + 8 == std::__tree<std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>>>::find<std::string>(sRegisteredAliasMap, (const void **)(*a3 + 32)))int v76 = 1; {
  else
  }
    int v76 = 17;
  *(_DWORD *)(*a3 + 56) |= v76;
  while (2)
  {
    int v77 = *v15;
    if (v77 == 47)
    {
      int v78 = *++v15;
      int v77 = v78;
LABEL_97:
      if (v77 == 42)
      {
        int v82 = *++v15;
        if (v82 != 91)
        {
          v127 = "Missing '[' after '*'";
          goto LABEL_197;
        }
      }
      else
      {
        int v79 = (char *)v15;
        if (v77 != 91)
        {
          while ((v77 - 42 > 0x31
                || ((1 << (v77 - 42)) & 0x2000000000021) == 0)
               && (_BYTE)v77)
          {
            char v80 = *++v79;
            LOBYTE(v77) = v80;
          }
          int v81 = 1;
          int v74 = (char *)v15;
          std::string v75 = v79;
          goto LABEL_129;
        }
      }
      uint64_t v83 = v15 + 1;
      int v84 = v15[1];
      if ((v84 - 48) < 0xA)
      {
        do
        {
          int v86 = *++v83;
          int v85 = v86;
        }
        while ((v86 - 48) < 0xA);
        if (v85 == 93)
        {
          int v81 = 3;
          goto LABEL_125;
        }
        v127 = "Missing ']' for integer array index";
LABEL_197:
        uint64_t v128 = __cxa_allocate_exception(0x18uLL);
        *(_DWORD *)uint64_t v128 = 102;
        v128[1] = v127;
        *((unsigned char *)v128 + 16) = 0;
      }
      for (uint64_t k = 0; ; ++k)
      {
        if (v84 == 61)
        {
          unint64_t v88 = &v15[k];
          int v89 = v15[k + 2];
          if (v89 == 34 || v89 == 39)
          {
            int v90 = v88 + 3;
            int v91 = v88[3];
            if (v88[3])
            {
              std::string v75 = (char *)(v88 + 1);
              while (1)
              {
                if (v91 == v89)
                {
                  int v93 = *++v90;
                  int v92 = v93;
                  if (v93 != v89) {
                    break;
                  }
                }
                int v94 = *++v90;
                int v91 = v94;
                if (!v94) {
                  goto LABEL_192;
                }
              }
              int v81 = 6;
              int v74 = (char *)(v15 + 1);
              goto LABEL_127;
            }
LABEL_192:
            v125 = "No terminating quote for array selector";
          }
          else
          {
            v125 = "Invalid quote in array selector";
          }
          unsigned int v126 = __cxa_allocate_exception(0x18uLL);
          *(_DWORD *)unsigned int v126 = 102;
          v126[1] = v125;
          *((unsigned char *)v126 + 16) = 0;
        }
        if (v84 == 93) {
          break;
        }
        if (!v84)
        {
          v127 = "Missing ']' or '=' for array index";
          goto LABEL_197;
        }
        int v84 = v15[k + 2];
      }
      uint64_t v95 = k + 1;
      if (strncmp("[last()", (const char *)v15, k + 1))
      {
        v127 = "Invalid non-numeric array index";
        goto LABEL_197;
      }
      uint64_t v83 = &v15[v95];
      int v81 = 4;
LABEL_125:
      int v92 = *v83;
      int v90 = v83;
LABEL_127:
      if (v92 != 93)
      {
        v127 = "Missing ']' for array index";
        goto LABEL_197;
      }
      int v79 = (char *)(v90 + 1);
LABEL_129:
      if (v79 == (char *)v15)
      {
        v127 = "Empty XPath step";
        goto LABEL_197;
      }
      MEMORY[0x18C11BE20](&v133, v15, v79 - (char *)v15);
      if (v81 != 6)
      {
        if (v81 != 1)
        {
LABEL_168:
          if (SHIBYTE(v133.__r_.__value_.__r.__words[2]) < 0) {
            std::string::__init_copy_ctor_external(&v132, v133.__r_.__value_.__l.__data_, v133.__r_.__value_.__l.__size_);
          }
          else {
            std::string v132 = v133;
          }
          if (SHIBYTE(v132.__r_.__value_.__r.__words[2]) < 0) {
            std::string::__init_copy_ctor_external(&__p, v132.__r_.__value_.__l.__data_, v132.__r_.__value_.__l.__size_);
          }
          else {
            std::string __p = v132;
          }
          unsigned int v138 = v81;
          unint64_t v110 = a3[1];
          unint64_t v111 = a3[2];
          if (v110 >= v111)
          {
            uint64_t v113 = (uint64_t)(v110 - *a3) >> 5;
            unint64_t v114 = v113 + 1;
            if ((unint64_t)(v113 + 1) >> 59) {
              std::vector<IIOTag *>::__throw_length_error[abi:ne180100]();
            }
            uint64_t v115 = v111 - *a3;
            if (v115 >> 4 > v114) {
              unint64_t v114 = v115 >> 4;
            }
            if ((unint64_t)v115 >= 0x7FFFFFFFFFFFFFE0) {
              unint64_t v116 = 0x7FFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v116 = v114;
            }
            double v144 = a3 + 2;
            BOOL v117 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<XPathStepInfo>>((uint64_t)(a3 + 2), v116);
            int v118 = &v117[32 * v113];
            int v140 = v117;
            unsigned int v141 = v118;
            int v143 = &v117[32 * v119];
            long long v120 = *(_OWORD *)&__p.__r_.__value_.__l.__data_;
            *((void *)v118 + 2) = *((void *)&__p.__r_.__value_.__l + 2);
            *(_OWORD *)int v118 = v120;
            memset(&__p, 0, sizeof(__p));
            *((_DWORD *)v118 + 6) = v138;
            int v142 = v118 + 32;
            std::vector<XPathStepInfo>::__swap_out_circular_buffer(a3, &v140);
            uint64_t v121 = a3[1];
            std::__split_buffer<XPathStepInfo>::~__split_buffer((uint64_t)&v140);
            int v122 = SHIBYTE(__p.__r_.__value_.__r.__words[2]);
            a3[1] = v121;
            if (v122 < 0) {
              operator delete(__p.__r_.__value_.__l.__data_);
            }
          }
          else
          {
            long long v112 = *(_OWORD *)&__p.__r_.__value_.__l.__data_;
            *(void *)(v110 + 16) = *((void *)&__p.__r_.__value_.__l + 2);
            *(_OWORD *)unint64_t v110 = v112;
            memset(&__p, 0, sizeof(__p));
            *(_DWORD *)(v110 + 24) = v138;
            a3[1] = v110 + 32;
          }
          if (SHIBYTE(v132.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v132.__r_.__value_.__l.__data_);
          }
          long long v15 = (unsigned __int8 *)v79;
          continue;
        }
        int v96 = SHIBYTE(v133.__r_.__value_.__r.__words[2]);
        if (SHIBYTE(v133.__r_.__value_.__r.__words[2]) < 0)
        {
          unsigned int v98 = (std::string *)v133.__r_.__value_.__r.__words[0];
          if (*v133.__r_.__value_.__l.__data_ != 64)
          {
LABEL_161:
            BOOL v108 = v96 < 0;
            uint64_t v109 = &v133;
            if (v108) {
              uint64_t v109 = v98;
            }
            int v97 = v109->__r_.__value_.__s.__data_[0];
            goto LABEL_164;
          }
        }
        else
        {
          int v97 = v133.__r_.__value_.__s.__data_[0];
          if (v133.__r_.__value_.__s.__data_[0] != 64)
          {
LABEL_164:
            if (v97 == 63)
            {
              ++v74;
              int v81 = 2;
            }
            else
            {
              int v81 = 1;
            }
LABEL_167:
            VerifyQualName(v74, v75);
            goto LABEL_168;
          }
          unsigned int v98 = &v133;
        }
        v98->__r_.__value_.__s.__data_[0] = 63;
        int v96 = SHIBYTE(v133.__r_.__value_.__r.__words[2]);
        if (SHIBYTE(v133.__r_.__value_.__r.__words[2]) < 0)
        {
          if (v133.__r_.__value_.__l.__size_ != 9) {
            goto LABEL_202;
          }
          unint64_t v101 = (std::string *)v133.__r_.__value_.__r.__words[0];
        }
        else
        {
          if (SHIBYTE(v133.__r_.__value_.__r.__words[2]) != 9) {
            goto LABEL_202;
          }
          unint64_t v101 = &v133;
        }
        std::string::size_type v105 = v101->__r_.__value_.__r.__words[0];
        int v106 = v101->__r_.__value_.__s.__data_[8];
        if (v105 != 0x6E616C3A6C6D783FLL || v106 != 103)
        {
LABEL_202:
          v127 = "Only xml:lang allowed with '@'";
          goto LABEL_197;
        }
        unsigned int v98 = (std::string *)v133.__r_.__value_.__r.__words[0];
        goto LABEL_161;
      }
      if (SHIBYTE(v133.__r_.__value_.__r.__words[2]) < 0)
      {
        std::string::size_type v102 = v133.__r_.__value_.__r.__words[0];
        unsigned int v100 = (std::string::value_type *)(v133.__r_.__value_.__r.__words[0] + 1);
        if (*(unsigned char *)(v133.__r_.__value_.__r.__words[0] + 1) != 64)
        {
LABEL_149:
          int v99 = *(unsigned __int8 *)(v102 + 1);
          goto LABEL_150;
        }
      }
      else
      {
        int v99 = v133.__r_.__value_.__s.__data_[1];
        unsigned int v100 = &v133.__r_.__value_.__s.__data_[1];
        if (v133.__r_.__value_.__s.__data_[1] != 64)
        {
LABEL_150:
          if (v99 == 63)
          {
            ++v74;
            int v81 = 5;
          }
          else
          {
            int v81 = 6;
          }
          goto LABEL_167;
        }
      }
      *unsigned int v100 = 63;
      int v103 = SHIBYTE(v133.__r_.__value_.__r.__words[2]);
      std::string::size_type v102 = v133.__r_.__value_.__r.__words[0];
      if ((v133.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        v104 = &v133;
      }
      else {
        v104 = (std::string *)v133.__r_.__value_.__r.__words[0];
      }
      if (strncmp((const char *)v104, "[?xml:lang=", 0xBuLL)) {
        goto LABEL_202;
      }
      if ((v103 & 0x80000000) == 0)
      {
        int v99 = BYTE1(v102);
        goto LABEL_150;
      }
      goto LABEL_149;
    }
    break;
  }
  if (*v15) {
    goto LABEL_97;
  }
  if (SHIBYTE(v133.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v133.__r_.__value_.__l.__data_);
  }
}

void sub_1885A3BE4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,uint64_t a25,int a26,__int16 a27,char a28,char a29,void *__p,uint64_t a31,int a32,__int16 a33,char a34,char a35)
{
  std::__split_buffer<XPathStepInfo>::~__split_buffer(v35 - 128);
  if (a35 < 0) {
    operator delete(__p);
  }
  if (a23 < 0) {
    operator delete(a18);
  }
  _Unwind_Resume(a1);
}

char *VerifySimpleXMLName(char *result, char *a2)
{
  if (result >= a2)
  {
    exception = __cxa_allocate_exception(0x18uLL);
    *(_DWORD *)exception = 102;
    uint64_t v16 = "Empty XML name";
LABEL_63:
    exception[1] = v16;
    *((unsigned char *)exception + 16) = 0;
  }
  uint64_t v3 = result;
  if ((*result & 0x80000000) == 0)
  {
    int v4 = *result;
    int v5 = result + 1;
    if ((v4 - 97) < 0x1A) {
      goto LABEL_14;
    }
    if (v4 == 95 || (v4 - 65) < 0x1A) {
      goto LABEL_14;
    }
    goto LABEL_61;
  }
  unsigned int v18 = 0;
  unint64_t v17 = 0;
  uint64_t result = CodePoint_from_UTF8(result, 4uLL, &v18, &v17);
  int v5 = &v3[v17];
  BOOL v7 = v18 - 192 >= 0x17 && v18 - 216 >= 0x1F;
  if (v7
    && v18 - 248 >= 0x208
    && v18 - 880 >= 0xE
    && v18 - 895 >= 0x1C81
    && (v18 & 0xFFFFFFFE) != 0x200C
    && v18 - 8304 >= 0x120
    && v18 - 11264 >= 0x3F0
    && v18 - 12289 >= 0xA7FF
    && v18 - 63744 >= 0x4D0
    && v18 - 65008 >= 0x20E
    && (v18 - 0x10000) >> 17 > 6)
  {
LABEL_61:
    exception = __cxa_allocate_exception(0x18uLL);
    *(_DWORD *)exception = 102;
    uint64_t v16 = "Bad XML name";
    goto LABEL_63;
  }
LABEL_14:
  while (v5 < a2)
  {
    if (*v5 < 0)
    {
      unsigned int v18 = 0;
      unint64_t v17 = 0;
      uint64_t result = CodePoint_from_UTF8(v5, 4uLL, &v18, &v17);
      v5 += v17;
      if (v18 - 192 >= 0x17 && v18 - 216 >= 0x1F)
      {
        BOOL v14 = v18 - 248 >= 0x208 && v18 - 880 >= 0xE;
        if (v14
          && v18 - 895 >= 0x1C81
          && (v18 & 0xFFFFFFFE) != 0x200C
          && v18 - 8304 >= 0x120
          && v18 - 11264 >= 0x3F0
          && v18 - 12289 >= 0xA7FF
          && v18 - 63744 >= 0x4D0
          && v18 - 768 >= 0x70
          && v18 - 65008 >= 0x20E
          && v18 - 0x10000 >= 0xE0000
          && v18 - 8255 >= 2
          && v18 != 183)
        {
          goto LABEL_61;
        }
      }
    }
    else
    {
      int v8 = *v5++;
      if ((v8 - 97) >= 0x1A && v8 != 95 && (v8 - 65) >= 0x1A)
      {
        unsigned int v10 = v8 - 48;
        unsigned int v11 = v8 - 45;
        if (v10 >= 0xA && v11 >= 2) {
          goto LABEL_61;
        }
      }
    }
  }
  return result;
}

uint64_t std::vector<XPathStepInfo>::reserve(uint64_t *a1, unint64_t a2)
{
  uint64_t v4 = a1[2];
  uint64_t result = (uint64_t)(a1 + 2);
  if (a2 > (v4 - *a1) >> 5)
  {
    if (a2 >> 59) {
      std::vector<IIOTag *>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v5 = a1[1] - *a1;
    v7[4] = result;
    v7[0] = std::__allocate_at_least[abi:ne180100]<std::allocator<XPathStepInfo>>(result, a2);
    v7[1] = v7[0] + v5;
    v7[2] = v7[0] + v5;
    v7[3] = v7[0] + 32 * v6;
    std::vector<XPathStepInfo>::__swap_out_circular_buffer(a1, v7);
    return std::__split_buffer<XPathStepInfo>::~__split_buffer((uint64_t)v7);
  }
  return result;
}

void sub_1885A4044(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<XPathStepInfo>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<XPathStepInfo>>(uint64_t a1, unint64_t a2)
{
  if (a2 >> 59) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  return operator new(32 * a2);
}

uint64_t std::vector<XPathStepInfo>::__swap_out_circular_buffer(uint64_t *a1, void *a2)
{
  uint64_t result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<XPathStepInfo>,std::reverse_iterator<XPathStepInfo*>,std::reverse_iterator<XPathStepInfo*>,std::reverse_iterator<XPathStepInfo*>>((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t std::__split_buffer<XPathStepInfo>::~__split_buffer(uint64_t a1)
{
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<XPathStepInfo>,std::reverse_iterator<XPathStepInfo*>,std::reverse_iterator<XPathStepInfo*>,std::reverse_iterator<XPathStepInfo*>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&long long v15 = a6;
  *((void *)&v15 + 1) = a7;
  long long v14 = v15;
  v12[0] = a1;
  v12[1] = &v14;
  v12[2] = &v15;
  uint64_t v13 = 0;
  if (a3 == a5)
  {
    uint64_t v10 = a6;
  }
  else
  {
    uint64_t v8 = a7;
    do
    {
      long long v9 = *(_OWORD *)(a3 - 32);
      *(void *)(v8 - 16) = *(void *)(a3 - 16);
      *(_OWORD *)(v8 - 32) = v9;
      *(void *)(a3 - 24) = 0;
      *(void *)(a3 - 16) = 0;
      *(void *)(a3 - 32) = 0;
      *(_DWORD *)(v8 - 8) = *(_DWORD *)(a3 - 8);
      v8 -= 32;
      v7 -= 32;
      a3 -= 32;
    }
    while (a3 != a5);
    *((void *)&v15 + 1) = v8;
    uint64_t v10 = v15;
  }
  LOBYTE(v13) = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<XPathStepInfo>,std::reverse_iterator<XPathStepInfo*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v12);
  return v10;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<XPathStepInfo>,std::reverse_iterator<XPathStepInfo*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    std::_AllocatorDestroyRangeReverse<std::allocator<XPathStepInfo>,std::reverse_iterator<XPathStepInfo*>>::operator()[abi:ne180100](a1);
  }
  return a1;
}

void std::__split_buffer<XPathStepInfo>::__destruct_at_end[abi:ne180100](uint64_t a1, void **a2)
{
  uint64_t v2 = *(void ***)(a1 + 16);
  if (v2 != a2)
  {
    do
    {
      uint64_t v5 = v2 - 4;
      *(void *)(a1 + 16) = v2 - 4;
      if (*((char *)v2 - 9) < 0)
      {
        operator delete(*v5);
        uint64_t v5 = *(void ***)(a1 + 16);
      }
      uint64_t v2 = v5;
    }
    while (v5 != a2);
  }
}

uint64_t *std::__tree<std::__value_type<std::string,std::vector<XPathStepInfo>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<XPathStepInfo>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<XPathStepInfo>>>>::__emplace_unique_key_args<std::string,std::pair<std::string const,std::vector<XPathStepInfo>>>(uint64_t **a1, const void **a2, long long *a3)
{
  uint64_t v10 = 0;
  uint64_t v5 = (uint64_t **)std::__tree<std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>>>::__find_equal<std::string>((uint64_t)a1, &v10, a2);
  uint64_t v6 = *v5;
  if (!*v5)
  {
    uint64_t v7 = v5;
    memset(v9, 0, sizeof(v9));
    std::__tree<std::__value_type<std::string,std::vector<XPathStepInfo>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<XPathStepInfo>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<XPathStepInfo>>>>::__construct_node<std::pair<std::string const,std::vector<XPathStepInfo>>>((uint64_t)a1, a3, v9);
    std::__tree<std::__value_type<unsigned long,unsigned long>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,unsigned long>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,unsigned long>>>::__insert_node_at(a1, v10, v7, v9[0]);
    uint64_t v6 = v9[0];
    v9[0] = 0;
    std::unique_ptr<std::__tree_node<std::__value_type<std::string,std::vector<XPathStepInfo>>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::string,std::vector<XPathStepInfo>>,void *>>>>::reset[abi:ne180100]((uint64_t)v9, 0);
  }
  return v6;
}

std::string *std::__tree<std::__value_type<std::string,std::vector<XPathStepInfo>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<XPathStepInfo>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<XPathStepInfo>>>>::__construct_node<std::pair<std::string const,std::vector<XPathStepInfo>>>@<X0>(uint64_t a1@<X0>, long long *a2@<X1>, void *a3@<X8>)
{
  uint64_t v5 = a1 + 8;
  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  uint64_t v6 = (char *)operator new(0x50uLL);
  *a3 = v6;
  a3[1] = v5;
  *((unsigned char *)a3 + 16) = 0;
  uint64_t result = std::pair<std::string const,std::vector<XPathStepInfo>>::pair[abi:ne180100]((std::string *)(v6 + 32), a2);
  *((unsigned char *)a3 + 16) = 1;
  return result;
}

void sub_1885A437C(_Unwind_Exception *a1)
{
  std::unique_ptr<std::__tree_node<std::__value_type<std::string,std::vector<XPathStepInfo>>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::string,std::vector<XPathStepInfo>>,void *>>>>::reset[abi:ne180100](v1, 0);
  _Unwind_Resume(a1);
}

std::string *std::pair<std::string const,std::vector<XPathStepInfo>>::pair[abi:ne180100]<std::string&,std::vector<XPathStepInfo>&,0>(std::string *this, long long *a2, long long **a3)
{
  if (*((char *)a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(this, *(const std::string::value_type **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v5 = *a2;
    this->__r_.__value_.__r.__words[2] = *((void *)a2 + 2);
    *(_OWORD *)&this->__r_.__value_.__l.__data_ = v5;
  }
  this[1].__r_.__value_.__r.__words[0] = 0;
  this[1].__r_.__value_.__l.__size_ = 0;
  this[1].__r_.__value_.__r.__words[2] = 0;
  std::vector<XPathStepInfo>::__init_with_size[abi:ne180100]<XPathStepInfo*,XPathStepInfo*>(this + 1, *a3, a3[1], ((char *)a3[1] - (char *)*a3) >> 5);
  return this;
}

void sub_1885A4404(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

std::string *std::vector<XPathStepInfo>::__init_with_size[abi:ne180100]<XPathStepInfo*,XPathStepInfo*>(std::string *result, long long *a2, long long *a3, unint64_t a4)
{
  if (a4)
  {
    uint64_t v6 = result;
    std::vector<XPathStepInfo>::__vallocate[abi:ne180100](result, a4);
    uint64_t result = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<XPathStepInfo>,XPathStepInfo*,XPathStepInfo*,XPathStepInfo*>((uint64_t)&v6->__r_.__value_.__r.__words[2], a2, a3, (std::string *)v6->__r_.__value_.__l.__size_);
    v6->__r_.__value_.__l.__size_ = (std::string::size_type)result;
  }
  return result;
}

void sub_1885A4488(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  *(void *)(v9 + 8) = v10;
  std::vector<XPathStepInfo>::__destroy_vector::operator()[abi:ne180100](&a9);
  _Unwind_Resume(a1);
}

char *std::vector<XPathStepInfo>::__vallocate[abi:ne180100](void *a1, unint64_t a2)
{
  if (a2 >> 59) {
    std::vector<IIOTag *>::__throw_length_error[abi:ne180100]();
  }
  uint64_t result = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<XPathStepInfo>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[32 * v4];
  return result;
}

std::string *std::pair<std::string const,std::vector<XPathStepInfo>>::pair[abi:ne180100](std::string *this, long long *a2)
{
  if (*((char *)a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(this, *(const std::string::value_type **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v4 = *a2;
    this->__r_.__value_.__r.__words[2] = *((void *)a2 + 2);
    *(_OWORD *)&this->__r_.__value_.__l.__data_ = v4;
  }
  this[1].__r_.__value_.__r.__words[0] = 0;
  this[1].__r_.__value_.__l.__size_ = 0;
  this[1].__r_.__value_.__r.__words[2] = 0;
  *(_OWORD *)&this[1].__r_.__value_.__l.__data_ = *(long long *)((char *)a2 + 24);
  this[1].__r_.__value_.__r.__words[2] = *((void *)a2 + 5);
  *((void *)a2 + 3) = 0;
  *((void *)a2 + 4) = 0;
  *((void *)a2 + 5) = 0;
  return this;
}

std::string *std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<XPathStepInfo>,XPathStepInfo*,XPathStepInfo*,XPathStepInfo*>(uint64_t a1, long long *a2, long long *a3, std::string *this)
{
  long long v4 = this;
  unint64_t v12 = this;
  uint64_t v13 = this;
  v10[0] = a1;
  v10[1] = &v12;
  _OWORD v10[2] = &v13;
  uint64_t v11 = 0;
  if (a2 != a3)
  {
    uint64_t v6 = a2;
    do
    {
      if (*((char *)v6 + 23) < 0)
      {
        std::string::__init_copy_ctor_external(v4, *(const std::string::value_type **)v6, *((void *)v6 + 1));
        uint64_t v8 = v13;
      }
      else
      {
        long long v7 = *v6;
        v4->__r_.__value_.__r.__words[2] = *((void *)v6 + 2);
        *(_OWORD *)&v4->__r_.__value_.__l.__data_ = v7;
        uint64_t v8 = v4;
      }
      LODWORD(v4[1].__r_.__value_.__l.__data_) = *((_DWORD *)v6 + 6);
      v6 += 2;
      long long v4 = (std::string *)((char *)v8 + 32);
      uint64_t v13 = (std::string *)((char *)v8 + 32);
    }
    while (v6 != a3);
  }
  LOBYTE(v11) = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<XPathStepInfo>,XPathStepInfo*>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v10);
  return v4;
}

void sub_1885A4610(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<XPathStepInfo>,XPathStepInfo*>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    std::_AllocatorDestroyRangeReverse<std::allocator<XPathStepInfo>,XPathStepInfo*>::operator()[abi:ne180100](a1);
  }
  return a1;
}

void std::unique_ptr<std::__tree_node<std::__value_type<std::string,std::vector<XPathStepInfo>>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::string,std::vector<XPathStepInfo>>,void *>>>>::reset[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void **)a1;
  *(void *)a1 = a2;
  if (v2)
  {
    if (*(unsigned char *)(a1 + 16)) {
      std::__destroy_at[abi:ne180100]<std::pair<std::string const,std::vector<XPathStepInfo>>,0>((uint64_t)v2 + 32);
    }
    operator delete(v2);
  }
}

uint64_t VerifySetOptions(unsigned int a1, const char *a2)
{
  if ((a1 & 0xDFFFE0FD) != 0)
  {
    exception = __cxa_allocate_exception(0x18uLL);
    *(_DWORD *)exception = 103;
    uint64_t v6 = "Unrecognized option flags";
    goto LABEL_13;
  }
  unsigned int v2 = (((a1 >> 1) & 0x800 | a1) >> 1) & 0x400 | (a1 >> 1) & 0x800 | a1;
  uint64_t v3 = (v2 >> 1) & 0x200 | v2;
  if ((a1 & 0x100) != 0 && (v3 & 0x200) != 0)
  {
    exception = __cxa_allocate_exception(0x18uLL);
    *(_DWORD *)exception = 103;
    uint64_t v6 = "IsStruct and IsArray options are mutually exclusive";
    goto LABEL_13;
  }
  if ((a1 & 2) != 0 && (v3 & 0x1F00) != 0)
  {
    exception = __cxa_allocate_exception(0x18uLL);
    *(_DWORD *)exception = 103;
    uint64_t v6 = "Structs and arrays can't have \"value\" options";
    goto LABEL_13;
  }
  if (a2 && (v3 & 0x1F00) != 0)
  {
    exception = __cxa_allocate_exception(0x18uLL);
    *(_DWORD *)exception = 103;
    uint64_t v6 = "Structs and arrays can't have string values";
LABEL_13:
    exception[1] = v6;
    *((unsigned char *)exception + 16) = 0;
  }
  return v3;
}

void XMP_ReadWriteLock::XMP_ReadWriteLock(XMP_ReadWriteLock *this)
{
  *((unsigned char *)this + 204) = 0;
  atomic_store(0, (unsigned int *)this + 50);
  if (pthread_rwlock_init((pthread_rwlock_t *)this, 0))
  {
    exception = __cxa_allocate_exception(0x18uLL);
    *(_DWORD *)exception = 11;
    exception[1] = "Initialize pthread rwlock failed";
    *((unsigned char *)exception + 16) = 0;
  }
}

uint64_t AdobeXMPCore_Int::InitializeXMPCommonFramework(AdobeXMPCore_Int *this)
{
  return AdobeXMPCore_Int::IMemoryAllocator_I::SetMemoryAllocator(0);
}

uint64_t AdobeXMPCore_Int::IMemoryAllocator_I::SetMemoryAllocator(uint64_t a1)
{
  if (AdobeXMPCore_Int::sDefaultMemoryAllocator(void)::onceToken != -1) {
    dispatch_once(&AdobeXMPCore_Int::sDefaultMemoryAllocator(void)::onceToken, &__block_literal_global_43);
  }
  return AdobeXMPCore_Int::MemoryAllocatorWrapperImpl::SetMemoryAllocator(AdobeXMPCore_Int::gDefaultMemoryAllocator, a1);
}

uint64_t AdobeXMPCore_Int::MemoryAllocatorWrapperImpl::SetMemoryAllocator(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  *(void *)(a1 + 8) = a2;
  return v2;
}

uint64_t XMPUtils::Initialize(XMPUtils *this)
{
  if (!XMPUtils::WhiteSpaceStrPtr) {
    operator new();
  }
  return 1;
}

void XMPIterator::Initialize(XMPIterator *this)
{
}

void sub_1885A4938(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10B3C407D34617ELL);
  _Unwind_Resume(a1);
}

AdobeXMPCore_Int::ISharedMutex *AdobeXMPCore_Int::ThreadSafeImpl::EnableThreadSafety(AdobeXMPCore_Int::ISharedMutex *this)
{
  if (!*((void *)this + 1)) {
    AdobeXMPCore_Int::ISharedMutex::CreateSharedMutex(this);
  }
  return this;
}

void AdobeXMPCore_Int::INameSpacePrefixMap_I::CreateDefaultNameSpacePrefixMap(AdobeXMPCore_Int::INameSpacePrefixMap_I *this)
{
  AdobeXMPCore_Int::ManageDefaultNameSpacePrefixMap(0, &v2);
  uint64_t v1 = v3;
  if (v3)
  {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
}

void AdobeXMPCore_Int::ISharedMutex::CreateSharedMutex(AdobeXMPCore_Int::ISharedMutex *this)
{
  uint64_t v1 = (void *)AdobeXMPCore_Int::MemoryManagedObject::operator new((AdobeXMPCore_Int::MemoryManagedObject *)0x20);
  v1[2] = 0;
  v1[3] = 0;
  void *v1 = off_1ED4EA8E0;
  v1[1] = off_1ED4EA980;
  AdobeXMPCore_Int::SharedObjectImpl::Acquire((uint64_t)(v1 + 1));
  std::shared_ptr<AdobeXMPCore_Int::SharedMutexImpl>::shared_ptr[abi:ne180100]<AdobeXMPCore_Int::SharedMutexImpl,std::__mem_fn<void (AdobeXMPCore_Int::SharedObjectImpl::*)(void)const>,void>(&v2, (uint64_t)v1);
}

void std::shared_ptr<AdobeXMPCore_Int::SharedMutexImpl>::shared_ptr[abi:ne180100]<AdobeXMPCore_Int::SharedMutexImpl,std::__mem_fn<void (AdobeXMPCore_Int::SharedObjectImpl::*)(void)const>,void>(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_1885A4B4C(void *a1)
{
  __cxa_begin_catch(a1);
  long long v4 = (void *)((char *)v3 + *(void *)(*v3 - 120) + (v2 >> 1));
  if (v2) {
    uint64_t v1 = *(void (**)(void *))(*v4 + v1);
  }
  v1(v4);
  __cxa_rethrow();
}

void sub_1885A4BB0(_Unwind_Exception *a1)
{
}

uint64_t XMPUtils::Terminate(XMPUtils *this)
{
  uint64_t v1 = XMPUtils::WhiteSpaceStrPtr;
  if (XMPUtils::WhiteSpaceStrPtr)
  {
    if (*(char *)(XMPUtils::WhiteSpaceStrPtr + 23) < 0) {
      operator delete(*(void **)XMPUtils::WhiteSpaceStrPtr);
    }
    uint64_t result = MEMORY[0x18C11C0E0](v1, 0x1012C40EC159624);
  }
  XMPUtils::WhiteSpaceStrPtr = 0;
  return result;
}

void ISOMedia::TerminateGlobals(ISOMedia *this)
{
  if (ISOMedia::boxList(void)::onceToken != -1) {
    dispatch_once(&ISOMedia::boxList(void)::onceToken, &__block_literal_global_45);
  }
  uint64_t v1 = (void *)ISOMedia::gBoxList;
  uint64_t v2 = (void *)(ISOMedia::gBoxList + 8);
  std::__tree<unsigned long long>::destroy(ISOMedia::gBoxList, *(void **)(ISOMedia::gBoxList + 8));
  void *v1 = v2;
  v1[2] = 0;
  void *v2 = 0;
}

uint64_t Common::HandlerRegistry::terminate(Common::HandlerRegistry *this)
{
  uint64_t result = Common::HandlerRegistry::sInstance;
  if (Common::HandlerRegistry::sInstance)
  {
    Common::HandlerRegistry::~HandlerRegistry((Common::HandlerRegistry *)Common::HandlerRegistry::sInstance);
    uint64_t result = MEMORY[0x18C11C0E0]();
  }
  Common::HandlerRegistry::suint64_t Instance = 0;
  return result;
}

void Common::HandlerRegistry::~HandlerRegistry(Common::HandlerRegistry *this)
{
  uint64_t v2 = *(void *)this;
  if (*(void *)this)
  {
    std::__tree<unsigned long long>::destroy(*(void *)this, *(void **)(v2 + 8));
    MEMORY[0x18C11C0E0](v2, 0x1020C4062D53EE8);
  }
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    std::__tree<unsigned long long>::destroy(*((void *)this + 1), *(void **)(v3 + 8));
    MEMORY[0x18C11C0E0](v3, 0x1020C4062D53EE8);
  }
  uint64_t v4 = *((void *)this + 2);
  if (v4)
  {
    std::__tree<unsigned long long>::destroy(*((void *)this + 2), *(void **)(v4 + 8));
    MEMORY[0x18C11C0E0](v4, 0x1020C4062D53EE8);
  }
  uint64_t v5 = *((void *)this + 3);
  if (v5)
  {
    std::__tree<unsigned long long>::destroy(*((void *)this + 3), *(void **)(v5 + 8));
    MEMORY[0x18C11C0E0](v5, 0x1020C4062D53EE8);
  }
}

void std::__tree<unsigned long long>::destroy(uint64_t a1, void *a2)
{
  if (a2)
  {
    std::__tree<unsigned long long>::destroy(a1, *a2);
    std::__tree<unsigned long long>::destroy(a1, a2[1]);
    operator delete(a2);
  }
}

uint64_t AdobeXMPCore_Int::ManageCoreObjectFactory(AdobeXMPCore_Int *this)
{
  {
    AdobeXMPCore_Int::ManageCoreObjectFactory(BOOL)::coreObjectFactoryImplObuint64_t j = (uint64_t)&unk_1ED4ECE60;
    __cxa_atexit((void (*)(void *))AdobeXMPCore_Int::CoreObjectFactoryImpl::~CoreObjectFactoryImpl, &AdobeXMPCore_Int::ManageCoreObjectFactory(BOOL)::coreObjectFactoryImplObj, &dword_188589000);
  }
  return (uint64_t)&AdobeXMPCore_Int::ManageCoreObjectFactory(BOOL)::coreObjectFactoryImplObj
       + *(void *)(AdobeXMPCore_Int::ManageCoreObjectFactory(BOOL)::coreObjectFactoryImplObj - 216);
}

void AdobeXMPCore_Int::INameSpacePrefixMap_I::DestroyDefaultNameSapcePrefixMap(AdobeXMPCore_Int::INameSpacePrefixMap_I *this)
{
  AdobeXMPCore_Int::ManageDefaultNameSpacePrefixMap((AdobeXMPCore_Int *)1, &v2);
  uint64_t v1 = v3;
  if (v3)
  {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
}

uint64_t XMPIterator::Terminate(XMPIterator *this)
{
  uint64_t result = sDummySchema;
  if (sDummySchema) {
    uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)sDummySchema + 8))(sDummySchema);
  }
  sDummySchema = 0;
  return result;
}

uint64_t ID3_Support::TerminateGlobals(ID3_Support *this)
{
  uint64_t v1 = ID3_Support::kMapID3GenreCodeToName;
  if (ID3_Support::kMapID3GenreCodeToName)
  {
    std::__tree<unsigned long long>::destroy(ID3_Support::kMapID3GenreCodeToName, *(void **)(ID3_Support::kMapID3GenreCodeToName + 8));
    uint64_t result = MEMORY[0x18C11C0E0](v1, 0x1020C4062D53EE8);
  }
  uint64_t v3 = ID3_Support::kMapID3GenreNameToCode;
  if (ID3_Support::kMapID3GenreNameToCode)
  {
    std::__tree<unsigned long long>::destroy(ID3_Support::kMapID3GenreNameToCode, *(void **)(ID3_Support::kMapID3GenreNameToCode + 8));
    uint64_t result = MEMORY[0x18C11C0E0](v3, 0x1020C4062D53EE8);
  }
  ID3_Support::kMapID3GenreNameToCode = 0;
  ID3_Support::kMapID3GenreCodeToName = 0;
  return result;
}

void XMP_NamespaceTable::~XMP_NamespaceTable(XMP_NamespaceTable *this)
{
  XMP_NamespaceTable::~XMP_NamespaceTable(this);

  JUMPOUT(0x18C11C0E0);
}

{
  *(void *)this = &unk_1ED4E48E8;
  std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::destroy((uint64_t)this + 240, *((void **)this + 31));
  std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::destroy((uint64_t)this + 216, *((void **)this + 28));
  XMP_ReadWriteLock::~XMP_ReadWriteLock((XMP_NamespaceTable *)((char *)this + 8));
}

uint64_t _CGImageMetadataTagFinalize(void *a1)
{
  atomic_fetch_add_explicit(&gMDTCount, 0xFFFFFFFFFFFFFFFFLL, memory_order_relaxed);
  uint64_t result = a1[3];
  if (result)
  {
    uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
    a1[3] = 0;
  }
  return result;
}

void IIOMetadata_Tag::~IIOMetadata_Tag(IIOMetadata_Tag *this)
{
  IIOMetadata_Tag::~IIOMetadata_Tag(this);

  JUMPOUT(0x18C11C0E0);
}

{
  const void *v2;
  const void *v3;
  const void *v4;
  const void *v5;
  const void *v6;

  *(void *)this = &unk_1ED4E32B0;
  uint64_t v2 = (const void *)*((void *)this + 4);
  if (v2) {
    CFRelease(v2);
  }
  uint64_t v3 = (const void *)*((void *)this + 2);
  if (v3) {
    CFRelease(v3);
  }
  uint64_t v4 = (const void *)*((void *)this + 3);
  if (v4) {
    CFRelease(v4);
  }
  uint64_t v5 = (const void *)*((void *)this + 7);
  if (v5) {
    CFRelease(v5);
  }
  uint64_t v6 = (const void *)*((void *)this + 6);
  if (v6) {
    CFRelease(v6);
  }
}

const char *IIOReadPlugin::ImageBlockSetReleaseInfo(const char *this, void *a2)
{
  if ((gIIODebugFlags & 0xC00) != 0) {
    return IIO_ImageBlockSetReleased(this);
  }
  return this;
}

double _CGImageMetadataFinalize(char *a1)
{
  if (a1 && (char *)*MEMORY[0x1E4F1D260] != a1)
  {
    uint64_t v2 = (const void *)*((void *)a1 + 3);
    if (v2) {
      CFRelease(v2);
    }
    uint64_t v3 = (const void *)*((void *)a1 + 6);
    if (v3) {
      CFRelease(v3);
    }
    uint64_t v4 = (const void *)*((void *)a1 + 4);
    if (v4) {
      CFRelease(v4);
    }
    uint64_t v5 = (const void *)*((void *)a1 + 5);
    if (v5) {
      CFRelease(v5);
    }
    uint64_t v6 = (const void *)*((void *)a1 + 7);
    if (v6) {
      CFRelease(v6);
    }
    long long v7 = (const void *)*((void *)a1 + 8);
    if (v7) {
      CFRelease(v7);
    }
    pthread_mutex_destroy((pthread_mutex_t *)(a1 + 72));
    pthread_mutex_destroy((pthread_mutex_t *)(a1 + 136));
    pthread_mutex_destroy((pthread_mutex_t *)(a1 + 208));
    double result = 0.0;
    *((_OWORD *)a1 + 1) = 0u;
    *((_OWORD *)a1 + 2) = 0u;
    *((_OWORD *)a1 + 3) = 0u;
    *((_OWORD *)a1 + 4) = 0u;
    *((_OWORD *)a1 + 5) = 0u;
    *((_OWORD *)a1 + 6) = 0u;
    *((_OWORD *)a1 + 7) = 0u;
    *((_OWORD *)a1 + 8) = 0u;
    *((_OWORD *)a1 + 9) = 0u;
    *((_OWORD *)a1 + 10) = 0u;
    *((_OWORD *)a1 + 11) = 0u;
    *((_OWORD *)a1 + 12) = 0u;
    *((_OWORD *)a1 + 13) = 0u;
    *((_OWORD *)a1 + 14) = 0u;
    *((_OWORD *)a1 + 15) = 0u;
    *((_OWORD *)a1 + 16) = 0u;
  }
  return result;
}

void IIO_Reader_AppleJPEG::initImageAtOffset()
{
}

void sub_1885A52C0(void *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10E1C40F933A5CALL);
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x1885A52A8);
}

const __CFDictionary **IIOImageSource::copyPropertiesAtIndex(IIOImageSource *this, unint64_t a2, const __CFDictionary **a3)
{
  PropertiesAtIndexInternal = (const __CFDictionary **)IIOImageSource::getPropertiesAtIndexInternal(this, a2, a3);
  if (PropertiesAtIndexInternal)
  {
    if ((gIIODebugFlags & 0x2000000000000) != 0) {
      IIODebugOrientation("copyPropertiesAtIndex", 1663, (IIODictionary *)PropertiesAtIndexInternal);
    }
    CFTypeRef cf = 0;
    uint64_t v7 = 0;
    uint64_t v5 = 0;
    IIODictionary::IIODictionary((IIODictionary *)&v5, PropertiesAtIndexInternal[1], 1);
    PropertiesAtIndexInternal = (const __CFDictionary **)CFRetain(cf);
    if (!PropertiesAtIndexInternal) {
      LogError("copyPropertiesAtIndex", 1670, "*** ERROR: CFDictionaryCreateCopy failed\n");
    }
    IIODictionary::~IIODictionary((IIODictionary *)&v5);
  }
  return PropertiesAtIndexInternal;
}

void sub_1885A5398(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  IIODictionary::~IIODictionary((IIODictionary *)va);
  _Unwind_Resume(a1);
}

IIODictionary *IIOImageSource::getPropertiesAtIndexInternal(IIOImageSource *this, unint64_t a2, const __CFDictionary **a3)
{
  if (!IIOImageSource::bindToReader(this)) {
    return 0;
  }
  uint64_t ImagePlus = IIOImageSource::makeImagePlus(this, a2, a3);
  if (ImagePlus)
  {
    uint64_t v7 = *(IIOImagePlus **)(ImagePlus + 24);
    Properties = (IIODictionary *)IIOImagePlus::getProperties(v7);
    Metastd::string::pointer data = IIOImagePlus::getMetadata(v7);
    if (!Properties)
    {
      _cg_jpeg_mem_term("getPropertiesAtIndexInternal", 1819, "*** iPlus->getProperties() is nil\n");
      return Properties;
    }
    CFDictionaryRef ImageMetadataAtIndex = (const __CFDictionary *)Metadata;
  }
  else
  {
    Properties = (IIODictionary *)IIOImageSource::getImagePropertiesAtIndex(this, a2);
    if (!Properties)
    {
      _cg_jpeg_mem_term("getPropertiesAtIndexInternal", 1824, "*** this->getImagePropertiesAtIndex() is nil\n");
      return Properties;
    }
    CFDictionaryRef ImageMetadataAtIndex = (const __CFDictionary *)IIOImageSource::getImageMetadataAtIndex((CFArrayRef *)this, a2);
    uint64_t v7 = 0;
  }
  if (IIODictionary::getBoolForKey(Properties, @"kCGSourceMetadataNotSynced"))
  {
    uint64_t v11 = CGImagePropertiesCreateFromMetadata(ImageMetadataAtIndex);
    if (v11)
    {
      unint64_t v12 = (IIODictionary *)v11;
      if (!CGImageMetadataGetTopLevelTag(ImageMetadataAtIndex, @"http://ns.apple.com/ImageIO/1.0/", @"hasIIM"))
      {
        if (IIODictionary::containsKey(v12, @"{IPTC}"))
        {
          IIODictionary::removeObjectForKeyGroup(v12, @"DateCreated", @"{IPTC}");
          IIODictionary::removeObjectForKeyGroup(v12, @"TimeCreated", @"{IPTC}");
          IIODictionary::removeObjectForKeyGroup(v12, @"DigitalCreationDate", @"{IPTC}");
          IIODictionary::removeObjectForKeyGroup(v12, @"DigitalCreationTime", @"{IPTC}");
          if (!CGImageMetadataGetTopLevelTag(ImageMetadataAtIndex, @"http://ns.apple.com/ImageIO/1.0/", @"hasXMP"))
          {
            IIODictionary::removeObjectForKeyGroup(v12, @"CopyrightNotice", @"{IPTC}");
            IIODictionary::removeObjectForKeyGroup(v12, @"Caption/Abstract", @"{IPTC}");
            IIODictionary::removeObjectForKeyGroup(v12, @"Byline", @"{IPTC}");
          }
        }
      }
      if (IIODictionary::containsKey(v12, @"{IPTC}"))
      {
        CFDictionaryRef ObjectForKey = IIODictionary::getObjectForKey(v12, @"{IPTC}");
        if (!CFDictionaryGetCount(ObjectForKey)) {
          IIODictionary::removeObjectForKey(v12, @"{IPTC}");
        }
      }
      IIODictionary::appendDictionary(Properties, (const __CFDictionary **)v12);
      (*(void (**)(IIODictionary *))(*(void *)v12 + 8))(v12);
    }
    IIODictionary::removeObjectForKey(Properties, @"kCGSourceMetadataNotSynced");
  }
  if (!a3)
  {
    IIODictionary::removeObjectForKey(Properties, @"_RenderingDepth");
LABEL_32:
    IIODictionary::removeObjectForKeyGroup(Properties, @"JPEGInterchangeFormat", @"{Exif}");
    IIODictionary::removeObjectForKeyGroup(Properties, @"JPEGInterchangeFormatLength", @"{Exif}");
    goto LABEL_33;
  }
  if (IIODictionary::containsKey((IIODictionary *)a3, @"kCGImageSourceAddRenderingInformation")
    && IIODictionary::getBoolForKey((IIODictionary *)a3, @"kCGImageSourceAddRenderingInformation")
    && IIODictionary::containsKey(Properties, @"Depth"))
  {
    unsigned int Uint32ForKey = IIODictionary::getUint32ForKey(Properties, @"Depth");
    if (Uint32ForKey <= 8) {
      int v15 = 8;
    }
    else {
      int v15 = Uint32ForKey;
    }
    IIONumber::IIONumber((IIONumber *)v17, v15);
    IIODictionary::setObjectForKey((uint64_t)Properties, (uint64_t)v17, @"_RenderingDepth");
    IIONumber::~IIONumber((IIONumber *)v17);
  }
  else
  {
    IIODictionary::removeObjectForKey(Properties, @"_RenderingDepth");
  }
  if (!IIODictionary::containsKey((IIODictionary *)a3, @"kCGImageSourceAddThumbnailInformation")
    || !IIODictionary::getBoolForKey((IIODictionary *)a3, @"kCGImageSourceAddThumbnailInformation"))
  {
    goto LABEL_32;
  }
LABEL_33:
  if (IIODictionary::containsKey(Properties, @"kCGImageSourceAddThumbnailInformation")) {
    IIODictionary::removeObjectForKey(Properties, @"XMP_FROM_SIDECAR");
  }
  IIODictionary::removeObjectForKeyGroup(Properties, @"iptcComputedMD5", @"{IPTC}");
  IIODictionary::removeObjectForKeyGroup(Properties, @"iptcPhotoshopMD5", @"{IPTC}");
  if (v7 && IIOImagePlus::getStatus(v7) == -1) {
    IIOImagePlus::setStatus((uint64_t)v7, kCGImageStatusComplete);
  }
  return Properties;
}

void sub_1885A57DC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  IIONumber::~IIONumber((IIONumber *)va);
  _Unwind_Resume(a1);
}

void IIODictionary::removeObjectForKey(IIODictionary *this, const __CFString *a2)
{
  if (a2)
  {
    uint64_t v2 = (__CFDictionary *)*((void *)this + 1);
    if (v2) {
      CFDictionaryRemoveValue(v2, a2);
    }
  }
}

void IIODictionary::removeObjectForKeyGroup(IIODictionary *this, const __CFString *a2, const __CFString *a3)
{
  GroupForKey = IIODictionary::getGroupForKey(this, a3, 0);
  if (a2 && GroupForKey)
  {
    CFDictionaryRemoveValue(GroupForKey, a2);
  }
}

void IIODictionary::setObjectForKeyGroup(IIODictionary *a1, uint64_t a2, const void *a3, const __CFString *a4)
{
  if (a3)
  {
    if (a4)
    {
      if (*((void *)a1 + 1))
      {
        GroupForKey = IIODictionary::getGroupForKey(a1, a4, 1);
        if (GroupForKey)
        {
          uint64_t v7 = *(const void **)(a2 + 16);
          CFDictionarySetValue(GroupForKey, a3, v7);
        }
      }
    }
  }
}

const __CFDictionary *IIODictionary::getObjectForKeyGroup(IIODictionary *this, const __CFString *a2, const __CFString *a3)
{
  CFDictionaryRef result = IIODictionary::getGroupForKey(this, a3, 0);
  if (result)
  {
    return (const __CFDictionary *)CFDictionaryGetValue(result, a2);
  }
  return result;
}

CFMutableDictionaryRef IIODictionary::getGroupForKey(IIODictionary *this, const __CFString *a2, int a3)
{
  CFMutableDictionaryRef Mutable = 0;
  if (a2)
  {
    CFDictionaryRef v5 = (const __CFDictionary *)*((void *)this + 1);
    if (v5)
    {
      CFDictionaryRef Value = (__CFDictionary *)CFDictionaryGetValue(v5, a2);
      CFMutableDictionaryRef Mutable = Value;
      if (!Value || (CFTypeID v9 = CFGetTypeID(Value), v9 == CFNullGetTypeID()))
      {
        if (a3)
        {
          CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
          CFDictionarySetValue(*((CFMutableDictionaryRef *)this + 1), a2, Mutable);
          CFRelease(Mutable);
        }
        if (Mutable)
        {
          CFTypeID v10 = CFGetTypeID(Mutable);
          if (v10 == CFNullGetTypeID()) {
            return 0;
          }
        }
      }
    }
  }
  return Mutable;
}

IIO_Reader *IIOImageSource::isRAWFile(IIOImageSource *this)
{
  CFDictionaryRef result = (IIO_Reader *)*((void *)this + 13);
  if (result)
  {
    unsigned int v2 = IIO_Reader::osType(result);
    return (IIO_Reader *)(HIWORD(v2) == 21057 && ((v2 >> 8) & 0xFE) - 48 <= 9 && (v2 & 0xFE) - 48 < 0xA);
  }
  return result;
}

uint64_t IIOImageSource::makeImagePlus(IIOImageSource *this, unint64_t a2, const __CFDictionary **a3)
{
  *(_WORD *)unint64_t v26 = 0;
  unint64_t v6 = IIOImageSource::updatedCount(this);
  memset(v25, 0, sizeof(v25));
  IIODictionary::IIODictionary((IIODictionary *)v25, a3[1], 1);
  uint64_t v7 = (IIOImageSource *)IIO_Reader::osType(*((IIO_Reader **)this + 13));
  if (v6 <= a2)
  {
    _cg_jpeg_mem_term("makeImagePlus", 3587, "*** ERROR: index (%d) >= count (%ld)\n", a2, v6);
LABEL_26:
    uint64_t v20 = 0;
    goto LABEL_23;
  }
  IIOImageSource::getCacheValues(v7, (IIODictionary *)a3, &v26[1], v26);
  uint64_t ImagePlus = (IIOImagePlus *)IIOImageSource::getImagePlus(this, a2);
  CFTypeID v9 = ImagePlus;
  if (!ImagePlus)
  {
LABEL_20:
    uint64_t v22 = *((void *)this + 2);
    if (v22)
    {
      if (CGImageReadSessionCreate(*((void *)this + 2)))
      {
        CGImageSourceGetSource(v22);
        IIONumber::IIONumber((IIONumber *)v24, *((char *)this + 53));
        IIODictionary::setObjectForKey((uint64_t)v25, (uint64_t)v24, @"kCGImageSourceForceUseServer");
        IIONumber::~IIONumber((IIONumber *)v24);
        CGImagePlusCreateWithSession();
      }
    }
    else
    {
      _cg_jpeg_mem_term("makeImagePlus", 3665, "*** this->imageReadRef() failed\n");
    }
    goto LABEL_26;
  }
  uint64_t Options = IIOImagePlus::getOptions(ImagePlus);
  if (*((unsigned char *)this + 33))
  {
    int v11 = *((unsigned __int8 *)this + 33) ^ 1;
LABEL_10:
    if (v11) {
      goto LABEL_11;
    }
    *((unsigned char *)this + 33) = 0;
    if (IIOImagePlus::getImageProvider(v9))
    {
      uint64_t Image = IIOImagePlus::getImage(v9);
      if (!Image || Image == *MEMORY[0x1E4F1D260]) {
        IIOImagePlus::releaseImageProvider(v9);
      }
    }
    IIOImageSource::setImagePlusAtIndex((uint64_t)this, 0, a2);
    goto LABEL_20;
  }
  uint64_t v12 = Options;
  int v13 = (*(uint64_t (**)(void))(**((void **)this + 13) + 168))(*((void *)this + 13));
  if (v12) {
    int v14 = v13;
  }
  else {
    int v14 = 0;
  }
  if (v14 == 1)
  {
    int v11 = (*(uint64_t (**)(void, void, const __CFDictionary *))(**((void **)this + 13) + 80))(*((void *)this + 13), *(void *)(v12 + 8), a3[1]);
    goto LABEL_10;
  }
LABEL_11:
  unsigned int Status = IIOImagePlus::getStatus(v9);
  if (Status != 0 && Status < 0xFFFFFFFB || ((1 << (Status + 5)) & 0x31) == 0)
  {
    IIOImagePlus::clearProperties((IIODictionary **)v9);
    IIOImagePlus::clearMetadata(v9);
    uint64_t v16 = IIO_Reader::testHeaderSize(v9);
    IIOImageReadSession::rewind(v16);
    unint64_t v17 = (const void *)IIO_Reader::utType(*((IIO_Reader **)this + 13));
    IIODebugCallbackPriv(v17, "initThumbnail");
    uint64_t v18 = *((void *)this + 13);
    uint64_t v19 = IIOImageSource::cf(v9);
    (*(void (**)(uint64_t, uint64_t, unint64_t, void))(*(void *)v18 + 88))(v18, v19, a2, 0);
    IIOImagePlus::copyPropertiesToRoot((IIODictionary **)v9);
  }
  uint64_t v20 = IIOImageSource::cf(v9);
LABEL_23:
  IIODictionary::~IIODictionary((IIODictionary *)v25);
  return v20;
}

void sub_1885A61EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  va_start(va1, a10);
  va_start(va, a10);
  uint64_t v11 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  uint64_t v15 = va_arg(va1, void);
  uint64_t v16 = va_arg(va1, void);
  uint64_t v17 = va_arg(va1, void);
  IIONumber::~IIONumber((IIONumber *)va);
  IIODictionary::~IIODictionary((IIODictionary *)va1);
  _Unwind_Resume(a1);
}

uint64_t IIOImagePlus::getProperties(IIOImagePlus *this)
{
  return *((void *)this + 14);
}

uint64_t IIOImageSource::updatedCount(IIOImageSource *this)
{
  if (*((unsigned char *)this + 32)) {
    return *((void *)this + 3);
  }
  if (!IIOImageSource::bindToReader(this)) {
    return 0;
  }
  if ((*(uint64_t (**)(void))(**((void **)this + 13) + 160))(*((void *)this + 13)))
  {
    uint64_t v3 = CGImageReadSessionCreate(*((void *)this + 2));
    if (v3)
    {
      uint64_t v4 = (const void *)v3;
      uint64_t v15 = 0xFFFFFFFFLL;
      CFDictionaryRef v5 = (const void *)IIO_Reader::utType(*((IIO_Reader **)this + 13));
      IIODebugCallbackPriv(v5, "imageCount");
      memset(v14, 0, sizeof(v14));
      IIODictionary::IIODictionary((IIODictionary *)v14);
      unint64_t v6 = (const void *)*MEMORY[0x1E4F1CFD0];
      uint64_t v7 = (const void *)*MEMORY[0x1E4F1CFC8];
      if (*((unsigned char *)this + 50)) {
        uint64_t v8 = (const void *)*MEMORY[0x1E4F1CFD0];
      }
      else {
        uint64_t v8 = (const void *)*MEMORY[0x1E4F1CFC8];
      }
      IIODictionary::setObjectForKey((IIODictionary *)v14, v8, @"shouldExposeMultiFrameContents");
      if (*((unsigned char *)this + 52)) {
        CFTypeID v9 = v6;
      }
      else {
        CFTypeID v9 = v7;
      }
      IIODictionary::setObjectForKey((IIODictionary *)v14, v9, @"useImageSequence");
      IIONumber::IIONumber((IIONumber *)v13, *((char *)this + 53));
      IIODictionary::setObjectForKey((uint64_t)v14, (uint64_t)v13, @"kCGImageSourceForceUseServer");
      IIONumber::~IIONumber((IIONumber *)v13);
      uint64_t v2 = (*(uint64_t (**)(void, const void *, void *, uint64_t *, char *))(**((void **)this + 13) + 24))(*((void *)this + 13), v4, v14, &v15, (char *)&v15 + 4);
      if (HIDWORD(v15) == -1400)
      {
        ImageIOLog(" retrying 'getImageCount' (ImageIOXPCService crashed?)\n");
        uint64_t v2 = (*(uint64_t (**)(void, const void *, void *, uint64_t *, char *))(**((void **)this + 13)
                                                                                          + 24))(*((void *)this + 13), v4, v14, &v15, (char *)&v15 + 4);
        CFTypeID v10 = "";
        if (!HIDWORD(v15)) {
          CFTypeID v10 = "";
        }
        ImageIOLog("%s retrying 'getImageCount'  err: %d\n", v10, HIDWORD(v15));
      }
      int v11 = v15;
      pthread_mutex_lock((pthread_mutex_t *)((char *)this + 288));
      *((_DWORD *)this + 28) = v11;
      pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 288));
      CFRelease(v4);
      IIODictionary::~IIODictionary((IIODictionary *)v14);
    }
    else
    {
      uint64_t v2 = 0;
    }
  }
  else
  {
    IIOXPCLog(" ImageIOXPC: XPC_READPLUGIN_IMAGECOUNT skipped - defaults to 1\n");
    uint64_t v2 = 1;
  }
  *((void *)this + 3) = v2;
  *((unsigned char *)this + 32) = 1;
  return v2;
}

void sub_1885A6498(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va1, a4);
  va_start(va, a4);
  uint64_t v5 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  IIONumber::~IIONumber((IIONumber *)va);
  IIODictionary::~IIODictionary((IIODictionary *)va1);
  _Unwind_Resume(a1);
}

void IIODictionary::IIODictionary(IIODictionary *this, CFDictionaryRef theDict, int a3)
{
  *(void *)this = &unk_1ED4DFD78;
  if (theDict)
  {
    if (a3) {
      DeepCopy = IIODictionaryCreateDeepCopy(theDict);
    }
    else {
      DeepCopy = CFDictionaryCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, theDict);
    }
  }
  else
  {
    DeepCopy = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  }
  *((void *)this + 1) = DeepCopy;
  *((unsigned char *)this + 16) = 1;
}

__CFDictionary *IIODictionaryCreateDeepCopy(const __CFDictionary *a1)
{
  if (!a1) {
    return 0;
  }
  CFAllocatorRef v2 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  DeepCopy = (__CFDictionary *)CFPropertyListCreateDeepCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a1, 2uLL);
  if (!DeepCopy)
  {
    CFIndex Count = CFDictionaryGetCount(a1);
    DeepCopy = CFDictionaryCreateMutable(v2, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    if (DeepCopy)
    {
      uint64_t v5 = (const void **)malloc_type_malloc(8 * Count, 0x80040B8603338uLL);
      if (v5)
      {
        unint64_t v6 = v5;
        uint64_t v7 = (const void **)malloc_type_malloc(8 * Count, 0x80040B8603338uLL);
        if (v7)
        {
          uint64_t v8 = v7;
          CFDictionaryGetKeysAndValues(a1, v6, v7);
          if (Count >= 1)
          {
            CFTypeID v9 = v8;
            CFTypeID v10 = v6;
            while (1)
            {
              CFTypeID v11 = CFGetTypeID(*v9);
              CFTypeID TypeID = CFDictionaryGetTypeID();
              CFTypeRef v13 = *v9;
              if (v11 == TypeID) {
                break;
              }
              CFTypeID v15 = CFGetTypeID(v13);
              if (v15 != CFArrayGetTypeID())
              {
                CFDictionarySetValue(DeepCopy, *v10, *v9);
                goto LABEL_15;
              }
              uint64_t v14 = IIOArrayCreateDeepCopy((__CFArray *)*v9);
              if (v14) {
                goto LABEL_13;
              }
LABEL_15:
              ++v10;
              ++v9;
              if (!--Count) {
                goto LABEL_16;
              }
            }
            uint64_t v14 = (__CFArray *)IIODictionaryCreateDeepCopy((const __CFDictionary *)v13);
            if (!v14) {
              goto LABEL_15;
            }
LABEL_13:
            uint64_t v16 = v14;
            CFDictionaryAddValue(DeepCopy, *v10, v14);
            CFRelease(v16);
            goto LABEL_15;
          }
LABEL_16:
          free(v6);
        }
        else
        {
          uint64_t v8 = v6;
        }
        free(v8);
      }
    }
  }
  return DeepCopy;
}

IIO_Reader *IIO_ReaderHandler::readerForType(IIO_ReaderHandler *this, int a2)
{
  CFAllocatorRef v2 = (IIO_Reader **)*((void *)this + 2);
  uint64_t v3 = (IIO_Reader **)*((void *)this + 3);
  if (v2 == v3) {
    return 0;
  }
  while (IIO_Reader::osType(*v2) != a2)
  {
    if (++v2 == v3) {
      return 0;
    }
  }
  return *v2;
}

uint64_t IIO_Reader::osType(IIO_Reader *this)
{
  return *((unsigned int *)this + 6);
}

void IIOImageSource::setImageMedadataAtIndex(CFArrayRef *this, const CGImageMetadata *a2, CFIndex a3)
{
  unsigned int Count = CFArrayGetCount(this[22]);
  uint64_t v7 = (const void *)*MEMORY[0x1E4F1D260];
  if (!a2) {
    a2 = (const CGImageMetadata *)*MEMORY[0x1E4F1D260];
  }
  if (a3 >= Count)
  {
    if (this[3] <= a3)
    {
      _cg_jpeg_mem_term("setImageMedadataAtIndex", 4027, "setImageMedadataAtIndex index (%d) larger than arrayCount (%d) and image count (%d)\n", a3, Count, this[3]);
      return;
    }
    while (CFArrayGetCount(this[22]) <= a3)
      CFArrayAppendValue(this[22], v7);
  }
  uint64_t v8 = this[22];

  CFArraySetValueAtIndex(v8, a3, a2);
}

uint64_t CGImageReadSessionCreate(uint64_t a1)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  if (CGImageReadSessionGetTypeID::once != -1) {
    dispatch_once(&CGImageReadSessionGetTypeID::once, &__block_literal_global_14);
  }
  uint64_t Instance = _CFRuntimeCreateInstance();
  if (Instance)
  {
    atomic_fetch_add_explicit(&gReadSessionCount, 1uLL, memory_order_relaxed);
    *(_DWORD *)(Instance + 16) = 1;
    operator new();
  }
  if ((gIIODebugFlags & 0xC000) != 0)
  {
    *(_OWORD *)__str = 0u;
    long long v8 = 0u;
    snprintf(__str, 0x20uLL, "(%p)", 0);
    int v3 = (unsigned __int16)gIIODebugFlags >> 14;
    if ((unsigned __int16)gIIODebugFlags >> 14)
    {
      uint64_t Source = (IIOImagePlus *)CGImageSourceGetSource(a1);
      uint64_t v5 = (const void *)IIOImagePlus::isr(Source);
      ImageIODebugOptions(v3, "S", "CGImageReadSessionCreate", v5, __str, -1, 0);
    }
  }
  return 0;
}

void sub_1885A69B0(_Unwind_Exception *exception_object)
{
}

void *IIOImageReadSession::IIOImageReadSession(void *a1, uint64_t a2, CFTypeRef cf)
{
  *a1 = &unk_1ED4E4C40;
  a1[1] = a2;
  CFTypeRef v4 = CFRetain(cf);
  a1[3] = v4;
  uint64_t Source = (IIOImagePlus *)CGImageSourceGetSource((uint64_t)v4);
  a1[4] = Source;
  a1[2] = IIOImagePlus::isr(Source);
  a1[5] = 0;
  a1[6] = a1;
  a1[7] = a1;
  return a1;
}

uint64_t IIOImagePlus::isr(IIOImagePlus *this)
{
  return ~*((void *)this + 2);
}

void IIOImageSource::setImagePlusAtIndex(uint64_t a1, const void *a2, CFIndex a3)
{
  unsigned int Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 168));
  uint64_t v7 = (const void *)*MEMORY[0x1E4F1D260];
  if (a2) {
    long long v8 = a2;
  }
  else {
    long long v8 = (const void *)*MEMORY[0x1E4F1D260];
  }
  if (a3 >= Count)
  {
    uint64_t v9 = *(void *)(a1 + 24);
    if (v9 <= a3)
    {
      _cg_jpeg_mem_term("setImagePlusAtIndex", 3972, "setImagePlusAtIndex index (%d) larger than arrayCount (%d) and image count (%d)\n", a3, Count, v9);
      if (a2)
      {
        CFRetain(a2);
      }
    }
    else
    {
      while (CFArrayGetCount(*(CFArrayRef *)(a1 + 168)) <= a3)
        CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 168), v7);
      CFTypeID v10 = *(__CFArray **)(a1 + 168);
      CFArraySetValueAtIndex(v10, a3, v8);
    }
  }
  else
  {
    CFArraySetValueAtIndex(*(CFMutableArrayRef *)(a1 + 168), a3, v8);
    if (!a2)
    {
      IIOImageSource::setImagePropertiesAtIndex((IIOImageSource *)a1, 0, a3);
      IIOImageSource::setImageMedadataAtIndex((CFArrayRef *)a1, 0, a3);
    }
  }
}

float IIO_Reader::updateImageHeadroom(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (!a2 || (CGImageGetContentHeadroom(), float v6 = v5, v5 <= 0.0))
  {
    float v6 = 0.0;
    if (a4)
    {
      CGColorSpaceGetHeadroomInfo();
      if (v7 > 0.0) {
        return v7;
      }
    }
  }
  return v6;
}

uint64_t IIOImageSource::getImagePlus(IIOImageSource *this, unint64_t a2)
{
  unint64_t v4 = IIOImageSource::updatedCount(this);
  if (v4 <= a2)
  {
    _cg_jpeg_mem_term("getImagePlus", 3496, "index (%d) out of range [0-%d]\n", a2, v4);
  }
  else
  {
    ImagePlusAtIndex = IIOImageSource::getImagePlusAtIndex((CFArrayRef *)this, a2);
    if (ImagePlusAtIndex) {
      return ImagePlusAtIndex[3];
    }
    IIOImageSource::setImagePlusAtIndex((uint64_t)this, 0, a2);
  }
  return 0;
}

const void *IIOImageSource::getImagePlusAtIndex(CFArrayRef *this, CFIndex a2)
{
  if (CFArrayGetCount(this[21]) <= a2) {
    return 0;
  }
  CFDictionaryRef result = CFArrayGetValueAtIndex(this[21], a2);
  if (result == (const void *)*MEMORY[0x1E4F1D260]) {
    return 0;
  }
  return result;
}

uint64_t IIOImagePlus::setStatus(uint64_t this, CGImageSourceStatus a2)
{
  if (*(_DWORD *)(this + 136) != -6)
  {
    *(_DWORD *)(this + 136) = a2;
    if (a2 == kCGImageStatusInvalidData)
    {
      this = CGImageSourceGetSource(~*(void *)(this + 16));
      if (this)
      {
        return IIOImageSource::setStatus((IIOImageSource *)this, kCGImageStatusInvalidData);
      }
    }
  }
  return this;
}

uint64_t IIOImagePlus::setShouldCacheImageBlocks(uint64_t this, int a2)
{
  if (a2) {
    char v2 = 2;
  }
  else {
    char v2 = 0;
  }
  *(unsigned char *)(this + 192) = *(unsigned char *)(this + 192) & 0xFD | v2;
  return this;
}

void IIOImagePlus::copyPropertiesToRoot(IIODictionary **this)
{
}

uint64_t IIO_Reader::callInitializeImageAtOffset(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6)
{
  IIODebugCallbackPriv(**(const void ***)(a1 + 8), "initImage");
  uint64_t v12 = *(IIO_Reader **)(a2 + 24);
  CFTypeRef v13 = (IIO_Reader *)IIO_Reader::testHeaderSize(v12);
  uint64_t v14 = (IIOXPCClient *)IIO_Reader::testHeaderSize(v13);
  IIOXPCClient = (IIOXPCClient *)IIOXPCClient::GetIIOXPCClient(v14);
  if (IIOXPCClient::useServerForInitImage((uint64_t)IIOXPCClient, v14, a1, a6))
  {
    kdebug_trace();
    uint64_t v134 = 256;
    uint64_t v135 = 0;
    long long v130 = 0u;
    buffer[0] = IIOImagePlus::getOptions(v12);
    buffer[1] = IIOImagePlus::getProperties(v12);
    int v131 = a3;
    int v132 = a4;
    uint64_t v133 = a5;
    BYTE2(v134) = IIOImageReadSession::isFinal(v13);
    if (a4) {
      LOBYTE(v134) = 3;
    }
    xpc_object_t v16 = xpc_dictionary_create(0, 0, 0);
    uint64_t v17 = v16;
    if (v16)
    {
      xpc_object_t v18 = iio_xpc_add_plugin_dict(v16);
      xpc_object_t v19 = iio_xpc_add_source_dict(v17);
      xpc_dictionary_set_uint64(v17, "iio_xpc_message_id", 4uLL);
      CFDictionaryRef v126 = 0;
      uint64_t v127 = 0;
      uint64_t v128 = 0;
      uint64_t v20 = IIOString::IIOString((IIOString *)&v126, **(const void ***)(a1 + 8));
      long long v21 = (const char *)IIOString::utf8String(v20);
      xpc_dictionary_set_string(v19, "iio_xpc_src_utitype", v21);
      xpc_dictionary_set_uint64(v19, "iio_xpc_src_ostype", *(unsigned int *)(a1 + 24));
      IIOImageReadSession::addDataToXPCDictionary(v13, v17, &v135);
      iio_xpc_dictionary_add_databuffer(v18, "iio_xpc_plugin_init_data", buffer, 0x38uLL);
      iio_xpc_dictionary_add_CFDictionary(v19, "iio_xpc_src_options");
      CFDataRef v22 = (const __CFData *)(*(uint64_t (**)(uint64_t, IIO_Reader *))(*(void *)a1 + 104))(a1, v13);
      if (v22)
      {
        iio_xpc_dictionary_add_GlobalInfo(v18, v22, *(_DWORD *)(a1 + 24));
        CFRelease(v22);
      }
      IIOString::~IIOString((IIOString *)&v126);
    }
    unint64_t v23 = (_xpc_connection_s *)IIOXPCClient::xpc_connection(IIOXPCClient);
    long long v24 = (dispatch_queue_s *)IIOXPCClient::xpc_queue(IIOXPCClient);
    xpc_object_t v25 = IIOXPCClient::send_message_with_reply(IIOXPCClient, v23, v24, v17);
    if (!v25)
    {
      IIOXPCLog(" ImageIOXPC: XPC_READPLUGIN_INITIMAGE error null-reply\n");
      uint64_t v34 = 4294967246;
      if (!v17) {
        goto LABEL_168;
      }
      goto LABEL_167;
    }
    unint64_t v26 = v25;
    xpc_object_t message_dict = iio_xpc_get_message_dict(v25);
    xpc_object_t xdict = iio_xpc_get_plugin_dict(v26);
    uint64_t error_code = iio_xpc_dictionary_get_error_code(message_dict);
    if (error_code == -1400)
    {
      int v29 = *(_DWORD *)(a1 + 24);
      unsigned int v30 = v29 >> 24;
      if (v29 < 0)
      {
        int v31 = __maskrune(v30, 0x40000uLL);
        int v29 = *(_DWORD *)(a1 + 24);
      }
      else
      {
        int v31 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v30 + 60) & 0x40000;
      }
      if (v31) {
        uint64_t v40 = (v29 >> 24);
      }
      else {
        uint64_t v40 = 46;
      }
      unsigned int v41 = v29 << 8 >> 24;
      unint64_t v42 = v26;
      if (v29 << 8 < 0)
      {
        int v43 = __maskrune(v41, 0x40000uLL);
        int v29 = *(_DWORD *)(a1 + 24);
      }
      else
      {
        int v43 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v41 + 60) & 0x40000;
      }
      if (v43) {
        uint64_t v44 = (v29 << 8 >> 24);
      }
      else {
        uint64_t v44 = 46;
      }
      unsigned int v45 = (__int16)v29 >> 8;
      if (v29 << 16 < 0)
      {
        int v46 = __maskrune(v45, 0x40000uLL);
        int v29 = *(_DWORD *)(a1 + 24);
      }
      else
      {
        int v46 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v45 + 60) & 0x40000;
      }
      if (v46) {
        uint64_t v47 = ((__int16)v29 >> 8);
      }
      else {
        uint64_t v47 = 46;
      }
      if ((v29 << 24) <= 0x7F000000)
      {
        if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * (char)v29 + 60) & 0x40000) != 0) {
          goto LABEL_45;
        }
      }
      else if (__maskrune((char)v29, 0x40000uLL))
      {
LABEL_45:
        uint64_t v48 = *(char *)(a1 + 24);
LABEL_48:
        IIOXPCLog(" ImageIOXPC [%c%c%c%c]: XPC_READPLUGIN_INITIMAGE XPC connection interrupted\n", v40, v44, v47, v48);
        uint64_t v34 = 4294965896;
LABEL_92:
        unint64_t v67 = v42;
        goto LABEL_166;
      }
      uint64_t v48 = 46;
      goto LABEL_48;
    }
    uint64_t v120 = error_code;
    BOOL v35 = error_code == -49 || error_code == 0;
    int v36 = *(_DWORD *)(a1 + 24);
    unsigned int v37 = v36 >> 24;
    if (v35 && xdict)
    {
      if (v36 < 0)
      {
        int v38 = __maskrune(v37, 0x40000uLL);
        int v36 = *(_DWORD *)(a1 + 24);
      }
      else
      {
        int v38 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v37 + 60) & 0x40000;
      }
      LODWORD(v50) = v36 >> 24;
      if (v38) {
        uint64_t v50 = v50;
      }
      else {
        uint64_t v50 = 46;
      }
      unint64_t v116 = v26;
      CFTypeRef v117 = (CFTypeRef)v50;
      unsigned int v51 = v36 << 8 >> 24;
      if (v36 << 8 < 0)
      {
        int v52 = __maskrune(v51, 0x40000uLL);
        int v36 = *(_DWORD *)(a1 + 24);
      }
      else
      {
        int v52 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v51 + 60) & 0x40000;
      }
      if (v52) {
        uint64_t v56 = (v36 << 8 >> 24);
      }
      else {
        uint64_t v56 = 46;
      }
      unsigned int v57 = (__int16)v36 >> 8;
      if (v36 << 16 < 0)
      {
        int v58 = __maskrune(v57, 0x40000uLL);
        int v36 = *(_DWORD *)(a1 + 24);
      }
      else
      {
        int v58 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v57 + 60) & 0x40000;
      }
      if (v58) {
        uint64_t v62 = ((__int16)v36 >> 8);
      }
      else {
        uint64_t v62 = 46;
      }
      if ((v36 << 24) <= 0x7F000000) {
        int v63 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * (char)v36 + 60) & 0x40000;
      }
      else {
        int v63 = __maskrune((char)v36, 0x40000uLL);
      }
      if (v63) {
        int v64 = *(_DWORD *)(a1 + 24);
      }
      else {
        LOBYTE(v64) = 46;
      }
      IIOXPCLog(" ImageIOXPC [%c%c%c%c]: XPC_READPLUGIN_INITIMAGE: OK\n", v117, v56, v62, (char)v64);
      int v68 = *(_DWORD *)(a1 + 24);
      CFDictionaryRef v69 = (const __CFDictionary *)iio_xpc_dictionary_copy_CFDictionary(xdict, "iio_xpc_plugin_type_changed");
      uint64_t v70 = (IIO_Reader *)a1;
      if (v69)
      {
        CFDictionaryRef v126 = 0;
        uint64_t v127 = 0;
        uint64_t v128 = 0;
        CFDictionaryRef cf = v69;
        long long v71 = IIODictionary::IIODictionary((IIODictionary *)&v126, v69);
        int Uint32ForKey = IIODictionary::getUint32ForKey(v71, @"NEW_PLUGIN_ostype");
        uint64_t v72 = MEMORY[0x1E4F14390];
        unsigned int v73 = v68 >> 24;
        if (v68 < 0) {
          int v74 = __maskrune(v68 >> 24, 0x40000uLL);
        }
        else {
          int v74 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v73 + 60) & 0x40000;
        }
        if (v74) {
          uint64_t v75 = v73;
        }
        else {
          uint64_t v75 = 46;
        }
        uint64_t v115 = v75;
        unsigned int v76 = v68 << 8 >> 24;
        if (v68 << 8 < 0) {
          int v77 = __maskrune(v68 << 8 >> 24, 0x40000uLL);
        }
        else {
          int v77 = *(_DWORD *)(v72 + 4 * v76 + 60) & 0x40000;
        }
        if (v77) {
          uint64_t v78 = v76;
        }
        else {
          uint64_t v78 = 46;
        }
        uint64_t v114 = v78;
        unsigned int v79 = (__int16)v68 >> 8;
        if (v68 << 16 < 0) {
          int v80 = __maskrune((__int16)v68 >> 8, 0x40000uLL);
        }
        else {
          int v80 = *(_DWORD *)(v72 + 4 * v79 + 60) & 0x40000;
        }
        if (v80) {
          uint64_t v81 = v79;
        }
        else {
          uint64_t v81 = 46;
        }
        uint64_t v113 = v81;
        if ((v68 << 24) <= 0x7F000000) {
          int v82 = *(_DWORD *)(v72 + 4 * (char)v68 + 60) & 0x40000;
        }
        else {
          int v82 = __maskrune((char)v68, 0x40000uLL);
        }
        if (v82) {
          uint64_t v83 = (char)v68;
        }
        else {
          uint64_t v83 = 46;
        }
        uint64_t v112 = v83;
        unsigned int v84 = Uint32ForKey >> 24;
        if (Uint32ForKey < 0) {
          int v85 = __maskrune(Uint32ForKey >> 24, 0x40000uLL);
        }
        else {
          int v85 = *(_DWORD *)(v72 + 4 * v84 + 60) & 0x40000;
        }
        if (v85) {
          uint64_t v86 = v84;
        }
        else {
          uint64_t v86 = 46;
        }
        uint64_t v111 = v86;
        unsigned int v87 = Uint32ForKey << 8 >> 24;
        if (Uint32ForKey << 8 < 0) {
          int v88 = __maskrune(Uint32ForKey << 8 >> 24, 0x40000uLL);
        }
        else {
          int v88 = *(_DWORD *)(v72 + 4 * v87 + 60) & 0x40000;
        }
        if (v88) {
          uint64_t v89 = v87;
        }
        else {
          uint64_t v89 = 46;
        }
        unsigned int v90 = (__int16)Uint32ForKey >> 8;
        if (Uint32ForKey << 16 < 0)
        {
          int v92 = __maskrune((__int16)Uint32ForKey >> 8, 0x40000uLL);
          uint64_t v91 = v72;
        }
        else
        {
          uint64_t v91 = v72;
          int v92 = *(_DWORD *)(v72 + 4 * v90 + 60) & 0x40000;
        }
        if ((Uint32ForKey << 24) <= 0x7F000000) {
          int v93 = *(_DWORD *)(v91 + 4 * (char)Uint32ForKey + 60) & 0x40000;
        }
        else {
          int v93 = __maskrune((char)Uint32ForKey, 0x40000uLL);
        }
        if (v92) {
          uint64_t v94 = v90;
        }
        else {
          uint64_t v94 = 46;
        }
        if (v93) {
          uint64_t v95 = (char)Uint32ForKey;
        }
        else {
          uint64_t v95 = 46;
        }
        IIOXPCLog("    changed pluin from '%c%c%c%c' to '%c%c%c%c'\n", v115, v114, v113, v112, v111, v89, v94, v95);
        int v96 = IIODictionary::getUint32ForKey((IIODictionary *)&v126, @"NEW_PLUGIN_dataOffset");
        unsigned int v97 = v96;
        ReaderHandler = (IIO_ReaderHandler *)IIO_ReaderHandler::GetReaderHandler(v96);
        uint64_t v70 = IIO_ReaderHandler::readerForType(ReaderHandler, Uint32ForKey);
        CFRelease(cf);
        a5 = v97;
        if (v70) {
          uint64_t v99 = v120;
        }
        else {
          uint64_t v99 = 4294967246;
        }
        uint64_t v120 = v99;
        IIODictionary::~IIODictionary((IIODictionary *)&v126);
        a3 = 0;
      }
      uint64_t v125 = 0;
      xpc_object_t GlobalInfo = iio_xpc_dictionary_get_GlobalInfo(xdict, &v125);
      if (v125 && v70)
      {
        (*(void (**)(IIO_Reader *, IIO_Reader *, xpc_object_t))(*(void *)v70 + 96))(v70, v13, GlobalInfo);
      }
      else if (!v70)
      {
        unint64_t v101 = 0;
        uint64_t v102 = v120;
        goto LABEL_152;
      }
      unint64_t v101 = (IIOReadPlugin *)(*(uint64_t (**)(IIO_Reader *, uint64_t, uint64_t, uint64_t))(*(void *)v70 + 248))(v70, a2, a3, a5);
      IIOReadPlugin::setUTIWithReader(v101, v70);
      uint64_t v102 = (*(uint64_t (**)(IIOReadPlugin *, xpc_object_t))(*(void *)v101 + 104))(v101, xdict);
LABEL_152:
      unint64_t v67 = v116;
      uint64_t v121 = v102;
      if (!v102)
      {
        CFDictionaryRef v103 = (const __CFDictionary *)iio_xpc_dictionary_copy_CFDictionary(xdict, "iio_xpc_plugin_init_properties");
        CFDictionaryRef v126 = 0;
        uint64_t v127 = 0;
        uint64_t v128 = 0;
        CFDictionaryRef v119 = v103;
        v104 = IIODictionary::IIODictionary((IIODictionary *)&v126, v103, 1);
        if (IIODictionary::getCount(v104)) {
          IIOImagePlus::appendProperties((IIODictionary **)v12, &v126);
        }
        xpc_object_t value = xpc_dictionary_get_value(xdict, "iio_xpc_plugin_init_metadata");
        if (value)
        {
          CGMutableImageMetadataRef v106 = CGImageMetadataCreateFromXPCObj(value);
          if (v106)
          {
            IIOImagePlus::setMetadata(v12, v106);
            CFRelease(v106);
          }
        }
        CFDictionaryRef v107 = (const __CFDictionary *)iio_xpc_dictionary_copy_CFDictionary(xdict, "iio_xpc_plugin_header_infoptr");
        memset(v124, 0, sizeof(v124));
        IIODictionary::IIODictionary((IIODictionary *)v124, v107, 1);
        InfoPtr = (__CFDictionary **)IIOReadPlugin::createInfoPtr(v101);
        if (IIODictionary::getCount((IIODictionary *)v124))
        {
          memset(v123, 0, sizeof(v123));
          IIODictionary::IIODictionary((IIODictionary *)v123, *InfoPtr);
          IIODictionary::appendDictionaryNoOverwrite((IIODictionary *)v123, v124);
          IIOReadPlugin::updateTempColorSpace(v101);
          IIODictionary::~IIODictionary((IIODictionary *)v123);
        }
        InfoPtr[1] = v101;
        IIOReadPlugin::setIPlus(v101, v12, v13);
        (*(void (**)(IIOReadPlugin *, __CFDictionary **))(*(void *)v101 + 64))(v101, InfoPtr);
        if (v119) {
          CFRelease(v119);
        }
        if (v107) {
          CFRelease(v107);
        }
        IIODictionary::~IIODictionary((IIODictionary *)v124);
        IIODictionary::~IIODictionary((IIODictionary *)&v126);
      }
      uint64_t v34 = v121;
LABEL_166:
      _cg_jpeg_mem_term(IIOXPCClient, v67, v49);
      xpc_release(v67);
      if (!v17)
      {
LABEL_168:
        if (v13)
        {
          if (v135) {
            IIOImageReadSession::releaseBytePointer((IIOImageRead **)v13, v135);
          }
        }
        kdebug_trace();
        return v34;
      }
LABEL_167:
      xpc_release(v17);
      goto LABEL_168;
    }
    if (v36 < 0)
    {
      int v39 = __maskrune(v37, 0x40000uLL);
      int v36 = *(_DWORD *)(a1 + 24);
    }
    else
    {
      int v39 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v37 + 60) & 0x40000;
    }
    if (v39) {
      uint64_t v53 = (v36 >> 24);
    }
    else {
      uint64_t v53 = 46;
    }
    unsigned int v54 = v36 << 8 >> 24;
    unint64_t v42 = v26;
    if (v36 << 8 < 0)
    {
      int v55 = __maskrune(v54, 0x40000uLL);
      int v36 = *(_DWORD *)(a1 + 24);
    }
    else
    {
      int v55 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v54 + 60) & 0x40000;
    }
    if (v55) {
      uint64_t v59 = (v36 << 8 >> 24);
    }
    else {
      uint64_t v59 = 46;
    }
    unsigned int v60 = (__int16)v36 >> 8;
    if (v36 << 16 < 0)
    {
      int v61 = __maskrune(v60, 0x40000uLL);
      int v36 = *(_DWORD *)(a1 + 24);
    }
    else
    {
      int v61 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v60 + 60) & 0x40000;
    }
    if (v61) {
      uint64_t v65 = ((__int16)v36 >> 8);
    }
    else {
      uint64_t v65 = 46;
    }
    if ((v36 << 24) <= 0x7F000000)
    {
      if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * (char)v36 + 60) & 0x40000) != 0) {
        goto LABEL_88;
      }
    }
    else if (__maskrune((char)v36, 0x40000uLL))
    {
LABEL_88:
      uint64_t v66 = *(char *)(a1 + 24);
LABEL_91:
      uint64_t v109 = v65;
      uint64_t v34 = v120;
      _cg_jpeg_mem_term("callInitializeImageAtOffset", 861, " ImageIOXPC [%c%c%c%c]: XPC_READPLUGIN_INITIMAGE error: %d  (IMAGEIO_PLUGIN_REPLY: %p)\n", v53, v59, v109, v66, v120, xdict);
      goto LABEL_92;
    }
    uint64_t v66 = 46;
    goto LABEL_91;
  }
  uint64_t v32 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)a1 + 72);

  return v32(a1, a2, a3, a4, a5);
}

void sub_1885A794C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31)
{
  IIODictionary::~IIODictionary((IIODictionary *)&a31);
  IIODictionary::~IIODictionary((IIODictionary *)(v31 - 176));
  _Unwind_Resume(a1);
}

uint64_t IIOXPCClient::GetIIOXPCClient(IIOXPCClient *this)
{
  if (IIOXPCClient::GetIIOXPCClient(void)::xpcClientCreate != -1) {
    dispatch_once(&IIOXPCClient::GetIIOXPCClient(void)::xpcClientCreate, &__block_literal_global_20);
  }
  return IIOXPCClient::GetIIOXPCClient(void)::gIIOXPCClient;
}

void IIODebugCallbackPriv(const void *a1, const char *a2)
{
  if ((gIIODebugFlags & 0xC000) != 0)
  {
    float v5 = 0;
    memset(v4, 0, sizeof(v4));
    IIOString::IIOString((IIOString *)v4, a1);
    int v3 = (const char *)IIOString::utf8String((IIOString *)v4);
    asprintf(&v5, "%s-%s", v3, a2);
    if (v5)
    {
      ImageIOLog("%s   %s\n", "S", v5);
      free(v5);
    }
    IIOString::~IIOString((IIOString *)v4);
  }
}

void sub_1885A7A8C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  IIOString::~IIOString((IIOString *)va);
  _Unwind_Resume(a1);
}

uint64_t IIOXPCClient::useServerForInitImage(uint64_t a1, IIOImageRead *a2, uint64_t a3, int a4)
{
  return IIOXPCClient::useServerForCall(a1, a2, a3, a4, 4, 1);
}

void CGImagePlusCreateWithSession()
{
  uint64_t v0 = *MEMORY[0x1E4F143B8];
  if (CGImagePlusGetTypeID::once != -1) {
    dispatch_once(&CGImagePlusGetTypeID::once, &__block_literal_global_5);
  }
  *(_DWORD *)(_CFRuntimeCreateInstance() + 16) = 1;
  atomic_fetch_add_explicit(&gImagePlusCount, 1uLL, memory_order_relaxed);
  operator new();
}

void sub_1885A7C18(_Unwind_Exception *exception_object)
{
}

void IIOImagePlus::IIOImagePlus(uint64_t a1, CFTypeRef cf)
{
  *(void *)a1 = &unk_1ED4DF190;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_OWORD *)(a1 + 104) = 0u;
  *(_OWORD *)(a1 + 120) = 0u;
  *(_DWORD *)(a1 + 136) = -3;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  strcpy((char *)(a1 + 176), "....");
  *(void *)(a1 + 184) = 0;
  *(_OWORD *)(a1 + 200) = 0u;
  *(_OWORD *)(a1 + 216) = 0u;
  *(_OWORD *)(a1 + 232) = 0u;
  *(unsigned char *)(a1 + 192) &= 0x80u;
  *(_DWORD *)(a1 + 196) = 0;
  *(void *)(a1 + 248) = a1;
  *(void *)(a1 + 256) = a1;
  if (cf) {
    CFTypeRef v4 = CFRetain(cf);
  }
  else {
    CFTypeRef v4 = 0;
  }
  *(void *)(a1 + 24) = v4;
  *(void *)(a1 + 32) = CGImageSourceGetSource((uint64_t)cf);
  operator new();
}

void sub_1885A7DE8(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10A1C4047070A01);
  _Unwind_Resume(a1);
}

CGMutableImageMetadataRef CGImageMetadataCreateMutable(void)
{
  IIOInitDebugFlags();
  if ((~(_WORD)gIIODebugFlags & 0x3000) == 0) {
    ImageIODebugOptions(3, "A", "CGImageMetadataCreateMutable", 0, 0, -1, 0);
  }
  CFAllocatorRef v0 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  if (CGImageMetadataGetTypeID::once != -1) {
    dispatch_once(&CGImageMetadataGetTypeID::once, &__block_literal_global_21);
  }
  uint64_t Instance = _CFRuntimeCreateInstance();
  uint64_t v2 = Instance;
  if (Instance)
  {
    *(unsigned char *)(Instance + 16) = 1;
    *(void *)(Instance + 24) = CFDictionaryCreateMutable(v0, 0, &kCGImageMetadataTagKeyCallbacks, MEMORY[0x1E4F1D540]);
    *(_OWORD *)(v2 + 32) = 0u;
    *(_OWORD *)(v2 + 48) = 0u;
    *(void *)(v2 + 64) = 0;
    initRecursivePthread_mutex((pthread_mutex_t *)(v2 + 72));
    pthread_mutex_init((pthread_mutex_t *)(v2 + 136), 0);
    initRecursivePthread_mutex((pthread_mutex_t *)(v2 + 208));
  }
  return (CGMutableImageMetadataRef)v2;
}

uint64_t initRecursivePthread_mutex(pthread_mutex_t *a1)
{
  uint64_t v4 = *MEMORY[0x1E4F143B8];
  v3.__sig = 0;
  *(void *)v3.__opaque = 0;
  pthread_mutexattr_init(&v3);
  pthread_mutexattr_settype(&v3, 2);
  pthread_mutex_init(a1, &v3);
  return pthread_mutexattr_destroy(&v3);
}

uint64_t IIOReadPlugin::IIOReadPlugin(uint64_t a1, uint64_t a2, int a3, uint64_t a4, int a5)
{
  *(_OWORD *)(a1 + 184) = 0u;
  uint64_t v9 = (CFIndex *)(a1 + 184);
  *(_OWORD *)(a1 + 200) = 0u;
  *(_OWORD *)(a1 + 216) = 0u;
  *(_OWORD *)(a1 + 232) = 0u;
  *(_OWORD *)(a1 + 248) = 0u;
  *(void *)(a1 + 424) = 0;
  *(_OWORD *)(a1 + --*(void *)(result + 264) = 0u;
  *(_OWORD *)(a1 + 280) = 0u;
  *(_OWORD *)(a1 + 296) = 0u;
  *(_OWORD *)(a1 + 312) = 0u;
  *(_OWORD *)(a1 + 328) = 0u;
  *(_OWORD *)(a1 + 344) = 0u;
  *(_OWORD *)(a1 + 360) = 0u;
  *(_OWORD *)(a1 + 376) = 0u;
  *(_OWORD *)(a1 + 392) = 0u;
  *(_OWORD *)(a1 + 408) = 0u;
  *(void *)a1 = &unk_1ED4DFDB8;
  *(void *)(a1 + 8) = a2;
  if (!a2)
  {
    *(void *)(a1 + 16) = 0;
    CFTypeID v11 = (IIOImagePlus **)(a1 + 16);
    *(unsigned char *)(a1 + 40) = 0;
    *(_DWORD *)(a1 + 432) = 0;
LABEL_7:
    *(unsigned char *)(a1 + 341) = 1;
    *(void *)(a1 + 24) = 0;
    *(void *)(a1 + 32) = 0;
    goto LABEL_8;
  }
  CFTypeID v10 = *(IIOImageSource **)(a2 + 24);
  *(void *)(a1 + 16) = v10;
  CFTypeID v11 = (IIOImagePlus **)(a1 + 16);
  *(unsigned char *)(a1 + 40) = 0;
  *(_DWORD *)(a1 + 432) = 0;
  if (!v10) {
    goto LABEL_7;
  }
  uint64_t v12 = IIOImageSource::count(v10);
  if (!v12) {
    goto LABEL_7;
  }
  uint64_t Source = (IIOImageReadSession *)CGImageSourceGetSource(v12);
  *(void *)(a1 + 24) = Source;
  *(unsigned char *)(a1 + 341) = IIOImageReadSession::isFinal(Source);
  uint64_t v14 = (IIOImageRead *)IIO_Reader::testHeaderSize(*(IIO_Reader **)(a1 + 24));
  *(void *)(a1 + 32) = v14;
  if (v14) {
    *uint64_t v9 = IIOImageRead::getSize(v14);
  }
LABEL_8:
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 80) = 0;
  *(void *)(a1 + 88) = 0;
  CFTypeID v15 = *(IIOImagePlus **)(a1 + 16);
  if (v15)
  {
    *(void *)(a1 + 48) = IIOImagePlus::getOptions(v15);
    *(void *)(a1 + 56) = IIOImagePlus::getProperties(*(IIOImagePlus **)(a1 + 16));
    *(void *)(a1 + 64) = IIOImagePlus::getMetadata(*(IIOImagePlus **)(a1 + 16));
  }
  *(_DWORD *)(a1 + 176) = 0;
  *(void *)(a1 + 96) = 0;
  *(void *)(a1 + 112) = 0;
  *(_DWORD *)(a1 + 104) = 0;
  long long v16 = *(_OWORD *)(MEMORY[0x1E4F1DB20] + 16);
  *(_OWORD *)(a1 + 120) = *MEMORY[0x1E4F1DB20];
  *(_OWORD *)(a1 + 136) = v16;
  *(void *)(a1 + 72) = 0;
  *(void *)(a1 + 160) = 0;
  *(void *)(a1 + 168) = 0;
  *(void *)(a1 + 152) = 0;
  *(unsigned char *)(a1 + 180) = IIOPluginShouldDebugWriteImageBlocks();
  *(unsigned char *)(a1 + 181) = IIOPluginShouldDebugWriteImageBlocks();
  *(_DWORD *)(a1 + 208) = a3;
  *(void *)(a1 + 192) = a4;
  *(unsigned char *)(a1 + 355) = -1;
  *(_DWORD *)(a1 + 320) = -1;
  *(_WORD *)(a1 + 328) = 0;
  *(void *)(a1 + 332) = 0x2D2D2D2D00000000;
  *(unsigned char *)(a1 + 342) = 1;
  if ((gIIODebugFlags & 0x20000000) != 0)
  {
    *(unsigned char *)(a1 + 343) = (gIIODebugFlags & 0x40000000) != 0;
  }
  else if (*v11)
  {
    *(unsigned char *)(a1 + 343) = IIOImagePlus::shouldCacheImageBlocks(*v11);
  }
  *(unsigned char *)(a1 + 344) = 1;
  *(_WORD *)(a1 + 353) = 0;
  uint64_t v17 = *(IIODictionary **)(a1 + 48);
  if (v17 && IIODictionary::containsKey(v17, @"kCGImageSourceDecodeRequest"))
  {
    CFStringRef ObjectForKey = (const __CFString *)IIODictionary::getObjectForKey(*(IIODictionary **)(a1 + 48), @"kCGImageSourceDecodeRequest");
    *(unsigned char *)(a1 + 353) = CFEqual(ObjectForKey, @"kCGImageSourceDecodeToSDR");
    *(unsigned char *)(a1 + 354) = CFEqual(ObjectForKey, @"kCGImageSourceDecodeToHDR");
  }
  *(void *)(a1 + 384) = 0;
  *(void *)(a1 + 392) = 0;
  *(void *)(a1 + 404) = -1;
  *(_DWORD *)(a1 + 400) = 538976288;
  *(_WORD *)(a1 + 413) = 256;
  *(_DWORD *)(a1 + 204) = a5;
  return a1;
}

IIOImageRead *IIOImageReadSession::isFinal(IIOImageReadSession *this)
{
  CFDictionaryRef result = (IIOImageRead *)*((void *)this + 4);
  if (result) {
    return (IIOImageRead *)IIOImageRead::isFinal(result);
  }
  return result;
}

uint64_t IIOImagePlus::getMetadata(IIOImagePlus *this)
{
  return *((void *)this + 15);
}

uint64_t IIOImageSource::bindToReader(IIOImageSource *this)
{
  uint64_t result = CGImageSourceGetSource(*((void *)this + 2));
  if (result)
  {
    if (*((unsigned char *)this + 89))
    {
      return 0;
    }
    else
    {
      BOOL isFinal = IIOImageRead::isFinal((IIOImageRead *)result);
      if (*((void *)this + 13))
      {
        int v4 = isFinal - 1;
        pthread_mutex_lock((pthread_mutex_t *)((char *)this + 288));
        *((_DWORD *)this + 28) = v4;
        pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 288));
        return 1;
      }
      else
      {
        return IIOImageSource::doBindToReader(this);
      }
    }
  }
  return result;
}

BOOL IIOImageRead::isFinal(IIOImageRead *this)
{
  if (*((unsigned char *)this + 65))
  {
    uint64_t v2 = (pthread_mutex_t *)((char *)this + 376);
    pthread_mutex_lock((pthread_mutex_t *)((char *)this + 376));
    int v3 = *((unsigned __int8 *)this + 64);
    pthread_mutex_unlock(v2);
  }
  else
  {
    int v3 = *((unsigned __int8 *)this + 64);
  }
  return v3 != 0;
}

uint64_t IIOPluginShouldDebugWriteImageBlocks()
{
  return 0;
}

uint64_t IIOImagePlus::getOptions(IIOImagePlus *this)
{
  return *((void *)this + 25);
}

uint64_t IIOImageSource::count(IIOImageSource *this)
{
  return *((void *)this + 3);
}

uint64_t IIOImagePlus::shouldCacheImageBlocks(IIOImagePlus *this)
{
  return (*((unsigned __int8 *)this + 192) >> 1) & 1;
}

void IIOImageSource::setImagePropertiesAtIndex(IIOImageSource *this, IIODictionary *a2, uint64_t a3)
{
  uint64_t v5 = *((void *)this + 18);
  float v7 = (void *)*((void *)this + 19);
  float v6 = (void **)((char *)this + 144);
  unint64_t v8 = ((uint64_t)v7 - v5) >> 3;
  if (a3 < v8)
  {
LABEL_2:
    *(void *)(v5 + 8 * a3) = a2;
    return;
  }
  uint64_t v9 = *((void *)this + 3);
  if (v9 > a3)
  {
    if (v8 <= a3)
    {
      CFTypeID v11 = (void *)((char *)this + 160);
      do
      {
        if ((unint64_t)v7 >= *v11)
        {
          if ((v8 + 1) >> 61) {
            std::vector<IIOTag *>::__throw_length_error[abi:ne180100]();
          }
          uint64_t v12 = *v11 - v5;
          uint64_t v13 = v12 >> 2;
          if (v12 >> 2 <= v8 + 1) {
            uint64_t v13 = v8 + 1;
          }
          if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v14 = v13;
          }
          if (v14) {
            CFTypeID v15 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<IIOTag *>>((uint64_t)v11, v14);
          }
          else {
            CFTypeID v15 = 0;
          }
          long long v16 = &v15[8 * v8];
          *(void *)long long v16 = 0;
          float v7 = v16 + 8;
          xpc_object_t v18 = (char *)*((void *)this + 18);
          uint64_t v17 = (char *)*((void *)this + 19);
          if (v17 != v18)
          {
            do
            {
              uint64_t v19 = *((void *)v17 - 1);
              v17 -= 8;
              *((void *)v16 - 1) = v19;
              v16 -= 8;
            }
            while (v17 != v18);
            uint64_t v17 = (char *)*v6;
          }
          *((void *)this + 18) = v16;
          *((void *)this + 19) = v7;
          *((void *)this + 20) = &v15[8 * v14];
          if (v17) {
            operator delete(v17);
          }
        }
        else
        {
          *v7++ = 0;
        }
        *((void *)this + 19) = v7;
        uint64_t v5 = *((void *)this + 18);
        unint64_t v8 = ((uint64_t)v7 - v5) >> 3;
      }
      while (v8 <= a3);
    }
    goto LABEL_2;
  }
  _cg_jpeg_mem_term("setImagePropertiesAtIndex", 4066, "setImagePropertiesAtIndex index (%d) larger than vectorCount (%d) and image count (%d\n", a3, ((uint64_t)v7 - v5) >> 3, v9);
}

uint64_t IIOImagePlus::getStatus(IIOImagePlus *this)
{
  unsigned int v1 = *((_DWORD *)this + 34);
  if (v1 == -6) {
    return 4294967291;
  }
  else {
    return v1;
  }
}

void StartElementHandler(void *a1, const char *a2, const char **a3)
{
  if (a3)
  {
    if (*a3)
    {
      uint64_t v3 = 0;
      while (a3[++v3])
        ;
      if (v3)
      {
        v5[0] = 11;
        v5[1] = "Expat attribute info has odd length";
        v5[2] = 0;
        (*(void (**)(void *, uint64_t, void *))(*(void *)a1 + 32))(a1, 1, v5);
      }
    }
    operator new();
  }
  StartElementHandler();
}

void sub_1885A8924(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10B3C40BB36A753);
  _Unwind_Resume(a1);
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<IIOTag *>>(uint64_t a1, unint64_t a2)
{
  if (a2 >> 61) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  return operator new(8 * a2);
}

void CharacterDataHandler(void *a1, const char *a2)
{
}

void sub_1885A8ACC(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10B3C40BB36A753);
  _Unwind_Resume(a1);
}

void XML_Node::XML_Node(XML_Node *this, XML_Node *a2, char *__s, char a4)
{
  *(void *)this = &unk_1ED4E5BF8;
  *((unsigned char *)this + 8) = a4;
  *((void *)this + 2) = 0;
  *((void *)this + 3) = 0;
  *((void *)this + 4) = 0;
  std::string::basic_string[abi:ne180100]<0>((void *)this + 5, __s);
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *((void *)this + 12) = a2;
  *(_OWORD *)((char *)this + 104) = 0u;
  *(_OWORD *)((char *)this + 120) = 0u;
  *(_OWORD *)((char *)this + 136) = 0u;
}

void sub_1885A8B70(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 39) < 0) {
    operator delete(*v2);
  }
  _Unwind_Resume(exception_object);
}

std::string *SetQualName(XMP_NamespaceTable **a1, const char *__s, XML_Node *a3)
{
  size_t v6 = strlen(__s);
  while (1)
  {
    size_t v7 = v6--;
    if (!v6) {
      break;
    }
    if (__s[v7 - 1] == 64) {
      goto LABEL_6;
    }
  }
  if (*__s == 64)
  {
LABEL_6:
    uint64_t v34 = 0;
    unsigned int v33 = 0;
    unint64_t v8 = &__s[v7];
    uint64_t v9 = (char *)a3 + 16;
    MEMORY[0x18C11BE20]((char *)a3 + 16, __s);
    int v10 = *((unsigned __int8 *)a3 + 39);
    if ((v10 & 0x80) != 0)
    {
      if (*((void *)a3 + 3) != 23) {
        goto LABEL_25;
      }
      CFTypeID v11 = *(uint64_t **)v9;
    }
    else
    {
      CFTypeID v11 = (uint64_t *)((char *)a3 + 16);
      if (v10 != 23)
      {
LABEL_19:
        if (!v10) {
          goto LABEL_28;
        }
        goto LABEL_27;
      }
    }
    uint64_t v12 = *v11;
    uint64_t v13 = v11[1];
    uint64_t v14 = *(uint64_t *)((char *)v11 + 15);
    if (v12 == 0x702F2F3A70747468 && v13 == 0x2F67726F2E6C7275 && v14 == 0x2F312E312F63642FLL)
    {
      MEMORY[0x18C11BE10]((char *)a3 + 16, "http://purl.org/dc/elements/1.1/");
      int v10 = *((unsigned __int8 *)a3 + 39);
      if ((v10 & 0x80) == 0) {
        goto LABEL_19;
      }
    }
    else if ((v10 & 0x80) == 0)
    {
      goto LABEL_19;
    }
LABEL_25:
    if (!*((void *)a3 + 3)) {
      goto LABEL_28;
    }
    uint64_t v9 = *(char **)v9;
LABEL_27:
    if (XMP_NamespaceTable::GetPrefix(a1[32], v9, (const char **)&v34, &v33))
    {
LABEL_29:
      *((void *)a3 + 11) = v33;
      CFDataRef v22 = (std::string *)((char *)a3 + 40);
      MEMORY[0x18C11BE10](v22, v34);
      return std::string::append(v22, v8);
    }
LABEL_28:
    v32[0] = 11;
    v32[1] = "Unknown URI in Expat full name";
    v32[2] = 0;
    (*((void (**)(XMP_NamespaceTable **, uint64_t, void *))*a1 + 4))(a1, 1, v32);
    goto LABEL_29;
  }
  uint64_t v17 = (char *)a3 + 40;
  uint64_t result = (std::string *)MEMORY[0x18C11BE10]((char *)a3 + 40, __s);
  uint64_t v19 = *((void *)a3 + 12);
  uint64_t v20 = (void *)(v19 + 40);
  int v21 = *(char *)(v19 + 63);
  if (v21 < 0)
  {
    if (*(void *)(v19 + 48) != 15) {
      return result;
    }
    uint64_t v20 = (void *)*v20;
  }
  else if (v21 != 15)
  {
    return result;
  }
  unint64_t v23 = (void *)*v20;
  uint64_t v24 = *(void *)((char *)v20 + 7);
  if (v23 == (void *)0x637365443A666472 && v24 == 0x6E6F697470697263)
  {
    if (*((char *)a3 + 63) < 0)
    {
      uint64_t v29 = *((void *)a3 + 6);
      if (v29 != 2)
      {
        if (v29 != 5) {
          return result;
        }
        if (**(_DWORD **)v17 != 1970233953 || *(unsigned char *)(*(void *)v17 + 4) != 116) {
          return result;
        }
        goto LABEL_57;
      }
      long long v27 = *(_WORD **)v17;
    }
    else
    {
      int v26 = *((unsigned __int8 *)a3 + 63);
      long long v27 = (_WORD *)((char *)a3 + 40);
      if (v26 != 2)
      {
        if (v26 != 5) {
          return result;
        }
        if (*(_DWORD *)v17 != 1970233953 || *((unsigned char *)a3 + 44) != 116) {
          return result;
        }
LABEL_57:
        MEMORY[0x18C11BE10]((char *)a3 + 16, "http://www.w3.org/1999/02/22-rdf-syntax-ns#");
        uint64_t v31 = "rdf:about";
        goto LABEL_58;
      }
    }
    if (*v27 != 17481) {
      return result;
    }
    MEMORY[0x18C11BE10]((char *)a3 + 16, "http://www.w3.org/1999/02/22-rdf-syntax-ns#");
    uint64_t v31 = "rdf:ID";
LABEL_58:
    uint64_t result = (std::string *)MEMORY[0x18C11BE10]((char *)a3 + 40, v31);
    *((void *)a3 + 11) = 4;
  }
  return result;
}

uint64_t IIOImagePlus::setShouldCacheImmediately(uint64_t this, int a2)
{
  if (a2) {
    char v2 = 4;
  }
  else {
    char v2 = 0;
  }
  *(unsigned char *)(this + 192) = *(unsigned char *)(this + 192) & 0xFB | v2;
  return this;
}

uint64_t IIO_Reader::initImageAtOffset(IIO_Reader *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (IIO_XPCServer()) {
    return 4294967246;
  }
  CFTypeID v11 = (IIOReadPlugin *)(*(uint64_t (**)(IIO_Reader *, uint64_t, uint64_t, uint64_t))(*(void *)a1 + 248))(a1, a2, a3, a5);
  IIOReadPlugin::setUTIWithReader(v11, a1);
  if (a4)
  {
    if (v11)
    {
      IIOReadPlugin::setDecodeMode((uint64_t)v11, 3);
      IIOReadPlugin::setDestMaxPixelSize((uint64_t)v11, a4);
    }
  }
  return IIOReadPlugin::callInitialize(v11);
}

void sub_1885A8F6C(void *a1)
{
}

void sub_1885A8F7C(void *a1)
{
}

uint64_t IIOReadPlugin::setUTIWithReader(IIOReadPlugin *this, IIO_Reader *a2)
{
  *((void *)this + 9) = IIOImageSource::cf(a2);
  uint64_t result = IIO_Reader::osType(a2);
  *((_DWORD *)this + 51) = result;
  return result;
}

uint64_t CGImagePropertiesCreateFromMetadata(void *a1)
{
  uint64_t v8 = 0;
  uint64_t v9 = &v8;
  uint64_t v10 = 0x2000000000;
  uint64_t v11 = 0;
  if (a1)
  {
    CFTypeID v2 = CFGetTypeID(a1);
    if (v2 == CGImageMetadataGetTypeID())
    {
      CFDictionaryRef v3 = (const __CFDictionary *)a1[3];
      if (v3 && !CFDictionaryGetCount(v3) && !a1[6])
      {
        uint64_t v5 = 0;
        goto LABEL_13;
      }
      uint64_t v4 = v9[3];
      if (a1[6])
      {
        if (!v4) {
          operator new();
        }
      }
      else if (!v4)
      {
        operator new();
      }
      v7[0] = MEMORY[0x1E4F143A8];
      v7[1] = 0x40000000;
      v7[2] = __CGImagePropertiesCreateFromMetadata_block_invoke;
      v7[3] = &unk_1E53CCA90;
      v7[4] = &v8;
      void v7[5] = a1;
      XMPMappingIterateUsingBlock((uint64_t)v7);
    }
  }
  uint64_t v5 = v9[3];
LABEL_13:
  _Block_object_dispose(&v8, 8);
  return v5;
}

void sub_1885A9114(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  MEMORY[0x18C11C0E0](v7, 0x10A1C4047070A01);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void IIO_Reader_PNG::createReadPlugin()
{
}

{
  operator new();
}

void sub_1885A91CC(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10E1C4070B3CFD8);
  _Unwind_Resume(a1);
}

double PNGReadPlugin::PNGReadPlugin(uint64_t a1, uint64_t a2, int a3, uint64_t a4, int a5)
{
  uint64_t v5 = IIOReadPlugin::IIOReadPlugin(a1, a2, a3, a4, a5);
  *(void *)uint64_t v5 = &unk_1ED4E07B8;
  double result = 0.0;
  *(_OWORD *)(v5 + 440) = 0u;
  *(_OWORD *)(v5 + 456) = 0u;
  *(_OWORD *)(v5 + 472) = 0u;
  *(_OWORD *)(v5 + 488) = 0u;
  *(_OWORD *)(v5 + 504) = 0u;
  return result;
}

uint64_t IIO_Reader_PNG::hasCustomImageCountProc(IIO_Reader_PNG *this)
{
  return 1;
}

double AppleJPEGReadPlugin::AppleJPEGReadPlugin(uint64_t a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, char a6, int a7, uint64_t a8, int a9)
{
  JPEGReadPlugin::JPEGReadPlugin(a1, a2, a3, a4, a5, a6, a7, a8, a9);
  *(void *)uint64_t v9 = &unk_1ED4E4A60;
  double result = 0.0;
  *(_OWORD *)(v9 + 504) = 0u;
  *(_OWORD *)(v9 + 520) = 0u;
  *(_OWORD *)(v9 + 536) = 0u;
  *(_OWORD *)(v9 + 552) = 0u;
  *(_OWORD *)(v9 + 568) = 0u;
  *(_OWORD *)(v9 + 584) = 0u;
  *(_OWORD *)(v9 + 600) = 0u;
  *(_OWORD *)(v9 + 616) = 0u;
  *(_OWORD *)(v9 + 632) = 0u;
  *(_OWORD *)(v9 + 648) = 0u;
  *(_OWORD *)(v9 + 664) = 0u;
  *(void *)(v9 + 680) = 0;
  return result;
}

double JPEGReadPlugin::JPEGReadPlugin(uint64_t a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, char a6, int a7, uint64_t a8, int a9)
{
  uint64_t v13 = IIOReadPlugin::IIOReadPlugin(a1, a2, a3, a4, a9);
  *(void *)uint64_t v13 = &unk_1ED4E28E0;
  double result = 0.0;
  *(_OWORD *)(v13 + 448) = 0u;
  *(_OWORD *)(v13 + 464) = 0u;
  *(_OWORD *)(v13 + 480) = 0u;
  *(void *)(v13 + 496) = 0;
  *(_DWORD *)(v13 + 452) = a7;
  *(unsigned char *)(v13 + 472) = a6;
  *(void *)(v13 + 456) = a4;
  *(void *)(v13 + 464) = a5;
  *(void *)(v13 + 440) = 0;
  return result;
}

uint64_t IIO_Reader_PNG::hasCustomCompareOptionsProc(IIO_Reader_PNG *this)
{
  return 1;
}

uint64_t IIO_Reader_PNG::compareOptions(IIO_Reader_PNG *this, const __CFDictionary *a2, const __CFDictionary *a3)
{
  memset(v19, 0, sizeof(v19));
  IIODictionary::IIODictionary((IIODictionary *)v19, a2);
  memset(v18, 0, sizeof(v18));
  IIODictionary::IIODictionary((IIODictionary *)v18, a3);
  unsigned int Uint32ForKey = IIODictionary::getUint32ForKey((IIODictionary *)v19, @"kCGImageSourceSubsampleFactor");
  unsigned int v6 = IIODictionary::getUint32ForKey((IIODictionary *)v18, @"kCGImageSourceSubsampleFactor");
  if (Uint32ForKey <= 1) {
    int v7 = 1;
  }
  else {
    int v7 = Uint32ForKey;
  }
  if (v6 <= 1) {
    int v8 = 1;
  }
  else {
    int v8 = v6;
  }
  if (v7 == v8
    && (BOOL BoolForKey = IIODictionary::getBoolForKey((IIODictionary *)v19, @"kCGImageSourceUseCoreImage"),
        BoolForKey == IIODictionary::getBoolForKey((IIODictionary *)v18, @"kCGImageSourceUseCoreImage"))
    && (CFDictionaryRef ObjectForKey = IIODictionary::getObjectForKey((IIODictionary *)v19, @"kCGImageSourceXMPSidecar"),
        CFDictionaryRef v11 = IIODictionary::getObjectForKey((IIODictionary *)v18, @"kCGImageSourceXMPSidecar"),
        (ObjectForKey != 0) == (v11 != 0))
    && (!ObjectForKey || !v11 || CFEqual(ObjectForKey, v11))
    && (int v12 = IIOSkipMetadata((IIODictionary *)v19), (v12 ^ 1 | IIOSkipMetadata((IIODictionary *)v18)) == 1))
  {
    CFStringRef Value = (const __CFString *)CFDictionaryGetValue(a2, @"kCGImageSourceDecodeRequest");
    CFStringRef v14 = (const __CFString *)CFDictionaryGetValue(a3, @"kCGImageSourceDecodeRequest");
    if (Value && v14) {
      BOOL v15 = CFEqual(Value, v14);
    }
    else {
      BOOL v15 = ((unint64_t)Value | (unint64_t)v14) == 0;
    }
    uint64_t v16 = v15;
  }
  else
  {
    uint64_t v16 = 0;
  }
  IIODictionary::~IIODictionary((IIODictionary *)v18);
  IIODictionary::~IIODictionary((IIODictionary *)v19);
  return v16;
}

void sub_1885A94DC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12)
{
}

uint64_t IIO_Reader::hasCustomImageCountProc(IIO_Reader *this)
{
  return 0;
}

void IIOXPCLog(char *a1, ...)
{
  va_start(va, a1);
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  if (IIOXPCLog::onceToken != -1) {
    dispatch_once(&IIOXPCLog::onceToken, &__block_literal_global_22);
  }
  if (IIOXPCLog::logXPC)
  {
    v3[0] = 0;
    va_copy((va_list)&v3[1], va);
    vasprintf(v3, a1, va);
    if (os_log_type_enabled(0, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v5 = v3[0];
      _os_log_impl(&dword_188589000, 0, OS_LOG_TYPE_DEFAULT, "%{public}s", buf, 0xCu);
    }
    CFTypeID v2 = (FILE *)*MEMORY[0x1E4F143C8];
    if (gRunningInXPCService) {
      fprintf(v2, "[S] %s");
    }
    else {
      fprintf(v2, "[C] %s");
    }
    free(v3[0]);
  }
}

uint64_t IIOReadPlugin::setDecodeMode(uint64_t result, char a2)
{
  *(unsigned char *)(result + 216) = a2;
  return result;
}

uint64_t IIOImagePlus::getImage(IIOImagePlus *this)
{
  return *((void *)this + 16);
}

uint64_t IIO_Reader_HEIF::hasCustomImageCountProc(IIO_Reader_HEIF *this)
{
  return 1;
}

uint64_t IIO_Reader_HEIF::hasCustomCompareOptionsProc(IIO_Reader_HEIF *this)
{
  return 1;
}

uint64_t IIO_Reader_HEIF::compareOptions(IIO_Reader_HEIF *this, const __CFDictionary *a2, const __CFDictionary *a3)
{
  memset(v16, 0, sizeof(v16));
  IIODictionary::IIODictionary((IIODictionary *)v16, a2);
  memset(v15, 0, sizeof(v15));
  IIODictionary::IIODictionary((IIODictionary *)v15, a3);
  unsigned int Uint32ForKey = IIODictionary::getUint32ForKey((IIODictionary *)v16, @"kCGImageSourceSubsampleFactor");
  unsigned int v6 = IIODictionary::getUint32ForKey((IIODictionary *)v15, @"kCGImageSourceSubsampleFactor");
  if (Uint32ForKey <= 1) {
    int v7 = 1;
  }
  else {
    int v7 = Uint32ForKey;
  }
  if (v6 <= 1) {
    int v8 = 1;
  }
  else {
    int v8 = v6;
  }
  if (v7 == v8
    && (int v9 = IIOSkipMetadata((IIODictionary *)v16),
        ((v9 ^ 1 | IIOSkipMetadata((IIODictionary *)v15)) & 1) != 0))
  {
    CFStringRef Value = (const __CFString *)CFDictionaryGetValue(a2, @"kCGImageSourceDecodeRequest");
    CFStringRef v11 = (const __CFString *)CFDictionaryGetValue(a3, @"kCGImageSourceDecodeRequest");
    if (Value && v11) {
      BOOL v12 = CFEqual(Value, v11);
    }
    else {
      BOOL v12 = ((unint64_t)Value | (unint64_t)v11) == 0;
    }
    uint64_t v13 = v12;
  }
  else
  {
    uint64_t v13 = 0;
  }
  IIODictionary::~IIODictionary((IIODictionary *)v15);
  IIODictionary::~IIODictionary((IIODictionary *)v16);
  return v13;
}

void sub_1885A9794(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12)
{
}

uint64_t IIO_Reader_AppleJPEG::hasCustomCompareOptionsProc(IIO_Reader_AppleJPEG *this)
{
  return 1;
}

uint64_t IIO_Reader_AppleJPEG::compareOptions(IIO_Reader_AppleJPEG *this, const __CFDictionary *a2, const __CFDictionary *a3)
{
  memset(v22, 0, sizeof(v22));
  IIODictionary::IIODictionary((IIODictionary *)v22, a2);
  memset(v21, 0, sizeof(v21));
  IIODictionary::IIODictionary((IIODictionary *)v21, a3);
  unsigned int Uint32ForKey = IIODictionary::getUint32ForKey((IIODictionary *)v22, @"kCGImageSourceSubsampleFactor");
  unsigned int v6 = IIODictionary::getUint32ForKey((IIODictionary *)v21, @"kCGImageSourceSubsampleFactor");
  if (Uint32ForKey <= 1) {
    int v7 = 1;
  }
  else {
    int v7 = Uint32ForKey;
  }
  if (v6 <= 1) {
    int v8 = 1;
  }
  else {
    int v8 = v6;
  }
  if (v7 == v8
    && (BOOL BoolForKey = IIODictionary::getBoolForKey((IIODictionary *)v22, @"kCGImageSourceUseCoreImage"),
        BoolForKey == IIODictionary::getBoolForKey((IIODictionary *)v21, @"kCGImageSourceUseCoreImage"))
    && (CFDictionaryRef ObjectForKey = IIODictionary::getObjectForKey((IIODictionary *)v22, @"kCGImageSourceXMPSidecar"),
        CFDictionaryRef v11 = IIODictionary::getObjectForKey((IIODictionary *)v21, @"kCGImageSourceXMPSidecar"),
        (ObjectForKey != 0) == (v11 != 0))
    && (!ObjectForKey || !v11 || CFEqual(ObjectForKey, v11))
    && (int v12 = IIOSkipMetadata((IIODictionary *)v22), (v12 ^ 1 | IIOSkipMetadata((IIODictionary *)v21)) == 1)
    && (BOOL v13 = IIODictionary::getBoolForKey((IIODictionary *)v22, @"kCGImageSourceAddJPEGQualityInformation"),
        v13 == IIODictionary::getBoolForKey((IIODictionary *)v21, @"kCGImageSourceAddJPEGQualityInformation"))
    && (BOOL v14 = IIODictionary::getBoolForKey((IIODictionary *)v22, @"kCGImageSourceAddThumbnailInformation"),
        v14 == IIODictionary::getBoolForKey((IIODictionary *)v21, @"kCGImageSourceAddThumbnailInformation"))
    && (BOOL v15 = IIODictionary::getBoolForKey((IIODictionary *)v22, @"kCGImageSourceUseHardwareAcceleration"),
        v15 == IIODictionary::getBoolForKey((IIODictionary *)v21, @"kCGImageSourceUseHardwareAcceleration")))
  {
    CFStringRef Value = (const __CFString *)CFDictionaryGetValue(a2, @"kCGImageSourceDecodeRequest");
    CFStringRef v19 = (const __CFString *)CFDictionaryGetValue(a3, @"kCGImageSourceDecodeRequest");
    if (Value && v19) {
      BOOL v20 = CFEqual(Value, v19);
    }
    else {
      BOOL v20 = ((unint64_t)Value | (unint64_t)v19) == 0;
    }
    uint64_t v16 = v20;
  }
  else
  {
    uint64_t v16 = 0;
  }
  IIODictionary::~IIODictionary((IIODictionary *)v21);
  IIODictionary::~IIODictionary((IIODictionary *)v22);
  return v16;
}

void sub_1885A9A18(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12)
{
}

uint64_t IIO_Reader_ATX::hasCustomImageCountProc(IIO_Reader_ATX *this)
{
  return 1;
}

void IIO_Reader_ATX::createReadPlugin()
{
}

{
  operator new();
}

void sub_1885A9ADC(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10E1C40910A7DF9);
  _Unwind_Resume(a1);
}

uint64_t IIO_Reader_ASTC::hasCustomImageCountProc(IIO_Reader_ASTC *this)
{
  return 1;
}

uint64_t IIO_Reader::hasCustomCompareOptionsProc(IIO_Reader *this)
{
  return 0;
}

void IIO_Reader_ASTC::createReadPlugin()
{
}

{
  operator new();
}

void sub_1885A9B8C(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10E1C40BDB929D5);
  _Unwind_Resume(a1);
}

unsigned __int8 *NormalizeLangValue(unsigned __int8 *result)
{
  if ((char)result[23] < 0) {
    double result = *(unsigned __int8 **)result;
  }
  while (1)
  {
    int v1 = *result;
    if (!*result || v1 == 45) {
      break;
    }
    if ((v1 - 65) <= 0x19) {
      std::string *result = v1 + 32;
    }
    ++result;
  }
  uint64_t v2 = 0;
  BOOL v3 = v1 == 45;
  for (uint64_t i = v3; ; ++i)
  {
    uint64_t v5 = v3 + v2;
    int v6 = result[v3 + v2];
    if (!result[v3 + v2] || v6 == 45) {
      break;
    }
    if ((v6 - 65) <= 0x19) {
      result[v5] = v6 + 32;
    }
    ++v2;
  }
  if (v2 == 2)
  {
    int v7 = result[v3];
    if ((v7 - 97) <= 0x19) {
      result[v3] = v7 - 32;
    }
    int v8 = &result[v3];
    int v9 = v8[1];
    if ((v9 - 97) <= 0x19) {
      v8[1] = v9 - 32;
    }
  }
  if (result[v5] == 45) {
    ++i;
  }
  uint64_t v10 = &result[i];
  while (1)
  {
    int v11 = *v10;
    if (!*v10) {
      break;
    }
    do
    {
      if (v11 == 45) {
        break;
      }
      if ((v11 - 65) <= 0x19) {
        *uint64_t v10 = v11 + 32;
      }
      int v12 = *++v10;
      int v11 = v12;
    }
    while (v12);
    if (v11 == 45) {
      ++v10;
    }
  }
  return result;
}

uint64_t IIOReadPlugin::setupImageProviderCallbackV1(uint64_t a1, CFDictionaryRef *a2)
{
  uint64_t v3 = IIOReadPlugin::prepareGeometry(a1, a2);
  if (!v3) {
    IIOImagePlus::setImageBlockProc(*(IIOImagePlus **)(a1 + 16));
  }
  return v3;
}

uint64_t IIOImagePlus::getSourceGeomColorSpace(IIOImagePlus *this)
{
  return *((void *)this + 11);
}

uint64_t IIOReadPlugin::prepareGeometry(uint64_t a1, CFDictionaryRef *a2)
{
  uint64_t v58 = 0;
  long long v56 = 0u;
  long long v57 = 0u;
  long long v54 = 0u;
  long long v55 = 0u;
  memset(v53, 0, sizeof(v53));
  IIODictionary::IIODictionary((IIODictionary *)v53, *(__CFDictionary **)(a1 + 152));
  if (*(unsigned char *)(a1 + 348)) {
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 152), @"kImageIOInfoHeader_supportsMultipleResolutions", (const void *)*MEMORY[0x1E4F1CFD0]);
  }
  if (*(unsigned char *)(a1 + 350))
  {
    int v4 = (*(unsigned __int8 *)(a1 + 279) << 12) | (*(unsigned __int8 *)(a1 + 280) << 16) | ((*(unsigned char *)(a1 + 281) != 0) << 8) | *(unsigned __int8 *)(a1 + 278);
    if ((gIIODebugFlags & 0x30000) != 0)
    {
      int v5 = *(unsigned __int16 *)(a1 + 272);
      int v6 = IIO_BitmapInfoString(v4);
      ImageIOLog("   createImageProviderWithBitmapInfo[decodedGeo]: bpc=%d  '%08X' %s\n", v5, v4, v6);
    }
    IIONumber::IIONumber((IIONumber *)v52, v4);
    IIODictionary::setObjectForKey((uint64_t)v53, (uint64_t)v52, @"kImageIOInfoHeader_createImageProviderWithBitmapInfo");
    IIONumber::~IIONumber((IIONumber *)v52);
  }
  IIOReadPlugin::updateColorSpace(a1, a2);
  int v7 = *(unsigned __int16 *)(a1 + 244);
  int v8 = *(unsigned __int8 *)(a1 + 278);
  switch(CGColorSpaceGetModel(*(CGColorSpaceRef *)(a1 + 160)))
  {
    case kCGColorSpaceModelMonochrome:
      BOOL v11 = v8 == 0;
      int v12 = 1;
      goto LABEL_11;
    case kCGColorSpaceModelRGB:
    case kCGColorSpaceModelLab:
      BOOL v11 = v8 == 0;
      int v12 = 3;
      goto LABEL_11;
    case kCGColorSpaceModelCMYK:
      BOOL v11 = v8 == 0;
      int v12 = 4;
LABEL_11:
      if (!v11) {
        ++v12;
      }
      break;
    default:
      if (v8) {
        BOOL v33 = v7 == 0;
      }
      else {
        BOOL v33 = 1;
      }
      if (v33) {
        int v12 = v7;
      }
      else {
        int v12 = v7 + 1;
      }
      break;
  }
  int v13 = *(unsigned __int16 *)(a1 + 276);
  if (v13 == 3)
  {
    int v13 = 4;
    if (*(unsigned char *)(a1 + 278)) {
      *(_WORD *)(a1 + 276) = 4;
    }
  }
  unsigned int v14 = *(_DWORD *)(a1 + 236);
  int v15 = *(_DWORD *)(a1 + 228);
  if (!v14)
  {
    unsigned int v14 = v15 * v12 * ((*(unsigned __int16 *)(a1 + 240) + 7) >> 3);
    *(_DWORD *)(a1 + 236) = v14;
  }
  int v16 = *(_DWORD *)(a1 + 232);
  if (v15
    && v16
    && (unsigned int v17 = *(unsigned __int16 *)(a1 + 242), *(_WORD *)(a1 + 242))
    && (unsigned int v18 = *(unsigned __int16 *)(a1 + 240), *(_WORD *)(a1 + 240))
    && v14)
  {
    int v19 = *(unsigned __int16 *)(a1 + 244);
    if (!*(_WORD *)(a1 + 244))
    {
      int v19 = v17 / v18;
      *(_WORD *)(a1 + 244) = v17 / v18;
    }
    unsigned int v20 = *(_DWORD *)(a1 + 260);
    if (!v20)
    {
      *(_DWORD *)(a1 + 260) = v15;
      unsigned int v20 = v15;
    }
    unsigned int v21 = *(_DWORD *)(a1 + 264);
    if (!v21)
    {
      *(_DWORD *)(a1 + --*(void *)(result + 264) = v16;
      unsigned int v21 = v16;
    }
    unsigned int v22 = *(unsigned __int16 *)(a1 + 272);
    if (!*(_WORD *)(a1 + 272))
    {
      *(_WORD *)(a1 + 272) = v18;
      unsigned int v22 = v18;
    }
    unsigned int v23 = *(unsigned __int16 *)(a1 + 274);
    if (!*(_WORD *)(a1 + 274))
    {
      *(_WORD *)(a1 + 274) = v17;
      unsigned int v23 = v17;
    }
    if (!v13) {
      *(_WORD *)(a1 + 276) = v19;
    }
    int v24 = *(unsigned __int8 *)(a1 + 280);
    int v25 = *(unsigned __int8 *)(a1 + 278);
    if (!((*(unsigned __int8 *)(a1 + 279) << 12) | (v24 << 16) | ((*(unsigned char *)(a1 + 281) != 0) << 8) | v25))
    {
      int v26 = *(unsigned __int8 *)(a1 + 247);
      unsigned int v27 = (v26 << 12) | (*(unsigned __int8 *)(a1 + 248) << 16);
      BOOL v28 = *(unsigned char *)(a1 + 249) != 0;
      int v25 = *(unsigned char *)(a1 + 246) & 0x1F;
      *(unsigned char *)(a1 + 278) = v25;
      *(unsigned char *)(a1 + 279) = v26 & 7;
      int v24 = HIWORD(v27) & 0xF;
      *(unsigned char *)(a1 + 280) = v24;
      *(unsigned char *)(a1 + 281) = v28;
    }
    unsigned int v29 = (((v23 + 7) >> 3) * v20 + 3) & 0xFFFFFFFC;
    if (*(unsigned __int16 *)(a1 + 316) > 1u)
    {
      unsigned int v30 = *(_DWORD *)(a1 + 268);
      if (v30 < v29)
      {
        if (v29 <= v14) {
          unsigned int v30 = v14;
        }
        else {
          unsigned int v30 = (((v23 + 7) >> 3) * v20 + 3) & 0xFFFFFFFC;
        }
        *(_DWORD *)(a1 + 268) = v30;
      }
    }
    else if (*(unsigned char *)(a1 + 349))
    {
      *(_DWORD *)(a1 + 268) = v14;
      unsigned int v30 = v14;
    }
    else
    {
      unsigned int v30 = *(_DWORD *)(a1 + 268);
      if (v30 < v29)
      {
        *(_DWORD *)(a1 + 268) = v29;
        unsigned int v30 = (((v23 + 7) >> 3) * v20 + 3) & 0xFFFFFFFC;
      }
    }
    *(void *)&long long v54 = v20;
    *((void *)&v54 + 1) = v21;
    *(void *)&long long v55 = v22;
    *((void *)&v55 + 1) = v23;
    *(void *)&long long v56 = v30;
    DWORD2(v56) = *(_DWORD *)(a1 + 324);
    *(void *)&long long v57 = *(void *)(a1 + 160);
    DWORD2(v57) = *(_DWORD *)(a1 + 176);
    HIDWORD(v57) = v25;
    LODWORD(v58) = v24 << 16;
    v9.i32[0] = *(_DWORD *)(a1 + 344);
    int16x4_t v34 = (int16x4_t)vmovl_u8(v9).u64[0];
    v10.i32[0] = vrev32_s16(v34).u32[0];
    v10.i32[1] = v34.i32[1];
    HIDWORD(v58) = vmovn_s16(v10).u32[0];
    if (!v19) {
      *(_WORD *)(a1 + 244) = v17 / v18;
    }
    uint64_t v35 = *(void *)(a1 + 16);
    if (v35)
    {
      IIOImagePlus::setReadPlugin(v35, (_DWORD *)a1);
      uint64_t v36 = *(void *)(a1 + 16);
      v50[2] = v56;
      v50[3] = v57;
      uint64_t v51 = v58;
      v50[0] = v54;
      v50[1] = v55;
      IIOImagePlus::setGeometry(v36, (CFTypeRef *)a2, (uint64_t)v50);
      if ((gIIODebugFlags & 0x30000) != 0)
      {
        int v37 = *(_DWORD *)(a1 + 204);
        unsigned int v38 = v37 >> 24;
        uint64_t v39 = MEMORY[0x1E4F14390];
        if (v37 < 0)
        {
          int v40 = __maskrune(v38, 0x40000uLL);
          int v37 = *(_DWORD *)(a1 + 204);
        }
        else
        {
          int v40 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v38 + 60) & 0x40000;
        }
        if (v40) {
          uint64_t v41 = (v37 >> 24);
        }
        else {
          uint64_t v41 = 46;
        }
        unsigned int v42 = v37 << 8 >> 24;
        if (v37 << 8 < 0)
        {
          int v43 = __maskrune(v42, 0x40000uLL);
          int v37 = *(_DWORD *)(a1 + 204);
        }
        else
        {
          int v43 = *(_DWORD *)(v39 + 4 * v42 + 60) & 0x40000;
        }
        if (v43) {
          uint64_t v44 = (v37 << 8 >> 24);
        }
        else {
          uint64_t v44 = 46;
        }
        unsigned int v45 = (__int16)v37 >> 8;
        if (v37 << 16 < 0)
        {
          int v46 = __maskrune(v45, 0x40000uLL);
          int v37 = *(_DWORD *)(a1 + 204);
        }
        else
        {
          int v46 = *(_DWORD *)(v39 + 4 * v45 + 60) & 0x40000;
        }
        if (v46) {
          uint64_t v47 = ((__int16)v37 >> 8);
        }
        else {
          uint64_t v47 = 46;
        }
        if ((v37 << 24) <= 0x7F000000) {
          int v48 = *(_DWORD *)(v39 + 4 * (char)v37 + 60) & 0x40000;
        }
        else {
          int v48 = __maskrune((char)v37, 0x40000uLL);
        }
        if (v48) {
          uint64_t v49 = *(char *)(a1 + 204);
        }
        else {
          uint64_t v49 = 46;
        }
        ImageIOLog("  '%c%c%c%c' IIOReadPlugin::prepareGeometry\n", v41, v44, v47, v49);
        IIOReadPlugin::debugGeometry(a1, &v54, (IIODictionary *)v53);
      }
    }
    uint64_t v31 = 0;
  }
  else
  {
    _cg_jpeg_mem_term("prepareGeometry", 1010, "*** input-size: %d x %d   rb: %d    bpp: %d      bpc: %d\n", v15, v16, v14, *(unsigned __int16 *)(a1 + 242), *(unsigned __int16 *)(a1 + 240));
    uint64_t v31 = 4294967246;
  }
  IIODictionary::~IIODictionary((IIODictionary *)v53);
  return v31;
}

void sub_1885AA260(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,char a25,uint64_t a26,uint64_t a27,char a28)
{
}

void IIONumber::IIONumber(IIONumber *this, int a2)
{
  int valuePtr = a2;
  *(void *)this = &unk_1ED4E5FD8;
  *((void *)this + 1) = 3;
  *((void *)this + 2) = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberSInt32Type, &valuePtr);
}

{
  int valuePtr;

  int valuePtr = a2;
  *(void *)this = &unk_1ED4E5FD8;
  *((void *)this + 1) = 9;
  *((void *)this + 2) = 0;
  *((void *)this + 2) = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberIntType, &valuePtr);
}

uint64_t IIOReadPlugin::updateColorSpace(uint64_t a1, CFDictionaryRef *a2)
{
  if (*(unsigned char *)(a1 + 352))
  {
    if ((gIIODebugFlags & 0x300000) != 0) {
      ImageIOLog("  _colorSpaceIsFlexGTCProxy - now creating a FlexGTC colorspace...\n");
    }
    memset(value, 0, sizeof(value));
    IIODictionary::IIODictionary((IIODictionary *)value);
    IIODictionary::setObjectForKey((IIODictionary *)value, *(const void **)(a1 + 160), @"kCGFlexRangeAlternateColorSpace");
    if (IIODictionary::containsKeyGroup(*(IIODictionary **)(a1 + 48), @"kCGTargetHeadroom", @"kCGImageSourceDecodeRequestOptions"))
    {
      double FloatForKeyGroup = IIODictionary::getFloatForKeyGroup(*(IIODictionary **)(a1 + 48), @"kCGTargetHeadroom", @"kCGImageSourceDecodeRequestOptions");
      IIONumber::IIONumber((IIONumber *)v9, *(float *)&FloatForKeyGroup);
      IIODictionary::setObjectForKey((IIODictionary *)value, v10, @"kCGTargetHeadroom");
      IIONumber::~IIONumber((IIONumber *)v9);
    }
    if (IIODictionary::containsKeyGroup(*(IIODictionary **)(a1 + 48), @"kCGDisableMetal", @"kCGImageSourceDecodeRequestOptions"))
    {
      int BoolForKeyGroup = IIODictionary::getBoolForKeyGroup(*(IIODictionary **)(a1 + 48), @"kCGDisableMetal", @"kCGImageSourceDecodeRequestOptions");
      IIONumber::IIONumber((IIONumber *)v9, BoolForKeyGroup);
      IIODictionary::setObjectForKey((IIODictionary *)value, v10, @"kCGDisableMetal");
      IIONumber::~IIONumber((IIONumber *)v9);
    }
    if (*(void *)(a1 + 168)
      || !(*(unsigned int (**)(uint64_t, void **, uint64_t))(*(void *)a1 + 176))(a1, value, a1 + 168))
    {
      uint64_t CopyWithFlexGTCInfo = IIO_ColorSpaceCreateCopyWithFlexGTCInfo();
      CGColorSpaceRelease(*(CGColorSpaceRef *)(a1 + 160));
      *(void *)(a1 + 160) = CopyWithFlexGTCInfo;
      v9[0] = 0;
      CGColorSpaceGetHeadroomInfo();
      *(float *)(a1 + 332) = v7;
      if ((gIIODebugFlags & 0x300000) != 0) {
        ImageIOLog("  updateColorSpace: - FlexGTC colorspace - headroom: %g\n", v7);
      }
    }
    else
    {
      CGColorSpaceRelease(*(CGColorSpaceRef *)(a1 + 160));
      *(void *)(a1 + 160) = 0;
    }
    IIODictionary::~IIODictionary((IIODictionary *)value);
  }
  if (!*(void *)(a1 + 160))
  {
    value[0] = 0;
    if (a2)
    {
      CFDictionaryGetValueIfPresent(*a2, @"TEMP_COLORSPACE", (const void **)value);
      if (value[0]) {
        *(void *)(a1 + 160) = CGColorSpaceCreateWithPropertyList(value[0]);
      }
    }
  }
  return 0;
}

void sub_1885AA520(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va1, a3);
  va_start(va, a3);
  uint64_t v4 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  IIONumber::~IIONumber((IIONumber *)va);
  IIODictionary::~IIODictionary((IIODictionary *)va1);
  _Unwind_Resume(a1);
}

uint64_t IIOImagePlus::setReadPlugin(uint64_t this, _DWORD *a2)
{
  *(void *)(this + 168) = a2;
  if (a2) {
    *(_DWORD *)(this + 176) = a2[51];
  }
  return this;
}

void IIOImagePlus::setGeometry(uint64_t a1, CFTypeRef *a2, uint64_t a3)
{
  uint64_t v77 = *MEMORY[0x1E4F143B8];
  if (a2)
  {
    CFDictionaryRef v4 = (const __CFDictionary *)*a2;
    if (!*a2 || (CFTypeID v7 = CFGetTypeID(*a2), v7 != CFDictionaryGetTypeID()))
    {
      LogFault("setGeometry", 745, "*** ERROR: ImageIO 'CGImagePlusSetGeometry' header is not a CFDictionary...\n");
      exit(0);
    }
    *(void *)(a1 + 160) = a2;
    pthread_mutex_lock(&ipGeomLock);
    int v8 = (_OWORD *)(a1 + 40);
    uint8x8_t v9 = *(CGColorSpace **)(a1 + 88);
    if (v9) {
      CGColorSpaceRelease(v9);
    }
    pthread_mutex_unlock(&ipGeomLock);
    _OWORD *v8 = 0u;
    *(_OWORD *)(a1 + 56) = 0u;
    *(_OWORD *)(a1 + 72) = 0u;
    *(_OWORD *)(a1 + 88) = 0u;
    *(void *)(a1 + 104) = 0;
    if ((unint64_t)(*(void *)a3 - 1) < 0xF4240 && (unint64_t)(*(void *)(a3 + 8) - 1) < 0xF4240)
    {
      unint64_t v10 = *(void *)(a3 + 16);
      if (v10 - 1 <= 0x1F)
      {
        unint64_t v11 = *(void *)(a3 + 24);
        if (v11 >= v10 && v11 - 641 >= 0xFFFFFFFFFFFFFD80)
        {
          unint64_t v12 = v11 * *(void *)a3 + 7;
          unint64_t v13 = v12 >> 3;
          unint64_t v14 = *(void *)(a3 + 32);
          if (!v14)
          {
            unint64_t v14 = ImageIOAlignRowBytes(v12 >> 3, 0x10uLL);
            *(void *)(a3 + 32) = v14;
          }
          if (v14 > 0x4C4B400)
          {
            _cg_jpeg_mem_term("setGeometry", 778, "*** geom.bytesPerRow > maxRB  %d > %d\n");
            return;
          }
          if (v14 < v13)
          {
            _cg_jpeg_mem_term("setGeometry", 783, "*** geom.bytesPerRow < minRB  %d < %d\n");
            return;
          }
          if (is_mul_ok(*(void *)(a3 + 8), v14))
          {
            pthread_mutex_lock(&ipGeomLock);
            _OWORD *v8 = *(_OWORD *)a3;
            long long v16 = *(_OWORD *)(a3 + 32);
            long long v15 = *(_OWORD *)(a3 + 48);
            long long v17 = *(_OWORD *)(a3 + 16);
            *(void *)(a1 + 104) = *(void *)(a3 + 64);
            *(_OWORD *)(a1 + 72) = v16;
            *(_OWORD *)(a1 + 88) = v15;
            *(_OWORD *)(a1 + 56) = v17;
            pthread_mutex_unlock(&ipGeomLock);
            unsigned int v18 = *(CGColorSpace **)(a3 + 48);
            if (v18)
            {
              int Type = CGColorSpaceGetType();
              CGColorSpaceModel Model = CGColorSpaceGetModel(v18);
              if (Type == 7)
              {
                BaseColorSpace = CGColorSpaceGetBaseColorSpace(v18);
                int Type = CGColorSpaceGetType();
                CGColorSpaceModel v22 = CGColorSpaceGetModel(BaseColorSpace);
                IIODictionary::setObjectForKey(*(IIODictionary **)(a1 + 112), (const void *)*MEMORY[0x1E4F1CFD0], @"IsIndexed");
              }
              else
              {
                CGColorSpaceModel v22 = Model;
              }
              if (Type == 10 || Type == 6)
              {
                unsigned int v23 = (const void *)CGColorSpaceCopyICCProfileDescription();
                IIODictionary::setObjectForKey(*(IIODictionary **)(a1 + 112), v23, @"ProfileName");
                if (v23) {
                  CFRelease(v23);
                }
              }
              if (v22 > kCGColorSpaceModelXYZ) {
                unsigned int v24 = 0;
              }
              else {
                unsigned int v24 = *(_DWORD *)&aYargBgrkymcBal[4 * v22];
              }
              int v25 = *(_DWORD *)(a3 + 40);
              if (!v25)
              {
                *(_DWORD *)(a3 + 40) = v24;
                int v25 = v24;
              }
              if (v24 != v25)
              {
                uint64_t v26 = MEMORY[0x1E4F14390];
                uint64_t v27 = MEMORY[0x1E4F14390] + 60;
                if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 60 + 4 * HIBYTE(v24)) & 0x40000) != 0) {
                  uint64_t v28 = HIBYTE(v24);
                }
                else {
                  uint64_t v28 = 46;
                }
                unsigned int v29 = HIWORD(v24) & 0x7F;
                if ((*(_DWORD *)(v27 + 4 * v29) & 0x40000) != 0) {
                  uint64_t v30 = v29;
                }
                else {
                  uint64_t v30 = 46;
                }
                unsigned int v31 = (v24 >> 8) & 0x7B;
                if ((*(_DWORD *)(v27 + 4 * v31) & 0x40000) != 0) {
                  uint64_t v32 = v31;
                }
                else {
                  uint64_t v32 = 46;
                }
                LODWORD(v33) = v24 & 0x7B;
                if ((*(_DWORD *)(v27 + 4 * v33) & 0x40000) != 0) {
                  uint64_t v33 = v33;
                }
                else {
                  uint64_t v33 = 46;
                }
                uint64_t v68 = v33;
                unsigned int v34 = v25 >> 24;
                if (v25 < 0)
                {
                  int v35 = __maskrune(v34, 0x40000uLL);
                  int v25 = *(_DWORD *)(a3 + 40);
                }
                else
                {
                  int v35 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v34 + 60) & 0x40000;
                }
                if (v35) {
                  uint64_t v36 = (v25 >> 24);
                }
                else {
                  uint64_t v36 = 46;
                }
                unsigned int v37 = v25 << 8 >> 24;
                if (v25 << 8 < 0)
                {
                  int v38 = __maskrune(v37, 0x40000uLL);
                  int v25 = *(_DWORD *)(a3 + 40);
                }
                else
                {
                  int v38 = *(_DWORD *)(v26 + 4 * v37 + 60) & 0x40000;
                }
                if (v38) {
                  uint64_t v39 = (v25 << 8 >> 24);
                }
                else {
                  uint64_t v39 = 46;
                }
                unsigned int v40 = (__int16)v25 >> 8;
                if (v25 << 16 < 0)
                {
                  int v41 = __maskrune(v40, 0x40000uLL);
                  int v25 = *(_DWORD *)(a3 + 40);
                }
                else
                {
                  int v41 = *(_DWORD *)(v26 + 4 * v40 + 60) & 0x40000;
                }
                if (v41) {
                  uint64_t v42 = ((__int16)v25 >> 8);
                }
                else {
                  uint64_t v42 = 46;
                }
                if ((v25 << 24) <= 0x7F000000) {
                  int v43 = *(_DWORD *)(v26 + 4 * (char)v25 + 60) & 0x40000;
                }
                else {
                  int v43 = __maskrune((char)v25, 0x40000uLL);
                }
                if (v43) {
                  int v44 = *(_DWORD *)(a3 + 40);
                }
                else {
                  LOBYTE(v44) = 46;
                }
                _cg_jpeg_mem_term("setGeometry", 846, "embedded profile '%c%c%c%c' does not match expected color model '%c%c%c%c'\n", v28, v30, v32, v68, v36, v39, v42, (char)v44);
                *(void *)(a3 + 48) = 0;
              }
            }
            if ((gIIODebugFlags & 0x8000300000) == 0)
            {
LABEL_95:
              int v58 = *(_DWORD *)(a3 + 40);
              if (v58 <= 1281450527)
              {
                if (v58 == 1129142603) {
                  goto LABEL_103;
                }
                int v59 = 1196573017;
              }
              else
              {
                if (v58 == 1281450528 || v58 == 1380401696) {
                  goto LABEL_103;
                }
                int v59 = 1482250784;
              }
              if (v58 != v59)
              {
                LogError("setGeometry", 859, "*** ERROR: image is not of a supported color model (%d)\n", *(_DWORD *)(a3 + 40));
                int v58 = *(_DWORD *)(a3 + 40);
              }
LABEL_103:
              if (v58 > 1281450527)
              {
                if (v58 == 1281450528)
                {
                  unsigned int v60 = (const void **)&kCGImagePropertyColorModelLab;
                }
                else
                {
                  if (v58 != 1380401696) {
                    goto LABEL_113;
                  }
                  unsigned int v60 = (const void **)&kCGImagePropertyColorModelRGB;
                }
              }
              else if (v58 == 1129142603)
              {
                unsigned int v60 = (const void **)&kCGImagePropertyColorModelCMYK;
              }
              else
              {
                if (v58 != 1196573017) {
                  goto LABEL_113;
                }
                unsigned int v60 = (const void **)&kCGImagePropertyColorModelGray;
              }
              IIODictionary::setObjectForKey(*(IIODictionary **)(a1 + 112), *v60, @"ColorModel");
LABEL_113:
              int v61 = *(const void **)(a3 + 48);
              if (v61)
              {
                Lab = (void *)CFRetain(v61);
LABEL_115:
                int v63 = Lab;
                goto LABEL_116;
              }
              int v63 = 0;
              int v67 = *(_DWORD *)(a3 + 40);
              if (v67 > 1281450527)
              {
                if (v67 == 1281450528)
                {
                  *(_OWORD *)whitePoint = xmmword_18898F9F0;
                  uint64_t v76 = 0x3FEA6594AF4F0D84;
                  memset(blackPoint, 0, sizeof(blackPoint));
                  *(_OWORD *)range = xmmword_18898FA08;
                  long long v73 = unk_18898FA18;
                  Lab = CGColorSpaceCreateLab(whitePoint, blackPoint, range);
                  goto LABEL_115;
                }
                if (v67 == 1380401696)
                {
                  Lab = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E4F1DC98]);
                  goto LABEL_115;
                }
              }
              else
              {
                if (v67 == 1129142603)
                {
                  Lab = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E4F1DBF0]);
                  goto LABEL_115;
                }
                if (v67 == 1196573017)
                {
                  Lab = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E4F1DC00]);
                  goto LABEL_115;
                }
              }
LABEL_116:
              pthread_mutex_lock(&ipGeomLock);
              *(void *)(a1 + 88) = v63;
              if (*(unsigned char *)(a1 + 180) && !CFDictionaryContainsValue(v4, @"kIsAdobeRGB")) {
                *(unsigned char *)(a1 + 180) = 0;
              }
              pthread_mutex_unlock(&ipGeomLock);
              uint64_t v64 = *(void *)(a1 + 112);
              IIONumber::IIONumber((IIONumber *)v71, *(void *)a3);
              IIODictionary::setObjectForKey(v64, (uint64_t)v71, @"PixelWidth");
              IIONumber::~IIONumber((IIONumber *)v71);
              uint64_t v65 = *(void *)(a1 + 112);
              IIONumber::IIONumber((IIONumber *)v70, *(void *)(a3 + 8));
              IIODictionary::setObjectForKey(v65, (uint64_t)v70, @"PixelHeight");
              IIONumber::~IIONumber((IIONumber *)v70);
              if ((IIODictionary::containsKey(*(IIODictionary **)(a1 + 112), @"Depth") & 1) == 0)
              {
                uint64_t v66 = *(void *)(a1 + 112);
                IIONumber::IIONumber((IIONumber *)v69, *(void *)(a3 + 16));
                IIODictionary::setObjectForKey(v66, (uint64_t)v69, @"Depth");
                IIONumber::~IIONumber((IIONumber *)v69);
              }
              if ((*(_DWORD *)(a3 + 60) & 0x1Fu) > 6 || ((1 << (*(_DWORD *)(a3 + 60) & 0x1F)) & 0x61) == 0) {
                IIODictionary::setObjectForKey(*(IIODictionary **)(a1 + 112), (const void *)*MEMORY[0x1E4F1CFD0], @"HasAlpha");
              }
              if (*(unsigned char *)(a3 + 68)) {
                IIODictionary::setObjectForKey(*(IIODictionary **)(a1 + 112), (const void *)*MEMORY[0x1E4F1CFD0], @"IsFloat");
              }
              if (*(_DWORD *)(a1 + 136) != -6) {
                *(_DWORD *)(a1 + 136) = -1;
              }
              return;
            }
            int v45 = *(_DWORD *)(a1 + 176);
            unsigned int v46 = v45 >> 24;
            if (v45 < 0)
            {
              int v47 = __maskrune(v46, 0x40000uLL);
              int v45 = *(_DWORD *)(a1 + 176);
            }
            else
            {
              int v47 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v46 + 60) & 0x40000;
            }
            if (v47) {
              uint64_t v48 = (v45 >> 24);
            }
            else {
              uint64_t v48 = 46;
            }
            unsigned int v49 = v45 << 8 >> 24;
            if (v45 << 8 < 0)
            {
              int v50 = __maskrune(v49, 0x40000uLL);
              int v45 = *(_DWORD *)(a1 + 176);
            }
            else
            {
              int v50 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v49 + 60) & 0x40000;
            }
            if (v50) {
              uint64_t v51 = (v45 << 8 >> 24);
            }
            else {
              uint64_t v51 = 46;
            }
            unsigned int v52 = (__int16)v45 >> 8;
            if (v45 << 16 < 0)
            {
              int v53 = __maskrune(v52, 0x40000uLL);
              int v45 = *(_DWORD *)(a1 + 176);
            }
            else
            {
              int v53 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v52 + 60) & 0x40000;
            }
            if (v53) {
              uint64_t v54 = ((__int16)v45 >> 8);
            }
            else {
              uint64_t v54 = 46;
            }
            if ((v45 << 24) <= 0x7F000000)
            {
              if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * (char)v45 + 60) & 0x40000) != 0) {
                goto LABEL_91;
              }
            }
            else if (__maskrune((char)v45, 0x40000uLL))
            {
LABEL_91:
              int v55 = *(_DWORD *)(a1 + 176);
LABEL_94:
              CFStringRef Name = CGColorSpaceGetName(*(CGColorSpaceRef *)(a3 + 48));
              IIOString::IIOString((IIOString *)range, Name);
              long long v57 = (const char *)IIOString::utf8String((IIOString *)range);
              ImageIOLog("COL setGeometry - '%c%c%c%c' using colorSpace: '%s'\n", v48, v51, v54, (char)v55, v57);
              IIOString::~IIOString((IIOString *)range);
              goto LABEL_95;
            }
            LOBYTE(v55) = 46;
            goto LABEL_94;
          }
        }
      }
    }
  }
}

void sub_1885AAE8C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  va_start(va, a10);
  IIONumber::~IIONumber((IIONumber *)va);
  _Unwind_Resume(a1);
}

void IIOImagePlus::setImageBlockProc(IIOImagePlus *a1)
{
}

void sub_1885AB578(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va1, a3);
  va_start(va, a3);
  uint64_t v5 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  IIONumber::~IIONumber((IIONumber *)va);
  IIODictionary::~IIODictionary((IIODictionary *)va1);
  IIODictionary::~IIODictionary((IIODictionary *)(v3 - 104));
  _Unwind_Resume(a1);
}

void IIONumber::~IIONumber(IIONumber *this)
{
  *(void *)this = &unk_1ED4E5FD8;
  int v1 = (const void *)*((void *)this + 2);
  if (v1) {
    CFRelease(v1);
  }
}

{
  uint64_t vars8;

  IIONumber::~IIONumber(this);

  JUMPOUT(0x18C11C0E0);
}

void IIODictionary::setObjectForKey(uint64_t a1, uint64_t a2, const void *a3)
{
  if (a3)
  {
    uint64_t v3 = *(__CFDictionary **)(a1 + 8);
    if (v3) {
      CFDictionarySetValue(v3, a3, *(const void **)(a2 + 16));
    }
  }
}

void IIONumber::IIONumber(IIONumber *this, uint64_t a2)
{
  uint64_t valuePtr = a2;
  *(void *)this = &unk_1ED4E5FD8;
  *((void *)this + 1) = 10;
  *((void *)this + 2) = 0;
  *((void *)this + 2) = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberLongType, &valuePtr);
}

{
  uint64_t valuePtr;

  uint64_t valuePtr = a2;
  *(void *)this = &unk_1ED4E5FD8;
  *((void *)this + 1) = 4;
  *((void *)this + 2) = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberSInt64Type, &valuePtr);
}

void IIODictionary::setObjectForKey(IIODictionary *this, const void *value, const __CFString *key)
{
  if (key)
  {
    uint64_t v3 = (__CFDictionary *)*((void *)this + 1);
    if (v3)
    {
      if (value) {
        CFDictionarySetValue(v3, key, value);
      }
      else {
        CFDictionaryRemoveValue(v3, key);
      }
    }
  }
}

uint64_t IIOImagePlus::releaseImageProvider(IIOImagePlus *this)
{
  uint64_t v2 = *((void *)this + 18);
  uint64_t v3 = *MEMORY[0x1E4F1D260];
  if (v2) {
    BOOL v4 = v2 == v3;
  }
  else {
    BOOL v4 = 1;
  }
  if (!v4)
  {
    atomic_fetch_add_explicit(&gImageProviderCount, 0xFFFFFFFFFFFFFFFFLL, memory_order_relaxed);
    CGImageProviderRelease();
  }
  uint64_t result = *((void *)this + 19);
  if (result) {
    BOOL v6 = result == v3;
  }
  else {
    BOOL v6 = 1;
  }
  if (!v6)
  {
    atomic_fetch_add_explicit(&gImageProviderCount, 0xFFFFFFFFFFFFFFFFLL, memory_order_relaxed);
    uint64_t result = CGImageProviderRelease();
  }
  *((unsigned char *)this + 192) &= ~0x40u;
  *((void *)this + 18) = 0;
  *((void *)this + 19) = 0;
  return result;
}

uint64_t IIOImageProviderInfo::IIOImageProviderInfo(uint64_t a1, uint64_t a2, uint64_t a3, const void *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  *(void *)a1 = &unk_1ED4E4FB8;
  *(_OWORD *)(a1 + 32) = *(_OWORD *)(a2 + 40);
  long long v15 = *(_OWORD *)(a2 + 56);
  long long v16 = *(_OWORD *)(a2 + 88);
  uint64_t v17 = *(void *)(a2 + 104);
  *(_OWORD *)(a1 + 64) = *(_OWORD *)(a2 + 72);
  *(_OWORD *)(a1 + 80) = v16;
  *(_OWORD *)(a1 + 48) = v15;
  *(void *)(a1 + 24) = a2;
  *(void *)(a1 + 96) = v17;
  *(void *)(a1 + 104) = 0;
  *(_OWORD *)(a1 + 112) = *(_OWORD *)(a2 + 160);
  *(_DWORD *)(a1 + 128) = *(_DWORD *)(a2 + 176);
  pthread_mutex_init((pthread_mutex_t *)(a1 + 144), 0);
  *(void *)(a1 + 136) = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  switch((int)a4)
  {
    case 0:
      return a1;
    case 1:
      *(_DWORD *)(a1 + 208) = 1;
      *(void *)(a1 + 216) = a5;
      *(void *)(a1 + 224) = a9;
      break;
    case 2:
      *(_DWORD *)(a1 + 208) = 2;
      *(void *)(a1 + 216) = a5;
      *(void *)(a1 + 224) = a6;
      *(void *)(a1 + 232) = a9;
      break;
    case 3:
      *(_DWORD *)(a1 + 208) = 3;
      *(void *)(a1 + 216) = a5;
      *(void *)(a1 + 224) = a6;
      *(void *)(a1 + 232) = a7;
      *(void *)(a1 + 240) = a8;
      *(void *)(a1 + 248) = a9;
      break;
    default:
      _cg_jpeg_mem_term("IIOImageProviderInfo", 1680, "*** unknown version number - %d [%p]\n", a4, a4);
      CFShow(@"unknown image provider version number");
      break;
  }
  return a1;
}

const void *IIOImagePlus::createSourceImageProvider(uint64_t a1, int a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  uint64_t v7 = *a4;
  if (*(_DWORD *)(*a4 + 208) >= 4u) {
    _cg_jpeg_mem_term("createSourceImageProvider", 977, "*** unknown callbackVersion - %d\n", *(_DWORD *)(v7 + 208));
  }
  if ((gIIODebugFlags & 0x20000) != 0) {
    ImageIOLog("  CGImageProviderCreate: %dx%d  compType: %d\n", *(void *)(a1 + 40), *(void *)(a1 + 48), a2);
  }
  uint64_t v8 = (const void *)CGImageProviderCreate();
  if (!v8) {
    _cg_jpeg_mem_term("createSourceImageProvider", 992, "*** CGImageProviderCreate returned NULL\n");
  }
  uint64_t v9 = ~*(void *)(a1 + 16);
  uint64_t Source = (IIOImageSource *)CGImageSourceGetSource(v9);
  if (Source && IIOImageSource::isRAWFile(Source))
  {
    CGImageProviderSetProperty();
    IIONumber::IIONumber((IIONumber *)__str, 64);
    CGImageProviderSetProperty();
    IIONumber::~IIONumber((IIONumber *)__str);
  }
  if ((gIIODebugFlags & 0xC000) != 0)
  {
    *(_OWORD *)__str = 0u;
    long long v13 = 0u;
    snprintf(__str, 0x20uLL, "(%p)", v8);
    if ((unsigned __int16)gIIODebugFlags >> 14) {
      ImageIODebugOptions((unsigned __int16)gIIODebugFlags >> 14, "S", "CGImageProviderCreate", (CFTypeRef)v9, __str, -1, 0);
    }
  }
  atomic_fetch_add_explicit(&gImageProviderCount, 1uLL, memory_order_relaxed);
  *(void *)(v7 + 16) = v8;
  *(void *)(a1 + 240) = a4;
  *(void *)(a1 + 144) = v8;
  if (*(unsigned char *)(a1 + 180))
  {
    uint64_t v8 = (const void *)CGImageProviderCreate();
    if ((unsigned __int16)gIIODebugFlags >> 14) {
      ImageIODebugOptions((unsigned __int16)gIIODebugFlags >> 14, "S", "CGImageProviderCreate", v8, 0, -1, 0);
    }
    *(void *)(a1 + 152) = v8;
  }
  return v8;
}

void sub_1885ABD40(_Unwind_Exception *a1)
{
  IIONumber::~IIONumber((IIONumber *)(v1 - 128));
  _Unwind_Resume(a1);
}

uint64_t IIOReadPlugin::callInitialize(IIOReadPlugin *this)
{
  CFDictionaryRef v124 = 0;
  uint64_t v125 = 0;
  uint64_t v126 = 0;
  IIODictionary::IIODictionary((IIODictionary *)&v124);
  memset(v123, 0, sizeof(v123));
  IIODictionary::IIODictionary((IIODictionary *)v123);
  int v2 = *((_DWORD *)this + 51);
  *((void *)this + 19) = v125;
  if ((gIIODebugFlags & 0x30000) != 0)
  {
    unsigned int v3 = v2 >> 24;
    uint64_t v4 = MEMORY[0x1E4F14390];
    if (v2 < 0) {
      int v5 = __maskrune(v2 >> 24, 0x40000uLL);
    }
    else {
      int v5 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v3 + 60) & 0x40000;
    }
    if (v5) {
      uint64_t v6 = v3;
    }
    else {
      uint64_t v6 = 46;
    }
    unsigned int v7 = v2 << 8 >> 24;
    if (v2 << 8 < 0) {
      int v8 = __maskrune(v2 << 8 >> 24, 0x40000uLL);
    }
    else {
      int v8 = *(_DWORD *)(v4 + 4 * v7 + 60) & 0x40000;
    }
    if (v8) {
      uint64_t v9 = v7;
    }
    else {
      uint64_t v9 = 46;
    }
    unsigned int v10 = (__int16)v2 >> 8;
    if (v2 << 16 < 0) {
      int v11 = __maskrune((__int16)v2 >> 8, 0x40000uLL);
    }
    else {
      int v11 = *(_DWORD *)(v4 + 4 * v10 + 60) & 0x40000;
    }
    if ((v2 << 24) <= 0x7F000000) {
      int v12 = *(_DWORD *)(v4 + 4 * (char)v2 + 60) & 0x40000;
    }
    else {
      int v12 = __maskrune((char)v2, 0x40000uLL);
    }
    if (v11) {
      uint64_t v13 = v10;
    }
    else {
      uint64_t v13 = 46;
    }
    if (v12) {
      uint64_t v14 = (char)v2;
    }
    else {
      uint64_t v14 = 46;
    }
    ImageIOLog("    callInitialize '%c%c%c%c' - [0x%x]\n", v6, v9, v13, v14, this);
  }
  uint64_t v15 = (*(uint64_t (**)(IIOReadPlugin *, void *))(*(void *)this + 96))(this, v123);
  uint64_t v16 = v15;
  if (v15)
  {
    if (v15 != -49) {
      goto LABEL_141;
    }
    int Uint32ForKey = IIODictionary::getUint32ForKey((IIODictionary *)v123, @"NEW_PLUGIN_ostype");
    unsigned int v115 = IIODictionary::getUint32ForKey((IIODictionary *)v123, @"NEW_PLUGIN_dataOffset");
    if (v115) {
      int Size = IIODictionary::getUint32ForKey((IIODictionary *)v123, @"NEW_PLUGIN_dataSize");
    }
    else {
      int Size = IIOImageReadSession::getSize(*((IIOImageReadSession **)this + 3));
    }
    unsigned int v18 = v2 >> 24;
    if (v2 < 0) {
      int v19 = __maskrune(v18, 0x40000uLL);
    }
    else {
      int v19 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v18 + 60) & 0x40000;
    }
    unsigned int v114 = v2 >> 24;
    if (v19) {
      uint64_t v20 = (v2 >> 24);
    }
    else {
      uint64_t v20 = 46;
    }
    uint64_t v118 = v20;
    unsigned int v21 = v2 << 8 >> 24;
    int v110 = v2 << 8;
    if (v2 << 8 < 0) {
      int v22 = __maskrune(v21, 0x40000uLL);
    }
    else {
      int v22 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v21 + 60) & 0x40000;
    }
    unsigned int v113 = v2 << 8 >> 24;
    if (v22) {
      uint64_t v23 = (v2 << 8 >> 24);
    }
    else {
      uint64_t v23 = 46;
    }
    uint64_t v117 = v23;
    unsigned int v24 = (__int16)v2 >> 8;
    int v109 = v2 << 16;
    if (v2 << 16 < 0)
    {
      int v26 = __maskrune(v24, 0x40000uLL);
      unsigned int v25 = (__int16)v2 >> 8;
    }
    else
    {
      unsigned int v25 = (__int16)v2 >> 8;
      int v26 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v24 + 60) & 0x40000;
    }
    unsigned int v112 = v25;
    if (v26) {
      uint64_t v27 = v25;
    }
    else {
      uint64_t v27 = 46;
    }
    unint64_t v116 = (IIOImageReadSession *)v27;
    unsigned int v28 = (char)v2;
    unsigned int v108 = v2 << 24;
    if ((v2 << 24) <= 0x7F000000)
    {
      int v29 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * (char)v2 + 60) & 0x40000;
    }
    else
    {
      int v29 = __maskrune((char)v2, 0x40000uLL);
      unsigned int v28 = (char)v2;
    }
    unsigned int v111 = v28;
    if (v29) {
      uint64_t v30 = v28;
    }
    else {
      uint64_t v30 = 46;
    }
    unsigned int v31 = Uint32ForKey >> 24;
    if (Uint32ForKey < 0) {
      int v32 = __maskrune(Uint32ForKey >> 24, 0x40000uLL);
    }
    else {
      int v32 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v31 + 60) & 0x40000;
    }
    if (v32) {
      uint64_t v33 = v31;
    }
    else {
      uint64_t v33 = 46;
    }
    LODWORD(v34) = Uint32ForKey << 8 >> 24;
    int v107 = Uint32ForKey << 8;
    if (Uint32ForKey << 8 < 0) {
      int v35 = __maskrune(Uint32ForKey << 8 >> 24, 0x40000uLL);
    }
    else {
      int v35 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v34 + 60) & 0x40000;
    }
    if (v35) {
      uint64_t v36 = v34;
    }
    else {
      uint64_t v36 = 46;
    }
    unsigned int v37 = (__int16)Uint32ForKey >> 8;
    int v106 = Uint32ForKey << 16;
    unsigned int v121 = v37;
    if (Uint32ForKey << 16 < 0) {
      int v38 = __maskrune(v37, 0x40000uLL);
    }
    else {
      int v38 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v37 + 60) & 0x40000;
    }
    unsigned int v39 = (char)Uint32ForKey;
    unsigned int v105 = Uint32ForKey << 24;
    if ((Uint32ForKey << 24) <= 0x7F000000) {
      int v40 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * (char)Uint32ForKey + 60) & 0x40000;
    }
    else {
      int v40 = __maskrune((char)Uint32ForKey, 0x40000uLL);
    }
    if (v38) {
      uint64_t v41 = v121;
    }
    else {
      uint64_t v41 = 46;
    }
    if (v40) {
      uint64_t v42 = (char)Uint32ForKey;
    }
    else {
      uint64_t v42 = 46;
    }
    _cg_jpeg_mem_term("callInitialize", 356, "***  ImageIO: plugin changed from '%c%c%c%c' to '%c%c%c%c'\n", v118, v117, v116, v30, v33, v36, v41, v42);
    int v43 = (IIO_ReaderHandler *)kdebug_trace();
    ReaderHandler = (IIO_ReaderHandler *)IIO_ReaderHandler::GetReaderHandler(v43);
    int v45 = IIO_ReaderHandler::readerForType(ReaderHandler, Uint32ForKey);
    if (!v45)
    {
      if (v2 < 0)
      {
        int v54 = __maskrune(v114, 0x40000uLL);
        unsigned int v53 = v2 >> 24;
      }
      else
      {
        unsigned int v53 = v2 >> 24;
        int v54 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v114 + 60) & 0x40000;
      }
      if (v54) {
        uint64_t v55 = v53;
      }
      else {
        uint64_t v55 = 46;
      }
      if (v110 < 0)
      {
        int v57 = __maskrune(v113, 0x40000uLL);
        unsigned int v56 = v2 << 8 >> 24;
      }
      else
      {
        unsigned int v56 = v2 << 8 >> 24;
        int v57 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v113 + 60) & 0x40000;
      }
      if (v57) {
        uint64_t v58 = v56;
      }
      else {
        uint64_t v58 = 46;
      }
      uint64_t v119 = v58;
      if (v109 < 0)
      {
        int v60 = __maskrune(v112, 0x40000uLL);
        unsigned int v59 = v112;
      }
      else
      {
        unsigned int v59 = v112;
        int v60 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v112 + 60) & 0x40000;
      }
      if (v60) {
        uint64_t v61 = v59;
      }
      else {
        uint64_t v61 = 46;
      }
      if (v108 <= 0x7F000000)
      {
        unsigned int v63 = v111;
        int v62 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v111 + 60) & 0x40000;
      }
      else
      {
        int v62 = __maskrune(v111, 0x40000uLL);
        unsigned int v63 = v111;
      }
      if (v62) {
        uint64_t v64 = v63;
      }
      else {
        uint64_t v64 = 46;
      }
      if (Uint32ForKey < 0) {
        int v65 = __maskrune(Uint32ForKey >> 24, 0x40000uLL);
      }
      else {
        int v65 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v31 + 60) & 0x40000;
      }
      if (v65) {
        uint64_t v66 = v31;
      }
      else {
        uint64_t v66 = 46;
      }
      if (v107 < 0) {
        int v67 = __maskrune(v34, 0x40000uLL);
      }
      else {
        int v67 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v34 + 60) & 0x40000;
      }
      if (v67) {
        uint64_t v34 = v34;
      }
      else {
        uint64_t v34 = 46;
      }
      if (v106 < 0) {
        int v68 = __maskrune(v121, 0x40000uLL);
      }
      else {
        int v68 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v121 + 60) & 0x40000;
      }
      if (v105 <= 0x7F000000) {
        int v69 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v39 + 60) & 0x40000;
      }
      else {
        int v69 = __maskrune(v39, 0x40000uLL);
      }
      if (v68) {
        uint64_t v70 = v121;
      }
      else {
        uint64_t v70 = 46;
      }
      if (v69) {
        uint64_t v71 = v39;
      }
      else {
        uint64_t v71 = 46;
      }
      LogError("callInitialize", 386, "*** cannot switch plugin: '%c%c%c%c' -> '%c%c%c%c'\n", v55, v119, v61, v64, v66, v34, v70, v71);
      uint64_t v16 = 4294967247;
      goto LABEL_141;
    }
    uint64_t Ref = IIOImageSource::imageReadRef(*((IIOImageSource **)this + 3));
    uint64_t Source = CGImageSourceGetSource(Ref);
    if (Uint32ForKey == 1212500291)
    {
      if (Source) {
        IIOImageSource::updateReader(Source, v45);
      }
      IIO_Reader_HEIF::CreateGlobalHEIFInfoIfNeeded(*((IIO_Reader_HEIF **)this + 3), (IIOImageReadSession *)v115, Size);
      IIODictionary::removeObjectForKey((IIODictionary *)v123, @"NEW_PLUGIN_dataOffset");
      IIODictionary::removeObjectForKey((IIODictionary *)v123, @"NEW_PLUGIN_dataSize");
    }
    uint64_t v48 = (IIOReadPlugin *)(*(uint64_t (**)(IIO_Reader *, void, void, void))(*(void *)v45 + 248))(v45, *((void *)this + 1), 0, v115);
    *((void *)v48 + 19) = v125;
    uint64_t v16 = (*(uint64_t (**)(IIOReadPlugin *, void *))(*(void *)v48 + 96))(v48, v123);
    *((void *)v48 + 9) = IIOImageSource::cf(v45);
    *((_DWORD *)v48 + 51) = IIO_Reader::osType(v45);
    (*(void (**)(IIOReadPlugin *))(*(void *)this + 8))(this);
    if (v16)
    {
      int v49 = *((_DWORD *)v48 + 51);
      if (v49)
      {
        if (v2 < 0)
        {
          int v51 = __maskrune(v114, 0x40000uLL);
          unsigned int v52 = v111;
          unsigned int v50 = v2 >> 24;
        }
        else
        {
          unsigned int v50 = v2 >> 24;
          int v51 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v114 + 60) & 0x40000;
          unsigned int v52 = v111;
        }
        if (v51) {
          uint64_t v84 = v50;
        }
        else {
          uint64_t v84 = 46;
        }
        uint64_t v122 = v84;
        if (v110 < 0)
        {
          int v86 = __maskrune(v113, 0x40000uLL);
          unsigned int v85 = v2 << 8 >> 24;
        }
        else
        {
          unsigned int v85 = v2 << 8 >> 24;
          int v86 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v113 + 60) & 0x40000;
        }
        if (v86) {
          uint64_t v87 = v85;
        }
        else {
          uint64_t v87 = 46;
        }
        uint64_t v120 = v87;
        if (v109 < 0)
        {
          int v89 = __maskrune(v112, 0x40000uLL);
          unsigned int v88 = v112;
        }
        else
        {
          unsigned int v88 = v112;
          int v89 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v112 + 60) & 0x40000;
        }
        if (v89) {
          uint64_t v90 = v88;
        }
        else {
          uint64_t v90 = 46;
        }
        if (v108 <= 0x7F000000) {
          int v91 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v52 + 60) & 0x40000;
        }
        else {
          int v91 = __maskrune(v52, 0x40000uLL);
        }
        if (v91) {
          uint64_t v92 = v52;
        }
        else {
          uint64_t v92 = 46;
        }
        unsigned int v93 = v49 >> 24;
        if (v49 < 0) {
          int v94 = __maskrune(v49 >> 24, 0x40000uLL);
        }
        else {
          int v94 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v93 + 60) & 0x40000;
        }
        if (v94) {
          uint64_t v95 = v93;
        }
        else {
          uint64_t v95 = 46;
        }
        unsigned int v96 = v49 << 8 >> 24;
        if (v49 << 8 < 0) {
          int v97 = __maskrune(v49 << 8 >> 24, 0x40000uLL);
        }
        else {
          int v97 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v96 + 60) & 0x40000;
        }
        if (v97) {
          uint64_t v98 = v96;
        }
        else {
          uint64_t v98 = 46;
        }
        unsigned int v99 = (__int16)v49 >> 8;
        if (v49 << 16 < 0) {
          int v100 = __maskrune((__int16)v49 >> 8, 0x40000uLL);
        }
        else {
          int v100 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v99 + 60) & 0x40000;
        }
        if ((v49 << 24) <= 0x7F000000) {
          int v101 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * (char)v49 + 60) & 0x40000;
        }
        else {
          int v101 = __maskrune((char)v49, 0x40000uLL);
        }
        if (v100) {
          uint64_t v102 = v99;
        }
        else {
          uint64_t v102 = 46;
        }
        if (v101) {
          uint64_t v103 = (char)v49;
        }
        else {
          uint64_t v103 = 46;
        }
        _cg_jpeg_mem_term("callInitialize", 408, "*** '%c%c%c%c' -> '%c%c%c%c' initialize failed - err = %d\n", v122, v120, v90, v92, v95, v98, v102, v103, v16);
LABEL_166:
        (*(void (**)(IIOReadPlugin *))(*(void *)v48 + 8))(v48);
        goto LABEL_167;
      }
      this = v48;
LABEL_141:
      unsigned int v72 = v2 >> 24;
      if (v2 < 0) {
        int v73 = __maskrune(v2 >> 24, 0x40000uLL);
      }
      else {
        int v73 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v72 + 60) & 0x40000;
      }
      if (v73) {
        uint64_t v74 = v72;
      }
      else {
        uint64_t v74 = 46;
      }
      unsigned int v75 = v2 << 8 >> 24;
      if (v2 << 8 < 0) {
        int v76 = __maskrune(v2 << 8 >> 24, 0x40000uLL);
      }
      else {
        int v76 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v75 + 60) & 0x40000;
      }
      if (v76) {
        uint64_t v77 = v75;
      }
      else {
        uint64_t v77 = 46;
      }
      unsigned int v78 = (__int16)v2 >> 8;
      if (v2 << 16 < 0) {
        int v79 = __maskrune((__int16)v2 >> 8, 0x40000uLL);
      }
      else {
        int v79 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v78 + 60) & 0x40000;
      }
      if ((v2 << 24) <= 0x7F000000) {
        int v80 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * (char)v2 + 60) & 0x40000;
      }
      else {
        int v80 = __maskrune((char)v2, 0x40000uLL);
      }
      if (v79) {
        uint64_t v81 = v78;
      }
      else {
        uint64_t v81 = 46;
      }
      if (v80) {
        uint64_t v82 = (char)v2;
      }
      else {
        uint64_t v82 = 46;
      }
      _cg_jpeg_mem_term("callInitialize", 410, "*** '%c%c%c%c' initialize failed - err = %d\n", v74, v77, v81, v82, v16);
      uint64_t v48 = this;
      goto LABEL_166;
    }
    this = v48;
  }
  IIOReadPlugin::postInitialize((CGColorSpaceRef *)this, &v124);
  uint64_t v16 = 0;
LABEL_167:
  IIODictionary::~IIODictionary((IIODictionary *)v123);
  IIODictionary::~IIODictionary((IIODictionary *)&v124);
  return v16;
}

void sub_1885AC8FC(_Unwind_Exception *a1)
{
  IIODictionary::~IIODictionary((IIODictionary *)(v1 - 136));
  IIODictionary::~IIODictionary((IIODictionary *)(v1 - 112));
  _Unwind_Resume(a1);
}

void IIODictionary::~IIODictionary(IIODictionary *this)
{
  *(void *)this = &unk_1ED4DFD78;
  uint64_t v1 = (const void *)*((void *)this + 1);
  if (v1) {
    CFRelease(v1);
  }
}

{
  uint64_t vars8;

  IIODictionary::~IIODictionary(this);

  JUMPOUT(0x18C11C0E0);
}

void IIODictionary::IIODictionary(IIODictionary *this)
{
  *(void *)this = &unk_1ED4DFD78;
  *((void *)this + 1) = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  *((unsigned char *)this + 16) = 1;
}

uint64_t IIOReadPlugin::postInitialize(CGColorSpaceRef *this, const __CFDictionary **a2)
{
  if (*((_DWORD *)this + 57) && *((_DWORD *)this + 58))
  {
    IIOReadPlugin::postInitHandleDecodeToSDR(this);
    InfoPtr = (__CFDictionary **)IIOReadPlugin::createInfoPtr((IIOReadPlugin *)this);
    if (IIODictionary::getCount((IIODictionary *)a2))
    {
      memset(v19, 0, sizeof(v19));
      IIODictionary::IIODictionary((IIODictionary *)v19, *InfoPtr);
      IIODictionary::appendDictionary((IIODictionary *)v19, a2);
      IIODictionary::~IIODictionary((IIODictionary *)v19);
    }
    InfoPtr[1] = (__CFDictionary *)this;
    (*((void (**)(CGColorSpaceRef *, __CFDictionary **))*this + 8))(this, InfoPtr);
    return 0;
  }
  else
  {
    int v6 = *((_DWORD *)this + 51);
    unsigned int v7 = v6 >> 24;
    uint64_t v8 = MEMORY[0x1E4F14390];
    if (v6 < 0) {
      int v9 = __maskrune(v6 >> 24, 0x40000uLL);
    }
    else {
      int v9 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v7 + 60) & 0x40000;
    }
    if (v9) {
      uint64_t v10 = v7;
    }
    else {
      uint64_t v10 = 46;
    }
    unsigned int v11 = v6 << 8 >> 24;
    if (v6 << 8 < 0) {
      int v12 = __maskrune(v6 << 8 >> 24, 0x40000uLL);
    }
    else {
      int v12 = *(_DWORD *)(v8 + 4 * v11 + 60) & 0x40000;
    }
    if (v12) {
      uint64_t v13 = v11;
    }
    else {
      uint64_t v13 = 46;
    }
    unsigned int v14 = (__int16)v6 >> 8;
    if (v6 << 16 < 0) {
      int v15 = __maskrune((__int16)v6 >> 8, 0x40000uLL);
    }
    else {
      int v15 = *(_DWORD *)(v8 + 4 * v14 + 60) & 0x40000;
    }
    if (v15) {
      uint64_t v16 = v14;
    }
    else {
      uint64_t v16 = 46;
    }
    if ((v6 << 24) <= 0x7F000000) {
      int v17 = *(_DWORD *)(v8 + 4 * (char)v6 + 60) & 0x40000;
    }
    else {
      int v17 = __maskrune((char)v6, 0x40000uLL);
    }
    if (v17) {
      uint64_t v18 = (char)v6;
    }
    else {
      uint64_t v18 = 46;
    }
    _cg_jpeg_mem_term("postInitialize", 475, "*** '%c%c%c%c' initialize returned bad _inputGeo (%d x %d)\n", v10, v13, v16, v18, *((_DWORD *)this + 57), *((_DWORD *)this + 58));
    return 4294967246;
  }
}

void sub_1885ACBE8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  IIODictionary::~IIODictionary((IIODictionary *)va);
  _Unwind_Resume(a1);
}

void CopyTiffPropertiesToRoot(IIODictionary *this, CGImageMetadata *a2)
{
  if (this && a2)
  {
    if (!IIODictionary::getBoolForKey(this, @"needsPostProcessing")) {
      goto LABEL_33;
    }
    IIODictionary::removeObjectForKey(this, @"needsPostProcessing");
    CFDictionaryRef ObjectForKeyGroup = IIODictionary::getObjectForKeyGroup(this, @"DateCreated", @"{IPTC}");
    CFDictionaryRef v5 = IIODictionary::getObjectForKeyGroup(this, @"TimeCreated", @"{IPTC}");
    if (ObjectForKeyGroup) {
      BOOL v6 = v5 == 0;
    }
    else {
      BOOL v6 = 0;
    }
    if (v6)
    {
      CFDictionaryRef v14 = IIODictionary::getObjectForKeyGroup(this, @"DateTimeOriginal", @"{Exif}");
      CFStringRef IPTCTimeFromExifDateTime = CreateIPTCTimeFromExifDateTime(v14);
      if (!IPTCTimeFromExifDateTime)
      {
LABEL_19:
        CFDictionaryRef v16 = (const __CFDictionary *)*((void *)a2 + 6);
        if (v16)
        {
          CFDictionaryRef v48 = 0;
          uint64_t v49 = 0;
          uint64_t v50 = 0;
          int v17 = IIODictionary::IIODictionary((IIODictionary *)&v48, v16, 1);
          uint64_t v18 = CGImageMetadataCreateFromLegacyProps(v17);
          int v19 = (const void *)v18;
          if (v18)
          {
            metadataSetSource(v18, 34);
            CGImageMetadataMerge((uint64_t)a2, (uint64_t)v19, 0);
            CFRelease(v19);
          }
          IIODictionary::appendDictionary(this, &v48);
          IIODictionary::~IIODictionary((IIODictionary *)&v48);
        }
        uint64_t v20 = CGImageMetadataCreateFromLegacyProps(this);
        if (v20)
        {
          unsigned int v21 = (const void *)v20;
          CGImageMetadataMerge((uint64_t)a2, v20, 0);
          CFRelease(v21);
        }
        CFDictionaryRef ObjectForKey = IIODictionary::getObjectForKey(this, @"{XMP}");
        if (ObjectForKey)
        {
          CGImageMetadataMerge((uint64_t)a2, (uint64_t)ObjectForKey, 0);
          IIODictionary::removeObjectForKey(this, @"{XMP}");
        }
        copyRenderingProperties(this, a2);
        if (IIODictionary::containsKeyGroup(this, @"Orientation", @"{TIFF}")
          && IIODictionary::getUint32ForKeyGroup(this, @"Orientation", @"{TIFF}") - 9 <= 0xFFFFFFF7)
        {
          IIODictionary::removeObjectForKeyGroup(this, @"Orientation", @"{TIFF}");
        }
        reconcileSubsecTimes(a2);
        reconcileGPSTimeStamp(a2);
        IIODictionary::setObjectForKey(this, (const void *)*MEMORY[0x1E4F1CFD0], @"kCGSourceMetadataNotSynced");
        if (IIODictionary::containsKey(this, @"{IPTC}"))
        {
          CFDictionaryRef v23 = IIODictionary::getObjectForKey(this, @"{IPTC}");
          if (!CFDictionaryGetCount(v23)) {
            IIODictionary::removeObjectForKey(this, @"{IPTC}");
          }
        }
        goto LABEL_33;
      }
      CFStringRef v10 = IPTCTimeFromExifDateTime;
      unsigned int v11 = this;
      CFStringRef v12 = v10;
      CFStringRef v13 = @"TimeCreated";
    }
    else
    {
      if (ObjectForKeyGroup) {
        BOOL v7 = 1;
      }
      else {
        BOOL v7 = v5 == 0;
      }
      if (v7) {
        goto LABEL_19;
      }
      CFDictionaryRef v8 = IIODictionary::getObjectForKeyGroup(this, @"DateTimeOriginal", @"{Exif}");
      CFStringRef IPTCDateFromExifDateTime = CreateIPTCDateFromExifDateTime(v8);
      if (!IPTCDateFromExifDateTime) {
        goto LABEL_19;
      }
      CFStringRef v10 = IPTCDateFromExifDateTime;
      unsigned int v11 = this;
      CFStringRef v12 = v10;
      CFStringRef v13 = @"DateCreated";
    }
    IIODictionary::setObjectForKeyGroup(v11, v12, v13, @"{IPTC}");
    CFRelease(v10);
    goto LABEL_19;
  }
  if (!this) {
    return;
  }
LABEL_33:
  if (!IIODictionary::containsKey(this, @"{TIFF}")) {
    return;
  }
  unsigned int v24 = IIODictionary::getObjectForKey(this, @"{TIFF}");
  CFDictionaryRef v48 = 0;
  uint64_t v49 = 0;
  uint64_t v50 = 0;
  unsigned int v25 = IIODictionary::IIODictionary((IIODictionary *)&v48, v24);
  if (IIODictionary::containsKey(v25, @"Orientation"))
  {
    unsigned int Uint32ForKey = IIODictionary::getUint32ForKey((IIODictionary *)&v48, @"Orientation");
    if (Uint32ForKey - 9 < 0xFFFFFFF8) {
      int v27 = 1;
    }
    else {
      int v27 = Uint32ForKey;
    }
    IIONumber::IIONumber((IIONumber *)v46, v27);
    IIODictionary::setObjectForKey((IIODictionary *)&v48, value, @"Orientation");
    IIONumber::~IIONumber((IIONumber *)v46);
    IIONumber::IIONumber((IIONumber *)v46, v27);
    IIODictionary::setObjectForKey(this, value, @"Orientation");
    IIONumber::~IIONumber((IIONumber *)v46);
  }
  if (IIODictionary::containsKey((IIODictionary *)&v48, @"ResolutionUnit")) {
    unsigned __int16 v28 = (unsigned __int16)IIODictionary::getUint32ForKey((IIODictionary *)&v48, @"ResolutionUnit");
  }
  else {
    unsigned __int16 v28 = 0;
  }
  unsigned int v29 = IIODictionary::containsKey((IIODictionary *)&v48, @"XResolution");
  if (!v29)
  {
    int v32 = 0;
    goto LABEL_49;
  }
  double DoubleForKey = IIODictionary::getDoubleForKey((IIODictionary *)&v48, @"XResolution");
  if (DoubleForKey <= 0.0 || (*(void *)&DoubleForKey & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000)
  {
    int v32 = 1;
LABEL_49:
    double DoubleForKey = 72.0;
    goto LABEL_50;
  }
  int v32 = 0;
LABEL_50:
  unsigned int v33 = IIODictionary::containsKey((IIODictionary *)&v48, @"YResolution");
  if (v33)
  {
    double v34 = IIODictionary::getDoubleForKey((IIODictionary *)&v48, @"YResolution");
    if (v34 <= 0.0) {
      goto LABEL_54;
    }
    double v35 = v34;
    if ((*(void *)&v34 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL || v32) {
      goto LABEL_54;
    }
  }
  else
  {
    double v35 = 72.0;
    double v34 = DoubleForKey;
    if (v32)
    {
LABEL_54:
      IIONumber::IIONumber((IIONumber *)v45, 72.0);
      IIODictionary::setObjectForKey((uint64_t)&v48, (uint64_t)v45, @"XResolution");
      IIONumber::~IIONumber((IIONumber *)v45);
      IIONumber::IIONumber((IIONumber *)v44, 72.0);
      IIODictionary::setObjectForKey((uint64_t)&v48, (uint64_t)v44, @"YResolution");
      IIONumber::~IIONumber((IIONumber *)v44);
      double v35 = 72.0;
      double v34 = 72.0;
      goto LABEL_55;
    }
  }
  if (v29)
  {
    if ((v33 & 1) == 0)
    {
      CFStringRef StringValueWithPath = (const __CFString *)CGImageMetadataGetStringValueWithPath(a2, 0, @"tiff:YResolution");
      if (StringValueWithPath && CFStringHasSuffix(StringValueWithPath, @"/0")) {
        double v35 = 72.0;
      }
      else {
        double v35 = DoubleForKey;
      }
    }
    double v34 = DoubleForKey;
    goto LABEL_55;
  }
  if (v33)
  {
LABEL_55:
    if (v28 == 3)
    {
      IIONumber::IIONumber((IIONumber *)v43, round(v34 * 2.54));
      IIODictionary::setObjectForKey((uint64_t)this, (uint64_t)v43, @"DPIWidth");
      IIONumber::~IIONumber((IIONumber *)v43);
      IIONumber::IIONumber((IIONumber *)v42, round(v35 * 2.54));
      uint64_t v36 = (IIONumber *)v42;
      IIODictionary::setObjectForKey((uint64_t)this, (uint64_t)v42, @"DPIHeight");
    }
    else
    {
      float v38 = v34;
      IIONumber::IIONumber((IIONumber *)v41, v38);
      IIODictionary::setObjectForKey((uint64_t)this, (uint64_t)v41, @"DPIWidth");
      IIONumber::~IIONumber((IIONumber *)v41);
      float v39 = v35;
      IIONumber::IIONumber((IIONumber *)v40, v39);
      uint64_t v36 = (IIONumber *)v40;
      IIODictionary::setObjectForKey((uint64_t)this, (uint64_t)v40, @"DPIHeight");
    }
    IIONumber::~IIONumber(v36);
  }
  IIODictionary::~IIODictionary((IIODictionary *)&v48);
}

void sub_1885AD224(_Unwind_Exception *a1)
{
  IIODictionary::~IIODictionary((IIODictionary *)(v1 - 120));
  _Unwind_Resume(a1);
}

const __CFDictionary *IIODictionary::containsKeyGroup(IIODictionary *this, const __CFString *a2, const __CFString *a3)
{
  CFDictionaryRef result = IIODictionary::getGroupForKey(this, a3, 0);
  if (result) {
    return (const __CFDictionary *)(CFDictionaryGetValue(result, a2) != 0);
  }
  return result;
}

uint64_t CGImageMetadataCreateFromLegacyProps(IIODictionary *a1)
{
  uint64_t v8 = 0;
  int v9 = &v8;
  uint64_t v10 = 0x2000000000;
  uint64_t v11 = 0;
  if (a1 && IIODictionary::getCount(a1))
  {
    v7[0] = MEMORY[0x1E4F143A8];
    v7[1] = 0x40000000;
    v7[2] = __CGImageMetadataCreateFromLegacyProps_block_invoke;
    v7[3] = &unk_1E53C01E8;
    v7[4] = &v8;
    void v7[5] = a1;
    XMPMappingIteratePropertiesUsingBlock(a1, (uint64_t)v7);
    CFStringRef ObjectForKeyGroup = (const __CFString *)IIODictionary::getObjectForKeyGroup(a1, @"iptcComputedMD5", @"{IPTC}");
    if (v9[3]) {
      BOOL v3 = ObjectForKeyGroup == 0;
    }
    else {
      BOOL v3 = 1;
    }
    if (!v3)
    {
      CFStringRef Copy = CFStringCreateCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], ObjectForKeyGroup);
      *(void *)(v9[3] + 56) = Copy;
    }
  }
  uint64_t v5 = v9[3];
  _Block_object_dispose(&v8, 8);
  return v5;
}

void sub_1885AD3F4(void *a1)
{
}

void sub_1885AD400(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

const __CFDictionary *IIODictionary::getCount(IIODictionary *this)
{
  CFDictionaryRef result = (const __CFDictionary *)*((void *)this + 1);
  if (result) {
    return (const __CFDictionary *)CFDictionaryGetCount(result);
  }
  return result;
}

void reconcileSubsecTimes(const __CFDictionary *a1)
{
  CFDictionaryRef TopLevelTag = CGImageMetadataGetTopLevelTag(a1, @"http://ns.adobe.com/exif/1.0/", @"SubsecTimeOriginal");
  CFDictionaryRef v3 = CGImageMetadataGetTopLevelTag(a1, @"http://ns.adobe.com/photoshop/1.0/", @"DateCreated");
  uint64_t v4 = (uint64_t)v3;
  if (v3) {
    BOOL v5 = TopLevelTag == 0;
  }
  else {
    BOOL v5 = 1;
  }
  if (v5)
  {
    if (!v3) {
      goto LABEL_13;
    }
    CFStringRef Value = (const __CFString *)CGImageMetadataTagGetValue((uint64_t)v3);
    CFStringRef SubsecTimeFromXMPDateTime = CreateSubsecTimeFromXMPDateTime(Value);
    if (!SubsecTimeFromXMPDateTime) {
      goto LABEL_13;
    }
    CFStringRef v8 = SubsecTimeFromXMPDateTime;
    int v9 = (const void *)CGImageMetadataTagCreateFromImageProperty(@"{Exif}", @"SubsecTimeOriginal", (uint64_t)SubsecTimeFromXMPDateTime);
    if (v9)
    {
      uint64_t v10 = v9;
      CGImageMetadataAddTag((uint64_t)a1, v9);
      CFRelease(v10);
    }
  }
  else
  {
    CFStringRef v11 = (const __CFString *)CGImageMetadataTagGetValue((uint64_t)v3);
    uint64_t v12 = CGImageMetadataTagGetValue((uint64_t)TopLevelTag);
    CFStringRef XMPDateFromXMPDateTimeAndSubsecTime = CreateXMPDateFromXMPDateTimeAndSubsecTime(v11, v12);
    if (!XMPDateFromXMPDateTimeAndSubsecTime) {
      goto LABEL_13;
    }
    CFStringRef v8 = XMPDateFromXMPDateTimeAndSubsecTime;
    CGImageMetadataTagSetValue(v4, XMPDateFromXMPDateTimeAndSubsecTime);
  }
  CFRelease(v8);
LABEL_13:
  CFDictionaryRef v14 = CGImageMetadataGetTopLevelTag(a1, @"http://ns.adobe.com/exif/1.0/", @"SubsecTimeDigitized");
  CFDictionaryRef v15 = CGImageMetadataGetTopLevelTag(a1, @"http://ns.adobe.com/xap/1.0/", @"CreateDate");
  uint64_t v16 = (uint64_t)v15;
  if (v15) {
    BOOL v17 = v14 == 0;
  }
  else {
    BOOL v17 = 1;
  }
  if (v17)
  {
    if (!v15) {
      goto LABEL_25;
    }
    CFStringRef v18 = (const __CFString *)CGImageMetadataTagGetValue((uint64_t)v15);
    CFStringRef v19 = CreateSubsecTimeFromXMPDateTime(v18);
    if (!v19) {
      goto LABEL_25;
    }
    CFStringRef v20 = v19;
    unsigned int v21 = (const void *)CGImageMetadataTagCreateFromImageProperty(@"{Exif}", @"SubsecTimeDigitized", (uint64_t)v19);
    if (v21)
    {
      int v22 = v21;
      CGImageMetadataAddTag((uint64_t)a1, v21);
      CFRelease(v22);
    }
  }
  else
  {
    CFStringRef v23 = (const __CFString *)CGImageMetadataTagGetValue((uint64_t)v15);
    uint64_t v24 = CGImageMetadataTagGetValue((uint64_t)v14);
    CFStringRef v25 = CreateXMPDateFromXMPDateTimeAndSubsecTime(v23, v24);
    if (!v25) {
      goto LABEL_25;
    }
    CFStringRef v20 = v25;
    CGImageMetadataTagSetValue(v16, v25);
  }
  CFRelease(v20);
LABEL_25:
  CFDictionaryRef v26 = CGImageMetadataGetTopLevelTag(a1, @"http://ns.adobe.com/exif/1.0/", @"SubsecTime");
  CFDictionaryRef v27 = CGImageMetadataGetTopLevelTag(a1, @"http://ns.adobe.com/xap/1.0/", @"ModifyDate");
  uint64_t v28 = (uint64_t)v27;
  if (v27) {
    BOOL v29 = v26 == 0;
  }
  else {
    BOOL v29 = 1;
  }
  if (v29)
  {
    if (!v27) {
      return;
    }
    CFStringRef v30 = (const __CFString *)CGImageMetadataTagGetValue((uint64_t)v27);
    CFStringRef v31 = CreateSubsecTimeFromXMPDateTime(v30);
    if (!v31) {
      return;
    }
    CFStringRef v32 = v31;
    unsigned int v33 = (const void *)CGImageMetadataTagCreateFromImageProperty(@"{Exif}", @"SubsecTime", (uint64_t)v31);
    if (v33)
    {
      double v34 = v33;
      CGImageMetadataAddTag((uint64_t)a1, v33);
      CFRelease(v34);
    }
  }
  else
  {
    CFStringRef v35 = (const __CFString *)CGImageMetadataTagGetValue((uint64_t)v27);
    uint64_t v36 = CGImageMetadataTagGetValue((uint64_t)v26);
    CFStringRef v37 = CreateXMPDateFromXMPDateTimeAndSubsecTime(v35, v36);
    if (!v37) {
      return;
    }
    CFStringRef v32 = v37;
    CGImageMetadataTagSetValue(v28, v37);
  }

  CFRelease(v32);
}

void reconcileGPSTimeStamp(const __CFDictionary *a1)
{
  CFDictionaryRef TopLevelTag = CGImageMetadataGetTopLevelTag(a1, @"http://ns.adobe.com/exif/1.0/", @"GPSTime");
  CFDictionaryRef v3 = CGImageMetadataGetTopLevelTag(a1, @"http://ns.adobe.com/exif/1.0/", @"GPSDate");
  uint64_t Source = CGImageSourceGetSource((uint64_t)TopLevelTag);
  uint64_t v5 = CGImageSourceGetSource((uint64_t)v3);
  if (TopLevelTag)
  {
    CFStringRef v6 = *(const __CFString **)(Source + 48);
    if (!v3 || ((CFStringRef v7 = *(const __CFString **)(v5 + 48), v6) ? (v8 = v7 == 0) : (v8 = 1), v8))
    {
      if (v6)
      {
        CFDictionaryRef v9 = CGImageMetadataGetTopLevelTag(a1, @"http://ns.adobe.com/photoshop/1.0/", @"DateCreated");
        CFStringRef Value = (const __CFString *)CGImageMetadataTagGetValue((uint64_t)v9);
        if (Value
          || (CFDictionaryRef v11 = CGImageMetadataGetTopLevelTag(a1, @"http://ns.adobe.com/xap/1.0/", @"CreateDate"), (Value = (const __CFString *)CGImageMetadataTagGetValue((uint64_t)v11)) != 0))
        {
          CFStringRef GPSDateStringWithXMPDateTimeString = CreateGPSDateStringWithXMPDateTimeString(Value);
          if (GPSDateStringWithXMPDateTimeString)
          {
            CFStringRef v13 = GPSDateStringWithXMPDateTimeString;
            CFStringRef XMPDateFromEXIFGPSDateAndTime = CreateXMPDateFromEXIFGPSDateAndTime(GPSDateStringWithXMPDateTimeString, v6);
            if (XMPDateFromEXIFGPSDateAndTime)
            {
              CFStringRef v15 = XMPDateFromEXIFGPSDateAndTime;
              CGImageMetadataSetValueWithPath(a1, 0, @"exif:GPSTimeStamp", XMPDateFromEXIFGPSDateAndTime);
              CFRelease(v15);
              CGImageMetadataRemoveTag((uint64_t)a1, (uint64_t)TopLevelTag);
            }
            CFRelease(v13);
          }
        }
      }
    }
    else
    {
      CFStringRef v16 = CreateXMPDateFromEXIFGPSDateAndTime(v7, v6);
      if (v16)
      {
        CFStringRef v17 = v16;
        CGImageMetadataSetValueWithPath(a1, 0, @"exif:GPSTimeStamp", v16);
        CFRelease(v17);
        CGImageMetadataRemoveTag((uint64_t)a1, (uint64_t)TopLevelTag);
        CGImageMetadataRemoveTag((uint64_t)a1, (uint64_t)v3);
      }
    }
  }
}

void copyRenderingProperties(IIODictionary *a1, const __CFDictionary *a2)
{
  SInt32 v13 = 0;
  double v12 = 0.0;
  CFStringRef TopLevelTag = (const __CFString *)CGImageMetadataGetTopLevelTag(a2, @"http://ns.adobe.com/tiff/1.0/", @"Orientation");
  if (TopLevelTag && GetIntegerFromPropertyValue(TopLevelTag, &v13))
  {
    IIONumber::IIONumber((IIONumber *)v11, v13);
    IIODictionary::setObjectForKeyGroup(a1, (uint64_t)v11, @"Orientation", @"{TIFF}");
    IIONumber::~IIONumber((IIONumber *)v11);
  }
  CFStringRef v5 = (const __CFString *)CGImageMetadataGetTopLevelTag(a2, @"http://ns.adobe.com/tiff/1.0/", @"XResolution");
  if (v5 && GetDoubleFromPropertyValue(v5, &v12))
  {
    IIONumber::IIONumber((IIONumber *)v10, v12);
    IIODictionary::setObjectForKeyGroup(a1, (uint64_t)v10, @"XResolution", @"{TIFF}");
    IIONumber::~IIONumber((IIONumber *)v10);
  }
  CFStringRef v6 = (const __CFString *)CGImageMetadataGetTopLevelTag(a2, @"http://ns.adobe.com/tiff/1.0/", @"YResolution");
  if (v6 && GetDoubleFromPropertyValue(v6, &v12))
  {
    IIONumber::IIONumber((IIONumber *)v9, v12);
    IIODictionary::setObjectForKeyGroup(a1, (uint64_t)v9, @"YResolution", @"{TIFF}");
    IIONumber::~IIONumber((IIONumber *)v9);
  }
  CFStringRef v7 = (const __CFString *)CGImageMetadataGetTopLevelTag(a2, @"http://ns.adobe.com/tiff/1.0/", @"ResolutionUnit");
  if (v7)
  {
    if (GetIntegerFromPropertyValue(v7, &v13))
    {
      IIONumber::IIONumber((IIONumber *)v8, v13);
      IIODictionary::setObjectForKeyGroup(a1, (uint64_t)v8, @"ResolutionUnit", @"{TIFF}");
      IIONumber::~IIONumber((IIONumber *)v8);
    }
  }
}

void sub_1885ADA8C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t IIOReadPlugin::postInitHandleDecodeToSDR(CGColorSpaceRef *this)
{
  if (((*((uint64_t (**)(CGColorSpaceRef *))*this + 3))(this) & 1) == 0 && *((unsigned char *)this + 353))
  {
    BOOL IsHDR = CGColorSpaceIsHDR(this[20]);
    BOOL v3 = CGColorSpaceUsesExtendedRange(this[20]);
    if (IsHDR)
    {
      CGColorSpaceRelease(this[20]);
      this[20] = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E4F1DB90]);
    }
    else
    {
      if (!v3) {
        return 0;
      }
      if (*((_DWORD *)this + 51) != 1163416096 && *((_WORD *)this + 120) == 32)
      {
        *((_WORD *)this + 136) = 16;
        __int16 v4 = *((_WORD *)this + 122);
        *((_WORD *)this + 137) = 16 * v4;
        *((unsigned char *)this + 279) = 1;
        if (!*((unsigned char *)this + 246))
        {
          *((unsigned char *)this + 278) = 5;
          *((_WORD *)this + 138) = v4 + 1;
        }
      }
    }
    *((_DWORD *)this + 44) = 1065353216;
  }
  return 0;
}

void *IIOReadPlugin::createInfoPtr(IIOReadPlugin *this)
{
  int v2 = malloc_type_calloc(0x10uLL, 1uLL, 0x93DC3238uLL);
  v2[1] = this;
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  void *v2 = Mutable;
  *((void *)this + 19) = Mutable;
  __int16 v4 = (IIOImageSource *)*((void *)this + 3);
  if (v4 && IIOImageSource::cf(v4))
  {
    CFStringRef v5 = (__CFDictionary *)*((void *)this + 19);
    CFStringRef v6 = (const void *)IIOImageSource::cf(*((IIOImageSource **)this + 3));
    CFDictionarySetValue(v5, @"kImageIOInfoHeader_session", v6);
    CFDictionarySetValue(*((CFMutableDictionaryRef *)this + 19), @"kImageIOInfoHeader_pluginHandlesReMapping", (const void *)*MEMORY[0x1E4F1CFD0]);
  }
  return v2;
}

uint64_t IIOImageSource::cf(IIOImageSource *this)
{
  return *((void *)this + 1);
}

uint64_t IIOReadPlugin::canHandleDecodeToSDRRequest(IIOReadPlugin *this)
{
  return 0;
}

uint64_t PNGReadPlugin::setupCallback(uint64_t a1, CFDictionaryRef *a2)
{
  int v2 = *(__int16 *)(a1 + 376);
  if (v2 == 12) {
    return IIOReadPlugin::setupImageProviderCallbackV2(a1, a2);
  }
  if (v2 == 1) {
    return IIOReadPlugin::setupCallback(a1, a2);
  }
  return 4294967246;
}

uint64_t IIOReadPlugin::setupCallback(uint64_t a1, CFDictionaryRef *a2)
{
  if (*(_WORD *)(a1 + 376) != 1)
  {
    int v4 = *(_DWORD *)(a1 + 204);
    unsigned int v5 = v4 >> 24;
    uint64_t v6 = MEMORY[0x1E4F14390];
    int v7 = v4 < 0 ? __maskrune(v4 >> 24, 0x40000uLL) : *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v5 + 60) & 0x40000;
    uint64_t v8 = v7 ? v5 : 46;
    unsigned int v9 = v4 << 8 >> 24;
    int v10 = v4 << 8 < 0 ? __maskrune(v4 << 8 >> 24, 0x40000uLL) : *(_DWORD *)(v6 + 4 * v9 + 60) & 0x40000;
    uint64_t v11 = v10 ? v9 : 46;
    unsigned int v12 = (__int16)v4 >> 8;
    int v13 = v4 << 16 < 0 ? __maskrune((__int16)v4 >> 8, 0x40000uLL) : *(_DWORD *)(v6 + 4 * v12 + 60) & 0x40000;
    uint64_t v14 = v13 ? v12 : 46;
    int v15 = (v4 << 24) <= 0x7F000000
        ? *(_DWORD *)(v6 + 4 * (char)v4 + 60) & 0x40000
        : __maskrune((char)v4, 0x40000uLL);
    uint64_t v16 = v15 ? (char)v4 : 46;
    _cg_jpeg_mem_term("setupCallback", 507, "*** '%c%c%c%c' plugin has to implement 'setupCallback' for non-version1 callbacks [%d]\n", v8, v11, v14, v16, *(__int16 *)(a1 + 376));
    if (v4 != 1246774599) {
      return 4294967246;
    }
  }
  IIOReadPlugin::setupImageProviderCallbackV1(a1, a2);
  return 0;
}

uint64_t PNGReadPlugin::initialize(CGColorSpace **this, IIODictionary *a2)
{
  BOOL v3 = (IIOImageReadSession *)IIOImageSource::count((IIOImageSource *)this);
  int v4 = this[6];
  unsigned int v5 = this[7];
  uint64_t v6 = this[8];
  int v7 = this[19];

  return PNGReadPlugin::InitializePluginData(v3, v4, v5, v6, this + 20, (uint64_t)(this + 23), (uint64_t)(this + 55), v7);
}

uint64_t AppleJPEGReadPlugin::setupCallback(uint64_t a1, CFDictionaryRef *a2)
{
  int v2 = *(__int16 *)(a1 + 376);
  switch(v2)
  {
    case 123:
      return IIOReadPlugin::setupImageProviderCallbackV3(a1, a2);
    case 12:
      return IIOReadPlugin::setupImageProviderCallbackV2(a1, a2);
    case 1:
      return IIOReadPlugin::setupCallback(a1, a2);
  }
  return 4294967246;
}

double IIODictionary::getDoubleFromValue(IIODictionary *this, const __CFString *cf)
{
  double valuePtr = 0.0;
  double v2 = 0.0;
  if (!cf) {
    return v2;
  }
  CFTypeID v4 = CFGetTypeID(cf);
  if (v4 == CFNumberGetTypeID())
  {
    CFNumberGetValue((CFNumberRef)cf, kCFNumberDoubleType, &valuePtr);
    return valuePtr;
  }
  CFTypeID v5 = CFGetTypeID(cf);
  if (v5 != CFStringGetTypeID()) {
    return v2;
  }

  return CFStringGetDoubleValue(cf);
}

double IIODictionary::getDoubleForKey(IIODictionary *this, const __CFString *a2)
{
  CFDictionaryRef v2 = (const __CFDictionary *)*((void *)this + 1);
  if (!v2) {
    return 0.0;
  }
  CFStringRef Value = (IIODictionary *)CFDictionaryGetValue(v2, a2);

  return IIODictionary::getDoubleFromValue(Value, (const __CFString *)Value);
}

uint64_t HEIFReadPlugin::canHandleDecodeToSDRRequest(HEIFReadPlugin *this)
{
  return 1;
}

uint64_t IIOReadPlugin::setupImageProviderCallbackV3(uint64_t a1, CFDictionaryRef *a2)
{
  uint64_t v3 = IIOReadPlugin::prepareGeometry(a1, a2);
  if (!v3) {
    IIOImagePlus::setImageBlockProc(*(IIOImagePlus **)(a1 + 16));
  }
  return v3;
}

uint64_t ATXReadPlugin::setupCallback(uint64_t a1, CFDictionaryRef *a2)
{
  int v2 = *(__int16 *)(a1 + 376);
  switch(v2)
  {
    case 13:
      return IIOReadPlugin::setupImageProviderCallbackV3(a1, a2);
    case 12:
      return IIOReadPlugin::setupImageProviderCallbackV2(a1, a2);
    case 1:
      return IIOReadPlugin::setupCallback(a1, a2);
  }
  return 4294967246;
}

uint64_t ASTCReadPlugin::setupCallback(uint64_t a1, CFDictionaryRef *a2)
{
  int v2 = *(__int16 *)(a1 + 376);
  if (v2 == 13) {
    return IIOReadPlugin::setupImageProviderCallbackV3(a1, a2);
  }
  if (v2 == 1) {
    return IIOReadPlugin::setupCallback(a1, a2);
  }
  return 4294967246;
}

CFStringRef CreateSubsecTimeFromXMPDateTime(const __CFString *cf)
{
  CFStringRef v1 = cf;
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  __int16 v18 = 0;
  *(void *)cStr = 0;
  long long v13 = 0u;
  long long v14 = 0u;
  long long v15 = 0u;
  uint64_t v16 = 0;
  long long v9 = 0u;
  long long v10 = 0u;
  long long v11 = 0u;
  uint64_t v12 = 0;
  if (cf)
  {
    CFTypeID v2 = CFGetTypeID(cf);
    if (v2 == CFStringGetTypeID()
      && (CFIndex v3 = CFStringGetLength(v1) + 1, (v4 = (char *)malloc_type_calloc(1uLL, v3, 0x2C26E6C3uLL)) != 0))
    {
      CFTypeID v5 = v4;
      int v8 = 0;
      if (CFStringGetCString(v1, v4, v3, 0x600u)
        && (sscanf(v5, "%04d-%02d-%02dT%02d:%02d:%02d.%9[0-9]+%02d:%02d", (char *)&v14 + 4, &v14, (unint64_t)&v13 | 0xC, (char *)&v13 + 8, (char *)&v13 + 4, &v8, cStr, (char *)&v9 + 8, (char *)&v9 + 4) == 9|| sscanf(v5, "%04d-%02d-%02dT%02d:%02d:%02d.%9[0-9]-%02d:%02d", (char *)&v14 + 4, &v14, (unint64_t)&v13 | 0xC, (char *)&v13 + 8, (char *)&v13 + 4,
              &v8,
              cStr,
              (char *)&v9 + 8,
              (char *)&v9 + 4) == 9
         || sscanf(v5, "%04d-%02d-%02dT%02d:%02d:%02d.%9[0-9]Z", (char *)&v14 + 4, &v14, (unint64_t)&v13 | 0xC, (char *)&v13 + 8, (char *)&v13 + 4, &v8, cStr) == 7))
      {
        int v7 = 0;
        CFStringRef v1 = 0;
        if (sscanf(cStr, "%d", &v7) == 1 && v7 >= 1) {
          CFStringRef v1 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], cStr, 0x600u);
        }
      }
      else
      {
        CFStringRef v1 = 0;
      }
      free(v5);
    }
    else
    {
      return 0;
    }
  }
  return v1;
}

void XMPMeta::~XMPMeta(XMPMeta *this)
{
  XMPMeta::~XMPMeta(this);

  JUMPOUT(0x18C11C0E0);
}

{
  uint64_t v2;

  *(void *)this = &unk_1ED4E5A58;
  if (*((int *)this + 2) >= 1) {
    __assert_rtn("~XMPMeta", "XMPMeta.cpp", 732, "this->clientRefs <= 0");
  }
  CFTypeID v2 = *((void *)this + 43);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  *((void *)this + 43) = 0;
  XMP_Node::~XMP_Node((XMPMeta *)((char *)this + 224));
  XMP_ReadWriteLock::~XMP_ReadWriteLock((XMPMeta *)((char *)this + 16));
}

void WXMPMeta_ParseFromBuffer_1(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void *a5)
{
  long long v10 = (XMP_ReadWriteLock *)(a1 + 16);
  XMP_ReadWriteLock::Acquire((pthread_rwlock_t *)(a1 + 16), 1);
  *a5 = 0;
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)a1 + 200))(a1, a2, a3, a4);
  XMP_AutoLock::~XMP_AutoLock(&v10);
}

uint64_t XMPMeta::ParseFromBuffer(XMPMeta *this, char *__s1, unsigned int a3, char a4)
{
  unsigned int v5 = a3;
  if (!__s1 && a3)
  {
    exception = __cxa_allocate_exception(0x18uLL);
    *(_DWORD *)exception = 4;
    exception[1] = "Null parse buffer";
    *((unsigned char *)exception + 16) = 0;
  }
  if (a3 == -1)
  {
    if (__s1)
    {
      uint64_t v10 = 0;
      unsigned int v5 = -1;
      while (__s1[v10])
      {
        if (++v10 == 0xFFFFFFFFLL) {
          goto LABEL_4;
        }
      }
      unsigned int v5 = v10;
    }
    else
    {
      unsigned int v5 = 0;
    }
  }
LABEL_4:
  int v7 = a4 & 2;
  if (*((void *)this + 43))
  {
    uint64_t result = XMPMeta::ProcessXMLBuffer(this, __s1, v5, v7 == 0);
    if (v7) {
      char v9 = 0;
    }
    else {
      char v9 = result;
    }
    if (v9)
    {
      XMPMeta::ProcessXMLTree(this, a4);
      uint64_t result = *((void *)this + 43);
      if (result) {
        uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
      }
      *((void *)this + 43) = 0;
    }
  }
  else
  {
    uint64_t result = (uint64_t)XMP_Node::ClearNode((XMPMeta *)((char *)this + 224));
    if (v5 | v7) {
      XMP_NewExpatAdapter();
    }
  }
  return result;
}

void sub_1885AE750(void *a1)
{
  __cxa_begin_catch(a1);
  uint64_t v2 = *(void *)(v1 + 344);
  if (v2) {
    XMPMeta::ParseFromBuffer(v2);
  }
  *(void *)(v1 + 344) = 0;
  __cxa_rethrow();
}

void sub_1885AE76C(_Unwind_Exception *a1)
{
}

void XMP_Node::~XMP_Node(XMP_Node *this)
{
  XMP_Node::~XMP_Node(this);

  JUMPOUT(0x18C11C0E0);
}

{
  void *v2;
  void *v3;

  *(void *)this = &unk_1ED4E5D30;
  XMP_Node::RemoveChildren(this);
  XMP_Node::RemoveQualifiers(this);
  uint64_t v2 = (void *)*((void *)this + 12);
  if (v2)
  {
    *((void *)this + 13) = v2;
    operator delete(v2);
  }
  CFIndex v3 = (void *)*((void *)this + 9);
  if (v3)
  {
    *((void *)this + 10) = v3;
    operator delete(v3);
  }
  if (*((char *)this + 63) < 0) {
    operator delete(*((void **)this + 5));
  }
  if (*((char *)this + 39) < 0) {
    operator delete(*((void **)this + 2));
  }
}

void *XMP_Node::RemoveQualifiers(void *this)
{
  uint64_t v1 = this;
  uint64_t v2 = this[13];
  uint64_t v3 = v2 - this[12];
  if (v3)
  {
    uint64_t v4 = 0;
    if ((unint64_t)(v3 >> 3) <= 1) {
      uint64_t v5 = 1;
    }
    else {
      uint64_t v5 = v3 >> 3;
    }
    do
    {
      this = *(void **)(v1[12] + 8 * v4);
      if (this) {
        this = (void *)(*(uint64_t (**)(void *))(*this + 8))(this);
      }
      ++v4;
    }
    while (v5 != v4);
    uint64_t v2 = v1[12];
  }
  v1[13] = v2;
  return this;
}

void *XMP_Node::RemoveChildren(void *this)
{
  uint64_t v1 = this;
  uint64_t v2 = this[10];
  uint64_t v3 = v2 - this[9];
  if (v3)
  {
    uint64_t v4 = 0;
    if ((unint64_t)(v3 >> 3) <= 1) {
      uint64_t v5 = 1;
    }
    else {
      uint64_t v5 = v3 >> 3;
    }
    do
    {
      this = *(void **)(v1[9] + 8 * v4);
      if (this) {
        this = (void *)(*(uint64_t (**)(void *))(*this + 8))(this);
      }
      ++v4;
    }
    while (v5 != v4);
    uint64_t v2 = v1[9];
  }
  v1[10] = v2;
  return this;
}

void *XMP_Node::ClearNode(XMP_Node *this)
{
  *((_DWORD *)this + 2) = 0;
  std::string::erase((std::string *)((char *)this + 16), 0, 0xFFFFFFFFFFFFFFFFLL);
  std::string::erase((std::string *)((char *)this + 40), 0, 0xFFFFFFFFFFFFFFFFLL);
  XMP_Node::RemoveChildren(this);

  return XMP_Node::RemoveQualifiers(this);
}

uint64_t XMPMeta::ProcessXMLBuffer(XMPMeta *this, char *__s1, unsigned int a3, uint64_t a4)
{
  unsigned int v5 = a3;
  uint64_t v6 = __s1;
  uint64_t v8 = *((void *)this + 43);
  int v9 = *(_DWORD *)(v8 + 200);
  if (v9 == -1)
  {
    uint64_t v10 = *(void *)(v8 + 208);
    if (a3 < 0x10 || v10)
    {
      if (16 - v10 >= (unint64_t)a3) {
        size_t v13 = a3;
      }
      else {
        size_t v13 = 16 - v10;
      }
      memcpy((void *)(v8 + v10 + 216), __s1, v13);
      unint64_t v11 = *(void *)(v8 + 208) + v13;
      *(void *)(v8 + 208) = v11;
      if ((a4 & 1) == 0 && v11 < 0x10) {
        return 0;
      }
      v5 -= v13;
      v6 += v13;
      uint64_t v12 = (const unsigned __int8 *)(v8 + 216);
    }
    else
    {
      unint64_t v11 = a3;
      uint64_t v12 = (const unsigned __int8 *)v6;
    }
    int v9 = DetermineInputEncoding(v12, v11);
    *(_DWORD *)(v8 + 200) = v9;
  }
  size_t v14 = *(void *)(v8 + 208);
  if (v9)
  {
    if (v14) {
      (*(void (**)(uint64_t, uint64_t, size_t, void))(*(void *)v8 + 16))(v8, v8 + 216, v14, 0);
    }
    (*(void (**)(uint64_t, char *, void, uint64_t))(*(void *)v8 + 16))(v8, v6, v5, a4);
    return 1;
  }
  if (!v14)
  {
LABEL_30:
    unint64_t v21 = ProcessUTF8Portion(*((XMLParserAdapter **)this + 43), v6, v5, a4);
    BOOL v22 = v5 > v21;
    size_t v23 = v5 - v21;
    if (v22)
    {
      if (a4) {
        XMPMeta::ProcessXMLBuffer();
      }
      if (v23 >= 0x11)
      {
        exception = __cxa_allocate_exception(0x18uLL);
        *(_DWORD *)exception = 9;
        exception[1] = "Parser bytesLeft too large";
        *((unsigned char *)exception + 16) = 0;
      }
      memcpy((void *)(v8 + 216), &v6[v21], v23);
      uint64_t result = 0;
      *(void *)(v8 + 208) = v23;
      return result;
    }
    return 1;
  }
  while (1)
  {
    if (16 - v14 >= v5) {
      size_t v15 = v5;
    }
    else {
      size_t v15 = 16 - v14;
    }
    memcpy((void *)(v8 + v14 + 216), v6, v15);
    unint64_t v16 = *(void *)(v8 + 208) + v15;
    *(void *)(v8 + 208) = v16;
    if ((a4 & 1) == 0 && v16 < 0x10) {
      return 0;
    }
    unsigned int v17 = v5 - v15;
    uint64_t v18 = ProcessUTF8Portion(*((XMLParserAdapter **)this + 43), (char *)(v8 + 216), v16, a4);
    uint64_t v19 = *(void *)(v8 + 208);
    size_t v20 = v19 - v18;
    if (v19 == v18)
    {
      v6 += v15;
LABEL_29:
      *(void *)(v8 + 208) = 0;
      unsigned int v5 = v17;
      goto LABEL_30;
    }
    if (v20 <= v15)
    {
      uint64_t v6 = &v6[v15 - v20];
      v17 += v20;
      goto LABEL_29;
    }
    if (!v17) {
      break;
    }
    size_t v14 = v19 - v15;
    *(void *)(v8 + 208) = v19 - v15;
    if (v19 == v15) {
      goto LABEL_30;
    }
  }
  if (a4) {
    XMPMeta::ProcessXMLBuffer();
  }
  *(void *)(v8 + 208) = v20;
  memcpy((void *)(v8 + 216), (const void *)(v8 + v18 + 216), v20);
  return 0;
}

uint64_t XMLParserAdapter::SetErrorCallback(uint64_t result, uint64_t a2)
{
  *(void *)(result + 232) = a2;
  return result;
}

uint64_t DetermineInputEncoding(const unsigned __int8 *a1, unint64_t a2)
{
  if (a2 < 2) {
    return 0;
  }
  int v4 = *a1;
  if (!*a1)
  {
    uint64_t result = 2;
    if (a2 < 4) {
      return result;
    }
    BOOL v5 = a1[1] == 0;
    unsigned int v6 = 4;
    goto LABEL_15;
  }
  if ((v4 & 0x80) != 0)
  {
    if (v4 != 239)
    {
      if (v4 == 254) {
        return 2;
      }
      goto LABEL_13;
    }
    return 0;
  }
  if (a1[1]) {
    return 0;
  }
LABEL_13:
  uint64_t result = 3;
  if (a2 < 4) {
    return result;
  }
  BOOL v5 = a1[2] == 0;
  unsigned int v6 = 5;
LABEL_15:
  if (v5) {
    return v6;
  }
  else {
    return result;
  }
}

uint64_t ProcessUTF8Portion(XMLParserAdapter *a1, char *__s1, uint64_t a3, int a4)
{
  uint64_t v5 = a3;
  uint64_t v8 = &__s1[a3];
  if (a3 >= 1)
  {
    int v9 = __s1;
    uint64_t v10 = __s1;
    while (1)
    {
      unsigned int v11 = *v9;
      if (v11 != 38 && v11 - 127 > 0xFFFFFFA0) {
        goto LABEL_30;
      }
      if ((v11 & 0x80) != 0) {
        break;
      }
      if (v11 < 0x20 || v11 == 127)
      {
        BOOL v17 = v11 > 0xD;
        int v18 = (1 << v11) & 0x2600;
        if (!v17 && v18 != 0) {
          goto LABEL_30;
        }
        (*(void (**)(XMLParserAdapter *, char *, int64_t, void))(*(void *)a1 + 16))(a1, v10, v9 - v10, 0);
        (*(void (**)(XMLParserAdapter *, const char *, uint64_t, void))(*(void *)a1 + 16))(a1, " ", 1, 0);
        goto LABEL_29;
      }
      if (v11 != 38) {
        ProcessUTF8Portion();
      }
      if ((unint64_t)(v8 - v9) >= 5)
      {
        if (strncmp(v9, "&#x", 3uLL)) {
          goto LABEL_30;
        }
        size_t v20 = v9 + 3;
        int v21 = v9[3];
        unsigned int v22 = v21 - 48;
        unsigned int v23 = v21 - 65;
        if ((v21 - 97) <= 5) {
          unsigned __int8 v24 = v21 - 87;
        }
        else {
          unsigned __int8 v24 = 0;
        }
        if ((v21 - 97) <= 5) {
          size_t v20 = v9 + 4;
        }
        unsigned __int8 v25 = v21 - 55;
        if (v23 <= 5) {
          size_t v20 = v9 + 4;
        }
        else {
          unsigned __int8 v25 = v24;
        }
        if (v22 > 9)
        {
          CFDictionaryRef v26 = (unsigned __int8 *)v20;
        }
        else
        {
          unsigned __int8 v25 = v22;
          CFDictionaryRef v26 = (unsigned __int8 *)(v9 + 4);
        }
        int v27 = *v26;
        unsigned int v28 = v27 - 48;
        unsigned int v29 = v27 - 65;
        unsigned int v30 = v27 - 97;
        char v31 = v27 + 16 * v25;
        if (v30 > 5)
        {
          CFStringRef v32 = v26;
        }
        else
        {
          unsigned __int8 v25 = v31 - 87;
          CFStringRef v32 = v26 + 1;
        }
        if (v29 > 5)
        {
          unsigned int v33 = v32;
        }
        else
        {
          unsigned __int8 v25 = v31 - 55;
          unsigned int v33 = v26 + 1;
        }
        unsigned __int8 v34 = v31 - 48;
        if (v28 <= 9)
        {
          CFStringRef v35 = v26 + 1;
        }
        else
        {
          unsigned __int8 v34 = v25;
          CFStringRef v35 = v33;
        }
        if (v35 != (unsigned __int8 *)v8)
        {
          if (*v35 != 59) {
            goto LABEL_30;
          }
          int64_t v36 = v35 - (unsigned __int8 *)v9;
          int v37 = v36 + 1;
          if ((unint64_t)(v36 + 1) < 5 || v34 <= 0xDu && ((1 << v34) & 0x2600) != 0) {
            goto LABEL_30;
          }
          if ((v37 & 0x80000000) == 0)
          {
            if (v36 != -1)
            {
              (*(void (**)(XMLParserAdapter *, char *, int64_t, void))(*(void *)a1 + 16))(a1, v10, v9 - v10, 0);
              (*(void (**)(XMLParserAdapter *, const char *, uint64_t, void))(*(void *)a1 + 16))(a1, " ", 1, 0);
              uint64_t v10 = &v9[v37];
              int v9 = v10 - 1;
            }
            goto LABEL_30;
          }
        }
      }
      if ((a4 & 1) == 0) {
        goto LABEL_72;
      }
LABEL_30:
      if (++v9 >= v8) {
        goto LABEL_66;
      }
    }
    if (v11 >= 0xC0)
    {
      unsigned int v12 = 4 * (v11 & 0x3F);
      unsigned int v13 = 2;
      if (v12 >= 0x80)
      {
        do
        {
          ++v13;
          unsigned int v12 = (2 * v12) & 0xF8;
        }
        while (v12 > 0x7F);
      }
      if (&v9[v13] <= v8)
      {
        uint64_t v38 = v13 - 1;
        float v39 = v9 + 1;
        while (1)
        {
          char v40 = *v39++;
          if ((v40 & 0xC0) != 0x80) {
            break;
          }
          if (!--v38)
          {
            v9 += v13 - 1;
            goto LABEL_30;
          }
        }
      }
      else if ((a4 & 1) == 0)
      {
LABEL_72:
        (*(void (**)(XMLParserAdapter *, char *, int64_t, void))(*(void *)a1 + 16))(a1, v10, v9 - v10, 0);
        return v9 - __s1;
      }
    }
    (*(void (**)(XMLParserAdapter *, char *, int64_t, void))(*(void *)a1 + 16))(a1, v10, v9 - v10, 0);
    uint64_t v14 = 0;
    size_t v15 = kReplaceLatin1[*v9 - 128];
    while (v15[v14])
    {
      ++v14;
      uint64_t v16 = 0xFFFFFFFFLL;
      if (v14 == 0xFFFFFFFFLL) {
        goto LABEL_28;
      }
    }
    uint64_t v16 = v14;
LABEL_28:
    (*(void (**)(XMLParserAdapter *, char *, uint64_t, void))(*(void *)a1 + 16))(a1, v15, v16, 0);
LABEL_29:
    uint64_t v10 = v9 + 1;
    goto LABEL_30;
  }
  uint64_t v10 = __s1;
  int v9 = __s1;
LABEL_66:
  if (v9 != v8) {
    ProcessUTF8Portion();
  }
  if (v10 < v8) {
    (*(void (**)(XMLParserAdapter *, char *, int64_t, void))(*(void *)a1 + 16))(a1, v10, v8 - v10, 0);
  }
  if (a4) {
    (*(void (**)(XMLParserAdapter *, const char *, uint64_t, uint64_t))(*(void *)a1 + 16))(a1, " ", 1, 1);
  }
  return v5;
}

uint64_t ExpatAdapter::ParseBuffer(uint64_t this, const char *a2, uint64_t a3, int a4)
{
  uint64_t v4 = this;
  if (a3 || a4)
  {
    if (!a3) {
      a2 = " ";
    }
    uint64_t v5 = *(XML_ParserStruct **)(this + 248);
    if (!a3) {
      LODWORD(a3) = 1;
    }
    this = XML_Parse(v5, a2, a3, a4);
    if (this != 1)
    {
      v6[0] = 201;
      v6[1] = "XML parsing failure";
      void v6[2] = 0;
      return (*(uint64_t (**)(uint64_t, void, void *))(*(void *)v4 + 32))(v4, 0, v6);
    }
  }
  return this;
}

void XMP_NewExpatAdapter()
{
}

void sub_1885AF22C(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10B3C4056A07C3ELL);
  _Unwind_Resume(a1);
}

void ExpatAdapter::ExpatAdapter(ExpatAdapter *this, int a2)
{
  *(void *)this = &unk_1ED4E3EE0;
  uint64_t v4 = (char *)this + 8;
  XML_Node::XML_Node((ExpatAdapter *)((char *)this + 8), 0, "", 0);
  *((_OWORD *)this + 10) = 0u;
  uint64_t v5 = (char **)((char *)this + 160);
  *((void *)this + 24) = 0;
  *((_OWORD *)this + 11) = 0u;
  *((_DWORD *)this + 50) = -1;
  *((void *)this + 26) = 0;
  *((void *)this + 31) = 0;
  unsigned int v6 = (XML_Parser *)((char *)this + 248);
  *((void *)this + 29) = 0;
  *((void *)this + 30) = 0;
  *(void *)this = &unk_1ED4DF138;
  *((void *)this + 32) = 0;
  *((void *)this + 33) = 0;
  NS = XML_ParserCreateNS(0, 64);
  *((void *)this + 31) = NS;
  if (NS)
  {
    if (!a2) {
      operator new();
    }
    *((void *)this + 32) = sRegisteredNamespaces;
    XML_SetUserData(NS, this);
    XML_SetNamespaceDeclHandler(*v6, (XML_StartNamespaceDeclHandler)StartNamespaceDeclHandler, (XML_EndNamespaceDeclHandler)EndNamespaceDeclHandler);
    XML_SetElementHandler(*v6, (XML_StartElementHandler)StartElementHandler, (XML_EndElementHandler)EndElementHandler);
    XML_SetCharacterDataHandler(*v6, (XML_CharacterDataHandler)CharacterDataHandler);
    XML_SetCdataSectionHandler(*v6, (XML_StartCdataSectionHandler)StartCdataSectionHandler, (XML_EndCdataSectionHandler)EndCdataSectionHandler);
    XML_SetProcessingInstructionHandler(*v6, (XML_ProcessingInstructionHandler)ProcessingInstructionHandler);
    XML_SetCommentHandler(*v6, (XML_CommentHandler)CommentHandler);
    unint64_t v8 = *((void *)this + 22);
    int v9 = (void *)*((void *)this + 21);
    if ((unint64_t)v9 >= v8)
    {
      uint64_t v11 = ((char *)v9 - *v5) >> 3;
      if ((unint64_t)(v11 + 1) >> 61) {
        std::vector<IIOTag *>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v12 = v8 - (void)*v5;
      uint64_t v13 = v12 >> 2;
      if (v12 >> 2 <= (unint64_t)(v11 + 1)) {
        uint64_t v13 = v11 + 1;
      }
      if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v13;
      }
      if (v14) {
        size_t v15 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<IIOTag *>>((uint64_t)this + 176, v14);
      }
      else {
        size_t v15 = 0;
      }
      uint64_t v16 = &v15[8 * v11];
      BOOL v17 = &v15[8 * v14];
      *(void *)uint64_t v16 = v4;
      uint64_t v10 = v16 + 8;
      uint64_t v19 = (char *)*((void *)this + 20);
      int v18 = (char *)*((void *)this + 21);
      if (v18 != v19)
      {
        do
        {
          uint64_t v20 = *((void *)v18 - 1);
          v18 -= 8;
          *((void *)v16 - 1) = v20;
          v16 -= 8;
        }
        while (v18 != v19);
        int v18 = *v5;
      }
      *((void *)this + 20) = v16;
      *((void *)this + 21) = v10;
      *((void *)this + 22) = v17;
      if (v18) {
        operator delete(v18);
      }
    }
    else
    {
      *int v9 = v4;
      uint64_t v10 = v9 + 1;
    }
    *((void *)this + 21) = v10;
  }
  else
  {
    v21[0] = 15;
    v21[1] = "Failure creating Expat parser";
    v21[2] = 0;
    (*(void (**)(ExpatAdapter *, uint64_t, void *))(*(void *)this + 32))(this, 3, v21);
  }
}

void sub_1885AF538(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v2, 0x10A1C40F44AF5F3);
  XMLParserAdapter::~XMLParserAdapter(v1);
  _Unwind_Resume(a1);
}

void XMPMeta::ProcessXMLTree(XMPMeta *this, char a2)
{
  uint64_t v4 = (void *)*((void *)this + 43);
  if (v4[24] < 2uLL)
  {
    uint64_t v5 = v4[23];
    if (!v5) {
      return;
    }
  }
  else
  {
    uint64_t v5 = PickBestRoot((const XML_Node *)(v4 + 1), a2);
    if (!v5) {
      return;
    }
  }
  uint64_t v6 = v5 + 40;
  int v7 = *(char *)(v5 + 63);
  if (v7 < 0)
  {
    if (*(void *)(v5 + 48) != 7) {
      goto LABEL_42;
    }
    uint64_t v6 = *(void *)v6;
  }
  else if (v7 != 7)
  {
    goto LABEL_42;
  }
  int v8 = *(_DWORD *)v6;
  int v9 = *(_DWORD *)(v6 + 3);
  if (v8 != 979788914 || v9 != 1178882618) {
LABEL_42:
  }
    XMPMeta::ProcessXMLTree();
  if ((a2 & 1) == 0) {
    goto LABEL_16;
  }
  uint64_t v19 = *(void *)(v5 + 96);
  if (!v19) {
    return;
  }
  uint64_t v20 = (uint64_t *)(v19 + 40);
  int v21 = *(char *)(v19 + 63);
  if (v21 < 0)
  {
    if (*(void *)(v19 + 48) != 9) {
      return;
    }
    uint64_t v20 = (uint64_t *)*v20;
  }
  else if (v21 != 9)
  {
    return;
  }
  BOOL v22 = *v20 == 0x74656D706D783A78 && *((unsigned char *)v20 + 8) == 97;
  if (v22
    || ((unsigned int v23 = (uint64_t *)*v20, v24 = *((unsigned __int8 *)v20 + 8), v23 == (uint64_t *)0x74656D7061783A78)
      ? (BOOL v25 = v24 == 97)
      : (BOOL v25 = 0),
        v25))
  {
LABEL_16:
    XMPMeta::ProcessRDF((size_t *)this, (const XML_Node *)v5);
    NormalizeDCArrays((XMPMeta *)((char *)this + 224));
    if ((*((unsigned char *)this + 234) & 2) != 0) {
      MoveExplicitAliases((XMPMeta *)((char *)this + 224), a2, (XMPMeta *)((char *)this + 352));
    }
    TouchUpDataModel(this, v11);
    uint64_t v12 = *((void *)this + 37);
    uint64_t v13 = *((void *)this + 38);
    if (v13 != v12)
    {
      unint64_t v14 = 0;
      do
      {
        size_t v15 = *(void **)(v12 + 8 * v14);
        if (v15[10] == v15[9])
        {
          (*(void (**)(void *))(*v15 + 8))(v15);
          uint64_t v12 = *((void *)this + 37);
          uint64_t v16 = *((void *)this + 38);
          uint64_t v17 = v12 + 8 * v14;
          uint64_t v18 = v16 - (v17 + 8);
          if (v16 != v17 + 8)
          {
            memmove((void *)(v12 + 8 * v14), (const void *)(v17 + 8), v16 - (v17 + 8));
            uint64_t v12 = *((void *)this + 37);
          }
          uint64_t v13 = v17 + v18;
          *((void *)this + 38) = v17 + v18;
        }
        else
        {
          ++v14;
        }
      }
      while (v14 < (v13 - v12) >> 3);
    }
  }
}

void XMPMeta::ProcessRDF(size_t *this, const XML_Node *a2)
{
  uint64_t v2 = (char *)(this + 44);
  RDF_Parser::RDF((RDF *)&v2, this + 28, a2);
}

void ExpatAdapter::~ExpatAdapter(ExpatAdapter *this)
{
  ExpatAdapter::~ExpatAdapter(this);

  JUMPOUT(0x18C11C0E0);
}

{
  XML_ParserStruct *v2;
  uint64_t v3;
  BOOL v4;
  uint64_t vars8;

  *(void *)this = &unk_1ED4DF138;
  uint64_t v2 = (XML_ParserStruct *)*((void *)this + 31);
  if (v2) {
    XML_ParserFree(v2);
  }
  *((void *)this + 31) = 0;
  uint64_t v3 = *((void *)this + 32);
  if (v3) {
    uint64_t v4 = v3 == sRegisteredNamespaces;
  }
  else {
    uint64_t v4 = 1;
  }
  if (!v4) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  *((void *)this + 32) = 0;

  XMLParserAdapter::~XMLParserAdapter(this);
}

void RDF_Parser::RDF(RDF *this, size_t *a2, const XML_Node *a3)
{
  if (*((void *)a3 + 13) != *((void *)a3 + 14))
  {
    v6[0] = 202;
    v6[1] = "Invalid attributes of rdf:RDF element";
    void v6[2] = 0;
    GenericErrorCallback::NotifyClient(*(void *)this, 0, (unsigned int *)v6, 0);
  }
  RDF_Parser::NodeElementList(this, a2, a3, 1);
}

uint64_t NormalizeDCArrays(XMP_Node *a1)
{
  uint64_t result = FindSchemaNode(a1, "http://purl.org/dc/elements/1.1/", 0, 0);
  if (result)
  {
    uint64_t v2 = result;
    uint64_t v3 = *(void *)(result + 80) - *(void *)(result + 72);
    if (v3)
    {
      uint64_t v4 = 0;
      unint64_t v5 = v3 >> 3;
      if (v5 <= 1) {
        uint64_t v6 = 1;
      }
      else {
        uint64_t v6 = v5;
      }
      do
      {
        uint64_t v7 = *(void *)(*(void *)(v2 + 72) + 8 * v4);
        if ((*(unsigned char *)(v7 + 9) & 0x1F) == 0)
        {
          int v8 = (uint64_t **)(v7 + 16);
          if ((*(char *)(v7 + 39) & 0x80000000) == 0)
          {
            int v9 = *(unsigned __int8 *)(v7 + 39);
            switch(*(unsigned char *)(v7 + 39))
            {
              case 7:
                int v10 = *(_DWORD *)(v7 + 19);
                BOOL v11 = *(_DWORD *)v8 == 1681548132;
                int v12 = 1702125924;
                goto LABEL_60;
              case 8:
                goto LABEL_76;
              case 9:
LABEL_71:
                if (*v8 == (uint64_t *)0x74686769723A6364 && *(unsigned char *)(v7 + 24) == 115) {
                  goto LABEL_77;
                }
                if (v9 != 8) {
                  goto LABEL_95;
                }
LABEL_76:
                if (*v8 == (uint64_t *)0x656C7469743A6364) {
                  goto LABEL_77;
                }
                goto LABEL_95;
              case 0xA:
                int v10 = *(unsigned __int16 *)(v7 + 24);
                BOOL v11 = *v8 == (uint64_t *)0x74616572633A6364;
                int v12 = 29295;
LABEL_60:
                if (!v11 || v10 != v12) {
                  goto LABEL_95;
                }
                goto LABEL_65;
              case 0xB:
LABEL_84:
                uint64_t v27 = *(void *)(v7 + 19);
                BOOL v28 = *v8 == (uint64_t *)0x75676E616C3A6364;
                uint64_t v29 = 0x65676175676E616CLL;
                goto LABEL_86;
              case 0xC:
LABEL_85:
                uint64_t v27 = *(unsigned int *)(v7 + 24);
                BOOL v28 = *v8 == (uint64_t *)0x696C6275703A6364;
                uint64_t v29 = 1919248499;
LABEL_86:
                if (v28 && v27 == v29) {
                  goto LABEL_97;
                }
                int v21 = (uint64_t *)(v7 + 16);
                if (v9 == 11) {
                  goto LABEL_91;
                }
                goto LABEL_95;
              case 0xE:
                if (*v8 != (uint64_t *)0x72637365643A6364 || *(void *)(v7 + 22) != 0x6E6F697470697263)
                {
                  switch(*(unsigned char *)(v7 + 39))
                  {
                    case 8:
                      goto LABEL_76;
                    case 9:
                      goto LABEL_71;
                    case 0xB:
                      goto LABEL_84;
                    case 0xC:
                      goto LABEL_85;
                    case 0xE:
                      if (*v8 == (uint64_t *)0x72746E6F633A6364 && *(void *)(v7 + 22) == 0x726F747562697274) {
                        goto LABEL_97;
                      }
                      if (v9 == 12) {
                        goto LABEL_85;
                      }
                      if (v9 == 11) {
                        goto LABEL_84;
                      }
                      goto LABEL_95;
                    default:
                      goto LABEL_95;
                  }
                }
                goto LABEL_77;
              default:
                goto LABEL_95;
            }
          }
          uint64_t v13 = *(void *)(v7 + 24);
          if (v13 == 7)
          {
            if (*(_DWORD *)*v8 == 1681548132 && *(_DWORD *)((char *)*v8 + 3) == 1702125924)
            {
LABEL_65:
              unsigned int v23 = 1024;
              goto LABEL_98;
            }
            uint64_t v13 = *(void *)(v7 + 24);
          }
          else if (v13 == 10 && **v8 == 0x74616572633A6364 && *((_WORD *)*v8 + 4) == 29295)
          {
            goto LABEL_65;
          }
          if (v13 == 14)
          {
            if (**v8 == 0x72637365643A6364 && *(uint64_t *)((char *)*v8 + 6) == 0x6E6F697470697263)
            {
LABEL_77:
              unsigned int v23 = 4096;
              goto LABEL_98;
            }
            uint64_t v13 = *(void *)(v7 + 24);
          }
          if (v13 == 9)
          {
            if (**v8 == 0x74686769723A6364 && *((unsigned char *)*v8 + 8) == 115) {
              goto LABEL_77;
            }
            uint64_t v13 = *(void *)(v7 + 24);
          }
          if (v13 == 8)
          {
            if (**v8 == 0x656C7469743A6364) {
              goto LABEL_77;
            }
            uint64_t v13 = *(void *)(v7 + 24);
          }
          if (v13 == 14)
          {
            if (**v8 == 0x72746E6F633A6364 && *(uint64_t *)((char *)*v8 + 6) == 0x726F747562697274) {
              goto LABEL_97;
            }
            uint64_t v13 = *(void *)(v7 + 24);
          }
          if (v13 == 11)
          {
            if (**v8 == 0x75676E616C3A6364 && *(uint64_t *)((char *)*v8 + 3) == 0x65676175676E616CLL) {
              goto LABEL_97;
            }
            uint64_t v13 = *(void *)(v7 + 24);
          }
          if (v13 == 12)
          {
            if (**v8 == 0x696C6275703A6364 && *((_DWORD *)*v8 + 2) == 1919248499) {
              goto LABEL_97;
            }
            uint64_t v13 = *(void *)(v7 + 24);
          }
          if (v13 == 11)
          {
            int v21 = *v8;
LABEL_91:
            uint64_t v31 = *v21;
            uint64_t v32 = *(uint64_t *)((char *)v21 + 3);
            if (v31 == 0x74616C65723A6364 && v32 == 0x6E6F6974616C6572)
            {
LABEL_97:
              unsigned int v23 = 512;
LABEL_98:
              VerifySetOptions(v23, 0);
              operator new();
            }
          }
LABEL_95:
          if (std::operator==[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>((void *)(v7 + 16), "dc:subject"))
          {
            goto LABEL_97;
          }
          uint64_t result = std::operator==[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>((void *)(v7 + 16), "dc:type");
          if (result) {
            goto LABEL_97;
          }
        }
        ++v4;
      }
      while (v4 != v6);
    }
  }
  return result;
}

void sub_1885B0054(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10B3C407D34617ELL);
  _Unwind_Resume(a1);
}

void std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::destroy(uint64_t a1, void *a2)
{
  if (a2)
  {
    std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::destroy(a1, *a2);
    std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::destroy(a1, a2[1]);
    std::__destroy_at[abi:ne180100]<std::pair<std::string const,std::string>,0>((uint64_t)(a2 + 4));
    operator delete(a2);
  }
}

void std::__destroy_at[abi:ne180100]<std::pair<std::string const,std::string>,0>(uint64_t a1)
{
  if (*(char *)(a1 + 47) < 0) {
    operator delete(*(void **)(a1 + 24));
  }
  if (*(char *)(a1 + 23) < 0)
  {
    uint64_t v2 = *(void **)a1;
    operator delete(v2);
  }
}

void XMPIterator::~XMPIterator(XMPIterator *this)
{
  *(void *)this = &unk_1ED4DEEC8;
  if (*((int *)this + 2) >= 1) {
    __assert_rtn("~XMPIterator", "XMPIterator.cpp", 506, "this->clientRefs <= 0");
  }
  uint64_t v3 = (void **)((char *)this + 368);
  std::vector<IterNode>::__destroy_vector::operator()[abi:ne180100](&v3);
  uint64_t v3 = (void **)((char *)this + 344);
  std::vector<IterNode>::__destroy_vector::operator()[abi:ne180100](&v3);
  if (*((char *)this + 335) < 0) {
    operator delete(*((void **)this + 39));
  }
  uint64_t v2 = (void *)*((void *)this + 35);
  if (v2)
  {
    *((void *)this + 36) = v2;
    operator delete(v2);
  }
  if (*((char *)this + 263) < 0) {
    operator delete(*((void **)this + 30));
  }
  XMP_ReadWriteLock::~XMP_ReadWriteLock((XMPIterator *)((char *)this + 16));
}

{
  uint64_t vars8;

  XMPIterator::~XMPIterator(this);

  JUMPOUT(0x18C11C0E0);
}

void XMP_ReadWriteLock::~XMP_ReadWriteLock(XMP_ReadWriteLock *this)
{
  if (atomic_load((unsigned int *)this + 50))
  {
    uint64_t v2 = "this->lockCount == 0";
    int v3 = 70;
    goto LABEL_6;
  }
  if (pthread_rwlock_destroy((pthread_rwlock_t *)this))
  {
    uint64_t v2 = "err == 0";
    int v3 = 72;
LABEL_6:
    __assert_rtn("~XMP_ReadWriteLock", "XMP_LibUtils.cpp", v3, v2);
  }
}

void XMPIterator::XMPIterator(XMPIterator *this, const XMPMeta *a2, char *a3, char *a4, int a5)
{
  *(void *)this = &unk_1ED4DEEC8;
  *((_DWORD *)this + 2) = 0;
  XMP_ReadWriteLock::XMP_ReadWriteLock((XMPIterator *)((char *)this + 16));
  *((_DWORD *)this + 56) = a5;
  *((_OWORD *)this + 15) = 0u;
  *((void *)this + 29) = a2;
  *(_OWORD *)((char *)this + 312) = 0u;
  *(_OWORD *)((char *)this + 328) = 0u;
  *(_OWORD *)((char *)this + 344) = 0u;
  *(_OWORD *)((char *)this + 360) = 0u;
  *(_OWORD *)((char *)this + 376) = 0u;
  *((unsigned char *)this + 392) = 0;
  *((_OWORD *)this + 16) = 0u;
  *((_OWORD *)this + 17) = 0u;
  *((_OWORD *)this + 18) = 0u;
  *((_DWORD *)this + 76) = 0;
  if ((_BYTE)a5)
  {
    exception = __cxa_allocate_exception(0x18uLL);
    *(_DWORD *)exception = 103;
    exception[1] = "Unsupported iteration kind";
    *((unsigned char *)exception + 16) = 0;
  }
  unsigned int v52 = a3;
  if (*a4)
  {
    memset(&v59, 0, sizeof(v59));
    ExpandXPath(a3, a4, (uint64_t *)&v59);
    Node = (const XMP_Node *)FindNode((void *)a2 + 28, (const void ***)&v59, 0, 0, 0);
    if (Node)
    {
      memset(&v58, 0, sizeof(v58));
      std::string::size_type v11 = v59.__r_.__value_.__r.__words[0];
      if (*(char *)(v59.__r_.__value_.__r.__words[0] + 55) < 0)
      {
        std::string::__init_copy_ctor_external(&v58, *(const std::string::value_type **)(v59.__r_.__value_.__r.__words[0] + 32), *(void *)(v59.__r_.__value_.__r.__words[0] + 40));
        std::string::size_type v11 = v59.__r_.__value_.__r.__words[0];
      }
      else
      {
        std::string v58 = *(std::string *)(v59.__r_.__value_.__r.__words[0] + 32);
      }
      if (v59.__r_.__value_.__l.__size_ - v11 >= 0x41)
      {
        uint64_t v12 = 0;
        unint64_t v13 = 2;
        do
        {
          if ((*(_DWORD *)(v11 + v12 + 88) & 0xFu) <= 2)
          {
            std::string::push_back(&v58, 47);
            std::string::size_type v11 = v59.__r_.__value_.__r.__words[0];
          }
          std::string::size_type v14 = v11 + v12;
          uint64_t v17 = *(const std::string::value_type **)(v14 + 64);
          std::string::size_type v15 = v14 + 64;
          uint64_t v16 = v17;
          int v18 = *(char *)(v15 + 23);
          if (v18 >= 0) {
            uint64_t v19 = (const std::string::value_type *)v15;
          }
          else {
            uint64_t v19 = v16;
          }
          if (v18 >= 0) {
            std::string::size_type v20 = *(unsigned __int8 *)(v15 + 23);
          }
          else {
            std::string::size_type v20 = *(void *)(v15 + 8);
          }
          std::string::append(&v58, v19, v20);
          ++v13;
          std::string::size_type v11 = v59.__r_.__value_.__r.__words[0];
          v12 += 32;
        }
        while (v13 < (uint64_t)(v59.__r_.__value_.__l.__size_ - v59.__r_.__value_.__r.__words[0]) >> 5);
      }
      std::string::size_type size = HIBYTE(v58.__r_.__value_.__r.__words[2]);
      if ((v58.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        BOOL v22 = &v58;
      }
      else {
        BOOL v22 = (std::string *)v58.__r_.__value_.__r.__words[0];
      }
      if ((v58.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        std::string::size_type size = v58.__r_.__value_.__l.__size_;
      }
      for (; size; --size)
      {
        int v23 = v22->__r_.__value_.__s.__data_[size];
        if (v23 == 47) {
          break;
        }
        if (v23 == 91) {
          break;
        }
      }
      if (v22->__r_.__value_.__s.__data_[size] == 47) {
        std::string::size_type v24 = size + 1;
      }
      else {
        std::string::size_type v24 = size;
      }
      int v25 = *((_DWORD *)Node + 2);
      std::string::basic_string[abi:ne180100]<0>(&v54, (char *)v22);
      LODWORD(v55) = v25;
      if (SHIBYTE(v54.__r_.__value_.__r.__words[2]) < 0) {
        std::string::__init_copy_ctor_external(&__p, v54.__r_.__value_.__l.__data_, v54.__r_.__value_.__l.__size_);
      }
      else {
        std::string __p = v54;
      }
      *(void *)&v57[0] = v24;
      memset((char *)v57 + 8, 0, 49);
      unint64_t v26 = *((void *)this + 44);
      if (v26 >= *((void *)this + 45))
      {
        uint64_t v28 = std::vector<IterNode>::__push_back_slow_path<IterNode>((uint64_t *)this + 43, (uint64_t)&v55);
      }
      else
      {
        *(_DWORD *)unint64_t v26 = v55;
        long long v27 = *(_OWORD *)&__p.__r_.__value_.__l.__data_;
        *(void *)(v26 + 24) = *((void *)&__p.__r_.__value_.__l + 2);
        *(_OWORD *)(v26 + 8) = v27;
        memset(&__p, 0, sizeof(__p));
        *(void *)(v26 + 32) = *(void *)&v57[0];
        *(void *)(v26 + 40) = 0;
        *(void *)(v26 + 48) = 0;
        *(void *)(v26 + 56) = 0;
        *(_OWORD *)(v26 + 40) = *(_OWORD *)((char *)v57 + 8);
        *((void *)&v57[0] + 1) = 0;
        *(void *)&v57[1] = 0;
        *(void *)(v26 + 56) = *((void *)&v57[1] + 1);
        *(void *)(v26 + 64) = 0;
        *((void *)&v57[1] + 1) = 0;
        *(void *)(v26 + 72) = 0;
        *(void *)(v26 + 80) = 0;
        *(_OWORD *)(v26 + 64) = v57[2];
        *(void *)(v26 + 80) = *(void *)&v57[3];
        memset(&v57[2], 0, 24);
        *(unsigned char *)(v26 + 88) = BYTE8(v57[3]);
        uint64_t v28 = v26 + 96;
      }
      *((void *)this + 44) = v28;
      v60[0] = (void **)&v57[2];
      std::vector<IterNode>::__destroy_vector::operator()[abi:ne180100](v60);
      v60[0] = (void **)v57 + 1;
      std::vector<IterNode>::__destroy_vector::operator()[abi:ne180100](v60);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v54.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v54.__r_.__value_.__l.__data_);
      }
      MEMORY[0x18C11BE10]((char *)this + 240);
      if (*((unsigned char *)this + 225)) {
        AddNodeOffspring((XMPIterator *)((char *)this + 224), (IterNode *)(*((void *)this + 44) - 96), Node);
      }
      if (SHIBYTE(v58.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v58.__r_.__value_.__l.__data_);
      }
    }
    uint64_t v55 = &v59;
    std::vector<XPathStepInfo>::__destroy_vector::operator()[abi:ne180100]((void ***)&v55);
  }
  else if (*a3)
  {
    std::string::basic_string[abi:ne180100]<0>(&v59, a3);
    LODWORD(v55) = 0x80000000;
    if (SHIBYTE(v59.__r_.__value_.__r.__words[2]) < 0) {
      std::string::__init_copy_ctor_external(&__p, v59.__r_.__value_.__l.__data_, v59.__r_.__value_.__l.__size_);
    }
    else {
      std::string __p = v59;
    }
    memset(v57, 0, 57);
    unint64_t v45 = *((void *)this + 44);
    if (v45 >= *((void *)this + 45))
    {
      uint64_t v47 = std::vector<IterNode>::__push_back_slow_path<IterNode>((uint64_t *)this + 43, (uint64_t)&v55);
    }
    else
    {
      *(_DWORD *)unint64_t v45 = v55;
      long long v46 = *(_OWORD *)&__p.__r_.__value_.__l.__data_;
      *(void *)(v45 + 24) = *((void *)&__p.__r_.__value_.__l + 2);
      *(_OWORD *)(v45 + 8) = v46;
      memset(&__p, 0, sizeof(__p));
      *(void *)(v45 + 32) = *(void *)&v57[0];
      *(void *)(v45 + 40) = 0;
      *(void *)(v45 + 48) = 0;
      *(void *)(v45 + 56) = 0;
      *(_OWORD *)(v45 + 40) = *(_OWORD *)((char *)v57 + 8);
      *((void *)&v57[0] + 1) = 0;
      *(void *)&v57[1] = 0;
      *(void *)(v45 + 56) = *((void *)&v57[1] + 1);
      *(void *)(v45 + 64) = 0;
      *((void *)&v57[1] + 1) = 0;
      *(void *)(v45 + 72) = 0;
      *(void *)(v45 + 80) = 0;
      *(_OWORD *)(v45 + 64) = v57[2];
      *(void *)(v45 + 80) = *(void *)&v57[3];
      memset(&v57[2], 0, 24);
      *(unsigned char *)(v45 + 88) = BYTE8(v57[3]);
      uint64_t v47 = v45 + 96;
    }
    *((void *)this + 44) = v47;
    v58.__r_.__value_.__r.__words[0] = (std::string::size_type)&v57[2];
    std::vector<IterNode>::__destroy_vector::operator()[abi:ne180100]((void ***)&v58);
    v58.__r_.__value_.__r.__words[0] = (std::string::size_type)v57 + 8;
    std::vector<IterNode>::__destroy_vector::operator()[abi:ne180100]((void ***)&v58);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v59.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v59.__r_.__value_.__l.__data_);
    }
    uint64_t v48 = *((void *)this + 44);
    SchemaNode = (IterNode *)FindSchemaNode((void *)a2 + 28, a3, 0, 0);
    if (SchemaNode) {
      AddSchemaProps((IterInfo *)(v48 - 96), SchemaNode, v50);
    }
    if (*(void *)(v48 - 56) == *(void *)(v48 - 48)) {
      std::vector<IterNode>::__base_destruct_at_end[abi:ne180100]((uint64_t)this + 344, (void **)(*((void *)this + 44) - 96));
    }
    else {
      MEMORY[0x18C11BE10]((char *)this + 240, a3);
    }
  }
  else
  {
    uint64_t v31 = *((void *)a2 + 38) - *((void *)a2 + 37);
    if (v31)
    {
      uint64_t v32 = 0;
      uint64_t v33 = v31 >> 3;
      unsigned int v53 = (uint64_t *)((char *)this + 344);
      do
      {
        uint64_t v34 = *(void *)(*((void *)a2 + 37) + 8 * v32);
        LODWORD(v55) = 0x80000000;
        if (*(char *)(v34 + 39) < 0)
        {
          std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)(v34 + 16), *(void *)(v34 + 24));
        }
        else
        {
          long long v35 = *(_OWORD *)(v34 + 16);
          __p.__r_.__value_.__r.__words[2] = *(void *)(v34 + 32);
          *(_OWORD *)&__p.__r_.__value_.__l.__data_ = v35;
        }
        memset(v57, 0, 57);
        unint64_t v36 = *((void *)this + 44);
        if (v36 >= *((void *)this + 45))
        {
          uint64_t v38 = std::vector<IterNode>::__push_back_slow_path<IterNode>(v53, (uint64_t)&v55);
        }
        else
        {
          *(_DWORD *)unint64_t v36 = v55;
          long long v37 = *(_OWORD *)&__p.__r_.__value_.__l.__data_;
          *(void *)(v36 + 24) = *((void *)&__p.__r_.__value_.__l + 2);
          *(_OWORD *)(v36 + 8) = v37;
          memset(&__p, 0, sizeof(__p));
          *(void *)(v36 + 32) = *(void *)&v57[0];
          *(void *)(v36 + 40) = 0;
          *(void *)(v36 + 48) = 0;
          *(void *)(v36 + 56) = 0;
          *(_OWORD *)(v36 + 40) = *(_OWORD *)((char *)v57 + 8);
          *((void *)&v57[0] + 1) = 0;
          *(void *)&v57[1] = 0;
          *(void *)(v36 + 56) = *((void *)&v57[1] + 1);
          *(void *)(v36 + 64) = 0;
          *((void *)&v57[1] + 1) = 0;
          *(void *)(v36 + 72) = 0;
          *(void *)(v36 + 80) = 0;
          *(_OWORD *)(v36 + 64) = v57[2];
          *(void *)(v36 + 80) = *(void *)&v57[3];
          memset(&v57[2], 0, 24);
          *(unsigned char *)(v36 + 88) = BYTE8(v57[3]);
          uint64_t v38 = v36 + 96;
        }
        *((void *)this + 44) = v38;
        v59.__r_.__value_.__r.__words[0] = (std::string::size_type)&v57[2];
        std::vector<IterNode>::__destroy_vector::operator()[abi:ne180100]((void ***)&v59);
        v59.__r_.__value_.__r.__words[0] = (std::string::size_type)v57 + 8;
        std::vector<IterNode>::__destroy_vector::operator()[abi:ne180100]((void ***)&v59);
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__p.__r_.__value_.__l.__data_);
        }
        if ((*((unsigned char *)this + 225) & 1) == 0)
        {
          uint64_t v40 = v33;
          uint64_t v41 = a2;
          uint64_t v42 = *((void *)this + 44);
          AddSchemaProps((IterInfo *)(v42 - 96), (IterNode *)v34, v39);
          uint64_t v43 = *(void *)(v42 - 56);
          uint64_t v44 = *(void *)(v42 - 48);
          a2 = v41;
          uint64_t v33 = v40;
          if (v43 == v44) {
            std::vector<IterNode>::__base_destruct_at_end[abi:ne180100]((uint64_t)v53, (void **)(*((void *)this + 44) - 96));
          }
        }
        ++v32;
      }
      while (v33 != v32);
    }
  }
  uint64_t v29 = *((void *)this + 43);
  uint64_t v30 = *((void *)this + 44);
  *((void *)this + 33) = v29;
  *((void *)this + 34) = v30;
  if ((*((unsigned char *)this + 225) & 1) != 0 && v29 != v30)
  {
    if (*v52) {
      *(unsigned char *)(v29 + 88) = 1;
    }
  }
}

void sub_1885B09F0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void **a10, XMP_ReadWriteLock *a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19, uint64_t a20)
{
  if (*(char *)(v20 - 97) < 0) {
    operator delete(*(void **)(v20 - 120));
  }
  IterInfo::~IterInfo(a10);
  XMP_ReadWriteLock::~XMP_ReadWriteLock(a11);
  _Unwind_Resume(a1);
}

void AddSchemaProps(IterInfo *a1, IterNode *a2, const XMP_Node *a3)
{
  uint64_t v3 = *((void *)a2 + 10) - *((void *)a2 + 9);
  if (v3)
  {
    uint64_t v6 = 0;
    uint64_t v7 = v3 >> 3;
    int v8 = (uint64_t *)((char *)a1 + 40);
    do
    {
      uint64_t v9 = *(void *)(*((void *)a2 + 9) + 8 * v6);
      int v14 = *(_DWORD *)(v9 + 8);
      if (*(char *)(v9 + 39) < 0)
      {
        std::string::__init_copy_ctor_external((std::string *)__p, *(const std::string::value_type **)(v9 + 16), *(void *)(v9 + 24));
      }
      else
      {
        long long v10 = *(_OWORD *)(v9 + 16);
        *(void *)&__p[16] = *(void *)(v9 + 32);
        *(_OWORD *)std::string __p = v10;
      }
      memset(v16, 0, 25);
      memset(&__p[24], 0, 32);
      unint64_t v11 = *((void *)a1 + 6);
      if (v11 >= *((void *)a1 + 7))
      {
        uint64_t v13 = std::vector<IterNode>::__push_back_slow_path<IterNode>(v8, (uint64_t)&v14);
      }
      else
      {
        *(_DWORD *)unint64_t v11 = v14;
        long long v12 = *(_OWORD *)__p;
        *(void *)(v11 + 24) = *(void *)&__p[16];
        *(_OWORD *)(v11 + 8) = v12;
        memset(__p, 0, 24);
        *(void *)(v11 + 32) = *(void *)&__p[24];
        *(void *)(v11 + 40) = 0;
        *(void *)(v11 + 48) = 0;
        *(void *)(v11 + 56) = 0;
        *(_OWORD *)(v11 + 40) = *(_OWORD *)&__p[32];
        *(_OWORD *)&__p[32] = 0uLL;
        *(void *)(v11 + 56) = *(void *)&__p[48];
        *(void *)(v11 + 64) = 0;
        *(void *)&__p[48] = 0;
        *(void *)(v11 + 72) = 0;
        *(void *)(v11 + 80) = 0;
        *(_OWORD *)(v11 + 64) = v16[0];
        *(void *)(v11 + 80) = *(void *)&v16[1];
        memset(v16, 0, 24);
        *(unsigned char *)(v11 + 88) = BYTE8(v16[1]);
        uint64_t v13 = v11 + 96;
      }
      *((void *)a1 + 6) = v13;
      uint64_t v17 = (void **)v16;
      std::vector<IterNode>::__destroy_vector::operator()[abi:ne180100](&v17);
      uint64_t v17 = (void **)&__p[32];
      std::vector<IterNode>::__destroy_vector::operator()[abi:ne180100](&v17);
      if ((__p[23] & 0x80000000) != 0) {
        operator delete(*(void **)__p);
      }
      ++v6;
    }
    while (v7 != v6);
  }
}

void sub_1885B0C4C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  IterNode::~IterNode((void **)va);
  _Unwind_Resume(a1);
}

uint64_t std::vector<IterNode>::__push_back_slow_path<IterNode>(uint64_t *a1, uint64_t a2)
{
  unint64_t v3 = 0xAAAAAAAAAAAAAAABLL * ((a1[1] - *a1) >> 5);
  unint64_t v4 = v3 + 1;
  if (v3 + 1 > 0x2AAAAAAAAAAAAAALL) {
    std::vector<IIOTag *>::__throw_length_error[abi:ne180100]();
  }
  if (0x5555555555555556 * ((a1[2] - *a1) >> 5) > v4) {
    unint64_t v4 = 0x5555555555555556 * ((a1[2] - *a1) >> 5);
  }
  if (0xAAAAAAAAAAAAAAABLL * ((a1[2] - *a1) >> 5) >= 0x155555555555555) {
    unint64_t v6 = 0x2AAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v6 = v4;
  }
  int v14 = a1 + 2;
  if (v6) {
    uint64_t v7 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<IterNode>>((uint64_t)(a1 + 2), v6);
  }
  else {
    uint64_t v7 = 0;
  }
  long long v10 = v7;
  unint64_t v11 = &v7[96 * v3];
  uint64_t v13 = &v7[96 * v6];
  std::allocator<IterNode>::construct[abi:ne180100]<IterNode,IterNode>((uint64_t)(a1 + 2), (uint64_t)v11, a2);
  long long v12 = v11 + 96;
  std::vector<IterNode>::__swap_out_circular_buffer(a1, &v10);
  uint64_t v8 = a1[1];
  std::__split_buffer<IterNode>::~__split_buffer((uint64_t)&v10);
  return v8;
}

void sub_1885B0D58(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<IterNode>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

__n128 std::allocator<IterNode>::construct[abi:ne180100]<IterNode,IterNode>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(_DWORD *)a2 = *(_DWORD *)a3;
  long long v3 = *(_OWORD *)(a3 + 8);
  *(void *)(a2 + 24) = *(void *)(a3 + 24);
  *(_OWORD *)(a2 + 8) = v3;
  *(void *)(a3 + 16) = 0;
  *(void *)(a3 + 24) = 0;
  *(void *)(a3 + 8) = 0;
  *(void *)(a2 + 32) = *(void *)(a3 + 32);
  *(void *)(a2 + 40) = 0;
  *(void *)(a2 + 48) = 0;
  *(void *)(a2 + 56) = 0;
  *(_OWORD *)(a2 + 40) = *(_OWORD *)(a3 + 40);
  *(void *)(a2 + 56) = *(void *)(a3 + 56);
  *(void *)(a3 + 40) = 0;
  *(void *)(a3 + 48) = 0;
  *(void *)(a3 + 56) = 0;
  *(void *)(a2 + 64) = 0;
  *(void *)(a2 + 72) = 0;
  *(void *)(a2 + 80) = 0;
  __n128 result = *(__n128 *)(a3 + 64);
  *(__n128 *)(a2 + 64) = result;
  *(void *)(a2 + 80) = *(void *)(a3 + 80);
  *(void *)(a3 + 64) = 0;
  *(void *)(a3 + 72) = 0;
  *(void *)(a3 + 80) = 0;
  *(unsigned char *)(a2 + 88) = *(unsigned char *)(a3 + 88);
  return result;
}

uint64_t std::vector<IterNode>::__swap_out_circular_buffer(uint64_t *a1, void *a2)
{
  uint64_t result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<IterNode>,std::reverse_iterator<IterNode*>,std::reverse_iterator<IterNode*>,std::reverse_iterator<IterNode*>>((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<IterNode>,std::reverse_iterator<IterNode*>,std::reverse_iterator<IterNode*>,std::reverse_iterator<IterNode*>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&long long v16 = a6;
  *((void *)&v16 + 1) = a7;
  long long v15 = v16;
  v13[0] = a1;
  v13[1] = &v15;
  v13[2] = &v16;
  uint64_t v14 = 0;
  if (a3 == a5)
  {
    uint64_t v11 = a6;
  }
  else
  {
    uint64_t v9 = a3;
    do
    {
      v9 -= 96;
      std::allocator<IterNode>::construct[abi:ne180100]<IterNode,IterNode>(a1, v7 - 96, v9);
      uint64_t v7 = *((void *)&v16 + 1) - 96;
      *((void *)&v16 + 1) -= 96;
    }
    while (v9 != a5);
    uint64_t v11 = v16;
  }
  LOBYTE(v14) = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<IterNode>,std::reverse_iterator<IterNode*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v13);
  return v11;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<IterNode>,std::reverse_iterator<IterNode*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    std::_AllocatorDestroyRangeReverse<std::allocator<IterNode>,std::reverse_iterator<IterNode*>>::operator()[abi:ne180100]((uint64_t *)a1);
  }
  return a1;
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<IterNode>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x2AAAAAAAAAAAAABLL) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  return operator new(96 * a2);
}

uint64_t std::__split_buffer<IterNode>::~__split_buffer(uint64_t a1)
{
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void std::__split_buffer<IterNode>::__destruct_at_end[abi:ne180100](uint64_t a1, uint64_t a2)
{
  while (1)
  {
    uint64_t v4 = *(void *)(a1 + 16);
    if (v4 == a2) {
      break;
    }
    uint64_t v5 = *(void *)(a1 + 32);
    *(void *)(a1 + 16) = v4 - 96;
    std::allocator_traits<std::allocator<IterNode>>::destroy[abi:ne180100]<IterNode,void>(v5, v4 - 96);
  }
}

void AdvanceIterPos(IterInfo *a1)
{
  uint64_t v2 = (char **)((char *)a1 + 56);
  uint64_t v3 = *((void *)a1 + 5);
  while (1)
  {
    while (1)
    {
      uint64_t v4 = *((void *)a1 + 6);
      if (v3 != v4) {
        break;
      }
      uint64_t v6 = *((void *)a1 + 8);
      if (*((void *)a1 + 7) == v6) {
        return;
      }
      uint64_t v8 = *(void *)(v6 - 16);
      uint64_t v7 = v6 - 16;
      uint64_t v3 = v8;
      *((void *)a1 + 5) = v8;
      *((void *)a1 + 6) = *(void *)(v7 + 8);
      *((void *)a1 + 8) = v7;
    }
    int v5 = *(unsigned __int8 *)(v3 + 88);
    if (v5 == 1) {
      break;
    }
    if (v5 == 2) {
      goto LABEL_10;
    }
    if (!*(unsigned char *)(v3 + 88))
    {
      if ((*(_DWORD *)v3 & 0x80000000) != 0)
      {
        std::string::operator=((std::string *)((char *)a1 + 16), (const std::string *)(v3 + 8));
        uint64_t v3 = *((void *)a1 + 5);
        uint64_t v4 = *((void *)a1 + 6);
      }
      goto LABEL_50;
    }
LABEL_11:
    uint64_t v3 = *((void *)a1 + 5);
    if (*(unsigned char *)(v3 + 88) == 3)
    {
      std::vector<IterNode>::__base_destruct_at_end[abi:ne180100](v3 + 40, *(void ***)(v3 + 40));
      uint64_t v3 = *((void *)a1 + 5) + 96;
      *((void *)a1 + 5) = v3;
    }
  }
  *(unsigned char *)(v3 + 88) = 2;
  if (*(void *)(v3 + 64) != *(void *)(v3 + 72))
  {
    unint64_t v15 = *((void *)a1 + 9);
    uint64_t v16 = *((void *)a1 + 6);
    uint64_t v17 = (uint64_t *)*((void *)a1 + 8);
    if ((unint64_t)v17 >= v15)
    {
      uint64_t v24 = ((char *)v17 - *v2) >> 4;
      unint64_t v25 = v24 + 1;
      if ((unint64_t)(v24 + 1) >> 60) {
        goto LABEL_54;
      }
      uint64_t v26 = v15 - (void)*v2;
      if (v26 >> 3 > v25) {
        unint64_t v25 = v26 >> 3;
      }
      if ((unint64_t)v26 >= 0x7FFFFFFFFFFFFFF0) {
        unint64_t v27 = 0xFFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v27 = v25;
      }
      if (v27) {
        uint64_t v28 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::unique_ptr<dispatch_queue_s,void (*)(dispatch_object_s *)>>>((uint64_t)a1 + 72, v27);
      }
      else {
        uint64_t v28 = 0;
      }
      uint64_t v34 = (uint64_t *)&v28[16 * v24];
      long long v35 = &v28[16 * v27];
      *uint64_t v34 = v3;
      v34[1] = v16;
      int v18 = v34 + 2;
      long long v37 = (char *)*((void *)a1 + 7);
      unint64_t v36 = (char *)*((void *)a1 + 8);
      if (v36 != v37)
      {
        do
        {
          *((_OWORD *)v34 - 1) = *((_OWORD *)v36 - 1);
          v34 -= 2;
          v36 -= 16;
        }
        while (v36 != v37);
        unint64_t v36 = *v2;
      }
      *((void *)a1 + 7) = v34;
      *((void *)a1 + 8) = v18;
      *((void *)a1 + 9) = v35;
      if (v36) {
        operator delete(v36);
      }
    }
    else
    {
      *uint64_t v17 = v3;
      v17[1] = v16;
      int v18 = v17 + 2;
    }
    *((void *)a1 + 8) = v18;
    uint64_t v38 = *((void *)a1 + 5);
    uint64_t v4 = *(void *)(v38 + 72);
    *((void *)a1 + 6) = v4;
    uint64_t v3 = *(void *)(v38 + 64);
    goto LABEL_49;
  }
LABEL_10:
  std::vector<IterNode>::__base_destruct_at_end[abi:ne180100](v3 + 64, *(void ***)(v3 + 64));
  uint64_t v9 = *((void *)a1 + 5);
  *(unsigned char *)(v9 + 88) = 3;
  if (*(void *)(v9 + 40) == *(void *)(v9 + 48)) {
    goto LABEL_11;
  }
  unint64_t v10 = *((void *)a1 + 9);
  uint64_t v12 = *((void *)a1 + 5);
  uint64_t v11 = *((void *)a1 + 6);
  uint64_t v13 = (void *)*((void *)a1 + 8);
  if ((unint64_t)v13 < v10)
  {
    void *v13 = v12;
    v13[1] = v11;
    uint64_t v14 = v13 + 2;
    goto LABEL_41;
  }
  uint64_t v19 = ((char *)v13 - *v2) >> 4;
  unint64_t v20 = v19 + 1;
  if ((unint64_t)(v19 + 1) >> 60) {
LABEL_54:
  }
    std::vector<IIOTag *>::__throw_length_error[abi:ne180100]();
  uint64_t v21 = v10 - (void)*v2;
  if (v21 >> 3 > v20) {
    unint64_t v20 = v21 >> 3;
  }
  if ((unint64_t)v21 >= 0x7FFFFFFFFFFFFFF0) {
    unint64_t v22 = 0xFFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v22 = v20;
  }
  if (v22) {
    int v23 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::unique_ptr<dispatch_queue_s,void (*)(dispatch_object_s *)>>>((uint64_t)a1 + 72, v22);
  }
  else {
    int v23 = 0;
  }
  uint64_t v29 = &v23[16 * v19];
  uint64_t v30 = &v23[16 * v22];
  *(void *)uint64_t v29 = v12;
  *((void *)v29 + 1) = v11;
  uint64_t v14 = v29 + 16;
  uint64_t v32 = (char *)*((void *)a1 + 7);
  uint64_t v31 = (char *)*((void *)a1 + 8);
  if (v31 != v32)
  {
    do
    {
      *((_OWORD *)v29 - 1) = *((_OWORD *)v31 - 1);
      v29 -= 16;
      v31 -= 16;
    }
    while (v31 != v32);
    uint64_t v31 = *v2;
  }
  *((void *)a1 + 7) = v29;
  *((void *)a1 + 8) = v14;
  *((void *)a1 + 9) = v30;
  if (v31) {
    operator delete(v31);
  }
LABEL_41:
  *((void *)a1 + 8) = v14;
  uint64_t v33 = *((void *)a1 + 5);
  uint64_t v4 = *(void *)(v33 + 48);
  *((void *)a1 + 6) = v4;
  uint64_t v3 = *(void *)(v33 + 40);
LABEL_49:
  *((void *)a1 + 5) = v3;
LABEL_50:
  if (v3 != v4)
  {
    if (*(unsigned char *)(v3 + 88)) {
      AdvanceIterPos();
    }
  }
}

void std::vector<IterNode>::__base_destruct_at_end[abi:ne180100](uint64_t a1, void **a2)
{
  uint64_t v4 = *(void ***)(a1 + 8);
  if (v4 != a2)
  {
    int v5 = v4 - 4;
    do
    {
      uint64_t v7 = v5;
      std::vector<IterNode>::__destroy_vector::operator()[abi:ne180100](&v7);
      uint64_t v7 = v5 - 3;
      std::vector<IterNode>::__destroy_vector::operator()[abi:ne180100](&v7);
      if (*((char *)v5 - 33) < 0) {
        operator delete(*(v5 - 7));
      }
      uint64_t v6 = v5 - 8;
      v5 -= 12;
    }
    while (v6 != a2);
  }
  *(void *)(a1 + 8) = a2;
}

void std::vector<IterNode>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  if (v2)
  {
    uint64_t v4 = v1[1];
    int v5 = **a1;
    if (v4 != v2)
    {
      uint64_t v6 = (uint64_t)v4 - 32;
      do
      {
        uint64_t v8 = v6;
        std::vector<IterNode>::__destroy_vector::operator()[abi:ne180100](&v8);
        uint64_t v8 = v6 - 24;
        std::vector<IterNode>::__destroy_vector::operator()[abi:ne180100](&v8);
        if (*(char *)(v6 - 33) < 0) {
          operator delete(*(void **)(v6 - 56));
        }
        uint64_t v7 = (void *)(v6 - 64);
        v6 -= 96;
      }
      while (v7 != v2);
      int v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void std::allocator_traits<std::allocator<IterNode>>::destroy[abi:ne180100]<IterNode,void>(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (void **)(a2 + 64);
  std::vector<IterNode>::__destroy_vector::operator()[abi:ne180100](&v3);
  uint64_t v3 = (void **)(a2 + 40);
  std::vector<IterNode>::__destroy_vector::operator()[abi:ne180100](&v3);
  if (*(char *)(a2 + 31) < 0) {
    operator delete(*(void **)(a2 + 8));
  }
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<std::unique_ptr<dispatch_queue_s,void (*)(dispatch_object_s *)>>>(uint64_t a1, unint64_t a2)
{
  if (a2 >> 60) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  return operator new(16 * a2);
}

void XMLParserAdapter::~XMLParserAdapter(XMLParserAdapter *this)
{
  *(void *)this = &unk_1ED4E3EE0;
  uint64_t v2 = (void *)*((void *)this + 20);
  if (v2)
  {
    *((void *)this + 21) = v2;
    operator delete(v2);
  }
  XML_Node::~XML_Node((XMLParserAdapter *)((char *)this + 8));
}

void XML_Node::~XML_Node(XML_Node *this)
{
  XML_Node::~XML_Node(this);

  JUMPOUT(0x18C11C0E0);
}

{
  void *v2;
  void *v3;

  *(void *)this = &unk_1ED4E5BF8;
  XML_Node::RemoveAttrs(this);
  XML_Node::RemoveContent(this);
  uint64_t v2 = (void *)*((void *)this + 16);
  if (v2)
  {
    *((void *)this + 17) = v2;
    operator delete(v2);
  }
  uint64_t v3 = (void *)*((void *)this + 13);
  if (v3)
  {
    *((void *)this + 14) = v3;
    operator delete(v3);
  }
  if (*((char *)this + 87) < 0) {
    operator delete(*((void **)this + 8));
  }
  if (*((char *)this + 63) < 0) {
    operator delete(*((void **)this + 5));
  }
  if (*((char *)this + 39) < 0) {
    operator delete(*((void **)this + 2));
  }
}

void *XML_Node::RemoveContent(void *this)
{
  uint64_t v1 = this;
  uint64_t v2 = this[17];
  uint64_t v3 = v2 - this[16];
  if (v3)
  {
    uint64_t v4 = 0;
    if ((unint64_t)(v3 >> 3) <= 1) {
      uint64_t v5 = 1;
    }
    else {
      uint64_t v5 = v3 >> 3;
    }
    do
    {
      this = *(void **)(v1[16] + 8 * v4);
      if (this) {
        this = (void *)(*(uint64_t (**)(void *))(*this + 8))(this);
      }
      ++v4;
    }
    while (v5 != v4);
    uint64_t v2 = v1[16];
  }
  v1[17] = v2;
  return this;
}

void *XML_Node::RemoveAttrs(void *this)
{
  uint64_t v1 = this;
  uint64_t v2 = this[14];
  uint64_t v3 = v2 - this[13];
  if (v3)
  {
    uint64_t v4 = 0;
    if ((unint64_t)(v3 >> 3) <= 1) {
      uint64_t v5 = 1;
    }
    else {
      uint64_t v5 = v3 >> 3;
    }
    do
    {
      this = *(void **)(v1[13] + 8 * v4);
      if (this) {
        this = (void *)(*(uint64_t (**)(void *))(*this + 8))(this);
      }
      ++v4;
    }
    while (v5 != v4);
    uint64_t v2 = v1[13];
  }
  v1[14] = v2;
  return this;
}

void IIODictionary::appendDictionary(IIODictionary *this, const __CFDictionary **a2)
{
  uint64_t v2 = (__CFDictionary *)*((void *)this + 1);
  if (v2) {
    IIODictionaryAppendDictionary(v2, a2[1], 1);
  }
}

uint64_t releaseUnusedImageProvider(uint64_t result, void *a2)
{
  if (*MEMORY[0x1E4F1D260] != result)
  {
    uint64_t v2 = *(void *)(result + 24);
    IIOImagePlus::releaseUnusedImageProvider(v2);
    return IIOImagePlus::setISR(v2, 0);
  }
  return result;
}

uint64_t IIOImagePlus::releaseUnusedImageProvider(uint64_t this)
{
  if ((*(unsigned char *)(this + 192) & 0x40) == 0)
  {
    uint64_t v1 = this;
    uint64_t v2 = *(void *)(this + 144);
    uint64_t v3 = *MEMORY[0x1E4F1D260];
    if (v2) {
      BOOL v4 = v2 == v3;
    }
    else {
      BOOL v4 = 1;
    }
    if (!v4)
    {
      atomic_fetch_add_explicit(&gImageProviderCount, 0xFFFFFFFFFFFFFFFFLL, memory_order_relaxed);
      CGImageProviderRelease();
    }
    this = *(void *)(v1 + 152);
    if (this) {
      BOOL v5 = this == v3;
    }
    else {
      BOOL v5 = 1;
    }
    if (!v5)
    {
      atomic_fetch_add_explicit(&gImageProviderCount, 0xFFFFFFFFFFFFFFFFLL, memory_order_relaxed);
      this = CGImageProviderRelease();
    }
    *(unsigned char *)(v1 + 192) &= ~0x40u;
    *(void *)(v1 + 144) = 0;
    *(void *)(v1 + 152) = 0;
  }
  return this;
}

CFStringRef ___ZL27CreateMetadataFromDatablockP19IIOImageReadSessionPK6tagdefmmbPK8__CFDataj_block_invoke()
{
  CFStringRef result = (const __CFString *)malloc_type_malloc(0x108uLL, 0x2004093837F09uLL);
  uint64_t v1 = (uint64_t)result;
  if (result)
  {
    uint64_t v2 = 0;
    uint64_t v3 = (const __CFString ***)&qword_1ED4B6078;
    do
    {
      BOOL v4 = *(v3 - 4);
      if (v4) {
        CFStringRef result = *v4;
      }
      else {
        CFStringRef result = 0;
      }
      BOOL v5 = *v3;
      if (*v3 || (BOOL v5 = *(v3 - 1)) != 0)
      {
        CFStringRef v6 = 0;
        if (result && *v5)
        {
          CFStringRef result = (const __CFString *)CGImageMetadataTagKeyCreate(result, *v5);
          CFStringRef v6 = result;
        }
      }
      else
      {
        CFStringRef v6 = 0;
      }
      *(void *)(v1 + v2) = v6;
      v3 += 7;
      v2 += 8;
    }
    while (v2 != 264);
  }
  IFD0TagKeys = v1;
  return result;
}

CFStringRef ___ZL27CreateMetadataFromDatablockP19IIOImageReadSessionPK6tagdefmmbPK8__CFDataj_block_invoke_3()
{
  CFStringRef result = (const __CFString *)malloc_type_malloc(0x260uLL, 0x2004093837F09uLL);
  uint64_t v1 = (uint64_t)result;
  if (result)
  {
    uint64_t v2 = 0;
    uint64_t v3 = (const __CFString ***)&qword_1ED4B4FA0;
    do
    {
      BOOL v4 = *(v3 - 4);
      if (v4) {
        CFStringRef result = *v4;
      }
      else {
        CFStringRef result = 0;
      }
      BOOL v5 = *v3;
      if (*v3 || (BOOL v5 = *(v3 - 1)) != 0)
      {
        CFStringRef v6 = 0;
        if (result && *v5)
        {
          CFStringRef result = (const __CFString *)CGImageMetadataTagKeyCreate(result, *v5);
          CFStringRef v6 = result;
        }
      }
      else
      {
        CFStringRef v6 = 0;
      }
      *(void *)(v1 + v2) = v6;
      v3 += 7;
      v2 += 8;
    }
    while (v2 != 608);
  }
  ExifTagKeys = v1;
  return result;
}

void *CGImageMetadataTagKeyCreate(const __CFString *a1, const __CFString *a2)
{
  if (!a1) {
    return 0;
  }
  CFTypeID v4 = CFGetTypeID(a1);
  CFTypeID TypeID = CFStringGetTypeID();
  CFStringRef v6 = 0;
  if (!a2 || v4 != TypeID) {
    return v6;
  }
  CFTypeID v7 = CFGetTypeID(a2);
  if (v7 != CFStringGetTypeID()) {
    return 0;
  }
  CFStringRef v6 = malloc_type_malloc(0x18uLL, 0x106004091AC2883uLL);
  if (v6)
  {
    CFAllocatorRef v8 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    void *v6 = CFStringCreateCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a1);
    v6[1] = CFStringCreateCopy(v8, a2);
    *((_DWORD *)v6 + 4) = 1;
  }
  return v6;
}

BOOL StartNamespaceDeclHandler(BOOL result, char *a2, char *__s1)
{
  if (a2) {
    uint64_t v3 = a2;
  }
  else {
    uint64_t v3 = "_dflt_";
  }
  if (__s1)
  {
    uint64_t v5 = result;
    if (!strcmp(__s1, "http://purl.org/dc/1.1/")) {
      CFTypeID v7 = "http://purl.org/dc/elements/1.1/";
    }
    else {
      CFTypeID v7 = __s1;
    }
    CFAllocatorRef v8 = *(XMP_NamespaceTable **)(v5 + 256);
    if (v8 == (XMP_NamespaceTable *)sRegisteredNamespaces)
    {
      return XMPMeta::RegisterNamespace((XMPMeta *)v7, v3, 0, 0, v6);
    }
    else
    {
      return XMP_NamespaceTable::Define(v8, v7, v3, 0, 0);
    }
  }
  return result;
}

void PNGReadPlugin::DecodeFrameStandard(IIOImageReadSession *a1, uint64_t a2, uint64_t a3, uint64_t *a4, double a5, double a6, double a7)
{
  uint64_t v8 = a2;
  BOOL v10 = 0;
  unint64_t v11 = *(unsigned __int16 *)(a2 + 132);
  uint64_t v97 = 0;
  uint64_t v98 = &v97;
  uint64_t v99 = 0x2000000000;
  int v100 = 0;
  uint64_t v93 = 0;
  int v94 = &v93;
  uint64_t v95 = 0x2000000000;
  unsigned int v96 = 0;
  uint64_t v12 = *(unsigned int **)(a3 + 48);
  BOOL v14 = v11 >= 2 || *(unsigned char *)(a3 + 58) != 0 || v12 == 0;
  unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 4, 2, 0));
  int v16 = !v14;
  BOOL v17 = *(unsigned char *)(a2 + 157) == 0;
  int v18 = v16 ^ 1;
  if (*(unsigned char *)(a2 + 157)) {
    int v18 = 1;
  }
  uint64_t v19 = &v100;
  uint64_t v89 = 0;
  uint64_t v90 = &v89;
  uint64_t v91 = 0x2000000000;
  int v92 = -40;
  uint64_t v20 = *a4;
  _WriteStatusReg(ARM64_SYSREG(3, 3, 4, 2, 0), StatusReg);
  if (v17) {
    int v21 = 0;
  }
  else {
    int v21 = v18;
  }
  char v22 = v21 ^ 1;
  if (*(unsigned char *)(a3 + 19) == 3) {
    int v23 = v21 ^ 1;
  }
  else {
    int v23 = 1;
  }
  if ((v22 & 1) == 0 && v23) {
    BOOL v10 = *v12 > 1;
  }
  uint64_t v83 = a4[5];
  uint64_t v24 = *(unsigned int *)(a2 + 112);
  double v25 = (double)(v20 * v24);
  LODWORD(a7) = *(_DWORD *)(a2 + 48);
  double v26 = (double)*(unint64_t *)&a7;
  if ((double)v24 + v25 <= v26) {
    double v27 = (double)v24;
  }
  else {
    double v27 = v26 - v25;
  }
  if (!v10 || *(unsigned char *)(a3 + 57)) {
    goto LABEL_29;
  }
  int v92 = 0;
  unsigned int v96 = v12[4];
  size_t v28 = *v12;
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 0x40000000;
  block[2] = ___ZN13PNGReadPlugin19DecodeFrameStandardEP19IIOImageReadSessionRK14ReadPluginDataRK13PNGPluginDataR20IIODecodeFrameParams_block_invoke;
  block[3] = &unk_1E53C4550;
  block[8] = a1;
  block[9] = a2;
  block[10] = v83;
  block[4] = &v97;
  block[5] = &v93;
  block[6] = &v89;
  block[7] = a3;
  dispatch_apply(v28, 0, block);
  uint64_t v29 = v98;
  uint64_t v19 = (int *)(v98 + 3);
  int v30 = *((_DWORD *)v98 + 6);
  if (v30 <= *((_DWORD *)v94 + 6)) {
    int v30 = *((_DWORD *)v94 + 6);
  }
  *uint64_t v19 = v30;
  if (*((_DWORD *)v90 + 6))
  {
LABEL_29:
    unint64_t v31 = (unint64_t)(v27 + v25);
    *uint64_t v19 = 0;
    uint64_t v32 = _cg_png_create_read_struct("1.6.43", 0, (uint64_t)handle_error, (uint64_t)handle_warning);
    uint64_t v87 = v32;
    _cg_png_create_info_struct((uint64_t)v32);
    uint64_t v34 = v33;
    long long v35 = 0;
    int v86 = v33;
    if (v32 && v33)
    {
      _cg_png_set_option((uint64_t)v32, 2u, 3);
      _cg_png_set_benign_errors((uint64_t)v32, 1);
      unint64_t v36 = *(void *)(v8 + 8);
      if (v36) {
        IIOImageReadSession::seek(a1, v36, 0);
      }
      else {
        IIOImageReadSession::rewind((uint64_t)a1);
      }
      _cg_png_set_read_fn(v32, (uint64_t)a1, (size_t (*)(size_t, void *, size_t))read_fn);
      _cg_png_set_keep_unknown_chunks_sized((uint64_t)v32, 3u, "CgBI", 4);
      *(unsigned char *)(a3 + 56) = 0;
      _cg_png_set_read_user_chunk_fn((uint64_t)v32, a3, (uint64_t)PNGReadPlugin::Read_user_chunk_callback);
      _cg_png_read_info((uLong)v32, v34);
      PNGReadPlugin::Validate_png_info((uint64_t)v32, (uint64_t)v34, a3);
      if (*(unsigned char *)(a3 + 27))
      {
        _cg_png_set_add_alpha((uint64_t)v32, 255, 1);
        if ((gIIODebugFlags & 0x20000) != 0)
        {
          int v37 = *(_DWORD *)(v8 + 20);
          unsigned int v38 = v37 >> 24;
          uint64_t v39 = MEMORY[0x1E4F14390];
          if (v37 < 0)
          {
            int v40 = __maskrune(v38, 0x40000uLL);
            int v37 = *(_DWORD *)(v8 + 20);
            unsigned int v38 = v37 >> 24;
          }
          else
          {
            int v40 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v38 + 60) & 0x40000;
          }
          if (v40) {
            uint64_t v41 = v38;
          }
          else {
            uint64_t v41 = 46;
          }
          uint64_t v80 = v41;
          unsigned int v42 = v37 << 8 >> 24;
          if (v37 << 8 < 0)
          {
            int v43 = __maskrune(v42, 0x40000uLL);
            int v37 = *(_DWORD *)(v8 + 20);
            unsigned int v42 = v37 << 8 >> 24;
          }
          else
          {
            int v43 = *(_DWORD *)(v39 + 4 * v42 + 60) & 0x40000;
          }
          if (v43) {
            uint64_t v44 = v42;
          }
          else {
            uint64_t v44 = 46;
          }
          unsigned int v45 = (__int16)v37 >> 8;
          if (v37 << 16 < 0)
          {
            int v47 = __maskrune(v45, 0x40000uLL);
            uint64_t v46 = v39;
            int v37 = *(_DWORD *)(v8 + 20);
            unsigned int v45 = (__int16)v37 >> 8;
          }
          else
          {
            uint64_t v46 = v39;
            int v47 = *(_DWORD *)(v39 + 4 * v45 + 60) & 0x40000;
          }
          if (v47) {
            uint64_t v48 = v45;
          }
          else {
            uint64_t v48 = 46;
          }
          unsigned int v49 = (char)v37;
          if ((v37 << 24) <= 0x7F000000)
          {
            int v50 = *(_DWORD *)(v46 + 4 * (char)v37 + 60) & 0x40000;
          }
          else
          {
            int v50 = __maskrune((char)v37, 0x40000uLL);
            unsigned int v49 = *(char *)(v8 + 20);
          }
          if (v50) {
            uint64_t v51 = v49;
          }
          else {
            uint64_t v51 = 46;
          }
          ImageIOLog("  '%c%c%c%c' %d: png_set_add_alpha: PNG_FILLER_AFTER\n", v80, v44, v48, v51, 4398);
        }
      }
      if (*(unsigned char *)(v8 + 63) == 1) {
        _cg_png_set_swap((uint64_t)v32);
      }
      PNGReadPlugin::Update_png_struct(v8, (unsigned char *)a3, (uint64_t)v32, v34);
      if (v20)
      {
        if (v11 <= 1) {
          uint64_t v52 = 1;
        }
        else {
          uint64_t v52 = v11;
        }
        uint64_t v53 = v20 * v52 * *(unsigned int *)(v8 + 112);
        if ((gIIODebugFlags & 0x30000) != 0) {
          ImageIOLog("    skipping rows %4d through %4d\n", 0, v53);
        }
        if (v53)
        {
          uint64_t v54 = v53;
          do
          {
            _cg_png_read_row_sized((uLong)v32, 0, 0, 0);
            --v54;
          }
          while (v54);
        }
      }
      unsigned int v85 = 1;
      uint64_t rowbytes = _cg_png_get_rowbytes((uint64_t)v32, (uint64_t)v34);
      unint64_t v56 = rowbytes;
      if (v11 >= 2)
      {
        if (v11 > 0x100) {
          uint64_t v57 = 1;
        }
        else {
          uint64_t v57 = 0x100 / v11;
        }
        unsigned int v85 = v57;
        size_t v58 = rowbytes * v11 * v57;
      }
      else
      {
        LODWORD(v57) = 1;
        size_t v58 = rowbytes;
      }
      std::string v59 = (char *)malloc_type_calloc(v58, 1uLL, 0x8A132A07uLL);
      long long v35 = v59;
      if (v11 >= 2)
      {
        uint64_t v82 = (unsigned __int8 *)v59;
        double v65 = (double)v11 * v25;
        double v66 = (double)(unint64_t)v65 + v27 * (double)v11;
        int v67 = *(_DWORD *)(v8 + 44);
        if ((unint64_t)v66 >= *(unsigned int *)(v8 + 48)) {
          unint64_t v68 = *(unsigned int *)(v8 + 48);
        }
        else {
          unint64_t v68 = (unint64_t)v66;
        }
        if (*(unsigned char *)(v8 + 62) == 1 && *(unsigned char *)(a3 + 35) == 0) {
          int v70 = 3;
        }
        else {
          int v70 = *(unsigned __int8 *)(v8 + 62);
        }
        __int16 v71 = *(_WORD *)(v8 + 92);
        memset(v84, 0, sizeof(v84));
        IIOSubsampler::IIOSubsampler((IIOSubsampler *)v84, v67, v56, v70, *(_WORD *)(v8 + 56), v71, *(_WORD *)(v8 + 132), 0, *(_DWORD *)(v8 + 108), *(_DWORD *)(v8 + 116));
        unint64_t v72 = (unint64_t)v65;
        if (v68 > (unint64_t)v65)
        {
          uint64_t v73 = 0;
          do
          {
            uint64_t v74 = v8;
            unint64_t v75 = v72 + (v57 * v11);
            if (v75 > v68)
            {
              uint64_t v57 = (v68 - v72) / v11;
              unsigned int v85 = v57;
              unint64_t v75 = v68;
            }
            unint64_t v76 = v11;
            unint64_t v77 = v72 - v75;
            if (v72 < v75)
            {
              unsigned int v78 = (char *)v82;
              do
              {
                _cg_png_read_row_sized((uLong)v32, v78, v56, 0);
                v78 += v56;
              }
              while (!__CFADD__(v77++, 1));
              LODWORD(v57) = v85;
              unint64_t v72 = v75;
            }
            unint64_t v11 = v76;
            IIOSubsampler::subsample((IIOSubsampler *)v84, v82, v57 * v76, (unsigned __int8 *)(v83 + v73 * *(unsigned int *)(v74 + 116)), &v85);
            LODWORD(v57) = v85;
            v73 += v85;
            *((_DWORD *)v98 + 6) += v85;
            uint64_t v8 = v74;
          }
          while (v72 < v68);
        }
        IIOSubsampler::~IIOSubsampler((IIOSubsampler *)v84);
        long long v35 = (char *)v82;
      }
      else
      {
        if (*(unsigned __int16 *)(v8 + 56) <= 7u
          && *(unsigned char *)(a3 + 19) == 3
          && !*(unsigned char *)(a3 + 28)
          && *(unsigned char *)(v8 + 220) != 1)
        {
          operator new();
        }
        BOOL v60 = v58 == a4[6];
        if (v31 > (unint64_t)v25)
        {
          uint64_t v61 = 0;
          do
          {
            uint64_t v62 = *(unsigned int *)(v8 + 116);
            unsigned int v63 = (void *)(v83 + v61 * v62);
            if (v60)
            {
              _cg_png_read_row_sized((uLong)v32, (char *)(v83 + v61 * v62), v56, 0);
            }
            else
            {
              _cg_png_read_row_sized((uLong)v32, v35, v56, 0);
              if (v56 >= *(unsigned int *)(v8 + 116)) {
                size_t v64 = *(unsigned int *)(v8 + 116);
              }
              else {
                size_t v64 = v56;
              }
              memcpy(v63, v35, v64);
            }
            ++*((_DWORD *)v98 + 6);
            ++v61;
          }
          while (v31 - (unint64_t)v25 != v61);
        }
      }
    }
    _cg_png_destroy_read_struct((uint64_t *)&v87, (void **)&v86, 0);
    if (v35) {
      free(v35);
    }
    uint64_t v29 = v98;
  }
  a4[8] = *((int *)v29 + 6);
  _Block_object_dispose(&v89, 8);
  _Block_object_dispose(&v93, 8);
  _Block_object_dispose(&v97, 8);
}

void sub_1885B2344(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28)
{
  MEMORY[0x18C11C0E0](v28, 0x10F1C4050BC5624);
  __cxa_begin_catch(a1);
  imagePNG_error_break(a28);
  uint64_t v32 = *(void *)(v30 - 128);
  unint64_t v33 = *(int *)(v32 + 24);
  if ((int)v33 >= 1 && v29 > v33) {
    *(_DWORD *)(v32 + 24) = v29;
  }
  __cxa_end_catch();
  JUMPOUT(0x1885B22D0);
}

void sub_1885B241C(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Block_object_dispose((const void *)(v1 - 200), 8);
  _Block_object_dispose((const void *)(v1 - 168), 8);
  _Block_object_dispose((const void *)(v1 - 136), 8);
  _Unwind_Resume(a1);
}

uint64_t AppleJPEGReadPlugin::readJFIFData(IIOImageReadSession **this, IIODictionary *a2)
{
  v26[1] = *MEMORY[0x1E4F143B8];
  uint64_t v24 = 0;
  uint64_t v25 = 0;
  if (!a2) {
    return 1;
  }
  v26[0] = 0;
  if (IIOImageReadSession::getBytesAtOffset(this[3], v26, 2uLL, 8uLL) != 8) {
    return 0;
  }
  unint64_t v4 = 2;
  while (1)
  {
    unsigned int v5 = __rev16(LOWORD(v26[0]));
    if (v5 != 0xFFFF) {
      break;
    }
    LODWORD(v6) = 0;
    --v4;
LABEL_9:
    v4 += v6 + 2;
    if (IIOImageReadSession::getBytesAtOffset(this[3], v26, v4, 8uLL) != 8) {
      return 0;
    }
  }
  if (v5 == 65498) {
    return 1;
  }
  uint64_t v6 = __rev16(WORD1(v26[0]));
  if (v5 != 65504) {
    goto LABEL_9;
  }
  if (v6 > 0xF)
  {
    unint64_t BytesAtOffset = IIOImageReadSession::getBytesAtOffset(this[3], &v24, v4 + 4, 0x10uLL);
    if (BytesAtOffset != v6)
    {
      if (BytesAtOffset + 4 != v6)
      {
        _cg_jpeg_mem_term("readJFIFData", 485, "bad APP0 marker: tagSize: %d  expected: %d\n", v6, 16);
        return 1;
      }
      _cg_jpeg_mem_term("readJFIFData", 482, "*** APP0 marker indicating depth/disparity...\n");
    }
    WORD2(v24) = bswap32(WORD2(v24)) >> 16;
    LOWORD(v25) = bswap32((unsigned __int16)v25) >> 16;
    WORD1(v25) = bswap32(WORD1(v25)) >> 16;
    CFMutableArrayRef v21 = 0;
    char v22 = 0;
    uint64_t v23 = 0;
    IIOArray::IIOArray((IIOArray *)&v21);
    IIONumber::IIONumber((IIONumber *)v20, WORD2(v24));
    IIOArray::addObject(&v21, (uint64_t)v20);
    IIONumber::~IIONumber((IIONumber *)v20);
    IIONumber::IIONumber((IIONumber *)v19, BYTE6(v24) >> 4);
    IIOArray::addObject(&v21, (uint64_t)v19);
    IIONumber::~IIONumber((IIONumber *)v19);
    IIONumber::IIONumber((IIONumber *)v18, BYTE6(v24) & 0xF);
    IIOArray::addObject(&v21, (uint64_t)v18);
    IIONumber::~IIONumber((IIONumber *)v18);
    IIODictionary::setObjectForKeyGroup(a2, v22, @"JFIFVersion", @"{JFIF}");
    IIONumber::IIONumber((IIONumber *)v17, (unsigned __int16)v25);
    IIODictionary::setObjectForKeyGroup(a2, (uint64_t)v17, @"XDensity", @"{JFIF}");
    IIONumber::~IIONumber((IIONumber *)v17);
    IIONumber::IIONumber((IIONumber *)v16, WORD1(v25));
    IIODictionary::setObjectForKeyGroup(a2, (uint64_t)v16, @"YDensity", @"{JFIF}");
    IIONumber::~IIONumber((IIONumber *)v16);
    IIONumber::IIONumber((IIONumber *)v15, HIBYTE(v24));
    IIODictionary::setObjectForKeyGroup(a2, (uint64_t)v15, @"DensityUnit", @"{JFIF}");
    IIONumber::~IIONumber((IIONumber *)v15);
    if (HIBYTE(v24) == 2)
    {
      LOWORD(v9) = v25;
      *(double *)&unint64_t v12 = (double)v9 * 2.54;
      float v10 = *(double *)&v12;
      LOWORD(v12) = WORD1(v25);
      float v11 = (double)v12 * 2.54;
    }
    else
    {
      float v10 = 0.0;
      float v11 = 0.0;
      if (HIBYTE(v24) == 1)
      {
        LOWORD(v9) = v25;
        float v10 = (float)v9;
        LOWORD(v9) = WORD1(v25);
        float v11 = (float)v9;
      }
    }
    if (ValidDPI(v10) && ValidDPI(v11))
    {
      IIONumber::IIONumber((IIONumber *)v14, v10);
      IIODictionary::setObjectForKey((uint64_t)a2, (uint64_t)v14, @"DPIWidth");
      IIONumber::~IIONumber((IIONumber *)v14);
      IIONumber::IIONumber((IIONumber *)v13, v11);
      IIODictionary::setObjectForKey((uint64_t)a2, (uint64_t)v13, @"DPIHeight");
      IIONumber::~IIONumber((IIONumber *)v13);
    }
    IIOArray::~IIOArray((IIOArray *)&v21);
    return 1;
  }
  if (bswap32(HIDWORD(v26[0])) != 1246120262) {
    return 1;
  }
  _cg_jpeg_mem_term("readJFIFData", 470, "bad APP0-JFIF marker: tagSize: %d  expected: %d\n", v6, 16);
  return 0;
}

void sub_1885B2850(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  IIONumber::~IIONumber((IIONumber *)va);
  IIOArray::~IIOArray((IIOArray *)(v4 - 136));
  _Unwind_Resume(a1);
}

void IIODictionary::setObjectForKeyGroup(IIODictionary *this, const void *a2, const __CFString *a3, const __CFString *a4)
{
  if (a3)
  {
    if (a4)
    {
      if (*((void *)this + 1))
      {
        GroupForKey = IIODictionary::getGroupForKey(this, a4, 1);
        if (GroupForKey)
        {
          if (a2)
          {
            CFDictionarySetValue(GroupForKey, a3, a2);
          }
          else
          {
            CFDictionaryRemoveValue(GroupForKey, a3);
          }
        }
      }
    }
  }
}

void IIOArray::~IIOArray(IIOArray *this)
{
  *(void *)this = &unk_1ED4E5BB8;
  uint64_t v1 = (const void *)*((void *)this + 1);
  if (v1) {
    CFRelease(v1);
  }
}

{
  uint64_t vars8;

  IIOArray::~IIOArray(this);

  JUMPOUT(0x18C11C0E0);
}

void IIOArray::IIOArray(IIOArray *this)
{
  *(void *)this = &unk_1ED4E5BB8;
  *((void *)this + 1) = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
  *((unsigned char *)this + 16) = 1;
}

uint64_t PNGReadPlugin::InitializePluginData(IIOImageReadSession *a1, IIODictionary *this, IIODictionary *a3, CGImageMetadata *a4, CGColorSpace **a5, uint64_t a6, uint64_t a7, __CFDictionary *a8)
{
  uint64_t v228 = 0;
  v229[0] = 0;
  if (!this)
  {
    uint64_t v107 = 4294967246;
LABEL_417:
    kdebug_trace();
    return v107;
  }
  if (IIODictionary::containsKey(this, @"kCGImageSourceCreateUnpremultipliedPNG"))
  {
    if (IIODictionary::getBoolForKey(this, @"kCGImageSourceCreateUnpremultipliedPNG")) {
      char v11 = 1;
    }
    else {
      char v11 = -1;
    }
  }
  else
  {
    char v11 = -1;
  }
  uint64_t v12 = a6;
  *(unsigned char *)(a7 + 72) = v11;
  int v182 = IIOSkipMetadata(this);
  IIOSkipXMP_and_IPTC(this);
  *(unsigned char *)(a7 + 28) = 0;
  v189 = this;
  *(unsigned char *)(a7 + 59) = IIODictionary::getBoolForKey(this, @"IIO_SKIP_APNG_COMPOSING");
  uint64_t v13 = IIOImageReadSession::globalInfoForType(a1, 1095781959);
  if (v13)
  {
    *(unsigned char *)(a7 + 30) = 1;
    uint64_t v16 = *((void *)v13 + 1) + 34 * *(unsigned int *)(a6 + 24);
    int v18 = *(_DWORD *)(v16 + 4);
    int v17 = *(_DWORD *)(v16 + 8);
    int v20 = *(_DWORD *)(v16 + 12);
    int v19 = *(_DWORD *)(v16 + 16);
    int v21 = *(unsigned __int8 *)(v16 + 24);
    int v22 = *(unsigned __int8 *)(v16 + 25);
    LOWORD(v14) = *(_WORD *)(v16 + 20);
    LOWORD(v15) = *(_WORD *)(v16 + 22);
    float v23 = (float)v14 / (float)v15;
    IIONumber::IIONumber((IIONumber *)v227, v23);
    IIODictionary::setObjectForKeyGroup(a3, (uint64_t)v227, @"UnclampedDelayTime", @"{PNG}");
    IIONumber::~IIONumber((IIONumber *)v227);
    double v24 = v23;
    if (v23 < 0.05) {
      double v24 = 0.05;
    }
    IIONumber::IIONumber((IIONumber *)v226, v24);
    IIODictionary::setObjectForKeyGroup(a3, (uint64_t)v226, @"DelayTime", @"{PNG}");
    IIONumber::~IIONumber((IIONumber *)v226);
    uint64_t v12 = a6;
    if (*(unsigned char *)(a7 + 59))
    {
      IIONumber::IIONumber((IIONumber *)v225, v20);
      IIODictionary::setObjectForKeyGroup(a3, (uint64_t)v225, @"xOffset", @"{PNG}");
      IIONumber::~IIONumber((IIONumber *)v225);
      IIONumber::IIONumber((IIONumber *)v224, v19);
      IIODictionary::setObjectForKeyGroup(a3, (uint64_t)v224, @"yOffset", @"{PNG}");
      IIONumber::~IIONumber((IIONumber *)v224);
      IIONumber::IIONumber((IIONumber *)v223, v18);
      IIODictionary::setObjectForKeyGroup(a3, (uint64_t)v223, @"width", @"{PNG}");
      IIONumber::~IIONumber((IIONumber *)v223);
      IIONumber::IIONumber((IIONumber *)v222, v17);
      IIODictionary::setObjectForKeyGroup(a3, (uint64_t)v222, @"height", @"{PNG}");
      IIONumber::~IIONumber((IIONumber *)v222);
      IIONumber::IIONumber((IIONumber *)v221, v21);
      IIODictionary::setObjectForKeyGroup(a3, (uint64_t)v221, @"disposeOp", @"{PNG}");
      IIONumber::~IIONumber((IIONumber *)v221);
      IIONumber::IIONumber((IIONumber *)v220, v22);
      IIODictionary::setObjectForKeyGroup(a3, (uint64_t)v220, @"blendOp", @"{PNG}");
      IIONumber::~IIONumber((IIONumber *)v220);
    }
  }
  unint64_t v25 = *(void *)(v12 + 8);
  if (v25) {
    IIOImageReadSession::seek(a1, v25, 0);
  }
  if (IIODictionary::containsKey(v189, @"kCGImageSourceSubsampleFactor")) {
    unint64_t Uint32ForKey = IIODictionary::getUint32ForKey(v189, @"kCGImageSourceSubsampleFactor");
  }
  else {
    unint64_t Uint32ForKey = 0;
  }
  v229[0] = _cg_png_create_read_struct("1.6.43", 0, (uint64_t)handle_error, (uint64_t)handle_warning);
  if (!v229[0])
  {
    uint64_t v107 = 4294967246;
    goto LABEL_417;
  }
  if (IIODictionary::containsKey(v189, @"kCGImageSourceSkipCRC")) {
    BOOL BoolForKey = IIODictionary::getBoolForKey(v189, @"kCGImageSourceSkipCRC");
  }
  else {
    BOOL BoolForKey = 0;
  }
  if (IIODictionary::containsKey(v189, @"kCGImageSourceDisableParallelDecode")) {
    BOOL v181 = IIODictionary::getBoolForKey(v189, @"kCGImageSourceDisableParallelDecode");
  }
  else {
    BOOL v181 = 0;
  }
  if (BoolForKey) {
    _cg_png_set_crc_action((uint64_t)v229[0], 4, 4);
  }
  _cg_png_create_info_struct((uint64_t)v229[0]);
  uint64_t v228 = v26;
  if (!v26) {
    goto LABEL_185;
  }
  _cg_png_set_read_fn(v229[0], (uint64_t)a1, (size_t (*)(size_t, void *, size_t))pngReadCallback);
  _cg_png_set_option((uint64_t)v229[0], 2u, 3);
  _cg_png_set_benign_errors((uint64_t)v229[0], 1);
  *(_DWORD *)(a7 + 40) = 0;
  _cg_png_set_keep_unknown_chunks_sized((uint64_t)v229[0], 3u, "CgBI", 4);
  *(unsigned char *)(a7 + 56) = 0;
  _cg_png_set_read_user_chunk_fn((uint64_t)v229[0], a7, (uint64_t)PNGReadPlugin::Read_user_chunk_callback);
  _cg_png_read_info((uLong)v229[0], v228);
  PNGReadPlugin::Validate_png_info((uint64_t)v229[0], (uint64_t)v228, a7);
  unsigned int bit_depth = _cg_png_get_bit_depth((uint64_t)v229[0], (uint64_t)v228);
  if (*(unsigned char *)(a7 + 30)) {
    *(unsigned char *)(a7 + 31) = _cg_png_get_first_frame_is_hidden((uint64_t)v229[0]) != 0;
  }
  *(unsigned char *)(a7 + 20) = _cg_png_set_interlace_handling((uint64_t)v229[0]);
  int color_type = _cg_png_get_color_type((uint64_t)v229[0], (uint64_t)v228);
  *(unsigned char *)(a7 + 19) = color_type;
  *(unsigned char *)(a7 + 18) = color_type;
  int v28 = color_type;
  if (color_type == 3)
  {
    if (!*(unsigned char *)(v12 + 157) || *(unsigned char *)(a7 + 30) || *(unsigned char *)(a7 + 20) == 7)
    {
      *(unsigned char *)(a7 + 32) = 1;
      _cg_png_set_palette_to_rgb((uint64_t)v229[0]);
      if ((gIIODebugFlags & 0x20000) != 0)
      {
        int v29 = *(_DWORD *)(v12 + 20);
        unsigned int v30 = v29 >> 24;
        if (v29 < 0)
        {
          int v31 = __maskrune(v30, 0x40000uLL);
          int v29 = *(_DWORD *)(v12 + 20);
          unsigned int v30 = v29 >> 24;
        }
        else
        {
          int v31 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v30 + 60) & 0x40000;
        }
        if (v31) {
          uint64_t v32 = v30;
        }
        else {
          uint64_t v32 = 46;
        }
        unsigned int v33 = v29 << 8 >> 24;
        if (v29 << 8 < 0)
        {
          int v34 = __maskrune(v33, 0x40000uLL);
          int v29 = *(_DWORD *)(v12 + 20);
          unsigned int v33 = v29 << 8 >> 24;
        }
        else
        {
          int v34 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v33 + 60) & 0x40000;
        }
        if (v34) {
          uint64_t v35 = v33;
        }
        else {
          uint64_t v35 = 46;
        }
        unsigned int v36 = (__int16)v29 >> 8;
        if (v29 << 16 < 0)
        {
          int v37 = __maskrune(v36, 0x40000uLL);
          int v29 = *(_DWORD *)(v12 + 20);
          unsigned int v36 = (__int16)v29 >> 8;
        }
        else
        {
          int v37 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v36 + 60) & 0x40000;
        }
        if (v37) {
          uint64_t v38 = v36;
        }
        else {
          uint64_t v38 = 46;
        }
        unsigned int v39 = (char)v29;
        if ((v29 << 24) <= 0x7F000000)
        {
          int v40 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * (char)v29 + 60) & 0x40000;
        }
        else
        {
          int v40 = __maskrune((char)v29, 0x40000uLL);
          unsigned int v39 = *(char *)(v12 + 20);
        }
        if (v40) {
          uint64_t v41 = v39;
        }
        else {
          uint64_t v41 = 46;
        }
        ImageIOLog("  '%c%c%c%c' %d: png_set_palette_to_rgb\n", v32, v35, v38, v41, 1816);
      }
      _cg_png_set_add_alpha((uint64_t)v229[0], 255, 0);
      if ((gIIODebugFlags & 0x20000) != 0)
      {
        int v42 = *(_DWORD *)(v12 + 20);
        unsigned int v43 = v42 >> 24;
        if (v42 < 0)
        {
          int v44 = __maskrune(v43, 0x40000uLL);
          int v42 = *(_DWORD *)(v12 + 20);
          unsigned int v43 = v42 >> 24;
        }
        else
        {
          int v44 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v43 + 60) & 0x40000;
        }
        if (v44) {
          uint64_t v45 = v43;
        }
        else {
          uint64_t v45 = 46;
        }
        unsigned int v46 = v42 << 8 >> 24;
        if (v42 << 8 < 0)
        {
          int v47 = __maskrune(v46, 0x40000uLL);
          int v42 = *(_DWORD *)(v12 + 20);
          unsigned int v46 = v42 << 8 >> 24;
        }
        else
        {
          int v47 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v46 + 60) & 0x40000;
        }
        if (v47) {
          uint64_t v48 = v46;
        }
        else {
          uint64_t v48 = 46;
        }
        unsigned int v49 = (__int16)v42 >> 8;
        if (v42 << 16 < 0)
        {
          int v50 = __maskrune(v49, 0x40000uLL);
          int v42 = *(_DWORD *)(v12 + 20);
          unsigned int v49 = (__int16)v42 >> 8;
        }
        else
        {
          int v50 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v49 + 60) & 0x40000;
        }
        if (v50) {
          uint64_t v51 = v49;
        }
        else {
          uint64_t v51 = 46;
        }
        unsigned int v52 = (char)v42;
        if ((v42 << 24) <= 0x7F000000)
        {
          int v53 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * (char)v42 + 60) & 0x40000;
        }
        else
        {
          int v53 = __maskrune((char)v42, 0x40000uLL);
          unsigned int v52 = *(char *)(v12 + 20);
        }
        if (v53) {
          uint64_t v54 = v52;
        }
        else {
          uint64_t v54 = 46;
        }
        ImageIOLog("  '%c%c%c%c' %d: png_set_add_alpha: PNG_FILLER_BEFORE\n", v45, v48, v51, v54, 1818);
      }
      *(unsigned char *)(a7 + 27) = 1;
    }
    if (*(_WORD *)(v12 + 58) == 24)
    {
      _cg_png_set_add_alpha((uint64_t)v229[0], 255, 0);
      if ((gIIODebugFlags & 0x20000) != 0)
      {
        int v55 = *(_DWORD *)(v12 + 20);
        unsigned int v56 = v55 >> 24;
        if (v55 < 0)
        {
          int v57 = __maskrune(v56, 0x40000uLL);
          int v55 = *(_DWORD *)(v12 + 20);
          unsigned int v56 = v55 >> 24;
        }
        else
        {
          int v57 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v56 + 60) & 0x40000;
        }
        if (v57) {
          uint64_t v58 = v56;
        }
        else {
          uint64_t v58 = 46;
        }
        unsigned int v59 = v55 << 8 >> 24;
        if (v55 << 8 < 0)
        {
          int v60 = __maskrune(v59, 0x40000uLL);
          int v55 = *(_DWORD *)(v12 + 20);
          unsigned int v59 = v55 << 8 >> 24;
        }
        else
        {
          int v60 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v59 + 60) & 0x40000;
        }
        if (v60) {
          uint64_t v61 = v59;
        }
        else {
          uint64_t v61 = 46;
        }
        unsigned int v62 = (__int16)v55 >> 8;
        if (v55 << 16 < 0)
        {
          int v63 = __maskrune(v62, 0x40000uLL);
          int v55 = *(_DWORD *)(v12 + 20);
          unsigned int v62 = (__int16)v55 >> 8;
        }
        else
        {
          int v63 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v62 + 60) & 0x40000;
        }
        if (v63) {
          uint64_t v64 = v62;
        }
        else {
          uint64_t v64 = 46;
        }
        unsigned int v65 = (char)v55;
        if ((v55 << 24) <= 0x7F000000)
        {
          int v66 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * (char)v55 + 60) & 0x40000;
        }
        else
        {
          int v66 = __maskrune((char)v55, 0x40000uLL);
          unsigned int v65 = *(char *)(v12 + 20);
        }
        if (v66) {
          uint64_t v67 = v65;
        }
        else {
          uint64_t v67 = 46;
        }
        ImageIOLog("  '%c%c%c%c' %d: png_set_add_alpha: PNG_FILLER_BEFORE\n", v58, v61, v64, v67, 1824);
      }
      *(unsigned char *)(a7 + 27) = 1;
    }
    int v28 = *(unsigned __int8 *)(a7 + 19);
  }
  if (!v28 && _cg_png_get_bit_depth((uint64_t)v229[0], (uint64_t)v228) <= 7)
  {
    _cg_png_set_expand_gray_1_2_4_to_8((uint64_t)v229[0]);
    if ((gIIODebugFlags & 0x20000) != 0)
    {
      int v68 = *(_DWORD *)(v12 + 20);
      unsigned int v69 = v68 >> 24;
      if (v68 < 0)
      {
        int v70 = __maskrune(v69, 0x40000uLL);
        int v68 = *(_DWORD *)(v12 + 20);
        unsigned int v69 = v68 >> 24;
      }
      else
      {
        int v70 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v69 + 60) & 0x40000;
      }
      if (v70) {
        uint64_t v71 = v69;
      }
      else {
        uint64_t v71 = 46;
      }
      unsigned int v72 = v68 << 8 >> 24;
      if (v68 << 8 < 0)
      {
        int v73 = __maskrune(v72, 0x40000uLL);
        int v68 = *(_DWORD *)(v12 + 20);
        unsigned int v72 = v68 << 8 >> 24;
      }
      else
      {
        int v73 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v72 + 60) & 0x40000;
      }
      if (v73) {
        uint64_t v74 = v72;
      }
      else {
        uint64_t v74 = 46;
      }
      unsigned int v75 = (__int16)v68 >> 8;
      if (v68 << 16 < 0)
      {
        int v76 = __maskrune(v75, 0x40000uLL);
        int v68 = *(_DWORD *)(v12 + 20);
        unsigned int v75 = (__int16)v68 >> 8;
      }
      else
      {
        int v76 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v75 + 60) & 0x40000;
      }
      if (v76) {
        uint64_t v77 = v75;
      }
      else {
        uint64_t v77 = 46;
      }
      unsigned int v78 = (char)v68;
      if ((v68 << 24) <= 0x7F000000)
      {
        int v79 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * (char)v68 + 60) & 0x40000;
      }
      else
      {
        int v79 = __maskrune((char)v68, 0x40000uLL);
        unsigned int v78 = *(char *)(v12 + 20);
      }
      if (v79) {
        uint64_t v80 = v78;
      }
      else {
        uint64_t v80 = 46;
      }
      ImageIOLog("  '%c%c%c%c' %d: png_set_expand_gray_1_2_4_to_8\n", v71, v74, v77, v80, 1834);
    }
  }
  if (_cg_png_get_valid((uint64_t)v229[0], (uint64_t)v228, 0x10u))
  {
    _cg_png_set_palette_to_rgb((uint64_t)v229[0]);
    if ((gIIODebugFlags & 0x20000) != 0)
    {
      int v81 = *(_DWORD *)(v12 + 20);
      unsigned int v82 = v81 >> 24;
      uint64_t v83 = MEMORY[0x1E4F14390];
      if (v81 < 0)
      {
        int v84 = __maskrune(v82, 0x40000uLL);
        int v81 = *(_DWORD *)(v12 + 20);
        unsigned int v82 = v81 >> 24;
      }
      else
      {
        int v84 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v82 + 60) & 0x40000;
      }
      if (v84) {
        uint64_t v88 = v82;
      }
      else {
        uint64_t v88 = 46;
      }
      unsigned int v89 = v81 << 8 >> 24;
      if (v81 << 8 < 0)
      {
        int v90 = __maskrune(v89, 0x40000uLL);
        int v81 = *(_DWORD *)(v12 + 20);
        unsigned int v89 = v81 << 8 >> 24;
      }
      else
      {
        int v90 = *(_DWORD *)(v83 + 4 * v89 + 60) & 0x40000;
      }
      if (v90) {
        uint64_t v91 = v89;
      }
      else {
        uint64_t v91 = 46;
      }
      unsigned int v92 = (__int16)v81 >> 8;
      if (v81 << 16 < 0)
      {
        int v93 = __maskrune(v92, 0x40000uLL);
        int v81 = *(_DWORD *)(v12 + 20);
        unsigned int v92 = (__int16)v81 >> 8;
      }
      else
      {
        int v93 = *(_DWORD *)(v83 + 4 * v92 + 60) & 0x40000;
      }
      if (v93) {
        uint64_t v94 = v92;
      }
      else {
        uint64_t v94 = 46;
      }
      unsigned int v95 = (char)v81;
      if ((v81 << 24) <= 0x7F000000)
      {
        int v96 = *(_DWORD *)(v83 + 4 * (char)v81 + 60) & 0x40000;
      }
      else
      {
        int v96 = __maskrune((char)v81, 0x40000uLL);
        unsigned int v95 = *(char *)(v12 + 20);
      }
      if (v96) {
        uint64_t v97 = v95;
      }
      else {
        uint64_t v97 = 46;
      }
      ImageIOLog("  '%c%c%c%c' %d: png_set_tRNS_to_alpha\n", v88, v91, v94, v97, 1842);
    }
    *(unsigned char *)(a7 + 28) = 1;
  }
  else if (*(unsigned char *)(a7 + 30) && (*(unsigned char *)(a7 + 18) & 0xFE) == 2)
  {
    _cg_png_set_add_alpha((uint64_t)v229[0], 255, 0);
    if ((gIIODebugFlags & 0x20000) != 0)
    {
      int v85 = *(_DWORD *)(v12 + 20);
      unsigned int v86 = v85 >> 24;
      if (v85 < 0)
      {
        int v87 = __maskrune(v86, 0x40000uLL);
        int v85 = *(_DWORD *)(v12 + 20);
        unsigned int v86 = v85 >> 24;
      }
      else
      {
        int v87 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v86 + 60) & 0x40000;
      }
      if (v87) {
        uint64_t v111 = v86;
      }
      else {
        uint64_t v111 = 46;
      }
      unsigned int v112 = v85 << 8 >> 24;
      if (v85 << 8 < 0)
      {
        int v113 = __maskrune(v112, 0x40000uLL);
        int v85 = *(_DWORD *)(v12 + 20);
        unsigned int v112 = v85 << 8 >> 24;
      }
      else
      {
        int v113 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v112 + 60) & 0x40000;
      }
      if (v113) {
        uint64_t v114 = v112;
      }
      else {
        uint64_t v114 = 46;
      }
      unsigned int v115 = (__int16)v85 >> 8;
      if (v85 << 16 < 0)
      {
        int v116 = __maskrune(v115, 0x40000uLL);
        int v85 = *(_DWORD *)(v12 + 20);
        unsigned int v115 = (__int16)v85 >> 8;
      }
      else
      {
        int v116 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v115 + 60) & 0x40000;
      }
      if (v116) {
        uint64_t v117 = v115;
      }
      else {
        uint64_t v117 = 46;
      }
      unsigned int v118 = (char)v85;
      if ((v85 << 24) <= 0x7F000000)
      {
        int v119 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * (char)v85 + 60) & 0x40000;
      }
      else
      {
        int v119 = __maskrune((char)v85, 0x40000uLL);
        unsigned int v118 = *(char *)(v12 + 20);
      }
      if (v119) {
        uint64_t v120 = v118;
      }
      else {
        uint64_t v120 = 46;
      }
      ImageIOLog("  '%c%c%c%c' %d: png_set_add_alpha: PNG_FILLER_BEFORE\n", v111, v114, v117, v120, 1850);
    }
    *(unsigned char *)(a7 + 27) = 1;
  }
  _cg_png_read_update_info((uint64_t)v229[0], v228);
  unsigned int channels = _cg_png_get_channels((uint64_t)v229[0], (uint64_t)v228);
  *(unsigned char *)(a7 + 18) = _cg_png_get_color_type((uint64_t)v229[0], (uint64_t)v228);
  unsigned int image_width = _cg_png_get_image_width((uint64_t)v229[0], v228);
  image_unsigned int height = _cg_png_get_image_height((uint64_t)v229[0], (uint64_t)v228);
  uint64_t rowbytes = _cg_png_get_rowbytes((uint64_t)v229[0], (uint64_t)v228);
  unint64_t v102 = ImageIOAlignRowBytes(rowbytes, 0x10uLL);
  if (image_width > 0x30D40 || image_height > 0x30D40)
  {
    LogError("InitializePluginData", 1868, "image too large (%ld x %ld)\n", image_width, image_height);
    goto LABEL_185;
  }
  int v103 = v102;
  if (color_type != 3)
  {
    if (v102 * image_height <= 10000 * *(void *)v12)
    {
      BOOL v105 = a8 != 0;
      goto LABEL_190;
    }
    LogError("InitializePluginData", 1878, "image (%ld x %ld) too large (b = %ld  bpr=%ld fs = %ld\n", image_width, image_height, v102 * image_height, v102, *(void *)v12);
LABEL_185:
    char v106 = 0;
    uint64_t v107 = 4294967246;
    goto LABEL_414;
  }
  if (a8)
  {
    CFDictionarySetValue(a8, @"kImageIOInfoHeader_originalIsIndexed", (const void *)*MEMORY[0x1E4F1CFD0]);
    bytes = 0;
    LODWORD(v219) = 0;
    _cg_png_get_PLTE((uint64_t)v229[0], (uint64_t)v228, &bytes, &v219);
    if (LODWORD(v219))
    {
      CFDataRef v104 = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], bytes, 3 * SLODWORD(v219));
      if (v104)
      {
        CFDictionarySetValue(a8, @"kImageIOInfoHeader_originalIndexedColorMap", v104);
        CFRelease(v104);
      }
    }
    BOOL v105 = 1;
  }
  else
  {
    BOOL v105 = 0;
  }
LABEL_190:
  *(_DWORD *)(v12 + 44) = image_width;
  *(_DWORD *)(v12 + 48) = image_height;
  *(_DWORD *)(v12 + 52) = v103;
  *(_WORD *)(v12 + 56) = bit_depth;
  *(_WORD *)(v12 + 60) = channels;
  *(_WORD *)(v12 + 58) = channels * bit_depth;
  if ((*(unsigned char *)(a7 + 18) & 2) != 0 && bit_depth == 8)
  {
    if (channels <= 3)
    {
      _cg_png_set_add_alpha((uint64_t)v229[0], 255, 1);
      if ((gIIODebugFlags & 0x20000) != 0)
      {
        int v108 = *(_DWORD *)(v12 + 20);
        unsigned int v109 = v108 >> 24;
        if (v108 < 0)
        {
          int v110 = __maskrune(v109, 0x40000uLL);
          int v108 = *(_DWORD *)(v12 + 20);
          unsigned int v109 = v108 >> 24;
        }
        else
        {
          int v110 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v109 + 60) & 0x40000;
        }
        if (v110) {
          uint64_t v121 = v109;
        }
        else {
          uint64_t v121 = 46;
        }
        unsigned int v122 = v108 << 8 >> 24;
        if (v108 << 8 < 0)
        {
          int v123 = __maskrune(v122, 0x40000uLL);
          int v108 = *(_DWORD *)(v12 + 20);
          unsigned int v122 = v108 << 8 >> 24;
        }
        else
        {
          int v123 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v122 + 60) & 0x40000;
        }
        if (v123) {
          uint64_t v124 = v122;
        }
        else {
          uint64_t v124 = 46;
        }
        unsigned int v125 = (__int16)v108 >> 8;
        if (v108 << 16 < 0)
        {
          int v126 = __maskrune(v125, 0x40000uLL);
          int v108 = *(_DWORD *)(v12 + 20);
          unsigned int v125 = (__int16)v108 >> 8;
        }
        else
        {
          int v126 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v125 + 60) & 0x40000;
        }
        if (v126) {
          uint64_t v127 = v125;
        }
        else {
          uint64_t v127 = 46;
        }
        unsigned int v128 = (char)v108;
        if ((v108 << 24) <= 0x7F000000)
        {
          int v129 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * (char)v108 + 60) & 0x40000;
        }
        else
        {
          int v129 = __maskrune((char)v108, 0x40000uLL);
          unsigned int v128 = *(char *)(v12 + 20);
        }
        if (v129) {
          uint64_t v130 = v128;
        }
        else {
          uint64_t v130 = 46;
        }
        ImageIOLog("  '%c%c%c%c' %d: png_set_add_alpha: PNG_FILLER_AFTER\n", v121, v124, v127, v130, 1915);
      }
      *(unsigned char *)(a7 + 27) = 1;
      *(_DWORD *)(v12 + 88) = 2097160;
      unsigned int channels = 4;
      *(_WORD *)(v12 + 92) = 4;
    }
    *(unsigned char *)(v12 + 95) = 0;
  }
  *(unsigned char *)(a7 + 29) = BoolForKey;
  unsigned int v131 = 1;
  *(_WORD *)(v12 + 132) = 1;
  if (image_width >= (unint64_t)image_height) {
    unint64_t v132 = image_height;
  }
  else {
    unint64_t v132 = image_width;
  }
  if (Uint32ForKey > v132)
  {
    uint64_t v133 = 1;
LABEL_250:
    unint64_t Uint32ForKey = v133;
    goto LABEL_277;
  }
  if (Uint32ForKey < 2)
  {
    if (*(unsigned __int8 *)(v12 + 32) < 2u)
    {
      unsigned int v131 = 1;
      goto LABEL_277;
    }
    unint64_t v134 = *(unsigned int *)(v12 + 28);
    if (v134
      && ((unsigned int v131 = 32, v134 < (unint64_t)image_width >> 5)
       || (unint64_t)image_height >> 5 > v134
       || (unsigned int v131 = 16, v134 < (unint64_t)image_width >> 4)
       || (unint64_t)image_height >> 4 > v134
       || (unsigned int v131 = 8, v134 < (unint64_t)image_width >> 3)
       || (unint64_t)image_height >> 3 > v134
       || (unsigned int v131 = 4, v134 < (unint64_t)image_width >> 2)
       || (unint64_t)image_height >> 2 > v134
       || (unsigned int v131 = 2, v134 < (unint64_t)image_width >> 1)
       || (unint64_t)image_height >> 1 > v134))
    {
      *(_WORD *)(v12 + 132) = v131;
    }
    else
    {
      unsigned int v131 = 1;
    }
    if (*(_DWORD *)(v12 + 48) > v131)
    {
      uint64_t v133 = v131;
      goto LABEL_250;
    }
    unsigned int v131 = 1;
  }
  else if (Uint32ForKey < 0x80)
  {
    if (Uint32ForKey < 0x40)
    {
      if (Uint32ForKey < 0x20)
      {
        if (Uint32ForKey < 0x10)
        {
          if (Uint32ForKey < 8)
          {
            if (Uint32ForKey < 4) {
              unsigned int v131 = 2;
            }
            else {
              unsigned int v131 = 4;
            }
          }
          else
          {
            unsigned int v131 = 8;
          }
        }
        else
        {
          unsigned int v131 = 16;
        }
      }
      else
      {
        unsigned int v131 = 32;
      }
    }
    else
    {
      unsigned int v131 = 64;
    }
  }
  else
  {
    unsigned int v131 = 128;
  }
  *(_WORD *)(v12 + 132) = v131;
LABEL_277:
  BOOL v135 = (*(unsigned __int8 *)(a7 + 30) | BYTE4(gIIODebugFlags) & 1) == 0;
  if (*(unsigned char *)(a7 + 18) == 3) {
    goto LABEL_285;
  }
  if (*(unsigned __int8 *)(a7 + 20) > 1u) {
    goto LABEL_285;
  }
  unsigned int v136 = *(unsigned __int16 *)(v12 + 56);
  if (v136 != 8 && v136 != 16) {
    goto LABEL_285;
  }
  if (Uint32ForKey <= 1) {
    BOOL v135 = 0;
  }
  if (v135)
  {
    *(_DWORD *)(v12 + 76) = image_width / v131;
    *(_DWORD *)(v12 + 80) = image_height / v131;
    *(_DWORD *)(v12 + 84) = image_width / v131 * channels * (v136 >> 3);
  }
  else
  {
LABEL_285:
    *(_WORD *)(v12 + 132) = 1;
  }
  *(unsigned char *)(v12 + 160) = 0;
  *(unsigned char *)(v12 + 162) = 0;
  if (a5)
  {
    double v219 = 0.0;
    *a5 = PNGReadPlugin::Get_colorspace(v12, a7, (uint64_t)v229[0], (uint64_t)v228, &v219);
    if (v219 != 0.0 && v105)
    {
      IIONumber::IIONumber((IIONumber *)&bytes, v219);
      CFDictionarySetValue(a8, @"kImageIOInfoHeader_gammaValue", value);
      IIONumber::~IIONumber((IIONumber *)&bytes);
    }
  }
  char v138 = *(unsigned char *)(a7 + 18);
  if (*(unsigned char *)(a7 + 35) && (*(unsigned char *)(a7 + 18) & 2) == 0) {
    goto LABEL_185;
  }
  switch(*(unsigned char *)(a7 + 18))
  {
    case 0:
      goto LABEL_303;
    case 2:
      *(unsigned char *)(v12 + 62) = 0;
      if (*(_WORD *)(v12 + 58) == 8 && *(_WORD *)(v12 + 56) == 8) {
        *(void *)(v12 + 88) = 0x5000400200008;
      }
      goto LABEL_320;
    case 3:
      if (*(unsigned char *)(a7 + 30) || *(unsigned char *)(a7 + 38)) {
        *(unsigned char *)(v12 + 62) = 5;
      }
      else {
        *(unsigned char *)(v12 + 62) = 0;
      }
      goto LABEL_320;
    case 4:
      char v138 = 3;
LABEL_303:
      *(unsigned char *)(v12 + 62) = v138;
      *(unsigned char *)(v12 + 94) = v138;
      *(_DWORD *)(v12 + 140) = 1196573017;
      goto LABEL_324;
    case 6:
      if (*(unsigned char *)(a7 + 35))
      {
        int v140 = *(_DWORD *)(a7 + 40) & 0x1F;
        switch(v140)
        {
          case 2:
            LOBYTE(v140) = 1;
            break;
          case 6:
            LOBYTE(v140) = 5;
            break;
          case 4:
            LOBYTE(v140) = 3;
            break;
        }
        *(unsigned char *)(v12 + 62) = v140;
        *(_WORD *)(v12 + 63) = 0;
        *(unsigned char *)(v12 + 65) = 0;
      }
      else
      {
        if (*(unsigned char *)(a7 + 72) == 1 || *(_WORD *)(v12 + 56) != 8) {
          LOBYTE(v140) = 3;
        }
        else {
          LOBYTE(v140) = 1;
        }
        *(unsigned char *)(v12 + 62) = v140;
      }
      *(unsigned char *)(v12 + 94) = v140;
LABEL_320:
      *(_DWORD *)(v12 + 140) = 1380401696;
      int v139 = 1380401696;
      break;
    default:
      int v139 = *(_DWORD *)(v12 + 140);
      break;
  }
  if (v139 == 1380401696 && channels >= 3) {
    *(unsigned char *)(a7 + 34) = 1;
  }
LABEL_324:
  if (_cg_png_get_valid((uint64_t)v229[0], (uint64_t)v228, 1u))
  {
    _cg_png_get_gAMA((uint64_t)v229[0], (uint64_t)v228, (double *)(a7 + 8));
    IIONumber::IIONumber((IIONumber *)v215, *(double *)(a7 + 8));
    IIODictionary::setObjectForKeyGroup(a3, (uint64_t)v215, @"Gamma", @"{PNG}");
    IIONumber::~IIONumber((IIONumber *)v215);
  }
  if (_cg_png_get_valid((uint64_t)v229[0], (uint64_t)v228, 0x800u))
  {
    LODWORD(bytes) = 0;
    _cg_png_get_sRGB((uint64_t)v229[0], (uint64_t)v228, &bytes);
    IIONumber::IIONumber((IIONumber *)v214, (int)bytes);
    IIODictionary::setObjectForKeyGroup(a3, (uint64_t)v214, @"sRGBIntent", @"{PNG}");
    IIONumber::~IIONumber((IIONumber *)v214);
  }
  if (_cg_png_get_valid((uint64_t)v229[0], (uint64_t)v228, 4u))
  {
    double v219 = 0.0;
    double v213 = 0.0;
    double v212 = 0.0;
    double v211 = 0.0;
    double v210 = 0.0;
    double v208 = 0.0;
    double v209 = 0.0;
    double v207 = 0.0;
    _cg_png_get_cHRM((uint64_t)v229[0], (uint64_t)v228, &v219, &v213, &v212, &v211, &v210, &v209, &v208, &v207);
    int v217 = 0;
    bytes = 0;
    xpc_object_t value = 0;
    IIOArray::IIOArray((IIOArray *)&bytes);
    IIONumber::IIONumber((IIONumber *)v206, v219);
    IIOArray::addObject((CFMutableArrayRef *)&bytes, (uint64_t)v206);
    IIONumber::~IIONumber((IIONumber *)v206);
    IIONumber::IIONumber((IIONumber *)v205, v213);
    IIOArray::addObject((CFMutableArrayRef *)&bytes, (uint64_t)v205);
    IIONumber::~IIONumber((IIONumber *)v205);
    IIONumber::IIONumber((IIONumber *)v204, v212);
    IIOArray::addObject((CFMutableArrayRef *)&bytes, (uint64_t)v204);
    IIONumber::~IIONumber((IIONumber *)v204);
    IIONumber::IIONumber((IIONumber *)v203, v211);
    IIOArray::addObject((CFMutableArrayRef *)&bytes, (uint64_t)v203);
    IIONumber::~IIONumber((IIONumber *)v203);
    IIONumber::IIONumber((IIONumber *)v202, v210);
    IIOArray::addObject((CFMutableArrayRef *)&bytes, (uint64_t)v202);
    IIONumber::~IIONumber((IIONumber *)v202);
    IIONumber::IIONumber((IIONumber *)v201, v209);
    IIOArray::addObject((CFMutableArrayRef *)&bytes, (uint64_t)v201);
    IIONumber::~IIONumber((IIONumber *)v201);
    IIONumber::IIONumber((IIONumber *)v200, v208);
    IIOArray::addObject((CFMutableArrayRef *)&bytes, (uint64_t)v200);
    IIONumber::~IIONumber((IIONumber *)v200);
    IIONumber::IIONumber((IIONumber *)v199, v207);
    IIOArray::addObject((CFMutableArrayRef *)&bytes, (uint64_t)v199);
    IIONumber::~IIONumber((IIONumber *)v199);
    IIODictionary::setObjectForKeyGroup(a3, v217, @"Chromaticities", @"{PNG}");
    IIOArray::~IIOArray((IIOArray *)&bytes);
  }
  int interlace_type = _cg_png_get_interlace_type((uint64_t)v229[0], (uint64_t)v228);
  IIONumber::IIONumber((IIONumber *)v198, interlace_type);
  IIODictionary::setObjectForKeyGroup(a3, (uint64_t)v198, @"InterlaceType", @"{PNG}");
  IIONumber::~IIONumber((IIONumber *)v198);
  unsigned int x_pixels_per_meter = _cg_png_get_x_pixels_per_meter((uint64_t)v229[0], (uint64_t)v228);
  unsigned int y_pixels_per_meter = _cg_png_get_y_pixels_per_meter((uint64_t)v229[0], (uint64_t)v228);
  if (x_pixels_per_meter && (unsigned int v144 = y_pixels_per_meter) != 0)
  {
    IIONumber::IIONumber((IIONumber *)v197, x_pixels_per_meter);
    IIODictionary::setObjectForKeyGroup(a3, (uint64_t)v197, @"XPixelsPerMeter", @"{PNG}");
    IIONumber::~IIONumber((IIONumber *)v197);
    IIONumber::IIONumber((IIONumber *)v196, v144);
    IIODictionary::setObjectForKeyGroup(a3, (uint64_t)v196, @"YPixelsPerMeter", @"{PNG}");
    IIONumber::~IIONumber((IIONumber *)v196);
    float v145 = roundf((float)x_pixels_per_meter * 0.0254);
    BOOL valid = ValidDPI(v145);
    if (!valid) {
      goto LABEL_338;
    }
    float v148 = roundf((float)v144 * 0.0254);
    BOOL valid = ValidDPI(v148);
    if (!valid) {
      goto LABEL_338;
    }
    IIONumber::IIONumber((IIONumber *)v195, v145);
    IIODictionary::setObjectForKey((uint64_t)a3, (uint64_t)v195, @"DPIWidth");
    IIONumber::~IIONumber((IIONumber *)v195);
    IIONumber::IIONumber((IIONumber *)v194, v148);
    unsigned int v149 = (IIONumber *)v194;
    IIODictionary::setObjectForKey((uint64_t)a3, (uint64_t)v194, @"DPIHeight");
  }
  else
  {
    float pixel_aspect_ratio = _cg_png_get_pixel_aspect_ratio((uint64_t)v229[0], (uint64_t)v228);
    if (pixel_aspect_ratio <= 0.0) {
      goto LABEL_338;
    }
    IIONumber::IIONumber((IIONumber *)v193, pixel_aspect_ratio);
    unsigned int v149 = (IIONumber *)v193;
    IIODictionary::setObjectForKeyGroup(a3, (uint64_t)v193, @"PixelAspectRatio", @"{PNG}");
  }
  IIONumber::~IIONumber(v149);
LABEL_338:
  if (v182) {
    PNGReadPlugin::AddOrientationToMetadata(valid, v147, a4, (uint64_t)v229[0], (uint64_t)v228);
  }
  else {
    PNGReadPlugin::HandlePNGMetadata(v189, a3, a4, (uint64_t)v229[0], (uint64_t)v228);
  }
  if (IIODictionary::containsKey(v189, @"kCGImageSourceAddPencilKitPrivateData"))
  {
    v151 = *(const void **)(a7 + 64);
    if (v151) {
      IIODictionary::setObjectForKeyGroup(a3, v151, @"PencilKitPrivateData", @"{PNG}");
    }
  }
  _cg_png_destroy_read_struct((uint64_t *)v229, (void **)&v228, 0);
  v229[0] = 0;
  int v152 = *(unsigned __int16 *)(v12 + 58);
  unsigned int v153 = *(unsigned __int16 *)(v12 + 56);
  if (v152 == 32 && v153 == 8)
  {
    if (*(unsigned char *)(v12 + 62) == 3)
    {
      char v154 = 3;
      if (!*(unsigned char *)(a7 + 30) && *(unsigned char *)(a7 + 72) != 1)
      {
        if ((*(_DWORD *)(a7 + 40) & 0x1Fu) - 1 < 2) {
          char v154 = 1;
        }
        else {
          char v154 = 3;
        }
      }
      *(unsigned char *)(v12 + 62) = v154;
      *(unsigned char *)(v12 + 63) = 0;
      goto LABEL_364;
    }
    if (*(unsigned char *)(a7 + 19) == 3)
    {
LABEL_360:
      *(unsigned char *)(a7 + 26) = 1;
      goto LABEL_364;
    }
  }
  else
  {
    if (*(unsigned char *)(a7 + 19) == 3) {
      goto LABEL_360;
    }
    if (v152 == 24)
    {
      if (*(unsigned char *)(v12 + 157)) {
        char v155 = 5;
      }
      else {
        char v155 = 3;
      }
      *(unsigned char *)(v12 + 94) = v155;
      *(unsigned char *)(v12 + 95) = 0;
      goto LABEL_364;
    }
    if (v153 == 16)
    {
      *(unsigned char *)(v12 + 63) = 1;
      *(unsigned char *)(v12 + 95) = 1;
      goto LABEL_364;
    }
  }
  if (!*(unsigned char *)(v12 + 157))
  {
    int v159 = *(unsigned __int8 *)(a7 + 18);
    if (*(unsigned char *)(a7 + 18))
    {
      if (v159 == 2)
      {
        if (v153 > 7) {
          goto LABEL_364;
        }
      }
      else if (v159 != 3)
      {
        goto LABEL_364;
      }
      *(unsigned char *)(a7 + 26) = 1;
      *(_DWORD *)(v12 + 52) = 4 * *(_DWORD *)(v12 + 44);
      *(_DWORD *)(v12 + 56) = 2097160;
      *(_WORD *)(v12 + 62) = 1027;
      *(unsigned char *)(a7 + 34) = 1;
      goto LABEL_364;
    }
    if (v153 == 8)
    {
      *(unsigned char *)(a7 + 27) = 1;
      *(_WORD *)(v12 + 58) = 16;
      *(_DWORD *)(v12 + 52) = 2 * *(_DWORD *)(v12 + 44);
    }
    else
    {
      *(_DWORD *)(v12 + 52) = 2 * *(_DWORD *)(v12 + 44);
      *(_DWORD *)(v12 + 56) = 1048584;
    }
    *(unsigned char *)(v12 + 62) = 3;
  }
LABEL_364:
  if (a5)
  {
    if (!*a5 && *(_DWORD *)(v12 + 140) == 1380401696)
    {
      CFDictionaryRef TopLevelTag = CGImageMetadataGetTopLevelTag(a4, @"http://ns.adobe.com/exif/1.0/", @"ColorSpace");
      if (TopLevelTag)
      {
        CFStringRef v157 = (const __CFString *)CGImageMetadataTagGetValue((uint64_t)TopLevelTag);
        if (v157)
        {
          CFTypeID TypeID = CFStringGetTypeID();
          if (TypeID == CFGetTypeID(v157))
          {
            if (CFStringGetIntValue(v157) == 1) {
              *a5 = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E4F1DC98]);
            }
          }
          else
          {
            CFTypeID v160 = CFNumberGetTypeID();
            if (v160 == CFGetTypeID(v157))
            {
              int v217 = 0;
              bytes = 0;
              xpc_object_t value = 0;
              IIONumber::IIONumber((IIONumber *)&bytes, (const __CFNumber *)v157);
              if (IIONumber::uint32Num((IIONumber *)&bytes) == 1) {
                *a5 = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E4F1DC98]);
              }
              IIONumber::~IIONumber((IIONumber *)&bytes);
            }
          }
        }
      }
    }
  }
  *(void *)(v12 + 176) = 1;
  *(unsigned char *)(a7 + 58) = v181;
  *(unsigned char *)a7 = 1;
  if (*(unsigned char *)(a7 + 30))
  {
    char v161 = 3;
LABEL_384:
    *(unsigned char *)a7 = v161;
    goto LABEL_385;
  }
  if (*(unsigned char *)(a7 + 20) == 7)
  {
    char v161 = 2;
    goto LABEL_384;
  }
LABEL_385:
  char v106 = 1;
  *(_WORD *)(v12 + 192) = 1;
  if (*(unsigned __int16 *)(v12 + 56) != bit_depth)
  {
    IIONumber::IIONumber((IIONumber *)v192, bit_depth);
    IIODictionary::setObjectForKey((uint64_t)a3, (uint64_t)v192, @"Depth");
    IIONumber::~IIONumber((IIONumber *)v192);
  }
  *(unsigned char *)(v12 + 166) = 1;
  int v162 = *(unsigned char *)(v12 + 97) != 0;
  if ((gIIODebugFlags & 0x20000) != 0)
  {
    int v163 = *(unsigned __int8 *)(v12 + 96);
    int v164 = *(unsigned __int8 *)(v12 + 95);
    int v165 = *(unsigned __int8 *)(v12 + 94);
    int v166 = *(_DWORD *)(v12 + 20);
    unsigned int v167 = v166 >> 24;
    if (v166 < 0)
    {
      int v168 = __maskrune(v167, 0x40000uLL);
      int v166 = *(_DWORD *)(v12 + 20);
      unsigned int v167 = v166 >> 24;
    }
    else
    {
      int v168 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v167 + 60) & 0x40000;
    }
    if (v168) {
      uint64_t v169 = v167;
    }
    else {
      uint64_t v169 = 46;
    }
    unsigned int v170 = v166 << 8 >> 24;
    if (v166 << 8 < 0)
    {
      int v171 = __maskrune(v170, 0x40000uLL);
      int v166 = *(_DWORD *)(v12 + 20);
      unsigned int v170 = v166 << 8 >> 24;
    }
    else
    {
      int v171 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v170 + 60) & 0x40000;
    }
    if (v171) {
      uint64_t v172 = v170;
    }
    else {
      uint64_t v172 = 46;
    }
    unsigned int v173 = (__int16)v166 >> 8;
    if (v166 << 16 < 0)
    {
      int v174 = __maskrune(v173, 0x40000uLL);
      int v166 = *(_DWORD *)(v12 + 20);
      unsigned int v173 = (__int16)v166 >> 8;
    }
    else
    {
      int v174 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v173 + 60) & 0x40000;
    }
    if (v174) {
      uint64_t v175 = v173;
    }
    else {
      uint64_t v175 = 46;
    }
    if ((v166 << 24) <= 0x7F000000)
    {
      int v176 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * (char)v166 + 60) & 0x40000;
    }
    else
    {
      int v176 = __maskrune((char)v166, 0x40000uLL);
      int v166 = *(_DWORD *)(v12 + 20);
    }
    unsigned int v177 = (v164 << 12) | (v163 << 16) | (v162 << 8) | v165;
    uint64_t v178 = IIO_BitmapInfoString(v177);
    if (v176) {
      uint64_t v179 = (char)v166;
    }
    else {
      uint64_t v179 = 46;
    }
    ImageIOLog("  '%c%c%c%c' %d: rpd._createImageProviderWithBitmapInfo 0x%08X  %s\n", v169, v172, v175, v179, 2400, v177, v178);
    uint64_t v107 = 0;
    char v106 = 1;
  }
  else
  {
    uint64_t v107 = 0;
  }
LABEL_414:
  if (v229[0]) {
    _cg_png_destroy_read_struct((uint64_t *)v229, (void **)&v228, 0);
  }
  if ((v106 & 1) == 0) {
    goto LABEL_417;
  }
  return v107;
}

void sub_1885B472C(void *a1)
{
  __cxa_begin_catch(a1);
  imagePNG_error_break(*(void *)(v1 - 112));
  __cxa_end_catch();
  JUMPOUT(0x1885B460CLL);
}

void sub_1885B48E8()
{
}

uint64_t _cg_png_get_valid(uint64_t a1, uint64_t a2, unsigned int a3)
{
  uint64_t result = 0;
  if (a1 && a2)
  {
    if (a3 == 16 && !*(_WORD *)(a1 + 384)) {
      return 0;
    }
    else {
      return *(_DWORD *)(a2 + 8) & a3;
    }
  }
  return result;
}

void IIOArray::addObject(CFMutableArrayRef *this, const void *a2)
{
  if (a2 && this[1])
  {
    if (*((unsigned char *)this + 16)) {
      CFArrayAppendValue(this[1], a2);
    }
    else {
      LogError("addObject", 630, "IIOArray -- addObject for immutable array\n");
    }
  }
}

void IIOArray::addObject(CFMutableArrayRef *a1, uint64_t a2)
{
}

void IIONumber::IIONumber(IIONumber *this, double a2)
{
  double valuePtr = a2;
  *(void *)this = &unk_1ED4E5FD8;
  *((void *)this + 1) = 13;
  *((void *)this + 2) = 0;
  *((void *)this + 2) = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberDoubleType, &valuePtr);
}

uint64_t _cg_png_get_color_type(uint64_t a1, uint64_t a2)
{
  uint64_t result = 0;
  if (a1)
  {
    if (a2) {
      return *(unsigned __int8 *)(a2 + 37);
    }
  }
  return result;
}

uint64_t IIOSkipXMP_and_IPTC(IIODictionary *a1)
{
  if (!IIOMetadataParsingEnabledFlag()) {
    return 1;
  }
  uint64_t result = IIOSkipMetadata(a1);
  if (a1)
  {
    if ((result & 1) == 0)
    {
      uint64_t result = IIODictionary::getBoolForKey(a1, @"kCGImageSourceSkipXMPMetadata");
      if (result)
      {
        if ((gIIODebugFlags & 0x4000000000000) != 0)
        {
          if (IIO_OSAppleInternalBuild()) {
            ImageIOLog("   kCGImageSourceSkipXMPMetadata --> skipping XMP+IPTC\n");
          }
        }
        return 1;
      }
    }
  }
  return result;
}

uint64_t _cg_png_set_option(uint64_t a1, unsigned int a2, int a3)
{
  uint64_t v3 = 1;
  if (a1 && a2 <= 0xD && (a2 & 1) == 0)
  {
    int v4 = 3 << a2;
    if (a3) {
      int v5 = 3;
    }
    else {
      int v5 = 2;
    }
    int v6 = *(_DWORD *)(a1 + 680);
    *(_DWORD *)(a1 + 680) = v6 & ~v4 | (v5 << a2);
    return (v6 & v4) >> a2;
  }
  return v3;
}

uint64_t _cg_png_set_benign_errors(uint64_t result, int a2)
{
  if (a2) {
    int v2 = 7340032;
  }
  else {
    int v2 = 0;
  }
  *(_DWORD *)(result + 80) = *(_DWORD *)(result + 80) & 0xFF8FFFFF | v2;
  return result;
}

void png_destroy_png_struct(void *__src)
{
  v2[135] = *MEMORY[0x1E4F143B8];
  if (__src)
  {
    memcpy(v2, __src, 0x438uLL);
    bzero(__src, 0x438uLL);
    if (v2[104]) {
      ((void (*)(void *, void *))v2[104])(v2, __src);
    }
    else {
      free(__src);
    }
  }
}

uint64_t _cg_png_get_rowbytes(uint64_t a1, uint64_t a2)
{
  uint64_t result = 0;
  if (a1)
  {
    if (a2) {
      return *(void *)(a2 + 16);
    }
  }
  return result;
}

uint64_t png_read_transform_info(uint64_t result, unsigned int *a2)
{
  int v2 = *(_DWORD *)(result + 88);
  if ((v2 & 0x1000) == 0) {
    goto LABEL_7;
  }
  int v3 = *((unsigned __int8 *)a2 + 37);
  if (v3 == 3)
  {
    if (*(_WORD *)(result + 384)) {
      char v4 = 6;
    }
    else {
      char v4 = 2;
    }
    *((unsigned char *)a2 + 37) = v4;
    *((unsigned char *)a2 + 36) = 8;
    *((_WORD *)a2 + 17) = 0;
    if (!*(void *)(result + 368)) {
      _cg_png_error((void (**)(void))result, "Palette is NULL in indexed image");
    }
LABEL_7:
    if ((v2 & 0x80) == 0) {
      goto LABEL_9;
    }
    goto LABEL_8;
  }
  if ((v2 & 0x2000000) != 0 && *(_WORD *)(result + 384)) {
    *((unsigned char *)a2 + 37) = v3 | 4;
  }
  if (*((unsigned __int8 *)a2 + 36) <= 7u) {
    *((unsigned char *)a2 + 36) = 8;
  }
  *((_WORD *)a2 + 17) = 0;
  if ((v2 & 0x80) != 0)
  {
LABEL_8:
    *((_WORD *)a2 + 105) = *(_WORD *)(result + 420);
    *(void *)((char *)a2 + 202) = *(void *)(result + 412);
  }
LABEL_9:
  a2[13] = *(_DWORD *)(result + 1000);
  unsigned int v5 = *((unsigned __int8 *)a2 + 36);
  if ((v2 & 0x4000400) != 0 && v5 == 16)
  {
    unsigned int v5 = 8;
    *((unsigned char *)a2 + 36) = 8;
  }
  if ((v2 & 0x4000) != 0) {
    *((unsigned char *)a2 + 37) |= 2u;
  }
  if ((v2 & 0x600000) != 0) {
    *((unsigned char *)a2 + 37) &= ~2u;
  }
  if ((v2 & 0x40) != 0 && (*((unsigned __int8 *)a2 + 37) | 4) == 6 && *(void *)(result + 664) && v5 == 8)
  {
    *((unsigned char *)a2 + 37) = 3;
    if ((v2 & 0x200) == 0) {
      goto LABEL_28;
    }
  }
  else if ((v2 & 0x200) == 0 || v5 != 8)
  {
LABEL_29:
    if ((v2 & 4) == 0) {
      goto LABEL_32;
    }
    goto LABEL_30;
  }
  if (*((unsigned char *)a2 + 37) == 3)
  {
LABEL_28:
    unsigned int v5 = 8;
    goto LABEL_29;
  }
  unsigned int v5 = 16;
  *((unsigned char *)a2 + 36) = 16;
  if ((v2 & 4) == 0) {
    goto LABEL_32;
  }
LABEL_30:
  if (v5 <= 7)
  {
    LOBYTE(v5) = 8;
    *((unsigned char *)a2 + 36) = 8;
  }
LABEL_32:
  int v7 = *((unsigned __int8 *)a2 + 37);
  if (v7 != 3 && (v7 & 2) != 0) {
    char v8 = 3;
  }
  else {
    char v8 = 1;
  }
  *((unsigned char *)a2 + 41) = v8;
  if ((v2 & 0x40000) != 0)
  {
    v7 &= ~4u;
    *((unsigned char *)a2 + 37) = v7;
    *((_WORD *)a2 + 17) = 0;
    if ((v7 & 4) == 0)
    {
LABEL_47:
      if ((v2 & 0x8000) == 0) {
        goto LABEL_54;
      }
      goto LABEL_51;
    }
  }
  else if ((v7 & 4) == 0)
  {
    goto LABEL_47;
  }
  *((unsigned char *)a2 + 41) = ++v8;
  if ((v2 & 0x8000) == 0) {
    goto LABEL_54;
  }
LABEL_51:
  if ((v7 | 2) == 2)
  {
    *((unsigned char *)a2 + 41) = ++v8;
    if ((v2 & 0x1000000) != 0) {
      *((unsigned char *)a2 + 37) = v7 | 4;
    }
  }
LABEL_54:
  if ((v2 & 0x100000) != 0)
  {
    char v9 = *(unsigned char *)(result + 72);
    if (v9)
    {
      *((unsigned char *)a2 + 36) = v9;
      LOBYTE(v5) = v9;
    }
    char v10 = *(unsigned char *)(result + 73);
    if (v10)
    {
      *((unsigned char *)a2 + 41) = v10;
      char v8 = v10;
    }
  }
  unsigned __int8 v11 = v5 * v8;
  *((unsigned char *)a2 + 42) = v5 * v8;
  BOOL v12 = (v5 * v8) >= 8u;
  unint64_t v13 = (*a2 * (unint64_t)(v5 * v8) + 7) >> 3;
  unint64_t v14 = *a2 * (unint64_t)(v11 >> 3);
  if (!v12) {
    unint64_t v14 = v13;
  }
  *((void *)a2 + 2) = v14;
  *(void *)(result + 352) = v14;
  return result;
}

void *png_create_read_struct_2(unsigned char *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  png_struct = png_create_png_struct(a1, a2, a3, a4, a5, a6, a7);
  char v8 = png_struct;
  if (png_struct)
  {
    *((_DWORD *)png_struct + 238) = 0x4000;
    int v9 = *((_DWORD *)png_struct + 20) | 0x300000;
    *((_DWORD *)png_struct + 19) = 0x8000;
    *((_DWORD *)png_struct + 20) = v9;
    _cg_png_set_read_fn(png_struct, 0, 0);
  }
  return v8;
}

void *_cg_png_set_read_fn(void *result, uint64_t a2, size_t (*a3)(size_t result, void *__ptr, size_t a3))
{
  if (result)
  {
    int v3 = result;
    if (a3) {
      char v4 = a3;
    }
    else {
      char v4 = png_default_read_data;
    }
    result[4] = v4;
    result[5] = a2;
    if (result[3])
    {
      result[3] = 0;
      uint64_t result = (void *)png_warning((uint64_t)result, "Can't set both read_data_fn and write_data_fn in the same structure");
    }
    v3[54] = 0;
  }
  return result;
}

void *png_create_png_struct(unsigned char *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  v17[135] = *MEMORY[0x1E4F143B8];
  bzero(v17, 0x438uLL);
  HIDWORD(v17[109]) = 1000000;
  v17[110] = 0x3E8000F4240;
  v17[111] = 8000000;
  png_set_mem_fn(v17, a5, a6, a7);
  png_set_error_fn(v17, a2, a3, a4);
  if (!png_user_version_check((uint64_t)v17, a1)) {
    return 0;
  }
  unint64_t v14 = png_malloc_warn(v17, 0x438uLL);
  unsigned int v15 = v14;
  if (v14)
  {
    v17[20] = png_zalloc;
    v17[21] = png_zfree;
    v17[22] = v14;
    memcpy(v14, v17, 0x438uLL);
  }
  return v15;
}

void *png_malloc_warn(void *result, size_t size)
{
  if (result)
  {
    uint64_t v2 = (uint64_t)result;
    if (!size) {
      goto LABEL_5;
    }
    int v3 = (uint64_t (*)(void *))result[103];
    if (v3)
    {
      uint64_t result = (void *)v3(result);
      if (result) {
        return result;
      }
      goto LABEL_5;
    }
    uint64_t result = malloc_type_malloc(size, 0xB622AF59uLL);
    if (!result)
    {
LABEL_5:
      png_warning(v2, "Out of memory");
      return 0;
    }
  }
  return result;
}

uint64_t png_user_version_check(uint64_t a1, unsigned char *a2)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  if (a2)
  {
    uint64_t v4 = 0;
    unsigned int v5 = 0;
    do
    {
      int v6 = a2[v4];
      if (v6 != a1643[v4]) {
        *(_DWORD *)(a1 + 80) |= 0x20000u;
      }
      if (v6 == 46) {
        ++v5;
      }
    }
    while (v5 <= 1 && v4++ != 6 && v6 != 0);
    if ((*(unsigned char *)(a1 + 82) & 2) == 0) {
      return 1;
    }
  }
  else
  {
    *(_DWORD *)(a1 + 80) |= 0x20000u;
  }
  memset(v13, 0, sizeof(v13));
  unint64_t v10 = png_safecat((uint64_t)v13, 0x80uLL, 0, "Application built with libpng-");
  unint64_t v11 = png_safecat((uint64_t)v13, 0x80uLL, v10, a2);
  unint64_t v12 = png_safecat((uint64_t)v13, 0x80uLL, v11, " but running with ");
  png_safecat((uint64_t)v13, 0x80uLL, v12, "1.6.43");
  png_warning(a1, v13);
  return 0;
}

void *png_set_mem_fn(void *result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (result)
  {
    result[102] = a2;
    result[103] = a3;
    result[104] = a4;
  }
  return result;
}

void *png_set_error_fn(void *result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (result)
  {
    result[1] = a4;
    result[2] = a2;
    std::string *result = a3;
  }
  return result;
}

uint64_t _cg_png_set_read_user_chunk_fn(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (result)
  {
    *(void *)(result + 728) = a3;
    *(void *)(result + 720) = a2;
  }
  return result;
}

void *_cg_png_create_read_struct(unsigned char *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return png_create_read_struct_2(a1, a2, a3, a4, 0, 0, 0);
}

IIOImageRead *IIOImageReadSession::globalInfoForType(IIOImageReadSession *this, int a2)
{
  uint64_t result = (IIOImageRead *)*((void *)this + 4);
  if (result) {
    return (IIOImageRead *)IIOImageRead::globalInfoPtrForType(result, a2);
  }
  return result;
}

uint64_t IIOImageRead::globalInfoPtrForType(IIOImageRead *this, int a2)
{
  uint64_t v4 = (pthread_mutex_t *)((char *)this + 88);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 88));
  unsigned int v5 = (uint64_t *)*((void *)this + 19);
  int v6 = (uint64_t *)*((void *)this + 20);
  if (v5 == v6)
  {
LABEL_7:
    uint64_t v8 = 0;
  }
  else
  {
    while (a2 != 1684170528 && *((_DWORD *)v5 + 4) != a2)
    {
      v5 += 3;
      if (v5 == v6) {
        goto LABEL_7;
      }
    }
    uint64_t v8 = *v5;
  }
  pthread_mutex_unlock(v4);
  return v8;
}

BOOL ValidDPI(float a1)
{
  BOOL v1 = a1 >= 10.0;
  if (a1 > 4800.0) {
    BOOL v1 = 0;
  }
  return (LODWORD(a1) & 0x7FFFFFFFu) < 0x7F800000 && v1;
}

void IIONumber::IIONumber(IIONumber *this, float a2)
{
  float valuePtr = a2;
  *(void *)this = &unk_1ED4E5FD8;
  *((void *)this + 1) = 12;
  *((void *)this + 2) = 0;
  *((void *)this + 2) = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberFloatType, &valuePtr);
}

uint64_t _cg_png_get_bit_depth(uint64_t a1, uint64_t a2)
{
  uint64_t result = 0;
  if (a1)
  {
    if (a2) {
      return *(unsigned __int8 *)(a2 + 36);
    }
  }
  return result;
}

unint64_t ImageIOAlignRowBytes(uint64_t a1, unint64_t a2)
{
  if (a2) {
    return (a1 + a2 - 1) / a2 * a2;
  }
  else {
    return (a1 + 1) & 0xFFFFFFFFFFFFFFFELL;
  }
}

uint64_t PNGReadPlugin::Validate_png_info(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(unsigned char *)(a3 + 35))
  {
    int bit_depth = _cg_png_get_bit_depth(a1, a2);
    int color_type = _cg_png_get_color_type(a1, a2);
    if (bit_depth != 8 || color_type == 3)
    {
      *(_WORD *)(a3 + 35) = 256;
      *(_DWORD *)(a3 + 40) = 0;
    }
  }
  return 0;
}

uint64_t _cg_png_set_interlace_handling(uint64_t a1)
{
  if (!a1 || !*(unsigned char *)(a1 + 388)) {
    return 1;
  }
  *(_DWORD *)(a1 + 88) |= 2u;
  return 7;
}

uint64_t _cg_png_get_y_pixels_per_meter(uint64_t a1, uint64_t a2)
{
  uint64_t result = 0;
  if (a1 && a2)
  {
    if ((*(unsigned char *)(a2 + 8) & 0x80) != 0 && *(unsigned char *)(a2 + 232) == 1) {
      return *(unsigned int *)(a2 + 228);
    }
    else {
      return 0;
    }
  }
  return result;
}

uint64_t _cg_png_get_x_pixels_per_meter(uint64_t a1, uint64_t a2)
{
  uint64_t result = 0;
  if (a1 && a2)
  {
    if ((*(unsigned char *)(a2 + 8) & 0x80) != 0 && *(unsigned char *)(a2 + 232) == 1) {
      return *(unsigned int *)(a2 + 224);
    }
    else {
      return 0;
    }
  }
  return result;
}

uint64_t _cg_png_get_interlace_type(uint64_t a1, uint64_t a2)
{
  uint64_t result = 0;
  if (a1)
  {
    if (a2) {
      return *(unsigned __int8 *)(a2 + 40);
    }
  }
  return result;
}

uint64_t _cg_png_get_image_width(uint64_t a1, unsigned int *a2)
{
  uint64_t result = 0;
  if (a1)
  {
    if (a2) {
      return *a2;
    }
  }
  return result;
}

uint64_t _cg_png_get_image_height(uint64_t a1, uint64_t a2)
{
  uint64_t result = 0;
  if (a1)
  {
    if (a2) {
      return *(unsigned int *)(a2 + 4);
    }
  }
  return result;
}

uint64_t _cg_png_get_channels(uint64_t a1, uint64_t a2)
{
  uint64_t result = 0;
  if (a1)
  {
    if (a2) {
      return *(unsigned __int8 *)(a2 + 41);
    }
  }
  return result;
}

CGColorSpace *PNGReadPlugin::Get_colorspace(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, double *a5)
{
  __dst[96] = *MEMORY[0x1E4F143B8];
  int color_type = _cg_png_get_color_type(a3, a4);
  *a5 = 0.0;
  if (*(unsigned char *)(a2 + 25))
  {
    cHRM_colorspace = (CGColorSpace *)CGColorSpaceCreateFromCICP();
    if (cHRM_colorspace) {
      goto LABEL_25;
    }
  }
  BOOL valid = (UInt8 *)_cg_png_get_valid(a3, a4, 0x1000u);
  if (!valid) {
    goto LABEL_24;
  }
  __src = 0;
  __dst[0] = 0;
  CFIndex length = 0;
  BOOL valid = (UInt8 *)_cg_png_get_iCCP(a3, a4, __dst, &length, (unsigned int **)&__src, (_DWORD *)&length + 1);
  if (HIDWORD(length) < 0x81)
  {
    if (color_type != 3)
    {
      BOOL v14 = 0;
      LOBYTE(v15) = 0;
LABEL_19:
      if ((color_type & 2) != 0) {
        LOBYTE(v15) = v14;
      }
      if (v15) {
        goto LABEL_24;
      }
      BOOL valid = (UInt8 *)__src;
      goto LABEL_23;
    }
LABEL_24:
    cHRM_colorspace = PNGReadPlugin::Get_cHRM_colorspace((uint64_t)valid, a3, a4, a5);
    goto LABEL_25;
  }
  BOOL valid = (UInt8 *)__src;
  int v13 = *((unsigned __int8 *)__src + 16);
  if (v13 == 71)
  {
    if (*((unsigned char *)__src + 17) == 82 && *((unsigned char *)__src + 18) == 65)
    {
      BOOL v15 = 0;
      BOOL v14 = *((unsigned char *)__src + 19) == 89;
      goto LABEL_16;
    }
  }
  else if (v13 == 82 && *((unsigned char *)__src + 17) == 71 && *((unsigned char *)__src + 18) == 66)
  {
    BOOL v14 = 0;
    BOOL v15 = *((unsigned __int8 *)__src + 19) == 32;
    goto LABEL_16;
  }
  BOOL v15 = 0;
  BOOL v14 = 0;
LABEL_16:
  if (color_type != 3) {
    goto LABEL_19;
  }
  if (!v15) {
    goto LABEL_24;
  }
LABEL_23:
  BOOL valid = (UInt8 *)CGColorSpaceCreateWithCopyOfData(valid, HIDWORD(length));
  cHRM_colorspace = (CGColorSpace *)valid;
  if (!valid) {
    goto LABEL_24;
  }
LABEL_25:
  if (color_type == 3 && !_cg_png_get_valid(a3, a4, 0x10u))
  {
    if (!cHRM_colorspace) {
      cHRM_colorspace = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E4F1DC98]);
    }
    if (!*(unsigned char *)(a2 + 32))
    {
      bzero(__dst, 0x300uLL);
      __src = 0;
      HIDWORD(length) = 0;
      _cg_png_get_PLTE(a3, a4, &__src, (_DWORD *)&length + 1);
      uint64_t v17 = SHIDWORD(length);
      memcpy(__dst, __src, 3 * SHIDWORD(length));
      if (*(unsigned char *)(a1 + 157))
      {
        CGColorSpaceRef Indexed = CGColorSpaceCreateIndexed(cHRM_colorspace, v17 - 1, (const unsigned __int8 *)__dst);
        if (Indexed)
        {
          CGColorSpaceRef v19 = Indexed;
          CGColorSpaceRelease(cHRM_colorspace);
          return v19;
        }
      }
    }
  }
  return cHRM_colorspace;
}

CGColorSpaceRef PNGReadPlugin::Get_cHRM_colorspace(uint64_t a1, uint64_t a2, uint64_t a3, double *a4)
{
  *a4 = 0.0;
  int color_type = _cg_png_get_color_type(a2, a3);
  if (_cg_png_get_valid(a2, a3, 0x800u))
  {
    if ((color_type & 2) == 0)
    {
      uint64_t v8 = (const __CFString **)MEMORY[0x1E4F1DC00];
LABEL_24:
      CFStringRef v21 = *v8;
      return CGColorSpaceCreateWithName(v21);
    }
LABEL_23:
    uint64_t v8 = (const __CFString **)MEMORY[0x1E4F1DC98];
    goto LABEL_24;
  }
  if (_cg_png_get_valid(a2, a3, 4u) && _cg_png_get_valid(a2, a3, 1u))
  {
    double v33 = 0.0;
    double v34 = 0.0;
    double v32 = 0.0;
    double v30 = 0.0;
    double v31 = 0.0;
    double v28 = 0.0;
    double v29 = 0.0;
    double v26 = 0.0;
    double v27 = 0.0;
    _cg_png_get_cHRM(a2, a3, &v33, &v32, &v31, &v30, &v29, &v28, &v27, &v26);
    _cg_png_get_gAMA(a2, a3, &v34);
    CGColorSpaceRef result = 0;
    if (v34 <= 0.0 || v33 <= 0.0 || v32 <= 0.0) {
      return result;
    }
    if ((color_type & 2) != 0 && v31 > 0.0 && v30 > 0.0 && v29 > 0.0 && v28 > 0.0 && v27 > 0.0 && v26 > 0.0)
    {
      float v10 = v33;
      float v11 = v32;
      float v12 = v31;
      float v13 = v30;
      float v14 = v29;
      float v15 = v28;
      float v16 = v27;
      float v17 = v26;
      float v18 = 1.0 / v34;
      return CGColorSpaceCreateCalRGB(v10, v11, v12, v13, v14, v15, v16, v17, v18);
    }
    if (color_type != 3)
    {
      float v23 = v33;
      float v24 = v32;
      float v25 = 1.0 / v34;
      return CGColorSpaceCreateCalGray(v23, v24, v25);
    }
    return 0;
  }
  if (!_cg_png_get_valid(a2, a3, 1u)) {
    return 0;
  }
  _cg_png_get_gAMA(a2, a3, a4);
  double v19 = *a4;
  if ((color_type & 2) != 0)
  {
    if (vabdd_f64(2.2, v19) >= 0.00003)
    {
      float v22 = 1.0 / v19;
      return CGColorSpaceCreateCalRGB(0.3127, 0.329, 0.64, 0.33, 0.3, 0.6, 0.15, 0.06, v22);
    }
    goto LABEL_23;
  }

  float v20 = 1.0 / v19;
  return CGColorSpaceCreateCalGray(0.3127, 0.329, v20);
}

float _cg_png_get_pixel_aspect_ratio(uint64_t a1, uint64_t a2)
{
  float result = 0.0;
  if (a1 && a2 && (*(unsigned char *)(a2 + 8) & 0x80) != 0)
  {
    unsigned int v3 = *(_DWORD *)(a2 + 224);
    if (v3) {
      return (float)*(unsigned int *)(a2 + 228) / (float)v3;
    }
  }
  return result;
}

uint64_t _cg_png_get_gAMA(uint64_t a1, uint64_t a2, double *a3)
{
  uint64_t result = 0;
  if (a1)
  {
    if (a2)
    {
      uint64_t result = 0;
      if (a3)
      {
        if (*(_WORD *)(a2 + 126))
        {
          *a3 = (double)*(int *)(a2 + 52) * 0.00001;
          return 1;
        }
      }
    }
  }
  return result;
}

uint64_t _cg_png_get_cHRM(uint64_t a1, uint64_t a2, double *a3, double *a4, double *a5, double *a6, double *a7, double *a8, double *a9, double *a10)
{
  uint64_t result = 0;
  if (a1 && a2)
  {
    if ((*(_WORD *)(a2 + 126) & 2) != 0)
    {
      if (a3) {
        *a3 = (double)*(int *)(a2 + 80) * 0.00001;
      }
      if (a4) {
        *a4 = (double)*(int *)(a2 + 84) * 0.00001;
      }
      if (a5) {
        *a5 = (double)*(int *)(a2 + 56) * 0.00001;
      }
      if (a6) {
        *a6 = (double)*(int *)(a2 + 60) * 0.00001;
      }
      if (a7) {
        *a7 = (double)*(int *)(a2 + 64) * 0.00001;
      }
      if (a8) {
        *a8 = (double)*(int *)(a2 + 68) * 0.00001;
      }
      if (a9) {
        *a9 = (double)*(int *)(a2 + 72) * 0.00001;
      }
      if (a10) {
        *a10 = (double)*(int *)(a2 + 76) * 0.00001;
      }
      return 4;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t _cg_png_get_sRGB(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  uint64_t result = 0;
  if (a1)
  {
    if (a2)
    {
      uint64_t result = 0;
      if (a3)
      {
        if ((*(_DWORD *)(a2 + 8) & 0x800) != 0)
        {
          *a3 = *(unsigned __int16 *)(a2 + 124);
          return 2048;
        }
      }
    }
  }
  return result;
}

uint64_t _cg_png_get_iCCP(uint64_t a1, uint64_t a2, void *a3, _DWORD *a4, unsigned int **a5, _DWORD *a6)
{
  uint64_t result = 0;
  if (a1)
  {
    if (a2)
    {
      uint64_t result = 0;
      if (a6)
      {
        if (a5 && a3 && (*(_DWORD *)(a2 + 8) & 0x1000) != 0)
        {
          uint64_t v8 = *(unsigned int **)(a2 + 136);
          *a3 = *(void *)(a2 + 128);
          *a5 = v8;
          *a6 = bswap32(*v8);
          if (a4) {
            *a4 = 0;
          }
          return 4096;
        }
      }
    }
  }
  return result;
}

uint64_t _cg_png_set_crc_action(uint64_t result, int a2, int a3)
{
  if (result)
  {
    uint64_t v4 = result;
    switch(a2)
    {
      case 2:
        uint64_t result = png_warning(result, "Can't discard critical data on CRC error");
        goto LABEL_4;
      case 3:
        unsigned int v5 = *(_DWORD *)(result + 80) & 0xFFFFF3FF | 0x400;
        goto LABEL_7;
      case 4:
        unsigned int v5 = *(_DWORD *)(result + 80) | 0xC00;
        goto LABEL_7;
      case 5:
        goto LABEL_8;
      default:
LABEL_4:
        unsigned int v5 = *(_DWORD *)(v4 + 80) & 0xFFFFF3FF;
LABEL_7:
        *(_DWORD *)(v4 + 80) = v5;
LABEL_8:
        switch(a3)
        {
          case 1:
            unsigned int v6 = *(_DWORD *)(v4 + 80) & 0xFFFFFCFF | 0x200;
            goto LABEL_13;
          case 3:
            unsigned int v6 = *(_DWORD *)(v4 + 80) & 0xFFFFFCFF | 0x100;
            goto LABEL_13;
          case 4:
            unsigned int v6 = *(_DWORD *)(v4 + 80) | 0x300;
            goto LABEL_13;
          case 5:
            return result;
          default:
            unsigned int v6 = *(_DWORD *)(v4 + 80) & 0xFFFFFCFF;
LABEL_13:
            *(_DWORD *)(v4 + 80) = v6;
            break;
        }
        break;
    }
  }
  return result;
}

uint64_t _cg_png_set_swap(uint64_t result)
{
  if (result)
  {
    if (*(unsigned char *)(result + 392) == 16) {
      *(_DWORD *)(result + 88) |= 0x10u;
    }
  }
  return result;
}

CGColorSpaceRef CGColorSpaceCreateCalGray(float a1, float a2, float a3)
{
  if (fabs(a1 + -0.3127) >= 0.0005 || fabs(a2 + -0.329) >= 0.0005) {
    goto LABEL_9;
  }
  if (fabs(a3 + -2.2) < 0.0005)
  {
    unsigned int v6 = (CFStringRef *)MEMORY[0x1E4F1DC00];
    goto LABEL_7;
  }
  if (fabs(a3 + -1.0) >= 0.0005)
  {
LABEL_9:
    memset(v21, 0, sizeof(v21));
    IIODictionary::IIODictionary((IIODictionary *)v21);
    CFMutableArrayRef v18 = 0;
    xpc_object_t value = 0;
    uint64_t v20 = 0;
    IIOArray::IIOArray((IIOArray *)&v18);
    CFMutableArrayRef v15 = 0;
    float v16 = 0;
    uint64_t v17 = 0;
    IIOArray::IIOArray((IIOArray *)&v15);
    CFMutableArrayRef v12 = 0;
    float v13 = 0;
    uint64_t v14 = 0;
    IIOArray::IIOArray((IIOArray *)&v12);
    uint64_t v8 = (const void *)*MEMORY[0x1E4F1CFD0];
    IIODictionary::setObjectForKey((IIODictionary *)v21, (const void *)*MEMORY[0x1E4F1CFD0], @"skipPhosphorsCheck");
    IIODictionary::setObjectForKey((IIODictionary *)v21, @"Calibrated Gray Colorspace", @"description");
    IIODictionary::setObjectForKey((IIODictionary *)v21, v8, @"unrestrictedGamma");
    IIODictionary::setObjectForKey((IIODictionary *)v21, @"calGray", @"profileType");
    IIOAddDateComponents(&v18);
    IIODictionary::setObjectForKey((IIODictionary *)v21, value, @"Date");
    IIONumber::IIONumber((IIONumber *)v11, a3);
    IIODictionary::setObjectForKey((uint64_t)v21, (uint64_t)v11, @"kGamma");
    IIONumber::~IIONumber((IIONumber *)v11);
    IIOAddXYZfrom_xy(&v15, a1, a2, 1.0);
    IIODictionary::setObjectForKey((IIODictionary *)v21, v16, @"wtpt");
    IIOAddXYZfrom_xy(&v12, 0.0, 0.0, 0.0);
    IIODictionary::setObjectForKey((IIODictionary *)v21, v13, @"bkpt");
    Profile = (const void *)ColorSyncMakeProfile();
    IIOArray::~IIOArray((IIOArray *)&v12);
    IIOArray::~IIOArray((IIOArray *)&v15);
    IIOArray::~IIOArray((IIOArray *)&v18);
    IIODictionary::~IIODictionary((IIODictionary *)v21);
    if (!Profile) {
      return CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E4F1DC00]);
    }
    CGColorSpaceRef v7 = (CGColorSpaceRef)MEMORY[0x18C11AC00](Profile, 0);
    CFRelease(Profile);
    if (!v7) {
      return CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E4F1DC00]);
    }
    return v7;
  }
  unsigned int v6 = (CFStringRef *)MEMORY[0x1E4F1DC78];
LABEL_7:
  CGColorSpaceRef v7 = CGColorSpaceCreateWithName(*v6);
  if (!v7) {
    return CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E4F1DC00]);
  }
  return v7;
}

void sub_1885B5EF4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va3, a2);
  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v4 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  va_copy(va2, va1);
  uint64_t v8 = va_arg(va2, void);
  uint64_t v10 = va_arg(va2, void);
  uint64_t v11 = va_arg(va2, void);
  va_copy(va3, va2);
  uint64_t v12 = va_arg(va3, void);
  uint64_t v14 = va_arg(va3, void);
  uint64_t v15 = va_arg(va3, void);
  IIONumber::~IIONumber((IIONumber *)va);
  IIOArray::~IIOArray((IIOArray *)va1);
  IIOArray::~IIOArray((IIOArray *)va2);
  IIOArray::~IIOArray((IIOArray *)va3);
  IIODictionary::~IIODictionary((IIODictionary *)(v2 - 72));
  _Unwind_Resume(a1);
}

void IIO_ReaderHandler::buildPluginList(IIO_ReaderHandler *this)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  kdebug_trace();
  v9[0] = 0;
  v9[1] = v9;
  _DWORD v9[2] = 0x2000000000;
  void v9[3] = 0;
  IIOInitDebugFlags();
  uint64_t v8 = 0;
  if (IIO_OSAppleInternalBuild() && (dyld_process_is_restricted() & 1) == 0) {
    BOOL v1 = getenv("RAWCAMERA_BUNDLE_PATH");
  }
  else {
    BOOL v1 = 0;
  }
  if ((gIIODebugFlags & 0x8000000) != 0) {
    goto LABEL_21;
  }
  if (!v1 || (uint64_t v2 = dlopen(v1, 257)) == 0)
  {
    uint64_t v2 = dlopen("/System/Library/CoreServices/RawCamera.bundle/RawCamera", 257);
    if (!v2)
    {
      uint64_t v2 = dlopen("/System/Library/CoreServices/RawCamera.bundle/Contents/MacOS/RawCamera", 257);
      if (!v2)
      {
        uint64_t v7 = dlerror();
        LogError("buildPluginList", 824, "*** ERROR: failed to load 'RawCamera' bundle: '%s'\n", v7);
LABEL_21:
        if (IIO_ReaderHandler::UseAppleJPEG(void)::appleJPEGCheck != -1) {
          dispatch_once(&IIO_ReaderHandler::UseAppleJPEG(void)::appleJPEGCheck, &__block_literal_global_27);
        }
        if (IIO_ReaderHandler::UseAppleJPEG(void)::gUseAppleJPEGPlugin) {
          CreateReader_AppleJPEG();
        }
        CreateReader_LibJPEG();
      }
    }
  }
  unsigned int v3 = dlsym(v2, RawCamera_CopyRawPluginsInfoArray);
  if (v3)
  {
    if (((uint64_t (*)(void, void))v3)(0, 0)) {
      operator new();
    }
  }
  else
  {
    uint64_t v4 = dlerror();
    LogError("buildPluginList", 843, "*** ERROR: failed to lookup 'CopyRawPluginsInfoArray' - '%s'\n", v4);
  }
  unsigned int v5 = (uint64_t (*)(char *, uint64_t *))dlsym(v2, "GetRawPluginsInfo");
  if (v5)
  {
    if (v5((char *)&v8 + 4, &v8)) {
      goto LABEL_19;
    }
  }
  else
  {
    uint64_t v6 = dlerror();
    LogError("buildPluginList", 857, "*** ERROR: failed to lookup 'GetRawPluginsInfo' - '%s'\n", v6);
  }
  LogError("buildPluginList", 862, "*** ERROR: failed to load 'RawCamera' plugins\n");
LABEL_19:
  gReadMakerNoteProps = dlsym(v2, "ReadMakerNoteProps");
  goto LABEL_21;
}

void sub_1885B87B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,char a28,uint64_t a29,uint64_t a30,uint64_t a31,void *a32)
{
}

IIO_Reader *IIO_ReaderHandler::readerForBytesImp(IIO_Reader ***this, uint64_t a2, unint64_t a3, __CFString *a4, unint64_t a5, unint64_t *a6, uint64_t a7, int *a8)
{
  if (a4)
  {
    uint64_t v15 = IIO_ReaderHandler::readerForUTType((IIO_ReaderHandler *)this, a4);
    float v16 = v15;
    if (v15)
    {
      if (a5 && IIO_Reader::minimumFileSize(v15) <= a5
        || (uint64_t v17 = IIO_Reader::minimumFileSize(v16), (a6[2] & 1) != 0)
        || !v17)
      {
        if (IIO_Reader::testHeaderSize(v16) <= a3)
        {
          unint64_t v32 = a6[2];
          long long v31 = *(_OWORD *)a6;
          if ((*(uint64_t (**)(IIO_Reader *, uint64_t, unint64_t, __CFString *, long long *))(*(void *)v16 + 16))(v16, a2, a3, a4, &v31))
          {
            int v18 = 0;
            if (a8) {
              goto LABEL_33;
            }
            return v16;
          }
        }
      }
    }
  }
  if ((~*((_DWORD *)a6 + 4) & 0xC) == 0)
  {
    IIOString::IIOString((IIOString *)v30, a4);
    double v19 = (const char *)IIOString::utf8String((IIOString *)v30);
    _cg_jpeg_mem_term("readerForBytesImp", 399, "*** ERROR: hint ('%s') does not match image data - kCGImageSourceFailForDataNotMatchingHint was specified --> failing\n", v19);
    IIOString::~IIOString((IIOString *)v30);
    float v16 = 0;
    int v18 = -57;
    if (a8) {
      goto LABEL_33;
    }
    return v16;
  }
  uint64_t v20 = this[2];
  CFStringRef v21 = this[3];
  while (1)
  {
    if (v20 == v21)
    {
      float v16 = 0;
      int v18 = -50;
      goto LABEL_30;
    }
    float v16 = *v20;
    if (!a5 || IIO_Reader::minimumFileSize(*v20) > a5)
    {
      uint64_t v22 = IIO_Reader::minimumFileSize(v16);
      if ((a6[2] & 1) == 0)
      {
        if (v22) {
          goto LABEL_28;
        }
      }
    }
    if (IIO_Reader::testHeaderSize(v16) > a3) {
      goto LABEL_28;
    }
    unint64_t v29 = a6[2];
    long long v28 = *(_OWORD *)a6;
    if (!(*(unsigned int (**)(IIO_Reader *, uint64_t, unint64_t, __CFString *, long long *))(*(void *)v16 + 16))(v16, a2, a3, a4, &v28))goto LABEL_28; {
    unint64_t v23 = *a6;
    }
    if (!*a6) {
      break;
    }
    int v24 = IIO_Reader::osType(v16);
    if (IIOFlagsSupportType(v23, v24)) {
      goto LABEL_35;
    }
    unint64_t v25 = a6[1];
    if (v25) {
      goto LABEL_27;
    }
LABEL_28:
    ++v20;
  }
  unint64_t v25 = a6[1];
  if (!v25) {
    goto LABEL_35;
  }
LABEL_27:
  int v26 = IIO_Reader::osType(v16);
  if ((IIOFlagsSupportType(v25, v26) & 1) == 0) {
    goto LABEL_28;
  }
LABEL_35:
  int v18 = 0;
LABEL_30:
  if (!v16) {
    int v18 = -63;
  }
  if (a8) {
LABEL_33:
  }
    *a8 = v18;
  return v16;
}

void sub_1885B8BCC(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14)
{
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  if (!v14) {
    JUMPOUT(0x1885B8BA0);
  }
  JUMPOUT(0x1885B8B9CLL);
}

uint64_t IIO_Reader::minimumFileSize(IIO_Reader *this)
{
  return *((void *)this + 5);
}

uint64_t IIO_Reader::testHeaderSize(IIO_Reader *this)
{
  return *((void *)this + 4);
}

uint64_t IIO_Reader_HEIF::testHeader(uint64_t a1, unsigned __int8 *a2, unint64_t a3, uint64_t a4, uint64_t a5)
{
  unsigned int v5 = *(__CFString ***)(a1 + 8);
  if (v5 == kCGImageTypeIdentifierJPEG)
  {
    int v15 = (*(_DWORD *)(a5 + 16) >> 4) & 3;
    if (v15) {
      int v16 = -1;
    }
    else {
      int v16 = 0;
    }
    if (v15 == 1) {
      int v17 = 1;
    }
    else {
      int v17 = v16;
    }
    if (v17)
    {
      if (v17 == 255
        && *a2 == 255
        && a2[1] == 216
        && a2[2] == 255
        && a2[3] == 224
        && !a2[4]
        && a2[5] == 20
        && a2[20] == 65
        && a2[21] == 77
        && a2[22] == 80
        && a2[23] == 70)
      {
        return 1;
      }
    }
    else if (*a2 == 255 && a2[1] == 216 && a2[2] == 255)
    {
      return 1;
    }
  }
  else
  {
    if (v5 != kCGImageTypeIdentifierJPEGXL)
    {
      uint64_t v25 = 0;
      memset(v24, 0, sizeof(v24));
      IIOScanner::IIOScanner((IIOScanner *)v24, a2, a3, 0);
      unsigned int Val32 = IIOScanner::getVal32((IIOScanner *)v24);
      int v9 = IIOScanner::getVal32((IIOScanner *)v24);
      if (Val32 >= a3) {
        unsigned int v10 = a3;
      }
      else {
        unsigned int v10 = Val32;
      }
      if (v9 != 1718909296)
      {
LABEL_78:
        IIOScanner::~IIOScanner((IIOScanner *)v24);
        return 0;
      }
      int v11 = IIOScanner::getVal32((IIOScanner *)v24);
      int v12 = v11;
      float v13 = *(__CFString ***)(a1 + 8);
      if (v13 == kCGImageTypeIdentifierAVCI)
      {
        int v14 = 1635148649;
        goto LABEL_53;
      }
      if (v13 == kCGImageTypeIdentifierHEIC)
      {
        if (v11 != 1751476579)
        {
          int v14 = 1751476600;
          goto LABEL_53;
        }
      }
      else if (v13 == kCGImageTypeIdentifierHEICS)
      {
        if (v11 != 1751476600)
        {
          int v14 = 1836279345;
          goto LABEL_53;
        }
      }
      else
      {
        if (v13 != kCGImageTypeIdentifierHEIF)
        {
          if (v13 == kCGImageTypeIdentifierAVIF)
          {
            int v14 = 1635150182;
          }
          else
          {
            if (v13 != kCGImageTypeIdentifierAVIS)
            {
LABEL_56:
              IIOScanner::getVal32((IIOScanner *)v24);
              if (v10 >= 0x11 && v10 - 16 >= 4)
              {
                unsigned int v20 = (v10 - 16) >> 2;
                while (1)
                {
                  int v21 = IIOScanner::getVal32((IIOScanner *)v24);
                  uint64_t v22 = *(__CFString ***)(a1 + 8);
                  if (v22 == kCGImageTypeIdentifierAVCI)
                  {
                    if (v21 == 1635148649) {
                      goto LABEL_54;
                    }
                  }
                  else if (v22 != kCGImageTypeIdentifierHEIC || v12 == 1836279345)
                  {
                    if (v22 == kCGImageTypeIdentifierHEICS)
                    {
                      if (v21 == 1751476600 || v21 == 1836279345) {
                        goto LABEL_54;
                      }
                    }
                    else if (v22 == kCGImageTypeIdentifierHEIF && (v21 == 1785750887 || v21 == 1835623985))
                    {
                      goto LABEL_54;
                    }
                  }
                  else if (v21 == 1751476579 || v21 == 1751476600)
                  {
                    goto LABEL_54;
                  }
                  if (!--v20) {
                    goto LABEL_78;
                  }
                }
              }
              goto LABEL_78;
            }
            int v14 = 1635150195;
          }
LABEL_53:
          if (v11 == v14) {
            goto LABEL_54;
          }
          goto LABEL_56;
        }
        if (v11 != 1785750887)
        {
          int v14 = 1835623985;
          goto LABEL_53;
        }
      }
LABEL_54:
      IIOScanner::~IIOScanner((IIOScanner *)v24);
      return 1;
    }
    if (a3 >= 0xC)
    {
      if (*(_WORD *)a2 == 2815) {
        return 1;
      }
      if (*(void *)a2 == 0x204C584A0C000000 && *((_DWORD *)a2 + 2) == 176622093) {
        return 1;
      }
    }
  }
  return 0;
}

void sub_1885B8FD0(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t IIOScanner::getVal32(IIOScanner *this)
{
  uint64_t v1 = *((void *)this + 3);
  if ((unint64_t)(v1 + 3) >= *((void *)this + 2))
  {
    LogError("getVal32", 216, "*** IIOScanner::getVal32 reached EOF\n");
    *((_DWORD *)this + 16) = -39;
    exception = __cxa_allocate_exception(4uLL);
    _DWORD *exception = -39;
    __cxa_throw(exception, MEMORY[0x1E4FBA3A8], 0);
  }
  LODWORD(v2) = *(_DWORD *)(*((void *)this + 1) + v1);
  unsigned int v3 = bswap32(v2);
  if (*((unsigned char *)this + 68)) {
    uint64_t v2 = v2;
  }
  else {
    uint64_t v2 = v3;
  }
  *((void *)this + 3) = v1 + 4;
  return v2;
}

void IIOScanner::~IIOScanner(IIOScanner *this)
{
  *(void *)this = &unk_1ED4DE450;
  if (*((void *)this + 1))
  {
    uint64_t v1 = (void *)*((void *)this + 6);
    if (v1)
    {
      uint64_t v2 = (IIOImageRead **)*((void *)this + 7);
      if (v2) {
        IIOImageReadSession::releaseBytePointer(v2, v1);
      }
    }
  }
}

{
  uint64_t vars8;

  IIOScanner::~IIOScanner(this);

  JUMPOUT(0x18C11C0E0);
}

void IIOScanner::IIOScanner(IIOScanner *this, unsigned __int8 *a2, uint64_t a3, char a4)
{
  *((void *)this + 6) = 0;
  *((void *)this + 7) = 0;
  *(void *)this = &unk_1ED4DE450;
  *((void *)this + 1) = a2;
  if ((a3 & 0x800000000) != 0 || a2 == 0) {
    uint64_t v5 = 0;
  }
  else {
    uint64_t v5 = a3;
  }
  *((void *)this + 2) = v5;
  *((void *)this + 3) = 0;
  *((void *)this + 5) = 0;
  *((unsigned char *)this + 68) = a4;
  *((_DWORD *)this + 16) = 0;
}

uint64_t IIO_Reader_AppleJPEG::testHeader(uint64_t a1, unsigned __int8 *a2, uint64_t a3, const __CFString *a4, uint64_t a5)
{
  if (*a2 == 255 && a2[1] == 216 && a2[2] == 255)
  {
    int v6 = (*(_DWORD *)(a5 + 16) >> 4) & 3;
    int v7 = v6 ? -1 : 0;
    int v8 = v6 == 1 ? 1 : v7;
    if (v8)
    {
      if (v8 != 255
        || a2[3] != 224
        || a2[4]
        || a2[5] != 20
        || a2[20] != 65
        || a2[21] != 77
        || a2[22] != 80
        || a2[23] != 70)
      {
        return 1;
      }
      if ((IIOFlagsSupportType(*(void *)a5, 1212500291) & 1) == 0
        && (*(unsigned char *)(a5 + 16) & 0x30) == 0
        && CFEqual(a4, @"public.jpeg"))
      {
        LogError("testHeader", 76, "*** JPEG with aux-image + 'fail-for-non-matching-hint are not compatible' - ignoring aux-image\n");
        return 1;
      }
    }
  }
  return 0;
}

BOOL IIO_Reader_PNG::testHeader(uint64_t a1, unsigned __int8 *a2)
{
  return *a2 == 137
      && a2[1] == 80
      && a2[2] == 78
      && a2[3] == 71
      && a2[4] == 13
      && a2[5] == 10
      && a2[6] == 26
      && a2[7] == 10;
}

BOOL IIO_Reader_ASTC::testHeader(IIO_ReaderHandler *a1, _DWORD *a2, unint64_t a3, uint64_t a4, long long *a5)
{
  int v6 = (__CFString **)*((void *)a1 + 1);
  if (v6 == kCGImageTypeIdentifierASTC) {
    return *a2 == 1554098963;
  }
  if (v6 != kCGImageTypeIdentifierKTX)
  {
    if (a3 < 0x51) {
      return 0;
    }
    if (v6 != kCGImageTypeIdentifierKTX2) {
      return 0;
    }
    ReaderHandler = (IIO_ReaderHandler *)IIO_ReaderHandler::GetReaderHandler(a1);
    int v11 = IIO_ReaderHandler::readerForType(ReaderHandler, 1263818802);
    long long v20 = *a5;
    uint64_t v21 = *((void *)a5 + 2);
    return (*(unsigned int (**)(IIO_Reader *, _DWORD *, unint64_t, uint64_t, long long *))(*(void *)v11 + 16))(v11, a2, a3, a4, &v20)&& IsASTC(a2[3]);
  }
  if (a3 < 0x41) {
    return 0;
  }
  float v13 = (IIO_ReaderHandler *)IIO_ReaderHandler::GetReaderHandler(a1);
  int v14 = IIO_ReaderHandler::readerForType(v13, 1263818784);
  if (!v14) {
    return 0;
  }
  uint64_t v23 = *((void *)a5 + 2);
  long long v22 = *a5;
  if (!(*(unsigned int (**)(IIO_Reader *, _DWORD *, unint64_t, uint64_t, long long *))(*(void *)v14 + 16))(v14, a2, a3, a4, &v22))return 0; {
  int v15 = a2[3];
  }
  unsigned int v16 = a2[4];
  unsigned int v17 = bswap32(v16);
  if (v15 != 67305985) {
    unsigned int v16 = v17;
  }
  if (v16) {
    return 0;
  }
  unsigned int v18 = bswap32(a2[7]);
  unsigned int v19 = v15 == 67305985 ? a2[7] : v18;
  BOOL result = 1;
  if (v19 >> 2 != 8855 && v19 - 37886 >= 0x10 && v19 - 37808 >= 0xE && v19 - 37840 >= 0xE) {
    return 0;
  }
  return result;
}

BOOL IsKTXHeader(const unsigned __int8 *a1)
{
  return *a1 == 171
      && a1[1] == 75
      && a1[2] == 84
      && a1[3] == 88
      && a1[4] == 32
      && a1[5] == 49
      && a1[6] == 49
      && a1[7] == 187
      && a1[8] == 13
      && a1[9] == 10
      && a1[10] == 26
      && a1[11] == 10;
}

BOOL IIO_Reader_KTX::testHeader(int a1, unsigned __int8 *a2)
{
  return IsKTXHeader(a2);
}

void IIOImageReadSession::releaseBytePointer(IIOImageRead **this, void *a2)
{
}

BOOL IIO_Reader_PVR::testHeader(IIO_ReaderHandler *a1, unsigned __int8 *a2, unint64_t a3, uint64_t a4, long long *a5)
{
  int v6 = (__CFString **)*((void *)a1 + 1);
  if (v6 == kCGImageTypeIdentifierPVR)
  {
    if (a2[44] == 80 && a2[45] == 86 && a2[46] == 82 && a2[47] == 33)
    {
      int v12 = *a2;
      if (v12 == 52) {
        return 1;
      }
    }
    else
    {
      int v12 = *a2;
    }
    return v12 == 80 && a2[1] == 86 && a2[2] == 82 && a2[3] == 3;
  }
  if (v6 == kCGImageTypeIdentifierKTX)
  {
    if (a3 < 0x40) {
      return 0;
    }
    ReaderHandler = (IIO_ReaderHandler *)IIO_ReaderHandler::GetReaderHandler(a1);
    int v14 = IIO_ReaderHandler::readerForType(ReaderHandler, 1263818784);
    if (!v14) {
      return 0;
    }
    uint64_t v25 = *((void *)a5 + 2);
    long long v24 = *a5;
    if (!(*(unsigned int (**)(IIO_Reader *, unsigned __int8 *, unint64_t, uint64_t, long long *))(*(void *)v14 + 16))(v14, a2, a3, a4, &v24))return 0; {
    int v15 = *((_DWORD *)a2 + 3);
    }
    unsigned int v16 = *((_DWORD *)a2 + 4);
    unsigned int v17 = bswap32(v16);
    unsigned int v18 = bswap32(*((_DWORD *)a2 + 7));
    BOOL v19 = v15 == 67305985;
    int v20 = v15 == 67305985 ? *((_DWORD *)a2 + 7) : v18;
    if (!v19) {
      unsigned int v16 = v17;
    }
    return !v16 && (v20 & 0xFFFFFFFC) == 0x8C00;
  }
  if (a3 >= 0x50 && v6 == kCGImageTypeIdentifierKTX2)
  {
    unsigned int v10 = (IIO_ReaderHandler *)IIO_ReaderHandler::GetReaderHandler(a1);
    int v11 = IIO_ReaderHandler::readerForType(v10, 1263818802);
    long long v22 = *a5;
    uint64_t v23 = *((void *)a5 + 2);
    if ((*(unsigned int (**)(IIO_Reader *, unsigned __int8 *, unint64_t, uint64_t, long long *))(*(void *)v11 + 16))(v11, a2, a3, a4, &v22))
    {
      if (IsPVRTC1(*((_DWORD *)a2 + 3))) {
        return 1;
      }
    }
  }
  return 0;
}

BOOL IIO_Reader_ETC::testHeader(IIO_Reader_ETC *a1, unsigned __int8 *a2, unint64_t a3, uint64_t a4, long long *a5)
{
  int v7 = (__CFString **)*((void *)a1 + 1);
  if (v7 == kCGImageTypeIdentifierBC)
  {
    if (a3 < 0x80 || !IIO_Reader_ETC::isInDDSContainer(a1, a2)) {
      return 0;
    }
    unsigned int v12 = bswap32(*((_DWORD *)a2 + 21));
    BOOL v13 = v12 - 1146639409 < 5 || v12 == 1146630448;
    return v13 || !v12 && (a2[80] & 0x40) != 0;
  }
  if (v7 == kCGImageTypeIdentifierKTX)
  {
    if (a3 < 0x40) {
      return 0;
    }
    ReaderHandler = (IIO_ReaderHandler *)IIO_ReaderHandler::GetReaderHandler(a1);
    unsigned int v16 = IIO_ReaderHandler::readerForType(ReaderHandler, 1263818784);
    if (!v16) {
      return 0;
    }
    uint64_t v24 = *((void *)a5 + 2);
    long long v23 = *a5;
    if (!(*(unsigned int (**)(IIO_Reader *, unsigned __int8 *, unint64_t, uint64_t, long long *))(*(void *)v16 + 16))(v16, a2, a3, a4, &v23))return 0; {
    unsigned int v17 = *((_DWORD *)a2 + 4);
    }
    unsigned int v18 = bswap32(v17);
    unsigned int v19 = bswap32(*((_DWORD *)a2 + 7));
    if (*((_DWORD *)a2 + 3) == 67305985)
    {
      unsigned int v20 = *((_DWORD *)a2 + 7);
    }
    else
    {
      unsigned int v17 = v18;
      unsigned int v20 = v19;
    }
    return !v17 && v20 - 37498 >= 0xFFFFFFF6;
  }
  if (a3 >= 0x50 && v7 == kCGImageTypeIdentifierKTX2)
  {
    unsigned int v10 = (IIO_ReaderHandler *)IIO_ReaderHandler::GetReaderHandler(a1);
    int v11 = IIO_ReaderHandler::readerForType(v10, 1263818802);
    long long v21 = *a5;
    uint64_t v22 = *((void *)a5 + 2);
    if ((*(unsigned int (**)(IIO_Reader *, unsigned __int8 *, unint64_t, uint64_t, long long *))(*(void *)v11 + 16))(v11, a2, a3, a4, &v21))
    {
      if (IsETC(*((_DWORD *)a2 + 3))) {
        return 1;
      }
    }
  }
  return 0;
}

BOOL IIO_Reader_BC::testHeader(IIO_Reader_ETC *a1, unsigned __int8 *a2, unint64_t a3, uint64_t a4, long long *a5)
{
  int v6 = (__CFString **)*((void *)a1 + 1);
  if (v6 == kCGImageTypeIdentifierBMP)
  {
    if (a2[1] > 1u) {
      return 0;
    }
    unsigned int v12 = a2[2];
    BOOL v13 = v12 > 0xB;
    int v14 = (1 << v12) & 0xE0E;
    BOOL v15 = v13 || v14 == 0;
    if (v15 || a2[7] > 0x20u || !a2[12] && !a2[13]) {
      return 0;
    }
    if (!a2[14] && !a2[15]) {
      return 0;
    }
    HIDWORD(v16) = a2[16];
    LODWORD(v16) = (HIDWORD(v16) << 24) - 0x8000000;
    return (v16 >> 27) <= 3u && a2[17] < 0x40u;
  }
  if (v6 == kCGImageTypeIdentifierBC)
  {
    if (a3 < 0x80 || !IIO_Reader_ETC::isInDDSContainer(a1, a2)) {
      return 0;
    }
    unsigned int v17 = bswap32(*((_DWORD *)a2 + 21));
    BOOL v18 = v17 - 1146639409 < 5 || v17 == 1146630448;
    return v18 || !v17 && (a2[80] & 0x40) != 0;
  }
  if (v6 != kCGImageTypeIdentifierKTX)
  {
    if (a3 < 0x50) {
      return 0;
    }
    if (v6 != kCGImageTypeIdentifierKTX2) {
      return 0;
    }
    ReaderHandler = (IIO_ReaderHandler *)IIO_ReaderHandler::GetReaderHandler(a1);
    int v11 = IIO_ReaderHandler::readerForType(ReaderHandler, 1263818802);
    long long v28 = *a5;
    uint64_t v29 = *((void *)a5 + 2);
    return (*(unsigned int (**)(IIO_Reader *, unsigned __int8 *, unint64_t, uint64_t, long long *))(*(void *)v11 + 16))(v11, a2, a3, a4, &v28)&& IsBCn(*((_DWORD *)a2 + 3));
  }
  if (a3 < 0x40) {
    return 0;
  }
  unsigned int v20 = (IIO_ReaderHandler *)IIO_ReaderHandler::GetReaderHandler(a1);
  long long v21 = IIO_ReaderHandler::readerForType(v20, 1263818784);
  if (!v21) {
    return 0;
  }
  uint64_t v31 = *((void *)a5 + 2);
  long long v30 = *a5;
  if (!(*(unsigned int (**)(IIO_Reader *, unsigned __int8 *, unint64_t, uint64_t, long long *))(*(void *)v21 + 16))(v21, a2, a3, a4, &v30))return 0; {
  int v22 = *((_DWORD *)a2 + 3);
  }
  unsigned int v23 = *((_DWORD *)a2 + 4);
  unsigned int v24 = bswap32(v23);
  if (v22 != 67305985) {
    unsigned int v23 = v24;
  }
  if (v23) {
    return 0;
  }
  unsigned int v25 = bswap32(*((_DWORD *)a2 + 7));
  if (v22 == 67305985) {
    unsigned int v26 = *((_DWORD *)a2 + 7);
  }
  else {
    unsigned int v26 = v25;
  }
  if (v26 - 36283 < 4) {
    return 1;
  }
  unsigned int v27 = v26 & 0xFFFFFFFC;
  BOOL result = 1;
  if (v27 != 33776 && v27 != 35916 && v27 != 36492) {
    return 0;
  }
  return result;
}

BOOL IIO_Reader_TIFF::testHeader(uint64_t a1, unsigned __int8 *a2)
{
  int v2 = *a2;
  if (v2 == 73) {
    return a2[1] == 73
  }
        && (a2[2] != 42 || a2[3] || a2[8] != 67 || a2[9] != 82 || a2[10] != 2 || a2[11])
        && (a2[2] & 0xFE) == 0x2A
        && !a2[3];
  return v2 == 77
      && a2[1] == 77
      && (a2[2] || a2[3] != 42 || a2[8] != 186 || a2[9] != 176 || a2[10] != 172 || a2[11] != 187)
      && !a2[2]
      && (a2[3] & 0xFE) == 0x2A;
}

BOOL IIO_Reader_JP2::testHeader(uint64_t a1, unsigned __int8 *a2)
{
  if (*a2 == 255)
  {
    if (a2[1] == 79 && a2[2] == 255)
    {
      int v2 = 81;
      uint64_t v3 = 3;
      return a2[v3] == v2;
    }
    return 0;
  }
  if (*a2
    || a2[1]
    || a2[2]
    || a2[3] != 12
    || a2[4] != 106
    || a2[5] != 80
    || a2[8] != 13
    || a2[9] != 10
    || a2[10] != 135)
  {
    return 0;
  }
  int v2 = 10;
  uint64_t v3 = 11;
  return a2[v3] == v2;
}

BOOL IIO_Reader_GIF::testHeader(uint64_t a1, unsigned char *a2)
{
  BOOL result = *a2 == 71
        && a2[1] == 73
        && a2[2] == 70
        && a2[3] == 56
        && ((int v2 = a2[4], v2 == 57) || v2 == 55)
        && a2[5] == 97;
  return result;
}

BOOL IIO_Reader_ATX::testHeader(uint64_t a1, unsigned char *a2)
{
  return *a2 == 65
      && a2[1] == 65
      && a2[2] == 80
      && a2[3] == 76
      && a2[4] == 13
      && a2[5] == 10
      && a2[6] == 26
      && a2[7] == 10;
}

uint64_t std::vector<std::unique_ptr<IIO_Reader>>::__swap_out_circular_buffer(uint64_t *a1, void *a2)
{
  uint64_t result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::unique_ptr<IIO_Reader>>,std::reverse_iterator<std::unique_ptr<IIO_Reader>*>,std::reverse_iterator<std::unique_ptr<IIO_Reader>*>,std::reverse_iterator<std::unique_ptr<IIO_Reader>*>>((uint64_t)(a1 + 2), a1[1], (void *)a1[1], *a1, (void *)*a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::unique_ptr<IIO_Reader>>,std::reverse_iterator<std::unique_ptr<IIO_Reader>*>,std::reverse_iterator<std::unique_ptr<IIO_Reader>*>,std::reverse_iterator<std::unique_ptr<IIO_Reader>*>>(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, void *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&long long v16 = a6;
  *((void *)&v16 + 1) = a7;
  long long v15 = v16;
  v13[0] = a1;
  v13[1] = &v15;
  v13[2] = &v16;
  uint64_t v14 = 0;
  if (a3 == a5)
  {
    uint64_t v11 = a6;
  }
  else
  {
    uint64_t v8 = (void *)(a7 - 8);
    int v9 = (void *)(a7 - 8);
    do
    {
      uint64_t v10 = *--a3;
      *a3 = 0;
      *v9-- = v10;
      *((void *)&v16 + 1) = v8;
      v7 -= 8;
      uint64_t v8 = v9;
    }
    while (a3 != a5);
    uint64_t v11 = v16;
  }
  LOBYTE(v14) = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::unique_ptr<IIO_Reader>>,std::reverse_iterator<std::unique_ptr<IIO_Reader>*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v13);
  return v11;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::unique_ptr<IIO_Reader>>,std::reverse_iterator<std::unique_ptr<IIO_Reader>*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    std::_AllocatorDestroyRangeReverse<std::allocator<std::unique_ptr<IIO_Reader>>,std::reverse_iterator<std::unique_ptr<IIO_Reader>*>>::operator()[abi:ne180100]((void *)a1);
  }
  return a1;
}

void **std::__split_buffer<std::unique_ptr<IIO_Reader>>::~__split_buffer(void **a1)
{
  if (*a1) {
    operator delete(*a1);
  }
  return a1;
}

void *std::__split_buffer<std::unique_ptr<IIO_Reader>>::__destruct_at_end[abi:ne180100](void *result, uint64_t a2)
{
  uint64_t v2 = result[2];
  if (v2 != a2)
  {
    uint64_t v4 = result;
    do
    {
      BOOL v4[2] = v2 - 8;
      uint64_t result = *(void **)(v2 - 8);
      *(void *)(v2 - 8) = 0;
      if (result) {
        uint64_t result = (void *)(*(uint64_t (**)(void *))(*result + 8))(result);
      }
      uint64_t v2 = v4[2];
    }
    while (v2 != a2);
  }
  return result;
}

BOOL IIO_Reader_KTX2::testHeader(int a1, unsigned __int8 *a2)
{
  return IsKTX2Header(a2);
}

BOOL IsKTX2Header(const unsigned __int8 *a1)
{
  return *a1 == 171
      && a1[1] == 75
      && a1[2] == 84
      && a1[3] == 88
      && a1[4] == 32
      && a1[5] == 50
      && a1[6] == 48
      && a1[7] == 187
      && a1[8] == 13
      && a1[9] == 10
      && a1[10] == 26
      && a1[11] == 10;
}

uint64_t IIOReader_RawCamera::testHeader(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  uint64_t v4 = *(uint64_t (**)(uint64_t, unint64_t, uint64_t))(a1 + 72);
  if (v4 && *(void *)(a1 + 32) <= a3) {
    return v4(a2, a3, a4);
  }
  else {
    return 0;
  }
}

uint64_t IIO_ReaderHandler::copySupportedTypes(IIO_ReaderHandler *this)
{
  if ((IIO_XPCServer() & 1) == 0)
  {
    uint64_t v1 = SecTaskCreateFromSelf((CFAllocatorRef)*MEMORY[0x1E4F1CF80]);
    if (v1)
    {
      uint64_t v2 = v1;
      CFTypeRef v3 = SecTaskCopyValueForEntitlement(v1, @"com.apple.imageio.allowabletypes", 0);
      if (v3)
      {
        uint64_t v4 = v3;
        CFTypeID v5 = CFGetTypeID(v3);
        if (v5 == CFArrayGetTypeID()) {
          operator new();
        }
        CFRelease(v4);
      }
      CFRelease(v2);
    }
  }
  return 0;
}

void sub_1885BA278(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  IIOArray::~IIOArray((IIOArray *)va);
  _Unwind_Resume(a1);
}

void CreateReader_KTX2_ASTC(void)
{
}

void sub_1885BA334(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10D1C405DC8C238);
  _Unwind_Resume(a1);
}

void CreateReader_AppleJPEG(void)
{
}

void sub_1885BA3D4(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10D1C405DC8C238);
  _Unwind_Resume(a1);
}

void CreateReader_KTX_ASTC(void)
{
}

void sub_1885BA480(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10D1C405DC8C238);
  _Unwind_Resume(a1);
}

void CreateReader_KTX2_PVR(void)
{
}

void sub_1885BA52C(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10D1C405DC8C238);
  _Unwind_Resume(a1);
}

void CreateReader_KTX2_ETC(void)
{
}

void sub_1885BA5D8(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10D1C405DC8C238);
  _Unwind_Resume(a1);
}

void CreateReader_LibJPEG(void)
{
}

void sub_1885BA684(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10D1C405DC8C238);
  _Unwind_Resume(a1);
}

void CreateReader_KTX_PVR(void)
{
}

void sub_1885BA730(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10D1C405DC8C238);
  _Unwind_Resume(a1);
}

void CreateReader_KTX_ETC(void)
{
}

void sub_1885BA7DC(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10D1C405DC8C238);
  _Unwind_Resume(a1);
}

void CreateReader_KTX_BC(void)
{
}

void sub_1885BA888(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10D1C405DC8C238);
  _Unwind_Resume(a1);
}

uint64_t CreateReader_JPEGXL(void)
{
  if (gHEIF_JPEGXL_DecodingSupported) {
    operator new();
  }
  return 0;
}

void sub_1885BA95C(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10D1C405DC8C238);
  _Unwind_Resume(a1);
}

void CreateReader_DDS_BC(void)
{
}

void sub_1885BA9FC(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10D1C405DC8C238);
  _Unwind_Resume(a1);
}

uint64_t CreateReader_HEICS(void)
{
  if (gHEIF_HEVC_DecodingSupported) {
    operator new();
  }
  return 0;
}

void sub_1885BAAD0(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10D1C405DC8C238);
  _Unwind_Resume(a1);
}

void CreateReader_WebP(void)
{
}

void sub_1885BAB70(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10D1C408A822D94);
  _Unwind_Resume(a1);
}

void CreateReader_TIFF(void)
{
}

void sub_1885BAC10(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10D1C405DC8C238);
  _Unwind_Resume(a1);
}

void CreateReader_ICNS(void)
{
}

void sub_1885BACB0(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10D1C405DC8C238);
  _Unwind_Resume(a1);
}

uint64_t CreateReader_HEIC(void)
{
  if (gHEIF_HEVC_DecodingSupported) {
    operator new();
  }
  return 0;
}

void sub_1885BAD84(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10D1C405DC8C238);
  _Unwind_Resume(a1);
}

void CreateReader_ASTC(void)
{
}

void sub_1885BAE24(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10D1C405DC8C238);
  _Unwind_Resume(a1);
}

void CreateReader_TGA(void)
{
}

void sub_1885BAEC4(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10D1C405DC8C238);
  _Unwind_Resume(a1);
}

void CreateReader_RAD(void)
{
}

void sub_1885BAF64(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10D1C405DC8C238);
  _Unwind_Resume(a1);
}

void CreateReader_PVR(void)
{
}

void sub_1885BB004(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10D1C405DC8C238);
  _Unwind_Resume(a1);
}

void CreateReader_PSD(void)
{
}

void sub_1885BB0A4(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10D1C405DC8C238);
  _Unwind_Resume(a1);
}

void CreateReader_PNG(void)
{
}

void sub_1885BB144(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10D1C405DC8C238);
  _Unwind_Resume(a1);
}

void CreateReader_PBM(void)
{
}

void sub_1885BB1E4(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10D1C405DC8C238);
  _Unwind_Resume(a1);
}

void CreateReader_MPO(void)
{
}

void sub_1885BB284(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10D1C405DC8C238);
  _Unwind_Resume(a1);
}

void CreateReader_KTX(void)
{
}

void sub_1885BB324(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10D1C405DC8C238);
  _Unwind_Resume(a1);
}

void CreateReader_JP2(void)
{
}

void sub_1885BB3C4(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10D1C405DC8C238);
  _Unwind_Resume(a1);
}

void CreateReader_ICO(void)
{
}

void sub_1885BB464(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10D1C405DC8C238);
  _Unwind_Resume(a1);
}

void CreateReader_GIF(void)
{
}

void sub_1885BB504(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10D1C405DC8C238);
  _Unwind_Resume(a1);
}

void CreateReader_EXR(void)
{
}

void sub_1885BB5A4(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10D1C405DC8C238);
  _Unwind_Resume(a1);
}

void CreateReader_CUR(void)
{
}

void sub_1885BB644(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10D1C405DC8C238);
  _Unwind_Resume(a1);
}

void CreateReader_BMP(void)
{
}

void sub_1885BB6E4(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10D1C405DC8C238);
  _Unwind_Resume(a1);
}

void CreateReader_ATX(void)
{
}

void sub_1885BB784(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10D1C405DC8C238);
  _Unwind_Resume(a1);
}

_OWORD *imageio_key_retain(long long *a1, void **a2, void *a3)
{
  uint64_t result = malloc_type_calloc(0x2CuLL, 1uLL, 0x851384CFuLL);
  if (result)
  {
    long long v6 = *a1;
    long long v7 = a1[1];
    *(_OWORD *)((char *)result + 28) = *(long long *)((char *)a1 + 28);
    _OWORD *result = v6;
    result[1] = v7;
  }
  *a2 = result;
  return result;
}

void IIOScanner::IIOScanner(IIOScanner *this, IIOImageReadSession *a2)
{
  *(void *)this = &unk_1ED4DE450;
  *((void *)this + 6) = 0;
  *((void *)this + 7) = a2;
  if (a2)
  {
    *((void *)this + 1) = IIOImageReadSession::retainBytePointer(a2, (const __CFData **)this + 6, 1);
    int Size = IIOImageReadSession::getSize(*((IIOImageReadSession **)this + 7));
  }
  else
  {
    int Size = 0;
    *((void *)this + 1) = 0;
  }
  *((void *)this + 2) = Size;
  *((void *)this + 3) = 0;
  *((void *)this + 5) = 0;
  *((unsigned char *)this + 68) = 1;
  *((_DWORD *)this + 16) = 0;
}

IIOImageRead *IIOImageReadSession::retainBytePointer(IIOImageReadSession *this, const __CFData **a2, int a3)
{
  uint64_t result = (IIOImageRead *)*((void *)this + 4);
  if (result) {
    return (IIOImageRead *)IIOImageRead::retainBytePointer(result, a2, a3);
  }
  return result;
}

AppleJPEGReadPlugin *AppleJPEGReadPlugin::appleJPEGDecodeOpen(AppleJPEGReadPlugin *this)
{
  int Size = (IIOImageRead *)*((void *)this + 58);
  if (!Size) {
    int Size = IIOImageReadSession::getSize(*((IIOImageReadSession **)this + 3));
  }
  *((void *)this + 73) = Size;
  *((void *)this + 67) = iioReadCallback;
  *((void *)this + 70) = iioRewindCallback;
  *((void *)this + 69) = iioSkipCallback;
  *((void *)this + 71) = (char *)this + 648;
  CFTypeRef v3 = (AppleJPEGReadPlugin *)applejpeg_decode_open_file();
  uint64_t v4 = v3;
  if (v3)
  {
    CFTypeID v5 = AppleJPEGReadPlugin::appleJPEGErrorString(v3, (int)v3);
    _cg_jpeg_mem_term("appleJPEGDecodeOpen", 1317, "*** ERROR: applejpeg_decode_open_file returned: %d '%s'\n", v4, v5);
  }
  return v4;
}

IIOImageRead *IIOImageReadSession::getSize(IIOImageReadSession *this)
{
  uint64_t result = (IIOImageRead *)*((void *)this + 4);
  if (result) {
    return (IIOImageRead *)IIOImageRead::getSize(result);
  }
  return result;
}

uint64_t IIOReadPlugin::callDecodeImage(uint64_t a1, uint64_t a2, uint64_t a3, IOSurfaceRef *a4, uint64_t a5, uint64_t *a6)
{
  int v10 = *(_DWORD *)(a1 + 204);
  ReaderHandler = (IIO_ReaderHandler *)IIO_ReaderHandler::GetReaderHandler((IIO_ReaderHandler *)a1);
  unsigned int v12 = IIO_ReaderHandler::readerForType(ReaderHandler, v10);
  BOOL v13 = *(IIO_Reader **)(a1 + 16);
  if (v13) {
    uint64_t Options = (IIODictionary *)IIOImagePlus::getOptions(*(IIOImagePlus **)(a1 + 16));
  }
  else {
    uint64_t Options = 0;
  }
  long long v15 = (IIOXPCClient *)IIOImageRead::forceUseServer(*(IIOImageRead **)(a1 + 32));
  int v16 = (int)v15;
  uint64_t IIOXPCClient = IIOXPCClient::GetIIOXPCClient(v15);
  unsigned int v146 = (IIO_Reader *)IIO_Reader::testHeaderSize(v13);
  BOOL v18 = (IIOImageRead *)IIO_Reader::testHeaderSize(v146);
  int v142 = (IIOXPCClient *)IIOXPCClient;
  int v19 = IIOXPCClient::useServerForDecodeImage(IIOXPCClient, v18, (uint64_t)v12, v16);
  if (!v12)
  {
    unsigned int v36 = v10 >> 24;
    if (v10 < 0) {
      int v37 = __maskrune(v10 >> 24, 0x40000uLL);
    }
    else {
      int v37 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v36 + 60) & 0x40000;
    }
    if (v37) {
      uint64_t v40 = v36;
    }
    else {
      uint64_t v40 = 46;
    }
    unsigned int v41 = v10 << 8 >> 24;
    if (v10 << 8 < 0) {
      int v42 = __maskrune(v10 << 8 >> 24, 0x40000uLL);
    }
    else {
      int v42 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v41 + 60) & 0x40000;
    }
    if (v42) {
      uint64_t v43 = v41;
    }
    else {
      uint64_t v43 = 46;
    }
    unsigned int v44 = (__int16)v10 >> 8;
    if (v10 << 16 < 0) {
      int v45 = __maskrune((__int16)v10 >> 8, 0x40000uLL);
    }
    else {
      int v45 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v44 + 60) & 0x40000;
    }
    if (v45) {
      uint64_t v46 = v44;
    }
    else {
      uint64_t v46 = 46;
    }
    if ((v10 << 24) <= 0x7F000000) {
      int v47 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * (char)v10 + 60) & 0x40000;
    }
    else {
      int v47 = __maskrune((char)v10, 0x40000uLL);
    }
    if (v47) {
      uint64_t v48 = (char)v10;
    }
    else {
      uint64_t v48 = 46;
    }
    _cg_jpeg_mem_term("callDecodeImage", 2172, "*** ERROR: could not find a reader for '%c%c%c%c'\n", v40, v43, v46, v48);
    return 4294967246;
  }
  int v20 = v19;
  unsigned int v141 = a4;
  long long v21 = *(const __CFString ***)(a1 + 72);
  if (v21)
  {
    CFStringRef v22 = *v21;
    if (*v21)
    {
      CFStringRef v23 = (const __CFString *)IIO_Reader::utType(v12);
      if (CFStringCompare(v22, v23, 0))
      {
        unsigned int v24 = *(const void ***)(a1 + 72);
        if (v24) {
          unsigned int v25 = *v24;
        }
        else {
          unsigned int v25 = 0;
        }
        uint64_t v64 = IIOString::IIOString((IIOString *)v150, v25);
        unsigned int v65 = (const char *)IIOString::utf8String(v64);
        int v66 = (const void *)IIO_Reader::utType(v12);
        uint64_t v67 = IIOString::IIOString((IIOString *)v149, v66);
        int v68 = (const char *)IIOString::utf8String(v67);
        _cg_jpeg_mem_term("callDecodeImage", 2177, "*** ERROR: pluginUTI '%s' does not match reader '%s'\n", v65, v68);
        IIOString::~IIOString((IIOString *)v149);
        IIOString::~IIOString((IIOString *)v150);
        return 4294967246;
      }
    }
  }
  if (v20)
  {
    kdebug_trace();
    IIOImagePlus::getProperties(v13);
    v149[0] = 0;
    xpc_object_t v26 = xpc_dictionary_create(0, 0, 0);
    if (v26)
    {
      unsigned int v27 = v26;
      iio_xpc_add_message_dict(v26);
      xpc_object_t v28 = iio_xpc_add_source_dict(v27);
      xpc_object_t v29 = iio_xpc_add_plugin_dict(v27);
      xpc_object_t xdict = iio_xpc_add_callback_dict(v27);
      xpc_object_t object = v27;
      xpc_dictionary_set_uint64(v27, "iio_xpc_message_id", 6uLL);
      memset(v150, 0, 24);
      long long v30 = (const void *)IIO_Reader::utType(v12);
      uint64_t v31 = IIOString::IIOString((IIOString *)v150, v30);
      unint64_t v32 = (const char *)IIOString::utf8String(v31);
      xpc_dictionary_set_string(v28, "iio_xpc_src_utitype", v32);
      xpc_dictionary_set_uint64(v28, "iio_xpc_src_ostype", *(unsigned int *)(a1 + 204));
      if (v146) {
        IIOImageReadSession::addDataToXPCDictionary(v146, v27, v149);
      }
      iio_xpc_dictionary_add_CFDictionary(v28, "iio_xpc_src_options");
      if (IIODictionary::containsKey(Options, @"kCGImageSourceDecodeRequest")) {
        iio_xpc_dictionary_add_CFDictionary(v28, "iio_xpc_src_properties");
      }
      IIODecodeParameter::saveDataToXPCObject((IIODecodeParameter *)a2, v27);
      xpc_dictionary_set_uint64(v28, "iio_xpc_src_image_type", a3);
      CFDataRef v33 = (const __CFData *)(*(uint64_t (**)(IIO_Reader *, IIO_Reader *))(*(void *)v12 + 104))(v12, v146);
      if (v33)
      {
        iio_xpc_dictionary_add_GlobalInfo(v29, v33, *(_DWORD *)(a1 + 204));
        CFRelease(v33);
      }
      (*(void (**)(uint64_t, xpc_object_t))(*(void *)a1 + 112))(a1, v29);
      char v34 = 0;
      if (a3 == 1 && v141)
      {
        if (*v141 && (xpc_object_t XPCObject = IOSurfaceCreateXPCObject(*v141)) != 0)
        {
          xpc_dictionary_set_value(xdict, "iio_xpc_cb_decode_iosurface", XPCObject);
          xpc_release(XPCObject);
          char v34 = 1;
        }
        else
        {
          char v34 = 0;
        }
      }
      unsigned int v69 = (_xpc_connection_s *)IIOXPCClient::xpc_connection(v142);
      int v70 = (dispatch_queue_s *)IIOXPCClient::xpc_queue(v142);
      xpc_object_t v71 = IIOXPCClient::send_message_with_reply(v142, v69, v70, object);
      unsigned int v72 = v71;
      if (v71)
      {
        xpc_object_t xdicta = iio_xpc_get_plugin_dict(v71);
        xpc_object_t message_dict = iio_xpc_get_message_dict(v72);
        xpc_object_t callback_dict = iio_xpc_get_callback_dict(v72);
        uint64_t error_code = iio_xpc_dictionary_get_error_code(message_dict);
        uint64_t v38 = error_code;
        if (error_code)
        {
          unsigned int v75 = v10 >> 24;
          if (error_code == -56)
          {
            if (v10 < 0) {
              __maskrune(v10 >> 24, 0x40000uLL);
            }
            if (v10 << 8 < 0) {
              __maskrune(v10 << 8 >> 24, 0x40000uLL);
            }
            if (v10 << 16 < 0) {
              __maskrune((__int16)v10 >> 8, 0x40000uLL);
            }
            if ((v10 << 24) > 0x7F000000) {
              __maskrune((char)v10, 0x40000uLL);
            }
            IIOXPCLog(" ImageIOXPC [%c%c%c%c]: XPC_READPLUGIN_DECODE_IMAGE: error: -56 (iio_methodNotImplemented)\n");
          }
          else if (error_code == -1400)
          {
            if (v10 < 0) {
              __maskrune(v10 >> 24, 0x40000uLL);
            }
            if (v10 << 8 < 0) {
              __maskrune(v10 << 8 >> 24, 0x40000uLL);
            }
            if (v10 << 16 < 0) {
              __maskrune((__int16)v10 >> 8, 0x40000uLL);
            }
            if ((v10 << 24) > 0x7F000000) {
              __maskrune((char)v10, 0x40000uLL);
            }
            IIOXPCLog(" ImageIOXPC [%c%c%c%c]: XPC_READPLUGIN_DECODE_IMAGE XPC connection interrupted\n");
          }
          else
          {
            if (v10 < 0) {
              int v83 = __maskrune(v10 >> 24, 0x40000uLL);
            }
            else {
              int v83 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v75 + 60) & 0x40000;
            }
            if (v83) {
              uint64_t v87 = v75;
            }
            else {
              uint64_t v87 = 46;
            }
            unsigned int v88 = v10 << 8 >> 24;
            if (v10 << 8 < 0) {
              int v89 = __maskrune(v10 << 8 >> 24, 0x40000uLL);
            }
            else {
              int v89 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v88 + 60) & 0x40000;
            }
            if (v89) {
              uint64_t v91 = v88;
            }
            else {
              uint64_t v91 = 46;
            }
            unsigned int v92 = (__int16)v10 >> 8;
            if (v10 << 16 < 0) {
              int v93 = __maskrune((__int16)v10 >> 8, 0x40000uLL);
            }
            else {
              int v93 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v92 + 60) & 0x40000;
            }
            if ((v10 << 24) <= 0x7F000000) {
              int v98 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * (char)v10 + 60) & 0x40000;
            }
            else {
              int v98 = __maskrune((char)v10, 0x40000uLL);
            }
            if (v93) {
              uint64_t v99 = v92;
            }
            else {
              uint64_t v99 = 46;
            }
            if (v98) {
              uint64_t v100 = (char)v10;
            }
            else {
              uint64_t v100 = 46;
            }
            IIOXPCLog(" ImageIOXPC [%c%c%c%c]: XPC_READPLUGIN_DECODE_IMAGE error: %d\n", v87, v91, v99, v100, v38);
          }
        }
        else
        {
          unsigned int v81 = v10 >> 24;
          if (v10 < 0) {
            int v82 = __maskrune(v10 >> 24, 0x40000uLL);
          }
          else {
            int v82 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v81 + 60) & 0x40000;
          }
          if (v82) {
            uint64_t v84 = v81;
          }
          else {
            uint64_t v84 = 46;
          }
          uint64_t v133 = v84;
          LODWORD(v85) = v10 << 8 >> 24;
          if (v10 << 8 < 0) {
            int v86 = __maskrune(v10 << 8 >> 24, 0x40000uLL);
          }
          else {
            int v86 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v85 + 60) & 0x40000;
          }
          if (v86) {
            uint64_t v85 = v85;
          }
          else {
            uint64_t v85 = 46;
          }
          unsigned int v90 = (__int16)v10 >> 8;
          if (v10 << 16 < 0) {
            int v132 = __maskrune((__int16)v10 >> 8, 0x40000uLL);
          }
          else {
            int v132 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v90 + 60) & 0x40000;
          }
          if ((v10 << 24) <= 0x7F000000) {
            int v95 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * (char)v10 + 60) & 0x40000;
          }
          else {
            int v95 = __maskrune((char)v10, 0x40000uLL);
          }
          if (v132) {
            uint64_t v96 = v90;
          }
          else {
            uint64_t v96 = 46;
          }
          if (v95) {
            uint64_t v97 = (char)v10;
          }
          else {
            uint64_t v97 = 46;
          }
          IIOXPCLog(" ImageIOXPC [%c%c%c%c]: XPC_READPLUGIN_DECODE_IMAGE: OK\n", v133, v85, v96, v97);
          if (a3 == 1)
          {
            if (callback_dict) {
              char v101 = v34;
            }
            else {
              char v101 = 1;
            }
            if ((v101 & 1) == 0)
            {
              xpc_object_t value = xpc_dictionary_get_value(callback_dict, "iio_xpc_cb_decode_iosurface");
              if (v141) {
                *unsigned int v141 = IOSurfaceLookupFromXPCObject(value);
              }
            }
          }
          else if (a3 == 3)
          {
            *a6 = (uint64_t)IIOReadPlugin::createImageBlockSetFromXPCObject(a1, v72, *(const void **)(a2 + 8), *(void *)(a2 + 16));
          }
          uint64_t v148 = 0;
          xpc_object_t GlobalInfo = iio_xpc_dictionary_get_GlobalInfo(xdicta, &v148);
          if (v148) {
            (*(void (**)(IIO_Reader *, IIO_Reader *, xpc_object_t))(*(void *)v12 + 96))(v12, v146, GlobalInfo);
          }
        }
        _cg_jpeg_mem_term(v142, v72, v94);
        xpc_release(v72);
      }
      else
      {
        IIOXPCLog(" ImageIOXPC: XPC_READPLUGIN_DECODE_IMAGE error null-reply\n");
        uint64_t v38 = 4294967246;
      }
      xpc_release(object);
      IIOString::~IIOString((IIOString *)v150);
      if (v146 && v149[0]) {
        IIOImageReadSession::releaseBytePointer((IIOImageRead **)v146, v149[0]);
      }
    }
    else
    {
      uint64_t v38 = 4294967246;
    }
    kdebug_trace();
    if (!v38) {
      goto LABEL_168;
    }
  }
  else
  {
    if (v16 == 1) {
      IIOXPCLog(" ImageIOXPC: OOP-request was made, but we're decoding in-process (XPC_READPLUGIN_DECODEIMAGE)...\n");
    }
    uint64_t v38 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, IOSurfaceRef *, uint64_t, uint64_t *))(*(void *)a1 + 216))(a1, a2, a3, v141, a5, a6);
    if (!v38)
    {
      if (a3 == 1)
      {
        OSType PixelFormat = IOSurfaceGetPixelFormat(*v141);
        if ((gIIODebugFlags & 0x30000) != 0)
        {
          int v77 = PixelFormat;
          unsigned int v78 = v10 >> 24;
          uint64_t v79 = MEMORY[0x1E4F14390];
          if (v10 < 0) {
            int v80 = __maskrune(v10 >> 24, 0x40000uLL);
          }
          else {
            int v80 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v78 + 60) & 0x40000;
          }
          if (v80) {
            uint64_t v109 = v78;
          }
          else {
            uint64_t v109 = 46;
          }
          uint64_t v147 = (IIOImageReadSession *)v109;
          unsigned int v110 = v10 << 8 >> 24;
          if (v10 << 8 < 0) {
            int v111 = __maskrune(v10 << 8 >> 24, 0x40000uLL);
          }
          else {
            int v111 = *(_DWORD *)(v79 + 4 * v110 + 60) & 0x40000;
          }
          if (v111) {
            uint64_t v112 = v110;
          }
          else {
            uint64_t v112 = 46;
          }
          int v143 = (IIOXPCClient *)v112;
          unsigned int v113 = (__int16)v10 >> 8;
          if (v10 << 16 < 0) {
            int v114 = __maskrune((__int16)v10 >> 8, 0x40000uLL);
          }
          else {
            int v114 = *(_DWORD *)(v79 + 4 * v113 + 60) & 0x40000;
          }
          if (v114) {
            uint64_t v115 = v113;
          }
          else {
            uint64_t v115 = 46;
          }
          xpc_object_t objecta = (xpc_object_t)v115;
          if ((v10 << 24) <= 0x7F000000) {
            int v116 = *(_DWORD *)(v79 + 4 * (char)v10 + 60) & 0x40000;
          }
          else {
            int v116 = __maskrune((char)v10, 0x40000uLL);
          }
          if (v116) {
            uint64_t v117 = (char)v10;
          }
          else {
            uint64_t v117 = 46;
          }
          xpc_object_t xdictb = (xpc_object_t)v117;
          IOSurfaceRef v118 = *v141;
          xpc_object_t Width = (xpc_object_t)IOSurfaceGetWidth(*v141);
          size_t Height = IOSurfaceGetHeight(*v141);
          unsigned int v120 = v77 >> 24;
          if (v77 < 0) {
            int v121 = __maskrune(v77 >> 24, 0x40000uLL);
          }
          else {
            int v121 = *(_DWORD *)(v79 + 4 * v120 + 60) & 0x40000;
          }
          if (v121) {
            uint64_t v122 = v120;
          }
          else {
            uint64_t v122 = 46;
          }
          unsigned int v123 = v77 << 8 >> 24;
          uint64_t v124 = v79;
          if (v77 << 8 < 0) {
            int v125 = __maskrune(v77 << 8 >> 24, 0x40000uLL);
          }
          else {
            int v125 = *(_DWORD *)(v79 + 4 * v123 + 60) & 0x40000;
          }
          if (v125) {
            uint64_t v126 = v123;
          }
          else {
            uint64_t v126 = 46;
          }
          unsigned int v127 = (__int16)v77 >> 8;
          if (v77 << 16 < 0) {
            int v128 = __maskrune((__int16)v77 >> 8, 0x40000uLL);
          }
          else {
            int v128 = *(_DWORD *)(v124 + 4 * v127 + 60) & 0x40000;
          }
          if (v128) {
            uint64_t v129 = v127;
          }
          else {
            uint64_t v129 = 46;
          }
          if ((v77 << 24) <= 0x7F000000) {
            int v130 = *(_DWORD *)(v124 + 4 * (char)v77 + 60) & 0x40000;
          }
          else {
            int v130 = __maskrune((char)v77, 0x40000uLL);
          }
          if (v130) {
            uint64_t v131 = (char)v77;
          }
          else {
            uint64_t v131 = 46;
          }
          ImageIOLog("  '%c%c%c%c' - decoded IOSurface: <IOSurface: %p> %ldx%ld  '%c%c%c%c'\n", v147, v143, objecta, xdictb, v118, Width, Height, v122, v126, v129, v131);
        }
      }
      else if (a3 == 3 && !*a6)
      {
        uint64_t v49 = *(void *)(a1 + 96);
        if (v49)
        {
          if (*(_DWORD *)(a1 + 104))
          {
            unint64_t v50 = 0;
            double v51 = 0.0;
            double v52 = 0.0;
            double y = 0.0;
            double x = 0.0;
            do
            {
              CGImageBlockGetRect();
              double v59 = v55;
              double v60 = v56;
              double v61 = v57;
              double v62 = v58;
              if (v50)
              {
                v151.origin.double x = x;
                v151.origin.double y = y;
                v151.size.width = v52;
                v151.size.unsigned int height = v51;
                CGRect v152 = CGRectUnion(v151, *(CGRect *)&v59);
                double x = v152.origin.x;
                double y = v152.origin.y;
                double v52 = v152.size.width;
                double v51 = v152.size.height;
              }
              else
              {
                double v51 = v58;
                double v52 = v57;
                double y = v56;
                double x = v55;
              }
              ++v50;
              unint64_t v63 = *(unsigned int *)(a1 + 104);
            }
            while (v50 < v63);
            uint64_t v49 = *(void *)(a1 + 96);
          }
          else
          {
            unint64_t v63 = 0;
            double x = 0.0;
            double y = 0.0;
            double v52 = 0.0;
            double v51 = 0.0;
          }
          *a6 = IIOReadPlugin::imageBlockSetCreate(a1, *(void *)(a2 + 16), v63, v52, v51, x, y, v52, v51, v49, *(const void **)(a2 + 8));
        }
        else
        {
          LogError("callDecodeImage", 2352, "*** ERROR: decodeImageImp failed - NULL _blockArray\n");
        }
      }
    }
    unsigned int v39 = *(void **)(a1 + 96);
    if (v39) {
      free(v39);
    }
    *(void *)(a1 + 96) = 0;
    *(_DWORD *)(a1 + 104) = 0;
    if (!v38)
    {
LABEL_168:
      if (!*(unsigned char *)(a1 + 353) || ((*(uint64_t (**)(uint64_t))(*(void *)a1 + 24))(a1) & 1) != 0) {
        return 0;
      }
      CGImageProviderSetContentHeadroom();
      BOOL v104 = CGColorSpaceUsesExtendedRange(*(CGColorSpaceRef *)(a1 + 160));
      BOOL IsHDR = CGColorSpaceIsHDR(*(CGColorSpaceRef *)(a1 + 160));
      if (v104 && *(unsigned char *)(a1 + 345))
      {
        char v106 = a6;
      }
      else
      {
        char v106 = a6;
        if (!IsHDR) {
          return 0;
        }
      }
      uint64_t v107 = *v106;
      if (*v106)
      {
        IIOReadPlugin::convertBlockSetToSDR(a1, *v106);
        uint64_t v38 = 0;
        uint64_t *v106 = v107;
        return v38;
      }
      return 0;
    }
  }
  return v38;
}

void sub_1885BC80C(_Unwind_Exception *a1)
{
  IIOString::~IIOString((IIOString *)(v1 - 144));
  _Unwind_Resume(a1);
}

BOOL IIOImageSource::doBindToReader(IIOImageSource *this)
{
  int v53 = 0;
  uint64_t Source = (IIO_ReaderHandler *)CGImageSourceGetSource(*((void *)this + 2));
  ReaderHandler = (IIOImageSource *)IIO_ReaderHandler::GetReaderHandler(Source);
  int v52 = 0;
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 288));
  *((_DWORD *)this + 28) = -4;
  pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 288));
  if (!Source) {
    goto LABEL_58;
  }
  BOOL isFinal = IIOImageRead::isFinal(Source);
  uint64_t v5 = IIOImageSource::cf(ReaderHandler);
  if (!v5)
  {
    uint64_t v11 = 0;
    goto LABEL_54;
  }
  size_t v6 = v5;
  if (isFinal) {
    int v7 = -5;
  }
  else {
    int v7 = -2;
  }
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 288));
  *((_DWORD *)this + 28) = v7;
  pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 288));
  uint64_t v8 = IIOImageRead::retainBytePointer(Source, (const __CFData **)&v53, 0);
  if (v8)
  {
    int v9 = (unsigned __int8 *)v8;
    unint64_t Size = IIOImageRead::getSize(Source);
    uint64_t v11 = 0;
  }
  else
  {
    uint64_t v11 = (unsigned __int8 *)malloc_type_malloc(v6, 0x5AA7F1FuLL);
    if (!v11) {
      goto LABEL_54;
    }
    unint64_t Size = IIOImageRead::getBytesAtOffset(Source, v11, 0, v6);
    int v9 = v11;
  }
  if (Size >= v6) {
    size_t v12 = v6;
  }
  else {
    size_t v12 = Size;
  }
  unint64_t v44 = v12;
  if (Size < 5) {
    goto LABEL_54;
  }
  ERROR_ImageIO_DataBufferIsNotReadable(v9);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 288));
  *((_DWORD *)this + 28) = -3;
  pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 288));
  CFIndex v13 = IIOImageRead::getSize(Source);
  uint64_t v14 = (IIO_Reader *)*((void *)this + 12);
  uint64_t v43 = v11;
  BOOL v42 = isFinal;
  if (v14
    || (CFStringRef v18 = (const __CFString *)*((void *)this + 7)) != 0
    && (uint64_t v14 = IIO_ReaderHandler::readerForUTType(ReaderHandler, v18), (*((void *)this + 12) = v14) != 0))
  {
    long long v15 = (IIO_Reader ***)ReaderHandler;
    int v16 = Source;
    unsigned int v17 = (__CFString *)IIO_Reader::utType(v14);
  }
  else
  {
    long long v15 = (IIO_Reader ***)ReaderHandler;
    int v16 = Source;
    unsigned int v17 = 0;
  }
  uint64_t v20 = *((void *)this + 9);
  uint64_t v19 = *((void *)this + 10);
  int v21 = (*((unsigned char *)this + 54) == 6) | (8 * (*((_DWORD *)this + 16) == 1)) | (4 * *((unsigned __int8 *)this + 88));
  if (*((unsigned char *)this + 51) == 1) {
    int v22 = 16;
  }
  else {
    int v22 = 32 * (*((unsigned char *)this + 51) != 0);
  }
  int v23 = v21 | v22;
  v49[0] = *((void *)this + 9);
  v49[1] = v19;
  int v50 = v21 | v22;
  int v51 = 0;
  unsigned int v24 = IIO_ReaderHandler::readerForBytes(v15, v9, v44, v17, v16, v13, v49, *((char *)this + 53), &v52);
  *((void *)this + 13) = v24;
  if (!v24 && v52 == -1400)
  {
    ImageIOLog(" retrying 'readerForBytes' (ImageIOXPCService crashed?)\n");
    v46[0] = v20;
    v46[1] = v19;
    int v47 = v23;
    int v48 = 0;
    *((void *)this + 13) = IIO_ReaderHandler::readerForBytes(v15, v9, v44, v17, v16, v13, v46, *((char *)this + 53), &v52);
    unsigned int v25 = "";
    if (!v52) {
      unsigned int v25 = "";
    }
    ImageIOLog("%s retrying 'readerForBytes'  err: %d\n", v25, v52);
    unsigned int v24 = (IIO_Reader *)*((void *)this + 13);
  }
  if (v24)
  {
    uint64_t Source = v16;
    if ((gIIODebugFlags & 0x30000) == 0)
    {
LABEL_52:
      pthread_mutex_lock((pthread_mutex_t *)((char *)this + 288));
      *((_DWORD *)this + 28) = v42 - 1;
      pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 288));
      goto LABEL_53;
    }
    int v26 = IIO_Reader::osType(v24);
    unsigned int v27 = v26 >> 24;
    uint64_t v28 = MEMORY[0x1E4F14390];
    if (v26 < 0)
    {
      if (__maskrune(v27, 0x40000uLL)) {
        goto LABEL_31;
      }
    }
    else if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v27 + 60) & 0x40000) != 0)
    {
LABEL_31:
      uint64_t v29 = ((int)IIO_Reader::osType(*((IIO_Reader **)this + 13)) >> 24);
      goto LABEL_36;
    }
    uint64_t v29 = 46;
LABEL_36:
    signed int v31 = IIO_Reader::osType(*((IIO_Reader **)this + 13)) << 8;
    unsigned int v32 = v31 >> 24;
    if (v31 < 0)
    {
      if (__maskrune(v32, 0x40000uLL)) {
        goto LABEL_38;
      }
    }
    else if ((*(_DWORD *)(v28 + 4 * v32 + 60) & 0x40000) != 0)
    {
LABEL_38:
      uint64_t v33 = ((int)(IIO_Reader::osType(*((IIO_Reader **)this + 13)) << 8) >> 24);
      goto LABEL_41;
    }
    uint64_t v33 = 46;
LABEL_41:
    int v34 = IIO_Reader::osType(*((IIO_Reader **)this + 13));
    int v35 = v34 << 16;
    unsigned int v36 = (__int16)v34 >> 8;
    if (v35 < 0)
    {
      if (__maskrune(v36, 0x40000uLL)) {
        goto LABEL_43;
      }
    }
    else if ((*(_DWORD *)(v28 + 4 * v36 + 60) & 0x40000) != 0)
    {
LABEL_43:
      uint64_t v37 = ((__int16)IIO_Reader::osType(*((IIO_Reader **)this + 13)) >> 8);
      goto LABEL_46;
    }
    uint64_t v37 = 46;
LABEL_46:
    int v38 = IIO_Reader::osType(*((IIO_Reader **)this + 13));
    if ((v38 << 24) <= 0x7F000000)
    {
      if ((*(_DWORD *)(v28 + 4 * (char)v38 + 60) & 0x40000) != 0) {
        goto LABEL_48;
      }
    }
    else if (__maskrune((char)v38, 0x40000uLL))
    {
LABEL_48:
      uint64_t v39 = (char)IIO_Reader::osType(*((IIO_Reader **)this + 13));
LABEL_51:
      ImageIOLog("*** doBindToReader:  _reader->osint Type = '%c%c%c%c'\n", v29, v33, v37, v39);
      goto LABEL_52;
    }
    uint64_t v39 = 46;
    goto LABEL_51;
  }
  uint64_t Source = v16;
  if (v52 != -57)
  {
LABEL_53:
    uint64_t v11 = v43;
    goto LABEL_54;
  }
  IIOString::IIOString((IIOString *)v45, v17);
  long long v30 = (const char *)IIOString::utf8String((IIOString *)v45);
  uint64_t v11 = v43;
  _cg_jpeg_mem_term("doBindToReader", 1042, "*** ERROR: hint ('%s') does not match image data - kCGImageSourceFailForDataNotMatchingHint was specified --> failing\n", v30);
  IIOString::~IIOString((IIOString *)v45);
  *((unsigned char *)this + 89) = 1;
LABEL_54:
  if (v53) {
    IIOImageRead::releaseBytePointer(Source, v53);
  }
  if (v11) {
    free(v11);
  }
LABEL_58:
  if (!*((void *)this + 13))
  {
    uint64_t v40 = IIOImageRead::copySourceInfo(Source);
    _cg_jpeg_mem_term("doBindToReader", 1071, "*** could not find a reader for: '%s'\n", v40);
    if (v40) {
      free(v40);
    }
  }
  return *((void *)this + 13) != 0;
}

void sub_1885BCD34(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  IIOString::~IIOString((IIOString *)va);
  _Unwind_Resume(a1);
}

CFIndex IIOImageRead::getSize(IIOImageRead *this)
{
  if (*((unsigned char *)this + 65))
  {
    uint64_t v2 = (pthread_mutex_t *)((char *)this + 376);
    pthread_mutex_lock((pthread_mutex_t *)((char *)this + 376));
    if (*((void *)this + 6))
    {
      CFIndex Length = *((void *)this + 10);
    }
    else
    {
      CFDataRef v4 = (const __CFData *)*((void *)this + 4);
      if (v4) {
        CFIndex Length = CFDataGetLength(v4);
      }
      else {
        CFIndex Length = 0;
      }
    }
    pthread_mutex_unlock(v2);
    return Length;
  }
  if (*((void *)this + 6)) {
    return *((void *)this + 10);
  }
  CFDataRef v5 = (const __CFData *)*((void *)this + 4);
  if (!v5) {
    return 0;
  }

  return CFDataGetLength(v5);
}

uint64_t IIO_ReaderHandler::GetReaderHandler(IIO_ReaderHandler *this)
{
  if (IIO_ReaderHandler::GetReaderHandler(void)::readerHandlerCreate != -1) {
    dispatch_once(&IIO_ReaderHandler::GetReaderHandler(void)::readerHandlerCreate, &__block_literal_global_26);
  }
  return IIO_ReaderHandler::GetReaderHandler(void)::gIIO_ReaderHandler;
}

const UInt8 *IIOImageRead::retainBytePointer(IIOImageRead *this, const __CFData **a2, int a3)
{
  CFDataRef v5 = (const void *)*((void *)this + 4);
  if (v5)
  {
    if ((gIIODebugFlags & 0x80000000000) != 0)
    {
      ImageIOLog("D   %s:%d CFRetain %p\n", "retainBytePointer", 2033, v5);
      CFDataRef v5 = (const void *)*((void *)this + 4);
    }
    CFRetain(v5);
    *a2 = (const __CFData *)*((void *)this + 4);
    CFDataRef v6 = (const __CFData *)*((void *)this + 4);
  }
  else
  {
    if (!a3) {
      return 0;
    }
    CFDataRef v8 = IIOImageRead::copyData(this);
    CFDataRef v9 = v8;
    if ((gIIODebugFlags & 0x80000000000) != 0) {
      ImageIOLog("D   %s:%d copyData %p\n", "retainBytePointer", 2041, v8);
    }
    if (!v9) {
      return 0;
    }
    *a2 = v9;
    CFDataRef v6 = v9;
  }

  return CFDataGetBytePtr(v6);
}

void IIOImageRead::releaseBytePointer(IIOImageRead *this, CFTypeRef cf)
{
  if (cf)
  {
    if ((gIIODebugFlags & 0x80000000000) != 0) {
      ImageIOLog("D   %s:%d CFRelease %p\n", "releaseBytePointer", 2055, cf);
    }
    CFRelease(cf);
  }
}

uint64_t ERROR_ImageIO_DataBufferIsNotReadable(unsigned __int8 *a1)
{
  return *a1;
}

IIO_Reader *IIO_ReaderHandler::readerForBytes(IIO_Reader ***a1, const void *a2, unint64_t a3, __CFString *a4, IIOImageRead *a5, unint64_t a6, void *a7, int a8, int *a9)
{
  uint64_t v17 = IIO_XPCServer();
  if ((v17 & 1) == 0)
  {
    uint64_t IIOXPCClient = (IIOXPCClient *)IIOXPCClient::GetIIOXPCClient((IIOXPCClient *)v17);
    if (!IIOXPCClient::useServerForIdentification((uint64_t)IIOXPCClient, a5, a8))
    {
      long long v56 = *(_OWORD *)a7;
      uint64_t v57 = a7[2];
      CFStringRef v18 = (unint64_t *)&v56;
      return IIO_ReaderHandler::readerForBytesImp(a1, (uint64_t)a2, a3, a4, a6, v18, 0, a9);
    }
    kdebug_trace();
    xpc_object_t v20 = xpc_dictionary_create(0, 0, 0);
    int v21 = v20;
    if (v20)
    {
      xpc_object_t v22 = iio_xpc_add_source_dict(v20);
      xpc_dictionary_set_uint64(v21, "iio_xpc_message_id", 1uLL);
      xpc_object_t v23 = xpc_data_create(a2, a3);
      if (v23)
      {
        unsigned int v24 = v23;
        xpc_dictionary_set_value(v22, "iio_xpc_src_header_data", v23);
        xpc_release(v24);
      }
      if (a4)
      {
        uint64_t v58 = 0;
        uint64_t v59 = 0;
        double v60 = 0;
        IIOString::IIOString((IIOString *)&v58, a4);
        unsigned int v25 = (const char *)IIOString::utf8String((IIOString *)&v58);
        xpc_dictionary_set_string(v22, "iio_xpc_src_hint_string", v25);
        IIOString::~IIOString((IIOString *)&v58);
      }
      xpc_dictionary_set_uint64(v22, "iio_xpc_src_file_size", a6);
      iio_xpc_add_xpcObj_from_IIOHeaderOptions(v22, "iio_xpc_src_header_options", a7);
    }
    int v26 = (_xpc_connection_s *)IIOXPCClient::xpc_connection(IIOXPCClient);
    unsigned int v27 = (dispatch_queue_s *)IIOXPCClient::xpc_queue(IIOXPCClient);
    xpc_object_t v28 = IIOXPCClient::send_message_with_reply(IIOXPCClient, v26, v27, v21);
    if (!v28)
    {
      IIOXPCLog(" ImageIOXPC: XPC_READPLUGIN_IDENTIFY error null-reply\n");
      uint64_t v33 = 0;
LABEL_36:
      xpc_release(v21);
      kdebug_trace();
      return v33;
    }
    uint64_t v29 = v28;
    xpc_object_t message_dict = iio_xpc_get_message_dict(v28);
    int error_code = iio_xpc_dictionary_get_error_code(message_dict);
    if (a9) {
      *a9 = error_code;
    }
    if (error_code)
    {
      if (error_code == -1400) {
        IIOXPCLog(" ImageIOXPC: XPC_READPLUGIN_IDENTIFY XPC connection interrupted\n");
      }
      else {
        IIOXPCLog(" ImageIOXPC: XPC_READPLUGIN_IDENTIFY error: %d\n");
      }
    }
    else
    {
      xpc_object_t source_dict = iio_xpc_get_source_dict(v29);
      if (source_dict)
      {
        int v35 = source_dict;
        string = xpc_dictionary_get_string(source_dict, "iio_xpc_src_utitype");
        int uint64 = xpc_dictionary_get_uint64(v35, "iio_xpc_src_ostype");
        int v38 = uint64;
        if (string)
        {
          uint64_t v58 = 0;
          uint64_t v59 = 0;
          double v60 = 0;
          IIOString::IIOString((IIOString *)&v58, string);
          int v53 = (const char *)IIOString::utf8String((IIOString *)&v58);
          unsigned int v39 = v38 >> 24;
          uint64_t v40 = MEMORY[0x1E4F14390];
          if (v38 < 0) {
            int v41 = __maskrune(v38 >> 24, 0x40000uLL);
          }
          else {
            int v41 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v39 + 60) & 0x40000;
          }
          if (v41) {
            uint64_t v43 = v39;
          }
          else {
            uint64_t v43 = 46;
          }
          unsigned int v44 = v38 << 8 >> 24;
          if (v38 << 8 < 0) {
            int v45 = __maskrune(v38 << 8 >> 24, 0x40000uLL);
          }
          else {
            int v45 = *(_DWORD *)(v40 + 4 * v44 + 60) & 0x40000;
          }
          if (v45) {
            uint64_t v46 = v44;
          }
          else {
            uint64_t v46 = 46;
          }
          unsigned int v47 = (__int16)v38 >> 8;
          if (v38 << 16 < 0)
          {
            int v49 = __maskrune((__int16)v38 >> 8, 0x40000uLL);
            uint64_t v48 = v40;
          }
          else
          {
            uint64_t v48 = v40;
            int v49 = *(_DWORD *)(v40 + 4 * v47 + 60) & 0x40000;
          }
          if ((v38 << 24) <= 0x7F000000) {
            int v50 = *(_DWORD *)(v48 + 4 * (char)v38 + 60) & 0x40000;
          }
          else {
            int v50 = __maskrune((char)v38, 0x40000uLL);
          }
          if (v49) {
            uint64_t v51 = v47;
          }
          else {
            uint64_t v51 = 46;
          }
          if (v50) {
            uint64_t v52 = (char)v38;
          }
          else {
            uint64_t v52 = 46;
          }
          IIOXPCLog(" ImageIOXPC: XPC_READPLUGIN_IDENTIFY: '%s' '%c%c%c%c'\n", v53, v43, v46, v51, v52);
          uint64_t v33 = IIO_ReaderHandler::readerForUTTypeAndOSType((IIO_ReaderHandler *)a1, v60, v38);
          IIOString::~IIOString((IIOString *)&v58);
          goto LABEL_35;
        }
        if (uint64 < 0) {
          __maskrune(uint64 >> 24, 0x40000uLL);
        }
      }
      else
      {
        int v38 = 774778414;
      }
      if (v38 << 8 < 0) {
        __maskrune(v38 << 8 >> 24, 0x40000uLL);
      }
      if (v38 << 16 < 0) {
        __maskrune((__int16)v38 >> 8, 0x40000uLL);
      }
      if ((v38 << 24) > 0x7F000000) {
        __maskrune((char)v38, 0x40000uLL);
      }
      IIOXPCLog(" ImageIOXPC: XPC_READPLUGIN_IDENTIFY '%c%c%c%c' failed to get plugin\n");
    }
    uint64_t v33 = 0;
LABEL_35:
    _cg_jpeg_mem_term(IIOXPCClient, v29, v32);
    xpc_release(v29);
    goto LABEL_36;
  }
  long long v54 = *(_OWORD *)a7;
  uint64_t v55 = a7[2];
  CFStringRef v18 = (unint64_t *)&v54;
  return IIO_ReaderHandler::readerForBytesImp(a1, (uint64_t)a2, a3, a4, a6, v18, 0, a9);
}

void sub_1885BD4C4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, ...)
{
  va_start(va, a14);
  IIOString::~IIOString((IIOString *)va);
  _Unwind_Resume(a1);
}

uint64_t IIOXPCClient::useServerForCall(uint64_t a1, IIOImageRead *a2, uint64_t a3, int a4, uint64_t a5, int a6)
{
  if (IIO_XPCServer()) {
    return 0;
  }
  if (a4 != 1)
  {
    if (a4 != -1) {
      return 0;
    }
    uint64_t result = IIOIsOOPEnabled(0);
    if (!result) {
      return result;
    }
  }
  if (a3)
  {
    if ((*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a3 + 232))(a3, a5)) {
      return IIOImageRead::trustedURL(a2) ^ 1;
    }
  }
  else if (a6)
  {
    return IIOImageRead::trustedURL(a2) ^ 1;
  }
  return 0;
}

uint64_t IIO_XPCServer()
{
  return gRunningInXPCService;
}

uint64_t IIOXPCClient::useServerForIdentification(uint64_t a1, IIOImageRead *a2, int a3)
{
  return IIOXPCClient::useServerForCall(a1, a2, 0, a3, 1, 1);
}

CGImageRef CGImageSourceCreateImageAtIndex(CGImageSourceRef isrc, size_t index, CFDictionaryRef options)
{
  memset(v28, 0, sizeof(v28));
  IIODictionary::IIODictionary((IIODictionary *)v28, options);
  IIOPackSrcInputInfo((IIODictionary *)v28, index);
  kdebug_trace();
  IIOInitDebugFlags();
  unsigned int v6 = (gIIODebugFlags >> 12) & 3;
  if (v6) {
    ImageIODebugOptions(v6, "A", "CGImageSourceCreateImageAtIndex", isrc, 0, index, options);
  }
  int v27 = 0;
  if (!isrc)
  {
    LogError("CGImageSourceCreateImageAtIndex", 5063, "*** ERROR: CGImageSourceCreateImageAtIndex: source is nil\n");
LABEL_54:
    uint64_t v9 = 0;
LABEL_12:
    int v10 = 0;
LABEL_13:
    if ((gIIODebugFlags & 0x800000000000) != 0) {
      ImageIOLog(" ISSUE: %s:%d:  %s\n", "CGImageSourceCreateImageAtIndex", 5088, "could not create CGImageRef");
    }
    if (v9 && !IIOImageSource::isProxy((IIOImageSource *)v9))
    {
      kdebug_trace();
      unsigned int v11 = v10 >> 24;
      uint64_t v12 = MEMORY[0x1E4F14390];
      if (v10 < 0) {
        int v13 = __maskrune(v10 >> 24, 0x40000uLL);
      }
      else {
        int v13 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v11 + 60) & 0x40000;
      }
      if (v13) {
        uint64_t v17 = v11;
      }
      else {
        uint64_t v17 = 46;
      }
      unsigned int v18 = v10 << 8 >> 24;
      if (v10 << 8 < 0) {
        int v19 = __maskrune(v10 << 8 >> 24, 0x40000uLL);
      }
      else {
        int v19 = *(_DWORD *)(v12 + 4 * v18 + 60) & 0x40000;
      }
      if (v19) {
        uint64_t v20 = v18;
      }
      else {
        uint64_t v20 = 46;
      }
      unsigned int v21 = (__int16)v10 >> 8;
      if (v10 << 16 < 0) {
        int v22 = __maskrune((__int16)v10 >> 8, 0x40000uLL);
      }
      else {
        int v22 = *(_DWORD *)(v12 + 4 * v21 + 60) & 0x40000;
      }
      if ((v10 << 24) <= 0x7F000000) {
        int v23 = *(_DWORD *)(v12 + 4 * (char)v10 + 60) & 0x40000;
      }
      else {
        int v23 = __maskrune((char)v10, 0x40000uLL);
      }
      if (v22) {
        uint64_t v24 = v21;
      }
      else {
        uint64_t v24 = 46;
      }
      if (v23) {
        uint64_t v25 = (char)v10;
      }
      else {
        uint64_t v25 = 46;
      }
      LogError("CGImageSourceCreateImageAtIndex", 5100, "*** ERROR: CGImageSourceCreateImageAtIndex[%ld] - '%c%c%c%c' - failed to create image [%d]\n", index, v17, v20, v24, v25, v27);
    }
    uint64_t v14 = 0;
    goto LABEL_51;
  }
  CFTypeID v7 = CFGetTypeID(isrc);
  if (CGImageSourceGetTypeID::once != -1) {
    dispatch_once(&CGImageSourceGetTypeID::once, &__block_literal_global_164);
  }
  if (v7 != CGImageSourceGetTypeID::id)
  {
    LogError("CGImageSourceCreateImageAtIndex", 5064, "*** ERROR: CGImageSourceCreateImageAtIndex: source is not a CGImageSourceRef\n");
    goto LABEL_54;
  }
  if (options)
  {
    CFTypeID v8 = CFGetTypeID(options);
    if (v8 != CFDictionaryGetTypeID()) {
      LogError("CGImageSourceCreateImageAtIndex", 5067, "*** ERROR: CGImageSourceCreateImageAtIndex: options parameter is not a CFDictionaryRef - ignoring\n");
    }
  }
  uint64_t v9 = *((void *)isrc + 3);
  if (!v9 || IIOImageSource::isProxy(*((IIOImageSource **)isrc + 3))) {
    goto LABEL_12;
  }
  if (*(unsigned char *)(v9 + 89))
  {
    LogError("CGImageSourceCreateImageAtIndex", 5074, "*** ERROR: invalid CGImageSourceRef (non-matching hint)\n");
    int v10 = 0;
    goto LABEL_13;
  }
  pthread_mutex_lock((pthread_mutex_t *)(v9 + 224));
  uint64_t v14 = IIOImageSource::createImageAtIndex((IIOImageSource *)v9, index, v28, &v27);
  long long v15 = *(IIO_Reader **)(v9 + 104);
  if (v15) {
    int v10 = IIO_Reader::osType(v15);
  }
  else {
    int v10 = 1848598816;
  }
  pthread_mutex_unlock((pthread_mutex_t *)(v9 + 224));
  if (!v14) {
    goto LABEL_13;
  }
  if ((gIIODebugFlags & 0x10000000) != 0)
  {
    CFShow(v14);
    CGImageDumpToFile();
  }
  CGImageGetWidth(v14);
  CGImageGetHeight(v14);
  CGImageGetBitsPerPixel(v14);
  CGImageGetBitsPerComponent(v14);
  ColorSpace = CGImageGetColorSpace(v14);
  CGColorSpaceGetModel(ColorSpace);
  CGImageGetImageProvider();
  CGImageGetContentHeadroom();
  CGImageGetBitmapInfo(v14);
LABEL_51:
  kdebug_trace();
  IIO_CheckHeadroom("CGImageSourceCreateImageAtIndex", v10, v14, (IIODictionary *)v28);
  IIODictionary::~IIODictionary((IIODictionary *)v28);
  return v14;
}

void sub_1885BDA1C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  IIODictionary::~IIODictionary((IIODictionary *)va);
  _Unwind_Resume(a1);
}

BOOL IIOImageSource::isProxy(IIOImageSource *this)
{
  return *((unsigned char *)this + 54) == 7;
}

const char *IIO_CheckHeadroom(const char *result, int a2, CGImage *a3, IIODictionary *a4)
{
  if ((gIIODebugFlags & 0x300000) != 0)
  {
    int v34 = result;
    CGImageGetContentHeadroom();
    float v8 = v7;
    ColorSpace = CGImageGetColorSpace(a3);
    CGColorSpaceGetHeadroomInfo();
    float v11 = v10;
    BOOL IsHDR = CGColorSpaceIsHDR(ColorSpace);
    BOOL v31 = CGColorSpaceUsesExtendedRange(ColorSpace);
    int v32 = CGColorSpaceContainsFlexGTCInfo();
    if (a4 && IIODictionary::containsKey(a4, @"kCGImageSourceDecodeRequest"))
    {
      CFStringRef ObjectForKey = (const __CFString *)IIODictionary::getObjectForKey(a4, @"kCGImageSourceDecodeRequest");
      CFComparisonResult v13 = CFStringCompare(ObjectForKey, @"kCGImageSourceDecodeToSDR", 0);
      CFComparisonResult v14 = CFStringCompare(ObjectForKey, @"kCGImageSourceDecodeToHDR", 0);
      if (v14) {
        BOOL v15 = 1;
      }
      else {
        BOOL v15 = v13 == kCFCompareEqualTo;
      }
      if (v13) {
        BOOL v16 = v14 == kCFCompareEqualTo;
      }
      else {
        BOOL v16 = 0;
      }
    }
    else
    {
      BOOL v16 = 0;
      BOOL v15 = 1;
    }
    size_t Width = CGImageGetWidth(a3);
    size_t Height = CGImageGetHeight(a3);
    unsigned int v19 = a2 >> 24;
    uint64_t v20 = MEMORY[0x1E4F14390];
    if (a2 < 0) {
      int v21 = __maskrune(a2 >> 24, 0x40000uLL);
    }
    else {
      int v21 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v19 + 60) & 0x40000;
    }
    if (v21) {
      uint64_t v22 = v19;
    }
    else {
      uint64_t v22 = 46;
    }
    unsigned int v23 = a2 << 8 >> 24;
    if (a2 << 8 < 0) {
      int v24 = __maskrune(a2 << 8 >> 24, 0x40000uLL);
    }
    else {
      int v24 = *(_DWORD *)(v20 + 4 * v23 + 60) & 0x40000;
    }
    if (v24) {
      uint64_t v25 = v23;
    }
    else {
      uint64_t v25 = 46;
    }
    unsigned int v26 = (__int16)a2 >> 8;
    if (a2 << 16 < 0) {
      int v27 = __maskrune((__int16)a2 >> 8, 0x40000uLL);
    }
    else {
      int v27 = *(_DWORD *)(v20 + 4 * v26 + 60) & 0x40000;
    }
    if (v27) {
      uint64_t v28 = v26;
    }
    else {
      uint64_t v28 = 46;
    }
    if ((a2 << 24) <= 0x7F000000) {
      int v29 = *(_DWORD *)(v20 + 4 * (char)a2 + 60) & 0x40000;
    }
    else {
      int v29 = __maskrune((char)a2, 0x40000uLL);
    }
    if (v29) {
      uint64_t v30 = (char)a2;
    }
    else {
      uint64_t v30 = 46;
    }
    return ImageIOLog("  %s '%c%c%c%c' [%ldx%ld]: imgHeadroom: %g   csHeadroom: %g   hasFlexGTC: %d   isHDR: %d   isEDR: %d   decodeToSDR: %d   decodeToHDR: %d\n", v34, v22, v25, v28, v30, Width, Height, v8, v11, v32, IsHDR, v31, v15, v16);
  }
  return result;
}

CGImage *IIOImageSource::createImageAtIndex(IIOImageSource *this, unint64_t a2, const __CFDictionary **a3, int *a4)
{
  uint64_t v94 = *MEMORY[0x1E4F143B8];
  *(void *)unsigned int v92 = 0;
  int v91 = 0;
  if ((IIOImageSource::bindToReader(this) & 1) == 0)
  {
    uint64_t Source = (_APP1XMP *)CGImageSourceGetSource(*((void *)this + 2));
    if (Source)
    {
      CFComparisonResult v14 = Source;
      unint64_t XmpData = _APP1XMP::getXmpData(Source);
      if (XmpData >= 8) {
        unint64_t v16 = 8;
      }
      else {
        unint64_t v16 = XmpData;
      }
      *(void *)bytes = 0;
      IIOImageRead::getBytesAtOffset(v14, bytes, 0, v16);
      int v87 = *((unsigned __int8 *)this + 54);
      uint64_t v86 = _APP1XMP::getXmpData(v14);
      int v17 = bytes[0];
      int v18 = bytes[1];
      int v85 = bytes[2];
      int v84 = bytes[3];
      int v83 = bytes[4];
      int v82 = bytes[5];
      int v81 = bytes[6];
      int v80 = bytes[7];
      uint64_t v19 = MEMORY[0x1E4F14390];
      if ((char)bytes[0] < 0)
      {
        int v25 = bytes[1];
        int v20 = __maskrune(bytes[0], 0x40000uLL);
        unsigned int v21 = bytes[0];
        unsigned int v22 = bytes[1];
        int v18 = v25;
      }
      else
      {
        int v20 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * bytes[0] + 60) & 0x40000;
        unsigned int v21 = bytes[0];
        unsigned int v22 = bytes[1];
      }
      if (v20) {
        uint64_t v26 = v21;
      }
      else {
        uint64_t v26 = 46;
      }
      uint64_t v78 = v26;
      int v79 = v18;
      if ((v22 & 0x80) != 0)
      {
        int v27 = __maskrune(v22, 0x40000uLL);
        unsigned int v22 = bytes[1];
      }
      else
      {
        int v27 = *(_DWORD *)(v19 + 4 * v22 + 60) & 0x40000;
      }
      if (v27) {
        uint64_t v28 = v22;
      }
      else {
        uint64_t v28 = 46;
      }
      UInt8 v29 = bytes[2];
      if ((char)bytes[2] < 0)
      {
        int v30 = __maskrune(bytes[2], 0x40000uLL);
        UInt8 v29 = bytes[2];
      }
      else
      {
        int v30 = *(_DWORD *)(v19 + 4 * bytes[2] + 60) & 0x40000;
      }
      if (v30) {
        uint64_t v31 = v29;
      }
      else {
        uint64_t v31 = 46;
      }
      UInt8 v32 = bytes[3];
      if ((char)bytes[3] < 0)
      {
        int v33 = __maskrune(bytes[3], 0x40000uLL);
        UInt8 v32 = bytes[3];
      }
      else
      {
        int v33 = *(_DWORD *)(v19 + 4 * bytes[3] + 60) & 0x40000;
      }
      if (v33) {
        uint64_t v34 = v32;
      }
      else {
        uint64_t v34 = 46;
      }
      UInt8 v35 = bytes[4];
      if ((char)bytes[4] < 0)
      {
        int v36 = __maskrune(bytes[4], 0x40000uLL);
        UInt8 v35 = bytes[4];
      }
      else
      {
        int v36 = *(_DWORD *)(v19 + 4 * bytes[4] + 60) & 0x40000;
      }
      if (v36) {
        uint64_t v37 = v35;
      }
      else {
        uint64_t v37 = 46;
      }
      UInt8 v38 = bytes[5];
      if ((char)bytes[5] < 0)
      {
        int v39 = __maskrune(bytes[5], 0x40000uLL);
        UInt8 v38 = bytes[5];
      }
      else
      {
        int v39 = *(_DWORD *)(v19 + 4 * bytes[5] + 60) & 0x40000;
      }
      if (v39) {
        uint64_t v40 = v38;
      }
      else {
        uint64_t v40 = 46;
      }
      UInt8 v41 = bytes[6];
      if ((char)bytes[6] < 0)
      {
        int v42 = __maskrune(bytes[6], 0x40000uLL);
        UInt8 v41 = bytes[6];
      }
      else
      {
        int v42 = *(_DWORD *)(v19 + 4 * bytes[6] + 60) & 0x40000;
      }
      if (v42) {
        uint64_t v43 = v41;
      }
      else {
        uint64_t v43 = 46;
      }
      LOBYTE(v44) = bytes[7];
      if ((char)bytes[7] < 0)
      {
        int v45 = __maskrune(bytes[7], 0x40000uLL);
        LOBYTE(v44) = bytes[7];
      }
      else
      {
        int v45 = *(_DWORD *)(v19 + 4 * bytes[7] + 60) & 0x40000;
      }
      if (v45) {
        uint64_t v44 = v44;
      }
      else {
        uint64_t v44 = 46;
      }
      LogError("createImageAtIndex", 1964, "*** ERROR: createImageAtIndex %d could not find plugin for image source [%ld bytes] %02X %02X %02X %02X %02X %02X %02X %02X... '%c%c%c%c%c%c%c%c'\n", v87, v86, v17, v79, v85, v84, v83, v82, v81, v80, v78, v28, v31, v34, v37,
        v40,
        v43,
        v44);
    }
    else
    {
      LogError("createImageAtIndex", 1955, "*** ERROR: could not find plugin for image source - imageRead is NULL\n");
    }
    float v10 = 0;
    float v11 = 0;
    int v12 = -62;
LABEL_69:
    int v91 = v12;
    goto LABEL_70;
  }
  uint64_t ImagePlus = IIOImageSource::makeImagePlus(this, a2, a3);
  *(void *)unsigned int v92 = ImagePlus;
  if (!ImagePlus)
  {
    if ((gIIODebugFlags & 0x3000) != 0) {
      ImageIOLog("*** %s:%d: makeImagePlus returned nil\n", "createImageAtIndex", 1975);
    }
    float v10 = 0;
    float v11 = 0;
    int v12 = -58;
    goto LABEL_69;
  }
  float v8 = (void *)ImagePlus;
  CFArrayRef v9 = (const __CFArray *)*((void *)this + 24);
  if (v9)
  {
    v95.CFIndex length = CFArrayGetCount(*((CFArrayRef *)this + 24));
    v95.location = 0;
    if (CFArrayContainsValue(v9, v95, v8))
    {
      if ((gIIODebugFlags & 0x3000) != 0) {
        ImageIOLog("*** %s:%d: 'createImage' returned incomplete iPlus: %p -- skipping image creation\n", "createImageAtIndex", 1984, 0);
      }
      float v10 = 0;
      float v11 = 0;
      int v12 = -59;
      goto LABEL_69;
    }
  }
  float v11 = (IIOImagePlus *)v8[3];
  float v10 = IIOImagePlus::createImage(v11, *((CGImageSource **)this + 1), &v91);
  if (v10)
  {
    CFSetAddValue(*((CFMutableSetRef *)this + 23), v10);
    uint64_t Plugin = IIOImagePlus::readPlugin(v11);
    if (Plugin)
    {
      uint64_t v24 = IIO_Reader::utType(*((IIO_Reader **)this + 13));
      (*(void (**)(uint64_t, CGImage *, uint64_t, unint64_t))(*(void *)Plugin + 128))(Plugin, v10, v24, a2);
    }
    else
    {
      IIO_Reader::utType(*((IIO_Reader **)this + 13));
      CGImageSetProperty();
      IIONumber::IIONumber((IIONumber *)bytes, a2);
      CGImageSetProperty();
      IIONumber::~IIONumber((IIONumber *)bytes);
      unsigned int v56 = IIO_Reader::osType(*((IIO_Reader **)this + 13));
      IIOString::IIOString((IIOString *)bytes, v56);
      CGImageSetProperty();
      IIOString::~IIOString((IIOString *)bytes);
    }
    *(void *)bytes = *((void *)this + 2);
    CFAllocatorRef v57 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    CFDataRef v58 = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], bytes, 8);
    if (v58)
    {
      CGImageSetProperty();
      CFRelease(v58);
    }
    CFDataRef v59 = CFDataCreate(v57, v92, 8);
    if (v59)
    {
      CGImageSetProperty();
      CFRelease(v59);
    }
    if (IIOImagePlus::getSubsampleFactor(v11))
    {
      __int16 valuePtr = IIOImagePlus::getSubsampleFactor(v11);
      CFNumberRef v60 = CFNumberCreate(v57, kCFNumberSInt16Type, &valuePtr);
      if (v60)
      {
        CGImageSetProperty();
        CFRelease(v60);
      }
    }
    ImagePropertiesAtIndedouble x = (IIODictionary *)IIOImageSource::getImagePropertiesAtIndex(this, a2);
    double v62 = ImagePropertiesAtIndex;
    if (ImagePropertiesAtIndex
      && IIODictionary::containsKey(ImagePropertiesAtIndex, @"Orientation"))
    {
      IIODictionary::getObjectForKey(v62, @"Orientation");
      CGImageSetProperty();
    }
    shouldCacheImmediateldouble y = (IIOImageSource *)IIOImagePlus::shouldCacheImmediately(v11);
    if (shouldCacheImmediately) {
      IIOImageSource::cacheImmediately(shouldCacheImmediately, v64, (IIODictionary *)a3, v10);
    }
  }
  else
  {
    if ((gIIODebugFlags & 0x3000) != 0) {
      ImageIOLog("*** %s:%d: 'createImage' returned nil (this: %p   iPlus: %p)\n", "createImageAtIndex", 1998, this, v11);
    }
    float v10 = 0;
  }
LABEL_70:
  IIOImageSource::removeUnusedImages((CFSetRef *)this);
  if ((gIIODebugFlags & 0x3000) == 0)
  {
    uint64_t v46 = a4;
    if (v10) {
      goto LABEL_127;
    }
    unsigned int v47 = (IIO_Reader *)*((void *)this + 13);
    if (v47)
    {
      int v48 = IIO_Reader::osType(v47);
      unsigned int v49 = v48 >> 24;
      if (v48 < 0)
      {
        int v50 = __maskrune(v49, 0x40000uLL);
        goto LABEL_82;
      }
    }
    else
    {
      unsigned int v49 = 110;
    }
    int v50 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v49 + 60) & 0x40000;
LABEL_82:
    uint64_t v51 = (IIO_Reader *)*((void *)this + 13);
    if (v50)
    {
      if (!v51)
      {
        unsigned int v54 = 47;
        uint64_t v52 = 110;
        goto LABEL_103;
      }
      uint64_t v52 = ((int)IIO_Reader::osType(v51) >> 24);
      uint64_t v51 = (IIO_Reader *)*((void *)this + 13);
      if (v51) {
        goto LABEL_85;
      }
    }
    else
    {
      uint64_t v52 = 46;
      if (v51)
      {
LABEL_85:
        signed int v53 = IIO_Reader::osType(v51) << 8;
        unsigned int v54 = v53 >> 24;
        if (v53 < 0)
        {
          int v55 = __maskrune(v54, 0x40000uLL);
          goto LABEL_104;
        }
LABEL_103:
        int v55 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v54 + 60) & 0x40000;
LABEL_104:
        unsigned int v65 = (IIO_Reader *)*((void *)this + 13);
        if (v55)
        {
          if (!v65)
          {
            unsigned int v69 = 97;
            uint64_t v66 = 47;
            goto LABEL_112;
          }
          uint64_t v66 = ((int)(IIO_Reader::osType(v65) << 8) >> 24);
          unsigned int v65 = (IIO_Reader *)*((void *)this + 13);
          if (v65) {
            goto LABEL_107;
          }
        }
        else
        {
          uint64_t v66 = 46;
          if (v65)
          {
LABEL_107:
            int v67 = IIO_Reader::osType(v65);
            int v68 = v67 << 16;
            unsigned int v69 = (__int16)v67 >> 8;
            if (v68 < 0)
            {
              int v70 = __maskrune(v69, 0x40000uLL);
              goto LABEL_113;
            }
LABEL_112:
            int v70 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v69 + 60) & 0x40000;
LABEL_113:
            xpc_object_t v71 = (IIO_Reader *)*((void *)this + 13);
            if (v70)
            {
              if (!v71)
              {
                unsigned int v74 = 32;
                uint64_t v72 = 97;
                goto LABEL_123;
              }
              uint64_t v72 = ((__int16)IIO_Reader::osType(v71) >> 8);
              xpc_object_t v71 = (IIO_Reader *)*((void *)this + 13);
              if (v71)
              {
LABEL_116:
                int v73 = IIO_Reader::osType(v71);
                unsigned int v74 = (char)v73;
                if ((v73 << 24) > 0x7F000000)
                {
                  if (__maskrune((char)v73, 0x40000uLL)) {
                    goto LABEL_118;
                  }
                  goto LABEL_124;
                }
LABEL_123:
                if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v74 + 60) & 0x40000) != 0)
                {
LABEL_118:
                  unsigned int v75 = (IIO_Reader *)*((void *)this + 13);
                  if (v75) {
                    uint64_t v76 = (char)IIO_Reader::osType(v75);
                  }
                  else {
                    uint64_t v76 = 32;
                  }
                  goto LABEL_126;
                }
LABEL_124:
                uint64_t v76 = 46;
LABEL_126:
                LogError("createImageAtIndex", 2093, "*** ERROR: createImageAtIndex[%ld] - '%c%c%c%c' - failed to create image [%d]\n", a2, v52, v66, v72, v76, v91);
                goto LABEL_127;
              }
            }
            else
            {
              uint64_t v72 = 46;
              if (v71) {
                goto LABEL_116;
              }
            }
            unsigned int v74 = 32;
            goto LABEL_123;
          }
        }
        unsigned int v69 = 97;
        goto LABEL_112;
      }
    }
    unsigned int v54 = 47;
    goto LABEL_103;
  }
  uint64_t v46 = a4;
  if (!v10) {
    ImageIOLog("*** %s:%d: could not create image (nil) (this: %p  iPlus: %p)\n", "createImageAtIndex", 2091, this, v11);
  }
LABEL_127:
  if (v46) {
    *uint64_t v46 = v91;
  }
  return v10;
}

void sub_1885BE5CC(_Unwind_Exception *a1)
{
  IIOString::~IIOString((IIOString *)(v1 - 120));
  _Unwind_Resume(a1);
}

uint64_t IIO_Reader::utType(IIO_Reader *this)
{
  return **((void **)this + 1);
}

CGImage *IIOImagePlus::createImage(IIOImagePlus *this, CGImageSource *a2, int *a3)
{
  uint64_t Source = CGImageSourceGetSource((uint64_t)a2);
  uint64_t v6 = *((void *)this + 5);
  if (!v6 || !*((void *)this + 6) || !*((void *)this + 9))
  {
    LogError("createImage", 1445, "*** ERROR: bad image size (%ld x %ld) rb: %ld\n", v6, *((void *)this + 6), *((void *)this + 9));
    float v10 = 0;
    int v11 = -67;
    goto LABEL_56;
  }
  float v7 = (IIOImageSource *)Source;
  float v8 = (void *)*((void *)this + 16);
  if (v8)
  {
    if (*((_DWORD *)this + 34))
    {
      int v9 = IIOImageSource::imageSourceType(v7);
      float v8 = (void *)*((void *)this + 16);
      if (v9 == 6)
      {
        if (CFGetRetainCount(v8) <= 1
          && (IIOImageSource::imageSourceType(v7) != 6
           || IIOImageSource::incrementalDataUpdated(v7)))
        {
          IIOImageSource::removeImageFromSet((uint64_t)v7, *((IIOImagePlus ***)this + 1), *((const void **)this + 16));
          *((void *)this + 16) = 0;
          *((unsigned char *)this + 192) &= ~0x40u;
          goto LABEL_14;
        }
        float v8 = (void *)*((void *)this + 16);
      }
    }
    float v10 = CGImageRetain((CGImageRef)v8);
    if (!v10)
    {
      int v11 = 0;
      goto LABEL_56;
    }
LABEL_55:
    int v11 = 0;
    *((void *)this + 16) = v10;
    goto LABEL_56;
  }
LABEL_14:
  uint64_t v12 = *((void *)this + 7);
  CFComparisonResult v13 = (CGColorSpace *)*((void *)this + 11);
  float v14 = *((float *)this + 24);
  int v15 = *((_DWORD *)this + 25);
  char v16 = *((unsigned char *)this + 108);
  int v17 = v15 | 0x100;
  if ((v16 & 1) == 0) {
    int v17 = *((_DWORD *)this + 25);
  }
  if ((*((unsigned char *)this + 109) & (v12 == 16)) != 0) {
    v17 |= 0x1000u;
  }
  if ((*((unsigned char *)this + 109) & (v12 == 32)) != 0) {
    int v18 = v17 | 0x2000;
  }
  else {
    int v18 = v17;
  }
  unsigned int v29 = v18;
  CGColorSpaceGetRenderingIntent();
  uint64_t v19 = 0;
  if (v12 > 15)
  {
    if (v12 == 16)
    {
      if (v16) {
        uint64_t v19 = 5;
      }
      else {
        uint64_t v19 = 2;
      }
      if (!v15) {
        goto LABEL_36;
      }
      goto LABEL_35;
    }
    if (v12 == 32)
    {
      if (v16) {
        uint64_t v19 = 4;
      }
      else {
        uint64_t v19 = 3;
      }
      if (!v15) {
        goto LABEL_36;
      }
      goto LABEL_35;
    }
  }
  else if (v12 == 8)
  {
    uint64_t v19 = 1;
  }
  else if (v12 == 10)
  {
    uint64_t v19 = 6;
    if (!v15) {
      goto LABEL_36;
    }
    goto LABEL_35;
  }
  if (v15) {
LABEL_35:
  }
    CGColorSpaceGetModel(v13);
LABEL_36:
  int v20 = (IIOImageReadSession *)CGImageSourceGetSource(*((void *)this + 3));
  if (IIOImageReadSession::isFinal(v20)) {
    *((_DWORD *)this + 34) = 0;
  }
  ImageProvider = IIOImagePlus::getImageProvider(this);
  if (ImageProvider)
  {
    unsigned int v22 = ImageProvider;
    CGImageProviderGetSize();
    if (v23 < 1.0 || v24 < 1.0 || v23 != (double)(unint64_t)v23 || v24 != (double)(unint64_t)v24) {
      LogError("createImage", 1550, "*** ERROR: CGImageProvider %p   size: %g x %g\n", v22, v23, v24);
    }
    float v10 = (CGImage *)CGImageCreateWithImageProvider();
    if (!v10)
    {
      IIOImagePlus::releaseImageProvider(this);
      LogError("createImage", 1575, "*** ERROR: CGImageCreateWithImageProvider failed\n");
      int v11 = -61;
      goto LABEL_56;
    }
    if (v14 <= 0.0)
    {
      uint64_t v25 = IIOImageSource::reader(v7);
      if (v25) {
        (*(void (**)(uint64_t, CGImage *, IIOImageReadSession *, CGColorSpace *, uint64_t, void))(*(void *)v25 + 128))(v25, v10, v20, v13, v19, v29);
      }
    }
    else
    {
      CGImageSetHeadroom();
    }
    IIOImagePlus::releaseImageProvider(this);
    *((unsigned char *)this + 192) |= 0x40u;
    *(void *)(**((void **)this + 30) + 8) = v10;
    if (*((void *)this + 23))
    {
      uint64_t CopyWithClipPath = CGImageCreateCopyWithClipPath();
      if (CopyWithClipPath)
      {
        int v27 = (CGImage *)CopyWithClipPath;
        CGImageRelease(v10);
        float v10 = v27;
      }
    }
    CGImageSetProperty();
    if (CGImageReadSessionGetFilePath(*((void *)this + 3))) {
      CGImageSetProperty();
    }
    goto LABEL_55;
  }
  _cg_jpeg_mem_term("createImage", 1541, "imageProvider is NULL\n");
  float v10 = 0;
  int v11 = -60;
LABEL_56:
  if (a3) {
    *a3 = v11;
  }
  return v10;
}

uint64_t IIOImageSource::reader(IIOImageSource *this)
{
  return *((void *)this + 13);
}

uint64_t IIOImageWriteSession::getSize(IIOImageWriteSession *this)
{
  return *((void *)this + 7);
}

const void *IIOImagePlus::getImageProvider(IIOImagePlus *this)
{
  if (*((void *)this + 18) == *MEMORY[0x1E4F1D260]) {
    uint64_t v1 = 0;
  }
  else {
    uint64_t v1 = (const void *)*((void *)this + 18);
  }
  if (v1)
  {
    CGImageProviderGetSize();
    if (v3 != (double)*((unint64_t *)this + 5)
      || ((double v5 = floor(v3), v4 == floor(v4)) ? (v6 = v3 == v5) : (v6 = 0),
          v6 ? (BOOL v7 = v4 == (double)*((unint64_t *)this + 6)) : (BOOL v7 = 0),
          !v7))
    {
      LogError("getImageProvider", 1056, "*** ERROR: imageProvider %p has illegal size: (%g, %g)\n", v1, v3, v4);
    }
  }
  return v1;
}

uint64_t CGImageReadSessionGetFilePath(uint64_t a1)
{
  if (a1 && (v1 = *(void *)(a1 + 24)) != 0 && (uint64_t v2 = *(IIOImageWriteSession **)(v1 + 32)) != 0) {
    return IIOImageWriteSession::getSize(v2);
  }
  else {
    return 0;
  }
}

uint64_t IIOImageSource::getImagePropertiesAtIndex(IIOImageSource *this, unint64_t a2)
{
  uint64_t v2 = *((void *)this + 18);
  uint64_t v3 = *((void *)this + 19);
  if ((v3 - v2) >> 3 > a2) {
    return *(void *)(v2 + 8 * a2);
  }
  if (v3 != v2) {
    _cg_jpeg_mem_term("getImagePropertiesAtIndex", 4042, "getImagePropertiesAtIndex index (%d) larger than vector size (%d)\n", a2, (v3 - v2) >> 3);
  }
  return 0;
}

void IIOImageSource::removeUnusedImages(CFSetRef *this)
{
  CFIndex Count = CFSetGetCount(this[23]);
  if (Count >= 2)
  {
    CFIndex v3 = Count;
    double v4 = (const void **)malloc_type_malloc(8 * Count, 0x2004093837F09uLL);
    if (v4)
    {
      double v5 = v4;
      uint64_t v16 = 0;
      CFSetGetValues(this[23], v4);
      AllImagePlusValues = IIOImageSource::getAllImagePlusValues(this, &v16);
      uint64_t v7 = 0;
      uint64_t v8 = v16;
      int v9 = (const void *)*MEMORY[0x1E4F1D260];
      do
      {
        float v10 = v5[v7];
        CFTypeID v11 = CFGetTypeID(v10);
        if (v11 == CGImageGetTypeID() && CFGetRetainCount(v10) == 1)
        {
          if (v8 >= 1)
          {
            uint64_t v12 = 0;
            while (1)
            {
              CFComparisonResult v13 = AllImagePlusValues[v12];
              if (v13 && v13 != v9)
              {
                int v15 = (IIOImagePlus *)*((void *)v13 + 3);
                if ((const void *)IIOImagePlus::getImage(v15) == v5[v7]) {
                  break;
                }
              }
              if (v8 == ++v12) {
                goto LABEL_16;
              }
            }
            IIOImagePlus::setRemoveCacheKey((uint64_t)v15, 1);
            IIOImagePlus::setImageIndex((uint64_t)v15, v12);
            IIOImageSource::setImagePlusAtIndex((uint64_t)this, 0, v12);
            AllImagePlusValues[v12] = v9;
          }
LABEL_16:
          CFSetRemoveValue(this[23], v5[v7]);
        }
        ++v7;
      }
      while (v7 != v3);
      if (AllImagePlusValues) {
        free(AllImagePlusValues);
      }
      free(v5);
    }
  }
}

uint64_t IIOImagePlus::shouldCacheImmediately(IIOImagePlus *this)
{
  return (*((unsigned __int8 *)this + 192) >> 2) & 1;
}

uint64_t IIOImagePlus::getSubsampleFactor(IIOImagePlus *this)
{
  return *((unsigned int *)this + 49);
}

uint64_t IIOImagePlus::readPlugin(IIOImagePlus *this)
{
  return *((void *)this + 21);
}

uint64_t IIO_Reader::callGetImageCount(const void ***a1, uint64_t a2, uint64_t a3, _DWORD *a4, _DWORD *a5)
{
  uint64_t Source = (IIO_Reader *)CGImageSourceGetSource(a2);
  float v10 = (IIOImageRead *)IIO_Reader::testHeaderSize(Source);
  CFTypeID v11 = v10;
  if (v10)
  {
    float v10 = (IIOImageRead *)IIOImageRead::forceUseServer(v10);
    char v12 = (char)v10;
  }
  else
  {
    char v12 = -1;
  }
  uint64_t IIOXPCClient = (IIOXPCClient *)IIOXPCClient::GetIIOXPCClient(v10);
  if (IIOXPCClient::useServerForImageCount((uint64_t)IIOXPCClient, v11, (uint64_t)a1, v12))
  {
    kdebug_trace();
    xpc_object_t v14 = xpc_dictionary_create(0, 0, 0);
    if (!v14)
    {
      LODWORD(a3) = 0;
      uint64_t uint64 = 1;
      goto LABEL_73;
    }
    int v15 = v14;
    int v73 = 0;
    xpc_object_t v16 = iio_xpc_add_source_dict(v14);
    xpc_object_t v17 = iio_xpc_add_plugin_dict(v15);
    xpc_dictionary_set_uint64(v15, "iio_xpc_message_id", 2uLL);
    memset(v72, 0, sizeof(v72));
    IIOString::IIOString((IIOString *)v72, *a1[1]);
    int v18 = (const char *)IIOString::utf8String((IIOString *)v72);
    xpc_dictionary_set_string(v16, "iio_xpc_src_utitype", v18);
    xpc_dictionary_set_uint64(v16, "iio_xpc_src_ostype", *((unsigned int *)a1 + 6));
    IIOImageReadSession::addDataToXPCDictionary(Source, v15, &v73);
    iio_xpc_dictionary_add_CFDictionary(v16, "iio_xpc_src_options");
    CFDataRef v19 = (const __CFData *)((uint64_t (*)(const void ***, IIO_Reader *))(*a1)[13])(a1, Source);
    if (v19)
    {
      iio_xpc_dictionary_add_GlobalInfo(v17, v19, *((_DWORD *)a1 + 6));
      CFRelease(v19);
    }
    int v20 = (_xpc_connection_s *)IIOXPCClient::xpc_connection(IIOXPCClient);
    unsigned int v21 = (dispatch_queue_s *)IIOXPCClient::xpc_queue(IIOXPCClient);
    xpc_object_t v22 = IIOXPCClient::send_message_with_reply(IIOXPCClient, v20, v21, v15);
    double v23 = v22;
    if (!v22)
    {
      IIOXPCLog(" ImageIOXPC: XPC_READPLUGIN_IMAGECOUNT error null-reply\n");
      LODWORD(a3) = 0;
      uint64_t uint64 = 1;
      goto LABEL_69;
    }
    xpc_object_t message_dict = iio_xpc_get_message_dict(v22);
    xpc_object_t source_dict = iio_xpc_get_source_dict(v23);
    uint64_t error_code = iio_xpc_dictionary_get_error_code(message_dict);
    a3 = error_code;
    if (!error_code)
    {
      if (source_dict)
      {
        xpc_object_t plugin_dict = iio_xpc_get_plugin_dict(v23);
        uint64_t uint64 = xpc_dictionary_get_uint64(source_dict, "iio_xpc_src_image_count");
        int v33 = *((_DWORD *)a1 + 6);
        unsigned int v34 = v33 >> 24;
        if (v33 < 0)
        {
          int v35 = __maskrune(v34, 0x40000uLL);
          int v33 = *((_DWORD *)a1 + 6);
        }
        else
        {
          int v35 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v34 + 60) & 0x40000;
        }
        LODWORD(v57) = v33 >> 24;
        if (v35) {
          uint64_t v57 = v57;
        }
        else {
          uint64_t v57 = 46;
        }
        uint64_t v69 = v57;
        unsigned int v58 = v33 << 8 >> 24;
        if (v33 << 8 < 0)
        {
          int v59 = __maskrune(v58, 0x40000uLL);
          int v33 = *((_DWORD *)a1 + 6);
        }
        else
        {
          int v59 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v58 + 60) & 0x40000;
        }
        LODWORD(v60) = v33 << 8 >> 24;
        if (v59) {
          uint64_t v60 = v60;
        }
        else {
          uint64_t v60 = 46;
        }
        uint64_t v68 = v60;
        unsigned int v61 = (__int16)v33 >> 8;
        if (v33 << 16 < 0)
        {
          int v62 = __maskrune(v61, 0x40000uLL);
          int v33 = *((_DWORD *)a1 + 6);
        }
        else
        {
          int v62 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v61 + 60) & 0x40000;
        }
        LODWORD(v63) = (__int16)v33 >> 8;
        if (v62) {
          uint64_t v63 = v63;
        }
        else {
          uint64_t v63 = 46;
        }
        uint64_t v67 = v63;
        if ((v33 << 24) <= 0x7F000000) {
          int v64 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * (char)v33 + 60) & 0x40000;
        }
        else {
          int v64 = __maskrune((char)v33, 0x40000uLL);
        }
        if (v64) {
          uint64_t v65 = *((char *)a1 + 24);
        }
        else {
          uint64_t v65 = 46;
        }
        IIOXPCLog(" ImageIOXPC [%c%c%c%c]: XPC_READPLUGIN_IMAGECOUNT: %d\n", v69, v68, v67, v65, uint64);
        *a4 = xpc_dictionary_get_int64(source_dict, "iio_xpc_src_status");
        if (plugin_dict)
        {
          uint64_t v71 = 0;
          xpc_object_t GlobalInfo = iio_xpc_dictionary_get_GlobalInfo(plugin_dict, &v71);
          if (v71) {
            ((void (*)(const void ***, IIO_Reader *, xpc_object_t))(*a1)[12])(a1, Source, GlobalInfo);
          }
        }
        goto LABEL_68;
      }
LABEL_67:
      uint64_t uint64 = 1;
LABEL_68:
      _cg_jpeg_mem_term(IIOXPCClient, v23, v27);
      xpc_release(v23);
LABEL_69:
      if (Source && v73) {
        IIOImageReadSession::releaseBytePointer((IIOImageRead **)Source, v73);
      }
      xpc_release(v15);
      IIOString::~IIOString((IIOString *)v72);
LABEL_73:
      kdebug_trace();
      if (!a5) {
        return uint64;
      }
      goto LABEL_14;
    }
    if (error_code == -1400)
    {
      int v28 = *((_DWORD *)a1 + 6);
      unsigned int v29 = v28 >> 24;
      if (v28 < 0)
      {
        int v30 = __maskrune(v29, 0x40000uLL);
        int v28 = *((_DWORD *)a1 + 6);
      }
      else
      {
        int v30 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v29 + 60) & 0x40000;
      }
      if (v30) {
        uint64_t v40 = (v28 >> 24);
      }
      else {
        uint64_t v40 = 46;
      }
      unsigned int v41 = v28 << 8 >> 24;
      if (v28 << 8 < 0)
      {
        int v42 = __maskrune(v41, 0x40000uLL);
        int v28 = *((_DWORD *)a1 + 6);
      }
      else
      {
        int v42 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v41 + 60) & 0x40000;
      }
      if (v42) {
        uint64_t v46 = (v28 << 8 >> 24);
      }
      else {
        uint64_t v46 = 46;
      }
      unsigned int v47 = (__int16)v28 >> 8;
      if (v28 << 16 < 0)
      {
        int v48 = __maskrune(v47, 0x40000uLL);
        int v28 = *((_DWORD *)a1 + 6);
      }
      else
      {
        int v48 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v47 + 60) & 0x40000;
      }
      if (v48) {
        uint64_t v53 = ((__int16)v28 >> 8);
      }
      else {
        uint64_t v53 = 46;
      }
      if ((v28 << 24) <= 0x7F000000)
      {
        if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * (char)v28 + 60) & 0x40000) != 0) {
          goto LABEL_53;
        }
      }
      else if (__maskrune((char)v28, 0x40000uLL))
      {
LABEL_53:
        uint64_t v54 = *((char *)a1 + 24);
LABEL_56:
        IIOXPCLog(" ImageIOXPC [%c%c%c%c]: XPC_READPLUGIN_IMAGECOUNT XPC connection interrupted\n", v40, v46, v53, v54);
        goto LABEL_67;
      }
      uint64_t v54 = 46;
      goto LABEL_56;
    }
    int v36 = *((_DWORD *)a1 + 6);
    unsigned int v37 = v36 >> 24;
    uint64_t v38 = MEMORY[0x1E4F14390];
    if (v36 < 0)
    {
      int v39 = __maskrune(v37, 0x40000uLL);
      int v36 = *((_DWORD *)a1 + 6);
    }
    else
    {
      int v39 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v37 + 60) & 0x40000;
    }
    if (v39) {
      uint64_t v43 = (v36 >> 24);
    }
    else {
      uint64_t v43 = 46;
    }
    unsigned int v44 = v36 << 8 >> 24;
    if (v36 << 8 < 0)
    {
      int v45 = __maskrune(v44, 0x40000uLL);
      int v36 = *((_DWORD *)a1 + 6);
    }
    else
    {
      int v45 = *(_DWORD *)(v38 + 4 * v44 + 60) & 0x40000;
    }
    if (v45) {
      uint64_t v49 = (v36 << 8 >> 24);
    }
    else {
      uint64_t v49 = 46;
    }
    unsigned int v50 = (__int16)v36 >> 8;
    if (v36 << 16 < 0)
    {
      int v52 = __maskrune(v50, 0x40000uLL);
      uint64_t v51 = v38;
      int v36 = *((_DWORD *)a1 + 6);
    }
    else
    {
      uint64_t v51 = v38;
      int v52 = *(_DWORD *)(v38 + 4 * v50 + 60) & 0x40000;
    }
    if (v52) {
      uint64_t v55 = ((__int16)v36 >> 8);
    }
    else {
      uint64_t v55 = 46;
    }
    if ((v36 << 24) <= 0x7F000000)
    {
      if ((*(_DWORD *)(v51 + 4 * (char)v36 + 60) & 0x40000) != 0) {
        goto LABEL_63;
      }
    }
    else if (__maskrune((char)v36, 0x40000uLL))
    {
LABEL_63:
      uint64_t v56 = *((char *)a1 + 24);
LABEL_66:
      IIOXPCLog(" ImageIOXPC [%c%c%c%c]: XPC_READPLUGIN_IMAGECOUNT error: %lld\n", v43, v49, v55, v56, a3);
      goto LABEL_67;
    }
    uint64_t v56 = 46;
    goto LABEL_66;
  }
  LODWORD(v72[0]) = 0;
  ((void (*)(const void ***, IIO_Reader *, uint64_t, _DWORD *, void **))(*a1)[4])(a1, Source, a3, a4, v72);
  uint64_t uint64 = LODWORD(v72[0]);
  LODWORD(a3) = 0;
  if (a5) {
LABEL_14:
  }
    *a5 = a3;
  return uint64;
}

void sub_1885BF3AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  IIOString::~IIOString((IIOString *)va);
  _Unwind_Resume(a1);
}

uint64_t IIOImageRead::forceUseServer(IIOImageRead *this)
{
  return *((char *)this + 456);
}

uint64_t IIOXPCClient::useServerForImageCount(uint64_t a1, IIOImageRead *a2, uint64_t a3, int a4)
{
  return IIOXPCClient::useServerForCall(a1, a2, a3, a4, 2, 1);
}

uint64_t IIOXPCClient::useServerForDecodeImage(uint64_t a1, IIOImageRead *a2, uint64_t a3, int a4)
{
  return IIOXPCClient::useServerForCall(a1, a2, a3, a4, 6, 1);
}

uint64_t IIO_Reader_PNG::getImageCount(IIO_Reader_PNG *this, IIOImageReadSession *a2, IIODictionary *a3, CGImageSourceStatus *a4, unsigned int *a5)
{
  v37[1] = *MEMORY[0x1E4F143B8];
  v37[0] = 0;
  unint64_t Size = IIOImageReadSession::getSize(a2);
  if (IIOImageReadSession::getBytesAtOffset(a2, v37, 8uLL, 8uLL) != 8) {
    goto LABEL_13;
  }
  unint64_t v6 = 0;
  char v7 = 0;
  unsigned int v8 = 0;
  unsigned int v35 = 0;
  unint64_t v9 = 8;
  while (1)
  {
    unsigned int v10 = bswap32(v37[0]);
    unsigned int v11 = bswap32(HIDWORD(v37[0]));
    if (v11 == 1229209940)
    {
      unint64_t v12 = 1;
      if (v6) {
        goto LABEL_14;
      }
      goto LABEL_12;
    }
    if (v11 == 1229472850)
    {
      if (v7)
      {
        _cg_jpeg_mem_term("getImageCount", 296, "*** ERROR: bad PNG - multiple 'IHDR' chunks in PNG are not allowed\n");
        goto LABEL_20;
      }
      if (IIOImageReadSession::getBytesAtOffset(a2, v37, v9 + 8, 8uLL) != 8) {
        goto LABEL_13;
      }
      unsigned int v35 = bswap32(v37[0]);
      unsigned int v8 = bswap32(HIDWORD(v37[0]));
      char v7 = 1;
      goto LABEL_10;
    }
    if (v11 == 1633899596) {
      break;
    }
LABEL_10:
    unint64_t v12 = v6;
LABEL_12:
    v9 += v10 + 12;
    unint64_t v6 = v12;
    if (IIOImageReadSession::getBytesAtOffset(a2, v37, v9, 8uLL) != 8) {
      goto LABEL_13;
    }
  }
  if (v6)
  {
    _cg_jpeg_mem_term("getImageCount", 319, "*** ERROR: bad 'acTL' chunk (after 'IDAT')\n");
    goto LABEL_20;
  }
  if (IIOImageReadSession::getBytesAtOffset(a2, v37, v9 + 8, 8uLL) != 8)
  {
LABEL_13:
    LODWORD(v12) = 1;
    goto LABEL_14;
  }
  unint64_t v12 = bswap32(v37[0]);
  if (v12 > (unint64_t)Size / 0x22)
  {
LABEL_20:
    LODWORD(v12) = 0;
    goto LABEL_14;
  }
  unsigned int v14 = HIDWORD(v37[0]);
  int v15 = IIOImageReadSession::globalInfoForType(a2, 1095781959);
  xpc_object_t v16 = v15;
  if (!v15) {
    operator new();
  }
  std::vector<fcTL_CHUNK>::resize((uint64_t)v15 + 8, 0);
  *((_DWORD *)v16 + 10) = v12;
  *((_DWORD *)v16 + 11) = bswap32(v14);
  std::vector<fcTL_CHUNK>::resize((uint64_t)v16 + 8, v12);
  uint64_t v17 = 0;
  uint64_t v32 = 0;
  unsigned int v18 = 0;
  unsigned int v19 = 0;
  *((_DWORD *)v16 + 8) = v35;
  *((_DWORD *)v16 + 9) = v8;
  unint64_t v20 = v9 + v10 + 12;
  memset(v36, 0, 34);
  while (2)
  {
    if (v12 <= v19) {
      goto LABEL_51;
    }
    if (IIOImageReadSession::getBytesAtOffset(a2, v37, v20, 8uLL) != 8)
    {
      ++v19;
      unsigned int v18 = v12;
      goto LABEL_41;
    }
    unsigned int v21 = v37[0];
    unsigned int v22 = bswap32(HIDWORD(v37[0]));
    if (v22 == 1717846356)
    {
      ++v32;
      goto LABEL_40;
    }
    if (v22 != 1717785676) {
      goto LABEL_40;
    }
    IIOImageReadSession::getBytesAtOffset(a2, v36, v20 + 8, 0x22uLL);
    ++v17;
    *(void *)((char *)&v36[1] + 10) = v20;
    unint64_t v23 = bswap32(v36[0]);
    LODWORD(v36[0]) = v23;
    if (v17 + v32 > v23)
    {
      int v24 = bswap32(DWORD1(v36[0]));
      int v25 = bswap32(DWORD2(v36[0]));
      *(void *)((char *)v36 + 4) = __PAIR64__(v25, v24);
      unsigned int v26 = bswap32(HIDWORD(v36[0]));
      unsigned int v27 = bswap32(v36[1]);
      HIDWORD(v36[0]) = v26;
      LODWORD(v36[1]) = v27;
      WORD2(v36[1]) = bswap32(WORD2(v36[1])) >> 16;
      int v28 = WORD3(v36[1]);
      WORD3(v36[1]) = __rev16(WORD3(v36[1]));
      if ((v26 & 0x80000000) != 0 || (v27 & 0x80000000) != 0 || v24 < 1 || v25 < 1 || v26 + v24 > v35 || v27 + v25 > v8)
      {
        if (v18) {
          LODWORD(v12) = v18 - 1;
        }
        else {
          LODWORD(v12) = 0;
        }
        _cg_jpeg_mem_term("getImageCount", 420, "*** bad dimensions: PNG: %dx%d\n", v35, v8);
        _cg_jpeg_mem_term("getImageCount", 421, "    frame[%d]: {%d, %d, %d, %d}\n", v12, HIDWORD(v36[0]), LODWORD(v36[1]), DWORD1(v36[0]), DWORD2(v36[0]));
        goto LABEL_49;
      }
      if (!v28) {
        strcpy((char *)&v36[1] + 6, "d");
      }
      uint64_t v29 = *((void *)v16 + 1) + 34 * v18;
      long long v30 = v36[0];
      long long v31 = v36[1];
      *(_WORD *)(v29 + 32) = v36[2];
      *(_OWORD *)uint64_t v29 = v30;
      *(_OWORD *)(v29 + 16) = v31;
      ++v18;
      ++v19;
LABEL_40:
      v20 += bswap32(v21) + 12;
LABEL_41:
      if (v20 > (unint64_t)Size)
      {
        if (v18) {
          LODWORD(v12) = v18 - 1;
        }
        else {
          LODWORD(v12) = 0;
        }
LABEL_49:
        *((_DWORD *)v16 + 10) = v12;
        goto LABEL_14;
      }
      continue;
    }
    break;
  }
  _cg_jpeg_mem_term("getImageCount", 384, "*** bad fcTL.sequence_number: %d/%d\n", v23, v12);
  *((_DWORD *)v16 + 10) = 1;
  std::vector<fcTL_CHUNK>::resize((uint64_t)v16 + 8, 1uLL);
  LODWORD(v12) = 1;
LABEL_51:
  if (v19 != v18)
  {
    _cg_jpeg_mem_term("getImageCount", 483, "frameLoop != fcTL_index (%d != %d) --> error while decoding frames\n", v19, v18);
    *((_DWORD *)v16 + 10) = v18;
  }
LABEL_14:
  if (a5) {
    *a5 = v12;
  }
  return 0;
}

void sub_1885BF8D4(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10B1C402BA5416ELL);
  _Unwind_Resume(a1);
}

uint64_t IIO_Reader_ASTC::getImageCount(IIO_Reader_ASTC *this, IIOImageReadSession *a2, IIODictionary *a3, CGImageSourceStatus *a4, unsigned int *a5)
{
  if (a5) {
    *a5 = 0;
  }
  int v16 = 0;
  unint64_t BytesAtOffset = (IIO_ReaderHandler *)IIOImageReadSession::getBytesAtOffset(a2, &v16, 0, 4uLL);
  if (BytesAtOffset == (IIO_ReaderHandler *)4 && v16 == 1554098963)
  {
    uint64_t result = 0;
    if (a5) {
      *a5 = 1;
    }
  }
  else
  {
    unint64_t v12 = (__CFString **)*((void *)this + 1);
    if (v12 == kCGImageTypeIdentifierKTX)
    {
      ReaderHandler = (IIO_ReaderHandler *)IIO_ReaderHandler::GetReaderHandler(BytesAtOffset);
      int v14 = 1263818784;
    }
    else
    {
      if (v12 != kCGImageTypeIdentifierKTX2) {
        return 4294967246;
      }
      ReaderHandler = (IIO_ReaderHandler *)IIO_ReaderHandler::GetReaderHandler(BytesAtOffset);
      int v14 = 1263818802;
    }
    int v15 = IIO_ReaderHandler::readerForType(ReaderHandler, v14);
    return (*(uint64_t (**)(IIO_Reader *, IIOImageReadSession *, IIODictionary *, CGImageSourceStatus *, unsigned int *))(*(void *)v15 + 32))(v15, a2, a3, a4, a5);
  }
  return result;
}

void ASTCReadPlugin::addImageTypeIdentifier(ASTCReadPlugin *this, CGImage *a2, const __CFString *a3, int a4)
{
  if (*((unsigned char *)this + 504))
  {
    CGImageSetProperty();
    IIOString::IIOString((IIOString *)v6, 0x4B545820u);
  }
  else
  {
    CGImageSetProperty();
    IIOString::IIOString((IIOString *)v6, *((_DWORD *)this + 51));
  }
  CGImageSetProperty();
  IIOString::~IIOString((IIOString *)v6);
  IIONumber::IIONumber((IIONumber *)v6, a4);
  CGImageSetProperty();
  IIONumber::~IIONumber((IIONumber *)v6);
}

void sub_1885BFB18(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  IIOString::~IIOString((IIOString *)va);
  _Unwind_Resume(a1);
}

uint64_t IIOImageSource::cacheImmediately(IIOImageSource *this, unint64_t a2, IIODictionary *a3, CGImage *a4)
{
  uint64_t result = CGImageGetImageProvider();
  if (result)
  {
    uint64_t result = IIOReadPluginFromImageProvider();
    if (result)
    {
      double v5 = *(uint64_t (**)(void))(*(void *)result + 160);
      return v5();
    }
  }
  return result;
}

void IIOReadPlugin::cacheImmediately(IIOReadPlugin *this, const __CFDictionary *a2, CGImageRef image)
{
  size_t Width = CGImageGetWidth(image);
  size_t Height = CGImageGetHeight(image);
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  ColorSpace = CGImageGetColorSpace(image);
  CGColorSpaceModel Model = CGColorSpaceGetModel(ColorSpace);
  xpc_object_t value = 0;
  double Current = CFAbsoluteTimeGetCurrent();
  unint64_t v12 = (const void **)MEMORY[0x1E4F1CFD0];
  if (Model == kCGColorSpaceModelRGB)
  {
    CFComparisonResult v13 = (const void *)*MEMORY[0x1E4F1DD38];
    if (a2 && CFDictionaryGetValueIfPresent(a2, (const void *)*MEMORY[0x1E4F1DD38], (const void **)&value))
    {
      CFDictionaryAddValue(Mutable, v13, value);
      goto LABEL_7;
    }
    CFDictionaryAddValue(Mutable, v13, (const void *)*MEMORY[0x1E4F1DD30]);
  }
  if (!a2)
  {
    unsigned int v22 = (__CFString *)*MEMORY[0x1E4F1DD48];
    unint64_t v20 = (void *)*v12;
    unsigned int v21 = Mutable;
    goto LABEL_21;
  }
LABEL_7:
  int v14 = (const void *)*MEMORY[0x1E4F1DD18];
  if (CFDictionaryGetValueIfPresent(a2, (const void *)*MEMORY[0x1E4F1DD18], (const void **)&value)) {
    CFDictionaryAddValue(Mutable, v14, value);
  }
  int v15 = (const void *)*MEMORY[0x1E4F1DD20];
  if (CFDictionaryGetValueIfPresent(a2, (const void *)*MEMORY[0x1E4F1DD20], (const void **)&value)) {
    CFDictionaryAddValue(Mutable, v15, value);
  }
  int v16 = (const void *)*MEMORY[0x1E4F1DD48];
  if (CFDictionaryGetValueIfPresent(a2, (const void *)*MEMORY[0x1E4F1DD48], (const void **)&value)) {
    uint64_t v17 = value;
  }
  else {
    uint64_t v17 = (void *)*v12;
  }
  CFDictionaryAddValue(Mutable, v16, v17);
  unsigned int v18 = (const void *)*MEMORY[0x1E4F1DD28];
  if (CFDictionaryGetValueIfPresent(a2, (const void *)*MEMORY[0x1E4F1DD28], (const void **)&value)) {
    CFDictionaryAddValue(Mutable, v18, value);
  }
  unsigned int v19 = (const void *)*MEMORY[0x1E4F1DD40];
  if (CFDictionaryGetValueIfPresent(a2, (const void *)*MEMORY[0x1E4F1DD40], (const void **)&value)) {
    CFDictionaryAddValue(Mutable, v19, value);
  }
  if (CFDictionaryGetValueIfPresent(a2, @"kCGImageBlockIOSurfaceOptimizedRequest", (const void **)&value))
  {
    unint64_t v20 = value;
    unsigned int v21 = Mutable;
    unsigned int v22 = @"kCGImageBlockIOSurfaceOptimizedRequest";
LABEL_21:
    CFDictionaryAddValue(v21, v22, v20);
  }
  CFDictionaryAddValue(Mutable, @"kCGImageBlockPreHeating", *v12);
  if ((gIIODebugFlags & 0x300) == 0x100 || (gIIODebugFlags & 0x400000000000) != 0) {
    ImageIOLog("::: pre-caching:     rect=(%5g, %5g, %5g, %5g)\n", 0.0, 0.0, (double)Width, (double)Height);
  }
  if (IIOReadPlugin::cacheImmediately(__CFDictionary const*,CGImage *)::onceToken != -1) {
    dispatch_once(&IIOReadPlugin::cacheImmediately(__CFDictionary const*,CGImage *)::onceToken, &__block_literal_global_174);
  }
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 0x40000000;
  block[2] = ___ZN13IIOReadPlugin16cacheImmediatelyEPK14__CFDictionaryP7CGImage_block_invoke_2;
  block[3] = &__block_descriptor_tmp_176;
  block[4] = this;
  block[5] = image;
  block[6] = 0;
  block[7] = 0;
  *(double *)&block[8] = (double)Width;
  *(double *)&block[9] = (double)Height;
  *(double *)&block[10] = (double)Width;
  *(double *)&void block[11] = (double)Height;
  block[12] = Mutable;
  dispatch_sync((dispatch_queue_t)IIOReadPlugin::cacheImmediately(__CFDictionary const*,CGImage *)::cacheQueue, block);
  CFRelease(Mutable);
  double v24 = CFAbsoluteTimeGetCurrent();
  if ((gIIODebugFlags & 0xC) != 0)
  {
    double v25 = v24;
    int v26 = *((_DWORD *)this + 51);
    unsigned int v27 = v26 >> 24;
    uint64_t v28 = MEMORY[0x1E4F14390];
    if (v26 < 0) {
      int v29 = __maskrune(v26 >> 24, 0x40000uLL);
    }
    else {
      int v29 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v27 + 60) & 0x40000;
    }
    if (v29) {
      uint64_t v30 = v27;
    }
    else {
      uint64_t v30 = 46;
    }
    unsigned int v31 = v26 << 8 >> 24;
    if (v26 << 8 < 0) {
      int v32 = __maskrune(v26 << 8 >> 24, 0x40000uLL);
    }
    else {
      int v32 = *(_DWORD *)(v28 + 4 * v31 + 60) & 0x40000;
    }
    if (v32) {
      uint64_t v33 = v31;
    }
    else {
      uint64_t v33 = 46;
    }
    unsigned int v34 = (__int16)v26 >> 8;
    if (v26 << 16 < 0) {
      int v35 = __maskrune((__int16)v26 >> 8, 0x40000uLL);
    }
    else {
      int v35 = *(_DWORD *)(v28 + 4 * v34 + 60) & 0x40000;
    }
    if (v35) {
      uint64_t v36 = v34;
    }
    else {
      uint64_t v36 = 46;
    }
    if ((v26 << 24) <= 0x7F000000) {
      int v37 = *(_DWORD *)(v28 + 4 * (char)v26 + 60) & 0x40000;
    }
    else {
      int v37 = __maskrune((char)v26, 0x40000uLL);
    }
    if (v37) {
      uint64_t v38 = (char)v26;
    }
    else {
      uint64_t v38 = 46;
    }
    ImageIOLog("    '%c%c%c%c' cacheImmediately\ttime: %g ms\n", v30, v33, v36, v38, (v25 - Current) * 1000.0);
  }
}

uint64_t IIOReadPluginFromImageProvider()
{
  CFAllocatorRef v0 = *(IIOImagePlus **)CGImageProviderGetInfo();

  return IIOImagePlus::getMetadata(v0);
}

void IIOImageProviderInfo::ReleaseInfo(IIOImageProviderInfo *this, void *a2)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  if (this)
  {
    if ((gIIODebugFlags & 0xC000) != 0)
    {
      *(_OWORD *)__str = 0u;
      long long v11 = 0u;
      CFIndex v3 = *(void **)this;
      if (*(void *)this) {
        CFIndex v3 = (void *)v3[2];
      }
      snprintf(__str, 0x20uLL, "(%p)", v3);
      if ((unsigned __int16)gIIODebugFlags >> 14) {
        ImageIODebugOptions((unsigned __int16)gIIODebugFlags >> 14, "S", "_CGImageProviderRelease", 0, __str, -1, 0);
      }
    }
    if (*(void *)this)
    {
      CFDataRef Property = (__CFArray *)CGImageProviderGetProperty();
      if (Property)
      {
        memset(__str, 0, sizeof(__str));
        *(void *)&long long v11 = 0;
        IIOArray::IIOArray((IIOArray *)__str, Property);
        for (unint64_t i = 0; i < IIOArray::getCount((IIOArray *)__str); ++i)
        {
          CFDictionaryRef ObjectAtIndex = IIOArray::getObjectAtIndex((IIOArray *)__str, i);
          memset(v9, 0, sizeof(v9));
          IIODictionary::IIODictionary((IIODictionary *)v9, ObjectAtIndex);
          unsigned int Uint32ForKey = IIODictionary::getUint32ForKey((IIODictionary *)v9, @"iosurface_plane_datasize");
          Uint64ForKedouble y = IIODictionary::getUint64ForKey((IIODictionary *)v9, @"iosurface_plane_baseAddress");
          if (Uint64ForKey)
          {
            if (Uint32ForKey) {
              _ImageIO_Free((unint64_t)Uint64ForKey, Uint32ForKey);
            }
          }
          IIODictionary::~IIODictionary((IIODictionary *)v9);
        }
        IIOArray::~IIOArray((IIOArray *)__str);
      }
      if (*(void *)this) {
        (*(void (**)(void))(**(void **)this + 8))(*(void *)this);
      }
    }
    free(this);
  }
}

void sub_1885C0228(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char a13)
{
}

void IIOImageProviderInfo::~IIOImageProviderInfo(IIOImageProviderInfo *this)
{
  IIOImageProviderInfo::~IIOImageProviderInfo(this);

  JUMPOUT(0x18C11C0E0);
}

{
  pthread_mutex_t *v2;
  double v3;
  char *v4;
  void (*v5)(void);

  *(void *)this = &unk_1ED4E4FB8;
  uint64_t v2 = (pthread_mutex_t *)((char *)this + 144);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 144));
  switch(*((_DWORD *)this + 52))
  {
    case 0:
    case 1:
      double v4 = (char *)this + 224;
      goto LABEL_6;
    case 2:
      double v4 = (char *)this + 232;
      goto LABEL_6;
    case 3:
      double v4 = (char *)this + 248;
LABEL_6:
      double v5 = *(void (**)(void))v4;
      *(void *)double v4 = 0;
      if (!v5) {
        goto LABEL_8;
      }
      v5(*((void *)this + 14));
      break;
    default:
      *(void *)&CFIndex v3 = _cg_jpeg_mem_term("~IIOImageProviderInfo", 1718, "*** unknown imageProvider callback version [%d]\n", *((_DWORD *)this + 52)).n128_u64[0];
LABEL_8:
      LogWarning("~IIOImageProviderInfo", 1731, "$$$ ImageProviderReleaseInfoCallback: cookie without releaseInfo - leaking\n", v3);
      break;
  }
  pthread_mutex_unlock(v2);
  pthread_mutex_destroy(v2);
}

void IIOReadPlugin::ReleaseInfo(IIOReadPlugin *this, void *a2)
{
  if (this)
  {
    CFIndex v3 = *(const void **)this;
    if (v3) {
      CFRelease(v3);
    }
    *(void *)this = 0;
    uint64_t v4 = *((void *)this + 1);
    if (v4) {
      (*(void (**)(uint64_t, void *))(*(void *)v4 + 8))(v4, a2);
    }
    free(this);
  }
}

void AppleJPEGReadPlugin::~AppleJPEGReadPlugin(AppleJPEGReadPlugin *this)
{
  AppleJPEGReadPlugin::~AppleJPEGReadPlugin(this);

  JUMPOUT(0x18C11C0E0);
}

{
  void *v2;
  uint64_t vars8;

  *(void *)this = &unk_1ED4E4A60;
  applejpeg_decode_destroy();
  *((void *)this + 63) = 0;
  uint64_t v2 = (void *)*((void *)this + 79);
  if (v2)
  {
    free(v2);
    *((void *)this + 79) = 0;
  }

  JPEGReadPlugin::~JPEGReadPlugin(this);
}

void IIOReadPlugin::~IIOReadPlugin(IIOReadPlugin *this)
{
  *(void *)this = &unk_1ED4DFDB8;
  if (*((unsigned char *)this + 40))
  {
    uint64_t v2 = *((void *)this + 4);
    if (!v2 || ((*(void (**)(uint64_t))(*(void *)v2 + 8))(v2), *((unsigned char *)this + 40)))
    {
      uint64_t v3 = *((void *)this + 3);
      if (v3) {
        (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
      }
    }
  }
  uint64_t v4 = (CGColorSpace *)*((void *)this + 20);
  if (v4)
  {
    CGColorSpaceRelease(v4);
    *((void *)this + 20) = 0;
  }
  double v5 = (const void *)*((void *)this + 21);
  if (v5)
  {
    CFRelease(v5);
    *((void *)this + 21) = 0;
  }
  unint64_t v6 = (void *)*((void *)this + 12);
  if (v6) {
    free(v6);
  }
  *((void *)this + 12) = 0;
  *((_DWORD *)this + 26) = 0;
  *(_OWORD *)((char *)this + 8) = 0u;
  *(_OWORD *)((char *)this + 24) = 0u;
  *((void *)this + 7) = 0;
  *((void *)this + 8) = 0;
  *((void *)this + 6) = 0;
  mach_port_name_t v7 = *((_DWORD *)this + 108);
  if (v7) {
    mach_port_deallocate(*MEMORY[0x1E4F14960], v7);
  }
}

{
  uint64_t vars8;

  IIOReadPlugin::~IIOReadPlugin(this);

  JUMPOUT(0x18C11C0E0);
}

void JPEGReadPlugin::~JPEGReadPlugin(JPEGReadPlugin *this)
{
  *(void *)this = &unk_1ED4E28E0;
  uint64_t v2 = (const void *)*((void *)this + 55);
  if (v2) {
    CFRelease(v2);
  }
  *((void *)this + 55) = 0;

  IIOReadPlugin::~IIOReadPlugin(this);
}

{
  uint64_t vars8;

  JPEGReadPlugin::~JPEGReadPlugin(this);

  JUMPOUT(0x18C11C0E0);
}

void PNGReadPlugin::~PNGReadPlugin(PNGReadPlugin *this)
{
  PNGReadPlugin::~PNGReadPlugin(this);

  JUMPOUT(0x18C11C0E0);
}

{
  void *v2;
  const void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1ED4E07B8;
  uint64_t v2 = (void *)*((void *)this + 61);
  if (v2)
  {
    free(v2);
    *((void *)this + 61) = 0;
  }
  uint64_t v3 = (const void *)*((void *)this + 63);
  if (v3)
  {
    CFRelease(v3);
    *((void *)this + 63) = 0;
  }

  IIOReadPlugin::~IIOReadPlugin(this);
}

void HEIFReadPlugin::~HEIFReadPlugin(HEIFReadPlugin *this)
{
  HEIFReadPlugin::~HEIFReadPlugin(this);

  JUMPOUT(0x18C11C0E0);
}

{
  const void *v2;
  uint64_t vars8;

  *(void *)this = &unk_1ED4E1188;
  uint64_t v2 = (const void *)*((void *)this + 65);
  if (v2) {
    CFRelease(v2);
  }

  IIOReadPlugin::~IIOReadPlugin(this);
}

void ASTCReadPlugin::~ASTCReadPlugin(ASTCReadPlugin *this)
{
  *(void *)this = &unk_1ED4E0EB0;
  CommonASTCReadPlugin::~CommonASTCReadPlugin(this);

  JUMPOUT(0x18C11C0E0);
}

{
  *(void *)this = &unk_1ED4E0EB0;
  CommonASTCReadPlugin::~CommonASTCReadPlugin(this);
}

void CommonASTCReadPlugin::~CommonASTCReadPlugin(CommonASTCReadPlugin *this)
{
  *(void *)this = &unk_1ED4E4E90;
  uint64_t v2 = (const void *)*((void *)this + 58);
  if (v2) {
    CFRelease(v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 60);
  if (v3) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v3);
  }

  IIOReadPlugin::~IIOReadPlugin(this);
}

{
  uint64_t vars8;

  CommonASTCReadPlugin::~CommonASTCReadPlugin(this);

  JUMPOUT(0x18C11C0E0);
}

void ATXReadPlugin::~ATXReadPlugin(ATXReadPlugin *this)
{
  *(void *)this = &unk_1ED4DF4E0;
  CommonASTCReadPlugin::~CommonASTCReadPlugin(this);

  JUMPOUT(0x18C11C0E0);
}

{
  *(void *)this = &unk_1ED4DF4E0;
  CommonASTCReadPlugin::~CommonASTCReadPlugin(this);
}

void _providerRelease(CGDataProvider *a1)
{
  CGDataProviderReleaseBytePtr();

  CGDataProviderRelease(a1);
}

IIO_Reader *IIO_ReaderHandler::typeForData(IIO_Reader ***a1, CFDataRef theData, __CFString *a3, uint64_t a4, unsigned char *a5)
{
  if (theData)
  {
    if (a5) {
      *a5 = 1;
    }
    BytePtr = CFDataGetBytePtr(theData);
    CFIndex Length = CFDataGetLength(theData);
    long long v13 = *(_OWORD *)a4;
    uint64_t v14 = *(void *)(a4 + 16);
    uint64_t result = IIO_ReaderHandler::typeForBytes(a1, (uint64_t)BytePtr, Length, a3, &v13);
    if (a5)
    {
      if (result) {
        *a5 = 0;
      }
    }
  }
  else
  {
    LogError("typeForData", 706, "*** ERROR: data parameter is nil\n");
    return 0;
  }
  return result;
}

IIO_Reader *IIO_ReaderHandler::typeForBytes(IIO_Reader ***a1, uint64_t a2, unint64_t a3, __CFString *a4, long long *a5)
{
  int v8 = 0;
  long long v6 = *a5;
  uint64_t v7 = *((void *)a5 + 2);
  uint64_t result = IIO_ReaderHandler::readerForBytesImp(a1, a2, a3, a4, a3, (unint64_t *)&v6, 0, &v8);
  if (result) {
    return (IIO_Reader *)IIO_Reader::utType(result);
  }
  return result;
}

CFStringRef createNamespacePrefixForNamespace(const __CFString *a1)
{
  __p[0] = 0;
  __p[1] = 0;
  uint64_t v11 = 0;
  if (!a1) {
    return 0;
  }
  IIOString::IIOString((IIOString *)&range, a1);
  UTF8String = (XMPMeta *)IIOString::createUTF8String((IIOString *)&range);
  IIOString::~IIOString((IIOString *)&range);
  if (!UTF8String) {
    return 0;
  }
  if (TXMPMeta<std::string>::GetNamespacePrefix(UTF8String, (uint64_t)__p)
    && ((v2 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80], v11 >= 0) ? (uint64_t v3 = __p) : (uint64_t v3 = (void **)__p[0]),
        CFStringRef v4 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const char *)v3, 0x8000100u),
        (CFStringRef v5 = v4) != 0))
  {
    range.location = 0;
    range.CFIndex length = 0;
    v12.CFIndex length = CFStringGetLength(v4);
    v12.location = 0;
    if (CFStringFindWithOptions(v5, @":", v12, 0, &range))
    {
      v13.CFIndex length = range.location;
      v13.location = 0;
      CFStringRef Copy = CFStringCreateWithSubstring(v2, v5, v13);
    }
    else
    {
      CFStringRef Copy = CFStringCreateCopy(v2, v5);
    }
    CFStringRef v7 = Copy;
    CFRelease(v5);
  }
  else
  {
    CFStringRef v7 = 0;
  }
  free(UTF8String);
  if (SHIBYTE(v11) < 0) {
    operator delete(__p[0]);
  }
  return v7;
}

void sub_1885C0AF0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t CreateMetadataFromXMPBufferInternal(const char *a1, uint64_t a2, const char *a3)
{
  if (a1 && a2)
  {
    pthread_mutex_lock(&CreateMetadataFromXMPBufferInternal(char const*,unsigned long,char const*,unsigned long,unsigned int)::mutex);
    CFRange v12 = 0;
    uint64_t v13 = 0;
    uint64_t v14 = 0;
    unint64_t v9 = 0;
    uint64_t v10 = 0;
    uint64_t v11 = 0;
    cStr = 0;
    uint64_t v7 = 0;
    uint64_t v8 = 0;
    int v5 = 0;
    if (IIO_InitializeXMPToolkit())
    {
      v4[0] = 0;
      v4[1] = 0;
      TXMPMeta<std::string>::TXMPMeta(v4);
    }
    pthread_mutex_unlock(&CreateMetadataFromXMPBufferInternal(char const*,unsigned long,char const*,unsigned long,unsigned int)::mutex);
    if (SHIBYTE(v8) < 0) {
      operator delete(cStr);
    }
    if (SHIBYTE(v11) < 0) {
      operator delete(v9);
    }
    if (SHIBYTE(v14) < 0) {
      operator delete(v12);
    }
  }
  return 0;
}

#error "1885C16B4: call analysis failed (funcsize=52)"

void sub_1885C16FC(_Unwind_Exception *a1)
{
}

void CGImageMetadataTagKeyRelease(void *a1)
{
  if (atomic_fetch_add((atomic_uint *volatile)a1 + 4, 0xFFFFFFFF) == 1)
  {
    CFAllocatorRef v2 = *(const void **)a1;
    if (v2) {
      CFRelease(v2);
    }
    uint64_t v3 = (const void *)*((void *)a1 + 1);
    if (v3) {
      CFRelease(v3);
    }
    free(a1);
  }
}

BOOL TXMPIterator<std::string>::Next(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5)
{
  uint64_t v9 = 0;
  memset(v8, 0, sizeof(v8));
  WXMPIterator_Next_1(*(void **)(a1 + 8), a2, a3, a4, a5, (void (*)(uint64_t, uint64_t, void))TXMPIterator<std::string>::SetClientString, (uint64_t)v8);
  if (*(void *)&v8[0])
  {
    exception = __cxa_allocate_exception(0x18uLL);
    uint64_t v7 = *(void *)&v8[0];
    *(_DWORD *)exception = v9;
    exception[1] = v7;
    *((unsigned char *)exception + 16) = 0;
  }
  return v9 != 0;
}

void WXMPIterator_Next_1(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5, void (*a6)(uint64_t, uint64_t, void), uint64_t a7)
{
  unint64_t v23 = (XMP_ReadWriteLock *)(a1 + 2);
  XMP_ReadWriteLock::Acquire((pthread_rwlock_t *)(a1 + 2), 1);
  *(void *)a7 = 0;
  uint64_t v22 = 0;
  unsigned int v21 = 0;
  uint64_t v20 = 0;
  unsigned int v19 = 0;
  uint64_t v17 = 0;
  uint64_t v18 = 0;
  if (!a5) {
    a5 = &v17;
  }
  uint64_t v14 = a1[29];
  if (!v14) {
    __assert_rtn("WXMPIterator_Next_1", "WXMPIterator.cpp", 140, "thiz->info.xmpObj != __null");
  }
  int v16 = (XMP_ReadWriteLock *)(v14 + 16);
  XMP_ReadWriteLock::Acquire((pthread_rwlock_t *)(v14 + 16), 0);
  int v15 = (*(uint64_t (**)(void *, uint64_t *, unsigned int *, uint64_t *, unsigned int *, uint64_t *, char *, uint64_t *, XMP_ReadWriteLock *, uint64_t))(*a1 + 16))(a1, &v22, &v21, &v20, &v19, &v18, (char *)&v17 + 4, a5, v16, v17);
  *(_DWORD *)(a7 + 32) = v15;
  if (v15)
  {
    if (a2) {
      a6(a2, v22, v21);
    }
    if (a3) {
      a6(a3, v20, v19);
    }
    if (a4) {
      a6(a4, v18, HIDWORD(v17));
    }
  }
  XMP_AutoLock::~XMP_AutoLock(&v16);
  XMP_AutoLock::~XMP_AutoLock(&v23);
}

void sub_1885C196C(void *a1, int a2)
{
  if (a2 == 3)
  {
    CFStringRef v4 = __cxa_begin_catch(a1);
    *(_DWORD *)(v2 + 32) = *(_DWORD *)v4;
    *(void *)(v2 + 8) = "XMP";
    int v5 = (const char *)*((void *)v4 + 1);
    if (!v5) {
      int v5 = "";
    }
  }
  else
  {
    long long v6 = __cxa_begin_catch(a1);
    if (a2 != 2)
    {
      *(_DWORD *)(v2 + 32) = 14;
      *(void *)uint64_t v2 = "Caught unknown exception";
      __cxa_end_catch();
LABEL_10:
      JUMPOUT(0x1885C1924);
    }
    *(_DWORD *)(v2 + 32) = 13;
    uint64_t v7 = (*(uint64_t (**)(void *))(*(void *)v6 + 16))(v6);
    int v5 = "";
    if (v7) {
      int v5 = (const char *)v7;
    }
  }
  *(void *)uint64_t v2 = v5;
  __cxa_end_catch();
  goto LABEL_10;
}

void sub_1885C1A40(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  XMP_AutoLock::~XMP_AutoLock((XMP_ReadWriteLock **)va);
  _Unwind_Resume(a1);
}

void TXMPIterator<std::string>::SetClientString()
{
}

uint64_t XMPIterator::Next(XMPIterator *this, const char **a2, unsigned int *a3, const char **a4, unsigned int *a5, const char **a6, unsigned int *a7, unsigned int *a8)
{
  if (*((void *)this + 33) == *((void *)this + 34)) {
    return 0;
  }
  int v16 = (XMPIterator *)((char *)this + 224);
  uint64_t result = (uint64_t)GetNextXMPNode((XMPIterator *)((char *)this + 224));
  if (result)
  {
    uint64_t v18 = result;
    if ((*((unsigned char *)v16 + 1) & 2) != 0)
    {
      while (1)
      {
        uint64_t v21 = *((void *)this + 33);
        if ((*(_DWORD *)v21 & 0x80000000) == 0 && *(void *)(v18 + 72) == *(void *)(v18 + 80)) {
          break;
        }
        *(unsigned char *)(v21 + 88) = 2;
        uint64_t result = (uint64_t)GetNextXMPNode(v16);
        uint64_t v18 = result;
        if (!result) {
          return result;
        }
      }
    }
    unsigned int v19 = (char *)this + 240;
    if (*((char *)this + 263) < 0) {
      unsigned int v19 = *(const char **)v19;
    }
    *a2 = v19;
    if (*((char *)this + 263) < 0) {
      uint64_t v20 = *((void *)this + 31);
    }
    else {
      LODWORD(v20) = *((unsigned __int8 *)this + 263);
    }
    *a3 = v20;
    *a8 = **((_DWORD **)this + 33);
    *a4 = "";
    *a5 = 0;
    *a6 = "";
    *a7 = 0;
    if ((*a8 & 0x80000000) == 0)
    {
      uint64_t v22 = *((void *)this + 33);
      unint64_t v23 = (const char *)(v22 + 8);
      if (*(char *)(v22 + 31) < 0) {
        unint64_t v23 = *(const char **)v23;
      }
      *a4 = v23;
      uint64_t v24 = *((void *)this + 33);
      if (*(char *)(v24 + 31) < 0) {
        uint64_t v25 = *(void *)(v24 + 16);
      }
      else {
        LODWORD(v25) = *(unsigned __int8 *)(v24 + 31);
      }
      *a5 = v25;
      if ((*((unsigned char *)v16 + 1) & 4) != 0)
      {
        *a4 = &v23[*(void *)(v24 + 32)];
        *a5 = v25 - *(_DWORD *)(*((void *)this + 33) + 32);
        XMP_Node::GetLocalURI((XMP_Node *)v18, a2, a3);
      }
      if ((*((unsigned char *)a8 + 1) & 0x1F) == 0)
      {
        int v26 = (const char *)(v18 + 40);
        if (*(char *)(v18 + 63) < 0) {
          int v26 = *(const char **)v26;
        }
        *a6 = v26;
        if (*(char *)(v18 + 63) < 0) {
          uint64_t v27 = *(void *)(v18 + 48);
        }
        else {
          LODWORD(v27) = *(unsigned __int8 *)(v18 + 63);
        }
        *a7 = v27;
      }
    }
    return 1;
  }
  return result;
}

const XMP_Node *GetNextXMPNode(IterInfo *a1)
{
  uint64_t v2 = (int *)*((void *)a1 + 5);
  if (*((unsigned char *)v2 + 88))
  {
    AdvanceIterPos(a1);
    uint64_t v2 = (int *)*((void *)a1 + 5);
  }
  memset(v14, 0, sizeof(v14));
  if (v2 == *((int **)a1 + 6)) {
    goto LABEL_25;
  }
  while (1)
  {
    int v3 = *v2;
    if (*v2 < 0)
    {
      std::string::operator=((std::string *)((char *)a1 + 16), (const std::string *)(v2 + 2));
      uint64_t v7 = *((void *)a1 + 5);
      uint64_t v8 = (char *)(v7 + 8);
      if (*(char *)(v7 + 31) < 0) {
        uint64_t v8 = *(char **)v8;
      }
      uint64_t SchemaNode = FindSchemaNode((void *)(*((void *)a1 + 1) + 224), v8, 0, 0);
      Node = (const XMP_Node *)(SchemaNode ? SchemaNode : sDummySchema);
    }
    else
    {
      if (*((char *)a1 + 39) >= 0) {
        CFStringRef v4 = (char *)a1 + 16;
      }
      else {
        CFStringRef v4 = (char *)*((void *)a1 + 2);
      }
      int v5 = v2 + 2;
      if (*((char *)v2 + 31) < 0) {
        int v5 = *(unsigned char **)v5;
      }
      ExpandXPath(v4, v5, (uint64_t *)v14);
      Node = (const XMP_Node *)FindNode((void *)(*((void *)a1 + 1) + 224), v14, 0, 0, 0);
    }
    uint64_t v10 = *((void *)a1 + 5);
    if (Node) {
      break;
    }
    CFRange v12 = *(void ***)(v10 + 40);
    uint64_t v11 = v10 + 40;
    *(unsigned char *)(v11 + 48) = 3;
    std::vector<IterNode>::__base_destruct_at_end[abi:ne180100](v11, v12);
    std::vector<IterNode>::__base_destruct_at_end[abi:ne180100](*((void *)a1 + 5) + 64, *(void ***)(*((void *)a1 + 5) + 64));
    AdvanceIterPos(a1);
    uint64_t v2 = (int *)*((void *)a1 + 5);
    if (v2 == *((int **)a1 + 6)) {
      goto LABEL_25;
    }
  }
  if (v10 == *((void *)a1 + 6))
  {
LABEL_25:
    Node = 0;
  }
  else
  {
    if (*(unsigned char *)(v10 + 88)) {
      __assert_rtn("GetNextXMPNode", "XMPIterator.cpp", 312, "info.currPos->visitStage == kIter_BeforeVisit");
    }
    if ((v3 & 0x80000000) == 0 && (*((unsigned char *)a1 + 1) & 1) == 0)
    {
      AddNodeOffspring(a1, *((IterNode **)a1 + 5), Node);
      uint64_t v10 = *((void *)a1 + 5);
    }
    *(unsigned char *)(v10 + 88) = 1;
  }
  int v15 = v14;
  std::vector<XPathStepInfo>::__destroy_vector::operator()[abi:ne180100]((void ***)&v15);
  return Node;
}

void sub_1885C1E08(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void **a12)
{
  a12 = (void **)&a9;
  std::vector<XPathStepInfo>::__destroy_vector::operator()[abi:ne180100](&a12);
  _Unwind_Resume(a1);
}

void CGImageMetadataAddTag(uint64_t a1, const void *a2)
{
  if (a1)
  {
    if (a2)
    {
      CFStringRef v4 = CGImageMetadataTagKeyCreateWithTag(a2);
      if (v4)
      {
        int v5 = v4;
        CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 24), v4, a2);
        CGImageMetadataTagKeyRelease(v5);
      }
    }
  }
}

void *CGImageMetadataTagKeyCreateWithTag(const void *a1)
{
  uint64_t Source = CGImageSourceGetSource((uint64_t)a1);
  if (!a1) {
    return 0;
  }
  uint64_t v3 = Source;
  CFTypeID v4 = CFGetTypeID(a1);
  if (v4 != CGImageMetadataTagGetTypeID()) {
    return 0;
  }
  CFStringRef v5 = *(const __CFString **)(v3 + 16);
  CFStringRef v6 = *(const __CFString **)(v3 + 32);

  return CGImageMetadataTagKeyCreate(v5, v6);
}

uint64_t FindNode(void *a1, const void ***a2, int a3, int a4, char **a5)
{
  int v32 = 0;
  if (a4 && (a3 & 1) == 0) {
    FindNode();
  }
  uint64_t v10 = *a2;
  uint64_t v11 = a2[1];
  if (*a2 == v11)
  {
    exception = __cxa_allocate_exception(0x18uLL);
    *(_DWORD *)exception = 102;
    exception[1] = "Empty XPath";
    *((unsigned char *)exception + 16) = 0;
  }
  uint64_t v12 = (char *)v11 - (char *)v10;
  if (((_BYTE)v10[7] & 0x10) != 0)
  {
    uint64_t v17 = std::__tree<std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>>>::find<std::string>(sRegisteredAliasMap, v10 + 4);
    if (sRegisteredAliasMap + 8 == v17) {
      FindNode();
    }
    uint64_t v18 = v17;
    uint64_t v20 = (void *)(v17 + 56);
    unsigned int v19 = *(char **)(v17 + 56);
    if (v19[23] < 0) {
      unsigned int v19 = *(char **)v19;
    }
    uint64_t SchemaNode = FindSchemaNode(a1, v19, a3, &v32);
    if (SchemaNode)
    {
      int v22 = *(_DWORD *)(SchemaNode + 8);
      if ((v22 & 0x8000) != 0)
      {
        *(_DWORD *)(SchemaNode + 8) = v22 ^ 0x8000;
        int v15 = v32;
        int v23 = 1;
      }
      else
      {
        int v15 = 0;
        int v23 = 0;
      }
      uint64_t result = FollowXPathStep(SchemaNode, v20, 1, a3, &v32, 0);
      if (!result) {
        goto LABEL_44;
      }
      int v25 = *(_DWORD *)(result + 8);
      if ((v25 & 0x8000) != 0)
      {
        *(_DWORD *)(result + 8) = v25 ^ 0x8000;
        if ((unint64_t)v12 >= 0x41 && (v25 & 0x1F00) == 0 && ((*a2)[11] & 0xF) == 1) {
          *(_DWORD *)(result + 8) = v25 ^ 0x8000 | 0x100;
        }
        if ((v22 & 0x8000) == 0) {
          int v15 = v32;
        }
        int v23 = 1;
      }
      if ((*(_DWORD *)(*v20 + 56) & 0x1E00) != 0 && (*(_DWORD *)(*v20 + 56) & 0x200) == 0) {
        FindNode();
      }
      uint64_t v27 = *(void *)(v18 + 64) - *v20;
      if ((*(_DWORD *)(*v20 + 56) & 0x1E00) != 0)
      {
        if (v27 == 96)
        {
          uint64_t result = FollowXPathStep(result, v20, 2, a3, &v32, 1);
          if (result)
          {
            int v28 = *(_DWORD *)(result + 8);
            if ((v28 & 0x8000) != 0)
            {
              *(_DWORD *)(result + 8) = v28 ^ 0x8000;
              if ((unint64_t)v12 >= 0x41 && (v28 & 0x1F00) == 0 && ((*a2)[11] & 0xF) == 1) {
                *(_DWORD *)(result + 8) = v28 ^ 0x8000 | 0x100;
              }
              if (!v23) {
                int v15 = v32;
              }
              int v23 = 1;
            }
            goto LABEL_50;
          }
LABEL_44:
          BOOL v16 = v23 != 0;
LABEL_45:
          if (a3) {
            FindNode();
          }
          if (v16) {
            DeleteSubtree(v15);
          }
          return 0;
        }
      }
      else if (v27 == 64)
      {
LABEL_50:
        BOOL v16 = v23 != 0;
        unint64_t v24 = 2;
LABEL_51:
        unint64_t v29 = v12 >> 5;
        if (v24 >= v29)
        {
LABEL_63:
          if (result != *(void *)v32) {
            FindNode();
          }
          if (v16) {
            *(_DWORD *)(result + 8) |= a4;
          }
          if (a5) {
            *a5 = v32;
          }
          return result;
        }
        while (1)
        {
          uint64_t result = FollowXPathStep(result, a2, v24, a3, &v32, 0);
          if (!result) {
            goto LABEL_45;
          }
          int v30 = *(_DWORD *)(result + 8);
          if ((v30 & 0x8000) != 0)
          {
            *(_DWORD *)(result + 8) = v30 ^ 0x8000;
            if (++v24 < v29 && (v30 & 0x1F00) == 0 && ((uint64_t)(*a2)[4 * v24 + 3] & 0xF) == 1) {
              *(_DWORD *)(result + 8) = v30 ^ 0x8000 | 0x100;
            }
            if (!v16) {
              int v15 = v32;
            }
            BOOL v16 = 1;
          }
          else
          {
            ++v24;
          }
          if (v24 == v29) {
            goto LABEL_63;
          }
        }
      }
      FindNode();
    }
    int v15 = 0;
    int v23 = 0;
    goto LABEL_44;
  }
  if (*((char *)v10 + 23) < 0) {
    uint64_t v10 = (const void **)*v10;
  }
  uint64_t result = FindSchemaNode(a1, (char *)v10, a3, &v32);
  if (result)
  {
    int v14 = *(_DWORD *)(result + 8);
    if ((v14 & 0x8000) != 0)
    {
      *(_DWORD *)(result + 8) = v14 ^ 0x8000;
      int v15 = v32;
      BOOL v16 = 1;
    }
    else
    {
      int v15 = 0;
      BOOL v16 = 0;
    }
    unint64_t v24 = 1;
    goto LABEL_51;
  }
  return result;
}

void sub_1885C228C(void *a1)
{
  __cxa_begin_catch(a1);
  if (v2) {
    DeleteSubtree(v1);
  }
  __cxa_rethrow();
}

void sub_1885C22A4(_Unwind_Exception *a1)
{
}

uint64_t FollowXPathStep(uint64_t a1, void *a2, uint64_t a3, int a4, void *a5, int a6)
{
  uint64_t v73 = 0;
  uint64_t v6 = *a2 + 32 * a3;
  uint64_t v7 = (_DWORD *)(v6 + 24);
  int v8 = *(_DWORD *)(v6 + 24) & 0xF;
  if ((v8 - 7) <= 0xFFFFFFF9) {
    FollowXPathStep();
  }
  uint64_t v9 = a5;
  int v10 = a4;
  if (v8 == 2)
  {
    if (*(char *)(v6 + 23) < 0) {
      uint64_t v6 = *(void *)v6;
    }
    if (*(unsigned char *)v6 != 63) {
      FollowXPathStep();
    }
    uint64_t result = FindQualifierNode(a1, (char *)(v6 + 1), a4, a5);
    goto LABEL_11;
  }
  if (v8 == 1)
  {
    if (*(char *)(v6 + 23) < 0) {
      uint64_t v6 = *(void *)v6;
    }
    uint64_t result = FindChildNode(a1, (char *)v6, a4, a5);
LABEL_11:
    uint64_t v73 = result;
    goto LABEL_12;
  }
  if ((*(unsigned char *)(a1 + 9) & 2) == 0)
  {
    exception = __cxa_allocate_exception(0x18uLL);
    *(_DWORD *)exception = 102;
    int v59 = "Indexing applied to non-array";
    goto LABEL_147;
  }
  uint64_t v14 = a3;
  switch(v8)
  {
    case 3:
      uint64_t v15 = *(unsigned __int8 *)(v6 + 23);
      if (*(char *)(v6 + 23) < 0)
      {
        unint64_t v16 = *(void *)(v6 + 8) - 1;
        if (v16 <= 1) {
          goto LABEL_142;
        }
        uint64_t v17 = *(unsigned char **)v6;
      }
      else
      {
        unint64_t v16 = v15 - 1;
        uint64_t v17 = (unsigned char *)(*a2 + 32 * a3);
        if ((unint64_t)(v15 - 1) <= 1) {
          goto LABEL_142;
        }
      }
      if (*v17 != 91
        || ((v15 & 0x80u) == 0 ? (uint64_t v23 = *a2 + 32 * a3) : (uint64_t v23 = *(void *)v6), *(unsigned char *)(v23 + v16) != 93))
      {
LABEL_142:
        FollowXPathStep();
      }
      unint64_t v24 = v16 - 1;
      if (!v24) {
        goto LABEL_149;
      }
      int v25 = 0;
      int v26 = (char *)(v23 + 1);
      do
      {
        int v28 = *v26++;
        int v27 = v28;
        if ((v28 - 48) >= 0xA) {
          FollowXPathStep();
        }
        int v25 = v27 + 10 * v25 - 48;
        if (v25 < 0)
        {
          exception = __cxa_allocate_exception(0x18uLL);
          *(_DWORD *)exception = 102;
          int v59 = "Array index overflow";
          goto LABEL_147;
        }
        --v24;
      }
      while (v24);
      if (!v25)
      {
LABEL_149:
        exception = __cxa_allocate_exception(0x18uLL);
        *(_DWORD *)exception = 102;
        int v59 = "Array index must be larger than zero";
LABEL_147:
        exception[1] = v59;
        *((unsigned char *)exception + 16) = 0;
      }
      LODWORD(v22) = v25 - 1;
      uint64_t v29 = (*(void *)(a1 + 80) - *(void *)(a1 + 72)) >> 3;
      if (v25 - 1 == v29 && a4 != 0) {
        operator new();
      }
      BOOL v50 = v25 <= (int)v29;
      uint64_t v14 = a3;
      if (v50) {
        goto LABEL_104;
      }
      LODWORD(v22) = -1;
LABEL_107:
      if (v22 == -1)
      {
        if (v10)
        {
          LODWORD(v22) = -1;
          if (v8 == 5)
          {
            if (a6)
            {
              if ((*(unsigned char *)(a1 + 9) & 0x10) == 0) {
                FollowXPathStep();
              }
              if (v14 == 2)
              {
                int v52 = *(char *)(v6 + 23);
                if (v52 < 0)
                {
                  if (*(void *)(v6 + 8) != 23) {
                    goto LABEL_144;
                  }
                  uint64_t v6 = *(void *)v6;
                }
                else if (v52 != 23)
                {
                  goto LABEL_144;
                }
                if (*(void *)v6 == 0x616C3A6C6D783F5BLL
                  && *(void *)(v6 + 8) == 0x65642D78223D676ELL
                  && *(void *)(v6 + 15) == 0x5D22746C75616665)
                {
                  operator new();
                }
              }
LABEL_144:
              FollowXPathStep();
            }
          }
        }
      }
LABEL_127:
      uint64_t result = v73;
      if (!v9 || !v73)
      {
LABEL_12:
        if (result) {
          goto LABEL_130;
        }
        if (v10) {
          FollowXPathStep();
        }
        return 0;
      }
      *uint64_t v9 = *(void *)(a1 + 72) + 8 * (int)v22;
LABEL_130:
      int v55 = *(_DWORD *)(result + 8);
      if ((v55 & 0x8000) != 0) {
        *(_DWORD *)(result + 8) = *v7 & 0x1E00 | v55;
      }
      if (v9 && result != *(void *)*v9) {
        FollowXPathStep();
      }
      return result;
    case 4:
      LODWORD(v22) = ((*(void *)(a1 + 80) - *(void *)(a1 + 72)) >> 3) - 1;
      goto LABEL_104;
    case 5:
      int v70 = 0;
      uint64_t v71 = 0;
      uint64_t v72 = 0;
      memset(&__p, 0, sizeof(__p));
      SplitNameAndValue(v6, (uint64_t)&v70, &__p);
      if (SHIBYTE(v72) < 0)
      {
        if (v71 != 8) {
          goto LABEL_55;
        }
        uint64_t v18 = v70;
      }
      else
      {
        if (HIBYTE(v72) != 8) {
          goto LABEL_55;
        }
        uint64_t v18 = &v70;
      }
      if (*v18 == 0x676E616C3A6C6D78)
      {
        NormalizeLangValue((unsigned __int8 *)&__p);
        LODWORD(v22) = LookupLangItem(a1, (unsigned __int8 **)&__p);
        goto LABEL_98;
      }
LABEL_55:
      uint64_t v65 = *(void *)(a1 + 72);
      uint64_t v31 = *(void *)(a1 + 80) - v65;
      if (!v31)
      {
        LODWORD(v22) = -1;
        goto LABEL_98;
      }
      int v64 = a6;
      uint64_t v66 = v14;
      int v60 = v10;
      unsigned int v61 = v9;
      uint64_t v22 = 0;
      if (v72 >= 0) {
        uint64_t v32 = HIBYTE(v72);
      }
      else {
        uint64_t v32 = v71;
      }
      uint64_t v33 = (unsigned __int8 *)&v70;
      if (v72 < 0) {
        uint64_t v33 = (unsigned __int8 *)v70;
      }
      __s2 = v33;
      std::string::size_type size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        std::string::size_type size = __p.__r_.__value_.__l.__size_;
      }
      std::string::size_type v67 = size;
      p_p = &__p;
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      uint64_t v62 = v31 >> 3;
      uint64_t v63 = p_p;
      while (1)
      {
        uint64_t v36 = *(void **)(v65 + 8 * v22);
        if (v36[8] != a1)
        {
          int v56 = 357;
          uint64_t v57 = "currItem->parent == arrayNode";
LABEL_138:
          __assert_rtn("LookupQualSelector", "XMPCore_Impl.cpp", v56, v57);
        }
        uint64_t v37 = v36[12];
        uint64_t v38 = v36[13] - v37;
        if (v38) {
          break;
        }
LABEL_93:
        if (++v22 == v62)
        {
          LODWORD(v22) = -1;
LABEL_95:
          uint64_t v7 = (_DWORD *)(v6 + 24);
          uint64_t v9 = v61;
          int v10 = v60;
          uint64_t v14 = v66;
          a6 = v64;
LABEL_98:
          if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(__p.__r_.__value_.__l.__data_);
          }
          if (SHIBYTE(v72) < 0) {
LABEL_101:
          }
            operator delete(v70);
LABEL_104:
          if ((v22 & 0x80000000) != 0) {
            goto LABEL_107;
          }
          uint64_t v51 = *(void *)(a1 + 72);
          if ((int)v22 <= (int)((unint64_t)(*(void *)(a1 + 80) - v51) >> 3)) {
            uint64_t v73 = *(void *)(v51 + 8 * v22);
          }
          goto LABEL_127;
        }
      }
      uint64_t v39 = 0;
      uint64_t v40 = v38 >> 3;
      while (1)
      {
        uint64_t v41 = *(void *)(v37 + 8 * v39);
        if (*(void **)(v41 + 64) != v36)
        {
          int v56 = 362;
          uint64_t v57 = "currQual->parent == currItem";
          goto LABEL_138;
        }
        uint64_t v42 = *(unsigned __int8 *)(v41 + 39);
        if ((v42 & 0x80u) == 0) {
          uint64_t v43 = *(unsigned __int8 *)(v41 + 39);
        }
        else {
          uint64_t v43 = *(void *)(v41 + 24);
        }
        if (v43 == v32)
        {
          unsigned int v44 = (const void **)(v41 + 16);
          if ((v42 & 0x80) != 0)
          {
            if (!memcmp(*v44, __s2, *(void *)(v41 + 24)))
            {
LABEL_81:
              uint64_t v46 = *(unsigned __int8 *)(v41 + 63);
              if ((v46 & 0x80u) == 0) {
                uint64_t v47 = *(unsigned __int8 *)(v41 + 63);
              }
              else {
                uint64_t v47 = *(void *)(v41 + 48);
              }
              if (v47 == v67)
              {
                int v48 = (const void **)(v41 + 40);
                if ((v46 & 0x80) != 0)
                {
                  if (!memcmp(*v48, v63, *(void *)(v41 + 48))) {
                    goto LABEL_95;
                  }
                }
                else
                {
                  if (!*(unsigned char *)(v41 + 63)) {
                    goto LABEL_95;
                  }
                  uint64_t v49 = v63;
                  while (*(unsigned __int8 *)v48 == v49->__r_.__value_.__s.__data_[0])
                  {
                    int v48 = (const void **)((char *)v48 + 1);
                    uint64_t v49 = (std::string *)((char *)v49 + 1);
                    if (!--v46) {
                      goto LABEL_95;
                    }
                  }
                }
              }
            }
          }
          else
          {
            if (!*(unsigned char *)(v41 + 39)) {
              goto LABEL_81;
            }
            int v45 = __s2;
            while (*(unsigned __int8 *)v44 == *v45)
            {
              unsigned int v44 = (const void **)((char *)v44 + 1);
              ++v45;
              if (!--v42) {
                goto LABEL_81;
              }
            }
          }
        }
        if (++v39 == v40) {
          goto LABEL_93;
        }
      }
    case 6:
      int v70 = 0;
      uint64_t v71 = 0;
      uint64_t v72 = 0;
      memset(&__p, 0, sizeof(__p));
      SplitNameAndValue(v6, (uint64_t)&v70, &__p);
      if (v72 >= 0) {
        uint64_t v20 = (const char *)&v70;
      }
      else {
        uint64_t v20 = (const char *)v70;
      }
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        uint64_t v21 = &__p;
      }
      else {
        uint64_t v21 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      LODWORD(v22) = LookupFieldSelector((const XMP_Node *)a1, v20, (const char *)v21);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      int v10 = a4;
      if (SHIBYTE(v72) < 0) {
        goto LABEL_101;
      }
      goto LABEL_104;
    default:
      exception = __cxa_allocate_exception(0x18uLL);
      *(_DWORD *)exception = 9;
      int v59 = "Unknown array indexing step in FollowXPathStep";
      goto LABEL_147;
  }
}

void sub_1885C2C40(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25,void *a26,uint64_t a27,int a28,__int16 a29,char a30,char a31)
{
  MEMORY[0x18C11C0E0](v31, 0x10B3C407D34617ELL);
  _Unwind_Resume(a1);
}

uint64_t FindChildNode(uint64_t a1, char *__s, int a3, void *a4)
{
  int v8 = *(_DWORD *)(a1 + 8);
  if ((v8 & 0x80000100) != 0) {
    goto LABEL_6;
  }
  if ((v8 & 0x8000) == 0)
  {
    exception = __cxa_allocate_exception(0x18uLL);
    *(_DWORD *)exception = 102;
    uint64_t v17 = "Named children only allowed for schemas and structs";
    goto LABEL_30;
  }
  if ((v8 & 0x200) != 0)
  {
    exception = __cxa_allocate_exception(0x18uLL);
    *(_DWORD *)exception = 102;
    uint64_t v17 = "Named children not allowed for arrays";
    goto LABEL_30;
  }
  if ((a3 & 1) == 0)
  {
    exception = __cxa_allocate_exception(0x18uLL);
    *(_DWORD *)exception = 9;
    uint64_t v17 = "Parent is new implicit node, but createNodes is false";
LABEL_30:
    exception[1] = v17;
    *((unsigned char *)exception + 16) = 0;
  }
  *(_DWORD *)(a1 + 8) = v8 | 0x100;
LABEL_6:
  uint64_t v9 = *(uint64_t **)(a1 + 72);
  uint64_t v10 = *(void *)(a1 + 80) - (void)v9;
  if (!v10)
  {
LABEL_18:
    if (a3) {
      operator new();
    }
    return 0;
  }
  uint64_t v11 = v10 >> 3;
  while (1)
  {
    uint64_t v12 = *v9;
    if (*(void *)(*v9 + 64) != a1) {
      FindChildNode();
    }
    uint64_t v13 = (void *)(v12 + 16);
    size_t v14 = strlen(__s);
    if (*(char *)(v12 + 39) < 0) {
      break;
    }
    if (v14 == *(unsigned __int8 *)(v12 + 39))
    {
      if (v14 == -1) {
        goto LABEL_26;
      }
      goto LABEL_16;
    }
LABEL_17:
    ++v9;
    if (!--v11) {
      goto LABEL_18;
    }
  }
  if (v14 != *(void *)(v12 + 24)) {
    goto LABEL_17;
  }
  if (v14 == -1) {
LABEL_26:
  }
    std::string::__throw_out_of_range[abi:ne180100]();
  uint64_t v13 = (void *)*v13;
LABEL_16:
  if (memcmp(v13, __s, v14)) {
    goto LABEL_17;
  }
  if (a4)
  {
    *a4 = v9;
    if (v12 != *v9) {
      FindChildNode();
    }
  }
  return v12;
}

void sub_1885C2F2C(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10B3C407D34617ELL);
  _Unwind_Resume(a1);
}

void AddNodeOffspring(IterInfo *a1, IterNode *a2, const XMP_Node *a3)
{
  uint64_t v39 = *MEMORY[0x1E4F143B8];
  memset(&v32, 0, sizeof(v32));
  int v6 = *((char *)a2 + 31);
  if (v6 < 0)
  {
    std::string::__init_copy_ctor_external(&v32, *((const std::string::value_type **)a2 + 1), *((void *)a2 + 2));
    int v6 = *((char *)a2 + 31);
    if (v6 < 0)
    {
      std::string::size_type v7 = *((void *)a2 + 2);
      goto LABEL_5;
    }
  }
  else
  {
    std::string v32 = *(std::string *)((char *)a2 + 8);
  }
  std::string::size_type v7 = v6;
LABEL_5:
  if (*((void *)a3 + 12) != *((void *)a3 + 13) && (*((unsigned char *)a1 + 1) & 0x10) == 0)
  {
    std::string::append(&v32, "/?");
    uint64_t v8 = *((void *)a3 + 13) - *((void *)a3 + 12);
    if (v8)
    {
      uint64_t v9 = 0;
      uint64_t v10 = v8 >> 3;
      do
      {
        uint64_t v11 = *(void *)(*((void *)a3 + 12) + 8 * v9);
        int v12 = *(char *)(v11 + 39);
        if (v12 >= 0) {
          uint64_t v13 = (const std::string::value_type *)(v11 + 16);
        }
        else {
          uint64_t v13 = *(const std::string::value_type **)(v11 + 16);
        }
        if (v12 >= 0) {
          std::string::size_type v14 = *(unsigned __int8 *)(v11 + 39);
        }
        else {
          std::string::size_type v14 = *(void *)(v11 + 24);
        }
        std::string::append(&v32, v13, v14);
        LODWORD(__p[0]) = *(_DWORD *)(v11 + 8);
        if (SHIBYTE(v32.__r_.__value_.__r.__words[2]) < 0) {
          std::string::__init_copy_ctor_external((std::string *)&__p[1], v32.__r_.__value_.__l.__data_, v32.__r_.__value_.__l.__size_);
        }
        else {
          *(std::string *)&__p[1] = v32;
        }
        std::string::size_type v35 = v7 + 2;
        long long v36 = 0u;
        memset(v37, 0, sizeof(v37));
        char v38 = 0;
        unint64_t v15 = *((void *)a2 + 9);
        if (v15 >= *((void *)a2 + 10))
        {
          uint64_t v17 = std::vector<IterNode>::__push_back_slow_path<IterNode>((uint64_t *)a2 + 8, (uint64_t)__p);
        }
        else
        {
          *(_DWORD *)unint64_t v15 = __p[0];
          long long v16 = *(_OWORD *)&__p[1];
          *(void **)(v15 + 24) = __p[3];
          *(_OWORD *)(v15 + 8) = v16;
          memset(&__p[1], 0, 24);
          *(void *)(v15 + 32) = v35;
          *(void *)(v15 + 40) = 0;
          *(void *)(v15 + 48) = 0;
          *(void *)(v15 + 56) = 0;
          *(_OWORD *)(v15 + 40) = v36;
          long long v36 = 0uLL;
          *(void *)(v15 + 56) = v37[0];
          *(void *)(v15 + 64) = 0;
          v37[0] = 0;
          *(void *)(v15 + 72) = 0;
          *(void *)(v15 + 80) = 0;
          *(_OWORD *)(v15 + 64) = *(_OWORD *)&v37[1];
          *(void *)(v15 + 80) = v37[3];
          memset(&v37[1], 0, 24);
          *(unsigned char *)(v15 + 88) = v38;
          uint64_t v17 = v15 + 96;
        }
        *((void *)a2 + 9) = v17;
        uint64_t v33 = (void **)&v37[1];
        std::vector<IterNode>::__destroy_vector::operator()[abi:ne180100](&v33);
        uint64_t v33 = (void **)&v36;
        std::vector<IterNode>::__destroy_vector::operator()[abi:ne180100](&v33);
        if (SHIBYTE(__p[3]) < 0) {
          operator delete(__p[1]);
        }
        std::string::erase(&v32, v7 + 2, 0xFFFFFFFFFFFFFFFFLL);
        ++v9;
      }
      while (v10 != v9);
    }
    std::string::erase(&v32, v7, 0xFFFFFFFFFFFFFFFFLL);
  }
  uint64_t v19 = *((void *)a3 + 9);
  uint64_t v18 = *((void *)a3 + 10);
  if (v19 != v18)
  {
    int v20 = *((_DWORD *)a3 + 2);
    if ((v20 & 0x1F00) == 0)
    {
      exception = __cxa_allocate_exception(4uLL);
      _DWORD *exception = -1;
      __cxa_throw(exception, MEMORY[0x1E4FBA3A8], 0);
    }
    if ((v20 & 0x100) != 0)
    {
      std::string::push_back(&v32, 47);
      ++v7;
      uint64_t v19 = *((void *)a3 + 9);
      uint64_t v18 = *((void *)a3 + 10);
    }
    uint64_t v21 = v18 - v19;
    if (v21)
    {
      uint64_t v22 = 0;
      uint64_t v23 = v21 >> 3;
      do
      {
        uint64_t v24 = *(void *)(*((void *)a3 + 9) + 8 * v22);
        if ((*((unsigned char *)a3 + 9) & 2) != 0)
        {
          memset(__p, 0, sizeof(__p));
          snprintf((char *)__p, 0x20uLL, "[%lu]", v22 + 1);
          std::string::append(&v32, (const std::string::value_type *)__p);
        }
        else
        {
          int v25 = *(char *)(v24 + 39);
          if (v25 >= 0) {
            int v26 = (const std::string::value_type *)(v24 + 16);
          }
          else {
            int v26 = *(const std::string::value_type **)(v24 + 16);
          }
          if (v25 >= 0) {
            std::string::size_type v27 = *(unsigned __int8 *)(v24 + 39);
          }
          else {
            std::string::size_type v27 = *(void *)(v24 + 24);
          }
          std::string::append(&v32, v26, v27);
        }
        LODWORD(__p[0]) = *(_DWORD *)(v24 + 8);
        if (SHIBYTE(v32.__r_.__value_.__r.__words[2]) < 0) {
          std::string::__init_copy_ctor_external((std::string *)&__p[1], v32.__r_.__value_.__l.__data_, v32.__r_.__value_.__l.__size_);
        }
        else {
          *(std::string *)&__p[1] = v32;
        }
        std::string::size_type v35 = v7;
        long long v36 = 0u;
        memset(v37, 0, sizeof(v37));
        char v38 = 0;
        unint64_t v28 = *((void *)a2 + 6);
        if (v28 >= *((void *)a2 + 7))
        {
          uint64_t v30 = std::vector<IterNode>::__push_back_slow_path<IterNode>((uint64_t *)a2 + 5, (uint64_t)__p);
        }
        else
        {
          *(_DWORD *)unint64_t v28 = __p[0];
          long long v29 = *(_OWORD *)&__p[1];
          *(void **)(v28 + 24) = __p[3];
          *(_OWORD *)(v28 + 8) = v29;
          memset(&__p[1], 0, 24);
          *(void *)(v28 + 32) = v35;
          *(void *)(v28 + 40) = 0;
          *(void *)(v28 + 48) = 0;
          *(void *)(v28 + 56) = 0;
          *(_OWORD *)(v28 + 40) = v36;
          long long v36 = 0uLL;
          *(void *)(v28 + 56) = v37[0];
          *(void *)(v28 + 64) = 0;
          v37[0] = 0;
          *(void *)(v28 + 72) = 0;
          *(void *)(v28 + 80) = 0;
          *(_OWORD *)(v28 + 64) = *(_OWORD *)&v37[1];
          *(void *)(v28 + 80) = v37[3];
          memset(&v37[1], 0, 24);
          *(unsigned char *)(v28 + 88) = v38;
          uint64_t v30 = v28 + 96;
        }
        *((void *)a2 + 6) = v30;
        uint64_t v33 = (void **)&v37[1];
        std::vector<IterNode>::__destroy_vector::operator()[abi:ne180100](&v33);
        uint64_t v33 = (void **)&v36;
        std::vector<IterNode>::__destroy_vector::operator()[abi:ne180100](&v33);
        if (SHIBYTE(__p[3]) < 0) {
          operator delete(__p[1]);
        }
        std::string::erase(&v32, v7, 0xFFFFFFFFFFFFFFFFLL);
        ++v22;
      }
      while (v23 != v22);
    }
  }
  if (SHIBYTE(v32.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v32.__r_.__value_.__l.__data_);
  }
}

void sub_1885C33C8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, char a18)
{
}

CFStringRef createPropertyNameFromPath(const __CFString *result)
{
  if (result)
  {
    CFStringRef v1 = result;
    v3.location = 0;
    v3.CFIndex length = 0;
    CFIndex Length = CFStringGetLength(result);
    v4.location = 0;
    v4.CFIndex length = Length;
    if (CFStringFindWithOptions(v1, @":", v4, 4uLL, &v3))
    {
      v5.location = v3.location + 1;
      v5.CFIndex length = Length - (v3.location + 1);
      return CFStringCreateWithSubstring((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v1, v5);
    }
    else
    {
      return CFStringCreateCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v1);
    }
  }
  return result;
}

BOOL CGImageMetadataRegisterNamespaceForPrefix(CGMutableImageMetadataRef metadata, CFStringRef xmlns, CFStringRef prefix, CFErrorRef *err)
{
  IIOInitDebugFlags();
  if ((~(_WORD)gIIODebugFlags & 0x3000) == 0)
  {
    IIOString::IIOString((IIOString *)v25, prefix);
    uint64_t v8 = (const char *)IIOString::utf8String((IIOString *)v25);
    ImageIODebugOptions(3, "A", "CGImageMetadataRegisterNamespaceForPrefix", 0, v8, -1, 0);
    IIOString::~IIOString((IIOString *)v25);
  }
  if (!metadata) {
    goto LABEL_4;
  }
  CFTypeID v12 = CFGetTypeID(metadata);
  if (CGImageMetadataGetTypeID::once != -1) {
    dispatch_once(&CGImageMetadataGetTypeID::once, &__block_literal_global_21);
  }
  if (v12 == CGImageMetadataGetTypeID::id)
  {
    if (xmlns && (CFTypeID v13 = CFGetTypeID(xmlns), v13 == CFStringGetTypeID()))
    {
      if (prefix)
      {
        CFTypeID v14 = CFGetTypeID(prefix);
        if (v14 == CFStringGetTypeID())
        {
          unint64_t v15 = (pthread_mutex_t *)((char *)metadata + 136);
          pthread_mutex_lock((pthread_mutex_t *)((char *)metadata + 136));
          CFDictionaryRef v16 = (const __CFDictionary *)*((void *)metadata + 4);
          if (!v16) {
            goto LABEL_24;
          }
          CFStringRef Value = (const __CFString *)CFDictionaryGetValue(v16, xmlns);
          if (Value)
          {
            CFStringRef v18 = Value;
            CFTypeID v19 = CFGetTypeID(Value);
            if (v19 == CFStringGetTypeID())
            {
              BOOL v11 = 1;
              if (CFStringCompare(v18, prefix, 1uLL))
              {
                CFSetRef Mutable = (const __CFSet *)CGImageMetadataRegisterNamespaceForPrefix::alreadyRegistered;
                if (!CGImageMetadataRegisterNamespaceForPrefix::alreadyRegistered)
                {
                  CFSetRef Mutable = CFSetCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D548]);
                  CGImageMetadataRegisterNamespaceForPrefix::alreadyRegistered = (uint64_t)Mutable;
                }
                if (!CFSetContainsValue(Mutable, v18))
                {
                  CFSetAddValue((CFMutableSetRef)CGImageMetadataRegisterNamespaceForPrefix::alreadyRegistered, v18);
                  uint64_t v21 = (__CFString *)CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Error: Cannot register the prefix '%@', '%@' is already associated with the prefix '%@'.", prefix, xmlns, v18);
                  if (v21)
                  {
                    uint64_t v22 = v21;
                    CGImageMetadataCreateAndLogError("CGImageMetadataRegisterNamespaceForPrefix", 4, v21, err);
                    CFRelease(v22);
                  }
                }
                BOOL v11 = 0;
              }
              goto LABEL_29;
            }
LABEL_28:
            BOOL v11 = 1;
LABEL_29:
            pthread_mutex_unlock(v15);
            return v11;
          }
          uint64_t v23 = (__CFDictionary *)*((void *)metadata + 4);
          if (!v23)
          {
LABEL_24:
            uint64_t v23 = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
            *((void *)metadata + 4) = v23;
          }
          if (!*((void *)metadata + 5))
          {
            *((void *)metadata + 5) = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
            uint64_t v23 = (__CFDictionary *)*((void *)metadata + 4);
          }
          CFDictionarySetValue(v23, xmlns, prefix);
          CFDictionarySetValue(*((CFMutableDictionaryRef *)metadata + 5), prefix, xmlns);
          goto LABEL_28;
        }
      }
      uint64_t v9 = "prefix must be a non-NULL CFStringRef.";
      int v10 = 2247;
    }
    else
    {
      uint64_t v9 = "xmlns must be a non-NULL CFStringRef.";
      int v10 = 2246;
    }
  }
  else
  {
LABEL_4:
    uint64_t v9 = "metadata must be a non-NULL CGMutableImageMetadataRef.";
    int v10 = 2245;
  }
  CGImageMetadataCreateAndLogUTF8Error("CGImageMetadataRegisterNamespaceForPrefix", v10, 2, v9, err);
  return 0;
}

void sub_1885C37A0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  IIOString::~IIOString((IIOString *)va);
  _Unwind_Resume(a1);
}

CFStringRef createNamespaceURIForPropertyPath(const __CFString *a1)
{
  __p[0] = 0;
  __p[1] = 0;
  uint64_t v8 = 0;
  if (!a1) {
    return 0;
  }
  CFStringRef PropertyPrefixFromPath = createPropertyPrefixFromPath(a1);
  if (!PropertyPrefixFromPath) {
    return 0;
  }
  IIOString::IIOString((IIOString *)v6, PropertyPrefixFromPath);
  UTF8String = (XMPMeta *)IIOString::createUTF8String((IIOString *)v6);
  IIOString::~IIOString((IIOString *)v6);
  if (UTF8String)
  {
    if (TXMPMeta<std::string>::GetNamespaceURI(UTF8String, (uint64_t)__p))
    {
      if (v8 >= 0) {
        CFRange v3 = __p;
      }
      else {
        CFRange v3 = (void **)__p[0];
      }
      CFStringRef v4 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const char *)v3, 0x8000100u);
    }
    else
    {
      CFStringRef v4 = 0;
    }
    free(UTF8String);
  }
  else
  {
    CFStringRef v4 = 0;
  }
  CFRelease(PropertyPrefixFromPath);
  if (SHIBYTE(v8) < 0) {
    operator delete(__p[0]);
  }
  return v4;
}

void sub_1885C3898(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
}

CFStringRef createPropertyPrefixFromPath(const __CFString *result)
{
  if (result)
  {
    CFStringRef v1 = result;
    v8.location = 0;
    v8.CFIndex length = 0;
    CFIndex Length = CFStringGetLength(result);
    v9.location = 0;
    v9.CFIndex length = Length;
    int v3 = CFStringFindWithOptions(v1, @"/", v9, 4uLL, &v8);
    if (v3) {
      CFIndex v4 = ~v8.location;
    }
    else {
      CFIndex v4 = 0;
    }
    CFIndex v5 = v4 + Length;
    if (v3) {
      CFIndex v6 = v8.location + 1;
    }
    else {
      CFIndex v6 = 0;
    }
    v10.location = v6;
    v10.CFIndex length = 1;
    int v7 = CFStringFindWithOptions(v1, @"?", v10, 0, &v8);
    if (v7) {
      ++v6;
    }
    v11.CFIndex length = v5 - (v7 != 0);
    v11.location = v6;
    if (CFStringFindWithOptions(v1, @":", v11, 4uLL, &v8))
    {
      v12.CFIndex length = v8.location - v6;
      v12.location = v6;
      return CFStringCreateWithSubstring((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v1, v12);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

void IIOString::IIOString(IIOString *this, CFTypeRef cf)
{
  *(void *)this = &unk_1ED4E5FF8;
  *((void *)this + 1) = 0;
  if (cf)
  {
    CFTypeID v4 = CFGetTypeID(cf);
    if (v4 == CFStringGetTypeID())
    {
      *((void *)this + 2) = CFRetain(cf);
      return;
    }
    IIOLogTypeMismatch(cf, "IIOString", "CFStringRef");
  }
  *((void *)this + 2) = &stru_1ED4F1F48;
  CFRetain(&stru_1ED4F1F48);
}

void *IIOString::createUTF8String(IIOString *this)
{
  CFStringRef v2 = (const __CFString *)*((void *)this + 2);
  if (!v2) {
    return 0;
  }
  CFIndex Length = CFStringGetLength(v2);
  CFIndex MaximumSizeForEncoding = CFStringGetMaximumSizeForEncoding(Length + 1, 0x8000100u);
  CFIndex v5 = malloc_type_malloc(MaximumSizeForEncoding, 0x100004077774924uLL);
  if (v5 && !CFStringGetCString(*((CFStringRef *)this + 2), (char *)v5, MaximumSizeForEncoding, 0x8000100u))
  {
    free(v5);
    return 0;
  }
  return v5;
}

void IIOReadPlugin::addImageTypeIdentifier(IIOReadPlugin *this, CGImage *a2, const __CFString *a3, int a4)
{
  CGImageSetProperty();
  IIONumber::IIONumber((IIONumber *)v6, a4);
  CGImageSetProperty();
  IIONumber::~IIONumber((IIONumber *)v6);
  IIOString::IIOString((IIOString *)v6, *((_DWORD *)this + 51));
  CGImageSetProperty();
  IIOString::~IIOString((IIOString *)v6);
}

void sub_1885C3B9C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  IIOString::~IIOString((IIOString *)va);
  _Unwind_Resume(a1);
}

void IIOString::~IIOString(IIOString *this)
{
  *(void *)this = &unk_1ED4E5FF8;
  CFStringRef v2 = (const void *)*((void *)this + 2);
  if (v2) {
    CFRelease(v2);
  }
  int v3 = (void *)*((void *)this + 1);
  if (v3) {
    free(v3);
  }
}

{
  uint64_t vars8;

  IIOString::~IIOString(this);

  JUMPOUT(0x18C11C0E0);
}

void IIOString::IIOString(IIOString *this, int a2)
{
  *(void *)this = &unk_1ED4E5FF8;
  *((void *)this + 1) = 0;
  char v17 = 0;
  *(_DWORD *)__str = 0;
  unsigned int v4 = a2 >> 24;
  uint64_t v5 = MEMORY[0x1E4F14390];
  if (a2 < 0) {
    int v6 = __maskrune(a2 >> 24, 0x40000uLL);
  }
  else {
    int v6 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v4 + 60) & 0x40000;
  }
  unsigned int v7 = a2 << 8 >> 24;
  if (a2 << 8 < 0) {
    int v8 = __maskrune(a2 << 8 >> 24, 0x40000uLL);
  }
  else {
    int v8 = *(_DWORD *)(v5 + 4 * v7 + 60) & 0x40000;
  }
  unsigned int v9 = (__int16)a2 >> 8;
  if (a2 << 16 < 0) {
    int v10 = __maskrune((__int16)a2 >> 8, 0x40000uLL);
  }
  else {
    int v10 = *(_DWORD *)(v5 + 4 * v9 + 60) & 0x40000;
  }
  if ((a2 << 24) <= 0x7F000000) {
    int v11 = *(_DWORD *)(v5 + 4 * (char)a2 + 60) & 0x40000;
  }
  else {
    int v11 = __maskrune((char)a2, 0x40000uLL);
  }
  if (v10) {
    uint64_t v12 = v9;
  }
  else {
    uint64_t v12 = 46;
  }
  if (v8) {
    uint64_t v13 = v7;
  }
  else {
    uint64_t v13 = 46;
  }
  if (v6) {
    uint64_t v14 = v4;
  }
  else {
    uint64_t v14 = 46;
  }
  if (v11) {
    uint64_t v15 = (char)a2;
  }
  else {
    uint64_t v15 = 46;
  }
  snprintf(__str, 5uLL, "%c%c%c%c", v14, v13, v12, v15);
  *((void *)this + 2) = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], __str, 0x8000100u);
}

BOOL TXMPMeta<std::string>::GetNamespaceURI(XMPMeta *a1, uint64_t a2)
{
  uint64_t v6 = 0;
  memset(v5, 0, sizeof(v5));
  WXMPMeta_GetNamespaceURI_1(a1, a2, (uint64_t (*)(uint64_t, void, void))TXMPMeta<std::string>::SetClientString, (unsigned int *)v5);
  if (*(void *)&v5[0])
  {
    exception = __cxa_allocate_exception(0x18uLL);
    uint64_t v4 = *(void *)&v5[0];
    *(_DWORD *)exception = v6;
    exception[1] = v4;
    *((unsigned char *)exception + 16) = 0;
  }
  return v6 != 0;
}

uint64_t WXMPMeta_GetNamespaceURI_1(XMPMeta *a1, uint64_t a2, uint64_t (*a3)(uint64_t, void, void), unsigned int *a4)
{
  *(void *)a4 = 0;
  if (!a1 || !*(unsigned char *)a1)
  {
    exception = __cxa_allocate_exception(0x18uLL);
    *(_DWORD *)exception = 101;
    exception[1] = "Empty namespace prefix";
    *((unsigned char *)exception + 16) = 0;
  }
  memset(v10, 0, sizeof(v10));
  uint64_t result = XMPMeta::GetNamespaceURI(a1, (const char **)&v10[4], (const char **)v10, a4);
  char v8 = result ^ 1;
  a4[8] = result;
  if (!a2) {
    char v8 = 1;
  }
  if ((v8 & 1) == 0) {
    return a3(a2, *(void *)&v10[4], *(unsigned int *)v10);
  }
  return result;
}

void sub_1885C3EE0(void *a1, int a2)
{
  if (a2 == 3)
  {
    uint64_t v4 = __cxa_begin_catch(a1);
    *(_DWORD *)(v2 + 32) = *(_DWORD *)v4;
    uint64_t v5 = (const char *)*((void *)v4 + 1);
    if (!v5) {
      uint64_t v5 = "";
    }
    *(void *)uint64_t v2 = v5;
    *(void *)(v2 + 8) = "XMP";
  }
  else
  {
    uint64_t v6 = __cxa_begin_catch(a1);
    if (a2 == 2)
    {
      *(_DWORD *)(v2 + 32) = 13;
      uint64_t v7 = (*(uint64_t (**)(void *))(*(void *)v6 + 16))(v6);
      char v8 = "";
      if (v7) {
        char v8 = (const char *)v7;
      }
    }
    else
    {
      *(_DWORD *)(v2 + 32) = 14;
      char v8 = "Caught unknown exception";
    }
    *(void *)uint64_t v2 = v8;
  }
  __cxa_end_catch();
  JUMPOUT(0x1885C3E98);
}

BOOL XMP_NamespaceTable::GetURI(XMP_NamespaceTable *this, char *a2, const char **a3, unsigned int *a4)
{
  char v17 = (XMP_NamespaceTable *)((char *)this + 8);
  XMP_ReadWriteLock::Acquire((pthread_rwlock_t *)((char *)this + 8), 0);
  if (!a2 || !*a2) {
    __assert_rtn("GetURI", "XMP_LibUtils.cpp", 527, "(_prefix != 0) && (*_prefix != 0)");
  }
  memset(&__p, 0, sizeof(__p));
  std::string::basic_string[abi:ne180100]<0>(&__p, a2);
  std::string::size_type size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    p_p = &__p;
  }
  else
  {
    std::string::size_type size = __p.__r_.__value_.__l.__size_;
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  if (p_p->__r_.__value_.__s.__data_[size - 1] != 58) {
    std::string::push_back(&__p, 58);
  }
  uint64_t v10 = std::__tree<std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>>>::find<std::string>((uint64_t)this + 240, (const void **)&__p.__r_.__value_.__l.__data_);
  int v11 = (char *)v10;
  uint64_t v12 = (char *)this + 248;
  if (v12 != (char *)v10)
  {
    if (a3)
    {
      uint64_t v13 = (const char *)(v10 + 56);
      if (*(char *)(v10 + 79) < 0) {
        uint64_t v13 = *(const char **)v13;
      }
      *a3 = v13;
    }
    if (a4)
    {
      if (*(char *)(v10 + 79) < 0) {
        uint64_t v14 = *(void *)(v10 + 64);
      }
      else {
        LODWORD(v14) = *(unsigned __int8 *)(v10 + 79);
      }
      *a4 = v14;
    }
  }
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  XMP_AutoLock::~XMP_AutoLock(&v17);
  return v12 != v11;
}

void sub_1885C40CC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, XMP_ReadWriteLock *a15)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  XMP_AutoLock::~XMP_AutoLock(&a15);
  _Unwind_Resume(a1);
}

BOOL TXMPMeta<std::string>::GetNamespacePrefix(XMPMeta *a1, uint64_t a2)
{
  uint64_t v6 = 0;
  memset(v5, 0, sizeof(v5));
  WXMPMeta_GetNamespacePrefix_1(a1, a2, (uint64_t (*)(uint64_t, void, void))TXMPMeta<std::string>::SetClientString, (unsigned int *)v5);
  if (*(void *)&v5[0])
  {
    exception = __cxa_allocate_exception(0x18uLL);
    uint64_t v4 = *(void *)&v5[0];
    *(_DWORD *)exception = v6;
    exception[1] = v4;
    *((unsigned char *)exception + 16) = 0;
  }
  return v6 != 0;
}

uint64_t WXMPMeta_GetNamespacePrefix_1(XMPMeta *a1, uint64_t a2, uint64_t (*a3)(uint64_t, void, void), unsigned int *a4)
{
  *(void *)a4 = 0;
  if (!a1 || !*(unsigned char *)a1)
  {
    exception = __cxa_allocate_exception(0x18uLL);
    *(_DWORD *)exception = 101;
    exception[1] = "Empty namespace URI";
    *((unsigned char *)exception + 16) = 0;
  }
  memset(v10, 0, sizeof(v10));
  uint64_t result = XMPMeta::GetNamespacePrefix(a1, (const char **)&v10[4], (const char **)v10, a4);
  char v8 = result ^ 1;
  a4[8] = result;
  if (!a2) {
    char v8 = 1;
  }
  if ((v8 & 1) == 0) {
    return a3(a2, *(void *)&v10[4], *(unsigned int *)v10);
  }
  return result;
}

void sub_1885C4234(void *a1, int a2)
{
  if (a2 == 3)
  {
    uint64_t v4 = __cxa_begin_catch(a1);
    *(_DWORD *)(v2 + 32) = *(_DWORD *)v4;
    uint64_t v5 = (const char *)*((void *)v4 + 1);
    if (!v5) {
      uint64_t v5 = "";
    }
    *(void *)uint64_t v2 = v5;
    *(void *)(v2 + 8) = "XMP";
  }
  else
  {
    uint64_t v6 = __cxa_begin_catch(a1);
    if (a2 == 2)
    {
      *(_DWORD *)(v2 + 32) = 13;
      uint64_t v7 = (*(uint64_t (**)(void *))(*(void *)v6 + 16))(v6);
      char v8 = "";
      if (v7) {
        char v8 = (const char *)v7;
      }
    }
    else
    {
      *(_DWORD *)(v2 + 32) = 14;
      char v8 = "Caught unknown exception";
    }
    *(void *)uint64_t v2 = v8;
  }
  __cxa_end_catch();
  JUMPOUT(0x1885C41ECLL);
}

void TXMPMeta<std::string>::SetClientString()
{
}

BOOL XMPMeta::GetNamespacePrefix(XMPMeta *this, const char **a2, const char **a3, unsigned int *a4)
{
  return XMP_NamespaceTable::GetPrefix((XMP_NamespaceTable *)sRegisteredNamespaces, (char *)this, a2, (unsigned int *)a3);
}

BOOL XMPMeta::GetNamespaceURI(XMPMeta *this, const char **a2, const char **a3, unsigned int *a4)
{
  return XMP_NamespaceTable::GetURI((XMP_NamespaceTable *)sRegisteredNamespaces, (char *)this, a2, (unsigned int *)a3);
}

void XMP_Node::GetLocalURI(XMP_Node *this, const char **a2, unsigned int *a3)
{
  if (a2) {
    *a2 = "";
  }
  if (a3) {
    *a3 = 0;
  }
  if (*((char *)this + 39) < 0)
  {
    if (!*((void *)this + 3)) {
      return;
    }
  }
  else if (!*((unsigned char *)this + 39))
  {
    return;
  }
  uint64_t v5 = (const std::string *)((char *)this + 16);
  if ((*((_DWORD *)this + 2) & 0x80000000) != 0)
  {
    if (a2)
    {
      if ((*((unsigned char *)this + 39) & 0x80) != 0) {
        uint64_t v5 = (const std::string *)v5->__r_.__value_.__r.__words[0];
      }
      *a2 = (const char *)v5;
    }
    if (a3)
    {
      if (*((char *)this + 39) < 0) {
        uint64_t v8 = *((void *)this + 3);
      }
      else {
        LODWORD(v8) = *((unsigned __int8 *)this + 39);
      }
      *a3 = v8;
    }
  }
  else
  {
    std::string::size_type v6 = std::string::find((const std::string *)((char *)this + 16), 58, 0);
    if (v6 != -1)
    {
      memset(&v10, 0, sizeof(v10));
      std::string::basic_string(&v10, v5, 0, v6, (std::allocator<char> *)&v9);
      if ((v10.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        uint64_t v7 = &v10;
      }
      else {
        uint64_t v7 = (std::string *)v10.__r_.__value_.__r.__words[0];
      }
      XMP_NamespaceTable::GetURI((XMP_NamespaceTable *)sRegisteredNamespaces, (char *)v7, a2, a3);
      if (SHIBYTE(v10.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v10.__r_.__value_.__l.__data_);
      }
    }
  }
}

void sub_1885C4438(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t TXMPMeta<std::string>::~TXMPMeta(uint64_t a1)
{
  *(void *)a1 = &unk_1ED4E5BD8;
  WXMPMeta_DecrementRefCount_1(*(_DWORD **)(a1 + 8));
  *(void *)(a1 + 8) = 0;
  return a1;
}

void WXMPMeta_DecrementRefCount_1(_DWORD *a1)
{
  {
  }
  uint64_t v4 = (XMP_ReadWriteLock *)(a1 + 4);
  XMP_ReadWriteLock::Acquire((pthread_rwlock_t *)(a1 + 4), 1);
  int v2 = a1[2];
  if (v2 <= 0) {
    __assert_rtn("WXMPMeta_DecrementRefCount_1", "WXMPMeta.cpp", 130, "thiz->clientRefs > 0");
  }
  int v3 = v2 - 1;
  a1[2] = v3;
  if (!v3)
  {
    XMP_ReadWriteLock::Release((XMP_ReadWriteLock *)(a1 + 4));
    uint64_t v4 = 0;
    (*(void (**)(_DWORD *))(*(void *)a1 + 8))(a1);
  }
  XMP_AutoLock::~XMP_AutoLock(&v4);
}

void sub_1885C4588(void *a1)
{
}

void sub_1885C4594(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  XMP_AutoLock::~XMP_AutoLock((XMP_ReadWriteLock **)va);
  _Unwind_Resume(a1);
}

uint64_t TXMPIterator<std::string>::~TXMPIterator(uint64_t a1)
{
  *(void *)a1 = &unk_1ED4DF370;
  WXMPIterator_DecrementRefCount_1(*(_DWORD **)(a1 + 8));
  *(void *)(a1 + 8) = 0;
  return a1;
}

void WXMPIterator_DecrementRefCount_1(_DWORD *a1)
{
  {
  }
  uint64_t v4 = (XMP_ReadWriteLock *)(a1 + 4);
  XMP_ReadWriteLock::Acquire((pthread_rwlock_t *)(a1 + 4), 1);
  int v2 = a1[2];
  if (v2 <= 0) {
    __assert_rtn("WXMPIterator_DecrementRefCount_1", "WXMPIterator.cpp", 105, "thiz->clientRefs > 0");
  }
  int v3 = v2 - 1;
  a1[2] = v3;
  if (!v3)
  {
    XMP_ReadWriteLock::Release((XMP_ReadWriteLock *)(a1 + 4));
    uint64_t v4 = 0;
    (*(void (**)(_DWORD *))(*(void *)a1 + 8))(a1);
  }
  XMP_AutoLock::~XMP_AutoLock(&v4);
}

void sub_1885C46DC(void *a1)
{
}

void sub_1885C46E8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  XMP_AutoLock::~XMP_AutoLock((XMP_ReadWriteLock **)va);
  _Unwind_Resume(a1);
}

void TXMPMeta<std::string>::TXMPMeta(void *a1)
{
  *a1 = &unk_1ED4E5BD8;
  uint64_t v2 = 0;
  memset(v1, 0, sizeof(v1));
  WXMPMeta_CTor_1(v1);
}

{
  _OWORD v1[2];
  uint64_t v2;

  *a1 = &unk_1ED4E5BD8;
  uint64_t v2 = 0;
  memset(v1, 0, sizeof(v1));
  WXMPMeta_CTor_1(v1);
}

void WXMPMeta_CTor_1(void *a1)
{
  *a1 = 0;
  if (sUseNewCoreAPIs) {
    operator new();
  }
  operator new();
}

void sub_1885C4884(void *a1, int a2)
{
  uint64_t v5 = v3;
  MEMORY[0x18C11C0E0](v5, 0x10B3C4030275F38);
  if (a2 == 3)
  {
    uint64_t v7 = __cxa_begin_catch(a1);
    *(_DWORD *)(v2 + 32) = *(_DWORD *)v7;
    uint64_t v8 = (const char *)*((void *)v7 + 1);
    if (!v8) {
      uint64_t v8 = "";
    }
    *(void *)uint64_t v2 = v8;
    *(void *)(v2 + 8) = "XMP";
  }
  else
  {
    char v9 = __cxa_begin_catch(a1);
    if (a2 == 2)
    {
      *(_DWORD *)(v2 + 32) = 13;
      uint64_t v10 = (*(uint64_t (**)(void *))(*(void *)v9 + 16))(v9);
      int v11 = "";
      if (v10) {
        int v11 = (const char *)v10;
      }
    }
    else
    {
      *(_DWORD *)(v2 + 32) = 14;
      int v11 = "Caught unknown exception";
    }
    *(void *)uint64_t v2 = v11;
  }
  __cxa_end_catch();
}

void TXMPMeta<std::string>::SetErrorCallback(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7 = 0;
  memset(v6, 0, sizeof(v6));
  WXMPMeta_SetErrorCallback_1(*(void *)(a1 + 8), (uint64_t)WrapErrorNotify, a2, a3, a4, v6);
  if (*(void *)&v6[0])
  {
    exception = __cxa_allocate_exception(0x18uLL);
    uint64_t v5 = *(void *)&v6[0];
    *(_DWORD *)exception = v7;
    exception[1] = v5;
    *((unsigned char *)exception + 16) = 0;
  }
}

void TXMPMeta<std::string>::ParseFromBuffer(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7 = 0;
  memset(v6, 0, sizeof(v6));
  WXMPMeta_ParseFromBuffer_1(*(void *)(a1 + 8), a2, a3, a4, v6);
  if (*(void *)&v6[0])
  {
    exception = __cxa_allocate_exception(0x18uLL);
    uint64_t v5 = *(void *)&v6[0];
    *(_DWORD *)exception = v7;
    exception[1] = v5;
    *((unsigned char *)exception + 16) = 0;
  }
}

void TXMPIterator<std::string>::Skip(uint64_t a1, uint64_t a2)
{
  uint64_t v5 = 0;
  memset(v4, 0, sizeof(v4));
  WXMPIterator_Skip_1(*(void **)(a1 + 8), a2, v4);
  if (*(void *)&v4[0])
  {
    exception = __cxa_allocate_exception(0x18uLL);
    uint64_t v3 = *(void *)&v4[0];
    *(_DWORD *)exception = v5;
    exception[1] = v3;
    *((unsigned char *)exception + 16) = 0;
  }
}

void WXMPMeta_IncrementRefCount_1(uint64_t a1)
{
  {
  }
  uint64_t v3 = (XMP_ReadWriteLock *)(a1 + 16);
  XMP_ReadWriteLock::Acquire((pthread_rwlock_t *)(a1 + 16), 1);
  int v2 = *(_DWORD *)(a1 + 8);
  *(_DWORD *)(a1 + 8) = v2 + 1;
  if (v2 < 0) {
    __assert_rtn("WXMPMeta_IncrementRefCount_1", "WXMPMeta.cpp", 116, "thiz->clientRefs > 0");
  }
  XMP_AutoLock::~XMP_AutoLock(&v3);
}

void sub_1885C4B7C(void *a1)
{
}

void sub_1885C4B88(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  XMP_AutoLock::~XMP_AutoLock((XMP_ReadWriteLock **)va);
  _Unwind_Resume(a1);
}

uint64_t FindQualifierNode(uint64_t a1, char *__s, int a3, void *a4)
{
  uint64_t v17 = 0;
  if (*__s == 63) {
    FindQualifierNode();
  }
  uint64_t v8 = *(uint64_t **)(a1 + 96);
  uint64_t v9 = *(void *)(a1 + 104) - (void)v8;
  if (v9)
  {
    for (uint64_t i = v9 >> 3; i; --i)
    {
      uint64_t v11 = *v8;
      if (*(void *)(*v8 + 64) != a1) {
        FindQualifierNode();
      }
      uint64_t v12 = (void *)(v11 + 16);
      size_t v13 = strlen(__s);
      if (*(char *)(v11 + 39) < 0)
      {
        if (v13 != *(void *)(v11 + 24)) {
          goto LABEL_13;
        }
        if (v13 == -1) {
LABEL_31:
        }
          std::string::__throw_out_of_range[abi:ne180100]();
        uint64_t v12 = (void *)*v12;
      }
      else
      {
        if (v13 != *(unsigned __int8 *)(v11 + 39)) {
          goto LABEL_13;
        }
        if (v13 == -1) {
          goto LABEL_31;
        }
      }
      if (!memcmp(v12, __s, v13))
      {
        uint64_t v17 = v11;
        if (a4)
        {
          *a4 = v8;
          goto LABEL_18;
        }
        BOOL v14 = v11 == 0;
LABEL_23:
        if (v14 && a3 != 0) {
          FindQualifierNode();
        }
        return v11;
      }
LABEL_13:
      ++v8;
    }
  }
  if (a3) {
    operator new();
  }
LABEL_18:
  uint64_t v11 = v17;
  BOOL v14 = v17 == 0;
  if (!a4 || !v17) {
    goto LABEL_23;
  }
  if (v17 != *(void *)*a4) {
    FindQualifierNode();
  }
  return v11;
}

void sub_1885C4E98(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10B3C407D34617ELL);
  _Unwind_Resume(a1);
}

void IIOTextureHandler::UnlockDataCallback(IIOTextureHandler *this, void *a2)
{
  if ((unsigned __int16)gIIODebugFlags >> 14) {
    ImageIODebugOptions((unsigned __int16)gIIODebugFlags >> 14, "S", "UnlockDataCallback", 0, 0, -1, 0);
  }
  if (this)
  {
    uint64_t v3 = *((void *)this + 1);
    if (v3)
    {
      uint64_t v4 = *(void (**)(void))(*(void *)v3 + 48);
      v4();
    }
  }
}

uint64_t imageio_make_purgeable(void *a1, void *a2)
{
  if ((gIIODebugFlags & 0x202) != 0) {
    ImageIOLog("    imageio_make_purgeable    value: %p   user_data: %p\n", a1, a2);
  }

  return ImageIO_make_purgeable(a1);
}

uint64_t _CGImageReadFinalize(void *a1)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  atomic_fetch_add_explicit(&gReadRefCount, 0xFFFFFFFFFFFFFFFFLL, memory_order_relaxed);
  if ((gIIODebugFlags & 0xC000) != 0)
  {
    *(_OWORD *)__str = 0u;
    long long v6 = 0u;
    uint64_t v2 = a1[3];
    uint64_t v3 = v2 ? (const void *)~*(void *)(v2 + 16) : 0;
    snprintf(__str, 0x20uLL, "(%p)", a1);
    if ((unsigned __int16)gIIODebugFlags >> 14) {
      ImageIODebugOptions((unsigned __int16)gIIODebugFlags >> 14, "S", "_CGImageReadFinalize", v3, __str, -1, 0);
    }
  }
  uint64_t result = a1[3];
  if (result) {
    uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
  }
  a1[2] = 0;
  a1[3] = 0;
  return result;
}

void IIOImageRead::~IIOImageRead(IIOImageRead *this)
{
  IIOImageRead::~IIOImageRead(this);

  JUMPOUT(0x18C11C0E0);
}

{
  char *v2;
  void *v3;
  long long *v4;
  long long *v5;
  int v6;
  long long v7;
  long long v8;
  char *DebugStringFromKey;
  char *v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  void *v14;
  const void *v15;
  const void *v16;
  const void *v17;
  const void *v18;
  void *v19;
  void *v20;
  long long key;
  unsigned char v22[28];

  *(void *)this = &unk_1ED4DF1B0;
  uint64_t v2 = (char *)this + 240;
  uint64_t v3 = (void *)((char *)this + 248);
  std::__tree<std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>>>::destroy((uint64_t)this + 240, *((void **)this + 31));
  *((void *)this + 30) = v3;
  *((void *)this + 32) = 0;
  *uint64_t v3 = 0;
  if ((gIIODebugFlags & 0x200) != 0) {
    ImageIOLog(">>> _cache_keys - deleting %d entries\n", -1171354717 * ((uint64_t)(*((void *)this + 37) - *((void *)this + 36)) >> 2));
  }
  uint64_t v5 = (long long *)*((void *)this + 36);
  uint64_t v4 = (long long *)*((void *)this + 37);
  if (v4 != v5)
  {
    long long v6 = 0;
    do
    {
      *(_OWORD *)&v22[12] = 0u;
      kedouble y = 0u;
      *(_OWORD *)uint64_t v22 = 0u;
      uint64_t v7 = *v5;
      uint64_t v8 = v5[1];
      *(_OWORD *)&v22[12] = *(long long *)((char *)v5 + 28);
      kedouble y = v7;
      *(_OWORD *)uint64_t v22 = v8;
      if ((gIIODebugFlags & 0x200) != 0)
      {
        DebugStringFromKedouble y = createDebugStringFromKey((uint64_t)&key);
        uint64_t v10 = DebugStringFromKey;
        if (DebugStringFromKey)
        {
          ImageIOLog("--- #%d cache_remove             %p key: %s\n", v6++, (const void *)gImageBlockCache, DebugStringFromKey);
          free(v10);
        }
      }
      cache_remove((cache_t *)gImageBlockCache, &key);
      uint64_t v5 = (long long *)((char *)v5 + 44);
    }
    while (v5 != v4);
  }
  if ((gIIODebugFlags & 0x200) != 0) {
    cache_print();
  }
  uint64_t v11 = *((void *)this + 19);
  uint64_t v12 = *((void *)this + 20);
  while (v11 != v12)
  {
    (*(void (**)(void))(v11 + 8))(*(void *)v11);
    v11 += 24;
  }
  if (*((unsigned char *)this + 66))
  {
    size_t v13 = *((_DWORD *)this + 6);
    if ((v13 & 0x80000000) == 0)
    {
      if ((gIIODebugFlags & 0x200000000000) != 0) {
        ImageIOLog("<<< _CGImageReadFinalize <IIOImageRead: %p>: closing file %d\n", this, v13);
      }
      kdebug_trace();
      close(*((_DWORD *)this + 6));
      *((unsigned char *)this + 66) = 0;
    }
  }
  *((_DWORD *)this + 6) = -1;
  BOOL v14 = (void *)*((void *)this + 33);
  if (v14) {
    free(v14);
  }
  uint64_t v15 = (const void *)*((void *)this + 5);
  if (v15) {
    CFRelease(v15);
  }
  *((void *)this + 5) = 0;
  CFDictionaryRef v16 = (const void *)*((void *)this + 4);
  if (v16) {
    CFRelease(v16);
  }
  *((void *)this + 4) = 0;
  uint64_t v17 = (const void *)*((void *)this + 6);
  if (v17) {
    CFRelease(v17);
  }
  *((void *)this + 6) = 0;
  CFStringRef v18 = (const void *)*((void *)this + 7);
  if (v18) {
    CFRelease(v18);
  }
  *((void *)this + 7) = 0;
  pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 176));
  pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 88));
  pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 376));
  pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 312));
  CFTypeID v19 = (void *)*((void *)this + 36);
  if (v19)
  {
    *((void *)this + 37) = v19;
    operator delete(v19);
  }
  std::__tree<std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>>>::destroy((uint64_t)v2, *((void **)this + 31));
  int v20 = (void *)*((void *)this + 19);
  if (v20)
  {
    *((void *)this + 20) = v20;
    operator delete(v20);
  }
}

void std::__tree<std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>>>::destroy(uint64_t a1, void *a2)
{
  if (a2)
  {
    std::__tree<std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>>>::destroy(a1, *a2);
    std::__tree<std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>>>::destroy(a1, a2[1]);
    std::__destroy_at[abi:ne180100]<std::pair<std::string const,std::shared_ptr<IIOBaseObject>>,0>((uint64_t)(a2 + 4));
    operator delete(a2);
  }
}

void GlobalHEIFInfo::~GlobalHEIFInfo(GlobalHEIFInfo *this)
{
  GlobalHEIFInfo::~GlobalHEIFInfo(this);

  JUMPOUT(0x18C11C0E0);
}

{
  const void *v2;
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  unsigned int v6;
  uint64_t v7;
  unsigned char *v8;
  unsigned char *v9;
  unint64_t v10;
  unsigned int v11;
  uint64_t v12;
  void *v13;

  *(void *)this = &unk_1ED4E1148;
  uint64_t v2 = (const void *)*((void *)this + 7);
  if (v2)
  {
    CFRelease(v2);
    *((void *)this + 7) = 0;
  }
  uint64_t v4 = *((void *)this + 1);
  uint64_t v3 = *((void *)this + 2);
  if (v3 != v4)
  {
    uint64_t v5 = 0;
    long long v6 = 1;
    do
    {
      uint64_t v7 = *(void *)(v4 + 8 * v5);
      if (v7)
      {
        (*(void (**)(uint64_t))(*(void *)v7 + 8))(v7);
        uint64_t v4 = *((void *)this + 1);
        uint64_t v3 = *((void *)this + 2);
      }
      uint64_t v5 = v6++;
    }
    while (v5 < (v3 - v4) >> 3);
  }
  uint64_t v8 = (unsigned char *)*((void *)this + 4);
  uint64_t v9 = (unsigned char *)*((void *)this + 5);
  if (v9 == v8)
  {
    uint64_t v8 = (unsigned char *)*((void *)this + 5);
    if (v9)
    {
LABEL_14:
      *((void *)this + 5) = v8;
      operator delete(v8);
    }
  }
  else
  {
    uint64_t v10 = 0;
    uint64_t v11 = 1;
    do
    {
      uint64_t v12 = *(void *)&v8[8 * v10];
      if (v12)
      {
        (*(void (**)(uint64_t))(*(void *)v12 + 8))(v12);
        uint64_t v8 = (unsigned char *)*((void *)this + 4);
        uint64_t v9 = (unsigned char *)*((void *)this + 5);
      }
      uint64_t v10 = v11++;
    }
    while (v10 < (v9 - v8) >> 3);
    if (v8) {
      goto LABEL_14;
    }
  }
  size_t v13 = (void *)*((void *)this + 1);
  if (v13)
  {
    *((void *)this + 2) = v13;
    operator delete(v13);
  }
}

void HEIFMainImage::~HEIFMainImage(HEIFMainImage *this)
{
  HEIFMainImage::~HEIFMainImage(this);

  JUMPOUT(0x18C11C0E0);
}

{
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  void *v9;
  void *v10;
  void *v11;
  void *v12;
  void *v13;
  const void *v14;
  CGColorSpace *v15;
  void *v16;
  void *v17;
  void *v18;
  void *v19;
  void *v20;
  void *v21;

  *(void *)this = &unk_1ED4DFC10;
  uint64_t v2 = (void *)*((void *)this + 1);
  uint64_t v3 = (void *)*((void *)this + 2);
  if (v2 != v3)
  {
    do
    {
      if (*v2) {
        (*(void (**)(void))(*(void *)*v2 + 8))(*v2);
      }
      ++v2;
    }
    while (v2 != v3);
    uint64_t v2 = (void *)*((void *)this + 1);
  }
  *((void *)this + 2) = v2;
  uint64_t v4 = (void *)*((void *)this + 4);
  uint64_t v5 = (void *)*((void *)this + 5);
  if (v4 != v5)
  {
    do
    {
      if (*v4) {
        (*(void (**)(void))(*(void *)*v4 + 8))(*v4);
      }
      ++v4;
    }
    while (v4 != v5);
    uint64_t v4 = (void *)*((void *)this + 4);
  }
  *((void *)this + 5) = v4;
  long long v6 = (void *)*((void *)this + 7);
  uint64_t v7 = (void *)*((void *)this + 8);
  if (v6 != v7)
  {
    do
    {
      if (*v6) {
        (*(void (**)(void))(*(void *)*v6 + 8))(*v6);
      }
      ++v6;
    }
    while (v6 != v7);
    long long v6 = (void *)*((void *)this + 7);
  }
  *((void *)this + 8) = v6;
  uint64_t v8 = (void *)*((void *)this + 10);
  uint64_t v9 = (void *)*((void *)this + 11);
  if (v8 != v9)
  {
    do
    {
      if (*v8) {
        (*(void (**)(void))(*(void *)*v8 + 8))(*v8);
      }
      ++v8;
    }
    while (v8 != v9);
    uint64_t v8 = (void *)*((void *)this + 10);
  }
  *((void *)this + 11) = v8;
  uint64_t v10 = (void *)*((void *)this + 16);
  uint64_t v11 = (void *)*((void *)this + 17);
  if (v10 != v11)
  {
    do
    {
      if (*v10) {
        (*(void (**)(void))(*(void *)*v10 + 8))(*v10);
      }
      ++v10;
    }
    while (v10 != v11);
    uint64_t v10 = (void *)*((void *)this + 16);
  }
  *((void *)this + 17) = v10;
  uint64_t v12 = (void *)*((void *)this + 13);
  size_t v13 = (void *)*((void *)this + 14);
  if (v12 != v13)
  {
    do
    {
      if (*v12) {
        (*(void (**)(void))(*(void *)*v12 + 8))(*v12);
      }
      ++v12;
    }
    while (v12 != v13);
    uint64_t v12 = (void *)*((void *)this + 13);
  }
  *((void *)this + 14) = v12;
  BOOL v14 = (const void *)*((void *)this + 36);
  if (v14) {
    CFRelease(v14);
  }
  uint64_t v15 = (CGColorSpace *)*((void *)this + 37);
  if (v15) {
    CGColorSpaceRelease(v15);
  }
  CFDictionaryRef v16 = (void *)*((void *)this + 16);
  if (v16)
  {
    *((void *)this + 17) = v16;
    operator delete(v16);
  }
  uint64_t v17 = (void *)*((void *)this + 13);
  if (v17)
  {
    *((void *)this + 14) = v17;
    operator delete(v17);
  }
  CFStringRef v18 = (void *)*((void *)this + 10);
  if (v18)
  {
    *((void *)this + 11) = v18;
    operator delete(v18);
  }
  CFTypeID v19 = (void *)*((void *)this + 7);
  if (v19)
  {
    *((void *)this + 8) = v19;
    operator delete(v19);
  }
  int v20 = (void *)*((void *)this + 4);
  if (v20)
  {
    *((void *)this + 5) = v20;
    operator delete(v20);
  }
  uint64_t v21 = (void *)*((void *)this + 1);
  if (v21)
  {
    *((void *)this + 2) = v21;
    operator delete(v21);
  }
}

uint64_t globalHEIFInfoReleaseProc(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void HEIFExif::~HEIFExif (HEIFExif *this)
{
  *(void *)this = &unk_1ED4E5B78;
  JUMPOUT(0x18C11C0E0);
}

{
  *(void *)this = &unk_1ED4E5B78;
}

uint64_t IIO_TerminateXMPToolkit()
{
  CFAllocatorRef v0 = (XMPFiles *)pthread_mutex_lock(&xmpLock);
  WXMPFiles_Terminate_1(v0);
  WXMPMeta_Terminate_1(v1);

  return pthread_mutex_unlock(&xmpLock);
}

void WXMPFiles_Terminate_1(XMPFiles *a1)
{
  if (voidResult(void)::onceToken != -1) {
    dispatch_once(&voidResult(void)::onceToken, &__block_literal_global_44);
  }
  *(void *)gVoidResult = 0;
  XMPFiles::Terminate(a1);
}

void sub_1885C590C(void *a1)
{
  __cxa_begin_catch(a1);
  __cxa_end_catch();
}

void (**png_write_sRGB(void (**a1)(void), int a2))(void)
{
  Bytef v2 = a2;
  if (a2 >= 4) {
    png_warning((uint64_t)a1, "Invalid sRGB rendering intent specified");
  }
  Bytef v5 = v2;
  return _cg_png_write_complete_chunk(a1, 1934772034, &v5, 1uLL);
}

void (**png_write_pHYs(void (**a1)(void), int a2, int a3, int a4))(void)
{
  Bytef v4 = a4;
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  if (a4 >= 2) {
    png_warning((uint64_t)a1, "Unrecognized unit type for pHYs chunk");
  }
  v9[0] = HIBYTE(a2);
  v9[1] = BYTE2(a2);
  _DWORD v9[2] = BYTE1(a2);
  void v9[3] = a2;
  void v9[4] = HIBYTE(a3);
  v9[5] = BYTE2(a3);
  v9[6] = BYTE1(a3);
  v9[7] = a3;
  v9[8] = v4;
  return _cg_png_write_complete_chunk(a1, 1883789683, v9, 9uLL);
}

uint64_t png_text_compress(uint64_t a1, int a2, uint64_t a3, int a4)
{
  uint64_t v7 = png_deflate_claim(a1, a2, *(void *)(a3 + 8));
  if (v7) {
    return v7;
  }
  unint64_t v8 = *(void *)(a3 + 8);
  *(void *)(a1 + 96) = *(void *)a3;
  uint64_t v9 = (void **)(a1 + 208);
  *(void *)(a1 + 120) = a3 + 20;
  int v10 = 1024;
  *(_DWORD *)(a1 + 128) = 1024;
  while (1)
  {
    if (v8 >= 0xFFFFFFFF) {
      uint64_t v11 = 0xFFFFFFFFLL;
    }
    else {
      uint64_t v11 = v8;
    }
    v8 -= v11;
    *(_DWORD *)(a1 + 104) = v11;
    if (*(_DWORD *)(a1 + 128)) {
      goto LABEL_12;
    }
    if (v10 + a4 < 0) {
      goto LABEL_14;
    }
    uint64_t v12 = *v9;
    if (!*v9) {
      break;
    }
LABEL_11:
    *(void *)(a1 + 120) = v12[1];
    int v13 = *(_DWORD *)(a1 + 216);
    *(_DWORD *)(a1 + 128) = v13;
    v10 += v13;
    uint64_t v9 = (void **)v12;
LABEL_12:
    uint64_t v14 = deflate((z_streamp)(a1 + 96), 4 * (v8 == 0));
    v8 += *(unsigned int *)(a1 + 104);
    *(_DWORD *)(a1 + 104) = 0;
    if (v14)
    {
      uint64_t v7 = v14;
      goto LABEL_15;
    }
  }
  uint64_t v12 = png_malloc_base(a1, *(unsigned int *)(a1 + 216) + 16);
  if (v12)
  {
    *uint64_t v12 = 0;
    v12[1] = v12 + 2;
    *uint64_t v9 = v12;
    goto LABEL_11;
  }
LABEL_14:
  uint64_t v7 = 4294967292;
LABEL_15:
  int v15 = v10 - *(_DWORD *)(a1 + 128);
  *(_DWORD *)(a1 + 128) = 0;
  *(_DWORD *)(a3 + 16) = v15;
  if ((v15 + a4) < 0x7FFFFFFF)
  {
    png_zstream_error(a1, v7);
    *(_DWORD *)(a1 + 92) = 0;
    if (v7 == 1 && !v8)
    {
      optimize_cmf((unsigned __int8 *)(a3 + 20), *(void *)(a3 + 8));
      return 0;
    }
  }
  else
  {
    *(void *)(a1 + 144) = "compressed data too long";
    *(_DWORD *)(a1 + 92) = 0;
    return 4294967292;
  }
  return v7;
}

uint64_t png_write_iCCP(uint64_t a1, unsigned __int8 *a2, uint64_t a3)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  if (!a3)
  {
    uint64_t v11 = "No profile for iCCP chunk";
    goto LABEL_15;
  }
  uint64_t v5 = _byteswap_ulong(*(_DWORD *)a3);
  if (v5 <= 0x83)
  {
    uint64_t v11 = "ICC profile too short";
    goto LABEL_15;
  }
  if ((*(unsigned char *)(a3 + 3) & 3) != 0 && *(unsigned __int8 *)(a3 + 8) >= 4u)
  {
    uint64_t v11 = "ICC profile length invalid (not a multiple of 4)";
    goto LABEL_15;
  }
  memset(v14, 0, 81);
  bzero(v13, 0x408uLL);
  int v8 = png_check_keyword(a1, a2, v14);
  if (!v8)
  {
    uint64_t v11 = "iCCP: invalid keyword";
    goto LABEL_15;
  }
  v14[v8 + 1] = 0;
  uint64_t v9 = (v8 + 2);
  v12[0] = a3;
  v12[1] = v5;
  v13[0] = 0;
  if (png_text_compress(a1, 1766015824, (uint64_t)v12, v9))
  {
    uint64_t v11 = *(const char **)(a1 + 144);
LABEL_15:
    _cg_png_error((void (**)(void))a1, v11);
  }
  _cg_png_write_chunk_header(a1, 1766015824);
  _cg_png_write_chunk_data(a1, v14, v9);
  png_write_compressed_data_out(a1, (uint64_t)v12);
  return _cg_png_write_chunk_end(a1);
}

uint64_t PNGWritePlugin::writePNG(PNGWritePlugin *this, IIOImagePixelDataProvider *a2, IIODictionary *a3)
{
  uint64_t v91 = *MEMORY[0x1E4F143B8];
  int v89 = 0;
  unint64_t v87 = 0;
  unint64_t v88 = 0;
  IIOImageSource::imageReadRef(a2);
  CGImageGetImageProvider();
  uint64_t Property = CGImageProviderGetProperty();
  unsigned int BitmapInfo = IIOImagePixelDataProvider::getBitmapInfo(a2);
  vImagePixelCount v8 = IIOImageSource::count(a2);
  uint64_t v9 = IIO_Reader::testHeaderSize(a2);
  unint64_t v10 = IIOImagePlus::sourceImageProvider(a2);
  unint64_t Error = _cg_GifLastError((uint64_t)a2);
  unint64_t appleflags = _cg_png_get_appleflags((uint64_t)a2);
  int v81 = a2;
  int v13 = a2;
  unint64_t v14 = Error;
  unint64_t v15 = appleflags;
  SourceGeomColorSpace = (CGColorSpace *)IIOImagePlus::getSourceGeomColorSpace(v13);
  CGColorSpaceModel Model = CGColorSpaceGetModel(SourceGeomColorSpace);
  CGImageProviderGetProperty();
  if (*((unsigned char *)this + 36))
  {
    ImageIOLog("  --- writePNG <%p>------\n, this", v72);
    ImageIOLog("            size: %d x %d\n", v8, v9);
    ImageIOLog("        rowBytes: %d\n", v10);
    ImageIOLog("             bpc: %d\n", v14);
    ImageIOLog("             bpp: %d\n", v15);
    uint64_t v17 = IIO_BitmapInfoString(BitmapInfo);
    CFStringRef v18 = IIO_AlphaInfoString(BitmapInfo);
    ImageIOLog("      bitmapInfo: %X '%s + %s'\n", BitmapInfo, v17, v18);
  }
  unint64_t v76 = v9;
  if ((BitmapInfo & 0x1000) != 0)
  {
    CFTypeID v19 = a3;
    if (v14 == 16)
    {
      int v84 = (BitmapInfo >> 8) & 1;
    }
    else
    {
      LogError("writePNG", 235, "BAD bitmapInfo: use 'ByteOrder16Little' or 'ByteOrder16Big' only for 16-bpc images\n");
      int v84 = 0;
    }
  }
  else
  {
    int v84 = 0;
    CFTypeID v19 = a3;
  }
  if ((BitmapInfo & 0x6000) != 0 && v14 != 32 && v15 != 32) {
    LogError("writePNG", 243, "BAD bitmapInfo: use 'ByteOrder32Little' or 'ByteOrder32Big' only for 32-bpp images\n");
  }
  size_t rowbytes = v10;
  if (_cg_png_get_rowbytes(*((void *)this + 5), *((void *)this + 6)) > v10) {
    size_t rowbytes = _cg_png_get_rowbytes(*((void *)this + 5), *((void *)this + 6));
  }
  if (rowbytes != v10 || *MEMORY[0x1E4F1CFD0] == Property)
  {
    unint64_t v87 = v10;
    unint64_t v88 = 1;
    uint64_t v21 = (char *)malloc_type_malloc(rowbytes, 0x7723A3FFuLL);
  }
  else
  {
    uint64_t v21 = (char *)IIOImagePixelDataProvider::createEncodingTempBuffer(v81, &v88, &v87);
  }
  int v89 = v21;
  uint64_t v74 = (int)_cg_png_set_interlace_handling(*((void *)this + 5));
  if (v14 == 16) {
    _cg_png_set_swap(*((void *)this + 5));
  }
  if (IIODictionary::containsKey(v19, @"PencilKitPrivateData"))
  {
    CFDictionaryRef ObjectForKey = IIODictionary::getObjectForKey(v19, @"PencilKitPrivateData");
    if (ObjectForKey)
    {
      CFDataRef v23 = ObjectForKey;
      unint64_t v24 = v15;
      BytePtr = CFDataGetBytePtr(ObjectForKey);
      unsigned int Length = CFDataGetLength(v23);
      dest.std::string::pointer data = (void *)0x74694B7001000000;
      LODWORD(dest.height) = bswap32(Length);
      uint64_t v27 = Length;
      _cg_png_write_chunk_header(*((void *)this + 5), 1634750532);
      _cg_png_write_chunk_data(*((void *)this + 5), (Bytef *)&dest, 12);
      unint64_t v28 = (Bytef *)BytePtr;
      unint64_t v15 = v24;
      _cg_png_write_chunk_data(*((void *)this + 5), v28, v27);
      _cg_png_write_chunk_end(*((void *)this + 5));
    }
  }
  unsigned int Uint32ForKey = IIODictionary::getUint32ForKey(v19, @"kCGImagePropertyPNGBandCount");
  if (Uint32ForKey >= 0x10) {
    unint64_t v30 = 16;
  }
  else {
    unint64_t v30 = Uint32ForKey;
  }
  unint64_t v82 = v30;
  if (!v74)
  {
    uint64_t v41 = 0;
    unint64_t v35 = v76;
LABEL_88:
    if (v41 == v35) {
      uint64_t v70 = 0;
    }
    else {
      uint64_t v70 = 4294967246;
    }
    goto LABEL_91;
  }
  if (v74 == 1 && !*((unsigned char *)this + 122) && v76 >= v30 && Model != kCGColorSpaceModelIndexed)
  {
    unint64_t Size = IIOImageWriteSession::getSize(*((IIOImageWriteSession **)this + 2));
    uint64_t v31 = (Bytef *)malloc_type_calloc(12 * v82 + 4, 1uLL, 0xE9E3B020uLL);
    unint64_t v80 = 12 * v82 + 4;
    _cg_png_write_chunk(*((void (***)(void))this + 5), (unsigned int *)"iDOT", v31, v80);
    *(_DWORD *)uint64_t v31 = v82 << 24;
    _cg_png_set_write_fn(*((void **)this + 5), *((void *)this + 2), (size_t (*)(size_t, void *, size_t))write_fn, (uint64_t (*)(uint64_t))flush_fn_noop);
    char do_filter = _cg_png_get_do_filter(*((void *)this + 5));
    _cg_png_set_do_filter(*((void *)this + 5), do_filter & 0x1F);
    uint64_t v33 = 0;
    unint64_t v34 = 0;
    unint64_t v35 = v76;
    unint64_t v36 = (v76 + v82 - 1) / v82;
    do
    {
      if (v36 + v34 >= v35) {
        unint64_t v36 = v35 - v34;
      }
      uint64_t v37 = &v31[12 * v33];
      int v38 = IIOImageWriteSession::getSize(*((IIOImageWriteSession **)this + 2));
      *((_DWORD *)v37 + 1) = bswap32(v34);
      *((_DWORD *)v37 + 2) = bswap32(v36);
      *((_DWORD *)v37 + 3) = bswap32(v38 - Size);
      uint64_t v39 = v36 + v34;
      if (v34 >= v36 + v34)
      {
        uint64_t v41 = v34;
      }
      else
      {
        while (1)
        {
          uint64_t v40 = v89;
          if (IIOImagePixelDataProvider::getBytes((uint64_t (**)(IIOImagePixelDataProvider *, void *))v81, v89) != v10)break; {
          _cg_png_write_row_sized(*((void *)this + 5), v40);
          }
          if (v39 == ++v34)
          {
            uint64_t v41 = v39;
            goto LABEL_40;
          }
        }
        uint64_t v41 = v34;
LABEL_40:
        unint64_t v35 = v76;
      }
      if (v33 != v82 - 1) {
        _cg_png_insert_iDOTBreak(*((void *)this + 5));
      }
      ++v33;
      unint64_t v34 = v39;
    }
    while (v33 != v82);
    _cg_png_set_write_fn(*((void **)this + 5), *((void *)this + 2), (size_t (*)(size_t, void *, size_t))write_fn, (uint64_t (*)(uint64_t))flush_fn);
    uint64_t v42 = IIOImageWriteSession::getSize(*((IIOImageWriteSession **)this + 2));
    IIOImageWriteSession::seek(*((IIOImageWriteSession **)this + 2), Size, 0);
    _cg_png_write_chunk(*((void (***)(void))this + 5), (unsigned int *)"iDOT", v31, v80);
    free(v31);
    IIOImageWriteSession::seek(*((IIOImageWriteSession **)this + 2), v42, 0);
    goto LABEL_88;
  }
  uint64_t v43 = 0;
  int v83 = BitmapInfo & 0x1F;
  int v78 = v14;
  vImagePixelCount v75 = v15 / v14 * v8;
  unint64_t v35 = v76;
  while (1)
  {
    uint64_t v73 = v43;
    uint64_t v41 = 0;
    if (v35) {
      break;
    }
LABEL_83:
    uint64_t v43 = v73 + 1;
    IIOImagePixelDataProvider::rewind(v81);
    if (v73 + 1 == v74) {
      goto LABEL_88;
    }
  }
  unint64_t v45 = v87;
  unint64_t v44 = v88;
  while (1)
  {
    if (v44 + v41 > v35)
    {
      unint64_t v44 = v35 - v41;
      unint64_t v45 = (v35 - v41) * v10;
    }
    if (!v45) {
      goto LABEL_86;
    }
    uint64_t Bytes = IIOImagePixelDataProvider::getBytes((uint64_t (**)(IIOImagePixelDataProvider *, void *))v81, v89);
    if (Bytes != v45) {
      break;
    }
    uint64_t v77 = v41;
    uint64_t v47 = v89;
    dest.std::string::pointer data = v89;
    dest.unsigned int height = 1;
    dest.width = v75;
    dest.rowuint64_t Bytes = v10;
    src.std::string::pointer data = v89;
    src.unsigned int height = 1;
    src.width = v8;
    src.rowuint64_t Bytes = v10;
    if (v44)
    {
      unint64_t v48 = 0;
      uint64_t v49 = &v89[2 * v8 - 1];
      BOOL v50 = &v89[4 * v8 - 2];
      while (1)
      {
        if (*((unsigned char *)this + 122))
        {
          if (*((unsigned char *)this + 84) == 4)
          {
            if (v8)
            {
              uint64_t v51 = 4 * v8 - 4;
              vImagePixelCount v52 = v8;
              do
              {
                unint64_t v53 = v47[v52 - 1];
                unint64_t v54 = v53 & 0xF;
                unint64_t v55 = *((void *)this + 13) - 1;
                BOOL v56 = v55 >= v53 >> 4;
                uint64_t v57 = v53 >> 4;
                if (!v56) {
                  uint64_t v57 = *((void *)this + 13) - 1;
                }
                if (v55 < v54) {
                  unint64_t v54 = *((void *)this + 13) - 1;
                }
                uint64_t v58 = 3 * v57;
                int v59 = &v47[v51];
                *int v59 = *(unsigned char *)(*((void *)this + 14) + v58);
                v59[1] = *(unsigned char *)(v58 + *((void *)this + 14) + 1);
                v59[2] = *(unsigned char *)(v58 + *((void *)this + 14) + 2);
                CFTypeRef v59[3] = 17 * v54;
                v51 -= 4;
                --v52;
              }
              while (v52);
            }
          }
          else
          {
            uint64_t v62 = v50;
            uint64_t v63 = v49;
            for (vImagePixelCount i = v8; i; --i)
            {
              unint64_t v65 = *(v63 - 1);
              unsigned int v67 = *v63;
              v63 -= 2;
              unint64_t v66 = v67;
              unint64_t v68 = *((void *)this + 13) - 1;
              if (v68 < v65) {
                unint64_t v65 = *((void *)this + 13) - 1;
              }
              if (v68 < v66) {
                unint64_t v66 = *((void *)this + 13) - 1;
              }
              uint64_t v69 = 3 * v65;
              *(v62 - 2) = *(unsigned char *)(*((void *)this + 14) + v69);
              *(v62 - 1) = *(unsigned char *)(v69 + *((void *)this + 14) + 1);
              *uint64_t v62 = *(unsigned char *)(v69 + *((void *)this + 14) + 2);
              v62[1] = v66;
              v62 -= 4;
            }
          }
          goto LABEL_81;
        }
        if (v84)
        {
          dest.std::string::pointer data = v47;
          vImage_Error v60 = vImageConvert_16Fto16U(&dest, &dest, 0);
          if (v60) {
            _cg_jpeg_mem_term("writePNG", 492, "    vImageConvert_16Uto16F err=%d\n", v60);
          }
        }
        if (v83 != 1) {
          goto LABEL_81;
        }
        src.std::string::pointer data = v47;
        if (Model != kCGColorSpaceModelRGB) {
          goto LABEL_81;
        }
        if (v78 == 16) {
          break;
        }
        vImage_Error v61 = vImageUnpremultiplyData_RGBA8888(&src, &src, 0);
        if (v61) {
          goto LABEL_80;
        }
LABEL_81:
        _cg_png_write_row_sized(*((void *)this + 5), v47);
        ++v48;
        v47 += v10;
        v49 += v10;
        v50 += v10;
        if (v44 <= v48) {
          goto LABEL_82;
        }
      }
      vImage_Error v61 = vImageUnpremultiplyData_RGBA16U(&src, &src, 0);
      if (!v61) {
        goto LABEL_81;
      }
LABEL_80:
      _cg_jpeg_mem_term("writePNG", 514, "    vImageUnpremultiply err=%d  (%d bpc)\n", v61, v78);
      goto LABEL_81;
    }
LABEL_82:
    unint64_t v35 = v76;
    uint64_t v41 = v44 + v77;
    if (v44 + v77 >= v76) {
      goto LABEL_83;
    }
  }
  _cg_jpeg_mem_term("writePNG", 438, "    iPixelDataProvider->getBytes asked for %ld bytes - got %d bytes\n", v45, Bytes);
LABEL_86:
  uint64_t v70 = 4294967246;
LABEL_91:
  if (v89) {
    free(v89);
  }
  return v70;
}

void _cg_png_write_row_sized(uint64_t a1, void *__src)
{
  if (!a1) {
    return;
  }
  if (!*(_DWORD *)(a1 + 308) && !*(unsigned char *)(a1 + 389))
  {
    if ((*(unsigned char *)(a1 + 77) & 4) == 0)
    {
      CFDataRef v23 = "png_write_info was never called before png_write_row";
      goto LABEL_68;
    }
    _cg_png_write_start_row(a1);
  }
  if (!*(unsigned char *)(a1 + 388) || (*(unsigned char *)(a1 + 88) & 2) == 0)
  {
LABEL_8:
    uint64_t v24 = 0;
    size_t v25 = 0;
    unsigned int v4 = *(_DWORD *)(a1 + 292);
    char v5 = *(unsigned char *)(a1 + 396);
    char v6 = *(unsigned char *)(a1 + 393);
    if ((v6 * v5) >= 8u) {
      size_t v7 = v4 * (unint64_t)((v6 * v5) >> 3);
    }
    else {
      size_t v7 = ((v6 * v5) * (unint64_t)v4 + 7) >> 3;
    }
    unsigned __int8 v8 = *(unsigned char *)(a1 + 391);
    size_t v25 = v7;
    uint64_t v26 = v8;
    LODWORD(v24) = v4;
    BYTE2(v26) = v5;
    BYTE1(v26) = v6;
    *(_DWORD *)((char *)&v26 + 3) = (v6 * v5);
    memcpy((void *)(*(void *)(a1 + 328) + 1), __src, v7);
    if (*(unsigned char *)(a1 + 388))
    {
      unsigned int v10 = *(unsigned __int8 *)(a1 + 389);
      if (v10 <= 5 && (*(unsigned char *)(a1 + 88) & 2) != 0)
      {
        png_do_write_interlace((uint64_t)&v24, (unsigned __int8 *)(*(void *)(a1 + 328) + 1), v10);
        if (!v24)
        {
          png_write_finish_row(a1);
          return;
        }
      }
    }
    if (*(_DWORD *)(a1 + 88)) {
      png_do_write_transformations(a1, (int *)&v24, v9);
    }
    if (BYTE3(v26) == *(unsigned __int8 *)(a1 + 394) && BYTE3(v26) == *(unsigned __int8 *)(a1 + 399))
    {
      if ((*(unsigned char *)(a1 + 760) & 4) == 0 || *(unsigned char *)(a1 + 764) != 64) {
        goto LABEL_60;
      }
      int v11 = v26;
      if ((v26 & 2) == 0) {
        goto LABEL_61;
      }
      uint64_t v12 = *(void *)(a1 + 328);
      int v13 = v24;
      if (BYTE1(v26) != 16)
      {
        if (BYTE1(v26) == 8)
        {
          if (v26 == 2)
          {
            uint64_t v14 = 3;
LABEL_52:
            if (v24)
            {
              CFDictionaryRef v16 = (unsigned char *)(v12 + 3);
              do
              {
                char v17 = *(v16 - 1);
                *(v16 - 2) -= v17;
                *v16 -= v17;
                v16 += v14;
                --v13;
              }
              while (v13);
            }
            goto LABEL_60;
          }
          if (v26 == 6)
          {
            uint64_t v14 = 4;
            goto LABEL_52;
          }
        }
LABEL_60:
        int v11 = v26;
LABEL_61:
        if (v11 == 3 && (*(_DWORD *)(a1 + 380) & 0x80000000) == 0) {
          png_do_check_palette_indexes(a1, (uint64_t)&v24);
        }
        png_write_find_filter(a1, (uint64_t)&v24);
        uint64_t v22 = *(void (**)(uint64_t, void, void))(a1 + 552);
        if (v22) {
          v22(a1, *(unsigned int *)(a1 + 308), *(unsigned __int8 *)(a1 + 389));
        }
        return;
      }
      if (v26 == 2)
      {
        uint64_t v15 = 6;
      }
      else
      {
        if (v26 != 6) {
          goto LABEL_60;
        }
        uint64_t v15 = 8;
      }
      if (v24)
      {
        CFStringRef v18 = (unsigned __int16 *)(v12 + 3);
        do
        {
          unsigned int v19 = bswap32(*v18);
          unsigned int v20 = __rev16(*(v18 - 1)) - HIWORD(v19);
          unsigned int v21 = __rev16(v18[1]) - HIWORD(v19);
          *((unsigned char *)v18 - 2) = BYTE1(v20);
          *((unsigned char *)v18 - 1) = v20;
          *((unsigned char *)v18 + 2) = BYTE1(v21);
          *((unsigned char *)v18 + 3) = v21;
          CFStringRef v18 = (unsigned __int16 *)((char *)v18 + v15);
          --v13;
        }
        while (v13);
      }
      goto LABEL_60;
    }
    CFDataRef v23 = "internal write transform logic error";
LABEL_68:
    _cg_png_error((void (**)(void))a1, v23);
  }
  switch(*(unsigned char *)(a1 + 389))
  {
    case 0:
      if ((*(unsigned char *)(a1 + 308) & 7) == 0) {
        goto LABEL_8;
      }
      goto LABEL_45;
    case 1:
      if ((*(unsigned char *)(a1 + 308) & 7) != 0 || *(_DWORD *)(a1 + 280) <= 4u) {
        goto LABEL_45;
      }
      goto LABEL_8;
    case 2:
      if ((*(_DWORD *)(a1 + 308) & 7) != 4) {
        goto LABEL_45;
      }
      goto LABEL_8;
    case 3:
      if ((*(unsigned char *)(a1 + 308) & 3) != 0 || *(_DWORD *)(a1 + 280) <= 2u) {
        goto LABEL_45;
      }
      goto LABEL_8;
    case 4:
      if ((*(_DWORD *)(a1 + 308) & 3) != 2) {
        goto LABEL_45;
      }
      goto LABEL_8;
    case 5:
      if ((*(unsigned char *)(a1 + 308) & 1) != 0 || *(_DWORD *)(a1 + 280) <= 1u) {
        goto LABEL_45;
      }
      goto LABEL_8;
    case 6:
      if (*(unsigned char *)(a1 + 308)) {
        goto LABEL_8;
      }
LABEL_45:
      png_write_finish_row(a1);
      break;
    default:
      goto LABEL_8;
  }
}

void png_write_find_filter(uint64_t a1, uint64_t a2)
{
  int v3 = *(unsigned __int8 *)(a1 + 390);
  unint64_t v4 = *(void *)(a2 + 8);
  uint64_t v5 = *(unsigned __int8 *)(a2 + 19);
  unint64_t v6 = (unint64_t)(v5 + 7) >> 3;
  uint64_t v7 = *(void *)(a1 + 328);
  if (v4 < 0x1FFFFFFFFFFFFFFLL)
  {
    unint64_t v8 = -257;
    if ((v3 & 8) != 0 && v3 != 8)
    {
      int v15 = AppleGetCPUCapabilities() & 0x100;
      if (v6 != 4 || v15 == 0)
      {
        unint64_t v8 = 0;
        if (v4)
        {
          char v17 = (unsigned __int8 *)(v7 + 1);
          unint64_t v18 = v4;
          do
          {
            int v20 = *v17++;
            LODWORD(v19) = v20;
            unsigned int v21 = 256 - v20;
            if ((v20 & 0x80u) == 0) {
              uint64_t v19 = v19;
            }
            else {
              uint64_t v19 = v21;
            }
            v8 += v19;
            --v18;
          }
          while (v18);
        }
      }
      else
      {
        unint64_t v8 = png_write_filter_row_none_neon((int8x16_t *)(v7 + 1), v7 + 1, v4);
      }
    }
  }
  else
  {
    v3 &= -v3;
    unint64_t v8 = -257;
  }
  if (v3 == 16)
  {
    uint8x8_t v9 = *(unsigned char **)(a1 + 336);
    *uint8x8_t v9 = 1;
    unsigned int v10 = v9 + 1;
    int v11 = (char *)(v7 + 1);
    if (v5)
    {
      unint64_t v12 = (unint64_t)(v5 + 7) >> 3;
      int v13 = (char *)(v7 + 1);
      do
      {
        char v14 = *v13++;
        *v10++ = v14;
        --v12;
      }
      while (v12);
    }
    else
    {
      int v13 = (char *)(v7 + 1);
    }
    unint64_t v30 = v4 - v6;
    if (v4 > v6)
    {
      do
      {
        char v32 = *v13++;
        char v31 = v32;
        char v33 = *v11++;
        *v10++ = v31 - v33;
        --v30;
      }
      while (v30);
    }
  }
  else
  {
    uint8x8_t v9 = (unsigned char *)v7;
    if ((v3 & 0x10) != 0)
    {
      uint64_t v22 = *(unsigned char **)(a1 + 336);
      *uint64_t v22 = 1;
      CFDataRef v23 = v22 + 1;
      __int16 CPUCapabilities = AppleGetCPUCapabilities();
      if (v6 == 4 && (CPUCapabilities & 0x100) != 0)
      {
        unint64_t v29 = png_write_filter_row_sub_neon((int8x16_t *)(v7 + 1), v23, v4, v25, v26, v27, v28);
      }
      else
      {
        unint64_t v34 = (char *)(v7 + 1);
        unint64_t v29 = 0;
        if (v5)
        {
          uint64_t v35 = v6;
          unint64_t v36 = (char *)(v7 + 1);
          do
          {
            int v38 = *v36++;
            LODWORD(v37) = v38;
            *v23++ = v38;
            unsigned int v39 = 256 - v38;
            if ((v38 & 0x80u) == 0) {
              uint64_t v37 = v37;
            }
            else {
              uint64_t v37 = v39;
            }
            v29 += v37;
            --v35;
          }
          while (v35);
        }
        else
        {
          unint64_t v36 = (char *)(v7 + 1);
        }
        if (v4 > v6)
        {
          unint64_t v40 = v6 + 1;
          do
          {
            char v42 = *v36++;
            char v41 = v42;
            char v43 = *v34++;
            unsigned __int8 v44 = v41 - v43;
            int v45 = (char)v44;
            *v23++ = v44;
            unsigned int v46 = v44;
            LODWORD(v47) = 256 - v44;
            if (v45 >= 0) {
              uint64_t v47 = v46;
            }
            else {
              uint64_t v47 = v47;
            }
            v29 += v47;
          }
          while (v29 <= v8 && v40++ < v4);
        }
      }
      if (v29 < v8)
      {
        uint64_t v49 = *(void *)(a1 + 344);
        if (v49)
        {
          *(void *)(a1 + 336) = v49;
          *(void *)(a1 + 344) = v22;
        }
        unint64_t v8 = v29;
        uint8x8_t v9 = v22;
      }
    }
  }
  if (v3 == 32)
  {
    png_setup_up_row((void *)a1, v4, v8, (unint64_t)(v5 + 7) >> 3);
    uint8x8_t v9 = *(unsigned char **)(a1 + 336);
LABEL_54:
    uint64_t v50 = a2;
    goto LABEL_55;
  }
  if ((v3 & 0x20) != 0)
  {
    unint64_t v53 = png_setup_up_row((void *)a1, v4, v8, (unint64_t)(v5 + 7) >> 3);
    if (v53 < v8)
    {
      uint8x8_t v9 = *(unsigned char **)(a1 + 336);
      uint64_t v54 = *(void *)(a1 + 344);
      if (v54)
      {
        *(void *)(a1 + 336) = v54;
        *(void *)(a1 + 344) = v9;
      }
      unint64_t v8 = v53;
    }
  }
  if (v3 == 64)
  {
    uint8x8_t v9 = *(unsigned char **)(a1 + 336);
    *uint8x8_t v9 = 3;
    unint64_t v55 = v9 + 1;
    BOOL v56 = (unsigned __int8 *)(*(void *)(a1 + 320) + 1);
    uint64_t v57 = (unsigned __int8 *)(v7 + 1);
    if (v5)
    {
      unint64_t v58 = (unint64_t)(v5 + 7) >> 3;
      int v59 = (char *)(v7 + 1);
      do
      {
        char v61 = *v59++;
        char v60 = v61;
        unsigned int v62 = *v56++;
        *v55++ = v60 - (v62 >> 1);
        LODWORD(v58) = v58 - 1;
      }
      while (v58);
    }
    else
    {
      int v59 = (char *)(v7 + 1);
    }
    if (v4 > v6)
    {
      unsigned int v71 = v6 + 1;
      do
      {
        char v73 = *v59++;
        char v72 = v73;
        int v75 = *v56++;
        int v74 = v75;
        int v76 = *v57++;
        *v55++ = v72 - ((v76 + v74) >> 1);
        BOOL v100 = v4 > v71++;
      }
      while (v100);
    }
  }
  else if ((v3 & 0x40) != 0)
  {
    uint64_t v63 = *(void *)(a1 + 336);
    *(unsigned char *)uint64_t v63 = 3;
    __int16 v64 = AppleGetCPUCapabilities();
    if (v6 == 4 && (v64 & 0x100) != 0)
    {
      unint64_t v70 = png_write_filter_row_avg_neon((unsigned __int32 *)(v7 + 1), (_DWORD *)(v63 + 1), (_DWORD *)(*(void *)(a1 + 320) + 1), v4, v65, v66, v67, v68, v69);
    }
    else
    {
      uint64_t v77 = (unsigned __int8 *)(v63 + 1);
      int v78 = (unsigned __int8 *)(*(void *)(a1 + 320) + 1);
      int v79 = (unsigned __int8 *)(v7 + 1);
      unint64_t v70 = 0;
      if (v5)
      {
        unint64_t v80 = (unint64_t)(v5 + 7) >> 3;
        int v81 = (char *)(v7 + 1);
        do
        {
          char v83 = *v81++;
          char v82 = v83;
          unsigned int v84 = *v78++;
          unsigned __int8 v85 = v82 - (v84 >> 1);
          int v86 = (char)v85;
          *v77++ = v85;
          unsigned int v87 = v85;
          LODWORD(v88) = 256 - v85;
          if (v86 >= 0) {
            uint64_t v88 = v87;
          }
          else {
            uint64_t v88 = v88;
          }
          v70 += v88;
          LODWORD(v80) = v80 - 1;
        }
        while (v80);
      }
      else
      {
        int v81 = (char *)(v7 + 1);
      }
      if (v4 > v6)
      {
        unsigned int v89 = v6 + 1;
        do
        {
          char v91 = *v81++;
          char v90 = v91;
          int v93 = *v78++;
          int v92 = v93;
          int v94 = *v79++;
          unsigned __int8 v95 = v90 - ((v94 + v92) >> 1);
          int v96 = (char)v95;
          *v77++ = v95;
          unsigned int v97 = v95;
          LODWORD(v98) = 256 - v95;
          if (v96 >= 0) {
            uint64_t v98 = v97;
          }
          else {
            uint64_t v98 = v98;
          }
          v70 += v98;
          unint64_t v99 = v89++;
          BOOL v100 = v70 <= v8 && v4 > v99;
        }
        while (v100);
      }
    }
    if (v70 < v8)
    {
      uint64_t v101 = *(void *)(a1 + 344);
      if (v101)
      {
        *(void *)(a1 + 336) = v101;
        *(void *)(a1 + 344) = v63;
      }
      unint64_t v8 = v70;
      uint8x8_t v9 = (unsigned char *)v63;
    }
  }
  if (v3 == 128)
  {
    uint8x8_t v9 = *(unsigned char **)(a1 + 336);
    *uint8x8_t v9 = 4;
    unint64_t v102 = v9 + 1;
    int v103 = (unsigned __int8 *)(*(void *)(a1 + 320) + 1);
    BOOL v104 = (unsigned __int8 *)(v7 + 1);
    if (v5)
    {
      uint64_t v105 = 0;
      do
      {
        v102[v105] = v104[v105] - v103[v105];
        ++v105;
      }
      while (v6 != v105);
      char v106 = &v104[v105];
      uint64_t v107 = &v103[v105];
      v102 += v105;
    }
    else
    {
      uint64_t v107 = (unsigned __int8 *)(*(void *)(a1 + 320) + 1);
      char v106 = (unsigned __int8 *)(v7 + 1);
    }
    uint64_t v50 = a2;
    unint64_t v117 = v4 - v6;
    if (v4 > v6)
    {
      do
      {
        int v119 = *v107++;
        int v118 = v119;
        int v121 = *v103++;
        int v120 = v121;
        int v123 = *v104++;
        char v122 = v123;
        int v124 = v123 - v120;
        if (v118 - v120 >= 0) {
          unsigned int v125 = v118 - v120;
        }
        else {
          unsigned int v125 = v120 - v118;
        }
        if (v124 >= 0) {
          unsigned int v126 = v124;
        }
        else {
          unsigned int v126 = -v124;
        }
        int v127 = v124 + v118 - v120;
        if (v127 < 0) {
          int v127 = -v127;
        }
        if (v126 > v127) {
          LOBYTE(v118) = v120;
        }
        if (v125 <= v127 && v125 <= v126) {
          LOBYTE(v118) = v122;
        }
        char v129 = *v106++;
        *v102++ = v129 - v118;
        --v117;
      }
      while (v117);
    }
  }
  else
  {
    if ((v3 & 0x80) == 0) {
      goto LABEL_54;
    }
    int v108 = *(unsigned char **)(a1 + 336);
    unsigned char *v108 = 4;
    __int16 v109 = AppleGetCPUCapabilities();
    if (v6 == 4 && (v109 & 0x100) != 0)
    {
      unint64_t v116 = png_write_filter_row_paeth_neon((unsigned char *)(v7 + 1), v108 + 1, (unsigned char *)(*(void *)(a1 + 320) + 1), v4, v110, v111, v112, v113, v114, v115);
    }
    else
    {
      int v130 = v108 + 1;
      uint64_t v131 = (unsigned __int8 *)(*(void *)(a1 + 320) + 1);
      int v132 = (unsigned __int8 *)(v7 + 1);
      unint64_t v116 = 0;
      if (v5)
      {
        uint64_t v133 = 0;
        do
        {
          unsigned __int8 v134 = v132[v133] - v131[v133];
          int v135 = (char)v134;
          v130[v133] = v134;
          unsigned int v136 = v134;
          LODWORD(v137) = 256 - v134;
          if (v135 >= 0) {
            uint64_t v137 = v136;
          }
          else {
            uint64_t v137 = v137;
          }
          v116 += v137;
          ++v133;
        }
        while (v6 != v133);
        char v138 = &v132[v133];
        int v139 = &v131[v133];
        v130 += v133;
      }
      else
      {
        int v139 = (unsigned __int8 *)(*(void *)(a1 + 320) + 1);
        char v138 = (unsigned __int8 *)(v7 + 1);
      }
      if (v4 > v6)
      {
        unint64_t v140 = v6 + 1;
        do
        {
          int v142 = *v139++;
          int v141 = v142;
          int v144 = *v131++;
          int v143 = v144;
          int v146 = *v132++;
          char v145 = v146;
          int v147 = v146 - v143;
          if (v141 - v143 >= 0) {
            unsigned int v148 = v141 - v143;
          }
          else {
            unsigned int v148 = v143 - v141;
          }
          if (v147 >= 0) {
            unsigned int v149 = v147;
          }
          else {
            unsigned int v149 = -v147;
          }
          int v150 = v147 + v141 - v143;
          if (v150 < 0) {
            int v150 = -v150;
          }
          if (v149 > v150) {
            LOBYTE(v141) = v143;
          }
          if (v148 <= v150 && v148 <= v149) {
            LOBYTE(v141) = v145;
          }
          char v152 = *v138++;
          unsigned __int8 v153 = v152 - v141;
          int v154 = (char)v153;
          *v130++ = v153;
          unsigned int v155 = v153;
          LODWORD(v156) = 256 - v153;
          if (v154 >= 0) {
            uint64_t v156 = v155;
          }
          else {
            uint64_t v156 = v156;
          }
          v116 += v156;
        }
        while (v116 <= v8 && v140++ < v4);
      }
    }
    uint64_t v50 = a2;
    if (v116 < v8)
    {
      uint64_t v158 = *(void *)(a1 + 344);
      if (v158)
      {
        *(void *)(a1 + 336) = v158;
        *(void *)(a1 + 344) = v108;
      }
      uint8x8_t v9 = v108;
    }
  }
LABEL_55:
  png_compress_IDAT(a1, (uint64_t)v9, *(void *)(v50 + 8) + 1, 0);
  uint64_t v51 = *(void *)(a1 + 320);
  if (v51)
  {
    *(void *)(a1 + 320) = *(void *)(a1 + 328);
    *(void *)(a1 + 328) = v51;
  }
  png_write_finish_row(a1);
  unsigned int v52 = *(_DWORD *)(a1 + 444) + 1;
  *(_DWORD *)(a1 + 444) = v52;
  if (*(_DWORD *)(a1 + 440) - 1 < v52)
  {
    _cg_png_write_flush(a1);
  }
}

uint64_t png_compress_IDAT(uint64_t a1, uint64_t a2, unint64_t a3, int a4)
{
  if (*(_DWORD *)(a1 + 92) != 1229209940)
  {
    unint64_t v8 = *(void ***)(a1 + 208);
    if (v8)
    {
      uint8x8_t v9 = *v8;
      if (*v8)
      {
        uint64_t *v8 = 0;
        do
        {
          unsigned int v10 = (void *)*v9;
          png_free(a1, v9);
          uint8x8_t v9 = v10;
        }
        while (v10);
      }
    }
    else
    {
      int v11 = png_malloc((void (**)(void))a1, *(unsigned int *)(a1 + 216) + 16);
      *(void *)(a1 + 208) = v11;
      char *v11 = 0;
      v11[1] = (void (*)(void))(v11 + 2);
    }
    unint64_t v12 = png_image_size(a1);
    if (png_deflate_claim(a1, 1229209940, v12)) {
      goto LABEL_45;
    }
    *(void *)(a1 + 120) = *(void *)(*(void *)(a1 + 208) + 8);
    *(_DWORD *)(a1 + 128) = *(_DWORD *)(a1 + 216);
  }
  *(void *)(a1 + 96) = a2;
  do
  {
    do
    {
      uint64_t v13 = a3 >= 0xFFFFFFFF ? 0xFFFFFFFFLL : a3;
      *(_DWORD *)(a1 + 104) = v13;
      unint64_t v14 = a3 - v13;
      int v15 = HIDWORD(a3) ? 0 : a4;
      uint64_t result = deflate((z_streamp)(a1 + 96), v15);
      int v17 = result;
      a3 = v14 + *(unsigned int *)(a1 + 104);
      *(_DWORD *)(a1 + 104) = 0;
      LODWORD(v14) = *(_DWORD *)(a1 + 128);
      if (v14) {
        break;
      }
      unint64_t v18 = *(unsigned __int8 **)(*(void *)(a1 + 208) + 8);
      unint64_t v14 = *(unsigned int *)(a1 + 216);
      if ((*(unsigned char *)(a1 + 76) & 4) != 0 || *(unsigned char *)(a1 + 872))
      {
        if (v14) {
          goto LABEL_24;
        }
      }
      else
      {
        unint64_t v19 = png_image_size(a1);
        uint64_t result = (uint64_t)optimize_cmf(v18, v19);
        if (v14)
        {
LABEL_24:
          if (*(_DWORD *)(a1 + 812)) {
            uint64_t result = png_write_fdAT(a1, v18, v14);
          }
          else {
            uint64_t result = (uint64_t)_cg_png_write_complete_chunk((void (**)(void))a1, 1229209940, v18, v14);
          }
        }
      }
      *(_DWORD *)(a1 + 76) |= 4u;
      *(void *)(a1 + 120) = v18;
      *(_DWORD *)(a1 + 128) = v14;
    }
    while (a4 && !v17);
    if (v17)
    {
      if (a4 == 4 && v17 == 1)
      {
        int v20 = *(unsigned __int8 **)(*(void *)(a1 + 208) + 8);
        int v21 = *(_DWORD *)(a1 + 216);
        if ((*(unsigned char *)(a1 + 76) & 4) == 0 && !*(unsigned char *)(a1 + 872))
        {
          unint64_t v22 = png_image_size(a1);
          uint64_t result = (uint64_t)optimize_cmf(v20, v22);
        }
        if (v21 != v14)
        {
          if (*(_DWORD *)(a1 + 812)) {
            uint64_t result = png_write_fdAT(a1, v20, (v21 - v14));
          }
          else {
            uint64_t result = (uint64_t)_cg_png_write_complete_chunk((void (**)(void))a1, 1229209940, v20, (v21 - v14));
          }
        }
        *(_DWORD *)(a1 + 128) = 0;
        *(void *)(a1 + 120) = 0;
        *(_DWORD *)(a1 + 76) |= 0xCu;
        *(_DWORD *)(a1 + 92) = 0;
        return result;
      }
      png_zstream_error(a1, v17);
LABEL_45:
      CFDataRef v23 = *(const char **)(a1 + 144);
LABEL_46:
      _cg_png_error((void (**)(void))a1, v23);
    }
  }
  while (a3);
  if (a4 == 4)
  {
    CFDataRef v23 = "Z_OK on Z_FINISH with output space";
    goto LABEL_46;
  }
  return result;
}

uint64_t IIOImagePixelDataProvider::getBytes(uint64_t (**this)(IIOImagePixelDataProvider *, void *), void *a2)
{
  return this[23]((IIOImagePixelDataProvider *)this, a2);
}

void png_write_finish_row(uint64_t a1)
{
  unsigned int v1 = *(_DWORD *)(a1 + 308) + 1;
  *(_DWORD *)(a1 + 308) = v1;
  if (v1 >= *(_DWORD *)(a1 + 288))
  {
    if (!*(unsigned char *)(a1 + 388)) {
      goto LABEL_15;
    }
    *(_DWORD *)(a1 + 308) = 0;
    unsigned __int8 v2 = *(unsigned char *)(a1 + 389);
    if ((*(unsigned char *)(a1 + 88) & 2) != 0)
    {
      ++v2;
    }
    else
    {
      while (++v2 <= 6u)
      {
        unsigned int v3 = png_do_write_interlace_png_pass_inc[v2];
        unsigned int v4 = *(_DWORD *)(a1 + 280) + v3 + ~png_do_write_interlace_png_pass_start[v2];
        *(_DWORD *)(a1 + 292) = v4 / v3;
        unsigned int v5 = png_write_finish_row_png_pass_yinc[v2];
        unsigned int v6 = *(_DWORD *)(a1 + 284) + v5 + ~png_write_finish_row_png_pass_ystart[v2];
        *(_DWORD *)(a1 + 288) = v6 / v5;
        if (v4 >= v3 && v6 >= v5) {
          break;
        }
      }
    }
    *(unsigned char *)(a1 + 389) = v2;
    if (v2 <= 6u)
    {
      if (*(void *)(a1 + 320))
      {
        unsigned int v7 = *(unsigned __int8 *)(a1 + 393) * *(unsigned __int8 *)(a1 + 396);
        unsigned int v8 = *(_DWORD *)(a1 + 280);
        BOOL v9 = v7 >= 8;
        unint64_t v10 = (v8 * (unint64_t)v7 + 7) >> 3;
        unint64_t v11 = v8 * (unint64_t)(v7 >> 3);
        if (!v9) {
          unint64_t v11 = v10;
        }
        bzero(*(void **)(a1 + 320), v11 + 1);
      }
    }
    else
    {
LABEL_15:
      png_compress_IDAT(a1, 0, 0, 4);
    }
  }
}

uint64_t IIOImagePixelDataProvider::getBytesImageProvider(IIOImagePixelDataProvider *this, char *a2, unint64_t a3)
{
  uint64_t result = 0;
  if (!a2 || !a3) {
    return result;
  }
  unint64_t v5 = *((void *)this + 19);
  unint64_t v6 = *((void *)this + 20);
  if (v6 <= v5) {
    return 0;
  }
  unsigned int v7 = a2;
  if (v5 + a3 <= v6) {
    unint64_t v8 = a3;
  }
  else {
    unint64_t v8 = v6 - v5;
  }
  BOOL v10 = v8 != *((void *)this + 4) * *((void *)this + 18) && *((void *)this + 22) != 0;
  uint64_t ImageProvider = CGImageGetImageProvider();
  unint64_t v12 = (const void *)ImageProvider;
  uint64_t v13 = *((void *)this + 25);
  if (!v10 || v13 == 0)
  {
    if (v13) {
      goto LABEL_40;
    }
    if (!ImageProvider) {
      return 0;
    }
LABEL_32:
    if (!*((void *)this + 24)) {
      *((void *)this + 24) = CFRetain(v12);
    }
    if (!v10 || v8 % *((void *)this + 18))
    {
      memset(&src, 0, 24);
      IIODictionary::IIODictionary((IIODictionary *)&src);
      IIONumber::IIONumber((IIONumber *)v80, 0);
      IIODictionary::setObjectForKey((uint64_t)&src, (uint64_t)v80, @"kCGImageProviderPreferedBandHeight");
      IIONumber::~IIONumber((IIONumber *)v80);
      uint64_t v30 = CGImageProviderCopyImageBlockSetWithOptions();
      if (!v30) {
        uint64_t v30 = CGImageProviderCopyImageBlockSetWithOptions();
      }
      IIODictionary::~IIODictionary((IIODictionary *)&src);
      if (!v30) {
        return 0;
      }
      goto LABEL_39;
    }
    uint64_t v30 = CGImageProviderCopyImageBlockSetWithOptions();
    if (v30)
    {
LABEL_39:
      *((void *)this + 25) = v30;
      CGImageBlockSetGetImageBlock();
      *((void *)this + 17) = CGImageBlockGetBytesPerRow();
      goto LABEL_40;
    }
    return 0;
  }
  CGImageBlockSetGetRect();
  CGFloat v16 = v15;
  double v18 = v17;
  CGFloat v20 = v19;
  double v22 = v21;
  CGImageBlockSetGetImageBlock();
  CGImageBlockGetRect();
  if (v18 < v23) {
    double v18 = v23;
  }
  if (v22 < v24) {
    double v22 = v24;
  }
  *((void *)this + 17) = CGImageBlockGetBytesPerRow();
  unint64_t v25 = *((void *)this + 18);
  double v26 = 1.0;
  if (v8 > v25 && !(v8 % v25)) {
    double v26 = (double)(v8 / v25);
  }
  if (v8 != v25 && v8 % v25
    || (double v27 = (double)(*((void *)this + 19) / v25),
        double v28 = (double)*((unint64_t *)this + 3),
        uint64_t v29 = 0,
        v81.origin.double x = v16,
        v81.origin.double y = v18,
        v81.size.width = v20,
        v81.size.unsigned int height = v22,
        !CGRectContainsRect(v81, *(CGRect *)(&v26 - 3))))
  {
    CGImageBlockSetRelease();
    *((void *)this + 25) = 0;
    if (!v12) {
      return 0;
    }
    goto LABEL_32;
  }
LABEL_40:
  uint64_t result = CGImageBlockSetGetCount();
  unint64_t v71 = result;
  if (!result) {
    return result;
  }
  Pixelunint64_t Size = CGImageProviderGetPixelSize();
  unint64_t v32 = (*((_DWORD *)this + 21) + 7) >> 3;
  if (v8 < v32)
  {
    _cg_jpeg_mem_term("getBytesImageProvider", 830, "Only %zu bytes requested, must request at least a full pixel (%zu bytes)", v8, v32);
    return 0;
  }
  uint64_t v33 = PixelSize;
  uint64_t result = 0;
  uint64_t v74 = v33;
  uint64_t v72 = *((void *)this + 3) * v33;
  unint64_t v34 = v8 / v32 * v32;
LABEL_43:
  if (v34)
  {
    uint64_t v77 = result;
    unint64_t v70 = v7;
    uint64_t v35 = 0;
    uint64_t v36 = 0;
    while (1)
    {
      memset(&src, 0, sizeof(src));
      memset(&dest, 0, sizeof(dest));
      unint64_t v38 = *((void *)this + 18);
      unint64_t v37 = *((void *)this + 19);
      unint64_t v39 = *((unsigned int *)this + 21);
      double v40 = IIOImagePixelDataProvider::endingPointForByteCount(this, v34);
      double v42 = v41;
      if (CGImageBlockSetGetImageBlock())
      {
        uint64_t v43 = (uint64_t)(double)(v37 / v38);
        CGImageBlockGetRect();
        uint64_t v48 = (uint64_t)v45 + (uint64_t)v47;
        if ((unint64_t)v48 >= *((void *)this + 4)) {
          uint64_t v48 = *((void *)this + 4);
        }
        uint64_t v75 = (uint64_t)v45;
        uint64_t v76 = v48;
        if (v43 >= (uint64_t)v45 && v48 > v43)
        {
          uint64_t v50 = (uint64_t)(double)(8 * (v37 % v38) / v39);
          uint64_t v51 = (uint64_t)v44;
          uint64_t v52 = (unint64_t)((uint64_t)v44 + (uint64_t)v46) >= *((void *)this + 3)
              ? *((void *)this + 3)
              : (uint64_t)v44 + (uint64_t)v46;
          if (v50 >= v51 && v52 > v50) {
            break;
          }
        }
      }
LABEL_101:
      if (++v35 >= v71 || !v34)
      {
        if (v34)
        {
          unsigned int v7 = v70;
          uint64_t result = v77;
          if (v36) {
            goto LABEL_43;
          }
          return result;
        }
        return v77;
      }
    }
    uint64_t Data = CGImageBlockGetData();
    size_t BytesPerRow = CGImageBlockGetBytesPerRow();
    *((void *)this + 17) = BytesPerRow;
    if (v40 <= (double)v52) {
      double v55 = v40;
    }
    else {
      double v55 = (double)v52;
    }
    vImagePixelCount v56 = *((void *)this + 3);
    uint64_t v57 = v70;
    while (1)
    {
      BOOL v58 = v40 < (double)(unint64_t)v52 && v42 == (double)v43;
      vImagePixelCount v59 = (unint64_t)(v55 - (double)v50);
      if (!v58) {
        vImagePixelCount v59 = v52 - v50;
      }
      src.std::string::pointer data = (void *)(Data + (v50 - v51) * v74 + BytesPerRow * (v43 - v75));
      src.width = v59;
      src.rowuint64_t Bytes = BytesPerRow;
      if (v59 == v56 && BytesPerRow == *((void *)this + 16))
      {
        vImagePixelCount v60 = v34 / *((void *)this + 18);
        if (v60 >= v76 - v43) {
          vImagePixelCount v60 = v76 - v43;
        }
        if (v60 <= 1) {
          vImagePixelCount v60 = 1;
        }
      }
      else
      {
        vImagePixelCount v60 = 1;
      }
      src.unsigned int height = v60;
      dest.unsigned int height = v60;
      dest.width = v59;
      dest.std::string::pointer data = v57;
      BOOL v61 = v59 < v56 && v60 == 1;
      size_t v62 = v61 ? v59 * ((*((_DWORD *)this + 21) + 7) >> 3) : *((void *)this + 18);
      dest.rowuint64_t Bytes = v62;
      unint64_t v63 = *((unsigned int *)this + 11);
      if (BytesPerRow < (v59 * v63 + 7) >> 3) {
        return v77;
      }
      if (v34 < v60 * v59 * ((*((_DWORD *)this + 21) + 7) >> 3))
      {
        _cg_jpeg_mem_term("getBytesImageProvider", 928, "*** numBytes < dstBuffer.rowBytes * dstBuffer.height (%ld > %d)\n", v34, v62 * v60);
        return v77;
      }
      if (v60 == 1)
      {
        vImagePixelCount v64 = v59 * (v63 >> 3);
        size_t v65 = v56 * (v63 >> 3);
        if (v64 < v65) {
          size_t v65 = v64;
        }
        src.rowuint64_t Bytes = v65;
      }
      vImagePixelCount v66 = IIOImagePixelDataProvider::convertBytes(this, &src, &dest);
      if (!v66) {
        return v77;
      }
      vImagePixelCount v67 = v66;
      size_t BytesPerRow = *((void *)this + 17);
      v57 += v67;
      v34 -= v67;
      v77 += v67;
      v36 += BytesPerRow;
      *((void *)this + 19) += v67;
      if (!v51 && v34)
      {
        uint64_t v68 = *((void *)this + 3);
        vImagePixelCount v69 = dest.width + v50 == v68 ? dest.height : 0;
        if (dest.width + v50 == v68) {
          uint64_t v50 = 0;
        }
        else {
          v50 += dest.width;
        }
        if (v52 == v68)
        {
          v43 += v69;
          if (v43 < v76)
          {
            vImagePixelCount v56 = v52;
            if (v72 <= v52 * v74) {
              continue;
            }
          }
        }
      }
      unint64_t v70 = v57;
      goto LABEL_101;
    }
  }
  return result;
}

void sub_1885C79BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27)
{
}

double IIOImagePixelDataProvider::endingPointForByteCount(IIOImagePixelDataProvider *this, unint64_t a2)
{
  unint64_t v2 = *((unsigned int *)this + 21);
  unint64_t v3 = *((void *)this + 18);
  unint64_t v4 = 8 * (*((void *)this + 19) % v3);
  double result = (double)(v4 / v2);
  if (v4 >= v2)
  {
    unint64_t v6 = (unint64_t)((double)v3 + (double)v2 * result * -0.125);
    if (v6)
    {
      BOOL v7 = a2 >= v6;
      unint64_t v8 = a2 - v6;
      if (v7)
      {
        double result = 0.0;
        a2 = v8;
      }
      else
      {
        double result = result + (double)(8 * a2 / v2);
        if (result > (double)*((unint64_t *)this + 3)) {
          double result = (double)*((unint64_t *)this + 3);
        }
        a2 = 0;
      }
    }
  }
  unint64_t v9 = a2 % v3;
  if (v9)
  {
    double result = (double)((v2 + 8 * v9 - 1) / v2);
    if (result > (double)*((unint64_t *)this + 3)) {
      return (double)*((unint64_t *)this + 3);
    }
  }
  return result;
}

vImagePixelCount IIOImagePixelDataProvider::convertBytes(IIOImagePixelDataProvider *this, vImage_Buffer *src, vImage_Buffer *dest)
{
  if (*((_DWORD *)this + 10) == 16 && *((_DWORD *)this + 20) == 8 && (*((unsigned char *)this + 57) & 0x10) != 0)
  {
    int v6 = *((_DWORD *)this + 11);
    if (v6 == 16)
    {
      if (*((_DWORD *)this + 21) == 8 && !vImageConvert_Planar16UtoPlanar8_dithered(src, dest, 3, 0)) {
        return dest->height * dest->rowBytes;
      }
    }
    else if (v6 == 48)
    {
      if (*((_DWORD *)this + 21) == 24 && !vImageConvert_RGB16UtoRGB888_dithered(src, dest, 3, 0)) {
        return dest->height * dest->rowBytes;
      }
    }
    else if (v6 == 64 {
           && *((_DWORD *)this + 21) == 32
    }
           && !vImageConvert_ARGB16UtoARGB8888_dithered(src, dest, 3, 0, 0))
    {
      return dest->height * dest->rowBytes;
    }
  }
  unint64_t v7 = vImageConvert_AnyToAny(*((const vImageConverterRef *)this + 15), src, dest, 0, 0x80u);
  unint64_t v8 = (void *)*((void *)this + 29);
  if ((v7 & 0x8000000000000000) == 0)
  {
    if (!v8)
    {
      if (!v7)
      {
        unint64_t v8 = 0;
        goto LABEL_23;
      }
      *((void *)this + 30) = v7;
      unint64_t v9 = malloc_type_malloc(v7, 0xE1AD70A3uLL);
      goto LABEL_21;
    }
    if (*((void *)this + 30) < v7)
    {
      *((void *)this + 30) = v7;
      unint64_t v9 = reallocf(v8, v7);
LABEL_21:
      unint64_t v8 = v9;
      *((void *)this + 29) = v9;
    }
  }
LABEL_23:
  vImage_Error v10 = iio_vImageConvert_AnyToAny(*((vImageConverterRef *)this + 15), src, dest, v8, 0);
  if (v10)
  {
    unint64_t v11 = IIO_vImageErrorString(v10);
    LogError("convertBytes", 555, "*** ERROR: vImageConvert_AnyToAny error: '%s'\n", v11);
    return 0;
  }
  if (*((unsigned char *)this + 225))
  {
    long long v13 = *(_OWORD *)&dest->width;
    *(_OWORD *)&desta.std::string::pointer data = *(_OWORD *)&dest->data;
    desta.rowuint64_t Bytes = *((void *)&v13 + 1);
    desta.width = 4 * v13;
    vImage_Error v14 = vImageByteSwap_Planar16U(&desta, &desta, 0x10u);
    if (v14) {
      LogError("convertBytes", 566, "*** ERROR: vImageByteSwap_Planar16U error: %d", v14);
    }
  }
  return dest->height * dest->rowBytes;
}

vImage_Error iio_vImageConvert_AnyToAny(vImageConverterRef converter, const vImage_Buffer *srcs, const vImage_Buffer *dests, void *a4, vImage_Flags flags)
{
  v21[1] = *MEMORY[0x1E4F143B8];
  if (!converter) {
    return -50;
  }
  if (srcs->data == dests->data)
  {
    vImage_Error MustOperateOutOfPlace = vImageConverter_MustOperateOutOfPlace(converter, srcs, dests, flags);
    if (MustOperateOutOfPlace == -21780)
    {
      LogError("iio_vImageConvert_AnyToAny", 1052, "ERROR: vImageConvert_AnyToAny cannot convert in-place\n");
      return -21780;
    }
  }
  else
  {
    vImage_Error MustOperateOutOfPlace = 0;
  }
  unint64_t v11 = converter;
  if (a4)
  {
    unint64_t v12 = srcs;
    long long v13 = dests;
    vImage_Error v14 = a4;
LABEL_15:
    vImage_Error MustOperateOutOfPlace = vImageConvert_AnyToAny(v11, v12, v13, v14, flags);
    goto LABEL_16;
  }
  unint64_t v15 = vImageConvert_AnyToAny(converter, srcs, dests, 0, 0x80u);
  if ((v15 & 0x8000000000000000) != 0)
  {
    _cg_jpeg_mem_term("iio_vImageConvert_AnyToAny", 1060, "*** ERROR: vImageConvert_AnyToAny+kvImageGetTempBufferSize returned: %lld\n", v15);
  }
  else
  {
    if (!v15)
    {
      double v17 = 0;
      goto LABEL_14;
    }
    if (v15 <= 0x800)
    {
      MEMORY[0x1F4188790](v15, v15);
      double v17 = (char *)v21 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0);
      bzero(v17, v16);
LABEL_14:
      unint64_t v11 = converter;
      unint64_t v12 = srcs;
      long long v13 = dests;
      vImage_Error v14 = v17;
      goto LABEL_15;
    }
    CGFloat v20 = malloc_type_malloc(v15, 0xD4DE49ADuLL);
    vImage_Error MustOperateOutOfPlace = vImageConvert_AnyToAny(converter, srcs, dests, v20, flags);
    free(v20);
  }
LABEL_16:
  if (MustOperateOutOfPlace)
  {
    double v18 = IIO_vImageErrorString(MustOperateOutOfPlace);
    _cg_jpeg_mem_term("iio_vImageConvert_AnyToAny", 1094, "*** ERROR *** vImageConvert_AnyToAny: %d (%s)\n", MustOperateOutOfPlace, v18);
    CFShow(converter);
  }
  return MustOperateOutOfPlace;
}

vImagePixelCount IIOImagePixelDataProvider::getBytesDataProvider(IIOImagePixelDataProvider *this, unsigned __int8 *a2, unint64_t a3)
{
  vImagePixelCount v3 = 0;
  if (a2)
  {
    unint64_t v5 = *((void *)this + 19);
    unint64_t v6 = *((void *)this + 20);
    if (v6 > v5)
    {
      if (v5 + a3 <= v6) {
        unint64_t v8 = a3;
      }
      else {
        unint64_t v8 = v6 - v5;
      }
      CFDataRef v9 = (const __CFData *)*((void *)this + 26);
      if (!v9)
      {
        DataProvider = CGImageGetDataProvider(*((CGImageRef *)this + 2));
        if (!DataProvider) {
          return 0;
        }
        unint64_t v32 = DataProvider;
        CFDataRef v33 = CGDataProviderCopyData(DataProvider);
        *((void *)this + 26) = v33;
        if (!v33) {
          return 0;
        }
        unint64_t v34 = (*((void *)this + 4) - 1) * *((void *)this + 16)
            + ((*((void *)this + 3) * (unint64_t)*((unsigned int *)this + 11)) >> 3);
        unint64_t Length = CFDataGetLength(v33);
        if (Length < v34)
        {
          int v36 = Length;
          CFRelease(*((CFTypeRef *)this + 26));
          *((void *)this + 26) = 0;
          _cg_jpeg_mem_term("getBytesDataProvider", 1034, "CGDataProviderCopyData(%p) did not return enough data. Got %d, expected %d.\n", v32, v36, *((_DWORD *)this + 8) * *((_DWORD *)this + 32));
          unint64_t v37 = (const void *)CGAccessSessionCreate();
          *(void *)&double v38 = _cg_jpeg_mem_term("getBytesDataProvider", 1037, "Making a copy of the data via CGAccessSession (%p).\n", v37).n128_u64[0];
          if (v37)
          {
            SizeOfuint64_t Data = CGDataProviderGetSizeOfData();
            uint64_t v40 = *((void *)this + 16);
            uint64_t v41 = *((void *)this + 4);
            if (SizeOfData != v41 * v40) {
              SizeOfuint64_t Data = (v41 - 1) * v40
            }
                         + *((void *)this + 3) * ((unint64_t)*((unsigned int *)this + 11) >> 3);
            CFSetRef Mutable = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], SizeOfData);
            if (Mutable)
            {
              uint64_t v43 = Mutable;
              CFDataSetLength(Mutable, SizeOfData);
              CFDataGetMutableBytePtr(v43);
              uint64_t Bytes = CGAccessSessionGetBytes();
              if (Bytes == SizeOfData)
              {
                _cg_jpeg_mem_term("getBytesDataProvider", 1058, "    success: (%p) CGAccessSessionGetBytes - got all data.\n", v32);
                *((void *)this + 26) = CFRetain(v43);
              }
              else
              {
                _cg_jpeg_mem_term("getBytesDataProvider", 1062, "*** CGAccessSessionGetBytes did not return enough data. Expected %zd, Got %zd.\n", SizeOfData, Bytes);
              }
              CFRelease(v43);
            }
            else
            {
              _cg_jpeg_mem_term("getBytesDataProvider", 1067, "Failed to create CFData.\n");
            }
            CGAccessSessionRelease();
          }
          else
          {
            _cg_jpeg_mem_term("getBytesDataProvider", 1072, "*** Failed to create CGAccessSession.\n", v38);
          }
        }
        CFDataRef v9 = (const __CFData *)*((void *)this + 26);
        if (!v9) {
          return 0;
        }
      }
      BytePtr = CFDataGetBytePtr(v9);
      if (BytePtr)
      {
        unint64_t v11 = BytePtr;
        unint64_t v13 = *((void *)this + 18);
        unint64_t v12 = *((void *)this + 19);
        CGFloat v14 = (double)(8 * (v12 % v13) / *((unsigned int *)this + 21));
        double v15 = (double)(v12 / v13);
        double v16 = IIOImagePixelDataProvider::endingPointForByteCount(this, v8);
        v47.double x = v16;
        double v18 = v17;
        LODWORD(v16) = *((_DWORD *)this + 11);
        double v19 = (unsigned __int8 *)&v11[*((void *)this + 16) * (uint64_t)v15
                                    + (uint64_t)(v14 * (double)*(unint64_t *)&v16 * 0.125)];
        v46.double x = v14;
        v46.double y = v15;
        v47.double y = v18;
        vImagePixelCount v3 = IIOImagePixelDataProvider::convertBytesWithRange(this, v19, a2, v46, v47, v8);
        if ((*((unsigned char *)this + 56) & 0x1F) == 0 && (*((_DWORD *)this + 24) & 0x1F) == 3)
        {
          Masuint64_t k = (CGImage *)CGImageGetMask();
          if (Mask)
          {
            double v21 = Mask;
            size_t BytesPerRow = CGImageGetBytesPerRow(Mask);
            double v23 = CGImageGetDataProvider(v21);
            CFDataRef v24 = CGDataProviderCopyData(v23);
            unint64_t v25 = CFDataGetBytePtr(v24);
            if (v18 > (double)(unint64_t)v15)
            {
              unint64_t v26 = (unint64_t)v15;
              double v27 = a2 + 1;
              unint64_t v28 = *((void *)this + 3);
              uint64_t v29 = &v25[BytesPerRow * (unint64_t)v15];
              do
              {
                if (v28)
                {
                  for (unint64_t i = 0; i < v28; ++i)
                  {
                    *double v27 = v29[i];
                    v27 += 2;
                    unint64_t v28 = *((void *)this + 3);
                  }
                }
                ++v26;
                v29 += BytesPerRow;
              }
              while (v18 > (double)v26);
            }
            CFRelease(v24);
          }
        }
      }
      else
      {
        return 0;
      }
    }
  }
  return v3;
}

vImagePixelCount IIOImagePixelDataProvider::convertBytesWithRange(IIOImagePixelDataProvider *this, unsigned __int8 *a2, unsigned __int8 *a3, CGPoint a4, CGPoint a5, vImagePixelCount a6)
{
  unint64_t v7 = a3;
  double y = a5.y;
  double x = a5.x;
  double v10 = a4.y;
  double v11 = a4.x;
  unint64_t v12 = a2;
  memset(&src, 0, sizeof(src));
  memset(&v35, 0, sizeof(v35));
  if (a4.x <= 0.0 || a5.y <= a4.y)
  {
    double v15 = a4.y;
    vImagePixelCount v16 = a6;
    goto LABEL_11;
  }
  vImagePixelCount v17 = (unint64_t)((double)*((unint64_t *)this + 3) - a4.x);
  src.std::string::pointer data = a2;
  src.unsigned int height = 1;
  LODWORD(a4.y) = *((_DWORD *)this + 11);
  *(double *)&unint64_t v18 = a4.x * (double)*(unint64_t *)&a4.y * 0.125;
  size_t v19 = (unint64_t)((double)*((unint64_t *)this + 16) - *(double *)&v18);
  src.width = v17;
  src.rowuint64_t Bytes = v19;
  v35.std::string::pointer data = a3;
  v35.unsigned int height = 1;
  LODWORD(v18) = *((_DWORD *)this + 21);
  double v20 = (double)*((unint64_t *)this + 18) - a4.x * (double)v18 * 0.125;
  v35.width = v17;
  v35.rowuint64_t Bytes = (unint64_t)v20;
  vImagePixelCount result = IIOImagePixelDataProvider::convertBytes(this, &src, &v35);
  if (result)
  {
    vImagePixelCount v16 = a6 - result;
    vImagePixelCount v22 = *((void *)this + 19) + result;
    if (v22 >= *((void *)this + 20)) {
      vImagePixelCount v22 = *((void *)this + 20);
    }
    *((void *)this + 19) = v22;
    v12 += src.rowBytes;
    v7 += result;
    double v15 = v10 + 1.0;
    double v11 = 0.0;
LABEL_11:
    if (y > v10 && v16 != 0)
    {
      vImagePixelCount v24 = *((void *)this + 3);
      src.std::string::pointer data = v12;
      src.unsigned int height = (unint64_t)(y - v15);
      size_t v25 = *((void *)this + 16);
      src.width = v24;
      src.rowuint64_t Bytes = v25;
      v35.std::string::pointer data = v7;
      v35.unsigned int height = src.height;
      size_t v26 = *((void *)this + 18);
      v35.width = v24;
      v35.rowuint64_t Bytes = v26;
      vImagePixelCount v27 = IIOImagePixelDataProvider::convertBytes(this, &src, &v35);
      if (!v27) {
        return a6 - v16;
      }
      v16 -= v27;
      vImagePixelCount v28 = *((void *)this + 19) + v27;
      if (v28 >= *((void *)this + 20)) {
        vImagePixelCount v28 = *((void *)this + 20);
      }
      *((void *)this + 19) = v28;
      v12 += src.height * src.rowBytes;
      v7 += v27;
    }
    if (!v16)
    {
      vImagePixelCount v33 = 0;
      return v33 + a6;
    }
    vImagePixelCount v29 = (unint64_t)(x - v11);
    src.std::string::pointer data = v12;
    src.unsigned int height = 1;
    size_t v30 = (*((unsigned int *)this + 11) * v29) >> 3;
    src.width = v29;
    src.rowuint64_t Bytes = v30;
    v35.std::string::pointer data = v7;
    v35.unsigned int height = 1;
    size_t v31 = (*((unsigned int *)this + 21) * v29) >> 3;
    v35.width = v29;
    v35.rowuint64_t Bytes = v31;
    vImagePixelCount v32 = IIOImagePixelDataProvider::convertBytes(this, &src, &v35);
    if (v32)
    {
      vImagePixelCount v33 = v32 - v16;
      vImagePixelCount v34 = *((void *)this + 19) + v32;
      if (v34 >= *((void *)this + 20)) {
        vImagePixelCount v34 = *((void *)this + 20);
      }
      *((void *)this + 19) = v34;
      return v33 + a6;
    }
    return a6 - v16;
  }
  return result;
}

uint64_t PNGReadPlugin::Read_user_chunkCgBI(uint64_t a1, void (**a2)(void), uint64_t a3)
{
  if (*(unsigned char *)(a1 + 36))
  {
    *(unsigned char *)(a1 + 35) = 0;
    *(_DWORD *)(a1 + 40) = 0;
    return 1;
  }
  else if (*(void *)(a3 + 16) == 4)
  {
    unint64_t v6 = *(unsigned __int8 **)(a3 + 8);
    int v7 = *v6 >> 4;
    int v8 = v6[3] & 0x1F;
    if (*(unsigned char *)(a1 + 72) == 1) {
      int v9 = 4;
    }
    else {
      int v9 = 2;
    }
    if (v8 == 6) {
      int v10 = 6;
    }
    else {
      int v10 = v9;
    }
    int v11 = v10 & 0xFFFFFFF | (v7 << 28) | 0x2000;
    if (v11 == 268443650) {
      int v12 = 805314562;
    }
    else {
      int v12 = v10 & 0xFFFFFFF | (v7 << 28) | 0x2000;
    }
    *(_DWORD *)(a1 + 40) = v12;
    if ((v11 & 0x10000000) != 0)
    {
      if (*(void *)(_cg_png_get_zstream((uint64_t)a2) + 56)) {
        _cg_png_error(a2, "Too late to change zlib mode.");
      }
      int appleflags = _cg_png_get_appleflags((uint64_t)a2);
      _cg_png_set_appleflags((uint64_t)a2, appleflags | 1);
    }
    if ((v11 & 0x20000000) != 0)
    {
      int v14 = _cg_png_get_appleflags((uint64_t)a2);
      _cg_png_set_appleflags((uint64_t)a2, v14 | 2);
    }
    uint64_t result = 1;
    *(unsigned char *)(a1 + 35) = 1;
  }
  else
  {
    _cg_jpeg_mem_term("Read_user_chunkCgBI", 719, "*** ERROR: PNG ERROR: CgBI chunk encountered with incorrect length (%d)\n", *(void *)(a3 + 16));
    return 0xFFFFFFFFLL;
  }
  return result;
}

uint64_t _cg_png_get_appleflags(uint64_t a1)
{
  return *(unsigned int *)(a1 + 84);
}

uint64_t _cg_png_set_appleflags(uint64_t result, int a2)
{
  *(_DWORD *)(result + 84) = a2;
  return result;
}

uint64_t _cg_png_get_zstream(uint64_t a1)
{
  return a1 + 96;
}

void (**_cg_png_write_complete_chunk(void (**result)(void), int a2, Bytef *a3, unint64_t a4))(void)
{
  if (result)
  {
    uint64_t v5 = (uint64_t)result;
    if (a4 >> 31) {
      _cg_png_error(result, "length exceeds PNG maximum");
    }
    _cg_png_write_chunk_header((uint64_t)result, a2);
    _cg_png_write_chunk_data(v5, a3, a4);
    *(_DWORD *)(v5 + 956) = 130;
    return (void (**)(void))png_write_data(v5);
  }
  return result;
}

uint64_t _cg_png_write_chunk_header(uint64_t result, int a2)
{
  uint64_t v5 = *MEMORY[0x1E4F143B8];
  if (result)
  {
    uLong v3 = result;
    *(_DWORD *)(result + 956) = 34;
    v4[0] = HIBYTE(a2);
    v4[1] = BYTE2(a2);
    _OWORD v4[2] = BYTE1(a2);
    v4[3] = a2;
    png_write_data(result);
    *(_DWORD *)(v3 + 312) = a2;
    png_reset_crc(v3);
    uint64_t result = png_calculate_crc(v3, v4, 4);
    *(_DWORD *)(v3 + 956) = 66;
  }
  return result;
}

void *_cg_png_set_write_fn(void *result, uint64_t a2, size_t (*a3)(size_t result, void *__ptr, size_t a3), uint64_t (*a4)(uint64_t result))
{
  if (result)
  {
    result[5] = a2;
    if (a3) {
      unint64_t v4 = a3;
    }
    else {
      unint64_t v4 = png_default_write_data;
    }
    result[3] = v4;
    if (a4) {
      uint64_t v5 = a4;
    }
    else {
      uint64_t v5 = png_default_flush;
    }
    result[54] = v5;
    if (result[4])
    {
      result[4] = 0;
      return (void *)png_warning((uint64_t)result, "Can't set both read_data_fn and write_data_fn in the same structure");
    }
  }
  return result;
}

uint64_t png_image_size(uint64_t a1)
{
  uint64_t v1 = *(unsigned int *)(a1 + 284);
  unint64_t v2 = *(void *)(a1 + 296);
  if (v2 >> 15) {
    BOOL v3 = 0;
  }
  else {
    BOOL v3 = v1 >> 15 == 0;
  }
  if (!v3) {
    return 0xFFFFFFFFLL;
  }
  if (!*(unsigned char *)(a1 + 388)) {
    return v1 + v1 * v2;
  }
  uint64_t result = 0;
  unint64_t v6 = *(unsigned __int8 *)(a1 + 394);
  int v7 = *(_DWORD *)(a1 + 280);
  unsigned int v8 = 7;
  unsigned int v9 = 1;
  do
  {
    unsigned int v10 = v9 - 1;
    if (v9 - 1 <= 1) {
      char v11 = 3;
    }
    else {
      char v11 = v8 >> 1;
    }
    unsigned int v12 = (v7 + ~(-1 << v11) - (((v10 & 1) << (3 - (v9 >> 1))) & 7)) >> v11;
    if (v12)
    {
      unint64_t v13 = (v6 >> 3) * (unint64_t)v12;
      unint64_t v14 = (v6 * (unint64_t)v12 + 7) >> 3;
      if (v6 > 7) {
        unint64_t v14 = v13;
      }
      unsigned int v15 = (v8 + 1) >> 1;
      if (v10 < 3) {
        LOBYTE(v15) = 3;
      }
      uint64_t v16 = (v1 - ((!(v10 & 1) << (3 - (v10 >> 1))) & 7) + ~(-1 << v15)) >> v15;
      result += v16 + v16 * v14;
    }
    ++v9;
    --v8;
  }
  while (v8);
  return result;
}

uint64_t png_deflate_claim(uint64_t a1, int a2, unint64_t a3)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  int v6 = *(_DWORD *)(a1 + 92);
  if (!v6) {
    goto LABEL_5;
  }
  memset(v25, 0, sizeof(v25));
  long long v24 = 0u;
  long long v23 = 0u;
  v17[0] = HIBYTE(a2);
  v17[1] = BYTE2(a2);
  v17[2] = BYTE1(a2);
  v17[3] = a2;
  __int16 v18 = 8250;
  char v19 = HIBYTE(v6);
  char v20 = BYTE2(v6);
  char v21 = BYTE1(v6);
  char v22 = v6;
  png_safecat((uint64_t)v17, 0x40uLL, 0xAuLL, " using zstream");
  png_warning(a1, v17);
  if (*(_DWORD *)(a1 + 92) != 1229209940)
  {
    *(_DWORD *)(a1 + 92) = 0;
LABEL_5:
    if (a2 == 1229209940)
    {
      int v8 = *(_DWORD *)(a1 + 220);
      int v9 = *(_DWORD *)(a1 + 224);
      int v10 = *(_DWORD *)(a1 + 228);
      int v11 = *(_DWORD *)(a1 + 232);
      if (*(unsigned char *)(a1 + 80)) {
        int v12 = *(_DWORD *)(a1 + 236);
      }
      else {
        int v12 = *(unsigned __int8 *)(a1 + 390) != 8;
      }
    }
    else
    {
      int v8 = *(_DWORD *)(a1 + 240);
      int v9 = *(_DWORD *)(a1 + 244);
      int v10 = *(_DWORD *)(a1 + 248);
      int v11 = *(_DWORD *)(a1 + 252);
      int v12 = *(_DWORD *)(a1 + 256);
    }
    if (a3 <= 0x4000)
    {
      unint64_t v13 = (1 << (v10 - 1));
      if (a3 + 262 <= v13)
      {
        do
        {
          LODWORD(v13) = v13 >> 1;
          --v10;
        }
        while (v13 >= (int)a3 + 262);
      }
    }
    if ((*(unsigned char *)(a1 + 84) & 0x10) != 0) {
      goto LABEL_31;
    }
    unsigned int v14 = *(_DWORD *)(a1 + 80);
    if ((v14 & 2) != 0
      && (*(_DWORD *)(a1 + 260) != v8
       || *(_DWORD *)(a1 + 264) != v9
       || *(_DWORD *)(a1 + 268) != v10
       || *(_DWORD *)(a1 + 272) != v11
       || *(_DWORD *)(a1 + 276) != v12))
    {
      if (deflateEnd((z_streamp)(a1 + 96))) {
        png_warning(a1, "deflateEnd failed (ignored)");
      }
      unsigned int v14 = *(_DWORD *)(a1 + 80) & 0xFFFFFFFD;
      *(_DWORD *)(a1 + 80) = v14;
    }
    *(void *)(a1 + 96) = 0;
    unsigned int v15 = (z_stream *)(a1 + 96);
    *(_DWORD *)(a1 + 104) = 0;
    *(void *)(a1 + 120) = 0;
    *(_DWORD *)(a1 + 128) = 0;
    if ((v14 & 2) != 0)
    {
      uint64_t v7 = deflateReset(v15);
      if (!v7) {
        goto LABEL_31;
      }
    }
    else
    {
      if (a2 == 1229209940 && (*(unsigned char *)(a1 + 84) & 0x11) != 0) {
        int v10 = -v10;
      }
      uint64_t v7 = deflateInit2_(v15, v8, v9, v10, v11, v12, "1.2.12", 112);
      if (!v7)
      {
        *(_DWORD *)(a1 + 80) |= 2u;
LABEL_31:
        uint64_t v7 = 0;
        *(_DWORD *)(a1 + 92) = a2;
        return v7;
      }
    }
    png_zstream_error(a1, v7);
    return v7;
  }
  *(void *)(a1 + 144) = "in use by IDAT";
  return 4294967294;
}

void (**_cg_png_write_chunk(void (**a1)(void), unsigned int *a2, Bytef *a3, unint64_t a4))(void)
{
  return _cg_png_write_complete_chunk(a1, bswap32(*a2), a3, a4);
}

uint64_t IIOImageWriteSession::seek(IIOImageWriteSession *this, uint64_t a2, int a3)
{
  uint64_t v4 = a2;
  if (a3)
  {
    if (a3 == 2)
    {
      uint64_t v5 = (char *)this + 56;
    }
    else
    {
      if (a3 != 1) {
        return -1;
      }
      uint64_t v5 = (char *)this + 64;
    }
    uint64_t v4 = *(void *)v5 + a2;
  }
  int v6 = (FILE *)*((void *)this + 4);
  if (!v6 || !fseek(v6, a2, a3))
  {
    *((void *)this + 8) = v4;
    return v4;
  }
  return -1;
}

uint64_t _cg_GifLastError(uint64_t a1)
{
  return *(unsigned int *)(a1 + 80);
}

unsigned __int8 *optimize_cmf(unsigned __int8 *result, unint64_t a2)
{
  if (a2 <= 0x4000)
  {
    unint64_t v2 = *result;
    if ((v2 & 0xF) == 8)
    {
      unint64_t v3 = v2 >> 4;
      unint64_t v4 = 128 << (*result >> 4);
      BOOL v5 = (v2 & 0xF0) <= 0x70 && v4 >= a2;
      if (v5)
      {
        int v6 = ((v3 & 0xF) << 12) | 0x800;
        unsigned __int8 v7 = (v2 & 0xF0) + 8;
        int v8 = v3 - 1;
        do
        {
          v6 -= 4096;
          v7 -= 16;
          BOOL v5 = v8-- != 0;
          if (!v5) {
            break;
          }
          unint64_t v4 = v4 >> 1;
        }
        while (v4 >= a2);
        IIO_Reader *result = v7;
        result[1] = (result[1] & 0xE0 | ((result[1] & 0xE0) - 31 * (((result[1] & 0xE0u) + v6) / 0x1F))) ^ 0x1F;
      }
    }
  }
  return result;
}

uint64_t png_write_eXIf(uint64_t a1, Bytef *a2, int a3)
{
  LODWORD(v3) = a3;
  Bytef v8 = 0;
  _cg_png_write_chunk_header(a1, 1700284774);
  if ((int)v3 >= 1)
  {
    uint64_t v3 = v3;
    do
    {
      Bytef v6 = *a2++;
      Bytef v8 = v6;
      _cg_png_write_chunk_data(a1, &v8, 1);
      --v3;
    }
    while (v3);
  }
  return _cg_png_write_chunk_end(a1);
}

uint64_t _cg_png_write_chunk_data(uint64_t result, Bytef *a2, uint64_t a3)
{
  if (result && a2 && a3)
  {
    uint64_t v5 = result;
    png_write_data(result);
    return png_calculate_crc(v5, a2, a3);
  }
  return result;
}

uint64_t png_write_data(uint64_t a1)
{
  uint64_t v1 = *(uint64_t (**)(void))(a1 + 24);
  if (!v1) {
    _cg_png_error((void (**)(void))a1, "Call to NULL write function");
  }

  return v1();
}

size_t write_fn(void (**a1)(void), const void *a2, size_t a3)
{
  uint64_t io_ptr = (IIOImageWriteSession *)_cg_png_get_io_ptr((uint64_t)a1);
  size_t result = IIOImageWriteSession::putBytes(io_ptr, a2, a3);
  if (result != a3) {
    _cg_png_error(a1, "Write Error");
  }
  return result;
}

size_t IIOImageWriteSession::putBytes(IIOImageWriteSession *this, const void *__ptr, size_t __nitems)
{
  size_t v3 = __nitems;
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  Bytef v6 = (FILE *)*((void *)this + 4);
  if (v6)
  {
    if (fwrite(__ptr, 1uLL, __nitems, v6) != __nitems)
    {
      __error();
      unsigned __int8 v7 = __error();
      strerror(*v7);
      LogError("putBytes", 250, "*** ERROR: failed to write %ld bytes - got: %ld  (err = %d '%s')\n");
      return 0;
    }
  }
  else
  {
    Bytef v8 = (__CFData *)*((void *)this + 3);
    if (v8)
    {
      unint64_t v10 = *((void *)this + 7);
      uint64_t v9 = *((void *)this + 8);
      if (v9 == v10)
      {
        CFDataAppendBytes(v8, (const UInt8 *)__ptr, __nitems);
      }
      else
      {
        size_t v13 = v9 + __nitems;
        if (v13 > v10)
        {
          CFDataIncreaseLength(v8, v13 - v10);
          Bytef v8 = (__CFData *)*((void *)this + 3);
        }
        MutableBytePtr = CFDataGetMutableBytePtr(v8);
        memcpy(&MutableBytePtr[*((void *)this + 8)], __ptr, v3);
      }
    }
    else if (*((void *)this + 2))
    {
      unint64_t v12 = *((void *)this + 7);
      unint64_t v11 = *((void *)this + 8);
      if (v11 < v12)
      {
        LogError("putBytes", 271, "*** ERROR: cannot write unless at end of data\n");
        return 0;
      }
      bzero(v20, 0x400uLL);
      if (v11 > v12)
      {
        do
        {
          uint64_t v15 = CGDataConsumerPutBytes();
          unint64_t v16 = *((void *)this + 8);
          unint64_t v17 = *((void *)this + 7) + v15;
          *((void *)this + 7) = v17;
        }
        while (v16 > v17);
      }
      size_t v3 = CGDataConsumerPutBytes();
    }
  }
  size_t v18 = *((void *)this + 8) + v3;
  if (v18 > *((void *)this + 7)) {
    *((void *)this + 7) = v18;
  }
  *((void *)this + 8) = v18;
  return v3;
}

uint64_t _cg_png_write_chunk_end(uint64_t result)
{
  if (result)
  {
    *(_DWORD *)(result + 956) = 130;
    return png_write_data(result);
  }
  return result;
}

uint64_t _cg_png_set_do_filter(uint64_t result, char a2)
{
  *(unsigned char *)(result + 390) = a2;
  return result;
}

void (**_cg_png_insert_iDOTBreak(uint64_t a1))(void)
{
  unint64_t v2 = (z_stream *)(a1 + 96);
  while (1)
  {
    if (deflate(v2, 3))
    {
      uint64_t v5 = *(const char **)(a1 + 144);
      if (!v5) {
        uint64_t v5 = "zlib error";
      }
      _cg_png_error((void (**)(void))a1, v5);
    }
    int v3 = *(_DWORD *)(a1 + 128);
    if (v3) {
      break;
    }
    _cg_png_write_complete_chunk((void (**)(void))a1, 1229209940, *(Bytef **)(*(void *)(a1 + 208) + 8), *(unsigned int *)(a1 + 216));
    *(void *)(a1 + 120) = *(void *)(*(void *)(a1 + 208) + 8);
    *(_DWORD *)(a1 + 128) = *(_DWORD *)(a1 + 216);
  }
  if (*(_DWORD *)(a1 + 104) != v3) {
    _cg_png_write_complete_chunk((void (**)(void))a1, 1229209940, *(Bytef **)(*(void *)(a1 + 208) + 8), (*(_DWORD *)(a1 + 216) - v3));
  }
  *(_DWORD *)(a1 + 444) = 0;
  png_flush(a1);
  _cg_png_cleanup_for_write_start_row(a1);
  *(_DWORD *)(a1 + 92) = 0;
  *(_DWORD *)(a1 + 84) |= 0x10u;
  size_t result = _cg_png_write_start_row(a1);
  *(void *)(a1 + 120) = *(void *)(*(void *)(a1 + 208) + 8);
  *(_DWORD *)(a1 + 128) = *(_DWORD *)(a1 + 216);
  return result;
}

void (**_cg_png_write_start_row(uint64_t a1))(void)
{
  unsigned int v2 = *(unsigned __int8 *)(a1 + 393) * *(unsigned __int8 *)(a1 + 396);
  unsigned int v3 = *(_DWORD *)(a1 + 280);
  unint64_t v4 = (v3 * (unint64_t)v2 + 7) >> 3;
  unint64_t v5 = v3 * (unint64_t)(v2 >> 3);
  if (v2 < 8) {
    unint64_t v5 = v4;
  }
  size_t v6 = v5 + 1;
  *(unsigned char *)(a1 + 399) = *(unsigned char *)(a1 + 394);
  *(unsigned char *)(a1 + 398) = v2;
  unsigned __int8 v7 = *(void **)(a1 + 328);
  if (v7) {
    free(v7);
  }
  size_t result = png_malloc((void (**)(void))a1, v6);
  *(void *)(a1 + 328) = result;
  *(unsigned char *)size_t result = 0;
  unsigned int v9 = *(unsigned __int8 *)(a1 + 390);
  if (*(_DWORD *)(a1 + 284) == 1) {
    v9 &= 0x1Fu;
  }
  if (*(_DWORD *)(a1 + 280) == 1) {
    v9 &= 0x2Fu;
  }
  if ((_BYTE)v9) {
    unsigned int v10 = v9;
  }
  else {
    unsigned int v10 = 8;
  }
  *(unsigned char *)(a1 + 390) = v10;
  if (v10 >= 0x10)
  {
    if (!*(void *)(a1 + 336))
    {
      size_t result = png_malloc((void (**)(void))a1, v6);
      *(void *)(a1 + 336) = result;
      if (((v10 >> 5) & 1) + (v10 >> 7) + ((v10 >> 4) & 1) + ((v10 >> 6) & 1) >= 2)
      {
        size_t result = png_malloc((void (**)(void))a1, v6);
        *(void *)(a1 + 344) = result;
      }
    }
    if (v10 >= 0x20)
    {
      size_t result = png_calloc((void (**)(void))a1, v6);
      *(void *)(a1 + 320) = result;
    }
  }
  if (!*(unsigned char *)(a1 + 388))
  {
    int v11 = *(_DWORD *)(a1 + 284);
    goto LABEL_22;
  }
  int v11 = *(_DWORD *)(a1 + 284);
  if ((*(unsigned char *)(a1 + 88) & 2) != 0)
  {
LABEL_22:
    *(_DWORD *)(a1 + 288) = v11;
    unsigned int v12 = *(_DWORD *)(a1 + 280);
    goto LABEL_23;
  }
  *(_DWORD *)(a1 + 288) = (v11 + 7) >> 3;
  unsigned int v12 = (*(_DWORD *)(a1 + 280) + 7) >> 3;
LABEL_23:
  *(_DWORD *)(a1 + 292) = v12;
  return result;
}

uint64_t png_flush(uint64_t result)
{
  uint64_t v1 = *(uint64_t (**)(void))(result + 432);
  if (v1) {
    return v1();
  }
  return result;
}

uint64_t _cg_png_get_do_filter(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 390);
}

void _cg_png_cleanup_for_write_start_row(uint64_t a1)
{
  unsigned int v2 = *(void **)(a1 + 328);
  if (v2)
  {
    free(v2);
    *(void *)(a1 + 328) = 0;
  }
  unsigned int v3 = *(void **)(a1 + 320);
  if (v3)
  {
    free(v3);
    *(void *)(a1 + 320) = 0;
  }
}

void *IIOImagePixelDataProvider::createEncodingTempBuffer(IIOImagePixelDataProvider *this, unint64_t *a2, unint64_t *a3)
{
  if (IIOImagePixelDataProvider::createEncodingTempBuffer(unsigned long *,unsigned long *)::once != -1) {
    dispatch_once(&IIOImagePixelDataProvider::createEncodingTempBuffer(unsigned long *,unsigned long *)::once, &__block_literal_global_41);
  }
  if (*((uint64_t (**)(IIOImagePixelDataProvider *__hidden, void *, void *, unint64_t))this + 23) == IIOImagePixelDataProvider::GetBytesCGAccessSessionNoConvert)
  {
    unint64_t v6 = 1;
  }
  else
  {
    unint64_t v6 = *((void *)this + 22);
    if (!v6)
    {
      unint64_t v6 = (unint64_t)IIOImagePixelDataProvider::createEncodingTempBuffer(unsigned long *,unsigned long *)::recommendedBufferSize
         / *((void *)this + 18);
      if (v6 >= *((void *)this + 4)) {
        unint64_t v6 = *((void *)this + 4);
      }
      if (v6 <= 1) {
        unint64_t v6 = 1;
      }
    }
  }
  *a2 = v6;
  size_t v7 = *((void *)this + 18) * v6;
  *a3 = v7;
  memptr = 0;
  if (!malloc_type_posix_memalign(&memptr, 0x40uLL, v7, 0x6071521CuLL)) {
    return memptr;
  }
  *a2 = 1;
  size_t v8 = *((void *)this + 18);
  *a3 = v8;
  return malloc_type_malloc(v8, 0x2485E155uLL);
}

uint64_t IIOImagePixelDataProvider::getBitmapInfo(IIOImagePixelDataProvider *this)
{
  return *((unsigned int *)this + 24);
}

uint64_t png_write_compressed_data_out(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a1;
  unsigned int v3 = *(_DWORD *)(a2 + 16);
  unint64_t v4 = (Bytef *)(a2 + 20);
  unint64_t v5 = *(void **)(a1 + 208);
  if (v3 >= 0x400) {
    uint64_t v6 = 1024;
  }
  else {
    uint64_t v6 = v3;
  }
  while (1)
  {
    uint64_t result = _cg_png_write_chunk_data(a1, v4, v6);
    v3 -= v6;
    if (!v3 || v5 == 0) {
      break;
    }
    unsigned int v9 = *(_DWORD *)(v2 + 216);
    unsigned int v10 = v5;
    unint64_t v5 = (void *)*v5;
    unint64_t v4 = (Bytef *)v10[1];
    if (v9 >= v3) {
      uint64_t v6 = v3;
    }
    else {
      uint64_t v6 = v9;
    }
    a1 = v2;
  }
  if (v3) {
    _cg_png_error((void (**)(void))v2, "error writing ancillary chunked compressed data");
  }
  return result;
}

uint64_t png_check_keyword(uint64_t a1, unsigned __int8 *a2, unsigned char *a3)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  if (a2)
  {
    unsigned int v4 = *a2;
    if (*a2)
    {
      unsigned int v5 = 0;
      unsigned int v6 = 0;
      int v7 = 1;
      size_t v8 = a2;
      do
      {
        if (v4 > 0xA0 || v4 - 33 <= 0x5D)
        {
          int v7 = 0;
          *a3++ = v4;
          ++v6;
        }
        else
        {
          if (v7)
          {
            if (!v5) {
              unsigned int v5 = v4;
            }
          }
          else
          {
            *a3++ = 32;
            ++v6;
            if (v4 != 32) {
              unsigned int v5 = v4;
            }
          }
          int v7 = 1;
        }
        unsigned int v9 = *++v8;
        unsigned int v4 = v9;
      }
      while (v9 && v6 < 0x4F);
    }
    else
    {
      unsigned int v6 = 0;
      unsigned int v5 = 0;
      int v7 = 1;
      size_t v8 = a2;
    }
    if (v6) {
      BOOL v11 = v7 == 0;
    }
    else {
      BOOL v11 = 1;
    }
    uint64_t v12 = !v11;
    if ((v12 & (v5 == 0)) != 0) {
      unint64_t v13 = 32;
    }
    else {
      unint64_t v13 = v5;
    }
    a3[-v12] = 0;
    uint64_t v10 = v6 - v12;
    if (v10)
    {
      if (*v8)
      {
        png_warning(a1, "keyword truncated");
      }
      else if (v13)
      {
        memset(v15, 0, sizeof(v15));
        png_warning_parameter((uint64_t)v15, 1, a2);
        png_warning_parameter_signed((uint64_t)v15, 2, 4, v13);
        png_formatted_warning(a1, (uint64_t)v15, "keyword \"@1\": bad character '0x@2'");
      }
    }
  }
  else
  {
    uint64_t v10 = 0;
    *a3 = 0;
  }
  return v10;
}

CGImageSourceRef CGImageSourceCreateWithData(CFDataRef data, CFDictionaryRef options)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  kdebug_trace();
  IIOInitDebugFlags();
  if (data)
  {
    CFTypeID v4 = CFGetTypeID(data);
    if (v4 == CFDataGetTypeID())
    {
      CFDataGetLength(data);
      if (options)
      {
        CFTypeID v5 = CFGetTypeID(options);
        CFTypeID TypeID = CFDictionaryGetTypeID();
        CFDictionaryRef v7 = options;
        if (v5 == TypeID) {
          goto LABEL_7;
        }
        LogError("CGImageSourceCreateWithData", 4535, "*** ERROR: CGImageSourceCreateWithData: options parameter is not a CFDictionaryRef - ignoring\n");
      }
      CFDictionaryRef v7 = 0;
LABEL_7:
      memset(__str, 0, sizeof(__str));
      *(void *)&long long v10 = 0;
      IIODictionary::IIODictionary((IIODictionary *)__str, v7);
      operator new();
    }
    LogError("CGImageSourceCreateWithData", 4531, "*** ERROR: CGImageSourceCreateWithData: data is not a CFDataRef\n");
  }
  else
  {
    LogError("CGImageSourceCreateWithData", 4530, "*** ERROR: CGImageSourceCreateWithData: data is nil\n");
  }
  if ((gIIODebugFlags & 0x800000000000) != 0) {
    ImageIOLog(" ISSUE: %s:%d:  %s\n", "CGImageSourceCreateWithData", 4588, "could not create CGImageSourceRef");
  }
  kdebug_trace();
  kdebug_trace();
  return 0;
}

void sub_1885C99D0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29)
{
  MEMORY[0x18C11C0E0](v29, 0x10E1C40A1B1CD90);
  IIODictionary::~IIODictionary((IIODictionary *)&a29);
  _Unwind_Resume(a1);
}

void IIOImageSource::IIOImageSource(IIOImageSource *this, CGDataProvider *a2, IIODictionary *a3)
{
  *(void *)this = &unk_1ED4E1420;
  *((void *)this + 18) = 0;
  *((void *)this + 19) = 0;
  *((void *)this + 20) = 0;
  *((void *)this + 25) = 0;
  *((void *)this + 26) = 0;
  *((void *)this + 27) = 0;
  IIOImageSource::setup((uint64_t)this, 2);
  if (a3) {
    IIOImageSource::extractOptions(this, a3);
  }
  *((void *)this + 2) = CGImageReadCreateWithProvider(*((void *)this + 1), a2, (CGDataProvider *)1);
  if ((gIIODebugFlags & 0x10000000) != 0)
  {
    CFDataRef v6 = CGDataProviderCopyData(a2);
    if (v6)
    {
      ImageIO_saveImageData("CGImageSourceCreateWithDataProvider", v6);
      CFRelease(v6);
    }
  }
}

void sub_1885C9AE0(_Unwind_Exception *exception_object)
{
  CFTypeID v5 = *v3;
  if (*v3)
  {
    *(void *)(v1 + 208) = v5;
    operator delete(v5);
  }
  CFDataRef v6 = *v2;
  if (*v2)
  {
    *(void *)(v1 + 152) = v6;
    operator delete(v6);
  }
  _Unwind_Resume(exception_object);
}

void IIOImageSource::IIOImageSource(IIOImageSource *this, const __CFData *a2, IIODictionary *a3)
{
  *(void *)this = &unk_1ED4E1420;
  *((void *)this + 18) = 0;
  *((void *)this + 19) = 0;
  *((void *)this + 20) = 0;
  *((void *)this + 25) = 0;
  *((void *)this + 26) = 0;
  *((void *)this + 27) = 0;
  IIOImageSource::setup((uint64_t)this, 1);
  if (a3) {
    IIOImageSource::extractOptions(this, a3);
  }
  *((void *)this + 2) = CGImageReadCreateWithData(*((void *)this + 1), a2, (__CFData *)1);
  if ((gIIODebugFlags & 0x10000000) != 0) {
    ImageIO_saveImageData("CGImageSourceCreateWithData", a2);
  }
}

void sub_1885C9BCC(_Unwind_Exception *exception_object)
{
  CFTypeID v5 = *v3;
  if (*v3)
  {
    *(void *)(v1 + 208) = v5;
    operator delete(v5);
  }
  CFDataRef v6 = *v2;
  if (*v2)
  {
    *(void *)(v1 + 152) = v6;
    operator delete(v6);
  }
  _Unwind_Resume(exception_object);
}

uint64_t CGImageReadRefCreateWith_ImageRead(IIOImageRead *a1)
{
  if (CGImageReadGetTypeID::once != -1) {
    dispatch_once(&CGImageReadGetTypeID::once, &__block_literal_global_76);
  }
  uint64_t Instance = _CFRuntimeCreateInstance();
  *(_DWORD *)(Instance + 16) = 1;
  atomic_fetch_add_explicit(&gReadRefCount, 1uLL, memory_order_relaxed);
  *(void *)(Instance + 24) = a1;
  *((void *)a1 + 1) = Instance;
  if ((unsigned __int16)gIIODebugFlags >> 14) {
    ImageIODebugOptions((unsigned __int16)gIIODebugFlags >> 14, "S", "CGImageReadRefCreate", (CFTypeRef)Instance, 0, -1, 0);
  }
  return Instance;
}

CFMutableArrayRef IIOImageSource::setup(uint64_t a1, int a2)
{
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 8) = 0;
  *(_WORD *)(a1 + 32) = 0;
  *(_DWORD *)(a1 + 48) = -16711679;
  *(_WORD *)(a1 + 52) = -255;
  *(unsigned char *)(a1 + 54) = a2;
  *(void *)(a1 + 56) = 0;
  *(_DWORD *)(a1 + 64) = 0;
  *(void *)(a1 + 72) = 0;
  *(void *)(a1 + 80) = 0;
  *(_WORD *)(a1 + 88) = 0;
  *(void *)(a1 + 96) = 0;
  *(void *)(a1 + 104) = 0;
  *(_DWORD *)(a1 + 112) = -5;
  *(_DWORD *)(a1 + 352) = 0;
  *(void *)(a1 + 120) = 0;
  *(void *)(a1 + 128) = 0;
  *(void *)(a1 + 136) = 0;
  pthread_mutex_init((pthread_mutex_t *)(a1 + 224), 0);
  CFMutableArrayRef result = (CFMutableArrayRef)pthread_mutex_init((pthread_mutex_t *)(a1 + 288), 0);
  *(void *)(a1 + 360) = a1;
  *(void *)(a1 + 368) = a1;
  *(void *)(a1 + 176) = 0;
  *(void *)(a1 + 184) = 0;
  *(void *)(a1 + 168) = 0;
  if (a2 != 8)
  {
    CFAllocatorRef v5 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    *(void *)(a1 + 184) = CFSetCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D548]);
    CFDataRef v6 = (const CFArrayCallBacks *)MEMORY[0x1E4F1D510];
    *(void *)(a1 + 168) = CFArrayCreateMutable(v5, 0, MEMORY[0x1E4F1D510]);
    *(void *)(a1 + 176) = CFArrayCreateMutable(v5, 0, v6);
    CFMutableArrayRef result = CFArrayCreateMutable(v5, 0, v6);
    *(void *)(a1 + 192) = result;
  }
  return result;
}

uint64_t IIOImageSource::extractOptions(IIOImageSource *this, IIODictionary *a2)
{
  if (!*((void *)this + 7))
  {
    CFDictionaryRef ObjectForKey = IIODictionary::getObjectForKey(a2, @"kCGImageSourceTypeIdentifierHint");
    if (ObjectForKey)
    {
      CFStringRef v14 = (const __CFString *)ObjectForKey;
      CFTypeID v15 = CFGetTypeID(ObjectForKey);
      CFTypeID TypeID = (IIO_ReaderHandler *)CFStringGetTypeID();
      if ((IIO_ReaderHandler *)v15 == TypeID)
      {
        ReaderHandler = (IIO_ReaderHandler *)IIO_ReaderHandler::GetReaderHandler(TypeID);
        size_t v18 = IIO_ReaderHandler::readerForUTType(ReaderHandler, v14);
        *((void *)this + 12) = v18;
        if (v18)
        {
          *((void *)this + 7) = CFRetain(v14);
          *((unsigned char *)this + 88) = IIODictionary::getBoolForKey(a2, @"kCGImageSourceFailForDataNotMatchingHint");
        }
        else
        {
          uint64_t v21 = IIOString::IIOString((IIOString *)v25, v14);
          char v22 = (const char *)IIOString::utf8String(v21);
          LogError("extractOptions", 211, "*** ERROR: unknown hint identifier 'kCGImageSourceTypeIdentifierHint:%s' -- ignoring...\n", v22);
          IIOString::~IIOString((IIOString *)v25);
        }
      }
    }
  }
  CFDictionaryRef v4 = IIODictionary::getObjectForKey(a2, @"kCGImageSourceDecodeFormatAllowlist");
  if (v4
    && (v5 = v4, v6 = CFGetTypeID(v4), CFDictionaryRef v7 = (IIO_ReaderHandler *)CFArrayGetTypeID(), (IIO_ReaderHandler *)v6 == v7))
  {
    if (!*((void *)this + 7))
    {
      LogError("extractOptions", 222, "*** ERROR: cannot use 'kCGImageSourceDecodeFormatAllowlist' without specifiying 'kCGImageSourceTypeIdentifierHint'\n");
      goto LABEL_21;
    }
    size_t v8 = (IIO_ReaderHandler *)IIO_ReaderHandler::GetReaderHandler(v7);
    unsigned int v9 = IIO_ReaderHandler::copyTypeIdentifiers(v8);
    CFIndex Count = CFArrayGetCount(v9);
    memset(v25, 0, sizeof(v25));
    IIOArray::IIOArray((IIOArray *)v25, v5);
    CFSetRef Mutable = CFSetCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D548]);
    v24[0] = MEMORY[0x1E4F143A8];
    v24[1] = 0x40000000;
    unsigned int v24[2] = ___ZN14IIOImageSource14extractOptionsEP13IIODictionary_block_invoke;
    v24[3] = &__block_descriptor_tmp_3;
    _OWORD v24[4] = v9;
    v24[5] = 0;
    v24[6] = Count;
    v24[7] = Mutable;
    IIOArray::enumerate((uint64_t)v25, (uint64_t)v24);
    if (!CFSetContainsValue(Mutable, *((const void **)this + 7)))
    {
      IIOString::IIOString((IIOString *)v23, *((const void **)this + 7));
      uint64_t v12 = (const char *)IIOString::utf8String((IIOString *)v23);
      LogError("extractOptions", 241, "*** ERROR: kCGImageSourceDecodeFormatAllowlist does not contain the provided hint '%s'\n", v12);
      IIOString::~IIOString((IIOString *)v23);
      CFSetAddValue(Mutable, *((const void **)this + 7));
    }
    *((unsigned char *)this + 88) = 1;
    IIOArray::~IIOArray((IIOArray *)v25);
  }
  else
  {
    if (!*((void *)this + 7) || !*((unsigned char *)this + 88)) {
      goto LABEL_21;
    }
    CFSetRef Mutable = CFSetCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D548]);
    CFSetAddValue(Mutable, *((const void **)this + 7));
  }
  if (*((unsigned char *)this + 88) && Mutable)
  {
    IIOImageSource::updateAllowedflags(this, Mutable);
  }
  else if (!Mutable)
  {
    goto LABEL_21;
  }
  CFRelease(Mutable);
LABEL_21:
  if (IIODictionary::containsKey(a2, @"kCGImageSourceShouldMemoryMap"))
  {
    BOOL BoolForKey = IIODictionary::getBoolForKey(a2, @"kCGImageSourceShouldMemoryMap");
    *((unsigned char *)this + 48) = BoolForKey;
    if (!BoolForKey) {
      goto LABEL_27;
    }
  }
  else if (!*((unsigned char *)this + 48))
  {
    goto LABEL_27;
  }
  if (IIODictionary::containsKey(a2, @"kCGImageSourceMemoryMapAsShared")) {
    *((unsigned char *)this + 49) = 1;
  }
LABEL_27:
  *((unsigned char *)this + 50) = 1;
  if (IIODictionary::containsKey(a2, @"kCGImageSourceRespectHEIFFileOrder")) {
    *((unsigned char *)this + 50) = IIODictionary::getBoolForKey(a2, @"kCGImageSourceRespectHEIFFileOrder");
  }
  *((unsigned char *)this + 51) = -1;
  if (IIODictionary::containsKey(a2, @"kCGImageSourceIgnoreJPEGAuxImages")) {
    *((unsigned char *)this + 51) = IIODictionary::getBoolForKey(a2, @"kCGImageSourceIgnoreJPEGAuxImages");
  }
  *((unsigned char *)this + 52) = 1;
  if (IIODictionary::containsKey(a2, @"kCGImageSourcePreferHEIFCollection")) {
    *((unsigned char *)this + 52) = !IIODictionary::getBoolForKey(a2, @"kCGImageSourcePreferHEIFCollection");
  }
  *((void *)this + 17) = 0;
  if (IIODictionary::containsKey(a2, @"kCGImageSourceForceUseServer")) {
    uint64_t result = IIODictionary::getBoolForKey(a2, @"kCGImageSourceForceUseServer");
  }
  else {
    uint64_t result = 255;
  }
  *((unsigned char *)this + 53) = result;
  return result;
}

void sub_1885CA1B0(_Unwind_Exception *a1)
{
  IIOArray::~IIOArray((IIOArray *)(v1 - 72));
  _Unwind_Resume(a1);
}

uint64_t CGImageReadCreateWithData(int a1, IIOImageRead *this, __CFData *a3)
{
  if (this) {
    IIOImageRead::CreateWithData(this, a3);
  }
  return 0;
}

void IIOImageRead::CreateWithData(IIOImageRead *this, const __CFData *a2)
{
  if (copyInputDataCheck != -1) {
    dispatch_once(&copyInputDataCheck, &__block_literal_global_8);
  }
  operator new();
}

void sub_1885CA2F4(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10F1C405FDDC6B3);
  _Unwind_Resume(a1);
}

uint64_t IIOImageRead::IIOImageRead(uint64_t a1, const __CFData *a2, int a3, char a4)
{
  *(void *)a1 = &unk_1ED4DF1B0;
  *(void *)(a1 + 152) = 0;
  *(void *)(a1 + 248) = 0;
  *(void *)(a1 + 240) = a1 + 248;
  *(void *)(a1 + 160) = 0;
  *(void *)(a1 + 168) = 0;
  *(void *)(a1 + 256) = 0;
  *(void *)(a1 + 296) = 0;
  *(void *)(a1 + 304) = 0;
  *(void *)(a1 + 288) = 0;
  IIOImageRead::setup(a1, a3);
  *(unsigned char *)(a1 + 64) = a4;
  *(unsigned char *)(a1 + 65) = a4 ^ 1;
  if (gCopyInputData)
  {
    *(void *)(a1 + 32) = CFDataCreateCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a2);
    if ((gIIODebugFlags & 0x80000000000) != 0) {
      ImageIOLog("D   %s:%d CFDataCreateCopy %p\n");
    }
  }
  else
  {
    *(void *)(a1 + 32) = CFRetain(a2);
    if ((gIIODebugFlags & 0x80000000000) != 0) {
      ImageIOLog("D   %s:%d CFRetain %p\n");
    }
  }
  *(void *)(a1 + 80) = CFDataGetLength(a2);
  return a1;
}

void sub_1885CA450(_Unwind_Exception *a1)
{
  CFDictionaryRef v7 = *v5;
  if (*v5)
  {
    *(void *)(v1 + 296) = v7;
    operator delete(v7);
  }
  std::__tree<std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>>>::destroy(v2, *v4);
  size_t v8 = *v3;
  if (*v3)
  {
    *(void *)(v1 + 160) = v8;
    operator delete(v8);
  }
  _Unwind_Resume(a1);
}

const char *IIOImageRead::setup(uint64_t a1, int a2)
{
  *(_DWORD *)(a1 + 72) = a2;
  *(unsigned char *)(a1 + 64) = 0;
  *(unsigned char *)(a1 + 71) = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 24) = -1;
  *(void *)(a1 + 80) = 0;
  *(_DWORD *)(a1 + 66) = 0;
  *(_DWORD *)(a1 + 440) = 0;
  *(void *)(a1 + 448) = 0;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(void *)(a1 + 272) = 0;
  *(void *)(a1 + 280) = 0;
  *(void *)(a1 + --*(void *)(result + 264) = 0;
  pthread_mutex_init((pthread_mutex_t *)(a1 + 176), 0);
  pthread_mutex_init((pthread_mutex_t *)(a1 + 88), 0);
  pthread_mutex_init((pthread_mutex_t *)(a1 + 376), 0);
  uint64_t result = (const char *)pthread_mutex_init((pthread_mutex_t *)(a1 + 312), 0);
  *(unsigned char *)(a1 + 456) = -1;
  if (!gImageBlockCache)
  {
    uint64_t result = CGImageReadCreateImageBlockCache((cache_s **)&gImageBlockCache);
    if ((gIIODebugFlags & 0x200) != 0) {
      uint64_t result = ImageIOLog("    created global image cache %p\n", (const void *)gImageBlockCache);
    }
  }
  *(void *)(a1 + 464) = a1;
  *(void *)(a1 + 472) = a1;
  return result;
}

IIO_Reader *IIO_ReaderHandler::readerForUTType(IIO_ReaderHandler *this, const __CFString *a2)
{
  uint64_t v2 = (IIO_Reader **)*((void *)this + 2);
  unsigned int v3 = (IIO_Reader **)*((void *)this + 3);
  if (v2 == v3) {
    return 0;
  }
  while (1)
  {
    CFStringRef v5 = (const __CFString *)IIO_Reader::utType(*v2);
    if (CFEqual(v5, a2)) {
      break;
    }
    if (++v2 == v3) {
      return 0;
    }
  }
  return *v2;
}

uint64_t CGImageReadCreateWithProvider(int a1, IIOImageRead *this, CGDataProvider *a3)
{
  if (this) {
    IIOImageRead::CreateWithDataProvider(this, a3);
  }
  return 0;
}

void IIOImageRead::CreateWithDataProvider(IIOImageRead *this, CGDataProvider *a2)
{
  if (copyInputDataCheck == -1)
  {
    if (!this) {
      goto LABEL_14;
    }
  }
  else
  {
    dispatch_once(&copyInputDataCheck, &__block_literal_global_86);
    if (!this) {
      goto LABEL_14;
    }
  }
  SizeOfuint64_t Data = CGDataProviderGetSizeOfData();
  if (SizeOfData != -1)
  {
    CFIndex v4 = SizeOfData;
    if (!SizeOfData) {
      goto LABEL_14;
    }
    if (!gCopyInputData)
    {
      uint64_t v5 = CGDataProviderRetainBytePtr();
      if (v5)
      {
        CFTypeID v6 = (const UInt8 *)v5;
        context.version = 0;
        context.info = this;
        context.retain = (CFAllocatorRetainCallBack)_providerRetain;
        context.release = (CFAllocatorReleaseCallBack)_providerRelease;
        memset(&context.copyDescription, 0, 40);
        CFAllocatorRef v7 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
        CFAllocatorRef v8 = CFAllocatorCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], &context);
        if (v8)
        {
          CFAllocatorRef v9 = v8;
          CFDataRef v10 = CFDataCreateWithBytesNoCopy(v7, v6, v4, v8);
          CFRelease(v9);
          if (v10) {
LABEL_7:
          }
            operator new();
        }
        else
        {
          CGDataProviderReleaseBytePtr();
        }
      }
    }
  }
  if (CGDataProviderCopyData(this)) {
    goto LABEL_7;
  }
LABEL_14:
  operator new();
}

void sub_1885CA7EC(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10F1C405FDDC6B3);
  _Unwind_Resume(a1);
}

const char *CGImageReadCreateImageBlockCache(cache_s **cache_out)
{
  uint64_t result = (const char *)cache_create("com.apple.ImageIO.imageblockcache", &ImageIOCacheAttributes, cache_out);
  if ((~gIIODebugFlags & 0x300) == 0) {
    return ImageIOLog("    cache_create 'com.apple.ImageIO.imageblockcache' %p\n", cache_out);
  }
  return result;
}

const char *IIOReadPlugin::ImageBlockRelease(const char *result, const void *a2)
{
  if ((gIIODebugFlags & 0xC00) != 0) {
    uint64_t result = IIO_ImageBlockReleased(result, a2);
  }
  if (a2)
  {
    uint64_t Data = (void *)CGImageBlockGetData();
    return (const char *)CGImageReadSessionReleaseCachedImageBlockData(Data);
  }
  return result;
}

CFArrayRef __IIODecodingSetAllowableTypes_block_invoke(IIO_ReaderHandler *a1)
{
  uint64_t v1 = a1;
  if ((gIIODebugFlags & 0x4000000000000) != 0)
  {
    a1 = (IIO_ReaderHandler *)IIO_OSAppleInternalBuild();
    if (a1)
    {
      CFIndex Count = CFArrayGetCount(*((CFArrayRef *)v1 + 5));
      a1 = (IIO_ReaderHandler *)ImageIOLog(" CGImageSourceSetAllowableTypes: limiting to %ld types\n", Count);
    }
  }
  ReaderHandler = (uint64_t **)IIO_ReaderHandler::GetReaderHandler(a1);
  *(_DWORD *)(*(void *)(*((void *)v1 + 4) + 8) + 24) = IIO_ReaderHandler::setAllowableTypes(ReaderHandler, *((const __CFArray **)v1 + 5));
  if (gAllowedTypes) {
    CFRelease((CFTypeRef)gAllowedTypes);
  }
  CFArrayRef result = CGImageSourceCopyTypeIdentifiers();
  gAllowedTypes = (uint64_t)result;
  gAllowedTypesChanged = 1;
  return result;
}

CFArrayRef CGImageSourceCopyTypeIdentifiers(void)
{
  kdebug_trace();
  IIOInitDebugFlags();
  CFAllocatorRef v0 = (IIO_ReaderHandler *)((gIIODebugFlags >> 12) & 3);
  if (v0) {
    ImageIODebugOptions((int)v0, "A", "CGImageSourceCopyTypeIdentifiers", 0, 0, -1, 0);
  }
  ReaderHandler = (IIO_ReaderHandler *)IIO_ReaderHandler::GetReaderHandler(v0);
  uint64_t v2 = IIO_ReaderHandler::copyTypeIdentifiers(ReaderHandler);
  kdebug_trace();
  return v2;
}

__CFArray *IIO_ReaderHandler::copyTypeIdentifiers(IIO_ReaderHandler *this)
{
  CFSetRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
  CFIndex v4 = (IIO_Reader **)*((void *)this + 2);
  unsigned int v3 = (IIO_Reader **)*((void *)this + 3);
  while (v4 != v3)
  {
    if (IIO_Reader::addToTypeIdentifiers(*v4))
    {
      uint64_t v5 = (const void *)IIO_Reader::utType(*v4);
      CFArrayAppendValue(Mutable, v5);
    }
    ++v4;
  }
  return Mutable;
}

uint64_t IIO_Reader::addToTypeIdentifiers(IIO_Reader *this)
{
  return *((unsigned __int8 *)this + 48);
}

const char *IIOReadPlugin::ImageBlockReleaseNonCached(const char *result, const void *a2)
{
  size_t v3 = (size_t)result;
  if ((gIIODebugFlags & 0xC00) != 0) {
    CFArrayRef result = IIO_ImageBlockReleased(result, a2);
  }
  if (a2)
  {
    unint64_t Data = CGImageBlockGetData();
    return (const char *)_ImageIO_Free(Data, v3);
  }
  return result;
}

uint64_t IIO_InitializeXMPToolkit()
{
  pthread_mutex_lock(&xmpLock);
  BOOL v0 = TXMPMeta<std::string>::Initialize();
  BOOL v1 = v0;
  BOOL v5 = TXMPFiles<std::string>::Initialize(v0, v2, v3, v4);
  pthread_mutex_unlock(&xmpLock);
  return v1 & v5;
}

BOOL TXMPFiles<std::string>::Initialize(uint64_t a1, uint64_t a2, uint64_t a3, const char *a4)
{
  uint64_t v8 = 0;
  memset(v7, 0, sizeof(v7));
  WXMPFiles_Initialize_1(0, (uint64_t)v7, a3, a4);
  if (*(void *)&v7[0])
  {
    exception = __cxa_allocate_exception(0x18uLL);
    uint64_t v6 = *(void *)&v7[0];
    *(_DWORD *)exception = v8;
    exception[1] = v6;
    *((unsigned char *)exception + 16) = 0;
  }
  return v8 != 0;
}

BOOL WXMPFiles_Initialize_1(XMPFiles *a1, uint64_t a2, uint64_t a3, const char *a4)
{
  *(void *)a2 = 0;
  BOOL result = XMPFiles::Initialize(a1, 0, 0, a4);
  *(_DWORD *)(a2 + 32) = result;
  return result;
}

BOOL XMPFiles::Initialize(XMPFiles *this, unsigned int a2, const char *a3, const char *a4)
{
  int v4 = sXMPFilesInitCount++;
  BOOL result = 1;
  if (v4 <= 0)
  {
    char v6 = (char)this;
    TXMPMeta<std::string>::Initialize();
    uint64_t v7 = ImageIOShouldAllowFullsizeDecode();
    if ((v7 & 1) == 0) {
      return 0;
    }
    uint64_t Instance = (Common::HandlerRegistry *)Common::HandlerRegistry::getInstance((Common::HandlerRegistry *)v7);
    Common::HandlerRegistry::initialize(Instance);
    InitializeUnicodeConversions();
    ignoreLocalText = (v6 & 2) != 0;
    if (!*kXMPFiles_EmbeddedVersion[0] || !*kXMPFiles_EmbeddedCopyright[0]) {
      return 0;
    }
  }
  return result;
}

void sub_1885CAD34(_Unwind_Exception *exception_object, int a2)
{
  if (a2 == 1)
  {
    uint64_t v2 = (unsigned int *)__cxa_begin_catch(exception_object);
    if (_MergedGlobals != -1) {
      dispatch_once(&_MergedGlobals, &__block_literal_global_42);
    }
    GenericErrorCallback::NotifyClient(qword_1EB2C0378, 3, v2, (uint64_t)"");
    __cxa_end_catch();
    JUMPOUT(0x1885CACD0);
  }
  _Unwind_Resume(exception_object);
}

BOOL TXMPMeta<std::string>::Initialize()
{
  uint64_t v4 = 0;
  memset(v3, 0, sizeof(v3));
  WXMPMeta_Initialize_1((XMPMeta *)v3);
  if (*(void *)&v3[0])
  {
    exception = __cxa_allocate_exception(0x18uLL);
    uint64_t v2 = *(void *)&v3[0];
    *(_DWORD *)exception = v4;
    exception[1] = v2;
    *((unsigned char *)exception + 16) = 0;
  }
  return v4 != 0;
}

uint64_t WXMPMeta_Initialize_1(XMPMeta *a1)
{
  *(void *)a1 = 0;
  uint64_t result = XMPMeta::Initialize(a1);
  *((_DWORD *)a1 + 8) = result;
  return result;
}

void InitializeUnicodeConversions(void)
{
  UTF8_to_UTF16Native = (uint64_t)UTF8_to_UTF16Nat;
  UTF8_to_UTF32Native = (uint64_t)UTF8_to_UTF32Nat;
  UTF16Native_to_UTF8 = (uint64_t)UTF16Nat_to_UTF8;
  UTF32Native_to_UTF8 = (uint64_t)UTF32Nat_to_UTF8;
  swap32to16Offset = 1;
  CodePoint_to_UTF16BE = (uint64_t)CodePoint_to_UTF16Swp;
  CodePoint_to_UTF16LE = (uint64_t)CodePoint_to_UTF16Nat;
  CodePoint_from_UTF16BE = (uint64_t)CodePoint_from_UTF16Swp;
  CodePoint_from_UTF16LE = (uint64_t)CodePoint_from_UTF16Nat;
  UTF8_to_UTF16BE = (uint64_t)UTF8_to_UTF16Swp;
  UTF8_to_UTF16LE = (uint64_t)UTF8_to_UTF16Nat;
  UTF8_to_UTF32BE = (uint64_t)UTF8_to_UTF32Swp;
  UTF8_to_UTF32LE = (uint64_t)UTF8_to_UTF32Nat;
  UTF16BE_to_UTF8 = (uint64_t)UTF16Swp_to_UTF8;
  UTF16LE_to_UTF8 = (uint64_t)UTF16Nat_to_UTF8;
  UTF32BE_to_UTF8 = (uint64_t)UTF32Swp_to_UTF8;
  UTF32LE_to_UTF8 = (uint64_t)UTF32Nat_to_UTF8;
  UTF16BE_to_UTF32BE = (uint64_t)UTF16Swp_to_UTF32Swp;
  UTF16BE_to_UTF32LE = (uint64_t)UTF16Swp_to_UTF32Nat;
  UTF16LE_to_UTF32BE = (uint64_t)UTF16Nat_to_UTF32Swp;
  UTF16LE_to_UTF32LE = (uint64_t)UTF16Nat_to_UTF32Nat;
  UTF32BE_to_UTF16BE = (uint64_t)UTF32Swp_to_UTF16Swp;
  UTF32BE_to_UTF16LE = (uint64_t)UTF32Swp_to_UTF16Nat;
  UTF32LE_to_UTF16BE = (uint64_t)UTF32Nat_to_UTF16Swp;
  UTF32LE_to_UTF16LE = (uint64_t)UTF32Nat_to_UTF16Nat;
}

uint64_t Common::HandlerRegistry::getInstance(Common::HandlerRegistry *this)
{
  if (!Common::HandlerRegistry::sInstance) {
    operator new();
  }
  return Common::HandlerRegistry::sInstance;
}

void sub_1885CB100(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x20C40DC1BFBCFLL);
  _Unwind_Resume(a1);
}

void Common::HandlerRegistry::HandlerRegistry(Common::HandlerRegistry *this)
{
}

uint64_t Common::HandlerRegistry::initialize(Common::HandlerRegistry *this)
{
  int v2 = Common::HandlerRegistry::registerNormalHandler(this, 0x50534420u, 0x227Fu, (uint64_t)PSD_CheckFormat, (uint64_t)PSD_MetaHandlerCTor, 0);
  int v3 = Common::HandlerRegistry::registerNormalHandler(this, 0x54494646u, 0x227Fu, (uint64_t)TIFF_CheckFormat, (uint64_t)TIFF_MetaHandlerCTor, 0);
  int v4 = Common::HandlerRegistry::registerNormalHandler(this, 0x47494620u, 0x46Bu, (uint64_t)GIF_CheckFormat, (uint64_t)GIF_MetaHandlerCTor, 0);
  uint64_t result = Common::HandlerRegistry::registerNormalHandler(this, 0x504E4720u, 0x46Bu, (uint64_t)PNG_CheckFormat, (uint64_t)PNG_MetaHandlerCTor, 0);
  if (!v2 || !v3 || !v4 || (result & 1) == 0)
  {
    exception = __cxa_allocate_exception(0x18uLL);
    *(_DWORD *)exception = 9;
    exception[1] = "Failure initializing linked-in file handlers";
    *((unsigned char *)exception + 16) = 0;
  }
  return result;
}

uint64_t Common::HandlerRegistry::registerNormalHandler(Common::HandlerRegistry *this, unsigned int a2, unsigned int a3, uint64_t a4, uint64_t a5, int a6)
{
  if (a2 == 538976288) {
    Common::HandlerRegistry::registerNormalHandler();
  }
  if ((a3 & 0x100) != 0) {
    Common::HandlerRegistry::registerNormalHandler();
  }
  if ((a3 & 0x1000) != 0) {
    Common::HandlerRegistry::registerNormalHandler();
  }
  if ((a3 & 3) == 1) {
    Common::HandlerRegistry::registerNormalHandler();
  }
  if (!a6)
  {
    if (!Common::HandlerRegistry::getHandlerInfo(this, a2)) {
      goto LABEL_21;
    }
    return 0;
  }
  uint64_t v11 = *((void *)this + 3);
  unint64_t v13 = (uint64_t *)(v11 + 8);
  uint64_t v12 = *(void *)(v11 + 8);
  if (v12)
  {
    uint64_t v14 = v11 + 8;
    do
    {
      unsigned int v15 = *(_DWORD *)(v12 + 32);
      BOOL v16 = v15 >= a2;
      if (v15 >= a2) {
        unint64_t v17 = (uint64_t *)v12;
      }
      else {
        unint64_t v17 = (uint64_t *)(v12 + 8);
      }
      if (v16) {
        uint64_t v14 = v12;
      }
      uint64_t v12 = *v17;
    }
    while (*v17);
    if ((uint64_t *)v14 != v13 && *(_DWORD *)(v14 + 32) <= a2) {
      return 0;
    }
  }
  uint64_t result = Common::HandlerRegistry::getHandlerInfo(this, a2);
  if (!result) {
    return result;
  }
  unsigned int v21 = a2;
  long long v19 = *(_OWORD *)result;
  uint64_t v23 = *(void *)(result + 16);
  long long v22 = v19;
  std::__tree<std::__value_type<unsigned int,Common::XMPFileHandlerInfo>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,Common::XMPFileHandlerInfo>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,Common::XMPFileHandlerInfo>>>::__emplace_hint_unique_key_args<unsigned int,std::pair<unsigned int,Common::XMPFileHandlerInfo>>((uint64_t **)v11, v13, &v21, (uint64_t)&v21);
  Common::HandlerRegistry::removeHandler((uint64_t ***)this, a2);
LABEL_21:
  uint64_t v20 = *((void *)this + 1);
  unsigned int v21 = a2;
  *(void *)&long long v22 = __PAIR64__(a3, a2);
  *((void *)&v22 + 1) = a4;
  uint64_t v23 = a5;
  std::__tree<std::__value_type<unsigned int,Common::XMPFileHandlerInfo>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,Common::XMPFileHandlerInfo>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,Common::XMPFileHandlerInfo>>>::__emplace_hint_unique_key_args<unsigned int,std::pair<unsigned int,Common::XMPFileHandlerInfo>>((uint64_t **)v20, (uint64_t *)(v20 + 8), &v21, (uint64_t)&v21);
  return 1;
}

char *std::__tree<std::__value_type<unsigned int,Common::XMPFileHandlerInfo>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,Common::XMPFileHandlerInfo>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,Common::XMPFileHandlerInfo>>>::__emplace_hint_unique_key_args<unsigned int,std::pair<unsigned int,Common::XMPFileHandlerInfo>>(uint64_t **a1, uint64_t *a2, unsigned int *a3, uint64_t a4)
{
  uint64_t v10 = 0;
  uint64_t v11 = 0;
  char v6 = std::__tree<std::__value_type<unsigned int,Common::XMPFileHandlerInfo>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,Common::XMPFileHandlerInfo>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,Common::XMPFileHandlerInfo>>>::__find_equal<unsigned int>(a1, a2, &v11, &v10, a3);
  uint64_t v7 = (char *)*v6;
  if (!*v6)
  {
    uint64_t v8 = (uint64_t **)v6;
    uint64_t v7 = (char *)operator new(0x40uLL);
    *((_DWORD *)v7 + 8) = *(_DWORD *)a4;
    *(_OWORD *)(v7 + 40) = *(_OWORD *)(a4 + 8);
    *((void *)v7 + 7) = *(void *)(a4 + 24);
    std::__tree<std::__value_type<unsigned long,unsigned long>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,unsigned long>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,unsigned long>>>::__insert_node_at(a1, (uint64_t)v11, v8, (uint64_t *)v7);
  }
  return v7;
}

uint64_t *std::__tree<std::__value_type<unsigned int,Common::XMPFileHandlerInfo>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,Common::XMPFileHandlerInfo>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,Common::XMPFileHandlerInfo>>>::__find_equal<unsigned int>(void *a1, uint64_t *a2, uint64_t **a3, uint64_t *a4, unsigned int *a5)
{
  BOOL v5 = a1 + 1;
  if (a1 + 1 == a2 || (v6 = *a5, unsigned int v7 = *((_DWORD *)a2 + 8), *a5 < v7))
  {
    uint64_t v8 = (uint64_t *)*a2;
    if ((uint64_t *)*a1 == a2)
    {
      uint64_t v10 = a2;
LABEL_17:
      if (v8)
      {
        *a3 = v10;
        return v10 + 1;
      }
      else
      {
        *a3 = a2;
        return a2;
      }
    }
    if (v8)
    {
      CFAllocatorRef v9 = (uint64_t *)*a2;
      do
      {
        uint64_t v10 = v9;
        CFAllocatorRef v9 = (uint64_t *)v9[1];
      }
      while (v9);
    }
    else
    {
      unint64_t v13 = a2;
      do
      {
        uint64_t v10 = (uint64_t *)v13[2];
        BOOL v14 = *v10 == (void)v13;
        unint64_t v13 = v10;
      }
      while (v14);
    }
    unsigned int v15 = *a5;
    if (*((_DWORD *)v10 + 8) < *a5) {
      goto LABEL_17;
    }
    uint64_t v16 = *v5;
    if (*v5)
    {
      do
      {
        while (1)
        {
          unint64_t v17 = (uint64_t *)v16;
          unsigned int v18 = *(_DWORD *)(v16 + 32);
          if (v15 >= v18) {
            break;
          }
          uint64_t v16 = *v17;
          BOOL v5 = v17;
          if (!*v17) {
            goto LABEL_29;
          }
        }
        if (v18 >= v15) {
          break;
        }
        BOOL v5 = v17 + 1;
        uint64_t v16 = v17[1];
      }
      while (v16);
    }
    else
    {
      unint64_t v17 = a1 + 1;
    }
LABEL_29:
    *a3 = v17;
    return v5;
  }
  if (v7 >= v6)
  {
    *a3 = a2;
    *a4 = (uint64_t)a2;
    return a4;
  }
  uint64_t v11 = a2[1];
  if (v11)
  {
    uint64_t v12 = (uint64_t *)a2[1];
    do
    {
      a4 = v12;
      uint64_t v12 = (uint64_t *)*v12;
    }
    while (v12);
  }
  else
  {
    long long v19 = a2;
    do
    {
      a4 = (uint64_t *)v19[2];
      BOOL v14 = *a4 == (void)v19;
      long long v19 = a4;
    }
    while (!v14);
  }
  if (a4 != v5 && v6 >= *((_DWORD *)a4 + 8))
  {
    uint64_t v20 = *v5;
    if (*v5)
    {
      do
      {
        while (1)
        {
          unsigned int v21 = (uint64_t *)v20;
          unsigned int v22 = *(_DWORD *)(v20 + 32);
          if (v6 >= v22) {
            break;
          }
          uint64_t v20 = *v21;
          BOOL v5 = v21;
          if (!*v21) {
            goto LABEL_48;
          }
        }
        if (v22 >= v6) {
          break;
        }
        BOOL v5 = v21 + 1;
        uint64_t v20 = v21[1];
      }
      while (v20);
    }
    else
    {
      unsigned int v21 = a1 + 1;
    }
LABEL_48:
    *a3 = v21;
    return v5;
  }
  if (v11)
  {
    *a3 = a4;
  }
  else
  {
    *a3 = a2;
    return a2 + 1;
  }
  return a4;
}

uint64_t Common::HandlerRegistry::getHandlerInfo(Common::HandlerRegistry *this, unsigned int a2)
{
  uint64_t v2 = *(void *)(*(void *)this + 8);
  if (v2)
  {
    uint64_t v3 = *(void *)this + 8;
    do
    {
      unsigned int v4 = *(_DWORD *)(v2 + 32);
      BOOL v5 = v4 >= a2;
      if (v4 >= a2) {
        unsigned int v6 = (uint64_t *)v2;
      }
      else {
        unsigned int v6 = (uint64_t *)(v2 + 8);
      }
      if (v5) {
        uint64_t v3 = v2;
      }
      uint64_t v2 = *v6;
    }
    while (*v6);
    if (v3 != *(void *)this + 8 && *(_DWORD *)(v3 + 32) <= a2) {
      return v3 + 40;
    }
  }
  uint64_t v7 = *((void *)this + 1);
  uint64_t v10 = *(void *)(v7 + 8);
  uint64_t v8 = v7 + 8;
  uint64_t v9 = v10;
  if (v10)
  {
    uint64_t v3 = v8;
    do
    {
      unsigned int v11 = *(_DWORD *)(v9 + 32);
      BOOL v12 = v11 >= a2;
      if (v11 >= a2) {
        unint64_t v13 = (uint64_t *)v9;
      }
      else {
        unint64_t v13 = (uint64_t *)(v9 + 8);
      }
      if (v12) {
        uint64_t v3 = v9;
      }
      uint64_t v9 = *v13;
    }
    while (*v13);
    if (v3 != v8 && *(_DWORD *)(v3 + 32) <= a2) {
      return v3 + 40;
    }
  }
  uint64_t v14 = *((void *)this + 2);
  uint64_t v17 = *(void *)(v14 + 8);
  uint64_t v15 = v14 + 8;
  uint64_t v16 = v17;
  if (!v17) {
    return 0;
  }
  uint64_t v18 = v15;
  do
  {
    unsigned int v19 = *(_DWORD *)(v16 + 32);
    BOOL v20 = v19 >= a2;
    if (v19 >= a2) {
      unsigned int v21 = (uint64_t *)v16;
    }
    else {
      unsigned int v21 = (uint64_t *)(v16 + 8);
    }
    if (v20) {
      uint64_t v18 = v16;
    }
    uint64_t v16 = *v21;
  }
  while (*v21);
  if (v18 == v15) {
    return 0;
  }
  unsigned int v22 = *(_DWORD *)(v18 + 32);
  uint64_t v23 = v18 + 40;
  if (v22 <= a2) {
    return v23;
  }
  else {
    return 0;
  }
}

uint64_t myApplierFunction(const void *a1, const void *a2, uint64_t (**a3)(void, void, void, void))
{
  char v4 = 0;
  return ((uint64_t (**)(void, const void *, const void *, char *))a3)[2](a3, a1, a2, &v4);
}

void ___ZN13IIOReadPlugin20extractDecodeOptionsEPK14__CFDictionary_block_invoke(uint64_t a1, CFStringRef theString1, const __CFString *a3, unsigned char *a4)
{
  uint64_t v7 = *(void *)(a1 + 32);
  if (CFEqual(theString1, (CFStringRef)*MEMORY[0x1E4F1DD38]))
  {
    if (CFStringCompare(a3, (CFStringRef)*MEMORY[0x1E4F1DD30], 0))
    {
      IIOString::IIOString((IIOString *)v16, a3);
      unsigned int v11 = (const char *)IIOString::utf8String((IIOString *)v16);
      LogWarning("extractDecodeOptions_block_invoke", 1343, "ImageIO - ignoring kCGImageBlockFormatRequest '%s'\n", v11);
      IIOString::~IIOString((IIOString *)v16);
      goto LABEL_19;
    }
    if (*(_DWORD *)(v7 + 320) == 1)
    {
      if (*(_WORD *)(v7 + 306) == 32 && *(_WORD *)(v7 + 304) == 8)
      {
        *(_WORD *)(v7 + 404) = 1;
        *(unsigned char *)(v7 + 406) = 1;
        return;
      }
      _cg_jpeg_mem_term("extractDecodeOptions_block_invoke", 1332, "*** ERROR: kCGImageBlockFormatBGRx8 is called for %d-bpp (%d-bpc) image\n");
    }
    else
    {
      _cg_jpeg_mem_term("extractDecodeOptions_block_invoke", 1337, "*** ERROR: kCGImageBlockFormatBGRx8 is called for non-RGB image [csm=%d]\n");
    }
    *(unsigned char *)(v7 + 414) = 0;
    return;
  }
  if (CFEqual(theString1, (CFStringRef)*MEMORY[0x1E4F1DD18]))
  {
    IIONumber::IIONumber((IIONumber *)v16, (const __CFNumber *)a3);
    *(void *)(v7 + 384) = IIONumber::uint64Num((IIONumber *)v16);
    IIONumber::~IIONumber((IIONumber *)v16);
    if (*(void *)(v7 + 384)) {
      *(unsigned char *)(v7 + 409) = 1;
    }
    return;
  }
  if (CFEqual(theString1, (CFStringRef)*MEMORY[0x1E4F1DD20]))
  {
    IIONumber::IIONumber((IIONumber *)v16, (const __CFNumber *)a3);
    *(void *)(v7 + 392) = IIONumber::uint64Num((IIONumber *)v16);
    IIONumber::~IIONumber((IIONumber *)v16);
    if (*(void *)(v7 + 392)) {
      *(unsigned char *)(v7 + 410) = 1;
    }
    return;
  }
  if (CFEqual(theString1, (CFStringRef)*MEMORY[0x1E4F1DD48]))
  {
    CFTypeID v13 = CFGetTypeID(a3);
    if (v13 == CFBooleanGetTypeID())
    {
      *(unsigned char *)(v7 + 408) = *MEMORY[0x1E4F1CFD0] == (void)a3;
      return;
    }
    IIONumber::IIONumber((IIONumber *)v16, (const __CFNumber *)a3);
    *(unsigned char *)(v7 + 408) = IIONumber::uint64Num((IIONumber *)v16) != 0;
LABEL_40:
    IIONumber::~IIONumber((IIONumber *)v16);
    return;
  }
  if (CFEqual(theString1, (CFStringRef)*MEMORY[0x1E4F1DD28]))
  {
    LogWarning("extractDecodeOptions_block_invoke", 1370, "ignoring 'kCGImageBlockColorSpaceRequest'\n");
    goto LABEL_19;
  }
  if (CFEqual(theString1, (CFStringRef)*MEMORY[0x1E4F1DD40]))
  {
    CFTypeID v14 = CFGetTypeID(a3);
    if (v14 == CFBooleanGetTypeID())
    {
      *(unsigned char *)(v7 + 407) = *MEMORY[0x1E4F1CFD0] == (void)a3;
      return;
    }
    IIONumber::IIONumber((IIONumber *)v16, (const __CFNumber *)a3);
    *(unsigned char *)(v7 + 407) = IIONumber::uint64Num((IIONumber *)v16) != 0;
    goto LABEL_40;
  }
  if (CFStringCompare(theString1, (CFStringRef)*MEMORY[0x1E4F1DD50], 0)
    && CFStringCompare(theString1, @"kCGImageBlockIOSurfacePromoteToCIF10", 0)
    && CFStringCompare(theString1, @"kImageIOConvertWideGamutImage", 0)
    && CFStringCompare(theString1, @"kCGImageBlockPreHeating", 0)
    && CFStringCompare(theString1, @"kCGImageSourceRasterizationDPI", 0)
    && CFStringCompare(theString1, @"kCGImagePreferGPUForColorConversion", 0)
    && CFStringCompare(theString1, @"kCGImagePreferredColorConversionMode", 0)
    && CFStringCompare(theString1, @"kCGImageProviderPreferedBandHeight", 0)
    && CFStringCompare(theString1, @"kCGImageSurfaceFormatRequest", 0))
  {
    CFStringRef v8 = CFCopyDescription(a3);
    IIOString::IIOString((IIOString *)v16, theString1);
    uint64_t v9 = (const char *)IIOString::utf8String((IIOString *)v16);
    IIOString::IIOString((IIOString *)v15, v8);
    uint64_t v10 = (const char *)IIOString::utf8String((IIOString *)v15);
    _cg_jpeg_mem_term("extractDecodeOptions_block_invoke", 1410, "ignoring unknown request for '%s' : '%s'\n", v9, v10);
    IIOString::~IIOString((IIOString *)v15);
    IIOString::~IIOString((IIOString *)v16);
    CFRelease(v8);
LABEL_19:
    *(unsigned char *)(v7 + 414) = 0;
    *a4 = 1;
  }
}

void sub_1885CBC54(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  IIOString::~IIOString((IIOString *)va);
  _Unwind_Resume(a1);
}

void IIONumber::IIONumber(IIONumber *this, CFTypeRef cf)
{
  *(void *)this = &unk_1ED4E5FD8;
  if (!cf) {
    goto LABEL_8;
  }
  CFTypeID v4 = CFGetTypeID(cf);
  if (v4 == CFNumberGetTypeID())
  {
    *((void *)this + 2) = CFRetain(cf);
    *((void *)this + 1) = CFNumberGetType((CFNumberRef)cf);
    return;
  }
  CFTypeID v5 = CFGetTypeID(cf);
  if (v5 == CFBooleanGetTypeID())
  {
    LOBYTE(valuePtr[0]) = *MEMORY[0x1E4F1CFD0] == (void)cf;
    *((void *)this + 1) = 1;
    *((void *)this + 2) = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberSInt8Type, valuePtr);
    return;
  }
  CFTypeID v6 = CFGetTypeID(cf);
  if (v6 == CFStringGetTypeID())
  {
    memset(valuePtr, 0, sizeof(valuePtr));
    IIOString::IIOString((IIOString *)valuePtr, cf);
    uint64_t v7 = (const char *)IIOString::utf8String((IIOString *)valuePtr);
    uint64_t v8 = atol(v7);
    *((void *)this + 1) = 10;
    *((void *)this + 2) = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberLongType, &v8);
    IIOString::~IIOString((IIOString *)valuePtr);
  }
  else
  {
LABEL_8:
    IIOLogTypeMismatch(cf, "IIONumber", "CFNumberRef");
    *((void *)this + 2) = 0;
  }
}

void sub_1885CBE08(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  IIOString::~IIOString((IIOString *)va);
  _Unwind_Resume(a1);
}

unint64_t IIONumber::uint64Num(IIONumber *this)
{
  uint64_t valuePtr = 0;
  CFNumberRef v2 = (const __CFNumber *)*((void *)this + 2);
  if (v2)
  {
    if (CFNumberGetValue(v2, kCFNumberSInt64Type, &valuePtr)) {
      return valuePtr;
    }
    CFNumberRef v2 = (const __CFNumber *)*((void *)this + 2);
  }
  if (CFNumberIsFloatType(v2))
  {
    double v4 = 0.0;
    if (CFNumberGetValue(*((CFNumberRef *)this + 2), kCFNumberDoubleType, &v4)) {
      return (unint64_t)v4;
    }
  }
  LogError("uint64Num", 366, "CFNumberGetValue/uint64_t failed\n");
  return 0;
}

uint64_t IIOImageProviderInfo::CopyImageTextureData(uint64_t *a1, const void *a2, const __CFDictionary *a3)
{
  kdebug_trace();
  IIOInitDebugFlags();
  if ((unsigned __int16)gIIODebugFlags >> 14) {
    ImageIODebugOptions((unsigned __int16)gIIODebugFlags >> 14, "S", "CopyImageTextureData", a2, 0, -1, a3);
  }
  if (a1)
  {
    uint64_t v7 = IIOImageProviderInfo::copyImageTextureData(*a1, v6, a3);
    if (v7)
    {
      CGImageTextureDataGetSize();
      CGImageTextureDataIsCompressed();
      CGImageTextureDataSupportsTiledLayout();
      CGImageTextureDataGetNumberOfMipmaps();
      CGImageTextureDataGetNumberOfFaces();
      CGImageTextureDataGetPixelFormat();
      CGImageTextureDataGetPixelFormat();
    }
  }
  else
  {
    uint64_t v7 = 0;
  }
  kdebug_trace();
  return v7;
}

uint64_t IIOImageProviderInfo::copyImageTextureData(uint64_t a1, uint64_t a2, const __CFDictionary *a3)
{
  if ((unsigned __int16)gIIODebugFlags >> 14) {
    ImageIODebugOptions((unsigned __int16)gIIODebugFlags >> 14, "S", "copyImageTextureData", 0, 0, -1, a3);
  }
  IIOInitDebugFlags();
  if ((gIIODebugFlags & 0xC) != 0) {
    *(CFAbsoluteTime *)(a1 + 136) = CFAbsoluteTimeGetCurrent();
  }
  if (*(void *)(a1 + 240))
  {
    CFTypeID v5 = *(CFTypeRef **)(a1 + 112);
    if (v5)
    {
      CFDictionaryRef v6 = (const __CFDictionary *)*v5;
      if (*v5)
      {
        CFTypeID v7 = CFGetTypeID(*v5);
        if (v7 == CFDictionaryGetTypeID())
        {
          pthread_mutex_lock((pthread_mutex_t *)(a1 + 144));
          uint64_t v8 = (const void *)*MEMORY[0x1E4F1CFD0];
          if (v8 == CFDictionaryGetValue(v6, @"kImageIOInfoHeader_pluginHandlesReMapping"))
          {
            BOOL v12 = 0;
            unsigned int v11 = 0;
          }
          else
          {
            CFStringRef Value = CFDictionaryGetValue(v6, @"kImageIOInfoHeader_session");
            uint64_t v10 = (IIOImageRead *)CGImageReadSessionGetRead((uint64_t)Value);
            unsigned int v11 = (const char *)v10;
            if (v10) {
              BOOL v12 = IIOImageRead::mapData(v10);
            }
            else {
              BOOL v12 = 0;
            }
          }
          uint64_t v13 = (*(uint64_t (**)(void, void, const __CFDictionary *))(a1 + 240))(*(void *)(a1 + 112), *(void *)(a1 + 16), a3);
          if (v13 && (gIIODebugFlags & 0xC) != 0) {
            *(CFAbsoluteTime *)(a1 + 136) = CFAbsoluteTimeGetCurrent() - *(double *)(a1 + 136);
          }
          if (v12 && v11) {
            IIOImageRead::unmapData(v11);
          }
          pthread_mutex_unlock((pthread_mutex_t *)(a1 + 144));
          if (v13) {
            return v13;
          }
          goto LABEL_24;
        }
      }
    }
    else
    {
      CFDictionaryRef v6 = 0;
    }
    LogFault("copyImageTextureData", 2494, "header '%p' is not a CFDictionary...\n", v6);
    return 0;
  }
  uint64_t v13 = 0;
LABEL_24:
  if ((gIIODebugFlags & 0x800000000000) != 0)
  {
    ImageIOLog(" ISSUE: %s:%d:  %s\n", "copyImageTextureData", 2525, "returned textureData is NULL\n");
    return 0;
  }
  return v13;
}

uint64_t ___ZN13IIOReadPlugin16cacheImmediatelyEPK14__CFDictionaryP7CGImage_block_invoke_2(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  CGImageGetImageProvider();
  *(unsigned char *)(v2 + 411) = 1;
  uint64_t result = CGImageProviderCopyImageBlockSetWithOptions();
  if (result)
  {
    *(unsigned char *)(v2 + 411) = -1;
LABEL_3:
    return CGImageBlockSetRelease();
  }
  if (!*(void *)(a1 + 96))
  {
    *(unsigned char *)(v2 + 411) = -1;
    return result;
  }
  uint64_t result = CGImageProviderCopyImageBlockSetWithOptions();
  *(unsigned char *)(v2 + 411) = -1;
  if (result) {
    goto LABEL_3;
  }
  return result;
}

const void *IIOImageProviderInfo::CopyImageBlockSetWithOptions(uint64_t *a1, const void *a2, const __CFDictionary *a3, double a4, double a5, double a6, double a7, double a8, double a9)
{
  uint64_t v43 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    CGImageProviderGetBitmapInfo();
    uint64_t v18 = *a1;
    IIOPackCopyCallbackInfo(*a1, a3);
    if (v18) {
      int v19 = *(_DWORD *)(v18 + 128);
    }
    else {
      int v19 = 0;
    }
    int v20 = v19;
    kdebug_trace();
    IIOInitDebugFlags();
    __int16 v21 = gIIODebugFlags;
    if ((gIIODebugFlags & 0xC000) != 0)
    {
      long long v41 = 0u;
      long long v42 = 0u;
      long long v39 = 0u;
      long long v40 = 0u;
      *(_OWORD *)__str = 0u;
      if (v18 && *(void *)(v18 + 24))
      {
        CFTypeRef cf = (CFTypeRef)IIOLookupISR();
        __int16 v21 = gIIODebugFlags;
      }
      else
      {
        CFTypeRef cf = 0;
      }
      if (v21 < 0)
      {
        if (v20 < 0) {
          __maskrune(v20 >> 24, 0x40000uLL);
        }
        if (v20 << 8 < 0) {
          __maskrune(v20 << 8 >> 24, 0x40000uLL);
        }
        if (v20 << 16 < 0) {
          __maskrune((__int16)v20 >> 8, 0x40000uLL);
        }
        if ((v20 << 24) > 0x7F000000) {
          __maskrune((char)v20, 0x40000uLL);
        }
        snprintf(__str, 0x50uLL, "'%c%c%c%c' src={%g,%g,%g,%g}  dest={%g,%g}");
      }
      else
      {
        if (v20 < 0) {
          __maskrune(v20 >> 24, 0x40000uLL);
        }
        if (v20 << 8 < 0) {
          __maskrune(v20 << 8 >> 24, 0x40000uLL);
        }
        if (v20 << 16 < 0) {
          __maskrune((__int16)v20 >> 8, 0x40000uLL);
        }
        if ((v20 << 24) > 0x7F000000) {
          __maskrune((char)v20, 0x40000uLL);
        }
        snprintf(__str, 0x50uLL, "%c%c%c%c");
      }
      if ((unsigned __int16)gIIODebugFlags >> 14) {
        ImageIODebugOptions((unsigned __int16)gIIODebugFlags >> 14, "S", "CopyImageBlockSetWithOptions", cf, __str, -1, a3);
      }
    }
    if (v18)
    {
      unsigned int v22 = IIOImageProviderInfo::copyImageBlockSetWithOptions(v18, a2, a3, a4, a5, a6, a7, a8, a9);
      if (v22)
      {
        uint64_t v23 = v22;
        CGImageBlockSetGetRect();
        goto LABEL_69;
      }
      unsigned int v24 = v20 >> 24;
      if (v20 < 0) {
        int v25 = __maskrune(v20 >> 24, 0x40000uLL);
      }
      else {
        int v25 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v24 + 60) & 0x40000;
      }
      if (v25) {
        uint64_t v26 = v24;
      }
      else {
        uint64_t v26 = 46;
      }
      unsigned int v27 = v20 << 8 >> 24;
      if (v20 << 8 < 0) {
        int v28 = __maskrune(v20 << 8 >> 24, 0x40000uLL);
      }
      else {
        int v28 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v27 + 60) & 0x40000;
      }
      if (v28) {
        uint64_t v29 = v27;
      }
      else {
        uint64_t v29 = 46;
      }
      unsigned int v30 = (__int16)v20 >> 8;
      if (v20 << 16 < 0) {
        int v31 = __maskrune((__int16)v20 >> 8, 0x40000uLL);
      }
      else {
        int v31 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v30 + 60) & 0x40000;
      }
      if (v31) {
        uint64_t v32 = v30;
      }
      else {
        uint64_t v32 = 46;
      }
      if ((v20 << 24) <= 0x7F000000) {
        int v33 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * (char)v20 + 60) & 0x40000;
      }
      else {
        int v33 = __maskrune((char)v20, 0x40000uLL);
      }
      if (v33) {
        uint64_t v34 = (char)v20;
      }
      else {
        uint64_t v34 = 46;
      }
      _cg_jpeg_mem_term("CopyImageBlockSetWithOptions", 2602, "*** ERROR: CopyImageBlockSetWithOptions '%c%c%c%c' returned NULL\n", v26, v29, v32, v34);
    }
  }
  else
  {
    kdebug_trace();
  }
  if (a2)
  {
    CGImageProviderGetBitmapInfo();
    CGImageProviderGetComponentType();
    ColorSpace = (CGColorSpace *)CGImageProviderGetColorSpace();
    CGColorSpaceGetModel(ColorSpace);
  }
  kdebug_trace();
  uint64_t v23 = 0;
LABEL_69:
  kdebug_trace();
  return v23;
}

unint64_t IIOPackCopyCallbackInfo(uint64_t a1, CFDictionaryRef theDict)
{
  if (theDict)
  {
    if (CFDictionaryContainsKey(theDict, (const void *)*MEMORY[0x1E4F1DD38])) {
      unint64_t v4 = 0x4000000000000000;
    }
    else {
      unint64_t v4 = 0x8000000000000000;
    }
    int v5 = CFDictionaryContainsKey(theDict, (const void *)*MEMORY[0x1E4F1DD48]);
    uint64_t v6 = 0x1000000000000000;
    if (!v5) {
      uint64_t v6 = 0x2000000000000000;
    }
    unint64_t v7 = v6 | v4;
    if (CFDictionaryContainsKey(theDict, @"kCGImageBlockIOSurfaceOptimizedRequest")) {
      uint64_t v8 = 0x400000000000000;
    }
    else {
      uint64_t v8 = 0x800000000000000;
    }
    int v9 = CFDictionaryContainsKey(theDict, (const void *)*MEMORY[0x1E4F1DD28]);
    uint64_t v10 = 0x100000000000000;
    if (!v9) {
      uint64_t v10 = 0x200000000000000;
    }
    uint64_t v11 = v7 | v8 | v10;
    int v12 = CFDictionaryContainsKey(theDict, (const void *)*MEMORY[0x1E4F1DD18]);
    uint64_t v13 = 0x40000000000000;
    if (!v12) {
      uint64_t v13 = 0x80000000000000;
    }
    uint64_t v14 = v11 | v13;
    if (CFDictionaryContainsKey(theDict, (const void *)*MEMORY[0x1E4F1DD20]))
    {
      unint64_t result = v14 | 0x10000000000000;
      if (!a1) {
        return result;
      }
    }
    else
    {
      unint64_t result = v14 | 0x20000000000000;
      if (!a1) {
        return result;
      }
    }
  }
  else
  {
    unint64_t result = 0xAAA0000000000000;
    if (!a1) {
      return result;
    }
  }
  result |= ((unint64_t)*(void *)(a1 + 48) << 32) & 0xFFFF00FFFFFFFFFFLL | ((unint64_t)*(void *)(a1 + 56) << 40);
  return result;
}

unint64_t IIOPackCopyCallbackInfo(const __CFDictionary *a1)
{
  if (!a1) {
    return 0xAAA0000000000000;
  }
  if (CFDictionaryContainsKey(a1, (const void *)*MEMORY[0x1E4F1DD38])) {
    unint64_t v2 = 0x4000000000000000;
  }
  else {
    unint64_t v2 = 0x8000000000000000;
  }
  int v3 = CFDictionaryContainsKey(a1, (const void *)*MEMORY[0x1E4F1DD48]);
  uint64_t v4 = 0x1000000000000000;
  if (!v3) {
    uint64_t v4 = 0x2000000000000000;
  }
  unint64_t v5 = v4 | v2;
  if (CFDictionaryContainsKey(a1, @"kCGImageBlockIOSurfaceOptimizedRequest")) {
    uint64_t v6 = 0x400000000000000;
  }
  else {
    uint64_t v6 = 0x800000000000000;
  }
  int v7 = CFDictionaryContainsKey(a1, (const void *)*MEMORY[0x1E4F1DD28]);
  uint64_t v8 = 0x100000000000000;
  if (!v7) {
    uint64_t v8 = 0x200000000000000;
  }
  uint64_t v9 = v5 | v6 | v8;
  int v10 = CFDictionaryContainsKey(a1, (const void *)*MEMORY[0x1E4F1DD18]);
  uint64_t v11 = 0x40000000000000;
  if (!v10) {
    uint64_t v11 = 0x80000000000000;
  }
  uint64_t v12 = v9 | v11;
  if (CFDictionaryContainsKey(a1, (const void *)*MEMORY[0x1E4F1DD20])) {
    return v12 | 0x10000000000000;
  }
  else {
    return v12 | 0x20000000000000;
  }
}

const void *IIOImageProviderInfo::copyImageBlockSetWithOptions(uint64_t a1, const void *a2, CFDictionaryRef theDict, double a4, double a5, double a6, double a7, double a8, double a9)
{
  uint64_t v16 = a1;
  char v17 = gIIODebugFlags;
  if ((gIIODebugFlags & 0x400000000000) != 0)
  {
    ImageIOLog("\n");
    LODWORD(a1) = ImageIOLog("*** copyImageBlockSetWithOptions *** %p {%g, %g, %g, %g} {%g, %g}\n", a2, a4, a5, a6, a7, a8, a9);
    char v17 = gIIODebugFlags;
  }
  if ((v17 & 0xC) != 0) {
    *(CFAbsoluteTime *)(v16 + 136) = CFAbsoluteTimeGetCurrent();
  }
  int v19 = 0;
  if (a8 != 0.0 && a9 != 0.0)
  {
    if (!*(void *)(v16 + 216))
    {
      int v19 = 0;
      goto LABEL_17;
    }
    int v20 = *(CFTypeRef **)(v16 + 112);
    if (!v20
      || (CFDictionaryRef v21 = (const __CFDictionary *)*v20) == 0
      || (CFTypeID v22 = CFGetTypeID(*v20), v22 != CFDictionaryGetTypeID()))
    {
      LogError("copyImageBlockSetWithOptions", 2227, "*** ERROR: 'ImageProviderCopyImageBlockSetCallback' header is not a CFDictionary...\n");
      return 0;
    }
    pthread_mutex_lock((pthread_mutex_t *)(v16 + 144));
    uint64_t v23 = (const void *)*MEMORY[0x1E4F1CFD0];
    if (v23 == CFDictionaryGetValue(v21, @"kImageIOInfoHeader_pluginHandlesReMapping")
      || (CFStringRef Value = CFDictionaryGetValue(v21, @"kImageIOInfoHeader_session")) == 0)
    {
      uint64_t v26 = 0;
    }
    else
    {
      int v25 = (IIOImageRead *)CGImageReadSessionGetRead((uint64_t)Value);
      uint64_t v26 = (const char *)v25;
      if (v25)
      {
        BOOL v27 = IIOImageRead::mapData(v25);
        goto LABEL_31;
      }
    }
    BOOL v27 = 0;
LABEL_31:
    uint64_t v31 = *(void *)(v16 + 24);
    if (v31)
    {
      CFDictionaryRef v32 = 0;
      if (!theDict || !*(unsigned char *)(v31 + 180)) {
        goto LABEL_38;
      }
      if (CFDictionaryContainsValue(theDict, (const void *)*MEMORY[0x1E4F1DD30]))
      {
        MutableCFStringRef Copy = CFDictionaryCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, theDict);
        CFDictionaryRef v32 = MutableCopy;
        if (MutableCopy)
        {
          CFDictionaryRemoveValue(MutableCopy, (const void *)*MEMORY[0x1E4F1DD38]);
          theDict = v32;
        }
LABEL_38:
        int v19 = (const void *)(*(uint64_t (**)(void, void, CFDictionaryRef, double, double, double, double, double, double))(v16 + 216))(*(void *)(v16 + 112), *(void *)(v16 + 16), theDict, a4, a5, a6, a7, a8, a9);
        if (!v19) {
          goto LABEL_49;
        }
        CGImageBlockSetGetRect();
        double v35 = v34;
        uint64_t Count = CGImageBlockSetGetCount();
        if (!Count || v35 == 0.0)
        {
          CFRelease(v19);
        }
        else
        {
          int v37 = Count;
          if (CGImageBlockSetGetImageBlock())
          {
            uint64_t v38 = *(void *)(v16 + 24);
            if (v38)
            {
              long long v39 = (IIOImageRead *)CGImageReadSessionGetRead(*(void *)(v38 + 24));
              if (v39)
              {
                if (IIOImageRead::isFinal(v39))
                {
                  uint64_t v40 = *(void *)(v16 + 24);
                  int v41 = *(_DWORD *)(v40 + 136);
                  if (v41 != -6)
                  {
                    if (v41) {
                      *(_DWORD *)(v40 + 136) = 0;
                    }
                  }
                }
              }
            }
            IIOImageProviderInfo::checkBlockSetBuffer(v16);
LABEL_49:
            if (v26 && v27) {
              IIOImageRead::unmapData(v26);
            }
            LODWORD(a1) = pthread_mutex_unlock((pthread_mutex_t *)(v16 + 144));
            if (!v32) {
              goto LABEL_17;
            }
LABEL_57:
            CFRelease(v32);
            goto LABEL_17;
          }
          _cg_jpeg_mem_term("copyImageBlockSetWithOptions", 2297, "*** CGImageBlockSetGetImageBlock returned NULL for index %d (count is %d)\n", 0, v37);
          IIO_ImageBlockSetRelease(v19);
          LODWORD(a1) = pthread_mutex_unlock((pthread_mutex_t *)(v16 + 144));
        }
        int v19 = 0;
        if (!v32) {
          goto LABEL_17;
        }
        goto LABEL_57;
      }
    }
    CFDictionaryRef v32 = 0;
    goto LABEL_38;
  }
LABEL_17:
  uint64_t v28 = gIIODebugFlags;
  if ((gIIODebugFlags & 0xC) != 0)
  {
    *(CFAbsoluteTime *)(v16 + 136) = CFAbsoluteTimeGetCurrent() - *(double *)(v16 + 136);
    IIOImageProviderInfo::logBlockSetDecodingTime(v16, (uint64_t)v19, a4, a5, a6, a7, a8, a9);
    uint64_t v28 = gIIODebugFlags;
  }
  if ((v28 & 0xC000) == 0x8000 || (v28 & 0x400000000000) != 0)
  {
    IIOImageProviderInfo::debugCallbackOptionsResult(a1, theDict, (uint64_t)v19);
    uint64_t v28 = gIIODebugFlags;
  }
  if (!v19 && (v28 & 0x800000000000) != 0)
  {
    ImageIOLog(" ISSUE: %s:%d:  %s\n", "copyImageBlockSetWithOptions", 2336, "returned blockSet is NULL\n");
    return 0;
  }
  return v19;
}

void IIOImageProviderInfo::checkBlockSetBuffer(uint64_t a1)
{
  if (IIOImageProviderInfo::checkBlockSetBuffer(CGImageBlockSet *)::onceToken != -1) {
    dispatch_once(&IIOImageProviderInfo::checkBlockSetBuffer(CGImageBlockSet *)::onceToken, &__block_literal_global_113);
  }
  uint64_t Count = CGImageBlockSetGetCount();
  if (Count)
  {
    uint64_t v3 = Count;
    for (uint64_t i = 0; i != v3; ++i)
    {
      if (CGImageBlockSetGetImageBlock())
      {
        CGImageBlockGetRect();
        double v6 = v5;
        double v8 = v7;
        double v10 = v9;
        double v12 = v11;
        unint64_t BytesPerRow = CGImageBlockGetBytesPerRow();
        Componentint Type = CGImageBlockSetGetComponentType();
        Pixelunint64_t Size = CGImageBlockSetGetPixelSize();
        unint64_t Data = (unsigned __int8 *)CGImageBlockGetData();
        if (Data)
        {
          char v17 = Data;
          unint64_t v18 = v6;
          byte_1EB2C0678 = CopyUInt32AsHexToStringAtOffset(unsigned int,char *,unsigned int)::table[v18 >> 28];
          byte_1EB2C0679 = CopyUInt32AsHexToStringAtOffset(unsigned int,char *,unsigned int)::table[(v18 >> 24) & 0xF];
          byte_1EB2C067A = CopyUInt32AsHexToStringAtOffset(unsigned int,char *,unsigned int)::table[(v18 >> 20) & 0xF];
          byte_1EB2C067B = CopyUInt32AsHexToStringAtOffset(unsigned int,char *,unsigned int)::table[(v18 >> 16) & 0xF];
          byte_1EB2C067C = CopyUInt32AsHexToStringAtOffset(unsigned int,char *,unsigned int)::table[(unsigned __int16)v18 >> 12];
          byte_1EB2C067D = CopyUInt32AsHexToStringAtOffset(unsigned int,char *,unsigned int)::table[(v18 >> 8) & 0xF];
          byte_1EB2C067E = CopyUInt32AsHexToStringAtOffset(unsigned int,char *,unsigned int)::table[v18 >> 4];
          byte_1EB2C067F = CopyUInt32AsHexToStringAtOffset(unsigned int,char *,unsigned int)::table[v18 & 0xF];
          unint64_t v19 = v8;
          byte_1EB2C0683 = CopyUInt32AsHexToStringAtOffset(unsigned int,char *,unsigned int)::table[v19 >> 28];
          byte_1EB2C0684 = CopyUInt32AsHexToStringAtOffset(unsigned int,char *,unsigned int)::table[(v19 >> 24) & 0xF];
          byte_1EB2C0685 = CopyUInt32AsHexToStringAtOffset(unsigned int,char *,unsigned int)::table[(v19 >> 20) & 0xF];
          byte_1EB2C0686 = CopyUInt32AsHexToStringAtOffset(unsigned int,char *,unsigned int)::table[(v19 >> 16) & 0xF];
          byte_1EB2C0687 = CopyUInt32AsHexToStringAtOffset(unsigned int,char *,unsigned int)::table[(unsigned __int16)v19 >> 12];
          byte_1EB2C0688 = CopyUInt32AsHexToStringAtOffset(unsigned int,char *,unsigned int)::table[(v19 >> 8) & 0xF];
          byte_1EB2C0689 = CopyUInt32AsHexToStringAtOffset(unsigned int,char *,unsigned int)::table[v19 >> 4];
          byte_1EB2C068A = CopyUInt32AsHexToStringAtOffset(unsigned int,char *,unsigned int)::table[v19 & 0xF];
          unint64_t v20 = v10;
          byte_1EB2C068E = CopyUInt32AsHexToStringAtOffset(unsigned int,char *,unsigned int)::table[v20 >> 28];
          byte_1EB2C068F = CopyUInt32AsHexToStringAtOffset(unsigned int,char *,unsigned int)::table[(v20 >> 24) & 0xF];
          byte_1EB2C0690 = CopyUInt32AsHexToStringAtOffset(unsigned int,char *,unsigned int)::table[(v20 >> 20) & 0xF];
          byte_1EB2C0691 = CopyUInt32AsHexToStringAtOffset(unsigned int,char *,unsigned int)::table[(v20 >> 16) & 0xF];
          byte_1EB2C0692 = CopyUInt32AsHexToStringAtOffset(unsigned int,char *,unsigned int)::table[(unsigned __int16)v20 >> 12];
          byte_1EB2C0693 = CopyUInt32AsHexToStringAtOffset(unsigned int,char *,unsigned int)::table[(v20 >> 8) & 0xF];
          byte_1EB2C0694 = CopyUInt32AsHexToStringAtOffset(unsigned int,char *,unsigned int)::table[v20 >> 4];
          unint64_t v21 = v12;
          byte_1EB2C0695 = CopyUInt32AsHexToStringAtOffset(unsigned int,char *,unsigned int)::table[v20 & 0xF];
          byte_1EB2C0699 = CopyUInt32AsHexToStringAtOffset(unsigned int,char *,unsigned int)::table[v21 >> 28];
          byte_1EB2C069A = CopyUInt32AsHexToStringAtOffset(unsigned int,char *,unsigned int)::table[(v21 >> 24) & 0xF];
          byte_1EB2C069B = CopyUInt32AsHexToStringAtOffset(unsigned int,char *,unsigned int)::table[(v21 >> 20) & 0xF];
          byte_1EB2C069C = CopyUInt32AsHexToStringAtOffset(unsigned int,char *,unsigned int)::table[(v21 >> 16) & 0xF];
          byte_1EB2C069D = CopyUInt32AsHexToStringAtOffset(unsigned int,char *,unsigned int)::table[(unsigned __int16)v21 >> 12];
          byte_1EB2C069E = CopyUInt32AsHexToStringAtOffset(unsigned int,char *,unsigned int)::table[(v21 >> 8) & 0xF];
          byte_1EB2C069F = CopyUInt32AsHexToStringAtOffset(unsigned int,char *,unsigned int)::table[v21 >> 4];
          byte_1EB2C06A0 = CopyUInt32AsHexToStringAtOffset(unsigned int,char *,unsigned int)::table[v21 & 0xF];
          byte_1EB2C06A8 = CopyUInt32AsHexToStringAtOffset(unsigned int,char *,unsigned int)::table[BytesPerRow >> 28];
          byte_1EB2C06A9 = CopyUInt32AsHexToStringAtOffset(unsigned int,char *,unsigned int)::table[(BytesPerRow >> 24) & 0xF];
          byte_1EB2C06AA = CopyUInt32AsHexToStringAtOffset(unsigned int,char *,unsigned int)::table[(BytesPerRow >> 20) & 0xF];
          byte_1EB2C06AB = CopyUInt32AsHexToStringAtOffset(unsigned int,char *,unsigned int)::table[(BytesPerRow >> 16) & 0xF];
          byte_1EB2C06AC = CopyUInt32AsHexToStringAtOffset(unsigned int,char *,unsigned int)::table[(unsigned __int16)BytesPerRow >> 12];
          byte_1EB2C06AD = CopyUInt32AsHexToStringAtOffset(unsigned int,char *,unsigned int)::table[(BytesPerRow >> 8) & 0xF];
          byte_1EB2C06AE = CopyUInt32AsHexToStringAtOffset(unsigned int,char *,unsigned int)::table[BytesPerRow >> 4];
          byte_1EB2C06AF = CopyUInt32AsHexToStringAtOffset(unsigned int,char *,unsigned int)::table[BytesPerRow & 0xF];
          byte_1EB2C06BB = CopyUInt32AsHexToStringAtOffset(unsigned int,char *,unsigned int)::table[PixelSize >> 28];
          byte_1EB2C06BC = CopyUInt32AsHexToStringAtOffset(unsigned int,char *,unsigned int)::table[(PixelSize >> 24) & 0xF];
          byte_1EB2C06BD = CopyUInt32AsHexToStringAtOffset(unsigned int,char *,unsigned int)::table[(PixelSize >> 20) & 0xF];
          byte_1EB2C06BE = CopyUInt32AsHexToStringAtOffset(unsigned int,char *,unsigned int)::table[(PixelSize >> 16) & 0xF];
          byte_1EB2C06BF = CopyUInt32AsHexToStringAtOffset(unsigned int,char *,unsigned int)::table[(unsigned __int16)PixelSize >> 12];
          byte_1EB2C06C0 = CopyUInt32AsHexToStringAtOffset(unsigned int,char *,unsigned int)::table[(PixelSize >> 8) & 0xF];
          byte_1EB2C06C1 = CopyUInt32AsHexToStringAtOffset(unsigned int,char *,unsigned int)::table[PixelSize >> 4];
          byte_1EB2C06C2 = CopyUInt32AsHexToStringAtOffset(unsigned int,char *,unsigned int)::table[PixelSize & 0xF];
          byte_1EB2C06CF = CopyUInt32AsHexToStringAtOffset(unsigned int,char *,unsigned int)::table[(unint64_t)ComponentType >> 28];
          char v22 = CopyUInt32AsHexToStringAtOffset(unsigned int,char *,unsigned int)::table[(ComponentType >> 20) & 0xF];
          byte_1EB2C06D0 = CopyUInt32AsHexToStringAtOffset(unsigned int,char *,unsigned int)::table[(ComponentType >> 24) & 0xF];
          byte_1EB2C06D1 = v22;
          byte_1EB2C06D2 = CopyUInt32AsHexToStringAtOffset(unsigned int,char *,unsigned int)::table[(ComponentType >> 16) & 0xF];
          char v23 = CopyUInt32AsHexToStringAtOffset(unsigned int,char *,unsigned int)::table[(ComponentType >> 8) & 0xF];
          byte_1EB2C06D3 = CopyUInt32AsHexToStringAtOffset(unsigned int,char *,unsigned int)::table[(unsigned __int16)ComponentType >> 12];
          byte_1EB2C06D4 = v23;
          byte_1EB2C06D5 = CopyUInt32AsHexToStringAtOffset(unsigned int,char *,unsigned int)::table[ComponentType >> 4];
          byte_1EB2C06D6 = CopyUInt32AsHexToStringAtOffset(unsigned int,char *,unsigned int)::table[ComponentType & 0xF];
          unk_1EB2C06DD = bswap32(*(_DWORD *)(a1 + 72));
          LODWORD(v20) = *(_DWORD *)(a1 + 128);
          byte_1EB2C06E8 = BYTE3(v20);
          byte_1EB2C06E9 = BYTE2(v20);
          byte_1EB2C06EA = BYTE1(v20);
          byte_1EB2C06EB = v20;
          memset(&byte_1EB2C06F7, 48, 16);
          qword_1EB2BF498 = (uint64_t)&IIOImageProviderInfo::checkBlockSetBuffer(CGImageBlockSet *)::logMessage;
          CHECK_FIRST_BYTE_OF_IMAGEBLOCK(Data);
          if (is_mul_ok((unint64_t)v12, BytesPerRow))
          {
            unint64_t v24 = (unint64_t)v12 * BytesPerRow;
            if (v24)
            {
              byte_1EB2C06F7 = CopyUInt32AsHexToStringAtOffset(unsigned int,char *,unsigned int)::table[(v24 - 1) >> 60];
              byte_1EB2C06F8 = CopyUInt32AsHexToStringAtOffset(unsigned int,char *,unsigned int)::table[((v24 - 1) >> 56) & 0xF];
              byte_1EB2C06F9 = CopyUInt32AsHexToStringAtOffset(unsigned int,char *,unsigned int)::table[((v24 - 1) >> 52) & 0xF];
              byte_1EB2C06FA = CopyUInt32AsHexToStringAtOffset(unsigned int,char *,unsigned int)::table[((v24 - 1) >> 48) & 0xF];
              byte_1EB2C06FB = CopyUInt32AsHexToStringAtOffset(unsigned int,char *,unsigned int)::table[((v24 - 1) >> 44) & 0xF];
              byte_1EB2C06FC = CopyUInt32AsHexToStringAtOffset(unsigned int,char *,unsigned int)::table[((v24 - 1) >> 40) & 0xF];
              byte_1EB2C06FD = CopyUInt32AsHexToStringAtOffset(unsigned int,char *,unsigned int)::table[((v24 - 1) >> 36) & 0xF];
              byte_1EB2C06FE = CopyUInt32AsHexToStringAtOffset(unsigned int,char *,unsigned int)::table[((v24 - 1) >> 32) & 0xF];
              byte_1EB2C06FF = CopyUInt32AsHexToStringAtOffset(unsigned int,char *,unsigned int)::table[((unint64_t)v12 * BytesPerRow - 1) >> 28];
              byte_1EB2C0700 = CopyUInt32AsHexToStringAtOffset(unsigned int,char *,unsigned int)::table[((v24 - 1) >> 24) & 0xF];
              byte_1EB2C0701 = CopyUInt32AsHexToStringAtOffset(unsigned int,char *,unsigned int)::table[((v24 - 1) >> 20) & 0xF];
              byte_1EB2C0702 = CopyUInt32AsHexToStringAtOffset(unsigned int,char *,unsigned int)::table[((v24 - 1) >> 16) & 0xF];
              byte_1EB2C0703 = CopyUInt32AsHexToStringAtOffset(unsigned int,char *,unsigned int)::table[(unsigned __int16)((unint64_t)v12 * BytesPerRow - 1) >> 12];
              byte_1EB2C0704 = CopyUInt32AsHexToStringAtOffset(unsigned int,char *,unsigned int)::table[((v24 - 1) >> 8) & 0xF];
              byte_1EB2C0705 = CopyUInt32AsHexToStringAtOffset(unsigned int,char *,unsigned int)::table[((unint64_t)v12 * BytesPerRow - 1) >> 4];
              byte_1EB2C0706 = CopyUInt32AsHexToStringAtOffset(unsigned int,char *,unsigned int)::table[(v24 - 1) & 0xF];
              qword_1EB2BF498 = (uint64_t)&IIOImageProviderInfo::checkBlockSetBuffer(CGImageBlockSet *)::logMessage;
              CHECK_LAST_BYTE_OF_IMAGEBLOCK(v17);
            }
          }
          qword_1EB2BF498 = 0;
        }
      }
    }
  }
}

uint64_t CGImageReadSessionGetRead(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = *(void *)(result + 24);
    if (v1) {
      return *(void *)(v1 + 32);
    }
    else {
      return 0;
    }
  }
  return result;
}

uint64_t IIO_Reader::CopyImageTextureDataProc(uint64_t a1, uint64_t a2, uint64_t a3)
{
  double v6 = *(unsigned char **)(a1 + 8);
  if (v6[181]) {
    ImageIOLog("    CopyImageTextureDataProc\n");
  }
  (*(void (**)(unsigned char *, uint64_t))(*(void *)v6 + 80))(v6, a3);
  uint64_t v7 = (*(uint64_t (**)(unsigned char *, uint64_t, uint64_t, uint64_t))(*(void *)v6 + 256))(v6, a1, a2, a3);
  (*(void (**)(unsigned char *))(*(void *)v6 + 88))(v6);
  return v7;
}

void sub_1885CD468(void *a1)
{
}

uint64_t IIO_Reader::CopyImageBlockSetProc(uint64_t a1, uint64_t a2, uint64_t a3, CGFloat a4, CGFloat a5, double a6, double a7, double a8, double a9)
{
  uint64_t ImageBlockSetFromCache = 0;
  if ((IIO_XPCServer() & 1) == 0)
  {
    unint64_t v18 = *(_DWORD **)(a1 + 8);
    if ((*(unsigned int (**)(_DWORD *, uint64_t))(*(void *)v18 + 80))(v18, a3))
    {
      exception = __cxa_allocate_exception(4uLL);
      _DWORD *exception = -1;
      __cxa_throw(exception, MEMORY[0x1E4FBA3A8], 0);
    }
    if (*((unsigned char *)v18 + 181)) {
      ImageIOLog("    CopyImageBlockSetProc: rect:{%g,%g,%g,%g}  size:{%g,%g}\n", a4, a5, a6, a7, a8, a9);
    }
    memset(v73, 0, sizeof(v73));
    __n128 v19 = IIOReadPlugin::inputGeometry((IIOReadPlugin *)v18, (uint64_t)v73);
    LODWORD(v20) = DWORD1(v73[0]);
    v19.n128_u32[0] = v73[0];
    v19.n128_f64[0] = (double)v19.n128_u64[0];
    double v21 = (double)v20;
    LODWORD(v23) = HIDWORD(v73[0]);
    LODWORD(v22) = DWORD2(v73[0]);
    double v24 = (double)v22;
    double v25 = (double)v23;
    v76.size.double width = fmax(a6, 1.0);
    v76.size.double height = fmax(a7, 1.0);
    v76.origin.double x = a4;
    v76.origin.double y = a5;
    CGRect v75 = CGRectIntersection(*(CGRect *)v19.n128_u64, v76);
    double x = v75.origin.x;
    double y = v75.origin.y;
    double width = v75.size.width;
    double height = v75.size.height;
    if ((gIIODebugFlags & 0x30000) == 0)
    {
LABEL_30:
      uint64_t ImageBlockSetFromCache = IIOReadPlugin::createImageBlockSetFromCache((uint64_t)v18, a1, a2, x, y, width, height, a8, a9);
      if (ImageBlockSetFromCache)
      {
LABEL_91:
        (*(void (**)(_DWORD *))(*(void *)v18 + 88))(v18);
        return ImageBlockSetFromCache;
      }
      uint64_t v72 = 0;
      memset(v71, 0, sizeof(v71));
      unsigned int v42 = IIOReadPlugin::index((IIOReadPlugin *)v18);
      IIODecodeParameter::IIODecodeParameter(v71, a1, a2, v42, a3, x, y, width, height, a8, a9);
      int v43 = IIOReadPlugin::callDecodeImage((uint64_t)v18, (uint64_t)v71, 3, 0, 0, &ImageBlockSetFromCache);
      if (v43 == -1400)
      {
        ImageIOLog(" retrying 'decodeImage' (ImageIOXPCService crashed?)\n");
        int v44 = IIOReadPlugin::callDecodeImage((uint64_t)v18, (uint64_t)v71, 3, 0, 0, &ImageBlockSetFromCache);
        int v43 = v44;
        double v45 = "";
        if (!v44) {
          double v45 = "";
        }
        ImageIOLog("%s retrying 'decodeImage'  err: %d\n", v45, v44);
      }
      if (v43 == -181)
      {
        IIOXPCLog(" request not handled [%d]\n", -181);
      }
      else if (v43)
      {
        if (v43 == -56)
        {
          int v46 = v18[51];
          unsigned int v47 = v46 >> 24;
          if (v46 < 0)
          {
            int v48 = __maskrune(v47, 0x40000uLL);
            int v46 = v18[51];
          }
          else
          {
            int v48 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v47 + 60) & 0x40000;
          }
          if (v48) {
            uint64_t v49 = (v46 >> 24);
          }
          else {
            uint64_t v49 = 46;
          }
          unsigned int v50 = v46 << 8 >> 24;
          if (v46 << 8 < 0)
          {
            int v51 = __maskrune(v50, 0x40000uLL);
            int v46 = v18[51];
          }
          else
          {
            int v51 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v50 + 60) & 0x40000;
          }
          if (v51) {
            uint64_t v52 = (v46 << 8 >> 24);
          }
          else {
            uint64_t v52 = 46;
          }
          unsigned int v53 = (__int16)v46 >> 8;
          if (v46 << 16 < 0)
          {
            int v54 = __maskrune(v53, 0x40000uLL);
            int v46 = v18[51];
          }
          else
          {
            int v54 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v53 + 60) & 0x40000;
          }
          if (v54) {
            uint64_t v55 = ((__int16)v46 >> 8);
          }
          else {
            uint64_t v55 = 46;
          }
          if ((v46 << 24) <= 0x7F000000) {
            int v56 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * (char)v46 + 60) & 0x40000;
          }
          else {
            int v56 = __maskrune((char)v46, 0x40000uLL);
          }
          if (v56) {
            uint64_t v57 = *((char *)v18 + 204);
          }
          else {
            uint64_t v57 = 46;
          }
          LogError("CopyImageBlockSetProc", 1569, "*** IIO_Reader::CopyImageBlockSetProc - '%c%c%c%c'- does not support 'callDecodeImage'\n", v49, v52, v55, v57);
        }
        int v58 = v18[51];
        unsigned int v59 = v58 >> 24;
        if (v58 < 0)
        {
          int v60 = __maskrune(v59, 0x40000uLL);
          int v58 = v18[51];
        }
        else
        {
          int v60 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v59 + 60) & 0x40000;
        }
        if (v60) {
          uint64_t v61 = (v58 >> 24);
        }
        else {
          uint64_t v61 = 46;
        }
        unsigned int v62 = v58 << 8 >> 24;
        if (v58 << 8 < 0)
        {
          int v63 = __maskrune(v62, 0x40000uLL);
          int v58 = v18[51];
        }
        else
        {
          int v63 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v62 + 60) & 0x40000;
        }
        if (v63) {
          uint64_t v64 = (v58 << 8 >> 24);
        }
        else {
          uint64_t v64 = 46;
        }
        unsigned int v65 = (__int16)v58 >> 8;
        if (v58 << 16 < 0)
        {
          int v66 = __maskrune(v65, 0x40000uLL);
          int v58 = v18[51];
        }
        else
        {
          int v66 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v65 + 60) & 0x40000;
        }
        if (v66) {
          uint64_t v67 = ((__int16)v58 >> 8);
        }
        else {
          uint64_t v67 = 46;
        }
        if ((v58 << 24) <= 0x7F000000)
        {
          if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * (char)v58 + 60) & 0x40000) != 0) {
            goto LABEL_84;
          }
        }
        else if (__maskrune((char)v58, 0x40000uLL))
        {
LABEL_84:
          uint64_t v68 = *((char *)v18 + 204);
LABEL_87:
          _cg_jpeg_mem_term("CopyImageBlockSetProc", 1575, "*** ERROR: '%c%c%c%c' callDecodeImage failed [%d]\n", v61, v64, v67, v68, v43);
          goto LABEL_88;
        }
        uint64_t v68 = 46;
        goto LABEL_87;
      }
LABEL_88:
      if (!ImageBlockSetFromCache) {
        _cg_jpeg_mem_term("CopyImageBlockSetProc", 1577, "*** ERROR: callDecodeImage returned NULL blockSet [%d]\n", v43);
      }
      IIODecodeParameter::~IIODecodeParameter((IIODecodeParameter *)v71);
      goto LABEL_91;
    }
    int v30 = v18[51];
    unsigned int v31 = v30 >> 24;
    uint64_t v32 = MEMORY[0x1E4F14390];
    if (v30 < 0)
    {
      int v33 = __maskrune(v31, 0x40000uLL);
      int v30 = v18[51];
    }
    else
    {
      int v33 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v31 + 60) & 0x40000;
    }
    if (v33) {
      uint64_t v34 = (v30 >> 24);
    }
    else {
      uint64_t v34 = 46;
    }
    unsigned int v35 = v30 << 8 >> 24;
    if (v30 << 8 < 0)
    {
      int v36 = __maskrune(v35, 0x40000uLL);
      int v30 = v18[51];
    }
    else
    {
      int v36 = *(_DWORD *)(v32 + 4 * v35 + 60) & 0x40000;
    }
    if (v36) {
      uint64_t v37 = (v30 << 8 >> 24);
    }
    else {
      uint64_t v37 = 46;
    }
    unsigned int v38 = (__int16)v30 >> 8;
    if (v30 << 16 < 0)
    {
      int v39 = __maskrune(v38, 0x40000uLL);
      int v30 = v18[51];
    }
    else
    {
      int v39 = *(_DWORD *)(v32 + 4 * v38 + 60) & 0x40000;
    }
    if (v39) {
      uint64_t v40 = ((__int16)v30 >> 8);
    }
    else {
      uint64_t v40 = 46;
    }
    if ((v30 << 24) <= 0x7F000000)
    {
      if ((*(_DWORD *)(v32 + 4 * (char)v30 + 60) & 0x40000) != 0) {
        goto LABEL_26;
      }
    }
    else if (__maskrune((char)v30, 0x40000uLL))
    {
LABEL_26:
      int v41 = v18[51];
LABEL_29:
      ImageIOLog("*** IIO_Reader::CopyImageBlockSetProc - using new '%c%c%c%c'- callDecodeImage [kIIOImageType_ImageBlockSet]\n", v34, v37, v40, (char)v41);
      goto LABEL_30;
    }
    LOBYTE(v41) = 46;
    goto LABEL_29;
  }
  return ImageBlockSetFromCache;
}

void sub_1885CDAA4(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15)
{
  __cxa_begin_catch(a1);
  *(void *)(v15 - 136) = 0;
  __cxa_end_catch();
  JUMPOUT(0x1885CDA50);
}

double IIOReadPlugin::didDecode(IIOReadPlugin *this)
{
  double result = 0.0;
  *(_OWORD *)((char *)this + 300) = 0u;
  *(_OWORD *)((char *)this + 284) = 0u;
  return result;
}

uint64_t IIOReadPlugin::willDecode(IIOReadPlugin *this, const __CFDictionary *a2)
{
  uint64_t v4 = MEMORY[0x1E4F14390];
  if (*((unsigned char *)this + 181))
  {
    int v5 = *((_DWORD *)this + 51);
    unsigned int v6 = v5 >> 24;
    if (v5 < 0) {
      int v7 = __maskrune(v5 >> 24, 0x40000uLL);
    }
    else {
      int v7 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v6 + 60) & 0x40000;
    }
    if (v7) {
      uint64_t v8 = v6;
    }
    else {
      uint64_t v8 = 46;
    }
    unsigned int v9 = v5 << 8 >> 24;
    if (v5 << 8 < 0) {
      int v10 = __maskrune(v5 << 8 >> 24, 0x40000uLL);
    }
    else {
      int v10 = *(_DWORD *)(v4 + 4 * v9 + 60) & 0x40000;
    }
    if (v10) {
      uint64_t v11 = v9;
    }
    else {
      uint64_t v11 = 46;
    }
    unsigned int v12 = (__int16)v5 >> 8;
    if (v5 << 16 < 0) {
      int v13 = __maskrune((__int16)v5 >> 8, 0x40000uLL);
    }
    else {
      int v13 = *(_DWORD *)(v4 + 4 * v12 + 60) & 0x40000;
    }
    if (v13) {
      uint64_t v14 = v12;
    }
    else {
      uint64_t v14 = 46;
    }
    if ((v5 << 24) <= 0x7F000000) {
      int v15 = *(_DWORD *)(v4 + 4 * (char)v5 + 60) & 0x40000;
    }
    else {
      int v15 = __maskrune((char)v5, 0x40000uLL);
    }
    if (v15) {
      uint64_t v16 = (char)v5;
    }
    else {
      uint64_t v16 = 46;
    }
    ImageIOLog(">>> willDecode -start- %c%c%c%c\n", v8, v11, v14, v16);
  }
  unsigned int v17 = *((_DWORD *)this + 73);
  if (!v17)
  {
    unsigned int v17 = *((_DWORD *)this + 65);
    *((_DWORD *)this + 73) = v17;
  }
  if (!*((_DWORD *)this + 74)) {
    *((_DWORD *)this + 74) = *((_DWORD *)this + 66);
  }
  unsigned int v18 = *((_DWORD *)this + 75);
  if (!v18)
  {
    unsigned int v18 = *((_DWORD *)this + 67);
    *((_DWORD *)this + 75) = v18;
  }
  unsigned int v19 = *((unsigned __int16 *)this + 152);
  if (!*((_WORD *)this + 152))
  {
    unsigned int v19 = *((unsigned __int16 *)this + 136);
    *((_WORD *)this + 152) = v19;
  }
  int v20 = *((unsigned __int16 *)this + 153);
  if (!*((_WORD *)this + 153))
  {
    int v20 = *((unsigned __int16 *)this + 137);
    *((_WORD *)this + 153) = v20;
  }
  int v21 = *((unsigned __int16 *)this + 154);
  if (!*((_WORD *)this + 154))
  {
    int v21 = *((unsigned __int16 *)this + 138);
    *((_WORD *)this + 154) = v21;
  }
  int v22 = *((unsigned __int8 *)this + 312);
  int v23 = *((unsigned __int8 *)this + 310);
  if (!((*((unsigned __int8 *)this + 311) << 12) | (v22 << 16) | ((*((unsigned char *)this + 313) != 0) << 8) | v23))
  {
    int v24 = *((unsigned __int8 *)this + 279);
    unsigned int v25 = (v24 << 12) | (*((unsigned __int8 *)this + 280) << 16);
    BOOL v26 = *((unsigned char *)this + 281) != 0;
    int v23 = *((unsigned char *)this + 278) & 0x1F;
    *((unsigned char *)this + 310) = v23;
    *((unsigned char *)this + 311) = v24 & 7;
    int v22 = HIWORD(v25) & 0xF;
    *((unsigned char *)this + 312) = v22;
    *((unsigned char *)this + 313) = v26;
  }
  if (v19 >= 9)
  {
    if (v19 == 10)
    {
      if (v22 << 16 == 196608 || v22 << 16 == 0x40000) {
        goto LABEL_54;
      }
    }
    else if (v19 > 0x10)
    {
      if (v19 > 0x20) {
        goto LABEL_124;
      }
      unsigned int v19 = 32;
      goto LABEL_53;
    }
    unsigned int v19 = 16;
LABEL_53:
    *((_WORD *)this + 152) = v19;
    goto LABEL_54;
  }
  unsigned int v19 = 8;
  *((_WORD *)this + 152) = 8;
  if (v20 == 24)
  {
    if (!v23)
    {
      int v28 = 0;
      int v27 = *((_DWORD *)this + 80);
      LOWORD(v20) = 24;
      goto LABEL_61;
    }
    int v20 = 32;
    *((_WORD *)this + 153) = 32;
  }
LABEL_54:
  int v27 = *((_DWORD *)this + 80);
  int v28 = v23 != 0;
  if (!v27 && v23)
  {
    if (v21 == 1)
    {
      int v21 = 2;
      *((_WORD *)this + 154) = 2;
    }
    int v27 = 0;
    if (v20 == v19)
    {
      LOWORD(v20) = v21 * v20;
      *((_WORD *)this + 153) = v20;
    }
    int v28 = 1;
  }
LABEL_61:
  if (v21 * v19 > (unsigned __int16)v20)
  {
    switch(v27)
    {
      case 0:
      case 5:
        if (v28) {
          __int16 v29 = 2;
        }
        else {
          __int16 v29 = 1;
        }
        *((_WORD *)this + 154) = v29;
        int v20 = v19 << v28;
        goto LABEL_79;
      case 1:
        if (v23) {
          __int16 v30 = 4;
        }
        else {
          __int16 v30 = 3;
        }
        *((_WORD *)this + 154) = v30;
        int v31 = v22 << 16;
        LOWORD(v20) = 32;
        if (v31 != 196608 && v31 != 0x40000) {
          LOWORD(v20) = v30 * v19;
        }
        goto LABEL_79;
      case 2:
        BOOL v32 = v23 == 0;
        __int16 v33 = 4;
        goto LABEL_76;
      case 3:
        BOOL v32 = v23 == 0;
        __int16 v33 = 3;
LABEL_76:
        if (!v32) {
          ++v33;
        }
        *((_WORD *)this + 154) = v33;
        LOWORD(v20) = v33 * v19;
LABEL_79:
        *((_WORD *)this + 153) = v20;
        break;
      default:
        break;
    }
  }
  unint64_t v34 = ((unsigned __int16)v20 >> 3) * (unint64_t)v17;
  if ((v34 & 0xFFFFFFFF00000000) != 0)
  {
LABEL_124:
    exception = __cxa_allocate_exception(4uLL);
    _DWORD *exception = -50;
  }
  if (v18 < v34) {
    *((_DWORD *)this + 75) = v34;
  }
  *((void *)this + 14) = 0x100000000;
  long long v35 = *(_OWORD *)(MEMORY[0x1E4F1DB20] + 16);
  *(_OWORD *)((char *)this + 120) = *MEMORY[0x1E4F1DB20];
  *((_DWORD *)this + 26) = 1;
  *(_OWORD *)((char *)this + 136) = v35;
  *((void *)this + 48) = 0;
  *((void *)this + 49) = 0;
  *(void *)((char *)this + 404) = -1;
  *((_DWORD *)this + 100) = 538976288;
  *(_WORD *)((char *)this + 413) = 256;
  unsigned int v67 = (*(uint64_t (**)(IIOReadPlugin *, const __CFDictionary *))(*(void *)this + 72))(this, a2);
  if ((IIOGeometry::isValid((IIOReadPlugin *)((char *)this + 220)) & 1) == 0)
  {
    unsigned int v36 = ((*((unsigned __int16 *)this + 121) + 7) >> 3) * *((_DWORD *)this + 57);
    if (v36 > *((_DWORD *)this + 59)) {
      *((_DWORD *)this + 59) = (v36 + 15) & 0xFFFFFFF0;
    }
  }
  if ((IIOGeometry::isValid((IIOReadPlugin *)((char *)this + 252)) & 1) == 0)
  {
    unsigned int v37 = ((*((unsigned __int16 *)this + 137) + 7) >> 3) * *((_DWORD *)this + 65);
    if (v37 > *((_DWORD *)this + 67)) {
      *((_DWORD *)this + 67) = (v37 + 15) & 0xFFFFFFF0;
    }
  }
  if ((IIOGeometry::isValid((IIOReadPlugin *)((char *)this + 284)) & 1) == 0)
  {
    unsigned int v38 = ((*((unsigned __int16 *)this + 153) + 7) >> 3) * *((_DWORD *)this + 73);
    if (v38 > *((_DWORD *)this + 75)) {
      *((_DWORD *)this + 75) = (v38 + 15) & 0xFFFFFFF0;
    }
  }
  unint64_t v39 = *((void *)this + 49);
  if (v39)
  {
    uint64_t v40 = *((unsigned int *)this + 75);
    if (v40 % (uint64_t)v39) {
      *((_DWORD *)this + 75) = (v39 + v40 - 1) / v39 * v39;
    }
  }
  IIOReadPlugin::updateRequestFormat((uint64_t)this);
  ++*((void *)this + 52);
  if ((gIIODebugFlags & 0x30000) != 0)
  {
    int v66 = *((unsigned __int16 *)this + 153);
    int v41 = *((unsigned __int16 *)this + 152);
    int v42 = *((unsigned __int16 *)this + 154);
    int v43 = *((unsigned __int8 *)this + 310);
    unsigned int v44 = (*((unsigned __int8 *)this + 312) << 16) | (*((unsigned __int8 *)this + 311) << 12) | ((*((unsigned char *)this + 313) != 0) << 8) | v43;
    int v45 = *((_DWORD *)this + 71);
    int v46 = *((_DWORD *)this + 72);
    int v47 = *((_DWORD *)this + 73);
    int v48 = *((_DWORD *)this + 74);
    int v49 = *((_DWORD *)this + 75);
    unsigned int v50 = IIO_BitmapInfoString(v44);
    int v65 = v47;
    uint64_t v4 = MEMORY[0x1E4F14390];
    ImageIOLog("             _blockGeo   %5d %5d %5d %5d   %6d   %3d   %3d   %3d   %3d   %08X   %s\n", v45, v46, v65, v48, v49, v66, v41, v42, v43, v44, v50);
  }
  if (*((unsigned char *)this + 181))
  {
    int v51 = *((_DWORD *)this + 51);
    unsigned int v52 = v51 >> 24;
    if (v51 < 0) {
      int v53 = __maskrune(v51 >> 24, 0x40000uLL);
    }
    else {
      int v53 = *(_DWORD *)(v4 + 4 * v52 + 60) & 0x40000;
    }
    if (v53) {
      uint64_t v54 = v52;
    }
    else {
      uint64_t v54 = 46;
    }
    unsigned int v55 = v51 << 8 >> 24;
    if (v51 << 8 < 0) {
      int v56 = __maskrune(v51 << 8 >> 24, 0x40000uLL);
    }
    else {
      int v56 = *(_DWORD *)(v4 + 4 * v55 + 60) & 0x40000;
    }
    if (v56) {
      uint64_t v57 = v55;
    }
    else {
      uint64_t v57 = 46;
    }
    unsigned int v58 = (__int16)v51 >> 8;
    if (v51 << 16 < 0) {
      int v59 = __maskrune((__int16)v51 >> 8, 0x40000uLL);
    }
    else {
      int v59 = *(_DWORD *)(v4 + 4 * v58 + 60) & 0x40000;
    }
    if (v59) {
      uint64_t v60 = v58;
    }
    else {
      uint64_t v60 = 46;
    }
    if ((v51 << 24) <= 0x7F000000) {
      int v61 = *(_DWORD *)(v4 + 4 * (char)v51 + 60) & 0x40000;
    }
    else {
      int v61 = __maskrune((char)v51, 0x40000uLL);
    }
    if (v61) {
      uint64_t v62 = (char)v51;
    }
    else {
      uint64_t v62 = 46;
    }
    ImageIOLog("<<< willDecode -result- %c%c%c%c\n", v54, v57, v60, v62);
  }
  return v67;
}

uint64_t IIOGeometry::isValid(IIOGeometry *this)
{
  int v3 = *((_DWORD *)this + 2);
  int v2 = *((_DWORD *)this + 3);
  if (v3)
  {
    if (!v2) {
      goto LABEL_5;
    }
  }
  else
  {
    if (v2)
    {
LABEL_5:
      _cg_jpeg_mem_term("isValid", 172, " bad width/height:  w: %d   h: %d\n", v3, v2);
      uint64_t result = 0;
      int v3 = *((_DWORD *)this + 2);
      goto LABEL_8;
    }
    int v3 = 0;
  }
  uint64_t result = 1;
LABEL_8:
  unsigned int v5 = *((unsigned __int16 *)this + 11);
  int v6 = *((_DWORD *)this + 4);
  if (v3 * v5 > 8 * v6)
  {
    _cg_jpeg_mem_term("isValid", 178, " rowBytes too small: w: %d   bpp: %d   rb: %d   min: %d\n", v3, (v5 + 7) >> 3, v6, ((v5 + 7) >> 3) * v3);
    uint64_t result = 0;
    unsigned int v5 = *((unsigned __int16 *)this + 11);
  }
  int v7 = *((unsigned __int16 *)this + 10);
  int v8 = *((unsigned __int16 *)this + 12);
  unsigned int v9 = v8 * v7;
  if (v8 * v7 <= v5)
  {
    if (v9 >= v5) {
      goto LABEL_26;
    }
    BOOL v10 = v7 == 10 || v7 == 5;
    if (v10 && v8 == 3) {
      goto LABEL_26;
    }
    _cg_jpeg_mem_term("isValid", 199, " bitsPerPixel too big: bpc: %d   #channels: %d   bpp: %d   min: %d\n");
    goto LABEL_25;
  }
  if (v7 != 10 || v8 != 4 || *((unsigned char *)this + 28) != 3)
  {
    _cg_jpeg_mem_term("isValid", 192, " bitsPerPixel too small: bpc: %d   #channels: %d   bpp: %d   min: %d\n");
    goto LABEL_25;
  }
  if (v9 > v5 + 8)
  {
    _cg_jpeg_mem_term("isValid", 187, " bitsPerPixel too small: bpc: %d   #channels: %d   bpp: %d   min: %d\n");
LABEL_25:
    uint64_t result = 0;
  }
LABEL_26:
  int v11 = *((unsigned __int16 *)this + 12);
  if ((v11 | 2) == 3 && *((unsigned char *)this + 26) && *((_WORD *)this + 10) != 5)
  {
    _cg_jpeg_mem_term("isValid", 208, " bad alpha: #channels: %d   alphaVal: %d 0x%08x\n", v11, *((unsigned __int8 *)this + 26), *((unsigned __int8 *)this + 26));
    return 0;
  }
  return result;
}

uint64_t IIOReadPlugin::updateRequestFormat(uint64_t this)
{
  switch(*(_DWORD *)(this + 320))
  {
    case 0:
      *(_DWORD *)(this + 400) = 1198678393;
      if (*(unsigned char *)(this + 404) == 1) {
        *(unsigned char *)(this + 404) = -1;
      }
      return this;
    case 1:
      if (*(unsigned char *)(this + 404) == 1)
      {
        int v1 = 1111970392;
        goto LABEL_16;
      }
      if (*(unsigned char *)(this + 405) == 1)
      {
LABEL_12:
        int v1 = 1380401752;
        goto LABEL_16;
      }
      switch(*(unsigned char *)(this + 310))
      {
        case 0:
          int v1 = 1380401696;
          goto LABEL_16;
        case 1:
        case 2:
        case 3:
        case 4:
          int v1 = 1380401729;
          goto LABEL_16;
        case 5:
        case 6:
          goto LABEL_12;
        default:
          return this;
      }
      return this;
    case 2:
      int v1 = 1129142603;
      goto LABEL_16;
    case 3:
      int v1 = 1281450528;
      goto LABEL_16;
    case 4:
      int v1 = 1684371022;
      goto LABEL_16;
    case 5:
      int v1 = 1768842360;
      goto LABEL_16;
    case 6:
      int v1 = 1885434996;
LABEL_16:
      *(_DWORD *)(this + 400) = v1;
      break;
    default:
      return this;
  }
  return this;
}

uint64_t IIOReadPlugin::extractDecodeOptions(IIOReadPlugin *this, const __CFDictionary *a2)
{
  *(void *)((char *)this + 404) = -1;
  *((_DWORD *)this + 100) = 538976288;
  *(_WORD *)((char *)this + 413) = 256;
  *((_OWORD *)this + 24) = xmmword_188990F60;
  memset(v6, 0, sizeof(v6));
  IIODictionary::IIODictionary((IIODictionary *)v6, a2);
  if (IIODictionary::getBoolForKey((IIODictionary *)v6, @"kCGImageBlockIOSurfaceOptimizedRequest"))
  {
    if (*((_DWORD *)this + 80) == 1 && *((_WORD *)this + 153) == 32) {
      *((_WORD *)this + 202) = 1;
    }
    *((unsigned char *)this + 408) = 1;
    *((void *)this + 49) = 16;
    *((unsigned char *)this + 406) = 0;
    *((unsigned char *)this + 413) = 1;
  }
  else
  {
    v5[0] = MEMORY[0x1E4F143A8];
    v5[1] = 0x40000000;
    _OWORD v5[2] = ___ZN13IIOReadPlugin20extractDecodeOptionsEPK14__CFDictionary_block_invoke;
    void v5[3] = &__block_descriptor_tmp_34;
    v5[4] = this;
    IIODictionary::enumerate((uint64_t)v6, v5);
    if (!*((unsigned char *)this + 310) && *((unsigned char *)this + 406) == 1) {
      *((unsigned char *)this + 414) = 0;
    }
    if (*((unsigned __int8 *)this + 410) == 255) {
      *((void *)this + 49) = 16;
    }
    if (*((unsigned __int8 *)this + 409) == 255) {
      *((void *)this + 48) = 64;
    }
  }
  if (*((unsigned char *)this + 414)) {
    uint64_t v3 = 0;
  }
  else {
    uint64_t v3 = 4294967246;
  }
  IIODictionary::~IIODictionary((IIODictionary *)v6);
  return v3;
}

void sub_1885CE5B4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  IIODictionary::~IIODictionary((IIODictionary *)va);
  _Unwind_Resume(a1);
}

void IIODictionary::enumerate(uint64_t a1, void *a2)
{
  int v2 = *(const void **)(a1 + 8);
  if (v2) {
    IIODictionaryEnumerateUsingBlock(v2, a2);
  }
}

void IIODictionaryEnumerateUsingBlock(const void *a1, void *a2)
{
  if (a1)
  {
    CFTypeID v4 = CFGetTypeID(a1);
    if (v4 == CFDictionaryGetTypeID())
    {
      CFDictionaryApplyFunction((CFDictionaryRef)a1, (CFDictionaryApplierFunction)myApplierFunction, a2);
    }
  }
}

void IIODecodeParameter::~IIODecodeParameter(IIODecodeParameter *this)
{
  *(void *)this = &unk_1ED4E45C8;
  int v2 = (const void *)*((void *)this + 10);
  if (v2) {
    CFRelease(v2);
  }
  *((void *)this + 10) = 0;
}

{
  uint64_t vars8;

  IIODecodeParameter::~IIODecodeParameter(this);

  JUMPOUT(0x18C11C0E0);
}

uint64_t IIODecodeParameter::IIODecodeParameter(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, CFTypeRef cf, double a6, double a7, double a8, double a9, double a10, double a11)
{
  *(void *)a1 = &unk_1ED4E45C8;
  *(void *)(a1 + 8) = a2;
  *(void *)(a1 + 16) = a3;
  *(double *)(a1 + 24) = a6;
  *(double *)(a1 + 32) = a7;
  *(double *)(a1 + 40) = a8;
  *(double *)(a1 + 48) = a9;
  *(double *)(a1 + 56) = a10;
  *(double *)(a1 + 64) = a11;
  *(void *)(a1 + 72) = a4;
  *(void *)(a1 + 80) = 0;
  if (cf) {
    *(void *)(a1 + 80) = CFRetain(cf);
  }
  return a1;
}

uint64_t IIOReadPlugin::index(IIOReadPlugin *this)
{
  return *((unsigned int *)this + 52);
}

uint64_t IIOReadPlugin::createImageBlockSetFromCache(uint64_t a1, uint64_t a2, uint64_t a3, double a4, double a5, double a6, double a7, double a8, double a9)
{
  uint64_t v41 = 0;
  int v42 = &v41;
  uint64_t v43 = 0x2000000000;
  uint64_t v44 = 0;
  uint64_t v14 = *(void *)(a1 + 32);
  v40[0] = MEMORY[0x1E4F143A8];
  v40[1] = 0x40000000;
  v40[2] = ___ZN13IIOReadPlugin28createImageBlockSetFromCacheEP7InfoRecP15CGImageProvider6CGRect6CGSizePK14__CFDictionary_block_invoke;
  v40[3] = &unk_1E53C7080;
  *(double *)&v40[6] = a4;
  *(double *)&v40[7] = a5;
  *(double *)&v40[8] = a6;
  *(double *)&v40[9] = a7;
  v40[4] = &v41;
  v40[5] = a1;
  v40[10] = a3;
  *(double *)&v40[11] = a8;
  *(double *)&v40[12] = a9;
  v40[13] = a2;
  IIOImageRead::enumerateCacheKeysWithBlock(v14, (uint64_t)v40);
  if (v42[3])
  {
    if ((gIIODebugFlags & 0x30000) == 0)
    {
LABEL_51:
      kdebug_trace();
      uint64_t v19 = v42[3];
      goto LABEL_52;
    }
    int v15 = *(_DWORD *)(a1 + 204);
    unsigned int v16 = v15 >> 24;
    uint64_t v17 = MEMORY[0x1E4F14390];
    if (v15 < 0)
    {
      int v18 = __maskrune(v16, 0x40000uLL);
      int v15 = *(_DWORD *)(a1 + 204);
    }
    else
    {
      int v18 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v16 + 60) & 0x40000;
    }
    if (v18) {
      uint64_t v20 = (v15 >> 24);
    }
    else {
      uint64_t v20 = 46;
    }
    unsigned int v21 = v15 << 8 >> 24;
    if (v15 << 8 < 0)
    {
      int v22 = __maskrune(v21, 0x40000uLL);
      int v15 = *(_DWORD *)(a1 + 204);
    }
    else
    {
      int v22 = *(_DWORD *)(v17 + 4 * v21 + 60) & 0x40000;
    }
    if (v22) {
      uint64_t v23 = (v15 << 8 >> 24);
    }
    else {
      uint64_t v23 = 46;
    }
    unsigned int v24 = (__int16)v15 >> 8;
    if (v15 << 16 < 0)
    {
      int v25 = __maskrune(v24, 0x40000uLL);
      int v15 = *(_DWORD *)(a1 + 204);
    }
    else
    {
      int v25 = *(_DWORD *)(v17 + 4 * v24 + 60) & 0x40000;
    }
    if (v25) {
      uint64_t v26 = ((__int16)v15 >> 8);
    }
    else {
      uint64_t v26 = 46;
    }
    if ((v15 << 24) <= 0x7F000000)
    {
      if ((*(_DWORD *)(v17 + 4 * (char)v15 + 60) & 0x40000) != 0) {
        goto LABEL_24;
      }
    }
    else if (__maskrune((char)v15, 0x40000uLL))
    {
LABEL_24:
      uint64_t v27 = *(char *)(a1 + 204);
      goto LABEL_27;
    }
    uint64_t v27 = 46;
LABEL_27:
    int v28 = *(_DWORD *)(a1 + 400);
    unsigned int v29 = v28 >> 24;
    if (v28 < 0)
    {
      int v30 = __maskrune(v29, 0x40000uLL);
      int v28 = *(_DWORD *)(a1 + 400);
    }
    else
    {
      int v30 = *(_DWORD *)(v17 + 4 * v29 + 60) & 0x40000;
    }
    if (v30) {
      uint64_t v31 = (v28 >> 24);
    }
    else {
      uint64_t v31 = 46;
    }
    unsigned int v32 = v28 << 8 >> 24;
    if (v28 << 8 < 0)
    {
      int v33 = __maskrune(v32, 0x40000uLL);
      int v28 = *(_DWORD *)(a1 + 400);
    }
    else
    {
      int v33 = *(_DWORD *)(v17 + 4 * v32 + 60) & 0x40000;
    }
    if (v33) {
      uint64_t v34 = (v28 << 8 >> 24);
    }
    else {
      uint64_t v34 = 46;
    }
    unsigned int v35 = (__int16)v28 >> 8;
    if (v28 << 16 < 0)
    {
      int v36 = __maskrune(v35, 0x40000uLL);
      int v28 = *(_DWORD *)(a1 + 400);
    }
    else
    {
      int v36 = *(_DWORD *)(v17 + 4 * v35 + 60) & 0x40000;
    }
    if (v36) {
      uint64_t v37 = ((__int16)v28 >> 8);
    }
    else {
      uint64_t v37 = 46;
    }
    if ((v28 << 24) <= 0x7F000000)
    {
      if ((*(_DWORD *)(v17 + 4 * (char)v28 + 60) & 0x40000) != 0) {
        goto LABEL_47;
      }
    }
    else if (__maskrune((char)v28, 0x40000uLL))
    {
LABEL_47:
      uint64_t v38 = *(char *)(a1 + 400);
LABEL_50:
      ImageIOLog("  '%c%c%c%c' rect: {%g,%g,%g,%g} found in cache - format: '%c%c%c%c'\n", v20, v23, v26, v27, a4, a5, a6, a7, v31, v34, v37, v38);
      goto LABEL_51;
    }
    uint64_t v38 = 46;
    goto LABEL_50;
  }
  uint64_t v19 = 0;
LABEL_52:
  _Block_object_dispose(&v41, 8);
  return v19;
}

void sub_1885CEA54(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 144), 8);
  _Unwind_Resume(a1);
}

uint64_t IIOImageRead::enumerateCacheKeysWithBlock(uint64_t a1, uint64_t a2)
{
  CFTypeID v4 = (pthread_mutex_t *)(a1 + 312);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 312));
  unsigned int v5 = *(long long **)(a1 + 288);
  int v6 = *(long long **)(a1 + 296);
  if (v5 != v6)
  {
    uint64_t v7 = 0;
    do
    {
      long long v8 = *v5;
      long long v9 = v5[1];
      *(_OWORD *)&v12[12] = *(long long *)((char *)v5 + 28);
      long long v11 = v8;
      *(_OWORD *)unsigned int v12 = v9;
      (*(void (**)(uint64_t, long long *, uint64_t))(a2 + 16))(a2, &v11, v7);
      uint64_t v7 = (v7 + 1);
      unsigned int v5 = (long long *)((char *)v5 + 44);
    }
    while (v5 != v6);
  }
  return pthread_mutex_unlock(v4);
}

__n128 IIOReadPlugin::inputGeometry@<Q0>(IIOReadPlugin *this@<X0>, uint64_t a2@<X8>)
{
  __n128 result = *(__n128 *)((char *)this + 220);
  long long v3 = *(_OWORD *)((char *)this + 236);
  *(__n128 *)a2 = result;
  *(_OWORD *)(a2 + 16) = v3;
  return result;
}

uint64_t CommonASTCReadPlugin::copyImageTextureData(uint64_t a1)
{
  int v2 = *(const void **)(a1 + 464);
  if (!v2)
  {
    long long v19 = xmmword_1ED4F0D28;
    long long v20 = *(_OWORD *)&off_1ED4F0D38;
    uint64_t v3 = IIOImageRead::imageCount(*(IIOImageRead **)(a1 + 32));
    memset(v18, 0, sizeof(v18));
    IIODictionary::IIODictionary((IIODictionary *)v18);
    int v4 = *(_DWORD *)(a1 + 452);
    IIONumber::IIONumber((IIONumber *)v17, *(_DWORD *)(a1 + 436));
    IIODictionary::setObjectForKey((uint64_t)v18, (uint64_t)v17, @"width");
    IIONumber::~IIONumber((IIONumber *)v17);
    IIONumber::IIONumber((IIONumber *)v16, *(_DWORD *)(a1 + 440));
    IIODictionary::setObjectForKey((uint64_t)v18, (uint64_t)v16, @"height");
    IIONumber::~IIONumber((IIONumber *)v16);
    IIONumber::IIONumber((IIONumber *)v15, 16 * v4);
    IIODictionary::setObjectForKey((uint64_t)v18, (uint64_t)v15, @"rowBytes");
    IIONumber::~IIONumber((IIONumber *)v15);
    IIONumber::IIONumber((IIONumber *)v14, *(_DWORD *)(a1 + 448));
    IIODictionary::setObjectForKey((uint64_t)v18, (uint64_t)v14, @"metalFormat");
    IIONumber::~IIONumber((IIONumber *)v14);
    IIONumber::IIONumber((IIONumber *)v13, v3);
    IIODictionary::setObjectForKey((uint64_t)v18, (uint64_t)v13, @"mipmapLevelCount");
    IIONumber::~IIONumber((IIONumber *)v13);
    IIONumber::IIONumber((IIONumber *)v12, 1);
    IIODictionary::setObjectForKey((uint64_t)v18, (uint64_t)v12, @"faceCount");
    IIONumber::~IIONumber((IIONumber *)v12);
    ColorSpace = (const void *)CGImageProviderGetColorSpace();
    IIODictionary::setObjectForKey((IIODictionary *)v18, ColorSpace, @"colorSpace");
    int v6 = hardware_supports_astc();
    uint64_t v7 = (const void **)MEMORY[0x1E4F1CFD0];
    if (!v6) {
      uint64_t v7 = (const void **)MEMORY[0x1E4F1CFC8];
    }
    IIODictionary::setObjectForKey((IIODictionary *)v18, *v7, @"supportsTiledLayout");
    int v8 = ASTCTextureImp::GLFormatForMetalFormat((ASTCTextureImp *)*(unsigned int *)(a1 + 448));
    IIONumber::IIONumber((IIONumber *)v11, v8);
    IIODictionary::setObjectForKey((uint64_t)v18, (uint64_t)v11, @"pixelFormatGL");
    IIONumber::~IIONumber((IIONumber *)v11);
    IIONumber::IIONumber((IIONumber *)v10, *(_DWORD *)(a1 + 448));
    IIODictionary::setObjectForKey((uint64_t)v18, (uint64_t)v10, @"pixelFormatMetal");
    IIONumber::~IIONumber((IIONumber *)v10);
    IIOImageSource::cf(*(IIOImageSource **)(a1 + 32));
    operator new();
  }
  CFRetain(v2);
  return *(void *)(a1 + 464);
}

void sub_1885CEDF8(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0xA1C40B41E38F6);
  IIODictionary::~IIODictionary((IIODictionary *)(v2 - 104));
  _Unwind_Resume(a1);
}

uint64_t ___ZN13IIOReadPlugin28createImageBlockSetFromCacheEP7InfoRecP15CGImageProvider6CGRect6CGSizePK14__CFDictionary_block_invoke(uint64_t a1, uint64_t a2, double a3, double a4)
{
  uint64_t v6 = *(void *)(a1 + 40);
  LODWORD(a3) = *(_DWORD *)(a2 + 8);
  LODWORD(a4) = *(_DWORD *)(a2 + 12);
  double v7 = (double)*(unint64_t *)&a3;
  double v8 = (double)*(unint64_t *)&a4;
  LODWORD(a3) = *(_DWORD *)(a2 + 16);
  LODWORD(a4) = *(_DWORD *)(a2 + 20);
  double v9 = (double)*(unint64_t *)&a3;
  double v10 = (double)*(unint64_t *)&a4;
  v15.origin.double x = v7;
  v15.origin.double y = v8;
  v15.size.double width = (double)*(unint64_t *)&a3;
  v15.size.double height = (double)*(unint64_t *)&a4;
  uint64_t result = CGRectEqualToRect(*(CGRect *)(a1 + 48), v15);
  if (result)
  {
    uint64_t v12 = *(void *)(a2 + 28);
    if (*(_DWORD *)(v6 + 208) == (unsigned __int16)v12
      && *(_DWORD *)(a2 + 24) == *(_DWORD *)(v6 + 400)
      && *(_WORD *)(v6 + 304) == BYTE6(v12)
      && __PAIR64__((v12 & 0x200000000000000) != 0, HIBYTE(v12) & 1) == __PAIR64__(*(unsigned __int8 *)(v6 + 354), *(unsigned __int8 *)(v6 + 353)))
    {
      unint64_t v14 = 0;
      uint64_t result = IIOImageRead::getCachedImageBlockData(*(void *)(v6 + 32), (_DWORD *)a2, (void **)&v14);
      if (result)
      {
        int v13 = IIO_ImageBlockCreate(v14, *(unsigned int *)(a2 + 36), 0, v7, v8, v9, v10);
        uint64_t result = IIOReadPlugin::imageBlockSetCreate(v6, *(void *)(a1 + 80), 1uLL, *(double *)(a1 + 88), *(double *)(a1 + 96), *(double *)(a1 + 48), *(double *)(a1 + 56), *(double *)(a1 + 64), *(double *)(a1 + 72), (uint64_t)&v13, *(const void **)(a1 + 104));
        *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
      }
    }
  }
  return result;
}

uint64_t ASTCTextureImp::GLFormatForMetalFormat(ASTCTextureImp *this)
{
  if ((this - 186) > 0x32) {
    return 0;
  }
  else {
    return dword_188991524[(int)this - 186];
  }
}

uint64_t IIOImageRead::imageCount(IIOImageRead *this)
{
  uint64_t Source = (IIOImageSource *)CGImageSourceGetSource(~*((void *)this + 2));
  if (!Source) {
    return 1;
  }

  return IIOImageSource::count(Source);
}

uint64_t hardware_supports_astc(void)
{
  if (hardware_supports_astc(void)::onceToken != -1) {
    dispatch_once(&hardware_supports_astc(void)::onceToken, &__block_literal_global_17);
  }
  return hardware_supports_astc(void)::supportsASTC;
}

const char *___ZN13IIOReadPlugin15getCachedBlocksEv_block_invoke(uint64_t a1, char *a2)
{
  uint64_t v4 = *(void *)(a1 + 32);
  uint64_t result = (const char *)imageio_key_is_equal(a2, (char *)(a1 + 40), 0);
  if (result)
  {
    int v6 = *((_DWORD *)a2 + 9);
    if (v6 != *(_DWORD *)(a1 + 76))
    {
      if ((gIIODebugFlags & 0x300) == 0x100 || (gIIODebugFlags & 0x400000000000) != 0) {
        uint64_t result = ImageIOLog("::: adjusting rowBytes to cached value: %d -> %d\n", *(_DWORD *)(a1 + 76), v6);
      }
      unsigned int v8 = *(_DWORD *)(a1 + 80);
      if (v8 && (int v9 = *((_DWORD *)a2 + 9), v8 >= *((_DWORD *)a2 + 5) * v9))
      {
        *(_DWORD *)(v4 + 300) = v9;
      }
      else
      {
        ImageIOLog(":::::::::::::::::::::::::::::::::::::::::::::::::::\n");
        ImageIOLog("::: cannot adjust rowBytes: cacheKey:%d  key:%d  alloc:%d\n", *(_DWORD *)(a1 + 76), *((_DWORD *)a2 + 9), *(_DWORD *)(a1 + 80));
        return ImageIOLog(":::::::::::::::::::::::::::::::::::::::::::::::::::\n");
      }
    }
  }
  return result;
}

BOOL imageio_key_is_equal(char *a1, char *a2, void *a3)
{
  BOOL v3 = 0;
  if (a1 && a2)
  {
    if (*(void *)a1 == *(void *)a2
      && *((_DWORD *)a1 + 2) == *((_DWORD *)a2 + 2)
      && *((_DWORD *)a1 + 3) == *((_DWORD *)a2 + 3)
      && *((_DWORD *)a1 + 4) == *((_DWORD *)a2 + 4)
      && *((_DWORD *)a1 + 5) == *((_DWORD *)a2 + 5)
      && (uint64_t v5 = *(void *)(a2 + 28) ^ *(void *)(a1 + 28), (v5 & 0xFF00FFFFFFFFFFLL) == 0))
    {
      BOOL v12 = *((_DWORD *)a1 + 6) == *((_DWORD *)a2 + 6) && (v5 & 0x100000000000000) == 0;
      BOOL v3 = (v5 & 0x200000000000000) == 0 && (unint64_t)v12;
    }
    else
    {
      BOOL v3 = 0;
    }
    if ((~(_WORD)gIIODebugFlags & 0x300) == 0)
    {
      DebugStringFromKedouble y = createDebugStringFromKey((uint64_t)a1);
      if (DebugStringFromKey)
      {
        double v7 = DebugStringFromKey;
        unsigned int v8 = "!=";
        if (v3) {
          unsigned int v8 = "==";
        }
        ImageIOLog("    %s %s\n", v8, DebugStringFromKey);
        free(v7);
      }
      int v9 = createDebugStringFromKey((uint64_t)a2);
      if (v9)
      {
        double v10 = v9;
        ImageIOLog("       %s\n", v9);
        free(v10);
      }
    }
  }
  return v3;
}

uint64_t ImageIO_make_purgeable(const void *a1)
{
  uint64_t result = IIO_XPCServer();
  if ((result & 1) == 0)
  {
    if ((gIIODebugFlags & 0xC0) != 0)
    {
      ImageIOLog("    ImageIO_make_purgeable:     %14p\n", a1);
      if ((gIIODebugFlags & 0x80) != 0) {
        IIODebug_ShowBacktrace(1);
      }
    }
    int v3 = 1;
    uint64_t result = MEMORY[0x18C11DC50](*MEMORY[0x1E4F14960], a1, 0, &v3);
    if (result)
    {
      if ((gIIODebugFlags & 0xC0) != 0) {
        return (uint64_t)ImageIOLog("    vm_purgable_control-SET_STATE-VM_PURGABLE_VOLATILE : %ld\n", (int)result);
      }
    }
  }
  return result;
}

void imageio_key_release(void *a1, void *a2)
{
  if ((gIIODebugFlags & 0x200) != 0) {
    ImageIOLog("    imageio_key_release    key: %p   user_data: %p\n", a1, a2);
  }

  free(a1);
}

uint64_t IIO_Reader_HEIF::initImageAtOffset(uint64_t a1)
{
  if ((IIO_XPCServer() & 1) == 0)
  {
    CFStringCompare(**(CFStringRef **)(a1 + 8), @"public.jpeg", 0);
    operator new();
  }
  return 4294967246;
}

void sub_1885CF4AC(void *a1)
{
}

uint64_t IIOReadPlugin::setDestMaxPixelSize(uint64_t this, int a2)
{
  *(_DWORD *)(this + 212) = a2;
  return this;
}

uint64_t HEIFReadPlugin::HEIFReadPlugin(uint64_t a1, uint64_t a2, int a3, unint64_t a4, unsigned int a5, char a6, int a7)
{
  uint64_t v12 = IIOReadPlugin::IIOReadPlugin(a1, a2, a3, a4, a7);
  *(void *)uint64_t v12 = &unk_1ED4E1188;
  *(_OWORD *)(v12 + 440) = 0u;
  *(_OWORD *)(v12 + 456) = 0u;
  *(_OWORD *)(v12 + 472) = 0u;
  *(_OWORD *)(v12 + 488) = 0u;
  *(_OWORD *)(v12 + 504) = 0u;
  *(void *)(v12 + 520) = 0;
  if (a7 == 1246774599)
  {
    uint64_t v15 = 0;
    memset(v14, 0, sizeof(v14));
    IIOScanner::IIOScanner((IIOScanner *)v14, *(IIOImageReadSession **)(a1 + 24));
    GlobalHEIFInfo::setShouldExposeMultiFrameContents((uint64_t)v14, 0);
    IIOScanner::seek((IIOScanner *)v14, a4);
    if (IIOScanner::getVal16((IIOScanner *)v14) == 65496)
    {
      IIOScanner::seek((IIOScanner *)v14, a4 + a5 - 2);
      if (IIOScanner::getVal16((IIOScanner *)v14) == 65497)
      {
        *(void *)(a1 + 464) = a4;
        *(void *)(a1 + 472) = a5;
      }
    }
    IIOScanner::~IIOScanner((IIOScanner *)v14);
  }
  *(_DWORD *)(a1 + 484) = 1;
  *(unsigned char *)(a1 + 499) = a6;
  *(unsigned char *)(a1 + 340) = 1;
  return a1;
}

#error "1885CF640: call analysis failed (funcsize=12)"

void sub_1885CF64C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  __cxa_end_catch();
  IIOScanner::~IIOScanner((IIOScanner *)va);
  JUMPOUT(0x1885CF668);
}

void createArrayPropertyValue(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  memset(v5, 0, 120);
  TXMPIterator<std::string>::TXMPIterator(v5, a2, a3, a5, 0);
}

void sub_1885CFD88(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21,uint64_t a22,char a23,uint64_t a24,char a25,uint64_t a26,uint64_t a27,void *__p,uint64_t a29,int a30,__int16 a31,char a32,char a33)
{
  TXMPIterator<std::string>::~TXMPIterator((uint64_t)&a25);
  if (a33 < 0) {
    operator delete(__p);
  }
  if (*(char *)(v33 - 137) < 0) {
    operator delete(*(void **)(v33 - 160));
  }
  if (*(char *)(v33 - 113) < 0) {
    operator delete(*(void **)(v33 - 136));
  }
  if (*(char *)(v33 - 89) < 0) {
    operator delete(*(void **)(v33 - 112));
  }
  _Unwind_Resume(a1);
}

void createStructPropertyValue(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  memset(v5, 0, 120);
  TXMPIterator<std::string>::TXMPIterator(v5, a2, a3, a5, 0);
}

void sub_1885D0498(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16, uint64_t a17, char a18, uint64_t a19, uint64_t a20,char a21,uint64_t a22,uint64_t a23,void *__p,uint64_t a25,int a26,__int16 a27,char a28,char a29,void *a30,uint64_t a31,int a32,__int16 a33,char a34,char a35)
{
  TXMPIterator<std::string>::~TXMPIterator((uint64_t)&a21);
  if (a29 < 0) {
    operator delete(__p);
  }
  if (a35 < 0) {
    operator delete(a30);
  }
  if (*(char *)(v35 - 113) < 0) {
    operator delete(*(void **)(v35 - 136));
  }
  if (*(char *)(v35 - 89) < 0) {
    operator delete(*(void **)(v35 - 112));
  }
  _Unwind_Resume(a1);
}

CGMutableImageMetadataRef CGImageMetadataCreateMutableCopy(CGImageMetadataRef metadata)
{
  IIOInitDebugFlags();
  if ((~(_WORD)gIIODebugFlags & 0x3000) == 0) {
    ImageIODebugOptions(3, "A", "CGImageMetadataCreateMutableCopy", 0, 0, -1, 0);
  }
  if (!metadata) {
    return 0;
  }
  CFTypeID v2 = CFGetTypeID(metadata);
  if (v2 != CGImageMetadataGetTypeID()) {
    return 0;
  }
  CFAllocatorRef v3 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CGImageMetadataGetTypeID();
  uint64_t Instance = _CFRuntimeCreateInstance();
  uint64_t v5 = Instance;
  if (Instance)
  {
    *(unsigned char *)(Instance + 16) = 1;
    CFDictionaryRef v6 = (const __CFDictionary *)*((void *)metadata + 3);
    double v7 = CGImageMetadataTagsDictCreate();
    if (!v6)
    {
LABEL_20:
      *(void *)(v5 + 24) = v7;
      CFDictionaryRef v20 = (const __CFDictionary *)*((void *)metadata + 5);
      if (v20) {
        *(void *)(v5 + 40) = CFDictionaryCreateMutableCopy(v3, 0, v20);
      }
      CFDictionaryRef v21 = (const __CFDictionary *)*((void *)metadata + 4);
      if (v21) {
        *(void *)(v5 + 32) = CFDictionaryCreateMutableCopy(v3, 0, v21);
      }
      CFDictionaryRef v22 = (const __CFDictionary *)*((void *)metadata + 6);
      if (v22) {
        *(void *)(v5 + 48) = CFDictionaryCreateMutableCopy(v3, 0, v22);
      }
      CFStringRef v23 = (const __CFString *)*((void *)metadata + 7);
      if (v23) {
        *(void *)(v5 + 56) = CFStringCreateCopy(v3, v23);
      }
      CFStringRef v24 = (const __CFString *)*((void *)metadata + 8);
      if (v24) {
        *(void *)(v5 + 64) = CFStringCreateCopy(v3, v24);
      }
      initRecursivePthread_mutex((pthread_mutex_t *)(v5 + 72));
      pthread_mutex_init((pthread_mutex_t *)(v5 + 136), 0);
      initRecursivePthread_mutex((pthread_mutex_t *)(v5 + 208));
      return (CGMutableImageMetadataRef)v5;
    }
    int64_t Count = CFDictionaryGetCount(v6);
    int v9 = (const void **)malloc_type_calloc(8uLL, Count, 0x69C4DE67uLL);
    double v10 = (const void **)malloc_type_calloc(8uLL, Count, 0xBEFA0FF0uLL);
    long long v11 = v10;
    if (v9 && v10)
    {
      CFDictionaryGetKeysAndValues(v6, v9, v10);
      if (Count < 1)
      {
LABEL_17:
        free(v9);
LABEL_18:
        if (v11) {
          free(v11);
        }
        goto LABEL_20;
      }
      uint64_t v15 = v11;
      unsigned int v16 = v9;
      do
      {
        if (*v15)
        {
          uint64_t v17 = (IIOMetadata_Tag *)*((void *)*v15 + 3);
          if (v17)
          {
            DeepCFStringRef Copy = IIOMetadata_Tag::createDeepCopy(v17, v12, v13, v14);
            if (DeepCopy)
            {
              CGImageMetadataTagRef v19 = DeepCopy;
              CFDictionarySetValue(v7, *v16, DeepCopy);
              CFRelease(v19);
            }
          }
        }
        ++v16;
        ++v15;
        --Count;
      }
      while (Count);
    }
    if (!v9) {
      goto LABEL_18;
    }
    goto LABEL_17;
  }
  return (CGMutableImageMetadataRef)v5;
}

CGImageMetadataTagRef IIOMetadata_Tag::createDeepCopy(IIOMetadata_Tag *this, uint64_t a2, uint64_t a3, const __CFString *a4)
{
  uint64_t v5 = (const void *)IIOMetadata_Tag::copyTagValue(this, *((const __CFString **)this + 2), *((const __CFString **)this + 3), a4, *((CFTypeRef *)this + 6), 1);
  if (!v5) {
    return 0;
  }
  CFDictionaryRef v6 = v5;
  CGImageMetadataTagRef v7 = CGImageMetadataTagCreate(*((CFStringRef *)this + 2), *((CFStringRef *)this + 3), *((CFStringRef *)this + 4), (CGImageMetadataType)*((_DWORD *)this + 10), v5);
  CFRelease(v6);
  if (v7)
  {
    double v10 = (const void *)*((void *)this + 7);
    if (v10)
    {
      uint64_t v11 = *((void *)v7 + 3);
      *(void *)(v11 + 56) = IIOMetadata_Tag::copyTagValue(v8, *((const __CFString **)this + 2), *((const __CFString **)this + 3), v9, v10, 1);
    }
  }
  return v7;
}

CGImageMetadataTagRef CGImageMetadataTagCreate(CFStringRef xmlns, CFStringRef prefix, CFStringRef name, CGImageMetadataType type, CFTypeRef value)
{
  IIOInitDebugFlags();
  if ((~(_WORD)gIIODebugFlags & 0x3000) == 0)
  {
    IIOString::IIOString((IIOString *)v24, name);
    double v10 = (const char *)IIOString::utf8String((IIOString *)v24);
    ImageIODebugOptions(3, "A", "CGImageMetadataTagCreate", 0, v10, -1, 0);
    IIOString::~IIOString((IIOString *)v24);
  }
  if (xmlns)
  {
    CFTypeID v11 = CFGetTypeID(xmlns);
    if (v11 == CFStringGetTypeID())
    {
      if (prefix)
      {
        CFTypeID v12 = CFGetTypeID(prefix);
        CFTypeID TypeID = CFStringGetTypeID();
        if (!name || v12 != TypeID) {
          return 0;
        }
      }
      else if (!name)
      {
        return 0;
      }
      CFTypeID v14 = CFGetTypeID(name);
      CFTypeID v15 = CFStringGetTypeID();
      if (value && v14 == v15)
      {
        CFTypeID v16 = CFGetTypeID(value);
        if (v16 == CFStringGetTypeID()
          || (CFTypeID v17 = CFGetTypeID(value), v17 == CFNumberGetTypeID())
          || (CFTypeID v18 = CFGetTypeID(value), v18 == CFBooleanGetTypeID())
          || (CFTypeID v19 = CFGetTypeID(value), v19 == CFArrayGetTypeID())
          || (CFTypeID v20 = CFGetTypeID(value), v20 == CFNullGetTypeID()))
        {
          if (type > kCGImageMetadataTypeStructure) {
            return 0;
          }
        }
        else
        {
          CFTypeID v22 = CFGetTypeID(value);
          CFTypeID v23 = CFDictionaryGetTypeID();
          if (type > kCGImageMetadataTypeStructure || v22 != v23) {
            return 0;
          }
        }
        if (CGImageMetadataTagGetTypeID::once != -1) {
          dispatch_once(&CGImageMetadataTagGetTypeID::once, &__block_literal_global_34);
        }
        *(_DWORD *)(_CFRuntimeCreateInstance() + 16) = 1;
        atomic_fetch_add_explicit(&gMDTCount, 1uLL, memory_order_relaxed);
        operator new();
      }
    }
  }
  return 0;
}

void sub_1885D0A84(void *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10E1C406EDB48BALL);
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x1885D0A24);
}

void sub_1885D0AB8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  IIOString::~IIOString((IIOString *)va);
  _Unwind_Resume(a1);
}

void IIOMetadata_Tag::IIOMetadata_Tag(IIOMetadata_Tag *this, const __CFString *a2, const __CFString *a3, const __CFString *a4, int a5, __CFString *a6)
{
  *(void *)this = &unk_1ED4E32B0;
  *(_OWORD *)((char *)this + 8) = 0u;
  *(_OWORD *)((char *)this + 24) = 0u;
  *((_DWORD *)this + 10) = -1;
  *((void *)this + 6) = 0;
  CFTypeID v12 = (CFStringRef *)((char *)this + 48);
  *((_DWORD *)this + 17) = 0;
  *((void *)this + 7) = 0;
  *((unsigned char *)this + 64) = 0;
  CFAllocatorRef v13 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFStringRef Copy = CFStringCreateCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a2);
  *((void *)this + 2) = Copy;
  if (!a3)
  {
    a3 = CGImageMetadataDefaultPrefixForNamespace(Copy);
    if (!a3)
    {
LABEL_15:
      exception = __cxa_allocate_exception(4uLL);
      _DWORD *exception = -1;
      __cxa_throw(exception, MEMORY[0x1E4FBA3A8], 0);
    }
  }
  *((void *)this + 3) = CFStringCreateCopy(v13, a3);
  CFTypeID TypeID = (IIOMetadata_Tag *)CFStringCreateCopy(v13, a4);
  *((void *)this + 4) = TypeID;
  if (a5) {
    goto LABEL_8;
  }
  CFTypeID v17 = CFGetTypeID(a6);
  CFTypeID TypeID = (IIOMetadata_Tag *)CFStringGetTypeID();
  if ((IIOMetadata_Tag *)v17 == TypeID
    || (CFTypeID v18 = CFGetTypeID(a6), TypeID = (IIOMetadata_Tag *)CFNumberGetTypeID(), (IIOMetadata_Tag *)v18 == TypeID)
    || (CFTypeID v19 = CFGetTypeID(a6), TypeID = (IIOMetadata_Tag *)CFBooleanGetTypeID(), (IIOMetadata_Tag *)v19 == TypeID))
  {
    a5 = 1;
LABEL_8:
    *((_DWORD *)this + 10) = a5;
    goto LABEL_9;
  }
  CFTypeID v21 = CFGetTypeID(a6);
  CFTypeID TypeID = (IIOMetadata_Tag *)CFArrayGetTypeID();
  if ((IIOMetadata_Tag *)v21 == TypeID)
  {
    a5 = 3;
    goto LABEL_8;
  }
  CFTypeID v22 = CFGetTypeID(a6);
  CFTypeID TypeID = (IIOMetadata_Tag *)CFDictionaryGetTypeID();
  if ((IIOMetadata_Tag *)v22 == TypeID)
  {
    a5 = 6;
    goto LABEL_8;
  }
LABEL_9:
  CFStringRef v20 = IIOMetadata_Tag::copyTagValue(TypeID, a2, a3, v16, a6, 0);
  *CFTypeID v12 = v20;
  if (!v20) {
    goto LABEL_15;
  }
  *((unsigned char *)this + 64) = 1;
}

CFStringRef IIOMetadata_Tag::copyTagValue(IIOMetadata_Tag *this, const __CFString *a2, const __CFString *a3, const __CFString *a4, __CFString *cf, int a6)
{
  MutableCFStringRef Copy = cf;
  CFTypeID v10 = CFGetTypeID(cf);
  if (v10 == CFNullGetTypeID()) {
    return MutableCopy;
  }
  CFTypeID v12 = CFGetTypeID(MutableCopy);
  if (v12 == CFStringGetTypeID())
  {
    CFAllocatorRef v13 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    return CFStringCreateCopy(v13, MutableCopy);
  }
  CFTypeID v14 = CFGetTypeID(MutableCopy);
  if (v14 != CFNumberGetTypeID())
  {
    CFTypeID v17 = CFGetTypeID(MutableCopy);
    if (v17 == CFBooleanGetTypeID())
    {
      CFStringRef v15 = MutableCopy;
      uint64_t v16 = 0;
      goto LABEL_11;
    }
    CFTypeID v18 = CFGetTypeID(MutableCopy);
    if (v18 == CFArrayGetTypeID())
    {
      uint64_t Count = CFArrayGetCount((CFArrayRef)MutableCopy);
      CFAllocatorRef v20 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      MutableCFStringRef Copy = (__CFString *)CFArrayCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], Count, (CFArrayRef)MutableCopy);
      if (Count >= 1)
      {
        for (CFIndex i = 0; Count != i; ++i)
        {
          ValueAtIndedouble x = CFArrayGetValueAtIndex((CFArrayRef)MutableCopy, i);
          CFTypeID v23 = CFGetTypeID(ValueAtIndex);
          if (v23 == CFStringGetTypeID())
          {
            CFStringRef v24 = CFStringCreateWithFormat(v20, 0, @"[%ld]", i);
            if (!v24) {
              continue;
            }
            CFStringRef v25 = v24;
            DeepCFStringRef Copy = CGImageMetadataTagCreate(a2, a3, v24, kCGImageMetadataTypeString, ValueAtIndex);
            CFRelease(v25);
            if (!DeepCopy) {
              continue;
            }
          }
          else
          {
            if (!ValueAtIndex || !a6) {
              continue;
            }
            CFTypeID v30 = CFGetTypeID(ValueAtIndex);
            if (CGImageMetadataTagGetTypeID::once != -1) {
              dispatch_once(&CGImageMetadataTagGetTypeID::once, &__block_literal_global_34);
            }
            if (v30 != CGImageMetadataTagGetTypeID::id) {
              continue;
            }
            uint64_t v31 = (IIOMetadata_Tag *)ValueAtIndex[3];
            if (!v31) {
              continue;
            }
            DeepCFStringRef Copy = IIOMetadata_Tag::createDeepCopy(v31, v27, v28, v29);
            if (!DeepCopy) {
              continue;
            }
          }
          CFArraySetValueAtIndex((CFMutableArrayRef)MutableCopy, i, DeepCopy);
          CFRelease(DeepCopy);
        }
      }
      return MutableCopy;
    }
    CFTypeID v32 = CFGetTypeID(MutableCopy);
    if (v32 != CFDictionaryGetTypeID())
    {
      CFStringRef v47 = CFCopyDescription(MutableCopy);
      IIOString::IIOString((IIOString *)v51, v47);
      int v48 = (const char *)IIOString::utf8String((IIOString *)v51);
      LogError("copyTagValue", 386, "*** ERROR: copyTagValue not handled for %s\n", v48);
      IIOString::~IIOString((IIOString *)v51);
      return 0;
    }
    CFIndex v33 = CFDictionaryGetCount((CFDictionaryRef)MutableCopy);
    MutableCFStringRef Copy = (__CFString *)CFDictionaryCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v33, (CFDictionaryRef)MutableCopy);
    uint64_t v34 = (const void **)malloc_type_calloc(8uLL, v33, 0x9A1BD4F9uLL);
    uint64_t v35 = (const void **)malloc_type_calloc(8uLL, v33, 0x34D33DFuLL);
    CFDictionaryGetKeysAndValues((CFDictionaryRef)MutableCopy, v34, v35);
    int v49 = v34;
    unsigned int v50 = v35;
    if (v33 < 1)
    {
      if (v34) {
LABEL_49:
      }
        free(v49);
      if (v50) {
        free(v50);
      }
      return MutableCopy;
    }
    while (1)
    {
      CFStringRef v36 = (const __CFString *)*v34;
      uint64_t v37 = *v35;
      CFTypeID v38 = CFGetTypeID(*v35);
      if (v38 == CFStringGetTypeID())
      {
        CGImageMetadataTagRef v39 = CGImageMetadataTagCreate(a2, a3, v36, kCGImageMetadataTypeString, v37);
      }
      else
      {
        if (v37) {
          BOOL v41 = a6 == 0;
        }
        else {
          BOOL v41 = 1;
        }
        if (v41) {
          goto LABEL_45;
        }
        CFTypeID v45 = CFGetTypeID(v37);
        if (CGImageMetadataTagGetTypeID::once != -1) {
          dispatch_once(&CGImageMetadataTagGetTypeID::once, &__block_literal_global_34);
        }
        if (v45 != CGImageMetadataTagGetTypeID::id) {
          goto LABEL_45;
        }
        int v46 = (IIOMetadata_Tag *)v37[3];
        if (!v46) {
          goto LABEL_45;
        }
        CGImageMetadataTagRef v39 = IIOMetadata_Tag::createDeepCopy(v46, v42, v43, v44);
      }
      CGImageMetadataTagRef v40 = v39;
      if (v39)
      {
        CFDictionarySetValue((CFMutableDictionaryRef)MutableCopy, v36, v39);
        CFRelease(v40);
      }
LABEL_45:
      ++v35;
      ++v34;
      if (!--v33) {
        goto LABEL_49;
      }
    }
  }
  CFStringRef v15 = MutableCopy;
  uint64_t v16 = 1;
LABEL_11:

  return CGImageMetadataCreateSimpleStringFromCFValue(v15, v16);
}

void sub_1885D10CC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  IIOString::~IIOString((IIOString *)va);
  _Unwind_Resume(a1);
}

CFStringRef CGImageMetadataCreateSimpleStringFromCFValue(CFStringRef result, uint64_t a2)
{
  if (!result) {
    return result;
  }
  CFStringRef v3 = result;
  CFTypeID v4 = CFGetTypeID(result);
  if (v4 == CFStringGetTypeID())
  {
    CFAllocatorRef v5 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    CFStringRef v6 = v3;
    goto LABEL_4;
  }
  CFTypeID v7 = CFGetTypeID(v3);
  if (v7 == CFBooleanGetTypeID())
  {
    int Value = CFBooleanGetValue((CFBooleanRef)v3);
    CFAllocatorRef v5 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    if (Value == 1) {
      CFStringRef v6 = @"True";
    }
    else {
      CFStringRef v6 = @"False";
    }
LABEL_4:
    return CFStringCreateCopy(v5, v6);
  }
  CFTypeID v9 = CFGetTypeID(v3);
  if (v9 == CFNumberGetTypeID())
  {
    switch(CFNumberGetType((CFNumberRef)v3))
    {
      case kCFNumberSInt8Type:
        LOBYTE(valuePtr) = 0;
        if (!CFNumberGetValue((CFNumberRef)v3, kCFNumberSInt8Type, &valuePtr)) {
          return 0;
        }
        CFAllocatorRef v10 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
        *(void *)&double v11 = SLOBYTE(valuePtr);
        goto LABEL_56;
      case kCFNumberSInt16Type:
        LOWORD(valuePtr) = 0;
        if (!CFNumberGetValue((CFNumberRef)v3, kCFNumberSInt16Type, &valuePtr)) {
          return 0;
        }
        CFAllocatorRef v10 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
        *(void *)&double v11 = SLOWORD(valuePtr);
        goto LABEL_56;
      case kCFNumberSInt32Type:
        LODWORD(valuePtr) = 0;
        if (!CFNumberGetValue((CFNumberRef)v3, kCFNumberSInt32Type, &valuePtr)) {
          return 0;
        }
        CFAllocatorRef v10 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
        *(void *)&double v11 = SLODWORD(valuePtr);
        goto LABEL_56;
      case kCFNumberSInt64Type:
        double valuePtr = 0.0;
        CFNumberRef v21 = (const __CFNumber *)v3;
        CFNumberType v22 = kCFNumberSInt64Type;
        goto LABEL_45;
      case kCFNumberFloat32Type:
        LODWORD(valuePtr) = 0;
        if (!CFNumberGetValue((CFNumberRef)v3, kCFNumberFloat32Type, &valuePtr)) {
          return 0;
        }
        if (a2 == 2) {
          goto LABEL_65;
        }
        if (a2 == 1) {
          goto LABEL_50;
        }
        *(void *)CGImageMetadataTagRef v39 = 0;
        double v23 = *(float *)&valuePtr;
        goto LABEL_69;
      case kCFNumberFloat64Type:
        double valuePtr = 0.0;
        if (!CFNumberGetValue((CFNumberRef)v3, kCFNumberFloat64Type, &valuePtr)) {
          return 0;
        }
        if (a2 == 2) {
          goto LABEL_64;
        }
        if (a2 == 1) {
          return CFStringCreateWithFormat(0, 0, @"%@", v3, v38, *(void *)v39);
        }
        *(void *)CGImageMetadataTagRef v39 = 0;
        double v23 = valuePtr;
LABEL_69:
        SRationalApprox(v23, (int *)&v39[1], v39);
        LODWORD(v35) = v39[0];
        if (!v39[0]) {
          return 0;
        }
        if (a2 != 4 || v39[0] != 1)
        {
          LODWORD(v36) = v39[1];
          if ((int)v39[1] >= 2 && v39[1] < v39[0] && v39[1] + v39[0] / v39[1] * v39[1] - v39[0] == 1)
          {
            LODWORD(v35) = (v39[0] + 1) / v39[1];
            LODWORD(v36) = 1;
            v39[0] = v35;
            v39[1] = 1;
          }
          CFAllocatorRef v10 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
          uint64_t v36 = (int)v36;
          uint64_t v35 = v35;
          return CFStringCreateWithFormat(v10, 0, @"%ld/%ld", v36, v35, *(void *)v39);
        }
        CFAllocatorRef v10 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
        *(void *)&double v11 = (int)v39[1];
LABEL_56:
        double v37 = v11;
        return CFStringCreateWithFormat(v10, 0, @"%ld", *(void *)&v37, v38, *(void *)v39);
      case kCFNumberCharType:
        LOBYTE(valuePtr) = 0;
        if (!CFNumberGetValue((CFNumberRef)v3, kCFNumberCharType, &valuePtr)) {
          return 0;
        }
        CFAllocatorRef v24 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
        uint64_t v25 = SLOBYTE(valuePtr);
        return CFStringCreateWithFormat(v24, 0, @"%d", v25, v38, *(void *)v39);
      case kCFNumberShortType:
        LOWORD(valuePtr) = 0;
        if (!CFNumberGetValue((CFNumberRef)v3, kCFNumberShortType, &valuePtr)) {
          return 0;
        }
        CFAllocatorRef v24 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
        uint64_t v25 = SLOWORD(valuePtr);
        return CFStringCreateWithFormat(v24, 0, @"%d", v25, v38, *(void *)v39);
      case kCFNumberIntType:
        LODWORD(valuePtr) = 0;
        if (!CFNumberGetValue((CFNumberRef)v3, kCFNumberIntType, &valuePtr)) {
          return 0;
        }
        CFAllocatorRef v24 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
        uint64_t v25 = LODWORD(valuePtr);
        return CFStringCreateWithFormat(v24, 0, @"%d", v25, v38, *(void *)v39);
      case kCFNumberLongType:
        double valuePtr = 0.0;
        CFNumberRef v26 = (const __CFNumber *)v3;
        CFNumberType v27 = kCFNumberLongType;
        goto LABEL_54;
      case kCFNumberLongLongType:
        double valuePtr = 0.0;
        CFNumberRef v21 = (const __CFNumber *)v3;
        CFNumberType v22 = kCFNumberLongLongType;
LABEL_45:
        if (!CFNumberGetValue(v21, v22, &valuePtr)) {
          return 0;
        }
        return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"%lld", *(void *)&valuePtr, v38, *(void *)v39);
      case kCFNumberFloatType:
        LODWORD(valuePtr) = 0;
        if (!CFNumberGetValue((CFNumberRef)v3, kCFNumberFloatType, &valuePtr)) {
          return 0;
        }
        if (a2 == 2)
        {
LABEL_65:
          CFAllocatorRef v32 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
          double v33 = *(float *)&valuePtr;
          return CFStringCreateWithFormat(v32, 0, @"%g", *(void *)&v33, v38, *(void *)v39);
        }
        if (a2 == 1)
        {
LABEL_50:
          CFAllocatorRef v28 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
          double v29 = *(float *)&valuePtr;
          return CFStringCreateWithFormat(v28, 0, @"%f", *(void *)&v29, v38, *(void *)v39);
        }
        *(void *)CGImageMetadataTagRef v39 = 0;
        double v34 = *(float *)&valuePtr;
        goto LABEL_74;
      case kCFNumberDoubleType:
        double valuePtr = 0.0;
        CFNumberRef v30 = (const __CFNumber *)v3;
        CFNumberType v31 = kCFNumberDoubleType;
        goto LABEL_59;
      case kCFNumberCFIndexType:
        double valuePtr = 0.0;
        CFNumberRef v26 = (const __CFNumber *)v3;
        CFNumberType v27 = kCFNumberCFIndexType;
        goto LABEL_54;
      case kCFNumberNSIntegerType:
        double valuePtr = 0.0;
        CFNumberRef v26 = (const __CFNumber *)v3;
        CFNumberType v27 = kCFNumberNSIntegerType;
LABEL_54:
        if (!CFNumberGetValue(v26, v27, &valuePtr)) {
          return 0;
        }
        CFAllocatorRef v10 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
        double v11 = valuePtr;
        goto LABEL_56;
      case kCFNumberCGFloatType:
        double valuePtr = 0.0;
        CFNumberRef v30 = (const __CFNumber *)v3;
        CFNumberType v31 = kCFNumberCGFloatType;
LABEL_59:
        if (!CFNumberGetValue(v30, v31, &valuePtr)) {
          return 0;
        }
        if (a2 == 2)
        {
LABEL_64:
          CFAllocatorRef v32 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
          double v33 = valuePtr;
          return CFStringCreateWithFormat(v32, 0, @"%g", *(void *)&v33, v38, *(void *)v39);
        }
        if (a2 == 1)
        {
          CFAllocatorRef v28 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
          double v29 = valuePtr;
          return CFStringCreateWithFormat(v28, 0, @"%f", *(void *)&v29, v38, *(void *)v39);
        }
        *(void *)CGImageMetadataTagRef v39 = 0;
        double v34 = valuePtr;
LABEL_74:
        SRationalApprox(v34, (int *)&v39[1], v39);
        uint64_t v35 = v39[0];
        if (v39[0])
        {
          CFAllocatorRef v10 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
          uint64_t v36 = (int)v39[1];
          if (a2 != 4 || v39[0] != 1) {
            return CFStringCreateWithFormat(v10, 0, @"%ld/%ld", v36, v35, *(void *)v39);
          }
          *(void *)&double v37 = (int)v39[1];
          return CFStringCreateWithFormat(v10, 0, @"%ld", *(void *)&v37, v38, *(void *)v39);
        }
        break;
      default:
        return 0;
    }
    return 0;
  }
  CFTypeID v12 = CFGetTypeID(v3);
  if (v12 != CFArrayGetTypeID()) {
    return 0;
  }
  uint64_t Count = CFArrayGetCount((CFArrayRef)v3);
  CFAllocatorRef v14 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  uint64_t result = (CFStringRef)CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], Count, MEMORY[0x1E4F1D510]);
  if (result)
  {
    CFStringRef v15 = (__CFArray *)result;
    if (Count >= 1)
    {
      for (CFIndex i = 0; i != Count; ++i)
      {
        ValueAtIndedouble x = CFArrayGetValueAtIndex((CFArrayRef)v3, i);
        CFStringRef SimpleStringFromCFValue = (const void *)CGImageMetadataCreateSimpleStringFromCFValue(ValueAtIndex, a2);
        if (SimpleStringFromCFValue)
        {
          CFTypeID v19 = SimpleStringFromCFValue;
          CFArraySetValueAtIndex(v15, i, SimpleStringFromCFValue);
          CFRelease(v19);
        }
      }
    }
    CFStringRef v20 = CFStringCreateByCombiningStrings(v14, v15, @"; ");
    CFRelease(v15);
    return v20;
  }
  return result;
}

CFMutableDictionaryRef CGImageMetadataTagsDictCreate()
{
  return CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, &kCGImageMetadataTagKeyCallbacks, MEMORY[0x1E4F1D540]);
}

void TXMPIterator<std::string>::TXMPIterator(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  *a1 = &unk_1ED4DF370;
  a1[1] = 0;
  uint64_t v6 = 0;
  memset(v5, 0, sizeof(v5));
  WXMPIterator_PropCTor_1(*(void *)(a2 + 8), a3, a4, a5, v5);
}

void TXMPIterator<std::string>::TXMPIterator(void *a1, uint64_t a2, uint64_t a3)
{
  *a1 = &unk_1ED4DF370;
  a1[1] = 0;
  uint64_t v4 = 0;
  memset(v3, 0, sizeof(v3));
  WXMPIterator_PropCTor_1(*(void *)(a2 + 8), (uint64_t)"", (uint64_t)"", a3, v3);
}

void WXMPIterator_PropCTor_1(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void *a5)
{
  *a5 = 0;
  uint64_t v5 = a1 + 16;
  XMP_ReadWriteLock::Acquire((pthread_rwlock_t *)(a1 + 16), 0);
  operator new();
}

void sub_1885D193C(void *a1, int a2, uint64_t a3, ...)
{
  va_start(va, a3);
  MEMORY[0x18C11C0E0](v4, 0x10F3C40652ADE5BLL);
  XMP_AutoLock::~XMP_AutoLock((XMP_ReadWriteLock **)va);
  if (a2 == 3)
  {
    unsigned int v8 = __cxa_begin_catch(a1);
    *(_DWORD *)(v3 + 32) = *(_DWORD *)v8;
    CFTypeID v9 = (const char *)*((void *)v8 + 1);
    if (!v9) {
      CFTypeID v9 = v5;
    }
    *(void *)(v3 + 8) = "XMP";
  }
  else
  {
    CFAllocatorRef v10 = __cxa_begin_catch(a1);
    if (a2 == 2)
    {
      *(_DWORD *)(v3 + 32) = 13;
      uint64_t v11 = (*(uint64_t (**)(void *))(*(void *)v10 + 16))(v10);
      if (v11) {
        CFTypeID v9 = (const char *)v11;
      }
      else {
        CFTypeID v9 = v5;
      }
    }
    else
    {
      *(_DWORD *)(v3 + 32) = 14;
      CFTypeID v9 = "Caught unknown exception";
    }
  }
  *(void *)uint64_t v3 = v9;
  __cxa_end_catch();
  JUMPOUT(0x1885D18FCLL);
}

BOOL CGImageMetadataTagAppendQualifier(CGImageMetadata *a1, uint64_t a2, const void *a3)
{
  BOOL v4 = a2;
  uint64_t Source = CGImageSourceGetSource(a2);
  uint64_t v7 = CGImageSourceGetSource((uint64_t)a3);
  if (!v4) {
    return v4;
  }
  uint64_t v9 = v7;
  CFTypeID v10 = CFGetTypeID((CFTypeRef)v4);
  CFTypeID TypeID = CGImageMetadataTagGetTypeID();
  BOOL v4 = 0;
  if (!a3 || v10 != TypeID) {
    return v4;
  }
  CFTypeID v12 = CFGetTypeID(a3);
  if (v12 != CGImageMetadataTagGetTypeID()) {
    return 0;
  }
  if (*(_DWORD *)(Source + 40) != 1)
  {
    CFStringRef v16 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Failed to add qualifier '%@:%@' to tag '%@:%@'. Qualifiers may only be added to string tags - not arrays or structures.", *(void *)(v9 + 24), *(void *)(v9 + 32), *(void *)(Source + 24), *(void *)(Source + 32));
    if (v16)
    {
      CFStringRef v17 = v16;
      IIOString::IIOString((IIOString *)err, v16);
      UTF8String = (char *)IIOString::createUTF8String((IIOString *)err);
      IIOString::~IIOString((IIOString *)err);
      if (UTF8String)
      {
        LogMetadata("CGImageMetadataTagAppendQualifier", 427, UTF8String);
        free(UTF8String);
      }
      CFRelease(v17);
    }
    return 0;
  }
  CFAllocatorRef v13 = *(__CFArray **)(Source + 56);
  if (!v13 || (CFTypeID v14 = CFGetTypeID(*(CFTypeRef *)(Source + 56)), v14 != CFArrayGetTypeID()))
  {
    CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
    if (Mutable)
    {
      CFAllocatorRef v13 = Mutable;
      *(void *)(Source + 56) = Mutable;
      goto LABEL_11;
    }
    return 0;
  }
LABEL_11:
  err[0] = 0;
  BOOL v4 = CGImageMetadataRegisterNamespaceForPrefix(a1, *(CFStringRef *)(v9 + 16), *(CFStringRef *)(v9 + 24), err);
  if (v4)
  {
    CFArrayAppendValue(v13, a3);
  }
  else
  {
    CStringPtr = CFStringGetCStringPtr(*(CFStringRef *)(v9 + 24), 0);
    CFStringRef v20 = CFStringGetCStringPtr(*(CFStringRef *)(v9 + 16), 0);
    LogMetadata("CGImageMetadataTagAppendQualifier", 408, "An error occurred while registering prefix '%s' for namespace '%s'\n", CStringPtr, v20);
    if (err[0])
    {
      CFStringRef v21 = CFErrorCopyFailureReason(err[0]);
      if (v21)
      {
        CFStringRef v22 = v21;
        double v23 = CFStringGetCStringPtr(v21, 0);
        LogMetadata("CGImageMetadataTagAppendQualifier", 414, "Failure Reason: %s\n", v23);
        CFRelease(v22);
      }
    }
  }
  return v4;
}

void sub_1885D1C34(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  IIOString::~IIOString((IIOString *)va);
  _Unwind_Resume(a1);
}

void AdobeXMPCore_Int::ICoreConfigurationManager_I::DestroyCoreConfigurationManager(AdobeXMPCore_Int::ICoreConfigurationManager_I *this)
{
  AdobeXMPCore_Int::ManageCoreConfigurationManager((AdobeXMPCore_Int *)1, &v2);
  uint64_t v1 = v3;
  if (v3)
  {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
}

void AdobeXMPCore_Int::ManageCoreConfigurationManager(AdobeXMPCore_Int *this@<X0>, void *a2@<X8>)
{
  {
    int v7 = (int)this;
    LODWORD(this) = v7;
    if (v8)
    {
      __cxa_atexit((void (*)(void *))std::shared_ptr<AdobeXMPCore::ICoreConfigurationManager_v1>::~shared_ptr[abi:ne180100], &AdobeXMPCore_Int::ManageCoreConfigurationManager(BOOL)::sCoreConfigurationManager, &dword_188589000);
      LODWORD(this) = v7;
    }
  }
  if (this)
  {
    uint64_t v3 = (std::__shared_weak_count *)qword_1EB2C0318;
    AdobeXMPCore_Int::ManageCoreConfigurationManager(BOOL)::sCoreConfigurationManager = 0;
    qword_1EB2C0318 = 0;
    if (!v3)
    {
      *a2 = 0;
      a2[1] = 0;
      return;
    }
    std::__shared_weak_count::__release_shared[abi:ne180100](v3);
  }
  else if (!AdobeXMPCore_Int::ManageCoreConfigurationManager(BOOL)::sCoreConfigurationManager)
  {
    BOOL v4 = (AdobeXMPCore_Int::CoreConfigurationManagerImpl *)AdobeXMPCore_Int::MemoryManagedObject::operator new((AdobeXMPCore_Int::MemoryManagedObject *)0x38);
    uint64_t v5 = (char *)AdobeXMPCore_Int::CoreConfigurationManagerImpl::CoreConfigurationManagerImpl(v4);
    AdobeXMPCore_Int::MakeUncheckedSharedPointer<AdobeXMPCore_Int::CoreConfigurationManagerImpl>(v5, 1, &v9);
  }
  uint64_t v6 = qword_1EB2C0318;
  *a2 = AdobeXMPCore_Int::ManageCoreConfigurationManager(BOOL)::sCoreConfigurationManager;
  a2[1] = v6;
  if (v6) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v6 + 8), 1uLL, memory_order_relaxed);
  }
}

void ASTCTextureImp::createTwiddledDataFromLinear(ASTCTextureImp *this, IIOImageReadSession *a2, uint64_t a3)
{
  if (*((_DWORD *)this + 58))
  {
    *((void *)this + 10) = 0;
    return;
  }
  ASTCTextureImp::createTwiddler((uint64_t)this);
  uint64_t v6 = (ASTCTwiddler *)*((void *)this + 30);
  if (v6)
  {
    if (ASTCTwiddler::finalized(v6))
    {
      if (a3)
      {
LABEL_8:
        *((void *)this + 10) = ASTCTwiddler::twiddledData(*((ASTCTwiddler **)this + 30));
        uint64_t v7 = ASTCTwiddler::twiddledDataSize(*((ASTCTwiddler **)this + 30));
        *((void *)this + 18) = v7;
        *((void *)this + 19) = 0;
        *((void *)this + 20) = v7;
        *((_DWORD *)this + 58) = 0;
        return;
      }
LABEL_7:
      ASTCTwiddler::finalizeTwiddling(*((ASTCTwiddler **)this + 30));
      goto LABEL_8;
    }
    if (!*((void *)this + 15))
    {
      uint64_t v11 = IIOImageReadSession::retainBytePointer(a2, (const __CFData **)this + 16, 1);
      *((void *)this + 15) = v11;
      if (!v11) {
        goto LABEL_19;
      }
      if (IIOImageSource::cf(a2))
      {
        CFTypeID v12 = (const void *)IIOImageSource::cf(a2);
        *((void *)this + 17) = v12;
        CFRetain(v12);
      }
      if (!*((void *)this + 15))
      {
LABEL_19:
        _cg_jpeg_mem_term("createTwiddledDataFromLinear", 832, "*** Can't access image data\n");
        goto LABEL_26;
      }
    }
    if (!*((void *)this + 14))
    {
      LogError("createTwiddledDataFromLinear", 801, "*** ERROR: _imp._textureBaseOffset is zero - that's wrong (should be the offset to the ASTC data).\n");
      goto LABEL_26;
    }
    unsigned int Size = IIOImageReadSession::getSize(a2);
    int v9 = *((_DWORD *)this + 7);
    if (v9 == 8)
    {
      if (*((_DWORD *)this + 8) == 8)
      {
        unsigned int v10 = (*((_DWORD *)this + 26) * *((_DWORD *)this + 25)) >> 2;
        goto LABEL_24;
      }
    }
    else if (v9 == 4 && *((_DWORD *)this + 8) == 4)
    {
      unsigned int v10 = *((_DWORD *)this + 26) * *((_DWORD *)this + 25);
LABEL_24:
      uint64_t v13 = *((void *)this + 14);
      if (v13 + (unint64_t)v10 <= Size)
      {
        ASTCTwiddler::copyFromLinearData(*((ASTCTwiddler **)this + 30), *((const void **)this + 15), v13, Size, (16 * *((_DWORD *)this + 5)), *((_DWORD *)this + 4));
        if (a3) {
          goto LABEL_8;
        }
        goto LABEL_7;
      }
      LogError("createTwiddledDataFromLinear", 823, "*** Can't access image data [%ld/%ld] (%dx%d)\n");
LABEL_26:
      *((void *)this + 10) = 0;
      *((_DWORD *)this + 58) = -50;
      return;
    }
    unsigned int v10 = 0;
    goto LABEL_24;
  }
}

void ASTCTextureImp::createTwiddledDataFromLinearLZFSE(ASTCTextureImp *this, IIOImageReadSession *a2, uint64_t a3)
{
  ASTCTextureImp::createTwiddler((uint64_t)this);
  uint64_t v6 = (ASTCTwiddler *)*((void *)this + 30);
  if (v6)
  {
    if (!ASTCTwiddler::finalized(v6))
    {
      if (!*((void *)this + 15))
      {
        *((void *)this + 15) = IIOImageReadSession::retainBytePointer(a2, (const __CFData **)this + 16, 1);
        uint64_t v7 = (const void *)IIOImageSource::cf(a2);
        *((void *)this + 17) = v7;
        CFRetain(v7);
        if (!*((void *)this + 15))
        {
          _cg_jpeg_mem_term("createTwiddledDataFromLinearLZFSE", 911, "*** ImageIO - can't access image data\n");
          goto LABEL_19;
        }
      }
      unsigned int Size = IIOImageReadSession::getSize(a2);
      uint64_t v9 = *((void *)this + 6);
      size_t v10 = *((unsigned int *)this + 11);
      if (v9 + v10 > Size)
      {
        LogError("createTwiddledDataFromLinearLZFSE", 881, "*** ImageIO - bad LZFSE data - (fileSize: %ld   compressedDataOffset: %ld   compressedSize: %ld)\n");
LABEL_19:
        *((void *)this + 10) = 0;
        int v14 = -50;
        goto LABEL_20;
      }
      uint64_t v11 = (unsigned __int8 *)(*((void *)this + 15) + v9);
      if (v10 >= 9 && (*(_DWORD *)v11 != 846755426 || *(_DWORD *)&v11[v10 - 4] != 611874402))
      {
        LogError("createTwiddledDataFromLinearLZFSE", 900, "*** ImageIO - bad LZFSE data - no start/end marker\n");
        goto LABEL_19;
      }
      ASTCTwiddler::decodeAndCopyFromLinearData(*((ASTCTwiddler **)this + 30), v11, v10, (16 * *((_DWORD *)this + 5)), *((_DWORD *)this + 4));
    }
    uint64_t v6 = (ASTCTwiddler *)*((void *)this + 30);
    if (!a3)
    {
      ASTCTwiddler::finalizeTwiddling(v6);
      uint64_t v6 = (ASTCTwiddler *)*((void *)this + 30);
    }
  }
  *((void *)this + 10) = ASTCTwiddler::twiddledData(v6);
  uint64_t v13 = ASTCTwiddler::twiddledDataSize(*((ASTCTwiddler **)this + 30));
  int v14 = 0;
  *((void *)this + 18) = v13;
  *((void *)this + 19) = 0;
  *((void *)this + 20) = v13;
LABEL_20:
  *((_DWORD *)this + 58) = v14;
}

const char *ASTCTwiddler::ASTCTwiddlerImpl::finalizeTwiddlingImp(const char *this)
{
  if (!this[64])
  {
    uint64_t v1 = (uint64_t)this;
    if (*((void *)this + 5))
    {
      objc_msgSend(*((id *)this + 7), "finalizeTextureMemory:");
      this = ImageIO_make_read_only(*(void *)(v1 + 40), *(void *)(v1 + 48));
    }
    *(unsigned char *)(v1 + 64) = 1;
  }
  return this;
}

void ASTCTwiddler::ASTCTwiddler(ASTCTwiddler *this, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5, int a6)
{
  *(void *)this = &unk_1ED4DEFA8;
  *((void *)this + 1) = 0;
  id v11 = MTLCreateSystemDefaultDevice();
  if (v11)
  {
    CFTypeID v12 = (void *)MEMORY[0x18C11CF40]();
    uint64_t v13 = (void *)[MEMORY[0x1E4F35338] texture2DDescriptorWithPixelFormat:a2 width:a3 height:a4 mipmapped:a5 > 1];
    [v13 setMipmapLevelCount:a5];
    int v14 = (void *)[v11 newTextureLayoutWithDescriptor:v13 isHeapOrBufferBacked:0];
    memory_object_size_t v17 = 0;
    if (!a6) {
      goto LABEL_6;
    }
    memory_object_size_t v15 = [v14 size];
    unint64_t v16 = [v14 alignment];
    if (v16) {
      memory_object_size_t v15 = (v16 + v15 - 1) / v16 * v16;
    }
    if (_ImageIO_Malloc(v15, v16, &v17, (uint64_t)kImageMalloc_ASTC_Data[0], 0, 0, 0)) {
LABEL_6:
    }
      operator new();
  }
}

void sub_1885D2368(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void *)(v1 + 8);
  *(void *)(v1 + 8) = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  _Unwind_Resume(exception_object);
}

void *IIOTextureHandler::IIOTextureHandler(void *a1, CFTypeRef cf)
{
  a1[3] = cf;
  a1[4] = 0;
  a1[6] = 0;
  *a1 = &unk_1ED4E4110;
  a1[1] = 0;
  a1[2] = 0;
  if (cf)
  {
    CFRetain(cf);
    a1[4] = CGImageSourceGetSource(a1[3]);
    uint64_t v3 = CGImageReadSessionCreate(a1[3]);
    a1[5] = v3;
    uint64_t Source = (IIOImageRead **)CGImageSourceGetSource(v3);
    a1[6] = Source;
    IIOImageReadSession::mapData(Source);
  }
  return a1;
}

void sub_1885D2454(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(std::__shared_weak_count **)(v1 + 16);
  if (v3) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t AppleJPEGReadPlugin::createImageBlockFromIOSurface(uint64_t a1, __IOSurface *a2, const void *a3, uint64_t a4)
{
  v47[0] = 0;
  vImagePixelCount v8 = *(unsigned int *)(a1 + 292);
  vImagePixelCount v9 = *(unsigned int *)(a1 + 296);
  size_t v10 = *(unsigned int *)(a1 + 300);
  int v46 = 197121;
  int v45 = 66051;
  int v11 = *(unsigned __int8 *)(a1 + 405);
  *(_DWORD *)(a1 + 104) = 1;
  IIOReadPlugin::allocateBlockArray((IIOReadPlugin *)a1, 1uLL);
  uint64_t v12 = 0;
  if (IOSurfaceLock(a2, 1u, 0)) {
    return v12;
  }
  CGImageMetadataTagRef v40 = a3;
  Planeuint64_t Count = IOSurfaceGetPlaneCount(a2);
  __dst = (char *)_ImageIO_Malloc(v10 * (unint64_t)v9, *(void *)(a1 + 384), v47, (uint64_t)kImageMalloc_APPLEJPEG_Data[0], *(_DWORD *)(a1 + 432), 0, 0);
  if (__dst)
  {
    int v37 = v11;
    uint64_t v38 = a4;
    BaseAddressOfPlane = (char *)IOSurfaceGetBaseAddressOfPlane(a2, 0);
    vImagePixelCount HeightOfPlane = IOSurfaceGetHeightOfPlane(a2, 0);
    vImagePixelCount WidthOfPlane = IOSurfaceGetWidthOfPlane(a2, 0);
    size_t BytesPerRowOfPlane = IOSurfaceGetBytesPerRowOfPlane(a2, 0);
    size_t v18 = BytesPerRowOfPlane;
    if (PlaneCount < 2)
    {
      if (HeightOfPlane == v9 && WidthOfPlane == v8)
      {
        CFTypeID v19 = __dst;
        if (BytesPerRowOfPlane == v10)
        {
          memcpy(__dst, BaseAddressOfPlane, v10 * (unint64_t)v9);
        }
        else
        {
          if (BytesPerRowOfPlane >= v10) {
            size_t v26 = v10;
          }
          else {
            size_t v26 = BytesPerRowOfPlane;
          }
          if (v9)
          {
            CFNumberType v27 = __dst;
            do
            {
              memcpy(v27, BaseAddressOfPlane, v26);
              BaseAddressOfPlane += v18;
              v27 += v10;
              LODWORD(v9) = v9 - 1;
            }
            while (v9);
          }
        }
      }
      else
      {
        srcYp.std::string::pointer data = BaseAddressOfPlane;
        srcYp.double height = HeightOfPlane;
        srcYp.double width = WidthOfPlane;
        srcYp.rowuint64_t Bytes = BytesPerRowOfPlane;
        CFTypeID v19 = __dst;
        srcCbCr.std::string::pointer data = __dst;
        srcCbCr.double height = v9;
        srcCbCr.double width = v8;
        srcCbCr.rowuint64_t Bytes = v10;
        int v25 = *(_DWORD *)(a1 + 324);
        if (v25 == 1196573017)
        {
          vImageScale_Planar8(&srcYp, &srcCbCr, 0, 0);
        }
        else if (v25 == 1380401696)
        {
          vImageScale_ARGB8888(&srcYp, &srcCbCr, 0, 0);
        }
      }
    }
    else
    {
      srcYp.std::string::pointer data = BaseAddressOfPlane;
      srcYp.double height = HeightOfPlane;
      srcYp.double width = WidthOfPlane;
      srcYp.rowuint64_t Bytes = BytesPerRowOfPlane;
      srcCbCr.std::string::pointer data = IOSurfaceGetBaseAddressOfPlane(a2, 1uLL);
      srcCbCr.double height = IOSurfaceGetHeightOfPlane(a2, 1uLL);
      srcCbCr.double width = IOSurfaceGetWidthOfPlane(a2, 1uLL);
      srcCbCr.rowuint64_t Bytes = IOSurfaceGetBytesPerRowOfPlane(a2, 1uLL);
      dest.double width = v8;
      dest.rowuint64_t Bytes = v10;
      CFTypeID v19 = __dst;
      dest.std::string::pointer data = __dst;
      dest.double height = v9;
      if (AppleJPEGReadPlugin::createImageBlockFromIOSurface(__IOSurface *,InfoRec *,CGImageProvider *)::YpCbCrToARGBCreate != -1) {
        dispatch_once(&AppleJPEGReadPlugin::createImageBlockFromIOSurface(__IOSurface *,InfoRec *,CGImageProvider *)::YpCbCrToARGBCreate, &__block_literal_global_179);
      }
      if (v37) {
        CFStringRef v20 = &v46;
      }
      else {
        CFStringRef v20 = &v45;
      }
      vImage_Error v21 = vImageConvert_420Yp8_CbCr8ToARGB8888(&srcYp, &srcCbCr, &dest, &AppleJPEGReadPlugin::createImageBlockFromIOSurface(__IOSurface *,InfoRec *,CGImageProvider *)::conversion, (const uint8_t *)v20, 0xFFu, 0);
      if (v21)
      {
        vImage_Error v22 = v21;
        double v23 = IIO_vImageErrorString(v21);
        _cg_jpeg_mem_term("createImageBlockFromIOSurface", 4070, "*** ERROR: vImageConvert_420Yp8_CbCr8ToARGB8888 returned %ld (%s)\n", v22, v23);
        a4 = v38;
        CFAllocatorRef v24 = a3;
LABEL_31:
        uint64_t v12 = 0;
        if (a4)
        {
          unint64_t v35 = *(unsigned int *)(a1 + 104);
          if (v35) {
            uint64_t v12 = IIOReadPlugin::imageBlockSetCreate(a1, a4, v35, *(double *)(a1 + 136), *(double *)(a1 + 144), *(double *)(a1 + 120), *(double *)(a1 + 128), *(double *)(a1 + 136), *(double *)(a1 + 144), *(void *)(a1 + 96), v24);
          }
        }
        IOSurfaceUnlock(a2, 1u, 0);
        if (v19) {
          _ImageIO_Free((unint64_t)v19, v47[0]);
        }
        goto LABEL_36;
      }
    }
    LODWORD(v17) = *(_DWORD *)(a1 + 292);
    double v28 = (double)v17;
    LODWORD(v17) = *(_DWORD *)(a1 + 296);
    double v29 = (double)v17;
    uint64_t v30 = 0;
    v48.origin.double x = 0.0;
    v48.origin.double y = 0.0;
    v48.size.double width = v28;
    v48.size.double height = v29;
    **(void **)(a1 + 96) = IIOReadPlugin::createImageBlock((IIOReadPlugin *)a1, v19, v47[0], v48, *(unsigned int *)(a1 + 300), *(unsigned __int8 *)(a1 + 343));
    if (CGRectEqualToRect(*(CGRect *)(a1 + 120), *MEMORY[0x1E4F1DB20]))
    {
      uint64_t v31 = 0;
    }
    else
    {
      v49.origin.double x = 0.0;
      v49.origin.double y = 0.0;
      v49.size.double width = v28;
      v49.size.double height = v29;
      *(CGRect *)(&v31 - 1) = CGRectUnion(*(CGRect *)(a1 + 120), v49);
      uint64_t v30 = v32;
      double v28 = v33;
      double v29 = v34;
    }
    a4 = v38;
    CFAllocatorRef v24 = v40;
    CFTypeID v19 = 0;
    *(void *)(a1 + 120) = v30;
    *(void *)(a1 + 128) = v31;
    *(double *)(a1 + 136) = v28;
    *(double *)(a1 + 144) = v29;
    goto LABEL_31;
  }
  uint64_t v12 = 0;
LABEL_36:
  if (a4) {
    IIOReadPlugin::freeBlockArray((IIOReadPlugin *)a1);
  }
  return v12;
}

uint64_t PNGReadPlugin::copyImageBlockSetStandard(uint64_t a1, const void *a2, const void *a3, double a4, double a5, double a6, double a7)
{
  uint64_t v12 = a3;
  memory_object_size_t v71 = 0;
  unsigned int v14 = *(unsigned __int16 *)(a1 + 316);
  if (*(unsigned char *)(a1 + 406) == 1)
  {
    uint64_t v15 = *MEMORY[0x1E4F1CFD0];
    uint64_t Property = CGImageProviderGetProperty();
    uint64_t v12 = a3;
    if (v15 == Property) {
      return 0;
    }
  }
  if (!*(unsigned char *)(a1 + 414)) {
    return 0;
  }
  BOOL v33 = !*(unsigned char *)(a1 + 498)
     && (v14 <= 1 ? (BOOL v18 = *(void *)(a1 + 488) == 0) : (BOOL v18 = 1), !v18)
     && *(unsigned char *)(a1 + 341) != 0;
  CFTypeID v19 = v12;
  CGImageProviderSetProperty();
  if (*(unsigned char *)(a1 + 181))
  {
    ImageIOLog(">>> copyImageBlockSetPNG   info: %p\n", a2);
    ImageIOLog("                       provider: %p\n", v19);
    ImageIOLog("                        session: %p\n", *(const void **)(a1 + 24));
    ImageIOLog("                     sourceRect: (%5g, %5g, %5g, %5g)\n", a4, a5, a6, a7);
  }
  uint64_t v63 = (uint64_t)v19;
  size_t v20 = *(unsigned int *)(a1 + 104);
  if (!v20 || v33 && (v20 != 1 || *(_DWORD *)(a1 + 296) != *(_DWORD *)(a1 + 232))) {
    return 0;
  }
  uint64_t v21 = *(unsigned int *)(a1 + 112);
  if (*(unsigned char *)(a1 + 181))
  {
    ImageIOLog("                  imageRowBytes: %6d\n", *(_DWORD *)(a1 + 300));
    ImageIOLog("               bitsPerComponent: %6d\n", *(unsigned __int16 *)(a1 + 240));
    ImageIOLog("                 isLittleEndian: %6d\n", *(unsigned __int8 *)(a1 + 344));
    ImageIOLog("                    blockHeight: %6d\n", *(_DWORD *)(a1 + 296));
    ImageIOLog("                     blockCount: %6d\n", *(_DWORD *)(a1 + 104));
    ImageIOLog("                     startBlock: %6d\n", *(_DWORD *)(a1 + 112));
    ImageIOLog("                       endBlock: %6d\n", *(_DWORD *)(a1 + 116));
    size_t v20 = *(unsigned int *)(a1 + 104);
  }
  IIOReadPlugin::allocateBlockArray((IIOReadPlugin *)a1, v20);
  int CachedBlocks = IIOReadPlugin::getCachedBlocks((IIOReadPlugin *)a1, v22, v23, v24);
  int v27 = CachedBlocks;
  if ((gIIODebugFlags & 0x30000) != 0) {
    ImageIOLog("     numberOfBlocksLeftToDecode: %d\n", CachedBlocks);
  }
  if (!v27)
  {
    LOBYTE(v64) = 0;
    goto LABEL_47;
  }
  double v28 = *(IIOImageRead ***)(a1 + 24);
  if (v28)
  {
    BOOL v64 = IIOImageReadSession::mapData(v28);
    double v29 = *(IIOImageReadSession **)(a1 + 24);
    if (v29)
    {
      unint64_t v30 = *(void *)(a1 + 192);
      uint64_t v31 = v21;
      if (v30) {
        IIOImageReadSession::seek(v29, v30, 0);
      }
      else {
        IIOImageReadSession::rewind((uint64_t)v29);
      }
    }
    else
    {
      uint64_t v31 = v21;
    }
  }
  else
  {
    uint64_t v31 = v21;
    BOOL v64 = 0;
  }
  uint64_t v34 = *(unsigned int *)(a1 + 112);
  if (v34 >= *(_DWORD *)(a1 + 116))
  {
LABEL_47:
    double v55 = *(double *)(a1 + 120);
    double v56 = *(double *)(a1 + 128);
    double v57 = *(double *)(a1 + 144);
    if (v57 == 0.0)
    {
      _cg_jpeg_mem_term("copyImageBlockSetStandard", 3182, ": pngCreateBlockSet - error while decoding PNG image rect: (%5g, %5g, %5g, %5g)\n", v55, v56, *(double *)(a1 + 136), v57);
    }
    else if (v63)
    {
      unint64_t v58 = *(unsigned int *)(a1 + 104);
      if (v58)
      {
        uint64_t v32 = IIOReadPlugin::imageBlockSetCreate(a1, v63, v58, *(double *)(a1 + 136), v57, v55, v56, *(double *)(a1 + 136), *(double *)(a1 + 144), *(void *)(a1 + 96), a2);
        goto LABEL_66;
      }
    }
LABEL_65:
    uint64_t v32 = 0;
LABEL_66:
    if (v64)
    {
LABEL_67:
      uint64_t v60 = *(const char ***)(a1 + 24);
      if (v60) {
        IIOImageReadSession::unmapData(v60);
      }
    }
    return v32;
  }
  uint64_t v62 = v31;
  uint64_t v35 = -8 * v31;
  uint64_t v36 = -v31;
  int v37 = (CGRect *)MEMORY[0x1E4F1DB20];
  while (1)
  {
    if (*(void *)(*(void *)(a1 + 96) + v35 + 8 * v34)) {
      _cg_jpeg_mem_term("copyImageBlockSetStandard", 3103, "*** _blockArray[%d] was cached - and already allocated\n", v36 + v34);
    }
    uint64_t v38 = *(unsigned int *)(a1 + 296);
    double v39 = (double)(unint64_t)(v34 * v38);
    LODWORD(v7) = *(_DWORD *)(a1 + 292);
    LODWORD(v26) = *(_DWORD *)(a1 + 232);
    double v40 = (double)v26;
    double v41 = (double)v38 + v39 <= v40 ? (double)v38 : v40 - v39;
    memory_object_size_t v42 = *(unsigned int *)(a1 + 300) * (unint64_t)v38;
    int64_t v43 = _ImageIO_Malloc(v42, *(void *)(a1 + 384), &v71, (uint64_t)kImageMalloc_PNG_Data[0], *(_DWORD *)(a1 + 432), 0, 0);
    if (!v43) {
      break;
    }
    CFStringRef v44 = (unsigned __int8 *)v43;
    uint64_t v45 = *(void *)(a1 + 384);
    if (v45 && v43 % v45) {
      goto LABEL_64;
    }
    bzero((void *)v43, v42);
    if ((gIIODebugFlags & 0x30000) != 0) {
      ImageIOLog("                   reading rows: %d ... %d\n", (unint64_t)v39, (unint64_t)(v41 + v39));
    }
    double v7 = (double)*(unint64_t *)&v7;
    uint64_t v46 = *(unsigned int *)(a1 + 300);
    v68[0] = v34;
    v68[1] = 0;
    *(double *)&v68[2] = v39;
    *(double *)&v68[3] = v7;
    *(double *)&v68[4] = v41;
    v68[5] = v44;
    v68[6] = v46;
    v68[7] = v42;
    long long v69 = 0u;
    uint64_t v70 = 0;
    uint64_t v67 = 0;
    long long v66 = 0u;
    std::vector<IIODecodeFrameParams>::vector(&v66, 1uLL, (uint64_t)v68);
    CFStringRef v47 = (IIOImageRead *)IIO_Reader::testHeaderSize(*(IIO_Reader **)(a1 + 24));
    PNGReadPlugin::DecodeUncomposedFrames(v47, 0, a1 + 184, (unsigned char *)(a1 + 440), (uint64_t **)&v66);
    unint64_t v48 = *(void *)(v66 + 64);
    double v49 = (double)v48;
    if (v41 != (double)v48)
    {
      _cg_jpeg_mem_term("copyImageBlockSetStandard", 3149, "*** ERROR: incomplete decode - got %d of %g rows\n", v48, v41);
      v72[0] = (void **)&v66;
      std::vector<IIODecodeFrameParams>::__destroy_vector::operator()[abi:ne180100](v72);
      IIODecodeFrameParams::~IIODecodeFrameParams((IIODecodeFrameParams *)v68);
      breakOnPngError();
      if (*(unsigned char *)(a1 + 181))
      {
        ImageIOLog("    got a PNG error  (success = %d)  sourceRect: (%5g, %5g, %5g, %5g)\n", 0, a4, a5, a6, a7);
        ImageIOLog("                    imageunint64_t Data = %p [%zu]\n", v44, (*(_DWORD *)(a1 + 300) * *(_DWORD *)(a1 + 296)));
        ImageIOLog("                    blockLoop = %ld\n", v34);
        ImageIOLog("                  _blockEnd-1 = %ld\n", *(unsigned int *)(a1 + 116) - 1);
        ImageIOLog("                          row = %ld\n", 0);
        ImageIOLog("                       endRow = %ld\n", (unint64_t)(v41 + v39));
        ImageIOLog("                    rowsValid = %ld\n", 0);
        ImageIOLog("               blockRowsValid = %ld\n", v48);
        ImageIOLog("                    blockRect = {%5g, %5g, %5g, %5g}\n", 0.0, v39, v7, v41);
      }
      if (v48 && v41 > v49)
      {
        if ((IIOImageReadSession::isFinal(*(IIOImageReadSession **)(a1 + 24)) & (v41 - v49 > 2.0)) != 0) {
          double v59 = (double)v48;
        }
        else {
          double v59 = v41;
        }
        if (v59 != 0.0)
        {
          PNGReadPlugin::postProcess((PNGReadPlugin *)a1, v44);
          v74.origin.double x = 0.0;
          v74.origin.double y = v39;
          v74.size.double width = v7;
          v74.size.double height = v59;
          *(void *)(*(void *)(a1 + 96) - 8 * v62 + 8 * v34) = IIOReadPlugin::createImageBlock((IIOReadPlugin *)a1, v44, v71, v74, *(unsigned int *)(a1 + 300), 0);
          v75.origin.double x = 0.0;
          v75.origin.double y = v39;
          v75.size.double width = v7;
          v75.size.double height = v59;
          AddSubRect((CGRect *)(a1 + 120), v75);
          goto LABEL_47;
        }
        _cg_jpeg_mem_term("copyImageBlockSetStandard", 3239, ": error while decoding PNG image rect: (%5g, %5g, %5g, %5g)\n", 0.0, v39, v7, v59);
      }
LABEL_64:
      _ImageIO_Free((unint64_t)v44, v71);
      goto LABEL_65;
    }
    PNGReadPlugin::postProcess((PNGReadPlugin *)a1, v44);
    v73.origin.double x = 0.0;
    v73.origin.double y = v39;
    v73.size.double width = v7;
    v73.size.double height = v41;
    *(void *)(*(void *)(a1 + 96) + v35 + 8 * v34) = IIOReadPlugin::createImageBlock((IIOReadPlugin *)a1, v44, v71, v73, *(unsigned int *)(a1 + 300), *(unsigned __int8 *)(a1 + 343));
    BOOL v50 = CGRectEqualToRect(*(CGRect *)(a1 + 120), *v37);
    uint64_t v51 = 0;
    if (!v50)
    {
      v76.origin.double x = 0.0;
      v76.origin.double y = v39;
      v76.size.double width = v7;
      v76.size.double height = v41;
      *(CGRect *)&uint64_t v51 = CGRectUnion(*(CGRect *)(a1 + 120), v76);
      double v39 = v52;
      double v7 = v53;
      double v41 = v54;
    }
    *(void *)(a1 + 120) = v51;
    *(double *)(a1 + 128) = v39;
    *(double *)(a1 + 136) = v7;
    *(double *)(a1 + 144) = v41;
    v72[0] = (void **)&v66;
    std::vector<IIODecodeFrameParams>::__destroy_vector::operator()[abi:ne180100](v72);
    IIODecodeFrameParams::~IIODecodeFrameParams((IIODecodeFrameParams *)v68);
    if (++v34 >= (unint64_t)*(unsigned int *)(a1 + 116)) {
      goto LABEL_47;
    }
  }
  uint64_t v32 = 0;
  if (v64) {
    goto LABEL_67;
  }
  return v32;
}

void sub_1885D300C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, ...)
{
  va_start(va1, a12);
  va_start(va, a12);
  uint64_t v14 = va_arg(va1, void);
  uint64_t v16 = va_arg(va1, void);
  uint64_t v17 = va_arg(va1, void);
  *(void *)(v12 - 160) = va;
  std::vector<IIODecodeFrameParams>::__destroy_vector::operator()[abi:ne180100]((void ***)(v12 - 160));
  IIODecodeFrameParams::~IIODecodeFrameParams((IIODecodeFrameParams *)va1);
  _Unwind_Resume(a1);
}

uint64_t IIOReadPlugin::allocateBlockArray(IIOReadPlugin *this, size_t size)
{
  unsigned int v2 = size;
  BOOL v4 = (void *)*((void *)this + 12);
  if (v4) {
    free(v4);
  }
  *((void *)this + 12) = 0;
  int v5 = *((_DWORD *)this + 26);
  if (v5 != v2 || v5 == 0) {
    return 4294967246;
  }
  double v7 = malloc_type_calloc(8uLL, v2, 0xEBE978FFuLL);
  uint64_t result = 0;
  *((void *)this + 12) = v7;
  return result;
}

BOOL IIOImageReadSession::mapData(IIOImageRead **this)
{
  return IIOImageRead::mapData(this[4]);
}

BOOL IIOImageRead::mapData(IIOImageRead *this)
{
  BOOL v12 = 0;
  int v11 = 0;
  if ((gIIODebugFlags & 0x100000000000) != 0) {
    ImageIOLog("    %s:   <IIOImageRead: %p> mmapping data    <CFData:%p>  count: %d\n", "mapData", this, *((const void **)this + 4), *((_DWORD *)this + 110));
  }
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 376));
  if (*((unsigned char *)this + 67))
  {
    if (*((void *)this + 4))
    {
      IIOImageRead::validateFileSize(this);
    }
    else
    {
      CFDataRef v2 = IIOImageRead::createDataWithMappedFile(this, &v12, &v11);
      *((void *)this + 4) = v2;
      if ((gIIODebugFlags & 0x80000000000) == 0) {
        goto LABEL_9;
      }
      ImageIOLog("D   %s:%d createDataWithMappedFile %p\n", "mapData", 954, v2);
    }
    CFDataRef v2 = (const __CFData *)*((void *)this + 4);
LABEL_9:
    if (v2)
    {
      uint64_t v3 = *((void *)this + 10);
      CFIndex Length = CFDataGetLength(v2);
      CFDataRef v5 = (const __CFData *)*((void *)this + 4);
      if (v3 != Length)
      {
        uint64_t v6 = *((void *)this + 10);
        CFIndex v7 = CFDataGetLength(v5);
        LogFault("mapData", 962, "*** ImageIO - mmapped file changed (old: %ld  new: %ld)\n", v6, v7);
        *((void *)this + 10) = CFDataGetLength(*((CFDataRef *)this + 4));
        CFDataRef v5 = (const __CFData *)*((void *)this + 4);
      }
      if (v5)
      {
        int v8 = *((_DWORD *)this + 110) + 1;
        *((_DWORD *)this + 110) = v8;
        if ((gIIODebugFlags & 0x100000000000) != 0)
        {
          CFIndex v9 = CFGetRetainCount(v5);
          ImageIOLog("    %s:                  new count: %d   (rc=%ld)\n", "mapData", v8, v9);
        }
      }
    }
  }
  pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 376));
  return v12;
}

uint64_t IIOReadPlugin::imageBlockSetCreate(uint64_t a1, uint64_t a2, unint64_t a3, double a4, double a5, double a6, double a7, double a8, double a9, uint64_t a10, const void *a11)
{
  if (a9 != a5) {
    _cg_jpeg_mem_term("imageBlockSetCreate", 2089, "*** buffer height mismatch: rect:{%g,%g,%g,%g}  size:{%g,%g}\n", a6, a7, a8, a9, a4, a5);
  }
  if (a8 != a4) {
    _cg_jpeg_mem_term("imageBlockSetCreate", 2091, "*** buffer width mismatch: rect:{%g,%g,%g,%g}  size:{%g,%g}\n", a6, a7, a8, a9, a4, a5);
  }
  uint64_t v21 = CGImageBlockSetCreate();
  if (!(a2 | v21)) {
    LogError("imageBlockSetCreate", 2096, "*** ERROR: CGImageBlockSetCreate returned NULL - called with NULL provider\n");
  }
  uint64_t v22 = gIIODebugFlags;
  if ((gIIODebugFlags & 0xC00) != 0 || *(unsigned char *)(a1 + 181))
  {
    atomic_fetch_add_explicit(&gBlockSetCount, 1u, memory_order_relaxed);
    uint64_t v23 = 115;
    if (a3 == 1) {
      uint64_t v23 = 32;
    }
    ImageIOLog("    CGImageBlockSetCreate:    %14p - info: %14p                        S-[%2ld] %2ld block%c\n", (const void *)v21, a11, gBlockSetCount, a3, v23);
    uint64_t v22 = gIIODebugFlags;
    if ((gIIODebugFlags & 0x800) != 0)
    {
      IIODebug_ShowBacktrace(2);
      uint64_t v22 = gIIODebugFlags;
    }
  }
  if ((v22 & 0x40000000000) != 0) {
    IIOReadPlugin::debugBlockSetAlpha(a1, a2, a3);
  }
  if (!v21) {
    _cg_jpeg_mem_term("imageBlockSetCreate", 2113, "*** CGImageBlockSetCreate returned nil rect:{%g,%g,%g,%g}  size:{%g,%g}\n", a6, a7, a8, a9, a4, a5);
  }
  return v21;
}

uint64_t IIOImageReadSession::rewind(uint64_t this)
{
  *(void *)(this + 40) = 0;
  return this;
}

const void *IIOReadPlugin::createImageBlock(IIOReadPlugin *this, void *a2, mach_vm_size_t a3, CGRect a4, unint64_t a5, int a6)
{
  double height = a4.size.height;
  double width = a4.size.width;
  double y = a4.origin.y;
  double x = a4.origin.x;
  if (!*((unsigned char *)this + 353) && IIOReadPlugin::readOnlyRequested(this)) {
    ImageIO_make_read_only((mach_vm_address_t)a2, a3);
  }
  if (!a3 || (*((unsigned char *)this + 341) ? (BOOL v15 = a6 == 0) : (BOOL v15 = 1), v15))
  {
LABEL_13:
    if (a2) {
      goto LABEL_14;
    }
LABEL_28:
    LogError("createImageBlock", 2741, "*** ERROR: CGImageBlockCreate {%g, %g, %g, %g} - data is NULL\n");
    return 0;
  }
  if (*((_DWORD *)this + 73) > 0xFu || *((_DWORD *)this + 74) >= 0x10u || *((void *)this + 52) >= 5uLL)
  {
    memset(v21, 0, 44);
    IIOReadPlugin::updateImageIOCacheKey((uint64_t)this, (uint64_t)v21, a5, x, y, width, height);
    DWORD2(v21[2]) = a3;
    IIOImageRead::setCachedImageBlockData(*((void *)this + 4), v21, a2, a3);
    goto LABEL_13;
  }
  if (!a2) {
    goto LABEL_28;
  }
LABEL_14:
  if (!a5)
  {
    LogError("createImageBlock", 2742, "*** ERROR: CGImageBlockCreate {%g, %g, %g, %g} - bytesPerRow is zero\n");
    return 0;
  }
  if (!a3)
  {
    uint64_t v17 = (const void *)IOMemorySizeLookup((uint64_t)a2);
    uint64_t v16 = "cached";
    goto LABEL_19;
  }
  if (height * (double)a5 > (double)a3)
  {
    LogError("createImageBlock", 2746, "*** ERROR: CGImageBlockCreate dataSize too small: %ld < %lld\n");
    return 0;
  }
  uint64_t v16 = "";
  uint64_t v17 = (const void *)a3;
LABEL_19:
  if ((gIIODebugFlags & 0x4000000000) != 0)
  {
    int v18 = IIOHashForBuffer(a2, a3, 0);
    ImageIOLog("# hash {%g,%g,%g,%g} rb: %d   ptr: %p   size: %ld  '%016x'\n", x, y, width, height, a5, a2, a3, v18);
  }
  CFTypeID v19 = (const void *)CGImageBlockCreate();
  if ((gIIODebugFlags & 0xC00) != 0)
  {
    atomic_fetch_add_explicit(&gBlockCount, 1u, memory_order_relaxed);
    ImageIOLog("    CGImageBlockCreate:       %14p - info: %14p  data: %14p  B-[%2ld]  rb: %8ld  r:(%4g,%4g,%4g,%4g) %s\n", v19, v17, a2, gBlockCount, a5, x, y, width, height, v16);
    if ((gIIODebugFlags & 0x800) != 0) {
      IIODebug_ShowBacktrace(2);
    }
  }
  if (*((unsigned char *)this + 180)) {
    IIOReadPlugin::debugWriteImageBlocks(this, a2, *((unsigned int *)this + 74), ++IIOReadPlugin::createImageBlock(void *,unsigned long,CGRect,unsigned long,BOOL)::uniqueBlockID, width, height, *((unsigned int *)this + 75), *((unsigned __int16 *)this + 152), (*((unsigned __int8 *)this + 311) << 12) | (*((unsigned __int8 *)this + 312) << 16) | ((*((unsigned char *)this + 313) != 0) << 8) | *((unsigned __int8 *)this + 310));
  }
  return v19;
}

BOOL IIOReadPlugin::readOnlyRequested(IIOReadPlugin *this)
{
  BOOL result = *((unsigned __int8 *)this + 407) == 1;
  if ((gIIODebugFlags & 0x400000000000) != 0)
  {
    if (IIOReadPlugin::readOnlyRequested(void)::onceToken == -1)
    {
      return 0;
    }
    else
    {
      dispatch_once(&IIOReadPlugin::readOnlyRequested(void)::onceToken, &__block_literal_global_13);
      return 0;
    }
  }
  return result;
}

uint64_t _ImageIO_Free(unint64_t a1, size_t a2)
{
  pthread_mutex_lock(&gImageIOMemoryHashLock);
  if (gMemoryHashCreateOnce != -1) {
    dispatch_once(&gMemoryHashCreateOnce, &__block_literal_global_31);
  }
  if (!a2)
  {
    unint64_t v6 = ~a1;
    CFIndex v7 = &v6;
    a2 = std::__tree<std::__value_type<unsigned long,unsigned long>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,unsigned long>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,unsigned long>>>::__emplace_unique_key_args<unsigned long,std::piecewise_construct_t const&,std::tuple<unsigned long const&>,std::tuple<>>((uint64_t **)(gIIOMemoryHash + 8), &v6, (uint64_t)&std::piecewise_construct, (uint64_t **)&v7)[5];
  }
  unint64_t v4 = IIOMemoryHash::remove((uint64_t **)gIIOMemoryHash, a1);
  if (v4 != a2)
  {
    if (v4 > a2) {
      a2 = v4;
    }
    else {
      LogFault("_ImageIO_Free", 529, "*** ptr %p got double released??? (%ld bytes)   hash: %ld\n", (const void *)a1, a2, v4);
    }
  }
  ImageIORecordMemory(a1, -(uint64_t)a2);
  munmap((void *)a1, a2);
  return pthread_mutex_unlock(&gImageIOMemoryHashLock);
}

memory_object_offset_t _ImageIO_Malloc(memory_object_size_t a1, uint64_t a2, memory_object_size_t *a3, uint64_t a4, task_t a5, const char *a6, int a7)
{
  pthread_mutex_lock(&gImageIOMemoryHashLock);
  memory_object_offset_t v13 = 0;
  uint64_t v14 = (mach_vm_size_t *)MEMORY[0x1E4F14B00];
  memory_object_size_t v15 = ((a1 + *MEMORY[0x1E4F14B00] - 1) & -*MEMORY[0x1E4F14B00]) + *MEMORY[0x1E4F14B00];
  memory_object_size_t size = v15;
  if (v15 >= a1)
  {
    uint64_t v16 = mmap(0, v15, 3, 4097, 1174405122, 0);
    if (v16 != (void *)-1)
    {
      memory_object_offset_t v13 = (memory_object_offset_t)v16;
      uint64_t v17 = (vm_map_t *)MEMORY[0x1E4F14960];
      mach_vm_protect(*MEMORY[0x1E4F14960], (mach_vm_address_t)v16 + v15 - *v14, *v14, 1, 0);
      if (a5)
      {
        object_handle[0] = 0;
        mach_error_t memory_entry_64 = mach_make_memory_entry_64(*v17, &size, v13, 3, object_handle, 0);
        if (!memory_entry_64)
        {
          mach_error_t v21 = mach_memory_entry_ownership(object_handle[0], a5, -1, 0);
          if (v21)
          {
            uint64_t v22 = mach_error_string(v21);
            LogError(a6, a7, "*** ERROR: mach_memory_entry_ownership: %s", v22);
          }
          mach_port_deallocate(*v17, object_handle[0]);
          if (!a4)
          {
LABEL_11:
            if (gMemoryHashCreateOnce == -1)
            {
              if (v13)
              {
LABEL_13:
                memory_object_size_t v19 = size;
                memory_object_offset_t v25 = ~v13;
                *(void *)object_handle = &v25;
                std::__tree<std::__value_type<unsigned long,unsigned long>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,unsigned long>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,unsigned long>>>::__emplace_unique_key_args<unsigned long,std::piecewise_construct_t const&,std::tuple<unsigned long const&>,std::tuple<>>((uint64_t **)(gIIOMemoryHash + 8), &v25, (uint64_t)&std::piecewise_construct, (uint64_t **)object_handle)[5] = v19;
                memory_object_size_t v20 = size;
                *a3 = size;
                ImageIORecordMemory(v13, v20);
                goto LABEL_20;
              }
            }
            else
            {
              dispatch_once(&gMemoryHashCreateOnce, &__block_literal_global_31);
              if (v13) {
                goto LABEL_13;
              }
            }
            *a3 = 0;
            goto LABEL_20;
          }
LABEL_10:
          __CFSetLastAllocationEventName();
          goto LABEL_11;
        }
        mach_error_string(memory_entry_64);
        LogError(a6, a7, "*** ERROR: mach_make_memory_entry_64: %s");
      }
      else if (IIO_XPCServer())
      {
        LogError(a6, a7, "*** ERROR: OWNERLESS SERVER ALLOCATION: %s, %llu bytes");
      }
      if (!a4) {
        goto LABEL_11;
      }
      goto LABEL_10;
    }
    memory_object_offset_t v13 = 0;
  }
LABEL_20:
  pthread_mutex_unlock(&gImageIOMemoryHashLock);
  return v13;
}

const char *ImageIORecordMemory(uint64_t a1, uint64_t a2)
{
  gImageIOBlockMemorySize += a2;
  if ((gIIODebugFlags & 3) != 0)
  {
    if (a2 < 1) {
      BOOL result = a2 < 0
    }
             ? ImageIOLog("ImageIO_Free:          %14p  [%12ld] total: %12ld  %s %s  %s:%d\n")
             : ImageIOLog("ImageIO_Malloc/Free:   %14p  [%12ld] total: %12ld  %s   %s:%d\n");
    else {
      BOOL result = ImageIOLog("ImageIO_Malloc:        %14p  [%12ld] total: %12ld  %s  %s:%d\n");
    }
    if ((~(_BYTE)gIIODebugFlags & 3) == 0)
    {
      return IIODebug_ShowBacktrace(2);
    }
  }
  return result;
}

uint64_t IIOImageRead::setCachedImageBlockData(uint64_t a1, long long *a2, void *a3, cache_cost_t a4)
{
  int v8 = (pthread_mutex_t *)(a1 + 312);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 312));
  cache_set_and_retain((cache_t *)gImageBlockCache, a2, a3, a4);
  DebugStringFromKedouble y = createDebugStringFromKey((uint64_t)a2);
  if (DebugStringFromKey)
  {
    size_t v10 = DebugStringFromKey;
    ImageIOLog("ADD cache_set_and_retain:  %p:   data: %12p key: %s  (size=%ld) \n", (const void *)gImageBlockCache, a3, DebugStringFromKey, a4);
    free(v10);
  }
  int v11 = *(long long **)(a1 + 288);
  BOOL v12 = *(long long **)(a1 + 296);
  while (v11 != v12)
  {
    long long v13 = *v11;
    long long v14 = v11[1];
    *(_OWORD *)&v38[12] = *(long long *)((char *)v11 + 28);
    long long v37 = v13;
    *(_OWORD *)uint64_t v38 = v14;
    if (imageio_key_is_equal((char *)&v37, (char *)a2, 0)) {
      return pthread_mutex_unlock(v8);
    }
    int v11 = (long long *)((char *)v11 + 44);
  }
  memory_object_size_t v15 = createDebugStringFromKey((uint64_t)a2);
  if (v15)
  {
    uint64_t v16 = v15;
    ImageIOLog("+++ setCachedImageBlockData adding new key: %p:   data: %12p key: %s  (size=%ld) \n", (const void *)gImageBlockCache, a3, v15, a4);
    free(v16);
  }
  uint64_t v17 = *(_OWORD **)(a1 + 296);
  unint64_t v18 = *(void *)(a1 + 304);
  if ((unint64_t)v17 >= v18)
  {
    uint64_t v22 = *(void *)(a1 + 288);
    uint64_t v23 = 0x2E8BA2E8BA2E8BA3 * (((uint64_t)v17 - v22) >> 2);
    unint64_t v24 = v23 + 1;
    if ((unint64_t)(v23 + 1) > 0x5D1745D1745D174) {
      std::vector<IIOTag *>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v25 = 0x2E8BA2E8BA2E8BA3 * ((uint64_t)(v18 - v22) >> 2);
    if (2 * v25 > v24) {
      unint64_t v24 = 2 * v25;
    }
    if (v25 >= 0x2E8BA2E8BA2E8BALL) {
      unint64_t v26 = 0x5D1745D1745D174;
    }
    else {
      unint64_t v26 = v24;
    }
    if (v26) {
      int v27 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<imageio_key>>(a1 + 304, v26);
    }
    else {
      int v27 = 0;
    }
    double v28 = &v27[44 * v23];
    double v29 = &v27[44 * v26];
    long long v30 = *a2;
    long long v31 = a2[1];
    *(_OWORD *)(v28 + 28) = *(long long *)((char *)a2 + 28);
    *(_OWORD *)double v28 = v30;
    *((_OWORD *)v28 + 1) = v31;
    mach_error_t v21 = v28 + 44;
    BOOL v33 = *(char **)(a1 + 288);
    uint64_t v32 = *(char **)(a1 + 296);
    if (v32 != v33)
    {
      do
      {
        long long v34 = *(_OWORD *)(v32 - 44);
        long long v35 = *(_OWORD *)(v32 - 28);
        *((_OWORD *)v28 - 1) = *((_OWORD *)v32 - 1);
        *(_OWORD *)(v28 - 28) = v35;
        *(_OWORD *)(v28 - 44) = v34;
        v28 -= 44;
        v32 -= 44;
      }
      while (v32 != v33);
      uint64_t v32 = *(char **)(a1 + 288);
    }
    *(void *)(a1 + 288) = v28;
    *(void *)(a1 + 296) = v21;
    *(void *)(a1 + 304) = v29;
    if (v32) {
      operator delete(v32);
    }
  }
  else
  {
    long long v19 = *a2;
    long long v20 = a2[1];
    *(_OWORD *)((char *)v17 + 28) = *(long long *)((char *)a2 + 28);
    *uint64_t v17 = v19;
    v17[1] = v20;
    mach_error_t v21 = (char *)v17 + 44;
  }
  *(void *)(a1 + 296) = v21;
  return pthread_mutex_unlock(v8);
}

uint64_t IIOReadPlugin::getCachedBlocks(IIOReadPlugin *this, double a2, double a3, double a4)
{
  uint64_t v4 = *((unsigned int *)this + 26);
  memory_object_size_t v98 = 0;
  v99[0] = 0;
  HIDWORD(v5) = 0;
  memset(v97, 0, 44);
  if (*((void *)this + 12))
  {
    unsigned int v7 = *((_DWORD *)this + 58);
    if (v7 != 1 && (v7 > 9 || *((_DWORD *)this + 57) >= 0xAu))
    {
      unint64_t v9 = *((unsigned int *)this + 28);
      unint64_t v8 = *((unsigned int *)this + 29);
      if (v9 < v8)
      {
        unsigned int v72 = v4;
        size_t v10 = (CGRect *)MEMORY[0x1E4F1DB20];
        int v11 = &gIIODebugFlags;
        while (1)
        {
          unsigned int v12 = *((_DWORD *)this + 93);
          if (v12) {
            *((_DWORD *)this + 74) = v12;
          }
          else {
            unsigned int v12 = *((_DWORD *)this + 74);
          }
          unsigned int v13 = v12 * v9;
          *((_DWORD *)this + 72) = v12 * v9;
          LODWORD(v5) = *((_DWORD *)this + 71);
          double v14 = (double)(v12 * v9);
          double v15 = (double)v5;
          LODWORD(v5) = *((_DWORD *)this + 73);
          double v16 = (double)v5;
          LODWORD(a4) = *((_DWORD *)this + 58);
          double v17 = (double)*(unint64_t *)&a4;
          if ((double)v12 + v14 <= v17) {
            double v18 = (double)v12;
          }
          else {
            double v18 = v17 - (double)v13;
          }
          IIOReadPlugin::updateImageIOCacheKey((uint64_t)this, (uint64_t)v97, *((_DWORD *)this + 75), v15, (double)v13, v16, v18);
          if (IIOImageRead::getCachedImageBlockData(*((void *)this + 4), v97, v99))
          {
            uint64_t v19 = *((void *)this + 4);
            v94[0] = MEMORY[0x1E4F143A8];
            v94[1] = 0x40000000;
            v94[2] = ___ZN13IIOReadPlugin15getCachedBlocksEv_block_invoke;
            v94[3] = &__block_descriptor_tmp_164;
            v94[4] = this;
            long long v95 = v97[0];
            v96[0] = v97[1];
            *(_OWORD *)((char *)v96 + 12) = *(_OWORD *)((char *)&v97[1] + 12);
            IIOImageRead::enumerateCacheKeysWithBlock(v19, (uint64_t)v94);
            v100.origin.double x = v15;
            v100.origin.double y = v14;
            v100.size.double width = v16;
            v100.size.double height = v18;
            *(void *)(*((void *)this + 12) - 8 * *((unsigned int *)this + 28) + 8 * v9) = IIOReadPlugin::createImageBlock(this, v99[0], 0, v100, *((unsigned int *)this+ 75), 1);
            if (!CGRectEqualToRect(*(CGRect *)((char *)this + 120), *v10))
            {
              v101.origin.double x = v15;
              v101.origin.double y = v14;
              v101.size.double width = v16;
              v101.size.double height = v18;
              *(CGRect *)(&a4 - 2) = CGRectUnion(*(CGRect *)((char *)this + 120), v101);
              double v15 = *(double *)&v5;
              double v14 = v20;
              double v16 = a4;
              double v18 = v21;
            }
            *((double *)this + 15) = v15;
            *((double *)this + 16) = v14;
            *((double *)this + 17) = v16;
            *((double *)this + 18) = v18;
            if ((*v11 & 0x300) == 0x100 || (*v11 & 0x400000000000) != 0) {
              ImageIOLog("::: cache  hit:      rect=(%5d, %5d, %5d, %5d)   rb=%d   imageData=%p\n");
            }
          }
          else if (IIOReadPlugin::toggleCacheKey((uint64_t)this, (uint64_t)v97))
          {
            uint64_t v22 = v11;
            int v23 = *((unsigned __int8 *)this + 404);
            *((unsigned char *)this + 404) = v23 != 1;
            CachedImageBlockunint64_t Data = IIOImageRead::getCachedImageBlockData(*((void *)this + 4), v97, v99);
            *((unsigned char *)this + 404) = v23;
            if (!CachedImageBlockData)
            {
              uint64_t v4 = v72;
              goto LABEL_106;
            }
            LODWORD(v16) = *((_DWORD *)this + 71);
            LODWORD(v25) = *((_DWORD *)this + 72);
            double v27 = (double)v25;
            LODWORD(v18) = *((_DWORD *)this + 73);
            unsigned int v28 = *((_DWORD *)this + 74);
            LODWORD(v26) = *((_DWORD *)this + 58);
            double v29 = (double)v26;
            if ((double)v25 + (double)v28 <= v29) {
              double v30 = (double)v28;
            }
            else {
              double v30 = v29 - v27;
            }
            memory_object_size_t v90 = *((unsigned int *)this + 75) * (unint64_t)v28;
            long long v31 = (void *)_ImageIO_Malloc(v90, *((void *)this + 48), &v98, (uint64_t)"ImageIOGetCachedBlocks", *((_DWORD *)this + 108), 0, 0);
            int v11 = v22;
            if (v31)
            {
              uint64_t v32 = v31;
              vImagePixelCount v33 = *((unsigned int *)this + 74);
              src.std::string::pointer data = v99[0];
              src.double height = v33;
              size_t v34 = *((unsigned int *)this + 75);
              src.double width = *((unsigned int *)this + 73);
              src.rowuint64_t Bytes = v34;
              dest.std::string::pointer data = v31;
              dest.double height = v33;
              dest.double width = src.width;
              dest.rowuint64_t Bytes = v34;
              *(_DWORD *)permuteMap = 50331906;
              Pluginint Type = IIOImagePlus::readPluginType(*((IIOImagePlus **)this + 2));
              int v36 = PluginType;
              long long v37 = (char *)gCrashMessage;
              unsigned int v38 = PluginType >> 24;
              if (PluginType < 0)
              {
                int v40 = __maskrune(PluginType >> 24, 0x40000uLL);
                uint64_t v39 = MEMORY[0x1E4F14390];
              }
              else
              {
                uint64_t v39 = MEMORY[0x1E4F14390];
                int v40 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v38 + 60) & 0x40000;
              }
              if (v40) {
                uint64_t v42 = v38;
              }
              else {
                uint64_t v42 = 46;
              }
              uint64_t v88 = v42;
              unsigned int v43 = v36 << 8 >> 24;
              if (v36 << 8 < 0) {
                int v44 = __maskrune(v36 << 8 >> 24, 0x40000uLL);
              }
              else {
                int v44 = *(_DWORD *)(v39 + 4 * v43 + 60) & 0x40000;
              }
              if (v44) {
                uint64_t v45 = v43;
              }
              else {
                uint64_t v45 = 46;
              }
              uint64_t v87 = v45;
              unsigned int v46 = (__int16)v36 >> 8;
              if (v36 << 16 < 0) {
                int v47 = __maskrune((__int16)v36 >> 8, 0x40000uLL);
              }
              else {
                int v47 = *(_DWORD *)(v39 + 4 * v46 + 60) & 0x40000;
              }
              if (v47) {
                uint64_t v48 = v46;
              }
              else {
                uint64_t v48 = 46;
              }
              uint64_t v86 = v48;
              if ((v36 << 24) <= 0x7F000000) {
                int v49 = *(_DWORD *)(v39 + 4 * (char)v36 + 60) & 0x40000;
              }
              else {
                int v49 = __maskrune((char)v36, 0x40000uLL);
              }
              if (v49) {
                uint64_t v50 = (char)v36;
              }
              else {
                uint64_t v50 = 46;
              }
              unsigned int v84 = v99[0];
              uint64_t v85 = v50;
              int v83 = DWORD2(v97[2]);
              int v82 = *((_DWORD *)this + 73);
              int v81 = *((_DWORD *)this + 74);
              int v80 = *((_DWORD *)this + 75);
              int v73 = *((unsigned __int8 *)this + 311);
              int v74 = *((unsigned __int8 *)this + 312);
              int v51 = *((unsigned char *)this + 313) != 0;
              int v52 = *((unsigned __int8 *)this + 310);
              int v79 = *((unsigned __int16 *)this + 158);
              int v77 = *((char *)this + 410);
              uint64_t v78 = *((void *)this + 49);
              int v53 = *((_DWORD *)this + 100);
              unsigned int v54 = v53 >> 24;
              int v75 = *((char *)this + 409);
              uint64_t v76 = *((void *)this + 48);
              unsigned int v89 = v37;
              if (v53 < 0)
              {
                int v55 = __maskrune(v54, 0x40000uLL);
                int v53 = *((_DWORD *)this + 100);
              }
              else
              {
                int v55 = *(_DWORD *)(v39 + 4 * v54 + 60) & 0x40000;
              }
              if (v55) {
                uint64_t v56 = (v53 >> 24);
              }
              else {
                uint64_t v56 = 46;
              }
              unsigned int v57 = v53 << 8 >> 24;
              if (v53 << 8 < 0)
              {
                int v58 = __maskrune(v57, 0x40000uLL);
                int v53 = *((_DWORD *)this + 100);
              }
              else
              {
                int v58 = *(_DWORD *)(v39 + 4 * v57 + 60) & 0x40000;
              }
              if (v58) {
                uint64_t v59 = (v53 << 8 >> 24);
              }
              else {
                uint64_t v59 = 46;
              }
              unsigned int v60 = (__int16)v53 >> 8;
              if (v53 << 16 < 0)
              {
                int v61 = __maskrune(v60, 0x40000uLL);
                int v53 = *((_DWORD *)this + 100);
              }
              else
              {
                int v61 = *(_DWORD *)(v39 + 4 * v60 + 60) & 0x40000;
              }
              if (v61) {
                uint64_t v62 = ((__int16)v53 >> 8);
              }
              else {
                uint64_t v62 = 46;
              }
              if ((v53 << 24) <= 0x7F000000) {
                int v63 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * (char)v53 + 60) & 0x40000;
              }
              else {
                int v63 = __maskrune((char)v53, 0x40000uLL);
              }
              if (v63) {
                int v64 = *((_DWORD *)this + 100);
              }
              else {
                LOBYTE(v64) = 46;
              }
              snprintf(v89, 0x200uLL, "ImageIO: getCachedBlocks[%c%c%c%c]-permuteChannels srcData=%p(%d)  dstData=%p(%ld)  w=%d  h=%d  rb=%d  bmi=0x%08x  sub=%d  rbAlign=%ld(%d)  addrAlign=%ld(%d) format='%c%c%c%c'(%d)\n", v88, v87, v86, v85, v84, v83, v32, v90, v82, v81, v80, (v73 << 12) | (v74 << 16) | (v51 << 8) | v52, v79, v78, v77,
                v76,
                v75,
                v56,
                v59,
                v62,
                (char)v64,
                *((char *)this + 404));
              qword_1EB2BF498 = gCrashMessage;
              vImagePermuteChannels_ARGB8888(&src, &dest, permuteMap, 0x10u);
              qword_1EB2BF498 = 0;
              size_t v10 = (CGRect *)MEMORY[0x1E4F1DB20];
              int v11 = v22;
              if (*((unsigned __int8 *)this + 246) - 3 <= 1)
              {
                if (*((unsigned char *)this + 404))
                {
                  if (*((unsigned char *)this + 404) == 1) {
                    vImagePremultiplyData_RGBA8888(&dest, &dest, 0x10u);
                  }
                }
                else
                {
                  vImageUnpremultiplyData_RGBA8888(&dest, &dest, 0x10u);
                }
              }
              double v65 = (double)*(unint64_t *)&v16;
              double v66 = (double)*(unint64_t *)&v18;
              CGImageReadSessionReleaseCachedImageBlockData(v99[0]);
              *(void *)(*((void *)this + 12) - 8 * *((unsigned int *)this + 28) + 8 * v9) = IIO_ImageBlockCreate((unint64_t)v32, *((unsigned int *)this + 75), 0, v65, v27, v66, v30);
              if ((*((unsigned char *)v22 + 1) & 8) != 0) {
                ImageIOLog("   CGImageBlockCreate-cache2     rect: (%5g, %5g, %5g, %5g)    rowBytes: %6d    imageunint64_t Data = %p  (found in cache)\n", v65, v27, v66, v30, *((_DWORD *)this + 75), v99[0]);
              }
              if (!CGRectEqualToRect(*(CGRect *)((char *)this + 120), *v10))
              {
                v102.origin.double x = v65;
                v102.origin.double y = v27;
                v102.size.double width = v66;
                v102.size.double height = v30;
                *(CGRect *)(&a4 - 2) = CGRectUnion(*(CGRect *)((char *)this + 120), v102);
                double v65 = *(double *)&v5;
                double v27 = v67;
                double v66 = a4;
                double v30 = v68;
              }
              *((double *)this + 15) = v65;
              *((double *)this + 16) = v27;
              *((double *)this + 17) = v66;
              *((double *)this + 18) = v30;
              if ((*v22 & 0x300) == 0x100 || (*v22 & 0x400000000000) != 0) {
                ImageIOLog("::: cache  hit RGB <-> BGR:      rect=(%5d, %5d, %5d, %5d)   rb=%d   imageData=%p\n");
              }
            }
          }
          else if ((*v11 & 0x300) == 0x100 || (*v11 & 0x400000000000) != 0)
          {
            ImageIOLog("### cache miss:      rect=(%5d, %5d, %5d, %5d)\n");
          }
          ++v9;
          unint64_t v8 = *((unsigned int *)this + 29);
          if (v9 >= v8)
          {
            LODWORD(v9) = *((_DWORD *)this + 28);
            break;
          }
        }
      }
      if (v8 <= v9)
      {
        LODWORD(v70) = v9;
      }
      else
      {
        long long v69 = (void *)*((void *)this + 12);
        uint64_t v70 = v9;
        while (*v69)
        {
          ++v70;
          ++v69;
          if (v8 == v70)
          {
            LODWORD(v70) = v8;
            goto LABEL_103;
          }
        }
        unint64_t v8 = (v8 - 1);
        if (v8 > v9)
        {
          while (*(void *)(*((void *)this + 12) - 8 * v9 + 8 * v8))
          {
            if (--v8 <= v9)
            {
              LODWORD(v8) = v9;
              break;
            }
          }
        }
        LODWORD(v8) = v8 + 1;
        *((_DWORD *)this + 29) = v8;
      }
LABEL_103:
      *((_DWORD *)this + 28) = v70;
      uint64_t v4 = (v8 - v70);
      if (v8 == v70) {
        ++*((void *)this + 53);
      }
    }
  }
LABEL_106:
  IIO_XPCServer();
  return v4;
}

BOOL IIOImageRead::getCachedImageBlockData(uint64_t a1, _DWORD *a2, void **a3)
{
  int v5 = cache_get_and_retain((cache_t *)gImageBlockCache, a2, a3);
  if (*a3 && !a2[10]) {
    a2[10] = IOMemorySizeLookup((uint64_t)*a3);
  }
  DebugStringFromKedouble y = createDebugStringFromKey((uint64_t)a2);
  if (DebugStringFromKey)
  {
    unsigned int v7 = DebugStringFromKey;
    if (v5) {
      ImageIOLog("MIS cache_get_and_retain:  %p:   data: %12p key: %s  NOT FOUND\n");
    }
    else {
      ImageIOLog("FND cache_get_and_retain:  %p:   data: %12p key: %s\n");
    }
    free(v7);
  }
  return v5 == 0;
}

char *createDebugStringFromKey(uint64_t a1)
{
  double v20 = 0;
  if ((gIIODebugFlags & 0x400000000300) == 0) {
    return 0;
  }
  CFDataRef v2 = *(const void **)a1;
  int v3 = *(_DWORD *)(a1 + 8);
  int v4 = *(_DWORD *)(a1 + 12);
  int v5 = *(_DWORD *)(a1 + 16);
  int v6 = *(_DWORD *)(a1 + 20);
  int v7 = *(_DWORD *)(a1 + 24);
  unsigned int v8 = v7 >> 24;
  uint64_t v9 = MEMORY[0x1E4F14390];
  if (v7 < 0)
  {
    int v10 = __maskrune(v8, 0x40000uLL);
    int v7 = *(_DWORD *)(a1 + 24);
  }
  else
  {
    int v10 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v8 + 60) & 0x40000;
  }
  if (v10) {
    uint64_t v12 = (v7 >> 24);
  }
  else {
    uint64_t v12 = 46;
  }
  unsigned int v13 = v7 << 8 >> 24;
  if (v7 << 8 < 0)
  {
    int v14 = __maskrune(v13, 0x40000uLL);
    int v7 = *(_DWORD *)(a1 + 24);
  }
  else
  {
    int v14 = *(_DWORD *)(v9 + 4 * v13 + 60) & 0x40000;
  }
  if (v14) {
    uint64_t v15 = (v7 << 8 >> 24);
  }
  else {
    uint64_t v15 = 46;
  }
  unsigned int v16 = (__int16)v7 >> 8;
  if (v7 << 16 < 0)
  {
    int v17 = __maskrune(v16, 0x40000uLL);
    int v7 = *(_DWORD *)(a1 + 24);
  }
  else
  {
    int v17 = *(_DWORD *)(v9 + 4 * v16 + 60) & 0x40000;
  }
  if (v17) {
    uint64_t v18 = ((__int16)v7 >> 8);
  }
  else {
    uint64_t v18 = 46;
  }
  if ((v7 << 24) <= 0x7F000000)
  {
    if ((*(_DWORD *)(v9 + 4 * (char)v7 + 60) & 0x40000) != 0) {
      goto LABEL_23;
    }
LABEL_25:
    uint64_t v19 = 46;
    goto LABEL_26;
  }
  if (!__maskrune((char)v7, 0x40000uLL)) {
    goto LABEL_25;
  }
LABEL_23:
  uint64_t v19 = *(char *)(a1 + 24);
LABEL_26:
  asprintf(&v20, "'%p [%d,%d,%d,%d] '%c%c%c%c' #=%d rb=%6d rba=%3d sub=%2d float=%2d bpc=%2d'", v2, v3, v4, v5, v6, v12, v15, v18, v19, (unsigned __int16)*(void *)(a1 + 28), *(_DWORD *)(a1 + 36), WORD1(*(void *)(a1 + 28)), BYTE4(*(void *)(a1 + 28)), (unsigned __int16)WORD2(*(void *)(a1 + 28)) >> 8, BYTE6(*(void *)(a1 + 28)));
  return v20;
}

uint64_t IIOReadPlugin::updateImageIOCacheKey(uint64_t result, uint64_t a2, int a3, double a4, double a5, double a6, double a7)
{
  *(void *)a2 = *(void *)(result + 32);
  *(_DWORD *)(a2 + 8) = a4;
  *(_DWORD *)(a2 + 12) = a5;
  *(_DWORD *)(a2 + 16) = a6;
  *(_DWORD *)(a2 + 20) = a7;
  unint64_t v7 = *(void *)(a2 + 28) & 0xFFFFFFFFFFFF0000 | *(unsigned __int16 *)(result + 208);
  *(void *)(a2 + 28) = v7;
  unint64_t v8 = (*(_DWORD *)(result + 392) << 16) | v7 & 0xFFFFFFFF0000FFFFLL;
  *(void *)(a2 + 28) = v8;
  unint64_t v9 = v8 & 0xFF00FFFFFFFFFFFFLL | ((unint64_t)*(unsigned __int8 *)(result + 304) << 48);
  *(void *)(a2 + 28) = v9;
  *(_DWORD *)(a2 + 24) = *(_DWORD *)(result + 400);
  unint64_t v10 = v9 & 0xFFFFFF00FFFFFFFFLL | ((unint64_t)*(unsigned __int8 *)(result + 316) << 32);
  *(void *)(a2 + 28) = v10;
  *(_DWORD *)(a2 + 36) = a3;
  unint64_t v11 = v10 & 0xFDFFFFFFFFFFFFFFLL | ((unint64_t)*(unsigned __int8 *)(result + 354) << 57);
  *(void *)(a2 + 28) = v11;
  *(void *)(a2 + 28) = v11 & 0xFEFFFFFFFFFFFFFFLL | ((unint64_t)*(unsigned __int8 *)(result + 353) << 56);
  return result;
}

uint64_t IIOReadPlugin::toggleCacheKey(uint64_t a1, uint64_t a2)
{
  if (*(_WORD *)(a1 + 306) != 32
    || *(_WORD *)(a1 + 304) != 8
    || *(_DWORD *)(a1 + 320) != 1
    || *(_DWORD *)(a1 + 228) != *(_DWORD *)(a1 + 292)
    || *(_DWORD *)(a1 + 232) != *(_DWORD *)(a1 + 296))
  {
    return 0;
  }
  uint64_t result = 0;
  unsigned int v4 = 1111970369;
  unint64_t v5 = *(unsigned int *)(a2 + 24);
  if ((int)v5 > 1380401728)
  {
    if (v5 != 1380401729)
    {
      if (v5 != 1380401752) {
        return result;
      }
      unsigned int v4 = 1111970392;
    }
  }
  else if (v5 == 1111970369)
  {
    unsigned int v4 = 1380401729;
  }
  else
  {
    if (v5 != 1111970392) {
      return result;
    }
    unsigned int v4 = 1380401752;
  }
  if ((gIIODebugFlags & 0x300) != 0)
  {
    uint64_t v6 = MEMORY[0x1E4F14390];
    if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * (v5 >> 24) + 60) & 0x40000) != 0) {
      uint64_t v7 = HIBYTE(*(_DWORD *)(a2 + 24));
    }
    else {
      uint64_t v7 = 46;
    }
    unsigned int v8 = (int)(v5 << 8) >> 24;
    if (((v5 << 8) & 0x80000000) != 0)
    {
      int v9 = __maskrune(v8, 0x40000uLL);
      LODWORD(v5) = *(_DWORD *)(a2 + 24);
    }
    else
    {
      int v9 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v8 + 60) & 0x40000;
    }
    if (v9) {
      uint64_t v10 = ((int)(v5 << 8) >> 24);
    }
    else {
      uint64_t v10 = 46;
    }
    unsigned int v11 = (__int16)v5 >> 8;
    if (((v5 << 16) & 0x80000000) != 0)
    {
      int v12 = __maskrune(v11, 0x40000uLL);
      LODWORD(v5) = *(_DWORD *)(a2 + 24);
    }
    else
    {
      int v12 = *(_DWORD *)(v6 + 4 * v11 + 60) & 0x40000;
    }
    if (v12) {
      uint64_t v13 = ((__int16)v5 >> 8);
    }
    else {
      uint64_t v13 = 46;
    }
    if (v5 << 24 <= 0x7F000000u) {
      int v14 = *(_DWORD *)(v6 + 4 * (char)v5 + 60) & 0x40000;
    }
    else {
      int v14 = __maskrune((char)v5, 0x40000uLL);
    }
    uint64_t v15 = 46;
    if (v14) {
      uint64_t v16 = *(char *)(a2 + 24);
    }
    else {
      uint64_t v16 = 46;
    }
    LODWORD(v17) = HIBYTE(v4);
    uint64_t v18 = v6 + 60;
    if ((*(_DWORD *)(v6 + 60 + 4 * HIBYTE(v4)) & 0x40000) != 0) {
      uint64_t v17 = v17;
    }
    else {
      uint64_t v17 = 46;
    }
    LODWORD(v19) = (v4 >> 8) & 0x52;
    BOOL v20 = (*(_DWORD *)(v18 + 4 * v19) & 0x40000) == 0;
    int v21 = *(_DWORD *)(v18 + 4 * (v4 & 0x59));
    if (v20) {
      uint64_t v19 = 46;
    }
    else {
      uint64_t v19 = v19;
    }
    if ((v21 & 0x40000) != 0) {
      uint64_t v22 = v4 & 0x59;
    }
    else {
      uint64_t v22 = 46;
    }
    if ((*(_DWORD *)(v6 + 344) & 0x40000) != 0) {
      uint64_t v15 = 71;
    }
    ImageIOLog("::: found '%c%c%c%c' - checking alternate '%c%c%c%c'\n", v7, v10, v13, v16, v17, v15, v19, v22);
  }
  *(_DWORD *)(a2 + 24) = v4;
  return 1;
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<imageio_key>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x5D1745D1745D175) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  return operator new(44 * a2);
}

void *std::vector<IIODecodeFrameParams>::vector(void *a1, unint64_t a2, uint64_t a3)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    std::vector<IIODecodeFrameParams>::__vallocate[abi:ne180100](a1, a2);
    uint64_t v6 = a1[1];
    uint64_t v7 = 88 * a2;
    uint64_t v8 = v6 + 88 * a2;
    do
    {
      long long v9 = *(_OWORD *)(a3 + 16);
      *(_OWORD *)uint64_t v6 = *(_OWORD *)a3;
      *(_OWORD *)(v6 + 16) = v9;
      long long v10 = *(_OWORD *)(a3 + 32);
      long long v11 = *(_OWORD *)(a3 + 48);
      long long v12 = *(_OWORD *)(a3 + 64);
      *(void *)(v6 + 80) = *(void *)(a3 + 80);
      *(_OWORD *)(v6 + 48) = v11;
      *(_OWORD *)(v6 + 64) = v12;
      *(_OWORD *)(v6 + 32) = v10;
      v6 += 88;
      v7 -= 88;
    }
    while (v7);
    a1[1] = v8;
  }
  return a1;
}

void sub_1885D4D30(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
}

char *std::vector<IIODecodeFrameParams>::__vallocate[abi:ne180100](void *a1, unint64_t a2)
{
  if (a2 >= 0x2E8BA2E8BA2E8BBLL) {
    std::vector<IIOTag *>::__throw_length_error[abi:ne180100]();
  }
  uint64_t result = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<IIODecodeFrameParams>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[88 * v4];
  return result;
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<IIODecodeFrameParams>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x2E8BA2E8BA2E8BBLL) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  return operator new(88 * a2);
}

void PNGReadPlugin::DecodeUncomposedFrames(IIOImageRead *a1, uint64_t a2, uint64_t a3, unsigned char *a4, uint64_t **a5)
{
  int v8 = *a4;
  if (v8 == 3)
  {
    uint64_t v12 = a5[1] - *a5;
    block[0] = MEMORY[0x1E4F143A8];
    block[1] = 0x40000000;
    block[2] = ___ZN13PNGReadPlugin22DecodeUncomposedFramesEP12IIOImageReadP13GlobalPNGInfoRK14ReadPluginDataRK13PNGPluginDataRNSt3__16vectorI20IIODecodeFrameParamsNSA_9allocatorISC_EEEE_block_invoke;
    block[3] = &__block_descriptor_tmp_165;
    block[4] = a1;
    block[5] = a2;
    block[6] = a3;
    block[7] = a4;
    block[8] = a5;
    dispatch_apply(0x2E8BA2E8BA2E8BA3 * v12, 0, block);
  }
  else
  {
    if (v8 == 2)
    {
      long long v16 = 0u;
      long long v17 = 0u;
      long long v14 = 0u;
      long long v15 = 0u;
      IIOImageReadSession::IIOImageReadSession((IIOImageReadSession *)&v14, a1);
      PNGReadPlugin::DecodeFrameInterlaced((IIOImageReadSession *)&v14, a3, a4, *a5);
    }
    else
    {
      if (v8 != 1) {
        return;
      }
      long long v16 = 0u;
      long long v17 = 0u;
      long long v14 = 0u;
      long long v15 = 0u;
      IIOImageReadSession::IIOImageReadSession((IIOImageReadSession *)&v14, a1);
      PNGReadPlugin::DecodeFrameStandard((IIOImageReadSession *)&v14, a3, (uint64_t)a4, *a5, v9, v10, v11);
    }
    IIOImageReadSession::~IIOImageReadSession((IIOImageReadSession *)&v14);
  }
}

void sub_1885D4F24(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  IIOImageReadSession::~IIOImageReadSession((IIOImageReadSession *)va);
  _Unwind_Resume(a1);
}

void IIOImageReadSession::IIOImageReadSession(IIOImageReadSession *this, IIOImageRead *a2)
{
  *((void *)this + 2) = 0;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1ED4E4C40;
  *((void *)this + 1) = 0;
  *((void *)this + 4) = a2;
  *((void *)this + 5) = 0;
  *((void *)this + 6) = this;
  *((void *)this + 7) = this;
}

void std::vector<IIODecodeFrameParams>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  uint64_t v1 = *a1;
  CFDataRef v2 = (char *)**a1;
  if (v2)
  {
    uint64_t v4 = (char *)v1[1];
    unint64_t v5 = v2;
    if (v4 != v2)
    {
      do
        IIODecodeFrameParams::~IIODecodeFrameParams((IIODecodeFrameParams *)(v4 - 88));
      while (v4 != v2);
      unint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void IIODecodeFrameParams::~IIODecodeFrameParams(IIODecodeFrameParams *this)
{
  uint64_t v1 = *((void *)this + 10);
  if (v1)
  {
    uint64_t v2 = *(void *)(v1 + 16);
    *(void *)(v1 + 16) = 0;
    if (v2) {
      MEMORY[0x18C11C0C0](v2, 0x1000C8033FC2DF1);
    }
    MEMORY[0x18C11C0E0](v1, 0x1020C40D090CC53);
  }
}

uint64_t PNGReadPlugin::postProcess(PNGReadPlugin *this, unsigned __int8 *a2)
{
  if (*((_WORD *)this + 153) == 32 && *((_WORD *)this + 152) == 8 && *((_DWORD *)this + 100) != 1768842360)
  {
    vImagePixelCount v4 = *((unsigned int *)this + 74);
    dest.std::string::pointer data = a2;
    dest.double height = v4;
    size_t v5 = *((unsigned int *)this + 75);
    dest.double width = *((unsigned int *)this + 73);
    dest.rowuint64_t Bytes = v5;
    BOOL v6 = (*((_DWORD *)this + 120) & 0x1Fu) - 1 >= 2 && *((unsigned char *)this + 406) != 0;
    if (*((unsigned char *)this + 413) || *((unsigned char *)this + 512) == 1) {
      BOOL v6 = 0;
    }
    if (*((unsigned char *)this + 475))
    {
      if (*((unsigned char *)this + 405))
      {
        *(_DWORD *)permuteMap = 50331906;
        vImagePermuteChannels_ARGB8888(&dest, &dest, permuteMap, 0x10u);
        if ((gIIODebugFlags & 0x20000) != 0)
        {
          int v7 = *((_DWORD *)this + 51);
          unsigned int v8 = v7 >> 24;
          uint64_t v9 = MEMORY[0x1E4F14390];
          if (v7 < 0)
          {
            uint64_t v20 = MEMORY[0x1E4F14390];
            int v10 = __maskrune(v8, 0x40000uLL);
            uint64_t v9 = v20;
            int v7 = *((_DWORD *)this + 51);
          }
          else
          {
            int v10 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v8 + 60) & 0x40000;
          }
          if (v10) {
            uint64_t v21 = (v7 >> 24);
          }
          else {
            uint64_t v21 = 46;
          }
          unsigned int v22 = v7 << 8 >> 24;
          if (v7 << 8 < 0)
          {
            uint64_t v24 = v9;
            int v23 = __maskrune(v22, 0x40000uLL);
            uint64_t v9 = v24;
            int v7 = *((_DWORD *)this + 51);
          }
          else
          {
            int v23 = *(_DWORD *)(v9 + 4 * v22 + 60) & 0x40000;
          }
          if (v23) {
            uint64_t v25 = (v7 << 8 >> 24);
          }
          else {
            uint64_t v25 = 46;
          }
          unsigned int v26 = (__int16)v7 >> 8;
          if (v7 << 16 < 0)
          {
            uint64_t v28 = v9;
            int v27 = __maskrune(v26, 0x40000uLL);
            uint64_t v9 = v28;
            int v7 = *((_DWORD *)this + 51);
          }
          else
          {
            int v27 = *(_DWORD *)(v9 + 4 * v26 + 60) & 0x40000;
          }
          if (v27) {
            uint64_t v29 = ((__int16)v7 >> 8);
          }
          else {
            uint64_t v29 = 46;
          }
          if ((v7 << 24) <= 0x7F000000) {
            int v30 = *(_DWORD *)(v9 + 4 * (char)v7 + 60) & 0x40000;
          }
          else {
            int v30 = __maskrune((char)v7, 0x40000uLL);
          }
          if (v30) {
            uint64_t v31 = *((char *)this + 204);
          }
          else {
            uint64_t v31 = 46;
          }
          ImageIOLog("  '%c%c%c%c' %d: vImagePermuteChannels_ARGB8888 {2,1,0,3}\n", v21, v25, v29, v31, 3391);
        }
        if (*((unsigned char *)this + 512) == 1 && *((unsigned char *)this + 404) != 1)
        {
          vImageUnpremultiplyData_RGBA8888(&dest, &dest, 0x10u);
          if ((gIIODebugFlags & 0x20000) != 0)
          {
            int v32 = *((_DWORD *)this + 51);
            unsigned int v33 = v32 >> 24;
            if (v32 < 0)
            {
              int v34 = __maskrune(v33, 0x40000uLL);
              int v32 = *((_DWORD *)this + 51);
            }
            else
            {
              int v34 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v33 + 60) & 0x40000;
            }
            if (v34) {
              uint64_t v54 = (v32 >> 24);
            }
            else {
              uint64_t v54 = 46;
            }
            unsigned int v55 = v32 << 8 >> 24;
            if (v32 << 8 < 0)
            {
              int v56 = __maskrune(v55, 0x40000uLL);
              int v32 = *((_DWORD *)this + 51);
            }
            else
            {
              int v56 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v55 + 60) & 0x40000;
            }
            if (v56) {
              uint64_t v57 = (v32 << 8 >> 24);
            }
            else {
              uint64_t v57 = 46;
            }
            unsigned int v58 = (__int16)v32 >> 8;
            if (v32 << 16 < 0)
            {
              int v59 = __maskrune(v58, 0x40000uLL);
              int v32 = *((_DWORD *)this + 51);
            }
            else
            {
              int v59 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v58 + 60) & 0x40000;
            }
            if (v59) {
              uint64_t v60 = ((__int16)v32 >> 8);
            }
            else {
              uint64_t v60 = 46;
            }
            if ((v32 << 24) > 0x7F000000) {
              __maskrune((char)v32, 0x40000uLL);
            }
            ImageIOLog("  '%c%c%c%c' %d: vImageUnpremultiplyData_RGBA8888 [%02X,%02X,%02X,%02X] -> [%02X,%02X,%02X,%02X]\n", v54, v57, v60);
          }
        }
      }
      else if (*((unsigned char *)this + 512) == 1 && *((unsigned char *)this + 404) != 1)
      {
        vImageUnpremultiplyData_RGBA8888(&dest, &dest, 0x10u);
        if ((gIIODebugFlags & 0x20000) != 0)
        {
          int v14 = *((_DWORD *)this + 51);
          unsigned int v15 = v14 >> 24;
          if (v14 < 0)
          {
            int v16 = __maskrune(v15, 0x40000uLL);
            int v14 = *((_DWORD *)this + 51);
          }
          else
          {
            int v16 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v15 + 60) & 0x40000;
          }
          if (v16) {
            uint64_t v68 = (v14 >> 24);
          }
          else {
            uint64_t v68 = 46;
          }
          unsigned int v69 = v14 << 8 >> 24;
          if (v14 << 8 < 0)
          {
            int v70 = __maskrune(v69, 0x40000uLL);
            int v14 = *((_DWORD *)this + 51);
          }
          else
          {
            int v70 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v69 + 60) & 0x40000;
          }
          if (v70) {
            uint64_t v71 = (v14 << 8 >> 24);
          }
          else {
            uint64_t v71 = 46;
          }
          unsigned int v72 = (__int16)v14 >> 8;
          if (v14 << 16 < 0)
          {
            int v73 = __maskrune(v72, 0x40000uLL);
            int v14 = *((_DWORD *)this + 51);
          }
          else
          {
            int v73 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v72 + 60) & 0x40000;
          }
          if (v73) {
            uint64_t v74 = ((__int16)v14 >> 8);
          }
          else {
            uint64_t v74 = 46;
          }
          if ((v14 << 24) > 0x7F000000) {
            __maskrune((char)v14, 0x40000uLL);
          }
          ImageIOLog("  '%c%c%c%c' %d: vImageUnpremultiplyData_BGRA8888 [%02X,%02X,%02X,%02X] -> [%02X,%02X,%02X,%02X]\n", v68, v71, v74);
        }
      }
    }
    else if (*((unsigned char *)this + 405))
    {
      if (v6 || *((unsigned char *)this + 406) == 1)
      {
        vImagePremultiplyData_RGBA8888(&dest, &dest, 0x10u);
        if ((gIIODebugFlags & 0x20000) != 0)
        {
          int v11 = *((_DWORD *)this + 51);
          unsigned int v12 = v11 >> 24;
          if (v11 < 0)
          {
            int v13 = __maskrune(v12, 0x40000uLL);
            int v11 = *((_DWORD *)this + 51);
          }
          else
          {
            int v13 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v12 + 60) & 0x40000;
          }
          if (v13) {
            uint64_t v35 = (v11 >> 24);
          }
          else {
            uint64_t v35 = 46;
          }
          unsigned int v36 = v11 << 8 >> 24;
          if (v11 << 8 < 0)
          {
            int v37 = __maskrune(v36, 0x40000uLL);
            int v11 = *((_DWORD *)this + 51);
          }
          else
          {
            int v37 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v36 + 60) & 0x40000;
          }
          if (v37) {
            uint64_t v38 = (v11 << 8 >> 24);
          }
          else {
            uint64_t v38 = 46;
          }
          unsigned int v39 = (__int16)v11 >> 8;
          if (v11 << 16 < 0)
          {
            int v40 = __maskrune(v39, 0x40000uLL);
            int v11 = *((_DWORD *)this + 51);
          }
          else
          {
            int v40 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v39 + 60) & 0x40000;
          }
          if (v40) {
            uint64_t v41 = ((__int16)v11 >> 8);
          }
          else {
            uint64_t v41 = 46;
          }
          if ((v11 << 24) > 0x7F000000) {
            __maskrune((char)v11, 0x40000uLL);
          }
          ImageIOLog("  '%c%c%c%c' %d: vImagePremultiplyData_RGBA8888 [%02X,%02X,%02X,%02X] -> [%02X,%02X,%02X,%02X]\n", v35, v38, v41);
        }
      }
    }
    else
    {
      *(_DWORD *)permuteMap = 50331906;
      vImagePermuteChannels_ARGB8888(&dest, &dest, permuteMap, 0x10u);
      if ((gIIODebugFlags & 0x20000) != 0)
      {
        int v17 = *((_DWORD *)this + 51);
        unsigned int v18 = v17 >> 24;
        if (v17 < 0)
        {
          int v19 = __maskrune(v18, 0x40000uLL);
          int v17 = *((_DWORD *)this + 51);
        }
        else
        {
          int v19 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v18 + 60) & 0x40000;
        }
        if (v19) {
          uint64_t v42 = (v17 >> 24);
        }
        else {
          uint64_t v42 = 46;
        }
        unsigned int v43 = v17 << 8 >> 24;
        if (v17 << 8 < 0)
        {
          int v44 = __maskrune(v43, 0x40000uLL);
          int v17 = *((_DWORD *)this + 51);
        }
        else
        {
          int v44 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v43 + 60) & 0x40000;
        }
        if (v44) {
          uint64_t v45 = (v17 << 8 >> 24);
        }
        else {
          uint64_t v45 = 46;
        }
        unsigned int v46 = (__int16)v17 >> 8;
        if (v17 << 16 < 0)
        {
          int v47 = __maskrune(v46, 0x40000uLL);
          int v17 = *((_DWORD *)this + 51);
        }
        else
        {
          int v47 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v46 + 60) & 0x40000;
        }
        if (v47) {
          uint64_t v48 = ((__int16)v17 >> 8);
        }
        else {
          uint64_t v48 = 46;
        }
        if ((v17 << 24) <= 0x7F000000) {
          int v49 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * (char)v17 + 60) & 0x40000;
        }
        else {
          int v49 = __maskrune((char)v17, 0x40000uLL);
        }
        if (v49) {
          uint64_t v50 = *((char *)this + 204);
        }
        else {
          uint64_t v50 = 46;
        }
        ImageIOLog("  '%c%c%c%c' %d: vImagePermuteChannels_ARGB8888 {2,1,0,3}\n", v42, v45, v48, v50, 3418);
      }
      if (*((unsigned char *)this + 406) == 1)
      {
        vImagePremultiplyData_RGBA8888(&dest, &dest, 0x10u);
        if ((gIIODebugFlags & 0x20000) != 0)
        {
          int v51 = *((_DWORD *)this + 51);
          unsigned int v52 = v51 >> 24;
          if (v51 < 0)
          {
            int v53 = __maskrune(v52, 0x40000uLL);
            int v51 = *((_DWORD *)this + 51);
          }
          else
          {
            int v53 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v52 + 60) & 0x40000;
          }
          if (v53) {
            uint64_t v61 = (v51 >> 24);
          }
          else {
            uint64_t v61 = 46;
          }
          unsigned int v62 = v51 << 8 >> 24;
          if (v51 << 8 < 0)
          {
            int v63 = __maskrune(v62, 0x40000uLL);
            int v51 = *((_DWORD *)this + 51);
          }
          else
          {
            int v63 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v62 + 60) & 0x40000;
          }
          if (v63) {
            uint64_t v64 = (v51 << 8 >> 24);
          }
          else {
            uint64_t v64 = 46;
          }
          unsigned int v65 = (__int16)v51 >> 8;
          if (v51 << 16 < 0)
          {
            int v66 = __maskrune(v65, 0x40000uLL);
            int v51 = *((_DWORD *)this + 51);
          }
          else
          {
            int v66 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v65 + 60) & 0x40000;
          }
          if (v66) {
            uint64_t v67 = ((__int16)v51 >> 8);
          }
          else {
            uint64_t v67 = 46;
          }
          if ((v51 << 24) > 0x7F000000) {
            __maskrune((char)v51, 0x40000uLL);
          }
          ImageIOLog("  '%c%c%c%c' %d: vImagePremultiplyData_BGRA8888 [%02X,%02X,%02X,%02X] -> [%02X,%02X,%02X,%02X]\n", v61, v64, v67);
        }
      }
    }
  }
  return 0;
}

uint64_t CGImageReadSessionReleaseCachedImageBlockData(void *value)
{
  if ((gIIODebugFlags & 0x200) != 0) {
    _cg_jpeg_mem_term("CGImageReadSessionReleaseCachedImageBlockData", 555, "    cache_release_value:   %p:   data: %12p\n", (const void *)gImageBlockCache, value);
  }
  uint64_t v2 = (cache_t *)gImageBlockCache;

  return cache_release_value(v2, value);
}

const char *ImageIO_make_read_only(mach_vm_address_t a1, mach_vm_size_t a2)
{
  pthread_mutex_lock(&gImageIOMemoryHashLock);
  if (gMemoryHashCreateOnce == -1)
  {
    if (a2) {
      goto LABEL_4;
    }
    goto LABEL_3;
  }
  dispatch_once(&gMemoryHashCreateOnce, &__block_literal_global_31);
  if (!a2)
  {
LABEL_3:
    mach_vm_address_t v5 = ~a1;
    BOOL v6 = &v5;
    a2 = std::__tree<std::__value_type<unsigned long,unsigned long>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,unsigned long>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,unsigned long>>>::__emplace_unique_key_args<unsigned long,std::piecewise_construct_t const&,std::tuple<unsigned long const&>,std::tuple<>>((uint64_t **)(gIIOMemoryHash + 8), &v5, (uint64_t)&std::piecewise_construct, (uint64_t **)&v6)[5];
  }
LABEL_4:
  mach_vm_protect(*MEMORY[0x1E4F14960], a1, a2, 1, 1);
  uint64_t result = (const char *)pthread_mutex_unlock(&gImageIOMemoryHashLock);
  if ((gIIODebugFlags & 0x80000000000) != 0) {
    return ImageIOLog("D   %s:%d mach_vm_protect: %p\n", "ImageIO_make_read_only", 640, (const void *)a1);
  }
  return result;
}

uint64_t IOMemorySizeLookup(uint64_t a1)
{
  uint64_t v1 = a1;
  if (a1)
  {
    pthread_mutex_lock(&gImageIOMemoryHashLock);
    if (gMemoryHashCreateOnce != -1) {
      dispatch_once(&gMemoryHashCreateOnce, &__block_literal_global_31);
    }
    unint64_t v3 = ~v1;
    vImagePixelCount v4 = &v3;
    uint64_t v1 = std::__tree<std::__value_type<unsigned long,unsigned long>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,unsigned long>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,unsigned long>>>::__emplace_unique_key_args<unsigned long,std::piecewise_construct_t const&,std::tuple<unsigned long const&>,std::tuple<>>((uint64_t **)(gIIOMemoryHash + 8), &v3, (uint64_t)&std::piecewise_construct, (uint64_t **)&v4)[5];
    pthread_mutex_unlock(&gImageIOMemoryHashLock);
  }
  return v1;
}

const char *IIOImageReadSession::unmapData(const char **this)
{
  return IIOImageRead::unmapData(this[4]);
}

uint64_t ASTCTextureImp::createTwiddler(uint64_t this)
{
  if (!*(void *)(this + 240)) {
    operator new();
  }
  return this;
}

void sub_1885D5C38(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0xA1C40BD48D6D6);
  _Unwind_Resume(a1);
}

BOOL ASTCTwiddler::finalized(ASTCTwiddler *this)
{
  uint64_t v1 = *((void *)this + 1);
  return v1 && *(unsigned char *)(v1 + 64) != 0;
}

const char *ASTCTwiddler::finalizeTwiddling(ASTCTwiddler *this)
{
  uint64_t result = (const char *)*((void *)this + 1);
  if (result) {
    return ASTCTwiddler::ASTCTwiddlerImpl::finalizeTwiddlingImp(result);
  }
  return result;
}

uint64_t ASTCTwiddler::twiddledDataSize(ASTCTwiddler *this)
{
  uint64_t v1 = *((void *)this + 1);
  if (v1) {
    return [*(id *)(v1 + 56) size];
  }
  else {
    return 0;
  }
}

uint64_t ASTCTwiddler::twiddledData(ASTCTwiddler *this)
{
  uint64_t v1 = *((void *)this + 1);
  if (v1 && *(unsigned char *)(v1 + 64)) {
    return *(void *)(v1 + 40);
  }
  else {
    return 0;
  }
}

void ASTCTwiddler::decodeAndCopyFromLinearData(ASTCTwiddler *this, unsigned __int8 *a2, size_t a3, size_t a4, int a5)
{
  mach_vm_address_t v5 = (ASTCTwiddler::ASTCTwiddlerImpl *)*((void *)this + 1);
  if (v5) {
    ASTCTwiddler::ASTCTwiddlerImpl::decodeAndCopyFromLinearDataImp(v5, a2, a3, a4, a5);
  }
}

uint64_t IIOImagePlus::readPluginType(IIOImagePlus *this)
{
  return *((unsigned int *)this + 44);
}

const void *IIO_ImageBlockCreate(unint64_t a1, uint64_t a2, const void *a3, double a4, double a5, double a6, double a7)
{
  if (a3)
  {
    int v13 = a3;
    int v14 = "";
  }
  else
  {
    pthread_mutex_lock(&gImageIOMemoryHashLock);
    if (gMemoryHashCreateOnce != -1) {
      dispatch_once(&gMemoryHashCreateOnce, &__block_literal_global_31);
    }
    unint64_t v17 = ~a1;
    unsigned int v18 = &v17;
    int v13 = (const void *)std::__tree<std::__value_type<unsigned long,unsigned long>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,unsigned long>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,unsigned long>>>::__emplace_unique_key_args<unsigned long,std::piecewise_construct_t const&,std::tuple<unsigned long const&>,std::tuple<>>((uint64_t **)(gIIOMemoryHash + 8), &v17, (uint64_t)&std::piecewise_construct, (uint64_t **)&v18)[5];
    pthread_mutex_unlock(&gImageIOMemoryHashLock);
    int v14 = "cached";
  }
  unsigned int v15 = (const void *)CGImageBlockCreate();
  if ((gIIODebugFlags & 0xC00) != 0)
  {
    atomic_fetch_add_explicit(&gBlockCount, 1u, memory_order_relaxed);
    ImageIOLog("    CGImageBlockCreate:       %14p - info: %14p  data: %14p  B-[%2ld]  rb: %8ld  r:(%4g,%4g,%4g,%4g) %s\n", v15, v13, (const void *)a1, gBlockCount, a2, a4, a5, a6, a7, v14);
    if ((gIIODebugFlags & 0x800) != 0) {
      IIODebug_ShowBacktrace(2);
    }
  }
  return v15;
}

ASTCTwiddler::ASTCTwiddlerImpl *ASTCTwiddler::copyFromLinearData(ASTCTwiddler *this, const void *a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6)
{
  uint64_t result = (ASTCTwiddler::ASTCTwiddlerImpl *)*((void *)this + 1);
  if (result) {
    return (ASTCTwiddler::ASTCTwiddlerImpl *)ASTCTwiddler::ASTCTwiddlerImpl::copyFromLinearDataImp(result, a2, a3, a4, a5, a6);
  }
  return result;
}

void RDF_Parser::ResourcePropertyElement(RDF_Parser *this, XMP_Node *a2, const XML_Node *a3, int a4)
{
  if (a4)
  {
    BOOL v6 = (char *)a3 + 40;
    int v7 = *((char *)a3 + 63);
    if (v7 < 0)
    {
      if (*((void *)a3 + 6) != 10) {
        goto LABEL_11;
      }
      BOOL v6 = *(char **)v6;
    }
    else if (v7 != 10)
    {
      goto LABEL_11;
    }
    uint64_t v8 = *(void *)v6;
    int v9 = *((unsigned __int16 *)v6 + 4);
    if (v8 == 0x676E6168633A5869 && v9 == 29541) {
      return;
    }
  }
LABEL_11:
  uint64_t v11 = RDF_Parser::AddChildNode(this, a2, a3, "", a4);
  if (!v11) {
    return;
  }
  unsigned int v12 = (XMP_Node *)v11;
  int v13 = (const XML_Node **)*((void *)a3 + 13);
  for (CFIndex i = (const XML_Node **)*((void *)a3 + 14); v13 != i; ++v13)
  {
    unsigned int v15 = *v13;
    int v16 = (void *)((char *)*v13 + 40);
    if (*((char *)*v13 + 63) < 0)
    {
      uint64_t v18 = *((void *)v15 + 6);
      if (v18 == 6)
      {
        int v16 = (void *)*v16;
LABEL_23:
        int v19 = *(_DWORD *)v16;
        int v20 = *((unsigned __int16 *)v16 + 2);
        if (v19 == 979788914 && v20 == 17481) {
          continue;
        }
        goto LABEL_27;
      }
      if (v18 == 8 && *(void *)*v16 == 0x676E616C3A6C6D78)
      {
LABEL_30:
        RDF_Parser::AddQualifierNode(this, v12, v15);
        continue;
      }
    }
    else
    {
      int v17 = *((unsigned __int8 *)*v13 + 63);
      if (v17 == 6) {
        goto LABEL_23;
      }
      if (v17 == 8 && *v16 == 0x676E616C3A6C6D78) {
        goto LABEL_30;
      }
    }
LABEL_27:
    *(_OWORD *)&v43.__r_.__value_.__r.__words[1] = (unint64_t)"Invalid attribute for resource property element";
    v43.__r_.__value_.__r.__words[0] = 202;
    GenericErrorCallback::NotifyClient(*(void *)this, 0, (unsigned int *)&v43, 0);
  }
  int v23 = (XML_Node **)*((void *)a3 + 16);
  unsigned int v22 = (XML_Node **)*((void *)a3 + 17);
  if (v23 != v22)
  {
    while (XML_Node::IsWhitespaceNode(*v23))
    {
      if (++v23 == v22) {
        goto LABEL_53;
      }
    }
  }
  if (v23 == v22)
  {
LABEL_53:
    v43.__r_.__value_.__r.__words[2] = 0;
    int v34 = "Missing child of resource property element";
LABEL_86:
    v43.__r_.__value_.__l.__size_ = (std::string::size_type)v34;
    v43.__r_.__value_.__r.__words[0] = 202;
    GenericErrorCallback::NotifyClient(*(void *)this, 0, (unsigned int *)&v43, 0);
    return;
  }
  uint64_t v24 = *v23;
  if (*((unsigned char *)*v23 + 8) != 1)
  {
    v43.__r_.__value_.__r.__words[2] = 0;
    int v34 = "Children of resource property element must be XML elements";
    goto LABEL_86;
  }
  uint64_t v25 = (int **)((char *)v24 + 40);
  int v26 = *((char *)v24 + 63);
  if (v26 < 0)
  {
    if (*((void *)v24 + 6) == 7)
    {
      uint64_t v29 = *v25;
      if (**v25 != 979788914 || *(int *)((char *)*v25 + 3) != 1734427194)
      {
        if (*v29 != 979788914 || *(int *)((char *)v29 + 3) != 1902465850) {
          goto LABEL_47;
        }
LABEL_65:
        int v33 = *((_DWORD *)v12 + 2) | 0x600;
        goto LABEL_70;
      }
LABEL_69:
      int v33 = *((_DWORD *)v12 + 2) | 0x200;
      goto LABEL_70;
    }
LABEL_66:
    if (std::operator!=[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>(v25, "rdf:Description"))
    {
      memset(&v43, 0, sizeof(v43));
      int v37 = *v23;
      if (*((char *)*v23 + 39) < 0) {
        std::string::__init_copy_ctor_external(&v43, *((const std::string::value_type **)v37 + 2), *((void *)v37 + 3));
      }
      else {
        std::string v43 = *(std::string *)((char *)v37 + 16);
      }
      std::string::size_type v38 = std::string::find((const std::string *)((char *)*v23 + 40), 58, 0);
      if (v38 != -1)
      {
        std::string::append(&v43, (const std::string *)((char *)*v23 + 40), v38 + 1, 0xFFFFFFFFFFFFFFFFLL);
        std::string::basic_string[abi:ne180100]<0>(__p, "rdf:type");
        RDF_Parser::AddQualifierNode();
      }
      __p[0] = (void *)203;
      __p[1] = "All XML elements must be in a namespace";
      __p[2] = 0;
      GenericErrorCallback::NotifyClient(*(void *)this, 0, (unsigned int *)__p, 0);
      if (SHIBYTE(v43.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v43.__r_.__value_.__l.__data_);
      }
      return;
    }
    *((_DWORD *)v12 + 2) |= 0x100u;
    uint64_t v24 = *v23;
    goto LABEL_78;
  }
  if (v26 != 7) {
    goto LABEL_66;
  }
  if (*(_DWORD *)v25 == 979788914 && *(_DWORD *)((char *)v24 + 43) == 1734427194) {
    goto LABEL_69;
  }
  BOOL v28 = *(_DWORD *)v25 == 979788914 && *(_DWORD *)((char *)v24 + 43) == 1902465850;
  uint64_t v29 = (int *)((char *)v24 + 40);
  if (v28) {
    goto LABEL_65;
  }
LABEL_47:
  int v30 = *v29;
  int v31 = *(int *)((char *)v29 + 3);
  if (v30 != 979788914 || v31 != 1953251642) {
    goto LABEL_66;
  }
  int v33 = *((_DWORD *)v12 + 2) | 0xE00;
LABEL_70:
  *((_DWORD *)v12 + 2) = v33;
LABEL_78:
  RDF_Parser::NodeElement(this, v12, v24, 0);
  int v39 = *((_DWORD *)v12 + 2);
  if ((v39 & 0x10000000) != 0)
  {
    RDF_Parser::FixupQualifiedNode(this, v12);
  }
  else if ((v39 & 0x800) != 0)
  {
    DetectAltText((std::string *)v12);
  }
  int v40 = v23 + 1;
  while (v40 != v22)
  {
    uint64_t v41 = *v40++;
    if (!XML_Node::IsWhitespaceNode(v41))
    {
      v43.__r_.__value_.__r.__words[2] = 0;
      int v34 = "Invalid child of resource property element";
      goto LABEL_86;
    }
  }
}

void sub_1885D6304(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t RDF_Parser::EmptyPropertyElement(RDF_Parser *this, XMP_Node *a2, const XML_Node *a3, int a4)
{
  if (*((void *)a3 + 16) != *((void *)a3 + 17))
  {
    uint64_t v35 = 0;
    unsigned int v5 = 202;
    BOOL v6 = "Nested content not allowed with rdf:resource or property attributes";
    goto LABEL_3;
  }
  int v10 = (uint64_t *)*((void *)a3 + 13);
  uint64_t v11 = (uint64_t *)*((void *)a3 + 14);
  if (v10 == v11)
  {
    uint64_t v16 = 0;
    int v15 = 0;
    int v13 = 0;
    char v12 = 0;
LABEL_38:
    uint64_t result = RDF_Parser::AddChildNode(this, a2, a3, "", a4);
    if (!result) {
      return result;
    }
    int v23 = (XMP_Node *)result;
    if ((v15 | v13))
    {
      uint64_t result = (uint64_t)std::string::operator=((std::string *)(result + 40), (const std::string *)(v16 + 64));
      if ((v15 & 1) == 0)
      {
        int v24 = 2;
LABEL_44:
        char v25 = (v15 | v13) ^ 1;
        *((_DWORD *)v23 + 2) |= v24;
LABEL_46:
        int v27 = (uint64_t *)*((void *)a3 + 13);
        int v26 = (uint64_t *)*((void *)a3 + 14);
        if (v27 == v26) {
          return result;
        }
        while (*v27 == v16)
        {
LABEL_62:
          if (++v27 == v26) {
            return result;
          }
        }
        uint64_t result = GetRDFTermKind(*v27 + 40);
        switch((int)result)
        {
          case 0:
            uint64_t v28 = *v27;
            if ((v25 & 1) == 0) {
              goto LABEL_55;
            }
            uint64_t v29 = (void *)(v28 + 40);
            int v30 = *(char *)(v28 + 63);
            if (v30 < 0)
            {
              if (*(void *)(v28 + 48) != 8)
              {
LABEL_59:
                int v31 = (const char *)(v28 + 64);
                if (*(char *)(v28 + 87) < 0) {
                  int v31 = *(const char **)v31;
                }
                uint64_t result = RDF_Parser::AddChildNode(this, v23, (const XML_Node *)v28, v31, 0);
                goto LABEL_62;
              }
              uint64_t v29 = (void *)*v29;
            }
            else if (v30 != 8)
            {
              goto LABEL_59;
            }
            if (*v29 == 0x676E616C3A6C6D78) {
              goto LABEL_55;
            }
            goto LABEL_59;
          case 2:
          case 6:
            goto LABEL_62;
          case 5:
            uint64_t v28 = *v27;
LABEL_55:
            uint64_t result = RDF_Parser::AddQualifierNode(this, v23, (const XML_Node *)v28);
            goto LABEL_62;
          default:
            int v34 = "Unrecognized attribute of empty property element";
            uint64_t v35 = 0;
            uint64_t v33 = 202;
            uint64_t result = GenericErrorCallback::NotifyClient(*(void *)this, 0, (unsigned int *)&v33, 0);
            goto LABEL_62;
        }
      }
    }
    else if (v12)
    {
      int v24 = 256;
      goto LABEL_44;
    }
    char v25 = 0;
    goto LABEL_46;
  }
  char v12 = 0;
  int v13 = 0;
  char v14 = 0;
  int v15 = 0;
  uint64_t v16 = 0;
  while (2)
  {
    switch(GetRDFTermKind(*v10 + 40))
    {
      case 0u:
        uint64_t v17 = *v10 + 40;
        if ((*(char *)(*v10 + 63) & 0x80000000) == 0)
        {
          int v18 = *(unsigned __int8 *)(*v10 + 63);
          if (v18 != 8)
          {
            if (v18 == 9 && *(void *)v17 == 0x756C61763A666472 && *(unsigned char *)(*v10 + 48) == 101) {
              goto LABEL_35;
            }
            goto LABEL_31;
          }
LABEL_30:
          BOOL v22 = *(void *)v17 != 0x676E616C3A6C6D78;
LABEL_32:
          v12 |= v22;
LABEL_33:
          if (++v10 == v11) {
            goto LABEL_38;
          }
          continue;
        }
        uint64_t v20 = *(void *)(*v10 + 48);
        if (v20 == 8)
        {
          uint64_t v17 = *(void *)v17;
          goto LABEL_30;
        }
        if (v20 != 9
          || (**(void **)v17 == 0x756C61763A666472 ? (BOOL v21 = *(unsigned char *)(*(void *)v17 + 8) == 101) : (BOOL v21 = 0),
              !v21))
        {
LABEL_31:
          BOOL v22 = 1;
          goto LABEL_32;
        }
LABEL_35:
        if ((v13 & 1) == 0)
        {
          int v13 = 0;
          int v15 = 1;
          uint64_t v16 = *v10;
          goto LABEL_33;
        }
LABEL_66:
        uint64_t v35 = 0;
        unsigned int v5 = 203;
        BOOL v6 = "Empty property element can't have both rdf:value and rdf:resource";
LABEL_3:
        int v34 = v6;
        uint64_t v33 = v5;
        return GenericErrorCallback::NotifyClient(*(void *)this, 0, (unsigned int *)&v33, 0);
      case 2u:
        goto LABEL_33;
      case 5u:
        if (v14) {
          goto LABEL_64;
        }
        if (v15) {
          goto LABEL_66;
        }
        int v15 = 0;
        char v14 = 0;
        uint64_t v16 = *v10;
        int v13 = 1;
        goto LABEL_33;
      case 6u:
        if (v13)
        {
LABEL_64:
          uint64_t v35 = 0;
          unsigned int v5 = 202;
          BOOL v6 = "Empty property element can't have both rdf:resource and rdf:nodeID";
          goto LABEL_3;
        }
        int v13 = 0;
        char v14 = 1;
        goto LABEL_33;
      default:
        uint64_t v35 = 0;
        unsigned int v5 = 202;
        BOOL v6 = "Unrecognized attribute of empty property element";
        goto LABEL_3;
    }
  }
}

void RDF_Parser::NodeElementList(RDF_Parser *this, size_t *a2, const XML_Node *a3, char a4)
{
  if ((a4 & 1) == 0) {
    RDF_Parser::NodeElementList();
  }
  vImagePixelCount v4 = (const XML_Node **)*((void *)a3 + 16);
  for (CFIndex i = (const XML_Node **)*((void *)a3 + 17); v4 != i; ++v4)
  {
    if (!XML_Node::IsWhitespaceNode(*v4)) {
      RDF_Parser::NodeElement(this, a2, *v4, 1);
    }
  }
}

void RDF_Parser::PropertyElementList(RDF_Parser *this, XMP_Node *a2, const XML_Node *a3, int a4)
{
  vImagePixelCount v4 = (const XML_Node **)*((void *)a3 + 16);
  for (CFIndex i = (const XML_Node **)*((void *)a3 + 17); v4 != i; ++v4)
  {
    if (!XML_Node::IsWhitespaceNode(*v4))
    {
      if (*((unsigned char *)*v4 + 8) == 1)
      {
        RDF_Parser::PropertyElement(this, a2, *v4, a4);
      }
      else
      {
        v9[1] = "Expected property element node not found";
        _DWORD v9[2] = 0;
        v9[0] = 202;
        GenericErrorCallback::NotifyClient(*(void *)this, 0, (unsigned int *)v9, 0);
      }
    }
  }
}

BOOL XML_Node::IsWhitespaceNode(XML_Node *this)
{
  if (*((unsigned char *)this + 8) != 3) {
    return 0;
  }
  for (unint64_t i = 0; ; ++i)
  {
    unint64_t v2 = *((unsigned __int8 *)this + 87);
    if ((*((unsigned char *)this + 87) & 0x80) != 0) {
      unint64_t v2 = *((void *)this + 9);
    }
    BOOL v3 = i >= v2;
    BOOL v4 = i >= v2;
    if (v3) {
      break;
    }
    unsigned int v5 = (char *)this + 64;
    if ((*((unsigned char *)this + 87) & 0x80) != 0) {
      unsigned int v5 = (char *)*((void *)this + 8);
    }
    unsigned int v6 = v5[i];
    BOOL v7 = v6 > 0x20;
    uint64_t v8 = (1 << v6) & 0x100002600;
    if (v7 || v8 == 0) {
      break;
    }
  }
  return v4;
}

void RDF_Parser::PropertyElement(RDF_Parser *this, XMP_Node *a2, const XML_Node *a3, int a4)
{
  unsigned int RDFTermKind = GetRDFTermKind((uint64_t)a3 + 40);
  if (RDFTermKind > 9 || RDFTermKind - 9 >= 0xFFFFFFF8)
  {
    uint64_t v35 = 0;
    unsigned int v10 = 202;
    uint64_t v11 = "Invalid property element name";
    goto LABEL_7;
  }
  int v13 = (uint64_t *)*((void *)a3 + 13);
  char v12 = (uint64_t *)*((void *)a3 + 14);
  if ((unint64_t)((char *)v12 - (char *)v13) > 0x18) {
    goto LABEL_9;
  }
  if (v13 == v12)
  {
LABEL_31:
    uint64_t v20 = *((void *)a3 + 16);
    uint64_t v21 = *((void *)a3 + 17);
    if (v20 == v21) {
      goto LABEL_9;
    }
    while (*(unsigned char *)(*(void *)v20 + 8) == 3)
    {
      v20 += 8;
      if (v20 == v21) {
        goto LABEL_64;
      }
    }
    if (v20 != v21)
    {
      RDF_Parser::ResourcePropertyElement(this, a2, a3, a4);
      return;
    }
    goto LABEL_64;
  }
  while (1)
  {
    uint64_t v14 = *v13;
    uint64_t v15 = *v13 + 40;
    int v16 = *(unsigned __int8 *)(*v13 + 63);
    if ((*(char *)(*v13 + 63) & 0x80000000) == 0)
    {
      switch(*(unsigned char *)(*v13 + 63))
      {
        case 6:
          if (*(_DWORD *)v15 == 979788914 && *(_WORD *)(*v13 + 44) == 17481) {
            goto LABEL_30;
          }
          goto LABEL_42;
        case 8:
          if (*(void *)v15 == 0x676E616C3A6C6D78) {
            goto LABEL_30;
          }
LABEL_42:
          if (v16 == 12) {
            goto LABEL_52;
          }
          if (v16 == 13) {
            goto LABEL_44;
          }
          goto LABEL_9;
        case 0xC:
LABEL_52:
          if (*(void *)v15 != 0x617461643A666472 || *(_DWORD *)(*v13 + 48) != 1701869940) {
            goto LABEL_9;
          }
          goto LABEL_64;
        case 0xD:
          goto LABEL_44;
        default:
          goto LABEL_9;
      }
    }
    uint64_t v18 = *(void *)(v14 + 48);
    if (v18 == 6) {
      break;
    }
    if (v18 != 8 || **(void **)v15 != 0x676E616C3A6C6D78) {
      goto LABEL_39;
    }
LABEL_30:
    if (++v13 == v12) {
      goto LABEL_31;
    }
  }
  if (**(_DWORD **)v15 == 979788914 && *(_WORD *)(*(void *)v15 + 4) == 17481) {
    goto LABEL_30;
  }
LABEL_39:
  uint64_t v22 = *(void *)(v14 + 48);
  if (v22 != 12)
  {
LABEL_40:
    if (v22 != 13) {
      goto LABEL_9;
    }
    uint64_t v15 = *(void *)v15;
LABEL_44:
    uint64_t v23 = *(void *)v15;
    uint64_t v24 = *(void *)(v15 + 5);
    if (v23 != 0x737261703A666472 || v24 != 0x6570795465737261) {
      goto LABEL_9;
    }
    int v26 = (int **)(v14 + 64);
    int v27 = *(char *)(v14 + 87);
    if (v27 < 0)
    {
      if (*(void *)(v14 + 72) != 7) {
        goto LABEL_73;
      }
      uint64_t v28 = *v26;
    }
    else
    {
      uint64_t v28 = (int *)(v14 + 64);
      if (v27 != 7) {
        goto LABEL_73;
      }
    }
    int v31 = *v28;
    int v32 = *(int *)((char *)v28 + 3);
    if (v31 == 1702127948 && v32 == 1818325605)
    {
      uint64_t v35 = 0;
      unsigned int v10 = 203;
      uint64_t v11 = "ParseTypeLiteral property element not allowed";
    }
    else
    {
LABEL_73:
      if (std::operator==[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>(v26, "Resource"))
      {
        RDF_Parser::ParseTypeResourcePropertyElement(this, a2, (const XML_Node ***)a3, a4);
        return;
      }
      uint64_t v35 = 0;
      if (std::operator==[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>(v26, "Collection"))
      {
        unsigned int v10 = 203;
        uint64_t v11 = "ParseTypeCollection property element not allowed";
      }
      else
      {
        unsigned int v10 = 203;
        uint64_t v11 = "ParseTypeOther property element not allowed";
      }
    }
LABEL_7:
    v34[1] = v11;
    v34[0] = v10;
    GenericErrorCallback::NotifyClient(*(void *)this, 0, (unsigned int *)v34, 0);
    return;
  }
  if (**(void **)v15 == 0x617461643A666472 && *(_DWORD *)(*(void *)v15 + 8) == 1701869940)
  {
LABEL_64:
    RDF_Parser::LiteralPropertyElement(this, a2, (const XML_Node ***)a3, a4);
    return;
  }
  if ((v16 & 0x80) != 0) {
    goto LABEL_40;
  }
LABEL_9:

  RDF_Parser::EmptyPropertyElement(this, a2, a3, a4);
}

uint64_t GetRDFTermKind(uint64_t a1)
{
  if (*(char *)(a1 + 23) < 0)
  {
    unint64_t v6 = *(void *)(a1 + 8);
    if (v6 <= 4) {
      return 0;
    }
    BOOL v7 = *(const char **)a1;
    if (strncmp(*(const char **)a1, "rdf:", 4uLL)) {
      return 0;
    }
    if (v6 == 6 && *(_DWORD *)v7 == 979788914 && *((_WORD *)v7 + 2) == 26988) {
      return 9;
    }
    if (v6 == 13)
    {
      if (**(void **)a1 == 0x737261703A666472 && *(void *)(*(void *)a1 + 5) == 0x6570795465737261) {
        return 4;
      }
      unint64_t v6 = *(void *)(a1 + 8);
    }
    if (v6 == 15)
    {
      if (**(void **)a1 == 0x637365443A666472 && *(void *)(*(void *)a1 + 7) == 0x6E6F697470697263) {
        return 8;
      }
      unint64_t v6 = *(void *)(a1 + 8);
    }
    if (v6 == 9)
    {
      BOOL v4 = *(const char **)a1;
      goto LABEL_47;
    }
  }
  else
  {
    unsigned int v2 = *(unsigned __int8 *)(a1 + 23);
    if (v2 < 5 || *(_DWORD *)a1 != 979788914) {
      return 0;
    }
    BOOL v4 = (const char *)a1;
    switch(*(unsigned char *)(a1 + 23))
    {
      case 6:
        if (*(_DWORD *)a1 != 979788914 || *(_WORD *)(a1 + 4) != 26988) {
          goto LABEL_51;
        }
        return 9;
      case 9:
        goto LABEL_47;
      case 0xD:
        if (*(void *)a1 == 0x737261703A666472 && *(void *)(a1 + 5) == 0x6570795465737261) {
          return 4;
        }
        break;
      case 0xF:
        if (*(void *)a1 == 0x637365443A666472 && *(void *)(a1 + 7) == 0x6E6F697470697263) {
          return 8;
        }
        break;
      default:
        goto LABEL_51;
    }
    BOOL v4 = (const char *)a1;
    if (v2 == 9)
    {
LABEL_47:
      if (*(void *)v4 == 0x756F62613A666472 && v4[8] == 116) {
        return 3;
      }
    }
  }
LABEL_51:
  if (std::operator==[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>((void *)a1, "rdf:resource")) {
    return 5;
  }
  if (std::operator==[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>((void *)a1, "rdf:RDF")) {
    return 1;
  }
  if (std::operator==[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>((void *)a1, "rdf:ID")) {
    return 2;
  }
  if (std::operator==[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>((void *)a1, "rdf:nodeID")) {
    return 6;
  }
  if (std::operator==[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>((void *)a1, "rdf:datatype")) {
    return 7;
  }
  if (std::operator==[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>((void *)a1, "rdf:aboutEach")) {
    return 10;
  }
  if (std::operator==[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>((void *)a1, "rdf:aboutEachPrefix"))
  {
    return 11;
  }
  if (std::operator==[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>((void *)a1, "rdf:bagID")) {
    return 12;
  }
  return 0;
}

void RDF_Parser::LiteralPropertyElement(RDF_Parser *this, XMP_Node *a2, const XML_Node ***a3, int a4)
{
  uint64_t v6 = RDF_Parser::AddChildNode(this, a2, (const XML_Node *)a3, "", a4);
  if (v6)
  {
    uint64_t v7 = v6;
    uint64_t v8 = a3[13];
    for (unint64_t i = a3[14]; v8 != i; ++v8)
    {
      unsigned int v10 = *v8;
      uint64_t v11 = (_DWORD *)((char *)*v8 + 40);
      if (*((char *)*v8 + 63) < 0)
      {
        uint64_t v13 = *((void *)v10 + 6);
        if (v13 == 6)
        {
          if (**(_DWORD **)v11 == 979788914 && *(_WORD *)(*(void *)v11 + 4) == 17481) {
            continue;
          }
          uint64_t v13 = *((void *)v10 + 6);
        }
        else if (v13 == 8 && **(void **)v11 == 0x676E616C3A6C6D78)
        {
LABEL_35:
          RDF_Parser::AddQualifierNode(this, (XMP_Node *)v7, v10);
          continue;
        }
        if (v13 == 12)
        {
          uint64_t v11 = *(_DWORD **)v11;
LABEL_19:
          uint64_t v15 = *(void *)v11;
          int v16 = v11[2];
          if (v15 == 0x617461643A666472 && v16 == 1701869940) {
            continue;
          }
        }
      }
      else
      {
        int v12 = *((unsigned __int8 *)*v8 + 63);
        switch(v12)
        {
          case 6:
            if (*v11 == 979788914 && *((_WORD *)*v8 + 22) == 17481) {
              continue;
            }
            break;
          case 8:
            if (*(void *)v11 == 0x676E616C3A6C6D78) {
              goto LABEL_35;
            }
            break;
          case 12:
            goto LABEL_19;
        }
      }
      uint64_t v33 = "Invalid attribute for literal property element";
      uint64_t v34 = 0;
      uint64_t v32 = 202;
      GenericErrorCallback::NotifyClient(*(void *)this, 0, (unsigned int *)&v32, 0);
    }
    uint64_t v20 = a3[16];
    int v19 = a3[17];
    if (v20 == v19)
    {
      std::string::size_type v21 = 0;
    }
    else
    {
      std::string::size_type v21 = 0;
      do
      {
        uint64_t v22 = *v20;
        if (*((unsigned char *)*v20 + 8) == 3)
        {
          if (*((char *)v22 + 87) < 0) {
            uint64_t v23 = *((void *)v22 + 9);
          }
          else {
            uint64_t v23 = *((unsigned __int8 *)v22 + 87);
          }
          v21 += v23;
        }
        else
        {
          uint64_t v33 = "Invalid child of literal property element";
          uint64_t v34 = 0;
          uint64_t v32 = 202;
          GenericErrorCallback::NotifyClient(*(void *)this, 0, (unsigned int *)&v32, 0);
        }
        ++v20;
      }
      while (v20 != v19);
    }
    std::string::reserve((std::string *)(v7 + 40), v21);
    uint64_t v24 = (uint64_t *)a3[16];
    while (v24 != (uint64_t *)v19)
    {
      uint64_t v25 = *v24++;
      int v26 = (const std::string::value_type *)(v25 + 64);
      int v27 = *(const std::string::value_type **)(v25 + 64);
      std::string::size_type v28 = *(unsigned __int8 *)(v25 + 87);
      std::string::size_type v29 = *(void *)(v25 + 72);
      if ((v28 & 0x80u) == 0) {
        int v30 = v26;
      }
      else {
        int v30 = v27;
      }
      if ((v28 & 0x80u) == 0) {
        std::string::size_type v31 = v28;
      }
      else {
        std::string::size_type v31 = v29;
      }
      std::string::append((std::string *)(v7 + 40), v30, v31);
    }
  }
}

uint64_t RDF_Parser::AddChildNode(RDF_Parser *this, XMP_Node *a2, const XML_Node *a3, const char *a4, int a5)
{
  uint64_t v6 = *((unsigned __int8 *)a3 + 39);
  int v7 = (char)v6;
  if ((v6 & 0x80u) != 0) {
    uint64_t v6 = *((void *)a3 + 3);
  }
  if (v6)
  {
    char v8 = a5;
    unsigned int v10 = a2;
    uint64_t v11 = (const void **)((char *)a3 + 40);
    if (*((char *)a3 + 63) < 0)
    {
      int v19 = (char *)*((void *)a3 + 5);
      uint64_t v18 = *((void *)a3 + 6);
      BOOL v15 = v18 == 6 && *(_DWORD *)v19 == 979788914 && *((_WORD *)v19 + 2) == 26988;
      BOOL v13 = v18 == 9 && *(void *)v19 == 0x756C61763A666472 && v19[8] == 101;
    }
    else
    {
      int v12 = *((unsigned __int8 *)a3 + 63);
      if (v12 == 9)
      {
        BOOL v15 = 0;
        BOOL v13 = *v11 == (const void *)0x756C61763A666472 && *((unsigned char *)a3 + 48) == 101;
      }
      else if (v12 == 6)
      {
        BOOL v13 = 0;
        BOOL v15 = *(_DWORD *)v11 == 979788914 && *((_WORD *)a3 + 22) == 26988;
      }
      else
      {
        BOOL v13 = 0;
        BOOL v15 = 0;
      }
      int v19 = (char *)a3 + 40;
    }
    int v23 = *((_DWORD *)a2 + 2);
    if (!a5) {
      goto LABEL_51;
    }
    if (*((void *)a2 + 8)) {
      RDF_Parser::AddChildNode();
    }
    if (v7 >= 0) {
      uint64_t v24 = (char *)a3 + 16;
    }
    else {
      uint64_t v24 = (char *)*((void *)a3 + 2);
    }
    uint64_t SchemaNode = FindSchemaNode(v10, v24, 1, 0);
    unsigned int v10 = (XMP_Node *)SchemaNode;
    int v26 = *(_DWORD *)(SchemaNode + 8);
    if ((v26 & 0x8000) != 0) {
      *(_DWORD *)(SchemaNode + 8) = v26 ^ 0x8000;
    }
    if (sRegisteredAliasMap + 8 == std::__tree<std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>>>::find<std::string>(sRegisteredAliasMap, v11))
    {
LABEL_51:
      if (!v15) {
        goto LABEL_47;
      }
    }
    else
    {
      *(_DWORD *)(*((void *)v10 + 8) + 8) |= 0x20000u;
      if (!v15)
      {
LABEL_47:
        if ((v23 & 0x200) == 0)
        {
          if (!v13)
          {
            if (FindChildNode((uint64_t)v10, v19, 0, 0))
            {
              uint64_t v36 = 0;
              unsigned int v16 = 203;
              uint64_t v17 = "Duplicate property or field node";
              goto LABEL_77;
            }
LABEL_79:
            v35[0] = 0;
            operator new();
          }
LABEL_74:
          if ((v8 & 1) != 0 || (int v33 = *((_DWORD *)v10 + 2), (v33 & 0x100) == 0))
          {
            uint64_t v36 = 0;
            unsigned int v16 = 202;
            uint64_t v17 = "Misplaced rdf:value element";
            goto LABEL_77;
          }
          *((_DWORD *)v10 + 2) = v33 | 0x10000000;
          goto LABEL_79;
        }
        uint64_t v27 = *((unsigned __int8 *)a3 + 63);
        if (*((char *)a3 + 63) < 0)
        {
          if (*((void *)a3 + 6) < 6uLL)
          {
LABEL_60:
            uint64_t v36 = 0;
            unsigned int v16 = 202;
            uint64_t v17 = "Array items cannot have arbitrary child names";
            goto LABEL_77;
          }
          std::string::size_type v28 = (const char *)*v11;
        }
        else
        {
          std::string::size_type v28 = (const char *)v11;
          if (v27 < 6) {
            goto LABEL_60;
          }
        }
        if (strncmp(v28, "rdf:_", 5uLL)) {
          goto LABEL_60;
        }
        unint64_t v29 = (v27 & 0x80u) == 0 ? v27 : *((void *)a3 + 6);
        if (v29 >= 6)
        {
          int v30 = (v27 & 0x80u) == 0 ? v11 : (const void **)*v11;
          if (*((unsigned __int8 *)v30 + 5) - 58 < 0xFFFFFFF6) {
            goto LABEL_60;
          }
          uint64_t v31 = 6;
          do
          {
            unint64_t v32 = v31;
            if (v29 == v31) {
              break;
            }
            ++v31;
          }
          while (*((unsigned __int8 *)v30 + v32) - 58 > 0xFFFFFFF5);
          if (v32 < v29) {
            goto LABEL_60;
          }
        }
LABEL_73:
        if (!v13) {
          goto LABEL_79;
        }
        goto LABEL_74;
      }
    }
    if ((v23 & 0x200) == 0)
    {
      uint64_t v36 = 0;
      unsigned int v16 = 202;
      uint64_t v17 = "Misplaced rdf:li element";
      goto LABEL_77;
    }
    goto LABEL_73;
  }
  uint64_t v36 = 0;
  unsigned int v16 = 202;
  uint64_t v17 = "XML namespace required for all elements and attributes";
LABEL_77:
  v35[1] = v17;
  v35[0] = v16;
  GenericErrorCallback::NotifyClient(*(void *)this, 0, (unsigned int *)v35, 0);
  return 0;
}

void sub_1885D76B0(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10B3C407D34617ELL);
  _Unwind_Resume(a1);
}

void XMP_Node::XMP_Node(XMP_Node *this, XMP_Node *a2, char *__s, char *a4, int a5)
{
  *(void *)this = &unk_1ED4E5D30;
  *((_DWORD *)this + 2) = a5;
  char v8 = (const std::string *)((char *)this + 16);
  std::string::basic_string[abi:ne180100]<0>((void *)this + 2, __s);
  std::string::basic_string[abi:ne180100]<0>((void *)this + 5, a4);
  *(_OWORD *)((char *)this + 72) = 0u;
  *((void *)this + 8) = a2;
  *(_OWORD *)((char *)this + 88) = 0u;
  *(_OWORD *)((char *)this + 104) = 0u;
  if (std::string::find(v8, 58, 0) != -1) {
    return;
  }
  int v9 = *((char *)this + 39);
  if (v9 < 0)
  {
    if (*((void *)this + 3) != 2) {
      goto LABEL_8;
    }
    unsigned int v10 = (const std::string *)v8->__r_.__value_.__r.__words[0];
LABEL_7:
    if (LOWORD(v10->__r_.__value_.__l.__data_) == 23899) {
      return;
    }
    goto LABEL_8;
  }
  unsigned int v10 = v8;
  if (v9 == 2) {
    goto LABEL_7;
  }
LABEL_8:
  if ((*((_DWORD *)this + 2) & 0x80000000) == 0)
  {
    if (*((void *)this + 8)) {
      __assert_rtn("XMP_Node", "XMPCore_Impl.hpp", 348, "(name.find(':') != XMP_VarString::npos) || (name == \"[]\") || (options & ((XMP_OptionBits)0x80000000UL)) || (parent == 0)");
    }
  }
}

void sub_1885D77E8(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 39) < 0) {
    operator delete(*v2);
  }
  _Unwind_Resume(exception_object);
}

void RDF_Parser::NodeElement(RDF_Parser *this, size_t *a2, const XML_Node *a3, int a4)
{
  int RDFTermKind = GetRDFTermKind((uint64_t)a3 + 40);
  if ((RDFTermKind & 7) != 0)
  {
    uint64_t v12 = 0;
    unsigned int v9 = 202;
    unsigned int v10 = "Node element must be rdf:Description or typedNode";
LABEL_6:
    v11[1] = v10;
    v11[0] = v9;
    GenericErrorCallback::NotifyClient(*(void *)this, 0, (unsigned int *)v11, 0);
    return;
  }
  if (!RDFTermKind && a4)
  {
    uint64_t v12 = 0;
    unsigned int v9 = 203;
    unsigned int v10 = "Top level typedNode not allowed";
    goto LABEL_6;
  }
  RDF_Parser::NodeElementAttrs((uint64_t)this, a2, a3, a4);

  RDF_Parser::PropertyElementList(this, (XMP_Node *)a2, a3, a4);
}

uint64_t RDF_Parser::NodeElementAttrs(uint64_t this, size_t *a2, const XML_Node *a3, int a4)
{
  BOOL v4 = (const XML_Node **)*((void *)a3 + 13);
  unsigned int v5 = (const XML_Node **)*((void *)a3 + 14);
  if (v4 != v5)
  {
    char v8 = (RDF_Parser *)this;
    int v9 = 0;
    std::string::size_type v21 = (std::string *)(a2 + 2);
    while (1)
    {
      this = GetRDFTermKind((uint64_t)*v4 + 40);
      if ((this - 2) >= 2)
      {
        if (!this)
        {
          BOOL v13 = (char *)*v4 + 64;
          if (*((char *)*v4 + 87) < 0) {
            BOOL v13 = *(const char **)v13;
          }
          this = RDF_Parser::AddChildNode(v8, (XMP_Node *)a2, *v4, v13, a4);
          goto LABEL_21;
        }
        if (this != 6) {
          break;
        }
      }
      if ((v9 & 0x4C) == 0)
      {
        v9 |= 1 << this;
        if (this != 3 || a4 == 0) {
          goto LABEL_21;
        }
        if (a2[8]) {
          RDF_Parser::NodeElementAttrs();
        }
        uint64_t v11 = *((unsigned __int8 *)a2 + 39);
        if (*((char *)a2 + 39) < 0) {
          size_t v12 = a2[3];
        }
        else {
          size_t v12 = *((unsigned __int8 *)a2 + 39);
        }
        BOOL v15 = *v4;
        unsigned int v16 = (const std::string *)((char *)*v4 + 64);
        if (!v12)
        {
          this = (uint64_t)std::string::operator=(v21, v16);
          goto LABEL_21;
        }
        uint64_t v17 = *((unsigned __int8 *)v15 + 87);
        if (*((char *)v15 + 87) < 0)
        {
          if (!*((void *)v15 + 9)) {
            goto LABEL_21;
          }
        }
        else if (!*((unsigned char *)v15 + 87))
        {
          goto LABEL_21;
        }
        if ((v11 & 0x80u) == 0) {
          size_t v18 = *((unsigned __int8 *)a2 + 39);
        }
        else {
          size_t v18 = a2[3];
        }
        uint64_t v19 = *((void *)v15 + 9);
        if ((v17 & 0x80u) == 0) {
          uint64_t v19 = v17;
        }
        if (v18 == v19)
        {
          if ((v17 & 0x80u) != 0) {
            unsigned int v16 = (const std::string *)v16->__r_.__value_.__r.__words[0];
          }
          if ((v11 & 0x80) != 0)
          {
            this = memcmp(v21->__r_.__value_.__l.__data_, v16, a2[3]);
            if (!this) {
              goto LABEL_21;
            }
          }
          else
          {
            if (!*((unsigned char *)a2 + 39)) {
              goto LABEL_21;
            }
            uint64_t v20 = v21;
            while (v20->__r_.__value_.__s.__data_[0] == v16->__r_.__value_.__s.__data_[0])
            {
              uint64_t v20 = (std::string *)((char *)v20 + 1);
              unsigned int v16 = (const std::string *)((char *)v16 + 1);
              if (!--v11) {
                goto LABEL_21;
              }
            }
          }
        }
        uint64_t v24 = 0;
        uint64_t v22 = 203;
        uint64_t v14 = "Mismatched top level rdf:about values";
        goto LABEL_19;
      }
      int v23 = "Mutally exclusive about, ID, nodeID attributes";
      uint64_t v24 = 0;
      uint64_t v22 = 202;
LABEL_20:
      this = GenericErrorCallback::NotifyClient(*(void *)v8, 0, (unsigned int *)&v22, 0);
LABEL_21:
      if (++v4 == v5) {
        return this;
      }
    }
    uint64_t v24 = 0;
    uint64_t v22 = 202;
    uint64_t v14 = "Invalid nodeElement attribute";
LABEL_19:
    int v23 = v14;
    goto LABEL_20;
  }
  return this;
}

void TouchUpDataModel(XMPMeta *a1, XMPMeta::ErrorCallbackInfo *a2)
{
  BOOL v3 = (XMPMeta *)((char *)a1 + 224);
  uint64_t SchemaNode = FindSchemaNode((void *)a1 + 28, "http://ns.adobe.com/exif/1.0/", 0, 0);
  if (SchemaNode)
  {
    uint64_t v5 = SchemaNode;
    uint64_t ChildNode = FindChildNode(SchemaNode, "exif:GPSTimeStamp", 0, 0);
    if (ChildNode)
    {
      int v7 = (std::string *)(ChildNode + 40);
      uint64_t v66 = 0;
      *(_OWORD *)std::string __p = 0u;
      long long v65 = 0u;
      int v8 = *(char *)(ChildNode + 63);
      int v9 = (char *)(ChildNode + 40);
      if (v8 < 0) {
        int v9 = (char *)v7->__r_.__value_.__r.__words[0];
      }
      XMPUtils::ConvertToDate(v9, (uint64_t)__p);
      if (!LODWORD(__p[0]) && __PAIR64__(HIDWORD(__p[0]), 0) == LODWORD(__p[1]))
      {
        uint64_t v10 = FindChildNode(v5, "exif:DateTimeOriginal", 0, 0);
        if (v10 || (uint64_t v10 = FindChildNode(v5, "exif:DateTimeDigitized", 0, 0)) != 0)
        {
          uint64_t v11 = (char *)(v10 + 40);
          uint64_t v63 = 0;
          memset(v62, 0, sizeof(v62));
          if (*(char *)(v10 + 63) < 0) {
            uint64_t v11 = *(char **)v11;
          }
          XMPUtils::ConvertToDate(v11, (uint64_t)v62);
          __p[0] = *(void **)&v62[0];
          LODWORD(__p[1]) = DWORD2(v62[0]);
          XMPUtils::ConvertFromDate((long long *)__p, v7);
        }
      }
    }
    uint64_t v12 = FindChildNode(v5, "exif:UserComment", 0, 0);
    if (v12 && (*(unsigned char *)(v12 + 9) & 0x1F) == 0) {
      operator new();
    }
  }
  uint64_t v13 = FindSchemaNode(v3, "http://ns.adobe.com/xmp/1.0/DynamicMedia/", 0, 0);
  if (v13)
  {
    uint64_t v14 = FindChildNode(v13, "xmpDM:copyright", 0, 0);
    if (v14)
    {
      uint64_t v15 = v14;
      uint64_t v16 = FindSchemaNode(v3, "http://purl.org/dc/elements/1.1/", 1, 0);
      uint64_t v17 = FindChildNode(v16, "dc:rights", 0, 0);
      uint64_t v18 = v17;
      uint64_t v19 = (const std::string::value_type *)(v15 + 40);
      if (!v17 || *(void *)(v17 + 72) == *(void *)(v17 + 80))
      {
        std::string::insert((std::string *)(v15 + 40), 0, "\n\n");
        if (*(char *)(v15 + 63) < 0) {
          uint64_t v19 = *(const std::string::value_type **)v19;
        }
        (*(void (**)(XMPMeta *, const char *, const char *, const char *, const char *, const std::string::value_type *, void))(*(void *)a1 + 128))(a1, "http://purl.org/dc/elements/1.1/", "rights", "", "x-default", v19, 0);
        goto LABEL_71;
      }
      __p[0] = 0;
      __p[1] = 0;
      *(void *)&long long v65 = 0;
      std::string::basic_string[abi:ne180100]<0>(__p, "x-default");
      int v20 = LookupLangItem(v18, (unsigned __int8 **)__p);
      if (v20 < 0)
      {
        uint64_t v21 = **(void **)(v18 + 72);
        uint64_t v22 = (void *)(v21 + 40);
        if (*(char *)(v21 + 63) < 0) {
          uint64_t v22 = (void *)*v22;
        }
        (*(void (**)(XMPMeta *, const char *, const char *, const char *, const char *, void *, void))(*(void *)a1 + 128))(a1, "http://purl.org/dc/elements/1.1/", "rights", "", "x-default", v22, 0);
        int v20 = LookupLangItem(v18, (unsigned __int8 **)__p);
      }
      if (v20) {
        __assert_rtn("MigrateAudioCopyright", "XMPMeta-Parse.cpp", 538, "xdIndex == 0");
      }
      uint64_t v23 = **(void **)(v18 + 72);
      uint64_t v24 = (unsigned __int8 **)(v23 + 40);
      std::string::size_type v25 = *(unsigned __int8 *)(v23 + 63);
      if (*(char *)(v23 + 63) < 0)
      {
        int v26 = *(char **)(v23 + 40);
        uint64_t v27 = *(void *)(v23 + 48);
      }
      else
      {
        int v26 = (char *)(v23 + 40);
        uint64_t v27 = *(unsigned __int8 *)(v23 + 63);
      }
      if (v27 >= 2)
      {
        std::string::size_type v28 = &v26[v27];
        unint64_t v29 = v26;
        while (1)
        {
          int v30 = (char *)memchr(v29, 10, v27 - 1);
          if (!v30) {
            goto LABEL_45;
          }
          if (*(_WORD *)v30 == 2570) {
            break;
          }
          unint64_t v29 = v30 + 1;
          uint64_t v27 = v28 - (unsigned char *)v29;
          if (v28 - (unsigned char *)v29 < 2) {
            goto LABEL_45;
          }
        }
        if (v30 != v28 && ((v30 - v26) & 0x80000000) == 0)
        {
          std::string::size_type v31 = (v30 - v26) + 2;
          int v32 = *(char *)(v15 + 63);
          int v33 = *(const std::string::value_type **)(v15 + 40);
          if (v32 >= 0) {
            std::string::size_type v34 = *(unsigned __int8 *)(v15 + 63);
          }
          else {
            std::string::size_type v34 = *(void *)(v15 + 48);
          }
          if ((v25 & 0x80) != 0)
          {
            std::string::size_type v25 = *(void *)(v23 + 48);
            if (v34 == -1 || v25 < v31) {
LABEL_115:
            }
              std::string::__throw_out_of_range[abi:ne180100]();
            uint64_t v35 = *v24;
          }
          else
          {
            if (v31 > v25) {
              goto LABEL_115;
            }
            uint64_t v35 = (unsigned __int8 *)(v23 + 40);
            if (v34 == -1) {
              goto LABEL_115;
            }
          }
          size_t v58 = v25 - v31;
          if (v32 < 0) {
            uint64_t v19 = v33;
          }
          if (v58 >= v34) {
            size_t v59 = v34;
          }
          else {
            size_t v59 = v58;
          }
          if (memcmp(&v35[v31], v19, v59) || v58 != v34) {
            std::string::replace((std::string *)(v23 + 40), v31, 0xFFFFFFFFFFFFFFFFLL, v19, v34);
          }
          goto LABEL_69;
        }
      }
LABEL_45:
      uint64_t v36 = *(unsigned __int8 *)(v15 + 63);
      if ((v36 & 0x80u) == 0) {
        uint64_t v37 = *(unsigned __int8 *)(v15 + 63);
      }
      else {
        uint64_t v37 = *(void *)(v15 + 48);
      }
      if ((v25 & 0x80u) == 0) {
        std::string::size_type v38 = v25;
      }
      else {
        std::string::size_type v38 = *(void *)(v23 + 48);
      }
      if (v37 == v38)
      {
        if ((v25 & 0x80u) == 0) {
          int v39 = (unsigned __int8 *)(v23 + 40);
        }
        else {
          int v39 = *v24;
        }
        if ((v36 & 0x80) != 0)
        {
          if (!memcmp(*(const void **)v19, v39, *(void *)(v15 + 48))) {
            goto LABEL_69;
          }
        }
        else
        {
          if (!*(unsigned char *)(v15 + 63)) {
            goto LABEL_69;
          }
          int v40 = (unsigned __int8 *)(v15 + 40);
          while (*v40 == *v39)
          {
            ++v40;
            ++v39;
            if (!--v36) {
              goto LABEL_69;
            }
          }
        }
      }
      std::string::append((std::string *)(v23 + 40), "\n\n");
      int v41 = *(char *)(v15 + 63);
      if (v41 >= 0) {
        uint64_t v42 = (const std::string::value_type *)(v15 + 40);
      }
      else {
        uint64_t v42 = *(const std::string::value_type **)(v15 + 40);
      }
      if (v41 >= 0) {
        std::string::size_type v43 = *(unsigned __int8 *)(v15 + 63);
      }
      else {
        std::string::size_type v43 = *(void *)(v15 + 48);
      }
      std::string::append((std::string *)(v23 + 40), v42, v43);
LABEL_69:
      if (SBYTE7(v65) < 0) {
        operator delete(__p[0]);
      }
LABEL_71:
      (*(void (**)(XMPMeta *, const char *, const char *))(*(void *)a1 + 80))(a1, "http://ns.adobe.com/xmp/1.0/DynamicMedia/", "copyright");
    }
  }
  uint64_t v44 = FindSchemaNode(v3, "http://purl.org/dc/elements/1.1/", 0, 0);
  if (v44)
  {
    uint64_t v45 = FindChildNode(v44, "dc:subject", 0, 0);
    if (v45) {
      *(_DWORD *)(v45 + 8) &= 0xFFFFE3FF;
    }
  }
  RepairAltText(v3, "http://purl.org/dc/elements/1.1/", "dc:description");
  RepairAltText(v3, "http://purl.org/dc/elements/1.1/", "dc:rights");
  RepairAltText(v3, "http://purl.org/dc/elements/1.1/", "dc:title");
  RepairAltText(v3, "http://ns.adobe.com/xap/1.0/rights/", "xmpRights:UsageTerms");
  RepairAltText(v3, "http://ns.adobe.com/exif/1.0/", "exif:UserComment");
  unsigned int v46 = (std::string *)((char *)a1 + 240);
  if (*((char *)a1 + 263) < 0)
  {
    uint64_t v47 = *((void *)a1 + 31);
    if (!v47) {
      return;
    }
    uint64_t v48 = (const char *)v46->__r_.__value_.__r.__words[0];
    if (!strncmp(v46->__r_.__value_.__l.__data_, "uuid:", 5uLL)) {
      goto LABEL_94;
    }
  }
  else
  {
    uint64_t v47 = *((unsigned __int8 *)a1 + 263);
    if (!*((unsigned char *)a1 + 263)) {
      return;
    }
    if (!strncmp((const char *)a1 + 240, "uuid:", 5uLL)) {
      goto LABEL_94;
    }
    uint64_t v48 = (char *)a1 + 240;
  }
  if (v47 == 36)
  {
    unint64_t v49 = 0;
    BOOL v50 = 1;
    while (1)
    {
      int v51 = v48[v49];
      if (v51 == 45)
      {
        if (v49 > 0x17 || ((1 << v49) & 0x842100) == 0) {
          return;
        }
      }
      else
      {
        unsigned int v52 = v51 - 48;
        unsigned int v53 = v51 - 97;
        if (v52 >= 0xA && v53 > 0x19)
        {
          if (!v50)
          {
LABEL_94:
            __p[0] = 0;
            __p[1] = 0;
            *(void *)&long long v65 = 0;
            ExpandXPath("http://ns.adobe.com/xap/1.0/mm/", "InstanceID", (uint64_t *)__p);
            uint64_t Node = FindNode(v3, (const void ***)__p, 1, 0, 0);
            int v56 = (void *)Node;
            if (!Node)
            {
              exception = __cxa_allocate_exception(0x18uLL);
              *(_DWORD *)exception = 9;
              exception[1] = "Failure creating xmpMM:InstanceID";
              *((unsigned char *)exception + 16) = 0;
            }
            *(_DWORD *)(Node + 8) = 0;
            std::string::operator=((std::string *)(Node + 40), v46);
            XMP_Node::RemoveChildren(v56);
            XMP_Node::RemoveQualifiers(v56);
            std::string::erase(v46, 0, 0xFFFFFFFFFFFFFFFFLL);
            *(void *)&v62[0] = __p;
            std::vector<XPathStepInfo>::__destroy_vector::operator()[abi:ne180100]((void ***)v62);
          }
          return;
        }
      }
      BOOL v50 = v49++ < 0x23;
      if (v49 == 36) {
        goto LABEL_94;
      }
    }
  }
}

void sub_1885D8464(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  MEMORY[0x18C11C0E0](v20, 0x10B3C407D34617ELL);
  _Unwind_Resume(a1);
}

uint64_t RepairAltText(XMP_Node *a1, char *a2, char *a3)
{
  uint64_t result = FindSchemaNode(a1, a2, 0, 0);
  if (result)
  {
    uint64_t result = FindChildNode(result, a3, 0, 0);
    if (result)
    {
      uint64_t v5 = result;
      if ((*(_DWORD *)(result + 8) & 0x1200) == 0x200)
      {
        *(_DWORD *)(result + 8) |= 0x1C00u;
        int v6 = ((*(void *)(result + 80) - *(void *)(result + 72)) >> 3) - 1;
        if (v6 >= 0)
        {
          while (1)
          {
            uint64_t v7 = v6;
            uint64_t v8 = *(void *)(*(void *)(v5 + 72) + 8 * v6);
            int v9 = *(_DWORD *)(v8 + 8);
            if ((v9 & 0x1F00) != 0) {
              goto LABEL_6;
            }
            if ((v9 & 0x40) == 0) {
              break;
            }
LABEL_15:
            int v6 = v7 - 1;
            if ((int)v7 <= 0) {
              return result;
            }
          }
          if (*(char *)(v8 + 63) < 0)
          {
            if (*(void *)(v8 + 48))
            {
LABEL_14:
              uint64_t v14 = 0;
              operator new();
            }
          }
          else if (*(unsigned char *)(v8 + 63))
          {
            goto LABEL_14;
          }
LABEL_6:
          uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)v8 + 8))(v8);
          uint64_t v10 = *(void *)(v5 + 72);
          uint64_t v11 = *(void *)(v5 + 80);
          uint64_t v12 = v10 + 8 * v7;
          uint64_t v13 = v11 - (v12 + 8);
          if (v11 != v12 + 8) {
            uint64_t result = (uint64_t)memmove((void *)(v10 + 8 * v7), (const void *)(v12 + 8), v11 - (v12 + 8));
          }
          *(void *)(v5 + 80) = v12 + v13;
          goto LABEL_15;
        }
      }
    }
  }
  return result;
}

void sub_1885D8740(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10B3C407D34617ELL);
  _Unwind_Resume(a1);
}

uint64_t FindSchemaNode(void *a1, char *__s, int a3, void *a4)
{
  if (a1[8]) {
    FindSchemaNode();
  }
  uint64_t v7 = (uint64_t *)a1[9];
  uint64_t v8 = a1[10] - (void)v7;
  if (!v8)
  {
LABEL_14:
    if (a3) {
      operator new();
    }
    return 0;
  }
  uint64_t v9 = v8 >> 3;
  while (1)
  {
    uint64_t v10 = *v7;
    if (*(void **)(*v7 + 64) != a1) {
      FindSchemaNode();
    }
    uint64_t v11 = (void *)(v10 + 16);
    size_t v12 = strlen(__s);
    if (*(char *)(v10 + 39) < 0) {
      break;
    }
    if (v12 == *(unsigned __int8 *)(v10 + 39))
    {
      if (v12 == -1) {
        goto LABEL_23;
      }
      goto LABEL_12;
    }
LABEL_13:
    ++v7;
    if (!--v9) {
      goto LABEL_14;
    }
  }
  if (v12 != *(void *)(v10 + 24)) {
    goto LABEL_13;
  }
  if (v12 == -1) {
LABEL_23:
  }
    std::string::__throw_out_of_range[abi:ne180100]();
  uint64_t v11 = (void *)*v11;
LABEL_12:
  if (memcmp(v11, __s, v12)) {
    goto LABEL_13;
  }
  if (a4)
  {
    *a4 = v7;
    if (v10 != *v7) {
      FindSchemaNode();
    }
  }
  return v10;
}

void sub_1885D89F0(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10B3C407D34617ELL);
  _Unwind_Resume(a1);
}

void sub_1885D8A14(void *a1)
{
  __cxa_begin_catch(a1);
  (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  __cxa_rethrow();
}

void sub_1885D8A48()
{
}

void XMP_Node::XMP_Node(XMP_Node *this, XMP_Node *a2, char *__s, int a4)
{
  *(void *)this = &unk_1ED4E5D30;
  *((_DWORD *)this + 2) = a4;
  int v6 = (_WORD **)((char *)this + 16);
  uint64_t v7 = (const std::string *)std::string::basic_string[abi:ne180100]<0>((void *)this + 2, __s);
  *(_OWORD *)((char *)this + 72) = 0u;
  *((void *)this + 5) = 0;
  *((void *)this + 6) = 0;
  *((void *)this + 7) = 0;
  *((void *)this + 8) = a2;
  *(_OWORD *)((char *)this + 88) = 0u;
  *(_OWORD *)((char *)this + 104) = 0u;
  if (std::string::find(v7, 58, 0) != -1) {
    return;
  }
  int v8 = *((char *)this + 39);
  if (v8 < 0)
  {
    if (*((void *)this + 3) != 2) {
      goto LABEL_8;
    }
    uint64_t v9 = *v6;
LABEL_7:
    if (*v9 == 23899) {
      return;
    }
    goto LABEL_8;
  }
  uint64_t v9 = v6;
  if (v8 == 2) {
    goto LABEL_7;
  }
LABEL_8:
  if ((*((_DWORD *)this + 2) & 0x80000000) == 0)
  {
    if (*((void *)this + 8)) {
      __assert_rtn("XMP_Node", "XMPCore_Impl.hpp", 326, "(name.find(':') != XMP_VarString::npos) || (name == \"[]\") || (options & ((XMP_OptionBits)0x80000000UL)) || (parent == 0)");
    }
  }
}

void sub_1885D8B64(_Unwind_Exception *exception_object)
{
  int v6 = *(void **)(v1 + 96);
  if (v6)
  {
    *(void *)(v1 + 104) = v6;
    operator delete(v6);
  }
  uint64_t v7 = *v4;
  if (*v4)
  {
    *(void *)(v1 + 80) = v7;
    operator delete(v7);
  }
  if (*(char *)(v1 + 63) < 0) {
    operator delete(*v3);
  }
  if (*(char *)(v1 + 39) < 0) {
    operator delete(*v2);
  }
  _Unwind_Resume(exception_object);
}

BOOL std::operator==[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>(void *a1, char *__s)
{
  size_t v4 = strlen(__s);
  if (*((char *)a1 + 23) < 0)
  {
    if (v4 == a1[1])
    {
      if (v4 == -1) {
        goto LABEL_10;
      }
      a1 = (void *)*a1;
      return memcmp(a1, __s, v4) == 0;
    }
  }
  else if (v4 == *((unsigned __int8 *)a1 + 23))
  {
    if (v4 == -1) {
LABEL_10:
    }
      std::string::__throw_out_of_range[abi:ne180100]();
    return memcmp(a1, __s, v4) == 0;
  }
  return 0;
}

void RDF_Parser::AddQualifierNode()
{
}

{
  __assert_rtn("AddQualifierNode", "ParseRDF.cpp", 566, "isType");
}

void sub_1885D8F84(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10B3C407D34617ELL);
  _Unwind_Resume(a1);
}

uint64_t XMP_Node::XMP_Node(uint64_t a1, uint64_t a2, long long *a3, long long *a4, int a5)
{
  *(void *)a1 = &unk_1ED4E5D30;
  *(_DWORD *)(a1 + 8) = a5;
  int v8 = (std::string *)(a1 + 16);
  if (*((char *)a3 + 23) < 0)
  {
    std::string::__init_copy_ctor_external((std::string *)(a1 + 16), *(const std::string::value_type **)a3, *((void *)a3 + 1));
  }
  else
  {
    long long v9 = *a3;
    *(void *)(a1 + 32) = *((void *)a3 + 2);
    *(_OWORD *)&v8->__r_.__value_.__l.__data_ = v9;
  }
  if (*((char *)a4 + 23) < 0)
  {
    std::string::__init_copy_ctor_external((std::string *)(a1 + 40), *(const std::string::value_type **)a4, *((void *)a4 + 1));
  }
  else
  {
    long long v10 = *a4;
    *(void *)(a1 + 56) = *((void *)a4 + 2);
    *(_OWORD *)(a1 + 40) = v10;
  }
  *(_OWORD *)(a1 + 72) = 0u;
  *(void *)(a1 + 64) = a2;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_OWORD *)(a1 + 104) = 0u;
  if (std::string::find(v8, 58, 0) != -1) {
    return a1;
  }
  int v11 = *(char *)(a1 + 39);
  if ((v11 & 0x80000000) == 0)
  {
    size_t v12 = v8;
    if (v11 != 2) {
      goto LABEL_14;
    }
LABEL_13:
    if (LOWORD(v12->__r_.__value_.__l.__data_) == 23899) {
      return a1;
    }
    goto LABEL_14;
  }
  if (*(void *)(a1 + 24) == 2)
  {
    size_t v12 = (std::string *)v8->__r_.__value_.__r.__words[0];
    goto LABEL_13;
  }
LABEL_14:
  if ((*(_DWORD *)(a1 + 8) & 0x80000000) == 0 && *(void *)(a1 + 64)) {
    __assert_rtn("XMP_Node", "XMPCore_Impl.hpp", 359, "(name.find(':') != XMP_VarString::npos) || (name == \"[]\") || (options & ((XMP_OptionBits)0x80000000UL)) || (parent == 0)");
  }
  return a1;
}

void sub_1885D90F4(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 39) < 0) {
    operator delete(*v2);
  }
  _Unwind_Resume(exception_object);
}

uint64_t RDF_Parser::AddQualifierNode(RDF_Parser *this, XMP_Node *a2, const XML_Node *a3)
{
  uint64_t v3 = *((unsigned __int8 *)a3 + 39);
  if ((v3 & 0x80u) != 0) {
    uint64_t v3 = *((void *)a3 + 3);
  }
  if (v3)
  {
    RDF_Parser::AddQualifierNode();
  }
  v5[0] = 202;
  v5[1] = "XML namespace required for all elements and attributes";
  _OWORD v5[2] = 0;
  GenericErrorCallback::NotifyClient(*(void *)this, 0, (unsigned int *)v5, 0);
  return 0;
}

std::string *NormalizeLangArray(std::string *result)
{
  if ((result->__r_.__value_.__s.__data_[9] & 0x10) == 0) {
    NormalizeLangArray();
  }
  std::string::pointer data = result[3].__r_.__value_.__l.__data_;
  uint64_t v2 = result[3].__r_.__value_.__l.__size_ - (void)data;
  if (v2)
  {
    uint64_t v3 = 0;
    uint64_t v4 = v2 >> 3;
    if ((unint64_t)(v2 >> 3) <= 1) {
      uint64_t v4 = 1;
    }
    do
    {
      uint64_t v5 = data[v3];
      int v6 = *(uint64_t **)(v5 + 96);
      if (v6 == *(uint64_t **)(v5 + 104)) {
        goto LABEL_31;
      }
      uint64_t v7 = *v6;
      int v8 = (void *)(v7 + 16);
      int v9 = *(char *)(v7 + 39);
      if (v9 < 0)
      {
        if (*(void *)(v7 + 24) != 8) {
          goto LABEL_31;
        }
        int v8 = (void *)*v8;
      }
      else if (v9 != 8)
      {
        goto LABEL_31;
      }
      if (*v8 != 0x676E616C3A6C6D78)
      {
LABEL_31:
        exception = __cxa_allocate_exception(0x18uLL);
        *(_DWORD *)exception = 203;
        exception[1] = "AltText array items must have an xml:lang qualifier";
        *((unsigned char *)exception + 16) = 0;
      }
      long long v10 = (uint64_t *)(v7 + 40);
      int v11 = *(char *)(v7 + 63);
      if (v11 < 0)
      {
        if (*(void *)(v7 + 48) != 9) {
          goto LABEL_21;
        }
        long long v10 = (uint64_t *)*v10;
      }
      else if (v11 != 9)
      {
        goto LABEL_21;
      }
      size_t v12 = (uint64_t *)*v10;
      int v13 = *((unsigned __int8 *)v10 + 8);
      if (v12 == (uint64_t *)0x6C75616665642D78 && v13 == 116)
      {
        if (v3)
        {
          uint64_t v15 = *data;
          *std::string::pointer data = v5;
          *(void *)(result[3].__r_.__value_.__r.__words[0] + 8 * v3) = v15;
        }
        if (v2 == 16)
        {
          uint64_t v16 = result[3].__r_.__value_.__l.__data_;
          uint64_t v17 = (const std::string *)(*v16 + 40);
          uint64_t v18 = (std::string *)(v16[1] + 40);
          return std::string::operator=(v18, v17);
        }
        return result;
      }
LABEL_21:
      ++v3;
    }
    while (v4 != v3);
  }
  return result;
}

std::string *DetectAltText(std::string *result)
{
  int v1 = result->__r_.__value_.__r.__words[1];
  if ((v1 & 0x800) == 0) {
    DetectAltText();
  }
  std::string::pointer data = result[3].__r_.__value_.__l.__data_;
  std::string::size_type size = result[3].__r_.__value_.__l.__size_;
  unint64_t v4 = (uint64_t)(size - (void)data) >> 3;
  uint64_t v5 = 0;
  if ((std::string::pointer)size != data)
  {
    if (v4 <= 1) {
      uint64_t v6 = 1;
    }
    else {
      uint64_t v6 = (uint64_t)(size - (void)data) >> 3;
    }
    while ((*(_DWORD *)(*(void *)&data[8 * v5] + 8) & 0x1F40) == 0x40)
    {
      if (v6 == ++v5)
      {
        uint64_t v5 = v6;
        break;
      }
    }
  }
  if ((std::string::pointer)size != data && v5 == v4)
  {
    LODWORD(result->__r_.__value_.__r.__words[1]) = v1 | 0x1000;
    return NormalizeLangArray(result);
  }
  return result;
}

uint64_t imageio_value_release(void *a1, void *a2)
{
  if ((gIIODebugFlags & 0x200) != 0) {
    ImageIOLog("    imageio_value_release ptr: %p   userData: %p\n", a1, a2);
  }

  return _ImageIO_Free((unint64_t)a1, (size_t)a2);
}

void WXMPMeta_SetErrorCallback_1(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, void *a6)
{
  size_t v12 = (XMP_ReadWriteLock *)(a1 + 16);
  XMP_ReadWriteLock::Acquire((pthread_rwlock_t *)(a1 + 16), 1);
  *a6 = 0;
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)a1 + 216))(a1, a2, a3, a4, a5);
  XMP_AutoLock::~XMP_AutoLock(&v12);
}

uint64_t XMPMeta::SetErrorCallback(uint64_t this, unsigned __int8 (*a2)(BOOL (*)(void *, unsigned __int8, int, const char *), void *, unsigned __int8, int, const char *), BOOL (*a3)(void *, unsigned __int8, int, const char *), void *a4, int a5)
{
  if (!a2) {
    XMPMeta::SetErrorCallback();
  }
  *(_DWORD *)(this + 364) = 0;
  *(unsigned char *)(this + 368) = 0;
  *(void *)(this + 376) = a2;
  *(void *)(this + 384) = a3;
  *(void *)(this + 392) = a4;
  *(_DWORD *)(this + 360) = a5;
  return this;
}

uint64_t IIOTextureHandler::LockDataCallback(IIOTextureHandler *this, void *a2, uint64_t a3, uint64_t a4, unint64_t *a5, unint64_t *a6, unint64_t *a7)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  if ((gIIODebugFlags & 0xC000) != 0)
  {
    *(_OWORD *)uint64_t v15 = 0u;
    long long v16 = 0u;
    sprintf(v15, "option: %d", a7);
    if ((unsigned __int16)gIIODebugFlags >> 14) {
      ImageIODebugOptions((unsigned __int16)gIIODebugFlags >> 14, "S", "LockDataCallback", 0, v15, -1, 0);
    }
  }
  if (!this) {
    return 0;
  }
  uint64_t result = *((void *)this + 1);
  if (result) {
    return (*(uint64_t (**)(uint64_t, void, void *, uint64_t, uint64_t, unint64_t *, unint64_t *, unint64_t *))(*(void *)result + 40))(result, *((void *)this + 6), a2, a3, a4, a5, a6, a7);
  }
  return result;
}

uint64_t ASTCTextureImp::textureDataLockData(ASTCTextureImp *this, IIOImageReadSession *a2, uint64_t a3, unint64_t a4, unint64_t *a5, unint64_t *a6, unint64_t *a7, char a8)
{
  *a5 = 0;
  *a6 = 0;
  *a7 = 0;
  uint64_t v15 = (pthread_mutex_t *)((char *)this + 168);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 168));
  if ((a8 & 2) != 0)
  {
    uint64_t v16 = *((void *)this + 10);
    if (!v16)
    {
      if (*((unsigned char *)this + 41))
      {
        if (*((unsigned char *)this + 40)) {
          LogError("textureDataLockData", 1057, "*** pre-twiddled LZFSE compressed ASTC is not supported\n");
        }
        else {
          ASTCTextureImp::createTwiddledDataFromTwiddled(this, a2);
        }
      }
      else if (*((unsigned char *)this + 40))
      {
        ASTCTextureImp::createTwiddledDataFromLinearLZFSE(this, a2, a3);
      }
      else
      {
        ASTCTextureImp::createTwiddledDataFromLinear(this, a2, a3);
      }
      uint64_t v16 = *((void *)this + 10);
      if (!v16) {
        goto LABEL_22;
      }
    }
    goto LABEL_21;
  }
  uint64_t v16 = *((void *)this + 7);
  if (v16)
  {
LABEL_21:
    unint64_t v17 = *((void *)this + 19);
    *a5 = *((void *)this + 18);
    *a6 = v17;
    *a7 = *((void *)this + 20);
LABEL_22:
    pthread_mutex_unlock(v15);
    return v16;
  }
  if (!*((unsigned char *)this + 41))
  {
    if (*((unsigned char *)this + 40)) {
      _cg_jpeg_mem_term("createLinearDataFromLZFSE", 992, "*** ERROR: createLinearDataFromLZFSE is not supported\n");
    }
    else {
      ASTCTextureImp::createLinearDataFromLinear(this, a2);
    }
LABEL_17:
    uint64_t v16 = *((void *)this + 7);
    if (!v16) {
      goto LABEL_22;
    }
    goto LABEL_21;
  }
  if (!*((unsigned char *)this + 40))
  {
    _cg_jpeg_mem_term("createLinearDataFromTwiddled", 1003, "*** ERROR: createLinearDataFromTwiddled is not supported\n");
    goto LABEL_17;
  }
  LogError("textureDataLockData", 1106, "*** pre-twiddled LZFSE compressed ASTC is not supported\n");
  return 0;
}

void ASTCTextureImp::createTwiddledDataFromTwiddled(ASTCTextureImp *this, IIOImageReadSession *a2)
{
  uint64_t v3 = *((void *)this + 15);
  if (v3
    || (*((void *)this + 15) = IIOImageReadSession::retainBytePointer(a2, (const __CFData **)this + 16, 1),
        uint64_t v5 = (const void *)IIOImageSource::cf(a2),
        *((void *)this + 17) = v5,
        CFRetain(v5),
        (uint64_t v3 = *((void *)this + 15)) != 0))
  {
    int v6 = 0;
    uint64_t v7 = v3 + *((void *)this + 14);
  }
  else
  {
    _cg_jpeg_mem_term("createTwiddledDataFromTwiddled", 952, "*** Can't access image data\n");
    uint64_t v7 = 0;
    int v6 = -50;
  }
  *((void *)this + 10) = v7;
  *((_DWORD *)this + 58) = v6;
}

os_log_t ___ZL13ImageIOLoggeriPKcS0_iS0_Pc_block_invoke()
{
  BOOL v0 = getprogname();
  os_log_t result = os_log_create("com.apple.imageio", v0);
  gIIO_Log = (uint64_t)result;
  return result;
}

void PNGReadPlugin::DecodeFrameInterlaced(IIOImageReadSession *a1, uint64_t a2, unsigned char *a3, void *a4)
{
  BOOL v50 = 0;
  uint64_t v7 = *(unsigned int *)(a2 + 48);
  int v51 = 0;
  uint64_t v8 = a4[6];
  int v9 = _cg_png_create_read_struct("1.6.43", 0, (uint64_t)handle_error, (uint64_t)handle_warning);
  int v51 = v9;
  if (v9)
  {
    long long v10 = v9;
    _cg_png_create_info_struct((uint64_t)v9);
    BOOL v50 = v11;
    if (!v11) {
      goto LABEL_79;
    }
    size_t v12 = (unsigned int *)v11;
    _cg_png_set_option((uint64_t)v10, 2u, 3);
    _cg_png_set_benign_errors((uint64_t)v10, 1);
    unint64_t v13 = *(void *)(a2 + 8);
    if (v13) {
      IIOImageReadSession::seek(a1, v13, 0);
    }
    else {
      IIOImageReadSession::rewind((uint64_t)a1);
    }
    _cg_png_set_read_fn(v10, (uint64_t)a1, (size_t (*)(size_t, void *, size_t))read_fn);
    if (!*(unsigned char *)(a2 + 157))
    {
      _cg_png_set_palette_to_rgb((uint64_t)v10);
      if ((gIIODebugFlags & 0x20000) != 0)
      {
        int v14 = *(_DWORD *)(a2 + 20);
        unsigned int v15 = v14 >> 24;
        if (v14 < 0)
        {
          int v16 = __maskrune(v15, 0x40000uLL);
          int v14 = *(_DWORD *)(a2 + 20);
          unsigned int v15 = v14 >> 24;
        }
        else
        {
          int v16 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v15 + 60) & 0x40000;
        }
        if (v16) {
          uint64_t v17 = v15;
        }
        else {
          uint64_t v17 = 46;
        }
        unsigned int v18 = v14 << 8 >> 24;
        if (v14 << 8 < 0)
        {
          int v19 = __maskrune(v18, 0x40000uLL);
          int v14 = *(_DWORD *)(a2 + 20);
          unsigned int v18 = v14 << 8 >> 24;
        }
        else
        {
          int v19 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v18 + 60) & 0x40000;
        }
        if (v19) {
          uint64_t v20 = v18;
        }
        else {
          uint64_t v20 = 46;
        }
        unsigned int v21 = (__int16)v14 >> 8;
        if (v14 << 16 < 0)
        {
          int v22 = __maskrune(v21, 0x40000uLL);
          int v14 = *(_DWORD *)(a2 + 20);
          unsigned int v21 = (__int16)v14 >> 8;
        }
        else
        {
          int v22 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v21 + 60) & 0x40000;
        }
        if (v22) {
          uint64_t v23 = v21;
        }
        else {
          uint64_t v23 = 46;
        }
        unsigned int v24 = (char)v14;
        if ((v14 << 24) <= 0x7F000000)
        {
          int v25 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * (char)v14 + 60) & 0x40000;
        }
        else
        {
          int v25 = __maskrune((char)v14, 0x40000uLL);
          unsigned int v24 = *(char *)(a2 + 20);
        }
        if (v25) {
          uint64_t v26 = v24;
        }
        else {
          uint64_t v26 = 46;
        }
        ImageIOLog("  '%c%c%c%c' %d: png_set_palette_to_rgb\n", v17, v20, v23, v26, 4614);
      }
    }
    _cg_png_set_expand_gray_1_2_4_to_8((uint64_t)v10);
    if ((gIIODebugFlags & 0x20000) != 0)
    {
      int v27 = *(_DWORD *)(a2 + 20);
      unsigned int v28 = v27 >> 24;
      uint64_t v29 = MEMORY[0x1E4F14390];
      if (v27 < 0)
      {
        int v30 = __maskrune(v28, 0x40000uLL);
        int v27 = *(_DWORD *)(a2 + 20);
        unsigned int v28 = v27 >> 24;
      }
      else
      {
        int v30 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v28 + 60) & 0x40000;
      }
      if (v30) {
        uint64_t v31 = v28;
      }
      else {
        uint64_t v31 = 46;
      }
      unsigned int v32 = v27 << 8 >> 24;
      if (v27 << 8 < 0)
      {
        int v33 = __maskrune(v32, 0x40000uLL);
        int v27 = *(_DWORD *)(a2 + 20);
        unsigned int v32 = v27 << 8 >> 24;
      }
      else
      {
        int v33 = *(_DWORD *)(v29 + 4 * v32 + 60) & 0x40000;
      }
      if (v33) {
        uint64_t v34 = v32;
      }
      else {
        uint64_t v34 = 46;
      }
      unsigned int v35 = (__int16)v27 >> 8;
      if (v27 << 16 < 0)
      {
        int v36 = __maskrune(v35, 0x40000uLL);
        int v27 = *(_DWORD *)(a2 + 20);
        unsigned int v35 = (__int16)v27 >> 8;
      }
      else
      {
        int v36 = *(_DWORD *)(v29 + 4 * v35 + 60) & 0x40000;
      }
      if (v36) {
        uint64_t v37 = v35;
      }
      else {
        uint64_t v37 = 46;
      }
      unsigned int v38 = (char)v27;
      if ((v27 << 24) <= 0x7F000000)
      {
        int v39 = *(_DWORD *)(v29 + 4 * (char)v27 + 60) & 0x40000;
      }
      else
      {
        int v39 = __maskrune((char)v27, 0x40000uLL);
        unsigned int v38 = *(char *)(a2 + 20);
      }
      if (v39) {
        uint64_t v40 = v38;
      }
      else {
        uint64_t v40 = 46;
      }
      ImageIOLog("  '%c%c%c%c' %d: png_set_expand_gray_1_2_4_to_8\n", v31, v34, v37, v40, 4617);
    }
    _cg_png_set_keep_unknown_chunks_sized((uint64_t)v10, 3u, "CgBI", 4);
    _cg_png_set_read_user_chunk_fn((uint64_t)v10, (uint64_t)a3, (uint64_t)PNGReadPlugin::Read_user_chunk_callback);
    _cg_png_read_info((uLong)v10, v12);
    int v41 = _cg_png_set_interlace_handling((uint64_t)v10);
    if (*(unsigned char *)(a2 + 63) == 1) {
      _cg_png_set_swap((uint64_t)v10);
    }
    PNGReadPlugin::Update_png_struct(a2, a3, (uint64_t)v10, v12);
    if (v41 >= 1)
    {
      uint64_t v42 = 0;
      uint64_t v43 = -1;
      do
      {
        if (v7)
        {
          uint64_t v44 = 0;
          uint64_t v45 = (char *)a4[5];
          do
          {
            if (*(unsigned char *)(a2 + 157)) {
              unsigned int v46 = v45;
            }
            else {
              unsigned int v46 = 0;
            }
            if (*(unsigned char *)(a2 + 157)) {
              int v47 = v8;
            }
            else {
              int v47 = 0;
            }
            if (*(unsigned char *)(a2 + 157)) {
              uint64_t v48 = 0;
            }
            else {
              uint64_t v48 = v45;
            }
            _cg_png_read_row_sized((uLong)v10, v46, v47, v48);
            v45 += v8;
            if (v43 <= v44) {
              uint64_t v43 = v44 + 1;
            }
            ++v44;
          }
          while (v7 != v44);
        }
        ++v42;
      }
      while (v42 != v41);
    }
    else
    {
LABEL_79:
      uint64_t v43 = -1;
    }
    _cg_png_destroy_read_struct((uint64_t *)&v51, &v50, 0);
  }
  else
  {
    uint64_t v43 = -1;
  }
  a4[8] = v43 & ~(v43 >> 63);
}

void sub_1885D9E10(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16)
{
  __cxa_begin_catch(a1);
  imagePNG_error_break(v16);
  _cg_png_get_height(a16);
  _cg_png_get_current_row_number(a16);
  __cxa_end_catch();
  if (!a16) {
    JUMPOUT(0x1885D9DE0);
  }
  JUMPOUT(0x1885D9DD0);
}

void sub_1885D9E60(_Unwind_Exception *a1)
{
}

uint64_t PNGReadPlugin::Update_png_struct(uint64_t a1, unsigned char *a2, uint64_t a3, unsigned int *a4)
{
  if (a2[32])
  {
    _cg_png_set_palette_to_rgb(a3);
    if ((gIIODebugFlags & 0x20000) != 0)
    {
      int v8 = *(_DWORD *)(a1 + 20);
      unsigned int v9 = v8 >> 24;
      uint64_t v10 = MEMORY[0x1E4F14390];
      if (v8 < 0)
      {
        int v11 = __maskrune(v9, 0x40000uLL);
        int v8 = *(_DWORD *)(a1 + 20);
        unsigned int v9 = v8 >> 24;
      }
      else
      {
        int v11 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v9 + 60) & 0x40000;
      }
      if (v11) {
        uint64_t v12 = v9;
      }
      else {
        uint64_t v12 = 46;
      }
      unsigned int v13 = v8 << 8 >> 24;
      if (v8 << 8 < 0)
      {
        int v14 = __maskrune(v13, 0x40000uLL);
        int v8 = *(_DWORD *)(a1 + 20);
        unsigned int v13 = v8 << 8 >> 24;
      }
      else
      {
        int v14 = *(_DWORD *)(v10 + 4 * v13 + 60) & 0x40000;
      }
      if (v14) {
        uint64_t v15 = v13;
      }
      else {
        uint64_t v15 = 46;
      }
      unsigned int v16 = (__int16)v8 >> 8;
      if (v8 << 16 < 0)
      {
        int v17 = __maskrune(v16, 0x40000uLL);
        int v8 = *(_DWORD *)(a1 + 20);
        unsigned int v16 = (__int16)v8 >> 8;
      }
      else
      {
        int v17 = *(_DWORD *)(v10 + 4 * v16 + 60) & 0x40000;
      }
      if (v17) {
        uint64_t v18 = v16;
      }
      else {
        uint64_t v18 = 46;
      }
      unsigned int v19 = (char)v8;
      if ((v8 << 24) <= 0x7F000000)
      {
        int v20 = *(_DWORD *)(v10 + 4 * (char)v8 + 60) & 0x40000;
      }
      else
      {
        int v20 = __maskrune((char)v8, 0x40000uLL);
        unsigned int v19 = *(char *)(a1 + 20);
      }
      if (v20) {
        uint64_t v21 = v19;
      }
      else {
        uint64_t v21 = 46;
      }
      ImageIOLog("  '%c%c%c%c' %d: png_set_palette_to_rgb\n", v12, v15, v18, v21, 2552);
    }
  }
  if (!a2[19] && _cg_png_get_bit_depth(a3, (uint64_t)a4) <= 7) {
    _cg_png_set_expand_gray_1_2_4_to_8(a3);
  }
  if (a2[28])
  {
    _cg_png_set_palette_to_rgb(a3);
  }
  else if (a2[27])
  {
    _cg_png_set_add_alpha(a3, 255, 1);
    if ((gIIODebugFlags & 0x20000) != 0)
    {
      int v22 = *(_DWORD *)(a1 + 20);
      if (v22 < 0)
      {
        __maskrune(v22 >> 24, 0x40000uLL);
        int v22 = *(_DWORD *)(a1 + 20);
      }
      if (v22 << 8 < 0)
      {
        __maskrune(v22 << 8 >> 24, 0x40000uLL);
        int v22 = *(_DWORD *)(a1 + 20);
      }
      if (v22 << 16 < 0)
      {
        __maskrune((__int16)v22 >> 8, 0x40000uLL);
        int v22 = *(_DWORD *)(a1 + 20);
      }
      if ((v22 << 24) > 0x7F000000) {
        __maskrune((char)v22, 0x40000uLL);
      }
      ImageIOLog("  '%c%c%c%c' %d: png_set_add_alpha: PNG_FILLER_AFTER\n");
    }
  }
  else if (a2[26])
  {
    _cg_png_set_filler(a3, 255, 0);
    if ((gIIODebugFlags & 0x20000) != 0)
    {
      int v23 = *(_DWORD *)(a1 + 20);
      if (v23 < 0)
      {
        __maskrune(v23 >> 24, 0x40000uLL);
        int v23 = *(_DWORD *)(a1 + 20);
      }
      if (v23 << 8 < 0)
      {
        __maskrune(v23 << 8 >> 24, 0x40000uLL);
        int v23 = *(_DWORD *)(a1 + 20);
      }
      if (v23 << 16 < 0)
      {
        __maskrune((__int16)v23 >> 8, 0x40000uLL);
        int v23 = *(_DWORD *)(a1 + 20);
      }
      if ((v23 << 24) > 0x7F000000) {
        __maskrune((char)v23, 0x40000uLL);
      }
      ImageIOLog("  '%c%c%c%c' %d: png_set_filler: PNG_FILLER_BEFORE\n");
    }
  }

  return _cg_png_read_update_info(a3, a4);
}

uint64_t _cg_png_set_add_alpha(uint64_t result, __int16 a2, int a3)
{
  if (result)
  {
    uint64_t v3 = result;
    os_log_t result = _cg_png_set_filler(result, a2, a3);
    int v4 = *(_DWORD *)(v3 + 88);
    if ((v4 & 0x8000) != 0) {
      *(_DWORD *)(v3 + 88) = v4 | 0x1000000;
    }
  }
  return result;
}

uint64_t _cg_png_set_filler(uint64_t result, __int16 a2, int a3)
{
  if (!result) {
    return result;
  }
  if ((*(unsigned char *)(result + 77) & 0x80) == 0)
  {
    if (*(unsigned char *)(result + 391))
    {
      if (*(unsigned char *)(result + 391) == 2)
      {
        char v3 = 4;
LABEL_9:
        *(unsigned char *)(result + 396) = v3;
        goto LABEL_10;
      }
      int v6 = "png_set_filler: inappropriate color type";
    }
    else
    {
      if (*(unsigned __int8 *)(result + 392) >= 8u)
      {
        char v3 = 2;
        goto LABEL_9;
      }
      int v6 = "png_set_filler is invalid for low bit depth gray output";
    }
    return png_app_error(result, v6);
  }
  *(_WORD *)(result + 402) = a2;
LABEL_10:
  *(_DWORD *)(result + 88) |= 0x8000u;
  int v4 = *(_DWORD *)(result + 80);
  if (a3 == 1) {
    unsigned int v5 = v4 | 0x80;
  }
  else {
    unsigned int v5 = v4 & 0xFFFFFF7F;
  }
  *(_DWORD *)(result + 80) = v5;
  return result;
}

uint64_t png_decompress_chunk(uint64_t a1, int a2, unsigned int a3, unint64_t *a4)
{
  unint64_t v8 = *(void *)(a1 + 888);
  if (v8 + 1 > 1)
  {
    unint64_t v9 = a3 + 1;
    if (v8 < v9)
    {
      uint64_t v12 = 4294967292;
      png_zstream_error(a1, -4);
      return v12;
    }
  }
  else
  {
    unint64_t v9 = a3 + 1;
    unint64_t v8 = -1;
  }
  unint64_t v10 = v8 - v9;
  if (v10 < *a4) {
    *a4 = v10;
  }
  unsigned int v11 = png_inflate_claim(a1, *(_DWORD *)(a1 + 312));
  if (!v11)
  {
    int v13 = a2 - a3;
    int v20 = a2 - a3;
    uint64_t v12 = png_inflate(a1, *(unsigned int *)(a1 + 312));
    if (v12 == 1)
    {
      if (inflateReset((z_streamp)(a1 + 96)))
      {
        png_zstream_error(a1, 1);
        uint64_t v12 = 4294967289;
      }
      else
      {
        unint64_t v14 = *a4;
        size_t v15 = a3 + *a4 + 1;
        unsigned int v16 = png_malloc_base(a1, v15);
        if (v16)
        {
          int v17 = v16;
          bzero(v16, v15);
          uint64_t v12 = png_inflate(a1, *(unsigned int *)(a1 + 312));
          if (v12 == 1)
          {
            if (v14 == *a4)
            {
              v17[v14 + a3] = 0;
              uint64_t v18 = *(void **)(a1 + 936);
              if (a3) {
                memcpy(v17, *(const void **)(a1 + 936), a3);
              }
              *(void *)(a1 + 936) = v17;
              *(void *)(a1 + 944) = v15;
              png_free(a1, v18);
              if (v13 != v20) {
                png_chunk_benign_error(a1, "extra compressed data");
              }
              uint64_t v12 = 1;
              goto LABEL_25;
            }
            uint64_t v12 = 4294967289;
          }
          png_free(a1, v17);
        }
        else
        {
          uint64_t v12 = 4294967292;
          png_zstream_error(a1, -4);
        }
      }
    }
LABEL_25:
    *(_DWORD *)(a1 + 92) = 0;
    return v12;
  }
  if (v11 == 1) {
    return 4294967289;
  }
  else {
    return v11;
  }
}

uint64_t png_inflate(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = MEMORY[0x1F4188790](a1, a2);
  uint64_t v7 = v2;
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  if (*(_DWORD *)(v2 + 92) == v8)
  {
    unint64_t v9 = v6;
    uint64_t v10 = v5;
    unsigned int v11 = v4;
    uint64_t v12 = *v6;
    int v13 = *v4;
    *(void *)(v2 + 96) = v3;
    *(_DWORD *)(v2 + 104) = 0;
    *(_DWORD *)(v2 + 128) = 0;
    if (v5) {
      *(void *)(v2 + 120) = v5;
    }
    do
    {
      bzero(v21, 0x1000uLL);
      *(_DWORD *)(v7 + 104) += v13;
      if (v10)
      {
        LODWORD(v14) = -1;
      }
      else
      {
        *(void *)(v7 + 120) = v21;
        LODWORD(v14) = 4096;
      }
      unint64_t v15 = v12 + *(unsigned int *)(v7 + 128);
      if (v15 >= v14) {
        uint64_t v14 = v14;
      }
      else {
        uint64_t v14 = v15;
      }
      *(_DWORD *)(v7 + 128) = v14;
      uint64_t v12 = v15 - v14;
      uint64_t v16 = png_zlib_inflate(v7, 4 * (v15 == v14));
      int v13 = 0;
    }
    while (!v16);
    uint64_t v17 = v16;
    if (!v10) {
      *(void *)(v7 + 120) = 0;
    }
    int v18 = *(_DWORD *)(v7 + 104);
    uint64_t v19 = v12 + *(unsigned int *)(v7 + 128);
    if (v19) {
      *v9 -= v19;
    }
    if (v18) {
      *v11 -= v18;
    }
    png_zstream_error(v7, v16);
  }
  else
  {
    *(void *)(v2 + 144) = "zstream unclaimed";
    return 4294967294;
  }
  return v17;
}

void _cg_png_set_iCCP(void *a1, uint64_t a2, char *a3, int a4, unsigned int *a5, unint64_t a6)
{
  if (a1 && a2 && a3 && a5)
  {
    if (a4) {
      png_app_error((uint64_t)a1, "Invalid iCCP compression method");
    }
    int v11 = png_colorspace_set_ICC((uint64_t)a1, a2 + 52, a3, a6, a5, *(unsigned char *)(a2 + 37));
    png_colorspace_sync_info((uint64_t)a1, a2);
    if (v11)
    {
      *(_WORD *)(a2 + 126) |= 0x18u;
      size_t v12 = strlen(a3) + 1;
      int v13 = png_malloc_warn(a1, v12);
      if (v13)
      {
        uint64_t v14 = v13;
        memcpy(v13, a3, v12);
        unint64_t v15 = png_malloc_warn(a1, a6);
        if (v15)
        {
          uint64_t v16 = v15;
          memcpy(v15, a5, a6);
          png_free_data((uint64_t)a1, a2, 0x10u, 0);
          *(_DWORD *)(a2 + 144) = a6;
          *(void *)(a2 + 128) = v14;
          *(void *)(a2 + 136) = v16;
          *(_DWORD *)(a2 + 300) |= 0x10u;
          *(_DWORD *)(a2 + 8) |= 0x1000u;
          return;
        }
        png_free((uint64_t)a1, v14);
        uint64_t v17 = "Insufficient memory to process iCCP profile";
      }
      else
      {
        uint64_t v17 = "Insufficient memory to process iCCP chunk";
      }
      png_benign_error((uint64_t)a1, v17);
    }
  }
}

uint64_t png_colorspace_set_ICC(uint64_t a1, uint64_t a2, unsigned char *a3, unint64_t a4, unsigned int *a5, char a6)
{
  if (*(__int16 *)(a2 + 74) < 0) {
    return 0;
  }
  unsigned int v6 = a4;
  if (a4 <= 0x83)
  {
    png_icc_profile_error(a1, a2, a3, a4, "too short");
    return 0;
  }
  uint64_t result = png_icc_check_header(a1, a2, a3, a4, (uint64_t)a5, a6);
  if (result)
  {
    uint64_t result = png_icc_check_tag_table(a1, a2, a3, v6, (uint64_t)a5);
    if (result)
    {
      png_icc_set_sRGB(a1, a2, a5, 0);
      return 1;
    }
  }
  return result;
}

void png_handle_iCCP(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = MEMORY[0x1F4188790](a1, a2);
  uint64_t v5 = v2;
  uint64_t v49 = *MEMORY[0x1E4F143B8];
  unsigned int v36 = v4;
  int v6 = *(_DWORD *)(v2 + 76);
  if ((v6 & 1) == 0) {
    png_chunk_error((void (**)(void))v2, "missing IHDR");
  }
  unsigned int v7 = v4;
  if ((v6 & 6) != 0)
  {
    png_crc_finish(v2, v4);
    int v8 = "out of place";
LABEL_6:
    png_chunk_benign_error(v5, v8);
    return;
  }
  if (v4 <= 0xD)
  {
    png_crc_finish(v2, v4);
    int v8 = "too short";
    goto LABEL_6;
  }
  int v9 = *(__int16 *)(v2 + 1074);
  if ((v9 & 0x80000000) == 0)
  {
    uint64_t v10 = v3;
    if ((v9 & 4) != 0)
    {
      unint64_t v15 = "too many profiles";
LABEL_32:
      png_crc_finish(v5, v36);
LABEL_33:
      *(_WORD *)(v5 + 1074) |= 0x8000u;
      png_colorspace_sync(v5, v10);
      *(void *)(v5 + 96) = 0;
      if (!v15) {
        return;
      }
      uint64_t v14 = v5;
      int v13 = v15;
      goto LABEL_35;
    }
    char v48 = 0;
    memset(__src, 0, sizeof(__src));
    if (v4 >= 0x51) {
      unsigned int v11 = 81;
    }
    else {
      unsigned int v11 = v4;
    }
    png_crc_read(v2, (Bytef *)__src, v11);
    uint64_t v12 = v7 - v11;
    unsigned int v36 = v12;
    if (v12 < 0xB)
    {
      png_crc_finish(v5, v12);
      int v13 = "too short";
      uint64_t v14 = v5;
LABEL_35:
      png_chunk_benign_error(v14, v13);
      return;
    }
    uint64_t v16 = 0;
    if (v7 >= 0x50) {
      uint64_t v17 = 80;
    }
    else {
      uint64_t v17 = v7;
    }
    while (*((unsigned char *)__src + v16))
    {
      if (v17 == ++v16) {
        goto LABEL_27;
      }
    }
    LODWORD(v17) = v16;
LABEL_27:
    if ((v17 - 1) > 0x4E)
    {
      unint64_t v15 = "bad keyword";
      goto LABEL_32;
    }
    size_t v18 = v17 + 1;
    if (v18 >= v11 || *((unsigned char *)__src + v18))
    {
      unint64_t v15 = "bad compression method";
      goto LABEL_32;
    }
    if (png_inflate_claim(v5, 1766015824))
    {
      unint64_t v15 = *(const char **)(v5 + 144);
      goto LABEL_32;
    }
    uint64_t v19 = (v17 + 2);
    int v46 = 0;
    long long v45 = 0u;
    long long v44 = 0u;
    long long v43 = 0u;
    long long v42 = 0u;
    long long v41 = 0u;
    long long v40 = 0u;
    long long v39 = 0u;
    long long v38 = 0u;
    bzero(v37, 0x1000uLL);
    unint64_t v35 = 132;
    *(void *)(v5 + 96) = (char *)__src + v19;
    *(_DWORD *)(v5 + 104) = v11 - v19;
    png_inflate_read(v5, v37, &v36, (uint64_t)&v38, (uint64_t *)&v35, 0);
    if (v35) {
      goto LABEL_40;
    }
    unint64_t v20 = bswap32(v38);
    if (!png_icc_check_length(v5, v5 + 1000, __src, v20)
      || !png_icc_check_header(v5, v5 + 1000, __src, v20, (uint64_t)&v38, *(unsigned char *)(v5 + 391)))
    {
      goto LABEL_49;
    }
    int v21 = v46;
    int v22 = BYTE1(v46);
    int v23 = BYTE2(v46);
    unsigned int v24 = HIBYTE(v46);
    uint64_t buffer = png_read_buffer(v5, v20, 2);
    if (!buffer)
    {
      unint64_t v15 = "out of memory";
      goto LABEL_50;
    }
    long long v26 = v45;
    buffer[6] = v44;
    buffer[7] = v26;
    *((_DWORD *)buffer + 32) = v46;
    long long v27 = v41;
    void buffer[2] = v40;
    buffer[3] = v27;
    long long v28 = v43;
    buffer[4] = v42;
    buffer[5] = v28;
    long long v29 = v39;
    _OWORD *buffer = v38;
    buffer[1] = v29;
    uint64_t v30 = 12 * ((v21 << 24) | (v22 << 16) | (v23 << 8) | v24);
    uint64_t v34 = (unsigned int *)buffer;
    unint64_t v35 = v30;
    uint64_t v31 = (char *)buffer + 132;
    png_inflate_read(v5, v37, &v36, (uint64_t)buffer + 132, (uint64_t *)&v35, 0);
    if (v35) {
      goto LABEL_40;
    }
    if (!png_icc_check_tag_table(v5, v5 + 1000, __src, v20, (uint64_t)v34))
    {
LABEL_49:
      unint64_t v15 = 0;
      goto LABEL_50;
    }
    unint64_t v35 = v20 - v30 - 132;
    png_inflate_read(v5, v37, &v36, (uint64_t)&v31[v30], (uint64_t *)&v35, 1);
    uint64_t v32 = v36;
    if (v36)
    {
      if ((*(unsigned char *)(v5 + 82) & 0x10) == 0)
      {
        unint64_t v15 = "extra compressed data";
        goto LABEL_50;
      }
      if (!v35)
      {
        png_chunk_warning(v5, "extra compressed data");
        goto LABEL_56;
      }
    }
    else if (!v35)
    {
LABEL_56:
      png_crc_finish(v5, v32);
      png_icc_set_sRGB(v5, v5 + 1000, v34, *(void *)(v5 + 192));
      if (v10)
      {
        png_free_data(v5, v10, 0x10u, 0);
        int v33 = png_malloc_base(v5, v18);
        *(void *)(v10 + 128) = v33;
        if (!v33)
        {
          *(_WORD *)(v5 + 1074) |= 0x8000u;
          png_colorspace_sync(v5, v10);
          *(_DWORD *)(v5 + 92) = 0;
          unint64_t v15 = "out of memory";
          goto LABEL_33;
        }
        memcpy(v33, __src, v18);
        *(_DWORD *)(v10 + 144) = v20;
        *(void *)(v10 + 136) = v34;
        *(void *)(v5 + 936) = 0;
        *(_DWORD *)(v10 + 300) |= 0x10u;
        *(_DWORD *)(v10 + 8) |= 0x1000u;
        png_colorspace_sync(v5, v10);
      }
      *(_DWORD *)(v5 + 92) = 0;
      *(void *)(v5 + 96) = 0;
      return;
    }
LABEL_40:
    unint64_t v15 = *(const char **)(v5 + 144);
LABEL_50:
    *(_DWORD *)(v5 + 92) = 0;
    goto LABEL_32;
  }

  png_crc_finish(v2, v4);
}

uint64_t png_zstream_error(uint64_t result, int a2)
{
  if (!*(void *)(result + 144))
  {
    if ((a2 + 7) > 9) {
      uint64_t v2 = "unexpected zlib return code";
    }
    else {
      uint64_t v2 = off_1E53CBAF0[a2 + 7];
    }
    *(void *)(result + 144) = v2;
  }
  return result;
}

uint64_t png_inflate_read(uint64_t result, Bytef *a2, unsigned int *a3, uint64_t a4, uint64_t *a5, int a6)
{
  uint64_t v6 = result;
  if (*(_DWORD *)(result + 92) == *(_DWORD *)(result + 312))
  {
    *(void *)(result + 120) = a4;
    *(_DWORD *)(result + 128) = 0;
    if (a6) {
      int v10 = 4;
    }
    else {
      int v10 = 2;
    }
    unsigned int v11 = 4096;
    while (1)
    {
      if (!*(_DWORD *)(v6 + 104))
      {
        if (v11 >= *a3) {
          unsigned int v11 = *a3;
        }
        *a3 -= v11;
        if (v11) {
          png_crc_read(v6, a2, v11);
        }
        *(void *)(v6 + 96) = a2;
        *(_DWORD *)(v6 + 104) = v11;
      }
      if (!*(_DWORD *)(v6 + 128))
      {
        if ((unint64_t)*a5 >= 0xFFFFFFFF) {
          uint64_t v12 = 0xFFFFFFFFLL;
        }
        else {
          uint64_t v12 = *a5;
        }
        *a5 -= v12;
        *(_DWORD *)(v6 + 128) = v12;
      }
      int v13 = *a3 ? 0 : v10;
      int v14 = png_zlib_inflate(v6, v13);
      if (v14) {
        break;
      }
      if (!*a5 && !*(_DWORD *)(v6 + 128))
      {
        uint64_t v15 = 0;
        goto LABEL_26;
      }
    }
    uint64_t v15 = *a5 + *(unsigned int *)(v6 + 128);
LABEL_26:
    *a5 = v15;
    *(_DWORD *)(v6 + 128) = 0;
    return png_zstream_error(v6, v14);
  }
  else
  {
    *(void *)(result + 144) = "zstream unclaimed";
  }
  return result;
}

uint64_t png_handle_iTXt(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v6 = *(_DWORD *)(a1 + 884);
  if (!v6) {
    goto LABEL_8;
  }
  int v7 = v6 - 1;
  if (!v7)
  {
    return png_crc_finish(a1, a3);
  }
  *(_DWORD *)(a1 + 884) = v7;
  if (v7 != 1)
  {
LABEL_8:
    int v10 = *(_DWORD *)(a1 + 76);
    if ((v10 & 1) == 0) {
      png_chunk_error((void (**)(void))a1, "missing IHDR");
    }
    if ((v10 & 4) != 0) {
      *(_DWORD *)(a1 + 76) = v10 | 8;
    }
    uint64_t buffer = (Bytef *)png_read_buffer(a1, (a3 + 1), 1);
    if (!buffer)
    {
      png_crc_finish(a1, a3);
      int v9 = "out of memory";
      goto LABEL_23;
    }
    uint64_t v12 = buffer;
    png_crc_read(a1, buffer, a3);
    uint64_t result = png_crc_finish(a1, 0);
    if (result) {
      return result;
    }
    if (!a3) {
      goto LABEL_19;
    }
    uint64_t v13 = 0;
    while (v12[v13])
    {
      if (a3 == ++v13)
      {
        LODWORD(v13) = a3;
        break;
      }
    }
    if ((v13 - 80) >= 0xFFFFFFB1)
    {
      if ((int)v13 + 5 <= a3)
      {
        uint64_t v15 = &v12[v13];
        int v16 = v15[1];
        if (v15[1] && (v16 != 1 || v15[2]))
        {
          int v14 = "bad compression info";
        }
        else
        {
          uint64_t v17 = (v13 + 3);
          uint64_t v18 = v17;
          while (v12[v18])
          {
            if (a3 == ++v18)
            {
              LODWORD(v18) = a3;
              break;
            }
          }
          int v19 = v18 + 1;
          if ((int)v18 + 1 >= a3)
          {
            int v21 = v18 + 1;
          }
          else
          {
            unint64_t v20 = &v12[v19];
            int v21 = v18 + 1;
            while (*v20++)
            {
              if (a3 == ++v21)
              {
                int v21 = a3;
                break;
              }
            }
          }
          unsigned int v23 = v21 + 1;
          if (v16 || a3 < v23)
          {
            int v14 = "truncated";
            if (!v16 || a3 <= v23) {
              return png_chunk_benign_error(a1, v14);
            }
            unint64_t v27 = -1;
            if (png_decompress_chunk(a1, a3, v21 + 1, &v27) == 1)
            {
              uint64_t v12 = *(Bytef **)(a1 + 936);
            }
            else
            {
              int v14 = *(const char **)(a1 + 144);
              if (v14) {
                return png_chunk_benign_error(a1, v14);
              }
            }
          }
          else
          {
            unint64_t v27 = a3 - v23;
          }
          v26[0] = 0;
          unint64_t v24 = v27;
          v12[v27 + v23] = 0;
          if (v16) {
            int v25 = 2;
          }
          else {
            int v25 = 1;
          }
          LODWORD(v26[0]) = v25;
          v26[5] = &v12[v17];
          v26[6] = &v12[v19];
          v26[1] = v12;
          void v26[2] = &v12[v23];
          v26[3] = 0;
          v26[4] = v24;
          uint64_t result = png_set_text_2((void (**)(void))a1, a2, (uint64_t)v26, 1);
          if (!result) {
            return result;
          }
          int v14 = "insufficient memory";
        }
      }
      else
      {
        int v14 = "truncated";
      }
    }
    else
    {
LABEL_19:
      int v14 = "bad keyword";
    }
    return png_chunk_benign_error(a1, v14);
  }
  png_crc_finish(a1, a3);
  int v9 = "no space in chunk cache";
LABEL_23:

  return png_chunk_benign_error(a1, v9);
}

uint64_t png_handle_tEXt(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unsigned int v3 = a3;
  int v6 = *(_DWORD *)(a1 + 884);
  if (v6)
  {
    int v7 = v6 - 1;
    if (!v7)
    {
      return png_crc_finish(a1, a3);
    }
    *(_DWORD *)(a1 + 884) = v7;
    if (v7 == 1)
    {
      png_crc_finish(a1, a3);
      int v9 = "no space in chunk cache";
LABEL_22:
      return png_chunk_benign_error(a1, v9);
    }
  }
  int v10 = *(_DWORD *)(a1 + 76);
  if ((v10 & 1) == 0) {
    png_chunk_error((void (**)(void))a1, "missing IHDR");
  }
  if ((v10 & 4) != 0) {
    *(_DWORD *)(a1 + 76) = v10 | 8;
  }
  uint64_t buffer = (Bytef *)png_read_buffer(a1, (a3 + 1), 1);
  if (!buffer)
  {
    int v9 = "out of memory";
    goto LABEL_22;
  }
  uint64_t v12 = buffer;
  png_crc_read(a1, buffer, v3);
  uint64_t result = png_crc_finish(a1, 0);
  if (!result)
  {
    uint64_t v13 = 0;
    v12[v3] = 0;
    while (v12[v13++])
      ;
    uint64_t v15 = v3 + 1 == v13 ? v12 : v12 + 1;
    v16[1] = v12;
    v16[0] = 0xFFFFFFFFLL;
    uint64_t v20 = 0;
    uint64_t v21 = 0;
    uint64_t v19 = 0;
    uint64_t v17 = (const char *)&v15[v13 - 1];
    size_t v18 = strlen(v17);
    uint64_t result = png_set_text_2((void (**)(void))a1, a2, (uint64_t)v16, 1);
    if (result) {
      return png_warning(a1, "Insufficient memory to process text chunk");
    }
  }
  return result;
}

void *png_read_buffer(uint64_t a1, size_t size, int a3)
{
  int v6 = *(void **)(a1 + 936);
  if (v6)
  {
    if (*(void *)(a1 + 944) >= size) {
      return v6;
    }
    *(void *)(a1 + 936) = 0;
    *(void *)(a1 + 944) = 0;
    png_free(a1, v6);
  }
  int v7 = png_malloc_base(a1, size);
  if (v7)
  {
    int v6 = v7;
    bzero(v7, size);
    *(void *)(a1 + 936) = v6;
    *(void *)(a1 + 944) = size;
  }
  else
  {
    if (a3 <= 1)
    {
      if (!a3) {
        png_chunk_error((void (**)(void))a1, "insufficient memory to read chunk");
      }
      png_chunk_warning(a1, "insufficient memory to read chunk");
    }
    return 0;
  }
  return v6;
}

double _cg_png_create_info_struct(uint64_t a1)
{
  if (a1)
  {
    int v1 = png_malloc_base(a1, 0x188uLL);
    if (v1)
    {
      v1[48] = 0;
      double result = 0.0;
      *((_OWORD *)v1 + 22) = 0u;
      *((_OWORD *)v1 + 23) = 0u;
      *((_OWORD *)v1 + 20) = 0u;
      *((_OWORD *)v1 + 21) = 0u;
      *((_OWORD *)v1 + 18) = 0u;
      *((_OWORD *)v1 + 19) = 0u;
      *((_OWORD *)v1 + 16) = 0u;
      *((_OWORD *)v1 + 17) = 0u;
      *((_OWORD *)v1 + 14) = 0u;
      *((_OWORD *)v1 + 15) = 0u;
      *((_OWORD *)v1 + 12) = 0u;
      *((_OWORD *)v1 + 13) = 0u;
      *((_OWORD *)v1 + 10) = 0u;
      *((_OWORD *)v1 + 11) = 0u;
      *((_OWORD *)v1 + 8) = 0u;
      *((_OWORD *)v1 + 9) = 0u;
      *((_OWORD *)v1 + 6) = 0u;
      *((_OWORD *)v1 + 7) = 0u;
      *((_OWORD *)v1 + 4) = 0u;
      *((_OWORD *)v1 + 5) = 0u;
      *((_OWORD *)v1 + 2) = 0u;
      *((_OWORD *)v1 + 3) = 0u;
      *(_OWORD *)int v1 = 0u;
      *((_OWORD *)v1 + 1) = 0u;
    }
  }
  return result;
}

void *png_malloc_base(uint64_t a1, size_t size)
{
  if (!size) {
    return 0;
  }
  if (a1)
  {
    uint64_t v2 = *(uint64_t (**)(void))(a1 + 824);
    if (v2) {
      return (void *)v2();
    }
  }
  return malloc_type_malloc(size, 0xB622AF59uLL);
}

uint64_t png_set_text_2(void (**a1)(void), uint64_t a2, uint64_t a3, signed int a4)
{
  uint64_t v4 = 0;
  if (!a3) {
    return v4;
  }
  uint64_t v5 = (uint64_t)a1;
  if (!a1) {
    return v4;
  }
  uint64_t v6 = a2;
  if (!a2 || a4 < 1) {
    return v4;
  }
  unsigned int v9 = *(_DWORD *)(a2 + 148);
  if ((int)(*(_DWORD *)(a2 + 152) - v9) < a4)
  {
    if ((v9 ^ 0x7FFFFFFF) < a4
      || ((int)(v9 + a4) >= 2147483639 ? (unsigned int v10 = 0x7FFFFFFF) : (unsigned int v10 = ((v9 + a4) & 0xFFFFFFF8) + 8),
          (unsigned int v11 = png_realloc_array(a1, *(const void **)(a2 + 160), v9, v10 - v9, 0x38uLL)) == 0))
    {
      long long v41 = "too many text chunks";
      uint64_t v4 = 1;
      uint64_t v42 = v5;
      goto LABEL_46;
    }
    uint64_t v12 = v11;
    png_free(v5, *(void **)(v6 + 160));
    *(void *)(v6 + 160) = v12;
    *(_DWORD *)(v6 + 300) |= 0x4000u;
    *(_DWORD *)(v6 + 152) = v10;
  }
  uint64_t v13 = a4;
  int v14 = (const char **)(a3 + 48);
  uint64_t v46 = v5;
  uint64_t v44 = v6;
  while (1)
  {
    uint64_t v15 = *(v14 - 5);
    if (v15) {
      break;
    }
LABEL_42:
    v14 += 7;
    if (!--v13) {
      return 0;
    }
  }
  int v16 = *((_DWORD *)v14 - 12);
  if ((v16 - 3) <= 0xFFFFFFFB)
  {
    png_chunk_report(v5, "text compression mode is out of range", 1);
    goto LABEL_42;
  }
  uint64_t v17 = *(void *)(v6 + 160);
  int v18 = *(_DWORD *)(v6 + 148);
  size_t v19 = strlen(v15);
  if (v16 < 1)
  {
    size_t v21 = 0;
LABEL_23:
    size_t v22 = 0;
    goto LABEL_24;
  }
  uint64_t v20 = *(v14 - 1);
  if (v20) {
    size_t v21 = strlen(v20);
  }
  else {
    size_t v21 = 0;
  }
  if (!*v14) {
    goto LABEL_23;
  }
  size_t v22 = strlen(*v14);
LABEL_24:
  unsigned int v23 = *(v14 - 4);
  if (v23 && *v23)
  {
    size_t v24 = v22;
    size_t v25 = strlen(v23);
    size_t v22 = v24;
  }
  else
  {
    size_t v25 = 0;
    if (v16 < 1) {
      int v16 = -1;
    }
    else {
      int v16 = 1;
    }
  }
  uint64_t v45 = v17 + 56 * v18;
  *(_DWORD *)uint64_t v45 = v16;
  size_t v26 = v22;
  size_t __n = v25;
  unint64_t v27 = png_malloc_base(v46, v19 + v21 + v22 + v25 + 4);
  *(void *)(v45 + 8) = v27;
  long long v28 = (void *)(v45 + 8);
  if (v27)
  {
    uint64_t v29 = v17;
    memcpy(v27, *(v14 - 5), v19);
    *(unsigned char *)(*v28 + v19) = 0;
    if (*((int *)v14 - 12) < 1)
    {
      int v31 = v18;
      uint64_t v34 = v29 + 56 * v18;
      *(void *)(v34 + 40) = 0;
      *(void *)(v34 + 48) = 0;
      size_t v26 = v19;
    }
    else
    {
      uint64_t v30 = (void *)(*v28 + v19 + 1);
      int v31 = v18;
      uint64_t v32 = v29 + 56 * v18;
      *(void *)(v32 + 40) = v30;
      memcpy(v30, *(v14 - 1), v21);
      *(unsigned char *)(*(void *)(v32 + 40) + v21) = 0;
      int v33 = (void *)(*(void *)(v32 + 40) + v21 + 1);
      *(void *)(v32 + 48) = v33;
      long long v28 = (void *)(v32 + 48);
      memcpy(v33, *v14, v26);
      *(unsigned char *)(*v28 + v26) = 0;
    }
    uint64_t v6 = v44;
    unint64_t v35 = (void *)(*v28 + v26 + 1);
    uint64_t v36 = v29 + 56 * v31;
    *(void *)(v36 + 16) = v35;
    uint64_t v37 = (void **)(v36 + 16);
    size_t v38 = __n;
    if (__n)
    {
      memcpy(v35, *(v14 - 4), __n);
      size_t v38 = __n;
      unint64_t v35 = *v37;
    }
    uint64_t v5 = v46;
    *((unsigned char *)v35 + v38) = 0;
    if (*(int *)v45 <= 0) {
      size_t v39 = v38;
    }
    else {
      size_t v39 = 0;
    }
    if (*(int *)v45 <= 0) {
      size_t v38 = 0;
    }
    uint64_t v40 = v29 + 56 * v31;
    *(void *)(v40 + 24) = v39;
    *(void *)(v40 + 32) = v38;
    ++*(_DWORD *)(v44 + 148);
    goto LABEL_42;
  }
  long long v41 = "text chunk: out of memory";
  uint64_t v4 = 1;
  uint64_t v42 = v46;
LABEL_46:
  png_chunk_report(v42, v41, 1);
  return v4;
}

void _cg_png_set_unknown_chunks(void (**a1)(void), uint64_t a2, uint64_t a3, signed int a4)
{
  if (a3 && a1 && a2 && a4 >= 1)
  {
    signed int v8 = *(_DWORD *)(a2 + 312);
    unsigned int v9 = png_realloc_array(a1, *(const void **)(a2 + 304), v8, a4, 0x20uLL);
    if (v9)
    {
      unsigned int v10 = v9;
      unsigned int v11 = &v9[32 * v8];
      int v12 = a4 + 1;
      for (uint64_t i = a3 + 16; ; i += 32)
      {
        *(_DWORD *)unsigned int v11 = *(_DWORD *)(i - 16);
        v11[4] = 0;
        unsigned char v11[24] = check_location((uint64_t)a1, *(unsigned char *)(i + 8));
        if (*(void *)i)
        {
          int v14 = png_malloc_base((uint64_t)a1, *(void *)i);
          size_t v15 = *(void *)i;
          *((void *)v11 + 1) = v14;
          *((void *)v11 + 2) = v15;
          if (!v14)
          {
            png_chunk_report((uint64_t)a1, "unknown chunk: out of memory", 1);
            goto LABEL_13;
          }
          memcpy(v14, *(const void **)(i - 8), *(void *)i);
        }
        else
        {
          *((void *)v11 + 1) = 0;
          *((void *)v11 + 2) = 0;
        }
        v11 += 32;
        ++v8;
LABEL_13:
        if (--v12 <= 1)
        {
          png_free((uint64_t)a1, *(void **)(a2 + 304));
          *(void *)(a2 + 304) = v10;
          *(_DWORD *)(a2 + 312) = v8;
          *(_DWORD *)(a2 + 300) |= 0x200u;
          return;
        }
      }
    }
    png_chunk_report((uint64_t)a1, "too many unknown chunks", 1);
  }
}

char *png_realloc_array(void (**a1)(void), const void *a2, unsigned int a3, unsigned int a4, unint64_t a5)
{
  if ((a3 & 0x80000000) != 0 || (int)a4 < 1 || !a5 || !a2 && a3) {
    _cg_png_error(a1, "internal error: array realloc");
  }
  if ((a3 ^ 0x7FFFFFFF) < a4) {
    return 0;
  }
  unsigned int v9 = 0;
  if (is_mul_ok(a5, a4 + a3))
  {
    unsigned int v10 = (char *)png_malloc_base((uint64_t)a1, (a4 + a3) * a5);
    unsigned int v9 = v10;
    if (v10)
    {
      if (a3)
      {
        size_t v11 = a3 * a5;
        memcpy(v10, a2, v11);
      }
      else
      {
        size_t v11 = 0;
      }
      bzero(&v9[v11], a4 * a5);
    }
  }
  return v9;
}

uint64_t check_location(uint64_t a1, char a2)
{
  int v2 = a2 & 0xB;
  if ((a2 & 0xB) == 0)
  {
    if ((*(unsigned char *)(a1 + 77) & 0x80) != 0
      || (png_app_warning(a1, "png_set_unknown_chunks now expects a valid location"),
          (int v2 = *(_DWORD *)(a1 + 76) & 0xB) == 0))
    {
      _cg_png_error((void (**)(void))a1, "invalid location in png_set_unknown_chunks");
    }
  }
  do
  {
    int v4 = v2;
    int v5 = v2 & -v2;
    v2 ^= v5;
  }
  while (v4 != v5);
  return v4;
}

uint64_t png_icc_check_header(uint64_t a1, uint64_t a2, unsigned char *a3, unint64_t a4, uint64_t a5, char a6)
{
  uint64_t v6 = a3;
  uint64_t v7 = a2;
  uint64_t v8 = a1;
  unint64_t v9 = bswap32(*(_DWORD *)a5);
  if (v9 != a4)
  {
    int v12 = "length does not match profile";
LABEL_13:
    a4 = v9;
    goto LABEL_14;
  }
  if ((a4 & 3) != 0 && *(unsigned __int8 *)(a5 + 8) >= 4u)
  {
    a4 = a4;
    int v12 = "invalid length";
LABEL_5:
    a1 = v8;
    a2 = v7;
    a3 = v6;
LABEL_14:
    png_icc_profile_error(a1, a2, a3, a4, v12);
    return 0;
  }
  unint64_t v9 = bswap32(*(_DWORD *)(a5 + 128));
  if (v9 > 0x1555554A || 12 * (int)v9 + 132 > a4)
  {
    int v12 = "tag count too large";
    goto LABEL_13;
  }
  a4 = bswap32(*(_DWORD *)(a5 + 64));
  if (a4 >= 0xFFFF)
  {
    int v12 = "invalid rendering intent";
    goto LABEL_5;
  }
  if (a4 >= 4) {
    png_icc_profile_error(a1, 0, a3, a4, "intent outside defined range");
  }
  a4 = bswap32(*(_DWORD *)(a5 + 36));
  if (a4 != 1633907568)
  {
    int v12 = "invalid signature";
    goto LABEL_5;
  }
  if (*(void *)(a5 + 68) != 0x100D6F60000 || *(_DWORD *)(a5 + 76) != 768802816) {
    png_icc_profile_error(v8, 0, v6, 0, "PCS illuminant is not D50");
  }
  a4 = bswap32(*(_DWORD *)(a5 + 16));
  if (a4 == 1196573017)
  {
    if ((a6 & 2) != 0)
    {
      int v12 = "Gray color space not permitted on RGB PNG";
      a1 = v8;
      a2 = v7;
      a3 = v6;
      a4 = 1196573017;
      goto LABEL_14;
    }
  }
  else
  {
    if (a4 != 1380401696)
    {
      int v12 = "invalid ICC profile color space";
      goto LABEL_5;
    }
    if ((a6 & 2) == 0)
    {
      int v12 = "RGB color space not permitted on grayscale PNG";
      a1 = v8;
      a2 = v7;
      a3 = v6;
      a4 = 1380401696;
      goto LABEL_14;
    }
  }
  unint64_t v16 = bswap32(*(_DWORD *)(a5 + 12));
  if ((int)v16 <= 1852662635)
  {
    if (v16 == 1633842036)
    {
      int v12 = "invalid embedded Abstract ICC profile";
      a1 = v8;
      a2 = v7;
      a3 = v6;
      a4 = 1633842036;
      goto LABEL_14;
    }
    if (v16 == 1818848875)
    {
      int v12 = "unexpected DeviceLink ICC profile class";
      a1 = v8;
      a2 = v7;
      a3 = v6;
      a4 = 1818848875;
      goto LABEL_14;
    }
    int v17 = 1835955314;
  }
  else if ((int)v16 > 1935896177)
  {
    if (v16 == 1935896178) {
      goto LABEL_47;
    }
    int v17 = 1936744803;
  }
  else
  {
    if (v16 == 1852662636)
    {
      int v18 = "unexpected NamedColor ICC profile class";
      uint64_t v19 = v8;
      uint64_t v20 = v6;
      unint64_t v16 = 1852662636;
      goto LABEL_46;
    }
    int v17 = 1886549106;
  }
  if (v16 != v17)
  {
    int v18 = "unrecognized ICC profile class";
    uint64_t v19 = v8;
    uint64_t v20 = v6;
LABEL_46:
    png_icc_profile_error(v19, 0, v20, v16, v18);
  }
LABEL_47:
  a4 = bswap32(*(_DWORD *)(a5 + 20));
  uint64_t result = 1;
  if (a4 != 1281450528 && a4 != 1482250784)
  {
    int v12 = "unexpected ICC PCS encoding";
    goto LABEL_5;
  }
  return result;
}

uint64_t png_icc_set_sRGB(uint64_t result, uint64_t a2, unsigned int *a3, uLong a4)
{
  if ((~*(_DWORD *)(result + 680) & 0x30) != 0)
  {
    uint64_t v6 = result;
    uint64_t v7 = 0;
    uInt v8 = 0;
    unsigned int v9 = bswap32(a3[21]);
    unsigned int v10 = 0x10000;
    while (1)
    {
      if (v9 == png_sRGB_checks[v7 + 3]
        && bswap32(a3[22]) == png_sRGB_checks[v7 + 4]
        && bswap32(a3[23]) == png_sRGB_checks[v7 + 5]
        && bswap32(a3[24]) == png_sRGB_checks[v7 + 6])
      {
        if (!v8)
        {
          uInt v8 = bswap32(*a3);
          unsigned int v10 = bswap32(a3[16]);
        }
        if (v8 == png_sRGB_checks[v7 + 2] && v10 == HIWORD(png_sRGB_checks[v7 + 7])) {
          break;
        }
      }
      v7 += 8;
      if (v7 == 40) {
        return result;
      }
    }
    if (!a4)
    {
      uLong v11 = adler32(0, 0, 0);
      a4 = adler32(v11, (const Bytef *)a3, v8);
    }
    if (a4 == png_sRGB_checks[v7]
      && (uLong v12 = crc32(0, 0, 0), crc32(v12, (const Bytef *)a3, v8) == png_sRGB_checks[v7 + 1]))
    {
      unsigned int v13 = bswap32(a3[16]);
      return png_colorspace_set_sRGB(v6, a2, v13);
    }
    else
    {
      return png_chunk_report(v6, "Not recognizing known sRGB profile that has been edited", 0);
    }
  }
  return result;
}

uint64_t png_icc_check_tag_table(uint64_t a1, uint64_t a2, unsigned char *a3, unsigned int a4, uint64_t a5)
{
  unsigned int v5 = bswap32(*(_DWORD *)(a5 + 128));
  if (!v5) {
    return 1;
  }
  for (uint64_t i = a5 + 132; ; i += 12)
  {
    unint64_t v11 = bswap32(*(_DWORD *)i);
    unsigned int v12 = _byteswap_ulong(*(_DWORD *)(i + 4));
    BOOL v13 = a4 >= v12;
    unsigned int v14 = a4 - v12;
    if (!v13 || bswap32(*(_DWORD *)(i + 8)) > v14) {
      break;
    }
    if ((*(unsigned char *)(i + 7) & 3) != 0) {
      png_icc_profile_error(a1, 0, a3, v11, "ICC profile tag start not a multiple of 4");
    }
    if (!--v5) {
      return 1;
    }
  }
  png_icc_profile_error(a1, a2, a3, v11, "ICC profile tag outside profile");
  return 0;
}

uint64_t png_icc_check_length(uint64_t a1, uint64_t a2, unsigned char *a3, unint64_t a4)
{
  if (a4 <= 0x83)
  {
    a4 = a4;
    int v4 = "too short";
LABEL_6:
    png_icc_profile_error(a1, a2, a3, a4, v4);
    return 0;
  }
  unint64_t v5 = *(void *)(a1 + 888);
  if (v5 && v5 < a4)
  {
    a4 = a4;
    int v4 = "exceeds application limits";
    goto LABEL_6;
  }
  return 1;
}

uint64_t png_icc_profile_error(uint64_t a1, uint64_t a2, unsigned char *a3, unint64_t a4, unsigned char *a5)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  if (a2) {
    *(_WORD *)(a2 + 74) |= 0x8000u;
  }
  int v27 = 0;
  memset(v26, 0, sizeof(v26));
  unint64_t v10 = png_safecat((uint64_t)v26, 0xC4uLL, 0, "profile '");
  unint64_t v11 = png_safecat((uint64_t)v26, v10 + 79, v10, a3);
  unint64_t v12 = png_safecat((uint64_t)v26, 0xC4uLL, v11, "': ");
  unint64_t v13 = v12;
  unint64_t v14 = a4 >> 24;
  if ((a4 >> 24 == 32 || v14 - 48 < 0xA || (v14 & 0xFFFFFFFFFFFFFFDFLL) - 65 <= 0x19)
    && (((a4 >> 16) & 0xDF) - 65 < 0x1A || BYTE2(a4) == 32 || (unint64_t)BYTE2(a4) - 48 <= 9)
    && (((a4 >> 8) & 0xDF) - 65 < 0x1A || BYTE1(a4) == 32 || (unint64_t)BYTE1(a4) - 48 <= 9)
    && ((unint64_t)(a4 & 0xDF) - 65 < 0x1A
     || a4 == 32
     || (unint64_t)a4 - 48 <= 9))
  {
    uint64_t v20 = (char *)v26 + v12;
    *((unsigned char *)v26 + v12) = 39;
    char v21 = BYTE3(a4);
    if (BYTE3(a4) - 32 >= 0x5F) {
      char v21 = 63;
    }
    v20[1] = v21;
    char v22 = BYTE2(a4);
    if (BYTE2(a4) - 32 >= 0x5F) {
      char v22 = 63;
    }
    v20[2] = v22;
    unsigned int v23 = a4 >> 8;
    if (BYTE1(a4) - 32 >= 0x5F) {
      LOBYTE(v23) = 63;
    }
    void v20[3] = v23;
    if (a4 - 32 >= 0x5F) {
      char v24 = 63;
    }
    else {
      char v24 = a4;
    }
    v20[4] = v24;
    *(_WORD *)(v20 + 5) = 14887;
    unint64_t v17 = v12 + 8;
    v20[7] = 32;
  }
  else
  {
    memset(v25, 0, sizeof(v25));
    size_t v15 = (unsigned char *)png_format_number((unint64_t)v25, (uint64_t)v26, 3, a4);
    unint64_t v16 = png_safecat((uint64_t)v26, 0xC4uLL, v13, v15);
    unint64_t v17 = png_safecat((uint64_t)v26, 0xC4uLL, v16, "h: ");
  }
  png_safecat((uint64_t)v26, 0xC4uLL, v17, a5);
  if (a2) {
    int v18 = 2;
  }
  else {
    int v18 = 1;
  }
  return png_chunk_report(a1, (char *)v26, v18);
}

unint64_t png_safecat(uint64_t a1, unint64_t a2, unint64_t a3, unsigned char *a4)
{
  if (a1 && a3 < a2)
  {
    if (a4 && (char v4 = *a4) != 0 && a2 - 1 > a3)
    {
      unint64_t v5 = a4 + 1;
      do
      {
        *(unsigned char *)(a1 + a3) = v4;
        unint64_t v6 = a3 + 1;
        int v7 = *v5++;
        char v4 = v7;
        if (v7) {
          BOOL v8 = v6 >= a2 - 1;
        }
        else {
          BOOL v8 = 1;
        }
        ++a3;
      }
      while (!v8);
    }
    else
    {
      unint64_t v6 = a3;
    }
    *(unsigned char *)(a1 + v6) = 0;
    return v6;
  }
  return a3;
}

uint64_t png_chunk_warning(uint64_t a1, const char *a2)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    memset(v6, 0, sizeof(v6));
    png_format_buffer(a1, (uint64_t)v6, (uint64_t)a2);
    return png_warning(a1, v6);
  }
  else
  {
    char v4 = (FILE **)MEMORY[0x1E4F143C8];
    fprintf((FILE *)*MEMORY[0x1E4F143C8], "libpng warning: %s", a2);
    unint64_t v5 = *v4;
    return fputc(10, v5);
  }
}

uint64_t png_warning(uint64_t a1, unsigned char *a2)
{
  if (a1)
  {
    if (*a2 == 35)
    {
      for (uint64_t i = 1; i != 15; ++i)
      {
        if (a2[i] == 32) {
          break;
        }
      }
    }
    else
    {
      LODWORD(i) = 0;
    }
    unsigned int v3 = *(uint64_t (**)(void))(a1 + 8);
    if (v3)
    {
      return v3();
    }
  }
  else
  {
    LODWORD(i) = 0;
  }
  unint64_t v5 = (FILE **)MEMORY[0x1E4F143C8];
  fprintf((FILE *)*MEMORY[0x1E4F143C8], "libpng warning: %s", &a2[i]);
  unint64_t v6 = *v5;

  return fputc(10, v6);
}

uint64_t png_format_buffer(uint64_t result, uint64_t a2, uint64_t a3)
{
  LODWORD(v3) = 0;
  unsigned int v4 = *(_DWORD *)(result + 312);
  for (int i = 24; i != -8; i -= 8)
  {
    unsigned int v6 = v4 >> i;
    int v7 = (v4 >> i);
    unsigned int v8 = v7 - 123;
    unsigned int v9 = v7 - 91;
    uint64_t v10 = (int)v3;
    if (v8 >= 0xFFFFFFC6 && v9 > 5)
    {
      *(unsigned char *)(a2 + (int)v3) = v6;
    }
    else
    {
      unint64_t v12 = (unsigned char *)(a2 + (int)v3);
      *unint64_t v12 = 91;
      v12[1] = png_digit[v6 >> 4];
      LODWORD(v3) = v3 + 3;
      void v12[2] = png_digit[v6 & 0xF];
      *(unsigned char *)(a2 + v10 + 3) = 93;
    }
    uint64_t v13 = (int)v3;
    uint64_t v3 = (int)v3 + 1;
  }
  if (a3)
  {
    uint64_t v14 = 0;
    *(unsigned char *)(a2 + v3) = 58;
    int v15 = v13 + 3;
    *(unsigned char *)(v13 + a2 + 2) = 32;
    LODWORD(v3) = v13 + 198;
    while (*(unsigned char *)(a3 + v14))
    {
      *(unsigned char *)(a2 + v15 + v14) = *(unsigned char *)(a3 + v14);
      if (++v14 == 195) {
        goto LABEL_15;
      }
    }
    LODWORD(v3) = v15 + v14;
  }
LABEL_15:
  *(unsigned char *)(a2 + (int)v3) = 0;
  return result;
}

uint64_t png_chunk_report(uint64_t a1, char *a2, int a3)
{
  if ((*(unsigned char *)(a1 + 77) & 0x80) != 0)
  {
    if (a3 > 1) {
      return png_chunk_benign_error(a1, a2);
    }
    else {
      return png_chunk_warning(a1, a2);
    }
  }
  else if (a3 <= 0)
  {
    return png_app_warning(a1, a2);
  }
  else
  {
    return png_app_error(a1, a2);
  }
}

uint64_t png_chunk_benign_error(uint64_t a1, const char *a2)
{
  if ((*(unsigned char *)(a1 + 82) & 0x10) == 0) {
    png_chunk_error((void (**)(void))a1, a2);
  }

  return png_chunk_warning(a1, a2);
}

uint64_t _cg_png_set_expand_gray_1_2_4_to_8(uint64_t result)
{
  if (result)
  {
    int v1 = *(_DWORD *)(result + 80);
    if ((v1 & 0x40) != 0)
    {
      return png_app_error(result, "invalid after png_start_read_image or png_read_update_info");
    }
    else
    {
      *(_DWORD *)(result + 80) = v1 | 0x4000;
      *(_DWORD *)(result + 88) |= 0x1000u;
    }
  }
  return result;
}

uint64_t ASTCReadPlugin::ASTCReadPlugin(uint64_t a1, uint64_t a2, int a3, uint64_t a4, int a5)
{
  uint64_t result = CommonASTCReadPlugin::CommonASTCReadPlugin(a1, a2, a3, a4, a5);
  *(void *)uint64_t result = &unk_1ED4E0EB0;
  *(void *)(result + 502) = -1;
  *(void *)(result + 488) = -1;
  *(void *)(result + 496) = -1;
  *(_WORD *)(result + 504) = 0;
  return result;
}

double ATXReadPlugin::ATXReadPlugin(uint64_t a1, uint64_t a2, int a3, uint64_t a4, int a5)
{
  uint64_t v5 = CommonASTCReadPlugin::CommonASTCReadPlugin(a1, a2, a3, a4, a5);
  *(void *)uint64_t v5 = &unk_1ED4DF4E0;
  double result = 0.0;
  *(_OWORD *)(v5 + 488) = 0u;
  *(_OWORD *)(v5 + 504) = 0u;
  *(_OWORD *)(v5 + 520) = 0u;
  *(_OWORD *)(v5 + 536) = 0u;
  *(_OWORD *)(v5 + 552) = 0u;
  *(_OWORD *)(v5 + 568) = 0u;
  *(_OWORD *)(v5 + 584) = 0u;
  *(_OWORD *)(v5 + 600) = 0u;
  *(_OWORD *)(v5 + 616) = 0u;
  *(void *)(v5 + 632) = 0;
  return result;
}

uint64_t CommonASTCReadPlugin::CommonASTCReadPlugin(uint64_t a1, uint64_t a2, int a3, uint64_t a4, int a5)
{
  uint64_t v6 = IIOReadPlugin::IIOReadPlugin(a1, a2, a3, a4, a5);
  *(void *)uint64_t v6 = &unk_1ED4E4E90;
  *(void *)(v6 + 472) = 0;
  *(void *)(v6 + 480) = 0;
  *(void *)(v6 + 444) = 0;
  *(void *)(v6 + 452) = 0;
  *(void *)(v6 + 436) = 0;
  std::allocate_shared[abi:ne180100]<ASTCTextureImp,std::allocator<ASTCTextureImp>,unsigned int &,void>((unsigned int *)(v6 + 208), &v10);
  long long v7 = v10;
  long long v10 = 0uLL;
  unsigned int v8 = *(std::__shared_weak_count **)(a1 + 480);
  *(_OWORD *)(a1 + 472) = v7;
  if (v8)
  {
    std::__shared_weak_count::__release_shared[abi:ne180100](v8);
    if (*((void *)&v10 + 1)) {
      std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v10 + 1));
    }
  }
  *(void *)(a1 + 464) = 0;
  return a1;
}

void sub_1885DC97C(_Unwind_Exception *a1)
{
  uint64_t v3 = (std::__shared_weak_count *)*((void *)v1 + 60);
  if (v3) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v3);
  }
  IIOReadPlugin::~IIOReadPlugin(v1);
  _Unwind_Resume(a1);
}

void *std::allocate_shared[abi:ne180100]<ASTCTextureImp,std::allocator<ASTCTextureImp>,unsigned int &,void>@<X0>(unsigned int *a1@<X1>, void *a2@<X8>)
{
  unsigned int v4 = operator new(0x110uLL);
  double result = std::__shared_ptr_emplace<ASTCTextureImp>::__shared_ptr_emplace[abi:ne180100]<unsigned int &,std::allocator<ASTCTextureImp>,0>(v4, a1);
  *a2 = v4 + 3;
  a2[1] = v4;
  return result;
}

void sub_1885DC9E4(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *std::__shared_ptr_emplace<ASTCTextureImp>::__shared_ptr_emplace[abi:ne180100]<unsigned int &,std::allocator<ASTCTextureImp>,0>(void *a1, unsigned int *a2)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = &unk_1ED4EF348;
  ASTCTextureImp::ASTCTextureImp((ASTCTextureImp *)(a1 + 3), *a2);
  return a1;
}

void sub_1885DCA44(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void ASTCTextureImp::ASTCTextureImp(ASTCTextureImp *this, int a2)
{
  *((_DWORD *)this + 2) = a2;
  *(void *)this = &unk_1ED4E0FD8;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 6) = 0u;
  *((_OWORD *)this + 7) = 0u;
  *((_OWORD *)this + 8) = 0u;
  *((_OWORD *)this + 9) = 0u;
  *((_OWORD *)this + 10) = 0u;
  *((_OWORD *)this + 11) = 0u;
  *((_OWORD *)this + 12) = 0u;
  *((_OWORD *)this + 13) = 0u;
  *((_OWORD *)this + 14) = 0u;
  *((void *)this + 30) = 0;
  pthread_mutex_init((pthread_mutex_t *)((char *)this + 168), 0);
}

void sub_1885DCACC(_Unwind_Exception *a1, uint64_t a2, const char *a3)
{
  _cg_jpeg_mem_term(v3, a2, a3);
  _Unwind_Resume(a1);
}

uint64_t _CGImageDestinationFinalize(void *a1)
{
  atomic_fetch_add_explicit(&gIDRCount, 0xFFFFFFFFFFFFFFFFLL, memory_order_relaxed);
  uint64_t result = a1[3];
  if (result) {
    uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
  }
  a1[2] = 0;
  a1[3] = 0;
  return result;
}

void IIOImageDestination::~IIOImageDestination(IIOImageDestination *this)
{
  IIOImageDestination::~IIOImageDestination(this);

  JUMPOUT(0x18C11C0E0);
}

{
  const void *v2;
  void *v3;
  const void *v4;
  uint64_t v5;
  const void *v6;
  CGImageRef *i;
  void *j;
  void *v9;
  CGImage *v10;
  uint64_t v11;
  const void *v12;
  void *v13;
  void *v14;

  *(void *)this = &unk_1ED4E4C20;
  uint64_t v3 = (void *)((char *)this + 16);
  int v2 = (const void *)*((void *)this + 2);
  if (v2) {
    CFRelease(v2);
  }
  *uint64_t v3 = 0;
  v3[1] = 0;
  unsigned int v4 = (const void *)*((void *)this + 20);
  if (v4) {
    CFRelease(v4);
  }
  *((void *)this + 20) = 0;
  uint64_t v5 = *((void *)this + 11);
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
  }
  *((void *)this + 11) = 0;
  uint64_t v6 = (const void *)*((void *)this + 12);
  if (v6) {
    CFRelease(v6);
  }
  *((void *)this + 12) = 0;
  for (int i = (CGImageRef *)*((void *)this + 13); i != *((CGImageRef **)this + 14); ++i)
    CGImageRelease(*i);
  unsigned int v9 = (void *)*((void *)this + 16);
  for (uint64_t j = (void *)*((void *)this + 17); v9 != j; ++v9)
  {
    if (*v9)
    {
      (*(void (**)(void))(*(void *)*v9 + 8))(*v9);
      uint64_t j = (void *)*((void *)this + 17);
    }
  }
  long long v10 = (CGImage *)*((void *)this + 21);
  if (v10)
  {
    CGImageRelease(v10);
    *((void *)this + 21) = 0;
  }
  unint64_t v11 = *((void *)this + 4);
  if (v11) {
    (*(void (**)(uint64_t))(*(void *)v11 + 8))(v11);
  }
  *((void *)this + 4) = 0;
  unint64_t v12 = (const void *)*((void *)this + 19);
  if (v12) {
    CFRelease(v12);
  }
  *((void *)this + 19) = 0;
  *((void *)this + 8) = 0;
  *((void *)this + 9) = 0;
  uint64_t v13 = (void *)*((void *)this + 16);
  if (v13)
  {
    *((void *)this + 17) = v13;
    operator delete(v13);
  }
  uint64_t v14 = (void *)*((void *)this + 13);
  if (v14)
  {
    *((void *)this + 14) = v14;
    operator delete(v14);
  }
}

uint64_t CreateExifBufferFromPropertiesJPEG(IIODictionary *a1, uint64_t a2, unsigned int a3, CGColorSpace *a4, const __CFData *a5, const __CFString *a6, unint64_t *a7)
{
  uint64_t v7 = MEMORY[0x1F4188790](a1, a2);
  unsigned int v9 = v8;
  long long v10 = (IIODictionary *)v7;
  v14[136] = *MEMORY[0x1E4F143B8];
  bzero(v14, 0x440uLL);
  bzero(v13, 0x9A0uLL);
  bzero(v12, 0x420uLL);
  if (v10)
  {
    IIODictionary::getObjectForKey(v10, @"{TIFF}");
    operator new();
  }
  if (v9) {
    *unsigned int v9 = 0;
  }
  return 0;
}

void sub_1885DDEAC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,char a56)
{
}

CFIndex validValueForKey(unsigned __int16 *a1, const __CFString *cf)
{
  CFIndex v2 = 0;
  if (!a1 || !cf) {
    return v2;
  }
  CFTypeID v5 = CFGetTypeID(cf);
  if (v5 == CFArrayGetTypeID() && (CFIndex Count = CFArrayGetCount((CFArrayRef)cf)) != 0)
  {
    uint64_t v7 = Count;
    if (Count < 1)
    {
      char v11 = 1;
      BOOL v15 = 1;
    }
    else
    {
      ValueAtIndedouble x = CFArrayGetValueAtIndex((CFArrayRef)cf, 0);
      CFTypeID v9 = CFGetTypeID(ValueAtIndex);
      if (v9 == CFNumberGetTypeID())
      {
        uint64_t v10 = 1;
        char v11 = 1;
        do
        {
          CFIndex v12 = v10;
          if (CFNumberIsFloatType((CFNumberRef)ValueAtIndex)) {
            char v11 = 0;
          }
          if (v7 == v12) {
            break;
          }
          ValueAtIndedouble x = CFArrayGetValueAtIndex((CFArrayRef)cf, v12);
          CFTypeID v13 = CFGetTypeID(ValueAtIndex);
          CFTypeID TypeID = CFNumberGetTypeID();
          uint64_t v10 = v12 + 1;
        }
        while (v13 == TypeID);
        BOOL v15 = v12 >= v7;
      }
      else
      {
        BOOL v15 = 0;
        char v11 = 1;
      }
    }
    unsigned int v18 = v11 & 1;
    int v17 = 1;
  }
  else
  {
    CFTypeID v16 = CFGetTypeID(cf);
    int v17 = 0;
    if (v16 == CFNumberGetTypeID())
    {
      uint64_t v7 = 0;
      unsigned int v18 = CFNumberIsFloatType((CFNumberRef)cf) == 0;
      BOOL v15 = 1;
    }
    else
    {
      uint64_t v7 = 0;
      BOOL v15 = 0;
      unsigned int v18 = 1;
    }
  }
  CFTypeID v19 = CFGetTypeID(cf);
  CFTypeID v20 = CFStringGetTypeID();
  CFTypeID v21 = v20;
  int v22 = a1[2];
  if (v22 == 4)
  {
    unsigned int v23 = *a1;
    if (a1[1] == 7)
    {
      switch(v23)
      {
        case 0xA000u:
          goto LABEL_24;
        case 0x9101u:
          return 4;
        case 0x9000u:
LABEL_24:
          if (v18)
          {
            if (v7 <= 1)
            {
              CFIndex v2 = 0;
              if (v23 == 36864 && v19 == v20) {
                return CFStringGetLength(cf) == 4;
              }
              return v2;
            }
            return 4;
          }
          break;
      }
    }
  }
  else
  {
    unsigned int v23 = *a1;
  }
  if (v23 == 42082)
  {
    char v25 = !v15;
    if (v7 < 7) {
      char v25 = 1;
    }
    if ((v25 & 1) == 0)
    {
      if ((unint64_t)v7 < 8) {
        return 56;
      }
      if (v7 == 8) {
        return 58;
      }
      return 8 * v7 - 12;
    }
    return 0;
  }
  if (v23 == 41995)
  {
    CFTypeID v24 = CFGetTypeID(cf);
    if (v24 == CFArrayGetTypeID())
    {
      CFIndex usedBufLen = 0;
      p_CFIndex usedBufLen = &usedBufLen;
      uint64_t v60 = 0x2000000000;
      uint64_t v61 = 4;
      memset(v57, 0, sizeof(v57));
      IIOArray::IIOArray((IIOArray *)v57, (const __CFArray *)cf);
      v56[0] = MEMORY[0x1E4F143A8];
      v56[1] = 0x40000000;
      v56[2] = ___ZL16validValueForKeyPK6tagdefPKv_block_invoke;
      v56[3] = &unk_1E53C6F80;
      v56[4] = &usedBufLen;
      IIOArray::enumerate((uint64_t)v57, (uint64_t)v56);
      CFIndex v2 = p_usedBufLen[3];
      IIOArray::~IIOArray((IIOArray *)v57);
      _Block_object_dispose(&usedBufLen, 8);
      return v2;
    }
    return 0;
  }
  if (v22 != 4)
  {
    int v26 = a1[1];
    if (v22 != 3) {
      goto LABEL_74;
    }
    if (v26 == 5)
    {
      if (v7) {
        goto LABEL_49;
      }
      if (v23 == 7 && v19 == v20) {
        return 24;
      }
      if (!v15)
      {
        uint64_t v7 = 0;
        goto LABEL_49;
      }
    }
    else
    {
      if (v7) {
        BOOL v32 = 0;
      }
      else {
        BOOL v32 = v26 == 32775;
      }
      int v33 = !v32;
      if (v32 && v23 == 7 && v19 == v20) {
        return 24;
      }
      if ((v33 | !v15)) {
        goto LABEL_74;
      }
    }
    if (v23 > 0x16 || ((1 << v23) & 0x500014) == 0) {
      goto LABEL_102;
    }
    return 24;
  }
  int v26 = a1[1];
  if (!v23 && v26 == 1 && ((v18 ^ 1) & 1) == 0) {
    return 4 * (v7 > 1);
  }
LABEL_74:
  if (v26 != 7)
  {
LABEL_102:
    if (v26 == 2 && v19 == v21)
    {
      v68.CFIndex length = CFStringGetLength(cf);
      CFIndex usedBufLen = 0;
      v68.location = 0;
      CFStringGetBytes(cf, v68, 0x8000100u, 0x3Fu, 0, 0, 0, &usedBufLen);
      if (usedBufLen) {
        return usedBufLen + 1;
      }
      else {
        return 0;
      }
    }
    if (v26 == 1) {
      unsigned int v40 = v18;
    }
    else {
      unsigned int v40 = 0;
    }
    if (v40 == 1)
    {
      uint64_t v41 = a1[2];
      BOOL v42 = v41 == 1;
      if (a1[2]) {
        int v43 = 0;
      }
      else {
        int v43 = v17;
      }
      BOOL v44 = v7 == v41 && v41 != 0;
      if (v43 | v44) {
        return v7;
      }
      else {
        return v42;
      }
    }
    if (v26 == 3) {
      unsigned int v45 = v18;
    }
    else {
      unsigned int v45 = 0;
    }
    if (v45 == 1)
    {
      unint64_t v46 = a1[2];
      BOOL v47 = v46 == 1;
      if (a1[2]) {
        int v48 = 0;
      }
      else {
        int v48 = v17;
      }
      BOOL v49 = v7 == v46 && v46 > 1;
      if (v48 | v49) {
        uint64_t v50 = v7;
      }
      else {
        uint64_t v50 = v47;
      }
      return 2 * v50;
    }
    CFIndex v2 = 0;
    if (v26 <= 9)
    {
      if (v26 != 4)
      {
        if (v26 != 5) {
          return v2;
        }
        goto LABEL_49;
      }
LABEL_140:
      if (v18)
      {
        unint64_t v51 = a1[2];
        BOOL v52 = v51 == 1;
        if (a1[2]) {
          int v53 = 0;
        }
        else {
          int v53 = v17;
        }
        BOOL v54 = v7 == v51 && v51 > 1;
        if (v53 | v54) {
          uint64_t v55 = v7;
        }
        else {
          uint64_t v55 = v52;
        }
        return 4 * v55;
      }
      return 0;
    }
    if (v26 != 10)
    {
      if (v26 != 32771) {
        return v2;
      }
      goto LABEL_140;
    }
LABEL_49:
    if (v15)
    {
      unint64_t v27 = a1[2];
      BOOL v28 = v27 == 1;
      if (a1[2]) {
        int v29 = 0;
      }
      else {
        int v29 = v17;
      }
      BOOL v30 = v7 == v27 && v27 > 1;
      if (v29 | v30) {
        uint64_t v31 = v7;
      }
      else {
        uint64_t v31 = v28;
      }
      return 8 * v31;
    }
    return 0;
  }
  if (v23 == 37510 && v19 == v20)
  {
    CFIndex Length = CFStringGetLength(cf);
    CFIndex usedBufLen = 0;
    if (Length
      && (v63.location = 0, v63.CFIndex length = Length, CFStringGetBytes(cf, v63, 0x600u, 0, 0, 0, 0, &usedBufLen) < 1))
    {
      v67.location = 0;
      v67.CFIndex length = Length;
      CFStringGetBytes(cf, v67, 0x100u, 0x3Fu, 1u, 0, 0, &usedBufLen);
    }
    else
    {
      v64.location = 0;
      v64.CFIndex length = Length;
      CFStringGetBytes(cf, v64, 0x600u, 0x3Fu, 0, 0, 0, &usedBufLen);
    }
    CFIndex v38 = usedBufLen;
    CFIndex v39 = usedBufLen + 8;
LABEL_153:
    if (v38) {
      return v39;
    }
    else {
      return 0;
    }
  }
  if (v23 == 37500 && v19 == v20)
  {
    CFIndex v35 = CFStringGetLength(cf);
    CFIndex usedBufLen = 0;
    if (v35
      && (v65.location = 0, v65.CFIndex length = v35, CFStringGetBytes(cf, v65, 0x600u, 0, 0, 0, 0, &usedBufLen) < 1))
    {
      v69.location = 0;
      v69.CFIndex length = v35;
      CFStringGetBytes(cf, v69, 0x100u, 0x3Fu, 1u, 0, 0, &usedBufLen);
    }
    else
    {
      v66.location = 0;
      v66.CFIndex length = v35;
      CFStringGetBytes(cf, v66, 0x600u, 0x3Fu, 0, 0, 0, &usedBufLen);
    }
    CFIndex v38 = usedBufLen;
    CFIndex v39 = usedBufLen + 44;
    goto LABEL_153;
  }
  if (v23 != 37500)
  {
LABEL_99:
    if ((*a1 & 0xFFFE) == 0xA300) {
      return v18;
    }
    else {
      return 0;
    }
  }
  CFTypeID v36 = CFGetTypeID(cf);
  if (v36 != CFDictionaryGetTypeID())
  {
    int v26 = a1[1];
    if (v26 == 7) {
      goto LABEL_99;
    }
    goto LABEL_102;
  }

  return AppleMakerNoteGetLength((const __CFDictionary *)cf);
}

void sub_1885DE6C4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va1, a8);
  va_start(va, a8);
  uint64_t v9 = va_arg(va1, void);
  uint64_t v11 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  IIOArray::~IIOArray((IIOArray *)va);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void WriteValueForTagID(const __CFString *a1, uint64_t a2, int a3, int a4, int a5, unsigned __int8 *a6)
{
  uint64_t v161 = *MEMORY[0x1E4F143B8];
  if (!a1 || !a6) {
    return;
  }
  CFTypeID v12 = CFGetTypeID(a1);
  CFTypeID TypeID = CFArrayGetTypeID();
  if (v12 == TypeID) {
    CFIndex Count = CFArrayGetCount((CFArrayRef)a1);
  }
  else {
    CFIndex Count = 1;
  }
  if (a4 != 7)
  {
    if (!a3 && a4 == 1)
    {
      unsigned int v156 = 0;
      LODWORD(valuePtr) = 0;
      LODWORD(usedBufLen[0]) = 0;
      LODWORD(v155) = 0;
      if (Count < 1
        || (ValueAtIndedouble x = (const __CFNumber *)CFArrayGetValueAtIndex((CFArrayRef)a1, 0)) == 0
        || !CFNumberGetValue(ValueAtIndex, kCFNumberIntType, &valuePtr))
      {
        LODWORD(valuePtr) = 0;
      }
      if (Count < 2
        || (CFNumberRef v16 = (const __CFNumber *)CFArrayGetValueAtIndex((CFArrayRef)a1, 1)) == 0
        || !CFNumberGetValue(v16, kCFNumberIntType, usedBufLen))
      {
        LODWORD(usedBufLen[0]) = 0;
      }
      if (Count < 3
        || (CFNumberRef v17 = (const __CFNumber *)CFArrayGetValueAtIndex((CFArrayRef)a1, 2)) == 0
        || !CFNumberGetValue(v17, kCFNumberIntType, &v155))
      {
        LODWORD(v155) = 0;
      }
      if (Count >= 4
        && (CFNumberRef v18 = (const __CFNumber *)CFArrayGetValueAtIndex((CFArrayRef)a1, 3)) != 0
        && CFNumberGetValue(v18, kCFNumberIntType, &v156))
      {
        int v19 = (int)v156 % 10;
      }
      else
      {
        LOBYTE(v19) = 0;
      }
      *a6 = LOBYTE(valuePtr)
          - 10
          * (((unint64_t)(1717986919 * SLODWORD(valuePtr)) >> 34) + (1717986919 * SLODWORD(valuePtr) < 0));
      a6[1] = LOBYTE(usedBufLen[0])
            - 10
            * (((unint64_t)(1717986919 * SLODWORD(usedBufLen[0])) >> 34)
             + (1717986919 * SLODWORD(usedBufLen[0]) < 0));
      int v32 = SLODWORD(v155) % 10;
      goto LABEL_108;
    }
    if (a3 == 7 && a4 == 5)
    {
      LODWORD(p_valuePtr) = 0;
      double valuePtr = 0.0;
      v163.CFIndex length = CFStringGetLength(a1);
      usedBufLen[0] = 0;
      v163.location = 0;
      CFStringGetBytes(a1, v163, 0x600u, 0x3Fu, 0, (UInt8 *)&valuePtr, 11, usedBufLen);
      if (usedBufLen[0] == 11 && BYTE2(valuePtr) == 58 && BYTE5(valuePtr) == 58 && p_valuePtr == 46)
      {
        unsigned int v20 = SBYTE1(valuePtr) + 10 * SLOBYTE(valuePtr) - 528;
        unsigned int v21 = HIWORD(v20);
        if (a5)
        {
          unsigned __int8 v22 = 0;
          unsigned int v23 = v20 >> 8;
          LOBYTE(v24) = BYTE1(valuePtr) + 10 * LOBYTE(valuePtr) - 16;
          v20 >>= 24;
          unsigned __int8 v25 = 1;
        }
        else
        {
          unsigned __int8 v25 = 0;
          unsigned int v24 = HIBYTE(v20);
          unsigned int v23 = HIWORD(v20);
          unsigned int v21 = v20 >> 8;
          unsigned __int8 v22 = 1;
        }
        *a6 = v24;
        a6[1] = v23;
        a6[2] = v21;
        a6[3] = v20;
        a6[4] = v25;
        *(_WORD *)(a6 + 5) = 0;
        a6[7] = v22;
        unsigned int v68 = SBYTE4(valuePtr) + 10 * SBYTE3(valuePtr) - 528;
        unsigned int v69 = HIWORD(v68);
        if (a5)
        {
          unsigned __int8 v70 = 0;
          unsigned int v71 = v68 >> 8;
          LOBYTE(v72) = BYTE4(valuePtr) + 10 * BYTE3(valuePtr) - 16;
          v68 >>= 24;
          unsigned __int8 v73 = 1;
        }
        else
        {
          unsigned __int8 v73 = 0;
          unsigned int v72 = HIBYTE(v68);
          unsigned int v71 = HIWORD(v68);
          unsigned int v69 = v68 >> 8;
          unsigned __int8 v70 = 1;
        }
        a6[8] = v72;
        a6[9] = v71;
        a6[10] = v69;
        a6[11] = v68;
        a6[12] = v73;
        *(_WORD *)(a6 + 13) = 0;
        a6[15] = v70;
        unsigned int v74 = 100 * SHIBYTE(valuePtr) + 1000 * SBYTE6(valuePtr) + 10 * SBYTE1(p_valuePtr) + SBYTE2(p_valuePtr) - 53328;
        unsigned int v75 = HIWORD(v74);
        if (a5)
        {
          unsigned __int8 v76 = 0;
          unsigned int v77 = HIWORD(v74);
          unsigned int v75 = v74 >> 8;
          unsigned int v78 = HIBYTE(v74);
          unsigned __int8 v79 = 100;
        }
        else
        {
          unsigned __int8 v79 = 0;
          unsigned int v77 = v74 >> 8;
          LOBYTE(v78) = 100 * HIBYTE(valuePtr) - 24 * BYTE6(valuePtr) + 10 * BYTE1(p_valuePtr) + BYTE2(p_valuePtr) - 80;
          v74 >>= 24;
          unsigned __int8 v76 = 100;
        }
      }
      else
      {
        if (usedBufLen[0] != 8 || BYTE2(valuePtr) != 58 || BYTE5(valuePtr) != 58) {
          return;
        }
        unsigned int v60 = SBYTE1(valuePtr) + 10 * SLOBYTE(valuePtr) - 528;
        unsigned int v61 = HIWORD(v60);
        if (a5)
        {
          unsigned __int8 v62 = 0;
          unsigned int v63 = v60 >> 8;
          LOBYTE(v64) = BYTE1(valuePtr) + 10 * LOBYTE(valuePtr) - 16;
          v60 >>= 24;
          unsigned __int8 v65 = 1;
        }
        else
        {
          unsigned __int8 v65 = 0;
          unsigned int v64 = HIBYTE(v60);
          unsigned int v63 = HIWORD(v60);
          unsigned int v61 = v60 >> 8;
          unsigned __int8 v62 = 1;
        }
        *a6 = v64;
        a6[1] = v63;
        a6[2] = v61;
        a6[3] = v60;
        a6[4] = v65;
        *(_WORD *)(a6 + 5) = 0;
        a6[7] = v62;
        unsigned int v98 = SBYTE4(valuePtr) + 10 * SBYTE3(valuePtr) - 528;
        unsigned int v99 = HIWORD(v98);
        if (a5)
        {
          unsigned __int8 v100 = 0;
          unsigned int v101 = v98 >> 8;
          LOBYTE(v102) = BYTE4(valuePtr) + 10 * BYTE3(valuePtr) - 16;
          v98 >>= 24;
          unsigned __int8 v103 = 1;
        }
        else
        {
          unsigned __int8 v103 = 0;
          unsigned int v102 = HIBYTE(v98);
          unsigned int v101 = HIWORD(v98);
          unsigned int v99 = v98 >> 8;
          unsigned __int8 v100 = 1;
        }
        a6[8] = v102;
        a6[9] = v101;
        a6[10] = v99;
        a6[11] = v98;
        a6[12] = v103;
        *(_WORD *)(a6 + 13) = 0;
        a6[15] = v100;
        unsigned int v74 = SHIBYTE(valuePtr) + 10 * SBYTE6(valuePtr) - 528;
        unsigned int v75 = HIWORD(v74);
        if (a5)
        {
          unsigned __int8 v76 = 0;
          unsigned int v77 = HIWORD(v74);
          unsigned int v75 = v74 >> 8;
          unsigned int v78 = HIBYTE(v74);
          unsigned __int8 v79 = 1;
        }
        else
        {
          unsigned __int8 v79 = 0;
          unsigned int v77 = v74 >> 8;
          LOBYTE(v78) = HIBYTE(valuePtr) + 10 * BYTE6(valuePtr) - 16;
          v74 >>= 24;
          unsigned __int8 v76 = 1;
        }
      }
      a6[16] = v74;
      a6[17] = v75;
      a6[18] = v77;
      a6[19] = v78;
      a6[20] = v79;
      *(_WORD *)(a6 + 21) = 0;
      a6[23] = v76;
      return;
    }
    if (a4 == 5)
    {
      if (a3 <= 0x16 && ((1 << a3) & 0x500014) != 0)
      {
        double valuePtr = 0.0;
        if (CFNumberGetValue((CFNumberRef)a1, kCFNumberDoubleType, &valuePtr))
        {
          double v36 = valuePtr;
          unsigned int v37 = valuePtr;
          unsigned int v38 = valuePtr >> 16;
          if (a5)
          {
            unsigned __int8 v39 = 0;
            unsigned int v40 = v37 >> 8;
            unsigned int v41 = HIBYTE(v37);
            unsigned __int8 v42 = 1;
            unsigned int v43 = valuePtr;
          }
          else
          {
            unsigned __int8 v42 = 0;
            unsigned int v43 = HIBYTE(v37);
            unsigned int v40 = HIWORD(v37);
            unsigned int v38 = v37 >> 8;
            unsigned __int8 v39 = 1;
            unsigned int v41 = valuePtr;
          }
          *a6 = v43;
          a6[1] = v40;
          a6[2] = v38;
          a6[3] = v41;
          a6[4] = v42;
          *(_WORD *)(a6 + 5) = 0;
          a6[7] = v39;
          double v87 = (v36 - (double)v37) * 60.0;
          unsigned int v88 = v87 >> 16;
          unsigned int v89 = v87 >> 24;
          if (a5) {
            unsigned __int8 v90 = v87;
          }
          else {
            unsigned __int8 v90 = v87 >> 24;
          }
          if (a5) {
            unsigned __int8 v91 = (unsigned __int16)v87 >> 8;
          }
          else {
            unsigned __int8 v91 = v87 >> 16;
          }
          if (!a5)
          {
            LOBYTE(v88) = (unsigned __int16)v87 >> 8;
            LOBYTE(v89) = v87;
          }
          a6[8] = v90;
          a6[9] = v91;
          a6[10] = v88;
          a6[11] = v89;
          a6[12] = a5 != 0;
          *(_WORD *)(a6 + 13) = 0;
          a6[15] = a5 == 0;
          unsigned int v92 = ((v87 - (double)v87) * 60.0 * 100.0 + 0.5);
          unsigned int v93 = HIWORD(v92);
          if (a5) {
            unsigned __int8 v94 = ((v87 - (double)v87) * 60.0 * 100.0 + 0.5);
          }
          else {
            unsigned __int8 v94 = ((v87 - (double)v87) * 60.0 * 100.0 + 0.5) >> 24;
          }
          if (a5) {
            unsigned __int8 v95 = (unsigned __int16)((v87 - (double)v87) * 60.0 * 100.0 + 0.5) >> 8;
          }
          else {
            unsigned __int8 v95 = ((v87 - (double)v87) * 60.0 * 100.0 + 0.5) >> 16;
          }
          a6[16] = v94;
          if (a5)
          {
            LOBYTE(v92) = ((v87 - (double)v87) * 60.0 * 100.0 + 0.5) >> 24;
            unsigned __int8 v96 = 100;
          }
          else
          {
            LOBYTE(v93) = (unsigned __int16)((v87 - (double)v87) * 60.0 * 100.0 + 0.5) >> 8;
            unsigned __int8 v96 = 0;
          }
          a6[17] = v95;
          a6[18] = v93;
          if (a5) {
            unsigned __int8 v97 = 0;
          }
          else {
            unsigned __int8 v97 = 100;
          }
          a6[19] = v92;
          a6[20] = v96;
          *(_WORD *)(a6 + 21) = 0;
          a6[23] = v97;
        }
      }
      else if (Count >= 1)
      {
        CFIndex v104 = 0;
        uint64_t v105 = a6 + 3;
        do
        {
          CFNumberRef v106 = (const __CFNumber *)a1;
          if (v12 == TypeID) {
            CFNumberRef v106 = (const __CFNumber *)CFArrayGetValueAtIndex((CFArrayRef)a1, v104);
          }
          double valuePtr = 0.0;
          if (CFNumberGetValue(v106, kCFNumberDoubleType, &valuePtr))
          {
            LODWORD(usedBufLen[0]) = 0;
            LODWORD(v155) = 0;
            URationalApprox(valuePtr, usedBufLen, (unsigned int *)&v155);
            LOBYTE(v107) = usedBufLen[0];
            int v108 = HIWORD(LODWORD(usedBufLen[0]));
            LOBYTE(v109) = LOBYTE(v155);
            int v110 = HIWORD(LODWORD(v155));
            int v111 = LODWORD(usedBufLen[0]) >> 8;
            int v112 = LODWORD(v155) >> 8;
            if (a5)
            {
              LOBYTE(v113) = usedBufLen[0];
              int v107 = HIBYTE(LODWORD(usedBufLen[0]));
              LOBYTE(v114) = LOBYTE(v155);
              int v109 = HIBYTE(LODWORD(v155));
            }
            else
            {
              int v113 = HIBYTE(LODWORD(usedBufLen[0]));
              int v111 = HIWORD(LODWORD(usedBufLen[0]));
              int v108 = LODWORD(usedBufLen[0]) >> 8;
              int v114 = HIBYTE(LODWORD(v155));
              int v112 = HIWORD(LODWORD(v155));
              int v110 = LODWORD(v155) >> 8;
            }
            *(v105 - 3) = v113;
            *(v105 - 2) = v111;
            *(v105 - 1) = v108;
            unsigned __int8 *v105 = v107;
            v105[1] = v114;
            v105[2] = v112;
            v105[3] = v110;
            v105[4] = v109;
          }
          ++v104;
          v105 += 8;
        }
        while (Count != v104);
      }
      return;
    }
    if (a4 == 2)
    {
      CFIndex Length = CFStringGetLength(a1);
      CFIndex MaximumSizeForEncoding = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u);
      double valuePtr = 0.0;
      v168.location = 0;
      v168.CFIndex length = Length;
      CFStringGetBytes(a1, v168, 0x8000100u, 0x3Fu, 0, a6, MaximumSizeForEncoding + 1, (CFIndex *)&valuePtr);
      a6[*(void *)&valuePtr] = 0;
      return;
    }
    if (a4 != 3)
    {
      switch(a4)
      {
        case 1:
          if (Count >= 1)
          {
            for (CFIndex i = 0; i != Count; ++i)
            {
              CFNumberRef v83 = (const __CFNumber *)a1;
              if (v12 == TypeID) {
                CFNumberRef v83 = (const __CFNumber *)CFArrayGetValueAtIndex((CFArrayRef)a1, i);
              }
              double valuePtr = 0.0;
              if (CFNumberGetValue(v83, kCFNumberLongType, &valuePtr))
              {
                unint64_t v84 = *(void *)&valuePtr & ~(*(uint64_t *)&valuePtr >> 63);
                if (v84 >= 0xFF) {
                  LOBYTE(v84) = -1;
                }
                a6[i] = v84;
              }
            }
          }
          return;
        case 32771:
          goto LABEL_183;
        case 10:
          if (Count >= 1)
          {
            CFIndex v142 = 0;
            int v143 = a6 + 3;
            do
            {
              CFNumberRef v144 = (const __CFNumber *)a1;
              if (v12 == TypeID) {
                CFNumberRef v144 = (const __CFNumber *)CFArrayGetValueAtIndex((CFArrayRef)a1, v142);
              }
              double v155 = 0.0;
              if (CFNumberGetValue(v144, kCFNumberDoubleType, &v155))
              {
                double valuePtr = 0.0;
                usedBufLen[0] = 0;
                RationalApprox(v155, 0x7FFFFFFFLL, (uint64_t *)&valuePtr, usedBufLen);
                LOBYTE(v145) = usedBufLen[0];
                int v146 = HIWORD(LODWORD(usedBufLen[0]));
                LOBYTE(v147) = LOBYTE(valuePtr);
                LODWORD(v148) = HIWORD(LODWORD(valuePtr));
                unint64_t v149 = *(void *)&valuePtr >> 8;
                int v150 = LODWORD(usedBufLen[0]) >> 8;
                if (a5)
                {
                  LOBYTE(v151) = LOBYTE(valuePtr);
                  unint64_t v147 = *(void *)&valuePtr >> 24;
                  LOBYTE(v152) = usedBufLen[0];
                  int v145 = HIBYTE(LODWORD(usedBufLen[0]));
                }
                else
                {
                  unint64_t v151 = *(void *)&valuePtr >> 24;
                  LODWORD(v149) = HIWORD(LODWORD(valuePtr));
                  unint64_t v148 = *(void *)&valuePtr >> 8;
                  int v152 = HIBYTE(LODWORD(usedBufLen[0]));
                  int v150 = HIWORD(LODWORD(usedBufLen[0]));
                  int v146 = LODWORD(usedBufLen[0]) >> 8;
                }
                *(v143 - 3) = v151;
                *(v143 - 2) = v149;
                *(v143 - 1) = v148;
                *int v143 = v147;
                v143[1] = v152;
                v143[2] = v150;
                v143[3] = v146;
                v143[4] = v145;
              }
              ++v142;
              v143 += 8;
            }
            while (Count != v142);
          }
          return;
        case 4:
LABEL_183:
          if (Count >= 1)
          {
            CFIndex v115 = 0;
            unint64_t v116 = a6 + 3;
            do
            {
              CFNumberRef v117 = (const __CFNumber *)a1;
              if (v12 == TypeID) {
                CFNumberRef v117 = (const __CFNumber *)CFArrayGetValueAtIndex((CFArrayRef)a1, v115);
              }
              double valuePtr = 0.0;
              if (CFNumberGetValue(v117, kCFNumberLongType, &valuePtr))
              {
                LOBYTE(v118) = LOBYTE(valuePtr);
                unsigned int v119 = HIWORD(LODWORD(valuePtr));
                unsigned int v120 = LODWORD(valuePtr) >> 8;
                if (a5)
                {
                  LOBYTE(v121) = LOBYTE(valuePtr);
                  unsigned int v118 = HIBYTE(LODWORD(valuePtr));
                }
                else
                {
                  unsigned int v121 = HIBYTE(LODWORD(valuePtr));
                  unsigned int v120 = HIWORD(LODWORD(valuePtr));
                  unsigned int v119 = LODWORD(valuePtr) >> 8;
                }
                *(v116 - 3) = v121;
                *(v116 - 2) = v120;
                *(v116 - 1) = v119;
                unsigned __int8 *v116 = v118;
              }
              ++v115;
              v116 += 4;
            }
            while (Count != v115);
          }
          return;
      }
      goto LABEL_194;
    }
    if (Count < 1) {
      return;
    }
    CFIndex v52 = 0;
    for (uint64_t j = a6 + 1; ; j += 2)
    {
      BOOL v54 = a1;
      if (v12 == TypeID) {
        BOOL v54 = CFArrayGetValueAtIndex((CFArrayRef)a1, v52);
      }
      usedBufLen[0] = 0;
      CFTypeID v55 = CFGetTypeID(v54);
      if (v55 == CFNumberGetTypeID())
      {
        if (CFNumberGetValue((CFNumberRef)v54, kCFNumberLongType, usedBufLen)) {
          goto LABEL_89;
        }
      }
      else
      {
        CFTypeID v56 = CFGetTypeID(v54);
        if (v56 == CFStringGetTypeID())
        {
          double valuePtr = 0.0;
          p_double valuePtr = 0;
          uint64_t v159 = 0;
          IIOString::IIOString((IIOString *)&valuePtr, v54);
          uint64_t v57 = (const char *)IIOString::utf8String((IIOString *)&valuePtr);
          usedBufLen[0] = atol(v57);
          IIOString::~IIOString((IIOString *)&valuePtr);
LABEL_89:
          uint64_t v58 = usedBufLen[0];
          if (usedBufLen[0] <= -32768) {
            uint64_t v58 = -32768;
          }
          if (v58 >= 0xFFFF) {
            LOWORD(v58) = -1;
          }
          if (a5) {
            unsigned __int8 v59 = v58;
          }
          else {
            unsigned __int8 v59 = BYTE1(v58);
          }
          if (a5) {
            LOBYTE(v58) = BYTE1(v58);
          }
          *(j - 1) = v59;
          unsigned __int8 *j = v58;
        }
      }
      if (Count == ++v52) {
        return;
      }
    }
  }
  if (a3 <= 37499)
  {
    if (a3 != 36864)
    {
      if (a3 != 37121)
      {
LABEL_73:
        if ((a3 & 0xFFFE) == 0xA300)
        {
          LOBYTE(valuePtr) = 0;
          if (CFNumberGetValue((CFNumberRef)a1, kCFNumberCharType, &valuePtr)) {
            *a6 = LOBYTE(valuePtr);
          }
          return;
        }
LABEL_194:
        if (a3 != 42082)
        {
          if (a3 == 41995)
          {
            if (v12 == TypeID)
            {
              *a6 = a5;
              a6[1] = a5 ^ 1;
              unsigned __int8 v122 = BYTE1(Count);
              if (a5) {
                unsigned __int8 v123 = Count;
              }
              else {
                unsigned __int8 v123 = BYTE1(Count);
              }
              if (!a5) {
                unsigned __int8 v122 = Count;
              }
              a6[2] = v123;
              a6[3] = v122;
              double valuePtr = 0.0;
              p_double valuePtr = &valuePtr;
              uint64_t v159 = 0x2000000000;
              int v160 = 4;
              memset(usedBufLen, 0, sizeof(usedBufLen));
              IIOArray::IIOArray((IIOArray *)usedBufLen, (const __CFArray *)a1);
              v153[0] = MEMORY[0x1E4F143A8];
              v153[1] = 0x40000000;
              v153[2] = ___ZL18WriteValueForTagIDPKvmttbPh_block_invoke;
              v153[3] = &unk_1E53C6FB8;
              v153[4] = &valuePtr;
              v153[5] = a2;
              v153[6] = a6;
              IIOArray::enumerate((uint64_t)usedBufLen, (uint64_t)v153);
              IIOArray::~IIOArray((IIOArray *)usedBufLen);
              _Block_object_dispose(&valuePtr, 8);
            }
            return;
          }
LABEL_203:
          _cg_jpeg_mem_term("WriteValueForTagID", 3707, "*** did not handle '%4X'\n", a3);
          return;
        }
        if (v12 == TypeID && Count >= 8)
        {
          CFIndex v124 = 0;
          int v125 = 0;
          do
          {
            CFNumberRef v126 = (const __CFNumber *)CFArrayGetValueAtIndex((CFArrayRef)a1, v124);
            double valuePtr = 0.0;
            LODWORD(usedBufLen[0]) = 0;
            unint64_t v127 = v124 - 7;
            if (v127 > 1)
            {
              if (CFNumberGetValue(v126, kCFNumberDoubleType, &valuePtr))
              {
                LODWORD(v155) = 0;
                unsigned int v156 = 0;
                URationalApprox(valuePtr, &v155, &v156);
                LOBYTE(v131) = LOBYTE(v155);
                int v132 = HIWORD(LODWORD(v155));
                int v133 = LODWORD(v155) >> 8;
                if (a5)
                {
                  LOBYTE(v134) = LOBYTE(v155);
                  int v131 = HIBYTE(LODWORD(v155));
                }
                else
                {
                  int v134 = HIBYTE(LODWORD(v155));
                  int v133 = HIWORD(LODWORD(v155));
                  int v132 = LODWORD(v155) >> 8;
                }
                int v135 = &a6[v125];
                *int v135 = v134;
                v135[1] = v133;
                unsigned int v136 = v156;
                unsigned int v137 = HIWORD(v156);
                v135[2] = v132;
                v135[3] = v131;
                unsigned int v138 = v136 >> 8;
                if (a5)
                {
                  LOBYTE(v139) = v136;
                  v136 >>= 24;
                }
                else
                {
                  unsigned int v139 = HIBYTE(v136);
                  LOBYTE(v138) = v137;
                  unsigned int v137 = v136 >> 8;
                }
                unint64_t v140 = &a6[v125 + 4];
                unsigned __int8 *v140 = v139;
                v140[1] = v138;
                v140[2] = v137;
                v140[3] = v136;
                v125 += 8;
              }
            }
            else if (CFNumberGetValue(v126, kCFNumberIntType, usedBufLen))
            {
              int v128 = &a6[v125];
              unsigned __int8 v129 = usedBufLen[0];
              if (a5) {
                unsigned __int8 v130 = usedBufLen[0];
              }
              else {
                unsigned __int8 v130 = BYTE1(usedBufLen[0]);
              }
              if (a5) {
                unsigned __int8 v129 = BYTE1(usedBufLen[0]);
              }
              *int v128 = v130;
              v128[1] = v129;
              v125 += 2;
            }
            CFIndex v124 = v127 + 8;
          }
          while (v124 != Count);
        }
        return;
      }
      unsigned int v156 = 0;
      LODWORD(valuePtr) = 0;
      LODWORD(usedBufLen[0]) = 0;
      LODWORD(v155) = 0;
      if (Count == 4)
      {
        CFNumberRef v26 = (const __CFNumber *)CFArrayGetValueAtIndex((CFArrayRef)a1, 0);
        CFNumberGetValue(v26, kCFNumberIntType, &valuePtr);
        CFNumberRef v27 = (const __CFNumber *)CFArrayGetValueAtIndex((CFArrayRef)a1, 1);
        CFNumberGetValue(v27, kCFNumberIntType, usedBufLen);
        CFNumberRef v28 = (const __CFNumber *)CFArrayGetValueAtIndex((CFArrayRef)a1, 2);
        CFNumberGetValue(v28, kCFNumberIntType, &v155);
        CFNumberRef v29 = (const __CFNumber *)CFArrayGetValueAtIndex((CFArrayRef)a1, 3);
        CFNumberGetValue(v29, kCFNumberIntType, &v156);
        LOBYTE(v19) = v156;
        unsigned __int8 v30 = LOBYTE(valuePtr);
        unsigned __int8 v31 = usedBufLen[0];
        LOBYTE(v32) = LOBYTE(v155);
      }
      else
      {
        LOBYTE(v19) = 0;
        LOBYTE(v32) = 3;
        unsigned __int8 v31 = 2;
        unsigned __int8 v30 = 1;
      }
      *a6 = v30;
      a6[1] = v31;
      goto LABEL_108;
    }
    goto LABEL_44;
  }
  if (a3 != 37500)
  {
    if (a3 == 37510)
    {
      CFIndex v46 = CFStringGetLength(a1);
      double valuePtr = 0.0;
      if (v46
        && (v166.location = 0,
            v166.CFIndex length = v46,
            CFStringGetBytes(a1, v166, 0x600u, 0, 0, 0, 0, (CFIndex *)&valuePtr) < 1))
      {
        *(void *)a6 = 0x45444F43494E55;
        uint64_t v85 = a6 + 8;
        if (a5) {
          CFStringEncoding v86 = 335544576;
        }
        else {
          CFStringEncoding v86 = 268435712;
        }
        v169.location = 0;
        v169.CFIndex length = v46;
        CFStringGetBytes(a1, v169, v86, 0x3Fu, 1u, v85, v46, (CFIndex *)&valuePtr);
      }
      else
      {
        *(void *)a6 = 0x4949435341;
        v167.location = 0;
        v167.CFIndex length = v46;
        CFStringGetBytes(a1, v167, 0x600u, 0x3Fu, 0, a6 + 8, v46, (CFIndex *)&valuePtr);
      }
      return;
    }
    if (a3 != 40960) {
      goto LABEL_73;
    }
LABEL_44:
    LODWORD(valuePtr) = 0;
    LODWORD(usedBufLen[0]) = 0;
    LODWORD(v155) = 0;
    CFTypeID v33 = CFStringGetTypeID();
    if (v33 == CFGetTypeID(a1))
    {
      CStringPtr = CFStringGetCStringPtr(a1, 0x8000100u);
      if (!CStringPtr) {
        return;
      }
      CFIndex v35 = (unsigned __int8 *)CStringPtr;
      if (strlen(CStringPtr) != 4) {
        return;
      }
      *a6 = *v35;
      a6[1] = v35[1];
      a6[2] = v35[2];
      LOBYTE(v19) = v35[3];
LABEL_109:
      a6[3] = v19;
      return;
    }
    if (Count < 1
      || (CFNumberRef v47 = (const __CFNumber *)CFArrayGetValueAtIndex((CFArrayRef)a1, 0)) == 0
      || !CFNumberGetValue(v47, kCFNumberIntType, &valuePtr))
    {
      LODWORD(valuePtr) = 0;
    }
    if (Count < 2
      || (CFNumberRef v48 = (const __CFNumber *)CFArrayGetValueAtIndex((CFArrayRef)a1, 1)) == 0
      || !CFNumberGetValue(v48, kCFNumberIntType, usedBufLen))
    {
      LODWORD(usedBufLen[0]) = 0;
    }
    if (Count >= 3
      && (CFNumberRef v49 = (const __CFNumber *)CFArrayGetValueAtIndex((CFArrayRef)a1, 2)) != 0
      && CFNumberGetValue(v49, kCFNumberIntType, &v155))
    {
      int v19 = SLODWORD(v155) % 10 + 48;
    }
    else
    {
      LOBYTE(v19) = 48;
    }
    char v50 = LOBYTE(valuePtr);
    int v51 = SLODWORD(valuePtr) / 10;
    *a6 = SLODWORD(valuePtr) / 10 % 10 + 48;
    a6[1] = v50 - 10 * v51 + 48;
    int v32 = SLODWORD(usedBufLen[0]) % 10 + 48;
LABEL_108:
    a6[2] = v32;
    goto LABEL_109;
  }
  CFTypeID v44 = CFGetTypeID(a1);
  if (v44 == CFStringGetTypeID())
  {
    double valuePtr = 0.0;
    CFIndex v45 = CFStringGetLength(a1);
    *(_WORD *)a6 = -7681;
    a6[2] = (unsigned __int16)(v45 + 44) >> 8;
    a6[3] = v45 + 44;
    *(void *)(a6 + 18) = 0x70086920100;
    *(_OWORD *)(a6 + 4) = *(_OWORD *)"iOS ";
    a6[26] = (unsigned __int16)(v45 + 8) >> 8;
    a6[27] = v45 + 8;
    *(void *)(a6 + 28) = 436207616;
    if (v45
      && (v164.location = 0,
          v164.CFIndex length = v45,
          CFStringGetBytes(a1, v164, 0x600u, 0, 0, 0, 30000, (CFIndex *)&valuePtr) < 1))
    {
      *(void *)(a6 + 36) = 0x45444F43494E55;
      if (a5) {
        CFStringEncoding v141 = 335544576;
      }
      else {
        CFStringEncoding v141 = 268435712;
      }
      v170.location = 0;
      v170.CFIndex length = v45;
      CFStringGetBytes(a1, v170, v141, 0x3Fu, 1u, a6 + 44, 30000, (CFIndex *)&valuePtr);
    }
    else
    {
      *(void *)(a6 + 36) = 0x4949435341;
      v165.location = 0;
      v165.CFIndex length = v45;
      CFStringGetBytes(a1, v165, 0x600u, 0x3Fu, 0, a6 + 44, 30000, (CFIndex *)&valuePtr);
    }
    return;
  }
  CFTypeID v66 = CFGetTypeID(a1);
  if (v66 != CFDictionaryGetTypeID())
  {
    a3 = 37500;
    goto LABEL_203;
  }
  size_t v67 = AppleMakerNoteGetLength((const __CFDictionary *)a1);

  AppleMakerNoteWriteToBuffer((const __CFDictionary *)a1, a6, v67, a5);
}

void sub_1885DF928(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va1, a9);
  va_start(va, a9);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  uint64_t v15 = va_arg(va1, void);
  IIOArray::~IIOArray((IIOArray *)va);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

BOOL IIO_CGColorSpaceNameMatchesName(CGColorSpace *a1, const __CFString *a2)
{
  CFStringRef v3 = CGColorSpaceCopyName(a1);
  if (!v3) {
    return 0;
  }
  CFStringRef v4 = v3;
  BOOL v5 = CFEqual(v3, a2);
  CFRelease(v4);
  return v5;
}

_DWORD *URationalApprox(double a1, _DWORD *result, unsigned int *a3)
{
  CFStringRef v4 = result;
  if (a1 <= 0.0)
  {
    int v5 = 0;
    unsigned int v6 = 1;
  }
  else
  {
    uint64_t v7 = 0;
    uint64_t v8 = 0;
    uint64_t result = (_DWORD *)RationalApprox(a1, 0xFFFFFFFFLL, &v8, &v7);
    int v5 = v8;
    unsigned int v6 = v7;
  }
  _DWORD *v4 = v5;
  *a3 = v6;
  return result;
}

uint64_t RationalApprox(double a1, uint64_t result, uint64_t *a3, uint64_t *a4)
{
  if ((double)result <= a1)
  {
    uint64_t v8 = 1;
  }
  else if ((double)-result >= a1)
  {
    uint64_t v8 = 1;
    uint64_t result = -result;
  }
  else
  {
    double v4 = -a1;
    if (a1 >= 0.0) {
      double v4 = a1;
    }
    uint64_t v5 = (uint64_t)v4;
    if ((uint64_t)v4 > result || result < 1)
    {
      uint64_t v12 = 0;
      uint64_t v8 = 1;
    }
    else
    {
      int v7 = 0;
      uint64_t v8 = 0;
      double v9 = v4 - (double)v5;
      double v10 = 1.0;
      uint64_t v11 = 1;
      uint64_t v12 = 1;
      while (1)
      {
        int v13 = v7 - 1;
        if (v7)
        {
          if (v10 > v9 * 100000.0) {
            break;
          }
        }
        if (v10 > v9 * (double)result && v7 == 0) {
          break;
        }
        uint64_t v15 = (uint64_t)(v10 / v9);
        v8 += v11 * v15;
        v12 += v5 * v15;
        BOOL v16 = v4 / ((double)v5 / (double)v11) >= 1.0 && v12 <= result;
        if (!v16 || v8 > result) {
          break;
        }
        double v10 = v10 - (double)(uint64_t)(v10 / v9) * v9;
        if (v9 <= v10 * 100000.0)
        {
          BOOL v18 = (double)v12 / (double)v8 / v4 < 1.0 || v7 == -9;
          uint64_t v19 = (uint64_t)(v9 / v10);
          double v9 = v9 - (double)v19 * v10;
          v11 += v8 * v19;
          v5 += v12 * v19;
          BOOL v20 = !v18 && v5 <= result;
          BOOL v21 = v20 && v11 <= result;
          int v7 = v13;
          if (v21) {
            continue;
          }
        }
        goto LABEL_40;
      }
      uint64_t v12 = v5;
      uint64_t v8 = v11;
    }
LABEL_40:
    if (a1 >= 0.0) {
      uint64_t result = v12;
    }
    else {
      uint64_t result = -v12;
    }
  }
  *a3 = result;
  *a4 = v8;
  return result;
}

uint64_t _CGImagePlusFinalize(void *a1)
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  atomic_fetch_add_explicit(&gImagePlusCount, 0xFFFFFFFFFFFFFFFFLL, memory_order_relaxed);
  if ((gIIODebugFlags & 0xC000) != 0)
  {
    *(_OWORD *)__str = 0u;
    long long v5 = 0u;
    CFIndex v2 = a1[3] ? (const void *)IIOLookupISR() : 0;
    snprintf(__str, 0x20uLL, "(%p)", a1);
    if ((unsigned __int16)gIIODebugFlags >> 14) {
      ImageIODebugOptions((unsigned __int16)gIIODebugFlags >> 14, "S", "_CGImagePlusFinalize", v2, __str, -1, 0);
    }
  }
  uint64_t result = a1[3];
  if (result)
  {
    uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
    a1[3] = 0;
  }
  return result;
}

void IIOImagePlus::~IIOImagePlus(IIOImagePlus *this)
{
  IIOImagePlus::~IIOImagePlus(this);

  JUMPOUT(0x18C11C0E0);
}

{
  CGColorSpace *v2;
  uint64_t v3;
  const void *v4;
  const void *v5;
  uint64_t v6;
  const void *v7;
  const CGPath *v8;
  uint64_t v9;

  *(void *)this = &unk_1ED4DF190;
  pthread_mutex_lock(&ipGeomLock);
  CFIndex v2 = (CGColorSpace *)*((void *)this + 11);
  *((void *)this + 11) = 0;
  if (v2) {
    CGColorSpaceRelease(v2);
  }
  pthread_mutex_unlock(&ipGeomLock);
  CFStringRef v3 = *((void *)this + 14);
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  *((void *)this + 14) = 0;
  double v4 = (const void *)*((void *)this + 15);
  if (v4)
  {
    CFRelease(v4);
    *((void *)this + 15) = 0;
  }
  long long v5 = (const void *)*((void *)this + 19);
  if (v5)
  {
    CFRelease(v5);
    *((void *)this + 19) = 0;
  }
  *((void *)this + 18) = 0;
  *((void *)this + 16) = 0;
  if ((*((unsigned char *)this + 192) & 0x20) != 0)
  {
    uint64_t v6 = CGImageReadSessionGetRead(*((void *)this + 3));
    if (v6) {
      IIOImageRead::removeCacheKey(v6, *((void *)this + 26));
    }
  }
  int v7 = (const void *)*((void *)this + 3);
  if (v7) {
    CFRelease(v7);
  }
  uint64_t v8 = (const CGPath *)*((void *)this + 23);
  if (v8) {
    CGPathRelease(v8);
  }
  double v9 = *((void *)this + 25);
  if (v9) {
    (*(void (**)(uint64_t))(*(void *)v9 + 8))(v9);
  }
  *((void *)this + 25) = 0;
}

uint64_t CGColorSpaceCreateWithCopyOfData(UInt8 *bytes, unint64_t length)
{
  if (!bytes) {
    return 0;
  }
  if (length < 0xFB) {
    return 0;
  }
  CFDataRef v2 = CFDataCreate(0, bytes, length);
  if (!v2) {
    return 0;
  }
  CFDataRef v3 = v2;
  uint64_t v4 = MEMORY[0x18C11AC10]();
  CFRelease(v3);
  return v4;
}

void __CGInitializeImageIO_block_invoke()
{
  global_queue = dispatch_get_global_queue(25, 0);

  dispatch_async(global_queue, &__block_literal_global_4);
}

void AdobeXMPCore::INameSpacePrefixMap_v1::CreateNameSpacePrefixMap(AdobeXMPCore::INameSpacePrefixMap_v1 *this)
{
  int v1 = (AdobeXMPCore_Int::NameSpacePrefixMapImpl *)AdobeXMPCore_Int::MemoryManagedObject::operator new((AdobeXMPCore_Int::MemoryManagedObject *)0x78);
  AdobeXMPCore_Int::NameSpacePrefixMapImpl::NameSpacePrefixMapImpl(v1);
  AdobeXMPCore_Int::MakeUncheckedSharedPointer<AdobeXMPCore_Int::NameSpacePrefixMapImpl>(v2, 1, &v3);
}

void std::shared_ptr<AdobeXMPCore_Int::NameSpacePrefixMapImpl>::shared_ptr[abi:ne180100]<AdobeXMPCore_Int::NameSpacePrefixMapImpl,std::__mem_fn<void (AdobeXMPCore_Int::SharedObjectImpl::*)(void)const>,void>(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_1885DFFB0(void *a1)
{
  __cxa_begin_catch(a1);
  uint64_t v4 = (void *)((char *)v3 + *(void *)(*v3 - 184) + (v2 >> 1));
  if (v2) {
    int v1 = *(void (**)(void *))(*v4 + v1);
  }
  v1(v4);
  __cxa_rethrow();
}

void sub_1885E0014(_Unwind_Exception *a1)
{
}

void AdobeXMPCore_Int::MakeUncheckedSharedPointer<AdobeXMPCore_Int::NameSpacePrefixMapImpl>(char *a1@<X0>, int a2@<W3>, void *a3@<X8>)
{
  if (a1 || !a2)
  {
    (**(void (***)(char *))&a1[*(void *)(*(void *)a1 - 184)])(&a1[*(void *)(*(void *)a1 - 184)]);
    std::shared_ptr<AdobeXMPCore_Int::NameSpacePrefixMapImpl>::shared_ptr[abi:ne180100]<AdobeXMPCore_Int::NameSpacePrefixMapImpl,std::__mem_fn<void (AdobeXMPCore_Int::SharedObjectImpl::*)(void)const>,void>(a3, (uint64_t)a1);
  }
  AdobeXMPCore_Int::IError_I::CreateError(1, 6, 2);
}

void sub_1885E01B8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a10);
  }
  _Unwind_Resume(exception_object);
}

double AdobeXMPCore_Int::NameSpacePrefixMapImpl::NameSpacePrefixMapImpl(AdobeXMPCore_Int::NameSpacePrefixMapImpl *this)
{
  *(void *)&double result = 0x100000000;
  *((void *)this + 8) = 0x100000000;
  *((void *)this + 9) = &unk_1ED4D44F0;
  *((void *)this + 12) = &unk_1ED4D46A0;
  *(void *)this = &unk_1ED4D3F70;
  *((void *)this + 7) = &unk_1ED4D40B0;
  *(void *)((char *)this + unk_1ED4D3F28) = &unk_1ED4D4228;
  *(void *)((char *)this + *(void *)(*(void *)this - 80)) = &unk_1ED4D41A0;
  *(void *)((char *)this + *(void *)(*(void *)this - 88)) = &unk_1ED4D4228;
  *((void *)this + 10) = 0;
  *((void *)this + 11) = 0;
  *((void *)this + 13) = 0;
  *((void *)this + 14) = 0;
  *((void *)this + 6) = 0;
  *((void *)this + 7) = off_1ED4ED178;
  *(void *)this = off_1ED4ECFE8;
  *((void *)this + 9) = off_1ED4ED270;
  *((void *)this + 12) = off_1ED4ED300;
  *((void *)this + 2) = 0;
  *((void *)this + 1) = (char *)this + 16;
  *((void *)this + 5) = 0;
  *((void *)this + 3) = 0;
  *((void *)this + 4) = (char *)this + 40;
  return result;
}

char *___ZN20IIOImageProviderInfo19checkBlockSetBufferEP15CGImageBlockSet_block_invoke()
{
  return strncpy(IIOImageProviderInfo::checkBlockSetBuffer(CGImageBlockSet *)::logMessage, "CGImageBlock {0x........,0x........,0x........,0x........} rb=0x........ pixSize=0x........ compType=0x........ csm='....' fmt='....' offset=0x................ ", 0xAAuLL);
}

const char *_mappedDeallocate(void *a1, void *a2)
{
  if (munmap(a1, (size_t)a2) < 0)
  {
    long long v5 = __error();
    uint64_t v6 = strerror(*v5);
    return LogFault("_mappedDeallocate", 78, "Failed to unmap data (%p; 0x%lx): %s.\n", a1, a2, v6);
  }
  else
  {
    double result = (const char *)kdebug_trace();
    if ((gIIODebugFlags & 0x100000000000) != 0)
    {
      double result = ImageIOLog("   ------------------------------------------------------\n");
      if ((gIIODebugFlags & 0x100000000000) != 0)
      {
        double result = ImageIOLog("    %s:%d             munmap   ptr: %p  size: %ld\n", "_mappedDeallocate", 84, a1, a2);
        if ((gIIODebugFlags & 0x100000000000) != 0)
        {
          return ImageIOLog("   ------------------------------------------------------\n");
        }
      }
    }
  }
  return result;
}

BOOL CGImageMetadataSetTagWithPath(CGMutableImageMetadataRef metadata, CGImageMetadataTagRef parent, CFStringRef path, CGImageMetadataTagRef tag)
{
  IIOInitDebugFlags();
  if ((~(_WORD)gIIODebugFlags & 0x3000) == 0) {
    ImageIODebugOptions(3, "A", "CGImageMetadataSetTagWithPath", 0, 0, -1, 0);
  }
  uint64_t Source = CGImageSourceGetSource((uint64_t)tag);
  if (!metadata) {
    goto LABEL_14;
  }
  uint64_t v9 = Source;
  CFTypeID v10 = CFGetTypeID(metadata);
  if (CGImageMetadataGetTypeID::once != -1) {
    dispatch_once(&CGImageMetadataGetTypeID::once, &__block_literal_global_21);
  }
  if (v10 != CGImageMetadataGetTypeID::id) {
    goto LABEL_14;
  }
  LOBYTE(v11) = 0;
  if (!path) {
    return v11;
  }
  if (!*((unsigned char *)metadata + 16)) {
    return v11;
  }
  CFTypeID v12 = CFGetTypeID(path);
  CFTypeID TypeID = CFStringGetTypeID();
  LOBYTE(v11) = 0;
  if (!tag || v12 != TypeID) {
    return v11;
  }
  CFTypeID v14 = CFGetTypeID(tag);
  if (v14 != CGImageMetadataTagGetTypeID())
  {
LABEL_14:
    LOBYTE(v11) = 0;
    return v11;
  }
  uint64_t v15 = (pthread_mutex_t *)((char *)metadata + 208);
  pthread_mutex_lock((pthread_mutex_t *)((char *)metadata + 208));
  if (*((unsigned char *)metadata + 200))
  {
    LogMetadata("CGImageMetadataSetTagWithPath", 946, "Cannot mutate metadata while enumerating");
    LOBYTE(v11) = 0;
  }
  else
  {
    pthread_mutex_unlock((pthread_mutex_t *)((char *)metadata + 208));
    uint64_t v15 = (pthread_mutex_t *)((char *)metadata + 72);
    pthread_mutex_lock((pthread_mutex_t *)((char *)metadata + 72));
    BOOL v11 = CGImageMetadataSetValueWithPath(metadata, parent, path, *(CFTypeRef *)(v9 + 48));
    if (v11)
    {
      TagWithPath = CGImageMetadataGetTagWithPath(metadata, parent, path);
      if (TagWithPath)
      {
        uint64_t v18 = (uint64_t)TagWithPath;
        uint64_t v19 = CGImageSourceGetSource((uint64_t)TagWithPath);
        CGImageMetadataTagSetNamespace(v18, *(const __CFString **)(v9 + 16));
        CGImageMetadataTagSetPrefix(v18, *(const __CFString **)(v9 + 24));
        CFArrayRef v20 = *(const __CFArray **)(v9 + 56);
        if (v20) {
          *(void *)(v19 + 56) = CFArrayCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, v20);
        }
        *(_DWORD *)(v19 + 40) = *(_DWORD *)(v9 + 40);
      }
    }
  }
  pthread_mutex_unlock(v15);
  return v11;
}

BOOL CGImageMetadataSetValueWithPath(CGMutableImageMetadataRef metadata, CGImageMetadataTagRef parent, CFStringRef path, CFTypeRef value)
{
  IIOInitDebugFlags();
  if ((~(_WORD)gIIODebugFlags & 0x3000) == 0) {
    ImageIODebugOptions(3, "A", "CGImageMetadataSetValueWithPath", 0, 0, -1, 0);
  }
  uint64_t v96 = 0;
  unsigned __int8 v97 = &v96;
  uint64_t v98 = 0x2000000000;
  uint64_t v99 = 0;
  uint64_t Source = CGImageSourceGetSource((uint64_t)parent);
  if (!metadata) {
    goto LABEL_4;
  }
  uint64_t v9 = (IIOMetadata_Tag *)Source;
  CFTypeID v10 = CFGetTypeID(metadata);
  if (CGImageMetadataGetTypeID::once != -1) {
    dispatch_once(&CGImageMetadataGetTypeID::once, &__block_literal_global_21);
  }
  if (v10 != CGImageMetadataGetTypeID::id) {
    goto LABEL_4;
  }
  if (parent)
  {
    CFTypeID v11 = CFGetTypeID(parent);
    CFTypeID TypeID = CGImageMetadataTagGetTypeID();
    unsigned int v89 = 0;
    char v88 = 0;
    if (!path || v11 != TypeID) {
      goto LABEL_161;
    }
  }
  else if (!path)
  {
LABEL_4:
    char v88 = 0;
    unsigned int v89 = 0;
    goto LABEL_161;
  }
  CFTypeID v13 = CFGetTypeID(path);
  if (v13 != CFStringGetTypeID()) {
    goto LABEL_4;
  }
  pthread_mutex_lock((pthread_mutex_t *)((char *)metadata + 208));
  if (*((unsigned char *)metadata + 200))
  {
    LogMetadata("CGImageMetadataSetValueWithPath", 1012, "Cannot mutate metadata while enumerating");
    pthread_mutex_unlock((pthread_mutex_t *)((char *)metadata + 208));
    goto LABEL_4;
  }
  pthread_mutex_unlock((pthread_mutex_t *)((char *)metadata + 208));
  int v82 = (pthread_mutex_t *)((char *)metadata + 72);
  pthread_mutex_lock((pthread_mutex_t *)((char *)metadata + 72));
  TagWithPath = CGImageMetadataGetTagWithPath(metadata, parent, path);
  if (TagWithPath)
  {
    char v88 = CGImageMetadataTagSetValue((uint64_t)TagWithPath, (const __CFString *)value);
LABEL_17:
    CFStringRef cf = 0;
LABEL_18:
    uint64_t v15 = 0;
    CFStringRef v85 = 0;
    CFStringRef PropertyPrefixFromCStrPrefix = 0;
    CFStringRef v16 = 0;
    CFStringRef Mutable = 0;
    unsigned int v89 = 0;
    goto LABEL_149;
  }
  CFAllocatorRef v18 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFAllocatorRef allocator = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  if (parent)
  {
    CFStringRef v19 = CFStringCreateWithFormat(v18, 0, @"%@:%@", *((void *)v9 + 3), *((void *)v9 + 4));
    if (!v19)
    {
      char v88 = 0;
      goto LABEL_17;
    }
    CFStringRef cf = IIOMetadata_Tag::createPathWithChildPath(v9, path);
    CFArrayRef v20 = parse_metadata_pathString(v19);
    if (v20)
    {
      uint64_t v21 = *((void *)v20 + 5);
      if (v21)
      {
        int v22 = 0;
        do
        {
          if ((*(_DWORD *)v21 & 0xFFFFFFFE) != 2) {
            break;
          }
          ++v22;
          uint64_t v21 = *(void *)(v21 + 40);
        }
        while (v21);
      }
      else
      {
        int v22 = 0;
      }
      freeNodes(v20);
    }
    else
    {
      int v22 = 0;
    }
    CFRelease(v19);
    unsigned int v23 = parse_metadata_pathString(cf);
  }
  else
  {
    CFStringRef cf = CFStringCreateCopy(v18, path);
    int v22 = 0;
    unsigned int v23 = parse_metadata_pathString(cf);
  }
  unsigned int v89 = (const char **)v23;
  unsigned int v24 = v23;
  if (!v23)
  {
    char v88 = 0;
    goto LABEL_18;
  }
  unsigned __int8 v25 = (char *)*((void *)v23 + 1);
  if (!v25 || !*((void *)v24 + 2)) {
    goto LABEL_170;
  }
  if (parent)
  {
    uint64_t v15 = (void *)CFRetain(parent);
    uint64_t v26 = CGImageSourceGetSource((uint64_t)v15);
    if (v22 < 1)
    {
      CFStringRef v85 = 0;
      CFStringRef PropertyPrefixFromCStrPrefix = 0;
      CFNumberRef v27 = v89;
    }
    else
    {
      CFNumberRef v27 = v89;
      do
      {
        CFNumberRef v27 = (const char **)v27[5];
        --v22;
      }
      while (v22);
      CFStringRef v85 = 0;
      CFStringRef PropertyPrefixFromCStrPrefix = 0;
    }
    goto LABEL_60;
  }
  CFStringRef PropertyPrefixFromCStrPrefix = createPropertyPrefixFromCStrPrefix(v25);
  if (!PropertyPrefixFromCStrPrefix)
  {
LABEL_170:
    char v88 = 0;
    uint64_t v15 = 0;
    CFStringRef v85 = 0;
    CFStringRef PropertyPrefixFromCStrPrefix = 0;
LABEL_171:
    CFStringRef v16 = 0;
    CFStringRef Mutable = 0;
    goto LABEL_149;
  }
  CFStringRef v85 = CFStringCreateWithCString(allocator, v89[2], 0x8000100u);
  CFStringRef v28 = (const __CFString *)CGImageMetadataNamespaceForPrefix(metadata, PropertyPrefixFromCStrPrefix);
  if (!v28)
  {
    LogMetadata("CGImageMetadataSetValueWithPath", 1091, "Could not obtain XMP namespace for prefix '%s'. Please ensure that the prefix has been registered with CGImageMetadataRegisterNamespaceForPrefix.", v89[1]);
    char v88 = 0;
    uint64_t v15 = 0;
    goto LABEL_171;
  }
  CFDictionaryRef v29 = (const __CFDictionary *)*((void *)metadata + 3);
  if (v29)
  {
    kedouble y = v28;
    p_kedouble y = v85;
    uint64_t v94 = 0;
    uint64_t v15 = (void *)CFDictionaryGetValue(v29, &key);
  }
  else
  {
    uint64_t v15 = 0;
  }
  uint64_t v30 = CGImageSourceGetSource((uint64_t)v15);
  if (v15)
  {
    uint64_t v26 = v30;
    CFRetain(v15);
    CFNumberRef v27 = v89;
    goto LABEL_60;
  }
  unsigned __int8 v31 = v89[5];
  if (v31)
  {
    int v32 = *(_DWORD *)v31;
    switch(v32)
    {
      case 4:
        CFStringRef Mutable = (const __CFString *)CFDictionaryCreateMutable(allocator, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
        CGImageMetadataType v33 = kCGImageMetadataTypeStructure;
        break;
      case 3:
        CFStringRef Mutable = (const __CFString *)CFArrayCreateMutable(allocator, 0, MEMORY[0x1E4F1D510]);
        CGImageMetadataType v33 = kCGImageMetadataTypeAlternateText;
        break;
      case 2:
        CFStringRef Mutable = (const __CFString *)CFArrayCreateMutable(allocator, 0, MEMORY[0x1E4F1D510]);
        CGImageMetadataType v33 = kCGImageMetadataTypeArrayOrdered;
        break;
      default:
        LogMetadata("CGImageMetadataSetValueWithPath", 1122, "Unable to create top-level property with type %d\n", v32);
        uint64_t v15 = 0;
        goto LABEL_147;
    }
    if (!Mutable)
    {
      uint64_t v15 = 0;
      CFStringRef v16 = 0;
      goto LABEL_148;
    }
    uint64_t v15 = CGImageMetadataTagCreate(v28, PropertyPrefixFromCStrPrefix, v85, v33, Mutable);
    uint64_t v26 = CGImageSourceGetSource((uint64_t)v15);
    CFRelease(Mutable);
  }
  else
  {
    uint64_t v15 = CGImageMetadataTagCreate(v28, PropertyPrefixFromCStrPrefix, v85, kCGImageMetadataTypeDefault, value);
    uint64_t v26 = CGImageSourceGetSource((uint64_t)v15);
  }
  if (!v15)
  {
LABEL_147:
    CFStringRef v16 = 0;
    CFStringRef Mutable = 0;
LABEL_148:
    char v88 = 1;
    goto LABEL_149;
  }
  CGImageMetadataAddTag((uint64_t)metadata, v15);
  CFNumberRef v27 = v89;
LABEL_60:
  CFStringRef valuea = (const __CFString *)value;
  unint64_t v84 = metadata;
  uint64_t v34 = v27[5];
  if (v34) {
    BOOL v35 = v15 == 0;
  }
  else {
    BOOL v35 = 1;
  }
  if (v35) {
    goto LABEL_147;
  }
  char v88 = 0;
  while (2)
  {
    CFTypeID v36 = CFGetTypeID(v15);
    if (v36 != CGImageMetadataTagGetTypeID()) {
      goto LABEL_171;
    }
    unsigned int v37 = (char *)*((void *)v34 + 1);
    if (v37) {
      CFStringRef v16 = createPropertyPrefixFromCStrPrefix(v37);
    }
    else {
      CFStringRef v16 = 0;
    }
    unsigned int v38 = (const char *)*((void *)v34 + 2);
    if (v38) {
      CFStringRef Mutable = CFStringCreateWithCString(allocator, v38, 0x8000100u);
    }
    else {
      CFStringRef Mutable = 0;
    }
    switch(*(_DWORD *)v34)
    {
      case 2:
        if (CGImageMetadataTagGetType((CGImageMetadataTagRef)v15) != kCGImageMetadataTypeArrayOrdered
          && CGImageMetadataTagGetType((CGImageMetadataTagRef)v15) != kCGImageMetadataTypeArrayUnordered
          && CGImageMetadataTagGetType((CGImageMetadataTagRef)v15) != kCGImageMetadataTypeAlternateArray)
        {
          goto LABEL_149;
        }
        unsigned __int8 v39 = (void *)CGImageMetadataTagGetValue((uint64_t)v15);
        CFTypeID v40 = CFGetTypeID(v39);
        if (v40 != CFArrayGetTypeID()) {
          goto LABEL_149;
        }
        CFIndex Count = CFArrayGetCount((CFArrayRef)v39);
        CFIndex v42 = *((int *)v34 + 6);
        if (Count < v42)
        {
          LogMetadata("CGImageMetadataSetValueWithPath", 1244, "Cannot set array element at index %d, current array has %d element(s).", *((_DWORD *)v34 + 6), Count);
          goto LABEL_149;
        }
        if (CFArrayGetCount((CFArrayRef)v39) <= v42) {
          ValueAtIndedouble x = 0;
        }
        else {
          ValueAtIndedouble x = CFArrayGetValueAtIndex((CFArrayRef)v39, *((int *)v34 + 6));
        }
        CFStringRef Namespace = (const __CFString *)CGImageMetadataTagGetNamespace((uint64_t)v15);
        Prefidouble x = (const __CFString *)CGImageMetadataTagGetPrefix((uint64_t)v15);
        CFStringRef v54 = CFStringCreateWithFormat(allocator, 0, @"[%d]", *((unsigned int *)v34 + 6));
        if (!v54) {
          goto LABEL_149;
        }
        if (ValueAtIndex)
        {
          CFTypeID v68 = CFGetTypeID(ValueAtIndex);
          if (v68 == CGImageMetadataTagGetTypeID())
          {
            CFTypeRef v69 = CFRetain(ValueAtIndex);
            _OWORD v97[3] = (uint64_t)v69;
            if (!*((void *)v34 + 5)) {
              CGImageMetadataTagSetValue((uint64_t)v69, valuea);
            }
            goto LABEL_140;
          }
        }
        unsigned __int8 v70 = (int *)*((void *)v34 + 5);
        if (!v70)
        {
          CGImageMetadataTagRef v75 = CGImageMetadataTagCreate(Namespace, Prefix, v54, kCGImageMetadataTypeDefault, valuea);
          _OWORD v97[3] = (uint64_t)v75;
          goto LABEL_138;
        }
        int v71 = *v70;
        switch(v71)
        {
          case 4:
            CFMutableDictionaryRef v72 = CFDictionaryCreateMutable(allocator, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
            CGImageMetadataType v73 = kCGImageMetadataTypeStructure;
            if (!v72) {
              goto LABEL_138;
            }
            break;
          case 3:
            CFMutableDictionaryRef v72 = CFArrayCreateMutable(allocator, 0, MEMORY[0x1E4F1D510]);
            CGImageMetadataType v73 = kCGImageMetadataTypeAlternateText;
            if (!v72) {
              goto LABEL_138;
            }
            break;
          case 2:
            CFMutableDictionaryRef v72 = CFArrayCreateMutable(allocator, 0, MEMORY[0x1E4F1D510]);
            CGImageMetadataType v73 = kCGImageMetadataTypeArrayOrdered;
            if (!v72)
            {
LABEL_138:
              unsigned __int8 v79 = (const void *)v97[3];
              if (v79) {
                CFArraySetValueAtIndex((CFMutableArrayRef)v39, *((int *)v34 + 6), v79);
              }
              goto LABEL_140;
            }
            break;
          default:
            LogMetadata("CGImageMetadataSetValueWithPath", 1289, "Unable to create a property with type %d\n", v71);
            goto LABEL_138;
        }
        CGImageMetadataTagRef v78 = CGImageMetadataTagCreate(Namespace, Prefix, v54, v73, v72);
        _OWORD v97[3] = (uint64_t)v78;
        CFRelease(v72);
        goto LABEL_138;
      case 3:
        if (CGImageMetadataTagGetType((CGImageMetadataTagRef)v15) != kCGImageMetadataTypeAlternateText) {
          goto LABEL_149;
        }
        CFIndex v52 = (void *)CGImageMetadataTagGetValue((uint64_t)v15);
        CFTypeID v53 = CFGetTypeID(v52);
        if (v53 != CFArrayGetTypeID()) {
          goto LABEL_149;
        }
        CFStringRef v54 = CFStringCreateWithCString(allocator, *((const char **)v34 + 4), 0x8000100u);
        if (!v54) {
          goto LABEL_149;
        }
        if (*((void *)v34 + 5))
        {
          LogMetadata("CGImageMetadataSetValueWithPath", 1327, "Language codes must be the last element in a path, all alternate-text array elements are strings and cannot have children.\n");
          CFRelease(v54);
          goto LABEL_149;
        }
        CFStringRef v55 = (const __CFString *)CGImageMetadataTagGetNamespace((uint64_t)v15);
        CFStringRef v56 = (const __CFString *)CGImageMetadataTagGetPrefix((uint64_t)v15);
        CFStringRef v57 = CFStringCreateWithFormat(allocator, 0, @"[%@]", v54);
        if (v57)
        {
          CGImageMetadataTagRef v58 = CGImageMetadataTagCreate(v55, v56, v57, kCGImageMetadataTypeString, valuea);
          _OWORD v97[3] = (uint64_t)v58;
          if (v58)
          {
            CGImageMetadataTagRef v59 = CGImageMetadataTagCreate(@"http://www.w3.org/XML/1998/namespace", @"xml", @"lang", kCGImageMetadataTypeString, v54);
            if (v59)
            {
              CGImageMetadataTagAppendQualifier(v84, v97[3], v59);
              CFArrayAppendValue((CFMutableArrayRef)v52, (const void *)v97[3]);
              CFRelease(v59);
            }
          }
          CFRelease(v57);
        }
LABEL_140:
        CFRelease(v54);
        goto LABEL_141;
      case 4:
        if (CGImageMetadataTagGetType((CGImageMetadataTagRef)v15) != kCGImageMetadataTypeStructure) {
          goto LABEL_149;
        }
        CFStringRef v44 = (const __CFString *)CGImageMetadataNamespaceForPrefix(v84, v16);
        CFIndex v45 = (void *)CGImageMetadataTagGetValue((uint64_t)v15);
        CFTypeID v46 = CFGetTypeID(v45);
        if (v46 != CFDictionaryGetTypeID() || !Mutable) {
          goto LABEL_149;
        }
        CFNumberRef v47 = CFDictionaryGetValue((CFDictionaryRef)v45, Mutable);
        CFNumberRef v48 = v47;
        if (v47)
        {
          CFTypeID v49 = CFGetTypeID(v47);
          if (v49 == CGImageMetadataTagGetTypeID())
          {
            CFTypeRef v50 = CFRetain(v48);
            _OWORD v97[3] = (uint64_t)v50;
            if (!*((void *)v34 + 5)) {
              CGImageMetadataTagSetValue((uint64_t)v50, valuea);
            }
            goto LABEL_141;
          }
        }
        unsigned int v60 = (int *)*((void *)v34 + 5);
        if (!v60)
        {
          CGImageMetadataTagRef v74 = CGImageMetadataTagCreate(v44, v16, Mutable, kCGImageMetadataTypeDefault, valuea);
          _OWORD v97[3] = (uint64_t)v74;
          goto LABEL_131;
        }
        int v61 = *v60;
        switch(v61)
        {
          case 4:
            CFMutableDictionaryRef v62 = CFDictionaryCreateMutable(allocator, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
            CGImageMetadataType v63 = kCGImageMetadataTypeStructure;
            if (!v62) {
              goto LABEL_131;
            }
            goto LABEL_129;
          case 3:
            CFMutableDictionaryRef v62 = CFArrayCreateMutable(allocator, 0, MEMORY[0x1E4F1D510]);
            CGImageMetadataType v63 = kCGImageMetadataTypeAlternateText;
            if (!v62) {
              goto LABEL_131;
            }
            goto LABEL_129;
          case 2:
            CFMutableDictionaryRef v62 = CFArrayCreateMutable(allocator, 0, MEMORY[0x1E4F1D510]);
            CGImageMetadataType v63 = kCGImageMetadataTypeArrayOrdered;
            if (!v62) {
              goto LABEL_131;
            }
LABEL_129:
            CGImageMetadataTagRef v76 = CGImageMetadataTagCreate(v44, v16, Mutable, v63, v62);
            _OWORD v97[3] = (uint64_t)v76;
            CFRelease(v62);
            goto LABEL_131;
        }
        LogMetadata("CGImageMetadataSetValueWithPath", 1210, "Unable to create a property with type %d\n", v61);
LABEL_131:
        unsigned int v77 = (const void *)v97[3];
        if (v77) {
          CFDictionarySetValue((CFMutableDictionaryRef)v45, Mutable, v77);
        }
        goto LABEL_141;
      case 5:
        kedouble y = 0;
        p_kedouble y = (const __CFString *)&key;
        uint64_t v94 = 0x2000000000;
        char v95 = 0;
        if (*((void *)v34 + 5))
        {
          LogMetadata("CGImageMetadataSetValueWithPath", 1358, "Only string qualifier values are currently supported.\n");
          goto LABEL_173;
        }
        uint64_t v51 = *(void *)(v26 + 56);
        if (v51)
        {
          v91[0] = MEMORY[0x1E4F143A8];
          v91[1] = 0x40000000;
          v91[2] = __CGImageMetadataSetValueWithPath_block_invoke;
          v91[3] = &unk_1E53C72C8;
          v91[6] = v16;
          v91[7] = Mutable;
          v91[4] = &v96;
          v91[5] = &key;
          IIOArrayEnumerateUsingBlock(v51, (uint64_t)v91);
          if (LOBYTE(p_key->length))
          {
            if (!*((void *)v34 + 5)) {
              CGImageMetadataTagSetValue(v97[3], valuea);
            }
            goto LABEL_111;
          }
        }
        CFStringRef v64 = (const __CFString *)CGImageMetadataNamespaceForPrefix(v84, v16);
        CGImageMetadataTagRef v65 = CGImageMetadataTagCreate(v64, v16, Mutable, kCGImageMetadataTypeDefault, valuea);
        _OWORD v97[3] = (uint64_t)v65;
        if (!v65) {
          goto LABEL_111;
        }
        if (CGImageMetadataTagAppendQualifier(v84, (uint64_t)v15, v65))
        {
          char v88 = 1;
LABEL_111:
          _Block_object_dispose(&key, 8);
LABEL_141:
          uint64_t v34 = (const char *)*((void *)v34 + 5);
          CFRelease(v15);
          uint64_t v15 = (void *)v97[3];
          _OWORD v97[3] = 0;
          uint64_t v26 = CGImageSourceGetSource((uint64_t)v15);
          if (v16) {
            CFRelease(v16);
          }
          if (Mutable) {
            CFRelease(Mutable);
          }
          if (!v34 || !v15) {
            goto LABEL_147;
          }
          continue;
        }
        char v88 = 0;
LABEL_173:
        _Block_object_dispose(&key, 8);
LABEL_149:
        pthread_mutex_unlock(v82);
        if (v15) {
          CFRelease(v15);
        }
        if (cf) {
          CFRelease(cf);
        }
        if (PropertyPrefixFromCStrPrefix) {
          CFRelease(PropertyPrefixFromCStrPrefix);
        }
        if (v85) {
          CFRelease(v85);
        }
        if (v16) {
          CFRelease(v16);
        }
        if (Mutable) {
          CFRelease(Mutable);
        }
LABEL_161:
        int v80 = (const void *)v97[3];
        if (v80) {
          CFRelease(v80);
        }
        freeNodes(v89);
        _Block_object_dispose(&v96, 8);
        return v88 & 1;
      default:
        goto LABEL_141;
    }
  }
}

void sub_1885E1388(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 136), 8);
  _Unwind_Resume(a1);
}

uint64_t PNGReadPlugin::AddOrientationToMetadata(uint64_t a1, uint64_t a2, CGImageMetadata *a3, uint64_t a4, uint64_t a5)
{
  int text_count = _cg_png_get_text_count(a4, a5);
  uint64_t v34 = 0;
  BOOL v35 = &v34;
  uint64_t v36 = 0x2000000000;
  int v37 = 0;
  if (text_count < 1) {
    goto LABEL_23;
  }
  int v9 = text_count;
  CFNumberRef v27 = a3;
  for (unsigned int i = 0; i != v9; ++i)
  {
    __s1[0] = 0;
    uint64_t v32 = 0;
    size_t v33 = 0;
    text_entrdouble y = (const char *)_cg_png_get_text_entry(a4, a5, i, __s1, &v32, &v33);
    CFTypeID v12 = __s1[0];
    if (!strncmp(__s1[0], "Raw profile type exif", 0x15uLL) || !strncmp(v12, "Raw profile type xmp", 0x14uLL))
    {
      __endptr = 0;
      if (*text_entry == 10)
      {
        CFTypeID v13 = text_entry + 1;
        unint64_t v14 = v32 - 1;
        do
        {
          unint64_t v15 = v14;
          int v16 = *(unsigned __int8 *)v13;
          if (!*v13) {
            break;
          }
          ++v13;
          --v14;
        }
        while (v16 != 10);
        uint64_t v17 = strtol(v13, &__endptr, 10);
        if ((int)v17 <= v15)
        {
          size_t v18 = v17;
          CFStringRef v19 = (char *)PNGReadPlugin::HexString2bin((PNGReadPlugin *)__endptr, (int)v17);
          if (v19)
          {
            CFArrayRef v20 = __s1[0];
            if (!strncmp(__s1[0], "Raw profile type exif", 0x15uLL))
            {
              v30[0] = MEMORY[0x1E4F143A8];
              v30[1] = 0x40000000;
              v30[2] = ___ZN13PNGReadPlugin24AddOrientationToMetadataEP13IIODictionaryS1_P15CGImageMetadataP14png_struct_defP12png_info_def_block_invoke;
              v30[3] = &unk_1E53BFD00;
              v30[4] = &v34;
              EnumerateExifDataUsingBlock(v19, v18, (uint64_t)v30);
            }
            else if (!strncmp(v20, "Raw profile type xmp", 0x14uLL) && !*((_DWORD *)v35 + 6))
            {
              int v21 = IIOGetOrientationFromXMPData(v19, v18);
              *((_DWORD *)v35 + 6) = v21;
            }
            free(v19);
          }
        }
      }
    }
    size_t v22 = v33;
    if (v33 && !strncmp(__s1[0], "XML:com.adobe.xmp", 0x11uLL) && !*((_DWORD *)v35 + 6))
    {
      int v23 = IIOGetOrientationFromXMPData(text_entry, v22);
      *((_DWORD *)v35 + 6) = v23;
    }
  }
  int v24 = *((_DWORD *)v35 + 6);
  a3 = v27;
  if (!v24)
  {
LABEL_23:
    LODWORD(v33) = 0;
    __s1[0] = 0;
    if (_cg_png_get_eXIf_1(a4, a5, &v33, __s1))
    {
      v29[0] = MEMORY[0x1E4F143A8];
      v29[1] = 0x40000000;
      v29[2] = ___ZN13PNGReadPlugin24AddOrientationToMetadataEP13IIODictionaryS1_P15CGImageMetadataP14png_struct_defP12png_info_def_block_invoke_2;
      v29[3] = &unk_1E53C44E0;
      v29[4] = &v34;
      EnumerateExifDataUsingBlock(__s1[0], v33, (uint64_t)v29);
    }
    int v24 = *((_DWORD *)v35 + 6);
  }
  if ((v24 - 1) <= 7)
  {
    IIONumber::IIONumber((IIONumber *)__s1, v24);
    unsigned __int8 v25 = CGImageMetadataTagCreate(@"http://ns.adobe.com/tiff/1.0/", @"tiff", @"Orientation", kCGImageMetadataTypeDefault, __s1[2]);
    IIONumber::~IIONumber((IIONumber *)__s1);
    if (v25)
    {
      CGImageMetadataSetTagWithPath(a3, 0, @"tiff:Orientation", v25);
      CFRelease(v25);
    }
  }
  _Block_object_dispose(&v34, 8);
  return 0;
}

void sub_1885E178C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  IIONumber::~IIONumber((IIONumber *)va);
  _Block_object_dispose((const void *)(v4 - 136), 8);
  _Unwind_Resume(a1);
}

uint64_t PNGReadPlugin::HandlePNGMetadata(IIODictionary *a1, IIODictionary *a2, void *a3, uint64_t a4, uint64_t a5)
{
  int v10 = IIOSkipMetadata(a1);
  char v64 = IIOSkipXMP_and_IPTC(a1);
  if ((v64 & 1) == 0)
  {
    CFDictionaryRef ObjectForKey = IIODictionary::getObjectForKey(a1, @"kCGImageSourceXMPSidecar");
    if (ObjectForKey)
    {
      CFDataRef v12 = ObjectForKey;
      BytePtr = (const char *)CFDataGetBytePtr(ObjectForKey);
      CFIndex Length = CFDataGetLength(v12);
      MetadataFromXMPSidecarunint64_t Data = (const void *)CreateMetadataFromXMPSidecarData(BytePtr, Length);
      CGImageMetadataMerge((uint64_t)a3, (uint64_t)MetadataFromXMPSidecarData, 0);
      if (MetadataFromXMPSidecarData) {
        CFRelease(MetadataFromXMPSidecarData);
      }
      goto LABEL_48;
    }
  }
  CFMutableDictionaryRef v62 = a2;
  uint64_t v63 = (uint64_t)a3;
  unsigned int v70 = 0;
  CFTypeRef v69 = 0;
  int text_count = _cg_png_get_text_count(a4, a5);
  if (text_count >= 1)
  {
    int v17 = text_count;
    unsigned int v18 = 0;
    while (1)
    {
      unint64_t v67 = 0;
      __s1 = 0;
      CFTypeID v66 = 0;
      text_entrdouble y = (const char *)_cg_png_get_text_entry(a4, a5, v18, &__s1, &v66, &v67);
      CFArrayRef v20 = __s1;
      if (!strncmp(__s1, "Raw profile type exif", 0x15uLL)
        || !strncmp(v20, "Raw profile type iptc", 0x15uLL)
        || !strncmp(v20, "Raw profile type xmp", 0x14uLL)
        || !strncmp(v20, "Raw profile type icc", 0x14uLL)
        || !strncmp(v20, "Raw profile type icm", 0x14uLL))
      {
        break;
      }
      unint64_t v21 = v67;
      if (v67)
      {
        if (!strncmp(v20, "XML:com.adobe.xmp", 0x11uLL))
        {
          if ((v64 & 1) == 0
            && (!IIODictionary::containsKey(a1, @"kCGImageSourceSkipXMPIfLargerThanSize")
             || v21 <= IIODictionary::getUint32ForKey(a1, @"kCGImageSourceSkipXMPIfLargerThanSize")))
          {
            MetadataFromXMPBuffer = (const void *)CreateMetadataFromXMPBuffer(text_entry, v21);
            CGImageMetadataMerge(v63, (uint64_t)MetadataFromXMPBuffer, 0);
            if (MetadataFromXMPBuffer) {
              CFRelease(MetadataFromXMPBuffer);
            }
          }
          goto LABEL_33;
        }
        size_t v22 = v66;
        int v23 = v62;
        int v24 = (IIODictionary *)v20;
        unsigned __int8 v25 = (UInt8 *)text_entry;
        unsigned int v26 = v21;
        goto LABEL_32;
      }
      size_t v22 = v66;
      if (v66)
      {
        int v23 = v62;
        int v24 = (IIODictionary *)v20;
        unsigned __int8 v25 = (UInt8 *)text_entry;
        unsigned int v26 = 0;
LABEL_32:
        PNGReadPlugin::AddTextChunkToProperties(v23, v24, v25, v22, v26);
      }
LABEL_33:
      if (++v18 == v17) {
        goto LABEL_40;
      }
    }
    __endptr = 0;
    if (*text_entry != 10) {
      goto LABEL_33;
    }
    CFNumberRef v27 = text_entry + 1;
    CFStringRef v28 = v66 - 1;
    do
    {
      CFDictionaryRef v29 = v28;
      int v30 = *(unsigned __int8 *)v27;
      if (!*v27) {
        break;
      }
      ++v27;
      --v28;
    }
    while (v30 != 10);
    size_t v31 = (int)strtol(v27, &__endptr, 10);
    if (v31 > (unint64_t)v29) {
      goto LABEL_33;
    }
    uint64_t v32 = (char *)PNGReadPlugin::HexString2bin((PNGReadPlugin *)__endptr, v31);
    if (!v32) {
      goto LABEL_33;
    }
    size_t v33 = v32;
    uint64_t v34 = __s1;
    if (!strncmp(__s1, "Raw profile type exif", 0x15uLL))
    {
      MetadataFromDatauint64_t buffer = CreateMetadataFromDatabuffer(v33, v31);
    }
    else
    {
      int v35 = strncmp(v34, "Raw profile type xmp", 0x14uLL);
      char v36 = v64;
      if (v35) {
        char v36 = 1;
      }
      if (v36) {
        goto LABEL_29;
      }
      MetadataFromDatauint64_t buffer = CreateMetadataFromXMPBuffer(v33, v31);
    }
    unsigned int v38 = (const void *)MetadataFromDatabuffer;
    if (MetadataFromDatabuffer)
    {
      CGImageMetadataMerge(v63, MetadataFromDatabuffer, a1);
      CFRelease(v38);
    }
LABEL_29:
    free(v33);
    goto LABEL_33;
  }
LABEL_40:
  a3 = (void *)v63;
  if (_cg_png_get_eXIf_1(a4, a5, &v70, &v69))
  {
    CFTypeID v40 = (void *)CreateMetadataFromDatabuffer((const char *)v69, v70);
    if (v40)
    {
      unsigned int v41 = v40;
      if (v10)
      {
        TagWithPath = CGImageMetadataGetTagWithPath(v40, 0, @"tiff:Orientation");
        if (TagWithPath) {
          CGImageMetadataAddTag(v63, TagWithPath);
        }
      }
      else
      {
        CGImageMetadataMerge(v63, (uint64_t)v40, a1);
      }
      CFRelease(v41);
    }
  }
  a2 = v62;
LABEL_48:
  if (a3) {
    char v43 = v10;
  }
  else {
    char v43 = 1;
  }
  if ((v43 & 1) == 0)
  {
    CFDictionaryRef v44 = (const __CFDictionary *)a3[3];
    if (v44)
    {
      if (CFDictionaryGetCount(v44) >= 1)
      {
        CFIndex v45 = CGImageMetadataGetTagWithPath(a3, 0, @"xmp:CreatorTool");
        if (v45)
        {
          int Value = (const void *)CGImageMetadataTagGetValue((uint64_t)v45);
          IIODictionary::setObjectForKeyGroup(a2, Value, @"Software", @"{PNG}");
        }
        IIODictionary::removeObjectForKey(a2, @"{TIFF}");
        TagMatchingImageuint64_t Property = (const void *)CGImageMetadataGetTagMatchingImageProperty(a3, @"{IPTC}", @"Caption/Abstract");
        DefaultString = CGImageMetadataGetDefaultString(TagMatchingImageProperty);
        if (DefaultString) {
          IIODictionary::setObjectForKeyGroup(a2, DefaultString, @"Description", @"{PNG}");
        }
        CFTypeID v49 = (const void *)CGImageMetadataGetTagMatchingImageProperty(a3, @"{IPTC}", @"CopyrightNotice");
        CFTypeRef v50 = CGImageMetadataGetDefaultString(v49);
        if (v50) {
          IIODictionary::setObjectForKeyGroup(a2, v50, @"Copyright", @"{PNG}");
        }
        uint64_t v51 = (const void *)CGImageMetadataGetTagMatchingImageProperty(a3, @"{IPTC}", @"ObjectName");
        CFIndex v52 = CGImageMetadataGetDefaultString(v51);
        if (v52) {
          IIODictionary::setObjectForKeyGroup(a2, v52, @"Title", @"{PNG}");
        }
        uint64_t v53 = CGImageMetadataGetTagMatchingImageProperty(a3, @"{IPTC}", @"Byline");
        CFStringRef v54 = (const void *)CGImageMetadataTagGetValue(v53);
        if (v54)
        {
          CFStringRef v55 = v54;
          CFTypeID v56 = CFGetTypeID(v54);
          if (v56 == CFStringGetTypeID())
          {
            CFStringRef v57 = a2;
            CGImageMetadataTagRef v58 = v55;
LABEL_68:
            IIODictionary::setObjectForKeyGroup(v57, v58, @"Author", @"{PNG}");
            return 0;
          }
          CFTypeID v59 = CFGetTypeID(v55);
          if (v59 == CFArrayGetTypeID() && CFArrayGetCount((CFArrayRef)v55) >= 1)
          {
            ValueAtIndedouble x = CFArrayGetValueAtIndex((CFArrayRef)v55, 0);
            CGImageMetadataTagRef v58 = (const void *)CGImageMetadataTagGetValue((uint64_t)ValueAtIndex);
            CFStringRef v57 = a2;
            goto LABEL_68;
          }
        }
      }
    }
  }
  return 0;
}

uint64_t CGImageMetadataGetTagMatchingImageProperty(const void *a1, const void *a2, const void *a3)
{
  uint64_t v13 = 0;
  unint64_t v14 = &v13;
  uint64_t v15 = 0x2000000000;
  uint64_t v16 = 0;
  if (a1)
  {
    CFTypeID v6 = CFGetTypeID(a1);
    if (CGImageMetadataGetTypeID::once == -1)
    {
      if (!a2) {
        goto LABEL_9;
      }
    }
    else
    {
      dispatch_once(&CGImageMetadataGetTypeID::once, &__block_literal_global_21);
      if (!a2) {
        goto LABEL_9;
      }
    }
    if (v6 == CGImageMetadataGetTypeID::id)
    {
      CFTypeID v7 = CFGetTypeID(a2);
      CFTypeID TypeID = CFStringGetTypeID();
      if (a3)
      {
        if (v7 == TypeID)
        {
          CFTypeID v9 = CFGetTypeID(a3);
          if (v9 == CFStringGetTypeID())
          {
            v12[0] = MEMORY[0x1E4F143A8];
            v12[1] = 0x40000000;
            void v12[2] = __CGImageMetadataGetTagMatchingImageProperty_block_invoke;
            void v12[3] = &unk_1E53C73B0;
            v12[4] = &v13;
            v12[5] = a2;
            v12[6] = a3;
            v12[7] = a1;
            XMPMappingIterateUsingBlock((uint64_t)v12);
          }
        }
      }
    }
  }
LABEL_9:
  uint64_t v10 = v14[3];
  _Block_object_dispose(&v13, 8);
  return v10;
}

void sub_1885E1EB0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

CFDictionaryRef XMPMappingIterateUsingBlock(uint64_t a1)
{
  return XMPMappingIteratePropertiesUsingBlock(0, a1);
}

const void *CGImageMetadataGetDefaultString(const void *result)
{
  if (result)
  {
    uint64_t v1 = result;
    CFTypeID v2 = CFGetTypeID(result);
    if (v2 == CGImageMetadataTagGetTypeID())
    {
      uint64_t v1 = *(const void **)(CGImageSourceGetSource((uint64_t)v1) + 48);
      if (!v1) {
        return 0;
      }
    }
    CFTypeID v3 = CFGetTypeID(v1);
    if (v3 == CFArrayGetTypeID()
      && CFArrayGetCount((CFArrayRef)v1) >= 1
      && (ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)v1, 0), (uint64_t v1 = ValueAtIndex) != 0)
      && (CFTypeID v5 = CFGetTypeID(ValueAtIndex), v5 == CGImageMetadataTagGetTypeID())
      && (uint64_t v1 = *(const void **)(CGImageSourceGetSource((uint64_t)v1) + 48)) == 0)
    {
      return 0;
    }
    else
    {
      CFTypeID v6 = CFGetTypeID(v1);
      if (v6 == CFStringGetTypeID()) {
        return v1;
      }
      else {
        return 0;
      }
    }
  }
  return result;
}

uint64_t _cg_png_get_text_count(uint64_t a1, uint64_t a2)
{
  uint64_t result = 0;
  if (a1)
  {
    if (a2) {
      return *(unsigned int *)(a2 + 148);
    }
  }
  return result;
}

uint64_t _cg_png_get_eXIf_1(uint64_t a1, uint64_t a2, _DWORD *a3, void *a4)
{
  uint64_t result = 0;
  if (a1)
  {
    if (a2)
    {
      uint64_t result = 0;
      if (a4)
      {
        if ((*(_DWORD *)(a2 + 8) & 0x10000) != 0)
        {
          *a3 = *(_DWORD *)(a2 + 236);
          *a4 = *(void *)(a2 + 240);
          return 0x10000;
        }
      }
    }
  }
  return result;
}

uint64_t CGImageMetadataTagGetValue(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = *(void *)(result + 24);
    if (v1) {
      return *(void *)(v1 + 48);
    }
    else {
      return 0;
    }
  }
  return result;
}

void ReadMetadataRtnl(uint64_t a1, IIOImageReadSession *a2, const __CFString *a3, const __CFString *a4, const __CFString *a5, const void *a6, int a7, uint64_t a8, char a9)
{
  uint64_t v16 = (unsigned int *)malloc_type_calloc(*(unsigned int *)(a8 + 4), 8uLL, 0x1BB58547uLL);
  unsigned int v17 = *(_DWORD *)(a8 + 8);
  if (a9)
  {
    unsigned int v17 = bswap32(v17);
    *(_DWORD *)(a8 + 8) = v17;
  }
  unint64_t BytesAtOffset = IIOImageReadSession::getBytesAtOffset(a2, v16, v17, (8 * *(_DWORD *)(a8 + 4)));
  unsigned int v19 = *(_DWORD *)(a8 + 4);
  if (BytesAtOffset == 8 * v19)
  {
    if ((v19 & 0x7FFFFFFF) != 0 && a9)
    {
      unint64_t v20 = 0;
      do
      {
        v16[v20] = bswap32(v16[v20]);
        ++v20;
        unsigned int v19 = *(_DWORD *)(a8 + 4);
      }
      while (v20 < 2 * v19);
    }
    BOOL v21 = v19 <= 1 && a7 == 0;
    size_t v22 = (const __CFAllocator **)MEMORY[0x1E4F1CF80];
    if (v21)
    {
      if (!v19) {
        goto LABEL_30;
      }
      uint64_t v37 = a1;
      prefidouble x = a4;
      CFStringRef v36 = a5;
      unsigned __int8 v25 = a6;
      int v24 = 0;
      int v26 = 1;
    }
    else
    {
      CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
      int v24 = Mutable;
      if (!*(_DWORD *)(a8 + 4))
      {
        if (!Mutable) {
          goto LABEL_30;
        }
        CGImageMetadataType v33 = kCGImageMetadataTypeArrayOrdered;
        CFStringRef v32 = a3;
        goto LABEL_27;
      }
      uint64_t v37 = a1;
      prefidouble x = a4;
      CFStringRef v36 = a5;
      unsigned __int8 v25 = a6;
      int v26 = 3;
    }
    CGImageMetadataType type = v26;
    unint64_t v27 = 0;
    CFAllocatorRef v28 = *v22;
    CFDictionaryRef v29 = v16 + 1;
    do
    {
      CFStringRef v30 = CFStringCreateWithFormat(v28, 0, @"%u/%u", *(v29 - 1), *v29);
      if ((a7 & 1) != 0 || (unint64_t v31 = *(unsigned int *)(a8 + 4), v31 >= 2))
      {
        CFArrayAppendValue(v24, v30);
        CFRelease(v30);
        CFStringRef v30 = 0;
        unint64_t v31 = *(unsigned int *)(a8 + 4);
      }
      v29 += 2;
      ++v27;
    }
    while (v27 < v31);
    a6 = v25;
    a4 = prefix;
    if (!v24)
    {
      a1 = v37;
      if (!v30) {
        goto LABEL_30;
      }
      CGImageMetadataTagRef v34 = CGImageMetadataTagCreate(a3, prefix, v36, type, v30);
      goto LABEL_28;
    }
    a5 = v36;
    a1 = v37;
    CFStringRef v32 = a3;
    CGImageMetadataType v33 = type;
LABEL_27:
    CGImageMetadataTagRef v34 = CGImageMetadataTagCreate(v32, a4, a5, v33, v24);
    CFStringRef v30 = (CFStringRef)v24;
LABEL_28:
    CFRelease(v30);
    if (v34)
    {
      CGImageMetadataAddTagWithKey(a1, a6, v34);
      CFRelease(v34);
    }
  }
LABEL_30:

  free(v16);
}

uint64_t CreateMetadataFromDatabuffer(const char *a1, unint64_t a2)
{
  if (a1)
  {
    if (a2 <= 0xD)
    {
      _cg_jpeg_mem_term("CreateMetadataFromDatabuffer", 2575, "*** ERROR bad metadata length (%d bytes)\n", a2);
      return 0;
    }
    int v4 = strncmp(a1, "Exif", 4uLL);
    uint64_t v5 = 6;
    if (v4) {
      uint64_t v5 = 0;
    }
    CFTypeID v6 = (unsigned __int8 *)&a1[v5];
    int v7 = a1[v5];
    if (v7 == 73)
    {
      if (v6[1] == 73 && v6[2] == 42 && !v6[3]) {
LABEL_16:
      }
        CGImageReadCreateWithDataForMetadata();
    }
    else if (v7 == 77 && v6[1] == 77 && !v6[2] && v6[3] == 42)
    {
      goto LABEL_16;
    }
  }
  return 0;
}

void ReadMetadataShort(uint64_t a1, IIOImageReadSession *a2, const __CFString *a3, const __CFString *a4, const __CFString *a5, const void *a6, int a7, uint64_t a8, uint64_t a9, char a10)
{
  size_t v15 = *(unsigned int *)(a8 + 4);
  if (v15 < 3)
  {
    uint64_t v16 = 0;
  }
  else
  {
    uint64_t v16 = malloc_type_calloc(v15, 2uLL, 0x1000040BDFB0063uLL);
    LODWORD(v15) = *(_DWORD *)(a8 + 4);
  }
  unsigned int v17 = (unsigned int *)(a8 + 8);
  if (v15 <= 2) {
    unsigned int v18 = (unsigned char *)(a8 + 8);
  }
  else {
    unsigned int v18 = v16;
  }
  unint64_t v19 = (2 * v15);
  if (v19 < 5) {
    goto LABEL_11;
  }
  unsigned int v20 = *v17;
  if (a10)
  {
    unsigned int v20 = bswap32(v20);
    *unsigned int v17 = v20;
  }
  unint64_t BytesAtOffset = IIOImageReadSession::getBytesAtOffset(a2, v16, a9 + v20, v19);
  LODWORD(v15) = *(_DWORD *)(a8 + 4);
  if (BytesAtOffset == 2 * v15)
  {
LABEL_11:
    BOOL v22 = v15 <= 1 && a7 == 0;
    int v23 = (const __CFAllocator **)MEMORY[0x1E4F1CF80];
    if (v22)
    {
      if (!v15) {
        goto LABEL_35;
      }
      uint64_t v36 = a1;
      uint64_t v37 = a6;
      unsigned __int8 v25 = 0;
      int v26 = 1;
    }
    else
    {
      CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
      unsigned __int8 v25 = Mutable;
      if (!*(_DWORD *)(a8 + 4))
      {
        if (!Mutable) {
          goto LABEL_35;
        }
        CGImageMetadataType v33 = kCGImageMetadataTypeArrayOrdered;
        goto LABEL_32;
      }
      uint64_t v36 = a1;
      uint64_t v37 = a6;
      int v26 = 3;
    }
    CGImageMetadataType type = v26;
    unint64_t v27 = 0;
    CFAllocatorRef v28 = *v23;
    do
    {
      unsigned int v29 = *(unsigned __int16 *)&v18[2 * v27];
      unsigned int v30 = bswap32(v29) >> 16;
      if (a10) {
        LOWORD(v29) = v30;
      }
      CFStringRef v31 = CFStringCreateWithFormat(v28, 0, @"%d", (unsigned __int16)v29);
      if ((a7 & 1) != 0 || (unint64_t v32 = *(unsigned int *)(a8 + 4), v32 >= 2))
      {
        CFArrayAppendValue(v25, v31);
        CFRelease(v31);
        CFStringRef v31 = 0;
        unint64_t v32 = *(unsigned int *)(a8 + 4);
      }
      ++v27;
    }
    while (v27 < v32);
    a1 = v36;
    a6 = v37;
    if (!v25)
    {
      if (!v31) {
        goto LABEL_35;
      }
      CGImageMetadataTagRef v34 = CGImageMetadataTagCreate(a3, a4, a5, type, v31);
      goto LABEL_33;
    }
    CGImageMetadataType v33 = type;
LABEL_32:
    CGImageMetadataTagRef v34 = CGImageMetadataTagCreate(a3, a4, a5, v33, v25);
    CFStringRef v31 = (CFStringRef)v25;
LABEL_33:
    CFRelease(v31);
    if (v34)
    {
      CGImageMetadataAddTagWithKey(a1, a6, v34);
      CFRelease(v34);
    }
  }
LABEL_35:
  if (v16)
  {
    free(v16);
  }
}

CGMutableImageMetadataRef CreateMetadataFromDatablock(IIOImageReadSession *a1, unsigned __int16 *a2, unint64_t a3, unsigned int a4, const __CFData *a5, char a6)
{
  uint64_t v138 = *MEMORY[0x1E4F143B8];
  if (!a1) {
    return 0;
  }
  unsigned __int16 v135 = 0;
  unsigned int MetadataLong = 0;
  unsigned int v128 = IIOImageReadSession::getSize(a1);
  CGMutableImageMetadataRef Mutable = CGImageMetadataCreateMutable();
  int v131 = a1;
  if (IIOImageReadSession::getBytesAtOffset(a1, &v135, a3, 2uLL) == 2)
  {
    unsigned int v9 = v135;
    if (a4)
    {
      unsigned int v9 = __rev16(v135);
      unsigned __int16 v135 = v9;
    }
    if ((unsigned __int16)(v9 - 255) >= 0xFF02u)
    {
      int v133 = (unsigned int *)malloc_type_calloc(v9, 0xCuLL, 0x2EA37F57uLL);
      if (v133)
      {
        unint64_t v10 = a3 + 2;
        unint64_t BytesAtOffset = IIOImageReadSession::getBytesAtOffset(a1, v133, v10, 12 * v135);
        unsigned int v12 = v135;
        if (BytesAtOffset != 12 * v135) {
          goto LABEL_26;
        }
        if (v135 && a4)
        {
          unsigned int v13 = 0;
          unint64_t v14 = v133;
          do
          {
            *(_WORD *)unint64_t v14 = bswap32(*(unsigned __int16 *)v14) >> 16;
            *((_WORD *)v14 + 1) = bswap32(*((unsigned __int16 *)v14 + 1)) >> 16;
            v14[1] = bswap32(v14[1]);
            ++v13;
            unsigned int v12 = v135;
            v14 += 3;
          }
          while (v13 < v135);
        }
        if ((a6 & 4) == 0
          || ((unint64_t v15 = IIOImageReadSession::getBytesAtOffset(a1, &MetadataLong, v10 + 12 * v12, 4uLL),
               unsigned int v16 = MetadataLong,
               v15 == 4)
            ? (BOOL v17 = MetadataLong == 0)
            : (BOOL v17 = 1),
              v17))
        {
          unint64_t v126 = 0;
        }
        else
        {
          if (a4)
          {
            unsigned int v16 = bswap32(MetadataLong);
            unsigned int MetadataLong = v16;
          }
          unint64_t v126 = v16;
        }
        if ((a6 & 8) != 0) {
          operator new();
        }
        if (a2 == (unsigned __int16 *)&tagdefsGPS && v135 < 2u)
        {
LABEL_26:
          unsigned int v18 = v133;
          goto LABEL_298;
        }
        if (a2 == (unsigned __int16 *)&tagdefsIFD0)
        {
          if (gInitializeTagKeyCacheIFD0Mutex != -1) {
            dispatch_once(&gInitializeTagKeyCacheIFD0Mutex, &__block_literal_global_11);
          }
          unint64_t v19 = &IFD0TagKeys;
        }
        else if (a2 == (unsigned __int16 *)&tagdefsIFD1)
        {
          if (gInitializeTagKeyCacheIFD1Mutex != -1) {
            dispatch_once(&gInitializeTagKeyCacheIFD1Mutex, &__block_literal_global_61);
          }
          unint64_t v19 = &IFD1TagKeys;
        }
        else if (a2 == (unsigned __int16 *)&tagdefsExif)
        {
          if (gInitializeTagKeyCacheExifMutex != -1) {
            dispatch_once(&gInitializeTagKeyCacheExifMutex, &__block_literal_global_64);
          }
          unint64_t v19 = &ExifTagKeys;
        }
        else
        {
          if (a2 != (unsigned __int16 *)&tagdefsGPS)
          {
            _cg_jpeg_mem_term("CreateMetadataFromDatablock", 2025, "*** ERROR: unexpected tagTable?\n");
            goto LABEL_297;
          }
          if (gInitializeTagKeyCacheGPSMutex != -1) {
            dispatch_once(&gInitializeTagKeyCacheGPSMutex, &__block_literal_global_67);
          }
          unint64_t v19 = &GPSTagKeys;
        }
        if (v135)
        {
          unsigned int v20 = 0;
          unsigned int v21 = 0;
          size_t size = 0;
          unsigned int v122 = 0;
          unsigned int v22 = 0;
          uint64_t v125 = *v19;
          CFAllocatorRef alloc = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
          int v23 = (unsigned __int16 *)v133;
          while (1)
          {
            int v24 = *a2;
            if (v24 == 0xFFFF) {
              goto LABEL_50;
            }
            uint64_t v25 = 0;
            int v26 = *v23;
            unint64_t v27 = a2 + 16;
            while (v24 != v26)
            {
              ++v25;
              int v24 = v27[12];
              v27 += 28;
              if (v24 == 0xFFFF) {
                goto LABEL_50;
              }
            }
            int v28 = *(v27 - 15);
            if (*(v27 - 15))
            {
              unsigned int v29 = v23[1];
              if (v29 != v28 && (v28 != 32771 || (unsigned __int16)(v29 - 3) >= 2u))
              {
                switch(*(v27 - 15))
                {
                  case 0x8001u:
                    if ((unsigned __int16)(v29 - 1) < 2u) {
                      goto LABEL_79;
                    }
                    goto LABEL_210;
                  case 0x8002u:
                    if ((v29 | 2) == 3) {
                      goto LABEL_79;
                    }
                    goto LABEL_210;
                  case 0x8004u:
                    if (v29 == 3 || v29 == 5) {
                      goto LABEL_79;
                    }
                    goto LABEL_210;
                  case 0x8005u:
                    if (v29 > 7) {
                      goto LABEL_210;
                    }
                    int v31 = 1 << v29;
                    int v32 = 134;
                    break;
                  case 0x8006u:
                    if ((unsigned __int16)(v29 - 3) < 3u) {
                      goto LABEL_79;
                    }
                    goto LABEL_210;
                  case 0x8007u:
                    if (v29 == 5 || v29 == 10) {
                      goto LABEL_79;
                    }
                    goto LABEL_210;
                  case 0x8008u:
                    if (v29 > 7) {
                      goto LABEL_210;
                    }
                    int v31 = 1 << v29;
                    int v32 = 150;
                    break;
                  case 0x8009u:
                    if (v29 > 0x12) {
                      goto LABEL_210;
                    }
                    int v31 = 1 << v29;
                    int v32 = 270352;
                    break;
                  case 0x800Au:
                    if (v29 == 1 || v29 == 7) {
                      goto LABEL_79;
                    }
                    goto LABEL_210;
                  default:
                    goto LABEL_210;
                }
                if ((v31 & v32) == 0)
                {
LABEL_210:
                  _cg_jpeg_mem_term("FindTagDef", 544, "*** tag '%04X'  type mismatch:   expected: %04X  got: %04X\n", v26, *(v27 - 15), v29);
                  goto LABEL_50;
                }
              }
            }
LABEL_79:
            int v33 = *(v27 - 14);
            if (*(v27 - 14))
            {
              int v34 = *((_DWORD *)v23 + 1);
              if (v34 == v33)
              {
                unsigned int v35 = *(v27 - 14);
              }
              else
              {
                if (v28 != 2 || v23[1] != 2) {
                  goto LABEL_50;
                }
                if (v33 == 2 && v34 == 1)
                {
                  unsigned int v35 = 2;
                }
                else
                {
                  if (v33 != 20 || v34 != 19) {
                    goto LABEL_50;
                  }
                  unsigned int v35 = 20;
                }
                uint64_t v25 = 0xFFFFFFFFLL;
              }
            }
            else
            {
              unsigned int v35 = 0;
            }
            uint64_t v36 = *((void *)v27 + 1);
            if (!v36) {
              ++v21;
            }
            if (v35 > v128) {
              ++v20;
            }
            if (v21 >= 0x2B)
            {
              LogError("CreateMetadataFromDatablock", 2059, "*** ERROR: corrupt metadata input - too many invalid tag-IDs\n");
              goto LABEL_242;
            }
            if (v20 >= 0x2B)
            {
              LogError("CreateMetadataFromDatablock", 2064, "*** ERROR: corrupt metadata input - too many invalid tag counts\n");
              goto LABEL_242;
            }
            uint64_t v37 = (const __CFString **)*((void *)v27 + 2);
            if ((unint64_t)v37 | v36)
            {
              if (!v37) {
                uint64_t v37 = (const __CFString **)*((void *)v27 + 1);
              }
              CFStringRef v38 = *v37;
            }
            else
            {
              CFStringRef v38 = 0;
            }
            unsigned __int8 v39 = (const __CFString **)*((void *)v27 - 2);
            if (v39) {
              CFStringRef v40 = *v39;
            }
            else {
              CFStringRef v40 = 0;
            }
            unsigned int v41 = (const __CFString **)*((void *)v27 - 1);
            if (v41) {
              CFStringRef v123 = *v41;
            }
            else {
              CFStringRef v123 = 0;
            }
            CFIndex v42 = 0;
            if ((v25 & 0x80000000) == 0 && v125) {
              CFIndex v42 = *(const void **)(v125 + 8 * v25);
            }
            if (a6)
            {
              if (v26 == 274)
              {
                unsigned int v46 = *((_DWORD *)v23 + 2);
                if (a4)
                {
                  if ((unsigned __int16)((bswap32(v46) >> 16) - 9) < 0xFFF8u)
                  {
                    int v47 = 256;
                    goto LABEL_145;
                  }
                }
                else if ((unsigned __int16)(v46 - 9) <= 0xFFF7u)
                {
                  int v47 = 1;
LABEL_145:
                  *((_DWORD *)v23 + 2) = v47;
                }
                if (v23[1] != 3 || *((_DWORD *)v23 + 1) > 0x28u) {
                  goto LABEL_50;
                }
                ReadMetadataShort((uint64_t)Mutable, v131, v40, v123, v38, v42, v33 != 1, (uint64_t)v23, 0, a4);
                int v26 = *v23;
              }
              if ((v26 & 0xFFFE) != 0x11A) {
                goto LABEL_152;
              }
              if (v23[1] == 5)
              {
                ReadMetadataRtnl((uint64_t)Mutable, v131, v40, v123, v38, v42, *(v27 - 14) != 1, (uint64_t)v23, a4);
                int v26 = *v23;
LABEL_152:
                if (v26 == 296 && v23[1] == 3) {
                  ReadMetadataShort((uint64_t)Mutable, v131, v40, v123, v38, v42, *(v27 - 14) != 1, (uint64_t)v23, 0, a4);
                }
                goto LABEL_50;
              }
              goto LABEL_50;
            }
            if ((a6 & 2) != 0)
            {
              if (*v23 <= 0x8768u)
              {
                if (v26 == 700) {
                  goto LABEL_50;
                }
                int v48 = 33723;
              }
              else
              {
                if (v26 == 34665 || v26 == 34853) {
                  goto LABEL_50;
                }
                int v48 = 37500;
              }
              if (v26 == v48) {
                goto LABEL_50;
              }
            }
            if (a2 == (unsigned __int16 *)&tagdefsIFD0 && v26 == 700)
            {
              unsigned int v122 = *((_DWORD *)v23 + 2);
              if (a4)
              {
                unsigned int v122 = bswap32(v122);
                *((_DWORD *)v23 + 2) = v122;
              }
              size_t size = *((unsigned int *)v23 + 1);
              goto LABEL_115;
            }
            if (*v23 > 0x8824u) {
              break;
            }
            if (v26 == 33723)
            {
              if (a2 == (unsigned __int16 *)&tagdefsIFD0 && (*((_DWORD *)v23 + 1) - 1) <= 0xF423F)
              {
                uint64_t v64 = v23[1];
                if (v64 > 0xA) {
                  goto LABEL_50;
                }
                size_t v65 = GetSizeForTiffType(v64) * *((unsigned int *)v23 + 1);
                CFMutableDictionaryRef v62 = (char *)malloc_type_malloc(v65, 0xC0BA3595uLL);
                if (!v62) {
                  goto LABEL_50;
                }
                unsigned int v66 = *((_DWORD *)v23 + 2);
                if (a4)
                {
                  unsigned int v66 = bswap32(v66);
                  *((_DWORD *)v23 + 2) = v66;
                }
                if (IIOImageReadSession::getBytesAtOffset(v131, v62, v66, v65) == v65)
                {
                  MetadataFromIPTCDatauint64_t buffer = CreateMetadataFromIPTCDatabuffer(v62, v65);
                  if (MetadataFromIPTCDatabuffer)
                  {
                    metadataSetUnspecifiedSource((uint64_t)Mutable, 2);
                    metadataSetSource((uint64_t)MetadataFromIPTCDatabuffer, 4);
                    CGImageMetadataMerge((uint64_t)Mutable, (uint64_t)MetadataFromIPTCDatabuffer, 0);
                    CFRelease(MetadataFromIPTCDatabuffer);
                  }
                }
                goto LABEL_222;
              }
              goto LABEL_115;
            }
            if (v26 != 34665) {
              goto LABEL_115;
            }
            unsigned int MetadataLong = ReadMetadataLong((uint64_t)Mutable, v131, v40, v123, v38, v42, 0, (uint64_t)v23, a4);
            MetadataFromDatablocuint64_t k = (const __CFDictionary *)CreateMetadataFromDatablock(v131, &tagdefsExif, MetadataLong, a4, a5, 0);
            CFDictionaryRef v50 = MetadataFromDatablock;
            if (MetadataFromDatablock)
            {
              CFDictionaryRef TopLevelTag = CGImageMetadataGetTopLevelTag(MetadataFromDatablock, @"http://ns.adobe.com/exif/1.0/", @"ISOSpeedRatings");
              if (TopLevelTag)
              {
                CFArrayRef v52 = (const __CFArray *)CGImageMetadataTagCopyValue(TopLevelTag);
                CFArrayRef v53 = v52;
                if (v52)
                {
                  CFTypeID v54 = CFGetTypeID(v52);
                  if (v54 == CFArrayGetTypeID() && CFArrayGetCount(v53) >= 1 && CFArrayGetCount(v53) == 1)
                  {
                    ValueAtIndedouble x = CFArrayGetValueAtIndex(v53, 0);
                    DefaultString = CGImageMetadataGetDefaultString(ValueAtIndex);
                    CGImageMetadataTagRef v57 = CGImageMetadataTagCreate(@"http://cipa.jp/exif/1.0/", @"exifEX", @"PhotographicSensitivity", kCGImageMetadataTypeString, DefaultString);
                    if (v57)
                    {
                      CGImageMetadataAddTag((uint64_t)v50, v57);
                      CFRelease(v57);
                    }
                  }
                  CFRelease(v53);
                }
              }
LABEL_142:
              CGImageMetadataMerge((uint64_t)Mutable, (uint64_t)v50, 0);
              CFRelease(v50);
            }
LABEL_50:
            ++v22;
            v23 += 6;
            if (v22 >= v135) {
              goto LABEL_242;
            }
          }
          if (v26 == 34853)
          {
            unsigned int MetadataLong = ReadMetadataLong((uint64_t)Mutable, v131, v40, v123, v38, v42, 0, (uint64_t)v23, a4);
            CFDictionaryRef v68 = (const __CFDictionary *)CreateMetadataFromDatablock(v131, &tagdefsGPS, MetadataLong, a4, a5, 0);
            CFDictionaryRef v50 = v68;
            if (!v68) {
              goto LABEL_50;
            }
            CFDictionaryRef v69 = CGImageMetadataGetTopLevelTag(v68, @"http://ns.adobe.com/exif/1.0/", @"GPSLatitude");
            CFDictionaryRef value = CGImageMetadataGetTopLevelTag(v50, @"http://ns.adobe.com/exif/1.0/", @"GPSLatitudeRef");
            CFDictionaryRef v124 = CGImageMetadataGetTopLevelTag(v50, @"http://ns.adobe.com/exif/1.0/", @"GPSLongitude");
            CFDictionaryRef v117 = CGImageMetadataGetTopLevelTag(v50, @"http://ns.adobe.com/exif/1.0/", @"GPSLongitudeRef");
            uint64_t Source = CGImageSourceGetSource((uint64_t)v69);
            uint64_t v71 = CGImageSourceGetSource((uint64_t)value);
            uint64_t v116 = CGImageSourceGetSource((uint64_t)v124);
            uint64_t v115 = CGImageSourceGetSource((uint64_t)v117);
            if (v69)
            {
              if (value)
              {
                CFStringRef v72 = CFStringCreateWithFormat(alloc, 0, @"%@%@", *(void *)(Source + 48), *(void *)(v71 + 48));
                if (v72)
                {
                  CGImageMetadataTagSetValue((uint64_t)v69, v72);
                  CGImageMetadataRemoveTag((uint64_t)v50, (uint64_t)value);
                  CFRelease(v72);
                }
              }
            }
            if (v124)
            {
              if (v117)
              {
                CFStringRef v73 = CFStringCreateWithFormat(alloc, 0, @"%@%@", *(void *)(v116 + 48), *(void *)(v115 + 48));
                if (v73)
                {
                  CGImageMetadataTagSetValue((uint64_t)v124, v73);
                  CGImageMetadataRemoveTag((uint64_t)v50, (uint64_t)v117);
                  CFRelease(v73);
                }
              }
            }
            goto LABEL_142;
          }
          if (v26 == 37500 && *((_DWORD *)v23 + 1) >= 5u)
          {
            unsigned int v58 = *((_DWORD *)v23 + 2);
            unsigned int v59 = bswap32(v58);
            if (a4) {
              unint64_t v60 = v59;
            }
            else {
              unint64_t v60 = v58;
            }
            unint64_t v61 = GetSizeForTiffType(v23[1]) * *((unsigned int *)v23 + 1);
            if (!v61) {
              goto LABEL_50;
            }
            if (v61 >= v128)
            {
              _cg_jpeg_mem_term("CreateMetadataFromDatablock", 2221, "*** ERROR: Bad makerNoteSize: %d >= fileSize: %d\n", v61, v128);
              goto LABEL_50;
            }
            CFMutableDictionaryRef v62 = (char *)malloc_type_calloc(v61, 1uLL, 0x3A8858BAuLL);
            if (v62)
            {
              unint64_t v63 = IIOImageReadSession::getBytesAtOffset(v131, v62, v60, v61);
              if (v63 != v61)
              {
                _cg_jpeg_mem_term("CreateMetadataFromDatablock", 2226, "*** ERROR: failed to read makerNote (expected: %d, got: %d bytes)\n", v61, v63);
                goto LABEL_50;
              }
              if (v61 < 0x20)
              {
                if (v61 >= 0xA) {
                  goto LABEL_215;
                }
                goto LABEL_219;
              }
              if (!strncmp(v62 + 4, "iOS ", 4uLL)) {
                goto LABEL_222;
              }
LABEL_215:
              if (*(void *)v62 == 0x4F6920656C707041 && *((_WORD *)v62 + 4) == 83)
              {
                PropertiesFromAppleMakerNote = (CFTypeRef *)CreatePropertiesFromAppleMakerNote((unsigned __int8 *)v62, v61);
                if (PropertiesFromAppleMakerNote)
                {
                  unint64_t v84 = (const void *)*((void *)Mutable + 6);
                  if (v84) {
                    CFRelease(v84);
                  }
                  *((void *)Mutable + 6) = CFRetain(PropertiesFromAppleMakerNote[1]);
                  (*((void (**)(CFTypeRef *))*PropertiesFromAppleMakerNote + 1))(PropertiesFromAppleMakerNote);
                }
              }
              else
              {
LABEL_219:
                long long v136 = 0uLL;
                uint64_t v137 = 0;
                IIODictionary::IIODictionary((IIODictionary *)&v136);
                uint64_t v80 = IIOImageSource::cf(v131);
                call_RAWCamera_readMakerNoteProps(v80, (IIODictionary *)&v136, v60, v61, a4);
                int v81 = (const void *)*((void *)Mutable + 6);
                if (v81) {
                  CFRelease(v81);
                }
                *((void *)Mutable + 6) = CFRetain(*((CFTypeRef *)&v136 + 1));
                IIODictionary::~IIODictionary((IIODictionary *)&v136);
              }
LABEL_222:
              int v82 = (unsigned __int8 *)v62;
LABEL_238:
              free(v82);
              goto LABEL_50;
            }
            goto LABEL_50;
          }
LABEL_115:
          char v43 = *(void (**)(CGMutableImageMetadataRef, IIOImageReadSession *, const __CFString *, const __CFString *, const __CFString *, const void *, unsigned __int16 *, void, int))v27;
          if (!*(void *)v27 && !v38 && !v40) {
            goto LABEL_50;
          }
          if (v26 == 274)
          {
            unsigned int v44 = *((_DWORD *)v23 + 2);
            if (a4)
            {
              if ((unsigned __int16)((bswap32(v44) >> 16) - 9) >= 0xFFF8u) {
                goto LABEL_198;
              }
              int v45 = 256;
            }
            else
            {
              if ((unsigned __int16)(v44 - 9) > 0xFFF7u) {
                goto LABEL_198;
              }
              int v45 = 1;
            }
            *((_DWORD *)v23 + 2) = v45;
          }
LABEL_198:
          if (v43)
          {
            LOBYTE(v114) = a4;
            v43(Mutable, v131, v40, v123, v38, v42, v23, 0, v114);
          }
          else
          {
            unsigned int v74 = *((_DWORD *)v23 + 1);
            if ((v74 - 1) >> 4 > 0x270 || v23[1] != 2)
            {
              switch(v23[1])
              {
                case 1u:
                  if (v74 <= 0x28) {
                    ReadMetadataByte((uint64_t)Mutable, v131, v40, v123, v38, v42, v33 != 1, (uint64_t)v23, 0, a4);
                  }
                  break;
                case 3u:
                  if (v74 <= 0x28) {
                    ReadMetadataShort((uint64_t)Mutable, v131, v40, v123, v38, v42, v33 != 1, (uint64_t)v23, 0, a4);
                  }
                  break;
                case 4u:
                  if (v74 <= 0x28) {
                    ReadMetadataLong((uint64_t)Mutable, v131, v40, v123, v38, v42, v33 != 1, (uint64_t)v23, a4);
                  }
                  break;
                case 5u:
                  ReadMetadataRtnl((uint64_t)Mutable, v131, v40, v123, v38, v42, v33 != 1, (uint64_t)v23, a4);
                  break;
                case 0xAu:
                  ReadMetadataSRtnl((uint64_t)Mutable, v131, v40, v123, v38, v42, v33 != 1, (uint64_t)v23, a4);
                  break;
                default:
                  goto LABEL_50;
              }
              goto LABEL_50;
            }
            ASCIIString = (unsigned __int8 *)ReadAndCreateASCIIString(v131, v23, 0, a4);
            CGImageMetadataTagRef v76 = ASCIIString;
            if (ASCIIString)
            {
              if (*ASCIIString && !onlyspaces(ASCIIString))
              {
                int v77 = stringType(v76, *((_DWORD *)v23 + 1));
                if (v77 == 1)
                {
                  CFStringEncoding v78 = 134217984;
LABEL_234:
                  CFStringRef valuea = CFStringCreateWithCString(alloc, (const char *)v76, v78);
                  if (valuea)
                  {
                    CGImageMetadataTagRef v85 = CGImageMetadataTagCreate(v40, v123, v38, kCGImageMetadataTypeString, valuea);
                    CFRelease(valuea);
                    if (v85)
                    {
                      CGImageMetadataAddTagWithKey((uint64_t)Mutable, v42, v85);
                      CFRelease(v85);
                    }
                  }
                }
                else if (!v77)
                {
                  CFStringEncoding v78 = 1536;
                  goto LABEL_234;
                }
              }
              int v82 = v76;
              goto LABEL_238;
            }
          }
          goto LABEL_50;
        }
        unsigned int v122 = 0;
        size_t size = 0;
LABEL_242:
        if (!v126) {
          goto LABEL_286;
        }
        if (IIOImageReadSession::getBytesAtOffset(v131, &v135, v126, 2uLL) != 2) {
          goto LABEL_297;
        }
        unsigned int v86 = v135;
        if (a4)
        {
          unsigned int v86 = __rev16(v135);
          unsigned __int16 v135 = v86;
        }
        unsigned int v18 = v133;
        if (v86 > 0xFE) {
          goto LABEL_298;
        }
        if (!v86) {
          goto LABEL_286;
        }
        double v87 = (unsigned int *)reallocf(v133, 12 * v86);
        if (!v87) {
          return Mutable;
        }
        int v133 = v87;
        unint64_t v88 = IIOImageReadSession::getBytesAtOffset(v131, v87, v126 + 2, 12 * v135);
        unsigned int v89 = v135;
        if (v88 != 12 * v135) {
          goto LABEL_297;
        }
        if (v135 && a4)
        {
          unsigned int v90 = 0;
          unsigned __int8 v91 = v133;
          do
          {
            *(_WORD *)unsigned __int8 v91 = bswap32(*(unsigned __int16 *)v91) >> 16;
            *((_WORD *)v91 + 1) = bswap32(*((unsigned __int16 *)v91 + 1)) >> 16;
            *(int8x8_t *)(v91 + 1) = vrev32_s8(*(int8x8_t *)(v91 + 1));
            ++v90;
            v91 += 3;
          }
          while (v90 < v89);
        }
        else if (!v135)
        {
          goto LABEL_286;
        }
        unsigned int v92 = 0;
        unsigned int v93 = 0;
        unsigned int v94 = 0;
        CFAllocatorRef v95 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
        uint64_t v96 = v133 + 2;
        while (1)
        {
          int v97 = *((unsigned __int16 *)v96 - 4);
          if (v97 == 514)
          {
            unsigned int v93 = *v96;
            CFStringRef v98 = CFStringCreateWithFormat(v95, 0, @"%d", *v96);
            if (v98)
            {
              CGImageMetadataTagRef v99 = CGImageMetadataTagCreate(@"http://ns.apple.com/ImageIO/1.0/", @"iio", @"JPEGInterchangeFormatLength", kCGImageMetadataTypeString, v98);
              goto LABEL_263;
            }
          }
          else if (v97 == 513)
          {
            unsigned int v92 = *v96 + 12;
            CFStringRef v98 = CFStringCreateWithFormat(v95, 0, @"%d", v92);
            if (v98)
            {
              CGImageMetadataTagRef v99 = CGImageMetadataTagCreate(@"http://ns.apple.com/ImageIO/1.0/", @"iio", @"JPEGInterchangeFormat", kCGImageMetadataTypeString, v98);
LABEL_263:
              CGImageMetadataTagRef v100 = v99;
              if (v99)
              {
                CGImageMetadataAddTag((uint64_t)Mutable, v99);
                CFRelease(v100);
              }
              CFRelease(v98);
            }
          }
          ++v94;
          v96 += 3;
          if (v94 >= v135)
          {
            if (v93 && v92)
            {
              WORD4(v136) = 0;
              *(void *)&long long v136 = 0;
              if (IIOImageReadSession::getBytesAtOffset(v131, &v136, v92 - 12, 2uLL) != 2) {
                goto LABEL_297;
              }
              if (bswap32((unsigned __int16)v136) >> 16 == 65496)
              {
                unsigned int v101 = v92 - 10;
                while (IIOImageReadSession::getBytesAtOffset(v131, &v136, v101, 0xAuLL) == 10)
                {
                  unsigned int v102 = __rev16((unsigned __int16)v136);
                  if (v102 == 65472)
                  {
                    unsigned int v103 = *(unsigned __int16 *)((char *)&v136 + 5);
                    CFStringRef v104 = CFStringCreateWithFormat(v95, 0, @"%zu", __rev16(*(unsigned __int16 *)((char *)&v136 + 7)));
                    CFStringRef v105 = CFStringCreateWithFormat(v95, 0, @"%zu", __rev16(v103));
                    if (v104)
                    {
                      CGImageMetadataTagRef v106 = CGImageMetadataTagCreate(@"http://ns.apple.com/ImageIO/1.0/", @"iio", @"JPEGInterchangeFormatWidth", kCGImageMetadataTypeString, v104);
                      if (v106)
                      {
                        CGImageMetadataAddTag((uint64_t)Mutable, v106);
                        CFRelease(v106);
                      }
                      CFRelease(v104);
                    }
                    if (v105)
                    {
                      CGImageMetadataTagRef v107 = CGImageMetadataTagCreate(@"http://ns.apple.com/ImageIO/1.0/", @"iio", @"JPEGInterchangeFormatHeight", kCGImageMetadataTypeString, v105);
                      if (v107)
                      {
                        CGImageMetadataAddTag((uint64_t)Mutable, v107);
                        CFRelease(v107);
                      }
                      CFRelease(v105);
                    }
                    goto LABEL_286;
                  }
                  v101 += (bswap32(WORD1(v136)) >> 16) + 2;
                  if (v102 == 65498) {
                    goto LABEL_286;
                  }
                }
LABEL_297:
                unsigned int v18 = v133;
LABEL_298:
                free(v18);
                return Mutable;
              }
            }
LABEL_286:
            metadataSetUnspecifiedSource((uint64_t)Mutable, 2);
            int v108 = 0;
            if (v122 && size)
            {
              int v108 = (char *)malloc_type_malloc(size, 0xE202211FuLL);
              if (!v108) {
                goto LABEL_297;
              }
              if (IIOImageReadSession::getBytesAtOffset(v131, v108, v122, size) == size)
              {
                MetadataFromXMPBuffer = (const void *)CreateMetadataFromXMPBuffer(v108, size);
                if (MetadataFromXMPBuffer)
                {
                  CGImageMetadataMerge((uint64_t)Mutable, (uint64_t)MetadataFromXMPBuffer, 0);
                  CFRelease(MetadataFromXMPBuffer);
                }
                goto LABEL_292;
              }
            }
            else
            {
LABEL_292:
              if (a5)
              {
                BytePtr = (const char *)CFDataGetBytePtr(a5);
                CFIndex Length = CFDataGetLength(a5);
                MetadataFromXMPSidecarunint64_t Data = (const void *)CreateMetadataFromXMPSidecarData(BytePtr, Length);
                if (MetadataFromXMPSidecarData)
                {
                  CGImageMetadataMerge((uint64_t)Mutable, (uint64_t)MetadataFromXMPSidecarData, 0);
                  CFRelease(MetadataFromXMPSidecarData);
                }
              }
              if (!v108) {
                goto LABEL_297;
              }
            }
            free(v108);
            goto LABEL_297;
          }
        }
      }
    }
  }
  return Mutable;
}

void sub_1885E3BB8(_Unwind_Exception *a1)
{
  IIODictionary::~IIODictionary((IIODictionary *)(v1 - 120));
  _Unwind_Resume(a1);
}

__CFArray *ReadMetadataLong(uint64_t a1, IIOImageReadSession *a2, const __CFString *a3, const __CFString *a4, const __CFString *a5, const void *a6, int a7, uint64_t a8, char a9)
{
  size_t v16 = *(unsigned int *)(a8 + 4);
  if (v16 < 2)
  {
    BOOL v17 = 0;
  }
  else
  {
    BOOL v17 = (unsigned int *)malloc_type_calloc(v16, 4uLL, 0x100004052888210uLL);
    LODWORD(v16) = *(_DWORD *)(a8 + 4);
  }
  unsigned int v18 = (unsigned int *)(a8 + 8);
  if (v16 <= 1) {
    unint64_t v19 = (unsigned int *)(a8 + 8);
  }
  else {
    unint64_t v19 = v17;
  }
  unint64_t BytesAtOffset = (4 * v16);
  if (BytesAtOffset >= 5)
  {
    unsigned int v21 = *v18;
    if (a9)
    {
      unsigned int v21 = bswap32(v21);
      unsigned int *v18 = v21;
    }
    unint64_t BytesAtOffset = IIOImageReadSession::getBytesAtOffset(a2, v17, v21, BytesAtOffset);
  }
  if (a3 || a4 || a5)
  {
    unsigned int v24 = *(_DWORD *)(a8 + 4);
    if (BytesAtOffset == 4 * v24)
    {
      CFStringRef v41 = a4;
      uint64_t v25 = (const __CFAllocator **)MEMORY[0x1E4F1CF80];
      if (v24 > 1 || a7)
      {
        CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
        int v23 = Mutable;
        if (!*(_DWORD *)(a8 + 4))
        {
          if (!Mutable) {
            goto LABEL_42;
          }
          uint64_t v37 = a1;
          CFStringRef v38 = a6;
          CGImageMetadataType v34 = kCGImageMetadataTypeArrayOrdered;
          goto LABEL_38;
        }
        CFStringRef name = a5;
        uint64_t v37 = a1;
        CFStringRef v38 = a6;
        int v26 = 3;
      }
      else
      {
        if (!v24) {
          goto LABEL_41;
        }
        CFStringRef name = a5;
        uint64_t v37 = a1;
        CFStringRef v38 = a6;
        int v23 = 0;
        int v26 = 1;
      }
      CGImageMetadataType type = v26;
      unint64_t v28 = 0;
      CFAllocatorRef v29 = *v25;
      do
      {
        LODWORD(v30) = v19[v28];
        unsigned int v31 = bswap32(v30);
        if (a9) {
          uint64_t v30 = v31;
        }
        else {
          uint64_t v30 = v30;
        }
        CFStringRef v32 = CFStringCreateWithFormat(v29, 0, @"%d", v30);
        if ((a7 & 1) != 0 || (unint64_t v33 = *(unsigned int *)(a8 + 4), v33 >= 2))
        {
          CFArrayAppendValue(v23, v32);
          CFRelease(v32);
          CFStringRef v32 = 0;
          unint64_t v33 = *(unsigned int *)(a8 + 4);
        }
        ++v28;
      }
      while (v28 < v33);
      if (v23)
      {
        a5 = name;
        CGImageMetadataType v34 = type;
LABEL_38:
        CGImageMetadataTagRef v35 = CGImageMetadataTagCreate(a3, v41, a5, v34, v23);
        CFStringRef v32 = (CFStringRef)v23;
LABEL_39:
        CFRelease(v32);
        if (v35)
        {
          CGImageMetadataAddTagWithKey(v37, v38, v35);
          CFRelease(v35);
        }
        goto LABEL_41;
      }
      if (v32)
      {
        CGImageMetadataTagRef v35 = CGImageMetadataTagCreate(a3, v41, name, type, v32);
        goto LABEL_39;
      }
    }
LABEL_41:
    int v23 = 0;
    goto LABEL_42;
  }
  unsigned int v22 = bswap32(*v19);
  if (a9) {
    int v23 = (__CFArray *)v22;
  }
  else {
    int v23 = (__CFArray *)*v19;
  }
LABEL_42:
  if (v17) {
    free(v17);
  }
  return v23;
}

void CGImageMetadataAddTagWithKey(uint64_t a1, const void *a2, const void *a3)
{
  if (a1 && a3)
  {
    if (a2) {
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 24), a2, a3);
    }
    else {
      CGImageMetadataAddTag(a1, a3);
    }
  }
}

void CGImageReadCreateWithDataForMetadata()
{
}

void sub_1885E3F08(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10F1C405FDDC6B3);
  _Unwind_Resume(a1);
}

uint64_t IIOImageRead::IIOImageRead(uint64_t a1, const UInt8 *a2, CFIndex a3, int a4, char a5)
{
  *(void *)a1 = &unk_1ED4DF1B0;
  *(void *)(a1 + 152) = 0;
  *(void *)(a1 + 248) = 0;
  *(void *)(a1 + 240) = a1 + 248;
  *(void *)(a1 + 160) = 0;
  *(void *)(a1 + 168) = 0;
  *(void *)(a1 + 256) = 0;
  *(void *)(a1 + 296) = 0;
  *(void *)(a1 + 304) = 0;
  *(void *)(a1 + 288) = 0;
  IIOImageRead::setup(a1, a4);
  *(unsigned char *)(a1 + 64) = a5;
  *(unsigned char *)(a1 + 65) = a5 ^ 1;
  CFDataRef v9 = CFDataCreateWithBytesNoCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a2, a3, (CFAllocatorRef)*MEMORY[0x1E4F1CFA0]);
  *(void *)(a1 + 32) = v9;
  if ((gIIODebugFlags & 0x80000000000) != 0) {
    ImageIOLog("D   %s:%d CFDataCreateWithBytesNoCopy %p\n", "IIOImageRead", 541, v9);
  }
  *(void *)(a1 + 80) = a3;
  return a1;
}

void sub_1885E4034(_Unwind_Exception *a1)
{
  int v7 = *v5;
  if (*v5)
  {
    *(void *)(v1 + 296) = v7;
    operator delete(v7);
  }
  std::__tree<std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>>>::destroy(v2, *v4);
  uint64_t v8 = *v3;
  if (*v3)
  {
    *(void *)(v1 + 160) = v8;
    operator delete(v8);
  }
  _Unwind_Resume(a1);
}

CGImageMetadataRef CGImageMetadataCreateFromXMPData(CFDataRef data)
{
  CFDataRef v1 = data;
  if (data) {
    CFDataGetLength(data);
  }
  kdebug_trace();
  IIOInitDebugFlags();
  if ((~(_WORD)gIIODebugFlags & 0x3000) == 0) {
    ImageIODebugOptions(3, "A", "CGImageMetadataCreateFromXMPData", 0, 0, -1, 0);
  }
  if (v1)
  {
    CFTypeID v2 = CFGetTypeID(v1);
    if (v2 == CFDataGetTypeID() && (unint64_t Length = CFDataGetLength(v1), Length >= 0x29))
    {
      unint64_t v4 = Length;
      BytePtr = (const char *)CFDataGetBytePtr(v1);
      uint64_t v6 = 29;
      if (!strncmp(BytePtr, kMainXMPSignatureString[0], 0x1DuLL)
        || (uint64_t v6 = 0, v1 = 0, !strncmp(BytePtr, kMainXMPPlainString[0], 0x21uLL)))
      {
        uint64_t MetadataFromXMPBuffer = CreateMetadataFromXMPBuffer(&BytePtr[v6], v4 - v6);
        CFDataRef v1 = (CFDataRef)MetadataFromXMPBuffer;
        if (MetadataFromXMPBuffer)
        {
          CFDictionaryRef v8 = *(const __CFDictionary **)(MetadataFromXMPBuffer + 24);
          if (v8) {
            CFDictionaryGetCount(v8);
          }
        }
      }
    }
    else
    {
      CFDataRef v1 = 0;
    }
  }
  kdebug_trace();
  return v1;
}

uint64_t CreateMetadataFromXMPBuffer(const char *a1, uint64_t a2)
{
  return CreateMetadataFromXMPBufferInternal(a1, a2, 0);
}

uint64_t _cg_png_get_text_entry(uint64_t a1, uint64_t a2, unsigned int a3, void *a4, void *a5, void *a6)
{
  if (a1 && a2 && *(_DWORD *)(a2 + 148) > a3)
  {
    if (a4) {
      *a4 = *(void *)(*(void *)(a2 + 160) + 56 * a3 + 8);
    }
    if (a5) {
      *a5 = *(void *)(*(void *)(a2 + 160) + 56 * a3 + 24);
    }
    uint64_t v6 = *(void *)(a2 + 160);
    if (a6) {
      *a6 = *(void *)(v6 + 56 * a3 + 32);
    }
    return *(void *)(v6 + 56 * a3 + 16);
  }
  else
  {
    if (a4) {
      *a4 = 0;
    }
    if (a5) {
      *a5 = 0;
    }
    uint64_t result = 0;
    if (a6) {
      *a6 = 0;
    }
  }
  return result;
}

void IIOMetadata_Tag::setPrefix(IIOMetadata_Tag *this, const __CFString *a2)
{
  CFTypeID v2 = (const void *)*((void *)this + 3);
  *((void *)this + 3) = CFStringCreateCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a2);
  if (v2)
  {
    CFRelease(v2);
  }
}

void IIOMetadata_Tag::setNamespace(IIOMetadata_Tag *this, const __CFString *a2)
{
  CFTypeID v2 = (const void *)*((void *)this + 2);
  *((void *)this + 2) = CFStringCreateCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a2);
  if (v2)
  {
    CFRelease(v2);
  }
}

void CGImageMetadataTagSetPrefix(uint64_t a1, const __CFString *a2)
{
  if (a1)
  {
    CFTypeID v2 = *(IIOMetadata_Tag **)(a1 + 24);
    if (v2) {
      IIOMetadata_Tag::setPrefix(v2, a2);
    }
  }
}

void CGImageMetadataTagSetNamespace(uint64_t a1, const __CFString *a2)
{
  if (a1)
  {
    CFTypeID v2 = *(IIOMetadata_Tag **)(a1 + 24);
    if (v2) {
      IIOMetadata_Tag::setNamespace(v2, a2);
    }
  }
}

uint64_t IIOMetadata_Tag::setValue(IIOMetadata_Tag *this, const __CFString *cf)
{
  if (!cf) {
    return 0;
  }
  CFTypeID v4 = CFGetTypeID(cf);
  if (v4 != CFStringGetTypeID())
  {
    CFTypeID v5 = CFGetTypeID(cf);
    if (v5 != CFNumberGetTypeID())
    {
      CFTypeID v6 = CFGetTypeID(cf);
      if (v6 != CFBooleanGetTypeID())
      {
        CFTypeID v7 = CFGetTypeID(cf);
        if (v7 != CFDictionaryGetTypeID())
        {
          CFTypeID v8 = CFGetTypeID(cf);
          if (v8 != CFArrayGetTypeID()) {
            return 0;
          }
        }
      }
    }
  }
  if (!*((unsigned char *)this + 64))
  {
    LogMetadata("setValue", 245, "Attempting to modify a tag from an immutable CGImageMetadataRef. Create a new CGImageMetadataTagRef or use CGImageMetadataCreateMutableCopy.\n");
    return 0;
  }
  CFDataRef v9 = (const void *)*((void *)this + 6);
  CFTypeID v10 = CFGetTypeID(cf);
  if (v10 == CFNumberGetTypeID() || (CFTypeID v11 = CFGetTypeID(cf), v11 == CFBooleanGetTypeID()))
  {
    CFStringRef SimpleStringFromCFValue = (void *)CGImageMetadataCreateSimpleStringFromCFValue(cf, 1);
    if (!SimpleStringFromCFValue)
    {
      _cg_jpeg_mem_term("setValue", 231, "*** ERROR: failed to create a CFString from 'value'\n");
      return 0;
    }
  }
  else
  {
    CFStringRef SimpleStringFromCFValue = (void *)CFRetain(cf);
  }
  *((void *)this + 6) = SimpleStringFromCFValue;
  if (v9) {
    CFRelease(v9);
  }
  return 1;
}

uint64_t CGImageMetadataTagSetValue(uint64_t a1, const __CFString *a2)
{
  if (a1 && (CFTypeID v2 = *(IIOMetadata_Tag **)(a1 + 24)) != 0) {
    return IIOMetadata_Tag::setValue(v2, a2);
  }
  else {
    return 0;
  }
}

void PNGReadPlugin::AddTextChunkToProperties(PNGReadPlugin *this, IIODictionary *a2, UInt8 *bytes, char *a4, unsigned int a5)
{
  if (!bytes) {
    return;
  }
  if (a4) {
    a5 = a4;
  }
  CFAllocatorRef v9 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFIndex v10 = a5;
  CFStringRef v11 = CFStringCreateWithBytes((CFAllocatorRef)*MEMORY[0x1E4F1CF80], bytes, a5, 0x8000100u, 0);
  if (v11)
  {
    CFStringRef v12 = v11;
    if (CFStringGetLength(v11)) {
      goto LABEL_9;
    }
    CFRelease(v12);
  }
  CFStringRef v12 = CFStringCreateWithBytes(v9, bytes, v10, 0x600u, 0);
  if (!v12) {
    return;
  }
LABEL_9:
  if (!strncmp((const char *)a2, "Author", 6uLL))
  {
    unsigned int v13 = &kCGImagePropertyPNGAuthor;
  }
  else if (!strncmp((const char *)a2, "Comment", 7uLL))
  {
    unsigned int v13 = &kCGImagePropertyPNGComment;
  }
  else if (!strncmp((const char *)a2, "Copyright", 9uLL))
  {
    unsigned int v13 = &kCGImagePropertyPNGCopyright;
  }
  else if (!strncmp((const char *)a2, "CreationTime", 0xCuLL))
  {
    unsigned int v13 = &kCGImagePropertyPNGCreationTime;
  }
  else if (!strncmp((const char *)a2, "Description", 0xBuLL))
  {
    unsigned int v13 = &kCGImagePropertyPNGDescription;
  }
  else if (!strncmp((const char *)a2, "Disclaimer", 0xAuLL))
  {
    unsigned int v13 = &kCGImagePropertyPNGDisclaimer;
  }
  else if (!strncmp((const char *)a2, "ModificationTime", 0x10uLL))
  {
    unsigned int v13 = &kCGImagePropertyPNGModificationTime;
  }
  else if (!strncmp((const char *)a2, "Software", 8uLL))
  {
    unsigned int v13 = &kCGImagePropertyPNGSoftware;
  }
  else if (!strncmp((const char *)a2, "Source", 6uLL))
  {
    unsigned int v13 = &kCGImagePropertyPNGSource;
  }
  else if (!strncmp((const char *)a2, "Title", 5uLL))
  {
    unsigned int v13 = &kCGImagePropertyPNGTitle;
  }
  else
  {
    if (strncmp((const char *)a2, "Warning", 7uLL))
    {
LABEL_34:
      _cg_jpeg_mem_term("AddTextChunkToProperties", 1069, "PNG - not handling:      key: %s\n", (const char *)a2);
      _cg_jpeg_mem_term("AddTextChunkToProperties", 1070, "                        text: %s\n", (const char *)bytes);
      goto LABEL_35;
    }
    unsigned int v13 = &kCGImagePropertyPNGWarning;
  }
  if (!*v13) {
    goto LABEL_34;
  }
  IIODictionary::setObjectForKeyGroup(this, v12, *v13, @"{PNG}");
LABEL_35:

  CFRelease(v12);
}

CGImageMetadataType CGImageMetadataTagGetType(CGImageMetadataTagRef tag)
{
  IIOInitDebugFlags();
  if ((~(_WORD)gIIODebugFlags & 0x3000) == 0) {
    ImageIODebugOptions(3, "A", "CGImageMetadataTagGetType", 0, 0, -1, 0);
  }
  if (tag && (uint64_t v2 = *((void *)tag + 3)) != 0) {
    return *(_DWORD *)(v2 + 40);
  }
  else {
    return -1;
  }
}

uint64_t CGImageMetadataTagGetPrefix(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = *(void *)(result + 24);
    if (v1) {
      return *(void *)(v1 + 24);
    }
    else {
      return 0;
    }
  }
  return result;
}

uint64_t CGImageMetadataTagGetNamespace(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = *(void *)(result + 24);
    if (v1) {
      return *(void *)(v1 + 16);
    }
    else {
      return 0;
    }
  }
  return result;
}

uint64_t IIOTextureHandler::ReleaseTextureInfo(uint64_t this, void *a2)
{
  if (this) {
    return (*(uint64_t (**)(void))(*(void *)this + 8))();
  }
  return this;
}

uint64_t __CGImageSourceGetTypeID_block_invoke()
{
  uint64_t result = _CFRuntimeRegisterClass();
  CGImageSourceGetTypeID::id = result;
  return result;
}

uint64_t __CGImageReadSessionGetTypeID_block_invoke()
{
  uint64_t result = _CFRuntimeRegisterClass();
  CGImageReadSessionGetTypeID::id = result;
  return result;
}

uint64_t __CGImageReadGetTypeID_block_invoke()
{
  uint64_t result = _CFRuntimeRegisterClass();
  CGImageReadGetTypeID::id = result;
  return result;
}

uint64_t __CGImagePlusGetTypeID_block_invoke()
{
  uint64_t result = _CFRuntimeRegisterClass();
  CGImagePlusGetTypeID::id = result;
  return result;
}

uint64_t __CGImageMetadataGetTypeID_block_invoke()
{
  uint64_t result = _CFRuntimeRegisterClass();
  CGImageMetadataGetTypeID::id = result;
  return result;
}

uint64_t PNGWritePlugin::writeEpilogue(PNGWritePlugin *this, IIOImagePixelDataProvider *a2, IIODictionary *a3)
{
  if ((gIIODebugFlags & 0x30000) != 0) {
    ImageIOLog("    writeEpilogue\n", a2, a3);
  }
  CFTypeID v5 = (uint64_t *)((char *)this + 40);
  CFTypeID v4 = (void (**)(void))*((void *)this + 5);
  if (v4)
  {
    uint64_t v8 = *((void *)this + 6);
    CFTypeID v7 = (void **)((char *)this + 48);
    uint64_t v6 = v8;
    if (v8)
    {
      _cg_png_write_end(v4, v6);
      if (*v7) {
        CFAllocatorRef v9 = v7;
      }
      else {
        CFAllocatorRef v9 = 0;
      }
      _cg_png_destroy_write_struct(v5, v9);
      *CFTypeID v5 = 0;
      v5[1] = 0;
    }
  }
  return 0;
}

void (**png_write_IEND(uint64_t a1))(void)
{
  uint64_t result = _cg_png_write_complete_chunk((void (**)(void))a1, 1229278788, 0, 0);
  *(_DWORD *)(a1 + 76) |= 0x10u;
  return result;
}

void _cg_png_destroy_write_struct(uint64_t *a1, void **a2)
{
  if (a1)
  {
    uint64_t v3 = *a1;
    if (*a1)
    {
      _cg_png_destroy_info_struct(*a1, a2);
      *a1 = 0;
      if ((*(unsigned char *)(v3 + 80) & 2) != 0) {
        deflateEnd((z_streamp)(v3 + 96));
      }
      png_free_buffer_list(v3, (void **)(v3 + 208));
      png_free(v3, *(void **)(v3 + 328));
      *(void *)(v3 + 328) = 0;
      png_free(v3, *(void **)(v3 + 320));
      png_free(v3, *(void **)(v3 + 336));
      png_free(v3, *(void **)(v3 + 344));
      *(void *)(v3 + 320) = 0;
      *(void *)(v3 + 336) = 0;
      *(void *)(v3 + 344) = 0;
      png_free(v3, *(void **)(v3 + 744));
      *(void *)(v3 + 744) = 0;
      png_destroy_png_struct((void *)v3);
    }
  }
}

void png_free_buffer_list(uint64_t a1, void **a2)
{
  uint64_t v3 = *a2;
  if (v3)
  {
    *a2 = 0;
    do
    {
      CFTypeID v5 = (void *)*v3;
      png_free(a1, v3);
      uint64_t v3 = v5;
    }
    while (v5);
  }
}

uint64_t PNGWritePlugin::writePrologue(PNGWritePlugin *this, IIOImagePixelDataProvider *a2, IIODictionary *a3)
{
  CFDataRef data = 0;
  unsigned int AlphaInfo = IIOImagePixelDataProvider::getAlphaInfo(a2);
  unsigned int v89 = AlphaInfo;
  if (AlphaInfo)
  {
    if (AlphaInfo < 5)
    {
      BOOL v7 = 1;
      BOOL v8 = 1;
      goto LABEL_7;
    }
    int v9 = *((unsigned __int8 *)this + 121);
    BOOL v7 = 1;
  }
  else
  {
    int v9 = *((unsigned __int8 *)this + 121);
    BOOL v7 = *((unsigned char *)this + 121) == 0;
  }
  BOOL v8 = v9 == 0;
LABEL_7:
  BOOL v91 = v8;
  double valuePtr = 0.0;
  IIOImageSource::imageReadRef(a2);
  CGImageGetImageProvider();
  if ((gIIODebugFlags & 0x30000) != 0) {
    ImageIOLog("    writePrologue\n");
  }
  unsigned int v10 = *((_DWORD *)this + 18);
  int v11 = *((_DWORD *)this + 19);
  uint64_t v12 = IIOImageSource::count(a2);
  unsigned int v92 = IIO_Reader::testHeaderSize(a2);
  uint64_t v13 = IIOImagePlus::sourceImageProvider(a2);
  SourceGeomColorSpace = (CGColorSpace *)IIOImagePlus::getSourceGeomColorSpace(a2);
  uint64_t result = 4294967246;
  if (v13 && SourceGeomColorSpace)
  {
    unsigned int v93 = a3;
    uint64_t v16 = v12;
    unsigned int v90 = v10;
    size_t NumberOfComponents = CGColorSpaceGetNumberOfComponents(SourceGeomColorSpace);
    CGColorSpaceModel Model = CGColorSpaceGetModel(SourceGeomColorSpace);
    int Type = CGColorSpaceGetType();
    if (*((unsigned char *)this + 124)) {
      BOOL v20 = Type == 7;
    }
    else {
      BOOL v20 = 0;
    }
    int v21 = !v20;
    int v95 = v11;
    if (v20)
    {
      BaseColorSpace = CGColorSpaceGetBaseColorSpace(SourceGeomColorSpace);
      size_t v23 = CGColorSpaceGetNumberOfComponents(BaseColorSpace);
      ColorTableCFIndex Count = CGColorSpaceGetColorTableCount(SourceGeomColorSpace);
      *((void *)this + 13) = ColorTableCount;
      uint64_t v25 = (uint8_t *)malloc_type_malloc(ColorTableCount * v23, 0x100004077774924uLL);
      *((void *)this + 14) = v25;
      CGColorSpaceGetColorTable(SourceGeomColorSpace, v25);
      SourceGeomColorSpace = CGColorSpaceGetBaseColorSpace(SourceGeomColorSpace);
      CGColorSpaceGetType();
      CGColorSpaceModel Model = CGColorSpaceGetModel(SourceGeomColorSpace);
    }
    size_t v26 = NumberOfComponents + v7;
    unsigned int appleflags = _cg_png_get_appleflags((uint64_t)a2);
    unsigned int v28 = _cg_GifLastError((uint64_t)a2);
    if (v26 - 5 >= 0xFFFFFFFFFFFFFFFCLL)
    {
      unsigned __int8 v29 = v28;
      uint64_t v30 = appleflags;
      if (appleflags == 24 && *((unsigned char *)this + 121) == 0) {
        uint64_t v30 = 32;
      }
      if (v26 * v28 == v30)
      {
        if (v95)
        {
          if ((v21 | !v7))
          {
LABEL_29:
            unsigned __int8 v32 = 2;
            uint64_t v33 = v16;
            if (Model != kCGColorSpaceModelIndexed && Model != kCGColorSpaceModelRGB)
            {
              CGImageMetadataType v34 = v93;
              if (Model)
              {
                int v87 = 0;
                int v88 = 1;
              }
              else
              {
                int v87 = 0;
                int v88 = 0;
                if (v91) {
                  unsigned __int8 v32 = 4;
                }
                else {
                  unsigned __int8 v32 = 0;
                }
              }
              goto LABEL_48;
            }
            int v87 = v91;
            int v88 = !v91;
            if (v91) {
              unsigned __int8 v32 = 6;
            }
            else {
              unsigned __int8 v32 = 2;
            }
LABEL_47:
            CGImageMetadataType v34 = v93;
LABEL_48:
            if (IIODictionary::containsKeyGroup(v34, @"InterlaceType", @"{PNG}")) {
              unsigned __int8 v41 = IIODictionary::getUint32ForKeyGroup(v34, @"InterlaceType", @"{PNG}") != 0;
            }
            else {
              unsigned __int8 v41 = 0;
            }
            _cg_png_set_IHDR(*((void *)this + 5), *((void *)this + 6), v33, v92, v29, v32, v41, 0, 0);
            if (IIODictionary::containsKey(v34, @"DPIWidth")
              && IIODictionary::containsKey(v34, @"DPIHeight"))
            {
              FloatForKedouble y = IIODictionary::getFloatForKey(v34, @"DPIWidth");
              float v43 = *(float *)&FloatForKey;
              double v44 = IIODictionary::getFloatForKey(v34, @"DPIHeight");
              _cg_png_set_pHYs(*((void *)this + 5), *((void *)this + 6), vcvtms_u32_f32((float)(v43 / 0.0254) + 0.5), vcvtms_u32_f32((float)(*(float *)&v44 / 0.0254) + 0.5), 1);
            }
            CFNumberRef Property = (const __CFNumber *)CGImageProviderGetProperty();
            if (Property) {
              CFNumberGetValue(Property, kCFNumberDoubleType, &valuePtr);
            }
            double v46 = 0.0;
            int v47 = v95;
            if (IIODictionary::containsKeyGroup(v34, @"Gamma", @"{PNG}"))
            {
              double FloatForKeyGroup = IIODictionary::getFloatForKeyGroup(v34, @"Gamma", @"{PNG}");
              if (*(float *)&FloatForKeyGroup > 0.0)
              {
                double v49 = *(float *)&FloatForKeyGroup;
                if (*(float *)&FloatForKeyGroup <= 21474.83)
                {
                  if (*(float *)&FloatForKeyGroup != 0.0)
                  {
                    _cg_png_set_gAMA(*((void (***)(void))this + 5), *((void *)this + 6), *(float *)&FloatForKeyGroup);
                    BOOL v50 = valuePtr == v49;
                    goto LABEL_67;
                  }
                  double v46 = *(float *)&FloatForKeyGroup;
                }
              }
            }
            if (valuePtr == 0.0)
            {
              BOOL v50 = 0;
            }
            else
            {
              _cg_png_set_gAMA(*((void (***)(void))this + 5), *((void *)this + 6), valuePtr);
              BOOL v50 = 1;
            }
            double v49 = v46;
LABEL_67:
            if (IIODictionary::containsKeyGroup(v34, @"Chromaticities", @"{PNG}"))
            {
              CFDictionaryRef ObjectForKeyGroup = IIODictionary::getObjectForKeyGroup(v34, @"Chromaticities", @"{PNG}");
              v98[0] = 0;
              v98[1] = 0;
              *(void *)&long long v99 = 0;
              IIOArray::IIOArray((IIOArray *)v98, ObjectForKeyGroup);
              if (IIOArray::getCount((IIOArray *)v98) >= 8)
              {
                DoubleAtIndedouble x = IIOArray::getDoubleAtIndex((IIOArray *)v98, 0);
                double v53 = IIOArray::getDoubleAtIndex((IIOArray *)v98, 1);
                double v54 = IIOArray::getDoubleAtIndex((IIOArray *)v98, 2);
                double v55 = IIOArray::getDoubleAtIndex((IIOArray *)v98, 3);
                double v56 = IIOArray::getDoubleAtIndex((IIOArray *)v98, 4);
                double v57 = IIOArray::getDoubleAtIndex((IIOArray *)v98, 5);
                double v58 = IIOArray::getDoubleAtIndex((IIOArray *)v98, 6);
                double v59 = IIOArray::getDoubleAtIndex((IIOArray *)v98, 7);
                _cg_png_set_cHRM(*((void (***)(void))this + 5), *((void *)this + 6), DoubleAtIndex, v53, v54, v55, v56, v57, v58, v59);
              }
              IIOArray::~IIOArray((IIOArray *)v98);
            }
            if (v95) {
              goto LABEL_112;
            }
            v98[0] = 0;
            uint64_t ExifBufferFromPropertiesJPEG = CreateExifBufferFromPropertiesJPEG(v34, v33, v92, SourceGeomColorSpace, 0, @"public.jpeg", v98);
            if (ExifBufferFromPropertiesJPEG)
            {
              unint64_t v61 = (void *)ExifBufferFromPropertiesJPEG;
              if (v98[0] >= 7) {
                _cg_png_set_eXIf_1(*((void *)this + 5), *((void *)this + 6), (LODWORD(v98[0]) - 6), (const void *)(ExifBufferFromPropertiesJPEG + 6));
              }
              free(v61);
            }
            CFDictionaryRef ObjectForKey = IIODictionary::getObjectForKey(v34, @"{MetaData}");
            uint64_t v63 = CGImageMetadataCreateFromLegacyProps(v34);
            uint64_t v64 = (const void *)v63;
            if (ObjectForKey)
            {
              if (v63)
              {
                CGImageMetadataMerge((uint64_t)ObjectForKey, v63, 0);
                CFRelease(v64);
              }
              CFRetain(ObjectForKey);
            }
            else
            {
              CFDictionaryRef ObjectForKey = (const __CFDictionary *)v63;
              if (!v63)
              {
LABEL_87:
                if (*((unsigned char *)this + 124)) {
                  char v72 = 1;
                }
                else {
                  char v72 = v50;
                }
                if (v72) {
                  goto LABEL_112;
                }
                char v97 = 0;
                CFErrorRef error = 0;
                CGColorSpaceGetCICPInfo();
                uint64_t Ref = (CGImage *)IIOImageSource::imageReadRef(a2);
                CGColorRenderingIntent RenderingIntent = CGImageGetRenderingIntent(Ref);
                CFDataRef data = CGColorSpaceCopyData(SourceGeomColorSpace, RenderingIntent);
                if (data)
                {
                  ColorSyncProfileRef v75 = ColorSyncProfileCreate(data, &error);
                  if (v75)
                  {
                    ColorSyncProfileRef v76 = v75;
                    SanitizedCFStringRef Copy = (const ColorSyncProfile *)ColorSyncProfileCreateSanitizedCopy();
                    CFRelease(v76);
                  }
                  else
                  {
                    SanitizedCFStringRef Copy = 0;
                  }
                  CFRelease(data);
                  CFDataRef data = 0;
                  BOOL v78 = SanitizedCopy == 0;
                  if (SanitizedCopy && !v97)
                  {
                    CFDataRef data = ColorSyncProfileCopyData(SanitizedCopy, &error);
                    if (data)
                    {
                      BytePtr = CFDataGetBytePtr(data);
                      CFIndex Length = CFDataGetLength(data);
                      if (BytePtr && Length)
                      {
                        CGColorSpaceGetName(SourceGeomColorSpace);
                        operator new();
                      }
                      CFRelease(data);
                      CFDataRef data = 0;
                    }
LABEL_111:
                    CFRelease(SanitizedCopy);
                    goto LABEL_112;
                  }
                }
                else
                {
                  SanitizedCFStringRef Copy = 0;
                  BOOL v78 = 1;
                }
                if ((v88 | v87) == 1 && v49 == 0.0)
                {
                  int v81 = (CGImage *)IIOImageSource::imageReadRef(a2);
                  __int32 v82 = CGImageGetRenderingIntent(v81) - 1;
                  if (v82 > 3) {
                    unsigned int v83 = 0;
                  }
                  else {
                    unsigned int v83 = dword_188991840[v82];
                  }
                  _cg_png_set_sRGB(*((void *)this + 5), *((void *)this + 6), v83);
                }
                if (!v78) {
                  goto LABEL_111;
                }
LABEL_112:
                if (IIODictionary::containsKeyGroup(v34, @"kCGImagePropertyPNGCompressionFilter", @"{PNG}"))
                {
                  unsigned int Uint32ForKeyGroup = IIODictionary::getUint32ForKeyGroup(v34, @"kCGImagePropertyPNGCompressionFilter", @"{PNG}");
                  if (Uint32ForKeyGroup <= 0xF8)
                  {
                    _cg_png_set_filter(*((void *)this + 5), 0, Uint32ForKeyGroup);
                    _cg_png_set_compression_strategy(*((void *)this + 5), 1);
                  }
                }
                _cg_png_set_write_fn(*((void **)this + 5), *((void *)this + 2), (size_t (*)(size_t, void *, size_t))write_fn, (uint64_t (*)(uint64_t))flush_fn);
                if (v47 || v90 < 2)
                {
                  if (v47) {
                    return 0;
                  }
                }
                else
                {
                  _cg_png_set_acTL(*((void *)this + 5), *((_DWORD **)this + 6), *((_DWORD *)this + 18), *((_DWORD *)this + 20));
                }
                _cg_png_write_info(*((void *)this + 5), *((void *)this + 6));
                if (!v91)
                {
                  if (v89 == 6)
                  {
                    uint64_t v85 = *((void *)this + 5);
                    int v86 = 0;
                    goto LABEL_124;
                  }
                  if (v89 == 5)
                  {
                    uint64_t v85 = *((void *)this + 5);
                    int v86 = 1;
LABEL_124:
                    _cg_png_set_filler(v85, 0, v86);
                  }
                }
                return 0;
              }
            }
            XMPunint64_t Data = CGImageMetadataCreateXMPData(ObjectForKey, 0);
            CFRelease(ObjectForKey);
            if (XMPData)
            {
              BOOL v94 = v50;
              uint64_t v101 = 0;
              long long v99 = 0u;
              long long v100 = 0u;
              *(_OWORD *)CFStringRef v98 = 0u;
              unsigned int v66 = CFDataGetBytePtr(XMPData);
              if (v66)
              {
                unint64_t v67 = v66;
                CFIndex v68 = CFDataGetLength(XMPData);
                if (v68)
                {
                  size_t v69 = v68;
                  unsigned int v70 = malloc_type_calloc(v68 + 1, 1uLL, 0xDBD2F272uLL);
                  if (v70)
                  {
                    uint64_t v71 = v70;
                    memcpy(v70, v67, v69);
                    LODWORD(v98[0]) = 1;
                    v98[1] = (unint64_t)"XML:com.adobe.xmp";
                    long long v99 = (unint64_t)v71;
                    long long v100 = v69;
                    uint64_t v101 = 0;
                    _cg_png_set_text(*((void (***)(void))this + 5), *((void *)this + 6), (uint64_t)v98, 1);
                    free(v71);
                  }
                }
              }
              CFRelease(XMPData);
              int v47 = v95;
              BOOL v50 = v94;
            }
            goto LABEL_87;
          }
          goto LABEL_43;
        }
        CGImageMetadataTagRef v35 = _cg_png_create_write_struct("1.6.43", 0, (uint64_t)handle_write_error, (uint64_t)handle_write_warning);
        *((void *)this + 5) = v35;
        if (v35)
        {
          _cg_png_set_compression_level((uint64_t)v35, 1);
          _cg_png_create_info_struct(*((void *)this + 5));
          *((void *)this + 6) = v36;
          if (v36)
          {
            _cg_png_set_option(*((void *)this + 5), 2u, 3);
            _cg_png_set_benign_errors(*((void *)this + 5), 1);
            if ((v21 | !v7))
            {
              if (*((unsigned char *)this + 124))
              {
                _cg_png_set_PLTE(*((void (***)(void))this + 5), *((void *)this + 6), *((const void **)this + 14), *((_DWORD *)this + 26));
                CFDictionaryRef v37 = IIODictionary::getObjectForKeyGroup(v93, @"kCGImagePropertyPNGTransparency", @"{PNG}");
                uint64_t v33 = v16;
                if (v37)
                {
                  CFDataRef v38 = v37;
                  unsigned __int8 v39 = CFDataGetBytePtr(v37);
                  unsigned int v40 = CFDataGetLength(v38);
                  if (*((void *)this + 13) == v40) {
                    _cg_png_set_tRNS(*((void *)this + 5), *((void *)this + 6), v39, v40, 0);
                  }
                }
                int v87 = 0;
                int v88 = 0;
                unsigned __int8 v32 = 3;
                goto LABEL_47;
              }
              goto LABEL_29;
            }
LABEL_43:
            *((unsigned char *)this + 84) = v29;
            int v87 = 1;
            int v88 = 0;
            *((unsigned char *)this + 122) = 1;
            unsigned __int8 v32 = 6;
            unsigned __int8 v29 = 8;
            uint64_t v33 = v16;
            goto LABEL_47;
          }
        }
        else
        {
          _cg_jpeg_mem_term("writePrologue", 620, "    png_create_write_struct failed -- _png_ptr is NULL\n");
        }
      }
    }
    return 4294967246;
  }
  return result;
}

void sub_1885E5640(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0xF1C40AFE2EBACLL);
  _Unwind_Resume(a1);
}

uint64_t IIOImageSource::imageReadRef(IIOImageSource *this)
{
  return *((void *)this + 2);
}

const __CFData *IIOImageRead::createDataWithMappedFile(IIOImageRead *this, BOOL *a2, int *a3)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  memset(&v17, 0, sizeof(v17));
  *((unsigned char *)this + 70) = 1;
  CFURLRef v5 = (const __CFURL *)*((void *)this + 6);
  if (!v5)
  {
LABEL_16:
    CFDataRef v11 = 0;
    LODWORD(a2) = 0;
    if (!a3) {
      return v11;
    }
    goto LABEL_26;
  }
  CFStringRef v7 = IIO_CFURLCopyResolvedFileSystemPath(v5);
  if (!v7)
  {
    LogError("createDataWithMappedFile", 1637, "*** ERROR: cannot resolve URL\n");
    goto LABEL_16;
  }
  CFStringRef v8 = v7;
  bzero(v18, 0x400uLL);
  if (!_CFStringGetFileSystemRepresentation())
  {
    LogError("createDataWithMappedFile", 1640, "*** ERROR: cannot get URL path\n");
    LODWORD(a2) = 0;
    CFDataRef v11 = 0;
    goto LABEL_25;
  }
  int v9 = open(v18, 0, 0);
  kdebug_trace();
  if ((gIIODebugFlags & 0x200000000000) != 0) {
    ImageIOLog(">>> %s: opening file [%d] '%s'\n", "createDataWithMappedFile", v9, v18);
  }
  if (v9 < 0)
  {
    LODWORD(a2) = *__error();
    unint64_t v14 = strerror((int)a2);
    LogFault("createDataWithMappedFile", 1686, "*** ERROR: 'open' failed '%s'\tCFErrorRef error = %d (%s)\n", v18, a2, v14);
    kdebug_trace();
    CFDataRef v11 = 0;
    goto LABEL_25;
  }
  if (fstat(v9, &v17) < 0)
  {
    LODWORD(a2) = *__error();
    unint64_t v15 = strerror((int)a2);
    LogFault("createDataWithMappedFile", 1654, "*** ERROR: 'failed - fstat err = %d (%s)\n", a2, v15);
    CFDataRef v11 = 0;
  }
  else
  {
    CFDataRef v10 = _CFDataCreateWithMappedFile(v9, v18, &v17, *((unsigned __int8 *)this + 68));
    CFDataRef v11 = v10;
    if (!v10)
    {
      LogFault("createDataWithMappedFile", 1676, "*** ERROR: '_CFDataCreateWithMappedFile' failed '%s'\n", v18);
      goto LABEL_21;
    }
    *((unsigned char *)this + 70) = 0;
    if (a2)
    {
      *a2 = 1;
      unint64_t Length = CFDataGetLength(v10);
      a2 = (BOOL *)(Length >= 4 ? 4 : Length);
      BytePtr = (unsigned __int8 *)CFDataGetBytePtr(v11);
      if (a2)
      {
        ImageIO_FileIsNotReadable(BytePtr, (size_t)a2);
LABEL_21:
        LODWORD(a2) = 0;
      }
    }
  }
  if ((gIIODebugFlags & 0x200000000000) != 0) {
    ImageIOLog("<<< %s: closing file [%d] '%s'\n", "createDataWithMappedFile", v9, v18);
  }
  kdebug_trace();
  close(v9);
LABEL_25:
  CFRelease(v8);
  if (a3) {
LABEL_26:
  }
    *a3 = (int)a2;
  return v11;
}

void IIOImageRead::validateFileSize(IIOImageRead *this)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  memset(&v7, 0, sizeof(v7));
  CFURLRef v2 = (const __CFURL *)*((void *)this + 6);
  if (v2)
  {
    CFStringRef v3 = IIO_CFURLCopyResolvedFileSystemPath(v2);
    if (v3)
    {
      CFStringRef v4 = v3;
      bzero(v8, 0x400uLL);
      if (_CFStringGetFileSystemRepresentation())
      {
        if (!stat(v8, &v7))
        {
          st_size_t size = v7.st_size;
          if (st_size != CFDataGetLength(*((CFDataRef *)this + 4)))
          {
            CFIndex Length = CFDataGetLength(*((CFDataRef *)this + 4));
            LogFault("validateFileSize", 1717, "*** ImageIO - mmapped file changed (old: %ld  new: %ld)\n", Length, v7.st_size);
          }
        }
      }
      else
      {
        LogError("validateFileSize", 1711, "*** ERROR: cannot get URL path\n");
      }
      CFRelease(v4);
    }
    else
    {
      LogError("validateFileSize", 1708, "*** ERROR: cannot resolve URL\n");
    }
  }
}

uint64_t CGImageReadCreateWithURL(uint64_t a1, const __CFURL *a2, unsigned __int8 *a3, int a4, int a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  if (a2)
  {
    CFStringRef v10 = IIO_CFURLCopyResolvedFileSystemPath(a2);
    if (v10)
    {
      CFURLRef v11 = (const __CFURL *)v10;
      bzero(&__s1, 0x400uLL);
      if (_CFStringGetFileSystemRepresentation())
      {
        off_t v12 = IIOImageRead::CreateWithURL(a2, v11, &__s1, a3, a4, a5);
        CFRelease(v11);
        if (v12)
        {
          pthread_mutex_lock((pthread_mutex_t *)(v12 + 376));
          IIOImageRead::setISR((IIOImageRead *)v12, a1);
          pthread_mutex_unlock((pthread_mutex_t *)(v12 + 376));
          return CGImageReadRefCreateWith_ImageRead((IIOImageRead *)v12);
        }
      }
      else
      {
        LogError("CGImageReadCreateWithURL", 2256, "*** ERROR: cannot get URL path\n");
        CFRelease(v11);
      }
    }
    else
    {
      LogError("CGImageReadCreateWithURL", 2249, "*** ERROR: cannot resolve URL\n");
    }
  }
  return 0;
}

CGImageSourceRef CGImageSourceCreateWithURL(CFURLRef url, CFDictionaryRef options)
{
  v7[131] = *MEMORY[0x1E4F143B8];
  IIOInitDebugFlags();
  kdebug_trace();
  if (url)
  {
    CFTypeID v4 = CFGetTypeID(url);
    if (v4 == CFURLGetTypeID())
    {
      if (options)
      {
        CFTypeID v5 = CFGetTypeID(options);
        if (v5 != CFDictionaryGetTypeID())
        {
          LogError("CGImageSourceCreateWithURL", 4611, "*** ERROR: CGImageSourceCreateWithURL: options parameter is not a CFDictionaryRef - ignoring\n");
          options = 0;
        }
      }
      memset(v7, 0, 24);
      IIODictionary::IIODictionary((IIODictionary *)v7, options, 1);
      operator new();
    }
    LogError("CGImageSourceCreateWithURL", 4608, "*** ERROR: CGImageSourceCreateWithURL: url is not a CFURLRef\n");
  }
  else
  {
    LogError("CGImageSourceCreateWithURL", 4607, "*** ERROR: CGImageSourceCreateWithURL: url is nil\n");
  }
  kdebug_trace();
  kdebug_trace();
  if ((gIIODebugFlags & 0x800000000000) != 0) {
    ImageIOLog(" ISSUE: %s:%d:  %s\n", "CGImageSourceCreateWithURL", 4657, "could not create CGImageSourceRef");
  }
  return 0;
}

void sub_1885E5F5C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13)
{
  if (a2)
  {
    MEMORY[0x18C11C0E0](v13, 0x10E1C40A1B1CD90);
    IIODictionary::~IIODictionary((IIODictionary *)&a13);
    __cxa_begin_catch(exception_object);
    __cxa_end_catch();
    JUMPOUT(0x1885E5EA0);
  }
  _Unwind_Resume(exception_object);
}

void IIOImageSource::IIOImageSource(IIOImageSource *this, const __CFURL *a2, IIODictionary *a3)
{
  uint64_t v34 = *MEMORY[0x1E4F143B8];
  *(void *)this = &unk_1ED4E1420;
  *((void *)this + 18) = 0;
  *((void *)this + 19) = 0;
  *((void *)this + 20) = 0;
  *((void *)this + 25) = 0;
  *((void *)this + 26) = 0;
  *((void *)this + 27) = 0;
  IIOImageSource::setup((uint64_t)this, 3);
  if (a3) {
    IIOImageSource::extractOptions(this, a3);
  }
  CFStringRef v6 = IIO_CFURLCopyResolvedFileSystemPath(a2);
  stat v7 = (IIO_ReaderHandler *)CFURLCopyPathExtension(a2);
  CFStringRef v8 = (const __CFString *)v7;
  if ((gIIODebugFlags & 0x10000000) != 0 && v6)
  {
    bzero(__filename, 0x400uLL);
    if (_CFStringGetFileSystemRepresentation())
    {
      memset(&v30, 0, sizeof(v30));
      stat(__filename, &v30);
      st_size_t size = v30.st_size;
      CFStringRef v10 = (UInt8 *)malloc_type_malloc(v30.st_size, 0x77BC9639uLL);
      if (v10)
      {
        CFURLRef v11 = fopen(__filename, "r");
        if (v11)
        {
          if (fread(v10, 1uLL, st_size, v11) == st_size)
          {
            CFDataRef v12 = CFDataCreate(0, v10, st_size);
            if (v12)
            {
              ImageIO_saveImageData("CGImageSourceCreateWithURL", v12);
              CFRelease(v12);
            }
          }
          fclose(v11);
        }
        free(v10);
      }
    }
    goto LABEL_14;
  }
  if (v6)
  {
LABEL_14:
    *(void *)__fileCFStringRef name = 0;
    uint64_t v32 = 0;
    uint64_t v33 = 0;
    IIOString::IIOString((IIOString *)__filename, v6);
    uint64_t propertyValueTypeRefPtr = *MEMORY[0x1E4F1CFC8];
    uint64_t v13 = propertyValueTypeRefPtr;
    unint64_t v14 = (IIO_ReaderHandler *)CFURLCopyResourcePropertyForKey(a2, (CFStringRef)*MEMORY[0x1E4F1D6B8], &propertyValueTypeRefPtr, 0);
    uint64_t v15 = propertyValueTypeRefPtr;
    if (v13 == propertyValueTypeRefPtr)
    {
      unint64_t v14 = (IIO_ReaderHandler *)CFURLCopyResourcePropertyForKey(a2, (CFStringRef)*MEMORY[0x1E4F1D6C8], &propertyValueTypeRefPtr, 0);
      uint64_t v15 = propertyValueTypeRefPtr;
    }
    if (v13 == v15)
    {
      memset(&v30, 0, 24);
      IIOString::IIOString((IIOString *)&v30, v6);
      int v21 = (const char *)IIOString::utf8String((IIOString *)&v30);
      LogError("IIOImageSource", 513, "*** ERROR: can't open '%s'  (fileExists == false)\n", v21);
      *((_DWORD *)this + 88) = -1;
      IIOString::~IIOString((IIOString *)&v30);
    }
    else
    {
      if (!*((void *)this + 7))
      {
        ReaderHandler = (IIO_ReaderHandler *)IIO_ReaderHandler::GetReaderHandler(v14);
        stat v17 = IIO_ReaderHandler::readerForPathExtension(ReaderHandler, v8);
        unsigned int v18 = v17;
        if (!v17
          || (CFStringRef v19 = (const __CFString *)IIO_Reader::utType(v17), CFStringCompare(v19, @"public.tiff", 0)))
        {
          IIOImageSource::setHintReader(this, v18);
        }
      }
      CFURLRef v20 = CFURLCreateWithFileSystemPath((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v6, kCFURLPOSIXPathStyle, 0);
      if (v20)
      {
        IIOImageSource::updateMemoryMapFlagForProtectionClass((uint64_t)this, (IIOString *)__filename);
        *((void *)this + 2) = CGImageReadCreateWithURL(*((void *)this + 1), v20, (unsigned __int8 *)1, *((unsigned __int8 *)this + 48), *((unsigned __int8 *)this + 49));
        CFRelease(v20);
      }
      else
      {
        _cg_jpeg_mem_term("IIOImageSource", 544, "CGImageReadCreateWithURL returned nil.\n");
        *((_DWORD *)this + 88) = -3;
      }
    }
    IIOString::~IIOString((IIOString *)__filename);
    CFRelease(v6);
    goto LABEL_26;
  }
  if (!*((void *)this + 7))
  {
    unsigned int v22 = (IIO_ReaderHandler *)IIO_ReaderHandler::GetReaderHandler(v7);
    size_t v23 = IIO_ReaderHandler::readerForPathExtension(v22, v8);
    IIOImageSource::setHintReader(this, v23);
  }
  unsigned int v24 = (IIOImageRead *)IIOCreateDataWithContentsOfURL(a2);
  if (v24)
  {
    *((void *)this + 2) = CGImageReadCreateWithData(*((void *)this + 1), v24, (__CFData *)1);
    CFRelease(v24);
  }
  else
  {
    CFStringRef v25 = CFURLCopyScheme(a2);
    CFStringRef v26 = v25;
    if (!v25) {
      goto LABEL_37;
    }
    CFComparisonResult v27 = CFStringCompare(v25, @"assets-library", 0);
    if (v27 == kCFCompareEqualTo) {
      LogError("IIOImageSource", 573, "*** ERROR: cannot handle this URL ('assets-library' scheme is not supported).\n");
    }
    CFRelease(v26);
    if (v27 == kCFCompareEqualTo)
    {
      int v28 = -2;
    }
    else
    {
LABEL_37:
      _cg_jpeg_mem_term("IIOImageSource", 584, "*** ERROR: IIOCreateDataWithContentsOfURL returned nil.\n");
      int v28 = -4;
    }
    *((_DWORD *)this + 88) = v28;
  }
LABEL_26:
  if (v8) {
    CFRelease(v8);
  }
}

void sub_1885E6414(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,char a30)
{
  uint64_t v34 = *v32;
  if (*v32)
  {
    *(void *)(v30 + 208) = v34;
    operator delete(v34);
  }
  CGImageMetadataTagRef v35 = *v31;
  if (*v31)
  {
    *(void *)(v30 + 152) = v35;
    operator delete(v35);
  }
  _Unwind_Resume(exception_object);
}

CFStringRef IIO_CFURLCopyResolvedFileSystemPath(const __CFURL *a1)
{
  if (!a1) {
    return 0;
  }
  CFStringRef v2 = CFURLCopyScheme(a1);
  if (!v2) {
    return 0;
  }
  CFStringRef v3 = v2;
  CFComparisonResult v4 = CFStringCompare(v2, @"file", 0);
  CFRelease(v3);
  if (v4) {
    return 0;
  }
  CFURLRef v6 = CFURLCopyAbsoluteURL(a1);
  if (!v6) {
    return 0;
  }
  CFURLRef v7 = v6;
  CFStringRef v8 = CFURLCopyFileSystemPath(v6, kCFURLPOSIXPathStyle);
  CFRelease(v7);
  return v8;
}

IIO_Reader *IIO_ReaderHandler::readerForPathExtension(IIO_ReaderHandler *this, CFStringRef theString)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  long long v6 = xmmword_1889AA7F2;
  char v7 = 0;
  if (theString && CFStringGetCString(theString, (char *)&v6 + 1, 15, 0x600u))
  {
    if (!strcasecmp((const char *)&v6, ".tif")) {
      return IIO_ReaderHandler::readerForUTType(this, @"public.tiff");
    }
    CFComparisonResult v4 = (void *)*((void *)this + 2);
    CFStringRef v3 = (void *)*((void *)this + 3);
    while (v4 != v3)
    {
      if ((*(unsigned int (**)(void, long long *))(*(void *)*v4 + 144))(*v4, &v6)) {
        return (IIO_Reader *)*v4;
      }
      ++v4;
    }
  }
  return 0;
}

const char *IIO_Reader::matchesExtension(IIO_Reader *this, char *a2)
{
  uint64_t result = (const char *)*((void *)this + 2);
  if (result) {
    return (const char *)(strcasestr(result, a2) != 0);
  }
  return result;
}

uint64_t IIOImageSource::updateMemoryMapFlagForProtectionClass(uint64_t this, IIOString *a2)
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  if (*(unsigned char *)(this + 48))
  {
    uint64_t v2 = this;
    CFStringRef v3 = (const char *)IIOString::utf8String(a2);
    v4[1] = 0;
    _OWORD v4[2] = 0;
    memset(v5, 0, sizeof(v5));
    v4[0] = 0x4000000000000005;
    this = getattrlist(v3, v4, v5, 0x40uLL, 1u);
    if (!this && LODWORD(v5[0]) == 8 && (DWORD1(v5[0]) - 1) <= 1) {
      *(unsigned char *)(v2 + 48) = 0;
    }
  }
  return this;
}

const __CFString *IIOString::utf8String(IIOString *this)
{
  CFStringRef result = (const __CFString *)*((void *)this + 2);
  if (result)
  {
    CFStringRef result = (const __CFString *)CFStringGetCStringPtr(result, 0x8000100u);
    if (!result)
    {
      CFStringRef result = (const __CFString *)*((void *)this + 1);
      if (!result)
      {
        CFStringRef result = (const __CFString *)IIOString::createUTF8String(this);
        *((void *)this + 1) = result;
      }
    }
  }
  return result;
}

void *IIOImageSource::setHintReader(void *this, IIO_Reader *a2)
{
  this[12] = a2;
  if (a2)
  {
    uint64_t v2 = this;
    if (!this[7])
    {
      CFStringRef v3 = (const void *)IIO_Reader::utType(a2);
      this = CFRetain(v3);
      v2[7] = this;
    }
  }
  return this;
}

off_t IIOImageRead::CreateWithURL(IIOImageRead *this, const __CFURL *a2, __CFString *__s1, unsigned __int8 *a4, int a5, int a6)
{
  CFStringRef v10 = strstr((char *)__s1, "/var/mnt/");
  if (v10) {
    int v11 = 0;
  }
  else {
    int v11 = a6;
  }
  if (v10) {
    int v12 = 0;
  }
  else {
    int v12 = a5;
  }
  int v13 = open((const char *)__s1, 0, 0);
  kdebug_trace();
  if ((gIIODebugFlags & 0x200000000000) != 0) {
    ImageIOLog(">>> %s: opening file [%d] '%s'\n", "CreateWithURL", v13, (const char *)__s1);
  }
  memset(&v26, 0, sizeof(v26));
  if (v13 < 0)
  {
    if (this)
    {
      CFStringRef v16 = CFCopyDescription(this);
      int v17 = *__error();
      unsigned int v18 = __error();
      CFStringRef v19 = strerror(*v18);
      IIOString::IIOString((IIOString *)v25, v16);
      CFURLRef v20 = (const char *)IIOString::utf8String((IIOString *)v25);
      LogError("CreateWithURL", 342, "*** ERROR: err=%d (%s) - could not open '%s'\n", v17, v19, v20);
      IIOString::~IIOString((IIOString *)v25);
      CFRelease(v16);
    }
    else
    {
      int v21 = *__error();
      unsigned int v22 = __error();
      size_t v23 = strerror(*v22);
      LogError("CreateWithURL", 346, "*** ERROR: err=%d (%s) - could not open '%s'\n", v21, v23, (const char *)__s1);
    }
    return 0;
  }
  else
  {
    unint64_t v14 = (IIOXPCClient *)fstat(v13, &v26);
    if ((v14 & 0x80000000) != 0 || (v26.st_mode & 0xF000) != 0x8000)
    {
      st_size_t size = 0;
    }
    else
    {
      st_size_t size = v26.st_size;
      if (v26.st_size)
      {
        if (v12) {
          unint64_t v14 = _CFDataCreateWithMappedFile(v13, (char *)__s1, &v26, v11);
        }
        if (IIOImageRead::CreateWithURL(__CFURL const*,__CFString const*,unsigned char *,BOOL,BOOL,BOOL)::onceToken != -1) {
          dispatch_once(&IIOImageRead::CreateWithURL(__CFURL const*,__CFString const*,unsigned char *,BOOL,BOOL,BOOL)::onceToken, &__block_literal_global_32);
        }
        if (IIOImageRead::CreateWithURL(__CFURL const*,__CFString const*,unsigned char *,BOOL,BOOL,BOOL)::useSystemPath
          || IIOXPCClient::CanCheckTrustedURL(v14)
          && (rootless_trusted_by_self_token(), rootless_verify_trusted_by_self_token()))
        {
          strncmp((const char *)__s1, "/System", 7uLL);
          kdebug_trace();
        }
        operator new();
      }
    }
    if ((gIIODebugFlags & 0x200000000000) != 0) {
      ImageIOLog("<<< %s: closing file [%d] '%s'\n", "CreateWithURL", v13, (const char *)__s1);
    }
    kdebug_trace();
    close(v13);
  }
  return st_size;
}

void sub_1885E6B94(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10F1C405FDDC6B3);
  _Unwind_Resume(a1);
}

CFDataRef _CFDataCreateWithMappedFile(int a1, char *a2, stat *a3, int a4)
{
  st_size_t size = (void *)a3->st_size;
  if (!ERROR_ImageIO_FileIsNotReadable(a1, a2)) {
    return 0;
  }
  if (a4) {
    int v9 = 16385;
  }
  else {
    int v9 = 16386;
  }
  CFStringRef v10 = (const UInt8 *)mmap(0, a3->st_size, 1, v9, a1, 0);
  if (v10 == (const UInt8 *)-1)
  {
    int v15 = *__error();
    CFStringRef v16 = __error();
    int v17 = strerror(*v16);
    LogFault("_CFDataCreateWithMappedFile", 199, "could not mmap '%s':  error: %d (%s)\n", a2, v15, v17);
    return 0;
  }
  int v11 = v10;
  kdebug_trace();
  context.version = 0;
  memset(&context.retain, 0, 40);
  context.info = st_size;
  context.deallocate = (CFAllocatorDeallocateCallBack)_mappedDeallocate;
  context.preferredunsigned int Size = 0;
  CFAllocatorRef v12 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFAllocatorRef v13 = CFAllocatorCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], &context);
  CFDataRef v14 = CFDataCreateWithBytesNoCopy(v12, v11, (CFIndex)st_size, v13);
  CFRelease(v13);
  if ((gIIODebugFlags & 0x100000000000) != 0)
  {
    ImageIOLog("   ------------------------------------------------------\n");
    if ((gIIODebugFlags & 0x100000000000) != 0)
    {
      ImageIOLog("    %s:%d   mmap    prt: %p  size: %lld  <CFDataRef:%p>  path: '%s'\n", "_CFDataCreateWithMappedFile", 208, v11, a3->st_size, v14, a2);
      if ((gIIODebugFlags & 0x100000000000) != 0) {
        ImageIOLog("   ------------------------------------------------------\n");
      }
    }
  }
  return v14;
}

uint64_t ERROR_ImageIO_FileIsNotReadable(int a1, char *a2)
{
  int v9 = a1;
  uint64_t v8 = a2;
  char __buf = 0;
  if (pread(a1, &__buf, 1uLL, 0) < 0)
  {
    uint64_t v2 = v8;
    int v3 = *__error();
    CFComparisonResult v4 = __error();
    CFTypeID v5 = strerror(*v4);
    LogFault("ERROR_ImageIO_FileIsNotReadable", 132, "*** %s path: '%s' - cannot not read first byte of file - error: %d (%s)\n", "ERROR_ImageIO_FileIsNotReadable", v2, v3, v5);
    char v10 = 0;
  }
  else
  {
    char v10 = 1;
  }
  return v10 & 1;
}

uint64_t IIOXPCClient::CanCheckTrustedURL(IIOXPCClient *this)
{
  if (IIOXPCClient::CanCheckTrustedURL(void)::onceToken != -1) {
    dispatch_once(&IIOXPCClient::CanCheckTrustedURL(void)::onceToken, &__block_literal_global_23);
  }
  return IIOXPCClient::CanCheckTrustedURL(void)::canCheckTrustedURL;
}

uint64_t IIOImageRead::IIOImageRead(uint64_t a1, const __CFData *a2, int a3, int a4, char a5, char a6)
{
  *(void *)a1 = &unk_1ED4DF1B0;
  *(void *)(a1 + 152) = 0;
  *(void *)(a1 + 248) = 0;
  *(void *)(a1 + 240) = a1 + 248;
  *(void *)(a1 + 160) = 0;
  *(void *)(a1 + 168) = 0;
  *(void *)(a1 + 256) = 0;
  *(void *)(a1 + 296) = 0;
  *(void *)(a1 + 304) = 0;
  *(void *)(a1 + 288) = 0;
  IIOImageRead::setup(a1, a3);
  if (gCopyInputData)
  {
    *(void *)(a1 + 32) = CFDataCreateCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a2);
    if ((gIIODebugFlags & 0x80000000000) != 0) {
      ImageIOLog("D   %s:%d CFDataCreateCopy %p\n");
    }
  }
  else
  {
    *(void *)(a1 + 32) = CFRetain(a2);
    if ((gIIODebugFlags & 0x80000000000) != 0) {
      ImageIOLog("D   %s:%d CFRetain %p\n");
    }
  }
  *(unsigned char *)(a1 + 71) = a5;
  *(void *)(a1 + 80) = CFDataGetLength(a2);
  *(unsigned char *)(a1 + 64) = a6;
  *(unsigned char *)(a1 + 65) = a6 ^ 1;
  *(unsigned char *)(a1 + 66) = 1;
  *(unsigned char *)(a1 + 67) = a4;
  *(_DWORD *)(a1 + 440) = a4;
  return a1;
}

void sub_1885E6FC8(_Unwind_Exception *a1)
{
  char v7 = *v5;
  if (*v5)
  {
    *(void *)(v1 + 296) = v7;
    operator delete(v7);
  }
  std::__tree<std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>>>::destroy(v2, *v4);
  uint64_t v8 = *v3;
  if (*v3)
  {
    *(void *)(v1 + 160) = v8;
    operator delete(v8);
  }
  _Unwind_Resume(a1);
}

CFTypeRef IIOImageRead::setURL(IIOImageRead *this, CFTypeRef cf)
{
  CFComparisonResult v4 = (const void *)*((void *)this + 6);
  if (v4) {
    CFRelease(v4);
  }
  CFTypeRef result = CFRetain(cf);
  *((void *)this + 6) = result;
  return result;
}

CFTypeRef IIOImageRead::setURLPath(IIOImageRead *this, CFTypeRef cf)
{
  CFComparisonResult v4 = (const void *)*((void *)this + 7);
  if (v4) {
    CFRelease(v4);
  }
  CFTypeRef result = CFRetain(cf);
  *((void *)this + 7) = result;
  return result;
}

const char *LogError(const char *result, int a2, const char *a3, ...)
{
  va_start(va, a3);
  if (gImageIOLogProc) {
    return (const char *)gImageIOLogProc(16, 0, result, a2, a3, va);
  }
  return result;
}

void *ImageIO_FileIsNotReadable(unsigned __int8 *a1, size_t a2)
{
  CFTypeID v5 = a1;
  size_t __n = a2;
  memset(__b, 0, sizeof(__b));
  return memcpy(__b, v5, __n);
}

void *png_create_write_struct_2(unsigned char *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  png_struct = png_create_png_struct(a1, a2, a3, a4, a5, a6, a7);
  uint64_t v8 = png_struct;
  if (png_struct)
  {
    *(_OWORD *)(png_struct + 27) = xmmword_188991050;
    *((_DWORD *)png_struct + 64) = 0;
    png_struct[31] = 0x80000000FLL;
    *(_OWORD *)(png_struct + 29) = xmmword_188991060;
    *((_DWORD *)png_struct + 20) |= 0x200000u;
    _cg_png_set_write_fn(png_struct, 0, 0, 0);
  }
  return v8;
}

uint64_t _cg_png_write_info(uint64_t result, uint64_t a2)
{
  if (!result || !a2) {
    return result;
  }
  uint64_t v3 = result;
  png_write_info_before_PLTE(result, a2);
  int v4 = *(_DWORD *)(a2 + 8);
  if ((v4 & 8) != 0)
  {
    png_write_PLTE(v3, *(void *)(a2 + 24), *(unsigned __int16 *)(a2 + 32));
    int v4 = *(_DWORD *)(a2 + 8);
    if ((v4 & 0x10) == 0) {
      goto LABEL_6;
    }
  }
  else
  {
    if (*(unsigned char *)(a2 + 37) == 3) {
      _cg_png_error((void (**)(void))v3, "Valid palette required for paletted images");
    }
    if ((v4 & 0x10) == 0)
    {
LABEL_6:
      if ((v4 & 0x20) == 0) {
        goto LABEL_7;
      }
      goto LABEL_27;
    }
  }
  if ((*(unsigned char *)(v3 + 90) & 8) != 0 && *(unsigned char *)(a2 + 37) == 3)
  {
    uint64_t v5 = *(unsigned __int16 *)(a2 + 34) >= 0x100u ? 256 : *(unsigned __int16 *)(a2 + 34);
    if (v5)
    {
      for (uint64_t i = 0; i != v5; ++i)
        *(unsigned char *)(*(void *)(a2 + 184) + i) = ~*(unsigned char *)(*(void *)(a2 + 184) + i);
    }
  }
  png_write_tRNS(v3, *(Bytef **)(a2 + 184), (unsigned __int16 *)(a2 + 192), *(unsigned __int16 *)(a2 + 34), *(unsigned __int8 *)(a2 + 37));
  int v4 = *(_DWORD *)(a2 + 8);
  if ((v4 & 0x20) == 0)
  {
LABEL_7:
    if ((v4 & 0x10000) == 0) {
      goto LABEL_8;
    }
    goto LABEL_28;
  }
LABEL_27:
  png_write_bKGD(v3, (unsigned __int8 *)(a2 + 202), *(unsigned __int8 *)(a2 + 37));
  int v4 = *(_DWORD *)(a2 + 8);
  if ((v4 & 0x10000) == 0)
  {
LABEL_8:
    if ((v4 & 0x40) == 0) {
      goto LABEL_9;
    }
    goto LABEL_29;
  }
LABEL_28:
  png_write_eXIf(v3, *(Bytef **)(a2 + 240), *(_DWORD *)(a2 + 236));
  *(_DWORD *)(v3 + 76) |= 0x4000u;
  int v4 = *(_DWORD *)(a2 + 8);
  if ((v4 & 0x40) == 0)
  {
LABEL_9:
    if ((v4 & 0x100) == 0) {
      goto LABEL_10;
    }
    goto LABEL_30;
  }
LABEL_29:
  png_write_hIST(v3, *(unsigned __int16 **)(a2 + 256), *(unsigned __int16 *)(a2 + 32));
  int v4 = *(_DWORD *)(a2 + 8);
  if ((v4 & 0x100) == 0)
  {
LABEL_10:
    if ((v4 & 0x400) == 0) {
      goto LABEL_11;
    }
    goto LABEL_31;
  }
LABEL_30:
  png_write_oFFs((void (**)(void))v3, *(unsigned int *)(a2 + 212), *(unsigned int *)(a2 + 216), *(unsigned __int8 *)(a2 + 220));
  int v4 = *(_DWORD *)(a2 + 8);
  if ((v4 & 0x400) == 0)
  {
LABEL_11:
    if ((v4 & 0x4000) == 0) {
      goto LABEL_12;
    }
    goto LABEL_32;
  }
LABEL_31:
  png_write_pCAL((void (**)(void))v3, *(unsigned __int8 **)(a2 + 264), *(_DWORD *)(a2 + 272), *(_DWORD *)(a2 + 276), *(unsigned __int8 *)(a2 + 296), *(unsigned __int8 *)(a2 + 297), *(const char **)(a2 + 280), *(const char ***)(a2 + 288));
  int v4 = *(_DWORD *)(a2 + 8);
  if ((v4 & 0x4000) == 0)
  {
LABEL_12:
    if ((v4 & 0x80) == 0) {
      goto LABEL_13;
    }
    goto LABEL_33;
  }
LABEL_32:
  png_write_sCAL_s((void (**)(void))v3, *(unsigned char *)(a2 + 332), *(char **)(a2 + 336), *(const char **)(a2 + 344));
  int v4 = *(_DWORD *)(a2 + 8);
  if ((v4 & 0x80) == 0)
  {
LABEL_13:
    if ((v4 & 0x200) == 0) {
      goto LABEL_14;
    }
    goto LABEL_34;
  }
LABEL_33:
  png_write_pHYs((void (**)(void))v3, *(_DWORD *)(a2 + 224), *(_DWORD *)(a2 + 228), *(unsigned __int8 *)(a2 + 232));
  int v4 = *(_DWORD *)(a2 + 8);
  if ((v4 & 0x200) == 0)
  {
LABEL_14:
    if ((v4 & 0x2000) == 0) {
      goto LABEL_38;
    }
LABEL_35:
    if (*(int *)(a2 + 328) >= 1)
    {
      uint64_t v7 = 0;
      uint64_t v8 = 0;
      do
      {
        png_write_sPLT((void (**)(void))v3, *(void *)(a2 + 320) + v7);
        ++v8;
        v7 += 40;
      }
      while (v8 < *(int *)(a2 + 328));
    }
    goto LABEL_38;
  }
LABEL_34:
  png_write_tIME((void (**)(void))v3, (unsigned __int16 *)(a2 + 168));
  *(_DWORD *)(v3 + 76) |= 0x200u;
  if ((*(_DWORD *)(a2 + 8) & 0x2000) != 0) {
    goto LABEL_35;
  }
LABEL_38:
  if (*(int *)(a2 + 148) >= 1)
  {
    uint64_t v9 = 0;
    uint64_t v10 = 0;
    uint64_t v11 = *(void *)(a2 + 160);
    while (1)
    {
      int v12 = *(_DWORD *)(v11 + v9);
      if (v12 >= 1) {
        break;
      }
      if (v12 == -1)
      {
        png_write_tEXt((void (**)(void))v3, *(unsigned __int8 **)(v11 + v9 + 8), *(char **)(v11 + v9 + 16));
        uint64_t v11 = *(void *)(a2 + 160);
LABEL_48:
        *(_DWORD *)(v11 + v9) = -3;
        goto LABEL_49;
      }
      if (!v12)
      {
        png_write_zTXt(v3, *(unsigned __int8 **)(v11 + v9 + 8), *(char **)(v11 + v9 + 16), 0);
        uint64_t v11 = *(void *)(a2 + 160);
LABEL_46:
        *(_DWORD *)(v11 + v9) = -2;
      }
LABEL_49:
      ++v10;
      v9 += 56;
      if (v10 >= *(int *)(a2 + 148)) {
        goto LABEL_50;
      }
    }
    png_write_iTXt(v3, v12, *(unsigned __int8 **)(v11 + v9 + 8), *(char **)(v11 + v9 + 40), *(char **)(v11 + v9 + 48), *(char **)(v11 + v9 + 16));
    uint64_t v11 = *(void *)(a2 + 160);
    if (*(_DWORD *)(v11 + v9) == -1) {
      goto LABEL_48;
    }
    goto LABEL_46;
  }
LABEL_50:

  return write_unknown_chunks(v3, a2, 2u);
}

uint64_t png_write_info_before_PLTE(uint64_t result, uint64_t a2)
{
  if (!result) {
    return result;
  }
  if (!a2) {
    return result;
  }
  uint64_t v3 = result;
  if ((*(unsigned char *)(result + 77) & 4) != 0) {
    return result;
  }
  png_write_sig(result);
  if ((*(unsigned char *)(v3 + 77) & 0x10) != 0 && *(_DWORD *)(v3 + 760))
  {
    png_warning(v3, "MNG features are not allowed in a PNG datastream");
    *(_DWORD *)(v3 + 760) = 0;
  }
  png_write_IHDR(v3, *(_DWORD *)a2, *(_DWORD *)(a2 + 4), *(unsigned __int8 *)(a2 + 36), *(unsigned __int8 *)(a2 + 37), *(unsigned __int8 *)(a2 + 38), *(unsigned __int8 *)(a2 + 39), *(unsigned __int8 *)(a2 + 40));
  if ((*(unsigned char *)(a2 + 10) & 2) != 0) {
    png_write_acTL(v3, *(_DWORD *)(a2 + 360), *(_DWORD *)(a2 + 364));
  }
  __int16 v4 = *(_WORD *)(a2 + 126);
  if ((v4 & 0x8008) == 8)
  {
    if ((*(unsigned char *)(a2 + 8) & 1) == 0) {
      goto LABEL_13;
    }
    png_write_gAMA_fixed((void (**)(void))v3, *(_DWORD *)(a2 + 52));
    __int16 v4 = *(_WORD *)(a2 + 126);
  }
  if ((v4 & 0x8000) == 0)
  {
LABEL_13:
    int v5 = *(_DWORD *)(a2 + 8);
    if ((v5 & 0x1000) != 0)
    {
      if ((v5 & 0x800) != 0) {
        png_app_warning(v3, "profile matches sRGB but writing iCCP instead");
      }
      png_write_iCCP(v3, *(unsigned __int8 **)(a2 + 128), *(void *)(a2 + 136));
    }
    else if ((v5 & 0x800) != 0)
    {
      png_write_sRGB((void (**)(void))v3, *(unsigned __int16 *)(a2 + 124));
    }
  }
  if ((*(unsigned char *)(a2 + 8) & 2) != 0) {
    png_write_sBIT(v3, (unsigned __int8 *)(a2 + 176), *(unsigned __int8 *)(a2 + 37));
  }
  if ((*(_WORD *)(a2 + 126) & 0x8010) == 0x10 && (*(unsigned char *)(a2 + 8) & 4) != 0) {
    png_write_cHRM_fixed((void (**)(void))v3, (unsigned int *)(a2 + 56));
  }
  CFTypeRef result = write_unknown_chunks(v3, a2, 1u);
  *(_DWORD *)(v3 + 76) |= 0x400u;
  return result;
}

uint64_t png_write_sig(uint64_t a1)
{
  *(_DWORD *)(a1 + 956) = 18;
  uint64_t result = png_write_data(a1);
  if (*(unsigned __int8 *)(a1 + 397) <= 2u) {
    *(_DWORD *)(a1 + 76) |= 0x1000u;
  }
  return result;
}

void (**png_write_IHDR(uint64_t a1, unsigned int a2, int a3, unsigned int a4, int a5, int a6, int a7, unsigned int a8))(void)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  Bytef v12 = a4;
  switch(a5)
  {
    case 0:
      if (a4 <= 0x10)
      {
        char v15 = 1;
        if (((1 << a4) & 0x10116) != 0) {
          goto LABEL_16;
        }
      }
      CFStringRef v16 = "Invalid bit depth for grayscale image";
      goto LABEL_45;
    case 2:
      char v15 = 3;
      if (a4 == 8 || a4 == 16) {
        goto LABEL_16;
      }
      CFStringRef v16 = "Invalid bit depth for RGB image";
      goto LABEL_45;
    case 3:
      if (a4 - 1 >= 8 || ((0x8Bu >> (a4 - 1)) & 1) == 0)
      {
        CFStringRef v16 = "Invalid bit depth for paletted image";
LABEL_45:
        _cg_png_error((void (**)(void))a1, v16);
      }
      char v15 = 1;
LABEL_16:
      *(unsigned char *)(a1 + 395) = v15;
      if (a6) {
        png_warning(a1, "Invalid compression type specified");
      }
      if ((*(unsigned char *)(a1 + 760) & 4) == 0 || (*(unsigned char *)(a1 + 77) & 0x10) != 0)
      {
        if (!a7) {
          goto LABEL_31;
        }
        goto LABEL_30;
      }
      BOOL v18 = (a5 & 0xFFFFFFFB) != 2 || a7 != 64;
      if (a7 && v18)
      {
LABEL_30:
        png_warning(a1, "Invalid filter type specified");
        LOBYTE(a7) = 0;
      }
LABEL_31:
      if (a8 >= 2)
      {
        png_warning(a1, "Invalid interlace type specified");
        LOBYTE(a8) = 1;
      }
      *(unsigned char *)(a1 + 392) = v12;
      *(unsigned char *)(a1 + 391) = a5;
      *(unsigned char *)(a1 + 388) = a8;
      *(unsigned char *)(a1 + 764) = a7;
      *(unsigned char *)(a1 + 872) = 0;
      *(_DWORD *)(a1 + 280) = a2;
      *(_DWORD *)(a1 + 284) = a3;
      char v19 = *(unsigned char *)(a1 + 395);
      *(unsigned char *)(a1 + 394) = v19 * v12;
      unint64_t v20 = a2 * (unint64_t)((v19 * v12) >> 3);
      if ((v19 * v12) < 8u) {
        unint64_t v20 = ((v19 * v12) * (unint64_t)a2 + 7) >> 3;
      }
      *(void *)(a1 + 296) = v20;
      *(_DWORD *)(a1 + 292) = a2;
      *(unsigned char *)(a1 + 393) = v12;
      *(unsigned char *)(a1 + 396) = v19;
      v23[0] = HIBYTE(a2);
      v23[1] = BYTE2(a2);
      v23[2] = BYTE1(a2);
      v23[3] = a2;
      v23[4] = HIBYTE(a3);
      v23[5] = BYTE2(a3);
      v23[6] = BYTE1(a3);
      v23[7] = a3;
      v23[8] = v12;
      v23[9] = a5;
      v23[10] = 0;
      v23[11] = a7;
      v23[12] = a8;
      uint64_t result = _cg_png_write_complete_chunk((void (**)(void))a1, 1229472850, v23, 0xDuLL);
      *(_DWORD *)(a1 + 776) = a2;
      *(_DWORD *)(a1 + 780) = a3;
      if (!*(unsigned char *)(a1 + 390))
      {
        char v22 = 8;
        if (*(unsigned char *)(a1 + 391) != 3)
        {
          if (*(unsigned __int8 *)(a1 + 392) < 8u) {
            char v22 = 8;
          }
          else {
            char v22 = -8;
          }
        }
        *(unsigned char *)(a1 + 390) = v22;
      }
      *(_DWORD *)(a1 + 76) = 1;
      return result;
    case 4:
      char v15 = 2;
      if (a4 == 8 || a4 == 16) {
        goto LABEL_16;
      }
      CFStringRef v16 = "Invalid bit depth for grayscale+alpha image";
      goto LABEL_45;
    case 6:
      char v15 = 4;
      if (a4 == 8 || a4 == 16) {
        goto LABEL_16;
      }
      CFStringRef v16 = "Invalid bit depth for RGBA image";
      goto LABEL_45;
    default:
      CFStringRef v16 = "Invalid image color type specified";
      goto LABEL_45;
  }
}

void (**_cg_png_write_end(void (**result)(void), uint64_t a2))(void)
{
  if (!result) {
    return result;
  }
  uint64_t v2 = (uint64_t)result;
  if ((*((unsigned char *)result + 76) & 4) == 0)
  {
    uint64_t v8 = "No IDATs written into file";
    goto LABEL_33;
  }
  if (*((unsigned char *)result + 391) == 3 && *((_DWORD *)result + 95) >= (int)*((unsigned __int16 *)result + 188)) {
    png_benign_error((uint64_t)result, "Wrote palette index exceeding num_palette");
  }
  if (*(_DWORD *)(v2 + 812) != *(_DWORD *)(v2 + 808))
  {
    uint64_t v8 = "Not enough frames written";
LABEL_33:
    _cg_png_error((void (**)(void))v2, v8);
  }
  if (a2)
  {
    if ((*(unsigned char *)(a2 + 9) & 2) != 0 && (*(unsigned char *)(v2 + 77) & 2) == 0) {
      png_write_tIME((void (**)(void))v2, (unsigned __int16 *)(a2 + 168));
    }
    if (*(int *)(a2 + 148) >= 1)
    {
      uint64_t v4 = 0;
      uint64_t v5 = 0;
      uint64_t v6 = *(void *)(a2 + 160);
      do
      {
        int v7 = *(_DWORD *)(v6 + v4);
        if (v7 < 1)
        {
          if ((v7 & 0x80000000) == 0)
          {
            png_write_zTXt(v2, *(unsigned __int8 **)(v6 + v4 + 8), *(char **)(v6 + v4 + 16), 0);
            uint64_t v6 = *(void *)(a2 + 160);
LABEL_18:
            *(_DWORD *)(v6 + v4) = -2;
            goto LABEL_19;
          }
          if (v7 != -1) {
            goto LABEL_19;
          }
          png_write_tEXt((void (**)(void))v2, *(unsigned __int8 **)(v6 + v4 + 8), *(char **)(v6 + v4 + 16));
          uint64_t v6 = *(void *)(a2 + 160);
        }
        else
        {
          png_write_iTXt(v2, v7, *(unsigned __int8 **)(v6 + v4 + 8), *(char **)(v6 + v4 + 40), *(char **)(v6 + v4 + 48), *(char **)(v6 + v4 + 16));
          uint64_t v6 = *(void *)(a2 + 160);
          if (*(_DWORD *)(v6 + v4) != -1) {
            goto LABEL_18;
          }
        }
        *(_DWORD *)(v6 + v4) = -3;
LABEL_19:
        ++v5;
        v4 += 56;
      }
      while (v5 < *(int *)(a2 + 148));
    }
    if ((*(unsigned char *)(a2 + 10) & 1) != 0 && (*(unsigned char *)(v2 + 77) & 0x40) == 0) {
      png_write_eXIf(v2, *(Bytef **)(a2 + 240), *(_DWORD *)(a2 + 236));
    }
    write_unknown_chunks(v2, a2, 8u);
  }
  *(_DWORD *)(v2 + 76) |= 8u;

  return png_write_IEND(v2);
}

uint64_t write_unknown_chunks(uint64_t result, uint64_t a2, unsigned __int8 a3)
{
  uint64_t v3 = *(int *)(a2 + 312);
  if ((int)v3 > 0)
  {
    uint64_t v5 = result;
    unint64_t v6 = *(void *)(a2 + 304);
    unint64_t v7 = v6 + 32 * v3;
    do
    {
      if ((*(unsigned char *)(v6 + 24) & a3) != 0)
      {
        uint64_t result = png_handle_as_unknown(v5, (_DWORD *)v6);
        if (result != 1
          && (result == 3 || (*(unsigned char *)(v6 + 3) & 0x20) != 0 || !result && *(_DWORD *)(v5 + 736) == 3))
        {
          unint64_t v8 = *(void *)(v6 + 16);
          if (!v8)
          {
            png_warning(v5, "Writing zero-length unknown chunk");
            unint64_t v8 = *(void *)(v6 + 16);
          }
          uint64_t result = (uint64_t)_cg_png_write_chunk((void (**)(void))v5, (unsigned int *)v6, *(Bytef **)(v6 + 8), v8);
        }
      }
      v6 += 32;
    }
    while (v6 < v7);
  }
  return result;
}

uint64_t _cg_png_set_filter(uint64_t result, int a2, unsigned int a3)
{
  if (result)
  {
    unsigned int v3 = a3;
    uint64_t v4 = result;
    int v5 = (*(unsigned __int8 *)(result + 760) >> 2) & 1;
    if (a2 != 64) {
      int v5 = 0;
    }
    if (a2 && !v5) {
      _cg_png_error((void (**)(void))result, "Unknown custom filter method");
    }
    char v6 = 8;
    switch((char)a3)
    {
      case 0:
        break;
      case 1:
        char v6 = 16;
        break;
      case 2:
        char v6 = 32;
        break;
      case 3:
        char v6 = 64;
        break;
      case 4:
        char v6 = 0x80;
        break;
      case 5:
      case 6:
      case 7:
        uint64_t result = png_app_error(result, "Unknown row filter for method 0");
        char v6 = 8;
        break;
      default:
        char v6 = a3;
        break;
    }
    *(unsigned char *)(v4 + 390) = v6;
    if (*(void *)(v4 + 328))
    {
      if (*(_DWORD *)(v4 + 284) == 1) {
        unsigned int v7 = v3 & 0xFFFFFF1F;
      }
      else {
        unsigned int v7 = v3;
      }
      if (*(_DWORD *)(v4 + 280) == 1) {
        unsigned int v3 = v7 & 0xFFFFFF2F;
      }
      else {
        unsigned int v3 = v7;
      }
      if ((v3 & 0xE0) != 0 && !*(void *)(v4 + 320))
      {
        uint64_t result = png_app_warning(v4, "png_set_filter: UP/AVG/PAETH cannot be added after start");
        v3 &= 0xFFFFFF1F;
      }
      unsigned int v8 = *(unsigned __int8 *)(v4 + 393) * *(unsigned __int8 *)(v4 + 396);
      unsigned int v9 = *(_DWORD *)(v4 + 280);
      BOOL v10 = v8 >= 8;
      unint64_t v11 = (v9 * (unint64_t)v8 + 7) >> 3;
      unint64_t v12 = v9 * (unint64_t)(v8 >> 3);
      if (!v10) {
        unint64_t v12 = v11;
      }
      size_t v13 = v12 + 1;
      if (!*(void *)(v4 + 336))
      {
        uint64_t result = (uint64_t)png_malloc((void (**)(void))v4, v13);
        *(void *)(v4 + 336) = result;
      }
      if (((v3 >> 4) & 1) + ((v3 >> 5) & 1) + ((v3 >> 6) & 1) + ((v3 >> 7) & 1) >= 2 && !*(void *)(v4 + 344))
      {
        uint64_t result = (uint64_t)png_malloc((void (**)(void))v4, v13);
        *(void *)(v4 + 344) = result;
      }
    }
    *(unsigned char *)(v4 + 390) = v3;
  }
  return result;
}

uint64_t _cg_png_set_compression_strategy(uint64_t result, int a2)
{
  if (result)
  {
    *(_DWORD *)(result + 80) |= 1u;
    *(_DWORD *)(result + 236) = a2;
  }
  return result;
}

uint64_t _cg_png_set_compression_level(uint64_t result, int a2)
{
  if (result) {
    *(_DWORD *)(result + 220) = a2;
  }
  return result;
}

void *_cg_png_create_write_struct(unsigned char *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return png_create_write_struct_2(a1, a2, a3, a4, 0, 0, 0);
}

uint64_t IIOImagePixelDataProvider::getAlphaInfo(IIOImagePixelDataProvider *this)
{
  return *((_DWORD *)this + 24) & 0x1F;
}

CFDataRef CGImageMetadataCreateXMPData(CGImageMetadataRef metadata, CFDictionaryRef options)
{
  CGImageMetadataRef v3 = metadata;
  if (metadata)
  {
    CFDictionaryRef v4 = (const __CFDictionary *)*((void *)metadata + 3);
    if (v4) {
      CFDictionaryGetCount(v4);
    }
  }
  kdebug_trace();
  IIOInitDebugFlags();
  if ((~(_WORD)gIIODebugFlags & 0x3000) == 0) {
    ImageIODebugOptions(3, "A", "CGImageMetadataCreateXMPData", 0, 0, -1, 0);
  }
  CFIndex length = 0;
  if (v3)
  {
    CFTypeID v5 = CFGetTypeID(v3);
    if (CGImageMetadataGetTypeID::once != -1) {
      dispatch_once(&CGImageMetadataGetTypeID::once, &__block_literal_global_21);
    }
    if (v5 == CGImageMetadataGetTypeID::id
      && (!options || (CFTypeID v6 = CFGetTypeID(options), v6 == CFDictionaryGetTypeID()))
      && (unsigned int v7 = SerializeMetadataForXMP((char *)v3, (size_t *)&length)) != 0)
    {
      unsigned int v8 = v7;
      CGImageMetadataRef v3 = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const UInt8 *)v7, length);
      free(v8);
      if (v3) {
        CFDataGetLength(v3);
      }
    }
    else
    {
      CGImageMetadataRef v3 = 0;
    }
  }
  kdebug_trace();
  return v3;
}

char *SerializeMetadataForXMP(char *cf, size_t *a2)
{
  if (!a2) {
    return 0;
  }
  SXMPMetaFromMetaCFDataRef data = cf;
  *a2 = 0;
  if (!cf) {
    return SXMPMetaFromMetadata;
  }
  CFTypeID v4 = CFGetTypeID(cf);
  if (v4 != CGImageMetadataGetTypeID()) {
    return 0;
  }
  CFDictionaryRef v5 = (const __CFDictionary *)*((void *)SXMPMetaFromMetadata + 3);
  if (v5)
  {
    if (!CFDictionaryGetCount(v5)) {
      return 0;
    }
  }
  memset(&v10, 0, sizeof(v10));
  if ((IIO_InitializeXMPToolkit() & 1) == 0) {
    return 0;
  }
  SXMPMetaFromMetaCFDataRef data = (char *)CreateSXMPMetaFromMetadata((const CGImageMetadata *)SXMPMetaFromMetadata);
  if (SXMPMetaFromMetadata)
  {
    std::string::erase(&v10, 0, 0xFFFFFFFFFFFFFFFFLL);
    TXMPMeta<std::string>::SerializeToBuffer((uint64_t)SXMPMetaFromMetadata, (uint64_t)&v10, 16, 0, "", "", 0);
    (*(void (**)(char *))(*(void *)SXMPMetaFromMetadata + 8))(SXMPMetaFromMetadata);
    if ((v10.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      size_t size = HIBYTE(v10.__r_.__value_.__r.__words[2]);
    }
    else {
      size_t size = v10.__r_.__value_.__l.__size_;
    }
    unsigned int v7 = (char *)malloc_type_malloc(size, 0x100004077774924uLL);
    SXMPMetaFromMetaCFDataRef data = v7;
    if ((v10.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      unsigned int v8 = &v10;
    }
    else {
      unsigned int v8 = (std::string *)v10.__r_.__value_.__r.__words[0];
    }
    strncpy(v7, (const char *)v8, size);
    *a2 = size;
  }
  IIO_TerminateXMPToolkit();
  if (SHIBYTE(v10.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v10.__r_.__value_.__l.__data_);
  }
  return SXMPMetaFromMetadata;
}

__CFData *CGColorSpaceCopyData(CGColorSpace *a1, int a2)
{
  if (!a1) {
    return 0;
  }
  BaseColorSpace = a1;
  while (1)
  {
    unsigned int Type = CGColorSpaceGetType();
    if (Type != 7) {
      break;
    }
    BaseColorSpace = CGColorSpaceGetBaseColorSpace(BaseColorSpace);
    if (!BaseColorSpace) {
      return 0;
    }
  }
  CFDictionaryRef v5 = 0;
  if (Type <= 0xA && ((1 << Type) & 0x578) != 0)
  {
    CFDataRef v6 = CGColorSpaceCopyICCData(BaseColorSpace);
    if (v6)
    {
      CFDataRef v7 = v6;
      if (bswap32(*((_DWORD *)CFDataGetBytePtr(v6) + 16)) == a2)
      {
        CFDictionaryRef v5 = (__CFData *)CFRetain(v7);
      }
      else
      {
        if (a2 == 4) {
          int v8 = 0x2000000;
        }
        else {
          int v8 = (a2 == 2) << 24;
        }
        MutableCFStringRef Copy = CFDataCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, v7);
        CFDictionaryRef v5 = MutableCopy;
        if (MutableCopy && CFDataGetLength(MutableCopy) >= 68) {
          *((_DWORD *)CFDataGetMutableBytePtr(v5) + 16) = v8;
        }
      }
      CFRelease(v7);
      return v5;
    }
    return 0;
  }
  return v5;
}

float IIODictionary::getFloatFromValue(IIODictionary *this, const __CFString *cf)
{
  float valuePtr = 0.0;
  float v2 = 0.0;
  if (cf)
  {
    CFTypeID v4 = CFGetTypeID(cf);
    if (v4 == CFNumberGetTypeID())
    {
      CFNumberGetValue((CFNumberRef)cf, kCFNumberFloatType, &valuePtr);
      return valuePtr;
    }
    else
    {
      CFTypeID v5 = CFGetTypeID(cf);
      if (v5 == CFStringGetTypeID()) {
        return CFStringGetDoubleValue(cf);
      }
    }
  }
  return v2;
}

double IIODictionary::getFloatForKey(IIODictionary *this, const __CFString *a2)
{
  CFDictionaryRef v2 = (const __CFDictionary *)*((void *)this + 1);
  if (!v2) {
    return 0.0;
  }
  int Value = (IIODictionary *)CFDictionaryGetValue(v2, a2);

  *(float *)&double result = IIODictionary::getFloatFromValue(Value, (const __CFString *)Value);
  return result;
}

void _cg_png_set_sRGB(uint64_t a1, uint64_t a2, unsigned int a3)
{
  if (a1 && a2)
  {
    png_colorspace_set_sRGB(a1, a2 + 52, a3);
    png_colorspace_sync_info(a1, a2);
  }
}

const char *___ZN17IIO_ReaderHandler12UseAppleJPEGEv_block_invoke()
{
  double result = getenv("ImageIO_Use_AppleJPEG");
  if (result)
  {
    double result = (const char *)atoi(result);
    IIO_ReaderHandler::UseAppleJPEG(void)::gUseAppleJPEGuint64_t Plugin = result != 0;
  }
  return result;
}

Class __IIOLockDownModeEnabled_block_invoke()
{
  Class result = NSClassFromString(&cfstr_Lockdownmodema.isa);
  if (result)
  {
    Class result = (Class)[(objc_class *)result shared];
    _ZZZ22IIOLockDownModeEnabledEUb_E20gLockdownModeManager = (uint64_t)result;
    if (result)
    {
      Class result = (Class)[(objc_class *)result enabled];
      IIOLockDownModeEnabled::lockDownModeEnabled = (char)result;
    }
  }
  return result;
}

void AdobeXMPCore_Int::IDOMImplementationRegistry_I::DestoryDOMImplementationRegistry(AdobeXMPCore_Int::IDOMImplementationRegistry_I *this)
{
  AdobeXMPCore_Int::ManageDOMImplementationRegistry((AdobeXMPCore_Int *)1, &v2);
  uint64_t v1 = v3;
  if (v3)
  {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
}

void AdobeXMPCore_Int::ManageDOMImplementationRegistry(AdobeXMPCore_Int *this@<X0>, uint64_t *a2@<X8>)
{
  int v2 = (int)this;
  {
    __cxa_atexit((void (*)(void *))std::shared_ptr<AdobeXMPCore::IDOMImplementationRegistry_v1>::~shared_ptr[abi:ne180100], &AdobeXMPCore_Int::ManageDOMImplementationRegistry(BOOL)::sDOMImplementationRegistry, &dword_188589000);
  }
  uint64_t v4 = AdobeXMPCore_Int::ManageDOMImplementationRegistry(BOOL)::sDOMImplementationRegistry;
  if (v2)
  {
    if (AdobeXMPCore_Int::ManageDOMImplementationRegistry(BOOL)::sDOMImplementationRegistry)
    {
      CFTypeID v5 = (std::__shared_weak_count *)qword_1E91007D8;
      AdobeXMPCore_Int::ManageDOMImplementationRegistry(BOOL)::sDOMImplementationRegistrdouble y = 0;
      qword_1E91007D8 = 0;
      if (!v5)
      {
        *a2 = 0;
        a2[1] = 0;
        return;
      }
      std::__shared_weak_count::__release_shared[abi:ne180100](v5);
      uint64_t v4 = AdobeXMPCore_Int::ManageDOMImplementationRegistry(BOOL)::sDOMImplementationRegistry;
    }
  }
  else if (!AdobeXMPCore_Int::ManageDOMImplementationRegistry(BOOL)::sDOMImplementationRegistry)
  {
    CFDataRef v6 = (void *)AdobeXMPCore_Int::MemoryManagedObject::operator new((AdobeXMPCore_Int::MemoryManagedObject *)0x58);
    AdobeXMPCore_Int::DOMImplementationRegistryImpl::DOMImplementationRegistryImpl(v6);
    CFDataRef v7 = (AdobeXMPCore_Int::RDFDOMParserImpl *)AdobeXMPCore_Int::MemoryManagedObject::operator new((AdobeXMPCore_Int::MemoryManagedObject *)0x80);
    AdobeXMPCore_Int::RDFDOMParserImpl::RDFDOMParserImpl(v7);
  }
  uint64_t v8 = qword_1E91007D8;
  *a2 = v4;
  a2[1] = v8;
  if (v8) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v8 + 8), 1uLL, memory_order_relaxed);
  }
}

void sub_1885E8748(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a12);
  }
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a10);
  }
  _Unwind_Resume(exception_object);
}

CFArrayRef IIOMetadata_Tag::copyValue(IIOMetadata_Tag *this)
{
  CFStringRef v2 = (const __CFString *)*((void *)this + 6);
  CFTypeID v3 = CFGetTypeID(v2);
  int v4 = *((_DWORD *)this + 10);
  if (v4 == 1)
  {
    if (v3 == CFStringGetTypeID())
    {
      CFAllocatorRef v5 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      return (CFArrayRef)CFStringCreateCopy(v5, v2);
    }
    int v4 = *((_DWORD *)this + 10);
  }
  if ((v4 - 2) <= 3)
  {
    if (v3 == CFArrayGetTypeID())
    {
      CFAllocatorRef v7 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      return CFArrayCreateCopy(v7, (CFArrayRef)v2);
    }
    int v4 = *((_DWORD *)this + 10);
  }
  if (v4 == 6)
  {
    CFAllocatorRef v8 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    return CFDictionaryCreateCopy(v8, (CFDictionaryRef)v2);
  }
  else
  {
    LogMetadata("copyValue", 197, "'tag' has an unrecognized value type\n");
    return 0;
  }
}

BOOL imageio_make_nonpurgeable(void *a1, void *a2)
{
  if ((gIIODebugFlags & 0x202) != 0) {
    ImageIOLog("    imageio_make_nonpurgeable value: %p   user_data: %p\n", a1, a2);
  }
  return ImageIO_make_non_purgeable(a1) == 0;
}

uint64_t ImageIO_make_non_purgeable(const void *a1)
{
  if (IIO_XPCServer()) {
    return 0;
  }
  if ((gIIODebugFlags & 0xC0) != 0)
  {
    ImageIOLog("    ImageIO_make_non_purgeable: %14p\n", a1);
    if ((gIIODebugFlags & 0x80) != 0) {
      IIODebug_ShowBacktrace(1);
    }
  }
  int v4 = 0;
  int v3 = MEMORY[0x18C11DC50](*MEMORY[0x1E4F14960], a1, 0, &v4);
  if (v3 && (gIIODebugFlags & 0xC0) != 0) {
    ImageIOLog("    vm_purgable_control-SET_STATE-VM_PURGABLE_NONVOLATILE : %ld\n", v3);
  }
  if (v4 == 2) {
    return 14;
  }
  else {
    return 0;
  }
}

uint64_t HEIFReadPlugin::setupCallback(uint64_t a1, CFDictionaryRef *a2)
{
  IIO_LoadHEIFSymbols();
  int v4 = *(__int16 *)(a1 + 376);
  if (v4 == 12)
  {
    uint64_t v5 = IIOReadPlugin::setupImageProviderCallbackV2(a1, a2);
    goto LABEL_5;
  }
  if (v4 == 1)
  {
    uint64_t v5 = IIOReadPlugin::setupCallback(a1, a2);
LABEL_5:
    uint64_t v6 = v5;
    goto LABEL_7;
  }
  uint64_t v6 = 4294967246;
LABEL_7:
  if ((gIIODebugFlags & 0x30000) != 0) {
    ImageIOLog("       useMainImageForThumbnail: %d\n", *(unsigned __int8 *)(a1 + 498));
  }
  return v6;
}

uint64_t IIOReadPlugin::setupImageProviderCallbackV2(uint64_t a1, CFDictionaryRef *a2)
{
  uint64_t v3 = IIOReadPlugin::prepareGeometry(a1, a2);
  if (!v3) {
    IIOImagePlus::setImageBlockProc(*(IIOImagePlus **)(a1 + 16));
  }
  return v3;
}

void IIO_Reader_ATX::getImageCount(IIO_Reader_ATX *this, IIOImageReadSession *a2, IIODictionary *a3, CGImageSourceStatus *a4, unsigned int *a5)
{
}

void sub_1885E8C68(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t IIO_Reader_HEIF::getImageCount(IIO_Reader_HEIF *this, IIOImageReadSession *a2, IIODictionary *a3, CGImageSourceStatus *a4, unsigned int *a5)
{
  IIO_LoadHEIFSymbols();
  unsigned int v9 = IIOImageReadSession::globalInfoForType(a2, 1212500294);
  if (!v9) {
    operator new();
  }
  int v10 = (*(uint64_t (**)(IIO_Reader_HEIF *, IIOImageRead *, IIOImageReadSession *, IIODictionary *))(*(void *)this + 272))(this, v9, a2, a3);
  if (v10 << 16)
  {
    uint64_t v12 = (__int16)v10;
    LogError("getImageCount", 1140, "*** ERROR: extractImageInfo failed: %d\n", (__int16)v10);
    unsigned int NumberOfMainImages = 0;
    if (!a5) {
      return v12;
    }
    goto LABEL_4;
  }
  unsigned int NumberOfMainImages = GlobalHEIFInfo::getNumberOfMainImages(v9);
  uint64_t v12 = 0;
  if (a5) {
LABEL_4:
  }
    *a5 = NumberOfMainImages;
  return v12;
}

void sub_1885E8E34(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10E1C40D222D63DLL);
  _Unwind_Resume(a1);
}

BOOL IIODictionary::containsKey(IIODictionary *this, const char *a2)
{
  IIOString::IIOString((IIOString *)v6, a2);
  CFDictionaryRef v3 = (const __CFDictionary *)*((void *)this + 1);
  if (v3) {
    BOOL v4 = CFDictionaryContainsKey(v3, key) != 0;
  }
  else {
    BOOL v4 = 0;
  }
  IIOString::~IIOString((IIOString *)v6);
  return v4;
}

void sub_1885E8EB4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  IIOString::~IIOString((IIOString *)va);
  _Unwind_Resume(a1);
}

void IIOString::IIOString(IIOString *this, const char *a2)
{
  *(void *)this = &unk_1ED4E5FF8;
  *((void *)this + 1) = 0;
  if (a2)
  {
    CFStringRef v3 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a2, 0x8000100u);
  }
  else
  {
    LogWarning("IIOString", 453, "IIOString -- 'str' is nil\n");
    CFStringRef v3 = 0;
  }
  *((void *)this + 2) = v3;
}

void IIO_LoadHEIFSymbols()
{
  if (gLoadCMPhotoSymbolsInitOnce != -1) {
    dispatch_once(&gLoadCMPhotoSymbolsInitOnce, &__block_literal_global_7);
  }
  if (gLoadCoreVideoSymbolsInitOnce != -1) {
    dispatch_once(&gLoadCoreVideoSymbolsInitOnce, &__block_literal_global_10);
  }
  if (gLoadCoreMediaSymbolsInitOnce != -1) {
    dispatch_once(&gLoadCoreMediaSymbolsInitOnce, &__block_literal_global_13_0);
  }
  if (gLoadVideoToolboxSymbolsInitOnce != -1)
  {
    dispatch_once(&gLoadVideoToolboxSymbolsInitOnce, &__block_literal_global_16_0);
  }
}

CGImageRef CGImageSourceCreateThumbnailAtIndex(CGImageSourceRef isrc, size_t index, CFDictionaryRef options)
{
  CFDictionaryRef v3 = options;
  memset(v53, 0, 24);
  uint64_t v6 = IIODictionary::IIODictionary((IIODictionary *)v53, options, 1);
  IIOPackSrcInputInfo(v6, index);
  kdebug_trace();
  IIOInitDebugFlags();
  unsigned int v7 = (gIIODebugFlags >> 12) & 3;
  if (v7) {
    ImageIODebugOptions(v7, "A", "CGImageSourceCreateThumbnailAtIndex", isrc, 0, index, v3);
  }
  int v52 = 0;
  if (!isrc)
  {
    LogError("CGImageSourceCreateThumbnailAtIndex", 5133, "*** ERROR: CGImageSourceCreateThumbnailAtIndex: source is nil\n");
LABEL_108:
    uint64_t v13 = 0;
    uint64_t v12 = 0;
    int v14 = 0;
    unsigned int Uint32ForKey = -1;
    LOBYTE(v10) = -1;
    char v49 = -1;
    int BoolForKey = 255;
    int v47 = 255;
    goto LABEL_37;
  }
  CFTypeID v8 = CFGetTypeID(isrc);
  if (CGImageSourceGetTypeID::once != -1) {
    dispatch_once(&CGImageSourceGetTypeID::once, &__block_literal_global_164);
  }
  if (v8 != CGImageSourceGetTypeID::id)
  {
    LogError("CGImageSourceCreateThumbnailAtIndex", 5134, "*** ERROR: CGImageSourceCreateThumbnailAtIndex: source is not a CGImageSourceRef\n");
    goto LABEL_108;
  }
  if (v3)
  {
    CFTypeID v9 = CFGetTypeID(v3);
    if (v9 != CFDictionaryGetTypeID())
    {
      LogError("CGImageSourceCreateThumbnailAtIndex", 5137, "*** ERROR: CGImageSourceCreateThumbnailAtIndex: options parameter is not a CFDictionaryRef - ignoring\n");
      CFDictionaryRef v3 = 0;
    }
  }
  if (IIODictionary::containsKey((IIODictionary *)v53, @"kCGImageSourceCreateThumbnailFromImageAlways"))int BoolForKey = IIODictionary::getBoolForKey((IIODictionary *)v53, @"kCGImageSourceCreateThumbnailFromImageAlways"); {
  else
  }
    int BoolForKey = 255;
  if (IIODictionary::containsKey((IIODictionary *)v53, @"kCGImageSourceCreateThumbnailFromImageIfAbsent"))char v49 = IIODictionary::getBoolForKey((IIODictionary *)v53, @"kCGImageSourceCreateThumbnailFromImageIfAbsent"); {
  else
  }
    char v49 = -1;
  if (IIODictionary::containsKey((IIODictionary *)v53, @"kCGImageSourceCreateThumbnailWithTransform"))int v10 = IIODictionary::getBoolForKey((IIODictionary *)v53, @"kCGImageSourceCreateThumbnailWithTransform"); {
  else
  }
    int v10 = 255;
  if (IIODictionary::containsKey((IIODictionary *)v53, @"kCGImageSourceThumbnailMaxPixelSize"))
  {
    unsigned int Uint32ForKey = IIODictionary::getUint32ForKey((IIODictionary *)v53, @"kCGImageSourceThumbnailMaxPixelSize");
    int v11 = 1;
  }
  else
  {
    unsigned int Uint32ForKey = -1;
    int v11 = 255;
  }
  int v47 = v11;
  uint64_t v12 = *((void *)isrc + 3);
  if (v12 && !IIOImageSource::isProxy((IIOImageSource *)v12))
  {
    if (*(unsigned char *)(v12 + 89))
    {
      LogError("CGImageSourceCreateThumbnailAtIndex", 5157, "*** ERROR: invalid CGImageSourceRef (non-matching hint)\n");
      uint64_t v13 = 0;
      int v14 = 0;
    }
    else
    {
      int v14 = 1848598816;
      if (BoolForKey == 1)
      {
        unsigned __int8 v15 = IIODictionary::containsKey((IIODictionary *)v53, @"kCGImageSourceThumbnailMaxPixelSize");
        char v16 = v10 == 255 ? v15 : 1;
        if ((v16 & 1) == 0)
        {
          pthread_mutex_lock((pthread_mutex_t *)(v12 + 224));
          int v17 = IIOImageSource::createImageAtIndex((IIOImageSource *)v12, index, v53, &v52);
          BOOL v18 = *(IIO_Reader **)(v12 + 104);
          int v19 = 1848598816;
          if (v18) {
            int v19 = IIO_Reader::osType(v18);
          }
          pthread_mutex_unlock((pthread_mutex_t *)(v12 + 224));
          if (v17) {
            goto LABEL_47;
          }
        }
      }
      pthread_mutex_lock((pthread_mutex_t *)(v12 + 224));
      uint64_t v13 = IIOImageSource::createThumbnailAtIndex((IIOImageSource *)v12, index, (IIODictionary *)v53, &v52);
      unint64_t v20 = *(IIO_Reader **)(v12 + 104);
      if (v20) {
        int v14 = IIO_Reader::osType(v20);
      }
      pthread_mutex_unlock((pthread_mutex_t *)(v12 + 224));
    }
  }
  else
  {
    LogError("CGImageSourceCreateThumbnailAtIndex", 5183, "*** ERROR: CGImageSourceGetSource returned NULL\n");
    uint64_t v13 = 0;
    int v14 = 0;
  }
LABEL_37:
  int v17 = (CGImage *)v13;
  if ((gIIODebugFlags & 0x800000000000) != 0)
  {
    int v17 = (CGImage *)v13;
    if (!v13)
    {
      ImageIOLog(" ISSUE: %s:%d:  %s\n", "CGImageSourceCreateThumbnailAtIndex", 5187, "could not create thumbnail-CGImageRef");
      int v17 = 0;
    }
  }
  if (v13 || !v12)
  {
    int v19 = v14;
    if (!v17) {
      goto LABEL_105;
    }
    goto LABEL_47;
  }
  if (IIOImageSource::isProxy((IIOImageSource *)v12)) {
    goto LABEL_102;
  }
  kdebug_trace();
  LODWORD(v21) = v14 >> 24;
  if (v3)
  {
    uint64_t v22 = MEMORY[0x1E4F14390];
    int v23 = v14 < 0
        ? __maskrune(v14 >> 24, 0x40000uLL)
        : *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v21 + 60) & 0x40000;
    uint64_t v26 = v23 ? v21 : 46;
    uint64_t v46 = v26;
    unsigned int v27 = v14 << 8 >> 24;
    int v28 = v14 << 8 < 0 ? __maskrune(v14 << 8 >> 24, 0x40000uLL) : *(_DWORD *)(v22 + 4 * v27 + 60) & 0x40000;
    uint64_t v29 = v28 ? v27 : 46;
    unsigned int v30 = (__int16)v14 >> 8;
    if (v14 << 16 < 0)
    {
      int v32 = __maskrune((__int16)v14 >> 8, 0x40000uLL);
      uint64_t v31 = v22;
    }
    else
    {
      uint64_t v31 = v22;
      int v32 = *(_DWORD *)(v22 + 4 * v30 + 60) & 0x40000;
    }
    int v33 = (v14 << 24) <= 0x7F000000
        ? *(_DWORD *)(v31 + 4 * (char)v14 + 60) & 0x40000
        : __maskrune((char)v14, 0x40000uLL);
    uint64_t v34 = v32 ? v30 : 46;
    uint64_t v35 = v33 ? (char)v14 : 46;
    LogError("CGImageSourceCreateThumbnailAtIndex", 5195, "*** ERROR: CGImageSourceCreateThumbnailAtIndex[%ld] - '%c%c%c%c' - failed to create thumbnail [%d] {alw:%d, abs: %d tra:%d max:%d}\n", index, v46, v29, v34, v35, v52, (char)BoolForKey, v49, (char)v10, Uint32ForKey);
  }
  else
  {
    int v25 = v14 < 0
        ? __maskrune(v14 >> 24, 0x40000uLL)
        : *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v21 + 60) & 0x40000;
    uint64_t v21 = v25 ? v21 : 46;
    unsigned int v36 = v14 << 8 >> 24;
    int v37 = v14 << 8 < 0
        ? __maskrune(v14 << 8 >> 24, 0x40000uLL)
        : *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v36 + 60) & 0x40000;
    uint64_t v38 = v37 ? v36 : 46;
    unsigned int v39 = (__int16)v14 >> 8;
    int v40 = v14 << 16 < 0
        ? __maskrune((__int16)v14 >> 8, 0x40000uLL)
        : *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v39 + 60) & 0x40000;
    int v41 = (v14 << 24) <= 0x7F000000
        ? *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * (char)v14 + 60) & 0x40000
        : __maskrune((char)v14, 0x40000uLL);
    uint64_t v42 = v40 ? v39 : 46;
    uint64_t v43 = v41 ? (char)v14 : 46;
    LogError("CGImageSourceCreateThumbnailAtIndex", 5192, "*** ERROR: CGImageSourceCreateThumbnailAtIndex[%ld] - '%c%c%c%c' - failed to create thumbnail (no options) [%d]\n", index, v21, v38, v42, v43, v52);
  }
  if (BoolForKey != 255)
  {
LABEL_102:
    int v17 = 0;
    int v19 = v14;
    goto LABEL_105;
  }
  if (v47 != 1)
  {
    LogError("CGImageSourceCreateThumbnailAtIndex", 5212, "*** ERROR: CGImageSourceCreateThumbnailAtIndex[%ld]  'FromImageAlways' / 'FromImageIfAbsent' / 'ThumbnailMaxPixelSize' were not specified - no thumbnail created'\n", index);
    goto LABEL_102;
  }
  memset(v51, 0, sizeof(v51));
  IIODictionary::IIODictionary((IIODictionary *)v51, v3, 1);
  IIODictionary::setObjectForKey((IIODictionary *)v51, (const void *)*MEMORY[0x1E4F1CFD0], @"kCGImageSourceCreateThumbnailFromImageAlways");
  pthread_mutex_lock((pthread_mutex_t *)(v12 + 224));
  int v17 = (CGImage *)IIOImageSource::createThumbnailAtIndex((IIOImageSource *)v12, index, (IIODictionary *)v51, &v52);
  double v44 = *(IIO_Reader **)(v12 + 104);
  if (v44) {
    int v19 = IIO_Reader::osType(v44);
  }
  else {
    int v19 = 1848598816;
  }
  pthread_mutex_unlock((pthread_mutex_t *)(v12 + 224));
  IIODictionary::~IIODictionary((IIODictionary *)v51);
  if (v17)
  {
LABEL_47:
    CGImageGetWidth(v17);
    CGImageGetHeight(v17);
    CGImageGetBitsPerPixel(v17);
    CGImageGetBitsPerComponent(v17);
    ColorSpace = CGImageGetColorSpace(v17);
    CGColorSpaceGetModel(ColorSpace);
    CGImageGetImageProvider();
    CGImageGetContentHeadroom();
    CGImageGetBitmapInfo(v17);
    if ((gIIODebugFlags & 0x10000000) != 0)
    {
      CFShow(v17);
      ImageIO_dumpImageData("CreateThumbnailAtIndex", v17);
    }
  }
LABEL_105:
  kdebug_trace();
  IIO_CheckHeadroom("CGImageSourceCreateThumbnailAtIndex", v19, v17, (IIODictionary *)v53);
  IIODictionary::~IIODictionary((IIODictionary *)v53);
  return v17;
}

void sub_1885E989C(_Unwind_Exception *a1)
{
  IIODictionary::~IIODictionary((IIODictionary *)(v1 - 128));
  _Unwind_Resume(a1);
}

uint64_t IIOImageSource::createThumbnailAtIndex(IIOImageSource *this, unint64_t a2, IIODictionary *a3, int *a4)
{
  int v27 = -50;
  *(void *)uint64_t v26 = 0;
  CGImageAlphaInfo v25 = kCGImageAlphaNone;
  unint64_t v24 = 0;
  uint64_t v23 = 0;
  memset(v22, 0, sizeof(v22));
  if (IIOImageSource::bindToReader(this) && IIOImageSource::updatedCount(this) > a2)
  {
    IIODictionary::getBoolForKey(a3, @"kCGImageSourceCreateThumbnailFromImageAlways");
    IIODictionary::getBoolForKey(a3, @"kCGImageSourceCreateThumbnailFromImageIfAbsent");
    IIODictionary::containsKey(a3, @"kCGImageSourceCreateThumbnailFromImageIfAbsent");
    IIODictionary::getBoolForKey(a3, @"kCGImageSourceCreateThumbnailWithTransform");
    IIODictionary::getUint32ForKey(a3, @"Orientation");
    if (IIODictionary::containsKey(a3, @"kCGImageSourceShouldCache")) {
      IIODictionary::getBoolForKey(a3, @"kCGImageSourceShouldCache");
    }
    if (IIODictionary::containsKey(a3, @"kCGImageSourceThumbnailMaxPixelSize"))
    {
      unsigned int Uint32ForKey = IIODictionary::getUint32ForKey(a3, @"kCGImageSourceThumbnailMaxPixelSize");
      (*(void (**)(void))(**((void **)this + 13) + 184))(*((void *)this + 13));
    }
    else
    {
      unsigned int Uint32ForKey = 0;
    }
    IIOImageSource::updateThumbnailInfo(this, a3, &v26[1], v26);
    if (v26[1] <= v26[0]) {
      unsigned int v9 = v26[0];
    }
    else {
      unsigned int v9 = v26[1];
    }
    if (Uint32ForKey) {
      unsigned int v10 = Uint32ForKey;
    }
    else {
      unsigned int v10 = v9;
    }
    if (v26[1] && v26[0] && v10 > v26[1] && v10 > v26[0])
    {
      LogError("createThumbnailAtIndex", 2477, "*** ERROR: kCGImageSourceThumbnailMaxPixelSize: %d is larger than image-dimension: %dx%d\n", v10, v26[1], v26[0]);
      IIODictionary::removeObjectForKey(a3, @"kCGImageSourceThumbnailMaxPixelSize");
      if (v26[1] <= v26[0]) {
        unsigned int v10 = v26[0];
      }
      else {
        unsigned int v10 = v26[1];
      }
    }
    int v11 = getprogname();
    if (!strncasecmp("Camera", v11, 7uLL))
    {
      if (IIODictionary::containsKey(a3, @"kCGImageSourceDecodeRequest"))
      {
        CFStringRef ObjectForKey = (const __CFString *)IIODictionary::getObjectForKey(a3, @"kCGImageSourceDecodeRequest");
        if (CFEqual(ObjectForKey, @"kCGImageSourceDecodeToHDR"))
        {
          if ((IIODictionary::containsKey(a3, @"kCGImageSourceDecodeRequestOptions") & 1) == 0)
          {
            IIODictionary::IIODictionary((IIODictionary *)v21);
            IIODictionary::setObjectForKey(a3, (const void *)v21[1], @"kCGImageSourceDecodeRequestOptions");
            IIODictionary::~IIODictionary((IIODictionary *)v21);
          }
          IIODictionary::setObjectForKeyGroup(a3, (const void *)*MEMORY[0x1E4F1CFC8], @"kCGGenerateFlexGTC", @"kCGImageSourceDecodeRequestOptions");
          if (IIODictionary::getBoolForKeyGroup(a3, @"kCGGenerateFlexGTC", @"kCGImageSourceDecodeRequestOptions"))LogError("createThumbnailAtIndex", 2501, "*** Camera - creating kCGGenerateFlexGTC\n"); {
        }
          }
      }
    }
    *(void *)&double v13 = IIOImageSource::getThumbnailInfoAtIndex((uint64_t)this, 0, v10, (uint64_t)v22).n128_u64[0];
    uint64_t v14 = *((void *)this + 2);
    if (v14)
    {
      uint64_t v15 = CGImageReadSessionCreate(*((void *)this + 2));
      if (v15)
      {
        uint64_t v17 = v15;
        uint64_t v18 = v14;
        uint64_t v19 = v17;
        CGImageSourceGetSource(v18);
        CGImageSourceGetSource(v19);
        operator new();
      }
      _cg_jpeg_mem_term("createThumbnailAtIndex", 2522, "*** Error: CGImageReadSessionCreate returned NULL\n", v16);
    }
    else
    {
      _cg_jpeg_mem_term("createThumbnailAtIndex", 2519, "*** Error: imageReadRef returned NULL\n", v13);
    }
  }
  if (v27) {
    CGImageRelease(0);
  }
  if (a4) {
    *a4 = v27;
  }
  return 0;
}

void sub_1885EAF74(_Unwind_Exception *a1)
{
  IIODictionary::~IIODictionary((IIODictionary *)(v1 - 240));
  _Unwind_Resume(a1);
}

uint64_t IIO_Reader_AppleJPEG::hasCustomThumbnailProc(IIO_Reader_AppleJPEG *this)
{
  return 1;
}

uint64_t IIO_Reader::canApplyTransform(IIO_Reader *this)
{
  return 0;
}

CGColorSpace *IIOImageSource::createThumbnailColorspace(IIOImageSource *this, CGImageRef image, CGImageAlphaInfo *a3, unint64_t *a4)
{
  CGImageAlphaInfo AlphaInfo = CGImageGetAlphaInfo(image);
  ColorSpace = CGImageGetColorSpace(image);
  CGColorSpaceModel Model = CGColorSpaceGetModel(ColorSpace);
  int Type = CGColorSpaceGetType();
  BOOL IsOpaque = _ImageIsOpaque(image);
  if (Model)
  {
    BOOL v12 = IsOpaque;
    if (Model != kCGColorSpaceModelRGB || Type == 7) {
      CGColorSpaceRef v13 = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E4F1DC98]);
    }
    else {
      CGColorSpaceRef v13 = CGColorSpaceRetain(ColorSpace);
    }
    uint64_t v14 = v13;
    *a4 = 4;
    if (v12) {
      CGImageAlphaInfo v15 = kCGImageAlphaNoneSkipFirst;
    }
    else {
      CGImageAlphaInfo v15 = kCGImageAlphaPremultipliedFirst;
    }
    *a3 = v15;
    CGImageGetBitmapInfo(image);
  }
  else
  {
    uint64_t v14 = CGColorSpaceRetain(ColorSpace);
    if (AlphaInfo)
    {
      *a4 = 2;
      *a3 = kCGImageAlphaPremultipliedLast;
    }
    else
    {
      *a4 = 1;
      *a3 = kCGImageAlphaNone;
    }
  }
  if ((gIIODebugFlags & 0x8000300000) != 0)
  {
    CFStringRef Name = CGColorSpaceGetName(v14);
    IIOString::IIOString((IIOString *)v19, Name);
    uint64_t v17 = (const char *)IIOString::utf8String((IIOString *)v19);
    ImageIOLog("COL createThumbnailColorspace: '%s'\n", v17);
    IIOString::~IIOString((IIOString *)v19);
  }
  return v14;
}

void sub_1885EB170(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  IIOString::~IIOString((IIOString *)va);
  _Unwind_Resume(a1);
}

BOOL _ImageIsOpaque(CGImage *a1)
{
  if (_ImageHasMask()) {
    return 0;
  }
  int AlphaInfo = _ImageGetAlphaInfo(a1);
  return AlphaInfo != 7 && (AlphaInfo - 5) < 0xFFFFFFFC;
}

uint64_t _ImageGetAlphaInfo(CGImage *a1)
{
  CGImageAlphaInfo AlphaInfo = CGImageGetAlphaInfo(a1);
  size_t BitsPerPixel = CGImageGetBitsPerPixel(a1);
  ColorSpace = CGImageGetColorSpace(a1);
  if (ColorSpace) {
    size_t NumberOfComponents = CGColorSpaceGetNumberOfComponents(ColorSpace);
  }
  else {
    size_t NumberOfComponents = 0;
  }
  size_t v6 = CGImageGetBitsPerComponent(a1) * NumberOfComponents;
  if (BitsPerPixel == v6) {
    CGImageAlphaInfo v7 = kCGImageAlphaNone;
  }
  else {
    CGImageAlphaInfo v7 = AlphaInfo;
  }
  if (v7) {
    BOOL v8 = 0;
  }
  else {
    BOOL v8 = BitsPerPixel > v6;
  }
  if (v8) {
    return 5;
  }
  else {
    return v7;
  }
}

BOOL _ImageHasMask()
{
  return CGImageGetClipPath() || CGImageGetMask() || CGImageGetMaskingColors() != 0;
}

__n128 IIOImageSource::getThumbnailInfoAtIndex(uint64_t a1, uint64_t a2, unsigned int a3, uint64_t a4)
{
  uint64_t v4 = *(void *)(a1 + 200);
  uint64_t v5 = *(void *)(a1 + 208);
  while (v4 != v5)
  {
    if (*(_DWORD *)(v4 + 28) == a2
      && (*(_DWORD *)(v4 + 12) >= a3 || *(_DWORD *)(v4 + 16) >= a3)
      && (v4 + 40 == v5 || !*(unsigned char *)(v4 + 35)))
    {
      __n128 result = *(__n128 *)v4;
      long long v7 = *(_OWORD *)(v4 + 16);
      *(void *)(a4 + 32) = *(void *)(v4 + 32);
      *(__n128 *)a4 = result;
      *(_OWORD *)(a4 + 16) = v7;
      return result;
    }
    v4 += 40;
  }
  return result;
}

void IIOImageSource::updateThumbnailInfo(IIOImageSource *this, IIODictionary *a2, unsigned int *a3, unsigned int *a4)
{
  if (*((void *)this + 26) != *((void *)this + 25)) {
    return;
  }
  unsigned int v8 = IIOImageSource::isRAWFile(this);
  unsigned int v9 = (IIO_Reader *)*((void *)this + 13);
  if (!v9)
  {
    if (v8) {
      int v11 = 1918990112;
    }
    else {
      int v11 = 1970170734;
    }
    goto LABEL_12;
  }
  int v10 = IIO_Reader::osType(v9);
  if (v8) {
    int v11 = 1918990112;
  }
  else {
    int v11 = v10;
  }
  if (!*((void *)this + 13))
  {
LABEL_12:
    Properties = (IIODictionary *)IIOImageSource::getProperties(this, a2);
    if (Properties) {
      goto LABEL_14;
    }
    goto LABEL_13;
  }
  Properties = (IIODictionary *)*((void *)this + 15);
  if (Properties) {
    goto LABEL_14;
  }
LABEL_13:
  Properties = (IIODictionary *)IIOImageSource::getProperties(this, a2);
LABEL_14:
  LODWORD(v13) = 0;
  if (v11 > 1212829766)
  {
    if (v11 != 1918990112)
    {
      unsigned int Uint32ForKey = 0;
      if (v11 != 1212829767) {
        goto LABEL_64;
      }
    }
LABEL_22:
    if (!Properties)
    {
      LODWORD(v13) = 0;
      unsigned int Uint32ForKey = 0;
      goto LABEL_41;
    }
    double v16 = (const __CFString **)&kCGImagePropertyImages;
    if (v8) {
      double v16 = (const __CFString **)kIIOPropertyRawImagesArray;
    }
    CFDictionaryRef ObjectForKeyGroup = IIODictionary::getObjectForKeyGroup(Properties, *v16, @"{FileContents}");
    CFArrayRef v13 = ObjectForKeyGroup;
    if (ObjectForKeyGroup)
    {
      if (CFArrayGetCount(ObjectForKeyGroup))
      {
        ValueAtIndedouble x = (const __CFDictionary *)CFArrayGetValueAtIndex(v13, 0);
        uint64_t v40 = 0;
        uint64_t v41 = 0;
        uint64_t v42 = 0;
        IIODictionary::IIODictionary((IIODictionary *)&v40, ValueAtIndex);
        LODWORD(v13) = IIODictionary::getUint32ForKey((IIODictionary *)&v40, @"Width");
        unsigned int Uint32ForKey = IIODictionary::getUint32ForKey((IIODictionary *)&v40, @"Height");
        IIODictionary::~IIODictionary((IIODictionary *)&v40);
        if (!v8) {
          goto LABEL_33;
        }
LABEL_31:
        CFArrayRef Value = IIODictionary::getObjectForKeyGroup(Properties, @"Thumbnails", @"{raw}");
        goto LABEL_35;
      }
      ValueAtIndedouble x = 0;
      unsigned int Uint32ForKey = 0;
      LODWORD(v13) = 0;
      if (v8) {
        goto LABEL_31;
      }
    }
    else
    {
      ValueAtIndedouble x = 0;
      unsigned int Uint32ForKey = 0;
      if (v8) {
        goto LABEL_31;
      }
    }
LABEL_33:
    if (!ValueAtIndex)
    {
      CFArrayRef v20 = 0;
LABEL_36:
      uint64_t v40 = 0;
      uint64_t v41 = 0;
      uint64_t v42 = 0;
      IIOArray::IIOArray((IIOArray *)&v40, v20);
      v36[0] = MEMORY[0x1E4F143A8];
      v36[1] = 0x40000000;
      v36[2] = ___ZN14IIOImageSource19updateThumbnailInfoEP13IIODictionaryPjS2__block_invoke;
      _OWORD v36[3] = &__block_descriptor_tmp_90;
      v36[4] = this;
      int v37 = (int)v13;
      unsigned int v38 = Uint32ForKey;
      char v39 = v8;
      IIOArray::enumerate((uint64_t)&v40, (uint64_t)v36);
      unint64_t v21 = *((void *)this + 25);
      unint64_t v22 = *((void *)this + 26);
      unint64_t v23 = 126 - 2 * __clz(0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v22 - v21) >> 3));
      if (v22 == v21) {
        uint64_t v24 = 0;
      }
      else {
        uint64_t v24 = v23;
      }
      std::__introsort<std::_ClassicAlgPolicy,IIOImageSource::updateThumbnailInfo(IIODictionary *,unsigned int *,unsigned int *)::$_0 &,IIOThumbnailInfo *,false>(v21, v22, v24, 1);
      IIOArray::~IIOArray((IIOArray *)&v40);
      if (!v13) {
        goto LABEL_41;
      }
LABEL_40:
      if (Uint32ForKey) {
        goto LABEL_64;
      }
      goto LABEL_41;
    }
    CFArrayRef Value = (const __CFArray *)CFDictionaryGetValue(ValueAtIndex, @"ThumbnailImages");
LABEL_35:
    CFArrayRef v20 = Value;
    goto LABEL_36;
  }
  if (v11 == 1212500291) {
    goto LABEL_22;
  }
  unsigned int Uint32ForKey = 0;
  if (v11 != 1212500307) {
    goto LABEL_64;
  }
  if (!Properties)
  {
    unsigned int Uint32ForKey = 0;
    LODWORD(v13) = 0;
    unsigned int v25 = 72;
    goto LABEL_42;
  }
  CFDictionaryRef ObjectForKey = IIODictionary::getObjectForKey(Properties, @"{HEICS}");
  uint64_t v40 = 0;
  uint64_t v41 = 0;
  uint64_t v42 = 0;
  IIODictionary::IIODictionary((IIODictionary *)&v40, ObjectForKey);
  LODWORD(v13) = IIODictionary::getUint32ForKey((IIODictionary *)&v40, @"CanvasPixelWidth");
  unsigned int Uint32ForKey = IIODictionary::getUint32ForKey((IIODictionary *)&v40, @"CanvasPixelHeight");
  IIODictionary::~IIODictionary((IIODictionary *)&v40);
  if (v13) {
    goto LABEL_40;
  }
LABEL_41:
  unsigned int v25 = HIBYTE(v11);
LABEL_42:
  uint64_t v26 = MEMORY[0x1E4F14390];
  if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v25 + 60) & 0x40000) != 0) {
    uint64_t v27 = v25;
  }
  else {
    uint64_t v27 = 46;
  }
  unsigned int v28 = v11 << 8 >> 24;
  if (v11 << 8 < 0) {
    int v29 = __maskrune(v11 << 8 >> 24, 0x40000uLL);
  }
  else {
    int v29 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v28 + 60) & 0x40000;
  }
  if (v29) {
    uint64_t v30 = v28;
  }
  else {
    uint64_t v30 = 46;
  }
  unsigned int v31 = (__int16)v11 >> 8;
  if (v11 << 16 < 0) {
    int v32 = __maskrune((__int16)v11 >> 8, 0x40000uLL);
  }
  else {
    int v32 = *(_DWORD *)(v26 + 4 * v31 + 60) & 0x40000;
  }
  if (v32) {
    uint64_t v33 = v31;
  }
  else {
    uint64_t v33 = 46;
  }
  if ((v11 << 24) <= 0x7F000000) {
    int v34 = *(_DWORD *)(v26 + 4 * (char)v11 + 60) & 0x40000;
  }
  else {
    int v34 = __maskrune((char)v11, 0x40000uLL);
  }
  if (v34) {
    uint64_t v35 = (char)v11;
  }
  else {
    uint64_t v35 = 46;
  }
  _cg_jpeg_mem_term("updateThumbnailInfo", 2295, "*** ERROR: IIOImageSource::updateThumbnailInfo '%c%c%c%c' did not get image dimensions (%d x %d)\n", v27, v30, v33, v35, v13, Uint32ForKey);
LABEL_64:
  if (a3) {
    *a3 = v13;
  }
  if (a4) {
    *a4 = Uint32ForKey;
  }
}

void sub_1885EB76C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, ...)
{
  va_start(va, a14);
  IIODictionary::~IIODictionary((IIODictionary *)va);
  _Unwind_Resume(a1);
}

__n128 IIOImageSource::makeThumbTransform@<Q0>(float a1@<S0>, float a2@<S1>, unint64_t a3@<X1>, unint64_t a4@<X2>, int a5@<W3>, uint64_t a6@<X8>)
{
  uint64_t v55 = *MEMORY[0x1E4F143B8];
  float v7 = a2 / a1;
  if (a2 <= a1) {
    float v7 = 1.0;
  }
  BOOL v8 = a1 <= a2;
  float v9 = a1 / a2;
  v14[0] = v7;
  v14[1] = 0.0;
  v14[2] = 0.0;
  if (v8) {
    float v9 = 1.0;
  }
  void v14[3] = v9;
  _OWORD v14[4] = 0.0;
  v14[5] = 0.0;
  double v15 = (float)-v7;
  uint64_t v16 = 0;
  uint64_t v17 = 0;
  double v18 = v9;
  double v19 = (float)(v7 * (float)a3);
  uint64_t v20 = 0;
  double v21 = v15;
  uint64_t v22 = 0;
  uint64_t v23 = 0;
  double v24 = (float)-v9;
  double v25 = v19;
  double v26 = (float)(v9 * (float)a4);
  double v27 = v7;
  uint64_t v28 = 0;
  uint64_t v29 = 0;
  double v30 = v24;
  uint64_t v31 = 0;
  double v32 = v26;
  uint64_t v33 = 0;
  double v34 = v15;
  double v35 = v24;
  uint64_t v36 = 0;
  double v37 = v26;
  double v38 = v19;
  uint64_t v39 = 0;
  double v40 = v15;
  double v41 = v9;
  uint64_t v42 = 0;
  uint64_t v43 = 0;
  double v44 = v19;
  uint64_t v45 = 0;
  double v46 = v7;
  double v47 = v9;
  long long v49 = 0u;
  long long v48 = 0u;
  double v50 = v7;
  double v51 = v24;
  uint64_t v52 = 0;
  double v53 = v26;
  uint64_t v54 = 0;
  if ((a5 - 9) >= 0xFFFFFFF8) {
    int v10 = a5 - 1;
  }
  else {
    int v10 = 0;
  }
  int v11 = &v14[6 * v10];
  __n128 result = *(__n128 *)v11;
  long long v13 = *((_OWORD *)v11 + 2);
  *(_OWORD *)(a6 + 16) = *((_OWORD *)v11 + 1);
  *(_OWORD *)(a6 + 32) = v13;
  *(__n128 *)a6 = result;
  return result;
}

uint64_t IIOImageSource::getProperties(IIOImageSource *this, IIODictionary *a2)
{
  if (!IIOImageSource::bindToReader(this)) {
    return 0;
  }
  uint64_t Source = (IIOImageRead *)CGImageSourceGetSource(*((void *)this + 2));
  uint64_t v5 = Source;
  if (!*((void *)this + 15)) {
    goto LABEL_5;
  }
  if (!IIOImageRead::isFinal(Source))
  {
    if (!*((void *)this + 15)) {
LABEL_5:
    }
      operator new();
    CFIndex Size = IIOImageRead::getSize(v5);
    IIONumber::IIONumber((IIONumber *)v24, Size);
    IIOImageSource::addProperty(this, 0, @"FileSize", v25);
    IIONumber::~IIONumber((IIONumber *)v24);
    if ((*(unsigned int (**)(void))(**((void **)this + 13) + 176))(*((void *)this + 13)))
    {
      uint64_t v7 = CGImageReadSessionCreate(*((void *)this + 2));
      if (v7)
      {
        BOOL v8 = (const void *)v7;
        int v23 = -1;
        float v9 = (const void *)IIO_Reader::utType(*((IIO_Reader **)this + 13));
        IIODebugCallbackPriv(v9, "addSourceProps");
        v24[0] = 0;
        v24[1] = 0;
        double v25 = 0;
        IIODictionary::IIODictionary((IIODictionary *)v24);
        int v10 = (const void *)*MEMORY[0x1E4F1CFD0];
        int v11 = (const void *)*MEMORY[0x1E4F1CFC8];
        if (*((unsigned char *)this + 50)) {
          BOOL v12 = (const void *)*MEMORY[0x1E4F1CFD0];
        }
        else {
          BOOL v12 = (const void *)*MEMORY[0x1E4F1CFC8];
        }
        IIODictionary::setObjectForKey((IIODictionary *)v24, v12, @"shouldExposeMultiFrameContents");
        if (*((unsigned char *)this + 52)) {
          long long v13 = v10;
        }
        else {
          long long v13 = v11;
        }
        IIODictionary::setObjectForKey((IIODictionary *)v24, v13, @"useImageSequence");
        IIONumber::IIONumber((IIONumber *)v22, *((char *)this + 53));
        IIODictionary::setObjectForKey((uint64_t)v24, (uint64_t)v22, @"kCGImageSourceForceUseServer");
        IIONumber::~IIONumber((IIONumber *)v22);
        uint64_t v14 = (IIO_ReaderHandler *)(*(uint64_t (**)(void, const void *, void, void, void *, IIODictionary *, int *))(**((void **)this + 13) + 48))(*((void *)this + 13), v8, *((void *)this + 1), *((void *)this + 15), v24, a2, &v23);
        if (v14 == -48)
        {
          ReaderHandler = (IIO_ReaderHandler *)IIO_ReaderHandler::GetReaderHandler(v14);
          double v19 = IIO_ReaderHandler::readerForType(ReaderHandler, 1212500291);
          if (v19)
          {
            __n128 v20 = _cg_jpeg_mem_term("getProperties", 1616, "    JPEG contains 'MPF' marker --> switch to 'HEIC' plugin\n");
            *((void *)this + 13) = v19;
            (*(void (**)(IIO_Reader *, const void *, void, void, void *, IIODictionary *, int *, __n128))(*(void *)v19 + 48))(v19, v8, *((void *)this + 1), *((void *)this + 15), v24, a2, &v23, v20);
          }
        }
        else if (v14 == -1400)
        {
          ImageIOLog(" retrying 'updateSourceProperties' (ImageIOXPCService crashed?)\n");
          int v15 = (*(uint64_t (**)(void, const void *, void, void, void *, IIODictionary *, int *))(**((void **)this + 13) + 48))(*((void *)this + 13), v8, *((void *)this + 1), *((void *)this + 15), v24, a2, &v23);
          uint64_t v16 = "";
          if (!v15) {
            uint64_t v16 = "";
          }
          ImageIOLog("%s retrying 'updateSourceProperties'  err: %d\n", v16, v15);
        }
        int v21 = v23;
        pthread_mutex_lock((pthread_mutex_t *)((char *)this + 288));
        *((_DWORD *)this + 28) = v21;
        pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 288));
        CFRelease(v8);
        IIODictionary::~IIODictionary((IIODictionary *)v24);
      }
    }
  }
  return *((void *)this + 15);
}

void sub_1885EBC08(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  IIODictionary::~IIODictionary((IIODictionary *)va);
  _Unwind_Resume(a1);
}

uint64_t IIO_Reader_AppleJPEG::hasCustomSourcePropertiesProc(IIO_Reader_AppleJPEG *this)
{
  return 1;
}

uint64_t IIO_Reader_AppleJPEG::updateSourceProperties(IIO_Reader_AppleJPEG *this, IIOImageRead **a2, IIODictionary *a3, IIODictionary *a4, IIODictionary *a5, CGImageSourceStatus *a6)
{
  if (a2) {
    BOOL v7 = IIOImageReadSession::mapData(a2);
  }
  else {
    BOOL v7 = 0;
  }
  uint64_t v34 = 0;
  long long v32 = 0u;
  long long v33 = 0u;
  long long v30 = 0u;
  long long v31 = 0u;
  IIOScanner::IIOScanner((IIOScanner *)&v30, (IIOImageReadSession *)a2);
  GlobalHEIFInfo::setShouldExposeMultiFrameContents((uint64_t)&v30, 0);
  if (IIOScanner::getVal16((IIOScanner *)&v30) != 65496) {
    goto LABEL_42;
  }
  for (unsigned __int16 i = IIOScanner::getVal16((IIOScanner *)&v30); ; unsigned __int16 i = IIOScanner::getVal16((IIOScanner *)&v30))
  {
    if ((i & 0xFFF0) != 0xFFE0) {
      goto LABEL_42;
    }
    unsigned int Val16 = IIOScanner::getVal16((IIOScanner *)&v30);
    unsigned int v10 = Val16;
    if (i == 65506 && Val16 >= 5) {
      break;
    }
LABEL_11:
    IIOScanner::skip((uint64_t)&v30, v10 - 2);
  }
  unint64_t v11 = *((void *)&v31 + 1);
  if (IIOScanner::getVal32((IIOScanner *)&v30) != 1297106432)
  {
    IIOScanner::seek((IIOScanner *)&v30, v11);
    goto LABEL_11;
  }
  uint64_t v12 = *((void *)&v31 + 1);
  if (IIOScanner::getVal16((IIOScanner *)&v30) == 18761) {
    GlobalHEIFInfo::setShouldExposeMultiFrameContents((uint64_t)&v30, 1);
  }
  if (IIOScanner::getVal16((IIOScanner *)&v30) != 42)
  {
LABEL_42:
    uint64_t v13 = 0;
    goto LABEL_43;
  }
  BOOL v27 = v7;
  if (IIOScanner::getVal32((IIOScanner *)&v30) != 8)
  {
    exception = __cxa_allocate_exception(4uLL);
    _DWORD *exception = -1;
    __cxa_throw(exception, MEMORY[0x1E4FBA3A8], 0);
  }
  uint64_t v13 = IIOScanner::getVal16((IIOScanner *)&v30);
  unsigned int v29 = 0;
  uint64_t v28 = 0;
  if (!v13) {
    goto LABEL_39;
  }
  int v14 = 0;
  unsigned int v15 = 0;
  int v16 = 0;
  do
  {
    IIOScanner::getTiffTag((uint64_t)&v30, (uint64_t)&v28);
    if ((unsigned __int16)v28 == 45057)
    {
      unsigned int v15 = v29;
    }
    else if ((unsigned __int16)v28 == 45058)
    {
      IIOScanner::seek((IIOScanner *)&v30, v12 + v29, 0);
      if (v15)
      {
        unsigned int v17 = v15;
        do
        {
          int Val32 = IIOScanner::getVal32((IIOScanner *)&v30);
          IIOScanner::skip((uint64_t)&v30, 8);
          int v19 = IIOScanner::getVal16((IIOScanner *)&v30);
          int v20 = v19 | IIOScanner::getVal16((IIOScanner *)&v30);
          if ((Val32 & 0xFFFFFF) != 0) {
            int v21 = v16;
          }
          else {
            int v21 = 1;
          }
          if (v20)
          {
            int v22 = 10;
          }
          else
          {
            int v16 = v21;
            int v22 = 8 * ((Val32 & 0xFFFFFF) == 0);
          }
          if (v22) {
            BOOL v23 = v22 == 10;
          }
          else {
            BOOL v23 = 1;
          }
          if (!v23) {
            break;
          }
          --v17;
        }
        while (v17);
      }
    }
    ++v14;
  }
  while (v14 != v13);
  if ((v16 & 1) == 0)
  {
    uint64_t v13 = 0;
LABEL_39:
    BOOL v7 = v27;
    goto LABEL_43;
  }
  kdebug_trace();
  BOOL v7 = v27;
  uint64_t v13 = 4294967248;
LABEL_43:
  char v25 = !v7;
  if (!a2) {
    char v25 = 1;
  }
  if ((v25 & 1) == 0) {
    IIOImageReadSession::unmapData((const char **)a2);
  }
  IIOScanner::~IIOScanner((IIOScanner *)&v30);
  return v13;
}

uint64_t GlobalHEIFInfo::setShouldExposeMultiFrameContents(uint64_t this, char a2)
{
  *(unsigned char *)(this + 68) = a2;
  return this;
}

void IIOImageSource::addProperty(IIOImageSource *this, const __CFString *a2, const __CFString *a3, const void *a4)
{
  if (a3)
  {
    uint64_t v4 = (IIODictionary *)*((void *)this + 15);
    if (!v4) {
      operator new();
    }
    if (a2)
    {
      if (a4)
      {
        IIODictionary::setObjectForKeyGroup(v4, a4, a3, a2);
      }
      else
      {
        IIODictionary::removeObjectForKeyGroup(v4, a3, a2);
      }
    }
    else if (a4)
    {
      IIODictionary::setObjectForKey(v4, a4, a3);
    }
    else
    {
      IIODictionary::removeObjectForKey(v4, a3);
    }
  }
  else
  {
    LogError("addProperty", 1543, "*** ERROR: key parameter is nil\n", a4);
  }
}

void sub_1885EC0F0(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10A1C4047070A01);
  _Unwind_Resume(a1);
}

uint64_t IIOImagePlus::getSourceGeom(IIOImagePlus *this)
{
  return (uint64_t)this + 40;
}

uint64_t IIOImagePlus::getValidRows(IIOImagePlus *this)
{
  return *((void *)this + 29);
}

uint64_t IIO_Reader::canScaleThumbnailToFinalSize(IIO_Reader *this)
{
  return 0;
}

uint64_t IIO_Reader::callUpdateSourceProperties(uint64_t a1, uint64_t a2, uint64_t a3, IIODictionary *a4, uint64_t a5, uint64_t a6, _DWORD *a7)
{
  if ((IIO_XPCServer() & 1) != 0
    || ((int v14 = (IIOImageRead *)CGImageSourceGetRead(a3), (v15 = v14) == 0)
      ? (char v16 = -1)
      : (int v14 = (IIOImageRead *)IIOImageRead::forceUseServer(v14), v16 = (char)v14),
        uint64_t IIOXPCClient = (IIOXPCClient *)IIOXPCClient::GetIIOXPCClient(v14),
        !IIOXPCClient::useServerForSourceProperties((uint64_t)IIOXPCClient, v15, a1, v16)))
  {
    uint64_t Source = CGImageSourceGetSource(a2);
    double v37 = *(uint64_t (**)(uint64_t, uint64_t, IIODictionary *, uint64_t, uint64_t, _DWORD *))(*(void *)a1 + 56);
    return v37(a1, Source, a4, a5, a6, a7);
  }
  else
  {
    kdebug_trace();
    xpc_object_t v18 = xpc_dictionary_create(0, 0, 0);
    if (v18)
    {
      int v19 = v18;
      int v20 = (IIOImageReadSession *)CGImageSourceGetSource(a2);
      BOOL v78 = 0;
      xpc_object_t v21 = iio_xpc_add_message_dict(v19);
      xpc_object_t v22 = iio_xpc_add_source_dict(v19);
      xpc_dictionary_set_uint64(v19, "iio_xpc_message_id", 3uLL);
      memset(v77, 0, sizeof(v77));
      IIOString::IIOString((IIOString *)v77, **(const void ***)(a1 + 8));
      BOOL v23 = (const char *)IIOString::utf8String((IIOString *)v77);
      xpc_dictionary_set_string(v22, "iio_xpc_src_utitype", v23);
      xpc_dictionary_set_uint64(v22, "iio_xpc_src_ostype", *(unsigned int *)(a1 + 24));
      IIOImageReadSession::addDataToXPCDictionary(v20, v19, &v78);
      iio_xpc_dictionary_add_CFDictionary(v22, "iio_xpc_src_options");
      if (a6) {
        iio_xpc_dictionary_add_CFDictionary(v21, "iio_xpc_msg_call_options");
      }
      iio_xpc_dictionary_add_CFDictionary(v22, "iio_xpc_src_properties");
      double v24 = (_xpc_connection_s *)IIOXPCClient::xpc_connection(IIOXPCClient);
      char v25 = (dispatch_queue_s *)IIOXPCClient::xpc_queue(IIOXPCClient);
      xpc_object_t v26 = IIOXPCClient::send_message_with_reply(IIOXPCClient, v24, v25, v19);
      BOOL v27 = v26;
      if (v26)
      {
        xpc_object_t message_dict = iio_xpc_get_message_dict(v26);
        xpc_object_t source_dict = iio_xpc_get_source_dict(v27);
        uint64_t error_code = iio_xpc_dictionary_get_error_code(message_dict);
        uint64_t v32 = error_code;
        if (error_code)
        {
          if (error_code == -1400)
          {
            int v33 = *(_DWORD *)(a1 + 24);
            unsigned int v34 = v33 >> 24;
            if (v33 < 0)
            {
              int v35 = __maskrune(v34, 0x40000uLL);
              int v33 = *(_DWORD *)(a1 + 24);
            }
            else
            {
              int v35 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v34 + 60) & 0x40000;
            }
            if (v35) {
              uint64_t v46 = (v33 >> 24);
            }
            else {
              uint64_t v46 = 46;
            }
            unsigned int v47 = v33 << 8 >> 24;
            if (v33 << 8 < 0)
            {
              int v48 = __maskrune(v47, 0x40000uLL);
              int v33 = *(_DWORD *)(a1 + 24);
            }
            else
            {
              int v48 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v47 + 60) & 0x40000;
            }
            if (v48) {
              uint64_t v52 = (v33 << 8 >> 24);
            }
            else {
              uint64_t v52 = 46;
            }
            unsigned int v53 = (__int16)v33 >> 8;
            if (v33 << 16 < 0)
            {
              int v54 = __maskrune(v53, 0x40000uLL);
              int v33 = *(_DWORD *)(a1 + 24);
            }
            else
            {
              int v54 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v53 + 60) & 0x40000;
            }
            if (v54) {
              uint64_t v58 = ((__int16)v33 >> 8);
            }
            else {
              uint64_t v58 = 46;
            }
            if ((v33 << 24) <= 0x7F000000) {
              int v59 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * (char)v33 + 60) & 0x40000;
            }
            else {
              int v59 = __maskrune((char)v33, 0x40000uLL);
            }
            if (v59) {
              uint64_t v60 = *(char *)(a1 + 24);
            }
            else {
              uint64_t v60 = 46;
            }
            IIOXPCLog(" ImageIOXPC [%c%c%c%c]: XPC_READPLUGIN_SOURCEPROPERTIES XPC connection interrupted\n", v46, v52, v58, v60);
          }
          else
          {
            int v42 = *(_DWORD *)(a1 + 24);
            unsigned int v43 = v42 >> 24;
            uint64_t v44 = MEMORY[0x1E4F14390];
            if (v42 < 0)
            {
              int v45 = __maskrune(v43, 0x40000uLL);
              int v42 = *(_DWORD *)(a1 + 24);
            }
            else
            {
              int v45 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v43 + 60) & 0x40000;
            }
            if (v45) {
              uint64_t v49 = (v42 >> 24);
            }
            else {
              uint64_t v49 = 46;
            }
            unsigned int v50 = v42 << 8 >> 24;
            if (v42 << 8 < 0)
            {
              int v51 = __maskrune(v50, 0x40000uLL);
              int v42 = *(_DWORD *)(a1 + 24);
            }
            else
            {
              int v51 = *(_DWORD *)(v44 + 4 * v50 + 60) & 0x40000;
            }
            if (v51) {
              uint64_t v55 = (v42 << 8 >> 24);
            }
            else {
              uint64_t v55 = 46;
            }
            unsigned int v56 = (__int16)v42 >> 8;
            if (v42 << 16 < 0)
            {
              int v57 = __maskrune(v56, 0x40000uLL);
              int v42 = *(_DWORD *)(a1 + 24);
            }
            else
            {
              int v57 = *(_DWORD *)(v44 + 4 * v56 + 60) & 0x40000;
            }
            if (v57) {
              uint64_t v61 = ((__int16)v42 >> 8);
            }
            else {
              uint64_t v61 = 46;
            }
            if ((v42 << 24) <= 0x7F000000) {
              int v62 = *(_DWORD *)(v44 + 4 * (char)v42 + 60) & 0x40000;
            }
            else {
              int v62 = __maskrune((char)v42, 0x40000uLL);
            }
            if (v62) {
              uint64_t v63 = *(char *)(a1 + 24);
            }
            else {
              uint64_t v63 = 46;
            }
            IIOXPCLog(" ImageIOXPC [%c%c%c%c]: XPC_READPLUGIN_SOURCEPROPERTIES error: %lld\n", v49, v55, v61, v63, (int)v32);
          }
        }
        else if (source_dict)
        {
          int v39 = *(_DWORD *)(a1 + 24);
          unsigned int v40 = v39 >> 24;
          if (v39 < 0)
          {
            int v41 = __maskrune(v40, 0x40000uLL);
            int v39 = *(_DWORD *)(a1 + 24);
          }
          else
          {
            int v41 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v40 + 60) & 0x40000;
          }
          LODWORD(v64) = v39 >> 24;
          if (v41) {
            uint64_t v64 = v64;
          }
          else {
            uint64_t v64 = 46;
          }
          uint64_t v75 = v64;
          unsigned int v65 = v39 << 8 >> 24;
          if (v39 << 8 < 0)
          {
            int v66 = __maskrune(v65, 0x40000uLL);
            int v39 = *(_DWORD *)(a1 + 24);
          }
          else
          {
            int v66 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v65 + 60) & 0x40000;
          }
          LODWORD(v67) = v39 << 8 >> 24;
          if (v66) {
            uint64_t v67 = v67;
          }
          else {
            uint64_t v67 = 46;
          }
          uint64_t v74 = v67;
          unsigned int v68 = (__int16)v39 >> 8;
          if (v39 << 16 < 0)
          {
            int v69 = __maskrune(v68, 0x40000uLL);
            int v39 = *(_DWORD *)(a1 + 24);
          }
          else
          {
            int v69 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v68 + 60) & 0x40000;
          }
          if (v69) {
            uint64_t v70 = ((__int16)v39 >> 8);
          }
          else {
            uint64_t v70 = 46;
          }
          if ((v39 << 24) <= 0x7F000000) {
            int v71 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * (char)v39 + 60) & 0x40000;
          }
          else {
            int v71 = __maskrune((char)v39, 0x40000uLL);
          }
          if (v71) {
            uint64_t v72 = *(char *)(a1 + 24);
          }
          else {
            uint64_t v72 = 46;
          }
          IIOXPCLog(" ImageIOXPC [%c%c%c%c]: XPC_READPLUGIN_SOURCEPROPERTIES: OK\n", v75, v74, v70, v72);
          CFDictionaryRef v73 = (const __CFDictionary *)iio_xpc_dictionary_copy_CFDictionary(source_dict, "iio_xpc_src_properties");
          if (v73)
          {
            memset(v76, 0, sizeof(v76));
            IIODictionary::IIODictionary((IIODictionary *)v76, v73, 1);
            IIODictionary::removeAllObjects(a4);
            IIODictionary::appendDictionary(a4, v76);
            CFRelease(v73);
            IIODictionary::~IIODictionary((IIODictionary *)v76);
          }
          *a7 = xpc_dictionary_get_int64(source_dict, "iio_xpc_src_status");
        }
        _cg_jpeg_mem_term(IIOXPCClient, v27, v31);
        xpc_release(v27);
      }
      else
      {
        IIOXPCLog(" ImageIOXPC: XPC_READPLUGIN_SOURCEPROPERTIES error null-reply\n");
        uint64_t v32 = 4294967246;
      }
      if (v78)
      {
        if (v20) {
          IIOImageReadSession::releaseBytePointer((IIOImageRead **)v20, v78);
        }
      }
      xpc_release(v19);
      IIOString::~IIOString((IIOString *)v77);
    }
    else
    {
      uint64_t v32 = 4294967246;
    }
    kdebug_trace();
    return v32;
  }
}

void sub_1885EC7D4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  IIOString::~IIOString((IIOString *)va);
  _Unwind_Resume(a1);
}

uint64_t IIOXPCClient::useServerForSourceProperties(uint64_t a1, IIOImageRead *a2, uint64_t a3, int a4)
{
  return IIOXPCClient::useServerForCall(a1, a2, a3, a4, 3, 1);
}

uint64_t CGImageSourceGetRead(uint64_t a1)
{
  if (a1 && (uint64_t v1 = *(void *)(a1 + 24)) != 0) {
    return CGImageSourceGetSource(*(void *)(v1 + 16));
  }
  else {
    return 0;
  }
}

uint64_t IIOImageReadSession::setGlobalInfo(IIOImageRead **this, int a2, void *a3, void (*a4)(void *))
{
  return IIOImageRead::setGlobalInfoPtr(this[4], a2, a3, a4);
}

void GlobalHEIFInfo::GlobalHEIFInfo(GlobalHEIFInfo *this)
{
  *(void *)this = &unk_1ED4E1148;
  *(_OWORD *)((char *)this + 8) = 0u;
  CFStringRef v2 = (char *)this + 32;
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 40) = 0u;
  std::vector<_APPx *>::resize((uint64_t)this + 8, 0);
  std::vector<_APPx *>::resize((uint64_t)v2, 0);
  *((void *)this + 7) = 0;
  *((void *)this + 8) = 0;
}

void sub_1885EC8B8(_Unwind_Exception *exception_object)
{
  uint64_t v4 = v3;
  size_t v6 = *v4;
  if (*v4)
  {
    *(void *)(v1 + 40) = v6;
    operator delete(v6);
  }
  BOOL v7 = *v2;
  if (*v2)
  {
    *(void *)(v1 + 16) = v7;
    operator delete(v7);
  }
  _Unwind_Resume(exception_object);
}

void std::vector<_APPx *>::resize(uint64_t a1, unint64_t a2)
{
  unint64_t v2 = (uint64_t)(*(void *)(a1 + 8) - *(void *)a1) >> 3;
  if (a2 <= v2)
  {
    if (a2 < v2) {
      *(void *)(a1 + 8) = *(void *)a1 + 8 * a2;
    }
  }
  else
  {
    std::vector<_APPx *>::__append((void **)a1, a2 - v2);
  }
}

uint64_t GlobalHEIFInfo::setUseHEIFSequence(uint64_t this, char a2)
{
  *(unsigned char *)(this + 71) = a2;
  return this;
}

uint64_t IIOImageRead::setGlobalInfoPtr(IIOImageRead *this, int a2, void *a3, void (*a4)(void *))
{
  BOOL v8 = (pthread_mutex_t *)((char *)this + 88);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 88));
  uint64_t v9 = *((void *)this + 19);
  unint64_t v10 = *((void *)this + 20);
  if (v9 == v10)
  {
LABEL_5:
    unint64_t v12 = *((void *)this + 21);
    if (v10 >= v12)
    {
      unint64_t v14 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v10 - v9) >> 3);
      unint64_t v15 = v14 + 1;
      if (v14 + 1 > 0xAAAAAAAAAAAAAAALL) {
        std::vector<IIOTag *>::__throw_length_error[abi:ne180100]();
      }
      unint64_t v16 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v12 - v9) >> 3);
      if (2 * v16 > v15) {
        unint64_t v15 = 2 * v16;
      }
      if (v16 >= 0x555555555555555) {
        unint64_t v17 = 0xAAAAAAAAAAAAAAALL;
      }
      else {
        unint64_t v17 = v15;
      }
      if (v17) {
        xpc_object_t v18 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::string>>((uint64_t)this + 168, v17);
      }
      else {
        xpc_object_t v18 = 0;
      }
      int v19 = &v18[24 * v14];
      int v20 = &v18[24 * v17];
      *(void *)int v19 = a3;
      *((void *)v19 + 1) = a4;
      *((_DWORD *)v19 + 4) = a2;
      *((_DWORD *)v19 + 5) = 0;
      uint64_t v13 = v19 + 24;
      xpc_object_t v22 = (char *)*((void *)this + 19);
      xpc_object_t v21 = (char *)*((void *)this + 20);
      if (v21 != v22)
      {
        do
        {
          long long v23 = *(_OWORD *)(v21 - 24);
          *((void *)v19 - 1) = *((void *)v21 - 1);
          *(_OWORD *)(v19 - 24) = v23;
          v19 -= 24;
          v21 -= 24;
        }
        while (v21 != v22);
        xpc_object_t v21 = (char *)*((void *)this + 19);
      }
      *((void *)this + 19) = v19;
      *((void *)this + 20) = v13;
      *((void *)this + 21) = v20;
      if (v21) {
        operator delete(v21);
      }
    }
    else
    {
      *(void *)unint64_t v10 = a3;
      *(void *)(v10 + 8) = a4;
      uint64_t v13 = (char *)(v10 + 24);
      *(_DWORD *)(v10 + 16) = a2;
      *(_DWORD *)(v10 + 20) = 0;
    }
    *((void *)this + 20) = v13;
  }
  else
  {
    uint64_t v11 = *((void *)this + 19);
    while (*(_DWORD *)(v11 + 16) != a2)
    {
      v11 += 24;
      if (v11 == v10) {
        goto LABEL_5;
      }
    }
    (*(void (**)(void))(v11 + 8))(*(void *)v11);
    *(void *)uint64_t v11 = a3;
    *(void *)(v11 + 8) = a4;
    *(_DWORD *)(v11 + 16) = a2;
    *(_DWORD *)(v11 + 20) = 0;
  }

  return pthread_mutex_unlock(v8);
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<std::string>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0xAAAAAAAAAAAAAABLL) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  return operator new(24 * a2);
}

uint64_t IIOScanner::validateBuffer(unsigned __int8 **this, const char *a2)
{
  ERROR_ImageIO_DataBufferIsNotReadable(this[1]);
  uint64_t v3 = (uint64_t)this[1];
  uint64_t v4 = (uint64_t)(this[2] - 1);

  return ERROR_ImageIO_DataBufferIsNotBigEnough(v3, v4);
}

uint64_t ERROR_ImageIO_DataBufferIsNotBigEnough(uint64_t a1, uint64_t a2)
{
  return *(unsigned __int8 *)(a1 + a2);
}

uint64_t ASTCReadPlugin::initialize(ASTCReadPlugin *this, IIODictionary *a2)
{
  uint64_t v119 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = (const void *)*((void *)this + 59);
  if (v3) {
  else
  }
    uint64_t v4 = 0;
  uint64_t v109 = 0;
  long long v107 = 0u;
  long long v108 = 0u;
  long long v105 = 0u;
  long long v106 = 0u;
  IIOScanner::IIOScanner((IIOScanner *)&v105, *((IIOImageReadSession **)this + 3));
  if (!*((unsigned char *)this + 341)) {
    goto LABEL_128;
  }
  unint64_t v5 = v106;
  if (IIOScanner::getBytesAtOffset((IIOScanner *)&v105, (char *)this + 488, *((void *)this + 24), 0x10uLL) != 16) {
    goto LABEL_128;
  }
  if (*((_DWORD *)this + 122) == 1554098963)
  {
    *((_WORD *)this + 252) = 0;
    int v9 = *((unsigned __int8 *)this + 492);
    int v10 = *((unsigned __int8 *)this + 493) | (v9 << 8);
    if (v10 > 2055)
    {
      if (v10 <= 3081)
      {
        switch(v10)
        {
          case 2565:
            int v11 = 213;
            goto LABEL_63;
          case 2566:
            int v11 = 214;
            goto LABEL_63;
          case 2567:
          case 2569:
            goto LABEL_57;
          case 2568:
            int v11 = 215;
            goto LABEL_63;
          case 2570:
            int v11 = 216;
            goto LABEL_63;
          default:
            if (v10 != 2056) {
              goto LABEL_57;
            }
            int v11 = 212;
            break;
        }
        goto LABEL_63;
      }
      if (v10 == 3082)
      {
        int v11 = 217;
        goto LABEL_63;
      }
      if (v10 == 3084)
      {
        int v11 = 218;
        goto LABEL_63;
      }
    }
    else if (v10 <= 1540)
    {
      switch(v10)
      {
        case 1028:
          int v11 = 204;
          goto LABEL_63;
        case 1284:
          int v11 = 205;
          goto LABEL_63;
        case 1285:
          int v11 = 206;
          goto LABEL_63;
      }
    }
    else if (v10 > 2052)
    {
      if (v10 == 2053)
      {
        int v11 = 210;
        goto LABEL_63;
      }
      if (v10 == 2054)
      {
        int v11 = 211;
        goto LABEL_63;
      }
    }
    else
    {
      if (v10 == 1541)
      {
        int v11 = 207;
        goto LABEL_63;
      }
      if (v10 == 1542)
      {
        int v11 = 208;
LABEL_63:
        *((_DWORD *)this + 112) = v11;
        *((void *)this + 24) = 16;
        ASTCTextureImp::setTextureBaseOffset((uint64_t)v4, 16);
        int v23 = *(unsigned __int16 *)((char *)this + 495) | (*((unsigned __int8 *)this + 497) << 16);
        *((_DWORD *)this + 109) = v23;
        int v24 = *((unsigned __int16 *)this + 249) | (*((unsigned __int8 *)this + 500) << 16);
        *((_DWORD *)this + 110) = v24;
        *((_DWORD *)this + 111) = *(unsigned __int16 *)((char *)this + 501) | (*((unsigned __int8 *)this + 503) << 16);
        unsigned int v25 = *((unsigned __int8 *)this + 492);
        unsigned int v26 = (v23 + v25 - 1) / v25;
        *((_DWORD *)this + 113) = v26;
        unsigned int v27 = *((unsigned __int8 *)this + 493);
        unsigned int v28 = (v24 + v27 - 1) / v27;
        *((_DWORD *)this + 114) = v28;
        uint64_t v29 = 16 * v26 * v28;
        if (*((void *)this + 23) >= (unint64_t)(*((void *)this + 24) + v29))
        {
          uint64_t v30 = *((void *)this + 7);
          IIONumber::IIONumber((IIONumber *)v104, 4);
          IIODictionary::setObjectForKey(v30, (uint64_t)v104, @"Orientation");
          IIONumber::~IIONumber((IIONumber *)v104);
          goto LABEL_66;
        }
        _cg_jpeg_mem_term("initialize", 364, "*** bad ASTC %dx%d data [%d x %d] vs. %ld bytes - expected %ld bytes\n", v25, v27, v23, v24, *((void *)this + 23), v29);
LABEL_128:
        kdebug_trace();
        uint64_t v63 = 4294967246;
        goto LABEL_129;
      }
    }
LABEL_57:
    LogError("initialize", 343, "*** can't handle ASTC image with block dimension (%d/%d/%d)\n", v9, *((unsigned __int8 *)this + 493), *((unsigned __int8 *)this + 494));
    goto LABEL_128;
  }
  long long v117 = 0u;
  long long v118 = 0u;
  int8x16_t __dst = 0u;
  long long v116 = 0u;
  if (IIOScanner::getBytesAtOffset((IIOScanner *)&v105, &__dst, *((void *)this + 24), 0x40uLL) != 64) {
    goto LABEL_128;
  }
  if (!IsKTXHeader(&__dst))
  {
    long long v113 = 0u;
    long long v114 = 0u;
    long long v111 = 0u;
    long long v112 = 0u;
    long long v110 = 0u;
    if (IIOScanner::getBytesAtOffset((IIOScanner *)&v105, &v110, *((void *)this + 24), 0x50uLL) != 80
      || !IsKTX2Header(&v110))
    {
      goto LABEL_128;
    }
    if ((unint64_t)v106 <= v112)
    {
      _cg_jpeg_mem_term("initialize", 491, "*** ERROR: Invalid numberOfArrayElements (%d).");
      goto LABEL_128;
    }
    if ((unint64_t)v106 <= v113)
    {
      _cg_jpeg_mem_term("initialize", 492, "*** ERROR: Invalid dfdOffset (%d).");
      goto LABEL_128;
    }
    if ((unint64_t)v106 <= DWORD1(v113))
    {
      _cg_jpeg_mem_term("initialize", 493, "*** ERROR: Invalid dfdLength (%d).");
      goto LABEL_128;
    }
    if ((unint64_t)v106 <= DWORD2(v113))
    {
      _cg_jpeg_mem_term("initialize", 494, "*** ERROR: Invalid kvdOffset (%d).");
      goto LABEL_128;
    }
    if ((unint64_t)v106 <= HIDWORD(v113))
    {
      _cg_jpeg_mem_term("initialize", 495, "*** ERROR: Invalid kvdLength (%d).");
      goto LABEL_128;
    }
    if ((unint64_t)v114 >= (unint64_t)v106)
    {
      _cg_jpeg_mem_term("initialize", 496, "*** ERROR: Invalid scgdOffset (%d).");
      goto LABEL_128;
    }
    if (*((void *)&v114 + 1) >= (unint64_t)v106)
    {
      _cg_jpeg_mem_term("initialize", 497, "*** ERROR: Invalid scgdLength (%d).");
      goto LABEL_128;
    }
    *((_WORD *)this + 252) = 256;
    if (v5 <= DWORD1(v111) || v5 <= DWORD2(v111) || DWORD2(v112) > 0x10) {
      goto LABEL_128;
    }
    uint64_t v12 = ASTCTextureImp::MetalFormatForVulkanFormat((ASTCTextureImp *)HIDWORD(v110));
    *((_DWORD *)this + 112) = v12;
    if ((v12 - 222) <= 0xE)
    {
      ASTCTextureImp::set_needs_hdr((uint64_t)v4, 1);
      uint64_t v12 = *((unsigned int *)this + 112);
    }
    *((unsigned char *)this + 344) = 0;
    unsigned int v15 = DWORD1(v111);
    unsigned int v14 = DWORD2(v111);
    *((_DWORD *)this + 109) = DWORD1(v111);
    *((_DWORD *)this + 110) = v14;
    *((_DWORD *)this + 111) = 1;
    int v16 = *((_DWORD *)this + 52);
    v101[0] = 0;
    unsigned __int8 v102 = 0;
    ASTCTextureImp::GetXYdimFromMetalFormat(v12, v101, &v102, v13);
    unsigned int v17 = v101[0];
    if (!v101[0]) {
      goto LABEL_128;
    }
    *((unsigned char *)this + 492) = v101[0];
    unsigned int v18 = v102;
    *((unsigned char *)this + 493) = v102;
    *((unsigned char *)this + 494) = 1;
    *(_WORD *)((char *)this + 495) = v15 >> v16;
    *((unsigned char *)this + 497) = v15 >> v16 >> 16;
    *((_WORD *)this + 249) = v14 >> v16;
    *((unsigned char *)this + 500) = v14 >> v16 >> 16;
    *(_WORD *)((char *)this + 501) = 1;
    *((unsigned char *)this + 503) = 0;
    unint64_t v19 = (v17 + *((_DWORD *)this + 109) - 1) / v17;
    *((_DWORD *)this + 113) = v19;
    unint64_t v20 = (v18 + *((_DWORD *)this + 110) - 1) / v18;
    *((_DWORD *)this + 114) = v20;
    if (v5 < v19 || v5 < v20) {
      goto LABEL_128;
    }
    goto LABEL_66;
  }
  *((_WORD *)this + 252) = 1;
  SwapKTXHeader(&__dst);
  *((_WORD *)this + 159) = 0;
  unsigned int v6 = IIODictionary::containsKey(*((IIODictionary **)this + 6), @"kCGImageSourceMipmapLevel");
  BOOL v7 = (IIODictionary *)*((void *)this + 6);
  if (v6)
  {
    LOWORD(v8) = (unsigned __int16)IIODictionary::getUint32ForKey(v7, @"kCGImageSourceMipmapLevel");
  }
  else
  {
    if ((IIODictionary::containsKey(v7, @"kCGImageSourceSubsampleFactor") & 1) == 0)
    {
      LOWORD(v8) = *((_WORD *)this + 159);
      goto LABEL_107;
    }
    unsigned int Uint32ForKey = IIODictionary::getUint32ForKey(*((IIODictionary **)this + 6), @"kCGImageSourceSubsampleFactor");
    if (Uint32ForKey) {
      double v22 = log2((double)Uint32ForKey);
    }
    else {
      double v22 = 0.0;
    }
    int v8 = (int)v22;
  }
  *((_WORD *)this + 159) = v8;
LABEL_107:
  unsigned int v46 = DWORD2(v118);
  if (DWORD2(v118) <= (unsigned __int16)v8)
  {
    __int16 v47 = WORD4(v118) - 1;
    if (!DWORD2(v118)) {
      __int16 v47 = 0;
    }
    *((_WORD *)this + 159) = v47;
  }
  else
  {
    LOBYTE(v47) = v8;
  }
  unint64_t v48 = (DWORD1(v117) >> v47);
  unint64_t v49 = (DWORD2(v117) >> v47);
  *((_DWORD *)this + 57) = v48;
  *((_DWORD *)this + 58) = v49;
  if (v46 > 0x10 || v5 <= v48 || v5 <= v49) {
    goto LABEL_128;
  }
  if (DWORD1(v118) != 1 && DWORD1(v118) != 6)
  {
    _cg_jpeg_mem_term("initialize", 408, "*** Error: invalid numberOfFaces (%ld)", DWORD1(v118));
    goto LABEL_128;
  }
  if (HIDWORD(v117) > 0x1F) {
    goto LABEL_128;
  }
  uint64_t v50 = ASTCTextureImp::MetalFormatForGLFormat((ASTCTextureImp *)HIDWORD(v116));
  *((_DWORD *)this + 112) = v50;
  *((unsigned char *)this + 344) = __dst.i32[3] == 67305985;
  int v52 = *((_DWORD *)this + 57);
  int v51 = *((_DWORD *)this + 58);
  *((_DWORD *)this + 109) = v52;
  *((_DWORD *)this + 110) = v51;
  *((_DWORD *)this + 111) = 1;
  LOBYTE(v110) = 0;
  v101[0] = 0;
  ASTCTextureImp::GetXYdimFromMetalFormat(v50, &v110, (unsigned __int8 *)v101, v53);
  unsigned int v54 = v110;
  if (!(_BYTE)v110) {
    goto LABEL_128;
  }
  *((unsigned char *)this + 492) = v110;
  unsigned int v55 = v101[0];
  *((unsigned char *)this + 493) = v101[0];
  *((unsigned char *)this + 494) = 1;
  *(_WORD *)((char *)this + 495) = v52;
  *((unsigned char *)this + 497) = BYTE2(v52);
  *((_WORD *)this + 249) = v51;
  *((unsigned char *)this + 500) = BYTE2(v51);
  *(_WORD *)((char *)this + 501) = 1;
  *((unsigned char *)this + 503) = 0;
  unint64_t v56 = (v54 + *((_DWORD *)this + 109) - 1) / v54;
  *((_DWORD *)this + 113) = v56;
  unint64_t v57 = (v55 + *((_DWORD *)this + 110) - 1) / v55;
  *((_DWORD *)this + 114) = v57;
  if (v5 < v56 || v5 < v57 || !ASTCReadPlugin::extractMetadata((uint64_t)this, (uint64_t)&__dst)) {
    goto LABEL_128;
  }
  int v58 = *((unsigned __int8 *)this + 509);
  if (v58 != 255)
  {
    uint64_t v59 = *((void *)this + 7);
    IIONumber::IIONumber((IIONumber *)v103, v58);
    IIODictionary::setObjectForKey(v59, (uint64_t)v103, @"Orientation");
    IIONumber::~IIONumber((IIONumber *)v103);
  }
  unint64_t v60 = HIDWORD(v118) + 64;
  *((void *)this + 24) = v60;
  unint64_t v61 = ASTCReadPlugin::calculateKTXOffsetToRequestedImage((uint64_t)this, (uint64_t)&__dst, v60);
  *((void *)this + 24) = v61;
  ASTCTextureImp::setTextureBaseOffset((uint64_t)v4, v61);
  if (!*((unsigned char *)this + 508))
  {
    uint64_t v62 = (16 * *((_DWORD *)this + 113) * *((_DWORD *)this + 114));
    if (*((void *)this + 23) < (unint64_t)(*((void *)this + 24) + v62))
    {
      _cg_jpeg_mem_term("initialize", 475, "*** bad KTX/ASTC %dx%d data [%d x %d] vs. %ld bytes - expected %ld bytes\n", *((unsigned __int8 *)this + 492), *((unsigned __int8 *)this + 493), *((_DWORD *)this + 109), *((_DWORD *)this + 110), *((void *)this + 23), v62);
      goto LABEL_128;
    }
  }
LABEL_66:
  ASTCTextureImp::setTextureDimension((uint64_t)v4, *((_DWORD *)this + 109), *((_DWORD *)this + 110));
  ASTCTextureImp::setMetalFormat((uint64_t)v4, *((_DWORD *)this + 112));
  ASTCTextureImp::setDim(v4, *((unsigned __int8 *)this + 492), *((unsigned __int8 *)this + 493));
  ASTCTextureImp::setBlocks((uint64_t)v4, *((_DWORD *)this + 113), *((_DWORD *)this + 114));
  if (*((unsigned char *)this + 504))
  {
    IIOScanner::seek((IIOScanner *)&v105, *((void *)this + 24));
    if (IIOScanner::getVal32((IIOScanner *)&v105) == 1397119564)
    {
      unint64_t v31 = *((void *)this + 24);
    }
    else
    {
      IIOScanner::getVal32((IIOScanner *)&v105);
      unint64_t v31 = *((void *)this + 24) + 4;
    }
    if ((gIIODebugFlags & 0x30000) != 0)
    {
      ImageIOLog("    KTX with LZFSE compressed ASTC data\n");
      if ((gIIODebugFlags & 0x30000) != 0)
      {
        ImageIOLog("                    lzfseOffset: %d\n", v31);
        if ((gIIODebugFlags & 0x30000) != 0) {
          ImageIOLog("                        _rpd._offset: %d\n", *((void *)this + 24));
        }
      }
    }
  }
  else
  {
    unint64_t v31 = 16;
  }
  if (!*((unsigned char *)this + 505))
  {
    IIOScanner::seek((IIOScanner *)&v105, v31);
    if (IIOScanner::getVal32((IIOScanner *)&v105) == 1397119564)
    {
      ASTCTextureImp::setInputIsLZFSECompressed((uint64_t)v4, 1);
      LODWORD(v110) = 0;
      unint64_t v32 = v31 + 4;
      IIOScanner::getBytesAtOffset((IIOScanner *)&v105, &v110, v31 + 4, 4uLL);
      ASTCTextureImp::setCompressedLZFSESize((uint64_t)v4, v110);
      uint64_t v33 = v31 + 8;
      ASTCTextureImp::setCompressedLZFSEDataOffset((uint64_t)v4, v33);
      if ((gIIODebugFlags & 0x30000) != 0)
      {
        ImageIOLog("                      lzfseSize: %d\n", v110);
        if ((gIIODebugFlags & 0x30000) != 0) {
          ImageIOLog("                lzfseDataOffset: %d\n", v33);
        }
      }
      if (v110 >= 9)
      {
        __dst.i32[0] = 0;
        *(_DWORD *)uint64_t v101 = 0;
        IIOScanner::getBytesAtOffset((IIOScanner *)&v105, &__dst, v33, 4uLL);
        IIOScanner::getBytesAtOffset((IIOScanner *)&v105, v101, v32 + v110, 4uLL);
        __int32 v34 = __dst.i32[0];
        if (__dst.i32[0] != 846755426 || *(_DWORD *)v101 != 611874402)
        {
          unsigned int v65 = __dst.i32[0] >> 24;
          uint64_t v66 = MEMORY[0x1E4F14390];
          if (__dst.i32[0] < 0)
          {
            int v67 = __maskrune(v65, 0x40000uLL);
            __int32 v34 = __dst.i32[0];
            unsigned int v65 = __dst.i32[0] >> 24;
          }
          else
          {
            int v67 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v65 + 60) & 0x40000;
          }
          if (v67) {
            uint64_t v75 = v65;
          }
          else {
            uint64_t v75 = 46;
          }
          unsigned int v76 = v34 << 8 >> 24;
          if (v34 << 8 < 0)
          {
            int v77 = __maskrune(v76, 0x40000uLL);
            __int32 v34 = __dst.i32[0];
            unsigned int v76 = __dst.i32[0] << 8 >> 24;
          }
          else
          {
            int v77 = *(_DWORD *)(v66 + 4 * v76 + 60) & 0x40000;
          }
          if (v77) {
            uint64_t v78 = v76;
          }
          else {
            uint64_t v78 = 46;
          }
          unsigned int v79 = (__int16)v34 >> 8;
          if (v34 << 16 < 0)
          {
            int v80 = __maskrune(v79, 0x40000uLL);
            __int32 v34 = __dst.i32[0];
            unsigned int v79 = __dst.i16[0] >> 8;
          }
          else
          {
            int v80 = *(_DWORD *)(v66 + 4 * v79 + 60) & 0x40000;
          }
          if (v80) {
            uint64_t v81 = v79;
          }
          else {
            uint64_t v81 = 46;
          }
          unsigned int v82 = (char)v34;
          if ((v34 << 24) <= 0x7F000000)
          {
            int v83 = *(_DWORD *)(v66 + 4 * (char)v34 + 60) & 0x40000;
          }
          else
          {
            int v83 = __maskrune((char)v34, 0x40000uLL);
            unsigned int v82 = __dst.i8[0];
          }
          if (v83) {
            uint64_t v84 = v82;
          }
          else {
            uint64_t v84 = 46;
          }
          int v85 = *(_DWORD *)v101;
          unsigned int v86 = v101[3];
          if ((*(_DWORD *)v101 & 0x80000000) != 0)
          {
            int v87 = __maskrune(v101[3], 0x40000uLL);
            int v85 = *(_DWORD *)v101;
            unsigned int v86 = v101[3];
          }
          else
          {
            int v87 = *(_DWORD *)(v66 + 4 * v101[3] + 60) & 0x40000;
          }
          if (v87) {
            uint64_t v88 = v86;
          }
          else {
            uint64_t v88 = 46;
          }
          unsigned int v89 = v85 << 8 >> 24;
          if (v85 << 8 < 0)
          {
            int v90 = __maskrune(v89, 0x40000uLL);
            int v85 = *(_DWORD *)v101;
            unsigned int v89 = v101[2];
          }
          else
          {
            int v90 = *(_DWORD *)(v66 + 4 * v89 + 60) & 0x40000;
          }
          if (v90) {
            uint64_t v91 = v89;
          }
          else {
            uint64_t v91 = 46;
          }
          unsigned int v92 = (__int16)v85 >> 8;
          if (v85 << 16 < 0)
          {
            int v93 = __maskrune(v92, 0x40000uLL);
            int v85 = *(_DWORD *)v101;
          }
          else
          {
            int v93 = *(_DWORD *)(v66 + 4 * v92 + 60) & 0x40000;
          }
          unsigned int v94 = (char)v85;
          if ((v85 << 24) <= 0x7F000000)
          {
            int v95 = *(_DWORD *)(v66 + 4 * (char)v85 + 60) & 0x40000;
          }
          else
          {
            int v95 = __maskrune((char)v85, 0x40000uLL);
            unsigned int v94 = v101[0];
          }
          LODWORD(v96) = (__int16)v85 >> 8;
          if (v93) {
            uint64_t v96 = v96;
          }
          else {
            uint64_t v96 = 46;
          }
          if (v95) {
            uint64_t v97 = v94;
          }
          else {
            uint64_t v97 = 46;
          }
          _cg_jpeg_mem_term("initialize", 624, "    ERROR: bad LZFSE data (does not start/end with 'bvx2'/'bvx$'  [%c%c%c%c][%c%c%c%c])\n", v75, v78, v81, v84, v88, v91, v96, v97);
          goto LABEL_128;
        }
      }
    }
  }
  unint64_t v35 = *((unsigned __int8 *)this + 492);
  unint64_t v36 = *((unsigned __int8 *)this + 493);
  unsigned int v37 = *((unsigned __int8 *)this + 494);
  if ((v35 - 13) < 0xFFFFFFF6
    || v36 < 3
    || v36 > 0xC
    || (v37 < 3 ? (BOOL v38 = v37 == 1) : (BOOL v38 = 1), v38 ? (v39 = 0) : (v39 = 1), v37 > 0xC || v39))
  {
    _cg_jpeg_mem_term("initialize", 641, "xyz-dim not supported:  xdim:%d  ydim:%d  zdim:%d\n", v35, *((unsigned __int8 *)this + 493), v37);
    goto LABEL_128;
  }
  uint64_t v40 = v106 - *((void *)this + 24);
  if (v40 < 0)
  {
    _cg_jpeg_mem_term("initialize", 649, "bad file _offset: %ld  fileSize: %ld\n", *((void *)this + 24), (void)v106);
    goto LABEL_128;
  }
  uint64_t v41 = *((unsigned int *)this + 109);
  uint64_t v42 = *((unsigned int *)this + 110);
  char isInputLZFSECompressed = ASTCTextureImp::isInputLZFSECompressed(v4);
  unint64_t v44 = 16 * (v35 + v41 - 1) / v35 * ((v36 + v42 - 1) / v36);
  if (v44 <= v40) {
    char v45 = 1;
  }
  else {
    char v45 = isInputLZFSECompressed;
  }
  if ((v45 & 1) == 0)
  {
    _cg_jpeg_mem_term("initialize", 662, "bad file size:  xdim:%d  ydim:%d  zdim:%d  size:%dx%d  dataSize:%d  expected:%d\n", v35, v36, v37, *((_DWORD *)this + 109), *((_DWORD *)this + 110), v40, v44);
    goto LABEL_128;
  }
  if ((*(unsigned __int16 *)((char *)this + 501) | (*((unsigned __int8 *)this + 503) << 16)) >= 2u)
  {
    _cg_jpeg_mem_term("initialize", 675, "zsize '%d' not supported\n", *(unsigned __int16 *)((char *)this + 501) | (*((unsigned __int8 *)this + 503) << 16));
    goto LABEL_128;
  }
  unsigned int v68 = *(unsigned __int16 *)((char *)this + 495) | (*((unsigned __int8 *)this + 497) << 16);
  unsigned int v69 = *((unsigned __int16 *)this + 249) | (*((unsigned __int8 *)this + 500) << 16);
  if (v68 && ((v68 * (unint64_t)v69) & 0xFFFFFFFF00000000) != 0)
  {
    _cg_jpeg_mem_term("initialize", 681, "overflow: xsize: %d    ysize: %d\n", *(unsigned __int16 *)((char *)this + 495) | (*((unsigned __int8 *)this + 497) << 16), v69);
    goto LABEL_128;
  }
  *((_DWORD *)this + 57) = v68;
  *((_DWORD *)this + 58) = v69;
  *((_DWORD *)this + 60) = 2097160;
  *((_WORD *)this + 122) = 4;
  *((_DWORD *)this + 81) = 1380401696;
  int v70 = *((unsigned __int8 *)this + 507);
  if (v70 == 255) {
    char v71 = 3;
  }
  else {
    char v71 = v70 & 0x1F;
  }
  *((unsigned char *)this + 246) = v71;
  *((void *)this + 20) = 0;
  unint64_t v72 = *((char *)this + 506);
  if (v72 <= 4) {
    *((void *)this + 20) = CGColorSpaceCreateWithName(**((CFStringRef **)&unk_1E53CCFF8 + v72));
  }
  *((_DWORD *)this + 59) = 4 * v68;
  *((unsigned char *)this + 346) = 0;
  if (*((void *)this + 3))
  {
    if ((ASTCTextureImp::isInputLZFSECompressed(v4) & 1) == 0
      && (ASTCTextureImp::isInputPreTwiddled(v4) & 1) == 0
      && *((unsigned __int8 *)this + 507) == 255
      && *((unsigned __int8 *)this + 506) == 255
      && !*((unsigned char *)this + 505))
    {
      long long v110 = 0uLL;
      CFDictionaryRef v73 = (IIOImageReadSession *)*((void *)this + 3);
      unint64_t Properties = IIOImagePlus::getProperties(v4);
      if (IIOImageReadSession::getBytesAtOffset(v73, &v110, Properties, 0x10uLL) == 16)
      {
        if ((v110 & 0x1FF) == 0x1FC)
        {
          ASTCTextureImp::set_needs_hdr((uint64_t)v4, (v110 & 0x200) != 0);
        }
        else
        {
          unsigned int v98 = (v110 >> 13) & 0xF;
          if ((v110 & 0x1800) != 0) {
            unsigned int v98 = (v110 >> 23) & 0x3F;
          }
          if ((v98 & 0x3E) == 0xE || v98 == 11 || v98 == 7 || (v98 & 0x3E) == 2) {
            ASTCTextureImp::set_needs_hdr((uint64_t)v4, 1);
          }
        }
      }
    }
  }
  if (ASTCTextureImp::needs_hdr(v4))
  {
    *((unsigned char *)this + 345) = 1;
    *((_DWORD *)this + 59) = 8 * v68;
    *((_DWORD *)this + 60) = 4194320;
    *((unsigned char *)this + 247) = 1;
    if (!*((void *)this + 20)) {
      *((void *)this + 20) = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E4F1DBE0]);
    }
  }
  long long v99 = getenv("IIO_useV3");
  if (v99 && !atoi(v99)) {
    __int16 v100 = 1;
  }
  else {
    __int16 v100 = 13;
  }
  uint64_t v63 = 0;
  *((_WORD *)this + 188) = v100;
LABEL_129:
  IIOScanner::~IIOScanner((IIOScanner *)&v105);
  return v63;
}

void sub_1885EDB84(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, ...)
{
  va_start(va, a17);
  IIOScanner::~IIOScanner((IIOScanner *)va);
  _Unwind_Resume(a1);
}

size_t IIOScanner::getBytesAtOffset(IIOScanner *this, void *__dst, uint64_t a3, size_t __n)
{
  if (__n + a3 > *((void *)this + 2)) {
    return 0;
  }
  size_t v4 = __n;
  memcpy(__dst, (const void *)(*((void *)this + 1) + a3), __n);
  return v4;
}

void EnumerateExifDataUsingBlock(const char *a1, int a2, uint64_t a3)
{
  unint64_t v5 = a1;
  char v42 = 0;
  v41[0] = 0;
  v41[1] = 0;
  uint64_t v40 = v41;
  LODWORD(v6) = 6;
  if (*(unsigned __int8 *)a1 == 255)
  {
    BOOL v7 = *((unsigned __int8 *)a1 + 1) == 225;
    a1 += 4 * v7;
    if (v7) {
      LODWORD(v6) = 10;
    }
    else {
      LODWORD(v6) = 6;
    }
  }
  if (!strncmp(a1, "Exif", 4uLL)) {
    uint64_t v6 = v6;
  }
  else {
    uint64_t v6 = 0;
  }
  v43[0] = 0;
  int v8 = (unsigned __int8 *)&v5[v6];
  int v9 = v5[v6];
  if (v9 != 73)
  {
    int v10 = 0;
    if (v9 != 77) {
      goto LABEL_64;
    }
    if (v5[v6 | 1] == 77)
    {
      int v11 = 1;
      goto LABEL_14;
    }
LABEL_61:
    int v10 = 0;
    goto LABEL_64;
  }
  if (v5[v6 | 1] != 73) {
    goto LABEL_61;
  }
  int v11 = 0;
LABEL_14:
  uint64_t v39 = 0;
  long long v37 = 0u;
  long long v38 = 0u;
  long long v35 = 0u;
  long long v36 = 0u;
  IIOScanner::IIOScanner((IIOScanner *)&v35, v8, (a2 - v6), v11 ^ 1);
  IIOScanner::skip((uint64_t)&v35, 4);
  unsigned int Val32 = IIOScanner::getVal32((IIOScanner *)&v35);
  IIOScanner::seek((IIOScanner *)&v35, Val32);
  int v13 = 0;
  unint64_t v30 = 0;
  unint64_t v31 = 0;
  int v32 = 0;
  char v14 = 0;
  if (v11) {
    char v15 = 16;
  }
  else {
    char v15 = 0;
  }
  char v29 = v15;
  while (1)
  {
    v43[0] = *((void *)&v36 + 1);
    int v16 = (void *)v41[0];
    if (v41[0])
    {
      unsigned int v17 = v41;
      do
      {
        unsigned int v18 = v16;
        unint64_t v19 = v17;
        unint64_t v20 = v16[4];
        xpc_object_t v21 = v16 + 1;
        if (v20 <= *((void *)&v36 + 1))
        {
          xpc_object_t v21 = v18;
          unsigned int v17 = v18;
        }
        int v16 = (void *)*v21;
      }
      while (v16);
      if (v17 != v41)
      {
        if (v20 > *((void *)&v36 + 1)) {
          unsigned int v18 = v19;
        }
        if (*((void *)&v36 + 1) <= v18[4]) {
          break;
        }
      }
    }
    std::__tree<unsigned long long,std::greater<unsigned long long>,std::allocator<unsigned long long>>::__emplace_unique_key_args<unsigned long long,unsigned long long const&>(&v40, (unint64_t *)v43, v43);
    int Val16 = IIOScanner::getVal16((IIOScanner *)&v35);
    if (Val16)
    {
      int v23 = 0;
      char v24 = v14 | v29;
      while (2)
      {
        long long v33 = 0u;
        long long v34 = 0u;
        BYTE8(v34) = v24;
        unint64_t v25 = *((void *)&v36 + 1);
        WORD4(v33) = IIOScanner::getVal16((IIOScanner *)&v35);
        WORD5(v33) = IIOScanner::getVal16((IIOScanner *)&v35);
        int v26 = IIOScanner::getVal32((IIOScanner *)&v35);
        HIDWORD(v33) = v26;
        switch(WORD5(v33))
        {
          case 1:
          case 2:
          case 7:
            goto LABEL_33;
          case 3:
            LOWORD(v26) = 2 * v26;
            goto LABEL_33;
          case 4:
          case 9:
            LOWORD(v26) = 4 * v26;
            goto LABEL_33;
          case 5:
          case 0xA:
            LOWORD(v26) = 8 * v26;
LABEL_33:
            DWORD1(v34) = (unsigned __int16)v26;
            if ((unsigned __int16)v26 >= 4u)
            {
              LODWORD(v34) = IIOScanner::getVal32((IIOScanner *)&v35);
              goto LABEL_45;
            }
            if ((unsigned __int16)v26 == 2)
            {
              LODWORD(v34) = IIOScanner::getVal16((IIOScanner *)&v35);
              uint64_t v27 = 2;
            }
            else
            {
              if ((unsigned __int16)v26 != 1) {
                goto LABEL_43;
              }
              LODWORD(v34) = IIOScanner::getVal8((IIOScanner *)&v35);
              uint64_t v27 = 3;
            }
            goto LABEL_44;
          default:
            if (!WORD4(v33) && v23 + 1 == Val16)
            {
              IIOScanner::seek((IIOScanner *)&v35, v25);
              ++v23;
              goto LABEL_54;
            }
            DWORD1(v34) = 0;
LABEL_43:
            uint64_t v27 = 4;
LABEL_44:
            IIOScanner::skip((uint64_t)&v35, v27);
LABEL_45:
            *(void *)&long long v33 = v25;
            if (WORD4(v33) == 34853)
            {
              unint64_t v31 = v34;
              int v32 = 34853;
              if (!a3) {
                goto LABEL_52;
              }
LABEL_51:
              (*(void (**)(uint64_t, long long *, uint64_t, char *))(a3 + 16))(a3, &v33, v6, &v42);
              goto LABEL_52;
            }
            if (WORD4(v33) == 34665)
            {
              unint64_t v30 = v34;
              int v13 = 34665;
            }
            if (a3) {
              goto LABEL_51;
            }
LABEL_52:
            if (v42) {
              goto LABEL_63;
            }
            ++v23;
LABEL_54:
            if (v23 == Val16) {
              break;
            }
            continue;
        }
        break;
      }
    }
    unsigned int v28 = IIOScanner::getVal32((IIOScanner *)&v35);
    if (v28)
    {
      char v14 = 1;
      IIOScanner::seek((IIOScanner *)&v35, v28);
    }
    else if (v13)
    {
      char v14 = 2;
      IIOScanner::seek((IIOScanner *)&v35, v30);
      int v13 = 0;
    }
    else
    {
      if (!v32) {
        goto LABEL_63;
      }
      char v14 = 3;
      IIOScanner::seek((IIOScanner *)&v35, v31);
      int v13 = 0;
      int v32 = 0;
    }
  }
  _cg_jpeg_mem_term("EnumerateExifDataUsingBlock", 4803, "*** ERROR: cycle in IDF offsets [offset %ld was already processed]\n", *((void *)&v36 + 1));
LABEL_63:
  IIOScanner::~IIOScanner((IIOScanner *)&v35);
  int v10 = (void *)v41[0];
LABEL_64:
  std::__tree<unsigned long long>::destroy((uint64_t)&v40, v10);
}

void sub_1885EE03C(_Unwind_Exception *a1)
{
  std::__tree<unsigned long long>::destroy(v1 - 128, *(void **)(v1 - 120));
  _Unwind_Resume(a1);
}

#error "1885EE07C: call analysis failed (funcsize=10)"

void sub_1885EE088(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  va_start(va, a10);
  IIOScanner::~IIOScanner((IIOScanner *)va);
  JUMPOUT(0x1885EE040);
}

uint64_t IIOScanner::getVal16(IIOScanner *this)
{
  uint64_t v1 = *((void *)this + 3);
  if ((unint64_t)(v1 + 1) >= *((void *)this + 2))
  {
    LogError("getVal16", 178, "*** IIOScanner::getVal16 reached EOF\n");
    *((_DWORD *)this + 16) = -39;
    exception = __cxa_allocate_exception(4uLL);
    _DWORD *exception = -39;
    __cxa_throw(exception, MEMORY[0x1E4FBA3A8], 0);
  }
  unsigned int v2 = *(unsigned __int16 *)(*((void *)this + 1) + v1);
  unsigned int v3 = bswap32(v2) >> 16;
  if (!*((unsigned char *)this + 68)) {
    LOWORD(v2) = v3;
  }
  *((void *)this + 3) = v1 + 2;
  return (unsigned __int16)v2;
}

uint64_t ___ZN13PNGReadPlugin24AddOrientationToMetadataEP13IIODictionaryS1_P15CGImageMetadataP14png_struct_defP12png_info_def_block_invoke_2(uint64_t result, uint64_t a2, uint64_t a3, unsigned char *a4)
{
  if (*(_WORD *)(a2 + 8) == 274)
  {
    *(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = *(_DWORD *)(a2 + 16);
    *a4 = 1;
  }
  return result;
}

uint64_t *std::__tree<unsigned long long,std::greater<unsigned long long>,std::allocator<unsigned long long>>::__emplace_unique_key_args<unsigned long long,unsigned long long const&>(uint64_t **a1, unint64_t *a2, uint64_t *a3)
{
  uint64_t v6 = a1 + 1;
  unint64_t v5 = a1[1];
  if (v5)
  {
    unint64_t v7 = *a2;
    while (1)
    {
      while (1)
      {
        int v8 = (uint64_t **)v5;
        unint64_t v9 = v5[4];
        if (v7 <= v9) {
          break;
        }
        unint64_t v5 = *v8;
        uint64_t v6 = v8;
        if (!*v8) {
          goto LABEL_10;
        }
      }
      if (v9 <= v7) {
        break;
      }
      unint64_t v5 = v8[1];
      if (!v5)
      {
        uint64_t v6 = v8 + 1;
        goto LABEL_10;
      }
    }
  }
  else
  {
    int v8 = a1 + 1;
LABEL_10:
    int v10 = (uint64_t *)operator new(0x28uLL);
    v10[4] = *a3;
    std::__tree<std::__value_type<unsigned long,unsigned long>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,unsigned long>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,unsigned long>>>::__insert_node_at(a1, (uint64_t)v8, v6, v10);
    return v10;
  }
  return (uint64_t *)v8;
}

void ___ZN19AppleJPEGReadPlugin12readExifDataEP13IIODictionarybb_block_invoke(uint64_t a1, uint64_t a2, unsigned int a3)
{
  v20[1] = *MEMORY[0x1E4F143B8];
  unsigned int v5 = *(unsigned __int16 *)(a2 + 8);
  if (v5 > 0x200)
  {
    if (v5 == 513)
    {
      if ((*(unsigned char *)(a1 + 80) & 4) != 0)
      {
        uint64_t v16 = *(void *)(*(void *)(a1 + 40) + 8);
        if (!*(void *)(v16 + 24))
        {
          *(void *)(v16 + 24) = *(unsigned int *)(a2 + 16) + (unint64_t)a3 + *(void *)(a1 + 72) + 10;
          IIONumber::IIONumber((IIONumber *)v18, *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24));
          unsigned int v17 = CGImageMetadataTagCreate(@"http://ns.adobe.com/tiff/1.0/", @"iio", @"JPEGInterchangeFormat", kCGImageMetadataTypeDefault, value);
          IIONumber::~IIONumber((IIONumber *)v18);
          if (v17)
          {
            CGImageMetadataSetTagWithPath(*(CGMutableImageMetadataRef *)(a1 + 64), 0, @"iio:JPEGInterchangeFormat", v17);
            CFRelease(v17);
          }
        }
      }
    }
    else if (v5 == 514 && (*(unsigned char *)(a1 + 80) & 4) != 0)
    {
      uint64_t v11 = *(void *)(*(void *)(a1 + 48) + 8);
      if (!*(_DWORD *)(v11 + 24))
      {
        *(_DWORD *)(v11 + 24) = *(_DWORD *)(a2 + 16);
        IIONumber::IIONumber((IIONumber *)v18, *(_DWORD *)(*(void *)(*(void *)(a1 + 48) + 8) + 24));
        uint64_t v12 = CGImageMetadataTagCreate(@"http://ns.adobe.com/tiff/1.0/", @"iio", @"JPEGInterchangeFormatLength", kCGImageMetadataTypeDefault, value);
        IIONumber::~IIONumber((IIONumber *)v18);
        if (v12)
        {
          CGImageMetadataSetTagWithPath(*(CGMutableImageMetadataRef *)(a1 + 64), 0, @"iio:JPEGInterchangeFormatLength", v12);
          CFRelease(v12);
        }
      }
    }
  }
  else if (v5 - 282 >= 2)
  {
    if (v5 == 274)
    {
      uint64_t v13 = *(void *)(*(void *)(a1 + 32) + 8);
      if (!*(_DWORD *)(v13 + 24))
      {
        int v14 = *(_DWORD *)(a2 + 16);
        if ((v14 - 1) <= 7)
        {
          *(_DWORD *)(v13 + 24) = v14;
          IIONumber::IIONumber((IIONumber *)v18, *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24));
          char v15 = CGImageMetadataTagCreate(@"http://ns.adobe.com/tiff/1.0/", @"tiff", @"Orientation", kCGImageMetadataTypeDefault, value);
          IIONumber::~IIONumber((IIONumber *)v18);
          if (v15)
          {
            CGImageMetadataSetTagWithPath(*(CGMutableImageMetadataRef *)(a1 + 64), 0, @"tiff:Orientation", v15);
            CFRelease(v15);
          }
        }
      }
    }
  }
  else
  {
    int v6 = a3 + *(_DWORD *)(a2 + 16) + *(_DWORD *)(a1 + 72);
    unint64_t v7 = (v6 + 10);
    if (v6 == -10) {
      return;
    }
    uint64_t v8 = *(void *)(a1 + 56);
    v20[0] = 0;
    IIOImageReadSession::getBytesAtOffset(*(IIOImageReadSession **)(v8 + 24), v20, v7, 8uLL);
    v20[0] = _byteswap_uint64(__PAIR64__(v20[0], HIDWORD(v20[0])));
    uint64_t v9 = (uint64_t)((double)LODWORD(v20[0]) / (double)HIDWORD(v20[0]));
    if (*(_WORD *)(a2 + 8) == 282)
    {
      IIONumber::IIONumber((IIONumber *)v18, v9);
      int v10 = CGImageMetadataTagCreate(@"http://ns.adobe.com/tiff/1.0/", @"tiff", @"XResolution", kCGImageMetadataTypeDefault, value);
      IIONumber::~IIONumber((IIONumber *)v18);
      if (!v10) {
        return;
      }
      CGImageMetadataSetTagWithPath(*(CGMutableImageMetadataRef *)(a1 + 64), 0, @"tiff:XResolution", v10);
    }
    else
    {
      IIONumber::IIONumber((IIONumber *)v18, v9);
      int v10 = CGImageMetadataTagCreate(@"http://ns.adobe.com/tiff/1.0/", @"tiff", @"YResolution", kCGImageMetadataTypeDefault, value);
      IIONumber::~IIONumber((IIONumber *)v18);
      if (!v10) {
        return;
      }
      CGImageMetadataSetTagWithPath(*(CGMutableImageMetadataRef *)(a1 + 64), 0, @"tiff:YResolution", v10);
    }
    CFRelease(v10);
  }
}

void sub_1885EE5B0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  IIONumber::~IIONumber((IIONumber *)va);
  _Unwind_Resume(a1);
}

uint64_t IterateChunks(IIOScanner *a1, uint64_t a2)
{
  IIOScanner::seek(a1, 8uLL);
  unint64_t v4 = *((void *)a1 + 3);
  uint64_t Val32 = IIOScanner::getVal32(a1);
  uint64_t v6 = bswap32(IIOScanner::getVal32(a1));
  unint64_t v7 = *((void *)a1 + 2);
  do
  {
    if (v7 <= v4) {
      break;
    }
    uint64_t result = (*(uint64_t (**)(uint64_t, unint64_t, uint64_t, uint64_t))(a2 + 16))(a2, v4, Val32, v6);
    if (result) {
      return result;
    }
    if (*((void *)a1 + 3) + (unint64_t)Val32 > *((void *)a1 + 2)) {
      break;
    }
    IIOScanner::skip((uint64_t)a1, Val32);
    unint64_t v4 = *((void *)a1 + 3);
    uint64_t Val32 = IIOScanner::getVal32(a1);
    uint64_t result = 4294967246;
    if (*((void *)a1 + 3) + 4 > v7 || v7 < Val32) {
      return result;
    }
    unsigned int v9 = IIOScanner::getVal32(a1);
    uint64_t v6 = bswap32(v9);
  }
  while (v9 != 541347397);
  return 0;
}

void sub_1885EE6D0(void *a1)
{
}

uint64_t IIOScanner::skip(uint64_t this, uint64_t a2)
{
  unint64_t v2 = *(void *)(this + 16);
  unint64_t v3 = *(void *)(this + 24) + a2;
  if (v3 >= v2)
  {
    *(void *)(this + 24) = v2;
    uint64_t v4 = this;
    LogError("skip", 415, "*** IIOScanner::skip reached EOF\n");
    *(_DWORD *)(v4 + 64) = -39;
    exception = __cxa_allocate_exception(4uLL);
    _DWORD *exception = -39;
    __cxa_throw(exception, MEMORY[0x1E4FBA3A8], 0);
  }
  *(void *)(this + 24) = v3;
  return this;
}

unint64_t IIOScanner::seek(IIOScanner *this, unint64_t a2)
{
  unint64_t v2 = *((void *)this + 2);
  if (v2 <= a2)
  {
    *((void *)this + 3) = v2;
    LogError("seek", 431, "*** IIOScanner::seek reached EOF\n");
    *((_DWORD *)this + 16) = -39;
    exception = __cxa_allocate_exception(4uLL);
    _DWORD *exception = -39;
    __cxa_throw(exception, MEMORY[0x1E4FBA3A8], 0);
  }
  *((void *)this + 3) = a2;
  *((_DWORD *)this + 16) = 0;
  return a2;
}

uint64_t ___ZN14IIO_Reader_ATX13getImageCountEP19IIOImageReadSessionP13IIODictionaryP19CGImageSourceStatusPj_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t result = 0;
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  if (a4 <= 1212498243)
  {
    if (a4 != 875704410 && a4 != 875704422 && a4 != 1095980099) {
      return result;
    }
    goto LABEL_13;
  }
  if (a4 == 1634956387 || a4 == 1280984659)
  {
LABEL_13:
    uint64_t v8 = *(_DWORD **)(a1 + 40);
    if (v8)
    {
      uint64_t result = 0;
      _DWORD *v8 = 1;
      return result;
    }
    return 0;
  }
  if (a4 != 1212498244) {
    return result;
  }
  int v14 = 0;
  long long v12 = 0u;
  long long v13 = 0u;
  long long v11 = 0u;
  memset(v10, 0, sizeof(v10));
  uint64_t v6 = *(void *)(*(void *)(a1 + 32) + 8);
  if (!*(unsigned char *)(v6 + 24))
  {
    *(unsigned char *)(v6 + 24) = 1;
    IIOScanner::copyBytes(*(void **)(a1 + 48), v10, 0x54uLL);
    if (HIDWORD(v11))
    {
      unsigned int v9 = *(_DWORD **)(a1 + 40);
      if (v9)
      {
        uint64_t result = 0;
        *unsigned int v9 = HIDWORD(v11);
        return result;
      }
    }
    return 0;
  }
  unint64_t v7 = *(_DWORD **)(a1 + 40);
  if (v7) {
    *unint64_t v7 = 0;
  }
  return 4294967246;
}

uint64_t ___ZN13ATXReadPlugin10initializeEP13IIODictionary_block_invoke(void *a1, uint64_t a2, int a3, int a4)
{
  uint64_t v6 = 0;
  uint64_t v7 = a1[6];
  if (a4 <= 1212498243)
  {
    if (a4 == 875704410) {
      goto LABEL_40;
    }
    if (a4 != 875704422)
    {
      if (a4 == 1095980099)
      {
        if (*(_DWORD *)(v7 + 540))
        {
          _cg_jpeg_mem_term("initialize_block_invoke", 179, "*** ERROR: lzfseCompressed mismatch\n");
          return 4294967246;
        }
        *(void *)(v7 + 576) = a2;
        uint64_t v14 = a1[7];
        uint64_t v15 = a2 + 12;
        goto LABEL_27;
      }
      return v6;
    }
    if (*(_DWORD *)(v7 + 504) != 1714434612)
    {
      _cg_jpeg_mem_term("initialize_block_invoke", 233, "*** ERROR: bad _atxHeader.glInternalFormat 0x%08X\n");
      return 4294967246;
    }
    unsigned int v9 = bswap32(IIOScanner::getVal32AtPosition((IIOScanner *)(*(void *)(a1[5] + 8) + 40), a2 + 8));
    if (v9 == 1128813133)
    {
      *(void *)(v7 + 608) = a2 + 24;
      *(_DWORD *)(v7 + 616) = IIOScanner::getVal32AtPosition((IIOScanner *)(*(void *)(a1[5] + 8) + 40), a2 + 12);
      *(_DWORD *)(v7 + 620) = IIOScanner::getVal32AtPosition((IIOScanner *)(*(void *)(a1[5] + 8) + 40), a2 + 16);
      unsigned int Val32AtPosition = IIOScanner::getVal32AtPosition((IIOScanner *)(*(void *)(a1[5] + 8) + 40), a2 + 20);
      *(_DWORD *)(v7 + 624) = Val32AtPosition;
      if (Val32AtPosition < *(_DWORD *)(v7 + 616) || Val32AtPosition < *(_DWORD *)(v7 + 620))
      {
        _cg_jpeg_mem_term("initialize_block_invoke", 260, "*** ERROR: bad geometry %dx%d - rb: %d\n");
        goto LABEL_38;
      }
    }
    else if (v9 == 1280658753)
    {
      *(void *)(v7 + 584) = a2 + 24;
      *(_DWORD *)(v7 + 592) = IIOScanner::getVal32AtPosition((IIOScanner *)(*(void *)(a1[5] + 8) + 40), a2 + 12);
      *(_DWORD *)(v7 + 596) = IIOScanner::getVal32AtPosition((IIOScanner *)(*(void *)(a1[5] + 8) + 40), a2 + 16);
      unsigned int v10 = IIOScanner::getVal32AtPosition((IIOScanner *)(*(void *)(a1[5] + 8) + 40), a2 + 20);
      *(_DWORD *)(v7 + 600) = v10;
      if (v10 < *(_DWORD *)(v7 + 592) || v10 < *(_DWORD *)(v7 + 596))
      {
        _cg_jpeg_mem_term("initialize_block_invoke", 248, "*** ERROR: bad geometry %dx%d - rb: %d\n");
LABEL_38:
        uint64_t v6 = 4294967246;
        goto LABEL_40;
      }
    }
    uint64_t v6 = 0;
LABEL_40:
    if (*(_DWORD *)(v7 + 504) == 1714434612)
    {
      unsigned int v21 = bswap32(IIOScanner::getVal32AtPosition((IIOScanner *)(*(void *)(a1[5] + 8) + 40), a2 + 8));
      if (v21 == 1667789421)
      {
        *(unsigned char *)(v7 + 632) = 1;
        *(void *)(v7 + 608) = a2 + 24;
        *(_DWORD *)(v7 + 616) = IIOScanner::getVal32AtPosition((IIOScanner *)(*(void *)(a1[5] + 8) + 40), a2 + 12);
        *(_DWORD *)(v7 + 620) = IIOScanner::getVal32AtPosition((IIOScanner *)(*(void *)(a1[5] + 8) + 40), a2 + 16);
        *(_DWORD *)(v7 + 624) = IIOScanner::getVal32AtPosition((IIOScanner *)(*(void *)(a1[5] + 8) + 40), a2 + 20);
        *(_DWORD *)(v7 + 628) = IIOScanner::getVal32AtPosition((IIOScanner *)(*(void *)(a1[5] + 8) + 40), a2 + 28);
        unsigned int v23 = *(_DWORD *)(v7 + 624);
        if (v23 >= *(_DWORD *)(v7 + 616) && v23 >= *(_DWORD *)(v7 + 620)) {
          return v6;
        }
        _cg_jpeg_mem_term("initialize_block_invoke", 303, "*** ERROR: bad geometry %dx%d - rb: %d\n");
      }
      else
      {
        if (v21 != 1819635041) {
          return v6;
        }
        *(unsigned char *)(v7 + 632) = 1;
        *(void *)(v7 + 584) = a2 + 24;
        *(_DWORD *)(v7 + 592) = IIOScanner::getVal32AtPosition((IIOScanner *)(*(void *)(a1[5] + 8) + 40), a2 + 12);
        *(_DWORD *)(v7 + 596) = IIOScanner::getVal32AtPosition((IIOScanner *)(*(void *)(a1[5] + 8) + 40), a2 + 16);
        *(_DWORD *)(v7 + 600) = IIOScanner::getVal32AtPosition((IIOScanner *)(*(void *)(a1[5] + 8) + 40), a2 + 20);
        *(_DWORD *)(v7 + 604) = IIOScanner::getVal32AtPosition((IIOScanner *)(*(void *)(a1[5] + 8) + 40), a2 + 28);
        unsigned int v22 = *(_DWORD *)(v7 + 600);
        if (v22 >= *(_DWORD *)(v7 + 592) && v22 >= *(_DWORD *)(v7 + 596)) {
          return v6;
        }
        _cg_jpeg_mem_term("initialize_block_invoke", 289, "*** ERROR: bad geometry %dx%d - rb: %d\n");
      }
    }
    else
    {
      _cg_jpeg_mem_term("initialize_block_invoke", 273, "*** ERROR: bad _atxHeader.glInternalFormat 0x%08X\n");
    }
    return 4294967246;
  }
  if (a4 == 1634956387)
  {
    if (*(_DWORD *)(v7 + 540))
    {
      _cg_jpeg_mem_term("initialize_block_invoke", 212, "*** ERROR: lzfseCompressed mismatch\n");
      return 4294967246;
    }
    *(void *)(v7 + 576) = a2;
    ASTCTextureImp::setInputIsPreTwiddled(a1[7], 1);
    ASTCTextureImp::setTextureBaseOffset(a1[7], a2 + 12);
    uint64_t v16 = IIOScanner::getVal32AtPosition((IIOScanner *)(*(void *)(a1[5] + 8) + 40), a2 + 8);
    ASTCTextureImp::setLock_blockSize(a1[7], v16);
    ASTCTextureImp::setLock_dataSize(a1[7], v16);
    ASTCTextureImp::setLock_blockOffset(a1[7], 0);
    return 0;
  }
  if (a4 == 1280984659)
  {
    if (!*(_DWORD *)(v7 + 540))
    {
      _cg_jpeg_mem_term("initialize_block_invoke", 194, "*** ERROR: lzfseCompressed mismatch\n");
      return 4294967246;
    }
    ASTCTextureImp::setInputIsLZFSECompressed(a1[7], 1);
    uint64_t v12 = a1[7];
    int v13 = IIOScanner::getVal32AtPosition((IIOScanner *)(*(void *)(a1[5] + 8) + 40), a2 + 8);
    ASTCTextureImp::setCompressedLZFSESize(v12, v13);
    ASTCTextureImp::setCompressedLZFSEDataOffset(a1[7], a2 + 12);
    *(void *)(v7 + 576) = a2;
    uint64_t v14 = a1[7];
    uint64_t v15 = a2;
LABEL_27:
    ASTCTextureImp::setTextureBaseOffset(v14, v15);
    return 0;
  }
  if (a4 != 1212498244) {
    return v6;
  }
  uint64_t v8 = *(void *)(a1[4] + 8);
  if (*(unsigned char *)(v8 + 24))
  {
    _cg_jpeg_mem_term("initialize_block_invoke", 162, "*** ERROR: found multiple headers in ATX file\n");
    return 4294967246;
  }
  *(unsigned char *)(v8 + 24) = 1;
  unsigned int v17 = (IIOScanner *)(*(void *)(a1[5] + 8) + 40);

  return ATXReadPlugin::readHeader((ATXReadPlugin *)v7, v17, a3);
}

uint64_t ASTCTextureImp::setTextureBaseOffset(uint64_t this, uint64_t a2)
{
  *(void *)(this + 112) = a2;
  return this;
}

uint64_t ASTCTextureImp::isInputLZFSECompressed(ASTCTextureImp *this)
{
  return *((unsigned __int8 *)this + 40);
}

uint64_t ATXReadPlugin::readHeader(ATXReadPlugin *this, IIOScanner *a2, int a3)
{
  if (a3 != 84) {
    return 4294967246;
  }
  IIOScanner::copyBytes(a2, (char *)this + 488, 0x54uLL);
  if (*((_DWORD *)this + 122) != 1)
  {
    _cg_jpeg_mem_term("readHeader", 65, "*** ERROR: unsupported ATX version [%d]\n");
    return 4294967246;
  }
  if ((*((_DWORD *)this + 130) - 33) <= 0xFFFFFFDF)
  {
    _cg_jpeg_mem_term("readHeader", 66, "*** ERROR: unsupported ATX pixelDepth [%d]\n");
    return 4294967246;
  }
  if (*((_DWORD *)this + 136) > 8u)
  {
    _cg_jpeg_mem_term("readHeader", 67, "*** ERROR: unsupported ATX orientation [%d]\n");
    return 4294967246;
  }
  v4.i64[0] = 0x5555555555555555;
  v4.i64[1] = 0x5555555555555555;
  int8x16_t v5 = vceqq_s8(*(int8x16_t *)((char *)this + 548), v4);
  v4.i8[1] = 2;
  int8x16_t v6 = vandq_s8(v5, (int8x16_t)xmmword_188990DB0);
  v4.i8[0] = vaddv_s8(*(int8x8_t *)v6.i8);
  v6.i64[0] = vextq_s8(v6, v6, 8uLL).u64[0];
  v6.i8[0] = vaddv_s8(*(int8x8_t *)v6.i8);
  v6.i32[0] = (unsigned __int16)(v4.i16[0] | (v6.i16[0] << 8));
  uint8x8_t v7 = (uint8x8_t)vcnt_s8(*(int8x8_t *)v6.i8);
  v7.i16[0] = vaddlv_u8(v7);
  if (v7.i32[0] >= 4u && v7.i32[0] != 16)
  {
    _cg_jpeg_mem_term("readHeader", 75, "*** ERROR: invalid watermark [%d]\n");
    return 4294967246;
  }
  if (*((_DWORD *)this + 142) >= 7u)
  {
    _cg_jpeg_mem_term("readHeader", 77, "*** ERROR: unsupported alpha [%d]\n");
    return 4294967246;
  }
  return 0;
}

void *IIOScanner::copyBytes(void *this, void *__dst, size_t a3)
{
  uint64_t v3 = this[3];
  if (v3 + a3 < this[2]) {
    return memcpy(__dst, (const void *)(this[1] + v3), a3);
  }
  return this;
}

uint64_t ATXReadPlugin::initialize(ATXReadPlugin *this, IIODictionary *a2)
{
  uint64_t v48 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = (const void *)*((void *)this + 59);
  if (v3) {
  else
  }
    int8x16_t v4 = 0;
  uint64_t v47 = 0;
  long long v45 = 0u;
  long long v46 = 0u;
  long long v43 = 0u;
  long long v44 = 0u;
  IIOScanner::IIOScanner((IIOScanner *)&v43, *((IIOImageReadSession **)this + 3));
  if (*((unsigned char *)this + 341))
  {
    int8x16_t v5 = (unsigned __int8 *)*((void *)&v43 + 1);
    char v6 = *(_DWORD *)(*((void *)&v43 + 1) + 4) == 169478669;
    *((unsigned char *)this + 344) = v6;
    uint64_t v36 = 0;
    long long v37 = &v36;
    uint64_t v38 = 0x7002000000;
    uint64_t v39 = __Block_byref_object_copy__0;
    memset(v41, 0, sizeof(v41));
    uint64_t v40 = __Block_byref_object_dispose__0;
    uint64_t v42 = 0;
    IIOScanner::IIOScanner((IIOScanner *)v41, v5, v44, v6);
    v34[0] = 0;
    v34[1] = v34;
    void v34[2] = 0x2000000000;
    char v35 = 0;
    *((void *)this + 72) = 0;
    v33[0] = MEMORY[0x1E4F143A8];
    v33[1] = 0x40000000;
    v33[2] = ___ZN13ATXReadPlugin10initializeEP13IIODictionary_block_invoke;
    v33[3] = &unk_1E53BFDC8;
    v33[4] = v34;
    v33[5] = &v36;
    v33[6] = this;
    v33[7] = v4;
    uint64_t v7 = IterateChunks((IIOScanner *)(v37 + 5), (uint64_t)v33);
    if (v7)
    {
      kdebug_trace();
      goto LABEL_62;
    }
    uint64_t v8 = (ASTCTextureImp *)*((unsigned int *)this + 126);
    unint64_t v9 = *((void *)this + 73);
    if (v8 == 1714434612)
    {
      if (v9 <= 0x18)
      {
        IIOImageReadSession::getSize(*((IIOImageReadSession **)this + 3));
        LogError("initialize", 327, "*** bad ATX file '420f' [%d bytes]\n");
        goto LABEL_62;
      }
      unint64_t v10 = *((void *)this + 76);
      if (v10 <= 0x18)
      {
        IIOImageReadSession::getSize(*((IIOImageReadSession **)this + 3));
        LogError("initialize", 328, "*** bad ATX file '420f' [%d bytes]\n");
        goto LABEL_62;
      }
      unsigned int v11 = *((_DWORD *)this + 148);
      unsigned int v12 = *((_DWORD *)this + 128);
      if (v11 < v12)
      {
        LogError("initialize", 330, "*** bad ATX '420f' Y plane (%d vs %d)\n");
        goto LABEL_62;
      }
      unsigned int v13 = *((_DWORD *)this + 149);
      unsigned int v14 = *((_DWORD *)this + 129);
      if (v13 < v14)
      {
        LogError("initialize", 331, "*** bad ATX '420f' Y plane (%d vs %d)\n");
        goto LABEL_62;
      }
      unsigned int v15 = *((_DWORD *)this + 150);
      if (v15 < v11)
      {
        LogError("initialize", 332, "*** bad ATX '420f' Y-rowBytes too small (%d < %d)\n");
        goto LABEL_62;
      }
      if (v15 > v11 + 32)
      {
        LogError("initialize", 333, "*** bad ATX '420f' Y-rowBytes too big (%d < %d)\n");
        goto LABEL_62;
      }
      unsigned int v16 = *((_DWORD *)this + 154);
      if (v16 < v12 >> 1)
      {
        int v31 = 335;
      }
      else
      {
        unsigned int v17 = *((_DWORD *)this + 155);
        if (v17 >= v14 >> 1)
        {
          unsigned int v18 = *((_DWORD *)this + 156);
          if (v18 < v16)
          {
            LogError("initialize", 337, "*** bad ATX '420f' CbCr-rowBytes too small (%d < %d)\n");
          }
          else if (v18 > v16 + 32)
          {
            LogError("initialize", 338, "*** bad ATX '420f' CbCr-rowBytes too big (%d < %d)\n");
          }
          else if (v11 > 0x4E20)
          {
            LogError("initialize", 340, "*** bad ATX '420f' width: %d\n");
          }
          else if (v13 >= 0x4E21)
          {
            LogError("initialize", 341, "*** bad ATX '420f' height: %d\n");
          }
          else if (v11 > 2 * v16 + 32)
          {
            LogError("initialize", 342, "*** bad ATX '420f' width:   Y: %d CbCr:%d\n");
          }
          else if (v13 > 2 * v17 + 32)
          {
            LogError("initialize", 343, "*** bad ATX '420f' height:   Y: %d CbCr:%d\n");
          }
          else
          {
            if (*((unsigned char *)this + 632))
            {
LABEL_25:
              *((_WORD *)this + 188) = 12;
LABEL_50:
              *((_DWORD *)this + 57) = v12;
              *((_DWORD *)this + 58) = v14;
              *((_WORD *)this + 120) = 8;
              *((_DWORD *)this + 59) = 4 * v12;
              *(_DWORD *)((char *)this + 242) = 262176;
              switch(*((_DWORD *)this + 141))
              {
                case 0:
                  *((void *)this + 20) = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E4F1DC98]);
                  if ((gIIODebugFlags & 0x30000) != 0) {
                    ImageIOLog("     colorspace: kCGColorSpaceSRGB (gray)\n");
                  }
                  break;
                case 1:
                  *((void *)this + 20) = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E4F1DC98]);
                  if ((gIIODebugFlags & 0x30000) != 0) {
                    ImageIOLog("     colorspace: kCGColorSpaceSRGB\n");
                  }
                  break;
                case 2:
                  *((void *)this + 20) = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E4F1DB78]);
                  if ((gIIODebugFlags & 0x30000) != 0) {
                    ImageIOLog("     colorspace: kCGColorSpaceAdobeRGB1998\n");
                  }
                  break;
                case 3:
                  *((void *)this + 20) = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E4F1DB90]);
                  if ((gIIODebugFlags & 0x30000) != 0) {
                    ImageIOLog("     colorspace: kCGColorSpaceDisplayP3\n");
                  }
                  break;
                case 4:
                  *((void *)this + 20) = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E4F1DBE8]);
                  if ((gIIODebugFlags & 0x30000) != 0) {
                    ImageIOLog("     colorspace: kCGColorSpaceExtendedSRGB\n");
                  }
                  break;
                default:
                  break;
              }
              *((_DWORD *)this + 81) = 1380401696;
              int v28 = *((_DWORD *)this + 142) & 0x1F;
              *((_DWORD *)this + 142) = v28;
              *((unsigned char *)this + 246) = v28;
              *((unsigned char *)this + 278) = v28;
              *((unsigned char *)this + 346) = 0;
              *((_DWORD *)this + 59) = 4 * *((_DWORD *)this + 57);
              *((unsigned char *)this + 350) = 1;
              goto LABEL_62;
            }
            if (v9 + v13 * v11 >= v10)
            {
              int v32 = 353;
            }
            else
            {
              unint64_t v19 = v16 * (unint64_t)v17;
              if ((v19 & 0xFFFFFFFF00000000) != 0)
              {
                int v32 = 356;
              }
              else
              {
                if (v10 + v19 < (unint64_t)v44) {
                  goto LABEL_25;
                }
                int v32 = 357;
              }
            }
            LogError("initialize", v32, "*** bad ATX '420f'\n");
          }
LABEL_62:
          _Block_object_dispose(v34, 8);
          _Block_object_dispose(&v36, 8);
          IIOScanner::~IIOScanner((IIOScanner *)v41);
          goto LABEL_63;
        }
        int v31 = 336;
      }
      LogError("initialize", v31, "*** bad ATX '420f' CbCr plane (%d vs %d)\n");
      goto LABEL_62;
    }
    if (v9)
    {
      int v30 = 363;
    }
    else
    {
      if (!*((void *)this + 76))
      {
        if (!*((void *)this + 72))
        {
          IIOImageReadSession::getSize(*((IIOImageReadSession **)this + 3));
          LogError("initialize", 366, "*** bad ATX file [%d bytes]\n");
          goto LABEL_62;
        }
        *((_DWORD *)this + 112) = ASTCTextureImp::MetalFormatForGLFormat(v8);
        int v20 = *((_DWORD *)this + 126);
        char v21 = 4;
        if (v20 > 37839)
        {
          if (v20 == 37840) {
            goto LABEL_37;
          }
          int v22 = 37847;
        }
        else
        {
          if (v20 == 37808) {
            goto LABEL_37;
          }
          int v22 = 37815;
        }
        if (v20 != v22) {
          goto LABEL_62;
        }
        char v21 = 8;
LABEL_37:
        *((unsigned char *)this + 572) = v21;
        *((unsigned char *)this + 573) = v21;
        *((unsigned char *)this + 574) = 1;
        int v23 = *((_DWORD *)this + 128);
        *((_DWORD *)this + 109) = v23;
        int v24 = *((_DWORD *)this + 129);
        *((_DWORD *)this + 110) = v24;
        ASTCTextureImp::setTextureDimension((uint64_t)v4, v23, v24);
        ASTCTextureImp::setMetalFormat((uint64_t)v4, *((_DWORD *)this + 112));
        if (ASTCTextureImp::isInputPreTwiddled(v4))
        {
          int v25 = *((unsigned __int8 *)this + 573) | (16 * *((unsigned __int8 *)this + 572));
          if (v25 == 136) {
            unsigned int v26 = 37815;
          }
          else {
            unsigned int v26 = 0;
          }
          if (v25 == 68) {
            uint64_t v27 = 37808;
          }
          else {
            uint64_t v27 = v26;
          }
          ASTCTextureImp::MetalFormatForGLFormat((ASTCTextureImp *)v27);
          operator new();
        }
        *((_DWORD *)this + 113) = (*((_DWORD *)this + 109) + *((unsigned __int8 *)this + 572) - 1)
                                / *((unsigned __int8 *)this + 572);
        *((_DWORD *)this + 114) = (*((_DWORD *)this + 110) + *((unsigned __int8 *)this + 573) - 1)
                                / *((unsigned __int8 *)this + 573);
        if ((gIIODebugFlags & 0x30000) != 0)
        {
          ImageIOLog("    %s:\n", "initialize");
          if ((gIIODebugFlags & 0x30000) != 0)
          {
            ImageIOLog("    textureSize: %d x %d\n", *((_DWORD *)this + 109), *((_DWORD *)this + 110));
            if ((gIIODebugFlags & 0x30000) != 0) {
              ImageIOLog("         blocks: %d x %d\n", *((_DWORD *)this + 113), *((_DWORD *)this + 114));
            }
          }
        }
        ASTCTextureImp::setDim(v4, *((unsigned __int8 *)this + 572), *((unsigned __int8 *)this + 573));
        ASTCTextureImp::setBlocks((uint64_t)v4, *((_DWORD *)this + 113), *((_DWORD *)this + 114));
        *((_WORD *)this + 188) = 13;
        unsigned int v12 = *((_DWORD *)this + 128);
        unsigned int v14 = *((_DWORD *)this + 129);
        goto LABEL_50;
      }
      int v30 = 364;
    }
    LogError("initialize", v30, "*** bad ATX file \n");
    goto LABEL_62;
  }
  uint64_t v7 = 4294967246;
LABEL_63:
  IIOScanner::~IIOScanner((IIOScanner *)&v43);
  return v7;
}

void sub_1885EF9B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27)
{
  _Block_object_dispose(&a23, 8);
  _Block_object_dispose(&a27, 8);
  IIOScanner::~IIOScanner(v27);
  IIOScanner::~IIOScanner((IIOScanner *)(v28 - 160));
  _Unwind_Resume(a1);
}

uint64_t ASTCTextureImp::MetalFormatForGLFormat(ASTCTextureImp *this)
{
  if ((this - 37808) > 0x2D) {
    return 0;
  }
  else {
    return dword_18899146C[(int)this - 37808];
  }
}

uint64_t ASTCTextureImp::setBlocks(uint64_t this, int a2, int a3)
{
  *(_DWORD *)(this + 20) = a2;
  *(_DWORD *)(this + 24) = a3;
  return this;
}

float ASTCTextureImp::setDim(ASTCTextureImp *this, int a2, int a3)
{
  *((_DWORD *)this + 7) = a2;
  *((_DWORD *)this + 8) = a3;
  float result = 128.0 / (double)(a3 * a2);
  *((float *)this + 9) = result;
  return result;
}

uint64_t ASTCTextureImp::setTextureDimension(uint64_t this, int a2, int a3)
{
  *(_DWORD *)(this + 100) = a2;
  *(_DWORD *)(this + 104) = a3;
  return this;
}

uint64_t ASTCTextureImp::isInputPreTwiddled(ASTCTextureImp *this)
{
  return *((unsigned __int8 *)this + 41);
}

uint64_t ASTCTextureImp::setMetalFormat(uint64_t this, int a2)
{
  *(_DWORD *)(this + 96) = a2;
  return this;
}

uint64_t IIOScanner::getVal32AtPosition(IIOScanner *this, uint64_t a2)
{
  if ((unint64_t)(a2 + 3) >= *((void *)this + 2))
  {
    LogError("getVal32AtPosition", 274, "*** IIOScanner::getVal32AtPosition reached EOF\n");
    *((_DWORD *)this + 16) = -39;
    exception = __cxa_allocate_exception(4uLL);
    _DWORD *exception = -39;
    __cxa_throw(exception, MEMORY[0x1E4FBA3A8], 0);
  }
  unsigned int v2 = *(_DWORD *)(*((void *)this + 1) + a2);
  unsigned int v3 = bswap32(v2);
  if (*((unsigned char *)this + 68)) {
    return v2;
  }
  else {
    return v3;
  }
}

uint64_t IIO_Reader_KTX::getImageCount(IIO_Reader_KTX *this, IIOImageReadSession *a2, IIODictionary *a3, CGImageSourceStatus *a4, unsigned int *a5)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  uint64_t v16 = 0;
  long long v14 = 0u;
  long long v15 = 0u;
  long long v12 = 0u;
  long long v13 = 0u;
  IIOScanner::IIOScanner((IIOScanner *)&v12, a2);
  unsigned int v7 = v13;
  long long v18 = 0u;
  memset(__dst, 0, sizeof(__dst));
  if (IIOScanner::getBytesAtOffset((IIOScanner *)&v12, __dst, 0, 0x40uLL) != 64)
  {
    unsigned int v9 = 1;
LABEL_13:
    uint64_t v8 = 4294967246;
    goto LABEL_14;
  }
  memset(v11, 0, sizeof(v11));
  if (!(*(unsigned int (**)(IIO_Reader_KTX *, int8x16_t *, uint64_t, void, void *))(*(void *)this + 16))(this, __dst, 64, 0, v11))
  {
LABEL_12:
    unsigned int v9 = 0;
    goto LABEL_13;
  }
  SwapKTXHeader(__dst);
  uint64_t v8 = ValidateKTXHeader(__dst, v13);
  if (v8)
  {
    unsigned int v9 = 0;
    goto LABEL_14;
  }
  if (HIDWORD(v18) > v7)
  {
    _cg_jpeg_mem_term("getImageCount", 164, "*** invalid KTX file: bytesOfKeyValueData: %d (fileSize: %d)\n", HIDWORD(v18), v7);
    goto LABEL_12;
  }
  unsigned int v9 = DWORD1(v18);
  uint64_t v8 = 0;
  if (v18)
  {
    if (DWORD1(v18) == 1) {
      unsigned int v9 = v18;
    }
    else {
      unsigned int v9 = 1;
    }
  }
LABEL_14:
  if (a5) {
    *a5 = v9;
  }
  IIOScanner::~IIOScanner((IIOScanner *)&v12);
  return v8;
}

void sub_1885EFC90(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15)
{
}

int8x16_t SwapKTXHeader(int8x16_t *a1)
{
  if (a1->i32[3] != 67305985)
  {
    int8x16_t v1 = vrev32q_s8(a1[2]);
    a1[1] = vrev32q_s8(a1[1]);
    a1[2] = v1;
    int8x16_t result = vrev32q_s8(a1[3]);
    a1[3] = result;
  }
  return result;
}

uint64_t ValidateKTXHeader(_DWORD *a1, unint64_t a2)
{
  if (!a1 || a1[11] > 0x7Fu) {
    return 4294967246;
  }
  unint64_t v3 = a1[12];
  uint64_t result = 4294967246;
  if (v3 < a2)
  {
    if (a1[14] <= 0x20u) {
      return 0;
    }
    else {
      return 4294967246;
    }
  }
  return result;
}

uint64_t ASTCTextureImp::setCompressedLZFSEDataOffset(uint64_t this, uint64_t a2)
{
  *(void *)(this + 48) = a2;
  return this;
}

uint64_t ASTCTextureImp::setInputIsLZFSECompressed(uint64_t this, char a2)
{
  *(unsigned char *)(this + 40) = a2;
  return this;
}

uint64_t ASTCTextureImp::setCompressedLZFSESize(uint64_t this, int a2)
{
  *(_DWORD *)(this + 44) = a2;
  return this;
}

uint64_t ASTCTextureImp::needs_hdr(ASTCTextureImp *this)
{
  return *((unsigned __int8 *)this + 42);
}

uint64_t ASTCTextureImp::GetXYdimFromMetalFormat(uint64_t this, unsigned char *a2, unsigned __int8 *a3, unsigned __int8 *a4)
{
  int v4 = this - 186;
  if ((this - 186) > 0x32)
  {
    char v5 = 0;
    unsigned __int8 v6 = 0;
  }
  else
  {
    char v5 = byte_1889915F0[v4];
    unsigned __int8 v6 = byte_188991623[v4];
  }
  *a2 = v5;
  *a3 = v6;
  return this;
}

uint64_t ASTCReadPlugin::extractMetadata(uint64_t a1, uint64_t a2)
{
  unint64_t v3 = *(unsigned int *)(a2 + 60);
  uint64_t v25 = 0;
  long long v23 = 0u;
  long long v24 = 0u;
  long long v21 = 0u;
  long long v22 = 0u;
  IIOScanner::IIOScanner((IIOScanner *)&v21, *(IIOImageReadSession **)(a1 + 24));
  if (v3 + 64 < (unint64_t)v22)
  {
    uint64_t v4 = *((void *)&v21 + 1) + 64;
    uint64_t v20 = 0;
    long long v18 = 0u;
    long long v19 = 0u;
    long long v16 = 0u;
    long long v17 = 0u;
    IIOScanner::IIOScanner((IIOScanner *)&v16, (unsigned __int8 *)(*((void *)&v21 + 1) + 64), v3, *(unsigned char *)(a1 + 344));
    while (1)
    {
      if (*((void *)&v17 + 1) + 4 >= v3
        || (unsigned int Val32 = IIOScanner::getVal32((IIOScanner *)&v16), v3 - *((void *)&v17 + 1) <= Val32)
        || (v6 = (Val32 + 3) & 0xFFFFFFFC, unint64_t v7 = *((void *)&v17 + 1) + v6, *((void *)&v17 + 1) + v6 > v3)
        || *(void *)(a1 + 184) <= v6)
      {
LABEL_37:
        uint64_t v14 = 1;
        IIOScanner::~IIOScanner((IIOScanner *)&v16);
        goto LABEL_38;
      }
      uint64_t v8 = (const char *)(v4 + *((void *)&v17 + 1));
      if (!strncmp((const char *)(v4 + *((void *)&v17 + 1)), "KTXorientation", v6))
      {
        IIOScanner::skip((uint64_t)&v16, 15);
        unint64_t v10 = v3 - *((void *)&v17 + 1);
        if (v3 - *((void *)&v17 + 1) < 7) {
          goto LABEL_33;
        }
        unsigned int v11 = (const char *)(v4 + *((void *)&v17 + 1));
        if (!strncmp((const char *)(v4 + *((void *)&v17 + 1)), "S=r,T=d", v6))
        {
LABEL_21:
          char v12 = 1;
LABEL_32:
          *(unsigned char *)(a1 + 509) = v12;
          goto LABEL_33;
        }
        if (!strncmp(v11, "S=r,T=u", v6))
        {
          char v12 = 4;
          goto LABEL_32;
        }
        if (v10 >= 0xC && (!strncmp(v11, "S=r,T=d,R=i", v6) || !strncmp(v11, "S=r,T=u,R=o", v6))) {
          goto LABEL_21;
        }
      }
      else
      {
        if (!strncmp(v8, "ColorSpace_APPLE", v6))
        {
          IIOScanner::skip((uint64_t)&v16, 17);
          int Val8 = IIOScanner::getVal8((IIOScanner *)&v16);
        }
        else
        {
          if (!strncmp(v8, "Compression_APPLE", v6))
          {
            IIOScanner::skip((uint64_t)&v16, 18);
LABEL_26:
            *(unsigned char *)(a1 + 508) = 1;
            goto LABEL_33;
          }
          if (!strncmp(v8, "AlphaInfo_APPLE", v6))
          {
            IIOScanner::skip((uint64_t)&v16, 16);
            char v9 = IIOScanner::getVal8((IIOScanner *)&v16);
LABEL_28:
            if ((v9 & 0xF8) == 0x30) {
              *(unsigned char *)(a1 + 507) = v9 - 48;
            }
            goto LABEL_33;
          }
          if (strncmp(v8, "ColorSpace", v6))
          {
            if (!strncmp(v8, "Compression", v6))
            {
              IIOScanner::skip((uint64_t)&v16, 12);
              goto LABEL_26;
            }
            if (strncmp(v8, "AlphaInfo", v6)) {
              goto LABEL_33;
            }
            IIOScanner::skip((uint64_t)&v16, 10);
            char v9 = IIOScanner::getVal8((IIOScanner *)&v16);
            goto LABEL_28;
          }
          IIOScanner::skip((uint64_t)&v16, 11);
          int Val8 = IIOScanner::getVal8((IIOScanner *)&v16);
        }
        if ((Val8 - 48) <= 4) {
          *(unsigned char *)(a1 + 506) = Val8 - 48;
        }
      }
LABEL_33:
      if (v7 >= v3) {
        goto LABEL_37;
      }
      IIOScanner::seek((IIOScanner *)&v16, v7);
    }
  }
  _cg_jpeg_mem_term("extractMetadata", 153, "*** invalid KTX file: KTXHeader: %d  metadatSize: %d    fileSize: %d\n", 64, v3, v22);
  uint64_t v14 = 0;
LABEL_38:
  IIOScanner::~IIOScanner((IIOScanner *)&v21);
  return v14;
}

void sub_1885F00BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
  va_start(va, a15);
  IIOScanner::~IIOScanner((IIOScanner *)va);
  _Unwind_Resume(a1);
}

void sub_1885F00D4(void *a1)
{
}

void sub_1885F0104(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  IIOScanner::~IIOScanner((IIOScanner *)va);
  JUMPOUT(0x1885F00C4);
}

uint64_t IIOScanner::getVal8(IIOScanner *this)
{
  unint64_t v1 = *((void *)this + 3);
  if (v1 >= *((void *)this + 2))
  {
    LogError("getVal8", 149, "*** IIOScanner::getVal8 reached EOF\n");
    *((_DWORD *)this + 16) = -39;
    exception = __cxa_allocate_exception(4uLL);
    _DWORD *exception = -39;
    __cxa_throw(exception, MEMORY[0x1E4FBA3A8], 0);
  }
  uint64_t v2 = *((void *)this + 1);
  *((void *)this + 3) = v1 + 1;
  return *(unsigned __int8 *)(v2 + v1);
}

void ASTCTwiddler::~ASTCTwiddler(ASTCTwiddler *this)
{
  uint64_t v2 = *((void *)this + 1);
  *(void *)this = &unk_1ED4DEFA8;
  *((void *)this + 1) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }

  JUMPOUT(0x18C11C0E0);
}

{
  uint64_t v2;

  uint64_t v2 = *((void *)this + 1);
  *(void *)this = &unk_1ED4DEFA8;
  *((void *)this + 1) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
}

void ASTCTwiddler::ASTCTwiddlerImpl::~ASTCTwiddlerImpl(ASTCTwiddler::ASTCTwiddlerImpl *this)
{
  ASTCTwiddler::ASTCTwiddlerImpl::~ASTCTwiddlerImpl(this);

  JUMPOUT(0x18C11C0E0);
}

{
  unint64_t v2;

  *(void *)this = &unk_1ED4E61F0;

  *((void *)this + 7) = 0;
  uint64_t v2 = *((void *)this + 5);
  if (v2) {
    _ImageIO_Free(v2, *((void *)this + 6));
  }
  *((void *)this + 5) = 0;
}

uint64_t ASTCTextureImp::setInputIsPreTwiddled(uint64_t this, char a2)
{
  *(unsigned char *)(this + 41) = a2;
  return this;
}

uint64_t ASTCTextureImp::setLock_blockOffset(uint64_t this, uint64_t a2)
{
  *(void *)(this + 152) = a2;
  return this;
}

uint64_t ASTCTextureImp::setLock_blockSize(uint64_t this, uint64_t a2)
{
  *(void *)(this + 160) = a2;
  return this;
}

uint64_t ASTCTextureImp::setLock_dataSize(uint64_t this, uint64_t a2)
{
  *(void *)(this + 144) = a2;
  return this;
}

uint64_t ASTCTwiddler::getWatermark(ASTCTwiddler *this, unsigned __int8 *a2)
{
  uint64_t v2 = *((void *)this + 1);
  if (!v2) {
    return 0;
  }
  uint64_t result = *(void *)(v2 + 56);
  if (result)
  {
    *(void *)a2 = [(id)result watermark];
    *((void *)a2 + 1) = v5;
    return 1;
  }
  return result;
}

uint64_t __CGImageMetadataTagGetTypeID_block_invoke()
{
  uint64_t result = _CFRuntimeRegisterClass();
  CGImageMetadataTagGetTypeID::id = result;
  return result;
}

BOOL CGImageDestinationFinalize(CGImageDestinationRef idst)
{
  kdebug_trace();
  unsigned int v2 = (gIIODebugFlags >> 12) & 3;
  if (v2) {
    ImageIODebugOptions(v2, "A", "CGImageDestinationFinalize", idst, 0, -1, 0);
  }
  unint64_t v8 = 0;
  if (!idst)
  {
    LogError("CGImageDestinationFinalize", 5308, "*** ERROR: CGImageDestinationFinalize: destination is nil\n");
    goto LABEL_13;
  }
  CFTypeID v3 = CFGetTypeID(idst);
  if (CGImageDestinationGetTypeID::once != -1) {
    dispatch_once(&CGImageDestinationGetTypeID::once, &__block_literal_global_25);
  }
  if (v3 != CGImageDestinationGetTypeID::id)
  {
    LogError("CGImageDestinationFinalize", 5309, "*** ERROR: CGImageDestinationFinalize: destination is not a CGImageDestinationRef\n");
    goto LABEL_13;
  }
  uint64_t v4 = *((void *)idst + 3);
  if (!v4)
  {
LABEL_13:
    int v5 = -50;
    goto LABEL_14;
  }
  int v5 = IIOImageDestination::finalizeDestination(*((IIOImageDestination **)idst + 3), (CFIndex *)&v8);
  size_t v6 = *(IIO_Reader **)(v4 + 64);
  if (v6) {
    IIO_Reader::osType(v6);
  }
LABEL_14:
  if ((gIIODebugFlags & 0x800000000000) != 0 && v5)
  {
    ImageIOLog(" ISSUE: %s:%d:  %s\n", "CGImageDestinationFinalize", 5321, "finalize failed");
  }
  else if (!v5)
  {
    goto LABEL_19;
  }
  kdebug_trace();
LABEL_19:
  kdebug_trace();
  return v5 == 0;
}

uint64_t IIOImageDestination::finalizeDestination(IIOImageDestination *this, CFIndex *a2)
{
  uint64_t v33 = *MEMORY[0x1E4F143B8];
  double Current = CFAbsoluteTimeGetCurrent();
  if (!*((void *)this + 2))
  {
    LogError("finalizeDestination", 3975, "*** ERROR: cannot finalize - invalid image destination\n");
LABEL_77:
    uint64_t v5 = 4294967246;
    goto LABEL_64;
  }
  if (*((unsigned char *)this + 225))
  {
    LogError("finalizeDestination", 3976, "*** ERROR: image destination was already finalized\n");
    goto LABEL_77;
  }
  if (*((unsigned char *)this + 224))
  {
    LogError("finalizeDestination", 3977, "*** ERROR: CGImageDestinationFinalize call is not allowed for this image destination (destination was updated with CGImageDestinationCopyImageSource)\n");
    goto LABEL_77;
  }
  if (*((_DWORD *)this + 51))
  {
    LogError("finalizeDestination", 3978, "*** ERROR: CGImageDestinationFinalize was called, but there were no images added [%d]\n");
    goto LABEL_77;
  }
  if (*((void *)this + 14) == *((void *)this + 13) && !*((void *)this + 20) && !*((void *)this + 21))
  {
    LogError("finalizeDestination", 3979, "*** ERROR: CGImageDestinationFinalize was called, but there were no images added\n");
    goto LABEL_77;
  }
  *((unsigned char *)this + 225) = 1;
  if (*((unsigned char *)this + 222))
  {
    if (*((unsigned char *)this + 223)) {
      uint64_t v5 = 0;
    }
    else {
      uint64_t v5 = 4294967246;
    }
    goto LABEL_12;
  }
  int v10 = *((unsigned __int8 *)this + 212);
  if (*((unsigned char *)this + 212))
  {
    if (*((void *)this + 20)) {
      int v10 = 1;
    }
    else {
      int v10 = *((void *)this + 21) != 0;
    }
  }
  *((unsigned char *)this + 216) = v10;
  char v11 = *((unsigned char *)this + 213);
  if (v11)
  {
    if (*((void *)this + 20)) {
      char v11 = 1;
    }
    else {
      char v11 = *((void *)this + 21) != 0;
    }
  }
  *((unsigned char *)this + 217) = v11;
  CFArrayRef v12 = (const __CFArray *)*((void *)this + 19);
  if (v12)
  {
    if (CFArrayGetCount(v12))
    {
      int v13 = 0;
      *((_WORD *)this + 108) = 0;
      goto LABEL_43;
    }
    int v10 = *((unsigned __int8 *)this + 216);
  }
  if (v10) {
    int v14 = IIOImageDestination::finalizeUsingAppleJPEGRecode(this);
  }
  else {
    int v14 = 0;
  }
  if (*((unsigned char *)this + 217)) {
    int v14 = IIOImageDestination::finalizeUsingHEIFRecode(this);
  }
  if (v14)
  {
    int v13 = 1;
  }
  else
  {
    if (*((unsigned char *)this + 216))
    {
      uint64_t v5 = 0;
      goto LABEL_12;
    }
    uint64_t v5 = 0;
    if (*((unsigned char *)this + 217)) {
      goto LABEL_12;
    }
    int v13 = 0;
  }
LABEL_43:
  CFArrayRef v15 = (const __CFArray *)*((void *)this + 12);
  if (!v15 || ((Count = CFArrayGetCount(v15)) == 0 ? (int v17 = 1) : (int v17 = v13), v17 == 1))
  {
    IIOImageDestination::finalizeUsingPixelProvider(this);
    CFArrayRef v18 = (const __CFArray *)*((void *)this + 12);
    if (!v18 || (unint64_t Count = CFArrayGetCount(v18)) == 0)
    {
      LogError("finalizeDestination", 4029, "*** ERROR: image destination must have at least one image\n");
      uint64_t v5 = 4294967228;
LABEL_64:
      if (IIOImageSource::count(*((IIOImageSource **)this + 3)))
      {
        long long v24 = (__CFData *)IIOImageSource::count(*((IIOImageSource **)this + 3));
        CFDataSetLength(v24, 0);
      }
      if ((gIIODebugFlags & 0x3000) != 0)
      {
        long long v31 = 0u;
        long long v32 = 0u;
        *(_OWORD *)uint64_t buffer = 0u;
        long long v30 = 0u;
        CFStringGetCString(*((CFStringRef *)this + 9), buffer, 64, 0x8000100u);
        ImageIOLog("*** %s - failed - '%s' (err: %d)\n", "finalizeDestination", buffer, v5);
      }
      goto LABEL_68;
    }
  }
  unint64_t v19 = *((void *)this + 5);
  if (v19)
  {
    if (Count > v19)
    {
      LogError("finalizeDestination", 4036, "*** ERROR: image destination does not have enough images (%d/%d)\n", Count, v19);
LABEL_80:
      uint64_t v5 = 0;
      goto LABEL_68;
    }
  }
  else if (IIO_Reader::testHeaderSize(*((IIO_Reader **)this + 8)) != -1 {
         && IIO_Reader::testHeaderSize(*((IIO_Reader **)this + 8)) < Count)
  }
  {
    uint64_t v27 = (const void *)IIO_Writer::utType(*((IIO_Writer **)this + 8));
    IIOString::IIOString((IIOString *)buffer, v27);
    uint64_t v28 = (const char *)IIOString::utf8String((IIOString *)buffer);
    LogError("finalizeDestination", 4033, "*** ERROR: image destination count %d is too large for format '%s'\n", Count, v28);
    IIOString::~IIOString((IIOString *)buffer);
    goto LABEL_80;
  }
  uint64_t v20 = (const void *)IIO_Writer::utType(*((IIO_Writer **)this + 8));
  IIODebugCallbackPriv(v20, "write");
  IIO_Reader::osType(*((IIO_Reader **)this + 8));
  kdebug_trace();
  uint64_t v5 = (***((uint64_t (****)(void))this + 8))();
  IIO_Reader::osType(*((IIO_Reader **)this + 8));
  kdebug_trace();
  if (v5)
  {
    long long v21 = (const void *)IIO_Writer::utType(*((IIO_Writer **)this + 8));
    IIOString::IIOString((IIOString *)buffer, v21);
    long long v22 = (const char *)IIOString::utf8String((IIOString *)buffer);
    _cg_jpeg_mem_term("finalizeDestination", 4049, "*** ERROR: '%s' - write failed (err: %d)\n", v22, v5);
    IIOString::~IIOString((IIOString *)buffer);
  }
  if (v13)
  {
    long long v23 = "with error";
    if (!v5) {
      long long v23 = "OK";
    }
    _cg_jpeg_mem_term("finalizeDestination", 4053, "*** NOTE: full transcode fallback completed: %s\n", v23);
  }
LABEL_12:
  size_t v6 = (const void *)*((void *)this + 12);
  if (v6)
  {
    CFRelease(v6);
    *((void *)this + 12) = 0;
  }
  if (v5) {
    goto LABEL_64;
  }
  uint64_t v5 = CGImageWriteSessionFinalize(*((void *)this + 2), 0);
  if (a2)
  {
    CFIndex Length = IIOImageSource::count(*((IIOImageSource **)this + 3));
    if (Length)
    {
      CFDataRef v8 = (const __CFData *)IIOImageSource::count(*((IIOImageSource **)this + 3));
      CFIndex Length = CFDataGetLength(v8);
    }
    *a2 = Length;
  }
  if ((gIIODebugFlags & 0x10000000) != 0 && IIOImageSource::count(*((IIOImageSource **)this + 3)))
  {
    CFDataRef v9 = (const __CFData *)IIOImageSource::count(*((IIOImageSource **)this + 3));
    ImageIO_saveImageData("CGImageDestinationFinalize", v9);
  }
  if (v5) {
    goto LABEL_64;
  }
LABEL_68:
  if ((gIIODebugFlags & 0x20000000000) != 0)
  {
    CFAbsoluteTime v25 = CFAbsoluteTimeGetCurrent();
    ImageIOLog("    IIOImageDestination::finalize - %g ms\n", (v25 - Current) * 1000.0);
  }
  return v5;
}

void sub_1885F0A80(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  IIOString::~IIOString((IIOString *)va);
  _Unwind_Resume(a1);
}

uint64_t IIOImageWriteSession::finalize(IIOImageWriteSession *this, int a2)
{
  CFStringRef v4 = (const __CFString *)*((void *)this + 5);
  if (v4)
  {
    CFIndex MaximumSizeOfFileSystemRepresentation = CFStringGetMaximumSizeOfFileSystemRepresentation(v4);
    size_t v6 = (std::__fs::filesystem::path *)malloc_type_malloc(MaximumSizeOfFileSystemRepresentation, 0xA4F987FAuLL);
    if (!CFStringGetFileSystemRepresentation(*((CFStringRef *)this + 5), (char *)v6, MaximumSizeOfFileSystemRepresentation))
    {
      unint64_t v7 = 0;
      goto LABEL_36;
    }
  }
  else
  {
    size_t v6 = 0;
  }
  CFStringRef v8 = (const __CFString *)*((void *)this + 6);
  if (v8)
  {
    CFIndex v9 = CFStringGetMaximumSizeOfFileSystemRepresentation(v8);
    unint64_t v7 = (std::__fs::filesystem::path *)malloc_type_malloc(v9, 0x747BEA1EuLL);
    if (!CFStringGetFileSystemRepresentation(*((CFStringRef *)this + 6), (char *)v7, v9)) {
      goto LABEL_36;
    }
    if (a2)
    {
      if (v7)
      {
        unlink((const char *)v7);
        goto LABEL_14;
      }
      goto LABEL_11;
    }
  }
  else
  {
    if (a2)
    {
LABEL_11:
      int v10 = (__CFData *)*((void *)this + 3);
      if (v10) {
        CFDataSetLength(v10, 0);
      }
      unint64_t v7 = 0;
      goto LABEL_14;
    }
    unint64_t v7 = 0;
  }
  if (!*((void *)this + 5))
  {
    if (!*((void *)this + 2)) {
      goto LABEL_14;
    }
    CFArrayRef v18 = (__CFData *)*((void *)this + 3);
    if (!v18) {
      goto LABEL_14;
    }
    if (!*((void *)this + 7)) {
      goto LABEL_14;
    }
    MutableBytePtr = CFDataGetMutableBytePtr(v18);
    uint64_t v20 = *((void *)this + 7);
    if (!v20) {
      goto LABEL_14;
    }
    long long v21 = MutableBytePtr;
    while (1)
    {
      uint64_t v22 = CGDataConsumerPutBytes();
      if (!v22) {
        break;
      }
      v21 += v22;
      v20 -= v22;
      if (!v20) {
        goto LABEL_14;
      }
    }
    LogError("finalize", 429, "*** ERROR: Could not write any more data to the consumer\n");
LABEL_36:
    uint64_t v11 = 4294967246;
    if (!v6) {
      goto LABEL_38;
    }
    goto LABEL_37;
  }
  CFArrayRef v12 = (FILE *)*((void *)this + 4);
  if (v12)
  {
    if ((gIIODebugFlags & 0x200000000000) != 0)
    {
      ImageIOLog("<<< CGImageWriteSessionFinalize: [%p] closing FILE* %p\n", this, v12);
      CFArrayRef v12 = (FILE *)*((void *)this + 4);
    }
    fclose(v12);
    *((unsigned char *)this + 73) = 0;
  }
  *((void *)this + 4) = 0;
  if (v6)
  {
    if (v7)
    {
      if (strcmp((const char *)v7, (const char *)v6))
      {
        rename(v7, v6, v13);
        if (v14)
        {
          CFArrayRef v15 = __error();
          long long v16 = strerror(*v15);
          int v17 = __error();
          LogError("finalize", 413, "*** ERROR: rename (\"%s\" to \"%s\") failed: '%s' (%d)\n", (const char *)v7, (const char *)v6, v16, *v17);
          unlink((const char *)v7);
          uint64_t v11 = 4294967246;
          goto LABEL_37;
        }
      }
    }
  }
LABEL_14:
  uint64_t v11 = 0;
  *((void *)this + 7) = 0;
  *((void *)this + 8) = 0;
  if (v6) {
LABEL_37:
  }
    free(v6);
LABEL_38:
  if (v7) {
    free(v7);
  }
  return v11;
}

uint64_t IIOGeneric_Writer::write(IIOGeneric_Writer *this, void *a2, void *a3)
{
  CFTypeID v3 = (uint64_t (*)(void *, void *, void, void))*((void *)this + 6);
  if (v3) {
    return v3(a2, a3, 0, 0);
  }
  else {
    return 4294967246;
  }
}

uint64_t PNGWritePlugin::WriteProc(PNGWritePlugin *this, IIOImageDestination *a2, void *a3, void *a4, void *a5)
{
  long long v13 = 0u;
  long long v14 = 0u;
  memset(v12, 0, sizeof(v12));
  long long v10 = 0u;
  long long v11 = 0u;
  memset(v9, 0, sizeof(v9));
  IIOWritePlugin::IIOWritePlugin((IIOWritePlugin *)v9, this, a2, 1347307296);
  memset(v12, 0, 21);
  *(_DWORD *)((char *)&v14 + 9) = 1;
  long long v11 = 0uLL;
  *(void *)&v9[0] = &unk_1ED4E2C38;
  *((void *)&v10 + 1) = 0;
  *((void *)&v13 + 1) = 0;
  *(void *)&long long v14 = 0;
  uint64_t v5 = PNGWritePlugin::writeAll((PNGWritePlugin *)v9);
  PNGWritePlugin::~PNGWritePlugin((PNGWritePlugin *)v9, v6, v7);
  return v5;
}

void sub_1885F0D8C(void *a1, uint64_t a2, const char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void PNGWritePlugin::~PNGWritePlugin(PNGWritePlugin *this, uint64_t a2, const char *a3)
{
  *(void *)this = &unk_1ED4E2C38;
  CFStringRef v4 = (void *)*((void *)this + 7);
  if (v4) {
    free(v4);
  }
  uint64_t v5 = (void *)*((void *)this + 14);
  if (v5) {
    free(v5);
  }
  if (*((void *)this + 5))
  {
    _cg_jpeg_mem_term("~PNGWritePlugin", 158, "*** PNGWritePlugin::~PNGWritePlugin -- cleaning up '_png_ptr' -- should have been done in writeEpilogue\n");
    if (*((void *)this + 6)) {
      uint64_t v6 = (void **)((char *)this + 48);
    }
    else {
      uint64_t v6 = 0;
    }
    _cg_png_destroy_write_struct((uint64_t *)this + 5, v6);
    *((void *)this + 5) = 0;
    *((void *)this + 6) = 0;
  }

  _cg_jpeg_mem_term(this, a2, a3);
}

{
  uint64_t vars8;

  PNGWritePlugin::~PNGWritePlugin(this, a2, a3);

  JUMPOUT(0x18C11C0E0);
}

uint64_t PNGWritePlugin::writeAll(PNGWritePlugin *this)
{
  Imageunint64_t Count = IIOWritePlugin::getImageCount((IIOImageDestination **)this);
  *((_DWORD *)this + 18) = ImageCount;
  if (ImageCount)
  {
    Containerunint64_t Properties = (IIODictionary *)IIOWritePlugin::getContainerProperties((IIOImagePlus **)this);
    *((unsigned char *)this + 121) = 1;
    PixelDataProviderAtIndedouble x = (IIOImagePixelDataProvider *)IIOWritePlugin::getPixelDataProviderAtIndex((CFArrayRef **)this, 0);
    uint64_t v5 = PixelDataProviderAtIndex;
    if (PixelDataProviderAtIndex)
    {
      BOOL hasAlpha = IIOImagePixelDataProvider::hasAlpha(PixelDataProviderAtIndex);
      PropertiesAtIndedouble x = (IIODictionary *)IIOWritePlugin::getPropertiesAtIndex((IIOImageDestination **)this, 0);
      *((void *)this + 11) = IIOImageSource::count(v5);
      *((void *)this + 12) = IIO_Reader::testHeaderSize(v5);
      *((_DWORD *)this + 19) = 0;
      if (*((_DWORD *)this + 18) == 1)
      {
        CFStringRef v8 = (IIOImageSource *)IIOWritePlugin::getPixelDataProviderAtIndex((CFArrayRef **)this, 0);
        uint64_t Ref = (CGImage *)IIOImageSource::imageReadRef(v8);
        CGImageGetColorSpace(Ref);
        if (CGColorSpaceGetType() == 7) {
          *((unsigned char *)this + 124) = 1;
        }
      }
      else
      {
        if (IIODictionary::containsKeyGroup(ContainerProperties, @"LoopCount", @"{PNG}")) {
          *((_DWORD *)this + 20) = IIODictionary::getUint32ForKeyGroup(ContainerProperties, @"LoopCount", @"{PNG}");
        }
        if (*((_DWORD *)this + 18) >= 2u)
        {
          uint64_t v10 = 0;
          while (1)
          {
            long long v11 = (IIOImageSource *)IIOWritePlugin::getPixelDataProviderAtIndex((CFArrayRef **)this, v10 + 1);
            CFArrayRef v12 = v11;
            if (v11)
            {
              uint64_t v13 = *((void *)this + 11);
              if (v13 != IIOImageSource::count(v11)) {
                break;
              }
              uint64_t v14 = *((void *)this + 12);
              if (v14 != IIO_Reader::testHeaderSize(v12)) {
                break;
              }
            }
            unint64_t v15 = *((unsigned int *)this + 18);
            unint64_t v16 = v10 + 2;
            ++v10;
            if (v16 >= v15) {
              goto LABEL_18;
            }
          }
          LODWORD(v15) = v10 + 1;
          uint64_t v17 = 115;
          if (!v10) {
            uint64_t v17 = 32;
          }
          _cg_jpeg_mem_term("writeAll", 1565, "*** ERROR trying to write APNG with %d frames - but frame sizes do not match. Writing %d frame%c.\n", *((_DWORD *)this + 18), v10 + 1, v17);
          *((_DWORD *)this + 18) = v15;
LABEL_18:
          if (v15 >= 2)
          {
            CFIndex v18 = 1;
            while (1)
            {
              unint64_t v19 = (IIOImagePixelDataProvider *)IIOWritePlugin::getPixelDataProviderAtIndex((CFArrayRef **)this, v18);
              if (hasAlpha != IIOImagePixelDataProvider::hasAlpha(v19)) {
                break;
              }
              if (++v18 >= (unint64_t)*((unsigned int *)this + 18)) {
                goto LABEL_24;
              }
            }
            *((unsigned char *)this + 121) = 0;
          }
        }
LABEL_24:
        CFStringRef v8 = (IIOImageSource *)IIOWritePlugin::getPixelDataProviderAtIndex((CFArrayRef **)this, 0);
        uint64_t v20 = (CGImage *)IIOImageSource::imageReadRef(v8);
        ColorSpace = CGImageGetColorSpace(v20);
        if (CGColorSpaceGetType() == 7)
        {
          ColorTableunint64_t Count = CGColorSpaceGetColorTableCount(ColorSpace);
          BaseColorSpace = CGColorSpaceGetBaseColorSpace(ColorSpace);
          int NumberOfComponents = CGColorSpaceGetNumberOfComponents(BaseColorSpace);
          CFAbsoluteTime v25 = (uint8_t *)malloc_type_malloc((NumberOfComponents * ColorTableCount), 0x6B6F3D69uLL);
          if (v25)
          {
            CGColorSpaceGetColorTable(ColorSpace, v25);
            *((unsigned char *)this + 124) = 1;
            if (*((_DWORD *)this + 18) < 2u) {
              goto LABEL_39;
            }
            CFIndex v26 = 1;
            while (1)
            {
              uint64_t v27 = (IIOImageSource *)IIOWritePlugin::getPixelDataProviderAtIndex((CFArrayRef **)this, v26);
              uint64_t v28 = (CGImage *)IIOImageSource::imageReadRef(v27);
              char v29 = CGImageGetColorSpace(v28);
              if (CGColorSpaceGetType() != 7)
              {
                *((unsigned char *)this + 124) = 0;
                _cg_jpeg_mem_term("writeAll", 1618, "*** writing indexed color APNG - image #d has no color palette\n", v26);
                goto LABEL_39;
              }
              int v30 = CGColorSpaceGetColorTableCount(v29);
              long long v31 = CGColorSpaceGetBaseColorSpace(v29);
              int v32 = CGColorSpaceGetNumberOfComponents(v31);
              if (v30 != ColorTableCount || v32 != NumberOfComponents) {
                break;
              }
              size_t v33 = (v32 * v30);
              long long v34 = (uint8_t *)malloc_type_malloc(v33, 0x39F8AB20uLL);
              if (!v34 || (CGColorSpaceGetColorTable(v29, v34), int v35 = memcmp(v34, v25, v33), free(v34), v35))
              {
                *((unsigned char *)this + 124) = 0;
                goto LABEL_39;
              }
              if (++v26 >= (unint64_t)*((unsigned int *)this + 18)) {
                goto LABEL_39;
              }
            }
            *((unsigned char *)this + 124) = 0;
            int v36 = CGColorSpaceGetColorTableCount(v29);
            _cg_jpeg_mem_term("writeAll", 1627, "*** writing indexed color APNG - image #%d: color palette mismatch (%d entries expected, got %d)\n", v26, ColorTableCount, v36);
LABEL_39:
            free(v25);
          }
          else
          {
            *((unsigned char *)this + 124) = 0;
          }
        }
      }
      uint64_t result = PNGWritePlugin::writePrologue(this, v8, PropertiesAtIndex);
      if (result) {
        return result;
      }
      int v40 = *((_DWORD *)this + 18);
      if (v40 == 1)
      {
        PNGWritePlugin::writePNG(this, v8, PropertiesAtIndex);
LABEL_56:
        PNGWritePlugin::writeEpilogue(this, v38, v39);
        return 0;
      }
      if (*((unsigned char *)this + 121))
      {
        if (!v40) {
          goto LABEL_56;
        }
      }
      else
      {
        _cg_jpeg_mem_term("writeAll", 1671, "alpha mismatch - convert all frames to have alpha\n");
        if (!*((_DWORD *)this + 18)) {
          goto LABEL_56;
        }
      }
      unint64_t v41 = 0;
      while (1)
      {
        if ((gIIODebugFlags & 0x30000) != 0) {
          ImageIOLog("    ==== writing APNG frame #%zu =================\n", v41);
        }
        if (v41)
        {
          CFStringRef v8 = (IIOImageSource *)IIOWritePlugin::getPixelDataProviderAtIndex((CFArrayRef **)this, v41);
          uint64_t v42 = IIOWritePlugin::getPropertiesAtIndex((IIOImageDestination **)this, v41);
          if (!v8) {
            return 4294967292;
          }
          PropertiesAtIndedouble x = (IIODictionary *)v42;
          *((unsigned char *)this + 120) = IIOImagePixelDataProvider::hasAlpha(v8);
        }
        else if (IIODictionary::containsKey(PropertiesAtIndex, @"kCGImageDestinationOptimizeForSize"))
        {
          *((unsigned char *)this + 123) = IIODictionary::getBoolForKey(PropertiesAtIndex, @"kCGImageDestinationOptimizeForSize");
        }
        *((_DWORD *)this + 19) = v41;
        PNGWritePlugin::writeAPNGFrame(this, v8, PropertiesAtIndex);
        _cg_png_reset_write(*((void ***)this + 5));
        if (++v41 >= *((unsigned int *)this + 18)) {
          goto LABEL_56;
        }
      }
    }
  }
  return 4294967246;
}

void sub_1885F138C(_Unwind_Exception *a1)
{
}

uint64_t IIOImageDestination::getPixelProviderAtIndex(CFArrayRef *this, CFIndex a2)
{
  unsigned int Count = CFArrayGetCount(this[12]);
  if (a2 < Count)
  {
    ValueAtIndedouble x = CFArrayGetValueAtIndex(this[12], a2);
    if (ValueAtIndex) {
      BOOL v6 = ValueAtIndex == (void *)*MEMORY[0x1E4F1D260];
    }
    else {
      BOOL v6 = 1;
    }
    if (!v6) {
      return ValueAtIndex[3];
    }
    return 0;
  }
  uint64_t result = 0;
  if (a2 && Count)
  {
    _cg_jpeg_mem_term("getPixelProviderAtIndex", 4145, "*** getImageMetadataAtIndex index (%d) larger than arrayCount (%d)\n", a2, Count);
    return 0;
  }
  return result;
}

uint64_t IIOWritePlugin::getPixelDataProviderAtIndex(CFArrayRef **this, CFIndex a2)
{
  return IIOImageDestination::getPixelProviderAtIndex(this[3], a2);
}

BOOL IIOImagePixelDataProvider::hasAlpha(IIOImagePixelDataProvider *this)
{
  return (*((_DWORD *)this + 24) & 0x1Fu) - 1 < 4;
}

uint64_t IIOImageDestination::getImagePropertiesAtIndex(IIOImageDestination *this, unint64_t a2)
{
  uint64_t v2 = *((void *)this + 16);
  unint64_t v3 = (*((void *)this + 17) - v2) >> 3;
  if (v3 > a2) {
    return *(void *)(v2 + 8 * a2);
  }
  _cg_jpeg_mem_term("getImagePropertiesAtIndex", 4225, "*** ERROR: IIOImageDestination::getImagePropertiesAtIndex - index (%d) larger than vector size (%d)\n", a2, v3);
  return 0;
}

uint64_t IIOWritePlugin::getContainerProperties(IIOImagePlus **this)
{
  return IIOImagePlus::getSourceGeomColorSpace(this[3]);
}

uint64_t IIOWritePlugin::getPropertiesAtIndex(IIOImageDestination **this, unint64_t a2)
{
  return IIOImageDestination::getImagePropertiesAtIndex(this[3], a2);
}

const __CFArray *IIOWritePlugin::getImageCount(IIOImageDestination **this)
{
  return IIOImageDestination::pixelProviderCount(this[3]);
}

const __CFArray *IIOImageDestination::pixelProviderCount(IIOImageDestination *this)
{
  CFArrayRef result = (const __CFArray *)*((void *)this + 12);
  if (result) {
    return (const __CFArray *)CFArrayGetCount(result);
  }
  return result;
}

uint64_t CGImageWriteSessionFinalize(uint64_t a1, int a2)
{
  if (a1 && (uint64_t v2 = *(IIOImageWriteSession **)(a1 + 24)) != 0) {
    return IIOImageWriteSession::finalize(v2, a2);
  }
  else {
    return 4294967246;
  }
}

CGImageDestinationRef CGImageDestinationCreateWithData(CFMutableDataRef data, CFStringRef type, size_t count, CFDictionaryRef options)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  kdebug_trace();
  IIOInitDebugFlags();
  if (data)
  {
    if (type)
    {
      if (!count) {
        LogError("CGImageDestinationCreateWithData", 4858, "*** ERROR: CGImageDestinationCreateWithData: invalid capacity (%zu)\n", 0);
      }
      CFTypeID v8 = CFGetTypeID(data);
      if (v8 == CFDataGetTypeID())
      {
        CFTypeID v9 = CFGetTypeID(type);
        if (v9 == CFStringGetTypeID())
        {
          if (options)
          {
            CFTypeID v10 = CFGetTypeID(options);
            if (v10 != CFDictionaryGetTypeID())
            {
              LogError("CGImageDestinationCreateWithData", 4863, "*** ERROR: CGImageDestinationCreateWithData: options parameter is not a CFDictionaryRef - ignoring\n");
              options = 0;
            }
          }
          if ((gIIODebugFlags & 0x3000) != 0)
          {
            long long v18 = 0u;
            long long v19 = 0u;
            *(_OWORD *)uint64_t buffer = 0u;
            long long v17 = 0u;
            CFStringGetCString(type, buffer, 64, 0x600u);
            unsigned int v11 = (gIIODebugFlags >> 12) & 3;
            if (v11) {
              ImageIODebugOptions(v11, "A", "CGImageDestinationCreateWithData", 0, buffer, -1, options);
            }
          }
          memset(buffer, 0, sizeof(buffer));
          *(void *)&long long v17 = 0;
          CFArrayRef v12 = IIODictionary::IIODictionary((IIODictionary *)buffer, options);
          WriterHandler = (IIO_WriterHandler *)IIO_WriterHandler::GetWriterHandler(v12);
          if (IIO_WriterHandler::findWriterForType(WriterHandler, type, (const __CFString *)count, (IIODictionary *)buffer, v14))
          {
            operator new();
          }
          IIODictionary::~IIODictionary((IIODictionary *)buffer);
          LogError("CGImageDestinationCreateWithData", 4879, "*** ERROR: CGImageDestinationCreateWithData: failed to create 'CGImageDestinationRef'\n");
        }
        else
        {
          LogError("CGImageDestinationCreateWithData", 4860, "*** ERROR: CGImageDestinationCreateWithData: type is not a CFStringRef\n");
        }
      }
      else
      {
        LogError("CGImageDestinationCreateWithData", 4859, "*** ERROR: CGImageDestinationCreateWithData: data is not a CFMutableDataRef\n");
      }
    }
    else
    {
      LogError("CGImageDestinationCreateWithData", 4856, "*** ERROR: CGImageDestinationCreateWithData: type is nil\n");
    }
  }
  else
  {
    LogError("CGImageDestinationCreateWithData", 4855, "*** ERROR: CGImageDestinationCreateWithData: data is nil\n");
  }
  if ((gIIODebugFlags & 0x800000000000) != 0) {
    ImageIOLog(" ISSUE: %s:%d:  %s\n", "CGImageDestinationCreateWithData", 4882, "could not create CGImageDestinationRef");
  }
  kdebug_trace();
  kdebug_trace();
  return 0;
}

void sub_1885F1874(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  MEMORY[0x18C11C0E0](v5, 0x10E1C40255C1624);
  IIODictionary::~IIODictionary((IIODictionary *)va);
  _Unwind_Resume(a1);
}

CFArrayRef CGImageDestinationCopyTypeIdentifiers(void)
{
  kdebug_trace();
  IIOInitDebugFlags();
  BOOL v0 = (IIO_WriterHandler *)((gIIODebugFlags >> 12) & 3);
  if (v0) {
    ImageIODebugOptions((int)v0, "A", "CGImageDestinationCopyTypeIdentifiers", 0, 0, -1, 0);
  }
  WriterHandler = (IIO_WriterHandler *)IIO_WriterHandler::GetWriterHandler(v0);
  uint64_t v2 = IIO_WriterHandler::copyTypeIdentifiers(WriterHandler);
  kdebug_trace();
  return v2;
}

uint64_t IIO_WriterHandler::GetWriterHandler(IIO_WriterHandler *this)
{
  if (IIO_WriterHandler::GetWriterHandler(void)::writerHandlerCreate != -1) {
    dispatch_once(&IIO_WriterHandler::GetWriterHandler(void)::writerHandlerCreate, &__block_literal_global_15);
  }
  return IIO_WriterHandler::GetWriterHandler(void)::gIIO_WriterHandler;
}

void IIOImageDestination::IIOImageDestination(IIOImageDestination *this, __CFData *a2, IIO_Writer *a3, const __CFString *a4, uint64_t a5, IIODictionary *a6)
{
  *(void *)this = &unk_1ED4E4C20;
  *(_OWORD *)((char *)this + 104) = 0u;
  *(_OWORD *)((char *)this + 120) = 0u;
  *(_OWORD *)((char *)this + 136) = 0u;
  IIOImageDestination::setup(this, 1);
  uint64_t v11 = CGImageWriteSessionCreateWithMutableData((uint64_t)a2);
  *((void *)this + 2) = v11;
  *((void *)this + 3) = CGImageSourceGetSource(v11);
  *((void *)this + 8) = a3;
  *((void *)this + 9) = IIO_Writer::utType(a3);
  *((void *)this + 5) = a5;
  IIOImageDestination::setProperties(this, a6);
}

void sub_1885F1A4C(_Unwind_Exception *exception_object)
{
  CFStringRef v4 = (void *)v1[16];
  if (v4)
  {
    v1[17] = v4;
    operator delete(v4);
  }
  uint64_t v5 = *v2;
  if (*v2)
  {
    v1[14] = v5;
    operator delete(v5);
  }
  _Unwind_Resume(exception_object);
}

CFMutableArrayRef IIOImageDestination::setup(CFMutableArrayRef result, int a2)
{
  *(_OWORD *)((char *)result + 72) = 0u;
  *(_OWORD *)((char *)result + 56) = 0u;
  *(_OWORD *)((char *)result + 40) = 0u;
  *(_OWORD *)((char *)result + 24) = 0u;
  *(_OWORD *)((char *)result + 8) = 0u;
  *((_OWORD *)result + 10) = 0u;
  *((_OWORD *)result + 11) = 0u;
  *(_DWORD *)((char *)result + 222) = 0;
  *((unsigned char *)result + 226) = 0;
  *((unsigned char *)result + 192) = a2;
  *((_DWORD *)result + 57) = 0;
  *((void *)result + 19) = 0;
  *((void *)result + 29) = result;
  *((void *)result + 30) = result;
  *((_DWORD *)result + 51) = 0;
  *((_DWORD *)result + 52) = 0;
  *((_WORD *)result + 106) = 0;
  *((unsigned char *)result + 216) = 0;
  *((void *)result + 11) = 0;
  *((void *)result + 12) = 0;
  *((_DWORD *)result + 49) = 0;
  if (a2 != 5)
  {
    CFMutableArrayRef v2 = result;
    CFArrayRef result = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
    *((void *)v2 + 12) = result;
  }
  return result;
}

const char *IIOImageDestination::setProperties(IIOImageDestination *this, IIODictionary *a2)
{
  if (*((void *)this + 2))
  {
    if (*((unsigned char *)this + 225))
    {
      BOOL v6 = "*** ERROR: image destination was already finalized\n";
      int v7 = 1966;
    }
    else
    {
      CFArrayRef v4 = (const __CFArray *)*((void *)this + 12);
      if (!v4 || !CFArrayGetCount(v4))
      {
        if (a2)
        {
          uint64_t v5 = *((void *)this + 11);
          if (v5) {
            (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
          }
          operator new();
        }
        operator new();
      }
      BOOL v6 = "*** ERROR: image destination cannot be changed once an image was added\n";
      int v7 = 1967;
    }
  }
  else
  {
    BOOL v6 = "*** ERROR: cannot set properties - invalid image destination\n";
    int v7 = 1965;
  }

  return LogError("setProperties", v7, v6);
}

void sub_1885F1C6C(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10A1C4047070A01);
  _Unwind_Resume(a1);
}

IIO_Reader *IIO_WriterHandler::findWriterForTypeAndAlternateType(IIO_WriterHandler *this, const __CFString *a2, const __CFString *a3, uint64_t a4, IIODictionary *a5)
{
  WriterForint Type = IIO_WriterHandler::getWriterForType(this, a2, a3);
  if (!WriterForType)
  {
    IIOString::IIOString((IIOString *)v13, a2);
    uint64_t v11 = (const char *)IIOString::utf8String((IIOString *)v13);
    LogError("findWriterForTypeAndAlternateType", 132, "*** ERROR: unsupported output file format '%s'\n", v11);
    IIOString::~IIOString((IIOString *)v13);
    kdebug_trace();
    return 0;
  }
  CFTypeID v8 = WriterForType;
  if (a4 && IIO_Reader::testHeaderSize(WriterForType) != -1 && IIO_Reader::testHeaderSize(v8) < a4)
  {
    IIOString::IIOString((IIOString *)v13, a2);
    CFTypeID v9 = (const char *)IIOString::utf8String((IIOString *)v13);
    int v10 = IIO_Reader::testHeaderSize(v8);
    LogError("findWriterForTypeAndAlternateType", 141, "*** ERROR: capacity parameter (%d) is too large for this file format '%s' (max is %d)\n", a4, v9, v10);
    IIOString::~IIOString((IIOString *)v13);
    return 0;
  }
  return v8;
}

void sub_1885F1DB4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  IIOString::~IIOString((IIOString *)va);
  _Unwind_Resume(a1);
}

IIO_Reader *IIO_WriterHandler::findWriterForType(IIO_WriterHandler *this, const __CFString *a2, const __CFString *a3, IIODictionary *a4, IIODictionary *a5)
{
  return IIO_WriterHandler::findWriterForTypeAndAlternateType(this, a2, a3, (uint64_t)a3, a5);
}

IIO_Writer *IIO_WriterHandler::getWriterForType(IIO_WriterHandler *this, const __CFString *a2, const __CFString *a3)
{
  unint64_t v3 = (IIO_Writer **)*((void *)this + 1);
  if (v3 == *((IIO_Writer ***)this + 2)) {
    return 0;
  }
  while (1)
  {
    CFStringRef v6 = (const __CFString *)IIO_Writer::utType(*v3);
    if (CFEqual(v6, a2)) {
      break;
    }
    if (++v3 == *((IIO_Writer ***)this + 2)) {
      return 0;
    }
  }
  return *v3;
}

__CFArray *IIO_WriterHandler::copyTypeIdentifiers(IIO_WriterHandler *this)
{
  CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
  for (unsigned __int16 i = (IIO_Writer **)*((void *)this + 1); i != *((IIO_Writer ***)this + 2); ++i)
  {
    if (IIO_Writer::addToTypeIdentifiers(*i))
    {
      CFArrayRef v4 = (const void *)IIO_Writer::utType(*i);
      CFArrayAppendValue(Mutable, v4);
    }
  }
  return Mutable;
}

uint64_t IIO_Writer::utType(IIO_Writer *this)
{
  uint64_t result = *((void *)this + 2);
  if (!result) {
    return **((void **)this + 1);
  }
  return result;
}

uint64_t IIO_Writer::addToTypeIdentifiers(IIO_Writer *this)
{
  return *((unsigned __int8 *)this + 44);
}

uint64_t CGImageDestinationRefCreateWith_ImageDestination(IIOImageDestination *a1)
{
  if (CGImageDestinationGetTypeID::once != -1) {
    dispatch_once(&CGImageDestinationGetTypeID::once, &__block_literal_global_25);
  }
  uint64_t result = _CFRuntimeCreateInstance();
  *(_DWORD *)(result + 16) = 1;
  atomic_fetch_add_explicit(&gIDRCount, 1uLL, memory_order_relaxed);
  *(void *)(result + 24) = a1;
  *((void *)a1 + 1) = result;
  return result;
}

uint64_t CGImageWriteSessionCreateWith_wSession(IIOImageWriteSession *a1)
{
  if (CGImageWriteSessionGetTypeID::once != -1) {
    dispatch_once(&CGImageWriteSessionGetTypeID::once, &__block_literal_global_8);
  }
  uint64_t result = _CFRuntimeCreateInstance();
  *(_DWORD *)(result + 16) = 1;
  atomic_fetch_add_explicit(&gWriteSessionCount, 1uLL, memory_order_relaxed);
  *(void *)(result + 24) = a1;
  return result;
}

uint64_t CGImageWriteSessionCreateWithMutableData(uint64_t a1)
{
  if (a1) {
    operator new();
  }
  return 0;
}

void sub_1885F2090(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10E1C408329B462);
  _Unwind_Resume(a1);
}

void IIOImageWriteSession::IIOImageWriteSession(IIOImageWriteSession *this, CFTypeRef cf)
{
  *(void *)this = &unk_1ED4E4FD8;
  *(_OWORD *)((char *)this + 8) = 0u;
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 40) = 0u;
  *(_OWORD *)((char *)this + 56) = 0u;
  *((_WORD *)this + 36) = 2;
  *((void *)this + 10) = this;
  *((void *)this + 11) = this;
  *((_DWORD *)this + 19) = 0;
  *((void *)this + 3) = CFRetain(cf);
  CFIndex Length = CFDataGetLength((CFDataRef)cf);
  *((void *)this + 7) = Length;
  if (Length)
  {
    CFDataSetLength(*((CFMutableDataRef *)this + 3), 0);
    *((void *)this + 7) = 0;
  }
}

{
  *(void *)this = &unk_1ED4E4FD8;
  *(_OWORD *)((char *)this + 8) = 0u;
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 40) = 0u;
  *(_OWORD *)((char *)this + 56) = 0u;
  *((_WORD *)this + 36) = 3;
  *((void *)this + 10) = this;
  *((void *)this + 11) = this;
  *((_DWORD *)this + 19) = 0;
  *((void *)this + 2) = CFRetain(cf);
  *((void *)this + 3) = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
}

unint64_t ASTCReadPlugin::calculateKTXOffsetToRequestedImage(uint64_t a1, uint64_t a2, unint64_t a3)
{
  int v5 = *(unsigned __int16 *)(a1 + 318);
  unsigned int v10 = 0;
  unsigned int v6 = *(_DWORD *)(a2 + 48);
  if (v5)
  {
    if (v6) {
      int v7 = 1;
    }
    else {
      int v7 = *(_DWORD *)(a2 + 52);
    }
    do
    {
      IIOImageReadSession::seek(*(IIOImageReadSession **)(a1 + 24), a3, 0);
      IIOImageReadSession::getBytes(*(IIOImageReadSession **)(a1 + 24), &v10, 4uLL);
      a3 += v10 * v7 + 4;
      --v5;
    }
    while (v5);
  }
  IIOImageReadSession::seek(*(IIOImageReadSession **)(a1 + 24), a3, 0);
  IIOImageReadSession::getBytes(*(IIOImageReadSession **)(a1 + 24), &v10, 4uLL);
  int v8 = v10;
  if (v6) {
    int v8 = v10 / v6;
  }
  return a3 + (*(_DWORD *)(a1 + 208) * v8) + 4;
}

uint64_t AppleJPEGReadPlugin::copyImageBlockSetImp(uint64_t a1, const void *a2, const void *a3, __CFDictionary *a4, double a5, double a6, double a7, double a8, double a9, double a10)
{
  v136[4] = *MEMORY[0x1E4F143B8];
  memory_object_size_t v135 = 0;
  int v133 = 0;
  memory_object_size_t v134 = 0;
  uint64_t v132 = 0;
  long long v130 = 0u;
  long long v131 = 0u;
  long long v128 = 0u;
  long long v129 = 0u;
  long long v126 = 0u;
  long long v127 = 0u;
  long long v124 = 0u;
  long long v125 = 0u;
  long long v123 = 0u;
  uint64_t v121 = 0;
  memory_object_size_t v122 = 0;
  uint64_t v120 = 0;
  int v119 = 0;
  long long v117 = 0u;
  long long v118 = 0u;
  long long v115 = 0u;
  long long v116 = 0u;
  memset(v114, 0, sizeof(v114));
  IIODictionary::IIODictionary((IIODictionary *)v114, a4);
  AppleJPEGReadPlugin::appleJPEGDecodeSetup((void *)a1);
  unsigned int v113 = *(unsigned __int16 *)(a1 + 316);
  if (!a3)
  {
    LODWORD(v18) = *(_DWORD *)(a1 + 228);
    LODWORD(v19) = *(_DWORD *)(a1 + 232);
    double v21 = (double)v18;
    double v23 = (double)v19;
    if (*(void *)(a1 + 504)) {
      goto LABEL_3;
    }
LABEL_27:
    _cg_jpeg_mem_term("copyImageBlockSetImp", 2902, "*** applejpeg_decode_session is nil");
LABEL_28:
    int v32 = 0;
    goto LABEL_209;
  }
  CGImageProviderGetSize();
  double v21 = v20;
  double v23 = v22;
  if (!*(void *)(a1 + 504)) {
    goto LABEL_27;
  }
LABEL_3:
  if (!*(unsigned char *)(a1 + 679))
  {
    HIDWORD(v120) = AppleJPEGReadPlugin::appleJPEGDecodeOpen((AppleJPEGReadPlugin *)a1);
    HIDWORD(v120) = applejpeg_decode_get_image_info();
    if (HIDWORD(v120)) {
      goto LABEL_28;
    }
  }
  if ((gIIODebugFlags & 0x30000) != 0) {
    ImageIOLog("    %s:%d: Entering\n", "copyImageBlockSetImp", 2914);
  }
  IIOReadPlugin::debugCopyBlockSet((const char *)a1, a3, a5, a6, a7, a8, a9, a10);
  if (IIODictionary::containsKey((IIODictionary *)v114, @"kCGImageBlockPreHeating")) {
    *(unsigned char *)(a1 + 497) = IIODictionary::getBoolForKey((IIODictionary *)v114, @"kCGImageBlockPreHeating");
  }
  CFStringRef v24 = (const __CFString *)*MEMORY[0x1E4F1DD50];
  if (!IIODictionary::containsKey((IIODictionary *)v114, (const __CFString *)*MEMORY[0x1E4F1DD50])) {
    goto LABEL_21;
  }
  Uint64ForKedouble y = IIODictionary::getUint64ForKey((IIODictionary *)v114, v24);
  if ((unint64_t)Uint64ForKey - 1 >= 0xFF) {
    unint64_t v27 = (unint64_t)Uint64ForKey;
  }
  else {
    unint64_t v27 = 256;
  }
  uint64_t v28 = (long long *)(a1 + 284);
  if (v27 > *(unsigned int *)(a1 + 292) || v27 > *(unsigned int *)(a1 + 296))
  {
    LODWORD(v136[0]) = 0;
    long long v29 = *(_OWORD *)(a1 + 300);
    long long v117 = *v28;
    long long v118 = v29;
LABEL_16:
    if ((gIIODebugFlags & 0x30000) != 0) {
      ImageIOLog("    decoding single tile: {%g,%g,%g,%g} {%g,%g}\n", a5, a6, a7, a8, a9, a10);
    }
    uint64_t v30 = AppleJPEGReadPlugin::copyImageBlockSetSingleTile(a1, a2, a3, a5, a6, a7, a8, a9, a10, v26, v136);
    goto LABEL_19;
  }
  LODWORD(v136[0]) = 0;
  long long v51 = *(_OWORD *)(a1 + 300);
  long long v117 = *v28;
  long long v118 = v51;
  if (!v27) {
    goto LABEL_16;
  }
  if ((gIIODebugFlags & 0x30000) != 0) {
    ImageIOLog("    decoding multi tiles [%d]: {%g,%g,%g,%g} {%g,%g}\n", v27, a5, a6, a7, a8, a9, a10);
  }
  uint64_t v30 = AppleJPEGReadPlugin::copyImageBlockSetTiles(a1, a2, a3, v27, v136, a5, a6, a7, a8, a9, a10);
LABEL_19:
  uint64_t ImageBlockSetWithHardwareDecode = v30;
  int v32 = 0;
  long long v33 = v118;
  long long *v28 = v117;
  *(_OWORD *)(a1 + 300) = v33;
  if (!v30)
  {
    BOOL v34 = 0;
    if (LODWORD(v136[0]) == 1) {
      goto LABEL_202;
    }
LABEL_21:
    int v35 = *(unsigned __int16 *)(a1 + 308);
    if (*(unsigned char *)(a1 + 348))
    {
      if ((gIIODebugFlags & 0x30000) != 0) {
        ImageIOLog("RB  multi-res: original subsampleFactor: %d\n", v113);
      }
      long long v36 = *(_OWORD *)(a1 + 300);
      long long v115 = *(_OWORD *)(a1 + 284);
      long long v116 = v36;
      if (v113 < 2)
      {
        unsigned int v37 = v21;
        unsigned int v38 = v23;
      }
      else
      {
        unsigned int v37 = *(_DWORD *)(a1 + 600);
        unsigned int v38 = *(_DWORD *)(a1 + 604);
      }
      unsigned int v39 = v37 >> 3;
      double v40 = (double)(v37 >> 3);
      double v41 = (double)(v38 >> 3);
      if (a9 > v40 || a10 > v41)
      {
        unsigned int v43 = v37 >> 2;
        double v40 = (double)(v37 >> 2);
        double v41 = (double)(v38 >> 2);
        if (a9 > v40 || a10 > v41)
        {
          unsigned int v45 = v37 >> 1;
          double v40 = (double)v45;
          unsigned int v46 = v38 >> 1;
          double v41 = (double)v46;
          BOOL v48 = a9 > (double)v45 || a10 > v41 || v113 == 2;
          if (!v48)
          {
            *(_WORD *)(a1 + 316) = 2;
            *(_DWORD *)(a1 + 292) = v45;
            *(_DWORD *)(a1 + 296) = v46;
            unint64_t v49 = v45 * (unint64_t)((*(unsigned __int16 *)(a1 + 240) + 7) >> 3 << (2 * (v35 != 1)));
            BOOL v48 = (v49 & 0xFFFFFFFF00000000) == 0;
            int v50 = (v49 + 15) & 0xFFFFFFF0;
            if (!v48) {
              int v50 = 0;
            }
            *(_DWORD *)(a1 + 300) = v50;
            if ((gIIODebugFlags & 0x30000) != 0) {
              ImageIOLog("RB  multi-res: new subsampleFactor 2:  rb=%d\n", v50);
            }
            goto LABEL_72;
          }
        }
        else if (v113 != 4)
        {
          *(_WORD *)(a1 + 316) = 4;
          *(_DWORD *)(a1 + 292) = v43;
          *(_DWORD *)(a1 + 296) = v38 >> 2;
          unint64_t v61 = v43 * (unint64_t)((*(unsigned __int16 *)(a1 + 240) + 7) >> 3 << (2 * (v35 != 1)));
          BOOL v48 = (v61 & 0xFFFFFFFF00000000) == 0;
          int v62 = (v61 + 15) & 0xFFFFFFF0;
          if (!v48) {
            int v62 = 0;
          }
          *(_DWORD *)(a1 + 300) = v62;
          if ((gIIODebugFlags & 0x30000) != 0) {
            ImageIOLog("RB  multi-res: new subsampleFactor 4:  rb=%d\n", v62);
          }
          goto LABEL_72;
        }
      }
      else if (v113 != 8)
      {
        *(_WORD *)(a1 + 316) = 8;
        *(_DWORD *)(a1 + 292) = v39;
        *(_DWORD *)(a1 + 296) = v38 >> 3;
        unint64_t v52 = v39 * (unint64_t)((*(unsigned __int16 *)(a1 + 240) + 7) >> 3 << (2 * (v35 != 1)));
        BOOL v48 = (v52 & 0xFFFFFFFF00000000) == 0;
        int v53 = (v52 + 15) & 0xFFFFFFF0;
        if (!v48) {
          int v53 = 0;
        }
        *(_DWORD *)(a1 + 300) = v53;
        if ((gIIODebugFlags & 0x30000) != 0) {
          ImageIOLog("RB  multi-res: new subsampleFactor 8:  rb=%d\n", v53);
        }
LABEL_72:
        int v55 = *(_DWORD *)(a1 + 300);
        int v32 = 1;
        double v23 = v41;
        double v60 = v40;
LABEL_73:
        if (!*(unsigned char *)(a1 + 341))
        {
          *(unsigned char *)(a1 + 496) = 0;
          if ((gIIODebugFlags & 0x1000000000) != 0) {
            ImageIOLog("H   Skipping HW decode - image is not final\n");
          }
        }
        if (*(_DWORD *)(a1 + 608) == 1)
        {
          *(unsigned char *)(a1 + 496) = 0;
          if ((gIIODebugFlags & 0x1000000000) != 0) {
            ImageIOLog("H   Skipping HW decode - APPLEJPEG_JPEG_PROGRESSIVE\n");
          }
        }
        if (a10 < v23) {
          int v63 = 1;
        }
        else {
          int v63 = v32;
        }
        if (v63) {
          a8 = v23;
        }
        int v64 = *(unsigned __int8 *)(a1 + 408);
        CGImageProviderGetPixelSize();
        if (ImageIOShouldAllowFullsizeDecode())
        {
          if (v64 == 1)
          {
            long long v110 = (int *)(a1 + 372);
            *(void *)(a1 + 368) = 0;
            goto LABEL_95;
          }
          if (!*(unsigned char *)(a1 + 341))
          {
            int v75 = *(_DWORD *)(a1 + 608);
            long long v110 = (int *)(a1 + 372);
            *(void *)(a1 + 368) = 0;
            if (v75 == 1) {
              goto LABEL_95;
            }
            goto LABEL_93;
          }
LABEL_92:
          long long v110 = (int *)(a1 + 372);
          *(void *)(a1 + 368) = 0;
LABEL_93:
          if (!*(unsigned char *)(a1 + 496))
          {
            v137.origin.double x = a5;
            v137.origin.double y = a6;
            v137.size.double width = v60;
            v137.size.double height = a8;
            IIOReadPlugin::optInForBandedDecoding((IIOReadPlugin *)a1, v137);
          }
LABEL_95:
          uint64_t v66 = *(unsigned int *)(a1 + 112);
          *(_DWORD *)(a1 + 284) = 0;
          *(_DWORD *)(a1 + 288) = *(_DWORD *)(a1 + 296) * v66;
          HIDWORD(v120) = IIOReadPlugin::allocateBlockArray((IIOReadPlugin *)a1, *(unsigned int *)(a1 + 104));
          if (!HIDWORD(v120))
          {
            if (!IIOReadPlugin::getCachedBlocks((IIOReadPlugin *)a1, v67, v68, v69))
            {
              BOOL v34 = 0;
              unsigned int v71 = 0;
LABEL_191:
              if (*(unsigned char *)(a1 + 341)) {
                AppleJPEGReadPlugin::save_index_table((AppleJPEGReadPlugin *)a1);
              }
              if (!v71)
              {
                uint64_t v102 = *(void *)(a1 + 16);
                if (v102) {
                  IIOImagePlus::setStatus(v102, kCGImageStatusComplete);
                }
              }
              uint64_t ImageBlockSetWithHardwareDecode = 0;
              if (!a3) {
                goto LABEL_202;
              }
              unint64_t v103 = *(unsigned int *)(a1 + 104);
              if (!v103) {
                goto LABEL_202;
              }
              uint64_t ImageBlockSetWithHardwareDecode = IIOReadPlugin::imageBlockSetCreate(a1, (uint64_t)a3, v103, v60, v23, *(double *)(a1 + 120), *(double *)(a1 + 128), *(double *)(a1 + 136), *(double *)(a1 + 144), *(void *)(a1 + 96), a2);
LABEL_203:
              IIOReadPlugin::freeBlockArray((IIOReadPlugin *)a1);
              goto LABEL_204;
            }
            int v70 = *(IIOImageRead ***)(a1 + 24);
            if (v70) {
              BOOL v112 = IIOImageReadSession::mapData(v70);
            }
            else {
              BOOL v112 = 0;
            }
            if (*(unsigned char *)(a1 + 673) && *(unsigned char *)(a1 + 674) != 1) {
              *(unsigned char *)(a1 + 496) = 0;
            }
            if ((gIIODebugFlags & 0x1000000000) != 0)
            {
              if (*(unsigned char *)(a1 + 496)) {
                unint64_t v72 = "YES";
              }
              else {
                unint64_t v72 = "NO";
              }
              ImageIOLog("H   %s: image size: {%d, %d}  block size: {%d, %d}   rb: %d    subsample: %d    useHW: %s\n", "copyImageBlockSetImp", *(_DWORD *)(a1 + 228), *(_DWORD *)(a1 + 232), *(_DWORD *)(a1 + 292), *(_DWORD *)(a1 + 296), *(_DWORD *)(a1 + 300), *(unsigned __int16 *)(a1 + 316), v72);
            }
            if (!*(unsigned char *)(a1 + 496))
            {
LABEL_127:
              unint64_t v76 = *(unsigned int *)(a1 + 112);
              if (v76 < *(_DWORD *)(a1 + 116))
              {
                unsigned int v71 = 0;
                uint64_t v108 = -8 * v66;
                int v77 = (CGRect *)MEMORY[0x1E4F1DB20];
                while (1)
                {
                  int v78 = *v110;
                  if (*v110) {
                    *(_DWORD *)(a1 + 296) = v78;
                  }
                  else {
                    int v78 = *(_DWORD *)(a1 + 296);
                  }
                  *(_DWORD *)(a1 + 288) = v78 * v76;
                  applejpeg_decode_clear_options();
                  int v79 = applejpeg_decode_set_option_outformat();
                  HIDWORD(v120) = v79;
                  if (v79) {
                    _cg_jpeg_mem_term("copyImageBlockSetImp", 3163, "    applejpeg_decode_set_option_outformat: err = %d\n", v79);
                  }
                  int v80 = applejpeg_decode_set_option_outsize();
                  HIDWORD(v120) = v80;
                  if (v80) {
                    _cg_jpeg_mem_term("copyImageBlockSetImp", 3176, "    applejpeg_decode_set_option_outsize err = %d\n", v80);
                  }
                  v136[0] = *(unsigned int *)(a1 + 300);
                  v136[1] = v136[0];
                  v136[2] = v136[0];
                  v136[3] = v136[0];
                  int v81 = applejpeg_decode_set_option_stride();
                  HIDWORD(v120) = v81;
                  if (v81) {
                    __n128 v82 = _cg_jpeg_mem_term("copyImageBlockSetImp", 3184, "    applejpeg_decode_set_option_stride err = %d\n", v81);
                  }
                  v82.n128_u32[0] = *(_DWORD *)(a1 + 284);
                  double x = (double)v82.n128_u64[0];
                  v82.n128_u32[0] = *(_DWORD *)(a1 + 288);
                  double y = (double)v82.n128_u64[0];
                  v82.n128_u32[0] = *(_DWORD *)(a1 + 292);
                  double width = (double)v82.n128_u64[0];
                  unsigned int v86 = *(_DWORD *)(a1 + 296);
                  double height = y + (double)v86 <= v23 ? (double)v86 : v23 - y;
                  if (*(_DWORD *)(a1 + 104) <= 1u && v86 == *(_DWORD *)(a1 + 264))
                  {
                    if (*(unsigned __int16 *)(a1 + 316) <= 1u)
                    {
                      int v88 = applejpeg_decode_set_option_outsize();
                      HIDWORD(v120) = v88;
                      if (v88) {
                        _cg_jpeg_mem_term("copyImageBlockSetImp", 3220, "    applejpeg_decode_set_option_outsize err = %d\n", v88);
                      }
                    }
                  }
                  else
                  {
                    int v89 = applejpeg_decode_set_option_crop();
                    HIDWORD(v120) = v89;
                    if (v89) {
                      _cg_jpeg_mem_term("copyImageBlockSetImp", 3211, "    applejpeg_decode_set_option_crop err = %d\n", v89);
                    }
                  }
                  if (*(unsigned char *)(a1 + 341)) {
                    AppleJPEGReadPlugin::create_or_restoreIndexTable(a1);
                  }
                  if (*(char *)(a1 + 677) != -1) {
                    applejpeg_decode_set_option_force_app14();
                  }
                  applejpeg_decode_set_option_error_fill();
                  int v90 = applejpeg_decode_set_option_mosquito_spray();
                  HIDWORD(v120) = v90;
                  if (v90) {
                    _cg_jpeg_mem_term("copyImageBlockSetImp", 3265, "    applejpeg_decode_set_option_mosquito_spray err = %d\n", v90);
                  }
                  int v91 = applejpeg_decode_set_option_multithread();
                  HIDWORD(v120) = v91;
                  if (v91) {
                    _cg_jpeg_mem_term("copyImageBlockSetImp", 3272, "    applejpeg_decode_set_option_multithread err = %d\n", v91);
                  }
                  output_dimensions = (AppleJPEGReadPlugin *)applejpeg_decode_get_output_dimensions();
                  int v93 = (int)output_dimensions;
                  HIDWORD(v120) = output_dimensions;
                  if (output_dimensions) {
                    break;
                  }
                  applejpeg_decode_get_output_buffer_size();
                  uint64_t v94 = *(unsigned int *)(a1 + 300);
                  if (v121 != v94)
                  {
                    _cg_jpeg_mem_term("copyImageBlockSetImp", 3290, "*** ERROR: get_output_buffer_size rb=%d  blockGeo.rb=%d\n", v121, v94);
                    uint64_t v94 = *(unsigned int *)(a1 + 300);
                  }
                  memory_object_size_t v95 = v122;
                  memory_object_size_t v96 = v94 * v119;
                  if (v122 < v96)
                  {
                    memory_object_size_t v122 = v96;
                    memory_object_size_t v95 = v96;
                  }
                  if ((gIIODebugFlags & 0x30000) != 0)
                  {
                    ImageIOLog("    %s:%d: applejpeg_decode_get_output_buffer_size:%ld rowB:%ld size:%ldx%ld\n", "copyImageBlockSetImp", 3295, v95, v121, (int)v120, v119);
                    memory_object_size_t v95 = v122;
                  }
                  uint64_t v97 = (void *)_ImageIO_Malloc(v95, *(void *)(a1 + 384), &v135, (uint64_t)kImageMalloc_APPLEJPEG_Data[0], *(_DWORD *)(a1 + 432), 0, 0);
                  if (!v97) {
                    goto LABEL_201;
                  }
                  if ((gIIODebugFlags & 0x30000) != 0) {
                    ImageIOLog("    %s:%d: Got outbuf\n", "copyImageBlockSetImp", 3308);
                  }
                  int v133 = v97;
                  memory_object_size_t v134 = v122;
                  int v98 = applejpeg_decode_image_all();
                  HIDWORD(v120) = v98;
                  if (v98)
                  {
                    if ((gIIODebugFlags & 0x30000) != 0)
                    {
                      ImageIOLog("    %s:%d: Decode error %d\n", "copyImageBlockSetImp", 3315, v98);
                      int v98 = HIDWORD(v120);
                    }
                    if (v98 == -2)
                    {
                      *(unsigned char *)(a1 + 343) = 0;
                      unsigned int v71 = 5;
                    }
                    else
                    {
                      if (v98 != 9 && v98 != -1) {
                        goto LABEL_201;
                      }
                      ++v71;
                      *(unsigned char *)(a1 + 343) = 0;
                      uint64_t v99 = *(void *)(a1 + 16);
                      if (v99) {
                        IIOImagePlus::setStatus(v99, (CGImageSourceStatus)-6);
                      }
                    }
                  }
                  if (!*(unsigned char *)(a1 + 341) && v71)
                  {
                    *(unsigned char *)(a1 + 343) = 0;
                    uint64_t v100 = *(void *)(a1 + 16);
                    if (v100) {
                      IIOImagePlus::setStatus(v100, (CGImageSourceStatus)-6);
                    }
                    unsigned int v71 = 5;
                  }
                  if ((gIIODebugFlags & 0x30000) != 0) {
                    ImageIOLog("    %s:%d: Decoded image\n", "copyImageBlockSetImp", 3344);
                  }
                  if (appleJPEGTintCheck != -1) {
                    dispatch_once(&appleJPEGTintCheck, &__block_literal_global_33);
                  }
                  v138.origin.double x = x;
                  v138.origin.double y = y;
                  v138.size.double width = width;
                  v138.size.double height = height;
                  *(void *)(*(void *)(a1 + 96) + v108 + 8 * v76) = IIOReadPlugin::createImageBlock((IIOReadPlugin *)a1, v97, v135, v138, *(unsigned int *)(a1 + 300), *(unsigned __int8 *)(a1 + 343));
                  if (!CGRectEqualToRect(*(CGRect *)(a1 + 120), *v77))
                  {
                    v140.origin.double x = x;
                    v140.origin.double y = y;
                    v140.size.double width = width;
                    v140.size.double height = height;
                    CGRect v139 = CGRectUnion(*(CGRect *)(a1 + 120), v140);
                    double x = v139.origin.x;
                    double y = v139.origin.y;
                    double width = v139.size.width;
                    double height = v139.size.height;
                  }
                  *(double *)(a1 + 120) = x;
                  *(double *)(a1 + 128) = y;
                  *(double *)(a1 + 136) = width;
                  *(double *)(a1 + 144) = height;
                  ++v76;
                  BOOL v101 = v112;
                  if (v76 >= *(unsigned int *)(a1 + 116) || v71 >= 5) {
                    goto LABEL_190;
                  }
                }
                CFStringRef v104 = AppleJPEGReadPlugin::appleJPEGErrorString(output_dimensions, (int)output_dimensions);
                _cg_jpeg_mem_term("copyImageBlockSetImp", 3280, "*** ERROR: applejpeg_decode_get_output_dimensions - error %d (%s)\n", v93, v104);
                if ((gIIODebugFlags & 0x30000) != 0) {
                  ImageIOLog("    %s:%d: Options error %d\n", "copyImageBlockSetImp", 3281, HIDWORD(v120));
                }
LABEL_201:
                uint64_t ImageBlockSetWithHardwareDecode = 0;
                BOOL v34 = v112;
LABEL_202:
                if (!a3) {
                  goto LABEL_204;
                }
                goto LABEL_203;
              }
              unsigned int v71 = 0;
              BOOL v101 = v112;
LABEL_190:
              BOOL v34 = v101;
              goto LABEL_191;
            }
            uint64_t ImageBlockSetWithHardwareDecode = AppleJPEGReadPlugin::createImageBlockSetWithHardwareDecode((unsigned __int8 *)a1, a2, (uint64_t)a3, a4, (int *)&v120 + 1);
            BOOL v34 = v112;
            if (ImageBlockSetWithHardwareDecode) {
              goto LABEL_202;
            }
            size_t v73 = *(unsigned int *)(a1 + 104);
            uint64_t v74 = *(void *)(a1 + 96);
            if (v73)
            {
              if (!a3 && v74 && !HIDWORD(v120))
              {
                uint64_t ImageBlockSetWithHardwareDecode = 0;
                if ((v32 & 1) == 0) {
                  goto LABEL_116;
                }
LABEL_205:
                long long v105 = v116;
                *(_OWORD *)(a1 + 284) = v115;
                *(_OWORD *)(a1 + 300) = v105;
                *(_WORD *)(a1 + 316) = v113;
                if (!v34) {
                  goto LABEL_208;
                }
                goto LABEL_206;
              }
              if (v74) {
                goto LABEL_124;
              }
            }
            else
            {
              if (v74)
              {
LABEL_124:
                if ((gIIODebugFlags & 0x1000000000) != 0) {
                  ImageIOLog("H   Hardware blockset is NULL, falling back to software decode.  (RB: %d\n", v55);
                }
                *(unsigned char *)(a1 + 680) = 1;
                *(unsigned char *)(a1 + 496) = 0;
                goto LABEL_127;
              }
              size_t v73 = 1;
              *(_DWORD *)(a1 + 104) = 1;
            }
            HIDWORD(v120) = IIOReadPlugin::allocateBlockArray((IIOReadPlugin *)a1, v73);
            goto LABEL_124;
          }
          goto LABEL_209;
        }
        *(unsigned char *)(a1 + 496) = 0;
        if ((gIIODebugFlags & 0x1000000000) != 0)
        {
          PixelCFIndex Size = CGImageProviderGetPixelSize();
          ImageIOLog("H   Disabling hardware decode, image is too large (%g MB).\n", v60 * v23 * (double)(unint64_t)PixelSize * 0.000000953674316);
        }
        if (v64 != 1) {
          goto LABEL_92;
        }
        _cg_jpeg_mem_term("copyImageBlockSetImp", 3058, "Rejecting singleton request - image is too large\n");
LABEL_209:
        BOOL v34 = 0;
        uint64_t ImageBlockSetWithHardwareDecode = 0;
        if (a3) {
          goto LABEL_203;
        }
        goto LABEL_204;
      }
    }
    BOOL v54 = v35 != 1;
    int v55 = *(_DWORD *)(a1 + 300);
    unsigned int v56 = (*(unsigned __int16 *)(a1 + 240) + 7) >> 3 << (2 * v54);
    unsigned int v57 = *(_DWORD *)(a1 + 292);
    unint64_t v58 = v57 * (unint64_t)v56;
    BOOL v48 = (v58 & 0xFFFFFFFF00000000) == 0;
    int v59 = (v58 + 15) & 0xFFFFFFF0;
    if (!v48) {
      int v59 = 0;
    }
    if (v55 != v59) {
      LogFault("copyImageBlockSetImp", 3028, " IIO-ERROR: img: {%d x %d}  blockGeoRB: %d   tempRB: %d   unadjRB: %d   subSample: %d\n", v57, *(_DWORD *)(a1 + 296), v55, v59, *(_DWORD *)(a1 + 300), *(unsigned __int16 *)(a1 + 316));
    }
    int v32 = 0;
    double v60 = v21;
    goto LABEL_73;
  }
  BOOL v34 = 0;
  if (a3) {
    goto LABEL_203;
  }
LABEL_204:
  if (v32) {
    goto LABEL_205;
  }
LABEL_116:
  *(_WORD *)(a1 + 316) = v113;
  if (!v34) {
    goto LABEL_208;
  }
LABEL_206:
  long long v106 = *(const char ***)(a1 + 24);
  if (v106) {
    IIOImageReadSession::unmapData(v106);
  }
LABEL_208:
  IIODictionary::~IIODictionary((IIODictionary *)v114);
  return ImageBlockSetWithHardwareDecode;
}

void sub_1885F311C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, ...)
{
  va_start(va, a14);
  IIODictionary::~IIODictionary((IIODictionary *)va);
  _Unwind_Resume(a1);
}

uint64_t ImageIOShouldAllowFullsizeDecode()
{
  return 1;
}

uint64_t IIOReadPlugin::freeBlockArray(IIOReadPlugin *this)
{
  CFMutableArrayRef v2 = (void *)*((void *)this + 12);
  if (v2) {
    free(v2);
  }
  *((void *)this + 12) = 0;
  *((_DWORD *)this + 26) = 0;
  return 0;
}

uint64_t AppleJPEGReadPlugin::initialize(AppleJPEGReadPlugin *this, IIODictionary *a2)
{
  v122[2] = *MEMORY[0x1E4F143B8];
  CFDictionaryRef v113 = (const __CFDictionary *)*((void *)this + 8);
  unint64_t v121 = 0;
  unsigned int v120 = 1380401696;
  char v119 = 0;
  int v4 = IIO_HardwareDecoderDefaultValue();
  int v5 = (IIODictionary *)*((void *)this + 6);
  long long v114 = (IIODictionary *)*((void *)this + 7);
  *((_WORD *)this + 336) = 255;
  if (!a2)
  {
    _cg_jpeg_mem_term("initialize", 1400, "*** ERROR: initialize called with NULL initOptions\n");
LABEL_342:
    uint64_t image_info = 4294967246;
    goto LABEL_55;
  }
  int v6 = v4;
  if (IIODictionary::containsKey(a2, @"NEW_PLUGIN_dataOffset")) {
    *((void *)this + 57) = IIODictionary::getUint32ForKey(a2, @"NEW_PLUGIN_dataOffset");
  }
  int v110 = v6;
  if (IIODictionary::containsKey(a2, @"NEW_PLUGIN_dataSize")) {
    *((void *)this + 58) = IIODictionary::getUint32ForKey(a2, @"NEW_PLUGIN_dataSize");
  }
  int v7 = IIOSkipMetadata(v5);
  int v8 = IIOSkipXMP_and_IPTC(v5);
  if (IIODictionary::containsKey(v5, @"kCGImageSourceXMPSidecar")) {
    theunint64_t Data = IIODictionary::getObjectForKey(v5, @"kCGImageSourceXMPSidecar");
  }
  else {
    theunint64_t Data = 0;
  }
  unsigned int v9 = IIODictionary::containsKey(v5, @"kCGImageSourceDecodeRequest");
  if (*((unsigned __int8 *)this + 216) < 2u) {
    char v10 = 1;
  }
  else {
    char v10 = v7;
  }
  if ((v10 & 1) == 0)
  {
    if ((gIIODebugFlags & 0x4000000000000) != 0 && IIO_OSAppleInternalBuild()) {
      ImageIOLog("   skipping metadata for thumbnail creation\n");
    }
    int v7 = 1;
  }
  unsigned int Uint32ForKey = IIODictionary::getUint32ForKey(v5, @"kCGImageSourceSubsampleFactor");
  unsigned int v115 = IIODictionary::containsKey(v5, @"kCGImageSourceColorTransform");
  if (v115)
  {
    unsigned int v11 = IIODictionary::getUint32ForKey(v5, @"kCGImageSourceColorTransform");
    uint64_t v108 = v11;
    if ((gIIODebugFlags & 0x8000300000) != 0) {
      ImageIOLog("COL      pdfColorTransform: %d\n", v11);
    }
  }
  else
  {
    uint64_t v108 = -1;
  }
  if (IIODictionary::containsKey(v5, @"kCGImageSourceColorTransformSpace")
    && (CFDictionaryRef ObjectForKey = IIODictionary::getObjectForKey(v5, @"kCGImageSourceColorTransformSpace")) != 0)
  {
    uint64_t v13 = ObjectForKey;
    size_t NumberOfComponents = CGColorSpaceGetNumberOfComponents(ObjectForKey);
    if ((gIIODebugFlags & 0x8000300000) != 0)
    {
      CFStringRef Name = CGColorSpaceGetName(v13);
      IIOString::IIOString((IIOString *)&v116, Name);
      unint64_t v15 = (const char *)IIOString::utf8String((IIOString *)&v116);
      ImageIOLog("COL pdfColorTransformSpace: %s\n", v15);
      IIOString::~IIOString((IIOString *)&v116);
    }
    int v111 = 1;
  }
  else
  {
    int v111 = 0;
    size_t NumberOfComponents = 0;
  }
  if ((gIIODebugFlags & 0x30000) != 0) {
    ImageIOLog("    %s:%d: Entering\n", "initialize", 1440);
  }
  if (IIODictionary::getBoolForKey(v5, @"IMAGEIO_USE_LIBJPEG"))
  {
    _cg_jpeg_mem_term("initialize", 1446, "*** IMAGEIO_USE_LIBJPEG --> switching to libJPEG\n");
    IIONumber::IIONumber((IIONumber *)&v116, 1279938631);
    IIODictionary::setObjectForKey(a2, value, @"NEW_PLUGIN_ostype");
    IIONumber::~IIONumber((IIONumber *)&v116);
    IIONumber::IIONumber((IIONumber *)&v116, *((void *)this + 24));
    IIODictionary::setObjectForKey(a2, value, @"NEW_PLUGIN_dataOffset");
    IIONumber::~IIONumber((IIONumber *)&v116);
    kdebug_trace();
LABEL_54:
    uint64_t image_info = 4294967247;
    goto LABEL_55;
  }
  if ((gIIODebugFlags & 0x30000) != 0) {
    ImageIOLog("    %s:%d: Got session\n", "initialize", 1457);
  }
  if (IIOImageReadSession::seek(*((IIOImageReadSession **)this + 3), *((void *)this + 24), 0) != *((void *)this + 24)) {
    goto LABEL_342;
  }
  if (IIODictionary::containsKey(v5, @"kCGImageSourcePreferredThreadCount"))
  {
    unsigned int v16 = IIODictionary::getUint32ForKey(v5, @"kCGImageSourcePreferredThreadCount");
    int v17 = v16;
    if ((gIIODebugFlags & 0x30000) != 0) {
      ImageIOLog("    %s:%d: Got preferred theadCount == %d\n", "initialize", 1465, v16);
    }
  }
  else
  {
    int v17 = 1;
  }
  if (IIODictionary::containsKey(v5, @"kCGImageSourceEnableMosquitoNoiseFiltering")) {
    *((unsigned char *)this + 672) = IIODictionary::getBoolForKey(v5, @"kCGImageSourceEnableMosquitoNoiseFiltering");
  }
  *((unsigned char *)this + 675) = v17;
  AppleJPEGReadPlugin::appleJPEGDecodeSetup(this);
  if (!*((void *)this + 63))
  {
    _cg_jpeg_mem_term("initialize", 1477, "*** applejpeg_decode_session is nil");
    goto LABEL_342;
  }
  if ((gIIODebugFlags & 0x30000) != 0)
  {
    ImageIOLog("    %s:%d: Got ajd_session\n", "initialize", 1479);
    if ((gIIODebugFlags & 0x30000) != 0)
    {
      unint64_t v18 = "";
      if (!*((unsigned char *)this + 341)) {
        unint64_t v18 = "not ";
      }
      ImageIOLog("    %s:%d: Session is %sfinal/numThreads=%d\n", "initialize", 1480, v18, v17);
    }
  }
  if (*((unsigned char *)this + 679)
    || (IIOImageReadSession::seek(*((IIOImageReadSession **)this + 3), *((void *)this + 57), 0),
        CFStringRef v24 = AppleJPEGReadPlugin::appleJPEGDecodeOpen(this),
        uint64_t image_info = (uint64_t)v24,
        !v24))
  {
    if ((gIIODebugFlags & 0x30000) != 0) {
      ImageIOLog("    %s:%d: Opened file\n", "initialize", 1514);
    }
    unint64_t v19 = (int *)((char *)this + 592);
    uint64_t image_info = applejpeg_decode_get_image_info();
    if (image_info) {
      goto LABEL_55;
    }
    if ((gIIODebugFlags & 0x30000) != 0) {
      ImageIOLog("    %s:%d: Got imageinfo {%d,%d}\n", "initialize", 1519, *((_DWORD *)this + 150), *((_DWORD *)this + 151));
    }
    int precision = applejpeg_decode_get_precision();
    if (precision == 12)
    {
      _cg_jpeg_mem_term("initialize", 1524, "*** 12-bit JPEG --> switching to HEIC decoder\n");
      IIONumber::IIONumber((IIONumber *)&v116, 1212500291);
      IIODictionary::setObjectForKey(a2, value, @"NEW_PLUGIN_ostype");
      IIONumber::~IIONumber((IIONumber *)&v116);
      IIONumber::IIONumber((IIONumber *)&v116, *((void *)this + 24));
      IIODictionary::setObjectForKey(a2, value, @"NEW_PLUGIN_dataOffset");
      IIONumber::~IIONumber((IIONumber *)&v116);
      IIONumber::IIONumber((IIONumber *)&v116, *((void *)this + 23));
      IIODictionary::setObjectForKey(a2, value, @"NEW_PLUGIN_dataSize");
      IIONumber::~IIONumber((IIONumber *)&v116);
      kdebug_trace();
      goto LABEL_54;
    }
    if (*((_DWORD *)this + 153) == 1
      && ((IIODictionary::getBoolForKey(a2, @"OriginalPluginWasMPO") | v9 ^ 1) & 1) == 0)
    {
      CFAbsoluteTime v25 = (IIOImagePlus *)*((void *)this + 2);
      if (v25
        && (uint64_t v26 = IIOImagePlus::isr(v25), (Source = (IIOImageSource *)CGImageSourceGetSource(v26)) != 0)
        && IIOImageSource::ignoreJPEGAuxImagesRequest(Source) == 1)
      {
        LogError("initialize", 1561, "*** NOTE: dropping 'kCGImageSourceDecodeRequest' since 'kCGImageSourceIgnoreJPEGAuxImages' was requested\n");
      }
      else if (AppleJPEGReadPlugin::containsGainMap(this))
      {
        _cg_jpeg_mem_term("initialize", 1550, "*** kCGImageSourceDecodeRequest --> switching to HEIFPlugin\n");
        IIONumber::IIONumber((IIONumber *)&v116, 1212500291);
        IIODictionary::setObjectForKey(a2, value, @"NEW_PLUGIN_ostype");
        IIONumber::~IIONumber((IIONumber *)&v116);
        IIONumber::IIONumber((IIONumber *)&v116, *((void *)this + 24));
        IIODictionary::setObjectForKey(a2, value, @"NEW_PLUGIN_dataOffset");
        IIONumber::~IIONumber((IIONumber *)&v116);
        IIONumber::IIONumber((IIONumber *)&v116, *((void *)this + 23));
        IIODictionary::setObjectForKey(a2, value, @"NEW_PLUGIN_dataSize");
        IIONumber::~IIONumber((IIONumber *)&v116);
        kdebug_trace();
        goto LABEL_54;
      }
    }
    if (v115)
    {
      uint64_t v116 = 0;
      uint64_t v117 = 0;
      if (*v19 >= 1)
      {
        int v31 = 0;
        while (1)
        {
          applejpeg_decode_get_segment_info();
          if (v116 == 238) {
            break;
          }
          if (++v31 >= *v19) {
            goto LABEL_92;
          }
        }
        *((unsigned char *)this + 673) = 1;
        if (HIDWORD(v116) == 14)
        {
          *(void *)((char *)v122 + 6) = 0;
          v122[0] = 0;
          IIOImageReadSession::getBytesAtOffset(*((IIOImageReadSession **)this + 3), v122, v117 + 2, 0xEuLL);
          BOOL v32 = *(_DWORD *)((char *)v122 + 2) == 1651467329 && BYTE6(v122[0]) == 101;
          if (v32) {
            *((unsigned char *)this + 674) = BYTE5(v122[1]);
          }
        }
      }
LABEL_92:
      if ((gIIODebugFlags & 0x8000300000) != 0)
      {
        if (*((unsigned char *)this + 673)) {
          long long v33 = "true";
        }
        else {
          long long v33 = "false";
        }
        ImageIOLog("COL         hasApp14Marker: %s\n", v33);
      }
    }
    if ((gIIODebugFlags & 0x30000) != 0) {
      ImageIOLog("    %s:%d: handling metadata\n", "initialize", 1591);
    }
    BOOL BoolForKey = IIODictionary::getBoolForKey(*((IIODictionary **)this + 7), @"kCGImageSourceAddMetadataFromPrimaryImage");
    BOOL v35 = BoolForKey;
    if (*((void *)this + 24)) {
      int v36 = BoolForKey;
    }
    else {
      int v36 = 1;
    }
    if (v36 != 1)
    {
LABEL_116:
      if (*((_DWORD *)this + 152) == 1) {
        IIODictionary::setObjectForKeyGroup(v114, (const void *)*MEMORY[0x1E4F1CFD0], @"IsProgressive", @"{JFIF}");
      }
      if (IIODictionary::getBoolForKey(v5, @"kCGImageSourceAddJPEGQualityInformation")) {
        AppleJPEGReadPlugin::readQualityPropertiesFromJPEG((uint64_t)this, *((void *)this + 63), v114);
      }
      else {
        *((unsigned char *)this + 676) = applejpeg_decode_get_chroma_subsampling();
      }
      if ((gIIODebugFlags & 0x30000) != 0) {
        ImageIOLog("    %s:%d: handling colorspace\n", "initialize", 1665);
      }
      double v40 = (UInt8 *)AppleJPEGReadPlugin::readICCData((IIOImageReadSession **)this, 0, *((void *)this + 24), &v121, &v120);
      if (v40 && (unint64_t v41 = v121) != 0)
      {
        if (IIODictionary::getBoolForKey(v5, @"kCGImageSourceKeepOriginalProfile")
          || (pthread_once(&gDisplayCheck, (void (*)(void))displayCheck), gIsWideGamutDisplay)
          || (CFDataRef v56 = CFDataCreateWithBytesNoCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v40, v41, (CFAllocatorRef)*MEMORY[0x1E4F1CFA0])) == 0|| (CanBeIgnoredOnSRGBDevice = ColorSyncDataCanBeIgnoredOnSRGBDevice(), CFRelease(v56), (CanBeIgnoredOnSRGBDevice & 1) == 0))
        {
          uint64_t v42 = (CGColorSpace *)CGColorSpaceCreateWithCopyOfData(v40, v41);
        }
        else
        {
          uint64_t v42 = 0;
        }
        free(v40);
        CFStringRef v43 = (const __CFString *)*((void *)this + 55);
        if (!v43) {
          goto LABEL_135;
        }
        long long v44 = (const void **)((char *)this + 440);
        if (v42)
        {
          CGColorSpaceRelease(v42);
          CFStringRef v43 = (const __CFString *)*v44;
        }
      }
      else
      {
        CFStringRef v43 = (const __CFString *)*((void *)this + 55);
        if (!v43)
        {
          uint64_t v42 = 0;
          goto LABEL_142;
        }
        long long v44 = (const void **)((char *)this + 440);
      }
      uint64_t v42 = CGColorSpaceCreateWithName(v43);
      if ((gIIODebugFlags & 0x8000300000) != 0)
      {
        IIOString::IIOString((IIOString *)&v116, *v44);
        unsigned int v45 = (const char *)IIOString::utf8String((IIOString *)&v116);
        ImageIOLog("COL using namedColorSpace '%s'\n", v45);
        IIOString::~IIOString((IIOString *)&v116);
      }
LABEL_135:
      if (v42)
      {
        CFStringRef v46 = CGColorSpaceGetName(v42);
        CFStringRef v47 = v46;
        if (v46 && (CFStringFind(v46, @"PQ", 1uLL).length || CFStringFind(v47, @"HLG", 1uLL).length))
        {
          IIONumber::IIONumber((IIONumber *)&v116, 1212500291);
          IIODictionary::setObjectForKey(a2, value, @"NEW_PLUGIN_ostype");
          IIONumber::~IIONumber((IIONumber *)&v116);
          IIONumber::IIONumber((IIONumber *)&v116, 0);
          IIODictionary::setObjectForKey(a2, value, @"NEW_PLUGIN_dataOffset");
          IIONumber::~IIONumber((IIONumber *)&v116);
          kdebug_trace();
          uint64_t image_info = 4294967247;
LABEL_179:
          CGColorSpaceRelease(v42);
          goto LABEL_55;
        }
        int v48 = 0;
LABEL_143:
        int v49 = *((_DWORD *)this + 153);
        if ((v49 - 3) < 3)
        {
          *((_WORD *)this + 122) = 4;
          unsigned int v120 = 1129142603;
          goto LABEL_150;
        }
        if ((v49 - 1) >= 2)
        {
          if (v49) {
            goto LABEL_150;
          }
          unsigned int v120 = 1196573017;
          __int16 v50 = 1;
        }
        else
        {
          unsigned int v120 = 1380401696;
          __int16 v50 = 3;
        }
        *((_WORD *)this + 122) = v50;
LABEL_150:
        if (!v48) {
          goto LABEL_171;
        }
        unsigned int v51 = v120;
        if (v120 == 1380401696)
        {
          CGColorSpaceRef v52 = createColorSpaceFromMetadata(v113, v7, &v119);
          uint64_t v42 = v52;
          if (v119) {
            *((_WORD *)this + 164) = 1;
          }
          if (v52) {
            goto LABEL_171;
          }
        }
        CFDictionaryRef TopLevelTag = CGImageMetadataGetTopLevelTag(v113, @"http://ns.adobe.com/exif/1.0/", @"ColorSpace");
        if (TopLevelTag)
        {
          CFStringRef v54 = (const __CFString *)CGImageMetadataTagGetValue((uint64_t)TopLevelTag);
          if (v54)
          {
            if (CFStringGetIntValue(v54) == 1)
            {
              uint64_t v42 = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E4F1DC98]);
              if (v42) {
                goto LABEL_171;
              }
            }
          }
        }
        switch(v51)
        {
          case 0x52474220u:
            int v55 = (CFStringRef *)MEMORY[0x1E4F1DC98];
            break;
          case 0x47524159u:
            int v55 = (CFStringRef *)MEMORY[0x1E4F1DC00];
            break;
          case 0x434D594Bu:
            int v55 = (CFStringRef *)MEMORY[0x1E4F1DBF0];
            break;
          default:
            uint64_t v42 = 0;
            goto LABEL_171;
        }
        uint64_t v42 = CGColorSpaceCreateWithName(*v55);
LABEL_171:
        if ((gIIODebugFlags & 0x30000) != 0) {
          ImageIOLog("    %s:%d: handling subsampling\n", "initialize", 1809);
        }
        unint64_t v58 = *((int *)this + 150);
        signed int v59 = *((_DWORD *)this + 151);
        unint64_t v60 = v59;
        if (v58 > 0x2710 || v59 >= 0x2711)
        {
          if (!is_mul_ok(v58, v59)) {
            goto LABEL_178;
          }
          uint64_t v61 = (int)v58 * (uint64_t)v59;
          unint64_t v62 = *((void *)this + 23);
          if ((double)v62 / (double)(unint64_t)v61 < 0.003)
          {
            _cg_jpeg_mem_term("initialize", 1824, "*** pixelCount: %ld   fileSize: %d    ratio: %g\n", (int)v58 * (uint64_t)(int)v60, v62, (double)v62 / (double)(unint64_t)v61);
            goto LABEL_178;
          }
        }
        LOWORD(v63) = Uint32ForKey;
        if (v58 >= v60) {
          unint64_t v64 = v60;
        }
        else {
          unint64_t v64 = *((int *)this + 150);
        }
        if (v64 < Uint32ForKey) {
          goto LABEL_184;
        }
        if (Uint32ForKey < 2)
        {
          if (*((unsigned __int8 *)this + 216) >= 2u)
          {
            unint64_t v68 = *((unsigned int *)this + 53);
            if (v68)
            {
              if (v58 <= v60) {
                unint64_t v69 = v60;
              }
              else {
                unint64_t v69 = *((int *)this + 150);
              }
              if (v69 < v68) {
                unint64_t v68 = v69;
              }
              *((_DWORD *)this + 53) = v68;
              if (v68 <= (v58 + 7) >> 3 || v68 <= (v60 + 7) >> 3)
              {
                unint64_t v63 = 8;
              }
              else if (v68 <= (v58 + 3) >> 2 || v68 <= (v60 + 3) >> 2)
              {
                unint64_t v63 = 4;
              }
              else if (v68 <= (v58 + 1) >> 1 || v68 <= (v60 + 1) >> 1)
              {
                unint64_t v63 = 2;
              }
              else
              {
                unint64_t v63 = 1;
              }
              if (v63 > v60 || v63 > v58) {
                unint64_t v71 = 1;
              }
              else {
                unint64_t v71 = v63;
              }
              if (v71 < 2)
              {
LABEL_184:
                LOWORD(v63) = 1;
                goto LABEL_227;
              }
              if ((gIIODebugFlags & 0x30000) != 0
                && (ImageIOLog("    subsampling '%d' for thumnnail creation:\n", v71), (gIIODebugFlags & 0x30000) != 0)
                && (ImageIOLog("    original size: %d x %d\n", v58, v60), (gIIODebugFlags & 0x30000) != 0))
              {
                ImageIOLog("      scaled size: %g x %g\n", (float)((float)v58 / (float)v71), (float)((float)v60 / (float)v71));
                v58 /= v71;
                v60 /= v71;
                if ((gIIODebugFlags & 0x30000) != 0) {
                  ImageIOLog("       subsampled: %d x %d\n", v58, v60);
                }
              }
              else
              {
                v58 /= v71;
                v60 /= v71;
              }
            }
          }
        }
        else
        {
          __int16 v65 = 2;
          if (Uint32ForKey > 3) {
            __int16 v65 = 4;
          }
          char v66 = 1;
          if (Uint32ForKey > 3) {
            char v66 = 2;
          }
          if (Uint32ForKey <= 7) {
            LOWORD(v63) = v65;
          }
          else {
            LOWORD(v63) = 8;
          }
          char v67 = 3;
          if (Uint32ForKey <= 7) {
            char v67 = v66;
          }
          v58 >>= v67;
          v60 >>= v67;
        }
LABEL_227:
        if (!v58 || !v60)
        {
LABEL_178:
          uint64_t image_info = 0;
          if (!v42) {
            goto LABEL_55;
          }
          goto LABEL_179;
        }
        *((_WORD *)this + 158) = v63;
        *((unsigned char *)this + 678) = 1;
        unsigned int v72 = v120;
        if (v120 == 1380401696)
        {
          if (*((unsigned char *)this + 341))
          {
            char v73 = 5;
          }
          else
          {
            *((unsigned char *)this + 678) = 0;
            char v73 = 3;
          }
        }
        else
        {
          char v73 = 0;
        }
        if ((gIIODebugFlags & 0x30000) != 0) {
          ImageIOLog("    %s:%d: handling ColorTransform\n", "initialize", 1919);
        }
        BOOL v74 = v72 == 1129142603;
        *((unsigned char *)this + 677) = -1;
        if (!v115) {
          goto LABEL_268;
        }
        int v75 = precision;
        switch(v108)
        {
          case 2:
            if (v72 == 1129142603)
            {
              BOOL v74 = *((unsigned char *)this + 673) == 0;
              if ((gIIODebugFlags & 0x8000300000) != 0)
              {
                if (*((unsigned char *)this + 673)) {
                  unint64_t v76 = "false";
                }
                else {
                  unint64_t v76 = "true";
                }
                ImageIOLog("COL           shouldInvert: %s\n", v76);
                goto LABEL_260;
              }
            }
            else
            {
              BOOL v74 = 0;
            }
            break;
          case 1:
            if ((gIIODebugFlags & 0x8000300000) != 0)
            {
              ImageIOLog("COL           shouldInvert: true\n");
              goto LABEL_251;
            }
            goto LABEL_252;
          case 0:
            if (v72 == 1129142603)
            {
              if ((gIIODebugFlags & 0x8000300000) != 0)
              {
                ImageIOLog("COL           shouldInvert: true (icSigCmykData)\n");
LABEL_251:
                BOOL v74 = 1;
LABEL_260:
                int v75 = precision;
                break;
              }
LABEL_252:
              BOOL v74 = 1;
              break;
            }
            if (*((unsigned char *)this + 673))
            {
              if ((gIIODebugFlags & 0x8000300000) != 0) {
                goto LABEL_258;
              }
            }
            else
            {
              *((unsigned char *)this + 677) = 0;
              if ((gIIODebugFlags & 0x8000300000) != 0) {
LABEL_258:
              }
                ImageIOLog("COL           shouldInvert: %s\n", "false");
            }
            BOOL v74 = 0;
            goto LABEL_260;
        }
        if ((gIIODebugFlags & 0x8000000000) == 0) {
          goto LABEL_269;
        }
        unint64_t v77 = *((char *)this + 677);
        if (v77 > 2) {
          int v78 = "";
        }
        else {
          int v78 = off_1E53CC720[v77];
        }
        ImageIOLog("COL           _aj._force_app14: %s\n", v78);
        if ((gIIODebugFlags & 0x8000300000) != 0)
        {
          ImageIOLog("COL              dimension: %d x %d\n", v58, v60);
          if ((gIIODebugFlags & 0x8000300000) != 0) {
            ImageIOLog("COL\n");
          }
        }
LABEL_268:
        int v75 = precision;
LABEL_269:
        *((_WORD *)this + 120) = v75;
        *((_WORD *)this + 136) = v75;
        if (v72 == 1196573017) {
          __int16 v79 = 1;
        }
        else {
          __int16 v79 = 4;
        }
        *((_WORD *)this + 122) = v79;
        int v80 = v75 << (2 * (v72 != 1196573017));
        *((_WORD *)this + 121) = v80;
        *((void *)this + 20) = v42;
        *((_DWORD *)this + 81) = v72;
        *((unsigned char *)this + 246) = v73;
        *(_WORD *)((char *)this + 247) = 0;
        *((unsigned char *)this + 249) = 0;
        if (v72 == 1129142603)
        {
          unsigned int v81 = (((unsigned __int16)v75 + 7) >> 1) & 0xFFFC;
        }
        else
        {
          if (v72 != 1196573017)
          {
            if (v75 == 16) {
              int v84 = 4;
            }
            else {
              int v84 = 3;
            }
            unsigned int v85 = (unsigned __int16)v75 + 7;
            unint64_t v86 = v58 * (unint64_t)((v85 >> 3) * v84);
            BOOL v32 = (v86 & 0xFFFFFFFF00000000) == 0;
            int v87 = (v86 + 15) & 0xFFFFFFF0;
            if (!v32) {
              int v87 = 0;
            }
            *((_DWORD *)this + 59) = v87;
            *((unsigned char *)this + 344) = 0;
            *((unsigned char *)this + 346) = v74;
            if (v72 == 1380401696)
            {
              unint64_t v88 = v58 * (unint64_t)((v85 >> 1) & 0xFFFC);
              BOOL v32 = (v88 & 0xFFFFFFFF00000000) == 0;
              int v89 = (v88 + 15) & 0xFFFFFFF0;
              if (!v32) {
                int v89 = 0;
              }
              *((_DWORD *)this + 59) = v89;
              *((unsigned char *)this + 278) = v73;
              *(_WORD *)((char *)this + 279) = 0;
              *((unsigned char *)this + 281) = 0;
              *((_WORD *)this + 136) = v75;
              *((_WORD *)this + 137) = v80;
              *((_WORD *)this + 138) = v79;
              *((_DWORD *)this + 67) = v89;
              *((unsigned char *)this + 350) = 1;
            }
LABEL_289:
            if (v111)
            {
              uint64_t image_info = 0;
              unint64_t v90 = 3;
              if (v72 == 1196573017) {
                unint64_t v90 = 1;
              }
              if (v90 > NumberOfComponents || NumberOfComponents > v90 + 1) {
                goto LABEL_55;
              }
            }
            if ((gIIODebugFlags & 0x80000000) == 0) {
              *((unsigned char *)this + 348) = 1;
            }
            *((_DWORD *)this + 57) = v58;
            *((_DWORD *)this + 58) = v60;
            *((void *)this + 45) = 1;
            uint64_t v91 = *((void *)this + 75);
            *(void *)&long long v92 = (int)v91;
            *((void *)&v92 + 1) = SHIDWORD(v91);
            *((_OWORD *)this + 30) = v92;
            unsigned int chroma_subsampling = applejpeg_decode_get_chroma_subsampling();
            if (chroma_subsampling <= 4 && ((0x1Bu >> chroma_subsampling) & 1) != 0) {
              *((_DWORD *)this + 84) = dword_1889ABE9C[chroma_subsampling];
            }
            if (IIODictionary::containsKey(v5, @"kCGImageSourceUseHardwareAcceleration"))
            {
              BOOL v94 = IIODictionary::getBoolForKey(v5, @"kCGImageSourceUseHardwareAcceleration");
              if ((gIIODebugFlags & 0x4000000000000) != 0 && IIO_OSAppleInternalBuild())
              {
                memory_object_size_t v95 = "";
                if (v94) {
                  memory_object_size_t v95 = "";
                }
                ImageIOLog(" %s UseHardwareAcceleration  | %s:%d\n", v95, "initialize", 2116);
              }
            }
            else
            {
              if ((gIIODebugFlags & 0x4000000000000) != 0 && IIO_OSAppleInternalBuild()) {
                ImageIOLog("  UseHardwareAcceleration  | %s:%d\n", "initialize", 2119);
              }
              BOOL v94 = 1;
            }
            if (v110)
            {
              if (v110 == 1) {
                BOOL v94 = 1;
              }
              int v96 = 0;
              int v97 = *((unsigned __int8 *)this + 677);
              if (v97 != 255 || *((_DWORD *)this + 152) == 1 || !v94) {
                goto LABEL_318;
              }
              int v96 = IIOHardwareDecodingEnabledFlag();
            }
            else
            {
              int v96 = 0;
            }
            int v97 = *((unsigned __int8 *)this + 677);
LABEL_318:
            *((unsigned char *)this + 496) = v96;
            unint64_t v98 = *((unsigned int *)this + 57)
                * (unint64_t)((*((unsigned __int16 *)this + 120) + 7) >> 3 << (2
                                                                                                  * (*((_WORD *)this + 121) != 8)));
            BOOL v32 = (v98 & 0xFFFFFFFF00000000) == 0;
            int v99 = (v98 + 15) & 0xFFFFFFF0;
            if (!v32) {
              int v99 = 0;
            }
            *((_DWORD *)this + 67) = v99;
            BOOL v101 = v72 != 1129142603 && *((unsigned char *)this + 341) != 0 && v97 == 255;
            int v102 = v101;
            __int16 v103 = 1;
            if (v101)
            {
              if (v96) {
                char v104 = 3;
              }
              else {
                char v104 = 4;
              }
              *((unsigned char *)this + 449) = v104;
              __int16 v103 = 12;
            }
            *((unsigned char *)this + 448) = 1;
            *((_WORD *)this + 188) = v103;
            long long v105 = (IIOImagePlus *)*((void *)this + 2);
            if (v105 && IIOImagePlus::sourceImageProvider(v105)) {
              CGImageProviderSetProperty();
            }
            if ((gIIODebugFlags & 0x30000) != 0) {
              ImageIOLog("    %s:%d: useVersion3: %d\n", "initialize", 2195, v102);
            }
            goto LABEL_340;
          }
          unsigned int v81 = ((unsigned __int16)v75 + 7) >> 3;
        }
        unint64_t v82 = v58 * (unint64_t)v81;
        if ((v82 & 0xFFFFFFFF00000000) != 0) {
          int v83 = 0;
        }
        else {
          int v83 = (v82 + 15) & 0xFFFFFFF0;
        }
        *((_DWORD *)this + 59) = v83;
        *((unsigned char *)this + 344) = 0;
        *((unsigned char *)this + 346) = v74;
        goto LABEL_289;
      }
LABEL_142:
      int v48 = 1;
      goto LABEL_143;
    }
    if (!AppleJPEGReadPlugin::readJFIFData((IIOImageReadSession **)this, v114))
    {
LABEL_340:
      uint64_t image_info = 0;
      goto LABEL_55;
    }
    Exifunint64_t Data = AppleJPEGReadPlugin::readExifData((IIOImageReadSession **)this, v5);
    XMPunint64_t Data = ExifData;
    if (v7 | v8)
    {
      CGImageMetadataMerge((uint64_t)v113, (uint64_t)ExifData, 0);
      if (!XMPData)
      {
LABEL_114:
        if (v35) {
          IIODictionary::removeObjectForKey(*((IIODictionary **)this + 7), @"kCGImageSourceAddMetadataFromPrimaryImage");
        }
        goto LABEL_116;
      }
    }
    else
    {
      if (ExifData)
      {
        CGImageMetadataMerge((uint64_t)v113, (uint64_t)ExifData, v5);
        CFRelease(XMPData);
      }
      CGMutableImageMetadataRef APP13 = AppleJPEGReadPlugin::readAPP13((IIOImageReadSession **)this);
      if (APP13)
      {
        CGImageMetadataMerge((uint64_t)v113, (uint64_t)APP13, v5);
        CFRelease(APP13);
      }
      XMPunint64_t Data = (const void *)AppleJPEGReadPlugin::readXMPData((IIOImageReadSession **)this, theData);
      if (!XMPData) {
        goto LABEL_114;
      }
      CGImageMetadataMerge((uint64_t)v113, (uint64_t)XMPData, v5);
    }
    CFRelease(XMPData);
    goto LABEL_114;
  }
  if (v24 == 3)
  {
    if (*((unsigned char *)this + 341))
    {
      _cg_jpeg_mem_term("initialize", 1494, "*** AppleJPEG returned APPLEJPEG_ERR_UNSUPPORTED falling back to libJPEG\n");
      IIONumber::IIONumber((IIONumber *)&v116, 1279938631);
      IIODictionary::setObjectForKey(a2, value, @"NEW_PLUGIN_ostype");
      IIONumber::~IIONumber((IIONumber *)&v116);
      IIONumber::IIONumber((IIONumber *)&v116, *((void *)this + 24));
      IIODictionary::setObjectForKey(a2, value, @"NEW_PLUGIN_dataOffset");
      IIONumber::~IIONumber((IIONumber *)&v116);
      kdebug_trace();
      goto LABEL_54;
    }
    _cg_jpeg_mem_term("initialize", 1503, "*** AppleJPEG returned APPLEJPEG_ERR_UNSUPPORTED -- NOT falling back to libJPEG --> _rpd._isFinal==NO\n");
    uint64_t image_info = 3;
  }
  else
  {
    uint64_t v28 = gIIODebugFlags & 0x30000;
    long long v29 = AppleJPEGReadPlugin::appleJPEGErrorString(v24, (int)v24);
    uint64_t v30 = v29;
    if (v28) {
      ImageIOLog("    %s:%d: applejpeg_decode_open_file failed (%d) %s\n", "initialize", 1509, image_info, v29);
    }
    _cg_jpeg_mem_term("initialize", 1510, "applejpeg_decode_open_file failed (%d) '%s'\n", image_info, v30);
  }
LABEL_55:
  int v21 = gIIODebugFlags;
  if ((gIIODebugFlags & 0x1000000000) != 0)
  {
    double v22 = "YES";
    if (!*((unsigned char *)this + 496)) {
      double v22 = "NO";
    }
    ImageIOLog("H   %s: image size: {%d, %d} rb: %d    subsample: %d    useHW: %s\n", "initialize", *((_DWORD *)this + 57), *((_DWORD *)this + 58), *((_DWORD *)this + 59), *((unsigned __int16 *)this + 158), v22);
    int v21 = gIIODebugFlags;
  }
  if ((*(void *)&v21 & 0x30000) != 0) {
    ImageIOLog("    %s:%d: returning err: %d\n", "initialize", 2203, image_info);
  }
  if (image_info) {
    kdebug_trace();
  }
  return image_info;
}

void sub_1885F4AA0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, ...)
{
  va_start(va, a16);
  IIONumber::~IIONumber((IIONumber *)va);
  _Unwind_Resume(a1);
}

unint64_t IIOImageReadSession::seek(IIOImageReadSession *this, unint64_t a2, int a3)
{
  int v4 = (IIOImageRead *)*((void *)this + 4);
  if (!v4) {
    return -1;
  }
  unint64_t Size = IIOImageRead::getSize(v4);
  if (a3)
  {
    if (a3 == 1)
    {
      a2 += *((void *)this + 5);
    }
    else
    {
      uint64_t v8 = -1;
      if (a3 != 2 || Size == -1) {
        return v8;
      }
      a2 += Size;
    }
  }
  if (Size != -1 && a2 > Size) {
    return -1;
  }
  unint64_t v10 = *((void *)this + 5);
  if (a2 < v10)
  {
    unint64_t v10 = 0;
    *((void *)this + 5) = 0;
  }
  if (a2 > v10)
  {
    IIOImageReadSession::skipBytes(this, a2 - v10);
    unint64_t v10 = *((void *)this + 5);
  }
  if (v10 == a2) {
    return a2;
  }
  else {
    return -1;
  }
}

void *AppleJPEGReadPlugin::appleJPEGDecodeSetup(void *this)
{
  if (!this[63])
  {
    uint64_t v1 = this;
    this[81] = this[3];
    this[82] = this[24];
    this[83] = this[58];
    this[66] = 0;
    this[64] = iio_jpeg_Malloc;
    this[65] = iio_jpeg_Free;
    this = (void *)applejpeg_decode_create();
    v1[63] = this;
    *((unsigned char *)v1 + 679) = 0;
  }
  return this;
}

uint64_t IIOImagePlus::sourceImageProvider(IIOImagePlus *this)
{
  return *((void *)this + 18);
}

uint64_t IIO_HardwareDecoderDefaultValue()
{
  if (IIO_HardwareDecoderDefaultValue::onceToken != -1) {
    dispatch_once(&IIO_HardwareDecoderDefaultValue::onceToken, &__block_literal_global_33);
  }
  return IIO_HardwareDecoderDefaultValue::hwDecoderDefaultValue;
}

uint64_t IIOHardwareDecodingEnabledFlag()
{
  return (gPermissions >> 3) & 1;
}

CGImageMetadata *AppleJPEGReadPlugin::readExifData(IIOImageReadSession **this, IIODictionary *a2)
{
  char v29 = 0;
  int v48 = 0;
  unsigned __int16 v47 = 0;
  int v46 = 0;
  v44[0] = 0;
  v44[1] = v44;
  v44[2] = 0x2000000000;
  int v45 = 0;
  uint64_t v40 = 0;
  unint64_t v41 = &v40;
  uint64_t v42 = 0x2000000000;
  uint64_t v43 = 0;
  uint64_t v4 = 2;
  uint64_t v36 = 0;
  unsigned int v37 = &v36;
  uint64_t v38 = 0x2000000000;
  int v39 = 0;
  while (2)
  {
    for (unint64_t i = v4 + 10; ; ++i)
    {
      if (IIOImageReadSession::getBytesAtOffset(this[3], &v48, i - 10, 4uLL) != 4) {
        goto LABEL_21;
      }
      unsigned int v6 = bswap32((unsigned __int16)v48) >> 16;
      if (v6 != 0xFFFF) {
        break;
      }
    }
    if (v6 == 65498) {
      goto LABEL_21;
    }
    unsigned int v7 = __rev16(HIWORD(v48));
    if (v6 == 65504)
    {
      char v29 = 1;
      goto LABEL_14;
    }
    if (v6 != 65505 || v7 < 0xB) {
      goto LABEL_14;
    }
    if (IIOImageReadSession::getBytesAtOffset(this[3], &v46, i - 6, 6uLL) != 6)
    {
LABEL_21:
      CFMutableArrayRef Mutable = 0;
      goto LABEL_22;
    }
    if (v46 ^ 0x66697845 | v47)
    {
LABEL_14:
      uint64_t v4 = i + v7 - 8;
      continue;
    }
    break;
  }
  if (v7 < 0x15) {
    goto LABEL_21;
  }
  unsigned int v8 = IIOMetadataFlagsFromImageSourceOptions(a2);
  unsigned int v9 = malloc_type_malloc(v7 - 6, 0xDAFC518EuLL);
  if (!v9) {
    goto LABEL_21;
  }
  if (IIOImageReadSession::getBytesAtOffset(this[3], v9, i, v7 - 6) != v7 - 6)
  {
    free(v9);
    goto LABEL_21;
  }
  if (v8)
  {
    CFMutableArrayRef Mutable = CGImageMetadataCreateMutable();
    v34[0] = MEMORY[0x1E4F143A8];
    v34[1] = 0x40000000;
    void v34[2] = ___ZN19AppleJPEGReadPlugin12readExifDataEP13IIODictionarybb_block_invoke;
    void v34[3] = &unk_1E53C0150;
    v34[8] = Mutable;
    v34[9] = i - 10;
    unsigned int v35 = v8;
    v34[4] = v44;
    v34[5] = &v40;
    v34[6] = &v36;
    v34[7] = this;
    EnumerateExifDataUsingBlock(v9, v7 - 6, (uint64_t)v34);
    if (v41[3] && *((_DWORD *)v37 + 6))
    {
      uint64_t v33 = 0;
      memset(v32, 0, sizeof(v32));
      IIOScanner::IIOScanner((IIOScanner *)v32, v9, v7 - 6, 0);
      uint64_t v22 = v41[3];
      if (v22 - IIOScanner::seek((IIOScanner *)v32, v22 - i) == i
        && IIOScanner::getVal16((IIOScanner *)v32) == 65496
        && !v33)
      {
        while (1)
        {
          int Val16 = IIOScanner::getVal16((IIOScanner *)v32);
          unsigned int v24 = IIOScanner::getVal16((IIOScanner *)v32);
          if (Val16 == 65472) {
            break;
          }
          IIOScanner::skip((uint64_t)v32, v24 - 2);
          if (Val16 == 65498 || v33) {
            goto LABEL_37;
          }
        }
        IIOScanner::skip((uint64_t)v32, 1);
        int v25 = IIOScanner::getVal16((IIOScanner *)v32);
        int v26 = IIOScanner::getVal16((IIOScanner *)v32);
        IIONumber::IIONumber((IIONumber *)v30, v26);
        unint64_t v27 = CGImageMetadataTagCreate(@"http://ns.adobe.com/tiff/1.0/", @"iio", @"JPEGInterchangeFormatWidth", kCGImageMetadataTypeDefault, value);
        IIONumber::~IIONumber((IIONumber *)v30);
        if (v27)
        {
          CGImageMetadataSetTagWithPath(Mutable, 0, @"iio:JPEGInterchangeFormatWidth", v27);
          CFRelease(v27);
        }
        IIONumber::IIONumber((IIONumber *)v30, v25);
        uint64_t v28 = CGImageMetadataTagCreate(@"http://ns.adobe.com/tiff/1.0/", @"iio", @"JPEGInterchangeFormatHeight", kCGImageMetadataTypeDefault, value);
        IIONumber::~IIONumber((IIONumber *)v30);
        if (v28)
        {
          CGImageMetadataSetTagWithPath(Mutable, 0, @"iio:JPEGInterchangeFormatHeight", v28);
          CFRelease(v28);
        }
      }
LABEL_37:
      IIOScanner::~IIOScanner((IIOScanner *)v32);
    }
  }
  else
  {
    CFMutableArrayRef Mutable = (CGImageMetadata *)CreateMetadataFromDatabuffer(v9, v7 - 6);
  }
  free(v9);
LABEL_22:
  if (v29)
  {
    CFDictionaryRef TopLevelTag = CGImageMetadataGetTopLevelTag(Mutable, @"http://ns.apple.com/ImageIO/1.0/", @"JPEGInterchangeFormat");
    uint64_t v12 = (uint64_t)TopLevelTag;
    if (TopLevelTag)
    {
      CFStringRef v13 = (const __CFString *)CGImageMetadataTagGetValue((uint64_t)TopLevelTag);
      IntCFArrayRef Value = CFStringGetIntValue(v13);
      v41[3] = IntValue;
      LOWORD(v32[0]) = 0;
      IIOImageReadSession::getBytesAtOffset(this[3], v32, IntValue, 2uLL);
      if (LOWORD(v32[0]) != 55551 && LOWORD(v32[0]) != 65496)
      {
        unint64_t v15 = v41[3] + 18;
        v41[3] = v15;
        IIOImageReadSession::getBytesAtOffset(this[3], v32, v15, 2uLL);
        if (LOWORD(v32[0]) == 65496 || LOWORD(v32[0]) == 55551)
        {
          CFStringRef v16 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"%lld", v41[3]);
          if (v16)
          {
            CGImageMetadataTagSetValue(v12, v16);
            CFRelease(v16);
          }
        }
        else
        {
          CFDictionaryRef v17 = CGImageMetadataGetTopLevelTag(Mutable, @"http://ns.apple.com/ImageIO/1.0/", @"JPEGInterchangeFormat");
          CGImageMetadataRemoveTag((uint64_t)Mutable, (uint64_t)v17);
          CFDictionaryRef v18 = CGImageMetadataGetTopLevelTag(Mutable, @"http://ns.apple.com/ImageIO/1.0/", @"JPEGInterchangeFormatLength");
          CGImageMetadataRemoveTag((uint64_t)Mutable, (uint64_t)v18);
          CFDictionaryRef v19 = CGImageMetadataGetTopLevelTag(Mutable, @"http://ns.apple.com/ImageIO/1.0/", @"JPEGInterchangeFormatWidth");
          CGImageMetadataRemoveTag((uint64_t)Mutable, (uint64_t)v19);
          CFDictionaryRef v20 = CGImageMetadataGetTopLevelTag(Mutable, @"http://ns.apple.com/ImageIO/1.0/", @"JPEGInterchangeFormatHeight");
          CGImageMetadataRemoveTag((uint64_t)Mutable, (uint64_t)v20);
        }
      }
    }
  }
  _Block_object_dispose(&v36, 8);
  _Block_object_dispose(&v40, 8);
  _Block_object_dispose(v44, 8);
  return Mutable;
}

void sub_1885F5248(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  IIONumber::~IIONumber((IIONumber *)va);
  __cxa_begin_catch(a1);
  CGImageMetadataRemoveTagWithPath(v4, 0, @"iio:JPEGInterchangeFormatWidth");
  CGImageMetadataRemoveTagWithPath(v4, 0, @"iio:JPEGInterchangeFormatHeight");
  __cxa_end_catch();
  JUMPOUT(0x1885F50F8);
}

void sub_1885F52B8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  IIOScanner::~IIOScanner((IIOScanner *)va);
  JUMPOUT(0x1885F52F0);
}

void sub_1885F52EC(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 200), 8);
  _Block_object_dispose((const void *)(v1 - 168), 8);
  _Block_object_dispose((const void *)(v1 - 136), 8);
  _Unwind_Resume(a1);
}

CGColorSpaceRef createColorSpaceFromMetadata(const __CFDictionary *a1, int a2, unsigned char *a3)
{
  uint64_t v23 = 0;
  uint64_t v24 = 0;
  uint64_t v22 = 0;
  float v21 = 0.0;
  float v20 = 0.0;
  double v25 = 0.0;
  CFDictionaryRef TopLevelTag = CGImageMetadataGetTopLevelTag(a1, @"http://cipa.jp/exif/1.0/", @"Gamma");
  CFStringRef Source = (const __CFString *)CGImageSourceGetSource((uint64_t)TopLevelTag);
  float v8 = 0.0;
  if (Source)
  {
    CFStringRef v9 = Source;
    CFStringRef Source = (const __CFString *)Source[1].data;
    if (Source)
    {
      if (LODWORD(v9[1].info) == 1)
      {
        LODWORD(Source) = GetDoubleFromPropertyValue(Source, &v25);
        float v8 = v25;
      }
      else
      {
        LODWORD(Source) = 0;
      }
    }
  }
  if ((a2 & ~Source) != 0) {
    float v10 = 2.2;
  }
  else {
    float v10 = v8;
  }
  if ((Source & 1) == 0 && !a2) {
    return 0;
  }
  CGImageMetadataGetFloatAtIndex(a1, @"http://ns.adobe.com/tiff/1.0/", @"WhitePoint", 0, (float *)&v24 + 1);
  if (!v11) {
    return 0;
  }
  CGImageMetadataGetFloatAtIndex(a1, @"http://ns.adobe.com/tiff/1.0/", @"WhitePoint", 1u, (float *)&v24);
  if (!v12) {
    return 0;
  }
  CGImageMetadataGetFloatAtIndex(a1, @"http://ns.adobe.com/tiff/1.0/", @"PrimaryChromaticities", 0, (float *)&v23 + 1);
  if (!v13) {
    return 0;
  }
  CGImageMetadataGetFloatAtIndex(a1, @"http://ns.adobe.com/tiff/1.0/", @"PrimaryChromaticities", 1u, (float *)&v23);
  if (!v14) {
    return 0;
  }
  CGImageMetadataGetFloatAtIndex(a1, @"http://ns.adobe.com/tiff/1.0/", @"PrimaryChromaticities", 2u, (float *)&v22 + 1);
  if (!v15) {
    return 0;
  }
  CGImageMetadataGetFloatAtIndex(a1, @"http://ns.adobe.com/tiff/1.0/", @"PrimaryChromaticities", 3u, (float *)&v22);
  if (!v16) {
    return 0;
  }
  CGImageMetadataGetFloatAtIndex(a1, @"http://ns.adobe.com/tiff/1.0/", @"PrimaryChromaticities", 4u, &v21);
  if (!v17) {
    return 0;
  }
  CGImageMetadataGetFloatAtIndex(a1, @"http://ns.adobe.com/tiff/1.0/", @"PrimaryChromaticities", 5u, &v20);
  if (!v18) {
    return 0;
  }
  if (!IIOChromaticitiesMatchAdobeRGB(*((float *)&v24 + 1), *(float *)&v24, *((float *)&v23 + 1), *(float *)&v23, *((float *)&v22 + 1), *(float *)&v22, v21, v20, v10))return CGColorSpaceCreateCalRGB(*((float *)&v24 + 1), *(float *)&v24, *((float *)&v23 + 1), *(float *)&v23, *((float *)&v22 + 1), *(float *)&v22, v21, v20, v10); {
  if (a3)
  }
    *a3 = 1;
  return CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E4F1DB78]);
}

float CGImageMetadataGetFloatAtIndex(const CGImageMetadata *a1, const __CFString *a2, const __CFString *a3, unsigned int a4, float *a5)
{
  double v12 = 0.0;
  CFDictionaryRef TopLevelTag = CGImageMetadataGetTopLevelTag(a1, (uint64_t)a2, (uint64_t)a3);
  uint64_t Source = CGImageSourceGetSource((uint64_t)TopLevelTag);
  if (Source)
  {
    CFArrayRef v10 = *(const __CFArray **)(Source + 48);
    if (v10)
    {
      if (*(_DWORD *)(Source + 40) == 3 && CFArrayGetCount(*(CFArrayRef *)(Source + 48)) > a4)
      {
        ValueAtIndedouble x = (const __CFString *)CFArrayGetValueAtIndex(v10, a4);
        if (ValueAtIndex) {
          GetDoubleFromPropertyValue(ValueAtIndex, &v12);
        }
      }
    }
  }
  if (a5)
  {
    float result = v12;
    *a5 = result;
  }
  return result;
}

uint64_t AppleJPEGReadPlugin::decodeImageImp(IIOReadPlugin *this, IIODecodeParameter *a2, int a3, void *a4, uint64_t a5, uint64_t *a6)
{
  if ((gIIODebugFlags & 0x20000) != 0)
  {
    int v11 = *((_DWORD *)this + 51);
    unsigned int v12 = v11 >> 24;
    uint64_t v13 = MEMORY[0x1E4F14390];
    if (v11 < 0)
    {
      int v14 = __maskrune(v12, 0x40000uLL);
      int v11 = *((_DWORD *)this + 51);
    }
    else
    {
      int v14 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v12 + 60) & 0x40000;
    }
    if (v14) {
      uint64_t v15 = (v11 >> 24);
    }
    else {
      uint64_t v15 = 46;
    }
    unsigned int v16 = v11 << 8 >> 24;
    if (v11 << 8 < 0)
    {
      int v17 = __maskrune(v16, 0x40000uLL);
      int v11 = *((_DWORD *)this + 51);
    }
    else
    {
      int v17 = *(_DWORD *)(v13 + 4 * v16 + 60) & 0x40000;
    }
    if (v17) {
      uint64_t v18 = (v11 << 8 >> 24);
    }
    else {
      uint64_t v18 = 46;
    }
    unsigned int v19 = (__int16)v11 >> 8;
    if (v11 << 16 < 0)
    {
      int v20 = __maskrune(v19, 0x40000uLL);
      int v11 = *((_DWORD *)this + 51);
    }
    else
    {
      int v20 = *(_DWORD *)(v13 + 4 * v19 + 60) & 0x40000;
    }
    if (v20) {
      uint64_t v21 = ((__int16)v11 >> 8);
    }
    else {
      uint64_t v21 = 46;
    }
    if ((v11 << 24) <= 0x7F000000)
    {
      if ((*(_DWORD *)(v13 + 4 * (char)v11 + 60) & 0x40000) != 0) {
        goto LABEL_22;
      }
    }
    else if (__maskrune((char)v11, 0x40000uLL))
    {
LABEL_22:
      uint64_t v22 = *((char *)this + 204);
LABEL_25:
      ImageIOLog("  '%c%c%c%c' [%s] %s\n", v15, v18, v21, v22, iioTypeStr[a3], "virtual OSStatus AppleJPEGReadPlugin::decodeImageImp(IIODecodeParameter *, IIOImageType, IOSurfaceRef *, CVPixelBufferRef *, CGImageBlockSetRef *)");
      goto LABEL_26;
    }
    uint64_t v22 = 46;
    goto LABEL_25;
  }
LABEL_26:
  uint64_t v23 = (AppleJPEGReadPlugin *)IIOReadPlugin::debugDecodeImage(this, a2);
  if (a3 == 3)
  {
    uint64_t v26 = *((void *)a2 + 1);
    uint64_t v27 = *((void *)a2 + 2);
    double v28 = *((double *)a2 + 3);
    double v29 = *((double *)a2 + 4);
    double v30 = *((double *)a2 + 5);
    double v31 = *((double *)a2 + 6);
    double v32 = *((double *)a2 + 7);
    double v33 = *((double *)a2 + 8);
    uint64_t XmpData = _APP1XMP::getXmpData(a2);
    uint64_t v35 = (*(uint64_t (**)(IIOReadPlugin *, uint64_t, uint64_t, uint64_t, double, double, double, double, double, double))(*(void *)this + 208))(this, v26, v27, XmpData, v28, v29, v30, v31, v32, v33);
    uint64_t v25 = 4294967246;
    if (a6)
    {
      *a6 = v35;
      if (v35) {
        return 0;
      }
      else {
        return 4294967246;
      }
    }
    return v25;
  }
  if (a3 != 1)
  {
    _cg_jpeg_mem_term("decodeImageImp", 2847, "*** ERROR: imageType '%d' not handled\n", a3);
    return 4294967246;
  }
  if (!a4) {
    return 4294967246;
  }
  if (*a4)
  {
    AppleJPEGReadPlugin::decodeIntoIOSurface(v23, a2, v24);
    uint64_t v25 = 4294967246;
    _cg_jpeg_mem_term("decodeImageImp", 2828, "*** decodeIntoIOSurface - err = %d\n", -50);
    return v25;
  }
  uint64_t v37 = *((void *)a2 + 2);
  uint64_t v38 = _APP1XMP::getXmpData(a2);
  int v39 = *(uint64_t (**)(IIOReadPlugin *, uint64_t, uint64_t, void *, void))(*(void *)this + 224);

  return v39(this, v37, v38, a4, 0);
}

uint64_t PNGReadPlugin::decodeImageImp(IIOReadPlugin *this, IIODecodeParameter *a2, int a3, IOSurfaceRef *a4, uint64_t a5, uint64_t *a6)
{
  if ((gIIODebugFlags & 0x20000) != 0)
  {
    int v11 = *((_DWORD *)this + 51);
    unsigned int v12 = v11 >> 24;
    uint64_t v13 = MEMORY[0x1E4F14390];
    if (v11 < 0)
    {
      int v14 = __maskrune(v12, 0x40000uLL);
      int v11 = *((_DWORD *)this + 51);
    }
    else
    {
      int v14 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v12 + 60) & 0x40000;
    }
    if (v14) {
      uint64_t v15 = (v11 >> 24);
    }
    else {
      uint64_t v15 = 46;
    }
    unsigned int v16 = v11 << 8 >> 24;
    if (v11 << 8 < 0)
    {
      int v17 = __maskrune(v16, 0x40000uLL);
      int v11 = *((_DWORD *)this + 51);
    }
    else
    {
      int v17 = *(_DWORD *)(v13 + 4 * v16 + 60) & 0x40000;
    }
    if (v17) {
      uint64_t v18 = (v11 << 8 >> 24);
    }
    else {
      uint64_t v18 = 46;
    }
    unsigned int v19 = (__int16)v11 >> 8;
    if (v11 << 16 < 0)
    {
      int v20 = __maskrune(v19, 0x40000uLL);
      int v11 = *((_DWORD *)this + 51);
    }
    else
    {
      int v20 = *(_DWORD *)(v13 + 4 * v19 + 60) & 0x40000;
    }
    if (v20) {
      uint64_t v21 = ((__int16)v11 >> 8);
    }
    else {
      uint64_t v21 = 46;
    }
    if ((v11 << 24) <= 0x7F000000)
    {
      if ((*(_DWORD *)(v13 + 4 * (char)v11 + 60) & 0x40000) != 0) {
        goto LABEL_22;
      }
    }
    else if (__maskrune((char)v11, 0x40000uLL))
    {
LABEL_22:
      uint64_t v22 = *((char *)this + 204);
LABEL_25:
      ImageIOLog("  '%c%c%c%c' [%s] %s\n", v15, v18, v21, v22, iioTypeStr[a3], "virtual OSStatus PNGReadPlugin::decodeImageImp(IIODecodeParameter *, IIOImageType, IOSurfaceRef *, CVPixelBufferRef *, CGImageBlockSetRef *)");
      goto LABEL_26;
    }
    uint64_t v22 = 46;
    goto LABEL_25;
  }
LABEL_26:
  IIOReadPlugin::debugDecodeImage(this, a2);
  *((_DWORD *)this + 52) = *((void *)a2 + 9);
  *((_DWORD *)this + 26) = 1;
  int v23 = *((unsigned __int8 *)this + 440);
  if (v23 == 3)
  {
    double v32 = (const void *)*((void *)a2 + 1);
    double v33 = (const void *)*((void *)a2 + 2);
    double v34 = *((double *)a2 + 3);
    double v35 = *((double *)a2 + 4);
    double v36 = *((double *)a2 + 5);
    double v37 = *((double *)a2 + 6);
    double v38 = *((double *)a2 + 7);
    double v39 = *((double *)a2 + 8);
    _APP1XMP::getXmpData(a2);
    uint64_t v30 = (uint64_t)PNGReadPlugin::copyImageBlockSetAPNG((uint64_t)this, v32, v33, v34, v35, v36, v37, v38, v39);
    goto LABEL_33;
  }
  if (v23 == 2)
  {
    _APP1XMP::getXmpData(a2);
    PNGReadPlugin::copyImageBlockSetInterlaced((uint64_t)this);
    goto LABEL_31;
  }
  if (v23 != 1)
  {
LABEL_31:
    uint64_t v31 = 0;
    goto LABEL_34;
  }
  uint64_t v24 = (const void *)*((void *)a2 + 1);
  uint64_t v25 = (const void *)*((void *)a2 + 2);
  double v26 = *((double *)a2 + 3);
  double v27 = *((double *)a2 + 4);
  double v28 = *((double *)a2 + 5);
  double v29 = *((double *)a2 + 6);
  _APP1XMP::getXmpData(a2);
  uint64_t v30 = PNGReadPlugin::copyImageBlockSetStandard((uint64_t)this, v24, v25, v26, v27, v28, v29);
LABEL_33:
  uint64_t v31 = v30;
LABEL_34:
  if (a3 == 1)
  {
    if (v31 && CGImageBlockSetGetCount() == 1 || *((_DWORD *)this + 26) == 1)
    {
      if (!a4 || !*a4)
      {
        uint64_t v43 = 0;
        goto LABEL_58;
      }
      if (IOSurfaceLock(*a4, 0, 0))
      {
        uint64_t v43 = 4294967246;
      }
      else
      {
        BaseAddress = IOSurfaceGetBaseAddress(*a4);
        IOSurfaceGetWidth(*a4);
        size_t Height = IOSurfaceGetHeight(*a4);
        size_t BytesPerRow = IOSurfaceGetBytesPerRow(*a4);
        if (v31) {
          CGImageBlockSetGetImageBlock();
        }
        CGImageBlockGetRect();
        double v45 = v44;
        uint64_t v46 = CGImageBlockGetBytesPerRow();
        unint64_t Data = (const void *)CGImageBlockGetData();
        if (BytesPerRow == v46 && Height == (unint64_t)v45) {
          memcpy(BaseAddress, Data, BytesPerRow * Height);
        }
        else {
          _cg_jpeg_mem_term("decodeImageImp", 3529, "*** ERROR: cannot copy into IOSurface\n");
        }
        uint64_t v43 = 0;
      }
    }
    else
    {
      uint64_t v43 = 4294967246;
      if (!a4) {
        goto LABEL_58;
      }
    }
    goto LABEL_56;
  }
  uint64_t v43 = 4294967246;
  if (a3 == 3 && a6)
  {
    uint64_t v43 = 0;
    *a6 = v31;
    uint64_t v31 = 0;
  }
  if (a4)
  {
LABEL_56:
    if (*a4) {
      IOSurfaceUnlock(*a4, 0, 0);
    }
  }
LABEL_58:
  if (v31) {
    CGImageBlockSetRelease();
  }
  return v43;
}

void sub_1885F5C9C(void *a1)
{
}

const char *IIOReadPlugin::debugCopyBlockSet(const char *result, const void *a2, double a3, double a4, double a5, double a6, double a7, double a8)
{
  if (result[181])
  {
    uint64_t v15 = result;
    Pixelunint64_t Size = CGImageProviderGetPixelSize();
    CGImageProviderGetSize();
    double v18 = v17;
    double v20 = v19;
    int v21 = *((_DWORD *)v15 + 51);
    ImageIOLog("===================================================================================================\n");
    unsigned int v22 = v21 >> 24;
    uint64_t v23 = MEMORY[0x1E4F14390];
    if (v21 < 0) {
      int v24 = __maskrune(v21 >> 24, 0x40000uLL);
    }
    else {
      int v24 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v22 + 60) & 0x40000;
    }
    if (v24) {
      uint64_t v25 = v22;
    }
    else {
      uint64_t v25 = 46;
    }
    unsigned int v26 = v21 << 8 >> 24;
    if (v21 << 8 < 0) {
      int v27 = __maskrune(v21 << 8 >> 24, 0x40000uLL);
    }
    else {
      int v27 = *(_DWORD *)(v23 + 4 * v26 + 60) & 0x40000;
    }
    if (v27) {
      uint64_t v28 = v26;
    }
    else {
      uint64_t v28 = 46;
    }
    unsigned int v29 = (__int16)v21 >> 8;
    if (v21 << 16 < 0) {
      int v30 = __maskrune((__int16)v21 >> 8, 0x40000uLL);
    }
    else {
      int v30 = *(_DWORD *)(v23 + 4 * v29 + 60) & 0x40000;
    }
    if (v30) {
      uint64_t v31 = v29;
    }
    else {
      uint64_t v31 = 46;
    }
    if ((v21 << 24) <= 0x7F000000) {
      int v32 = *(_DWORD *)(v23 + 4 * (char)v21 + 60) & 0x40000;
    }
    else {
      int v32 = __maskrune((char)v21, 0x40000uLL);
    }
    if (v32) {
      uint64_t v33 = (char)v21;
    }
    else {
      uint64_t v33 = 46;
    }
    ImageIOLog(">>> CGImageBlockSet - %c%c%c%c\n", v25, v28, v31, v33);
    ImageIOLog("                         plugin: %p\n", v15);
    ImageIOLog("                          index: %d\n", *((_DWORD *)v15 + 52));
    ImageIOLog("                     sourceRect: {%g, %g, %g, %g}\n", a3, a4, a5, a6);
    ImageIOLog("               destionationSize: {%g, %g}\n", a7, a8);
    ImageIOLog("                      imageSize: {%d, %d}\n", (int)v18, (int)v20);
    ImageIOLog("                       provider: %p\n", a2);
    ImageIOLog("                      pixelSize: %zu\n", PixelSize);
    ImageIOLog("                        session: %p\n", *((const void **)v15 + 3));
    ImageIOLog("                subsampleFactor: %d\n", *((unsigned __int16 *)v15 + 158));
    if (*((_DWORD *)v15 + 73) > *((_DWORD *)v15 + 65))
    {
      if (*((unsigned __int16 *)v15 + 158) <= 1u) {
        double v34 = "";
      }
      else {
        double v34 = "SUBSAMPLING ISSUE";
      }
      _cg_jpeg_mem_term("debugCopyBlockSet", 1581, "*** _rpd._blockGeo seem to be wrong %s\n", v34);
    }
    if (*((unsigned __int8 *)v15 + 409) != 255) {
      ImageIOLog("               addressAlignment: %d\n", *((void *)v15 + 48));
    }
    if (*((void *)v15 + 49) != -1) {
      ImageIOLog("              rowBytesAlignment: %d\n", *((void *)v15 + 49));
    }
    if (*((unsigned __int8 *)v15 + 408) != 255) {
      ImageIOLog("                      singleton: YES\n");
    }
    int v35 = *((unsigned __int8 *)v15 + 404);
    if (v35 != 255)
    {
      if (v35 == 1) {
        double v36 = "YES";
      }
      else {
        double v36 = "NO";
      }
      ImageIOLog("                   format_BGRx8: %s\n", v36);
    }
    int v37 = *((unsigned __int8 *)v15 + 406);
    if (v37 != 255)
    {
      if (v37 == 1) {
        double v38 = "YES";
      }
      else {
        double v38 = "NO";
      }
      ImageIOLog("              premultiplication: %s\n", v38);
    }
    int v39 = *((unsigned __int8 *)v15 + 411);
    if (v39 != 255)
    {
      if (v39 == 1) {
        uint64_t v40 = "YES";
      }
      else {
        uint64_t v40 = "NO";
      }
      ImageIOLog("      cacheImmediatelyRequested: %s\n", v40);
    }
    int v41 = *((unsigned __int8 *)v15 + 407);
    if (v41 != 255)
    {
      if (v41 == 1) {
        uint64_t v42 = "YES";
      }
      else {
        uint64_t v42 = "NO";
      }
      ImageIOLog("                 readOnlyBlocks: %s\n", v42);
    }
    return ImageIOLog("\n");
  }
  return result;
}

const char *IIOReadPlugin::debugDecodeImage(IIOReadPlugin *this, IIODecodeParameter *a2)
{
  if ((gIIODebugFlags & 0x20000) != 0)
  {
    ImageIOLog("    debugDecodeImage\n");
    _APP1XMP::getXmpData(a2);
    IIOReadPlugin::printRequests(this, v12);
    return IIOReadPlugin::debugGeometry((uint64_t)this, 0, 0);
  }
  else
  {
    uint64_t v4 = (const void *)*((void *)a2 + 2);
    double v5 = *((double *)a2 + 3);
    double v6 = *((double *)a2 + 4);
    double v7 = *((double *)a2 + 5);
    double v8 = *((double *)a2 + 6);
    double v9 = *((double *)a2 + 7);
    double v10 = *((double *)a2 + 8);
    return IIOReadPlugin::debugCopyBlockSet((const char *)this, v4, v5, v6, v7, v8, v9, v10);
  }
}

IIODictionary *IIOMetadataFlagsFromImageSourceOptions(IIODictionary *result)
{
  if (result)
  {
    uint64_t v1 = result;
    unsigned int v2 = IIOSkipMetadata(result);
    if (IIOSkipXMP_and_IPTC(v1)) {
      v2 |= 2u;
    }
    if (IIODictionary::getBoolForKey(v1, @"kCGImageSourceAddThumbnailInformation")) {
      v2 |= 4u;
    }
    if (IIODictionary::getBoolForKey(v1, @"kCGImageSourceShouldPreferIPTCToEXIF")) {
      return (IIODictionary *)(v2 | 8);
    }
    else {
      return (IIODictionary *)v2;
    }
  }
  return result;
}

CGMutableImageMetadataRef AppleJPEGReadPlugin::readAPP13(IIOImageReadSession **this)
{
  v17[2] = *MEMORY[0x1E4F143B8];
  int v16 = 0;
  *(void *)((char *)v17 + 6) = 0;
  v17[0] = 0;
  CGMutableImageMetadataRef Mutable = 0;
  if (IIOImageReadSession::getBytesAtOffset(this[3], &v16, 2uLL, 4uLL) != 4) {
    return Mutable;
  }
  unint64_t v3 = 0;
  uint64_t v4 = 0;
  unint64_t v5 = 2;
  while (1)
  {
    unsigned int v6 = bswap32((unsigned __int16)v16) >> 16;
    uint64_t v7 = bswap32(HIWORD(v16)) >> 16;
    if (v6 == 65517)
    {
      if (v7 >= 0xF)
      {
        if (IIOImageReadSession::getBytesAtOffset(this[3], v17, v5 + 4, 0xEuLL) != 14) {
          goto LABEL_21;
        }
        if (v17[0] == 0x6F68736F746F6850 && *(void *)((char *)v17 + 6) == 0x302E3320706F68)
        {
          if (v7 < 0x11) {
            goto LABEL_21;
          }
          uint64_t v9 = (v7 - 16);
          uint64_t v4 = reallocf(v4, v9 + v3);
          if (v4)
          {
            if (IIOImageReadSession::getBytesAtOffset(this[3], (unsigned char *)v4 + v3, v5 + 18, (v7 - 16)) != v9)
            {
              CGMutableImageMetadataRef Mutable = 0;
LABEL_22:
              free(v4);
              return Mutable;
            }
            v3 += v9;
          }
        }
      }
      goto LABEL_18;
    }
    if (v6 == 0xFFFF)
    {
      ++v5;
      goto LABEL_20;
    }
    if (v6 == 65498) {
      break;
    }
LABEL_18:
    v5 += v7 + 2;
LABEL_20:
    if (IIOImageReadSession::getBytesAtOffset(this[3], &v16, v5, 4uLL) != 4)
    {
LABEL_21:
      CGMutableImageMetadataRef Mutable = 0;
      if (!v4) {
        return Mutable;
      }
      goto LABEL_22;
    }
  }
  if (v4)
  {
    CGMutableImageMetadataRef Mutable = CGImageMetadataCreateMutable();
    ReadPhotoshopImageResource((uint64_t)Mutable, (uint64_t)v4, v3);
    if (Mutable)
    {
      TagWithPath = CGImageMetadataGetTagWithPath(Mutable, 0, @"iio:PSIRClippingPath");
      if (TagWithPath)
      {
        uint64_t v12 = (uint64_t)TagWithPath;
        CFArrayRef Value = (const CGPath *)CGImageMetadataTagGetValue((uint64_t)TagWithPath);
        if (Value)
        {
          int v14 = this[2];
          uint64_t v15 = CGPathRetain(Value);
          IIOImagePlus::setClipPath(v14, v15);
        }
        CGImageMetadataRemoveTag((uint64_t)Mutable, v12);
      }
    }
    goto LABEL_22;
  }
  return 0;
}

uint64_t AppleJPEGReadPlugin::readXMPData(IIOImageReadSession **this, CFDataRef theData)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  if (theData)
  {
    BytePtr = (const char *)CFDataGetBytePtr(theData);
    CFIndex Length = CFDataGetLength(theData);
    return CreateMetadataFromXMPSidecarData(BytePtr, Length);
  }
  long long v35 = 0u;
  memset(v36, 0, sizeof(v36));
  int v28 = 0;
  uint64_t v32 = 0;
  uint64_t v33 = 0;
  memset(v34, 0, 14);
  memset(__s1, 0, 75);
  MetadataFromExtendedXMPunint64_t Data = 0;
  if (IIOImageReadSession::getBytesAtOffset(this[3], &v28, 2uLL, 4uLL) != 4) {
    return MetadataFromExtendedXMPData;
  }
  char v24 = 0;
  uint64_t v25 = 0;
  int v26 = 0;
  double v8 = 0;
  LODWORD(v9) = 0;
  double v10 = 0;
  unint64_t v11 = 2;
  while (1)
  {
    unsigned int v12 = bswap32((unsigned __int16)v28) >> 16;
    unsigned int v13 = bswap32(HIWORD(v28)) >> 16;
    if (v12 != 65505)
    {
      if (v12 == 65498) {
        goto LABEL_44;
      }
      goto LABEL_43;
    }
    if (v13 >= 0x1E) {
      break;
    }
LABEL_43:
    v11 += v13 + 2;
    if (IIOImageReadSession::getBytesAtOffset(this[3], &v28, v11, 4uLL) != 4)
    {
LABEL_44:
      if (!v8) {
        goto LABEL_52;
      }
      goto LABEL_45;
    }
  }
  if (IIOImageReadSession::getBytesAtOffset(this[3], &v32, v11 + 4, 0x1EuLL) != 30) {
    goto LABEL_44;
  }
  BOOL v15 = v32 == 0x6E2F2F3A70747468 && v33 == 0x2E65626F64612E73 && v34[0] == 0x2F7061782F6D6F63;
  if (v15 && BYTE5(v34[1]) == 60)
  {
    size_t v9 = v13 - 31;
    double v10 = reallocf(v10, v9);
    if (IIOImageReadSession::getBytesAtOffset(this[3], v10, v11 + 33, v9) != v9) {
      goto LABEL_44;
    }
    goto LABEL_43;
  }
  if (v13 < 0x4C) {
    goto LABEL_43;
  }
  if (IIOImageReadSession::getBytesAtOffset(this[3], __s1, v11 + 4, 0x4BuLL) != 75) {
    goto LABEL_44;
  }
  if (strcmp((const char *)__s1, "http://ns.adobe.com/xmp/extension/")) {
    goto LABEL_43;
  }
  uint64_t v23 = v8;
  long long v29 = 0u;
  long long v30 = 0u;
  IIOImageReadSession::getBytesAtOffset(this[3], &v29, v11 + 39, 0x20uLL);
  unsigned int v27 = 0;
  IIOImageReadSession::getBytesAtOffset(this[3], &v27, v11 + 71, 4uLL);
  size_t v16 = bswap32(v27);
  unsigned int v27 = 0;
  IIOImageReadSession::getBytesAtOffset(this[3], &v27, v11 + 75, 4uLL);
  unsigned int v17 = v27;
  if ((v24 & 1) != 0
    || (v35 = v29, *(_OWORD *)v36 = v30, v26 = v16, (uint64_t v23 = (char *)malloc_type_calloc(1uLL, v16, 0x5BBD479CuLL)) != 0))
  {
    BOOL v20 = (void)v35 == (void)v29
       && *((void *)&v35 + 1) == *((void *)&v29 + 1)
       && *(void *)v36 == (void)v30
       && *(void *)&v36[8] == *((void *)&v30 + 1);
    if (v20 && v16 == v26)
    {
      uint64_t v21 = bswap32(v17);
      uint64_t v22 = v13 - 77;
      if (v21 + (unint64_t)v22 > v16) {
        goto LABEL_51;
      }
      IIOImageReadSession::getBytesAtOffset(this[3], &v23[v21], v11 + 79, v13 - 77);
      v25 += v22;
    }
    char v24 = 1;
    double v8 = v23;
    goto LABEL_43;
  }
  uint64_t v23 = 0;
LABEL_51:
  int v26 = v16;
  double v8 = v23;
  if (v23)
  {
LABEL_45:
    if (!v26 || v25 != v26 || !v10 || !v9) {
      goto LABEL_52;
    }
    MetadataFromExtendedXMPunint64_t Data = CreateMetadataFromExtendedXMPData(v10, v9, v8);
    free(v10);
    goto LABEL_59;
  }
LABEL_52:
  if (v10 && v9)
  {
    MetadataFromExtendedXMPunint64_t Data = CreateMetadataFromXMPBuffer(v10, v9);
    free(v10);
    if (!v8) {
      return MetadataFromExtendedXMPData;
    }
    goto LABEL_59;
  }
  if (v10) {
    free(v10);
  }
  MetadataFromExtendedXMPunint64_t Data = 0;
  if (v8) {
LABEL_59:
  }
    free(v8);
  return MetadataFromExtendedXMPData;
}

IIOImageRead *IIOImageReadSession::skipBytes(IIOImageReadSession *this, uint64_t a2)
{
  unint64_t v3 = (IIOImageReadSession *)MEMORY[0x1F4188790](this, a2);
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  float result = (IIOImageRead *)*((void *)v3 + 4);
  if (result)
  {
    unint64_t v5 = v2;
    CFIndex Size = IIOImageRead::getSize(result);
    if (Size == -1)
    {
      bzero(v11, 0x2000uLL);
      if (v5)
      {
        unint64_t v8 = (unint64_t)v5;
        do
        {
          if (v8 >= 0x400) {
            unint64_t v9 = 1024;
          }
          else {
            unint64_t v9 = v8;
          }
          unint64_t Bytes = IIOImageReadSession::getBytes(v3, v11, v9);
          if (!Bytes) {
            break;
          }
          v8 -= Bytes;
        }
        while (v8);
      }
      else
      {
        unint64_t v8 = 0;
      }
      return (IIOImageRead *)((char *)v5 - v8);
    }
    else
    {
      uint64_t v7 = *((void *)v3 + 5);
      if (Size - v7 >= (unint64_t)v5) {
        float result = v5;
      }
      else {
        float result = (IIOImageRead *)(Size - v7);
      }
      *((void *)v3 + 5) = (char *)result + v7;
    }
  }
  return result;
}

__n128 AppleJPEGReadPlugin::save_index_table(AppleJPEGReadPlugin *this)
{
  if (!*((void *)this + 79))
  {
    size_t ra_table_sz = (int)applejpeg_decode_get_ra_table_sz();
    *((void *)this + 80) = (int)ra_table_sz;
    if (ra_table_sz)
    {
      *((void *)this + 79) = malloc_type_malloc(ra_table_sz, 0x3B70D5EDuLL);
      uint64_t v4 = (AppleJPEGReadPlugin *)applejpeg_decode_dump_ra_table();
      if (v4)
      {
        int v5 = (int)v4;
        unsigned int v6 = AppleJPEGReadPlugin::appleJPEGErrorString(v4, (int)v4);
        return _cg_jpeg_mem_term("save_index_table", 273, "err = %d '%s'\n", v5, v6);
      }
    }
  }
  return result;
}

void ReadPhotoshopImageResource(uint64_t a1, uint64_t a2, unint64_t a3)
{
  uint64_t v73 = *MEMORY[0x1E4F143B8];
  if (a3 >= 0xD)
  {
    CFStringRef v5 = 0;
    unint64_t v6 = 0;
    unint64_t v54 = a3 - 7;
    CFStringRef cf = 0;
    CFDictionaryRef theDict = 0;
    unint64_t v53 = a3 - 4;
    CFAllocatorRef allocator = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    uint64_t v7 = @"%02X";
    while (1)
    {
      if (*(_DWORD *)(a2 + v6) != 1296646712) {
        goto LABEL_64;
      }
      long long v71 = 0u;
      long long v72 = 0u;
      long long v69 = 0u;
      long long v70 = 0u;
      long long v67 = 0u;
      long long v68 = 0u;
      long long v65 = 0u;
      long long v66 = 0u;
      long long v63 = 0u;
      long long v64 = 0u;
      long long v61 = 0u;
      long long v62 = 0u;
      long long v59 = 0u;
      long long v60 = 0u;
      *(_OWORD *)int8x16_t __dst = 0u;
      long long v58 = 0u;
      unint64_t v8 = (const char *)(a2 + v6 + 6);
      unint64_t v9 = *(unsigned __int8 *)v8;
      if (v54 - v6 < v9) {
        break;
      }
      CFStringRef v10 = v7;
      unsigned int v11 = *(unsigned __int16 *)(v6 + a2 + 4);
      strncpy(__dst, v8 + 1, *(unsigned __int8 *)v8);
      __dst[v9] = 0;
      uint64_t v12 = ((_WORD)v9 + 2) & 0x1FE;
      unint64_t v13 = v12 + v6 + 6;
      if (v13 + 3 > a3)
      {
        if (v5) {
          CFRelease(v5);
        }
        int v41 = 261;
        CFStringRef v5 = (const __CFString *)cf;
        if (!cf) {
          goto LABEL_72;
        }
        goto LABEL_71;
      }
      if (v13 > v53 || ((unsigned int v14 = *(_DWORD *)(a2 + v13), v13 += 4, a3 >= v13) ? (v15 = v14 == 0) : (v15 = 1), v15))
      {
        uint64_t v7 = (__CFString *)v10;
      }
      else
      {
        CFStringRef v51 = v5;
        unint64_t v16 = bswap32(v14);
        if (a3 - v13 < v16)
        {
          LogError("ReadPhotoshopImageResource", 284, "*** ERROR: Corrupt 8BIM data. Reported 8BIM length (%zu bytes) exceeds actual length (%zu bytes).\n", v16, a3 - v13);
          CFStringRef v5 = v51;
          CFDictionaryRef v37 = theDict;
          goto LABEL_78;
        }
        unsigned int v17 = __rev16(v11);
        if (v17 == 1028)
        {
          uint64_t v7 = (__CFString *)v10;
          if (cf) {
            CFRelease(cf);
          }
          CFStringRef cf = CreateMetadataFromIPTCDatabuffer((unsigned char *)(a2 + v13), v16);
        }
        else
        {
          uint64_t v7 = (__CFString *)v10;
          if (v17 - 2000 > 0x3E6 || v16 % 0x1A)
          {
            if (v17 == 2999)
            {
              if (v51) {
                CFRelease(v51);
              }
              if (v16 <= *(unsigned __int8 *)(a2 + v13))
              {
                LogError("ReadPhotoshopImageResource", 310, "*** ERROR: Corrupt Photoshop Image Resources Field (id=%d), Pascal string length exceeds size of field", 2999);
                CFStringRef v5 = 0;
                CFDictionaryRef v37 = theDict;
                goto LABEL_78;
              }
              CFStringRef v51 = CFStringCreateWithPascalString(allocator, (ConstStr255Param)(a2 + v13), 0);
            }
            else if (v17 == 1061 && v14 == 0x10000000)
            {
              CGMutableImageMetadataRef Mutable = CFStringCreateMutable(allocator, 32);
              for (uint64_t i = 0; i != 16; ++i)
                CFStringAppendFormat(Mutable, 0, v10, *(unsigned __int8 *)(a2 + v13 + i));
              double v36 = *(const void **)(a1 + 64);
              if (v36) {
                CFRelease(v36);
              }
              *(void *)(a1 + 64) = Mutable;
            }
          }
          else
          {
            uint64_t v45 = 0;
            path = CGPathCreateMutable();
            uint64_t v18 = 0;
            int64_t v19 = 0;
            char v44 = 0;
            size_t v48 = 0;
            BOOL v20 = 0;
            uint64_t v21 = a2 + v6 + v12;
            while (2)
            {
              uint64_t v22 = v18 + 13;
              while (1)
              {
                unsigned int v23 = __rev16(*(unsigned __int16 *)(v21 + v22 - 3));
                unint64_t v56 = 2;
                if (v23 > 5) {
                  break;
                }
                if (((1 << v23) & 0x36) == 0)
                {
                  if (v23)
                  {
                    if (v20)
                    {
                      add_points_to_path(path, v20, 3 * v45, v44 & 1);
                      free(v20);
                    }
                    uint64_t v45 = __rev16(*(unsigned __int16 *)(v21 + v22 - 1));
                    size_t v48 = v45 + 2 * v45;
                    BOOL v20 = (CGPoint *)malloc_type_calloc(v48, 0x10uLL, 0x1000040451B5BE8uLL);
                    char v44 = 0;
                    int64_t v19 = 0;
                  }
                  else
                  {
                    if (v20)
                    {
                      add_points_to_path(path, v20, 3 * v45, v44 & 1);
                      free(v20);
                    }
                    uint64_t v25 = __rev16(*(unsigned __int16 *)(v21 + v22 - 1));
                    if (!v25) {
                      goto LABEL_41;
                    }
                    uint64_t v45 = v25;
                    size_t v48 = 3 * v25;
                    BOOL v20 = (CGPoint *)malloc_type_calloc(3 * v25, 0x10uLL, 0x1000040451B5BE8uLL);
                    int64_t v19 = 0;
                    char v44 = 1;
                  }
                  break;
                }
                if (v20)
                {
                  int64_t v47 = v19;
                  if (v19 <= (uint64_t)(v48 - 3))
                  {
                    uint64_t v43 = (unsigned __int8 *)(v21 + v22 - 3);
                    int v26 = &v20[v19];
                    v26->double x = read_point(v43, &v56);
                    v26->double y = v27;
                    uint64_t v42 = &v20[v47];
                    v26[1].double x = read_point(v43, &v56);
                    v26[1].double y = v28;
                    uint64_t v7 = (__CFString *)v10;
                    double v29 = read_point(v43, &v56);
                    int64_t v19 = v47 + 3;
                    v42[2].double x = v29;
                    v42[2].double y = v30;
                  }
                  else
                  {
                    LogError("createPathWithData", 159, "*** ERROR: corrupt 8BIM data");
                    int64_t v19 = v47;
                  }
                  break;
                }
                unint64_t v24 = v22 + 13;
                v22 += 26;
                if (v24 >= v16) {
                  goto LABEL_41;
                }
              }
              uint64_t v18 = v22 + 13;
              if (v22 + 13 < v16) {
                continue;
              }
              break;
            }
            if (v20)
            {
              add_points_to_path(path, v20, 3 * v45, v44 & 1);
              free(v20);
            }
LABEL_41:
            uint64_t v31 = theDict;
            if (!theDict) {
              uint64_t v31 = CFDictionaryCreateMutable(allocator, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
            }
            if (path)
            {
              if (v31)
              {
                CFStringRef v32 = CFStringCreateWithCString(allocator, __dst, 0);
                if (v32)
                {
                  CFStringRef v33 = v32;
                  CFDictionarySetValue(v31, v32, path);
                  CFRelease(v33);
                }
              }
            }
            CFDictionaryRef theDict = v31;
            CGPathRelease(path);
          }
        }
        v13 += (v16 + 1) & 0xFFFFFFFE;
        CFStringRef v5 = v51;
      }
      unint64_t v6 = v13;
      if (v13 + 12 >= a3) {
        goto LABEL_64;
      }
    }
    if (cf) {
      CFRelease(cf);
    }
    int v41 = 247;
    if (!v5) {
      goto LABEL_72;
    }
LABEL_71:
    CFRelease(v5);
LABEL_72:
    LogError("ReadPhotoshopImageResource", v41, "*** ERROR: parsing 8BIM header, exceeds buffer length.\n");
    return;
  }
  CFDictionaryRef theDict = 0;
  CFStringRef v5 = 0;
  CFStringRef cf = 0;
LABEL_64:
  CGImageMetadataMerge(a1, (uint64_t)cf, 0);
  CFDictionaryRef v37 = theDict;
  if (theDict && v5)
  {
    CFArrayRef Value = CFDictionaryGetValue(theDict, v5);
    CGImageMetadataTagRef v39 = CGImageMetadataTagCreate(@"http://ns.apple.com/ImageIO/1.0/", @"iio", @"PSIRClippingPath", kCGImageMetadataTypeString, Value);
    if (v39)
    {
      CGImageMetadataTagRef v40 = v39;
      CGImageMetadataAddTag(a1, v39);
      CFRelease(v40);
    }
    goto LABEL_79;
  }
LABEL_78:
  if (v5) {
LABEL_79:
  }
    CFRelease(v5);
  if (v37) {
    CFRelease(v37);
  }
  if (cf) {
    CFRelease(cf);
  }
}

uint64_t PNGReadPlugin::copyImageBlockSetInterlaced(uint64_t a1)
{
  unint64_t v39 = 0;
  CGImageProviderSetProperty();
  uint64_t v3 = *(unsigned int *)(a1 + 112);
  IIOReadPlugin::allocateBlockArray((IIOReadPlugin *)a1, *(unsigned int *)(a1 + 104));
  if (IIOReadPlugin::getCachedBlocks((IIOReadPlugin *)a1, v4, v5, v6))
  {
    unint64_t v8 = *(IIOImageRead ***)(a1 + 24);
    if (v8) {
      BOOL v33 = IIOImageReadSession::mapData(v8);
    }
    else {
      BOOL v33 = 0;
    }
    unint64_t v9 = *(unsigned int *)(a1 + 112);
    if (v9 < *(_DWORD *)(a1 + 116))
    {
      uint64_t v10 = -8 * v3;
      uint64_t v11 = -v3;
      uint64_t v12 = (CGRect *)MEMORY[0x1E4F1DB20];
      do
      {
        if (*(void *)(*(void *)(a1 + 96) + v10 + 8 * v9)) {
          _cg_jpeg_mem_term("copyImageBlockSetInterlaced", 3299, "*** _blockArray[%d] was cached - and already allocated\n", v11 + v9);
        }
        uint64_t v13 = *(unsigned int *)(a1 + 296);
        double v14 = (double)(v9 * v13);
        LODWORD(v1) = *(_DWORD *)(a1 + 292);
        LODWORD(v7) = *(_DWORD *)(a1 + 232);
        double v15 = (double)v7;
        double v16 = (double)v13 + v14 <= v15 ? (double)v13 : v15 - v14;
        memory_object_size_t v17 = *(unsigned int *)(a1 + 300) * (unint64_t)v13;
        uint64_t v18 = (unsigned __int8 *)_ImageIO_Malloc(v17, *(void *)(a1 + 384), &v39, (uint64_t)kImageMalloc_PNG_Data[0], *(_DWORD *)(a1 + 432), 0, 0);
        if (!v18) {
          break;
        }
        int64_t v19 = v18;
        double v1 = (double)*(unint64_t *)&v1;
        bzero(v18, v17);
        uint64_t v20 = *(unsigned int *)(a1 + 300);
        v36[0] = v9;
        v36[1] = 0;
        *(double *)&v36[2] = v14;
        *(double *)&_OWORD v36[3] = v1;
        *(double *)&v36[4] = v16;
        void v36[5] = v19;
        v36[6] = v20;
        v36[7] = v17;
        long long v37 = 0u;
        uint64_t v38 = 0;
        uint64_t v35 = 0;
        long long v34 = 0u;
        std::vector<IIODecodeFrameParams>::vector(&v34, 1uLL, (uint64_t)v36);
        uint64_t v21 = (IIOImageRead *)IIO_Reader::testHeaderSize(*(IIO_Reader **)(a1 + 24));
        PNGReadPlugin::DecodeUncomposedFrames(v21, 0, a1 + 184, (unsigned char *)(a1 + 440), (uint64_t **)&v34);
        uint64_t v22 = *(void *)(v34 + 64);
        if (!v22)
        {
          int v29 = *(_DWORD *)(a1 + 104);
          if (v29) {
            *(_DWORD *)(a1 + 104) = v29 - 1;
          }
          _ImageIO_Free((unint64_t)v19, v39);
          uint64_t v30 = *(void *)(a1 + 16);
          if (v30) {
            IIOImagePlus::setStatus(v30, (CGImageSourceStatus)-6);
          }
          v40[0] = (void **)&v34;
          std::vector<IIODecodeFrameParams>::__destroy_vector::operator()[abi:ne180100](v40);
          IIODecodeFrameParams::~IIODecodeFrameParams((IIODecodeFrameParams *)v36);
          break;
        }
        PNGReadPlugin::postProcess((PNGReadPlugin *)a1, v19);
        if (*(unsigned char *)(a1 + 343)) {
          BOOL v23 = v22 >= *(unsigned int *)(a1 + 232);
        }
        else {
          BOOL v23 = 0;
        }
        v41.origin.double x = 0.0;
        v41.origin.double y = v14;
        v41.size.double width = v1;
        v41.size.double height = v16;
        *(void *)(*(void *)(a1 + 96) + v10 + 8 * v9) = IIOReadPlugin::createImageBlock((IIOReadPlugin *)a1, v19, v39, v41, *(unsigned int *)(a1 + 300), v23);
        BOOL v24 = CGRectEqualToRect(*(CGRect *)(a1 + 120), *v12);
        uint64_t v25 = 0;
        if (!v24)
        {
          v42.origin.double x = 0.0;
          v42.origin.double y = v14;
          v42.size.double width = v1;
          v42.size.double height = v16;
          *(CGRect *)&uint64_t v25 = CGRectUnion(*(CGRect *)(a1 + 120), v42);
          double v14 = v26;
          double v1 = v27;
          double v16 = v28;
        }
        *(void *)(a1 + 120) = v25;
        *(double *)(a1 + 128) = v14;
        *(double *)(a1 + 136) = v1;
        *(double *)(a1 + 144) = v16;
        v40[0] = (void **)&v34;
        std::vector<IIODecodeFrameParams>::__destroy_vector::operator()[abi:ne180100](v40);
        IIODecodeFrameParams::~IIODecodeFrameParams((IIODecodeFrameParams *)v36);
        ++v9;
      }
      while (v9 < *(unsigned int *)(a1 + 116));
    }
    if (v33)
    {
      uint64_t v31 = *(const char ***)(a1 + 24);
      if (v31) {
        IIOImageReadSession::unmapData(v31);
      }
    }
  }
  if (*(unsigned char *)(a1 + 181))
  {
    ImageIOLog("<<< copyImageBlockSetInterlaced - PNG  [%p]\n", 0);
    ImageIOLog("===================================================================================================\n");
  }
  return 0;
}

void sub_1885F73C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va1, a4);
  va_start(va, a4);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  *(void *)(v4 - 128) = va;
  std::vector<IIODecodeFrameParams>::__destroy_vector::operator()[abi:ne180100]((void ***)(v4 - 128));
  IIODecodeFrameParams::~IIODecodeFrameParams((IIODecodeFrameParams *)va1);
  _Unwind_Resume(a1);
}

CFArrayRef CGImageMetadataCopyTags(CGImageMetadataRef metadata)
{
  IIOInitDebugFlags();
  if ((~gIIODebugFlags & 0x3000) == 0) {
    ImageIODebugOptions(3, "A", "CGImageMetadataCopyTags", 0, 0, -1, 0);
  }
  if (!metadata) {
    goto LABEL_10;
  }
  CFTypeID v2 = CFGetTypeID(metadata);
  if (CGImageMetadataGetTypeID::once != -1) {
    dispatch_once(&CGImageMetadataGetTypeID::once, &__block_literal_global_21);
  }
  if (v2 != CGImageMetadataGetTypeID::id)
  {
LABEL_10:
    LogMetadata("CGImageMetadataCopyTags", 552, "metadata is NULL or not a CGImageMetadataRef");
    return 0;
  }
  CFIndex Count = CFDictionaryGetCount(*((CFDictionaryRef *)metadata + 3));
  uint64_t v4 = (const void **)malloc_type_calloc(8uLL, Count, 0x911B64C4uLL);
  double v5 = (const void **)malloc_type_calloc(8uLL, Count, 0x7E0FFA52uLL);
  uint64_t v6 = v5;
  if (v4 && v5)
  {
    CFDictionaryGetKeysAndValues(*((CFDictionaryRef *)metadata + 3), v4, v5);
    CFArrayRef v7 = CFArrayCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v6, Count, MEMORY[0x1E4F1D510]);
  }
  else
  {
    CFArrayRef v7 = 0;
    CFArrayRef v8 = 0;
    if (!v4) {
      goto LABEL_13;
    }
  }
  free(v4);
  CFArrayRef v8 = v7;
LABEL_13:
  if (v6) {
    free(v6);
  }
  return v8;
}

uint64_t png_colorspace_check_xy(int *a1, int *a2)
{
  int v2 = *a2;
  if (*a2 > 0x186A0) {
    return 1;
  }
  int v5 = a2[1];
  uint64_t result = 1;
  if ((v5 & 0x80000000) == 0 && v5 <= 100000 - v2)
  {
    unsigned int v6 = a2[2];
    if (v6 <= 0x186A0)
    {
      signed int v7 = a2[3];
      if ((v7 & 0x80000000) == 0 && v7 <= (int)(100000 - v6))
      {
        unsigned int v8 = a2[4];
        if (v8 <= 0x186A0)
        {
          signed int v9 = a2[5];
          if ((v9 & 0x80000000) == 0 && v9 <= (int)(100000 - v8))
          {
            unsigned int v10 = a2[6];
            if (v10 <= 0x186A0)
            {
              int v11 = a2[7];
              if (v11 >= 5 && v11 <= (int)(100000 - v10))
              {
                int v12 = 0;
                int v13 = v5 - v9;
                int v14 = v6 - v8;
                if (v6 != v8 && v5 != v9)
                {
                  double v15 = floor((double)v14 * (double)v13 / 7.0 + 0.5);
                  if (v15 > 2147483650.0 || v15 < -2147483650.0) {
                    return 2;
                  }
                  int v12 = (int)v15;
                }
                int v17 = 0;
                int v18 = v7 - v9;
                int v19 = v2 - v8;
                if (v2 != v8 && v7 != v9)
                {
                  double v20 = floor((double)v19 * (double)v18 / 7.0 + 0.5);
                  if (v20 > 2147483650.0 || v20 < -2147483650.0) {
                    return 2;
                  }
                  int v17 = (int)v20;
                }
                int v22 = 0;
                int v23 = v11 - v9;
                if (v6 != v8 && v11 != v9)
                {
                  double v24 = floor((double)v14 * (double)v23 / 7.0 + 0.5);
                  if (v24 > 2147483650.0 || v24 < -2147483650.0) {
                    return 2;
                  }
                  int v22 = (int)v24;
                }
                int v26 = 0;
                int v27 = v10 - v8;
                if (v7 != v9 && v10 != v8)
                {
                  double v28 = floor((double)v18 * (double)v27 / 7.0 + 0.5);
                  if (v28 > 2147483650.0 || v28 < -2147483650.0) {
                    return 2;
                  }
                  int v26 = (int)v28;
                }
                int v30 = v22 - v26;
                if (v22 == v26) {
                  return 1;
                }
                int v31 = v12 - v17;
                if (v12 == v17)
                {
                  int v32 = 0;
                }
                else
                {
                  double v33 = floor((double)v11 * (double)v31 / (double)v30 + 0.5);
                  if (v33 > 2147483650.0 || v33 < -2147483650.0) {
                    return 1;
                  }
                  int v32 = (int)v33;
                }
                if (v32 <= v11) {
                  return 1;
                }
                int v35 = 0;
                if (v5 != v9 && v10 != v8)
                {
                  double v36 = floor((double)v13 * (double)v27 / 7.0 + 0.5);
                  if (v36 > 2147483650.0 || v36 < -2147483650.0) {
                    return 2;
                  }
                  int v35 = (int)v36;
                }
                int v38 = 0;
                if (v2 == v8 || v11 == v9)
                {
LABEL_67:
                  if (v35 != v38)
                  {
                    if (v12 == v17)
                    {
                      int v41 = 0;
                    }
                    else
                    {
                      double v42 = floor((double)v11 * (double)v31 / (double)(v35 - v38) + 0.5);
                      if (v42 > 2147483650.0 || v42 < -2147483650.0) {
                        return 1;
                      }
                      int v41 = (int)v42;
                    }
                    if (v41 <= v11) {
                      return 1;
                    }
                    double v44 = 1.0e10 / (double)v11 + 0.5;
                    double v45 = floor(v44);
                    BOOL v46 = v45 < -2147483650.0 || v45 > 2147483650.0;
                    unsigned int v47 = vcvtmd_s64_f64(v44);
                    if (v46) {
                      unsigned int v47 = 0;
                    }
                    double v48 = (double)v32;
                    double v49 = 1.0e10 / (double)v32 + 0.5;
                    double v50 = floor(v49);
                    BOOL v51 = v50 < -2147483650.0 || v50 > 2147483650.0;
                    unsigned int v52 = vcvtmd_s64_f64(v49);
                    double v53 = (double)v41;
                    if (v51) {
                      unsigned int v54 = 0;
                    }
                    else {
                      unsigned int v54 = v52;
                    }
                    double v55 = 1.0e10 / v53 + 0.5;
                    double v56 = floor(v55);
                    BOOL v57 = v56 < -2147483650.0 || v56 > 2147483650.0;
                    unsigned int v58 = vcvtmd_s64_f64(v55);
                    if (v57) {
                      unsigned int v58 = 0;
                    }
                    int v59 = v47 - (v54 + v58);
                    if (v59 < 1) {
                      return 1;
                    }
                    if (v2)
                    {
                      double v60 = floor((double)v2 * 100000.0 / v48 + 0.5);
                      if (v60 > 2147483650.0 || v60 < -2147483650.0) {
                        return 1;
                      }
                      int v2 = (int)v60;
                    }
                    *a1 = v2;
                    int v62 = a2[1];
                    if (v62)
                    {
                      double v63 = floor((double)v62 * 100000.0 / v48 + 0.5);
                      if (v63 > 2147483650.0 || v63 < -2147483650.0) {
                        return 1;
                      }
                      int v62 = (int)v63;
                    }
                    a1[1] = v62;
                    int v65 = 100000 - (a2[1] + *a2);
                    if (v65)
                    {
                      double v66 = floor((double)v65 * 100000.0 / v48 + 0.5);
                      if (v66 > 2147483650.0 || v66 < -2147483650.0) {
                        return 1;
                      }
                      int v65 = (int)v66;
                    }
                    a1[2] = v65;
                    int v68 = a2[2];
                    if (v68)
                    {
                      double v69 = floor((double)v68 * 100000.0 / v53 + 0.5);
                      if (v69 > 2147483650.0 || v69 < -2147483650.0) {
                        return 1;
                      }
                      int v68 = (int)v69;
                    }
                    a1[3] = v68;
                    int v71 = a2[3];
                    if (v71)
                    {
                      double v72 = floor((double)v71 * 100000.0 / v53 + 0.5);
                      if (v72 > 2147483650.0 || v72 < -2147483650.0) {
                        return 1;
                      }
                      int v71 = (int)v72;
                    }
                    a1[4] = v71;
                    int v74 = 100000 - (a2[3] + a2[2]);
                    if (v74)
                    {
                      double v75 = floor((double)v74 * 100000.0 / v53 + 0.5);
                      if (v75 > 2147483650.0 || v75 < -2147483650.0) {
                        return 1;
                      }
                      int v74 = (int)v75;
                    }
                    a1[5] = v74;
                    int v77 = a2[4];
                    if (v77)
                    {
                      double v78 = floor((double)v59 * (double)v77 / 100000.0 + 0.5);
                      if (v78 > 2147483650.0 || v78 < -2147483650.0) {
                        return 1;
                      }
                      int v77 = (int)v78;
                    }
                    a1[6] = v77;
                    int v80 = a2[5];
                    if (v80)
                    {
                      double v81 = floor((double)v59 * (double)v80 / 100000.0 + 0.5);
                      if (v81 > 2147483650.0 || v81 < -2147483650.0) {
                        return 1;
                      }
                      int v80 = (int)v81;
                    }
                    a1[7] = v80;
                    int v83 = 100000 - (a2[5] + a2[4]);
                    if (v83)
                    {
                      double v84 = floor((double)v59 * (double)v83 / 100000.0 + 0.5);
                      if (v84 > 2147483650.0 || v84 < -2147483650.0) {
                        return 1;
                      }
                      int v83 = (int)v84;
                    }
                    memset(v87, 0, sizeof(v87));
                    a1[8] = v83;
                    if (!png_xy_from_XYZ((int *)v87, a1)) {
                      return !png_colorspace_endpoints_match(a2, v87, 5);
                    }
                  }
                  return 1;
                }
                double v39 = floor((double)v19 * (double)v23 / 7.0 + 0.5);
                if (v39 <= 2147483650.0 && v39 >= -2147483650.0)
                {
                  int v38 = (int)v39;
                  goto LABEL_67;
                }
                return 2;
              }
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t png_xy_from_XYZ(int *a1, int *a2)
{
  int v2 = *a2;
  int v3 = a2[1] + *a2 + a2[2];
  if (v3)
  {
    if (v2)
    {
      double v4 = floor((double)v2 * 100000.0 / (double)v3 + 0.5);
      if (v4 > 2147483650.0 || v4 < -2147483650.0) {
        return 1;
      }
      int v2 = (int)v4;
    }
    *a1 = v2;
    int v6 = a2[1];
    if (v6)
    {
      double v7 = floor((double)v6 * 100000.0 / (double)v3 + 0.5);
      if (v7 > 2147483650.0 || v7 < -2147483650.0) {
        return 1;
      }
      int v6 = (int)v7;
    }
    a1[1] = v6;
    int v9 = a2[3];
    int v10 = a2[4] + v9 + a2[5];
    if (v10)
    {
      int v12 = *a2;
      int v11 = a2[1];
      if (v9)
      {
        double v13 = floor((double)v9 * 100000.0 / (double)v10 + 0.5);
        if (v13 > 2147483650.0 || v13 < -2147483650.0) {
          return 1;
        }
        int v9 = (int)v13;
      }
      a1[2] = v9;
      int v15 = a2[4];
      if (v15)
      {
        double v16 = floor((double)v15 * 100000.0 / (double)v10 + 0.5);
        if (v16 > 2147483650.0 || v16 < -2147483650.0) {
          return 1;
        }
        int v15 = (int)v16;
      }
      a1[3] = v15;
      int v18 = a2[6];
      int v19 = a2[7] + v18 + a2[8];
      if (v19)
      {
        int v21 = a2[3];
        int v20 = a2[4];
        if (v18)
        {
          double v22 = floor((double)v18 * 100000.0 / (double)v19 + 0.5);
          if (v22 > 2147483650.0 || v22 < -2147483650.0) {
            return 1;
          }
          int v18 = (int)v22;
        }
        a1[4] = v18;
        int v24 = a2[7];
        if (v24)
        {
          double v25 = floor((double)v24 * 100000.0 / (double)v19 + 0.5);
          if (v25 > 2147483650.0 || v25 < -2147483650.0) {
            return 1;
          }
          int v24 = (int)v25;
        }
        a1[5] = v24;
        int v27 = v10 + v3 + v19;
        if (v27)
        {
          int v28 = v21 + v12;
          int v29 = a2[7];
          int v30 = v28 + a2[6];
          if (v30)
          {
            double v31 = floor((double)v30 * 100000.0 / (double)v27 + 0.5);
            if (v31 > 2147483650.0 || v31 < -2147483650.0) {
              return 1;
            }
            int v30 = (int)v31;
          }
          a1[6] = v30;
          int v33 = v20 + v11 + v29;
          if (!v33)
          {
            int v38 = 0;
            goto LABEL_56;
          }
          double v34 = floor((double)v33 * 100000.0 / (double)v27 + 0.5);
          if (v34 <= 2147483650.0 && v34 >= -2147483650.0)
          {
            int v38 = (int)v34;
LABEL_56:
            uint64_t v36 = 0;
            a1[7] = v38;
            return v36;
          }
        }
      }
    }
  }
  return 1;
}

uint64_t png_colorspace_set_chromaticities(void (**a1)(void), uint64_t a2, int *a3, int a4)
{
  int v11 = 0;
  memset(v10, 0, sizeof(v10));
  int v8 = png_colorspace_check_xy((int *)v10, a3);
  if (v8 == 1)
  {
    *(_WORD *)(a2 + 74) |= 0x8000u;
    png_benign_error((uint64_t)a1, "invalid chromaticities");
    return 0;
  }
  else
  {
    if (v8)
    {
      *(_WORD *)(a2 + 74) |= 0x8000u;
      _cg_png_error(a1, "internal error checking chromaticities");
    }
    return png_colorspace_set_xy_and_XYZ((uint64_t)a1, a2, (uint64_t)a3, (uint64_t)v10, a4);
  }
}

uint64_t png_colorspace_set_xy_and_XYZ(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  int v5 = *(__int16 *)(a2 + 74);
  if (v5 < 0) {
    return 0;
  }
  if (a5 > 1 || (v5 & 2) == 0) {
    goto LABEL_6;
  }
  if (!png_colorspace_endpoints_match((int *)a3, (_DWORD *)(a2 + 4), 100))
  {
    *(_WORD *)(a2 + 74) = v5 | 0x8000;
    png_benign_error(a1, "inconsistent chromaticities");
    return 0;
  }
  if (!a5) {
    return 1;
  }
LABEL_6:
  long long v11 = *(_OWORD *)(a3 + 16);
  *(_OWORD *)(a2 + 4) = *(_OWORD *)a3;
  *(_OWORD *)(a2 + 20) = v11;
  long long v12 = *(_OWORD *)(a4 + 16);
  *(_OWORD *)(a2 + 36) = *(_OWORD *)a4;
  *(_OWORD *)(a2 + 52) = v12;
  *(_DWORD *)(a2 + 68) = *(_DWORD *)(a4 + 32);
  BOOL v13 = png_colorspace_endpoints_match((int *)a3, &sRGB_xy, 1000);
  __int16 v14 = v5 & 0xFFBD | 2;
  if (v13) {
    __int16 v14 = v5 | 0x42;
  }
  *(_WORD *)(a2 + 74) = v14;
  return 2;
}

BOOL png_colorspace_endpoints_match(int *a1, _DWORD *a2, int a3)
{
  int v3 = a1[6];
  int v4 = a2[6];
  int v5 = v4 - a3;
  int v6 = v4 + a3;
  if (v3 >= v5)
  {
    BOOL v9 = __OFSUB__(v3, v6);
    BOOL v7 = v3 == v6;
    BOOL v8 = v3 - v6 < 0;
  }
  else
  {
    BOOL v9 = 0;
    BOOL v7 = 0;
    BOOL v8 = 0;
  }
  if (!(v8 ^ v9 | v7)) {
    return 0;
  }
  int v10 = a1[7];
  int v11 = a2[7];
  int v12 = v11 - a3;
  int v13 = v11 + a3;
  if (v10 >= v12)
  {
    BOOL v16 = __OFSUB__(v10, v13);
    BOOL v14 = v10 == v13;
    BOOL v15 = v10 - v13 < 0;
  }
  else
  {
    BOOL v16 = 0;
    BOOL v14 = 0;
    BOOL v15 = 0;
  }
  if (!(v15 ^ v16 | v14)) {
    return 0;
  }
  int v17 = *a1;
  int v18 = *a2 + a3;
  if (*a1 >= *a2 - a3)
  {
    BOOL v21 = __OFSUB__(v17, v18);
    BOOL v19 = v17 == v18;
    BOOL v20 = v17 - v18 < 0;
  }
  else
  {
    BOOL v21 = 0;
    BOOL v19 = 0;
    BOOL v20 = 0;
  }
  if (!(v20 ^ v21 | v19)) {
    return 0;
  }
  uint64_t v22 = 0;
  int v24 = a1[1];
  int v25 = a2[1];
  if (v24 >= v25 - a3 && v24 <= v25 + a3)
  {
    uint64_t v22 = 0;
    int v26 = a1[2];
    int v27 = a2[2];
    if (v26 >= v27 - a3 && v26 <= v27 + a3)
    {
      uint64_t v22 = 0;
      int v28 = a1[3];
      int v29 = a2[3];
      if (v28 >= v29 - a3 && v28 <= v29 + a3)
      {
        uint64_t v22 = 0;
        int v30 = a1[4];
        int v31 = a2[4];
        if (v30 >= v31 - a3 && v30 <= v31 + a3)
        {
          int v32 = a1[5];
          int v33 = a2[5];
          int v34 = v33 - a3;
          int v35 = v33 + a3;
          if (v32 >= v34)
          {
            BOOL v38 = __OFSUB__(v32, v35);
            BOOL v36 = v32 == v35;
            BOOL v37 = v32 - v35 < 0;
          }
          else
          {
            BOOL v38 = 0;
            BOOL v36 = 0;
            BOOL v37 = 0;
          }
          return (v37 ^ v38 | v36) != 0;
        }
      }
    }
  }
  return v22;
}

void IIOTextureHandler::~IIOTextureHandler(IIOTextureHandler *this)
{
  IIOTextureHandler::~IIOTextureHandler(this);

  JUMPOUT(0x18C11C0E0);
}

{
  const void *v2;
  std::__shared_weak_count *v3;

  *(void *)this = &unk_1ED4E4110;
  if (*((void *)this + 5))
  {
    IIOImageReadSession::unmapData(*((const char ***)this + 6));
    CFRelease(*((CFTypeRef *)this + 5));
  }
  *((void *)this + 5) = 0;
  int v2 = (const void *)*((void *)this + 3);
  if (v2) {
    CFRelease(v2);
  }
  *((void *)this + 3) = 0;
  int v3 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v3) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v3);
  }
}

void CGInitializeImageIO()
{
  if ((IIO_XPCServer() & 1) == 0)
  {
    BOOL v0 = getprogname();
    if (strncmp(v0, "ImageIOXPCService", 0x11uLL))
    {
      gWakeupTime = CFAbsoluteTimeGetCurrent();
      if (CGInitializeImageIO::initOnceToken != -1)
      {
        dispatch_once(&CGInitializeImageIO::initOnceToken, &__block_literal_global_35);
      }
    }
  }
}

uint64_t ___ZL25_CFDataCreateWithProviderP14CGDataProvider_block_invoke()
{
  uint64_t result = IOPreferencesGetBoolean("ImageIO_CopyInputData", 0, 0);
  gCopyInputunint64_t Data = result;
  return result;
}

uint64_t __IIOXPCLog_block_invoke()
{
  uint64_t result = IIO_OSAppleInternalBuild();
  if (result) {
    IIOXPCLog::logXPC = (gIIODebugFlags & 0xC0000) != 0;
  }
  return result;
}

uint64_t ___ZN12IIOImageRead14CreateWithDataEPK8__CFDatab_block_invoke()
{
  uint64_t result = IOPreferencesGetBoolean("ImageIO_CopyInputData", 0, 0);
  gCopyInputunint64_t Data = result;
  return result;
}

uint64_t ___ZN12IIOImageRead13CreateWithURLEPK7__CFURLPK10__CFStringPhbbb_block_invoke()
{
  uint64_t result = IOPreferencesGetBoolean("ImageIO_TrustSystemPathURLs", 0, 0);
  IIOImageRead::CreateWithURL(__CFURL const*,__CFString const*,unsigned char *,BOOL,BOOL,BOOL)::useSystemPath = result;
  return result;
}

void ___ZN17IIO_ReaderHandler16GetReaderHandlerEv_block_invoke()
{
}

void sub_1885F83D0(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10A1C40EEBF52FBLL);
  _Unwind_Resume(a1);
}

void IIO_ReaderHandler::IIO_ReaderHandler(IIO_ReaderHandler *this)
{
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((void *)this + 8) = 0;
  *((_DWORD *)this + 18) = 1065353216;
  *(void *)this = &unk_1ED4E4130;
  *((void *)this + 1) = 0;
  *((_DWORD *)this + 20) = 0;
  CFAbsoluteTimeGetCurrent();
  IIO_ReaderHandler::buildPluginList(this);
}

void sub_1885F84C8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  std::__hash_table<std::__hash_value_type<IIO_Reader *,IIO_ReaderHandler::QueuePool>,std::__unordered_map_hasher<IIO_Reader *,std::__hash_value_type<IIO_Reader *,IIO_ReaderHandler::QueuePool>,std::hash<IIO_Reader *>,std::equal_to<IIO_Reader *>,true>,std::__unordered_map_equal<IIO_Reader *,std::__hash_value_type<IIO_Reader *,IIO_ReaderHandler::QueuePool>,std::equal_to<IIO_Reader *>,std::hash<IIO_Reader *>,true>,std::allocator<std::__hash_value_type<IIO_Reader *,IIO_ReaderHandler::QueuePool>>>::~__hash_table(v4 + 40);
  std::vector<std::unique_ptr<IIO_Reader>>::__destroy_vector::operator()[abi:ne180100]((void ***)va);
  _Unwind_Resume(a1);
}

uint64_t IOPreferencesGetBoolean(const char *a1, uint64_t a2, BOOL *a3)
{
  int v6 = getenv(a1);
  if (v6)
  {
    BOOL v7 = v6;
    if (!strcasecmp(v6, "YES")) {
      a2 = 1;
    }
    else {
      a2 = strcasecmp(v7, "NO") && atoi(v7) != 0;
    }
    BOOL v12 = 1;
    goto LABEL_28;
  }
  CFStringRef v8 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a1, 0x600u);
  if (!v8)
  {
    BOOL v12 = 0;
    goto LABEL_28;
  }
  CFStringRef v9 = v8;
  CFStringRef v10 = (const __CFString *)CFPreferencesCopyAppValue(v8, (CFStringRef)*MEMORY[0x1E4F1D3D8]);
  if (!v10)
  {
    CFStringRef v10 = (const __CFString *)CFPreferencesCopyValue(v9, @"com.apple.ImageIO", (CFStringRef)*MEMORY[0x1E4F1D3F0], (CFStringRef)*MEMORY[0x1E4F1D3E0]);
    if (!v10)
    {
      BOOL v12 = 0;
      goto LABEL_27;
    }
  }
  CFTypeID v11 = CFGetTypeID(v10);
  if (v11 != CFBooleanGetTypeID())
  {
    if (v11 == CFNumberGetTypeID())
    {
      if (!CFNumberIsFloatType((CFNumberRef)v10))
      {
        int valuePtr = 0;
        CFNumberGetValue((CFNumberRef)v10, kCFNumberIntType, &valuePtr);
        a2 = valuePtr != 0;
        goto LABEL_10;
      }
    }
    else if (v11 == CFStringGetTypeID())
    {
      BOOL v12 = 1;
      if (CFStringCompare(v10, @"YES", 1uLL))
      {
        BOOL v12 = 1;
        if (CFStringCompare(v10, @"NO", 1uLL))
        {
          BOOL v12 = 1;
          if (CFStringCompare(v10, @"1", 1uLL))
          {
            CFComparisonResult v13 = CFStringCompare(v10, @"0", 1uLL);
            BOOL v12 = v13 == kCFCompareEqualTo;
            if (v13) {
              a2 = a2;
            }
            else {
              a2 = 0;
            }
          }
          else
          {
            a2 = 1;
          }
        }
        else
        {
          a2 = 0;
        }
      }
      else
      {
        a2 = 1;
      }
      goto LABEL_26;
    }
    BOOL v12 = 0;
    goto LABEL_26;
  }
  a2 = v10 == (const __CFString *)*MEMORY[0x1E4F1CFD0];
LABEL_10:
  BOOL v12 = 1;
LABEL_26:
  CFRelease(v10);
LABEL_27:
  CFRelease(v9);
LABEL_28:
  if (a3) {
    *a3 = v12;
  }
  return a2;
}

uint64_t ImageIOLogInternal(const char *a1, ...)
{
  va_start(va, a1);
  uint64_t result = IIO_OSAppleInternalBuild();
  if (result)
  {
    if (gImageIOLogProc) {
      return gImageIOLogProc(0, 0, 0, 0, a1, va);
    }
  }
  return result;
}

uint64_t IIO_OSAppleInternalBuild()
{
  if (IIO_OSAppleInternalBuild::predicate != -1) {
    dispatch_once(&IIO_OSAppleInternalBuild::predicate, &__block_literal_global_29_1);
  }
  return IIO_OSAppleInternalBuild::is_internal;
}

void ImageIOLogger(int a1, const char *a2, const char *a3, int a4, const char *a5, va_list a6)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  if (ImageIOLogger(int,char const*,char const*,int,char const*,char *)::once != -1) {
    dispatch_once(&ImageIOLogger(int,char const*,char const*,int,char const*,char *)::once, &__block_literal_global_28);
  }
  int v17 = 0;
  int v18 = 0;
  if (a3)
  {
    asprintf(&v18, "%s%s:%d: %s");
  }
  else if (a2)
  {
    asprintf(&v18, "%s: %s");
  }
  else
  {
    asprintf(&v18, "%s");
  }
  vasprintf(&v17, v18, a6);
  if (a1 <= 1)
  {
    if (a1)
    {
      if (a1 != 1) {
        goto LABEL_25;
      }
      uint64_t v11 = gIIO_Log;
      if (!os_log_type_enabled((os_log_t)gIIO_Log, OS_LOG_TYPE_INFO)) {
        goto LABEL_25;
      }
      *(_DWORD *)buf = 136446210;
      BOOL v20 = v17;
      BOOL v12 = v11;
      os_log_type_t v13 = OS_LOG_TYPE_INFO;
    }
    else
    {
      uint64_t v16 = gIIO_Log;
      if (!os_log_type_enabled((os_log_t)gIIO_Log, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_25;
      }
      *(_DWORD *)buf = 136446210;
      BOOL v20 = v17;
      BOOL v12 = v16;
      os_log_type_t v13 = OS_LOG_TYPE_DEFAULT;
    }
    _os_log_impl(&dword_188589000, v12, v13, "%{public}s\n", buf, 0xCu);
    goto LABEL_25;
  }
  switch(a1)
  {
    case 2:
      BOOL v14 = gIIO_Log;
      if (os_log_type_enabled((os_log_t)gIIO_Log, OS_LOG_TYPE_DEBUG)) {
        ImageIOLogger((uint64_t *)&v17, v14);
      }
      break;
    case 16:
      BOOL v15 = gIIO_Log;
      if (os_log_type_enabled((os_log_t)gIIO_Log, OS_LOG_TYPE_ERROR)) {
        ImageIOLogger((uint64_t *)&v17, v15);
      }
      break;
    case 17:
      CFStringRef v10 = gIIO_Log;
      if (os_log_type_enabled((os_log_t)gIIO_Log, OS_LOG_TYPE_FAULT)) {
        ImageIOLogger((uint64_t *)&v17, v10);
      }
      break;
  }
LABEL_25:
  free(v17);
  free(v18);
}

uint64_t IIOLockDownModeEnabled()
{
  if (IIOLockDownModeEnabled::once != -1) {
    dispatch_once(&IIOLockDownModeEnabled::once, &__block_literal_global_21);
  }
  return IIOLockDownModeEnabled::lockDownModeEnabled;
}

uint64_t IIOGetBundleIdentifer()
{
  if (IIOGetBundleIdentifer::onceToken != -1) {
    dispatch_once(&IIOGetBundleIdentifer::onceToken, &__block_literal_global_23);
  }
  return IIOGetBundleIdentifer::gBundleIdentifer;
}

void ImageIOLogger(uint64_t *a1, NSObject *a2)
{
  uint64_t v5 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *a1;
  int v3 = 136446210;
  uint64_t v4 = v2;
  _os_log_error_impl(&dword_188589000, a2, OS_LOG_TYPE_ERROR, "%{public}s\n", (uint8_t *)&v3, 0xCu);
}

{
  uint64_t v2;
  int v3;
  uint64_t v4;
  uint64_t v5;

  uint64_t v5 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *a1;
  int v3 = 136446210;
  uint64_t v4 = v2;
  _os_log_debug_impl(&dword_188589000, a2, OS_LOG_TYPE_DEBUG, "%{public}s\n", (uint8_t *)&v3, 0xCu);
}

{
  uint64_t v2;
  int v3;
  uint64_t v4;
  uint64_t v5;

  uint64_t v5 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *a1;
  int v3 = 136446210;
  uint64_t v4 = v2;
  _os_log_fault_impl(&dword_188589000, a2, OS_LOG_TYPE_FAULT, "%{public}s\n", (uint8_t *)&v3, 0xCu);
}

uint64_t IIO_ReaderHandler::setAllowableTypes(uint64_t **this, const __CFArray *a2)
{
  memset(v21, 0, sizeof(v21));
  int v3 = IIOArray::IIOArray((IIOArray *)v21, a2);
  IIOArray::getCount(v3);
  kdebug_trace();
  uint64_t v17 = 0;
  int v18 = &v17;
  uint64_t v19 = 0x2000000000;
  int v20 = 0;
  if (IIOArray::getCount((IIOArray *)v21))
  {
    uint64_t v4 = IIO_ReaderHandler::copyTypeIdentifiers((IIO_ReaderHandler *)this);
    int Count = CFArrayGetCount(v4);
    v16[0] = MEMORY[0x1E4F143A8];
    v16[1] = 0x40000000;
    void v16[2] = ___ZN17IIO_ReaderHandler17setAllowableTypesEPK9__CFArray_block_invoke;
    void v16[3] = &unk_1E53CBBD8;
    v16[4] = &v17;
    v16[5] = v4;
    IIOArray::enumerate((uint64_t)v21, (uint64_t)v16);
    CFRelease(v4);
    int v6 = Count;
  }
  else
  {
    LogWarning("setAllowableTypes", 1214, "*** 'CGImageSourceSetAllowableTypes' -> disabling all image decoding\n");
    int v6 = 0;
  }
  BOOL v7 = this[2];
  if (this[3] == v7)
  {
    uint64_t v8 = 0;
    if (!v6) {
      goto LABEL_18;
    }
LABEL_17:
    _cg_jpeg_mem_term("setAllowableTypes", 1251, "*** 'CGImageSourceSetAllowableTypes' - original: %d  new: %d (removed %d)\n", v6, *((_DWORD *)v18 + 6), v6 - *((_DWORD *)v18 + 6));
    goto LABEL_18;
  }
  uint64_t v8 = 4294967230;
  do
  {
    CFStringRef v9 = (const void *)IIO_Reader::utType((IIO_Reader *)*v7);
    if (IIOArray::containsValue((IIOArray *)v21, v9))
    {
      ++v7;
      CFStringRef v10 = this[3];
    }
    else
    {
      std::__unwrap_and_dispatch[abi:ne180100]<std::__overload<std::__move_loop<std::_ClassicAlgPolicy>,std::__move_trivial>,std::unique_ptr<IIO_Reader> *,std::unique_ptr<IIO_Reader> *,std::unique_ptr<IIO_Reader> *,0>(v7 + 1, this[3], v7);
      CFStringRef v10 = v11;
      BOOL v12 = this[3];
      while (v12 != v10)
      {
        uint64_t v14 = *--v12;
        uint64_t v13 = v14;
        *BOOL v12 = 0;
        if (v14) {
          (*(void (**)(uint64_t))(*(void *)v13 + 8))(v13);
        }
      }
      uint64_t v8 = 0;
      this[3] = v10;
    }
  }
  while (v7 != v10);
  if (v6) {
    goto LABEL_17;
  }
LABEL_18:
  kdebug_trace();
  _Block_object_dispose(&v17, 8);
  IIOArray::~IIOArray((IIOArray *)v21);
  return v8;
}

void sub_1885F8D58(_Unwind_Exception *a1)
{
  IIOArray::~IIOArray((IIOArray *)(v1 - 72));
  _Unwind_Resume(a1);
}

const __CFArray *IIOArray::containsValue(IIOArray *this, const void *a2)
{
  CFArrayRef result = (const __CFArray *)*((void *)this + 1);
  if (result)
  {
    v5.CFIndex length = CFArrayGetCount(result);
    v5.location = 0;
    return (const __CFArray *)(CFArrayContainsValue(*((CFArrayRef *)this + 1), v5, a2) != 0);
  }
  return result;
}

uint64_t *std::__unwrap_and_dispatch[abi:ne180100]<std::__overload<std::__move_loop<std::_ClassicAlgPolicy>,std::__move_trivial>,std::unique_ptr<IIO_Reader> *,std::unique_ptr<IIO_Reader> *,std::unique_ptr<IIO_Reader> *,0>(uint64_t *a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t v4 = a1;
  if (a1 != a2)
  {
    do
    {
      uint64_t v6 = *v4;
      uint64_t *v4 = 0;
      uint64_t v7 = *a3;
      *a3 = v6;
      if (v7) {
        (*(void (**)(uint64_t))(*(void *)v7 + 8))(v7);
      }
      ++v4;
      ++a3;
    }
    while (v4 != a2);
    return a2;
  }
  return v4;
}

void IIOReader_RawCamera::~IIOReader_RawCamera(IIOReader_RawCamera *this, uint64_t a2, const char *a3)
{
  _cg_jpeg_mem_term(this, a2, a3);

  JUMPOUT(0x18C11C0E0);
}

uint64_t IIOArray::enumerate(uint64_t a1, uint64_t a2)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return IIOArrayEnumerateUsingBlock(result, a2);
  }
  return result;
}

uint64_t HEIFMainImage::HEIFMainImage(uint64_t a1, uint64_t a2, int a3, __CFDictionary *a4, uint64_t a5, const __CFDictionary *a6, int a7)
{
  *(void *)a1 = &unk_1ED4DFC10;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 104) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_OWORD *)(a1 + 120) = 0u;
  *(_OWORD *)(a1 + 136) = 0u;
  memset(v49, 0, sizeof(v49));
  uint64_t v11 = IIODictionary::IIODictionary((IIODictionary *)v49, a4);
  *(_OWORD *)(a1 + 160) = 0u;
  BOOL v12 = (unsigned int *)(a1 + 160);
  *(_OWORD *)(a1 + 272) = 0u;
  *(_OWORD *)(a1 + 288) = 0u;
  *(_OWORD *)(a1 + 240) = 0u;
  *(_OWORD *)(a1 + 256) = 0u;
  *(_OWORD *)(a1 + 208) = 0u;
  *(_OWORD *)(a1 + 224) = 0u;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_DWORD *)(a1 + 160) = a3;
  *(_DWORD *)(a1 + 172) = 8;
  if (a6)
  {
    CFTypeRef value = 0;
    CFDictionaryGetValueIfPresent(a6, *(const void **)gIIO_kCMPhotoDecompressionContainerDescription_MainImages, (const void **)&value);
    if (value && CFArrayGetCount((CFArrayRef)value))
    {
      ValueAtIndedouble x = (const __CFDictionary *)CFArrayGetValueAtIndex((CFArrayRef)value, 0);
      long long v46 = 0uLL;
      uint64_t v47 = 0;
      IIODictionary::IIODictionary((IIODictionary *)&v46, ValueAtIndex);
      *(_DWORD *)(a1 + 164) = IIODictionary::getUint32ForKeyGroup((IIODictionary *)&v46, @"Width", *(const __CFString **)gIIO_kCMPhotoDecompressionContainerDescription_Dimensions);
      *(_DWORD *)(a1 + 168) = IIODictionary::getUint32ForKeyGroup((IIODictionary *)&v46, @"Height", *(const __CFString **)gIIO_kCMPhotoDecompressionContainerDescription_Dimensions);
      IIODictionary::~IIODictionary((IIODictionary *)&v46);
    }
  }
  else
  {
    *(_DWORD *)(a1 + 164) = IIODictionary::getUint32ForKeyGroup(v11, @"Width", *(const __CFString **)gIIO_kCMPhotoDecompressionContainerDescription_Dimensions);
    *(_DWORD *)(a1 + 168) = IIODictionary::getUint32ForKeyGroup((IIODictionary *)v49, @"Height", *(const __CFString **)gIIO_kCMPhotoDecompressionContainerDescription_Dimensions);
    if (IIODictionary::containsKey((IIODictionary *)v49, *(const __CFString **)gIIO_kCMPhotoDecompressionContainerDescription_BitDepth))
    {
      CFDictionaryRef ObjectForKey = IIODictionary::getObjectForKey((IIODictionary *)v49, *(const __CFString **)gIIO_kCMPhotoDecompressionContainerDescription_BitDepth);
      long long v46 = 0uLL;
      uint64_t v47 = 0;
      IIOArray::IIOArray((IIOArray *)&v46, ObjectForKey);
      if (IIOArray::getCount((IIOArray *)&v46)) {
        *(_DWORD *)(a1 + 172) = IIOArray::getUint32AtIndex((IIOArray *)&v46, 0);
      }
      IIOArray::~IIOArray((IIOArray *)&v46);
    }
  }
  *(_DWORD *)(a1 + 200) = IIODictionary::getUint32ForKey((IIODictionary *)v49, *(const __CFString **)gIIO_kCMPhotoDecompressionContainerDescription_ItemID);
  *(_DWORD *)(a1 + 180) = IIODictionary::getUint32ForKey((IIODictionary *)v49, *(const __CFString **)gIIO_kCMPhotoDecompressionContainerDescription_DataLength);
  *(_DWORD *)(a1 + 184) = IIODictionary::getUint32ForKey((IIODictionary *)v49, *(const __CFString **)gIIO_kCMPhotoDecompressionContainerDescription_DataOffset);
  *(_DWORD *)(a1 + 196) = a7;
  if ((a7 & 0x80000000) == 0)
  {
    *(unsigned char *)(a1 + 280) = IIODictionary::getBoolForKey((IIODictionary *)v49, *(const __CFString **)gIIO_kCMPhotoDecompressionContainerDescription_SequenceSampleDependsOnOthers);
    CFDictionaryRef v15 = IIODictionary::getObjectForKey((IIODictionary *)v49, *(const __CFString **)gIIO_kCMPhotoDecompressionContainerDescription_SequenceSampleDuration);
    long long v46 = 0uLL;
    uint64_t v47 = 0;
    gFunc_CMTimeMakeFromDictionary(&v46, v15);
    long long v44 = v46;
    uint64_t v45 = v47;
    *(double *)(a1 + 272) = gFunc_CMTimeGetSeconds(&v44);
  }
  *(void *)(a1 + 296) = 0;
  CFDictionaryRef v16 = IIODictionary::getObjectForKey((IIODictionary *)v49, *(const __CFString **)gIIO_kCMPhotoDecompressionContainerDescription_NamedColorSpace);
  *(void *)(a1 + 288) = v16;
  if (v16)
  {
    CFTypeRef v17 = CFRetain(v16);
LABEL_13:
    *(void *)(a1 + 288) = v17;
    goto LABEL_14;
  }
  BOOL v37 = IIODictionary::getObjectForKey((IIODictionary *)v49, *(const __CFString **)gIIO_kCMPhotoDecompressionContainerDescription_ColorSpace);
  BOOL v38 = v37;
  if (!v37)
  {
    CFTypeRef v17 = CFRetain((CFTypeRef)*MEMORY[0x1E4F1DC98]);
    goto LABEL_13;
  }
  CFStringRef v39 = CGColorSpaceCopyName(v37);
  *(void *)(a1 + 288) = v39;
  if (!v39) {
    *(void *)(a1 + 296) = CGColorSpaceRetain(v38);
  }
LABEL_14:
  *(_DWORD *)(a1 + 188) = 0;
  *(_DWORD *)(a1 + 192) = 0;
  if (IIODictionary::containsKey((IIODictionary *)v49, *(const __CFString **)gIIO_kCMPhotoDecompressionContainerDescription_TileDimensions))
  {
    *(_DWORD *)(a1 + 188) = IIODictionary::getUint32ForKeyGroup((IIODictionary *)v49, @"Width", *(const __CFString **)gIIO_kCMPhotoDecompressionContainerDescription_TileDimensions);
    *(_DWORD *)(a1 + 192) = IIODictionary::getUint32ForKeyGroup((IIODictionary *)v49, @"Height", *(const __CFString **)gIIO_kCMPhotoDecompressionContainerDescription_TileDimensions);
  }
  if (IIODictionary::containsKey((IIODictionary *)v49, *(const __CFString **)gIIO_kCMPhotoDecompressionContainerDescription_ThumbnailImages))
  {
    CFDictionaryRef v18 = IIODictionary::getObjectForKey((IIODictionary *)v49, *(const __CFString **)gIIO_kCMPhotoDecompressionContainerDescription_ThumbnailImages);
    CFArrayRef v19 = v18;
    if (v18)
    {
      CFIndex Count = CFArrayGetCount(v18);
      if (Count >= 1)
      {
        for (CFIndex i = 0; i != Count; ++i)
        {
          if (CFArrayGetValueAtIndex(v19, i)) {
            operator new();
          }
        }
      }
    }
  }
  if (IIODictionary::containsKey((IIODictionary *)v49, *(const __CFString **)gIIO_kCMPhotoDecompressionContainerDescription_AuxiliaryImages))
  {
    CFDictionaryRef v22 = IIODictionary::getObjectForKey((IIODictionary *)v49, *(const __CFString **)gIIO_kCMPhotoDecompressionContainerDescription_AuxiliaryImages);
    CFArrayRef v23 = v22;
    if (v22)
    {
      CFIndex v24 = CFArrayGetCount(v22);
      if (v24 >= 1)
      {
        for (CFIndex j = 0; j != v24; ++j)
        {
          if (CFArrayGetValueAtIndex(v23, j)) {
            operator new();
          }
        }
      }
    }
  }
  if (IIODictionary::containsKey((IIODictionary *)v49, *(const __CFString **)gIIO_kCMPhotoDecompressionContainerDescription_CustomMetadataPayloads))
  {
    CFDictionaryRef v26 = IIODictionary::getObjectForKey((IIODictionary *)v49, *(const __CFString **)gIIO_kCMPhotoDecompressionContainerDescription_CustomMetadataPayloads);
    CFArrayRef v27 = v26;
    if (v26)
    {
      CFIndex v28 = CFArrayGetCount(v26);
      if (v28 >= 1)
      {
        for (CFIndex k = 0; k != v28; ++k)
        {
          if (CFArrayGetValueAtIndex(v27, k)) {
            operator new();
          }
        }
      }
    }
  }
  if (IIODictionary::containsKey((IIODictionary *)v49, *(const __CFString **)gIIO_kCMPhotoDecompressionContainerDescription_AlternateImages))
  {
    CFDictionaryRef v30 = IIODictionary::getObjectForKey((IIODictionary *)v49, *(const __CFString **)gIIO_kCMPhotoDecompressionContainerDescription_AlternateImages);
    CFArrayRef v31 = v30;
    if (v30)
    {
      CFIndex v32 = CFArrayGetCount(v30);
      if (v32 >= 1)
      {
        for (CFIndex m = 0; m != v32; ++m)
        {
          CFDictionaryRef v34 = (const __CFDictionary *)CFArrayGetValueAtIndex(v31, m);
          long long v46 = 0uLL;
          uint64_t v47 = 0;
          IIODictionary::IIODictionary((IIODictionary *)&v46, v34);
          unsigned int Uint32ForKey = IIODictionary::getUint32ForKey((IIODictionary *)&v46, *(const __CFString **)gIIO_kCMPhotoDecompressionContainerDescription_ItemType);
          if (!Uint32ForKey) {
            unsigned int Uint32ForKey = IIODictionary::getUint32ForKey((IIODictionary *)&v46, *(const __CFString **)gIIO_kCMPhotoDecompressionContainerDescription_CodecType);
          }
          if (Uint32ForKey == 1953325424) {
            operator new();
          }
          IIODictionary::~IIODictionary((IIODictionary *)&v46);
        }
      }
    }
  }
  *(void *)&long long v46 = 0;
  if (gFunc_CMPhotoDecompressionContainerGetExifCountForIndexWithOptions(a2, *v12, 0, &v46)) {
    BOOL v36 = 1;
  }
  else {
    BOOL v36 = (uint64_t)v46 < 1;
  }
  if (!v36) {
    operator new();
  }
  if (a5) {
    operator new();
  }
  CFTypeRef value = 0;
  if (gFunc_CMPhotoDecompressionContainerGetXMPCountForIndexWithOptions(a2, *v12, 0, &value)) {
    BOOL v40 = 1;
  }
  else {
    BOOL v40 = (uint64_t)value < 1;
  }
  if (!v40) {
    operator new();
  }
  HEIFMainImage::extractISO5Metadata((HEIFMainImage *)a1, (IIODictionary *)v49);
  IIODictionary::~IIODictionary((IIODictionary *)v49);
  return a1;
}

void sub_1885F9BE8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void **a10, uint64_t a11, uint64_t a12, void **a13, void **a14, void **a15, void **a16)
{
  IIODictionary::~IIODictionary((IIODictionary *)(v18 - 104));
  int v20 = *a10;
  if (*a10)
  {
    v16[17] = v20;
    operator delete(v20);
  }
  uint64_t v21 = *v17;
  if (*v17)
  {
    v16[14] = v21;
    operator delete(v21);
  }
  CFDictionaryRef v22 = *a16;
  if (*a16)
  {
    v16[11] = v22;
    operator delete(v22);
  }
  CFArrayRef v23 = *a13;
  if (*a13)
  {
    v16[8] = v23;
    operator delete(v23);
  }
  CFIndex v24 = *a15;
  if (*a15)
  {
    v16[5] = v24;
    operator delete(v24);
  }
  int v25 = *a14;
  if (*a14)
  {
    void v16[2] = v25;
    operator delete(v25);
  }
  _Unwind_Resume(a1);
}

void IIOArray::IIOArray(IIOArray *this, CFTypeRef cf)
{
  *(void *)this = &unk_1ED4E5BB8;
  if (cf)
  {
    CFTypeID v4 = CFGetTypeID(cf);
    if (v4 == CFArrayGetTypeID())
    {
      CFTypeRef v5 = CFRetain(cf);
      char v6 = 0;
      *((void *)this + 1) = v5;
    }
    else
    {
      IIOLogTypeMismatch(cf, "IIOArray", "CFArrayRef");
      char v6 = 0;
      *((void *)this + 1) = 0;
    }
  }
  else
  {
    *((void *)this + 1) = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
    char v6 = 1;
  }
  *((unsigned char *)this + 16) = v6;
}

{
  CFTypeID v4;
  void *Mutable;
  char v6;

  *(void *)this = &unk_1ED4E5BB8;
  if (cf)
  {
    CFTypeID v4 = CFGetTypeID(cf);
    if (v4 != CFArrayGetTypeID())
    {
      IIOLogTypeMismatch(cf, "IIOArray", "CFArrayRef");
      char v6 = 0;
      *((void *)this + 1) = 0;
      goto LABEL_7;
    }
    CGMutableImageMetadataRef Mutable = (void *)CFRetain(cf);
  }
  else
  {
    CGMutableImageMetadataRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
  }
  *((void *)this + 1) = Mutable;
  char v6 = 1;
LABEL_7:
  *((unsigned char *)this + 16) = v6;
}

const __CFArray *IIOArray::getCount(IIOArray *this)
{
  CFArrayRef result = (const __CFArray *)*((void *)this + 1);
  if (result) {
    return (const __CFArray *)CFArrayGetCount(result);
  }
  return result;
}

uint64_t IIOArray::getUint32AtIndex(IIOArray *this, CFIndex a2)
{
  CFArrayRef v2 = (const __CFArray *)*((void *)this + 1);
  if (!v2) {
    return 0;
  }
  ValueAtIndedouble x = CFArrayGetValueAtIndex(v2, a2);
  IIONumber::IIONumber((IIONumber *)v6, ValueAtIndex);
  uint64_t v4 = IIONumber::uint32Num((IIONumber *)v6);
  IIONumber::~IIONumber((IIONumber *)v6);
  return v4;
}

void sub_1885F9EE4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  IIONumber::~IIONumber((IIONumber *)va);
  _Unwind_Resume(a1);
}

uint64_t HEIFReadPlugin::initialize(HEIFReadPlugin *this, IIODictionary *a2)
{
  int v3 = (IIODictionary *)*((void *)this + 6);
  uint64_t v4 = (CGImageMetadata *)*((void *)this + 8);
  double v213 = 0;
  v214[0] = 0;
  CFDictionaryRef ObjectForKey = IIODictionary::getObjectForKey(v3, @"kCGImageSourceXMPSidecar");
  if (ObjectForKey)
  {
    CFDictionaryRef v6 = ObjectForKey;
    CFTypeID v7 = CFGetTypeID(ObjectForKey);
    if (v7 == CFDataGetTypeID()) {
      CFDataRef v8 = v6;
    }
    else {
      CFDataRef v8 = 0;
    }
  }
  else
  {
    CFDataRef v8 = 0;
  }
  int v9 = *((unsigned __int8 *)this + 354);
  if (IIODictionary::containsKey(v3, @"kCGImageSourceTiledDownsamplingMode")) {
    *((_DWORD *)this + 121) = IIODictionary::getUint32ForKey(v3, @"kCGImageSourceTiledDownsamplingMode");
  }
  if (IIODictionary::containsKey(v3, @"kCGImageSourceSubsampleFactor")) {
    unint64_t Uint32ForKey = IIODictionary::getUint32ForKey(v3, @"kCGImageSourceSubsampleFactor");
  }
  else {
    unint64_t Uint32ForKey = 0;
  }
  IIO_LoadHEIFSymbols();
  uint64_t v11 = IIOImageReadSession::globalInfoForType(*((IIOImageReadSession **)this + 3), 1212500294);
  if (!v11)
  {
    kdebug_trace();
    LogError("initialize", 518, "*** ERROR: globalHEIFInfo was not set in IIO_Reader_HEIF::updateSourceProperties or IIO_Reader_HEIF::getImageCount\n");
LABEL_13:
    CFDataRef v12 = 0;
    uint64_t v13 = 4294967246;
    goto LABEL_14;
  }
  CFTypeRef v17 = v11;
  if (!GlobalHEIFInfo::getNumberOfMainImages(v11))
  {
    _cg_jpeg_mem_term("initialize", 519, "*** no main image??? (globalHEIFInfo->getNumberOfMainImages() is 0)\n");
    goto LABEL_13;
  }
  unsigned int v18 = GlobalHEIFInfo::resolvedIndexForIndex(v17, *((unsigned int *)this + 52));
  *((_DWORD *)this + 126) = v18;
  HEIFMainImageAtIndedouble x = (HEIFMainImage *)GlobalHEIFInfo::getHEIFMainImageAtIndex(v17, v18);
  if (!HEIFMainImageAtIndex)
  {
    _cg_jpeg_mem_term("initialize", 524, "*** ERROR: could not get mainImage[%d]\n");
    goto LABEL_13;
  }
  int v20 = HEIFMainImageAtIndex;
  *((_WORD *)this + 158) = 0;
  unsigned int v192 = v3;
  theunint64_t Data = v8;
  metaCFDataRef data = v4;
  if (*((unsigned __int8 *)this + 216) >= 2u)
  {
    HEIFThumbnailImageAtIndedouble x = (HEIFGroupItem *)HEIFMainImage::getHEIFThumbnailImageAtIndex(HEIFMainImageAtIndex, 0);
    if (HEIFThumbnailImageAtIndex)
    {
      CFDictionaryRef v22 = HEIFThumbnailImageAtIndex;
      *((_DWORD *)this + 57) = HEIFGroupItem::getGroupType(HEIFThumbnailImageAtIndex);
      *((_DWORD *)this + 58) = TIFFFieldIsAnonymous((uint64_t)v22);
      IIO_Reader::osType(v22);
      HEIFThumbnailImage::dataLength(v22);
      int v23 = *((_DWORD *)this + 53);
      if (!v23) {
        goto LABEL_70;
      }
      unsigned int v24 = *((_DWORD *)this + 57);
      if (v24 <= *((_DWORD *)this + 58)) {
        unsigned int v24 = *((_DWORD *)this + 58);
      }
      if (v24 == v23) {
        goto LABEL_70;
      }
    }
    goto LABEL_28;
  }
  if (*((_DWORD *)this + 53)
    && (HEIFMainImage::width(HEIFMainImageAtIndex) > *((_DWORD *)this + 53)
     || HEIFMainImage::height(v20) > *((_DWORD *)this + 53)))
  {
LABEL_28:
    CFDataRef v12 = 0;
    *((unsigned char *)this + 498) = 1;
    goto LABEL_71;
  }
  *((_DWORD *)this + 57) = HEIFMainImage::width(v20);
  *((_DWORD *)this + 58) = HEIFMainImage::height(v20);
  if (Uint32ForKey < 2)
  {
LABEL_70:
    CFDataRef v12 = 0;
    goto LABEL_71;
  }
  if (Uint32ForKey <= 3) {
    __int16 v35 = 2;
  }
  else {
    __int16 v35 = 4;
  }
  if (Uint32ForKey > 7) {
    __int16 v35 = 8;
  }
  *((_WORD *)this + 158) = v35;
  CFIndex Size = IIOImageReadSession::getSize(*((IIOImageReadSession **)this + 3));
  BOOL v37 = IIOImageReadSession::retainBytePointer(*((IIOImageReadSession **)this + 3), (const __CFData **)&v213, 1);
  if (!v37)
  {
    LogError("initialize", 575, "*** ERROR: retainBytePointer failed\n");
    goto LABEL_13;
  }
  BOOL v38 = (const UInt8 *)v37;
  uint64_t v39 = *((void *)this + 58);
  if (v39)
  {
    uint64_t v40 = *((void *)this + 59);
    if (!v40) {
      uint64_t v39 = 0;
    }
    BOOL v38 = (const UInt8 *)v37 + v39;
    if (v40) {
      CFIndex Size = (IIOImageRead *)*((void *)this + 59);
    }
  }
  CFDataRef v12 = CFDataCreateWithBytesNoCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v38, (CFIndex)Size, (CFAllocatorRef)*MEMORY[0x1E4F1CFA0]);
  v210[0] = 0;
  v202[0] = 0;
  uint64_t ExpectedWidthAndHeightForSubsampling = HEIFReadPlugin::getExpectedWidthAndHeightForSubsampling(this, v12, *((unsigned int *)this + 126), *((unsigned __int16 *)this + 158), v210, v202);
  if (!ExpectedWidthAndHeightForSubsampling)
  {
    if ((gIIODebugFlags & 0x30000) != 0)
    {
      ImageIOLog("    getExpectedWidthAndHeightForSubsampling:    subSampleFactor: %d  size: %d x %d\n", *((unsigned __int16 *)this + 158), v210[0], v202[0]);
      if ((gIIODebugFlags & 0x30000) != 0) {
        ImageIOLog("                                           :    original size: %d x %d\n", *((_DWORD *)this + 57), *((_DWORD *)this + 58));
      }
    }
    unsigned int v108 = v202[0];
    *((_DWORD *)this + 57) = v210[0];
    *((_DWORD *)this + 58) = v108;
LABEL_71:
    unsigned int v42 = *((_DWORD *)this + 53);
    if (v42 && *((unsigned char *)this + 498))
    {
      float v43 = (float)v42 / (float)HEIFMainImage::width(v20);
      float v44 = (float)*((unsigned int *)this + 53);
      float v45 = v44 / (float)HEIFMainImage::height(v20);
      if (v43 < v45) {
        float v45 = v43;
      }
      if (v45 <= 1.0) {
        float v46 = v45;
      }
      else {
        float v46 = 1.0;
      }
      *((_DWORD *)this + 57) = (float)(v46 * (float)HEIFMainImage::width(v20));
      *((_DWORD *)this + 58) = (float)(v46 * (float)HEIFMainImage::height(v20)) & 0xFFFFFFFE;
    }
    ColorSpaceCFStringRef Name = (const __CFString *)HEIFMainImage::getColorSpaceName(v20);
    if (ColorSpaceName)
    {
      double v48 = CGColorSpaceCreateWithName(ColorSpaceName);
    }
    else
    {
      ColorSpace = (CGColorSpace *)HEIFMainImage::getColorSpace(v20);
      double v48 = CGColorSpaceRetain(ColorSpace);
    }
    *((void *)this + 20) = v48;
    if (!v48)
    {
      double v48 = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E4F1DC98]);
      *((void *)this + 20) = v48;
    }
    uint64_t v50 = MEMORY[0x1E4F14390];
    if ((gIIODebugFlags & 0x8000300000) == 0)
    {
LABEL_109:
      uint64_t v191 = v17;
      if (CGColorSpaceGetModel(v48) == kCGColorSpaceModelRGB) {
        int v65 = 1380401696;
      }
      else {
        int v65 = 1196573017;
      }
      *((_DWORD *)this + 81) = v65;
      *((_WORD *)this + 250) = 0;
      StereoAggressorCFIndex Count = HEIFGroupItem::getStereoAggressorCount(v20);
      if (StereoAggressorCount)
      {
        int v67 = StereoAggressorCount;
        for (unsigned int i = 0; i != v67; ++i)
        {
          if (HEIFMainImage::getHEIFAlternateImageAtIndex(v20, i)) {
            *((unsigned char *)this + 495) = 1;
          }
        }
      }
      int NumberOfAuxImages = HEIFMainImage::getNumberOfAuxImages(v20);
      if (NumberOfAuxImages)
      {
        int v70 = NumberOfAuxImages;
        int xmlns = v9;
        for (unsigned int j = 0; j != v70; ++j)
        {
          HEIFAuxImageAtIndedouble x = (IIOImageWriteSession *)HEIFMainImage::getHEIFAuxImageAtIndex(v20, j);
          CFStringRef v73 = (const __CFString *)IIOImageWriteSession::getSize(HEIFAuxImageAtIndex);
          if (HEIFAuxImage::auxiliaryType(HEIFAuxImageAtIndex) == 3)
          {
            int v74 = HEIFAuxImage::auxiliaryAlpha(HEIFAuxImageAtIndex);
            if (!v74)
            {
              _cg_jpeg_mem_term("initialize", 661, "*** ERROR: image has alpha plane, but auxImage alpha is 'kCGImageAlphaNone'?\n");
              LOBYTE(v74) = 3;
            }
            *((unsigned char *)this + 246) = v74 & 0x1F;
            *((unsigned char *)this + 501) = HEIFAuxImage::auxiliaryAlpha(HEIFAuxImageAtIndex) == 1;
            *((_DWORD *)this + 122) = HEIFAuxImage::auxiliaryPixelFormat(HEIFAuxImageAtIndex);
            *((unsigned char *)this + 500) = 1;
          }
          else if (v73 {
                 && CFEqual(v73, *(CFStringRef *)gIIO_kCMPhotoAuxiliaryImageTypeURN_HDRGainMap))
          }
          {
            *((unsigned char *)this + 494) = 1;
          }
        }
        double v75 = v191;
        unint64_t v76 = v192;
        int v9 = xmlns;
        if (*((unsigned char *)this + 500)) {
          goto LABEL_128;
        }
        *((unsigned char *)this + 246) = 5;
        if (!xmlns) {
          goto LABEL_135;
        }
      }
      else
      {
        unint64_t v76 = v192;
        if (*((_DWORD *)this + 81) == 1380401696)
        {
          int v78 = HEIFMainImage::bitDepth(v20);
          *((unsigned char *)this + 246) = 5;
          double v75 = v191;
          if (v78 == 10)
          {
            *((_WORD *)this + 139) = 5;
            *((_WORD *)this + 155) = 5;
            *((unsigned char *)this + 247) = 0;
          }
LABEL_128:
          if (v9) {
            goto LABEL_129;
          }
LABEL_135:
          BOOL v77 = 0;
          goto LABEL_137;
        }
        *((unsigned char *)this + 246) = 0;
        double v75 = v191;
        if (!v9) {
          goto LABEL_135;
        }
      }
LABEL_129:
      if (*((unsigned char *)this + 494)) {
        BOOL v77 = 1;
      }
      else {
        BOOL v77 = *((unsigned char *)this + 495) != 0;
      }
LABEL_137:
      int v79 = *((unsigned __int8 *)this + 246);
      if ((v79 - 1) < 4 || v79 == 7)
      {
        int v80 = *((_DWORD *)this + 57);
        int v81 = *((_DWORD *)this + 58);
        unint64_t v82 = IIO_AlphaInfoString(v79);
        ImageIOLogInternal(" ImageIO: loading HEIF (%dx%d) with '%s'\n", v80, v81, v82);
      }
      *((_WORD *)this + 120) = HEIFMainImage::bitDepth(v20);
      BOOL EnableRestrictedDecodingFlag = HEIFReadPlugin::getEnableRestrictedDecodingFlag((IIODictionary **)this, v76);
      if (*((_DWORD *)this + 81) == 1196573017)
      {
        char v84 = *((unsigned char *)this + 500);
        if (v84) {
          __int16 v85 = 2;
        }
        else {
          __int16 v85 = 1;
        }
        *((_WORD *)this + 122) = v85;
        if (*((unsigned __int16 *)this + 120) <= 8u) {
          int v86 = 8;
        }
        else {
          int v86 = 16;
        }
        *((_WORD *)this + 120) = v86;
        int v87 = v86 << v84;
        *((_WORD *)this + 121) = v87;
LABEL_160:
        unsigned int v90 = (*((_DWORD *)this + 57) * ((unsigned __int16)v87 >> 3) + 15) & 0xFFFFFFF0;
        *((_DWORD *)this + 59) = v90;
        *((_DWORD *)this + 67) = v90;
        int v91 = IIOSkipMetadata(v76);
        int v92 = IIOSkipXMP_and_IPTC(v76);
        if (v91)
        {
          if (!*((unsigned char *)this + 354)) {
            goto LABEL_177;
          }
          if ((gIIODebugFlags & 0x4000000000000) != 0 && IIO_OSAppleInternalBuild()) {
            ImageIOLog("   skipMetadata and decodeToHDR - contradicting requests\n");
          }
          if ((v92 & 1) == 0) {
            _cg_jpeg_mem_term("initialize", 776, "*** ERROR: skipMetadata and decodeToHDR - contradicting requests - will only skip XMP metadata\n");
          }
          int v92 = 1;
        }
        if (*((unsigned __int8 *)this + 216) < 2u || *((unsigned char *)this + 354) || *((unsigned char *)this + 353))
        {
          int v93 = 0;
          goto LABEL_178;
        }
        if ((gIIODebugFlags & 0x4000000000000) != 0 && IIO_OSAppleInternalBuild()) {
          ImageIOLog("   skipping metadata for thumbnail creation\n");
        }
LABEL_177:
        int v93 = 1;
LABEL_178:
        int v94 = IIOCreateCMPhotoDecompressionSession((uint64_t)v214);
        if (v94)
        {
          int v95 = v94;
          int v96 = IIOCMErrorString(v94);
          LogError("initialize", 792, "*** CMPhotoDecompressionSessionCreate  err = %s [%d]\n", v96, v95);
LABEL_271:
          *((unsigned char *)this + 352) = 0;
          char v167 = CGColorSpaceContainsFlexGTCInfo();
          *((unsigned char *)this + 351) = v167;
          if ((v167 & 1) == 0 && (*((unsigned char *)this + 495) || *((unsigned char *)this + 494)))
          {
            CFStringRef v168 = (const __CFString *)IIODictionary::getObjectForKey(v76, @"kCGImageSourceDecodeRequest");
            if (v168)
            {
              if (CFEqual(v168, @"kCGImageSourceDecodeToHDR"))
              {
                CFDictionaryRef v169 = IIODictionary::getObjectForKey(v76, @"kCGImageSourceDecodeRequestOptions");
                *(void *)double v210 = 0;
                uint64_t v211 = 0;
                CFTypeRef v212 = 0;
                IIODictionary::IIODictionary((IIODictionary *)v210, v169);
                if (*((unsigned char *)this + 496))
                {
                  if (CGColorSpaceIsPQBased(*((CGColorSpaceRef *)this + 20)))
                  {
                    *((unsigned char *)this + 352) = 1;
                    IIOReadPlugin::updateColorSpace((uint64_t)this, 0);
                  }
                  else
                  {
                    *((unsigned char *)this + 496) = 0;
                  }
                }
                IIODictionary::~IIODictionary((IIODictionary *)v210);
              }
            }
          }
          *((_WORD *)this + 188) = 12;
          int v171 = HEIFMainImage::bitDepth(v20);
          uint64_t v172 = MEMORY[0x1E4F14390];
          if (v171 != *((unsigned __int16 *)this + 120))
          {
            uint64_t v173 = *((void *)this + 7);
            IIONumber::IIONumber((IIONumber *)v193, v171);
            IIODictionary::setObjectForKey(v173, (uint64_t)v193, @"Depth");
            IIONumber::~IIONumber((IIONumber *)v193);
          }
          if (GlobalHEIFInfo::shouldExposeMultiFrameContents(v75))
          {
            int v174 = *((_DWORD *)this + 52);
            if (v174 == GlobalHEIFInfo::getPrimaryImageIndex(v75)) {
              IIODictionary::setObjectForKey(*((IIODictionary **)this + 7), (const void *)*MEMORY[0x1E4F1CFD0], @"PrimaryImage");
            }
          }
LABEL_289:
          if ((gIIODebugFlags & 0x30000) == 0) {
            goto LABEL_314;
          }
          int v175 = *((_DWORD *)this + 51);
          unsigned int v176 = v175 >> 24;
          if (v175 < 0)
          {
            int v177 = __maskrune(v176, 0x40000uLL);
            int v175 = *((_DWORD *)this + 51);
          }
          else
          {
            int v177 = *(_DWORD *)(v172 + 4 * v176 + 60) & 0x40000;
          }
          if (v177) {
            uint64_t v178 = (v175 >> 24);
          }
          else {
            uint64_t v178 = 46;
          }
          unsigned int v179 = v175 << 8 >> 24;
          if (v175 << 8 < 0)
          {
            int v180 = __maskrune(v179, 0x40000uLL);
            int v175 = *((_DWORD *)this + 51);
          }
          else
          {
            int v180 = *(_DWORD *)(v172 + 4 * v179 + 60) & 0x40000;
          }
          if (v180) {
            uint64_t v181 = (v175 << 8 >> 24);
          }
          else {
            uint64_t v181 = 46;
          }
          unsigned int v182 = (__int16)v175 >> 8;
          if (v175 << 16 < 0)
          {
            int v183 = __maskrune(v182, 0x40000uLL);
            int v175 = *((_DWORD *)this + 51);
          }
          else
          {
            int v183 = *(_DWORD *)(v172 + 4 * v182 + 60) & 0x40000;
          }
          if (v183) {
            uint64_t v184 = ((__int16)v175 >> 8);
          }
          else {
            uint64_t v184 = 46;
          }
          if ((v175 << 24) <= 0x7F000000)
          {
            if ((*(_DWORD *)(v172 + 4 * (char)v175 + 60) & 0x40000) != 0) {
              goto LABEL_310;
            }
          }
          else if (__maskrune((char)v175, 0x40000uLL))
          {
LABEL_310:
            uint64_t v185 = *((char *)this + 204);
LABEL_313:
            ImageIOLog("  '%c%c%c%c'-initialize  w: %d  h: %d  rb: %d  bpp: %d  bpc: %d\n", v178, v181, v184, v185, *((_DWORD *)this + 57), *((_DWORD *)this + 58), *((_DWORD *)this + 59), *((unsigned __int16 *)this + 121), *((unsigned __int16 *)this + 120));
LABEL_314:
            uint64_t v13 = 0;
            if (!v12) {
              goto LABEL_52;
            }
            goto LABEL_51;
          }
          uint64_t v185 = 46;
          goto LABEL_313;
        }
        CFTypeRef v208 = 0;
        CFTypeRef v209 = 0;
        uint64_t v207 = 1;
        if (!v12)
        {
          int v97 = IIOImageReadSession::getSize(*((IIOImageReadSession **)this + 3));
          unint64_t v98 = IIOImageReadSession::retainBytePointer(*((IIOImageReadSession **)this + 3), (const __CFData **)&v213, 1);
          if (!v98)
          {
            LogError("initialize", 807, "*** ERROR: retainBytePointer failed\n");
            CFDataRef v12 = 0;
            uint64_t v172 = MEMORY[0x1E4F14390];
            goto LABEL_289;
          }
          int v99 = (const UInt8 *)v98;
          uint64_t v100 = *((void *)this + 58);
          if (v100)
          {
            if (*((void *)this + 59)) {
              int v97 = (IIOImageRead *)*((void *)this + 59);
            }
            else {
              uint64_t v100 = 0;
            }
            int v99 = (const UInt8 *)v98 + v100;
          }
          CFDataRef v12 = CFDataCreateWithBytesNoCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v99, (CFIndex)v97, (CFAllocatorRef)*MEMORY[0x1E4F1CFA0]);
          if (!v12)
          {
LABEL_270:
            CFRelease(v214[0]);
            goto LABEL_271;
          }
        }
        int v101 = gFunc_CMPhotoDecompressionSessionCreateContainer(v214[0], 0, v12, (char *)&v207 + 4, &v209);
        if (v101)
        {
          int v102 = v101;
          __int16 v103 = IIOCMErrorString(v101);
          LogError("initialize", 825, "*** CMPhotoDecompressionSessionCreateContainer  err = %s [%d]\n", v103, v102);
          goto LABEL_270;
        }
        if (GlobalHEIFInfo::hasHEIFSequence(v75)) {
          int v104 = IIOImageRead::trustedURL(v75);
        }
        else {
          int v104 = 0;
        }
        unsigned int v206 = 0;
        CFDataRef v205 = 0;
        if (v93)
        {
          ImageGeometryForIndexWithuint64_t Options = gFunc_CMPhotoDecompressionContainerGetImageGeometryForIndexWithOptions(v209, *((unsigned int *)this + 126), 0, 0, 0, &v207);
          if (ImageGeometryForIndexWithOptions)
          {
            int v106 = ImageGeometryForIndexWithOptions;
            long long v107 = IIOCMErrorString(ImageGeometryForIndexWithOptions);
            LogError("initialize", 849, "*** CMPhotoDecompressionContainerGetImageGeometryForIndexWithOptions  err = %s [%d]\n", v107, v106);
            goto LABEL_244;
          }
          *(void *)double v210 = 0;
          uint64_t v211 = 0;
          CFTypeRef v212 = 0;
          IIODictionary::IIODictionary((IIODictionary *)v210);
          IIONumber::IIONumber((IIONumber *)v202, v207);
          IIODictionary::setObjectForKeyGroup((IIODictionary *)v210, v204, @"Orientation", @"{TIFF}");
          IIONumber::~IIONumber((IIONumber *)v202);
          uint64_t v109 = (const void *)CGImageMetadataCreateFromLegacyProps((IIODictionary *)v210);
          CGImageMetadataMerge((uint64_t)metadata, (uint64_t)v109, 0);
          if (v109)
          {
            CFRelease(v109);
            IIODictionary::~IIODictionary((IIODictionary *)v210);
            goto LABEL_244;
          }
          IIODictionary::~IIODictionary((IIODictionary *)v210);
        }
        HEIFExifPayloadAtIndedouble x = (IIOImageSource *)HEIFMainImage::getHEIFExifPayloadAtIndex(v20, 0);
        if (HEIFExifPayloadAtIndex)
        {
          int v111 = HEIFExifPayloadAtIndex;
          BOOL v112 = (uint64_t (*)(CFTypeRef, uint64_t, uint64_t, void, unsigned int *, const __CFData **))gFunc_CMPhotoDecompressionContainerCopyExifForIndexWithOptions;
          CFTypeRef v113 = v209;
          uint64_t v114 = IIOImageSource::cf(HEIFExifPayloadAtIndex);
          uint64_t Ref = IIOImageSource::imageReadRef(v111);
          int v116 = v112(v113, v114, Ref, 0, &v206, &v205);
          if (v116)
          {
            int v117 = v116;
            long long v118 = IIOCMErrorString(v116);
            LogError("initialize", 876, "*** CMPhotoDecompressionContainerCopyExifForIndexWithOptions  err = %s [%d]\n", v118, v117);
            double v75 = v191;
          }
          else
          {
            CFDataRef v190 = v12;
            BytePtr = CFDataGetBytePtr(v205);
            unsigned int Length = CFDataGetLength(v205);
            double v75 = v191;
            if (Length > v206)
            {
              MetadataFromDatauint64_t buffer = CreateMetadataFromDatabuffer((const char *)&BytePtr[v206], Length - v206);
              memory_object_size_t v122 = (CGImageMetadata *)MetadataFromDatabuffer;
              if (MetadataFromDatabuffer)
              {
                long long v123 = *(__CFDictionary **)(MetadataFromDatabuffer + 48);
                if (v123)
                {
                  *(void *)double v210 = 0;
                  uint64_t v211 = 0;
                  CFTypeRef v212 = 0;
                  long long v124 = IIODictionary::IIODictionary((IIODictionary *)v210, v123);
                  double FloatForKeyGroup = IIODictionary::getFloatForKeyGroup(v124, @"33", @"{MakerApple}");
                  *((_DWORD *)this + 127) = LODWORD(FloatForKeyGroup);
                  double v126 = IIODictionary::getFloatForKeyGroup((IIODictionary *)v210, @"48", @"{MakerApple}");
                  *((_DWORD *)this + 128) = LODWORD(v126);
                  if ((gIIODebugFlags & 0x300000) != 0) {
                    ImageIOLog("  %s - headroom from makerNote: _meteorHeadroom: %g   _meteorPlusHeadroom:%g\n", "initialize", *((float *)this + 127), *(float *)&v126);
                  }
                  IIODictionary::~IIODictionary((IIODictionary *)v210);
                }
              }
              if (HEIFMainImage::isTiled(v20))
              {
                Tilesize_t Width = HEIFMainImage::getTileWidth(v20);
                Tileunsigned int Length = HEIFMainImage::getTileLength(v20);
                IIONumber::IIONumber((IIONumber *)v210, TileWidth);
                long long v128 = CGImageMetadataTagCreate(@"http://ns.adobe.com/tiff/1.0/", @"tiff", @"TileWidth", kCGImageMetadataTypeDefault, v212);
                IIONumber::~IIONumber((IIONumber *)v210);
                if (v128)
                {
                  CGImageMetadataSetTagWithPath(v122, 0, @"tiff:TileWidth", v128);
                  CFRelease(v128);
                }
                IIONumber::IIONumber((IIONumber *)v210, TileLength);
                long long v129 = CGImageMetadataTagCreate(@"http://ns.adobe.com/tiff/1.0/", @"tiff", @"TileLength", kCGImageMetadataTypeDefault, v212);
                IIONumber::~IIONumber((IIONumber *)v210);
                double v75 = v191;
                if (v129)
                {
                  CGImageMetadataSetTagWithPath(v122, 0, @"tiff:TileLength", v129);
                  CFRelease(v129);
                }
              }
              CGImageMetadataMerge((uint64_t)metadata, (uint64_t)v122, 0);
              if (v122) {
                CFRelease(v122);
              }
            }
            CFDataRef v12 = v190;
            if (v205) {
              CFRelease(v205);
            }
          }
        }
        if (v92)
        {
          if ((v93 & 1) == 0) {
            CGImageMetadataRemoveTagWithPath(metadata, 0, @"dc:creator");
          }
          goto LABEL_235;
        }
        if (theData)
        {
          long long v130 = (const char *)CFDataGetBytePtr(theData);
          CFIndex v131 = CFDataGetLength(theData);
          MetadataFromXMPSidecarunint64_t Data = CreateMetadataFromXMPSidecarData(v130, v131);
          CGImageMetadataMerge((uint64_t)metadata, MetadataFromXMPSidecarData, 0);
          if (!MetadataFromXMPSidecarData)
          {
LABEL_235:
            if (v104)
            {
              if (*((_DWORD *)this + 51) == 1096173907) {
                int v146 = &kCGImagePropertyAVISDictionary;
              }
              else {
                int v146 = &kCGImagePropertyHEICSDictionary;
              }
              CFStringRef v147 = *v146;
              double FrameDuration = HEIFMainImage::getFrameDuration(v20);
              unint64_t v149 = (IIODictionary *)*((void *)this + 7);
              IIONumber::IIONumber((IIONumber *)v201, FrameDuration);
              IIODictionary::setObjectForKeyGroup(v149, (uint64_t)v201, @"UnclampedDelayTime", v147);
              IIONumber::~IIONumber((IIONumber *)v201);
              double v150 = 0.1;
              if (FrameDuration >= 0.1) {
                double v150 = FrameDuration;
              }
              unint64_t v151 = (IIODictionary *)*((void *)this + 7);
              IIONumber::IIONumber((IIONumber *)v200, v150);
              IIODictionary::setObjectForKeyGroup(v151, (uint64_t)v200, @"DelayTime", v147);
              IIONumber::~IIONumber((IIONumber *)v200);
            }
            HEIFItemPayloadAtIndedouble x = (HEIFItem *)HEIFMainImage::getHEIFItemPayloadAtIndex(v20, 0);
            if (HEIFItemPayloadAtIndex) {
              HEIFItem::updateProperties(HEIFItemPayloadAtIndex, *((IIODictionary **)this + 7));
            }
LABEL_244:
            uint64_t v198 = 0;
            uint64_t v199 = 0;
            if (v104)
            {
              int v153 = gFunc_CMPhotoDecompressionContainerCreateSequenceContainer(v209, 0, 0, &v208);
              if (v153)
              {
                int v154 = v153;
                double v155 = IIOCMErrorString(v153);
                LogError("initialize", 1006, "*** CMPhotoDecompressionContainerCreateSequenceContainer  err = %s [%d]\n", v155, v154);
              }
              int v156 = gFunc_CMPhotoDecompressionContainerGetImageGeometryForIndexWithOptions(v208, *((unsigned int *)this + 126), 0, &v199, &v198, &v207);
              unint64_t v76 = v192;
              if (v156)
              {
                IIOCMErrorString(v156);
                LogError("initialize", 1009, "*** CMPhotoDecompressionContainerGetImageGeometryForIndexWithOptions  err = %s [%d]\n");
LABEL_251:
                LODWORD(v207) = 0;
LABEL_252:
                if (IIODictionary::getBoolForKey(v76, @"kCGImageSourceCreateThumbnailWithTransform")
                  && (v207 - 5) <= 3)
                {
                  *(int32x2_t *)((char *)this + 260) = vrev64_s32(*(int32x2_t *)((char *)this + 228));
                }
                if (IIODictionary::containsKey(v76, @"kCGImageSourceDecodeRequest"))
                {
                  *(void *)double v210 = 0;
                  uint64_t v211 = 0;
                  CFTypeRef v212 = 0;
                  IIODictionary::IIODictionary((IIODictionary *)v210);
                  int v158 = HEIFMainImage::bitDepth(v20);
                  int DecodePixelFormatForBitDepth = HEIFReadPlugin::getDecodePixelFormatForBitDepth(this, v158);
                  IIONumber::IIONumber((IIONumber *)v197, DecodePixelFormatForBitDepth);
                  IIODictionary::setObjectForKey((uint64_t)v210, (uint64_t)v197, *(const void **)gIIO_kCMPhotoDecompressionOption_OutputPixelFormat);
                  IIONumber::~IIONumber((IIONumber *)v197);
                  HEIFReadPlugin::updateCreateImageOptions(this, (IIODictionary *)v210, v76);
                  CFTypeRef cf = 0;
                  int v160 = gFunc_CMPhotoDecompressionContainerCreateOutputBufferAttributesForImageIndex(v209, *((unsigned int *)this + 126), v211, &cf);
                  int v161 = v160;
                  if (v160)
                  {
                    int v162 = IIOCMErrorString(v160);
                    LogError("initialize", 1064, "*** CMPhotoDecompressionContainerCreateOutputBufferAttributesForImageIndex  err = %s [%d]\n", v162, v161);
                  }
                  if (cf)
                  {
                    *(void *)v202 = 0;
                    uint64_t v203 = 0;
                    char v204 = 0;
                    IIODictionary::IIODictionary((IIODictionary *)v202);
                    IIODictionary::appendDictionary(v163, (const __CFDictionary *)cf);
                    if ((IIODictionary::containsKey((IIODictionary *)v202, *(const __CFString **)gIIO_kCVPixelBufferPixelFormatTypeKey) & 1) == 0)
                    {
                      CFDictionaryRef v164 = IIODictionary::getObjectForKey((IIODictionary *)v210, *(const __CFString **)gIIO_kCMPhotoDecompressionOption_OutputPixelFormat);
                      IIODictionary::setObjectForKey((IIODictionary *)v202, v164, *(const __CFString **)gIIO_kCVPixelBufferPixelFormatTypeKey);
                      if ((gIIODebugFlags & 0x2000000) != 0)
                      {
                        int v165 = IIODictionary::getUint32ForKey((IIODictionary *)v202, *(const __CFString **)gIIO_kCVPixelBufferPixelFormatTypeKey);
                        LogPixelFormat(v165, "initialize", 1072);
                      }
                    }
                    HEIFMainImage::getHeadroom(v20);
                    if (v166 > 0.0)
                    {
                      IIONumber::IIONumber((IIONumber *)v194, v166);
                      IIODictionary::setObjectForKey((IIODictionary *)v202, value, @"IOSurfaceContentHeadroom");
                      IIONumber::~IIONumber((IIONumber *)v194);
                    }
                    HEIFReadPlugin::handleDecodeRequest(this, v76, (IIODictionary *)v202);
                    CFRelease(cf);
                    IIODictionary::~IIODictionary((IIODictionary *)v202);
                  }
                  IIODictionary::~IIODictionary((IIODictionary *)v210);
                }
                if (v208) {
                  CFRelease(v208);
                }
                if (v209) {
                  CFRelease(v209);
                }
                goto LABEL_270;
              }
            }
            else
            {
              int v157 = gFunc_CMPhotoDecompressionContainerGetImageGeometryForIndexWithOptions(v209, *((unsigned int *)this + 126), 0, &v199, &v198, &v207);
              unint64_t v76 = v192;
              if (v157)
              {
                IIOCMErrorString(v157);
                LogError("initialize", 1014, "*** CMPhotoDecompressionContainerGetImageGeometryForIndexWithOptions  err = %s [%d]\n");
                goto LABEL_251;
              }
            }
            if (v207)
            {
              IIONumber::IIONumber((IIONumber *)v210, v207);
              CFRange v170 = CGImageMetadataTagCreate(@"http://ns.adobe.com/tiff/1.0/", @"tiff", @"TileLength", kCGImageMetadataTypeDefault, v212);
              IIONumber::~IIONumber((IIONumber *)v210);
              double v75 = v191;
              if (v170)
              {
                CGImageMetadataSetTagWithPath(metadata, 0, @"tiff:Orientation", v170);
                CFRelease(v170);
              }
            }
            goto LABEL_252;
          }
          CFDataRef v133 = (CFDataRef)MetadataFromXMPSidecarData;
        }
        else
        {
          *(void *)double v210 = 0;
          HEIFXMPPayloadAtIndedouble x = (IIOImageSource *)HEIFMainImage::getHEIFXMPPayloadAtIndex(v20, 0);
          if (!HEIFXMPPayloadAtIndex) {
            goto LABEL_235;
          }
          memory_object_size_t v135 = HEIFXMPPayloadAtIndex;
          long long v136 = gFunc_CMPhotoDecompressionContainerCopyXMPForIndexWithOptions;
          CFTypeRef v137 = v209;
          uint64_t v138 = IIOImageSource::cf(HEIFXMPPayloadAtIndex);
          uint64_t v139 = IIOImageSource::imageReadRef(v135);
          int v140 = ((uint64_t (*)(CFTypeRef, uint64_t, uint64_t, void, void, unsigned int *))v136)(v137, v138, v139, 0, 0, v210);
          if (v140)
          {
            int v141 = v140;
            CFIndex v142 = IIOCMErrorString(v140);
            LogError("initialize", 959, "*** CMPhotoDecompressionContainerCopyXMPForIndexWithOptions  err = %s [%d]\n", v142, v141);
          }
          else
          {
            int v143 = (const char *)CFDataGetBytePtr(*(CFDataRef *)v210);
            unsigned int v144 = CFDataGetLength(*(CFDataRef *)v210);
            uint64_t MetadataFromXMPBuffer = (const void *)CreateMetadataFromXMPBuffer(v143, v144);
            CGImageMetadataMerge((uint64_t)metadata, (uint64_t)MetadataFromXMPBuffer, 0);
            if (MetadataFromXMPBuffer) {
              CFRelease(MetadataFromXMPBuffer);
            }
          }
          CFDataRef v133 = *(CFDataRef *)v210;
          double v75 = v191;
          if (!*(void *)v210) {
            goto LABEL_235;
          }
        }
        CFRelease(v133);
        goto LABEL_235;
      }
      *((_WORD *)this + 122) = 4;
      if (v77)
      {
        if (!EnableRestrictedDecodingFlag)
        {
          unsigned int v88 = *((unsigned __int16 *)this + 120);
LABEL_157:
          if (v88 != 10 || *((unsigned char *)this + 500))
          {
            *((_DWORD *)this + 60) = 4194320;
            LOWORD(v87) = 64;
            goto LABEL_160;
          }
          *((_DWORD *)this + 60) = 2097162;
          *((unsigned char *)this + 248) = 3;
          *((unsigned char *)this + 280) = 3;
          *((unsigned char *)this + 312) = 3;
LABEL_156:
          LOWORD(v87) = 32;
          goto LABEL_160;
        }
      }
      else
      {
        unsigned int v88 = *((unsigned __int16 *)this + 120);
        char v89 = v88 < 9 || EnableRestrictedDecodingFlag;
        if ((v89 & 1) == 0) {
          goto LABEL_157;
        }
      }
      *((_DWORD *)this + 60) = 2097160;
      goto LABEL_156;
    }
    int v51 = *((_DWORD *)this + 51);
    unsigned int v52 = v51 >> 24;
    if (v51 < 0)
    {
      int v53 = __maskrune(v52, 0x40000uLL);
      int v51 = *((_DWORD *)this + 51);
    }
    else
    {
      int v53 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v52 + 60) & 0x40000;
    }
    if (v53) {
      uint64_t v54 = (v51 >> 24);
    }
    else {
      uint64_t v54 = 46;
    }
    unsigned int v55 = v51 << 8 >> 24;
    if (v51 << 8 < 0)
    {
      int v56 = __maskrune(v55, 0x40000uLL);
      int v51 = *((_DWORD *)this + 51);
    }
    else
    {
      int v56 = *(_DWORD *)(v50 + 4 * v55 + 60) & 0x40000;
    }
    if (v56) {
      uint64_t v57 = (v51 << 8 >> 24);
    }
    else {
      uint64_t v57 = 46;
    }
    unsigned int v58 = (__int16)v51 >> 8;
    if (v51 << 16 < 0)
    {
      int v59 = __maskrune(v58, 0x40000uLL);
      int v51 = *((_DWORD *)this + 51);
    }
    else
    {
      int v59 = *(_DWORD *)(v50 + 4 * v58 + 60) & 0x40000;
    }
    if (v59) {
      uint64_t v60 = ((__int16)v51 >> 8);
    }
    else {
      uint64_t v60 = 46;
    }
    if ((v51 << 24) <= 0x7F000000)
    {
      if ((*(_DWORD *)(v50 + 4 * (char)v51 + 60) & 0x40000) != 0) {
        goto LABEL_105;
      }
    }
    else if (__maskrune((char)v51, 0x40000uLL))
    {
LABEL_105:
      int v61 = *((_DWORD *)this + 51);
LABEL_108:
      CFStringRef Name = CGColorSpaceGetName(*((CGColorSpaceRef *)this + 20));
      double v63 = IIOString::IIOString((IIOString *)v210, Name);
      long long v64 = (const char *)IIOString::utf8String(v63);
      ImageIOLog("COL '%c%c%c%c' %s:%d using colorSpace: '%s'\n", v54, v57, v60, (char)v61, "initialize", 630, v64);
      IIOString::~IIOString((IIOString *)v210);
      double v48 = (CGColorSpace *)*((void *)this + 20);
      goto LABEL_109;
    }
    LOBYTE(v61) = 46;
    goto LABEL_108;
  }
  uint64_t v13 = ExpectedWidthAndHeightForSubsampling;
  LogError("initialize", 592, "*** ERROR: _getExpectedWidthAndHeightForSubsampling failed\n");
LABEL_14:
  int v14 = *((_DWORD *)this + 51);
  unsigned int v15 = v14 >> 24;
  if (v14 < 0)
  {
    int v16 = __maskrune(v15, 0x40000uLL);
    int v14 = *((_DWORD *)this + 51);
  }
  else
  {
    int v16 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v15 + 60) & 0x40000;
  }
  if (v16) {
    uint64_t v25 = (v14 >> 24);
  }
  else {
    uint64_t v25 = 46;
  }
  unsigned int v26 = v14 << 8 >> 24;
  if (v14 << 8 < 0)
  {
    int v27 = __maskrune(v26, 0x40000uLL);
    int v14 = *((_DWORD *)this + 51);
  }
  else
  {
    int v27 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v26 + 60) & 0x40000;
  }
  if (v27) {
    uint64_t v28 = (v14 << 8 >> 24);
  }
  else {
    uint64_t v28 = 46;
  }
  unsigned int v29 = (__int16)v14 >> 8;
  if (v14 << 16 < 0)
  {
    int v30 = __maskrune(v29, 0x40000uLL);
    int v14 = *((_DWORD *)this + 51);
  }
  else
  {
    int v30 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v29 + 60) & 0x40000;
  }
  if (v30) {
    uint64_t v31 = ((__int16)v14 >> 8);
  }
  else {
    uint64_t v31 = 46;
  }
  if ((v14 << 24) <= 0x7F000000)
  {
    if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * (char)v14 + 60) & 0x40000) != 0) {
      goto LABEL_47;
    }
  }
  else if (__maskrune((char)v14, 0x40000uLL))
  {
LABEL_47:
    uint64_t v32 = *((char *)this + 204);
    goto LABEL_50;
  }
  uint64_t v32 = 46;
LABEL_50:
  _cg_jpeg_mem_term("initialize", 1154, "*** ERROR: '%c%c%c%c'-initialize failed [%d]\n", v25, v28, v31, v32, v13);
  kdebug_trace();
  if (v12) {
LABEL_51:
  }
    CFRelease(v12);
LABEL_52:
  if (v213)
  {
    int v33 = (IIOImageRead **)*((void *)this + 3);
    if (v33) {
      IIOImageReadSession::releaseBytePointer(v33, v213);
    }
  }
  return v13;
}

void sub_1885FB6C8(_Unwind_Exception *a1)
{
  IIONumber::~IIONumber((IIONumber *)(v1 - 144));
  _Unwind_Resume(a1);
}

uint64_t HEIFMainImage::bitDepth(HEIFMainImage *this)
{
  return *((unsigned int *)this + 43);
}

float IIO_Reader_HEIF::updateImageHeadroom(uint64_t a1, CGImageRef image, IIOImageReadSession *a3, uint64_t a4)
{
  CGImageGetColorSpace(image);
  if (CGColorSpaceContainsFlexGTCInfo())
  {
    CGColorSpaceGetHeadroomInfo();
    goto LABEL_16;
  }
  if (!a3
    || (CFDataRef v8 = IIOImageReadSession::globalInfoForType(a3, 1212500294)) == 0
    || (HEIFMainImageAtIndedouble x = (HEIFMainImage *)GlobalHEIFInfo::getHEIFMainImageAtIndex(v8, 0)) == 0
    || (HEIFMainImage::getHeadroom(HEIFMainImageAtIndex), v10 <= 0.0))
  {
LABEL_16:
    return IIO_Reader::updateImageHeadroom(a1, (uint64_t)image, (uint64_t)a3, a4);
  }
  float v11 = v10;
  if (image)
  {
    ColorSpace = CGImageGetColorSpace(image);
    CFStringRef Name = CGColorSpaceGetName(ColorSpace);
    if (!Name)
    {
      if ((gIIODebugFlags & 0x300000) != 0)
      {
        CFStringRef v17 = (const __CFString *)CGColorSpaceCopyICCProfileDescription();
        CFStringRef Name = v17;
        if (v17) {
          CFAutorelease(v17);
        }
      }
      else
      {
        CFStringRef Name = 0;
      }
    }
    memset(v18, 0, sizeof(v18));
    IIOString::IIOString((IIOString *)v18, Name);
    int v14 = (const char *)IIOString::utf8String((IIOString *)v18);
    if (CGColorSpaceUsesITUR_2100TF(ColorSpace) || CGColorSpaceUsesExtendedRange(ColorSpace))
    {
      int v15 = CGImageSetHeadroom();
      if ((gIIODebugFlags & 0x300000) != 0)
      {
        if (v15) {
          ImageIOLog("  %s - updating image headroom: %g [colorspace: '%s']\n");
        }
        else {
          ImageIOLog("  %s - failed to update image headroom: %g  [colorspace: '%s']\n");
        }
      }
    }
    else if ((gIIODebugFlags & 0x300000) != 0)
    {
      ImageIOLog("  %s - not setting image headroom: %g for SDR [colorspace: '%s']\n", "updateImageHeadroom", v11, v14);
    }
    IIOString::~IIOString((IIOString *)v18);
  }
  return v11;
}

void sub_1885FB9BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  IIOString::~IIOString((IIOString *)va);
  _Unwind_Resume(a1);
}

uint64_t GlobalHEIFInfo::getHEIFMainImageAtIndex(GlobalHEIFInfo *this, unsigned int a2)
{
  uint64_t v2 = a2;
  uint64_t v3 = *((void *)this + 1);
  if (a2 >= (unint64_t)((*((void *)this + 2) - v3) >> 3)) {
    return 0;
  }
  if (!*((unsigned char *)this + 68)) {
    uint64_t v2 = *((unsigned int *)this + 16);
  }
  return *(void *)(v3 + 8 * v2);
}

void HEIFMainImage::getHeadroom(HEIFMainImage *this)
{
  BOOL v2 = *((float *)this + 66) > 0.0;
  uint64_t v3 = *((void *)this + 4);
  uint64_t v4 = *((void *)this + 5) - v3;
  if ((v4 & 0x7FFFFFFF8) != 0)
  {
    unint64_t v5 = 0;
    unint64_t v6 = v4 >> 3;
    uint64_t v7 = ((unint64_t)v4 >> 3);
    while (1)
    {
      if (v6 <= v5) {
        uint64_t v8 = 0;
      }
      else {
        uint64_t v8 = *(void *)(v3 + 8 * v5);
      }
      float v9 = *(float *)(v8 + 48);
      if (v9 == 0.0) {
        float v9 = *(float *)(v8 + 44);
      }
      if (v9 > 0.0) {
        break;
      }
      if (v7 == ++v5) {
        goto LABEL_12;
      }
    }
    BOOL v2 = 1;
  }
LABEL_12:
  uint64_t v10 = *((void *)this + 7);
  unint64_t v11 = *((void *)this + 8) - v10;
  if ((v11 & 0x7FFFFFFF8) != 0)
  {
    uint64_t v12 = 0;
    uint64_t v13 = (v11 >> 3);
    while (fmaxf(*(float *)(*(void *)(v10 + 8 * v12) + 56), *(float *)(*(void *)(v10 + 8 * v12) + 60)) <= 0.0)
    {
      if (v13 == ++v12) {
        goto LABEL_16;
      }
    }
  }
  else
  {
LABEL_16:
    if (!v2)
    {
      if (!*((void *)this + 37) || (CGColorSpaceGetHeadroomInfo(), v14 <= 0.0))
      {
        CFStringRef v15 = (const __CFString *)*((void *)this + 36);
        if (v15)
        {
          CGColorSpaceRef v16 = CGColorSpaceCreateWithName(v15);
          if (v16)
          {
            CFStringRef v17 = v16;
            CGColorSpaceGetHeadroomInfo();
            CGColorSpaceRelease(v17);
          }
        }
      }
    }
  }
}

BOOL HEIFReadPlugin::getEnableRestrictedDecodingFlag(IIODictionary **this, IIODictionary *a2)
{
  if (IIORestrictedDecodingEnabledFlag()) {
    return 1;
  }
  if (!IIODictionary::getCount(a2)) {
    return 0;
  }
  if (IIODictionary::containsKey(a2, @"kCGImageSourceEnableRestrictedDecoding"))
  {
    BOOL BoolForKey = IIODictionary::getBoolForKey(a2, @"kCGImageSourceEnableRestrictedDecoding");
    if ((gIIODebugFlags & 0x4000000000000) != 0 && IIO_OSAppleInternalBuild())
    {
      unint64_t v5 = "";
      if (BoolForKey) {
        unint64_t v5 = "";
      }
      int v6 = 1308;
LABEL_16:
      ImageIOLog(" %s EnableRestrictedDecoding  | %s:%d\n", v5, "getEnableRestrictedDecodingFlag", v6);
      return BoolForKey;
    }
    return BoolForKey;
  }
  if (!IIODictionary::containsKey(this[6], @"kCGImageSourceEnableRestrictedDecoding"))
  {
    if ((gIIODebugFlags & 0x4000000000000) != 0 && IIO_OSAppleInternalBuild()) {
      ImageIOLog("  EnableRestrictedDecoding  | %s:%d\n", "getEnableRestrictedDecodingFlag", 1316);
    }
    return 0;
  }
  BOOL BoolForKey = IIODictionary::getBoolForKey(this[6], @"kCGImageSourceEnableRestrictedDecoding");
  if ((gIIODebugFlags & 0x4000000000000) != 0 && IIO_OSAppleInternalBuild())
  {
    unint64_t v5 = "";
    if (BoolForKey) {
      unint64_t v5 = "";
    }
    int v6 = 1313;
    goto LABEL_16;
  }
  return BoolForKey;
}

uint64_t IIORestrictedDecodingEnabledFlag()
{
  return (gPermissions >> 4) & 1;
}

uint64_t GlobalHEIFInfo::hasHEIFSequence(GlobalHEIFInfo *this)
{
  return *((unsigned __int8 *)this + 69);
}

uint64_t GlobalHEIFInfo::resolvedIndexForIndex(GlobalHEIFInfo *this, uint64_t a2)
{
  if (!*((unsigned char *)this + 68)) {
    return *((unsigned int *)this + 16);
  }
  return a2;
}

uint64_t IIO_Reader_HEIF::extractImageInfo(IIO_Reader_HEIF *this, GlobalHEIFInfo *a2, IIOImageReadSession *a3, IIODictionary *a4)
{
  v63[0] = 0;
  uint64_t v62 = 0;
  long long v60 = 0u;
  long long v61 = 0u;
  long long v58 = 0u;
  long long v59 = 0u;
  IIOScanner::IIOScanner((IIOScanner *)&v58, a3);
  if (GlobalHEIFInfo::getNumberOfMainImages(a2))
  {
    uint64_t v6 = 0;
  }
  else
  {
    uint64_t v7 = IIOCreateCMPhotoDecompressionSession((uint64_t)v63);
    uint64_t v6 = v7;
    if (v7)
    {
      float v9 = IIOCMErrorString(v7);
      _cg_jpeg_mem_term("extractImageInfo", 474, "*** CMPhotoDecompressionSessionCreate  err = %s [%d]\n", v9, v6);
    }
    else
    {
      CFTypeRef v56 = 0;
      CFTypeRef v57 = 0;
      int v55 = 0;
      uint64_t v10 = (const UInt8 *)*((void *)&v58 + 1);
      CFIndex Uint32ForKey = v59;
      if (a4 && IIODictionary::containsKey(a4, @"JPEGOffset"))
      {
        CFIndex Uint32ForKey = IIODictionary::getUint32ForKey(a4, @"JPEGLength");
        v10 += IIODictionary::getUint32ForKey(a4, @"JPEGOffset");
      }
      uint64_t v6 = 0;
      CFDataRef v12 = 0;
      if (Uint32ForKey && v10)
      {
        CFDataRef v12 = CFDataCreateWithBytesNoCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v10, Uint32ForKey, (CFAllocatorRef)*MEMORY[0x1E4F1CFA0]);
        if (v12)
        {
          uint64_t v6 = gFunc_CMPhotoDecompressionSessionCreateContainer(v63[0], 0, v12, &v55, &v57);
          if (v6 || !v57)
          {
            float v46 = IIOCMErrorString(v6);
            __n128 v8 = _cg_jpeg_mem_term("extractImageInfo", 513, "*** CMPhotoDecompressionSessionCreateContainer  err = %s [%d]\n", v46, v6);
          }
          else
          {
            CFDictionaryRef theDict = 0;
            uint64_t v13 = gFunc_CMPhotoDecompressionContainerCreateDictionaryDescription(v57, &theDict);
            uint64_t v6 = v13;
            if (v13)
            {
              float v14 = IIOCMErrorString(v13);
              _cg_jpeg_mem_term("extractImageInfo", 526, "*** CMPhotoDecompressionContainerCreateDictionaryDescription  err = %s [%d]\n", v14, v6);
            }
            else
            {
              memset(v53, 0, sizeof(v53));
              IIODictionary::IIODictionary((IIODictionary *)v53, theDict);
              if (IIODictionary::containsKey((IIODictionary *)v53, *(const __CFString **)gIIO_kCMPhotoDecompressionContainerDescription_GroupsList))
              {
                value[0] = 0;
                CFDictionaryGetValueIfPresent(theDict, *(const void **)gIIO_kCMPhotoDecompressionContainerDescription_GroupsList, (const void **)value);
                theArradouble y = 0;
                if (gFunc_CMPhotoDecompressionContainerCopyGroupsDescriptionArray)
                {
                  uint64_t v6 = gFunc_CMPhotoDecompressionContainerCopyGroupsDescriptionArray(v57, &theArray);
                }
                else
                {
                  _cg_jpeg_mem_term("extractImageInfo", 547, "*** ERROR: Symbol 'CMPhotoDecompressionContainerCopyGroupsDescriptionArray' not loaded\n");
                  uint64_t v6 = 0;
                }
                CFIndex Count = CFArrayGetCount((CFArrayRef)value[0]);
                if (theArray) {
                  CFIndex v16 = CFArrayGetCount(theArray);
                }
                else {
                  CFIndex v16 = 0;
                }
                if (Count >= 1)
                {
                  for (CFIndex i = 0; i != Count; ++i)
                  {
                    if (CFArrayGetValueAtIndex((CFArrayRef)value[0], i))
                    {
                      if (i < v16) {
                        CFArrayGetValueAtIndex(theArray, i);
                      }
                      operator new();
                    }
                  }
                }
                if (theArray) {
                  CFRelease(theArray);
                }
              }
              else
              {
                uint64_t v6 = 0;
              }
              if (IIODictionary::containsKey((IIODictionary *)v53, *(const __CFString **)gIIO_kCMPhotoDecompressionContainerDescription_ImageSequenceCount))unsigned int v18 = IIODictionary::getUint32ForKey((IIODictionary *)v53, *(const __CFString **)gIIO_kCMPhotoDecompressionContainerDescription_ImageSequenceCount); {
              else
              }
                unsigned int v18 = 0;
              int v19 = IIOImageRead::trustedURL(a2);
              if (v18) {
                int v20 = v19;
              }
              else {
                int v20 = 0;
              }
              if (v20 == 1)
              {
                value[0] = 0;
                GlobalHEIFInfo::setHasHEIFSequence((uint64_t)a2, 1);
                SequenceCFIndex Count = gFunc_CMPhotoDecompressionContainerGetSequenceCount(v57, value);
                int v22 = SequenceCount;
                if (SequenceCount)
                {
                  int v23 = IIOCMErrorString(SequenceCount);
                  _cg_jpeg_mem_term("extractImageInfo", 586, "*** CMPhotoDecompressionContainerGetSequenceCount  err = %s [%d]\n", v23, v22);
                }
                int v24 = gFunc_CMPhotoDecompressionContainerCreateSequenceContainer(v57, 0, (char *)value[0] - 1, &v56);
                int v25 = v24;
                if (v24)
                {
                  unsigned int v26 = IIOCMErrorString(v24);
                  _cg_jpeg_mem_term("extractImageInfo", 592, "*** CMPhotoDecompressionContainerCreateSequenceContainer  err = %s [%d]\n", v26, v25);
                }
                theArradouble y = 0;
                uint64_t v27 = gFunc_CMPhotoDecompressionContainerCreateDictionaryDescription(v56, &theArray);
                uint64_t v6 = v27;
                if (v27)
                {
                  uint64_t v28 = IIOCMErrorString(v27);
                  _cg_jpeg_mem_term("extractImageInfo", 603, "*** CMPhotoDecompressionContainerCreateDictionaryDescription  err = %s [%d]\n", v28, v6);
                }
                if (theArray)
                {
                  CFArrayRef v51 = 0;
                  CFDictionaryGetValueIfPresent(theArray, *(const void **)gIIO_kCMPhotoDecompressionContainerDescription_MainImages, (const void **)&v51);
                  CFIndex v29 = CFArrayGetCount(v51);
                  uint64_t v50 = 0;
                  CFDictionaryGetValueIfPresent(theArray, *(const void **)gIIO_kCMPhotoDecompressionContainerDescription_SequenceTracksDescription, (const void **)&v50);
                  if (v29 >= 1)
                  {
                    for (CFIndex j = 0; j != v29; ++j)
                    {
                      if (CFArrayGetValueAtIndex(v51, j))
                      {
                        CFTypeRef cf = 0;
                        int v31 = gFunc_CMPhotoDecompressionContainerCopyHEIFItemPropertiesForIndexWithOptions(v56, j, 0, &cf);
                        int v32 = v31;
                        if ((v31 + 16994) >= 2 && v31 != 0)
                        {
                          CFDictionaryRef v34 = IIOCMErrorString(v31);
                          _cg_jpeg_mem_term("extractImageInfo", 625, "*** CMPhotoDecompressionContainerCopyHEIFItemPropertiesForIndexWithOptions  err = %s [%d]\n", v34, v32);
                        }
                        operator new();
                      }
                    }
                  }
                  CFRelease(theArray);
                }
                if (v56)
                {
                  CFRelease(v56);
                  CFTypeRef v56 = 0;
                }
              }
              else
              {
                value[0] = 0;
                CFDictionaryGetValueIfPresent(theDict, *(const void **)gIIO_kCMPhotoDecompressionContainerDescription_MainImages, (const void **)value);
                if (value[0])
                {
                  CFIndex v35 = CFArrayGetCount((CFArrayRef)value[0]);
                  if (v35 >= 1)
                  {
                    for (CFIndex k = 0; k != v35; ++k)
                    {
                      if (CFArrayGetValueAtIndex((CFArrayRef)value[0], k))
                      {
                        LODWORD(v51) = 0;
                        theArradouble y = 0;
                        int v37 = gFunc_CMPhotoDecompressionContainerCopyHEIFItemPropertiesForIndexWithOptions(v57, k, 0, &theArray);
                        int v38 = v37;
                        if ((v37 + 16994) >= 2 && v37 != 0)
                        {
                          uint64_t v40 = IIOCMErrorString(v37);
                          _cg_jpeg_mem_term("extractImageInfo", 668, "*** CMPhotoDecompressionContainerCopyHEIFItemPropertiesForIndexWithOptions  err = %s [%d]\n", v40, v38);
                        }
                        ImageGeometryForIndexWithuint64_t Options = gFunc_CMPhotoDecompressionContainerGetImageGeometryForIndexWithOptions(v57, k, 0, 0, 0, &v51);
                        int v42 = ImageGeometryForIndexWithOptions;
                        if (ImageGeometryForIndexWithOptions != -16993 && ImageGeometryForIndexWithOptions != 0)
                        {
                          float v44 = IIOCMErrorString(ImageGeometryForIndexWithOptions);
                          _cg_jpeg_mem_term("extractImageInfo", 674, "*** CMPhotoDecompressionContainerGetImageGeometryForIndexWithOptions  err = %s [%d]\n", v44, v42);
                        }
                        operator new();
                      }
                    }
                  }
                }
              }
              theArradouble y = 0;
              CFDictionaryGetValueIfPresent(theDict, *(const void **)gIIO_kCMPhotoDecompressionContainerDescription_PrimaryImageIndex, (const void **)&theArray);
              if (theArray)
              {
                memset(value, 0, sizeof(value));
                IIONumber::IIONumber((IIONumber *)value, theArray);
                unsigned int v45 = IIONumber::uint32Num((IIONumber *)value);
                GlobalHEIFInfo::setPrimaryImageIndex((uint64_t)a2, v45);
                IIONumber::~IIONumber((IIONumber *)value);
              }
              IIODictionary::~IIODictionary((IIODictionary *)v53);
            }
            if (theDict) {
              CFRelease(theDict);
            }
            CFRelease(v57);
          }
        }
        else
        {
          uint64_t v6 = 0;
        }
      }
      gFunc_CMPhotoDecompressionSessionFlushCachedBuffers(v63[0], 0, 0, v8);
      CFRelease(v63[0]);
      if (v12) {
        CFRelease(v12);
      }
    }
  }
  IIOScanner::~IIOScanner((IIOScanner *)&v58);
  return v6;
}

void sub_1885FC578()
{
}

void sub_1885FC594()
{
}

void sub_1885FC5C8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  va_start(va1, a10);
  va_start(va, a10);
  uint64_t v11 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  uint64_t v15 = va_arg(va1, void);
  uint64_t v16 = va_arg(va1, void);
  uint64_t v17 = va_arg(va1, void);
  uint64_t v18 = va_arg(va1, void);
  IIODictionary::~IIODictionary((IIODictionary *)va);
  IIOScanner::~IIOScanner((IIOScanner *)va1);
  _Unwind_Resume(a1);
}

uint64_t GlobalHEIFInfo::getNumberOfMainImages(GlobalHEIFInfo *this)
{
  uint64_t v1 = (*((void *)this + 2) - *((void *)this + 1)) >> 3;
  if (*((unsigned char *)this + 68)) {
    return v1;
  }
  else {
    return v1 != 0;
  }
}

uint64_t IIOCreateCMPhotoDecompressionSession(uint64_t a1)
{
  return gFunc_CMPhotoDecompressionSessionCreate(*MEMORY[0x1E4F1CF80], 0, a1);
}

uint64_t IIONumber::uint32Num(IIONumber *this)
{
  unsigned int valuePtr = 0;
  CFNumberRef v2 = (const __CFNumber *)*((void *)this + 2);
  if (!v2) {
    goto LABEL_9;
  }
  if (CFNumberGetValue(v2, kCFNumberSInt32Type, &valuePtr)) {
    return valuePtr;
  }
  uint64_t v5 = 0;
  if (CFNumberGetValue(*((CFNumberRef *)this + 2), kCFNumberLongType, &v5)) {
    return v5;
  }
  if (CFNumberIsFloatType(*((CFNumberRef *)this + 2)))
  {
    double v4 = 0.0;
    if (CFNumberGetValue(*((CFNumberRef *)this + 2), kCFNumberDoubleType, &v4)) {
      return v4;
    }
  }
LABEL_9:
  LogError("uint32Num", 350, "CFNumberGetValue/uint32_t failed\n");
  return 0;
}

uint64_t GlobalHEIFInfo::shouldExposeMultiFrameContents(GlobalHEIFInfo *this)
{
  return *((unsigned __int8 *)this + 68);
}

uint64_t GlobalHEIFInfo::getPrimaryImageIndex(GlobalHEIFInfo *this)
{
  return *((unsigned int *)this + 16);
}

uint64_t GlobalHEIFInfo::setPrimaryImageIndex(uint64_t this, unsigned int a2)
{
  if (a2 < (unint64_t)((uint64_t)(*(void *)(this + 16) - *(void *)(this + 8)) >> 3)) {
    *(_DWORD *)(this + 64) = a2;
  }
  return this;
}

void GlobalHEIFInfo::addHEIFMainImage(GlobalHEIFInfo *this, HEIFMainImage *a2)
{
  unint64_t v6 = *((void *)this + 3);
  double v4 = (char *)this + 24;
  unint64_t v5 = v6;
  uint64_t v7 = (void *)*((void *)v4 - 1);
  if ((unint64_t)v7 >= v6)
  {
    float v9 = (void **)(v4 - 16);
    uint64_t v10 = *((void *)v4 - 2);
    uint64_t v11 = ((uint64_t)v7 - v10) >> 3;
    if ((unint64_t)(v11 + 1) >> 61) {
      std::vector<IIOTag *>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v12 = v5 - v10;
    uint64_t v13 = v12 >> 2;
    if (v12 >> 2 <= (unint64_t)(v11 + 1)) {
      uint64_t v13 = v11 + 1;
    }
    if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v14 = v13;
    }
    if (v14) {
      uint64_t v15 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<IIOTag *>>((uint64_t)v4, v14);
    }
    else {
      uint64_t v15 = 0;
    }
    uint64_t v16 = &v15[8 * v11];
    uint64_t v17 = &v15[8 * v14];
    *(void *)uint64_t v16 = a2;
    __n128 v8 = v16 + 8;
    int v19 = (char *)*((void *)this + 1);
    uint64_t v18 = (char *)*((void *)this + 2);
    if (v18 != v19)
    {
      do
      {
        uint64_t v20 = *((void *)v18 - 1);
        v18 -= 8;
        *((void *)v16 - 1) = v20;
        v16 -= 8;
      }
      while (v18 != v19);
      uint64_t v18 = (char *)*v9;
    }
    *((void *)this + 1) = v16;
    *((void *)this + 2) = v8;
    *((void *)this + 3) = v17;
    if (v18) {
      operator delete(v18);
    }
  }
  else
  {
    *uint64_t v7 = a2;
    __n128 v8 = v7 + 1;
  }
  *((void *)this + 2) = v8;
}

uint64_t HEIFMainImage::height(HEIFMainImage *this)
{
  return *((unsigned int *)this + 42);
}

uint64_t HEIFMainImage::width(HEIFMainImage *this)
{
  return *((unsigned int *)this + 41);
}

uint64_t HEIFMainImage::getNumberOfAuxImages(HEIFMainImage *this)
{
  return (*((void *)this + 5) - *((void *)this + 4)) >> 3;
}

void HEIFMainImage::extractISO5Metadata(HEIFMainImage *this, IIODictionary *a2)
{
  CFDictionaryRef ObjectForKey = IIODictionary::getObjectForKey(a2, @"AmbientViewingEnvironment");
  if (ObjectForKey)
  {
    uint64_t v9 = 0;
    uint64_t v10 = 0;
    uint64_t v11 = 0;
    IIODictionary::IIODictionary((IIODictionary *)&v9, ObjectForKey);
    *((float *)this + 51) = (float)IIODictionary::getUint32ForKey((IIODictionary *)&v9, @"AmbientIlluminance")/ 10000.0;
    *((float *)this + 52) = (float)IIODictionary::getUint32ForKey((IIODictionary *)&v9, @"AmbientLightX")/ 50000.0;
    *((float *)this + 53) = (float)IIODictionary::getUint32ForKey((IIODictionary *)&v9, @"AmbientLightY")/ 50000.0;
    IIODictionary::~IIODictionary((IIODictionary *)&v9);
  }
  CFDictionaryRef v5 = IIODictionary::getObjectForKey(a2, @"ContentLightLevelInfo");
  if (!v5)
  {
    CFDictionaryRef v7 = IIODictionary::getObjectForKey(a2, @"MasteringDisplayColorVolume");
    float v6 = 0.0;
    if (!v7) {
      goto LABEL_14;
    }
    goto LABEL_7;
  }
  uint64_t v9 = 0;
  uint64_t v10 = 0;
  uint64_t v11 = 0;
  IIODictionary::IIODictionary((IIODictionary *)&v9, v5);
  *((float *)this + 54) = (float)IIODictionary::getUint32ForKey((IIODictionary *)&v9, @"MaxContentLightLevel");
  *((float *)this + 55) = (float)IIODictionary::getUint32ForKey((IIODictionary *)&v9, @"MaxPicAverageLightLevel");
  float v6 = *((float *)this + 54);
  IIODictionary::~IIODictionary((IIODictionary *)&v9);
  CFDictionaryRef v7 = IIODictionary::getObjectForKey(a2, @"MasteringDisplayColorVolume");
  float v8 = v6;
  if (v7)
  {
LABEL_7:
    uint64_t v9 = 0;
    uint64_t v10 = 0;
    uint64_t v11 = 0;
    IIODictionary::IIODictionary((IIODictionary *)&v9, v7);
    *((float *)this + 58) = (float)IIODictionary::getUint32ForKey((IIODictionary *)&v9, @"DisplayPrimariesXB")/ 50000.0;
    *((float *)this + 56) = (float)IIODictionary::getUint32ForKey((IIODictionary *)&v9, @"DisplayPrimariesXG")/ 50000.0;
    *((float *)this + 60) = (float)IIODictionary::getUint32ForKey((IIODictionary *)&v9, @"DisplayPrimariesXR")/ 50000.0;
    *((float *)this + 59) = (float)IIODictionary::getUint32ForKey((IIODictionary *)&v9, @"DisplayPrimariesYB")/ 50000.0;
    *((float *)this + 57) = (float)IIODictionary::getUint32ForKey((IIODictionary *)&v9, @"DisplayPrimariesYG")/ 50000.0;
    *((float *)this + 61) = (float)IIODictionary::getUint32ForKey((IIODictionary *)&v9, @"DisplayPrimariesYR")/ 50000.0;
    *((float *)this + 64) = (float)IIODictionary::getUint32ForKey((IIODictionary *)&v9, @"MaxDisplayMasteringLuminance")/ 10000.0;
    *((float *)this + 65) = (float)IIODictionary::getUint32ForKey((IIODictionary *)&v9, @"MinDisplayMasteringLuminance")/ 10000.0;
    *((float *)this + 62) = (float)IIODictionary::getUint32ForKey((IIODictionary *)&v9, @"WhitePointX")/ 50000.0;
    *((float *)this + 63) = (float)IIODictionary::getUint32ForKey((IIODictionary *)&v9, @"WhitePointY")/ 50000.0;
    float v8 = *((float *)this + 64);
    IIODictionary::~IIODictionary((IIODictionary *)&v9);
    if (v5 && v8 >= v6) {
      float v8 = v6;
    }
  }
  if (v8 <= 0.0) {
    return;
  }
  if ((float)(v8 / 203.0) >= 1.0) {
    float v6 = v8 / 203.0;
  }
  else {
    float v6 = 1.0;
  }
LABEL_14:
  *((float *)this + 66) = v6;
}

void sub_1885FCB0C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  IIODictionary::~IIODictionary((IIODictionary *)va);
  _Unwind_Resume(a1);
}

uint64_t HEIFMainImage::getColorSpaceName(HEIFMainImage *this)
{
  return *((void *)this + 36);
}

uint64_t HEIFGroupItem::getStereoAggressorCount(HEIFGroupItem *this)
{
  return (*((void *)this + 8) - *((void *)this + 7)) >> 3;
}

uint64_t IIOImageRead::trustedURL(IIOImageRead *this)
{
  return *((unsigned __int8 *)this + 71);
}

void IIO_Reader_HEIF::~IIO_Reader_HEIF(IIO_Reader_HEIF *this, uint64_t a2, const char *a3)
{
  _cg_jpeg_mem_term(this, a2, a3);

  JUMPOUT(0x18C11C0E0);
}

void IIO_Reader_PVR::~IIO_Reader_PVR(IIO_Reader_PVR *this, uint64_t a2, const char *a3)
{
  _cg_jpeg_mem_term(this, a2, a3);

  JUMPOUT(0x18C11C0E0);
}

void IIO_Reader_BC::~IIO_Reader_BC(IIO_Reader_BC *this, uint64_t a2, const char *a3)
{
  _cg_jpeg_mem_term(this, a2, a3);

  JUMPOUT(0x18C11C0E0);
}

void IIO_Reader_ASTC::~IIO_Reader_ASTC(IIO_Reader_ASTC *this, uint64_t a2, const char *a3)
{
  _cg_jpeg_mem_term(this, a2, a3);

  JUMPOUT(0x18C11C0E0);
}

void IIO_Reader_ETC::~IIO_Reader_ETC(IIO_Reader_ETC *this, uint64_t a2, const char *a3)
{
  _cg_jpeg_mem_term(this, a2, a3);

  JUMPOUT(0x18C11C0E0);
}

void IIO_Reader_OpenEXR::~IIO_Reader_OpenEXR(IIO_Reader_OpenEXR *this, uint64_t a2, const char *a3)
{
  _cg_jpeg_mem_term(this, a2, a3);

  JUMPOUT(0x18C11C0E0);
}

void IIO_Reader_KTX2::~IIO_Reader_KTX2(IIO_Reader_KTX2 *this, uint64_t a2, const char *a3)
{
  _cg_jpeg_mem_term(this, a2, a3);

  JUMPOUT(0x18C11C0E0);
}

void IIO_Reader_ICNS::~IIO_Reader_ICNS(IIO_Reader_ICNS *this, uint64_t a2, const char *a3)
{
  _cg_jpeg_mem_term(this, a2, a3);

  JUMPOUT(0x18C11C0E0);
}

void IIO_Reader_TGA::~IIO_Reader_TGA(IIO_Reader_TGA *this, uint64_t a2, const char *a3)
{
  _cg_jpeg_mem_term(this, a2, a3);

  JUMPOUT(0x18C11C0E0);
}

void IIO_Reader_RAD::~IIO_Reader_RAD(IIO_Reader_RAD *this, uint64_t a2, const char *a3)
{
  _cg_jpeg_mem_term(this, a2, a3);

  JUMPOUT(0x18C11C0E0);
}

void IIO_Reader_PSD::~IIO_Reader_PSD(IIO_Reader_PSD *this, uint64_t a2, const char *a3)
{
  _cg_jpeg_mem_term(this, a2, a3);

  JUMPOUT(0x18C11C0E0);
}

void IIO_Reader_PDF::~IIO_Reader_PDF(IIO_Reader_PDF *this, uint64_t a2, const char *a3)
{
  _cg_jpeg_mem_term(this, a2, a3);

  JUMPOUT(0x18C11C0E0);
}

void IIO_Reader_PBM::~IIO_Reader_PBM(IIO_Reader_PBM *this, uint64_t a2, const char *a3)
{
  _cg_jpeg_mem_term(this, a2, a3);

  JUMPOUT(0x18C11C0E0);
}

void IIO_Reader_AI::~IIO_Reader_AI(IIO_Reader_AI *this, uint64_t a2, const char *a3)
{
  _cg_jpeg_mem_term(this, a2, a3);

  JUMPOUT(0x18C11C0E0);
}

void IIO_Reader_KTX::~IIO_Reader_KTX(IIO_Reader_KTX *this, uint64_t a2, const char *a3)
{
  _cg_jpeg_mem_term(this, a2, a3);

  JUMPOUT(0x18C11C0E0);
}

void IIO_Reader_ATX::~IIO_Reader_ATX(IIO_Reader_ATX *this, uint64_t a2, const char *a3)
{
  _cg_jpeg_mem_term(this, a2, a3);

  JUMPOUT(0x18C11C0E0);
}

void IIO_Reader_CUR::~IIO_Reader_CUR(IIO_Reader_CUR *this, uint64_t a2, const char *a3)
{
  _cg_jpeg_mem_term(this, a2, a3);

  JUMPOUT(0x18C11C0E0);
}

void IIO_Reader_AppleJPEG::~IIO_Reader_AppleJPEG(IIO_Reader_AppleJPEG *this, uint64_t a2, const char *a3)
{
  _cg_jpeg_mem_term(this, a2, a3);

  JUMPOUT(0x18C11C0E0);
}

void IIO_Reader_LibJPEG::~IIO_Reader_LibJPEG(IIO_Reader_LibJPEG *this, uint64_t a2, const char *a3)
{
  _cg_jpeg_mem_term(this, a2, a3);

  JUMPOUT(0x18C11C0E0);
}

void IIO_Reader_WebP::~IIO_Reader_WebP(IIO_Reader_WebP *this, uint64_t a2, const char *a3)
{
  _cg_jpeg_mem_term(this, a2, a3);

  JUMPOUT(0x18C11C0E0);
}

void IIO_Reader_TIFF::~IIO_Reader_TIFF(IIO_Reader_TIFF *this, uint64_t a2, const char *a3)
{
  _cg_jpeg_mem_term(this, a2, a3);

  JUMPOUT(0x18C11C0E0);
}

void IIO_Reader_PNG::~IIO_Reader_PNG(IIO_Reader_PNG *this, uint64_t a2, const char *a3)
{
  _cg_jpeg_mem_term(this, a2, a3);

  JUMPOUT(0x18C11C0E0);
}

void IIO_Reader_MPO::~IIO_Reader_MPO(IIO_Reader_MPO *this, uint64_t a2, const char *a3)
{
  _cg_jpeg_mem_term(this, a2, a3);

  JUMPOUT(0x18C11C0E0);
}

void IIO_Reader_JP2::~IIO_Reader_JP2(IIO_Reader_JP2 *this, uint64_t a2, const char *a3)
{
  _cg_jpeg_mem_term(this, a2, a3);

  JUMPOUT(0x18C11C0E0);
}

void IIO_Reader_ICO::~IIO_Reader_ICO(IIO_Reader_ICO *this, uint64_t a2, const char *a3)
{
  _cg_jpeg_mem_term(this, a2, a3);

  JUMPOUT(0x18C11C0E0);
}

void IIO_Reader_GIF::~IIO_Reader_GIF(IIO_Reader_GIF *this, uint64_t a2, const char *a3)
{
  _cg_jpeg_mem_term(this, a2, a3);

  JUMPOUT(0x18C11C0E0);
}

void IIO_Reader_BMP::~IIO_Reader_BMP(IIO_Reader_BMP *this, uint64_t a2, const char *a3)
{
  _cg_jpeg_mem_term(this, a2, a3);

  JUMPOUT(0x18C11C0E0);
}

const char *LogWarning(const char *result, int a2, const char *a3, ...)
{
  va_start(va, a3);
  if (gImageIOLogProc) {
    return (const char *)gImageIOLogProc(0, 0, result, a2, a3, va);
  }
  return result;
}

CFStringRef CGImageSourceGetType(CGImageSourceRef isrc)
{
  kdebug_trace();
  IIOInitDebugFlags();
  unsigned int v2 = (gIIODebugFlags >> 12) & 3;
  if (v2) {
    ImageIODebugOptions(v2, "A", "CGImageSourceGetType", isrc, 0, -1, 0);
  }
  if (!isrc)
  {
    LogError("CGImageSourceGetType", 4848, "*** ERROR: CGImageSourceGetType: source is nil\n");
LABEL_23:
    CFStringRef v6 = 0;
    goto LABEL_19;
  }
  CFTypeID v3 = CFGetTypeID(isrc);
  if (CGImageSourceGetTypeID::once != -1) {
    dispatch_once(&CGImageSourceGetTypeID::once, &__block_literal_global_164);
  }
  if (v3 != CGImageSourceGetTypeID::id)
  {
    LogError("CGImageSourceGetType", 4849, "*** ERROR: CGImageSourceGetType: source is not a CGImageSourceRef\n");
    goto LABEL_23;
  }
  uint64_t v4 = *((void *)isrc + 3);
  if (!v4)
  {
    CFStringRef v6 = 0;
    goto LABEL_19;
  }
  if (*(unsigned char *)(v4 + 89))
  {
    LogError("CGImageSourceGetType", 4854, "*** ERROR: invalid CGImageSourceRef (non-matching hint)\n");
    goto LABEL_23;
  }
  pthread_mutex_lock((pthread_mutex_t *)(v4 + 224));
  if (IIOImageSource::isProxy((IIOImageSource *)v4))
  {
    CFDictionaryRef Type = IIOImageSource::proxyGetType((IIODictionary **)v4);
  }
  else
  {
    if (!IIOImageSource::bindToReader((IIOImageSource *)v4))
    {
      CFStringRef v6 = 0;
      goto LABEL_16;
    }
    CFDictionaryRef Type = (const __CFDictionary *)IIO_Reader::utType(*(IIO_Reader **)(v4 + 104));
  }
  CFStringRef v6 = (const __CFString *)Type;
LABEL_16:
  CFDictionaryRef v7 = *(IIO_Reader **)(v4 + 104);
  if (v7) {
    IIO_Reader::osType(v7);
  }
  pthread_mutex_unlock((pthread_mutex_t *)(v4 + 224));
LABEL_19:
  kdebug_trace();
  return v6;
}

uint64_t _CGImagePixelDataProviderFinalize(void *a1)
{
  atomic_fetch_add_explicit(&gPDPCount, 0xFFFFFFFFFFFFFFFFLL, memory_order_relaxed);
  uint64_t result = a1[3];
  if (result) {
    uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
  }
  a1[2] = 0;
  a1[3] = 0;
  return result;
}

void IIOImagePixelDataProvider::~IIOImagePixelDataProvider(IIOImagePixelDataProvider *this)
{
  IIOImagePixelDataProvider::~IIOImagePixelDataProvider(this);

  JUMPOUT(0x18C11C0E0);
}

{
  CGImage *v2;
  CGColorSpace *v3;
  const void *v4;
  const void *v5;
  const void *v6;
  vImageConverter *v7;
  void *v8;

  *(void *)this = &unk_1ED4E5608;
  if (*((void *)this + 31)) {
    CGAccessSessionRelease();
  }
  unsigned int v2 = (CGImage *)*((void *)this + 2);
  if (v2) {
    CGImageRelease(v2);
  }
  CFTypeID v3 = (CGColorSpace *)*((void *)this + 11);
  if (v3) {
    CGColorSpaceRelease(v3);
  }
  uint64_t v4 = (const void *)*((void *)this + 26);
  if (v4) {
    CFRelease(v4);
  }
  CFDictionaryRef v5 = (const void *)*((void *)this + 24);
  if (v5) {
    CFRelease(v5);
  }
  if (*((void *)this + 25)) {
    CGImageBlockSetRelease();
  }
  CFStringRef v6 = (const void *)*((void *)this + 27);
  if (v6) {
    CFRelease(v6);
  }
  CFDictionaryRef v7 = (vImageConverter *)*((void *)this + 15);
  if (v7) {
    vImageConverter_Release(v7);
  }
  float v8 = (void *)*((void *)this + 29);
  if (v8) {
    free(v8);
  }
}

void ___ZN17IIO_WriterHandler16GetWriterHandlerEv_block_invoke()
{
}

void sub_1885FD4C8(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x81C4018A671A6);
  _Unwind_Resume(a1);
}

void IIO_WriterHandler::IIO_WriterHandler(IIO_WriterHandler *this)
{
  *(void *)this = &unk_1ED4E4150;
  *((void *)this + 1) = 0;
  *((void *)this + 2) = 0;
  *((void *)this + 3) = 0;
  CFAbsoluteTimeGetCurrent();
  IIO_WriterHandler::buildWriterList(this);
}

void sub_1885FD598(_Unwind_Exception *exception_object)
{
  uint64_t v4 = *v2;
  if (*v2)
  {
    *(void *)(v1 + 16) = v4;
    operator delete(v4);
  }
  _Unwind_Resume(exception_object);
}

void IIO_WriterHandler::buildWriterList(IIO_WriterHandler *this)
{
}

uint64_t IIOLookupISR()
{
  return 0;
}

void CreateWriter_HEIC_JPEG(void)
{
}

void sub_1885FE7CC(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10E1C409ED2048DLL);
  _Unwind_Resume(a1);
}

uint64_t IIO_Writer::setAddToTypeIdentifiers(uint64_t this, char a2)
{
  *(unsigned char *)(this + 44) = a2;
  return this;
}

void CreateWriter_AppleJPEG(void)
{
}

void sub_1885FE870(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10E1C409ED2048DLL);
  _Unwind_Resume(a1);
}

uint64_t CreateWriter_HEICS(void)
{
  if (gHEIF_HEVC_EncodingSupported) {
    operator new();
  }
  return 0;
}

void sub_1885FE938(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10E1C409ED2048DLL);
  _Unwind_Resume(a1);
}

void CreateWriter_TIFF(void)
{
}

void sub_1885FE9D4(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10E1C409ED2048DLL);
  _Unwind_Resume(a1);
}

void CreateWriter_KTX2(void)
{
}

void sub_1885FEA48(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10E1C4021BA897DLL);
  _Unwind_Resume(a1);
}

void CreateWriter_ICNS(void)
{
}

void sub_1885FEABC(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10E1C4021BA897DLL);
  _Unwind_Resume(a1);
}

uint64_t CreateWriter_HEIC(void)
{
  if (gHEIF_HEVC_EncodingSupported) {
    operator new();
  }
  return 0;
}

void sub_1885FEB74(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10E1C409ED2048DLL);
  _Unwind_Resume(a1);
}

uint64_t CreateWriter_AVCI(void)
{
  if (gHEIF_AVCI_EncodingSupported) {
    operator new();
  }
  return 0;
}

void sub_1885FEC3C(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10E1C409ED2048DLL);
  _Unwind_Resume(a1);
}

void CreateReader_AI(void)
{
}

void sub_1885FECE8(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10D1C405DC8C238);
  _Unwind_Resume(a1);
}

void CreateReader_PDF(void)
{
}

void sub_1885FED94(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10D1C405DC8C238);
  _Unwind_Resume(a1);
}

void CreateReader_KTX2_BC(void)
{
}

void sub_1885FEE40(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10D1C405DC8C238);
  _Unwind_Resume(a1);
}

uint64_t IIO_Reader::setAddToTypeIdentifiers(uint64_t this, char a2)
{
  *(unsigned char *)(this + 48) = a2;
  return this;
}

void CreateReader_KTX2(void)
{
}

void sub_1885FEEE8(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10D1C405DC8C238);
  _Unwind_Resume(a1);
}

uint64_t CreateReader_HEIC_JPEG(void)
{
  if (gHEIF_JPEG_DecodingSupported) {
    operator new();
  }
  return 0;
}

void sub_1885FEFB8(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10D1C405DC8C238);
  _Unwind_Resume(a1);
}

void IIO_Reader::IIO_Reader(IIO_Reader *this, const __CFString *const *a2, const char *a3, int a4, uint64_t a5, uint64_t a6)
{
  *(void *)this = &unk_1ED4DE470;
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((_DWORD *)this + 6) = a4;
  *((void *)this + 4) = a5;
  *((void *)this + 5) = a6;
  *((unsigned char *)this + 48) = 1;
}

uint64_t CreateReader_AVCI(void)
{
  if (gHEIF_AVCI_DecodingSupported) {
    operator new();
  }
  return 0;
}

void sub_1885FF0C0(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10D1C405DC8C238);
  _Unwind_Resume(a1);
}

uint64_t CreateReader_AVIF(void)
{
  if (gHEIF_AVIF_DecodingSupported) {
    operator new();
  }
  return 0;
}

void sub_1885FF194(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10D1C405DC8C238);
  _Unwind_Resume(a1);
}

uint64_t CreateReader_AVIS(void)
{
  if (gHEIF_AVIF_DecodingSupported) {
    operator new();
  }
  return 0;
}

void sub_1885FF268(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10D1C405DC8C238);
  _Unwind_Resume(a1);
}

uint64_t CreateReader_HEIF(void)
{
  if (gHEIF_JPEG_DecodingSupported) {
    operator new();
  }
  return 0;
}

void sub_1885FF33C(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10D1C405DC8C238);
  _Unwind_Resume(a1);
}

void IIODetermineHEIFSupport(void)
{
  IIO_LoadCMPhotoSymbols();
  if (gHEIFDecoderEncoderCheckInitOnce != -1)
  {
    dispatch_once(&gHEIFDecoderEncoderCheckInitOnce, &__block_literal_global_40);
  }
}

void IIO_LoadCMPhotoSymbols()
{
  if (gLoadCMPhotoSymbolsInitOnce != -1) {
    dispatch_once(&gLoadCMPhotoSymbolsInitOnce, &__block_literal_global_4_0);
  }
}

void CreateWriter_ASTC(void)
{
}

void sub_1885FF450(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10E1C409ED2048DLL);
  _Unwind_Resume(a1);
}

void CreateWriter_TGA(void)
{
}

void sub_1885FF4EC(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10E1C409ED2048DLL);
  _Unwind_Resume(a1);
}

void CreateWriter_PVR(void)
{
}

void sub_1885FF560(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10E1C4021BA897DLL);
  _Unwind_Resume(a1);
}

uint64_t IIOGeneric_Writer::IIOGeneric_Writer(uint64_t a1, uint64_t *a2, int a3)
{
  uint64_t v4 = *a2;
  uint64_t v5 = a2[9];
  int v6 = *((_DWORD *)a2 + 20);
  *(_DWORD *)(a1 + 24) = a3;
  *(void *)(a1 + 32) = v5;
  *(_DWORD *)(a1 + 40) = v6;
  *(unsigned char *)(a1 + 44) = 1;
  *(void *)(a1 + 8) = v4;
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = &unk_1ED4E40C0;
  uint64_t v7 = a2[11];
  *(void *)(a1 + 48) = v7;
  if (!v7) {
    LogError("IIOGeneric_Writer", 190, "*** ERROR: IIOGeneric_Writer::IIOGeneric_Writer called with invalid pluginInfo (writeProc is nil)");
  }
  return a1;
}

void CreateWriter_PSD(void)
{
}

void sub_1885FF660(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10E1C4021BA897DLL);
  _Unwind_Resume(a1);
}

void CreateWriter_PNG(void)
{
}

void sub_1885FF6D4(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10E1C4021BA897DLL);
  _Unwind_Resume(a1);
}

void CreateWriter_PDF(void)
{
}

void sub_1885FF770(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10E1C409ED2048DLL);
  _Unwind_Resume(a1);
}

void IIO_Writer::IIO_Writer(IIO_Writer *this, const __CFString *const *a2, int a3, uint64_t a4, int a5)
{
  *(void *)this = &unk_1ED4DE590;
  *((void *)this + 1) = a2;
  *((_DWORD *)this + 6) = a3;
  *((void *)this + 4) = a4;
  *((_DWORD *)this + 10) = a5;
  *((unsigned char *)this + 44) = 1;
  *((void *)this + 2) = 0;
}

void CreateWriter_PBM(void)
{
}

void sub_1885FF81C(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10E1C4021BA897DLL);
  _Unwind_Resume(a1);
}

void CreateWriter_KTX(void)
{
}

void sub_1885FF890(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10E1C4021BA897DLL);
  _Unwind_Resume(a1);
}

void CreateWriter_JP2(void)
{
}

void sub_1885FF904(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10E1C4021BA897DLL);
  _Unwind_Resume(a1);
}

void CreateWriter_ICO(void)
{
}

void sub_1885FF9A0(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10E1C409ED2048DLL);
  _Unwind_Resume(a1);
}

void CreateWriter_GIF(void)
{
}

void sub_1885FFA3C(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10E1C409ED2048DLL);
  _Unwind_Resume(a1);
}

void CreateWriter_EXR(void)
{
}

void sub_1885FFAB0(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10E1C4021BA897DLL);
  _Unwind_Resume(a1);
}

void CreateWriter_BMP(void)
{
}

void sub_1885FFB4C(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10E1C409ED2048DLL);
  _Unwind_Resume(a1);
}

void CreateWriter_ATX(void)
{
}

void sub_1885FFBC0(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10E1C4021BA897DLL);
  _Unwind_Resume(a1);
}

void CreateWriter_BC(void)
{
}

void sub_1885FFC5C(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10E1C409ED2048DLL);
  _Unwind_Resume(a1);
}

void __AppleGetCPUCapabilities_block_invoke()
{
  AppleGetCPUCapabilities::gImageIO_cpu_capabilities = MEMORY[0xFFFFFC020];
}

uint64_t _CGImageWriteSessionFinalize(void *a1)
{
  atomic_fetch_add_explicit(&gWriteSessionCount, 0xFFFFFFFFFFFFFFFFLL, memory_order_relaxed);
  uint64_t result = a1[3];
  if (result) {
    uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
  }
  a1[2] = 0;
  a1[3] = 0;
  return result;
}

void IIOImageWriteSession::~IIOImageWriteSession(IIOImageWriteSession *this)
{
  IIOImageWriteSession::~IIOImageWriteSession(this);

  JUMPOUT(0x18C11C0E0);
}

{
  const void *v2;
  const void *v3;
  FILE *v4;
  const void *v5;
  const void *v6;

  *(void *)this = &unk_1ED4E4FD8;
  unsigned int v2 = (const void *)*((void *)this + 2);
  if (v2) {
    CFRelease(v2);
  }
  *((void *)this + 2) = 0;
  CFTypeID v3 = (const void *)*((void *)this + 3);
  if (v3) {
    CFRelease(v3);
  }
  *((void *)this + 3) = 0;
  uint64_t v4 = (FILE *)*((void *)this + 4);
  if (v4)
  {
    if ((gIIODebugFlags & 0x200000000000) != 0)
    {
      ImageIOLog("<<< _CGImageWriteSessionFinalize: [%p] closing FILE* %p\n", this, v4);
      uint64_t v4 = (FILE *)*((void *)this + 4);
    }
    fclose(v4);
    *((unsigned char *)this + 73) = 0;
  }
  *((void *)this + 4) = 0;
  uint64_t v5 = (const void *)*((void *)this + 5);
  if (v5) {
    CFRelease(v5);
  }
  *((void *)this + 5) = 0;
  int v6 = (const void *)*((void *)this + 6);
  if (v6) {
    CFRelease(v6);
  }
  *((void *)this + 6) = 0;
}

void ___ZN12IIOXPCClient15GetIIOXPCClientEv_block_invoke()
{
}

void sub_1885FFE60(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10E1C409FA54CB2);
  _Unwind_Resume(a1);
}

uint64_t ProcessingInstructionHandler(void *a1, const char *__s1, const char *a3)
{
  if (!__s1) {
    ProcessingInstructionHandler();
  }
  uint64_t result = strcmp(__s1, "xpacket");
  if (!result) {
    operator new();
  }
  return result;
}

void sub_1885FFFD0(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10B3C40BB36A753);
  _Unwind_Resume(a1);
}

CFMutableArrayRef IIO_ReaderHandler::copyTypeExtensions(IIO_ReaderHandler *this, const __CFString *a2)
{
  CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
  uint64_t v5 = (IIO_Reader **)*((void *)this + 2);
  int v6 = (IIO_Reader **)*((void *)this + 3);
  if (v5 != v6)
  {
    while (1)
    {
      if (!a2) {
        goto LABEL_5;
      }
      CFComparisonResult v7 = CFStringCompare(a2, @"public.camera-raw-image", 0);
      CFStringRef v8 = (const __CFString *)IIO_Reader::utType(*v5);
      if (v7 == kCFCompareEqualTo) {
        break;
      }
      if (CFEqual(v8, a2)) {
        goto LABEL_5;
      }
LABEL_6:
      if (++v5 == v6) {
        return Mutable;
      }
    }
    if (!CFStringHasSuffix(v8, @"raw-image")) {
      goto LABEL_6;
    }
LABEL_5:
    (*(void (**)(IIO_Reader *, CFMutableArrayRef))(*(void *)*v5 + 136))(*v5, Mutable);
    goto LABEL_6;
  }
  return Mutable;
}

size_t IIO_Reader::addExtensionsToArray(size_t this, __CFArray *a2)
{
  uint64_t v2 = *(void *)(this + 16);
  if (v2)
  {
    this = strlen(*(const char **)(this + 16));
    if (this >= 3)
    {
      uint64_t v4 = (const char *)(v2 + 1);
      this = strcspn(v4, ".");
      if (this)
      {
        CFIndex v5 = this;
        CFAllocatorRef v6 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
        do
        {
          CFStringRef v7 = CFStringCreateWithBytes(v6, (const UInt8 *)v4, v5, 0x600u, 0);
          if (v7)
          {
            CFStringRef v8 = v7;
            v9.CFIndex length = CFArrayGetCount(a2);
            v9.location = 0;
            if (!CFArrayContainsValue(a2, v9, v8)) {
              CFArrayAppendValue(a2, v8);
            }
            CFRelease(v8);
          }
          v4 += v5 + 1;
          this = strcspn(v4, ".");
          CFIndex v5 = this;
        }
        while (this);
      }
    }
  }
  return this;
}

CGImage *CGImageCopySourceData(CGImage *a1)
{
  IIOInitDebugFlags();
  if ((unsigned __int16)gIIODebugFlags >> 14) {
    ImageIODebugOptions((unsigned __int16)gIIODebugFlags >> 14, "S", "CGImageCopySourceData", 0, 0, -1, 0);
  }
  kdebug_trace();
  if (!a1) {
    goto LABEL_11;
  }
  CFDataRef Property = (const __CFData *)CGImageGetProperty();
  *(void *)uint64_t buffer = 0;
  if (Property)
  {
    v9.location = 0;
    v9.CFIndex length = 8;
    CFDataGetBytes(Property, v9, buffer);
    if (!*(void *)buffer) {
      return 0;
    }
    uint64_t Source = (IIOImageRead *)CGImageSourceGetSource(*(uint64_t *)buffer);
    if (Source)
    {
      CFDataRef v4 = IIOImageRead::copyData(Source);
      a1 = v4;
      if (v4) {
        CFDataGetLength(v4);
      }
      goto LABEL_11;
    }
  }
  else
  {
    size_t Width = CGImageGetWidth(a1);
    size_t Height = CGImageGetHeight(a1);
    _cg_jpeg_mem_term("CGImageCopySourceData", 2802, "*** ERROR: cannot get CGImageReadRef from image (%ldx%ld)\n", Width, Height);
  }
  a1 = 0;
LABEL_11:
  kdebug_trace();
  return a1;
}

const __CFData *IIOImageRead::copyData(IIOImageRead *this)
{
  int v13 = 0;
  int v2 = *((unsigned __int8 *)this + 67);
  CFTypeID v3 = (const void *)*((void *)this + 4);
  if (v2)
  {
    if (!v3) {
      return IIOImageRead::createDataWithMappedFile(this, 0, &v13);
    }
    goto LABEL_6;
  }
  if (v3)
  {
LABEL_6:
    return (const __CFData *)CFRetain(v3);
  }
  if (*((_DWORD *)this + 6) != -1)
  {
    size_t v6 = *((void *)this + 10);
    if (v6)
    {
      CFStringRef v7 = (UInt8 *)malloc_type_malloc(v6, 0xFC25250EuLL);
      CFIndex BytesAtOffset = IIOImageRead::getBytesAtOffset(this, v7, 0, *((void *)this + 10));
      CFAllocatorContext v12 = *(CFAllocatorContext *)byte_1ED4F0B88;
      CFAllocatorRef v9 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      CFAllocatorRef v10 = CFAllocatorCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], &v12);
      CFDataRef v4 = CFDataCreateWithBytesNoCopy(v9, v7, BytesAtOffset, v10);
      CFRelease(v10);
      return v4;
    }
    return 0;
  }
  uint64_t v11 = (CGDataProvider *)*((void *)this + 5);
  if (!v11) {
    return 0;
  }

  return CGDataProviderCopyData(v11);
}

void WXMPIterator_Skip_1(void *a1, uint64_t a2, void *a3)
{
  CFStringRef v8 = (XMP_ReadWriteLock *)(a1 + 2);
  XMP_ReadWriteLock::Acquire((pthread_rwlock_t *)(a1 + 2), 1);
  *a3 = 0;
  uint64_t v6 = a1[29];
  if (!v6) {
    __assert_rtn("WXMPIterator_Skip_1", "WXMPIterator.cpp", 164, "thiz->info.xmpObj != __null");
  }
  CFStringRef v7 = (XMP_ReadWriteLock *)(v6 + 16);
  XMP_ReadWriteLock::Acquire((pthread_rwlock_t *)(v6 + 16), 0);
  (*(void (**)(void *, uint64_t))(*a1 + 24))(a1, a2);
  XMP_AutoLock::~XMP_AutoLock(&v7);
  XMP_AutoLock::~XMP_AutoLock(&v8);
}

void sub_18860053C(void *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, XMP_ReadWriteLock *a9)
{
  XMP_AutoLock::~XMP_AutoLock(&a9);
  if (a2 == 3)
  {
    CFAllocatorContext v12 = __cxa_begin_catch(a1);
    *(_DWORD *)(v9 + 32) = *(_DWORD *)v12;
    *(void *)(v9 + 8) = "XMP";
    int v13 = (const char *)*((void *)v12 + 1);
    if (!v13) {
      int v13 = "";
    }
  }
  else
  {
    unint64_t v14 = __cxa_begin_catch(a1);
    if (a2 != 2)
    {
      *(_DWORD *)(v9 + 32) = 14;
      *(void *)uint64_t v9 = "Caught unknown exception";
      __cxa_end_catch();
LABEL_10:
      JUMPOUT(0x1886004FCLL);
    }
    *(_DWORD *)(v9 + 32) = 13;
    uint64_t v15 = (*(uint64_t (**)(void *))(*(void *)v14 + 16))(v14);
    int v13 = "";
    if (v15) {
      int v13 = (const char *)v15;
    }
  }
  *(void *)uint64_t v9 = v13;
  __cxa_end_catch();
  goto LABEL_10;
}

void sub_188600614(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  XMP_AutoLock::~XMP_AutoLock((XMP_ReadWriteLock **)va);
  _Unwind_Resume(a1);
}

void XMPIterator::Skip(XMPIterator *this, unsigned int a2)
{
  if (!a2)
  {
    exception = __cxa_allocate_exception(0x18uLL);
    *(_DWORD *)exception = 103;
    CFDataRef v4 = "Must specify what to skip";
    goto LABEL_12;
  }
  if (a2 >= 4)
  {
    exception = __cxa_allocate_exception(0x18uLL);
    *(_DWORD *)exception = 103;
    CFDataRef v4 = "Undefined options";
LABEL_12:
    exception[1] = v4;
    *((unsigned char *)exception + 16) = 0;
  }
  if (a2)
  {
    *(unsigned char *)(*((void *)this + 33) + 88) = 3;
  }
  else if ((a2 & 2) != 0)
  {
    *((void *)this + 33) = *((void *)this + 34);
    int v2 = (XMPIterator *)((char *)this + 224);
    AdvanceIterPos(v2);
  }
}

void ___ZL21sDefaultErrorCallbackv_block_invoke()
{
}

void ___ZL21sDefaultErrorCallbackv_block_invoke_0()
{
}

void IIOIOSurfaceWrapper_CIF10::~IIOIOSurfaceWrapper_CIF10(IIOIOSurfaceWrapper_CIF10 *this)
{
  IIOIOSurfaceWrapperBase::~IIOIOSurfaceWrapperBase(this);

  JUMPOUT(0x18C11C0E0);
}

void IIOIOSurfaceWrapperBase::~IIOIOSurfaceWrapperBase(IIOIOSurfaceWrapperBase *this)
{
  *(void *)this = &unk_1ED4B4230;
  pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 8));
  int v2 = (__IOSurface *)*((void *)this + 9);
  if (v2)
  {
    if (*((void *)this + 10))
    {
      CGColorSpaceRelease(*((CGColorSpaceRef *)this + 10));
      int v2 = (__IOSurface *)*((void *)this + 9);
    }
    CFTypeRef v3 = IOSurfaceCopyValue(v2, @"com.apple.ImageIO.ImageIO_Malloced");
    if (v3)
    {
      IOSurfaceRemoveValue(*((IOSurfaceRef *)this + 9), @"com.apple.ImageIO.ImageIO_Malloced");
      BaseAddress = IOSurfaceGetBaseAddress(*((IOSurfaceRef *)this + 9));
      _ImageIO_Free((unint64_t)BaseAddress, 0);
      CFRelease(v3);
    }
    IOSurfaceDecrementUseCount(*((IOSurfaceRef *)this + 9));
    IIO_IOSurfaceRelease(*((__IOSurface **)this + 9));
  }
}

{
  uint64_t vars8;

  IIOIOSurfaceWrapperBase::~IIOIOSurfaceWrapperBase(this);

  JUMPOUT(0x18C11C0E0);
}

uint64_t HEIFReadPlugin::copyIOSurfaceImp(uint64_t a1, uint64_t a2, __CFDictionary *a3, __IOSurface **a4, uint64_t *a5)
{
  v70[0] = 0;
  memset(v69, 0, sizeof(v69));
  IIODictionary::IIODictionary((IIODictionary *)v69, a3);
  IIO_LoadHEIFSymbols();
  uint64_t v9 = *(IIOImageRead ***)(a1 + 24);
  if (!v9)
  {
    uint64_t updated = 4294967246;
    goto LABEL_12;
  }
  BOOL v10 = IIOImageReadSession::mapData(v9);
  CFTypeRef v68 = 0;
  if (!gFunc_CMPhotoDecompressionSessionCreate) {
    _cg_jpeg_mem_term("copyIOSurfaceImp", 3261, "*** CMPhotoDecompressionSessionCreate symbol not found\n");
  }
  uint64_t v11 = IIOCreateCMPhotoDecompressionSession((uint64_t)&v68);
  uint64_t updated = v11;
  if (v11)
  {
    int v13 = IIOCMErrorString(v11);
    _cg_jpeg_mem_term("copyIOSurfaceImp", 3268, "*** CMPhotoDecompressionSessionCreate  err = %s [%d]\n", v13, updated);
    goto LABEL_6;
  }
  CFTypeRef cf = 0;
  CFTypeRef v67 = 0;
  int v65 = 0;
  long long v64 = 0;
  CFIndex Size = IIOImageReadSession::getSize(*(IIOImageReadSession **)(a1 + 24));
  uint64_t v17 = IIOImageReadSession::retainBytePointer(*(IIOImageReadSession **)(a1 + 24), (const __CFData **)&v64, 1);
  uint64_t v18 = (const UInt8 *)v17;
  if (!v17)
  {
    LogError("copyIOSurfaceImp", 3283, "*** ERROR: retainBytePointer failed\n");
    uint64_t updated = 4294967277;
    goto LABEL_6;
  }
  uint64_t v19 = *(void *)(a1 + 464);
  if (v19)
  {
    if (*(void *)(a1 + 472)) {
      CFIndex Size = *(IIOImageRead **)(a1 + 472);
    }
    else {
      uint64_t v19 = 0;
    }
    uint64_t v18 = (const UInt8 *)v17 + v19;
  }
  CFDataRef v20 = CFDataCreateWithBytesNoCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v18, (CFIndex)Size, (CFAllocatorRef)*MEMORY[0x1E4F1CFA0]);
  if (!v20)
  {
    uint64_t updated = 0;
LABEL_104:
    CFRelease(v68);
    if (v20) {
      CFRelease(v20);
    }
    if (v64)
    {
      CFTypeRef v57 = *(IIOImageRead ***)(a1 + 24);
      if (v57) {
        IIOImageReadSession::releaseBytePointer(v57, v64);
      }
    }
    goto LABEL_6;
  }
  int v21 = gFunc_CMPhotoDecompressionSessionCreateContainer(v68, 0, v20, &v65, &v67);
  LODWORD(updated) = v21;
  if (v21 || !v67)
  {
    int v24 = IIOCMErrorString(v21);
    _cg_jpeg_mem_term("copyIOSurfaceImp", 3299, "*** CMPhotoDecompressionSessionCreateContainer  err = %s [%d]\n", v24, updated);
    if (updated) {
      uint64_t updated = updated;
    }
    else {
      uint64_t updated = 4294967246;
    }
    goto LABEL_104;
  }
  uint64_t v61 = 0;
  uint64_t v62 = 0;
  uint64_t v63 = 0;
  IIODictionary::IIODictionary((IIODictionary *)&v61);
  int v22 = IIOImageReadSession::globalInfoForType(*(IIOImageReadSession **)(a1 + 24), 1212500294);
  if (GlobalHEIFInfo::hasHEIFSequence(v22)) {
    int v23 = IIOImageRead::trustedURL(v22);
  }
  else {
    int v23 = 0;
  }
  HEIFMainImageAtIndedouble x = (HEIFMainImage *)GlobalHEIFInfo::getHEIFMainImageAtIndex(v22, *(_DWORD *)(a1 + 504));
  if (HEIFMainImageAtIndex)
  {
    int v26 = HEIFMainImage::bitDepth(HEIFMainImageAtIndex);
    int DecodePixelFormatForBitDepth = HEIFReadPlugin::getDecodePixelFormatForBitDepth((HEIFReadPlugin *)a1, v26);
    HEIFReadPlugin::updateHardwareDecodeOptions((IIODictionary **)a1, (IIODictionary *)&v61, *(const __CFDictionary ***)(a1 + 48));
    IIONumber::IIONumber((IIONumber *)v60, DecodePixelFormatForBitDepth);
    IIODictionary::setObjectForKey((uint64_t)&v61, (uint64_t)v60, *(const void **)gIIO_kCMPhotoDecompressionOption_OutputPixelFormat);
    IIONumber::~IIONumber((IIONumber *)v60);
    HEIFReadPlugin::updateCreateImageOptions((HEIFReadPlugin *)a1, (IIODictionary *)&v61, *(IIODictionary **)(a1 + 48));
    if (IIODictionary::containsKey((IIODictionary *)v69, @"kCGImageSurfaceFormatRequest")
      && !*(unsigned char *)(a1 + 492)
      && !*(unsigned char *)(a1 + 493))
    {
      int DecodePixelFormatForBitDepth = IIODictionary::getUint32ForKey((IIODictionary *)v69, @"kCGImageSurfaceFormatRequest");
      IIONumber::IIONumber((IIONumber *)v59, DecodePixelFormatForBitDepth);
      IIODictionary::setObjectForKey((uint64_t)&v61, (uint64_t)v59, *(const void **)gIIO_kCMPhotoDecompressionOption_OutputPixelFormat);
      IIONumber::~IIONumber((IIONumber *)v59);
    }
    if (v23)
    {
      uint64_t v28 = gFunc_CMPhotoDecompressionContainerCreateSequenceContainer(v67, 0, 0, &cf);
      uint64_t updated = v28;
      if (v28)
      {
        CFIndex v29 = IIOCMErrorString(v28);
        __n128 v34 = _cg_jpeg_mem_term("copyIOSurfaceImp", 3338, "*** CMPhotoDecompressionSessionCreateContainer[sequence] err = %s [%d]\n", v29, updated);
      }
      else
      {
        if (*(unsigned __int8 *)(a1 + 216) < 2u || *(unsigned char *)(a1 + 498)) {
          ImageForIndedouble x = gFunc_CMPhotoDecompressionContainerCreateImageForIndex(cf, *(unsigned int *)(a1 + 504), v62, 1, v70);
        }
        else {
          ImageForIndedouble x = gFunc_CMPhotoDecompressionContainerCreateThumbnailImageForIndex(cf, *(unsigned int *)(a1 + 504), 0, v62, 1, v70);
        }
        uint64_t updated = ImageForIndex;
        int v30 = (const char *)IIO_IOSurfaceLogAlphaInfo(v70[0], "HEIFSequence");
      }
    }
    else
    {
      if (*(unsigned char *)(a1 + 216) == 2 && !*(unsigned char *)(a1 + 498)) {
        ThumbnailImageForIndedouble x = gFunc_CMPhotoDecompressionContainerCreateThumbnailImageForIndex(v67, *(unsigned int *)(a1 + 504), 0, v62, 1, v70);
      }
      else {
        ThumbnailImageForIndedouble x = gFunc_CMPhotoDecompressionContainerCreateImageForIndex(v67, *(unsigned int *)(a1 + 504), v62, 1, v70);
      }
      uint64_t updated = ThumbnailImageForIndex;
      int v30 = (const char *)IIO_IOSurfaceLogAlphaInfo(v70[0], "HEIF decode");
    }
    if (updated)
    {
      if (updated == -15470 && a2) {
        CGImageProviderSetProperty();
      }
      int v37 = IIOCMErrorString(updated);
      _cg_jpeg_mem_term("copyIOSurfaceImp", 3383, "*** CMPhotoDecompressionContainerCreateImageForIndex  err = %s [%d]\n", v37, updated);
      unsigned int v38 = DecodePixelFormatForBitDepth >> 24;
      uint64_t v39 = MEMORY[0x1E4F14390];
      if (DecodePixelFormatForBitDepth < 0) {
        int v40 = __maskrune(DecodePixelFormatForBitDepth >> 24, 0x40000uLL);
      }
      else {
        int v40 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v38 + 60) & 0x40000;
      }
      if (v40) {
        uint64_t v41 = v38;
      }
      else {
        uint64_t v41 = 46;
      }
      long long v58 = (GlobalHEIFInfo *)v41;
      unsigned int v42 = DecodePixelFormatForBitDepth << 8 >> 24;
      if (DecodePixelFormatForBitDepth << 8 < 0) {
        int v43 = __maskrune(DecodePixelFormatForBitDepth << 8 >> 24, 0x40000uLL);
      }
      else {
        int v43 = *(_DWORD *)(v39 + 4 * v42 + 60) & 0x40000;
      }
      if (v43) {
        uint64_t v44 = v42;
      }
      else {
        uint64_t v44 = 46;
      }
      unsigned int v45 = (__int16)DecodePixelFormatForBitDepth >> 8;
      if (DecodePixelFormatForBitDepth << 16 < 0)
      {
        int v47 = __maskrune((__int16)DecodePixelFormatForBitDepth >> 8, 0x40000uLL);
        uint64_t v46 = v39;
      }
      else
      {
        uint64_t v46 = v39;
        int v47 = *(_DWORD *)(v39 + 4 * v45 + 60) & 0x40000;
      }
      if ((DecodePixelFormatForBitDepth << 24) <= 0x7F000000) {
        int v48 = *(_DWORD *)(v46 + 4 * (char)DecodePixelFormatForBitDepth + 60) & 0x40000;
      }
      else {
        int v48 = __maskrune((char)DecodePixelFormatForBitDepth, 0x40000uLL);
      }
      if (v47) {
        uint64_t v49 = v45;
      }
      else {
        uint64_t v49 = 46;
      }
      if (v48) {
        uint64_t v50 = (char)DecodePixelFormatForBitDepth;
      }
      else {
        uint64_t v50 = 46;
      }
      *(void *)&double v51 = _cg_jpeg_mem_term("copyIOSurfaceImp", 3384, "    outputPixelFormat: %c%c%c%c\n", v58, v44, v49, v50).n128_u64[0];
      _cg_jpeg_mem_term(v62, 4, "cmPhotoContainer", v51);
      goto LABEL_101;
    }
    if (gFunc_CMPhotoDecompressionSessionDetachSurface)
    {
      int v30 = (const char *)gFunc_CMPhotoDecompressionSessionDetachSurface(v68, v70[0], v34);
      uint64_t updated = (uint64_t)v30;
    }
    else
    {
      uint64_t updated = 0;
    }
    if (*(unsigned char *)(a1 + 492))
    {
      if ((gIIODebugFlags & 0x300000) != 0) {
        ImageIOLog("  _requestedApplyGainMap --> createSurfaceWithGainMapApplied\n");
      }
      SurfaceWithGainMapApplied = HEIFReadPlugin::createSurfaceWithGainMapApplied(a1, (uint64_t)v67, v32, v22, v70[0]);
      int v53 = SurfaceWithGainMapApplied;
      if ((gIIODebugFlags & 0x2000000) != 0) {
        LogSurfaceFormat(SurfaceWithGainMapApplied, "outputSurface", "copyIOSurfaceImp", 3398);
      }
      if (v53)
      {
LABEL_90:
        CFRelease(v70[0]);
        v70[0] = v53;
      }
    }
    else if (*(unsigned char *)(a1 + 493))
    {
      if ((gIIODebugFlags & 0x300000) != 0) {
        int v30 = ImageIOLog("  _requestedApplyToneMap --> createSurfaceWithToneMapApplied\n");
      }
      SurfaceWithToneMapApplied = HEIFReadPlugin::createSurfaceWithToneMapApplied((uint64_t)v30, v31, v32, v33, v70[0], *(_DWORD *)(a1 + 440), *(const __CFString **)(a1 + 520), *(unsigned __int8 *)(a1 + 497));
      int v53 = SurfaceWithToneMapApplied;
      if ((gIIODebugFlags & 0x2000000) != 0) {
        LogSurfaceFormat(SurfaceWithToneMapApplied, "outputSurface", "copyIOSurfaceImp", 3409);
      }
      if (v53) {
        goto LABEL_90;
      }
    }
    if (!a5) {
      goto LABEL_98;
    }
    if (*(unsigned char *)(a1 + 495))
    {
      uint64_t v55 = HEIFReadPlugin::copyISOGainMapDictionary(a1, (uint64_t)v67);
    }
    else
    {
      if (!*(unsigned char *)(a1 + 494)) {
        goto LABEL_98;
      }
      uint64_t v55 = (uint64_t)HEIFReadPlugin::copyHDRGainMapDictionary(a1, (uint64_t)v67, v22, (uint64_t)v69);
    }
    *a5 = v55;
LABEL_98:
    if (updated)
    {
      CFTypeRef v56 = IIOCMErrorString(updated);
      _cg_jpeg_mem_term("copyIOSurfaceImp", 3436, "*** CMPhotoDecompressionSessionDetachSurface  err = %s [%d]\n", v56, updated);
    }
    else
    {
      uint64_t updated = IIO_UpdateIOSurfaceOwnershipIdentity((uint64_t)v70[0], *(_DWORD *)(a1 + 432));
    }
LABEL_101:
    if (cf) {
      CFRelease(cf);
    }
    CFRelease(v67);
    IIODictionary::~IIODictionary((IIODictionary *)&v61);
    goto LABEL_104;
  }
  LogError("copyIOSurfaceImp", 3311, "*** ERROR: failed to get mainImage [#%d]\n", *(_DWORD *)(a1 + 504));
  IIODictionary::~IIODictionary((IIODictionary *)&v61);
  uint64_t updated = 4294967246;
LABEL_6:
  if (v10)
  {
    unint64_t v14 = *(const char ***)(a1 + 24);
    if (v14) {
      IIOImageReadSession::unmapData(v14);
    }
  }
  if (a4) {
    *a4 = v70[0];
  }
LABEL_12:
  IIODictionary::~IIODictionary((IIODictionary *)v69);
  return updated;
}

void sub_188601114(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va1, a6);
  va_start(va, a6);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v11 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  IIONumber::~IIONumber((IIONumber *)va);
  IIODictionary::~IIODictionary((IIODictionary *)va1);
  IIODictionary::~IIODictionary((IIODictionary *)(v6 - 120));
  _Unwind_Resume(a1);
}

uint64_t AppleJPEGReadPlugin::createImageBlockSetWithHardwareDecode(unsigned __int8 *a1, const void *a2, uint64_t a3, const __CFDictionary *a4, int *a5)
{
  int v21 = 0;
  uint64_t v18 = 0;
  uint64_t v19 = 0;
  uint64_t v20 = 0;
  IIODictionary::IIODictionary((IIODictionary *)&v18);
  memset(v17, 0, sizeof(v17));
  IIODictionary::IIODictionary((IIODictionary *)v17, a4);
  unsigned int Uint32ForKey = IIODictionary::getUint32ForKey((IIODictionary *)v17, @"kCGImageSurfaceFormatRequest");
  int v11 = a1[405];
  if (Uint32ForKey == 875704422) {
    _cg_jpeg_mem_term("createImageBlockSetWithHardwareDecode", 4119, "    requested '420f' format will be ignored (creating a monochrome/RGBx blockset)\n");
  }
  if (v11) {
    IIONumber::IIONumber((IIONumber *)v15, 1380401729);
  }
  else {
    IIONumber::IIONumber((IIONumber *)v15, 1111970369);
  }
  IIODictionary::setObjectForKey((IIODictionary *)&v18, value, @"kCGImageSurfaceFormatRequest");
  IIONumber::~IIONumber((IIONumber *)v15);
  int v12 = (*(uint64_t (**)(unsigned __int8 *, uint64_t, uint64_t, __IOSurface **, void))(*(void *)a1 + 224))(a1, a3, v19, &v21, 0);
  if (v12) {
    _cg_jpeg_mem_term("createImageBlockSetWithHardwareDecode", 4132, "*** ERROR: copyIOSurfaceImp returned: %d\n", v12);
  }
  if (!v21)
  {
    uint64_t ImageBlockFromIOSurface = 0;
    if (!a5) {
      goto LABEL_11;
    }
    goto LABEL_10;
  }
  uint64_t ImageBlockFromIOSurface = AppleJPEGReadPlugin::createImageBlockFromIOSurface((uint64_t)a1, v21, a2, a3);
  IIO_IOSurfaceRelease(v21);
  if (a5) {
LABEL_10:
  }
    *a5 = v12;
LABEL_11:
  IIODictionary::~IIODictionary((IIODictionary *)v17);
  IIODictionary::~IIODictionary((IIODictionary *)&v18);
  return ImageBlockFromIOSurface;
}

void sub_188601324(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va2, a3);
  va_start(va1, a3);
  va_start(va, a3);
  uint64_t v4 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  va_copy(va2, va1);
  uint64_t v8 = va_arg(va2, void);
  uint64_t v10 = va_arg(va2, void);
  uint64_t v11 = va_arg(va2, void);
  IIONumber::~IIONumber((IIONumber *)va);
  IIODictionary::~IIODictionary((IIODictionary *)va1);
  IIODictionary::~IIODictionary((IIODictionary *)va2);
  _Unwind_Resume(a1);
}

uint64_t AppleJPEGReadPlugin::copyIOSurfaceImp(uint64_t a1, int a2, __CFDictionary *a3, void *a4)
{
  v57[0] = 0;
  memset(v56, 0, sizeof(v56));
  IIODictionary::IIODictionary((IIODictionary *)v56, a3);
  if (*(void *)(a1 + 24))
  {
    IIO_LoadHEIFSymbols();
    uint64_t v6 = *(IIOImageRead ***)(a1 + 24);
    if (v6) {
      BOOL v7 = IIOImageReadSession::mapData(v6);
    }
    else {
      BOOL v7 = 0;
    }
    CFTypeRef v55 = 0;
    CFAllocatorRef v9 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    uint64_t v10 = gFunc_CMPhotoDecompressionSessionCreate(*MEMORY[0x1E4F1CF80], 0, &v55);
    uint64_t updated = v10;
    if (v10)
    {
      uint64_t v11 = IIOCMErrorString(v10);
      LogError("copyIOSurfaceImp", 3764, "*** CMPhotoDecompressionSessionCreate  err = %s [%d]\n", v11, updated);
    }
    else
    {
      CFTypeRef v54 = 0;
      int v53 = 0;
      unsigned int v52 = 0;
      CFIndex Size = IIOImageReadSession::getSize(*(IIOImageReadSession **)(a1 + 24));
      uint64_t v15 = IIOImageReadSession::retainBytePointer(*(IIOImageReadSession **)(a1 + 24), (const __CFData **)&v52, 1);
      uint64_t v16 = (const UInt8 *)v15;
      if (v15)
      {
        uint64_t v17 = *(void *)(a1 + 456);
        if (v17)
        {
          if (*(void *)(a1 + 464) != 0 && *(void *)(a1 + 464) + v17 < (unint64_t)Size) {
            CFIndex Size = *(IIOImageRead **)(a1 + 464);
          }
          else {
            uint64_t v17 = 0;
          }
          uint64_t v16 = (const UInt8 *)v15 + v17;
        }
        CFDataRef v18 = CFDataCreateWithBytesNoCopy(v9, v16, (CFIndex)Size, (CFAllocatorRef)*MEMORY[0x1E4F1CFA0]);
        if (v18)
        {
          uint64_t v20 = gFunc_CMPhotoDecompressionSessionCreateContainer(v55, 0, v18, &v53, &v54);
          uint64_t updated = v20;
          if (v20)
          {
            int v21 = IIOCMErrorString(v20);
            __n128 v19 = _cg_jpeg_mem_term("copyIOSurfaceImp", 3803, "*** CMPhotoDecompressionSessionCreateContainer  err = %s [%d]\n", v21, updated);
          }
          else
          {
            uint64_t v49 = 0;
            uint64_t v50 = 0;
            uint64_t v51 = 0;
            IIODictionary::IIODictionary((IIODictionary *)&v49);
            unsigned int Uint32ForKey = IIODictionary::getUint32ForKey((IIODictionary *)v56, @"kCGImageSurfaceFormatRequest");
            int v23 = *(_DWORD *)(a1 + 324);
            if (v23 == 1196573017)
            {
              unsigned int v24 = 1278226488;
            }
            else if (v23 == 1380401696)
            {
              unsigned int v24 = 875704422;
              if (!*(unsigned char *)(a1 + 676))
              {
                if (*(unsigned char *)(a1 + 405)) {
                  unsigned int v24 = 1380401729;
                }
                else {
                  unsigned int v24 = 1111970369;
                }
              }
              if (Uint32ForKey == 875704422 || Uint32ForKey == 1380401729 || Uint32ForKey == 1111970369) {
                unsigned int v24 = Uint32ForKey;
              }
            }
            else
            {
              unsigned int v24 = 0;
            }
            IIONumber::IIONumber((IIONumber *)v48, v24);
            IIODictionary::setObjectForKey((uint64_t)&v49, (uint64_t)v48, *(const void **)gIIO_kCMPhotoDecompressionOption_OutputPixelFormat);
            IIONumber::~IIONumber((IIONumber *)v48);
            IIODictionary::setObjectForKey((IIODictionary *)&v49, (const void *)*MEMORY[0x1E4F1CFC8], *(const __CFString **)gIIO_kCMPhotoDecompressionOption_ApplyTransform);
            if (*(_DWORD *)(a1 + 292) <= *(_DWORD *)(a1 + 296)) {
              int v25 = *(_DWORD *)(a1 + 296);
            }
            else {
              int v25 = *(_DWORD *)(a1 + 292);
            }
            IIONumber::IIONumber((IIONumber *)v47, v25);
            IIODictionary::setObjectForKey((uint64_t)&v49, (uint64_t)v47, *(const void **)gIIO_kCMPhotoDecompressionOption_MaxPixelSize);
            IIONumber::~IIONumber((IIONumber *)v47);
            IIONumber::IIONumber((IIONumber *)v46, 1);
            IIODictionary::setObjectForKey((uint64_t)&v49, (uint64_t)v46, *(const void **)gIIO_kCMPhotoDecompressionOption_TiledDownsampling);
            IIONumber::~IIONumber((IIONumber *)v46);
            if (*(unsigned char *)(a1 + 216) == 2 && *(_DWORD *)(a1 + 452) != 1920231541) {
              ThumbnailImageForIndedouble x = gFunc_CMPhotoDecompressionContainerCreateThumbnailImageForIndex(v54, 0, 0, v50, 1, v57);
            }
            else {
              ThumbnailImageForIndedouble x = gFunc_CMPhotoDecompressionContainerCreateImageForIndex(v54, 0, v50, 1, v57);
            }
            uint64_t updated = ThumbnailImageForIndex;
            if (ThumbnailImageForIndex)
            {
              uint64_t v28 = IIOCMErrorString(ThumbnailImageForIndex);
              _cg_jpeg_mem_term("copyIOSurfaceImp", 3861, "*** CoSurfaceMPhotoDecompressionContainerCreateImageForIndex  err = %s [%d]\n", v28, updated);
              LODWORD(v29) = HIBYTE(v24);
              uint64_t v30 = MEMORY[0x1E4F14390];
              if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * HIBYTE(v24) + 60) & 0x40000) != 0) {
                uint64_t v29 = v29;
              }
              else {
                uint64_t v29 = 46;
              }
              uint64_t v45 = v29;
              unsigned int v31 = (int)(v24 << 8) >> 24;
              if (((v24 << 8) & 0x80000000) != 0) {
                int v32 = __maskrune((int)(v24 << 8) >> 24, 0x40000uLL);
              }
              else {
                int v32 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v31 + 60) & 0x40000;
              }
              if (v32) {
                uint64_t v36 = v31;
              }
              else {
                uint64_t v36 = 46;
              }
              unsigned int v37 = (__int16)v24 >> 8;
              if (((v24 << 16) & 0x80000000) != 0)
              {
                int v39 = __maskrune((__int16)v24 >> 8, 0x40000uLL);
                uint64_t v38 = v30;
              }
              else
              {
                uint64_t v38 = v30;
                int v39 = *(_DWORD *)(v30 + 4 * v37 + 60) & 0x40000;
              }
              if (v24 << 24 <= 0x7F000000) {
                int v40 = *(_DWORD *)(v38 + 4 * (char)v24 + 60) & 0x40000;
              }
              else {
                int v40 = __maskrune((char)v24, 0x40000uLL);
              }
              if (v39) {
                uint64_t v41 = v37;
              }
              else {
                uint64_t v41 = 46;
              }
              if (v40) {
                uint64_t v42 = (char)v24;
              }
              else {
                uint64_t v42 = 46;
              }
              *(void *)&double v43 = _cg_jpeg_mem_term("copyIOSurfaceImp", 3862, "    outputPixelFormat: %c%c%c%c\n", v45, v36, v41, v42).n128_u64[0];
              _cg_jpeg_mem_term(v50, 4, "cmPhotoContainer", v43);
            }
            else
            {
              if (gFunc_CMPhotoDecompressionSessionDetachSurface)
              {
                int v33 = gFunc_CMPhotoDecompressionSessionDetachSurface(v55, v57[0], v27);
                int v34 = v33;
                if (v33)
                {
                  CFIndex v35 = IIOCMErrorString(v33);
                  _cg_jpeg_mem_term("copyIOSurfaceImp", 3874, "*** CMPhotoDecompressionSessionDetachSurface  err = %s [%d]\n", v35, v34);
                }
              }
              uint64_t updated = IIO_UpdateIOSurfaceOwnershipIdentity(v57[0], *(_DWORD *)(a1 + 432));
            }
            CFRelease(v54);
            IIODictionary::~IIODictionary((IIODictionary *)&v49);
          }
        }
        else
        {
          uint64_t updated = 0;
        }
        gFunc_CMPhotoDecompressionSessionFlushCachedBuffers(v55, 0, 0, v19);
        CFRelease(v55);
        if (v18) {
          CFRelease(v18);
        }
        if (v52)
        {
          uint64_t v44 = *(IIOImageRead ***)(a1 + 24);
          if (v44) {
            IIOImageReadSession::releaseBytePointer(v44, v52);
          }
        }
      }
      else
      {
        LogError("copyIOSurfaceImp", 3782, "retainBytePointer failed\n");
        uint64_t updated = 0;
      }
    }
    if (v7)
    {
      int v12 = *(const char ***)(a1 + 24);
      if (v12) {
        IIOImageReadSession::unmapData(v12);
      }
    }
    if (a4) {
      *a4 = v57[0];
    }
  }
  else
  {
    uint64_t updated = 4294967246;
  }
  IIODictionary::~IIODictionary((IIODictionary *)v56);
  return updated;
}

void sub_188601958(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va1, a6);
  va_start(va, a6);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v11 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  uint64_t v15 = va_arg(va1, void);
  uint64_t v16 = va_arg(va1, void);
  uint64_t v17 = va_arg(va1, void);
  IIONumber::~IIONumber((IIONumber *)va);
  IIODictionary::~IIODictionary((IIODictionary *)va1);
  IIODictionary::~IIODictionary((IIODictionary *)(v6 - 120));
  _Unwind_Resume(a1);
}

uint64_t IIO_UpdateIOSurfaceOwnershipIdentity(uint64_t a1, int a2)
{
  int v3 = IIO_XPCServer();
  uint64_t v4 = 0;
  if (a2)
  {
    if (v3)
    {
      uint64_t v4 = IOSurfaceSetOwnershipIdentity();
      if (v4) {
        _cg_jpeg_mem_term("IIO_UpdateIOSurfaceOwnershipIdentity", 340, "*** ERROR: IOSurfaceSetOwnershipIdentity failed: %d", v4);
      }
    }
  }
  return v4;
}

void IIO_IOSurfaceRelease(__IOSurface *a1)
{
  if (a1)
  {
    if (CFGetRetainCount(a1) == 1)
    {
      CFTypeRef v2 = IOSurfaceCopyValue(a1, @"com.apple.ImageIO.ImageIO_Malloced");
      if (v2)
      {
        int v3 = v2;
        BaseAddress = IOSurfaceGetBaseAddress(a1);
        AllocCFIndex Size = IOSurfaceGetAllocSize(a1);
        if (BaseAddress) {
          _ImageIO_Free((unint64_t)BaseAddress, AllocSize);
        }
        CFRelease(v3);
      }
    }
    CFRelease(a1);
  }
}

uint64_t IIO_IOSurfaceLogAlphaInfo(__IOSurface *a1, const char *a2)
{
  if (a1)
  {
    if ((gIIODebugFlags & 0x40000000000) != 0)
    {
      signed int PixelFormat = IOSurfaceGetPixelFormat(a1);
      CFDictionaryRef v5 = IOSurfaceCopyAllValues(a1);
      if (v5)
      {
        CFDictionaryRef v6 = v5;
        memset(&v25, 0, sizeof(v25));
        memset(v24, 0, sizeof(v24));
        IIODictionary::IIODictionary((IIODictionary *)v24, v5);
        if (!IOSurfaceGetBulkAttachments()) {
          std::string::append(&v25, "bulk: alphaUnknown  ");
        }
        IIO_LoadHEIFSymbols();
        if (IIODictionary::containsKey((IIODictionary *)v24, *(const __CFString **)gIIO_kCVImageBufferAlphaChannelIsOpaque))
        {
          if (IIODictionary::getBoolForKey((IIODictionary *)v24, *(const __CFString **)gIIO_kCVImageBufferAlphaChannelIsOpaque))
          {
            BOOL v7 = "alphaOpaque  ";
          }
          else
          {
            BOOL v7 = "alphaNotOpaque  ";
          }
          std::string::append(&v25, v7);
        }
        if (IIODictionary::containsKey((IIODictionary *)v24, *(const __CFString **)gIIO_kCVImageBufferAlphaChannelModeKey))
        {
          CFStringRef ObjectForKey = (const __CFString *)IIODictionary::getObjectForKey((IIODictionary *)v24, *(const __CFString **)gIIO_kCVImageBufferAlphaChannelModeKey);
          if (CFStringCompare(ObjectForKey, *(CFStringRef *)gIIO_kCVImageBufferAlphaChannelMode_PremultipliedAlpha, 0))
          {
            if (CFStringCompare(ObjectForKey, *(CFStringRef *)gIIO_kCVImageBufferAlphaChannelMode_StraightAlpha, 0)) {
              CFAllocatorRef v9 = "unknown  ";
            }
            else {
              CFAllocatorRef v9 = "alphaStraight  ";
            }
          }
          else
          {
            CFAllocatorRef v9 = "alphaPremul  ";
          }
          std::string::append(&v25, v9);
        }
        if ((gIIODebugFlags & 0x40000000000) != 0)
        {
          unsigned int v10 = PixelFormat >> 24;
          uint64_t v11 = MEMORY[0x1E4F14390];
          if (PixelFormat < 0) {
            int v12 = __maskrune(PixelFormat >> 24, 0x40000uLL);
          }
          else {
            int v12 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v10 + 60) & 0x40000;
          }
          if (v12) {
            uint64_t v13 = v10;
          }
          else {
            uint64_t v13 = 46;
          }
          unsigned int v14 = PixelFormat << 8 >> 24;
          if (PixelFormat << 8 < 0) {
            int v15 = __maskrune(PixelFormat << 8 >> 24, 0x40000uLL);
          }
          else {
            int v15 = *(_DWORD *)(v11 + 4 * v14 + 60) & 0x40000;
          }
          if (v15) {
            uint64_t v16 = v14;
          }
          else {
            uint64_t v16 = 46;
          }
          unsigned int v17 = (__int16)PixelFormat >> 8;
          if (PixelFormat << 16 < 0) {
            int v18 = __maskrune((__int16)PixelFormat >> 8, 0x40000uLL);
          }
          else {
            int v18 = *(_DWORD *)(v11 + 4 * v17 + 60) & 0x40000;
          }
          if ((PixelFormat << 24) <= 0x7F000000) {
            int v19 = *(_DWORD *)(v11 + 4 * (char)PixelFormat + 60) & 0x40000;
          }
          else {
            int v19 = __maskrune((char)PixelFormat, 0x40000uLL);
          }
          if (v18) {
            uint64_t v20 = v17;
          }
          else {
            uint64_t v20 = 46;
          }
          if (v19) {
            uint64_t v21 = (char)PixelFormat;
          }
          else {
            uint64_t v21 = 46;
          }
          int v22 = &v25;
          if ((v25.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
            int v22 = (std::string *)v25.__r_.__value_.__r.__words[0];
          }
          ImageIOLog("  %s <IOSurface:  %p> '%c%c%c%c' - %s\n", a2, a1, v13, v16, v20, v21, (const char *)v22);
        }
        CFRelease(v6);
        IIODictionary::~IIODictionary((IIODictionary *)v24);
        if (SHIBYTE(v25.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v25.__r_.__value_.__l.__data_);
        }
      }
    }
  }
  return 0;
}

void sub_188601DE0(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 - 89) < 0) {
    operator delete(*(void **)(v1 - 112));
  }
  _Unwind_Resume(exception_object);
}

void CGImageMetadataEnumerateTagsUsingBlock(CGImageMetadataRef metadata, CFStringRef rootPath, CFDictionaryRef options, CGImageMetadataTagBlock block)
{
  IIOInitDebugFlags();
  if ((~gIIODebugFlags & 0x3000) == 0) {
    ImageIODebugOptions(3, "A", "CGImageMetadataEnumerateTagsUsingBlock", 0, 0, -1, 0);
  }
  if (!metadata) {
    goto LABEL_9;
  }
  CFTypeID v8 = CFGetTypeID(metadata);
  if (CGImageMetadataGetTypeID::once != -1) {
    dispatch_once(&CGImageMetadataGetTypeID::once, &__block_literal_global_21);
  }
  if (v8 == CGImageMetadataGetTypeID::id)
  {
    if (block)
    {
      pthread_mutex_lock((pthread_mutex_t *)((char *)metadata + 72));
      pthread_mutex_lock((pthread_mutex_t *)((char *)metadata + 208));
      *((unsigned char *)metadata + 200) = 1;
      pthread_mutex_unlock((pthread_mutex_t *)((char *)metadata + 208));
      memset(v11, 0, sizeof(v11));
      IIODictionary::IIODictionary((IIODictionary *)v11, options);
      CGImageMetadataEnumerateTagsUsingBlockInternal((uint64_t)metadata, rootPath, (IIODictionary *)v11, (uint64_t)block);
      pthread_mutex_lock((pthread_mutex_t *)((char *)metadata + 208));
      *((unsigned char *)metadata + 200) = 0;
      pthread_mutex_unlock((pthread_mutex_t *)((char *)metadata + 208));
      pthread_mutex_unlock((pthread_mutex_t *)((char *)metadata + 72));
      IIODictionary::~IIODictionary((IIODictionary *)v11);
      return;
    }
    CFAllocatorRef v9 = "block is NULL.";
    int v10 = 2089;
  }
  else
  {
LABEL_9:
    CFAllocatorRef v9 = "'metadata' is not a CGImageMetadataRef.";
    int v10 = 2093;
  }

  LogMetadata("CGImageMetadataEnumerateTagsUsingBlock", v10, v9);
}

void sub_188601FAC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  IIODictionary::~IIODictionary((IIODictionary *)va);
  _Unwind_Resume(a1);
}

void CGImageMetadataEnumerateTagsUsingBlockInternal(uint64_t a1, const __CFString *a2, IIODictionary *a3, uint64_t a4)
{
  BOOL BoolForKey = IIODictionary::getBoolForKey(a3, @"kCGImageMetadataEnumerateRecursively");
  if (a2 && CFStringGetLength(a2) >= 1)
  {
    TagWithPath = (CGImageMetadataTag *)CGImageMetadataGetTagWithPath((void *)a1, 0, a2);
    if (!TagWithPath) {
      return;
    }
    uint64_t v9 = (uint64_t)TagWithPath;
    CGImageMetadataType Type = CGImageMetadataTagGetType(TagWithPath);
    if (Type == kCGImageMetadataTypeDefault) {
      return;
    }
    CGImageMetadataType v11 = Type;
    CFDictionaryRef Value = (const __CFDictionary *)CGImageMetadataTagGetValue(v9);
    if ((v11 & 0xFFFFFFFE) == 2)
    {
      uint64_t v13 = (const void *)CGImageMetadataTagGetValue(v9);
      if (!v13) {
        return;
      }
      uint64_t v14 = (uint64_t)v13;
      CFTypeID v15 = CFGetTypeID(v13);
      if (v15 != CFArrayGetTypeID()) {
        return;
      }
      v52[0] = MEMORY[0x1E4F143A8];
      v52[1] = 0x40000000;
      v52[2] = ___ZL46CGImageMetadataEnumerateTagsUsingBlockInternalPK15CGImageMetadataPK10__CFStringP13IIODictionaryU13block_pointerFbS4_P18CGImageMetadataTagE_block_invoke;
      v52[3] = &unk_1E53C7400;
      v52[4] = a4;
      v52[5] = a2;
      BOOL v53 = BoolForKey;
      v52[6] = a1;
      void v52[7] = a3;
      uint64_t v16 = v52;
      uint64_t v17 = v14;
      goto LABEL_37;
    }
    if (v11 == kCGImageMetadataTypeAlternateText)
    {
      int v32 = (const void *)CGImageMetadataTagGetValue(v9);
      if (!v32) {
        return;
      }
      uint64_t v33 = (uint64_t)v32;
      CFTypeID v34 = CFGetTypeID(v32);
      if (v34 != CFArrayGetTypeID()) {
        return;
      }
      v51[0] = MEMORY[0x1E4F143A8];
      v51[1] = 0x40000000;
      v51[2] = ___ZL46CGImageMetadataEnumerateTagsUsingBlockInternalPK15CGImageMetadataPK10__CFStringP13IIODictionaryU13block_pointerFbS4_P18CGImageMetadataTagE_block_invoke_2;
      void v51[3] = &unk_1E53C7428;
      v51[5] = a1;
      v51[6] = a2;
      v51[4] = a4;
      uint64_t v16 = v51;
      uint64_t v17 = v33;
LABEL_37:
      IIOArrayEnumerateUsingBlock(v17, (uint64_t)v16);
      return;
    }
    if (v11 != kCGImageMetadataTypeStructure) {
      return;
    }
    CFDictionaryRef v35 = Value;
    if (!Value) {
      return;
    }
    CFTypeID v36 = CFGetTypeID(Value);
    if (v36 != CFDictionaryGetTypeID()) {
      return;
    }
    int64_t Count = CFDictionaryGetCount(v35);
    uint64_t v38 = (const void **)malloc_type_calloc(8uLL, Count, 0xDA39B998uLL);
    int v39 = (const void **)malloc_type_calloc(8uLL, Count, 0xF7EB24FFuLL);
    CFDictionaryGetKeysAndValues(v35, v38, v39);
    uint64_t v49 = v39;
    if (v38 && v39)
    {
      if (Count >= 1)
      {
        BOOL v40 = BoolForKey;
        uint64_t v41 = 0;
        CFAllocatorRef v42 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
        do
        {
          CFStringRef v43 = CFStringCreateWithFormat(v42, 0, @"%@.%@", a2, v38[v41]);
          if (v43)
          {
            CFStringRef v44 = v43;
            uint64_t v45 = CGImageMetadataGetTagWithPath((void *)a1, 0, v43);
            if (!(*(unsigned int (**)(uint64_t, const __CFString *, void *))(a4 + 16))(a4, v44, v45))
            {
              free(v38);
              free(v49);
              CFStringRef v46 = v44;
LABEL_53:
              CFRelease(v46);
              return;
            }
            if (v40) {
              CGImageMetadataEnumerateTagsUsingBlockInternal(a1, v44, a3, a4);
            }
            CFRelease(v44);
          }
          ++v41;
        }
        while (Count != v41);
      }
    }
    else if (!v38)
    {
      goto LABEL_58;
    }
    free(v38);
LABEL_58:
    unsigned int v31 = v49;
    if (!v49) {
      return;
    }
    goto LABEL_30;
  }
  if (a1)
  {
    CFTypeID v18 = CFGetTypeID((CFTypeRef)a1);
    if (CGImageMetadataGetTypeID::once != -1) {
      dispatch_once(&CGImageMetadataGetTypeID::once, &__block_literal_global_21);
    }
    if (v18 == CGImageMetadataGetTypeID::id)
    {
      BOOL v48 = BoolForKey;
      int v47 = a3;
      int64_t v19 = CFDictionaryGetCount(*(CFDictionaryRef *)(a1 + 24));
      uint64_t v20 = (const void **)malloc_type_calloc(8uLL, v19, 0x2C27D4D5uLL);
      uint64_t v21 = (const void **)malloc_type_calloc(8uLL, v19, 0xAB6C3DECuLL);
      CFDictionaryGetKeysAndValues(*(CFDictionaryRef *)(a1 + 24), v20, v21);
      if (v21 && v19 >= 1 && v20)
      {
        uint64_t v22 = 0;
        CFAllocatorRef v23 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
        do
        {
          uint64_t v24 = (uint64_t)v21[v22];
          if (v24 && (CFTypeID v25 = CFGetTypeID(v21[v22]), v25 == CGImageMetadataTagGetTypeID()))
          {
            uint64_t Source = CGImageSourceGetSource(v24);
            CFStringRef v27 = CFStringCreateWithFormat(v23, 0, @"%@:%@", *(void *)(Source + 24), *(void *)(Source + 32));
            if (v27)
            {
              CFStringRef v28 = v27;
              if (!(*(unsigned int (**)(uint64_t, CFStringRef, uint64_t))(a4 + 16))(a4, v27, v24))
              {
                free(v20);
                free(v21);
                CFStringRef v46 = v28;
                goto LABEL_53;
              }
              if (v48) {
                CGImageMetadataEnumerateTagsUsingBlockInternal(a1, v28, v47, a4);
              }
              CFRelease(v28);
            }
          }
          else
          {
            CStringPtr = CFStringGetCStringPtr(*(CFStringRef *)v20[v22], 0);
            uint64_t v30 = CFStringGetCStringPtr(*((CFStringRef *)v20[v22] + 1), 0);
            LogMetadata("CGImageMetadataEnumerateTagsUsingBlockInternal", 2041, "Value for Kedouble y = %s%s is not a valid CGImageMetadataTagRef\n", CStringPtr, v30);
          }
          ++v22;
        }
        while (v19 != v22);
      }
      if (v20) {
        free(v20);
      }
      if (v21)
      {
        unsigned int v31 = v21;
LABEL_30:
        free(v31);
      }
    }
  }
}

BOOL CGImageMetadataRemoveTagWithPath(CGMutableImageMetadataRef metadata, CGImageMetadataTagRef parent, CFStringRef path)
{
  IIOInitDebugFlags();
  if ((~(_WORD)gIIODebugFlags & 0x3000) == 0)
  {
    CFDictionaryRef v6 = IIOString::IIOString((IIOString *)&v62, path);
    BOOL v7 = (const char *)IIOString::utf8String(v6);
    ImageIODebugOptions(3, "A", "CGImageMetadataRemoveTagWithPath", 0, v7, -1, 0);
    IIOString::~IIOString((IIOString *)&v62);
  }
  uint64_t v62 = 0;
  uint64_t v63 = &v62;
  uint64_t v64 = 0x2000000000;
  char v65 = 0;
  if (metadata)
  {
    CFTypeID v8 = CFGetTypeID(metadata);
    if (CGImageMetadataGetTypeID::once == -1)
    {
      if (!path) {
        goto LABEL_73;
      }
    }
    else
    {
      dispatch_once(&CGImageMetadataGetTypeID::once, &__block_literal_global_21);
      if (!path) {
        goto LABEL_73;
      }
    }
    if (v8 == CGImageMetadataGetTypeID::id)
    {
      CFTypeID v9 = CFGetTypeID(path);
      if (v9 == CFStringGetTypeID())
      {
        uint64_t Source = (IIOMetadata_Tag *)CGImageSourceGetSource((uint64_t)parent);
        pthread_mutex_lock((pthread_mutex_t *)((char *)metadata + 208));
        if (*((unsigned char *)metadata + 200))
        {
          LogMetadata("CGImageMetadataRemoveTagWithPath", 1473, "Cannot mutate metadata while enumerating");
          pthread_mutex_unlock((pthread_mutex_t *)((char *)metadata + 208));
          goto LABEL_73;
        }
        pthread_mutex_unlock((pthread_mutex_t *)((char *)metadata + 208));
        CFAllocatorRef v11 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
        if (parent)
        {
          CFStringRef v12 = CFStringCreateWithFormat(v11, 0, @"%@:%@", *((void *)Source + 3), *((void *)Source + 4));
          if (!v12) {
            goto LABEL_73;
          }
          CFStringRef PathWithChildPath = IIOMetadata_Tag::createPathWithChildPath(Source, path);
          uint64_t v14 = parse_metadata_pathString(v12);
          if (v14)
          {
            uint64_t v15 = *((void *)v14 + 5);
            if (v15)
            {
              int v16 = 0;
              do
              {
                if ((*(_DWORD *)v15 & 0xFFFFFFFE) != 2) {
                  break;
                }
                ++v16;
                uint64_t v15 = *(void *)(v15 + 40);
              }
              while (v15);
            }
            else
            {
              int v16 = 0;
            }
            freeNodes(v14);
          }
          else
          {
            int v16 = 0;
          }
          CFRelease(v12);
        }
        else
        {
          CFStringRef PathWithChildPath = CFStringCreateCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], path);
          int v16 = 0;
        }
        uint64_t v17 = parse_metadata_pathString(PathWithChildPath);
        CFTypeID v18 = v17;
        if (!v17 || !*((void *)v17 + 1) || !*((void *)v17 + 2)) {
          goto LABEL_69;
        }
        int64_t v19 = 0;
        uint64_t v20 = v17;
        do
        {
          uint64_t v21 = v20;
          uint64_t v22 = v19;
          uint64_t v20 = (char *)*((void *)v20 + 5);
          int64_t v19 = v21;
        }
        while (v20);
        CFTypeRef v57 = (pthread_mutex_t *)((char *)metadata + 72);
        pthread_mutex_lock((pthread_mutex_t *)((char *)metadata + 72));
        if (!parent && v21 == v18)
        {
          TagWithPath = CGImageMetadataGetTagWithPath(metadata, 0, PathWithChildPath);
          if (TagWithPath)
          {
            CGImageMetadataRemoveTag((uint64_t)metadata, (uint64_t)TagWithPath);
LABEL_31:
            *((unsigned char *)v63 + 24) = 1;
          }
          goto LABEL_65;
        }
        if (parent && v22 == v18)
        {
LABEL_34:
          uint64_t v24 = CGImageSourceGetSource((uint64_t)parent);
          CFTypeID v25 = (IIOMetadata_Tag *)v24;
          switch(*(_DWORD *)v21)
          {
            case 2:
              if ((*(_DWORD *)(v24 + 40) - 2) <= 2)
              {
                int v26 = *(const void **)(v24 + 48);
                if (v26)
                {
                  CFTypeID v27 = CFGetTypeID(*(CFTypeRef *)(v24 + 48));
                  if (v27 == CFArrayGetTypeID())
                  {
                    CFAllocatorRef v28 = CFGetAllocator(v26);
                    CFIndex Count = CFArrayGetCount((CFArrayRef)v26);
                    MutableCFStringRef Copy = CFArrayCreateMutableCopy(v28, Count, (CFArrayRef)v26);
                    CFStringRef v31 = (const __CFString *)MutableCopy;
                    if (MutableCopy)
                    {
                      CFArrayRemoveValueAtIndex(MutableCopy, *((int *)v21 + 6));
                      IIOArrayEnumerateUsingBlock((uint64_t)v31, (uint64_t)&__block_literal_global_29);
                      IIOMetadata_Tag::setValue(v25, v31);
                      CFRelease(v26);
                      goto LABEL_31;
                    }
                  }
                }
              }
              break;
            case 3:
              if (*(_DWORD *)(v24 + 40) == 5)
              {
                uint64_t v39 = *(void *)(v24 + 48);
                if (v39)
                {
                  CFTypeID v40 = CFGetTypeID(*(CFTypeRef *)(v24 + 48));
                  if (v40 == CFArrayGetTypeID())
                  {
                    CFStringRef v41 = CFStringCreateWithCString(v11, *((const char **)v21 + 4), 0x8000100u);
                    CFStringRef v42 = v41;
                    if (v41)
                    {
                      v60[0] = 0;
                      v60[1] = v60;
                      v60[2] = 0x2000000000;
                      char v61 = 0;
                      v59[0] = MEMORY[0x1E4F143A8];
                      v59[1] = 0x40000000;
                      v59[2] = __CGImageMetadataRemoveTagWithPath_block_invoke_2;
                      CFTypeRef v59[3] = &unk_1E53C7338;
                      v59[6] = v41;
                      v59[7] = v39;
                      v59[8] = v25;
                      v59[4] = &v62;
                      v59[5] = v60;
                      IIOArrayEnumerateUsingBlock(v39, (uint64_t)v59);
                      CFRelease(v42);
                      _Block_object_dispose(v60, 8);
                    }
                  }
                }
              }
              break;
            case 4:
              if (*(_DWORD *)(v24 + 40) == 6)
              {
                CFStringRef v43 = *(const void **)(v24 + 48);
                if (v43)
                {
                  CFTypeID v44 = CFGetTypeID(*(CFTypeRef *)(v24 + 48));
                  if (v44 == CFDictionaryGetTypeID())
                  {
                    CFAllocatorRef v45 = CFGetAllocator(v43);
                    CFStringRef v46 = CFDictionaryCreateMutableCopy(v45, 0, (CFDictionaryRef)v43);
                    if (v46)
                    {
                      CFStringRef v47 = CFStringCreateWithCString(v11, *((const char **)v21 + 2), 0x8000100u);
                      if (v47)
                      {
                        CFDictionaryRemoveValue(v46, v47);
                        IIOMetadata_Tag::setValue(v25, (const __CFString *)v46);
                        CFRelease(v43);
                        CFRelease(v47);
                        goto LABEL_31;
                      }
                      CFRelease(v46);
                    }
                  }
                }
              }
              break;
            case 5:
              CFStringRef v48 = CFStringCreateWithCString(v11, *((const char **)v21 + 1), 0x8000100u);
              CFStringRef v49 = CFStringCreateWithCString(v11, *((const char **)v21 + 2), 0x8000100u);
              uint64_t v50 = *((void *)v25 + 7);
              if (v50)
              {
                v58[0] = MEMORY[0x1E4F143A8];
                v58[1] = 0x40000000;
                v58[2] = __CGImageMetadataRemoveTagWithPath_block_invoke_4;
                CFTypeRef v58[3] = &unk_1E53C7360;
                v58[6] = v49;
                v58[7] = v50;
                v58[4] = &v62;
                v58[5] = v48;
                IIOArrayEnumerateUsingBlock(v50, (uint64_t)v58);
              }
              if (v48) {
                CFRelease(v48);
              }
              if (v49) {
                CFRelease(v49);
              }
              break;
            default:
              goto LABEL_65;
          }
          goto LABEL_65;
        }
        CFStringRef v56 = path;
        CFAllocatorRef v32 = v11;
        CFStringRef v33 = PathWithChildPath;
        uint64_t v34 = (uint64_t)v18;
        if (parent)
        {
          int v35 = v16 + 1;
          uint64_t v34 = (uint64_t)v18;
          do
          {
            uint64_t v34 = *(void *)(v34 + 40);
            --v35;
          }
          while (v35);
        }
        int v36 = *(_DWORD *)v34;
        *((void *)v22 + 5) = 0;
        NodePath = createNodePath(v34);
        *(_DWORD *)uint64_t v34 = v36;
        *((void *)v22 + 5) = v21;
        CFStringRef PathWithChildPath = v33;
        CFAllocatorRef v11 = v32;
        path = v56;
        if (!NodePath) {
          goto LABEL_65;
        }
        CFStringRef v38 = CFStringCreateWithCString(v11, NodePath, 0x8000100u);
        if (v38)
        {
          parent = (CGImageMetadataTagRef)CGImageMetadataGetTagWithPath(metadata, parent, v38);
          CFRelease(v38);
          free(NodePath);
          if (parent) {
            goto LABEL_34;
          }
        }
        else
        {
          free(NodePath);
        }
LABEL_65:
        if (!*((unsigned char *)v63 + 24))
        {
          CFIndex Length = CFStringGetLength(path);
          CFIndex v52 = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u) + 1;
          BOOL v53 = (char *)malloc_type_calloc(1uLL, v52, 0x25857A6uLL);
          if (v53)
          {
            CFStringGetCString(path, v53, v52, 0x8000100u);
            LogMetadata("CGImageMetadataRemoveTagWithPath", 1721, "Could not find a tag at path '%s' to remove.\n", v53);
            free(v53);
          }
        }
        pthread_mutex_unlock(v57);
LABEL_69:
        if (PathWithChildPath) {
          CFRelease(PathWithChildPath);
        }
        if (v18) {
          freeNodes(v18);
        }
      }
    }
  }
LABEL_73:
  char v54 = *((unsigned char *)v63 + 24);
  _Block_object_dispose(&v62, 8);
  return v54;
}

void sub_188602C08(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 136), 8);
  _Unwind_Resume(a1);
}

void CGImageMetadataRemoveTag(uint64_t a1, uint64_t a2)
{
  uint64_t Source = CGImageSourceGetSource(a2);
  if (a1)
  {
    if (a2)
    {
      key[2] = 0;
      uint64_t v5 = *(void *)(Source + 32);
      key[0] = *(void *)(Source + 16);
      key[1] = v5;
      CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 24), key);
    }
  }
}

uint64_t ___ZN12IIOXPCClient18CanCheckTrustedURLEv_block_invoke(IIOXPCClient *a1)
{
  uint64_t result = IIOXPCClient::ProcessSupportsOOP(a1);
  IIOXPCClient::CanCheckTrustedURL(void)::canCheckTrustedURL = result;
  if (result)
  {
    getpid();
    uint64_t result = sandbox_check();
    IIOXPCClient::CanCheckTrustedURL(void)::canCheckTrustedURL = result == 0;
  }
  return result;
}

uint64_t IIOXPCClient::ProcessSupportsOOP(IIOXPCClient *this)
{
  if (IIO_XPCServer()) {
    return 0;
  }
  if (IIOXPCClient::GetIIOXPCClient(void)::xpcClientCreate != -1) {
    dispatch_once(&IIOXPCClient::GetIIOXPCClient(void)::xpcClientCreate, &__block_literal_global_20);
  }

  return IIOIsOOPEnabled(0);
}

CGImageRef IIOImageDestination::create1BitImage(IIOImageDestination *this, CGImageRef image, IIODictionary *a3, int a4)
{
  size_t BitsPerComponent = CGImageGetBitsPerComponent(image);
  size_t v9 = BitsPerComponent;
  if (BitsPerComponent != 8 && BitsPerComponent != 1
    || (HEIFAuxImage::auxiliaryPixelFormat(*((HEIFAuxImage **)this + 8)) & 0x100) == 0)
  {
    return 0;
  }
  unsigned int v10 = IIODictionary::containsKey(a3, @"Depth");
  size_t Uint32ForKey = v9;
  if (v10) {
    size_t Uint32ForKey = IIODictionary::getUint32ForKey(a3, @"Depth");
  }
  if (Uint32ForKey != 1) {
    return 0;
  }
  if (v9 == 8)
  {
    ColorSpace = CGImageGetColorSpace(image);
    if (CGColorSpaceGetModel(ColorSpace))
    {
      CGImageRef v13 = 0;
    }
    else
    {
      if (IIODictionary::containsKey(a3, @"kCGImagePropertyThreshold")) {
        unsigned __int8 v16 = IIODictionary::getUint32ForKey(a3, @"kCGImagePropertyThreshold");
      }
      else {
        unsigned __int8 v16 = 0x80;
      }
      CGImageRef v13 = Create1BitImageFromImageRefWithOrientation(image, a4, v16);
      if (v13)
      {
        IIONumber::IIONumber((IIONumber *)v18, 1);
        IIODictionary::setObjectForKey((uint64_t)a3, (uint64_t)v18, @"Orientation");
        IIONumber::~IIONumber((IIONumber *)v18);
        *((_WORD *)this + 100) = 1;
      }
    }
  }
  else
  {
    CGImageRef v13 = CGImageRetain(image);
  }
  if (CFEqual(*((CFStringRef *)this + 9), @"public.tiff"))
  {
    int Uint32ForKeyGroup = IIODictionary::getUint32ForKeyGroup(a3, @"Compression", @"{TIFF}");
    if ((Uint32ForKeyGroup - 3) >= 2)
    {
      _cg_jpeg_mem_term("create1BitImage", 2107, "*** {TIFF} dictionary does not contain compression information - using COMPRESSION_CCITTFAX4\n");
      int Uint32ForKeyGroup = 4;
    }
    IIONumber::IIONumber((IIONumber *)v17, Uint32ForKeyGroup);
    IIODictionary::setObjectForKeyGroup(a3, (uint64_t)v17, @"Compression", @"{TIFF}");
    IIONumber::~IIONumber((IIONumber *)v17);
  }
  return v13;
}

void sub_188602FA0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  IIONumber::~IIONumber((IIONumber *)va);
  _Unwind_Resume(a1);
}

void IIOImageDestination::addImageInternal(IIOImageDestination *this, CGImage *a2, IIODictionary *a3)
{
  CFAbsoluteTimeGetCurrent();
  if (CGImageGetMask()) {
    IIOImageCreateWithImageAndMaskInterleaved(a2, 0);
  }
  if ((gIIODebugFlags & 0x300000) != 0)
  {
    CGImageGetContentHeadroom();
    ImageIOLog("  %s - adding image with headroom: %g\n", "addImageInternal", v5);
  }
  *((void *)this + 22) = 0;
  *((_WORD *)this + 100) = 1;
  *((unsigned char *)this + 221) = 0;
  *((unsigned char *)this + 214) = 0;
  uint64_t v6 = *((void *)this + 6);
  *((void *)this + 6) = v6 + 1;
  *((void *)this + 7) = v6;
  operator new();
}

void sub_188603984(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  IIONumber::~IIONumber((IIONumber *)va);
  _Unwind_Resume(a1);
}

uint64_t HEIFAuxImage::auxiliaryPixelFormat(HEIFAuxImage *this)
{
  return *((unsigned int *)this + 10);
}

const __CFDictionary *IIOImageDestination::handleDestinationImageMaxPixelSize(IIOImageDestination *this, CGImage *a2, IIODictionary *a3, BOOL *a4)
{
  *a4 = 0;
  if ((gIIODebugFlags & 0x2000000000000) != 0) {
    IIODebugOrientation("handleDestinationImageMaxPixelSize", 2127, a3);
  }
  CFDictionaryRef v8 = IIODictionary::containsKey(a3, @"kCGImageDestinationImageMaxPixelSize");
  if (v8)
  {
    if (IIODictionary::getBoolForKey(a3, @"kCGImageSourceCreateThumbnailWithTransform"))
    {
      unsigned int v9 = IIOGetExifOrientation(a3, 0);
      BOOL v10 = v9 > 1;
      if (v9 <= 1) {
        unsigned int v11 = 1;
      }
      else {
        unsigned int v11 = v9;
      }
    }
    else
    {
      BOOL v10 = 0;
      unsigned int v11 = 1;
    }
    unint64_t Uint32ForKey = IIODictionary::getUint32ForKey(a3, @"kCGImageDestinationImageMaxPixelSize");
    if (*((unsigned char *)this + 214) && IIODictionary::containsKey(a3, @"IMAGEIO_USE_LIBJPEG"))
    {
      BOOL v13 = !IIODictionary::getBoolForKey(a3, @"IMAGEIO_USE_LIBJPEG");
      if (!*((unsigned char *)this + 214)) {
        LOBYTE(v13) = 0;
      }
      *((unsigned char *)this + 214) = v13;
    }
    if (*((unsigned char *)this + 213))
    {
      if ((gIIODebugFlags & 0x2000000000000) != 0)
      {
        uint64_t v14 = "NO";
        if (v10) {
          uint64_t v14 = "YES";
        }
        ImageIOLog("%s bakeInOrientation: _HEIC_to_JPEG %s\n", "-o- ", v14);
      }
      *((void *)this + 21) = CGImageRetain(a2);
      *((void *)this + 23) = Uint32ForKey;
      *a4 = 1;
    }
    else if (*((unsigned char *)this + 214))
    {
      if ((gIIODebugFlags & 0x2000000000000) != 0)
      {
        uint64_t v15 = "NO";
        if (v10) {
          uint64_t v15 = "YES";
        }
        ImageIOLog("%s bakeInOrientation: _useAppleJPEG_resize %s\n", "-o- ", v15);
      }
      *((unsigned char *)this + 212) = 1;
      *((void *)this + 21) = CGImageRetain(a2);
      *((void *)this + 23) = Uint32ForKey;
      *a4 = 1;
    }
    else
    {
      if ((gIIODebugFlags & 0x2000000000000) != 0)
      {
        unsigned __int8 v16 = "NO";
        if (v10) {
          unsigned __int8 v16 = "YES";
        }
        ImageIOLog("%s bakeInOrientation: default %s\n", "-o- ", v16);
      }
      if (IIODictionary::containsKey(a3, @"Depth"))
      {
        int v17 = IIODictionary::getUint32ForKey(a3, @"Depth");
        if (CFEqual(*((CFStringRef *)this + 9), @"public.jpeg")) {
          int v17 = -1;
        }
      }
      else
      {
        int v17 = -1;
      }
      int v18 = 2 * *((unsigned __int8 *)this + 221);
      if ((gIIODebugFlags & 0x8000300000) != 0)
      {
        if (*((unsigned char *)this + 221)) {
          int64_t v19 = "on";
        }
        else {
          int64_t v19 = "off";
        }
        ImageIOLog("COL adding image [%p] with optimizeColorForSharing turned %s\n", a2, v19);
      }
      uint64_t v20 = (CGImage *)*((void *)this + 22);
      if (v10)
      {
        if (v20)
        {
          CGImageRelease(v20);
          *((void *)this + 22) = 0;
        }
        ThumbNew = CGImageCreateThumbNew(a2, Uint32ForKey, v11, v17, v18);
        *((void *)this + 22) = ThumbNew;
        if (ThumbNew) {
          *((_WORD *)this + 100) = 1;
        }
        if ((gIIODebugFlags & 0x2000000000000) != 0) {
          ImageIOLog("%s CGImageCreateThumbNew: maxPixelSize: %d  exifOrientation: %d\n", "-o- ", Uint32ForKey, v11);
        }
        IIONumber::IIONumber((IIONumber *)v35, 1);
        IIODictionary::setObjectForKey((uint64_t)a3, (uint64_t)v35, @"Orientation");
        IIONumber::~IIONumber((IIONumber *)v35);
        IIONumber::IIONumber((IIONumber *)v34, 1);
        IIODictionary::setObjectForKeyGroup(a3, (uint64_t)v34, @"Orientation", @"{TIFF}");
        IIONumber::~IIONumber((IIONumber *)v34);
      }
      else
      {
        if (v20)
        {
          CGImageRelease(v20);
          *((void *)this + 22) = 0;
        }
        if (!*((void *)this + 20)) {
          goto LABEL_59;
        }
        uint64_t v31 = 0;
        CFDictionaryRef options = 0;
        uint64_t v33 = 0;
        IIODictionary::IIODictionary((IIODictionary *)&v31);
        IIONumber::IIONumber((IIONumber *)v29, Uint32ForKey);
        IIODictionary::setObjectForKey((IIODictionary *)&v31, value, @"kCGImageSourceThumbnailMaxPixelSize");
        IIONumber::~IIONumber((IIONumber *)v29);
        uint64_t v22 = (const void *)*MEMORY[0x1E4F1CFD0];
        IIODictionary::setObjectForKey((IIODictionary *)&v31, (const void *)*MEMORY[0x1E4F1CFD0], @"kCGImageSourceCreateThumbnailFromImageIfAbsent");
        ThumbnailAtIndedouble x = CGImageSourceCreateThumbnailAtIndex(*((CGImageSourceRef *)this + 20), *((void *)this + 7), options);
        uint64_t v24 = ThumbnailAtIndex;
        if (ThumbnailAtIndex)
        {
          size_t Width = CGImageGetWidth(ThumbnailAtIndex);
          size_t Height = CGImageGetHeight(v24);
          if (Width >= Uint32ForKey
            || Height >= Uint32ForKey
            || (CGImageRelease(v24),
                IIODictionary::removeObjectForKey((IIODictionary *)&v31, @"kCGImageSourceCreateThumbnailFromImageIfAbsent"), IIODictionary::setObjectForKey((IIODictionary *)&v31, v22, @"kCGImageSourceCreateThumbnailFromImageAlways"), (uint64_t v24 = CGImageSourceCreateThumbnailAtIndex(*((CGImageSourceRef *)this + 20), *((void *)this + 7), options)) != 0))
          {
            if (*((unsigned char *)this + 221)) {
              CFTypeID v27 = CGImageCreateThumbNew(v24, Uint32ForKey, *((_DWORD *)this + 14), v17, v18);
            }
            else {
              CFTypeID v27 = CGImageRetain(v24);
            }
            *((void *)this + 22) = v27;
            CGImageRelease(v24);
          }
        }
        IIODictionary::~IIODictionary((IIODictionary *)&v31);
        if (!*((void *)this + 22)) {
LABEL_59:
        }
          *((void *)this + 22) = CGImageCreateThumbNew(a2, Uint32ForKey, 0, v17, v18);
      }
    }
  }
  return v8;
}

void sub_188603EC4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  IIODictionary::~IIODictionary((IIODictionary *)va);
  _Unwind_Resume(a1);
}

uint64_t IIOImageDestination::createPixelDataProviderConforming(uint64_t a1, CGImageRef image, uint64_t a3, int a4, uint64_t a5, uint64_t a6, IIODictionary *a7)
{
  Decode = CGImageGetDecode(image);
  double Current = CFAbsoluteTimeGetCurrent();
  if ((gIIODebugFlags & 0x10000000000) != 0)
  {
    ImageIOLog("CGImageDestination - CGImagePixelDataProviderCreateConforming\n");
    if ((gIIODebugFlags & 0x10000000000) != 0)
    {
      ImageIOLog("-------------------------------------------------------------\n");
      if ((gIIODebugFlags & 0x10000000000) != 0) {
        ImageIOLog("           writerMode:  %s [0x%X]\n", IIO_WriterModeString(CGImagePluginWriteModes)::output, a6);
      }
    }
  }
  uint64_t v114 = 0;
  long long v112 = 0u;
  long long v113 = 0u;
  if (a3 != 1 && a4)
  {
    if ((gIIODebugFlags & 0x2000000000000) != 0) {
      ImageIOLog("*** ERROR: Orientation '%d' not handled - fallback to old CGImageCreateConforming.\n", a3);
    }
    uint64_t PixelDataProviderForExtendedRange = 0;
    goto LABEL_332;
  }
  uint64_t v108 = a5;
  *(void *)&long long v113 = _ImageGetBitmapInfo(image);
  LODWORD(v112) = (unsigned __int16)CGImageGetBitsPerComponent(image);
  DWORD1(v112) = (unsigned __int16)CGImageGetBitsPerPixel(image);
  *((void *)&v112 + 1) = CGImageGetColorSpace(image);
  *((void *)&v113 + 1) = CGImageGetDecode(image);
  size_t BitsPerComponent = CGImageGetBitsPerComponent(image);
  size_t BitsPerPixel = CGImageGetBitsPerPixel(image);
  ColorSpace = CGImageGetColorSpace(image);
  CGColorSpaceModel Model = CGColorSpaceGetModel(ColorSpace);
  unsigned int Type = CGColorSpaceGetType();
  int AlphaInfo = _ImageGetAlphaInfo(image);
  int EndianInfo = _ImageGetEndianInfo(image);
  int IsFloat = _ImageIsFloat(image);
  CFStringRef v21 = *(const __CFString **)(a1 + 72);
  int v106 = (double *)Decode;
  if (v21) {
    BOOL v100 = CFEqual(v21, @"public.tiff");
  }
  else {
    BOOL v100 = 0;
  }
  uint64_t PixelDataProviderForExtendedRange = 0;
  if ((a6 & 0x7F000000) == 0 || (a6 & 0x1FF00) == 0 || !image || (a6 & 0x7F) == 0) {
    goto LABEL_332;
  }
  unsigned int v22 = IIOImageDestination::adjustWriteModesForWriter(a1, a6, BitsPerComponent, Model, AlphaInfo, *(_DWORD *)(a1 + 40), ColorSpace, a7);
  unsigned int v23 = v22;
  if ((gIIODebugFlags & 0x10000000000) != 0)
  {
    ImageIOLog("       new writerMode:  %s [0x%X]\n", IIO_WriterModeString(CGImagePluginWriteModes)::output, v22);
    if ((gIIODebugFlags & 0x10000000000) != 0)
    {
      CGBitmapInfo BitmapInfo = CGImageGetBitmapInfo(image);
      CGBitmapInfo v25 = CGImageGetBitmapInfo(image);
      int v26 = IIO_BitmapInfoString(v25);
      ImageIOLog("     image bitmapInfo:  0x%X %s\n", BitmapInfo, v26);
    }
  }
  if (Type == 7)
  {
    ColorSpace = CGColorSpaceGetBaseColorSpace(ColorSpace);
    unsigned int v27 = CGColorSpaceGetType();
    CGColorSpaceModel Model = CGColorSpaceGetModel(ColorSpace);
    int v28 = 1;
    BOOL v29 = Model == kCGColorSpaceModelRGB;
    if (Model == kCGColorSpaceModelRGB)
    {
      int v30 = 1;
      if ((v23 & 0x10) != 0) {
        goto LABEL_33;
      }
    }
  }
  else
  {
    LOBYTE(v28) = Model == kCGColorSpaceModelRGB;
    BOOL v29 = Model == kCGColorSpaceModelRGB;
    unsigned int v27 = Type;
  }
  int v31 = !v29;
  if (Type == 7) {
    int v31 = 1;
  }
  if ((v23 & 1) == 0) {
    int v31 = 1;
  }
  if (v31 != 1 || (v28 & 1) == 0)
  {
    int v28 = v29;
    int v30 = Model;
LABEL_33:
    int v109 = 1;
    BOOL v29 = v28;
    CGColorSpaceModel Model = v30;
    goto LABEL_34;
  }
  int v109 = 0;
LABEL_34:
  if ((gIIODebugFlags & 0x10000000000) != 0)
  {
    ImageIOLog("            csIndexed: %d\n", Type == 7);
    if ((gIIODebugFlags & 0x10000000000) != 0)
    {
      CFAllocatorRef v32 = IIO_ColorModelString(Model);
      ImageIOLog("              csModel: %d = %s\n", Model, v32);
      if ((gIIODebugFlags & 0x10000000000) != 0) {
        ImageIOLog("            indexedOK: %d\n", v109);
      }
    }
  }
  unsigned int v103 = Type;
  if (((Type == 7) & ((v23 & 0x10) >> 4)) != 0) {
    unsigned int v33 = v23 & 0xF9FFFFFF;
  }
  else {
    unsigned int v33 = v23;
  }
  int v34 = (v23 & 0x11) == 0 || !v29;
  BOOL v36 = (v23 & 2) == 0 || Model != kCGColorSpaceModelCMYK;
  if (v34 == 1 && v36)
  {
    if (Model == kCGColorSpaceModelLab)
    {
      if ((v23 & 8) != 0) {
        goto LABEL_55;
      }
    }
    else if (Model == kCGColorSpaceModelMonochrome && (v23 & 0x24) != 0)
    {
      goto LABEL_55;
    }
    int v38 = 0;
    goto LABEL_69;
  }
LABEL_55:
  BOOL v37 = CGColorSpaceUsesExtendedRange(ColorSpace);
  int v38 = 1;
  if ((v37 & IsFloat) == 1 && (v33 & 0x10000) == 0 && (v33 & 0x8000) == 0)
  {
    if (v29)
    {
      if ((gIIODebugFlags & 0x8000300000) != 0) {
        ImageIOLog("COL extended-sRGB --> P3\n");
      }
      uint64_t PixelDataProviderForExtendedRange = IIOImageDestination::createPixelDataProviderForExtendedRange(a1, image, (uint64_t)&v112, v108, v33, a7);
      if (!PixelDataProviderForExtendedRange) {
        _cg_jpeg_mem_term("createPixelDataProviderConforming", 1086, "*** createPixelDataProviderForExtendedRange failed (nil)\n");
      }
      goto LABEL_332;
    }
    if (Model == kCGColorSpaceModelMonochrome)
    {
      if ((gIIODebugFlags & 0x8000300000) != 0) {
        ImageIOLog("COL extended-Gray --> gray\n");
      }
      int v38 = 1;
    }
  }
LABEL_69:
  if (!v38 && Model == kCGColorSpaceModelDeviceN && BitsPerComponent == 1 && (v33 & 0x100) != 0)
  {
    uint64_t v39 = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E4F1DC00]);
    CGImageRef CopyWithColorSpace = CGImageCreateCopyWithColorSpace(image, v39);
    if (CopyWithColorSpace)
    {
      CFStringRef v41 = CopyWithColorSpace;
      *((void *)&v112 + 1) = v39;
      uint64_t PixelDataProviderForExtendedRange = CGImagePixelDataProviderCreate((uint64_t)CopyWithColorSpace, (uint64_t)&v112);
      CGImageRelease(v41);
    }
    else
    {
      uint64_t PixelDataProviderForExtendedRange = 0;
    }
LABEL_330:
    if (v39) {
      CGColorSpaceRelease(v39);
    }
    goto LABEL_332;
  }
  char v101 = v38;
  if ((gIIODebugFlags & 0x10000000000) != 0) {
    ImageIOLog("         spaceModelOK: %d\n", v38);
  }
  if (v27 < 6 && ((0x27u >> v27) & 1) != 0) {
    int v42 = 1;
  }
  else {
    int v42 = (v27 != 9) & (v33 >> 18);
  }
  char v104 = v42;
  if ((gIIODebugFlags & 0x10000000000) != 0) {
    ImageIOLog("          spaceTypeOK: %d\n", v42);
  }
  if (BitsPerComponent == 1 && (v33 & 0x100) != 0) {
    goto LABEL_110;
  }
  if (BitsPerComponent == 2 && (v33 & 0x200) != 0) {
    goto LABEL_110;
  }
  if (BitsPerComponent == 4 && (v33 & 0x400) != 0) {
    goto LABEL_110;
  }
  if (BitsPerComponent == 8 && (v33 & 0x800) != 0) {
    goto LABEL_110;
  }
  if (BitsPerComponent == 16 && (v33 & 0x1000) != 0) {
    goto LABEL_110;
  }
  if (BitsPerComponent == 16 && (v33 & 0x4000) != 0) {
    goto LABEL_110;
  }
  int v43 = v33 & 0x10000;
  int v44 = IsFloat ^ 1;
  if (BitsPerComponent == 16 && v43 && !v44) {
    goto LABEL_110;
  }
  BOOL v45 = (v33 & 0x2000) != 0 && BitsPerComponent == 32;
  int v46 = v45 ? IsFloat ^ 1 : 1;
  if (v46 != 1) {
    goto LABEL_110;
  }
  BOOL v47 = BitsPerComponent != 32;
  int v48 = v33 & 0x8000;
  if ((v33 & 0x8000) == 0) {
    BOOL v47 = 1;
  }
  if (((v47 | v44) & 1) == 0)
  {
LABEL_110:
    int v43 = v33 & 0x10000;
    int v48 = v33 & 0x8000;
    int v49 = 1;
  }
  else
  {
    int v49 = 0;
  }
  int v50 = IsFloat ^ 1;
  if (v43) {
    int v50 = 1;
  }
  int v97 = v48;
  if (v48) {
    int v50 = 1;
  }
  int v102 = v49 & v50;
  if ((gIIODebugFlags & 0x10000000000) != 0
    && (ImageIOLog("          bitsPerComp: %zu\n", BitsPerComponent), (gIIODebugFlags & 0x10000000000) != 0))
  {
    ImageIOLog("              depthOK: %d\n", v102);
    BOOL v98 = ((1 << (AlphaInfo + 24)) & v33 & 0x7F000000) != 0;
    if ((gIIODebugFlags & 0x10000000000) != 0) {
      ImageIOLog("              alphaOK: %d\n", ((1 << (AlphaInfo + 24)) & v33 & 0x7F000000) != 0);
    }
  }
  else
  {
    BOOL v98 = ((1 << (AlphaInfo + 24)) & v33 & 0x7F000000) != 0;
  }
  unsigned int v96 = v43;
  if (BitsPerComponent == 1 && !EndianInfo && (v33 & 0x100) != 0) {
    goto LABEL_176;
  }
  if (BitsPerComponent == 2 && !EndianInfo && (v33 & 0x200) != 0) {
    goto LABEL_176;
  }
  if (BitsPerComponent == 4 && !EndianInfo && (v33 & 0x400) != 0) {
    goto LABEL_176;
  }
  if (BitsPerComponent == 8 && !EndianInfo && (v33 & 0x800) != 0) {
    goto LABEL_176;
  }
  if (BitsPerComponent == 8 && EndianInfo == 0x2000 && (v33 & 0x800) != 0 && (v33 & 0x40) != 0) {
    goto LABEL_176;
  }
  BOOL v51 = BitsPerComponent != 16;
  if (BitsPerComponent == 16 && EndianInfo == 12288 && (v33 & 0x1000) != 0) {
    goto LABEL_176;
  }
  if (BitsPerComponent == 16 && !EndianInfo && (v33 & 0x1000) != 0) {
    goto LABEL_176;
  }
  if (EndianInfo != 4096) {
    BOOL v51 = 1;
  }
  if (!v51 && (v33 & 0x4000) != 0) {
    goto LABEL_176;
  }
  BOOL v52 = !v43 || v51;
  int v53 = IsFloat ^ 1;
  if (!v52 && !v53) {
    goto LABEL_176;
  }
  BOOL v55 = BitsPerComponent != 32 || EndianInfo != 0x4000;
  if ((v33 & 0x2000) == 0) {
    BOOL v55 = 1;
  }
  if ((v55 | v53) != 1) {
    goto LABEL_176;
  }
  BOOL v57 = BitsPerComponent != 32 || EndianInfo != 0;
  if ((v33 & 0x2000) == 0) {
    BOOL v57 = 1;
  }
  if ((v57 | v53) != 1)
  {
LABEL_176:
    int v60 = 1;
  }
  else if (BitsPerComponent != 32 || EndianInfo != 0x2000 || v97 == 0)
  {
    int v60 = 0;
  }
  else
  {
    int v60 = IsFloat;
  }
  if ((gIIODebugFlags & 0x10000000000) != 0)
  {
    ImageIOLog("          bitsPerComp: %zd\n", BitsPerComponent);
    if ((gIIODebugFlags & 0x10000000000) != 0)
    {
      ImageIOLog("           endianInfo: %d [0x%X]\n", EndianInfo, EndianInfo);
      if ((gIIODebugFlags & 0x10000000000) != 0) {
        ImageIOLog("             endianOK: %d\n", v60);
      }
    }
  }
  if (v106)
  {
    BOOL v61 = *v106 == 1.0 && v106[1] == 0.0;
    if (*v106 == 0.0)
    {
      int v62 = v106[1] == 1.0;
      if (Model) {
        goto LABEL_194;
      }
    }
    else
    {
      int v62 = 0;
      if (Model) {
        goto LABEL_194;
      }
    }
  }
  else
  {
    BOOL v61 = 0;
    int v62 = 1;
    if (Model) {
      goto LABEL_194;
    }
  }
  int v63 = v61 & (v23 >> 5);
  if (BitsPerComponent == 1) {
    int v63 = 1;
  }
  int v62 = v63 | v62 & (v23 >> 2);
LABEL_194:
  if ((gIIODebugFlags & 0x10000000000) != 0) {
    ImageIOLog("             decodeOK: %d\n", v62);
  }
  int v99 = v62;
  HasMasCFIndex k = _ImageHasMask();
  BOOL v65 = HasMask;
  if ((gIIODebugFlags & 0x10000000000) != 0) {
    ImageIOLog("               maskOK: %d\n", !HasMask);
  }
  double v66 = CGImageGetColorSpace(image);
  MinimalPixelCFIndex Size = _GetMinimalPixelSize(v66, BitsPerComponent, AlphaInfo);
  size_t v68 = MinimalPixelSize;
  if ((gIIODebugFlags & 0x10000000000) != 0) {
    ImageIOLog("                bppOK: %d\n", BitsPerPixel == MinimalPixelSize);
  }
  char v69 = IIO_CGImageWrapsIOSurface((uint64_t)image, 1);
  char v70 = v102 & v104 & v109 & v101 & v99 & !v65 & v98 & v60;
  if (BitsPerPixel != v68) {
    char v70 = 0;
  }
  if ((v70 & 1) == 0 && (*(_DWORD *)&v69 & ((v33 & 0x80000) >> 19)) == 0)
  {
    if (_ImageIsOpaque(image))
    {
      if ((v33 & 0x40000000) != 0)
      {
        int v72 = 6;
        int v71 = v97;
      }
      else
      {
        int v71 = v97;
        if ((v33 & 0x20000000) != 0)
        {
          int v72 = 5;
        }
        else if ((v33 & 0x1000000) != 0)
        {
          int v72 = 0;
        }
        else if ((v33 & 0x8000000) != 0)
        {
          int v72 = 3;
        }
        else if ((v33 & 0x10000000) != 0)
        {
          int v72 = 4;
        }
        else if ((v33 & 0x2000000) != 0)
        {
          int v72 = 1;
        }
        else if ((v33 & 0x4000000) != 0)
        {
          int v72 = 2;
        }
        else
        {
          int v72 = 0x1000000;
        }
      }
      goto LABEL_240;
    }
    unsigned int v73 = AlphaInfo - 1;
    if ((v33 & 0x2000000) != 0 && (v73 < 2 || v100 && (gIIODebugFlags & 0x800000000) == 0))
    {
      int v72 = 1;
    }
    else if ((v33 & 0x4000000) != 0 && (v73 < 2 || v100 && (gIIODebugFlags & 0x800000000) == 0))
    {
      int v72 = 2;
    }
    else
    {
      if ((v33 & 0x8000000) == 0)
      {
        if ((v33 & 0x10000000) != 0) {
          int v72 = 4;
        }
        else {
          int v72 = 1;
        }
        if ((v33 & 0x12000000) == 0) {
          int v72 = 2;
        }
        int v71 = v97;
        if ((v33 & 0x16000000) == 0)
        {
          if ((v33 & 0x40000000) != 0) {
            int v72 = 6;
          }
          else {
            int v72 = ((int)(4 * v33) >> 31) & 5;
          }
        }
LABEL_240:
        if ((v33 & 0x1000000) != 0 && (v72 - 7) >= 0xFFFFFFFE && Model == kCGColorSpaceModelCMYK) {
          int v76 = 0;
        }
        else {
          int v76 = v72;
        }
        char v77 = v101;
        if ((v102 & 1) == 0)
        {
          if ((v33 & 0x1FF00) == 0x2000) {
            goto LABEL_254;
          }
          char v78 = IsFloat;
          if ((v33 & 0xA000) == 0) {
            char v78 = 0;
          }
          if (v78)
          {
LABEL_254:
            size_t BitsPerComponent = 32;
          }
          else if (v96 && IsFloat == 1 || BitsPerComponent >= 9 && (v33 & 0x5000) != 0)
          {
            size_t BitsPerComponent = 16;
          }
          else
          {
            int v90 = (v33 >> 11) & 1;
            if ((v33 & 0x15000) == 0) {
              int v90 = 1;
            }
            if (v90) {
              size_t BitsPerComponent = 8;
            }
            else {
              size_t BitsPerComponent = 16;
            }
            char v77 = v101;
          }
        }
        if ((v60 & 1) == 0)
        {
          if (BitsPerComponent == 16 && (v33 & 0x14000) != 0)
          {
            unsigned int v79 = v76 | 0x1000;
            goto LABEL_272;
          }
          BOOL v80 = BitsPerComponent != 32 || v71 == 0;
          int v81 = IsFloat ^ 1;
          if (v80) {
            int v81 = 1;
          }
          if (v81) {
            int v82 = 0;
          }
          else {
            int v82 = 0x2000;
          }
          int EndianInfo = v82;
        }
        unsigned int v79 = EndianInfo | v76;
        if (BitsPerComponent != 16)
        {
          if (BitsPerComponent == 32) {
            v79 |= 0x100u;
          }
LABEL_276:
          char v83 = v77 ^ 1 | v104 ^ 1;
          int v84 = v109;
          if (v103 != 7) {
            int v84 = 0;
          }
          if ((v83 & 1) == 0 && v84)
          {
            __int16 v85 = CGImageGetColorSpace(image);
LABEL_288:
            CGColorSpaceRef v89 = CGColorSpaceRetain(v85);
LABEL_320:
            uint64_t v39 = v89;
            goto LABEL_321;
          }
          if ((v83 & 1) == 0)
          {
            __int16 v85 = ColorSpace;
            goto LABEL_288;
          }
          char v86 = v101 ^ 1;
          if (Model == kCGColorSpaceModelCMYK) {
            char v87 = v101 ^ 1;
          }
          else {
            char v87 = 1;
          }
          if ((v87 & 1) == 0)
          {
LABEL_286:
            unsigned int v88 = (CFStringRef *)MEMORY[0x1E4F1DBF0];
LABEL_319:
            CGColorSpaceRef v89 = CGColorSpaceCreateWithName(*v88);
            goto LABEL_320;
          }
          if (Model) {
            char v86 = 1;
          }
          if (v86)
          {
            if ((v23 & 1) != 0 && (v79 & 0x100) != 0)
            {
              unsigned int v88 = (CFStringRef *)MEMORY[0x1E4F1DBE0];
              goto LABEL_319;
            }
            if (v23)
            {
              unsigned int v88 = (CFStringRef *)MEMORY[0x1E4F1DC98];
              goto LABEL_319;
            }
            if ((v23 & 2) != 0) {
              goto LABEL_286;
            }
            if ((v23 & 4) == 0)
            {
              uint64_t v39 = 0;
LABEL_321:
              size_t v91 = _GetMinimalPixelSize(v39, BitsPerComponent, v76);
              *(void *)&long long v112 = __PAIR64__(v91, BitsPerComponent);
              *((void *)&v112 + 1) = v39;
              *(void *)&long long v113 = v79;
              int v92 = v106;
              if (!v99) {
                int v92 = 0;
              }
              *((void *)&v113 + 1) = v92;
              if ((gIIODebugFlags & 0x10000000000) != 0)
              {
                ImageIOLog("CGImagePixelDataProviderCreate\n");
                if ((gIIODebugFlags & 0x10000000000) != 0)
                {
                  int v93 = IIO_BitmapInfoString(v79);
                  ImageIOLog("        newBitmapInfo: %d  %s\n", v79, v93);
                  if ((gIIODebugFlags & 0x10000000000) != 0)
                  {
                    ImageIOLog("    newbits/Component: %d\n", BitsPerComponent);
                    if ((gIIODebugFlags & 0x10000000000) != 0) {
                      ImageIOLog("        newbits/Pixel: %zd\n", v91);
                    }
                  }
                }
              }
              uint64_t PixelDataProviderForExtendedRange = CGImagePixelDataProviderCreate((uint64_t)image, (uint64_t)&v112);
              if (!PixelDataProviderForExtendedRange) {
                _cg_jpeg_mem_term("createPixelDataProviderConforming", 1439, "*** CGImagePixelDataProviderCreate failed (nil)\n");
              }
              goto LABEL_330;
            }
          }
          unsigned int v88 = (CFStringRef *)MEMORY[0x1E4F1DC00];
          goto LABEL_319;
        }
LABEL_272:
        if (IsFloat)
        {
          v79 |= v96 >> 8;
        }
        else if ((v33 & 0x5000) == 0)
        {
          v79 |= 0x100u;
        }
        goto LABEL_276;
      }
      int v72 = 3;
    }
    int v71 = v97;
    goto LABEL_240;
  }
  uint64_t PixelDataProviderForExtendedRange = CGImagePixelDataProviderCreate((uint64_t)image, (uint64_t)&v112);
  if (!PixelDataProviderForExtendedRange) {
    _cg_jpeg_mem_term("createPixelDataProviderConforming", 1278, "*** CGImagePixelDataProviderCreate (orig image) failed (nil)\n");
  }
LABEL_332:
  if ((gIIODebugFlags & 0x20000000000) != 0)
  {
    CFAbsoluteTime v94 = CFAbsoluteTimeGetCurrent();
    ImageIOLog("    IIOImageDestination::createPixelDataProviderConforming - %g ms\n", (v94 - Current) * 1000.0);
  }
  return PixelDataProviderForExtendedRange;
}

CGImage *CGImageCreateCopyWithParametersNew(CGImageRef image, CGColor *a2, CGAffineTransform *a3, unint64_t a4, unint64_t a5, unint64_t a6, size_t a7, unint64_t a8, CGColorSpace *a9, CGBitmapInfo a10, BOOL a11, CGColorRenderingIntent a12, CGInterpolationQuality a13, BOOL a14)
{
  if ((gIIODebugFlags & 0x400000000) != 0) {
    ImageIOLog("    %s\n", "CGImageCreateCopyWithParametersNew");
  }
  CGImageGetColorSpace(image);
  uint64_t v20 = CGColorSpaceRetain(a9);
  if (!a4 || !a5)
  {
    _cg_jpeg_mem_term("CGImageCreateCopyWithParametersNew", 526, "*** ERROR: bad dimension: %dx%d\n");
    goto LABEL_28;
  }
  if (!image)
  {
    _cg_jpeg_mem_term("CGImageCreateCopyWithParametersNew", 527, "*** ERROR: image is NULL\n");
LABEL_28:
    if (!v20) {
      return 0;
    }
    goto LABEL_52;
  }
  size_t Width = CGImageGetWidth(image);
  size_t Height = CGImageGetHeight(image);
  if (a6 > 0x20 || ((1 << a6) & 0x100010100) == 0)
  {
    _cg_jpeg_mem_term("CGImageCreateCopyWithParametersNew", 529, "*** ERROR: bad bitsPerComponent '%d'\n");
    goto LABEL_28;
  }
  if (!v20)
  {
    _cg_jpeg_mem_term("CGImageCreateCopyWithParametersNew", 530, "*** ERROR: targetColorSpace is NULL\n");
    return 0;
  }
  unint64_t v62 = Height;
  int v63 = a3;
  CGBitmapInfo v23 = a10;
  unsigned int v24 = a10 & 0x1F;
  if (_GetMinimalPixelSize(v20, a6, v24) > a7)
  {
    _GetMinimalPixelSize(v20, a6, a10 & 0x1F);
    _cg_jpeg_mem_term("CGImageCreateCopyWithParametersNew", 531, "*** ERROR: bpp: %d   minPixelSize: %d");
LABEL_52:
    CGColorSpaceRelease(v20);
    return 0;
  }
  if (a8 < (a7 * a4 + 7) >> 3)
  {
    _cg_jpeg_mem_term("CGImageCreateCopyWithParametersNew", 532, "*** ERROR: bad bytesPerRow %d for width: %d bpc: %d\n");
    goto LABEL_52;
  }
  if (CGColorSpaceGetType() == 7)
  {
    CGColorSpaceGetType();
    _cg_jpeg_mem_term("CGImageCreateCopyWithParametersNew", 533, "*** ERROR: bad targetColorSpaceType %d\n");
    goto LABEL_52;
  }
  if (!_ValidAlphaInfo(a6, a7, v20, a10 & 0x1F))
  {
    _cg_jpeg_mem_term("CGImageCreateCopyWithParametersNew", 534, "*** ERROR: bad bpc:%d bpp:%d alpha:%d\n");
    goto LABEL_52;
  }
  unint64_t v61 = Width;
  unint64_t v64 = a8;
  BOOL v25 = CGColorSpaceUsesExtendedRange(v20);
  if (a6 <= 0xF && v25) {
    _cg_jpeg_mem_term("CGImageCreateCopyWithParametersNew", 538, "*** ERROR: dstColorSpace is extended, but requested bitsPerComponent is '%d'\n", a6);
  }
  unsigned int v26 = a10 & 0xFFFFFFE0;
  CGColorSpaceModel Model = CGColorSpaceGetModel(v20);
  CGColorSpaceModel v28 = Model;
  if (Model == kCGColorSpaceModelRGB)
  {
    if ((a10 & 0x100) == 0)
    {
      if (a6 == 8 && a7 == 24 && (a10 & 0x1F) == 0)
      {
LABEL_21:
        CGBitmapInfo v23 = v26 | 5;
LABEL_62:
        size_t v60 = a7;
        if (v23 != a10)
        {
          int v66 = 0;
          LODWORD(a7) = 4 * a6;
          unint64_t v30 = (((4 * a6 * a4) >> 3) + 15) & 0x3FFFFFFFFFFFFFF0;
          goto LABEL_69;
        }
        int v66 = 0;
        CGBitmapInfo v23 = a10;
        goto LABEL_64;
      }
      if (a7 == 32 && a6 == 8 && v24 == 4)
      {
        CGBitmapInfo v23 = v26 | 2;
        goto LABEL_62;
      }
      if (a7 != 32 || a6 != 8 || v24 != 3)
      {
        if (a7 == 32 && a6 == 8 && v24 == 6)
        {
          CGBitmapInfo v23 = v26 | 6;
          goto LABEL_62;
        }
        if ((a7 != 32 || a6 != 8 || v24 != 5)
          && (a6 != 16 || a7 != 48 || (a10 & 0x1F) != 0)
          && (a7 != 64 || a6 != 16 || v24 != 6))
        {
          if (v24 == 3 && a6 == 16 && a7 == 64) {
            CGBitmapInfo v23 = v26 | 1;
          }
          goto LABEL_62;
        }
        goto LABEL_21;
      }
LABEL_61:
      CGBitmapInfo v23 = v26 | 1;
      goto LABEL_62;
    }
    if (a6 == 16 || a6 == 32)
    {
      if (v24 - 1 >= 4)
      {
        if (v24 - 5 >= 2)
        {
          if ((a10 & 0x1F) != 0)
          {
            int v66 = 0;
            unint64_t v30 = v64;
            size_t v60 = a7;
            goto LABEL_69;
          }
          if (a7 == 48 || a7 == 96) {
            goto LABEL_21;
          }
          _cg_jpeg_mem_term("CGImageCreateCopyWithParametersNew", 559, "*** ERROR: bitsPerPixel: %d alphaInfo:%d\n");
        }
        else
        {
          if (a7 == 64 || a7 == 128) {
            goto LABEL_21;
          }
          _cg_jpeg_mem_term("CGImageCreateCopyWithParametersNew", 572, "*** ERROR: bitsPerPixel: %d alphaInfo:%d\n");
        }
      }
      else
      {
        if (a7 == 64 || a7 == 128) {
          goto LABEL_61;
        }
        _cg_jpeg_mem_term("CGImageCreateCopyWithParametersNew", 567, "*** ERROR: bitsPerPixel: %d alphaInfo:%d\n");
      }
    }
    else
    {
      _cg_jpeg_mem_term("CGImageCreateCopyWithParametersNew", 554, "*** ERROR: bitsPerPixel: %d alphaInfo:%d\n");
    }
    goto LABEL_52;
  }
  size_t v60 = a7;
  if (Model == kCGColorSpaceModelCMYK)
  {
    int v66 = 0;
    if (a6 == 8 && a7 == 40)
    {
      unsigned int v29 = v24 - 1;
      unint64_t v30 = v64;
      if (v29 <= 3)
      {
        unint64_t v30 = (4 * (a4 & 0x7FFFFFFFFFFFFFFLL) + 15) & 0x3FFFFFFFFFFFFFF0;
        int v66 = 1;
        LODWORD(a7) = 40;
LABEL_50:
        CGBitmapInfo v23 = a10 & 0xFFFFFFE0;
        goto LABEL_69;
      }
      goto LABEL_69;
    }
LABEL_64:
    unint64_t v30 = v64;
    goto LABEL_69;
  }
  if (a6 == 8 && a7 == 16 && Model == kCGColorSpaceModelMonochrome)
  {
    if (v24 - 1 >= 4)
    {
      if (v24 - 5 < 2) {
        CGBitmapInfo v23 = v26 | 5;
      }
    }
    else
    {
      CGBitmapInfo v23 = v26 | 1;
    }
    int v66 = 0;
    unint64_t v30 = (2 * a4 + 15) & 0xFFFFFFFFFFFFFFF0;
    LODWORD(a7) = 16;
    goto LABEL_69;
  }
  int v66 = 0;
  if (a6 != 16 || a7 != 32 || (a10 & 0x1F) == 0) {
    goto LABEL_64;
  }
  unint64_t v30 = v64;
  if (Model == kCGColorSpaceModelMonochrome)
  {
    unint64_t v30 = (4 * a4 + 15) & 0xFFFFFFFFFFFFFFF0;
    int v66 = 1;
    LODWORD(a7) = 32;
    goto LABEL_50;
  }
LABEL_69:
  if (!CGColorSpaceEqualToColorSpace() || CGColorSpaceSupportsOutput(v20)) {
    goto LABEL_71;
  }
  if (v28)
  {
    if (v28 == kCGColorSpaceModelRGB)
    {
      DeviceRGB = CGColorSpaceCreateDeviceRGB();
    }
    else
    {
      if (v28 != kCGColorSpaceModelCMYK)
      {
LABEL_71:
        CGImageRef CopyWithColorSpace = 0;
        unsigned int v33 = 0;
        goto LABEL_72;
      }
      DeviceRGB = CGColorSpaceCreateDeviceCMYK();
    }
  }
  else
  {
    DeviceRGB = CGColorSpaceCreateDeviceGray();
  }
  unsigned int v33 = DeviceRGB;
  if (DeviceRGB) {
    CGImageRef CopyWithColorSpace = CGImageCreateCopyWithColorSpace(image, DeviceRGB);
  }
  else {
    CGImageRef CopyWithColorSpace = 0;
  }
LABEL_72:
  if (v66)
  {
    uint64_t v59 = 0;
    int v34 = (CGContext *)CGBitmapContextCreateWithAlpha();
    if (!v34) {
      unint64_t v35 = _cg_jpeg_mem_term("CGImageCreateCopyWithParametersNew", 694, "*** ERROR: CGBitmapContextCreateWithAlpha returned NULL\n", 0).n128_u64[0];
    }
    if ((gIIODebugFlags & 0x400000000) != 0) {
      fwrite("\nCGImageCreateCopyWithParametersNew - CGBitmapContextCreateWithAlpha\n", 0x45uLL, 1uLL, (FILE *)*MEMORY[0x1E4F143C8]);
    }
  }
  else
  {
    BOOL v36 = v28 == kCGColorSpaceModelCMYK;
    BOOL v37 = v23 != 0;
    unint64_t v38 = 64;
    if (a6 == 8) {
      unint64_t v38 = 32;
    }
    BOOL v39 = !v36 || !v37;
    if (v36 && v37) {
      CGBitmapInfo v40 = 0;
    }
    else {
      CGBitmapInfo v40 = v23;
    }
    if (v39)
    {
      int v41 = a7;
    }
    else
    {
      unint64_t v30 = (v38 >> 3) * a4;
      int v41 = v38;
    }
    if (a14) {
      int v42 = v40;
    }
    else {
      int v42 = v40 | 0x1000;
    }
    if (a6 != 16) {
      int v42 = v40;
    }
    if (a6 == 32) {
      unsigned int v43 = v42 | 0x100;
    }
    else {
      unsigned int v43 = v42;
    }
    uint64_t v59 = 0;
    int v34 = (CGContext *)CGBitmapContextCreateWithDictionary();
    if (!v34)
    {
      _cg_jpeg_mem_term("CGImageCreateCopyWithParametersNew", 754, "*** ERROR: CGBitmapContextCreateWithDictionary returned NULL\n", 0);
      int v44 = IIO_BitmapInfoString(v43);
      unint64_t v35 = _cg_jpeg_mem_term("CGImageCreateCopyWithParametersNew", 755, "           size: %d x %d  rb: %d   bpc: %d   bpp: %d   bmi: %04X (%s)\n", a4, a5, v30, a6, v41, v43, v44).n128_u64[0];
    }
    if ((gIIODebugFlags & 0x400000000) != 0) {
      fwrite("\nCGImageCreateCopyWithParametersNew - CGBitmapContextCreateWithDictionary\n", 0x4AuLL, 1uLL, (FILE *)*MEMORY[0x1E4F143C8]);
    }
    if (!v33 && CGColorSpaceIsHDR(v20))
    {
      CGImageGetContentHeadroom();
      CGContextSetEDRTargetHeadroom();
    }
  }
  if (v34)
  {
    double v45 = (double)a4;
    double v46 = (double)a5;
    if (a2)
    {
      unint64_t Data = CGBitmapContextGetData(v34);
      if (CGColorGetAlpha(a2) != 1.0) {
        memset(Data, 255, v30 * a5);
      }
      CGContextSetFillColorWithColor(v34, a2);
      v69.origin.double x = 0.0;
      v69.origin.double y = 0.0;
      v69.size.double width = (double)a4;
      v69.size.double height = (double)a5;
      CGContextFillRect(v34, v69);
    }
    else
    {
      v70.origin.double x = 0.0;
      v70.origin.double y = 0.0;
      v70.size.double width = (double)a4;
      v70.size.double height = (double)a5;
      CGContextClearRect(v34, v70);
    }
    CGContextSetInterpolationQuality(v34, a13);
    if (v63->a != 0.0 || v63->b != 0.0 || v63->c != 0.0 || v63->d != 0.0)
    {
      double v45 = (double)v61;
      double v46 = (double)v62;
      long long v48 = *(_OWORD *)&v63->c;
      *(_OWORD *)&transform.a = *(_OWORD *)&v63->a;
      *(_OWORD *)&transform.c = v48;
      *(_OWORD *)&transform.tdouble x = *(_OWORD *)&v63->tx;
      CGContextConcatCTM(v34, &transform);
    }
    if (CopyWithColorSpace) {
      int v49 = CopyWithColorSpace;
    }
    else {
      int v49 = image;
    }
    v71.origin.double x = 0.0;
    v71.origin.double y = 0.0;
    v71.size.double width = v45;
    v71.size.double height = v46;
    CGContextDrawImage(v34, v71, v49);
    if (CGImageGetImageProvider() && (uint64_t v50 = *MEMORY[0x1E4F1CFD0], v50 == CGImageProviderGetProperty()))
    {
      LogError("CGImageCreateCopyWithParametersNew", 814, "*** ERROR: image decode failed due to 'kCMPhotoError_XPCError'\n");
    }
    else
    {
      CGImageRef v51 = CGBitmapContextCreateImage(v34);
      if (v51)
      {
        int v53 = v51;
        if ((gIIODebugFlags & 0x400000000) != 0) {
          fwrite("\nCGBitmapContextCreateImage:\n", 0x1DuLL, 1uLL, (FILE *)*MEMORY[0x1E4F143C8]);
        }
        CGImageSetProperty();
        CGImageSetProperty();
        int v31 = CGImageCreateCopyWithColorSpace(v53, v20);
        if ((gIIODebugFlags & 0x400000000) != 0) {
          fwrite("\nCGImageCreateCopyWithColorSpace:\n", 0x22uLL, 1uLL, (FILE *)*MEMORY[0x1E4F143C8]);
        }
        CGImageRelease(v53);
        if (v31)
        {
          if (!v66
            || (CopyWithCGBitmapInfo BitmapInfo = CGImageCreateCopyWithBitmapInfo(v31, 0, v60, v64, a10, a11, a12),
                CFRelease(v31),
                (int v31 = CopyWithBitmapInfo) != 0))
          {
            CGImageSetProperty();
          }
        }
        else
        {
          _cg_jpeg_mem_term("CGImageCreateCopyWithParametersNew", 861, "*** ERROR: dstImage is NULL\n");
        }
        goto LABEL_130;
      }
      _cg_jpeg_mem_term("CGImageCreateCopyWithParametersNew", 843, "*** ERROR: CGBitmapContextCreateImage returned NULL\n", v52, v59);
    }
  }
  else
  {
    _cg_jpeg_mem_term("CGImageCreateCopyWithParametersNew", 766, "*** ERROR: context is NULL\n", *(double *)&v35, v59);
  }
  int v31 = 0;
LABEL_130:
  CGColorSpaceRelease(v20);
  if (v33) {
    CGColorSpaceRelease(v33);
  }
  if (CopyWithColorSpace) {
    CGImageRelease(CopyWithColorSpace);
  }
  if (v34) {
    CFRelease(v34);
  }
  return v31;
}

size_t _GetMinimalPixelSize(CGColorSpace *a1, uint64_t a2, int a3)
{
  size_t NumberOfComponents = CGColorSpaceGetNumberOfComponents(a1);
  if (a3) {
    size_t v6 = NumberOfComponents + 1;
  }
  else {
    size_t v6 = NumberOfComponents;
  }
  return v6 * a2;
}

BOOL _ValidAlphaInfo(uint64_t a1, size_t a2, CGColorSpaceRef space, unsigned int a4)
{
  if (!a4) {
    return CGColorSpaceGetNumberOfComponents(space) * a1 == a2;
  }
  if (a4 <= 4) {
    return a1 + a1 * CGColorSpaceGetNumberOfComponents(space) <= a2;
  }
  if (a4 - 5 > 1) {
    return 0;
  }
  return CGColorSpaceGetNumberOfComponents(space) * a1 < a2;
}

void IIOImageDestination::cleanupDestinationProperties(IIOImageDestination *this, IIODictionary *a2)
{
  if (IIODictionary::containsKey(a2, @"HasAlpha"))
  {
    CFDictionaryRef ObjectForKey = IIODictionary::getObjectForKey(a2, @"HasAlpha");
    IIODictionary::setObjectForKey(a2, ObjectForKey, @"kCGImageDestinationAllowAlpha");
    IIODictionary::removeObjectForKey(a2, @"HasAlpha");
  }
}

uint64_t IIOImageDestination::updateCreateISOGainMapFlag(IIOImageDestination *this, CGImage *a2, IIODictionary *a3)
{
  if ((gIIODebugFlags & 0x300000) != 0) {
    ImageIOLog("  %s\n", "updateCreateISOGainMapFlag");
  }
  *((unsigned char *)this + 220) = -1;
  if (IIODictionary::containsKey(a3, @"kCGImageDestinationEncodeRequest"))
  {
    *((unsigned char *)this + 220) = 0;
    ColorSpace = CGImageGetColorSpace(a2);
    if (CGColorSpaceUsesITUR_2100TF(ColorSpace) || CGColorSpaceUsesExtendedRange(ColorSpace))
    {
      CFStringRef ObjectForKey = (const __CFString *)IIODictionary::getObjectForKey(a3, @"kCGImageDestinationEncodeRequest");
      if (CFEqual(ObjectForKey, @"kCGImageDestinationEncodeToISOGainmap")) {
        *((unsigned char *)this + 220) = 1;
      }
    }
  }
  return 0;
}

uint64_t IIOImageDestination::updateCreateHDRGainMapFlag(IIOImageDestination *this, CGImage *a2, IIODictionary *a3)
{
  if ((gIIODebugFlags & 0x300000) != 0) {
    ImageIOLog("  %s\n", "updateCreateHDRGainMapFlag");
  }
  *((unsigned char *)this + 219) = -1;
  if (IIODictionary::containsKey(a3, @"kCGImageDestinationCreateHDRGainMap"))
  {
    ColorSpace = CGImageGetColorSpace(a2);
    if (CGColorSpaceUsesITUR_2100TF(ColorSpace) || (BOOL v7 = CGColorSpaceUsesExtendedRange(ColorSpace))) {
      LOBYTE(v7) = IIODictionary::getBoolForKey(a3, @"kCGImageDestinationCreateHDRGainMap");
    }
    *((unsigned char *)this + 219) = v7;
  }
  return 0;
}

__n128 IIOImageDestination::setImagePropertiesAtIndex(IIOImageDestination *this, IIODictionary *a2, unsigned int a3)
{
  uint64_t v4 = (unsigned char *)*((void *)this + 16);
  size_t v6 = (char *)*((void *)this + 17);
  float v5 = (void **)((char *)this + 128);
  uint64_t v7 = v6 - v4;
  if (a3 >= ((unint64_t)(v6 - v4) >> 3))
  {
    unsigned int v11 = *((_DWORD *)this + 12);
    if (a3 >= v11)
    {
      return _cg_jpeg_mem_term("setImagePropertiesAtIndex", 4252, "setImagePropertiesAtIndex index (%d) larger than vectorCount (%d) and image count (%d\n", a3, (unint64_t)(v6 - v4) >> 3, v11);
    }
    else
    {
      unint64_t v12 = a3;
      unint64_t v13 = v7 >> 3;
      if (v7 >> 3 <= (unint64_t)a3)
      {
        uint64_t v15 = (void *)((char *)this + 144);
        do
        {
          if ((unint64_t)v6 >= *v15)
          {
            if ((v13 + 1) >> 61) {
              std::vector<IIOTag *>::__throw_length_error[abi:ne180100]();
            }
            uint64_t v16 = *v15 - (void)v4;
            uint64_t v17 = v16 >> 2;
            if (v16 >> 2 <= v13 + 1) {
              uint64_t v17 = v13 + 1;
            }
            if ((unint64_t)v16 >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v18 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v18 = v17;
            }
            if (v18) {
              int64_t v19 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<IIOTag *>>((uint64_t)v15, v18);
            }
            else {
              int64_t v19 = 0;
            }
            uint64_t v20 = &v19[8 * v13];
            *(void *)uint64_t v20 = 0;
            size_t v6 = v20 + 8;
            unsigned int v22 = (char *)*((void *)this + 16);
            CFStringRef v21 = (char *)*((void *)this + 17);
            if (v21 != v22)
            {
              do
              {
                uint64_t v23 = *((void *)v21 - 1);
                v21 -= 8;
                *((void *)v20 - 1) = v23;
                v20 -= 8;
              }
              while (v21 != v22);
              CFStringRef v21 = (char *)*v5;
            }
            *((void *)this + 16) = v20;
            *((void *)this + 17) = v6;
            *((void *)this + 18) = &v19[8 * v18];
            if (v21) {
              operator delete(v21);
            }
          }
          else
          {
            *(void *)size_t v6 = 0;
            v6 += 8;
          }
          *((void *)this + 17) = v6;
          uint64_t v4 = (unsigned char *)*((void *)this + 16);
          unint64_t v13 = (v6 - v4) >> 3;
        }
        while (v13 <= v12);
      }
      *(void *)&v4[8 * v12] = a2;
    }
  }
  else
  {
    uint64_t v8 = a3;
    uint64_t v9 = *(void *)&v4[8 * a3];
    if (v9)
    {
      (*(void (**)(uint64_t))(*(void *)v9 + 8))(v9);
      uint64_t v4 = *v5;
    }
    *(void *)&v4[8 * v8] = a2;
  }
  return result;
}

uint64_t IIOImageDestination::adjustWriteModesForWriter(uint64_t a1, uint64_t a2, int a3, int a4, int a5, unsigned int a6, CGColorSpace *a7, IIODictionary *this)
{
  if (!*(void *)(a1 + 64) || !*(void *)(a1 + 72)) {
    return 0;
  }
  uint64_t v16 = a2;
  if (this)
  {
    uint64_t v16 = a2;
    if (IIODictionary::containsKey(this, @"kCGImageDestinationAllowAlpha"))
    {
      if (IIODictionary::getBoolForKey(this, @"kCGImageDestinationAllowAlpha")) {
        uint64_t v16 = a2;
      }
      else {
        uint64_t v16 = a2 & 0xE1FFFFFF;
      }
    }
  }
  if (CFEqual(*(CFStringRef *)(a1 + 72), @"public.png"))
  {
    if (a3 > 7) {
      goto LABEL_42;
    }
    if (a4 == 5)
    {
      if ((a5 - 1) > 3) {
        goto LABEL_42;
      }
    }
    else if (!a4 && (a5 - 1) >= 4)
    {
      goto LABEL_42;
    }
    LODWORD(v16) = v16 & 0xFFFFF8FF;
LABEL_42:
    if (a6 <= 1) {
      uint64_t v16 = v16;
    }
    else {
      uint64_t v16 = v16 & 0xFFFFBFFF;
    }
    goto LABEL_45;
  }
  if (CFEqual(*(CFStringRef *)(a1 + 72), @"public.heic"))
  {
    if (a5) {
      BOOL v19 = 0;
    }
    else {
      BOOL v19 = a3 == 16;
    }
    if (v19 && a4 == 1) {
      uint64_t v16 = v16 & 0xFFFEAFFF;
    }
    else {
      uint64_t v16 = v16;
    }
    goto LABEL_45;
  }
  if (CFEqual(*(CFStringRef *)(a1 + 72), @"public.jpeg"))
  {
    if (((a4 == 0) & (a2 >> 2)) != 0) {
      uint64_t v16 = v16 & 0x9FFFFFFF;
    }
    else {
      uint64_t v16 = v16;
    }
    goto LABEL_45;
  }
  if (CFEqual(*(CFStringRef *)(a1 + 72), @"com.microsoft.bmp"))
  {
    if (a4 != 5 || a3 == 8) {
      uint64_t v16 = v16;
    }
    else {
      uint64_t v16 = v16 & 0xFFFFFFEF;
    }
    goto LABEL_45;
  }
  if (CFEqual(*(CFStringRef *)(a1 + 72), @"com.apple.atx"))
  {
    unsigned int v26 = *(IIODictionary **)(a1 + 88);
    if (v26 && IIODictionary::containsKey(v26, @"kCGImagePropertyEncoder"))
    {
      unsigned int v27 = *(IIODictionary **)(a1 + 88);
    }
    else
    {
      if (!this) {
        goto LABEL_60;
      }
      if (!IIODictionary::containsKey(this, @"kCGImagePropertyEncoder")) {
        goto LABEL_46;
      }
      unsigned int v27 = this;
    }
    CFDictionaryRef ObjectForKey = IIODictionary::getObjectForKey(v27, @"kCGImagePropertyEncoder");
    if (ObjectForKey)
    {
      if (CFEqual(ObjectForKey, @"kCGImageProperty420fEncoder")) {
        uint64_t v16 = v16 & 0xF4FFFFFF;
      }
      else {
        uint64_t v16 = v16;
      }
    }
    goto LABEL_45;
  }
  CFStringRef v17 = @"org.khronos.ktx";
  uint64_t Uint32ForKey = CFStringCompare(*(CFStringRef *)(a1 + 72), @"org.khronos.ktx", 0);
  if (!Uint32ForKey)
  {
    if (!this) {
      goto LABEL_93;
    }
    if (IIODictionary::containsKey(this, @"kCGImagePropertyEncoder"))
    {
      CFDictionaryRef v29 = IIODictionary::getObjectForKey(this, @"kCGImagePropertyEncoder");
      if (CFEqual(v29, @"kCGImagePropertyPVREncoder"))
      {
        unint64_t v30 = kCGImageTypeIdentifierPVR;
LABEL_85:
        CFStringRef v17 = *v30;
        goto LABEL_86;
      }
      if (CFEqual(v29, @"kCGImagePropertyBCEncoder"))
      {
        unint64_t v30 = kCGImageTypeIdentifierBC;
        goto LABEL_85;
      }
      if (CFEqual(v29, @"kCGImagePropertyASTCEncoder")) {
        CFStringRef v17 = @"org.khronos.astc";
      }
    }
LABEL_86:
    uint64_t Uint32ForKey = (uint64_t)IIODictionary::containsKey(this, @"kCGImagePropertyBCFormat");
    if (Uint32ForKey)
    {
      uint64_t Uint32ForKey = (uint64_t)IIODictionary::getUint32ForKey(this, @"kCGImagePropertyBCFormat");
      BOOL v32 = (Uint32ForKey & 0xFFFFFFFD) != 0x8DBC && (Uint32ForKey - 36496) < 0xFFFFFFFE;
      goto LABEL_94;
    }
LABEL_93:
    BOOL v32 = 0;
LABEL_94:
    WriterHandler = (IIO_WriterHandler *)IIO_WriterHandler::GetWriterHandler((IIO_WriterHandler *)Uint32ForKey);
    WriterForunsigned int Type = IIO_WriterHandler::findWriterForType(WriterHandler, v17, (const __CFString *)1, this, v34);
    if (WriterForType) {
      LODWORD(v16) = HEIFAuxImage::auxiliaryPixelFormat(WriterForType);
    }
    if (v32) {
      uint64_t v16 = v16 & 0xFFFE7FFF;
    }
    else {
      uint64_t v16 = v16;
    }
    if (a7)
    {
      switch(a4)
      {
        case 2:
          uint64_t v16 = v16 & 0xFFFBFFFF;
          break;
        case 1:
          if (!IIO_CGColorSpaceNameMatchesName(a7, (const __CFString *)*MEMORY[0x1E4F1DC98])
            && !IIO_CGColorSpaceNameMatchesName(a7, (const __CFString *)*MEMORY[0x1E4F1DB90]))
          {
            CFStringRef v36 = (const __CFString *)*MEMORY[0x1E4F1DB78];
            v37[0] = (CGColorSpaceRef)&unk_1ED4DFD58;
            v37[1] = CGColorSpaceCreateWithName(v36);
            if (IIO_CGColorSpaceNameMatchesName(a7, v36)) {
              uint64_t v16 = v16;
            }
            else {
              uint64_t v16 = v16 & 0xFFFBFFFF;
            }
            IIOColorSpace::~IIOColorSpace(v37);
          }
          break;
        case 0:
          if (IIO_CGColorSpaceNameMatchesName(a7, (const __CFString *)*MEMORY[0x1E4F1DC00])) {
            uint64_t v16 = v16;
          }
          else {
            uint64_t v16 = v16 & 0xFFFBFFFF;
          }
          break;
      }
    }
LABEL_45:
    if (!this) {
      goto LABEL_60;
    }
    goto LABEL_46;
  }
  if (CFStringCompare(*(CFStringRef *)(a1 + 72), @"com.compuserve.gif", 0))
  {
    CFStringCompare(*(CFStringRef *)(a1 + 72), @"com.apple.icns", 0);
    goto LABEL_45;
  }
  if (!this) {
    goto LABEL_60;
  }
  if (IIODictionary::containsKeyGroup(this, @"ImageColorMap", @"{GIF}")) {
    uint64_t v16 = v16 | 0x1000000;
  }
  else {
    uint64_t v16 = v16;
  }
LABEL_46:
  if (!IIODictionary::containsKey(this, @"Depth")) {
    goto LABEL_60;
  }
  unsigned int v22 = IIODictionary::getUint32ForKey(this, @"Depth");
  if (v22 == 8)
  {
    if ((a2 & 0x800) != 0)
    {
LABEL_55:
      unsigned int v24 = v16 & 0xFFFF5FFF;
      if (v22 >= 0x11) {
        unsigned int v24 = v16;
      }
      if (v22 >= 9) {
        uint64_t v16 = v24;
      }
      else {
        uint64_t v16 = v24 & 0xFFFEAFFF;
      }
    }
  }
  else
  {
    if (v22 == 32)
    {
      int v23 = 40960;
    }
    else
    {
      if (v22 != 16) {
        goto LABEL_60;
      }
      int v23 = 86016;
    }
    if ((a2 & v23) != 0) {
      goto LABEL_55;
    }
  }
LABEL_60:
  if (v16 == a2) {
    return a2;
  }
  if ((gIIODebugFlags & 0x10000000000) != 0) {
    ImageIOLog("        adjusted mode: 0x%X  ->  0x%X\n", a2, v16);
  }
  return v16;
}

void sub_1886061E4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  IIOColorSpace::~IIOColorSpace((CGColorSpaceRef *)va);
  _Unwind_Resume(a1);
}

__n128 IIOImageDestination::setPixelProviderAtIndex(uint64_t a1, const void *a2, CFIndex a3)
{
  unsigned int Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 96));
  uint64_t v7 = (const void *)*MEMORY[0x1E4F1D260];
  if (!a2) {
    a2 = (const void *)*MEMORY[0x1E4F1D260];
  }
  if (a3 >= Count)
  {
    if (*(void *)(a1 + 48) <= a3) {
      return _cg_jpeg_mem_term("setPixelProviderAtIndex", 4170, "setImageMedadataAtIndex index (%d) larger than arrayCount (%d) and image count (%d)\n", a3, Count, *(void *)(a1 + 48));
    }
    while (CFArrayGetCount(*(CFArrayRef *)(a1 + 96)) <= a3)
      CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 96), v7);
  }
  uint64_t v8 = *(__CFArray **)(a1 + 96);

  CFArraySetValueAtIndex(v8, a3, a2);
  return result;
}

__n128 IIOImageDestination::setSourceImageAtIndex(IIOImageDestination *this, CGImageRef image, uint64_t a3)
{
  uint64_t v4 = *((void *)this + 13);
  size_t v6 = (void *)*((void *)this + 14);
  float v5 = (void **)((char *)this + 104);
  unint64_t v7 = ((uint64_t)v6 - v4) >> 3;
  if (a3 >= v7)
  {
    unsigned int v11 = *((_DWORD *)this + 12);
    if (a3 >= v11)
    {
      return _cg_jpeg_mem_term("setSourceImageAtIndex", 4211, "setSourceImageAtIndex index (%d) larger than vectorCount (%d) and image count (%d\n", a3, ((uint64_t)v6 - v4) >> 3, v11);
    }
    else
    {
      unint64_t v12 = a3;
      if (v7 <= a3)
      {
        uint64_t v14 = (void *)((char *)this + 120);
        do
        {
          if ((unint64_t)v6 >= *v14)
          {
            if ((v7 + 1) >> 61) {
              std::vector<IIOTag *>::__throw_length_error[abi:ne180100]();
            }
            uint64_t v15 = *v14 - v4;
            uint64_t v16 = v15 >> 2;
            if (v15 >> 2 <= v7 + 1) {
              uint64_t v16 = v7 + 1;
            }
            if ((unint64_t)v15 >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v17 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v17 = v16;
            }
            if (v17) {
              unint64_t v18 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<IIOTag *>>((uint64_t)v14, v17);
            }
            else {
              unint64_t v18 = 0;
            }
            BOOL v19 = &v18[8 * v7];
            *(void *)BOOL v19 = 0;
            size_t v6 = v19 + 8;
            CFStringRef v21 = (char *)*((void *)this + 13);
            uint64_t v20 = (char *)*((void *)this + 14);
            if (v20 != v21)
            {
              do
              {
                uint64_t v22 = *((void *)v20 - 1);
                v20 -= 8;
                *((void *)v19 - 1) = v22;
                v19 -= 8;
              }
              while (v20 != v21);
              uint64_t v20 = (char *)*v5;
            }
            *((void *)this + 13) = v19;
            *((void *)this + 14) = v6;
            *((void *)this + 15) = &v18[8 * v17];
            if (v20) {
              operator delete(v20);
            }
          }
          else
          {
            *v6++ = 0;
          }
          *((void *)this + 14) = v6;
          uint64_t v4 = *((void *)this + 13);
          unint64_t v7 = ((uint64_t)v6 - v4) >> 3;
        }
        while (v7 <= v12);
      }
      *((void *)*v5 + v12) = CGImageRetain(image);
    }
  }
  else
  {
    uint64_t v8 = a3;
    uint64_t v9 = *(CGImage **)(v4 + 8 * a3);
    if (v9) {
      CGImageRelease(v9);
    }
    *((void *)*v5 + v8) = CGImageRetain(image);
  }
  return result;
}

uint64_t IIOImageDestination::GetOptimizeForSharing(IIOImageDestination *this, IIODictionary *a2, BOOL *a3)
{
  if (a2) {
    *(unsigned char *)a2 = 0;
  }
  if (!this) {
    return 0;
  }
  uint64_t result = (uint64_t)IIODictionary::containsKey(this, @"kCGImageDestinationOptimizeColorForSharing");
  if (!result) {
    return result;
  }
  CFStringRef ObjectForKey = (const __CFString *)IIODictionary::getObjectForKey(this, @"kCGImageDestinationOptimizeColorForSharing");
  CFTypeID v7 = CFGetTypeID(ObjectForKey);
  if (v7 == CFBooleanGetTypeID()) {
    return ObjectForKey == (const __CFString *)*MEMORY[0x1E4F1CFD0];
  }
  CFTypeID v8 = CFGetTypeID(ObjectForKey);
  if (v8 != CFStringGetTypeID()) {
    return 0;
  }
  CFComparisonResult v9 = CFStringCompare(ObjectForKey, @"sRGB", 0);
  uint64_t result = v9 == kCFCompareEqualTo;
  if (a2)
  {
    if (v9 == kCFCompareEqualTo)
    {
      uint64_t result = 1;
      *(unsigned char *)a2 = 1;
    }
  }
  return result;
}

void IIOImageDestination::swapWriterIfNeeded(IIO_Writer **this, CGImage *a2, int a3)
{
  CFStringRef v6 = (const __CFString *)IIO_Writer::utType(this[8]);
  if (CFStringCompare(v6, @"public.jpeg", 0)) {
    return;
  }
  WriterHandler = (IIO_WriterHandler *)IIO_WriterHandler::GetWriterHandler(0);
  CFTypeID v8 = WriterHandler;
  if (a3)
  {
    WriterForTypeAndAlternateunsigned int Type = IIO_WriterHandler::findWriterForTypeAndAlternateType(WriterHandler, @"public.heic", @"public.jpeg", 1, 0);
    if (!WriterForTypeAndAlternateType) {
      return;
    }
    BOOL v10 = WriterForTypeAndAlternateType;
    *((_WORD *)this + 106) = 256;
    BOOL v11 = *((_DWORD *)this + 52) == 5;
    int v12 = 4;
    if (*((_DWORD *)this + 52) == 5) {
      int v13 = 6;
    }
    else {
      int v13 = 4;
    }
    *((_DWORD *)this + 52) = v13;
    if (v11) {
      int v12 = 6;
    }
    _cg_jpeg_mem_term("swapWriterIfNeeded", 4292, "*** Note: switching write plugin (auxImage): 'JPEG' --> 'HEIC'  (_transcodingMode: %d)\n", v12);
LABEL_11:
    this[8] = v10;
    return;
  }
  if (a2)
  {
    CGImageAlphaInfo AlphaInfo = CGImageGetAlphaInfo(a2);
    ColorSpace = CGImageGetColorSpace(a2);
    CGColorSpaceModel Model = CGColorSpaceGetModel(ColorSpace);
    if (AlphaInfo != kCGImageAlphaNoneSkipLast || Model)
    {
      if (IIO_CGImageWrapsIOSurface((uint64_t)a2, 1))
      {
        BOOL v10 = IIO_WriterHandler::findWriterForTypeAndAlternateType(v8, @"public.heic", @"public.jpeg", 1, 0);
        if (v10) {
          goto LABEL_11;
        }
      }
    }
  }
}

void IIOImageDestination::updateCompression(CFStringRef *this, IIODictionary *a2)
{
  if (CFEqual(this[9], @"public.tiff"))
  {
    if ((IIODictionary::containsKey(a2, @"{TIFF}") & 1) == 0)
    {
      uint64_t v6 = 0;
      CFTypeRef value = 0;
      uint64_t v8 = 0;
      IIODictionary::IIODictionary((IIODictionary *)&v6);
      IIODictionary::setObjectForKey(a2, value, @"{TIFF}");
      IIODictionary::~IIODictionary((IIODictionary *)&v6);
    }
    if (IIODictionary::containsKey(a2, @"Compression"))
    {
      CFDictionaryRef ObjectForKey = IIODictionary::getObjectForKey(a2, @"Compression");
      IIODictionary::setObjectForKeyGroup(a2, ObjectForKey, @"Compression", @"{TIFF}");
      IIODictionary::removeObjectForKey(a2, @"Compression");
      if (IIODictionary::getUint32ForKeyGroup(a2, @"Compression", @"{TIFF}") >= 2)
      {
        IIODictionary::removeObjectForKeyGroup(a2, @"TileWidth", @"{TIFF}");
        IIODictionary::removeObjectForKeyGroup(a2, @"TileLength", @"{TIFF}");
      }
    }
  }
  if (CFEqual(this[9], @"com.truevision.tga-image")
    && IIODictionary::containsKey(a2, @"Compression"))
  {
    if (IIODictionary::containsKey(a2, @"{TGA}"))
    {
      CFDictionaryRef v5 = IIODictionary::getObjectForKey(a2, @"Compression");
      IIODictionary::setObjectForKeyGroup(a2, v5, @"Compression", @"{TGA}");
      IIODictionary::removeObjectForKey(a2, @"Compression");
    }
  }
}

void sub_188606830(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  IIODictionary::~IIODictionary((IIODictionary *)va);
  _Unwind_Resume(a1);
}

uint64_t IIO_ReaderHandler::UseAppleJPEG(IIO_ReaderHandler *this)
{
  if (IIO_ReaderHandler::UseAppleJPEG(void)::appleJPEGCheck != -1) {
    dispatch_once(&IIO_ReaderHandler::UseAppleJPEG(void)::appleJPEGCheck, &__block_literal_global_27);
  }
  return IIO_ReaderHandler::UseAppleJPEG(void)::gUseAppleJPEGPlugin;
}

uint64_t IIO_Writer::canWriteExifOrientation(IIO_Writer *this)
{
  return (*((unsigned __int8 *)this + 42) >> 1) & 1;
}

uint64_t IIO_CGImageWrapsIOSurface(uint64_t result, int a2)
{
  if (result)
  {
    uint64_t result = CGImageGetImageProvider();
    if (result)
    {
      uint64_t Property = CGImageProviderGetProperty();
      if (Property) {
        BOOL v4 = Property == *MEMORY[0x1E4F1CFD0];
      }
      else {
        BOOL v4 = 0;
      }
      uint64_t result = v4;
      if (!v4)
      {
        if (a2) {
          return CGImageProviderGetCallbackVersion() > 1;
        }
      }
    }
  }
  return result;
}

uint64_t _ImageIsFloat(CGImage *a1)
{
  return (CGImageGetBitmapInfo(a1) >> 8) & 1;
}

uint64_t _ImageGetEndianInfo(CGImage *a1)
{
  return CGImageGetBitmapInfo(a1) & 0x7000;
}

uint64_t _ImageGetBitmapInfo(CGImage *a1)
{
  int AlphaInfo = _ImageGetAlphaInfo(a1);
  return CGImageGetBitmapInfo(a1) & 0xFFFFFFE0 | AlphaInfo;
}

uint64_t IIOGetExifOrientation(IIODictionary *a1, unsigned __int16 a2)
{
  if (a1)
  {
    if (IIODictionary::containsKey(a1, @"Orientation"))
    {
      unsigned __int16 Uint32ForKey = (unsigned __int16)IIODictionary::getUint32ForKey(a1, @"Orientation");
    }
    else if (IIODictionary::containsKeyGroup(a1, @"Orientation", @"{TIFF}"))
    {
      unsigned __int16 Uint32ForKey = (unsigned __int16)IIODictionary::getUint32ForKeyGroup(a1, @"Orientation", @"{TIFF}");
    }
    else
    {
      unsigned __int16 Uint32ForKey = 1;
    }
    if ((unsigned __int16)(Uint32ForKey - 9) >= 0xFFF8u) {
      return Uint32ForKey;
    }
    else {
      return a2;
    }
  }
  else
  {
    return 1;
  }
}

void __CGInitializeImageIO_block_invoke_2()
{
  IIOInitDebugFlags();
  if (IIOXPCClient::GetIIOXPCClient(void)::xpcClientCreate != -1) {
    dispatch_once(&IIOXPCClient::GetIIOXPCClient(void)::xpcClientCreate, &__block_literal_global_20);
  }
  if (IIOIsOOPEnabled(0))
  {
    ImageIOLogInternal("   CGInitializeImageIO called...\n");
    CFStringRef v0 = (const __CFString *)*MEMORY[0x1E4F1D3D8];
    CFNumberRef v1 = (const __CFNumber *)CFPreferencesCopyAppValue(@"IIO_LaunchInfo", (CFStringRef)*MEMORY[0x1E4F1D3D8]);
    if (v1)
    {
      CFNumberRef v2 = v1;
      CFNumberGetValue(v1, kCFNumberDoubleType, &gSavedFirstCallTime);
    }
    else
    {
      ImageIOLogInternal("   ImageIO: not launching XPCService (no launchinfo)...\n");
      CFNumberRef v2 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberDoubleType, &gSavedFirstCallTime);
      CFPreferencesSetAppValue(@"IIO_LaunchInfo", v2, v0);
    }
    CFRelease(v2);
    double v3 = *(double *)&gSavedFirstCallTime;
    if (*(double *)&gSavedFirstCallTime == -1.0)
    {
      ImageIOLogInternal("   ImageIO: waiting for first ImageIO call...\n", *(double *)&gSavedFirstCallTime);
      dispatch_time_t v4 = dispatch_time(0, 8000000000);
      global_queue = dispatch_get_global_queue(0, 0);
      dispatch_after(v4, global_queue, &__block_literal_global_11);
      double v3 = *(double *)&gSavedFirstCallTime;
    }
    if (v3 > 0.0 && v3 < 10.0)
    {
      double v6 = fmax(v3 + -0.06, 0.01);
      ImageIOLogInternal("   ImageIO: waiting %g s before launching XPCService\n", v6);
      dispatch_time_t v7 = dispatch_time(0, (uint64_t)(v6 * 1000000000.0));
      uint64_t v8 = dispatch_get_global_queue(2, 0);
      dispatch_after(v7, v8, &__block_literal_global_16);
    }
  }
}

CGColorSpaceRef CGColorSpaceCreateCalRGB(float a1, float a2, float a3, float a4, float a5, float a6, float a7, float a8, float a9)
{
  if (IIOChromaticitiesMatchAdobeRGB(a1, a2, a3, a4, a5, a6, a7, a8, a9))
  {
    unsigned int v24 = (CFStringRef *)MEMORY[0x1E4F1DB78];
  }
  else if (IIOChromaticitiesMatchSRGB(a1, a2, a3, a4, a5, a6, a7, a8, a9))
  {
    unsigned int v24 = (CFStringRef *)MEMORY[0x1E4F1DC98];
  }
  else
  {
    if (!IIOChromaticitiesMatchLinearSRGB(a1, a2, a3, a4, a5, a6, a7, a8, a9))
    {
      memset(v45, 0, sizeof(v45));
      IIODictionary::IIODictionary((IIODictionary *)v45);
      CFMutableArrayRef v42 = 0;
      unsigned int v43 = 0;
      uint64_t v44 = 0;
      IIOArray::IIOArray((IIOArray *)&v42);
      unsigned int v27 = (const void *)*MEMORY[0x1E4F1CFD0];
      IIODictionary::setObjectForKey((IIODictionary *)v45, (const void *)*MEMORY[0x1E4F1CFD0], @"skipPhosphorsCheck");
      IIODictionary::setObjectForKey((IIODictionary *)v45, @"Calibrated RGB Colorspace", @"description");
      IIODictionary::setObjectForKey((IIODictionary *)v45, v27, @"unrestrictedGamma");
      IIODictionary::setObjectForKey((IIODictionary *)v45, @"displayRGB", @"profileType");
      IIONumber::IIONumber((IIONumber *)v41, v29);
      IIODictionary::setObjectForKey((uint64_t)v45, (uint64_t)v41, @"gammaR");
      IIONumber::~IIONumber((IIONumber *)v41);
      IIONumber::IIONumber((IIONumber *)v40, v29);
      IIODictionary::setObjectForKey((uint64_t)v45, (uint64_t)v40, @"gammaG");
      IIONumber::~IIONumber((IIONumber *)v40);
      IIONumber::IIONumber((IIONumber *)v39, v29);
      IIODictionary::setObjectForKey((uint64_t)v45, (uint64_t)v39, @"gammaB");
      IIONumber::~IIONumber((IIONumber *)v39);
      IIONumber::IIONumber((IIONumber *)v38, a1);
      IIODictionary::setObjectForKey((uint64_t)v45, (uint64_t)v38, @"whitePointx");
      IIONumber::~IIONumber((IIONumber *)v38);
      IIONumber::IIONumber((IIONumber *)v37, a2);
      IIODictionary::setObjectForKey((uint64_t)v45, (uint64_t)v37, @"whitePointy");
      IIONumber::~IIONumber((IIONumber *)v37);
      IIONumber::IIONumber((IIONumber *)v36, a3);
      IIODictionary::setObjectForKey((uint64_t)v45, (uint64_t)v36, @"phosphorRx");
      IIONumber::~IIONumber((IIONumber *)v36);
      IIONumber::IIONumber((IIONumber *)v35, a4);
      IIODictionary::setObjectForKey((uint64_t)v45, (uint64_t)v35, @"phosphorRy");
      IIONumber::~IIONumber((IIONumber *)v35);
      IIONumber::IIONumber((IIONumber *)v34, a5);
      IIODictionary::setObjectForKey((uint64_t)v45, (uint64_t)v34, @"phosphorGx");
      IIONumber::~IIONumber((IIONumber *)v34);
      IIONumber::IIONumber((IIONumber *)v33, a6);
      IIODictionary::setObjectForKey((uint64_t)v45, (uint64_t)v33, @"phosphorGy");
      IIONumber::~IIONumber((IIONumber *)v33);
      IIONumber::IIONumber((IIONumber *)v32, a7);
      IIODictionary::setObjectForKey((uint64_t)v45, (uint64_t)v32, @"phosphorBx");
      IIONumber::~IIONumber((IIONumber *)v32);
      IIONumber::IIONumber((IIONumber *)v31, a8);
      IIODictionary::setObjectForKey((uint64_t)v45, (uint64_t)v31, @"phosphorBy");
      IIONumber::~IIONumber((IIONumber *)v31);
      IIOAddDateComponents(&v42);
      IIODictionary::setObjectForKey((IIODictionary *)v45, v43, @"Date");
      Profile = (const void *)ColorSyncMakeProfile();
      IIOArray::~IIOArray((IIOArray *)&v42);
      IIODictionary::~IIODictionary((IIODictionary *)v45);
      if (!Profile) {
        return CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E4F1DC98]);
      }
      CGColorSpaceRef v25 = (CGColorSpaceRef)MEMORY[0x18C11AC00](Profile, 0);
      CFRelease(Profile);
      if (!v25) {
        return CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E4F1DC98]);
      }
      return v25;
    }
    unsigned int v24 = (CFStringRef *)MEMORY[0x1E4F1DC88];
  }
  CGColorSpaceRef v25 = CGColorSpaceCreateWithName(*v24);
  if (!v25) {
    return CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E4F1DC98]);
  }
  return v25;
}

void sub_188606FE8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  IIONumber::~IIONumber((IIONumber *)va);
  IIOArray::~IIOArray((IIOArray *)(v6 - 144));
  IIODictionary::~IIODictionary((IIODictionary *)(v6 - 120));
  _Unwind_Resume(a1);
}

BOOL IIOChromaticitiesMatchSRGB(float a1, float a2, float a3, float a4, float a5, float a6, float a7, float a8, float a9)
{
  return fabs(a1 + -0.3127) < 0.0005
      && fabs(a2 + -0.329) < 0.0005
      && fabs(a3 + -0.64) < 0.0005
      && fabs(a4 + -0.33) < 0.0005
      && fabs(a5 + -0.3) < 0.0005
      && fabs(a6 + -0.6) < 0.0005
      && fabs(a7 + -0.15) < 0.0005
      && fabs(a8 + -0.06) < 0.0005
      && fabs(a9 + -2.2) < 0.0005;
}

BOOL IIOChromaticitiesMatchAdobeRGB(float a1, float a2, float a3, float a4, float a5, float a6, float a7, float a8, float a9)
{
  return fabs(a1 + -0.3127) < 0.0005
      && fabs(a2 + -0.329) < 0.0005
      && fabs(a3 + -0.64) < 0.0005
      && fabs(a4 + -0.33) < 0.0005
      && fabs(a5 + -0.21) < 0.0005
      && fabs(a6 + -0.71) < 0.0005
      && fabs(a7 + -0.15) < 0.0005
      && fabs(a8 + -0.06) < 0.0005
      && fabs(a9 + -2.2) < 0.0005;
}

uint64_t CGImagePixelDataProviderCreate(uint64_t a1, uint64_t a2)
{
  if (a1)
  {
    if (*(void *)(a2 + 8))
    {
      if (CGImagePixelDataProviderGetTypeID::once != -1) {
        dispatch_once(&CGImagePixelDataProviderGetTypeID::once, &__block_literal_global_30);
      }
      *(_DWORD *)(_CFRuntimeCreateInstance() + 16) = 1;
      atomic_fetch_add_explicit(&gPDPCount, 1uLL, memory_order_relaxed);
      operator new();
    }
    _cg_jpeg_mem_term("CGImagePixelDataProviderCreate", 1654, "*** ERROR: CGImagePixelDataProviderCreate is called with NULL-dstFormat-colorspace\n");
  }
  else
  {
    _cg_jpeg_mem_term("CGImagePixelDataProviderCreate", 1649, "*** ERROR: CGImagePixelDataProviderCreate is called with NULL-image\n");
  }
  return 0;
}

void sub_188607440(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10F1C4054C77265);
  _Unwind_Resume(a1);
}

void IIOImagePixelDataProvider::IIOImagePixelDataProvider(IIOImagePixelDataProvider *this, CGImage *a2, vImage_CGImageFormat *a3, CGColor *a4)
{
  *(void *)this = &unk_1ED4E5608;
  if (a2)
  {
    if (a3)
    {
      if (a3->colorSpace)
      {
        IIOImagePixelDataProvider::setup(this, a2, a3, a4);
        return;
      }
      int v4 = -3;
    }
    else
    {
      int v4 = -2;
    }
  }
  else
  {
    int v4 = -1;
  }
  *((_DWORD *)this + 57) = v4;
}

void IIOImagePixelDataProvider::setup(IIOImagePixelDataProvider *this, CGImage *a2, vImage_CGImageFormat *a3, CGColorRef color)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  *((void *)this + 1) = 0;
  *(_OWORD *)((char *)this + 120) = 0u;
  uint64_t v8 = (vImageConverterRef *)((char *)this + 120);
  *(_OWORD *)((char *)this + 136) = 0u;
  *(_OWORD *)((char *)this + 152) = 0u;
  *((void *)this + 21) = 0;
  *((void *)this + 25) = 0;
  *((void *)this + 26) = 0;
  *((void *)this + 24) = 0;
  *((void *)this + 27) = CGColorRetain(color);
  *(_WORD *)((char *)this + 225) = 0;
  *((void *)this + 31) = 0;
  *((unsigned char *)this + 256) = 0;
  *((_DWORD *)this + 57) = 0;
  *((void *)this + 22) = 0;
  *((void *)this + 23) = 0;
  *((void *)this + 2) = CGImageRetain(a2);
  *((void *)this + 3) = CGImageGetWidth(a2);
  size_t Height = (IIOImagePixelDataProvider *)CGImageGetHeight(a2);
  *((void *)this + 4) = Height;
  *((void *)this + 29) = 0;
  *((void *)this + 30) = 0;
  IIOImagePixelDataProvider::initvImageCGImageFormat(Height, a2, (vImage_CGImageFormat *)this + 1);
  *((void *)this + 10) = *(void *)&a3->bitsPerComponent;
  *((void *)this + 11) = CGColorSpaceRetain(a3->colorSpace);
  *((void *)this + 12) = *(void *)&a3->bitmapInfo;
  *((void *)this + 13) = a3->decode;
  *((_DWORD *)this + 28) = CGImageGetRenderingIntent(*((CGImageRef *)this + 2));
  memset(v36, 0, sizeof(v36));
  if (color)
  {
    CGColorGetColorSpace(color);
    if (CGColorSpaceEqualToColorSpace())
    {
      Components = CGColorGetComponents(color);
    }
    else if (IIO_ConvertCGColorToColorComponents(color, *((void *)this + 11)))
    {
      Components = (const CGFloat *)v36;
    }
    else
    {
      Components = 0;
    }
  }
  else
  {
    Components = 0;
  }
  int v11 = *((_DWORD *)this + 14) & 0xF0000;
  if (v11 == 196608)
  {
    _cg_jpeg_mem_term("setup", 162, "*** NOTE: vImageConverter_CreateWithCGImageFormat cannot handle kCGImagePixelFormatRGB101010 - using workaround\n");
    *((void *)this + 16) = CGImageGetBytesPerRow(*((CGImageRef *)this + 2));
    uint64_t v13 = CGImageGetWidth(*((CGImageRef *)this + 2)) * ((unint64_t)*((unsigned int *)this + 21) >> 3);
    *((void *)this + 18) = v13;
    uint64_t v14 = IIOImagePixelDataProvider::GetBytesDataProviderRGB101010;
LABEL_13:
    *((void *)this + 23) = v14;
    *((void *)this + 20) = CGImageGetHeight(*((CGImageRef *)this + 2)) * v13;
    uint64_t v15 = *((void *)this + 16);
    *((void *)this + 21) = CGImageGetHeight(*((CGImageRef *)this + 2)) * v15;
    return;
  }
  if (v11 == 0x40000)
  {
    *((unsigned char *)this + 226) = 1;
    *((void *)this + 10) = 0x4000000010;
    *((void *)this + 16) = CGImageGetBytesPerRow(*((CGImageRef *)this + 2));
    size_t Width = CGImageGetWidth(*((CGImageRef *)this + 2));
    uint64_t v13 = 8 * Width;
    *((void *)this + 18) = 8 * Width;
    if (Width >> 61) {
      abort();
    }
    uint64_t v14 = IIOImagePixelDataProvider::GetBytesDataProviderCIF10;
    goto LABEL_13;
  }
  vImage_Error error = 0;
  vImageConverterRef v16 = vImageConverter_CreateWithCGImageFormat((const vImage_CGImageFormat *)this + 1, (const vImage_CGImageFormat *)this + 2, Components, 0x10u, &error);
  vImageConverterRef *v8 = v16;
  if (!v16)
  {
    int v18 = error;
    BOOL v19 = IIO_vImageErrorString(error);
    LogWarning("setup", 177, "Could not create vImageConverter, vImageConverter_CreateWithCGImageFormat: err=%d [%s]\n", v18, v19);
    unsigned int v20 = *((_DWORD *)this + 14);
    int v21 = *((_DWORD *)this + 10);
    int v22 = *((_DWORD *)this + 11);
    int v23 = IIO_BitmapInfoString(v20);
    _cg_jpeg_mem_term("setup", 178, "*** srcFormat: bpc: %d   bpp: %d  bmi: 0x%08X %s\n", v21, v22, v20, v23);
    unsigned int v24 = *((_DWORD *)this + 24);
    int v25 = *((_DWORD *)this + 20);
    int v26 = *((_DWORD *)this + 21);
    unsigned int v27 = IIO_BitmapInfoString(v24);
    _cg_jpeg_mem_term("setup", 179, "*** dstFormat: bpc: %d   bpp: %d  bmi: 0x%08X %s\n", v25, v26, v24, v27);
    *((_DWORD *)this + 57) = -5;
    return;
  }
  *((void *)this + 16) = CGImageGetBytesPerRow(*((CGImageRef *)this + 2));
  size_t v17 = CGImageGetWidth(*((CGImageRef *)this + 2)) * *((unsigned int *)this + 21) + 7;
  *((void *)this + 18) = v17 >> 3;
  if (*((void *)this + 16) > v17 >> 3 && *((_DWORD *)this + 14) == *((_DWORD *)this + 24))
  {
    if (MEMORY[0x18C11D790]((char *)this + 40, (char *)this + 80))
    {
      *((void *)this + 18) = *((void *)this + 16);
    }
    else if (*((_DWORD *)this + 11) <= *((_DWORD *)this + 21))
    {
      _cg_jpeg_mem_term("setup", 197, "*** image: %p  bad rowbytes?   size: %5zd x %5zd      _srcRowBytes: %d   _dstRowBytes: %d\n", *((const void **)this + 2), *((void *)this + 3), *((void *)this + 4), *((void *)this + 16), *((void *)this + 18));
    }
  }
  if (CGImageGetImageProvider())
  {
    uint64_t Property = (const void *)CGImageProviderGetProperty();
    if (Property)
    {
      if (CFEqual(Property, (CFTypeRef)*MEMORY[0x1E4F1CFD0]))
      {
        CFNumberRef v29 = (const __CFNumber *)CGImageProviderGetProperty();
        if (v29)
        {
          CFNumberRef v30 = v29;
          CFTypeID v31 = CFGetTypeID(v29);
          if (v31 == CFNumberGetTypeID()) {
            CFNumberGetValue(v30, kCFNumberLongType, (char *)this + 176);
          }
        }
      }
    }
    BOOL v32 = IIOImagePixelDataProvider::GetBytesImageProvider;
LABEL_30:
    *((void *)this + 23) = v32;
    goto LABEL_31;
  }
  *((void *)this + 23) = IIOImagePixelDataProvider::GetBytesDataProvider;
  if (CGImageGetDataProvider(a2) && CGDataProviderGetSizeOfData() == -1)
  {
    if (!MEMORY[0x18C11D790]((char *)this + 40, (char *)this + 80))
    {
      if (!vImageConverter_MustOperateOutOfPlace(*v8, 0, 0, 0) && *((void *)this + 18) >= *((void *)this + 16)) {
        *((unsigned char *)this + 256) = 1;
      }
      BOOL v32 = IIOImagePixelDataProvider::GetBytesCGAccessSessionConvert;
      goto LABEL_30;
    }
    *((void *)this + 23) = IIOImagePixelDataProvider::GetBytesCGAccessSessionNoConvert;
    *((void *)this + 18) = *((void *)this + 16);
  }
LABEL_31:
  uint64_t v33 = *((void *)this + 18);
  *((void *)this + 20) = CGImageGetHeight(*((CGImageRef *)this + 2)) * v33;
  uint64_t v34 = *((void *)this + 16);
  *((void *)this + 21) = CGImageGetHeight(*((CGImageRef *)this + 2)) * v34;
  if ((gIIODebugFlags & 0x400000000) != 0) {
    vImageConverter_Print();
  }
}

const CGFloat *IIOImagePixelDataProvider::initvImageCGImageFormat(IIOImagePixelDataProvider *this, CGImageRef image, vImage_CGImageFormat *a3)
{
  a3->bitsPerComponent = CGImageGetBitsPerComponent(image);
  a3->bitsPerPixel = CGImageGetBitsPerPixel(image);
  a3->colorSpace = CGImageGetColorSpace(image);
  a3->bitmapInfo = CGImageGetBitmapInfo(image);
  a3->renderingIntent = CGImageGetRenderingIntent(image);
  a3->version = 0;
  uint64_t result = CGImageGetDecode(image);
  a3->decode = result;
  return result;
}

void ___Z23IIODetermineHEIFSupportv_block_invoke()
{
  if (gFunc_CMPhotoDecompressionSupportedForContainerAndCodec)
  {
    char v8 = 0;
    if (gFunc_CMPhotoDecompressionSupportedForContainerAndCodec(0, 1785750887, 0, &v8)) {
      BOOL v0 = 1;
    }
    else {
      BOOL v0 = v8 == 0;
    }
    if (!v0) {
      gHEIF_JPEG_DecodingSupported = 1;
    }
    if (gFunc_CMPhotoDecompressionSupportedForContainerAndCodec(0, 1752589105, 0, &v8)) {
      BOOL v1 = 1;
    }
    else {
      BOOL v1 = v8 == 0;
    }
    if (!v1) {
      gHEIF_HEVC_DecodingSupported = 1;
    }
    if (gFunc_CMPhotoDecompressionSupportedForContainerAndCodec(0, 1635148593, 0, &v8)) {
      BOOL v2 = 1;
    }
    else {
      BOOL v2 = v8 == 0;
    }
    if (!v2) {
      gHEIF_AVCI_DecodingSupported = 1;
    }
    if (gFunc_CMPhotoDecompressionSupportedForContainerAndCodec(0, 1635135537, 0, &v8)) {
      BOOL v3 = 1;
    }
    else {
      BOOL v3 = v8 == 0;
    }
    if (!v3) {
      gHEIF_AVIF_DecodingSupported = 1;
    }
    if (gFunc_CMPhotoDecompressionSupportedForContainerAndCodec(2, 1786276896, 0, &v8)) {
      BOOL v4 = 1;
    }
    else {
      BOOL v4 = v8 == 0;
    }
    if (!v4) {
      gHEIF_JPEGXL_DecodingSupported = 1;
    }
  }
  if (gFunc_CMPhotoCompressionSupportedForContainerAndCodec)
  {
    char v9 = 0;
    if (gFunc_CMPhotoCompressionSupportedForContainerAndCodec(0, 1785750887, 0, &v9)) {
      BOOL v5 = 1;
    }
    else {
      BOOL v5 = v9 == 0;
    }
    if (!v5) {
      gHEIF_JPEG_EncodingSupported = 1;
    }
    if (gFunc_CMPhotoCompressionSupportedForContainerAndCodec(0, 1752589105, 0, &v9)) {
      BOOL v6 = 1;
    }
    else {
      BOOL v6 = v9 == 0;
    }
    if (!v6) {
      gHEIF_HEVC_EncodingSupported = 1;
    }
    if (gFunc_CMPhotoCompressionSupportedForContainerAndCodec(0, 1635148593, 0, &v9)) {
      BOOL v7 = 1;
    }
    else {
      BOOL v7 = v9 == 0;
    }
    if (!v7) {
      gHEIF_AVCI_EncodingSupported = 1;
    }
  }
}

void sub_188607D30(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  IIONumber::~IIONumber((IIONumber *)va);
  _Unwind_Resume(a1);
}

uint64_t __CGImageWriteSessionGetTypeID_block_invoke()
{
  uint64_t result = _CFRuntimeRegisterClass();
  CGImageWriteSessionGetTypeID::id = result;
  return result;
}

uint64_t __CGImagePixelDataProviderGetTypeID_block_invoke()
{
  uint64_t result = _CFRuntimeRegisterClass();
  CGImagePixelDataProviderGetTypeID::id = result;
  return result;
}

uint64_t __CGImageDestinationGetTypeID_block_invoke()
{
  uint64_t result = _CFRuntimeRegisterClass();
  CGImageDestinationGetTypeID::id = result;
  return result;
}

uint64_t displayCheck(void)
{
  uint64_t result = MGGetBoolAnswer();
  gIsWideGamutDispladouble y = result;
  return result;
}

void ___ZL10voidResultv_block_invoke()
{
}

void ___ZN16AdobeXMPCore_IntL23sDefaultMemoryAllocatorEv_block_invoke()
{
}

void sub_188607E68(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0xA1C40BD48D6D6);
  _Unwind_Resume(a1);
}

void *AdobeXMPCore_Int::MemoryAllocatorWrapperImpl::MemoryAllocatorWrapperImpl(void *this)
{
  *this = &unk_1ED4EDC28;
  this[1] = 0;
  return this;
}

void ___ZN8ISOMediaL7boxListEv_block_invoke()
{
}

void CGImageDestinationAddImage(CGImageDestinationRef idst, CGImageRef image, CFDictionaryRef properties)
{
  uint64_t v36 = *MEMORY[0x1E4F143B8];
  memset(v30, 0, sizeof(v30));
  IIODictionary::IIODictionary((IIODictionary *)v30, properties);
  if (image)
  {
    CGImageGetWidth(image);
    CGImageGetHeight(image);
  }
  IIOPackDstInputInfo((IIODictionary *)v30);
  if (image)
  {
    CGImageGetBitsPerPixel(image);
    CGImageGetBitsPerComponent(image);
    ColorSpace = CGImageGetColorSpace(image);
    CGColorSpaceGetModel(ColorSpace);
    CGImageGetImageProvider();
    CGImageGetContentHeadroom();
    CGImageGetBitmapInfo(image);
  }
  kdebug_trace();
  IIO_LoadHEIFSymbols();
  if ((gIIODebugFlags & 0x3000) != 0)
  {
    long long v34 = 0u;
    long long v35 = 0u;
    long long v32 = 0u;
    long long v33 = 0u;
    *(_OWORD *)__str = 0u;
    if (!image)
    {
      strcpy(__str, "(NULL)");
      goto LABEL_17;
    }
    if (CGImageGetImageProvider())
    {
      if (CGImageProviderGetProperty() == *MEMORY[0x1E4F1CFD0]) {
        BOOL v7 = "(IP-S)";
      }
      else {
        BOOL v7 = "(IP)";
      }
    }
    else
    {
      BOOL v7 = "(DP)";
    }
    unsigned int v27 = v7;
    uint64_t Property = (const void *)CGImageGetProperty();
    char v9 = (const void *)CGImageGetProperty();
    size_t Width = CGImageGetWidth(image);
    size_t Height = CGImageGetHeight(image);
    size_t BytesPerRow = CGImageGetBytesPerRow(image);
    size_t BitsPerComponent = CGImageGetBitsPerComponent(image);
    uint64_t v13 = "";
    if (Property)
    {
      IIOString::IIOString((IIOString *)v29, Property);
      uint64_t v13 = (const char *)IIOString::utf8String((IIOString *)v29);
      if (v9) {
        goto LABEL_15;
      }
    }
    else if (v9)
    {
LABEL_15:
      IIOString::IIOString((IIOString *)buffer, v9);
      uint64_t v14 = (const char *)IIOString::utf8String((IIOString *)buffer);
      snprintf(__str, 0x50uLL, "[%p] {%ld,%ld}  rb:%ld  bpc:%ld  %s %s%s", image, Width, Height, BytesPerRow, BitsPerComponent, v27, v13, v14);
      IIOString::~IIOString((IIOString *)buffer);
      if (Property) {
LABEL_16:
      }
        IIOString::~IIOString((IIOString *)v29);
LABEL_17:
      unsigned int v15 = (gIIODebugFlags >> 12) & 3;
      if (v15) {
        ImageIODebugOptions(v15, "A", "CGImageDestinationAddImage", 0, __str, -1, properties);
      }
      CFDataRef v16 = (const __CFData *)CGImageGetProperty();
      *(void *)uint64_t buffer = 0;
      if (v16)
      {
        v37.location = 0;
        v37.CFIndex length = 8;
        CFDataGetBytes(v16, v37, buffer);
        uint64_t Source = (IIOImageRead *)CGImageSourceGetSource(*(uint64_t *)buffer);
        int v18 = IIOImageRead::copySourceInfo(Source);
        free(v18);
      }
      goto LABEL_21;
    }
    snprintf(__str, 0x50uLL, "[%p] {%ld,%ld}  rb:%ld  bpc:%ld  %s %s%s", image, Width, Height, BytesPerRow, BitsPerComponent, v27, v13, "");
    if (!Property) {
      goto LABEL_17;
    }
    goto LABEL_16;
  }
LABEL_21:
  if (idst) {
    int v19 = 5048;
  }
  else {
    int v19 = 5047;
  }
  if (idst) {
    unsigned int v20 = "*** ERROR: CGImageDestinationAddImage: cgImage is nil\n";
  }
  else {
    unsigned int v20 = "*** ERROR: CGImageDestinationAddImage: destination is nil\n";
  }
  if (!idst || !image) {
    goto LABEL_45;
  }
  CFTypeID v21 = CFGetTypeID(idst);
  if (CGImageDestinationGetTypeID::once != -1) {
    dispatch_once(&CGImageDestinationGetTypeID::once, &__block_literal_global_25);
  }
  if (v21 != CGImageDestinationGetTypeID::id)
  {
    LogError("CGImageDestinationAddImage", 5049, "*** ERROR: CGImageDestinationAddImage: destination is not a CGImageDestinationRef\n");
    goto LABEL_46;
  }
  CFTypeID v22 = CFGetTypeID(image);
  if (v22 != CGImageGetTypeID())
  {
    unsigned int v20 = "*** ERROR: CGImageDestinationAddImage: cgImage is not a CGImageRef\n";
    int v19 = 5050;
LABEL_45:
    LogError("CGImageDestinationAddImage", v19, v20);
    goto LABEL_46;
  }
  if (properties)
  {
    CFTypeID v23 = CFGetTypeID(properties);
    if (v23 != CFDictionaryGetTypeID()) {
      LogError("CGImageDestinationAddImage", 5053, "*** ERROR: CGImageDestinationAddImage: properties parameter is not a CFDictionaryRef - ignoring\n");
    }
  }
  uint64_t v24 = *((void *)idst + 3);
  if (v24)
  {
    IIOImageDestination::addImage(*((IIOImageDestination **)idst + 3), image, (IIODictionary *)v30);
    int v25 = *(IIO_Reader **)(v24 + 64);
    if (v25) {
      IIO_Reader::osType(v25);
    }
  }
LABEL_46:
  kdebug_trace();
  IIODictionary::~IIODictionary((IIODictionary *)v30);
}

void sub_1886083BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, char a20,uint64_t a21,uint64_t a22,char a23,uint64_t a24,uint64_t a25,char a26)
{
  IIOString::~IIOString((IIOString *)&a20);
  if (v26) {
    IIOString::~IIOString((IIOString *)&a23);
  }
  IIODictionary::~IIODictionary((IIODictionary *)&a26);
  _Unwind_Resume(a1);
}

uint64_t IIOImageDestination::addImage(IIOImageDestination *this, void *cf, IIODictionary *a3)
{
  if (*((void *)this + 2))
  {
    if (*((unsigned char *)this + 225))
    {
      LogError("addImage", 2792, "*** ERROR: image destination was already finalized\n");
    }
    else if (*((unsigned char *)this + 224))
    {
      LogError("addImage", 2793, "*** ERROR: CGImageDestinationAddImage call is not allowed for this image destination (destination was updated with CGImageDestinationCopyImageSource)\n");
    }
    else if (cf)
    {
      CFTypeID v6 = CFGetTypeID(cf);
      if (v6 == CGImageGetTypeID()) {
        IIOImageDestination::addImageInternal(this, (CGImage *)cf, a3);
      }
      LogError("addImage", 2795, "*** ERROR: image parameter is not a CGImageRef\n");
    }
    else
    {
      LogError("addImage", 2794, "*** ERROR: image parameter is nil\n");
    }
  }
  else
  {
    LogError("addImage", 2791, "*** ERROR: cannot add image - invalid image destination\n");
  }
  return 4294967246;
}

uint64_t IIOPackDstInputInfo(IIODictionary *a1)
{
  if (!a1) {
    return 0xFFA800000000;
  }
  unint64_t v2 = ((unint64_t)IIODictionary::getUint32ForKey(a1, @"Orientation") & 0xF) << 52;
  unint64_t v3 = v2 | (((unint64_t)IIODictionary::getUint32ForKeyGroup(a1, @"Orientation", @"{TIFF}") & 0xF) << 48);
  if (IIODictionary::containsKey(a1, @"kCGImageDestinationEncodeRequest"))
  {
    CFStringRef ObjectForKey = (const __CFString *)IIODictionary::getObjectForKey(a1, @"kCGImageDestinationEncodeRequest");
    if (CFStringCompare(ObjectForKey, @"kCGImageDestinationEncodeToSDR", 0))
    {
      if (CFStringCompare(ObjectForKey, @"kCGImageDestinationEncodeToISOHDR", 0))
      {
        if (CFStringCompare(ObjectForKey, @"kCGImageDestinationEncodeToISOGainmap", 0)) {
          uint64_t v5 = 0;
        }
        else {
          uint64_t v5 = 0x300000000000;
        }
      }
      else
      {
        uint64_t v5 = 0x200000000000;
      }
    }
    else
    {
      uint64_t v5 = 0x100000000000;
    }
    if (IIODictionary::containsKeyGroup(a1, @"kCGToneMappingMode", @"kCGImageDestinationEncodeRequestOptions"))unint64_t v8 = ((unint64_t)IIODictionary::getUint32ForKeyGroup(a1, @"kCGToneMappingMode", @"kCGImageDestinationEncodeRequestOptions") & 0xF) << 40; {
    else
    }
      unint64_t v8 = 0xF0000000000;
    unint64_t v9 = v5 | v8 | v3;
    if (IIODictionary::containsKeyGroup(a1, @"kCGImageDestinationCreateHDRGainMap", @"kCGImageDestinationEncodeRequestOptions"))
    {
      if (IIODictionary::getBoolForKeyGroup(a1, @"kCGImageDestinationCreateHDRGainMap", @"kCGImageDestinationEncodeRequestOptions"))uint64_t v7 = v9 | 0x4000000000; {
      else
      }
        uint64_t v7 = v9;
    }
    else
    {
      uint64_t v7 = v9 | 0x8000000000;
    }
  }
  else
  {
    uint64_t v7 = v3 | 0xFF8000000000;
  }
  if (IIODictionary::containsKey(a1, @"kCGImageDestinationPreserveGainMap"))
  {
    if (IIODictionary::getBoolForKey(a1, @"kCGImageDestinationPreserveGainMap")) {
      v7 |= 0x1000000000uLL;
    }
  }
  else
  {
    v7 |= 0x2000000000uLL;
  }
  if (IIODictionary::containsKey(a1, @"kCGImageDestinationOptimizeColorForSharing"))
  {
    if (IIODictionary::getBoolForKey(a1, @"kCGImageDestinationOptimizeColorForSharing")) {
      uint64_t v10 = v7 | 0x400000000;
    }
    else {
      uint64_t v10 = v7;
    }
  }
  else
  {
    uint64_t v10 = v7 | 0x800000000;
  }
  unsigned int Uint32ForKey = IIODictionary::getUint32ForKey(a1, @"kCGImageDestinationImageMaxPixelSize");
  if (!Uint32ForKey) {
    LOWORD(Uint32ForKey) = (unsigned __int16)IIODictionary::getUint32ForKey(a1, @"kCGImageSourceThumbnailMaxPixelSize");
  }
  return v10 | (unsigned __int16)Uint32ForKey;
}

void ___ZL16sProgressDefaultv_block_invoke()
{
}

void IIOLoadCoreMediaSymbols(void)
{
  if (IIOLoadCoreMediaSymbols(void)::once != -1) {
    dispatch_once(&IIOLoadCoreMediaSymbols(void)::once, &__block_literal_global_594);
  }
  if (!gFunc_CMBufferQueueCreate)
  {
    LogFault("IIOLoadCoreMediaSymbols", 838, "*** Failed to load 'CoreMedia' symbols ***\n");
  }
}

__IOSurface *IIOImageProviderInfo::CopyIOSurface(uint64_t *a1, const void *a2, const __CFDictionary *a3)
{
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    CGImageProviderGetBitmapInfo();
    uint64_t v6 = *a1;
    IIOPackCopyCallbackInfo(*a1, a3);
    if (v6) {
      int v7 = *(_DWORD *)(v6 + 128);
    }
    else {
      int v7 = 0;
    }
  }
  else
  {
    uint64_t v6 = 0;
    int v7 = 0;
  }
  int v8 = v7;
  kdebug_trace();
  IIOInitDebugFlags();
  if (!a1) {
    goto LABEL_38;
  }
  if ((gIIODebugFlags & 0xC000) != 0)
  {
    *(void *)__str = 0;
    unsigned int v9 = v8 >> 24;
    uint64_t v10 = MEMORY[0x1E4F14390];
    int v11 = v8 < 0 ? __maskrune(v8 >> 24, 0x40000uLL) : *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v9 + 60) & 0x40000;
    uint64_t v12 = v11 ? v9 : 46;
    unsigned int v13 = v8 << 8 >> 24;
    int v14 = v8 << 8 < 0 ? __maskrune(v8 << 8 >> 24, 0x40000uLL) : *(_DWORD *)(v10 + 4 * v13 + 60) & 0x40000;
    uint64_t v15 = v14 ? v13 : 46;
    unsigned int v16 = (__int16)v8 >> 8;
    int v17 = v8 << 16 < 0 ? __maskrune((__int16)v8 >> 8, 0x40000uLL) : *(_DWORD *)(v10 + 4 * v16 + 60) & 0x40000;
    uint64_t v18 = v17 ? v16 : 46;
    int v19 = (v8 << 24) <= 0x7F000000
        ? *(_DWORD *)(v10 + 4 * (char)v8 + 60) & 0x40000
        : __maskrune((char)v8, 0x40000uLL);
    uint64_t v20 = v19 ? (char)v8 : 46;
    snprintf(__str, 8uLL, "%c%c%c%c", v12, v15, v18, v20);
    if ((unsigned __int16)gIIODebugFlags >> 14) {
      ImageIODebugOptions((unsigned __int16)gIIODebugFlags >> 14, "S", "CopyIOSurface", a2, __str, -1, a3);
    }
  }
  if (v6 && (CFTypeID v21 = IIOImageProviderInfo::copyIOSurface(v6, a2, (uint64_t)a3), (v22 = v21) != 0))
  {
    CFTypeRef v23 = IOSurfaceCopyValue(v21, @"IOSurfaceContentHeadroom");
    if (v23)
    {
      CFRelease(v23);
    }
    else
    {
      CGImageProviderGetContentHeadroom();
      *(void *)__str = 0;
      uint64_t v30 = 0;
      CFTypeRef value = 0;
      IIONumber::IIONumber((IIONumber *)__str, v24);
      CFTypeRef v25 = value;
      if (value)
      {
        if ((gIIODebugFlags & 0x300000) != 0)
        {
          IIONumber::IIONumber((IIONumber *)v28, (const __CFNumber *)value);
          float v26 = IIONumber::floatNum((IIONumber *)v28);
          ImageIOLog("  %s - updating <IOSurface: %p>  headroom: %g\n", "CopyIOSurface", v22, v26);
          IIONumber::~IIONumber((IIONumber *)v28);
        }
        IOSurfaceSetValue(v22, @"IOSurfaceContentHeadroom", v25);
      }
      IIONumber::~IIONumber((IIONumber *)__str);
    }
    IOSurfaceGetWidth(v22);
    IOSurfaceGetHeight(v22);
    IOSurfaceGetPixelFormat(v22);
  }
  else
  {
LABEL_38:
    kdebug_trace();
    CFTypeID v22 = 0;
  }
  kdebug_trace();
  return v22;
}

void sub_188608BA4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  IIONumber::~IIONumber((IIONumber *)va);
  _Unwind_Resume(a1);
}

__IOSurface *IIOImageProviderInfo::copyIOSurface(uint64_t a1, const void *a2, uint64_t a3)
{
  char v5 = gIIODebugFlags;
  if ((gIIODebugFlags & 0x400000000000) != 0)
  {
    ImageIOLog("\n");
    ImageIOLog("*** copyIOSurface *** %p\n", a2);
    char v5 = gIIODebugFlags;
  }
  if ((v5 & 0xC) != 0) {
    *(CFAbsoluteTime *)(a1 + 136) = CFAbsoluteTimeGetCurrent();
  }
  if (!*(void *)(a1 + 224))
  {
    uint64_t v15 = gIIODebugFlags;
    if ((gIIODebugFlags & 0x400000000000) == 0)
    {
      unsigned int v16 = 0;
      goto LABEL_29;
    }
LABEL_28:
    ImageIOLog("    copyIOSurface - IOSurface = NULL\n");
    unsigned int v16 = 0;
    uint64_t v15 = gIIODebugFlags;
LABEL_29:
    if (v16 || (v15 & 0x800000000000) == 0) {
      return v16;
    }
    ImageIOLog(" ISSUE: %s:%d:  %s\n", "copyIOSurface", 2412, "returned ioSurface is NULL\n");
    return 0;
  }
  int v7 = *(CFTypeRef **)(a1 + 112);
  if (!v7)
  {
    CFDictionaryRef v8 = 0;
LABEL_16:
    LogFault("copyIOSurface", 2361, "header '%p' is not a CFDictionary...\n", v8);
    return 0;
  }
  CFDictionaryRef v8 = (const __CFDictionary *)*v7;
  if (!*v7) {
    goto LABEL_16;
  }
  CFTypeID v9 = CFGetTypeID(*v7);
  if (v9 != CFDictionaryGetTypeID()) {
    goto LABEL_16;
  }
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 144));
  uint64_t v10 = (const void *)*MEMORY[0x1E4F1CFD0];
  if (v10 == CFDictionaryGetValue(v8, @"kImageIOInfoHeader_pluginHandlesReMapping")
    || (CFDictionaryRef Value = CFDictionaryGetValue(v8, @"kImageIOInfoHeader_session")) == 0)
  {
    BOOL v14 = 0;
    unsigned int v13 = 0;
  }
  else
  {
    uint64_t Source = (IIOImageRead **)CGImageSourceGetSource((uint64_t)Value);
    unsigned int v13 = (const char **)Source;
    if (Source) {
      BOOL v14 = IIOImageReadSession::mapData(Source);
    }
    else {
      BOOL v14 = 0;
    }
  }
  unsigned int v16 = (__IOSurface *)(*(uint64_t (**)(void, void, uint64_t))(a1 + 224))(*(void *)(a1 + 112), *(void *)(a1 + 16), a3);
  if (v16 && (gIIODebugFlags & 0xC) != 0)
  {
    *(CFAbsoluteTime *)(a1 + 136) = CFAbsoluteTimeGetCurrent() - *(double *)(a1 + 136);
    IIOImageProviderInfo::logSurfaceDecodingTime((IIOImageProviderInfo *)a1, v16);
  }
  if (v14 && v13) {
    IIOImageReadSession::unmapData(v13);
  }
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 144));
  uint64_t v15 = gIIODebugFlags;
  if ((gIIODebugFlags & 0x400000000000) == 0) {
    goto LABEL_29;
  }
  if (!v16) {
    goto LABEL_28;
  }
  size_t Width = IOSurfaceGetWidth(v16);
  size_t Height = IOSurfaceGetHeight(v16);
  size_t BytesPerRow = IOSurfaceGetBytesPerRow(v16);
  signed int PixelFormat = IOSurfaceGetPixelFormat(v16);
  signed int v21 = PixelFormat;
  unsigned int v22 = PixelFormat >> 24;
  uint64_t v23 = MEMORY[0x1E4F14390];
  if (PixelFormat < 0) {
    int v24 = __maskrune(PixelFormat >> 24, 0x40000uLL);
  }
  else {
    int v24 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v22 + 60) & 0x40000;
  }
  if (v24) {
    uint64_t v26 = v22;
  }
  else {
    uint64_t v26 = 46;
  }
  unsigned int v27 = v21 << 8 >> 24;
  if (v21 << 8 < 0) {
    int v28 = __maskrune(v21 << 8 >> 24, 0x40000uLL);
  }
  else {
    int v28 = *(_DWORD *)(v23 + 4 * v27 + 60) & 0x40000;
  }
  if (v28) {
    uint64_t v29 = v27;
  }
  else {
    uint64_t v29 = 46;
  }
  unsigned int v30 = (__int16)v21 >> 8;
  if (v21 << 16 < 0) {
    int v31 = __maskrune((__int16)v21 >> 8, 0x40000uLL);
  }
  else {
    int v31 = *(_DWORD *)(v23 + 4 * v30 + 60) & 0x40000;
  }
  if (v31) {
    uint64_t v32 = v30;
  }
  else {
    uint64_t v32 = 46;
  }
  if ((v21 << 24) <= 0x7F000000) {
    int v33 = *(_DWORD *)(v23 + 4 * (char)v21 + 60) & 0x40000;
  }
  else {
    int v33 = __maskrune((char)v21, 0x40000uLL);
  }
  if (v33) {
    uint64_t v34 = (char)v21;
  }
  else {
    uint64_t v34 = 46;
  }
  ImageIOLog("    copyIOSurface - <IOSurface:%p> '%c%c%c%c'  {%ld, %ld} rb: %ld\n", v16, v26, v29, v32, v34, Width, Height, BytesPerRow);
  return v16;
}

IOSurfaceRef IIO_Reader::CopyIOSurfaceProc(uint64_t a1, uint64_t a2, uint64_t a3)
{
  IOSurfaceRef SurfaceWithFormat = 0;
  uint64_t v6 = *(IIOReadPlugin **)(a1 + 8);
  if ((*(unsigned int (**)(IIOReadPlugin *, uint64_t))(*(void *)v6 + 80))(v6, a3))
  {
    exception = __cxa_allocate_exception(4uLL);
    _DWORD *exception = -1;
    __cxa_throw(exception, MEMORY[0x1E4FBA3A8], 0);
  }
  int v7 = (*(uint64_t (**)(IIOReadPlugin *))(*(void *)v6 + 32))(v6);
  int v8 = *((_DWORD *)v6 + 51);
  unsigned int v9 = v8 >> 24;
  uint64_t v10 = MEMORY[0x1E4F14390];
  if (v8 < 0)
  {
    int v11 = __maskrune(v9, 0x40000uLL);
    int v8 = *((_DWORD *)v6 + 51);
  }
  else
  {
    int v11 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v9 + 60) & 0x40000;
  }
  if (v11) {
    uint64_t v12 = (v8 >> 24);
  }
  else {
    uint64_t v12 = 46;
  }
  unsigned int v13 = v8 << 8 >> 24;
  if (v8 << 8 < 0)
  {
    int v14 = __maskrune(v13, 0x40000uLL);
    int v8 = *((_DWORD *)v6 + 51);
  }
  else
  {
    int v14 = *(_DWORD *)(v10 + 4 * v13 + 60) & 0x40000;
  }
  if (v14) {
    uint64_t v15 = (v8 << 8 >> 24);
  }
  else {
    uint64_t v15 = 46;
  }
  unsigned int v16 = (__int16)v8 >> 8;
  if (v8 << 16 < 0)
  {
    int v17 = __maskrune(v16, 0x40000uLL);
    int v8 = *((_DWORD *)v6 + 51);
  }
  else
  {
    int v17 = *(_DWORD *)(v10 + 4 * v16 + 60) & 0x40000;
  }
  if (v17) {
    uint64_t v18 = ((__int16)v8 >> 8);
  }
  else {
    uint64_t v18 = 46;
  }
  if ((v8 << 24) <= 0x7F000000)
  {
    if ((*(_DWORD *)(v10 + 4 * (char)v8 + 60) & 0x40000) != 0) {
      goto LABEL_22;
    }
LABEL_24:
    LOBYTE(v19) = 46;
    goto LABEL_25;
  }
  if (!__maskrune((char)v8, 0x40000uLL)) {
    goto LABEL_24;
  }
LABEL_22:
  int v19 = *((_DWORD *)v6 + 51);
LABEL_25:
  _cg_jpeg_mem_term("CopyIOSurfaceProc", 1607, "*** IIO_Reader::CopyIOSurfaceProc - using new '%c%c%c%c'- callDecodeImage [kIIOImageType_IOSurface]\n", v12, v15, v18, (char)v19);
  CGImageProviderGetSize();
  double v21 = v20;
  double v23 = v22;
  if (v7)
  {
    int v24 = (*(uint64_t (**)(IIOReadPlugin *))(*(void *)v6 + 16))(v6);
    ColorSpace = (CGColorSpace *)CGImageProviderGetColorSpace();
    IOSurfaceRef SurfaceWithFormat = IIO_CreateSurfaceWithFormat(v24, (unint64_t)v21, (unint64_t)v23, ColorSpace);
    if (!SurfaceWithFormat)
    {
      unsigned int v34 = v24 >> 24;
      if (v24 < 0) {
        int v35 = __maskrune(v24 >> 24, 0x40000uLL);
      }
      else {
        int v35 = *(_DWORD *)(v10 + 4 * v34 + 60) & 0x40000;
      }
      if (v35) {
        uint64_t v56 = v34;
      }
      else {
        uint64_t v56 = 46;
      }
      unsigned int v57 = v24 << 8 >> 24;
      if (v24 << 8 < 0) {
        int v58 = __maskrune(v24 << 8 >> 24, 0x40000uLL);
      }
      else {
        int v58 = *(_DWORD *)(v10 + 4 * v57 + 60) & 0x40000;
      }
      if (v58) {
        uint64_t v59 = v57;
      }
      else {
        uint64_t v59 = 46;
      }
      unsigned int v60 = (__int16)v24 >> 8;
      if (v24 << 16 < 0) {
        int v61 = __maskrune((__int16)v24 >> 8, 0x40000uLL);
      }
      else {
        int v61 = *(_DWORD *)(v10 + 4 * v60 + 60) & 0x40000;
      }
      if ((v24 << 24) <= 0x7F000000) {
        int v62 = *(_DWORD *)(v10 + 4 * (char)v24 + 60) & 0x40000;
      }
      else {
        int v62 = __maskrune((char)v24, 0x40000uLL);
      }
      if (v61) {
        uint64_t v63 = v60;
      }
      else {
        uint64_t v63 = 46;
      }
      if (v62) {
        uint64_t v64 = (char)v24;
      }
      else {
        uint64_t v64 = 46;
      }
      _cg_jpeg_mem_term("CopyIOSurfaceProc", 1615, "*** ERROR: IIO_CreateSurfaceWithFormat '%c%c%c%c'\n", v56, v59, v63, v64);
      return 0;
    }
  }
  uint64_t v67 = 0;
  memset(v66, 0, sizeof(v66));
  unsigned int v26 = IIOReadPlugin::index(v6);
  IIODecodeParameter::IIODecodeParameter(v66, a1, a2, v26, a3, 0.0, 0.0, v21, v23, v21, v23);
  int v27 = IIOReadPlugin::callDecodeImage((uint64_t)v6, (uint64_t)v66, 1, &SurfaceWithFormat, 0, 0);
  if (v27 == -1400)
  {
    ImageIOLog(" retrying 'decodeImage' (ImageIOXPCService crashed?)\n");
    int v29 = IIOReadPlugin::callDecodeImage((uint64_t)v6, (uint64_t)v66, 1, &SurfaceWithFormat, 0, 0);
    int v27 = v29;
    unsigned int v30 = "";
    if (!v29) {
      unsigned int v30 = "";
    }
    ImageIOLog("%s retrying 'decodeImage'  err: %d\n", v30, v29);
  }
  if (v27)
  {
    if (v27 != -56) {
      goto LABEL_59;
    }
    int v31 = *((_DWORD *)v6 + 51);
    unsigned int v32 = v31 >> 24;
    if (v31 < 0)
    {
      int v33 = __maskrune(v32, 0x40000uLL);
      int v31 = *((_DWORD *)v6 + 51);
    }
    else
    {
      int v33 = *(_DWORD *)(v10 + 4 * v32 + 60) & 0x40000;
    }
    if (v33) {
      uint64_t v36 = (v31 >> 24);
    }
    else {
      uint64_t v36 = 46;
    }
    unsigned int v37 = v31 << 8 >> 24;
    if (v31 << 8 < 0)
    {
      int v38 = __maskrune(v37, 0x40000uLL);
      int v31 = *((_DWORD *)v6 + 51);
    }
    else
    {
      int v38 = *(_DWORD *)(v10 + 4 * v37 + 60) & 0x40000;
    }
    if (v38) {
      uint64_t v39 = (v31 << 8 >> 24);
    }
    else {
      uint64_t v39 = 46;
    }
    unsigned int v40 = (__int16)v31 >> 8;
    if (v31 << 16 < 0)
    {
      int v41 = __maskrune(v40, 0x40000uLL);
      int v31 = *((_DWORD *)v6 + 51);
    }
    else
    {
      int v41 = *(_DWORD *)(v10 + 4 * v40 + 60) & 0x40000;
    }
    if (v41) {
      uint64_t v42 = ((__int16)v31 >> 8);
    }
    else {
      uint64_t v42 = 46;
    }
    if ((v31 << 24) <= 0x7F000000)
    {
      if ((*(_DWORD *)(v10 + 4 * (char)v31 + 60) & 0x40000) != 0) {
        goto LABEL_55;
      }
    }
    else if (__maskrune((char)v31, 0x40000uLL))
    {
LABEL_55:
      uint64_t v43 = *((char *)v6 + 204);
LABEL_58:
      LogError("CopyIOSurfaceProc", 1631, "*** IIO_Reader::CopyIOSurfaceProc - '%c%c%c%c'- does not support 'callDecodeImage'\n", v36, v39, v42, v43);
LABEL_59:
      int v44 = *((_DWORD *)v6 + 51);
      unsigned int v45 = v44 >> 24;
      if (v44 < 0)
      {
        int v46 = __maskrune(v45, 0x40000uLL);
        int v44 = *((_DWORD *)v6 + 51);
      }
      else
      {
        int v46 = *(_DWORD *)(v10 + 4 * v45 + 60) & 0x40000;
      }
      if (v46) {
        uint64_t v47 = (v44 >> 24);
      }
      else {
        uint64_t v47 = 46;
      }
      unsigned int v48 = v44 << 8 >> 24;
      if (v44 << 8 < 0)
      {
        int v49 = __maskrune(v48, 0x40000uLL);
        int v44 = *((_DWORD *)v6 + 51);
      }
      else
      {
        int v49 = *(_DWORD *)(v10 + 4 * v48 + 60) & 0x40000;
      }
      if (v49) {
        uint64_t v50 = (v44 << 8 >> 24);
      }
      else {
        uint64_t v50 = 46;
      }
      unsigned int v51 = (__int16)v44 >> 8;
      if (v44 << 16 < 0)
      {
        int v52 = __maskrune(v51, 0x40000uLL);
        int v44 = *((_DWORD *)v6 + 51);
      }
      else
      {
        int v52 = *(_DWORD *)(v10 + 4 * v51 + 60) & 0x40000;
      }
      if (v52) {
        uint64_t v53 = ((__int16)v44 >> 8);
      }
      else {
        uint64_t v53 = 46;
      }
      if ((v44 << 24) <= 0x7F000000)
      {
        if ((*(_DWORD *)(v10 + 4 * (char)v44 + 60) & 0x40000) != 0) {
          goto LABEL_79;
        }
      }
      else if (__maskrune((char)v44, 0x40000uLL))
      {
LABEL_79:
        uint64_t v54 = *((char *)v6 + 204);
LABEL_82:
        __n128 v28 = _cg_jpeg_mem_term("CopyIOSurfaceProc", 1634, "*** ERROR: '%c%c%c%c' callDecodeImage failed [%d]\n", v47, v50, v53, v54, v27);
        goto LABEL_83;
      }
      uint64_t v54 = 46;
      goto LABEL_82;
    }
    uint64_t v43 = 46;
    goto LABEL_58;
  }
LABEL_83:
  if ((*(unsigned int (**)(IIOReadPlugin *, __n128))(*(void *)v6 + 264))(v6, v28)) {
    IIOReadPlugin::debugWriteIOSurface(v6, SurfaceWithFormat);
  }
  (*(void (**)(IIOReadPlugin *))(*(void *)v6 + 88))(v6);
  IIODecodeParameter::~IIODecodeParameter((IIODecodeParameter *)v66);
  IOSurfaceRef result = SurfaceWithFormat;
  if ((gIIODebugFlags & 0x800000000000) != 0 && !SurfaceWithFormat)
  {
    ImageIOLog(" ISSUE: %s:%d:  %s\n", "CopyIOSurfaceProc", 1647, "could not create IOSurfaceRef");
    return SurfaceWithFormat;
  }
  return result;
}

void sub_1886095F0(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15)
{
  __cxa_begin_catch(a1);
  *(void *)(v15 - 104) = 0;
  __cxa_end_catch();
  JUMPOUT(0x188609484);
}

uint64_t IIOReadPlugin::shouldDebugWriteImageBlocks(IIOReadPlugin *this)
{
  return *((unsigned __int8 *)this + 180);
}

uint64_t IIOReadPlugin::canHandleRemoteIOSurface(IIOReadPlugin *this)
{
  return 0;
}

uint64_t IIODecodingSetAllowableTypes(const void *a1)
{
  uint64_t v6 = 0;
  int v7 = &v6;
  uint64_t v8 = 0x2000000000;
  uint64_t v1 = 4294967246;
  int v9 = -50;
  if (a1)
  {
    CFTypeID v3 = CFGetTypeID(a1);
    if (v3 == CFArrayGetTypeID())
    {
      v5[0] = MEMORY[0x1E4F143A8];
      v5[1] = 0x40000000;
      _OWORD v5[2] = __IIODecodingSetAllowableTypes_block_invoke;
      void v5[3] = &unk_1E53BFF30;
      _OWORD v5[4] = &v6;
      void v5[5] = a1;
      if (IIODecodingSetAllowableTypes::onceToken != -1) {
        dispatch_once(&IIODecodingSetAllowableTypes::onceToken, v5);
      }
      uint64_t v1 = *((unsigned int *)v7 + 6);
    }
    else
    {
      uint64_t v1 = 4294967246;
      *((_DWORD *)v7 + 6) = -50;
    }
  }
  _Block_object_dispose(&v6, 8);
  return v1;
}

void sub_18860972C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t ___Z22hardware_supports_astcv_block_invoke()
{
  uint64_t result = MGGetBoolAnswer();
  hardware_supports_astc(void)::supportsASTC = result;
  return result;
}

dispatch_queue_t ___ZN13IIOReadPlugin16cacheImmediatelyEPK14__CFDictionaryP7CGImage_block_invoke()
{
  dispatch_queue_t result = dispatch_queue_create("CacheImmediatelyQueue", 0);
  IIOReadPlugin::cacheImmediately(__CFDictionary const*,CGImage *)::cacheQueue = (uint64_t)result;
  return result;
}

uint64_t IIOIOSurfaceWrapperBase::ReleaseInfo(uint64_t this, void *a2)
{
  if (this) {
    return (*(uint64_t (**)(void))(*(void *)this + 8))();
  }
  return this;
}

uint64_t HEIFReadPlugin::decodeImageImp(IIOReadPlugin *this, IIODecodeParameter *a2, int a3, __IOSurface **a4, uint64_t a5, uint64_t *a6)
{
  *((_DWORD *)this + 52) = *((void *)a2 + 9);
  *((unsigned char *)this + 343) = 0;
  *((unsigned char *)this + 408) = 1;
  *((_DWORD *)this + 26) = 1;
  if ((gIIODebugFlags & 0x20000) != 0)
  {
    int v11 = *((_DWORD *)this + 51);
    unsigned int v12 = v11 >> 24;
    uint64_t v13 = MEMORY[0x1E4F14390];
    if (v11 < 0)
    {
      int v14 = __maskrune(v12, 0x40000uLL);
      int v11 = *((_DWORD *)this + 51);
    }
    else
    {
      int v14 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v12 + 60) & 0x40000;
    }
    if (v14) {
      uint64_t v15 = (v11 >> 24);
    }
    else {
      uint64_t v15 = 46;
    }
    unsigned int v16 = v11 << 8 >> 24;
    if (v11 << 8 < 0)
    {
      int v17 = __maskrune(v16, 0x40000uLL);
      int v11 = *((_DWORD *)this + 51);
    }
    else
    {
      int v17 = *(_DWORD *)(v13 + 4 * v16 + 60) & 0x40000;
    }
    if (v17) {
      uint64_t v18 = (v11 << 8 >> 24);
    }
    else {
      uint64_t v18 = 46;
    }
    unsigned int v19 = (__int16)v11 >> 8;
    if (v11 << 16 < 0)
    {
      int v20 = __maskrune(v19, 0x40000uLL);
      int v11 = *((_DWORD *)this + 51);
    }
    else
    {
      int v20 = *(_DWORD *)(v13 + 4 * v19 + 60) & 0x40000;
    }
    if (v20) {
      uint64_t v21 = ((__int16)v11 >> 8);
    }
    else {
      uint64_t v21 = 46;
    }
    if ((v11 << 24) <= 0x7F000000)
    {
      if ((*(_DWORD *)(v13 + 4 * (char)v11 + 60) & 0x40000) != 0) {
        goto LABEL_22;
      }
    }
    else if (__maskrune((char)v11, 0x40000uLL))
    {
LABEL_22:
      uint64_t v22 = *((char *)this + 204);
LABEL_25:
      ImageIOLog("  '%c%c%c%c' [%s] %s\n", v15, v18, v21, v22, iioTypeStr[a3], "virtual OSStatus HEIFReadPlugin::decodeImageImp(IIODecodeParameter *, IIOImageType, IOSurfaceRef *, CVPixelBufferRef *, CGImageBlockSetRef *)");
      goto LABEL_26;
    }
    uint64_t v22 = 46;
    goto LABEL_25;
  }
LABEL_26:
  IIOReadPlugin::debugDecodeImage(this, a2);
  double v23 = IIOImageReadSession::globalInfoForType(*((IIOImageReadSession **)this + 3), 1212500294);
  if (!v23)
  {
    _cg_jpeg_mem_term("decodeImageImp", 3020, "*** ERROR: globalHEIFInfo is NULL\n");
    return 4294967246;
  }
  *((_DWORD *)this + 126) = GlobalHEIFInfo::resolvedIndexForIndex(v23, *((unsigned int *)this + 52));
  if (a3 == 3)
  {
    uint64_t v25 = *((void *)a2 + 1);
    uint64_t v26 = *((void *)a2 + 2);
    double v27 = *((double *)a2 + 3);
    double v28 = *((double *)a2 + 4);
    double v29 = *((double *)a2 + 5);
    double v30 = *((double *)a2 + 6);
    double v31 = *((double *)a2 + 7);
    double v32 = *((double *)a2 + 8);
    uint64_t XmpData = _APP1XMP::getXmpData(a2);
    uint64_t v34 = (*(uint64_t (**)(IIOReadPlugin *, uint64_t, uint64_t, uint64_t, double, double, double, double, double, double))(*(void *)this + 208))(this, v25, v26, XmpData, v27, v28, v29, v30, v31, v32);
    if (a6)
    {
      uint64_t v24 = 0;
      *a6 = v34;
      return v24;
    }
    return 4294967246;
  }
  if (a3 != 1 || !a4) {
    return 4294967246;
  }
  if (*a4)
  {
    uint64_t v24 = HEIFReadPlugin::decodeIntoIOSurface(this, a2, *a4);
    if ((gIIODebugFlags & 0x2000000) != 0) {
      LogSurfaceFormat(*a4, "*ioSurface", "decodeImageImp", 3030);
    }
    if (v24) {
      _cg_jpeg_mem_term("decodeImageImp", 3032, "*** decodeIntoIOSurface - err = %d\n", v24);
    }
  }
  else
  {
    uint64_t v35 = *((void *)a2 + 2);
    uint64_t v36 = _APP1XMP::getXmpData(a2);
    uint64_t v24 = (*(uint64_t (**)(IIOReadPlugin *, uint64_t, uint64_t, __IOSurface **, void))(*(void *)this + 224))(this, v35, v36, a4, 0);
    if ((gIIODebugFlags & 0x2000000) != 0) {
      LogSurfaceFormat(*a4, "*ioSurface", "decodeImageImp", 3038);
    }
  }
  return v24;
}

uint64_t HEIFReadPlugin::copyImageBlockSetImp(uint64_t a1, const void *a2, const void *a3, __CFDictionary *a4, double a5, double a6, double a7, double a8, double a9, double a10)
{
  memset(v154, 0, sizeof(v154));
  v155[0] = 0;
  IIODictionary::IIODictionary((IIODictionary *)v154, a4);
  if (!*(void *)(a1 + 24))
  {
    uint64_t v29 = 0;
    goto LABEL_204;
  }
  IIO_LoadHEIFSymbols();
  unsigned int v19 = IIOImageReadSession::globalInfoForType(*(IIOImageReadSession **)(a1 + 24), 1212500294);
  if (GlobalHEIFInfo::hasHEIFSequence(v19)) {
    int v138 = IIOImageRead::trustedURL(v19);
  }
  else {
    int v138 = 0;
  }
  IIOReadPlugin::debugCopyBlockSet((const char *)a1, a3, a5, a6, a7, a8, a9, a10);
  int v20 = (const __CFString **)MEMORY[0x1E4F1DD50];
  if (*(unsigned char *)(a1 + 492) || *(unsigned char *)(a1 + 493))
  {
    *(unsigned char *)(a1 + 343) = 1;
    CFStringRef v21 = *v20;
  }
  else
  {
    int v115 = *(unsigned __int8 *)(a1 + 408);
    BOOL v117 = a8 != a10 || a7 != a9 || v115 == 1;
    CFStringRef v21 = (const __CFString *)*MEMORY[0x1E4F1DD50];
    if (v117
      && v115 != 1
      && (IIODictionary::containsKey((IIODictionary *)v154, (const __CFString *)*MEMORY[0x1E4F1DD50]) & 1) == 0
      && !*(unsigned char *)(a1 + 499))
    {
      HEIFMainImageAtIndedouble x = (HEIFMainImage *)GlobalHEIFInfo::getHEIFMainImageAtIndex(v19, *(_DWORD *)(a1 + 504));
      if (!*(unsigned char *)(a1 + 498) && *(unsigned __int16 *)(a1 + 316) <= 1u)
      {
        char v119 = HEIFMainImageAtIndex;
        Tileint Width = HEIFMainImage::getTileWidth(HEIFMainImageAtIndex);
        TileCFIndex Length = HEIFMainImage::getTileLength(v119);
        if (TileWidth)
        {
          if (TileLength)
          {
            if (TileWidth != *(_DWORD *)(a1 + 292))
            {
              unsigned int v123 = *(_DWORD *)(a1 + 296);
              if (TileLength != v123 && *(unsigned int *)(a1 + 300) * (unint64_t)v123 >= 0x1000001)
              {
                LODWORD(v145) = 0;
                long long v124 = *(_OWORD *)(a1 + 300);
                *(_OWORD *)&dest.CFDataRef data = *(_OWORD *)(a1 + 284);
                *(_OWORD *)&dest.double width = v124;
                if ((gIIODebugFlags & 0x30000) != 0) {
                  ImageIOLog("    decoding multi tiles: {%g,%g,%g,%g} {%g,%g} - subsample: %d\n", a5, a6, a7, a8, a9, a10, *(unsigned __int16 *)(a1 + 316));
                }
                uint64_t v29 = HEIFReadPlugin::copyImageBlockSetTiles(a1, a2, (uint64_t)a3, v154, TileWidth, a5, a6, a7, a8, v122, &v145);
                long long v125 = *(_OWORD *)&dest.width;
                *(_OWORD *)(a1 + 284) = *(_OWORD *)&dest.data;
                *(_OWORD *)(a1 + 300) = v125;
                if (v29 || v145 == 1) {
                  goto LABEL_204;
                }
                _cg_jpeg_mem_term("copyImageBlockSetImp", 2022, "*** ERROR: tiled decoding failed - falling back to standard decode\n");
              }
            }
          }
        }
      }
    }
  }
  if (IIODictionary::containsKey((IIODictionary *)v154, v21) && !*(unsigned char *)(a1 + 492))
  {
    if ((gIIODebugFlags & 0x30000) != 0) {
      ImageIOLog("    got 'kCGImageBlockTileRequest'\n");
    }
    uint64_t v22 = a2;
    unsigned int Uint32ForKey = IIODictionary::getUint32ForKey((IIODictionary *)v154, v21);
    if (Uint32ForKey - 1 >= 0xFF) {
      unsigned int v25 = Uint32ForKey;
    }
    else {
      unsigned int v25 = 256;
    }
    uint64_t v26 = (_OWORD *)(a1 + 284);
    if (v25 <= *(_DWORD *)(a1 + 292) && v25 <= *(_DWORD *)(a1 + 296))
    {
      long long v129 = *(_OWORD *)(a1 + 300);
      *(_OWORD *)&dest.CFDataRef data = *v26;
      *(_OWORD *)&dest.double width = v129;
      LODWORD(v145) = 0;
      if (v25)
      {
        if ((gIIODebugFlags & 0x30000) != 0) {
          ImageIOLog("    decoding multi tiles [%d]: {%g,%g,%g,%g} {%g,%g}\n", v25, a5, a6, a7, a8, a9, a10);
        }
        uint64_t v28 = HEIFReadPlugin::copyImageBlockSetTiles(a1, v22, (uint64_t)a3, v154, v25, a5, a6, a7, a8, v24, &v145);
LABEL_21:
        uint64_t v29 = v28;
        long long v30 = *(_OWORD *)&dest.width;
        *uint64_t v26 = *(_OWORD *)&dest.data;
        *(_OWORD *)(a1 + 300) = v30;
        if (!v28 && v145 != 1)
        {
          *(_DWORD *)(a1 + 104) = 1;
          a2 = v22;
          goto LABEL_24;
        }
LABEL_204:
        BOOL v126 = 0;
        if (!a3) {
          goto LABEL_195;
        }
        goto LABEL_194;
      }
    }
    else
    {
      long long v27 = *(_OWORD *)(a1 + 300);
      *(_OWORD *)&dest.CFDataRef data = *v26;
      *(_OWORD *)&dest.double width = v27;
      LODWORD(v145) = 0;
    }
    if ((gIIODebugFlags & 0x30000) != 0) {
      ImageIOLog("    decoding single tile: {%g,%g,%g,%g} {%g,%g}\n", a5, a6, a7, a8, a9, a10);
    }
    uint64_t v28 = HEIFReadPlugin::copyImageBlockSetSingleTile(a1, v22, (uint64_t)a3, v154, &v145, a5, a6, a7, a8);
    goto LABEL_21;
  }
LABEL_24:
  if ((gIIODebugFlags & 0x30000) != 0) {
    ImageIOLog("    _blockunsigned int Count = %d\n", *(_DWORD *)(a1 + 104));
  }
  uint64_t v140 = *(unsigned int *)(a1 + 112);
  IIOReadPlugin::debugCopyBlockSet((const char *)a1, a3, a5, a6, a7, a8, a9, a10);
  BlockArradouble y = IIOReadPlugin::allocateBlockArray((IIOReadPlugin *)a1, *(unsigned int *)(a1 + 104));
  if (IIOReadPlugin::getCachedBlocks((IIOReadPlugin *)a1, v32, v33, v34))
  {
    uint64_t v36 = *(IIOImageRead ***)(a1 + 24);
    memory_object_size_t v134 = a3;
    if (v36) {
      BOOL v133 = IIOImageReadSession::mapData(v36);
    }
    else {
      BOOL v133 = 0;
    }
    uint64_t v39 = *(unsigned int *)(a1 + 112);
    if (v39 < *(_DWORD *)(a1 + 116))
    {
      int v141 = 0;
      CFDataRef v139 = 0;
      CFIndex v131 = (void *)(a1 + 292);
      char v137 = 1;
      CFAllocatorRef v136 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      CFAllocatorRef v135 = (const __CFAllocator *)*MEMORY[0x1E4F1CFA0];
      CFTypeRef value = (void *)*MEMORY[0x1E4F1CFC8];
      while (1)
      {
        if (*(void *)(*(void *)(a1 + 96) + 8 * (v39 - v140))) {
          _cg_jpeg_mem_term("copyImageBlockSetImp", 2080, "*** _blockArray[%d] was cached - and already allocated\n", v39 - v140);
        }
        unsigned int v40 = *(_DWORD *)(a1 + 296);
        double v41 = (double)(v40 * v39);
        LODWORD(a8) = *(_DWORD *)(a1 + 292);
        LODWORD(v35) = *(_DWORD *)(a1 + 264);
        double v42 = (double)*(unint64_t *)&v35;
        double v43 = (double)v40 + v41 <= v42 ? (double)v40 : v42 - (double)(v40 * v39);
        unsigned int v44 = *(_DWORD *)(a1 + 300);
        CFTypeRef v152 = 0;
        int v45 = IIOCreateCMPhotoDecompressionSession((uint64_t)&v152);
        BlockArradouble y = v45;
        if (!v45) {
          break;
        }
        int v46 = IIOCMErrorString(v45);
        _cg_jpeg_mem_term("copyImageBlockSetImp", 2109, "*** CMPhotoDecompressionSessionCreate  err = %s [%d]\n", v46, BlockArray);
LABEL_41:
        a8 = (double)*(unint64_t *)&a8;
        v156.origin.double x = 0.0;
        v156.origin.double y = v41;
        v156.size.double width = a8;
        v156.size.double height = v43;
        *(void *)(*(void *)(a1 + 96) + 8 * (v39 - v140)) = IIOReadPlugin::createImageBlock((IIOReadPlugin *)a1, v141, v155[0], v156, *(unsigned int *)(a1 + 300), *(unsigned __int8 *)(a1 + 343));
        BOOL v47 = CGRectEqualToRect(*(CGRect *)(a1 + 120), *MEMORY[0x1E4F1DB20]);
        uint64_t v48 = 0;
        if (!v47)
        {
          v157.origin.double x = 0.0;
          v157.origin.double y = v41;
          v157.size.double width = a8;
          v157.size.double height = v43;
          *(CGRect *)(&v35 - 2) = CGRectUnion(*(CGRect *)(a1 + 120), v157);
          double v41 = v49;
          a8 = v35;
          double v43 = v50;
        }
        *(void *)(a1 + 120) = v48;
        *(double *)(a1 + 128) = v41;
        *(double *)(a1 + 136) = a8;
        *(double *)(a1 + 144) = v43;
        if (++v39 >= (unint64_t)*(unsigned int *)(a1 + 116)) {
          goto LABEL_160;
        }
      }
      CFTypeRef v150 = 0;
      CFTypeRef v151 = 0;
      int v149 = 0;
      unint64_t v148 = 0;
      CFIndex Size = IIOImageReadSession::getSize(*(IIOImageReadSession **)(a1 + 24));
      int v52 = IIOImageReadSession::retainBytePointer(*(IIOImageReadSession **)(a1 + 24), (const __CFData **)&v148, 1);
      uint64_t v53 = (const UInt8 *)v52;
      if (!v52)
      {
        LogError("copyImageBlockSetImp", 2125, "*** ERROR: retainBytePointer failed\n");
        a3 = v134;
        BOOL v37 = v133;
        goto LABEL_190;
      }
      uint64_t v54 = *(void *)(a1 + 464);
      CFDataRef v55 = v139;
      if (v54)
      {
        if (*(void *)(a1 + 472)) {
          CFIndex Size = *(IIOImageRead **)(a1 + 472);
        }
        else {
          uint64_t v54 = 0;
        }
        uint64_t v53 = (const UInt8 *)v52 + v54;
      }
      if (!v139)
      {
        CFDataRef v55 = CFDataCreateWithBytesNoCopy(v136, v53, (CFIndex)Size, v135);
        if (!v55)
        {
          CFDataRef v139 = 0;
          BlockArradouble y = 0;
          goto LABEL_156;
        }
      }
      CFDataRef v139 = v55;
      int v56 = gFunc_CMPhotoDecompressionSessionCreateContainer(v152, 0, v55, &v149, &v151);
      BlockArradouble y = v56;
      if (v56)
      {
        unsigned int v57 = IIOCMErrorString(v56);
        _cg_jpeg_mem_term("copyImageBlockSetImp", 2145, "*** CMPhotoDecompressionSessionCreateContainer  err = %s [%d]\n", v57, BlockArray);
LABEL_156:
        CFRelease(v152);
        if (v148)
        {
          long long v113 = *(IIOImageRead ***)(a1 + 24);
          if (v113) {
            IIOImageReadSession::releaseBytePointer(v113, v148);
          }
        }
        goto LABEL_41;
      }
      uint64_t v145 = 0;
      uint64_t v146 = 0;
      uint64_t v147 = 0;
      IIODictionary::IIODictionary((IIODictionary *)&v145);
      HEIFReadPlugin::updateHardwareDecodeOptions((IIODictionary **)a1, (IIODictionary *)&v145, v154);
      CFTypeRef cf = 0;
      if (*(unsigned char *)(a1 + 493))
      {
        int v58 = (HEIFMainImage *)GlobalHEIFInfo::getHEIFMainImageAtIndex(v19, *(_DWORD *)(a1 + 504));
        int v59 = HEIFMainImage::bitDepth(v58);
        int DecodePixelFormatForBitDepth = HEIFReadPlugin::getDecodePixelFormatForBitDepth((HEIFReadPlugin *)a1, v59);
        goto LABEL_68;
      }
      if (!*(unsigned char *)(a1 + 492))
      {
        int DecodePixelFormatForBitDepth = HEIFReadPlugin::getPixelFormatForBitDepth((HEIFReadPlugin *)a1, *(unsigned __int16 *)(a1 + 304), *(IIODictionary **)(a1 + 48));
        goto LABEL_68;
      }
      int v61 = *(_DWORD *)(a1 + 324);
      if (v61 == 1196573017)
      {
        BOOL v62 = *(unsigned char *)(a1 + 500) == 0;
        int v63 = 843264310;
        int v64 = 1278226742;
      }
      else
      {
        if (v61 != 1380401696)
        {
          int DecodePixelFormatForBitDepth = 0;
          goto LABEL_68;
        }
        BOOL v62 = *(unsigned char *)(a1 + 500) == 0;
        int v63 = 1815491698;
        int v64 = 2019963440;
      }
      if (v62) {
        int DecodePixelFormatForBitDepth = v64;
      }
      else {
        int DecodePixelFormatForBitDepth = v63;
      }
LABEL_68:
      IIONumber::IIONumber((IIONumber *)v143, DecodePixelFormatForBitDepth);
      IIODictionary::setObjectForKey((uint64_t)&v145, (uint64_t)v143, *(const void **)gIIO_kCMPhotoDecompressionOption_OutputPixelFormat);
      IIONumber::~IIONumber((IIONumber *)v143);
      IIODictionary::setObjectForKey((IIODictionary *)&v145, value, *(const __CFString **)gIIO_kCMPhotoDecompressionOption_ApplyTransform);
      HEIFReadPlugin::updateCreateImageOptions((HEIFReadPlugin *)a1, (IIODictionary *)&v145, *(IIODictionary **)(a1 + 48));
      if (v138)
      {
        int v65 = gFunc_CMPhotoDecompressionContainerCreateSequenceContainer(v151, 0, 0, &v150);
        int v66 = v65;
        if (v65)
        {
          uint64_t v67 = IIOCMErrorString(v65);
          _cg_jpeg_mem_term("copyImageBlockSetImp", 2182, "*** CMPhotoDecompressionSessionCreateContainer[sequence] err = %s [%d]\n", v67, v66);
        }
        if (*(unsigned __int8 *)(a1 + 216) < 2u || *(unsigned char *)(a1 + 498))
        {
          int v68 = gFunc_CMPhotoDecompressionContainerCreateImageForIndex(v150, *(unsigned int *)(a1 + 504), v146, 2, &cf);
          BlockArradouble y = v68;
          if (v68)
          {
            *(void *)&double v69 = _cg_jpeg_mem_term("copyImageBlockSetImp", 2199, "CMPhotoDecompressionContainerCreateImageForIndex(%s)  err=%d\n", (const char *)*(unsigned int *)(a1 + 504), v68).n128_u64[0];
            goto LABEL_75;
          }
          goto LABEL_84;
        }
        CGRect v71 = &v150;
      }
      else
      {
        if (*(unsigned __int8 *)(a1 + 216) < 2u || *(unsigned char *)(a1 + 498))
        {
          int v70 = gFunc_CMPhotoDecompressionContainerCreateImageForIndex(v151, *(unsigned int *)(a1 + 504), v146, 2, &cf);
          goto LABEL_83;
        }
        CGRect v71 = &v151;
      }
      int v70 = gFunc_CMPhotoDecompressionContainerCreateThumbnailImageForIndex(*v71, *(unsigned int *)(a1 + 504), 0, v146, 2, &cf);
LABEL_83:
      BlockArradouble y = v70;
      if (v70)
      {
LABEL_75:
        if (BlockArray == -15470)
        {
          LogError("copyImageBlockSetImp", 2251, "*** ERROR: CMPhotoDecompressionContainerCreateImageForIndex failed (kCMPhotoError_XPCError) - mediaserverd is not running? - no way to decode a HEIC\n", v69);
          char v137 = 0;
          BlockArradouble y = -15470;
        }
LABEL_153:
        if (v150) {
          CFRelease(v150);
        }
        CFRelease(v151);
        IIODictionary::~IIODictionary((IIODictionary *)&v145);
        goto LABEL_156;
      }
LABEL_84:
      if (*(unsigned char *)(a1 + 492))
      {
        if ((gIIODebugFlags & 0x300000) != 0) {
          ImageIOLog("  _requestedApplyGainMap --> createSurfaceWithGainMapApplied\n");
        }
        IOSurface = (__IOSurface *)gFunc_CVPixelBufferGetIOSurface(cf);
        unsigned int v73 = IOSurface;
        if ((gIIODebugFlags & 0x2000000) != 0) {
          LogSurfaceFormat(IOSurface, "surface", "copyImageBlockSetImp", 2272);
        }
        int PixelFormatForBitDepth = HEIFReadPlugin::getPixelFormatForBitDepth((HEIFReadPlugin *)a1, *(unsigned __int16 *)(a1 + 304), *(IIODictionary **)(a1 + 48));
        if (PixelFormatForBitDepth == 1815491698)
        {
          if (*(unsigned char *)(a1 + 313)) {
            int PixelFormatForBitDepth = 1380411457;
          }
          else {
            int PixelFormatForBitDepth = 1815491698;
          }
        }
        *(_DWORD *)(a1 + 440) = PixelFormatForBitDepth;
        SurfaceWithGainMapApplied = HEIFReadPlugin::createSurfaceWithGainMapApplied(a1, (uint64_t)v151, v75, v19, v73);
        char v77 = SurfaceWithGainMapApplied;
        if (!SurfaceWithGainMapApplied) {
          goto LABEL_106;
        }
        if ((gIIODebugFlags & 0x2000000) != 0) {
          LogSurfaceFormat(SurfaceWithGainMapApplied, "outputSurface", "copyImageBlockSetImp", 2281);
        }
      }
      else
      {
        if (!*(unsigned char *)(a1 + 493)) {
          goto LABEL_106;
        }
        if ((gIIODebugFlags & 0x300000) != 0) {
          ImageIOLog("  _requestedApplyToneMap --> createSurfaceWithToneMapApplied\n");
        }
        char v78 = (__IOSurface *)gFunc_CVPixelBufferGetIOSurface(cf);
        unsigned int v79 = v78;
        if ((gIIODebugFlags & 0x2000000) != 0) {
          LogSurfaceFormat(v78, "surface", "copyImageBlockSetImp", 2294);
        }
        uint64_t v80 = HEIFReadPlugin::getPixelFormatForBitDepth((HEIFReadPlugin *)a1, *(unsigned __int16 *)(a1 + 304), *(IIODictionary **)(a1 + 48));
        SurfaceWithToneMapApplied = HEIFReadPlugin::createSurfaceWithToneMapApplied(v80, v81, v82, v83, v79, v80, *(const __CFString **)(a1 + 520), *(unsigned __int8 *)(a1 + 497));
        char v77 = SurfaceWithToneMapApplied;
        if (!SurfaceWithToneMapApplied) {
          goto LABEL_106;
        }
        if ((gIIODebugFlags & 0x2000000) != 0) {
          LogSurfaceFormat(SurfaceWithToneMapApplied, "outputSurface", "copyImageBlockSetImp", 2300);
        }
      }
      dest.CFDataRef data = 0;
      gFunc_CVPixelBufferCreateWithIOSurface(0, v77, 0, &dest);
      CFRelease(v77);
      CFRelease(cf);
      CFTypeRef cf = dest.data;
LABEL_106:
      int v141 = (char *)_ImageIO_Malloc(v44 * (unint64_t)v40, *(void *)(a1 + 384), v155, (uint64_t)kImageMalloc_HEIF_Data[0], *(_DWORD *)(a1 + 432), 0, 0);
      if (!v141)
      {
        _cg_jpeg_mem_term("copyImageBlockSetImp", 2314, "failed to alloc imageData (%ld bytes)\n", v44 * (unint64_t)v40);
        IIODictionary::~IIODictionary((IIODictionary *)&v145);
        a3 = v134;
        BOOL v37 = v133;
        goto LABEL_190;
      }
      gFunc_CVPixelBufferLockBaseAddress(cf, 0);
      int IsPlanar = gFunc_CVPixelBufferIsPlanar(cf);
      PixelFormatunsigned int Type = gFunc_CVPixelBufferGetPixelFormatType(cf);
      int v87 = PixelFormatType;
      if (IsPlanar)
      {
        unsigned int v88 = PixelFormatType >> 24;
        if (PixelFormatType < 0) {
          int v89 = __maskrune(PixelFormatType >> 24, 0x40000uLL);
        }
        else {
          int v89 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v88 + 60) & 0x40000;
        }
        if (v89) {
          uint64_t v103 = v88;
        }
        else {
          uint64_t v103 = 46;
        }
        unsigned int v104 = v87 << 8 >> 24;
        if (v87 << 8 < 0) {
          int v105 = __maskrune(v87 << 8 >> 24, 0x40000uLL);
        }
        else {
          int v105 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v104 + 60) & 0x40000;
        }
        if (v105) {
          uint64_t v106 = v104;
        }
        else {
          uint64_t v106 = 46;
        }
        unsigned int v107 = (__int16)v87 >> 8;
        if (v87 << 16 < 0) {
          int v108 = __maskrune((__int16)v87 >> 8, 0x40000uLL);
        }
        else {
          int v108 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v107 + 60) & 0x40000;
        }
        if ((v87 << 24) <= 0x7F000000) {
          int v109 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * (char)v87 + 60) & 0x40000;
        }
        else {
          int v109 = __maskrune((char)v87, 0x40000uLL);
        }
        if (v108) {
          uint64_t v110 = v107;
        }
        else {
          uint64_t v110 = 46;
        }
        if (v109) {
          uint64_t v111 = (char)v87;
        }
        else {
          uint64_t v111 = 46;
        }
        LogError("copyImageBlockSetImp", 2325, "*** 'BGRA' request returned planar data - not handled '%c%c%c%c'\n", v103, v106, v110, v111);
      }
      else
      {
        BaseAddress = (char *)gFunc_CVPixelBufferGetBaseAddress(cf);
        unint64_t BytesPerRow = gFunc_CVPixelBufferGetBytesPerRow(cf);
        unint64_t Height = gFunc_CVPixelBufferGetHeight(cf);
        long long v130 = a2;
        int Width = gFunc_CVPixelBufferGetWidth(cf);
        if (BytesPerRow >= *(unsigned int *)(a1 + 300)) {
          size_t v94 = *(unsigned int *)(a1 + 300);
        }
        else {
          size_t v94 = BytesPerRow;
        }
        if (Height >= *(unsigned int *)(a1 + 296)) {
          unsigned int v95 = *(_DWORD *)(a1 + 296);
        }
        else {
          unsigned int v95 = Height;
        }
        *gCrashMessage = 0;
        snprintf(gCrashMessage, 0x200uLL, "ImageIO: copyImageBlockSetImp: pixelBuf: %dx%d (rb:%d)  blockSet: %dx%d (rb:%d)  src: %p  dst: %p\n", *(_DWORD *)(a1 + 292), *(_DWORD *)(a1 + 296), *(_DWORD *)(a1 + 300), Width, Height, BytesPerRow, BaseAddress, v141);
        qword_1EB2BF498 = gCrashMessage;
        int v97 = v141;
        for (unsigned int i = v95; i; --i)
        {
          memcpy(v97, BaseAddress, v94);
          v97 += *(unsigned int *)(a1 + 300);
          BaseAddress += BytesPerRow;
        }
        unsigned int v99 = *(_DWORD *)(a1 + 296);
        a2 = v130;
        if (v99 > v95)
        {
          BOOL v100 = &BaseAddress[-BytesPerRow];
          do
          {
            memcpy(v97, v100, v94);
            v97 += *(unsigned int *)(a1 + 300);
            ++v95;
            unsigned int v99 = *(_DWORD *)(a1 + 296);
          }
          while (v95 < v99);
        }
        qword_1EB2BF498 = 0;
        if (v87 == 1111970369)
        {
          if (!*(unsigned char *)(a1 + 405)) {
            goto LABEL_209;
          }
          if ((gIIODebugFlags & 0x30000) != 0)
          {
            ImageIOLog("    vImagePermuteChannels_ARGB8888:   BGRX -> RGBX\n");
            unsigned int v99 = *(_DWORD *)(a1 + 296);
          }
          dest.CFDataRef data = v141;
          dest.double height = v99;
          size_t v101 = *(unsigned int *)(a1 + 300);
          dest.double width = *(unsigned int *)(a1 + 292);
          dest.rowunint64_t Bytes = v101;
          *(_DWORD *)permuteMap = 50331906;
          vImagePermuteChannels_ARGB8888(&dest, &dest, permuteMap, 0x10u);
          if (!*(unsigned char *)(a1 + 405))
          {
LABEL_209:
            if (*(unsigned char *)(a1 + 500) && !*(unsigned char *)(a1 + 501))
            {
              dest.CFDataRef data = v141;
              v102.i64[0] = *v131;
              v102.i64[1] = HIDWORD(*v131);
              *(int8x16_t *)&dest.double height = vextq_s8(v102, v102, 8uLL);
              dest.rowunint64_t Bytes = *(unsigned int *)(a1 + 300);
              vImagePremultiplyData_RGBA8888(&dest, &dest, 0x10u);
            }
          }
        }
      }
      v112.n128_f64[0] = gFunc_CVPixelBufferUnlockBaseAddress(cf, 0, v96);
      gFunc_CVPixelBufferRelease(v112);
      BlockArradouble y = 0;
      goto LABEL_153;
    }
    CFDataRef v139 = 0;
    char v137 = 1;
LABEL_160:
    int v38 = v137 & 1;
    a3 = v134;
    BOOL v37 = v133;
    if (BlockArray)
    {
LABEL_190:
      uint64_t v29 = 0;
      goto LABEL_191;
    }
  }
  else
  {
    CFDataRef v139 = 0;
    BOOL v37 = 0;
    int v38 = 1;
    if (BlockArray) {
      goto LABEL_190;
    }
  }
  uint64_t v29 = 0;
  unint64_t v114 = *(unsigned int *)(a1 + 104);
  if (!a3) {
    int v38 = 0;
  }
  if (v114 && v38) {
    uint64_t v29 = IIOReadPlugin::imageBlockSetCreate(a1, (uint64_t)a3, v114, *(double *)(a1 + 136), *(double *)(a1 + 144), *(double *)(a1 + 120), *(double *)(a1 + 128), *(double *)(a1 + 136), *(double *)(a1 + 144), *(void *)(a1 + 96), a2);
  }
LABEL_191:
  BOOL v126 = v37;
  if (v139) {
    CFRelease(v139);
  }
  if (a3) {
LABEL_194:
  }
    IIOReadPlugin::freeBlockArray((IIOReadPlugin *)a1);
LABEL_195:
  if (v126)
  {
    long long v127 = *(const char ***)(a1 + 24);
    if (v127) {
      IIOImageReadSession::unmapData(v127);
    }
  }
  IIODictionary::~IIODictionary((IIODictionary *)v154);
  return v29;
}

void sub_18860AC80(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,char a35)
{
  IIODictionary::~IIODictionary((IIODictionary *)&a35);
  IIODictionary::~IIODictionary((IIODictionary *)(v35 - 176));
  _Unwind_Resume(a1);
}

void HEIFReadPlugin::updateHardwareDecodeOptions(IIODictionary **this, IIODictionary *a2, const __CFDictionary **a3)
{
  int v6 = IIO_HardwareDecoderDefaultValue();
  if (HEIFReadPlugin::getEnableRestrictedDecodingFlag(this, (IIODictionary *)a3))
  {
    if (!gFunc_VTAreVideoDecodersRunningInProcess()) {
      LogError("updateHardwareDecodeOptions", 1334, "*** ERROR: kCGImageSourceEnableRestrictedDecoding was requested, but VTRestrictVideoDecoders() was not called.\n");
    }
    IIODictionary::setObjectForKey(a2, (const void *)*MEMORY[0x1E4F1CFD0], *(const __CFString **)gIIO_kCMPhotoDecompressionOption_RestrictedDecoding);
    if ((gIIODebugFlags & 0x30000) != 0)
    {
      ImageIOLog("***************************************************************\n");
      if ((gIIODebugFlags & 0x30000) != 0)
      {
        ImageIOLog("*** kCMPhotoDecompressionOption_RestrictedDecoding enabled ***\n");
        if ((gIIODebugFlags & 0x30000) != 0) {
          ImageIOLog("***************************************************************\n");
        }
      }
    }
    goto LABEL_27;
  }
  if (!v6) {
    goto LABEL_22;
  }
  if (v6 == 255)
  {
    if (IIODictionary::containsKey((IIODictionary *)a3, @"kCGImageSourceUseHardwareAcceleration"))
    {
      if (!IIODictionary::getBoolForKey((IIODictionary *)a3, @"kCGImageSourceUseHardwareAcceleration")) {
        goto LABEL_22;
      }
      LOBYTE(v6) = 1;
    }
    else
    {
      LOBYTE(v6) = -1;
    }
  }
  int v7 = IIOHardwareDecodingEnabledFlag();
  int v8 = (char)v6;
  if (!v7) {
    int v8 = 0;
  }
  switch(v8)
  {
    case 1:
      int v10 = *((_DWORD *)this + 51);
      if (v10 == 1096173907 || v10 == 1096173894)
      {
        if ((gIIODebugFlags & 0x4000000000000) != 0 && IIO_OSAppleInternalBuild())
        {
          int v11 = *((_DWORD *)this + 51);
          unsigned int v12 = v11 >> 24;
          uint64_t v13 = MEMORY[0x1E4F14390];
          if (v11 < 0)
          {
            int v14 = __maskrune(v12, 0x40000uLL);
            int v11 = *((_DWORD *)this + 51);
          }
          else
          {
            int v14 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v12 + 60) & 0x40000;
          }
          if (v14) {
            uint64_t v15 = (v11 >> 24);
          }
          else {
            uint64_t v15 = 46;
          }
          unsigned int v16 = v11 << 8 >> 24;
          if (v11 << 8 < 0)
          {
            int v17 = __maskrune(v16, 0x40000uLL);
            int v11 = *((_DWORD *)this + 51);
          }
          else
          {
            int v17 = *(_DWORD *)(v13 + 4 * v16 + 60) & 0x40000;
          }
          if (v17) {
            uint64_t v18 = (v11 << 8 >> 24);
          }
          else {
            uint64_t v18 = 46;
          }
          unsigned int v19 = (__int16)v11 >> 8;
          if (v11 << 16 < 0)
          {
            int v20 = __maskrune(v19, 0x40000uLL);
            int v11 = *((_DWORD *)this + 51);
          }
          else
          {
            int v20 = *(_DWORD *)(v13 + 4 * v19 + 60) & 0x40000;
          }
          if (v20) {
            uint64_t v21 = ((__int16)v11 >> 8);
          }
          else {
            uint64_t v21 = 46;
          }
          if ((v11 << 24) <= 0x7F000000) {
            int v22 = *(_DWORD *)(v13 + 4 * (char)v11 + 60) & 0x40000;
          }
          else {
            int v22 = __maskrune((char)v11, 0x40000uLL);
          }
          if (v22) {
            uint64_t v23 = *((char *)this + 204);
          }
          else {
            uint64_t v23 = 46;
          }
          ImageIOLog("  UseHardwareAcceleration(%c%c%c%c)  | %s:%d\n", v15, v18, v21, v23, "updateHardwareDecodeOptions", 1371);
        }
        IIONumber::IIONumber((IIONumber *)v26, 0);
        IIODictionary::setObjectForKey((uint64_t)a2, (uint64_t)v26, *(const void **)gIIO_kCMPhotoDecompressionOption_AccelerationMode);
        int v9 = (IIONumber *)v26;
      }
      else
      {
        if ((gIIODebugFlags & 0x4000000000000) != 0 && IIO_OSAppleInternalBuild()) {
          ImageIOLog("  UseHardwareAcceleration  | %s:%d\n", "updateHardwareDecodeOptions", 1375);
        }
        IIONumber::IIONumber((IIONumber *)v25, 2);
        IIODictionary::setObjectForKey((uint64_t)a2, (uint64_t)v25, *(const void **)gIIO_kCMPhotoDecompressionOption_AccelerationMode);
        int v9 = (IIONumber *)v25;
      }
      goto LABEL_26;
    case 0:
LABEL_22:
      if ((gIIODebugFlags & 0x4000000000000) != 0 && IIO_OSAppleInternalBuild()) {
        ImageIOLog("  UseHardwareAcceleration  | %s:%d\n", "updateHardwareDecodeOptions", 1380);
      }
      IIONumber::IIONumber((IIONumber *)v24, 1);
      IIODictionary::setObjectForKey((uint64_t)a2, (uint64_t)v24, *(const void **)gIIO_kCMPhotoDecompressionOption_AccelerationMode);
      int v9 = (IIONumber *)v24;
LABEL_26:
      IIONumber::~IIONumber(v9);
      break;
    case -1:
      IIONumber::IIONumber((IIONumber *)v27, 0);
      IIODictionary::setObjectForKey((uint64_t)a2, (uint64_t)v27, *(const void **)gIIO_kCMPhotoDecompressionOption_AccelerationMode);
      IIONumber::~IIONumber((IIONumber *)v27);
      if ((gIIODebugFlags & 0x4000000000000) != 0)
      {
        if (IIO_OSAppleInternalBuild()) {
          ImageIOLog("  UseHardwareAcceleration  | %s:%d\n");
        }
      }
      break;
  }
LABEL_27:
  BREAK_ON_RESTRICTED_CHECK(*((const __CFDictionary **)this[6] + 1), a3[1]);
}

void sub_18860B154(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  va_start(va, a10);
  IIONumber::~IIONumber((IIONumber *)va);
  _Unwind_Resume(a1);
}

uint64_t HEIFReadPlugin::getPixelFormatForBitDepth(HEIFReadPlugin *this, unsigned int a2, IIODictionary *a3)
{
  int v4 = *((_DWORD *)this + 81);
  if (v4 == 1196573017)
  {
    if (a2 >= 9) {
      return 1278226742;
    }
    else {
      return 1278226488;
    }
  }
  else if (v4 == 1380401696)
  {
    BOOL EnableRestrictedDecodingFlag = HEIFReadPlugin::getEnableRestrictedDecodingFlag((IIODictionary **)this, a3);
    int v7 = a2 < 9 || EnableRestrictedDecodingFlag;
    if (a2 == 10) {
      unsigned int v8 = 1815162994;
    }
    else {
      unsigned int v8 = 1815491698;
    }
    if (v7) {
      return 1111970369;
    }
    else {
      return v8;
    }
  }
  else
  {
    unsigned int v10 = v4 >> 24;
    uint64_t v11 = MEMORY[0x1E4F14390];
    if (v4 < 0)
    {
      int v12 = __maskrune(v10, 0x40000uLL);
      int v4 = *((_DWORD *)this + 81);
    }
    else
    {
      int v12 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v10 + 60) & 0x40000;
    }
    if (v12) {
      uint64_t v13 = (v4 >> 24);
    }
    else {
      uint64_t v13 = 46;
    }
    unsigned int v14 = v4 << 8 >> 24;
    if (v4 << 8 < 0)
    {
      int v15 = __maskrune(v14, 0x40000uLL);
      int v4 = *((_DWORD *)this + 81);
    }
    else
    {
      int v15 = *(_DWORD *)(v11 + 4 * v14 + 60) & 0x40000;
    }
    if (v15) {
      uint64_t v16 = (v4 << 8 >> 24);
    }
    else {
      uint64_t v16 = 46;
    }
    unsigned int v17 = (__int16)v4 >> 8;
    if (v4 << 16 < 0)
    {
      int v18 = __maskrune(v17, 0x40000uLL);
      int v4 = *((_DWORD *)this + 81);
    }
    else
    {
      int v18 = *(_DWORD *)(v11 + 4 * v17 + 60) & 0x40000;
    }
    if (v18) {
      uint64_t v19 = ((__int16)v4 >> 8);
    }
    else {
      uint64_t v19 = 46;
    }
    if ((v4 << 24) <= 0x7F000000)
    {
      int v20 = *(_DWORD *)(v11 + 4 * (char)v4 + 60) & 0x40000;
    }
    else
    {
      int v20 = __maskrune((char)v4, 0x40000uLL);
      int v4 = *((_DWORD *)this + 81);
    }
    uint64_t v9 = 1111970369;
    if (v20) {
      uint64_t v21 = (char)v4;
    }
    else {
      uint64_t v21 = 46;
    }
    _cg_jpeg_mem_term("getPixelFormatForBitDepth", 1243, "*** getPixelFormatForBitDepth - unexpected colorModel: '%c%c%c%c' [0x%08x]- using icSigRgbData with 'BGRA'\n", v13, v16, v19, v21, v4);
    *((_DWORD *)this + 81) = 1380401696;
  }
  return v9;
}

void HEIFReadPlugin::updateCreateImageOptions(HEIFReadPlugin *this, IIODictionary *a2, IIODictionary *a3)
{
  int v6 = *((_DWORD *)this + 53);
  if (*((unsigned __int8 *)this + 216) <= 1u && v6 == 0)
  {
    if (!*((_WORD *)this + 158)) {
      goto LABEL_20;
    }
    unsigned int v10 = IIOImageReadSession::globalInfoForType(*((IIOImageReadSession **)this + 3), 1212500294);
    HEIFMainImageAtIndedouble x = (HEIFMainImage *)GlobalHEIFInfo::getHEIFMainImageAtIndex(v10, *((_DWORD *)this + 126));
    if (*((unsigned char *)this + 340))
    {
      unsigned int v12 = *((_DWORD *)this + 73);
      if (v12)
      {
        unsigned int v13 = *((_DWORD *)this + 74);
      }
      else
      {
        unsigned int v12 = *((_DWORD *)this + 57);
        unsigned int v13 = *((_DWORD *)this + 58);
      }
      if (v12 <= v13) {
        unsigned int v17 = v13;
      }
      else {
        unsigned int v17 = v12;
      }
    }
    else
    {
      unsigned int v14 = HEIFMainImageAtIndex;
      unsigned int v15 = HEIFMainImage::width(HEIFMainImageAtIndex) / *((unsigned __int16 *)this + 158);
      if (v15 <= HEIFMainImage::height(v14) / *((unsigned __int16 *)this + 158)) {
        unsigned int v16 = HEIFMainImage::height(v14);
      }
      else {
        unsigned int v16 = HEIFMainImage::width(v14);
      }
      unsigned int v17 = v16 / *((unsigned __int16 *)this + 158);
    }
    IIONumber::IIONumber((IIONumber *)v22, v17);
    IIODictionary::setObjectForKey((uint64_t)a2, (uint64_t)v22, *(const void **)gIIO_kCMPhotoDecompressionOption_MaxPixelSize);
    IIONumber::~IIONumber((IIONumber *)v22);
    int v18 = *((_DWORD *)this + 121);
    uint64_t v9 = (IIONumber *)v21;
    IIONumber::IIONumber((IIONumber *)v21, v18);
    IIODictionary::setObjectForKey((uint64_t)a2, (uint64_t)v21, *(const void **)gIIO_kCMPhotoDecompressionOption_TiledDownsampling);
  }
  else
  {
    IIONumber::IIONumber((IIONumber *)v24, v6);
    IIODictionary::setObjectForKey((uint64_t)a2, (uint64_t)v24, *(const void **)gIIO_kCMPhotoDecompressionOption_MaxPixelSize);
    IIONumber::~IIONumber((IIONumber *)v24);
    int v8 = *((_DWORD *)this + 121);
    uint64_t v9 = (IIONumber *)v23;
    IIONumber::IIONumber((IIONumber *)v23, v8);
    IIODictionary::setObjectForKey((uint64_t)a2, (uint64_t)v23, *(const void **)gIIO_kCMPhotoDecompressionOption_TiledDownsampling);
  }
  IIONumber::~IIONumber(v9);
LABEL_20:
  BOOL BoolForKey = IIODictionary::getBoolForKey(a3, @"kCGImageSourceCreateThumbnailWithTransform");
  int v20 = (const void **)MEMORY[0x1E4F1CFD0];
  if (!BoolForKey) {
    int v20 = (const void **)MEMORY[0x1E4F1CFC8];
  }
  IIODictionary::setObjectForKey(a2, *v20, *(const __CFString **)gIIO_kCMPhotoDecompressionOption_ApplyTransform);
}

void sub_18860B548(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

char *__IIOInitDebugFlags_block_invoke()
{
  BOOL v0 = getenv("IIO_LogMemoryUsage");
  if (v0) {
    char v1 = atoi(v0);
  }
  else {
    char v1 = 0;
  }
  unint64_t v2 = gIIODebugFlags & 0xFFFFFFFFFFFFFFFCLL | v1 & 3;
  gIIODebugFlags = v2;
  CFTypeID v3 = getenv("IIO_LogDecodingTime");
  if (v3) {
    char v4 = atoi(v3);
  }
  else {
    char v4 = 0;
  }
  unint64_t v5 = v2 & 0xFFFFFFFFFFFFFFF3 | (4 * (v4 & 3));
  gIIODebugFlags = v5;
  int v6 = getenv("IIO_LogMetadataTime");
  if (v6) {
    char v7 = atoi(v6);
  }
  else {
    char v7 = 0;
  }
  unint64_t v8 = v5 & 0xFFFFFFFFFFFFFFCFLL | (16 * (v7 & 3));
  gIIODebugFlags = v8;
  uint64_t v9 = getenv("IIO_LogPurgeability");
  if (v9) {
    char v10 = atoi(v9);
  }
  else {
    char v10 = 0;
  }
  unint64_t v11 = v8 & 0xFFFFFFFFFFFFFF3FLL | ((unint64_t)(v10 & 3) << 6);
  gIIODebugFlags = v11;
  unsigned int v12 = getenv("IIO_LogImageBlocks");
  if (v12) {
    char v13 = atoi(v12);
  }
  else {
    char v13 = 0;
  }
  unint64_t v14 = v11 & 0xFFFFFFFFFFFFF3FFLL | ((unint64_t)(v13 & 3) << 10);
  gIIODebugFlags = v14;
  unsigned int v15 = getenv("IIO_dLogImageIOAPICalls");
  if (v15) {
    char v16 = atoi(v15);
  }
  else {
    char v16 = 0;
  }
  unint64_t v17 = v14 & 0xFFFFFFFFFFFFCFFFLL | ((unint64_t)(v16 & 3) << 12);
  gIIODebugFlags = v17;
  int v18 = getenv("IIO_dLogImageIOSPICalls");
  if (v18) {
    char v19 = atoi(v18);
  }
  else {
    char v19 = 0;
  }
  unint64_t v20 = v17 & 0xFFFFFFFFFFFF3FFFLL | ((unint64_t)(v19 & 3) << 14);
  gIIODebugFlags = v20;
  uint64_t v21 = getenv("IIO_LogPluginInfo");
  if (v21) {
    char v22 = atoi(v21);
  }
  else {
    char v22 = 0;
  }
  unint64_t v23 = v20 & 0xFFFFFFFFFFFCFFFFLL | ((unint64_t)(v22 & 3) << 16);
  gIIODebugFlags = v23;
  uint64_t v24 = getenv("IIO_LogHDR");
  if (v24) {
    char v25 = atoi(v24);
  }
  else {
    char v25 = 0;
  }
  unint64_t v26 = v23 & 0xFFFFFFFFFFCFFFFFLL | ((unint64_t)(v25 & 3) << 20);
  gIIODebugFlags = v26;
  long long v27 = getenv("IIO_LogCacheUsage");
  if (v27) {
    char v28 = atoi(v27);
  }
  else {
    char v28 = 0;
  }
  unint64_t v29 = v26 & 0xFFFFFFFFFFFFFCFFLL | ((unint64_t)(v28 & 3) << 8);
  gIIODebugFlags = v29;
  long long v30 = getenv("IIO_DEBUG_METADATA");
  if (v30) {
    char v31 = atoi(v30);
  }
  else {
    char v31 = 0;
  }
  unint64_t v32 = v29 & 0xFFFFFFFFFEFFFFFFLL | ((unint64_t)(v31 & 1) << 24);
  gIIODebugFlags = v32;
  double v33 = getenv("IMAGEIO_DEBUG_RAW_LOADING");
  if (v33) {
    char v34 = atoi(v33);
  }
  else {
    char v34 = 0;
  }
  unint64_t v35 = v32 & 0xFFFFFFFFFBFFFFFFLL | ((unint64_t)(v34 & 1) << 26);
  gIIODebugFlags = v35;
  uint64_t v36 = getenv("DISABLE_RAW_SUPPORT");
  if (v36) {
    char v37 = atoi(v36);
  }
  else {
    char v37 = 0;
  }
  unint64_t v38 = v35 & 0xFFFFFFFFF7FFFFFFLL | ((unint64_t)(v37 & 1) << 27);
  gIIODebugFlags = v38;
  uint64_t v39 = getenv("IIO_SAVEINPUTDATA");
  if (v39) {
    char v40 = atoi(v39);
  }
  else {
    char v40 = 0;
  }
  unint64_t v41 = v38 & 0xFFFFFFFFEFFFFFFFLL | ((unint64_t)(v40 & 1) << 28);
  gIIODebugFlags = v41;
  double v42 = getenv("IMAGEIO_ENABLE_CACHE");
  unint64_t v43 = v41 & 0xFFFFFFFFDFFFFFFFLL | ((unint64_t)(v42 != 0) << 29);
  gIIODebugFlags = v43;
  if (v42) {
    char v44 = atoi(v42);
  }
  else {
    char v44 = 0;
  }
  unint64_t v45 = v43 & 0xFFFFFFFFBFFFFFFFLL | ((unint64_t)(v44 & 1) << 30);
  gIIODebugFlags = v45;
  int v46 = getenv("IIO_DISABLE_MULTIPLE_RESOLUTIONS");
  if (v46) {
    int v47 = atoi(v46);
  }
  else {
    int v47 = 0;
  }
  unint64_t v48 = (v47 << 31) | v45 & 0xFFFFFFFF7FFFFFFFLL;
  gIIODebugFlags = v48;
  double v49 = getenv("IIO_DisableSubsamplePNG");
  if (v49) {
    char v50 = atoi(v49);
  }
  else {
    char v50 = 0;
  }
  unint64_t v51 = v48 & 0xFFFFFFFEFFFFFFFFLL | ((unint64_t)(v50 & 1) << 32);
  gIIODebugFlags = v51;
  int v52 = getenv("IIO_DisableSubsampleTIFF");
  if (v52) {
    char v53 = atoi(v52);
  }
  else {
    char v53 = 0;
  }
  unint64_t v54 = v51 & 0xFFFFFFFDFFFFFFFFLL | ((unint64_t)(v53 & 1) << 33);
  gIIODebugFlags = v54;
  CFDataRef v55 = getenv("IIO_DebugImageCopy");
  if (v55) {
    char v56 = atoi(v55);
  }
  else {
    char v56 = 0;
  }
  unint64_t v57 = v54 & 0xFFFFFFFBFFFFFFFFLL | ((unint64_t)(v56 & 1) << 34);
  gIIODebugFlags = v57;
  int v58 = getenv("IIO_PreferUnassociatedAlphaTIFF");
  if (v58) {
    char v59 = atoi(v58);
  }
  else {
    char v59 = 0;
  }
  unint64_t v60 = v57 & 0xFFFFFFF7FFFFFFFFLL | ((unint64_t)(v59 & 1) << 35);
  gIIODebugFlags = v60;
  int v61 = getenv("IIO_LogHWUsage");
  if (v61) {
    char v62 = atoi(v61);
  }
  else {
    char v62 = 0;
  }
  unint64_t v63 = v60 & 0xFFFFFFEFFFFFFFFFLL | ((unint64_t)(v62 & 1) << 36);
  gIIODebugFlags = v63;
  int v64 = getenv("IIO_DebugIncrementalLoading");
  if (v64) {
    char v65 = atoi(v64);
  }
  else {
    char v65 = 0;
  }
  unint64_t v66 = v63 & 0xFFFFFFDFFFFFFFFFLL | ((unint64_t)(v65 & 1) << 37);
  gIIODebugFlags = v66;
  uint64_t v67 = getenv("IIO_DebugSurfaceFormat");
  if (v67) {
    char v68 = atoi(v67);
  }
  else {
    char v68 = 0;
  }
  unint64_t v69 = v66 & 0xFFFFFFFFFDFFFFFFLL | ((unint64_t)(v68 & 1) << 25);
  gIIODebugFlags = v69;
  int v70 = getenv("IIO_DisableLowPowerGPU");
  if (v70) {
    char v71 = atoi(v70);
  }
  else {
    char v71 = 1;
  }
  unint64_t v72 = v69 & 0xFFF7FFFFFFFFFFFFLL | ((unint64_t)(v71 & 1) << 51);
  gIIODebugFlags = v72;
  unsigned int v73 = getenv("IIO_DebugMemMapping");
  if (v73) {
    char v74 = atoi(v73);
  }
  else {
    char v74 = 0;
  }
  unint64_t v75 = v72 & 0xFFFFEFFFFFFFFFFFLL | ((unint64_t)(v74 & 1) << 44);
  gIIODebugFlags = v75;
  int v76 = getenv("IIO_DebugFileAccess");
  if (v76) {
    char v77 = atoi(v76);
  }
  else {
    char v77 = 0;
  }
  unint64_t v78 = v75 & 0xFFFFDFFFFFFFFFFFLL | ((unint64_t)(v77 & 1) << 45);
  gIIODebugFlags = v78;
  unsigned int v79 = getenv("IIO_DebugReads");
  if (v79) {
    char v80 = atoi(v79);
  }
  else {
    char v80 = 0;
  }
  unint64_t v81 = v78 & 0xFFFFFFFFFF3FFFFFLL | ((unint64_t)(v80 & 3) << 22);
  gIIODebugFlags = v81;
  uint64_t v82 = getenv("IIO_CreateHash");
  if (v82) {
    unint64_t v83 = (unint64_t)(atoi(v82) & 1) << 38;
  }
  else {
    unint64_t v83 = 0;
  }
  unint64_t v84 = v83 | v81 & 0xFFFFFFBFFFFFFFFFLL;
  gIIODebugFlags = v84;
  __int16 v85 = getenv("IIO_DebugColorHandling");
  if (v85) {
    unint64_t v86 = (unint64_t)(atoi(v85) & 1) << 39;
  }
  else {
    unint64_t v86 = 0;
  }
  unint64_t v87 = v86 | v84 & 0xFFFFFF7FFFFFFFFFLL;
  gIIODebugFlags = v87;
  unsigned int v88 = getenv("IIO_DebugCreateImageConforming");
  if (v88) {
    unint64_t v89 = (unint64_t)(atoi(v88) & 1) << 40;
  }
  else {
    unint64_t v89 = 0;
  }
  unint64_t v90 = v89 | v87 & 0xFFFFFEFFFFFFFFFFLL;
  gIIODebugFlags = v90;
  size_t v91 = getenv("IIO_LogEncodingTime");
  if (v91) {
    unint64_t v92 = (unint64_t)(atoi(v91) & 1) << 41;
  }
  else {
    unint64_t v92 = 0;
  }
  unint64_t v93 = v92 | v90 & 0xFFFFFDFFFFFFFFFFLL;
  gIIODebugFlags = v93;
  size_t v94 = getenv("IIO_DebugAlphaHandling");
  if (v94) {
    unint64_t v95 = (unint64_t)(atoi(v94) & 1) << 42;
  }
  else {
    unint64_t v95 = 0;
  }
  unint64_t v96 = v95 | v93 & 0xFFFFFBFFFFFFFFFFLL;
  gIIODebugFlags = v96;
  int v97 = getenv("IIO_DebugDataHandling");
  if (v97) {
    unint64_t v98 = (unint64_t)(atoi(v97) & 1) << 43;
  }
  else {
    unint64_t v98 = 0;
  }
  unint64_t v99 = v98 | v96 & 0xFFFFF7FFFFFFFFFFLL;
  gIIODebugFlags = v99;
  BOOL v100 = getenv("IIO_DebugBlockSet");
  if (v100) {
    unint64_t v101 = (unint64_t)(atoi(v100) & 1) << 46;
  }
  else {
    unint64_t v101 = 0;
  }
  if ((v101 & 0x400000000000) != 0) {
    unint64_t v102 = v101 | v99 & 0xFFFFBFFFFFFFFFFFLL;
  }
  else {
    unint64_t v102 = v101 & 0xFFFFBFFFFFFFFFFFLL | v99 & 0xFFFFBFFFFFFFFFFFLL;
  }
  gIIODebugFlags = v102;
  uint64_t v103 = getenv("IIO_LogIssues");
  if (v103) {
    unint64_t v104 = (unint64_t)(atoi(v103) & 1) << 47;
  }
  else {
    unint64_t v104 = 0;
  }
  unint64_t v105 = v104 | v102 & 0xFFFF7FFFFFFFFFFFLL;
  gIIODebugFlags = v105;
  uint64_t v106 = getenv("IIO_Animation");
  if (v106) {
    unint64_t v107 = (unint64_t)(atoi(v106) & 1) << 48;
  }
  else {
    unint64_t v107 = 0;
  }
  unint64_t v108 = v107 | v105 & 0xFFFEFFFFFFFFFFFFLL;
  gIIODebugFlags = v108;
  int v109 = getenv("IIO_LogXPC");
  if (v109) {
    uint64_t v110 = (atoi(v109) & 3u) << 18;
  }
  else {
    uint64_t v110 = 0;
  }
  unint64_t v111 = v110 | v108 & 0xFFFFFFFFFFF3FFFFLL;
  gIIODebugFlags = v111;
  __n128 v112 = getenv("IIO_LogEXIFOrientation");
  if (v112) {
    unint64_t v113 = (unint64_t)(atoi(v112) & 1) << 49;
  }
  else {
    unint64_t v113 = 0;
  }
  unint64_t v114 = v113 | v111 & 0xFFFDFFFFFFFFFFFFLL;
  gIIODebugFlags = v114;
  int v115 = getenv("IIO_LogRestrictions");
  if (v115) {
    unint64_t v116 = (unint64_t)(atoi(v115) & 1) << 50;
  }
  else {
    unint64_t v116 = 0;
  }
  gIIODebugFlags = v116 | v114 & 0xFFFBFFFFFFFFFFFFLL;
  BOOL v117 = getenv("IIO_SaveImageBlocks");
  if (v117)
  {
    long long v118 = v117;
    unsigned int __dst = 538976288;
    size_t v119 = strlen(v117);
    if (v119 >= 4) {
      size_t v120 = 4;
    }
    else {
      size_t v120 = v119;
    }
    memcpy(&__dst, v118, v120);
    unsigned int v121 = IIOGetIndexForOSType(bswap32(__dst));
    if (!v121)
    {
      if (!strncmp(v118, "ALL", 3uLL)) {
        unsigned int v121 = 0;
      }
      else {
        unsigned int v121 = -1;
      }
    }
    IIOSetFlagAtIndex(&gDebugBlockType, v121);
  }
  dispatch_queue_t result = getenv("IIO_PluginVerbose");
  if (result)
  {
    unsigned int v123 = result;
    unsigned int v127 = 538976288;
    size_t v124 = strlen(result);
    if (v124 >= 4) {
      size_t v125 = 4;
    }
    else {
      size_t v125 = v124;
    }
    memcpy(&v127, v123, v125);
    unsigned int v126 = IIOGetIndexForOSType(bswap32(v127));
    if (!v126)
    {
      if (!strncmp(v123, "ALL", 3uLL)) {
        unsigned int v126 = 0;
      }
      else {
        unsigned int v126 = -1;
      }
    }
    return (char *)IIOSetFlagAtIndex(&gDebugVerboseType, v126);
  }
  return result;
}

uint64_t ___ZN25IIOImagePixelDataProvider24createEncodingTempBufferEPmS0__block_invoke()
{
  int v5 = 0;
  size_t v3 = 4;
  unint64_t v4 = 0;
  size_t v2 = 8;
  uint64_t result = sysctlbyname("hw.physicalcpu_max", &v5, &v3, 0, 0);
  unint64_t v1 = 0x100000;
  if (!result && v3 == 4)
  {
    uint64_t result = sysctlbyname("hw.l2cachesize", &v4, &v2, 0, 0);
    unint64_t v1 = 0x100000;
    if (!result && v2 == 8) {
      unint64_t v1 = v4 >> 1;
    }
  }
  if (v1 >= 0x100000) {
    unint64_t v1 = 0x100000;
  }
  IIOImagePixelDataProvider::createEncodingTempBuffer(unsigned long *,unsigned long *)::recommendedBufferCFIndex Size = v1;
  return result;
}

CFMutableArrayRef CGImageSourceCopyTypeExtensions(const __CFString *a1)
{
  IIOInitDebugFlags();
  CFTypeID TypeID = (unsigned __int16)gIIODebugFlags >> 14;
  if ((unsigned __int16)gIIODebugFlags >> 14) {
    ImageIODebugOptions(TypeID, "S", "CGImageSourceCopyTypeExtensions", 0, 0, -1, 0);
  }
  if (a1 && (CFTypeID v3 = CFGetTypeID(a1), TypeID = CFStringGetTypeID(), v3 != TypeID))
  {
    LogError("CGImageSourceCopyTypeExtensions", 4370, "*** ERROR: CGImageSourceCopyTypeExtensions: utType is not a CFStringRef\n");
    return 0;
  }
  else
  {
    ReaderHandler = (IIO_ReaderHandler *)IIO_ReaderHandler::GetReaderHandler((IIO_ReaderHandler *)TypeID);
    return IIO_ReaderHandler::copyTypeExtensions(ReaderHandler, a1);
  }
}

uint64_t CGImageSourceEnableRestrictedDecoding()
{
  IIOInitDebugFlags();
  if ((unsigned __int16)gIIODebugFlags >> 14) {
    ImageIODebugOptions((unsigned __int16)gIIODebugFlags >> 14, "S", "CGImageSourceEnableRestrictedDecoding", 0, 0, -1, 0);
  }

  return IIOEnableRestrictedDecoding();
}

uint64_t CGImageSourceDisableHardwareDecoding()
{
  IIOInitDebugFlags();
  if ((unsigned __int16)gIIODebugFlags >> 14) {
    ImageIODebugOptions((unsigned __int16)gIIODebugFlags >> 14, "S", "CGImageSourceDisableHardwareDecoding", 0, 0, -1, 0);
  }

  return IIODisableHardwareDecoding();
}

uint64_t png_handle_bKGD(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v4 = *(_DWORD *)(a1 + 76);
  if ((v4 & 1) == 0) {
    png_chunk_error((void (**)(void))a1, "missing IHDR");
  }
  if ((v4 & 4) == 0)
  {
    int v6 = *(unsigned __int8 *)(a1 + 391);
    if ((v4 & 2) != 0 || v6 != 3)
    {
      if (a2 && (*(unsigned char *)(a2 + 8) & 0x20) != 0)
      {
        png_crc_finish(a1, a3);
        char v7 = "duplicate";
        goto LABEL_6;
      }
      if ((v6 & 2) != 0) {
        int v9 = 6;
      }
      else {
        int v9 = 2;
      }
      if (v6 == 3) {
        int v10 = 1;
      }
      else {
        int v10 = v9;
      }
      if (v10 != a3)
      {
        png_crc_finish(a1, a3);
        char v7 = "invalid";
        goto LABEL_6;
      }
      __int16 v22 = 0;
      int v21 = 0;
      uint64_t v19 = 0;
      __int16 v20 = 0;
      png_crc_read(a1, (Bytef *)&v21, a3);
      uint64_t result = png_crc_finish(a1, 0);
      if (result) {
        return result;
      }
      int v11 = *(unsigned __int8 *)(a1 + 391);
      if (v11 == 3)
      {
        LOBYTE(v19) = v21;
        if (!a2 || !*(_WORD *)(a2 + 32))
        {
          HIWORD(v19) = 0;
          *(_DWORD *)((char *)&v19 + 2) = 0;
LABEL_42:
          __int16 v20 = 0;
          return png_set_bKGD(a1, a2, (uint64_t)&v19);
        }
        if (*(unsigned __int16 *)(a2 + 32) > v21)
        {
          unsigned int v12 = (unsigned __int8 *)(*(void *)(a1 + 368) + 3 * v21);
          WORD1(v19) = *v12;
          WORD2(v19) = v12[1];
          __int16 v13 = v12[2];
LABEL_41:
          HIWORD(v19) = v13;
          goto LABEL_42;
        }
        char v16 = "invalid index";
        return png_chunk_benign_error(a1, v16);
      }
      unsigned int v14 = *(unsigned __int8 *)(a1 + 392);
      if ((v11 & 2) != 0)
      {
        if (v14 >= 9)
        {
          __int16 v18 = BYTE2(v21);
          __int16 v17 = v22;
        }
        else
        {
          if ((_BYTE)v21 || BYTE2(v21) || (__int16 v17 = v22, (_BYTE)v22))
          {
            char v16 = "invalid color";
            return png_chunk_benign_error(a1, v16);
          }
          __int16 v18 = 0;
        }
        LOBYTE(v19) = 0;
        WORD1(v19) = _byteswap_ushort(v21);
        WORD2(v19) = HIBYTE(v21) | (unsigned __int16)(v18 << 8);
        __int16 v13 = HIBYTE(v22) | (unsigned __int16)(v17 << 8);
        goto LABEL_41;
      }
      if (v14 >= 9)
      {
        __int16 v15 = BYTE1(v21);
      }
      else if ((_BYTE)v21 || (__int16 v15 = BYTE1(v21), BYTE1(v21) >> v14))
      {
        char v16 = "invalid gray level";
        return png_chunk_benign_error(a1, v16);
      }
      LOBYTE(v19) = 0;
      __int16 v20 = v15 | (v21 << 8);
      HIWORD(v19) = v20;
      WORD2(v19) = v20;
      WORD1(v19) = v20;
      return png_set_bKGD(a1, a2, (uint64_t)&v19);
    }
  }
  png_crc_finish(a1, a3);
  char v7 = "out of place";
LABEL_6:

  return png_chunk_benign_error(a1, v7);
}

uint64_t png_set_bKGD(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (result && a2)
  {
    if (a3)
    {
      *(void *)(a2 + 202) = *(void *)a3;
      *(_WORD *)(a2 + 210) = *(_WORD *)(a3 + 8);
      *(_DWORD *)(a2 + 8) |= 0x20u;
    }
  }
  return result;
}

uint64_t __IIOEnableRestrictedDecoding_block_invoke(uint64_t result)
{
  uint64_t v1 = result;
  if ((gIIODebugFlags & 0x4000000000000) != 0)
  {
    uint64_t result = IIO_OSAppleInternalBuild();
    if (result) {
      uint64_t result = (uint64_t)ImageIOLog(" CGImageSourceEnableRestrictedDecoding - restricted decoding (no IOSurface,...) is enabled for this process\n");
    }
  }
  gPermissions |= 0x10uLL;
  gPermissionsChanged = 1;
  *(_DWORD *)(*(void *)(*(void *)(v1 + 32) + 8) + 24) = 0;
  return result;
}

uint64_t __IIODisableHardwareDecoding_block_invoke(uint64_t result)
{
  uint64_t v1 = result;
  if ((gIIODebugFlags & 0x4000000000000) != 0)
  {
    uint64_t result = IIO_OSAppleInternalBuild();
    if (result) {
      uint64_t result = (uint64_t)ImageIOLog(" CGImageSourceDisableHardwareDecoding - JPEG/HEIF hardware decoder will no longer be used in this process\n");
    }
  }
  gPermissions &= ~8uLL;
  gPermissionsChanged = 1;
  *(_DWORD *)(*(void *)(*(void *)(v1 + 32) + 8) + 24) = 0;
  return result;
}

CFStringRef CreateIPTCDateStringWithXMPDateTimeString(const __CFString *a1)
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  char v5 = 0;
  *(void *)__str = 0;
  memset(&v3, 0, sizeof(v3));
  int DateTimeStructFromXMPDateTimeString = GetDateTimeStructFromXMPDateTimeString(a1, &v3, 0, 0);
  CFStringRef result = 0;
  if (DateTimeStructFromXMPDateTimeString)
  {
    snprintf(__str, 9uLL, "%04d%02d%02d", v3.tm_year + 1900, v3.tm_mon + 1, v3.tm_mday);
    return CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], __str, 0x600u);
  }
  return result;
}

CFStringRef CreateEXIFDataTimeStringWithXMPDateTimeString(const __CFString *a1)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  *(void *)__str = 0;
  uint64_t v5 = 0;
  int v6 = 0;
  memset(&v3, 0, sizeof(v3));
  int DateTimeStructFromXMPDateTimeString = GetDateTimeStructFromXMPDateTimeString(a1, &v3, 0, 0);
  CFStringRef result = 0;
  if (DateTimeStructFromXMPDateTimeString)
  {
    snprintf(__str, 0x14uLL, "%04d:%02d:%02d %02d:%02d:%02d", v3.tm_year + 1900, v3.tm_mon + 1, v3.tm_mday, v3.tm_hour, v3.tm_min, v3.tm_sec);
    return CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], __str, 0x600u);
  }
  return result;
}

uint64_t GetDateTimeStructFromXMPDateTimeString(const __CFString *cf, tm *a2, BOOL *a3, BOOL *a4)
{
  uint64_t v4 = (uint64_t)a2;
  uint64_t v27 = 0;
  long long v25 = 0u;
  long long v26 = 0u;
  long long v24 = 0u;
  uint64_t v23 = 0;
  long long v21 = 0u;
  long long v22 = 0u;
  long long v20 = 0u;
  if (a2)
  {
    a2->tm_zone = 0;
    *(_OWORD *)&a2->tm_mon = 0uLL;
    *(_OWORD *)&a2->tm_isdst = 0uLL;
    *(_OWORD *)&a2->tm_sec = 0uLL;
    if (!cf) {
      return 0;
    }
    CFTypeID v8 = CFGetTypeID(cf);
    if (v8 != CFStringGetTypeID()) {
      return 0;
    }
    CFIndex Length = CFStringGetLength(cf);
    int v9 = (char *)malloc_type_malloc(Length + 1, 0x314760DBuLL);
    if (!v9) {
      return 0;
    }
    int v10 = v9;
    double v19 = 0.0;
    if (!CFStringGetCString(cf, v9, Length + 1, 0x600u)) {
      goto LABEL_69;
    }
    tzset();
    if (a3) {
      *a3 = 0;
    }
    if (a4) {
      *a4 = 0;
    }
    if (sscanf(v10, "%04d-%02d-%02dT%02d:%02d:%lf+%02d:%02d", (char *)&v25 + 4, &v25, (unint64_t)&v24 | 0xC, (char *)&v24 + 8, (char *)&v24 + 4, &v19, (char *)&v20 + 8, (char *)&v20 + 4) == 8|| sscanf(v10, "%04d%02d%02dT%02d%02d%lf+%02d%02d", (char *)&v25 + 4, &v25, (unint64_t)&v24 | 0xC, (char *)&v24 + 8, (char *)&v24 + 4, &v19,
           (char *)&v20 + 8,
           (char *)&v20 + 4) == 8)
    {
      LODWORD(v24) = (int)v19;
LABEL_13:
      *(int32x2_t *)&long long v25 = vadd_s32(*(int32x2_t *)&v25, (int32x2_t)0xFFFFF894FFFFFFFFLL);
      uint64_t v11 = 3600 * SDWORD2(v20) + 60 * SDWORD1(v20);
      goto LABEL_18;
    }
    if (sscanf(v10, "%04d-%02d-%02dT%02d:%02d:%lf-%02d:%02d", (char *)&v25 + 4, &v25, (unint64_t)&v24 | 0xC, (char *)&v24 + 8, (char *)&v24 + 4, &v19, (char *)&v20 + 8, (char *)&v20 + 4) == 8|| sscanf(v10, "%04d%02d%02dT%02d%02d%lf-%02d%02d", (char *)&v25 + 4, &v25, (unint64_t)&v24 | 0xC, (char *)&v24 + 8, (char *)&v24 + 4, &v19,
           (char *)&v20 + 8,
           (char *)&v20 + 4) == 8)
    {
      LODWORD(v24) = (int)v19;
      goto LABEL_17;
    }
    if (sscanf(v10, "%04d-%02d-%02dT%02d:%02d:%lfZ", (char *)&v25 + 4, &v25, (unint64_t)&v24 | 0xC, (char *)&v24 + 8, (char *)&v24 + 4, &v19) == 6)
    {
      LODWORD(v24) = (int)v19;
      *(int32x2_t *)&long long v25 = vadd_s32(*(int32x2_t *)&v25, (int32x2_t)0xFFFFF894FFFFFFFFLL);
      *((void *)&v26 + 1) = 0;
      if (a3) {
        *a3 = 1;
      }
      unsigned int v12 = a4;
      if (!a4) {
        goto LABEL_22;
      }
      __int16 v15 = &v10[Length];
      goto LABEL_35;
    }
    if (sscanf(v10, "%04d%02d%02dT%02d%02d%lfZ", (char *)&v25 + 4, &v25, (unint64_t)&v24 | 0xC, (char *)&v24 + 8, (char *)&v24 + 4, &v19) == 6)
    {
      LODWORD(v24) = (int)v19;
      *(int32x2_t *)&long long v25 = vadd_s32(*(int32x2_t *)&v25, (int32x2_t)0xFFFFF894FFFFFFFFLL);
      *((void *)&v26 + 1) = 0;
      if (a3) {
        *a3 = 1;
      }
      unsigned int v12 = a4;
      if (!a4) {
        goto LABEL_22;
      }
      __int16 v15 = &v10[Length];
LABEL_35:
      int v16 = *(v15 - 1);
      goto LABEL_36;
    }
    if (Length > 18)
    {
      if (Length == 19)
      {
        if (sscanf(v10, "%04d:%02d:%02d %02d:%02d:%02d", (char *)&v25 + 4, &v25, (unint64_t)&v24 | 0xC, (char *)&v24 + 8, (char *)&v24 + 4, &v24) == 6)
        {
          *(int32x2_t *)&long long v25 = vadd_s32(*(int32x2_t *)&v25, (int32x2_t)0xFFFFF894FFFFFFFFLL);
          goto LABEL_56;
        }
      }
      else if (Length == 22)
      {
        if (sscanf(v10, "%04d-%02d-%02dT%02d:%02d+%02d:%02d", (char *)&v25 + 4, &v25, (unint64_t)&v24 | 0xC, (char *)&v24 + 8, (char *)&v24 + 4, (char *)&v20 + 8, (char *)&v20 + 4) == 7)goto LABEL_13; {
        if (sscanf(v10, "%04d-%02d-%02dT%02d:%02d-%02d:%02d", (char *)&v25 + 4, &v25, (unint64_t)&v24 | 0xC, (char *)&v24 + 8, (char *)&v24 + 4, (char *)&v20 + 8, (char *)&v20 + 4) == 7)
        }
        {
LABEL_17:
          *(int32x2_t *)&long long v25 = vadd_s32(*(int32x2_t *)&v25, (int32x2_t)0xFFFFF894FFFFFFFFLL);
          uint64_t v11 = -3600 * DWORD2(v20) - 60 * DWORD1(v20);
LABEL_18:
          *((void *)&v26 + 1) = v11;
          if (a3) {
            *a3 = 1;
          }
          unsigned int v12 = a4;
          if (!a4) {
            goto LABEL_22;
          }
LABEL_21:
          *unsigned int v12 = 1;
LABEL_22:
          long long v13 = v25;
          *(_OWORD *)uint64_t v4 = v24;
          *(_OWORD *)(v4 + 16) = v13;
          *(_OWORD *)(v4 + 32) = v26;
          *(void *)(v4 + 48) = v27;
          uint64_t v4 = 1;
LABEL_23:
          free(v10);
          return v4;
        }
      }
    }
    else
    {
      if (Length == 10)
      {
        if (sscanf(v10, "%04d-%02d-%02d", (char *)&v25 + 4, &v25, (unint64_t)&v24 | 0xC) == 3)
        {
LABEL_63:
          *(int32x2_t *)&long long v25 = vadd_s32(*(int32x2_t *)&v25, (int32x2_t)0xFFFFF894FFFFFFFFLL);
          goto LABEL_22;
        }
        if (sscanf(v10, "%02d:%02d:%02d", (char *)&v24 + 8, (char *)&v24 + 4, &v24) == 3) {
          goto LABEL_56;
        }
        int v17 = sscanf(v10, "%04d:%02d:%02d");
        goto LABEL_62;
      }
      if (Length == 17
        && sscanf(v10, "%04d-%02d-%02dT%02d:%02dZ", (char *)&v25 + 4, &v25, (unint64_t)&v24 | 0xC, (char *)&v24 + 8, (char *)&v24 + 4) == 5)
      {
        *(int32x2_t *)&long long v25 = vadd_s32(*(int32x2_t *)&v25, (int32x2_t)0xFFFFF894FFFFFFFFLL);
        *((void *)&v26 + 1) = 0;
        if (a3) {
          *a3 = 1;
        }
        unsigned int v12 = a4;
        int v16 = v10[16];
LABEL_36:
        if (v16 != 90) {
          goto LABEL_22;
        }
        goto LABEL_21;
      }
    }
    if (sscanf(v10, "%02d:%02d:%02d", (char *)&v24 + 8, (char *)&v24 + 4, &v24) == 3)
    {
LABEL_56:
      unsigned int v12 = a3;
      if (!a3) {
        goto LABEL_22;
      }
      goto LABEL_21;
    }
    if (Length == 4)
    {
      if (sscanf(v10, "%04d", (char *)&v25 + 4) == 1)
      {
        DWORD1(v25) -= 1900;
        HIDWORD(v24) = 1;
        goto LABEL_22;
      }
      goto LABEL_69;
    }
    if (Length == 7)
    {
      if (sscanf(v10, "%04d-%02d", (char *)&v25 + 4, &v25) == 2)
      {
        *(int32x2_t *)&long long v25 = vadd_s32(*(int32x2_t *)&v25, (int32x2_t)0xFFFFF894FFFFFFFFLL);
        HIDWORD(v24) = 1;
        goto LABEL_22;
      }
      goto LABEL_69;
    }
    if (Length != 8) {
      goto LABEL_69;
    }
    int v17 = sscanf(v10, "%04d%02d%02d");
LABEL_62:
    if (v17 == 3) {
      goto LABEL_63;
    }
LABEL_69:
    uint64_t v4 = 0;
    goto LABEL_23;
  }
  return v4;
}

uint64_t IIOEnableRestrictedDecoding()
{
  kdebug_trace();
  uint64_t v3 = 0;
  uint64_t v4 = &v3;
  uint64_t v5 = 0x2000000000;
  int v6 = -50;
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 0x40000000;
  block[2] = __IIOEnableRestrictedDecoding_block_invoke;
  block[3] = &unk_1E53C7228;
  block[4] = &v3;
  if (IIOEnableRestrictedDecoding::onceToken != -1) {
    dispatch_once(&IIOEnableRestrictedDecoding::onceToken, block);
  }
  uint64_t v0 = *((unsigned int *)v4 + 6);
  _Block_object_dispose(&v3, 8);
  return v0;
}

uint64_t IIODisableHardwareDecoding()
{
  kdebug_trace();
  uint64_t v3 = 0;
  uint64_t v4 = &v3;
  uint64_t v5 = 0x2000000000;
  int v6 = -50;
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 0x40000000;
  block[2] = __IIODisableHardwareDecoding_block_invoke;
  block[3] = &unk_1E53C7200;
  block[4] = &v3;
  if (IIODisableHardwareDecoding::onceToken != -1) {
    dispatch_once(&IIODisableHardwareDecoding::onceToken, block);
  }
  uint64_t v0 = *((unsigned int *)v4 + 6);
  _Block_object_dispose(&v3, 8);
  return v0;
}

const char *___ZL23IIOLoadCoreMediaSymbolsv_block_invoke()
{
  uint64_t v0 = dlopen("/System/Library/Frameworks/CoreMedia.framework/CoreMedia", 261);
  IIOLoadCoreMediaSymbols(void)::lib = (uint64_t)v0;
  if (v0)
  {
    gFunc_CMBufferQueueCreate = dlsym(v0, "CMBufferQueueCreate");
    if (!gFunc_CMBufferQueueCreate)
    {
      uint64_t v1 = dlerror();
      printf("  failed to load 'CMBufferQueueCreate' [%s]\n", v1);
    }
    gFunc_CMBufferQueueDequeueAndRetain = (uint64_t (*)(void))dlsym((void *)IIOLoadCoreMediaSymbols(void)::lib, "CMBufferQueueDequeueAndRetain");
    if (!gFunc_CMBufferQueueDequeueAndRetain)
    {
      size_t v2 = dlerror();
      printf("  failed to load 'CMBufferQueueDequeueAndRetain' [%s]\n", v2);
    }
    gFunc_CMBufferQueueEnqueue = (uint64_t (*)(void))dlsym((void *)IIOLoadCoreMediaSymbols(void)::lib, "CMBufferQueueEnqueue");
    if (!gFunc_CMBufferQueueEnqueue)
    {
      uint64_t v3 = dlerror();
      printf("  failed to load 'CMBufferQueueEnqueue' [%s]\n", v3);
    }
    gFunc_CMBufferQueueGetBufferunsigned int Count = dlsym((void *)IIOLoadCoreMediaSymbols(void)::lib, "CMBufferQueueGetBufferCount");
    if (!gFunc_CMBufferQueueGetBufferCount)
    {
      uint64_t v4 = dlerror();
      printf("  failed to load 'CMBufferQueueGetBufferCount' [%s]\n", v4);
    }
    gFunc_CMBufferQueueGetHead = dlsym((void *)IIOLoadCoreMediaSymbols(void)::lib, "CMBufferQueueGetHead");
    if (!gFunc_CMBufferQueueGetHead)
    {
      uint64_t v5 = dlerror();
      printf("  failed to load 'CMBufferQueueGetHead' [%s]\n", v5);
    }
    gFunc_CMBufferQueueInstallTriggerWithIntegerThreshold = dlsym((void *)IIOLoadCoreMediaSymbols(void)::lib, "CMBufferQueueInstallTriggerWithIntegerThreshold");
    if (!gFunc_CMBufferQueueInstallTriggerWithIntegerThreshold)
    {
      int v6 = dlerror();
      printf("  failed to load 'CMBufferQueueInstallTriggerWithIntegerThreshold' [%s]\n", v6);
    }
    gFunc_CMBufferQueueIsAtEndOfunint64_t Data = (uint64_t (*)(void))dlsym((void *)IIOLoadCoreMediaSymbols(void)::lib, "CMBufferQueueIsAtEndOfData");
    if (!gFunc_CMBufferQueueIsAtEndOfData)
    {
      uint64_t v7 = dlerror();
      printf("  failed to load 'CMBufferQueueIsAtEndOfData' [%s]\n", v7);
    }
    gFunc_CMBufferQueueIsEmptdouble y = (uint64_t (*)(void))dlsym((void *)IIOLoadCoreMediaSymbols(void)::lib, "CMBufferQueueIsEmpty");
    if (!gFunc_CMBufferQueueIsEmpty)
    {
      CFTypeID v8 = dlerror();
      printf("  failed to load 'CMBufferQueueIsEmpty' [%s]\n", v8);
    }
    gFunc_CMBufferQueueMarkEndOfunint64_t Data = dlsym((void *)IIOLoadCoreMediaSymbols(void)::lib, "CMBufferQueueMarkEndOfData");
    if (!gFunc_CMBufferQueueMarkEndOfData)
    {
      int v9 = dlerror();
      printf("  failed to load 'CMBufferQueueMarkEndOfData' [%s]\n", v9);
    }
    gFunc_CMBufferQueueReset = (uint64_t (*)(void))dlsym((void *)IIOLoadCoreMediaSymbols(void)::lib, "CMBufferQueueReset");
    if (!gFunc_CMBufferQueueReset)
    {
      int v10 = dlerror();
      printf("  failed to load 'CMBufferQueueReset' [%s]\n", v10);
    }
    gFunc_CMClockGetHostTimeClocCFIndex k = dlsym((void *)IIOLoadCoreMediaSymbols(void)::lib, "CMClockGetHostTimeClock");
    if (!gFunc_CMClockGetHostTimeClock)
    {
      uint64_t v11 = dlerror();
      printf("  failed to load 'CMClockGetHostTimeClock' [%s]\n", v11);
    }
    gFunc_CMTimeAdd = dlsym((void *)IIOLoadCoreMediaSymbols(void)::lib, "CMTimeAdd");
    if (!gFunc_CMTimeAdd)
    {
      unsigned int v12 = dlerror();
      printf("  failed to load 'CMTimeAdd' [%s]\n", v12);
    }
    gFunc_CMTimeMake = dlsym((void *)IIOLoadCoreMediaSymbols(void)::lib, "CMTimeMake");
    if (!gFunc_CMTimeMake)
    {
      long long v13 = dlerror();
      printf("  failed to load 'CMTimeMake' [%s]\n", v13);
    }
    gFunc_CMTimeMakeWithSeconds = dlsym((void *)IIOLoadCoreMediaSymbols(void)::lib, "CMTimeMakeWithSeconds");
    if (!gFunc_CMTimeMakeWithSeconds)
    {
      unsigned int v14 = dlerror();
      printf("  failed to load 'CMTimeMakeWithSeconds' [%s]\n", v14);
    }
    gFunc_CMTimeMakeFromDictionardouble y = (void *(*)(void *__return_ptr, void))dlsym((void *)IIOLoadCoreMediaSymbols(void)::lib, "CMTimeMakeFromDictionary");
    if (!gFunc_CMTimeMakeFromDictionary)
    {
      __int16 v15 = dlerror();
      printf("  failed to load 'CMTimeMakeFromDictionary' [%s]\n", v15);
    }
    gFunc_CMTimeCopyAsDictionardouble y = (uint64_t)dlsym((void *)IIOLoadCoreMediaSymbols(void)::lib, "CMTimeCopyAsDictionary");
    if (!gFunc_CMTimeCopyAsDictionary)
    {
      int v16 = dlerror();
      printf("  failed to load 'CMTimeCopyAsDictionary' [%s]\n", v16);
    }
    gFunc_CMTimeGetSeconds = (double (*)(void))dlsym((void *)IIOLoadCoreMediaSymbols(void)::lib, "CMTimeGetSeconds");
    if (!gFunc_CMTimeGetSeconds)
    {
      int v17 = dlerror();
      printf("  failed to load 'CMTimeGetSeconds' [%s]\n", v17);
    }
    gFunc_CMTimebaseAddTimerDispatchuint64_t Source = dlsym((void *)IIOLoadCoreMediaSymbols(void)::lib, "CMTimebaseAddTimerDispatchSource");
    if (!gFunc_CMTimebaseAddTimerDispatchSource)
    {
      __int16 v18 = dlerror();
      printf("  failed to load 'CMTimebaseAddTimerDispatchSource' [%s]\n", v18);
    }
    gFunc_CMTimebaseCreateWithSourceClocCFIndex k = dlsym((void *)IIOLoadCoreMediaSymbols(void)::lib, "CMTimebaseCreateWithSourceClock");
    if (!gFunc_CMTimebaseCreateWithSourceClock)
    {
      double v19 = dlerror();
      printf("  failed to load 'CMTimebaseCreateWithSourceClock' [%s]\n", v19);
    }
    gFunc_CMTimebaseGetTime = dlsym((void *)IIOLoadCoreMediaSymbols(void)::lib, "CMTimebaseGetTime");
    if (!gFunc_CMTimebaseGetTime)
    {
      long long v20 = dlerror();
      printf("  failed to load 'CMTimebaseGetTime' [%s]\n", v20);
    }
    gFunc_CMTimebaseSetRate = dlsym((void *)IIOLoadCoreMediaSymbols(void)::lib, "CMTimebaseSetRate");
    if (!gFunc_CMTimebaseSetRate)
    {
      long long v21 = dlerror();
      printf("  failed to load 'CMTimebaseSetRate' [%s]\n", v21);
    }
    CFStringRef result = (const char *)dlsym((void *)IIOLoadCoreMediaSymbols(void)::lib, "CMTimebaseSetTimerDispatchSourceNextFireTime");
    gFunc_CMTimebaseSetTimerDispatchSourceNextFireTime = result;
    if (!result)
    {
      uint64_t v23 = dlerror();
      return (const char *)printf("  failed to load 'CMTimebaseSetTimerDispatchSourceNextFireTime' [%s]\n", v23);
    }
  }
  else
  {
    long long v24 = dlerror();
    return LogError("IIOLoadCoreMediaSymbols_block_invoke", 833, "  Failed to load %s  [%s]\n", "/System/Library/Frameworks/CoreMedia.framework/CoreMedia", v24);
  }
  return result;
}

uint64_t IIOLoadCMPhotoSymbols(void)
{
  uint64_t v210 = *MEMORY[0x1E4F143B8];
  strcpy(__path, "/System/Library/PrivateFrameworks/CMPhoto.framework/CMPhoto");
  uint64_t v0 = dlopen(__path, 257);
  if (v0)
  {
    uint64_t v1 = v0;
    gFunc_CMPhotoCompressionCreateContainerFromImageExt = (uint64_t)dlsym(v0, "CMPhotoCompressionCreateContainerFromImageExt");
    if (gFunc_CMPhotoCompressionCreateContainerFromImageExt)
    {
      int v2 = 0;
    }
    else
    {
      uint64_t v4 = dlerror();
      printf("  failed to load 'CMPhotoCompressionCreateContainerFromImageExt' [%s]\n", v4);
      int v2 = 1;
    }
    gFunc_CMPhotoCompressionCreateDataContainerFromuint64_t Image = dlsym(v1, "CMPhotoCompressionCreateDataContainerFromImage");
    if (!gFunc_CMPhotoCompressionCreateDataContainerFromImage)
    {
      uint64_t v5 = dlerror();
      printf("  failed to load 'CMPhotoCompressionCreateDataContainerFromImage' [%s]\n", v5);
      ++v2;
    }
    gFunc_CMPhotoCompressionSessionAddAuxiliaryuint64_t Image = dlsym(v1, "CMPhotoCompressionSessionAddAuxiliaryImage");
    if (!gFunc_CMPhotoCompressionSessionAddAuxiliaryImage)
    {
      int v6 = dlerror();
      printf("  failed to load 'CMPhotoCompressionSessionAddAuxiliaryImage' [%s]\n", v6);
      ++v2;
    }
    gFunc_CMPhotoCompressionSessionAddAuxiliaryImageFromDictionaryRepresentation = (uint64_t)dlsym(v1, "CMPhotoCompressionSessionAddAuxiliaryImageFromDictionaryRepresentation");
    if (!gFunc_CMPhotoCompressionSessionAddAuxiliaryImageFromDictionaryRepresentation)
    {
      uint64_t v7 = dlerror();
      printf("  failed to load 'CMPhotoCompressionSessionAddAuxiliaryImageFromDictionaryRepresentation' [%s]\n", v7);
      ++v2;
    }
    gFunc_CMPhotoCompressionSessionAddCustomMetaCFDataRef data = dlsym(v1, "CMPhotoCompressionSessionAddCustomMetadata");
    if (!gFunc_CMPhotoCompressionSessionAddCustomMetadata)
    {
      CFTypeID v8 = dlerror();
      printf("  failed to load 'CMPhotoCompressionSessionAddCustomMetadata' [%s]\n", v8);
      ++v2;
    }
    gFunc_CMPhotoCompressionSessionAddExif = dlsym(v1, "CMPhotoCompressionSessionAddExif");
    if (!gFunc_CMPhotoCompressionSessionAddExif)
    {
      int v9 = dlerror();
      printf("  failed to load 'CMPhotoCompressionSessionAddExif' [%s]\n", v9);
      ++v2;
    }
    gFunc_CMPhotoCompressionSessionAddGroup = dlsym(v1, "CMPhotoCompressionSessionAddGroup");
    if (!gFunc_CMPhotoCompressionSessionAddGroup)
    {
      int v10 = dlerror();
      printf("  failed to load 'CMPhotoCompressionSessionAddGroup' [%s]\n", v10);
      ++v2;
    }
    gFunc_CMPhotoCompressionSessionAddGroupunint64_t Properties = dlsym(v1, "CMPhotoCompressionSessionAddGroupProperties");
    if (!gFunc_CMPhotoCompressionSessionAddGroupProperties)
    {
      uint64_t v11 = dlerror();
      printf("  failed to load 'CMPhotoCompressionSessionAddGroupProperties' [%s]\n", v11);
      ++v2;
    }
    gFunc_CMPhotoImageHasOpaqueAlphaFromPixelunint64_t Data = dlsym(v1, "CMPhotoImageHasOpaqueAlphaFromPixelData");
    if (!gFunc_CMPhotoImageHasOpaqueAlphaFromPixelData)
    {
      unsigned int v12 = dlerror();
      printf("  failed to load 'CMPhotoImageHasOpaqueAlphaFromPixelData' [%s]\n", v12);
      ++v2;
    }
    gFunc_CMPhotoCompressionSessionAdduint64_t Image = dlsym(v1, "CMPhotoCompressionSessionAddImage");
    if (!gFunc_CMPhotoCompressionSessionAddImage)
    {
      long long v13 = dlerror();
      printf("  failed to load 'CMPhotoCompressionSessionAddImage' [%s]\n", v13);
      ++v2;
    }
    gFunc_CMPhotoCompressionSessionAddImageHandleToGroup = (uint64_t (*)(void, void, void, void))dlsym(v1, "CMPhotoCompressionSessionAddImageHandleToGroup");
    if (!gFunc_CMPhotoCompressionSessionAddImageHandleToGroup)
    {
      unsigned int v14 = dlerror();
      printf("  failed to load 'CMPhotoCompressionSessionAddImageHandleToGroup' [%s]\n", v14);
      ++v2;
    }
    gFunc_CMPhotoCompressionSessionAddImageToSequence = dlsym(v1, "CMPhotoCompressionSessionAddImageToSequence");
    if (!gFunc_CMPhotoCompressionSessionAddImageToSequence)
    {
      __int16 v15 = dlerror();
      printf("  failed to load 'CMPhotoCompressionSessionAddImageToSequence' [%s]\n", v15);
      ++v2;
    }
    gFunc_CMPhotoCompressionSessionAddTmapImageOneShot = dlsym(v1, "CMPhotoCompressionSessionAddTmapImageOneShot");
    if (!gFunc_CMPhotoCompressionSessionAddTmapImageOneShot)
    {
      int v16 = dlerror();
      printf("  failed to load 'CMPhotoCompressionSessionAddTmapImageOneShot' [%s]\n", v16);
      ++v2;
    }
    gFunc_CMPhotoCompressionSessionAddThumbnail = dlsym(v1, "CMPhotoCompressionSessionAddThumbnail");
    if (!gFunc_CMPhotoCompressionSessionAddThumbnail)
    {
      int v17 = dlerror();
      printf("  failed to load 'CMPhotoCompressionSessionAddThumbnail' [%s]\n", v17);
      ++v2;
    }
    gFunc_CMPhotoCompressionSessionAddXMP = dlsym(v1, "CMPhotoCompressionSessionAddXMP");
    if (!gFunc_CMPhotoCompressionSessionAddXMP)
    {
      __int16 v18 = dlerror();
      printf("  failed to load 'CMPhotoCompressionSessionAddXMP' [%s]\n", v18);
      ++v2;
    }
    gFunc_CMPhotoCompressionSessionCloseContainer = (uint64_t)dlsym(v1, "CMPhotoCompressionSessionCloseContainer");
    if (!gFunc_CMPhotoCompressionSessionCloseContainer)
    {
      double v19 = dlerror();
      printf("  failed to load 'CMPhotoCompressionSessionCloseContainer' [%s]\n", v19);
      ++v2;
    }
    gFunc_CMPhotoCompressionSessionCloseContainerAndCopyBacking = dlsym(v1, "CMPhotoCompressionSessionCloseContainerAndCopyBacking");
    if (!gFunc_CMPhotoCompressionSessionCloseContainerAndCopyBacking)
    {
      long long v20 = dlerror();
      printf("  failed to load 'CMPhotoCompressionSessionCloseContainerAndCopyBacking' [%s]\n", v20);
      ++v2;
    }
    gFunc_CMPhotoCompressionSessionCreate = dlsym(v1, "CMPhotoCompressionSessionCreate");
    if (!gFunc_CMPhotoCompressionSessionCreate)
    {
      long long v21 = dlerror();
      printf("  failed to load 'CMPhotoCompressionSessionCreate' [%s]\n", v21);
      ++v2;
    }
    gFunc_CMPhotoCompressionSessionEndImageSequence = dlsym(v1, "CMPhotoCompressionSessionEndImageSequence");
    if (!gFunc_CMPhotoCompressionSessionEndImageSequence)
    {
      long long v22 = dlerror();
      printf("  failed to load 'CMPhotoCompressionSessionEndImageSequence' [%s]\n", v22);
      ++v2;
    }
    gFunc_CMPhotoCompressionSessionInvalidate = dlsym(v1, "CMPhotoCompressionSessionInvalidate");
    if (!gFunc_CMPhotoCompressionSessionInvalidate)
    {
      uint64_t v23 = dlerror();
      printf("  failed to load 'CMPhotoCompressionSessionInvalidate' [%s]\n", v23);
      ++v2;
    }
    gFunc_CMPhotoCompressionSessionOpenEmptyContainer = dlsym(v1, "CMPhotoCompressionSessionOpenEmptyContainer");
    if (!gFunc_CMPhotoCompressionSessionOpenEmptyContainer)
    {
      long long v24 = dlerror();
      printf("  failed to load 'CMPhotoCompressionSessionOpenEmptyContainer' [%s]\n", v24);
      ++v2;
    }
    gFunc_CMPhotoCompressionSessionOpenExistingContainerForModification = dlsym(v1, "CMPhotoCompressionSessionOpenExistingContainerForModification");
    if (!gFunc_CMPhotoCompressionSessionOpenExistingContainerForModification)
    {
      long long v25 = dlerror();
      printf("  failed to load 'CMPhotoCompressionSessionOpenExistingContainerForModification' [%s]\n", v25);
      ++v2;
    }
    gFunc_CMPhotoCompressionSessionReleaseHardwareResources = dlsym(v1, "CMPhotoCompressionSessionReleaseHardwareResources");
    if (!gFunc_CMPhotoCompressionSessionReleaseHardwareResources)
    {
      long long v26 = dlerror();
      printf("  failed to load 'CMPhotoCompressionSessionReleaseHardwareResources' [%s]\n", v26);
      ++v2;
    }
    gFunc_CMPhotoCompressionSessionStartImageSequence = dlsym(v1, "CMPhotoCompressionSessionStartImageSequence");
    if (!gFunc_CMPhotoCompressionSessionStartImageSequence)
    {
      uint64_t v27 = dlerror();
      printf("  failed to load 'CMPhotoCompressionSessionStartImageSequence' [%s]\n", v27);
      ++v2;
    }
    gFunc_CMPhotoCompressionSupportedForContainerAndCodec = (uint64_t (*)(void, void, void, void))dlsym(v1, "CMPhotoCompressionSupportedForContainerAndCodec");
    if (!gFunc_CMPhotoCompressionSupportedForContainerAndCodec)
    {
      char v28 = dlerror();
      printf("  failed to load 'CMPhotoCompressionSupportedForContainerAndCodec' [%s]\n", v28);
      ++v2;
    }
    gFunc_CMPhotoDecompressionContainerCopyAuxiliaryImageCGColorSpaceForIndexWithuint64_t Options = (uint64_t)dlsym(v1, "CMPhotoDecompressionContainerCopyAuxiliaryImageCGColorSpaceForIndexWithOptions");
    if (!gFunc_CMPhotoDecompressionContainerCopyAuxiliaryImageCGColorSpaceForIndexWithOptions)
    {
      unint64_t v29 = dlerror();
      printf("  failed to load 'CMPhotoDecompressionContainerCopyAuxiliaryImageCGColorSpaceForIndexWithOptions' [%s]\n", v29);
      ++v2;
    }
    gFunc_CMPhotoDecompressionContainerCopyCustomMetadataForIndexWithuint64_t Options = dlsym(v1, "CMPhotoDecompressionContainerCopyCustomMetadataForIndexWithOptions");
    if (!gFunc_CMPhotoDecompressionContainerCopyCustomMetadataForIndexWithOptions)
    {
      long long v30 = dlerror();
      printf("  failed to load 'CMPhotoDecompressionContainerCopyCustomMetadataForIndexWithOptions' [%s]\n", v30);
      ++v2;
    }
    gFunc_CMPhotoDecompressionContainerCopyDebugMetadataForIndexWithuint64_t Options = (uint64_t)dlsym(v1, "CMPhotoDecompressionContainerCopyDebugMetadataForIndexWithOptions");
    if (!gFunc_CMPhotoDecompressionContainerCopyDebugMetadataForIndexWithOptions)
    {
      char v31 = dlerror();
      printf("  failed to load 'CMPhotoDecompressionContainerCopyDebugMetadataForIndexWithOptions' [%s]\n", v31);
      ++v2;
    }
    gFunc_CMPhotoDecompressionContainerCopyExifForIndexWithuint64_t Options = dlsym(v1, "CMPhotoDecompressionContainerCopyExifForIndexWithOptions");
    if (!gFunc_CMPhotoDecompressionContainerCopyExifForIndexWithOptions)
    {
      unint64_t v32 = dlerror();
      printf("  failed to load 'CMPhotoDecompressionContainerCopyExifForIndexWithOptions' [%s]\n", v32);
      ++v2;
    }
    gFunc_CMPhotoDecompressionContainerCopyFormatDescriptionForIndexWithuint64_t Options = (uint64_t)dlsym(v1, "CMPhotoDecompressionContainerCopyFormatDescriptionForIndexWithOptions");
    if (!gFunc_CMPhotoDecompressionContainerCopyFormatDescriptionForIndexWithOptions)
    {
      double v33 = dlerror();
      printf("  failed to load 'CMPhotoDecompressionContainerCopyFormatDescriptionForIndexWithOptions' [%s]\n", v33);
      ++v2;
    }
    gFunc_CMPhotoDecompressionContainerCopyGroupsDescriptionArradouble y = (uint64_t (*)(void, void))dlsym(v1, "CMPhotoDecompressionContainerCopyGroupsDescriptionArray");
    if (!gFunc_CMPhotoDecompressionContainerCopyGroupsDescriptionArray)
    {
      char v34 = dlerror();
      printf("  failed to load 'CMPhotoDecompressionContainerCopyGroupsDescriptionArray' [%s]\n", v34);
      ++v2;
    }
    gFunc_CMPhotoDecompressionContainerCopyHEIFItemPropertiesForIndexWithuint64_t Options = (uint64_t (*)(void, void, void, void))dlsym(v1, "CMPhotoDecompressionContainerCopyHEIFItemPropertiesForIndexWithOptions");
    if (!gFunc_CMPhotoDecompressionContainerCopyHEIFItemPropertiesForIndexWithOptions)
    {
      unint64_t v35 = dlerror();
      printf("  failed to load 'CMPhotoDecompressionContainerCopyHEIFItemPropertiesForIndexWithOptions' [%s]\n", v35);
      ++v2;
    }
    gFunc_CMPhotoDecompressionContainerCopyImageBitDepthForIndexWithuint64_t Options = (uint64_t (*)(void, void, void, void))dlsym(v1, "CMPhotoDecompressionContainerCopyImageBitDepthForIndexWithOptions");
    if (!gFunc_CMPhotoDecompressionContainerCopyImageBitDepthForIndexWithOptions)
    {
      uint64_t v36 = dlerror();
      printf("  failed to load 'CMPhotoDecompressionContainerCopyImageBitDepthForIndexWithOptions' [%s]\n", v36);
      ++v2;
    }
    gFunc_CMPhotoDecompressionContainerCopyImagePropertiesForIndexWithuint64_t Options = (uint64_t)dlsym(v1, "CMPhotoDecompressionContainerCopyImagePropertiesForIndexWithOptions");
    if (!gFunc_CMPhotoDecompressionContainerCopyImagePropertiesForIndexWithOptions)
    {
      char v37 = dlerror();
      printf("  failed to load 'CMPhotoDecompressionContainerCopyImagePropertiesForIndexWithOptions' [%s]\n", v37);
      ++v2;
    }
    gFunc_CMPhotoDecompressionContainerCopyStereoMetadataForIndedouble x = (uint64_t)dlsym(v1, "CMPhotoDecompressionContainerCopyStereoMetadataForIndex");
    if (!gFunc_CMPhotoDecompressionContainerCopyStereoMetadataForIndex)
    {
      unint64_t v38 = dlerror();
      printf("  failed to load 'CMPhotoDecompressionContainerCopyStereoMetadataForIndex' [%s]\n", v38);
      ++v2;
    }
    gFunc_CMPhotoDecompressionContainerCopyXMPForIndexWithuint64_t Options = dlsym(v1, "CMPhotoDecompressionContainerCopyXMPForIndexWithOptions");
    if (!gFunc_CMPhotoDecompressionContainerCopyXMPForIndexWithOptions)
    {
      uint64_t v39 = dlerror();
      printf("  failed to load 'CMPhotoDecompressionContainerCopyXMPForIndexWithOptions' [%s]\n", v39);
      ++v2;
    }
    gFunc_CMPhotoDecompressionContainerCreateAuxiliaryImageDictionaryRepresentation = dlsym(v1, "CMPhotoDecompressionContainerCreateAuxiliaryImageDictionaryRepresentation");
    if (!gFunc_CMPhotoDecompressionContainerCreateAuxiliaryImageDictionaryRepresentation)
    {
      char v40 = dlerror();
      printf("  failed to load 'CMPhotoDecompressionContainerCreateAuxiliaryImageDictionaryRepresentation' [%s]\n", v40);
      ++v2;
    }
    gFunc_CMPhotoDecompressionContainerCreateAuxiliaryImageForIndedouble x = (uint64_t (*)(void, void, void, void, void, void))dlsym(v1, "CMPhotoDecompressionContainerCreateAuxiliaryImageForIndex");
    if (!gFunc_CMPhotoDecompressionContainerCreateAuxiliaryImageForIndex)
    {
      unint64_t v41 = dlerror();
      printf("  failed to load 'CMPhotoDecompressionContainerCreateAuxiliaryImageForIndex' [%s]\n", v41);
      ++v2;
    }
    gFunc_CMPhotoDecompressionContainerCopyAuxiliaryImageMetadataForIndexWithuint64_t Options = (uint64_t (*)(void, void, void, void, void))dlsym(v1, "CMPhotoDecompressionContainerCopyAuxiliaryImageMetadataForIndexWithOptions");
    if (!gFunc_CMPhotoDecompressionContainerCopyAuxiliaryImageMetadataForIndexWithOptions)
    {
      double v42 = dlerror();
      printf("  failed to load 'CMPhotoDecompressionContainerCopyAuxiliaryImageMetadataForIndexWithOptions' [%s]\n", v42);
      ++v2;
    }
    gFunc_CMPhotoDecompressionContainerFindFirstAuxiliaryOfTypeForIndexWithuint64_t Options = dlsym(v1, "CMPhotoDecompressionContainerFindFirstAuxiliaryOfTypeForIndexWithOptions");
    if (!gFunc_CMPhotoDecompressionContainerFindFirstAuxiliaryOfTypeForIndexWithOptions)
    {
      unint64_t v43 = dlerror();
      printf("  failed to load 'CMPhotoDecompressionContainerFindFirstAuxiliaryOfTypeForIndexWithOptions' [%s]\n", v43);
      ++v2;
    }
    gFunc_CMPhotoDecompressionContainerCreateDictionaryDescription = (uint64_t (*)(void, void))dlsym(v1, "CMPhotoDecompressionContainerCreateDictionaryDescription");
    if (!gFunc_CMPhotoDecompressionContainerCreateDictionaryDescription)
    {
      char v44 = dlerror();
      printf("  failed to load 'CMPhotoDecompressionContainerCreateDictionaryDescription' [%s]\n", v44);
      ++v2;
    }
    gFunc_CMPhotoDecompressionContainerCreateImageForIndedouble x = (uint64_t (*)(void, void, void, void, void))dlsym(v1, "CMPhotoDecompressionContainerCreateImageForIndex");
    if (!gFunc_CMPhotoDecompressionContainerCreateImageForIndex)
    {
      unint64_t v45 = dlerror();
      printf("  failed to load 'CMPhotoDecompressionContainerCreateImageForIndex' [%s]\n", v45);
      ++v2;
    }
    gFunc_CMPhotoDecompressionContainerCreateOutputBufferAttributesForImageIndedouble x = (uint64_t (*)(void, void, void, void))dlsym(v1, "CMPhotoDecompressionContainerCreateOutputBufferAttributesForImageIndex");
    if (!gFunc_CMPhotoDecompressionContainerCreateOutputBufferAttributesForImageIndex)
    {
      int v46 = dlerror();
      printf("  failed to load 'CMPhotoDecompressionContainerCreateOutputBufferAttributesForImageIndex' [%s]\n", v46);
      ++v2;
    }
    gFunc_CMPhotoDecompressionContainerCreateSequenceContainer = (uint64_t (*)(void, void, void, void))dlsym(v1, "CMPhotoDecompressionContainerCreateSequenceContainer");
    if (!gFunc_CMPhotoDecompressionContainerCreateSequenceContainer)
    {
      int v47 = dlerror();
      printf("  failed to load 'CMPhotoDecompressionContainerCreateSequenceContainer' [%s]\n", v47);
      ++v2;
    }
    gFunc_CMPhotoDecompressionContainerCreateThumbnailImageForIndedouble x = (uint64_t (*)(void, void, void, void, void, void))dlsym(v1, "CMPhotoDecompressionContainerCreateThumbnailImageForIndex");
    if (!gFunc_CMPhotoDecompressionContainerCreateThumbnailImageForIndex)
    {
      unint64_t v48 = dlerror();
      printf("  failed to load 'CMPhotoDecompressionContainerCreateThumbnailImageForIndex' [%s]\n", v48);
      ++v2;
    }
    gFunc_CMPhotoDecompressionContainerGetAuxiliaryImageCountForIndexWithuint64_t Options = (uint64_t)dlsym(v1, "CMPhotoDecompressionContainerGetAuxiliaryImageCountForIndexWithOptions");
    if (!gFunc_CMPhotoDecompressionContainerGetAuxiliaryImageCountForIndexWithOptions)
    {
      double v49 = dlerror();
      printf("  failed to load 'CMPhotoDecompressionContainerGetAuxiliaryImageCountForIndexWithOptions' [%s]\n", v49);
      ++v2;
    }
    gFunc_CMPhotoDecompressionContainerGetAuxiliaryImageTypeForIndexWithuint64_t Options = (uint64_t)dlsym(v1, "CMPhotoDecompressionContainerGetAuxiliaryImageTypeForIndexWithOptions");
    if (!gFunc_CMPhotoDecompressionContainerGetAuxiliaryImageTypeForIndexWithOptions)
    {
      char v50 = dlerror();
      printf("  failed to load 'CMPhotoDecompressionContainerGetAuxiliaryImageTypeForIndexWithOptions' [%s]\n", v50);
      ++v2;
    }
    gFunc_CMPhotoDecompressionContainerGetCustomMetadataCountForIndexWithuint64_t Options = (uint64_t)dlsym(v1, "CMPhotoDecompressionContainerGetCustomMetadataCountForIndexWithOptions");
    if (!gFunc_CMPhotoDecompressionContainerGetCustomMetadataCountForIndexWithOptions)
    {
      unint64_t v51 = dlerror();
      printf("  failed to load 'CMPhotoDecompressionContainerGetCustomMetadataCountForIndexWithOptions' [%s]\n", v51);
      ++v2;
    }
    gFunc_CMPhotoDecompressionContainerGetDebugMetadataCountForIndexWithuint64_t Options = (uint64_t)dlsym(v1, "CMPhotoDecompressionContainerGetDebugMetadataCountForIndexWithOptions");
    if (!gFunc_CMPhotoDecompressionContainerGetDebugMetadataCountForIndexWithOptions)
    {
      int v52 = dlerror();
      printf("  failed to load 'CMPhotoDecompressionContainerGetDebugMetadataCountForIndexWithOptions' [%s]\n", v52);
      ++v2;
    }
    gFunc_CMPhotoDecompressionContainerGetExifCountForIndexWithuint64_t Options = (uint64_t (*)(void, void, void, void))dlsym(v1, "CMPhotoDecompressionContainerGetExifCountForIndexWithOptions");
    if (!gFunc_CMPhotoDecompressionContainerGetExifCountForIndexWithOptions)
    {
      char v53 = dlerror();
      printf("  failed to load 'CMPhotoDecompressionContainerGetExifCountForIndexWithOptions' [%s]\n", v53);
      ++v2;
    }
    gFunc_CMPhotoDecompressionContainerGetImageCountWithuint64_t Options = (uint64_t)dlsym(v1, "CMPhotoDecompressionContainerGetImageCountWithOptions");
    if (!gFunc_CMPhotoDecompressionContainerGetImageCountWithOptions)
    {
      unint64_t v54 = dlerror();
      printf("  failed to load 'CMPhotoDecompressionContainerGetImageCountWithOptions' [%s]\n", v54);
      ++v2;
    }
    gFunc_CMPhotoDecompressionContainerGetImageGeometryForIndexWithuint64_t Options = (uint64_t (*)(void, void, void, void, void, void))dlsym(v1, "CMPhotoDecompressionContainerGetImageGeometryForIndexWithOptions");
    if (!gFunc_CMPhotoDecompressionContainerGetImageGeometryForIndexWithOptions)
    {
      CFDataRef v55 = dlerror();
      printf("  failed to load 'CMPhotoDecompressionContainerGetImageGeometryForIndexWithOptions' [%s]\n", v55);
      ++v2;
    }
    gFunc_CMPhotoDecompressionContainerGetSequenceunsigned int Count = (uint64_t (*)(void, void))dlsym(v1, "CMPhotoDecompressionContainerGetSequenceCount");
    if (!gFunc_CMPhotoDecompressionContainerGetSequenceCount)
    {
      char v56 = dlerror();
      printf("  failed to load 'CMPhotoDecompressionContainerGetSequenceCount' [%s]\n", v56);
      ++v2;
    }
    gFunc_CMPhotoDecompressionContainerGetThumbnailCountForIndexWithuint64_t Options = (uint64_t)dlsym(v1, "CMPhotoDecompressionContainerGetThumbnailCountForIndexWithOptions");
    if (!gFunc_CMPhotoDecompressionContainerGetThumbnailCountForIndexWithOptions)
    {
      unint64_t v57 = dlerror();
      printf("  failed to load 'CMPhotoDecompressionContainerGetThumbnailCountForIndexWithOptions' [%s]\n", v57);
      ++v2;
    }
    gFunc_CMPhotoDecompressionContainerGetThumbnailGeometryForIndexWithuint64_t Options = (uint64_t)dlsym(v1, "CMPhotoDecompressionContainerGetThumbnailGeometryForIndexWithOptions");
    if (!gFunc_CMPhotoDecompressionContainerGetThumbnailGeometryForIndexWithOptions)
    {
      int v58 = dlerror();
      printf("  failed to load 'CMPhotoDecompressionContainerGetThumbnailGeometryForIndexWithOptions' [%s]\n", v58);
      ++v2;
    }
    gFunc_CMPhotoDecompressionContainerGetXMPCountForIndexWithuint64_t Options = (uint64_t (*)(void, void, void, void))dlsym(v1, "CMPhotoDecompressionContainerGetXMPCountForIndexWithOptions");
    if (!gFunc_CMPhotoDecompressionContainerGetXMPCountForIndexWithOptions)
    {
      char v59 = dlerror();
      printf("  failed to load 'CMPhotoDecompressionContainerGetXMPCountForIndexWithOptions' [%s]\n", v59);
      ++v2;
    }
    gFunc_CMPhotoDecompressionContainerJFIFTranscode = dlsym(v1, "CMPhotoDecompressionContainerJFIFTranscode");
    if (!gFunc_CMPhotoDecompressionContainerJFIFTranscode)
    {
      unint64_t v60 = dlerror();
      printf("  failed to load 'CMPhotoDecompressionContainerJFIFTranscode' [%s]\n", v60);
      ++v2;
    }
    gFunc_CMPhotoDecompressionDetectContainerFormat = (uint64_t)dlsym(v1, "CMPhotoDecompressionDetectContainerFormat");
    if (!gFunc_CMPhotoDecompressionDetectContainerFormat)
    {
      int v61 = dlerror();
      printf("  failed to load 'CMPhotoDecompressionDetectContainerFormat' [%s]\n", v61);
      ++v2;
    }
    gFunc_CMPhotoDecompressionDetectContainerFormatAndCodec = (uint64_t)dlsym(v1, "CMPhotoDecompressionDetectContainerFormatAndCodec");
    if (!gFunc_CMPhotoDecompressionDetectContainerFormatAndCodec)
    {
      char v62 = dlerror();
      printf("  failed to load 'CMPhotoDecompressionDetectContainerFormatAndCodec' [%s]\n", v62);
      ++v2;
    }
    gFunc_CMPhotoDecompressionSessionCreate = (uint64_t (*)(void, void, void))dlsym(v1, "CMPhotoDecompressionSessionCreate");
    if (!gFunc_CMPhotoDecompressionSessionCreate)
    {
      unint64_t v63 = dlerror();
      printf("  failed to load 'CMPhotoDecompressionSessionCreate' [%s]\n", v63);
      ++v2;
    }
    gFunc_CMPhotoDecompressionSessionCreateContainer = (uint64_t (*)(void, void, void, void, void))dlsym(v1, "CMPhotoDecompressionSessionCreateContainer");
    if (!gFunc_CMPhotoDecompressionSessionCreateContainer)
    {
      int v64 = dlerror();
      printf("  failed to load 'CMPhotoDecompressionSessionCreateContainer' [%s]\n", v64);
      ++v2;
    }
    gFunc_CMPhotoDecompressionSessionFlushCachedBuffers = (uint64_t (*)(void, void, void, __n128))dlsym(v1, "CMPhotoDecompressionSessionFlushCachedBuffers");
    if (!gFunc_CMPhotoDecompressionSessionFlushCachedBuffers)
    {
      char v65 = dlerror();
      printf("  failed to load 'CMPhotoDecompressionSessionFlushCachedBuffers' [%s]\n", v65);
      ++v2;
    }
    gFunc_CMPhotoDecompressionSessionReleaseHardwareResources = (uint64_t)dlsym(v1, "CMPhotoDecompressionSessionReleaseHardwareResources");
    if (!gFunc_CMPhotoDecompressionSessionReleaseHardwareResources)
    {
      unint64_t v66 = dlerror();
      printf("  failed to load 'CMPhotoDecompressionSessionReleaseHardwareResources' [%s]\n", v66);
      ++v2;
    }
    gFunc_CMPhotoDecompressionSupportedForContainerAndCodec = (uint64_t (*)(void, void, void, void))dlsym(v1, "CMPhotoDecompressionSupportedForContainerAndCodec");
    if (!gFunc_CMPhotoDecompressionSupportedForContainerAndCodec)
    {
      uint64_t v67 = dlerror();
      printf("  failed to load 'CMPhotoDecompressionSupportedForContainerAndCodec' [%s]\n", v67);
      ++v2;
    }
    gFunc_CMPhotoDecompressionSessionDetachSurface = (uint64_t (*)(void, void, __n128))dlsym(v1, "CMPhotoDecompressionSessionDetachSurface");
    if (!gFunc_CMPhotoDecompressionSessionDetachSurface)
    {
      char v68 = dlerror();
      printf("  failed to load 'CMPhotoDecompressionSessionDetachSurface' [%s]\n", v68);
      ++v2;
    }
    gFunc_CMPhotoGetAPIVersion = (uint64_t (*)(void))dlsym(v1, "CMPhotoGetAPIVersion");
    if (!gFunc_CMPhotoGetAPIVersion)
    {
      unint64_t v69 = dlerror();
      printf("  failed to load 'CMPhotoGetAPIVersion' [%s]\n", v69);
      ++v2;
    }
    gFunc_CMPhotoJPEGCreateJPEGFromIOSurface = (uint64_t)dlsym(v1, "CMPhotoJPEGCreateJPEGFromIOSurface");
    if (!gFunc_CMPhotoJPEGCreateJPEGFromIOSurface)
    {
      int v70 = dlerror();
      printf("  failed to load 'CMPhotoJPEGCreateJPEGFromIOSurface' [%s]\n", v70);
      ++v2;
    }
    gFunc_CMPhotoDetermineMIAFCompliantThumbnailMaxPixelCFIndex Size = dlsym(v1, "CMPhotoDetermineMIAFCompliantThumbnailMaxPixelSize");
    if (!gFunc_CMPhotoDetermineMIAFCompliantThumbnailMaxPixelSize)
    {
      char v71 = dlerror();
      printf("  failed to load 'CMPhotoDetermineMIAFCompliantThumbnailMaxPixelSize' [%s]\n", v71);
      ++v2;
    }
    gIIO_kCMPhotoCompressionContainerDescription_EXIFMetaCFDataRef data = (uint64_t)dlsym(v1, "kCMPhotoCompressionContainerDescription_EXIFMetadata");
    if (!gIIO_kCMPhotoCompressionContainerDescription_EXIFMetadata)
    {
      unint64_t v72 = dlerror();
      printf("  failed to load 'kCMPhotoCompressionContainerDescription_EXIFMetadata' [%s]\n", v72);
      ++v2;
    }
    gIIO_kCMPhotoCompressionContainerDescription_Extrinsics_Position = (uint64_t)dlsym(v1, "kCMPhotoCompressionContainerDescription_Extrinsics_Position");
    if (!gIIO_kCMPhotoCompressionContainerDescription_Extrinsics_Position)
    {
      unsigned int v73 = dlerror();
      printf("  failed to load 'kCMPhotoCompressionContainerDescription_Extrinsics_Position' [%s]\n", v73);
      ++v2;
    }
    gIIO_kCMPhotoCompressionContainerDescription_GroupProperty_DisparityAdjustment = (uint64_t)dlsym(v1, "kCMPhotoCompressionContainerDescription_GroupProperty_DisparityAdjustment");
    if (!gIIO_kCMPhotoCompressionContainerDescription_GroupProperty_DisparityAdjustment)
    {
      char v74 = dlerror();
      printf("  failed to load 'kCMPhotoCompressionContainerDescription_GroupProperty_DisparityAdjustment' [%s]\n", v74);
      ++v2;
    }
    gIIO_kCMPhotoCompressionContainerDescription_GroupProperty_StereoAggressors = (uint64_t)dlsym(v1, "kCMPhotoCompressionContainerDescription_GroupProperty_StereoAggressors");
    if (!gIIO_kCMPhotoCompressionContainerDescription_GroupProperty_StereoAggressors)
    {
      unint64_t v75 = dlerror();
      printf("  failed to load 'kCMPhotoCompressionContainerDescription_GroupProperty_StereoAggressors' [%s]\n", v75);
      ++v2;
    }
    gIIO_kCMPhotoCompressionContainerDescription_GroupProperty_MonoImageLocation = (uint64_t)dlsym(v1, "kCMPhotoCompressionContainerDescription_GroupProperty_MonoImageLocation");
    if (!gIIO_kCMPhotoCompressionContainerDescription_GroupProperty_MonoImageLocation)
    {
      int v76 = dlerror();
      printf("  failed to load 'kCMPhotoCompressionContainerDescription_GroupProperty_MonoImageLocation' [%s]\n", v76);
      ++v2;
    }
    gIIO_kCMPhotoCompressionContainerDescription_Intrinsics = (uint64_t)dlsym(v1, "kCMPhotoCompressionContainerDescription_Intrinsics");
    if (!gIIO_kCMPhotoCompressionContainerDescription_Intrinsics)
    {
      char v77 = dlerror();
      printf("  failed to load 'kCMPhotoCompressionContainerDescription_Intrinsics' [%s]\n", v77);
      ++v2;
    }
    gIIO_kCMPhotoCompressionContainerDescription_Orientation = (uint64_t)dlsym(v1, "kCMPhotoCompressionContainerDescription_Orientation");
    if (!gIIO_kCMPhotoCompressionContainerDescription_Orientation)
    {
      unint64_t v78 = dlerror();
      printf("  failed to load 'kCMPhotoCompressionContainerDescription_Orientation' [%s]\n", v78);
      ++v2;
    }
    gIIO_kCMPhotoCompressionContainerDescription_XMPMetaCFDataRef data = (uint64_t)dlsym(v1, "kCMPhotoCompressionContainerDescription_XMPMetadata");
    if (!gIIO_kCMPhotoCompressionContainerDescription_XMPMetadata)
    {
      unsigned int v79 = dlerror();
      printf("  failed to load 'kCMPhotoCompressionContainerDescription_XMPMetadata' [%s]\n", v79);
      ++v2;
    }
    gIIO_kCMPhotoCompressionContainerOption_Backingunsigned int Type = (uint64_t)dlsym(v1, "kCMPhotoCompressionContainerOption_BackingType");
    if (!gIIO_kCMPhotoCompressionContainerOption_BackingType)
    {
      char v80 = dlerror();
      printf("  failed to load 'kCMPhotoCompressionContainerOption_BackingType' [%s]\n", v80);
      ++v2;
    }
    gIIO_kCMPhotoCompressionContainerOption_Format = (uint64_t)dlsym(v1, "kCMPhotoCompressionContainerOption_Format");
    if (!gIIO_kCMPhotoCompressionContainerOption_Format)
    {
      unint64_t v81 = dlerror();
      printf("  failed to load 'kCMPhotoCompressionContainerOption_Format' [%s]\n", v81);
      ++v2;
    }
    gIIO_kCMPhotoCompressionContainerOption_StripExistingMetaCFDataRef data = (uint64_t)dlsym(v1, "kCMPhotoCompressionContainerOption_StripExistingMetadata");
    if (!gIIO_kCMPhotoCompressionContainerOption_StripExistingMetadata)
    {
      uint64_t v82 = dlerror();
      printf("  failed to load 'kCMPhotoCompressionContainerOption_StripExistingMetadata' [%s]\n", v82);
      ++v2;
    }
    gIIO_kCMPhotoCompressionOption_ApplyTransforCFIndex m = (uint64_t)dlsym(v1, "kCMPhotoCompressionOption_ApplyTransform");
    if (!gIIO_kCMPhotoCompressionOption_ApplyTransform)
    {
      unint64_t v83 = dlerror();
      printf("  failed to load 'kCMPhotoCompressionOption_ApplyTransform' [%s]\n", v83);
      ++v2;
    }
    gIIO_kCMPhotoCompressionOption_BitDepth = (uint64_t)dlsym(v1, "kCMPhotoCompressionOption_BitDepth");
    if (!gIIO_kCMPhotoCompressionOption_BitDepth)
    {
      unint64_t v84 = dlerror();
      printf("  failed to load 'kCMPhotoCompressionOption_BitDepth' [%s]\n", v84);
      ++v2;
    }
    gIIO_kCMPhotoCompressionOption_Codecunsigned int Type = (uint64_t)dlsym(v1, "kCMPhotoCompressionOption_CodecType");
    if (!gIIO_kCMPhotoCompressionOption_CodecType)
    {
      __int16 v85 = dlerror();
      printf("  failed to load 'kCMPhotoCompressionOption_CodecType' [%s]\n", v85);
      ++v2;
    }
    gIIO_kCMPhotoCompressionOption_ColorSpace = (uint64_t)dlsym(v1, "kCMPhotoCompressionOption_ColorSpace");
    if (!gIIO_kCMPhotoCompressionOption_ColorSpace)
    {
      unint64_t v86 = dlerror();
      printf("  failed to load 'kCMPhotoCompressionOption_ColorSpace' [%s]\n", v86);
      ++v2;
    }
    gIIO_kCMPhotoCompressionOption_EnableSoftwareHEVCEncoder = (uint64_t)dlsym(v1, "kCMPhotoCompressionOption_EnableSoftwareHEVCEncoder");
    if (!gIIO_kCMPhotoCompressionOption_EnableSoftwareHEVCEncoder)
    {
      unint64_t v87 = dlerror();
      printf("  failed to load 'kCMPhotoCompressionOption_EnableSoftwareHEVCEncoder' [%s]\n", v87);
      ++v2;
    }
    gIIO_kCMPhotoCompressionOption_ForceHighSpeed = (uint64_t)dlsym(v1, "kCMPhotoCompressionOption_ForceHighSpeed");
    if (!gIIO_kCMPhotoCompressionOption_ForceHighSpeed)
    {
      unsigned int v88 = dlerror();
      printf("  failed to load 'kCMPhotoCompressionOption_ForceHighSpeed' [%s]\n", v88);
      ++v2;
    }
    gIIO_kCMPhotoCompressionOption_ImageOrientation = (uint64_t)dlsym(v1, "kCMPhotoCompressionOption_ImageOrientation");
    if (!gIIO_kCMPhotoCompressionOption_ImageOrientation)
    {
      unint64_t v89 = dlerror();
      printf("  failed to load 'kCMPhotoCompressionOption_ImageOrientation' [%s]\n", v89);
      ++v2;
    }
    gIIO_kCMPhotoCompressionOption_IntrinsicsMatridouble x = (uint64_t)dlsym(v1, "kCMPhotoCompressionOption_IntrinsicsMatrix");
    if (!gIIO_kCMPhotoCompressionOption_IntrinsicsMatrix)
    {
      unint64_t v90 = dlerror();
      printf("  failed to load 'kCMPhotoCompressionOption_IntrinsicsMatrix' [%s]\n", v90);
      ++v2;
    }
    gIIO_kCMPhotoCompressionOption_MaxPixelCFIndex Size = (uint64_t)dlsym(v1, "kCMPhotoCompressionOption_MaxPixelSize");
    if (!gIIO_kCMPhotoCompressionOption_MaxPixelSize)
    {
      size_t v91 = dlerror();
      printf("  failed to load 'kCMPhotoCompressionOption_MaxPixelSize' [%s]\n", v91);
      ++v2;
    }
    gIIO_kCMPhotoCompressionOption_PreferSoftwareCodec = (uint64_t)dlsym(v1, "kCMPhotoCompressionOption_PreferSoftwareCodec");
    if (!gIIO_kCMPhotoCompressionOption_PreferSoftwareCodec)
    {
      unint64_t v92 = dlerror();
      printf("  failed to load 'kCMPhotoCompressionOption_PreferSoftwareCodec' [%s]\n", v92);
      ++v2;
    }
    gIIO_kCMPhotoCompressionOption_Primaryuint64_t Image = (uint64_t)dlsym(v1, "kCMPhotoCompressionOption_PrimaryImage");
    if (!gIIO_kCMPhotoCompressionOption_PrimaryImage)
    {
      unint64_t v93 = dlerror();
      printf("  failed to load 'kCMPhotoCompressionOption_PrimaryImage' [%s]\n", v93);
      ++v2;
    }
    gIIO_kCMPhotoCompressionOption_QualityControllerParameters = (uint64_t)dlsym(v1, "kCMPhotoCompressionOption_QualityControllerParameters");
    if (!gIIO_kCMPhotoCompressionOption_QualityControllerParameters)
    {
      size_t v94 = dlerror();
      printf("  failed to load 'kCMPhotoCompressionOption_QualityControllerParameters' [%s]\n", v94);
      ++v2;
    }
    gIIO_kCMPhotoCompressionOption_QualityControllerunsigned int Type = (uint64_t)dlsym(v1, "kCMPhotoCompressionOption_QualityControllerType");
    if (!gIIO_kCMPhotoCompressionOption_QualityControllerType)
    {
      unint64_t v95 = dlerror();
      printf("  failed to load 'kCMPhotoCompressionOption_QualityControllerType' [%s]\n", v95);
      ++v2;
    }
    gIIO_kCMPhotoCompressionOption_RequireHardwareCodec = (uint64_t)dlsym(v1, "kCMPhotoCompressionOption_RequireHardwareCodec");
    if (!gIIO_kCMPhotoCompressionOption_RequireHardwareCodec)
    {
      unint64_t v96 = dlerror();
      printf("  failed to load 'kCMPhotoCompressionOption_RequireHardwareCodec' [%s]\n", v96);
      ++v2;
    }
    gIIO_kCMPhotoCompressionOption_RGBToYUVDithering = (uint64_t)dlsym(v1, "kCMPhotoCompressionOption_RGBToYUVDithering");
    if (!gIIO_kCMPhotoCompressionOption_RGBToYUVDithering)
    {
      int v97 = dlerror();
      printf("  failed to load 'kCMPhotoCompressionOption_RGBToYUVDithering' [%s]\n", v97);
      ++v2;
    }
    gIIO_kCMPhotoCompressionOption_Subsampling = (uint64_t)dlsym(v1, "kCMPhotoCompressionOption_Subsampling");
    if (!gIIO_kCMPhotoCompressionOption_Subsampling)
    {
      unint64_t v98 = dlerror();
      printf("  failed to load 'kCMPhotoCompressionOption_Subsampling' [%s]\n", v98);
      ++v2;
    }
    gIIO_kCMPhotoCompressionOption_Tiling = (uint64_t)dlsym(v1, "kCMPhotoCompressionOption_Tiling");
    if (!gIIO_kCMPhotoCompressionOption_Tiling)
    {
      unint64_t v99 = dlerror();
      printf("  failed to load 'kCMPhotoCompressionOption_Tiling' [%s]\n", v99);
      ++v2;
    }
    gIIO_kCMPhotoCompressionOption_UseVTCompression = (uint64_t)dlsym(v1, "kCMPhotoCompressionOption_UseVTCompression");
    if (!gIIO_kCMPhotoCompressionOption_UseVTCompression)
    {
      BOOL v100 = dlerror();
      printf("  failed to load 'kCMPhotoCompressionOption_UseVTCompression' [%s]\n", v100);
      ++v2;
    }
    gIIO_kCMPhotoCompressionSessionOption_UseCodecSessionPool = (uint64_t)dlsym(v1, "kCMPhotoCompressionSessionOption_UseCodecSessionPool");
    if (!gIIO_kCMPhotoCompressionSessionOption_UseCodecSessionPool)
    {
      unint64_t v101 = dlerror();
      printf("  failed to load 'kCMPhotoCompressionSessionOption_UseCodecSessionPool' [%s]\n", v101);
      ++v2;
    }
    gIIO_kCMPhotoCustomMetadata_unint64_t Data = (uint64_t)dlsym(v1, "kCMPhotoCustomMetadata_Data");
    if (!gIIO_kCMPhotoCustomMetadata_Data)
    {
      unint64_t v102 = dlerror();
      printf("  failed to load 'kCMPhotoCustomMetadata_Data' [%s]\n", v102);
      ++v2;
    }
    gIIO_kCMPhotoCustomMetadata_CFStringRef Name = (uint64_t)dlsym(v1, "kCMPhotoCustomMetadata_Name");
    if (!gIIO_kCMPhotoCustomMetadata_Name)
    {
      uint64_t v103 = dlerror();
      printf("  failed to load 'kCMPhotoCustomMetadata_Name' [%s]\n", v103);
      ++v2;
    }
    gIIO_kCMPhotoCustomMetadata_URI = (uint64_t)dlsym(v1, "kCMPhotoCustomMetadata_URI");
    if (!gIIO_kCMPhotoCustomMetadata_URI)
    {
      unint64_t v104 = dlerror();
      printf("  failed to load 'kCMPhotoCustomMetadata_URI' [%s]\n", v104);
      ++v2;
    }
    gIIO_kCMPhotoDecompressionContainerDescription_AlphaPremultiplication = (uint64_t)dlsym(v1, "kCMPhotoDecompressionContainerDescription_AlphaPremultiplication");
    if (!gIIO_kCMPhotoDecompressionContainerDescription_AlphaPremultiplication)
    {
      unint64_t v105 = dlerror();
      printf("  failed to load 'kCMPhotoDecompressionContainerDescription_AlphaPremultiplication' [%s]\n", v105);
      ++v2;
    }
    gIIO_kCMPhotoDecompressionContainerDescription_AlternateImages = (uint64_t)dlsym(v1, "kCMPhotoDecompressionContainerDescription_AlternateImages");
    if (!gIIO_kCMPhotoDecompressionContainerDescription_AlternateImages)
    {
      uint64_t v106 = dlerror();
      printf("  failed to load 'kCMPhotoDecompressionContainerDescription_AlternateImages' [%s]\n", v106);
      ++v2;
    }
    gIIO_kCMPhotoDecompressionContainerDescription_AudioTrackunsigned int Count = (uint64_t)dlsym(v1, "kCMPhotoDecompressionContainerDescription_AudioTrackCount");
    if (!gIIO_kCMPhotoDecompressionContainerDescription_AudioTrackCount)
    {
      unint64_t v107 = dlerror();
      printf("  failed to load 'kCMPhotoDecompressionContainerDescription_AudioTrackCount' [%s]\n", v107);
      ++v2;
    }
    gIIO_kCMPhotoDecompressionContainerDescription_AuxiliaryImageunsigned int Count = (uint64_t)dlsym(v1, "kCMPhotoDecompressionContainerDescription_AuxiliaryImageCount");
    if (!gIIO_kCMPhotoDecompressionContainerDescription_AuxiliaryImageCount)
    {
      unint64_t v108 = dlerror();
      printf("  failed to load 'kCMPhotoDecompressionContainerDescription_AuxiliaryImageCount' [%s]\n", v108);
      ++v2;
    }
    gIIO_kCMPhotoDecompressionContainerDescription_AuxiliaryImages = (uint64_t)dlsym(v1, "kCMPhotoDecompressionContainerDescription_AuxiliaryImages");
    if (!gIIO_kCMPhotoDecompressionContainerDescription_AuxiliaryImages)
    {
      int v109 = dlerror();
      printf("  failed to load 'kCMPhotoDecompressionContainerDescription_AuxiliaryImages' [%s]\n", v109);
      ++v2;
    }
    gIIO_kCMPhotoDecompressionContainerDescription_AuxiliaryNativesigned int PixelFormat = (uint64_t)dlsym(v1, "kCMPhotoDecompressionContainerDescription_AuxiliaryNativePixelFormat");
    if (!gIIO_kCMPhotoDecompressionContainerDescription_AuxiliaryNativePixelFormat)
    {
      uint64_t v110 = dlerror();
      printf("  failed to load 'kCMPhotoDecompressionContainerDescription_AuxiliaryNativePixelFormat' [%s]\n", v110);
      ++v2;
    }
    gIIO_kCMPhotoDecompressionContainerDescription_Auxiliaryunsigned int Type = (uint64_t)dlsym(v1, "kCMPhotoDecompressionContainerDescription_AuxiliaryType");
    if (!gIIO_kCMPhotoDecompressionContainerDescription_AuxiliaryType)
    {
      unint64_t v111 = dlerror();
      printf("  failed to load 'kCMPhotoDecompressionContainerDescription_AuxiliaryType' [%s]\n", v111);
      ++v2;
    }
    gIIO_kCMPhotoDecompressionContainerDescription_AuxiliaryTypeURN = (uint64_t)dlsym(v1, "kCMPhotoDecompressionContainerDescription_AuxiliaryTypeURN");
    if (!gIIO_kCMPhotoDecompressionContainerDescription_AuxiliaryTypeURN)
    {
      __n128 v112 = dlerror();
      printf("  failed to load 'kCMPhotoDecompressionContainerDescription_AuxiliaryTypeURN' [%s]\n", v112);
      ++v2;
    }
    gIIO_kCMPhotoDecompressionContainerDescription_BitDepth = (uint64_t)dlsym(v1, "kCMPhotoDecompressionContainerDescription_BitDepth");
    if (!gIIO_kCMPhotoDecompressionContainerDescription_BitDepth)
    {
      unint64_t v113 = dlerror();
      printf("  failed to load 'kCMPhotoDecompressionContainerDescription_BitDepth' [%s]\n", v113);
      ++v2;
    }
    gIIO_kCMPhotoDecompressionContainerDescription_Codecunsigned int Type = (uint64_t)dlsym(v1, "kCMPhotoDecompressionContainerDescription_CodecType");
    if (!gIIO_kCMPhotoDecompressionContainerDescription_CodecType)
    {
      unint64_t v114 = dlerror();
      printf("  failed to load 'kCMPhotoDecompressionContainerDescription_CodecType' [%s]\n", v114);
      ++v2;
    }
    gIIO_kCMPhotoDecompressionContainerDescription_ColorSpace = (uint64_t)dlsym(v1, "kCMPhotoDecompressionContainerDescription_ColorSpace");
    if (!gIIO_kCMPhotoDecompressionContainerDescription_ColorSpace)
    {
      int v115 = dlerror();
      printf("  failed to load 'kCMPhotoDecompressionContainerDescription_ColorSpace' [%s]\n", v115);
      ++v2;
    }
    gIIO_kCMPhotoDecompressionContainerDescription_CustomMetadataPayloads = (uint64_t)dlsym(v1, "kCMPhotoDecompressionContainerDescription_CustomMetadataPayloads");
    if (!gIIO_kCMPhotoDecompressionContainerDescription_CustomMetadataPayloads)
    {
      unint64_t v116 = dlerror();
      printf("  failed to load 'kCMPhotoDecompressionContainerDescription_CustomMetadataPayloads' [%s]\n", v116);
      ++v2;
    }
    gIIO_kCMPhotoDecompressionContainerDescription_DataCFIndex Length = (uint64_t)dlsym(v1, "kCMPhotoDecompressionContainerDescription_DataLength");
    if (!gIIO_kCMPhotoDecompressionContainerDescription_DataLength)
    {
      BOOL v117 = dlerror();
      printf("  failed to load 'kCMPhotoDecompressionContainerDescription_DataLength' [%s]\n", v117);
      ++v2;
    }
    gIIO_kCMPhotoDecompressionContainerDescription_DataOffset = (uint64_t)dlsym(v1, "kCMPhotoDecompressionContainerDescription_DataOffset");
    if (!gIIO_kCMPhotoDecompressionContainerDescription_DataOffset)
    {
      long long v118 = dlerror();
      printf("  failed to load 'kCMPhotoDecompressionContainerDescription_DataOffset' [%s]\n", v118);
      ++v2;
    }
    gIIO_kCMPhotoDecompressionContainerDescription_DebugPayloads = (uint64_t)dlsym(v1, "kCMPhotoDecompressionContainerDescription_DebugPayloads");
    if (!gIIO_kCMPhotoDecompressionContainerDescription_DebugPayloads)
    {
      size_t v119 = dlerror();
      printf("  failed to load 'kCMPhotoDecompressionContainerDescription_DebugPayloads' [%s]\n", v119);
      ++v2;
    }
    gIIO_kCMPhotoDecompressionContainerDescription_DerivationDetails = (uint64_t)dlsym(v1, "kCMPhotoDecompressionContainerDescription_DerivationDetails");
    if (!gIIO_kCMPhotoDecompressionContainerDescription_DerivationDetails)
    {
      size_t v120 = dlerror();
      printf("  failed to load 'kCMPhotoDecompressionContainerDescription_DerivationDetails' [%s]\n", v120);
      ++v2;
    }
    gIIO_kCMPhotoDecompressionContainerDescription_DerivationGainMapDimension = (uint64_t)dlsym(v1, "kCMPhotoDecompressionContainerDescription_DerivationGainMapDimension");
    if (!gIIO_kCMPhotoDecompressionContainerDescription_DerivationGainMapDimension)
    {
      unsigned int v121 = dlerror();
      printf("  failed to load 'kCMPhotoDecompressionContainerDescription_DerivationGainMapDimension' [%s]\n", v121);
      ++v2;
    }
    gIIO_kCMPhotoDecompressionContainerDescription_DerivationGainMapOrientation = (uint64_t)dlsym(v1, "kCMPhotoDecompressionContainerDescription_DerivationGainMapOrientation");
    if (!gIIO_kCMPhotoDecompressionContainerDescription_DerivationGainMapOrientation)
    {
      uint64_t v122 = dlerror();
      printf("  failed to load 'kCMPhotoDecompressionContainerDescription_DerivationGainMapOrientation' [%s]\n", v122);
      ++v2;
    }
    gIIO_kCMPhotoDecompressionContainerDescription_DerivationGainMapsigned int PixelFormat = (uint64_t)dlsym(v1, "kCMPhotoDecompressionContainerDescription_DerivationGainMapPixelFormat");
    if (!gIIO_kCMPhotoDecompressionContainerDescription_DerivationGainMapPixelFormat)
    {
      unsigned int v123 = dlerror();
      printf("  failed to load 'kCMPhotoDecompressionContainerDescription_DerivationGainMapPixelFormat' [%s]\n", v123);
      ++v2;
    }
    gIIO_kCMPhotoDecompressionContainerDescription_Dimensions = (uint64_t)dlsym(v1, "kCMPhotoDecompressionContainerDescription_Dimensions");
    if (!gIIO_kCMPhotoDecompressionContainerDescription_Dimensions)
    {
      size_t v124 = dlerror();
      printf("  failed to load 'kCMPhotoDecompressionContainerDescription_Dimensions' [%s]\n", v124);
      ++v2;
    }
    gIIO_kCMPhotoDecompressionContainerDescription_ExifPayloads = (uint64_t)dlsym(v1, "kCMPhotoDecompressionContainerDescription_ExifPayloads");
    if (!gIIO_kCMPhotoDecompressionContainerDescription_ExifPayloads)
    {
      size_t v125 = dlerror();
      printf("  failed to load 'kCMPhotoDecompressionContainerDescription_ExifPayloads' [%s]\n", v125);
      ++v2;
    }
    gIIO_kCMPhotoDecompressionContainerDescription_Group_PictureIndexList = (uint64_t)dlsym(v1, "kCMPhotoDecompressionContainerDescription_Group_PictureIndexList");
    if (!gIIO_kCMPhotoDecompressionContainerDescription_Group_PictureIndexList)
    {
      unsigned int v126 = dlerror();
      printf("  failed to load 'kCMPhotoDecompressionContainerDescription_Group_PictureIndexList' [%s]\n", v126);
      ++v2;
    }
    gIIO_kCMPhotoDecompressionContainerDescription_Group_unsigned int Type = (uint64_t)dlsym(v1, "kCMPhotoDecompressionContainerDescription_Group_Type");
    if (!gIIO_kCMPhotoDecompressionContainerDescription_Group_Type)
    {
      unsigned int v127 = dlerror();
      printf("  failed to load 'kCMPhotoDecompressionContainerDescription_Group_Type' [%s]\n", v127);
      ++v2;
    }
    gIIO_kCMPhotoDecompressionContainerDescription_GroupsList = (uint64_t)dlsym(v1, "kCMPhotoDecompressionContainerDescription_GroupsList");
    if (!gIIO_kCMPhotoDecompressionContainerDescription_GroupsList)
    {
      long long v128 = dlerror();
      printf("  failed to load 'kCMPhotoDecompressionContainerDescription_GroupsList' [%s]\n", v128);
      ++v2;
    }
    gIIO_kCMPhotoDecompressionContainerDescription_ImageSequenceunsigned int Count = (uint64_t)dlsym(v1, "kCMPhotoDecompressionContainerDescription_ImageSequenceCount");
    if (!gIIO_kCMPhotoDecompressionContainerDescription_ImageSequenceCount)
    {
      long long v129 = dlerror();
      printf("  failed to load 'kCMPhotoDecompressionContainerDescription_ImageSequenceCount' [%s]\n", v129);
      ++v2;
    }
    gIIO_kCMPhotoDecompressionContainerDescription_ItemID = (uint64_t)dlsym(v1, "kCMPhotoDecompressionContainerDescription_ItemID");
    if (!gIIO_kCMPhotoDecompressionContainerDescription_ItemID)
    {
      long long v130 = dlerror();
      printf("  failed to load 'kCMPhotoDecompressionContainerDescription_ItemID' [%s]\n", v130);
      ++v2;
    }
    gIIO_kCMPhotoDecompressionContainerDescription_Itemunsigned int Type = (uint64_t)dlsym(v1, "kCMPhotoDecompressionContainerDescription_ItemType");
    if (!gIIO_kCMPhotoDecompressionContainerDescription_ItemType)
    {
      CFIndex v131 = dlerror();
      printf("  failed to load 'kCMPhotoDecompressionContainerDescription_ItemType' [%s]\n", v131);
      ++v2;
    }
    gIIO_kCMPhotoDecompressionContainerDescription_MainImages = (uint64_t)dlsym(v1, "kCMPhotoDecompressionContainerDescription_MainImages");
    if (!gIIO_kCMPhotoDecompressionContainerDescription_MainImages)
    {
      uint64_t v132 = dlerror();
      printf("  failed to load 'kCMPhotoDecompressionContainerDescription_MainImages' [%s]\n", v132);
      ++v2;
    }
    gIIO_kCMPhotoDecompressionContainerDescription_MeteorHeadroomFromMakerNote = (uint64_t)dlsym(v1, "kCMPhotoDecompressionContainerDescription_MeteorHeadroomFromMakerNote");
    if (!gIIO_kCMPhotoDecompressionContainerDescription_MeteorHeadroomFromMakerNote)
    {
      BOOL v133 = dlerror();
      printf("  failed to load 'kCMPhotoDecompressionContainerDescription_MeteorHeadroomFromMakerNote' [%s]\n", v133);
      ++v2;
    }
    gIIO_kCMPhotoDecompressionContainerDescription_MeteorHeadroomFromunint64_t Properties = (uint64_t)dlsym(v1, "kCMPhotoDecompressionContainerDescription_MeteorHeadroomFromProperties");
    if (!gIIO_kCMPhotoDecompressionContainerDescription_MeteorHeadroomFromProperties)
    {
      memory_object_size_t v134 = dlerror();
      printf("  failed to load 'kCMPhotoDecompressionContainerDescription_MeteorHeadroomFromProperties' [%s]\n", v134);
      ++v2;
    }
    gIIO_kCMPhotoDecompressionContainerDescription_NamedColorSpace = (uint64_t)dlsym(v1, "kCMPhotoDecompressionContainerDescription_NamedColorSpace");
    if (!gIIO_kCMPhotoDecompressionContainerDescription_NamedColorSpace)
    {
      CFAllocatorRef v135 = dlerror();
      printf("  failed to load 'kCMPhotoDecompressionContainerDescription_NamedColorSpace' [%s]\n", v135);
      ++v2;
    }
    gIIO_kCMPhotoDecompressionContainerDescription_NclxColor_ColorPrimaries = (uint64_t)dlsym(v1, "kCMPhotoDecompressionContainerDescription_NclxColor_ColorPrimaries");
    if (!gIIO_kCMPhotoDecompressionContainerDescription_NclxColor_ColorPrimaries)
    {
      CFAllocatorRef v136 = dlerror();
      printf("  failed to load 'kCMPhotoDecompressionContainerDescription_NclxColor_ColorPrimaries' [%s]\n", v136);
      ++v2;
    }
    gIIO_kCMPhotoDecompressionContainerDescription_NclxColor_TransferFunction = (uint64_t)dlsym(v1, "kCMPhotoDecompressionContainerDescription_NclxColor_TransferFunction");
    if (!gIIO_kCMPhotoDecompressionContainerDescription_NclxColor_TransferFunction)
    {
      char v137 = dlerror();
      printf("  failed to load 'kCMPhotoDecompressionContainerDescription_NclxColor_TransferFunction' [%s]\n", v137);
      ++v2;
    }
    gIIO_kCMPhotoDecompressionContainerDescription_NclxColor_YCbCrMatridouble x = (uint64_t)dlsym(v1, "kCMPhotoDecompressionContainerDescription_NclxColor_YCbCrMatrix");
    if (!gIIO_kCMPhotoDecompressionContainerDescription_NclxColor_YCbCrMatrix)
    {
      int v138 = dlerror();
      printf("  failed to load 'kCMPhotoDecompressionContainerDescription_NclxColor_YCbCrMatrix' [%s]\n", v138);
      ++v2;
    }
    gIIO_kCMPhotoDecompressionContainerDescription_NclxColor = (uint64_t)dlsym(v1, "kCMPhotoDecompressionContainerDescription_NclxColor");
    if (!gIIO_kCMPhotoDecompressionContainerDescription_NclxColor)
    {
      CFDataRef v139 = dlerror();
      printf("  failed to load 'kCMPhotoDecompressionContainerDescription_NclxColor' [%s]\n", v139);
      ++v2;
    }
    gIIO_kCMPhotoDecompressionContainerDescription_Orientation = (uint64_t)dlsym(v1, "kCMPhotoDecompressionContainerDescription_Orientation");
    if (!gIIO_kCMPhotoDecompressionContainerDescription_Orientation)
    {
      uint64_t v140 = dlerror();
      printf("  failed to load 'kCMPhotoDecompressionContainerDescription_Orientation' [%s]\n", v140);
      ++v2;
    }
    gIIO_kCMPhotoDecompressionContainerDescription_PrimaryImageIndedouble x = (uint64_t)dlsym(v1, "kCMPhotoDecompressionContainerDescription_PrimaryImageIndex");
    if (!gIIO_kCMPhotoDecompressionContainerDescription_PrimaryImageIndex)
    {
      int v141 = dlerror();
      printf("  failed to load 'kCMPhotoDecompressionContainerDescription_PrimaryImageIndex' [%s]\n", v141);
      ++v2;
    }
    gIIO_kCMPhotoDecompressionContainerDescription_SequenceSampleDependsOnOthers = (uint64_t)dlsym(v1, "kCMPhotoDecompressionContainerDescription_SequenceSampleDependsOnOthers");
    if (!gIIO_kCMPhotoDecompressionContainerDescription_SequenceSampleDependsOnOthers)
    {
      CFIndex v142 = dlerror();
      printf("  failed to load 'kCMPhotoDecompressionContainerDescription_SequenceSampleDependsOnOthers' [%s]\n", v142);
      ++v2;
    }
    gIIO_kCMPhotoDecompressionContainerDescription_SequenceSampleDuration = (uint64_t)dlsym(v1, "kCMPhotoDecompressionContainerDescription_SequenceSampleDuration");
    if (!gIIO_kCMPhotoDecompressionContainerDescription_SequenceSampleDuration)
    {
      int v143 = dlerror();
      printf("  failed to load 'kCMPhotoDecompressionContainerDescription_SequenceSampleDuration' [%s]\n", v143);
      ++v2;
    }
    gIIO_kCMPhotoDecompressionContainerDescription_SequenceSampleIsDependedOnByOthers = (uint64_t)dlsym(v1, "kCMPhotoDecompressionContainerDescription_SequenceSampleIsDependedOnByOthers");
    if (!gIIO_kCMPhotoDecompressionContainerDescription_SequenceSampleIsDependedOnByOthers)
    {
      unsigned int v144 = dlerror();
      printf("  failed to load 'kCMPhotoDecompressionContainerDescription_SequenceSampleIsDependedOnByOthers' [%s]\n", v144);
      ++v2;
    }
    gIIO_kCMPhotoDecompressionContainerDescription_SequenceSamplePTS = (uint64_t)dlsym(v1, "kCMPhotoDecompressionContainerDescription_SequenceSamplePTS");
    if (!gIIO_kCMPhotoDecompressionContainerDescription_SequenceSamplePTS)
    {
      uint64_t v145 = dlerror();
      printf("  failed to load 'kCMPhotoDecompressionContainerDescription_SequenceSamplePTS' [%s]\n", v145);
      ++v2;
    }
    gIIO_kCMPhotoDecompressionContainerDescription_SequenceTracksDescription = (uint64_t)dlsym(v1, "kCMPhotoDecompressionContainerDescription_SequenceTracksDescription");
    if (!gIIO_kCMPhotoDecompressionContainerDescription_SequenceTracksDescription)
    {
      uint64_t v146 = dlerror();
      printf("  failed to load 'kCMPhotoDecompressionContainerDescription_SequenceTracksDescription' [%s]\n", v146);
      ++v2;
    }
    gIIO_kCMPhotoDecompressionContainerDescription_ThumbnailImageunsigned int Count = (uint64_t)dlsym(v1, "kCMPhotoDecompressionContainerDescription_ThumbnailImageCount");
    if (!gIIO_kCMPhotoDecompressionContainerDescription_ThumbnailImageCount)
    {
      uint64_t v147 = dlerror();
      printf("  failed to load 'kCMPhotoDecompressionContainerDescription_ThumbnailImageCount' [%s]\n", v147);
      ++v2;
    }
    gIIO_kCMPhotoDecompressionContainerDescription_ThumbnailImages = (uint64_t)dlsym(v1, "kCMPhotoDecompressionContainerDescription_ThumbnailImages");
    if (!gIIO_kCMPhotoDecompressionContainerDescription_ThumbnailImages)
    {
      unint64_t v148 = dlerror();
      printf("  failed to load 'kCMPhotoDecompressionContainerDescription_ThumbnailImages' [%s]\n", v148);
      ++v2;
    }
    gIIO_kCMPhotoDecompressionContainerDescription_TiffOffset = (uint64_t)dlsym(v1, "kCMPhotoDecompressionContainerDescription_TiffOffset");
    if (!gIIO_kCMPhotoDecompressionContainerDescription_TiffOffset)
    {
      int v149 = dlerror();
      printf("  failed to load 'kCMPhotoDecompressionContainerDescription_TiffOffset' [%s]\n", v149);
      ++v2;
    }
    gIIO_kCMPhotoDecompressionContainerDescription_TileDimensions = (uint64_t)dlsym(v1, "kCMPhotoDecompressionContainerDescription_TileDimensions");
    if (!gIIO_kCMPhotoDecompressionContainerDescription_TileDimensions)
    {
      CFTypeRef v150 = dlerror();
      printf("  failed to load 'kCMPhotoDecompressionContainerDescription_TileDimensions' [%s]\n", v150);
      ++v2;
    }
    gIIO_kCMPhotoDecompressionContainerDescription_VideoTrackunsigned int Count = (uint64_t)dlsym(v1, "kCMPhotoDecompressionContainerDescription_VideoTrackCount");
    if (!gIIO_kCMPhotoDecompressionContainerDescription_VideoTrackCount)
    {
      CFTypeRef v151 = dlerror();
      printf("  failed to load 'kCMPhotoDecompressionContainerDescription_VideoTrackCount' [%s]\n", v151);
      ++v2;
    }
    gIIO_kCMPhotoDecompressionContainerDescription_XMPPayloads = (uint64_t)dlsym(v1, "kCMPhotoDecompressionContainerDescription_XMPPayloads");
    if (!gIIO_kCMPhotoDecompressionContainerDescription_XMPPayloads)
    {
      CFTypeRef v152 = dlerror();
      printf("  failed to load 'kCMPhotoDecompressionContainerDescription_XMPPayloads' [%s]\n", v152);
      ++v2;
    }
    gIIO_kCMPhotoDecompressionOption_AccelerationMode = (uint64_t)dlsym(v1, "kCMPhotoDecompressionOption_AccelerationMode");
    if (!gIIO_kCMPhotoDecompressionOption_AccelerationMode)
    {
      int v153 = dlerror();
      printf("  failed to load 'kCMPhotoDecompressionOption_AccelerationMode' [%s]\n", v153);
      ++v2;
    }
    gIIO_kCMPhotoDecompressionOption_AlternateIndedouble x = (uint64_t)dlsym(v1, "kCMPhotoDecompressionOption_AlternateIndex");
    if (!gIIO_kCMPhotoDecompressionOption_AlternateIndex)
    {
      int v154 = dlerror();
      printf("  failed to load 'kCMPhotoDecompressionOption_AlternateIndex' [%s]\n", v154);
      ++v2;
    }
    gIIO_kCMPhotoDecompressionOption_ApplyTransforCFIndex m = (uint64_t)dlsym(v1, "kCMPhotoDecompressionOption_ApplyTransform");
    if (!gIIO_kCMPhotoDecompressionOption_ApplyTransform)
    {
      double v155 = dlerror();
      printf("  failed to load 'kCMPhotoDecompressionOption_ApplyTransform' [%s]\n", v155);
      ++v2;
    }
    gIIO_kCMPhotoDecompressionOption_BackCGImageWithIOSurface = (uint64_t)dlsym(v1, "kCMPhotoDecompressionOption_BackCGImageWithIOSurface");
    if (!gIIO_kCMPhotoDecompressionOption_BackCGImageWithIOSurface)
    {
      CGRect v156 = dlerror();
      printf("  failed to load 'kCMPhotoDecompressionOption_BackCGImageWithIOSurface' [%s]\n", v156);
      ++v2;
    }
    gIIO_kCMPhotoDecompressionOption_DecodeToHDROutputHeadRooCFIndex m = (uint64_t)dlsym(v1, "kCMPhotoDecompressionOption_DecodeToHDROutputHeadRoom");
    if (!gIIO_kCMPhotoDecompressionOption_DecodeToHDROutputHeadRoom)
    {
      CGRect v157 = dlerror();
      printf("  failed to load 'kCMPhotoDecompressionOption_DecodeToHDROutputHeadRoom' [%s]\n", v157);
      ++v2;
    }
    gIIO_kCMPhotoDecompressionOption_DecodeToHDROutputMode = (uint64_t)dlsym(v1, "kCMPhotoDecompressionOption_DecodeToHDROutputMode");
    if (!gIIO_kCMPhotoDecompressionOption_DecodeToHDROutputMode)
    {
      int v158 = dlerror();
      printf("  failed to load 'kCMPhotoDecompressionOption_DecodeToHDROutputMode' [%s]\n", v158);
      ++v2;
    }
    gIIO_kCMPhotoDecompressionOption_DecodeToHDROutputDoNotDecodeBaselayer = (uint64_t)dlsym(v1, "kCMPhotoDecompressionOption_DecodeToHDROutputDoNotDecodeBaselayer");
    if (!gIIO_kCMPhotoDecompressionOption_DecodeToHDROutputDoNotDecodeBaselayer)
    {
      uint64_t v159 = dlerror();
      printf("  failed to load 'kCMPhotoDecompressionOption_DecodeToHDROutputDoNotDecodeBaselayer' [%s]\n", v159);
      ++v2;
    }
    gIIO_kCMPhotoDecompressionOption_DecodeToHDROutputuint64_t Options = (uint64_t)dlsym(v1, "kCMPhotoDecompressionOption_DecodeToHDROutputOptions");
    if (!gIIO_kCMPhotoDecompressionOption_DecodeToHDROutputOptions)
    {
      int v160 = dlerror();
      printf("  failed to load 'kCMPhotoDecompressionOption_DecodeToHDROutputOptions' [%s]\n", v160);
      ++v2;
    }
    gIIO_kCMPhotoDecompressionContainerConstituent_FlexRangeMetaCFDataRef data = (uint64_t)dlsym(v1, "kCMPhotoDecompressionContainerConstituent_FlexRangeMetadata");
    if (!gIIO_kCMPhotoDecompressionContainerConstituent_FlexRangeMetadata)
    {
      int v161 = dlerror();
      printf("  failed to load 'kCMPhotoDecompressionContainerConstituent_FlexRangeMetadata' [%s]\n", v161);
      ++v2;
    }
    gIIO_kCMPhotoDecompressionContainerConstituent_FlexRangeColorSpace = (uint64_t)dlsym(v1, "kCMPhotoDecompressionContainerConstituent_FlexRangeColorSpace");
    if (!gIIO_kCMPhotoDecompressionContainerConstituent_FlexRangeColorSpace)
    {
      int v162 = dlerror();
      printf("  failed to load 'kCMPhotoDecompressionContainerConstituent_FlexRangeColorSpace' [%s]\n", v162);
      ++v2;
    }
    gIIO_kCMPhotoDecompressionContainerConstituent_FlexRangeGainMap = (uint64_t)dlsym(v1, "kCMPhotoDecompressionContainerConstituent_FlexRangeGainMap");
    if (!gIIO_kCMPhotoDecompressionContainerConstituent_FlexRangeGainMap)
    {
      CFRange v163 = dlerror();
      printf("  failed to load 'kCMPhotoDecompressionContainerConstituent_FlexRangeGainMap' [%s]\n", v163);
      ++v2;
    }
    gIIO_kCMPhotoDecompressionOption_ForceHighSpeed = (uint64_t)dlsym(v1, "kCMPhotoDecompressionOption_ForceHighSpeed");
    if (!gIIO_kCMPhotoDecompressionOption_ForceHighSpeed)
    {
      CFDictionaryRef v164 = dlerror();
      printf("  failed to load 'kCMPhotoDecompressionOption_ForceHighSpeed' [%s]\n", v164);
      ++v2;
    }
    gIIO_kCMPhotoDecompressionOption_MaxPixelCFIndex Size = (uint64_t)dlsym(v1, "kCMPhotoDecompressionOption_MaxPixelSize");
    if (!gIIO_kCMPhotoDecompressionOption_MaxPixelSize)
    {
      int v165 = dlerror();
      printf("  failed to load 'kCMPhotoDecompressionOption_MaxPixelSize' [%s]\n", v165);
      ++v2;
    }
    gIIO_kCMPhotoDecompressionOption_Outputsigned int PixelFormat = (uint64_t)dlsym(v1, "kCMPhotoDecompressionOption_OutputPixelFormat");
    if (!gIIO_kCMPhotoDecompressionOption_OutputPixelFormat)
    {
      float v166 = dlerror();
      printf("  failed to load 'kCMPhotoDecompressionOption_OutputPixelFormat' [%s]\n", v166);
      ++v2;
    }
    gIIO_kCMPhotoDecompressionOption_RestrictedDecoding = (uint64_t)dlsym(v1, "kCMPhotoDecompressionOption_RestrictedDecoding");
    if (!gIIO_kCMPhotoDecompressionOption_RestrictedDecoding)
    {
      char v167 = dlerror();
      printf("  failed to load 'kCMPhotoDecompressionOption_RestrictedDecoding' [%s]\n", v167);
      ++v2;
    }
    gIIO_kCMPhotoDecompressionOption_SourceCropRect = (uint64_t)dlsym(v1, "kCMPhotoDecompressionOption_SourceCropRect");
    if (!gIIO_kCMPhotoDecompressionOption_SourceCropRect)
    {
      CFStringRef v168 = dlerror();
      printf("  failed to load 'kCMPhotoDecompressionOption_SourceCropRect' [%s]\n", v168);
      ++v2;
    }
    gIIO_kCMPhotoDecompressionOption_TiledDownsampling = (uint64_t)dlsym(v1, "kCMPhotoDecompressionOption_TiledDownsampling");
    if (!gIIO_kCMPhotoDecompressionOption_TiledDownsampling)
    {
      CFDictionaryRef v169 = dlerror();
      printf("  failed to load 'kCMPhotoDecompressionOption_TiledDownsampling' [%s]\n", v169);
      ++v2;
    }
    gIIO_kCMPhotoDecompressionOption_UseProvidedPixelBuffer = (uint64_t)dlsym(v1, "kCMPhotoDecompressionOption_UseProvidedPixelBuffer");
    if (!gIIO_kCMPhotoDecompressionOption_UseProvidedPixelBuffer)
    {
      CFRange v170 = dlerror();
      printf("  failed to load 'kCMPhotoDecompressionOption_UseProvidedPixelBuffer' [%s]\n", v170);
      ++v2;
    }
    gIIO_kCMPhotoJPEGCustomLumaQuantTable = (uint64_t)dlsym(v1, "kCMPhotoJPEGCustomLumaQuantTable");
    if (!gIIO_kCMPhotoJPEGCustomLumaQuantTable)
    {
      int v171 = dlerror();
      printf("  failed to load 'kCMPhotoJPEGCustomLumaQuantTable' [%s]\n", v171);
      ++v2;
    }
    gIIO_kCMPhotoJPEGCustomChromaQuantTable = (uint64_t)dlsym(v1, "kCMPhotoJPEGCustomChromaQuantTable");
    if (!gIIO_kCMPhotoJPEGCustomChromaQuantTable)
    {
      uint64_t v172 = dlerror();
      printf("  failed to load 'kCMPhotoJPEGCustomChromaQuantTable' [%s]\n", v172);
      ++v2;
    }
    gIIO_kCMPhotoJPEGSoftwareEncode = (uint64_t)dlsym(v1, "kCMPhotoJPEGSoftwareEncode");
    if (!gIIO_kCMPhotoJPEGSoftwareEncode)
    {
      uint64_t v173 = dlerror();
      printf("  failed to load 'kCMPhotoJPEGSoftwareEncode' [%s]\n", v173);
      ++v2;
    }
    gIIO_kCMPhotoMetadata_TonemapAlternateHDRHeadrooCFIndex m = (uint64_t)dlsym(v1, "kCMPhotoMetadata_TonemapAlternateHDRHeadroom");
    if (!gIIO_kCMPhotoMetadata_TonemapAlternateHDRHeadroom)
    {
      int v174 = dlerror();
      printf("  failed to load 'kCMPhotoMetadata_TonemapAlternateHDRHeadroom' [%s]\n", v174);
      ++v2;
    }
    gIIO_kCMPhotoMetadata_TonemapBaseColorIsWorkingColor = (uint64_t)dlsym(v1, "kCMPhotoMetadata_TonemapBaseColorIsWorkingColor");
    if (!gIIO_kCMPhotoMetadata_TonemapBaseColorIsWorkingColor)
    {
      int v175 = dlerror();
      printf("  failed to load 'kCMPhotoMetadata_TonemapBaseColorIsWorkingColor' [%s]\n", v175);
      ++v2;
    }
    gIIO_kCMPhotoMetadata_TonemapBaseHDRHeadrooCFIndex m = (uint64_t)dlsym(v1, "kCMPhotoMetadata_TonemapBaseHDRHeadroom");
    if (!gIIO_kCMPhotoMetadata_TonemapBaseHDRHeadroom)
    {
      unsigned int v176 = dlerror();
      printf("  failed to load 'kCMPhotoMetadata_TonemapBaseHDRHeadroom' [%s]\n", v176);
      ++v2;
    }
    gIIO_kCMPhotoMetadata_TonemapChannelMetadataKeys = (uint64_t)dlsym(v1, "kCMPhotoMetadata_TonemapChannelMetadataKeys");
    if (!gIIO_kCMPhotoMetadata_TonemapChannelMetadataKeys)
    {
      int v177 = dlerror();
      printf("  failed to load 'kCMPhotoMetadata_TonemapChannelMetadataKeys' [%s]\n", v177);
      ++v2;
    }
    gIIO_kCMPhotoMetadataTonemapChannel_AlternateOffset = (uint64_t)dlsym(v1, "kCMPhotoMetadataTonemapChannel_AlternateOffset");
    if (!gIIO_kCMPhotoMetadataTonemapChannel_AlternateOffset)
    {
      uint64_t v178 = dlerror();
      printf("  failed to load 'kCMPhotoMetadataTonemapChannel_AlternateOffset' [%s]\n", v178);
      ++v2;
    }
    gIIO_kCMPhotoMetadataTonemapChannel_BaseOffset = (uint64_t)dlsym(v1, "kCMPhotoMetadataTonemapChannel_BaseOffset");
    if (!gIIO_kCMPhotoMetadataTonemapChannel_BaseOffset)
    {
      unsigned int v179 = dlerror();
      printf("  failed to load 'kCMPhotoMetadataTonemapChannel_BaseOffset' [%s]\n", v179);
      ++v2;
    }
    gIIO_kCMPhotoMetadataTonemapChannel_GainMapMadouble x = (uint64_t)dlsym(v1, "kCMPhotoMetadataTonemapChannel_GainMapMax");
    if (!gIIO_kCMPhotoMetadataTonemapChannel_GainMapMax)
    {
      int v180 = dlerror();
      printf("  failed to load 'kCMPhotoMetadataTonemapChannel_GainMapMax' [%s]\n", v180);
      ++v2;
    }
    gIIO_kCMPhotoMetadataTonemapChannel_GainMapMin = (uint64_t)dlsym(v1, "kCMPhotoMetadataTonemapChannel_GainMapMin");
    if (!gIIO_kCMPhotoMetadataTonemapChannel_GainMapMin)
    {
      uint64_t v181 = dlerror();
      printf("  failed to load 'kCMPhotoMetadataTonemapChannel_GainMapMin' [%s]\n", v181);
      ++v2;
    }
    gIIO_kCMPhotoMetadataTonemapChannel_Gamma = (uint64_t)dlsym(v1, "kCMPhotoMetadataTonemapChannel_Gamma");
    if (!gIIO_kCMPhotoMetadataTonemapChannel_Gamma)
    {
      unsigned int v182 = dlerror();
      printf("  failed to load 'kCMPhotoMetadataTonemapChannel_Gamma' [%s]\n", v182);
      ++v2;
    }
    gIIO_kCMPhotoAuxiliaryImageTypeURN_Alpha = (uint64_t)dlsym(v1, "kCMPhotoAuxiliaryImageTypeURN_Alpha");
    if (!gIIO_kCMPhotoAuxiliaryImageTypeURN_Alpha)
    {
      int v183 = dlerror();
      printf("  failed to load 'kCMPhotoAuxiliaryImageTypeURN_Alpha' [%s]\n", v183);
      ++v2;
    }
    gIIO_kCMPhotoAuxiliaryImageTypeURN_MIAF_Alpha = (uint64_t)dlsym(v1, "kCMPhotoAuxiliaryImageTypeURN_MIAF_Alpha");
    if (!gIIO_kCMPhotoAuxiliaryImageTypeURN_MIAF_Alpha)
    {
      uint64_t v184 = dlerror();
      printf("  failed to load 'kCMPhotoAuxiliaryImageTypeURN_MIAF_Alpha' [%s]\n", v184);
      ++v2;
    }
    gIIO_kCMPhotoAuxiliaryImageTypeURN_Depth = (uint64_t)dlsym(v1, "kCMPhotoAuxiliaryImageTypeURN_Depth");
    if (!gIIO_kCMPhotoAuxiliaryImageTypeURN_Depth)
    {
      uint64_t v185 = dlerror();
      printf("  failed to load 'kCMPhotoAuxiliaryImageTypeURN_Depth' [%s]\n", v185);
      ++v2;
    }
    gIIO_kCMPhotoAuxiliaryImageTypeURN_MIAF_Depth = (uint64_t)dlsym(v1, "kCMPhotoAuxiliaryImageTypeURN_MIAF_Depth");
    if (!gIIO_kCMPhotoAuxiliaryImageTypeURN_MIAF_Depth)
    {
      v186 = dlerror();
      printf("  failed to load 'kCMPhotoAuxiliaryImageTypeURN_MIAF_Depth' [%s]\n", v186);
      ++v2;
    }
    gIIO_kCMPhotoAuxiliaryImageTypeURN_PortraitEffectsMatte = (uint64_t)dlsym(v1, "kCMPhotoAuxiliaryImageTypeURN_PortraitEffectsMatte");
    if (!gIIO_kCMPhotoAuxiliaryImageTypeURN_PortraitEffectsMatte)
    {
      char v187 = dlerror();
      printf("  failed to load 'kCMPhotoAuxiliaryImageTypeURN_PortraitEffectsMatte' [%s]\n", v187);
      ++v2;
    }
    gIIO_kCMPhotoAuxiliaryImageTypeURN_SemanticHairMatte = (uint64_t)dlsym(v1, "kCMPhotoAuxiliaryImageTypeURN_SemanticHairMatte");
    if (!gIIO_kCMPhotoAuxiliaryImageTypeURN_SemanticHairMatte)
    {
      int v188 = dlerror();
      printf("  failed to load 'kCMPhotoAuxiliaryImageTypeURN_SemanticHairMatte' [%s]\n", v188);
      ++v2;
    }
    gIIO_kCMPhotoAuxiliaryImageTypeURN_SemanticSkinMatte = (uint64_t)dlsym(v1, "kCMPhotoAuxiliaryImageTypeURN_SemanticSkinMatte");
    if (!gIIO_kCMPhotoAuxiliaryImageTypeURN_SemanticSkinMatte)
    {
      v189 = dlerror();
      printf("  failed to load 'kCMPhotoAuxiliaryImageTypeURN_SemanticSkinMatte' [%s]\n", v189);
      ++v2;
    }
    gIIO_kCMPhotoAuxiliaryImageTypeURN_SemanticTeethMatte = (uint64_t)dlsym(v1, "kCMPhotoAuxiliaryImageTypeURN_SemanticTeethMatte");
    if (!gIIO_kCMPhotoAuxiliaryImageTypeURN_SemanticTeethMatte)
    {
      CFDataRef v190 = dlerror();
      printf("  failed to load 'kCMPhotoAuxiliaryImageTypeURN_SemanticTeethMatte' [%s]\n", v190);
      ++v2;
    }
    gIIO_kCMPhotoAuxiliaryImageTypeURN_SemanticGlassesMatte = (uint64_t)dlsym(v1, "kCMPhotoAuxiliaryImageTypeURN_SemanticGlassesMatte");
    if (!gIIO_kCMPhotoAuxiliaryImageTypeURN_SemanticGlassesMatte)
    {
      uint64_t v191 = dlerror();
      printf("  failed to load 'kCMPhotoAuxiliaryImageTypeURN_SemanticGlassesMatte' [%s]\n", v191);
      ++v2;
    }
    gIIO_kCMPhotoAuxiliaryImageTypeURN_SemanticSkyMatte = (uint64_t)dlsym(v1, "kCMPhotoAuxiliaryImageTypeURN_SemanticSkyMatte");
    if (!gIIO_kCMPhotoAuxiliaryImageTypeURN_SemanticSkyMatte)
    {
      unsigned int v192 = dlerror();
      printf("  failed to load 'kCMPhotoAuxiliaryImageTypeURN_SemanticSkyMatte' [%s]\n", v192);
      ++v2;
    }
    gIIO_kCMPhotoAuxiliaryImageTypeURN_HDRGainMap = (uint64_t)dlsym(v1, "kCMPhotoAuxiliaryImageTypeURN_HDRGainMap");
    if (!gIIO_kCMPhotoAuxiliaryImageTypeURN_HDRGainMap)
    {
      unsigned int v193 = dlerror();
      printf("  failed to load 'kCMPhotoAuxiliaryImageTypeURN_HDRGainMap' [%s]\n", v193);
      ++v2;
    }
    gIIO_kCMPhotoCompressionOption_AuxiliaryImageCustomTypeURN = (uint64_t)dlsym(v1, "kCMPhotoCompressionOption_AuxiliaryImageCustomTypeURN");
    if (!gIIO_kCMPhotoCompressionOption_AuxiliaryImageCustomTypeURN)
    {
      int v194 = dlerror();
      printf("  failed to load 'kCMPhotoCompressionOption_AuxiliaryImageCustomTypeURN' [%s]\n", v194);
      ++v2;
    }
    gIIO_kCMPhotoQualityControllerParameter_QualityCFDictionaryRef Value = (uint64_t)dlsym(v1, "kCMPhotoQualityControllerParameter_QualityValue");
    if (!gIIO_kCMPhotoQualityControllerParameter_QualityValue)
    {
      v195 = dlerror();
      printf("  failed to load 'kCMPhotoQualityControllerParameter_QualityValue' [%s]\n", v195);
      ++v2;
    }
    gIIO_kCMPhotoTranscodeOption_ColorConverter = (uint64_t)dlsym(v1, "kCMPhotoTranscodeOption_ColorConverter");
    if (!gIIO_kCMPhotoTranscodeOption_ColorConverter)
    {
      v196 = dlerror();
      printf("  failed to load 'kCMPhotoTranscodeOption_ColorConverter' [%s]\n", v196);
      ++v2;
    }
    gIIO_kCMPhotoTranscodeOption_ColorConverterCallbacCFIndex k = (uint64_t)dlsym(v1, "kCMPhotoTranscodeOption_ColorConverterCallback");
    if (!gIIO_kCMPhotoTranscodeOption_ColorConverterCallback)
    {
      unsigned int v197 = dlerror();
      printf("  failed to load 'kCMPhotoTranscodeOption_ColorConverterCallback' [%s]\n", v197);
      ++v2;
    }
    gIIO_kCMPhotoTranscodeOption_ColorConverterCGColorSpace = (uint64_t)dlsym(v1, "kCMPhotoTranscodeOption_ColorConverterCGColorSpace");
    if (!gIIO_kCMPhotoTranscodeOption_ColorConverterCGColorSpace)
    {
      uint64_t v198 = dlerror();
      printf("  failed to load 'kCMPhotoTranscodeOption_ColorConverterCGColorSpace' [%s]\n", v198);
      ++v2;
    }
    gIIO_kCMPhotoTranscodeOption_ColorConverterUserPointer = (uint64_t)dlsym(v1, "kCMPhotoTranscodeOption_ColorConverterUserPointer");
    if (!gIIO_kCMPhotoTranscodeOption_ColorConverterUserPointer)
    {
      uint64_t v199 = dlerror();
      printf("  failed to load 'kCMPhotoTranscodeOption_ColorConverterUserPointer' [%s]\n", v199);
      ++v2;
    }
    gIIO_kCMPhotoTranscodeOption_ColorConverterVersion = (uint64_t)dlsym(v1, "kCMPhotoTranscodeOption_ColorConverterVersion");
    if (!gIIO_kCMPhotoTranscodeOption_ColorConverterVersion)
    {
      uint64_t v200 = dlerror();
      printf("  failed to load 'kCMPhotoTranscodeOption_ColorConverterVersion' [%s]\n", v200);
      ++v2;
    }
    gIIO_kCMPhotoTranscodeOption_IncludeAuxiliaryImages = (uint64_t)dlsym(v1, "kCMPhotoTranscodeOption_IncludeAuxiliaryImages");
    if (!gIIO_kCMPhotoTranscodeOption_IncludeAuxiliaryImages)
    {
      unint64_t v201 = dlerror();
      printf("  failed to load 'kCMPhotoTranscodeOption_IncludeAuxiliaryImages' [%s]\n", v201);
      ++v2;
    }
    gIIO_kCMPhotoTranscodeOption_IncludeMetaCFDataRef data = (uint64_t)dlsym(v1, "kCMPhotoTranscodeOption_IncludeMetadata");
    if (!gIIO_kCMPhotoTranscodeOption_IncludeMetadata)
    {
      v202 = dlerror();
      printf("  failed to load 'kCMPhotoTranscodeOption_IncludeMetadata' [%s]\n", v202);
      ++v2;
    }
    gIIO_kCMPhotoTranscodeOption_IncludeThumbnail = (uint64_t)dlsym(v1, "kCMPhotoTranscodeOption_IncludeThumbnail");
    if (!gIIO_kCMPhotoTranscodeOption_IncludeThumbnail)
    {
      uint64_t v203 = dlerror();
      printf("  failed to load 'kCMPhotoTranscodeOption_IncludeThumbnail' [%s]\n", v203);
      ++v2;
    }
    gIIO_kCMPhotoTranscodeOption_PreferSoftwareEncode = (uint64_t)dlsym(v1, "kCMPhotoTranscodeOption_PreferSoftwareEncode");
    if (!gIIO_kCMPhotoTranscodeOption_PreferSoftwareEncode)
    {
      char v204 = dlerror();
      printf("  failed to load 'kCMPhotoTranscodeOption_PreferSoftwareEncode' [%s]\n", v204);
      ++v2;
    }
    gIIO_kCMPhotoTranscodeOption_PreserveAndModifyGainMap = (uint64_t)dlsym(v1, "kCMPhotoTranscodeOption_PreserveAndModifyGainMap");
    if (!gIIO_kCMPhotoTranscodeOption_PreserveAndModifyGainMap)
    {
      CFDataRef v205 = dlerror();
      printf("  failed to load 'kCMPhotoTranscodeOption_PreserveAndModifyGainMap' [%s]\n", v205);
      ++v2;
    }
    gIIO_kCMPhotoTranscodeOption_ReplacementImageunint64_t Properties = (uint64_t)dlsym(v1, "kCMPhotoTranscodeOption_ReplacementImageProperties");
    if (!gIIO_kCMPhotoTranscodeOption_ReplacementImageProperties)
    {
      unsigned int v206 = dlerror();
      printf("  failed to load 'kCMPhotoTranscodeOption_ReplacementImageProperties' [%s]\n", v206);
      ++v2;
    }
    gIIO_kCMPhotoTranscodeOption_RestrictedTranscoding = (uint64_t)dlsym(v1, "kCMPhotoTranscodeOption_RestrictedTranscoding");
    if (!gIIO_kCMPhotoTranscodeOption_RestrictedTranscoding)
    {
      uint64_t v207 = dlerror();
      printf("  failed to load 'kCMPhotoTranscodeOption_RestrictedTranscoding' [%s]\n", v207);
      ++v2;
    }
    uint64_t result = (uint64_t)dlsym(v1, "kCMPhotoTranscodeOption_Strips");
    gIIO_kCMPhotoTranscodeOption_Strips = result;
    if (!result)
    {
      CFTypeRef v208 = dlerror();
      uint64_t result = printf("  failed to load 'kCMPhotoTranscodeOption_Strips' [%s]\n", v208);
      ++v2;
    }
    if (v2)
    {
      gFunc_CMPhotoGetAPIVersion();
      return (uint64_t)LogError("IIOLoadCMPhotoSymbols", 758, "  ERROR: failed to load %d CMPhoto symbols (APIVersion at compile: %d  -  APIVersion installed: %d)\n");
    }
  }
  else
  {
    dlerror();
    return (uint64_t)LogError("IIOLoadCMPhotoSymbols", 754, "  Failed to load %s  [%s]\n");
  }
  return result;
}